fault tolerant algorithm establish synchrony distribute node algorithm fault model stabilisation initial arbitrary ongoing byzantine fault node deviate protocol arbitrary manner furthermore assume local node progress drift communication bound delay model pulse synchronisation task guarantee eventually node generate local pulse unlabelled logical tick synchronise manner prior achieve exponential improvement stabilisation communicate sublinear algorithm deterministic stabilise node broadcast per exponentially reduce broadcast per retain stabilisation randomise stabilise node broadcast per exponentially reduce stabilisation polylog node broadcast polylog per obtain recursive approach reduce task stabilise pulse synchronisation bound delay model non stabilise binary consensus synchronous model approach introduces logarithmic overhead stabilisation broadcast underlie consensus routine CCS concept theory computation distribute algorithm additional transient fault byzantine fault drift agreement introduction fundamental distribute compute relate timing fault tolerance distribute inherently asynchronous convenient assume synchrony reliable global distribute vast majority exist integrate VLSI circuit accord synchronous paradigm internal signal distribute throughout chip neatly alternation computation communication establish synchronous abstraction numerous distribute algorithm considerably easy however accuracy availability signal typically assumption error affect behavior unpredictable impossible tackle layer therefore reliably generate distribute joint essential task distribute unfortunately  synchronisation poorly understood pulse synchronisation stabilise byzantine pulse synchronisation achieve synchronisation despite severe fault assume fully message passing node unbounded transient fault anywhere network node faulty exhibit arbitrary ongoing  transient fault arbitrarily corrupt node loss synchrony moreover node remain faulty deviate protocol behave adversarially collude disrupt node misinformation transient fault cease fault communication network fault communication link respective endpoint goal establish synchronisation transient fault cease despite byzantine node algorithm simultaneously stabilise byzantine fault tolerant specifically transient fault cease initial choice faulty node behaviour faulty node bound stabilisation non faulty node generate pulse almost simultaneously correctly operating node skew satisfy specify minimum maximum frequency bound accuracy arbitrary behaviour initial stabilisation phase due transient fault eventually synchronise unlabelled tick non faulty node requirement node estimate progress assume node equip continuous hardware arbitrarily within normalise minimum assume drift bound constant asynchronous communication computation unknown unbounded perfect insufficient ensure relative timing guarantee action node therefore additionally assume node message within journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus execution pulse synchronisation algorithm initial stabilisation phase delimit vertical node generate pulse bound skew accuracy message delay behave adversarially within respective bound summary yield highly adversarial model compute restriction render task infeasible transient fault arbitrary involve entire network ongoing fault arbitrary erroneous behavior node communication link solvable without bound accuracy local communication delay synchronisation cannot achieve without drift unbounded message delay unbounded skew unbounded drift trivial  argument bound pulse frequency maintain background related described greatly simplifies without permanent ongoing fault becomes trivial suffices node designate leader without transient fault straightforward elegant classic guarantee asymptotically optimal skew uncertainty unknown message delay drift equation digital synchronisation communication proceeds synchronous task consistent bound counter abstraction unrealistic model yield conceptual insight pulse synchronisation bound delay model moreover useful assign pulse pulse synchronisation fully fledge contrast relaxed formulation pulse synchronisation challenge impossible seminal article dolev welch otherwise albeit algorithm impractical exponential stabilisation subsequent stabilisation reduce polynomial linear however linear algorithm relies simulate multiple instance synchronous consensus algorithm concurrently communication complexity consensus fundamental primitive fault tolerant compute relevant synchronous binary consensus byzantine fault node input output journal acm vol article publication date august lenzen rybicki agreement exists node validity node termination node eventually terminate obstacle properly initialise stabilisation computation proceeds synchronous compute cycle confines task understand interference byzantine node synchronous consensus extremely survey precisely fault tolerate node message connectivity communication network deterministic algorithm randomise algorithm constant  non trivial bound communication complexity pulse synchronisation linear pulse synchronisation algorithm relies simulate synchronous consensus instance node simultaneously accordingly protocol node broadcast per moreover deterministic consensus crucial failure consensus instance generate output within prespecified bound loss synchrony algorithm fail apparent stabilisation obstacle overcome avoid consensus reduce pulse synchronisation easy task generate resynchronisation roughly uniformly distribute within achieve initiate resynchronisation random combination threshold voting locally checked timing constraint  influence byzantine node simpler consensus randomisation obtain suitable resynchronisation strongly reminds coin exactly core routine constant consensus algorithm contribution framework reduces pulse synchronisation arbitrary synchronous binary consensus routine overhead efficient algorithm solves consensus standard synchronous model compute without stabilisation obtain efficient algorithm solves stabilise pulse synchronisation bound delay model drift upon exist technique approach difference utilise concept resynchronisation pulse generate probabilistically moreover approach inherent bound generate pulse contrast devise recursive scheme allows deterministically generate resynchronisation pulse probabilistically generate resynchronisation pulse construct algorithm generate resynchronisation pulse employ resilience boost filter technique inspire recent digital synchronisation synchronous model motivation gain understand linear communication complexity barrier research pulse synchronisation without distract additional timing uncertainty due communication delay drift challenge newly developed synchronous model bound delay bound drift model journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus summary pulse synchronisation algorithm reference poly det det det rand adversary cannot predict coin flip rand adversary cannot predict coin flip polylog polylog rand private channel poly rand private channel respective algorithm stabilisation broadcast node per denotes algorithm deterministic randomise randomise algorithm stabilise probability fourth indicates additional detail model assumption algorithm tolerate faulty node arbitrary fix constant efficiency recursive approach node participates consensus instance recursion overhead reduction consensus routine constant multiplicative factor complexity concretely complexity increase overall factor apply suitable consensus routine yield exponential improvement complexity deterministic complexity randomise respectively deterministic exponentially reduce node broadcast per retain stabilisation achieve employ phase algorithm construction randomise exponentially reduce stabilisation polylog node broadcast polylog per achieve algorithm  slightly reduces resilience fix constant private communication channel randomise obtain stabilisation polynomial communication complexity optimal resilience assume private communication channel achieve consensus routine feldman micali almost ben pulse synchronisation constant bound randomise algorithm probability additional assumption resilience private communication channel inherit employ consensus routine private communication channel byzantine node decision message knowledge algorithm input message faulty node probability distribution independent internal randomness node adversary indirectly randomness adversary framework impose additional assumption stabilisation guaranteed recursive framework underlie consensus routine succeed within prespecified bound constantly prior summarise regardless employ consensus routine achieve skew maximum message delay optimal model overly pessimistic sum communication computation delay journal acm vol article publication date august lenzen rybicki skew asymptotically optimal remark combine algorithm achieve bound without affect confident technique apply algorithm propose finally algorithm drift parameter node drift comparison cheap  oscillator achieve hardness pulse synchronisation beyond immediate improvement complexity algorithm pulse synchronisation framework employ consensus algorithm prof pulse synchronisation essentially easy synchronous consensus without requirement stabilisation timing uncertainty apart possibility future improvement consensus algorithm  fundamental pulse synchronisation synchronous consensus due various bound impossibility consensus mention earlier positive immediately imply technique optimal however speculate pulse synchronisation synchronous approximate agreement precise synchronisation pulse node approximate agreement deterministically logc input negative possibility currently explicitly consensus leverage technique likely consensus algorithmic technique insight PRELIMINARIES model computation introduce notation subsequent formally define pulse synchronisation resynchronisation notation denote positive integer define shorthand finally non negative notation interval interval finally reference throughout assume global reference available node distribute reference behaviour strictly increase  reference local perceive reference indicates local drift satisfies measurement elapse factor apart journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus bound delay model bound delay message passing model distribute computation model fully network node  denotes node assume node unique identifier node local maximum drift global constant assume node cannot directly local instead local timeouts predetermine node request signal  node local timeout communication assume sender authentication node distinguish sender message receives incoming communication link label identifier sender unlike fully synchronous model communication computation proceeds lock node model message associate delay simplicity assume maximum delay constant assume  constant offset reading due discrete model increase assume transient fault arbitrarily corrupt entire formally define entail model transient fault cease assume node remain byzantine faulty arbitrary behaviour necessarily protocol denote arbitrary faulty node node algorithm configuration execution algorithm assume node executes finite machine transition node recently message local timeouts formally algorithm tuple finite subset trigger pulse finite message finite timer transition function message function explain detail evolves algorithm local configuration timer timeouts local configuration node consists input channel local timer recall assume transient fault arbitrary entail node initial arbitrary shorthand timer timer node expires expire timer transition node expire timer journal acm vol article publication date august lenzen rybicki expire  expire otherwise input channel node update due message local timer expires node update node prior computation node transition remark definition allows possibility transition arbitrary succession however algorithm constant transition constant computational delay treat interpret communication delay convenience define predicate transition otherwise node transition reset timer accordingly timer define max treset treset treset recent node reset timer treset max treset unless treset exception arbitrary initial timer reset treset  timer indicates pas local node timer expires involve definition timer behave achieve owe requirement stabilisation communication node sends message node moreover node broadcast message sends message bound delay message destination immediately model communication delay function  strictly increase function  input channel node satisfy  otherwise message faulty nodev decides transmit node assume adversary freely communication delay function  adversary node faulty node message node traverse maximum delay bound intuitively denotes recent message node node transient fault arbitrarily corrupt communication channel assume arbitrary  adversary execution fix algorithm assume adversary chooses faulty node initial local configuration local message delay function  message faulty node journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus algorithm deterministic adversary choice execution local configuration randomisation consensus subroutine brevity postpone discussion randomisation obtain utilise randomise consensus routine remark minor adjustment definition precise model randomness adversary however affect framework oblivious employ consensus routine operates logical machine slide memory buffer presentation algorithm machine formalism instead machine transition timer expiration slide memory buffer described formalism straightforward implement additional local timer formally logical identify logical surjective projection onto equivalence logical addition associate timer logical equivalence employ slide buffer algorithm slide buffer node message within node local local configuration node arbitrary content slide buffer guaranteed valid buffer contains message message interval reference vice versa sends  buffer guaranteed message interval reference algorithm slide buffer remove message currently buffer node slide buffer buffer contains message pulse synchronisation algorithm pulse synchronisation task node locally generate pulse almost synchronise fashion despite arbitrary initial presence byzantine faulty node addition pulse node generates pulse moreover denote node generates kth pulse exists stabilise onwards min accuracy bound separation generate pulse node generate pulse interval kth pulse node apart node subsequent pulse apart resilient pulse synchronisation algorithm skew accuracy stabilisation choice adversary exists stabilises onwards scenario illustrate journal acm vol article publication date august lenzen rybicki execution resynchronisation algorithm eventually node generate pulse within node refrain generate pulse finally pulse synchronisation algorithm pulser accuracy bound satisfy skew denote maximum node sends channel per execute algorithm resynchronisation algorithm pulse synchronisation algorithm resynchronisation pulse facilitate stabilisation  pulse resynchronisation algorithm weak variant pulse synchronisation guarantee eventually node generate resynchronisation pulse almost synchronously silence resynchronisation pulse behaviour arbitrary illustration formally resilient resynchronisation algorithm skew separation stabilises choice adversary exists node locally generates resynchronisation pulse resynchronisation pulse resynchronisation pulse impose restriction node outside interval spurious resynchronisation pulse outside interval denote maximum node sends channel per execute synchronous consensus routine rely synchronous consensus algorithm briefly define synchronous model computation sake completeness synchronous model computation proceeds discrete node access global node message message perform local computation update synchronous binary consensus assume private input fix initial stabilisation compute output journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus however byzantine faulty node resilient synchronous consensus routine complexity guarantee agreement exists validity termination decides terminates denote maximum sends node execution transformation framework contribution modular framework allows non stabilise synchronous consensus algorithm stabilise pulse synchronisation algorithm bound delay model transformation yield overhead communication complexity construction relatively involve opt fashion theorem corollary auxiliary theorem later discus auxiliary establish formally definition definition consensus routine function satisfy increase synchronous consensus routine exists synchronous consensus routine node resilient node terminates node sends node per technical consensus routine obtain pulse synchronisation algorithm additional overhead emphasise algorithm assume stabilise theorem synchronous consensus routine exists resilient pulser stabilisation channel per satisfy sum empty deterministic phase algorithm synchronous consensus routine satisfy requirement phase algorithm node communicate broadcast information node additional communication framework satisfies derive pulser moreover phase protocol achieves optimal resilience constant journal acm vol article publication date august lenzen rybicki message asymptotically optimal complexity immediately yield corollary deterministic resilient pulser node stabilises node broadcast per employ randomise consensus algorithm framework straightforward summarise related randomise pulse synchronisation algorithm detail later apply construction  randomise consensus algorithm  efficient randomise pulse synchronisation algorithm corollary suppose private channel constantÎµ randomise resilient polylog pulser node stabilises polylog node broadcast polylog per utilise constant protocol feldman micali chernoff bound readily implies stabilisation expectation probability corollary suppose private channel randomise resilient pulser node stabilises ino node broadcast poly per proof theorem proof inductive approach inductive assume pulse synchronisation algorithm resilience construct via hoop discus later pulse synchronisation algorithm resilience formalise technical lemma later lemma define suppose exists resilient pulser node accuracy satisfy sufficiently constant resilient consensus routine network node message exists pulser node resilience stabilises max sends max channel per skew accuracy bound satisfy theorem relatively straightforward consequence lemma theorem synchronous consensus routine exists resilient pulser stabilisation journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus channel per satisfy sum empty proof induction trivial algorithm arbitrary node designate leader generates pulse  local whenever leader node pulse node within node pulse leader generate pulse locally obtain pulser stabilises sends message without fault consensus communication inductive suppose exists resilient pulser algorithm node sufficiently constant apply lemma guarantee yield resilient pulser node stabilisation max constant increase similarly bound lemma induction assumption max constant increase auxiliary lemma ingredient pulse synchronisation algorithm stabilisation mechanism trigger resynchronisation pulse journal acm vol article publication date august lenzen rybicki resynchronisation algorithm latter ingredient formalise theorem proven respectively theorem suppose network node exists resilient synchronous consensus algorithm resilient resynchronisation algorithm skew sufficiently separation tolerates drift node per channel exists constant sufficiently exists resilient pulse synchronisation algorithm node skew satisfies accuracy bound stabilises node per channel apply theorem suitable consensus resynchronisation algorithm rely consensus algorithm prior construct efficient resynchronisation algorithm combine pulse synchronisation algorithm resilience obtain resynchronisation algorithm resilience theorem define sufficiently constant exists  exists pulse synchronisation algorithm node resilience skew accuracy bound exists resynchronisation algorithm node resilience skew separation generates resynchronisation pulse max node max per channel suitable consensus algorithm readily combine theorem obtain lemma theorem therefore reduce construct resilient pulse synchronisation algorithm algorithm tolerate fault recurse illustrates algorithm interleave proof lemma proof theorem sufficiently exists resynchronisation algorithm skew separation node resilience stabilises max max node max per channel journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus recursively building resilient pulse synchronisation algorithm node construction utilises resilience pulse synchronisation algorithm resilience resynchronisation algorithm obtain highly resilient pulse synchronisation algorithm consists trivial resilient pulse synchronisation algorithm node respectively resilient resynchronisation algorithm node theorem resynchronisation algorithm synchronous consensus algorithm obtain pulse synchronisation algorithm via theorem resilient pulse synchronisation algorithm node trivial resilient algorithm obtain resilient resynchronisation algorithm node resilient consensus algorithm obtain pulse synchronisation algorithm node node node faulty node faulty node respective algorithm correctly hence arbitrary output theorem yield pulse synchronisation algorithm claimed application theorem increase stabilisation additional per channel organisation remainder article dedicate remain detail omit namely describes byzantine tolerant pulse synchronisation algorithm  utilise algorithm serf introduction notation style proof proof theorem proof theorem extends framework randomise consensus algorithm establishes corollary byzantine tolerant pulse synchronisation non stabilise pulse synchronisation algorithm utilise later construction stabilise algorithm algorithm variant byzantine fault tolerant synchronisation algorithm   avoids transmit favour unlabelled pulse journal acm vol article publication date august lenzen rybicki execution non stabilise pulse synchronisation algorithm initialisation signal pulse synchronisation without stabilisation previously mention stabilisation however instead assume synchronous devise algorithm node synchronously generate pulse node initialisation signal within later generate initialisation signal stabilise manner initialisation signal node arbitrary behaviour node signal node signal synchronously generate pulse suppose node initialisation signal node execute algorithm bound possibly non constant node receives initialisation signal immediately transition reset purpose consistently initialise local memory node initialisation signal node arbitrary behaviour later repeatedly algorithm subroutine stabilise algorithm possibility message earlier possibly corrupt instance transit node execute previous instance incorrect initialisation signal easily overcome sufficient local guarantee node transition message transition clearing memory buffer ensures obsolete information previous instance node goal establish theorem theorem node receives initialisation signal exists pulse synchronisation algorithm node resilience generate pulse initialisation signal skew accuracy bound node broadcast per description algorithm algorithm illustrate denote logical reset propose pulse machine node reset initialisation phase algorithm journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus machine non stabilise pulse synchronisation algorithm transition guard respective satisfied label transition guard involve local timer expires node sufficiently message node propose communication occurs node transition propose happens node broadcast information others notation indicates expiration timer reset transition local transition label propose indicates node slide message buffer transition reset pulse node forgets propose previous iteration algorithm assumes interval node transition reset initialisation phase algorithm eventually node transition pulse within execute algorithm whenever node transition pulse generates local pulse constraint impose timeouts node initialisation signal denote transition label transition guard transition notation denotes timer expire guard satisfied label propose node transition designate memory buffer immediately throughout denote node propose message clearing memory buffer purpose analysis denote node propose message clearing slide buffer moreover without loss generality assume slide buffer infinite message expire unless buffer explicitly transition constraint impose timeouts expression propose message denotes simplicity assume description node transition logical broadcast node constant logical per node algorithm node undergo constant transition constant broadcasting information per closer inspection reveals per iteration cycle suffices relevant information node propose algorithm analysis algorithm relies heavily faulty node allows vote technique node receives propose journal acm vol article publication date august lenzen rybicki non stabilise pulse synchronisation algorithm recall parameter algorithm message node originate node interval message positive delay furthermore node propose message vote technique transition propose pulse suppose node node transition pulse node propose guard implies node transition propose node remain propose guard eventually satisfied node technique transition propose initialisation phase algorithm remark suppose assume message buffer interval transition pulse node transition pulse otherwise lemma exists proof node receives initialisation signal treset transition reset reset node transition tstart treset treset timer guard expires constraint tstart treset tstart moreover transition propose tpropose tstart tstart guard satisfied hence transition propose later tstart treset tpropose minimal node transition propose transition reset node message buffer transition reset tstart tpropose tpropose slide memory buffer contains message node node propose message node tpropose tpropose guard guard constraint previous bound  tstart  hence timeT memory buffer transition pulse  tpropose hence node transition journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus pulse  propose message node meeting guard min  minimal node transition pulse remains argue  constraint node memory buffer node transition pulse guard satisfied node propose message node clearing memory buffer tstart message tpropose already  constraint node reset propose flag transition propose  imply guard satisfied   claimed fix previous lemma node define inf   inf node generates pulse lemma exist proof induction  directly lemma inductive suppose transition  guard moreover constraint  node transition propose implies node receives propose message node tpropose node transition propose tpropose guard constraint  tpropose therefore exists  node  tpropose hence propose message tpropose guard transition pulse yield  inf already establish argument lemma tpropose propose message trigger guard node guard satisfied imply theorem node receives initialisation signal exists pulse synchronisation algorithm node resilience generate pulse initialisation signal skew accuracy bound node broadcast per journal acm vol article publication date august lenzen rybicki proof constraint satisfied lemma exists node generate pulse interval apply lemma node generate ith pulse interval observation node communicate transition propose guard node fort reference transition propose generate pulse hence node broadcast  pulse synchronisation resynchronisation algorithm synchronous consensus routine devise stabilise pulse synchronisation algorithm obtain theorem suppose network node exists resilient synchronous consensus algorithm resilient resynchronisation algorithm skew sufficiently separation tolerates drift node per channel exists constant sufficiently exists resilient pulse synchronisation algorithm node skew satisfies accuracy bound stabilises node per channel overview ingredient pulse synchronisation algorithm consists machine parallel machine responsible pulse generation auxiliary machine assist initiate consensus instance stabilisation machine indicates pulse generate handle communication node message simulated consensus instance latter handle auxiliary machine transition machine series threshold vote local timeouts signal auxiliary machine aim devise stabilise algorithm auxiliary machine arbitrarily initialise handle stabilisation mechanism conjunction ensure regardless initial node eventually manage synchronise journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus construct stabilise SS byzantine fault tolerant pulse synchronisation algorithm bound delay model BD byzantine fault tolerant non stabilise pulse synchronisation algorithm synchronous consensus algorithm resynchronisation algorithm algorithm node resynchronisation algorithm eventually output resynchronisation pulse reset stabilisation mechanism auxiliary machine auxiliary machine simulates execution simulation initiate due node transition machine resynchronisation pulse machine generates pulse consensus instance output stabilise guarantee initialisation consensus algorithm auxiliary machine machine stabilisation mechanism relies subroutine summarise resynchronisation algorithm non stabilise pulse synchronisation algorithm synchronous consensus algorithm resynchronisation pulse recall resynchronisation algorithm solves weak variant pulse synchronisation guarantee eventually within bound node generate resynchronisation pulse resynchronisation pulse generate algorithm generate pulse arbitrary frequency necessarily node nevertheless node bound generate resynchronisation pulse rough synchrony leverage cleanly initialise stabilisation mechanism somewhat initialisation signal incoming initialisation signal resynchronisation pulse summarise assume throughout node receives resynchronisation pulse another resynchronisation pulse sufficiently later later devise efficient algorithm resynchronisation pulse simulate synchronous consensus subroutine conjunction variant   pulse synchronisation algorithm described simulate synchronous consensus algorithm bound delay model pulse synchronisation algorithm stabilise properly nonfaulty node initialise algorithm within interval assume node initialise non stabilise pulse synchronisation algorithm within apart straightforward simulate synchronous journal acm vol article publication date august lenzen rybicki machine node transition pulse generate local pulse pulse message node node transition broadcast message node guard employ slide memory buffer pulse message within local node transition pulse reset local timeout expires guard guard become satisfied similarly timer twait reset node transition expires guard satisfied node transition recover node transition pulse guard satisfied output signal auxiliary machine algorithm pulse generate indicates synchronous algorithm delay pulse ensure node execute local computation synchronous algorithm message related pulse occurs employ consensus utilise consensus routine construction consensus routine satisfy exactly consensus routine validity agreement termination addition node message execution node input definition consensus consensus routine execution node input node message synchronous consensus routine convert consensus routine essentially prior exists transformation induces overhead algorithm theorem consensus protocol transform consensus protocol moreover resilience message without loss generality assume throughout consensus routine moreover introduce asymptotic loss communicate construction strategy construction resynchronisation algorithm parallel stabilise pulse synchronisation algorithm devise resynchronisation algorithm resynchronisation signal generates pulse synchronisation algorithm pulse synchronisation algorithm consists machine auxiliary machine auxiliary machine responsible generate output signal machine guard guard journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus auxiliary machine auxiliary machine responsible initialise simulate consensus routine denote simulation consensus routine transition node locally  non stabilise pulse synchronisation algorithm instance node transition input consensus routine node transition input consensus simulation declares output node transition output output respective output signal machine immediately timeouts tlisten tconsensus reset node transition respective guard refer timeout tactive guard dash reset resynchronisation signal underlie resynchronisation algorithm input input loop activate guard satisfied guard satisfied timer reset auxiliary machine employ consensus routine facilitate agreement node pulse consensus simulation output node auxiliary machine signal machine generate pulse otherwise consensus instance output signal something node detect stabilise carefully construction stabilises consensus instance node guaranteed output node assumption initial arbitrary non trivial construction node synchronise simulate consensus jointly resynchronisation algorithm algorithm stabilises node stuck recovery recover latter resynchronisation pulse node synchronously reset local timeout timeout expires node recover consensus instance input happens journal acm vol article publication date august lenzen rybicki algorithm already stabilise node recover node recover jointly consensus instance output validity consensus routine stabilisation guaranteed resynchronisation signal resynchronisation signal straightforward node receives resynchronisation signal underlie resynchronisation algorithm node reset local timeout tactive auxiliary machine upon expiration timeout guard auxiliary machine activate node recover machine machine responsible generate pulse operates node pulse generates local pulse sends pulse message node suppose node transition pulse node pulse observes node generate pulse within guard node generate pulse synchronise fashion happens guard ensures node proceeds suggests generate pulse ensure pulse obey desire frequency bound otherwise node node synchronise transition pulse recover guard node recover consensus algorithm output guard satisfied transition pulse simulation consensus handle auxiliary machine discus node consensus sufficiently node transition within stabilise node transition almost synchronously hence stabilisation node input consensus instance node transition node node observes longer consensus simulation operation stabilise transition recover consensus instance output node something transition recover stabilisation phase node transition recover refrain input consensus routine local timeout tactive expires refer discussion auxiliary machine stabilises behaviour machine guard guard satisfied implies node alternate pulse stabilise operation node transition pulse within node transition pulse within ensure guard satisfied node transition within correctly initialise simulation consensus algorithm input node transition synchronise fashion auxiliary machine node remain guard guard become satisfied journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus finally ensure stabilisation node remain machine longer properly initialise simulate consensus instance achieve twait timeout guard due validity consensus routine node input entail guard satisfied guard node transition pulse within auxiliary machine auxiliary machine slightly involve however node node transition consistent operation consensus routine node assume node participate simulation consensus consensus algorithm output node node transition hence stabilise consensus algorithm output node transition recently operates correctly consensus simulation succeed output node implement auxiliary machine suppose node local timeout tactive expire recall tactive reset resynchronisation signal node remains node transition machine happens guard satisfied node transition node observes node transition node node node transition node node observes node transition later node stabilise happens guard eventually satisfied node transition input node willing input simulation consensus unless recover machine guard becomes satisfied transition input insists input consensus simulation node transition input input remain local timeout expires guard guard guard however guard becomes satisfied node input local timeout reset guard becomes satisfied input node node stabilise reset timeout ensure node jointly consensus instance guarantee simulation guard satisfied node roughly reset timeout node currently simulate consensus instance critical proof stabilisation journal acm vol article publication date august lenzen rybicki outline proof difficulty achieve stabilisation ensure simulation consensus routine despite arbitrary initial transient fault cease node attempt execute consensus whereas moreover node simulate consensus simulate consensus routine  cannot indefinitely argument node attempt input consensus node transition machine lemma node node initialise consensus instance input node transition interval node transition lemma node cannot transition node attempt input consensus node initialise consensus instance within lemma node initialise consensus instance within node participate consensus instance successfully simulate entire execution lemma timeout sufficiently ensure consensus instance consensus instance initialise input node properly simulate execution consensus routine node attempt instance consensus establish easy synchronisation establish persists specifically argue node transition pulse apart node initialise consensus instance within input lemma stabilises node eventually generate pulse skew accordingly substantial proof argue node eventually transition pulse within bound eventually interval node simultaneously recover timeout tactive expires node guard auxiliary machine becomes satisfied node consensus instance input initialise within lemma node attempt input interval node recover timeout tactive expires node node eventually transition pulse within lemma node attempt input interval node recover timeout tactive expires node lemma latter argument guarantee stabilisation corollary corollary finally argue timeouts employ construction argument constraint related timeouts summarise lemma satisfied proceed formalise argument detail structure proof summarise journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus timeout employ construction tlisten tlisten tlisten tconsensus max tlisten max tlisten tactive tconsensus twait tconsensus tactive tlisten tlisten twait tactive tconsensus tlisten twait tconsensus overall structure proof theorem bold rectangle denote informally analyse machine arbitrary initial content slide message buffer remark max tlisten slide memory buffer guard guard guard valid content buffer guard contains message message similarly guard guard interval tlisten without loss generality assume moreover assume node resynchronisation signal interval journal acm vol article publication date august lenzen rybicki content message buffer valid node reset  timeout hence timeout tactive expires node tactive tactive denote maximum simulation consensus routine employ non stabilise pulse synchronisation algorithm assume consensus routine theorem convert consensus routine without asymptotic loss highlight useful simulation scheme implement auxiliary machine remark node transition node remains respective node execute node leaf respective halt simulation tconsensus node transition input auxiliary machine node transition machine rough synchrony lemma suppose node transition input tlisten tlisten transition proof transition input distinct message within tlisten satisfy guard message node minimal tlisten transition node transition interval node transition transition lemma suppose node transition tactive transition proof transition node transition pulse interval message node denote node node node transition pulse transition recover transition transition pulse satisfy guard guard guard guard input input respectively assumption guard satisfied tactive option timeout expire pulse conclude transition pulse activate guard transition previous lemma node transition input auxiliary machine node eventually  participates consensus instance node  underlie   pulse synchronisation algorithm within interval journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus lemma suppose node transition input tlisten tactive transition tlisten moreover guard cannot satisfied node minv proof lemma exists transition tlisten implies guard guard becomes satisfied tlisten transition input input input input transition due guard activate reset local timer moreover tlisten tlisten node transition input input guard guard becomes activate transition node remains input input interval none guard guard guard satisfied local timer expires moreover apply lemma transition interval tlisten recall cannot transition pulse without transition tlisten constraint recover tlisten node transition tlisten transition pulse satisfy guard transition output timeout expire already tlisten definition node transition pulse tlisten conclude guard cannot satisfied interval lemma proceed transition lemma transition observation tlisten node    algorithm locally simulation algorithm remark simulation hence remains simulation output recall reset timeout tlisten tlisten tlisten reset satisfy guard interval expires transition max tlisten constraint happens tlisten claimed node initialise instance   pulse synchronisation algorithm within interval node  participates successfully completes simulation consensus routine lemma suppose exists node transition minimal transition journal acm vol article publication date august lenzen rybicki output output guard satisfied tconsensus transition output output termination agreement transition output validity proof transition sends initialisation signal non stabilise   algorithm described algorithm node simulate consensus algorithm node enters input otherwise enters input theorem implies node initialise   algorithm within apart simulation moreover node declare output hence declare output within skew pulse simulation auxiliary machine guard satisfied timer tconsensus expire node simulation node simulated declare output assumption guard cannot satisfied prior node timer tconsensus reset hence cannot expire earlier tconsensus constraint hence simulation succeed simulation consensus routine completes guard guard satisfied nodev hence transition output output lemma agreement validity consensus routine node transition pulse within node remain synchronise skew accuracy bound stabilises lemma suppose exists interval exists tconsensus  proof node transition pulse node transition auxiliary machine node transition output auxiliary machine satisfy guard pulse furthermore happens node transition immediately output auxiliary machine transition initiate another consensus instance transition output hence constraint ensures node message node slide buffer cannot transition recover guard constraint assumption transition pulse node observes pulse message node node pulse message node satisfy guard hence node transition interval remains guard guard activate denote transition output output exists minv guard cannot activate min twait journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus auxiliary machine node node transition pulse interval tlisten constraint guard guard become satisfied interval node transition input interval guard active recover imply min twait constraint constraint guard cannot become active yield transition guard become active transition constraint assume otherwise transition however remark twait tconsensus constraint constraint constraint constraint node transition transition output spending constraint pulse therefore apply lemma yield tconsensus  transition output auxiliary machine trigger transition pulse machine ensure stabilisation node eventually generate pulse skew pulse synchronisation routine stabilises bound stabilisation within interval node simultaneously recover machine auxiliary machine eventually timeout tactive expires allows passive stabilisation mechanism activate timer tactive expire node stabilise lemma lemma tactive minv  suppose node node recover guard satisfied tactive tconsensus transition pulse proof guard satisfied  guard satisfied node leaf tlisten tactive activate guard remains recover interval tactive tactive minimal guard becomes satisfied node simulation algorithm remark transition away tactive tactive constraint conclude transition output pulse tactive therefore transition tactive tactive recall guard satisfied hence apply lemma interval imply transition output transition recover pulse finally lemma guarantee tconsensus tactive tconsensus journal acm vol article publication date august lenzen rybicki establish series lemma apply lemma directly conjunction lemma guarantee stabilisation remainder define abbreviation tlisten twait tactive tconsensus tlisten tconsensus tlisten remark tactive inequality equivalent constraint interval timeouts distinguish stabilisation ensure node transition input node transition input correspond proof strategy described occurs node recover passive stabilisation mechanism guarantee stabilisation timer tactive expires latter happens constraint satisfied consensus instance processor ensure node pulse generate output stabilise output everyone transition recover analyse node transition input interval lemma suppose node transition input exists tactive satisfies recover guard satisfied minw proof constraint tactive apply lemma due constraint apply lemma tlisten yield tlisten tconsensus tactive transition output output output auxiliary machine output transition output implies guard activate transition pulse output guard implies remains transition recover moreover node immediately transition auxiliary machine finally lemma guard cannot satisfied corollary suppose node transition input exists tactive tconsensus satisfies proof apply lemma lemma immediately apply lemma journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus attention node transition input interval lemma transition input transition twait proof transition pulse twait transition recover interval guard satisfied recover guard satisfied hence transition output auxiliary machine however node transition input input auxiliary machine twait recover machine guard cannot satisfied conclude node transition interval twait guard cannot satisfied exists interval node simulate consensus instance lemma suppose guard satisfied interval exists nov proof guard cannot satisfied tactive node assumption guard satisfied interval proceed via analysis suppose guard guard cannot satisfied node remains moreover leaf transition hence cannot transition guard guard guard satisfied cannot hence execution tlisten timer cannot reset interval tlisten transition input input guard cannot satisfied hence transition input input interval tlisten cannot transition interval tlisten moreover transition tlisten transition away tlisten tconsensus guard guard become satisfied therefore nodev input input tlisten tconsensus apply constraint tlisten tconsensus tlisten hence tlisten tconsensus interval precondition previous lemma satisfied due lemma exists twait twait guard satisfied proof twait twait  transition exist trivially twait otherwise journal acm vol article publication date august lenzen rybicki tlisten twait tactive constraint apply lemma yield transition tlisten tlisten guard satisfied statement infer node transition input implies node transition pulse subsequently conclude precondition lemma satisfied lemma suppose transition input transition pulse proof apply lemma obtain interval twait guard cannot satisfied apply lemma interval yield interval implies node consensus instance interval moreover message prior consensus instance transit node attempt simulate consensus instance later  simulation transition apply lemma transition interval twait node attempt simulate simulation transition entail node attempt simulate input consensus routine definition entail message related unless receives node absence message terminate output conclude transition output transition pulse machine transition output auxiliary machine lemma suppose nov transition pulse  recover machine auxiliary machine moreover guard satisfied minv  proof transition pulse guard guard recover precisely recover machine twait guard satisfied tlisten tactive guard cannot active interval auxiliary machine tlisten tconsensus lemma guard cannot satisfied transition node occurs cannot node transition pulse guard constraint input transition node recover machine tactive timeout expires node eventually activate guard node simulation input corollary suppose transition input exists tactive tconsensus transition pulse proof lemma lemma prerequisite lemma satisfied tactive journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus remains constraint satisfied timeouts lemma constraint satisfied timeouts proof recall consensus routine declare output simulate consensus routine  tactive chosen constant later tlisten max tconsensus twait tconsensus tactive immediately satisfy constraint constraint constraint constraint constraint moreover constraint  sufficiently constant remain constraint denote sufficiently constant subsume abbreviate consensus max  non constant tconsensus satisfy constraint constraint constraint sufficient guarantee consensus consensus consensus consensus inequality automatically satisfied satisfy inequality imply assume thatt consensus rearrange remain inequality yield recall constant constant hence inequality satisfied inequality andc constant imply timeouts desire corollary suitably chosen timeouts execution exists transition pulse interval proof timeouts accordance lemma nov transition input corollary yield otherwise node transition input interval corollary journal acm vol article publication date august lenzen rybicki accuracy bound within constant factor apart corollary constant obtain accuracy bound satisfy proof lemma accuracy bound  tconsensus timeouts proof lemma arbitrarily constant inequality sufficiently proof theorem finally theorem theorem suppose network node exists resilient synchronous consensus algorithm resilient resynchronisation algorithm skew sufficiently separation tolerates drift node per channel exists constant sufficiently exists resilient pulse synchronisation algorithm node skew satisfies accuracy bound stabilises node per channel proof resynchronisation algorithm resynchronisation pulse occurs within happens corollary node transition pulse lemma algorithm stabilises skew corollary accuracy bound within factor apart without affect stabilisation asymptotically analyse per machine communicates node transition pulse encode message moreover node remains pulse machine sends  per auxiliary machine communicate apart message related simulation consensus non stabilise pulse synchronisation  sends message node generates pulse pulse simulate node broadcast per resynchronisation ALGORITHMS component proof theorem pulse synchronisation algorithm network resilience obtain resynchronisation algorithm network resilience precisely theorem theorem define journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus sufficiently constant exists  exists pulse synchronisation algorithm node resilience skew accuracy bound exists resynchronisation algorithm node resilience skew separation generates resynchronisation pulse max node max per channel goal devise stabilise resynchronisation algorithm skew separation node tolerates faulty node algorithm guarantee exists node locally generate resynchronisation pulse interval pulse interval resynchronisation algorithm generate various spurious resynchronisation pulse pulse resynchronisation pulse pulse generate subset node algorithm illustrate resynchronisation algorithm ignore drift suppose source pulse generate pulse fix frequency whenever source generates pulse resynchronisation pulse trigger source generate pulse frequency coprime multiple sufficiently guaranteed eventually source pulse pulse generate source illustration otherwise suppose indicates node observes pulse source generate pulse scheme output variable resynchronisation algorithm  eventually source generates pulse roughly coprime integer multiple constant factor slack drift etc eventually pulse generate source source generate another pulse obviously reliable stabilise pulse source node faulty node effectively pulse synchronisation already however construction relies resynchronisation algorithm avoid chicken partition node instance pulse synchronisation algorithm resilience almost pulse synchronisation algorithm resilience obtain resynchronisation algorithm resilience allows recursively construct resynchronisation algorithm trivial pulse synchronisation algorithm tolerate faulty node obstacle construction cannot guarantee instance resilience correctly fault exceeds tolerate individual instance overcome enlist node instance output satisfy desire frequency bound journal acm vol article publication date august lenzen rybicki resynchronisation algorithm pulse source coprime frequency output logical source dim delimit interval interval correctly operating source generate pulse pulse source approximately whereas pulse source approximately source pulse frequency node input pulse hence output pulse resynchronisation pulse pulse silence faulty source spurious pulse source faulty node observation output faulty source upper spurious input pulse occurs input pulse inconsistently detect node devise construction pulse frequency bound source accepted source fails adhere frequency bound ignore node input pulse ignore pulse source however node spurious pulse adheres frequency bound detect suspicious behaviour node output pulse although node faulty source silence correctly source resynchronisation pulse faulty source ensures node generate output signal within silence output conservatively filter sufficiently voting mechanism happens incorrect output imply fault threshold respective instance exceed accordingly instance operating correctly thanks absence interference faulty instance succeed generate resynchronisation pulse illustrates pulse  overview pulse synchronisation algorithm implement resynchronisation algorithm described partition node pulse synchronisation algorithm journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus node tolerates faulty node stabilises sends per channel skew accuracy bound node execute pulse synchronisation algorithm optimistic approach source pulse node  generate pulse within roughly unfortunately cannot directly pulse synchronisation algorithm reliable source pulse faulty node contains faulty node hence algorithm stabilise generate spurious pulse uncontrolled frequency algorithm generate pulse frequency prevent however guaranteed algorithm stabilises lemma faulty node exists stabilises proof prevent algorithm stabilise fault setV fault setV fault algorithm stabilises node  locally generate pulse skew accuracy bound however algorithm stabilises moreover algorithm forever generate spurious pulse arbitrary frequency spurious pulse refers pulse satisfy skew accuracy bound spurious pulse pulse subset node generate skew pulse occurs tackle employ series threshold vote timeouts filter spurious pulse generate  algorithm violate timing constraint impose frequency  algorithm trigger resynchronisation pulse frequency bound satisfied inconsequential non stabilise algorithm trigger resynchronisation pulse subset node filter scheme eventually satisfy stabilise pulse generate accepted stabilise pulse respect frequency bound accepted precisely filter pulse respect slightly relaxed accuracy bound enforce filter pulse satisfy roughly accuracy bound sufficiently apart node reject pulse generate filter mechanism becomes relatively easy implement conceptual resynchronisation algorithm apply filter mechanism algorithm filter output source pulse algorithm illustrate guaranteed source eventually pulse define accuracy bound furthermore source respect accuracy bound refrain generate pulse source respect accuracy bound  frequency guarantee sufficiently separation resynchronisation pulse otherwise journal acm vol article publication date august lenzen rybicki resynchronisation construction node tolerate fault partition network pulse synchronisation algorithm output fed respective filter pulse filter resynchronisation pulse filter consists node network participate threshold vote anyone pulse node generate pulse pulse accuracy bound respect pulse ignore moreover generates pulse incorrect frequency filter mechanism pulse generate construction resilient resynchronisation algorithm node resilient pulse synchronisation algorithm node node node pulse synchronisation algorithm respectively algorithm guaranteed stabilise eventually faulty node stabilise node filter mechanism output respectively ensure node locally generates resynchronisation pulse without node register apply timeout constraint enforce desire frequency bound exploit unreliable source reliable source generate pulse sufficiently separation filter spurious pulse pulse filter scheme recent construction synchronous counting algorithm however considerable translate approach simpler synchronous model bound delay model drift approach implement filter scheme bound delay model illustrates underlie pulse synchronisation algorithm combine filter mechanism convenience refer node node performs threshold vote journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus observes node generate pulse vote generate resynchronisation pulse node inv vote pulse within accepts node accepts pulse node vote due moreover node observes vote deduce node node generate pulse node accepts pulse generate node aware pulse node perform temporal filter generate pulse node local  timer reset node suspect stabilise pulse accepted voting mechanism resynchronisation pulse trigger met  timer expire recent pulse node reset  timer observes vote pulse vote observes vote vote timely fashion pulse generate pulse whenever trigger resynchronisation pulse nodev node reset  timer trigger resynchronisation pulse furthermore pulse within reset  counter finally node refuse trigger resynchronisation pulse  timer active stabilises eventually  timer expires reset ensures eventually trigger resynchronisation pulse implementation bound delay model implement threshold voting temporal filter machine depict node voter validator machine parallel voter machine fail local signal validator machine feature voter machine voting scheme node transition vote node transition fail guaranteed node transition node vote within implies node node vote slightly node idle transition directly fail node transition bound transition fail validator machine ensures subsequent transition tmin tcool apart moreover fail transition occurs subsequent transition tcool voter machine handle generate fail transition underlie pulse synchronisation algorithm pulse within  essentially transition validator journal acm vol article publication date august lenzen rybicki voter machine machine trigger resynchronisation pulse node voter machine voter machine performs threshold vote ensure node resynchronisation pulse trigger node vote message within  local node immediately transition fail idle guard transition signal validator machine generate resynchronisation pulse refrain  timer expires validator machine machine trigger resynchronisation pulse node validator machine validator fail transition signal voter machine satisfy minimum bound transition timely manner transition ignore reset timer tcool machine accuracy bound tmin tmax  apart furthermore underlie pulse synchronisation algorithm stabilises transition roughly accuracy bound detailed analysis behaviour machine later impose timeouts parameter inequality satisfied timeouts carefully lemma constant exists constant satisfy constraint journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus employ construction tmin tmax tvote tvote   tvote tvote tcool max  tcool tvote   tmin tcool tmin tcool tmax tvote tmin tvote  constant remain timeouts resynchronisation algorithm described ingredient resynchronisation algorithm remains define output resynchronisation algorithm define indicator variable transition node transition otherwise furthermore define output resynchronisation algorithm max trigger resynchronisation pulse node node generates resynchronisation pulse trigger resynchronisation pulse node goal exists node generates resynchronisation pulse neither trigger resynchronisation pulse node however communication overhead incur voter validator machine lemma compute node max per proof broadcast generates pulse locally node assume generates pulse per stabilisation wrapper filter pulse journal acm vol article publication date august lenzen rybicki within constraint interfere pulse behaviour algorithm stabilise addition pulse message straightforward verify node communicate transition idle vote pas voter machine due tvote tmax timeouts node cannot transition within timeouts constraint constraint proof theorem approach theorem delay detailed analysis voter machine later theorem stabilise algorithm stabilise hence voter validator machine operating correctly bound max max tcool max constraint emerge later proof resynchronisation pulse trigger skew tvote desire separation later argue faulty cannot  interfere resynchronisation pulse trigger lemma stabilisation suppose exist  fori  satisfy trigger resynchronisation pulse node resynchronisation pulse trigger roughly node refrain generate resynchronisation pulse sufficiently latter node observes resynchronisation pulse trigger somewhere due threshold voting mechanism reset  counter transition ignore formally capture lemma lemma lemma validator machine exists tvote  tvote tcool  inf lemma proof strategy fix lemma node node succeed resynchronisation pulse separation however possibly faulty spoil resynchronisation pulse trigger resynchronisation pulse node  node filter mechanism journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus guarantee faulty obeys impose frequency constraint pulse node ignore argue resynchronisation pulse generate accordingly assume faulty interferes generates spurious resynchronisation pulse node resynchronisation pulse separation moreover define inf inf furthermore convenience define notation tcool otherwise purpose analysis  chunk integer define tvote tvote abbreviate tmin tmax tvote constraint constraint lemma useful theorem defer proof lemma resynchronisation  tvote tvote corollary proof recall thatr tvote constraint  lemma inequality definition straightforward manipulation interval tvote tvote tvote tvote tvote tvote eventually algorithm output resynchronisation pulse lemma exists max exists satisfy journal acm vol article publication date august lenzen rybicki proof suppose lemma recall tvote otherwise trivially corollary constraint imply tcool constraint similarly fix recall analysis constraint constraint minv satisfies lemma thatt max readily verify constraint theorem define sufficiently constant exists  exists pulse synchronisation algorithm node resilience skew accuracy bound exists resynchronisation algorithm node resilience skew separation generates resynchronisation pulse max node max per channel proof computation corollary lemma sufficiently choice max satisfied assumption algorithm accuracy bound sufficiently satisfy initial assumption precondition lemma journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus compute output lemma resynchronisation algorithm communicate per addition message underlie pulse synchronisation algorithm lemma resynchronisation pulse skew happens max proof lemma eventually trigger resynchronisation pulse accuracy bound goal algorithm stabilise node transition synchronise fashion argue eventually transition couple transition recall pulse synchronisation algorithm skew accuracy bound nodev generates pulse accord algorithm  timeT algorithm stabilise moreover exists satisfies algorithm exist inf generates pulse node ith stabilisation initial pulse node transition fail thereby reset tmax timeouts node pulse lemma suppose node idle local tmax timer expire interval proof timer tmax reset later expire tmax constraint constraint node receives pulse message node   constraint node idle leaf recall node cannot fail node vote pas timeout tvote expires node idle transition within tvote accordingly node reset tmax timer tvote  node pulse message node  respective buffer therefore node transition vote interval implies node vote message node respective buffer timeout    therefore node idle finally node idle   transition idle tvote   tvote   constraint define indicator variable transition node transition otherwise journal acm vol article publication date august lenzen rybicki similarly define inf inf inf minimal node transition voter machine pulse stabilisation ith node transition pulse signal essentially echo pulse lemma tvote moreover node transition fail proof lemma idle guard active within  local constraint node receives pulse message node transition vote node vote message node tvote constraint node transition pas tvote expires transition tvote reset buffer pulse vote message node consequently node idle pulse tmax expires former occurs node earlier  tvote constraint constraint pulse tvote constraint constraint node idle  expire earlier consequently inductively proof define bound tcool guaranteed transition become couple lemma suppose proof node transition validator machine voter machine transition fori ignore argue node eventually validator machine voter machine transition node transition lemma node transition fail utilise node transition hence apply lemma constraint tmin moreover transition fail journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus voter machine hence induction node transition transition ignore tcool node transition hence applies reset tcool timeout remains ignore tcool tcool timer expires transition applies lemma analysis node tcool tcool transition entail transition claimed lemma stabilisation suppose exist  fori  satisfy proof constraint max lemma lemma  minv bound latter constraint proof lemma lemma lemma validator machine exists tvote  tvote tcool  inf lemma analyse voting validator machine behave voter machine roughly synchronise node transition node transition fail within lemma tvote andv  tvote node transition fail interval tvote proof tvote vote message node supposedly another node actually satisfies transition tvote imply vote message node interval tvote hence vote message node interval tvote journal acm vol article publication date august lenzen rybicki minimal node transition vote interval node observation vote message buffer  constraint transition idle node idle transition fail within tvote guard overall node transition fail interval tvote tvote synchronisation lemma validator machine node transition trigger resynchronisation pulse node trigger resynchronisation pulse transition ignore within lemma tvote suppose exists tvote node transition ignore interval tvote proof suppose node transition transition voter machine lemma exists tvote node transition fail interval tvote transition voter machine transition validator machine ignore hence interval node transition ignore transition ignore cannot transition  local tcool lemma implies lemma tvote proof lemma aim lemma hence  define resynchronisation pulse generate couple pulse generate underlie pulse synchronisation algorithm argue faulty respect accuracy bound trigger resynchronisation pulse refrain trigger resynchronisation pulse tcool lemma proof definition hence transition transition therefore transition idle voter machine validator machine cannot transition min tmin tcool local timer tmin tcool expires tmin tcool constraint tmin transition fail local timer tmax expires idle tvote reset upon idle expires idle tmax tlisten node transition fail implies tmax tvote node transition ignore validator machine hence tmax tvote tcool tcool therefore journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus lemma readily lemma resynchronisation  tvote tvote proof  vacuously induction increase assume directly definition lemma apply lemma index induction hypothesis interval tcool tvote tvote proof lemma lemma constant exists constant satisfy constraint  constant remain timeouts proof satisfy constraint  tcool sufficiently depends constant choice tcool satisfies constraint remain timeouts variable constraint easy equality satisfied simultaneously regard constraint  constant furthermore constraint satisfied constant bound constraint  assume constraint satisfied journal acm vol article publication date august lenzen rybicki constraint satisfied tcool yield constraint satisfied tvote remains address constraint constraint constraint inequality constraint equivalent   accordance constraint inequality concern  recall assume yield inequality constraint satisfied inequality trivially satisfied already establish equality inequality constraint equivalent    calculation       similarly    overall conclude constraint satisfied finally assume bound function depends constant constraint satisfied yield satisfy constraint  ALGORITHMS deterministic algorithm framework extends randomise algorithm allows obtain faster algorithm simply replace synchronous consensus algorithm randomise variant randomise consensus algorithm linear bound deterministic algorithm allows construct pulse synchronisation algorithm stabilise sublinear typically randomise consensus relaxes termination suffices algorithm terminates probability probabilistic bound etc complexity however framework operates deterministic termination guarantee algorithm assume declare output journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus therefore instead relax agreement probability formally node input output agreement probability exists node validity node node termination node terminate within modification straightforward lemma lemma randomise synchronous consensus routine terminates expectation deterministically satisfies agreement validity exists randomise synchronous consensus routine deterministically satisfies validity terminates within satisfies agreement probability message resilience proof modify algorithm operates algorithm terminates node node output decision algorithm otherwise node output input deterministically guarantee validity node input algorithm output concern agreement markov bound algorithm terminate node within probability accordingly agreement probability remark construction generates consensus routine regular applies randomise algorithm lemma obtain suitable randomise consensus routine framework framework consensus construction underlie theorem stabilisation constant consecutive consensus instance succeed constant probability individual consensus instance sufficient maintain stabilisation individual stabilisation hierarchy summarise variant theorem corollary suppose network node exist resilient resynchronisation algorithm skew separation sufficiently resilient randomise synchronous consensus algorithm node per channel agreement constant probability exists randomise resilient pulse synchronisation algorithm node  accuracy bound stabilises node per channel underlie pulse synchronisation algorithm construction theorem stabilises resynchronisation algorithm stabilises deterministically consensus randomisation apply linearity expectation recursive theorem generalises corollary randomise synchronous consensus routine satisfies agreement constant probability andt journal acm vol article publication date august lenzen rybicki  exists pulser skew per channel stabilisation satisfy sum empty however randomise algorithm efficient typically additional restriction model adversary predict future random decision naturally restriction apply apply corollary subsequently corollary typical assumption communication via private channel faulty node behaviour function communication node faulty node interval input consensus algorithm obtain pulse synchronisation algorithm efficient respect stabilisation communication randomise consensus algorithm  theorem lemma suppose communication via private channel randomise synchronous consensus routine satisfy algorithm satisfies agreement constant probability algorithm satisfies validity algorithm terminates polylog node polylog constant freely chosen upfront algorithm  actually satisfies bound node imply statement framework node broadcast constant per recursion construction obtain corollary corollary suppose private channel constantÎµ randomise resilient polylog pulser node stabilises polylog node broadcast polylog per trivial boost probability stabilisation repetition algorithm stabilise polylog regardless initial exploit corollary however uniform slowly function useful apply concentration bound probability stabilisation concretely algorithm feldman micali constant regardless translates constant probability algorithm theorem lemma suppose communication via private channel exists randomise synchronous consensus routine satisfy algorithm satisfies agreement constant probability algorithm satisfies validity algorithm terminates broadcast node poly journal acm vol article publication date august stabilise byzantine synchronisation almost easy consensus employ consensus routine constant probability recursion stabilises apply chernoff bound recursive stabilisation yield stabilisation probability corollary suppose private channel randomise resilient pulser node stabilises ino node broadcast poly per CONCLUSIONS stabilise pulse synchronisation byzantine fault achieve efficiently bound delay model bound drift reduces task non stabilise synchronous binary consensus efficiently deterministic algorithm linear stabilisation fault node broadcasting per obtain sublinear algorithm randomisation expense broadcast per conclude highlight construction reduction consensus reduction consensus pulse synchronisation consensus reduction direction complexity pulse synchronisation remains pulse synchronisation strictly easy synchronous consensus reduction fairly complicate efficient algorithm achieve pulse synchronisation stabilise manner technique exist practical non stabilise synchronisation algorithm stabilise