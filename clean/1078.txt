article randomize vega distribute algorithm construct minimum span mst network optimal polylogarithmic factor message complexity algorithm exchange message probability node network hop diameter distribute mst algorithm simultaneously bound message bound apply randomize monte carlo algorithm prior message bound derive completely graph construction exist bound construction bound complement algorithm bound graph construction distribute mst algorithm message CCS concept theory computation distribute algorithm additional distribute algorithm minimum span introduction minimum span mst construction central distribute compute research aim develop efficient distribute algorithm mst thirty seminal article distribute algorithm construct mst logn exchange logn message denote node network respectively message complexity algorithm essentially optimal complexity hence research concentrate improve complexity complexity improve logn chin  improve   bound existentially optimal exist graph till mid ninety identify graph parameter capture complexity distribute network computation exist network hop diameter significantly vertex therefore desirable protocol bound distribute algorithm mst later improve kutten peleg however algorithm message optimal exchange message respectively article synchronous congest model distribute compute standard model distribute compute lack progress improve barrier bound distribute mst peleg  logn distribute algorithm construct mst network diameter logn establishes asymptotic tight optimality algorithm bound peleg  applies deterministic algorithm later bound improve logn randomize monte carlo approximation algorithm summarize distribute mst algorithm exist algorithm optimal message optimal exchange message simultaneously indeed optimal algorithm sublinear algorithm message optimal asymptotically message contrast message optimal algorithm mst optimal significantly  peleg  distribute mst algorithm simultaneously optimal respect message complexity distribute verification mst verify span mst optimal message exists distribute verification algorithm message optimal bound mst verification however mst construction remain address fundamental aspect distribute algorithm namely relationship complexity message simultaneous optimization message complexity elusive fundamental algorithm message complexity improve factor respective algorithm reduce component factor respective phase article henceforth optimal optimal polylog factor denote polylog polylog respectively acm transaction algorithm vol article publication date november message optimal distribute algorithm minimum span mst shortest random consequently research decade distribute algorithm focus mainly optimize separately however various emerge application  communication network distribute computation data crucial distribute algorithm optimize simultaneously model definition briefly distribute compute model algorithm previously mst algorithm specify analyze congest model standard distribute compute literature communication network model undirected graph vertex processor communication link without loss generality assume denotes hop diameter unweighted diameter diameter hop diameter assume graph distinct implies mst graph unique definition generalize readily necessarily distinct node host processor limited initial knowledge specifically assumption node unique identity essential simplifies presentation computation vertex accepts input identity incident node local knowledge specifically assume node unique incident distinct node initial knowledge endpoint incident node model refer network model sometimes refer KT model initial  node restrict ill radius local knowledge KT model standard model distribute compute typically literature prior distribute mst notable exception detail vertex communicate graph assume communication synchronous occurs discrete node arbitrary message logn incident message arrives unbounded message local model mst trivially polynomial vertex therefore communicate model distribute computation congest logn model simply congest model assume vertex access outcome unbiased private coin flip efficiency distribute algorithm traditionally message communication complexity complexity synchronous algorithm whereas message complexity amount message processor execution algorithm complexity crucially influence performance distribute algorithm enjoys singular optimality admits distribute algorithm message complexity optimal fails admit namely algorithm complexity necessarily incur message complexity vice versa exhibit message tradeoff acm transaction algorithm vol article publication date november summary upper bound complexity distribute mst reference complexity message complexity logn logn  logn kutten peleg elkin article  mst radius distribute mst algorithm article distribute mst algorithm congest model simultaneously message optimal algorithm randomize vega return mst algorithm message complexity bound probability distribute mst algorithm simultaneously bound message bound apply randomize monte carlo algorithm terminology introduce earlier therefore distribute mst exhibit singular optimality polylogarithmic factor summarizes upper bound complexity distribute mst bound aforementioned message bound existential derive completely graph construction however graph bound complement graph construction distribute mst algorithm  message related importance distribute mst significant related aspect besides prior already mention discus relevant distribute mst additional detail recent survey distribute mst algorithm elkin parameter mst radius capture complexity distribute mst algorithm mst radius denote function graph topology roughly maximum radius vertex examine mst elkin devise distribute protocol construct mst ratio diameter mst radius consequently input protocol faster protocol factor however drawback protocol unlike previous mst protocol cannot detect termination algorithm unless input distribute mst algorithm correctly terminate bound sufficiently function exists graph node diameter throughout probability probability network acm transaction algorithm vol article publication date november message optimal distribute algorithm minimum span compute span constant probability message complexity elkin algorithm graph admit efficient mst algorithm bound planar graph graph bound genus treewidth pathwidth graph random complexity practical perspective mst construction logn diameter network worth investigate distribute algorithm faster output approximate minimum span devise faster approximation algorithm mst elkin later establish hardness distribute mst approximation approximate mst graph diameter within ratio essentially logn khan  exponential gap approximate mst construction exist graph distribute mst algorithm logn whereas logn approximate mst compute logn distribute approximation algorithm khan  message optimal optimal complexity distribute approximate mst approximate shortest satisfies bound applies deterministic randomize algorithm approximate version distribute algorithm compute approximation mst message complexity fully message complexity leader election graph randomize algorithm setting specifically randomize algorithm monte carlo algorithm suitably constant probability message bound exists graph node bound applies distribute mst algorithm elect leader leader chosen message construct bound applies distribute mst construction sufficiently constant bound non comparison algorithm algorithm manipulate actual node identity identity node initial knowledge synchronous network node wake simultaneously finally congest model message ofO logn local model message arbitrary mst construct message arbitrarily synchronous network KT variant important article prior prior mst assume network model KT node initial knowledge identity however assume model node knowledge model  model although distinction   clearly bearing asymptotic bound complexity significant message complexity message bound mst KT model allows possibly randomize monte carlo comparison algorithm acm transaction algorithm vol article publication date november algorithm IDs prior mst algorithm mention earlier comparison hence implies mst algorithm comparison randomize message optimal KT model considers comparison algorithm message bound applies  algorithm perform arbitrary local computation deterministic algorithm congest model terminate bound depends graph topology function randomize non comparison algorithm message bound apply KT model recently surprising elegant KT model randomize monte carlo algorithm construct mst message message bound algorithm randomize comparison algorithm achieve message complexity  optimal significantly subsequent  another randomize comparison mst algorithm complexity diam mst message complexity recently algorithm improve complexity bound message complexity randomize  algorithm message KT model subsequent preliminary version article exists deterministic message optimal mst algorithm algorithm randomize due randomize construction algorithm deterministic elkin building affirmatively devise deterministic mst algorithm achieves essentially bound article message novelty elkin algorithm fragment diameter oppose phase algorithm mst oppose mst algorithm execute brings benefit complexity minimum outgo subsequent upcast auxiliary bfs network within desire message bound hence phase algorithm bypass phase contains sole randomize portion algorithm randomize construction fully deterministic algorithm another message optimal algorithm mst recently application distribute algorithm compute function partition network overview algorithm message optimal distribute mst algorithm article prior distribute mst algorithm message optimal optimal overview algorithm intuition contrast previous mst algorithm description algorithm analysis algorithm explain additionally elkin bound improve article polylogarithmic factor acm transaction algorithm vol article publication date november message optimal distribute algorithm minimum span GHS GHS algorithm sublinear distribute mst algorithm optimal algorithm kutten peleg GHS synchronous version classical   GHS algorithm modification recall synchronous GHS algorithm essentially distribute implementation boruvka algorithm consists logn phase initial phase node mst fragment subgraph mst subsequent phase mst fragment minimum outgo LOE guaranteed mst mst fragment merge via LOEs mst fragment phase logn mst fragment halve phase message complexity logn essentially optimal complexity logn complexity optimal communication phase mst fragment diameter mst fragment significantly graph diameter complexity GHS algorithm optimal GHS algorithm alleviates situation growth diameter mst fragment merge GHS fragment remain  fragment GHS implement message GHS implement optimal algorithm message optimal message exchange however modify version implement message explain merge remain fragment algorithm GHS exist optimal mst algorithm exist optimal mst algorithm algorithm message optimal pipeline procedure pipeline procedure auxiliary breadth bfs network inter fragment mst fragment bfs mst locally pipeline algorithm cycle mst eliminate inter fragment cannot belong mst route journey pipeline procedure due pipelining mst discover message optimal exchange message node bfs message overall bfs construction message algorithm strategy achieve optimality message novelty algorithm algorithm fragment remain GHS procedure merge fragment mst unlike previous optimal algorithm pipeline procedure message optimal instead merge fragment  style algorithm implement  style merge efficiently merge achieve rename IDs merge fragment ID node combine fragment ID procedure efficiently merge fragment remain sparse neighborhood efficient communication fragment acm transaction algorithm vol article publication date november merge fragment fragment accordingly algorithm phase described phase phase treat phase described later however phase separately understand phase construct bfs entire network perform merge fragment LOE  within fragment fragment leader message overall LOE leader respective fragment  ando message traverse merges fragment sends rename fragment IDs respective leader fragment downcast message complexity upcast leader fragment broadcast ID node respective fragment message per fragment hence message overall iteration merge message iteration reduces fragment iteration iso logn iteration fragment label subsequent iteration fragment LOE LOE fragment label  within fragment leader fragment sends LOE per fragment lesser combine fragment distinct label overall LOE combine fragment merge message complexity per merge iteration respectively phase fragment fragment previous approach merge via global bfs directly message complexity address issue merge manner respect locality merge fragment local leader LOE hierarchy sparse neighborhood accomplish merge sparse neighborhood decomposition graph overlap cluster satisfy suitable definition intuition cluster relatively diameter diameter fragment bound allows efficient communication fragment within cluster weak diameter fragment bound cluster diameter cluster overlap vertex belongs cluster allows essentially congestion overhead polylog per vertex communication hence operation efficiently parallel across cluster phase fragment reduces switch phase detail merge phase efficient randomize construction algorithm due elkin randomization algorithm neighborhood elkin improve pipeline procedure distribute mst algorithm replace pipeline entirely achieve message optimality recall diameter  fragment refers shortest ignore vertex vertex whereas weak diameter  allows vertex acm transaction algorithm vol article publication date november message optimal distribute algorithm minimum span communication efficient important technical aspect merge construction efficient communication nearby fragment maintain update algorithm iteration algorithm fragment communication efficient additional leader fragment fragment member shortcut vertex reduce distance definition formalizes definition communication efficient fragment fragment vertex designate fragment leader fragment  vertex associate possibly vertex   weak diameter communication efficient defines rout data structure maintain communication efficient later construction rout data structure inductively iteration fragment respective LOEs message cannot merge fragment along LOEs chain procedure  merge fragment manner  maximal fragment graph induced LOE crucial communication efficient communicate efficiently message wise fragment leader node fragment LOEs fragment leader adjacent fragment merge implement  procedure FindLightest describes LOE assume communication efficient fragment maintenance efficient fragment recursively fragment efficient merge fragment efficient hierarchy sparse neighborhood construct communication efficient fragment hierarchy consists collection cluster radius hierarchy cluster radius fragment radius subsequent hierarchy cluster geometrically increase radius hierarchy simply bfs entire graph easy construct communication efficient fragment  lemma subsequent iteration merge adjacent fragment algorithm cluster fragment neighborhood cluster allows algorithm construct communication efficient merge fragment shortcut outside fragment hence weak diameter assume fragment merge efficient important fragment cluster relation radius cluster otherwise message complexity pipeline scenario hence invariant maintain iteration cluster depth fragment cluster depth bound  message complexity invariant maintain fragment per cluster compensate increase cluster radius lemma phase invariant guarantee cluster radius fragment acm transaction algorithm vol article publication date november phase cluster radius cluster radius becomes bfs switch phase remain fragment guaranteed phase phase merge procedure phase phase merge iteration fragment respective LOEs LOEs fragment  respective leader leader mostO upcast merges fragment sends merge information fragment leader downcast phase treat remain fragment fragment important difference phase merge leaf leader fragment intact future iteration phase fragment LOE procedure FindLightest whereby endpoint fragment distinct label candidate LOE fragment leader communicate respective node bfs via hierarchy communication efficient rout construct phase incur polylogarithmic overhead takesO per merge iteration  LOE bfs via communication efficient merge iteration message complexity per merge iteration iteration theo takesO message  logn iteration overall obtain desire bound description analysis algorithm algorithm operates mst partition vertex graph collection subgraph mst fragment subgraph induced  ing mst mst contains fragment diameter similarly mst weak mst contains fragment weak diameter define fragment graph structure throughout algorithm fragment graph consists vertex fragment iteration algorithm obtain contract vertex vertex remove loop sometimes remain inter fragment algorithm proceeds outgo LOEs fragment partly LOE graph iteration vertex remove inter fragment unique LOE per fragment GHS procedure algorithm invocation GHS procedure introduce subsequently refine GHS algorithm modify variant GHS algorithm purpose balance outcome diameter fragment whereas GHS algorithm allows uncontrolled growth fragment achieve compute phase maximal fragment merge fragment accordingly resort variant incurs message complexity precede version phase essentially reduces fragment factor increase diameter fragment factor phase GHS capped throughout denotes logarithm acm transaction algorithm vol article publication date november message optimal distribute algorithm minimum span algorithm message optimal distribute mst algorithm GHS procedure algorithm fragment obtain GHS phase fragment construct bfs fragment leader upu bfs downu bfs leader election algorithm constant approximation diameter skip phase phase node iteration construct  suitably chosen constant node locally remembers incident fragment FindLightest LOE incoming leader along upward FindPath communication efficient connects leader merge iteration merge fragment fragment weak diameter marked active graph induced LOE vertex active fragment output  simulate inter fragment communication communication efficient fragment merge active fragment incident LOE merge orient marked merge fragment ID fragment leader fragment outgo marked becomes dominator non dominator fragment leader sends merge request adjacent dominator dominate leader leader merge request node leader merge fragment fragment sends  along leader receives instructs node update fragment ID update entry previously indexed indexed fragment graph consist merge fragment inter fragment iteration  phase compute mst fragment graph iteration invoke FindLightest fragment parallel upcast LOE bfs bfs receives LOEs fragment computes merge locally sends merge label fragment  downcast via bfs fragment leader relay label node fragment via broadcast along communication efficient iteration fragment label iteration fragment individually invokes FindLightest whereby endpoint fragment distinct label candidate LOE acm transaction algorithm vol article publication date november algorithm procedure GHS mst network procedure GHS initial mst connectivity component maximal diameter determines LOE candidate maximal SM graph diameter incident SM mst fragment return GHS procedure fragment denote lemma described lemma algorithm output mst sends logn message proof correctness algorithm establish lemma lemma corollary ith iteration algorithm implement timeO hence complexity GHS analyze message complexity algorithm iteration algorithm message complexity outgo fragment analysis GHS algorithm maximal built cole  symmetry algorithm argue proof corollary iteration algorithm message per fragment exchange cole  algorithm terminates iteration message complexity building maximal afterwards additional logn message complexity message complexity algorithm GHS therefore logn rout data structure communication efficient achieve complexity bound algorithm maintains efficient fragment iteration node locally maintain rout detail node dimensional array upu downu rout array indexed fragment ID  iteration loop variable algorithm array upu contrast array downu intuitively upu refers towards leader refers iteration construct similarly downu ofu communication efficient originate leader downu disseminate information leader fragment member oversimplify envision upu downu relation fragment leader integer corresponds iteration loop entry algorithm fix fragment array induce chain incident acm transaction algorithm vol article publication date november message optimal distribute algorithm minimum span array array route along chain chain upward downward emphasize existence node fragment leader simply communication efficient omit relevant define node specify downu node upu definition rout structure explain construction detail rout message detail suppose  generates message leader encapsulates ID indicator message sends upu simplicity denote fragment ID node receives   integer encapsulate message along specify relayed  upward node  undefined attempt lookup  along upward forth manner along upward ith iteration algorithm loop upward coincides fragment leader ith iteration iteration leader ith iteration disseminate message fragment member sends downu similarly message relayed leaf downward entry  undefined node  respective upward traverse downward convenience concatenation downward simply define upward similarly individual component algorithm detail simplify presentation discus detail algorithm inductively assume node bfs fragment leader bfs span fragment easily construct GHS procedure depth fragment node initializes rout array upu bfs downu bfs lemma iteration algorithm fragment fragment leader proof initialization rout immediate leader node along upward similarly leader along downward allows fragment member bound diameter bound fragment lemma outgo LOEs procedure FindLightest procedure FindLightest enables fragment leader obtain outgo exactly endpoint iteration node perform additional computation message described algorithm aggregate simultaneously message focus mechanism acm transaction algorithm vol article publication date november FindLightest fragment node exchange fragment IDs ensure node incident outgo node leaf bfs fragment along upward node upward message outgo upward lemma prof useful FindLightest bound message complexity inductively argue structure fragment relies introduce subsequent hence postpone message complexity analysis lemma lemma efficient LOE computation suppose iteration fragment communication efficient fragment leader obtains outgo execute procedure FindLightest  proof accurately bound congestion simultaneous invocation FindLightest fragment assumption fragment  fragment node relay outgo information fragment leader along  precisely upward leader bound congestion upward subpath confine node fragment execute GHS fragment disjoint message aggregate within fragment fragment leader leader fragment accumulates information node within lemma traverse upward fragment distinct message information reduce hence message along subsequent upward maximum congestion node standard upcast  fragment leader receives message  communication efficient procedure FindPath execute FindLightest leader obtain identity outgo distinct fragment invoke building procedure FindPath ensure leader aware hence instruct node along upward leader algorithm FindPath detail goal compute communication efficient leader route message node fragment leverage communication efficient efficiently merge fragment crucial building efficient sparse neighborhood precompute iteration algorithm recall definition concern underlie unweighted graph distance hop distance definition sparse neighborhood graph collection cluster acm transaction algorithm vol article publication date november message optimal distribute algorithm minimum span depth depth sparsity vertex graph neighborhood vertex graph exists contains entire neighborhood vertex sparse neighborhood introduce useful application efficient distribute randomize construction due elkin recall theorem theorem exists distribute randomize vega algorithm  construct neighborhood logn logn message bound probability congest model mst algorithm invoke elkin  procedure logn  neighborhood parameter communication efficient construction overall message complexity construction carefully probe cluster induces communication efficient recall node locally incident cluster precomputed structure independent array instruct leader probe message node probe message along cluster respective cluster receives probe message timely fashion exists probe message leader within logn depth account congestion simultaneous probe message fragment leader lemma message reverse inform leader communication efficient multiple message however cluster sends message receives probe message leader exactly message message cluster node ID without loss generality assume identify communication efficient discard message suppose message along cluster sends message along instructs node  successor towards  predecessor node update  array contact adjacent node update  similarly leader node proceeds update respective entry information towards contact successor update rout information whereas sends request successor request cluster concatenate communication efficient leader although algorithm described monte carlo easily convert vega acm transaction algorithm vol article publication date november fragment iteration adjacent fragment communicate along communication efficient execute FindPath probe message along cluster finally succeed communication efficient cluster cluster leader similarly obtain communication efficient cluster probe message cluster iteration merge fragment respectively adjacent proceed construct  cluster probe appropriate cluster leader node probe message  cluster leader message rerun probe probe message along incident cluster forth fragment leader synchronize execute probe lemma fragment weak diameter iteration radius ensures depth cluster cluster apply construction communication efficient lemma probe message generate distinct fragment leader transit simultaneously iteration FindPath proof lemma fragment leader probe message simultaneously explore communication efficient leader probe message cluster lemma iteration fragment graph induces weak mst acm transaction algorithm vol article publication date november message optimal distribute algorithm minimum span proof adapt proof lemma fragment graph weak mst directly lemma focus inductive suppose weak mst argue fragment weak diameter subgraph induced marked merge algorithm component marked output  analogously lemma component contains fragment weak diameter fragment weak diameter become active participate maximality implies component diameter fragment subgraph moreover fragment component weak diameter fragment weak diameter merge iteration inductive hypothesis merge component weak diameter argue fragment contains node iteration assume merge fragment iteration fragment contains node weak diameter hence active description merge guaranteed merge fragment inductive hypothesis consist node hence merge fragment node lemma iteration execution FindPath exists communication efficient leader leader mostO integer exists cluster  FindPath message terminates min diam probability proof description FindPath leader probe message along incident towards respective cluster establish efficient communication cluster definition hence probe message lemma iteration fragment weak diameter whereas cluster radius logn argue message complexity bound apart probe message discover communication efficient cluster account probe message along cluster generate depth depth message communicate efficiently via cluster depth apply lemma account additional congestion simultaneous probe message yield complexity depth acm transaction algorithm vol article publication date november lemma iteration suppose FindPath invoked simultaneously outgo message complexity invocation complexity diam probability proof lemma fragment weak diameter adjacent fragment cluster lemma invocation FindPath message lemma fragment LOEs hence message incur fragment LOE sum obtain claimed bound message complexity finally lemma already account congestion simultaneous invocation yield bound complexity summarize procedure FindPath enables leader adjacent fragment communicate message along communication efficient rout merge fragment avoid chain merge fragment procedure   output maximal fragment fragment treat super vertex graph inter fragment procedure  simulates cole  symmetry distribute algorithm terminates iteration theorem simulation efficiently fragment graph procedure FindPath enables communication via communication efficient adjacent fragment leader enables simulation procedure  network induced leader perform computation  lemma directly lemma lemma suppose fragment communication efficient outgo graph obtain FindPath  simulated network define diam message non dominator fragment sends  message leader arbitrarily chosen adjacent dominator fragment dominator fragment merge request parallel  message leader fragment  request along downward node upon  message node update fragment ID update rout upu upu downu downu leader dominator fragment becomes leader merge fragment lemma  fragment communication efficient probability message complexity merge fragment iteration completes within diam fragment communication efficient acm transaction algorithm vol article publication date november message optimal distribute algorithm minimum span proof argue recursively iteration   message communicate fragment lemma diam message adjacent fragment suppose merges dominator fragment eventually broadcast fragment ID node ensure rout upu downu update correctly route message towards leader vice versa node compute outgo merge fragment subsequent iteration compose merge fragment merge previous iteration without loss generality suppose iteration isi assumption consist efficient fragment node remove rout information leader communication efficient obtain invoke FindPath iteration fragment ID leader iteration fragment apply lemma reveals obtain invoke FindPath iteration relay fragment ID iteration fragment incur diam message recursively apply argument iteration allows diam logn message sufficient relay fragment IDs fragment leader fragment leader bfs fragment broadcast information fragment node message consists communication efficient fragment hence fragment node newly merge fragment already communicate efficiently leader  become moreover obtain FindPath ensure communicate efficiently leader hence transitively communication efficient analysis message complexity merge fragment allows obtain bound message compute outgo fragment lemma message complexity parallel invocation FindLightest iso proof FindLightest node exchange message message fragment vertex previously argue relay LOE information along upward fragment leader upward fragment leader exactly bfs yield GHS crucial observation sends LOE information LOE message ensures node sends exactly message hence obtain bound message upward node subsume message complexity exchange message fragment leader exactly aggregate outgo information message relayed fragment leader along respective upward ofO  hop definition reverse argument lemma inductively apply lemma obtain bound message per iteration message complexity analyze correctness complexity phase algorithm acm transaction algorithm vol article publication date november lemma phase algorithm message ensures fragment label merge proof algorithm executes phase directly phase skip phase execute phase argue fragment fragment ID logn iteration phase fragment label halve iteration execute FindLightest node exchange fragment IDs  message candidate LOE endpoint fragment distinct IDs ensures fragment another fragment hence distinct IDs remove chain fragment LOE faster reduction distinct label fragment chain adapt fragment ID phase pseudo code iteration phase fragment fragment ID LOE fragment merge message complexity phase accord lemma complexity LOEs accord lemma message LOEs independently phase directly phase phase execute phase directly phase skip phase FindLightest node locally incident LOE aggregate LOE fragment leader addition fragment bfs construct global bfs diameter assumption fragment leader respective LOE along towards  oft  distinct fragment LOE upward additional message complexity ofO account takesO fragment leader LOE fragment complexity amount argue message complexity execute phase phase distinct fragment fragment ID global bfs treeT  fragment LOE aggregate fragment leader  global bfs  message assumption combine complexity bound previous lemma obtain theorem theorem synchronous network KT model node diameter suppose logn transmit link algorithm computes mst probability exchange message simultaneously tight lower bound mention exist graph construction establish bound simultaneously yield message bound similarly exist bound graph construction message bound simultaneously yield bound previously sparse graph obtain bound acm transaction algorithm vol article publication date november message optimal distribute algorithm minimum span almost choice message broadcast hence construct minimum span universal bound mst essentially exists graph node  randomize mst algorithm message graph succeed constant probability proof combine bound technique hardness distribute symmetry bound message complexity communication complexity bound complexity theorem exists graph node diameter error distribute mst algorithm KT model message expectation graph sufficiently constant node unique IDs chosen poly knowledge network diameter proof theorem bound graph bound graph consists graph construction subsequent refinement combine dumbbell graph construction outline feature refer reader detail graph consists designate node vertex disjoint highway determines diameter node enumerate obtain diameter shortcut node highway ith highway node node modify graph remove vertex highway distance vertex regular graph consist  node positive constant assume diameter logn sufficiently positive constantc ofc switch vertex ofc obtain concrete graph bound construction assign unique IDs chosen poly specify mapping node deg mapping function advance concrete graph define graph graph remove define  graph obtain remove switch remove node construction  consists graph removal  graph disjoint node IDs due remove algorithm construct span message elect leader message construct span execute broadcast algorithm restrict communication span strengthen diameter described looser bound sake readability graph exist random regular graph expander hence diameter probability sufficiently constant acm transaction algorithm vol article publication date november obtain dumbbell graph denote dumbbell bridge symmetry complexity bridge broadcast define input graph collection dumbbell graph obtain bridging ID disjoint graph  contains removal concrete graph account  ID assignment bridge introduce capture hardness discover bridge without message detail algorithm solves bridge execution graph vertex sends message across bridge bound message complexity deterministic bridge algorithm input lemma deterministic algorithm achieves bridge dumbbell graph collection message complexity graph uniformly sample lemma lemma difference input restrict dumbbell graph combination switch inc whereas switch nevertheless switch inc sufficiently hence counting argument lemma apply average message complexity bridge deterministic algorithm input graph uniformly introduce technical overall proof refer reader detail proof dumbbell concrete ID assignment bridge algorithm execution disconnect graph consist node execution dumbbell easy  argument behaves exactly execution bridge happens execution disconnect graph sends message across increase predetermine sends message across dumbbell graph dumbbell occurs message obtain average message complexity deterministic algorithm counting message graph graph input collection lemma lemma extend randomize monte carlo algorithm via yao minimax lemma yield lemma error randomize bridge algorithm exists graph message complexity expectation random communication complexity reduction disjointness bound mst reduction span subgraph reduction disjointness acm transaction algorithm vol article publication date november message optimal distribute algorithm minimum span graph dumbbell proof theorem acm transaction algorithm vol article publication date november communication complexity model alice  bob receives vector player communicate along communication channel index razborov  randomize communication protocol disjointness leverage alice bob jointly simulate execution distribute mst algorithm graph assignment input obtain protocol disjointness assignment highway obtain whereas incident obtain assign recall description bound graph hence ith incident assign otherwise similarly ith incident assign otherwise mst jth crucial exactly incident otherwise disconnect graph highway cycle disjoint jth incident alice jth incident bob consequently lemma mst contains disjoint simulate mst algorithm alice bob  assign appropriately incident simulate execution ong alice unaware bob input hence incident therefore alice simulate node similarly bob simulates node completeness simulation argument alice alice bob simulation node  logn per simulated mention alice simulate hence boundary node highway simulated node message node simulated bob alice boundary node highway simulation suppose message highway simulated bob bob simply sends message alice logn bob message alice concern boundary node alice simulate boundary node however simulate boundary node highway alice loses ability simulate layer boundary node respective closer alice become boundary node recall bound graph construction node alice simulate simulate node bob cannot afford message originate node alice alice loses simulated highway boundary vertex node highway alice simulate acm transaction algorithm vol article publication date november message optimal distribute algorithm minimum span terminates alice incident mst bob moreover mst depends incident alice compute incident bob logn bob reconstruct mst mst lemma bob conclude disjoint mst incident index intersect mst solves disjointness described simulation logn consequently simulation cannot terminate logn communicate alice bob contradict bound disjointness constant probability error easy application markov inequality complexity lemma exists function graph execute algorithm graph  expectation everything combine lemma argue unweighted graph lemma lemma directly implies theorem lemma mst algorithm exists graph expectation message complexity proof mst algorithm assignment lemma apply graph collection yield collection graph correspond graph denote subgraph correspond regular unweighted subgraph accord assignment switch construct dumbbell graph lemma lemma applies graph collection markov inequality derive probability individual statement lemma lemma union bound yield probability message bound simultaneously CONCLUSIONS distribute algorithm fundamental minimum span simultaneously message optimal within polylog factor exists distribute mst algorithm  message complexity KT variant model currently important shortest minimum random enjoy singular optimality admit distribute algorithm essentially optimal message optimal direction recently research address