introduce hollow heap data structure amortize efficiency classical fibonacci heap heap operation delete delete min amortize delete delete min amortize heap item hollow heap simplest structure achieve bound hollow heap combine novel lazy deletion insertion decrease operation dag acyclic graph instead heap lazy deletion hollow node node without item data structure CCS concept theory computation data structure analysis additional data structure priority queue heap amortize analysis introduction heap data structure consist item totally universe heap operation heap return empty heap min return item minimum heap null empty insert return heap heap insert item item heap delete min return heap non empty heap delete item return min meld return heap item item disjoint heap decrease item heap  return heap delete return heap delete assume heap insert delete min decrease delete heap meld destroyed operation heap operation decrease delete location item heap parameter omit decrease delete decrease operation efficient intermixed meld operation disjoint data structure partition item heap discussion reference fredman tarjan fibonacci heap implementation heap delete min delete item heap amortize operation amortize application fibonacci heap implementation dijkstra shortest algorithm algorithm undirected minimum span invention fibonacci heap heap implementation amortize bound propose notably  complicate heap implementation achieves bound fibonacci heap later simplify data structure significantly complicate  structure discussion related reference focus amortize efficiency heap spite competitor fibonacci heap remain simplest heap implementation code taught numerous undergraduate graduate data structure hollow heap data structure surpasses fibonacci heap conceptually simpler simpler analyze implement decrease bound fibonacci heap data structure novelty lazy deletion decrease operation avoid cascade fibonacci heap heap dag acyclic graph instead amortize analysis hollow heap nontrivial simplify fundamental data structure retain performance important endeavor fibonacci heap decrease heap violation node violate node subtree eventually destroy balance data structure maintain balance trigger cascade ancestor originally node loss information outcome previous comparison decrease operation although modify data structure reduces reference hollow heap item decrease merely node preserve exist structure lazy deletion carefully hollow heap efficient fibonacci heap develop hollow heap hollow node appropriate rank replace cascade fibonacci heap efficient replace heap acm transaction algorithm vol article publication date july hollow heap unranked link link rank reference orthogonal hollow node obtain data structure avoid hollow node heap treelike dag node remainder article consists multi version hollow heap mention version hollow heap version data structure replaces movement dag representation describes rebuild improve efficiency hollow heap implementation detail data structure explores hollow heap identify variant efficient variant multi hollow  classic fibonacci heap data structure heap heap fibonacci heap node exactly item item exactly node relax invariant node item node item hollow newly node later become hollow item node delete hollow node hollow destroyed item node structure necessarily exogenous endogenous node item item node denote item item null hollow item denote node node node associate item hollow item organize node arc arc zero arc ancestor descendant node node leaf heap arc hollow heap implies minimum maintain invariant heap empty contains minimum node hollow maintain pointer node pointer minimum node heap generic implement heap update operation via link primitive link arbitrarily loser link winner link eliminates preserve heap loser fibonacci heap link delete min delete operation delete item minimum node heap return empty min return item minimum node meld heap empty return otherwise unite update minimum node insert item heap node item node meld node heap exist heap alternatively item node alternative preferable primarily experimental acm transaction algorithm vol article publication date july decrease operation lazy deletion decrease item node heap minimum node merely otherwise node hollow subtrees meld heap consist descendant choice critical decision address shortly optimization minimum node avoid node merely update minimum node delete min delete item minimum node delete item remove node node hollow completes deletion unless minimum node delete item minimum node delete min delete proceed hollow destroy unite zero link reduce remain heap meld heap choice link another critical decision address shortly remark implementation delete allows hollow proceed deletion item minimum node whenever item delete fibonacci heap data structure efficient node rank node non negative integer rank rank node insertion initial rank link rank link increase rank winner link ranked link delete deletes item minimum node ranked link none rank ranked link suffices remain decision choice subtrees decrease operation rank newly node achieve efficiency maintain rank invariant node rank exactly rank unless hollow decrease exactly rank maintain rank invariant decrease operation item node node initialize rank max rank rank rank along subtrees rank retains rank rank rank along subtrees rank retains rank data structure multi hollow heap illustrates operation multi hollow heap theorem multi hollow heap correctly implement heap operation maintain heap maintain rank invariant proof proof straightforward induction heap operation decision balance appropriate argument fibonacci heap simpler fredman obtain constant amortize bound decrease data structure nlog extra information node rank although significant technical restriction iacono  acm transaction algorithm vol article publication date july hollow heap operation multi hollow heap node node hollow node non zero rank heap successive insertion item item singleton arrow item minimum pointer heap deletion minimum item item heap decrease heap delete item heap delete min operation deletes item recall definition fibonacci satisfy golden ratio lemma node rank descendant hollow proof proof induction immediate descendant node rank descendant rank rank invariant hollow induction hypothesis descendant acm transaction algorithm vol article publication date july corollary rank node multi hollow heap node logφ proof corollary immediate lemma obtain efficient implementation multi hollow heap node singly link decrease rank heap singly link circular access via minimum node circular link allows  constant meld constant ranked link decrease rank decrease item node node rank rank heap operation delete delete min constant link delete array indexed rank fibonacci heap global array heap delete unless deletes item minimum node hollow destroyed remain destruction hollow link link per rank logφ corollary link logφ meld logφ delete per hollow destroyed plus per link plus bound amortize per operation modify analysis fibonacci heap theorem amortize per multi hollow heap operation operation delete delete min per delete delete min heap node proof per operation delete deletes item minimum node per hollow node destroyed plus per link plus node destruction correspond node creation per insert per decrease obtain theorem remains bound link link potential function node another node potential node hollow node node potential zero potential heap sum potential node define amortize operation link plus increase potential initial potential zero data structure empty potential non negative link sum amortize operation link delete operation delete item minimum node amortize operation potential per insert zero per min meld per decrease hollow node delete link amortize zero convert reduce potential potential delete remove item creates hollow node increase potential per logφ conclude link per heap operation plus logφ per delete heap node acm transaction algorithm vol article publication date july hollow heap remark proof theorem bound amortize comparison per operation per insert meld per decrease logφ per delete heap node obtain multi hollow heap fibonacci heap decrease operation node instead entire subtree subtrees preserve balance avoid cascade fibonacci heap cascade rank reference restructuring reduce heap violation reference decrease operation amortize additional information fibonacci analysis lemma directly amortize analysis theorem becomes simpler implementation simpler singly link replace doubly link fibonacci heap pointer price threefold data structure becomes exogenous endogenous item node vice versa item node amortize delete delete min becomes data structure item heap node latter insert decrease operation reduce bound periodically rebuild data structure discus multi hollow heap asymptotically optimal available information comparison update minimum node meld decrease node successively item modify data structure additional information hollow  link rank obtain version hollow heap orthogonal hollow node reference obtain version rank heap reference obtain version fibonacci heap apply hollow heap modify hollow heap drastically avoid decrease operation described ranked link applies rank node node winner increase rank winner arbitrarily contrast unranked link applies rank node node rank arbitrarily link loser winner loser link ranked unranked link ranked unranked respectively retains ranked unranked decrease operation lose another link becomes hollow later destroyed hollow heap empty heap minimum node heap operation multi hollow heap meld non empty heap unranked link decrease item node node initialize rank max rank ranked rank rank along subtrees unranked along subtrees acm transaction algorithm vol article publication date july operation hollow heap node node hollow node non zero rank bold dash denote ranked unranked link respectively heap successive insertion item link perform unranked heap deletion minimum item link perform ranked heap decrease heap delete item heap another delete min operation rank invariant hollow heap node rank exactly ranked rank unless hollow decrease exactly ranked rank node unranked illustrates operation hollow heap acm transaction algorithm vol article publication date july hollow heap theorem hollow heap correctly implement heap operation maintain heap maintain rank invariant proof proof straightforward induction heap operation lemma node rank hollow heap descendant hollow proof proof lemma proof actually descendant acquire ranked link corollary rank node hollow heap node logφ proof proof corollary lemma obtain efficient implementation hollow heap node singly link circular access via ranked decrease rank unranked circular access via node allows link constant maintain desire ranked link unranked link ranked unranked node rank decrease item node node rank along subtrees leaf ranked rank unranked implementation none unranked theorem amortize per hollow heap operation operation delete delete min per delete delete min heap node proof proof proof theorem slightly potential function node potential unless ranked node zero potential ranked link reduces potential amortize zero unranked link potential amortize amortize operation delete delete min argument proof theorem delete delete min node hollow delete item increase potential ranked increase potential deletion item minimum node ranked link amortize zero unranked link per rank amortize delete delete min conclude option link delete remove item minimum node meld repeatedly meld minimum rank easy implement theory justify increase rank winner unranked link unranked link rank increase rank winner link ranked link unranked link unequal rank rank winner increase rank rank loser increase algorithm slightly define link increase acm transaction algorithm vol article publication date july rank winner ranked link link unranked link implementation loser ranked unranked link becomes respectively decrease item node node merely rank zero preserve rank maintains invariant node rank rank rank rank extension analysis efficient node accumulate ranked rank handle analysis node additional potential maximum zero ranked minus rank omit detail analysis already option improves performance experimental certainly complicate algorithm hollow  drastic hollow heap eliminates movement decrease operation convert data structure treelike dag decrease item node  node initial rank max rank instead merely hollow heap applies equally multi hollow heap data structure hollow heap contrast data structure jointly hollow heap detail extend terminology dag dag arc node node leaf dag node heap arc topological dag arranges node non decrease hollow heap empty heap dag minimum node heap operation hollow heap decrease item node node illustrates operation hollow heap theorem hollow heap correctly implement heap operation maintain heap heap dag empty proof proof straightforward induction heap operation analysis hollow heap straightforward  hollow heap analysis define virtually node mimic movement hollow heap definition analysis algorithm algorithm lemma node hollow heap hollow node hollow cannot acquire acm transaction algorithm vol article publication date july hollow heap operation hollow heap node node hollow bold dash  denote ranked link unranked link respectively node non zero rank successive insertion item empty heap delete min operation link delete min ranked decrease delete min hollow node becomes unranked link node occurs delete min hollow node become destroyed hollow loses link ranked proof node acquire acquire lose link node acquire become hollow decrease operation node loses link node becomes hollow cannot become cannot acquire node item clone lemma maximal clone dag decrease creation clone possibly hollow insertion deletion stack proof proof induction heap operation insertion creates clone consist node decrease item node node hollow clone delete delete min remove item node clone node hollow subsequently destruction node acm transaction algorithm vol article publication date july virtual movement rank invariant hollow heap node virtual node virtual virtual loses ranked link becomes virtual virtual node destroyed loses virtual node acquire virtual later lose link decrease item node node virtual node virtual rank rank max rank node virtual virtual lemma virtual proof proof induction heap operation newly node virtual suppose node acquires virtual lose link subsequently virtual later clone become destroyed lemma later clone destroyed recent virtual hence becomes virtual rank invariant hollow heap node rank exactly virtual rank unless hollow decrease exactly virtual rank theorem hollow heap maintain rank invariant proof proof induction heap operation proof correspond theorem lemma lemma node acquires ranked link becomes virtual node virtual virtual define virtual node virtual descendant node virtual descendant virtual lemma node rank hollow heap virtual descendant hollow proof proof lemma corollary rank node hollow heap node logφ proof proof corollary lemma straightforward implement hollow heap exogenous singly link link loser winner exogenous endogenous node node node acquires lose link acquires later hollow decrease node node lose node hollow node deletion initialize node false node hollow acm transaction algorithm vol article publication date july hollow heap decrease node destroyed false becomes false alternative implementation theorem amortize per hollow heap operation operation delete delete min per delete delete min heap node proof proof proof theorem hollow node lose without become destroyed another decrease hollow node per decrease ranked link slightly potential function node potential unless virtual node ranked link reduces potential amortize zero unranked link meld potential node hollow remove item increase potential logφ virtual increase potential conclude hollow heap decrease item node eventually destroyed destroyed depends future heap operation advance node destroyed become destroyed hollow meld hollow heap distribute decrease occurs become destroyed hollow heap none become destroyed hollow heap delay access postpone become local advantage translates global advantage  node hollow heap insertion plus decrease operation item heap heap meld decrease operation polynomial insertion item minimum node delete heap item amortize per delete delete min fibonacci heap application storage input linear heap operation extra hollow node linear heap graph algorithm dijkstra shortest algorithm various minimum span algorithm edmonds optimum branching algorithm application insert delete min per vertex delete operation trigger delete min operation decrease operation per arc application hollow heap asymptotically efficient fibonacci heap although linear arc whereas fibonacci heap linear vertex advantage fibonacci heap significant depends graph density implementation detail application decrease operation insertion extra hollow node becomes bottleneck periodic rebuild guarantee heap acm transaction algorithm vol article publication date july heap suitable constant eliminate hollow node rebuild heap rebuild completely disassemble heap node destroy hollow node node node heap node rank meld heap remains comparison node rank contract hollow node  hollow heap eliminate node dag multi node rank zero ancestor destroy hollow node extend analysis rebuild define unranked rebuild rebuild traversal dag rebuild per hollow node destroyed rebuild heap operation hollow node per operation obtain theorem theorem rebuild amortize per hollow heap operation operation delete min delete per delete min delete heap item heap bound hollow heap sufficiently arbitrarily reduce rebuild overhead constant factor additive constant amortize delete rebuild actually application rebuild described decrease operation longer decrease trigger rebuild amortize remains preserve decrease operation incremental rebuild although detail complicate simpler alternative multi version hollow heap decrease item decrease decrease node update minimum node instead item node rebuild delete delete min hollow node per item consecutive delete delete min operation operation appropriately guarantee node hollow fix hollow node entirely eliminate data structure hollow heap contract hollow node application multi hollow heap modify described hollow heap hollow maximal subtree hollow node leaf symmetric define node correspond contract structure delete replace becomes sublist sublists sublists individual decrease operation somewhat tedious detail maintain decrease rank partition sublists consecutive behavior algorithm defines sublists ranked acm transaction algorithm vol article publication date july hollow heap link loser winner becomes member singleton sublist sublists remain sublists remain decrease node merely node item appropriate sublists decrease item node update completes decrease sublist split sublists sublist empty delete sublist rank empty rank remove sublist sublist rank remove sublists  rank max rank replace sublists  remain sublists update minimum node data structure contract hollow heap analysis extends theorem theorem amortize per contract hollow heap operation operation delete min delete per delete min delete heap insert decrease operation meld operation straightforward extend contraction hollow heap extend hollow heap nice contraction node arbitrarily contract hollow heap hollow node significant drawback per delete obtain latter bound additional rebuild pointer per node implement structure exceed fibonacci heap rank heap although structure endogenous pointer contract hollow heap primarily theoretical implementation hollow  mention implement hollow heap multi pointer per item node rank pointer per node sibling item straightforward implementation hollow heap exogenous implementation hollow heap  thereby reduce acquire via link decrease respectively node hollow decrease lose define link endogenous link loser winner implies crucial lemma node proof node acquire become hollow newly acquires later via link becomes hence remains acm transaction algorithm vol article publication date july pointer node node node hollow solid dash  arrow denote extra pointer respectively recall operation perform heap successive insertion item empty heap delete min operation link delete min ranked decrease delete min hollow node becomes unranked link node occurs delete min hollow node become destroyed hollow loses link ranked lemma allows pointer per node hollow heap node null null deletion efficient query constant node query node pointer extra null node iff null iff null iff node rank fourth pointer item item null item pointer node node rank integer storage illustrates pointer structure implementation heap operation delete straightforward implementation pseudocode implementation auxiliary decrease item minimum node acm transaction algorithm vol article publication date july hollow heap implementation hollow heap operation delete implementation auxiliary newly hollow node node  sibling remark hollow node null data structure information implementation heap operation information implementation delete destroyed link maintain hollow singly link pointer pointer duty link adjacent sibling link adjacent maintain array indexed rank per rank delete hollow initialize hollow empty empty delete node apply appropriate destroy hollow deletion null processing node acm transaction algorithm vol article publication date july implementation delete hollow heap rank update ranked link auxiliary ranked link null null node loses unless contains rank link via ranked link winner rank winner finally empty empty link via unranked link pseudocode implement delete null assignment factor auxiliary delete link array global variable assume initialize empty integer max rank global variable implementation per operation delete operation remove item delete remove item plus per hollow node loses plus per link plus node dag delete max rank corollary bound theorem reduce pointer per node implementation node item null item null hollow per node acm transaction algorithm vol article publication date july hollow heap implementation auxiliary delete node hollow trading per node pointer per node avoid extra per node rank hollow node rank hollow node node actual rank plus variant disadvantage item extra pointer alternative per node pointer per node pointer eliminate pointer instead node boolean variable decrease node item  penultimate query  traversal query delete processing hollow combine alse another alternative eliminates pointer delete pointer boolean variable node modify item hollow node item alternative delete item node null otherwise hollow node dangle item pointer node item node  null item item item item item pointer replace pointer item cannot destroyed hollow node previously destroyed alternative appeal rank item instead node decrease operation access item decrease node node item automatically hollow item node alternative experimental likely sequence operation detail computer program  explore hollow heap data structure occupy sweet although structure preserve efficiency destroy explore variant acm transaction algorithm vol article publication date july structure extend analogous  structure structure ıve integer function specify rank node decreasekey operation function rank node hollow operation data structure data structure rank decrease max exactly data structure data structure data structure rank decrease max  ranked unranked exactly data structure finally ıve data structure rank decrease max assigns hollow node becomes delete become regime fix non negative integer positive non decrease integer function tends infinity tends infinity positive fix integer efficiency fibonacci heap straightforward adapt analysis increase rank bound corollary decrease constant factor approach respectively grows logarithm tradeoff amortize bound decreasekey increase linearly variant inefficient specifically amortize per delete min operation amortize per heap insert amortize per decrease demonstrate construct costly sequence operation variant content merely amortize per decrease variant asymptotically sequence summarize theorem individual construction theorem variant efficient choice fix independent variant namely ıve regime inefficient regime ıve regime positive non decrease function tends infinity obtain expensive sequence operation define binomial inductively  link consists empty insertion item increase delete min insertion consist rank delete min link ranked node rank operation decrease operation item item previous hollow insert item item finally delete min delete min deletes hollow hollow node link hollow node rank node link delete min acm transaction algorithm vol article publication date july hollow heap construction binomial label node hollow solid dash denote ranked unranked link respectively initial configuration binomial shade node item decrease operation perform heap perform decrease operation insert item newly hollow node decrease node link node node involve link binomial node remains binomial link ranked link consecutive subsequent operation contains delete min operation delete min operation operation desire amortize per delete min amortize per heap insert amortize per decrease tends infinity ıve ıve identical exactly described extension construction ıve inefficient adversary ranked link assume simplicity acm transaction algorithm vol article publication date july ıve identical ıve node decrease rank construction ıve issue insert node rank function node decrease ıve additional node non zero rank link affect construction initial decrease operation item insert operation item delete min operation operation link delete min adversary preferentially link newly insert node grandchild delete avoid link involve node decrease operation choice furthermore chooses newly insert item minimum link additional descendant node decrease operation construction initial subsequent operation maintains invariant consists additional descendant node decrease operation analysis operation desire operation however construction ıve logarithmic amortize per decrease construct rank node hollow repeatedly insert delete min repetition construction decrease operation node hollow descendant operation maintain invariant hollow node hollow descendant manipulate hollow node increase operation ignore hollow node equivalently regard delete furthermore restriction behavior suffices rank rank insert item node becomes decrease item grandchild insert item finally delete min delete min rank inclusive rank rank delete min decrease operation hollow node node descendant hollow node induction arbitrary operation operation repetition insert delete min sequence operation elaborate rank replace rank rank acm transaction algorithm vol article publication date july hollow heap construction node solid dash denote ranked unranked link respectively rank beneath node obtain insert item perform delete min operation insert item item rank delete min insert node become rank link ranked link rank remain become node exactly descendant rank inclusive obtain perform delete min operation assume rank rank rank delete min rank unlike situation descendant link arbitrarily finally decrease item descendant  decrease item node hollow descendant rank node rank node node already rank rank rank extra hollow node ignore convert insert item induction operation operation repetition insert delete min desire mlog acm transaction algorithm vol article publication date july finally regime construct expensive sequence operation construction generalize construction choice regime define inductively node rank hollow rank ith obtain link link expensive sequence operation building repetition expensive sequence operation arbitrary related consists obtain delete min succession node rank obtainable heap insert operation obtain variant construction exist remains throughout sequence operation decreasekey operation exist node hollow becomes node rank obtain ranked link node rank link participate insert operation node node finally additional insert operation delete min extra node delete deletion hollow delete min collection rank ranked link decrease finally link suppose expensive sequence operation decrease operation insert item node item situation delete min hollow delete remain delete min ranked link link unranked link sequence operation consists insert decrease operation delete min node operation operation built repetition acm transaction algorithm vol article publication date july hollow heap node label subtree denote subtrees node hollow solid dash denote ranked unranked link respectively  denote acm transaction algorithm vol article publication date july obtain perform decrease operation insert node label subtree denote subtrees node hollow solid dash denote ranked unranked link respectively  denote omit expensive sequence operation described operation operation whereas desire extension construction inefficiency regime instead decrease appropriate item reduce rank node item suppose positive non decrease function tend infinity decreasekey operation reduce rank node item rank initial node item extend construction decrease operation per amortize per decrease assume amortize per delete heap insert