minimum asks minimum cardinality node acyclic graph dag minimum dag width motivate application pan genomics genomic variation population express dag classical alignment algorithm exploit sparse dynamic program extend sequence dag mimic algorithm sequence minimum handle evaluation anomaly reachability query namely introduce framework dag extension sparse dynamic program framework algorithm counterpart sequence factor illustrate classical extend DAGs increase subsequence subsequence former obtain algorithm optimal classical variant input sequence model obtain analogous subsequence apply technique linear chain generalization algorithm involve ingredient FM index tailor alphabet dimensional modify maximum query sequence dag alignment formulation allows affine gap sequence ingredient propose framework algorithm minimum dag improve bound dag dense addition boost sparse dynamic program framework immediate consequence minimum algorithm improve tradeoff reachability query arbitrary graph CCS concept theory computation graph algorithm analysis pack dynamic program apply compute computational genomics additional subsequence linear chain  introduction acyclic graph dag node belongs disjoint minimum mpc minimum mpc width ofG DAGs commonly genome research graph encode variation graph model gene transcript consist former node latter node reference survey pan genomics approach however generally width average splice graph gene chromosome width knowledge mpc algorithm complexity width dag width algorithm obtain slightly modify algorithm minimum chain partial reference algorithm due chen chen max article mpc algorithm previous algorithm graph denser algorithm standard reduction minimum maximum proceed alignment admit efficient sparse dynamic program sequence extend DAGs complexity increase minimum namely improvement applies data structure previously compute maintain query compute mpc algorithm enables complexity generally extend careful bookkeeping due evaluation reachability node technique computes propagation link partial synchronize illustrate versatility technique compute increase subsequence LIS label dag optimal classical sequence model illustrate technique subsequence LCS label dag sequence demonstrate framework complex linear chain CLC introduce reference propose model sequence alignment massive input recent reference CLC input directly assume interval sequence exactly approximately acm transaction algorithm vol article publication date february sparse dynamic program DAGs width CLC alignment asks subset plausible maximizes coverage sequence increase sequence algorithm optimal define generalization CLC sequence label dag motivation mention align sequence entire chromosome dag variation population respect reference genome mention input interval sequence anchor dag straightforward topological dag reachability anchor exist align dna sequence DAGs  rely anchor technique potential impact algorithm propose CLC extension involve develop stage conclude alignment specific formulation framework admits affine gap LIS LCS limited variant CLC related extend DAGs graph node label minimum edit operation conditional bound already linear graph edit distance cannot compute constant unless exponential hypothesis seth fails quadratic boundary motivation sparse dynamic program sequence extend sparse dynamic program input dag obtain non sparse subsequence reference subsequence input sequence dag sparse dynamic algorithm logn logn sequence graph significantly non sparse notation simplify notation dag assume topological assume label dag tuple dag assigns node label alphabet label denote concatenation label node namely moreover node startpoint node endpoint node denote possibly empty node node denote node denote consecutive integer interval notation meaning interval denote respective endpoint access fix access summarize notation notion introduce later acm transaction algorithm vol article publication date february mäkinen notation article notation definition label dag dag assigns label alphabet node label dag label dag node node namely possibly empty lastreach PK dag lastreach node node node exists dag propagation link node node index lastreach index PK index update val leaf update val RMaxQ return  maximum query mpc algorithm assume familiarity network concept reference detail minimum graph source sink demand task minimum sum exit source satisfies demand feasible standard reduction minimum minimum reference creates  replace nodev  ofv finally reduction global source node global sink node demand demand minimum width decomposition source sink induces minimum mpc algorithm reduction minimum maximum reference feasible transform minimum feasible maximum capacity minimum obtain factor classical greedy algorithm reference chapter remain uncovered node lemma dynamic program lemma dag width compute PK proof algorithm uncovered node node acm transaction algorithm vol article publication date february sparse dynamic program DAGs width otherwise uncovered node compute dynamic program traverse node inverse topological  compute node maximum trace along optimal obtain update node iterate node overall algorithm analysis identical classical greedy approximation algorithm chapter universe implies induces shrink ford fulkerson algorithm successive augment bound combine lemma observation obtain theorem dag width mpc approach theorem minimum chain partial chain pairwise comparable algorithm reference feature logn chain chain uncovered reduces however apply algorithm DAGs timeO algorithm classical reduction fulkerson bipartite graph graph encodes relation DAGs transitive reduction compute transitive closure dag finally mention approximation refinement approach apply graph hop dynamic programming framework overview approach introduce technical notion aim feature easy benefit however sufficient correctness correctness application framework suppose involve DAGs solvable dynamic program traverse node topological assume partial node obtainable node dag plus independent another sequence furthermore suppose node query maintain data structure depends query TR query data structure nodev obtainable query TR query previous node necessarily disjoint express formula TR query TR query equation operation query min max conceptual illustration acm transaction algorithm vol article publication date february mäkinen conceptual representation decomposition node dag node dag marked node lastreach namely node decompose dash link node outgo link link obtain decompose graph PK perform computation along employ data structure TK processing node data structure concern node depends cannot node update correspond arbitrary node distinguish node exists node lastreach insight reference symmetrically identify node chain chain subsequence observation decomposition equation acm transaction algorithm vol article publication date february sparse dynamic program DAGs width observation PK dag lastreach exists lastreach otherwise lastreach exist proof reverse inclusion node PK lastreach lastreach therefore desire allows identify node propagation link node index lastreach illustration concept node incoming link propagation link decomposition compute update correspond data structure belongs propagate query decomposition node already correctly compute decomposition suffices apply operation lemma compute lastreach consequence propagation link dynamic program lemma dag PK compute lastreach overall proof node index algorithm actually computes lastreach index node lastreach algorithm lastreach precisely node cannot node traverse node topological node lastreach index otherwise lastreach max lastreach compute lastreach node incorrectly lastreach index lastreach index previous node namely lastreach index lastreach node immediate application theorem lastreach reachability query another application extension increase subsequence LIS label DAGs LIS subsequence LCS linear chain CLC anchor global alignment affine gap standard data structure reference lemma operation balance binary logn leaf acm transaction algorithm vol article publication date february mäkinen update val leaf update val RMaxQ return  maximum query moreover balance binary construct sort component exploit faster data structure summarize lemma operation lemma query semi infinite update increase data structure construct logn restrict version operation amortize logn proof recall van  boa maintain subset insertion deletion operation predecessor successor respectively operation logn reduction  maximum query auxiliary array initialize invariant contains semi infinite maximum query strictly increase series query RMaxQ predecessor predecessor exists maintain invariant update operation update val val val predecessor otherwise insert setV val delete succeed  deletion precede successor operation amortize update operation operation insertion throughout article assume data structure lemma initialize structure lemma implicitly initialize accordingly APPLICATIONS reachability query recall theorem lastreach constant node reachable node reference index index lastreach index define define proof lemma convention index recall reachability query arbitrary graph reduce reachability query dag strongly component node component pairwise reachable exist tradeoff reachability query corollary arbitrary graph width dag strongly component construct index reachable reference incorrectly attribute reference query consequence reference incorrectly mention query reference acm transaction algorithm vol article publication date february sparse dynamic program DAGs width previous comparable tradeoff reachability query construction index query reference article compile reference LIS increase subsequence LIS asks delete minimum input sequence remain strictly increase series input sequence assume alphabet input sequence alphabet unique optimal increase subsequence logn optimal comparison model computation improve integer alphabet ram model computation logn easily modify logn integer alphabet subset preserve mapping logn sort sequence relabeling rank distinct index input sequence LLIS define strictly increase subsequence LLIS compute dynamic program previous LLIS data structure lemma query RMaxQ definition LLIS LLIS  hence update decrease lemma feature subsequent algorithm omit mention sequel extension LIS label dag width subsequence label strictly increase subsequence explain extend previous dynamic program algorithm analogously subset preserve mapping recall assume topological assume compute node aim analogously compute LLIS strictly increase subsequence label subsequence data structure lemma update increase subsequence initialize LLIS algorithm proceeds fix topological assume already update associate update LLIS max LLIS RMaxQ algorithm topological LLIS update remains update  occurs update LLIS acm transaction algorithm vol article publication date february mäkinen LIS dag node label integer seek increase sequence label dag maxv LLIS actual LIS standard  algorithm theorem plug becomes assumption theorem summarizes theorem label dag width alphabet increase subsequence dag label model standard LIS algorithm lemma return complexity  bound standard LIS integer alphabet standard LIS algorithm logn bound restrict detail LIS instance dag node label link  namely link instead link incoming assume topological contains node node node compute LLIS perform update contains perform update along link exit link update LLIS max LLIS RMaxQ max compute LLIS perform update contains link drawn perform update along link exit link fromv tov update LLIS max LLIS RMaxQ max compute LLIS perform update contains perform update along link exit link update LLIS max LLIS RMaxQ max finally  link tov LLIS acm transaction algorithm vol article publication date february sparse dynamic program DAGs width LCS label dag sequence alphabet subsequence LCS subsequence label subsequence modify LIS algorithm minimally LCS  sequence denote node aim  subsequence label subsequence assume compute assume mapped sort binary label relabeling rank exception node label replace data structure lemma update subsequence initialize  algorithm proceeds fix topological node update array   max  RMaxQ update algorithm node update  maxv  actual LCS standard  algorithm assume theorem plug becomes theorem label dag width alphabet subsequence sequence namely bound improves nearly sparse dynamic program algorithm LCS sequence sequence respectively algorithm reference min min dominant subset sequence algorithm difference factor due data structure computation CO linear  formal definition linear chain illustration notion introduce reference linear chain CLC sequence alphabet subset maximizes coverage define coverage acm transaction algorithm vol article publication date february mäkinen linear chain sequence subset interval anchor interval sequence increase interval maximum input highlight optimal subset anchor reference illustration CLC sequence dag substring highlight optimal subset definition coverage sequence symmetric simply exchange role CLC dag sequence maximize coverage sequence dag former variant define precedence relation definition dag precedes node ing endpoint startpoint prefix overlap fully exists max extend formulation handle sequence dag illustration CLC  dag sequence label dag non negative integer interpretation label substring subset maximizes coverage analogously define coverage acm transaction algorithm vol article publication date february sparse dynamic program DAGs width illustrate technique article seek consecutive overlap dag prefix overlap challenge postpone overlap limited CLC  dag hypothesis subset non empty node node maximizes coverage trivial approach assume input endpoint topological arbitrarily denote maximum coverage subset theorem overlap limited linear chain sequence label dag input proof reverse node correspond endpoint preprocessing compute maximum coverage topological endpoint depth traversal startpoint reverse depth traversal predecessor whenever encounter node corresponds endpoint examine fulfills criterion coverage max coverage fulfill criterion coverage max inclusion compute incorrectly equally compute finally max depth traversal execute however significantly apply framework linear chain sequence revisit dynamic program algorithm reference sequence reuse algorithm mpc approach sort input coordinate sequence ensure overlap acm transaction algorithm vol article publication date february mäkinen sequence analogous theorem maximum coverage subset hence maxj maximum coverage equation invariant technique convert recurrence relation exploit maximum query lemma max RMaxQ max RMaxQ max correctly properly update update update compute illustrates optimal chain schematic chain extract modify algorithm  pointer theorem input optimal linear chain DAGs minimum modify algorithm DAGs technique article theorem label dag width input proof assume compute binary reminder correspond coverage overlap respectively sequence moreover recall consecutive graph overlap additionally recall initialize preprocessing node topological detailed algorithm node corresponds endpoint update  node propagation link   account endpoint loop propagation link computation previous account naive algorithm indirectly exception overlap graph omit statement propagation ensures query indeed reachable account  already compute  startpoint coverage update endpoint NK propagation link query endpoint update endpoint bound NK update acm transaction algorithm vol article publication date february sparse dynamic program DAGs width theorem plug becomes algorithm linear chain sequence dag input dag PK output index maxj lemma propagation link initialize associate update update respectively index respectively irst topological update update update RMaxQ RMaxQ max return  linear chain overlap extend algorithm developed overlap detection merge overlap reference tailor approach purpose FM index tailor alphabet dimensional modify maximum query former obtain coverage array input overlap input endpoint input node topological implies input already induction correctly compute modification sequence arbitrarily respect acm transaction algorithm vol article publication date february mäkinen dimensional maximum query interval split interval subtrees subtree lemma respectively index correspond subinterval modify reference interval maintain analogous mechanism linear chain algorithm cannot advance input dynamic interval account dimensional query illustrates query sufficient overlap account throughout algorithm execution trivial algorithm sum input construction actually induce input query sufficient algorithm input directly safely reorganize input accordingly introduction interval related jth obtain FM index version propose reference sequence alphabet denotes reverse purpose sufficient FM index interval correspond lexicographically interval operation backward index direction reverse backward interval backward non empty interval interval corresponds prefix corresponds input overlap prefix jth input interval coverage array rearrange input accord array lexicographic acm transaction algorithm vol article publication date february sparse dynamic program DAGs width backward index induce exactly interval dominate query however bound query claimed earlier alternatively omit expensive query overlap separately compute constant contribution another bound overlap overlap overlap input improve overlap generalize compute overlap advance proof theorem obtain theorem label dag algorithm theorem modify additional overlap input overlap overlap input alignment specific framework express framework alignment remove feature CLC gap model reference assume reader familiar concept alignment reference input sequence label input dag sparse alignment anchor compute global alignment alignment source sink alignment substitution subset alignment anchor initialization compute recurrence max substitution align gap function associate shortest framework applies gap define linear function gap affine gap model constant function equation max max max handle consecutive substitution sequence gap substitution sequence invariant trick linear chain detail analogous LIS LCS CLC algorithm equation approach assume compute data structure lemma initialize wavelet FM index bound later improve bound subroutine acm transaction algorithm vol article publication date february mäkinen update handle equation array initialize handle equation algorithm proceeds fix topological node update max RMaxQ update algorithm node update update max initialization handle alignment gap anchor substitution handle properly combine algorithm global alignment generalization  dag LCS replace anchor theorem label dag width alignment anchor compute maximum anchor global alignment sequence source sink affine gap discussion apply alignment anchor explain formulation alignment anchor sequence input usually maximal MEMs sequence retrieve linear largely retrieve MEMs sequence dag efficiently limited MEMs reference extension feature functionality practical anchor already incorporate conduct alignment sequence dag implement linear chain algorithm report preliminary experimental conference version article theoretical remains mpc algorithm benefit initial approximation faster compute generally remains overall bound mpc improve non sparse graph graph reference restrict DAGs NP hardness graph bottleneck extend sparse dynamic program framework handle cycle addition cycle dynamic program framework extend various gap model demonstrate framework applies affine linear gap input sequence remains handle complex function gap graph http github com anna   acm transaction algorithm vol article publication date february sparse dynamic program DAGs width finally sparse dynamic program framework sequence dag alignment dag dag alignment PA dag EA PB dag EB minimizes edit distance PA PB easily EA EB extend sparse dynamic program framework direction