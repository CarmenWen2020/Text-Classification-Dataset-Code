deterministic incremental algorithm exactly maintain minimum amortize per insertion query partially thorup contrast polynomial conditional bound fully dynamic minimum algorithm obtain combine sparsification technique kawarabayashi thorup recent improvement  rao wang incremental algorithm  efficient incremental algorithm minimum concretely exists logn monte carlo algorithm insertion empty graph probability algorithm maintains approximation minimum algorithm amortize update constant query inverse ackermann function CCS concept theory computation dynamic graph algorithm sublinear linear algorithm additional minimum connectivity efficient dynamic graph algorithm introduction compute minimum graph fundamental algorithmic graph although focus static efficient algorithm minimum dynamic maintenance minimum attract increase attention decade motivation dynamic apparent network social network undergo constant rapid initial graph goal dynamic graph algorithm data structure maintains update query operation update operation dynamic algorithm classify category fully dynamic update operation consist insertion deletion incremental update operation consist insertion decremental update operation consist deletion article incremental algorithm maintain minimum unweighted undirected graph denote operation insert insert  return approximate minimum algorithm approximation  return positive characterize query denotes query update denotes insertion algorithm amortize update update insertion empty graph hide polylogarithmic factor related decade static deterministic algorithm compute minimum due gabow logn kawarabayashi thorup devise algorithm applies unweighted undirected graph recently improve randomize monte carlo algorithm context static minimum initiate karger randomize algorithm due karger karger dynamic maintenance minimum generality devise fully dynamic albeit randomize algorithm maintain  minimum amortize per operation incremental update approximation ratio improve thorup karger improve upon precede guarantee achieve approximation factor amortize per operation  obtain guarantee incremental minimum ano amortize update approximation ano amortize update approximation ano logn amortize update minimum minimum polylogarithmic thorup fully dynamic monte carlo algorithm maintain minimum per operation obtain approximation arbitrary minimum bound comparison previous worth achieves update  sankowski dynamic maintenance minimum planar graph arbitrary obtain fully dynamic algorithm query update conditional bound dynamic recent   acm transaction algorithm vol article publication date march incremental min polylogarithmic amortize update conditional bound minimum assume online matrix vector multiplication conjecture fully dynamic algorithm  preprocessing simultaneously achieve update query technical overview incremental algorithm concern maintenance minimum algorithm apply undirected unweighted graph deterministic incremental algorithm exactly maintain minimum amortize per operation ando query allows partially affirmative regard efficient dynamic algorithm minimum thorup additionally contrast polynomial conditional bound fully dynamic minimum   obtain heavily rely recent sparsification technique developed context static minimum algorithm specifically graphG kawarabayashi thorup procedure contract vertex multigraph considerably vertex preserve motivate crucial observation entirely graph sequence newly insert increase minimum latter occurs recompute multigraph graph  iso logn maintain minimum appeal incremental algorithm due  technical contribution  combine algorithm formally argue combination desirable guarantee motivate recent efficient dynamic algorithm efficient maintenance minimum concretely logn monte carlo algorithm insertion empty graph probability maintains approximation minimum amortize update constant query although model allows constrain efficient dynamic model algorithm maintain explicit sparsifier information construct algorithm maintain sparsifier approximate minimum bound due compute spectral sparsifier witho logn ando amortize update comparison although update slightly achieve constant query whereas algorithm query preliminary undirected unweighted multigraph loop vertex exist disjoint graph vertex local connectivity vertex connectivity subset EG endpoint omit subscript context EG singleton refer trivial acm transaction algorithm vol article publication date march vertex belong component graph induced minimum minimum global minimum simply context minimum vertex menger theorem minimum global minimum vertex initial insert respectively sum initial insert moreover denote global minimum minimum graph respectively minimum upper bound connectivity subset contract vertex identify discard collection vertex denote graph obtain contract vertex contraction associate mapping subset correspond subset induced throughout probability denote probability positive constant sparse  review useful sparsification introduce nagamochi  definition  karger implicitly nagamochi  definition sparse connectivity certificate simply certificate unweighted graph vertex subgraph consists contains undirected graph maximal span decomposition msfd decomposition ofG disjoint span maximal span ofG  certificate msfd fulfills proof defer appendix lemma msfd graph integer nonempty subset subgraph implies min nagamochi  algorithm decomposition algorithm DA construct msfd refer DA msfd incremental minimum deterministic incremental algorithm exactly maintains algorithm update query applies undirected unweighted graph obtain carefully combine recent static min algorithm kawarabayashi thorup recent improvement due incremental min algorithm  acm transaction algorithm vol article publication date march incremental min polylogarithmic amortize update maintenance nontrivial vertex maintain nontrivial kawarabayashi thorup devise linear algorithm contract vertex input graph sparse multi graph preserve nontrivial minimum refer graph KT sparsifier recently improve construct bound define slightly generalize version KT sparsifier bound achieve algorithm definition KT sparsifier undirected unweighted graph vertex min multigraph KT sparsifier vertex preserve nontrivial obtain contract vertex theorem undirected unweighted graph algorithm construct KT sparsifier vertex whenever invoke algorithm construct KT sparsifier invoke algorithm theorem theorem undirected unweighted graph algorithm construct KT sparsifier logn vertex logn nontrivial concerned theorem implies instead ofG sequence newly insert satisfies incrementally maintain apply  algorithm verify correctness compute min  clearly insertion increase min min increase compute information previous precede perform efficiently cactus representation define shortly crucial observation whenever increase assume efficiently instead recomputing cactus scratch update intermediate structure remain previous cactus precise implementation minimum cactus representation introduce  frank concise proof cactus graph graph define mapping node exactly node node corresponds possibly empty subset min corresponds min min corresponds min odd cycle intersect node furthermore belong cycle whereas belonging cycle acm transaction algorithm vol article publication date march   cactus data structure    efficiently maintain cactus fix minimum insertion implies data structure efficiently min increase insertion summarize theorem theorem cactus algorithm maintains cactus fix minimum insertion reporting minimum increase attention efficient construction update cactus representation  construct cactus algorithm due gabow proceeds computes subgraph intersection compute cactus theorem cactus construction dependent compute theorem undirected unweighted multigraph assume algorithm computes cactus representation construct hence construct cactus bound gabow devise algorithm compute logn moreover algorithm incremental whenever input compute efficiently recomputing scratch precise statement bound theorem theorem undirected unweighted multigraph algorithm computes logn moreover sequence insertion increase minimum compute logn graph combine theorem cactus initial graph compute ino logn cactus graph minimum increase compute logn maintain trivial remark multigraph theorem preserve nontrivial trivial minimum achieve maintain minimum heap HG vertex vertex insertion perform endpoint update accordingly heap construct HG operation min HG  HG implement ino ando logn respectively algorithm correctness graph throughout execution algorithm correspond multigraph maintain algorithm recall preserve useful exists minimum union trivial useful update anymore trivial correctness algorithm correctly maintains trivial min algorithm correctly maintains acm transaction algorithm vol article publication date march incremental min polylogarithmic amortize update algorithm incremental minimum compute min heap HG vertex vertex compute KT sparsifier mapping VH compute min DA msfd cactus data structure theorem maintain cactus minimum operation query return min min HG insertion update cactus accord insertion update HG endif  min min HG rebuild compute compute KT sparsifier graph update min compute DA msfd cactus partial rebuild compute DA msfd update cactus theorem graph compute cactus min HG operation query return min HG update endpoint HG endif  goto endif goto useful min min HG fails rebuild lemma algorithm correctly maintains trivial min proof directly min heap HG simplify notation refer rebuild namely initial rebuild graph multigraph obtain invoke KT sparsifier rebuild suppose graph correspond multigraph acm transaction algorithm vol article publication date march undergone sequence insertion trigger execution partial rebuild rebuild execute multigraph partial rebuild insert algorithm maintains execution loop partial rebuild define sparsified graph algorithm maintains DA msfd graph multigraph rebuild preserve lemma multigraphs define earlier nonempty subset proof proceed induction partial rebuilds inductive fix define EH EH EH similarly define partition EH  distinguish assume construction induction hypothesis latter along lemma implies assume induction hypothesis along lemma implies induction hypothesis latter along lemma imply completes proof multigraphs minimum lemma assume min min proof non min non min contrapositive min min assumption lemma distinguish precede along implies cannot min direction min similarly lemma implies acm transaction algorithm vol article publication date march incremental min polylogarithmic amortize update chosen arbitrarily latter along imply min subgraph latter along imply inequality equality min min lemma graph multigraph maintain algorithm assume denotes min rebuild maintain algorithm satisfies proof execution partial rebuild suffices proceed induction partial rebuilds rebuild rebuild rebuild algorithm computes KT sparsifier preserve nontrivial min update DA msfd compute cactus construct lemma min min latter implies cactus preserve min preserve cactus algorithm correctly increment conclude rebuild correctly inductive induction hypothesis assume lemma min min DA msfd compute partial rebuild define lemma min  precede equivalence min min graph define algorithm correctly preserve min correctness cactus incremental cactus algorithm correctly increment conclude min graph partial rebuild precede lemma guaranteed algorithm execute partial rebuild however correctness algorithm execute partial rebuild crucial achieve bound lemma min min HG useful proof nontrivial ing cardinality strictly otherwise cannot minimum min min HG distinguish lemma algorithm maintains correctly obtain contract vertex VH cannot minimum inequality contraction acm transaction algorithm vol article publication date march min HG lemma min HG similarly cannot minimum ofG appeal precede conclude useful min trivial lemma graph algorithm correctly maintains proof graph multigraph maintain algorithm argue min min HG min min HG lemma useful exists minimum union trivial lemma guarantee algorithm correctly maintains min HG trivial minimum lemma ensures min min HG however min min HG min min HG implies min min HG min HG argue earlier algorithm correctly maintains min HG algorithm correctly maintains remains min min HG whenever happens algorithm performs rebuild rebuild min min HG trivially analysis theorem LetG graph node andm insert maintain minimum empty graph amortize per insertion iso minimum constant proof analyze building heap HG compute ando respectively recall  construct cactus dominate assumes execution algorithm increase define phase execute exclude rebuild additionally assumes algorithm define superphase consist rebuild along execute rebuild min min HG rebuild superphase consists sequence phase potentially moreover algorithm executes phase belongs superphase phase execute superphase remark vertex superphase remains unchanged lifespan denote vertex superphase bound quantity proposition superphase execution algorithm logn belonging superphase acm transaction algorithm vol article publication date march incremental min polylogarithmic amortize update proof theorem logn moreover phase execute whenever belonging superphase relation implies logn logn remain analysis correspond phase  superphase phase consists execution partial rebuild execution insertion phase theorem heap insertion perform logn phase logn logn logn sizeO  logn compute DA msfd partial rebuild logn proposition logn compute cactus spent phase denote minimum graph correspond multigraph respectively recall equation phase superphase consists execution rebuild along execution met rebuild compute construct cactus dominate logn throughout execution algorithm superphase whenever min min HG implies rebuild superphase whenever increase factor logn insertion  incremental minimum incremental monte carlo algorithm maintain min factor algorithm update respectively query algorithm whereas improves complexity logn algorithm algorithm approach previous maintain min achieve maintain sparse certificate incorporate incremental min acm transaction algorithm vol article publication date march algorithm incremental min initialize union data structure empty empty cactus minimum operation query return insertion connectivity null update cactus accord insertion endif endif  graph compute cactus goto algorithm due  described finally apply randomize sparsification due karger obtain maintain min incrementally maintain msfd unweighted graph union data structure maintains span recall disjoint insert define index append union return cannot simply discard return null refer procedure connectivity easy maintain connectivity newly insert indeed disjoint combine procedure technique  algorithm correctness precede algorithm immediate lemma query bound theorem  sake completeness proof corollary ano algorithm insertion empty graph maintains min empty graph insert  logn query constant inverse ackermann function proof analyze initialize union data structure construct building empty cactus dominate assumes execution algorithm increase define phase execute phase execution execution denote insertion phase connectivity endpoint newly insert update cactus dominate graph acm transaction algorithm vol article publication date march incremental min polylogarithmic amortize update algorithm min logn empty sample subgraph operation query minimum return insertion probability maintain min logn algorithm endif goto compute cactus logn combine precede bound spent phase logn phase  logn complexity algorithm maintain span execution min arbitrary corollary polylogarithmic amortize update min polylogarithmic min arbitrary sample technique due karger allows approximation min probability lemma graph minimum logn subgraph obtain probability independently probability   denote subgraph ofG obtain ofG  probability independently incremental algorithm theorem randomize algorithm insertion empty graph maintains approximation min ofG probability amortize update per operation iso query logn proof correctness algorithm integer graph insertion denote min logn EG integer lemma implies probability min logn latter along implication lemma minimum logn logn probability probability additionally algorithm return approximation min lemma acm transaction algorithm vol article publication date march logn sufficient maintain logn sample subgraphs algorithm applies unweighted graph apply union bound probability algorithm maintain approximation maintain sample subgraph logn corollary maintain logn subgraphs amortize per insertion requirement logn query scan logn subgraphs min query constant improve logn requirement previous algorithm toO logn without degrade sample subgraph instead logn unweighted undirected graph assume random chosen uniformly graph denote  unweighted subgraph ofG consists lemma due karger lemma logn graph probability approximation min proof uniformly distribute probability exactly graph contains probability lemma graph appropriate precede lemma min ofG bound probability instead graphG along random collection minimum disjoint span collection msfd lemma preserve minimum algorithm data structure NI sparsifier data structure graphG assign parameter devise insertion data structure maintains collection minimum disjoint span respect incremental maintain minimum span logn per insertion dynamic structure  tarjan  tarjan specifically data structure node maximum cycle induces minimum span max denote maximum update operation insert dynamic data structure belong link return null evict otherwise max latter return false otherwise replace maximum return boolean return indicates belongs acm transaction algorithm vol article publication date march incremental min polylogarithmic amortize update return longer belong insertion logn refer insert operation insert msf algorithm maintains minimum span implement operation initialize NI initializes data structure empty minimum span insert NI false null insert msf endif  return return null boolean return indicates belongs return remove recall abbreviation NI sparsifier refer data structure throughout algorithm associate refer version lemma graphG NI sparsifier maintains  insertion algorithm insert logn proof NI sparsifier maintains decomposition disjoint maximal proceed induction insertion decomposition empty disjointness maximality trivially insertion insert respectively denote union respectively insertion inductive assumption satisfies insert NI satisfies otherwise construction append exactly respectively denote maximal respectively insertion distinguish link maximal disjoint satisfies otherwise addition deletion another maximal disjoint apply argument addition remain conclude satisfies argue complexity dynamic data structure implement query regard max logn algorithm maintains requirement insertion execution insert msf procedure logn limited min data structure algorithm implement operation unweighted graph parameter insert limited executes insertion algorithm query limited return acm transaction algorithm vol article publication date march algorithm min logn logn logn empty graph initialize limited query limited operation query return query limited min insertion sample random denote  insert limited endif insert NI insert null remove endif endif  rebuild unweighted subgraph consist goto initialize limited data structure parameter execute algorithm insert limited abbreviation lim refer data structure combine precede data structure algorithm correctness analysis throughout execution algorithm corresponds exactly msfd maintain NI sparsifier graph input lim corollary query limited return min return formally correctness lemma logn assume algorithm empty graph query limited return rebuild trigger insertion increase proof algorithm empty graph throughout sequence insertion decrease induction  insertion choice graph empty graph insertion insert denote correspond graph insertion inductive assumption hence rebuild perform insertion exactly insertion increase rebuild query limited return trigger execution rebuild acm transaction algorithm vol article publication date march incremental min polylogarithmic amortize update analyze random variable randomly chosen unweighted subgraph contains lemma graph consist insert rebuild rebuild proof rebuild lemma rebuild rebuild immediately rebuild subsequent insertion trigger rebuild newly insert implies lemma rebuild msfd proof NI sparsifier maintains maximal span decomposition  span hierarchical decomposition induced NI sparsifier return exactly hierarchy insert NI sparsifier msfd min approximation probability random variable implies approximation lemma lemma probability logn proof rebuild logn logn denote index rebuild induction logn logn probability equivalent rebuild argue rebuild claimed probability lemma indeed unweighted additionally earlier rebuild probability combine bound yield logn rebuild logn analyze index rebuild assume insertion rebuild lemma rebuild  remain rebuild addition logn implies induction inductively assume rebuild logn probability  graphG insertion trigger rebuild  return rebuild insertion rebuild acm transaction algorithm vol article publication date march define gnew induction hypothesis probability logn logn gnew gnew lemma gnew gnew probability apply union bound previous statement simultaneously probability gnew   graph lim rebuild  implies gnew logn gnew gnew logn probability implies probability gnew choice remains gnew  rebuild graph proof lemma suffices subgraph respectively respectively graph respectively respectively rebuild insert instance lemma additionally lemma msfd lemma EG assume contradiction minimum implies lemma  contradicts assumption algorithm incremental applies unweighted graph insertion precede lemma implies graph algorithm return approximation min probability logn apply union bound graph probability algorithm maintain approximation mostO logn return approximation probability theorem logn randomize algorithm insertion empty graph maintains approximation min probability insert query constant proof requirement iso logn algorithm  lim NI sparsifier mostO logn corollary lemma algorithm executes rebuild lim data structure rebuilt NI sparsifier algorithm insert NI operation perform lemma operation involve NI sparsifier remains analyze corollary initialize limited acm transaction algorithm vol article publication date march incremental min polylogarithmic amortize update rebuild logn  throughout execution algorithm analyze remain query operation executes query limited operation constant insertion executes  operation amortize maintain balance binary insertion deletion logn insertion remain combine precede bound theorem appendix  PROOFS proof lemma argument closely nagamochi  helpful lemma lemma msfd  graphG proof fix argue contains indeed maximality graph cycle contains disjoint disjoint namely disjoint consist hence proof lemma assume definition preserve assume otherwise lemma EG  belongs lemma 