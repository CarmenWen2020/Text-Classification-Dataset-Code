recent significant progress explain apparent hardness improve upon naive fundamental polynomially solvable progress conditional bound reduction assume sum shortest orthogonal vector others min convolution goal compute sequence mini sequence easily algorithm article undertake systematic min convolution hardness assumption establish equivalence variant classic knapsack related subadditive sequence min convolution building algorithm notably  hoc hardness assumption investigate connection reduction explain replace assumption exponential hypothesis CCS concept theory computation dynamic program complexity reduction completeness additional grain complexity knapsack conditional bound min convolution subquadratic equivalence introduction hardness exist ingenious algorithm significantly improve upon naive approach complexity fundamental naive algorithm improve upon slightly extent explain  conjecture however naive approach polynomial algorithm  conjecture particularly useful polynomial bound recent significant progress establish bound conjecture  conjecture complexity bound conjecture conjecture algorithm sum implies hardness computational geometry dynamic algorithm conjecture algorithm  shortest APSP implies hardness graph radius graph median hardness dynamic survey related finally exponential hypothesis seth introduce extensively hardness parametrized recently polynomial bound via intermediate orthogonal vector bound edit distance subsequence others worth mention hardness computationally equivalent underlie cluster equivalent cluster correspond hardness assumption  papadimitriou NP develop polynomial algorithm NP without NP completeness proof without spirit conditional hardness polynomial landscape really recent background hardness MinConv article propose another hardness assumption MinConv MinConv input sequence task output sequence mini previously hardness assumption specific knowledge attempt systematically neighborhood polynomial complexity landscape precise definition assume input sequence consist integer APSP conjecture polylog factor definition subquadratic conjecture  algorithm MinConv definition introduction relatively technicality acm transaction algorithm vol article publication date january equivalent min convolution relationship popular conjecture reduction OV sum APSP contradicts nondeterministic version seth arrow strike occupy MinConv landscape establish hardness conjecture reduction conjecture MinConv reduction MinConv APSP MinConv reduce sum reduction proposition theorem detail appendix reduction sum APSP MinConv imply reduction sum APSP relation MinConv seth OV article category category consists classic knapsack variant essentially equivalent MinConv somewhat surprising recent progress bringmann subsetsum knapsack however bringmann algorithm efficient subsetsum built upon compose convolution implement efficiently fourier transform fft correspond composition operation knapsack MinConv detail category consists directly related MinConv decision version MinConv related notion  subadditive sequence idempotent MinConv unsurprising equivalent MinConv finally investigate previously related MinConv contribute reduction simplify exist moreover article publish independently  conference DEFINITIONS  RESULTS sum sum input integer task exist sum hardness assumption admits logn algorithm existence algorithm remains bound hardness sum algorithm sum slightly subquadratic logn polylog algorithm acm transaction algorithm vol article publication date january nondeterministic turing machine definition nondeterministic algorithm sum  equivalent convolution version randomize sumConv input sequence integer task exist sometimes restrict integer MinConv already define MinConv equivalent negate analogous MaxConv MaxConv input sequence task output sequence maxi contribution MinConv version already heavily however theorem proof MaxConv easy decision version herein max denote MaxConv sequence MaxConv upperbound input sequence task maxi replace latter maxi obtain MaxConv lowerbound another statement decision version asks sequence upper bound respect MaxConv superadditive perspective MinConv analogous subadditive equivalent negate computational complexity superadditivity input sequence task maxi standard convolution compute logn fft approach MinConv analog fft min semi tropical semi however due lack inverse min operation unclear transform exists sequence restrict convex sequence tropical analog fft namely legendre fenchel transform MinConv min convolution inf convolution  sum acm transaction algorithm vol article publication date january equivalent min convolution perform linear sparse variant convolution connection sum research dedicate improve upon algorithm MinConv logn algorithm MinConv reduction MinConv APSP theorem williams developed algorithm APSP obtain algorithm MinConv truly subquadratic algorithm MinConv exist monotone increase sequence integer bound chan  randomize algorithm deterministic algorithm exploit additive combinatorics random input MinConv compute logn satisfied compute relative error MinConv admits nearly linear algorithm FPTAS fully polynomial approximation scheme usually reserve output decision version NP technique reduction MaxConv upperbound sum appendix construct polylog algorithm nondeterministic turing machine MaxConv upperbound lemma algorithm MinConv nonuniform decision model technique fredman remains unclear transfer ram model knapsack knapsack input item integer capacity task maximum subset multiple item obtain unbounded knapsack decision version NP classical algorithm dynamic program pseudopolynomial knapsack unbounded knapsack output research FPTAS knapsack knapsack unbounded knapsack related MinConv sparsity input function parameter task maximum subtree sparsity admits algorithm restrict balance later generalize nearly linear FPTAS FPTAS MinConv algorithm sparsity entail subquadratic algorithm MinConv acm transaction algorithm vol article publication date january maximum consecutive  MCSP input sequence task output maximum sum consecutive trivial algorithm MCSP nearly linear FPTAS FPTAS MinConv knowledge explicitly proven  equivalent MinConv reduction superadditivity allows significantly simplify proof necklace alignment input sequence location bead task output alignment norm mod circular offset shift distance function necklace alignment sort sequence necklace assume sequence refer necklace bead distance bead define min minimum clockwise counterclockwise distance along circular necklace necklace alignment optimization manipulate parameter parameter  clockwise rotation necklace relative necklace parameter shift defines perfect bead necklace bead bead mod interested bound maximum distance bead emerge research geometry musical rhythm necklace alignment systematically various logn algorithm fft reduce MinConv slightly subquadratic algorithm necklace alignment context MinConv hardness interestingly hardness intrigue instead reduce necklace alignment related although input convenient integer sequence necklace algorithm MinConv application text algorithm  rahman reduce indexed permutation MinConv obtain algorithm MinConv obtain faster algorithm  described dominate MinConv later MinConv obtain faster algorithm decision version approximate  binary alphabet summary RESULTS illustrates technical contribution article reduction summarize acm transaction algorithm vol article publication date january equivalent min convolution summary reduction MinConv complexity arrow denotes reduction dash arrow previously arrow correspond arrow correspond theorem randomize reduction proof theorem theorem statement equivalent exists algorithm MaxConv exists algorithm MaxConv upperbound exists algorithm superadditivity exists algorithm unbounded knapsack exists algorithm knapsack randomize algorithm theorem split implication separately theorem theorem relatively statement version equivalence analogous implication subpolynomial improvement algorithm MinConv williams theorem version implication proof theorem independently reduction introduces essential technique vassilevska williams devote remain arrow theorem obtain alternative proof equivalence MCSP MaxConv MinConv simpler sparsity reduces MaxConv complement reduction observation equivalence necklace alignment MaxConv relation MaxConv sum implies conjecture seth exploit reveal connection replace hardness assumption unbounded knapsack seth precisely deterministic reduction acm transaction algorithm vol article publication date january unbounded knapsack assumption  PRELIMINARIES series admits algorithm timeT admits algorithm timeT  depends  input thatt knapsack parametrization function multiple argument article convention decision admits nondeterministic algorithm   assume input consists integer within conjecture oblivious polylog factor omit parameter  hide factor polylog sake readability  explicitly hide polylogarithmic factor respect argument herein max denote MaxConv sequence input increase reduction restrict function satisfy constantc justified focus function  reduction integer instance increase polylog account overhead perform arithmetic operation logarithm  theorem unbounded knapsack knapsack algorithm knapsack implies algorithm unbounded knapsack proof instance unbounded knapsack capacity item construct equivalent knapsack instance item multiplicity item chosen unbounded knapsack define binary representation vector induces knapsack described mapping invert implies equivalence instance prof superadditivity nonnegative monotonic sequence useful technical assumption simplifies proof lemma sequence transform linear nonnegative monotonic sequence superadditive iff superadditive proof sequence superadditive influence algorithm ensure nonnegativity guarantee monotonicity maxi otherwise acm transaction algorithm vol article publication date january equivalent min convolution sequence strictly increase nonnegative moreover equality theorem superadditivity unbounded knapsack unbounded knapsack superadditivity admits algorithm logn proof nonnegative monotonic sequence lemma construct unbounded knapsack instance item target obtain item construct instance superadditive superadditive exceed assume superadditive feasible knapsack item exceed optimal item lighter therefore optimal contains item superadditive replace item without decrease argument item lighter sequence monotonic profitable replace item heavier load exceed conclude optimal completes proof theorem MaxConv upperbound superadditivity superadditivity timeT MaxConv upperbound admits algorithm logn proof reduce instance MaxConv upperbound nonnegative monotonic sequence analogous lemma rewrite constant hence replace sequence equivalent instance  magnitude ensure nonnegative sequence monotonic sequence increase maximum herein assume sequence nonnegative monotonic  maximum sequence construct sequence exists therefore superadditive superadditive assume implies monotonic restrict assume finally superadditivity clearly corresponds MaxConv upperbound define acm transaction algorithm vol article publication date january graphical interpretation sequence theorem height rectangle proof reduction MaxConv MaxConv upperbound recently independently technique introduce vassilevska williams subcubic reduction min matrix multiplication detect negative graph theorem MaxConv MaxConv upperbound algorithm MaxConv upperbound implies logn algorithm MaxConv proof assume access oracle MaxConv upperbound max argue invoke oracle logn index exists violate superadditivity constraint satisfy index exists prek prefix sequence inequality prek max prek prek broken constraint binary inequality introduces overhead factor logn oracle violate index violate index interval potentially  violate constraint exist timeT logn translate index  violates superadditivity substitute constant exceed feasible sum analyze anomaly longer detect important index violate superadditivity  preserve oracle ensure violate index report sake readability pseudocode algorithm subroutine  return broken constraint none exist notation subsequence interval assume interval furthermore  hence repetition therefore procedure  logn algorithm maxi binary coordinate simultaneously procedure logw converge maxi acm transaction algorithm vol article publication date january equivalent min convolution algorithm   violate return violate corollary exists truly subquadratic algorithm MaxConv assume dependency proof algorithm violate additional  oracle parameter MaxConv truly subquadratic algorithm truly sublinear oracle cannot polynomially oracle linear polylogarithmic factor algorithm violate yield dependency reduction knapsack  observation unbounded knapsack item chosen multiple algorithm obtain standard dynamic program algorithm theorem exists algorithm unbounded knapsack proof algorithm discard item unbounded ignore item valuable item item standard dynamic program perspective parameter unless complexity exponent breakthrough MaxConv complement truly subquadratic algorithm MaxConv implies algorithm knapsack bringmann linear pseudopolynomial algorithm subsetsum adapt knapsack introduce concept related subsetsum previous observation substitute fft MaxConv consequently obtain algorithm knapsack  MaxConv acm transaction algorithm vol article publication date january subset sum recall subsetsum integer target integer goal exists subset sum horowitz sahni introduce notion subset sum later eppstein dynamic subset sum recently koiliaris develop algorithm subsetsum denotes sum later bringmann improve algorithm denotes target subsetsum subset sum define upper bound compute logu fft namely polynomial respectively compute polynomial logu polynomial nonzero coefficient iff easily extract koiliaris compute partition recursively compute fft koiliaris analyze algorithm lemma later bringmann lemma observation positive superadditive function function satisfy max logn sum knapsack adapt notion sum knapsack data structure capacity pack data structure implement array comparison implement binary vector emphasize knapsack denote array item partial compute denote max valid max  consists sum hence max max MaxConv array max denote MaxConv domain compute split cardinality disjoint subset recursively compute finally sum item lemma obtain logn algorithm recall naive algorithm MaxConv retrace bringmann obtain algorithm knapsack improves upon algorithm previous algorithm subsetsum bringmann technique layer splitting useful observation instance acm transaction algorithm vol article publication date january equivalent min convolution partition logn layer logn  partition infer otherwise cumulative sum technique application cod randomize algorithm compute sum combine technique bringmann developed algorithm subsetsum retrace knapsack context cod modify bringmann cod technique MaxConv instead fft obtain algorithm knapsack discus algorithm compute probability randomly partition item disjoint algorithm succeed partition lemma exists algorithm computes   probability constant  compute MaxConv algorithm  algorithm randomly partition max max return maxj proof split array exists conflict random max max contains item probability argument assume item probability item partition probability item forth obtain probability compute MaxConv repetition hence obtain algorithm layer splitting split item logn layer layer item logn layer  item item layer chosen quickly compute suffices compute MaxConv logn compute cod lemma exists algorithm computes entry probability acm transaction algorithm vol article publication date january algorithm  algorithm return  randomly partition  logm max return proof argument lemma split disjoint subset partition compute item probability lemma hence MinConv linear ultimately combine array binary compute max max max subset yield significant saving compute max max compute MaxConv logm complexity logm overall complexity algorithm logarithmic factor omit assume exists thatt correctness algorithm subset item  procedure guarantee sufficiently probability theorem knapsack MaxConv MaxConv knapsack logn probability proof obtain algorithm knapsack mention split disjoint layer  compute MaxConv pseudocode algorithm algorithm overall logn logn logn koiliaris variant subsetsum exists subset sum extension knapsack equivalent MaxConv definition knapsack acm transaction algorithm vol article publication date january equivalent min convolution algorithm knapsack algorithm split fori logn  logn  logn max return corollary knapsack MaxConv MaxConv int knapsack logn probability algorithm return array entry optimal probability obtain optimal knapsack capacity increase probability union bound consequently entry faulty probability upper bound entry incorrect introduces additional polylog factor finally completeness knapsack knapsack knapsack return capacity however knapsack interested capacity exactly corollary knapsack knapsack knapsack knapsack corollary reduction corollary algorithm knapsack implies algorithm knapsack PROBLEMS related  MCSP MCSP knowledge explicitly proven   equivalent MinConv reduction MCSP MaxConv completeness moreover reduction direction opinion simpler theorem MCSP MaxConv MaxConv MCSP admits algorithm proof input sequence construct sequence empty sum otherwise partial sum max max max maximum consecutive sum perform MaxConv acm transaction algorithm vol article publication date january theorem superadditivity MCSP MCSP superadditivity admits algorithm proof input sequence superadditivity translate min compute MCSP vector sufficient verify sparsity theorem sparsity MaxConv MaxConv timeT function superadditive sparsity admits algorithm proof advantage decomposition introduce  tarjan technique utilized transform nearly linear PTAS MaxConv nearly linear PTAS sparsity decompose spine construct spine define subtree node spine leaf remain node become analogous spine leaf intersects logn spine spine transition subtree node subtree compute sparsity vector index heaviest subtree compute sparsity vector spine recursively spine sparsity vector subtree zero vector interval max max max vector subtree  exists max operator associative hence max compute vector optimal subtree contains max max max max recall function definition formula reduce  subproblems interval merge max convolution proceed obtain recursion sum convolution logm recall thatt superadditive decomposition guarantee logn spine leaf moreover compute sparsity vector spine logn recursion recursion execute MaxConv procedure hence obtain acm transaction algorithm vol article publication date january equivalent min convolution schema spine decomposition spine spine efficient data structure MaxConv  bracket logn spine leaf necklace alignment necklace alignment alignment reducible MinConv equivalent MinConv necklace alignment tightly min convolution reduction related MaxConv lowerbound avenue expand equivalent MinConv however understand nondeterministic complexity MinConv elaborate issue theorem MaxConv lowerbound necklace alignment necklace alignment MaxConv lowerbound admits algorithm logn proof input sequence MaxConv lowerbound combination sum choice sequence formally definition combination combination sum combination assume input sequence assume sequence nonnegative guarantee appropriate positive constant assume combination sequence positive coefficient positive achieve artificially append sum influence MaxConv lowerbound instance combination positive bound nonnegative guarantee linear function sequence combination positive factor sum positive suffices acm transaction algorithm vol article publication date january correspond connection bead inner repetition sequence outer consists sequence sequence maximum absolute parameter previous inequality combination remain unaffected transformation increase define necklace bead implies monotonicity sequence combination zero distance plus necklace define maxi mod mini mod fix optimal min mod max max mod connection bead mod II IV formula combination bound apply combination indeed maximal distance minimum within combination occurrence distance  distance IV acm transaction algorithm vol article publication date january equivalent min convolution combination contains equivalent maxi exists MaxConv lowerbound sequence mink return finally exist already verify swap sequence inside necklace developed via index shift necklace analogous prior observation structure remain valid MaxConv lowerbound sequence guarantee conclude argument necklace alignment MaxConv lowerbound admit linear nondeterministic algorithm MaxConv lowerbound sufficient assign satisfied  inequality  necklace alignment define decision version alignment bound reducible via binary positive instance algorithm simply  induce optimal negative instance therefore suffices  mod mod MaxConv upperbound admits polylog nondeterministic algorithm lemma obstacle existence subquadratic reduction MaxConv lowerbound MaxConv upperbound however nondeterministic algorithm sum exploit technique significantly modular arithmetic potential reduction probably rely structural MaxConv nondeterministic ALGORITHMS recently subset sum cannot improve assume seth tempt analogous bound knapsack algorithm tight advantage nondeterministic lens introduce argue existence bound unbounded knapsack unlikely recall complexity nondeterministic algorithm refer bound nondeterministic nondeterministic routine instance belongs assume nondeterministic exponential hypothesis  cannot barrier nondeterministic algorithm informal rely  bound seth indeed admit hidden structure  researcher  deterministic reduction nontrivial nondeterministic algorithm allows argue situation hardness theory seth moreover disprove  imply nontrivial bound circuit  nondeterministic algorithm decision version unbounded knapsack target acm transaction algorithm vol article publication date january unbounded knapsack cannot deterministic reduction assumption  observation nontrivial nondeterministic algorithm sum entail MaxConv upperbound lemma MaxConv upperbound admits nondeterministic polylog algorithm proof combine theorem involves reduction MaxConv upperbound sumConv deterministic  reduction sumConv sum nondeterministic polylog algorithm sum lemma obtain analogous algorithm MaxConv upperbound careful complexity analysis nondeterministic algorithm developed lemma essentially bound input reformulation proof nondeterministic algorithm appendix completeness decision version unbounded knapsack additionally  multiset item theorem decision version unbounded knapsack admits nondeterministic algorithm proof assume instance  verify instance admits  proof involve array upper bound item sum verify proof nondecreasing item sequence define item  multiple item valuable otherwise latter equivalent max instance MaxConv upperbound bound sequence contains nonzero verify nondecreasing implies neglect zero sequence apply reduction theorem perform reduction obtain logw instance sumConv sequence additional knowledge index perform deterministic reduction sumConv sum omit index sequence obtain logw instance sum apply lemma  reduction preserve nondeterministic corollary nondeterministic algorithm theorem reduction seth unbounded knapsack unlikely corollary  deterministic grain reduction seth unbounded knapsack technical definition grain reduction definition acm transaction algorithm vol article publication date january equivalent min convolution CONCLUSIONS future article undertake systematic MinConv hardness assumption subquadratic equivalence MinConv superadditivity unbounded knapsack knapsack sparsity MinConv conjecture wellknown conjecture APSP sum MinConv equivalent APSP sum intrigue MinConv conjecture OV exploit algorithm MaxConv automatically obtain algorithm knowledge subquadratic algorithm superadditivity improves algorithm sparsity polylogarithmic factor although within scope article consequence bound knapsack  algorithm knapsack contradicts  conjecture algorithm contradicts MinConv conjecture algorithm another recently replace  conjecture seth subsetsum cannot exploit seth algorithm unbounded knapsack tight analogous regard knapsack remains finally MaxConv lowerbound equivalent MinConv imply equivalence necklace alignment MinConv APPENDICES reduction sum connection MaxConv sum conjecture reduction widely community knowledge explicitly appendix completeness article equivalence MaxConv MaxConv upperbound theorem sumConv  equivalent sum hence theorem suffices theorem MaxConv upperbound sumConv sumConv timeT MaxConv upperbound admits algorithm proof heavily utilizes proposition theorem completeness  denotes binary prefix significant statement proposition prefix alternately treat integer modify notation slightly integer lemma proposition integer iff exists prek prek prek exists prek prek prek prek prek prek prek prek prek acm transaction algorithm vol article publication date january proof theorem translate inequality MaxConv upperbound alternative logw equation logw construct instance sumConv related lemma sequence prek prek prek absolute prek prek prek otherwise prek prek prek otherwise prek prek prek otherwise satisfied unrolled formula contains summand cannot satisfied otherwise reduces inequality iff construct instance sumConv  instance logw sumConv  equivalent sum establishes relationship subquadratic equivalence nondeterministic algorithm sum lemma nondeterministic algorithm sum depends input however application function analyze regard parameter lemma nondeterministic algorithm sum maximum absolute integer assume proof triple  verify triple  prime prime  denotes prime integer mod mod mod triple satisfies modp instance exists proof false positive tuples prime triple distinct prime divisor therefore false positive bound candidate verify proof verify contains compute mod mod mod instance modulo indeed false positive instance acm transaction algorithm vol article publication date january equivalent min convolution bound fft logp