parallel load balance protocol client server distribute model define client server client constant request assign server client server via fix bipartite graph request client server neighborhood goal assign client request minimize maximum load server efficient parallel protocol available dense topology protocol raes recently introduce regular dense bipartite graph symmetric non adaptive protocol achieves constant maximum load parallel completion logn overall motivate proximity constraint arise client server analyze raes almost regular bipartite graph node neighborhood detail raes protocol performance maximum load completion complexity respectively almost regular bipartite graph logn analysis significantly departs cope non trivial stochastic dependence issue random choice algorithmic due sparse topology underlie graph keywords parallel balance allocation bin randomize algorithm introduction framework goal parallel load balance allocation client server distribute client server bipartite graph client request bound constant server client server assignment admissible proximity constraint client request server neighborhood algorithmic goal entity assign request parallel minimize maximum server load analyze performance propose protocol distribute task adopt standard synchronous distribute model introduce parallel bin client server autonomous compute entity exchange information introduce symmetric non adaptive protocol tight bound offs maximum load complexity completion complexity propose informally protocol symmetric entity anonymous client server moreover request destination chosen independently uniformly random protocol non adaptive client restricts fix possibly random candidate server neighborhood communication symmetric non adaptive protocol practical merit easy implement flexible application load balance communication network request schedule hash efficient symmetric non adaptive protocol dense regular bipartite graph almost tight bound important parallel protocol subsection description goal consist improve previous respect specific complexity aim efficient achieve bound maximum load focus symmetric non adaptive load balance protocol restrict non dense graph topology extension previous inspire network application previous client server accept request fix subset trust server client client server metric non random client server interaction feasible proximity constraint scenario motivate previous important sequential load balance algorithm knowledge efficient non dense graph available classic sequential model client request schedule instance choice strategy apply load server update assignment request assign server minimal load server chosen independently uniformly random raes algorithm parallel distribute model adopt propose symmetric non adaptive algorithm raes request link accept threshold criterion approach adopt context simulation pram algorithm distribute memory machine dmm collision informally raes consist phase client phase client alive accepted server selects server independently uniformly random replacement submits client phase server accepts request phase unless exceed limit accepted parameter suitable constant server saturate reject request phase algorithm completes client submit server boolean client request moreover algorithm terminates maximum load server regular bipartite graph raes terminates within probability contribution analyze raes algorithm bipartite graph recall satisfies almost regularity ratio maximal server minimal client bound absolute constant algorithm parameter sufficiently constant constant request raes terminates within formal definition almost regular graph formal statement theorem remark notion almost regularity allows variance entity non extremal bipartite graph client minimal server maximal algorithm analysis overview dense graph exploit analysis raes algorithm client server neighborhood fix sufficiently constant non saturate server neighborhood client thanks counting argument deterministically independently previous load configuration yield alive client request probability accepted allows logarithmic completion raes dense graph non dense graph node deterministically non saturate server fix neighborhood random variable importantly depends graph topology random choice perform node previous scenario analysis considerably harder dense cope issue variant raes saer accept exceed request raes exception whenever server phase overall load reject request phase becomes burnt server burnt accept request successive algorithm variant raes notion burnt server restrictive somewhat static saturate server raes allows analyze burnt server alive request rigorous moreover alternative analysis per couple raes saer implies completion former cannot stochastically latter thanks focus analysis saer algorithm similarly raes version terminates server load hence technical issue bound saer client assign server arbitrary client server neighborhood establish recursive formula describes decrease rate overall request neighborhood receives expectation derive conditioning sequence maximum burnt server client neighborhood algorithmic sufficiently conditional decrease rate exponential couple argument derive concentration bound rate conditional expectation magnitude argument stage anymore decrease rate burnt server increase along overall additive factor magnitude thanks request survive stage assign stage latter additional previous load balance algorithm extremely active research important application topic computer hash pram simulation schedule establish effective model classic bin typically assign bin framework previous related sequential algorithm bipartite graph thrown independently uniformly random bin maximum load bin bound instance breakthrough assume assign sequentially bin chosen independently uniformly random assign bin broken arbitrarily greedy strategy choice maximum load derive version model extend analysis greedy algorithm heavily load version sequential algorithm instance non uniform choice assignment moreover address heterogeneous bin recently bin analyze theoretic framework sequential algorithm restrict bipartite graph sequential algorithm restrict bin client server topology admissible cluster bin decides strategy accord load cluster choice previous   analyze sequential greedy algorithm client chooses server uniformly random assigns server minimum load greedy algorithm achieves maximum load  analyze sequential greedy algorithm input model random cluster server assign client algorithm detail client uniform random server prof random subset chosen accord fix almost uniform distribution server subset greedy algorithm achieves optimal maximum load overall bound overall server sequential framework adopt improve analysis greedy algorithm along direction detail weaker notion almost uniform distribution random server cluster assign client moreover input framework deterministic server cluster overall suitable version sequential greedy algorithm achieves maximum load greedy algorithm adopt server information client load application feature algorithm yield critical issue privacy security involve entity threshold approach adopt raes saer implement fully decentralize fashion client cannot approximation load server remark algorithm parallel algorithm bipartite graph inspire application arise parallel distribute active research focus computational entity communicate constraint specific version model protocol synchronous bin exchange message non adaptive symmetric protocol analyze performance maximum load message complexity instance introduce parallelization greedy algorithm constant constant random choice achieves maximum load complex greedy algorithm achieves maximum load interestingly performance offs essentially optimal restrict non adaptive symmetric algorithm threshold algorithm informally bin receives fix threshold excess reject chosen arbitrary parallel threshold algorithm introduce heavily load finally mention adaptive non symmetric protocol graph recent achieve significantly performance symmetric non adaptive strategy complex aim previous subsection analysis non adaptive symmetric protocol restrict client server topology parallel algorithm restrict bipartite graph rigorous analysis parallel protocol restrict client server topology aware raes protocol previous introduction preliminary load balance client server bipartite graph subset client subset server determines client subset server client request node client server denote define client arbitrary constant sequel request goal parallel distribute protocol assigns client server accord previous load balance fully decentralize computational model directional node communication along synchronous detail consists phase phase client sends unsettled alive selection server phase server accept reject remark algorithm model constrains client IDs server request accept reject moreover global label node node local label link analyze propose algorithmic respect fundamental complexity completion define protocol successfully assign client server overall define overall exchange message node network protocol execution protocol load balance performance analyze protocol load balance raes request link accept introduce variant raes saer accept exceed request non adaptive threshold criterion server accept reject incoming protocol organize consists phase sake readability client exactly request arbitrary fix constant analysis analyze performance raes variant saer protocol adopts restrictive assign server informally server overall threshold reject formal description saer algorithm algorithm image KB image algorithm protocol saer remark easily protocol description protocol client successfully within happens maximum load server clearly bound technical bound concentration completion protocol perform issue decentralize implementation knowledge parameter depends underlie almost regular bipartite graph theorem subsection server client knowledge global parameter interestingly implies security privacy server suitably client cannot approximation load theorem accord definition client server bipartite graph protocol raes saer technical contribution theorem performance saer raes constant sufficiently bipartite graph constant load balance request sufficiently constant protocol raes saer completion counting argument implies bipartite graph theorem almost regularity hypothesis remark allows relative variance node instance theorem topology minimum client maximum server client server minimal proof theorem saer theorem saer subsection upper bound burnt server logarithmic subsection easily logarithmic bound completion derive linear bound perform protocol burnt server theorem saer bipartite graph satisfies protocol saer crucial burnt server define notion important random variable algorithmic related server random variable server receives definition burnt server integer server burnt saer moreover client define burnt server neighborhood define maximum burnt node client neighborhood proof theorem relies upper bound burnt server logarithmic lemma burnt server hypothesis theorem constant subsection devote proof lemma proof lemma define random variable saer definition client overall server neighborhood moreover maximum server neighborhood receives formally burnt server expression inequality analysis definition client definition easily imply random variable elementary random variable definition client binary random variable alive saer accepted server equivalent random variable raes definition client server binary random variable random contact server saer equivalent random variable raes accord definition alive correspond random variable relevant evolution fix client random variable useful lemma random variable mutually independent choice positive random variable negatively associate proof observation saer non adaptive symmetric hence client chooses random destination request regardless latter determines request really iff request reject previous happens iff destination request burnt server finally moreover fix random variable independent analysis via induction bound maximum client neighborhood lemma hypothesis theorem probability proof random variable bernoulli random variable parameter lemma apply chernoff bound negatively associate random variable theorem obtain inequality sufficiently bipartite graph finally definition union bound proof lemma fix random derive client upper bound concentration random variable assume fix bound variable bound conditional bound sequence alive decrease factor explicit depends burnt server upper bound conditional fix upper bound lemma induction hypothesis theorem client moreover proof express sum apply lemma claimed bound concentration apply chernoff bound sum random variable aim bernoulli random variable parameter however distribution analyze correlation random variable cope issue exploit lemma construct hoc independent bernoulli random variable stochastically dominates formally thanks lemma define couple define couple uniform independent random variable define random variable previous random variable accord sort definition improperly denote random variable subset fix define define couple couple define marginal trivial independence random variable chain sort adopt definition easy couple satisfies indeed indeed derive inequality couple positive satisfies detail moreover apply chernoff bound negatively associate random variable theorem appendix indeed lemma imply random variable conditioning distribute bernoulli parameter negatively associate definition appendix wrap analysis stage lemma lemma decrease rate alive fix conditioning derive specific sequence effectively lemma moreover lemma allows sufficiently concentration bound expectation clearly effective concentration bound address issue split analysis stage roughly stage proceeds expectation characterize exponential decrease lemma lemma stage technical goal instead burnt node bound constant neglect decrease rate cannot anymore concentration bound random variable essentially analysis stage expectation subsequent burnt node bound constant hence alive request successfully assign stage sequence define recurrence appendix lemma sequence define recurrence increase lemma useful concentration bound random variable stage lemma stage decrease active hypothesis theorem integer exists proof apply lemma inequality union bound client inequality definition establish probability lemma ensure sufficiently integer hence indeed lemma verifies finally lemma stage II burnt server hypothesis theorem exists previous lemma define define recurrence proof analyze sequence sequence increase proof previous lemma integer lemma imply lemma union bound client definition remark analysis proof density hypothesis detail hypothesis constant weaker however hypothesis argument simpler lemma lemma imply lemma indeed chain inequality chain lemma lemma inequality binomial inequality conclude probability whereas probability performance saer proof theorem consequence lemma corollary assumption theorem protocol saer completion proof fix client parameter lemma implies probability accepted conditioning bound lemma apply union bound client probability conditioning saer completes probability analyze overall perform saer proceed approach analysis algorithm raes recall random variable introduce definition random variable counting request perform client plus relative server assign easily bound fix aim bound difference theorem appendix random variable conditioning alive function independent random variable satisfies lipschitz coefficient definition theorem indeed define random variable alive random variable server destination alive random variable mutually independent alive function satisfies lipschitz coefficient destination request destination impact switch symmetric argument lemma implies burnt node node neighborhood remains bound probability therefore apply theorem obtain chain alive decrease factor hence alive theorem remain alive assign within implies additional hence integer claimed linear bound complexity saer proof theorem raes analysis raes theorem proceeds introduce suitable couple saer raes couple implies upper bound saturate node raes burnt server saer lemma apply saer obtain bound derive performance bound raes analyze raes introduce random variable definition raes server receives server accepts within raes saer server accepts server reject saturate definition integer server saturate raes moreover client saturate server neighborhood define maximum saturate node client neighborhood establish upper bound saturate server raes introduce suitable couple saer raes couple saer raes raes saer client server graph initial client request informally aim maximum saturate server accord saer probabilistically bound maximum burnt server accord raes argument rigorous notion stochastic domination denote recall definition appendix equivalent lemma raes construct couple random variable couple non client server destination essentially accord couple easily alive raes saer definition random variable contact server saer equivalent random variable raes random variable independent server chooses server destination independently definition remark completely described random variable indeed destination server derive saturate burnt node reject request active define couple thanks random variable define couple introduce random variable definition client random variable destination chosen uniformly random definition couple saer raes client define couple couple client chooses server destination raes saer subscript random variable define joint probability couple define saturate server couple  lemma raes lemma saturate server hypothesis theorem probability saturate node raes satisfies proof lemma couple definition random variable stochastically dominate thanks lemma derive couple satisfies detail thanks lemma appendix suffices accord couple induction fix server saturate raes burnt saer client alive moreover node saturate iff burnt server definition definition couple identical assume server saturate raes burnt saer definition couple chooses destination induction hypothesis alive raes alive saer client equation implies server indeed moreover couple server saturate raes burnt saer indeed saturate server burnt saer implies saturate server neighborhood raes dominate burnt server raes performance analysis raes theorem consequence lemma formal proof proceeds saer subsection omit corollary assumption theorem protocol raes completion conclusion future parallel load balance protocol probabilistic analysis performance novelty client server bipartite graph sparse previous model important network scenario proximity trust issue restrict admissible client server assignment technical sparse topology yield probabilistic issue analysis challenge dense previous intrigue analysis protocol variant graph presence dynamic framework instance client request random topology protocol execution former remark lemma latter structure protocol manage dynamic scenario achieves  regime performance