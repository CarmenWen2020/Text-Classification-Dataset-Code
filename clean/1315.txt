steiner dst central combinatorial optimization theoretical computer graph  terminal output minimum arborescence contains recently grandoni  independently   quasi polynomial logğ‘˜  approximation algorithm tight popular complexity assumption bound steiner DB dst additionally bound vertex vertex output quasi polynomial logğ‘›logğ‘˜ logğ‘› bicriteria approximation algorithm logğ‘›logğ‘˜ optimum violates constraint factor logğ‘› non trivial guarantee nearly optimal violation factor logğ‘› logğ‘› factor away approximation bound logğ‘› hardness hardness bound steiner DB gst closing gap violation factor tight affirmative logğ‘›logğ‘˜ logğ‘› bicriteria approximation algorithm DB gst access auckland library introduction network central combinatorial optimization computer capture practical situation model network constraint attract researcher theory decade bound minimum span DB mst model multi cast network node broadcast bound sequence breakthrough goemans singh lau algorithm output optimum violate bound additive factor DB mst dedicate generalization bound steiner goal minimum subgraph connects terminal meeting bound bound  network node  disjoint literature recently bound network online besides standard network bound version steiner literature graph vertex collection goal minimum connects vertex bound steiner DB gst variant steiner bound vertex bound  feasible steiner generalizes steiner bound version generalizes bound steiner DB gst online negative approximate online DB gst simultaneously input graph specifically exists input demand sequence algorithm factor violation date non trivial approximation algorithm DB gst online offline zero  flexible network workshop bound variant classic network bound steiner DB dst formally DB dst vertex graph vertex terminal bound vertex goal minimum contains terminal respect bound vertex despite classic previous positive DB dst generalization DB gst barrier obtain non trivial approximation algorithm DB gst DB dst previous algorithm metric closure input graph metric embed height reduction technique lose subgraph  algorithm bicriteria  logğ‘› approximation algorithm DB dst quasi polynomial randomize algorithm bicriteria approximation algorithm DB dst output terminal vertex optimum violate constraint theorem randomize logğ‘›logğ‘˜ logğ‘› bicriteria approximation algorithm bound steiner logğ‘› knowledge DB dst non trivial bicriteria approximation technique expands upon recent grandoni  steiner algorithm easily extend bound nevertheless amend constrain framework concentration bound non trivial logğ‘›logğ‘˜ approximation factor almost tight due hardness steiner slightly improve hardness logğ‘› loglogğ‘› hardness logğ‘› violation factor output ignore DB dst almost tight guarantee violation factor logğ‘› logğ‘› factor away approximation bound logğ‘› hardness understand gap reduce DB dst obtain hardness construction namely bound steiner DB gst undirected subset vertex bound vertex goal minimum subtree vertex respect bound vertex  logğ‘› bicriteria approximation algorithm DB gst polynomial violation algorithm tight guarantee almost tight improves upon logğ‘›logğ‘˜ logğ‘›logğ‘˜ bicriteria approximation algorithm due   randomize algorithm guarantee violation theorem randomize logğ‘›logğ‘˜ logğ‘› bicriteria approximation algorithm bound steiner polynomial remark factor loglogğ‘› approximation factor DB dst slight increase however complicates algorithmic framework deliver algorithmic cleaner logğ‘›logğ‘˜ approximation ratio technique algorithm bound steiner ingredient optimum recursively partition balance sub assign sub structure recursive partition indirectly transform correspond sub contains vertex sub portal obtain improve approximation algorithm dst construct super contains sub reduce sub formulate linear program LP relaxation LP recursive procedure construction super LP technique extend algorithm DB dst portal algorithmic framework output multi vertex multiple procedure logğ‘›logğ‘˜ obtain multi violates requirement obtain bicriteria approximation analysis non trivial introduce technique concentration bound vertex multi summarize technique analyze bound factor requirement violate introduce technique transform graph vertex clearly bound introduce recursive transform graph computes vertex vertex correspond graph detail impose bound obtain equivalent graph maximum ensure bound satisfied portal construction leaf outgo vertex chosen leaf vertex recursively compute bound leaf valid satisfied bound detail finally existence multiple vertex multi bound vertex bound vertex multi expectation exponential random variable bound vertex logğ‘› constant probability combine technique dst obtain claimed bicriteria approximation DB gst technique algorithm gst bound indeed generalization random slightly boost branching probability constant factor almost affect bound probability vertex amplify dramatically drawback incurs handle amplify branching probability probability sufficiently inaccurate illustrate algorithm random vertex random branching direction simultaneously extra branching generates logğ‘› simultaneous random logğ‘› simultaneous random incur blown factor logğ‘› violation blown factor probability factor logğ‘›  logğ‘˜ difference algorithm  logğ‘˜ extra logğ‘› factor factor violation logğ‘› preliminary bound steiner notation assumption algorithm analysis DB dst arborescence denote vertex  denote denote descendant sub weakly sub graph arborescence sometimes refer vertex important clearly specify denote triple vertex denote parameter input digraph    assume terminal incoming outgo assume operation terminal satisfy vertex replace increase assume non terminal outgo extend definition slightly transform graph equivalent definition constraint transformation focus non terminal outgo replace outgo gadget binary leaf newly vertex  vertex outgo gadget naturally define unfortunately operation vertex address issue define transformation function vertex graph identically otherwise non internal vertex gadget define identity function compute vertex correspond recursively leaf  otherwise output ensure satisfy bound simplicity notation refer modify graph instead remainder text transformation graph consist outgo vertex transform subgraph vertex transformation hollow non leaf vertex label compute image balance partition algorithm proof elementary defer appendix lemma   vertex binary exists vertex    lemma partition     contains vertex contains vertex  assume imply leaf consequently           moreover   strictly sub balance partition procedure balance partition   vertex procedure partition later apply balance partition procedure recursively recursion contains multi define multi intermediate structure simply multi vertex definition multi input digraph multi   vertex  associate label label  label label vertex  vertex label  label label label contains exists  label extend function bound automatically multi vertex multi   label label multi   naturally define  multi vertex compute definition multi   multi leaf terminal vertex multi correspond subgraph image theorem DB dst theorem logğ‘› randomize algorithm output multi    opt opt optimum instance   contains logğ‘› logğ‘› exp  logğ‘› implies theorem proof theorem algorithm theorem obtain multi  logğ‘›logğ‘˜ output multi output remove becomes apply union bound terminal union probability theorem statement exp   logğ‘› exp logğ‘˜ inequality independently logğ‘› markov inequality exp  exp exactly  probability terminal vertex logğ‘›  union reflect graph sub graph contains terminal logğ‘›logğ‘˜ opt vertex logğ‘› arbitrary steiner output algorithm logğ‘›logğ‘˜ logğ‘› bicriteria approximation algorithm bound steiner algorithm logğ‘› organization remain organize define argue valid reduce linear program algorithm proof theorem dedicate proof theorem bound steiner DB gst optimum binary assumption DB dst apply balance partition recursively obtain decomposition partition balance partition procedure recursively partition obtain sub contains decomposition binary node corresponds sub due balance height logğ‘› throughout logğ‘› denote upper bound height decomposition thanks depth decomposition becomes however node corresponds sub optimum contains information algorithm handle instead extract information node node contains information sub afford enumerate node node decomposition information correspondent multi binary node satisfy consistency constraint establish direction connection multi valid sub definition related convenient optimum sub obtain recursive balance partition procedure definition however definition till fix valid sub portal contains portal definition vertex portal non terminal leaf portal obtain recursive balance partition procedure portal portal definition definition portal portal easy portal internal node decomposition satisfy definition definition allowable portal allowable motivates definition allowable assume contains sub obtain apply balance partition portal respectively allowable proof portal non internal vertex easy subtree subtrees correspond allowable portal drawn hollow terminal hollow subtree subtrees portal portal respectively image vector information vector definition vector vector integer supposedly definition consistency vector portal allowable vector respectively consistent vector consistent contradictory information definition triple vector portal vector agrees denotes define otherwise similarly portal vector triple agrees definition former define latter define identically argument definition corresponds recursive balance partition contains contains portal restrict portal similarly contains vertex vector define definition tuple portal vector tuple portal vector vertex definition binary depth node associate leaf associate triple  leaf agrees internal node allowable consistent terminal involve exists leaf leaf define define define  otherwise define define leaf remark bound ensure outgo vertex actually vertex leaf portal non portal outgo recursive definition compute bound correspond definition reduction valid involve terminal decomposition optimum involves terminal allude construct node decomposition formally obtain gen define algorithm algorithm vector vertex procedure purpose analysis algorithm lemma involve terminal proof satisfies definition trivially define parameter recursion gen restrict  exactly encode succinct encode capture boundary information portal encodes decompose subtrees decomposition allowable corresponds image multi focus direction reduction suppose goal construct multi moreover terminal involve contains multi construct associate leaf node recursive procedure node construct multi mapping vertex multi mapping satisfy label imply mapping construct focus leaf node define contains otherwise define contains define naturally internal node identify multi vertex obtain define mapping combination vertex vertex identify mapping define easy multi  straightforward involve contains vector consistent leaf agrees aggregate vector recover vector vertex multi   leaf procedure algorithm LP extend construction relationship multi establish focus involve terminal construct quasi polynomial corresponds sub satisfy roughly super potential however consistency define convenient insert virtual node internal node convenient leaf node node information formally construct correspondent node node internal node virtual node replace leaf node node information node node define  otherwise  super node extend correspondent clearly correspondence extend super potential extend formally super node  obtain union extend virtual node denote decompose subtree correspond node vertex portal portal along subtrees image immediate construction subtree extend happens super node exactly node node exactly node virtual node virtual node mathbf circ mathbf extend mathbf depth sub mathbf circ mathrm mathbf circ vertex involve mathbf node mathbf mathrm mathrm mathrm mathbf denote mathrm mathbf define sum node mathbf becomes extend mathbf circ involves terminal probability LP formulation formulate LP relaxation task mathbf circ node mathbf circ mathbf mathrm mathbf circ mathbf circ mathrm mathbf circ mathrm virt mathbf circ mathrm virtual node mathbf circ respectively super node mathbf mathbf bigl mathbf circ mathrm mathrm text mathrm mathrm  node involve mathbf target extend correspondent tau LP variable mathbf circ indicates mathbf align min qquad sum mathbf circ mathrm align align sum lambda mathbf circ forall mathbf circ mathrm cup mathbf align align forall mathbf circ mathrm virt lambda mathbf circ align align forall mathbf circ align align sum lambda mathbf circ cap mathbf forall mathbf circ align align sum mathbf forall align objective function LP minimize leaf mathbf super node mathbf exactly mathbf virtual node mathbf mathbf node mathbf terminal descendant node mathbf mathbf exactly leaf node mathrm mathrm mathrm constraint LP variable constraint mathbf imply mathbf imply node leaf mathbf circ non increase algorithm valid LP algorithm obtain mathbf subseteq mathbf circ induces algorithm difference node super node mathbf exactly mathbf algorithm independent decision algorithm formally described algorithm algorithm simply mathrm mathbf straightforward induced mathrm mathbf extend mathbf circ lambda mathbf circ mathbf random return mathrm mathbf frac apply mathbf mathbf circ mathrm induced mathbf exactly mathrm theorem algorithm theorem mathbf random return mathrm mathbf terminal align mathbf cap mathbf emptyset frac align theorem algorithm  however adapt analysis slightly algorithm straightforward omit proof theorem wrap proof theorem theorem LP obtain mathrm mathrm mathbf mathrm tau mathrm mathbf leftarrow mathrm mathbf algorithm mathbf induced mathbf extend tau correspondent mathbf multi construct procedure multi mathrm theorem probability involve omega algorithmic framework polynomial mathbf circ allowable cup cup node mathbf circ mathbf simplicity super virtual node counting node mathbf circ mathbf circ maximum node rho rho cdot allowable choice split fix allowable vector rho rho rho rho consistent rho rho rho max possibility virtual node cdot cdot max mathrm poly node height mathbf circ bound mathrm poly LP algorithm proof theorem concentration bound vertex finally theorem fix vertex vertex mathbf circ sum lambda mathbf circ cap mathbf constraint lambda mathbf circ cap mathbf cap mathbf node lambda mathbf circ cap mathbf algorithm typical introduce parameter expectation random exponential variable mathbf mathbf constant bound mathbb mathbf mathbf induction proof convenient definition node mathbf circ maximum mathbf circ leaf internal node mathbf circ plus maximum define alpha integer alpha mathbf alpha mathbf alpha forall alpha alpha cdots increase sequence induce lemma lemma node mathbf circ mathbb mathbf mathbf alpha proof lemma induction leaf mathbf mathbb mathbf mathbf alpha mathbf mathbb mathbf mathbf mathbf alpha lemma integer assume lemma focus node virtual node mathbf implies mathbf handle independently algorithm align mathbb mathbf mathbf prod lambda mathbf circ mathbb mathbf mathbf prod lambda mathbf circ frac cdot mathbb mathbf mathbf frac prod lambda mathbf circ frac mathbb mathbf mathbf align super node node sum lambda mathbf circ mathbf procedure exactly mathbf align mathbb mathbf mathbf sum lambda mathbf circ frac mathbb mathbf mathbf sum lambda mathbf circ frac mathbb mathbf mathbf prod lambda mathbf circ frac mathbb mathbf mathbf align inequality alpha theta convex function theta upper bound theta alpha interval theta summation allows bound frac frac alpha frac alpha sum lambda mathbf circ frac cdot frac frac quantity inside exp cdot maximum frac alpha equality definition alpha theta theta frac inductively lemma lemma alpha frac proof definition alpha mathbf frac statement assume statement align alpha mathbf alpha mathbf frac frac frac frac frac align inequality induction hypothesis theta theta theta theta lemma mathbb mathbf mathbf alpha frac frac proof theorem bicriteria approximation algorithm bound steiner theorem theorem randomize bicriteria approximation algorithm bound steiner polynomial notation theorem recall circ input circ denotes vertex circ denotes circ simplicity assume vertex instead vertex circ indexed subseteq circ leaf circ assume disjoint vertex bound goal output subtree circ satisfies constraint contains vertex circ notation descendant vertex circ lambda denote circ lambda denote descendant circ LP relaxation vertex circ chosen correspondent integer program LP valid LP relaxation DB gst align text min qquad sum circ qquad text align align qquad forall circ lambda align align sum qquad forall align align sum cap lambda qquad forall forall circ align align sum lambda cdot qquad forall circ align align qquad forall circ align correspondent integer program objective minimize sum circ  constraint vertex constraint exactly vertex constraint chosen vertex lambda cap chosen constraint constraint LP relaxation constraint imply modify LP LP obtain optimum LP circ algorithm convenient non positive integer modify LP operation violate LP constraint slightly circ frac decrease easy constraint violate constraint sum frac frac remove vertex instance assume frac circ increase non positive integer violate constraint LP factor vector circ circ integer frac along leaf circ non increase sum frac sum cap lambda circ sum lambda circ sum circ cdot mathrm opt mathrm opt optimum integer algorithm algorithm define important global parameter lceil rceil gamma lfloor rfloor lambda hop vertex circ define ell sum hop circ circ lambda ell ell ell ell ell circ algorithm apply define align min ell gamma text circ align mention introduction increase probability factor circ lambda ell ell gamma important recursive algorithm circ lambda proof hop ell ell otherwise min gamma min gamma therefore integer recursive algorithm procedure recursive output lambda probability independent choice recursive recursion recursive algorithm recursive procedure independently cdots obtain repetition union analyze focus easy probability chosen exactly gamma therefore cdot mathrm opt therefore ML cdot mathrm opt cdot mathrm opt cdot mathrm opt analyze constraint probability frac frac sum lambda frac sum lambda frac cdots summation independent random variable expectation summation cdot chernoff bound probability cdot frac factor therefore probability node cdot therefore violation factor algorithm claimed theorem analysis connectivity probability remains probability contains vertex goal till focus fix vertex circ define mathbf chosen goal bound  mathbf probability vertex chosen adjacent node circ chosen whenever contract sub node circ super vertex without algorithm adjacent vertex circ lambda ell ell contract maximal sub vertex circ ell operation circ ell exactly circ circ lambda ell ell super vertex vertex contract internal super vertex remove descendant without analysis contains leaf vertex define align sum cap lambda align bound  cap lambda mathbf mathbf circ stage due threshold gamma define variable ell gamma focus ell gamma stage capture lemma respectively lemma vertex ell gamma  cap lambda mathbf mathbf frac ell frac lemma multiple previous parameter slightly proof approach lemma bound conditional random variable chosen vertex cap lambda mathematical induction ell proof lemma suppose leaf otherwise  cap lambda mathbf mathbf frac lemma clearly ell lemma induction ell ell leaf lemma assume lemma ell ell ell gamma lemma ell ell leaf lemma assume leaf align  cap lambda mathbf mathbf prod lambda frac cdot frac ell frac prod lambda frac cdot frac ell cdot frac prod lambda exp frac ell cdot frac exp frac ell cdot frac frac ell cdot frac frac frac ell cdot frac frac ell cdot frac frac ell frac frac ell ell frac frac ell cdot frac align inequality induction hypothesis frac probability frac ell frac bound probability vertex cap lambda chosen equality gamma gamma inequality theta theta theta inequality theta theta frac theta theta inequality frac inequality ell cdot ell ell ell lemma implies ell gamma  cap lambda mathbf mathbf frac cdot frac analyze probability ell gamma recall gamma lfloor rfloor gamma alpha gamma frac ell gamma define alpha ell alpha ell alpha ell easy ell gamma alpha ell frac gamma ell ell gamma align alpha ell alpha ell alpha ell alpha ell alpha ell alpha ell frac gamma ell alpha ell frac gamma ell align therefore align alpha gamma prod ell gamma frac gamma ell alpha gamma frac gamma prod ell gamma gamma ell frac gamma gamma omega align inequality theta theta theta equality gamma lfloor rfloor gamma theta alpha define lemma via mathematical induction lemma vertex ell ell gamma  cap lambda mathbf mathbf alpha ell frac proof lemma ell gamma mention assume ell gamma lemma ell replace ell leaf  cap lambda mathbf mathbf frac lemma assume leaf align  cap lambda mathbf mathbf prod lambda frac alpha ell frac prod lambda frac alpha ell frac prod lambda exp alpha ell frac exp alpha ell frac alpha ell frac frac alpha ell frac alpha ell frac alpha ell frac alpha ell frac align equality ell ell lambda inequality argument lemma apply lemma circ  mathbf alpha cdot frac alpha cdot frac omega cdots probability chosen omega frac probability union cdots contains