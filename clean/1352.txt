encode dimensional array query aim obtain encoding information theoretic bound construct efficiently array propose encode query query restrict propose encode query generalizes joint cartesian trivial encode encode addition upper bound encoding bound encoding query upper bound almost optimal introduction dimensional 1D array query return refer query query query query extend definition dimensional 2D 2D array query return without loss generality assume distinct lexicographic assume query report sort query report sort correspond unsorted query report arbitrary query query query query query query encode model model construct data structure encode query access data structure without access input array minimum encode refer effective entropy input data aim obtain encoding effective entropy construct efficiently denote context unless otherwise mention assume query sort query finally assume standard ram model footnote previous encode 1D array query widely recent commonly maximum query rmq extensively application fischer  propose optimal data structure rmq query 1D array constant 2D array trivial encode rmq query rank encoding query extra encode joint cartesian extend encode obtain encode query trivial encode propose data structure query constant finally obtain optimal encode query although query efficiently propose data structure encode 1D array query constant later improve   optimal although query efficiently 1D array propose encode sort query query   propose  encode query although query efficiently encode query propose data structure query strictly increase function 2D array query rank query efficiently encode exist orthogonal reporting data structure 3D coordinate rank coordinate correspond reporting sort rank however 3D orthogonal reporting data structure linear sort query detail  tao data structure query data structure super linear query knowledge encoding query 2D array summary upper bound encoding 2D array array sufficient sort query unsorted query sufficient bound strictly encode sort query 2D gap encode query sort unsorted contrast 1D encode query sort unsorted asymptotically encoding simply construct min heap data structure sect encoding query array obtain data structure query combine propose alternative encode trivial encode sort precise sufficient sort query array encoding sort query encode obtain binary dag query array generalizes encode query array propose encode joint cartesian corresponds dag additional independent extend encode array obtain encode query array improves upon trivial encode generalizes encode query trivial encode input array whereas easily bound encode array query query query parameter strict improvement trivial encode gap partially achieve strict improvement sect obtain data structure query exists encode sort query 1D array encode data structure query efficiently encode query finally sect array bound additional unsorted sort encoding query additional unsorted query encoding unsorted query bound bound unsorted query array additional sort query encoding unsorted sort query bound imply encoding optimal within bound encode array query individual summarize encode query dimensional array encode sort unsorted query 2D array denote 2D array sort query introduce encode simply extend encode sort query 1D array propose propose optimal encode sort query 1D array define another 1D array define exists satisfies otherwise rightmost occurrence along additional auxiliary structure obtain encode query 2D array encode sort query 1D array encode described encode proposition 2D array encode sort query optimal encode sort query 1D array define another 1D array otherwise query rightmost rightmost finally return therefore sort query sort exist extend encode sort query 2D array obtain optimal encode theorem theorem 2D array encode sort query bound asymptotically optimum proof define define sequence otherwise exist sequence entry sum sort query procedure rightmost return query otherwise return return sort correspond apply procedure sort query described upper bound encode sort query suppose distinct sequence sort encoding 2D array respectively definition array distinct sequence array completes proof theorem without loss generality suppose reconstruct rightmost assign assign rightmost discard assign procedure assign correspond assign remain remain assign contains procedure encode encode proposition unsorted query encode unsorted query 2D array unsorted lexicographic array unsorted query query implies unsorted query query convert unsorted query unsorted query 1D array obtain another encode unsorted query optimal query concern theorem 2D array data structure unsorted query moreover bound asymptotically optimal proof upper bound separately encode unsorted query correspond along unsorted encode unsorted hence encode query decode decode unsorted query decode unsorted query obvious within query therefore extra unsorted query encode query encode described query query unsorted procedure difference report sub array  query bound upper bound theorem bound without loss generality suppose array array exists unsorted statement induction assign unsorted assign remain arbitrary query array query assume inductive hypothesis statement array satisfy statement inductive arbitrary array none assign integer unsorted query remain chosen assign delete easy unsorted assign remain chosen finally assign remain arbitrarily unsorted query array unsorted unsorted therefore statement whenever prof theorem construct encode theorem maintain min heap precisely insert delete minimum heap heap scan heap insertion remark encode sort unsorted query respectively 1D array   requirement asymptotically contrast 2D array theorem implies gap encode query sort unsorted 2D array significantly 1D array encode query array encode query 2D array query concern data structure simply trivial encode query rank sort introduce data structure query rmq encode proposition 2D array exists data structure unsorted proof data structure outline  heap selection algorithm unsorted query 1D  encode rmq maximum query constant rectangular encode rank maximum rmq query ary heap obtain procedure heap subtrees recursively construct ary heap sub array respectively ary heap algorithm propose  algorithm heap node subgraph ary heap introduce alternative encode query 2D array trivial encode overall sufficient sort query encoding sort query encode obtain encode binary dag define later extend encode array obtain encode query encode trivial encode encode sort array assume sort encoding already query joint cartesian joint cartesian construct conceptual binary analogous cartesian maximum splitting correspond node maximum recur  extra node conceptual binary query encoding detail sort query extend joint cartesian dag structure denote define node label interval refer sort query node label define array dag image label node label node leaf node suppose exists non leaf node label leftmost rightmost index respectively node node label similarly node node label lemma useful lemma array statement distinct node distinct node descendant interval exists unique node satisfies label descendant furthermore node proof construction node label implies suppose distinct node label contradict analogous construction descendant suppose node descendant exists node satisfies descendant label contains neither label otherwise exists satisfies imply contradiction lemma exists unique node contains interval none label label contains index easy exists node label contains suppose exists another node label label contains lemma otherwise descendant contradict suppose analogous exists node label contradict unique suppose exist contains without loss generality assume handle label contains contradict lemma dag sort query correspond node sort query correspond node satisfies encode encode node assign node assign traverse node enable query correspond node node previous specifically node encoding individual lemma encode query however exists node lemma encode independent skip redundant node node node information obtain already traverse node without extra information modify modify later encode accord modify encode skip redundant node traversal modify node label label satisfy node precedes node node label node multiple dag contains respectively already candidate node already candidate node suppose analogous candidate node candidate node encoding overall procedure modify traverse node modify classify node unvisited node unvisited traversal node traverse node node denote label modify traversal image node information query modify information picked node combine node traversal node node query thesis assume encoding suppose unvisited non node modify candidate picked node extra handle similarly candidate another candidate information extra lemma bound information picked node lemma array dag node proof non leaf node label non leaf node node suppose modify traversal therefore without loss generality assume easily correspond construction algorithm therefore node contradicts usage encode independent suppose exists non node candidate candidate distinct modify prior node although ancestor lemma bound encode picked accord modify encode independent lemma array dag picked twice traverse node modify proof suppose query distinct node query node ancestor node modify traversal algorithm traverse therefore without loss generality assume node suppose exists node node another candidate modify traversal algorithm contradicts assumption traversal accord modify picked node respectively indicates picked theorem theorem array exists encode sort query 1D array encode construct construct encode construct query proof sort query query lemma encode sort query correspond node encode traverse dag traversal initialize information query namely respectively traverse modify node whenever node traversal algorithm described node append candidate lemma candidate node encode query individual pre node node finally candidate picked node therefore whenever traverse node sufficient encode query traverse node twice modify node lemma construct encode lemma traverse node decode query correspond node construct whenever node label traversal algorithm described decode unvisited decode unvisited easily former traverse node candidate unvisited node candidate already picked node without loss generality assume picked extra information node decode encode modify easily encode therefore encode query extra sort query theorem bound encode theorem improve theorem array exists encode sort query 1D array encode construct encode query proof define proof theorem construct node traverse modify picked picked prof theorem respectively respectively suppose label node modify picked traverse algorithm definition already picked picked implies descendant label definition picked node label suppose picked node without loss generality precedes node definition ancestor descendant implies hence cannot picked node picked node picked twice lemma implies picked encode theorem theorem obtain encode sort query array extend encode array theorem array exists encode sort query 1D array encode sort query proof sort query encode query array respectively theorem encode query array extra query query define query correspond query suppose increase procedure iteratively corollary array exists encode sort query 1D array encode sort query finally combine encode theorem   optimal encode sort query 1D array obtain encode corollary array exists encode sort query exists encode sort query data structure query array encode theorem sufficient query span encoding sort query however encode query efficiently reconstruct node query query improve additional simply data structure encode 1D array query 1D array obtain query additional although data structure query asymptotically integer sufficiently data structure query array image define graph vertex exists correspond vertex satisfies define graph analogous replace respectively graph vertex vertex resp exists vertex resp incident graph exist lemma array graph graph proof suppose minimum definition correspond contradicts definition lemma succinct representation graph   minor modification described encode vertex vertex index incident maintain finally resp maintain another resp resp resp resp encode sort query encode additional array define query theorem array exists encode sort query 1D array data structure query proof sort query query maintain succinct representation resp resp encode query resp resp procedure iteratively query procedure comparison already suppose instead respectively procedure vertex index incident exists vertex incident definition correspond however cannot correspond therefore definition definition correspond however cannot vertex incident therefore query encode procedure iteration query bound encode query array bound encode array unsorted sort query specifically bound extra unsorted query assume access encoding individual unsorted query sort query assume access encoding individual sort query unsorted query extra unsorted sort query extra simplicity avoid ceiling avoid boundary assume odd bound extra query bound extra query former unsorted sort query assume distinct sort ascend finally define mapping unsorted query theorem bound unsorted query array encoding unsorted query already bound bound unsorted query array theorem array encoding unsorted query additional unsorted query proof extra unsorted query suppose array satisfies sort ascend array encoding unsorted query individual distinct array exists definition distinct array exists distinct unsorted query implies bound additional query array compute exists sort ascend construct array construct array respectively distinct array respectively satisfy maintain sort ascend furthermore without loss generality assume respectively distinct therefore array respectively satisfy maintain sort ascend statement described obtain recursive relation recursive relation characteristic equation obtain prof theorem sort query array array sort exists array sort ascend implies array encoding unsorted sort query individual central binomial therefore additional sort query span encoding sort unsorted theorem array additional sort query encoding sort unsorted query conclusion propose encoding query 2D array array propose upper bound sort unsorted query finally obtain encode sort query array sort query efficient query array obtain improve upper bound sort query array denote entropy binary density zero another structure sort query bound