compress representation compression standard comparison pointer machine model computation efficient prefix query namely preprocess alphabet compress data structure optimal determines prefix query optimal regardless data structure exist rely ram technique tabulation hash address arithmetic parallelism hence pointer machine pointer machine achieves along develop data structure pointer machine independent optimal data structure random access grammar compress optimal data structure variant ancestor introduction compactly efficient prefix query prefix efficient fundamental data structural date component application computational biology data compression data mining information retrieval processing challenge focus recent efficient compress advantage repetition minimize efficient query efficient rely powerful ram technique tabulation address arithmetic parallelism hash etc achieve efficient bound technique obtain efficient compress simpler computational primitive pointer data structure comparison suffice affirmative introduce compress compression standard comparison pointer machine model computation achieve bound alphabet query compress discussion query information theoretic bound query optimal comparison query algorithm regardless previous model computation computational model computational model comparison model algorithm interact input hence cannot exploit internal representation input hash parallelism comparison model fundamental computational model textbook sort computational geometry program library standard template library implement comparison algorithm abstract user specify comparison function function argument context comparison query algorithm access input via comparison pointer machine model data structure graph bound node contains constant data pointer node algorithm access data structure traverse graph hence pointer machine algorithm cannot implement random access structure array perform address arithmetic pointer machine capture link data structure link pointer machine model classic model finally ram model computation memory array memory logarithmic memory standard arithmetic operation boolean operation shift ram model strictly powerful comparison model pointer machine model random access hash address arithmetic parallelism etc model data structure ram model memory pointer machine model node model assume node pointer machine logarithmic hence model within constant factor previous classic textbook due fredkin trie prefix query traversal label outgo node manage prefix otherwise representation trie model computation obtain combination complexity comparison pointer machine model computation outgo bias query compress merge maximal identical subtrees replace acyclic graph dag query dag exponentially compress instance label correspond highly compressible label identical subtrees hence dag ram model improve representation succinct representation achieve query simultaneously achieve optimal query information theoretic bound rely powerful ram technique obtain bound tabulation hash numerous trie representation ram technique achieve optimal combination another approach compress accord various repetitiveness empirical entropy lempel ziv parse grammar encode burrow wheeler transform others query fischer straightforward adapt prefix query lempel ziv parse concatenation   implies query exponentially significantly improve highly compressible almost optimal information theoretic bound bound repetitiveness succinct representation ram technique propose compress achieves bound theorem alphabet comparison pointer machine model computation construct compress query bound theorem information theoretic bound bound classic linear implementation bias model computation furthermore bound optimal theorem exists alphabet comparison algorithm belongs perform comparison theorem regardless weaker membership query assumes algorithm comparison algorithm upper bound pointer machine comparison addition arithmetic operation bound assumes comparison technique compression transforms label another height hierarchical decomposition subgraphs cluster cluster overlap cluster node leaf corresponds cluster consist internal node corresponds merge cluster compress classical dag compression dag dag navigational query compress exponentially dag compression dag compression factor technical contribution implement prefix optimally dag develop optimal pointer machine data structure independent data structure extraction asks compactly label node efficiently return label optimal obtain plug specifically fully persistent queue simpler elegant data structure ancestor asks compactly node positive efficiently return  ancestor distance immediate implication ancestor data structure optimal data structure random access grammar compress improves soda ram trick data structure spine extraction asks compactly compression cluster efficiently return unique boundary node bound algorithm perform comparison implies bound implies bound roadmap sect recall obtain merge vertically horizontally subtrees overlap node sect randomize monte carlo ram compress index basis deterministic pointer machine efficiently handle horizontal merges deterministically vertical merges randomize monte carlo sect handle vertical merges deterministically pointer machine sect suffices achieve query theorem handle vertical merges sect horizontal merges sect sect suffice achieve query theorem finally sect bound query theorem optimal regardless structure preliminary briefly review karp rabin fingerprint compression karp rabin fingerprint karp rabin fingerprint define randomly chosen positive integer prime karp rabin fingerprint guarantee furthermore probability fingerprint compose lemma decomposable prefix karp rabin fingerprint calculate remain fingerprint constant cluster node define subtree induced descendant define induced descendant component induced node cluster boundary node component cluster boundary node boundary node component node denote boundary node cluster cluster therefore boundary node denote cluster boundary node leaf boundary node otherwise boundary node node boundary node internal node boundary node cluster cluster spine obtain concatenate label spine denote disjoint cluster vertex overlap boundary node merge union cluster merge cluster merges vertical merges vertical cluster boundary node boundary node cluster merges horizontal merges horizontal cluster boundary node merge cluster node boundary node remain boundary node merge cluster node boundary node become internal non boundary node merge cluster merges merge cluster boundary node boundary node image hierarchical decomposition cluster label binary define node correspond cluster corresponds cluster boundary node leaf correspond label leaf label correspond internal node corresponds merge cluster label internal node merge merge option cluster preorder traversal lemma construct height trie label subscript identify correspond leaf hierarchical cluster correspond node vertical cluster node horizontal cluster dag image dag label acyclic graph dag identify identical subtrees replace dag denote minimal dag representation compute footnote DAGs important compression computation optimal compression bound lemma   node alphabet construct dag index randomize monte carlo ram index deterministic comparison pointer machine later data structure trie correspond dag data structure augments additional information cluster information leaf cluster label internal cluster label rightmost boundary node fingerprint constant cluster hence denote unique node prefix prefix unique node prefix compute fingerprint prefix lemma compute fingerprint substring traverse suppose cluster return otherwise leaf cluster label return otherwise horizontal cluster respectively label rightmost otherwise vertical cluster respectively otherwise fingerprint otherwise lemma algorithm correctly computes prefix proof induction cluster prefix empty empty prefix inductively suppose prefix algorithm maintains invariant algorithm greedily hence traversal algorithm prefix compute fingerprint traversal constant depth summary theorem theorem correspond dag trie ram model computation compress index randomize monte carlo convert algorithm randomize algorithm ram machine deterministic algorithm pointer machine theorem subsequent extend variant prefix query counting query return occurrence cluster modify cluster boundary occurrence obtain counting within complexity reporting query return prefix simply decompress incur additional linear prefix spine extraction handle vertical cluster deterministically pointer machine challenge efficiently extract spine vertical cluster without decompress cluster efficiently compute prefix spine substring achieve dag spine extraction compactly vertical cluster return report online report sequence extraction goal obtain efficient report prefix spine extraction data structure derive dag vertical dag extract spine compute prefix spine plug traversal sect obtain theorem vertical vertical dag vertical label binary node vertical cluster leaf cluster correspond spine cluster define cluster unique vertical leaf descendant spine respectively cluster unique vertical leaf descendant spine correspondence spine subtrees vertical vertical dag horizontal horizontal dag image lemma vertical merge leaf furthermore corresponds proof definition spine leaf cluster leaf cluster cluster hence instance descendant leaf correspond spine vertical dag dag obtain merge identical subtrees accord dag compression spine extraction spine extraction vertical dag simulate depth traversal recursive traversal spine extraction horizontal cluster dag extract spine therefore define vertical exit cluster quickly cluster define vertical exit cluster ancestor leaf intuitively extract cluster leaf subtree extract leaf subtree correspond extract goal implement spine extraction yield telescope sum multiple extraction data structure consists vertical dag augment internal cluster label spine leaf cluster label cluster implement spine extraction simulate depth traversal recursive traversal extract return label suppose extract extract simulated depth cluster leftmost leaf leaf return cluster simulated depth lemma algorithm correctly solves spine extraction extract stack traversal height vertical height vertical bound vertical dag stack summary lemma lemma vertical dag vertical cluster spine extraction extract prefix lemma compute prefix reporting spine mismatch prefix plug spine extraction algorithm sect algorithm sect define horizontal entry cluster vertical cluster denote horizontal cluster leaf cluster contains within horizontal cluster leaf horizontal entry cluster cluster horizontal cluster leaf cluster leftmost leaf data structure consists data structure sect without fingerprint sect algorithm sect implementation vertical merges vertical cluster recall vertical cluster prefix algorithm extract compute prefix correspond vertical exit cluster traverse leftmost lemma algorithm correctly computes prefix proof induction cluster prefix empty empty prefix inductively suppose prefix correctness lemma description induction correctness spine extraction induction descendant boundary node ancestor contains exactly hence vertical cluster compute prefix computation extract correspond horizontal entry cluster hence vertical cluster extract respectively leaf sect horizontal merges leaf horizontal merges concludes proof query theorem spine extraction constant overhead achieve query theorem horizontal merges sect vertical merges sect hence technique achieve bound vertical merges horizontal merges improve spine extraction optimal introduce novel extraction sect extract spine sect extraction node extraction compactly node return node constant per node node report online node report sequence extraction node essential direction trivial simply pointer traverse linear constant per node ram trick easily bound exist ancestor data structure optimal ram trick pointer machine mention introduction optimal obtain plug simpler elegant decomposition extraction node node node node leaf link sort increase depth image distance deepest leaf subtree respectively decompose consist node consist remain node leaf explicitly link sort increase depth multiple node across leaf hence equality definition decomposition descendant leaf leaf disjoint leaf internal node pointer arbitrary leaf node pointer unique ancestor leaf extraction query node leaf pointer output leaf unique ancestor leaf extract simultaneously pointer node stack extract node pointer node stack node stack output node leaf output node stack plus therefore extract per node hence lemma node extraction linear preprocessing constant per report node optimal spine extraction plug extraction depth traversal vertical dag spine extraction prefix computation recall vertical cluster goal simulate depth traversal subtree vertical dag construct node node hence leftmost corresponds node ancestor node extraction data structure lemma implement depth traversal whenever traversal unexplored cluster extraction cluster correspond leftmost descendant leaf extract leaf depth traversal hence depth traversal partition alternate sequence leftmost whenever traversal extract node correspond extraction instance extract topmost constant leftmost descendant leaf traverse leaf hence improve traversal maintain ongoing extraction instance along stack linear correspond subpath hence extra lemma vertical dag vertical cluster spine extraction extract prefix horizontal access efficiently handle horizontal merges algorithm sect constant horizontal merge cannot afford instead handle horizontal merges convert variant random access grammar compress linear logarithmic query random access random access sect sect introduce horizontal dag sect define horizontal access sect grammar random access grammar compression replaces context grammar cfg grammar dag node grammar defines righthand  node define parse consist leaf denotes concatenation grammar random access compactly access query index report random access  pointer machine model furthermore node access query purpose slightly extend gapped grammar gapped grammar grammar internal non negative integer gap generate hence generate insert gap random access straightforward generalize gapped grammar lemma compress gapped grammar node random access query pointer machine model computation horizontal access linear inverse ackermann factor complexity lemma remove assume ram model computation achieve pointer machine replace component ancestor structure ancestor node positive node distance goal preprocess ancestor query non node positive ancestor without proof lemma suffices perform random access query boil perform ancestor query query ancestor query proportional intuitively seek distance longer query achieve query linear pointer machine imply inverse ackermann factor improvement lemma lemma node preprocessed ancestor query node ancestor proof partition slice ith slice denote consists node collection node pointer arbitrary descendant belongs denote leaf correspond descendant belongs query node replace increase replace descendant return node assume input query node leaf node pointer ancestor belongs query node leaf replace return ancestor whenever applies decrease separately preprocess ancestor query node distance correspond maximum therefore focus preprocess parameter ancestor query ancestor leaf preprocessing proceeds recursively partition denote collection constitute denote node belongs leaf pointer ancestor belongs denote collection obtain remove leaf leaf additionally pointer arbitrary leaf subtree pointer arbitrary leaf subtree apply construction recursively parameter illustration parameter decompose image query leaf replace return return replace decrease correspond mutually exclusive correctness immediate recurse maintain invariant leaf sought node easily belong indeed instead respectively recursive decrease cannot belong currently query analyze assume partition conceptual information associate node leaf information remove participate construction indeed overall per node finally described query leaf query algorithm rewrite information node behaves hence corollary compress gapped grammar node random access query pointer machine model computation horizontal horizontal DAGs vertical define horizontal consists horizontal cluster leaf boundary horizontal cluster define horizontal cluster horizontal cluster leaf vertical cluster similarly lemma horizontal merge leaf boundary node leaf correspond node boundary node proof definition boundary node correspond leaf horizontal cluster furthermore definition hence node boundary node instance descendant leaf correspond horizontal define horizontal dag dag obtain merge subtrees accord dag compression gapped grammar horizontal access internal cluster spine unique contains descendant cluster spine descendant cluster spine define horizontal exit cluster horizontal cluster denote cluster unique leaf label spine descendant horizontal dag horizontal access compactly horizontal merge efficiently label within return horizontal exit cluster horizontal access characteristic vector cluster binary encode label precisely define rank sort cluster define rank leaf label define characteristic vector recursively leaf cluster internal cluster cluster definition correspondence characteristic vector leaf label cluster lemma cluster leaf label iff cluster virtual cluster gapped parse hence horizontal dag gapped grammar lemma label random access query correspond gapped grammar exists precisely lemma cluster horizontal access proof construction characteristic vector hence corollary complexity augment random access corollary definition apply explain approach decomposition partition leaf decompose alternate sequence compactly encodes subpath uniquely corresponds node ancestor random access corollary solves ancestor query lemma computes alternate sequence subpaths leaf cluster label construct contract non spine descendant leaf consist unmarked correspond construct contract unmarked contract node node ancestor query identifies node correspond horizontal entry cluster contract  contract ancestor query correspond query traverse alternate sequence marked endpoint ancestor query simply marked plug spine extraction sect horizontal access sect algorithm sect define vertical entry cluster horizontal cluster denote vertical cluster leaf cluster contains data structure consists data structure sect spine extraction data structure sect horizontal access furthermore vertical cluster pointer horizontal entry cluster horizontal cluster pointer vertical entry cluster alternate horizontal access lemma spine extraction lemma instead traversal entry cluster directly pointer specifically modify algorithm suppose cluster return otherwise leaf cluster label return otherwise horizontal cluster compute return otherwise vertical cluster algorithm otherwise extract compute prefix correspond vertical exit cluster lemma algorithm correctly computes prefix proof induction cluster prefix empty empty prefix inductively suppose prefix correctness lemma induction otherwise label descendant description lemma definition hence induction recall horizontal exit cluster horizontal cluster spine descendant hence cluster descendant internal node hence definition alternate sequence horizontal access spine extraction horizontal access spine extraction spine hence horizontal access distinct horizontal access lemma horizontal access sequence alternate spine extraction hence lemma spine extraction concludes proof query theorem bound theorem namely structure alphabet perform comparison belongs comparison structure irrelevant technical lemma gist bound lemma comparison algorithm alphabet perform comparison proof alphabet decision correspond comparison algorithm decides comparison node corresponds subset input corresponds leaf correspond disjoint subset input depth assume contains leaf exists leaf correspond subset input distinct distinct exists without lose generality define algorithm incorrectly decides proceed bound fix contains structure allows belongs implies comparison algorithm lemma comparison integer assumption contains structure allows belongs implies comparison algorithm additionally execute algorithm clearly access perform comparison additionally algorithm convert procedure lemma comparison combine bound obtain comparison rewrite assumption obtain bound combine bound bound minimum bound prof theorem