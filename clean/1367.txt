prize  steiner instance compose integer graph penalty vertex objective span vertex minimizes plus penalty vertex fundamental network generalization prize  steiner minimum  approximation algorithm improves currently approximation factor faster algorithm modification primal dual framework goemans williamson reveals apply access auckland library introduction network input consists graph output minimum subset vertex fundamental NP variant prize  steiner PCST minimum  mst PCST subset vertex span vertex incurs penalty objective function mst output vertex prize  steiner PCST generalization PCST mst instance consists undirected graph vertex non negative integer non negative vertex non negative penalty span vertex minimize plus penalty vertex span minimize without loss generality assume related PCST PCST approximation LP algorithm goemans factor improve randomize algorithm goemans williamson approximation primal dual scheme PCST constrain bound optimal weak duality consequence analysis implies integrality gap LP formulation asymptotically tight currently approximation PCST due factor approximation factor steiner yield factor PCST mst PCST vertex assume span exactly vertex vertex prune without increase approximation algorithm devise mst constant factor approximation factor primal dual scheme garg improve factor subsequently  ramesh garg algorithm obtain factor later arora  approximation modify garg algorithm currently approximation mst approximation due garg sophisticated primal dual scheme knowledge constant factor approximation PCST factor primal dual scheme lagrangian relaxation linear program later   derive approximation combine underlie instance PCST mst algorithm bottleneck garg approximation mst approximation PCST approximation factor PCST improve significant increase contribution approximation PCST precisely algorithm opt opt optimal improves approximation factor complexity previously algorithm approximation modify version goemans williamson algorithm analysis reveals primal dual scheme insight constraint inequality algorithm correspond dual LP formulation PCST analysis rely weak duality moreover modification algorithm approximation quota variant PCST instance vertex quota algorithm overview algorithm successively executes modify version approximation primal dual scheme PCST due goemans williamson algorithm growth phase prune phase growth phase computes feasible dual subset vertex non negative output collection subset subset correspond tight dual inequality LP formulation prune phase algorithm deletes subset disconnect graph prune derive approximation bound factor dual objective function algorithm output optimal directly modification growth phase receives argument potential potential uniform increase penalty vertex output span vertex growth phase concurrent multiple choice execution usually choice fix lexicographic algorithm contrary relies priority concurrent dictate priority iteration algorithm allows execution algorithm potential built garg argument approximation mst described prune span exactly vertex approximation lagrangian relaxation strategy however exists sufficiently potential prune span vertex potential prune span vertex construct prune collection similarly construct prune collection feasible cannot bound vector bound feasible garg algorithm collection obtain vertex bound algorithm iteratively transforms replace subset iteration prune collection span vertex instead perform operation augments prune sequence correspond dual restriction tight vertex algorithm considers correspond collection however construct execute growth phase potential differentiate account brake maximal prefix compute tuple threshold tuple execute growth phase prune vertex prune vertex vice versa collection output execution growth phase slightly indeed ingredient analysis lemma scenario collection subset moreover vector output execution growth phase straightforward augment prune sequence correspond inequality tight without transformation although compute vector satisfies inequality inequality correspond LP dual formulation PCST hence cannot weak duality bound optimal instead lemma algorithm return approximate identifies non empty subset vertex span optimal desire safely reduce instance therefore algorithm approximate text organization remain organize sect series definition introduce terminology text sect modification primal dual scheme account potential sect formally define threshold tuple compute sect threshold tuple construct span exactly vertex sect bound compute approximation PCST sect conclude remark definition preliminary nonempty collection laminar subset laminar collection binary distinct non empty subset denote collection inclusion wise maximal subset collection laminar subset disjoint partition extreme contains extreme  internal  external distinct  external parallel  graph subset induced subgraph collection subset vertex denotes exactly extreme subscript subset define penalty   non negative potential subset  vector entry non negative variable respect  respect vertex penalty   subset tight inequality correspond equality analogously subset tight inequality correspond satisfied equality context simply tight inequality inequality dual formulation PCST difference inequality subset however inequality correspond dual LP formulation PCST collection subset denote collection subset subset denote collection subset vertex moreover  bound optimal lemma lemma optimal suppose laminar collection minimal subset respect proof laminar subset contains vertex subset subset cannot otherwise minimal  inequality subset inequality respect modify growth prune phase detail modification primal dual scheme due goemans williamson PCST algorithm compose routine cluster algorithm growth phase cleanup algorithm prune phase modify cluster algorithm modify growth phase described denote  listing afterwards algorithm algorithm maintains binary laminar collection partition vertex vector respect iteratively construct  subset subset tight iteration subset algorithm define implicitly initialize iteration maximal subset active iteration increase active subset uniformly occurs external  becomes tight union active subset becomes tight multiple subset become tight simultaneously modify algorithm possibly empty sequence subset denote iteration accord correspond priority correspond finally correspond subset priority fix lexicographic algorithm active subset algorithm defines output lemma invariant growth phase lemma iteration  binary laminar collection respect tight laminar subset tight subset contains proof iteration hence valid assume invariant valid iteration subset therefore valid iteration iteration valid  non negative vertex assume invariant valid iteration iteration variable correspond active subset increase minimum external active subset becomes tight become tight external moreover subset becomes tight subset laminar therefore modify inequality violate invariant remains valid iteration valid compose singleton contains assume invariant valid iteration tight union  therefore remains valid iteration invariant laminar tight active subset invariant iteration active component  algorithm active component invariant span corollary output  lemma iteration execute  proof invariant increase subset therefore consequence growth phase executes polynomial implies exceed modify prune algorithm modify prune phase denote  listing algorithm algorithm receives graph iteratively deletes subset assume input subgraph laminar collection subset prune execute algorithm  graph prune input graph cycle whereas standard prune phase considers useful sect vertex distinct prune cycle lemma invariant prune phase lemma iteration  proof algorithm subset chosen iteration assume valid delete disconnect remove iteration induce subgraph corollary graph output  prune proof construction prune invariant implies structural prune phase auxiliary lemma implies series monotonic prune algorithm lemma graph assume prune graph output  proof assume execution output algorithm execute iteration assign variable iteration induction clearly assume   choice prune implies invariant induction implication lemma output  invariant subset corollary graph output execution  proof prune output  lemma symmetrically corollary prune fix graph  supergraph graph obtain prune corollary graph output   respectively proof prune prune lemma corollary considers graph sandwich graph prune subgraph intuitively interpret corollary prune partially prune graph fully prune graph corollary graph graph output   respectively proof prune lemma analogously prune lemma therefore modify goemans williamson algorithm modify goemans williamson algorithm wrap growth prune phase denote  listing algorithm algorithm executes  obtain executes  return prune  subset return span vertex recall  lemma sufficiently lemma output  proof corollary  return tuple subset delete prune phase suppose contradiction subset iteration vertex denote  iteration subset iteration vertex exactly active subset iteration vertex subset invariant exist external extreme respect invariant contains iteration becomes tight iteration    contradiction  threshold tuple execute modify goemans williamson algorithm potential zero passing empty execute  return span vertex approximate lemma proof adapt appendix lemma return  optimal remainder assume execute  return span vertex lemma implies potential vertex associate return span exactly vertex exists instead goal tuple threshold tuple define introduce notation iteration  subset correspond necessarily tight respect potential sequence subset iteration  corresponds denote prefix definition return  return  threshold tuple respect threshold tuple obtain vertex vertex structure sect construct span exactly vertex approximation sect threshold tuple sect compute polynomial threshold tuple execution   identical iteration lemma respect respect iteration   variable identical proof statement definition statement iteration execution depends item iteration growth phase important role distinguish output return execute   corresponds subset auxiliary possibility threshold tuple lemma assume threshold tuple subset iteration  subset iteration  proof output  identical output    return identical threshold tuple indeed assume respect iteration  tight external lemma iteration  tight external iteration  priority tight iteration assume subset suppose contradiction subset subset iteration  tight external iteration collection tight active subset iteration   lemma processing subset modify variable subset execution although subset becomes tight iteration   variable identical implies execution output contradiction threshold tuple notion iteration recall execution  iteration increment variable zero vector remains unaltered iteration vector iteration vector iteration output growth phase corresponds collection subset suppose execute  return execute  return threshold tuple difference restrict remove subset proof argument rely execution growth phase almost identical iteration collection depends iteration   illustration iteration depict execution maximal subset subset correspond tight external drawn maximal subset tight label priority subset correspond label index  contour surround subset execution processing  item processing execution   image execution   subset image  subset iteration illustration convention depicts iteration  processing  item processing execution maximal subset   execution  whereas maximal execution  lemma summarizes threshold tuples lemma assume threshold tuple output compute  output compute  subset proof subset iteration  respect subset iteration  lemma tight external iteration  similarly define analogous correspond  lemma priority subset becomes internal iteration active tight subset iteration execution  parallel  iteration therefore parallel iteration similarly  iteration iteration  tight external iteration  priority tight external indeed iteration compute  compute  moreover component external collection active subset iteration execution implies sequence subset succeed iteration therefore output   lemma subset collection active tight subset iteration  similarly define analogous collection correspond  subset lemma suppose processing  iteration priority subset tight external becomes internal iteration  respectively lemma tight external iteration  processing subset tight external processing subset  sequence iteration  implies  iteration  iteration consequence tight subset remains maximal iteration  tight maximal iteration  vice versa processing subset unprocessed therefore correspond   external collection active subset execution previous implies sequence subset succeed iteration execution subset   conversely subset   subset   return identical threshold tuple completes lemma compute threshold tuple algorithm compute threshold tuple definition correspond auxiliary lemma increase function suppose fix interval respect fix laminar collection collection subset compute  iteration correspond respectively collection active subset iteration define collection correspond collection contains active subset external active  tight external active  iteration  subset iteration contains subset iteration iteration  variable active subset increase inequality correspond subset violate compute subset increase variable becomes tight interval fix depends increase function correspond function lemma increase function linear proof integer sublist define respect collection correspond index entry iteration  define index increase function correspond induction function linear lemma subset singleton vertex maximal subset singleton iteration growth phase increase tight  similarly active  iteration assume linear subset  denote index active subset iteration iteration  linear linear  collection active subset iteration external active  tight active  inequality correspond linear function increase active subset tight linear similarly subset inequality correspond  function linear function  linear diverge potential potential collection correspond iteration growth phase increase function evaluates suppose execute  subset iteration execute  distinct subset iteration situation former execution latter increase function linear implies potential iteration  distinct formally diverge potential subset distinct increase function execution  iteration increase function linear diverge potential finite compute polynomial standard intersection algorithm definition implies consecutive diverge potential subset tight iteration growth phase execute diverge potential formalize lemma sequence diverge potential iteration  tight iteration  proof distinct increase function consecutive potential function intersect continuity increase function iteration  increase variable tight iteration threshold tuple algorithm threshold tuple algorithm denote  listing algorithm threshold tuple algorithm construct iteratively maintains invariant respect  return span vertex  return span vertex initialize variable iteration iteration compute sequence diverge potential  return vertex  return vertex index  return vertex  return vertex discover subset iteration  arbitrary extend append lemma extend respect invariant maintain execute  update return vertex  return vertex threshold tuple algorithm analogously  return vertex threshold tuple neither invariant maintain  indeed threshold tuple lemma execute  return span vertex  return threshold tuple polynomial proof argue algorithm indeed maintains invariant respect  return span vertex  return span vertex empty respect potential  return span vertex assumption  return span vertex lemma iteration invariant description algorithm invariant iteration iteration algorithm return threshold tuple  iteration suppose iteration lemma growth phase executes iteration sequence subset   respect invariant implies   output   return identical contradicts invariant threshold tuple assume threshold tuple execute   obtain span vertex vertex vertex vertex respectively denote correspond compute growth phase denote laminar collection compute growth phase laminar collection slightly lemma   compute identical vector moreover subset tight objective span vertex recall collection subset vertex optimal assume minimal subset relax assumption later bound optimal lemma bound bound inequality analogous goemans williamson analysis therefore obtain approximation sufficient feasible span vertex goal compute span exactly vertex construct vertex algorithm algorithm due garg explain assumption minimal subset recall subset binary laminar without loss generality minimal subset contains contains subset contains therefore assumption safely reduce instance discard vertex vertex subset iteration  assume subset lemma implies collection exactly subset span vertex collection contains subset collection monotonicity prune operation therefore obtain span exactly vertex goemans williamson analysis prune collection tight subset prune vertex subset prune collection prune algorithm delete sequence tight subset illustrate subset sequence delete subset subset image definition laminar collection subset graph sequence subset partition subset prune vertex prune correspond subset vertex definition subset subset subset image lemma exists subset compute polynomial lemma prune subset compute polynomial proof already prune subset assume execute  iteration graph prune iteration graph return algorithm subset chosen delete iteration iteration execution subset  inclusion wise minimal invariant sequence subset choice vertex vertex  prune subset contains inclusion wise minimal subset indeed suppose false minimum  inclusion wise minimal subset contradicts restrict attention disjoint partition vertex otherwise disconnect unique connects disjoint laminar implies subset contradiction restrict attention unique extreme assume connects symmetrical implies therefore distinct graph cycle vertex iteration vertex remove implies  contradiction choice hence conclude ell prune mathcal notin dot ell indeed subset mathcal completes proof subset remain graph vertex graph output monotonicity prune operation contains span vertex goal subset sigma subset prune vertex sigma prune therefore lemma directly implies lemma sigma subset subset compute polynomial assume sigma lemma implies moreover span vertex difference exactly exists unique unlike cannot obtain subset remove disconnect graph instead exactly cycle cycle contains contains cycle lemma sigma contains cycle proof contains prune imply lemma indeed contains lemma contains contains vertex suppose contains vertex prune algorithm remove vertex subset correspond subset vertex remove indeed contains construct subset sigma cycle prune sequence delete subset lemma sigma subset dot ell compute polynomial moreover connects subset connects proof define contains prune subset exactly extreme extreme extreme define obtain graph execute mathtt PP mathcal grey denote delete prune subset mathcal contains contains unique vertex vertex delete prune algorithm vertex cycle contains vertex prune mathcal image vertex define prune mathcal suppose subset mathcal delta prune mathcal contains exactly extreme implies prune mathcal implies notin mathcal disjoint delta contradiction therefore prune mathcal obtain subset prune lemma obtain subset dot prune lemma obtain subset dot prune dot dot subset exactly connects cycle vertex dot dot subset dot dot image augment assume already compute subset dot ell recall contains subgraph span vertex ell corresponds vertex span vertex exists index subset dot ell vertex dot ell vertex dot ell exactly vertex augment sequence iteratively subset vertex goal sequence subset dot subset induces subgraph adjacent subset suppose already compute sequence dot vertex cap subset vertex suppose vertex cap initialize subset correspond subset define otherwise contains vertex binary laminar implies disjoint subset cup cap assumption otherwise cap implies cap cap span vertex vertex vertex define cap update variable induces subgraph exemplifies solid contour denote subset sequence dot image summarize vertex algorithm denote mathtt PV lambda tau listing algorithm obtain subset dot ell lemma sigma subset dot ell vertex sequence dot sequence dot dot ell exactly vertex subset induces subgraph adjacent subset induces span exactly vertex output algorithm denote subset correspond subset subseteq cap emptyset recall mathcal collection subset mathcal subset vertex lemma vertex laminar collection mathcal mathcal lemma suppose contains vertex vertex setminus subset contains proof dot ell compute subset recall subgraph subset contains prune algorithm delete subseteq implies role iteration vertex cap remain vertex picked therefore lemma subset prune lemma delta proof algorithm computes subset dot ell sigma subset sigma define vertex prune delta suppose contradiction notin delta delta disjoint delta therefore delta delta delta contains adjacent subset subseteq vertex delta delta contradiction assume subseteq span vertex subseteq vertex vertex iteration subset cap remain vertex picked cap otherwise vertex cap picked contradiction delta lemma extract critical output algorithm bound collection subset mathcal denote mathcal collection subset mathcal vertex mathcal contains subset mathcal subset lemma execution mathtt GP return mathcal collection active subset vertex iteration align sum mathcal delta mathcal mathcal align proof dot ell subset compute algorithm define ell subgraph subset associate delta dot sequence subset picked lemma subset contains laminar collection iteration mathtt GP mathcal collection maximal subset active vertex mathcal collection maximal subset active vertex mathcal cup mathcal partition contract subset mathcal cup mathcal obtain graph vertex correspond subset delta active subset maximal subset laminar collection iteration subset mathcal disjoint mathcal interested counting vertex correspond non active subset mathcal collection subset mathcal delta subset mathcal mathcal lemma proof contract graph mathcal mathcal non active subset active subset indeed mathcal contains subset active subset contains otherwise mathcal mathcal align sum mathcal delta mathcal mathcal sum mathcal delta sum mathcal delta mathcal mathcal mathcal mathcal mathcal mathcal align implies sum mathcal delta mathcal mathcal lemma contract graph cycle cycle exists maximal subset mathcal cup mathcal induces disconnect subgraph invariant cup cycle vertex intersect contains sigma contains contract contains cycle component otherwise cycle recall suppose contradiction extreme maximal subset mathcal cup mathcal cycle cycle conclude connects consecutive maximal subset cycle therefore extreme contains vertex span vertex otherwise dot lemma span vertex subset span vertex lemma connects consecutive subset contains vertex subset subset vertex therefore cannot vertex subseteq vertex delta contains delta cannot contains vertex component suppose without loss generality notin cap setminus laminar subseteq illustrates maximal subset dash contraction graph cycle graph cycle image implies mathcal mathcal contains subset mathcal maximal subset exactly cycle align sum mathcal delta mathcal sum mathcal delta sum mathcal delta mathcal mathcal mathcal mathcal mathcal align implies sum mathcal delta mathcal mathcal lemma approximation wrap algorithm bound output mathtt PV bound within factor optimal PCST bound adopt definition introduce sect simplify notation remainder recall mathcal denotes collection subset mathcal contains vertex mathcal denotes collection subset mathcal subset mathcal collection subset mathcal lemma bound vertex penalty output mathtt PV lemma return mathtt PV lambda tau proof lemma vector compute growth phase mathtt GP lambda tau mathtt GP lambda widetilde tau tight induction iteration mathtt GP lambda tau growth phase inequality assume inequality iteration mathcal collection active subset vertex maximal subset contains notin mathcal subset contains notin mathcal mathcal laminar therefore maximal subset neither inequality hence assume active subset contains mathcal subseteq mathcal mathcal subseteq mathcal suppose iteration variable active subset increase varDelta inequality increase sum mathcal delta varDelta increase mathcal mathcal varDelta lemma increase inequality maintain iteration lemma return mathtt PV lambda tau proof partition correspond vertex penalty paid component subset setminus intersection vertex paid precisely define vertex paid tight lambda respect lambda align lambda lambda lambda cup sum mathcal sum mathcal cup align denote mathcal collection subset mathcal cup vertex vertex mathcal mathcal mathcal partition collection mathcal cup similarly denote mathcal collection subset mathcal vertex cup vertex mathcal cup mathcal mathcal partition collection mathcal mathcal setminus mathcal subseteq mathcal subset mathcal setminus mathcal contains vertex mathcal vertex contains vertex setminus subset contains lemma implies therefore mathcal mathcal setminus mathcal subseteq mathcal simplify index summation align mathcal setminus mathcal cup mathcal cup cup mathcal cup mathcal setminus mathcal cup mathcal cup mathcal subseteq mathcal cup cup mathcal setminus mathcal align vertex paid vertex span subset addition vertex vertex setminus cup paid vertex delete prune algorithm vertex indeed subset contains vertex cup hence collection dot subset partition vertex argument collection dot ell subset partition vertex subset tight lambda align lambda cup sum ell lambda sum ell sum mathcal sum mathcal cup mathcal align collection summation disjoint align mathcal setminus mathcal cup cup mathcal cup mathcal subseteq mathcal cup cup mathcal cup mathcal subseteq mathcal setminus cup mathcal align combine conclude align lambda setminus lambda lambda cup sum mathcal setminus sum mathcal align combine bound previous lemma obtains corollary corollary return mathtt PV lambda tau approximation algorithm lemma ingredient approximation lemma return mathtt PV lambda tau optimal suppose minimal subset mathcal align setminus setminus align proof assume span exactly vertex span vertex setminus setminus therefore align setminus lambda setminus lambda setminus lambda setminus lambda setminus  sum mathcal lambda setminus setminus align penultimate inequality corollary inequality lemma respect lambda finally approximation denote mathtt text approx listing algorithm algorithm compute series output iteration compute execute mathtt GW emptyset already span vertex iteration otherwise threshold tuple lambda tau lemma compute mathtt TS return mathtt PV lambda tau mathcal laminar collection mathtt PV lambda tau compute subset mathcal inclusion wise maximal subset otherwise remove vertex iteration vertex delete iteration reduce graph mathcal algorithm output compute minimizes respect graph argue approximation optimal respect iteration subgraph algorithm iteration compute mathtt GW emptyset lemma implies approximation respect otherwise inclusion wise minimal subset lemma implies compute mathtt PV lambda tau approximation respect approximation respect approximation respect theorem return mathtt text approx optimal align setminus setminus align remark approximation prize  steiner improves previous approximation factor mathtt text approx iterates mathcal complexity iteration dominate subroutine mathtt TS mathcal algorithm mathcal variant prize  steiner classical network practical theoretical perspective version PCST cardinality constraint technique apply connectivity particularly primal dual framework although algorithm primal dual framework mathrm LP formulation standard integer linear program PCST integrality gap quota version mst vertex associate non negative integer minimum vertex vertex quota mst quota vertex modification algorithm approximation quota variant PCST equivalent instance PCST replace vertex location although instance necessarily polynomial growth phase vertex simulated polynomial reference archer    improve approximation algorithm prize steiner tsp siam comput http doi org ezproxy auckland MathSciNet article math google scholar arora  varepsilon approximation algorithm mst math program http doi org ezproxy auckland MathSciNet article math google scholar  ramesh factor approximation algorithm mst inf lett http doi org ezproxy auckland   blum  approximation guarantee minimum prize salesman siam comput MathSciNet article google scholar  goemans  levi williamson prize salesman math program http doi org ezproxy auckland BF MathSciNet article math google scholar blum ravi  constant factor approximation algorithm mst comput  sci http doi org ezproxy auckland  MathSciNet article math google scholar  grandoni   steiner approximation via iterative randomize acm http doi org ezproxy auckland   williamson approximate mst steiner via primal dual  relaxation math program http doi org ezproxy auckland MathSciNet article math google scholar  fernandes ferreira  johnson  phillips algorithm prize steiner corr arxiv garg approximation minimum span vertex proceeding annual symposium foundation computer FOCS computer society washington DC usa http acm org ezproxy auckland citation cfm garg epsilon approximation mst graph proceeding thirty seventh annual acm symposium theory compute STOC acm york NY usa http doi org ezproxy auckland http doi acm org goemans williamson approximation technique constrain siam comput http doi org ezproxy auckland MathSciNet article math google scholar han approximation algorithm prize steiner  lett http doi org ezproxy auckland johnson  phillips prize steiner theory proceeding  annual acm siam symposium discrete algorithm soda society industrial apply mathematics  PA usa http acm org ezproxy auckland citation cfm   approximation algorithm prize steiner  lett http doi org ezproxy auckland MathSciNet article math google scholar     thesis   paulo    ravi    ravi span siam  math MathSciNet article google scholar williamson  approximation algorithm  cambridge york google scholar reference author information affiliation institute compute   brazil     hugo    correspond author correspondence hugo    additional information publisher springer remains neutral regard  publish institutional affiliation  paulo research foundation  grant national council scientific technological development  grant proof lemma proof lemma appendix lemma mathtt GW emptyset return vertex approximation proof adapt mathcal tuple return mathtt GP emptyset growth phase computes correspond laminar collection mathcal associate vector output mathtt GW emptyset return mathtt PP mathcal recall mathcal denotes collection subset mathcal vertex subset mathcal denote collection subset mathcal vertex mathcal collection subset mathcal bound lemma bound lemma bound penalty vertex lemma return mathtt GW emptyset proof tight induction iteration mathtt GP emptyset growth phase inequality assume inequality iteration laminar collection mathcal iteration mathcal collection active maximal subset mathcal vertex mathcal collection non active maximal subset mathcal vertex maximal subset mathcal contains neither inequality assume maximal subset contains suppose variable active subset increase varDelta iteration hence inequality increase increase mathcal setminus mathcal varDelta inequality maintain iteration mathcal cup mathcal partition graph contract subset mathcal cup mathcal subgraph graph mathcal invariant non active subset mathcal mathcal prune mathcal corollary implies therefore vertex correspond subset mathcal subset active exactly subset mathcal contains hence mathcal setminus mathcal mathcal lemma return mathtt GW emptyset proof corollary vertex span subset mathcal mathtt PP mathcal deletes subset mathcal vertex span subset mathcal mathcal laminar collection cdots subset mathcal partition vertex subset mathcal tight lemma lemma return mathtt GW emptyset optimal proof minimal subset mathcal vertex mathcal collection subset mathcal vertex mathcal mathcal setminus mathcal partition mathcal contains mathcal subseteq mathcal combine lemma subset disjoint simplify index summation respect lemma lambda