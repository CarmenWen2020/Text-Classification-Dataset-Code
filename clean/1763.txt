develop simd vector ISAs instruction wider data simd architecture rely programmer compiler transform code vector limitation compiler memory alias analysis presence infrequent memory data dependence code cannot safely vectorised without risk semantics application restrict available performance simd architecture address issue relies speculation identify  violation vector execution identify simd lane erroneous data replayed lane execution compiler loop iteration dependence safely vectorise execute architecture selective replay vectorisation srv evaluate purpose hpc benchmark average loop speedup already vectorised code program speedup average already vectorised application introduction simd vector ISAs  intel develop extend instruction vector width avx ISA intel extends operation data developed scalable vector extension sve architecture allows code compile variety implementation vector width maximum compiler automatic vectorisation application trend sophisticated analysis transformation increase amount code vectorised ass profitability  however despite presence vectorisation technique hardware compiler aside domain rarely vectorise purpose application partially due inability compiler perform accurate interprocedural pointer disambiguation array dependence analysis limit application exist compiler architectural vectorisation technique simd ISAs operating vector data transformation proven compiler programmer ensure violate data dependence convert code scalar vector otherwise risk semantics application consume tedious developer compiler static analysis accurately disambiguate pointer due conservative exist research memory access rarely alias unless aliasing obvious requirement code memory dependence violation vectorised irregular infrequent dependence prevent code simd hardware limit performance available researcher address propose FlexVec memory dependence vectorised code execution violation occurs predicate erroneous lane partial vectorisation lane binary translator speculatively vectorise sequential code restart checkpoint sequential version violation incur overhead performance majority code dependence violation parallel hardware approach speculatively execute vectorised code monitor memory address access identify memory dependence violation execute code lane obtain data lane data rerun selective replay vectorisation architecture srv augments standard pipeline limit overhead detect dependence violation compiler vectorise freely presence unknown dependence evaluation vector operation agnostic average speedup across spec cpu hpc application II motivation compiler fail vectorise code presence unknown infrequent data dependence listing loop indirect memory access array compile therefore compiler cannot refer memory location loop UI OOVBM  PNQVUFS SDIJUFDUVSF acm annual international symposium computer architecture isca doi isca integer standard input int listing code iteration dependence iteration return vectorised assume function memory dependence violation indeed  lane update obtain data iteration compiler unsafe vectorise loop unless lane detect violation perform limit across benchmark detail application examine vectorisation purpose hpc workload affected unknown dependence workload memory dependence runtime estimate optimal performance vectorisation obtain inner loop fail vectorise presence dependency achieve emulate vectorisation iteration loop assume logic available buffer avoid dependence violation false  dependence additional logic detect loop exit average potential program speedup vectorise inner loop average speedup vectorise unknown memory dependence currently  inner loop dependence therefore technique address issue critical exist option achieve FlexVec compiler generate instruction loop  lane lane dependence violation listing assume vector lane FlexVec loop memory dependence within iteration lane dependence violation partially  iteration execute lane iteration fourth however drawback approach instruction usually loop introduce overhead code listing FlexVec implement  instruction perform explicit memory disambiguation instruction enable previous violation detect overhead comparison increase memory access alias increase partial vectorisation fully exploit potential data parallelism ideally vectorise execute loop iteration execution iteration monitor memory address access dynamically lane dependence violation iteration executes lane dependence violation execution propose srv address drawback resolve unknown periodic dependence violation vectorisation mechanism selective replay vectorisation hardware compiler evaluate performance VI selective replay vectorisation srv hardware vectorisation technique allows compiler speculatively vectorise code data dependence violation automatically execute affected lane maintain sequential semantics program compiler vectorise code cannot absence data dependence simd lane hardware monitor memory address access lane identify data execute obtain allows compiler vectorise code periodic rare dependence obtain benefit vectorised execution knowledge hardware violation resolve overview standard superscalar pipeline shade logic srv assume baseline architecture sve predicate register mask execution lane simd instruction execute srv proceed pipeline normal execution lane guard additional predicate register srv replay register fully lane execute instruction memory access instruction buffer load queue enable memory disambiguation identify lane data dependence violation violation resolve load selective memory update incorrect lane another predicate register srv replay register data dependence violation sequence vector instruction srv replay register indicates lane replayed srv replay register execution vector instruction sequence enable srv execution vectorisation srv introduce instruction srv srv vectorised loop unknown fetch decode dispatch rename issue reg execute memory writeback instruction cache register file data cache IQ rat rob lsu RF srv srv instruction srv replay predicate register extend  logic logic srv standard superscalar pipeline periodic rare dependence listing pseudocode compiler generate code listing bound srv  instruction srv contains vector instruction srv vectorise non loop code unknown dependence slp algorithm although pursue direction inside srv srv enable additional logic srv gate code outside srv execute srv instruction denotes speculative execution restart lane violate memory dependence execute execute srv involves PC instruction fully srv replay register load queue perform extend memory disambiguation described scalar operation architectural loop iteration induction variable outside  compiler variable remain nonspeculative data speculative lane cannot core cache hierarchy become nonspeculative checkpoint architectural register apart PC register srv persist across execution execution srv proceeds srv regular code completion encounter srv instruction memory dependence violation fully unset srv replay register speculative commit execution beyond srv however incorrect lane execution immediately previous srv instruction PC lane incorrect data replayed rollback multiple lane bound vector lane lane VI execution additional iteration workload srv cannot nest loop srv load scatter srv inc comp  loop listing pseudo code listing srv meaning srv cannot  instruction execute srv instruction attribute indicates iteration srv lane vector register increase access memory address increase loop increase induction variable srv instruction attribute memory disambiguation described otherwise lane vector register increase access memory address decrease loop decrease induction variable srv instruction attribute memory address comparison memory disambiguation adjust account direction data access attribute srv instruction compiler memory disambiguation perform memory disambiguation srv leverage exist load lsu component within superscalar core augment modest additional logic capture  violation focus lsu target relaxed memory consistency model align armv sve memory model assume lsu split load queue LQ address queue saq data queue SDQ contiguous broadcast vector load instruction occupy entry LQ whereas vector entry lane load likewise contiguous vector entry saq SDQ whereas vector scatter entry lane data load execution load instruction issue saq execute scalar code load access address saq data forwardable correspond SDQ load instruction although architecture load contains data load implementation aggressive enable partial  load load obtains forwardable byte multiple entry SDQ cache however srv address access issue load overlap later lane violation occurs byte address forwardable SDQ entry data later program non vectorised code load instruction instead obtain forwardable data earlier lane lane SDQ entry load memory hierarchy mechanism described witt address data SDQ entry correspond cache concurrently combine destination vector register disambiguation scheme allows data partially load memory partially SDQ execution instruction issue virtual address becomes LQ entry load parallel saq detect  violation scalar code raw dependence violation occurs load previously data address partially overlap address issue whenever happens signal generate squash load instruction addition srv raw violation issue writes address partially overlap address load later simd lane load already data squash however squash instruction instead srv resolve violation lane prior load violate dependence srv lane replayed later lane load data  violation issue writes data address later lane srv resolve issue violate lane information selectively update memory srv data srv writes version address memory resolve dependence described previous data dependence violate execution srv  violation handle immediately former data later lane latter saq lane data memory recent version program eventually raw dependence contrast handle srv replay register execute violate lane srv srv architecture arbitrary within srv conversion code statement execute srv predicate remove execute code predicate however currently loop function due difficulty calculate lsu entry loop fix iteration graph recursion memory access instruction within srv obtains identifier srv memory instruction PC assign srv splitting scatter replay entry allocate lsu instead entry srv update ensure presence predication execution srv instruction fetch issue lane predicate execute unchanged creates entry lsu memory access meaning replay lane execute instruction predicate entry lsu affect code execute within srv instruction predicate completely unset issue allocate lsu entry srv perform srv encounter microarchitecture lsu entry srv pre allocate entry majority srv within loop likely execute consecutively architectural describes architecture srv serialisation srv instruction creates serialisation meaning execute previous instruction execution instruction execute due srv replay register sticky handle rely completion necessitates serialisation achieve srv marked non speculative issue logic stall issue instruction srv execute architectural architectural processor augment srv replay register PC instruction srv outside srv PC normal execution inside lane srv replay register non speculative execute architectural advance instruction commit  execution srv instruction srv replay register srv context switch processor mode occurs within srv interrupt exception PC srv replay register PC instruction srv sufficient capture execution return non speculative data lsu memory data correspond lane srv replay register PC data lane speculative content discard resumption PCs restore however correspond lane srv replay register restore srv replay register correspond lane avoids correctness issue resume execution speculative lane srv resume execution non speculative lane srv instruction encounter lane execute entirety  interrupt exception interrupt context switch srv handle immediately described exception handle similarly interrupt identify lane exception handle lane lane currently execute subsequent lane marked execution guard exception erroneous data memory dependence violation precise interrupt exception maintain saq modification entry queue augment speculative flag instruction within srv commit rob data remains queue speculative flag execution srv instruction srv replay register unset speculative flag writes data cache constraint described register rename upon execution instruction merge behaviour preserve data inactive already execute lane rename typically achieve reading destination register extra source operand instruction instruction physical register destination physical register source operand merge data architecture apply srv processor straightforward machine execution load baseline microarchitecture however srv akin limited execution cpu logic detect data dependence violation achieve simply lsu standard processor pipeline srv extension described lsu overflow memory instruction srv lsu entry longer speculative however compiler srv load available entry resolve approach industrial  scheme effort basis whereby transaction fail context srv memory access instruction transparently sequential execution srv lane execute commit although lsu entry affect correctness execution blindly apply code transformation slowdown due vector version code efficient sequential code loop address propose compiler generate sequential version loop code execute microarchitecture lsu entry vectorised version already insert compiler circumvent auto vectorisation obstacle aliasing pointer lsu entry target microarchitecture expose compiler compiler analyse maximum memory access within loop intend vectorise srv perform vectorisation guarantee memory access overflow compiler already perform optimisation code generation target specific microarchitectures typically specify   command option vector register file principle srv additional vector register file  issue slot merge predication predication leaf inactive lane untouched merge predication efficiently microarchitecture usually implement propagate destination register onto physical register imply additional vector register however reasonably assume balance baseline microarchitecture generation simd extension sve intel avx already merge predication already adequate handle merge operation throughput assumption additional overhead introduce srv reduce combine predicate associate vector merge instruction srv replay register binary logic operation srv  instruction  instruction  instruction srv listing pseudo code illustrate vertical horizontal dependence instruction instruction vertical dependence instruction horizontal vertical dependence transactional memory transactional memory detects memory violation thread resolve execution apply vector execution simd lane thread strict ibm gene operates transactional memory detect resolve conflict lane however unless transactional memory version cache execute lane dependence violation raw ensure execution situation summary srv technique speculative vectorisation vectorised code executes oforder core memory dependence violation identify technique handle outline detailed srv microarchitecture IV srv memory disambiguation microarchitecture component srv ability identify  violation achieve additional logic load memory disambiguation terminology happens execution load instruction terminology extend concept conventional inter statement data dependence introduce banerjee notation lane vector instruction distinguish definition inter lane dependence inter statement dependence introduce banerjee former horizontal dependency latter vertical dependency listing srv instruction vector load vector operating byte data lane vector instruction writes data sixteen contiguous array indexed iteration vector load instruction data corresponds vertical dependence instruction standard execution however vector load instruction load data sixteen contiguous array offset iteration therefore dependence lane load lane instruction access address lane instruction lane lane corresponds horizontal dependence instruction technique conventional dependence representation lane information independent lane vector statement however srv operation vector statement without dependence lane information essential dependence detection addition horizontal dependence define address alignment address aligns vector specific vector architecture vector architecture consideration vector byte address etc alignment address span consecutive alignment address alignment address alignment vertical disambiguation mechanism identify vertical data dependence baseline microarchitecture srv lsu contains logic marked dash title vertical disambiguation logic consists vector per saq LQ compute issue correspond byte access correspond saq LQ entry relative address alignment byte access vector vector determines byte overlap issue load VOB vector vertically overlap byte vector code listing vector saq SDQ vector load instruction issue assume address alignment dynamic instance instruction xab data offset byte mention previously instruction operates byte lane elem lane important instruction issue saq consult occurs entry instruction address alignment byte access vector instruction VOB vector consists overlap memory address offset byte address alignment byte instruction indicates data load prior forwardable addr align offset saq LQ issue load info addr align byte access lane elem offset lane elem VOB vector horizontal violation hob vector overall VOB vec overall hob vector vertical disambiguation logic horizontal disambiguation logic detailed vertical horizontal disambiguation logic structure issue instruction saq LQ vector generate data SDQ generate signal addr align offset lane elem saq content  xab issue load  VOB xab vertical disambiguation code listing vector load issue VOB indicates detail load instruction issue  vector calculate   vector saq address alignment VOB vector VOB vector  overall VOB vector indicates byte issue load instruction prior whereas unset byte memory action manage priority data described witt multiple SDQ entry data load instruction data multiple SDQ entry contiguous load data previous violation model data within cycle explain witt however violation rare VI therefore conservative implementation handle multiple cycle without incur measurable performance penalty occurs instruction issue non zero overall VOB vector indicates vertical memory violation load beyond squash happens load non zero VOB vector model microarchitecture assumes load reorder respect earlier program outcome predictor functionality predictor largely orthogonal srv affect vertical disambiguation horizontal horizontal disambiguation mechanism srv extra horizontal disambiguation logic alongside conventional vertical disambiguation logic performs horizontal disambiguation parallel vertical disambiguation marked dash title horizontal disambiguation logic consists vector identify horizontal memory dependence violation horizontal violation vector another byte overlap issue load hob vector horizontally overlap byte vector illustration code listing contiguous vector access vector instruction vector load instruction instruction issue VOB vector described IV correspond byte instruction access account offset address alignment instruction however address alignment offset memory dependence violation violation byte later lane load  vector onwards byte violate byte hob vector VOB vector horizontal violation vector correctly byte violate memory dependence violation vector cannot byte vector load instead load obtain byte cache addr align offset lane elem saq content  xab issue load  VOB horizontal violation hob xab horizontal disambiguation code listing vector load issue vector code indication horizontal dependence identify instruction however identify horizontal  violation data load complicate various vector memory access contiguous scatter broadcast lane instruction access logic combination issue load prior occurs issue prior load scatter operation perform action individual load instruction contiguous address alignment offset issue load previous saq overlap byte SDQ VOB vector forwardable VOB vector hob vector otherwise horizontal violation occurs issue load obtain forwardable data scatter lane memory access load lane previous lane VOB vector indicates forwardable byte SDQ entry VOB vector correspond hob vector otherwise horizontal violation detect issue load ignores overlap byte SDQ entry data forwardable SDQ load memory contiguous scatter contiguous scenario horizontal violation vector initialise correspond overlap lane contiguous load prior scatter mth lane marked load lane contrast contiguous prior mth lane marked shift horizontal violation vector byte data correspond SDQ entry horizontal violation issue load access VOB vector  correspond horizontal violation vector forwardable byte SDQ entry hob vector broadcast contiguous broadcast scatter scenario variant situation instruction contiguous contiguous load scatter difference treat broadcast access memory address lane construct VOB vector hob vector accordingly execution listing horizontal raw violation detection assume array allocate address xff lsu address alignment byte iteration execution information load instruction LQ entry within pipeline scatter instruction split sixteen byte  entry saq correspond entry SDQ scatter instruction writes array address load entry LQ scatter writes data address  address alignment load instruction xff entry overlap access scatter load offset scatter load instruction overlap happens byte counting therefore VOB vector horizontal violation vector horizontal disambiguation logic interested lane lane scatter instruction  VOB vector horizontal violation vector hob vector execution scatter writes array address alignment load VOB vector horizontal violation vector concerned identify lane load scatter lane onward  however vector hob vector addr align offset lane elem LQ content load xff omit clarity issue scatter VOB horizontal violation hob xff xff xff xff xff horizontal disambiguation load queue iteration code listing vector meaning although conflict dependence violation data memory writes array memory dependence violation non zero hob vector due raw violation lane writes non zero hob vector scatter instruction execute hob vector  overall hob vector reduce lsu byte srv replay register consult srv non zero replay lane load data experimental setup evaluate performance srv benchmark spec cpu purpose workload application NAS parallel benchmark NPB suite  ssca hpc challenge benchmark suite rodinia benchmark suite hpc scientific domain spec benchmark reference input NPB input eleven benchmark spec others compile toolchain model srv architecture within gem simulator extend version already contains scalable vector extension sve aarch ISA core model fix vector agnostic simulation describes simulated processor parameter configuration core 3GHz pipeline fetch decode issue width lsu entry IQ entry rob entry saq writes CAMs SDQ writes vec reg file writes cache vec cycle non mem integer others mem load pred entry local entry global  entry  entry RAS cache KiB cycle lat cache MiB cycle lat core memory experimental setup compile application extend version llvm performs auto vectorisation sve although application srv limited loop currently focus loop vectorisation within compiler modify analysis enable compiler identify loop statically unknown memory dependency compiler bypass  loop mechanism openmp hint later transformation stage performs vectorisation regardless memory dependence transformation amend pas bound loop within srv srv instruction workload compile optimisation baseline sve srv binary simulated srv vectorisable loop detailed outof cpu model code maintain dynamic instruction due prohibitively per loop speedup srv vectorisable loop benchmark correspond coverage dynamic instruction baseline microarchitecture simulation spec cpu benchmark invocation srv vectorisable loop simulated detailed cpu model loop dynamic instruction average dynamic instruction per loop across workload invocation simulate perform version spec benchmark memory dependence difference invocation invocation loop conclude spec benchmark later invocation loop behaviour characteristic invocation srv vectorisable loop benchmark simulated VI performance evaluation speedup srv vectorisable loop cannot vectorised without srv normalise performance  sve performance benchmark report loop achieve speedup loop bzip gcc hmmer  achieve loop speedup achieves loop speedup majority instruction srv vectorisable loop already vectorisable exist technique compiler imprecise alias analysis hinders vectorisation however omnetpp soplex xalancbmk achieve relatively loop speedup  loop memory computation ratio operation multiple instruction data benchmark srv vectorisable loop dynamic instruction percentage srv  loop unknown memory dependence sole feature prevents vectorisation enhance coverage vectorisation program speedup benchmark vectorisation sve advanced compiler technique srv however astar milc xalancbmk  considerable amount code advantage srv accounting dynamic instruction respectively program speedup benchmark calculate dynamic instruction srv vectorisable loop coverage additional benefit srv brings beyond vectorisation speedup spec benchmark application geometric sve vectorisation srv achieves speedup spec benchmark application floatingpoint benchmark spec benefit srv srv vectorisable loop benchmark percentage dynamic instruction bzip gcc gobmk href observable speedup loop vectorised srv spec benchmark negligible performance enhancement execution barrier cycle srv vectorised loop percentage violation execution srv vectorised loop srv program obvious speedup loop vectorised srv considerable program moreover loop operation vectorisable exist technique srv enables vectorisation operation realise speedup overall geometric speedup overhead analysis srv introduces performance overhead cycle introduce execution barrier cycle within srv vectorisable loop benchmark cycle srv instruction stall issue later instruction execute due serialisation benchmark execution barrier execution cycle srv vectorisable loop bzip omnetpp astar milc negligible performance overhead respectively execution barrier however execution barrier significant perlbench hmmer href xalancbmk  loop benchmark another source overhead occurrence memory dependence violation rollback srv vectorised loop broken memory access replay memory dependence violation instruction within vectorised loop benchmark actually incur violation others loop static analysis suggests violation none actually benchmark memory dependence violation per static loop instruction fourth overhead replay vector iteration raw dependence violation bzip instruction raw dependence violation replay meaning additional vector iteration contrast instruction raw dependence violation translates overhead iteration instruction loop instruction violation account percentage advantage srv guarantee execution loop vectorise compiler cannot iteration dependence due dynamic conflict rare vector instruction handle furthermore compiler cannot absence loop vectorise none loop  vectorisable exist hardware compiler hardware parameter memory access loop previously  due statically undecidable dependence srv vectorise safely majority loop memory access although memory access instruction access due load multi dimensional array pointer chase loop memory access maximum scatter instruction workload load multiple micro ops access lsu address disambiguation srv vectorised loop independently cycle implementation across commercial simulation vector lsu entry srv contains entry lsu execute loop without overflow srv enhances coverage vectorisation additional horizontal address disambiguation vectorisation reduces dynamic instruction therefore potentially reduces address disambiguation however srv introduces extra horizontal address disambiguation memory access instruction vector iteration address disambiguation execute loop vectorised srv sequential execution broken srv increase address disambiguation benchmark bzip omnetpp milc xalancbmk srv incurs address disambiguation sequential execution vectorisation reduces dynamic instruction address disambiguation horizontal srv horizontal disambiguation replace vertical execute load instruction horizontal vertical disambiguation execute instruction although horizontal disambiguation incur comparison vector shift srv hardware execute srv vectorisable loop hence overhead srv almost negligible explore analysis modify McPAT analyse introduce srv McPAT model cam lookup operation calculate dynamic consumption processor issue load instruction model cam lookup buffer load cam lookup load buffer maintain load instruction issue instruction cam lookup load buffer model load squash dynamic consumption introduce srv model srv cam lookup operation extra cam lookup buffer instruction srv reflect extra cam lookup horizontal disambiguation cam lookup load instruction unchanged horizontal disambiguation replaces vertical disambiguation execute load instruction srv however limited detail McPAT model extra vector shift incur horizontal disambiguation model core benchmark srv without vectorisation cam lookup consumption however core negligible lsu contributes average across benchmark benchmark bzip omnetpp milc xalancbmk srv consumption due reduction address disambiguation benchmark srv comparison FlexVec closest technique srv FlexVec compiler generate memory dependence violation limit vector width lane incur violation srv differs FlexVec implicit memory disambiguation mechanism allows lane violate lane execute violation srv potentially execute loop iteration FlexVec due selective replay lane violation vectorise loop efficiently due implicit memory disambiguation mechanism unfortunately aware compiler currently implement FlexVec author opensource therefore FlexVec faithfully reproduce technique loop memory dependence information unknown compile model FlexVec srv emulator validate gem implementation srv dynamic instruction srv FlexVec emulate  instruction instruction source vector enable previous target vector account FlexVec address disambiguation mechanism partial vectorisation already model srv FlexVec evaluation execute sample code surround vectorised loop profitable profiler contrast execute loop vectorisable described impact vectorisation dynamic instruction target loop technique srv dynamic instruction vectorise loop FlexVec benchmark mainly srv incur extra instruction perform moreover vector iteration srv reduce dynamic instruction summary performance improvement introduce srv analyse srv performance overhead FlexVec closest exist technique literature srv architecture demonstrates judicious speculation unleash data parallelism performance benefit simd execution wider code vii related speculative vectorisation technique propose compiler architecture vectorise loop source iteration dependence guard conditional statement rarely code generate lane vector iteration advance vector code execute false vector lane otherwise fallback scalar code execute application speculative vectorisation limited conditional statement cannot iteration dependence cycle moreover partially vectorisable loop vectorised technique another approach combination inspector executor  loop compiler generates inspector code analysis iteration dependence within loop executor program employ specific optimisation loop iteration dependence information inspector technique associate overhead generally additional data structure extra memory operation propose FlexVec partially  loop generate code perform alias however overhead technique highly dependent frequency pointer alias  violation moreover FlexVec attempt vectorise pointer alias memory dependence detect reduces effectiveness vector register  architecture hardware approach propose detect pointer alias  violation however prior focus violation detection violation detect execution sequential mode therefore application technique limited potential exploit data parallelism realise conclusion future selective replay vectorisation technique safely vectorise code periodic unknown memory data dependence hardware monitor memory address access within compiler annotate loop replay simd lane memory dependence violation evaluation loop speedup program speedup across purpose hpc application already vectorised code conclusion srv architecture demonstrates judicious speculation unleash data parallelism performance benefit simd execution wider code future advanced compiler technique advantage srv enhance coverage vectorisation develop optimisation remove serialisation barrier srv improve performance efficiency