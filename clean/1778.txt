mainstream compute poise embrace advent byte addressable non volatile memory nvm important roadblock remain largely unnoticed legacy library nvm library underpin software everywhere nvm program interface designate construct nvm reference legacy library incompatible data obstacle future application nvm introduces approach mitigate issue novel approach around user transparent persistent reference concept allows programmer reference persistent reference normal volatile implementation concept carefully examines soundness describes compiler architecture performance overhead introduction non volatile memory nvm persistency  dram access latency bandwidth programmer data nvm dram without worry lose data upon failure drawn attention recently service provider adopt nvm production environment performance gain reduction across data focus issue prior attention manifest roadblock adoption nvm legacy library library library foundation underpin compute ubuntu lts official package archive instance contains library boost  gtk  constitute layer indispensable execution stack almost mainstream compute codebase library code function hence imperative ensure library future nvm application  cloc  respectively  poise embrace nvm architecture program model code future nvm issue however remain largely unnoticed option legacy library nvm application due persistent data nvm program model persistent program model organizes persistent data pool persistent memory pool   living program mapped virtual address pointer persistent  address pointer program persistent pointer  persistent pointer implement differently conventional pointer exist program model define persistent pointer data dereference apis intel PMDK  persistent pointer  adopts pack pool offset byte pointer declare reference persistent via persistent pointer explicit persistent reference legacy library obstacle nvm application accept data persistent invocation apis access reside nvm nvm mainstream compute roadblock already manifest practical adoption nvm instance incompatible data virtual address recognize challenge adopt nvm production redis skilled engineer intel spent redis nvm accord git repository update code UI OOVBM  PNQVUFS SDIJUFDUVSF acm annual international symposium computer architecture isca doi isca constitute codebase redis migration incomplete data structure  unavailable hence effort production another research project migrates index data structure another  code principled requirement desirable principled requirement avoid manual code rewrite whenever legacy library rewrite program model rewrite massive global access potential importantly library usually application via parameter volatile invocation persistent uncertainty complexity rewrite codebase legacy library manual code rewrite avoid whenever reliance feature exist program generic template instance potentially simplify treatment data uncertainty issue mention earlier recent  propose garbage collection GC mitigate software migration nvm however applicable volume library generic GC accommodate various usage manipulation pointer essential soundness important library program performance overhead efficiency library architecture minor propose propose requirement embed persistence volatility info pointer pointer runtime discern treatment realize effectively address concern soundness efficiency specifically contribution introduce concept user transparent persistent reference effortless migration legacy library nvm storage format persistent pointer conventional pointer persistence systematically analyze soundness user transparent persistent reference examine pointer related operation allows freedom hence complexity pointer manipulation architecture reduces execution overhead user transparent persistent reference nearly negligible empirically demonstrate efficiency implementation benefit mitigate library migration complexity popular library boost machine application  persistent reference significantly mitigate migration burden program library hardware efficient user transparent persistent reference crucial pure software implementation slows library average hardware remove nearly entire performance loss user transparency necessarily sacrifice performance hardware explicit persistent reference gain speedup average thanks reduce memory address translation entail overhead incur migrate program nvm minor benchmark average architecture knowledge propose legacy library nvm software developer adopt program legacy library instal compiler plugin persistent memory allocator legacy library recompilation binary rewrite invoked nvm application outside inside persistent transaction user rely achieve crash consistency although architecture involves minor instruction benefit however tremendous massive rewrite effort volume legacy library background II propose careful analysis soundness IV architecture compiler efficiency discussion relation crash consistency code optimization VI vii related conclusion IX II background exist persistent program model commonality brief explanation intel  persistent memory programmer persistent pool pool persistent memory operating assigns unique ID pool reading pool programmer pool pool operating pool contiguous virtual address address memory mapping file address operating pool address execution program however certainly user persistent transaction library manual compiler code offset pool pool demonstrates mapping virtual address pool pool obj physical address mapping obj pool mapping offset offset persistent pool persistent pool program model mention earlier representation address persistent pointer volatile pointer pointer valid persistent mapped address principle user transparent persistent reference despite difference representation program difference program reference persistent nvm volatile dram user transparent persistent reference embed info persistent volatile representation pointer runtime discern pointer challenge ensure soundness efficiency scheme focus soundness efficiency respectively memory layout pointer representation illustrates virtual address layout representation pointer dram nvm virtual address layout pointer representation intra  offset  ID virtual address dram data nvm data virtual address relative address virtual address layout pointer representation terabyte virtual address byte dedicate dram dedicate nvm virtual address nvm translate address physical address significant msb pointer interpret constitute virtual address correspond regular conventional pointer relative address correspond persistent pointer relative address contains pool ID intra pool offset runtime pseudo code illustrate runtime interpret pointer appropriately execute pointer assignment statement simply flag pointer function  rava respectively translation virtual address relative address EF EF CD CD EF CD CD pseudocode runtime interpretation pointer execute pointer assignment statement  translates virtual address relative address rava consideration concern  persistent reference removal difference program soundness issue program usage pointer overhead runtime minimize conduct software pointer access obviously incur overhead discus issue IV soundness soundness manner iso standard enumerate operation involve pointer operation pointer correspond behavior semantics user transparent persistent reference wherever  various pointer pointer nvm dram AA modify semantics operation iso standard allows pointer correspond semantics user transparent persistent reference normal virtual address representation relative address representation specification iso standard easily confirm user transparent persistent reference return operation involves pointer consistent specification iso standard despite actual representation pointer relative address format persistent pointer absolute address format volatile pointer dynamic format automatically resolve difference whenever intuitively hardware convert absolute address relative safely convert relative address absolute address nvm pointer operation performance opportunistically pointer relative address convert storage propose scheme preserve relative pointer optimization opportunistically without impair soundness efficiency naively dynamic pointer access incur overhead code increase explore reduce overhead novel architecture pure compiler analysis transformation hardware hardware introduces instruction additional semantics memory instruction assistant hardware component dramatically reduces overhead dramatic lightweight compiler instruction semantics pointer format persistent pointer relative address format conventional pointer virtual address format identification msb distinguishes relative address virtual address furthermore virtual address split equally volatile persistent denote source destination register respectively rava  function convert relative virtual address virtual relative address respectively semantics memory reference instruction instruction semantics instruction semantics  load mem mem rava  mem mem rava storep mem  mem mem rava  mem rava mem mem rava error combination load instruction relative address convert virtual address issue tlb cache similarly applies  instruction additionally instruction storep  regular instruction intend data memory location storep intend pointer memory location architecture pointer pointer convert relative address memory program storep address persistent memory location storep replace  function  int semantics storep largely reflect contains virtual address hence conversion relative address relative address virtual address relative address hence conversion virtual address pipeline assume compiler chooses  storep whenever data pointer memory respectively specifically llvm optimization pas detects pointer operation translates combination llvm irs accord semantics code cpu issue load arithmetic logic memory management data cache storep llvm pas  storep semantic overview compiler assumption modification cpu pipeline cpu pipeline modification load functional execute load  instruction respectively regular processor additional convert relative address virtual address effective address generation execute stage translate relative address virtual address adopt translation structure analogous tlb persistent pot persistent lookaside buffer POLB translation virtual address pipeline hence mechanism load bypassing load memory dependence speculation affected storep instruction additional processing convert pointer format introduce functional storep translate virtual relative address achieve relies finite machine translation derives pointer operand hardware logic implement   storep finite machine  memory management POLB VALB tlb pow  ptw load queue buffer entry FSM entry contains  translate virtual address translate relative address issue conventional operation tlb dependency POLB persistent aside buffer ObjectID virtual address VALB virtual address aside buffer virtual address ObjectID pow persistent walker  virtual address walker ptw walker memory subsystem   storep function dataflow operation   solid modify module dash arrow data  refers micro operation storep instruction virtual relative address conversion incur variable latency buffer outstanding storep instruction multiple instruction execute concurrently buffer entry contains placeholder virtual address relative address translation entry finite machine progress translation memory management MMU lookaside buffer implement rava  translation POLB virtual address lookaside buffer VALB respectively VALB translates virtual address relative address retrieves PMO ID virtual address concatenates offset portion virtual address VALB entry PMO address PMO PMO ID VALB ternary content addressable memory TCAM entry prefix retrieval PMO ID POLB kernel  VALB kernel virtual address  PMOs address  adopts structure propose tlb POLB VALB permission permission already enforce tlb storep instruction execute portion illustrates tracked machine translate virtual address relative address respectively simultaneously virtual address tlb permission addition protection permission fault storep incur fault error hardware complexity storage overhead storep functional reservation hence affect critical delay instruction POLB VALB access prior tlb hence delay critical address translation MMU model simulation prediction mechanism deployed accelerate predict non PMO access bypass POLB VALB future chip storage hardware structure FSM POLB VALB minor KB detailed II others   software data structure kernel memory cactus evaluate chip storage consumes  core  processor II hardware implementation entry num structure byte entry byte FSM POLB VALB byte compiler unlike software architecture compiler role generate storep instruction assignment operation function generate load  instruction data load assignment instruction accept user transparent persistent reference input leverage storep convert relative virtual address illustrates link append function utilize storep instruction insert llvm pas hardware user transparent persistent reference llvm pas hardware user transparent persistent reference invoked optimization none recognizes storep instruction code generate code generate code link append function storep instruction pointer temporary variable tmp tmp stack variable volatile memory accord semantic pointer assignment   storep instruction translate virtual address relative address compiler besides hardware explore pure compiler static analysis infer actual pointer program hence avoid insertion actual pointer precisely compiler inference topic program task context statement void  compiler dram stack variable persistent memory allocation function return relative address per definition however program due difficulty function parameter passing alias hence cannot remove dynamic outline approach implement pas llvm conduct inference inference module pas predefined function accept return relative address   argument return function backward dataflow analysis propagate variable propagation pointer semantic assign  pointer stack variable variable  pointer code OS memory layout program assignment logical relational llvm pointer detection pointer inference component workflow compiler approach pointer variable compiler cannot compile compiler insert dynamic demonstrates generate code link append function relational operation compiler insert  pointer convert virtual address accordingly assignment operation compiler insert  function ED AB CD CD CD CD AB ED CD CD CD AB CD AB code generate code link append function generate llvm pas VI discussion propose legacy library callable nvm application recompilation binary rewrite instruction code replace  storep instruction library function invoked application regardless library function persistent volatile enclose persistent transaction application code compiler application program insert runtime instruction application library function ensure crash consistency obviously prevent user library advantage nvm instance persistent transaction inside library software hardware implementation insert code generation pas code optimization prevents scalar optimization lazy code PMO detach code generate generate code pool detach inconsistent program semantics subexpression elimination software user transparent persistent reference compiler generate rava function statement trivial easily remove redundant rava employ user transparent persistent reference pas however optimization inconsistent program semantic illustrates pool associate detach program execution code generate software interrupt rava function optimize code executes normally potentially compiler conduct inference uncertain insert extend hardware instruction software dynamic report however thanks superior performance hardware propose hardware prefetchers physical address proposal data placement physical address virtual address stride prefetchers lose performance data persistent memory pool mapped distribute virtual address however consequence persistent memory pool address mapping introduce persistent memory program model propose technique vii evaluation evaluates soundness propose technique aspect soundness semantic program preserve pointer nvm relative address productivity modify library application migrate nvm largely reduce performance performance program generate propose technique comparable default explicit persistent reference breakdown sensitivity analysis latency hardware VALB breakdown benefit methodology benchmark complexity compatibility library nvm motivation focus evaluation commonly library none exist nvm benchmark evaluate library performance developed benchmark suite specifically concentrate boost popular library program task structure linear algebra pseudorandom generation multithreading image processing regular expression commonly data structure boost focus source code performance library harness invoke harness intel PMDK framework nvm core operation harness mapping evaluate data structure harness replaces mapping scheme correspond implementation data structure operation performance harness ycsb generate workload specifically  preset workload ycsb generate operation byte text operation operation insert update index data structure pointer operation access distribution zipfian distribution recently insert likely data structure role mapping hence compatible harness link hence harness evaluate generates node node pointer byte randomly generate integer iterates link accumulates addition conduct detailed machine application knn machine algorithm collection  library armadillo boost implement knn algorithm widely data mining iris dataset input dataset contains sample iris persist content data structure explicitly specify  memory allocator data volatile data structure code modification application code boost library knn benchmark persist matrix code modify modification knn application  armadillo boost library benchmark benchmark description implement boost library link node insert iterate hash chain hash bucket rbtree balance binary application  avl database transaction frequent lookup splay splay garbage collector retrieve multiple SG  balance rebalancing performance implement  armadillo boost knn algorithm widely classification data mining hardware simulator evaluate implementation interval timing accurate hardware simulator  simulator pin frontend implement instruction magic instruction  latency IV simulator parameter capacity latency POLB accord CACTI ensure latency cycle VALB default latency POLB conduct sensitivity influence latency IV simulated architecture component parameter ISA  architecture cpu core  cache predictor pentium penalty cycle data tlb entry cycle tlb entry cycle cycle data cache entry cycle cache KB cycle cache MB cycle memory cycle dram cycle nvm buffer POLB cycle cycle VALB cycle cycle version performance comparison focus version HW version nvm program hardware user transparent persistent reference SW version nvm program compiler user transparent persistent reference explicit version nvm program representative explicit persistent reference program model version apis program access nvm data access ID relative pointer convert virtual address hardware extension volatile version native implementation program normal pointer without consideration nvm version nvm overhead cannot nvm reference examine overhead version soundness evaluation soundness user transparent persistent reference examine execution program propose HW SW version empirically output consistent output program correctness pointer data structure confirm program output moreover pointer persistent relative pointer format throughout entire execution program confirm analytical IV moreover soundness technique production quality llvm suite suite contains program bitcode llvm intermediate representation IR program application regression gcc  suite SW version user transparent persistent reference semantics pointer operation persistent memory persist entire heap replace default memory allocator  library transparently override malloc function allocate memory nvm stack memory remains volatile prior performance evaluation report execution program normalize volatile observation HW version outperforms explicit version observation surprising productivity improvement explicit speedup detailed analysis explicit version due apis IDs pointer address conversion access persistent contrast HW version conversion naturally assign normal pointer hence reuse later access pointer illustrates  benefit removal difference persistent volatile pointer program SW version suffers significant overhead although compiler inference avoid insertion dynamic whenever complexity pointer alias analysis substantial amount dynamic code dynamic conditional statement mispredictions report mispredictions normalize volatile version mispredictions SW version EPR SW HW execution normalize baseline hash RB splay avl SG geomean simulated execution normalize native execution EPR denotes explicit persistent reference CD CD GH FE CD CD GH FE user transparent persistent reference explicit persistent reference FE FE access address translation  user transparent persistent reference access persistent naturally reuse virtual address attain conversion  explicit persistent reference access persistent conversion relative address virtual address HW version overhead hash relatively program relatively data locality hence insert dynamic weigh overall hardware user transparent persistent pointer remove almost overhead incur persistent pointer overhead splay volatile persistent pointer dynamic conversion HW SW misprediction normalize baseline hash RB splay avl SG geomean mispredictions normalize volatile version dynamic conversion absolute address relative vice versa benchmark refers absolute address rel refers relative address benchmark dynamic rel rel hash RB splay avl SG sensitivity analysis VALB latency latency VALB  generates marginal impact performance cycle latency VALB  implies VALB lookup access memory execution benchmark increase execution normalize execution explicit persistent reference hash rbtree splay avl SG execution normalize baseline amortize latency   cycle execution amortize latency VALB  normalize execution explicit persistent reference demonstrates impact memory access instruction storep access VALB  comparison memory access access POLB pow knn productivity performance detailed knn multiple library armadillo matrix creation boost computation VALB involve portion storep instruction hash RB splay avl SG geomean POLB involve portion load instruction hash RB splay avl SG geomean portion load instruction involve VALB POLB knn algorithm matrix input internal output matrix compound data structure define armadillo library matrix contains pointer data array metadata instance matrix  matrix nvm dram another data collection program output knn knn  output matrix nvm pointer convert persistent pointer allocate matrix nvm input matrix instead interact directly matrix boost library input  matrix assume matrix  propose technique code modify replace malloc persistent version automate compiler explicit version contrast code data function knn machine library function usable situation equip dram nvm handle combination data placement dram nvm matrix correspond possibility explicit version knn code quickly code version maintain future performance HW version marginal difference baseline load instruction incur address translation SW version slowdown VI related program framework user transparent persistent reference relocation relocation overhead relocation espresso java update pointer via pointer trace  java update pointer via pointer trace pmem update pointer via pointer trace PMDK independent pointer pointer breeze update pointer via pointer trace atlas iDO independent pointer byte pointer overall observation overall conclude user transparent persistent reference HW SW affect soundness program user transparent persistent reference remove program burden migrate code library nvm propose hardware significantly improves performance nvm program explicit persistent pointer reduce execution overhead nearly negligible related recently persistent volatile essential practical persistent program legacy library expectedly benefit without distinguish persistent volatile pointer however exist proposal limited summarize VI espresso  pmem mitigate explicit persistent reference manage java semantic java reference pointer operation simpler java pointer cast integer operation obstacle technique apply library garbage collection enable reusability persistent propose prior espresso conventional pointer persistent  security address layout randomization java virtual machine load persistent heap address program execution mapping fails address occupy espresso persistent heap address update pointer within persistent heap  reachability criterion persistent automatically dram nvm jvm update pointer hence pointer persistent programmer however applies manage program virtual machine unclear tackle reusability proposal atlas  disallow nvm mapped address restriction loss security protection opportunity assume nvm mapped address NV heap PMDK pointer compose pool ID intra pool offset pool hence byte pointer incurs substantial overhead propose   pointer software translate  pointer virtual address propose hardware acceleration relative pointer compose pool ID intra pool offset instruction access data relative pointer programmer pointer apis persistent belonging explicit category evaluate proposes conversion relative pointer conventional pointer semantics propose user transparent address conversion reusability selects pointer retain nvm implement pointer conversion offset pointer   programmer function explicitly dereference relative pointer convert conventional pointer relative pointer enhance semantics pointer operation propose implement compiler automatically insert dereferences conversion proposal persistent volatile breeze programmer annotate persistent pointer PMDK persistent pointer template persist ptr identical interface operation persistent pointer normal pointer programmer define persistent pointer instance persist ptr template later persistent pointer normal pointer however programmer define persistent pointer normal pointer materialize program template absent pointer explore context manage generational garbage collection persistent assumption persistent pointer allows pointer operation lack runtime outweighs performance consideration relevant technique implement user transparent persistent pointer java barrier technique orthogonal semantics pointer operation hardware propose barrier function java compiler runtime transparent insert program memory access content function define developer java runtime compiler easily implement semantics pointer operation propose IV java barrier furthermore software scheme suffers substantial runtime overhead reference conditional barrier implement assembly instruction slowdown java program operation user transparent persistent pointer complex apply memory access hardware appeal preserve performance IX conclusion library fundamental layer compute stack lack legacy library nvm obstacle practical adoption nvm introduce introduces user transparent persistent reference concept effortless migration legacy library nvm carefully analyzes soundness pointer related operation proposes lightweight architecture eliminate runtime overhead  persistent reference report effectiveness popular library boost machine application propose promising remove roadblock legacy library adoption nvm