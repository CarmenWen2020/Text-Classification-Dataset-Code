fence instruction coarse grain mechanism enforce instruction execution pipeline  instruction completion instruction perform undo non volatile memory nvm update variable correspond undo entry persist instruction reorder unfortunately ISAs execution dependence instruction register memory dependence programmer fence unnecessarily serialize unrelated instruction remedy limitation propose ISA extension capable execution dependence proposal execution dependence extension EDE aarch ISA hardware realization EDE enforce execution dependence stage pipeline issue queue IQ another buffer WB implement IQ WB simulator nvm application overall EDE IQ WB fence attain average workload speedup respectively index fence instruction ISA extension introduction fence instruction enforce instruction execution pipeline fence stall execution subsequent instruction instruction memory fence memory access instruction fence affect instruction however fence coarse grain mechanism execution instruction however requirement program necessitate execution instruction completion instruction grain mechanism instruction execution instruction reorder arbitrarily fence  unnecessary execution stall environment fence persist operation non volatile memory nvm undo undo entry persist update enforce option fence persist perform thomas  affiliate illinois   research update unfortunately approach unnecessarily constrains instruction execution  instance update entry execute parallel insertion fence serialization independent instruction ideally execution dependence hardware enforce define execution dependence individual instruction sink instruction consumer cannot source instruction producer processor execution dependence honor underlie hardware instruction register dependence communicate register memory dependence access memory location however cannot processor honor execution dependence unrelated instruction execution dependence exists nvm undo entry reduce fence propose ISA extension capable execution dependence proposal execution dependence extension EDE aarch ISA EDE instruction convention define execution dependence specifically augment instruction opcodes execution dependence edk link execution dependence producer consumer via execution dependence define link instruction via EDKs data dependent instruction link register EDE precisely convey variety instruction execution ordering instruction ordering description without fence thereby instruction proceed execution ordering conveyed EDE responsibility hardware honor propose implementation IQ WB IQ EDE execution dependence enforce issue queue hardware monitor execution dependence alongside register memory dependence instruction execute IQ achieves significant performance gain UI OOVBM  PNQVUFS SDIJUFDUVSF acm annual international symposium computer architecture isca doi isca opportunity improvement IQ stall instruction pipeline hence propose aggressive enforces execution dependence buffer instruction retire WB evaluate performance impact EDE implement IQ WB simulator model core demonstrate EDE utility nvm environment develop nvm kernel persistent memory development kit PMDK application EDE instead fence overall EDE IQ WB attain average workload speedup respectively contribution identify instruction execution dependence benefit mechanism grain instruction propose EDE ISA extension allows instruction execution dependence conveyed hardware propose practical hardware realization EDE evaluate EDE significant performance improvement II background motivation non volatile memory fence atomic recently latency byte addressable non volatile memory nvm become commercially available however multiple volatile cache processor nvm hence ensure processor nvm propagates beyond cache nvm processor introduce clwb instruction writes cache nvm retain cache armv introduce instruction propagate writes persistence domain specifically data unified cache virtual address persistence DC cvap instruction aarch ISA clwb DC cvap ensures virtual address nvm aarch clwb DC cvap relaxed memory instruction update nvm deterministic hence guarantee fence insert specifically guarantee clwb instruction writes CLWBs insert fence sfence instruction fence barrier aarch data synchronization barrier dsb DC  relative instruction  impose instruction instruction dsb execute instruction aarch data memory barrier  imposes memory instruction however instruction currently DC  array array array void uint operator const uint val val update val val application code framework code inject persistence operation update persistent array void uint val uint entry slot undo reserve uint slot addr val slot val val asm volatile cvap dsb slot memory void update uint val uint val val val asm volatile cvap val memory framework function persist framework function update persist framework implementation persistence operation feature nvm framework user failure atomic ability collection persist atomically failureatomic persist none persist framework traditionally failure atomic undo redo operation typically insertion fence fence overhead nvm application understand fence negatively affect performance persistent application implement undo fence code snippet update persistent array uint minimize effort developer persistent application persistent framework operator overload automatically perform persistent action persistent framework overload assignment operator statement transparently perform persistent action code val via function update val val via function update undo update persistently perform array array array application code phase update update update dsb phase phase dsb dsb phase execution timeline reorder limitation impose  contains array ptr array contains slot ptr ldr load stp addr val cvap persist slot dsb slot persist mov load str cvap persist array asm modulo ptr location array asm modulo ptr location aarch assembly slot within undo reserve address finally entry persist ensure persist instruction emit asm volatile code described II aarch issue DC cvap dsb dsb guarantee entry persist update memory update variable location DC cvap issue guarantee nvm dsb unnecessary become persistent failure atomic assembly instruction generate compiler code load array address via aarch pairwise stp instruction DC cvap issue persist entry stp byte align cache hence DC cvap persist register perform update persist assembly generate array assembly array array nearly identical update difference update storage location array array location fence unfortunately fence coarse grain mechanism instruction enforce unrelated instruction significant performance overhead impact  update timeline update operation execute relative  clarity operation associate update differently array array array label execution phase  phase related array execute dsb prevents instruction array update array array execute phase update array array execute concurrently however dsb instruction array update array phase update array update code address reserve entry slot update independent ideally processor overlap execution instruction update specifically execute instruction phase update execute parallel update update correspond however dsb enforce persistence ordering update unnecessarily serialize code commonplace failureatomic nvm framework furthermore usually reorder instruction limit fence overhead compiler information intention fence insert framework code hence unable operation register dependence memory dependence execution dependence ldr stp cvap dsb mov str cvap program dependence graph instruction around persistent operation transparently insert framework code user unable manually reorder operation inability convey instruction execution dependence issue previous currently convey arbitrary instruction dependence within ISA currently register memory dependence conveyed ISA register dependence communicate instruction refer register memory dependence conveyed instruction access address however logical dependence exist expressible via memory location register instruction register arrow memory dependence dash arrow code label register dependence instruction define register instruction register memory dependence chain access address collection register memory dependence imposes schedule restriction processor functional throughput processor execute instruction however processor respect register memory dependence within execution DC cvap stp str memory dependence instruction ensures memory however explain ensure DC cvap executes str convey introduce notion execution dependence execution dependence cvap str arrow execution dependence denotes instruction correctness execution dependence source operation dependence sink operation instruction completes define operation observable IV describes completion detail cvap register str instruction access memory address processor naturally respect execution dependence therefore insert dsb code unlike register memory dependence dsb enforces across instruction unfortunately presently option ensure execution dependence honor processor encode execution dependence within instruction limitation propose instruction convey execution dependence execution dependence explicitly enforce completion specify instruction collectively instruction execution dependence extension EDE instruction addition traditional memory register dependence execution dependence arbitrary prior instruction define enable introduce concept execution dependence edk edk instruction edk consume instruction EDE allows instruction link sink instruction edk consumer cannot source instruction edk producer benefit EDE explicitly execution dependence instruction ISA fence within application substantially reduce instance EDE convey execution dependence cvap str without dsb instruction reduce fence processor achieve performance instruction execute parallel hardware EDE via EDE convey instruction execution dependence hardware however hardware responsibility information maximize application performance hardware implementation EDE evaluate practical option implementation IQ enforces execution dependence issue queue execution edk consume instruction delayed correspond edk instruction IQ effective achieve performance benefit indeed cacheline writeback instruction observable memory retire IQ unnecessarily stall execution edk consume cacheline writeback instruction pipeline prevent stall propose aggressive enforces cacheline writeback instruction buffer WB WB cacheline writeback instruction retire execution dependence satisfied however memory buffer execution dependence enforce overall edk consume cacheline writeback instruction retire WB enables subsequent independent instruction proceed  IV EDE ISA definition EDE specification concept define execution dependence afterwards introduce EDE instruction EDE concept execution dependence conveyed ISA abstraction define dependence source dependence sink link source sink dependence source instruction dependence producer dependence sink instruction dependence consumer link execution dependence edk execution dependence EDKs link instruction therefore convey execution dependence traditional register EDKs directly encode instruction however unlike register data instead EDKs index execution dependence edm edm edk instruction instruction decode edm access instruction EDKs execution dependence specifically edm instruction sink execution dependence instruction source execution dependence edm update IV EDKs define sixteen EDKs edk edk throughout refer edk operand edk refers access edm fifteen sixteen entry edk serf zero zero encode instruction ignore instruction execution dependence source sink dependence producer dependence producer instruction source execution dependence consume dependence consumer instruction dependence producer edk access edm edm update edk  link appropriate slot subsequent dependence consumer instruction edk query edm entry link producer dependence consumer dependence consumer instruction dependent prior dependence producer instruction dependence consumer edk access edm entry edm edk dependence consumer instruction edm entry dependence consumer merely query edm modify multiple dependence consumer dependence producer instruction concept define instruction introduce EDE memory instruction variant instruction EDE memory instruction variant propose variant memory instruction operand  EDKuse operand  instruction dependence producer EDKuse instruction dependence consumer operand instruction operand   str instruction parenthesis  EDKuse instruction variant instruction source dependence  sink dependence EDKuse instruction source sink dependence zero edk appropriate operand format consumer instruction dependent previous instruction however explain IV limitation remove EDE instruction execution dependence format memory instruction aarch cacheline writebacks discus apply execution dependence variant load synchronization primitive component instruction variant definition dependence producer instruction dependence producer correspond dependence consumer memory str pairwise stp instruction visible processor writeback instruction DC cvap correspond data guaranteed persist definition completion aarch instruction EDE instruction EDE introduces instruction handle unusual  EDKuse EDKuse edk  inst ops inst ops inst ops inst ops inst ops inst ops inst ops inst ops inst ops EDKs  EDKuse EDKuse instruction prior dependence producer producer via multiple  instruction execution dependence multiple prior dependence producer useful edk resolution multiple merge instance instruction edk edk another insert  edk edk instruction desire outcome edk  presence function without intervention callee function overwrite edk caller function incorrect execution dependence link prevent EDE introduces edk instruction instruction dependence producer consumer addition unlike instruction edk prior dependence producer therefore instruction function ensure dependence met detail define convention EDE IX  instruction prevents subsequent consumer instruction execute prior dependence producer consumer instruction useful ensure persistency operation code EDE EDKs define execution dependence series instruction execution dependence arrow execution dependence instruction EDKs define execution dependence multiple instruction concurrently instruction stall execution instruction edk affect execution instruction addition EDKs reuse establish execution dependence apply EDE persistence operation described previous insert dsb ensure update execute instruction execution dependence format convey dependence specifically void uint val uint entry slot undo reserve uint slot addr val slot val val asm volatile cvap dsb slot memory label dependence producer edk label dependence consumer edk void update uint val uint val asm volatile str cvap val val memory apply EDE persistence operation modify DC cvap dependence producer edk consumes zero similarly update modify str dependence consumer edk zero dsb longer remove hardware implementation mapping producer consumer described IV execution dependence edm fifteen entry edk  implementation dependence producer edm entry producer flight instruction ID instruction EDKs decode hardware access edm instruction consumer edk edm entry edk empty instruction execution dependence instead edm entry edk empty instruction register execution dependence correspond inflight instruction furthermore decode instruction producer edk edm entry update instruction ID instruction EDE perspective remove entry edm therefore dependence instruction completes correspond edm entry query hardware ID instruction edm entry checkpointing edm processor squash sometimes flush speculative pipeline situation edm revert non speculative accomplish edm non speculative  spec another speculative  technique commonly register mapping throughout normal execution  however pipeline squash  spec issue execute mem retire inst ops ideal enforcement execution dependency enforcement execution dependency IQ implementation inst ops inst ops inst ops inst ops inst ops inst ops inst ops comparison ideal IQ execution timeline  execution restarts due similarity edm register file straightforward extend maintain consistent edm multiple checkpoint implement EDE memory instruction execution dependence identify processor ensure dependence upheld strategy propose IQ enforces execution dependence issue queue WB buffer enforce dependence enforce dependence issue queue IQ execution dependence ordering enforce issue queue additional instruction wakeup logic normally instruction deem execute register memory dependence met IQ extra monitoring status instruction execution dependence specifically execution dependence  flag instruction issue queue instruction enters issue queue hardware outstanding execution dependence  otherwise  later instruction execution dependence satisfied  dependence satisfied instruction marked execute exist issue queue schedule logic otherwise unmodified instruction completes IQ  dependence consumer instruction issue queue action multiple instruction become execute drawback IQ IQ effective performance limited edk consume cacheline writebacks observable memory retire hence suboptimal stall execution due execution dependence pipeline IQ understand limitation execution timeline EDE instruction execution dependence instruction access address timeline abstract pipeline issue execute retire stage mem entry buffer correspond writeback instruction memory mem longer pipeline stage memory subsystem latency timeline gap stage instruction stall ideal timeline enforces execution dependence conventional pipeline instruction issue retire enforce execution dependence instruction instruction delay mem hence remains invisible processor instruction completes mem instruction execution dependence prior instruction hence proceed mem immediately retires fourth instruction dependent therefore perform mem instruction contrast timeline IQ IQ enforces execution dependence issue queue instruction unable proceed execute instruction completes mem instruction independent retire instruction retire finally fourth instruction dependent therefore execute instruction mem overall IQ unable unlock ideal amount parallelism instruction execution significantly longer code pairwise instruction dependence nvm application described II motivate factor EDE multiple update proceed parallel unfortunately IQ enable parallelism enforce dependence buffer resolve performance limitation IQ introduce  WB execution dependence resolve buffer instruction consume execution dependence execute normal retirement irrespective producer instruction retirement hardware instruction buffer data memory subsystem execution timeline WB instruction retire without stall execution dependence WB noticeable performance benefit IQ describes WB depth implement EDE instruction  EDKuse EDKuse edk  instruction implement  EDKuse EDKuse instruction monitor execution dependence source IQ WB source instruction instruction edk  instruction monitor completion instruction EDE instruction completes instruction edk EDKs perform instruction dependence producer consumer edk edk none instruction describes implementation instruction WB depth WB implementation WB buffer contains logic enforce EDE dependence recall writeback instruction EDKs decode hardware access edm consumer execution dependence edm ID flight instruction source dependence ID  tag pipeline buffer retires entry deposit buffer hardware performs cam operation buffer contains entry correspond  instruction entry  data memory addition entry buffer memory hardware entry buffer  tag entry  data memory instruction decode access edm potentially source tag   instruction tag pipeline buffer buffer entry instruction data  tag entry data logic regular writes writebacks  tag instruction remove buffer finally  introduce counter per edk overall EDE instruction buffer writebacks instruction edk tag  EDKuse EDKuse pipeline buffer information increment counter instruction enters buffer decrement counter instruction completes  instruction retire appropriate counter retire counter zero VI experimental setup simulator environment evaluate EDE implement IQ WB gem simulator persistent application EDE instruction gem aarch frontend built clang llvm version simulator OoO configuration model processor simulator architectural parameter modify simulator model hybrid dram plus nvm memory asynchronous dram refresh adr setup nvm dram request controller however physical address split address target nvm target dram dram interface model mhz ddr nvm interface asymmetric latency persistent slot DIMM buffer buffer temporarily buffer update nvm architectural PARAMETERS ISA aarch EDE extension compiler clang llvm EDE built processor parameter core processor OoO core instr decode width 3GHz queue entry buffer entry cache KB cycle access latency cache KB cycle access latency cache KB cycle access latency cache MB core cycle access latency memory parameter capacity dram 2GB nvm 2GB nvm latency nvm nvm DIMM buffer slot dram mhz ddr dram rank per channel dram per rank application evaluate performance impact EDE persistent application combination kernel application application available PMDK repository application II kernel application perform series modification array update operation consists update random array swap operation swap random array application undo maintain crash consistency evaluate EDE collection application PMDK  benchmark suite accomplish PMDK framework code leverage EDE perform undo II evaluation data structure btree ctree rbtree  application operation consists insert data structure application multiple operation grouped transaction specifically simulation application operation per transaction transaction application perform operation simulation application completion precisely simulate spent perform operation II APPLICATIONS  kernel application update perform update random array swap perform pairwise swap random array PMDK application btree implementation per node ctree  trie implementation rbtree implementation sentinel node  radix implementation radix architecture configuration architecture configuration baseline  ensure crash consistent aarch barrier unsafe SU aarch barrier instruction  enforce instruction configuration allows hardware perform  violate aarch crash consistency requirement SU approximate overhead fence within nvm application machine IQ WB EDE instead  properly persists finally unsafe  program remove hardware perform  violate crash consistency requirement architecture CONFIGURATIONS configuration description baseline  enforce barrier unsafe SU  enforce sfence allows unsafe  IQ EDE target IQ hardware WB EDE target WB hardware unsafe fence allows unsafe  update swap btree ctree rbtree  geomean normalize execution SU IQ WB application execution vii evaluation execution execution application configuration described VI application execution normalize geometric SU IQ WB reduce execution respectively application attain amount improvement SU outperforms  sts instruction instruction  across application IQ outperforms SU EDE finegrained mechanism dependent instruction SU grain mechanism fence likewise WB performs IQ across application IQ enforces execution dependence issue queue unable maximize amount parallelism described EDE WB enforces execution dependence buffer overlap writes average WB attain execution reduction versus hence recovers significant portion spent ensure nvm update crash consistent remove fence code allows  prevent data recovery overall EDE significantly workload maintain crash consistent indeed EDE IQ WB fence attain average workload speedup respectively issue queue throughput distribution instruction issue cycle percentage cycle processor issue label instruction axis cumulatively setup stack account simulated cycle although simulated architecture instruction decode width issue queue width implementation issue instruction majority cycle writes nvm significant latency pipeline average ipc application SU IQ WB configuration respectively update pending writes nvm sample SU IQ WB swap pending writes nvm sample SU IQ WB btree pending writes nvm sample SU IQ WB ctree pending writes nvm sample SU IQ WB rbtree pending writes nvm sample SU IQ WB  pending writes nvm sample SU IQ WB distribution pending writes nvm persistent slot DIMM buffer nvm interface update swap btree ctree rbtree  average per cycle issue width distribution SU IQ WB distribution instruction issue cycle across application IQ WB cycle unable issue instruction SU average IQ WB cycle issue instruction however WB issue instruction active cycle specifically issue instruction WB issue average instruction IQ WB execution dependent instruction issue queue IQ remain execution dependence satisfied pending writes nvm described VI nvm interface persistent slot DIMM buffer pending writes merge nvm desirable pending writes buffer opportunity coalesce enables writeback throughput however fence processor pipeline stall execution crash consistent application issue nvm writes buffer application configuration distribution pending writes persistent slot DIMM buffer configuration axis pending nvm writes buffer axis percentage sample pending nvm writes sample nvm medium across application pending nvm writes issue fence stall writes kernel application buffer kernel nvm frequency PMDK application maintain data structure pending nvm writes configuration although WB average slightly pending writes nvm configuration previous WB allows faster writebacks nvm configuration behavior future USING EDE multi  APPLICATIONS fence overhead focus overhead fence nvm application fence impose significant overhead multi thread application domain domain fence enforce instruction ordering guarantee data integrity fence memory reclamation lock data structure thread concurrently modify lock data structure reclaim memory remove data structure popular hazard pointer ensure item prematurely freed hazard pointer efficient thread announce currently thread safely active hazard pointer ensure reference exists operation hazard pointer update announce thread access hence alive announcement operation perform aarch code register pointer location assume hazard pointer assume location retrieve location hazard pointer announce thread afterwards pointer location checked pointer location thread successfully announce location access announcement ensure announce location contains ptr location contains hazard ptr loop ldr load location str announce location  fence announcement ldr load location cmp location loop location hazard pointer announcement aarch freed algorithm thread temporarily announces algorithm validate location announce announcement guaranteed load happens announcement unfortunately aarch enforce load dependence currently fence  instruction aarch EDE remove fence achieve str ldr multi thread EDE fence enforce ordering multithreaded application extends beyond hazard pointer described indeed algorithm rely announcement likely fence eliminate via define explicit execution dependence benefit EDE pronounce aarch lock algorithm typically fence guarantee perform java EDE enforce multi thread ordering java memory model guarantee initialize another thread addition java virtual machine jvm implementation traditionally metadata alongside initialize another thread access coordination data subset ideal target EDE another multi thread coordination data kernel circular buffer kernel circular buffer trace data throughout runtime ideally buffer handle update multiple thread concurrently via EDE pop data circular buffer perform lock manner without fence finally concurrent garbage collector   careful orchestration movement data alongside concurrent update initialization dynamic code load environment EDE minimize overhead garbage collection barrier future involves evaluate multi thread EDE plus additional important multi thread discover EDE load synchronization primitive discus EDE memory instruction variant aarch cacheline writeback instruction however EDE multithreaded environment EDE instruction hardware load synchronization primitive detailed description EDE instruction definition hardware load synchronization primitive IX future compiler EDE integration compiler internal representation IR described VI leverage EDE built intrinsics clang llvm however desirable integrate EDE compiler fully specifically compiler internal representation IR augment incorporate execution dependence instance jvm compiler node representation commonly representation creates dependence graph register memory dependence instruction straightforward introduce execution dependence representation compiler perform aggressive optimization without illegally reorder instruction execution dependence described compiler automatically execution dependence initial IR generation automatic persistent application persistency integrate expose EDE framework developer via atomics java  intrinsics longer finally fully integrate EDE compiler EDKs virtualized compiler automatically assign logical edk exist register allocation technique graph linear scan straightforward repurpose edk assignment edk convention along integrate EDE compiler IR establish convention EDE ensure library compatibility normally register pas parameter category  callee register manner EDKs introduce concept caller  caller caller assume overwritten within callee function hence caller function return instruction consumes instruction insert ensures consumer return completion producer caller callee inst ops inst ops foo overwrite EDKs inst ops inst ops function foo inst ops inst ops caller function callee function edk usage across function callee caller function performs action however within callee function  insert instruction dependence producer dependence consumer instruction callee ensure consumer return completion producer correctly maintain caller callee across function caller callee related research investigate  instruction memory consistency model memory consistency model EDE selectively additional constraint manner  fence prior overhead fence within relaxed architecture notable opportunity restriction improve performance proposal selectively enforce fence monitoring coherence message leaf software unchanged hardware coherence message approach limit scope subsequent instruction affected fence technique subset EDE behavior recent focus persistency model underlie hardware reorder writes nvm relevant strand persistency strand persistency subset ordering  via EDE indeed strand persistency limited instruction strand contiguous program EDE eliminates restriction  instruction dependence effectively equivalent strand code interleave another propagate writes nvm designate buffer instead normal cache hierarchy EDE orthogonal buffer persistency complement propose accelerate failure atomic hardware software accelerate nvm EDE mechanism alter consistency model leveraged outside persistency domain accelerate multi thread workload aarch hence EDE multifaceted EDE compelling extension XI conclusion ISAs unable execution dependence instruction register memory dependence hence programmer fence unnecessarily execution remedy propose execution dependence extension EDE allows execution dependence encode ISA described hardware implementation EDE namely IQ WB offs complexity versus performance potential evaluate EDE impact implement IQ WB simulator nvm application overall EDE IQ WB fence attain average workload speedup respectively EDE potential enable aggressive reorder memory access multi thread code hence EDE fully realize performance potential relaxed memory consistency model lock algorithm currently explore avenue