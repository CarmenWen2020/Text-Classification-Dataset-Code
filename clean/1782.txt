ability capture frequent per millisecond persistent snapshot nvm enable compelling unfortunately exist nvm snapshotting technique suffer combination persistence barrier stall amplification nvm lack scalability beyond socket NVOverlay scalable efficient technique capture frequent persistent snapshot nvm randomly access later NVOverlay coherent snapshot efficiently memory previous snapshot across  parallel multi snapshot nvm mapping snapshot nvm avoid excessive amplification demonstrate NVOverlay successfully hide overhead capture snapshot reduce amplification stateof snapshotting technique index non volatile memory nvm snapshotting shadow introduction byte addressable non volatile memory nvm technology leverage persistence focus specifically benefit challenge nvm frequent persistent snapshotting goal capture persistent snapshot physical address nvm rate per millisecond usage model enable frequent persistent snapshot ability efficiently capture frequent snapshot nvm enable persistent  memory enables usage model replay debug distribute application snapshot capture upon user specify aka bursty fashion computation across distribute implement persistent grant NSF samsung intel focus nvm device DIMM factor intel  persistent memory evict epoch versioned domain nvdimm llc slice llc slice fetch fetch evict cst evict coherence resp epoch llc slice epoch versioned domain epoch versioned domain dram nvdimm MNM NVOverlay feature multi snapshot nvm mapping MNM coherent snapshot cst background persistence distribute epoch coherence driven epoch synchronization distribute llc durable data structure grain backup replication latency crash recovery challenge memory avoid nvm amplification fundamental challenge frequency persistent snapshotting efficient scalable challenge arises snapshot quickly minimal amount data snapshot hence challenge exactly within physical address previous snapshot delta capture without normal execution capture coherently across entire parallel application scalable address span multiple socket successfully identify information memory snapshot fundamental challenge snapshot persistent efficiently nvm randomly access later multiple snapshot avoid nvm amplification previous software hardware proposal capture persistent snapshot nvm unfortunately previous suffer combination non trivial performance overhead due persistence barrier stall nvm amplification lack UI OOVBM  PNQVUFS SDIJUFDUVSF acm annual international symposium computer architecture isca doi isca scalability multi socket lack randomly access multiple previous snapshot important distribute debug usage model software approach generally suffer performance degradation due persistence barrier addition software approach nvm amplification snapshot data persistent later copying eventual location nvm randomly access address amplification effectively nvm bandwidth reduce program erase cycle hardware proposal improve performance overlap normal execution snapshot persistent via hardware dirty data cache nvm proposal effectively eliminate persistence barrier stall drawback typically suffer nvm amplification due typically multi socket assumption inclusive monolithic cache hierarchy within socket introduce  structure centralize mapping structure logic insight approach NVOverlay overcome challenge frequent persistent snapshot NVOverlay upon insight address challenge memory recent snapshot efficient scalable combine novel extension  overlay relaxed distribute epoch maintain lamport coherent snapshot cst mechanism address challenge avoid amplification persist multiple snapshot nvm avoid altogether instead persistent shadow mapping nvm interface multi snapshot nvm mapping MNM mechanism detail mechanism later IV respectively illustrate contribution propose evaluate NVOverlay efficient scalable frequency snapshotting nvm thereby enable usage model distribute debug NVOverlay coherent snapshot cst efficiently memory snapshot multi socket NVOverlay multi snapshot nvm mapping MNM persistence multiple snapshot nvm avoid amplification performance evaluation NVOverlay demonstrates successfully hide overhead frequent persistent snapshot reduce nvm amplification II motivation related failure atomicity persistence barrier achieve failure atomicity nvm application programmer various software propose hardware available software approach typically transactional library hoc data structure memory allocator storage service software approach rely persistence barrier enforce critical atomicity undo entry flush nvm data update  software shadow mapping transaction prior becomes persistent persistence barrier typically consists series cache flush instruction clwb clflush memory fence sfence frequent usage persistence barrier negatively impact performance however pipeline stall flush execution multiple barrier serialize unnecessarily overlap persistence execution eliminate software persistent barrier previous propose purpose hardware enforce persistence background hardware generates entry coordinate data background thereby overlap persistence execution persistence manage load coherence controller cache controller memory controller hardware approach minimal runtime overhead software approach disadvantage nvm amplification approach data dirty data nvm typically incur amplification factor undo redo excessive cache hierarchy nvm degrade performance waste bus bandwidth reduce lifespan nvm device limited writes reduce amplification via shadow avoid nvm amplification hardware alternative approach hardware shadow remaps dirty data alternate shadow address avoid overwrite consistent image shadow writes data inherent data amplification remapping perform tlb memory controller hardware shadow perform persistence operation background minimize runtime overhead feature minimum software unbounded distribute commit persistence non inclusive versioning amplification flush redirection barrier llc protocol SW undo per SW redo constant SW shadow maybe constant PiCL HW none ssp HW shadow none NVOverlay none qualitative comparison NVOverlay core core core core dram nvdimm generic network ver tag VD tag walker llc slice llc slice OMC ver tag VD internals  ver tag ver tag llc bypassing OMC OMC memory controller architecture component memory bus constitute cst frontend component memory bus constitute MNM backend hardware shadow generally exist challenge restriction limited snapshot non  mapping update NVOverlay novel approach grain shadow model avoids drawback discus detail II scalability prior persistent snapshotting proposal suffer scalability challenge multicore processor feature non inclusive distribute llc slice proposal centralize llc tag walker logic simply previous proposal assume globally synchronize epoch achieve consensus due increase communication finally previous tend generate burst traffic snapshot frequently due coordinate simultaneous component burst traffic become increasingly likely hurt performance saturate bandwidth memory bus nvm device approach NVOverlay NVOverlay adopts combination barrier coherent snapshot cst frontend overlap persistence grain shadow mapped  nvm mapping MNM backend combination eliminates unnecessary barrier stall frontend amplification backend NVOverlay assumes epoch snapshot model execution disjoint interval epoch snapshotting NVOverlay maintains data snapshot data data maintain ordinary manner nvm dram dirty data generate epoch persist nvm access independently frontend backend scalability goal eliminate centralize epoch logic relax consistency requirement snapshot necessarily conform consistent causality define coherence protocol achieve partition cache hierarchy llc versioned domain VDs maintain epoch epoch counter lamport update local epoch counter update remote epoch counter local epoch observes dirty cache generate remote epoch dirty data generate VDs tracked collectively version tag hierarchy logical cache tag extra version epoch NVOverlay mandate invariant dirty version become immutable epoch cease active multiple instance address exist hierarchy constitute snapshot version coherence protocol addition exist coherence protocol cache version orchestrates eviction ensure meanwhile backend dirty version insert per epoch mapping enables random cache granularity access continuously merge persistent global consistent memory image data movement merge entry qualitative comparison NVOverlay epoch epoch epoch epoch VD VD VD GETS data GETX data GETX data relaxed epoch model capture epoch VD VD VD respectively   overlay overlay originally propose finegrained address mapping scheme allows virtual address mapped multiple backing address cache granularity cache hierarchy tag overlay ID oid address tag  mapped physical location overlay memory controller OMC serf memory controller cache hierarchy memory reader posse prior knowledge overlay understand NVOverlay mostly remain compatible reader interested overlay comparison NVOverlay encourage info architecture depicts architecture assume multicore distribute cache llc llc inclusive inclusive cache core cache tag hierarchy extend oid epoch ID update core core versioned domain VD remain core VD although core llc slice actual distribute simplicity cache VD epoch cache controller maintain  register VD epoch synchronize within VD VDs relatively epoch synchronization lightweight incurs local communication snapshot cache evict cache hierarchy llc handle OMC integrate memory controller OMC maintains series mapping translates cache address shadow address nvm NVOverlay evict evict evict evict eviction oid dirty version addition baseline protocol marked logic distribute multiple  scalability responsible address partition application dram nvm memory relaxed epoch model conceptually NVOverlay execution VD epoch identify integer simplicity discussion assume VD within epoch update instruction incrementally capture NVOverlay coherent snapshot IV persist nvm snapshot snapshot contains within epoch processor VD dump internal context nvm epoch snapshot crash recovery NVOverlay recent fully persist epoch consistent memory image rebuilt combine incremental proportional model becomes complicate due data dependency multiple VDs interact via memory access recall unlike previous proposal VD NVOverlay independent epoch data dependency cache VD epoch access VD epoch NVOverlay synchronizes VD epoch data future VD local epoch lamport capture distribute relaxed snapshot NVOverlay memory image execution nevertheless snapshot correctly preserve progress image recovery consistent logical capture snapshot reflect memory VD VD VD respectively snapshot consistent however local VD capture agrees causality imply inter VD cache coherence IV coherent snapshot TRACKING cst described coherent snapshot cst address challenge incremental primarily focus memory recovery external network data recv syscall dir GETS dir GETS evict evict evict external downgrade downgrade cache recent version synchronization epoch discus topic detail operation within VD extend discussion multiple VDs cache coherence assume directory MESI baseline protocol easily extend  MESI mainstream derivation MOESI  emphasize NVOverlay modify baseline protocol instead extra tag evicts exist coherence action transition remain untouched version access protocol version cache content epoch execution cache version oid tag VD epoch coherence message network version RV request response version meaning explain version dirty coherence MESI protocol dirty NVOverlay maintains invariant version already persist nvm dirty version previous epoch therefore immutable epoch snapshot persist goal version access protocol ensure date version access multiple version address exist hierarchy protocol guarantee eventually version hierarchy evict nvm dram recent version version access protocol cache respectively operation load request processor behaves exactly non overlay tag lookup perform without oid tag oppose overlay lookup protocol address oid lookup GETS request load retry otherwise load completes locally request tag lookup perform load request RV VD  lookup signal writable cache controller acquire exclusive permission GETX retry controller oid RV dirty oid RV completes dir GETX dir GETX evict evict evict evict external invalidation optimization apply version directly requestor via cache cache transfer locally otherwise version immutable controller evicts immutable version without invalidate performs eviction schedule eviction critical NVOverlay enables cache multiple version hierarchy leverage inclusive cache temporary buffer version oid update RV reflect epoch RV snapshot eviction dirty  request schedule evict buffer RV oid eviction implementation dependent cache eviction critical  affect cache access latency operation GETS GETX performs tag lookup signal insufficient permission request response RV oid  performs tag lookup oid coherence dirty oid RV evicts avoid overwrite version preserve invariant version version address eviction schedule situation invalidate inclusiveness completes request copying data oid cache slot eviction dirty version addition llc controller sends version OMC via coherence network bypassing llc non inclusive llc bypassing network already exists cache directly predict therefore avoids dedicate datapath advantage llc bypassing request RV oid backend operation external invalidation downgrade challenge implement external invalidation downgrade cache dirty version NVOverlay solves extra eviction external invalidation dir GETX downgrade dir GETS controller query directory sharer none handle request locally schedule eviction request version respectively sharer controller request controller simply schedule eviction GETX dir GETX req ack ack inv ack completes intra VD invalidation assume directory ack controller eviction handle request locally date version directory response response RV oid difference protocol baseline eviction instead generate eviction traffic llc OMC version llc fulfill coherence request OMC happens cached dirty version  closer inspection reveals however excessive eviction avoid leverage observation dirty version version evict llc constitute memory image version newer request invalidation VD recent version version llc directory hence OMC fulfill dir GETX request instead cache cache transfer initiate directly requestor cache reduce traffic coherence latency llc dram operation version leaf VD guaranteed persist coherence dirty llc dram therefore implement version coherence protocol  update maintain per oid dram dram controller reserve dram update oid data ecc memory update oid ecc ecc enable memory technique dram compression employ embed oid without extra preserve  outside VDs avoid lose recent epoch update data dependency coherence driven epoch update versioned domain coherence intra VD coherence remains unchanged writes dirty version local version possibly schedule eviction coherence protocol already implement trick ownership address dirty invalidation transfer llc peer cache via link NVOverlay exist mechanism GETS dir GETS req evict data evict evict intra VD downgrade assume directory data cache request address insufficient permission VD request becomes inter VD controller llc directory directory request invalidation downgrade VDs llc exactly non NVOverlay cache hierarchy advance epoch inter VD request receives response RV response oid response controller cur epoch register RV RV VD terminate epoch advance epoch RV advance epoch controller signal core VD stall pipeline cache controller respond external coherence request drain intra VD request queue deadlock impossible core VD dump nonspeculative context nvm tag cur epoch finally cur epoch register cache controller update RV avoid epoch skews VDs VDs advance local epoch fix instruction external rare epoch wrap around refer IV cache tag walker component coherent snapshot mechanism cache tag walker hardware machine built cache controller tag walker opportunistically scan cache tag outstanding request VD tag walker dirty version  controller cur epoch nvm tag walker downgrade addition data oid OMC discard evict overwritten dirty address evict correctness NVOverlay protocol rely tag walker progress epoch wrap around conceptually epoch monotonically increase progress computation epoch fix width integer wrap around zero eventually simplest approach eliminate error approach wrap around reset  versioning clearing local epoch version tag OMC overlay  pool mmaster bitmap ref version background merge dram nvm version  update persist data multi snapshot nvm mapping orange arrow data eviction arrow background merge becomes recoverable metadata grey data flush cache reset limit inter VD epoch skew  partition epoch equally persistent epoch indicates epoch around unchanged OMC enforces invariant VDs epoch whenever VD advance local epoch another ensures cache remain tag belonging flip epoch essentially recycle epoch currently reuse ahead currently discussion protocol compatibility neither NVOverlay assume specific coherence protocol modify coherence machine protocol notion ownership extend NVOverlay coherence overhead NVOverlay version coherence protocol generates eviction critical eviction overhead exists background persistence reduce nvm writes address evict downgrade frequently epoch redundant nvm dram generate propose battery cache OMC reduce persist latency nvm writes cache essentially persistent llc absorb version eviction flush failure multi snapshot nvm mapping MNM overview version evict VDs tracked multi snapshot nvm mapping MNM mechanism retrieve request NVOverlay MNM manage OMC dram nvm data structure rebuilt upon recovery maintain volatile dram access bandwidth avoid nvm contention meanwhile version maintain nvm compactly overlay data OMC maintains image recent recoverable epoch series overlay mapping continuously update background incorporate recent version evict frontend depicts MNM recoverable epoch NVOverlay epoch becomes fully persistent VDs advanced local epoch dirty version addition epoch recovery epoch fully persistent epoch globally synchronize recoverable epoch distribute fashion discus tag walker local register min ver initialize cur epoch tag update version oid encounter cache controller sends min ver OMC array recently min ver VD maintain message OMC recomputes recoverable epoch min  atomically location rec epoch nvm multiple  OMC computes local remain  OMC persists compute overlay mapping nvm storage allocate multi snapshot nvm mapping mechanism maintain buffer pool initialize startup manage OMC hardware OMC allocation status bitmap negligible storage overhead index persistent rebuilt recovery epoch OMC maintains per epoch volatile mapping mapping implement radix dram version epoch mapping physical address version data nvm OMC manages epoch overlay instance mapping distinct data overlay sparse version compactly sub KB storage sec version epoch OMC  request RV insert version  physical address OS populates NVOverlay physical address index OMC maintains mapping mmaster overlay mapping epoch rec epoch mmaster radix per epoch exactly per epoch indexed address cache granularity mapping mmaster reflect consistent memory image node mmaster data mapping radix structure index grey data persist nvm update mmaster atomic persistent buffer whenever  update OMC epoch epoch OMC merges mapping volatile mmaster advance consistent memory image update procedure simply scan  version insert physical address nvm address mmaster data update merge perform background OMC without affect normal execution garbage collection merge version unmapped mmaster become stale qualify garbage collection GC cannot however immediately reclaim storage version mapped granularity  sparse refer unmapped individually cache granularity frequently update cache GC storage explosion nvm storage OMC exception OS simply allocates feasible notifies OMC physical address otherwise allocate OMC deem infeasible OS device storage consumption quota limit OMC perform version compaction algorithm invoked epoch version mapped mmaster version date epoch address epoch source safely reclaim amplification negligible majority address update epoch dram per epoch reclaim merge mmaster retrieve persistent snapshot recall persistent snapshot nvm per epoch manner efficient retrieval scenario snapshot data access individually per epoch mapping mmaster access snapshot discus snapshot utilized crash recovery crash OS firmware restores initial snapshotting recovery procedure load consistent image nvm scan mmaster reading version correspond address dram completes procedure rec epoch nvm processor context dumped nvm rec epoch load context resume execution crash volatile OMC data structure rebuilt recovery remote replication snapshot persist transfer remote backup machine via network snapshot remote machine replay incremental redo archive future access remote replication architecture atomicity guarantee however orthogonal thoroughly previous debug access address epoch access function address semantics version chain access  database snapshot incrementally discussion hardware NVOverlay hardware  oid tag OMC logic oid tag increase chip SRAM storage exist prior proposal neither replacement algorithm coherence machine verification OMC logically serf memory controller dedicate cpu thread software manage cache implement hardwired logic embed programmable micro controller chip emphasize NVOverlay hardware addition oid tag usefulness transactional memory besides overlay user scenario enables potentially novel explore deployed runtime dram overhead byte dram tag oid incur dram overhead oid granularity byte OMC reserve oid tag KB dram lower tag overhead oid super cache exist oid update incoming oid runtime nvm overhead nvm mmaster unlike previous shadow proposal overhead NVOverlay allows user tradeoff amplification storage overhead threshold exceeds threshold OMC suspend version immediately version compaction reclaim storage nvm array future nvm platform storage density dram NVOverlay OMC MNM nvm array multiple memory controller exist responsible request address partition OMC maintains instance overlay mmaster address partition OMC maintains  array VDs epoch update VI experimental framework simulation environment evaluation zsim pin simulator feature cycle accurate multicore simulation implement NVOverlay module without exist coherence protocol II configuration simulated processor core superscalar 3GHz cache KB cycle cache KB cycle llc MB cycle dram ddr mhz controller nvdimm latency II simulated configuration comparison NVOverlay mechanism software undo SW software shadow SW shadow hardware shadow HW shadow PiCL PiCL PiCL briefly mechanism software software generates flush undo entry assume software library flush epoch nvm writes barrier software shadow software flush dirty epoch software maintains persistent mapping update epoch nvm writes barrier hardware shadow model hardware shadow version cache granularity shadow scheme ThyNVM hardware overlap persistence previous epoch execution epoch however centralize mapping update synchronously PiCL hardware undo entry generate software hardware dirty version tag inclusive llc tag walker periodically evicts dirty previous epoch ignore overhead global epoch synchronization focus data PiCL hypothetical function PiCL tag estimate performance PiCL style undo multicores without monolithic inclusive llc fairness comparison assume simulated baseline equip dram buffer accommodate entire epoch uops PiCL NVOverlay initiate tag ACS PiCL terminology epoch completes benchmark benchmark stamp suite data structure benchmark evaluation stamp consists memory intensive application stress data transactional multicore synchronization model stress modify coherence protocol data structure benchmark consist   std hash std unordered workload insert workload random mimic bulk insertion database index benchmark spawn worker thread compile lock   thread execute program instruction  instruction vii experimental RESULTS multicore performance cycle workload worker thread normalize ideal nvm snapshotting workload NVOverlay PiCL fully overlap execution snapshotting incur cycle overhead consistent PiCL PiCL perfectly overlap execution persistence PiCL suffers slightly execution due chip excessive eviction writes hierarchy ssca kmeans PiCL NVOverlay PiCL SW SW shadow considerably NVOverlay  consequence data entry synchronously although NVOverlay fully overlap persistence execution contradict observation software scheme NVOverlay handle distribute burst writes workload shift exist leaf node evaluation workload nvm data request generate coherence protocol NVOverlay evenly distributes writes across execution HW shadow moderately NVOverlay HW shadow NVOverlay attribute ability overlap data persistence execution however synchronously update mapping epoch avoid corrupt epoch amplification amplification byte nvm device data metadata writes PiCL PiCL assume entry byte data address tag HW SW SW shadow HW shadow PiCL PiCL NVOverlay hash rbtree labyrinth bayes yada intruder vacation kmeans genome ssca normalize cycle normalize cycle worker thread normalize baseline execution without snapshotting hash rbtree labyrinth bayes yada intruder vacation kmeans genome ssca normalize byte amplification byte data worker thread normalize NVOverlay shadow NVOverlay byte writes perform radix mapping normalize NVOverlay II HW shadow NVOverlay demonstrate amplification PiCL PiCL cache cache eviction instead overall PiCL writes data NVOverlay PiCL amplification chip previous workload NVOverlay incurs writes shadow NVOverlay coherence protocol issue nvm ownership cache transfer upper hierarchy llc negative become significant kmeans writes issue nvm HW shadow PiCL PiCL issue writes nvm NVOverlay due extra writes kmeans reveal writes issue llc simulate HW shadow writes issue simulate NVOverlay writes capacity eviction load downgrade eviction conclude kmeans suffers thrash portion data fetch later evict capacity explains kmeans llc hardware scheme hash rbtree labyrinth bayes yada intruder vacation kmeans genome ssca mapping mmaster persistent mapping metadata percentage fortunately amplification translate execution NVOverlay persistent metadata overhead comparison mapping mmaster define amount data mapped mmaster ratio mmaster stable across workload yada metadata consistent radix perfectly byte pointer leaf node byte cache achieve theoretical bound NVOverlay achieve almost optimal mapping storage thanks locality computation PiCL PiCL NVOverlay epoch normalize cycle normalize cycle epoch normalize byte normalize writes sensitivity epoch benchmark cycle normalize baseline writes normalize NVOverlay capacity coherence tag PiCL PiCL NVOverlay evict tag walker epoch PiCL PiCL NVOverlay evict without tag walker evict decomposition workload yada investigation inner slot average imply occupancy inner contrast leaf slot cache locality address maintain sensitivity epoch epoch hence tag frequency simulate PiCL PiCL NVOverlay epoch cycle amplification cycle NVOverlay PiCL insensitive epoch explain eviction coherence load downgrade capacity eviction tag marginally contribute bandwidth PiCL performs epoch around eviction generate tag eviction commit previous epoch amplification epoch increase amplification PiCL PiCL steadily reduce frequency tag besides dirty cache survive longer cache without entry generate epoch increase amplification PiCL PiCL respectively tag walker evaluate tag walker performance simulate PiCL PiCL NVOverlay buffer buffer normalize cycle NVOverlay normalize cycle buffer buffer nvm writes NVOverlay nvm writes reduce writes OMC buffer workload without tag walker decomposition evict PiCL PiCL heavily dependent tag walker progress request generate tag tag walker become performance bottleneck cache PiCL PiCL NVOverlay contrast writes dirty mainly cache coherence capacity eviction distribute evenly execution tag walker contributes around eviction efficiency tag walker therefore limited NVOverlay OMC buffer evaluate persistent OMC buffer propose IV simulate NVOverlay without buffer evaluation epoch throughout execution stress buffer ability absorb redundant generate address epoch hierarchy buffer configuration simulated llc expectation reduce nvm traffic NVOverlay built llc OMC buffer improves performance reveals performance improvement reduce writes effectiveness request buffer achieve rate bandwidth evaluate bandwidth benefit simulate NVOverlay PiCL btree nvm bandwidth bandwidth entire simulation default epoch NVOverlay demonstrates advantage average bandwidth consumption significantly PiCL peak bandwidth overall fluctuation scalability component fix bandwidth budget attribute NVOverlay version coherence amortizes version bandwidth regular execution PiCL evict dirty tag bandwidth surge epoch boundary bandwidth epoch localize burst mimic PiCL NVOverlay progress nvm bandwidth GB sec btree default epoch progress nvm bandwidth GB sec btree bursty epoch nvm bandwidth series debug programmer manually epoch around suspicious code bursty interval marked vertical epoch bursty interval respectively demonstrates epoch moderately scheme extremely epoch however NVOverlay sustains relatively bandwidth PiCL observes traffic due frequent generation additional related discus additional related beyond already II journaling implement conventional file crash recovery operation commits metadata flush journal disk replayed crash sake recovery journaling related structure file  treat entire file journal  fix location data metadata mapping item logical address mapping  NVOverlay backend MNM similarly  difference multiple journal epoch data regard nvm improve file nvm file  treat version journaling file data entire file  update operation creates snapshot file via  atomic pointer swing similarly jacob describes flash snapshot chain mapping entry address combination customize FTL performs  along firmware maintain mapping snapshot retrieve later crash recovery contrast previous target file crash recovery goal  snapshotting address  memory involves additional challenge snapshotting frequency simply crash recovery magnitude target NVOverlay thereby easy avoid performance bottleneck file flash storage already explicit metadata location data dram memory enable ability distinguish data  snapshot dram cache aspect NVOverlay file involve explicit software interface operation unlike cpu writes memory perform regular instruction frequency described earlier NVOverlay coherent snapshot cst multi snapshot nvm mapping MNM overcome challenge IX CONCLUSIONS evaluate novel hardware technique NVOverlay snapshotting nvm address  parallel application multiprocessor leverage overlay lazily persist  checkpoint NVOverlay achieves significantly performance hardware shadow benchmark hardware NVOverlay significantly reduces amount amplification roughly factor avoids dirty data nvm nvm bandwidth becomes precious benchmark bandwidth saving  performance impact snapshotting efficient scalable fashion NVOverlay crash recovery frequent checkpointing checkpoint debug practical parallel application