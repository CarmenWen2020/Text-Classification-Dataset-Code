graph mining GPM algorithm widely application bio medicine  security social etc GPM computationally intensive enormous amount coarse grain parallelism therefore attractive hardware acceleration unfortunately exist GPM accelerator algorithm optimization questionable benefit software implementation FlexMiner software hardware GPM accelerator improves efficiency without compromise generality productivity software GPM framework FlexMiner exploit massive amount coarse grain parallelism GPM deploy specialized processing efficient FlexMiner hardware accepts specific execution generate automatically FlexMiner compiler avoid repetitive computation neighborhood connectivity dedicate chip storage memoize reusable connectivity information connectivity implement throughput hardware chip memory FlexMiner manage dynamically heuristic derive compiler fully utilized evaluate FlexMiner GPM application graph cycle accurate simulation FlexMiner PEs achieves speedup average software execute thread core intel cpu index accelerator software hardware graph mining aware introduction graph mining GPM subgraphs graph GPM  building numerous important application chemical engineering bioinformatics web spam detection social others GPM predict functionality protein protein protein interaction network vertex protein label functionality interaction protein prediction preform mining frequent subgraphs interaction protein GPM widely application cheaper compute efficient parallel GPM program consume error prone software GPM   fractal  AutoMine pangolin  input graph subgraphs embeddings graph mining data graph propose improve productivity GPM solver program data graph enumerates subgraphs subgraph isomorphic computationally intensive moderate graph massive combinatorial expensive graph isomorphism cycle  graph vertex billion AutoMine GPM software socket core core intel cpu machine therefore hardware GPM accelerator  gramer propose improve GPM performance efficiency subgraph enumeration model building efficiency GPM depends upon aware exploit specific drastically prune unfortunately exist hardware accelerator inefficient naive oblivious strategy significantly software meanwhile exist accelerator limited generality  unlike software GPM subset GPM gramer GPM adopts hoc approach implement specific solver specific GPM significantly hamper usability limited generality consequence gramer  lack define software hardware interface configure program accelerator lastly unlike GPM software exist accelerator lack memoization repetitively connectivity vertex propose FlexMiner software hardware GPM strives generality performance without sacrifice program UI OOVBM  PNQVUFS SDIJUFDUVSF acm annual international symposium computer architecture isca doi isca FlexMiner dfs walker hardware FlexMiner software hardware interface user interested analysis FlexMiner compiler execution overview FlexMiner software hardware illustrates overview FlexMiner contains FlexMiner hardware software hardware interface FlexMiner hardware purpose architecture offload GPM computation application host depth dfs software hardware interface establish user program hardware FlexMiner  user program specify software GPM framework FlexMiner analysis compiler automatically generate specific execution execution load host cpu FlexMiner hardware execution customizes dfs hardware FlexMiner flexibly arbitrary algorithmic efficiency addition flexibility FlexMiner hardware throughput purpose CPUs efficiency FlexMiner hardware stem feature massive multithreading FlexMiner exploit embarrass amount parallelism GPM vertex mutually independent task concurrently FlexMiner consists collection processing PEs exploit massive parallelism saturate memory bandwidth hide memory latency PE specialization PE contains specialized optimize efficient intersection difference operation operation frequently vertex bottleneck software GPM framework connectivity memoization operation access frequently repeatedly significant amount redundant computation novel structure VI memorize neighborhood information avoid redundancy hardware besides FlexMiner compiler specific hint hardware efficiently manage storage prototype PE FlexMiner rtl  synthesize  library PE private cache scratchpad 3GHz comparison intel skylake core MB cache clocked around 4GHz detailed performance simulation PEs approximately intel cpu core FlexMiner wedge clique cycle diamond motif motif vertex vertex motif achieves speedup average theart software core intel cpu summary contribution FlexMiner aware GPM accelerator variety GPM application technique software algorithm GPM program interface ofthe software GPM compiler generate execution configure hardware hardware memoizing connectivity information avoid redundant computation evaluation representative GPM application diverse graph FlexMiner significantly improves performance software framework organization II defines GPM introduces GPM describes GPM software GPM limitation exist hardware motivate IV introduces FlexMiner architecture defines software hardware interface discus hardware VI vii evaluates IX concludes II background graph mining graph vertex  subgraph graph vertex contains endpoint induced subgraph graph vertex contains endpoint data graph GPM seek subgraphs embeddings isomorphic embeddings graph GPM guarantee completeness uniqueness distinct report GPM input graph symmetry lightly subgraphs remove consideration symmetry symmetry unnecessary extension prune subgraph portion subgraph vertex extension counting TC clique listing CL clique  define subgraph vertex vertex graph subgraph listing SL enumerates induced subgraphs isomorphic user define motif counting MC occurrence vertex motif motif motif MC vertex induced subgraphs GPM TC CL SL whereas multiple simultaneously multi MC GPM execution model strategy GPM solver program enumerates subgraphs subgraph isomorphic model building vertex subgraph subgraphs vertex intuitively subgraph subgraph obtain extend vertex vertex neighborhood subgraph vertex extension formally express useful label similarly extension extends subgraph endpoint model classify exist software GPM framework category oblivious aware oblivious approach leaf isomorphic contrast aware leverage prune avoid isomorphism analyze generate symmetry prune define ancestor avoid notational confusion vertex vertex denote vertex data vertex denote ancestor subgraph vertex ancestor vertex vertex ancestor ancestor denote CAS CAS ancestor simplicity CA instead CAS obvious context vertex defines data vertex vertex suppose cycle generate MO ancestor MO CA CA CA CA meaning vertex mapped mapped mapped mapped subgraphs marked prune vertex mapped vertex mapped eliminates apply isomorphism leaf leaf subgraphs symmetry specific subgraph multiple subgraph vertex occurs identical subgraphs automorphisms avoid repetitive enumeration canonical extend selection symmetry establish diamond partial partial partial generate symmetry cycle approach symmetry define partial symmetry candidate vertex subgraphs satisfy symmetry suppose define symmetry cycle lightly subgraphs prune reduces guarantee uniqueness specifically subgraphs automorphisms former prune aware analysis generate symmetry generate program automatically generate analyzer enumerates likely perform diamond wedge wedge wedge sparse graph likely perform prune candidate stage generate symmetry MO subgraph incrementally specify MO symmetry partial interchangeable meaning enforce twice permute similarly partial respectively symmetry generate cycle memoizing connectivity information computation AutoMine  GraphZero intersection difference  frequent access  cycle intersection avoid lookup memoize connectivity entry vertex ID depth vertex embed implement bitset assume embed vertex entry vertex vertex vertex embed construct operation replace query cycle intersection replace query LIMITATIONS  GPM software SYSTEMS  software GPM   fractal  AutoMine pangolin  GraphZero simplify GPM program apply algorithmic optimization improve performance however irregularity GPM computation software performance depth understand software GPM behave purpose processor evaluate AutoMine software GPM core machine 0GB max dram bandwidth hyper thread thread per core performance memory bandwidth mining clique orkut performance linearly thread hyperthreading kick slows probably cache contention behavior core machine thread thread memory bandwidth beyond thread potential improve performance physical core another intel vtune pipeline slot waste due misprediction frequent comparison branching intersection difference account majority computation AutoMine observation accelerator physical core operation local memory effective GPM performance unfortunately exist hardware GPM accelerator  gramer efficient  variant optimal  algorithm operation perform intersection  introduces specialized core coprocessor cpu core cache specialized core avoid cache pollution writes introduces MB dedicate chip scratchpad partial  cache buffer intermediate operation however  limitation perform symmetry suffers redundant computation connectivity  CL dual thread core maximum dram bandwidth 0GB lack interface configure hardware limited induced gramer propose data prioritization technique GPM heuristically prioritizes frequently access data cache technique improves performance exist oblivious software  fractal however gramer employ oblivious strategy although filter mechanism  leveraged gramer remove irrelevant subgraphs sufficient prune arbitrary lack gramer expensive isomorphism gramer GPM  synthesize hardware solver GPM due lack programmable interface extra rtl program effort user significant task without expertise hardware graph mining IV  overview limitation exist pure software pure hardware motivate develop SW HW GPM overcome limitation FlexMiner establishes software hardware interface user specify input analysis invokes FlexMiner compiler generate specific execution execution fed FlexMiner hardware execution FlexMiner hardware template dfs walker subgraph implement finite machine IV template customize  execution therefore hardware aware throughput hardware contains collection processing PEs specialized GPM architecture leverage parallelism task vertex independent task inside PE FlexMiner introduces hardware hashmap VI efficiently perform GPM computation hashmap overflow specialized operation invoked  dfs exec buffer reducer cache PE scheduler global reducer chip memory PE PE PE PE memory controller SIU SDU noc cache scheduler private cache ancestor stack PE frontier  frontier FlexMiner hardware architecture private empty empty vid vid deq deq enq intersection difference adj fifo adj fifo frontier fifo intersection empty vid empty deq enq vid deq deq enq difference vid  vertex vertex  hardware SIU SDU upper bound prune vid vertex upper bound input  FlexMiner hardware architecture illustrates FlexMiner architecture FlexMiner consists scheduler cache processing PE network chip noc scheduler dynamically assigns task available idle PEs cache buffer vertex data PEs intermediate data spill PEs cache coherency FlexMiner task independent update data PE responsible processing assign task independently synchronization PEs PE contains component  finite machine detailed IV responsible vertex pruner prune vertex candidate configure specifically prior execution ID vertex within bound symmetry query connectivity constraint overflow SIU SDU invoked perform intersection difference operation compute qualify vertex candidate SIU SDU merge algorithm hardware structure specialized SIU SDU perform loop iteration loop per cycle reducer contains counter reduction operation extend easily user define reduction operation ancestor stack register partial dfs private cache  data  frontier vertex already constraint reuse detailed frontier generate address frontier scratchpad accommodates specialized hash memoize neighborhood connectivity detailed VI detail machine FlexMiner execution FlexMiner execution aware software recursion suitable implementation hardware instead FlexMiner iterative execution model implement finite machine PE runtime idle extend  depth counter emb ancestor stack whenever dfs vertex stack traversal stack pop vertex backtracks previous depth register vertex extend index extension execution vertex  task assign scheduler  stack depth switch extend stage depth stack subgraph output backtracks previous decrease pop emb maximum depth vertex emb picked accord vertex extension index switch  index backtracks previous previous depth entire subtree already traverse idle stage task scheduler otherwise  candidate vertex checked pruner satisfies constraint symmetry connectivity emb increase switch extend overall FlexMiner explain execution execution load scheduler assigns task vertex PE  ancestor stack satisfy constraint vertex emb accord offset  offset  false output emb extend vertex false extend  emb false emb  idle emb pop emb pop false execution FlexMiner configures pruner accord execution pruner load  private cache vertex bound query connectivity constraint overflow SIU SDU invoked intermediate data frontier private cache cache evict private cache frontier generate correspond information update frontier reuse private cache access deeper whenever  reducer increase local global reducer software hardware interface efficiently awareness FlexMiner define interface pas specific execution hardware propose intermediate representation IR express symmetry hint manage chip storage specific execution cycle IR listing develop execution generator refer compiler analysis generate IR code automatically IR code pre load hardware accelerator execution compiler generates symmetry approach prior software framework generates hint manage chip storage multi adj adj adj adj symmetry cycle adj adj adj adj adj symmetry diamond adj adj adj adj symmetry execution induced cycle diamond error fix listing IR code cycle vertex pruneBy pruneBy pruneBy pruneBy embed emb emb emb emb emb emb emb IR format IR consists vertex embed vertex describes vertex extend vertex valid candidate extension extend candidate confine pruneBy primitive accepts parameter vid upper bound ancestor vid upper bound defines upper bound candidate vertex ID ancestor contains vertex embed candidate vertex candidate vertex conform constraint embed listing ID ID embed describes dependency partially embeddings instance mining cycle partial embeddings  embed emb emb wedge emb cycle emb embed chain emb fully link dependency chain label primitive defines vertex action perform extend embed emb extend emb multi straightforward compiler generate IR code symmetry multiple dependency chain multiple chain merge multiple chain dependency whenever embed express mining multiple simultaneously merge avoid repetitive enumeration execution diamond listing IR code diamond vertex pruneBy pruneBy pruneBy pruneBy pruneBy embed emb emb emb emb emb emb emb emb emb candidate constraint vertex therefore merge diverge listing generate IR code illustrate vertex chain diverges extend vertex respectively embed dependency emb emb stem emb FlexMiner efficiently multi MC hint data management optimize frontier memoization technique diamond candidate adj adj difference memoize adj adj PE local cache avoid repetitive computation analyze compiler identifies reusable memoized indicates hardware flag IR code similarly compiler embeds information IR manage VI addition compiler optimization detect clique analysis symmetry orientation technique convert undirected data graph acyclic graph dag establish endpoint convert originally undirected commonly approach enforce vertex vertex vertex ID orientation symmetry runtime preprocessing usually execution convert graph CL aware execution execution model FlexMiner customize constraint customization achieve simply IR code hardware cycle FlexMiner extends wedge cycle depth execute emb emb refers primitive pruneBy vertex defines  vertex ancestor stack constraint mining dependency partial embeddings sequence execution model simply depth index vertex retrieve primitive without embed multi however embed handle divergence due execution multiple listing emb emb explore sequentially dfs emb backtracks emb VI hardware connectivity explain propose hardware optimization FlexMiner detail update query runtime construct incrementally embed extend vertex embed empty vertex embed vertex insert entry vertex vertex embed vertex insert vertex vertex already exist update vertex vertex embed entry vertex become useless update similarly vertex embed vertex insert update  backtracking connectivity information resume stack fashion therefore task entry invalidate extend embed vertex vertex connectivity vertex vertex query bitset vertex vertex vertex vertex lookup exist vertex vertex embed input graph embed entry newly insert orange entry update grey entry become useless previous vector implement software instead vertex vector pre allocates entry per vertex implementation query constant average speedup CL however vector restrict implementation scalable data graph counting clique graph billion vertex maximum bound vector implementation allocate vector billion GB per thread moreover cache particularly inefficient structure cache information byte useful information hardware propose hardware information compact access hardware complexity simplify linear probe scheme insertion lookup deletion simpler conventional linear probe delete entry simply entry invalidate functionally due observation GPM algorithm update bulk fashion sequence deletion entry insert atomically lookup remove delete exist deletion operation entry remove probe faster partition parallel probe successive entry prototype hardware  byte byte byte entry parameter successfully synthesize fpga mhz ASIC 3GHz empirically properly occupancy maintain access latency access cycle management connectivity information differently cycle listing checked graph source max AstroPh  patent youtube livejournal orkut input graph symmetric loop duplicate compiler annotates connectivity information therefore mining cycle insert besides vertex upper bound compiler prevents vid insert reduce entry finally mechanism guarantee execution overflow obtain compute vertex extension influence memory footprint hence dynamically estimate occupancy chosen threshold detect estimate footprint threshold mechanism activate pruner switch invoke SIU SDU instead query cycle allocation fail instead extend connectivity pruner sends request  cache  SIU compute intersection vii evaluation experimental setup benchmark graph datasets GPM application II TC CL SL MC input graph gramer graph speedup software baseline distort input graph symmetric loop duplicate input graph compress sparse csr format vertex sort ascend vertex ID baseline evaluate efficiency FlexMiner software GPM AutoMine GraphZero exist hardware GPM accelerator gramer unable FlexMiner  simulator release absolute AutoMine GraphZero core intel cpu 0GHz turbo 3GHz MB llc 4GB dram report execution cpu average gramer evaluate xilinx   fpga chip LUTs register MB bram 6GB ddr memory II gramer fpga AutoMine cpu GraphZero cpu gramer report graph graph gramer AutoMine GraphZero TC CL CL MC II baseline gramer thread PU fpga AutoMine thread cpu GraphZero thread cpu bold gramer subset SL evaluate gramer GraphZero almost faster gramer CL average speedup regardless hardware specialization gramer speedup mainly due awareness GraphZero gramer outperform oblivious software GPM framework  fractal demonstrate gramer however awareness AutoMine significantly prune  faster  fractal GraphZero symmetry AutoMine faster AutoMine therefore GraphZero cpu baseline FlexMiner GraphZero evaluation FlexMiner compilation GraphZero negligible mining execution FlexMiner simulation configuration performance evaluation developed custom cycle accurate simulator model microarchitecture behavior module described conservatively 3GHz PE frequency 8GHz  private cache MB cache available private scratchpad FlexMiner fallback mechanism SIU SDU report simulation benchmark within GraphZero II due extremely cycle accurate simulation simulator integrate  simulate cycle accurate behavior access offchip memory simulated 4GB ddr dram channel cpu baseline integrate booksim noc standard cycle accurate non inclusive cache model cache frontier memoization described enable FlexMiner comparison GraphZero technique implement software implement propose PE  generate verilog synthesize logic synopsys compiler  library synthesis operating voltage achieve target comfortably 3GHz estimate SRAMs PE CACTI technology node closest available CACTI overall PE FlexMiner intel skylake cpu core evaluation focus ASIC FlexMiner FlexMiner without cpu baseline GraphZero benefit PE specialization massive multithreading evaluate FlexMiner benefit reasonable PEs demonstrate detailed performance lastly noc traffic impact reduce memory request memoization reduces access  performance cmap comparison baseline FlexMiner without performance thread GraphZero illustrate FlexMiner PE already outperform GraphZero although frequency cpu due specialized execution SIU SDU PE efficient purpose cpu core operation exists algorithm intersection merge algorithm GraphZero comparison cpu baseline GraphZero FlexMiner memoization frontier avoids recomputation intersection reusable intermediate clique diamond memoization FlexMiner algorithmic efficiency software performance improvement mostly accelerate operation speedup specific depends portion memory stall cycle benchmark benefit PE specialization spends computation contrast benchmark mostly memory request speedup marginal TC computation application relatively datasets cache behavior cache rate respectively likely spent memory access graph contains therefore TC FlexMiner baseline PE simpler logic private cache purpose core cpu cpu L1D MB PEs within PEs PE PE FlexMiner achieves speedup thanks embarrass amount parallelism GPM application average FlexMiner PE PE PE outperform cpu baseline respectively performance impact evaluate performance impact cmap unlimited unlimited performance upper bound impractical cmap unlimited achieves significant performance improvement cmap cycle average speedup frontier reuse cycle reuse heavily proof ratio percentage access mining cycle  ratio translate directly speedup cycle however CL diamond memoizing frontier already effective performance improvement cycle TC frontier reuse reuses cycle ratio TC  reduce reuse cycle cycle CL constantly obtains speedup across application mainly due dense graph average therefore exists abundant reuses demonstrate ratio meanwhile benchmark already capture performance benefit cmap unlimited maximum graph although vertex rare due distribution utilized compiler heuristic VI default FlexMiner graph configuration achieves average speedup cpu baseline respectively graph evaluate graph TC clique simulation PE FlexMiner achieves speedup GraphZero due simulation graph simulator FlexMiner graph memory graph memory capacity graph partition framework FlexMiner without performance thread GraphZero cpu FlexMiner performance PE normalize FlexMiner without FlexMiner performance PEs increase normalize PE evaluate CL PE FlexMiner outperforms GraphZero entry currently FlexMiner fully benefit within vertex beyond partially FlexMiner SIU SDU dfs unless overflow scalability noc traffic illustrates FlexMiner performance PE increase generally linear PEs although application datasets impact factor TC simplest irregular application therefore TC performance almost perfect however dataset TC datasets task parallelism CL TC likely due computation exist CL average PE FlexMiner achieves speedup GraphZero noc traffic memory request PEs noc impact memory subsystem benchmark benefit TC cycle diamond noc traffic significantly reduce introduce reduces nearly noc traffic cycle CL noc traffic frontier already amount memory request cmap performance gain CL impressive increase however achieves speedup purely achieve reduce operation summary demonstrate FlexMiner achieves significant speedup cpu baseline thanks PE specialization massive  memoization specifically performance speedup PE without cpu baseline attribute PE specialization multithreading adoption scratchpad improves noc traffic access dram access cycle diamond performance reasonable tradeoff hardware related software GPM  fractal  distribute GPM   pangolin AutoMine GraphZero  GPM target machine graph query    GPM software GPM improve programmability achieves limited performance explain software GPM application numerous optimize GPM application target various platform TC  MC SL FSM employ sophisticated optimization improve algorithmic architectural efficiency however lack generality program effort GPM meanwhile accelerator achieve performance application cpu gpu software hardware accelerator graph analytics graph processing framework propose improve programmability graph processing limited subgraph mining task graph analytics accelerator propose improve performance software graph analytics however demonstrate graph analytics accelerator yield performance GPM application IX conclusion GPM widely  application aware hardware accelerator GPM performance exist software hardware accelerate scalability allows exploit massive parallelism GPM increase processing specifically aware GPM FlexMiner compiler automates generation execution hardware achieves awareness without program effort software GPM framework hardware memoization technique tradeoff efficiency parallelism evaluation demonstrates significant speedup software framework cpu