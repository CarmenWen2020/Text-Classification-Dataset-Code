memory safety significant software reliability security overhead complexity hardware  computer designer explore pathway deployable memory safety defense technique recent trend software usage binning memory allocator memory allocation malloc architectural feature overcome  issue traditional approach memory safety compatibility unsecured software significant performance degradation architecture incurs overhead spec cpu benchmark VLSI measurement overhead finally hardware aware memory allocation effectively mitigates speculative attack  additional  fuzz improve fuzz bandwidth magnitude approach index bound fuzzing memory safety microarchitecture spectre security introduction memory safety violation program significant opportunity exploitation attacker instance microsoft recently reveal around exploit target software memory safety violation similarly project zero google report memory corruption issue  CVEs zero vulnerability address threat memory safety software AddressSanitizer fuzz widely deployed software fuzz binary AddressSanitizer detect memory safety vulnerability input mutate exemplary input detect bug deployment google report fuzzing machine continuously identification critical bug software google chrome source project assume per cpu memory machine requirement reasonable performance fuzz investment software fuzzing detect memory error billion despite  effort software vendor memory safety vulnerability deployed recognize pre deployment fuzz propose  crowdsourced fuzz instance mozilla recently framework fuzzing software cluster fuzzers user willing contribute cpu resource workstation fuzz assume participate global amount invest reliable software amount software crowdsourced increase efficiency memory error detection significant benefit addition improve security reliability researcher commercial vendor reduce inefficiency software security academic proposal continuously  away overhead detect memory safety vulnerability commercial vendor propose manufacture hardware mitigate overhead intel MPX  oracle adi overhead memory safety decrease novel hardware traditional memory safety technique incur overhead source storage metadata detect memory safety violation computational overhead memory safety metadata eliminates metadata attach pointer hide computational overhead metadata perform parallel regular lookup technological facilitates improvement increase adoption binning allocator binning memory allocator collection bin bin allocate bin enables allocator quickly  calorie closely related refer scheme pointer UI OOVBM  PNQVUFS SDIJUFDUVSF acm annual international symposium computer architecture isca doi isca ptr malloc ptr compute ptr malloc secure source code assembly hardware ptr ptr compute allocation sizeof char allocation address overview allocation architectural feature allocation request increase performance maintain allocation locality binning allocator implicitly derive allocation bound information address pointer without rely explicit metadata hardware software contract  slightly facilitate binning allocator standard allocation binning allocator hardware load instruction access allocation memory allocation malloc becomes architectural feature illustrate protection program allocates array writes ptr allocation architectural feature modifies compiler propagate allocation address ptr memory instruction secure access memory computes allocation memory address ptr compute address compiler propagate address ptr exception mismatch moreover enforces temporal protection generate random tag upon memory allocation currently unused upper pointer upon execute memory instruction verifies tag resilience subset speculative execution attack namely spectre spectre attack exploit speculative execution access bound memory effectively bypassing software bound memory instruction aware allocation bound information allocation bound information verify memory access within valid bound speculatively execute instruction challenge prior memory safety proposal proposal involves ISA practical deployment consideration instruction interface compatible software performance degradation software code simply  luckily described viz standardize memory allocation structure information memory safety software implementation moreover advantage prior prior suffer performance overhead mitigates temporal safety intra spatial safety implementation prior software modification improve prior arbitrary allocation oppose allocation software transformation perform clang llvm compiler framework experimental spec cpu benchmark suite overhead average conservative measurement VLSI implementation  efficiently processor negligible performance overhead summary standardize memory allocation explicitly information available architecture distinct benefit improve fuzz currently software program bug majority bug tend intricate memory safety bug expose allocation hardware simplifies memory safety improves fuzz bandwidth AddressSanitizer fuzzing improve security despite effort software engineer bug code bug production risk user user remain residual risk overhead protection publish memory safety thwart data corruption attack improve resilience spectre attack expose allocation hardware allows hardware effectively perform bound speculative memory access II overview preliminary binning memory allocator gain prominence decade widely binning  heap allocate pre memory return program standard allocator allocation request byte allocation request byte contrast  allocator amount memory request program additional allocation header binning allocator memory fragmentation faster allocation deallocation practically fragmentation overhead tend negligible program expose pre binning memory allocator hardware memory safety inter allocation spatial memory safety goal inter allocation spatial memory safety identify pointer access access address outside memory allocate pointer perform information address allocation allocate pointer address  access benefit binning allocator compute arithmetic concurrently data access pointer address pointer GiB heap address pointer ptr allocation allocation address allocation compute ptr whereas combination integer multiplication ptr ptr align boundary address assume heap address memory allocator bin GiB allocation program executes char malloc memory allocator return address arbitrary pointer ptr hardware computes heap address ignore lsbs hardware retrieves allocation recent proposes passing semantic information software hardware achieve resource utilization enhance performance however neither allocation grain security hardware finally address compute information attack attacker ability index variable dynamically allocate array ability attacker pointer bound subvert memory instruction allocation simply calculate address attacker modify address attack expectation address ought avoid  extends memory access instruction extra operand trust address trust address simply address return malloc verify correctness access compute address input pointer trust address instruction compute address pointer memory access instruction costly operation operation multiplication relatively expensive operation CPUs simplify bound operation  ptr ptr instruction trust address compute correspond extract explain difference input pointer trust instruction address pointer overflow adjacent allocation difference compute difference pointer underflows previous allocation ptr negative interpret positive unsigned arithmetic compatible unprotected code memory instruction perform emit instruction specifically secure load secure load secure secure instruction allocation address distinct operand operand propagate binary compiler pas secure load secure verify access boundary  described machine hardware secure load interpret regular load operand ignore intra allocation spatial memory safety goal intra allocation spatial memory safety prevent overflow another within allocation strategy intra allocation safety convert intra allocation memory safety inter allocation source source transformation BufPtr previously data layout optimization enhance performance BufPtr promotes buffer exist structs allocation illustrate BufPtr listing array buf within struct foo replace promote pointer buf variable array define foo buf transformation allocation deallocations usage properly promote allocation composite data foo becomes allocation promote foo buf standalone allocation address described struct foo char buf int struct foo malloc sizeof struct foo buf promote char foo buf struct foo char buf int promote allocation struct foo malloc sizeof struct foo buf malloc sizeof foo buf promote usage buf buf promote deallocations buf transform listing BufPtr transformation temporal memory safety enforce temporal memory safety tag upper data pointer random upon malloc propagate instruction secure load secure memory address allocation address tag memory address tag allocation address temporal safety violation probability virtual memory reallocate receives random tag implicitly nullify dangle pointer likely tag handle procedure nest pointer pointer allocation derive pointer within allocation pointer happens function aka context originally function pointer derivative access address source source transformation extra operand function pointer argument address stack function function signature compatibility unprotected code instead simpler abstraction whenever data pointer context another function spill memory verify  pointer verify bound verify bound instruction pointer load memory compute address compute instruction propagate address memory instruction operand approach attacker abuse pointer escape another function verify bound pointer spill memory memory assure pointer memory cannot overwritten abstraction permit intra procedural analysis simplifies implementation verify bound verify bound instruction address operand compute address inside compute operand retrieve address propagate address memory instruction address architecture instruction ISA secure secure load instruction register operand register load address source destination register register reserve allocation address propagate compiler upon execute instruction hardware computes allocation difference address exception thrown additionally hardware upper detect temporal memory safety violation verify bound instruction bound pointer memory passing function register operand register pointer whereas register reserve allocation address propagate compiler secure secure load upon execute instruction hardware computes allocation difference address exception thrown bound pointer memory compute instruction memory address pointer input return allocation address pointer instruction retrieve address pointer context function IV microarchitecture hardware component enable mast memory allocation hardware structure initialize program startup allocation configuration binning allocator mast enables generic non allocation bin binning allocator heap equally bin distinct bin sufficient balance performance memory utilization entry mast entry KB entry inverse nth entry allocation nth allocator bin inverse optimization later program heap contiguous hardware register address program heap derive address bin binning allocator tcmalloc  allocation bin runtime bin freed allocator simply update mast entry investigation memory allocator future bound module bound module operand ptr  subtracts operand allocation  compute pointer bound module pointer allocation bin shift operation access mast retrieve allocation bound module subtraction operation ptr  unsigned comparison recently retrieve  temporal comparison operation upper ptr  bound module invoked secure load secure instruction prevent bound pointer dereference verify bound instruction prevent bound pointer escape memory operation totally hidden within access latency data cache compute module II pointer context another relies intra procedural compiler analysis recompute address pointer load memory pointer function argument feature currently implement compute instruction invokes compute module eliminate mast additional memory overhead optimization  bound data array tag array address decoder address decoder mux data address calculation memory allocation exception data cache address compute aligner offset tag index bound module pipeline diagram cache operation bound operation pipelined avoid access latency data module ptr operand computes address ptr ptr ptr ptr mast lookup operation costly  optimization replaces expensive ptr ptr cheaper multiplication ptr ptr fix arithmetic approach feasible allocation constant allocation reciprocal pre calculate mast along allocation dedicate register file secure load secure instruction register operand introduce register pressure architectural register compiler exclusively propagate allocation address register register file access parallel regular register file software memory allocator compiler operating dynamic memory management contribution allocation architectural feature allocation information software hardware enable feature binning memory allocator memory allocate constraint allocator manages internal metadata intercept memory management operation intercept malloc tag return pointer random ensure temporal memory safety upon deallocation intercept delete remove tag allocator delete api pointer uninstrumented code tag ignore hardware maintain compatibility compiler heap instrumentation guarantee spatial protection implement instrumentation pas llvm IR replaces program load instruction secure load secure allocation address register operand  analysis propagate pointer return malloc intra procedurally handle context pointer load memory function argument compiler pas insert compute instruction correspond location resolve allocation address pas insert verify bound instruction pointer memory due cast pointer ptr integer int ptr ptr memory ptr passing ptr function ptr return ptr function return ptr source source transformation achieve  memory safety source source transformation BufPtr described II BufPtr implement clang  interface perform ast traversal translation program composite data structs usage perform traversal perform actual rewrite stack global instrumentation achieve memory safety memory extend allocate stack global memory compile stack global allocation  bin satisfy heap allocation unified enforce memory safety program memory avoid overhead related allocate stack heap adopt pointer mirror memory aliasing technique prior operating mast initialization program initialization memory allocator pas allocation information hardware task hardware mapped memory fix described IV context switch upon context switch operating OS mast dedicate register file content interrupt update mast register file mast register file content fix likely minimal overhead load instruction OS context switch typically privileged exception hardware detects access violation privileged exception instruction becomes non speculative operating properly handle exception privileged exception fault assume fault address exist register reporting investigation purpose finally regular data pointer memory layout naturally OS functionality inter data  memory mapped file per metadata swap subsystem VI security analysis threat model adversarial capability assume threat model comparable contemporary related memory safety defense assume victim program vulnerability attacker exploit gain arbitrary capability memory goal mitigate spatial temporal memory violation furthermore assume adversary aware access source code binary image target program finally assume attacker cannot tamper per configuration mast kernel memory upon context switch harden assumption assume hardware component propose trust tamper resistant therefore attack exploit hardware vulnerability rowhammer channel attack scope speculative execution attack spectre aka bound bypass threat model violates memory safety speculatively spectre variant manipulate predictor buffer affect program behavior security discussion buffer defends exploitation buffer overflow underflows detect bound pointer advantage allocation per memory architectural feature enforce spatial memory safety protects  allocation stack global memory reserve alias stack global allocation per memory feature protection applies inter intra allocation safety BufPtr reduces  inter allocation described II temporal memory safety tag data pointer validate tag spatial bound allocate virtual physical memory tag increase dangle pointer dangle pointer tag allocate hijack attack attack scenario corrupt code pointer becomes prefer attack vector instance hijack attack rop variant corrupt return address function function pointer hijack program aforementioned attack typically spatial temporal memory safety violation effectively hijack attack eliminate data orient attack memory safety vulnerability attacker launch data attack without abuse code pointer mitigates attack ensure load legitimate bound attacker pointer bound non adjacent allocation exception compute address malicious pointer address operand secure load secure instruction uninitialized explicitly mitigate uninitialized attack attacker leak information stack heap location load location operation mitigate attack vector deallocated heap stack zeroed prior efficiently software library attack maintains compatibility library compiler pas security guarantee vulnerability exist uninstrumented code increase security coverage software wrapper commonly memory function library memcpy   ensure cannot attacker undermine  listing pseudocode memcpy wrapper computes address source destination pointer ensures address source destination plus memcpy function void memcpy wrap void dst void src compute src src compute src src assert src src compute dst dst compute dst dst assert dst dst return memcpy dst src listing memcpy wrapper spectre resiliency advantage prior memory safety defense resiliency speculative channel attack namely spectre bound bypass summarize spectre undermine prior memory safety technique finally mitigates extra mispredicted secret data val secret secret leak listing speculative execution attack attack summary understand spectre listing attacker index attacker predictor multiple valid attacker bound index index violates software bound hardware mispredict speculatively executes speculative buffer  occurs secret index attacker finally leak secret via covert channel speculative execution leaf trace processor structure data cache address depends secret flush reload data cache attacker cache reveals secret prior spectre concern prior memory safety technique undermine security guarantee attacker infer memory tag memory without trigger memory tag violation bypass memory tag sparc adi  mitigate spectre prior insert serialization instruction aka fence program prevent processor speculatively bypassing bound approach runtime overhead another propose isolate speculatively access data prevent leakage via covert channel defense reduce performance overhead substantial complexity hardware spectre secure load secure instruction resilient spectre construction processor mispredicted instruction listing secure load legitimate bound data operand immediately recognizes speculative access bound access data access cache avoid modify cache hence resilient recent spectre attack namely μop disclosure primitive exploit micro cache timing channel transmit delay overhead GE gate equivalent hardware structure GE delay baseline data cache bound module compute module bound secret additionally prevents dependent load instruction execute  register load exception bound access non speculative delay exception commit stage avoid false alarm bound memory access happens due benign misprediction spectre variant VI  spectre variant bound bypass focus memory safety spectre variant spectre aka target injection attacker pollute target buffer victim program speculatively arbitrary sequence instruction spectre gadget spectre gadget memory access instruction secure load speculatively execute content register memory address register allocation address register content belong incorrect execution context argument applies spectre gadget compute instruction  mitigation address attack vector vii evaluation evaluate across multiple dimension hardware overhead performance  deployment memory safety spec cpu analyze memory overhead fourth evaluate BufPtr estimate memory performance benchmark hardware overhead minimal hardware qualitatively KB mast extra logic compute allocation address namely shift multiplier bound module namely shift comparator comparator bound operation parallel data tag access processor frequency impact quantify overhead typical optimize KB mapped cache implement module verilog synthesize synopsys compiler  library generate SRAM array mast tag data array  summarizes VLSI implementation timing delay bound module minimal pipelined fetch allocation mast subtraction comparison operation latency overlap access latency cache bound module additional data cache dominate SRAMs mast comparators compute module invoked compute instruction dominate multiplier module latency optimize customize multiplier software performance overhead VLSI measurement hardware modification performance overhead evaluate software overhead instruction secure load secure regular load increase code instruction register operand regular memory instruction extra register pressure compensate specific register file intel MPX additional functionality perform instruction totally hidden within processor pipeline vii however binning memory allocator invokes additional instruction verify bound verify pointer bound memory compute compute allocation address arbitrary pointer load memory without loss generality implement binning allocator binning malloc virtual memory 2GB satisfy heap allocation request unique stack global memory allocation satisfied carve 2GB estimate compute instruction overhead implement IR pas llvm clang compiler code insert mul instruction instead compute instruction correspond location similarly insert dummy instruction verify bound instruction instruction omit compiler optimization evaluation setup bare intel skylake xeon processor 6GHz  linux kernel implement clang AddressSanitizer ASan intel MPX representative pre deployment memory safety respectively recommend setting suppresses warning error benchmark completion additionally disable reporting minimize performance impact functionality difference compiler version optimization norm exec intel MPX address sanitizer software  binning malloc performance overhead spec cpu benchmark normalize correspond baseline normalize respective baseline comparison insight overhead software version explicitly pointer bound software hardware software  malloc version binning memory allocator bound  spec cpu benchmark suite ref input completion minimize variability benchmark execute average execution report performance summarizes performance overhead spec cpu normalize correspond baseline geometric ASan MPX  binning malloc overhead underlie memory allocator introduces overhead gcc allocates pad binning malloc introduces extra runtime whereas binning malloc version slowdown configure allocation program initialization reduce pad overhead software memory overhead accurately memory usage linux utility  regularly snapshot memory peak resident RSS actually memory virtual address reserve II binning allocator memory overhead average  allocator gcc  povray outlier inspect allocation intensive benchmark memory allocator memory overhead comparable binning  tcmalloc  allocator dlmalloc  clang ASan gcc intel MPX gcc perlbench namd blender fail MPX due  error exclude MPX average II memory usage spec cpu bench memory usage MB heap allocation BufPtr perlbench gcc mcf namd  povray lbm omnetpp xalancbmk blender deepsjeng  leela nab gcc  povray norm memory usage glibc dlmalloc   tcmalloc memory usage allocation intensive benchmark memory allocator BufPtr analysis memory memory overhead BufPtr report separately BufPtr promotes intra allocation buffer standalone allocation additional heap allocation report bracket II majority benchmark extra allocation exception  blender deepsjeng latter performs malloc structs intra buffer extra allocation actual source code transformation minimal affect struct performance performance overhead promote intra allocation standalone allocation amortize program execution buffer typically load regular execution BufPtr argue load load indirection however implement BufPtr source transformation advantage compiler optimize access load load address load address adjust verify hypothesis overhead implement BufPtr program spec cpu benchmark overhead baseline memory allocator without BufPtr deployment  discus requirement strength weakness requirement usage binning memory allocator internal detail memory allocator irrelevant minimum requirement allocation per memory allocator aka non binning  allocator violate requirement allocate non binning allocator rely allocation header allocation allocator derive allocation address memory access allocation header memory instruction execute additionally spatial memory protection non temporal memory aspect strictly temporal tag upper data pointer non temporal memory safety achieve efficient approach randomization memory quarantine handle   idiom programmer propensity exploit undefined behavior undefined behavior behavior explicitly disallowed standard issue document excellent exposition author CHERI idiom intentionally bound pointer although unclear programmer idiom exists strive identify pointer allocation arithmetic operation bound pointer function inside program access memory intra procedural analysis recompute address function entry compute however already bound pointer resultant address refer data pointer escape operation compiler performs intra procedural analysis categorization prior spatial memory safety handle security metadata bound tripwires per allocation per pointer disjoint metadata  bound  ASan softbound watchdog intel MPX AOS CHEx inlined metadata  CHERI compact ptrs califorms metadata  sparc adi implicit metadata native ptrs encode pointer load insufficient handle verify bound bound pointer escape memory function described II functionality programmer undefined behavior fix strength deterministic memory safety guarantee granularity protection variety spatial temporal memory safety violation hijack attack data orient attack pure data corruption protection minimal performance overhead minor hardware furthermore naturally mitigates speculative execution threat spectre additional weakness BufPtr precise information allocate guaranteed style program void allocation compiler infer intra allocation skip limitation technique rely source transformation intra allocation protection evaluation vii intra allocation buffer minimal allocation ambiguous properly handle program annotation future IX comparison prior summarize prior related memory safety mitigation categorize prior handle metadata bound information metadata maintain disjoint inlined implicit  prior technique security hardware IV comparison prior proposal spatial protection temp binary MT hardware metadata memory performance inter intra prot comp modification overhead overhead overhead  μop injection tlb tag per ptr ptrs ptr  per softbound per ptr ptrs ptr   bound pad ptr ops compact ptrs extra pipeline stage pad ptr ops bound update watchdog rename logic μop injection logic per ptr ptrs  ptr  lock location  per ptr ptrs  ptr ops native ptrs pad ptr ops bound register per ptr ops execution instruction ptr  intel MPX unknown platform per ptr ptrs ptr  BOGO unknown platform per ptr ptrs ptr  CHERI capability coprocessor tag ptr ptrs ptr ops capability cherivoke capability coprocessor tag ptr ptrs ptr ops tag controller capability pump extend data tag width per cache prog mem footprint ptr ops handler  unknown platform per prog mem footprint tag ops per L1D comparator token blacklist memory dis  califorms per L1D per per critical blacklist memory bloc  AOS pac instruction memory bound per ptr ptrs ptr  queue bound bound buffer CHEx μop injection logic alias capability per ptr  ptrs ptr  speculative pointer tracker bound compute KB per pad ptr  module address register file linear non linear overflow linear protection partial protection protection fully compatible execution compatible protection external module modify pointer stateless synchronization global metadata achieve bound narrow complexity memory requirement performance overhead IV explicit bound memory safety defense attache bound metadata pointer allocation metadata shadow aka disjoint memory  softbound intel MPX CHEx AOS marshal pointer extend CHERI temporal memory safety technique additional identifier along pointer metadata verify stale identifier retrieve  watchdog  invalidate pointer freed lookup BOGO explicit bound security guarantee advantage simpler hardware modification faster prior saving mainly stem metadata spatial temporal memory safety  metadata shadow memory extra memory access fetch update metadata introduces atomicity multithreading application bound technique softbound advantage hardware  encode pointer bound extra load register operand propagate within function scope perform memory safety hardware hardware reduce runtime overhead softbound eliminate perform bound software reduce memory lookup fetch metadata disjoint memory structure however hardware aforementioned perform extra memory operation access bound pointer load memory within function scope pointer contrast performance due derives bound information pointer load memory specifically replaces costly metadata memory access arithmetic computation compute instruction increase pointer width metadata layout compatibility unprotected library contrary performs arithmetic computation derive allocation bound fix mast furthermore metadata aspect scheme allows multi thread application false positive negative disjoint metadata scheme intel MPX additionally BufPtr transformation  resolve intra allocation memory safety overlook recent memory safety technique software implicit bound derive allocation bound pointer guard pointer memory  encode pointer upper similarly  bound restricts allocation encodes binary logarithm allocation pointer upper unlike choice significantly increase program memory footprint due pad allocation  moreover neither guard pointer  bound temporal protection compact pointer avoid restriction float representation encode allocation bound pointer CHERI concentrate adopts approach compress metadata instead pointer layout introduce instruction manipulate due pointer layout manipulation technique neither temporal memory safety maintain binary compatibility binning allocator native pointer program virtual address allocate non software native pointer suffers performance overhead additionally native pointer naturally temporal protection  temporal protection intra allocation memory safety native pointer expensive per allocation metadata concurrent hardware  dubbed maintain per allocation metadata pointer upper index intra allocation bound retrieval metadata scheme program stack heap globals reduce lookup overhead unlike temporal protection utilizes pointer upper index metadata advantage  per pointer allocation metadata almost native performance memory safety mitigation memory tag technique associate newly allocate memory upper data pointer access allocate memory runtime hardware enforces spatial memory safety pointer access memory sparc adi assigns memory limit minimum allocation  per memory metadata acquire along correspond data extra memory operation temporal safety enforce assign memory reuse unlike tag temporal protection tag memory tag defense limited tag pointer memory location prior technique entropy temporal protection  allocation sparc adi allocation attacker bypassing defense tripwires memory safety defense aim detect overflow memory allocation flag access predetermine random dubbed token memory invalidate spatial memory safety violation detect cache token fetch due token intra allocation memory safety califorms solves insert hardware canary introduce cache format inline metadata within program data tripwires califorms comparable performance overhead security guarantee cannot bypass non adjacent buffer overflow microsoft memory safety CVEs additionally califorms demand quarantine pool temporal safety memory quarantine typically increase performance overhead prevents program reuse recently freed memory satisfy allocation request instead rely memory quarantine achieve temporal memory safety effectively reduce overhead allocation intensive application finally attacker bypass califorms intra allocation protection binary leak location hardware canary encode binary whereas binary secret allocation information derive propagate runtime conclusion propose secure architecture implicitly derive allocation bound enforces spatial memory safety temporal safety without increase program memory footprint maintain compatibility unprotected code overall incurs performance degradation slowdown software version extra security guarantee benefit reduce  overhead improve pre deployment software furthermore user willing performance degradation memory safety protection excellent user willing security feature non pointer data corruption performance degradation lightweight exploit mitigation technique ZeRØ benefit beyond memory safety instance allocation architectural feature accelerate garbage collector memory opportunity enhance predictability memory prefetchers dram controller