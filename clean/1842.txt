recently OpenCL emerge program model efficient fpga accelerator however OpenCL framework FPGAs suffer performance usability proposes highlevel synthesis framework OpenCL FPGAs SOFF automatically synthesizes datapath execute OpenCL kernel thread pipelined manner synthesizes efficient memory subsystem datapath characteristic OpenCL kernel unlike previous synthesis technique propose formal handle  instruction complex OpenCL barrier atomic operation OpenCL kernel SOFF OpenCL framework correctly compiles executes application spec accel benchmark suite application fpga resource available addition SOFF achieves speedup intel fpga sdk OpenCL without explicit user annotation source code modification index accelerator architecture FPGAs synthesis parallel program pipeline processing introduction efficiency becomes important goal performance compute hpc datacenter server FPGAs emerge opportunity FPGAs intel xilinx logic deliver performance tflops microsoft adopt FPGAs datacenters accelerate data compression etc amazon EC compute instance exploit FPGAs recently OpenCL compute promising program model fpga accelerator fpga vendor intel formerly national research foundation korea NRF grant NRF MCA  BK plus program pioneer innovative compute dept computer engineering  NRF institute information communication technology promotion  grant cuda program environment fpga cluster fund ministry ict  korea samsung advanced institute technology  samsung electronics ltd ict  national research facility   national altera xilinx release OpenCL framework FPGAs advantage OpenCL synthesis HLS OpenCL kernel spatial parallelism kernel thread execute simultaneously pipelined manner traditional hardware software partition OpenCL application already compute intensive kernel remain OpenCL excludes feature implement FPGAs recursion function pointer fourth memory hierarchy naturally mapped memory hierarchy FPGAs external memory embed memory register finally due gpgpu technology decade OpenCL enjoy software ecosystem OpenCL HLS exist application fpga without modification however significant effort research community achieve performance usability OpenCL HLS OpenCL framework FPGAs hinder numerous bug unsupported feature explicit user annotation generate inefficient circuit OpenCL application significant HLS technique OpenCL kernel publicly propose internal implementation commercial OpenCL framework remain hinders researcher fundamental OpenCL HLS proposes synthesis framework OpenCL FPGAs SOFF  OpenCL framework FPGAs datapath architecture FPGAs pipeline thread OpenCL kernel compilation automatically synthesize logic circuit extends concept pipelining II propose previous HLS dataflow architecture compiler feature OpenCL describes formal handle  instruction IV IV complex IV synchronization primitive IV OpenCL kernel acm annual international symposium computer architecture isca doi isca valid stall loop instruction loop datapath structure execute loop cycle cycle executes loop iteration datapath SOFF OpenCL framework correctly compiles executes application spec accel benchmark suite application fpga resource available moreover explicit user annotation source code modification version SOFF implement evaluate intel arria fpga however propose technique independent specific fpga directly apply FPGAs xilinx contribution proposes technique automatically synthesize efficient datapaths FPGAs OpenCL kernel technique stall handle mechanism deadlock prevention mechanism proposes adopt intermediate representation HLS easily complex structure program proposes implementation OpenCL barrier atomic operation datapath correctly execute OpenCL kernel proposes efficient memory subsystem datapath characteristic OpenCL kernel evaluation SOFF spec accel polybench achieves speedup intel fpga sdk OpenCL without explicit user annotation source code modification II background briefly introduce synthesis HLS technique OpenCL program model synthesis HLS technique FPGAs reconfigurable architecture target imperative program propose despite target platform almost primary goal HLS generate datapath imperative program usually entire application HLS multiple functional datapath allocation determines cycle instruction target program completes execution schedule functional instruction execute binding connects functional bus register muxes accord schedule binding addition generate multiple datapath capacity target fpga allows execute multiple instance program thread loop iteration simultaneously datapaths component memory controller finally register transfer rtl description deliver logic synthesis reconfigure fpga widely approach discover parallelism imperative program utilize functional datapath exploit instruction parallelism ILP compile pipelining pipelining exploit ILP exploit ILP within variant hyperblock trace cycle functional datapath execute data independent instruction parallel instruction datapath executes approach widely VLIW architecture illustrates datapath executes loop loop consists instruction suppose latency instruction cycle illustrate datapath computes cycle load cycle computes cycle computes fourth cycle finally fifth cycle iteration loop execution however approach hinder limited instruction parallelism  instruction typical imperative program moreover muxes functional appropriate input source instruction multiplier muxes costly FPGAs compile pipelining target loop multiple loop iteration execute pipelined manner instead execute suppose loop consists latency instruction compile loop loop dependence pipelined datapath easily construct functional instruction accord data dependence instruction insert register functional ensure entry exit register split pipeline stage pipelined datapath loop functional corresponds individual instruction muxes functional receives input predecessor register insert functional split datapath stage datapath execute loop iteration per cycle loop loop dependence capacity target fpga insufficient complex schedule algorithm modulo schedule approach compile pipelining functional assign exactly pipeline stage compile pipelining however loop contains complex datapath cannot split fix pipeline stage compile variable latency instruction FPGAs compute instruction usually fix latency load instruction embed chip memory intel MK memory xilinx RAMs fix latency however application external memory dram handle data cache implement fpga embed memory improve performance external memory access latency load instruction access cache previous compile pipelining technique target innermost perfectly nest loop employ complex memory subsystem construct pipelined datapath without schedule instruction compile instead functional communicate handshaking protocol execute instruction whenever operand mechanism implement asynchronously without global synchronously global pipelining datapath recent synthesis technique adopt approach complex application OpenCL OpenCL program model heterogeneous purpose cpu accelerator gpus FPGAs OpenCL application consists host program kernel compute intensive data parallel task application usually implement kernel execute accelerator application becomes host program cpu host program typical program java python kernel resemble function OpenCL program argument host program execution model host program issue kernel execution command accelerator OpenCL api function instance kernel kernel thread execute accelerator kernel instance item addition item equally multiple item unique global ID workgroup unique ID similarly  unique local ID within host program define index  execute kernel  determines item assign ID item item argument distinguish IDs OpenCL built function obtain item ID memory hierarchy OpenCL hierarchical memory address kernel global memory local memory private memory global memory host program item host program invokes OpenCL api function allocate byte array buffer global memory data memory global memory host program pas pointer array kernel argument item access global memory pointer local memory item within private memory private item kernel declares address local variable allocate host program cannot access local memory private memory cpu memory fpga static reconfigurable pcie endpoint dma memory controller external memory item dispatcher item counter memory subsystem datapath datapath datapath argument trigger completion cpu accessible register memory interface pcie bus structure target platform diagram circuit reconfigurable memory consistency model OpenCL relaxed memory consistency model item execute independently kernel barrier atomic operation barrier barrier function synchronizes item within guarantee memory consistency affect item workgroups atomic operation visible subsequent atomic operation item related previous HLS technique OpenCL program cuda simply translate OpenCL kernel sequential program deliver traditional HLS ignore inherent spatial parallelism OpenCL kernel rely traditional HLS parallelism previous synthesize purpose core fpga execute OpenCL kernel core suitable maximally utilize compute FPGAs propose OpenCL fpga compiler generate logic circuit executes multiple item pipelined manner introduce  module behave similarly pipeline IV mention deadlock inner loop briefly however formally discus deadlock propose efficient prevention mechanism moreover address variable latency instruction barrier important issue OpenCL HLS overview SOFF describes overall implementation SOFF target platform circuit compilation execution target platform illustrates target platform SOFF consists cpu fpga pcie bus fpga consists logic dsp embed memory programmable interconnect addition external memory embed memory external memory becomes OpenCL global memory fpga static reconfigurable static contains logic component commonly OpenCL application reconfigurable contains compiler generate circuit dedicate execute kernel application target platform boot static anymore reconfigurable modify application partial reconfiguration widely FPGAs static contains pcie endpoint communicates device driver cpu pcie endpoint enables device driver directly register inside reconfigurable dma request memory fpga external memory actual data transfer dma static feature easily implement IP core fpga vendor reconfigurable diagram circuit reconfigurable suppose target OpenCL application kernel reconfigurable contains item dispatcher datapath memory subsystem item counter later datapath reconfigurable argument register trigger register completion register register accessible device driver kernel argument definition  integer assume argument register trigger register kernel execution item dispatcher distributes item datapaths item datapath assigns datapath sends IDs item correspond datapath cycle unless entry datapath temporarily stall item assigns datapath workgroups assign datapaths distribution barrier local memory easily implement datapath executes assign item pipelined manner item private variable intermediate register addition expose memory interface memory subsystem interface issue load request global local memory response load request memory subsystem contains embed memory OpenCL local memory cpu thread fpga OpenCL api configure request thread datapaths host program kernel compiler OpenCL  compiler logic synthesis cpu executable fpga bitstream SOFF IP core runtime verilog code kernel function inlining ssa pointer analysis DFG datapath generation memory subsystem generation verilog code variable analysis compile execute OpenCL application detailed compilation dash component contribution cache global memory external memory controller static handle cache internal implementation datapath memory subsystem described IV respectively item counter incremented whenever  execution datapaths item counter item  cache flush signal memory subsystem dirty cache external memory completion register host program completion kernel execution polling completion register target OpenCL application multiple kernel reconfigurable accommodates multiple aforementioned circuit kernel contains kernel pointer register accessible device driver circuit specify kernel pointer enable circuit disabled trigger register capacity target fpga sufficiently multiple kernel reconfigurable contains circuit kernel SOFF modifies reconfigurable whenever application launch kernel partial reconfiguration FPGAs compilation execution OpenCL application compile execute SOFF OpenCL verilog compiler SOFF generates rtl description reconfigurable source code kernel application verilog contains instance SOFF IP core IP core building datapaths memory subsystem interface across target FPGAs implement target dependent manner IP core vendor rtl description SOFF IP core deliver logic synthesis intel  prime xilinx vivado generate bitstream reconfigurable although OpenCL online offline compilation kernel kernel compile SOFF offline compilation synthesize circuit predict maximum datapaths prior synthesis circuit SOFF generates various rtl description datapaths attempt synthesize logic synthesis chooses datapaths successfully synthesize SOFF runtime host program OpenCL application cpu runtime SOFF runtime user library implement OpenCL api function invoked host program configures reconfigurable pre built bitstream application interacts device driver introduce request data transfer memory fpga global memory external memory execute kernel fpga runtime writes argument register kernel pointer trigger register completion register kernel execution memory allocator manage fpga global memory code generation illustrates compilation detail OpenCL kernel static assignment ssa scalar variable vector structure array treat variable allocate private memory replace ssa variable unless address user define function kernel inlined implement function fpga barrier regard leader instruction split sequence instruction kernel data graph DFG DFG acyclic graph node corresponds instruction corresponds data dependence instruction convenience introduce arbitrary node source sink DFG source ssa variable sink consumes variable DFG widely adopt intermediate representation previous HLS technique  respectively construct DFG SOFF DFG kernel void global float global float int int int float global barrier clk global mem fence source sink source  sequence  sequence sequence sequence sink OpenCL kernel consist DFG structure entire DFG anti output dependence memory access DFG dependence node  output dependence treat normal DFG transfer data SOFF conservatively assumes memory access refer location address buffer load node node insert anti dependence load addition memory access sink node ensure completion unless subsequent datadependent node sink DFG correctly partial execution node contains finally hierarchically grouped kernel entire kernel leaf individual node leaf node construct structure program specifically sequence        indicates entry multiple exit acyclic graph  indicates multiple exit loop node target kernel contains return statement assume OpenCL kernel structure program goto construct almost OpenCL application exploit recursively construct pipelined datapath IV datapaths architecture individual datapaths functional mention II functional building datapath functional executes individual instruction kernel consumes operand instruction cycle implementation functional target fpga SOFF IP core functional fully pipelined increase operating frequency datapath advantage pipelined access dram simultaneously executes instruction item pipelined manner consumes input cycle output input functional item input instruction consume cycle output cycle intermediate instruction item functional SOFF defines maximum latency LF functional fix latency LF simply indicates otherwise LF properly empirically item correspond instruction LF cycle minimize functional stall IV prevent deadlock IV pipeline pipeline circuit executes consumes ssa variable correspond ssa variable contains multiple functional DFG node instruction connection functional isomorphic DFG output predecessor functional becomes input successor functional functional correspond source node mention simply distributes ssa variable successor functional correspond sink node aggregate output predecessor output entire pipeline pipeline implement synchronous pipelining scheme introduce II functional consumes input verifies predecessor output similarly functional output verifies successor consume previous output previous output handshaking predecessor successor protocol propose source functional sink functional pipeline source sink source sink pipeline item cycle pipeline  handle pipeline stall functional temporarily stall pipeline cannot consume input cycle functional stall predecessor subsequently stall cycle delay stall functional predecessor predecessor recognize stall cycle without delay global stall signal scalable introduce functional contains additional register maintain output successor stall recognize stall functional restore stall output consume successor stall SOFF stall occurs variable latency instruction memory load instruction correspond functional item consumes input finally pipeline becomes reduce stall SOFF enforces functional stall item LF maximum latency obvious fix latency functional adder multiplier constraint however sophisticated variable latency functional memory subsystem carefully implement satisfy constraint understand deadlock prevention mechanism described IV LF item stall stall occurs functional successor output cannot output finally output reduce stall SOFF insert fifo queue functional sum maximum latency source sink pipeline sequence datapath sequence  pipeline pipeline pipeline sequence  sequence pipeline pipeline pipeline pipeline datapath OpenCL kernel minimal amount fifo queue formulate integer linear program ILP SOFF variable ILP formulation fifo queue functional hierarchical datapath generation entire datapath construct hierarchically combine pipeline accord structure non leaf node SOFF merges pipeline node glue logic pipeline role glue logic deliver  pipeline another pas variable item pipeline input another pipeline illustrates datapath construct built pipeline correspond dash compound pipeline correspond non leaf node sequence   node datapath contains glue pipeline glue delivers item successor predecessor zero glue chooses item item predecessor delivers successor cycle SOFF glue implementation propose unlike functional pipeline pipeline non leaf node output input item execution loop iteration IV introduce glue logic restrict item freely reorder consecutively deliver item barrier cycle instruction cycle instruction cycle inst cycle inst loop kernel simplify pipeline execute loop cycle cycle pipeline stuck deadlock another loop pipeline deadlock cannot avoid assign priority glue compile partial pipeline datapath pipeline correspond node execute  multiple pipeline loop execute item pipeline deadlock prevention glue item regardless behavior glue deadlock loop describes deadlock introduces glue logic prevent deadlock motivate illustrates simplify pipeline execute loop  loop iteration remain iteration latency glue item loop enters  iteration arrives glue whenever chooses item stall finally resume loop deadlock deadlock easily avoid priority compile complex deadlock cannot avoid assign priority item iteration iteration finally glue priority loop stuck deadlock iteration priority loop stuck deadlock iteration characteristic pipeline introduce deadlock prevention mechanism SOFF characteristic individual pipeline definition pipeline strongly stall cannot consume input cycle addition resume consume input output consume successor pipeline pipeline contains functional DFG source node source DFG sink node sink fix latency instruction variable latency instruction stall introduce IV occurs stall subsequently occurs stall pipeline becomes unable consume input however pipeline strongly stall consume input cycle item output consume successor pipeline stall occurs subsequently stall pipeline becomes unable consume input pipeline strongly stall functional restore stall output consume successor pipeline source sink LF functional LF maximum latency addition pipeline lmin minimum source sink goal theorem theorem pipeline lmin item pipeline strongly stall source sink source sink source sink source sink source sink pipeline pipeline cannot consume input strongly stall pipeline strongly stall lemma source sink pipeline item exists functional stall cycle proof suppose functional stall cycle mention IV functional LF  entire source sink LF item contradicts assumption lemma pipeline lmin item exists functional stall cycle source functional predecessor item proof suppose arbitrary source sink exactly item entire lmin item item lemma functional stall predecessor functional item stall predecessor exists instead procedure acyclic contains finite functional finally functional source functional predecessor item lemma pipeline lmin  strongly stall proof lemma pipeline lmin item eventually consumes input output consume successor pipeline meantime functional satisfies lemma source functional predecessor output item consume input aggregate output predecessor without intervention logic component functional item lmin  finite item functional eventually source functional chosen source functional stall entire pipeline consume input theorem easily lemma assume pipeline loop contains cycle pipeline glue glue deadlock pipeline strongly stall glue chooses successor solely behavior OpenCL kernel cannot avoid prevent deadlock accord theorem SOFF prevents lmin item costly individual glue independently limit  cycle loop pipeline cycle minimum lmin limit  loop pipeline minimum however significantly lower utilization functional loop item usually longer execution SOFF improves latter nmax nmin maximum minimum lmin respectively SOFF item loop pipeline nmax insert fifo queue nmax nmin loop enforce nmax item loop pipeline SOFF attache loop entrance glue loop exit glue entry exit loop pipeline respectively item counter counter nmax loop entrance glue permit item loop pipeline item leaf loop counter decremented   item dispatcher barrier cond item dispatcher barrier  barrier  item dispatcher barrier item dispatcher item dispatcher barrier synchronization primitive described II OpenCL synchronization primitive barrier atomic operation describes functional correspond primitive implement SOFF barrier functional barrier fifo queue consumes ssa variable barrier incoming variable whenever item specific  variable item item assumes item consecutively item arrives item previous otherwise indefinitely storage variable item dispatcher described issue item consecutively target OpenCL kernel code assumption satisfied barrier however loop entry datapath barrier item assume  grouped item denotes denotes local ID pipeline node datapath preserve workgroup input output suppose item pipeline consumes preserve however production item preserve barrier loop respectively item barrier consecutively preserve loop recursively inductively implement   preserve SOFF preserve addition insert fifo queue glue glue glue enqueues ID incoming item glue delivers item ID queue preserve workgroup item ID entry exit loop   preserve SOFF loop bound expression kernel argument constant item iterate loop SOFF cond preserve otherwise SOFF attache  entrance glue  exit glue entry exit loop respectively item enters loop glue permit item loop loop becomes empty descendant loop additionally preserve SOFF applies preserve workgroup   barrier inside pipeline preserve workgroup item accord OpenCL program model otherwise behavior OpenCL kernel undefined barrier inside loop loop entrance glue loop loop stuck deadlock assume item loop entrance glue item loop enqueued barrier barrier permanently SOFF replaces loop entrance exit glue  entrance exit glue atomic operation atomic operation rarely OpenCL application hinder performance kernel gpus SOFF conservatively implement functional atomic operation lock atomic operation access cache local memory described lock execution functional acquires lock correspond cache address lock addr execution release lock minimize lock contention typical OpenCL kernel atomic operation datapath mem interface external memory datapath cache arbiter local memory cache cache local memory cache memory arbiter memory subsystem functional access OpenCL global memory access OpenCL local memory memory subsystem describes architecture memory subsystem illustrates diagram memory subsystem SOFF role memory subsystem memory interface functional executes memory load instruction unlike compute instruction functional cannot execute memory load instruction instead issue memory access request memory subsystem memory interface memory interface SOFF  memorymapped  MM interface protocol cache functional access global memory cache memory subsystem cache non cache cooperate fully pipelined functional SOFF mapped cache introduce complex cache degrade operating frequency entire circuit cache fpga external memory vendor specific protocol  MM axi feasible handle global memory access request numerous functional cache generally cache memory access request handle cycle SOFF discovers characteristic OpenCL kernel distribute irrelevant memory access request multiple cache SOFF cache OpenCL buffer mention II OpenCL kernel access global memory buffer pointer host program memory access refer buffer access memory location cache SOFF chooses cache functional accord pointer analysis SOFF cache datapath instance kernel atomic operation OpenCL guarantee memory consistency unless atomic operation item local int int local memory array int datapath instance addition significantly degrade cache ratio usually access global memory functional datapath instance access buffer cache robin arbiter datapath cache arbiter insert functional cache functional mention IV cache datapath cache arbiter guarantee functional across memory interface stall LF item LF pending memory access request otherwise additional pipeline stall deadlock IV local memory SOFF local memory variable array allocate OpenCL local memory functional access local memory variable correspond local memory illustrates local memory array int SOFF determines granularity array access compile local memory byte address unlike cache global memory local memory sufficient enable functional concurrently access conflict occurs specifically creates functional address functional datapath execute item however local memory private individual  maximum LF datapath entry exit target OpenCL kernel local memory SOFF allows  datapath  workgroups datapath previous workgroups execution commonly target SYSTEMS fpga intel programmable xilinx virtex ultrascale acceleration fpga VCU acceleration intel arria GX fpga development kit fpga intel arria GX xilinx   LUTs logic logic DSPs dsp dsp slice embed memory external memory GB ddr GB ddr interface pci express gen pci express gen cpu intel xeon CPUs memory GB GB OS centos ubuntu logic synthesis  prime vivado pro suite OpenCL intel fpga sdk SDAccel framework OpenCL addition SOFF local memory variable  local memory capacity ID address VI evaluation SOFF commercial OpenCL framework intel fpga sdk OpenCL intel OpenCL xilinx SDAccel experimental setup describes target fpga intel xilinx officially vendor OpenCL framework SOFF intel OpenCL xilinx SDAccel logic dsp slice capacity embed memory xilinx fpga intel fpga application spec accel application polybench II application spec accel various complicate feature OpenCL application polybench benchmark application mainly execution OpenCL kernel CPUs component significantly impact performance implement runtime SOFF intel arria fpga source OpenCL runtime code intel programmable acceleration library device driver intel fpga implement SOFF IP core intel fpga empirically maximum latency functional global memory load global memory cache KB intel OpenCL target fpga OpenCL  compiler SOFF independent specific fpga II APPLICATIONS USED source application intel xilinx SOFF spec  IA CE accel stencil IA lbm fft spmv  histo CE bfs CE  kmeans lavamd CE CE cfd IR hotspot CE lud srad CE  CE CE IR  IA IA IR poly dconv bench dconv  bicg gemm   mvt syrk syrk corr   local memory barrier atomic operation CE compile error IA incorrect error hang IR insufficient fpga resource modify target fpga functional correctness compile execute benchmark application intel OpenCL xilinx SDAccel SOFF II summarizes intel OpenCL cannot execute application spec accel xilinx SDAccel cannot execute application spec accel application polybench yield compile error application atomic operation local memory access inside indirect pointer SOFF correctly executes application spec accel polybench compile error remain application kernel fails compile SOFF SOFF insufficient capacity target intel fpga circuit kernel accommodate circuit kernel described target fpga performance comparison SOFF intel OpenCL fully utilize capacity target fpga execute item multiple datapath instance mainly focus comparison SOFF intel OpenCL stencil lbm fft spmv histo bfs  kmeans lud srad dconv dconv  bicg gemm   mvt syrk syrk corr   geomean speedup speedup SOFF intel fpga sdk OpenCL speedup SOFF intel OpenCL application SOFF automatically replicates maximum datapath instance comparison manually insert num compute attribute application maximally replicate datapath instance intel OpenCL SOFF outperforms intel OpenCL application achieves speedup average static IP core SOFF target xilinx fpga reference SOFF xilinx SDAccel indirect execution application intel fpga SOFF execution xilinx fpga xilinx SDAccel comparison  SOFF xilinx SDAccel datapath instance default instance replicate target fpga user manually target OpenCL kernel multiple data parallel manner exploit multiple datapath instance optimistic assumption xilinx SDAccel achieves linear speedup application multiple datapath instance replicates extrapolate execution application execution intel fpga SOFF comparison xilinx SOFF II xilinx SDAccel SOFF despite fpga speedup SOFF xilinx SDAccel xilinx SOFF II optimistic assumption SOFF faster xilinx SDAccel cannot analyze speedup slowdown individual application detail intel OpenCL xilinx SDAccel limited information actual circuit layout however imply performance propose framework architecture comparable proprietary OpenCL framework architecture vii CONCLUSIONS propose OpenCL application execute FPGAs SOFF framework target fpga contains datapath speedup speedup xilinx SOFF xilinx SOFF II datapath executes multiple item pipelined manner datapath consists pipeline pipeline consists functional instruction functional communicate accord synchronous pipelining scheme SOFF reduces functional stall prevents deadlock inner loop preserve barrier intermediate representation  latency functional target fpga contains memory subsystem contains cache buffer datapaths memory request cycle SOFF proprietary OpenCL framework experimental SOFF correctly application achieves comparable performance exist framework SOFF solid foundation future OpenCL HLS source code SOFF http ace 