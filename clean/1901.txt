core load queue LQ queue SQ buffer SB responsible ensure load load respect external requirement safeguard sequential semantics program execution applies serial parallel code requirement safeguard semantics coherence consistency tso load SQ SB invalidation LQ speculative load violate uniprocessor multiprocessor timing constraint LQ SQ SB compose cam structure frequently complexity significant difficulty prior research demonstrate feasibility non associative LQ replay load commit steep however significant increase access contention prior assumes sequential consistency completely ignores existence SB contrast intentionally delay SB achieve management load core tso eliminate LQ without burdening extra access achieve delay speculatively issue load validate commit entirely core tso load load preserve delay remote external SB speculative reorder load commit latter inspire recent non speculative load reorder contribution accomplish without load queue eliminate LQ saving performance improvement elimination LQ induced stall index memory consistency execution introduction core load queue LQ essential issue load speculatively guarantee correctness correctness consists intra thread memory dependence consistency load load coherence load address independently consistency model memory dependence load address core location interim spanish  european commission  fund grant tin swedish research council VR grant previous resolve target address issue subsequent load severe performance penalty performance processor issue load speculatively unknown address resolve address commit LQ speculatively execute load address load subsequent instruction squash consistence load load consistency model tso specify load program previous load consume processor speculatively execute load load load violate remote core writes memory location speculative load therefore upon invalidation upon cache eviction core LQ speculatively reorder load occurs load subsequent instruction squash coherence load load address load previous correctness requirement concern specific memory model tso argue limited applicability load reorder coherence consistence requirement therefore universal coherent regardless memory model supersede consistence requirement specifically load reorder another load address load resolve address requirement invalidation eviction LQ squash speculatively execute load excellent discussion phenomenon       summarize processor aggressively execute load speculatively detect memory dependence violation memory violation consistence coherence squash offend load LQ central role approach incoming invalidation cache eviction address resolution LQ load multiple cycle associative address complex cam structure fifo allows priority LQ annual acm international symposium microarchitecture doi micro expensive structure inhibits microarchitecture cam structure grows exponentially without correspond contribution performance prior concentrate eliminate LQ culprit associative LQ non associative LQ invalidation LQ conflict load insight detection conflict load core remote core defer load commit conflict load issue commits load replayed load checked load ensures conflict invalidation longer available commit conflict undetected approach propose quickly dismiss tremendous pressure   improve filter load replay simply unresolved address invalidation load issue commit technique improve roth accurate filter load concept vulnerability  despite successive improvement remains sizeable load execute commit increase consumption creates interference cache ultimately hurt performance proposes completely eliminate load queue limitation without affect observation safely correctly delayed buffer SB previous approach ignore existence buffer instead LQ SQ relation cache hierarchy fundamental SB delay SB met without affect memory consistency model tso observation validate load speculation commit core without core delay SB  external conflict invalidation otherwise squash load delay external remote SBs implication observation LQ longer operation core tso specifically LQ longer load issue memory dependence speculation unresolved address concept commit advancement previous access extra benefit approach allows memory dependence predictor core something previous  approach LQ longer load issue consistency speculation  load tso employ concept delay conflict invalidation similarly eviction cache speculatively access load advancement previous approach LQ maintain lockdown completion load instead implement cacheline lockdown cacheline lockdown invalidation eviction cacheline speculative lock cacheline respond invalidation contrast cacheline cannot evict altogether  approach completely eliminates LQ therefore LQ without LQ commit load simply reorder buffer rob load replay commit load memory dependence speculation replay restrict core access buffer memory dependence speculation essentially substitute associative LQ buffer benefit relieve burden load replay substantial benefit approach however eliminate LQ external invalidation cache eviction external account bulk LQ previous load replay eliminate net profit eliminate LQ significant saving splash parsec spec structure involve replay proposal splash parsec spec standard architecture feature associative LQ addition elimination LQ core LQ stall issue improves performance approach associative LQ approach respectively II background conceptually load queue construct insulate structure insulate  perform operation strict program performance insulate LQ snoop load issue performance   uniprocessor memory dependence speculation multiprocessor speculative memory reorder searchable load queue perform situation resolve address validate load memory dependence speculation upon invalidation cache eviction enforce memory consistence model background relate situation memory dependence speculation instruction architecture promise instruction execute atomically sequentially program naturally load recent program address precedes load core translates load  SQ SB address exists  fundamental ISA cannot eliminate without SQ SB load access memory dependence address generation instruction delayed due latency load eagerly speculatively issue assume address unresolved address load speculative accord terminology speculative load associative access load queue buffer SQ SB speculatively access assume SQ SB resolve address access LQ speculative load violate memory dependence access load squash execute associative memory dependence prediction memory dependence prediction MDP effective address memory dependence predict load likely avoid likely futile issue load resolve address memory dependence prediction predicts existence dependence conservatively prevents load execute potentially prediction dependence harm delay execution load however MDP predicts absence dependence unsafe allows load execute presence unresolved address prediction incorrect dependence issue dependent load incorrect load squash typically instruction incorrect load squash likelihood predict absence dependence workload modest reduction associative SQ SB LQ assume MDP throughout eliminate LQ approach approach eliminates load squash LQ delay squash load attempt commit commit load  load reload intervene associative access perform per speculative load load queue buffer SQ SB speculatively access assume SQ SB access commit validate load access load squash execute standard handle speculative load described II simply LQ access profitable tradeoff depends relative LQ versus access imperative reduce replay commit minimum increase pressure detrimental performance avoid replay load commit   filter load replay commit unresolved address exists SQ commit load issue roth improves filter account load elaborate scheme enforce replay unresolved address SQ load issue despite successive improvement proposal manage approach par architecture performance extra access tax already strain resource diminish benefit convert LQ non associative structure enforce consistence coherence speculatively reorder load memory operation execute program restrictive performance consistency model tso core load execute speculatively respect non perform load reorder load speculative however consistence violate conflict another core speculatively reorder load detect invalidation conflict speculative load squash execute addition cache eviction load speculatively reorder squash load without cache invalidation conflict associative LQ speculative load approach  validation  load commit stage load replayed speculatively load load squash similarly dependence speculation II approach obviates searchable associative LQ substitute associative LQ extra access speculative load replayed filter approach replay speculative load presence invalidation cache eviction non speculative load reorder recent preserve appearance load tso efficiently achieve coherence protocol non speculative tso load load reorder reorder perform load conflict simply load perform observation conflict slightly later load perform reorder proposal simply delay conflict buffer withholding invalidation acknowledgment reorder resolve load reorder load perform approach potential catalyze  approach significantly reduce squash unfortunately relies existence LQ lock load load execute respect load invalidation withhold reorder cannot propose external structure lockdown ldt purpose remove load LQ commit however ldt external proxy LQ remove load advancement achieve goal without LQ   buffer approach eliminate LQ processor tso processor model subsequently LQ validation memory dependence speculation eliminate finally lock cachelines delay conflict buffer eliminates LQ invalidation cacheline eviction processor model processor model assume typical oforder architecture instruction queue IQ reorder buffer rob load queue LQ queue SQ buffer SB dispatch stage instruction dispatch IQ insert rob load insert LQ SQ respectively structure cannot accommodate insertion dispatch possibly stall LQ SQ replicate instruction rob simply helper structure function hone various subset instruction without LQ SQ willing  entire rob active SB SQ combine SQ SB commit active SQ SB SQ SB core core active commit active combine SQ SB expensive instead LQ SQ rob structure simply circular memory buffer SRAM relative load LQ SQ define rob explain SB upper structure commit rob SQ commits transition SQ SB upper diagram visible memory SB correspond cacheline permission remove SB permission initiate coherence action overlap latency coherence action queue SB SB prefetch permission enters SB actual processor issue prefetches SQ SB structure implementation combine SQ SB physical structure logically SQ SB diagram structure fifo cam buffer pointer dispatch remove pointer cache logical distinction SQ SB additional pointer non commit commit benefit unified combine SQ SB structure utilization available buffer downside perform target SQ SB perform target modify cam circuitry distinguish structure actually perform comparison treat SQ SB combine structure architecture LQ necessity resolve address external invalidation cache eviction occurs proposal without LQ commit insert sort sort active insert commit sort sort commit insert sort sort active active active wrap around sort wrap around flash sort sort instruction rob encode sort processor model replay commit processor model replay commit model   model speculative load extra pipeline stage commit stage access   assume replay access perform faster initial access stage speculative instruction important requirement approach become evident subsequent ability easily instruction load accomplish dynamic instruction dispatch ascend sequence sequence storage implementation limited width counter sequence incurs frequent wraparound instruction processor instruction instruction apart rob allows efficient encode inspire propose encode instruction  instruction queue  encode instruction simply rob augment additional sort sort rob circular fifo buffer pointer wrap around rob situation newly insert instruction occupy rob instruction sort correctly encodes situation instruction mechanic sort pointer rob rob dispatch instruction receives sort insert upper diagram pointer wrap around rob rob rob sort diagram newly insert instruction rob pointer pointer wrap around rob sort entry rob flash diagram instruction rob sort instruction rob entry sort flash structure rob item simply instruction versus imply comparison rob encode validate memory dependence speculation load issue unresolved address speculate memory dependence speculation validate LQ load load load commit necessitates  LQ architecture responsibility load execute speculatively squash occurs resolve address load responsibility speculation speculation initiate load issue access SQ existence prior unresolved address however load commit speculation already commit load commit already memory load SB fail SB eliminate load replay access delay appropriate SB load issue memory dependence speculation solely SB sentinel simplify presentation explain perspective speculative load issue unresolved address load issue SQ SB recent address unresolved address recall assume unified SQ SB structure approach easily adapt structure SB SQ SB cannot unknown address SQ commit SB outside instruction encode commit SB SQ replay rob commit instr flight instr speculative rob replay commit remove sentinel speculation active commit SB SQ rob commit unresolved address SQ sentinel sentinel replay commit speculative without loss generality remain pointer rob SQ SB correspond physical structure load load unresolved address SQ without intervene address becomes  speculative cannot commit unless speculation validate replay ensure load speculation validate SB unresolved address sentinel upper diagram sentinel rob load load rob combine SQ SB commits resolve target address LQ speculative load load responsible commit pas SQ SB without action however commit sentinel SB cannot load sentinel SB cannot deadlock explain commit speculative load SB diagram SQ already commit load commit commit speculative load SB address mention previously SB combine SQ SB SB appropriate modification cam logic optimization commit active commit SB SQ rob update sentinel unresolved address relative instr update sentinel speculative load remove sentinel exit SB remove sentinel access SQ SB sentinel load summarize resolve address SQ load marked sentinel load rob cannot SB load commit stage load address dependence violation load subsequent instruction squash execute dependence load commits update sentinel discussion perspective  load unresolved address however situation execution significantly complex multiple speculative load multiple unresolved address load sentinel happens multiple load sentinel similarly happens load shadow multiple unresolved address despite chaos execution approach principle sentinel issue load unresolved address perspective SQ unresolved address marked sentinel newly issue load sentinel replace sentinel resolve address sentinel cannot update longer simply cannot unresolved address commit pas SQ SB sentinel SB correspond load load perspective issue load SQ SB load trivial  writes load speculatively squash commit SB SQ rob active commit SB SQ rob commit  SQ SB SB prevent rob remove sentinel sentinel resolve cannot exit SB rob remove sentinel deadlock SB address unresolved address wildcards exist address load unknown address unresolved address address load sentinel  rob entry replay assume SQ SB non compact fifo cam structure operation described  selection logic  reverse selection logic address selection rob selection logic described detail selection circuit additional selection typically comparison rob  address rare additional selection unresolved address sentinel additional however critical load absence deadlock SB concern deadlock situation deadlock SB SB consume combine SQ SB SQ accept situation depict prevent load sentinel rob replay remove sentinel SQ contains exactly rob insert rob insert SQ dispatch stage SQ cannot accept insert instruction rob stall deadlock distance depict arrow maximum SQ combine SQ SB however distance load fix rob resolve address becomes prevents update sentinel load resolve address SQ commit unknown address deadlock impossible implies insert rob maximum SQ  conflict non speculative load reorder approach delay conflict SB reorder cannot violate consistency model tso delay conflict buffer achieve withholding acknowledgement invalidation thereby prevent obtain permission exit buffer coherence directory  non cacheable tear data guarantee absence deadlock livelock important feature approach however relevant speculative load squash invalidation cache eviction approach   invalidation cache eviction responsible replay load workload correspond percentage uniprocessor dependence speculation sophisticated complex costly execution filter technique introduce roth load replayed technique avoids squash load invalidation eviction therefore invaluable obviates replay approach intimately LQ mention II specifically LQ load reorder respect load invalidation load load becomes respect load release invalidation acknowledgement unblock correspond conflict approach LQ functionality instead lockdown implement directly access invalidation load issue  load selectively  status load rob load speculatively issue non perform load access sentinel access cacheline load receives data rob entry location cacheline cache index cacheline lockdown mode speculative cannot invalidate evict sentinel update speculative load cacheline invalidation sentinel cannot update longer prevents livelock endless update sentinel cacheline lockdown receives invalidation withholds ack invalidation speculative load sentinel rob commits load remove sentinel cacheline access location information rob entry update sentinel update tag coherence replacement frequent operation update tag sentinel replace sentinel upon invalidation eviction cache controller existence sentinel alongside coherence replacement snoop valid sentinel specific sentinel simply extra enforce snoop pas core sentinel remove cacheline invalidation acknowledgement withheld release acknowledgment queue coherence controller simply signal correspond cacheline enqueued return proposal coherence layer ensures load anywhere memory  directory non cacheable tear data latter particularly evident eviction recall eviction cachelines lockdown conflict lockdown cacheline non cacheable access approach achieves functionality nonspeculative reorder load without LQ respect simpler proposal replay speculative load commit stage guaranteed cacheline instead removal sentinel pipeline stage replay speculative load substantial reduction replay previous approach IV sentinel removal squash removal sentinel SB correspond load speculative speculative respectively rob  speculative load rob checked squash speculative load squash invalidation eviction however important load remove sentinel squash  exception  prior instruction sentinel removal technique depends processor squash discard  instruction lazily eagerly lazy squash bogus retirement lazy squash squash instruction marked rob discard rob squash load remove sentinel SB commit stage discard eager squash approach equally applicable architecture eager squash instruction squash bulk rob entry immediately reclaim allocate newly issue instruction however removal sentinel involve assume instruction speculate  load etc henceforth squash squash subsequent instruction sentinel squash cancel SB however cannot squash rob guarantee instruction squash commit speculative load rob  become squash sentinel  therefore remain sentinel  SB squash rob guarantee instruction squash commit flash remain sentinel SB release invalidation acknowledgment squash rob simplicity sentinel implies delay issue speculative load practically data squash rob almost shorter sentinel squash vast majority benchmark almost mispredicted rob sentinel benchmark notable percentage mispredicted delay sentinel average cycle exception handle  per SB entry cacheline feasible sentinel overlap squash sentinel complex handle    speculative   stall benchmark speculative load ncp dedup streamcluster canneal benefit summarize benefit approach standard architecture LQ complexity LQ speculative load perform replay SB SQ instead LQ speculative load eliminate LQ replace access cache remove sentinel   roth replay filter load replay dependence speculation vulnerability access replay speculative load SB instead replay access speculative load invalidation simply removal sentinel access memory dependence prediction correlate load conflict SB contrast previous approach identity lose writes conflict detect checked useful information discussion incur rob SQ SB cachelines rob entry enable access sentinel SQ SB cachelines selection logic SQ SB entry finally extra SQ SB handle increase contention due replay evaluation simulation infrastructure cycle accurate  simulator multicore timing model memory hierarchy cache coherence protocol interconnect  detailed processor model driven sniper incorporate  processor model implement  memory dependence predictor tournament predictor II configuration processor   haswell issue commit width instruction instruction queue IQ entry reorder buffer rob entry lazy squash load queue LQ entry queue buffer SQ SB entry memory private cache KB addr calc cycle pipelined MSHRs prefetcher private cache KB cycle cache MB per cycle directory coverage memory access cycle network topology fully data msg flit switch switch cycle  memory dependence predictor rely identity appropriate technique evaluate technique replay IV cache model implement fully pipelined prefetching simulate multicore processor consist core architectural detail simulated model intel  processor displayed II model   processor LQ bottleneck core minor performance improvement benefit baseline however comparable  parallel sequential application parallel application splash parsec benchmark suite  fmm ocean   radix raytrace   spatial freqmine streamcluster swaptions vip  barnes cholesky fft ncb blackscholes bodytrack canneal dedup ferret fluidanimate input parallel sequential application spec cpu benchmark suite ref input correspond representative billion instruction chosen simpoint methodology model technique guarantee memory dependence memory LQ approach implement commodity processor employ LQ resolve target address cache invalidation eviction happens replay alternative propose   load replay comparison retirement alternative LQ optimize completely remove LQ addition model replay filter optimization adapt proposal tso consistency model SB access load replay SB consumption per access LQ SQ SB SQ SB replay cache tag access cache replay tag access cache adapt efficiently replay SB implement extra cache replaces  approach replaces LQ replay necessitate replay guarantee local remote writes replay SB commit speculative load finally  idealize version  optimize commit stage replay SB load replay speculative SB SB delayed reduce mechanism detect load speculative model consumption LQ SQ SB cache previous technique model CACTI technology dynamic consumption SQ SB replay applies replay  cache replay replay benefit  traditional LQ implementation LQ bottleneck remove therefore stall due LQ capacity eliminate benefit replay completely remove expensive cache replay replay policy efficient feasible load replay SB replay mechanism load execute previous unresolved address  perform replay SB load previous percentage load replay SB filter speculatively execute percentage replayed load SB splash parsec spec percentage replay increase slightly  scheme application faster load execute speculatively load replay replay replay mechanism load perform load speculative invalidation eviction filter prevent replay percentage load replay load filter replay manages filter replay percentage replayed splash parsec spec percentage replay cache therefore increase consumption replay writes extra contention introduce latency cycle replay increase  filter replay ensures data update load perform processor stall account percentage cycle processor cannot progress due rob SQ SB LQ processor stall due LQ LQ splash parsec spec replay  incur LQ stall lack LQ stall translates overall stall barnes spatial swaptions bottleneck rob SQ SB  radix canneal lbm apply commit beneficial  technique LQ implementation  rob predominant bottleneck evaluation future  sentinel SQ SB prevent perform potentially pressure SQ SB  coherence pressure SQ SB previously negligible stall percentage due SQ SB increase significantly LQ splash parsec spec  splash parsec spec although  sentinel release later  pressure SQ SB affected overall processor stall reduce LQ  splash parsec spec execution reduction percentage processor stall translates application execution extra replay replay however performance degradation splash parsec spec despite advantage LQ contrast  improves execution replay technique splash parsec spec LQ technique splash parsec spec  execution  longer considerably affect execution   IIW        UD     YJ  ERG          YJ HSOD  HSOD   HSOD HG      LS          OEP             zui   YJ HSOD  load replay SB   IIW        UD     YJ  ERG          YJ HSOD  HSOD   HSOD HG      LS          OEP             zui   YJ HSOD  load replay   IIW        UD     YJ  ERG          YJ  HSOD      LS          OEP             zui   YJ  processor stall   IIW        UD     HR  ERG          HR RUPDOL   HSOD      LS          OEP             zui   HR RUPDOL   normalize execution   IIW        UD     YJ  ERG          YJ RUPDOL   HSOD     ULWH    LS          OEP             zui   YJ RUPDOL   normalize consumption consumption dynamic consumption cache SQ SB LQ access split tag access tag cache prefetches replay  LQ queue increase replay application replay technique increase considerably despite modest replay application memory bound access cache replay frequently mostly sequential application increase finally SQ SB increase replay technique significant commit SQ SB SB  overall  improves consumption LQ SQ SB replay technique splash parsec spec LQ technique splash parsec spec  haswell splash parsec spec respectively VI conclusion contribution LQ superfluous execution memory consistency model tso concept delay buffer ensure uniprocessor load multiprocessor memory former employ novel approach burden load replay instead confine entirely buffer latter employ concept delay remote conflict buffer coherence layer achieve novel rely LQ