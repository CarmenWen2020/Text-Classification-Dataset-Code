thread performance processor improves capability entire reduce critical latency program typically conventional superscalar processor improve performance introduce oforder OoO execution register rename however increase complexity affect efficiency realizes novel computer architecture resolve dilemma feature unique instruction format source operand distance producer instruction leverage format register rename completely remove pipeline practical instruction architecture ISA novel efficient OoO microarchitecture compilation algorithm machine code ISA sequential execution semantics CPUs compiler program architecture easy conventional CPUs compiler assembler linker cycle accurate simulator developed performance moreover rtl description developed estimate reduction evaluation standard benchmark performance conventional superscalar processor issue width instruction improvement achieve rapid recovery compilation technology resolve overhead ISA reveal rtl analysis architecture reduces consumption remove rename reveal performance efficiency novel viable alternative purpose OoO processor index microprocessor instruction parallelism execution register rename computer architecture compiler efficiency introduction response trend semiconductor technology processor architecture continually evolve achieve research partially   grant research partially VLSI education  tokyo collaboration synopsys corporation mentor graphic corporation performance function efficiency currently purpose embed processor server processor heterogeneous multicore architecture adopt typically implement various various core chip efficient core application characteristic strategy efficiency utilized core reflect recent dilemma transistor increase cannot switch simultaneously scenario cpu effectively execute program parallelize cannot parallelize programmer critical execution ongoing task thread execution essential improve performance currently superscalar core inevitably accepted powerful feasible architecture gain performance OoO mechanism predictor sophisticated superscalar core exploit underlie instruction parallelism ILP thread relatively however increase performance challenge indirect operation increase core critical limited budget therefore recent improvement thread performance relatively modest gpus tlp technology demonstrate performance increase proportional increase transistor employ realizes novel OoO execution architecture reduces amount indirect operation per instruction unique instruction architecture ISA adopt skip register rename ISA guarantee logical register discard fix elaborates later render register rename unnecessary OoO execution structure scalable instruction exploit ILP annual acm international symposium microarchitecture doi micro hardware architecture executes instruction directly without rename operand architecture actually ISA however code easily translate  assignment ssa intermediate recently dominant compiler infrastructure viability compromise cycle accurate simulation environment  rtl description developed evaluation environment OoO RISC developed superscalar counterpart evaluation demonstrates improves  performance reduces consumption derive simpler hardware organization enable ISA concept ISA eliminate register rename herein however realize microarchitecture compiler architecture execute purpose program reveal essential hardware software technology contribution practical ISA built application program ISA feature source operand distance producer instruction microarchitecture receives ISA realize approach completely remove register rename OoO core hotspot critical eliminate pipeline furthermore simplify architecture achieves rapid recovery reorder buffer rob scalability compilation algorithm generates machine code llvm intermediate representation IR developed pad register RMOV instruction operand convert statically distance remainder SPADD instruction cycle accurate simulator faithfully model pipeline stage developed performance evaluation compile code standard benchmark  coremark achieves performance OoO superscalar processor simpler hardware  enhances performance restriction ISA deteriorate performance increase redundant RMOV instruction however eliminate algorithmically compiler efficiency confirm rtl analysis rtl description prepared comparative evaluation reveals remove register rename improves entire efficiency processor remainder organize II describes motivation concept architecture detail ISA microarchitecture IV compiler algorithm generate machine code evaluation setting VI evaluation vii discus related conclude II motivation advantage disadvantage register rename enhance thread performance register rename critical exploit additional ILP false dependency hazard dynamically pipeline register rename apply instruction convert operand identifier logical register physical register address internal register file operation implement multiple reference compose ram cam register mapping RMT register alias rat ram RMT logical register RMT correspond physical register logical register index mechanism circular fifo  physical register correspond logical register operation instruction RMT access source register source physical register obtain RMT access simultaneously destination register previous dedicate physical register obtain recovery retire operation physical register pipeline stage destination physical register RMT simultaneously update physical register operation code exploit parallelism however register rename report hotspot density consumption lower efficiency OoO cpu core consume RMT access essential execution instruction cycle fetch width render RMT  processor  access affect frequency unless RMT update rename fetch cannot moreover scalability instruction determines amount exploitable ILP disturbed register rename instruction directly related rob flight instruction dispatch stage retire stage queue however rob proportionally increase penalty mispredicted instruction detect RMT restore rob implementation correspond instruction penalty report cycle entry rob average considerably affect performance cam RMT avoid penalty expense amount RMT checkpoint however disturbs rob scalability cam RMT cannot increase physical register physical register sufficient rob entry stall due shortage physical register increase although register rename important contribution acceleration thread execution introduces limitation progress core performance improvement architecture concept instead manage physical register dynamically concept false dependency hazard compiler eliminates register overwrites register finite register freed fix program limited loop code without overwrites technique introduce register relatively dynamic instruction distance architecture fetch instruction directly dispatch scheduler manage mapping register file built easy however realize computer novel instruction format involves challenge unique operand format practical ISA application newly construct viability significantly  code generation nevertheless develop compiler instruction format novel challenge moreover previous concept scalability prioritize hardware register assume limit desktop sever processor hereafter realize evaluate processor resolve challenge microarchitecture conventional mobile processor increase opportunity utilized efficient processor core specify ISA developed instruction collection operation typical RISC architecture conventional OoO superscalar architecture sequential execution model precise interrupt programmer code instruction performs ordinary operation operand distance instruction source instruction code format instruction previous instruction operand previous instruction therefore code calculates fibonacci series instruction noteworthy operand distance therefore differs distance static code contains  program counter PC transition instruction concept define format instruction architecture instruction specify destination register identifier identifier source operand source operand span instruction reference decode zero register ST instruction register output distance calculation instruction occupies destination register refer return specification unique representation contains characteristic dataflow satisfies restriction correspond concept guarantee usage register register identify fetch instruction instruction destination operand identify distance lifetime register maximum distance instruction reference succeed instruction execute additional architectural register stack pointer SP  register guarantee complicate algorithm SP memory pointer instruction SPADD instruction sufficient SP related operation modifies SP immediate destination register succeed load instruction SP distance SPADD instruction described compiler SPADD utilized compile complicate function issue queue RF register file reorder buffer load data cache alu alu decoder SP RP processing scheduler memory memory instruction cache fetcher prediction fetch dispatch issue execution register decode schedule retire register pipeline organization realize scalable OoO execution pipeline organization operation instruction conventional RISC architecture pipeline compose conventional mechanism difference mechanism mechanism pipeline determines operand register retire recovery mechanism related rob detailed mechanism operand determination operation corresponds RMT access conventional OoO superscalar processor obtain physical source register source distance instruction register register pointer RP introduce hardware incremented instruction RP destination register source register obtain distance RP multiple instruction fetch parallel RP instruction rigidly regardless operation precede instruction therefore fetch width extend effective RP return zero exceeds maximum max RP mechanism related SP SP  register SPADD instruction SPADD instruction immediate operand instruction update SP decode stage subsequently SPADD instruction writes SP destination register perform OoO manner guarantee multiple  fetch cascade SPADD calculation cycle possibly affect frequency SPADD instruction fetch restrict stall performance mechanism operand determination pipeline mechanism retire recovery operation stall negligible SPADD interval per function retire recovery mechanism compose circular fifo structure rob maintains information flight instruction entry maintains architecture correspond instruction RP PC instruction SP decode sufficient entry unlike conventional architecture retire operation remove instruction rob unless instruction exception recovery reduce hardware entry rob maintain relevant RP RP correspond rob maintain derive entry addition SP rob entry redundant SP update rare maintain pointer rob significant rob capacity recovery operation misprediction speculation extremely typical superscalar architecture rob entry sufficient destination register instruction discard SP PC obtain execution misprediction recovery restart obtain rob register RP restoration rob update pointer movement operation sufficient ensure microarchitectural generate mispredicted instruction overwritten eventually restart execution although mandatory consume invalid instruction partial flush scheduler pipelined functional load queue perform correspond RP max RP physical register sufficient avoid unexpected physical register aliasing register exceeds derive max RP register unexpected overwrites instruction destination register retire register maximum distance maintain therefore correspond RP retirement instruction nevertheless flight instruction receives register rob entry max RP maximum distance rob entry improves efficiency OoO execution remove register rename moreover eliminates rob penalty enables instruction increase eliminate hotspot register rename frequency conventional OoO superscalar processor issue width functional nevertheless architecture prevent configure efficient core physical register rob maximum distance therefore core configure shrink IV compiler technology compilation compiler compiler generates assembly source register express distance explain program convert assembly correctly adopt llvm IR input compiler advantage adopt llvm IR ssa IR destination register ssa IR overwritten statically manner register management architecture distance calculate instruction producer consumer execution however merges statement statement distance compiler instruction distance fix described convention basically architecture argument return register instruction generate           instruction arrangement convention fix define function manner caller pas variable argument return convention producer argument arg prior link  instruction producer arg caller satisfy convention distance instruction callee producer argument fix regardless  instruction invoked instruction callee refers arg arg return address callee  instruction writes PC destination register register JR instruction callee refers  instruction distance realizes return operation variable argument printf via stack frame convention define manner function define return multiple define distance JR instruction producer return addi instruction JR instruction calculates  plus producer instruction cannot convention register RMOV instruction instead RMOV source register destination register alive variable stack frame SP function SP incremented decremented SPADD instruction SPADD instruction generate entrance exit function LD ST instruction access stack frame refer relevant SPADD instruction SPADD writes update SP destination register code generation operation translation compilation compilation consists              source operation translation llvm IR distance fix distance bound code compiler compilation compiler translates operation llvm IR compiler conventional architecture instruction delete operation llvm IR correspond exactly distance fix merge compiler adjusts distance consumer instruction producer instruction regardless classify branching merge distance producer instruction fix however distance merge compiler RMOVs merge fix distance basically RMOVs algorithm compiler obtains information producer correspond merge phi instruction llvm IR phi instruction operand multiple producer candidate distance varies multiple producer instruction consumer information producer merge obtain liveness analysis RMOVs merge fix distance regardless variable RMOVs stack merge producer consumer consumer BB BB BB consumer producer producer BB BB BB consumer producer producer BB BB BB RMOV RMOV distance distance already fix  eliminate distance difference although RMOVs redundant optimization described later reduce fix distance counter variable loop statement counter variable initialize BB addi incremented conditional statement BB addi SLT BB counter variable source operand operand BB BB operand  fix RMOVs distance bound architecture maximum distance source register therefore compiler RMOVs relay distance exceeds maximum RMOV maximum distance consumer avoid RMOVs compiler distance maximum optimization specific convert program code satisfies requirement architecture described furthermore addition code generation compiler optimize code aspect specific register management redundancy elimination reduces RMOVs code compile source code optimization pseudo code generates variable compilation algorithm RMOVs generate proportionally variable addi BB BB BB RMOV BB nop  addi  RMOV BB distance fix loop statement merge loop contains RMOVs instruction instruction fix distance occupy loop performance degradation however distance fix without RMOVs rearrange producer instruction addi instruction instead RMOVs within iteration instruction generate adjust distance RMOVs reduce instruction remove RMOV instruction return address  stack frame load loop completion variable loop execution therefore correspond RMOV relay variable variable stack frame reduces RMOVs relay variable loop contains RMOV instruction generally variable future effective evaluation simulated model novel architecture instruction execution pipeline confirm feasibility execute application program developed cycle accurate simulation environment compiler assembler linker cycle accurate simulator developed simulator faithfully model pipeline stage involve OoO schedule prediction memory dependency prediction load queue lsq memory disambiguation cache prediction scheduler replay prefetcher data cache mechanism misprediction recovery conventional superscalar reveal architecture improves performance efficiency cycle accurate simulator RISC  developed superscalar counterpart ram rob assume evaluation code void iota int arr int int arr arg arr arg  function iota addi zero RMOV arr RMOV RMOV  RMOV nop label cond SLT  label ST addi addi arr RMOV arr RMOV RMOV  RMOV label cond label JR arg arr arg  function iota addi zero nop label cond SLT  label ST addi arr RMOV RMOV  addi label cond label JR arg arr arg  function iota SPADD ST RMOV arr RMOV addi zero nop label cond SLT  label ST addi arr RMOV addi label cond label SPADD LD JR source code code optimization stall fetch instruction rename stage rob width frontend width pipeline conventional superscalar processor simulator code therefore superscalar model ILP technology described equalization  architecture disabled float instruction module evaluation evaluate processor model parameter module SS model clarify comparison superscalar respectively configure confirm behavior typical model cpu core desktop PCs server OoO execution fully ability model OoO core emerge mobile device maximum distance model equalize rob entry physical register SS parameter architecture optimal parameter however parameter clarify comparison described instruction performance execution cycle program compile  MODELS SS SS ISA   fetch width latency rob capacity scheduler entry entry register file lsq LD ST LD ST exec alu mul div BC mem alu mul div BC mem commit width predictor gshare global entry LI cache KiB cycle latency L1D cache KiB cycle latency cache KiB cycle latency cache MiB cycle latency memory cycle latency source code standard benchmark  coremark representative purpose integer benchmark evaluate novel processor fundamental characteristic code generate compiler llvm IR code obtain clang target mips linux gnu emit llvm option input target option architecture specific compiler exist however currently mips sufficient output intermediate code compiler benchmark binary prepared raw generate algorithm described IV IV generate redundancy elimination described IV raw comparison clang llvm generate RISC code llvm  code generate march  target riscv option cycle fix iteration benchmark program  coremark performance inverse execution cycle rtl analysis reveal improvement efficiency perform analysis register transfer rtl rtl description faithfully model OoO execution speculation recovery mechanism developed rtl description               performance comparison SS rvi involves superscalar technology simulator description code comparison difference module related stage rob organization rtl processor almost SS however function integer instruction omit confirm rtl processor execute code correctly consume code execution analyze joule rtl cadence processor recent advanced technology node assume baseline frequency comparable mobile processor frequency evaluation rtl processor synthesize relevant constraint VI evaluation performance comparison conventional superscalar performance SS relative performance normalize SS performance superscalar processor  coremark performance SS  coremark respectively overhead ISA raw coremark degrades performance baseline SS RMOV instruction compiler coremark tends alive execution               performance comparison SS  however graph overhead reduce redundancy elimination algorithm performance performance comparison SS manner relative performance degradation raw configuration model RMOV instruction behaves alu instruction impact increase RMOV instruction becomes relatively configuration however OoO core configuration comparable performance superscalar counterpart degrades performance SS  improves coremark redundant elimination algorithm effective core architecture configure pipeline width instruction predictor significant performance difference ISA characteristic eliminates register overwrites RMOV instruction LD ST instruction misprediction penalty recovery mechanism shorter pipeline former degrade performance latter improves performance impact rapid recovery graph performance SS performance misprediction penalty SS idealize zero performance coremark graph misprediction penalty significant superscalar around amount report integer program ram RMT rob configure          misprediction penalty although RMT technology reduce penalty exist increase RMT reduces penalty hardware performance efficiency improve prediction technology reduce recovery penalty reveal impact implement tage predictor component  tage simulator relative performance coremark tage instead conventional gshare predictor relative performance reduce performance baseline SS relatively improve reduce recovery penalty however performance configuration characteristic comparable performance execute instruction coremark contrast code characteristic normalize instruction SS graph instruction alu LD ST RMOV nop others graph raw code SS program increase instruction primarily RMOVs adjust distance impact naive ISA code exchange simpler hardware reduces instruction drastically impact compiler technology increase RMOVs reduce baseline SS performance evaluation performance SS issue width               performance comparison SS tage predictor SS raw   normalize SS others nop RMOV ST LD alu retire instruction increase instruction execute parallel utilize empty issue slot reserve maximum ILP sensitivity parameter source distance distribution cumulative graph distribution source operand distance retire instruction code generate uppermost distance limitation measurement actual maximum distance generate code benchmark graph distance producer instruction consumer instruction within graph almost source operand  coremark previous instruction   operand distance coremark  cumulative source distance indicates operand sufficient source distance distance limitation ISA severe unless trend reduce hardware resource physical register shrink instruction confirm simulation coremark performance degradation around maximum distance reduce reduction rtl analysis relative SS various frequency baseline baseline graph rename logic register file module normalize correspond SS baseline frequency module involves core cache bus predictor SS rename logic circuit operand determination counterpart clearly graph correspond register rename almost remove efficiency factor recent processor dissipation increase frequency reference proportion rename module analysis analyze processor proportion increase wider width configure introduce reduce recovery register file module slight increase amount register file logic increase instruction per cycle ipc rename logic register file module  normalize SS module frequency SS relative SS various frequency aspect performance improvement cancel increase reduce execution vii related WORKS thread performance intensively research various approach significance superscalar architecture achieves sophisticated OoO execution register rename schedule pipelining smart cache management various predictor complexity consumption per instruction drawback limitation optimization superscalar pipeline depth comprehensively explore around enforces researcher explore novel ILP architecture effective microarchitectures scalable ILP architecture cluster architecture representative approach issue core execution maintain critical loop regardless entire processor thread program lack parallelism fully utilize issue core speculative multithreading technology instruction core speculatively singlethreaded program multiple thread slipstream processor runahead execution drastic technology utilize helper thread training predictor cache recent heterogeneous multicore processor technology OoO performance desire chip performance improvement potential heterogeneous multicore architecture improve efficiency thread execution switch dedicate core dynamically core ISA implement chip adequate core ILP amount thread adequate configuration program instruction composite core  introduces OoO mechanism core enable rapid switch mirage core virtually increase OoO core transfer schedule instruction inorder  core register rename increase OoO core consumption affect frequency introduce critical loop pipeline proposes stage pipelined rename logic reduce frequency overhead propose rename trace cache rtc cache rename operand introduce distance representation rtc extend cache target although conventional RMT rtc approach advantage compatibility tile architecture target hardware wider execution thread performance introduce specific ISA architecture dataflow graph almost directly onto alu network hybrid approach introduce increase viability concept reduces hardware improves performance efficiency leverage compiler unlike  leverage compiler technology schedule perform hardware enables dynamic speculative ILP execution instruction format partially characteristic instruction representation dataflow architecture operand connection producer instruction consumer instruction unlike RISC architecture register essential dataflow architecture register automatically discard hardware structure temporal maintain queue structure instead structure mechanism pas variable across code becomes challenge producer consumer relation approach statically code  relative distance consumer producer operand fetch behavior fix regardless execution relative distance hybrid dataflow architecture  argument accord relative data improve inter communication contrary typical dataflow architecture producer instruction specifies destination direction inverse consumer instruction refers source execution avoid fanout broadcast mechanism scheduler RISC architecture execution model inherits PC enables exploit speculation pump instruction pipeline without actual execution approach dataflow bound instruction RP incremented data pointer contrast typical dataflow architecture hierarchical structure inter intra instruction unification architecture conclusion herein practical architecture ISA specification microarchitecture organization compiler algorithm source operand distance producer instruction ISA guarantee register discard fix characteristic enable novel microarchitecture eliminates register rename maintain flexible OoO execution compiler algorithm generates code novel ISA reveal alive variable fix regardless variation performance evaluate cycle accurate simulator consumption evaluate rtl analysis superscalar counterpart developed comparison evaluation achieves performance simpler hardware performance superscalar counterpart misprediction penalty deliver hardware superiority unique ISA possibly deteriorates performance naive compiler however reveal redundancy elimination resolve overhead performance superscalar processor configuration demonstrates suitability mobile platform rtl analysis reduces consumption remove rename therefore architecture achieves performance improvement hardware architecture novel viable alternative purpose OoO processor