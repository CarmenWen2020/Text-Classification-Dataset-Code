hotpads memory hierarchy memory java rust memory hide memory layout programmer prevents memory corruption bug enables automatic memory management hotpads extends insight memory hierarchy hide memory layout software dispense conventional address abstraction avoids associative cache instead hotpads across hierarchy directly address memory rewrite pointer avoid associative lookup hardware memory allocation unifies hierarchical garbage collection data placement hotpads improves memory performance efficiency substantially unlocks optimization index memory hierarchy cache scratchpad  manage garbage collection introduction computer cater program fortran expose memory address programmer memory unsafe operation perform arbitrary pointer arithmetic access arbitrary memory location address interface memory computer interface memory organize hierarchy preserve illusion address hierarchy rely expensive translation mechanism associative cache virtual memory fortunately java memory expose raw pointer access arbitrary memory location memory safety greatly improves programmability avoids memory corruption simplifies memory management memory safety overhead largely stem mismatch memory semantics prior sought bridge semantic gap memory architecture accelerate operation address protection sec II within conventional memory hierarchy contrast redesign memory hierarchy cater memory avoids overhead conventional hierarchy unlocks optimization insight exploit memory hide memory layout programmer programmer raw memory address pointer abstract data  dereferenced software hiding memory layout enables automatic memory management garbage collection GC hotpads novel memory hierarchy extends insight hardware sec hotpads hide memory layout dispense address abstraction hotpads ISA sec IV prevents program reading manipulate raw pointer enable hotpads hardware rewrite avoids associative cache instead hotpads hardware manage hierarchy directly address memory scratchpad pad pad contiguous allocate manage technique GC sec specifically hotpads relies feature implicit data movement data movement happens implicitly response memory access core initiate access currently pad analogous cache pad access perform pointer rewrite avoid associative lookup pad pointer beyond pad program dereferences pointer hardware automatically rewrite pointer location subsequent dereferences pointer incur associative lookup pad associative lookup non pointer whereas cache perform associative lookup access pointer rewrite associative lookup rare hierarchy allocation allocate pad  pad backing storage memory access cheaply without unified hierarchical garbage collection eviction pad trigger GC detects reclaims evicts reference  access pad collection eviction CE leverage locality principle underpins cache generational hypothesis underpins generational GCs CEs concurrently program execution hierarchical pad incur frequent CEs CE cheap hotpads manages pad entirely hardware leaf management garbage collection memory software hotpads arbitrarily pad cache chunk subobjects hotpads maintains coherence granularity standard protocol finally hotpads compatibility mode memory unsafe program minor slowdown annual acm international symposium microarchitecture doi micro evaluate hotpads detailed simulation heavily modify research java virtual machine jvm java benchmark sec VI hotpads substantially outperforms cache hierarchy sec vii operating variable instead fix cache onchip capacity efficiently pointer rewrite avoids associative lookup pad efficient cache CEs dramatically reduce GC overhead average overall hotpads improves performance reduces memory hierarchy finally hotpads slows memory unsafe program beyond gain hotpads avenue improve memory hierarchy improve security avoid cache channel isolation resource management concurrency technique sec IX technique future II background memory  redesign memory  manage rely combination static analysis runtime prevent program manipulate memory directly prevent bug buffer overflow enable garbage collection nearly introduce memory java rust although application operating project singularity OS   feature entire software stack memory therefore hotpads target memory compatibility mode legacy application sec prior focus bridging semantic gap memory architecture  reduce virtual overhead accelerate reference capability memory protection isolation typed architecture accelerate dynamic whereas prior focus core standard cache hierarchy focus redesign memory hierarchy garbage collection GC automatic memory management programmer manually memory instead automatically reclaims memory occupy  GC trace reference counting style pro con trace GC cyclic reference widely hotpads leverage principle trace GC manage memory hierarchy trace GC algorithm periodically scan heap available pointer outside manage heap static stack register variable trace GC traverse heap reachable reclaims unreachable trace algorithm non GCs collection           heap GC         heap GC generational GC contiguous avoid fragmentation contrast non GCs  data structure GC simplifies memory allocation hotpads performs GC achieve compact layout variable prior propose technique reduce GC overhead focus dimension generational concurrent GC generational GC algorithm exploit generational hypothesis empirical observation heap heap allocate heap heap GC heap heap heap GC generational GCs improve performance GC heap cheap filter greatly reduces frequency expensive GCs generational GCs improve cache locality runtimes generational GC generational GCs cache hierarchy similarity analogous empirical observation generational hypothesis locality principle adopt multilevel structure seek hotpads unifies generational GC hierarchical data placement concurrent GC algorithm reduce pause arise conventional GC program GC pause traditionally hinder adoption trace GC environment latency operation important concurrent GCs reduce pause GC phase concurrently program however overhead handle program GC thread incur pause interrupt thread  reduces throughput pause millisecond concurrent GC selectively pause detrimental collection eviction hotpads encompasses GC concurrent incurs minimal overhead negligible pause cycle sec VI hardware technique accelerate GC date lisp machine recent  accelerates reference counting reduce heap GC overhead cooperative cache scrub extends ISA scrub instruction recycle cache without incur memory traffic finally concurrent GC implementation exploit hardware transactional memory reduce overhead prior reduces GC overhead conventional cache hierarchy contrast hotpads memory hierarchy exploit principle memory hiding memory layout improve efficiency hotpads overview structure hotpads hotpads hardware manage hierarchy directly address memory scratchpad pad unlike  scratchpad hierarchy explicit data movement hotpads data movement happens implicitly response memory access hierarchy pad hotpads arbitrary       hotpads hierarchical memory multiple pad         pad organization pad internal structure pad devote data array manage circular buffer data array contiguous allocate data array bump pointer allocation fetch newly allocate allocate pad metadata pointer canonical tag array decouple tag cache later auxiliary structure feature explain sec hotpads relies novel feature implicit data movement pointer rewrite avoid associative lookup hierarchy allocation unified hierarchical GC eviction illustrates feature core pad data array pad initial core register file pointer pad memory pad solid orange relevant implicit data movement pointer rewrite core issue access pad pointer register file rewrite subsequent dereferences pointer access directly pointer rewrite applies register pad data core dereferences pointer pad core address pointer rewrite dereferences simply access data array avoid associative lookup pointer rewrite avoids associative lookup pointer detect                                    hotpads feature already rewrite pointer role canonical tag explain later hierarchy allocation core creates allocate directly pad backing storage memory pad unified hierarchical garbage collection eviction pad pad collection eviction CE similarly GC CE data array detect addition GC CE evicts non recently access pad  reference modify memory data stale access recently CE evict pad already modify eviction writeback pointer rewrite modification contrast allocate pad array GC compact contiguous simplify management CEs concurrently program execution hierarchical pad perform CE independently pad pad performs CE independently pad ensure enforce invariant sec memory IV hotpads ISA hiding memory layout hotpads treat pointer abstract data content access enable microarchitecture manipulate hotpads introduces instruction pointer operation dereference comparison allocation summarize address discipline hotpads address mode offset register pointer offset immediate displacement register index standard load instruction access non pointer data hotpads register memory access pointer address pointer arbitrary location within restriction unique hotpads  enforce facilitate pointer manipulation pointer load hotpads load variant access pointer   instruction semantics data access pointer pointer dereference hotpads dereference instruction facilitate pointer rewrite    load pointer address disp unlike   denotes program immediately intend access  enables efficient pointer rewrite data pad brings rewrite dereferenced pointer pointer pointer access  dereferenced rewrite pointer location  access conversely  program sometimes pointer wasteful pointer comparison   register source register otherwise instruction register layout hotpads ISA imposes layout within pad align implementation contains immutable creation program identify vtable pointer hotpads per metadata opaque hotpads hotpads rely identifier pointer instead relies    identify reading return illegal exception allocation finally hotpads instruction allocate alloc allocates hotpads ISA instruction format operation data load disp mem  data disp mem  pointer load  disp mem  pointer  disp mem  pointer  disp mem  dereference brings pointer equality  prp allocation alloc  alloc mem   denote register data pointer memory access offset address pointer displacement format disp  disp disp immediate instruction index variant  writes pointer code address simplicity hotpads treat code hide code address sec indirect normal address pointer integrity hotpads metadata guarantee integrity pad pointer program cannot transform non pointer data pointer pad hotpads metadata memory relies  memory safety guarantee integrity memory pointer compiler jit bug program fetch data memory corrupt illegally access pad bug avoidable automatically verify trust code alternatively hotpads memory metadata prevent bug hardware sec hotpads microarchitecture microarchitecture hotpads explain operation hotpads simplification assume limited byte data access instruction access core remove limitation sec onwards pointer format format hotpads pointer address upper metadata role introduce later embed metadata pointer simplifies operation          hotpads pointer format address hotpads address hotpads data array pad memory address align mapping simplicity KB pad MB pad GB memory mapping KB MB GB mapping trivial address per address address finally empty null pointer zero canonical invariant pad hierarchy evict successive CEs define canonical canonical memory pad canonical address address canonical pointer canonical address canonical simplicity hotpads enforces invariant invariant exists canonical canonical canonical backing hotpads canonical memory cache hierarchy unlike cache hierarchy canonical grows invariant pointer pad canonical address pointer pad memory canonical address invariant simplifies pointer rewrite sec limit rewrite valuable invariant invariant  canonical invariant enable hierarchical CEs sec pad organization sec pad consists data array canonical tag tag array per per metadata component format data array detail format hotpads manages upper rarely access metadata coherence CEs addition  canonical pointer directly allows translate  canonical pointer data array access                pad format tag array conventional associative structure allows mapping canonical address resident per address format tag entry tag array cache decouple tag array cache data array address      canonical tag entry format non canonical tag entry pad canonical address translation canonical memory canonical finally detail per per metadata associate pointer pointer associate metadata valid dirty recency eviction              pad metadata format metadata data array nearly access instead narrow array per metadata array entry data array indexed directly overall metadata overhead steady operation explain hotpads operation steady execution CE sec explains CEs perform memory access pad access request core pointer offset within access pointer canonical access proceeds invariant data pointer non canonical pad valid valid access perform directly index data array valid unset pad canonical pointer restarts access load valid parallel access dirty                 pad access wider arrow denote frequent pointer implies canonical invariant pad tag tag pad obtains address proceeds tag pad request pad receives data array tag entry performs access access beyond pad pad pad canonical pointer invariant canonical therefore access traverse canonical access proceeds entire core dereferencing pointer memory address access tag tag memory invalidation tag array suffer conflict insert canonical address translation remove another translation pad recently access invalid dirty simply core invalidation tag array entry remove multicore extend invalidation coherence sec pointer rewrite pointer rewrite perform whenever pad access non pointer access conventional load instruction address core relevant register rewrite access  instruction contains non pointer rewrite pointer rewrite pad writes pointer semantics rewrite dirty multicores perform pad sec pointer dirty although rewrite happens pad hotpads significant workload generally enjoy rate associativity overhead pad access fetch amount data entire pad perform pointer operation pointer comparison  non canonical pointer canonical pointer canonical non canonical pointer equality within core core obtains pointer canonical pointer pad canonical pointer allocation alloc instruction allocates pad implementation allocate KB KB KB KB pad pad pad mem access subobjects sec subsequent zeroed maintain CE metadata pointer CEs without software intervention pointer pad pointer identify memory pointer CEs manipulate pointer    propagate hierarchy memory memory pointer invariant memory pointer pointer ensure integrity pad pointer sec IV recency CEs evict coarse grain lru timestamps access timestamp recency pad capacity tag timestamp timestamp increase nearly perfect lru prior propose perform policy lru adapt hotpads trivial CEs perform eviction bulk adapt insight policy hotpads future collection eviction CE pad threshold  CE trigger GCs CEs traverse data array addition CE evicts non recently access pad CE seek pad capacity threshold consistently invariant sec enable hierarchical CEs pad perform CE without involve pad however pad involve pad CE CE explain pad CEs discus CEs pad within pad performs CE involves GC compact evict update pointer pointer outside pad pad pad pointer currently core register core negligible hotpads difference software GC software GCs interrupt thread unwind stack significant bias generational GC heap typically llc hotpads allocation allocate stack frame heap stack heap CEs traverse separately software GCs standard  pas reference CE  scan scan canonical  invariant marked scan pad iteratively inspects array scan scan scan promotes  scan scan scan  accelerate phase fifo scan pointer implementation fifo promote scan insert fifo empty scan dequeued fifo empty data array traverse scan compact evict scan array processing evict recency recently access capacity otherwise compact chunk bootstrapped capacity phase controller rename address return pointer data array later rename without overhead finally eviction preserve invariant evict pointer rewrite canonical pointer rewrite canonical however canonical canonical evict unless recently      eviction      eviction eviction canonical non evict update pointer finally CE traverse pointer array query rename update pointer location core pointer update rename discard concurrent operation alternate protocol CEs program execution concurrently CE pad controller flip epoch epoch embed pointer distinguish pointer pointer update apply pointer finally core access pointer compaction phase cheap data array compact sequence rename access location negligible performance impact happens phase CE dual compaction enable rename without overhead lookup cheap directly address rename pointer per data array pad capacity CE capacity rename release pointer update efficient crucial rename grows incrementally perform compaction pas allocate rename advance pad capacity accomplish rename slightly alternate processing compact compact rename immediately freed pointer update CEs pad difference involves traverse pad addition reading core pointer pad pointer perform CE sends update pointer phase pad addition core                                          dual compaction scan update pointer pad pointer perform CE request update pointer rename arbitrarily assume bound arbitrarily useful array accomplish cache subobjects access threshold SS fetch subobject SS SS byte implementation subobjects pad cache distinct address subobjects cache code generation load implicitly fetch subobject however lower efficiency pointer rewrite hotpads access subobjects byte address core issue load offset fetch subobject tag entry canonical address address    OG UG                  access canonical subobjects access subobject repeatedly register associative lookup latency avoid associative lookup introduce shadow subobject register register associate shadow subobject register shadow subobject register pointer subobject access associate register access within subobject shadow subobject register hotpads performs access pad instead associative lookup otherwise shadow subobject register overwritten subobject pointer finally KB cannot encode pointer allocate directly memory sec pointer subobjects fetch pad coherence hotpads orthogonal coherence implement MESI coherence core pad inclusive core private pad fully pad pad inclusive memory fetch allocate pad per sharer simulate core sharer vector suffices vector unused core extra vector future repurpose valid dirty encode coherence modify exclusive invalid access manipulate conventional MESI trigger action trigger upgrade request pad invalidates pad grant exclusive permission fourth private intermediate pad filter invalidation evicts  marked entry sharer vector advantage avoids false contend data core contend contend transfer coherence action core private pad pad core core issue invalidates core pointer invalid update finally core traverse pointer invalid canonical address fetch fetch downgrade core dirty writeback pad core                 VW UG  OG UG coherence hotpads coherence invalidation machinery format canonical invalidate suppose newly canonical preserve invariant invalidate canonical hotpads procedure access canonical valid canonical canonical pointer pointer canonical address invalidate handle subobjects coherence maintain subobject granularity pad extra per subobject subobject sharer canonical instruction pad instruction cache ignore instruction fetch principle hotpads improve instruction fetch efficiency rewrite address instruction pad trace cache without associative lookup approach drastic ISA jit future instead treat code fetch subobjects core conventional instruction cache access subobjects pad crosscut issue pad multicores pad achieve throughput stripe pad address across manage pad split across load balance pad evicts canonical across robin fashion empirically suffices capacity bandwidth balance canonical memory address directly determines finally pad perform CEs pointer interfacing memory implementation cache evicts memory memory bump pointer ddr impose minimum burst byte suffer  cache memory controller KB implementation retain  data thanks spatial locality cache avoids  overhead implementation garbage memory software implementation baseline jvm simply flush pad treat memory access subobjects GC thread concurrent memory GC future finally hotpads generalize manage memory technique reference counting GC future legacy code adoption hotpads memory unsafe program treat memory address mode hardware treat address offset mode hotpads somewhat cache due serial tag lookup pointer rewrite bulk eviction virtual memory VM multiple evaluate setup detailed VM future however hotpads greatly reduce VM overhead extreme OSes singularity  eliminate VM rely verify memory safety isolation conventional OS hotpads partition pad capacity private perform demand segmentation memory address translation pad II configuration simulated core core core ISA ghz     PHT issue entry IQ entry rob entry LQ entry SQ cache KB associative split cache KB private per core associative MB associative lru replacement hotpads L1D KB data array  entry KB metadata LI KB cache associative KB data array  entry KB metadata MB data array  entry KB metadata mem ddr channel per access VI experimental methodology prototype hotpads  simulation platform combine zsim pin simulator   research jvm hardware simulate core processor cache pad hierarchy parameter II core modification core model validate  encode hotpads ISA opcodes jvm emit hotpads ISA architectural register data pointer index register computer separation enable multiple optimization pointer register file instead pipeline however purpose register prototyping register pointer physical register pointer semantics pad   destination register pointer instruction reset destination register pointer exception trigger non pointer instruction attempt register pointer source operand vice versa perform CE core flush  pipeline pointer register pad CE resume execution cycle pointer rewrite perform lazily commit update physical register directly pad pointer rewrite treat writes inflight instruction pointer register destination issue logic dispatch multiple instruction pointer register core issue access canonical address load rewrite pointer impact correctness speculative execution pad fetch allocates speculatively load alloc instruction commit  detect pad simply bump pointer allocate pointer tag update lazily commit cache scrub finally implement cooperative cache scrub instruction zero scrub  cache jvm reduce memory traffic due allocation recycle java WORKLOADS  USED suite benchmark input    jython pmd  lusearch MR lusearch fix  xalan default input specjbb warehouse per thread transaction  pagerank amazon graph IV latency   latency cycle leakage cache pad cache pad cache pad model byte access byte pad software jvm cache  jvm CX jit compiler hotpads modify jit compiler hotpads ISA jvm initialization jit compiler prior simulation cache tune generational GC heap MB twice llc average performance across benchmark prior heap tune per application workload heap crash standard methodology hotpads performs concurrent CEs hardware  GC software  heap hotpads heap cache GCs software concurrent CEs hotpads concurrent GCs overhead sec II throughput efficiency pause workload java workload  suite specjbb pagerank graph processing workload  popular java graph library describes input vii evaluation latency cache pad IV report latency dynamic leakage cache pad CACTI derive extend CACTI model pad detail optimize delay parallel tag data access cache optimize minimize delay SRAM leakage transistor cache perform serial tag data access commonly methodology cache prior IV pad slightly cache overall overhead slightly leakage owe extra however access pad tag faster substantially execution breakdown normalize baseline          lusearch xalan lusearch fix  specjbb pmd pagerank average baseline scrub hotpads perfect mem app non GC GC GC execution normalize BSH BSH BSH BSH BSH BSH BSH BSH BSH lusearch xalan lusearch fix  specjbb pmd pagerank average app non GC LI mem GC dynamic memory hierarchy AMAT cycle BSH BSH BSH BSH BSH BSH BSH BSH BSH lusearch xalan lusearch fix  specjbb pmd pagerank average app non GC LI mem average memory access AMAT simulation thread workload efficient difference pad access consumes cache access IV difference IV assumes byte pad transfer cache improves efficiency hotpads outperforms traditional hierarchy analyze thread workload due constraint representative apps benchmark average apps discus trend difference across apps performance runtime scheme contribution application non GC GC overhead addition baseline scrub hotpads evaluate perfect memory memory access cycle GCs trigger  memory serf upper bound overall hotpads outperforms baseline average lusearch gain stem reduce GC overhead average baseline hotpads reduce application runtime due memory performance contrast scrub outperforms baseline scrub reduces application runtime allocates directly cache instead fetch unused memory avoids cache however scrub accelerate GC hotpads outperforms scrub focus GC overhead GCs GCs rarely hotpads CEs eliminate  overhead reduce overall GC although GC overhead GC overhead software scheme perform heap MB heap increase GC due memory traffic heap GCs frequent expensive finally perfect memory improves performance baseline hotpads bridge performance gap baseline perfect memory whereas scrub bridge gap memory hierarchy breakdown dynamic memory hierarchy hotpads reduces memory hierarchy dynamic baseline due factor instruction data dynamic data pad mostly access sec vii efficient data cache hotpads reduces memory hotpads CEs software GCs contrast scrub reduces dynamic baseline chiefly reduce memory traffic hotpads consumes scrub memory hierarchy latency breakdown average memory access AMAT hierarchy application exclude GC hotpads pad efficiency slight AMAT latency due longer latency access tag lookup extra cycle cache IV thanks pointer rewrite pad access incur penalty hotpads AMAT baseline scrub AMAT difference across apps sort apps lifetime hotpads benefit across apps lusearch xalan lusearch fix allocate chip pad hotpads memory nearly eliminates memory traffic enjoys minimal GC contrast baseline scrub incur memory traffic contention code non heap data evict heap memory apps  specjbb pmd hotpads CEs evict memory incur memory traffic although traffic baseline scrub chip finally apps pagerank data structure reside memory hotpads benefit mostly reduce GC overhead memory traffic slightly  scheme cache hierarchy enhancement hotpads cache hierarchy enhance technique DRRIP llc normalize execution BB BB BB lusearch specjbb average app GC GC execution normalize BB BB BB lusearch specjbb average LI mem GC breakdown simulation baseline DRRIP prefetchers prefetchers model  enhance baseline enhance scrub feature improve performance baseline scrub hotpads outperforms moreover prefetchers degrade memory scrub due mispredicted prefetches increase hotpads advantage enhance cache hierarchy GCs bump pointer allocation regular scan access however barely application access irregular scrub already accelerates allocation enhancement reduce application runtime scrub improve GCs hotpads feature effective conventional cache optimization moreover hotpads adapt optimization prefetching related consecutive subobjects sec IX hotpads reduces data movement across hierarchy traffic byte average across apps normalize baseline writes due load due fetch writes due eviction dirty data hotpads significant traffic beyond memory scrub saving stem hotpads feature hotpads cache improve pad utilization reduce amount data transfer per CEs quickly reduces traffic lifetime analysis canonical byte allocate evict byte evict data allocate pad therefore hotpads evict portion allocate byte memory explains drastic reduction traffic beyond normalize byte BSH BSH BSH BSH LI mem app app GC GC breakdown byte per byte normalize allocate byte LI mem allocate evict allocate evict byte per pad breakdown access pad lusearch xalan lusearch fix  specjbb pmd pagerank access canonical tag canonical tag breakdown access across pad data array utilization hotpads chip capacity efficiently cache define utilization ratio access allocate cache pad hotpads achieves utilization across benchmark baseline scrub achieve utilization difference pointer rewrite avoids associative lookup access tag tag hotpads access access pointer rewrite highly effective pad access access explains pad consume cache incur AMAT penalty pointer rewrite pad access canonical pad access however filter access access impact overall consumption CEs infrequent duration frequency CEs pad average across apps CEs active cycle pad frequent CEs CE cheap CEs frequent cheaper CEs distribution CDFs pad CE interval consecutive CEs representative apps factor CE apps pad capacity longer CEs eviction dominate CE lusearch fix CEs  data CE duration frequency across pad  pad avg CE cycle avg interval CEs cycle CEs cdf CE specjbb  fix pagerank CE cycle cdf CE interval specjbb  fix pagerank interval CEs cycle CDFs interval CEs normalize execution BSH BSH BSH BSH BSH pmd  fix  xalan avg app GC GC execution normalize BSH BSH BSH BSH BSH pmd  fix  xalan avg LI mem GC breakdown simulation multithreaded workload pad apps longer CEs pad priority demand access CE access CEs longer apps frequent pad access interval CEs depends allocation rate lusearch fix shorter inter CE interval  apps finally CDFs although variability CEs CE shortest inter CE interval CEs active hotpads performs multithreaded workload runtime breakdown multithreaded workload difference GC overhead  GC parallel address limitation  parallel GC achieve GC overhead thread due serial GCs hotpads improves performance hotpads reduces  runtime similarly thread achieves reduction baseline hotpads benefit compile code focus java workload jit overhead  code quality limit performance compile application rust nonetheless compile program benefit hotpads hotpads ISA demonstrate  benchmark garbage collection  creates traverse binary variant  manual allocates node malloc manually scope standard implementation report standard glibc malloc google tcmalloc automatic garbage collection avoid explicitly report boehm GC  GC hotpads custom fully customize memory management strategy allocates arena node allocate compactly arena  allocation scope arena deallocated node bulk currently implementation  computer benchmark simulation normalize glibc malloc tcmalloc improves default metric tcmalloc allocation routine faster reduce execution instruction tcmalloc compactly reduce memory footprint execution malloc tcmalloc boehm hotpads custom instruction malloc tcmalloc boehm hotpads custom normalize malloc tcmalloc boehm hotpads custom memory footprint malloc tcmalloc boehm hotpads custom simulation  boehm GC automatic memory management memory baseline footprint slightly tcmalloc custom achieves performance due specialized allocation strategy reduces execution instruction memory footprint finally hotpads retains simplicity GC delivers performance custom hotpads reduces execution achieves memory reduction memory footprint baseline boehm GC hotpads substantially benefit compile application compile away explicit memory management advocate smart pointer trace GC workload compile hotpads automatically future legacy mode incurs performance overhead finally hotpads legacy mode incurs modest overhead program conventional load unmodified spec cpu application legacy mode sec hotpads cache hierarchy average xalancbmk slowdown stem factor mode hotpads cache subobjects memory rewrite pointer serial tag data lookup hurt access latency hotpads performs bulk eviction data array partly unused whereas cache nearly additional related focus GC prior propose software hardware technique manual memory management memory bound pointer hotpads combine technique program program sizable memory allocation hotpads avoid adaptive granularity sector cache  improve utilization reduce traffic involve tag lookup predictor fetch data granularity hotpads avoids overhead fetch data granularity cache decouples tag data array similarly tag data array decouple pad improves associativity  tag array whereas pad organization manage data array independently gpus accelerator software manage scratchpad avoid inefficiency cache scratchpad programmer compiler manage data placement movement regular program stash seek combine benefit scratchpad cache programmer global memory onto stash access scratchpad achieve  efficiency automatically fetch data cache stash hotpads achieves cheap access however hotpads programmer explicitly data virtual memory cache conventionally associative lookup TLBs cache tag TLC D2D DM  fold cache tag information tlb reduce eliminate cache tag lookup however associative lookup tlb access introduce complexity contrast hotpads avoids associative lookup access IX future conclusion beyond specific implementation hotpads avenue aspect memory future security hotpads cache hide address effectively avoid speculation related cache channel underpin recent spectre meltdown attack secure hotpads implementation channel randomize CEs isolation hotpads reduce eliminate VM overhead sec pad capacity beyond functional isolation performance isolation cheaply cache partition considerable overhead hierarchy management hotpads leverage insight prior developed manage cache adapt recent replacement policy bulk eviction sec perform locality aware selection bypass fetch rearrange pad facilitate prefetching concurrency non volatility hotpads overwrite eviction invalidation pad  implement transactional memory accelerate nvm conclusion insight memory hiding memory layout apply efficient memory hierarchy hotpads outperforms cache hierarchy avoids associative lookup greatly reduces GC overhead hotpads future memory program