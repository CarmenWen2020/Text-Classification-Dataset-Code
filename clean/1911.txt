deployed software numerous  memory error significantly affect reliability security application crash erratic execution behavior security attack unfortunately exist cannot deployed production environment impose significant performance memory overhead detect partial error sampler library employ combination hardware sampling novel heap allocator efficiently identify memory  buffer overflow  invalid due stringent quality service qos requirement production service sampler proposes detection effectiveness performance execution inspect memory access sampler proposes performance monitoring pmu hardware sample memory access validity sample access sampler proposes novel dynamic allocator metadata lookup prevent false alarm potentially sample sample approach although reduce effectiveness execution suitable  software software generally employ individual execute randomize sample execution sample sequence memory access enable effective detection experimental demonstrate sampler detects memory bug inside application without false positive sampler imposes negligible performance overhead average sampler simultaneously satisfies efficiency  completeness accuracy transparency practical production deployment index sample pmu vulnerability detection introduction memory error buffer overflow  plague deployed software decade program crash incorrect exploit launch security attack leakage private data hijack machine impossible  memory error development phase via static analysis dynamic static analysis approach numerous false positive scalability issue although dynamic overcomes issue specific input timing susceptible schedule multithreaded program expose bug achieve insufficient imperfect environment therefore numerous memory error inevitably leak deployed environment significant memory error hidden deployed software report nvd database memory error heap overflow heap invalid occurrence  heap  unfortunately none exist dynamic employ production environment due serious shortcoming incur significant performance overhead instance valgrind introduces overhead expensive dynamic instrumentation prior memory access AddressSanitizer popular google inc employ static analysis reduce memory access imposes performance overhead memory overhead importantly AddressSanitizer detect error component thereby error non library although lightweight technique exist serious limitation  function machine equip error code ecc memory typically available server underlie operating due purpose ecc  unavoidably compromise goal ecc prevent data corruption  report possibility buffer overflow cannot inform specific location error   recent detection detect memory error overlook portion error proposes sampler simultaneously satisfies employ production environment efficiency detection overhead extremely due stringent quality service qos demand production software  report sufficient information assist programmer fix bug completeness detect error component accuracy report error extremely programmer con annual acm international symposium microarchitecture doi micro firm production error due lack runtime environment sensitive input library execution transparency detection procedure transparent normal user zero effort expertise willingness perform additional task deployed software generally utilized individual billion microsoft user execute crowdsource error detection individual execution sampler incurs minimum runtime overhead detect partial error however employ myriad execution detect memory error sampler proposes utilize sample approach reduce individual detection overhead specifically sampler leverage ubiquitous shelf performance monitoring pmu hardware trace sample memory access pmu sample non intrusive neither application explicit instrumentation unlike exist pmu hardware sample memory writes component detect error hidden component addition sample precise instruction pointer IP code reference error therefore pmu sample potential satisfy efficiency completeness  reality multiple technical challenge factor significant performance overhead pmu sample overhead prohibitively perform upon sample due overhead frequent interrupt instead sampler configures kernel collection sample buffer overcomes correctness issue integrate custom memory allocator pmu hardware generate excessive sample sample sample imply significant pressure error tackle sampler novel memory allocator information computable capability sample address inside heap sampler compute address metadata placement layout allocator accelerate computation upon operation false positive incorrect report generate sample mechanism exist detector embed metadata actual heap easily corrupt memory error buffer overflow circumstance false alarm generate avoid corruption sampler  style meaning bag allocator metadata actual challenge temporal relationship memory reference operation avoid false report incorrect sampler employ precise hardware timestamp machine coordinate actual operation custom allocator combine detection custom allocator benefit avoid memory consumption bitmap described effectiveness greatly limited sample frequency impractical significantly increase sample frequency due potential performance overhead sampler instead proposes randomly initiate sample thread across execution stable overhead randomization mechanism coordinate execution altogether without centralize mechanism detect error latent production software execution sequence memory reference detect error contribution overall contribution utilize pmu sample detect memory error sampler propose sample detect memory error leverage performance monitoring pmu hardware detect error proposes cooperate custom allocator avoid false alarm reduce detection overhead faster memory allocator  sampler novel  style memory allocator information computable capability advantage vast address machine allocator around faster standard linux allocator enables lookup metadata allocator safer linux allocator metadata actual heap however imposes around memory overhead practical transparently utilized production environment sampler dynamic library simply link application underlie OS recompilation legacy software application sampler zero manual effort user experimental sampler detects bug widely application impose negligible performance overhead average outline remainder organize II briefly discus background pmu detect memory error sampler memory allocator IV detailed implementation sampler discus effectiveness limitation sampler VI evaluates effectiveness performance overhead memory overhead sampler vii discus related concludes II overview explains background pmu sample technical challenge detect memory error pmu sample sampler proposes leverage performance monitoring pmu hardware sample memory access detect buffer overflow pmu hardware sample memory access hardware related activity currently pmu hardware ubiquitous architecture instruction sample IBS amd opteron processor precise sample  intel processor pmu hardware sample memory load precise instruction pointer stack timestamps memory address memory address utilized invalid access precise instruction pointer IP infer code information application timestamp information report temporality utilized confirm access operating pmu hardware kernel fortunately linux kernel linux user program correspond register perf obtain file descriptor return communication buffer establish user kernel mmap preset sample kernel sample buffer interrupt user program sample buffer instance sample pmu hardware sample memory access overhead effectiveness pmu sample highly depends sample frequent sample introduce overhead understand execution frequent sample reduces overhead effectiveness detection sampler detect memory error buffer overflow invalid described detect buffer overflow buffer overflow program outside boundary variable buffer overflow source security attack reliability issue detect buffer overflow exist AddressSanitizer  allocate additional redzones redzones along canary around heap redzone buffer overflow detect sampler borrows redzone sample access within redzone overflow detect report sampler organizes heap adjusts allocation redzone application request ceiling remain byte treat redzone otherwise allocation satisfied request redzone additionally sampler utilizes redzones described II instead bitmap mechanism detect dangle pointer whenever application access previously deallocated currently utilized purpose unexpected program behavior exploit breach security detect sampler borrows AddressSanitizer freed treat redzones report  increase capability detection freed quarantine cannot  future actually freed thereafter available utilized quarantine predefined threshold available slot quarantine however sampler utilizes per thread quarantine reduce contention detection buffer overflow sampler employ mechanism redzones described II detect invalid indicates freed invalid passing invalid pointer function error exploit perform security attack sampler guaranteed detect invalid accurately false positive employ custom allocator described detection without sample mechanism basically sampler embeds status information metadata detect pointer function currently refer freed mechanism delay allocation bug detect invalid sampler address belongs heap valid heap violation invalid sampler allocator information computable capability allows lookup metadata confirmation address corresponds valid heap summary sampler applies redzone sample memory error detection sampler novel custom allocator enables perform faster avoid false alarm technical challenge described multiple technical challenge along correspond address avoid corruption heap metadata therefore prevent false alarm sampler custom memory allocator metadata actual heap described reduce prevent overhead bitmap instance AddressSanitizer memory usage due bitmap sampler relies information computable capability valid address metadata sampler buffer overflow memory reference address reference beyond address valid address invalid operation report bitmap incur significant performance overhead issue address information computable capability sampler metadata lookup described crowdsource detection execution sampler sample randomly thread execution sequence memory access detect memory error described IV reduce overhead frequent interrupt sampler cumulatively analyzes sample described IV custom memory allocator sampler novel memory allocator overcome issue associate employ linux allocator unique dynamic memory management sampler approach manage exist allocator allocation request megabyte satisfied heap described otherwise treat manage scheme described management memory layout allocator illustrate allocator advantage vast address machine obtains memory underlie operating bagID objSize bagID objSize bagID objSize bagID objSize MB heap  status stack pointer metadata redzone  2G  2G sampler custom allocator partition multiple chunk chunk bag throughout remainder currently bag gigabyte adjustable option compile sampler employ  bag  style manage bag basically within bag heap  byte megabyte bag monotonically increase byte megabyte bag dedicate byte bag byte forth bag coalesce linux allocator allocation request specific cannot satisfied sampler report user bag upon restart application however gigabyte sufficiently application encounter situation exceed bag metadata actual heap prevent metadata corruption memory error buffer overflow layout actually information computable capability address within heap easily compute address metadata placement correspond address heap metadata allocator employ per thread sub heap memory allocation thread satisfied sub heap reduces false multiple thread cache simultaneously sampler acquire lock upon allocation deallocation memory blowup described allocation request satisfied thread per thread heap bump pointer conversely deallocation request insert thread corresponds allocation thread sub heap mechanism satisfy allocation request bump pointer allocate heap thread upon allocation checked typically manage  recently deallocated utilized benefit temporal locality recently deallocated typically cache available correspond allocate bump pointer increment bump pointer refer sub heap exhaust available bump pointer invalid another MB obtain correspond bag protection bag wise lock deallocation deallocation return thread related avoids unnecessary lock acquisition lock contention however generate unnecessary cache contention freed another thread thread typically load cache already unnecessary cache contention reuse thread furthermore exacerbate false comparison approach return freed owner thread thread cache experimentally confirm improves performance information computable capability error sampler allocator accelerates metadata lookup compute related information bag ID ID directly sample memory address heap layout pseudo code sampler computes sample address  bag index bagID sample access belongs compute offset within heap  fix bag  2GB bag allot monotonically increase compute objSize bag index bagID bag offset within bag   index  compute address  precomputed   objSize importantly calculate unique  allows sampler directly metadata enable memory error although sampler allocator information computable capability   bagID  objSize  bagID objSize bagID objSize  2G      2G computation related variable    bagID    bagID  objSize bagID    objSize    objSize     compute information  distinct aspect  return freed owner introduce unnecessary overhead lock acquisition lock contention sampler compute information faster address within heap instruction address faster   owner thread information sampler cannot overall sampler allocator simpler  reduces amount computation almost reduce memory blowup memory blowup memory consumption unnecessarily increase freed memory cannot reuse satisfy future memory request freed return thread subheap application producer consumer model therefore donation mechanism reduce memory blowup thread monitor freed donate partial global freed predefined threshold KB exist threshold adaptively amount deallocations twice allocation thread threshold likely donate typically thread donate freed producer consumer model confirm mechanism significantly reduce unnecessary donation avoid unnecessary migration across multiple thread management sampler manages MB another heap therefore per thread heap avoid lock contention instead thread heap avoid performance loss unnecessary cache load fault align MB instead reduce cache loading thread prefer utilize freed thread maintains deallocated thread upon allocation thread allocate whenever available status sufficient multiple contiguous coalesce satisfy request however empty available satisfy request coalesce sampler proceeds address heap mechanism fail sampler bump pointer allocate allocate MB memory maintain correspond metadata indicates valid address inside status information utilized error status information propagate coalesce MB upon allocation deallocations IV implementation DETAILS describes sampler detect memory error combination pmu sample custom allocator intercept allocation deallocations sampler intercept memory allocation deallocations  mechanism sampler redzones upon allocation detect buffer overflow  detects invalid upon deallocations II described II redzones contiguous detect buffer underflows overflow sampler flexible redzones interact custom allocator aligns allocation dedicates remainder byte beyond request redzones allocation already align  allocate install memory request redzones deallocation freed quarantine marked redzones entire render inaccessible detect redzones sampler utilizes mechanism bitmap mechanism bitmap redzones marked explicitly upon allocation impose unnecessary memory performance overhead however exist  perf   perf ast   mmap null  prot prot SHARED   mmap null  prot prot SHARED       async ioctl  perf IOC output     EX owner    EX owner         initialization pmu driver thread cannot avoid bitmap physically sample memory address impossible address access sample sampler maintain bitmap sampler compute address valid address metadata procedure obviates update bitmap upon allocation access beyond valid address buffer overflow detect  valid address address treat memory reference sample memory access program execution pmu hardware sample user retire load sample analyze identify buffer overflow  pmu configuration sample mechanism described sampler randomly sample thread execution sample avoid sequence sample memory access sampler capture sequence memory access within thread execution detect error initialize pmu driver sampler utilizes perf pmu hardware illustrate currently sampler evaluate intel skylake architecture load multiple thread perform initialization flag perf guarantee thread core avoid thread migration avoid unnecessary interference thread thread handle signal  achieve invoke   EX flag load initialize separately invoke perf  dumped buffer simplifies handle however differentiate status sample  file descriptor load perf initialize ioctl invoked perf IOC output fourth mmap generate buffer auxiliary buffer kernel user application sample obtain reading buffer initialization precise attribute maximum instruction pointer skid instruction  IP cpu attache timestamp raw sample TSC counter temporal relationship reference correspond operation reduce sample related overhead sampler multiple approach reduce sample overhead borrows  reduce unnecessary format translation kernel user currently pmu hardware automatically sample  buffer debug DS typically KB linux DS nearly interrupt kernel additional information sample sample generate sample format perf user kernel allows user perf analyze however procedure involves unnecessary format translate raw  perf unnecessary DS buffer   driver avoids overhead raw  aux buffer eliminates additional DS buffer finally kernel sends  signal poll  flag inform user application obtain sample reading buffer aux buffer KB  swap however mechanism increase complexity unnecessarily unstable sampler modifies mechanism KB sampler analyzes sample online without disk typically disk incur prohibitive performance overhead file operation described online analysis improves convenience due avoid unnecessary offline analysis furthermore security standpoint online analysis essential enable timely attack detection sampler reduces interrupt kernel notify user application aux buffer nearly delay memory reference challenge guarantee correctness report described IV memory sample avoid significant performance overhead frequent interrupt sampler  memory sample aux buffer kernel notifies  signal sampler poll sample quarantine capacity sampler sample upon normal abnormal exit application signal handler sample aux buffer buffer sample memory reference within heap handler address timestamp access load confirm reference buffer overflow error detection memory error described IV afterward ioctl invoked perf IOC refresh resume sample redzone reference redzone potential false positive naive  polling invoked quarantine thread becomes thread becomes coordinator thread described II quarantine freed utilized quickly reference freed marked redzones error quarantine freed actually freed newly freed coordinator thread notifies thread execution poll exist sample simultaneously otherwise false alarm generate freed  allocate valid reference report buffer overflow sample reference reallocation avoid issue related sampler introduces barrier guarantee thread proceed normal execution thread reading sample sampler analyzes sample program quits normal abnormal exit sampler register function normal exit invoke  api explicitly routine sampler register signal handler abnormal exit  signal exit program error sampler stack fault sampler performs error detection reading sample polling detect memory error sample memory access sampler access buffer overflow error normal access due volume sample access per error efficiently sampler mechanism accelerate procedure custom allocator information computable capability address metadata information compute quickly therefore additional bitmap placement redzones avoid load additional cache sampler valid address metadata comparison validity reference address valid address valid confirmation reference valid reference otherwise error freed invalid reference buffer overflow sampler guarantee exist sample analyze therefore generates false positive illustrate freed confirm error sampler timestamp reference correspond operation pmu hardware attache TSC timestamp sampler timestamp operation metadata freed quarantine therefore timestamps reference operation however multiple potential issue version hardware ivy bridge cannot attach timestamps perform kernel interrupt transform generate false positive reference later timestamp fortunately newer version hardware skylake attach TSC timestamp sample allows utilize timestamp reliably identify correctly core TSC timestamps however difference core invariant hardware invariant TSC therefore sampler evaluates difference beforehand utilizes reasonable threshold around reference occurs within threshold conceptually sampler immediate operation however rarely operation thread closely within thread suffer issue furthermore generally multiple access error reporting memory error currently sampler simply report error screen future report developer via email obtain user approval sampler report stack memory allocation deallocation precise instruction error buffer overflow sampler report stack correspond memory allocation statement actual overflow similarly sampler report stack detect invalid multithreaded application multithreaded program sampler intercept pthread function assign heap thread initialize per thread data structure sample mechanism utilize custom function task thread creation custom function actually invokes thread function allows sampler capture exit thread inside sampler internal thread index utilized thread fetch per thread data quickly memory allocation sampler obtain index thread allocate return per thread heap upon interrupt sampler index placement thread correspond buffer acquire internal thread index naively rely thread local storage declare keyword thread however naive involve external library lookup indexed instead sampler borrows exist circumvent TLS variable sampler assigns stack newly thread upon thread creation stack thread thread allot contiguously offset thread stack thread index stack  compute thread index offset stack variable address global stack stack DISCUSSIONS detection effectiveness sampler proposes sample mechanism detect heap overflow guaranteed detect invalid due allocator heap overflow detection effectiveness proportional sample rate instance sample sampler sample rate therefore sampler detect heap overflow probability reality buffer overflow incur multiple reference explains sampler probability detect error evaluate VI limitation sampler limitation sampler handle buffer overflow stack global variable sampler code redzones variable perform AddressSanitizer sampler cannot detect occurrence memory error execution due sample sampler compromise detection effectiveness trading overhead capable deployment production software however sampler detect bug reasonable execution VI evaluation aim effectiveness sampler detect memory error application performance overhead performance overhead sampler sampler allocator perform separately memory overhead memory overhead sampler attribute allocator experimental setup perform core quiescent machine intel core cpu processor 0GHz skylake model machine 6GB memory KB KB MB cache separately perform linux patch   driver gcc fno omit frame pointer flag compile application AddressSanitizer compile clang built detection heap overflow  bug comparison effectiveness perform effectiveness evaluation bug php gzip  libtiff bzip php interpreter  input file code error evaluate bug invalid  buffer overflow due sample significantly affect effectiveness evaluate setting indicates sample inversely proportional sample rate instance sample pmu hardware sample access instruction therefore actually sample rate sample rate II specify bug detect execution multiple sampler detect invalid regardless sample due sampler custom allocator sample rate typically implies effectiveness detect buffer overflow typically detection rate sample rate sample reasonable overhead evaluate VI reasonable effectiveness default sample false negative combine execution sample sample macro user easily compile sample sampler detects average buffer overflow sampler detection rate average user performance overhead sampler sample boost average detection rate  buffer overflow respectively confirm detection rate sample rate due bug redzones multiple detection II correspond bug detect default sample bug around execution detect bug inside around execution detect buffer overflow sampler utilize execution detect bug due randomization mechanism probability analysis formulate detection probability bug detection bernoulli trial outcome failure probability successful detection fix execution independent sample invalid access execution probability successful detection therefore predict bernoulli trial obtain probability obtain detection trial compute equation probability obtain false negative execution probability examine bug invalid access parameter around detection execution actual detection gzip bug invalid access therefore probability approximately detection execution successful trial finally predict detection indicates sampler sample rate throttle underlie OS enables reliable performance sample rate examine bug bzip invalid access sample probability obtain false negative execution similarly probability respectively therefore sampler detect memory error combine sufficient execution performance overhead evaluate performance sampler parsec multithreaded benchmark suite application  memcached mysql pbzip pfscan sqlite performance overhead ASan sampler perf average execution sampler perf sample normalize runtime runtime normalize default linux library therefore indicates performance ASan detect memory error memory access detection perf utility simply memory reference pmu mechanism without detect error naively perf employ detection default linux library sampler imposes around performance overhead average utilize default sample contrast ASan average overhead indicates inapplicable usage deployment motivation sampler perf imposes performance overhead indicates naive mechanism employ pmu detection sufficient sampler custom memory allocator mechanism sample data mechanism reduce translation kernel user borrow  reduce performance overhead sampler imposes overhead application application canneal memory allocation exceed therefore obtain stack allocation deallocations significant source increase overhead overhead raytrace swaptions similarly attribute sampler actually achieves performance speedup bodytrack zero overhead others facesim streamcluster speedup sampler custom memory allocator SA allocator series evaluate sampler allocator exclude detection logic quarantine sample collection stack allocation deallocations sampler allocator actually faster linux allocator understand multiple factor contribute excellent performance sampler allocator generally avoids lock allocation deallocations metadata actual heap improves cache utilization quantity cache frequently access data metadata access frequent impact sample rate effectiveness evaluation evaluate performance overhead sampler setting performance sample average overhead around overhead sample therefore user sample rate performance budget typically frequent sample indicates overhead effectiveness II memory overhead memory overhead sampler evaluate application performance evaluation default sample understand sample rate significantly affect memory overhead evaluation sample memory consumption via linux utility server application terminate implement script periodically obtain proc pid status file display maximum resident RSS throughout lifetime memory overhead sampler imposes around memory overhead sampler allocator imposes memory overhead default linux allocator ofthe ASan imposes memory overhead application indicates sampler memory overhead acceptable sampler percentage startup memory overhead footprint application swaptions however application footprint memory overhead typically reasonable adjustable quarantine configuration parameter linux allocator sampler allocator utilizes additional memory pointer allocates alignment overhead sampler around memory overhead per thread quarantine allocator metadata contribute sampler memory overhead quarantine customizable actual overhead detection application bug detection php cve php cve php cve php cve php cve php cve buffer overflow  bzip buffer overflow  gzip buffer overflow  libtiff buffer overflow cve  buffer overflow  invalid cve average II detection effectiveness RESULTS sampler USING  sampler  false  USING  hardware assistance custom allocator detection indicates execution sampler USING detects bug  bodytrack canneal dedup facesim ferret  freqmine raytrace  swaptions vip   mysql pbzip pfscan sqlite average normalize runtime ASan default SA allocator sampler perf dummy performance overhead AddressSanitizer ASan sampler allocator SA allocator sampler perf default linux library default configuration easily tunable achieve optimal default sampler utilizes MB quarantine vii related detect memory error focus dynamic classify dynamic instrumentation numerous dynamic instrumentation valgrind  memory  intel inspector discover although dynamic instrumentation obvious advantage recompilation modification program however serious shortcoming prevent adoption production software typically performance overhead instance valgrind memory introduces around runtime overhead normal user expertise compiler analysis instrumentation utilize compiler perform static analysis correspondingly reduce overhead approach AddressSanitizer imposes around performance overhead however overhead employ production environment delta pointer detects contiguous non contiguous overflow carefully manipulate pointer arithmetic operation however cannot detect error code instrumentation  multiple prior approach mixture library  virtual memory technique detect memory error   employ evidence approach detect heap overflow  surpasses  multithreaded application  bodytrack canneal dedup facesim ferret  freqmine raytrace  swaptions vip   mysql pbzip pfscan sqlite average normalize runtime sampler sampler sampler dummy performance overhead sampler utilize series increase sample memory overhead MB application ASan linux SA alloc sampler blackscholes bodytrack canneal dedup facesim ferret fluidanimate freqmine raytrace streamcluster swaptions vip  memcached mysql pbzip pfscan sqlite memory overhead MB APPLICATIONS USING  default linux  sampler allocator sampler sampling implant canary execution evidence upon epoch detect memory error identical execution evidence memory error discover impose around overhead program without memory error however detect failure cannot multithreaded program hoc synchronization sampler detects error overhead application without issue protection leverage protection mechanism achieve memory safety expense increase tlb pressure performance overhead efficient oscar optimizes virtual management imposes performance overhead temporal memory safety contrast sampler broader spectrum memory error sample detection exist approach utilize sample technique detect software bug memory leak however none focus memory error sampler conclusion proposes pmu sample detect buffer overflow error validate memory reference exist sampler utilizes novel custom allocator avoid false alarm improve performance evaluation sampler imposes performance overhead detect bug within reasonable execution sampler simultaneously satisfies efficiency precision completeness accuracy transparency candidate production