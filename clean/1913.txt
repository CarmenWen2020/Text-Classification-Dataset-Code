iDO compiler approach failure atomicity nonvolatile memory unlike prior persistent data redo undo iDO compiler identifies idempotent instruction sequence execution guaranteed  thereby eliminate persistent extension prior JUSTDO compiler arranges recovery failure thread idempotent execute failure atomic extension transforms JUSTDO technique hypothetical future machine nonvolatile cache technique significantly outperforms lock persistence mechanism hardware normal execution preserve recovery introduction emergence byte addressable nonvolatile memory commercial 3D xpoint ReRAM  conceive memory access ordinary load simply available flush file survive crash obvious technology focus programmer heap persistently memory bypassing expensive serialization onto traditional storage device widely applicable envision application persistent heap alternative disk resident local database harvest device frequent crash enable restarts unfortunately perspective crash recovery nonvolatile memory compromise traditional cache data memory arbitrary inconsistent wake crash failure link insertion crash dangle reference pointer predecessor node memory insert node moreover absence reorder failure operation atomic content memory inconsistent intermediate render unusable avoid error ensure crash consistency persistent data researcher developed  programmer delineate failureatomic operation persistent data typically transaction failure atomic FASEs outermost lock knowledge operation failure atomicity ensure via approach operation within code atomically respect failure maintain consistency persistent data transaction potential advantage respect program potentially performance normal operation comparison coarse grain lock retrofit exist code due idiom lock limitation synchronization irreversible operation transaction tend perform poorly tune grain lock lock principal challenge FASE recovery transactional recovery stem lack isolation critical lock program FASEs involve lock data progress execution synchronization undo update avoids hiding FASE update address possibility FASE FASE interrupt crash atlas incorporate undo therefore FASE dependence prepared FASEs crash recovery arises redo FASEs  incomplete FASE release lock locally buffer thread subsequently acquires lock dependence earlier FASE fails dependent fail implies thread dependent FASE normal execution earlier FASE replay proceed simplify management FASE persistence avoid dependence annual acm international symposium microarchitecture doi micro introduce notion JUSTDO FASE recovery undo replay FASE writes redo JUSTDO information resume FASE recovery execute completion recovery via resumption immediately prior instruction FASE JUSTDO persistent memory program counter update address recovery code crashed program remainder interrupt FASE recent entry future program assure recover data consistent conventional program ensure integrity data  file JUSTDO requirement persistent related requirement expensive fulfill conventional machine volatile cache ISAs limited cache persistent memory limitation likely foreseeable future ensure writes memory program typically employ sequence instruction refer persist fence intel sequence sfence clwb clwb sfence sequence initiate cache ensure persistent future writes unfortunately incurs communication memory controller persistence JUSTDO assumes unlike atlas  machine cache persistent due implementation stt  capacitor driven flush failure conventional machine persist fence JUSTDO atlas JUSTDO imposes restrict program model within FASEs volatile data cache register restriction preclude simd instruction widely regard essential data intensive application memory database contribution demonstrate recovery via resumption efficient conventional machine volatile cache expensive persist fence operation persist fence multiple instruction application achieve coverage via compiler identification idempotent instruction sequence idempotent code safely execute arbitrary without output recovery procedure wake crash resume execution eliminate individual instruction program iDO practical compiler failure atomicity JUSTDO iDO grain concurrency lock FASEs avoids dependence execute FASE crash recovery unlike JUSTDO iDO allows register FASEs persists coarser granularity advantage iDO outperform prior hypothetical machine nonvolatile cache confirm outperform substantial margin conventional machine volatile cache instead information instruction iDO persists slightly amount program register stack variable program counter idempotent code within overall FASE idempotent sequence tend significantly longer span consecutive instruction benchmark instruction application iDO implement llvm chain implementation implement variety important optimization significantly information pack cache naively introduce implementation FASE boundary lock memory fence employ JUSTDO principal contribution summarize introduce iDO lightweight strategy leverage idempotence ensure atomicity FASEs consistency persistent memory wake crash individual memory iDO lightweight summary program idempotent performance iDO exist demonstrate magnitude improvement atlas transactional mnemosyne verify recovery iDO magnitude faster atlas  program organize II additional background failure atomicity idempotence discus iDO IV  detail performance discus related VI conclude vii II background model iDO assumes hybrid architecture memory replace nonvolatile memory memory cache processor register remain volatile data core cache therefore transient lose failure portion memory likely refer physical memory volatile nonvolatile program memory data transient persistent hybrid architecture model portion memory nonvolatile core cache dram volatile FASE nest lock mutex lock lock mutex lock lock mutex unlock lock mutex unlock lock FASE lock mutex lock lock mutex lock lock mutex unlock lock mutex unlock lock FASEs interleave lock implement dram due density endurance issue nvm technology recent assume latency nvm dram writes atomic byte granularity failure model encompasses fail error arise outside application kernel panic outage various hardware failure program model iDO employ program model lock delineate failure atomic FASEs primarily ubiquity exist code FASE define maximal code lock mutex acquire operation lock release lock outermost lock unlock necessarily FASEs interleave lock nest lock lock  lock FASE iDO variant classic acid transaction atomicity update persistent data perform FASE manner FASE interrupt crash recovery procedure consistency typically define program semantics assume FASE transition memory program invariant another interrupt FASE recovery preserve consistency presence failure persistent data lock isolation transaction thread execution likewise invisible commit FASE program model isolation consequence mutual exclusion properly nest FASEs outermost lock durability persistence FASEs survive crash specifically FASE visible survives crash survives thread program code access  variable iDO programmer delineate durable code code define programmer failure atomic lack isolation guarantee lock delineate FASEs FASE denote lock  failure atomic code FASE failure atomicity undo redo typically prohibit thread communication outside critical  prevents happens dependence critical without knowledge advantage gain recovery via resumption thread communication outside critical without compromise correctness despite strength recovery via resumption pitfall recovery succeed failure atomic code completion resumption infeasible speculative transaction abort update conflict detect execution possibly recovery consequently iDO vulnerable software bug within FASEs recovery  buggy code restore consistency assume program model writes persistent location within  programmer delineate FASEs model ensures program crash corresponds across align lock release durable code thread FASE disallow conventional data within FASEs atomic variable avoid possibility resolve invert recovery persistent outside FASEs idempotence idempotent entry possibly  subgraph graph program standard terminology input refer variable input definition entry definition within similarly output refer variable update output variable serf input  refer dependence variable subsequently overwritten idempotent generate output entry execution within assume isolation thread enable input overwritten  input execution idempotent variety purpose literature recovery exception fail speculation various hardware fault purpose iDO input preserve enable execution  failure atomicity unlike undo redo iDO failure atomicity via resumption individual memory thread enters FASE iDO ensure completes FASE presence failure idempotent code FASE input persistent memory idempotent thread overwrites input consequently crash interrupt execution idempotent iDO execute idempotent persistent input precisely compiler delineate idempotent iDO output data data modify input data define output data define downward expose     define  iDO compiler persists  successful recovery additional execute FASE recovery thread thread lock crashed thread information responsibility thread local lock array sec update lock acquisition release subsection structure iDO implementation FASE boundary lock recovery procedure additional compiler detail identify FASEs transform FASEs series idempotent defer IV iDO thread iDO runtime creates structure iDO manage per thread iDO global link iDO persistent iDO structure management iDO thread memory location recovery procedure sec IV structure thread creation iDO structure comprises recovery initial instruction idempotent   register register fix location array lock array indirect lock address mutexes thread series within FASE execution idempotent execution issue instruction output register   output stack comprise  already persist additional action update recovery execute recover failure execution execute code generate  persist boundary successor described definition idempotent overwrite input iDO fashion FASE enforce iDO compiler insert persist fence thread idempotent output register   immediately modification writes output stack likewise initiate immediately completion fence absence precise pointer analysis cannot identify writes variable access via pointer therefore tracked idempotent recovery wake crash described indirect lock discussion mostly idempotent obtain failure atomicity entire FASEs introduce lock recovery wake crash reassign lock crash recovery thread ensure lock execute interrupt FASEs guarantee lock accidentally lock previous program execution deadlock previous approach persist mutex recovery unlock mutex release fail thread assign recovery thread JUSTDO task update lock intention lock ownership lock operation lock unlock operation entail persist fence sequence significant expense iDO introduces novel approach avoids mutexes persistent insight mutexes unlocked failure really therefore minimize persistence overhead introduce indirect lock holder lock lock holder resides persistent memory immutable address transient lock normal execution immediately acquire lock thread address lock holder lock array entry iDO initial index slot array array slot immediately release lock thread lock array entry finally iDO compiler insert idempotent boundary immediately lock acquire lock release upon failure transient mutex lose recovery procedure however allocate transient lock indirect lock holder recovery thread acquire lock identify lock holder lock array scheme JUSTDO thread acquires lock indirect lock holder crash another thread steal lock recovery harmless boundary lock acquire ensure  thread fail execute instruction lock iDO recovery building precede subsection summarize entire recovery procedure restart iDO detects crash retrieves iDO link iDO initializes creates recovery thread entry recovery thread  lock lock array executes barrier respect thread recovery thread restores register stack pointer iDO interrupt idempotent thread executes FASE thread lock recovery recovery terminate emphasize failure atomicity iDO implement checkpointing execute program restart execution beyond interrupt FASEs crashed program persistent data consistent recovery fully application specific IV implementation DETAILS compiler implementation overview iDO compiler built llvm generate llvm IR input performs phase instrumentation generates executable discus phase FASE inference lock ownership preservation instrumentation phase iDO compiler infers FASE boundary lock code lock unlock operation iDO library assumption FASE confine function technical specification transaction prefer production quality extension FASE boundary program source identify function function pointer within FASE idempotent formation instrumentation phase iDO compiler identifies idempotent previous idempotence recovery scheme developed partition algorithm guarantee absence memory  preservation variable specific scheme developed iDO compiler computes  memory access llvm  alias analysis applies algorithm strategy report characteristic preserve input persist output instrumentation phase iDO compiler performs analysis guarantee input idempotent overwritten execution register artificially extend interval register thereby prevent register allocator assign interval register reintroduce  stack variable perform interval extension prevent llvm stack phase related analysis iDO compiler ensures output idempotent persist register previous already persist register multiple FASE inference lock ownership  idempotent  register  llvm IR variable  code  phase executable iDO compiler overview llvm IR  clang compiler performs iDO phase bold generates executable entry persist idempotent similarly writes output stack initiate idempotent writes variable access via pointer heap tracked persist coalesce optimization iDO compiler advantage register persist atlas byte information persist contiguous entry byte cache iDO register persist clflush persist coalesce iDO register grouped update register later program update register persist persistent iDO mechanism enable allocate persistent memory visible program leverage atlas implementation purpose atlas manager persistent memory file incorporate address via mmap mapped memory allocation malloc  evaluation evaluation iDO alternative failure atomicity runtimes employ realworld application explore iDO performance impact normal crash execution employ microbenchmarks scalability benchmark report statistic idempotent understand performance separately recovery finally ass sensitivity nvm latency applicable failure atomic runtimes guarantee crash consistency persistent memory machine atlas undo lock synchronization iDO atlas equates failureatomic outermost critical undo allows atlas delay FASE  undo FASE lack isolation combine rollback recovery model atlas dependence across critical prepared FASE depends FASE fail crash mnemosyne redo transactional integrate transaction update version recently publish whisper benchmark suite fix bug accidentally introduce version specifically remove trace instr JUSTDO recovery via resumption originally machine persistent cache recovery information unlike version JUSTDO implementation adopts iDO strategy program stack nonvolatile memory significant performance improvement avoid manually stack variable heap FASE initialization nvml intel undo information persistent persistence synchronization programmer delineate FASEs library nvml programmer annotate persistent access FASE  redo lock operates granularity OS protection critical maintain dirty release upon lock release origin indicates uninstrumented  code performance baseline atlas iDO JUSTDO llvm mnemosyne gcc due reliance transaction feature implement llvm runtimes FASEs mnemosyne transactional treat critical global lock speculative implementation otherwise idle machine amd opteron processor singlethreaded core hardware thread core access private cache MB per core cache MB across core processor machine centos absence actual nonvolatile DIMMs persistent server thread throughput ops insertion intensive insertion origin mnemosyne atlas JUSTDO  server thread throughput ops intensive insertion origin mnemosyne atlas JUSTDO  memcached throughput data structure operation per function thread med throughput ops sec origin atlas JUSTDO nvml  redis throughput database data structure ordinary memory dram assume clflush instruction sfence roughly approximate overhead persistence machine intel adr chip memory controller persistence domain explore sensitivity assumption performance overhead understand iDO performance benchmark integrate along failure atomicity library memcached redis production quality memcached typically cache query variety commercial enterprise facebook wikipedia flickr active development advantage mnemosyne already integrate version software whisper benchmark integrate iDO atlas JUSTDO lock code memcached server client amd opteron server methodology maximize throughput  client generate memcached request accord desire distribution client thread generate request uniformly distribute byte byte  accompanies memcached whisper suite ycsb mnemosyne crashed workload client thread workload insertion intensive insertion intensive insertion throughput iDO outperforms FASE competitor factor peak iDO throughput code impose significant arguably tolerable overhead return persistence crash consistency notably none manages particularly version thread version memcached notorious exhibit due coarse grain lock synchronization framework rework coarse grain lock memcached mnemosyne enjoys performance iDO scalability transactional sec iDO outperform mnemosyne later version memcached redis variety data structure unlike memcached redis thread rely  FASEs outermost lock delineate failure atomic memcached advantage redis already adapt persistent memory nvml building prior integrate iDO JUSTDO atlas code server client amd opteron machine redis lru client client query server distribution fix iDO outperforms exist persistence redis significant margin overhead relative crash vulnerable code redis FASEs relatively persistent writes iDO significant advantage idempotent notably database grows performance difference iDO uninstrumented code shrink occurs benchmark spends database iDO imposes minimal idempotent performance undo atlas nvml undo nvml neither compiler integration synchronization programmer manually annotate persistent FASE insert synchronization atlas achieves substantially multithreaded code compiler detection persistent access automatic FASE dependence additional feature atlas become performance overhead thread benchmark redis scalability scalability data structure microbenchmarks evaluation JUSTDO microbenchmarks perform access data structure across thread data structure implement stack lock variation  stack queue lock version queue sort traverse lock implementation allows concurrent access within thread cannot pas another fix hash implementation bucket obviate  lock data structure parallelism stack serializes access critical extreme hash allows concurrent access across within bucket parallelism data structure poorly worker thread whereas parallelism data structure exhibit nearly linear performance conservative maximum  throughput structure code data structure overall bottleneck thread fix interval overhead hardware timer operation aggregate duration microbenchmark execution thread repeatedly chooses random operation execute structure evaluation queue stack thread randomly insert remove hash thread randomly random within fix thread pin core consistent entirely core processor thread synchronize data structure variable within data structure appropriately pad avoid false generate random thread thread local generator avoid contention smooth performance curve  prevent fault performance microbenchmarks without persistence elide clarity scalability memcached redis iDO outperforms  scheme configuration thread iDO  distribution memcached redis stack queue hash register  distribution memcached redis stack queue hash benchmark characteristic cumulative distribution register per dynamic mnemosyne perfect speedup hash demonstrates absolute lack synchronization thread iDO runtime thread synchronization handle lock program contrast atlas mnemosyne quickly saturate runtime synchronization throttle performance mnemosyne performs application inherent concurrency worker thread iDO atlas writes persistent memory lock acquisition release lock ownership per thread execution relative mnemosyne employ speculative implementation conversely iDO atlas lock mnemosyne transactional api idiom entire traversal transaction data persistent memory iDO atlas extract concurrency benchmark  execution mnemosyne consequently thread iDO outperforms mnemosyne due extract parallelism despite thread performance characteristic understand performance difference intel pin statistic idempotent application microbenchmarks upper display cumulative dynamic distribution per idempotent indicates saving operation relative redo undo JUSTDO microbenchmarks zero spends thread throughput ops stack  mnemosyne atlas JUSTDO  thread throughput ops queue  mnemosyne atlas JUSTDO  thread throughput ops  mnemosyne atlas JUSTDO  thread throughput ops hash  mnemosyne atlas JUSTDO  throughput data structure operation per function thread lock data update allows mnemosyne avoids lock operation outperform scheme microbenchmark moderate thread iDO outperforms JUSTDO substantial margin largely indirect lock mechanism realistic application roughly memcached redis multiple iDO consolidate operation throughput thread average improve alias analysis compiler currently rely llvm  algorithm conservative display cumulative dynamic distribution register per idempotent significantly dynamic benchmark register typical operation cache flush register input recovery overhead evaluate correctness recovery microbenchmarks interrupt application external  signal application recovery iDO recovery procedure summarize iDO initialize recovery thread iDO recovers variable interrupt entry interrupt execution stack queue  hashmap recovery ratio atlas iDO FASE interestingly recovery iDO thread FASEs benchmark generally microsecond overhead iDO recovery mapping persistent virtual address recovery thread essentially constant overhead contrast atlas recovery traverse compute global consistent happens undo interrupt FASEs ratio recovery atlas iDO application crash atlas quickly traverse compute consistent iDO overhead initialize recovery thread however application longer atlas traverse compute consistent faster recovery iDO throughput ops sec memcached atlas JUSTDO  throughput ops sec redis atlas JUSTDO  sensitivity nvm latency sensitivity nvm latency rely sfence instruction capture previous writes  chip memory controller machine implement controller stt  instead capacitor SRAM others handshake across memory bus memcached redis additional delay emulate nonvolatile writes typically expensive traverse data mnemosyne insert configurable delay loop  non cacheable nonvolatile memory clflush cacheable memory leveraged capability atlas delay memcached  server insertion intensive data redis  data iDO atlas maintain performance delay around beyond significant slowdown occurs JUSTDO contrast significant slowdown relative additional delay attribute difference relatively frequent JUSTDO relative atlas iDO preliminary endorsement intel adr asynchronous dram refresh fail suggestion reasonable appropriate runtime replace  SRAM physically nonvolatile memory adr memory controller VI related nonvolatile memory impend dram device technology compete inexpensive dense nonvolatile storage become dominant memory technology candidate pcm  spin transfer torque magnetic memory stt  building technology researcher attempt maximize density endurance economy various compromise across variable microarchitecture architect programmer grain timing writes volatile cache nonvolatile memory semantics surround comprise memory persistency model analogous traditional memory consistency exist processor rough intel clflush  future thread local ordering buffering reduce penalty writes persistence various scheme hardware epoch persistence buffer epoch persistence explicit epoch persistence  HOPS intel release ISA extension persistency model clwb  instruction persistency model research built performance software persistent application project concurrent data structure transactional file database contrast performance specialized application iDO member address library compiler enable programmer easily crash resistant code II summarizes difference mnemosyne NV heap  nvml extend transactional memory durability guarantee nonvolatile memory mnemosyne emphasizes performance redo postpones flush data persistence transaction commits  redo shadow intel deprecate  instruction batch update dram nvm NV heap undo emphasizes programmer convenience garbage collection avoid pitfall unique persistence pointer transient data inadvertently persistent memory nvml intel persistent memory transaction undo persistent implement highly optimize procedure bypass transactional function failure atomic iDO lock synchronization delineate failure atomic outermost critical II failure atomic failure atomic semantics recovery granularity dependency transient cache iDO lock infer FASE resumption idempotent atlas lock infer FASE undo mnemosyne transaction redo  lock infer FASE redo JUSTDO lock infer FASE resumption  transaction undo nvml programmer delineate undo  programmer delineate redo contiguous data extension explore compose operation concurrent persistent data structure failure atomic thereby eliminate finegrained within persistent data structure data structure detectable execution  allows undo JUSTDO optimize composition analogous boost software transactional memory optimization iDO specialized persistent application runtimes nonvolatile memory analogue traditional failure atomic disk flash borrow technique literature disk database traditionally ahead ensure consistent recoverability transactional file update explore research prototype commercial implementation user implementation persistent heap failure atomic update explore research historically ensure consistency discard update interrupt failure redo update recovery unless everything failure contrast idempotent update update failure simply execute discard reduce idempotence researcher leveraged idempotence various purpose exploit recover exception speculative execution VLIW processor around propose  atomic sequence uniprocessor idempotence leveraged idempotence reduce hardware storage buffer data compiler assist speculative execution model idempotence precise exception vector processor virtual memory idempotent data trigger thread execution recently researcher leveraged idempotence recovery error ecc fault advanced checkpoint prune serf remove operation reconstruct error extend idempotent processing context sensor error detector ensure recovery recently harvest community idempotent processing recover frequent failure without battery idempotence recovery heuristic approximate minimal checkpoint survive failure revolves around sever anti dependence checkpoint load manner reminiscent lately technique highlight promise limitation idempotence ensure progress multiple failure within span microsecond vein highlight limitation  idempotence analysis additional consumption due unnecessary checkpoint significantly project target embed processor execution cache exist despite wealth related iDO knowledge idempotence achieve lightweight fault tolerant execution failure atomic purpose program vii conclusion fault tolerance application emerge nonvolatile memory technology exist approach persistence however suffer performance usability transactional approach generally incompatible exist lock code tend concurrency failureatomic FASEs contrast compatible lock idiom introduce barrier scalability unfortunately prior FASE approach persistence incur significant overhead address limitation introduce iDO compiler approach failure atomicity iDO compiler FASE idempotent failure recovery restart interrupt idempotent execute FASE unlike undo redo iDO avoids individual program thereby achieve significant reduction instrumentation overhead across variety benchmark application iDO significantly outperforms exist lock persistent normal execution machine conventional volatile cache preserve recovery