software transparent crash consistency promising direction immediately reap benefit nonvolatile memory NVMM without  programmer  transactional semantics unfortunately propose hardware ahead wal scheme performance overhead particularly multi core thread chip cache NVMs random access performance proposes PiCL wal checkpointing mechanism overhead software transparent crash consistency NVMM PiCL introduces  cache driven asynchronous cache scan reduce random access enable locality nvm relax durability timing checkpoint crash consistency performance overhead slowdown typical prior demonstrate feasibility  crash consistency fully implement PiCL fpga prototype verilog OpenPiton framework index cache memory nonvolatile memory parallel processing computer crash checkpointing introduction nonvolatile memory NVMM emerge important research direction NVMM NVMM rapidly converge byte addressable nonvolatile memory nvm intel 3D xpoint commercialize plugin ddr replacement standard nvdimm propose intel announce ddr pin compatible nvm DIMM device TB addressable memory besides refresh storage density conventional dram data persistence nvm promise instantaneous crash recovery availability  distribute warehouse memory failure unfortunately crash consistency cheap nvm lose data loss  cache hierarchy reorder coalesces memory operation memory memory inconsistency failure instance doubly link append memory location update pointer pointer reside cache propagate memory crash memory  corrupt   XIIHU    DFKH HDG ULWH     DWD HPRU  DWD    structural PiCL architecture memory writes epoch cache tag  eid overwrite cache  creates undo entry coalesce undo buffer sequentially KB nvm prior crash consistency software transactional interface persistent multi versioning management sadly burden correctness programmer scheme hurt programmability error prone software cache flush performance slowdown software transparent approach crash consistency attractive alternative additionally compatibility legacy software benefit NVMM  immediately accelerate adoption rate persistent memory technology scheme checkpoint memory per epoch interval crash memory readily revert consistent avoid copying entire memory address epoch  wal redo undo conjunction shorter checkpoint  critical scalability prior cache flush mandatory epoch CPUs MB chip cache cache flush latency dominates commit execution overhead furthermore cache flush synchronous stall annual acm international symposium microarchitecture doi micro completely redo undo significantly random access nvm storage NVMs random access performance conventional dram costly dram cache layer absorb writes writes necessarily persist nvm layer guarantee checkpoint durability propose PiCL pronounce pickle software transparent crash consistency PiCL implement unique multi undo cache driven asynchronous cache scan cache flush critical coalesce undo writes performance characteristic NVMs concept database file commit largely unexplored context software transparent crash consistency mechanism demonstrate tag cache epoch IDs eid volatile cache hierarchy data epoch simultaneously epoch detect pre data undo entry chip undo buffer chip buffer periodically flush entry maximize sequential bandwidth NVMs PiCL minimizes random access crash consistency performance overhead performance loss typical prior core cpu MB cache besides performance overhead architecture PiCL cache eviction policy unmodified PiCL translation nvm cache sophisticated persistent memory controller PiCL shelf ddr NVDIMMs demonstrate feasibility PiCL implement fpga prototype OpenPiton source manycore framework interrupt handler prototype summarize implementation report overhead synthesize xilinx genesys fpga specific contribution introduce multi undo improvement undo allows concurrent multiple epoch introduce cache driven overhead technique cache modification across epoch writes undo data directly processor  costly commit access sequence undo scheme combine multi undo cache driven purposefully overcome cache flush minimize buffer nvm exist ddr nvdimm interface evaluate PiCL across spec application cache flush non sequential prior glossary epoch  epoch interval writes within epoch ID eid execute epoch uncommitted epoch eid epoch  commit epoch epoch necessarily persist nvm persist epoch epoch data fully nvm revert memory persist epoch abbreviate  epoch writes within epoch reorder coalesce cannot across epoch boundary epoch boundary modify data flush persist epoch significantly introduce overhead multi core multi programmed workload implement PiCL OpenPiton demonstrate feasibility software transparent crash consistency II background concept understand motivation epoch checkpointing weakness prior ahead difference performance sequential random access  NVMs epoch checkpointing lifetime program cache modify multiple strategy bandwidth requirement drastically instead strictly enforce writes epoch checkpointing allows reorder within interval epoch epoch checkpoint interval varies usage relevant prior checkpointing typically checkpoint achieve availability PiCL generally agnostic checkpoint reliable performance checkpoint requirement epoch checkpointing correctness modify cache synchronously flush persist nvm epoch epoch modify data completely flush flush memory consistency guaranteed loss cache flush mandatory commit persist operation atomically prior wal proposal achieve recover within   XIIHU DFKH  redo   RJ DFKH   HP undo DFKH    RJ   XIIHU PiCL cache eviction handle redo undo redo appends data redo buffer undo writes append data undo PiCL undo source multiple undo data directly chip undo buffer cache flush scalable chip cache overhead commit checkpoint dirty cache data memory average MB cache dram checkpoint unacceptable chip SRAM cache rapidly intel amd server CPUs MB MB ibm mainframe MB MB cache memory controller reorder transaction exploit buffer locality cache content data spatial locality memory controller constantly memory byte data literature database commit finality transaction slightly semantic nvm crash consistency precise checkpoint commit guaranteed atomicity consistency isolation durability permanence checkpoint persist nvm durable overview difference execute commit persist undo redo ahead database file ahead wal technique atomicity durability apply checkpointing atomicity epoch restore durability ensures data persist epoch corrupt newer uncommitted epoch writes propagate nvm mainly cache eviction cache flush epoch approach wal redo undo redo cache eviction temporarily redo buffer nvm preserve memory consistency commit phase cpu buffer redo buffer snoop memory access avoid return outdated data redo buffer scalable multi core cpu buffer redo buffer typically fix associative structure suitable workload multi core concurrent thread writes buffer overflow buffer overflow abort epoch prematurely shorter epoch disrupt cache flush undo cache eviction undo data canonical memory address data persist undo buffer nvm finally eviction memory refer sequence modify access sequence crash loses reverts writes apply entry undo buffer restore consistency checkpoint undo data spatial locality cache eviction modify access sequence perform ensure correctness writes multiple undo entry coalesce nvm optimization however  reading multiple undo data update data separately prior SW transparent wal closest prior PiCL ThyNVM ThyNVM redo wal memory translation maintain commit volatile execution version data mixed checkpoint granularity nvm buffer usage workload spatial locality ThyNVM overlap checkpoint phase execution phase minimize stall although synchronous cache flush stall checkpoint translation scalable multi core PiCL closely related previous hardware driven frequency checkpointing FRM frequency checkpoint rely undo crash recovery worth decrease checkpoint frequency unlikely eliminate performance overhead instance undo modify operation cache eviction redo translation limit duration checkpoint related epoch persistency writes persist barrier programmer discussion vii difference persist barrier SW transparent persist barrier typically shorter checkpoint II comparison  prior software transparent ahead  FRM journaling ThyNVM PiCL async cache flush commit overlap multi commit overlap undo coalesce redo coalesce epoch translation layer mem ctrl complexity medium medium performance byte addressable nvm byte addressable NVMs faster nand flash SSDs significantly random access performance dram  storage memory scm NVMs buffer latency dram commercial namely intel 3D xpoint characterize random operation per IOPS per chip chip typical amount memory DIMM throughput IOPS around per buffer therefore imperative memory request NVMs maximize spatial locality experimental data peak throughput KB data suggests buffer KB buffer likely multi mlc nvm infer source code  motivation PiCL statement summarize prior software transparent wal scalable multi core neither undo redo data spatial locality approach synchronous cache flush scalable cache propose novelty PiCL decouple execution checkpointing phase multi undo multi undo allows multiple logical commits flight maintain central undo remove synchronous cache flush versioning individual cache asynchronous cache scan remove cache flush critical asynchronously executes checkpoint phase minimize performance overhead buffer undo cache driven preemptively source undo data directly chip cache buffer entry nvm concept database file commit largely unexplored context software transparent crash consistency instance knowledge none prior flush cache asynchronously recent redo scheme ThyNVM enables asynchronous execution checkpointing overlap limited checkpoint cache flush synchronous commit employ amortize persistency unclear apply cache eviction PiCL applies cache driven coalesce efficiently multiple undo entry summary II overview feature PiCL contribute ultimately PiCL performance durability permanence checkpoint multiple checkpoint flight delay persist operation adversely affect consistency discus topic IV undo baseline PiCL incrementally cache driven asynchronous cache scan ACS multi undo achieve goal undo drawback undo nonetheless PiCL undo advantage unlike redo translation correctness cache eviction canonical memory location undo PiCL inherits desirable characteristic exist memory controller architecture however performance undo modify access sequence cache eviction persist undo entry NVMs random access IOPS access sequence severely reduces effective nvm bandwidth cache driven fix modify sequence performance propose cache driven instead access nvm undo entry tag cache epoch ID eid data identify cpu cache nvm directly without operation technique cache driven cache actively lazily writes appropriate undo entry eid difference reside cache eid chip undo buffer buffer entry chip IO access nvm baseline KB buffer nvm buffer assume multiple account buffering multiple channel nvm worth performance degradation stem memory queue delay chip undo buffer minimal KB HFXWLRQ DFKH  HFXWLRQ DFKH     traditional synchronous cache flush HFXWLRQ HFXWLRQ HFXWLRQ HFXWLRQ  ACS execution cache flush asynchronous cache scan ACS ACS lock volatile execution cache flush gap persist commit epoch ACS gap modify cache entry chip tend remain cached unrelated undo entry efficiently cache evict central correctness approach cache cannot evict undo data flush chip undo buffer happens undo data lose upon failure memory inconsistent enforce dependency undo writes bloom filter detect eviction undo entry buffer buffer flush rare llc sufficient associativity false positive rate insignificant sufficiently bloom filter entry capacity filter buffer flush asynchronous cache scan remove cache flush critical important cache flush synchronously immediately prior ensure durability checkpoint immediately persist checkpoint neither PiCL multi undo allows multiple epoch concurrently cache flush stall entirely asynchronous PiCL  epoch persistency asynchronous cache scan ACS cache flush ACS scan cache flush dirty cache difference instead dirty cache ACS target cache eid tag currently persist epoch ID ACS cache memory ACS trail threshold epoch lock execution refer epoch ID difference  parameter configurable independent parameter ACS gap zero cache scan initiate commit persist ACS opportunistically access eid tag array dirty 7DJ DWD  URP  undo entry nvm 7DJ DWD  DWD augment cache entry meta data cache entry array appropriate data entry  ACS delayed epoch bandwidth upon cache scan ACS flush chip undo buffer buffer contains entry epoch persist epoch multi undo introduce multi undo baseline multi undo undo entry contiguous memory nvm patch memory restore consistent upon hardware failure semantic difference multiple outstanding commit persist epoch undo entry commits undo without restriction entry address persist preserve delivery guarantee acid consistency  ACS implication multiple outstanding epoch significant critically remove stall flush cache enable overhead crash consistency chip cache unlike baseline undo scheme undo entry implicitly belong recently commit epoch multi undo undo entry epoch  furthermore entry belong multiple consecutive epoch PiCL entry tag   eid  eid reflect epoch cache modify modify specify validity data recovery entry expire reclaim garbage  undo entry commits contiguous memory maximize sequential performance nvm device multi undo depicts sequence writes across epoch undo entry multi undo indicates writes cache eviction processor undo entry writes unmodified epoch modify assume previously undo              entry multi undo shorthand cache undo data append chip undo buffer evict eviction data entry data version epoch append undo epoch modify undo epoch modify evict due cache eviction policy difference dirty data  checkpoint allows overlap execution commit phase logical commit epoch prior commit imply persistency modify cache flush cache epoch durable contrast PiCL  persistency checkpoint ACS difference undo creation cache eviction epoch evict memory logically regard undo cache eviction epoch transaction scheme semantics data epoch persist nvm epoch multi undo allows reorder operation facilitate efficient coalesce undo writes constraint cache eviction policy purpose ACS PiCL ACS assumes responsibility dirty data cache flush checkpoint durable available recovery ACS operation ACS actually writes data nvm ACS instance dirty cache flush nvm undo entry already recovery ACS flush chip undo buffer already flush validity multi undo undo entry tag    modify eid undo entry  eid modify  epoch ID contrast undo tag entry revert commit commit commit                 addition cache transition graph llc cache assume MESI IV implementation hardware implementation PiCL entirely implement SRAM cache hierarchy eid tag cache update tag undo entry OS garbage collection undo discus related topic consistency multi channel memory nvm dram buffer extension cache eid tag implement cache driven architecture eid tag cache eid tag sufficient epoch modify eid tag eid cache modify across epoch boundary eid undo data prior modification tag cache llc private cache  PiCL  recent fully persist fully recoverable checkpoint  currently execute uncommitted epoch per cache  denotes modify relevant transition llc undo entry ordinary llc valid cache modify logically physically modify disambiguate transient   commit transient cache commit data undo entry load memory llc eid associate request data undo entry  tag  otherwise eid undo entry   eid tag update   entry  undo hook private cache largely llc eid tag private cache update eid tag undo data entry            gig addition cache transition graph private cache assume MESI PiCL modify cache coherence protocol additional action llc llc eid tag llc update  cache llc cache modify repeatedly across multiple epoch without llc critical absorbed eid tag fairly comparison negligible cache coherence operation tlb lookup tag additionally undo hook relocate summary undo entry cache modify commit modify cache modify undo data private cache commonly atomic operation llc handle manner described private cache PiCL cache coherency protocol cache eviction policy simply hook undo entry undo buffer undo entry directly chip buffer flush nvm bulk buffer KB evaluation maximize sequential performance buffer undo entry mixed eid tag coalesce queue undo buffer flush entry buffering employ accept incoming undo entry buffer flush buffer flush ACS persist eid undo entry buffer conservative flush undo buffer ACS evaluation ACS asynchronous cache scan implement hardware llc mechanism opportunistically scan eid array llc valid tag target eid tag dirty flush memory cache flush dirty private snoop ACS ordinary cache access simultaneously incorrect data instance ACS occurs prior memory another append undo modify cache sole difference extra memory correctness preserve nvm interface OS interface explicit hardware requirement nvm interface PiCL compatible exist ddr ddr interface simplify implementation reduce bookkeeping task allocation garbage collection crash recovery handle OS allocation OS allocate memory MB nvm pas pointer PiCL hardware buffer flush data OS interrupt allocate memory update pointer memory allocation contiguous pointer maintain garbage collection  tag OS entry nvm expires safely discard garbage bookkeeping entry super KB expiration max  member entry crash handle procedure recover failure OS memory location nvm valid persist checkpoint  undo scheme OS scan backward entry undo entry   eid applies memory important scan apply undo entry backward undo multiple undo entry address previous epoch valid scan procedure  tag super  discussion multi core data writes core thread epoch ID  recovery applies application memory memory mapped exempt eid structure memory allocation consistency prior crash recovery consistency extensively immediately writes buffer delayed epoch writes fully persist checkpoint persist latency ACS delay epoch persist operation effective latency epoch ACS gap delayed correspondingly detrimental workload critical forcefully epoch conduct bulk ACS outstanding undo entry release pending bulk ACS extension  checked pas eid latency delay activity affect  workload throughput affected delay performance  workload remains tolerable epoch moreover prior writes delayed unreliable interface tcp IP built fault tolerance application storage medium idempotent operation consumer application video playback similarly tolerate fault recovery latency thorough recovery procedure undo checkpoint recovery latency around due ACS  undo entry recovery latency lengthen multiple PiCL decrease runtime overhead worth increase recovery latency instance suppose recovery latency increase availability assume failure  contrast runtime overhead amount compute lose per transaction per dram buffer extension accommodate NVMs IOPS layer dram  cache cache memory dram layer typically cache data granularity  capture spatial locality PiCL function  dram dram cache modification intuition semantics writes nvm PiCL remain equivalent without dram cache otherwise mode assume dram inclusive cache granularity apply PiCL dram cache treat llc private cache PiCL cache granularity prototyping fully implement PiCL hardware prototype OpenPiton demonstrate feasibility correctness multi undo cache driven implement verilog fully recoverable micro benchmark simulation hardware prototype OpenPiton nominal fpga frequency mhz OpenPiton implementation cache OpenPiton private per tile distribute llc llc cache modify cache driven cache precede operation eid undo entry simplify somewhat undo llc llc chip interface chip interface implement buffer bloom filter described challenge OpenPiton cache byte private cache byte llc OpenPiton distribute instead  hardware   fpga logic LUTs bram slice llc llc controller IV configuration core 0GHz cpi non memory instruction KB per core private cycle associative KB per core private associative cycle llc MB per core associative cycle memory link 6GHz 8GB nvm timing FCFS controller byte  sub quad byte complexity performance adopt granularity byte instead byte drawback llc eid tag per cache entry per sub lastly software interface OS epoch boundary handler purpose handler internal memory register file arithmetic checkpoint cacheable fix memory address per core visible OS handler implement periodic adjustable timer interrupt occurs transparently userspace program actual interrupt vector execute cpu handler ingredient epoch checkpointing scheme PiCL hardware overhead summarizes hardware overhead implement xilinx genesys fpga logic overhead LUTs register llc modification overhead due buffering eid array llc account ram bram allocation bram overhead llc maintains eid per byte cache mention earlier reasonable VI evaluation methodology PiCL crash consistency legacy software  benchmark suite profile performance specifically modify pin  prime simulator simulate benchmark core execution normalize ideal nvm representative billion cycle trace publicly available simpoint multi program profile trace instruction trace instruction sustain load program default configuration detailed IV nvm buffer latency writes  NVMs epoch instruction default consistent prior PiCL benefit longer epoch evaluate multi core performance multiprogram workload randomly chosen benchmark PiCL representative  crash consistency journaling  FRM ThyNVM journaling redo described II shadow largely journaling increase granularity   translation commit optimization performance acceptable  locally within memory module decrease memory bandwidth utilization entry retain avoid memory epoch FRM representative undo scheme frequently frequency per epoch checkpoint working described II ThyNVM redo mixed KB granularity  overlap capability implement ThyNVM described implement dram cache layer instead allocate redo buffer nvm assume cache snoop correctness described detail ideal nvm model checkpoint crash consistency performance comparison journaling shadow ThyNVM translation configure entry entry respectively ThyNVM associative consistent prior performance overhead evaluate thread performance across  simulation prior thread multi core performance normalize ideal nvm multiprogram WORKLOADS randomly chosen href soplex hmmer bzip gcc sjeng perlbench hmmer gcc gobmk gcc soplex bzip tonto gcc bzip lbm gobmk perlbench cactusADM bzip href mcf gcc bzip tonto cactusADM astar bzip namd zeusmp perlbench wrf gobmk gcc namd gobmk milc bzip omnetpp bzip bzip gobmk sjeng perlbench bzip gobmk gcc tonto cactusADM dealii gobmk omnetpp bzip gcc wrf gcc bzip gromacs gcc perlbench thread workload multi thread PiCL crash consistency almost overhead rare sphinx PiCL loses performance due undo buffer flush KB contiguous data request elaborate II primary increase cache flush frequency increase IOPS non sequential increase cache flush cache flush due redo buffer overflow described II performance redo scheme journaling shadow ThyNVM insight plot actual commit frequency accounting translation overflow normally commit per instruction journaling commit frequently PiCL undo approach PiCL FRM suffer characteristic workload workload compute intensive workload translation consistently workload sequential traffic mcf shadow entry cache per entry however workload spatial average commits per instruction thread default commit per hardware translation overflow epoch commit normalize operation nvm device nvm   RM ICL locality astar neither suitable journal  commits cache flush increase IOPS due performance explain increase operation due  operation random access performance NVMs plot IOPS memory benchmark normalize traffic ideal nvm activity grouped category sequential random sequential denotes access nvm buffer shadow indicates  operation random denotes extra cache cache flush journal shadow PiCL plot raw operation reading KB memory operation extra IOPS generate checkpoint mechanism traffic despite cache flush latency extra access substantially degrade performance FRM incurs random IOPS alternative perform modify access sequence cache eviction meanwhile PiCL exhibit extra access nvm due interface undo amount writes ACS minimal performance overhead ideal nvm eviction traffic flush cache dirty data obviate future eviction undo epoch instruction PiCL epoch default storage overhead PiCL incurs overhead scheme multiple epoch outstanding storage allocate nonetheless majority workload consumes MB storage per epoch workload heaviest remain within megabyte within capacity nvm storage epoch grain recovery responsiveness epoch increase decrease overhead unfortunately redo scheme cannot handle longer epoch quantifies default epoch instruction instruction epoch journaling shadow compute bound workload povray scheme effective epoch  shadow journaling PiCL limited hardware resource memory storage 1GB storage sufficient maintain instruction epoch workload sensitivity cache II chip cache longer synchronously flush dirty data checkpoint PiCL generally performance overhead across cache asynchronously opportunistically scan dirty data noteworthy ThyNVM overhead grows faster scheme due redo buffer across multiple epoch pressure shorter checkpoint nvm latency byte addressable NVMs latency affect average core execution various cache normalize ideal nvm average core performance nvm latency normalize ideal nvm latency plot multi core performance latency varied latency IOPS overhead scheme tax latency worsen performance relatively optimistic latency average performance overhead previous chip bandwidth PiCL chip bandwidth device bandwidth additional writes nvm source undo data chip cache chip bandwidth transfer data amount chip bandwidth incur performance loss suggests around 2GB chip bandwidth default ddr baseline 8GB ACS gap defer asynchronous cache scan ACS bandwidth usage effective ACS gap reduce amount ACS plot traffic various ACS gap comparison  zero delay cache scan epoch greatly reduce amount average increase ACS gap reduction vii related substantial crash consistency persistent memory propose software transparent epoch persistency ahead data persistency epoch  persistency lower performance overhead writes epoch refer persist barrier essentially related EpochID hardware meta data per cache cache tag EpochID evict overwritten cache tag  performance PiCL chip link bandwidth normalize ideal nvm bandwidth traffic ACS gap varied normalize ACS gap zero evict preserve nvm lower overhead relax reduce false dependency expose concurrency reduce overhead thread synchronization generally difference PiCL  writes per thread complex synchronization thread persist barrier typically handful tightly couple eviction policy cache coherence protocol cumulatively difference PiCL recent prior explore isolate decouple execution persistence phase achieve performance DudeTM maintains redo buffer redo asynchronous data update background redo undo writes undo redo data cache hierarchy without overly constraint cache eviction policy HOPS proposes persist buffer operation cache hierarchy dirty cache evicts discard PiCL scheme software transparent redo challenge workload due limited capacity redo buffer remap memory controller perform instead cache evict PiCL software transparent scheme essentially  address nvm bypassing cache hierarchy okay transaction magnitude bandwidth cache evict unacceptable performance apply software transparent consistency others software transparent PiCL legacy software unlike proposal augment optimize software persistent api secondly PiCL reorder optimize traffic contrast prior crash persistency built memory fence data cache hierarchy incurs significant bandwidth penalty nvm cache NV llc propose multi versioning transaction capability contrast PiCL specifically volatile SRAMs lower implementation barrier additionally NV llc modify eviction replacement policy prevent transaction evict OS handle overflow NV llc narayanan propose transparent persistence scheme failure processor flush volatile cache dram NVRAM residual technique protects loss PiCL enables recovery wider error furthermore unclear residual flush chip cache conclusion capitalize emerge byte addressable nvm technology decrease adoption barrier propose PiCL  crash consistent technique NVMM PiCL implement innovative overcome scalability challenge cache flush mandatory prior nvm technology random IOPS PiCL crash consistency virtually performance loss lastly fully implement PiCL fpga prototype verilog demonstrate feasibility software transparent crash consistency