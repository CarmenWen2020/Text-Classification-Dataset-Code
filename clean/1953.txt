conduct systematic analysis exist cpu optimization target scientific server workload mobile apps important concept identify accelerate individual critical instruction workload spec effective mobile apps difference mobile app characteristic dependency critical instruction intersperse non critical instruction dependence chain temporal proximity critical instruction dynamic bottleneck shift rear datapath pipeline contributor ineffectiveness traditional criticality optimization instead propose concept critical instruction chain CritICs critical sequence instruction aggregate optimization motivate offline profiler analysis framework easily identify CritICs propose software mechanism compiler exploit ISA format nearly fetch bandwidth instruction implement entire framework profiler compiler evaluate effectiveness popular apps experimental evaluation approach effective previously criticality optimization yield speedup saving cpu translate saving additional hardware index criticality cpu mobile introduction proliferation mobile device decade fuel hardware advancement numerous diverse application apps device device exceeds desktop server nearly billion mobile device population extent hardware software evolution device drawn lesson desktop server counterpart adapt resource constraint factor etc mobile apps characteristic desktop server workload amount user interaction handle sensor etc device optimization effective mobile platform optimization instruction prioritization memory prefetching exploit important namely criticality instruction server desktop domain mechanism mobile apps instead proposes criticality granularity  instruction chain assigns criticality metric chain bottleneck shift rear cpu datapath pipeline mobile apps introduces novel prioritize aggregate critical instruction chain critic software additional hardware extra resource hardware mechanism superscalar processor datapath boost performance embed domain important utilize exist resource amongst compete instruction resource constrain environment mechanism prioritization amongst compete instruction criticality critical instruction processor datapath prioritizations optimization employ numerous criticality optimization propose workload prioritize cpu resource cache memory request queue predict instruction issue prefetch request etc however impact optimization date mobile workload important void intend unlike desktop server workload throughput demand mobile apps highly user interactive user action screen swipe sensor input positional gps movement accelerometer frequently execution app react action additional input consequent code conventionally deem critical instruction conducive independent instruction optimization dependent possibly non critical instruction dependence chain instance recent optimization prioritizes critical load spec workload prior  speedup spectrum mobile apps criticality optimization target mobile apps sequence critical instruction optimize individually identify additional difference bottleneck critical instruction shift execute commit stage superscalar pipeline fetch stage pipeline spec mobile apps sequence critical instruction dynamic execution mobile apps spec workload amenable aggregate software optimization aware prior insufficiency criticality individual instruction optimization mobile apps workload difference TU OOVBM   revisit topic mobile context motivate insight shelf android apps contribution concept instruction chain IC within data graph DFG execute independent instruction encounter introduce criticality metric IC calculate average fan per instruction chain ICs criticality exceed threshold marked CritICs entire critic sequence instruction priority unlike spec CritICs mobile apps relatively instruction widely dynamic instruction suitable software compiler profiler identification critic instruction mobile apps bottleneck fetch stage pipeline oppose spec execute commit stage latency instruction former producer instruction pipeline consumer drain instruction fetch queue equally important contributor bottleneck stage identification critical ICs convenient abstraction tackle fetch bottleneck theoretically hoist aggregate instruction macro instruction critic sequence option expensive adhere philosophy impose minimal hardware enhancement instead propose novel approach fetch bandwidth critic instruction leverage instruction format convert instruction representation compiler pas loss functionality precede command instruct hardware switch format instruction propose hoist conversion software employ cpu device implement profiler  emulator gem simulator identify critic sequence compiler pas android runtime compiler hoist aggregate emit representation critic instruction evaluate proposal gem google tablet configuration diverse popular suite stock android apps approach speedup speedup average apps previously regard instruction criticality load prefetching instruction prioritization speedup average representation nearly fetch bandwidth critic sequence buying producer fetch pack  reduces data across instruction buying consumer fetch achieve extra hardware requirement exist processor datapath increase cache capacity improve prediction accuracy employ instruction prefetchers address fetch bottleneck extra hardware mobile platform resource constraint future platform incorporate additional hardware address fetch software technique hardware approach platform cache capacity perfect predictor synergistically additional speedup hardware technique opportunistically format instruction optimize fetch stage instruction improvement approach identify hoist critic sequence selectively format instruction sequence opportunistically format instruction complement improvement II  criticality within confines resource superscalar processor important issue deploy assign resource incoming instruction essentially priority schedule fetch execute instruction adequate resource instruction resource however resource constrain priority critical instruction definition criticality prior instruction critical execution becomes visible hidden overall app execution conventional criticality identification per definition instruction marked critical execution assign resource hence prior propose estimate criticality instruction fetch heuristic instruction critical threshold execution latency instruction latency instruction implies despite frequent critical instruction mobile apps benefit critical instruction spec critical instruction android apps successive fanout instruction dependence chain dependence fanout instruction instruction delayed critical dependent instruction refer fanout particularly rob instruction execute instruction output maintain instruction exceed threshold prior execution predictor upon instruction fetch PC instruction critical criticality scheme mobile apps optimization employ upon fetch critical instruction prioritize cpu resource cache memory request predict instruction issue prefetches etc optimization primarily propose evaluate server desktop workload mobile apps platform DFG timing superscalar processor issue width illustrate fanout prioritization without loss generality representative  proven criticality optimization prioritize important resource memory issue prefetches critical load another alu resource instruction schedule proposal identify fanout load critical issue prefetch prioritize critical instruction alu resource allocation technique significant benefit server workload  optimization outperform latency identify exploit criticality evaluate usefulness criticality optimization depict mobile apps speedup obtain employ technique spec int spec float android apps experimental detail sec IV performance gain prefetching fanout load prioritize alu resource schedule significant spec int prefetching prioritize spec float prefetching prioritize affirm prior interestingly gain optimization relatively  prefetching prioritize mobile apps mobile apps significant fanout load alu instruction benefit optimization contrary axis mobile apps percentage critical instruction spec counterpart opportunity optimize execution understand identify scenario optimization scenario mobile apps DFG graph execute instruction trigger instruction become execution fanout optimization obviously execute fanout instruction become prioritize execution subsequently  fanout schedule instruction fanout  instruction prioritization differentiate dependent fanout instruction cannot schedule till optimization prioritize sibling instruction criticality optimization scheme described previously stall cycle execution scenario occurs commonly mobile execution explain instruction despite fanout priority subsequently dependent fanout instruction consequently insufficient optimize individual fanout instruction independently instead sequence dependent instruction schedule fanout instruction evidence scenario mobile apps spec counterpart dependence chain fanout instruction fanout instruction successive fanout instruction dependence chain dependence chain fanout instruction dependence chain fanout critical instruction cumulatively android apps spec float spec int apps dependent fanout instruction around android apps hardly happens fanout instruction successive fanout thereby critical spec apps benefit optimize critical instruction individually oppose android dependent chain reduce effectiveness individual optimization mobile app prioritize optimize critical instruction individually effective  apportion resource temporally proximate dependent critical instruction chain sequence optimization future traditional criticality optimization target critical instruction chain instruction optimize closely dependent critical instruction android apps important understand amongst superscalar pipeline stage towards breakdown execution profile amongst stage fetch commit breakdown fanout instruction spec android android fetch bottleneck due stall instruction fetch StallForI stall resource dependency StallForR instruction pipeline mobile apps latency instruction spec graph profile critical instruction identify fanout metric spec float spec int apps unlike spec apps execute stage consequently pressure rob queue residency dominant android apps execution stage latency consequently rob residency critical instruction android apps execution latency instruction spec counterpart however fetch stage decode stage extent dominant android apps spec due contribution execute stage fetch stage critical instruction spec stage shift profile rear fetch stage consumes pipeline android warrant closer stage fetch execution apps StallForI responsible instruction stage StallForR instruction stage subsequent decode former depends cache latency misprediction latter largely pressure exert subsequent pipeline stage decode commit prior instruction relative contribution StallForI StallForR overall fetch overhead comparable across spec android apps however actual StallForI contributes overall execution spec android apps execute code diverse library apis frequent function cache stall execution prediction stall another StallForI StallForR spec apps execute latency instruction creates pressure fetch stage spec float spec int android apps majority fanout instruction  instruction impose pressure execute stage instead dependence resolution various instruction stall StallForR apps optimization critical instruction reduce StallForI StallForR latency cache  optimization optimization alone suffice later insight android apps fanout thereby critical instruction temporal proximity non critical fanout instruction dependence chain optimize sequence instruction concurrently fetch stage important instruction optimization stage likely yield reward hardware conventionally bottleneck execute commit stage accelerate rate instruction fetch stage accelerate rate instruction pipeline  critical instruction  identify requirement explore identify critical instruction dependence chain sequence temporal proximity optimize sequence minimal StallForI StallForR latency fetch stage minimal hardware extension identify CritICs critic sequence identify optimize individual fanout thereby critical instruction limited option instead future future critical instruction dependence chain graph consequently entire chain prioritize optimize intermediate instruction dependence chain dependence chain traditionally marked critical fan towards identify critical instruction chain critic introduce metric definition instruction chain IC instruction chain acyclic data graph DFG independently schedulable execution previous DFG independent DFG independently schedulable qualify ICs qualify IC depends another independently schedulable sub qualifies IC DFG sub IC IC IC sequence instruction executable atomic entity macro instruction consist micro instruction sequence without dependency individual instruction exploit later optimize critical ICs  DFG individual ICs goal execute ICs prioritize relative criticality DFG timing superscalar processor issue width optimize CritICs execution fanout optimization prioritize IC fanout instruction inefficient cycle execution becomes serialize ILP cycle however identify relative criticality ICs non trivial instruction IC fan criticality simply fan constituent instruction accurate IC criticality variance amongst instruction cumulatively fanout IC fanout instruction subsequent instruction fanout vice versa representation capture variance future average fanout per instruction IC capture criticality IC ICs average fanout per instruction exceed threshold marked critic sequence DFG conventional instruction fanout prioritization execution cycle issue superscalar processor critic approach identify ICs prioritize latter former average fanout per instruction schedule cycle strategy identify CritICs hardware predictor prior software profile driven compilation explain minimize hardware requirement mobile device become highly resource constrain opt latter approach additional issue address ability without user intervention unlike desktop environment user apps mobile apps publish priori  etc unreasonable popular apps undergone profile driven compiler optimization phase already quality revision performance bug etc publish integrate phase appropriate code generation diverse input user interactivity apps available priori execution input data mobile apps user interactivity conveniently user input readily apps standard format avail approach ability ICs software approach criticize restrict scope analyze code concurrently ICs considerably dynamic instruction instance apply approach spec apps ICs instruction dynamic ICs mobile apps maximum instruction instruction conducive approach tractability ICs instruction ICs app execution generate volume profile data GB critic sequence numerous sequence instead optimize critic sequence app critic sequence coverage dynamic execution substantially reduces profile  built profile driven compilation framework IC correspond dynamic instruction execution spec android apps cdf coverage unique CritICs AB DE critic instruction transform format thumb format ISA automatically identify optimize critic sequence android apps app execution profile  emulation gem hardware simulator instruction identify critic sequence device android runtime compiler compiler generates optimize binary various compiler optimization implement additional instrumentation pas compiler critic optimize DFG generate generate optimization optimize critic sequence optimize sequence motivate important observation critic sequence instruction nearly execution fetch stage StallForI StallForR contribution become equally important critic sequence instruction execute sequence without influence sequence ideally critic sequence macro instruction functionality equivalent execute constituent instruction another compiler replace entire sequence correspond macro instruction avoid individual fetch constituent incur fetch operation reduce StallForI contribution hoist entire dependent chain critical instruction macro instruction reduce eliminate unnecessary gap shorten data reduce StallForR contribution later stage pipeline flush macro instruction obvious choice implement macro instruction extend ISA multiple mnemonic critic sequence mnemonic argument index structure critic sequence macro instruction sequence micro instruction execute reasonable option critic sequence somewhat limited sequence widely prevalent across apps however unique critic sequence opcode operand constituent instruction propose software framework methodology app unique critic sequence impossible extend ISA purpose building dedicate hardware unique critic sequence exploit ISA instead mechanism dynamically mimic ing macro instruction CritICs propose novel achieve ISA contemporary ISA format instruction opcodes source destination operand register concise format thumb extension mode opcode operand format embed controller optimize binary exist decoder decode format flag pending queue structure propose instruction critic sequence optimize format report format instruction execute slowdown cannot predicate execution architected register operand format amenable critic instruction illustrate plot cdf coverage dynamic instruction instruction identify critic sequence code format plot cdf coverage critic instruction format without neither predication register critic instruction cannot unique critic sequence refer critic ideal sec IV demonstrates promise proposal additionally decoder inform instruction format switch forth representation inform decoder format switch hardware explicit instruction sec IV incurs additional overhead relatively critic instruction sequence propose alternative extend already exist instruction mnemonic critic thumb format switch decoder hardware evaluate sec IV summarize methodology summarizes software framework perform implement critic optimization instruction critic sequence cannot format entire sequence format optimize quantify trace collection android apps qemu emulator android OS hardware component cpu gpu gps network accelerometer gyro display speaker etc model  code loc output trace instruction execute data access isolated app consideration offline profile identify CritICs trace detailed microarchitectural simulation gem modification identify critical instruction  across rob entry loc CritICs critical instruction implement additional logic dump independently schedulable ICs GBs ICs offline distribute hash spark  sort CritICs ICs average fanout threshold coverage loc fix beneficial average fanout threshold slight performance degradation CritICs relatively concise KB account dynamic coverage compilation modify source compiler pas critic instrumentation pas applies critic optimization apk binary  generation compiler already optimization constant fold code elimination etc dex intermediate representation load elimination register allocation etc destination assembly code binary generation critic pas assembly code instruction  pas critic profile instruction  thumb format entire critic sequence instruction another format appropriate approach explain switch instruction format loc hoist  CritICs encounter pas affect exist instruction schedule shelf apps framework readily apply shelf app apk file playstore II mobile apps evaluation apps belong diverse domain texting video audio apps rat downloads playstore net benefit roughly instruction fetch rate halve StallForI critical instruction sequence switch format reduce StallForR delay dependent chain contiguous demonstrate propose hardware overhead interpret format switch approach readily hardware albeit inefficiency approach exist mnemonic switch format extension switch exist decoder code generation CritICs identify CritICs instruction sequence IV EVALUATIONS switch approach actual hardware conventional approach decoder switch instruction format unconditional instruction critic instruction sequence purpose instruction inform decoder impend format switch target address statically encode subsequent instruction critic sequence format thumb flag decode instruction critic subsequent critic instruction decode thumb format decoder critic sequence format target instruction critic reset format flag decoder mandate critic sequence amortize implement google tablet hardware core GB LPDDR memory optimize CritICs exist hardware leaf performance gap ideal scenario gain hardware critic optimization apps along actual speedup gain  average lose potential CritICs format switch gain critic sequence typically amortize overhead motivate propose alternative slight enhancement hardware address gain switch approach extend exist instruction avoid aforementioned overhead propose already exist instruction mnemonic CDP processor cpu fetch decode rename rob issue execute commit superscalar pipeline rob entry entry BPU memory KB cache KB cache cycle latency MB  prefetcher entry cycle rank per rank vdd tcl trp tRCD baseline simulation configuration domain app activity perform domain acrobat comment document reader  physic browser load web interface facebook RT texting messenger email mail email client mobile direction navigation audio player slide edit interactive display  browse image image browsing youtube HQ video video spec int bzip hmmer libquantum mcf gcc gobmk sjeng href spec float  namd gromacs calculix lbm milc dealii leslied II popular mobile spec apps evaluation data processing argument denote instruction format inform decoder accordingly illustrates translation compiler pas critic sequence contains CDP command argument contains instruction critic sequence format instruction critic sequence format upon encounter CDP command decoder subsequent latter CDP remain critic instruction decode CDP argument allows translate critic instruction format CDP command longer sequence simply issue CDP command subsequently critic sequence instruction suffice bulk saving detailed sec IV instruction sequence subsequent switch decode format implement laid logic mode switch CDP synopsys compiler SP technology library extra logic consumes dynamic leakage consumption respectively although timing logic conservatively assume cycle extra decode stage delay processing CDP command entire critic sequence instruction fetch  approach compiler translation roughly instruction fetch rate halve StallForI alternative instruction dynamic dataflow gap reduce thereby StallForR simulation evaluation platform conduct scenario conduct depth evaluation propose critic optimization performance consumption hardware evaluate app execution hardware configuration google tablet gem hardware consists CPUs issue superscalar core KB cache KB cache simulate detailed memory model 2GB LPDDR DRAMSim setup enables execute apps cycle hardware simulation obtain performance consumption cpu cache memory soc app execution profile phase sec apps emulate average execute average around instruction translates app execution without emulator overhead evaluation sample random contiguous instruction app execution tally instruction optimization evaluate quantify performance propose critic mobile apps evaluate choice baseline configuration hoist employ mechanism hoist instruction critic sequence another replace thumb format effectiveness individually towards implement scheme former identifies critic sequence hoist sequence instruction leaf format hoist evaluation critic propose critic aim tackle fetch bottleneck fanout instruction StallForR bottleneck hoist aggregate constituent instruction translate instruction thumb format critic ideal earlier leverage subset critic sequence instruction translate directly thumb format lose opportunity evaluate scheme critic ideal hypothetically aggregate thumb translates critic instruction cdf performance plot cpu execution speedup app scenario individual combine component critic optimization discus app speedup optimization normalize respect baseline individual optimization evaluate critic optimization consistently perform apps acrobat speedup however hoist target  marginal improvement average gain critic combine StallForI StallForR optimization speedup baseline fetch stage saving critic instruction gain critic optimization instruction suffice scheme reduces dataflow gap across critical instruction without boost fetch efficiency impact StallForR optimization across apps reiterate fetch improvement apps youtube bottleneck StallForR youtube baseline translates benefit optimization StallForR apps improvement hoist critic instruction browser  benefit critic implement conversion boost fetch bandwidth hoist improvement speedup improvement average difference critic critic ideal gap acrobat browser limit critic directly translate thumb format hurt majority critic instruction amenable thumb representation improvement average sec volume critic instruction representable format within entire critic instruction volume average speedup critic significantly outperforms previously propose instruction criticality optimization load prefetching alu prioritization speedup respectively gain critic optimization gain various component mobile soc plot recall critic optimization decrease access cache IC execution instruction instruction translates gain cache soc cpu speedup additional gain cpu memory average cpu contributes saving memory execution contributes additional overall average maximum saving  specifically cpu execution alone exclude peripheral ASIC accelerator etc realizes average conventional hardware fetch optimization numerous prior hardware enhancement propose address fetch stage comparison hardware mechanism speedup impact  StallForR intelligently manage cache predictor instruction prefetchers sophisticated hardware CPUs acceptable resource constraint mobile platform warrant sophisticated hardware implement hardware address fetch bottleneck described speedup obtain software critic FD critic format instruction fetch selectively fetch bandwidth critical instruction hypothetical hardware fetch decode stage bandwidth instruction critical stage scheme FD simulate hardware cache latency resource hardware queue fetch decode stage cache unreasonable hardware cache capacity KB KB reduce instruction  implement recently propose instruction prefetcher specifically useful user driven application mobile apps prefetcher user stack predict function prefetch instruction KB lookup maintain stack  hypothetical assume misprediction entire execution critic address StallForI address StallForR somewhat address prior criticality optimization prioritize backend resource instruction additionally configuration  platform implement prioritization hardware resource propose hardware propose KB SRAM maintain token  consists hardware sensitivity analysis fetch saving speedup critic speedup critic profile coverage backends cache    critic addition vanilla critic additional hardware critic combination hardware mechanism previously propose hardware mechanism yield speedup however important optimize StallForI StallForR hardware mechanism benefit stall FD cache  penalty reduce StallForI  completely eliminates penalty reduce fetch stall mechanism StallForR similarly  address StallForR reduce tackle StallForI hardware tackle stall  overall speedup benefit extensive hardware unacceptable mobile platform critic additional hardware significantly individual hardware mechanism future mobile platform incorporate StallForI StallForR hardware mechanism critic synergistically boost benefit incorporates hardware  speedup boost speedup critic sensitivity critic speedup gain report critic instruction investigate impact critic application performance critic ideal difference realistic critic instruction critic reward individually CritICs individual increase fetch StallForI StallForR latency however probability critic exactly instruction directly translate thumb format decrease increase offs impact axis fetch saving axis consequent speedup axis fetch diminish return speedup increase beyond probability sequence diminishes coverage CritICs execute longer critic sensitivity profile technique offline profile identify modify critical chain sensitivity extent profile percentage app execution profile speedup axis function percentage execution profile axis average across apps profile execution coverage reduce speedup obtain execution profile transform critic thumb sequence speedup across apps profile transform entire application speedup average bother criticality propose thumb format nearly fetch bandwidth critic instruction approach opportunistically instruction amenable modification instruction bother identify CritICs justify plot speedup obtain scheme opp approach opportunistically convert amenable sequence consecutive dynamic instruction sequence thumb format regardless critical instruction amenable format conversion instruction amenable opp instruction around conversion explain earlier dynamic sequence exceeds contiguous instruction convert another CDP instruction accommodate longer sequence conversion compress thumb compression technique implement grain thumb conversion heuristic convert function thumb replaces frequently thumb instruction instruction critic implement critic mechanism described earlier hoist identify critic sequence instruction convert format amenable conversion opp critic combine critic critic sequence instruction opp others approach opportunistically leverage thumb format opp benefit average opportunistically transform thumb format speedup percentage dynamic instruction convert format baseline smartly employ thumb format compress yield speedup opp compress agnostic critical instruction chain fetch StallForI whenever without hoist dependent instruction chain hence technique benefit critic optimization critic convert around instruction dynamic format opp compress respectively clearly identify critical instruction sequence optimization instead blindly instruction precludes optimization instruction critic opp critic scheme speedup critic alone VI related criticality instruction criticality important criterion selectively optimize instruction prior revolve around identify critical instruction metric fanout  execution latency slack execution graph representation optimize identify technique critical load optimization backend optimization critical instruction potentially employ optimization mobile apps mobile apps data dependent cluster occurrence critical instruction ensemble optimization consideration individually optimize instruction chain ensemble prior specifically processor identify extract dependence chain however technique fairly extensive hardware identify chain optimize technique KB SRAM incurs additional suitable resource constrain mobile socs contrast entirely software approach identify dependence chain software approach optimize intelligently employ thumb compression mechanism optimization mobile platform significant recent optimize mobile cpu execution optimization target specific domain web browser others address overall efficiency unlike approach optimization provision cpu hardware optimize specific app domain amongst mobile apps bottleneck fetch stage pipeline considerable reward target stage fetch stage bottleneck extensively address processor numerous technique smart cache management prefetching prediction instruction compression simd VLIW vector processing etc however extensive hardware mobile platform conducive software employ trick hoist thumb conversion critical instruction extract performance hardware mechanism mobile processor evolve incorporate hardware optimize fetch stage critic software approach synergistically integrate significantly boost improvement spirit prior instruction compression quantitatively identify critical chain hoist instruction selectively compression software profile mobile platform software profile framework propose library usage app source advertisement model dynamic instrumentation mechanism developer debug optimization etc extend profile compilation phase described built  emulation gem hardware simulator profile compiler code transformation vii conclusion target enhance performance application mobile apps prevalent user driven traditional server scientific workload context mobile apps unique characteristic volume critical instruction sequence dependent instruction attractive exploit criticality optimization technique instead introduce concept CritICs granularity exploit criticality apps novel profiler driven approach identify CritICs hoist aggregate exploit exist ISA thumb instruction format compiler pas boost fetch bandwidth application profile identification CritICs hoist instruction transformation thumb format evaluate google tablet gem simulator estimate performance benefit evaluation popular mobile apps propose average speedup reduction consumption baseline hardware propose technique synergistically integrate optimization hardware prefetching opportunistically convert instruction thumb format benefit