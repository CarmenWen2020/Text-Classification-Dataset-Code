non volatile random access memory NVRAM technology closing performance gap traditional storage memory however integrity persistent data structure  shutdown remains concern commonly ensure consistency NVRAM imposes significant performance overhead additional extra data NVRAM goal eliminate extra writes achieve consistency ssp exploit novel cache remapping mechanism eliminate redundant data NVRAM minimizes storage overhead consolidation remove failure atomicity overhead critical significantly improve performance NVRAM evaluation demonstrate ssp reduces overall traffic reduces extra NVRAM writes critical improves transaction throughput CCS CONCEPTS information phase memory computer organization reliability keywords shadow sub NVRAM failure atomicity introduction non volatile random access memory NVRAM become reality technology stt ram pcm  memory  dram performance disk persistence recently intel announce optane DC persistent memory facilitate acceptance NVRAM storage tier NVRAM memory bus persistent memory introduces storage interface application cpu load instruction directly storage medium model remove maintain data format memory storage program streamline reduce overhead instance avoid serialization deserialization memory data structure data persistent memory survives cycle model mechanism ensure persist data reusable preserve application consistency presence failure durable transaction straightforward abstraction consistency programmer specify code failure atomic update within failure atomic guaranteed execute  prior failure atomicity persistent memory focus challenge limited endurance NVRAM dram latency overhead introduce guarantee failure atomicity memory fence flush inability amortize overhead operating byte addressable NVRAM prior approach challenge technique ahead structure shadow ahead ensures storage consistency explicit data copying previous employ grain avoid unnecessary memory bandwidth consumption unfortunately granularity redundant writes introduce bandwidth overhead additional structure maintain data adjust mapping reference furthermore structure approach usually maintains mapping data reduce capacity overhead mapping comparison actual data unfortunately introduces fragmentation writes introduces garbage collection overhead incur nand flash flexible hence complex mapping scheme reduce otherwise prohibitive metadata micro october columbus usa overhead persistent memory approach relies shadow optimization leverage   modify data however unmodified data render approach inefficient update introduce hardware friendly remapping mechanism shadow reduce extra NVRAM writes avoid extra data copying within critical propose shadow sub ssp cache remapping metadata overhead approach cache actively update atomic update transaction commit involves update  metadata bitwise operation extra data movement critical extend translation lookaside buffer tlb hardware ssp semantics minimize processor core avoid address remapping overhead ssp leverage observation  instead duplicate writes approach ssp consistently update amount meta data NVRAM metadata actual data redundant traffic concern exist NVRAM almost completely avoid however ssp challenge metadata atomically consistent address lightweight metadata journaling ssp introduces memory capacity overhead address via consolidation nutshell approach virtual NVRAM memory tlb ssp maintains physical mapping persistent writes apply alternatively ssp switch mapping failure atomic transaction instead perform  per granularity ssp maintains additional meta information cache basis within finally evict tlb ssp performs consolidation merge physical consolidation ssp introduces redundant writes observation however transaction tlb eviction application allows ssp batch redundant writes NVRAM significant decrease overall writes consolidation perform background ssp remove overhead failure atomicity performance critical summary contribution propose efficient remapping technique avoids inefficiency shadow modification cache granularity propose metadata journaling preserve consistency propose consolidation storage evaluate ssp improve performance micro benchmark workload remainder organize background persistent memory durable transaction exist atomicity technique highlight ssp describes architecture ssp detail evaluates finding discus related concludes background motivation motivate background persistent memory review exist failure atomicity mechanism persistent memory legacy model data application buffer fsync data storage medium focus NVRAM style program model application directly access storage medium persistent memory processor load instruction ensure durability instruction cache emerge memory technology nvm style program model unique opportunity reduce persist data enables leverage byte addressable representation data persistence leverage virtual memory indirection efficient address remapping scheme requirement persistent memory transaction database community define transaction atomicity consistency isolation durability acid define requirement enable failureatomic transaction failure atomic transaction consist multiple persistent writes partially transaction abnormal termination violation application semantics persistent writes within transaction perform fashion refer atomicity consistency application specific update perform transaction user define advance consistent another multi core environment concurrent thread expose update incomplete transaction refer isolation finally durability update non volatile storage NVRAM transaction acknowledge non trivial requirement persistent memory likely volatile cache possibly dram performance flush operation utilized dirty data cache persistent memory focus enforce ACD programmer lock transactional memory ensure isolation concurrent thread transactional memory combine failure atomic transaction future drawback exist crash atomicity technique storage traditionally ensure crash consistency technique ahead shadow ssp eliminate redundant writes failure atomic NVRAMs via shadow sub micro october columbus usa extra writes persistence overhead instruction overhead software redo undo   LSNVMM SCSP ssp summary exist failure atomicity mechanism structure examine technique persistent memory transaction summary exist failure atomicity mechanism discus detail ahead whenever data overwritten data data NVRAM persist NVRAM data update guarantee failure data recover variant implementation investigate academia implementation twice nvm writes perform twice actual data prior approach technique minimize software overhead reduce impact overall performance software entail significant instruction overhead software undo excessive flush instruction ensure update data update software redo memory intercept redirect redo obtain hardware therefore introduce performance  hardware undo update critical atomic update dependency update data update hardware  hardware redo improves upon previous decouple data update transaction commit modify cache persistent memory overlap execution non transactional code transaction however  commit redundant writes NVRAM remains critical delay subsequent transaction reduce overall performance shadow shadow performs creates memory update atomically update persistent virtual physical address mapping failure atomic sequence  redesign traditional shadow  filesystem circuit shadow SCSP SCSP optimization portion data applies byte atomic update avoid propagate  SCSP suitable file workload file data update tend persistent memory access perform byte granularity render unsuitable persistent memory structure structure update data instead append newly data continuously update mapping logical address physical storage unique challenge  persistent memory limit overhead mapping mapping refer  data persistent memory however grain byte granularity introduces fragmentation garbage collection overhead utilize structure non volatile memory LSNVMM proposes sophisticated remapping mechanism allows update perform varied granularity mapping LSNVMM implement partition array skip node cache hashtable employ reduce traversal despite optimization capacity overhead mapping instruction overhead significant data access sub microsecond latency ssp introduce ssp introduce program model discus concept ssp introduce technique metadata journaling consolidation conclude discussion program model ISA extension adopt program model propose mnemosyne programmer construct atomic define failure atomic update inside persist fashion persistent keyword annotate pointer persistent data furthermore extend ISA instruction atomic atomic define failure atomic instruction atomic hint conduct atomic fashion atomic atomic memory barrier atomic instruction address transaction flush NVRAM commit compiler modify translate software interface atomic persistent pointer ISA instruction interface resembles interface intel tsx   transaction intel tsx replace lock ensure thread synchronization guarantee durability future investigate integrate ssp hardware transactional memory unified interface acid transaction assume isolation thread guaranteed lock grab lock operation perform thread prevent intermediate micro october columbus usa shadow sub conventional shadow suffers operates cache  entire address challenge propose shadow sub technique update finer granularity cache shadow sub inspiration ptm technique extension failure atomicity persistent memory ssp abstraction shadow sub ssp persistent  version shadow ssp perform atomic update active virtual associate physical active tlb inactive physical consolidated efficiency refer physical extra physical besides physical ssp bitmap actively update specifically cache virtual update commit bitmap refers cache offset bitmap access perform critical cached tlb explain metadata defines recent version data refer virtual address currently mapped physical update whenever cache reset commit update bitmap transaction commit defines currently contains commit version cache transaction cache transaction ssp performs task atomically correspond update transaction apply cache resides instance commit cache invert recent transient version cache ssp specific virtual cache currently whenever target cache already simply update cache commit failure atomic transaction ssp persists cache flush NVRAM cache already persist transaction evict cache ssp failure writes overwrite commit data furthermore commit sequence update bitmap atomically commit speculative update lastly commit bitmap persist failure bitmap recover approach explain suffers cache virtual address currently mapped cache  update apply costly option cache cache however virtually reduce thread update bitmap thread update bitmap  bitmap commit bitmap tlb hardware volatile NVRAM commit invalid speculative update thread speculative update thread metadata ssp thread private update bitmap thread bitmap virtual  commit bitmap preserve consistent  VA VB VA VB commit bitmap NVRAM VA VB commit bitmap NVRAM VA VB commit bitmap NVRAM atomic update update update update address update commit bitmap VA update commit bitmap VB consistent inconsistent consistent code address layout consistency ssp commit consist update multiple commit bitmap NVRAM failure inconsistent cache address issue technique instead perform  directly apply cache however atomically tag already flush NVRAM previous commit approach metadata storage per bitmap checked update critical prior extend tlb hardware cache extra metadata ssp specifically physical update bitmap bitmap tlb hardware thread core update bitmap transaction commit abort modification isolation ensure memory thread bitmap virtual discus ensure coherence bitmap core guarantee data previously commit transaction retrieve cycle per commit bitmap  NVRAM update commit ssp eliminate redundant writes failure atomic NVRAMs via shadow sub micro october columbus usa metadata journaling preserve atomicity data update transaction span multiple update commit bitmap atomically transaction commit scenario code specifies cache update atomically commit involves update commit bitmap VA VB however update commit bitmap perspective memory controller crash update VA visible recovery violates atomicity metadata journaling ensure atomicity update metadata ssp metadata journaling approach redo however ssp metadata data conventional redo update per metadata appends entry operation entry contains ID commit bitmap persist meta transaction NVRAM ssp update per commit bitmap metadata detail implementation metadata journaling data journaling redo undo modify data typically byte ssp journaling lightweight metadata modify consolidation associate virtual physical capacity overhead address ssp consolidates physical whenever virtual actively tlb ssp resident tlb transaction consolidate cached without tlb mapping commit invalid consolidation valid data virtual likely distribute across associate physical minimize data copying overhead identify physical contains valid cache valid data physical easily compute valid cache counting correspond commit bitmap finally update virtual physical mapping virtual refers physical valid data another issue address accurate identification inactive virtual important premature consolidation actively update unnecessary data copying overhead reuse tlb hotness virtual reference tlb entry inactive inactive consolidated eagerly immediately detect lazily demand memory resource implementation consolidate inactive eagerly investigate lazy consolidation future discussion virtually indexed cache ssp seamlessly physical virtually indexed physically tag cache ssp virtually indexed cache extend tag TX cache modify transaction modify cache memory TX allows shadow sub distinguish transactional cache regular cache transactional cache leverage ssp remapping prevent overwrite commit data access extend tlb ssp locates mapping cache superpages superpages commonly increase coverage tlb superpages ssp challenge due per metadata overhead instance MiB cache bitmap byte unpractical tlb entry bitmap ssp currently KiB however technique transparent superpages cluster linux extend ssp coexistence superpages automatically  superpages update promote superpages become inactive approach superpages data tlb hardware superpages ssp coexist processor vendor split TLBs ssp tlb extension KiB limitation ssp limitation transaction transaction update tlb ssp abort transaction revert transfer programmer define handler implement unbounded software redo undo ensure atomicity ssp handle medium transaction efficiently exist commercial HTMs ssp architecture depicts architectural detail ssp per metadata ssp contains persistent commit bitmap volatile bitmap manage memory controller ssp cache extend tlb hardware cache bitmap update bitmap physical core extend handle atomic update cache cache tag update update atomically transaction commit core cache modify issue metadata update instruction modify memory controller memory controller performs metadata journaling ensure atomicity metadata update furthermore memory controller status ssp cache conduct consolidation architectural extension extension cpu hardware propose architectural extension facilitate ssp adopt wider tlb entry cache physical micro october columbus usa VPN ppn ppn bitmap cpu cache cpu core extend tlb metadata journaling tid sid commit bitmap VPN bitmap update bitmap transient data persistent data journal cache journal memory NVRAM dram commit bitmap mem ctrl ssp cache commit bitmap bitmap tlb core architecture ssp update bitmap bitmap cpu cache tag data update flip fetch data NVRAM update cache tag update atomic update ssp update fourth cache generate data cache  bitmap update bitmap modify tlb core conduct obtain physical afterwards interacts memory controller fetch ssp specific metadata index physical bitmap update bitmap initialize zero memory address translation virtual address translate correspond access cache remainder memory access remains unmodified atomic update ssp handle atomic update assume cache allocate policy atomic update described shadow sub data load cache cache remapped tag cache update cache update data flip transaction modify cache associate another evict cache anytime without worry overwrite commit NVRAM conduct remapping bitmap coherent across core memory controller straightforward perform tlb shootdown however tlb shootdowns incur significant overhead instead adopt approach propose overlay exploit cache coherence network guarantee coherency tlb entry bitmap cache coherence network extend message flip cache update transaction zero flip  message broadcast via cache coherence network notify core memory controller flip correspond cache  flip invalidation message approach trivially extend directory cache coherency protocol broadcasting impose minimal overhead overall previous typical PM workload portion access PM majority dram moreover broadcast operation PM modify cacheline transaction transaction commit durable transaction guarantee data persistence commit request acknowledge commit ssp involves data persistence metadata update atomic update ensure data persistence update cache transaction commit instruction clwb cache modify commit transaction commit transaction tracked update bitmap extend tlb commit update commit bitmap NVRAM extend interface memory controller metadata update instruction update identify update buffer pas information ID update bitmap memory controller metadata update instruction memory controller perform journaling ensure atomicity metadata update metadata update instruction memory controller without cache ensure data persistence metadata update crash atomic metadata update speculative update discard recover consistent memory controller extension ssp architecture memory controller centralize storage metadata performs consolidation metadata journaling furthermore responsible manage physical allocate ssp eliminate redundant writes failure atomic NVRAMs via shadow sub micro october columbus usa bound tlb entry consolidation ensures freed become inactive metadata storage ssp associate virtual additional metadata additional active extension entry instead memory controller maintains ssp cache separately ssp related metadata ssp cache entry contains detail regard actively update physical ppn ppn consistent commit bitmap bitmap TLBs cached translation tlb reference core update core reference information physical commit bitmap  bitmap core tlb reference transient recovery whenever ssp cache entry access tlb ssp cache consult physical memory controller insert entry ssp cache replacement algorithm ssp cache straightforward memory controller evict entry contains already consolidated commit bitmap zero reference tlb tlb reference zero ssp cache accord tlb core instance core entry TLBs ssp cache  factor accommodate consolidated rationale maximum concurrent transaction transaction entry  consolidated tlb request rare cache entry reserve resize ssp cache request OS management initialization OS reserve continuous NVRAM physical pas address memory controller register memory controller associate entry ssp cache extra physical extra physical utilized virtual assign entry reuse entry assign virtual data extra persist consolidation overcome uneven memory controller exchange per slot extra physical consolidation ssp decides eligible consolidation accord information tlb cached ssp cache entry specifically tlb reference consolidate tlb reference increase core fetch ssp cache entry memory controller decrease core evicts ssp cache entry tlb memory controller detects reference counter zero entry physical commit bitmap insert consolidation queue OS thread conduct consolidation background tlb entry insert minimal delay consolidated consolidation thread insert entry queue notify controller reserve ssp cache entry status consolidated rare request tlb consolidation response delayed consolidation metadata journaling multi transaction multiple update metadata commit bitmap metadata journaling intention update ssp cache transaction ID tid ID cache slot modify sid physical commit bitmap tid assign memory controller uniquely identify metadata update transaction sid compute physical address slot address ssp cache upon metadata update instruction memory controller generates appends metadata journal journaling NVRAM cache granularity buffer explicit request flush buffer checkpointing limit growth journaling bound recovery memory controller perform checkpointing update persistent ssp cache recent consistent snapshot journaling background OS thread checkpointing pointer appends journal applies persistent ssp cache advance pointer journal checkpointing thread capture modify cache entry persistent cache architecture detail discus optional detail improve efficiency implementation ssp buffer update bitmap tlb entry along physical bitmap albeit straightforward entail burst non transactional access transaction tlb entry update bitmap non zero evict impossible transaction address issue buffer update bitmap buffer ongoing transaction commit decouple update bitmap tlb evict tlb ongoing transaction per core reference per reference increase upon flip  specific core upon metadata update instruction non zero core reference consolidation cache eviction ssp cache organization transient runtime information reference update frequently ssp cache NVRAM unnecessary ssp cache organize transient ssp cache dram persistent ssp cache NVRAM transient cache employ request core persistent cache serf micro october columbus usa backup recovery persistent metadata physical commit bitmap persistent cache leverage faster memory hierarchy portion cache ssp cache megabyte cache cache ssp cache entry sensitivity access latency ssp cache evaluation hardware complexity hardware overhead extend tlb entry buffer typical KiB byte cache cache per bitmap physical tlb entry across entry tlb overall expand tlb byte tlb consideration entry tlb another kilobyte buffer entry tag bitmap entry buffer therefore byte overall hardware kilobyte identify opportunity address hardware overhead conservatively assume ideal granularity ensure persistence byte cache granularity however disclose recent preferable granularity persist data intel optane DC persistent memory byte utilize sub bitmap reduce significantly reduce overhead tlb entry furthermore recent intel ibm processor htm htm transactional per cache speculative update reuse transactional eliminate update bitmap complexity performance reduce hardware complexity modification tlb hardware implement ssp mapping userspace however imposes significant instruction overhead load intercept similarly software transactional memory avoid tlb coherence network tlb shootdowns instead however tlb shootdown procedure involves trap OS issue inter interrupt impose significant performance overhead implementation serf baseline explore viability ssp alternative prior discloses optane persistent memory embeds address indirection achieve leveling management indirection layer opportunity incorporate functionality ssp entirely inside PM controller significantly reduce complexity without sacrifice performance recovery upon restart  shutdown ssp performs recovery rebuilds transient ssp cache persistent metadata persistent cache specifically physical commit bitmap reload directly persistent cache processor OoO core ghz issue retire rob entry load queue DTLB entry LI L1D KiB byte cycle KiB byte cycle MiB byte cycle dram GiB channel per rank KiB  NVRAM GiB channel per rank KiB  parameter description rbtree rand insert delete node random workload btree rand insert delete node random workload hash rand insert delete node hashtable random workload SPS swap array rbtree zipf insert delete node zipfian workload btree zipf insert delete node zipfian workload hash zipf insert delete node hashtable zipfian workload memcached  workload generator client vacation client tuples evaluate microbenchmarks average cache modify average modify maximum modify consists atomic update within transaction bitmap initialize commit bitmap transient reference counter initialize zero furthermore transient cache update recent consistent snapshot replay metadata journal whereas entry aborted transaction skip evaluation experimental setup implement ssp  cycle accurate simulator architecture integrate DRAMSim  detailed memory simulation DRAMSim extend model hybrid memory dram NVRAM memory bus parameter simulated machine execution entry DTLB cache nvdimm ssp eliminate redundant writes failure atomic NVRAMs via shadow sub micro october columbus usa btree rand rbtree rand hash rand SPS btree zipf rbtree zipf hash zipf tps normalize undo redo ssp thread btree rand rbtree rand hash rand SPS btree zipf rbtree zipf hash zipf tps normalize undo redo ssp thread performance micro benchmark btree rand rbtree rand hash rand SPS btree zipf rbtree zipf hash zipf writes normalize undo redo ssp comparison writes simulation methodology simulate impact consolidation data persistence   model impact ssp tlb cache coherency tlb flip message tlb access persistent heap latency access ssp cache model workload accord ssp cache ratio latency cycle dram latency cycle extra cycle cycle understand impact latency ssp cache access conduct sensitivity reserve cache ssp cache ssp cache entry benchmark evaluate microbenchmarks workload microbenchmarks commonly data structure btree described workload byte integer data structure update insert delete swap wrap inside durable transaction benchmark btree rbtree hash delete insert absent access workload distribution rand zipf denote random workload zipfian workload zipfian workload update apply generate prior evaluate application memcached memory cache vacation emulates OLTP prior publish persistent memory aware version application merely replace durable interface characterization benchmark none evaluate application writes transaction entry buffer sufficient accommodate workload none evaluate application unbounded evaluate ssp tune optimal parameter buffer conventional shadow transaction cache average conventional shadow degrades performance cache undo naive hardware undo mechanism atomic generate entry entry persistent memory undo repeatedly update multiple generate entry update employ buffer avoid redundant entry redo hardware redo allows overlap data persistence non transactional code transaction commit besides employ buffer predict cache avoids redundant entry  transactional throughput performance microbenchmarks ssp outperforms undo redo average thread workload improvement mainly ability ssp reduce overhead ssp decrease traffic respectively undo undo btree rand workload ssp nearly eliminates writes improvement transactional throughput btree benchmark exhibit spatial locality cache modify minimizes writes introduce metadata journaling performance thread ssp ssp micro october columbus usa btree rand rbtree rand hash rand SPS btree zipf rbtree zipf hash zipf NVRAM writes normalize undo redo ssp comparison NVRAM writes btree rand rbtree rand hash rand SPS btree zipf rbtree zipf hash zipf writes data journaling consolidation checkpointing breakdown NVRAM writes ssp NVRAM writes NVRAM latency tps undo redo ssp rbtree NVRAM latency tps undo redo ssp btree sensitivity latency NVRAM axis NVRAM latency multiple dram latency latency cycle improvement btree rand rbtree rand hash rand SPS btree zipf rbtree zipf hash zipf sensitivity latency ssp cache axis speedup redo improve performance undo redo average respectively NVRAM writes ssp baseline NVRAM writes observation ssp traffic undo redo average undo redo essentially data twice although consolidation extra writes ssp  operation modify data immediate operation transaction commit instead additional writes active inactive transaction frequency frequency become inactive ssp effectively batch additional writes failure atomicity breakdown NVRAM writes ssp writes consolidation data writes workload SPS locality workload affect NVRAM writes benchmark zipfian access btree zipf rbtree zipf hash zipf ssp average reduce traffic undo redo contrast random workload unified distribution ssp traffic undo redo workload locality extra writes consolidation negligible demonstrates ssp efficiently prevent premature consolidation minimize consolidation overhead zipfian workload sensitivity latency NVRAM transaction throughput memory latency brevity representative workload overall performance ssp baseline degrade NVRAM latency increase however gap ssp ssp eliminate redundant writes failure atomic NVRAMs via shadow sub micro october columbus usa undo redo memcached vacation performance improvement benchmark memcached vacation undo redo memcached vacation traffic benchmark memcached vacation increase speedup redo increase benchmark btree ssp minimizes writes sensitive NVRAM latency NVRAM dram redo outperforms ssp benchmark rbtree persistency overhead dram latency redo hide delay persist data latency ssp cache impact latency ssp cache performance ssp workload besides SPS cache latency limited impact ssp performance moderate linear performance decrease increase latency however latency ssp cache critical benchmark SPS hash rand locality frequent tlb increase frequency access ssp cache zipfian workload sensitive latency ssp cache random explain difference locality expose workload performance workload performance improvement ssp memcached vacation benchmark memcached benchmark ssp throughput improvement undo throughput redolog vacation benchmark ssp improvement undo throughput redo improvement reduction overhead specifically ssp writes undo redo workload average vacation benchmark ssp generates improvement redo volatile execution contributes overhead vacation benchmark reduction NVRAM writes ssp traffic NVRAM reduction undo redo memcached workload reduction undo redolog memcached workload extra traffic consolidation traffic memcached vacation workload related NVRAM aware data structure focus reduce persistence data structure contrast ssp atomic durable update data structure exist  library NVRAM aware file undo undo shadow durable transaction ssp increase efficiency exist approach prior propose optimization softwarebased failure atomicity mechanism  TX LSNVMM attempt reduce persistency overhead eliminate extra writes critical  TX maintains backup modify data LSNVMM structure approach however technique inefficiency LSNVMM introduces significant instruction overhead maintain additional indirection userspace  TX delay dependent transaction overlap prior transaction DudeTM enjoys benefit redo cpu flush barrier avoid drawback address remapping approach however DudeTM actual data modification apply update persistent storage afterwards comparison ssp costly software mapping imposes delay dependent transaction minimizes extra writes critical recent propose hardware reduce overhead however none address twice introduce suffer performance degradation extra traffic critical recent propose hardware relax nvm writes loc proposes architectural modification relax intra transaction inter transaction propose optimization implement durable transaction relax memory persistency proposal orthogonal apply improve propose leverage non volatile cache queue memory controller reduce introduce persistency overhead trivially extend advantage advanced hardware feature previous introduces concept shadow sub preliminary stage performance evaluation beyond technique evaluation overlay aim grain memory management per bitmap proposes wider tlb entry update cache however overlay semantics durable transaction efficiently consolidation transaction commit critical ssp transactional NVRAM update efficiently ssp perform consolidation upon tlb eviction performs consolidation critical ssp preserve consistency metadata recovery leverage lightweight metadata journaling SI TM VM leverage indirection virtual memory efficient snapshot isolation transaction however address durability issue persistent micro october columbus usa memory transaction ptm leverage virtual memory unbounded transactional memory cache mapping semantic reduce copying however beyond address additional challenge enable failure atomicity metadata update introduce consolidation address overhead ptm conclusion propose ssp novel shadow scheme leverage grain cache remapping enable efficient failure atomic transaction ssp eliminates redundant writes introduce prior technique delay application redundant writes via address remapping enable batching reduce overall writes NVRAM introduce cache remapping technique successfully eliminates overhead prior shadow mapping scheme unfeasible moderate tlb hardware addition improve endurance ssp remove redundant writes critical improve transactional performance experimental ssp reduce overall NVRAM writes improve performance hardware