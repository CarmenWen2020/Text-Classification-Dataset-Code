gradient become increasingly important computer graphic machine computer vision ability compute gradient crucial optimization inverse render gradient respect variable camera parameter source scene geometry appearance however compute gradient render challenge render integral visibility differentiable previous differentiable render focus approximate handle secondary shadow global illumination gradient respect variable pixel coordinate introduce purpose differentiable ray tracer knowledge comprehensive compute derivative scalar function render image respect arbitrary scene parameter camera scene geometry parameter novel sample algorithm directly sample dirac delta function introduce derivative discontinuous integrand develop efficient importance sample spatial hierarchy generate gradient scene complexity desire precision interface differentiable ray tracer library pytorch prototype application inverse render generation adversarial neural network CCS concept compute methodology ray trace visibility reconstruction additional ray trace inverse render differentiable program introduction computation derivative increasingly central computer graphic computer vision machine critical optimization inverse role via backpropagation creates render algorithm differentiate respect arbitrary input parameter camera location direction scene geometry appearance texture unfortunately render integral visibility differentiable boundary whereas image function usually differentiable radiance integrate pixel  source etc integrand render algorithm derivative acm trans graph vol article publication date november  mao miika aittala frédo durand jaakko lehtinen integrand dirac delta occlusion boundary cannot handle traditional sample strategy previous differentiable render focus approximate simpler render model handle primary visibility ignore secondary shadow indirect analytical exist diffuse  generalize arbitrary model exception differentiates respect image coordinate whereas derivative respect arbitrary scene parameter previous usually relies finite difference limitation function complex namely configuration propose comprehensive transport equation propose algorithm knowledge compute derivative scalar function  render image respect arbitrary input parameter camera geometry etc stochastic monte carlo ray trace introduce technique explicitly sample addition solid angle sample traditional approach spatial acceleration strategy importance sample efficiently sample sample derivative arbitrary bounce transport precision overhead roughly render image alone integrate differentiable ray tracer automatic differentiation library pytorch efficient integration optimization approach scene geometry camera parameterized pytorch tensor enables complex combination 3D graphic transport neural network backpropagation seamlessly across pytorch renderer related inverse graphic inverse graphic technique seek scene parameter image vision inverse graphic computer graphic vision technique inverse graphic utilize derivative render inference blanz vetter optimize texture   optimize perceptual metric focus scatter parameter interested spatially propose jointly optimize illumination reflectance aim photograph fabric approach utilize gradient inverse develop specialized solver compute gradient specific transport scenario interested  propose differentiable render pipeline focus performance approximate primary visibility gradient multiple inside pixel assume lambertian compute shadow global illumination recently increasingly popular incorporate differentiable render layer architecture render layer usually purpose handle geometric discontinuity primary visibility shadow knowledge differentiate tracer geometric discontinuity account derivative render analytical derivative compute footprint predict specular derivative usually manually derive focus generalize arbitrary model unlike compute gradient hybrid approach automatic differentiation manually derive derivative focus discontinuous integrand  propose analytical compute spatial gradient irradiance clip mesh correctly integrate factor scene complexity impossible compute integration arbitrary analysis transport highly related derivation generalizes differentiate respect scene parameter furthermore handle primary visibility secondary visibility global illumination irradiance radiance cache numerically computes gradient  respect spatial orientation receiver discontinuity account resort stratify sample unlike estimate gradient integral directly automatic differentiation sample propose variant metropolis transport algorithm compute hessian contribution respect parameter automatic differentiation geometric discontinuity account task 3D scene continuous parameter camera scene geometry parameter generate image trace algorithm scalar function compute acm trans graph vol article publication date november differentiable monte carlo ray trace sample sample sample pixel overlap interested compute derivative pixel respect increase pixel background traditional sample sample automatic differentiation account addition traditional sample propose novel sample algorithm sample sample differential computes unbiased gradient correctly occlusion account image loss function optimize goal backpropagate gradient scalar respect scene parameter pixel formalize integration pas pixel filter monte carlo sample estimate integral gradient integral however integrand discontinuous due geometry occlusion traditional sample correctly capture due camera parameter vertex movement mathematically gradient discontinuous integrand dirac delta function therefore traditional sample zero probability capture dirac delta strategy compute gradient integral split smooth discontinuous smooth integrand  shade bilinear texture reconstruction employ traditional sample automatic differentiation discontinuous novel sample capture boundary subsection focus primary visibility integrate 2D screen domain generalize handle shadow global illumination focus mesh assume mesh preprocessed  assume source perfectly specular approximate source BRDFs roughness focus static scene integration dimension blur future primary visibility focus 2D pixel filter integral pixel integrates pixel filter radiance radiance another integral integrates source hemisphere generalize handle discontinuity inside radiance integral pixel zero contribution occlusion split  increase decrease integrate compute gradient account compute integration sample compute difference compute handle occlusion correctly occlude sample continuous contribution function contribution grey sample zero contribution gradient  notational convenience combine pixel filter radiance scene function interested gradient integral respect parameter scene function mesh vertex  integral usually complex non lambertian BRDFs involve therefore rely monte carlo integration estimate pixel however cannot naive approach apply monte carlo sampler estimate gradient scene function necessarily differentiable respect scene parameter observation discontinuity allows explicitly integrate discontinuity 2D split model heaviside function upper defines equation endpoint construct equation upper vice versa endpoint plug endpoint obtain  acm trans graph vol article publication date november  mao miika aittala frédo durand jaakko lehtinen rewrite scene function summation heaviside function equation arbitrary function   heaviside function defines multiplication heaviside function integral source hemisphere crucial later generalization secondary visibility analytically differentiate heaviside function explicitly integrate derivative dirac delta function swap gradient operator inside integral integral    equation estimate gradient monte carlo estimator estimate integral dirac delta function estimate pixel integral smooth function replace gradient compute automatic differentiation estimate integral dirac delta function eliminate dirac function perform variable substitution rewrite dirac delta function integral integrates    gradient equation respect jacobian variable substitution account gradient equation  byproduct derivation obtain screen gradient potentially facilitate adaptive sample analysis obtain gradient respect parameter camera parameter 3D vertex vertex normal propagate derivative project vertex chain desire parameter monte carlo sample estimate dirac integral equation recall defines equation therefore compute combine equation equation monte carlo estimation dirac integral probability employ smooth shade continuous dirac integral zero definition continuity silhouette non zero contribution gradient project mesh screen clip camera  silhouette probability proportional screen uniformly handle occlusion correctly sample another continuous contribution function sample zero contribution gradient illustrates recap sample strategy estimate gradient integral pixel filter equation discontinuous integrand equation continuous equation compute gradient discontinuous explicitly sample compute difference monte carlo sample equation secondary visibility easily generalize handle shadow global illumination integrate 3D scene illustrates focus shade propagate derivative screen camera parameter equation shade shade equation involves integration scene manifold scene function response geometric factor incoming radiance visibility pixel integrand previous equation therefore propagate gradient chain automatic differentiation equation acm trans graph vol article publication date november differentiable monte carlo ray trace sample source blocker shade secondary visibility scene width correction easily generalize handle shadow global illumination primary visibility geometry shade split 3D introduces discontinuity assume blocker integrate compute difference account increase blocker decrease source shade integration define intersection scene manifold shade semi transparent orientation  width differs scene intersects integration project scene width onto ratio width sin normal scene primary visibility 3D introduces function scene function derive function shade dot vector normal determines equation therefore define compute gradient analogously apply derivation primary visibility 3D version equation equation replace integral integrate scene analogous equation normal crucial difference 3D integral equation previous screen integral equation screen integral coincides 2D 3D integral projection shade scene manifold semi transparent illustrates projection extra correction project scene onto infinitesimal width integrate 3D integral monte carlo sample substitute variable parameter jacobian 3D vector projection onto scene manifold respect parameter derive jacobian appendix derivative compute integral efficient monte carlo sample secondary involve unlike primary visibility viewpoint shade anywhere scene consequence sophisticated data structure prune zero contribution describes importance sample importance sampling  sample described sample scene fold sample sample efficiently typically contribute gradient silhouette solid angle naive sample fail important non zero contribution exists highly specular mention primary visibility easy viewpoint camera project onto screen preprocessing pas silhouette respect camera sample distance screen uniformly sample screen secondary visibility complicate viewpoint anywhere scene response viewpoint account scalable implementation sample arbitrary viewpoint inspire previous sample source hierarchical data structure efficient data structure silhouette recent linear source hierarchical sample shade task importance sample factor account acm trans graph vol article publication date november  mao miika aittala frédo durand jaakko lehtinen scene importance  importance  importance  importance  comparison sample without importance sample algorithm scene shadow global illumination specular reflection per pixel derivative average respect bunny derivative respect reflect  logo gradient inset texture derivative resolve without importance sample overhead sample however without importance sample capture rare shadow cast specular reflection extremely variance gradient geometric  factor proportional inverse distance response shade radiance incoming direction source hierarchy contains associate mesh smooth shade normal contains remain 3D bound volume hierarchy 3D endpoint 6D bound volume hierarchy endpoint normal associate rejection non silhouette node hierarchy cone direction angle normal direction alternative 3D hierarchy   opt simplicity previous directional component diagonal scene bound construction split dimension extent traverse hierarchy sample source usually significant source contribution therefore traverse hierarchy twice traversal focus overlap cone  source shade traversal sample combine sample multiple importance sample cone intersection quickly discard intersect source traversal node hierarchy compute importance traverse upper bound estimation contribution  algorithm estimate bound inverse distance  BRDF importance zero node silhouette traverse shade inside bound BRDF bound threshold angle  cone threshold importance sample oftentimes highly specular BRDF portion significant contribution employ recent technique integrate linear source linearly transform cosine distribution  integral linear source BRDF geometric  numerically invert integrate cumulative distribution function newton importance sample precompute linearly transform cosine BRDFs evaluate sample comparison baseline approach uniformly sample baseline acm trans graph vol article publication date november differentiable monte carlo ray trace sample initial target optimize primary occlusion shadow camera glossy glossy receiver specular global illumination verify renderer synthetic scene transport configuration scene initial parameter attempt scene parameter render target gradient optimization scene intend aspect renderer optimizes presence occlusion optimizes blocker shadow optimizes camera parameter textured glossy optimizes blocker shadow receiver highly glossy optimizes almost specular reflection camera parameter optimizes camera presence global illumination shadow generate gradient scene optimize parameter correctly minimal difference optimize target scene render sample per pixel optimization rendering sample per pixel sample encourage reader refer supplementary video scene approach efficiently sample rare shadow cast source specular reflection importance sample generates image variance RESULTS implement alone renderer interface automatic differentiation library pytorch user construct scene pytorch tensor vertex index float integer tensor renderer pas output image pytorch tensor user compute scalar loss output image obtain gradient  scene parameter inside renderer operator overload approach automatic differentiation  library ray cast operation renderer pinhole camera planar  spherical projection lambertian   BRDFs  approximation fresnel reflection bilinear reconstruction texture diffuse specular reflectance roughness source mesh verification synthetic scene variety occlusion non lambertian global illumination scene initial parameter optimize parameter minimize difference render image target image gradient generate living scene optimize difference gaussian pyramid render image target image pytorch interface allows apply stock optimizers backpropagate scene parameter easily adam algorithm optimization parameter renderer generate gradient optimizer infer scene handle transport scenario vertex optimize optimization blocker acm trans graph vol article publication date november  mao miika aittala frédo durand jaakko lehtinen image finite difference shadow  central finite difference render scene scene slightly adjust per pixel gradient clearer image derivative respect rightmost vertex shadow blocker camera screen derivative finite difference within error relative norm gradient finite difference usually magnitude sample error sample per pixel scene sample per pixel scene finite difference sample per pixel scene sample per pixel shadow joint optimization camera parameter estimation presence global illumination optimize blocker occlude highly glossy reflection invert specular reflection supplementary central finite difference resolution version synthetic scene derivative finite difference within error relative norm gradient comparison roughly quality increase sample finite difference error finite difference visibility gradient correctly usually magnitude sample error addition finite difference parameter impractical optimization task demonstrates convergence visualize gradient bunny scene sample per pixel gradient average pixel respect bunny screen spp spp spp spp visualize per pixel gradient contribution generate sample per pixel bunny scene gradient average respect bunny sample per pixel image around compute core machine usually sample per pixel inverse render generate converge sample per pixel image around core machine render converge image optimization utilize stochastic gradient descent render sample image usually comparison previous differentiable renderers subsection previously propose differentiable renderers  neural 3D mesh renderer previous focus approximate gradient lambertian  contrast output unbiased gradient arbitrary non dirac shadow global illumination  neural 3D mesh renderer approach render buffer traditional  buffer approximate derivative respect screen vertex render buffer  performs screen filter approach brightness constancy assumption filter boundary detection ID horizontal derivative pixel occlusion boundary kernel pixel boundary intersect boundary occlusion acm trans graph vol article publication date november differentiable monte carlo ray trace sample planar scene  neural lit interested derivative image respect static derivative zero boundary previous buffer difference approximate derivative unable variation pixel account output non zero derivative output derivative boundary kernel neural 3D mesh renderer performs extra rasterization pas accumulates derivative compute difference difference buffer around derivative response modify apply smooth  previous differentiable renderers output incorrect gradient brightness variation pixel due lit inverse distance  renderers compute derivative pixel respect source illumination remains static derivative zero boundary previous renderers difference buffer pixel approximate derivative incorrectly illumination variation output non zero derivative around highlight sample correctly output zero derivative continuous  distance  neural 3D mesh renderer modify renderers renderer pure planar approximate  grid previous renderers  shade inverse render application apply inverse render task fitting camera parameter source intensity scene photo geometry data thesis jones scene validate daylight simulation scene contains indirect illumination non lambertian assign plastic arbitrary camera initial parameter scene gradient optimizer adam gradient generate camera parameter avoid stuck local minimum perform optimization multi fashion linearly increase input scene traffic  iteration  traffic iteration  traffic iteration combine traffic 3D scene adversarial neural network gradient generate optimize geometry camera intensity direction minimize traffic iteration network classifies  iteration traffic prediction plot sum traffic function iteration optimize scene parameter gradient descent geometry minimizes decrease resolution stage loss perform iteration exclude source loss function pixel radiance 3D adversarial recently gradient optimization adversarial neural network analysis mining training data image originally label correctly neural network classifier backpropagation image minimizes network output respect output mining adversarial 3D scene ability backpropagate image scene parameter explore renderer demonstrate classify correctly vgg classifier optimize parameter camera intensity global translation rotation vertex displacement perform stochastic acm trans graph vol article publication date november  mao miika aittala frédo durand jaakko lehtinen gradient descent minimize network output traffic sample per pixel iteration network output  iteration traffic prediction sum probability robust attack neural network CG scene statistic image nevertheless demonstrates gradient scene configuration potentially mining training data limitation performance cpu implementation generate resolution image sample stochastic gradient descent usually sample scene bottleneck sample phase automatic differentiation develop sample algorithm incorporate bidirectional trace avenue future develop compiler technique optimize automatic differentiation code gpu backends important task transport phenomenon assume static scene participate medium differentiate blur sample 4D extra dimension combine handle participate medium future  geometry parallel derivative  mesh splitting derivative  mesh generate simulation handle perfectly align projection camera shadow ray origin however zero perfectly align viewport converge shader discontinuity assume BRDF model shaders differentiable handle discontinuity shaders handle texture correctly differentiate smooth reconstruction widely reflection model  smith mask disney principled BRDF differentiable however handle discontinuity internal reflection BRDFs rely discrete operation discrete stochastic  model compiler technique limit BRDFs apply mitigate shader discontinuity issue conclusion introduce differentiable monte carlo ray trace algorithm capable generate unbiased gradient respect arbitrary input parameter scene geometry camera introduce novel sample algorithm geometric discontinuity consideration derive appropriate conversion increase efficiency discrete hierarchical sample focus relevant continuous importance sample software release impact inverse render