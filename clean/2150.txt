theory efficient quality render unstructured data greatly benefit gpus gpus limited amount memory mesh representation sample reconstruction acceleration structure memory optimize encode unstructured mesh efficiently encodes unstructured mesh correspond sample reconstruction acceleration structure random access sample render demonstrate data encode allows render billion mar lander shelf gpu billion version gpus introduction computational capability rapidly evolve supercomputing improves improve ability simulate around simulation naturally increase computational budget nasa mar lander unstructured mesh consists billion vertex billion finite per thereof compression rate achieve unstructured mesh data ocean  resolution  mar lander  quote memory consumption compress uncompressed version unstructured mesh acceleration data structure allows random access sample representation encodes information uncompressed reference implementation memory compression rate achieve unstructured mesh data ocean  resolution  mar lander  quote memory consumption compress uncompressed version unstructured mesh acceleration data structure allows random access sample representation encodes information uncompressed reference implementation memory structure volume become complex largely unstructured data data commonly predominant format semi structure grid data unstructured finite semi structure data adaptive mesh refinement amr data consist brick grid voxels resolution unstructured finite consist tetrahedron pyramid wedge  twist bend effectively adapt computational domain amr unstructured mesh equally important application prefer vice versa however standpoint visualize compute data difference amr unstructured mesh pronounce amr data code handle conversely unstructured mesh representation relatively standardize easy across unstructured mesh arguably amr representation convert unstructured mesh compute dual mesh vice versa consequently advance quality performance render unstructured mesh benefit unstructured amr code remainder assume truly quality render unstructured data involves sample volume ray march without volumetric scatter combine render embed geometry within context unstructured data apparent issue unstructured mesh implicit structure meaning reconstruct sample expensive location kernel complex incoherent memory access pointer chase code divergence situation unstructured code useful simulation adapt frequency feature compute function consequently amr unstructured data suffer difference feature relative computational domain advanced sample strategy sample resolve feature visualization render model gpus however complicate another obvious memory unstructured mesh scalar mesh topology storage per scalar structure semistructured format mar lander data scalar additional vertex scalar another billion connectivity roughly memory vertex index scalar perform sample reconstruction sample volume render correspond acceleration structure built introduce memory requirement complicate ability benefit gpus situation unstructured mesh visualization processing theory prime candidate gpu acceleration cannot data gpu memory memory footprint unstructured mesh memory efficient focus strategy reduce memory footprint acceleration data structure quality sample ray trace analyze data structure optimize CPUs spends memory adopt strategy reduce memory overhead maintain essentially implicit structure explicit goal encode compact unstructured data everything random access sample onto gpu reduce memory consumption entirely orthogonal sample ray march therefore discussion skip adaptive sample another focus exclusively memory consumption influence propose technique raw sample throughput related render unstructured mesh challenge visualization researcher tackle various challenge involve prior focus render performance memory consumption compression strategy independently holistic approach address challenge specific memory consumption however review relevant across category context challenge involve render data unstructured volume render prior focus challenge involve render unstructured data splatting unstructured frame buffer march align ray excellent survey gpu accelerate technique quality volume render without unstructured typically relies volume ray march originally propose unstructured mesh location interpolate within sample ospray widely source framework scientific visualization performs volume render unstructured mesh approach described  series query per align ray volumetric ray  query traversal bound volume hierarchy acceleration structure combination performance query critical component performance volumetric ray   propose  optimize memory efficient data structure perform query bound interval hierarchy recent leverage ray traversal gpus accelerate optimize query propose  tetrahedral mesh recent extend hardware accelerate concept unstructured mesh consist mixed tetrahedron pyramid wedge  latter handle model memory render data due additional structure acceleration structure compression bound volume hierarchy  become facto standard interactive ray trace naïve encode bvh overall memory limit factor unstructured mesh render typically bvh structure prior sought reduce acceleration structure reduce internal node bvh branching factor demonstrate    wald additionally  compress quantize node bound relative bound fix encode constrain node bound float finite node integer compress bvh compression scheme bvh goal reduce traversal memory traffic trace incoherent ray mesh compression beyond compress acceleration structure prior explore strategy compress mesh data generally unstructured mesh vertex potentially multiple primitive index vertex mesh primitive comprise multiple primitive tetrahedron wedge  primitive index variable vertex lossy approach compress unstructured mesh quantize vertex however unstructured mesh amount memory vertex typically vertex index bvh node saving vertex tends limited consequently compression mesh typically focus compress primitive vertex index vertex orthogonal approach sequential encode propose mesh compression simplification technique employ adaptive tessellation multi approach propose relevant progressive multi resolution mesh compression technique advantage technique mesh progressively decode visualize possibly successive detail propose collapse  tetrahedral incrementally subdivide tetrahedral mesh wavelet decompression scheme decode tetrahedral mesh multi resolution technique efficient encode  mesh although approach detail mesh decode become prohibitively expensive ray march approach render unstructured mesh efficient decode per sample limit encode mesh bvh encode reference  mesh bvh aim improve memory efficient encode unstructured mesh data render sample ray  worth exist random access sample proven effective render unstructured mesh purpose alternative technique orthogonal choice mesh traversal technique ultimately influence choice discus alternative  understand choice implement random access sample unstructured mesh investigate memory layout reference implementation ospray analysis recognize important caveat choice ospray assumption memory pressure severe CPUs ospray adopt efficient bvh encode ospray task implementation cannot ospray choice bvh mesh encode wasteful outlier instead representative non compress almost identical encode bvh unstructured mesh author ray trace dynamic geometry iso ray trace recently gpu tet mesh location illustration input mesh split  described  contains multi branching bvh sample reconstruction vertex tetrahedron index dimensional node bound quantize reduce memory footprint node item replace offset per  multi node primitive emphasize intend comparison ospray specifically towards explore memory relative typical non compress encode sample render arguably memory concern architecture gpus context ospray merely easily accessible proxy uncompressed likely memory specific data analysis chose medium version nasa mar lander model vertex billion memory unstructured mesh bvh ospray chosen memory layout sum approximately GB mesh data input unstructured data consists vertex scalar vertex index unstructured mesh comprise mostly tetrahedron pyramid wedge  vertex scalar data lander precision float ospray others precision float vertex float fourth scalar vertex GB unstructured mesh input array index array tetrahedron pyramid wedge  ints respectively array ospray instead integer encode hex index non negative tetrahedron pyramid wedge index negative encode index respectively encode vertex index array format consumes exactly byte GB mar lander alone already roughly memory vertex actual scalar data already  RTX gpus possibly bvh memory random access sample reconstruction ospray binary min max bvh node spatial bound minimum maximum scalar vertex within node subtree latter location useful implicit iso ray trace ospray node consists float spatial bound float min max scalar integer encode primitive node contains primitive indicates inner node remain encode offset node array inner node primitive index leaf memory layout exactly integer per unstructured across leaf item plus byte per bvh node ospray bvh node builder heuristic  termination criterion depends actual model mar lander data ospray unstructured bvh builder creates billion bvh node GB bvh node GB item memory ospray mar lander sum GB roughly bvh unstructured index vertex data tabulate summary data data slightly overall ratio roughly exclude data ospray usually compute per vertex gradient temporary memory bvh construction encode mesh data primary target memory optimization acceleration structure however mesh data mar lander alone exceeds available gpu memory vertex scalar briefly precision encode spirit hierarchical mesh quantization eventually discard primarily scalar data vertex exhibit spatial coherence scalar cannot easily quantize therefore opt float vertex layout ospray memory mar lander data unstructured mesh implementation  load version ospray multiple byte unstructured mesh source potential saving reduce average index per reduce byte per index reduce index ospray index per tetrahedron index opportunity roughly halve memory vertex index adopt encode index downside strategy become harder address longer multiple consequence another encode obvious choice variable offset unused leaf item later eliminate item altogether adopt hybrid primitive encode multiple index tetrahedron index wedge pyramid hex unused index marked invalid index encode index already significant saving however later leaf multiple tetrahedron vertex index nearby tet vertex exploit redundancy tet primitive leaf identify tet encode index vertex instead individual tet propose grouped quad obtain compact memory representation mesh saving tet model tet usually data pyramid wedge hex index meaning eventually encode primitive useful later average primitive encode roughly reduction vertex index sub mesh encode mar lander reduction index integer per GBs GB vertex already exceed RTX gpu memory reduce index memory adopt pre partition mesh independently encode mesh vertex per mesh mesh per index strategy vertex primitive mesh replicate mesh memory index memory replicate vertex input mesh evaluate concept recursively partition mesh   vertex heuristic  split ospray bvh builder perform meaning topologically partition pre partitioner evaluate index vertex replication data adopt index optimum unlike natively integer native data unacceptable amount vertex replication consequently memory usage impact pre partition per vertex index encode index generate trigger vertex replication encode mesh data summary input mesh multiple sub mesh float vertex unsigned integer per representation vertex replication mar lander GBs mesh data almost reference uncompressed layout acceleration structure encode reduce mesh memory roughly carefully encode acceleration structure reduce memory overhead refer avenue reduce bvh memory reduce bvh node reduce bvh node reduce ideally entirely eliminate item bvh primitive adapt bvh pre partition described bvh   necessarily limited integer index per  node array index array eliminate bvh leaf rid item primitive bvh reference exactly leaf instead leaf node pointer node IDs instead primitive reference node node offset primitive leaf contains offset address item structure node item mar lander ospray GBs completely disappears caveat primitive longer uniform encode primitive leaf index tetrahedron index tet index pyramid wedge hex entry leaf however eliminate instead encode primitive leaf tetrahedron others counter plus offset challenge increase node layout squeeze counter byte creates available influence leaf bvh builder possibly eventually chose tet individual tet non tet adopt multi branching bvh eliminate item towards reduce bvh node memory adopt exist ray tracer  switch binary bvh multi branching bvh per node leaf node significantly inner node branching factor eventually adopt per node per node variable byte align easily accessible data unlike  bvh however bvh binary bvh  backwards leaf building leaf active average active per  merge cannot guarantee fully occupy multi node subtrees cannot merge average per leaf generally node despite partition termination criterion initial binary bvh collapse significantly leaf ospray ospray bvh builder almost partition individual primitive excessive multi node encode eliminate item reduce node reduce bvh efficient encode node multi node encode information 3D bound offset primitive leaf node node array inner node leaf counter leaf bound incremental encode propose   eventually abandon expensive traverse due stack requirement quantization propose ben float precision across entire multi node quantization relative eventually core  aggressively instead float bound quantization relative bound subtree layer quantization relative  another relative individual node instead reduce pointer quantize bound information multi node eventually becomes dominate pointer offset counter primitive respectively distinct pointer properly node primitive reduce offset eliminate node inner node sequentially node array inner node compute offset index per multi node plus sibling inner node similarly leaf primitive sequentially item offset plus sibling item remove inner node completely described node offset inner node leaf node plus counter node counter zero inner node layout indeed memory statistic naïve stack cuda implementation exhibit traversal factor divergent code thread warp traverse primitive etc amount inner loop decompress entire multi node primitive maintain traversal stack bvh sub mesh within sub mesh reduce implement scheme eliminate interior node completely collapse subtrees leaf multi leaf node leaf discard node perform sample location without interior node borrow optix bvh multi leaf epsilon ray multi leaf overlap sample within intersection program decompress multi node sample primitive overlap query advantage scheme multi leaf across sub mesh bvh downside scheme optix memory inner node representation currently optix bvh roughly inner node inner node amortize data vertex primitive leaf data optix bvh roughly model oppose inner node format upside scheme advantage allows slightly byte align node layout byte offset inner node bvh sub mesh multi leaf optix bvh importantly scheme allows node layer bvh traversal entirely optix roughly improvement cuda bvh traversal node layout node layout assume optix bvh inner node sum byte byte bound byte item offset byte counter byte byte quantize byte encode node byte per node reference uncompressed layout data layout quantize multi node optix bvh extra byte offset data layout quantize multi node optix bvh extra byte offset bvh ospray bvh builder heuristic  split node leaf construct binary bvh builder multi leaf described input statistic component generate builder memory consumption exclude gpu data frame buffer mesh transfer function  data etc memory optimize encode  builder usually  termination criterion decides leaf estimate traversal primitive intersection respectively criterion caveat chose traversal estimate twice primitive estimate slightly shallower  stage leaf actually encode encode described split regular  leaf implicit lod information render focus data structure data hierarchical average bvh leaf multi leaf sub mesh respectively sample within data structure obvious potential information employ detail technique generate faster sample information skip adaptive sample bridge load latency demonstrate modify encode scalar render image sample replace average leaf multi leaf sub mesh respectively however detailed discussion detail render completely orthogonal beyond scope evaluate efficacy unstructured mesh data access overview model statistical data primitive vertex model  japan  ocean version mar lander native unstructured mesh various unstructured code  natively octree amr convert unstructured mesh compute dual mesh explicitly data data previous encode efficiency statistical data data vertex primitive vertex sub mesh multi leaf aggregate memory various data amount memory renderer data structure visualization implicit detail lod information across data structure encode render average sub mesh scalar average multi leaf leaf node respectively per reconstruct sample version mar lander memory usage comfortably GBs RTX  gpu mar lander barely longer model across gpus currently latter prototypical sort data parallel renderer NVLINK manage memory distribute data across gpus comparison  comparison encode efficiency addition encode data structure implement data structure representation unstructured optix user geometry primarily interested encode efficiency report comparison aim saturate available gpu memory respective therefore split data structure nasa lander consecutive chunk partially upload data gpu memory intensive data representation representation chunk RTX gpu GB ddr memory load chunk user geometry data representation eventually memory amount unstructured data structure consumes GB gpu memory encode efficiency data structure  optix user geometry split nasa lander data chunk allows partially upload data RTX gpu GB ddr memory memory efficient user geometry representation gpu memory data structure comparison ospray encode ospray load model ospray memory ospray recently undergone handle unstructured data version comparison average reduction memory usage roughly relative ospray relative ospray generally tetrahedral mesh memory saving  largely compress bvh index memory tetrahedral mesh tend memory bvh node  intentionally limit comparison memory consumption aspect neither ray  integrate data evaluate memory efficiency framework image render prototype renderer framework memory consumption memory uploaded gpu apply quantize compress encode model upper previous gpu unstructured renderers handle ospray ospray ray  data layout framework interactive performance prototype renderer model quality setting manage achieve ospray however conversely ospray render framework framework comparison representation memory usage essentially data structure differently encode ospray indicates ospray  data format encode compute encode currently offline core preprocess model probably significantly improve interactive rate model reading input model output upside model compress encode compute disk reading mesh bvh encode roughly reading input data uncompressed currently consequence data  gigabyte data assume host memory available handle argument compute billion bound billion bvh node etc compute mesh connectivity splitting model sub mesh specific implementation implementation prioritize easy experimentation evaluation offs data layout tet merge heuristic etc flexibility frequent memory allocation data frequent STL data structure implementation currently performs validation unlikely error compound billion execution data currently format temporarily binary bvh multi node bvh etc compound memory pressure finally intrinsic dependency currently cannot predict entry index vector subtree subtree built severely limit amount parallelism factor address efficient parallel encode ideally building subtree parallel gpu future render quality performance memory efficiency encode sample alone volume ray  intentional volume renderer sample version skip adaptive sample massive influence render performance model complexity easily  impact sample unless careful renderers skewed sometimes mislead intentionally refrain comparison secondary code perform evaluation guarantee variant sample transfer function hardware etc implement prototypical renderers data structure reference implement naïve volume renderer equidistant sample limited skip addition implement quality gpu volume renderer monte carlo sample image render renderer renderers interactive albeit quality latter however due model skip adaptive sample technique previous  achieve sample efficiency detailed discussion beyond scope focus important encode memory saving performance efficient encoding directly individual primitive operating entire multi leaf non trivial decode  data therein decode cheap evaluate implementation user geom mention respective sample routine suitably model encoding compress encode accord roughly performance associate reduction memory relative user geom roughly performance memory saving hardware accelerate performance memory encode relative user geom propose  reference tetrahedron  jet data jet chosen consists solely tetrahedron tet march highlight compression overhead render 7Discussion conclude data structure efficient interactively render fitting model gpu memory workstation render interactively shelf software aggregate scheme allows data structure ospray unstructured mesh renderer memory largely tetrahedral data benefiting largely  data allows fitting data onto gpu  allows sample cuda desire RTX acceleration location acknowledge focus software ospray potentially cpu memory limited typical workstation gpu memory however memory saving ospray approach compelling limitation approach data structure neither rebuilt update interactively primary objective explore potential offs update memory efficiency future direction comparison ray mesh traversal approach orthogonal traverse volumetric mesh thereby integrate volume distance ray unstructured memory efficient data structure approach propose advantage approach auxiliary data structure connectivity information careful data handle vertex account memory requirement tetrahedral mesh reduce significantly approach knowledge exist publicly available implementation mesh traversal approach accessible instead discus difference detail quantitative comparison future advantage approach mesh traversal mesh traversal connectivity information data however obtain reliable connectivity information mesh vertex duplicate refinement boundary numerical simulation mesh resolution  vertex issue arise partially overlap unstructured degenerate generally technique robust sporadically sample traversal entire ray unaffected mesh traversal highly sensitive issue significant handle fail completely another advantage approach scalability mesh traversal approach rely march another conceptually memory optimization adaptive sample implement contrast sample approach eventually outperform mesh traversal approach expense potentially undersampling volume approach however trivial implement  ray offset accumulate convergence frame prototypical renderer image highly reduce approach data generally approach orthogonal individual merit data structure direction amortize memory overhead acceleration data structure closing memory gap approach generality approach prototypical implementation evaluation currently nvidia hardware nevertheless optimization propose specific hardware platform similarly applicable gpus CPUs vendor compression data parallel render significantly increase limit data render machine data rate eventually technique gpu furthermore data parallel render scientific visualization data parallel compute simulation visualization pipeline important address approach address focus improve scalability gpu absolutely acknowledge ultimately data parallel caveat argument approach data parallel render predominantly rely sort compositing hamper technique skip precludes quality trace node renderer technique data renderer gpu data render quality renderer technique data parallel mutually exclusive reduce memory render improves choice data parallel render reduce memory render allows node reduce communication memory evaluate integrate data structure data parallel renderer spatially distributes model across multi  gpus render chunk non trace volume render combine intermediate mpi sort compositing report data parallel renderer workstation equip nvidia gpus GB memory per gpu uncompressed bvh representation compress gpus uncompressed version usually faster however model multiple gpus render lander gpu compress version instead gpus data replicate render performance quality scalability server nvidia gpus GB ddr memory slightly efficient encode described performance render data structure uncompressed data representation naïve ray march approach prototypical sort data parallel renderer denote compress data representation indicates reference data representation plot fully extend model combine gpu memory scalability server nvidia gpus GB ddr memory slightly efficient encode described performance render data structure uncompressed data representation naïve ray march approach prototypical sort data parallel renderer denote compress data representation indicates reference data representation plot fully extend model combine gpu memory demonstrate another workstation RTX gpus GBs lander model data parallel renderer  user geom representation barely lander across gpus data manage memory encode model gpu gpu available instead data replicate across performance frame per model sort data parallel reference bvh encode memory footprint render model performance sort render alone gpu data replicate summary conclusion goal develop evaluate memory efficient encode data perform sample render unstructured data gpu propose scheme hierarchical encode quantization reduce memory unstructured data bvh built primitive summary achieves roughly magnitude memory reduction relative comparable uncompressed representation model gpu data structure render prototypical render implementation however truly render model advanced technique skip adaptive sample probably detail implement vein issue skip adaptive sample easily spatial subdivision technique sub overlap bvh building additional data structure skip obvious concern regard memory algorithm operating data structure sample reconstruction ospray min max bvh implicit iso ray trace implement maybe importantly technique proof concept truly useful eventually integrate easily user accessible software framework    possibly ospray  api achieve however