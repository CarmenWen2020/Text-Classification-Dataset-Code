recent advance bandit technique sequential steadily enable application promising resolution challenge related goal quickly identify optimal sequentially sample stochastic payoff develop algorithm arbitrary depth summarize deeper confidence interval depth apply identification procedure sample complexity guarantee refine dependence instance experimentally algorithm outperform exist elimination algorithm previous purpose depth introduction player zero sum interaction sequence successive maximin model action sequence collection max node correspond player action min node player action leaf specify payoff player goal action player deterministic payoff primarily algorithmic powerful prune strategy available stochastic payoff addition statistical challenge sequential identification stochastic payoff arise naturally robust version bandit core component monte carlo MCTS approach  deterministic entire sub stochastic leaf randomize evaluation perform consists typically random policy outcome player MCTS within AlphaGo evaluation leaf combine supervise smart MCTS algorithm expert algorithm remain costly expensive leaf evaluation output action player focus sample complexity monte carlo purpose simplify model MCTS already generalizes depth framework conference neural information processing beach CA usa model monte carlo fix max node leaf introduce stochastic oracle leaf evaluation perform leaf MCTS algorithm model optimize evaluation strategy assume oracle sample unknown distribution presentation focus binary oracle loss oracle bernoulli distribution unknown probability player correspond algorithm without modification oracle distribution bound node denote denote player node recursively define  max node minc min node action argmax identify MCTS algorithm sequentially selects correspond leaf oracle leaf chosen adaptive sample sample  pac framework strategy leaf longer evaluate recommendation output upon  player risk accuracy parameter goal recommendation  within probability  algorithm satisfy challenge algorithm leaf evaluation related model introduce monte carlo reminiscent stochastic bandit model agent repeatedly selects probability distribution sample chosen distribution bandit model mostly focus regret minimization agent aim maximize sum sample reward context MCTS sample corresponds loss maximize successful correspond simulated odds identify quickly action action identification closer identification bai goal standard bai quickly accurately bai fix confidence model depth deeper leaf interested action action function leaf structure bandit algorithm recently bai algorithm successfully adapt building UCB algorithm regret minimize algorithm variant uct algorithm MCTS successful AIs however weak theoretical guarantee uct moreover maximize successful target recent leverage bai literature sequential halve explore latter algorithm algorithm fix budget bai goal identify probability error budget propose shot sequential halve apply algorithm empirically uct approach improvement hybrid approach shot uct without sample complexity guarantee fix confidence develop sample complexity guarantee model propose algorithm FindTopWinner uniform sample elimination approach related successive elimination algorithm fix confidence bai bandit model FindTopWinner proceeds leaf eliminate sample repeatedly precision estimate prune node estimate differs significantly estimate elimination leaf depth propose elimination procedure simpler algorithm exploit confidence interval developed inspire LUCB algorithm fix confidence bai variant propose LUCB algorithm perform simulation elimination algorithm investigate trend deeper theory contribution propose generic architecture bai MCTS identification bai algorithm confidence interval node action identification arbitrary depth specific instance UGapE MCTS LUCB MCTS rely confidence bai algorithm probability upper bound sample complexity theoretical empirical improve elimination algorithm FindTopWinner bai MCTS algorithm generic algorithm bai MCTS combine bai algorithm exploration confidence interval node introduce algorithm instance explain confidence interval introduce central notion representative representative leaf confidence interval representative node leaf observation leaf confidence interval resp upper confidence bound resp confidence bound specific confidence interval later confidence interval propagate upwards construction internal node recursively define  max node minc min node  max node minc min node interval tightest sole assumption confidence interval valid construction  algorithm context easy convince oneself induction appendix accuracy confidence interval preserve construction proposition define representative internal node  max node argminc min node representative leaf node leaf obtain representative otherwise confidence interval statistically plausible node hence representative interpret optimistic max node pessimistic min node assume adversary reminiscent behavior uct algorithm construction confidence interval associate representative illustrate construction confidence interval representative max node input bai algorithm initialization   sample representative leaf update information output  bai MCTS architecture bai MCTS architecture generic bai MCTS algorithm sample combine ingredient identification selects action confidence exploration depth node representative leaf evaluation structure bai MCTS algorithm algorithm depends identification bai algorithm component algorithm sample  selects  return algorithm decides recommendation  selects candidate bai MCTS depth node hence information bai algorithm decision   information depth node update loop bai algorithm information instance rely confidence interval empirical estimate depth node UGapE MCTS LUCB MCTS identification algorithm within bai MCTS variant respectively UGapE LUCB algorithm algorithm exploit confidence interval however LUCB algorithm additionally empirical within bai MCTS define estimate Vˆ depth node generic structure algorithm promising depth node compute denote candidate node confidence interval uncertain node argmax bai MCTS architecture representative leaf compute sample algorithm whenever confidence interval promising overlap inf uct lbt recommends  algorithm detail depth node optimistic challenger maximal depth node node explore discover depth action quickly UGapE MCTS UGapE MCTS introduce depth node index max promising depth node define argmin argmax LUCB MCTS LUCB MCTS promising depth node define argmax Vˆ argmax Vˆ empirical  leaf node alternative definition Vˆ propose confidence interval maxa Vˆ choice crucial analysis LUCB MCTS appendix analysis UGapE MCTS UGapE MCTS LUCB MCTS theorem probability upper bound sample UGapE MCTS upper bound obtain LUCB MCTS theorem appendix confidence interval assume confidence interval leaf   exploration function tune pac algorithm express lemma proof appendix lemma max choice UGapE MCTS LUCB MCTS satisfy  practical feature confidence interval local whereas bai algorithm exploration function hence confidence interval update ancestor leaf recursively moreover leverage recently introduce obtain tighter confidence interval union bound artifact analysis however exploration function lemma conservative recommend finally correctness slightly exploration function obtain confidence interval kullback leibler divergence performance standard identification depth however sample complexity analysis intricate hence hoeffding confidence interval complexity sample complexity guarantee introduce notation recall optimal action identify depth node satisfy define depth node  recall denotes node introduce furthermore anc ancestor node define complexity max anc intuition denominator sample leaf prune ancestor prune everyone happens leaf optimal precision theorem min UGapE MCTS exploration function probability  remark correctness furthermore upper bound expectation however algorithm becomes efficient implement leaf observation confidence interval update lower probability error significantly comparison previous knowledge FindTopWinner algorithm algorithm literature action identification depth algorithm upper bound probability improvement constant presence unavoidable regime gap improvement optimal leaf UGapE MCTS leaf significantly gap moreover unlike FindTopWinner LUCB depth UGapE MCTS provable guarantee regard algorithm LUCB extension LUCB depth belong bai MCTS algorithm indeed reverse structure compute representative leaf depth node perform bai representative leaf  alternative architecture generalize deeper empirical performance bai MCTS LUCB benchmark distinguish LUCB MCTS exploration rate depends global empirical maximin maximize Vˆ alternative choice theoretical guarantee deeper finally exploration bai MCTS algorithm similarity uct algorithm alternatively yield UCB LCB however behavior bai MCTS bai algorithm another difference bai MCTS relies confidence recent independently propose  algorithm differs  LUCB MCTS picked analysis feature refine complexity maximal distance consecutive ancestor leaf replace maximal distance ancestor leaf obtain algorithm interval interval probability correspond whereas uct heuristic confidence interval node aggregate sample descendant node uct obvious define suitable hence comparison algorithm hybrid comparison uct FindTopWinner propose uct random sample fix confidence algorithm FindTopWinner advantage sample algorithm dominate FindTopWinner proof theorem upper bound assume appendix lemma intuition leaf representative leaf confidence interval nest lemma hence permit bound width interval upper bound function lemma lemma exploit mechanism UGapE relate width another useful lemma leverage exploration function obtain explicit upper bound lemma define sup consequence theorem appendix leaf played satisfies lemma apply lemma sum conclude proof remark proof lemma appendix  probability experimental validation evaluate performance algorithm evaluate depth benchmark depth random ensemble FindTopWinner algorithm depth LUCB algorithm relation bai MCTS bai MCTS algorithm LUCB exploration rate stylize version lemma KL refinement confidence interval replicate algorithm algorithm undo conservative union bound leaf excessive choice exceed algorithm none error rate exceeds benchmark performance algorithm purpose depth LUCB performs closely arbitrary depth LUCB MCTS UGapE MCTS significantly sample FindTopWinner displayed appendix sake readability depth leaf drawn uniformly algorithm outperform previous magnitude finally replicate comparison proven exploration rate ary depth bernoulli leaf parameter drawn uniformly random average sample LUCB MCTS UGapE MCTS FindTopWinner closely apply union bound leaf algorithm error algorithm bai MCTS algorithm deliver impressive fold reduction sample depth benchmark leaf average algorithm LUCB MCTS error sample  FindTopWinner LUCB average repetition bound discussion MCTS model parameterized leaf action define alt technique classic identification establish non explicit bound proof appendix theorem assume algorithm satisfies sup inf alt binary kullback leibler divergence however directly amenable comparison upper bound optimization define lemma easy upper bound dependency depth resp action player resp moreover suggests intrigue behavior lemma assume depth supremum definition restrict  max min extract proof theorem appendix vector attains supremum average proportion selection leaf algorithm bound hence sparsity lemma suggests algorithm leaf hint prospect optimal stochastic prune asymptotic regime numerically bound optimization concave maximization correspond benchmark displayed obtain bound potential improvement factor future direction asymptotically optimal algorithm bai developed maintains empirical proportion exploration ensure develop MCTS advance quality algorithm challenge develop efficient solver optimization sparsity reveal lemma depth efficient solver sparsity evolves deeper alone compute