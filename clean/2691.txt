online monitoring user cardinality graph fundamental application anomaly detection graph duplicate user item infeasible exactly compute user cardinality due limited computational memory resource exist approximately estimate user cardinality accuracy highly depends complex parameter cannot anytime available estimation address develop novel register algorithm register array compact sketch user item algorithm exploit dynamic register array zero array significantly improve estimation accuracy complexity update estimation user item addition algorithm easy without requirement tune parameter furthermore extend detect super spreader cardinality evaluate performance datasets experimental demonstrate accurate faster amount memory introduction network graph network node user user another web surf activity model bipartite graph user node partition website node partition user website browse monitoring cardinality user network fundamental application network anomaly detection user cardinality define distinct user item user connects  bipartite graph due graph infeasible entire graph computational memory resource limited network router memory traffic monitoring module incapable exactly compute cardinality network user therefore important develop memory efficient algorithm approximately compute user cardinality however exist challenge challenge implement bloom filter handle duplicate exploit frequency estimation min sketch approximate user cardinality memory usage estimation error min sketch utilize variety counter user frequency user occurs essential hash distinct bloom filter handle duplicate graph compute user cardinality specifically bloom filter dimensional array consist independent hash function incoming bloom filter randomly selects hash function afterwards previously bloom filter hash function correspond treat duplicate associate otherwise characteristic bloom filter false positive false negative false positive calculate sum user cardinality graph false positive therefore assign memory bloom filter achieve desire false positive false positive wrongly identify complex estimation error min sketch false positive unknown advance moreover min usually estimation user cardinality easy classify user cardinality user cardinality generate estimation bias challenge optimal exist sketch variety cardinality estimation linear probabilistic counting LPC HyperLogLog HLL developed approximately compute cardinality LPC HLL sketch consists register parameter affect estimation accuracy user cardinality advance achieve reasonable accuracy user cardinality however waste considerable memory user cardinality develop virtual sketch compress user LPC HLL sketch register array user virtual sketch user virtual LPC HLL sketch register randomly register array significantly reduces memory usage register user however register user virtual LPC HLL sketch contaminate user refer register noisy register user cardinality virtual LPC HLL sketch tend noisy register estimation error challenge exist customize estimate user cardinality data unable report user cardinality application online anomaly detection important user cardinality network monitoring detect abnormal IP address super spreader IP address cardinality specify threshold moreover online monitoring IP address cardinality facilitates online detection stealthy attack launch subclass IP address address challenge develop novel algorithm FreeBS FreeRS accurately estimate user cardinality addition anomaly detection mainly focus abnormal user extremely cardinality memory resource counter user cardinality therefore extend combination unbiased detect super spreader summarize contribution previous register algorithm FreeBS FreeRS exploit dynamic register array significantly improve estimation accuracy dynamic register array summarize register user dynamically increase cardinality increase user cardinality tend register zero array register register array dynamically FreeBS FreeRS incrementally estimate user cardinality probability user item register register array decrease algorithm report user cardinality estimation user cardinality complexity reduce cse vHLL update user cardinality estimation user item extend algorithm detect super spreader cardinality rank user accurate faster exist evaluate performance datasets experimental demonstrate magnitude faster accurate amount memory organize summarizes related formulation introduces preliminary algorithm FreeBS FreeRS extension detect super spreader performance evaluation conclusion future related estimate data cardinality addition LPC HLL developed estimate cardinality user detail combine LPC sample enlarge estimation LPC  martin develop sketch FM register estimate data cardinality bound register improve accuracy sketch  loglog HyperLogLog  HLL  developed register compress register develop cardinality estimator statistic sample  introduces concept generally model sketch martingale estimator improve accuracy extend HLL estimate cardinality slide besides sketch  adaptive sample distinct sample developed estimate cardinality furthermore summarize exist cardinality estimation evaluate performance estimate user cardinality achieve desire accuracy register user user cardinality unknown advance memory efficient user cardinality develop virtual sketch compress LPC HLL sketch user register array user reduce noisy virtual LPC sketch regular LPC sketch user information estimate user cardinality virtual sketch virtual sketch achieve desire accuracy user cardinality however computation estimation error  user cardinality register virtual sketch tend contaminate noisy addition virtual sketch customize non setting estimate host cardinality interval computationally expensive extend setting detect hitter super hitter super spreader important anomaly user behavior usually hitter define user frequency threshold super spreader define user cardinality exceed specific threshold detect hitter deterministic sample randomize sketch algorithm hitter graph consist item insertion deletion calculates hitter multiple dimension memory algorithm sample multistage filter detect hitter without entire network develop sketch algorithm detect variety network measurement specially faster memory efficient user accord frequency consistent moreover detect hitter summary data structure bias  later proposes probabilistic model replace minimum data structure varied probability reduce estimation bias policy update minimum counter consistent developed frequent hitter estimation addition propose hardware friendly logical location variety fix introduce novel strategy exponential decay achieve precision hitter memory efficient comparison develop reversible sketch data structure reverse hash monitor user frequency significantly another exist duplicate graph hitter estimation cannot directly detect super spreader hash distinct item connection sketch chinese remainder theorem monitor reverse super spreader implement besides propose novel  reversible data structure distribute network monitoring detect super spreader introduces vector bloom filter VBF extraction hash function improve cardinality estimation memory usage computation although utilize hash function reverse user without computation enumerate combine almost hash reconstruct user practicable detect super spreader return false user actually graph introduce estimation error addition sample detect super spreader propose sample algorithm detect super spreader proven accuracy performance bound adaptive sample detect super spreader online sample approach identify super spreader cardinality exceed threshold within specific propose reservoir sample bias combine sample algorithm introduce filter tracker  framework spreader scanner online sample filter user cardinality implement detect super spreader cannot guarantee super spreader sample exhibit error cardinality estimation formulation formally define introduce notation graph consist sequence focus bipartite graph consist user item however easily extend  graph computer network network communication source IP address destination IP address online social network social relation user denote user item respectively denote tth user item respectively denote distinct item user connects define cardinality user sum user cardinality develop accurate estimate user cardinality limited amount memory besides aim monitor super spreader cardinality estimation confusion arises omit superscript exposition preliminary estimate user cardinality linear probabilistic counting user linear probabilistic counting sketch item connects formally define array consist initialize uniform hash function user item arrives probability remains zero denote zero expectation compute equation estimate LPC  weakness LPC limited estimation estimate user cardinality  HyperLogLog estimate cardinality user HyperLogLog developed  martin FM sketch consist register register initialize user item arrives HLL item random variable integer uniformly random drawn geometric distribution register update max estimate HLL   constant bias formula complicate compute numerically HLL severely bias cardinality HLL treat LPC sketch  estimate  zero register therefore easily LPC outperforms HLL cardinality memory usage discussion compute user cardinality LPC HLL sketch estimate user cardinality clearly LPC HLL exhibit error user cardinality user cardinality assign LPC HLL sketch user accurately estimate user cardinality wasteful LPC HLL achieve reasonable estimation accuracy user cardinality user cardinality advance therefore optimal LPC HLL estimate user cardinality subsection introduce address discus shortcoming estimate user cardinality cse compress LPC sketch user array cse consists array independent hash function mapping user dimensional array LPC cse virtual LPC sketch user embeds LPC sketch user user virtual LPC sketch consists randomly hash function zero user item arrives cse LPC uniform hash function cse zero respectively user virtual LPC sketch regular LPC sketch noisy bold wrongly zero item user remove estimation error introduce noisy estimate cse   equation regular LPC corrects error introduce noisy overview cse register vHLL virtual cse vHLL sketch user noisy register register bold vHLL compress HLL sketch user array develop register vHLL extends HLL estimate user cardinality vHLL consists register initialize zero maintain virtual HLL sketch user vHLL independent hash function randomly register register function user formally define user item arrives item random variable integer uniformly random random integer drawn geometric distribution HLL easily virtual HLL sketch user therefore vHLL update register max user virtual HLL sketch regular HLL noisy register register bold wrongly item user remove estimation error introduce noisy register estimate vHLL MM   HLL parenthesis equation regular HLL corrects error introduce noisy register regular HLL replace   register discussion LPC HLL register array user user cardinality affected others achieve desire estimation accuracy LPC HLL user waste memory user cardinality contrary cse vHLL memory efficient allows register register array user cannot challenge challenge parameter cse vHLL estimation accuracy cse vHLL highly depends increase introduces unused virtual LPC sketch user become contaminate unused refer user virtual LPC sketch user item user hash however decrease introduces estimation error user cardinality similarly vHLL confronts challenge optimal later experimental verify error increase user cardinality cse vHLL challenge computationally intensive estimate user cardinality cse vHLL complexity compute cardinality user apply compute cardinality user cse vHLL repeatedly incur computational prohibits application manner algorithm FreeBS FreeRS estimate user cardinality novel register technique respectively assign register user cardinality significant improvement cardinality estimation accuracy register user cardinality ensure estimation performance however exist waste register user cardinality limit estimation accuracy user cardinality therefore unlike vHLL cse mapping user item register FreeBS FreeRS randomly user item register array correspond register user sample accord cardinality item user cardinality tend register user item discard update register register array user otherwise user item increase cardinality estimation user define probability user item register register array FreeBS parameter data structure data structure FreeBS FreeBS consists dimensional array initialize zero addition FreeBS hash function uniformly independently user item integer random differs hash function cse user integer random overview FreeBS overview FreeBS update procedure pseudo code FreeBS algorithm user item arrives FreeBS computes random variable denote index correspond zero formally define FreeBS denote cardinality estimate user initialize FreeBS denote zero denote probability define denote indicator function predicate otherwise besides arrival user item update cardinality estimate user FreeBS FreeBS SourceRight click MathML additional feature user cardinality estimate unchanged FreeBS FreeBS easily compute incrementally initialize incrementally compute hence complexity FreeBS processing user item algorithm pseudo code FreeBS FreeBS foreach FreeBS FreeBS error analysis denote occurrence user item associate user theorem expectation variance FreeBS FreeBS source var FreeBS sourcewhere proof denote indicator update user item incurs otherwise denote random variable update probability user item array calculate array probability source var  FreeBS incrementally calculate random variable correspond probability FreeBS  FreeBS  SourceRight click MathML additional feature random variable independent association variable sequence update probability FreeBS FreeBS sourcethe variance FreeBS compute var FreeBS var   SourceSince var FreeBS equation var var var var FreeBS var FreeBS source derive formula specific distinct exist distinct user item user item stirling compute undefined sequence  addition exist undefined sequence  distinct therefore undefined sequence  compute undefined sequence  SourceRight click MathML additional feature expand function taylor series around var  easily var obtain FreeRS parameter register data structure data structure FreeRS FreeRS consists register initialize zero addition FreeRS hash function randomly user item integer another function random integer accord geometric distribution hash function vHLL user random integer respectively algorithm pseudo code FreeRS FreeRS foreach FreeRS FreeRS overview FreeRS update procedure pseudo code FreeRS algorithm user item arrives FreeRS computes random variable update max denote probability register formally define FreeRS denote cardinality estimate user user item arrives update cardinality estimate user FreeRS FreeRS sourcefor user cardinality estimate unchanged FreeRS FreeRS initialize incrementally compute hence complexity FreeRS processing user item error analysis derive error FreeRS theorem expectation variance FreeRS FreeRS SourceRight click MathML additional feature var FreeRS SourceRight click MathML additional feature undefined sequence  sourcewith   approximately proof proof theorem theorem derive formula FreeRS randomly split sub maximum function user item sub assume distinct user item  therefore undefined sequence   expression easily derive however complex analyze hence introduce approximate    discussion FreeBS versus cse FreeBS outperforms cse aspect FreeBS estimate cardinality  maximum cardinality  cse FreeBS exhibit estimation error cse expectation variance cse compute cse source var cse SourceRight click MathML additional feature zero array cse exhibit bias FreeBS unbiased approach FreeBS cse perform nearly operation cardinality estimator theorem var cse var FreeBS source FreeBS complexity update user cardinality estimate observes user item cse complexity FreeRS versus vHLL FreeRS outperforms vHLL aspect FreeRS complexity update user cardinality estimate observes user item vHLL complexity FreeRS exhibit estimation error comparison vHLL theorem var FreeRS  variance vHLL var vHLL MM SMM  versus FreeRS FreeBS faster FreeRS user item FreeBS computes FreeRS compute update register memory usage accuracy FreeBS FreeRS register register theorem var FreeBS SourceRight click MathML additional feature var FreeRS SourceRight click MathML additional feature therefore FreeRS accurate FreeBS user distinct user item HLL exhibit error estimate cardinality register HLL LPC estimate cardinality register easily approximately compute register FreeBS register FreeRS memory usage indicates FreeBS accurate FreeRS user user item limitation limitation estimate user cardinality user estimate cardinality limitation exploit compute user cardinality graph consist limited user monitoring network connection host campus user therefore user cardinality limited amount memory practical estimate user cardinality graph consist user monitoring network connection host router internal external network impractical user cardinality due limited memory resource however application anomaly detection focus user extremely cardinality super spreader therefore implement sketch unbiased user cardinality extension super spreader detection estimate cardinality graph extra counter user correspond cardinality however datasets user extremely memory resource meanwhile datasets skewed distribution user cardinality anomaly detection mainly focus monitoring abnormal user cardinality user mention exist frequency estimation cannot directly complex super spreader detection due duplicate graph exist super spreader detection exhibit estimation error therefore extend combine unbiased monitor super spreader unbiased almost implement data structure update procedure replaces minimum varied probability unbiased FreeBS FreeRS handle duplicate graph accurately estimate user cardinality utilize unbiased monitor super spreader complexity FreeBS ssd FreeBS super spreader detection data structure pseudo code FreeBS ssd algorithm FreeBS ssd consists data structure dimension array item estimate cardinality user summary data structure bucket user cardinality specifically summary data structure doubly link bucket initialize contains parameter user counter FreeBS ssd estimate cardinality maximum estimation sufficient bucket super spreader bucket super spreader meanwhile bucket ranked accord counter algorithm pseudo code FreeBS ssd FreeBS ssd foreach FreeBS ssd FreeBS ssd rerank bucket  FreeBS ssd min rand replace smin FreeBS ssd min FreeBS ssd FreeBS ssd min rerank bucket FreeBS ssd min FreeBS ssd min rerank bucket FreeBS ssd FreeBS ssd insert rerank bucket FreeBS ssd min minimum counter smin user bucket update procedure user item arrives FreeBS ssd update array described algorithm update summary detail user already monitor bucket user directly update correspond counter FreeBS ssd FreeBS ssd probability user item rerank bucket accord counter bucket sort update bucket counter prior bucket bucket usually update bucket bucket ranked contrary user monitor scenario scenario empty bucket update bucket minimum counter FreeBS ssd min denote minimum counter correspond user smin probability FreeBS ssd min random met update bucket smin FreeBS ssd min FreeBS ssd FreeBS ssd min rerank bucket accord counter otherwise update minimum counter FreeBS ssd min FreeBS ssd min rerank bucket scenario empty bucket initialize bucket user insert suitable accord counter specially estimation user initialize therefore complexity FreeBS ssd update bucket user item error analysis accord data structure update procedure FreeBS ssd theorem theorem user FreeBS ssd unbiased estimation cardinality FreeBS ssd proof simplify FreeBS ssd exposition scenario user user user estimate cardinality update mention theorem increment unbiased estimation user user counter minimum probability happens probability increment update compute SourceTherefore FreeBS ssd unbiased estimation cardinality FreeBS ssd FreeRS ssd FreeRS super spreader detection data structure pseudo code FreeRS ssd algorithm FreeRS ssd consists register array register item estimate cardinality user summary data structure bucket user cardinality update procedure user item arrives FreeRS ssd procedure FreeRS update register array implement procedure FreeBS ssd update bucket specifically user directly update counter FreeRS ssd FreeRS ssd denotes probability register update bucket accord counter ranked user monitor scenario scenario update bucket minimum counter smin FreeRS ssd min FreeRS ssd FreeRS ssd min probability FreeRS ssd min rerank bucket accord counter otherwise update bucket FreeRS ssd min FreeRS ssd min rerank bucket scenario empty bucket initialize counter user estimation bucket suitable accord counter complexity update bucket user item error analysis FreeBS ssd theorem user FreeRS ssd unbiased estimation cardinality FreeRS ssd proof theorem theorem omit due limited super spreader detection FreeBS ssd FreeRS ssd detect super spreader user cardinality rank user mention bucket contains parameter user counter FreeBS ssd FreeBS ssd resp FreeRS ssd FreeRS ssd maximum estimation bucket ranked accord counter FreeBS ssd resp FreeRS ssd increment user insert summary data structure approximately treat cardinality user therefore sequentially enumerate bucket report user FreeBS ssd resp FreeRS ssd evaluation datasets conduct variety publicly available datasets summarize dataset sanjose resp chicago consists passive traffic trace  sanjose resp  chicago data collection monitor march twitter flickr orkut livejournal graph datasets social relationship user datasets  user cardinality datasets algorithm pseudo code FreeRS ssd FreeRS ssd foreach FreeRS ssd FreeRS ssd rerank bucket  FreeRS ssd min rand replace FreeRS ssd min FreeRS ssd FreeRS ssd min rerank bucket FreeRS ssd min FreeRS ssd min rerank bucket FreeRS ssd FreeRS ssd insert rerank bucket  user cardinality summary datasets summary datasets baseline memory usage therefore algorithm FreeBS cse whereas register algorithm FreeRS vHLL register moreover cse vHLL virtual sketch cardinality user optimal accord metric LPC HyperLogLog HLL sketch user item connects specially HLL optimize HyperLogLog register implement bias correction sparse representation strategy improve cardinality estimation performance LPC HLL register user respectively addition combine BF CM bloom filter min sketch detail counter min hash function bloom filter parameter memory structure ratio memory bloom filter memory denote counter array min counter counter array later parameter optimal memory aim compute cardinality user enumerate user compute cardinality cse vHLL LPC HLL user computationally intensive prohibitive estimate user cardinality allocate user counter cardinality cse vHLL LPC HLL estimate cardinality user cse vHLL LPC HLL update counter counter user unchanged reduces complexity user cardinality therefore FreeRS FreeBS cse vHLL LPC HLL counter user memory usage memory usage comparison metric grain metric relative standard error RSE evaluate performance estimate cardinality user cardinality formally define RSE addition metric average absolute relative error  evaluate average performance estimate user cardinality respect  formally define  accuracy user cardinality estimation whenever arrives implement estimate cardinality user respectively experimental LPC cse dataset orkut memory virtual sketch cse experimental datasets diagonal estimation accuracy LPC cse limited estimation LPC exhibit extremely estimation performance cardinality fix memory user dataset orkut LPC maximum estimation therefore omit experimental LPC later meanwhile parameter respectively metric  estimation performance dataset sanjose  decrease memory usage increase FreeBS FreeRS performance estimate user cardinality dataset sanjose contains user user cse FreeBS user vHLL HLL FreeRS register average noisy register contaminate user cse vHLL FreeBS FreeBS user register HLL limited cannot guarantee estimation accuracy addition  cse vHLL decrease increase increase maintain performance consistent analysis increase increase estimation performance cse vHLL extent introduces unused register user cardinality easy register contaminate user furthermore BF CM accurate  cse memory handle duplicate graph introduces complex error min sketch orkut estimate cardinality versus actual cardinality LPC cse memory virtual sketch cse sanjose  comparison cse vHLL HLL BF CM parameter fix memory usage cse vHLL BF CM metric RSE estimation error grain FreeBS FreeRS accurate cse vHLL HLL BF CM FreeBS resp cse accurate register FreeRS resp vHLL characterize user cardinality user cardinality register FreeRS resp vHLL outperforms FreeBS resp cse specially RSE cse decrease increase actual cardinality increase cse estimation  consistent meanwhile HLL accurate cse vHLL cardinality due bias correction strategy user register HLL vHLL HLL performs estimation error vHLL cardinality min user cardinality user cardinality easily affected user identify user cardinality therefore RSE BF CM cardinality besides  estimate user cardinality memory usage per user estimation error increase graph FreeBS FreeRS performance memory usage per user decrease volume graph increase user graph datasets cardinality estimation accuracy RSE memory cse vHLL BF CM sanjose cardinality estimation accuracy  memory usage user cardinality estimation memory cse vHLL BF CM sanjose cardinality estimation accuracy  memory usage user cardinality estimation memory cse vHLL BF CM runtime cse vHLL LPC HLL runtime mainly register user virtual sketch estimate user cardinality enumerate  user sketch complexity contrary FreeBS FreeRS complexity update counter user register sketch average processing update user cardinality experimental increase runtime cse vHLL LPC HLL increase FreeBS FreeRS substantially faster cse faster vHLL FreeBS faster FreeRS register perform operation processing runtime FreeBS FreeRS comparison cse vHLL LPC HLL register virtual sketch user accuracy super spreader detection detect super spreader cse vHLL HLL BF CM reversible sketch vector bloom filter VBF memory VBF consists dimensional array hash function array contains initialize whenever arrives VBF user sub without overlap hash compute fifth hash function randomly user integer hash function index array sixth hash function generate index array correspond array VBF enumerates hash array reconstruct user overlap estimate correspond cardinality array therefore easily super spreader metric false negative ratio FNR false positive ratio fpr evaluate super spreader detection performance memory cse vHLL HLL BF CM consists sketch user counter memory register array summary data structure bucket summary data structure contains parameter user counter maximum estimation assign respectively therefore memory array VBF user variable ratio memory summary data structure memory accuracy detect super spreader dataset sanjose omit datasets FNRs FPRs increase increase accuracy user cardinality estimation decrease memory register array later fix accuracy detect super spreader datasets FreeBS ssd FreeRS ssd outperform datasets specially due limited estimation cse exhibit estimation error datasets twitter orkut although VBF reduces memory usage user counter reversible sketch estimation accuracy seriously affected false user reverse actually graph computationally expensive reverse user practicable detect super spreader FNRs FPRs detect super spreader super spreader detect increase FNRs increase user  super spreader user graph increase simultaneously complex analyze trend FPRs meanwhile outperform detect super spreader sanjose accuracy detect super spreader memory cse vHLL BF CM datasets accuracy detect super spreader cse vHLL BF CM sanjose accuracy detect super spreader lambda frac cse vHLL BF CM sanjose accuracy detect super spreader cse vHLL BF CM conclusion develop novel algorithm FreeBS FreeRS accurately estimate user cardinality exist register register user FreeBS FreeRS enables register user dynamically increase cardinality increase user register therefore capable estimate user cardinality besides algorithm exploit dynamic register significantly improve estimation accuracy effective sharply reduce complexity compute user cardinality user item FreeBS accurate FreeRS user user item graph FreeRS outperforms FreeBS user user item furthermore extend accurately detect super spreader conduct datasets experimental demonstrate significantly outperform accuracy computational