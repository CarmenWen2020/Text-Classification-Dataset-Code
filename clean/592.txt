hash trie data structure nearly ideal characteristic implementation hash lock hash data structure lock hash focus memory reclamation without lose lock freedom knowledge outside garbage environment implementation hash reclaim memory lock manner achieve goal propose approach memory reclamation specific lock hash explores characteristic structure achieve efficient memory reclamation define memory bound discus detail algorithm easily reproduce implementation others experimental approach obtains memory reclamation competitive scalable hash implementation lock implementation keywords memory reclamation lock freedom hash hazard pointer introduction data structure program almost computer program algorithm data structure building advantage multiple core efficiently guarantee progress throughput latency traditional approach synchronize access critical concurrent environment primitive  mutexes semaphore algorithm non failure suspension thread cannot failure suspension another thread non algorithm atomic modify primitive notable CAS swap instruction non algorithm lock guaranteed progress per thread progress guarantee individual thread starve guaranteed thread progress define regardless schedule policy multiple implementation lock data structure entirely usable lock manner delegate task memory reclamation garbage collector avoids portability environment garbage collector available available lock loss overall lock freedom memory reclamation scheme developed lock data structure however compatible lock data structure lock specific operating hardware implementation memory reclamation remove lock data structure lock data structure ensure lock freedom concurrent access data structure cannot guarantee access thread remove overcome limitation sophisticated postpone delegate reclamation guarantee performance memory usage bound lock freedom memory reclamation reclaim remove progress rate remove data structure unbounded memory consumption knowledge outside garbage environment implementation hash reclaim memory lock manner focus extend sophisticated implementation lock hash data structure lock hash LFHT efficient memory reclamation lock manner LFHT implement hash hierarchy hash instead monolithic expand grant latency throughput characteristic approach explore lock memory reclamation due LFHT intrinsic procedure delegate removal circumstance incompatible LFHT data structure aba however reproduce aba somehow situation extremely rare implement exist memory reclamation incorrect approach sake benchmarking comparison execution inconsistent data structure unsuccessful attempt explore alternative memory reclamation exploit specific characteristic LFHT data structure viable memory reclamation guarantee memory bound enhance overall performance data structure novel hazard hash hazard respectively hierarchy LFHT data structure define portion memory reclamation thread update hazard operation lock memory reclamation hazard hash HHL achieves synchronization overhead lock memory reclamation define flexible memory bound minor limitation restricts usage configuration LFHT data structure underlie memory allocator efficiently align memory allocation request experimental LFHT HHL achieve performance scalability surpass lock implementation concurrent hash intel TBB library extreme performance degradation throughput data structure LFHT inherent update global information access frequently thread HHL remainder organize introduce relevant background regard lock memory reclamation regard LFHT data structure discus motivation challenge HHL emphasis algorithm easily reproduce others discus correctness lock progress HHL discus experimental finally conclusion direction background discus concept lock freedom aba threat memory reclamation lock data structure lock freedom aba lock algorithm ensure progress independently thread schedule policy whenever thread executes define guaranteed thread progress execution achieve lock freedom avoid lock algorithm thread lock progress amount schedule thread thread lock unfortunately outside kernel advantage atomic primitive hardware specific instruction atomically memory location arguably relevant atomic instruction swap CAS widely architecture CAS instruction normally commit concurrent task interfere meantime algorithm pseudo code CAS instruction execute atomically receives argument memory address replace nutshell CAS operation atomically content corresponds update otherwise remains unchanged operation return boolean correspond operation succeed algorithm image KB image algorithm CAS address besides reduce granularity synchronization CAS operation lock data structure usually lock environment reading memory address task finally commit CAS instruction initial argument CAS memory address CAS simply fails meaning redo another thread interfere however usage CAS instruction straightforward semantic exactly valid remain unchanged commit scenario concurrent operation update memory address CAS operation succeed memory meantime aba prevention aba context algorithm synchronization primitive prevent context algorithm ideal additional hardware otherwise specific synchronization primitive width CAS load link conditional primitive widely available across architecture practical implementation severely limited lock memory reclamation motivate lock memory reclamation introduce harris lock link implement node consists associate reference node chain flag node valid invalid flag embed node reference significant reference information due memory alignment header node reference node node reference header node lifetime node valid invalid unreachable  configuration illustrate image KB image node node valid reachable header node flag valid node invalid reachable flag invalid finally node unreachable logically remove reachable unreachable node invalid node despite node unreachable thread local reference unreachable longer reference unreachable node thread physically reclaim node memory node  remove operation node image KB image node removal node invalid flag informs thread node remove node logically remove update correspond chain reference previous valid node node unreachable upcoming thread access node remove remove operation local global reclamation queue reclamation procedure amount node reclamation queue threshold threshold tune exchange memory usage execution arises node reclamation queue becomes  thread reference operation node unreachable thread operation node unreachable impossible thread reference node  thread operation node unreachable methodology node reclaim another spacial location thread memory reclamation methodology grace quiescent thread access resource grace thread quiescent node unreachable grace elapse thread reference various relative temporal reclaim memory synchronization establish temporal usage era global epoch lamport freely frequency quiescent declare reclaim memory associate regard amount memory reclamation queue although necessarily hurt lock freedom concurrent data structure delegate reclamation procedure cannot ensure lock freedom declaration quiescent thread render thread unable reclaim memory future node remove normal operation data structure progress memory reclamation unbounded memory consumption logic lock memory allocation hazard pointer hazard pointer variable pointer resource currently thread inform thread data structure access thread cannot reclaim others hazard pointer usually imply significant overhead thread location data structure lock link hazard pointer per thread previous node thread traverse reclaim node reading hazard pointer thread node reclamation queue node reference hazard pointer safely reclaim thread reference anchor described grace extend recovery mechanism hazard pointer despite expensive rarely thread identifies another thread progress amount marked stuck recovery procedure recover node node anchor register update anchor recovery procedure replaces exist node replace node frozen allows remain thread ignore stuck thread reclaim memory normally replace node remain frozen recovers regard reclamation apart guarantee removal node inferior thread similarly grace ensure recover thread protects node visible thread stuck recover frozen become unreachable recovery procedure freeze reclamation frozen node thread freeze performance wise approach grace introduces bound memory usage proportional node anchor width CAS recovery procedure latency hazard era similarly grace however removal node insert allows reclaim memory thread delay failure global increase atomically removal similarly hazard pointer update hazard pointer thread reference local update global insert node allows reclamation thread stall fail node insert delayed thread reclamation node data structure update local amount memory bound performance overhead interval reclamation similarly hazard era however node within chain insertion follower node reference information allows traverse thread update local without consult global comparison advantage disadvantage boil aspect performance memory usage complexity grace optimal performance memory usage explode render unusable hazard pointer optimal bound memory extra performance slightly complex implement anchor balance performance memory price complexity hazard era interval reclamation balance everything excel detail memory bound synchronization comparison memory reclamation memory bound synchronization operation per node thread hazard pointer per thread anchor interval maximum valid node   synch ops grace  hazard  load   hazard  load interval  load lock hash LFHT data structure node hash node leaf node leaf node hash node implement hierarchy hash fix hierarchy compute hash chunk index appropriate hash node hash index entry appropriate bucket array collision leaf node link respective bucket entry threshold met expansion operation update node link hash instead monolithic hash hash trie hierarchy hash fix insertion node hash image KB image insertion node hash initial configuration hash hash hash node bucket array entry backward reference prev previous hash correspond chain node per bucket entry bucket entry empty bucket entry bucket entry reference hash node hash node reference chain leaf node correspond hash collision entry configuration insertion node configuration insertion node leaf node reference chain node flag node valid invalid expansion operation insert hash node chain bucket entry reference prev reference insertion chain leaf node node mapped bucket bucket node insert simultaneously another thread node expand bucket entry reference becomes immutable immutable background invalidation node remove flag valid invalid flag already invalid another thread remove node node unreachable valid node chain hash node correspond traverse chain hash node hash node traverse chain valid node bucket entry valid node exists node already unreachable otherwise reference refers hash node concurrent expansion simultaneously restart node expand invalidate currently expand expand invalid unreachable otherwise expand unreachable expand thread expand unreachable invalid expansion situation thread expansion becomes responsible node unreachable transfer responsibility expand thread delegation definition challenge default memory reclamation rely remove data structure unreachable remove operation terminates however LFHT data structure node guaranteed unreachable remove operation concurrent expansion simultaneously task node unreachable delegate expand thread illustrates expansion operation node unreachable  assumption thread remove operation cannot reference remove node valid anymore thread operation thread remove operation node unreachable expand thread scenario node become  later delegation image KB image node expansion avoid delegation mechanism  node hash realize marked invalid unreachable illustrates situation detail resides exclusively thread expansion valid node correspond bucket reference expand another thread invalidate unreachable remove thread interfere reference expand thread succeed update bucket reference effectively  reachable image KB image  invalid node expansion apply reclamation LFHT avoid guarantee node becomes permanently unreachable within execution correspond remove operation guarantee remove operation node marked invalid chain expand unreachable expand tag tag CAS expand thread fail avoid  expand thread verify invalid meantime skip expansion implement extensively without however critical flaw specific circumstance node  unreachable multiple expansion simultaneously hash expand node overflow tag  invalid node tag overflow aba described earlier illustrates aba image KB image  invalid node due tag overflow tag expansion simultaneously thread expand node thread expand node node expand bucket node perform CAS becomes aba another thread invalidates detects ongoing expansion increment tag becomes aba unreachable invalidates detects ongoing expansion increment tag expansion tag overflow becomes becomes aba finally resume performs CAS  succeed due tag overflow  unreachable node aba situation unlikely unable reproduce approach delegation benchmarking purpose hazard hash approach hazard pointer memory bound memory reclamation however rely thread synchronization perform sequentially consistent atomic writes node traverse reduce synchronization overhead memory bound task knowledge merge node define hazard pointer characteristic LFHT leaf node already grouped chain define maximum instead hazard reference node novel approach hazard hash HHL define leaf node novel approach thread maintains hazard hazard hash HH hazard HL data structure HH LFHT HL portion detail HHL approach guarantee limitation implement HHL approach extend LFHT algorithm data structure ensure thread cannot access node outside portion define hazard ensure thread recover preemption progress valid data structure hash node leaf node within node insert expansion thread recover thread return immediately hash node recovers LFHT insert expand operation priority perform concurrently priority expand operation thread collaborate undergo expansion insert node implement LFHT data structure bucket entry hash flag reference hash hash flag atomic reference leaf node generation hash insert tag hash tag atomic validity flag reference chain node information leaf node generation atomic tuple argument generation node meaning insert hash atomic tuple meaning refer node argument hash argument valid argument image KB image traversal node HHL approach HHL approach nutshell thread execute LFHT data structure protects reclamation define chain leaf node therefore leaf node reclaim chain thread reference despite meantime expand deeper guarantee thread protects chain leaf node reclamation advantage hash flag bucket entry tag leaf node knowledge node insert expand illustrate traversal HHL approach initial assume thread hash update hazard HL refer assume preempt node reading chain reference preempt configuration chain due concurrent expansion later guarantee resume safely reference ensure reference HL discus situation resume preemption situation reference refers tag HL safely chain reference situation reference due concurrent expansion refers hash node tag HL detect concurrent expansion  reference bucket entry understand expansion already refer expansion undergo node insert expansion safely reference situation reference due concurrent expansion refers node tag HL  reference however scenario refers reference node HL restarts traversal reference instead reference summary traverse chain relies tag expansion concurrently tag hazard protection traversal already completely expand reference node hazard delegation node remove thread local reclamation queue correspond remove operation invalidate remove operation unreachable delegate thread concurrent expansion delayed delegation postpone  guarantee reclamation information hash correspond defines generation defines entry tag becomes immutable invalidate defines hash reclamation trigger local queue pre define threshold node reclamation procedure reading hazard thread copying local data structure hazard pointer however HHL reading twice hazard perform reclamation memory node cannot avoid situation thread hazard access thread perform delegation unreachable hazard hazard solves unreachable previous situation cannot reading twice hazard node reclamation queue cannot reclaim hazard HH hash hazard HL HL generation tag hazard exists node reclamation queue otherwise thread remove node local queue reclaims memory memory bound everything memory reclamation however ensure finite memory bound infinite node insert remove specific chain without trigger expansion thread suspends fails chain thread continuously chain traverse prevent remove node reclaim unrealistic nonetheless situation node thread reclamation thread predefined threshold expansion operation specific chain guarantee reclamation previously remove node prevents node later progress previously remove node  thread acquire hazard chain already expand define flexible memory bound improve performance expansion likely multiple thread concurrently specific chain multiple chain reduce contention cannot expansion hash traverse chain exactly hazard pointer hazard inform reclamation procedure hazard pointer reclaim node cannot expand delegation cannot hazard pointer intend situation extremely rare data structure almost hash function guarantee limitation guarantee addition guarantee lock freedom HHL define memory bound synchronization overhead hazard expansion define maximum amount  memory amount depends thread remove operation per thread trigger reclamation procedure node thread trigger expansion maximum node chain parameter memory bound factor reclamation procedure thread node thread iteration increase removal chain maximum node remove chain factor due specific thread exist thread occurrence per thread thread situation regard synchronization overhead HHL expansion atomic writes per operation hazard hash another hazard traverse chain expansion extra atomic per node traverse atomic hazard expansion traversal uncommon situation lock approach lock limitation usage alignment validity flag tag limit amount information tag limit maximum amount data structure consequently minimum bucket array assume address architecture address addressable address addressable implementation leaf node occupies address addressable leaf node therefore amount available tag exclude validity flag maximum amount hash consequently assume minimum bucket array entry reasonable limit data structure implementation detail algorithm update correspond hazard hash node inform thread thread traversal procedure  procedure within hash hash node return associate null leaf node algorithm pseudo code  procedure hash node  return tuple argument argument refers leaf node argument refers hash node chain algorithm argument relevant omit exist hash  return null argument algorithm image KB image algorithm  hash  algorithm  procedure traverse hash associate hash node hash node  within refer another hash node traversal return reference bucket entry within  correspond refers chain node leaf node hash node  traverse former procedure execute thread update hazard restarts  synchronize update hazard reference obtain  otherwise  algorithm proceed proceed execute thread hazard HL concurrent expansion recall concurrent expansion interfere thread deeper hash HL expansion proceeds compute bucket entry otherwise concurrent expansion detect execute hash node deeper hazard HL bucket entry previous expansion meantime update hazard hash restarts finally traverse chain leaf node traversal chain reference hazard HL scenario traversal valid leaf node algorithm return tuple chain leaf node traverse algorithm return null expansion interfere somehow interference node  hazard HL  bucket entry ongoing expansion meantime update hazard restart hash node meaning expansion restarts node procedure remove operation algorithm pseudo code  procedure remove data structure exists algorithm update correspond hazard hash node leaf node removal  procedure node invalid fails another thread already marked node invalid  procedure algorithm proceeds unreachable finally  procedure local reclamation queue execute thread algorithm image KB image algorithm  algorithm image KB image algorithm  leaf hash leaf node unreachable algorithm receives argument leaf node hash node nutshell algorithm valid node chain node respectively   algorithm bypass node chain   unreachable detail algorithm  procedure traverse chain node reachable already unreachable return null otherwise return hash node chain initial traverse hash  procedure update hazard similarly  procedure continuation already unreachable  procedure simply return otherwise valid node      return null expansion interfere  procedure restarts interfere expansion meantime return unreachable delegate interfere expansion already unreachable successful algorithm bypass successful bypass CAS operation successfully execute correspond address  CAS fails bypass unsuccessful  restarts   important algorithm important understand actual algorithm pseudo code  reference already invalid leaf node hash node   procedure algorithm image KB image algorithm  leaf hash algorithm reading hazard HL bucket entry algorithm traverse chain leaf node valid data structure scenario traversal valid hash leaf node return expansion interfere somehow null return interference leaf node tag tag unreachable delegate interfere expansion meantime restart  procedure correctness lock progress discus correctness proposal proof consists proposal linearizable lock freedom operation focus linearization proof algorithm described enumerate linearization invariant proof linearization preserve invariant linearization algorithm  algorithm linearizable   algorithm linearizable   algorithm linearizable   algorithm linearizable   algorithm linearizable   algorithm linearizable   algorithm linearizable   algorithm linearizable   algorithm linearizable successful CAS  algorithm linearizable  invariant preserve data structure hash refers previous hash bucket entry belonging hash comply semantics initial reference update refer node follower update refer another node hash hash refer update node comply semantics initial valid update invalid valid accessibility node comply semantics valid reachable otherwise invalid sequence stage stage reachable stage unreachable stage  valid node chain node bucket entry belonging hash comply semantics initial chain reference update refer another node chain hash refers hash deeper refers chain reference invalid node update valid node chain node bucket entry belonging hash predefined threshold hash exists hash  hash bucket valid chain node node unreachable marked invalid unique finally proof linearization namely preserve invariant proof remain linearization proof strategy theorem linearization preserve invariant proof assume thread execute algorithm exists hash operation necessarily node null situation invalid already marked invalid update valid invalid remains reachable valid node chain decrease remain invariant affected invariant data structure occurs theorem linearization preserve invariant proof assume thread execute algorithm invalid node invariant execution CAS operation previous execution CAS ensures reachable ensures exists node  unique execution CAS failure memory address address  otherwise fails invariant data structure occurs successful CAS address  memory reference valid hash leaf node address bucket entry  reference leaf node deeper hash node obtain otherwise address leaf node argument tuple maintains leaf node valid  reference hash leaf node successful CAS unreachable remain invariant affected experimental experimental HHL lock memory reclamation methodology developed benchmarking compiles data structure memory reclamation module execution detail benchmarking environment visual representation benchmarking controller receives input parameter communicates data structure specific interface insert remove operation input parameter thread operation execute percentage insert operation percentage operation percentage remove operation image KB image benchmarking benchmarking stage initial stage launch thread data structure thread pre insert remove operation equally thread thread receives predefined pseudo random generator PRNG PRNG generates within generate distribute accord percentage correspond insert remove operation illustrates distribution procedure thread respectively however important random generate implies percentage insert remove exactly specify input parameter PRNG operation actual deviation negligible image KB image distribution thread operation stage executes benchmark reset thread initial execution thread performs operation accord generate PRNG thread execution benchmark execution optional stage correctness data structure verify insertion data structure remove stage execute error detect environment machine core amd opteron GB memory linux kernel memory allocator  default LFHT data structure configuration bucket entry per hash node threshold chain node threshold reclamation queue finally fix operation execution average perspective HHL approach implement optimistic implement optimistic approach thread private reclamation buffer node remove around reclaims memory node buffer entry refill newly remove node despite incorrect approach scenario memory reclamation  grace era implement grace era approach aba global atomically incremented removal local thread update global quiescent declare operation GPL grace lamport implement grace approach aba lamport quiescent declare operation thread thread update maximum plus performance analysis execution  GPL HHL approach benchmark percentage insert remove operation thread overhead imply normalize approach image KB image execution normalize approach  GPL HHL approach benchmark percentage insert remove operation benchmark insert  approach behaves closely ideal global update almost synchronization memory reclamation happens HHL approach hazard synchronize thread remain benchmark degradation grace HHL remains almost stable explain synchronization per quiescent declare happens per insert remove operation  GPL hazard era anchor hazard era  management instead equivalent quiescent operation node traverse guarantee memory bound similarly anchor GPL management procedure anchor maintenance recovery guarantee memory bound fully implement achieve performance obtain  GPL approach argue grace quiescent per operation competitive HHL workload non trivial amount remove operation insertion removal execution thread HHL grace throughput operation per LFHT HHL memory reclamation lock concurrent hash TBB library LFHT data structure configuration bucket entry per hash node HHL HHL respectively image KB image throughput operation per HHL TBB approach benchmark percentage insert remove operation nutshell HHL HHL approach benchmark TBB limitation benchmark perform insert remove benchmark mostly competitive HHL TBB benchmark mainly insert remove TBB suffers performance degradation benchmark TBB expose around modification operation per independently thread HHL almost linearly operation throughput workload modification operation thread ratio behavior TBB around operation per corresponds modification operation per clearly impact HHL lock approach TBB conclusion efficient memory reclamation lock hash data structure knowledge outside garbage environment implementation hash reclaim memory lock manner HHL hazard hash hazard define define memory reclamation update hazard operation HHL achieves synchronization overhead lock memory reclamation define flexible memory bound experimental HHL competitive scalable thread hash implementation lock implementation HHL memory reclamation adapt lock data structure LFHT extend removal reclamation hash node intend evaluate novel automatic memory reclamation automatic optimistic access access performance