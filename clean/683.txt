stabilize leader election algorithm network complexity logδ loglogn per node node network maximum complexity sub logarithmic complexity network logn per node algorithm sub logarithmic complexity knowledge algorithm algorithm stabilize leader election logn bound algorithm network bound obtain via non stabilize algorithm sophisticated distance stabilize manner complexity logδ loglogn per node latter allows implement sub logarithmic encode span IDs logn per node encode span logδ loglogn per node moreover construct compactly encode span without rely variable encode distance node variable logn per node keywords stabilisation leader election span construction introduction motivation tackle memory efficient stabilize algorithm leader election stabilization paradigm recovery capability network intuitively protocol stabilize recover transient failure without external intervention leader election fundamental building distribute compute enables node network distinguish perform specific action leader election important context stabilization protocol various assume leader exists network fault hence stabilize leader election mechanism enables protocol network leader priori stabilization preserve composition technique memory efficiency relates amount information node enable stabilization mutable memory variable compute memory complexity stabilize protocol immutable memory code protocol complexity induces amount information transmission reduces overhead stabilization fault stabilization facilitates stabilization replication related foundational regard complexity context stabilize algorithm due node network memory per node task leader election talkative algorithm complexity stabilize leader election attempt compact stabilize leader election algorithm algorithm complexity perform restrict algorithm  levin  ostrovsky constant per node guarantee probabilistic stabilization vega deterministic stabilize leader election algorithm propose prime node arbitrary assume node identifier node bound constant context deterministic stabilize leader election algorithm arbitrary identifier arbitrary polynomially bound complexity per node network stabilize leader election tightly stabilize construction existence leader enables memory efficient stabilize construction merge technique stabilize leader election algorithm network leader inward knowledge algorithm assume pre exist leader construction per node complexity due implementation technique algorithm recall technique pointer variable designate unambiguously node purpose construction pointer variable typically node construct specifically node designate unambiguously identifier pointer variable principle reduce memory per pointer variable network maximum node distance instead identifier identify however availability stabilize distance node algorithm per node previous stabilize distance algorithm variable instance algorithm node communicates distance neighborhood yield complexity random yield complexity finally deterministic algorithm reduces complexity per node achieve ignore another pointer variable node absence distance algorithm precisely suppose implementation per node date stabilize algorithm implement pointer variable complexity arbitrary network technique construction leader election distance variable distance node elect node network distance variable stabilize span construction cycle arbitrary initial clearly distance node network per node stabilize construction algorithm explicit distance variable complexity memory per node principle distance variable complexity attempt distribute information distance leader node accord mechanism enable per node however sophisticated mechanism demonstrate date stabilize algorithm implement distance variable complexity arbitrary network analyze stabilize leader election algorithm complexity node network maximum algorithm stabilize leader election algorithm arbitrary network complexity whenever standard model memory model stabilize algorithm network performs unfair distribute scheduler algorithm overcome bottleneck difficulty manipulate pointer distance variable arbitrary network overcome bottleneck achieve thanks development sub routine algorithm deserve independent described hereafter extend wise publication technique arbitrary topology approach retains per node complexity identifier independent propose stabilize algorithm distance complexity memory per node precisely algorithm achieves complexity memory per node oppose previous distance algorithm identifier encode pointer variable per node instead compact representation identifier per node enables symmetry distance permit distinguish node compact encode span technique detect presence cycle pointer approach distance uniqueness identifier network notably technique implement stabilize algorithm complexity memory per node technique avoid creation cycle execution leader election algorithm technique distance maintains span eventually reduces span leader completion leader election algorithm implement technique stabilize algorithm complexity memory per node model definition protocol syntax semantics distribute consist arbitrary communication graph node graph communicate directly node graph node graph complexity stabilization considers volatile memory memory content execution protocol non volatile memory content execution protocol code constant node unique identifier complexity volatile memory allocate protocol variable program counter command code execute achieve memory per node define function enable volatile memory remain threshold node access constant unique identifier access identifier function return significant identifier memory per node function immutable code portion node pseudocode function node node unique identifier execute unique code suppose node identifier notation binary notation implement assume identifier function return execute function program counter encode identifier encode assume node access locally unique associate adjacent assume consistency constant throughout execution initialize adversary contains variable variable domain variable denote variable node guard boolean predicate variable command variable assignment command update variable variable classical communication model model communication model model stabilization preserve compiler actual code assignment variable configuration guard configuration enable configuration disabled otherwise atomic execution subset enable per transition configuration another transition distribute maximal alternate sequence configuration maximality execution infinite configuration enable scheduler  model adversary scheduler chooses subset enable execute scheduler classify accord characteristic fairness distribution etc taxonomy assume unfair distribute scheduler scheduler challenge assumption subset enable chosen scheduler nonempty enable empty guarantee progress algorithm predicate specification predicate boolean function configuration configuration conforms predicate evaluates configuration configuration violates predicate otherwise predicate protocol configuration conforms protocol configuration conform protocol configuration conforms configuration execution conforms specification processor defines configuration sequence sequence variable subset processor subset specification prescribes protocol behavior output protocol external variable update protocol display protocol computation specification sequence configuration external variable protocol implement specification implementation mapping protocol configuration specification configuration mapping however unambiguous protocol protocol configuration specification configuration mapping protocol specification configuration establish protocol mapped specification sequence protocol configuration mapped correspond specification configuration  consequent identical specification configuration eliminate overall protocol satisfies specification mapping belongs specification protocol solves scheduler scheduler satisfies specification define predicate invariant protocol conform satisfies subsequent configuration predicate protocol attractor protocol configuration conforms contains configuration conforms relationship denote relation transitive predicate intermediate attractor towards definition stabilization protocol stabilize specification exists predicate attractor configuration satisfy satisfies definition leader election variable mapped boolean specification variable leader denote leader election specification sequence consists specification configuration unique definition model protocol execution finite otherwise protocol talkative complexity respect individual perform complexity stabilize leader election algorithm individual leader elect arbitrary configuration compact stabilize leader election network stabilize leader election algorithm span construction maximum node without distance multiple maximum node network identifier theorem algorithm LE solves leader election talkative stabilize manner node graph assume model distribute unfair scheduler memory per node talkative stabilize algorithm reuses extends technique obtain compact identifier memory per node leader election consists algorithm layer decrease priority stabilize distance permit implement pointer memory per node stabilize cycle destruction illegitimate sub span destruction reuse previous stabilize cycle detection distance variable talkative stabilize span construction distance variable algorithm trivially modify obtain leader election algorithm integrate previous component leader election protocol graph compact memory identifier deterministic stabilize leader election algorithm approach node unique identifier however avoid communicate reuse scheme devise previous progressively publish node identifier identifier node assume non zero binary representation node unique identifier leader election algorithm execution node algorithm defines phase differently communicate decrease significance encode identifier propagate possibly network subsequent phase propagation symmetry detect cycle span construction image KB image overview algorithm identifier constant communicate however encode identifier node upper bound identifier circumvent rank agnostic identifier extract previous dedicate propagation identifier phase remark slightly modify previous assume identifier node encode simply significant node irrelevant instead variable significant node binary representation variable core identifier comparison variable phase variable phase remark non zero binary representation identifier node non zero phase algorithm readable introduce variable compact identifier sequel meaningful node trivially detect error predicate whenever compact identifier global identifier phase moreover phase node node phase ahead node ahead another predicate capture denotes subset understood input upper layer algorithm detects error reset compact identifier phase command talkative node identifier publish compact identifier infinitely node active maximum phase phase active error active another active error detect detects error reset compact identifier phase trigger action error eventually disappear compact identifier respectively compact identifier significant respectively significant significant significant phase respectively node significant phase possibly respect compact identifier denote finally node compact identifier denote phase binary representation identifier node comparison compact identifier predicate node increase phase restarts dedicate protocol dedicate talkative protocol command dedicate increase phase restart command assigns node minimum maximum compact identifier subset principal ingredient compact identifier predicate node similarly node remark stabilize algorithm talkative phase maximum publication restarts phase consequence phase node maximum phase phase increase phase compute minimum maximum compact identifier denote function minimum maximum denote minimum maximum significant node compact identifier refer phase minimum phase node finally compute minimum maximum predicate minimum node predicate maximum node assign local variable minimum maximum compact identifier ingredient compact identifier stabilize distance assign unique distance bound  graph graph efficiently implement pointer mechanism otherwise memory per node remain organize concept function predicate algorithm formally algorithm dedicate establish proof correctness stabilize algorithm description compact identifier reduce memory usage node node conflict neighborhood identifier conflict node chosen node publish maximum neighborhood  maximum advertised plus conflict distance resolve node conflict distance publishes role relay computes advertises maximum identifier compact identifier mechanism identifier avoid modulo upper bound distance compute locally node stabilize algorithm node maintains variable denote variable denote variable minimum conflict neighborhood variable maximum neighborhood player node minimum conflict relay node minimum conflict minimum conflict node continuously update variable accord minimum maximum publish player node compact identifier compact identifier player relay node becomes loser node neighborhood player node phase compact identifier increase phase becomes loser conflict remains neighborhood player node neighborhood maximum phase restart phase relay node continuously compact identifier player purpose becomes loser node alternate relay player algorithm distance variable remain function predicate action algorithm exclusive node cannot function predicate action algorithm function return maximum define authorize node function return minimum conflict distance function return maximum distance predicate moreover predicate compact identifier global identifier predicate phase subset coherent predicate predicate minimum conflict announce conflict distance predicate minimum conflict minimum conflict function return subset minimum conflict relay node function return subset conflict distance relay node conflict distance image MB image execution scheme network rectangle denotes node variable upper disk denotes maximum distance variable disk denotes minimum conflict distance variable denotes absence immediately node denotes execute configuration execution interpretation reference legend reader refer web version article predicate whenever compete player phase node identifier maximum competitor lose competitor predicate relay node accord player node minimum identifier relay node maximum compact identifier player action update variable reset variable relative identifier command node maximum distance plus modulo assign algorithm assures variable node node maintain satisfy memory requirement protocol function return maximum neighborhood whenever exceeds reset dedicate update variable whenever neighborhood player node erroneous phase variable identifier another player node function computes minimum maximum reset compact identifier variable command increase node maintains command minimum conflict minimum identifier increase phase player minimum identifier phase update identifier variable relay node image KB image correctness theorem algorithm solves vertex  distance stabilize manner graph assume model distribute unfair scheduler moreover node identifier memory per node detail lemma sequel predicate configuration predicate intermediate attractor towards legitimate configuration configuration unique leader establish predicate indeed attractor potential function function configuration non negative integer strictly decrease algorithm execute remain potential function define closely proof argument lemma theorem various invariant define potential function output decrease invariant avoid additional notation configuration define predicate predicate understood characteristic function return configuration false otherwise lemma node sufficient enable distance graph proof distance distance distance distinct leaf available node configuration function potential function configuration define configuration zero function potential function denote configuration activation subset node denotes enable node due configuration empty lemma configuration empty proof node execute consequence decrease function define potential function define potential function define comparison configuration lexical denote subset enable node algorithm configuration algorithm stabilize node neither player relay node conflict distance define lemma proof function decrease execution remark non corruptible local information execute remains disabled afterwards moreover maintains inferior modify maintain invariant hence scheduler activates obtain otherwise activate already scheduler activates node obtain overall scheduler activates obtain scheduler activates focus node enable configuration node predicate activation obtain command command function argument applies compute identifier execution obtain thanks execution command command assigns remark remains disabled decrease thanks lemma configuration disabled node increase phase player node activation obtain execute decrease due predicate node function increase phase decrease conflict resolve node become player node relay node another hence decrease node conflict distance distance remains lemma algorithm memory per node proof variable compact identifier per node proof theorem lemma lemma lemma lemma algorithm converges proof potential function cleaning cycle impostor span graph suppose distance thanks previous algorithm construct span node maintains variable otherwise function return subset node variable variable manage algorithm span construction error characterize presence inconsistency variable node construction error node impact descendant node detects error algorithm descendant cleaning achieve algorithm already previous algorithm cycle detection thanks predicate impostor leader detection thanks predicate impostor leader node erroneously node detects cycle impostor deletes simultaneously becomes frozen node descendant becomes frozen finally leaf span node delete reset variable related cycle detection construction cleaning cannot livelock algorithm freeze stabilize algorithm memory per node important frozen node frozen node participate cycle detection span construction recall freeze algorithm algorithm binary variable approach advantage detect cycle cycle broken deletes frozen node cannot subtree due cleaning leaf cleaning cannot livelock image KB image theorem algorithm freeze deletes cycle impostor sub span node graph stabilize manner assume model distribute unfair scheduler moreover algorithm freeze memory per node converges proof theorem due stabilize algorithm cycle detection subsection stabilize algorithm detect cycle possibly due initial incorrect configuration without classical compute distance assumption global identifier hence node network compact identifier scheme postpone stabilize algorithm identifier detect cycle uniqueness identifier minimum identifier node identifier minimum receives identifier detect cycle similarly node minimum identifier detect cycle issue resolve minimum identifier propagate exist network erroneous initial variable minimum identifier leaf node denote minimum identifier obtain previous iteration protocol node node propagate identifier kid return function predicate core algorithm indeed node detect presence cycle publishes identifier publish identifier explain detail span structure node suppose belong cycle node cannot belong cycle minimum identifier variable belongs subtree denote node selects minimum upstream exists configuration configuration detect error due uniqueness identifier cycle image KB image span structure suppose node identifier identifier exist node selects minimum upstream exists configuration involve detect error indeed due uniqueness identifier identifier cycle remain node selects minimum upstream exists configuration belonging node minimum restart computation minimum identifier purpose identifier variable avoid livelock previous variable variable lock perpetual restart node algorithm moreover node minimum identifier leaf contains identifier identifier node detects error minimum compute identifier algorithm contains update variable variable nevertheless enable variable minimum publish relative minimum declares intent restart minimum identifier computation erase dedicate declare intent restart intent restart execution algorithm depict image KB image image KB image execution algorithm network node node activate scheduler node orange detects cycle execution configuration identifier along correspond definition interpretation reference legend reader refer web version article correctness algorithm theorem algorithm solves detection cycle node graph stabilize manner assume model distribute unfair scheduler moreover node identifier algorithm memory per node integer node identifier denote node descendant node exists suppose node improve node vanishes execution predicate capture predicate define recursively improve node descendant improve descendent improve node bound action function define function define depicts evolution return minimum identifier function define comparison configuration perform lexical denotes variable configuration algorithm stabilize improve define lemma proof predicate configuration consideration simply review execute algorithm enable scheduler activates obtain otherwise error detect improve improve obtain consequence scheduler activates obtain definition improve scheduler activates obtain conclude configuration occurs later proof theorem span structure contains cycle node purpose contradiction assume node cycle definition node node node enable contradiction cycle node due  integer node contradiction assumption node lemma algorithm converges proof potential function stabilize cycle detection compact identifier refine algorithm compact identifier instead global identifier compact identifier node deduce phase node selects minimum compact identifier variable neighborhood previous configuration compact identifier become passive variable remain active otherwise variable active node increase phase moreover node increase phase information namely span node increase phase leaf node situation explain absence phase increase node identifier involve cycle suppose involve cycle another configuration increase phase phase active node increase phase configuration detects cycle error variable combine compact identifier usage permit obtain algorithm predicate account error related compact identifier management important cycle algorithm manage phase difference indeed node phase assigns compact identifier variable lexicographic modification algorithm minor increase phase passive node restart remark variable variable obtain memory requirement per node algorithm predicate predicate update account extra denote minimum compact identifier moreover predicate account error related compact identifier management important cycle algorithm manage phase difference compact identifier lexicographic image KB image theorem algorithm solves detection cycle arbitrary node graph stabilize manner assume model distribute unfair scheduler moreover node identifier algorithm memory per node converges proof theorem mimic proof algorithm extra factor respect algorithm comparison compact identifier talkative span construction without distance approach stabilize leader election construct span elect leader obstacle stabilize construction possibility arbitrary initial configuration cycle presence impostor span already explain cycle detection cleaning focus  configuration mimic fragment approach introduce ideal situation node fragment fragment merges fragment signature remains fragment signature maximum maximum maximum global identifier maintain span structure become relative remain relative relationship evolve become vice versa algorithm maintains invariant lemma indeed fragment merge signature signature descendant node identify approach permit construct acyclic span structure without maintain distance information variable signature relative identifier comparison lexical variable exists node otherwise function return maximum algorithm description detail algorithm algorithm chooses node variable update behavior creates thanks variable sub span node sub span subtree node aware signature becomes finally descendant update variable predicate capture trivial error impostor error construction span error priority image KB image predicate function return maximum trivial error impostor error construction span explanation compose predicate node without relative signature variable variable invariant satisfied node involve rerouting signature node involve rerouting signature tentative signature node involve rerouting situation image KB image various situation arise evaluate predicate node denotes variable denotes variable denotes variable arrow visually relationship situation multiset predicate evaluate situation announces hence predicate evaluates interpretation reference legend reader refer web version article correctness theorem algorithm ST solves span construction stabilize node graph assume absence span cycle model distribute unfair scheduler memory per node proof theorem denote maximum maximum lemma invariant node remains proof proof induction basis node algorithm chooses node maximum exist chooses maximum identifier maximum node execution algorithm node invariant preserve node maximum local denote node suppose execution node execution invariant preserve node execution algorithm node invariant preserve assumption assume execution algorithm preserve invariant inductive node assumption node cannot algorithm assigns invariant preserve assigns invariant preserve lemma descendant proof proof induction descendant node otherwise error detect node iff exists maintains variable satisfied assumption assume exists configuration node descendant inductive configuration node descendant assumption exists induction assumption descendant remains inferior induction assumption cannot descendant subtree cannot exists execute obtain contradiction assumption descendant conclude descendant configuration remains descendant configuration remains empty configuration lemma exists acyclic span structure configuration execution maintains acyclic span structure configuration proof proof induction acyclic span structure basis contradiction remark thanks algorithm exist node node configuration relative node enable suppose purpose contradiction configuration cycle exists precisely achieve obtain contradiction assumption assume configuration exists acyclic span structure inductive node node lemma descendant acyclic span structure preserve remark action delete cycle lemma descendant action maintains acyclic span structure conclude configuration maintains acyclic span structure lemma node ancestor ancestor proof suppose purpose contradiction ancestor lemma sub span ancestor hypothesis ancestor lemma contradicts lemma execute algorithm construct span node maximum maximum maximum identifier assume model distribute unfair scheduler proof function define node function define remark node cannot otherwise error detect predicate potential function define configuration node enable algorithm executes increase obtain executes implies empty execution become empty decrease finally executes implies therefore obtain lemma lemma obtain span construct lemma algorithm ST converges proof potential function adapt ST compact identifier obtain algorithm ST compact identifier node along algorithm execution node become non therefore remain fragment away non node enable multi hop comparison broadcasting convergecast span structure assure propagation compact identifier theorem ST solves span construction talkative stabilize node graph assume absence span cycle model distribute unfair scheduler memory per node node broadcast compact identifier variable previous algorithm variable descendant compact identifier phase proceed convergecast precisely node variable node consequence increase restarts phase assigns lemma algorithm ST converges proof theorem mimic proof theorem stabilize leader election assembly developed obtain stabilize leader election algorithm algorithm extra variable maintain node otherwise variable output leader election stabilize leader election algorithm combine algorithm already explain priority algorithm reset variable lesser priority algorithm moreover lesser priority algorithm modify variable priority algorithm algorithm prioritize arbitrary configuration eventually guaranteed distance network thereafter algorithm ensures cycle fake span undetected forever priority destroy terminates cycle fake span exists algorithm talkative elect leader forever bound algorithm terminate thanks theorem obtain finite span node maximum maximum maximum identifier lexicographic leader variable algorithm guarantee span node span remains forever elect leader theorem algorithm LE solves leader election talkative stabilize manner node graph assume model distribute unfair scheduler memory per node proof theorem activation algorithm bound exist node enable subset node enable algorithm node enable node belong span possibly otherwise enable exists node enable algorithm algorithm talkative node phase graph exists node exists configuration enable cannot phase enable algorithm schedule execution priority unfair distribute scheduler obtain convergence configuration node enable algorithm exists node enable algorithm thanks theorem obtain span node maximum maximum maximum identifier consequence node conclusion stabilize leader election arbitrary graph memory per node bound weaken stabilization model  schedule assumption unfair scheduler besides construction leader election research pave memory efficient stabilize algorithm stabilize maximal construction fix pointer variable distance permit memory per node network important byproduct approach respect previous longer hypothesis weak fairness progress sufficient complexity alter indeed complexity becomes per node previous although exist technique stabilization systematic manner context stabilization currently limited fix fix configuration finite implies protocol ala leader election per node instead developed systematic approach potential function obtain correctness proof complexity formalize technique future