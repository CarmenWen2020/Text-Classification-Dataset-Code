identify pairwise maximal substring sequence frequently construct computational biology application dna sequence cluster assembly due error sequencer algorithm accommodate difference formally collection sequence threshold mismatch threshold goal identify report mismatch maximal substring heuristic extend style filter technique employ application however cannot provably efficient guarantee sequential algorithm output distribute memory parallel algorithm global communication realistic assumption processor finally demonstrate performance scalability algorithm throughput sequence data keywords approximate sequence algorithm ham distance parallel algorithm introduction sequence algorithm core application computational biology generation sequence  sequence typically randomly sample multiple genome decipher pairwise alignment application interested sufficiently overlap prefix overlap genomic  assembly substring overlap compression rna sequence  etc throughput sequence illumina sequencer error rate predominantly substitution error algorithm tolerate mismatch error yield expensive alignment computation motivate application formulate mismatch maximal substring collection sequence threshold mismatch threshold report mismatch maximal substring sequence substring mismatch substring ham distance mismatch maximal substring neither mismatch substring efficient sequential parallel setting sequential algorithm output distribute memory parallel algorithm communication processor reasonable assumption occurrence substring across sequence assumption algorithm enforces effective partition series modify localize processing within processor demonstrate scalability performance parallel algorithm genomic datasets processor core related extend style filter approach employ underlie principle sequence mismatch substring substring therefore hash technique sequence substring identify exhaustively candidate output generate sequential filter heuristic broadly classify category filter filter substring filter parallel heuristic filter mainly focus correspond application propose parallel cluster est data clearly filter algorithm cannot guarantee candidate generate overwhelmingly output recently publish sub quadratic sequential algorithm insertion deletion along mismatch accelerate pairwise edit distance estimation sequence sequence alignment apply however sequence error rate mostly mismatch sequence alignment impractical quadratic complexity organize introduce notation data structure algorithm due absence provably efficient sequential algorithm algorithm parallel algorithm detail claimed bound communication discus implementation detail parallel algorithm finally discus implementation genomic gene expression datasets notation preliminary denote alphabet sequence throughout assume constant concatenation sequence unique lexicographically clearly exists mapping sequence denote identifier sequence correspond denote prefix denote prefix permit mismatch reverse denote therefore briefly review standard data structure algorithm array lcp data structure denote prefix substring generalize equivalently denote lexicographic arrangement compact trie consists exactly leaf internal node node label substring refer concatenation label node leaf node unique equivalently unique unique vice versa node ancestor array correspond leaf lexicographically inverse array prefix array ancestor leaf exist optimal sequential algorithm construct data structure operation purpose simulated minimum query rmq data structure array node uniquely interval respectively leftmost rightmost index leaf minimum compute constant rmq similarly prefix compute finally mismatch prefix compute terminology redefine report tuples constraint ensure threshold maximality thereby maximality whereas constraint ensures belong sequence sequential algorithm optimal identify node node marked node clearly satisfies specify iff correspond leaf marked node allows marked node independently denote correspond leaf subtree partition bucket unique bucket previous previous bucket satisfies specify hence valid output bucket bucket sort identifier correspond sequence therefore within bucket sequence contiguously report scan bucket bucket belongs unless bucket output entry contiguous chunk construction marked node implement via integer sort chunk implement proportional input output combine complexity constant alphabet mismatch standard data structure array directly enable approximate novel approach transform approximate equivalent carefully craft inexact inexact modify obvious generate modify correspond accommodate mismatch however strategy combinatorially explosive algorithm specification bound modify nevertheless sufficient compute mismatch maximal substring detail definition modify replace denotes modify obtain replace specify algorithm consists phase phase collection modify phase independently extract phase phase height therefore combine complexity phase replace obtain claimed phase detail detail phase phase recursive recursion collection modify denote previous illustration generate compact trie internal node trie consist correspond leaf subtree replace modify within prefix occurrence exactly contains modify therefore modify lemma sum height proof statement easily construction procedure statement via induction sum clearly sum generate height compact trie height compact trie remove prefix essentially analysis phase implement expectation generate lexicographic modify constant simply lexicographic obtain delete prefix occurrence therefore sort comparison sort algorithm sort successive compute constant sort construct compact trie standard technique construction finally generate proportional summary complexity overall complexity replace bound phase generate pre correspond node recursion generate immediately pas phase extract information discard delete subtree execution algorithm maintain correspond leaf recursion lemma bound assume detail phase phase seek phase independently generate linear output approach compact trie modify identify marked node recall marked node correspond modification modify clearly leaf correspond modify subtree marked node report trie linear creation trie sort modify efficiently modify lexicographic rank obtain remove modify sort via linear integer sort extract implement procedure described however approach report although per report complexity therefore improve complexity via bucketing achieve claimed ensure output report exactly exploit processing modify subtree marked node report iff modify satisfy unique therefore task execute efficiently processing modify subtree marked node partition bucket previous partition modify bucket sub bucket sequence originally sub bucket therefore associate unique previous correspond bucket belongs sequence within sub bucket sort modify identifier sequence belongs finally sub bucket sequence correspond sub bucket entry sub bucket report entry within sub bucket sort accord sequence identifier therefore entry contiguous chunk easily skip analysis overall implement therefore complexity assume constant theorem assume constant ham distance algorithm output capture algorithm mismatch remains parallel algorithm extend obtain provably efficient parallel algorithm assume input equivalently concatenate distribute across processor processor maximal substring mismatch essentially concatenation maximal mismatch various mismatch substring shortest maximal occurs mismatch uniformly distribute observation observation sequence mismatch maximal substring within maximal mismatch maximal substring contains maximal upon categorize illustrates output algorithm generalize however actual implementation operation equivalently data structure greatly presentation clarity implementation efficient implementation recent flick  construct data structure parallel sort processor flick  algorithm non trivial adaptation classic prefix algorithm  mayer processor contiguous chunk roughly array processor chunk correspond additionally maintain data structure reverse denote respective data structure denote image KB image illustration output distribute algorithm identifies initial accomplishes internal node distribute chosen internal node across processor node independently generate satisfy constraint generate generate distribute fashion independently processing internal node information locally retrieve requisite information communication strategy independent processing node localizes computation hence performance minimize communication overhead load balance via distribution construction data structure mention distribution partition distribute subtrees processor node primary alternatively node leaf primary node illustration assign primary node along correspond leaf subtree processor associate approximately across processor reasonable assumption sufficiently frequency occurrence substring across sequence  constant assumption easily perform distribution associate processor redistribution amount merely adjust boundary accord sort array partition across processor primary node processor assign seek achieve primary node assign processor correspond maximal clearly report processing subtree detail image KB image distribution primary node processing primary node overview strategy respectively input mismatch maximal substring desire output clearly output output observation mismatch maximal substring maximal  occurs therefore exists primary node generalize primary node output generate modify output modify initial handle modify difference modify generate output illustrate procedure primary node procedure recursive denotes correspond leaf subtree recall within replace modify within prefix modification straightforward generalization unique modify onwards terminology collection universe initial refer lemma partition universe subsequent partition generate specifically generate processing partition whereas generate processing partition simpler generate partition independently partition compact trie modify within identify node trie whereas node secondary node modify correspond leaf subtree secondary node therefore efficiently apply bucketing strategy described correspond secondary node generate intuition algorithm generate recall correspond leaf subtree primary node therefore processing primary node constraint correspond constraint efficiently generate partition denote correspond modification compact trie modify internal node trie denote apply described modify correspond leaf subtree another reverse prefix universe partition described compact trie identify secondary node within node secondary modification modify correspond leaf subtree secondary node clearly exactly bucketing technique described proportional generate finally generate multiple partition however exactly partition specify correspond mismatch therefore avoid reporting mismatch ensure maximality correctness procedure respect fix maximal substring sufficiently mention exists partition modification mismatch compact trie partition node modify diverge ensures maximality impose mismatch universe unique partition modification denote finally report uniquely processing specific partition belong multiple therefore processing reporting simply belongs another output bound initial construction distribution remainder algorithm localizes computation within processor devise complex strategy outline performance minimize communication overhead however preparatory execute primary node assign processor data structure etc underlie subtree locally compute additional deduce correspond globally distribute array etc rely communication achieve computation bound communication communication computation communication obtain claimed expectation involve parallel algorithm recursive construction modify partition processing partition generate output involves construction compact whereas involves bucketing sort modify scan bucket generate output construction compact consists modify lexicographic compute consecutive modify topology trie infer additional linear modify prefix modification therefore sort respect rank inverse array correspond obtain remove pertinent inverse array obtain query communication bound reduction task modify sort reduce integer sort standard linear algorithm compute linear query distribute array summary compact throughout execution algorithm construct locally linear modify involve bound construction compact processor primary node height respectively modify modify reverse prefix generate processing refer lemma therefore linear trie construction procedure construction compact node sum subtree primary node assign processor bound processor processing involves bucketing sort scan linear integer sort algorithm scan generate output linear output generate however encounter processing multiple although report therefore bound replace height obtain claimed bound communication distribute construction compact gathering relevant portion global data structure collective operation involve processor mention recursive construction modify compact query distribute array data structure query efficiently rely communication standard assumption available memory bandwidth communicate processor collective communication assumption satisfy query bound communication outgo processor query processor modify modify reverse prefix handle expectation per assumption accommodate therefore collective communication expectation bound communication incoming processor slightly tricky within modify bound communication incoming query sufficient lemma fix query expectation proof recall recursive algorithm partition processing node trie query iff exists modify subtree distinct bound maximum additionally modify fix query substitute obtain claimed bound argument query fix bound expectation therefore communication expectation communicate processor communication assume constant transfer processor another communication bound expectation complexity implement distribute array array processor local data structure array per processor construct described simultaneously bound runtime complexity derive without output retain memory standard output disk storage however multiple batch per batch processor complexity analysis communication bound bound per processor per batch batch derive bound batch available per processor limited available per processor bound algorithm batch implementation detail implement algorithm mpi wise distribution distribute SA lcp array refer within processor local local array representation distribute data structure generalize distribute data structure distribute distribute local data structure minimum query local array respectively processor enable distribute minimum query maintain processor array minimum processor local similarly construct array array integer array implement byte array entry limited throughput sequence byte representation compact described modify generate recursive construction compact compact trie array sort constitute compact trie lcp array contains prefix consecutive representation internal node internal node tuple compact construct recursion internal node internal node trie generate modify representation advantage representation integer exceeds limit unsigned integer datasets primary node limit integer bound maximum input sequence hence byte internal node byte representation construction distribute construct construct array correspond communication entry construct local implementation processor correspond local array construct gathering processor minimum local rmq array construct communication construct SA lcp constant collective communication operation selection primary node scan array primary node leaf straddle processor shift ranked processor completely within processor earlier assumption distribution prefix limit per processor array shift remain distribute construct identify internal node  respect array  array index internal node respectively internal node tuples generate  sort remove duplicate entry batch processing internal node internal node node batch memory available per processor accommodate construct communicate operation limited mpi implementation hence query distribute ISA minimum query limited limit depends upon mpi implementation internal node batch primary node partition node assign processor batch processor batch earlier others participate collective operation ISA minimum query address achieve load balance batch batch approximately uniform across processor described internal node tuples identify  duplicate entry eliminate sort internal node batch sort sort tuples sort uniform batch across processor sort hence performance construction compact input construction compact trie accomplish building correspond SA lcp array query rank trie SA minimum query construct trie lcp array query relation generate rightward extension modify generate output universe processing procedure instead SA compact trie generate context internal node generate internal node rank query distribute preform distribute query recursion batch communication processor sends batch query processor entry communication processor return processor query query construct trie SA sort SA entry rank constant communication trie construction communication complexity described remains valid lcp compact trie construct SA trie construct lcp array distribute minimum query partition entry array construct previous correspond processor SA entry communication minimum query index communication minimum query trie processor prefix consecutive trie SA minimum  entry query processor  trie SA entry processor distribute minimum query generate processing batch local lcp consecutive SA correspond trie compute query bound manner ISA query hence communication complexity remains generation maximal substring construct procedure described generate valid generate generate modify however bucket modify belongs query distribute array identify precede hence maximal substring generation extra communication query experimental intel xeon infiniband cluster node ghz core intel xeon processor GB memory  operating node cluster interconnect EDR gbps infiniband conduct node core per node core evaluate algorithm datasets detailed dataset ncbi sra  SRR consists sample genome yeast  datasets  SRR  SRR rna seq datasets randomly sample express portion genome rna sequence genome genome dataset sample uniformly random entire genome sample uniformly random rna sequence frequency rna sequence proportional expression correspond gene hence datasets constitute highly non uniform sample underlie genomic datasets illumina  sequencer   desktop sequencer  datasets            gbp gbp gbp dataset pre processing  data gbp gbp gbp input gbp gbp gbp redundant fully another clearly potentially overlap hence input useful significantly increase output without additional hence developed pre processing algorithm eliminate redundant rna seq characterize consecutive poly mRNA substring biological relevance hence trim poly avoid generate spurious output input approximately twice dataset dna strand strand reverse complement substitution input sequence consists strand correctly infer maximal substring sequence complementary strand input sequence account however remove duplicate introduce addition reverse complement sequence input slightly dataset runtime core core runtime sec relative  sec relative speedup core runtime sec relative  sec relative speedup core runtime sec relative  sec relative speedup depends upon application error rate sequence machine demonstrate scalability propose algorithm multiple dataset longer datasets respectively chosen subtree internal node depth significantly validate assumption derive complexity another observation leaf belong primary node subtrees internal node processing algorithm hence eliminate dataset function processor core illustrate behavior algorithm grows exponentially behavior reflect significant increase however improve error rate sequence machine application typically increase mismatch maximal substring satisfy criterion decrease reduce parameter choice processor core varied demonstrate reasonably perfect illustrate relative speedup core relative speedup core slightly improves experimental observation dataset ideal speedup due imbalance assign processor core batch approximately batch wise processing distribution internal node uniform profile datasets  software  cpu timer linux profile code sample frequency sample per per profiler compute cpu spent distribute query proxy imbalance assign processor core increase significant increase non remains approximately core additional due communication construction runtime core core runtime sec relative  sec relative speedup core runtime sec relative  sec relative speedup input ratio longer longer due difference coverage underlie sample genome respective datasets genome sequence dataset yeast genome coverage genome define ratio genome customary define coverage rna seq datasets varies express portion rate expression average individual coverage indicator depth sample cod within genome sample rna seq datasets average coverage coverage dataset coverage overlap input sequence therefore height likely hence faster difference datasets speedup exhibit image KB image runtime core datasets respectively profile datasets cpu query non micro core cpu query non cpu query non core cpu query non cpu query non observation core underscore importance parallel algorithm core datasets ratio roughly increase reflect exponential increase function runtime  sec limit algorithm dataset longer magnitude dataset core conclusion approximate sequence algorithm significant computational biology replacement quadratic alignment algorithm particularly throughput sequencer datasets parallel algorithm mismatch maximal substring sub quadratic sequential algorithm recently propose parallel algorithm date achieves parallel complexity report maximal substring reflect compute maximal substring degrades slowly factor additional error tolerate algorithm practical distribute memory model parallel computation demonstrate performance datasets constrain parallel computer available difficulty algorithm beyond core demonstrate algorithm useful identify overlap illumina sequencer typically rate substitution error sequencer account dna rna sequence worldwide algorithm significant impact currently explore algorithm application genome mapping assembly