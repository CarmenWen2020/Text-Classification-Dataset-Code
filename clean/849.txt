software commonly indirect realize dynamic program behavior however indirect challenge construct precise graph standard prerequisite static program analysis harden technique unfortunately identify indirect target compiler recognize  target default exist approach identify indirect target analysis function pointer address function approach however suffer false positive rate irrelevant function propose approach namely multi layer analysis MLTA effectively refine indirect target program MLTA relies observation function pointer commonly multilayer hierarchy indirect function pointer load hierarchy layer layer multi layer function pointer function MLTA dramatically refine indirect target MLTA effective multi layer restrictive  introduce false negative conservatively target propagation multi layer layer allows MLTA safely whenever analysis layer becomes infeasible implement MLTA namely TypeDive llvm extensively evaluate linux kernel freebsd kernel firefox browser evaluation TypeDive eliminate indirect target exist approach without introduce false negative demonstrate TypeDive improves scalability static analysis benefit semantic bug detection TypeDive semantic bug linux kernel CCS concept security privacy security software application security keywords layer analysis indirect target function pointer CFI introduction function pointer commonly program dynamic program behavior linux kernel unified apis file operation internally file implementation apis kernel function pointer concrete implementation invoke runtime invocation indirect icall icall target callback function entry virtual function icalls useful dynamic icall target cannot precisely static analysis inherent challenge construct precise global graph cfg connects icalls target compiler gcc llvm recognize icall target default user cfg option analysis encounter icalls analysis address function potential target option apparent drawback former limit coverage analysis latter limit scalability precision analysis hurt strength harden technique specifically bug detection inter procedural analysis skip icalls bug hidden icalls massive irrelevant function significant false positive bug detection technique likely explosion symbolic execution impede precise analysis furthermore integrity CFI prevents hijack attack restrict transfer predefined icall target inaccuracy icall target permissive CFI enforcement render protection ineffective importance identify icall target researcher attempt achieve pointer analysis analysis theory pointer analysis icall target program analysis however pointer analysis cfg analysis recursive computational expensive importantly realize precise pointer analysis typically guarantee soundness limitation pointer analysis recent practical CFI technique opt function analysis approach identify icall target function pointer session 8D security CCS november london united kingdom potential target function approach practically apply harden program suffer significant false positive indirect parameter void char unrelated function target propose approach multi layer analysis MLTA effectively refine icall target without introduce false negative exist analysis approach intuition MLTA function address belong multi layer hierarchy function pointer icall load layer layer hierarchy statement fptr function address function pointer fptr correspondingly invoke function icall function address load layer layer load function pointer fptr load multi layer fptr instead layer fptr address function function pointer dramatically refine icall target accordingly denote exist analysis focus layer layer analysis FLTA MLTA unique advantage multi layer restrictive layer significantly reduce false positive layer inner layer multi layer icall target FLTA layer union MLTA related multi layer icall MLTA subset FLTA multi layer elastic avoid potential false negative layer restriction confine icall target however multi layer available due escape MLTA permissive sub icall target without introduce false negative formal analysis MLTA guarantee effectiveness introduce false negative however challenge implement MLTA analysis maintain multi layer address function expensive storage computation aforementioned MLTA maintain fptr fptr fptr separately program maintain globally target program potentially maintain become complicate cast occurs frequently multi layer recursively maintain cast importantly multi layer source sink cast extract challenge complicate data involve MLTA address issue carefully avoid potential false negative challenge multi layer series layer associate icall target fptr maintain mapping fptr cast simply layer instead involve multi layer layer independent others icall function pointer load assemble layer multi layer resolve icall target restrict icall target effectively efficiently apply MLTA program additional effort pointer virtual function vtable frequently cast char render ineffective address develop mechanism precisely  correspond cast recent attempt enforce CFI program virtual function invoke virtual function implement derive others analysis realize extract hierarchy information program MLTA outperform MLTA refine icall target pointer recursively MLTA precisely cast therefore virtual function derive become valid icall target actual cast exists implement MLTA TypeDive TypeDive identify function address load layer layer conservatively capture escape evaluate effectiveness potential false negative TypeDive widely program linux kernel freebsd kernel firefox browser evaluation exist approach FLTA TypeDive additionally eliminate icall target complex program empirical false negative evaluation TypeDive introduce false negative FLTA TypeDive improve scalability precision traditional static analysis leveraged TypeDive peer function identify semantic bug security initialize variable manually confirm bug initialization bug linux kernel bug hidden icalls exist detection approach simply ignore significant false positive summary contribution approach propose multi layer analysis effectively refine indirect target MLTA elastic introduce false negative exist analysis approach technique propose multiple technique confinement propagation analysis escape analysis ensure effectiveness MLTA conservatively eliminate potential false negative extend MLTA program extensive evaluation bug implement MLTA prototype TypeDive extensively evaluate effectiveness scalability false negative apply complex program TypeDive semantic bug linux kernel session 8D security CCS november london united kingdom organize icall target resolve overview TypeDive TypeDive implementation TypeDive formally analyze MLTA evaluation TypeDive discus limitation related finally conclude definition background function pointer usage prevalence limitation exist approach motivate approach function pointer indirect program function pointer realize dynamic feature improve program performance achieve dynamic feature icall target function pointer originates callback exception handle virtual function program heavily virtual function realize polymorphism concrete behavior function runtime compiler address virtual function implement vtable address entry pointer program virtual function obtain function pointer index vtable finally function icall OS kernel function pointer extensively achieve polymorphism analogous invoke specific file indirect cpu cycle command dispatcher  invoke function input implement switch comparison function however implement switch icall efficient program retrieve function pointer input index function icall function pointer memory function pointer reside memory primitive variable  function pointer memory function preserve cast char understand conduct statistically linux kernel analyze llvm bitcode file instruction function pointer function address composite function address primitive variable former cast function instruction latter cast function pointer function address composite function address typically load composite dereferenced icalls MLTA exploit information refine icall target motivate sample usage function pointer code snippet defines function pointer fptr structure contains  void fptr char char struct fptr handler struct struct outer layer struct struct outer layer void char dst char src  src max len  dst src void char dst char src  dst src function  struct handler function instruction struct handler void handle input char user input char buf max len handler buf user input handler buf user input buffer overflow indirect function confine multi layer analysis function pointer fptr traditional potential target however MLTA identify pointer pointer handler function pointer fptr instance code function char argument performs boundary copying identical boundary code defines global variable initializes variable accordingly function handle input untrusted user input arbitrary malicious content handle input creates stack buffer buf fix max len retrieves function pointer variable user input stack buffer buf respectively exist FLTA MLTA identify icall target exist approach limitation exist FLTA relies infer target icall specifically FLTA identifies  icall program address function icall function pointer handler fptr address variable initialization FLTA label valid target similarly FLTA assign function icall however manual icall target function icall target function FLTA introduces false positive identify icall target trigger false alarm inaccuracy FLTA false alarm static analysis detect bug session 8D security CCS november london united kingdom layer analysis maintain func confinement maintain propagation identify escape indirect target resolve escape union intersect layer indirect target foreach icall function prop escape maintain data structure bitcode file overview TypeDive program llvm bitcode input output target icall TypeDive phase icall target phase inspects address instruction function analyzes cast instruction relationship identify escape phase built resolve target icall static analysis identify buffer overflow analysis detects buffer buf handle input proceeds memory access buffer within boundary icall FLTA target therefore analysis inspects function report buffer overflow due boundary however false alarm icall function cripple CFI protection inaccuracy FLTA security issue CFI protection CFI aim prevent controlflow hijack attack attacker maliciously memory variable function pointer divert bidding CFI indirect transfer indirect return predefined valid target therefore accurate indirect analysis protection attacker corrupt function pointer handler divert FLTA analysis employ recent CFI mechanism function approximation weakens protection attacker divert launch attack FLTA fails identify accurate icall target code program code inaccuracy significant false positive render analysis meaningful therefore develop approach effectively refine icall target approach multi layer analysis FLTA layer information function pointer icall target without layer observation motivates propose approach multi layer analysis MLTA insight MLTA target icall confine multi layer function memory function pointer memory memory recursively leverage layer refine icall target MLTA function pointer handler fptr retrieve therefore layer retrieve function pointer fptr MLTA target icall address assign pointer layer fptr program function satisfy requirement assign function pointer fptr therefore multi layer analysis remove false positive unique target overview TypeDive MLTA refines icall target analysis multiple layer introduce TypeDive practical implementation multi layer analysis refining icall target overview TypeDive input llvm bitcode file target program identifies target icalls output TypeDive consists phase analysis phase target resolve phase phase thoroughly scan bitcode file  information simplicity refer composite default TypeDive address function identifies address operation latter static initializer global variable instruction TypeDive analyzes address operation identify multi layer memory address assign handler TypeDive identify multi layer fptr TypeDive split multi layer layer efficient target propagation fptr split fptr layer fptr layer layer TypeDive information function hash layer associate function TypeDive identifies typed relationship operand propagation propagation pointer TypeDive analyzes cast operation maintains cast relationship propagation nest cast maintain cast operation component phase capture potential escape escape escape cannot icall target confine primitive cast composite cannot target session 8D security CCS november london united kingdom primitive target composite become undecidable composite escape phase TypeDive aim resolve target icall icall instruction TypeDive identifies multi layer function pointer series layer TypeDive initializes target layer FLTA iteratively resolve target layer layer layer layer target layer intersect target resolve previous layer layer TypeDive layer escape maintain escape escape TypeDive conservatively confine target icall output target overestimation target otherwise TypeDive query propagation cast target recursively combine target layer intersect target previous layer iteration TypeDive identify layer identify TypeDive report exist target icall otherwise TypeDive target resolve layer target layer intersect TypeDive effectively refine icall target TypeDive analysis conservative elastic TypeDive cannot layer immediately return target escape TypeDive resolve target previous layer TypeDive analysis sensitive maintain target TypeDive TypeDive goal effectively refine target introduce false negative valid target FLTA component TypeDive achieve goal phase layer analysis TypeDive phase phase identifies  global variable function address memory maintains function confine propagate importantly avoid false negative phase identifies escape instance undecided target maintain function confinement function address valid icall target memory variable function address TypeDive identifies layer maintains confinement global function function confine function address confinement function address load instruction static initializer global variable analysis sensitive information index function layer confinement address operation function pointer another confinement layer information enables TypeDive layer layer specifically function address initializer instruction TypeDive recursively identify layer maintain confinement function identify confines function layer confine function layer function layer FLTA layer identify function valid target icalls however layer identify unique function target icall icall confine icall maintain propagation multi layer  operation introduces layer confinement however another  operation function confine propagate target target potentially significantly expand propagation identify propagation thoroughly analyze cast operation  pointer another cast operation cast instruction cast operator static  llvm IR union implement multiple IR relies cast load instance cast operation identify source sink propagation maintain propagation sink source cast sink propagation nest sub source propagates sink recursively perform propagation nest sub source sink TypeDive employ data analysis cannot guarantee TypeDive function pointer load identify escape essence TypeDive identify confine target however become infeasible contains undecidable target escape specify policy identify  define unsupported non composite pointer char integer pointer  compute index structure criterion mandatory propagation thoroughly tracked layer analysis exclude non composite observation session 8D security CCS november london united kingdom potentially function target render layer analysis effective non composite significantly enlarge maintain data structure impact analysis efficiency contrast criterion pointer  compute undecidable identify composite escape cast unsupported unsupported cast unsupported policy intuitive cast propagates icall target source sink target unsupported undecidable target composite become undecidable applies policy propagates icall target policy composite cast unsupported pointer unsupported destination pointer memory target composite become undecidable identify escape analyze cast operation target composite extract source sink unsupported conservatively label composite escape cannot composite cast unsupported pointer composite function cannot pointer function treat composite escape sensitive analysis TypeDive analysis sensitive important refining icall target multiple function target therefore TypeDive computes index TypeDive sensitive analysis analyze operation pointer access array structs operation llvm IR   pointer arithmetic access composite index operation constant analyze index straightforward however index non constant uncommon TypeDive conservatively label escape function confinement propagation escape index sensitive analysis union naturally union treat composite recognize index phase II target resolve icalls information phase phase TypeDive resolve target icall TypeDive iteratively resolve confine target layer function pointer load memory target layer intersect target icall layer TypeDive recursively resolve target maintain confinement algorithm iteratively resolve target indirect input icall indirect target resolve function function confinement propagation propagation escape escape output  target indirect icall procedure  icall function propagation escape  address function   icall layer composite    index obtain along      ensure  escape  escape  function  merge target propagate   propagation  recursively target        return  intersect target layer    return  procedure   function propagation escape  function   propagation  ensure  escape  escape return null recursively target        return null return  propagation TypeDive  algorithm component target resolve algorithm algorithm TypeDive function  iteratively resolve target icall layer layer simplicity index omit algorithm target icall initialize address function icall TypeDive obtains function composite obtain TypeDive ensures escape query escape TypeDive query function function target confine index explain index cast TypeDive therefore query propagation propagate employ recursive function  conservatively function target target  target  layer intersect exist target  session 8D security CCS november london united kingdom TypeDive iteration resolve target layer TypeDive  another iteration TypeDive iteration cannot  escape recursive function  return null TypeDive analysis conservative cannot fails TypeDive immediately resolve return target return target algorithm icall target resolve target layer algorithm TypeDive conservatively target propagate propagate   initializes propagate target  target confines query function TypeDive propagate  query propagation TypeDive recursively target union escape TypeDive return null terminate target resolve  resolve target function layer  function parameter FLTA parameter consolidated approach false negative MLTA parameter composite propagate escape address TypeDive treat parameter composite function apply propagation escape policy parameter resolve target function TypeDive approach program principle propagation escape capture TypeDive safely resolve icall target without false negative conservative TypeDive terminates target resolve whenever escape described cast unsupported primitive identify escape introduces program virtual function vtable pointer cast unsupported pointer specifically pointer refer function pointer TypeDive meaningless virtual function pointer load  therefore develop technique overcome program polymorphic vtable entry vtable contains address virtual function  essentially global array static  constructor vtable pointer cast pointer function pointer construct virtual function vtable pointer load load  pointer vtable pointer load skip vtable pointer unsupported TypeDive directly virtual function specifically analyze constructor identify  virtual function function virtual function correspondingly icall virtual function ignore layer load vtable pointer directly resolve target layer load pointer query function approach multiple inheritance virtual function mapped forth avoid escape issue program TypeDive effectively program implementation implement TypeDive llvm version easy llvm pas input  llvm bitcode file TypeDive phase analyzes bitcode file generates data structure information phase analyzes bitcode file resolve target icall icall target maintain instruction indirect function target instruction TypeDive easily query important implementation detail generate bitcode file generate llvm bitcode file program challenge gcc specific feature asm goto strategy discard incompatible file rare option ignore error compilation dump bitcode file implement llvm module pas  llvm llvm IR analyze currently function signature struct array vector confine icall target conservatively exclude unsupported index llvm module pointer comparison challenge TypeDive llvm function easily incurs significant storage overhead TypeDive maintains multiple address hash implementation default hash function standard library integer index convert hash virtual function virtual function compile pointer automatically insert argument virtual function invoked icall argument invoke pointer cast derive pointer invoke virtual function derive argument instead derive fail function address session 8D security CCS november london united kingdom confinement propagation resolve FLTA cast MLTA comp comp comp formal representation FLTA MLTA confinement address function initializes propagation propagates function cast resolve decides icall target multi layer comp compatible multi layer exclude pointer argument compute hash virtual function instead TypeDive correctly resolve virtual function maintain cast identify layer TypeDive iteratively identifies layer identify layer maintain function resolve icall target layer outer layer layer outer layer host layer layer contrast layer host pointer layer therefore instead definition outer layer layer layer easily implement recursively parse    instruction directly layer pointer operand instruction identify layer conservative TypeDive instruction target alias layer conservative analysis ensures avoid potential false negative layer identify TypeDive obtains layer pointer obtain  identify index specifically  obtain  index zero however layer   index accumulate constant index index non constant TypeDive conservatively flag escape rare formal analysis MLTA effective refining icall target MLTA introduce false negative FLTA formal analysis MLTA FLTA assumption formal analysis focus operation related FLTA MLTA icalls address ignore others affect analysis simplify description proof assumption explicit cast cast cast variable information available variable code analysis scope assumption program implicit cast exists previous demonstrates challenge modify program eliminate violation assumption llvm generates IR explicit variable source code available formal representation FLTA MLTA contains code statement correspond action confinement FLTA code action confinement confine function return layer variable mlt return multi layer variable handler return fptr mlt return fptr comp return multi layer compatible define multi layer compatible another overlap instance another ptr multi layer function pointer ptr function pointer escape function layer ptr compatible ptr latter instance former ptr compatible ptr cannot instance latter compatible ptr due lack FLTA operation address cast involve function pointer icall confinement inspects address instruction address function pointer function function correspond function address memory propagation handle cast function pointer cast function pointer therefore function FLTA resolve target icall resolve specifically function inside valid target MLTA instead considers multi layer instruction confinement function function mlt mlt multi layer mlt obtain conservative backward analysis cannot outer layer analysis propagation MLTA handle cast load variable assign another variable function target reachable mlt propagate mlt reachable function mlt mlt union compatible mlt multi layer compatible mlt update instance mlt assignment ultimately mlt instance target instance MLTA resolve icall target resolve reachable target session 8D security CCS november london united kingdom  void fptr char  void fptr int struct fptr handler struct  handler void func char void func int struct handler func struct handler func struct struct handler FN FLTA icall  func however target func FLTA cast mlt union compatible mlt function union valid target icall formally analyze MLTA FLTA introduce sensitive define code pointer integrity recursively sensitive function pointer void pointer another sensitive pointer structure member sensitive lemma program cast sensitive FLTA FN MLTA FN MLTA introduces extra FP FLTA MLTA fps FLTA proof icall suppose target function truth FLTA FN suppose address confinement FLTA similarly resolve FLTA infers target icall contains MLTA FN suppose address multi layer multi layer cast sensitive involve byte suppose mlt confinement similarly resolve suppose mlt resolve super compatible therefore MLTA extra fps FLTA suppose suppose resolve MLTA mlt resolve MLTA subset resolve compatible compatible meanwhile resolve MLTA equivalent resolve FLTA icall target return MLTA subset return FLTA MLTA fps FLTA code MLTA introduces fps FLTA adequate predicate generally FLTA union MLTA propagation MLTA merge target compatible layer ptr MLTA fps MLTA lemma program cast sensitive FLTA FNs MLTA FN MLTA fps FLTA proof indirect instruction suppose target function truth FLTA FNs function pointer handler fptr FLTA report target func function however target func FLTA target cast outer layer FLTA implicit cast function pointer cast outer layer MLTA FN introduce FNs cast propagation MLTA handle cast conservatively mlt mlt layer cast layer however propagation conservatively propagates function compatible source compatible destination therefore MLTA function target cast therefore introduce FN scenario cast sensitive summary cast MLTA introduce FN MLTA fps FLTA multi layer confinement source MLTA fps program layer MLTA achieve significantly fps FLTA theorem MLTA introduce FN FLTA FNs MLTA fps FLTA proof lemma lemma theorem evaluation formal analysis MLTA implement TypeDive llvm compiler infrastructure evaluate TypeDive aspect scalability TypeDive excels program composite prevalent evaluation confirm TypeDive extremely program effectiveness reduce icall target goal TypeDive evaluation extent TypeDive reduce icall target false negative avoid potential false negative another goal TypeDive evaluation confirm TypeDive valid icall target important foundational approach apply TypeDive assist static bug detection mechanism demonstrate usefulness experimental setup apply TypeDive program linux kernel version freebsd kernel version release firefox browser commit  linux kernel compile  option module freebsd kernel firefox browser compile default configuration program compile flag fno inlining flag generate binary accurately contains debug information function simplify verification false negative analysis detect bug however TypeDive session 8D security CCS november london united kingdom module sloc load analysis linux freebsd firefox scalability TypeDive compilation configuration optimization aggressive code inlining although evaluation report effectiveness TypeDive compilation option evaluation option future experimental machine equip ubuntu lts llvm version instal machine 4GB ram intel cpu xeon cpu ghz core scalability TypeDive TypeDive construct global graph code linux kernel within spent load bitcode file promising scalability benefit TypeDive avoids data analysis pointer analysis analysis TypeDive split multi layer  reduce storage computation reduction indirect target goal TypeDive reduce false positive icall target evaluate effectiveness TypeDive extent TypeDive reduce icall target evaluation address function baseline false positive target remove report average icall target identify TypeDive program distribution target breakdown reduction layer average target average icall target report TypeDive icall TypeDive denotes icalls benefit TypeDive icall load function pointer composite TypeDive cannot ensure zero false negative composite escape icall qualify TypeDive exclude icalls enjoy reduction TypeDive icalls linux kernel target refine TypeDive func denotes address function program address function therefore traditional coarse grain CFI technique conservatively function valid icall target weak protection ave target signature average target apply signature function layer average target apply TypeDive icalls qualify TypeDive average calculate icalls benefit MLTA layer calculate average icalls cannot benefit icall func ave target ave target icall TypeDive signature TypeDive linux freebsd firefox reduction icall target func denotes  function reduction percentage target report signature approach layer analysis icall target ratio icalls cdf MLTA cdf FLTA pdf MLTA pdf FLTA distribution icall target MLTA identifies icalls target target FLTA infers icalls target icalls MLTA target icalls FLTA target MLTA average indirect target amortize linux freebsd firefox respectively average target reflect complexity static analysis traverse cfg analysis treat TypeDive generate accurate cfg average target reasonable metric however fail benefit TypeDive defense mechanism improve CFI evaluation target distribution icalls target distribution target distribution icall target cdf cumulative distribution function MLTA cdf FLTA MLTA consistently identifies target icalls FLTA pdf probability density function graph MLTA identifies icalls target FLTA icalls target graph static analysis icalls permit target MLTA analysis icalls target FLTA icalls target icalls seek runtime information reduce target reduction breakdown evaluate extent layer refine icall target evaluation TypeDive configurable layer specify maximum layer TypeDive maximum session 8D security CCS november london united kingdom analysis report target couple layer dramatically reduce icall target layer largely independent however reduction becomes steady layer TypeDive slightly reduce target linux kernel extremely complex code layer remove target program recent propose confine icall target treat layer analysis discus difference TypeDive false positive static analysis icall resolution invocation icall instruction invocation target instead unique code target however evaluation MLTA dramatically reduce average extremely complicate program linux kernel firefox average MLTA significantly improves FLTA technique average icall target reduce around comparison exist taint analysis analysis icall target author average icall target evaluate analysis accuracy measurement operating benchmark freebsd latter report icall target average although clarify difference evaluation calculate icalls MLTA layer icalls calculate average icalls cannot benefit MLTA report icalls assembly code usually target consideration therefore average exclude target icalls accuracy manual fix violation assumption detect comparison TypeDive automatically upper layer avoid false negative static taint analysis longer pointer analysis alternative approach icall target recent effectiveness  CFI FLTA pointer analysis CFI SVF comparison indicates evidence pointer analysis accurate resolve icall target evaluate program FLTA achieves accurate SVF program program MLTA performs FLTA kernel browser pointer analysis approach program specifically nginx kloc  kloc SVF cannot reasonable crash limited scalability pointer analysis approach technique MLTA analysis linux kernel code within therefore baseline layer layer layer layer layer linux freebsd firefox breakdown target reduction layer icalls multi layer analysis icalls pointer analysis approach MLTA accurate icall target efficiently false negative analysis understand false negative MLTA FLTA empirically icall trace linux kernel firefox browser partial truth trace intel PT processor trace qemu accurately icall trace PT trace intel PT hardware feature execution nearly overhead recent feature intel PT  realize trace collection  instruction dump operand trace intel PT generate another packet address instruction program insert  icall function pointer operand runtime  dump target PT trace address  instruction immediately icall implement instrumentation llvm pas code program compatible llvm compiler qemu trace unfortunately linux kernel fully llvm compilation PT trace kernel modification userspace code kernel therefore instead modify qemu source target icall linux kernel implement icall   function indirect instruction specific register target indirect  rax icall instruction realize  simplifies qemu code within  target address specific register return address stack immediately icall instruction implement qemu trace code cpu exec file qemu false negative analysis trace icall trace evaluate false negative trace source code information source file information callees specifically trace caller query global graph construct TypeDive obtain icall target callee trace icall target TypeDive correctly identify callee otherwise false negative without  perform evaluation intel PT however sequentially decode PT package consume suffers data loss session 8D security CCS november london united kingdom firefox manually google com youtube com firefox browser trace trace indirect caller caller however majority correspond bitcode file available experimental setup remove finally obtain unique icall trace evaluation TypeDive callee investigate function pointer load confine callee therefore cast however cast analysis code bitcode file contains cast analysis scope TypeDive callee bitcode file analysis TypeDive successfully discus TypeDive source code available comprehensively identify propagation linux trace linux kernel qemu employ  explore similarly remove source code analysis scope unique trace trace icall target report TypeDive TypeDive originally callees trace investigate callees layer analysis function specifically parameter int void interleave implicit cast int char implicit cast int unsigned int implementation TypeDive cast primitive traditional CFI equalize primitive integer pointer TypeDive approach however violation integration approach future although exist function false negative TypeDive introduce extra false negative empirical evaluation evidence TypeDive introduce false negative exist FLTA however due limited code coverage dynamic execution evaluation proof apply TypeDive program diverse input fuzzing symbolic execution improve reliability evaluation TypeDive semantic bug detection goal TypeDive refine icall target TypeDive useful semantic bug otherwise cannot detect shallow specification outof bound access insight target icalls peer function implement pre define interface semantics peer function detect deviation contradiction potential bug avoids challenge understand semantics detection approach employ TypeDive detect semantics error initialization security TypeDive identifies icall target typically semantically equivalent parameter function peer target parameter icall commonly initialize peer function report potential initialization bug function function parameter commonly checked peer function report potential bug realize detection llvm detection implement intra procedural data analysis parameter checked initialize return function checked statistically rank potential bug ratio peer issue detection apply detection linux kernel TypeDive report ranked potential bug chose bug manually confirm confirm  bug bug detail shade contains icall location infer target FLTA MLTA MLTA significantly reduces target bug detection efficient reduces manual effort confirm bug shade bug subsystem source file function affected variable impact bug byte uninitialized UI leak LK confirm TypeDive assist semantic bug detection accurately identifies icall target effective exist detection initialization security handle indirect bug limited information infer icall target false positive rate confirm bug manually target FLTA however significantly reduce MLTA confirm usefulness TypeDive bug detection static analysis bug hidden indirect initialization bug demonstrate benefit MLTA bug detection bug information leakage bug linux kernel manually checked confirm leak byte memory bug static bug detector icall file   FLTA identify target bug detector analyze function bug importantly detection employ unrelated function likely bury bug comparison MLTA report target analysis effort buggy function  intel contains another icall bug detector analyze confirm bug icall FLTA report target MLTA permit latter target quickly confirm information session 8D security CCS november london united kingdom  file function variable impact driver gpu drm    drm  intel display  intel pll UI drm     pll LK drm     pll LK driver medium core ioctl medium     fmt sdr cap UI driver stag  core  security crypto lib crypt  lib   UI stag  crypt  prism   UI driver stag medium    stag   params  UI stag    params  UI default stag    params  UI default crypto alg crypto  hash hash accept  ctx UI initialization bug TypeDive shade location icall target infer FLTA MLTA UI denotes memory initialize properly LK denotes  information leakage indicates uninitialized memory leakage bug therefore bug FLTA MLTA reduces merely exaggerated explosion discussion indirect prototype TypeDive identify indirect target indirect mainly switch statement compiler usually identifies switch inside therefore target resolve exist compiler MLTA previous skip indirect however indirect intentionally definitely algorithm algorithm function target complement data analysis although  scalable data analysis complementary exclusive MLTA benefit  data analysis without alias involve rely taint analysis multi layer variable within function data analysis MLTA infer icall target analysis across function boundary data analysis equip MLTA scalable indirect assembly binary MLTA assumes function pointer define violate assembly binary code fortunately previous icalls assembly code easily resolve manual effort user program assembly code llvm IR propagate input operand output operand icalls binary infer information variable reverse engineering technique infer MLTA MLTA assembly binary scope variable argument function variable argument function reduces accurate function prototype MLTA hash function function therefore conservatively concludes fix argument however introduce MLTA stem function FLTA therefore future data attack TypeDive accurate graph cfg CFI achieve protection transfer however data attack survive CFI enhance TypeDive attack recent data attack expressive construct automatically attacker defender data attack benefit accurate cfg generate TypeDive attacker reachable  gadget false positive simplify attack construction defender calculate accurate data realize efficient data integrity related struct location vector propose CFI structure location vector  confine icalls  identify location function pointer struct location information icall target MLTA  important limitation construct vector  considers struct member structs nest structs pointer structs false negative struct OS kernel typically pointer avoid copying memory  handle cast generally instead treat cast however cast fundamental false negative properly handle taint analysis propose taint analysis icall target operating observation complicate operation function pointer inside kernel data analysis challenge taint propagation function pointer assign structure taint memory structure policy MLTA apply layer function pointer structure MLTA capture relationship layer moreover manual fix violation detect data pointer function pointer MLTA elastic automatically inner layer avoid false negative cfg construction researcher spent amount effort resolve icall target enforce integrity CFI program source code available icall target conservatively function icall valid function program source code available function information infer grain session 8D security CCS november london united kingdom target icall function CFI partial function parameter confine icall modular CFI function mixed infer function information program binary argument caller callees MLTA information multiple layer dramatically refine icall target recent CFI leverage runtime information restrict runtime transfer scope ensure runtime target valid instead MLTA aim infer target icalls statically resolve virtual related resolve virtual function relies hierarchy analysis hierarchy virtual divert function implement derive essentially approach expand layer target comparison MLTA multiple layer refine target virtual function derive cast valid target conclusion MLTA approach effectively refines indirect target program implement MLTA TypeDive TypeDive independent layer dramatically refine target TypeDive decouples data elastic avoid false negative evaluation TypeDive reduce indirect target exist approach function TypeDive significantly benefit exist static analysis harden technique illustrate TypeDive effectively initialization bug linux kernel