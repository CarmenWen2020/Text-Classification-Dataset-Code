mayhem automatically exploitable bug binary executable program bug report mayhem accompany spawn exploit exploit ensure soundness bug report security critical actionable mayhem raw binary code without debug information exploit generation binary mayhem address technical challenge actively manage execution without exhaust memory symbolic memory index load address depends user input propose novel technique hybrid symbolic execution combine online offline concolic execution maximize benefit technique index memory model technique allows mayhem efficiently symbolic memory binary mayhem demonstrate exploitable vulnerability linux program previously undocumented introduction bug plentiful ubuntu linux bug management database currently bug however bug exploit attacker typically serious patch central program bug bug exploitable mayhem automatically exploitable bug binary executable program mayhem  exploit bug report guarantee bug report actionable security critical binary code mayhem enables without source code access security software mayhem detects generates exploit principle introduce previous AEG mayhem exploitable augment symbolic execution additional constraint potentially vulnerable program constraint detail instruction pointer redirect attack code memory ultimately execute attacker code formula satisfiable exploit challenge exploit generation explore application exploitable tackle mayhem principle progress arbitrarily ideally forever without exceed resource memory maximize performance throwaway previous analysis reusable subsequent symbolic memory load address depends user input handle memory address essential exploit bug principle complex application non trivial program potentially infinite explore approach symbolic execution cute  klee sage  AEG SE others satisfy conceptually executor category offline executor concretely execution symbolically execute trace concolic executor sage online executor execute SE neither online offline executor satisfy principle addition symbolic execution symbolic memory principle offline symbolic executor execution principle satisfied iteratively explore independent others previous immediately reuse satisfy principle however offline satisfy principle restart execution program conceptually instruction execute repeatedly execution trace experimental execution expensive online symbolic execution fork previous instruction execute continued fork strain memory execution increase progress principle met online executor klee fork avoid memory executor satisfy principle principle potentially eliminate mayhem combine introduce hybrid symbolic execution execution alternate online offline symbolic execution hybrid execution memory manager OS efficiently swap symbolic execution memory pressure hybrid executor execution formula thread restore restore formula concretely program previous execution cache formula prevents symbolic execution instruction bottleneck offline manage memory efficiently online execution mayhem proposes technique efficiently symbolic memory symbolic memory access occurs load address depends input symbolic pointer binary generate  exploit generate exploit impossible due concretization constraint overcome mayhem employ index memory model avoid constrain index whenever encourage ample research mayhem currently generates exploit security vulnerability buffer overflow function pointer overwrites format vulnerability program mayhem demonstrates speedup offline symbolic execution without memory constraint online symbolic execution overall mayhem contribution hybrid execution introduce scheme  execution hybrid symbolic execution allows balance memory requirement hybrid execution enables mayhem explore multiple faster exist approach IV index memory model propose index memory model practical approach symbolic index binary binary exploit generation binary exploitable bug demonstrates exploitability output hijack exploit II overview mayhem overall architecture usage scenario challenge exploitable bug http server  highlight challenge mayhem source clarity simplicity mayhem binary code  vulnerability  http connection http request routine static buffer loop user request user input byte buffer conn buf buf increment variable conn buf byte prevent buffer overflow loop checked user byte without http loop abort server return error status message non error request via  function vulnerability server  user specify format http request  function fpr int format  stack argument exploit vulnerability format stack user data exploit additional format  desire location stack layout  format vulnerability detect  format argument user  highlight exploitable bug detail   detail return address stack pointer motivation focus binary technique enormous encounter statement exponential explosion additionally portion code related input  unfolds loop symbolic execution iteration longer input fork harder scalability challenge unfortunately exploit buffer overflow typical exploit byte checked exploitable  bug mayhem loop input fork interpreter error without careful resource management  symbolic execution thread execution execute natively symbolic execution concrete execution semantics instruction simulated software instruction server attacker socket execute instruction concretely switch symbolic execution mayhem architecture exploitable bug user mayhem mayhem sym net  sourcethe command mayhem symbolically execute  tpd socket symbolic byte packet remain exploit perform automatically mayhem architecture mayhem architecture mayhem consists concurrently concrete executor client cec executes code natively cpu symbolic executor server SES cec target SES platform connection cec cec binary program along potential symbolic source input specification input communication SES SES symbolically executes cec sends output normal crash exploit mayhem vulnerable code generate exploit sym net argument mayhem perform symbolic execution data socket effectively specify input source potentially attacker mayhem handle attacker input environment variable file network cec load vulnerable program connects SES initialize symbolic input source initialization mayhem executes binary concretely cpu cec execution cec code performs dynamic taint analysis taint contains taint instruction sequence instruction conditional instruction cec encounter taint target suspends concrete execution taint target dependent attacker input cec sends instruction SES SES determines feasible cec later target explore SES SES parallel cec receives taint instruction cec SES  instruction intermediate symbolically executes correspond IL cec concrete whenever instruction operates symbolic operand concrete operand SES maintains formula formula formula reflect constraint code conditional constraint input constrain input execute input execute exploitability formula exploitability formula determines attacker gain instruction pointer execute payload mayhem taint SES decides fork execution query smt solver fork execution fork selector prioritize upon SES notifies cec correspond execution restore resource cap checkpoint manager generate checkpoint instead fork executor IV generate terminate executor SES informs cec checkpoint execution execution SES switch context executor cec checkpoint restores execution execution cec maintains virtualization layer handle program interaction underlie checkpoint restore multiple program execution IV mayhem detects taint instruction exploitability formula query smt solver satisfiable satisfy input construction exploit exploit taint instruction SES explore execution perform exploitable bug mayhem user specify maximum runtime exhaust background binary representation symbolic execution perform assembly instruction execute overall cec explain earlier assume simply leverage  source binary analysis framework convert assembly intermediate suitable symbolic execution instruction execute symbolic executor  instruction  IL SES performs symbolic execution directly IL introduces additional constraint related specific attack payload sends formula smt solver satisfiability IL ret instruction consists statement load address memory address symbolic execution IL concrete execution program concrete input executes statement terminates symbolic execution restrict execution instead symbolic input variable input symbolic execution evaluates expression statement symbolic input symbolic execution considers target false target fork interpreter assert generate formula guard satisfied formula encapsulates met execute formula predicate mayhem IL statement correspond symbolic execution assertion IL immediately append formula conditional statement formula guard assert asserts negation guard false already formula execute  guard target formula FSE  FSE  sourcewhere symbolic execution target due semantics companion IV hybrid symbolic execution mayhem hybrid symbolic execution instead pure online offline execution mode mayhem alternate mode motivation mechanic hybrid execution previous symbolic execution offline symbolic execution sage input target program initial input offline concretely execute program input trace symbolically execute instruction trace approach concolic execution juxtaposition concrete symbolic execution offline execution attractive simplicity resource requirement handle execution diagram highlight immediate drawback approach explore execution execute potentially instruction symbolic execution fork explore instruction hybrid execution combine online execution memory offline execution efficiently explore input hybrid execution combine online execution memory offline execution efficiently explore input online symbolic execution avoids execution fork interpreter execution explore online execution simply perform context switch execution suspend interpreter SE klee AEG approach perform online symbolic execution llvm bytecode however fork executor quickly strain memory entire  halt online executor address aggressive optimization klee immutable representation SE snapshot physical memory disk nonetheless execution memory simultaneously eventually online executor memory cap mitigate dfs depth however useful strategy demonstrate SE coreutils application echo symbolic argument byte symbolic execution throughput generate per memory increase online execution throughput versus memory hybrid symbolic execution mayhem introduces hybrid symbolic execution actively manage memory without constantly execute instruction hybrid symbolic execution alternate online offline mode maximize effectiveness mode mayhem analysis online mode memory cap switch offline mode fork executor instead checkpoint online execution later crux distribute online execution task subtasks without lose potentially hybrid execution algorithm employ mayhem split phase initialization mayhem invoked program initializes checkpoint manager checkpoint database directory online execution program phase online exploration online phase mayhem symbolically executes program online fashion context switch active execution generate checkpointing checkpoint manager monitor online execution whenever memory utilization cap executor exceeds threshold generate checkpoint active executor checkpoint contains symbolic execution suspend executor predicate statistic etc replay information concrete execution discard online execution eventually active execution mayhem phase checkpoint restoration checkpoint manager selects checkpoint rank heuristic IV restores memory symbolic execution checkpoint mayhem construct concrete execution mayhem concretely executes program satisfiable assignment predicate input program instruction execution suspend concrete restore online exploration phase restarts phase avoids symbolically execute instruction checkpoint restoration phase unlike standard concolic execution execution happens concretely intuition hybrid execution detailed comparison online offline hybrid execution implementation cec cec binary program input source symbolic optional checkpoint input contains execution information previous cec concretely executes program hook input source performs taint analysis input variable contains taint instruction SES symbolic execution response cec receives address execute restoration whenever execution cec context switch unexplored SES execution cec terminates execution explore threshold checkpoint cec executes program concretely checkpoint execution virtualization layer online execution cec handle multiple concrete execution analyze program simultaneously concrete execution register context memory OS OS contains snapshot virtual filesystem network kernel guidance SES selector cec context switch concrete execution symbolic executor currently active virtualization layer mediates host OS emulates OS ensures across execution instance executor writes file modification visible execution executor instance file efficient snapshot snapshot concrete execution fork expensive mitigate cec across execution whenever execution fork execution reuses execution subsequent modification execution implementation SES SES manages symbolic execution environment decides execute cec environment consists symbolic executor selector determines feasible checkpoint manager SES cap symbolic executor memory cap mayhem generate interpreter checkpoint execution explore program mayhem unable explore due memory cap checkpoint prioritize mayhem exploration subsequent pending execution terminate mayhem selects checkpoint execution checkpoint consume mayhem exit symbolic executor maintains context variable context symbolic register temporary memory context symbolic data memory whenever execution fork SES clone symbolic memory execution immutable advantage optimization previous symbolic executor priority queue priority queue regularly update selector explore instruction precondition symbolic execution mayhem implement precondition symbolic execution AEG precondition symbolic execution user optionally partial specification input prefix input reduce user precondition SES explore feasible corresponds user minimum amount information selection mayhem applies prioritization heuristic sage klee explore currently mayhem heuristic rank executor explore code instead execute code priority executor identify symbolic memory access priority execution symbolic instruction pointer detect priority heuristic prioritize likely bug instance heuristic relies assumption previously explore code likely bug code performance tune mayhem employ optimization symbolic execution optimization effective independent formula algebraic simplification taint analysis klee mayhem split predicate independent formula optimize solver query implementation difference klee mayhem input variable formula construct query solver representation allows optimization mayhem applies standard optimization propose previous constraint subsumption optimization counter cache others mayhem simplifies symbolic expression formula apply algebraic simplification recall IV mayhem taint analysis selectively execute instruction symbolic data optimization speedup average execute instruction index memory model mayhem introduces index memory model practical approach handle symbolic memory load index model allows mayhem adapt treatment symbolic memory index entire memory model mayhem mayhem model memory index expression load expression index index memory load content ith memory load concrete index directly translate mayhem appropriate lookup  instruction memory mapped previous symbolic index model symbolic index occurs index memory lookup expression frequently binary code switch statement compile lookup input index standard conversion function ASCII unicode vice versa upper etc category handle arbitrary symbolic index notoriously symbolic index reference memory previous research approach handle symbolic index concretize index memory fully symbolic concretize instead indexed memory concretize index specific address concretization reduce complexity formula improve exploration however constrain index instance index concretization choice offline executor sage  memory address access concrete execution index treat memory fully symbolic    capability handle symbolic memory tradeoff concretization approach performance formula involve symbolic memory expressive exploration usually memory model mayhem implementation mayhem concretization approach concretize memory index decision severely limit address index usually satisfy exploit payload constraint handle symbolic memory concretization insufficient alternative approach symbolic memory avoid scalability associate fully symbolic memory mayhem model memory partially writes concretize symbolic model symbolically index memory model mayhem detail optimization memory model symbolic mayhem introduces memory global memory memory index expression unlike global memory however memory immutable whenever symbolic index memory mayhem generates memory contains access index partial snapshot global memory memory mayhem reduce evaluation load expression semantically equivalent return difference symbolic array introduce formula memory magnitude entire memory memory bound resolution instantiate memory mayhem symbolic index query solver memory address tackle mayhem exchange accuracy scalability resolve bound memory upper bound index bound conservative index within interval memory continuous realizable obtain bound mayhem solver perform binary index context predicate bound satisfiable unsatisfiability indicates recover bound bound instantiate memory symbolic array bound resolution algorithm described sufficient generate conservative representation memory mayhem symbolic memory detail optimization technique mayhem tackle caveat algorithm query solver symbolic memory dereference expensive binary identify bound index query average memory continuous bound infeasible memory consequently formula within memory structure model byte array opportunity optimize formula structure symbolic index access location memory analysis VSA mayhem employ online version VSA reduce solver load resolve bound symbolic index VSA return stride interval symbolic index stride interval stride bound interval stride interval output VSA approximation index instance byte byte symbolic byte interval interval VSA stride interval VSA refine solver binary strategy tight upper bound memory instance predicate asserts byte interval index byte refine VSA preprocessing cascade memory model perform query resolve bound memory stride interval eliminate impossible formula simpler elimination trigger optimization refinement cache VSA interval refine solver query refinement expensive instance approximation return VSA coarse avoid interval mayhem cache mapping interval potential refinement whenever cache query solver cached refinement accurate symbolic index resort binary refinement refinement cache reduce bound resolution query lemma cache entry refinement cache solver query mayhem another cache avoid repeatedly query equivalent formula formula structurally equivalent variable rename mayhem convert query formula canonical representation cache query lemma formula mapping canonical representation retrieve immediately cache lemma cache reduce bound resolution query effectiveness cache depends independent formula optimization IV predicate independent formula otherwise formula addition predicate invalidate previous entry lemma cache index  load memory symbolic resolve constraint involve load solver entry satisfies constraint ensure index entry realizable lighten burden solver mayhem replaces memory lookup expression index  ST binary symbolic index leaf node entry entire encode formula representation load expression concretely sort address entry within memory balance ST symbolic index define ST  addr    expression   initial entry addr return address entry entry ST return entry without construct expression definition construct balance ist instead construct ist nest expression formula depth entry instead logn however experimental balance ist faster nest ist mayhem construct ist entry memory conversion symbolic index conversion generate ST ST linearization bucketization linear function ist generation algorithm creates leaf node entry memory reduce entry mayhem performs extra preprocessing passing ist memory structure combine multiple entry bucket bucket index parameterized expression return memory index within mayhem linear function generate bucket specifically mayhem sweep entry within memory consecutive index tuples linearization  linearization memory split bucket bucket isolated bucket ist algorithm ist apply linearization linearization effectively reduces leaf node linear function simplify memory lookup observation linear frequently operation binary generate switch statement conversion translation ASCII unicode vice versa linearly index prioritize concretization model symbolic load memory beneficial memory significantly entire memory optimization activate memory approximate threshold whenever memory exceeds threshold mayhem concretize index access however instead satisfy random mayhem attempt prioritize concretization specifically symbolic pointer mayhem performs redirect pointer unmapped memory context predicate mayhem generate crash satisfy redirect symbolic pointer symbolic data mayhem redirect concretize pointer constrain symbolic data redirect pointer towards constrain mayhem avoid load  eliminate potentially identify constrain mayhem split memory symbolic sort complexity constraint associate fail mayhem  index valid memory address execution infer symbolic expression pointer valid null contains buffer overflow however attacker guaranteed hijack  overwrites return address program return instruction actually transfer however program performs dereferences succeed avoid crash program pointer ptr already overwritten user data mayhem augment prioritize concretization generate distinct crash invalid dereference pointer ptr crash dereferencing pointer fails successfully redirect ptr symbolic data exploit dereferences succeed user input hijack program memory layout mayhem reconstruct symbolic data structure VI exploit generation mayhem exploitable symbolic taint instruction pointer symbolic format corresponds buffer overflow format attack respectively whenever exploitable policy violate mayhem generates exploitability formula satisfy exploit mayhem generate local remote attack generic allows handle attack similarly mayhem detects overwritten structure exception handler  stack exception occurs  exploit buffer overflow mayhem generates exploit instruction pointer overwrite commonly trigger buffer overflow mayhem symbolic instruction pointer generate register exploit previous exploit instruction pointer trampoline jmp eax register eax memory shellcode encode constraint formula mayhem query solver satisfy exists bug exploitable generate register exploit generate simpler exploit instruction pointer directly memory shellcode format attack identify generate format attack mayhem format argument format function contains symbolic byte symbolic byte detect format payload within argument overwrite return address format function vii implementation mayhem consists OCaml code binary instrumentation framework built pin hook model api symbolic execution solely OCaml consists code rely  convert assembly instruction IL decision procedure built OCaml binding remote communication component implement platform rpc protocol OCaml additionally symbolic execution mode implement online offline hybrid evaluation experimental setup evaluate virtual machine desktop 0GHz intel core cpu 6GB ram VM 4GB ram debian linux squeeze VM XP SP respectively exploitable bug detection vulnerable program effectiveness mayhem summarizes perform strip unmodified binary linux application mayhem exploit packed binary program mayhem demonstrate exploitable exploit mayhem detect described VI symbolic source program symbolic input source mayhem command argument arg environment variable env var network packet network symbolic file file symbolic input describes precondition mayhem program split category prefix crash input described IV advisory report demonstrate exploit mayhem zero exploit linux application report developer contains exploit generation program mayhem analyze exploit generation analysis creation exploit varies greatly complexity application symbolic input program exploit linux wireless configuration utility  program scalability hybrid symbolic execution effectiveness hybrid symbolic execution across dimension memory memory hungry online execution average memory mayhem analyze utility coreutils cho online offline hybrid execution online execution maximum interpreter terminate execution memory increase linearly explore become deeper hybrid execution consumes memory online execution without exceed memory threshold utilizes memory resource aggressively offline execution throughout execution offline execution memory KB average performance demonstrate memory online offline hybrid mode memory online offline hybrid mode faster offline execution exploration bin echo limit maximum executor byte symbolic argument explore entire input reasonable amount maximum executor mayhem disk checkpoint average checkpoint KB symbolic equivalent offline execution maximum executor mayhem checkpoint disk equivalent online executor online execution around explore input offline execution online faster offline identify performance boost exploration limit maximum executor exploration limit maximum executor execution context switch execution IV mayhem spent execute previous offline scheme online spent context switch online cache efficient offline execution implementation specifically online execution efficient pin code cache switch memory execution code cache online execution faster offline execution additionally gui program  throughput offline hybrid execution chose program user interaction mouse click symbolic execution program execution mode hybrid execution faster offline execution handle symbolic memory application recall index memory model enables mayhem symbolic index program symbolic memory model exploit mayhem analysis unable generate exploit program without  memory model understand evaluate index memory model optimization  server bound resolution II mayhem vulnerability  optimization bound resolution algorithm exploit detection exploit generation affected bound resolution algorithm VSA reduces average query smt solver query per symbolic memory access reduces II effectiveness bound resolution optimization cache respectively lemma refinement cache define II effectiveness bound resolution optimization cache respectively lemma refinement cache define query refinement cache cache enable VSA cache reduces binary speedup lemma cache cache optimization cache burden cache additional speedup cache efficient relies heavily independence formula predicate cumulative speedup index representation recall mayhem model symbolic memory load  effectiveness optimization formula representation balance ST faster unbalanced binary representation linearization formula obtain cumulative speedup symbolic array  unable detect exploit within limit performance comparison ist   performance comparison ist    comparison evaluate mayhem ability source symbolic executor klee performance mayhem klee source mayhem binary code coverage coreutils application function mayhem application generate code coverage gnu  utility code coverage achieve mayhem progress coreutils application code coverage achieve mayhem progress coreutils application code mayhem achieve average coverage per application coverage comparison klee achieve coverage coreutils without simulated failure configuration mayhem mayhem competitive klee data mayhem specifically maximize code coverage however rough comparison symbolic executor comparison AEG picked program AEG exploit generation program configuration IV mayhem average AEG AEG source code advantage operating abstraction binary structure function variable buffer instruction execute IV another factor highlight difference source binary analysis positive competitive mayhem IV AEG comparison binary execution instruction IV AEG comparison binary execution instruction precondition additional presence precondition affect exploit generation specifically picked program crash input exploitable bug iteratively decrease precondition exploit generation summarizes normalize precondition normalize precondition byte crash input byte crash input precondition mayhem behavior program dependent program phase transition removal mayhem detect exploitable bug within limit topic future exploit generation versus precondition exploit generation versus precondition performance tune formula optimization recall IV mayhem various optimization technique solver query faster optimize version mayhem optimization chose linux program evaluate speedup obtain optimization comparison exploit generation formula optimization option algebraic simplification usually analysis average speedup program significant speedup independent formula optimization along simplification offering speedup exploit generation mayhem optimization exploit generation mayhem optimization incremental additional exploit generation incremental mode incremental formula comparable obtain independent formula optimization incremental formula outperform independent formula contrast previous implies solver incremental mode alleviate formula simplification optimization downside solver incremental mode symbolic execution mutable memory efficient taint instruction taint instruction evaluate symbolically mayhem execute natively percentage taint instruction program instruction taint sample program optimization speedup average taint instruction linux application taint instruction linux application IX discussion focus exploitable bug however technique adapt application domain context symbolic execution hybrid symbolic execution index memory model symbolic execution stress intention mayhem inform user exploitable bug exists exploit intend demonstrate severity debug address underlie issue mayhem effort bypass OS defense ASLR dep likely exploit generate however previous broken exploit longer ASLR dep automatically transform probability exploit bypass defense OSes exploit generate mayhem directly explore possibility limitation mayhem model library implementation model linux library analyze complicate program model artifact perform per symbolic execution symbolic executor SE  execute user kernel code limitation analysis expensive restoration spent analyze kernel code another limitation mayhem currently analyze execution thread mayhem cannot handle multi thread program thread interact message passing memory mayhem executes taint instruction pitfall taint analysis   implicit future mayhem generate exploit standard vulnerability stack buffer overflow format future direction extend mayhem handle advanced exploitation technique exploit heap buffer overflow vulnerability information disclosure attack detect attack safety mayhem currently employ however technique detect exploit program related introduce automatic patch exploit generation ape challenge  patch location bug slice construct formula code input source vulnerable mayhem vulnerability vulnerable code addition  notion exploit abstract input violates introduce exploit specifically hijack exploit automatically generate   technique crash input program along register automatically generates exploit research explores crash input AEG tackle identify exploitable bug automatically generate exploit AEG solely source code introduce precondition symbolic execution focus symbolic execution towards mayhem logical extension AEG binary code binary code automatic exploit generation wider program scenario binary symbolic execution frame      sage SE variety application domain tackle mayhem demonstrate exploitable bug hybrid symbolic execution technique completely hybrid concolic interleaf random concolic execution achieve code coverage XI conclusion mayhem automatically exploitable bug binary executable program efficient scalable mayhem introduces novel hybrid symbolic execution scheme combine benefit exist symbolic execution technique online offline  memory model technique allows mayhem discover exploitable bug binary mayhem analyze application automatically identify demonstrate exploitable vulnerability