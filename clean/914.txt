exploit vulnerability binary code challenge task lack semantically information data structure construct analysis program harder however importance binary analysis situation binary analysis disprove code actually execute binary analysis framework implement analysis technique propose systematize implementation technique allows researcher compose develop approach addition implementation technique unify framework allows comparison  identification advantage disadvantage evaluation perform recent dataset darpa evaluate effectiveness binary vulnerability analysis technique framework source available security community introduction despite interpret web binary analysis remain extremely important topic computer security interpret interpret binary program jit compile binary code core OS construct performance critical application usually compile binary code internet device resource constrain without cycle waste interpretation compilation firmware device tends usually compile binary unfortunately security guarantee vulnerability buffer overflow  remain software flaw despite concert effort develop technology mitigate vulnerability wider memory corruption vulnerability vast majority stem unsafe substantial portion vulnerability limited software purpose compute device remotely exploitable vulnerability discover device   automobile another important aspect compiler chain bug proven analyze source code program program compile happens recently malicious version   ghost silently infect popular iOS application insert malicious code compile compromise device user vulnerability serious consequence discover abuse paramount security research community invest substantial amount effort develop analysis technique identify flaw binary program offensive attack analyze application analysis technique widely approach vulnerability target suffer implementation binary analysis technique existence research prototype happens effort contribution waste future researcher scratch implementation upon approach startup discourages progress spent implement previous technique devote develop novel consequence amount reproduce frequent unavailability public replicate becomes impractical applicability individual binary analysis technique relative technique becomes unclear along inherent complexity operating difficulty accurately consistently model application interaction environment extremely establish comparison comparison exist tend underlie implementation detail evaluation datasets attempt mitigate issue angr binary analysis framework integrates binary analysis technique literature goal systematize encourage development generation binary analysis technique implement accessible usable effective technique research effort easily angr building analysis static dynamic technique propose research approach easily implement effectiveness additionally building enable composition analysis leverage strength introduce aim towards analysis technique research reproducibility specifically darpa organize cyber challenge competition explore automate binary analysis vulnerability  exploit generation software patch competition darpa release corpus application specifically realistic challenge automate analysis truth label vulnerability exploit challenge dataset binary perfect suite gauge relative effectiveness various analysis recently propose literature additionally darpa CGC qualify around automate binary analysis attack defend binary public opportunity exist offensive technique literature competitor goal gain understand relative efficacy offensive technique implement binary analysis detail implementation generation binary analysis angr offensive analysis developed technique specifically replication approach currently described literature reproduce vulnerability discovery exploit replay automatic exploit generation compilation rop shellcode exploit harden challenge overcome improvement achieve combine technique augment capability implement atop analysis explore difference effectiveness stem theoretical difference approach implementation difference underlie analysis enable perform comparative evaluation approach dataset darpa contribution reproduce exist approach offensive binary analysis coherent framework understand relative effectiveness offensive binary analysis technique difficulty difficulty combine diverse binary analysis technique apply source framework angr future generation research analysis binary code II automate binary analysis researcher strive automate binary analysis technique however despite recent advance challenge develop deploy technique serious limitation overcome perform automate analysis software challenge automate analysis discus darpa cyber challenge contest meaningful analysis approach offs binary analysis challenge crash analogous analysis quickly  halt program analysis offensive binary analysis tend carefully balance theoretical offs maintain feasibility offs  bug offs bug discover analysis replayable boil scope analysis operates analysis execute application exactly trigger vulnerability analyze individual application bug specific module cannot trigger execution module therefore cannot automatically replay crash semantic insight analysis lack ability program semantically meaningful dynamic analysis trace code execute application understand execute input application specific symbolic analysis specific byte input responsible program behavior semantic understand  input semantic insight analysis technique offs  associate coverage intuitive analysis technique replayable input understand code analyze unable analyze code analysis without replay trigger input validate bug analysis prioritize bug  suffer false positive flaw detection actual vulnerability absence replayable input false positive filter heuristic introduce false negative likewise achieve semantic insight program analyze analysis amount data semantically insightful dynamic analysis specific program static analysis tune semantic insight chosen data domain simpler data domain instead actual semantic insight analysis attempt reproducibility semantic understand encounter issue scalability retain semantic information entire application entry action processing capacity conceptually identical resource execute program analysis applicable discard information sacrifice soundness guarantee potential vulnerability discover aside fundamental challenge implementation challenge environment model analysis semantic understand model application interaction environment operating interaction incredibly complex version linux analysis model demonstrate various challenge binary analysis concrete program multiple vulnerability listing clarity simplify expose reader later memcpy buffer overflow however amount information tracked static analysis technique report memcpy potential bug information buffer overflow additionally report static analysis location bug input trigger dynamic technique fuzzing benefit actionable input trigger bug fuzzing technique typically shallow bug fail pas code precisely craft input listing dynamic technique difficulty bug specific input satisfied however overflow trigger random fuzzing technique input trigger bug bug introduce abstract data model input approach dynamic symbolic execution DSE however dynamic symbolic technique powerful suffer explosion grows exponentially quickly becomes intractable symbolic execution detect bug generate input constraint solver additionally memcpy cannot overflow however execution likely bug potential trigger bug listing technique report bug listing technique report bug darpa cyber challenge october darpa announce darpa cyber challenge darpa challenge robotics autonomous vehicle CGC pit around competition participant autonomous program participant goal cyber challenge autonomously identify exploit patch vulnerability software prize announce CGC qualify USD CGC USD USD USD respectively organizer cyber challenge competition automate binary analysis address environment model OS specifically CGC  OS  extremely operating transmit  data file descriptor random generate random data allocate deallocate memory management terminate exit despite environment model binary darpa CGC complexity kilobyte megabyte implement functionality echo server web server image processing library darpa source binary competition proof concept exploit ups vulnerability environment model feasible accurately implement evaluate binary analysis technique darpa CGC sample dataset comparative evaluation comparative analysis CGC binary offensive binary analysis underlie technique application analyze data domain utilize interaction application survey analysis depth evaluation focus specifically analysis goal identify exploit flaw binary software memory safety violation identification symbolic execution oppose binary analysis technique symbolic execution background static vulnerability discovery static technique program without execute usually program interpret abstract domain memory location zero abstract entity familiar simply integer explain abstract construct additionally program construct layout memory execution abstract split static analysis paradigm model program graph graph model data static vulnerability identification technique drawback relate offs II replayable detection static analysis verify information trigger detect vulnerability recover analysis tend simpler data domain reduce semantic insight approximate  absence program vulnerability suffer rate false positive statement regard presence vulnerability recover recovery graph cfg node instruction transfer pre requisite almost static technique vulnerability discovery recovery widely literature cfg recovery implement recursive algorithm  analyzes identifies exit successor cfg already connects analysis recursively exit identify cfg recovery fundamental challenge indirect indirect binary transfer target register memory location unlike target encode instruction trivially  target indirect factor specifically indirect category compute target compute application calculation specify code calculation rely register memory application register memory index memory target address index context sensitive indirect context application qsort standard library function callback target inside qsort caller caller callback function sensitive context sensitivity sensitivity orient polymorphism virtual function implement virtual function pointer consult runtime target target function caller technique indirect discus implementation vii goal cfg recovery resolve target indirect cfg indirect resolve address trigger context sensitivity target resolve cfg recovery analysis soundness cfg recovery technique potential transfer graph generate indirect resolve subset address actually target soundness graph decrease potential target target cfg recovery algorithm indirect cumulative failure resolve indirect severely reduce completeness graph soundness positive rate indirect target identification binary completeness cfg recovery cfg actually transfer cfg analysis errs completeness likely cannot really exist completeness inverse false positive rate indirect target identification cfg recovery analysis empty graph analysis graph instruction instruction ideal somewhere achieve scalable algorithm analysis compromise difficulty graph accurately code coverage code discover graph complicate presence code code unreachable vulnerability detection model vulnerability program discover analysis graph program graph vulnerability discovery program graph graph data graph dependence graph identify vulnerability software apply source code related technique extend binary technique rely building model bug node data dependency graph identify occurrence model application however technique gear vulnerable code technique benefit pre exist knowledge already exist vulnerability unlike technique focus discovery completely vulnerability vulnerability detection data model static analysis abstraction data upon application operates analysis static analysis approach analysis VSA VSA attempt identify tight approximation program memory register program understand target indirect target memory operation approximation suffer lack accuracy approximate approximate analyze approximate access memory writes location variable buffer identify binary recover variable buffer location analyze overlap buffer overlap buffer buffer overflow vulnerability detection potential vulnerability IV background dynamic vulnerability discovery dynamic approach analysis examine program execution actual emulate environment specific input focus specifically dynamic technique identify vulnerability binary analysis technique dynamic technique split category concrete symbolic execution technique input highly replayable semantic insight dynamic concrete execution dynamic concrete execution concept execute program minimally environment program function normal domain data normally zero analysis typically program specific input dynamic concrete execution user unknown dataset readily available fuzzing relevant application dynamic concrete execution vulnerability discovery fuzzing fuzzing dynamic technique malformed input application attempt trigger crash input generate hardcoded application depth monitoring execution application crashed specific input input trigger bug otherwise input randomly mutate unfortunately fuzzers suffer requirement without carefully craft mutate fuzzer anything superficial functionality program coverage fuzzing requirement carefully craft partially mitigate advent code coverage fuzzing code coverage fuzzers attempt input maximize amount code execute target application insight code execute execute vulnerable code american fuzzy  afl fuzzer responsible discovery recent vulnerability code coverage metric sole principle vulnerability driven increase fuzzing recent coverage fuzzing suffers lack semantic insight target application detect code execute cannot understand input mutate code execute taint fuzzing another approach improve fuzzing development taint fuzzers fuzzers analyze application input understand input modify future fuzzers combine taint static technique data dependency recovery others introduce protocol analysis improve fuzzing coverage taint fuzzer understand input mutate execution program unaware mutate input dynamic symbolic execution symbolic technique bridge gap static dynamic analysis cope limited semantic insight fuzzing dynamic symbolic execution subset symbolic execution dynamic technique executes program emulate environment however execution occurs abstract domain symbolic variable emulate application register memory throughout program execution constraint variable whenever conditional execution fork constraint inverse constraint unlike fuzzing dynamic symbolic execution extremely semantic insight target application technique trigger specific desire program accumulate constraint retroactively input application execute trigger analysis interested extremely powerful identify bug software dynamic symbolic execution active research classical dynamic symbolic execution dynamic symbolic execution directly vulnerability software apply source code dynamic symbolic execution extend binary code mayhem SE analyze application perform exploration vulnerable instruction pointer overwritten input attacker identify however offs II currently propose symbolic execution technique suffer limited scalability due explosion program increase exponentially instruction attempt survive explosion prioritize promising merge situation appropriate however challenge pure dynamic symbolic execution analysis  later bug discover shallow symbolic assist fuzzing propose address explosion offload processing faster technique fuzzing approach leverage strength fuzzing attempt mitigate weakness lack semantic insight application researcher fuzzing symbolic execution symbolically fuzzers modify input identify fuzzing component processing dynamic symbolic execution dynamic symbolic execution depth understand analyze program properly mutate input additional trigger previously unexplored code fuzzing component progress code coverage constrain symbolic execution another increase tractability dynamic symbolic execution execute application approach constrain symbolic execution effective identify potential bug drawback ensure context execution application false positive static vulnerability discovery technique constrain symbolic execution  bug detects exchange scalability background exploitation vulnerability discovery analysis actually discover crash input triaging crash input understand crash actual security issue outside scope approach however exist reproduction analysis discover vulnerability reproduce identify crash automatically generate exploit verify security impact crash harden exploit resilient presence mitigation technique crash reproduction vulnerability discovery analysis execute application realistic fuzzers randomize execution code source randomness pid executable fuzzing approach implicit assumption input instantiation application model randomness technique dynamic symbolic execution explore research randomization crash report vulnerability discovery technique trivially replayable outside analysis environment application generates random token token user unsafe code crash randomize analysis environment generate token crash input identify analysis crash however outside analysis environment token previously crash input instead non crash crash input trivially replayable generally category data vulnerability discovery technique sometimes manage response without application token constant randomize environment analysis fuzzer accidentally without retrieve program replay crash input outside analysis environment token crash relationship technique semantic insight fuzzing unable recover relationship data retrieve program subsequent data crash input application token user later crash output fuzzer lack relationship token application user token user application data input simply replayable outside analysis environment crash input analysis exist specialize identification data leak implement analysis angr latter randomize crash input convert input specification defines communicate application relationship data application data later approach  computes precondition program understand reproduce program exploit generation productive vulnerability  utilize described crash application however crash exploitable non exploitable input null pointer dereference operating disallow mapping memory address previously exploitable situation reduce non exploitable crash understand crash exploitable triaging bug understand bug investigate fix obvious crash exploitable exploit propose attempt crash input automatically convert exploit application exploit harden recent binary harden technique non executable stack address layout randomization ASLR severely reduce efficacy traditional exploit generate generation automatic exploitation exploitable vulnerability mitigate protection automatic exploitation technique widespread adoption mitigation technique software protection exploit non functional circumvent approach automatically harden exploit generate technique defense technique translate traditional shellcode exploit equivalent exploit utilize return orient program automatic approach construct return orient program approach developed VI analysis analysis described IV propose various implement technology evaluate disparate datasets methodology problematic understand relative effectiveness approach applicability application alleviate developed flexible capable generation binary analysis angr implement selection analysis previous describes analysis goal impact analysis realistic binary goal goal angr architecture embed device mips processor software hardware architecture departure previous decade analysis binary analysis perform architecture analysis furthermore processor longer standard analysis analysis binary platform vein architecture analysis analyze software operating concept specific individual operating abstract load executable format implement analysis paradigm useful analysis analysis described earlier abstract away memory model data domain usability purpose angr security community useful reproduce improve binary analysis technique  angr curve usability angr almost completely implement python concise api easily usable  interactive python constant performance potential choice binary analysis technique suffer algorithmic  impose performance impact rarely overhead important angr python jit  significant increase goal angr reproduction typical binary analysis technique platform reproduce veritesting symbolic execution AEG weekend constrain symbolic execution implementation effort estimate dynamic symbolic execution analysis implement building goal carefully analysis modular building various analysis careful maintain strict separation reduce assumption angr representation data model easy convert analysis easy researcher reuse individual module angr discus technical angr submodule submodule intermediate representation multiple architecture translate architecture specific native binary code intermediate representation IR atop implement analysis IR  extremely consume engineering effort leveraged  IR  valgrind project  IR  specifically program analysis  originally  expose  IR python leverage  analysis version mips PPC version latter amd processor improvement constantly valgrind contributor sparc architecture currently underway discus later fundamental restriction angr  IR implement intermediate representation straightforward engineering effort submodule binary load task load application binary analysis handle module CLE recursive acronym CLE load everything CLE abstract binary format handle load binary library depends resolve dynamic perform relocation properly initialize program CLE angr binary posix compliant linux freebsd etc  OS darpa cyber challenge CLE extensible interface binary loader binary application binary posix dll location inside CLE file format parse library specifically  linux binary  binary parse performs relocation expose memory image load application submodule program representation modification SimuVEX module responsible program snapshot register memory file etc  SimuVEX implement collection plugins option specify user analysis currently plugins exist register SimuVEX register program plugin correspond program symbolic memory enable symbolic execution SimuVEX symbolic memory model plugin implement indexed memory model propose mayhem abstract memory abstract memory plugin static analysis model memory unlike symbolic memory implement continuous indexed memory model abstract memory memory model static analysis posix analyze binary posix compliant environment SimuVEX plugins file symbolic file memory symbolic index SimuVEX everything memory writes file etc plugin inspection SimuVEX powerful debug interface breakpoints complex taint expression makeup symbolic interface behavior SimuVEX memory emulate memory mapped device solver solver plugin expose interface data domain data model provider claripy plugin configure symbolic mode interprets data register memory file symbolically constraint application analyze architecture architecture plugin architecture specific information useful analysis stack pointer  architecture etc information plugin source  module distribute angr plugins building combine various analysis additionally SimuVEX implement analysis semantic program application code SimuVEX terminology code  SimuVEX capability input  code generate output output encounter multiple output conditional SimuVEX modular addition  translation SimuVEX currently allows user handcraft python function  powerful python code implement environment model implement python function modify program submodule data model register memory  abstraction another module claripy claripy abstract internal representation expression operation expression expression become expression maintain link argument expression expression leaf node operation non leaf node expression translate data domain claripy backends specifically claripy backends concrete domain integer float symbolic domain symbolic integer symbolic float smt solver abstract domain analysis claripy easily extensible backends specifically implement smt solver solver excel constraint user operation interpret construct backends symbolic expression backend python primitive integer constraint frontends frontend augments backend additional functionality complexity claripy currently frontends  frontend expose symbolic user constraint backend cache  klee mayhem splitting constraint independent reduces load solver  transparent interface functionality  frontend constraint simply VSA backend interpret expression VSA domain   expands  constraint VSA constraint introduce  analyzes identify bound variable involve  subsequently consult variable intersect variable previously accurate VSA otherwise   combine   approximation symbolic constraint mayhem hint capability knowledge angr publicly available capability research community modular allows claripy combine functionality various data domain powerful expose angr submodule program analysis analyst angr analysis dynamic symbolic execution graph recovery entry analysis project binary associate library functionality submodules access examine retrieve intermediate representation hook binary code python function etc additionally interface program analysis analysis  interface dynamic symbolic execution application split terminate creation interface stem frustration management symbolic execution angr development implement hoc management analysis symbolic execution implement functionality hierarchy split merge analyze prioritize exploration understand promising terminate unified action  interface analysis angr abstraction program analysis analysis manages lifecycle static analysis graph recovery complex dynamic analysis IX angr identifies truth binary address address knowledge correspond project knowledge allows analysis collaboratively discover information application source release angr goal develop platform implement binary analysis approach unexpected challenge associate analysis realistic binary realize analysis extremely useful security community source angr basis future binary analysis researcher burden address challenge angr implement code usable directly  python module easily installable via standard python package manager pip source release angr analysis module described VI VI implement application XV latter source graph recovery static analysis framework dynamic symbolic execution constrain symbolic execution implementation release application future currently prototype code actively apply darpa cyber challenge angr met extreme enthusiasm community source release almost software github across module angr roughly installation via pip average clone git repository weekly angr already project another institution introduce binary analysis additionally aware institution basis research prototype corporation evaluate usability commercial binary analysis vii implementation cfg recovery angr generate cfg specific technique developed improve completeness soundness specific program angr performs iterative cfg recovery entry program optimization angr leverage combination execution backwards slice symbolic execution recover target indirect moreover generates quantity data target application later analysis data dependence algorithm drawback automatically handle code code reachable  indirect address issue secondary algorithm disassembly binary without execute heuristic identify function intra function inter function transition secondary algorithm however accurate lack information reachability function context sensitive unable recover complex indirect reminder discus advanced recovery algorithm dub CFGAccurate discus algorithm CFGFast vii assumption angr CFGAccurate assumption binary optimize algorithm code program distribute function function explicit instruction equivalent precede optimization reduce stack recursive function function newly function simply reuses return address caller stack cleanup behavior function predictable regardless CFGAccurate safely skip function already analyze analyze caller function stack balance assumption constraint binary angr analyze assumption binary analyze obfuscate behaves normal remove assumption analyze obfuscate abnormal binary cfg recovery cfg recovery code built upon technique propose related literature however technique assumption overly strict unrealistic binary specifically assume unlike cfg recovery function return instruction site target indirect program context exist literature assumes indirect compute oppose function pointer prior context expression target indirect idiom unlike exist assumption operation apply pointer stack pointer function return function overlap cannot CFGAccurate handle function code additional information relocation information available actual algorithm recover graph binary described iterative cfg generation unfortunately technique CFGAccurate goal recover cfg CFGAccurate construct cfg interleave series technique achieve completeness specifically technique execution lightweight backward slice symbolic execution analysis cfg iteratively recover technique initialize entry application throughout cfg recovery CFGAccurate maintains indirect target resolve analysis identifies iterative technique terminates CFGAccurate trigger technique resolve unresolved cfg CFGAccurate terminates technique indirect resolve available analysis execution angr CFGAccurate leverage concept dynamic execution stage cfg recovery execution ensures direction conditional execute CFGAccurate maintains analyze analysis initializes whenever CFGAccurate analyzes indirect however cannot handle execution target indirect actual program execution execute code unexpected indirect later analysis cannot resolve indirect analysis function pas cfg recovery analysis quickly analysis detect unresolved indirect symbolic execution issue dynamic execution presence indirect target indirect correctly resolve indirect completely  execution target uninitialized memory leaf broken transition recover cfg indirect partially solvable analysis retrieves portion target CFGAccurate traverse cfg backwards merge multiple converge indirect threshold empirically reasonable threshold performs symbolic execution indirect constraint solver retrieve target indirect CFGAccurate considers successfully resolve compute target threshold threshold resolve successfully unconstrained meaning target bound address resolve successfully remove node cfg target backward slice angr execution symbolic execution analysis fail resolve unresolved due lack context analysis context insensitive manner function pointer argument pointer target indirect analysis unable resolve achieve completeness cfg generation context sensitive component accomplish backward slice CFGAccurate computes backward slice unresolved slice extend previous context indirect analyze function slice extend backward node CFGAccurate executes slice angr symbolic execution constraint identify target symbolic threshold target target resolve successfully remove transition target recover cfg CFGFast goal cfg generation algorithm generate graph code coverage identifies location content function binary graph lack however graph useful manual automate analysis binary CFGFast function identification cod function prologue signature generate technique  identify function inside application application specify location function graph function additionally entry program graph recursive disassembly recursive disassembly recover within identify function indirect resolution lightweight alias analysis data combine pre define strategy resolve intra function transfer currently CFGFast strategy identification indirect target resolution goal quickly recover cfg coverage without concern understand reachability function another cfg recovery angr expose cfg recovery algorithm analysis CFGFast CFGAccurate analysis output cfg data angr knowledge VI data manual analysis later automate analysis implementation analysis cfg generate advanced analysis analysis analysis VSA static analysis technique combine numeric analysis pointer analysis binary program abstract domain abstract domain approximate register abstract location program VSA analyzes program fix program function fix tight approximation register abstract memory location function respect memory compute address consult compute fix target VSA propose perform analyze binary VSA binary develop improvement increase precision analysis discrete stride interval data VSA stride interval essentially approximation approximate normal concrete however target program approximate stride interval yield unsoundness recover cfg transition address target effectively developed data stride interval stride interval  stride interval  stride interval contains threshold adjust model II threshold semantic insight versus scalability allows maintain precision increase analysis complexity apply algebraic solver predicate constrain variable conditional exit merge procedure precise analysis affine relation analysis propose technique however complicate implement generally arithmetic operation constraint expression computationally expensive reality implement lightweight algebraic solver stride interval domain modulo arithmetic affine relation predicate conditional attempt simplify obtain variable involve predicate perform intersection newly generate correspond variable allows continuously refine analysis encounter increase precision eventual fix adopt  agnostic domain originally propose VSA operates stride interval domain assumes stride interval bound upper bound however heavily approximate unsigned arithmetic calculation approximation exacerbate address unsigned computation address generally relies unsigned unsigned comparison adopt  agnostic domain analysis wrap interval analysis interval domain analyze llvm code unsigned  agnostic stride interval domain theory apply VSA domain VSA memory corruption detection phase access program VSA access perform variable recovery variable stack heap implementation variable recovery scan stack heap abnormal buffer overlap buffer bound buffer simply report abnormal buffer potential memory corruption VSA interface angr program VSA analysis graph  enhance cfg program VSA fix program location parameter  analysis function function entire program program  memory abstract layout SimuVEX specifically  memory model memory claripy perform buffer overlap analysis data program analyze memory access IX implementation dynamic symbolic execution dynamic symbolic execution module analysis platform mainly technique described mayhem implementation memory model prioritization technique module core functionality angr analysis veritesting constrain symbolic execution claripy interface symbolic memory model specifically  SimuVEX individual execution program manage angr action predicate various specific information manage angr  functionality interface manage splitting merge filter dynamic symbolic execution angr built veritesting implement veritesting analysis expose transparent option  advanced merge technique mitigate exponential explosion statically selectively merge implementation constrain symbolic execution implement constrain symbolic execution  propose UC klee dubbed UC angr  dynamic symbolic execution technique execution perform function separately analysis cannot specific function detection  replayable function generate without context argument global variable actual execution analysis accurate suffers false positive  tag context constrain constrain data pointer constrain pointer demand memory allocation enables code manages complex data structure analyze security violation identify return address stack involve checked constrain status data involve constrain violation filter false positive technique described  global memory constrain UC klee implementation treat access global memory constrain however memory program context impossible predict  analyze function global data already potentially overwritten global data constrain false positive rate limiter UC klee implementation built limitation prevent explosion limit depth constrain pointer dereferences avoid constrain link terminate additional limiter abort analysis function responsible explosion detect cod limit empirically limit function replace function immediate return rewind analysis site function analysis tractable avoid explosion analysis accurate false positive filter introduce additional false positive filter implementation UC angr specifically detect exploitable attempt ensure incorrectly exploitable lack constraint constrain data perform constraint additional constraint express exploitable security violation overwrite return address constrain return address overwritten constrain constrain  constraint finally remove constraint constraint exploit function likely inherent flaw flaw necessarily data context flaw false positive due constraint due limited context data constrain UC angr implement  plugin constrain data access relocation plugin initialize constrain symbolic execution perform  paradigm dynamic symbolic execution XI implementation symbolic assist fuzzing summary symbolic assist fuzzing implementation approach driller detailed implementation symbolic assist fuzzing afl fuzzer foundation angr symbolic tracer monitoring afl performance symbolically trace input afl decision rate fuzzer discover transition afl report discover transition perform mutation input assume fuzzer progress invoke angr afl deem unique identify tuple source destination address transition afl unable input driller symbolic component implement angr symbolic execution symbolically trace concrete input afl avoids explosion inherent symbolic execution concrete input corresponds trace input heavily filter afl ensure promising trace concrete input corresponds individual   checked ensure recent instruction previously unknown afl smt solver query input execution input fed afl mutate future fuzzing feedback loop allows balance expensive symbolic execution cheap fuzzing mitigates fuzzing semantic insight program operation xii implementation crash reproduction implement approach propose  recover relationship input attacker sends output attacker leak application implementation  built atop symbolic execution define replay crash input input specification program initial crash algorithm input program initial entry executable crash input brings randomize environment properly replay uninstrumented environment implementation symbolically executes input constraint generate execute constraint execution program initial symbolically execute unconstrained symbolic input previously execution crash input constraint input output analyze relationship recover relationship data generate input specification crash input replayed implementation propose  limitation application crash reproduction discus crash retrieve data properly replay crash  unable handle crash input  execute application randomize environment processing crash input generate input specification execution trace binary random data  cannot compute input random cookie introduces predicate execution specific decode function replay execution constrain cookie initial happens replayed cookie replay attempt fail discus later AEG limitation suggests research progress task implementation exploit generation implement algorithm described  AEG mayhem evaluate effectiveness automatic exploit generation implementation allows exploit vulnerability attacker program execution overwrite instruction pointer overwrite function pointer exploit buffer overflow stack vulnerable unlike AEG mayhem  generate exploit perform concolic execution crash program input angr concolic execution dynamic trace concretely execute crash input apply program concolic execution program crashed inspect symbolic crash exploitability counting symbolic register triage crash category frame pointer overwrite instruction pointer overwrite arbitrary others instruction pointer overwrite technique simplest exploitable bug encounter symbolic instruction pointer crash detect symbolic instruction pointer constrain instruction pointer sequence instruction shellcode rop gadget pivot stack symbolic buffer execute rop chain generate exploit harden angr handle implementation detail AEG  taint building limit symbolic memory buffer apply constraint register generate exploit propose approach exploit CGC binary cyber challenge host custom OS lack execute program file exploitation within cyber challenge limited demonstrate register ability memory darpa standard exploit exist CGC exploit demonstrates attacker purpose register instruction pointer register exploit demonstrates attacker perform memory binary apply AEG succeed exploit binary binary generate exploit exploit unable harden rop resort jumping shellcode additionally AEG generate harden rop exploit automate exploit generation applicable vulnerability challenge demonstrate challenge attempt exploit cyber challenge binary  focus exploitation vulnerability mention challenge readme specifically buffer overflow stack exists decode attacker issue exploit generation presence predicate constrain byte overflow data despite byte chosen symbolic input  demonstrates decode function byte payload switch statement decode restrictive predicate vulnerable switch statement symbolic data data return concrete program traditional AEG approach assumes ability constraint symbolic data hijack behavior decode function desire byte output buffer performs desirable hijack vulnerable however exploit generation capability capacity prevent stack buffer overflow vulnerability CGC qualifier exploit automatic exploit generation xiv implementation exploit harden harden exploit mitigation technique implement rop chain compiler automatically generate rop payload fulfill goal data memory arbitrary function library focus difference improvement approach comprises gadget discovery scan executable code application byte offset identify rop gadget classify accord instruction sequence mov ebx eax pop ebx ret classify memory register load classification analysis leverage action angr symbolic relation claripy gadget arrangement rop chain compiler determines arrangement gadget perform action gadget data stack gadget pop data arrangement data register another payload generation rop compiler identifies requisite gadget arrangement combine gadget chain action execute attacker specify specify argument gadget arrangement program angr constrain output argument query smt solver input implementation differs minor stack scratch storage explanation analysis platform model stack operation another approach remains assume stack necessarily stack pointer unknown location integrate identify stack pointer stack metadata exploit generate implementation AEG another improvement gadget classification sample identify specific gadget gadget chain due limited coverage sample data approach symbolically analyze gadget careful cache technique analysis analysis implement evaluate literature XV comparative evaluation leverage angr reproduce binary analysis technique codebase enable comparative evaluation effectiveness knowledge previous comparison implementation possibility difference introduce implementation difference exception fuzzer afl analysis implement analysis code corpus CGC binary release darpa CGC qualification evaluation II binary widely complexity utilize environment model darpa reduce implementation effort analysis evaluate technique implement cfg recovery dynamic static vulnerability discovery crash replay exploitation exploit harden summary analysis implement evaluate along literature described cfg recovery cfg pre requisite analysis angr important understand angr cfg recovery performs detail vii angr cfg recovery algorithm CFGAccurate relies approach execution indirect resolution backwards slice symbolic traversal CFGFast mainly recursive disassembly heuristic quickly identify function inter function understand effectiveness recovery technique CFGFast CFGAccurate cfg recovery commercial ida pro CGC binary detail ida pro recovers cfg available description previous observation ida pro  binary recursively heuristic location function throughout binary utilizes lightweight data analysis target indirect conceptually CFGFast CFGAccurate truth cfg information available evaluate relative recover transfer ida cfg recovery II evaluation CFGFast CFGAccurate recover cfg versus cfg recover ida pro median average across binary crashed binary competitor CGC qualification evaluate completeness cfg identify CFGFast graph generate ida pro II CFGFast slightly code coverage ida pro recovers lightweight data analysis heuristic CFGFast advanced ida manual analysis recovery binary indicates CFGFast aggressive code recovery ida pro code reachable refuse disassemble code CFGFast identifies location code explanation approach overly aggressive identify location however identify analyze CGC binary binary analysis reachability information entry comparison reachable portion cfg generate ida pro cfg comprise entry cfg recover angr CFGAccurate analysis II improve execution technique backward slice angr substantially improves ability reconstruct cfg however CFGAccurate leverage hoc heuristic cfg code coverage ida pro achieve coverage user CFGAccurate recover function CFGFast evaluation vulnerability analysis technique XI implementation vulnerability discovery technique comparative evaluation technique apply CGC dataset evaluation timeout darpa competition retrieve evaluation dataset summary IV additionally context crash identify technique crash identify competitor actual CGC qualification overall rely crash placement qualify correlate competitor competitor seventh blog technique competition symbolically assist fuzzing technique conceptually driller implementation driller identifies vulnerability coincidence likely driven similarity technique IV evaluation across vulnerability discovery technique IV evaluation across vulnerability discovery technique dynamic symbolic execution chose evaluate dynamic symbolic execution alone presence veritesting explosion mitigation technique implementation detail approach IX dynamic symbolic execution frequently  explosion standard approach identify vulnerability CGC binary veritesting partially mitigate explosion identify combine application vulnerability identify surprised despite veritesting approach vulnerability dynamic symbolic execution alone investigate binary identify inherent veritesting veritesting efficient merge combat explosion responsible ability explore deeper binary explosion render progress impossible however merge introduces complex expression register eax differs merge merge complex expression encode previous overload constraint solver constraint solver tend increase merges constraint NP increase complexity vulnerability become unreachable within reasonable veritesting identify shallow bug dynamic symbolic execution otherwise explosion  constraint solver longer symbolic assist fuzzing assist fuzzing proven extremely effective literature XI discus implementation symbolic assist fuzzing dubbed driller symbolic assist fuzzer afl fuzzing component input afl trace dynamic symbolic execution identify code careful mutation input careful mutation symbolic constraint solver input reintroduce afl execution mutation individual input trace DSE input concrete explosion trace afl limit input DSE filter input increase code coverage mention afl alone identify vulnerability significant amount CGC service vulnerability symbolic assist fuzzer detect detect afl alone remain symbolic assistance DSE fuzzing difference various dynamic symbolic execution approach surprising reasonably DSE identify roughly vulnerability symbolically assist fuzzing fuzzing alone reality fuzzing identify almost vulnerability mirror recent trend security symbolic analysis criticize impractical fuzzers increase amount attention however situation odds research direction recent symbolic execution crash discover fuzzing dynamic symbolic execution analyze crash input approach identify exploit dynamic symbolic execution tend application dynamic symbolic execution veritesting fail vulnerability conclude due increase analysis complexity exponentially proportional specifically split conditional conditional fork amount analyze increase exponentially unreasonable analyze exponentially proportional execute analysis typical dynamic symbolic execution approach shallow crash execution crash tend hidden unreachable explosion understand relative effectiveness technique calculate code coverage generate symbolic execution veritesting average per binary median fuzzing median symbolic assist fuzzing median yield another conclusion generate fuzzing symbolic assist fuzzing combine graph cfg code coverage recover CFGAccurate virtue graph reachable definition perfect completeness imply improvement accurate cfg recovery algorithm constrain symbolic execution extend angr constrain symbolic execution understand effective technique dataset detail UC angr report vulnerability CGC binary however approach analyzes function without context suffers static analysis false positive replayable generate crash input instead location vulnerability identify false positive UC angr positive false positive rate report UC klee static buffer overlap detection vulnerability identify fuzzing symbolic execution static analysis implement VSA memory corruption detection analysis detail similarly UC angr VSA replayable suffer false positive VSA identify actual vulnerability CGC binary false positive false positive rate non replayable replayable analysis another surprising comparatively performance non replayable technique VSA constrain symbolic execution technique freed  requirement achieve coverage analysis context lack enormous amount false positive dataset false positive rate reasonable implement aggressive false positive filter filter positive improvement static analysis technique binary research attention direction future exploitation evaluation crash identify approach attempt replay exploit understand severity crash replay discus crash input identify vulnerability discovery analysis trivially replayable due environmental data random randomize analysis analyze crash CGC binary reference crash input darpa binary unable identify vulnerability vulnerability identification technique crash input trivially replayable simply replay crash input vulnerability identification analyze interaction binary recover challenge response component binary interestingly darpa imposes limitation author CGC binary CGC qualify disallows impact random data limitation  xii introduction predicate due random data apply operation CGC binary angr hang application manual analysis reveal implementation issue approach  recover input specification remain binary dataset suggests technique adequately handle binary absence variance random data evaluate possibly extend technique binary complex automatic exploit generation identify crash  input specification reliably crash target application however input exploitable crash null pointer dereferences CGC dataset exploitable exploitable non exploitable input attempt generate exploit crash attempt automatically generate exploit CGC application technique propose AEG however surprised crash exploit  exploit technique deeper binary understood goal CGC qualification crash binary exploit vulnerability binary actually exploitable null pointer dereferences CGC binary model realistic exploitation scenario technique propose AEG applicable majority fairly research enable automatic exploitation complex vulnerability exploit harden exploitable vulnerability mitigate protection exploit harden investigate recent  technique propose attempt harden exploit generate AEG implementation harden exploit AEG generate analysis remain exploit harden reveal approach utilize information binary attacker data stack stack pivot attacker data program approach basis operation exploit cannot harden xvi conclusion angr implement unified framework technique automate identification exploitation vulnerability binary systematize fashion analysis challenge encounter framework implement approach meaningfully effectiveness dataset evaluation technique evaluation basis highlight research direction improve exist technique angr source community focus address challenge binary analysis