coverage fuzzing widely effective software vulnerability code coverage utilize fuzzing crucial coverage fuzzers however accurate coverage infeasible due instrumentation overhead popular fuzzers afl coarse coverage information compact bitmap achieve highly efficient greybox inaccuracy incompleteness coverage introduce serious limitation fuzzers collision prevent fuzzers discover potential crash importantly prevents fuzzers wise decision fuzzing strategy propose coverage sensitive fuzzing collafl mitigates collision accurate coverage information preserve instrumentation overhead utilizes coverage information apply fuzzing strategy promote discover vulnerability implement prototype collafl popular fuzzer afl evaluate popular application collision collide others application collafl reduce collision ratio nearly zero moreover fuzzing strategy collafl outperforms afl code coverage vulnerability discovery average collafl program unique crash bug afl collafl security bug CVEs assign introduction memory corruption vulnerability severe threat program hijack attack information leakage attack defender attacker eager discover vulnerability program attacker rely vulnerability target program execution perform malicious action defender patch vulnerability defeat potential attack discover vulnerability advance coverage fuzzing popular vulnerability discovery widely deployed google OSS fuzz platform adopts coverage fuzzers libfuzzer honggfuzz afl continuously source application bug virtual machine code coverage crucial coverage fuzzers accurate coverage information fuzzers perceive unique explore vulnerability however infeasible coverage due extraordinarily instrumentation overhead fuzzers coverage accuracy performance libfuzzer honggfuzz utilize  instrumentation clang compiler coverage vuzzer dynamic binary instrumentation pin coverage afl gcc llvm mode static instrumentation compact bitmap coverage information coverage afl hash collision issue hash coverage bitmap loss accuracy coverage collide others application importantly utilize coverage information fuzzing crucial coverage fuzzers afl utilizes coverage information identify testcases contribute coverage pool mutation aflfast utilizes coverage information prioritize pool frequent mutation improve efficiency discovery vuzzer utilizes coverage information  error handle testcases frequent however fuzzers fail optimal decision code coverage information inaccurate moreover fuzzers utilize code coverage information directly fuzzing towards non explore knowledge consequence coverage inaccuracy overshadow fuzzers systematically evaluate demonstrate actually crucial impact fuzzers ability demonstrate accurate coverage achieve overhead coverage fuzzing strategy deployed fuzzers significantly improve ability explore bug coverage inaccuracy blur bug coverage inaccuracy fuzzers fail differentiate program testcase collides previously explore fuzzer wrongly classify thoroughly explore related loss code coverage potential vulnerability hidden similarly fuzzer wrongly classify newly vulnerability collides previously vulnerability importantly coverage inaccuracy blur fuzzing strategy prevents fuzzers optimal decision mutate aflfast prioritizes frequent inaccurate coverage capture approximate bitmap aflgo prioritizes closer target location accurate coverage information coverage inaccuracy issue render fuzzers selection policy inefficient bug improve coverage accuracy fuzzers aforementioned accurate coverage infeasible coverage coverage afl information coverage moreover afl coverage introduces runtime overhead others afl coverage fuzzers improve coverage accuracy however afl coverage imperfect due hash collision issue straightforward issue enlarge bitmap afl coverage eliminate hash collision introduce significant overhead coverage sensitive fuzzing collafl resolve afl hash collision issue improves coverage accuracy without performance loss furthermore collafl leverage accurate coverage information newly fuzzing strategy fuzzer towards non explore improve efficiency vulnerability discovery collafl resolve hash collision issue afl ensure target program unique hash afl differentiate specifically analyze graph target application carefully hash scheme assign IDs compute hash ensure instrumentation collision eliminate hash collision issue resolve fuzzers obtain accurate coverage information enable coverage sensitive fuzzing strategy selection policy accurate coverage allows fuzzer prioritize grain associate execution memory access operation untouched untouched descendant along correspondingly proposes selection policy memory access untouched untouched descendant prioritizes selection mention policy improvement fuzzer efficiency vulnerability discovery coverage sensitive fuzzing perform implement prototype collafl popular coverage fuzzer afl evaluate collafl lava dataset source application evaluation demonstrate hash collision issue prevalent application conflict others collision mitigation propose resolve hash collision fuzzer explore code unique crash security bug average untouched selection policy  collision mitigation improve fuzzer efficiency bug discovery average fuzzer explore code unique crash security bug security vulnerability source application report upstream vendor report researcher expose public remain vulnerability confirm cve summarize contribution negative impact coverage inaccuracy coverage fuzzers demonstrate hash collision issue afl severely limit efficiency vulnerability discovery algorithm resolve hash collision issue afl improve coverage accuracy overhead instrumentation scheme faster afl propose coverage sensitive selection policy empirical confirm prioritize accurate coverage information significantly improves fuzzers performance implement prototype collafl afl evaluate source application effectiveness collafl partially validate ability security vulnerability previously application II background related fuzzing fuzzing currently effective efficient vulnerability discovery fuzzers generate massive testcases target application monitor application runtime execution report bug security violation detect fuzzers usually easy setup application fuzzing become dominant vulnerability discovery fuzzers usually testcase generation grammar mutation grammar fuzzers generate testcases input grammar grammar fuzzers generate valid testcases program engineering translate input grammar fail handle application without grammar mutation fuzzers mutate exist testcases generate testcases without dependency input grammar scalability due simplicity scalability mutation widely adopt workflow coverage fuzzing coverage inaccuracy coverage inaccuracy however trivial mutation fuzzers usually code coverage input format trigger deeper vulnerability researcher improve fuzzers code coverage efficiency fuzzing coverage fuzzing towards improve code coverage successful coverage fuzzing employ evolve algorithm fuzzers towards code coverage afl libfuzzer honggfuzz vuzzer coverage fuzzers workflow coverage fuzzer usually maintains pool testcases performs continuous fuzzing loop pool specific policy mutate generate batch testcases target application testcases monitor program execution instrumentation code coverage security violation report vulnerability security violation detect filter testcases contribute code coverage pool continuous loop fuzzers prioritize contribute coverage evolve towards code coverage improvement loop promote efficiency effectiveness fuzzers factor fuzzer coverage accuracy selection policy mutation policy sensitivity security violation etc optimization propose improve throughput fuzzers afl utilizes fork mechanism linux accelerate adopts  mode persistent mode reduce burden fork moreover afl parallel mode enable multiple fuzzer instance collaborate wen proposes primitive afl fuzzers mechanism static instrumentation dynamic binary instrumentation debug emulation target application useful information afl utilizes gcc clang compiler perform static source instrumentation utilizes qemu perform dynamic binary instrumentation vuzzer utilizes pin perform dynamic binary instrumentation syzkaller  utilize qemu hardware feature intel PT fuzzers program crash indicator vulnerability easy detect without instrumentation however program crash vulnerability trigger pad byte array overwritten researcher propose detect security violation widely AddressSanitizer detect buffer overflow vulnerability sanitizers available  mem      detail coverage coverage fuzzers utilize coverage information fuzzing aforementioned coverage inaccuracy blur bug essential fuzzers accurate coverage reader aware coverage accuracy factor fuzzers program exhibit program behavior vulnerability accurate coverage fuzzers perceive however infeasible coverage runtime extraordinary storage overhead coverage fuzzers code coverage libfuzzer hong  utilize  instrumentation clang compiler coverage VU  pin coverage afl    coverage coverage infer coverage infer coverage coverage  remove critical secure latter inference coverage enhance version coverage coverage information coverage critical factor hinders infer coverage coverage critical function foo program sub function foo coverage exactly coverage exists fuzzers coverage libfuzzer  fuzz VU  improve coverage accuracy replace scheme coverage afl however coverage afl imperfect hash collision issue afl utilizes bitmap default KB application coverage byte bitmap statistic specific hash compute bitmap hash collision issue scheme hash fuzzer differentiate coverage inaccuracy specifically afl target application assigns random afl computes hash cur prev SourceRight click MathML additional feature  cur respectively due randomness hash moreover comparable bitmap collision ratio birthday attack  consequence coverage inaccuracy overshadow fuzzers systematically evaluate invisible afl application due hash collision issue greatly limit afl ability issue address selection policy recent selection policy fuzzing loop crucial coverage fuzzers selection policy improve fuzzer explore bug finding afl prioritizes execute faster likely testcases  honggfuzz selects sequentially lib fuzzer prioritizes VU  prioritizes deeper  testcases error handle frequent likely useless error handle avoid aflfast prioritizes frequent likely thoroughly waste selection policy strengthen fuzzer ability specific direction  prioritizes faulty code identify static analysis increase probability trigger vulnerability  prioritizes resource cpu memory increase probability trigger algorithmic complexity vulnerability aflgo prioritizes closer  target location commits review enable efficient fuzzing however fuzzers fail optimal decision code coverage information accurate aflfast wrongly classify hash collide poorly potential vulnerability moreover fuzzers utilize code coverage information directly fuzzing towards non explore proposes policy address issue mutation policy mutate fuzzing loop essential coverage fuzzers afl libfuzzer etc basically deterministic random algorithm mutate generate testcases mutation policy related core source mutate mutation generate mutation IMF learns dependency syscalls normal application execution generate testcases accordingly enable kernel bug  learns probabilistic context sensitive grammar abundant input testcase generation difuze leverage static analysis compose valid input user kernel driver recently researcher utilize AI technique fuzzing  godefroid proposes rnn recurrent neural network generate valid file generate input pas format improve code coverage nicole  proposes gan generative adversarial network argument pool extra another promising however research improve quality input another core mutation mutate vuzzer data feature infer byte mutate magic byte useful data  propose identify sensitive byte mutate static data lineage analysis   proposes dnn neural network predicate byte mutate promising improvement  taint analysis recognize checksum byte fix core mutation mutation vuzzer dynamic analysis infer magic mutate  fuzz deploys strategy recognize operand cmp instruction runtime greatly improve coverage laf intel transforms target application split constant comparison comparison statement enable fuzzer mutation faster focus improve fuzzers efficiency bug propose collafl coverage sensitive fuzzing component demonstrate focus improves accuracy code coverage utilizes accurate coverage information fuzzer replace selection policy detail research mutation policy optimization performance instrumentation scheme grain security sanitizers orthogonal propose benefit improve coverage accuracy aforementioned coverage inaccuracy blur fuzzers ability bug invisible fuzzers improvement collafl exist coverage fuzzers coverage accuracy fuzzers explore vulnerability coverage granularity coverage choice balance instrumentation overhead coverage accuracy inaccuracy issue coverage implementation propose coverage granularity coverage granularity coverage coverage coverage pro con typical coverage widely adopt fuzzers vuzzer libfuzzer honggfuzz however loss coverage information invisible coverage fuzzers typical coverage representative implementation afl instrumentation overhead coverage however lose information coverage code coverage information however application runtime overhead memory overhead coverage extremely infeasible coverage coverage balance efficiency coverage information however representative coverage afl hash collision issue inaccuracy collafl adopts coverage scheme fix collision issue fuzzers vuzzer benefit scheme trivial hash collision straightforward issue enlarge hash bitmap afl implementation however explain afl default bitmap KB performance chosen collision sporadic almost intend target usually sport  analyze microsecond effortlessly within cache illustration hash algorithm cur assign prev global variable cache assign execute evaluate efficiency confirm fuzzer performance quickly enlarge bitmap reduce hash collision ratio increase bitmap KB MB execution guarantee eliminate collision enlarge bitmap due randomness hash collision issue collafl hash collision equation afl fix formula compute hash prone collision refine carefully apply hash formula eliminate hash collision preserve hash computation coverage prev cur compute hash fmul cur prev cur prev sourcewhere parameter equation afl specific algorithm computation  afl overhead parameter compute hash simplicity parameter prev cached global variable prev parameter application parameter ensure hash compute via  greedy algorithm parameter differentiate hash resolve hash collision issue however guarantee application application traverse parameter guarantee exists randomly assign refine propose hash computation algorithm hash algorithm precedent precedent directly assign hash equation compute hash collide precedent combination parameter unique hash sole incoming introduce hash algorithm  cur prev sourcewhere prev cur assign parameter unique constant hash resolve offline cod collafl faster afl hash precedent application runtime overhead improve throughput fuzzer furthermore hash resolve avoid conflict hash unused hash assign precedent hash algorithm multiple precedent multiple precedent multiple incoming dynamically compute hash incoming runtime aforementioned equation compute hash earlier guarantee equation avoid collision remove precedent greedy algorithm resolve parameter denote resolve solvable denote resolve unsolvable unsolvable introduce another hash algorithm incoming  cur prev hash lookup cur prev SourceRight click MathML additional feature prev cur hash offline unique hash unsolvable hash runtime lookup precomputed hash hash runtime hash lookup operation previous algorithm fmul  limit unsolvable accord usually empty overall mitigation ensure bitmap hash otherwise avoid hash collision propose hash formula fmul   resolve hash collision apply formula fmul   solvable multi  precedent source algorithm collision mitigation algorithm algorithm overview preprocess application retrieve precedent information target application static analysis compiler  program split sub  multiple precedent precedent information  assigns unique random program assignment information algorithm parameter multiple precedent  solvable sol unsolvable  parameter solvable params hash hash hashmap unsolvable   unused hash hash algorithm demonstrates workflow  parameter multiple precedent parameter iterates BB traverse combination combination hash others combination classify unsolvable  otherwise sol params multiple precedent handle  otherwise another parameter previous algorithm appendix demonstrates  hash unsolvable  random unused hash unsolvable hash hashmap return unused hash  application coverage  solvable sol fmul afl parameter params unsolvable   hash hashmap runtime precedent code unused hash  eliminate hash collision algorithm  performance analysis earlier performance overhead propose hash algorithm  fmul  source accord precedent unsolvable num  num fmul num  source overall performance introduce hash computation collafl evaluation II introduces instruction performance afl application implementation detail collafl built coverage fuzzer afl extend afl llvm mode clang link optimization pas retrieve information assign unique resolve hash computation algorithm hash computation coverage code algorithm easy implement clang default implementation successor precedent information via api   however challenge resolve target indirect transfer offline affect precision precedent information wrongly classify none precedent extra refine entry function directly anyone multi precedent moreover unwind indirect instruction indirect instruction  technique connects reduce precedent fmul  compute hash reduce probability collision runtime accuracy information affect aware collision mitigation ensures eliminate collision collision runtime collafl moreover collafl currently application source code binary information accurate evaluate performance binary future IV prioritize selection exist selection policy mainly focus execution frequency depth none focus directly fuzzer towards non explore towards goal intuition non explore untouched likely mutation explore non explore non explore untouched descendant likely mutation explore non explore descendant eventual goal increase effectiveness vulnerability discovery towards goal another intuition memory access operation likely trigger potential memory corruption vulnerability mutation mutation intuition fuzzer explore discover vulnerability propose novel selection policy intuition worth policy limited fuzzer coverage information apply policy fuzzer improve efficiency vulnerability discovery untouched neighbour policy policy untouched prioritize fuzz mutation probability explore untouched simplicity denote policy collafl specifically untouched testcase    sourcewhere function  return  previous testcase otherwise prioritize fuzzed policy worth previously testcases return function  testcase dynamic worth iterate multiple multiple testcase loop contribute overall untouched neighbour descendant policy policy untouched descendant prioritize fuzz mutation probability explore untouched descendant denote policy collafl desc specifically untouched descendant testcase desc     sourcewhere function  collafl policy function  return descendant argument formal definition     source deterministic function  dynamic however descendant sub deterministic compute static analysis without runtime overhead similarly iterate multiple multiple testcase memory access policy policy denote collafl mem memory access operation prioritize fuzz specifically memory access operation testcase mem  sourcewhere function  EMI  return memory access operation argument compute statically compute deterministic unlike previous policy similarly iterate multiple multiple testcase implementation detail worth policy apply coverage fuzzer coverage information implement policy afl replace default selection policy aforementioned memory access operation descendant sub compile runtime testcase untouched descendant subpaths memory access operation along  specifically testcase coverage bitmap testcase hash decode hash untouched overall coverage bitmap descendant sub memory access operation already compute policy accordingly evaluation evaluate collafl conduct application impact hash collision issue motivation code coverage crash growth improvement effectiveness bug fuzzer application randomness fuzz comparison fuzzers chose popular source linux application version tcpdump clamav image processing library libtiff  audio video processing  libav document processing vim   etc chosen feature popularity community development activeness diversity category furthermore evaluate lava dataset application craft vulnerability evaluate setting fuzzer collafl collafl collafl desc collafl mem resolve hash collision apply selection policy default policy afl untouched untouched descendant memory access respectively fuzzer afl afl collafl aflfast collision mitigation evaluate fuzzers application configuration virtual machine configure core 2GHz intel cpu GB ram ubuntu vms memory GB comparison VM improve fuzzers performance detail evaluation appendix impact hash collision evaluate prevalence hash collision coverage fuzzer afl demonstrate motivation evaluate effectiveness trivial mitigation propose statistic target application file instruction collision ratio demonstrate prevalence hash collision statistic target application file instruction collision ratio demonstrate prevalence hash collision prevalence hash collision statistic target application KB MB hash collision ratio proportional consistent afl evaluation collide application  bitmap KB byte without conflict remain collide hash algorithm application collision effectiveness trivial mitigation aforementioned trivial mitigation hash collision issue enlarge bitmap effectiveness mitigation confirm collision ratio bitmap increase enlarge bitmap KB MB collision ratio  however hash collision ratio reduce bitmap due birthday attack randomness hash evaluate mitigation mitigation greatly execution fuzzer confirms afl concern tradeoff coverage accuracy performance execution  enlarge bitmap KB MB bitmap update runtime cache collision rate enlarge bitmap collision rate enlarge bitmap execution enlarge bitmap execution factor fuzzers fork afl  performs afl due execution restriction moreover execution crucial fuzzers reader aware factor fuzzers addition simply enlarge bitmap reduce collision ratio zero execution code coverage explore bug trivial mitigation hash collision issue effectiveness collafl mitigation eliminate collision delicate algorithm  fmul  assign hash II statistic mitigation instruction afl delta instrumentation perform collafl afl instrumentation collafl hash collision ratio mitigation II statistic collision mitigation collafl application   fmul  equation  fmul instrumentation collafl afl fourth prof collafl instruction afl application  average collafl instruction application afl worth collafl enlarge bitmap successfully eliminate collision otherwise bitmap KB guarantee bitmap fully utilized hash hash distinct remain collide others II bitmap KB  collision ratio collafl resolve collision slightly improve execution outperform trivial mitigation default afl code coverage code coverage important factor coverage fuzzers evaluate fuzzers source application coverage performance unique explore comparison evaluate aflfast demonstrate significant improvement discovery fork collafl applies collafl hash collision mitigation aflfast due limit source application appendix lava dataset explore coverage improvement aforementioned hash collision mitigation enable visible fuzzers selection policy explore untouched collafl likely improve code coverage application explore fuzzers within afl collafl default selection policy average collafl mem desc policy average respectively aflfast collafl default selection policy average prof collafl default selection policy outperforms afl aflfast discovery propose selection policy collafl propose hash collision mitigation selection policy improve code coverage pool code coverage coverage bitmap code coverage code coverage improvement IX appendix conclusion evaluation coverage growth appendix growth code coverage fuzzers source application within growth trend code coverage collafl collafl grows faster afl afl respectively collision mitigation apply collafl effective code coverage collafl grows faster collafl setting selection policy effective fuzzers usually stuck moreover aflfast outperform afl discovery usually afl worth evaluate effectiveness efficiency fuzzers crash fuzzers average crash IV vulnerability detect collafl within version target application unknown vulnerability vulnerability afl collafl default desc mem policy unknown vulnerability confirm cve ace arbitrary code execution IV vulnerability detect collafl within version target application unknown vulnerability vulnerability afl collafl default desc mem policy unknown vulnerability confirm cve ace arbitrary code execution unique crash addition code coverage another important factor fuzzers unique crash crash security vulnerability crash probability vulnerability identify reader aware fuzzers vulnerability crash due randomness fuzz previous evaluate collafl afl aflfast source application tracked unique crash fuzzers crash improvement previous collafl discover afl likely collafl unique crash unique crash directly report afl application fuzzers within application average crash fuzzers baseline ratio crash fuzzer collafl default selection policy outperforms afl aflfast unique crash propose selection policy collafl crash propose hash collision mitigation selection policy fuzzers crash crash growth appendix growth crash fuzzers source application within collafl outperforms afl aflfast almost application application collafl crash collafl outperforms aflfast application application  aflfast unique crash collafl surpass collision mitigation fuzzers crash moreover collafl growth momentum crash application  collafl desc collafl mem growth momentum crash summary propose policy fuzzers crash desc crash fuzzing identify vulnerability target application afl AddressSanitizer duplicate triage crash manually analyze remain crash confirm vulnerability average  fuzzers trial discovery crash finding VI deviation fuzzers trial bug finding specific vulnerability tracked trial shortest trial vulnerability vulnerability aforementioned evaluate collafl application IV detailed trial unique crash application identify vulnerability crash triage analysis triage crash filter vulnerability utilized source duplicate crash internally gdb plugin exploitable compute hash crash backtrace duplicate crash hash furthermore recompile target application AddressSanitizer  crash sample AddressSanitizer report crash remove duplicate finally manually analyze remain crash confirm unique vulnerability worth utilize AddressSanitizer triage crash collafl due performance overhead collafl execution potential vulnerability crash collafl AddressSanitizer future submit proof concept sample vulnerability upstream vendor vendor researcher fix release unknown remain vulnerability unknown vendor acknowledge cve appendix furthermore ace arbitrary code execution non ace vulnerability serious consequence vulnerability tcpdump clamav utilized dos attack disable victim defense trial afl vulnerability detect vulnerability collafl default mem desc selection policy vulnerability respectively vulnerability afl collafl policy afl vulnerability discovery randomness evaluation aforementioned fuzzers outperform others lose fuzzing evaluation reduce randomness random mutation algorithm fuzzers previous trial evaluate fuzzers code coverage crash finding vulnerability discovery randomness concern evaluate deviation fuzzers setup however resource requirement along evaluation conduct fuzzer setting application core core trial conduct multiple trial evaluate randomness usually trial instead conduct trial trial evaluate fuzzers application evaluate fuzzer setting application setting core core deviation discovery crash finding fuzzer target application sample discover trial compute relative standard deviation  trial sample finally compute arithmetic average  sample average  fuzzer trial application discovery vii average bug fuzzers trial parenthesis average bug respectively vii average bug fuzzers trial parenthesis average bug respectively fuzzers randomness discovery crash reasonable fuzzers  usually discovery crash finding application exi afl collafl  respectively discovery straightforward crash randomness finding crash trigger probability vulnerable explore moreover randomness fuzzers relatively improvement collafl collafl afl application  improvement ratio sum afl collafl  collafl outperform afl discovery collafl outperform afl crash discovery deviation vulnerability fuzzers deviation crash discovery similarly infer fuzzers deviation vulnerability crash due scarcity vulnerability sample previous compute  instead trial specific vulnerability trial vulnerability VI statistic collafl desc bug trial trial spends bug slowest spends target vulnerability collafl trial afl collafl bug trial afl trial moreover collafl target vulnerability faster afl collafl bug trial afl comparison fuzzers fuzzer setting collafl afl fuzzers evaluate effectiveness hash mitigation selection policy evaluate extra variation afl evaluate variation afl denote afl trace guard instrumentation clang coverage coverage adopt another instrumentation laf intel integer comparison operation split switch statement statement combine laf intel afl collafl respectively denote afl laf collafl laf vulnerability discovery vii average vulnerability fuzzers trial aforementioned trial evaluate fuzzing setting application lava dataset fuzzers vulnerability afl laf significantly outperforms afl afl collafl lava dataset underperforms application lava benchmark integer comparison hinder traditional fuzzers application collafl outperforms afl afl underperforms afl laf lava dataset focus comparison moreover collafl laf outperforms afl laf selection policy effective however collafl laf outperforms collafl lava underperforms application lava dataset specially craft VI conclusion negative impact coverage inaccuracy coverage fuzzers propose coverage sensitive fuzzing collafl resolve hash collision issue fuzzer afl enable accurate coverage information preserve instrumentation overhead accurate coverage information propose selection policy fuzzer directly towards non explore effective efficient discovery crash vulnerability discovery security bug application confirm cve acknowledgement  matthew  anonymous reviewer insightful comment colleague prof dong laboratory mathematical engineering advanced compute valuable comment suggestion research national foundation china grant elite scientist sponsorship program cast grant  award tsinghua information technology national laboratory appendix algorithm parameter  algorithm workflow  hash unsolvable multi precedent random unused hash unsolvable hash hashmap return unused hash hash algorithm  memory fuzzing fuzzers memory input afl per configuration bitmap memory GB memory fuzz unless target application runtime memory explore application explore application input afl per ent bitmap memory input afl per ent bitmap memory coverage improvement application pool discover coverage bitmap code coverage IX application explore fuzzers within evaluation conclusion collafl default selection policy outperforms afl aflfast discovery collafl propose selection policy coverage growth application aforementioned evaluate collafl application code coverage growth application lava dataset application application difference fuzzers afl fuzzer significant demonstrate lava dataset IX explore application recover counter coverage bitmap IX explore application recover counter coverage bitmap effectiveness collision mitigation code coverage collafl collafl faster afl afl respectively collision mitigation apply collafl effective collafl afl collafl aflfast unique crash application unique crash application code coverage collafl collafl desc faster setting untouched untouched descendant selection policy others collafl collafl desc collafl moreover fuzzers difference fuzzers distinct however difference increase rapidly collafl collafl desc outperform others trial fairly differentiate fuzzers due randomness fuzzing conduct crash growth application trial tracked crash fuzzers unique crash application collafl outperforms afl application outperforms aflfast application application collafl crash collafl outperforms aflfast application application  aflfast unique crash collafl surpass collision mitigation effective crash moreover collafl growth momentum crash application  collafl desc  growth momentum crash application exi  collafl mem growth momentum crash libtiff   policy sometimes discover unique crash others collafl desc unique crash  coverage growth lava dataset evaluate collafl lava dataset code coverage growth code coverage collafl collafl grows faster afl afl respectively prof collision mitigation collafl effective explore lava dataset explore lava dataset unique crash lava dataset unique crash lava dataset distribution unique crash lava dataset fuzzers distribution unique crash lava dataset fuzzers distribution bug lava dataset fuzzers distribution bug lava dataset fuzzers moreover code coverage collafl grows faster others application  selection policy effective collafl fuzzers discovery crash lava dataset trial tracked crash fuzzers demonstrates growth crash collafl outperforms others underperforms collafl desc sum distribution crash lava distribution unique crash lava dataset fuzzers demonstrates proportion crash fuzzer application application axis unique crash application demonstrates proportion crash fuzzer collafl collafl crash afl afl respectively hash collision mitigation improves fuzzer ability crash application collision collafl fuzzing untouched selection policy policy crash distribution vulnerability lava aforementioned automate analysis afl AddressSanitizer  crash  perform manual analysis confirm vulnerability distribution bug lava dataset fuzzers demonstrates distribution bug fuzzer application application axis unique bug application bug multiple fuzzers demonstrates overall capability fuzzers bug fuzzer collafl default desc mem selection policy vulnerability discover afl afl collafl collafl desc cve vulnerability collafl cve vulnerability collafl bug discover afl afl bug untouched untouched descendant selection policy others vulnerability detection cve vulnerability submit proof concept sample vulnerability upstream vendor vendor researcher fix release unknown remain vulnerability unknown vendor acknowledge cve detail cve vulnerability discussion accuracy information relies compiler information compute hash accordingly resolve conflict however challenge accurate graph static analysis guarantee resolve conflict compiler collafl suffers hash collision runtime overall collision ratio afl collision account collision ratio unknown afl extend binary program information accurate due challenge  analysis anticipate runtime hash collision increase however conservative analysis maybe  consideration ensure eliminate collision extend ensure collision ratio extend binary future  coverage sensitivity afl default bitmap coverage information performance  information ideally accurate worth another accurate information evaluate fuzzing anticipate slowdown fuzzing fuzzer context fuzzer hidden vulnerability challenge reduce runtime overhead explore direction future utilize security sanitizers currently apply sanitizers fuzzing crash specific signal report due performance consideration potential bug bug crash trigger buffer overflow trigger without tamper valuable data program crash future apply sanitizers   etc fuzzer evaluate effectiveness performance efficiency vulnerability discovery fuzzing setup fuzzing indeed important discover vulnerability widely adopt guideline application consist benchmark target application publicly available proof concept sample trigger vulnerability earlier version fuzzing library important driver fuzzers libfuzzer wrapper target entry function evaluation default driver program library libtiff library tiffpdf  fuzzed potential vulnerability backend libtiff library