We study the interaction of the programming construct “new,” which generates statically scoped names, with
communication via messages on channels. This interaction is crucial in security protocols, which are the main
motivating examples for our work; it also appears in other programming-language contexts.
We define the applied pi calculus, a simple, general extension of the pi calculus in which values can be
formed from names via the application of built-in functions, subject to equations, and be sent as messages. (In
contrast, the pure pi calculus lacks built-in functions; its only messages are atomic names.) We develop semantics and proof techniques for this extended language and apply them in reasoning about security protocols.
This article essentially subsumes the conference paper that introduced the applied pi calculus in 2001. It
fills gaps, incorporates improvements, and further explains and studies the applied pi calculus. Since 2001,
the applied pi calculus has been the basis for much further work, described in many research publications
and sometimes embodied in useful software, such as the tool ProVerif, which relies on the applied pi calculus
to support the specification and automatic analysis of security protocols. Although this article does not aim
to be a complete review of the subject, it benefits from that further work and provides better foundations for
some of it. In particular, the applied pi calculus has evolved through its implementation in ProVerif, and the
present definition reflects that evolution.
CCS Concepts: • Security and privacy → Formal methods and theory of security; • Theory of
computation → Process calculi;
Additional Key Words and Phrases: Security protocols
1 A CASE FOR IMPURITY
Purity often comes before convenience and even before faithfulness in the lambda calculus, the pi
calculus, and other foundational programming languages. For example, in the standard pi calculus,
the only messages are atomic names (Milner 1999). This simplicity is extremely appealing from
a foundational viewpoint, and helps in developing the theory of the pi calculus. Furthermore,
ingenious encodings demonstrate that it may not entail a loss of generality. In particular, integers,
objects, and even higher-order processes can be represented in the pure pi calculus. Similarly,
various encodings of cryptographic operations in the pi calculus have been considered (Abadi and
Gordon 1999; Baldamus et al. 2004; Carbone and Maffeis 2003; Martinho and Ravara 2011).
On the other hand, this purity has a price. In applications, the encodings can be futile, cumbersome, and even misleading. For instance, in the study of programming languages based on the pi
calculus (such as Pict (Pierce and Turner 2000), JoCaml (Conchon and Fessant 1999), or occampi (Welch and Barnes 2005)), there is little point in pretending that integers are not primitive. The
encodings may also hinder careful reasoning about communication (e.g., because they require extra messages), and they may complicate static analysis and proofs.
These difficulties are often circumvented through on-the-fly extensions. The extensions range
from quick punts (“for the next example, let’s pretend that we have a data type of integers”) to
the laborious development of new calculi, such as the spi calculus (Abadi and Gordon 1999) (a
calculus with cryptographic operations) and its variants. Generally, the extensions bring us closer
to a realistic programming language or modeling language—that is not always a bad thing.
Although many of the resulting calculi are ad hoc and poorly understood, others are robust and
uniform enough to have a rich theory and a variety of applications. In particular, impure extensions
of the lambda calculus with function symbols and with equations among terms (“delta rules”) have
been developed systematically, with considerable success. Similarly, impure versions of CCS and
CSP with value passing are not always deep but often neat and convenient (Milner 1989).
In this article, we introduce, study, and use an analogous uniform extension of the pi calculus,
which we call the applied pi calculus (by analogy with “applied lambda calculus”). From the pure
pi calculus, we inherit constructs for communication and concurrency, and for generating statically scoped new names (“new”). We add functions and equations, much as is done in the lambda
calculus. Messages may then consist not only of atomic names but also of values constructed from
names and functions. This embedding of names into the space of values gives rise to an important interaction between the “new” construct and value-passing communication, which appears
in neither the pure pi calculus nor value-passing CCS and CSP. Further, we add an auxiliary substitution construct, roughly similar to a floating “let”; this construct is helpful in programming
examples and especially in semantics and proofs, and serves to capture the partial knowledge that
an environment may have of some values.
The applied pi calculus builds on the pure pi calculus and its substantial theory, but it shifts the
focus away from encodings. In comparison with ad hoc approaches, it permits a general, systematic
development of syntax, operational semantics, equivalences, and proof techniques.
Using the calculus, we can write and reason about programming examples where “new” and
value passing appear. First, we can easily treat standard data types (integers, pairs, arrays, etc.). We
can also model unforgeable capabilities as new names, then model the application of certain functions to those capabilities. For instance, we may construct a pair of capabilities. More delicately,
the capabilities may be pointers to composite structures, and then adding an offset to a pointer to a
pair may yield a pointer to its second component (e.g., as in Liblit and Aiken (2000)). Furthermore,
we can study a variety of security protocols. For this purpose, we represent fresh channels, nonces,
and keys as new names, and primitive cryptographic operations as functions, obtaining a simple
but useful programming-language perspective on security protocols (much as in the spi calculus).
A distinguishing characteristic of the present approach is that we need not craft a special calculus
and develop its proof techniques for each choice of cryptographic operations. Thus, we can express
and analyze fairly sophisticated protocols that combine several cryptographic primitives (encryptions, hashes, signatures, XORs, etc.). We can also describe attacks against the protocols that rely
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:3
on (equational) properties of some of those primitives. In our work to date, security protocols are
our main source of examples.
The next section defines the applied pi calculus. Section 3 introduces some small, informal examples. Section 4 defines semantic concepts, such as process equivalence, and develops proof techniques. Sections 5 and 6 treat larger, instructive examples; they concern a Diffie-Hellman key exchange, cryptographic hash functions, and message authentication codes. (The two sections are
independent.) Many other examples now appear in the literature, as explained below. Section 7
discusses related work, and Section 8 concludes. The body of the article contains some proofs and
outlines others; many details of the proofs, however, are in appendices.
This article essentially subsumes the conference paper that introduced the applied pi calculus in
2001. It fills gaps, incorporates various improvements, and further explains and studies the applied
pi calculus. Specifically, it presents a revised language, with a revised semantics, as explained in
Sections 2 and 4. It also includes precise definitions and proofs; these address gaps in the conference
paper, discussed in further detail in Section 4. Finally, some of the examples in Sections 3, 5, and
especially 6 are polished or entirely new.
Since 2001, the applied pi calculus has been the basis for much further work, described in many
research publications (some of which are cited below) and tutorials (Abadi 2007; Cortier and
Kremer 2014; Ryan and Smyth 2011). This further work includes semantics, proof techniques, and
applications in diverse contexts (key exchange, electronic voting, certified email, cryptographic
file systems, encrypted web storage, website authorization, zero-knowledge proofs, and more).
It is sometimes embodied in useful software, such as the tool ProVerif (Blanchet 2001, 2004,
2016; Blanchet et al. 2008). This tool, which supports the specification and automatic analysis of
security protocols, relies on the applied pi calculus as input language. Other software that builds
on ProVerif targets protocol implementations, web security mechanisms, or stateful systems such
as hardware devices (Arapinis et al. 2011; Bansal et al. 2012; Bhargavan et al. 2008b). Finally,
the applied pi calculus has also been implemented in other settings, such as the prover Tamarin
(Kremer and Künnemann 2014; Meier et al. 2013).
Although this article does not aim to offer a complete review of the subject and its growth
since 2001, it benefits from that further work and provides better foundations for some of it. In
particular, the applied pi calculus has evolved through its implementation in ProVerif, and the
present definition reflects that evolution.
2 THE APPLIED PI CALCULUS
In this section, we define the applied pi calculus: its syntax and informal semantics (Section 2.1),
then its operational semantics (Section 2.2). We also discuss a few variants and extensions of our
definitions (Section 2.3).
2.1 Syntax and Informal Semantics
A signature Σ consists of a finite set of function symbols, such as f, encrypt, and pair, each with
an arity. A function symbol with arity 0 is a constant symbol.
Given a signature Σ, an infinite set of names, and an infinite set of variables, the set of terms is
defined by the grammar:
L, M, N,T,U,V ::= terms
a,b,c,..., k,...,m,n,...,s name
x,y, z variable
f (M1,..., Ml ) function application,
where f ranges over the functions of Σ and l matches the arity of f .
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.
1:4 M. Abadi et al.
Although names, variables, and constant symbols have similarities, we find it clearer to keep
them separate. A term is ground when it does not contain variables (but it may contain names
and constant symbols). We use metavariables u,v,w to range over both names and variables. We
abbreviate tuples u1,...,ul and M1,..., Ml to uand M, respectively.
The grammar for processes is similar to the one in the pi calculus, but here messages can contain
terms (rather than only names) and names need not be just channel names:
P,Q, R ::= processes (or plain processes)
0 null process
P | Q parallel composition
!P replication
νn.P name restriction (“new”)
if M = N then P else Q conditional
N (x).P message input
NM.P message output
The null process 0 does nothing; P | Q is the parallel composition of P and Q; the replication
!P behaves as an infinite number of copies of P running in parallel. The process νn.P makes a
new, private name n and then behaves as P. The conditional construct if M = N then P else Q is
standard, but we should stress that M = N represents equality, rather than strict syntactic identity.
We abbreviate it if M = N then P when Q is 0. Finally, N (x).P is ready to input from channel N,
then to run P with the actual message replaced for the formal parameter x, while NM.P is ready
to output M on channel N, then to run P. In both of these, we may omit P when it is 0.
Further, we extend processes with active substitutions:
A, B,C ::= extended processes
P plain process
A | B parallel composition
νn.A name restriction
νx.A variable restriction
{M/x } active substitution
We write {M/x } for the substitution that replaces the variable x with the term M. Considered as a
process, {M/x } is like let x = M in ..., and is similarly useful. However, unlike a “let” definition,
{M/x } floats and applies to any process that comes into contact with it. To control this contact,
we may add a restriction: νx.({M/x } | P) corresponds exactly to let x = M in P. The substitution
{M/x } typically appears when the term M has been sent to the environment, but the environment
may not have the atomic names that appear in M; the variable x is just a way to refer to M in
this situation. Although the substitution {M/x } concerns only one variable, we can build bigger
substitutions by parallel composition, and may write
{
M1
/x1 ,...,Ml /xl } for {
M1
/x1 } | ... | {Ml
/xl }.
We write σ, {M/x }, {M
/x} for substitutions; xσ for the image of x by σ; and T σ for the result of
applying σ to the free variables of T . We identify the empty substitution and the null process 0.
As usual, names and variables have scopes, which are delimited by restrictions and by inputs.
We write fv(A) and fn(A) for the sets of free variables and free names of A, respectively. These
sets are inductively defined, as detailed in Figure 1. The domain dom(A) of an extended process A
is the set of variables that A exports (those variables x for which A contains a substitution {M/x }
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.        
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:5
Fig. 1. Free variables, free names, and domain.
not under a restriction on x). Figure 1 also defines dom(A) formally. We consider that expressions
(processes and extended processes) are equal modulo renaming of bound names and variables.
We always assume that our substitutions are cycle-free; that is, by reordering, they can be written {M1
/x1 ,...,Ml /xl }, where xi  fv(Mj) for all i ≤ j ≤ l. For instance, we exclude substitutions
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017. 
1:6 M. Abadi et al.
Fig. 2. Sort system.
such as {
f (y)
/x ,
f (x )
/y }. We also assume that, in an extended process, there is at most one substitution for each variable, and there is exactly one when the variable is restricted, that is,
dom(A) ∩ dom(B) = ∅ in every extended process A | B, and x ∈ dom(A) in every extended process νx.A. An extended process A is closed when its free variables are all defined by an active
substitution, that is, dom(A) = fv(A). We use the abbreviation νufor the (possibly empty) series of
pairwise distinct restrictions νu1.νu2.... νul .
A frame is an extended process built up from 0 and active substitutions of the form {M/x } by
parallel composition and restriction. We let φ and ψ range over frames. Every extended process A
can be mapped to a frame φ(A) by replacing every plain process embedded in A with 0. The frame
φ(A) can be viewed as an approximation of A that accounts for the static knowledge exposed
by A to its environment, but not for A’s dynamic behavior. Assuming that all bound names and
variables are pairwise distinct and do not clash with free ones, one can ignore all restrictions in a
frame, thus obtaining an underlying substitution; we require that, for each extended process, this
resulting substitution be cycle-free.
We rely on a sort system for terms and processes. It includes a sort Channel for channels. It may
also include other sorts such as Integer, Key, or simply a universal sort for data Data. Each variable
and each name comes with a sort; we write u : τ to mean that u has sort τ . There are an infinite
number of variables and an infinite number of names of each sort. We typically use a, b, and c as
names of sort Channel; s and k as names of some other sort (e.g., Data); and m and n as names
of any sort. Function symbols also come with the sorts of their arguments and of their result. We
write f : τ1 ×···× τl → τ to mean that f has arguments of sorts τ1,..., τl and a result of sort τ .
Figure 2 gives the rules of the sort system. It defines the following judgments: 	 M : τ means that
M is a term of sort τ ; 	 P means that the process P is well sorted; 	 A means that the extended
process A is well sorted. This sort system enforces that function applications are well sorted, that
M and N are of the same sort in conditional expressions, that N has sort Channel in input and
output expressions, that M is well sorted (with an arbitrary sort τ ) in output expressions, and that
active substitutions preserve sorts. We always assume that expressions are well sorted, and that
substitutions preserve sorts.
2.2 Operational Semantics
We give an operational semantics for the applied pi calculus in the now customary “chemical
style” (Berry and Boudol 1992; Milner 1992). At the center of this operational semantics is a
reduction relation → on extended processes, which basically models the steps of computations.
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017. 
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:7
For example, aM | a(x).bx → bM represents the transmission of the message M on the channel a to a process that will forward the message on the channel b; the formal x is replaced with its
actual value M in this reduction. The axioms for the reduction relation →, which are remarkably
simple, rely on auxiliary rules for a structural equivalence relation ≡ that permits the rearrangement of processes, for example, the use of commutativity and associativity of parallel composition.
Furthermore, both structural equivalence and reduction depend on an underlying equational theory. Therefore, this section introduces equational theories, then defines structural equivalence and
reduction.
Given a signature Σ, we equip it with an equational theory, that is, with a congruence relation
on terms that is closed under substitution of terms for variables and names. (See, e.g., Mitchell’s
textbook (Mitchell 1996, Chapter 3) and its references for background on universal algebra and algebraic data types from a programming-language perspective.) We further require that this equational theory respect the sort system (i.e., two equal terms are of the same sort) and that it be
nontrivial (i.e., there exist two different terms in each sort).
An equational theory may be generated from a finite set of equational axioms or from rewrite
rules, but this property is not essential for us. We tend to ignore the mechanics of specifying
equational theories, but give several examples in Section 3.
We write Σ 	 M = N when the equation M = N is in the theory associated with Σ. Here we
keep the theory implicit, and we may even abbreviate Σ 	 M = N to M = N when Σ is clear from
context or unimportant. We write Σ  M = N for the negation of Σ 	 M = N.
As usual, a context is an expression with a hole. An evaluation context is a context whose hole
is not under a replication, a conditional, an input, or an output. A context E[_] closes A when E[A]
is closed.
Structural equivalence ≡ is the smallest equivalence relation on extended processes that is closed
by application of evaluation contexts, and such that:
Par-0 A ≡ A | 0
Par-A A | (B | C) ≡ (A | B) | C
Par-C A | B ≡ B | A
Repl !P ≡ P | !P
New-0 νn.0 ≡ 0
New-C νu.νv.A ≡ νv.νu.A
New-Par A | νu.B ≡ νu.(A | B) when u  fv(A) ∪ fn(A)
Alias νx.{M/x } ≡ 0
Subst {M/x } | A ≡ {M/x } | A{M/x }
Rewrite {M/x }≡{N/x } when Σ 	 M = N
The rules for parallel composition and restriction are standard. Alias enables the introduction
of an arbitrary active substitution. Subst describes the application of an active substitution to
a process that is in contact with it. Rewrite deals with equational rewriting. Subst implicitly
requires that x : τ and 	 M : τ for some sort τ . In combination, Alias and Subst yield A{M/x } ≡
νx.({M/x } | A) for x  fv(M):
A{M/x } ≡ A{M/x } | 0 by Par-0
≡ A{M/x } | νx.{M/x } by Alias
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.         
1:8 M. Abadi et al.
≡ νx.(A{M/x }|{M/x }) by New-Par
≡ νx.({M/x } | A{M/x }) by Par-C
≡ νx.({M/x } | A) by Subst
Using structural equivalence, every closed extended process A can be rewritten to consist of a
substitution and a closed plain process with some restricted names:
A ≡ νn.({
M
/x} | P),
where fv(P) = ∅, fv(M) = ∅, and {n} ⊆ fn(M). In particular, every closed frame φ can be rewritten
to consist of a substitution with some restricted names:
φ ≡ νn.{
M
/x},
where fv(M) = ∅ and {n} ⊆ fn(M). The set {x} is the domain of φ.
Internal reduction → is the smallest relation on extended processes closed by structural equivalence and application of evaluation contexts such that
Comm Nx.P | N (x).Q → P | Q
Then if M = M then P else Q → P
Else if M = N then P else Q → Q
for any ground terms M and N such that Σ  M = N.
Communication (Comm) is remarkably simple because the message concerned is a variable; this
simplicity entails no loss of generality because Alias and Subst can introduce a variable to stand
for a term:
NM.P | N (x).Q ≡ νx.({
M/x } | Nx.P | N (x).Q)
→ νx.({
M/x } | P | Q) by Comm
≡ P | Q{
M/x }.
(This derivation assumes that x  fv(N) ∪ fv(M) ∪ fv(P), which can be established by renaming
as needed.)
Comparisons (Then and Else) directly depend on the underlying equational theory. Using Else
sometimes requires that active substitutions in the context be applied first, to yield ground terms
M and N. For example, rule Else does not allow us to reduce {
n
/x } | if x = n then P else Q.
This use of the equational theory may be reminiscent of initial algebras. In an initial algebra,
the principle of “no confusion” dictates that two elements are equal only if this is required by
the corresponding equational theory. Similarly, if M = N then P else Q reduces to P only if this
is required by the equational theory, and reduces to Q otherwise. Initial algebras also obey the
principle of “no junk,” which says that all elements correspond to terms built exclusively from
function symbols of the signature. In contrast, a fresh name need not equal any such term in the
applied pi calculus.
2.3 Variants and Extensions
Several variants of the syntax of the applied pi calculus appear in the literature, and further variants
may be considered. We discuss a few:
• In the conference paper, there are several sorts for channels: the sort Channelτ  is the sort
of channels that convey messages of sort τ . The sort Channel without argument is more
general, in the sense that all processes well sorted with Channelτ  are also well sorted with
Channel. Having a single sort for channels simplifies some models, for instance, when all
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.                         
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:9
public messages are sent on the same channel, even if they have different types. Moreover,
by using Channel as only sort, we can encode an untyped version of the applied pi calculus.
The tool ProVerif also uses the sort Channel without argument.
• In a more refined version of the sort system, we could allow names only in a distinguished
set of sorts. For instance, we could consider a sort of Booleans, containing as only values the
constants true and false. Such a sort would not contain names. Sorts without names would
have to be treated with special care in proofs, since our proofs often use fresh names.
On the other hand, letting all sorts contain names does not prevent modeling Booleans by
a sort. For example, we can treat as false all terms of the sort different from true, including
not only the constant false but also all names. Analogous treatments apply to other common
data types.
• In the conference paper, channels in inputs and outputs are names or variables rather than
any term. Allowing any term as channel yields a more general calculus and avoids some
side conditions in theorems. It is also useful for some encodings (Abadi and Blanchet 2005b).
Finally, it is in line with the syntax of ProVerif, where this design choice was adopted in order
to simplify the untyped version of the calculus.
Nevertheless, the sort system can restrict the terms that appear as channels: if no function
symbol returns a result of sort Channel, then channels can be only names or variables.
• Function symbols can also be defined by rewrite rules instead of an equational theory. This
approach is taken in ProVerif (Blanchet 2009): a destructor д is a partial function defined by
rewrite rules д(M1,..., Ml ) → M; the destructor application д(N1,..., Nl ) fails when no
rewrite rule applies, and this failure can be tested in the process calculus.
A destructorд : τ1 ×···× τl → τ with rewrite ruleд(M1,..., Ml ) → M can be encoded in
the applied pi calculus by function symbols д : τ1 ×···× τl → τ and testд : τ1 ×···× τl →
bool with the equations
д(M1,..., Ml ) = M
testд (M1,..., Ml ) = true.
The function testд allows one to test whether д(N1,..., Nl ) is defined, by checking whether
testд (N1,..., Nl ) = true holds. (See Section 3 for examples of such test functions.) The functionд may be applied even when its arguments are not instances of (M1,..., Ml ), thus yielding terms д(N1,..., Nl ) that do not exist in the calculus with rewrite rules. These “stuck”
terms may be simulated with distinct fresh names in that variant of the calculus.
Destructors are easy to implement in a tool. They also provide a built-in error-handling
construct: the error handling is triggered when no rewrite rule applies. However, they complicate the semantics because they require a notion of evaluation of terms. Moreover, many
useful functions can be defined by equations but not as destructors (for instance, encryption without redundancy, XOR, and modular exponentiation, which we use in the rest of
this article). Therefore, ProVerif supports both destructors and equations (Blanchet et al.
2008). Thus, the language of ProVerif is a superset of the applied pi calculus as defined in
this article (Blanchet 2016, Chapter 4), with the caveat that ProVerif does not support all
equational theories and that it considers only plain processes.
• An extension that combines the applied pi calculus with ambients and with a built-in construct for evaluating messages as programs has also been studied (Blanchet and Aziz 2003).
This extended calculus mixes many notions, so the corresponding proofs are complex. Considering a single notion at a time yields a simpler and more elegant calculus. Furthermore,
although the applied pi calculus has few primitives, it supports various other constructs via
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.
1:10 M. Abadi et al.
encodings; in particular, the message evaluation construct could be represented by defining
an interpreter in the calculus.
• Our equational theories are closed under substitution of terms for names. This property
yields a simple and uniform treatment of variables and names. An alternative definition,
which may suffice, assumes only that equational theories are closed under one-to-one renaming and do not equate names. That definition makes it possible to define a function that
tests whether a term is a name.
Some other variations concern the definition of the semantics:
• As in other papers (Blanchet et al. 2008; Liu 2011), we can handle the replication by a reduction step !P → P | !P instead of the structural equivalence rule !P ≡ P | !P. This modification
prevents transforming P | !P into !P, and thus simplifies some proofs.
• As Section 2.2 indicates, we can rewrite extended processes by pulling restrictions to the
top, so that every closed extended process A becomes an extended process A◦ such that
A ≡ A◦ = νn.({
M
/x} | P1 | ... | Pl ),
where fv(P1 | ... | Pl ) = ∅, fv(M) = ∅, and P1,..., Pl are replication, conditional, input, or
output expressions. We can then modify the definitions of structural equivalence and internal reduction to act on processes in the form above. Structural equivalence says that the
parallel composition P1 | ... | Pl is associative and commutative and that the names in n
can be reordered. Internal reduction is the smallest relation on closed extended processes,
closed by structural equivalence, such that
E[NM.P | N 
(x).Q] → E[P | Q{M/x }]
◦ if Σ 	 N = N 
E[if M = N then P else Q] → E[P]
◦ if Σ 	 M = N
E[if M = N then P else Q] → E[Q]
◦ if Σ  M = N
E[!P] → E[P | !P]
◦
for any evaluation context E. A similar idea appears in the intermediate applied pi calculus
of Delaune et al. (2010) and Liu et al. (2011, 2012). There, all restrictions not under replication are pulled to the top of processes, over conditionals, inputs, outputs, and parallel
compositions; the processes P1,..., Pl may be 0; and channels are names or variables.
• Pushing the previous idea further, we can represent the extended process
A ≡ νn.({
M
/x} | P1 | ... | Pl )
as a configuration (N, σ, P) = ({n}, {M
/x}, {P1,..., Pl}), where N is a set of names, σ is a
substitution, and P is a multiset of processes. We can then define internal reduction on such
configurations, without any structural equivalence. (Sets and multisets allow us to ignore
the ordering of restrictions and parallel processes.) This idea is used in semantics of the
calculus of ProVerif (Abadi and Blanchet 2005b; Allamigeon and Blanchet 2005; Blanchet
2009, 2016).
Semantics based on global configurations are closer to abstract machines. Such semantics simplify
proofs, because they leave only few choices in reductions. They also make it easier to define further
extensions of the calculus, such as tables and phases in ProVerif (Blanchet 2016). However, our
compositional semantics is more convenient in order to model interactions between a process and
a context. It is also closer to the traditional semantics of the pi calculus. The two kinds of semantics
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.              
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:11
are of course connected. In particular, Blanchet (2016, Chapter 4) formally relates the semantics of
ProVerif based on configurations to our semantics.
3 BRIEF EXAMPLES
This section collects several examples, focusing on signatures, equations, and some simple processes. We start with pairs; this trivial example serves to introduce some notations and issues.
We then discuss lists, cryptographic hash functions, encryption functions, digital signatures, and
the XOR function (Menezes et al. 1996; Schneier 1996), as well as a form of multiplexing, which
demonstrates the use of channels that are terms rather than names. Further examples appear in
Sections 5 and 6. More examples, such as blind signatures (Kremer and Ryan 2005) and zeroknowledge proofs (Backes et al. 2008), have appeared in the literature since 2001.
Of course, at least some of these functions appear in most formalizations of cryptography and
security protocols. In comparison with the spi calculus, the applied pi calculus permits a more
uniform and versatile treatment of these functions, their variants, and their properties. Like the spi
calculus, however, the applied pi calculus takes advantage of notations, concepts, and techniques
from programming languages.
Pairs. Algebraic data types such as pairs, tuples, arrays, and lists occur in many examples. Encoding them in the pure pi calculus is not hard, but neither is representing them as primitive. For
instance, the signature Σ may contain the binary function symbol pair and the unary function
symbols fst and snd, with the abbreviation (M, N) for pair(M, N), and with the evident equations:
fst((x,y)) = x (1)
snd((x,y)) = y. (2)
(So the equational theory consists of these equations, and all the equations obtained by reflexivity,
symmetry, transitivity, applications of function symbols, and substitutions of terms for variables.)
These function symbols may, for instance, be sorted as follows:
pair : Data × Data → Data
fst : Data → Data
snd : Data → Data
We may use the test (fst(M),snd(M)) = M to check that M is a pair before using the values of
fst(M) and snd(M). Alternatively, we may add a Boolean function is_pair that recognizes pairs,
defined by the equation
is_pair((x,y)) = true.
With this equation, the conditional if is_pair(M) = true then P else Q runs P if M is a pair and Q
otherwise. Using pairs, we may, for instance, define the process:
νs.

a(M,s) | a(z).if snd(z) = s then bfst(z)

.
One of its components sends a pair consisting of a term M and a fresh name s on a channel a.
The other receives a message on a and, if its second component iss, forwards the first component
on a channel b. Thus, we may say that s serves as a capability (or password) for the forwarding.
However, this capability is not protected from eavesdroppers when it travels on a. Any other
process can listen on a and can apply snd to the message received, thus learning s. We can represent
such an attacker within the calculus, for example, by the following process:
a(z).a(N,snd(z)),
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.        
1:12 M. Abadi et al.
which may receive (M,s) on a and send (N,s) on a. Composing this attacker in parallel with the
process, we may obtain N instead of M on b.
Such attacks can be thwarted by the use of restricted channel names, as in the process
νa.νs.

a(M,s) | a(z).if snd(z) = s then bfst(z)

.
Alternatively, they can be thwarted by the use of cryptography, as discussed below.
Lists. We may treat lists similarly, with the following function symbols and corresponding sorts:
nil : List
cons : Data × List → List
hd : List → Data
tl : List → List
The constant nil is the empty list; cons(x,y) represents the concatenation of the element x at the
beginning of the list y, and we write it with infix notation as x :: y, where the symbol :: associates
to the right, and hd and tl are head and tail functions with the equations
hd(x :: y) = x tl(x :: y) = y. (3)
Further, we write M ++ N for the concatenation of an element N at the end of a list M, where the
function ++ : List × Data → List associates to the left, and satisfies the equations
nil ++ x = x :: nil (x :: y) ++ z = x :: (y ++ z). (4)
Cryptographic Hash Functions. We represent a cryptographic hash function as a unary function
symbol h with no equations. The absence of an inverse for h models the one-wayness of h. The
fact that h(M) = h(N) only when M = N models that h is collision-free.
Modifying our first example, we may now write the process:
νs.

a(M, h((s, M))) | a(x).if h((s, fst(x))) = snd(x) then bfst(x)

.
Here the value M is authenticated by pairing it with the fresh name s and then hashing the pair.
Although (M, h((s, M))) travels on the public channel a, no other process can extract s from this
message or produce (N, h((s, N))) for some other N using the available functions. Therefore, we
may reason that this process will forward only the intended term M on channel b.
This example is a typical cryptographic application of hash functions. In light of the practical
importance of those applications, our treatment of hash functions is attractively straightforward.
Still, we may question whether our formal model of these functions is not too strong and simplistic
in comparison with the properties of actual implementations based on algorithms such as SHA. In
Section 6, we consider a somewhat weaker, subtler model for hash functions.
Symmetric Encryption. In order to model symmetric cryptography (i.e., shared-key cryptography), we take binary function symbols enc and dec for encryption and decryption, respectively,
with the equation
dec(enc(x,y),y) = x.
Here x represents the plaintext and y the key. We often use fresh names as keys in examples; for
instance, the (useless) process
νk.aenc(M, k)
sends the term M encrypted under a fresh key k.
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.              
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:13
In applications of encryption, it is frequent to assume that each encrypted message comes with
sufficient redundancy so that decryption with the “wrong” key is evident. Accordingly, we can test
whether the decryption of M with the key k succeeds by testing whether enc(dec(M, k), k) = M.
Alternatively, we could also add a test function testdec with the equation
testdec (enc(x,y),y) = true.
Provided that we check that decryption succeeds before using the decrypted message, this model
of encryption basically yields the spi calculus (Abadi and Gordon 1999).
On the other hand, in modern cryptology, such redundancy is not usually viewed as part of
the encryption function proper, but rather an addition. The redundancy can be implemented with
message authentication codes. We can model an encryption scheme without redundancy with the
following two equations:
dec(enc(x,y),y) = x
enc(dec(z,y),y) = z.
These equations model that decryption is the inverse bijection of encryption, a property that is
typically satisfied by block ciphers.
Asymmetric Encryption. It is only slightly harder to model asymmetric (public-key) cryptography, where the keys for encryption and decryption are different. We introduce two new unary
function symbols pk and sk for generating public and private keys from a seed, and the equation
dec(enc(x, pk(y)),sk(y)) = x.
We may now write the process
νs.

apk(s) | b(x).cdec(x,sk(s))

.
The first component publishes the public key pk(s) by sending it on a. The second receives a
message on b, uses the corresponding private key sk(s) to decrypt it, and forwards the resulting
plaintext on c. As this example indicates, we essentially view name restriction (νs) as a generator
of unguessable seeds. In some cases, those seeds may be directly used as passwords or keys; in
others, some transformations are needed.
Some encryption schemes have additional properties. In particular, enc and dec may be the
same function. This property matters in implementations, and sometimes permits attacks. Moreover, certain encryptions and decryptions commute in some schemes. For example, we have
dec(enc(x,y), z) = enc(dec(x, z),y) if the encryptions and decryptions are performed using RSA
with the same modulus. The treatment of such properties is left open in the spi calculus (Abadi
and Gordon 1999). In contrast, it is easy to express the properties in the applied pi calculus and to
study the protocols and attacks that depend on them.
Nondeterministic (“Probabilistic”) Encryption. Going further, we may add a third argument to enc,
so that the encryption of a plaintext with a key is not unique. This nondeterminism is an essential
property of probabilistic encryption (Goldwasser and Micali 1984). The equation for decryption
becomes
dec(enc(x, pk(y), z),sk(y)) = x.
With this variant, we may write the process
a(x).

νm.benc(M, x,m) | νn.cenc(N, x,n)

,
which receives a message x and uses it as an encryption key for two messages, enc(M, x,m) and
enc(N, x,n). An observer who does not have the corresponding decryption key cannot tell whether
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.            
1:14 M. Abadi et al.
the underlying plaintexts M and N are identical by comparing the ciphertexts, because the ciphertexts rely on different fresh namesm and n. Moreover, even if the observer learns x, M, and N (but
not the decryption key), it cannot verify that the messages contain M and N because it does not
know m and n.
Public-Key Digital Signatures. Like public-key encryption schemes, digital signature schemes
rely on pairs of public and private keys. In each pair, the private key serves for computing signatures and the public key for verifying those signatures. In order to model key generation, we use
again the two unary function symbols pk and sk for generating public and private keys from a
seed. For signatures and their verification, we use a new binary function symbol sign, a ternary
function symbol check, and a constant symbol ok, with the equation
check(x,sign(x,sk(y)), pk(y)) = ok.
(Several variants are possible.)
Modifying once more our first example, we may now write the process

νs.{
pk(s )
/y } | a(M,sign(M,sk(s)))

|
a(x).if check(fst(x),snd(x),y) = ok then bfst(x).
Here the value M is signed using the private key sk(s). Although M and its signature travel on the
public channel a, no other process can produce N and its signature for some other N. Therefore,
again, we may reason that only the intended term M will be forwarded on channel b. This property
holds despite the publication of pk(s) (but notsk(s)), which is represented by the active substitution
that maps y to pk(s). Despite the restriction on s, processes outside the restriction can use pk(s)
through y. In particular, y refers to pk(s) in the process that checks the signature on M.
XOR. We may model the XOR function, some of its uses in cryptography, and some of the protocol flaws connected with it. Some of these flaws (e.g., Ryan and Schneider (1998)) stem from
the intrinsic equational properties of XOR, such as associativity, commutativity, the existence of a
neutral element, and the cancellation property that we may write as follows:
xor(xor(x,y), z) = xor(x, xor(y, z))
xor(x,y) = xor(y, x)
xor(x, 0) = x
xor(x, x) = 0.
Others arise because of the interactions between XOR and other operations (e.g., Core SDI S.A.
(1998); Stubblebine and Gligor (1992)). For example, CRCs (cyclic redundancy checks) can be poor
proofs of integrity, partly because of the equation
crc(xor(x,y)) = xor(crc(x), crc(y)).
Multiplexing. Finally, we illustrate a possible usage of channels that are not names. Consider, for
instance, a pairing function for building channels pair : Data × Port → Channel with its associated
projections fst : Channel → Data and snd : Channel → Port, and Equations (1) and (2) from our
first example. We may use this function for multiplexing as follows:
νs.(pair(s, port1)M1 | pair(s, port2)M2
| pair(s, port1)(x1) | pair(s, port2)(x2)).
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.          
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:15
In this process, the first output can be received only by the first input, and the second output can
be received only by the second input.
4 EQUIVALENCES AND PROOF TECHNIQUES
In examples, we frequently argue that two given processes cannot be distinguished by any context, that is, that the processes are observationally equivalent. The spi calculus developed the idea
that the context represents an active attacker, and equivalences capture authenticity and secrecy
properties in the presence of the attacker. More broadly, a wide variety of security properties can
be expressed as equivalences.
In this section, we define observational equivalence for the applied pi calculus. We also introduce a notion of static equivalence for frames, a labeled semantics for processes, and a labeled
equivalence relation. We prove that labeled equivalence and observational equivalence coincide,
obtaining a convenient proof technique for observational equivalence.
4.1 Observational Equivalence
We write A ⇓a when A can send a message on name a, that is, when A →∗≡ E[aM.P] for some
evaluation context E[_] that does not bind a.
Definition 4.1. An observational bisimulation is a symmetric relation R between closed extended
processes with the same domain such that A R B implies:
(1) if A ⇓a, then B ⇓a;
(2) if A →∗ A and A is closed, then B →∗ B and A R B for some B
;
(3) E[A] R E[B] for all closing evaluation contexts E[_].
Observational equivalence (≈) is the largest such relation.
For example, when h is a unary function symbol with no equations, we obtain that νs.as ≈
νs.ah(s).
These definitions are standard in the pi calculus, where ⇓a is called a barb on a, and where ≈ is
one of the two usual notions of weak barbed bisimulation congruence. (See Section 4.5 and Fournet
and Gonthier (1998) for a detailed discussion.) In the applied pi calculus, one could also define barbs
on arbitrary terms, not just on names; we do not need that generalization for our purposes. The
set of closing evaluation contexts for A depends only on A’s domain; hence, in Definition 4.1, A
and B have the same closing evaluation contexts. In Definition 4.1(2), since R is a relation between
closed extended processes, we require that A also be closed. Being closed is not preserved by
all reductions, since structural equivalence may introduce free unused variables. For instance, we
have 0 ≡ νx.{
y
/x } by Alias and {M/x }≡{fst((M,y))/x } by Rewrite using the equation fst((x,y)) = x.
Although observational equivalence is undecidable in general, various tools support certain
automatic proofs of observational equivalence and other equivalence relations, in the applied pi
calculus and related languages (e.g., Baudet (2005), Blanchet et al. (2008), Chadha et al. (2012), and
Cheval et al. (2013)).
4.2 Static Equivalence
Two substitutions may be seen as equivalent when they behave equivalently when applied to
terms. We write ≈s for this notion of equivalence and call it static equivalence. In the presence of
the “new” construct, defining ≈s is somewhat delicate and interesting. For instance, consider two
functions f and g with no equations (intuitively, two independent hash functions), and the three
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.      
1:16 M. Abadi et al.
frames
φ0
def
= νk.{
k
/x } | νs.{
s
/y }
φ1
def
= νk.{
f(k)
/x ,
g(k)
/y }
φ2
def
= νk.{
k
/x ,
f(k)
/y }.
In φ0, the variables x and y are mapped to two unrelated values that are different from any value
that the context may build (since k and s are new). These properties also hold, but more subtly,
for φ1; although f(k) and g(k) are based on the same underlying fresh name, they look unrelated.
(Analogously, it is common to derive apparently unrelated keys by hashing from a single underlying secret, as in SSL and TLS (Dierks and Rescorla 2008; Freier et al. 1996).) Hence, a context
that obtains the values for x and y cannot distinguish φ0 and φ1. On the other hand, the context
can discriminate φ2 by testing the predicate f(x) = y. Therefore, we would like to define static
equivalence so that φ0 ≈s φ1 ≈s φ2.
This example relies on a concept of equality of terms in a frame, which the following definition
captures.
Definition 4.2. Two terms M and N are equal in the frame φ, written (M = N)φ, if and only if
fv(M) ∪ fv(N) ⊆ dom(φ), φ ≡ νn.σ, Mσ = N σ, and {n} ∩ (fn(M) ∪ fn(N)) = ∅ for some names n
and substitution σ.
In Definition 4.2, the equality Mσ = N σ is independent of the representative νn.σ chosen for the
frame φ such that φ ≡ νn.σ and {n} ∩ (fn(M) ∪ fn(N)) = ∅. (Lemma D.1 in Appendix D establishes
this property.)
Definition 4.3. Two closed frames φ and ψ are statically equivalent, written φ ≈s ψ, when
dom(φ) = dom(ψ ) and when, for all terms M and N, we have (M = N)φ if and only if (M = N)ψ.
Two closed extended processes are statically equivalent, written A ≈s B, when their frames are
statically equivalent.
For instance, in our example, we have (f(x) = y)φ2 but not (f(x) = y)φ1, and hence, φ1 ≈s φ2.
Depending on Σ, static equivalence can be quite hard to check, but at least it does not depend on
the dynamics of processes. Some simplifications are possible in common cases, in particular when
terms can be put in normal forms (e.g., in the proof of Theorems 6.1 and 6.3). Decision procedures
exist for static equivalence in large classes of equational theories (Abadi and Cortier 2006), some
implemented in tools (Baudet et al. 2009a; Ciobâcă et al. 2012).
The next lemma establishes closure properties of static equivalence: it shows that static equivalence is invariant by structural equivalence and reduction, and closed by application of closing
evaluation contexts. Its proof appears in Appendix A.
Lemma 4.4. Let A and B be closed extended processes. If A ≡ B or A → B, then A ≈s B. If A ≈s B,
then E[A] ≈s E[B] for all closing evaluation contexts E[_].
As the next two lemmas demonstrate, static equivalence coincides with observational equivalence on frames, but is coarser on extended processes.
Lemma 4.5. Observational equivalence and static equivalence coincide on frames.
This lemma is an immediate corollary of Theorem 4.8 below. (See Corollary C.14 in Appendix C.3.)
Lemma 4.6. Observational equivalence is strictly finer than static equivalence on extended processes: ≈⊂≈s .
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.      
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:17
To see that observational equivalence implies static equivalence, note that if A and B are observationally equivalent, then A | C and B | C have the same barbs for every C with fv(C) ⊆ dom(A),
and that they are statically equivalent when A | C and B | C have the same barb ⇓a for every C
of the special form if M = N then an, where a does not occur in A or B and fv(C) ⊆ dom(A).
(See Lemma C.9 in Appendix C.3.) The converse does not hold, as the following counterexample
shows: letting A = an and B = bn, we have A  B, but A ≈s B because φ(A) = φ(B) = 0.
4.3 Labeled Operational Semantics and Equivalence
A labeled operational semantics extends the chemical semantics of Section 2.2, enabling us to reason about processes that interact with their context while keeping it implicit. The labeled semantics
defines a relation A α
−→ A
, where α is a label of one of the following forms:
• A label N (M), which corresponds to an input of M on N
• A label νx.Nx, where x is a variable that must not occur in N, which corresponds to an
output of x on N
The variable x is bound in the label νx.Nx, so we define the bound variables of labels by
bv(N (M)) def
= ∅ and bv(νx.Nx) def
= {x}. The free variables of labels are defined by fv(N (M)) def
=
fv(N) ∪ fv(M) and fv(νx.Nx) def
= fv(N) (since x does not occur in N in the latter label).
In addition to the rules for structural equivalence and reduction of Section 2, we adopt the
following rules:
In N (x).P
N (M) −−−−→ P{M/x }
Out-Var x  fv(NM.P)
NM.P ν x .N x −−−−−−−→ P | {M/x }
Scope
A α
−→ A u does not occur in α
νu.A α
−→ νu.A
Par
A α
−→ A bv(α) ∩ fv(B) = ∅
A | B α
−→ A | B
Struct
A ≡ B B α
−→ B B ≡ A
A α
−→ A .
According to In, a term M may be input. On the other hand, Out-Var permits output for terms
“by reference”: a fresh variable is associated with the term in question and output.
For example, using the signature and equations for symmetric encryption, and the new constant
symbol oops! , we have the sequence of transitions of Figure 3. The first two transitions do not
directly reveal the term M. However, they give enough information to the environment to compute
M as dec(x,y) and to input it in the third transition.
The labeled operational semantics leads to an equivalence relation:
Definition 4.7. A labeled bisimulation is a symmetric relation R on closed extended processes
such that A R B implies:
(1) A ≈s B;
(2) if A → A and A is closed, then B →∗ B and A R B for some B
;
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.                      
1:18 M. Abadi et al.
Fig. 3. Example transitions.
(3) if A α
−→ A
, A is closed, and fv(α) ⊆ dom(A), then B →∗ α
−→→∗ B and A R B for some B
.
Labeled bisimilarity (≈l) is the largest such relation.
Conditions 2 and 3 are standard; condition 1, which requires that bisimilar processes be statically
equivalent, is necessary, for example, in order to distinguish the frames φ0 and φ2 of Section 4.2.
As in Definition 4.1, we explicitly require that A be closed and fv(α) ⊆ dom(A) in order to exclude
transitions that introduce free unused variables.
Our main result is that this relation coincides with observational equivalence. Although such
results are fairly common in process calculi, they are important and nontrivial.
Theorem 4.8. Observational equivalence is labeled bisimilarity: ≈ = ≈l .
The proof of this theorem is outlined in Section 4.5 and completed in the appendix.
The theorem implies that ≈l is closed by application of closing evaluation contexts. However,
unlike the definition of ≈, the definition of ≈l does not include a condition about contexts. It
therefore permits simpler proofs.
In addition, labeled bisimilarity can probably be established via standard “bisimulation up to
context” techniques (Sangiorgi 1998), which enable useful on-the-fly simplifications in frames after
output steps. We do not develop the theory of “up to context” techniques, since we do not use them
in this article.
The following lemmas provide methods for simplifying frames:
Lemma 4.9 (Alias elimination). Let A and B be closed extended processes, M be a term such that
fv(M) ⊆ dom(A), and x be a variable such that x  dom(A). We have A ≈l B if and only if
{
M/x } | A ≈l {
M/x } | B.
Proof. Both directions follow from context closure of ≈l for the contexts {M/x } | _ and νx._,
respectively. In the converse direction, since x is not free in A or B, we have A ≡ νx.({M/x } | A),
νx.({M/x } | A) ≈l νx.({M/x } | B), and νx.({M/x } | B) ≡ B, and hence A ≈l B.
Lemma 4.10 (Name disclosure). Let A and B be closed extended processes and x be a variable
such that x  dom(A). We have A ≈l B if and only if
νn.({
n
/x } | A) ≈l νn.({
n
/x } | B).
Proof. The direct implication follows from context closure of ≈l . Conversely, we show that
the relation R defined by A R B if and only if A and B are closed extended processes and
νn.({
n
/x } | A) ≈l νn.({
n
/x } | B) for some x  dom(A) is a labeled bisimulation. This proof is detailed
in Appendix D.
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.     
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:19
In Lemma 4.9, the substitution {M/x } can affect only the context, since A and B are closed. However, the lemma implies that the substitution does not give or mask any information about A and B
to the context. In Lemma 4.10, the restriction on n and the substitution {
n
/x } mean that the context
can access n only indirectly, through the free variable x. Intuitively, the lemma says that indirect
access is equivalent to direct access in this case.
Our labeled operational semantics contrasts with a more naive semantics carried over from the
pure pi calculus, with output labels of the form νu.NM and rules that permit direct output of
any term, such as
Out-Term NM.P
N M −−−−→ P
Open
A νu.N M −−−−−−−→ A v ∈ fv(M) ∪ fn(M) \ (fv(N) ∪ fn(N) ∪ {u})
νv.A νv,u.N M −−−−−−−−−→ A
.
These rules lead to a different, finer equivalence relation, which, for example, would distinguish
νk,s.a(k,s) and νk.a(f(k), g(k)). This equivalence relation is often inadequate in applications
(as in Abadi and Gordon (1999, Section 5.2.1)), hence our definitions.
We have also studied intermediately liberal rules for output, which permit direct output of certain terms. In particular, the rules of the conference paper permit direct output of channel names.
That feature implies that it is not necessary to export variables of channel types; as Section 4.5
explains, this property is needed for Theorem 4.8 for those rules. That feature makes little sense
in the present calculus, in which arbitrary terms may be used as channels, so we abandon it in the
rules above. Nevertheless, certain rules with more explicit labels can still be helpful. We explain
those rules next.
4.4 Making the Output Labels More Explicit
In the labeled operational semantics of Section 4.3, the labels for outputs do not reveal anything
about the terms being output: those terms are represented by fresh variables. Often, however,
more explicit labels can be convenient in reasoning about protocols, and they do not cause harm
as long as they only make explicit information that is immediately available to the environment.
For instance, for the process νk.a(Header, enc(M, k)), the label νy.a(Header,y) is more informative than νx.ax. In this example, the environment could anyway observe that x is a pair such
that fst(x) = Header and use snd(x) for y. More generally, we rely on the following definition to
characterize the information that the environment can derive.
Definition 4.11. Variables xresolve to M in A if and only if A ≡ {M
/x} | νx.A. They are solvable in
A if and only if they resolve to some terms in A.
Hence, when variables x resolve to terms M in A, they are in dom(A) and we can erase the
restriction of νx.A by applying the context {M
/x} | _ and by structural equivalence. Intuitively, A
does not reveal more information than νx.A, because the environment can build the terms M and
use them instead of x.
In general, when variables x are in dom(A), there exist n, M, and A such that A ≡ νn.({M
/x} |
A
). If variables x resolve to M in A, then n can be chosen empty, so that the terms M are not
under restrictions. The following lemma provides two reformulations of Definition 4.11, including
a converse to this observation. Its proof appears in Appendix E.
Lemma 4.12. The following three properties are equivalent:
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.                                               
1:20 M. Abadi et al.
(1) The variables xresolve to M in A.
(2) There exists A such that A ≡ {M
/x} | A
.
(3) (x = M)φ(A) and the substitution {M
/x} is cycle-free.
For example, using pairs and symmetric encryption, we let
φ
def
= νk.{
M/x ,
enc(x,k)
/y,
(Header,y)
/z }.
The variable y resolves to snd(z) in φ, since
φ ≡ {snd(z)
/y } | νk.{
M/x ,
(Header,enc(x,k))/z },
and z resolves to (Header,y) in φ, since
φ ≡ {(Header,y)
/z } | νk.{
M/x ,
enc(x,k)
/y }.
In contrast, x is not always solvable in φ (for instance, when M is k).
A second lemma shows that Definition 4.11 is robust in the sense that it is preserved by static
equivalence, so a fortiori by labeled bisimilarity:
Lemma 4.13. If A ≈s B and xresolve to M in A, then xresolve to M in B.
Proof. Static equivalence preserves property 3 of Lemma 4.12, so we conclude by
Lemma 4.12.
We introduce an alternative semantics in which the rules permit composite terms in output labels but require that every restricted variable that is exported be solvable. In this semantics, the
label α in the relation A α
−→ A ranges over the same input labels N (M) as in Section 4.3, and over
generalized output labels of the form νx.NM, where {x} ⊆ fv(M) \ fv(N). The label νx.NM
corresponds to an output of M on N that reveals the variables x. We retain the rules for structural equivalence and reduction, and rules In, Par, and Struct of Section 4.3. We also keep rule
Scope, but only for labels with no extrusion, that is, for labels N (M) and NM. This restriction is
necessary because variables may not remain solvable after the application of a context νu._. As a
replacement for the rule Out-Var, we use the rule Out-Term discussed in Section 4.3 and
Open-Var
A
N M −−−−→ A {x} ⊆ fv(M) \ fv(N)
xsolvable in {M/z } | A for some z  fv(A
) ∪ {x}
νx.A νx.N M −−−−−−−→ A
.
These rules are more liberal than those of Section 4.3. For instance, considerA1 = νk.a(f(k), g(k))
and A2 = νk.a(k, f(k)). With the rules of Section 4.3, we have
Ai
ν z.az −−−−−−→ νx,y.({
(x,y)
/z } | φi ),
where φi is as in Section 4.2. With the new rules, we also have
Ai
ν x,y.a(x,y)
−−−−−−−−−−−→ φi . (5)
Indeed,Ai ≡ νx,y.(a(x,y) | φi ) and the variables x,y are solvable in {(x,y)
/z } | φi because {(x,y
/z } |
φi ≡ {fst(z)
/x ,
snd(z)
/y } | νx,y.({(x,y)
/z } | φi ), so we derive
a(x,y) a(x,y)
−−−−−−→ 0 by Out-Term
a(x,y) | φi
a(x,y)
−−−−−−→ φi by Par and Struct
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.                                                   
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:21
νx,y.(a(x,y) | φi ) ν x,y.a(x,y)
−−−−−−−−−−−→ φi by Open-Var
Ai
ν x,y.a(x,y)
−−−−−−−−−−−→ φi by Struct.
The transition in Equation (5) is the most informative for A1 since x and y behave like fresh,
independent values in φ1. For A2, we also have the more informative transition:
A2
ν x .a(x,f(x )) −−−−−−−−−−−→ νk.{
k
/x },
which reveals the link between x and y, but not that x is a name. As in this example, several output
transitions are sometimes possible, each transition leading to an extended process with a different
frame. In reasoning (e.g., in proving that a relation is included in labeled bisimilarity), it often
suffices to consider any one of the transitions, so one may be chosen so as to limit the complexity
of the resulting extended processes.
We name “simple semantics” the labeled semantics of Section 4.3 and “refined semantics” the semantics of this section, and “simple labels” and “refined labels” the corresponding labels. The next
theorem states that the two labeled semantics yield the same notion of equivalence. Thus, making
the output labels more explicit only makes apparent some of the information that is otherwise
kept in the static, equational part of labeled bisimilarity.
Theorem 4.14. Let ≈L be the relation of labeled bisimilarity obtained by applying Definition 4.7
to the refined semantics. We have ≈l = ≈L.
The proof of Theorem 4.14 relies on the next two lemmas, which relate simple and refined output
transitions.
Lemma 4.15. A νx.N M −−−−−−−→ A if and only if, for some z that does not occur in any of A, A
, x, N, and
M, A ν z.N z −−−−−−→ νx.({M/z } | A
), {x} ⊆ fv(M) \ fv(N), and the variables xare solvable in {M/z } | A
.
In Lemma 4.15, the transition A νx.N M −−−−−−−→ A is performed in the refined semantics, while the
transition A ν z.N z −−−−−−→ νx.({M/z } | A
) is performed in the simple semantics. However, Lemma 4.16
shows that the choice of the semantics does not matter. Lemma 4.16 is a consequence of
Lemma 4.15.
Lemma 4.16. A ν x .N x −−−−−−−→ A in the refined semantics if and only if A ν x .N x −−−−−−−→ A in the simple
semantics.
Theorem 4.14 is then proved as follows. By Lemma 4.16, ≈L is a simple-labeled bisimulation, and
thus ≈L ⊆ ≈l . Conversely, to show that ≈l is a refined-labeled bisimulation, it suffices to prove its
bisimulation property for any refined output label. This proof, which relies on Lemma 4.15, and
the proofs of Lemmas 4.12, 4.15, and 4.16 are detailed in Appendix E.
4.5 Proving Theorem 4.8 (≈ = ≈l )
A claim of Theorem 4.8 appears, without proof, in the conference version of this article for the
calculus as presented in that version. There, the channels in labels cannot be variables. The claim
neglects to include a corresponding hypothesis that exported variables must not be of channel type.
This hypothesis is implicitly assumed, as it holds trivially for plain processes and is maintained, as
an invariant, by output transitions. Without it, the two extended processes νa.({
a
/x }) and νa.({
a
/x } |
aN) (where the exported variable x stands for the channel a) would constitute a counterexample:
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.                             
1:22 M. Abadi et al.
they would not be observationally equivalent, but they would be bisimilar in the labeled semantics,
since neither could make a labeled transition. Delaune et al. (2007, 2010) included the hypothesis
in their study of symbolic bisimulation. Avik Chaudhuri (private communication, 2007) pointed
out this gap in the statement of the theorem, and Bengtson et al. (2011) discussed it as motivation
for their work on alternative calculi, the psi calculi, with a more abstract treatment of terms and a
mechanized metatheory. On the other hand, Liu (2011) presented a proof of the theorem, making
explicit the necessary hypothesis. Her proof demonstrated that the theorem was basically right—no
radical changes or new languages were needed. More recently, Liu and others have also developed
an extension of the proof for a stateful variant of the applied pi calculus (Arapinis et al. 2014).
Theorem 4.8, in its present form, does not require that hypothesis because of some of the details
of the calculus as we define it in this article. Specifically, the labeled semantics allows variables
that stand for channels in labels. Therefore, extended processes such as νa.({
a
/x } | aN) can make
labeled transitions.
This section outlines the proof of Theorem 4.8. The appendix gives further details, including all
proofs that this section omits. Those details are fairly long and technical. In particular, they rely
on a definition of “partial normal forms” for extended processes, which are designed to simplify
reasoning about reductions. (In an extended process A | B, the frame of A may affect B and vice
versa, soA and B may not reduce independently of each other; partial normal forms are designed to
simplify the analysis of reductions in such situations.) We believe that these partial normal forms
may be useful in other proofs on the applied pi calculus. In this section, we omit further specifics
on partial normal forms, since they are not essential to understanding our main arguments.
The proof of Theorem 4.8 starts with a fairly traditional definition of “labeled bisimulation up
to ≡”:
Definition 4.17. A relation R on closed extended processes is a labeled bisimulation up to ≡ if
and only if R is symmetric and A R B implies:
(1) A ≈s B;
(2) if A → A and A is closed, then B →∗ B and A ≡R≡ B for some closed B
;
(3) if A α
−→ A
, A is closed, and fv(α) ⊆ dom(A), then B →∗ α
−→→∗ B and A ≡R≡ B for some
closed B
.
This definition implies that, if R is a labeled bisimulation up to ≡, then ≡R≡ restricted to closed
processes is a labeled bisimulation (since, by Lemma 4.4, static equivalence is invariant by structural equivalence).
We use the definition to establish the following lemma:
Lemma 4.18. ≈l is closed by application of closing evaluation contexts.
In the proof of this lemma (which is given in Appendix C.2), we show that we can restrict
attention to contexts of the form νu.(_ | C). To every relation R on closed extended processes,
we associate a relation R = {(νu.(A | C), νu.(B | C)) | A R B, νu.(_ | C) closing for A and B}. We
prove that, if R is a labeled bisimulation, then R is a labeled bisimulation up to ≡, and hence
R ⊆ ≡R
≡⊆≈l . For R = ≈l , this property entails that ≈l is closed by application of evaluation
contexts νu.(_ | C).
Another lemma characterizes barbs in terms of labeled transitions:
Lemma 4.19. Let A be a closed extended process. We have A ⇓a if and only if A →∗ ν x .ax −−−−−−→ A for
some fresh variable x and some A
.
We then obtain Lemma 4.20, which is one direction of Theorem 4.8:
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.         
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:23
Lemma 4.20. ≈l ⊆ ≈.
Proof. We show that ≈l satisfies the three properties of Definition 4.1, as follows:
(1) To show that ≈l preserves barbs, we apply Lemma 4.19 and use Properties 2 and 3 of
Definition 4.7.
(2) Suppose that A ≈l B, A →∗ A
, and A is closed. Given the trace A = A0 → A1 →···→
An = A
, we instantiate all variables in n
i=0 (fv(Ai ) \ dom(Ai )) with fresh names. This
instantiation yields a trace in which all intermediate processes are closed. We can then
conclude that B →∗ B and A ≈l B for some B by Property 2 of Definition 4.7.
(3) ≈l is closed by application of closing evaluation contexts by Lemma 4.18.
Moreover, ≈l is symmetric. Since ≈ is the largest relation that satisfies these properties, we obtain
≈l ⊆ ≈.
The other direction of Theorem 4.8 relies on two lemmas that characterize input and output
transitions. The first lemma characterizes inputs N (M) using processes of the formTp
N (M)
def
= pp |
NM.p(x). Here, the use of p as a message in pp is arbitrary: we could equally use processes of
the form pM
 for any term M
.
Lemma 4.21. Let A be a closed extended process. Let N and M be terms such that fv(NM) ⊆
dom(A). Let p be a name that does not occur in A, M, and N.
(1) If A
N (M) −−−−→ A and p does not occur in A
, then A | Tp
N (M) →→ A and A ⇓p.
(2) If A | Tp
N (M) →∗ A and A ⇓p, then A →∗ N (M) −−−−→→∗ A
.
The second lemma characterizes outputs νx.Nx using processes of the formTp,q
ν x .N x
def
= pp |
N (x).p(y).qx.
Lemma 4.22. Let A be a closed extended process. Let N be a term such that fv(N) ⊆ dom(A). Let p
and q be names that do not occur in A and N.
(1) IfA ν x .N x −−−−−−−→ A andp and q do not occur inA
, thenA | Tp,q
ν x .N x →→ νx.(A | qx), νx.(A |
qx) ⇓p, and x  dom(A).
(2) Let x be a variable such that x  dom(A). If A | Tp,q
ν x .N x →∗ A and A ⇓p, then
A →∗ ν x .N x −−−−−−−→→∗ A and A ≡ νx.(A | qx) for some A
.
A further lemma provides a way of proving the equivalence of two extended processes with the
same domain by putting them in a context that binds the variables in their domain and extrudes
them. Given a family of processes Pi fori in a finite setI, we write i Pi for the parallel composition
of the processes Pi if I is not empty, and 0 otherwise.
Lemma 4.23. Let A and B be two closed extended processes with a same domain that contains x.
Let Ex[_] def
= νx.(
x ∈x nx x | _ ) using names nx that do not occur in A or B. If Ex[A] ≈ Ex[B], then
A ≈ B.
The final lemma is the other direction of Theorem 4.8:
Lemma 4.24. ≈ is a labeled bisimulation, and thus ≈⊆≈l .
Proof. The relation ≈ is symmetric. We show that it satisfies the three properties of Definition 4.7.
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.                                           
1:24 M. Abadi et al.
(1) If A ≈ B, then A ≈s B, by Lemma 4.6.
(2) If A ≈ B, A → A
, and A is closed, then B →∗ B and A ≈ B for some B
, by Property 2
of the definition of ≈.
(3) If A ≈ B, A α
−→ A
, A is closed, and fv(α) ⊆ dom(A), then B →∗ α
−→→∗ B and A ≈ B for
some B
. To prove this property, we rely on characteristic contexts _ | Tα that unambiguously test for a labeled transition α
−→ using the disappearance of a barb ⇓p, and do not
otherwise affect ≈.
Assume A ≈ B, A α
−→ A
, A is closed, and fv(α) ⊆ dom(A).
(a) For input α = N (M) (where N and M may contain variables exported by A and B)
and some fresh name p, we have A | Tp
N (M) →→ A ⇓p by Lemma 4.21(1), and hence
B | Tp
N (M) →∗ B ⇓p with A ≈ B
, and hence B →∗ N (M) −−−−→→∗ B by Lemma 4.21(2).
(b) For output α = νx.Nx and some fresh names p and q, we have A | Tp,q
ν x .N x →→
νx.(A | qx) ⇓p and x  dom(A) by Lemma 4.22(1), and hence B | Tp,q
ν x .N x →∗ B ⇓
p for some B, and hence B →∗ ν x .N x −−−−−−−→→∗ B and B ≡ νx.(B | qx) for some B
by Lemma 4.22(2). We obtain a pair νx.(A | qx) ≈ νx.(B | qx) and conclude by
applying Lemma 4.23.
Hence, ≈ is a labeled bisimulation, and ≈⊆≈l , since ≈l is the largest labeled bisimulation.
Theorem 4.8 is an immediate consequence of Lemmas 4.20 and 4.24.
Considering this proof of Theorem 4.8, we can explain further some aspects of our definition
of observational equivalence (Definition 4.1). That definition includes conditions related to barbs,
reductions, and evaluation contexts (Conditions (1) to (3), respectively), as is done in work on the
ν-calculus (Honda and Yoshida 1995) and on the join calculus (Abadi et al. 1998). In an alternative approach, used in CCS (Milner and Sangiorgi 1992) and in the pi calculus (Sangiorgi 1993),
equivalence is defined in two stages:
(1) First, barbed bisimilarity is defined as the largest barbed bisimulation, that is, the largest
symmetric relation R such that A R B implies Conditions (1) and (2) of Definition 4.1.
(2) Second, equivalence is defined as the largest congruence (i.e., the largest relation R such
that A R B implies Condition (3) of Definition 4.1) contained in barbed bisimilarity.
The two approaches do not necessarily yield the same equivalence relation; see Fournet and
Gonthier (1998) for positive and negative examples in variants of the pi calculus. The advantage of
our approach is that, in reasoning about process equivalences, we can add a context at any point
after reductions, as we do in the proof of Lemma 4.24. With the alternative approach, we can add
a context only at the beginning, before any reduction, so we need to build contexts that test for all
possible sequences of labeled transitions that the processes under consideration may make, and
that manifest them as different combinations of barbs. This testing is not possible for all processes,
so with the alternative approach, analogs of Theorem 4.8 would typically require a restriction
to so-called image finite processes (Milner and Sangiorgi 1992). Our definition of observational
equivalence avoids this restriction.
It would be interesting to formalize the proofs of this section (and also those of the rest of the
article) with a theorem prover such as Coq. This formalization may perhaps benefit from past Coq
developments on bisimulations for the pi calculus (Hirschkoff 1997; Honsell et al. 2001) and the spi
calculus (Briais 2008). However, the applied pi calculus introduces additional difficulties (because
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.                  
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:25
of the role of terms with equational theories), and proving our results with Coq would certainly
require a major effort.
5 DIFFIE-HELLMAN KEY AGREEMENT
The fundamental Diffie-Hellman protocol allows two principals to establish a shared secret by exchanging messages over public channels (Diffie and Hellman 1976). The principals need not have
any shared secrets in advance. The basic protocol, on which we focus here as an example, does
not provide authentication; therefore, a “bad” principal may play the role of either principal in
the protocol. On the other hand, the two principals that follow the protocol will communicate securely with one another afterward, even in the presence of active attackers. In extended protocols,
such as the Station-to-Station protocol (Diffie et al. 1992) and SKEME (Krawczyk 1996), additional
messages perform authentication.
We program the basic protocol in terms of the binary function symbol f and the unary function
symbol g, with the equation
f(x, g(y)) = f(y, g(x)). (6)
Concretely, the functions are f(x,y) = yx mod p and g(x) = αx mod p for a prime p and a generator α of Z∗
p , and we have the equation f(x, g(y)) = (αy )
x = αy×x = αx×y = (αx )
y = f(y, g(x)).
However, we ignore the underlying number theory, working abstractly with f and g.
The protocol has two symmetric participants, which we represent by the processes A0 and A1.
The protocol establishes a shared key, then the participants respectively run P0 and P1 using the
key. We use the public channel c01 for messages from A0 to A1 and the public channel c10 for
communication in the opposite direction. (Although the use of two distinct public channels is of
no value for security, it avoids some trivial confusions and so makes for a cleaner presentation.)
We assume that none of the values introduced in the protocol appear in P0 and P1, except for the
key.
In order to establish the key, A0 invents a name n0 and sends g(n0) to A1, and A1 proceeds
symmetrically. Then A0 computes the key as f(n0, g(n1)) and A1 computes it as f(n1, g(n0)), with
the same result. We find it convenient to use the following substitutions for A0’s message and key:
σ0
def
= {
g(n0 )
/x0 }
ϕ0
def
= {
f(n0,x1 )
/y }
and the corresponding substitutions σ1 and ϕ1, as well as the frame
φ
def
= (νn0. (ϕ0 | σ0)) | (νn1. σ1).
With these notations, A0 is
A0
def
= νn0.(c01x0σ0 | c10 (x1).P0ϕ0),
and A1 is analogous.
Two reductions represent a normal run of the protocol:
A0 | A1 →→ νx0, x1,n0,n1. (P0ϕ0 | P1ϕ1 | σ0 | σ1) (7)
≡ νx0, x1,n0,n1,y. (P0 | P1 | ϕ0 | σ0 | σ1) (8)
≡ νy.(P0 | P1 | νx0, x1. φ). (9)
The two communication steps (Equation (7)) use structural equivalence to activate the substitutions σ0 and σ1 and extend the scope of the secret values n0 and n1. The structural equivalence
(Equation (8)) crucially relies on Equation (6) in order to reuse the active substitution ϕ0 instead
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.  
1:26 M. Abadi et al.
of ϕ1 after the reception of x0 in A1. The next structural equivalence (Equation (9)) tightens the
scope for restricted names and variables, then uses the definition of φ.
We model an eavesdropper as a processc01 (x0).c01x0.c10 (x1).c10x1.P that intercepts messages
on c01 and c10, remembers them, but forwards them unmodified. Using the labeled semantics to
represent the interaction of A0 | A1 with such a passive attacker, we obtain
A0 | A1
c01x0 −−−−−→ νn0.(σ0 | c10 (x1).P0ϕ0) | A1
c01 (x0 ) −−−−−→ νn0.(σ0 | c10 (x1).P0ϕ0) | νn1.(c10σ1x1 | P1ϕ1)
c10x1 −−−−−→ νn0.(σ0 | c10 (x1).P0ϕ0) | νn1.(σ1 | P1ϕ1)
c10 (x1 ) −−−−−→ νn0.(σ0 | P0ϕ0) | νn1.(σ1 | P1ϕ1)
≡ νn0,n1,y. (P0 | P1 | ϕ0 | σ0 | σ1)
≡ νy.(P0 | P1 | φ).
The labeled transitions c01x0 −−−−−→ c01 (x0 ) −−−−−→ show that the eavesdropper obtains the message sent on c01
by A0, stores it in x0, and forwards it to A1. The transitions c10x1 −−−−−→ c10 (x1 ) −−−−−→ deal with the message
on c10 in a similar way. The absence of the restrictions on x0 and x1 corresponds to the fact that
the eavesdropper has obtained the values of these variables.
The following theorem relates this process to
νk.(P0 | P1){
k
/y },
which represents the bodies P0 and P1 of A0 and A1 sharing a key k. This key appears as a simple
shared name, rather than as the result of communication and computation. Intuitively, we may
read νk.(P0 | P1){
k
/y } as the ideal outcome of the protocol: P0 and P1 execute using a shared key,
without concern for how the key was established, and without any side effects from weaknesses
in the establishment of the key. The theorem says that this ideal outcome is essentially achieved,
up to some “noise.” This “noise” is a substitution that maps x0 and x1 to unrelated, fresh names.
It accounts for the fact that an attacker may have the key-exchange messages, and that they look
just like unrelated values to the attacker. In particular, the key in use between P0 and P1 has no
observable relation to those messages, or to any other leftover secrets. We view this independence
of the shared key as an important forward-secrecy property.
Theorem 5.1. Let P0 and P1 be processes with free variable y where the name k does not appear.
We have
νy.(P0 | P1 | φ) ≈ νk.(P0 | P1){
k
/y } | νs0.{
s0
/x0 } | νs1.{
s1
/x1 }.
Proof. The theorem follows from Lemma 4.5 and the static equivalence φ ≈s
νs0,s1, k.{
s0
/x0 ,
s1 /x1 ,
k /y }, which says that the frame φ generated by the protocol execution is
equivalent to one that maps variables to fresh names. This static equivalence is proved automatically by ProVerif, using the technique presented in Blanchet et al. (2008). We conclude by applying
the context νy.(P0 | P1 | _).
Extensions of the basic protocol add rounds of communication that confirm the key and authenticate the principals. We have studied one such extension with key confirmation. There, the
shared secret f(n0, g(n1)) is used in confirmation messages. Because of these messages, the shared
secret can no longer be equated with a virgin key for P0 and P1. Instead, the final key is computed
by hashing the shared secret. This hashing guarantees the independence of the final key.
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.               
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:27
Fig. 4. A correct trace.
We have also studied more advanced protocols that rely on a Diffie-Hellman key exchange, such
as the JFK protocol (Aiello et al. 2004). The analysis of JFK in the applied pi calculus (Abadi et al.
2007) illustrates the composition of manual reasoning with invocations of ProVerif.
6 HASH FUNCTIONS AND MESSAGE AUTHENTICATION CODES
Section 3 briefly discusses cryptographic hash functions. In this section, we continue their study,
and also treat message authentication codes (MACs). We consider constructions of both hash functions and MACs. These examples provide a further illustration of the usefulness of equations
in the applied pi calculus. On the other hand, some aspects of the constructions are rather low
level, and we would not expect to account for all their combinatorial details (e.g., the “birthday attacks” (Menezes et al. 1996)). A higher-level task is to express and reason about protocols treating
hash functions and MACs as primitive; this is squarely within the scope of our approach.
6.1 Using MACs
MACs serve to authenticate messages using shared keys. When k is a key and M is a message,
and k is known only to a certain principal A and to the recipient B of the message, B may take
mac(k, M) as proof that M comes fromA. More precisely, B can check mac(k, M) by recomputing it
upon receipt of M and mac(k, M), and reason that A must be the sender of M. This property should
hold even if A generates MACs for other messages as well; those MACs should not permit forging
a MAC for M. In the worst case, it should hold even if A generates MACs for other messages on
demand.
Using a new binary function symbol mac, we may describe this scenario by the following processes:
A def
= !a(x).b(x, mac(k, x))
B def
= b(y).if mac(k, fst(y)) = snd(y) then cfst(y)
S def
= νk.(A | B)
The process S represents the complete system, composed of A and B; the restriction on k means
that k is private toAand B. The processAreceives messages on a public channel a and returns them
MACed on the public channel b. When B receives a message on b, it checks its MAC and acts upon
it, here simply by forwarding on a channel c. Intuitively, we would expect that B forwards on c
only a message thatA has MACed. In other words, although an attacker may intercept, modify, and
inject messages on b, it should not be able to forge a MAC and trick B into forwarding some other
message. Hence, every message output on c equals a preceding input on a, as illustrated in Figure 4.
This property can be expressed precisely in terms of the labeled semantics and it can be checked
without too much difficulty when mac is a primitive function symbol with no equations. The property remains true even if there is a function extract that maps a MAC mac(x,y) to the underlying
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.    
1:28 M. Abadi et al.
Fig. 5. An attack scenario.
cleartext y, with the equation extract(mac(x,y)) = y. Since MACs are not supposed to guarantee
secrecy, such a function may well exist, so it is safer to assume that it is available to the attacker.
The property is more delicate if mac is defined from other operations, as it invariably is in
practice. In that case, the property may even be taken as the specification of MACs (Goldwasser
and Bellare 1999). Thus, a MAC implementation may be deemed correct if and only if the process S
works as expected when mac is instantiated with that implementation. More specifically, the next
section deals with the question of whether the property remains true when mac is defined from
hash functions.
6.2 Constructing Hash Functions and MACs
In Section 3, we give no equations for hash functions. In practice, following Merkle and Damgård,
hash functions are commonly defined by iterating a basic binary compression function, which
maps two input blocks to one output block (Menezes et al. 1996). Furthermore, keyed hash functions include a key as an additional argument. Thus, we may have
h(x,y0 :: y1 :: z) = h(f(x,y0),y1 :: z) (10)
h(x,y :: nil) = f(x,y). (11)
Here, we use the sorts Block for blocks and BlockList for sequences of blocks, defined as lists as
in Section 3, with sorts Block and BlockList instead of Data and List, respectively. The function
h : Block × BlockList → Block is the keyed hash function; f : Block × Block → Block is the compression function.
In these equations, we are rather abstract in our treatment of blocks, their sizes, and therefore
padding and other related issues. We also ignore two common twists: some functions use initialization vectors to start the iteration, and some append a length block to the input. Nevertheless,
we can explain various MAC constructions, describing flaws in some and reasoning about the
properties of others.
A first, classical definition of a MAC from a keyed hash function h is
mac(x,y) def
= h(x,y).
For instance, the MAC of a three-block message M = M1 :: M2 :: M3 :: nil with key k is mac(k, M) =
f(f(f(k, M1), M2), M3). More generally, the MAC of an n-block message M = M1 :: ... :: Mn :: nil is
mac(k, M) = f(... (f(k, M1),...), Mn ). This implementation is subject to a well-known extension
attack. Given the MAC of M = M1 :: ... :: Mn :: nil, an attacker can compute the MAC of any extension M ++ N = M1 :: ... :: Mn :: N :: nil without knowing the MAC key, since mac(k, M ++ N) =
f(mac(k, M), N).
We describe the extension attack formally, through the operational semantics of the process
S of Section 6.1, in Figures 5 and 6. These figures use the semantics of Sections 4.3 and 4.4,
respectively. In both cases, we assume k  fn(M) ∪ fn(N). Additionally, we adopt the sorts
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017. 
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:29
Fig. 6. An attack scenario (with refined labels).
pair : BlockList × Block → Data, fst : Data → BlockList, and snd : Data → Block; the abbreviation (M, N) for pair(M, N); and Equations (1) and (2) of Section 3. In Figures 5 and 6, we see that
the message M that the system MACs differs from the message M ++ N that it forwards on c. These
transitions are not enabled with the primitive MAC of Section 6.1; hence, S with the proposed MAC
implementation is not labeled bisimilar to S with the primitive MAC.
There are several ways to address extension attacks, and indeed the literature contains many
MAC constructions that are not subject to these attacks. We have considered some of them. Here
we describe a construction that uses the MAC key twice:
mac(x,y) def
= f(x, h(x,y)).
Under this definition, the MAC of M = M1 :: M2 :: M3 :: nil with key k is mac(k, M) =
f(k, f(f(f(k, M1), M2), M3)), and the process S forwards on c only a message that it has previously
MACed, as desired.
Looking beyond the case of S, we can prove a more general result by comparing the situation
where mac is primitive (and has no special equations) and one with the definition of mac(x,y) as
f(x, h(x,y)). Given a name k and an extended process C that uses the symbol mac, we write [[C]]
for the translation ofC in which the definition of mac is expanded wherever the key k is used, with
f(k, h(k, M)) replaced for mac(k, M). The theorem says that this translation yields an equivalent
process (so, intuitively, the constructed MACs work as well as the primitive ones). It applies to a
class of equational theories generated by rewrite rules.
Theorem 6.1. Suppose that the signature Σ is equipped with an equational theory generated by a
convergent rewrite system such that mac and f do not occur in the left-hand sides of rewrite rules; the
only rewrite rules with h at the root of the left-hand side are those of Equations (10) and (11) oriented
from left to right; there are no rewrite rules with :: nor nil at the root of the left-hand side; and names
do not occur in rewrite rules. Suppose that C is closed and the name k appears only as first argument
of mac in C. Then νk.C ≈ νk.[[C]].
In the proof of this theorem (which is given in Appendix F), we use the same notion of partial
normal form as in the proof of Theorem 4.8. We define a relation R by A R B if and only if A and
B are closed, A ≡ νk.C, B ≡ νk.[[C]], C is a closed extended process in partial normal form, and the
name k appears only as MAC key in C. We show that the relation R∪R−1 (i.e., the union of R
with its inverse relation) is a labeled bisimulation. Static equivalence follows from the preservation
of equality by the translation [[ · ]] for terms in which k occurs only as MAC key; reductions commute with the translation [[ · ]] and preserve the restriction on the occurrences of the key k. We
conclude by Theorem 4.8. An alternative proof of similar complexity would show that R∪R−1 is
an observational bisimulation.
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.
1:30 M. Abadi et al.
Theorem 6.1 considers a single MAC key at a time. For an extended process with several MAC
keys k1,..., kn, we can apply Theorem 6.1 once for each key ki , using structural equivalence to
move each restriction νki to the root of the extended process.
Theorem 6.1 allows cryptographic primitives other than hash functions and MACs, provided the
assumptions on the equational theory are satisfied. The following corollary states a simple special
case for the primitives mentioned in this section. It suffices for treating the system S.
Corollary 6.2. Suppose that the signature Σ is equipped with the equational theory defined by
Equations (1), (2), (3), (4), (10), and (11). Suppose that C is closed and the name k appears only as a
first argument of mac in C. Then νk.C ≈ νk.[[C]].
6.3 Constructing Robust Hash Functions
Constructions of hash functions, of the kind described in Section 6.2, typically impose constraints
on the use of these functions. For example, some care is needed in order to thwart extension
attacks in the definition of MACs. The possibility of such attacks stems from structural flaws in the
constructions; details such as the iteration of a compression function are not completely hidden,
lead to unwanted additional properties, and can be exploited.
A line of work in cryptography studies safer hash functions with stronger guarantees (Coron
et al. 2005). Although these functions are generally built much as in Section 6.2 by iterating a
compression function, their design conceals their inner structure. The functions thus aim to behave
like abstract “random oracles” on inputs of arbitrary length. A notion of indifferentiability captures
this goal.
In this section, as a final, more advanced example, we describe one design that strengthens the
Merkle-Damgård approach, following Coron et al. (2005, Section 3.4). In this example, the attacker
is given only indirect access to functions, such as the hash function h. We model this restriction
by inserting a private name k as the first argument of h. (Cryptographically, the name k may
reflect the initial random sampling of h.) We refer to this argument as a key, of sort Key. We use
sorts Block for blocks and BlockList for sequences of blocks, defined as lists as in Section 3, with
sorts Block and BlockList instead of Data and List, respectively. We use sort Block2 for pairs of
blocks, with pair : Block × Block → Block2, fst : Block2 → Block, and snd : Block2 → Block; the
abbreviation (x,y) for pair(x,y); and the equations
fst((x,y)) = x snd((x,y)) = x (fst(x),snd(x)) = x. (12)
The third equation of (12) is not present in Section 3; it models that all elements of sort Block2 are
pairs. We use sort Block3 for pairs of a Block2 and a Block defined in the same way with overloaded
function symbols pair, fst, and snd, and sort Bool for Booleans.
We define the hash function h : Key × BlockList → Block by
h(k, z) = h2 (k, (0, 0), z), (13)
where
h2 (k, x, nil) = fst(x) (14)
h2 (k, x,y :: z) = h2 (k, f(k, (x,y)), z). (15)
The function h2 : Key × Block2 × BlockList → Block uses a compression function f : Key ×
Block3 → Block2. In h2 (k, x, z), the variable x represents the fixed-size internal state of the hash
function and z is the remainder of the input. The internal state starts at (0, 0) and is updated by
applications of the compression function f as input blocks are processed. Finally, only the first half
of the internal state is returned.
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:31
For instance, the hash of a two-block message M = M1 :: M2 :: nil with key k is h(k, M) =
fst(f(k, (f(k, ((0, 0), M1)), M2))). More generally, we have
h(k, M1 :: ... :: Mn :: nil) = fst(f(k, (... f(k, ((0, 0), M1)) ..., Mn ))).
Indifferentiability requires that the hash function behave like a black box (like a “random oracle”), even in interaction with an adversary that also has access to the underlying compression
function. The compression function and the hash function are related, of course. However, as far
as the adversary can tell, it is the compression function that may be defined from the hash function (in fact, from an ideal hash function without equations as in Section 3) rather than the other
way around. Thus, we express indifferentiability as the equivalence of two systems, each of which
provides access to the hash function and the compression function. In the applied pi calculus, one
of the systems is
νk.(A0
h | A0
f ),
where the processes
A0
h = !ch (y).if ne_list(y) = true then c
hh(k,y)
A0
f = !cf (x).c
f f(k, x)
answer requests to evaluate h and f with key k. We restrict ourselves to hashes of nonempty
sequences of blocks. In practice, one never hashes the empty string, because the input of the hash
function is padded to a nonzero multiple of the block length. This restriction is important in this
example, because the definition of h yields h(k, nil) = 0, and this special hash value would break
indifferentiability. In order to enforce this restriction, we use symbols true : Bool and ne_list :
BlockList → Bool, with equations
ne_list(x :: nil) = true ne_list(x :: y :: z) = ne_list(y :: z). (16)
The term ne_list(M) is equal to true when M is a nonempty list.
The other system offers an analogous interface for an ideal hash function h : Key × BlockList →
Block and for a stateful compression function built from h
:
νk.(A1
h | A1
f ).
The process A1
h answers requests to evaluate an ideal hash function h
:
A1
h = !ch (y).if ne_list(y) = true then c
hh
(k,y)
and A1
f simulates the compression function using h
. The code for A1
f , which is considerably more
intricate, captures the core of the security argument as it might appear in the cryptography literature. (The paper by Coron et al. (2005) omits this argument and, as far as we know, this argument
does not appear elsewhere.)
A1
f = ν,cs .(!cs (s).cf (x).x,s,s | !Q | cs ((0, 0), nil) :: nil)
Q = (x,t,s).if t = nil then P0 else
if fst(hd(t)) = fst(x) then P1 else x,tl(t),s
P0 = c
f f

(k, x) | cs s
P1 = let z = snd(hd(t)) in
let z = z ++ snd(x) in
let r = (h
(k, z
), fc (k, z
)) in
c
f r | cs (r, z
) :: s
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.                        
1:32 M. Abadi et al.
In this definition, let x = M in P is syntactic sugar for P{M/x }; (x,t,s).P is syntactic sugar for
(y).let x = fst(y) in let t = fst(snd(y)) in let s = snd(snd(y)) in P, where y is a fresh variable;
and x,t,s is syntactic sugar for (x, (t,s)), with the appropriate sorts and overloading of the
function symbols for pairs. The function symbol f : Key × Block3 → Block2 represents the compression function outside the domain used for implementing the hash function, and the function
symbol fc : Key × BlockList → Block represents the second projection of the compression function
inside that domain. The channelcs maintains the global private state, a lookup table that maps each
term (h
(k, M), fc (k, M)) with M = M1 :: ... :: Mn :: nil built as a result of previous compression
requests to the term M, and initially maps (0, 0) to nil. This lookup table is represented as a list of
pairs. Each table element, of sort Block2Blocks, is a pair of a Block2 and a BlockList; the table, of
sort Block2Blocks_List, is a list of Block2Blocks; we overload the function symbols for pairs and
lists. Upon a compression request with input x, the processQ looks up fst(x) in the table:Q receives
as input x, the initial state of the table s, and the tail t of the lookup table. It uses a local channel l
for encoding the recursive call. The auxiliary processes P0 and P1 complete compression requests
in the cases where lookups fail and succeed, respectively. When a lookup fails, the compression request is outside the domain used for implementing the hash function, so P0 answers it using f and
leaves the table unchanged. When a lookup succeeds, we have either fst(x) = (h
(k, M), fc (k, M))
with M = M1 :: ... :: Mn−1 :: nil and n > 0, or fst(x) = (0, 0) and we let M = nil. The lookup yields
z = M, and P1 computes z = z ++ snd(x) and returns r = (h
(k, z
), fc (k, z
)) as result of the compression request. The table is extended by adding the mapping from r to z
.
Let us now explain, informally, why this code ensures that the results of the compression function are consistent with those of hash computations. The result of a compression request with
argument x needs to be made consistent with the hash function when
x = (f(k, (... f(k, ((0, 0), M1)) ..., Mn−1)), Mn ) (17)
for some M1,..., Mn (n > 0), because in that case
h(k, M1 :: ... :: Mn :: nil) = fst(f(k, x)); (18)
that is, in the systemνk.(A0
h | A0
f ), the result of the hash request with argument M1 :: ... :: Mn :: nil
computed by A0
h is equal to the first block of the result of the compression request with argument x computed by A0
f . We need to have an analogous equality in the system νk.(A1
h | A1
f ). In
the system νk.(A0
h | A0
f ), the equality in Equation (17) holds exactly when fst(x) is the result of
previous compression requests f(k, (... f(k, ((0, 0), M1)) ..., Mn−1)) for some M1,..., Mn−1. In the
system νk.(A1
h | A1
f ), the table lookup tests a corresponding condition, and when it succeeds, P1
retrieves z = M1 :: ... :: Mn−1 :: nil, computes z = M1 :: ... :: Mn−1 :: Mn :: nil since snd(x) = Mn,
and returnsr = (h
(k, z
), fc (k, z
)). Hence, fst(r) = h
(k, z
) and the result of the hash request with
argument z = M1 :: ... :: Mn :: nil computed by A1
h is equal to the first block of the result r of the
compression request with argument x computed by A1
f .
Formally, we obtain the following observational equivalence:
Theorem 6.3. νk.(A0
h | A0
f ) ≈ νk.(A1
h | A1
f ).
In the proof of this theorem (which is given in Appendix G), we define a relation R between configurations of the two systems and show that R∪R−1 is a labeled bisimulation. A key step of this
proof consists in proving static equivalence between related configurations; this step formalizes
the informal explanation of the process Af
1 given above. We conclude by Theorem 4.8.
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.        
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:33
7 RELATED WORK
This section aims to position the applied pi calculus with respect to research on process calculi and
on the analysis of security protocols. As discussed in Section 1, the applied pi calculus has been the
basis for much further work since its initial publication; this section does not discuss many papers
that build on the applied pi calculus. (Some of those papers, and others, are mentioned elsewhere
in this article.)
7.1 Process Calculi
The applied pi calculus has many commonalities with the original pi calculus (Milner 1999) and
its relatives, such as the spi calculus (Abadi and Gordon 1999) (discussed in Sections 3 and 4). In
particular, the model of communication adopted in the applied pi calculus is deliberately classical: communication is through named channels, and value computation is rather separate from
communication.
Furthermore, active substitutions are reminiscent of the constraints of the fusion calculus (Victor
1998). They are especially close to the substitution environments that Boreale et al. employ in
their proof techniques for a variant of the spi calculus with a symmetric cryptosystem (Boreale
et al. 1999). We incorporate substitutions into processes, systematize them, and generalize from
symmetric cryptosystems to arbitrary operations and equations.
Extensions of the pi calculus are not limited to modeling cryptography: many extensions and
variants of the pi calculus have been designed for diverse applications. Examples include calculi
for mobility, such as the ambient calculus (Cardelli and Gordon 2000); calculi for modeling biological processes, such as the enhanced pi calculus (Curti et al. 2004); and calculi for service-oriented
computing, which model the contracts that services implement, the composition of services, and
their protocols (Buscemi and Montanari 2007; Cruz-Filipe et al. 2014; Lapadula et al. 2007; Lucchi
and Mazzara 2007). The psi calculi (Bengtson et al. 2011) provide a general framework parameterized by nominal data types for terms, conditions (generalizing comparison between terms),
and assertions (generalizing our notion of frames) and their operational semantics. They also give
sufficient conditions on these parameters to ensure that the resulting observational equivalence
coincides with labeled bisimilarity. The framework accommodates encodings of the pi calculus and
several of its variants, for example, ones with fusion (Wischik and Gardner 2004) and concurrent
constraints (Buscemi and Montanari 2007). In particular, Bengtson et al. give an encoding of the
applied pi calculus in their framework. However, as they explain, the result of this encoding differs
from the applied pi calculus in the way processes interact with contexts. In particular, an important difference is that, when an encoded process sends a ciphertext, the ciphertext appears on the
label of the transition, and an agent that receives this message will immediately learn the cleartext
and the key. In psi calculi, one can avoid such counterintuitive disclosures by explicitly creating
and using aliases. A recent extension of psi calculi (Borgström et al. 2014, 2016) addresses these
difficulties with a new form of pattern matching. In contrast, the management of aliases is built
into the applied pi calculus, facilitating the modeling of security protocol attackers as contexts.
7.2 Analysis of Security Protocols
The analysis of a security protocol generally requires reasoning about its possible executions.
However, the ways of talking about the executions and their properties vary greatly. We use a
process calculus whose semantics provides a detailed specification for interactions with a context.
Because the process calculus has a proper “new” construct (like the pi calculus but unlike CSP), it
provides a direct account of the generation of new keys and other fresh quantities. It also enables
reasoning with equivalence and implementation relations.
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.
1:34 M. Abadi et al.
Reasoning with those relations is often more challenging than reasoning about trace properties,
but it can be worthwhile. Equivalences are useful, in particular, for modeling privacy properties
(Pfitzmann and Köhntopp 2001), for instance, in electronic voting (Delaune et al. 2009). While
proofs of equivalences are difficult to automate in general—and observational equivalence is undecidable as noted in Section 4.1—several tools support certain automatic proofs of equivalences in
the applied pi calculus and similar languages: tools have focused on establishing particular kinds
of equivalences such as trace equivalence for bounded processes (i.e., processes without replication) (Chadha et al. 2012; Cheval et al. 2013; Tiu and Dawson 2010) or for restricted classes of
unbounded processes (Chrétien et al. 2015a, 2015b). Although ProVerif initially focused on proofs
of trace properties (Blanchet 2009), it also supports automatic proofs of diff-equivalences, which
are equivalences between processes that share the same structure and differ only in the choice of
terms (Blanchet et al. 2008). A diff-equivalence between two processes requires that the two processes reduce in the same way, in the presence of any adversary. In particular, the two processes
must have the same branching behaviour. Hence, diff-equivalence is much stronger than observational equivalence. Maude-NPA (Santiago et al. 2014) and Tamarin (Basin et al. 2015) also employ
that notion. Baudet (2005, 2007) showed that diff-equivalence is decidable for bounded processes:
he treated a class of equivalences that model security against offline guessing attacks in Baudet
(2005) and proved the full result in Baudet (2007).
Furthermore, the use of a process calculus permits treating security protocols as programs written in a programming notation—subject to typing (Abadi 1999; Cardelli 2000; Gordon and Jeffrey
2004), to other static analyses (Bodei et al. 1998), and to translations (Abadi 1998; Abadi et al. 1998,
2000). Thus, language-based approaches have led to tools such as ProVerif where protocols can be
described by programs and analyzed using automated techniques that leverage type systems and
Horn clauses (Abadi and Blanchet 2005a).
The applied pi calculus is also convenient as an intermediate language. Translations to ProVerif
have been implemented from TulaFale (a language for standardized web services protocols)
(Bhargavan et al. 2003), from F# (Bhargavan et al. 2008b), and from JavaScript in order to verify
protocols, including TLS (Bhargavan et al. 2008a).
As in many other works (e.g., Abadi and Gordon (1999), Amadio and Lugiez (2000), Armando
et al. (2005), Cremers (2008), Dam (1998), DeMillo et al. (1982), Dolev and Yao (1983), Escobar et al.
(2006), Kemmerer et al. (1994), Lowe (1996), Merritt (1983), Mitchell et al. (1997), Paulson (1998),
Schmidt et al. (2012), Schneider (1996), and Thayer Fábrega et al. (1998)), our use of the applied
pi calculus conveniently avoids matters of computational complexity and probability. In contrast,
other techniques for the analysis of security protocols employ more concrete computational models, where principals are basically Turing machines that manipulate bitstrings, and security depends on the computational limitations of attackers (e.g., Bellare and Rogaway (1993), Goldwasser
and Bellare (1999), Goldwasser and Micali (1984), Goldwasser et al. (1988), and Yao (1982)).
Although these two approaches remained rather distinct during the 1980s and 1990s, fruitful
connections have now been established (e.g., Abadi et al. (2009), Abadi and Rogaway (2002), Backes
et al. (2009), Barthe et al. (2010), Blanchet (2006), Blanchet and Pointcheval (2006), Comon-Lundh
and Cortier (2008), Datta et al. (2005), Lincoln et al. (1998), and Pfitzmann et al. (2000)). In particular, some work interprets symbolic proofs in terms of concrete, bitstring-based models (Abadi and
Rogaway 2002), in some cases specifically studying the “computational soundness” of the applied
pi calculus (Backes et al. 2009; Baudet et al. 2009b; Comon-Lundh and Cortier 2008). Other work
focuses directly on those concrete models but benefits from notations and ideas from process calculi and programming languages. For example, the tool CryptoVerif (Blanchet 2006; Blanchet and
Pointcheval 2006) provides guarantees in terms of bitstrings, running times, and probabilities, but
Journal of the ACM, Vol. 65, No. 1, Article 1. Publication date: October 2017.
The Applied Pi Calculus: Mobile Values, New Names, and Secure Communication 1:35
its input language is strongly reminiscent of the applied pi calculus, which influenced it—rather
than of Turing machines.
8 CONCLUSION
In this article, we describe a uniform extension of the pi calculus, the applied pi calculus, in which
messages may be compound values, not just channel names. We study its theory, developing its
semantics and proof techniques. Although the calculus has no special, built-in features to deal with
security, it has proved useful in the analysis of security protocols.
Famously, the pi calculus is the language of those lively social occasions where all conversations
are exchanges of names. The applied pi calculus opens the possibility of more substantial, structured conversations; the cryptic character of some of these conversations can only add to their
charm and to their tedium.
The previous paragraph closed the conference paper that introduced the applied pi calculus in
2001. We are now in a better position to assess the possibility to which it refers. As we hoped
in 2001, the applied pi calculus has been extensively used for modeling and for reasoning about
security protocols, particularly ones that rely heavily on cryptography (and less for ones that rely
on simple capabilities). The flexibility of the applied pi calculus is a key enabler for those applications. This flexibility did not render unnecessary or uninteresting the exploration of variants and
extensions. However, it did allow the applied pi calculus to remain a relevant core system—it was
not displaced by an extended language with many more constructs.
We are also in a better position to comment on matters of charm and tedium, alas. It is debatable
whether security protocols have become more charming or more tedious since 2001. It is clear,
however, that they play an ever-growing role, and that their security remains problematic. The
evolution of TLS exemplifies these points. The literature now contains many attacks on TLS (e.g.,
Adrian et al. (2015), Aviram et al. (2016), Bhargavan et al. (2014a), and Vanhoef and Piessens (2015)),
but also several partial specifications and proofs (Cremers et al. 2016; Jager et al. 2012; Krawczyk
et al. 2013; Paterson et al. 2011), sometimes relying on the applied pi calculus (Bhargavan et al.
2017a, 2012), and sometimes with language-based methods of the kind that the applied pi calculus
started to explore (Bhargavan et al. 2014b, 2013). The state-of-the-art approaches (Bhargavan et al.
2017a, 2017b, 2014b, 2013; Jager et al. 2012; Krawczyk et al. 2013; Paterson et al. 2011) rely on
refined frameworks that consider matters of computational complexity and probability, which are
beyond the (explicit) scope of the applied pi calculus, as explained above. In such applications, tools
play a helpful role, often an essential one. Although they sometimes lead to important insights,
manual proofs—in particular, manual proofs of equivalences—can be rather painful and tedious.
(We may have suspected this fact in 2001; on the basis of our experience since then, we now
know it with certainty.) On the other hand, the relative ease of use of ProVerif has contributed
greatly to the spread of the applied pi calculus. The applied pi calculus has evolved through its
implementation in ProVerif, and as a result of its use in this context. That evolution is, in our
opinion, an improvement, so the present article, aims to reflect it.
Finally, independently of the merits and the future of the applied pi calculus, we believe that
languages, and in particular the formalization of attackers as contexts, should continue to play a
role in the analysis of security protocols. The alternatives (defining protocols as interacting Turing
machines?) are not easier. Describing protocols in a programming notation not only makes them
precise but also brings them into the realm where ideas and tools from programming can support
analysis.