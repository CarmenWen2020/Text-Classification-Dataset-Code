We propose a new algorithmic framework, called partial rejection sampling, to draw samples exactly from a
product distribution, conditioned on none of a number of bad events occurring. Our framework builds new
connections between the variable framework of the Lovász Local Lemma and some classical sampling algorithms such as the cycle-popping algorithm for rooted spanning trees. Among other applications, we discover
new algorithms to sample satisfying assignments of k-CNF formulas with bounded variable occurrences.
CCS Concepts: • Theory of computation → Generating random combinatorial structures; Random
walks and Markov chains;
Additional Key Words and Phrases: Exact sampling, Lovász Local Lemma, #SAT
1 INTRODUCTION
The Lovász Local Lemma (LLL) [9] is a classical gem in combinatorics that guarantees the existence
of a perfect object that avoids all events deemed to be “bad.” The original proof is non-constructive,
but there has been great progress in the algorithmic aspects of the local lemma. After a long line
of research [2, 3, 8, 30, 34, 37], the celebrated result by Moser and Tardos [31] gives efficient algorithms to find such a perfect object under conditions that match the LLL in the so-called variable
framework. However, it is natural to ask whether, under the same condition, we can also sample
a perfect object uniformly at random instead of merely finding one.
Roughly speaking, the resampling algorithm by Moser and Tardos [31] works as follows. We
initialize all variables randomly. If bad events occur, then we arbitrarily choose a bad event and
resample all the involved variables. Unfortunately, it is not hard to see that this algorithm can produce biased samples. This seems inevitable. As Bezáková et al. [4] showed, sampling can be N-hard
even under conditions that are stronger than those of the local lemma. On the one hand, the symmetric LLL only requires epΔ ≤ 1, where p is the probability of bad events and Δ is the maximum
degree of the dependency graph. On the other hand, translating the result of Bezáková et al. [4]
to this setting, one sees that as soon as pΔ2 ≥ C for some constant C, then even approximately
sampling perfect objects in the variable framework becomes NP-hard.
The starting point of our work is a new condition (see Condition 5) under which we show
that the output of the Moser-Tardos algorithm is in fact uniform (see Theorem 8). Intuitively, the
condition requires any two dependent bad events to be disjoint. Indeed, instances satisfying this
condition are called extremal in the study of the LLL. For these extremal instances, we can in
fact resample in a parallel fashion, since the occurring bad events form an independent set in the
dependency graph. We call this algorithm partial rejection sampling,
1 in the sense that it is like
rejection sampling but only resamples an appropriate subset of variables.
Our result puts some classical sampling algorithms under a unified framework, including the
cycle-popping algorithm by Wilson [39] for sampling rooted spanning trees, and the sink-popping
algorithm by Cohn et al. [7] for sampling sink-free orientations of an undirected graph. Indeed,
Cohn et al. [7] coined the term partial rejection sampling and asked for a general theory, and we
believe that extremal instances under the variable framework is a satisfactory answer. With our
techniques, we are able to give a new algorithm to sample solutions for a special class of k-CNF
formulas, under conditions matching the LLL (see Corollary 19), which is an NP-hard task for
general k-CNF formulas. Furthermore, we provide explicit formulas for the expected running time
of these algorithms (see Theorem 13), which matches the running time upper bound given by
Kolipaka and Szegedy [26] under the condition of Shearer [35].
The next natural question is thus whether we can go beyond extremal instances. Indeed, our
main technical contribution is a general uniform sampler (see Algorithm 6) that applies to any
problem under the variable framework. The main idea is that instead of only resampling occurring
bad events, we resample a larger set of events so that the choices made do not block any perfect
assignments in the end to make sure of uniformity in the final output.
As a simple example, we describe how our algorithm samples independent sets. The algorithm
starts by choosing each vertex with probability 1/2 independently. At each subsequent round,
in the induced subgraph on the currently chosen vertices, the algorithm finds all the connected
components of size ≥2. Then it resamples all of these vertices and their boundaries (which are
unoccupied). And it repeats this process until there is no edge with both endpoints occupied.
What seems surprising is that this simple process does yield a uniformly random independent set
when it stops. Indeed, as we will show in Theorem 35, this simple process is an exact sampler for
weighted independent sets (also known as the hard-core model in statistical physics). In addition, it
runs in expected linear time under a condition that matches, up to a constant factor, the uniqueness
threshold of the model (beyond which the problem of approximate sampling becomes NP-hard).
In the more general setting, we will choose the set of events to be resampled, denoted by Res,
iteratively. We start from the set of occurring bad events. Then we include all neighboring events
of the current set Res until there is no event A on the boundary of Res such that the current
assignment, projected on the common variables of A and Res, can be extended so that A may
happen. In the worst case, we will resample all events (there is no event in the boundary at all). In
that scenario, the algorithm is the same as a naive rejection sampling, but typically we resample
1Despite the apparent similarity in names, our algorithm is different from partial resampling in Harris and Srinivasan [20,
21]. We resample all variables in certain sets of events, whereas partial resampling only resamples a subset of variables
from some bad event.
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.
Uniform Sampling Through the Lovász Local Lemma 18:3
fewer variables in every step. We show that this is a uniform sampler on assignments that avoid
all bad events once it stops (see Theorem 25).
One interesting feature of our algorithm is that unlike Markov chain–based algorithms, ours
does not require the solution space (or any augmented space) to be connected. Moreover, our
sampler is exact—that is, when the algorithm halts, the final distribution is precisely the desired
distribution. Prior to our work, most exact sampling algorithms were obtained by coupling from
the past [32]. We also note that previous work on the Moser-Tardos output distribution, such as
Haeupler et al. [19], is not strong enough to guarantee a uniform sample (or ε-close to uniform in
terms of total variation distances).
We give sufficient conditions that guarantee a linear expected running time of our algorithm
in the general setting (see Theorem 26). The first condition is that pΔ2 is bounded above by a
constant. This is optimal up to constants in observance of the NP-hardness result in Bezáková et al.
[4]. Unfortunately, the condition on pΔ2 alone does not make the algorithm efficient. In addition,
we also need to bound the expansion from bad events to resampling events, which leads to an
extra condition on intersections of bad events. Removing this extra condition seems to require
substantial changes to our current algorithm.
To illustrate the result, we apply our algorithm to sample satisfying assignments of k-CNF formulas in which the degree of each variable (the number of clauses containing it) is at most d. We
say that a k-CNF formula has intersection s if any two dependent clauses share at least s variables.
The extra condition from our analysis naturally leads to a lower bound on s. Let n be the number of
variables. We (informally) summarize our results on k-CNF formulas as follows (see Corollary 31
and Theorem 33):
• If d ≤ 1
6e · 2k/2, dk ≥ 23e and s ≥ min{log2 dk, k/2}, then the general partial rejection resampling algorithm outputs a uniformly random solution to a k-CNF formula with degree
d and intersection s in expected running time O(n).
• If d ≥ 4 · 2k/2 (for an even k), then even if s = k/2, it is NP-hard even to approximately
sample a solution to a k-CNF formula with degree d and intersection s.
As shown in the hardness result, the intersection bound does not render the problem trivial.
Previously, sampling/counting satisfying assignments of k-CNF formulas required the formula
to be monotone and d ≤ k to be large enough [4] (see also [5, 28]). Although our result requires an
additional lower bound on intersections, not only does it improve the dependency of k and d exponentially but it also achieves a matching constant 1/2 in the exponent. Furthermore, the samples
produced are exactly uniform. Thus, if the extra condition on intersections can be removed, we will
have a sharp phase transition at around d = O(2k/2) in the computational complexity of sampling
solutions to k-CNF formulas with bounded variable occurrences. A similar sharp transition has
been recently established, for example, for sampling configurations in the hard-core model [12,
36, 38].
Simultaneous to our work, Hermon et al. [24] showed that Markov chains for monotone k-CNF
formulas are rapidly mixing, if d ≤ c2k/2 for a constant c. In another parallel work, Moitra [29]
gave a novel algorithm to sample solutions for general k-CNF when d  2k/60. We note that neither results are directly comparable to ours, and the techniques are very different. Both of these
two samplers are approximate, whereas ours is exact. Moreover, ours does not require monotonicity (unlike Hermon et al. [24]) and allows larger d than Moitra [29] but at the cost of an extra
intersection lower bound. Unfortunately, our algorithm can be exponentially slow when the intersection s is not large enough. In sharp contrast, as shown by Hermon et al. [24], Markov chains
mix rapidly for d ≤ c2k /k2 when s = 1.
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019. 
18:4 H. Guo et al.
Although the study of algorithmic LLL has progressed beyond the variable framework [1, 22, 23],
we restrict our focus to the variable framework in this work. It is also an interesting future direction
to investigate and extend our techniques of uniform sampling beyond the variable framework.
For example, one may want to sample a permutation that avoids certain patterns. The classical
sampling problem of perfect matchings in a bipartite graph can be formulated in this way.
Since the conference version of this article appeared [18], a number of applications of the partial
rejection sampling method have been found [15–17]. One highlight is the first fully polynomialtime randomized approximation scheme (FPRAS) for all-terminal network reliability [17]. For the
extremal instances, tight running time bounds have also been obtained [14]. Moreover, partial
rejection sampling is adapted to dynamic and distributed settings as well [10].
2 PARTIAL REJECTION SAMPLING
We first describe the “variable” framework. Let {X1,...,Xn } be a set of random variables. Each Xi
can have its own distribution and range Di . Let {A1,...,Am } be a set of “bad” events that depend
on Xi ’s. For example, for a constraint satisfaction problem (CSP) with variables Xi (1 ≤ i ≤ n) and
constraints Cj (1 ≤ j ≤ m), each Aj is the set of unsatisfying assignments of Cj for 1 ≤ j ≤ m. Let
var(Ai ) be the (index) set of variables that Ai depends on.
The dependency graph G = (V, E) has m vertices, identified with the integers {1, 2,...,m}, corresponding to the events Ai , and (i, j) is an edge if Ai and Aj depend on one or more common
variables, and i  j. In other words, for any distinct i, j, (i, j) ∈ E if var(Ai ) ∩ var(Aj)  ∅. We write
Ai ∼ Aj if the vertices i and j are adjacent in G. The asymmetric LLL [9] states the following.
Theorem 1. If there exists a vector x ∈ [0, 1)
m such that ∀i ∈ [m],
Pr(Ai ) ≤ xi

(i,j)∈E
(1 − xj), (1)
then Pr(
m
i=1 Ai ) ≥ m
i=1 (1 − xi ) > 0.
Theorem 1 has a condition that is easy to verify but not necessarily optimal. Shearer [35] gave
the optimal condition for the local lemma to hold for a fixed dependency graphG. To state Shearer’s
condition, we will need the following definitions. Let pi := Pr(Ai ) for all 1 ≤ i ≤ m. Let I be the
collection of independent sets of G. Define the following quantity:
qI (p) :=

J ∈I, I ⊆J
(−1)|J |−|I |

i ∈J
pi,
where p = (p1,...,pm ). When there is no confusion, we also simply write qI instead of the more
cumbersome qI (p). Moreover, to simplify the notation, let qi := q{i } for 1 ≤ i ≤ m. Note that if
I  I, qI = 0.
Theorem 2 (Shearer [35]). If qI ≥ 0 for all I ⊆ V , then Pr(
m
i=1 Ai ) ≥ q∅.
In particular, if the condition holds with q∅ > 0, then Pr(
m
i=1 Ai ) > 0.
Neither Theorem 1 nor Theorem 2 yields an efficient algorithm to find the assignment avoiding
all bad events, since they only guarantee an exponentially small probability. There has been a long
line of research devoted to an algorithmic version of the LLL, culminating in Moser and Tardos
[31] with essentially the same condition as in Theorem 1. The Resample algorithm of Moser and
Tardos is very simple, described in Algorithm 1.
Moser and Tardos [31] showed that Algorithm 1 finds a good assignment very efficiently.
Theorem 3 (Moser and Tardos [31]). Under the condition of Theorem 1, the expected number
of resampling steps in Algorithm 1 is at most m
i=1
xi
1−xi
.
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.        
Uniform Sampling Through the Lovász Local Lemma 18:5
ALGORITHM 1: The Resample Algorithm
(1) Draw independent samples of all variables X1,...,Xn from their respective distributions.
(2) While at least one Ai holds, pick one such Ai arbitrarily and resample all variables
in var(Ai ).
(3) Output the current assignment.
Unfortunately, the final output of Algorithm 1 is not distributed as we would like, namely as a
product distribution conditioned on avoiding all bad events.
In addition, Kolipaka and Szegedy [26] showed that up to Shearer’s condition, Algorithm 1 is
efficient. Recall that qi := q{i } for 1 ≤ i ≤ m.
Theorem 4 (Kolipaka and Szegedy [26]). If qI ≥ 0 for all I ∈ I and q∅ > 0, then the expected
number of resampling steps in Algorithm 1 is at most m
i=1
qi
q∅
.
However, the cycle-popping algorithm of Wilson [39] is very similar to the Resample algorithm,
but it outputs a uniformly random rooted spanning tree. Another similar algorithm is the sinkpopping algorithm by Cohn et al. [7] to generate a sink-free orientation uniformly at random.
Upon close examination of these two algorithms, we found a common feature of both problems.
Condition 5. If (i, j) ∈ E (or equivalently Ai ∼ Aj), then Pr(Ai ∧ Aj) = 0; namely, the two events
Ai and Aj are disjoint if they are dependent.
In other words, any two events Ai and Aj are either independent or disjoint. These instances
have been noticed in the study of the LLL. They are the ones that minimize Pr(
m
i=1 Ai ) given
Shearer’s condition (namely, Pr(
m
i=1 Ai ) = q∅). Instances satisfying Condition 5 have been named
extremal [26].
We will show that, given Condition 5, the final output of the Resample algorithm is a sample
from a conditional product distribution (Theorem 8). Moreover, we will show that under Condition 5, the running time upper bound m
i=1
qi
q∅ given by Kolipaka and Szegedy (Theorem 4) is indeed
the exact expected running time. See Theorem 13.
In fact, when Condition 5 holds, at each step of Algorithm 1, the occurring events form an
independent set of the dependency graph G. Think of the execution of Algorithm 1 as going in
rounds. In each round, we find the set I of bad events that occur. Due to Condition 5, var(Ai ) ∩
var(Aj) = ∅ for any i, j ∈ I (i.e., I is an independent set in the dependency graph). Therefore, we can
resample all variables involved in the occurring bad events without interfering with each other.
This motivates Algorithm 2.
ALGORITHM 2: Partial Rejection Sampling for Extremal Instances
(1) Draw independent samples of all variables X1,...,Xn from their respective distributions.
(2) While at least one bad event holds, find the independent set I of occurring Ai ’s.
Independently resample all variables in 
i ∈I var(Ai ).
(3) Output the current assignment.
We call Algorithm 2 the Partial Rejection Sampling algorithm. This name was coined by
Cohn et al. [7]. Indeed, they ask as an open problem how to generalize their sink-popping
algorithm and Wilson’s cycle-popping algorithm. We answer this question under the variable
framework. Partial Rejection Sampling differs from the normal rejection sampling algorithm
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.  
18:6 H. Guo et al.
Table 1. A Resampling Table
With Four Variables
X1 X1,1 X1,2 X1,3 ...
X2 X2,1 X2,2 X2,3 ...
X3 X3,1 X3,2 X3,3 ...
X4 X4,1 X4,2 X4,3 ...
by only resampling “bad” events. Moreover, Algorithm 2 is uniform only on extremal instances and
is a special case of Algorithm 6 given in Section 5, which is a uniform sampler for all instances.
In fact, Algorithm 2 is the same as the parallel version of Algorithm 1 by Moser and Tardos [31]
for extremal instances. Suppose each event is assigned to a processor, which determines whether
the event holds by looking at the variables associated with the event. If the event holds, then all
associated variables are resampled. No conflict will be created due to Condition 5.
In the following analysis, we will use the resampling table idea, which has appeared in both the
analysis of Moser and Tardos [31] and Wilson [39]. Note that we only use this idea to analyze the
algorithm rather than to really create the table in the execution. Associate each variable Xi with
an infinite stack of random values {Xi,1,Xi,2,...}. This forms the resampling table where each row
represents a variable and there are infinitely many columns, as shown in Table 1. In the execution
of the algorithm, when a variable needs to be resampled, the algorithm draws the top value from
the stack or equivalently moves from the current entry in the resampling table to its right.
Let t be a positive integer to denote the round of Algorithm 2. Let ji,t be the index of the variable
Xi in the resampling table at round t. In other words, at the t-th round, Xi takes value Xi,ji, t .
Thus, the set σt = {Xi,ji, t | 1 ≤ i ≤ n} is the current assignment of variables at round t. This σt
determines which events happen. Call the set of occurring events, viewed as a subset of the vertex
set of the dependency graph, It . (For convenience, we shall sometimes identify the event Ai with
its index i; thus, we shall refer to the “events in S” rather than the “events indexed by S.”) As
explained earlier, It is an independent set of G due to Condition 5. Then variables involved in any
of the events in It are resampled. In other words,
ji,t+1 =

ji,t + 1 if ∃ ∈ It such that i ∈ var(A );
ji,t otherwise.
Therefore, any event that happens in round t + 1 must share at least one variable with some event
in It (possibly itself). In other words, It+1 ⊆ Γ+(It ), where Γ+(·) denotes the set of all neighbors
of I unioned with I itself. This inspires the notion of independent set sequences (first introduced
in Kolipaka and Szegedy [26]).
Definition 6. A list S = S1, S2,..., S of independent sets in G is called an independent set sequence if Si  ∅ for all 1 ≤ i ≤  − 1 and for every 1 ≤ i ≤  − 1, Si+1 ⊆ Γ+(Si ).
We adopt the convention that the empty list is an independent set sequence with  = 0. Note
that we allow S to be ∅.
Let M be a resampling table. Suppose running Algorithm 2 on M does not terminate up to some
integer  ≥ 1 rounds. Define the log of running Algorithm 2 on M up to round  as the sequence of
independent sets I1, I2,..., I created by this run. Thus, for any M and  ≥ 1, the log I1, I2,..., I
must be an independent set sequence. Moreover, if Algorithm 2 terminates at roundT , let σt := σT
if t > T . Denote by μ(·) the product distribution of all random variables.
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.             
Uniform Sampling Through the Lovász Local Lemma 18:7
Lemma 7. Suppose Condition 5 holds. Given any log S = S1, S2,..., S of length  ≥ 1 and conditioned on seeing the log S, σ+1 is a random sample from the product distribution conditioned on the
event
i ∈[m]\Γ+(S ) Ai , namely from μ(· |
i ∈[m]\Γ+(S ) Ai ).
We remark that Lemma 7 is not true for non-extremal instances (i.e., if Condition 5 fails). In
particular, Lemma 7 says that given any log, every valid assignment is not only reachable but also
with the correct probability. This is no longer the case for non-extremal instances—some valid
assignments from the desired conditional product distribution could be “blocked” under the log
S. In Section 5, we show how to instead achieve uniformity by resampling an “unblocking” set of
bad events.
Proof. The set of occurring events at round  is S. Hence, σ+1 does not make any of the
Ai ’s happen where i  Γ+(S ). Call an assignment σ valid if none of the Ai ’s happen where i
Γ+(S ). To show that σ+1 has the desired conditional product distribution, we will show that the
probabilities of getting any two valid assignments σ and σ  are proportional to their probabilities
of occurrence in μ(·).
Let M be the resampling table so that the log of the algorithm is S up to round  ≥ 1, and
σ+1 = σ. Indeed, since we only care about events up to round  + 1, we may truncate the table so
that M = {Xi,j | 1 ≤ i ≤ n, 1 ≤ j ≤ ji, +1}. Let M = {X
i,j | 1 ≤ i ≤ n, 1 ≤ j ≤ ji, +1} be another
table where X
i,j = Xi,j if j < ji, +1 for any i ∈ [n] but σ+1 = σ 
. In other words, we only change
the values in the final round (Xi,ji, +1 ) and only to another valid assignment.
We claim that the algorithm running on M generates the same log S. The lemma then follows
by the following argument. Assuming that the claim holds, then conditioned on the log S, every possible table M such that σ+1 = σ is one to one corresponding to another table M so that
σ+1 = σ 
. It implies that for every pair of valid assignments σ, σ 
, there is a bijection between the
resampling tables resulting in them. The ratio between the probability of two corresponding tables
is exactly the ratio between the probabilities of σ and σ  under μ(·). Since the probability of getting
a particular σ in round  + 1 is the sum over the probabilities of all resampling tables (conditioned
on the log S) leading to σ, the probability of getting σ is also proportional to its weight under μ(·).
Suppose the claim fails and the logs obtained by running the algorithm on M and M differ. Let
t0 ≤  be the first round where resampling changes. Without loss of generality, let A be an event
that occurs in St0 on M but not on M. Moreover, there must be a non-empty set of variables Y ⊆
var(A) that have values (Xi,ji, +1 ), as otherwise the two runs would be identical. Since resampling
history does not change before t0, in the M run, the assignment of variables in Y must be (X
i,ji, +1
)
at time t0.
We claim that Y = var(A). If the claim does not hold, then Z := var(A) \ Y  ∅. Any variable in
Z has not reached final round and must be resampled in the M run. Let Xj ∈ Z be the first such
variable being resampled at or after round t0 in the M run. (The choice ofXj may not be unique, and
we just choose an arbitrary one.) Recall that Y  ∅, A can no longer happen, and thus there must
be A  A causing such a resampling of Xj . Then var(A) ∩ var(A
)  ∅. Consider any variable Xk
with k ∈ var(A) ∩ var(A
). It is resampled at or after time t0 in the M run due to A
. Hence, Xk ∈ Z
for any such k. Moreover, in the M run, until A happens, Xk has not been resampled since time t0,
because A is the first resampling event at or after time t0 that involves variables in Z. However, in
the M run,Xk ’s value causesA to happen at time t0. Hence, there exists an assignment on variables
in var(A) ∩ var(A
) such that both A and A happen. Clearly, this assignment can be extended to a
full assignment so that both A and A happen. However, A ∼ A as they share the variable Xj . Due
to Condition 5, A ∩ A = ∅. Contradiction! Therefore, the claim holds.
We argue that the remaining case, Y = var(A), is also not possible. Since A occurs in the M run,
we know, by the definition of σ 
, that A ∈ Γ+(S ). Thus, some event whose variables intersect with
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.                                  
18:8 H. Guo et al.
those in A must occur in the M run. But when the algorithm attempts to update variables shared
by these two events in the M run, it will access values beyond the final round of the resampling
table, a contradiction.
Theorem 8. When Condition 5 holds and Algorithm 2 halts, its output is the product distribution
μ(·) conditioned on avoiding all bad events.
Proof. Let an independent set sequence S of length  be the log of any successful run. Then
S = ∅. By Lemma 7, conditioned on the log S, the output assignment σ is μ(· |
i ∈[m]\Γ+(S ) Ai ) =
μ(· |
i ∈[m] Ai ). This is valid for any possible log, and the theorem follows.
In other words, let Σ be the set of assignments that avoid all bad events. Let U be the output
of Algorithm 2. In the case that all variables are sampled from the uniform distribution, we have
Pr(U = σ ) = 1
|Σ|
, for all σ ∈ Σ.
3 EXPECTED RUNNING TIME OF ALGORITHM 2
In this section, we give an explicit formula for the running time of Algorithm 2. We assume that
Condition 5 holds throughout the section.
We first give a combinatorial explanation of qI for any independent set I of the dependency
graph G. To simplify the notation, we denote the event
i ∈S Ai—for instance, the conjunction of
all events in S, by A(S).
For any set I in the dependency graph, we denote by pI the probability Prμ (A(I)) that all events
in I happen (and possibly some other events too). If I is an independent set in the dependency
graph, any two events in I are independent and
pI =

i ∈I
pi . (2)
Moreover, for any set J of events that is not an independent set, we have pJ = 0 due to Condition 5.
However, the quantity qI is in fact the probability that exactly the events in I happen and no
others do. This can be verified using inclusion-exclusion, together with Condition 5:
Prμ



	
i ∈I
Ai ∧
	
iI
Ai



=

J ⊇I
(−1)|J \I |
pJ
=

J ∈I, J ⊇I
(−1)|J \I |
pJ = qI , (3)
where I denotes the collection of all independent sets of G. Since the events (

i ∈I Ai ∧
iI Ai )
are mutually exclusive for different I’s,

I ∈I
qI = 1.
Moreover, since the event A(I) is the union over J ⊇ I of the events (

i ∈J Ai ∧
iJ Ai ), we have
pI =

J ∈I, J ⊇I
qJ . (4)
Lemma 9. Assume that Condition 5 holds. Let S = S1,..., S be an independent set sequence of
length  > 0. Then in Algorithm 2,
Pr(the log is S up to round ) = qS

−1
t=1
pSt .
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.                        
Uniform Sampling Through the Lovász Local Lemma 18:9
Proof. Clearly, if qS = 0, then the said sequence will never happen. We assume that qS > 0
in the following.
Recall that μ is the product distribution of sampling all variables independently. We need to
distinguish the probability space with respect to μ from that with respect to the execution of the
algorithm. We write PrPRS (·) to refer to the algorithm and write Prμ (·) to refer to the (static) space
with respect to μ. As noted before, to simplify the notation, we will use A(S) to denote the event

i ∈S Ai , where S ⊆ [m]. In addition, B(S) will be used to denote
i ∈S Ai . For I ∈ I, define
∂I := Γ+(I) \ I, I
e := [m] \ Γ+(I), and I
c := [m] \ I = ∂I ∪ I
e .
Thus, ∂I is the “boundary” of I, comprising events that are not in I but which depend on I, and
I e is the “exterior” of I, comprising events that are independent of all events in I. The complement I c is simply the set of all events not in I. Note that B(I c ) = B(∂I) ∧ B(I e ). As examples of
the notation, Prμ (A(I)) = i ∈I pi = pI is the probability that all events in I occur under μ, and
Prμ (A(I) ∧ B(I c )) = qI is the probability that exactly the events in I occur.
By the definition of I e , we have that
Prμ (B(I
e ) | A(I)) = Prμ (B(I
e )) (5)
and, by Condition 5, that
A(I) ∧ B(∂I) = A(I). (6)
Hence, for any I ∈ I,
qI = Prμ (A(I) ∧ B(I
c ))
= Prμ (A(I) ∧ B(∂I) ∧ B(I
e ))
= Prμ (A(I) ∧ B(I
e )) by (6)
= Prμ (A(I)) Prμ (B(I
e )). by (5) (7)
We prove the lemma by induction. It clearly holds when  = 1. At round  ≥ 2, since we only
resample variables that are involved in S−1, we have that S ⊆ Γ+(S−1). Moreover, variables are
not resampled in any Ai where i ∈ Se
−1, and hence
B


Sc


∧ B


Se
−1

= B


Sc


. (8)
Conditioned on S−1, by Lemma 7, the distribution of σ at round  is the product distribution
conditioned on none of the events outside of Γ+(S−1) occurring; namely, it is Prμ (· | B(Se
−1)).
Thus, the probability of getting S in round  is
PrPRS 

A(S ) ∧ B(Sc
 ) holds in round  

 prior log is S1,..., S−1

= Prμ


A(S ) ∧ B(Sc
 ) | B(Se
−1)

= Prμ


A(S ) ∧ B(Sc
 ) ∧ B(Se
−1)

Prμ (B(Se
−1))
= Prμ


A(S ) ∧ B(Sc
 )

Prμ (B(Se
−1)) by (8)
= qS
Prμ (B(Se
−1)) . (9)
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.                                    
18:10 H. Guo et al.
By (9) and the induction hypothesis, we have
PrPRS (the log is S up to round ) = qS
Prμ (B(Se
−1)) · qS−1

−2
t=1
pSt
= qS

−1
t=1
pSt ,
where to get the last line we used (7) on S−1.
Essentially, the preceding proof is a delayed revelation argument. At each round 1 ≤ t ≤  − 1,
we only reveal variables that are involved in St . Thus, at round , we have revealed all variables
that are involved in S. With respect to these variables, the sequence S happens with probability
pS. Condition 5 guarantees that what we have revealed so far does not interfere with the final
output (cf. Lemma 7). Hence, the final state happens with probability qS .
We write pS = 
i=1 pSi for an independent set sequence S of length  ≥ 0. Note the convention
that pS = 1 if S is empty and  = 0. Then, Lemma 9 implies the following equality, which is first
shown by Kolipaka and Szegedy [26] in the more general (not necessarily extremal) setting of the
local lemma.
Corollary 10. Assume that Condition 5 holds. If q∅ > 0, then

S s.t. S1=I
pSq∅ = qI ,
where S is an independent set sequence and I is an independent set of G.
Proof. First we claim that if q∅ > 0, then Algorithm 2 halts with probability 1. Conditioned
on any log S = S1,..., S−1, by Lemma 7, the distribution of σ at round  is μ(· | B(Se
−1)). The
probability of getting a desired assignment is thus μ(B([m]) | B(Se
−1)) = μ (B([m]))
μ (B(S e
−1 )) ≥ μ(B([m])) =
q∅. Hence, the probability that the algorithm does not halt at time t is at most (1 − q∅)
t , which goes
to 0 as t goes to infinity.
Then we apply Lemma 9 when ∅ is the final independent set. The left-hand side is the total
probability of all possible halting logs whose first independent set is exactly I. This is equivalent
to getting exactly I in the first step, which happens with probability qI .
As a sanity check, the probability of all possible logs should sum to 1 when q∅ > 0 and the
algorithm halts with probability 1. Indeed, by Corollary 10, 
S
pSq∅ =

I ∈I

S s.t. S1=I
pSq∅ =

I ∈I
qI = 1,
where S is an independent set sequence. In other words,

S
pS = 1
q∅
, (10)
where S is an independent set sequence. This fact is also observed by Knuth [25, Theorem F]
and Harvey and Vondrák [23, Corollary 5.28] in the more general settings. Our proof here gives a
combinatorial explanation of this equality.
Equation (10) holds whenever q∅ > 0. Recall that q∅ is the shorthand of q∅ (p), which is
q∅ (p) =

I ∈I
(−1)|I |

i ∈I
pi, (11)
where I is the collection of independent sets of the dependency graph G.
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.                         
Uniform Sampling Through the Lovász Local Lemma 18:11
Lemma 11. Assume that Condition 5 holds. If q∅ (p) > 0, then q∅ (p1,...,piz,...,pm ) > 0 for any
i ∈ [m] and 0 ≤ z ≤ 1.
Proof. By (11),
q∅ (p1,...,piz,...,pm ) =

I ∈I, iI
(−1)|I |

j ∈I
pj + z

I ∈I, i ∈I
(−1)|I |

j ∈I
pj .
Notice that 
I ∈I, i ∈I (−1)|I | j ∈I pj = −qi (p) < 0 (qi (p) is the probability of exactly event Ai occurring). Hence, q∅ (p1,...,piz,...,pm ) ≥ q∅ (p) > 0.
LetTi be the number of resamplings of event Ai andT be the total number of resampling events.
Then T = m
i=1 Ti .
Lemma 12. Assume that Condition 5 holds. If q∅ (p) > 0, then ETi = q∅ (p)( 1
q∅ (p1,...,pi z,...,pm ) )
|z=1.
Proof. By Lemma 11, Equation (10) holds with pi replaced by piz where z ∈ [0, 1]. For a given
independent set sequence S, let Ti (S) be the total number of occurrences of Ai in S. Then we
have that

S
pSzTi (S) = 1
q∅ (p1,...,piz,...,pm )
. (12)
Take derivative with respect to z of (12):

S
Ti (S)pSzTi (S)−1 =
 1
q∅ (p1,...,piz,...,pm )

.
Evaluate the preceding equation at z = 1:

S
Ti (S)pS =
 1
q∅ (p1,...,piz,...,pm )
 



z=1
. (13)
However, we have that
ETi =

S
PrPRS (the log is S)Ti (S)
=

S
pSq∅ (p)Ti (S) (by Lemma 9)
= q∅ (p)
 1
q∅ (p1,...,piz,...,pm )
 



z=1
. (by (13))
This completes the proof.
Theorem 13. Assume that Condition 5 holds. If q∅ > 0, then ET = m
i=1
qi
q∅
.
Proof. Clearly, ET = m
i=1 ETi . By Lemma 12, all we need to show is that
q∅ (p)
 1
q∅ (p1,...,piz,...,pm )
 



z=1
= qi (p)
q∅ (p)
. (14)
This is because
q
∅ (p1,...,piz,...,pm ) =

i ∈J, J ∈I
(−1)|J |

j ∈J
pj
= −qi (p),
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.      
18:12 H. Guo et al.
and thus
 1
q∅ (p1,...,piz,...,pm )

= −q
∅ (p1,...,piz,...,pm )
q∅ (p1,...,piz,...,pm )2
= qi (p)
q∅ (p1,...,piz,...,pm )2 .
It is easy to see that (14) follows as we set z = 1 and the theorem is shown.
The quantity m
i=1
qi
q∅ is not always easy to bound. Kolipaka and Szegedy [26] have shown that
when the probability vector p satisfies Shearer’s condition with a constant “slack,” the running
time is in fact linear in the number of events in the more general setting. We rewrite it in our
notations.
Theorem 14 ([26, Theorem 5]). Let d ≥ 2 be a positive integer and pc = (d−1)(d−1)
dd . Let p =
maxi ∈[m]{pi}. If G has maximum degree d and p < pc , then ET ≤ p
pc−p · m.
4 APPLICATIONS OF ALGORITHM 2
4.1 Sink-Free Orientations
The goal of this application is to sample a sink-free orientation. Given a graph G = (V, E), an
orientation of edges is a mapping σ so that σ (e) = (u,v) or (v,u) where e = (u,v) ∈ E. A sink
under orientation σ is a vertex v so that for any adjacent edge e = (u,v), σ (e) = (u,v). A sink-free
orientation is an orientation so that no vertex is a sink.
Name Sampling Sink-Free Orientations
Instance A graph G.
Output A uniform sink-free orientation.
The first algorithm for this problem is given by Bubley and Dyer [6], using Markov chains and
path coupling techniques.
In this application, we associate with each edge a random variable, whose possible values are
(u,v) or (v,u). For each vertex v, we associate it with a bad event Av , which happens when v is
a sink. Thus, the graph G itself is also the dependency graph. Condition 5 is satisfied, because if a
vertex is a sink, then none of its neighbors can be a sink. Thus, we may apply Algorithm 2, which
yields Algorithm 3. This is the sink-popping algorithm given by Cohn et al. [7].
ALGORITHM 3: Sample Sink-Free Orientations
(1) Orient each edge independently and uniformly at random.
(2) While there is at least one sink, reorient all edges that are adjacent to a sink.
(3) Output the current assignment.
Let Zsink,0 be the number of sink-free orientations, and let Zsink,1 be the number of orientations
having exactly one sink. Then Theorem 13 specializes into the following.
Theorem 15. The expected number of resampled sinks in Algorithm 3 is Zsink,1
Zsink,0
.
It is easy to see that a graph has a sink-free orientation if and only if the graph is not a tree. The
next theorem gives an explicit bound on Zsink,1
Zsink,0 when sink-free orientations exist.
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019. 
Uniform Sampling Through the Lovász Local Lemma 18:13
Theorem 16. Let G be a connected graph on n vertices. If G is not a tree, then Zsink,1
Zsink,0 ≤ n(n − 1),
where n = |V (G)|.
Proof. Consider an orientation of the edges of G with a unique sink at vertex v. We give a systematic procedure for transforming this orientation to a sink-free orientation. SinceG is connected
and not a tree, there exists an (undirected) path Π in G of the form v = v0,v1,...,v−1,v = vk ,
where the vertices v0,v1,...,v−1 are all distinct and 0 ≤ k ≤  − 2. In other words, Π is a simple path of length  − 1 followed by a single edge back to some previously visited vertex. We will
choose a canonical path of this form (depending only on G and not on the current orientation) for
each start vertex v.
We now proceed as follows. Since v is a sink, the first edge on Π is directed (v1,v0). Reverse the
orientation of this edge so that it is now oriented (v0,v1). This operation destroys the sink atv = v0
but may create a new sink at v1. If v1 is not a sink, then halt. Otherwise, reverse the orientation of
the second edge of Π from (v2,v1) to (v1,v2). Continue in this fashion: if we reach vi and it is not a
sink, then halt; otherwise, reverse the orientation of the (i + 1)th edge from (vi+1,vi ) to (vi,vi+1).
This procedure must terminate with a sink-free graph before we reach v. To see this, note that
if we reach the vertex v−1, then the final edge of Π must be oriented (v−1,v ); otherwise, the
procedure would have terminated already at vertex vk (= v ).
The effect of the preceding procedure is to reverse the orientation of edges on some initial
segment v0,...,vi of Π. To put the procedure into reverse, we just need to know the identity of
the vertex vi . So our procedure associates at most n orientations having a single sink at vertex v
with each sink-free orientation. There are n(n − 1) choices for the pair (v,vi ), and hence n(n − 1)
single-sink orientations associated with each sink-free orientation. This establishes the result.
Remark. The bound in Theorem 16 is optimal up to a factor of 2. Consider a cycle of length n.
Then there are two sink-free orientations and n(n − 1) single-sink orientations.
Theorem 16 and Theorem 15 together yield an n2 bound on the expected number of resamplings
that occur during a run of Algorithm 3. A cycle of length n is an interesting special case. Consider
the number of clockwise-oriented edges during a run of the algorithm. It is easy to check that this
number evolves as an unbiased lazy simple random walk on [0,n]. Since the walk starts close to
n/2 with high probability, we know that it will take Ω(n2) steps to reach one of the sink-free states
(i.e., 0 or n).
However, if G is a regular graph of degree Δ ≥ 3, then we get a much better linear bound
from Theorem 14. In the case Δ = 3, we have pc = 4/27, p = 1/8, and p/(pc − p) = 27/5. Thus,
the expected number of resamplings is bounded by 27n/5. The constant in the bound improves as
Δ increases. Conversely, since the expected running time is exact, we can also apply Theorem 14
to give an upper bound of Zsink,1
Zsink,0 when G is a regular graph.
4.2 Rooted Spanning Trees
Given a graph G = (V, E) with a special vertex r, we want to sample a uniform spanning tree with
r as the root.
Name Sampling Rooted Spanning Trees
Instance A graph G with a vertex r.
Output A uniform spanning tree rooted at r.
Of course, any given spanning tree may be rooted at any vertex r, so there is no real difference
between rooted and unrooted spanning trees. However, since this approach to sampling generates
an oriented tree, it is easier to think of the trees as being rooted at a particular vertex r.
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.           
18:14 H. Guo et al.
For all vertices other than r, we randomly assign it to point to one of its neighbors. This is the
random variable associated with v. We will think of this random variable as an arrow v → s(v)
pointing from v to its successor s(v). The arrows point out an oriented subgraph of G with n − 1
edges {{v,s(v)} : v ∈ V \ {r}} directed as specified by the arrows. The constraint for this subgraph
to be a tree rooted at r is that it contains no directed cycles. Note that there are 2|E |−|V |+κ(G)
(undirected) cycles in G, where κ(G) is the number of connected components of G. Hence, we
have possibly exponentially many constraints.
Two cycles are dependent if they share at least one vertex. We claim that Condition 5 is satisfied.
Suppose a cycleC is present, andC  C is another cycle that shares at least one vertex withC. IfC
is also present, then we may start from any vertex v ∈ C ∩C
, and then follow the arrows v → v
.
Since both C and C are present, it must be that v ∈ C ∩C as well. Continuing this argument, we
see that C = C
. Contradiction!
As Condition 5 is met, we may apply Algorithm 2, yielding Algorithm 4. This is exactly the
cycle-popping algorithm by Wilson [39], as described in Propp and Wilson [33].
ALGORITHM 4: Sample Rooted Spanning Trees
(1) Let T be an empty set. For each vertex v  r, randomly choose a neighbor u ∈ Γ(v) and add
an edge (v,u) to T .
(2) While there is at least one cycle in T , remove all edges in all cycles, and for all vertices whose
edges are removed, redo step (1).
(3) Output the current set of edges.
Let Ztree,0 be the number of possible assignments of arrows to the vertices of G, which yield a
(directed) tree with rootr, and Ztree,1 be the number of assignments that yield a unicyclic subgraph.
The next theorem gives an explicit bound on Ztree,1
Ztree,0
.
Theorem 17. Suppose G is a connected graph on n vertices, with m edges. Then Ztree,1
Ztree,0 ≤ mn.
Proof. Consider an assignment of arrows to the vertices of G that forms a unicyclic graph.
This unicyclic subgraph has two components: a directed tree with root r and a directed cycle with
a number of directed subtrees rooted on the cycle. This is because if we remove the unicyclic
component, the rest of the graph has one less edge than vertices and no cycles, which must be a
spanning tree.
As G is connected, there must be an edge in G joining the two components; let this edge be
{v0,v1}, where v0 is in the tree component and v1 in the unicyclic component. Now extend this
edge to a path v0,v1,...,v, by following arrows until we reach the cycle. Thus, v1 → v2, v2 →
v3, ..., v−1 → v are all arrows, and v is the first vertex that lies on the cycle. (It may happen
that  = 1.) Letv → v+1 be the arrow out ofv. Now reassign the arrows from verticesv1,...,v;
thus, v → v−1, ...,v2 → v1, v1 → v0. Notice that the result is a directed tree rooted at r.
As before, we would like to bound the number of unicyclic subgraphs associated with a given
tree by this procedure. We claim that the procedure can be reversed given just two pieces of information, namely the edge {v,v+1} and the vertex v0. Note that even though the edge {v,v+1} is
undirected, we can disambiguate the endpoints, as v is the vertex closer to the rootr. The vertices
v−1,...,v1 are easy to recover, as they are the vertices on the unique path in the tree fromv tov0.
To recover the unicyclic subgraph, we just need to reassign the arrows for vertices v1,...,v as
follows: v1 → v2, ..., v → v+1.
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.                       
Uniform Sampling Through the Lovász Local Lemma 18:15
As the procedure can be reversed knowing one edge and one vertex, the number of unicyclic
graphs associated with each tree can be at most mn.
Theorem 17 combined with Theorem 13 yields an mn upper bound on the expected number of
“popped cycles” during a run of Algorithm 4.
However, take a cycle of length n. There are n spanning trees with a particular root v, and there
are Ω(n3) unicyclic graphs (here a cycle has to be of length 2). Thus, the ratio is Ω(n2) = Ω(mn)
since m = n, matching the bound of Theorem 17. Moreover, it is known that the cycle-popping
algorithm may take Ω(n3) time, such as on a dumbbell graph [33].
4.3 Extremal CNF Formulas
A classical setting in the study of algorithmic LLL is to find satisfying assignments in k-CNF formulas,2 when the number of appearances of every variable is bounded by d. Theorem 1 guarantees
the existence of a satisfying assignment as long as d ≤ 2k
ek + 1. However, sampling is apparently
harder than searching in this setting. As shown in Bezáková et al. [4, Corollary 30], it is NP-hard
to approximately sample satisfying assignments when d ≥ 5 · 2k/2, even restricted to the special
case of monotone formulas.
Meanwhile, sink-free orientations can be recast in terms of CNF formulas. Every vertex in the
graph is mapped to a clause, and every edge is a variable. Thus, every variable appears exactly
twice, and we require that the two literals of the same variable are always opposite. Interpreting
an orientation from u to v as making the literal in the clause corresponding to v false, the “sinkfree” requirement is thus “not all literals in a clause are false.” Hence, a sink-free orientation is just
a satisfying assignment for the corresponding CNF formula.
To apply Algorithm 2, we need to require that the CNF formula satisfies Condition 5. Such
formulas are defined as follows.
Definition 18. We call a CNF formula extremal if for every two clauses Ci and Cj , if there is a
common variable shared by Ci and Cj , then there exists some variable x such that x appears in
both Ci and Cj and the two literals are one positive and one negative.
Let C1,...,Cm be the clauses of a formula φ. Then define the bad event Ai as the set of unsatisfying assignments of clauseCi . For an extremal CNF formula, these bad events satisfy Condition 5.
This is because if Ai ∼ Aj , then by Definition 18, there exists a variable x ∈ var(Ai ) ∩ var(Aj) such
that the unsatisfying assignment of Ci and Cj differ on x. Hence, Ai ∩ Aj = ∅.
In this formulation, if the size ofCi is k, then the corresponding event Ai happens with probability pi = Pr(Ai ) = 2−k , where variables are sampled uniformly and independently.3 Suppose each
variable appears at most d times. Then the maximum degree in the dependency graph is at most
Δ = (d − 1)k. Note that in Theorem 14, pc = (Δ−1)(Δ−1)
ΔΔ ≥ 1
eΔ . Thus, if d ≤ 2k
ek + 1, thenpi = 2−k < pc
and we may apply Theorem 14 to obtain a polynomial time sampling algorithm.
Corollary 19. For extremal k-CNF formulas where each variable appears in at most d clauses,
if d ≤ 2k
ek + 1, then Algorithm 2 samples satisfying assignments uniformly at random, with O(m)
expected resamplings where m is the number of clauses.
The condition in Corollary 19 essentially matches the condition of Theorem 1. However, if we
only require Shearer’s condition as in Theorem 2, Algorithm 2 is not necessarily efficient. More
2As usual, in the study of the LLL, by “k-CNF” we mean that every clause has exactly size k. 3We note that to find a satisfying assignment, it is sometimes beneficial to consider non-uniform distributions. See Gebauer
et al. [13].
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019. 
18:16 H. Guo et al.
precisely, let ZCNF,0 be the number of satisfying assignments and ZCNF,1 be the number of assignments satisfying all but one clause. If we only require Shearer’s condition in Theorem 2, then the
expected number of resamplings ZCNF,1
ZCNF,0 can be exponential, as shown in the next example.
Example 20. Construct an extremal CNF formula φ = C1 ∧C2 ∧ ... ∧C4m as follows. Let C1 :=
x1. Then the variable x1 is pinned to 1 to satisfy C1. Let C2 := x1 ∨y1 ∨y2, C3 := x1 ∨y1 ∨y2, and
C4 := x1 ∨y1 ∨y2. Then y1 and y2 are also pinned to 1 to satisfy all C1 − C4.
We continue this construction by letting
C4k+1 := y2k−1 ∨y2k ∨ xk+1,
C4k+2 := xk+1 ∨y2k+1 ∨y2k+2,
C4k+3 := xk+1 ∨y2k+1 ∨y2k+2,
C4k+4 := xk+1 ∨y2k+1 ∨y2k+2,
for all 1 ≤ k ≤ m − 1. It is easy to see by induction that to satisfy all of them, all xi ’s andyi ’s have to
be 1. Moreover, one can verify that this is indeed an extremal formula. Thus, ZCNF,0 = 1. Moreover,
since φ has a satisfying assignment and is extremal, Shearer’s condition is satisfied. Note also that
φ is not a 3-CNF formula because C1 contains a single variable.
However, if we are allowed to ignore C1, then x1 can be 0. In that case, there are three choices
of y1 and y2 so that x2 to be 0 as well. Thus, there are at least 3m assignments that only violate C1,
where x1 = x2 = ··· = xm = 0. It implies that ZCNF,1 ≥ 3m. Hence, we see that ZCNF,1
ZCNF,0 ≥ 3m. Due to
Theorem 13, the expected running time of Algorithm 2 on this formula φ is exponential in m.
We will discuss more on sampling satisfying assignments of a k-CNF formula in Section 7.1.
5 GENERAL PARTIAL REJECTION SAMPLING
In this section, we give a general version of Algorithm 2 that can be applied to arbitrary instances
in the variable framework, even without Condition 5.
Recall the notation introduced at the beginning of Section 2. Thus, {X1,...,Xn } is a set of random variables, each with its own distribution and range Di , and {A1,...,Am } is a set of bad
events that depend on Xi ’s. The dependencies between events are encoded in the dependency
graph G = (V, E). As before, we will use the idea of a resampling table. Recall that σ = σt =
{Xi,ji, t | 1 ≤ i ≤ n} denotes the current assignment of variables at round t (i.e., the elements of
the resampling table that are active at time t). Given σ, let Bad(σ ) be the set of occurring bad
events; that is, Bad(σ ) = {i | σ ∈ Ai}. For a subset S ⊂ V , let ∂S be the boundary of S; that is,
∂S = {i | i  S and ∃j ∈ S, (i, j) ∈ E}. Moreover, let
var(S) :=

i ∈S
var(Ai ).
Let σ |S be the partial assignment of σ restricted to var(S). For an event Ai and S ⊆ V , we write
Ai ⊥ σ |S if either var(Ai ) ∩ var(S) = ∅ or there is no way to extend the partial assignment σ |S to
all variables so that Ai holds. Otherwise, Ai ⊥ σ |S .
Definition 21. A set S ⊆ V is unblocking under σ if for every i ∈ ∂S, Ai ⊥ σ |S .
Given σ, our goal is to resample a set of events that is unblocking and contains Bad(σ ). Such
a set must exist because V is unblocking (∂V is empty) and Bad(σ ) ⊆ V . However, we want to
resample as few events as possible.
Intuitively, we start by setting the resampling set R0 as the set of bad events Bad(σ ). We mark
resampling events in rounds, similar to a breadth-first search. Let Rt be the resampling set of round
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019. 
Uniform Sampling Through the Lovász Local Lemma 18:17
ALGORITHM 5: Select the Resampling Set Res(σ ) Under an Assignment σ
R ← Bad(σ ) ; // R is the set of events that will be resampled.
N ← ∅ ; // N is the set of events that will not be resampled.
U ← ∂R \ N;
while U  ∅ do
for i ∈ U do
if Ai ⊥ σ |R then
R ← R ∪ {i};
else
N ← N ∪ {i};
end
end
U ← ∂R \ N;
end
return R
t ≥ 0. In round t + 1, let Ai be an event on the boundary of Rt that has not been marked yet. We
mark it “resampling” if the partial assignments on the shared variables ofAi and Rt can be extended
so that Ai occurs. Otherwise, we mark it “not resampling.” We continue this process until there is
no unmarked event left on the boundary of the current R. An event outside of Γ+(R) may be left
unmarked at the end of Algorithm 5. Note that once we mark some event “not resampling,” it will
never be added into the resampling set. This is because R is only grow in size during the algorithm.
In Algorithm 5, we are dynamically updating R during each iteration of going through U . This
is potentially beneficial as an event Ai may become incompatible with R after some event Aj is
added, where both i, j ∈ U .
We fix a priori an arbitrary ordering while choosing i ∈ U in the “for” loop of Algorithm 5. Then
the output of Algorithm 5 is deterministic under σ. Call it Res(σ ).
Lemma 22. Let σ be an assignment. For any i ∈ ∂Res(σ ), Ai ⊥ σ |Res(σ ).
Proof. Since i ∈ ∂Res(σ ), it must have been marked. Moreover, i  Res(σ ), so it must be
marked as “not resampling.” Thus, there exists an intermediate set R ⊆ Res(σ ) during the execution of Algorithm 5 such that Ai ⊥ σ |R and i ∈ ∂R. It implies that Ai is disjoint from the partial
assignment of σ restricted to var(Ai ) ∩ var(R). However,
var(Ai ) ∩ var(R) ⊆ var(Ai ) ∩ var(Res(σ ))
as R ⊆ Res(σ ). We have that Ai ⊥ σ |Res(σ ).
If Condition 5 is met, then Res(σ ) = Bad(σ ). This is because at the first step, R = Bad(σ ). By
Condition 5, for any i ∈ ∂Bad(σ ), Ai is disjoint from all Aj ’s where j ∈ Bad(σ ) and Ai ∼ Aj . Since
Aj occurs under σ, Ai ⊥ σ |R. Algorithm 5 halts in the first iteration. In this case, since the resampling set is just the (independent) set of occurring bad events, the later Algorithm 6 coincides with
Algorithm 2.
The key property of Res(σ ) is that if we change the assignment outside of Res(σ ), then Res(σ )
does not change, unless the new assignment introduces a new bad event outside of Res(σ ). More
formally, we have the following lemma.
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.   
18:18 H. Guo et al.
Lemma 23. Let σ be an assignment. Let σ  be another assignment such that Bad(σ 
) ⊆ Res(σ )
and such that σ and σ  agree on all variables in var(Res(σ )) = 
i ∈Res(σ ) var(Ai ). Then, Res(σ 
) =
Res(σ ).
Proof. Let Rt (σ ), Nt (σ ) be the intermediate sets R, N, respectively, at time t of the execution of Algorithm 5 under σ. Thus, R0 (σ ) = Bad(σ ) and R0 (σ ) ⊆ R1 (σ ) ⊆ ··· ⊆ Res(σ ). Moreover,
N0 (σ ) ⊆ N1 (σ ) ⊆ ··· . We will show by induction that Rt (σ ) = Rt (σ 
) and Nt (σ ) = Nt (σ 
) for any
t ≥ 0.
For the base case of t = 0, by the condition of the lemma, for every i ∈ Bad(σ ) ⊆ Res(σ ), the assignments σ and σ  agree on var(Ai ), or equivalently σ |Res(σ ) = σ 
|Res(σ ). Together with Bad(σ 
) ⊆
Res(σ ), it implies that Bad(σ ) = Bad(σ 
) and R0 (σ ) = R0 (σ 
). Moreover, N0 (σ ) = N0 (σ 
) = ∅.
For the induction step t > 0, we have that Rt−1 (σ ) = Rt−1 (σ 
) ⊆ Res(σ ) and Nt−1 (σ ) = Nt−1 (σ 
).
Let R = Rt−1 (σ ) = Rt−1 (σ 
) and N = Nt−1 (σ ) = Nt−1 (σ 
). Then we will go through U = ∂R \ N,
which is the same for both σ and σ 
. Moreover, while marking individual events “resampling” or
not, it is sufficient to look at only σ |R = σ 
|R since R ⊆ Res(σ ). Thus, the markings are exactly the
same, implying that Rt (σ ) = Rt (σ 
) ⊆ Res(σ ) and Nt (σ ) = Nt (σ 
).
ALGORITHM 6: General Partial Rejection Sampling
(1) Draw independent samples of all variables X1,...,Xn from their respective distributions.
(2) While at least one bad event occurs under the current assignment σ, use Algorithm 5
to find Res(σ ). Resample all variables in 
i ∈Res(σ ) var(Ai ).
(3) When none of the bad events holds, output the current assignment.
To prove the correctness of Algorithm 6, we will only use three properties of Res(σ ), which are
intuitively summarized as follows:
(1) Bad(σ ) ⊆ Res(σ ).
(2) For any i ∈ ∂Res(σ ), Ai is disjoint from the partial assignment of σ projected on var(Ai ) ∩
var(Res(σ )) (Lemma 22).
(3) If we fix the partial assignment of σ projected on var(Res(σ )), then the output of Algorithm 5 is fixed, unless there are new bad events occurring outside of Res(σ ) (Lemma 23).
Similarly to the analysis of Algorithm 2, we call S = S1,..., S the log if Si is the set of resampling events in step i of Algorithm 6. Note that for Algorithm 6, the log is not necessarily an independent set sequence. In addition, recall that σi is the assignment of variables in step i, and σt = σT
if T is when Algorithm 6 terminates and t > T . The following lemma is an analogue of Lemma 7.
Lemma 24. Given any log S of length  ≥ 1, σ+1 has the product distribution conditioned on none
of Ai ’s occurring where i  Γ+(S ), namely from μ(· |
i ∈[m]\Γ+(S ) Ai ).
Proof. Suppose i  Γ+(S ). By construction, S contains all occurring bad events of σ, and
hence Ai does not occur under σ. In step , we only resample variables that are involved in S, so
σ+1 and σ agree on var(Ai ). Hence,Ai cannot occur under σ+1. Call an assignment σ valid if none
of Ai occurs where i  Γ+(S ). To show that σ+1 has the desired conditional product distribution,
we will show that the probabilities of getting any two valid assignments σ and σ  are proportional
to their probabilities of occurrence under the product distribution μ(·).
Let M be the resampling table so that the log of Algorithm 6 is S up to round , and σ+1 = σ.
Indeed, since we only care about events up to round  + 1, we may truncate the table so that
M = {Xi,j | 1 ≤ i ≤ n, 1 ≤ j ≤ ji, +1}. Let M = {X
i,j | 1 ≤ i ≤ n, 1 ≤ j ≤ ji, +1} be another table
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.                          
Uniform Sampling Through the Lovász Local Lemma 18:19
whereX
i,j = Xi,j if j < ji, +1 for any i ∈ [n], and σ  = (X
i,ji, +1 : 1 ≤ i ≤ n) is a valid assignment. In
other words, we only change the last assignment (Xi,ji, +1 : 1 ≤ i ≤ n) to another valid assignment.
We will use σ 
t = (X
i,ji, t
) to denote the active elements of the second resampling table at time t;
thus, σ  = σ 
+1.
The lemma follows if Algorithm 6 running on M generates the same log S up to round , since,
if this is the case, then conditioned on the log S, every possible table M where σ+1 = σ is one-toone correspondence with another table M where σ 
+1 = σ 
. Hence, the probability of getting σ is
proportional to its weight under μ(·).
Suppose otherwise and the log of running Algorithm 6 on M and M differ. Let t0 ≤  be the
first round where resampling changes, by which we mean that Res(σt0 )  Res(σ 
t0 ). By Lemma 23,
either Bad(σ 
t0 )  Res(σt0 ) or σt0 |Res(σt0 )  σ 
t0 |Res(σt0 ). In the latter case, there must be a variable
Xi with i ∈ var(Res(σt0 )) and index ji, +1. However, i ∈ var(Res(σt0 )) means that Xi is resampled
at least once more in the original run on M, and its index goes up to at least ji, +1 + 1 at round
 + 1. A contradiction. Thus, σt0 |Res(σt0 ) = σ 
t0 |Res(σt0 ) and Bad(σ 
t0 )  Res(σt0 ).
As Bad(σ 
t0 )  Res(σt0 ), there must be a variable Xi0 such that ji0,t0 = ji0, +1 (otherwise,
Xi0,ji0, t0 = X
i0,ji0, t0
) and an event Ak such that i0 ∈ var(Ak ), k ∈ Bad(σ 
t0 ) but k  Res(σt0 ). Suppose first that ∀i ∈ var(Ak ), ji,t0 = ji, +1, which means that all variables of Ak have reached their
final values in the M run at time t0. This implies that k  Γ+(St ) for any t ≥ t0 as otherwise some of
the variables in var(Ak ) would be resampled at least once after round t0. In particular, k  Γ+(S ).
This contradicts with σ  being valid.
Otherwise, there are some variables in var(Ak ) that get resampled after time t0 in the M run.
Let t1 be the first such time and Y ⊂ var(Ak ) be the set of variables resampled at round t1, namely
Y = var(Ak ) ∩ var(Res(σt1 )). We have that σt1 |Y = σt0 |Y because t1 is the first time of resampling
variables in Y. Moreover, as variables of Y have not reached their final values yet in the M run,
σt0 |Y = σ 
t0 |Y . Thus, σt1 |Y = σ 
t0 |Y .
Assuming k ∈ Res(σt1 ) would contradict the fact that Xi0 has reached its final value in the
M run. Hence, k  Res(σt1 ), but nevertheless variables in Y ⊂ var(Ak ) are resampled. This implies that k ∈ ∂Res(σt1 ). By Lemma 22, Ak ⊥ σt1 |Res(σt1 ). As var(Ak ) cannot be disjoint from
var(Res(σt1 )), this means that Ak is incompatible with the partial assignment of σt1 restricted
to var(Ak ) ∩ var(Res(σt1 )) = Y. Equivalently, Ak ⊥ σt1 |Y . However, we know that σt1 |Y = σ 
t0 |Y , so
Ak ⊥ σ 
t0 |Y , contradicting k ∈ Bad(σ 
t0 ).
Theorem 25. If Algorithm 6 halts, then its output has the product distribution conditioned on none
of Ai ’s occurring.
Proof. Let a sequence S of sets of events be the log of any successful run. Then S = ∅. By
Lemma 24, conditioned on the log S, the output assignment σ is μ(· |
i ∈[m]\Γ+(S ) Ai ) = μ(· |

i ∈[m] Ai ). This is valid for any possible log, and the theorem follows.
6 RUNNING TIME ANALYSIS OF ALGORITHM 6
Obviously, when there is no assignment avoiding all bad events, then Algorithm 6 will never halt.
Thus, we want to assume some conditions to guarantee a desired assignment. However, the optimal
condition of Theorem 2 is quite difficult to work under. Instead, in this section, we will be working
under the assumption that the asymmetric LLL condition (1) holds. In fact, to make the presentation
clean, we will mostly work with the simpler symmetric case.
However, as mentioned in Section 4.3, Bezáková et al. [4, Corollary 30] showed that even under
the asymmetric LLL condition (1), sampling can still be NP-hard. We thus in turn look for further
conditions to make Algorithm 6 efficient.
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.                             
18:20 H. Guo et al.
Recall that μ(·) is the product distribution of sampling all variables independently. For two distinct events Ai ∼ Aj , let Rij be the event that the partial assignments on var(Ai ) ∩ var(Aj) can be
extended to an assignment making Aj true. Thus, if Ai ⊥ σ |S for some event set S, then Rji must
hold for all Aj ∈ S and Aj ∼ Ai . Conversely, it is possible that each individual Rji is true for all
Aj ∈ R and Aj ∼ Ai , and yet Ai ⊥ σ |S . Also note that Rij is not necessarily the same as Rji . Let
rij := μ(Rij).
Define p := maxi ∈[m] pi and r := maxAi∼Aj, ij rij . Let Δ be the maximum degree of the dependency graph G. The main result of the section is the following theorem.
Theorem 26. Let m be the number of events and n be the number of variables. For any Δ ≥ 2, if
6epΔ2 ≤ 1 and 3erΔ ≤ 1, then the expected number of resampled events of Algorithm 6 is O(m).
Moreover, when these conditions hold, the number of rounds isO(logm) and the number of variable
resamples is O(n logm), both in expectation and with high probability.
The first condition 6epΔ2 ≤ 1 is stronger than the condition of the symmetric LLL, but this seems
necessary since Bezáková et al. [4, Corollary 30] imply that if pΔ2 ≥ C for some constant C, then
the sampling problem is NP-hard. Intuitively, the second condition 3erΔ ≤ 1 bounds the expansion
from bad events to resampling events at every step of Algorithm 6. We will prove Theorem 26 in
the rest of the section.
Let S ⊆ [m] be a subset of vertices of the dependency graph G. Recall that A(S) is the event

i ∈S Ai and B(S) is the event
i ∈S Ai . Moreover, Sc is the complement of S, namely Sc = [m] \ S,
and Se is the “exterior” of S, namely Se = [m] \ Γ+(S).
Lemma 24 implies that if we resample S at some step t of Algorithm 6, then at step t + 1 the
distribution is the product measure μ conditioned on none of the events in the exterior of S holds,
namely Prμ (· | B(Se )).
Let E be an event (not necessarily one of Ai ) depending on a set var(E) of variables. Let
Γ(E) := {i | i ∈ [m], var(Ai ) ∩ var(E)  ∅} if E is not one of Ai , and Γ(Ai ) := {j | j ∈ [m], j
i and var(Aj) ∩ var(Ai )  ∅} is defined as usual. Let S ⊆ [m] be a subset of vertices of G. The next
lemma bounds the probability of E conditioned on none of the events in S happening. It was first
observed in Haeupler et al. [19]. We include a proof for completeness (which is a simple adaptation
of the ordinary local lemma proof).
Lemma 27 ([19, Theorem 2.1]). Suppose (1) holds. For an event E and any set S ⊆ [m],
Prμ (E | B(S)) ≤ Prμ (E)

i ∈Γ(E)∩S
(1 − xi )
−1
,
where xi ’s are from (1).
Proof. We prove the inequality by induction on the size of S. The base case is when S is empty
and the lemma holds trivially.
For the induction step, let S1 = S ∩ Γ(E) and S2 = S \ S1. If S1 = ∅, then the lemma holds trivially
as E is independent from S in this case. Otherwise, S2 is a proper subset of S. We have that
Prμ (E | B(S)) = Prμ (E ∧ B(S1) | B(S2))
Prμ (B(S1) | B(S2))
≤
Prμ (E | B(S2))
Prμ (B(S1) | B(S2))
= Prμ (E)
Prμ (B(S1) | B(S2)) ,
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.       
Uniform Sampling Through the Lovász Local Lemma 18:21
where the last line is because E is independent from B(S2). We then use the induction hypothesis
to bound the denominator. Suppose S1 = {j1, j2,..., jr } for some r > 0. Then,
Prμ (B(S1) | B(S2)) = Prμ



	
i ∈S1
Ai






	
i ∈S2
Ai



=
r
t=1
Prμ



Ajt






	t−1
s=1
Ajs ∧
	
i ∈S2
Ai



=
r
t=1



1 − Prμ



Ajt






	t−1
s=1
Ajs ∧
	
i ∈S2
Ai






.
By the induction hypothesis and (1), we have that for any 1 ≤ t ≤ r,
Prμ



Ajt






	t−1
s=1
Ajs ∧
	
i ∈S2
Ai



≤ Prμ (Ajt )

i ∈Γ(jt )
(1 − xi )
−1
≤ xjt

i ∈Γ(jt )
(1 − xi )

i ∈Γ(jt )
(1 − xi )
−1
= xjt .
Thus,
Prμ (B(S1) | B(S2)) ≥

i ∈S1
(1 − xi ) .
The lemma follows.
Typically, we set xi = 1
Δ+1 in the symmetric setting. Then (1) holds if ep(Δ + 1) ≤ 1. In this
setting, Lemma 27 is specialized into the following.
Corollary 28. If ep(Δ + 1) ≤ 1, then
Prμ (E | B(S)) ≤ Prμ (E)

1 +
1
Δ
|Γ(E)|
.
In particular, if ep(Δ + 1) ≤ 1, for any event Ai where i  S, by Corollary 28,
Prμ (Ai | B(S)) ≤ pi
Δ + 1
Δ
Δ
≤ ep. (15)
Let Rest be the resampling set of Algorithm 6 at round t ≥ 1, and let Badt be the set of bad
events present at round t. If Algorithm 6 has already stopped at round t, then Rest = Badt = ∅.
Furthermore, let Bad0 = Res0 = [m] since in the first step all random variables are fresh.
Let C := 1 − p.
Lemma 29. For any Δ ≥ 2, if 6epΔ2 ≤ 1 and 3erΔ ≤ 1, then
E (|Rest+1 | | Res0,..., Rest ) ≤ C |Rest | .
Proof. Clearly, for any Δ ≥ 2, the condition 6epΔ2 ≤ 1 implies that ep(Δ + 1) ≤ 1. Therefore,
the prerequisite of Corollary 28 is met. Notice that by Lemma 24, we have that
E (|Rest+1 | | Res0,..., Rest ) = E (|Rest+1 | | Rest ).
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.                  
18:22 H. Guo et al.
We will show in the following that
E(|Rest+1 ||the set of resampling events at round t is (exactly) Rest ) ≤ C|Rest |,
where C = 1 − p. This implies the lemma.
Call a path i0,i1,...,i where  ≥ 0 in the dependency graph G bad if the following holds:
(1) i0 ∈ Badt+1;
(2) the event Rik−1ik holds for every 1 ≤ k ≤ ;
(3) any ik (k ∈ []) is not adjacent to ik unless k = k − 1 or k + 1.
Indeed, paths having the third property are induced paths in G. If i ∈ Rest+1, Ai must be added by
Algorithm 5 during some iteration of the while loop. In the 0th iteration, all of Badt+1 are added.
We claim that for any i ∈ Rest+1 added in  ≥ 0 iteration by Algorithm 5, there exists at least one
bad path such that i0,i1,...,i = i. We show the claim by an induction on :
• The base case is that  = 0, and thus i ∈ Badt+1. The bad path is simply i itself.
• For the induction step  ≥ 1, due to Algorithm 5, there must existi−1 adjacent to i = i such
that i−1 has been marked “resampling” during iteration  − 1, and Ri−1i occurs. By the
induction hypothesis, there exists a bad path i0,...,i−1. Since i is not marked at iteration
 − 1, i is not adjacent to any vertices that has been marked up to iteration  − 2. Thus, i
is not adjacent to any ik where k ≤  − 2, and the path i0,...,i−1,i is bad.
We next turn to bounding the number of bad paths. It is straightforward to bound the size of
Badt+1 ⊆ Γ+(Rest ). If i ∈ Badt+1, then there are two possibilities. The first scenario is that i ∈
Rest and then all of its random variables are fresh. In this case, it occurs with probability pi ≤ p.
Otherwise, i ∈ ∂Rest . Recall that by Lemma 24, the distribution at round t + 1 is Prμ (· | B(Rese
t )).
By Corollary 28, for any i ∈ ∂Rest ,
Prμ


Ai | B


Rese
t
  ≤ p

1 +
1
Δ
Δ
≤ ep.
This implies that
E (|Badt+1 | | the set of resampling events at round t is (exactly) Rest )
≤ p |Rest | + ep |∂Rest | ≤ p(1 + eΔ) |Rest | . (16)
Next we bound the size of |Rest+1 \ Badt+1 |. Let P = i0,...,i be an induced path; that is, for
any k ∈ [], ik is not adjacent to ik unless k = k − 1 or k + 1. Only induced paths are potentially
bad. Moreover, P contributes to |Rest+1 \ Badt+1 | only if its length  ≥ 1. Let DP be the event that
P is bad. In other words, DP := Ai0 ∧ Ri0i1 ∧ ... ∧ Ri−1i . By Lemma 24, we have that
Pr(P is bad at round t + 1 | the set of resampling events at round t is Rest )
= Prμ (DP | B(Rese
t )), (17)
where we recall that we denote Rese
t = [m] \ Γ+(Rest ). Applying Corollary 28 with S = Rese
t , we
have that
Prμ (DP | B(Rese
t )) ≤ Prμ (DP )

1 +
1
Δ
|Γ(DP )|
. (18)
Note that Γ(Rik ik+1 ) ⊆ Γ+(Aik ) for all 0 ≤ k ≤  − 1. By the definition of DP ,
Γ(DP ) ⊆ Γ(Ai0 ) ∪ Γ(Ri0i1 ) ∪···∪ Γ(Ri−1i )
⊆ Γ+(Ai0 ) ∪ Γ+(Ai1 ) ∪···∪ Γ+(Ai−1 ),
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.                               
Uniform Sampling Through the Lovász Local Lemma 18:23
implying that
|Γ(DP )| ≤ (Δ + 1), (19)
as 
Γ+(Ak )
 ≤ Δ + 1 for all 0 ≤ k ≤  − 1.
We claim thatAi0 is independent from Rik−1ik for any 2 ≤ k ≤ . This is because ik is not adjacent
to i0 for any k ≥ 2, implying that
var(Rik−1ik ) ∩ var(Ai0 ) = var(Aik−1 ) ∩ var(Aik ) ∩ var(Ai0 )
⊆ var(Aik ) ∩ var(Ai0 ) = ∅.
Moreover, any two events Rik−1ik and Rik−1ik are independent of each other as long as k < k
. This
is also due to the third property of bad paths. Since k < k
, we see that |k − (k − 1)| ≥ 2 and ik is
not adjacent to ik−1. It implies that
var(Rik−1ik ) ∩ var(Rik−1ik ) = var(Aik−1 ) ∩ var(Aik ) ∩ var(Aik−1 ) ∩ var(Aik )
⊆ var(Aik−1 ) ∩ var(Aik ) = ∅.
The consequence of these independences is
Prμ (DP ) ≤ Prμ (Ai0 ∧ Ri1i2 ∧···∧ Ri−1i )
= Prμ (Ai0 )


k=2
Prμ (Rik−1ik )
≤ pr −1
. (20)
Note that in the preceding calculation, we ignore Ri0i1 because it can be positively correlated to
Ai0 .
Combining (17), (18), (19), and (20), we have that
Pr(DP | the set of resampling events at round t is (exactly) Rest )
≤ pr −1

1 +
1
Δ
 (Δ+1)
≤ p
r
 1 +
1
Δ

er
. (21)
To apply a union bound on all bad paths, we need to bound their number. The first vertex i0
must be in Badt+1, implying that i0 ∈ Γ+(Rest ). Hence, there are at most (Δ + 1) |Rest | choices.
Then there are at most Δ choices of i1 and (Δ − 1) choices of every subsequent ik where k ≥ 2.
Hence, there are at most Δ(Δ − 1)
−1 induced paths of length  ≥ 1, originating from a particular
i0 ∈ Γ+(Rest ). Thus, by a union bound on all potentially bad paths and (21),
E(|Rest+1 \ Badt+1 | |the set of resampling events at round t is (exactly) Rest )
≤
∞
=1
(Δ + 1) |Rest | Δ(Δ − 1)
−1
p/r
 1 +
1
Δ

er
= (Δ + 1)Δp
(Δ − 1)r |Rest |
∞
=1
 Δ2 − 1
Δ

er
≤ (Δ + 1)Δp
(Δ − 1)r |Rest |
∞
=1
(erΔ)
 = (Δ + 1)Δp
(Δ − 1)r · erΔ
1 − erΔ |Rest |
≤
Δ + 1
Δ − 1 ·
3
2 · epΔ2 |Rest | , (22)
where we use the condition that erΔ ≤ 1/3.
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.                    
18:24 H. Guo et al.
Combining (16) and (22), we have that
E (|Rest+1 | | the set of resampling events at round t is (exactly) Rest )
≤
Δ + 1
Δ − 1 ·
3
2 · epΔ2 |Rest | + p(1 + eΔ) |Rest |
= p
Δ + 1
Δ − 1 ·
3
2 · eΔ2 + (1 + eΔ)
|Rest | .
All that is left is to verify that
p
Δ + 1
Δ − 1 ·
3
2 · eΔ2 + (1 + eΔ)
≤ C,
where C = 1 − p. This is straightforward by the condition 6epΔ2 ≤ 1 and Δ ≥ 2, as
C − p
Δ + 1
Δ − 1 ·
3
2 · eΔ2 + (1 + eΔ)
≥ 6epΔ2 − p − p
Δ + 1
Δ − 1 ·
3
2 · eΔ2 + (1 + eΔ)
≥ p

6eΔ2 − 1 − Δ + 1
Δ − 1 ·
3
2 · eΔ2 − (1 + eΔ)
≥ 0.
For t ≥ 1, by Lemma 29 and the law of iterated expectations,
E |Rest | ≤ C E |Rt−1 | .
Thus, E |Rest | ≤ Ct |R0 | = Ct
m. As C < 1, the expected number of resampling events is
∞
t=0
E |Rest | ≤
∞
t=0
Ct
m = 1
1 − C · m.
This implies the first part of Theorem 26. For the second part, just observe that after O(logm)
rounds, the expected number of bad events is less than m−c for any constant c, and Markov inequality applies.
The first condition of Theorem 26 requires p to be roughly O(Δ−2). This is necessary, due to the
hardness result in Bezáková et al. [4] (see also Theorem 33). In addition, in the analysis, it is possible
to always add all of ∂Badt into Rest . Consider a monotone CNF formula. If a clause is unsatisfied,
then all of its neighbors need to be added into the resampling set. Such behaviors would eventually
lead to the O(Δ−2) bound. This situation is in contrast to the resampling algorithm of Moser and
Tardos [31], which only requires p = O(Δ−1) as in the symmetric LLL.
We also note that monotone CNF formulas, in which all correlations are positive, seem to be
the worst instances for our algorithms. In particular, Algorithm 6 is exponentially slow when the
underlying hypergraph of the monotone CNF is a (hyper-)tree. This indicates that our condition
on r in Theorem 26 is necessary for Algorithm 6. In contrast, Hermon et al. [24] show that on a
linear hypergraph (including the hypertree), the Markov chain mixes rapidly for degrees higher
than the general bound. It is unclear how to combine the advantages from these two approaches.
7 APPLICATIONS OF ALGORITHM 6
7.1 k-CNF Formulas
Consider a k-CNF formula where every variable appears in at most d clauses. Then Theorem 1
says that if d ≤ 2k /(ek) + 1, then there exists a satisfying assignment. However, as mentioned
in Section 4.3, Bezáková et al. [4, Corollary 30] showed that when d ≥ 5 · 2k/2, then sampling
satisfying assignments is NP-hard, even restricted to monotone formulas.
To apply Algorithm 6 in this setting, we need to bound the parameterr in Theorem 26. A natural
way is to lower bound the number of shared variables between any two dependent clauses. If this
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019. 
Uniform Sampling Through the Lovász Local Lemma 18:25
lower bound is s, then r = 2−s since there is a unique assignment on these s variables that can be
extended in such a way as to falsify the clauses.
Definition 30. Let d ≥ 2 and s ≥ 1. A k-CNF formula is said to have degree d if every variable
appears in at most d clauses. Moreover, it has intersection s if for any two clauses Ci and Cj that
share at least one variable, |var(Ci ) ∩ var(Cj)| ≥ s.
Note that by the definition, if k < s then the formula is simply isolated clauses. Otherwise, k ≥ s
and we have that pi = p = 2−k and r ≤ 2−s . A simple double counting argument indicates that the
maximum degree Δ in the dependency graph satisfies Δ ≤ dk
s .
We claim that for integers d and k such that d ≥ 3 and dk ≥ 23e , conditions d ≤ 2k/2
6e and s ≥
min{log2 dk, k/2} imply the conditions of Theorem 26, namely 6epΔ2 ≤ 1 and 3erΔ ≤ 1. In fact, if
s ≥ log2 dk ≥ log2 d, then
6epΔ2 ≤ 6e2−k

dk
s
2
≤ 6e2−k
 dk
log2 d
2
≤ 6e
 k
6e 
k/2 − log2 6e

2
< 1,
as d
log2 d is increasing for any d ≥ 3. Moreover,
3erΔ ≤
3edk
2s s ≤
3e
log2 (dk) ≤ 1.
Otherwise, k/2 ≤ s ≤ log2 dk, which implies that
6epΔ2 ≤ 6e2−k

dk
s
2
≤ 6e2−k

dk
k/2
2
≤ 6e2−k

2k/2
3e
2
< 1,
and
3erΔ ≤
3edk
2s s ≤
6edk
k2k/2 ≤ 1.
Thus, by Theorem 26, we have the following result. Note that resampling a clause involves at most
k variables, and for k-CNF formulas with degree d, the number of clauses is linear in the number
of variables.
Corollary 31. For integers d and k such that d ≥ 3 and dk ≥ 23e , if d ≤ 1
6e · 2k/2 and s ≥
min{log2 dk, k/2}, then Algorithm 6 samples satisfying assignments of k-CNF formulas with degree
d and intersection s in O(n) time in expectation and in O(n logn) time with high probability, where
n is the number of variables.
We remark that the lower bound on intersection size s in Corollary 31 does not make the problem trivial. Note that the lower bound min{log2 dk, k/2} is at most k/2. The “hard” instance in
the proof of Bezáková et al. [4, Corollary 30] has roughly k/2 shared variables for each pair of
dependent clauses. For completeness, we will show that if k is even, and d ≥ 4 · 2k/2 and s = k/2,
then the sampling problem is NP-hard. The proof is almost identical to that of Bezáková et al. [4,
Corollary 30]. The case of odd k can be similarly handled but with larger constants.
We will use the inapproximability result of Sly and Sun [36] (or equivalently, of Galanis et al.
[12]) for the hard-core model. We first remind the reader of the relevant definitions. Let λ > 0.
For a graph G = (V, E), the hard-core model with parameter λ > 0 is a probability distribution
over the set of independent sets of G; each independent set I of G has weight proportional to λ|I |
.
The normalizing factor of this distribution is the partition function ZG (λ), formally defined as
ZG (λ) := 
I λ|I | where the sum ranges over all independent sets I of G. The hardness result we
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.
18:26 H. Guo et al.
are going to use is about approximating ZG (λ), but it is standard to translate it into the sampling
setting as the problem is self-reducible.
Theorem 32 ([12, 36]). For d ≥ 3, let λc (d) := (d − 1)
d−1/(d − 2)
d . For all λ > λc (d), it is NP-hard
to sample an independent set I with probability proportional to λ|I | in a d-regular graph.
Theorem 33. Let k be an even integer. If d ≥ 4 · 2k/2 and s = k/2, then it is NP-hard to sample
satisfying assignments of k-CNF formulas with degree d and intersection s uniformly at random.
Proof. Given a d-regular graph G = (V, E), we will construct a monotone k-CNF formula C
with degree d and intersection k/2 such that satisfying assignments of C can be mapped to independent sets of G. Replace each vertex v ∈ V by s variables, say v1,...,vs . If (u,v) ∈ E, then
create a monotone clause v1 ∨···∨vs ∨u1 ∨···∨us . It is easy to see that every variable appears
exactly d times since G is d-regular. Moreover, the number of shared variables is alwayss, and the
clause size is 2s = k.
For each satisfying assignment, we map it to a subset of vertices ofG. If all ofv1,...,vs are false,
then make v occupied. Otherwise, v is unoccupied. Thus, a satisfying assignment is mapped to an
independent set of G. Moreover, there are (2k/2 − 1)
n−|I | satisfying assignments corresponding to
an independent set I, where n is the number of vertices in G. Thus, the weight of I is proportional
to (2k/2 − 1)
−|I |
, namely λ = (2k/2 − 1)
−1 in the hard-core model.
To apply Theorem 32, all we need to do is verify that λ > λc , or equivalently
2k/2 − 1 < (d − 2)
d
(d − 1)d−1 .
This can be done as follows:
(d − 2)
d
(d − 1)d−1 = (d − 2)

1 − 1
d − 1
d−1
≥

4
5
5
(d − 2) > 2k/2 − 1.
Due to Theorem 33, we see that the dependence between k and d in Corollary 31 is tight in the
exponent, even with the further assumption on intersection s.
7.2 Independent Sets
We may also apply Algorithm 6 to sample hard-core configurations with parameter λ. Every vertex
is associated with a random variable that is occupied with probability λ
1+λ . In this case, each edge
defines a bad event that holds if both endpoints are occupied. Thus, p = ( λ
1+λ )
2. Algorithm 6 is
specialized to Algorithm 7.
ALGORITHM 7: Sample Hard-Core Configurations
(1) Mark each vertex occupied with probability λ
1+λ independently.
(2) While there is at least one edge with both end points occupied, resample all occupied
components of sizes at least 2 and their boundaries.
(3) Output the set of vertices.
To see this, consider a graphG = (V, E) with maximum degree d. Given a configuration σ : V →
{0, 1}, consider the subgraph G[σ] of G induced by the vertex subset {v ∈ V : σ (v) = 1}. Then we
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019. 
Uniform Sampling Through the Lovász Local Lemma 18:27
denote by BadVtx(σ ) the set of vertices in any component of G[σ] of size at least 2. Then the
output of Algorithm 5 is
ResVtx(σ ) := BadVtx(σ ) ∪ ∂BadVtx(σ ).
This is because first, all of ∂BadVtx(σ ) will be resampled, since any of them has at least one occupied neighbor in BadVtx(σ ). Second, v ∈ ∂BadVtx(σ ) is unoccupied (otherwise, v ∈ BadVtx(σ )),
and Algorithm 5 stops after adding all of ∂BadVtx(σ ). This explains Algorithm 7.
Moreover, let Bad(σ ) be the set of edges whose both endpoints are occupied under σ. Let Res(σ )
be the set of edges whose both endpoints are in ResVtx(σ ). Let σt be the random configuration of
Algorithm 7 at round t if it has not halted, and Badt = Bad(σt ), Rest = Res(σt ).
Lemma 34. If ep(2d − 1) < 1, then E |Badt+1 | ≤ (4ed2 − 1)p E |Badt |.
Proof. First note that the dependency graph is the line graph of G and Δ = 2d − 2 is the maximum degree of the line graph ofG. Thus, ep(2d − 1) < 1 guarantees the prerequisite of Corollary 28
is met. It also implies that for any σ, |Res(σ )| ≤ (2d − 1)Bad(σ ), and ∂ |Res(σ )| ≤ (2d − 2) |Res(σ )|.
Similarly to the analysis in Lemma 29, conditioned on a fixed Badt , by Corollary 28 (or (15) in particular), we have that
E |Badt+1 | ≤ p |Res(σ )| + ep |∂Res(σ )|
≤ (p(2d − 1) + ep(2d − 2)(2d − 1)) |Badt |
< (4ed2 − 1)p |Badt | .
Since the preceding equality holds for any Badt , the lemma follows.
Lemma 34 implies that if 4epd2 ≤ 1, then the number of bad edges shrinks with a constant factor,
and Algorithm 7 resamplesO(m) edges in expectation andO(m logm) edges with high probability,
where m = |E|. A bounded degree graph is sparse and thus m = O(n), where n is the number of
vertices. Since p = ( λ
1+λ )
2, the condition 4epd2 ≤ 1 is equivalent to
λ ≤
1
2
√
ed − 1
.
Thus, we have the following theorem, where the constants are slightly better than directly applying
Theorem 26.
Theorem 35. If λ ≤ 1
2
√
ed−1 , then Algorithm 7 draws a uniform hard-core configuration with parameter λ from a graph with maximum degree d in O(n) time in expectation and in O(n logn) time
with high probability, where n is the number of vertices.
The optimal bound of sampling hard-core configurations is λ < λc ≈ e
d , where λc is defined
in Theorem 32. The algorithm is due to Weitz [38], and the hardness is shown in Galanis et al. [12]
and Sly and Sun [36]. The condition of our Theorem 35 is more restricted than correlation decay–
based algorithms [38] or traditional Markov chain–based algorithms. Nevertheless, our algorithm
matches the correct order of magnitude λ = O(d−1). Moreover, our algorithm has the advantage
of being simple, exact, and running in linear time in expectation.
8 DISTRIBUTED ALGORITHMS FOR SAMPLING
An interesting feature of Algorithm 6 is that it is distributed.4 For concreteness, consider the algorithm applied to sampling hard-core configurations on a graphG (i.e., Algorithm 7), assumed to be
4See Feng et al. [11] for a very recent work on distributed sampling algorithms. In particular, they show a similar lower
bound in their work [11, Section 5].
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019. 
18:28 H. Guo et al.
of bounded maximum degree. Imagine that each vertex is assigned a processor that has access to
a source of random bits. Communication is possible between adjacent processors and is assumed
to take constant time. This is essentially the LOCAL model of Linial [27]. Then, in each parallel
round of the algorithm, the processor at vertex v can update the value σ (v) in constant time, as
this requires access only to the values of σ (u) for vertices u ∈ V (G) within a bounded distance r
of v. In the case of the hard-core model, we have r = 2, since the value σ (v) at vertex v should be
updated precisely if there are vertices u and u such that v ∼ u and u ∼ u and σ (u) = σ (u
) = 1.
Note that we allow u = v here.
In certain applications, including the hard-core model, Algorithm 6 runs in a number of
rounds that is bounded by a logarithmic function of the input size with high probability. (Recall
Theorem 26.) We show that this is optimal. (Although the argument is presented in the context of
the hard-core model, it ought to generalize to many other applications.)
Set L = c logn for some constant c > 0 to be chosen later. The instance that establishes the
lower bound is a graph G consisting of a collection of n/L disjoint paths Π1,..., Πn/L with L vertices each. (Assume that n is an exact multiple of L; this is not a significant restriction.) The highlevel idea behind the lower bound is simple and consists of two observations. We assume first that
the distributed algorithm we are considering always produces an output, say σˆ : V (G) → {0, 1},
within t rounds. It will be easy at the end to extend the argument to the situation where the running time is a possibly unbounded random variable with bounded expectation.
Focus attention on a particular path Π with endpointsu andv. The first observation is that ifrt <
L/2, then σ (u) (respectively, σ (v)) depends only on the computations performed by processors in
the half of Π containing u (respectively, v). Therefore, in the algorithm’s output, σˆ (u) and σˆ (v) are
probabilistically independent. The second observation is that if the constantc is sufficiently small,
then in the hard-core distribution, σ (u) and σ (v) are significantly correlated. Since the algorithm
operates independently on each of the n/L paths, these small but significant correlations combine
to force to a large variation distance between the hard-core distribution and the output distribution
of the algorithm.
We now quantify the second observation. Let σ : V (G) → {0, 1} be a sample from the hardcore distribution on a path Π on k vertices with endpoints u and v, and let Ik = ZΠ(λ) denote
the corresponding hard-core partition function (weighted sum over independent sets). Define the
matrix Wk = (
w00 w01
w10 w11 ), where wij = Pr(σ (u) = i ∧ σ (v) = j). Then
Wk = 1
Ik

Ik−2 λIk−3
λIk−3 λ2Ik−4

,
since Ik is the total weight of independent sets in Π, Ik−2 is the total weight of independent sets
with σ (u) = σ (v) = 0, Ik−3 is the total weight of independent sets with σ (u) = 0 and σ (v) = 1, and
so on. Also note that Ik satisfies the recurrence
I0 = 1, I1 = λ + 1, and Ik = Ik−1 + λIk−2, for k ≥ 2. (23)
We will use detWk to measure the deviation of the distribution of (σ (u), σ (v)) from a product
distribution. Write
W 
k =

Ik−2 Ik−3
Ik−3 Ik−4

,
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.
Uniform Sampling Through the Lovász Local Lemma 18:29
and note that detWk = λ2I−2
k detW 
k . Applying recurrence (23) once to each of the four entries of
W 
k , we have
detW 
k = Ik−2Ik−4 − I
2
k−3
= (Ik−3 + λIk−4)(Ik−5 + λIk−6) − (Ik−4 + λIk−5)
2
= Ik−3 (Ik−5 + λIk−6) − Ik−4 (Ik−4 + λIk−5) + λ2 (Ik−4Ik−6 − I
2
k−5)
= Ik−3Ik−4 − Ik−4Ik−3 + λ2 detW 
k−2
= λ2 detW 
k−2,
for all k ≥ 6. By direct calculation, detW 
4 = −λ2 and detW 
5 = λ3. Hence, by induction, detW 
k =
(−1)
k−1λk−2, and
detWk = (−1)
k−1λk
I 2
k
, (24)
for all k ≥ 4.
Solving the recurrence (23) gives the following formula for Ik :
Ik = Aλ

1 + √
4λ + 1
2


k
+ Bλ

1 − √
4λ + 1
2


k
,
where
Aλ =

1
2
+
2λ + 1
2
√
4λ + 1

and Bλ =

1
2 − 2λ + 1
2
√
4λ + 1

.
Asymptotically,
Ik = (1 + o(1))Aλ

1 + √
4λ + 1
2


k
.
Substituting this estimate into (24) yields | detWk | = (1 + o(1))A−2
λ αk where
α = 2λ
2λ + √
4λ + 1 + 1
.
Note that 0 < α < 1 and α depends only on λ.
Now let the matrixW	k = (
w	00 w	01
w	10 w	11 ) be defined as forWk , but with respect to the output distribution of the distributed sampling algorithm rather than the true hard-core distribution. Recall that
we choose L = c logn > 2rt, which implies that σˆ (u) and σˆ (v) are independent and detW	L = 0.
It is easy to check that if W	k −Wk ∞ ≤ ε, where the matrix norm is entrywise, then | detWk | ≤ ε.
Thus, for c sufficiently small (and L = c logn), we can ensure that W	L −WL ∞ ≥ n−1/3. Thus,
|w	ij − wij | ≥ n−1/3, for some i, j; for definiteness, suppose i = j = 0 and that w	00 > w00.
Let Z (respectively, Z
	) be the number of paths whose endpoints are both assigned 0 in the hardcore distribution (respectively, the algorithm’s output distribution). Then Z (respectively, Z
	) is a
binomial random variable with expectation μ = w00n/L (respectively, μˆ = w	00n/L). Since | EZ −
EZ
	| > Ω(n2/3/ logn), a Chernoff bound gives that Pr(Z ≥ (μ + μˆ)/2) and Pr(Z
	 ≤ (μ + μˆ)/2) both
tend to zero exponentially fast with n. It follows that the variation distance between the distributions of σ and σˆ is 1 − o(1).
The preceding argument assumes an absolute bound on running time, whereas the running time
of an exact sampling algorithm will in general be a random variable T . To bridge the gap, suppose
Journal of the ACM, Vol. 66, No. 3, Article 18. Publication date: April 2019.   
18:30 H. Guo et al.
Pr(T ≤ t) ≥ 2
3 . Then
σˆ − σ TV = max
A
| Pr(σˆ ∈ A) − Pr(σ ∈ A)|
= max
A
|


Pr(σˆ ∈ A | T ≤ t) − Pr(σ ∈ A)

Pr(T ≤ t)
+ 

Pr(σˆ ∈ A | T > t) − Pr(σ ∈ A)

Pr(T > t)|
≥ 2
3 (1 − o(1)) − 1
3 × 1,
where ·TV denotes variation distance and A ranges over events A ⊆ {0, 1}|V (G)|
. Thus, σ −
σˆ TV ≥ 1
3 − o(1), which is a contradiction. It follows that Pr(T ≤ t) < 2
3 and hence E(T ) ≥ 1
3 t. Note
that this argument places a lower bound on parallel time not just for exact samplers but even for
(very) approximate ones.
With only a slight increase in work, one could take the instance G to be a path of length n,
which might be considered more natural. Identify O(n/L) subpaths within G, suitably spaced, and
of length L. The only complication is that the hard-core distribution does not have independent
marginals on distinct subpaths. However, by ensuring that the subpaths are separated by distance
nα , for some small α > 0, the correlations can be controlled, and the argument proceeds, with only
slight modification, as before.