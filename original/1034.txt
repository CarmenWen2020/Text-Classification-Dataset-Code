The cost of communication is a substantial factor affecting the scalability of many distributed applications.
Every message sent can incur a cost in storage, computation, energy, and bandwidth. Consequently, reducing
the communication costs of distributed applications is highly desirable. The best way to reduce message costs
is by communicating without sending any messages whatsoever. This article initiates a rigorous investigation
into the use of silence in synchronous settings, in which processes can fail. We formalize sufficient conditions
for information transfer using silence, as well as necessary conditions for particular cases of interest. This
allows us to identify message patterns that enable communication through silence. In particular, a pattern
called a silent choir is identified, and shown to be central to information transfer via silence in failure-prone
systems. The power of the new framework is demonstrated on the atomic commitment problem (AC). A complete characterization of the tradeoff between message complexity and round complexity in the synchronous
model with crash failures is provided, in terms of lower bounds and matching protocols. In particular, a new
message-optimal AC protocol is designed using silence, in which processes decide in three rounds in the
common case. This significantly improves on the best previously known message-optimal AC protocol, in
which decisions were performed in Θ(n) rounds.
And in the naked light I saw
Ten thousand people, maybe more
People talking without speaking
···
People writing songs that voices never share
And no one dared
Disturb the sound of silence
Paul Simon, 1964
CCS Concepts: • Theory of computation → Distributed computing models; Distributed algorithms;
• Computing methodologies → Reasoning about belief and knowledge; Distributed algorithms;
Multi-agent systems; • Networks→Network protocol design; •Information systems→Distributed database
transactions;
Additional Key Words and Phrases: Silent information exchange, null messages, silent choir, atomic commitment, consensus, optimality, fault-tolerance, knowledge
1 INTRODUCTION
The cost of communication is a substantial factor limiting the scalability of many distributed applications (see, e.g., References [21, 22, 26, 28, 30]). Indeed, sending a message imposes costs in
storage, computation, energy, and bandwidth. Consequently, reducing the communication costs
of distributed applications is highly desirable. The best way to reduce these costs is by communicating without sending any messages whatsoever. In reliable synchronous systems processes
can exchange information in silence, effectively “sending a message by not sending a message,” to
use a term from Reference [23]. In fault-prone systems, however, using silence in this way is considerably more subtle. Roughly speaking, in a reliable system in which messages from j to i are
guaranteed to be delivered within Δ time units, if j sends no message to i at time t, then i is able to
detect this fact at time t + Δ. This, in turn, can be used to pass information from j to i. In a setting
in which j may fail, however, it is possible for i not to receive j’s message because j failed in some
way.
Given the value of reducing communication costs and the power of silence to do so, efficient
protocols for a variety of tasks of interest make effective, albeit implicit, use of silence (see, e.g.,
References [1, 2, 4, 10, 16, 19, 27]). There is no clear theory underlying this use of silence, however.
This article initiates a rigorous investigation into the use of silence in synchronous settings in
which processes can fail. We formalize sufficient conditions for information transfer using silence,
as well as necessary conditions for particular cases of interest. This allows us to identify message
patterns that enable silent communication.
Using the proposed framework, we consider the atomic commitment problem (AC) in synchronous systems with crash failures [5, 13] as a case study. A silence-based analysis provides new
lower bounds on the efficiency of AC protocols that are optimal in the common case. The conditions identified for using silence are then used to provide protocols that match the lower bounds.
In some cases, the new protocols significantly improve the state-of-the-art.
The main contributions of this article are:
• Simple rules for silent information transfer in the presence of failures are provided and
formalized.
• The Silent Choir Theorem, which precisely captures the communication patterns required
for silence to convey information about the initial values, is proven. In failure-prone systems, a silent choir plays the role that null messages play in reliable systems, facilitating
communication via silence.
• Using a silence-based analysis, lower bounds are established on the number of messages
needed for AC protocols to decide at the end of D rounds in the common case, for any
given D ≥ 1.
• Silent information transfer rules are used to design protocols that prove these bounds to be
tight, thereby completely characterizing the tradeoff between the message complexity and
round complexity of AC. For the most interesting case of message-optimal AC, we present
the Stealth protocol, which reduces the decision times from Θ(n) to Θ(1) rounds (in fact,
from n + 2f to 3).
This article is organized as follows: The next section introduces our model of computation and
formal definitions of indistinguishability, knowledge, and AC. Section 3 formalizes how silence can
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.
Silence 3:3
be used to convey information in fault-prone synchronous message-passing systems. It defines the
notion of a silent choir and presents the Silent Choir Theorem. Lower bounds and upper bounds
for optimal AC in the common case are established in Section 4. An extended version of the Silent
Choir Theorem is presented in Section 5. Concluding remarks are discussed in Section 6.
2 DEFINITIONS AND PRELIMINARY RESULTS
2.1 Atomic Commitment
In the atomic commitment problem [5, 13, 16, 17], each process j starts out with a binary initial
value vj ∈ {0, 1}. Processes need to decide between two actions, commit or abort. All runs of an
AC protocol are required to satisfy the following conditions:
Atomic Commitment:
Decision: Every correct process must eventually decide either commit or abort,
Agreement: All processes that decide make the same decision,
Commit Validity: A process can decide commit only if all initial values are 1, and
Abort Validity: A process can decide abort only if some initial value is 0, or if some
process failed.
The AC problem is motivated by distributed databases, in which the processes are involved in performing a joint transaction. An initial value of 0 can correspond to a vote to abort the transaction,
while 1 is a vote to commit the transaction. Typically, processes enter the AC protocol with a vote
to commit, and failures in runs of AC are rare. We call a run in which all initial values are 1 and no
failures occur, a nice run. As first advocated by Reference [13], it is sensible to seek AC protocols
that are optimized for the common case, i.e., for their nice runs. Natural parameters to optimize
are the number of messages sent, and the number of rounds required for decision and for halting in nice runs. We call an AC protocol that sends the fewest possible messages in its nice run
message-optimal, and one that decides the soonest round optimal. In a recent paper [16], Guerraoui
and Wang present a message-optimal AC protocol. It uses n + f − 1 messages in the nice run (for
a system with n processes and up to f crash failures). But this message efficiency seems to come at
a cost in terms of decision time: In the nice run, processes decide only at the end of n + 2f rounds.
This raises the interesting open problem of identifying the tradeoff between message complexity
and decision time, for AC protocols in the common case.
2.2 Model of Computation
We consider the standard synchronous message-passing model with crash failures. We assume a
set P = {0, 1,...,n − 1} of n > 2 processes. Each pair of processes is connected by a two-way communication link, and for each message the receiver knows the identity of the sender. All processes
share a discrete global clock that starts at time 0 and advances by increments of one. At any given
timem ≥ 0, each process is in a well-defined local state. Once a process has crashed, its local state
becomes ⊥, and it remains ⊥ from then on. As long as it has not crashed, we assume for simplicity
that the local state of each process i at a given point consists of its initial value vi ∈ {0, 1}, the
current time m, and the finite sequence of actions that i has performed up to that time (including
the messages it has sent), as well as the messages that process i has received so far. In particular,
its local state at time 0 has the form (vi, 0, {}).
A protocol specifies what messages a process should send and what decisions it should take, as
a deterministic function of its local state. Communication in the system proceeds in a sequence of
rounds, with round m + 1 taking place between time m and time m + 1, for m ≥ 0. Messages are
delivered in the round in which they are sent. Thus, a message sent by a process i to j in round
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.
3:4 G. Goren and Y. Moses
m + 1 will reach j by time m + 1. (Note that the protocol determines at time m which messages
will be sent in round m + 1.) Processes may fail by crashing, which occurs in a particular round.
A process is said to be active at time m if it does not crash in any round k ≤ m. If a process i is
active at time m > 0, then at time m − 1 it correctly follows its protocol: It performs decisions (if
any) and sends messages, as determined by its protocol. A process that crashes in round m will
perform no actions at times m ≥ m. If a process i crashes in round m > 0, then at time m − 1 it
performs a (possibly strict) subset of the actions that its protocol specifies.
We will consider the design of protocols that are required to withstand up to f crashes. Thus,
given 1 ≤ f < n, we denote by γ f the model described above in which it is guaranteed that no
more than f processes fail in any given run. We assume that a protocol P has access to the values
of n and f , typically passed to P as parameters.
A run is a description of a (possibly infinite) execution of the system: For every process i ∈ P,
it records i’s local state at all times m ≥ 0 (the local state at time 0 contains i’s initial value vi ).
Moreover, if i decides in a given run r, then the run records the value that i decides on. We call a
set of runs R a system. We will be interested in systems of the form RP = R(P,γ f ) consisting of
all runs of a given protocol P in which no more than f processes fail. Observe that a protocol P
solves AC in the model γ f if and only if every run of RP satisfies the Decision, Agreement, and
two Validity conditions described above. Given a run r and a time m, we denote the local state
of process i at time m in run r by ri (m). Notice that a process i can be in the same local state in
different runs of the same protocol. Since the current timem is represented in the local state ri (m),
however, r(m) = r
(m
) can hold only if m = m
.
2.3 Indistinguishability and Knowledge
We will say that two runsr and r are indistinguishable to processi at time m if ri (m) = r
i (m). We
denote this by r ≈m
i r
. Notice that, since we assume that processes follow deterministic protocols,
if r ≈m
i r
, then process i performs the same actions at time m in both r and r if it does not fail.
Problem specifications typically impose restrictions on actions, based on properties of the run.
Moreover, since the actions that a process performs are a function of its local state, the restrictions
can depend on properties of other runs as well. For example, the Agreement condition in AC
implies that a processi cannot decide to commit at timem in a run r if there is an indistinguishable
run r ≈m
i r in which some process decides abort. Similarly, by Commit Validity, a process i can
not commit if there is a run r that is indistinguishable from r (to i at time m) in which one of the
initial values is 0. Similarly, by Abort Validity, i can not abort at time m in a run r if r ≈m
i rˆ where
rˆ is a nice run (i.e., all initial values are 1 and no failure occurs in rˆ). These examples illustrate how
indistinguishability can inhibit actions—performing an action can be prohibited because of what
may be true at indistinguishable runs.
Rather than considering when actions are prohibited, we can choose to consider what is required for an action to be allowed by the specification. To this end, we can view Commit Validity
as implying that processi is allowed to perform commit at timem in r only if all initial values are 1
in every run r ≈m
i r. This is much stronger than stating that all initial values are 1 only in the run
r itself, of course. Roughly speaking, the stronger statement is true, because at time m process i
cannot tell whether it is in r or in any of the runs r ≈m
i r. When this condition holds, we say that
i knows that all values are 1. Generally, it will be convenient to define the dual of indistinguishability, i.e., what is true at all indistinguishable runs, as what the process knows. To reason about
knowledge in a rigorous manner, we shall make use of a formal definition of knowledge. We now
introduce just enough of the theory of knowledge to support the analysis performed in this article.
For a more general setting and further details, see References [14, 20].
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.
Silence 3:5
We shall use φ, ψ, and so on, to denote facts. In general, at any particular time t of any given
run r, a fact φ is either true or false. Specifications of agreement problems such as consensus and
AC often involve facts such as “vj = 1” (j’s initial value is 1), “j is faulty” (in the current run), and
“j decides commit” (in the current run). Such facts capture properties of runs: For every run r, the
fact is either true at all times in r or is false at all times.
Definition 1 (Knowledge). Fix a system R, a run r ∈ R, a process i, and a fact φ. We say that Kiφ
(which we read as “processi knows φ”) holds at timem in r iff for all runsr ∈ R such thatr ≈m
i r,
the fact φ is true at time m in r
.
Notice that knowledge is defined with respect to a given systemR. Often, the system is clear from
the context and is not stated explicitly. Definition 1 immediately implies the so-called Knowledge
property: If Kiφ holds at a given time m in r, then φ is true at time m in r.
We use Boolean operators such as ¬ (Not), ∧ (And), and ∨ (Or) freely in the sequel, to obtain
more complex formulas from simpler ones. We remark that even when φ is a property of runs, Kiφ
need not be. Thus, for example, Ki (vj = 0) may be false at timem in a run r and true at timem + 1,
based perhaps on messages that i does or does not receive in round m + 1.
A recent paper [29] provides an essential connection between knowledge and action in distributed protocols called the knowledge of preconditions principle (KoP). It states that whatever
must be true when a process i performs a particular action must be known by i when the action
is performed. This is one way of capturing the role of indistinguishability discussed above. More
formally, we say that a fact φ is a necessary condition for an action α in a system R if for all runs
r ∈ R and times m, if α is performed at time m in r, then φ is true at time m in r. For deterministic
protocols in synchronous models such as γ f
, the KoP can be stated as follows:
Theorem 1 (KoP, [29]). Fix a protocol P for γ f
, let i be a process, and let α be an action of i in RP.
If φ is a necessary condition for α in RP, then Kiφ is a necessary condition for α in RP.
We use all[1] to denote the fact that all initial values are 1. Since all[1] is a necessary condition
for performing commit in AC, Theorem 1 immediately implies the following, which will be useful
in our analysis of AC in Section 4:
Corollary 1 (Hadzilacos [17]). When a process i commits in a run of an AC protocol, it must
know all[1]. (In particular, Ki (vj = 1) must hold for every process j.)
Hadzilacos [17] is a very elegant paper that was the first to apply knowledge theory to the study
of commitment problems.
3 SILENCE IN THE PRESENCE OF CRASHES
We now discuss three ways in which information can be transferred using silence. We start with
an intuitive, high-level exposition and formalize the discussion (within the synchronous model
defined above) in Section 3.1.
S1. Silent inference from a reliable source: Suppose that any message sent from a process j
to i is sure to be delivered within Δ time units. Moreover, assume that process j is guaranteed to
send i a message at time t in case some condition φ of interest is false. If, by time t + Δ, process i
has not received a message that j sent to i at time t, then i can infer that φ holds.
In fact, extensive use of silence can achieve an even greater effect. Suppose that the proper operation of a synchronous system depends on the truth of local conditions φj , for different processes j.
In this case, all nodes of the system can be informed that all conditions hold simply if no process
reports a violation of its local condition. Effectively, this achieves a (silent) broadcast from each
process to all processes, at no message cost.
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.
3:6 G. Goren and Y. Moses
Notice that silence can be informative only in case there are alternative circumstances (e.g.,
when φ does not hold) under which a message would be received by i. Thus, in a precise sense,
silence can serve to shift the communication costs among scenarios. This can be especially useful for optimizing the behavior of protocols in cases of interest. Most popular is optimization
for the common case (often referred to as fast path/slow path protocols) in which a protocol is
designed to be very efficient in the common case, at the expense of being less efficient in uncommon cases. In S1, the ability to convey information by silence depends on a reliability assumption, since if j may fail by crashing, for example, then it would be possible for i not to
hear from j even if φ is false. The information conveyed by a null message in this case can be
described by:
S2. Silent inference from an unreliable source: Suppose that a process j is guaranteed to send i
a message at time t in case some condition φ of interest does not hold and j is not faulty. If, by time
t + Δ, process i has not received a message that j sent to i at time t, then i can infer that at least
one of the following is true: (i) φ holds, or (ii) j is faulty.
In particular, if j sends messages to i over a reliable communication link, then (ii) reduces to
process j being faulty. Despite the fact that i may fall short of inferring that φ holds when it does
not hear from j, the information that it does obtain may still be very useful. In many problems
having to do with fault-tolerance, the specification depends on whether failures occur. Thus, for
example, in the original atomic commitment problem [13, 16], deciding to abort is allowed if one of
the initial values is 0, or if a failure occurs. In Byzantine agreement [31] and weak agreement [24],
deciding on a default value is allowed in case of a failure. But this is not true in general. In the
popular consensus problem, for example, the Validity condition is independent of whether failures
occur [9], thus rendering conditional knowledge as provided by S2 insufficient. As we will see,
there are circumstances under which silence can provide unconditional information even in the
face of failures.
Our investigation will focus on synchronous message-passing systems, in which, for ease of
exposition, our model assumes that processes communicate in rounds and a message sent in a
particular round is received by the end of that round. Moreover, we will consider settings in which
only processes may fail, and there is an a priori bound of f on the number of processes that can
fail. One way to infer unconditional information in such settings is captured by:
S3. Silent inference with bounded failures: Assume that at most f processes can fail, and let
S be a set of at least f + 1 processes. Moreover, suppose that every process j ∈ S is guaranteed to
send i a message no later than round m in case φ does not hold and j is not faulty. If i hears from
no process in S by time m, then i can infer that φ holds.
S3 is used, for example, by Amdur et al. [1], who consider message-efficient solutions to Byzantine agreement. To prove to all processes that the original sender completed the first round, their
protocol has the sender send messages to a set B of f processes in the second round. In the third
round, a member of B sends no messages if it received the sender’s second-round message. This
implies, in particular, that the sender did not fail in the first round. A member of B does send thirdround messages to everyone in case it did not hear from the sender in the second round. The set
S = {sender} ∪ B satisfies the above rule and allows all processes to infer the fact φ = “the sender
completed the first round successfully” based on silence in the third round.
The rules S1–S3 provide sufficient conditions for silent information transfer. As we will show,
both S2 and S3 can be used to facilitate the design and analysis of efficient fault-tolerant protocols.
Moreover, S3 is in a precise sense also a necessary condition for inferring particular facts of interest
from silence. This, in turn, will allow us to obtain simple and intuitive proofs of lower bounds and
matching optimal protocols.
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.
Silence 3:7
3.1 Silent Broadcast
There are several ways to formally state the rules S1–S3; we will state them in a form that will be
most convenient to use in the sequel. It is natural to capture the fact that processi infers thatφ holds
using the knowledge terminology. Moreover, in a synchronous setting, not sending a message at
a given point is a choice just like performing an action. In S1, process j is assumed not to send a
message in case φ holds. Thus, by the knowledge of preconditions principle (Theorem 1), j must
know φ to make this choice. We say that a protocol guarantees a property if this property is true
in all runs of the protocol. We can thus formalize S1 as follows:
Lemma 1. Let R be a synchronous system with reliable communication in which process j reliably
follows a protocol P (i.e., j is guaranteed to be correct in all runs of R). Let φ be a property of runs in
R and assume that P guarantees that if ¬Kjφ at time m − 1, then j sends a message to i in round m.
If i does not receive a message from j in round m of a run r ∈ R, then Kiφ holds at time m in r.
Proof. Fix r ∈ R and assume that i does not receive a message from j in round m of r. Moreover, choose an arbitrary run r ∈ R such that r ≈m
i r. By Definition 1, it suffices to show that r
satisfies φ. By assumption, i has the same local state at time m in both runs, and so it does not
receive a message from j in round m of r
. Since R is synchronous and communication is assumed
to be reliable, it follows that j did not send a message to i in round m of r
. Process j is assumed
to reliably follow the protocol P. Hence, by assumption, Kjφ must be true at time m − 1 in r
, or
else it would have sent a message to i. By the knowledge property, it follows that φ holds at time
m − 1 in r
. Moreover, since φ is a property of runs, the run r satisfies φ, and we are done.
S2 considers information gained by silence in systems in which processes can fail, such as the
context γ f
. In this case, i might not receive a message from j due to a failure, rather than because of
information that j has at the beginning of the round. We thus obtain a weaker variant of Lemma 1,
formalizing S2:
Lemma 2. Let φ be a property of runs in the system RP = R(P,γ f ), and fix i, j ∈ P and a time
m > 0. Moreover, assume that P guarantees that if ¬Kjφ at time m − 1, then j sends a message to i
in round m. If i does not receive a round m message from j in a run r ∈ RP, then Ki (φ ∨ j is faulty)
holds at time m in r.
Proof. The proof is very similar to that of Lemma 1. Fix r ∈ R and assume thati does not receive
a message from j in round m of r. Moreover, choose an arbitrary run r ∈ R such that r ≈m
i r. By
Definition 1, we need to show that r satisfies (φ ∨ j is faulty). By assumption, i has the same local
state at timem in both runs, and so it does not receive a message from j in roundm ofr
. However,
since in RP the protocol P is applied in the unreliable context γ f
, there are two possible reasons for
this: One is that j fails in r before it has a chance to send i a message in roundm, in which case j is
faulty in r
; the other one is that j reliably follows P at time m − 1, in which case by assumption,
Kjφ must be true at time m − 1 in r (implying that φ is true in r
), or else it would have sent a
message to i. It follows that (φ ∨ j is faulty) must be true in r
, and we are done.
Clearly, the fact that becomes known by silence inγ f
, as captured by Lemma 2, is contingent (i.e.,
φ is true provided that j has not failed), and hence quite a bit weaker than what can be guaranteed
in the more reliable setting of Lemma 1. As mentioned in the Introduction, there are problems
in which such weaker knowledge may be sufficient. A closer inspection shows, however, that it
is possible to obtain unqualified knowledge from silence even in fault-prone settings such as the
context γ f
. The key to this is the fact that even when any single process may be faulty, a process
is often guaranteed that a set of processes must contain a nonfaulty process. In this case, we can
use Lemma 2 to obtain the following formalization of S3:
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.  
3:8 G. Goren and Y. Moses
Fig. 1. An illustration of a silent choir. Fig. 2. A silent choir performing a silent
broadcast.
Corollary 2. Let RP = R(P,γ f ), let φ be a property of runs in RP, and fix a process i ∈ P and a
set |S | > f of processes. Moreover, assume that for all j ∈ S the protocol P guarantees that if ¬Kjφ at
timem − 1 ≥ 0, then j sends a message to i (unless it fails) in roundm. If, in some run r ∈ RP, process
i does not receive a round m message from any process in S, then Kiφ holds at time m in r.
Proof. Under the assumptions of the claim, choose a run r ≈m
i r in RP. It suffices to show that
φ is true in r
. Since |S | > f , there must be a process h ∈ S that is correct in r
. Lemma 2 implies
that (φ ∨ h is faulty) is true in r
. But, since h is not faulty in r
, we obtain that φ holds in r
, as
required.
Corollary 2 shows how a set |S | > f of processes can inform a specific process i of a fact φ by
not sending messages to i. In fact, with no extra cost, the set S can be silent to all processes in a
round m of interest, thereby informing everyone that φ holds. We call this a silent broadcast. See
Figure 1 for a depiction of a silent choir, and Figure 2 for an illustration of a silent broadcast.
3.2 The Silent Choir Theorem
The rule S3 and its formalization in Corollary 2 show that a protocol can orchestrate information
transfer through silence by first informing (perhaps directly) a large enough set of processes about
the fact of interest. We now show that, in a precise sense, this is indeed necessary. Intuitively,
transferring information through silence requires enough processes to be mum to ensure that at
least one of them is correct. We will call this the Silent Choir Theorem. The direct information
transfer in the reliable case (S1) is a particular instance of this, because a choir of one suffices
when there are no failures. While the sufficient conditions of Section 3.1 apply rather broadly
to general properties of runs φ, to prove necessary conditions for silent inference, we need to
restrict attention to certain primitive facts. This is because knowledge of a composite fact such
as a conjunction φ = ψ1 ∧ψ2, for example, can be obtained by separately learning about each of
its components. Intuitively, a primitive fact is a fact that is local to a process j and whose truth
is not determined by the local states of the other processes. For ease of exposition, our analysis
will exclusively consider a single primitive fact, the fact “vj = 1” stating that j’s initial value is 1.
Knowledge about initial values plays an important role in many problems, including consensus
[9, 12] and AC.
Our treatment will make use of message chains. Given processes i,i ∈ P and times m,m ≥ 0,
we say that there is a message chain from (i,m) to (i
,m
) in a run r, and write (i,m) r
(i
,m
), if either (a) i = i and m ≤ m
, or (b) there exist processes i = j0, j1,..., j = i and corresponding times m ≤ t0 < t1,...,< t ≤ m such that for all 0 ≤ k < , a message from jk to jk+1 is
sent in r at time tk . Such a message chain is said to have length . (Notice that m ≤ t0, so the first
message in the chain may be sent after time m.) We say that there is a message chain from i to j
in r if (i, 0) r (j,m) for some time m ≥ 0.
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.       
Silence 3:9
Recall that in γ f process j’s initial value is not known to processes i  j at the start. Clearly,
one way in which process i can come to know that vj = 1 is by direct communication, i.e., via a
message chain from j to i. Alternatively, i can learn this fact using silence. The ways by which a
process i can come to know that vj = 1 in γ f are characterized by Theorem 2 below.
Definition 2. Let r ∈ R(P,γ f ), denote by Fr the set of faulty processes in r, and assume that
(j,t) r (i,m). If the set S = {h ∈ P : (j,t) r (h,m − 1)} satisfies |Fr ∪ S | > f , then S forms a
silent choir from (j,t) to (i,m) in r.
Roughly speaking, S is the set of processes that could have learned the value vj by time m − 1
via a message chain from j. These processes could then inform i through silence about vj . Notice
that it is possible for a process h to which a message chain from j is created in a run r to crash in
this run. In this case, h can be both in S and in Fr .
Theorem 2 (Silent Choir). Let r ∈ R(P,γ f ) and let m > 0. If Ki (vj = 1) holds at time m in r
and (j, 0) r (i,m), then a silent choir from (j, 0) to (i,m) exists in r.
Proof. Let r and m satisfy the assumptions. It suffices to show that if (j, 0) r (i,m) and no
silent choir from (j, 0) to (i,m) exists in r, then Ki (vj = 1) does not hold at time m in r. For every
time t ≥ 0, we define S (t) = {h ∈ P : (j, 0) r (h,t)}. By Definition 2, the assumption that no silent
choir from (j, 0) to (i,m) exists in r means that |Fr ∪ S (m − 1)| ≤ f . We will use this to prove that
Ki (vj = 1) does not hold at time m; i.e., we will show that if |Fr ∪ S (m − 1)| ≤ f , then i considers
it possible at time m that vj = 0 and that every process h ∈ S (m − 1) crashed without informing
anyone of j’s value.
More formally, we proceed as follows: For every h ∈ S (m − 1), define th to be the first round
of r in which a message chain from j to h is completed. Consider a run r of P in which vj = 0
and all other initial values are the same as in r. Every process h ∈ S (m − 1) crashes in round th + 1
of r without sending any messages. (In particular, j crashes initially.) Finally, the processes of
Fr \ S (m − 1) fail in r as well, in the same round and in the same manner as they do in r. Thus,
the faulty processes in r are those in Fr ∪ S (m − 1). By assumption |Fr ∪ S (m − 1)| ≤ f , and so
r is a run of P in γ f
.
We now prove by induction on  in the range 0 ≤  ≤ m that for every process z  S (), we have
that rz () = r
z ().
Base: Notice that S (0) = {j}. For  = 0, we have, for all z  j, that rz (0) = r
z (0), since by definition
of r all initial values other than vj are the same in both runs.
Step: Let 0 <  ≤ m, and assume that the inductive claim holds for  − 1. Consider a process
z  S (). Clearly, z  S ( − 1) and so, by the inductive hypothesis, rz ( − 1) = r
z ( − 1). By definition of S (), the fact that z  S () implies that z receives no messages from processes in S ( − 1)
in round  of r. By definition of r
, the processes in S ( − 1) send no messages in round  of
r
. Thus, z receives no messages from processes in S ( − 1) in r as well. Let h  S ( − 1). Then
rh ( − 1) = r
h ( − 1) holds by the inductive hypothesis. Since P is deterministic, it specifies for h
to perform the same actions, and in particular to send the same messages, in round  of both runs.
Clearly, if rh ( − 1) = ⊥, then h sends no messages in round . Moreover, if h fails in round  of r,
then by definition of r
, it fails in the same manner in round  of r
. It follows that z receives the
same messages in round  in both r and r
. Since rz ( − 1) = r
z ( − 1), we obtain thatrz () = r
z (),
completing the inductive step.
Since i  S (m), we have in particular that ri (m) = r
i (m), and hence r ≈m
i r
. By construction,
we have that vj  1 in r
, and so Ki (vj = 1) does not hold at time m in r.
By Theorem 2, any run in which a process learns about initial values without an explicit message
chain must contain a silent choir. Note that constructing a silent choir can be costly. In failure-free
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.                                         
3:10 G. Goren and Y. Moses
runs, for example, it requires sending at least f messages. Thus, using a silent choir to save a
single message is clearly inefficient. Recall, however, that the same choir can be used to perform a
silent broadcast. In this case, it can be very efficient, replacing n − 1 messages by f messages. Not
surprisingly, silent choirs can be found in message-efficient protocols in the literature, although
they are typically implicit in the solutions. For example, it is possible to identify a silent choir in
the message-optimal AC protocol of Reference [16], as well as in message-optimal protocols for
Byzantine agreement [1, 19] and for failure discovery [18].
While Theorem 2 considers silent choirs in the context of learning initial values, they can be
used more generally along the lines of Corollary 2. In Section 5, we will discuss extensions of
Theorem 2 to more general facts. Before considering such extensions, we turn to study a set of
practical applications of silent choirs.
4 EFFICIENT PROTOCOLS FOR ATOMIC COMMITMENT
Guerraoui and Wang [16] present state-of-the-art protocols for AC optimized for nice runs in
a variety of models and point out that there is a tradeoff between time and messages in their
protocols. For γ f they present three different protocols. In the nice run of their most messageefficient protocol (which is in fact message-optimal), n + f − 1 messages are sent, and processes
decide at time n + 2f . In the nice run of their fastest protocol, decisions are obtained within two
rounds, and 2n2 − 2n messages are sent.
4.1 Lower Bounds on AC in the Common Case
We are now ready to apply the formalism of Section 3 to the analysis of AC to derive protocols that are efficient in the common case. Our first goal is to show that silence must be used
in message-optimal AC protocols. To do so, we start by proving a useful combinatorial property
relating message chains and message complexity:
Lemma 3. Let k > 0, and assume that the run r contains, for every process j ∈ P, message chains
to at least k other processes. Then at least n + k − 1 messages are sent in r.
Proof. First notice that every process i ∈ P must send at least one message in r, since it has
message chains to other processes. Define the rank of a process i ∈ P to be the length of the
longest message chain from (i, 0) in the run r. If there is a process with rank ≥ n + k − 1, then we
are done. Otherwise, let h be a process with minimal rank, and let M be the set of messages on
chains that start at h. Clearly |M| ≥ k, because r contains message chains from h to at least k other
processes. Moreover, every j  h must send at least one message that is not in M, since otherwise
j’s rank would be strictly smaller than that of h. Thus, at least n − 1 + |M| ≥ n + k − 1 messages
must be sent in r, as claimed.
The message-optimal AC protocol for γ f presented in Reference [16], which we will refer to as
the GW protocol, sends n + f − 1 messages in its nice run. This can be used to prove the necessity
of silent choirs.
Corollary 3. If f < n − 1 and P is a message-optimal solution to AC in γ f , then the nice run of
P contains a silent choir.
Proof. Let f and P satisfy the assumptions, and let r be the nice run of P in γ f . Every process
i ∈ P commits in r, and by Corollary 1, i must know that vj = 1, for all j, when it commits. Theorem 2 implies that if r does not contain a silent choir, then there must be a message chain from
j to i. Since this is true for every pair of processes i, j ∈ P, the conditions of Lemma 3 thus hold
in r for k = n − 1, implying that P must send at least 2n − 2 > n + f − 1 messages in its nice run
r, contradicting the assumption that P is message-optimal. The claim follows.
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.   
Silence 3:11
Recall that the common case in this setting consists of a nice run, i.e., runs where all initial values
are 1, and no failures occur. Corollary 1 captures a basic property of AC protocols: A committing
process must know that all initial values are 1. The Silent Choir Theorem and the KoP can be used
to show the following property, which will be key to our lower bound proofs:
Lemma 4. When a processi commits in a run of an AC protocol, it must know, for every j ∈ P, that
there is a message chain from j to some correct process in the current run.
Proof. Assume that i commits in the run r of P. By Theorem 1, it suffices to show that if i
commits in r, then r contains a message chain from j to some correct process, for every j ∈ P.
Fix j ∈ P. Since f < n, there must be at least one correct process in r; denote it by h. Given that
i commits in r, we have by Agreement that h commits in r. Let us denote by m the decision time
of h. By Corollary 1, we have that Kh (vj = 1) holds when h commits. If there is a message chain
from j to h in r, then we are done, since h is the desired correct process. Otherwise, Theorem 2
states that r contains a silent choir from (j, 0) to (h,m), which we denote by S. The definition of
a silent choir implies that |Fr ∪ S | > f , and so S contains a correct process h
. Hence, the run r
contains a message chain from j to h
, and the claim follows.
We are now in a position to state and prove a set of lower bounds on the tradeoff between the
decision time and number of messages sent in the nice runs of AC protocols.
Theorem 3. Let P be an AC protocol for γ f
, let D be the time at which decision is reached in its
nice run, and let M be the number of messages sent in this run. Then D and M satisfy the following
constraints1:
(a) If D = 1, then f = 1 and M ≥ n2 − n;
(b) If D = 2, then M ≥ f n; and
(c) If D ≥ 3, then M ≥ n + f − 1.
Proof. Throughout the proof, r will denote the nice run of an AC protocol P.
Consider part (a), in which D = 1, and so P decides at time 1. Charron-Bost and Schiper established in Reference [7] that if f > 1, then D ≥ 2. Since by definition f ≥ 1, it follows that if
D = 1, then f = 1. In addition, given that D = 1, all processes commit at time m = 1 in r. Thus, by
Corollary 1, the fact Ki (vj = 1) must hold at time m = 1 in r for all i, j ∈ P. We now claim that
there can be no silent choir from (j, 0) to (i, 1). Since r is a nice run and f = 1, a silent choir in r
must contain more than one process. But at time 0, the only process to which there is a message
chain from (j, 0) is j itself. Thus, by Theorem 2, the run r must construct a message chain between
every pair of processesi  j ∈ P in the first round. It follows that M ≥ n(n − 1) = n2 − n messages
are sent in r, as claimed.
For part (b), it suffices to show that if D = 2, then every process must send at least f messages
in r. Let P be an AC protocol with D = 2, let i ∈ P, and denote by T the set of processes to which
i sends messages in the nice run r. Assume, by way of contradiction, that |T | < f . Consider a run
r of P in which i crashes after deciding, without sending any messages after the second round.
Moreover, every process h ∈ T fails in the second round without sending messages to any process
except possibly to i (to which h sends in r iff it does so in r). The run r contains |T | + 1 ≤ f
failures, and is a run of P in γ f
. The run r contains no message chain from i itself to a correct
process. Moreover, r ≈2
i r by construction, and therefore when it commits in r, process i does
not know that the run contains a message chain from itself to a correct process. This contradicts
Lemma 4.
1We prove that M ≥ n + f − 1 in part (c) for completeness. This was proved for the case of f = n − 1 by Dwork and Skeen
in Reference [13], and appears for general f in Guerraoui and Wang [16], with some details of the proof omitted.
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.  
3:12 G. Goren and Y. Moses
Finally, for part (c), we now prove that M ≥ n + f − 1. This will follow by Lemma 3 once we
show that the run r must contain, for every process j ∈ P, message chains from j to at least f
other processes. Fix a process j. If r contains message chains from j to all other processes, then we
are done, since f ≤ n − 1. Otherwise, let i be a process to which there is no message chain from j
in r. Since r is nice, all processes commit in r. Denote by m the time when i commits. Given that
there is no message chain from j to i in r, Theorem 2 implies that |Fr ∪ Sj | > f , where Sj is the
set of processes to which a message chain from j is completed by time m − 1 in r. Since r is nice,
we have that Fr = ∅, and so |Sj | > f . Finally, as j ∈ |Sj |, there must be message chains from j to at
least f other processes in r. The claim follows.
Next, we prove that the bounds of Theorem 3 are tight by providing matching upper bounds.
4.2 Upper Bounds on AC in the Common Case
Recall that we consider the set of processes to be P = {0, 1,...,n − 1}. Roughly speaking, the
message-optimal GW protocol spends n + f − 1 rounds creating a long chain of n + f − 1 messages
sent in cyclic order from process 1 through n − 1 and then continuing to 0,..., f . It then runs a
consensus protocol to decide among the actions commit and abort. This consensus phase goes on
for another f + 1 rounds starting at time n + f − 1 and sends no messages during the nice run. In
our terminology, the first process to know thatvj = 1 for all j is process 0. The processes 0, 1,..., f
form the silent choir: They must inform the processes in case the chain is broken. At time n + f , if
a process is not informed of a problem, it knows that all initial values are 1. However, it does not
decide until time n + 2f . This is because, in the GW protocol, before time n + 2f the process does
not know that others are deciding to commit.
Using the terminology of Theorem 3, the GW protocol decides in D = n + 2f rounds. Dwork
and Skeen’s message-optimal protocol for the case f = n − 1 decides in D = 2n + 1 rounds [13].
There is a very large gap between these decision times and the lower bound of D ≥ 3 established in
Theorem 3(c). We now present the Stealth protocol, a message-optimal AC protocol that decides
in D = 3 rounds. We will then present two additional protocols that are similarly Pareto optimal,
in the sense that their message complexity cannot be reduced without increasing their round complexity. One of them decides in D = 2 rounds for the case of f > 1, and the other in D = 1 round
when f = 1. Together, these three protocols prove that the bounds in Theorem 3 are all tight, and
completely characterize the tradeoff between time and message complexities in the common case
for AC protocols.2 Full descriptions of all protocols in this section, together with their proofs of
correctness, appear in Appendices A.1–A.3.
Stealth: an AC protocol with D = 3 and M = n + f − 1.
Fast Path: In the first round, all processes that have value 1 send a message to process 0. If process
0 hears from all processes by time 1, then it sends messages to processes 1, 2,..., f in the second
round. In case all these messages arrive to their destinations by time 2, no messages are sent in the
third round. A process that receives no third-round messages performs commit at time 3. Finally,
if such a process receives no fourth-round messages, then it halts at time 4.
Slow Path: The slow path in Stealth operates as follows. In the third round, any member of
the choir (i.e., processes 0, 1,..., f ) broadcasts “error” messages to all processes if it has observed
that the run is not nice. Namely, process 0 does so if it did not received n − 1 messages in the
first round, while each of the other members broadcasts an “error” message if it did not receive
2Guerraoui and Wang present a protocol called 1NBAC in [16] in which processes decide in the second round in the nice
run, but do so after the sending phase of the second round, and before receiving second-round messages. 1NBAC requires
2n2 − 2n messages in its nice run. In Section B, we prove a lower bound of n2 + f n − n messages for their model, and
present a matching protocol that proves that the bound is tight.
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020. 
Silence 3:13
a second-round message from 0. Any process that receives an error message in the third round
broadcasts a clarification request message “huh? ” in the fourth round. Finally, if a process receives
any “huh? ” message in the fourth round, it runs the Beep sub-protocol of Figure 3 for at most
f + 1 rounds, starting at time 4. Beep is a consensus protocol based on Reference [8], which
has the property that if any correct process has initial value 1, then the final decision is 1. See
Section A.1 for details. A process proposes 1 (in favor of committing) in the consensus protocol
if it received no message in the third round, or if it is in the choir and received its second-round
message. It proposes 0 (in favor of aborting) otherwise. Processes that participate in the consensus
protocol and have not committed prior to time 4 decide according to the consensus output. In the
worst case, the last process halts in Stealth at time f + 5. ♣
In its nice run, the Stealth protocol constructs a silent choir for the fact that all values are 1 in
the second round, and uses the third round to allow the choir to perform a silent broadcast of this
fact to all processes. Interestingly, it uses silence in an additional manner: Round 4 implements a
silent broadcast from all processes to all processes. This does not require a silent choir, because it
makes use of the rule S2: a null message from j informsi that j is either active and has committed,
or has crashed without deciding. The next protocol also uses two rounds of silence in a similar
manner.
D2: an AC protocol with D = 2 and M = f n.
Fast Path: Every process j with vj = 1 sends messages to the f processes j + 1, j + 2,..., j + f
(wrapping around mod n) in the first round. In the second round, a process that sent messages
and received all f possible first-round messages is silent. A process that receives no second-round
messages performs commit at time 2, and remains silent in the third round. Finally, if such a process
receives no third-round messages, it halts at time 3.
Slow Path: The slow path is similar in spirit to that of Stealth, starting one round earlier. A
process j such that vj = 0, or that does not receive first-round messages from all of its f predecessors j − 1, j − 2,..., j − f (mod n) broadcasts an “error” message (to all processes) in the second
round. In the third round, a process that (sent or) received an “error” message in the second round
broadcasts a message listing all processes whose values it knows to be 1. All processes that do not
halt at time 3 participate in the Beep consensus protocol as in Stealth, which starts at time 3. In
this case, a process proposes 1 in Beep iff it knows that all initial values were 1. ♣
Our third protocol treats the boundary case of f = 1. Rather than two silent rounds, only the
latter one, corresponding to S2, is needed in the nice run:
D1f1: an AC protocol with D = 1 and M = n2 − n for f = 1.
Fast Path: In the first round, every process j with vj = 1 sends messages to all other processes. A
process with initial value 1 that receives messages from all processes in the first round performs
commit at time 1. Finally, if such a process receives no messages in the second round, it halts at
time 2.
Slow Path: For the slow path, a processj withvj = 1 that does not receive messages from everyone
in the first round broadcasts a “huh? ” message in the second round. A committed process that
receives such a message in the second round responds in the third round with an “all[1]” message
to the requesting process j. Finally, a process that did not commit at time 1 will perform commit at
time 3 if it received an “all[1]” message in the second round, and will perform abort otherwise.
All processes halt at time 3 (possibly after deciding at time 3). ♣
5 A MORE GENERAL SILENT CHOIR THEOREM
Section 3.2 proved the necessity of a silent choir for transferring information about the initial
value of a process j without sending messages. But silent choirs are not specific to information
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.
3:14 G. Goren and Y. Moses
about initial values. In this section, we extend the analysis to more general facts about j’s local
state. Namely, we show that silent choirs are similarly necessary for discovering any nontrivial
fact about what j knew at a previous point in time.
For any formula ψ and time t, we define the formula ψ@t, which holds if ψ is true at time t in
the current run. Thus, for example, (Kjφ)@t states that at time t, the fact ψ = Kjφ holds (or held)
in the current run. (Observe that ψ@t is a property of runs.) We will study how Ki ((Kjφ)@t) can
arise in our model. As a first step, let us consider how a process i can come to know that j has
not crashed by a given time t. More precisely, recall a process is called active at time t in a given
run r if it does not crash in the first t rounds of r. We denote the fact that j is currently active
by the proposition Activej . We can show that silent choirs are necessary for learning Activej@t
without a message chain from (j,t):
Theorem 4. Let r ∈ R(P,γ f ) and let m > 0. If both Ki (Activej@t) holds at time m in r and
(j,t) r (i,m), then a silent choir from (j,t) to (i,m) must exist in r.
Proof (sketch.) The proof is very similar to that of Theorem 2, with (j,t) assuming the role
played by (j, 0) in Theorem 2 and message chains from (j,t) replacing message chains from
(j, 0). Given a run r ∈ R(P,γ f ) and time m > 0, we construct a run r ≈m
i r in which Activej@t
does not hold. For every time k ≥ 0, we define the set S (k) = {h ∈ P : (j,t) r (h, k)}, and for all
h ∈ S (m − 1) denote by kh the minimal k such that h ∈ S (k). In the run r
, process j crashes at the
end of round t after sending all its prescribed messages for that round. Moreover, every process
h ∈ S (m − 1) crashes in round kh + 1 without sending messages. Thus, in particular, Activej@t
does not hold in r
. Finally, following the same lines as in the proof of Theorem 2, an inductive
argument shows that rz () = r
z () holds for every  in the range t ≤  ≤ m and every process
z  S (). In particular, ri (m) = r
i (m), and so r ≈m
i r
.
Knowing that a process was active at a given time can form the basis of other interesting facts.
In particular, if i knows that j was active at time t, it immediately learns that j had followed its
protocol in all rounds 1 ≤ k ≤ t. Therefore, i knows that if j was silent in one of these rounds, this
silence was intentional and not due to a failure. Recall that by rule S2 and Lemma 2, if i receives
no message from j in round m, then process i can learn facts of the form Ki (φ ∨ j is faulty) at
time m. Once it learns that Activej@t, for some t ≥ m, process i can come to know φ. In fact, the
message-optimal Byzantine agreement protocols of References [1, 19] make (implicit) use of this
observation. Specifically, these protocols use a silent choir to inform processes that the leader was
active at time 1, and as a result, processes that did not receive a message from the leader in round
1 learn that its initial value was v.
Another important implication of Theorem 4, which we show next, is that, essentially, silent
choirs are necessary to learn that a process knew a particular fact of interest at a given time in the
past. This is true for all facts except for those that a crashed process may be said to know. Notice
that we assume that a crashed process has the local state ⊥, which contains no information other
than that the process has crashed. We proceed as follows.
Definition 3. We say that a fact φ is j-trivial at time m in a system R = R(P,γ f ) if for some run
r ∈ R such that rj (m) = ⊥ (i.e., j has crashed by time m), j knows φ at time m in r. The fact φ is
called j-nontrivial at m otherwise.
An immediate consequence of this definition is that a process that knows a nontrivial fact must
be active. We can now show the following corollary of Theorem 4:
Corollary 4. Let r ∈ R = R(P,γ f ), let φ be a j-nontrivial fact at time t in R, and let m > 0. If
Ki ((Kjφ)@t) holds at time m in r and (j,t)r (i,m), then a silent choir from (j,t) to (i,m) must
exist in r.
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.         
Silence 3:15
Proof. Fix the system R = R(P,γ f ). Let r, φ, and m satisfy the assumptions, and suppose that
Ki ((Kjφ)@t) holds at time m in r. We will show that Ki (Activej@t) holds at time m in r, and
so the claim will follow directly from Theorem 4. To show that Ki (Activej@t) holds, choose an
arbitrary run r ≈m
i r; since Ki ((Kjφ)@t) holds at timem in r, we have by the knowledge property
that (Kjφ)@t holds at timem in the chosen run r
. Since φ is j-nontrivial at time t in R, Definition 3
implies that j is active at time t in r
. In particular, it follows that Activej@t holds at time m in r
.
Finally, since r is an arbitrarily chosen run such thatr ≈m
i r, we obtain that Ki (Activej@t) holds
at time m in r. The claim now follows by Theorem 4.
It is instructive to review the AC protocols we have discussed in light of Corollary 4. In both
the GW protocol and our Stealth protocol, there is a point in the nice run at which a particular
process (called process 0 in Stealth) knows that all initial values are 1. This is a nontrivial fact
for this process (in the sense of Definition 3), and each of the protocols makes use of a single silent
choir that informs everyone of process 0’s knowledge. Consequently, everyone also learns that
all values are 1. Note that constructing and using a silent choir requires at least two rounds in a
failure-free run. Hence, our faster protocol D2, which decides in just two rounds in its nice run, is
forced to construct a separate silent choir for each individual fact vj = 1. This is the reason for the
increased message complexity in D2 compared to Stealth, and for the inherent tradeoff between
time and communication in the solutions to the AC problem that we have considered.
6 DISCUSSION
In the well-known story Silver Blaze, Sherlock Holmes is able to conclude that a victim’s dog was
familiar with the murderer, based on the fact that the dog was silent when the criminal entered
[11]. In that example, Conan Doyle crisply illustrates how a crucial piece of knowledge can be
gained by observing silence. The focus of our investigation has been on the use of silence in faulttolerant distributed protocols. A variety of protocols in the literature make implicit use of silence
(e.g., References [6, 10, 25]). In network protocols, periodically sending Keep-alive messages is
commonly used to inform a peer that a node is active. The absence of such messages allows the
peer to discover that a failure has occurred [32].
As has been elucidated by Reference [23], synchronous channels allow processes to send null
messages by not sending a message. In a precise sense, our analysis considers what information
can be passed using null messages. This becomes especially interesting in systems with failures,
since the absence of a message in such settings can be caused by a failure, rather than by deliberate silence. In the presence of a bounded number of crash failures, we identified the notion of a
silent choir as an essential component of information transfer by silence. We showed that the only
way that a process j can inform another process i of j’s initial value without an explicit message
chain between them is by constructing a silent choir (Theorem 2). Indeed, in a variety of messageoptimal protocols it is possible to identify silent choirs. These include Reference [16] for Atomic
Commitment, References [1, 19] for Byzantine Agreement, and Reference [18] for the failure discovery problem. The silent choir is a valuable tool for a protocol designer. By directly constructing
silent choirs, we were able to reduce the number of rounds for message-optimal AC protocols
from n + 2f to 3 in the Stealth protocol, and to design a protocol (D2) that is message-optimal
among round-optimal AC protocols in Section 4.2. Since silent choirs are necessary in some cases,
they can also serve in theoretical analyses. In Theorem 3, we used the necessity of silent choirs in
message-optimal solutions to obtain a complete characterization of the tradeoff between decision
times and communication costs for AC protocols.
While our investigation has focused on the synchronous round-based model γ f in which processes fail by crashing and the network is fully connected, it applies to more general synchronous
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020. 
3:16 G. Goren and Y. Moses
systems. In particular, the rules S2 and S3 and their formalizations, as well as the Silent Choir
Theorem, hold with minor modifications even in the presence of Byzantine failures.
We have seen that knowledge can arise from communication patterns that involve silent choirs.
This suggests defining a notion of potential causality that is based on both messages and silent
choirs. An analogous notion for reliable systems based on combining explicit messages and null
messages was defined and used in Reference [3]. (A null message is a silent choir of size 1.)
Intuitively, the notion of a silent choir should apply even when the network is an arbitrary graph.
In this case, however, we would expect a silent choir to consist exclusively of in-neighbors of the
target process (corresponding to i in Definition 2). Moreover, membership in the choir in this case
should be based on knowledge rather than on receiving a message chain. The use of silence, and
more generally the topic of how information can be gleaned from actions that are not performed
by processes in a system, is an exciting topic that deserves further investigation in the future.
APPENDICS
A DESCRIPTIONS OF THE PROTOCOLS
Recall that the goal is to optimize AC protocols for the common-case, i.e., in nice runs. Therefore,
to simplify the exposition of protocols, improvements regarding the uncommon cases, when runs
are not nice, are left out. In runs that are not nice, the Stealth and D2 protocols occasionally make
use of a simple consensus protocol we call Beep, which is shown in Figure 3. This is an instance
of well-known protocols due to Dolev and his colleagues from the 1980s [8]. In the Beep protocol,
every process is guaranteed to halt after no more than f + 1 rounds. Moreover, the Beep protocol
is “biased to 1,” in the sense that for all runs, if some correct processi ∈ P proposes 1 in Beep, then
the decision value is 1.
Fig. 3. The Beep consensus protocol.
A.1 The Stealth Protocol
The Stealth protocol, sketched in Section 4.2, is given in Figure 4. Its performance matches the
lower bound of Theorem 3(c). That is, for f > 1, Stealth is time-optimal among message-optimal
AC protocols with M = n + f − 1 and D = 3. The protocol is optimal in bits as well as in messages.
Each message sent in Stealth consists of a single bit. Both all[1], “err,” and “huh? ” can be represented by “1,” as they are the only messages that might appear in rounds 2, 3, and 4, respectively.
Two possible runs of Stealth are illustrated in Figures 5 and 6. Figure 5 depicts the protocol’s nice run, and it goes as follows: in round 1, all processes send 1 to process 0; in round 2,
process 0 sends all[1] to processes 1, 2,..., f ; in round 3, all processes are quiet; at time 3, all processes decide 1; and at time 4 (i.e., after another silent round) all processes halt. Figure 6 depicts an
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.
Silence 3:17
Fig. 4. The Stealth protocol. Not all processes participate in all rounds.
Fig. 5. The nice run of Stealth. Fig. 6. A run of Stealth with failures.
example of a run that is not nice. It goes as follows: in round 1, all processes send 1 to process 0; in
round 2, process 0 tries to send all[1] to processes 1, 2,..., f but crashes, by time 2 some receive
it and some do not; in round 3, processes from {1, 2,..., f } that did not receive all[1], send err
to all, the rest are quiet; in round 4, all processes that received err send “huh? ” to all (asking for
help); at time 4, the active processes start Beep, a process that knows all[1] proposes 1 (green
smiley), the rest propose 0 (red frowny). In this case, in which the run is not nice, a consensus
protocol is initiated at time 4, which can take up to f + 1 additional rounds to complete.
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.
3:18 G. Goren and Y. Moses
Recall that the specification of the AC problem is given in Section 2.1. Throughout the Appendix,
unless stated otherwise, the protocols are assumed to execute in the context γ f
.
We now consider correctness of the Stealth protocol, which appears in Figure 4.
Claim 1. In the nice run of Stealth, exactly n + f − 1 messages are sent over the network, and
all processes perform commit at time 3.
Proof. Letr be the nice run of Stealth, illustrated in Figure 5. Since r is nice, it holds thatvi = 1
for all i ∈ P and no failures occur, therefore, r goes as follows: In the first round, n − 1 messages
of 1 are sent to process 0. In the second round, process 0 sends all[1] to S =
0, 1, 2,..., f

, adding
f to the total number of sent messages (it does not actually send a message to itself). In the third
round all is quiet (no message is sent) and then, at time 3, all processes perform commit. This
results in a total of n + f − 1 sent messages.
Lemma 5. The Stealth protocol satisfies commit validity.
Proof. Let r be a run of Stealth in which some process, say i, starts with 0. We show that
no decision in r is commit. By definition of Stealth, since i starts with 0 in r, it does not send
“1” to process 0 in the first round. Thus, at time 1 of r, process 0 does not receive “1” from all and
therefore does not send all[1] to anyone in the second round. By time 2 ofr, none of the processes
in S =
0, 1, 2,..., f

receives all[1] from process 0, so any active process in S at time 2 sends err
to all in the third round. Since |S | = f + 1, it is guaranteed that at least one of them is correct in
r, and hence will broadcast err in the third round. Hence, by time 3 all processes receive an err
(at least from the correct process). Thus, at time 3 of r, no one commits and each process sends
“huh?” to all others in the fourth round. At time 4, Beep is activated. Since no process ever received
all[1] from process 0 in the second round of r, all processes active at time 4 participate in Beep,
each proposing a value of 0. By the validity of Beep, the consensus value is 0, and thus the only
decisions possible in r are abort and no process performs commit in r. The claim follows.
Lemma 6. The Stealth protocol satisfies abort validity.
Proof. Let r be a run of Stealth in which no process starts with 0 (they all start with 1) and
no failures occur. Thus, r is a nice run by definition. By Claim 1, no process performs abort in r
(they all perform commit).
Lemma 7. The Stealth protocol satisfies decision.
Proof. Let r be a run of Stealth and let i ∈ P be a correct process in r. If i does not decide
at time 3 of r, then it successfully sends a “huh? ” message to all. (Recall that i is correct.) All the
active processes at time 4, including all the correct processes in r, receive i’s “huh? ” and therefore
they all participate in the Beep consensus phase. By the decision guarantee of Beep, i decides no
later than at time f + 5 in r.
Lemma 8. The Stealth protocol satisfies agreement.
Proof. Let r be a run of Stealth. We prove by dividing into the two possible cases for r: case
(1) No decision in r is made at time 3. By definition of Stealth, this implies that all correct processes in r participate in the Beep consensus protocol and all decisions are made according to it.
Therefore, in this case, r satisfies agreement based on the consensus agreement property of Beep.
case (2) Some process, say i, decides at time 3 in r. By definition of Stealth, every process that
decides at time 3, including i, decides commit. For process i to commit at time 3 of r, it must
have received no message from any process in S =
0, 1, 2,..., f

in the third round. |S | = f + 1,
and so at least one of the processes in S is correct in r and is quiet because it knows all[1]
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.          
Silence 3:19
Fig. 7. Round-optimal protocol D2: decides in the nice run at time D = 2, using M = n f messages.
(process 0 or someone that heard all[1] from process 0). Let us name this process pgood. By definition of Stealth, processes that decide from time 4 onward in r send “huh? ” to all in the fourth
round; after which, all processes that have not crashed by time 4 in r, including pgood, start Beep.
Since pgood knows all[1], it proposes 1 in Beep. Since pgood is correct proposing 1 in Beep, the
decision value in Beep is 1. By definition of Stealth, every process that decides in r after round
4 chooses to commit, and r satisfies agreement in this case as well. It follows that in both possible
cases, r satisfies agreement.
Claim 2. Stealth is an AC protocol in γ f .
Proof. Let r be a run of Stealth in γ f . By Lemmas 5, 6, 7, and 8, r satisfies the required
conditions for AC, and so Stealth is an AC protocol in γ f .
A.2 The D2 Protocol
The protocol in Figure 7 commits at time 2 in its nice run, using only n f messages.
We next prove the correctness of D2.
Claim 3. If r is the nice run of D2, then exactly n f messages are sent over the network and all
processes perform commit at time 2 in r.
Proof. Let r be the nice run of D2. Then r goes as follows: In the first round of r every i ∈ P
sends 1 to {i,i + 1,...,i + f } (a total of n f messages). Thus, all processes receive their expected
first-round messages, so they all remain quiet in the second round. Since every process i receives
no err messages in the second round, everyone commits at time 2. Hence, exactly n f messages are
sent and all processes commit at time 2 in r.
Lemma 9. The D2 protocol satisfies commit validity.
Proof. Let r be a run of D2 in which some process i ∈ P starts with vi = 0. We show that no
process commits in r.
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.   
3:20 G. Goren and Y. Moses
In the first round, i does not send 1 to {i,i + 1,...,i + f } (mod n). Consequently, in the second
round, correct processes in {i,i + 1,...,i + f } send err to all. Since |{i,i + 1,...,i + f }| > f , at
least one of these processes is correct in r, and therefore its err messages reach all processes by
time 2. Because every process receives an err message in the second round, at time 2 none of them
decides. (Instead, they use the third round to send the IDs of processes from which they heard in
the first round.) As no process receives 1 from i in the first round, no one sends the ID of i in the
third round. Hence, no process receives all IDs by time 4 in r. Therefore, at time 4 every correct
j ∈ P proposes 0 in Beep. By the validity property of Beep, no process decides 1 (and consequently
no process commits) in r.
Lemma 10. The D2 protocol satisfies abort validity.
Proof. Let r be a run of D2 in which all processes start with 1 and no failure occurs. By definition, this is a nice run, and as proved in Claim 3, all processes commit at time 2 in r. (No process
performs abort.)
Lemma 11. The D2 protocol satisfies agreement.
Proof. Let r be a run of D2. If all decisions in r are performed before time 3, then all correct
processes decide to commit. Thus, r satisfies agreement. If no decision in r is done before time 3,
then all decisions are according to Beep, and thusr satisfies agreement. The only case left to check
is when some decisions, but not all, are performed before time 3 (i.e., at time 2).
Let i be a process that decides at time 2 in r and let i be a process that decides in r at some
time k ≥ 3. We will prove that all processes that decide in r decide the same as i. By definition of
D2, every decision before time 2 is commit, and so all processes that decide before time 3, and in
particular process i, decide to commit. We claim that in this case every decision at times k ≥ 3 is
commit as well. Processi commits at time 2, since it does not receive any err message in the second
round. It follows that, for every j ∈ P, process i did not receive an err message from any process
in Sj = {j, j + 1,..., j + f }. As there are no more than f failures in r, this implies that for every
j ∈ P there is at least one correct process in Sj that received 1 from j in the first round. We denote
this process by pgood,j . This process either commits at time 2 or it succeeds in sending j’s ID to all
in the third round of r. Since i decides in r later than at time 2, it must be the case that i is active
at time 3, and therefore i succeeds in sending its third-round messages. All correct processes in r
(including all the pgood,j processes) receive a message from i in the third round and participate in
the Beep protocol from time 3 onward. If any of the pgood,j committed at time 2, then it proposes
1 in Beep. It follows that a correct process proposes 1 in Beep, and the properties of Beep ensure
that the consensus value decided on is 1. This leads i to commit, as desired. Finally, suppose that
none of the pgood,j processes commits at time 2 in r. Then each pgood,j succeeds in sending j’s ID
to all in the third round of r. Consequently, by time 3, all correct processes receive the IDs of all
processes j ∈ P. Therefore, all correct processes propose 1 in Beep, and by validity of consensus,
the consensus value is 1. By definition of D2, all decisions are commit, the same as i’s decision. It
follows that D2 satisfies agreement.
Lemma 12. The D2 protocol satisfies decision.
Proof. Let r be a run of D2 and let i ∈ P be a correct process in r. If i does not decide at time 2
of r, then it sends second-round messages to all. i is correct and its messages arrive. All the active
processes at time 3, including all the correct processes in r, receive i’s messages and therefore
participate in the consensus phase. By the decision guarantee of Beep, i decides no later than time
f + 4 in r.
Claim 4. D2 is an AC protocol in γ f .
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.    
Silence 3:21
Fig. 8. The protocol D1f1 for f = 1, which decides at time D = 1 in the nice run.
Proof. This follows directly from Lemmas 9, 10, 11, and 12.
A.3 The D1f1 Protocol
Protocol D1f1, specially tailored for the case of a single possible failure (γ 1), is presented in Figure 8.
Its proof of correctness follows.
A.3.1 Correctness of D1f1.
Claim 5. In the nice run of D1f1 in γ 1 all processes perform commit at time 1, and a total of n2 − n
messages are sent.
Proof. Let r ∈ R(D1f1,γ 1) be a run in which all processes start with 1 and no failures occur
(a nice run). Then r goes as follows: In the first round, every process successfully sends 1 to all.
Thereafter, since every process receives 1 from all in the first round, they all perform commit at
time 1. As all perform commit at time 1, no “huh? ” message is sent in the second round. Finally,
all processes halt at time 2. Hence, every process commits at time 1 in r and sends n − 1 messages
(for a total of n2 − n messages overall).
Corollary 5. The D1f1 protocol satisfies abort validity in γ 1
.
Proof. Let r be a run of D1f1 in γ 1, in which all processes start with 1 and no failures occur (a
nice run). Then by Claim 5 no process aborts in r (they all commit).
Lemma 13. The D1f1 protocol satisfies commit validity in γ 1
.
Proof. Let r ∈ R(D1f1,γ 1) be a run in which some process j ∈ P starts with vj = 0. We show
that no process commits in r. In the first round of r, j does not send 1 to anyone. Thus, at time 1,
no process receives 1 from all, therefore no process commits, and all correct processes send “huh?
” to all. Since no process commits at time 1, no all[1] messages are sent in the third round of
r. Finally, a process that reaches time 3 in r did not commit previously and did not receive any
message of all[1] in the third round, therefore, it decides abort at time 3 of r. Hence, no process
commits in r (they either abort or crash).
Lemma 14. The D1f1 protocol satisfies agreement in γ 1
.
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.    
3:22 G. Goren and Y. Moses
Proof. Let r be a run of D1f1 in γ 1
. If no process decides (to commit) at time 1 in r, then no
process halts at time 2, and no process sends all[1] in the second round. Therefore, at time 3 of r,
all decisions are made and they all are to abort. Thus, r satisfies agreement.
Consider the other case in which a process, say i, decides at time 1 in r. Obviously, i commits.
We show that all other decisions are commit as well. If i is correct in r, then it would send all[1]
to all undecided processes in the third round, thus, forcing them to perform commit at time 3 of r.
If, however, i is faulty in r, then no other process fails in r (no more than a single failure is possible
in γ 1). Hence, since i decides at time 1, it is the case that vj = 1 for all j ∈ P and no one crashes in
the first round (including i). Thus, all processes decide to commit at time 1 in r. We obtain that if
some process decides commit at time 1, then all decisions are commit, and r satisfies agreement.
The claim follows.
Lemma 15. The D1f1 protocol satisfies decision in γ 1
.
Proof. Let r be a run of D1f1. By definition of D1f1, correct processes that do not decide at
time 1 in r decide at time 3 in r. Therefore, all correct processes eventually decide in r (at time 3
latest).
Claim 6. D1f1 is an AC protocol in γ 1
.
Proof. This follows directly from Lemmas 5, 13, 14, and 15.
B COMMITTING IN MID-ROUND
Charron-Bost and Schiper [7] showed that no AC protocol tolerating f > 1 commits at time D = 1
in a nice run of γ f
. Nevertheless, Guerraoui and Wang present in Reference [16] an AC protocol
called 1NBAC that is claimed to commit after one round of communication in its nice run. The
source of the discrepancy is that Guerraoui and Wang assume a slightly different model than the
standard synchronous model γ f
. In their model, processes can decide on a value in mid-round.
In particular, in the nice run of 1NBAC, the processes commit after sending their second-round
messages and before receiving any second-round message. Thus, a crash cannot cause a process to
commit at time 1 without sending any messages in the second round. If a process commits under
this protocol, then it is guaranteed that its messages were sent successfully and will be delivered
to all correct destination process. All of the protocols that we have presented solve AC within the
stated complexity in γ˜f
. For completeness, we now present lower and upper bounds for deciding
before time 2 in γ˜f
.
The following lemma forms the basis of the analysis:
Lemma 16. Assume that f > 1, let r be the nice run of an AC protocol in γ˜f , and let i ∈ P be a
process that decides before time 2 in r. Then
(a) In the first round, process i must receive a message from every process in r, and
(b) In the second round, process i must send at least f messages before it commits.
Proof. Let r and i satisfy the assumptions in the claim’s statement. In particular, i commits
in r at time 1, perhaps after sending some messages in the second round. By Corollary 1, processi
needs to know that all initial values were 1 when it commits. If i does not receive a message from
some process j  i in the first round, then there is a run r in which vj = 0, everyone else starts
with 1, and j crashes before sending any messages. Clearly, r is a legal run, ri (1) = r
i (1), and so i
does not know that vj = 1 at time 1 in r. This establishes (a).
To prove (b), fix, in addition, a process j
 ∈ P. Since f > 1 and i has no information about
failures at time 1 in r, process i considers it possible that j
 crashed in the first round without
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.    
Silence 3:23
Fig. 9. Message-optimal AC Protocol 1.5D for γ˜f deciding before time 2.
sending messages to anyone other than i and that, in addition, i itself may crash immediately after
committing.
Recall from Lemma 4 that when i commits it must know, for every j ∈ P, that the run contains
a message chain from j to at least one correct process. If i is the only process that has heard from j

in the first round and it crashes immediately after committing, then the only way that there will be
a message chain from j
 to a correct process is if i sends messages in the second round to at least
f − 1 processes other than j
 before it commits. Since f > 1 by assumption, i must send at least
one message in round two before committing. Let h be a process to which i sends a message in the
second round before i commits. The previous argument (for the particular case in which j
 = h)
implies that i must send messages in the second round to at least f − 1 processes other than h.
Since i also sends a message to h in the second round, it follows that i must, in fact, send at least
f messages in this round before committing, establishing claim (b).
Lemma 16 states that every process that commits before time 2 in the nice run of an AC protocol
must receive at least n − 1 messages in the first round and send at least f messages in the second.
Thus, we get:
Corollary 6. For f > 1, no AC protocol in context γ˜f can commit before time 2 in its nice run
without sending messages in the second round.
Moreover, using Lemma 16 and the fact that every round-one message is received by a unique
process, and every round-two message is sent by a unique process, we obtain:
Corollary 7. Let P be an AC protocol in γ˜f
, in which all processes commit before time 2 in the
nice run. Then at least M ≥ n2 + (f − 1)n messages are sent in the nice run of P.
The bound of M ≥ n2 + (f − 1)n is smaller than the upper bound of 2n2 − 2n presented by the
1NBAC of Reference [16]. In Figure 9, we present the protocol 1.5D that decides at the same time
as 1NBAC and uses only M = n2 + (f − 1)n messages. This proves that the bound of Corollary 7 is
tight. As in Stealth, all messages of the 1.5D protocol consist of a single bit. The only non-trivial
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020. 
3:24 G. Goren and Y. Moses
message is “huh? ” which is implemented using at most one bit by being quiet to {i + 1,...,i + f }
mod n, and sending 1 to the rest.
B.1 Correctness of the 1.5D Protocol
Claim 7. In the nice run of 1.5D in γ˜f
, all processes commit at time 1 and a total of n2 + (f − 1)n
messages are sent.
Proof. Let r be the nice run of 1.5D in γ˜f
. Then r proceeds as follows: In the first round of r,
every process sends 1 to all, and they all receive the message (n − 1 messages per process). At time 1
of r every process receives 1 from all; therefore, it sends its f second round messages successfully
and then performs commit at time 1. Hence, every process commits at time 1 and sends n + f − 1
messages in r (for a total of n2 + (f − 1)n messages over all processes).
Corollary 8. All runs of 1.5D in context γ˜f satisfy abort validity.
Proof. By Claim 7, all processes commit in the nice run of 1.5D in γ˜f
.
Lemma 17. All runs of 1.5D in context γ˜f satisfy commit validity.
Proof. Let r be a run of 1.5D in γ˜f
, in which some process j ∈ P starts with vj = 0. We show
that no process commits in r. In the first round of r, process j does not send 1 to anyone. Thus, at
time 1, no process receives 1 from everyone, and therefore all processes that are active at time 1
send “huh? ” to all in the second round. Since no all[1] messages are received in the second round
of r, processes that are active at time 2 propose 0 in Beep (this includes all correct processes). By
the consensus validity property of Beep, no process decides 1 in Beep, and consequently no process
commits in r.
Lemma 18. All runs of 1.5D in context γ˜f satisfy agreement.
Proof. Let r be a run of 1.5D in γ˜f
. If all decisions in r are performed before time 2, then all
decisions are to commit, and so r satisfies agreement. If no decision is done in r before time 2, then
all decisions are according to Beep (in which all correct processes participate), and thus r satisfies
agreement. The only remaining case is when some processes decide before time 2, and some decide
at times ≥ 2.
Leti be a process that decides before time 2 inr, and leti be a process that decides at a time k ≥ 2.
We will prove that all other processes that decide in r (including i
) perform the same decision asi.
By definition of 1.5D, every decision before time 2 is commit. Thus, every process that decides
before time 2 in r, including i, decides commit. It remains to show that every decision from time 2
onward in r is commit as well. Since i commits in the second round at time 1, we have thatKiall[1]
holds at time 1 in r. Moreover, i informs a set Si of f + 1 processes (including itself) in the second
round that all[1] holds. Since i decides in r at a time k ≥ 2, it is active at time 2 in r in r, which
implies that i successfully sends “huh? ” messages to all in the second round. Hence, all processes
that are active at time 2 (including, in particular, all correct process) inr, participate in Beep starting
at time 2. The bound of f possible failures ensures us that at least one process in Si is correct and
knows all[1] in r. This correct process will propose 1 in Beep. The consensus value will thus be
1, leading to all decisions in 1.5D being to commit. Thus, they all agree with i, proving the claim
that r satisfies agreement.
Lemma 19. All runs of 1.5D in context γ˜f satisfy decision.
Proof. Let r be a run of 1.5D in γ˜f , and let i be a correct process in r. If i decides before time 2,
we are done. Assume it does not. Then by definition of 1.5D, i sends “huh? ” messages to all in the
Journal of the ACM, Vol. 67, No. 1, Article 3. Publication date: January 2020.    
Silence 3:25
second round. Consequently, all processes that are active at time 2 in r (including i and all other
correct processes in r) participate in Beep starting at time 2. As Beep completes in at most f + 1
rounds, i decides no later than time f + 3. The claim follows.
Claim 8. Protocol 1.5D (Figure 9) is an AC protocol in γ˜f
.
Proof. This follows directly by Lemmas 8, 17, 18, and 19. 