We give a new general approach for designing exact exponential-time algorithms for subset problems. In a
subset problem the input implicitly describes a family of sets over a universe of size n and the task is to
determine whether the family contains at least one set. A typical example of a subset problem is Weighted
d-SAT. Here, the input is a CNF-formula with clauses of size at most d, and an integer W . The universe is
the set of variables and the variables have integer weights. The family contains all the subsets S of variables
such that the total weight of the variables in S does not exceed W and setting the variables in S to 1 and
the remaining variables to 0 satisfies the formula. Our approach is based on “monotone local search,” where
the goal is to extend a partial solution to a solution by adding as few elements as possible. More formally,
in the extension problem, we are also given as input a subset X of the universe and an integer k. The task is
to determine whether one can add at most k elements to X to obtain a set in the (implicitly defined) family.
Our main result is that a cknO(1) time algorithm for the extension problem immediately yields a randomized
algorithm for finding a solution of any size with running time O((2 − 1
c )
n ).
In many cases, the extension problem can be reduced to simply finding a solution of size at most k. Furthermore, efficient algorithms for finding small solutions have been extensively studied in the field of parameterized algorithms. Directly applying these algorithms, our theorem yields in one stroke significant
improvements over the best known exponential-time algorithms for several well-studied problems, including d-Hitting Set, Feedback Vertex Set, Node Uniqe Label Cover, and Weighted d-SAT. Our results demonstrate an interesting and very concrete connection between parameterized algorithms and exact
exponential-time algorithms.
We also show how to derandomize our algorithms at the cost of a subexponential multiplicative factor in
the running time. Our derandomization is based on an efficient construction of a new pseudo-random object
that might be of independent interest. Finally, we extend our methods to establish new combinatorial upper
bounds and develop enumeration algorithms.
Categories and Subject Descriptors: F.2.2 [Analysis of Algorithms and Problem Complexity]: Nonnumerical Algorithms and Problems
1 INTRODUCTION
In the area of exact exponential-time algorithms, the objective is to design algorithms that outperform brute-force for computationally intractable problems. Because the problems are intractable,
we do not hope for polynomial time algorithms. Instead, the aim is to allow super-polynomial
time and design algorithms that are significantly faster than brute-force. For subset problems in
NP, where the goal is to find a subset with some specific properties in a universe of n elements, the
brute-force algorithm that tries all possible solutions has running time 2nnO(1)
. Thus, our goal is
typically to design an algorithm with running time cnnO(1) for c < 2, and we try to minimize the
constant c. We refer to the textbook of Fomin and Kratsch (2010) for an introduction to the field.
In the area of parameterized algorithms (see Cygan et al. (2015)), the goal is to design efficient
algorithms for the “easy” instances of computationally intractable problems. Here, the running
time is measured not only in terms of the input size n but also in terms of a parameter k, which is
expected to be small for “easy” instances. For subset problems, the parameter k is often chosen to
be the size of the solution sought for, and many subset problems have parameterized algorithms
that find a solution of size k (if there is one) in time cknO(1) for a constant c, which is often much
larger than 2.
In this article, we address the following question: Can an efficient algorithm for the easy instances
of a hard problem yield a non-trivial algorithm for all instances of that problem? More concretely,
can parameterized algorithms for a problem be used to speed up exact exponential-time algorithms
for the same problem? Our main result is an affirmative answer to this question: We show that,
for a large class of problems, an algorithm with running time cknO(1) for any c > 1 immediately
implies an exact algorithm with running time O((2 − 1
c )
n+o(n)
) for the problem. Our main result,
coupled with the fastest known parameterized algorithms, gives in one stroke the first non-trivial
exact algorithm for a number of problems and simultaneously significantly improves over the bestknown exact algorithms for several well-studied problems; see Table 1 for a non-exhaustive list
of corollaries. Our approach is also useful to prove upper bounds on the number of interesting
combinatorial objects and to design efficient algorithms that enumerate these objects; see Table 2.
At this point, it is worth noting that a simple connection between algorithms running in time
cknO(1) forc < 4 and exact exponential-time algorithms beating O(2n ) has been known for a long
time. For subset problems, where we are looking for a specific subset of size k in a universe of size
n, to beat O(2n ), one only needs to outperform brute-force for values of k that are very close to
n/2. Indeed, for k sufficiently far away from n/2, trying all subsets of size k takes time (
n
k )nO(1)
,
which is significantly faster than O(2n ). Thus, if there is an algorithm deciding whether there is
a solution of size at most k in time cknO(1) for some c < 4, we can deduce that the problem can
be solved in time O((2 − ϵ )
n ) for an ϵ > 0 that depends only on c. However, it is easy to see that
this trade-off between ck and (
n
k ) does not yield any improvement over 2n when c ≥ 4. Our main
result significantly outperforms the algorithms obtained by this trade-off for every value of c > 1
and further yields better than O(2n ) time algorithms even for c ≥ 4.
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.
Exact Algorithms via Monotone Local Search 8:3
As a concrete example, consider the Interval Vertex Deletion problem. Here the input
is a graph G and an integer k and the task is to determine whether G can be turned into an
interval graph by deleting k vertices. The fastest parameterized algorithm for the problem is
due to Cao (2016) and runs in time 8knO(1)
. Combining this algorithm with the simple tradeoff scheme described above does not outperform brute-force, since 8 ≥ 4. The fastest previously
known exponential-time algorithm for the problem is due to Bliznets et al. (2013) and runs in time
O((2 − ϵ )
n ) for ϵ < 10−20. However, combining the parameterized algorithm, as a black box, with
our main result immediately yields a 1.875n+o(n) time algorithm for Interval Vertex Deletion.
While we focus mostly on decision problems, by a standard self-reduction, one can also find a
smallest vertex set whose deletion makes the input graph an interval graph in time 1.875n+o(n)
.
Our Results. We need some definitions to state our results precisely. We define an implicit set
system as a function Φ that takes as input a string I ∈ {0, 1}
∗ and outputs a set system (UI , FI ),
where UI is a universe and FI is a collection of subsets of UI . The string I is referred to as an
instance, and we denote by |UI | = n the size of the universe and by |I | = N the size of the instance.
We assume that N ≥ n. The implicit set system Φ is said to be polynomial time computable if (a)
there exists a polynomial time algorithm that given I producesUI , and (b) there exists a polynomial
time algorithm that given I, UI and a subset S of UI determines whether S ∈ FI . All implicit set
systems discussed in this article are polynomial time computable, except for the minimal satisfying
assignments of d-CNF formulas, which are not polynomial time computable unless P=NP (Yato and
Seta 2003).
An implicit set system Φ naturally leads to some problems about the set system (UI , FI ). Find a
set in FI . Is FI non-empty? What is the cardinality of FI ? In this article, we will primarily focus on
the first and last problems. Examples of implicit set systems include the set of all feedback vertex
sets of a graph of size at most k, the set of all satisfying assignments of a CNF formula of weight
at most W , and the set of all minimal hitting sets of a set system. Next, we formally define subset
problems.
Φ-Subset
Input: An instance I
Output: A set S ∈ FI if one exists.
An example of a subset problem is Min-Ones d-Sat. Here for an integer k and a propositional
formula F in conjunctive normal form (CNF) where each clause has at most d literals, the task is to
determine whether F has a satisfying assignment with Hamming weight at most k, i.e., setting at
most k variables to 1. In our setting, the instance I consists of the input formula F and the integer
k, encoded as a string over 0s and 1s. The implicit set system Φ is a function from I to (UI , FI ),
where UI is the set of variables of F , and FI is the set of all satisfying assignments of Hamming
weight at most k.
Φ-Extension
Input: An instance I, a set X ⊆ UI , and an integer k.
Question: Does there exists a subset S ⊆ (UI \ X) such that S ∪ X ∈ FI and |S | ≤ k?
Our first main result gives exponential-time randomized algorithms for Φ-Subset based on singleexponential, deterministic as well as randomized, parameterized algorithms for Φ-Extension with
parameter k. Our randomized algorithms are Monte Carlo algorithms with one-sided error. On
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.
8:4 F. V. Fomin et al.
no-instances they always return no, and on yes-instances they return yes (or output a certificate)
with probability > 1
2 . Our algorithms are deterministic algorithms unless stated otherwise.
Theorem 1.1. If there exists an algorithm for Φ-Extension with running time ckN O(1)
, then there
exists a randomized algorithm for Φ-Subset with running time (2 − 1
c )
nN O(1)
.
Our second main result is that the algorithm of Theorem 1.1 can be derandomized at the cost of a
subexponential factor in n in the running time.
Theorem 1.2. If there exists an algorithm for Φ-Extension with running time ckN O(1)
, then there
exists an algorithm for Φ-Subset with running time (2 − 1
c )
n+o(n)
N O(1)
.
To exemplify the power of these theorems, we give a few examples of applications. We have already
seen the first example, the 1.875n+o(n) time algorithm for Interval Vertex Deletion. Let us now
consider the Min-Ones d-SAT problem described above.
A simple branching algorithm solves the extension problem for Min-Ones d-SAT as follows.
Suppose we have already selected a set X of variables to set to 1, remove all clauses containing
a positive literal on X, and remove negative literals on X from the remaining clauses. Start from
the all-0 assignment on the remaining variables, with a budget for flipping k variables from 0 to 1.
As long as there is an unsatisfied clause, guess which one of the at most d variables in this clause
should be flipped from 0 to 1, and for each proceed recursively with the budget decreased by one.
The recursion tree of this algorithm has depth at most k, and each node of the recursion tree has
at most d children, thus this algorithm terminates in time dk · nO(1)
.
Hence, by Theorem 1.2, Min-Ones d-SAT can be solved in time (2 − 1
d )
n+o(n)
. For d = 3 there is a
faster parameterized algorithm with running time 2.562knO(1) due to Kutzkov and Scheder (2010).
Thus, Min-Ones 3-SAT can be solved in time O(1.6097n ). Since d-Hitting Set is a special case of
Min-Ones d-SAT, the same bounds hold for this problem as well, and the same approach works for
weighted variants of these problems. However, due to faster known parameterized algorithms for
d-Hitting Set (Fomin et al. 2010), our theorem implies faster exact algorithms for d-Hitting Set
with running time (2 − 1
(d−0.9255) )
n. That is, for d-Hitting Set, d ≥ 3, there are parameterized
algorithms running in time (d − 0.9245)
k (Fomin et al. 2010), and thus combining this with our
theorem implies exact algorithms for d-Hitting Set with running time (2 − 1
(d−0.9255) )
n.
Another interesting example is the Feedback Vertex Set problem. Here, the task is to decide,
for a graph G and an integer k, whether G can be made acyclic by removing k vertices. While
this problem is trivially solvable in time 2nnO(1) for n-vertex graphs, breaking the 2n-barrier for
the problem was an open problem in the area for some time. The first algorithm breaking the
barrier is due to Razgon (2006). The running time O(1.8899n ) of the algorithm from Razgon (2006)
was improved in Fomin et al. (2008) to O(1.7548n ). Then Xiao and Nagamochi (2013) gave an
algorithm with running time O(1.7356n ). Finally, an algorithm of running time O(1.7347n ) was
obtained in Fomin et al. (2015). For the parameterized version of the problem there was also a chain
of improvements (Cao et al. 2015; Chen et al. 2008; Dehne et al. 2007; Guo et al. 2006), resulting
in a 3knO(1) time randomized algorithm (Cygan et al. 2011) and a 3.591knO(1) time deterministic
algorithm (Kociumaka and Pilipczuk 2014). This, coupled with our main theorem, immediately
gives us randomized and deterministic algorithms of running times O(1.6667n ) and O(1.7216n ),
respectively.
More generally, let Π be a hereditary family of graphs. That is, if G ∈ Π then so are all its induced subgraphs. Examples of hereditary families include the edgeless graphs, forests, bipartite
graphs, chordal graphs, interval graphs, split graphs, and perfect graphs. Of course, this list is not
exhaustive. For every hereditary graph family Π there is a natural vertex deletion problem, which
we define here.
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.
Exact Algorithms via Monotone Local Search 8:5
Π-Vertex Deletion
Input: An undirected (or directed) graph G and an integer k.
Question: Is there a set S ⊆ V (G) with |S | ≤ k such that G − S ∈ Π?
We can cast Π-Vertex Deletion as a Φ-Subset problem as follows. The instance I describes
the graph G, so UI = V (G) and FI is the family of subsets S of V (G) of size at most k such that
G − S ∈ Π. Notice that a polynomial time algorithm to determine whether a graph G is in Π yields
a polynomial time algorithm to determine whether a set S is in FI , implying that Φ is polynomial
time computable. Moreover, a ckN O(1) time algorithm for Π-Vertex Deletion trivially gives the
same running time for its extension variant, since vertices in X can simply be deleted. Also, if Π
is characterized by a set of forbidden induced subgraphs, which all have at most d vertices, such
as cographs (d = 4) (Corneil et al. 1981) and split graphs (d = 5) (Hammer and Földes 1977), we
can reduce the Π-Vertex Deletion problem to d-Hitting Set where the number of elements is the
number of vertices of the input graph.
In Table 1, we list more applications of Theorem 1.2. We also provide the running times of
the fastest known parameterized and exact algorithms. The problem definitions are given in the
appendix. For most of these problems, the results are obtained by simply using the fastest known
parameterized algorithm in combination with Theorem 1.2. The results for Weighted d-Hitting
Set follow from a variant that relies on algorithms for a permissive version of Φ-Extension; see
Section 2.3.
We also extend the technique to enumeration problems and to prove combinatorial upper
bounds. For example, a minimal satisfying assignment of a d-CNF formula is a satisfying assignment a such that no other satisfying assignment sets every variable to 0 that a sets to 0. In other
words, a satisfying assignment a is minimal, if setting any variable assigned 1 to 0 leads to an unsatisfying assignment. It is interesting to investigate the number of minimal satisfying assignments of
d-CNF formulas, algorithms to enumerate these assignments, and upper bounds and enumeration
algorithms for other combinatorial objects.
Formally, let Φ be an implicit set system and c ≥ 1 be a real-valued constant. We say that Φ
is c-uniform if, for every instance I, set X ⊆ UI , and integer k ≤ n − |X |, the cardinality of the
collection
F k
I,X = {S ⊆ UI \ X : |S | = k and S ∪ X ∈ FI }
is at mostcknO(1)
. The next theorem will provide new combinatorial upper bounds for collections
generated by c-uniform implicit set systems.
Theorem 1.3. Let c > 1 and Φ be an implicit set system. If Φ is c-uniform, then
|FI | ≤ (2 − 1
c )
nnO(1) for every instance I.
We say that an implicit set system Φ is efficiently c-uniform if there exists an algorithm that
given I, X and k enumerates all elements of F k
I,X in time ckN O(1)
. In this case, we can enumerate
FI in time (2 − 1
c )
n+o(n)
N O(1)
.
Theorem 1.4. Let c > 1 and Φ be an implicit set system. If Φ is efficiently c-uniform, then there is
an algorithm that given as input I enumerates FI in time (2 − 1
c )
n+o(n)
N O(1)
.
For minimal satisfying assignments of d-CNF formulas, we observe that the afore-mentioned
branching algorithm for the extension version of Min-Ones d-Sat, which explores the Hamming
ball of radius k around the all-0 assignment of the reduced instance, encounters all minimal satisfying assignments extending X by at most k variables. Thus, minimal satisfying assignments for
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.
8:6 F. V. Fomin et al.
Table 1. Summary of Known and New Results for Different Optimization Problems
Problem Name Parameterized New bound Previous Bound
Feedback Vertex Set 3k (r) (h) 1.6667n (r)
Feedback Vertex Set 3.592k (q) 1.7217n 1.7347n (m)
Subset Feedback Vertex Set 4k (v) 1.7500n 1.8638n (l)
Feedback Vertex Set in Tournaments 1.6181k (r) 1.3820n 1.4656n (r)
Group Feedback Vertex Set 4k (v) 1.7500n NPR
Node Uniqe Label Cover |Σ|
2k (v) (2 − 1
|Σ|
2 )
n NPR
Vertex (r, )-Partization (r,  ≤ 2) 3.3146k (b) 1.6984n NPR
Interval Vertex Deletion 8k (e ) 1.8750n (2 − ε)
n for ε < 10−20 (c )
Proper Interval Vertex Deletion 6k (n) 1.8334n (2 − ε)
n for ε < 10−20 (c )
Block Graph Vertex Deletion 4k (a) 1.7500n (2 − ε)
n for ε < 10−20 (c )
Cluster Vertex Deletion 1.9102k (d) 1.4765n 1.6181n (i)
Thread Graph Vertex Deletion 8k (p) 1.8750n NPR
Multicut on Trees 1.5538k (o) 1.3565n NPR
3-Hitting Set 2.0755k (u) 1.5182n 1.6278n (u)
4-Hitting Set 3.0755k (i) 1.6750n 1.8704n (i)
d-Hitting Set (d ≥ 3) (d − 0.9245)
k (i) (2 − 1 (d−0.9245) )
n (д)
Min-Ones 3-SAT 2.562k (s ) 1.6097n NPR
Min-Ones d-SAT (d ≥ 4) dk (2 − 1
d )
n NPR
Weighted d-SAT (d ≥ 3) dk (2 − 1
d )
n NPR
Weighted Feedback Vertex Set 3.6181k (a) 1.7237n 1.8638n (k)
Weighted 3-Hitting Set 2.168k (t) 1.5388n 1.6755n (f )
Weighted d-Hitting Set (d ≥ 4) (d − 0.832)
k (j) (2 − 1 d−0.832 )
n (f )
NPR means that we are not aware of any previous algorithms faster than brute-force. All bounds suppress factors polynomial in the input size N . The algorithms in the first row are randomized (r).
(a) Agrawal et al. (2016) (l)
Fomin et al. (2014)
(b)
Baste et al. (2015), Kolay and Panolan (2015) (m)
Fomin et al. (2015)
(c )
Bliznets et al. (2013) (n)
Cao (2015), van ’t Hof and Villanger (2013)
(d)
Boral et al. (2014) (o)
Kanj et al. (2014)
(e )
Cao (2016) (p)
Kanté et al. (2015)
(f )
Cochefert et al. (2016) (q)
Kociumaka and Pilipczuk (2014)
(д)
Cochefert et al. (2016), Fomin et al. (2010) (r )
Kumar and Lokshtanov (2016)
(h)
Cygan et al. (2011) (s )
Kutzkov and Scheder (2010)
(i)
Fomin et al. (2010) (t )
Shachnai and Zehavi (2017)
(j)
Fomin et al. (2010), Shachnai and Zehavi (2017) (u)
Wahlström (2007)
(k)
Fomin et al. (2008) (v)
Wahlström (2014)
d-CNF formulas are d-uniform. It follows immediately that minimal d-hitting sets are d-uniform
and they are also efficiently d-uniform.
A tournament is a directed graph (digraph) in which every pair of distinct vertices is connected
by a single directed edge. That is, it is an orientation of a complete graph. An induced subgraph
of a tournament is called a subtournament. Furthermore, a (sub)tournament is called transitive if
it does not contain any directed cycle. By a classical theorem of Moon from 1971 (Moon 1971) the
number of maximal transitive subtournaments in an n-vertex tournament does not exceed 1.7170n.
Gaspers and Mnich (2013) improved this bound to 1.6740n. It is well known that a (sub)tournament
is transitive if and only if it does not contain a directed cycle of length 3 (directed 3-cycle). Using
this characterization our approach yields immediately a better bound of O(1.6667n ), since every
directed 3-cycle needs to be hit. Similarly, in chordal graphs, a set is a feedback vertex set (FVS)
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.  
Exact Algorithms via Monotone Local Search 8:7
Table 2. Summary of Known and New Results for Different Combinatorial Bounds
Problem Name c-uniform New bound Previous Bound
Minimal FVSs in Tournaments 3 1.6667n 1.6740n (a)
Minimal 3-Hitting Sets 3 1.6667n 1.6755n (b)
Minimal 4-Hitting Sets 4 1.7500n 1.8863n (b)
Minimal 5-Hitting Sets 5 1.8000n 1.9538n (b)
Minimal d-Hitting Sets d (2 − 1
d )
n (2 − ϵd )
n with ϵd < 1/d (b)
Minimal d-Sat (d ≥ 2) d (2 − 1
d )
n NPR
Minimal FVSs in chordal graphs 3 1.6667n 1.6708n (c )
Minimal Subset FVSs in chordal graphs 3 1.6667n NPR
Maximal r-colorable induced subgraphs of perfect graphs r + 1 (2 − 1
r+1 )
n NPR
NPR means that we are not aware of any previous results better than 2n. All bounds suppress factors polynomial in the
universe size n. (a)
Gaspers and Mnich (2013)
(b)
Cochefert et al. (2016)
(c )
Golovach et al. (2013).
if it hits every 3-cycle. For maximal r-colorable induced subgraphs of perfect graphs it suffices to
hit every clique of size r + 1. Some consequences of our results for enumeration algorithms and
combinatorial bounds are given in Table 2.
Local Search versus Monotone Local Search. One of the successful approaches for obtaining
exact exponential-time algorithms for d-SAT is based on sampling and local search. In his breakthrough article, Schöning (1999) introduced the following simple and elegant approach: Sample a
random assignment and then do a local search in a Hamming ball of small radius around this assignment. With the right choice of the parameter for the local search algorithm (the Hamming distance, in this case), it is possible to prove that with a reasonable amount of samples this algorithm
decides the satisfiability of a given formula with good probability. The running time of Schöning’s
algorithm on formulas with n variables is O((2 − 2/d)
n ) and it was shown by Moser and Scheder
(2011) how to derandomize it in almost the same running time, see also Dantsin et al. (2002).
While this method has been very successful for satisfiability, it is not clear how to apply this
approach to other NP-complete problems, in particular, to optimization problems, like finding a
satisfying assignment of Hamming weight at most k or finding a hitting set of size at most k. The
reason why Schöning’s approach cannot be directly applied to optimization problems is that it is
very difficult to get efficient local search algorithms for these problems.
Consider, for example, Min-Ones d-Sat. If we select some assignment a as a center of Hamming ball Br of radius r, then there is a dramatic difference between searching for any satisfying
assignment in Br , and a satisfying assignment of Hamming weight at most k in Br . In the first
case the local search problem can be solved in time dr · nO(1)
. In the second case, we do not know
any better alternative to a brute-force search. Indeed, an algorithm with running time on the form
f (r) · nO(1) for any function f would imply that FPT = W[1]. This issue is not specific to MinOnes d-Sat: it is known that the problem of searching a Hamming ball Br of radiusr is W[1]-hard
parameterized by r for most natural optimization problems (Fellows et al. 2012).
Despite this obstacle, our approach is based on sampling an initial solution, and then performing
a local search from that solution. The way we get around the hardness of local search is to make the
local search problem easier, at the cost of reducing the success probability of the sampling step.
Specifically, we only consider monotone local search, where we are not allowed to remove any
elements from the solution, and only allowed to add at most k new elements. Instead of searching
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.
8:8 F. V. Fomin et al.
a Hamming ball around the initial solution, we look for a solution in a Hamming cone. Monotone
local search is equivalent to the extension problem, and it turns out that the extension problem
can very often be reduced to the problem of finding a solution of size at most k. This allows us to
use for our monotone local search the powerful toolbox developed for parameterized algorithms.
Our Approach. Our algorithm is based on random sampling. Suppose we are looking for a solution S of size k in a universe U of size n, and we have already found some set X of size t, which
we know is a subset of S. At this point, one option we have is to run the extension algorithm—this
would take time ck−t · nO(1)
. Another option is to pick a random element x ∈ U \ X, add x to X,
and then proceed. We succeed if x is in S \ X, so the probability of success is at least (k − t)/(n − t).
If we succeed in picking x from S \ X, then k − t drops by 1, so running the extension algorithm
on X ∪ {x} is a factorc faster than running it on X. Therefore, as long as (k − t)/(n − t) ≥ 1/c it is
better to keep sampling vertices and adding them to X. When (k − t)/(n − t) < 1/c it is better to
run the algorithm for the extension problem. This is the entire algorithm!
While the description of the algorithm used to obtain Theorem 1.1 is simple, the analysis is a bit
more involved. In particular, getting the right upper bound on the running time of the algorithm
requires more work. At a first glance it is not at all obvious that a 100k · nO(1) time algorithm for
the extension problem gives any advantage over trying all subsets of size k in (
n
k ) time. To see why
our approach outperforms (
n
k ), it is helpful to think of the brute-force algorithm as a randomized
algorithm that picks a random subset of size k by picking one vertex at a time and inserting it into
the solution. The success probability of such an algorithm is at least
k
n ·
k − 1
n − 1 ·
k − 2
n − 2 · ... · 2
n − (k − 2) · 1
n − (k − 1) = 1
(
n
k )
.
Notice that in the beginning of the random process the success probability of each step is high,
but that it gets progressively worse, and that in the very end it is close to 1/n. At some point, we
have picked t vertices and (k − t)/(n − t) drops below 1/c. Here, we run the extension algorithm,
spending time ck−t , instead of continuing with brute-force, which would take time

n − t
k − t

= n − t
k − t ·
n − t − 1
k − t − 1 · ... ·
n − k + 2
2 ·
n − k + 1
1 ,
which is a product of k − t larger and larger terms, with even the first and smallest term being
greater than c. Thus, we can conclude that any ck algorithm will give some improvement over 2n.
Notice that if the algorithm is looking for a set of size k in a universe of size n, the number t
of vertices to sample before the algorithm should switch from picking more random vertices to
running the extension algorithm can directly be deduced from n, k, and c. The algorithm picks a
random set X of size t, and runs the extension algorithm on X. We succeed if X is a subset of a
solution, hence the success probability is p = (
k
t )/(
n
t ). To get constant success probability, we run
the algorithm 1/p times, taking time ck−t · nO(1) for each run.
To derandomize the algorithm, we show that it is possible to construct in time (1/p) · 2o(n) a
family F of sets of size t, such that |F | ≤ (1/p) · 2o(n)
, and every set of size k has a subset of size
t in F . Thus, it suffices to construct F and run the extension algorithm on each set X in F . The
construction of the family F borrows ideas from Naor et al. (1995); however, their methods are not
directly applicable to our setting. We also refer to the work of Alon and Gutner (2010) in this line
of research. Our construction appears in Theorem 1.2 and constitutes one of the main technical
contributions of the article.
The main conceptual contribution of this article is a non-trivial generalization of local-search
based satisfiability algorithms to a wide class of optimization problems. Instead of covering the
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.  
Exact Algorithms via Monotone Local Search 8:9
search space by Hamming balls, we cover it by Hamming cones and use a parameterized algorithm
to search for a solution in each of the cones.
2 COMBINING RANDOM SAMPLING WITH FPT ALGORITHMS
In this section, we prove our main results, Theorems 1.1–1.4, which will give new algorithms to
find a set in FI and to enumerate the sets in FI . For many potential applications, the objective is to
find a minimum-size set with certain properties, for example, that the removal of this set of vertices
yields an acyclic graph. This can easily be done using the algorithms resulting from Theorems 1.1
and 1.2 with only a polynomial overhead by using binary search over k, the size of the targeted
set S, and specifying that FI contains only sets of size at most k.
2.1 Picking Random Subsets of the Solution
This subsection is devoted to the proof of Theorem 1.1 that we recall here. Note that the algorithm mentioned in Theorem 1.1 is a Monte Carlo algorithm with one-sided error. That is, on
no-instances it always returns no, and on yes-instances it returns yes (or output a certificate) with
probability > 1
2 . Recall that Φ-Extension is the following problem: Given an instance I, a subset
X ⊆ UI , and an integer k, find a set S ⊆ UI \ X with |S | ≤ k such that X ∪ S ∈ FI .
Theorem 1.1. If there exists an algorithm for Φ-Extension with running time ckN O(1)
, then there
exists a randomized algorithm for Φ-Subset with running time (2 − 1
c )
nN O(1)
.
The theorem will follow from the following lemma, which gives a new randomized algorithm
for Φ-Extension. The next lemma formalizes the intuition given in our approach paragraph of the
the introduction.
Lemma 2.1. If there is a constant c > 1 and an algorithm for Φ-Extension with running
time ckN O(1)
, then there is a randomized algorithm for Φ-Extension with running time (2 − 1
c )
n− |X |
N O(1)
.
Proof. Let B be an algorithm for Φ-Extension with running time ckN O(1)
. We now give another algorithm, A, for the same problem. A is a randomized algorithm and consists of the following two steps for an input instance (I,X, k
) with k ≤ k.
(1) Choose an integer t ≤ k depending on c, n, k and |X |, and then select a random subset
Y of UI \ X of size t. The choice of t will be discussed towards the end of the proof.
(2) Run Algorithm B on the instance (I,X ∪ Y, k − t) and return the answer.
This completes the description of Algorithm A. Since the running time of step (1) is polynomial
in N, the running time of the whole algorithm is upper bounded by ck
−tN O(1)
.
If A returns yes for (I,X, k
), then this is because B returned yes for (I,X ∪ Y, k − t). In this
case, there exists a set S ⊆ UI \ (X ∪ Y ) of size at most k − t ≤ k − t such that S ∪ X ∪ Y ∈ FI .
Thus, Y ∪ S witnesses that (I,X, k) is indeed a yes-instance.
Next, we lower bound the probability that A returns yes in case there exists a set S ⊆ UI \ X
of size exactly k such that X ∪ S ∈ FI . The algorithm A picks a set Y of size t at random from
UI \ X. There are (
n− |X |
t ) possible choices for Y. If A picks one of the (
k
t ) subsets of S as Y, then
A returns yes. Thus, given that there exists a set S ⊆ UI \ X of size k such that X ∪ S ∈ FI , we
have that
Pr[A returns yes] ≥ Pr[Y ⊆ S] =

k
t
 n − |X |
t

.
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.
8:10 F. V. Fomin et al.
Let p(k
) = (
k
t )/(
n− |X |
t ). For each k ∈ {0,..., k}, our main algorithm runs A independently
1/p(k
) times with parameter k
. The algorithm returns yes if any of the runs of A return
yes. If (I,X, k) is a yes-instance, then the main algorithm returns yes with probability at least
mink≤k {1 − (1 − p(k
))1/p(k
)
} ≥ 1 − 1
e > 1
2 . Next, we upper bound the running time of the main
algorithm, which is

k≤k
1
p(k) ·ck
−t
N O(1) ≤ max
k≤k
(
n− |X |
t )
(
k
t ) ·ck
−t
N O(1)
≤ max
k ≤n− |X |
(
n− |X |
t )
(
k
t ) ·ck−t
N O(1)
.
We are now ready to discuss the choice of t in the algorithm A. The algorithm A chooses the
value for t that gives the minimum value of ( n−|X |
t )
( k
t ) ·ck
−t . Thus, for fixed n and |X | the running
time of the algorithm is upper bounded by
max 0≤k ≤n− |X |
⎧⎪
⎨
⎪
⎩
min
0≤t ≤k
⎧⎪
⎨
⎪
⎩
(
n− |X |
t )
(
k
t ) ck−t
N O(1)
⎫⎪
⎬
⎪
⎭
⎫⎪
⎬
⎪
⎭
. (1)
We upper bound the expression in (1) by (2 − 1
c )
n− |X |
N O(1) in Lemma 2.3 below. The running time
of the algorithm is thus upper bounded by (2 − 1
c )
n− |X |
N O(1)
, completing the proof.
Remark 2.2. The proof of Lemma 2.1 goes through just as well when B is a randomized algorithm. If B is deterministic or has one-sided error (possibly saying no whereas it should say
yes), then the algorithm of Lemma 2.1 also has one sided error. If B has two sided error, then the
algorithm of Lemma 2.1 has two sided error as well.
Now, we give the technical lemma that was used to upper bound the running time of the algorithm described in Lemma 2.1.
Lemma 2.3. Let c > 1 be a fixed constant, and let n be a non-negative integer. Then,
max
0≤k ≤n
⎧⎪
⎨
⎪
⎩
min
0≤t ≤k
⎧⎪
⎨
⎪
⎩
(
n
t )
(
k
t )
ck−t
⎫⎪
⎬
⎪
⎭
⎫⎪
⎬
⎪
⎭
≤

2 − 1
c
n
nO(1)
.
Proof. For k ≤ n/c, we can choose t = 0 and obtain that the expression is at most cn/c ≤ (2 −
1/c)
n.
Now, assume k > n/c. We have that

n
t
	

k
t
	ck−t = n!
t!(n − t)!
·
t!(k − t)!
k! ·
(n − k)!
(n − k)!
·ck−t
=

n
k
	

n−t
k−t
	  1
c
	k−t . (2)
Let us lower bound the denominator. Using ordinary generating functions, one can show that, for
any x ∈ [0, 1) and any integer m ≥ 0,

i ≥0

m + i
i

xi =

i ≥0

m + i
m

xi = 1
(1 − x)m+1 ,
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.   
Exact Algorithms via Monotone Local Search 8:11
and this identity is well-known. Setting m = n − k and x = 1/c, the summand at i = k − t equals
the denominator of Equation (2). Remember that we aim to choose a value fort, and therefore also
for i that maximizes the denominator. Let us first show that the maximum term of the sum occurs
when i ≤ k. When i > k, we can rewrite a term of the sum as
(m + i)!
i! · m! · xi
= (m + i) · (m + i − 1) · ... · (m + k + 1) · (m + k) · ... · (m + 1)
i˙
(i − 1) · ... · (k + 1) · (k) · ... · 1 xi−k · xk
=m + i
i · x ·
m + i − 1
i − 1 · x · ... ·
m + k + 1
k + 1 · x ·
(m + k) · (m + k − 1) · ... · (m + 1)
(k) · (k − 1) · ... · 1 · xk .
Let Γk = (m+k)·(m+k−1)·...·(m+1)
(k)·(k−1)·...·1 · xk . The quantity Γk corresponds to the (k + 1)th term of the sum.
Furthermore, since n
k < c, we have that m+j
j · x < 1 whenever j ≥ k. This implies that any term
after (k + 1)th term of the sum is less than Γk . From here, we conclude that the maximum term of
the sum occurs for i ≤ k. Then expanding the sum for i > k and extracting Γk from each term, we
get
m + k + 1
k + 1 · x + m + k + 2
k + 2 · x ·
m + k + 1
k + 1 · x + ··· m + k + 3
k + 3 · x ·
m + k + 2
k + 2 · x ·
m + k + 1
k + 1 · x + ···
This sum is upper bounded by the following sum:

j ≥1

m + k + 1
k + 1
j
· xj
. (3)
This is a geometric series with ratio m+k+1
k+1 x < 1. Now, since the sum of a geometric series converges for coefficients in [0; 1), we also have that the series in Equation (3) can be upper bounded
by a constant. Therefore, the sum of the terms fori > k can be upper bounded by a constant times
the largest summand. We conclude that the value of the largest summand is Ω(( 1
1−x )
m ) up to a
lower order factor of O(k). So, Equation (2) is at most

n
k

(1 − x)
n−knO(1) =

2 − 1
c
n
nO(1)
by the binomial theorem.
By running the algorithm from Lemma 2.1 with X = ∅ and for each value of k ∈ {0,...,n}, we
obtain an algorithm for Φ-Subset, and this proves Theorem 1.1.
2.2 Derandomization
In this section, we prove Theorem 1.2 by derandomizing the algorithm of Theorem 1.1, at the cost
of a subexponential factor in the running time. Recall Theorem 1.2.
Theorem 1.2. If there exists an algorithm for Φ-Extension with running time ckN O(1)
, then there
exists an algorithm for Φ-Subset with running time (2 − 1
c )
n+o(n)
N O(1)
.
The key tool in our derandomization is a new pseudo-random object, which we call setinclusion-families, as well as an almost optimal (up to subexponential factors) construction of
such objects.
Definition 2.4. Let U be a universe of size n and let 0 ≤ q ≤ p ≤ n. A family C ⊆ (
U
q ) is an
(n,p,q)-set-inclusion-family, if for every set S ∈ (
U
p ), there exists a set Y ∈ C such that Y ⊆ S.
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.   
8:12 F. V. Fomin et al.
Let κ(n,p,q) = (
n
q )/(
p
q ). Observe that that κ−1 (n,p,q) is exactly the probability of a fixed p sized
set being covered by a randomly selected q-sized set. Let t = κ(n,p,q) · nO(1)
. Construct the family
C = {C1,...,Ct } by selecting each setCi independently and uniformly at random from (
U
q ). Then,
using an application of probabilistic method one can show that C is an (n,p,q)-set-inclusionfamily with a positive probability. We give details of this construction in Lemma 3.1. However, to
obtain a deterministic algorithm, we need an efficient and deterministic construction. In Section 3
(Theorem 3.3), we give a deterministic construction of an (n,p,q)-set-inclusion-family, C, of size
at most κ(n,p,q) · 2o(n)
. The running time of the algorithm constructing C is also upper bounded
by κ(n,p,q) · 2o(n)
. This construction crucially uses a constructive version of Lemma 3.1.
The proof of Theorem 1.2 is now almost identical to the proof of Theorem 1.1. However, in
Lemma 2.1, we replace the sampling step where the algorithm A picks a set Y ⊆ UI \ X of size
t at random, with a construction of an (n − |X |, k
,t)-set-inclusion-family C using Theorem 3.3.
Instead of κ(n − |X |, k
,t) · nO (1) independent repetitions of the algorithm A, the new algorithm
loops over all Y ∈ C. The correctness follows from the definition of set-inclusion-families, while
the running-time analysis is identical to the analysis of Lemma 2.1.
2.3 Extension to Permissive FPT Subroutines
For some of our applications, specifically the ones for weighted hitting set problems, our results
rely on algorithms for permissive variants of the Φ-Extension problem. Permissive problems were
introduced in the context of local search algorithms (Marx and Schlotter 2011) and it has been
shown that permissive variants can be fixed-parameter tractable even if the strict version is W[1]-
hard and the optimization problem is NP-hard (Gaspers et al. 2012).
Permissive Φ-Extension
Input: An instance I, a set X ⊆ UI , and an integer k.
Question: If there is a subset S ⊆ (UI \ X) such that S ∪ X ∈ FI and |S | ≤ k, then answer yes;
else if |FI | > 0, then answer yes or no;
else answer no.
We observe that any algorithm solving Φ-Extension also solves Permissive Φ-Extension. However, using an algorithm for Permissive Φ-Extension will only allow us to solve a decision variant
of the Φ-Subset problem, unless it also returns a certificate in case it answers yes.
Decision Φ-Subset
Input: An instance I
Question: Is |FI | > 0?
The proof of Lemma 2.1 can easily be adapted to the Permissive Φ-Extension problem.
Lemma 2.5. If there exists a constant c > 1 and an algorithm for Permissive Φ-Extension with
running time ckN O(1)
, then there exists a randomized algorithm for Permissive Φ-Extension with
running time (2 − 1
c )
n− |X |
N O(1)
.
Now, any algorithm for Permissive Φ-Extension also solves Decision Φ-Subset. If the algorithm
for Permissive Φ-Extension also returns a certificate whenever it answers yes, then this also leads
to an algorithm for Φ-Subset. Again, these algorithms can be derandomized at the cost of a factor
2o(n) in the running time.
Theorem 2.6. If there is an algorithm for Permissive Φ-Extension with running time ckN O(1)
,
then there is an algorithm for Decision Φ-Subset with running time (2 − 1
c )
n+o(n)
N O(1)
. Moreover,
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.
Exact Algorithms via Monotone Local Search 8:13
if the algorithm for Permissive Φ-Extension computes a certificate whenever it answers yes, then
there is an algorithm for Φ-Subset with running time (2 − 1
c )
n+o(n)
N O(1)
.
2.4 Enumeration and Combinatorial Upper Bounds
In this subsection, we prove Theorems 1.3 and 1.4 on combinatorial upper bounds and enumeration
algorithms. Let us first restate Theorem 1.3.
Theorem 1.3. Let c > 1 and Φ be an implicit set system. If Φ is c-uniform, then |FI | ≤ (2 − 1
c )
nnO(1) for every instance I.
For the intuition behind Theorem 1.3, consider the following random process:
(1) Choose an integer t based on c, n, and k, then randomly sample a subset X of size t from
UI .
(2) Uniformly at random pick a set S from F k−t I,X , and output W = X ∪ S. In the special case
where F k−t I,X is empty return the empty set.
An analysis similar to the one in Lemma 2.1 shows that each set in the family FI is selected with
probability at least (2 − 1
c )
−n · n−O(1)
. This implies that there are at most (2 − 1
c )
nnO(1) such sets.
Next, we formalize this intuition.
Proof of Theorem 1.3. Let I be an instance and k ≤ n. We prove that the number of sets in FI
of size exactly k is upper bounded by (2 − 1
c )
nnO(1)
. Since k is chosen arbitrarily the bound on |FI |
will follow. We describe below a random process that picks a set W of size k from FI as follows.
(1) Choose an integer t based on c, n, and k, then randomly sample a subset X of size t from
UI .
(2) Uniformly at random, pick a set S from F k−t I,X , and output W = X ∪ S. In the corner case
where F k−t I,X is empty, return the empty set.
This completes the description of the process.
For each set Z ∈ FI of size exactly k, let EZ denote the event that the setW output by the random
process above is equal to Z. Now, we lower bound the probability of the event EZ . We have the
following lower bound.
Pr[EZ ] = Pr[X ⊆ Z ∧ S = Z \ X]
= Pr[X ⊆ Z] × Pr[S = Z \ X | X ⊆ Z] (4)
= (
k
t )
(
n
t )
×
1
|F k−t I,X |
.
Since Φ is c-uniform, we have that |F k−t I,X | ≤ ck−t
nO(1)
, hence
Pr[EZ ] ≥
(
k
t )
(
n
t )
c−(k−t)
n−O(1)
.
We are now ready to discuss the choice oft in the random process. The integert is chosen such that
the preceding expression for Pr[EZ ] is maximized (or, in other words, its reciprocal is minimized).
By Lemma 2.3, we have that for every k ≤ n there exists a t ≤ k such that
(
k
t )
(
n
t )
c−(k−t) ≥

2 − 1
c
−n
· n−O(1)
.
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.  
8:14 F. V. Fomin et al.
Hence, Pr[EZ ] ≥ (2 − 1
c )
−n · n−O(1) for every Z ∈ FI of size k. Since the events EZ are disjoint for
all the different sets Z ∈ FI , we have that

Z ∈FI
|Z |=k
Pr[EZ ] ≤ 1.
This, together with the lower bound on Pr[EZ ] implies that the number of sets in FI of size exactly
k is upper bounded by (2 − 1
c )
nnO(1)
, completing the proof.
If the implicit set system Φ is efficiently c-uniform, then the proof of Theorem 1.3 can be made
constructive by replacing the sampling step by a construction of an (n, k,t)-set-inclusion-family
C using Theorem 3.3. For each X ∈ C the algorithm uses the fact that Φ is efficiently c-uniform to
loop over all sets S ∈ F k−t I,X and output X ∪ S for each such S. Looping over C instead of sampling
X incurs a 2o(n) overhead in the running time of the algorithm. To avoid enumerating duplicates,
we also store each set that we output in a trie and for each set that we output, we check first in
linear time whether we have already output that set.
Theorem 1.4. Let c > 1 and Φ be an implicit set system. If Φ is efficiently c-uniform, then there is
an algorithm that given as input I enumerates FI in time (2 − 1
c )
n+o(n)
N O(1)
.
3 EFFICIENT CONSTRUCTION OF SET-INCLUSION-FAMILIES
In this section, we give the promised construction of set-inclusion-families. The (n,p,q)-setinclusion-family is actually related to (n, k,l) covering design (Kuzjurin 2000; Jukna 2011), and
it is very plausible that a modification of these known constructions can be used for our purposes.
It is also related to the concepts of splitters and universal sets introduced by Naor et al. (1995).
Here, we present a simple and self-contained construction. We start by giving a construction of
set-inclusion-families with good bounds on the size, but with a poor bound on the construction
time. Recall that κ(n,p,q) = (
n
q )/(
p
q ).
Before proceeding with the technical proof of Theorem 3.3, let us provide a high-level overview.
The proof is based on the following ideas.
(a) Existential Proof (Lemma 3.1). This lemma shows that there exists an (n,p,q)-setinclusion-family C of size at most κ(n,p,q) · nO(1)
. Essentially, it shows that if we construct the family C = {C1,...,Ct } by selecting each set Ci independently and uniformly
at random from (
U
q ), then with positive probability C is indeed an (n,p,q)-set-inclusionfamily. This also leads to not “so fast algorithm” to design the family C using an approximation algorithm for the Set Cover problem.
(b) Universe Reduction. The construction obtained in Lemma 3.1 has only one drawback—
the time is much larger what we can afford. To overcome this lacuna, we do not apply the
construction in Lemma 3.1 directly. We first prove a result that helps us in reducing
the universe size to something smaller. This is done using the known construction of
pairwise independent hash families of size O(n2). This makes the universe small enough
that we can apply the construction given in Lemma 3.1.
Lemma 3.1. There is an algorithm that given n, p and q outputs an (n,p,q)-set-inclusion-family C
of size at most κ(n,p,q) · nO(1) in time O(8n ).
Proof. We start by giving a randomized algorithm that with positive probability constructs an
(n,p,q)-set-inclusion-family C with the claimed size. We will then discuss how to deterministically
compute such a C within the required time bound. Set t = κ(n,p,q) · (p + 1) logn and construct
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019. 
Exact Algorithms via Monotone Local Search 8:15
the family C = {C1,...,Ct } by selecting each set Ci independently and uniformly at random from
(
U
q ).
By construction, the size of C is within the required bounds. We now argue that with positive
probability C is indeed an (n,p,q)-set-inclusion-family. For a fixed set A ∈ (
U
p ), and integer i ≤ t,
we consider the probability that Ci ⊆ A. This probability is 1/κ(n,p,q). Since each Ci is chosen
independently from the other sets in C, the probability that no Ci satisfies Ci ⊆ A is

1 − 1
κ(n,p,q)
t
≤ e−(p+1) log n ≤
1
np+1 .
There are (
n
p ) choices for A ∈ (
U
p ), therefore the union bound yields that the probability that there
exists an A ∈ (
U
p ) such that no set Ci ∈ C satisfies Ci ⊆ A is upper bounded by 1
np+1 · np = 1
n .
To construct C within the stated running time, proceed as follows. We construct an instance of
Set Cover, and then, using a known approximation algorithm for Set Cover, we construct the
desired family. An instance of Set Cover consists of a universe U and a family S of subsets of U.
The objective is to find a minimum sized sub-collection S  ⊆ S such that the union of elements
of the sets in S  is U. It is known (Johnson 1974) that Set Cover admits a polynomial time
approximation algorithm with factor O(log |U|). For our problem, the elements of the universe U
are uA for every A ∈ (
U
p ). For every set B ∈ (
U
q ), let FB consist of all the elements uA ∈ U such that
B ⊆ A. The set family S contains FB for each choice of B ∈ (
U
q ). Given a sub-collection S  ⊆ S ,
we construct the family C(S 
) by taking the sets B ∈ (
U
q ) such that FB ∈ S 
. Clearly, any C(S 
)
corresponding to a sub-collection S  ⊆ S covering U is a (n,p,q)-set-inclusion-family, and vice
versa.
Let OPT denote the size of a minimum sized sub-collection S  ⊆ S covering U. We run the
known O(log |U|)-factor approximation algorithm on our instance and obtain a sub-collection
S  ⊆ S covering U. Let C = C(S 
). By the preceding discussions, we know that C is an (n,p,q)-
set-inclusion-family. Clearly, the size of C is upper bounded by
|C| ≤ OPT · O(log |U|) ≤ t · O(log |U|)
≤ O(t(lognp )) ≤ κ(n,p,q) · nO(1)
.
It is well known that one can implement the approximation algorithm for Set Cover to run in
time O(|U| · 

S ∈S |S |) = O(( n
p ) · (
n
q )( n−q
p−q )) = O(2n · 2n · 2n ) = O(8n ) (Korte and Vygen 2012).
This concludes the proof.
Next, we will reduce the problem of finding an (n,p,q)-set-inclusion-family to the same problem,
but with a much smaller value of n. To that end, we will use a well-known construction of pair-wise
independent families of functions. Let U be a universe of size n and b be a positive integer. Let X
be a collection of functions from U to [b]. That is, each function f in X takes as input an element
of U and returns an integer from 1 to b. The collection X is said to be pair-wise independent if, for
every i, j ∈ [b] and every u,v ∈ U such that u  v we have that
Pr
f ∈X[f (u) = i ∧ f (v) = j] = 1
b2 .
Observe that this implies that any pairwise independent family of functions from U to [b] with
|U | ≥ 2 also satisfies that for every i ∈ [b] and u ∈ U we have Prf ∈X[f (u) = i] = 1
b . We will make
use of the following known construction of pair-wise independent families.
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.  
8:16 F. V. Fomin et al.
Proposition 3.2 (Alon et al. (1986)). There is a polynomial time algorithm that given a universe
U and integer b constructs a pair-wise independent family X of functions from U to [b]. The size of
X is O(n2).
Using Proposition 3.2, we can give a much faster construction of an (n,p,q)-set-inclusion-family
than the one in Lemma 3.1 at the cost of a subexponential overhead in the size of the family.
We will also use the following well known bounds on binomial coefficients to simplify our
expressions in the proof of next theorem,
1
nO(1)
⎡
⎢
⎢
⎢
⎢
⎣

k
n
− k
n 
1 − k
n
 k
n −1⎤
⎥
⎥
⎥
⎥
⎦
n
≤

n
k

≤
⎡
⎢
⎢
⎢
⎢
⎣

k
n
− k
n 
1 − k
n
 k
n −1⎤
⎥
⎥
⎥
⎥
⎦
n
. (5)
Theorem 3.3. There is an algorithm that given n, p and q outputs an (n,p,q)-set-inclusion-family
C of size at most κ(n,p,q) · 2o(n) in time κ(n,p,q) · 2o(n)
.
Proof. The construction sets β = q/p, selects a number b = logn of buckets and applies
Proposition 3.2 to construct a pairwise independent family X of functions from U to [b]. For each
function f ∈ X and integer i ∈ [b], we set Ui
f = {u ∈ U : f (u) = i} and ni
f = |Ui
f |. Call a function
f good if, for every i ∈ [b] we have that |ni
f − n/b| ≤ √
n · b. For every good function f ∈ X, every i ∈ [b], and every integers ≤ ni
f , we construct an (ni
f ,s, βs)-set-inclusion-family C(i,s )
f using
Lemma 3.1. We now describe the family C output by the construction. Each set Y ∈ C is defined
by
(1) a good f ∈ X,
(2) a sequence p1,...,pb of integers such that |pi − p
b | ≤ √
n · b,
(3) a sequence Y1,...,Yb of sets with Yi ∈ C(i,pi )
f ,
(4) a set D ⊆ U of size at most b.
The set Y defined by the tuple (f ,p1,...,pb ,Y1,...,Yb ,D) is set to Y = (

i ≤b Yi ) \ D. This concludes the construction. Let T denote the set of tuples.
First, we analyze the running time of the construction. Constructing the set X takes polynomial
time by Proposition 3.2. For each good f , i ∈ [b] and s ≤ ni
f , constructing C(i,s )
f using Lemma 3.1
takes time 2o(n)
, because ni
f ≤ n
b + √
n · logn = O( n
log n ). There are O(n2) choices for f , at most
O(logn) choices for i and O( n
log n ) choices for s. Thus, the overall time of the construction is
2o(n) plus the time to output C. Outputting C can be done spending polynomial time for each set
Y ∈ T by enumerating over all the tuples (f ,p1,...,pb ,Y1,...,Yb ,D). Thus, the running time of
the construction is upper bounded by 2o(n) + |T | · nO(1)
.
Further, note that the size of C is upper bounded by the number of tuples
(f ,p1,...,pb ,Y1,...,Yb ,D). That is, |C| ≤ |T |. It remains to upper bound |T |. There are
O(n2) choices for f , at most nb choices for p1,...,pb and nO(b) choices for D. Thus, the number of
tuples is upper bounded by 2o(n) times the maximum number of choices for Y1 ...Yb for any fixed
choice of f , p1 ... pb and D. For each i, we choose Yi from C(i,pi )
f , so there are κ(ni
f ,pi, βpi) · nO(1)
choices for Yi . It follows that the total number of choices for Y1,...,Yb is upper bounded by

i ≤b
κ

ni
f ,pi, βpi
	
· nO(1) ≤ 2o(n) ·

i ≤b
( ni
f
βpi 
)
( pi
βpi  )
. (6)
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.  
Exact Algorithms via Monotone Local Search 8:17
Now, we have that

i ≤b


ni
f
βpi


≤

i ≤b

n/b
p/b

· nO(
√
n log n)

≤

n
p

· 2o(n)
. (7)
In the last transition, we used that the number of ways to pick b sets of size p/b, each from a
universe of size n/b is upper bounded by the number of ways to pick a set of size b · p/b from
a universe of size b · n/b. This in turn is upper bounded by (
n
p ) · 2o(n)
. Furthermore,

i ≤b
 pi
βpi

≥

i ≤b
 p/b
β (p/b)

· n−O(
√
n log n)

≥

β−β (1 − β)
β−1
	(p/b)
· n−O(1)
b
· 2−o(n) (8)
≥

p
q

· 2−o(n)
Here the two last transitions use Equation (5). Inserting the bounds from (7) and (8) into (6) yields
that the total number of choices for Y1,...,Yb is upper bounded by κ(n,p,q) · 2o(n) and thus, |C| ≤
κ(n,p,q) · 2o(n) as well.
All that remains is to argue that C is in fact an (n,p,q)-set-inclusion-family. Towards this, consider any subset S of U of size exactly p. For any fixed i ∈ [b], consider the process of picking a
random function f from X. We are interested in the random variables |Ui
f | and |Ui
f ∩ S |. Using
indicator variables for each element in U it is easy to show that
E
f ∈X




Ui
f




= n
b and E
f ∈X




Ui
f ∩ S



= p
b
.
Furthermore, X is pairwise independent, and therefore the covariance of any pair of indicator variables is 0. Thus, Varf ∈X[|Ui
f |] ≤ n and Varf ∈X[|Ui
f ∩ S |] ≤ n. By Chebyshev’s inequality it follows
that
Pr 




|Ui
f | − n
b




≥ √
n · b

≤
1
b2 and
Pr 




|Ui
f ∩ S | − p
b




≥ √
n · b

≤
1
b2 .
Consider now the probability that at least one of the variables |Ui | or |Ui ∩ S | deviates from its
expectation by at least √
n · b. Combining the preceding inequalities with the union bound taken
over all i ∈ [b] yields that this probability is upper bounded by 2b · 1
b2 ≤ 2
b . Since b = logn > 2, we
have that with non-zero probability, all the random variables |U1 |,..., |Ub | and |U1 ∩ S |,..., |Ub ∩
S | are within √
n · b of their respective means. Thus, there exists a function f ∈ X such that for
every i ∈ [b], we have




|Ui
f | − n
b




≤ √
n · b and




|Ui
f ∩ S | − p
b




≤ √
n · b.
In the remainder of the proof, let f be such a function in X.
The choice of f implies that f is a good function. For each i ≤ b, let Si = |Ui
f ∩ S | and pi = |Si |.
Again, by the choice of f , we have that |pi − p
b | ≤ √
n · b. Since C(i,pi )
f is an (ni
f ,pi, βpi)-
set-inclusion-family, there exists a set Yi ∈ C(i,pi )
f such that Yi ⊆ Si and |Yi | = βpi. For each
i ∈ [b] select such a Yi from C(i,pi )
f . Finally, let D be any subset of 
i ≤b Yi of size 

i ≤b |Yi | −
q. Note that |Yi | ≤ βpi + 1, thus 

i ≤b |Yi | − q ≤ b, so |D| ≤ b. Consider, finally, the tuple
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.
8:18 F. V. Fomin et al.
(f ,p1 ... pb ,Y1,... Yb ,D). We have just proved that this tuple satisfies all of the conditions for
giving rise to a set Y = 
i ≤b Yi \ D in C. However, Yi ⊆ Si for all i, so Y ⊆ S, proving that C is a
(n,p,q)-set-inclusion-family.
4 CONCLUSION AND DISCUSSION
In this article, we have shown that for many subset problems, an algorithm that finds a solution
of size k in time cknO(1) directly implies an algorithm with running time O((2 − 1
c )
n+o(n)
). We
also show that often, an upper bound of cknO(1) on the number of sets of size at most k in a
family F can yield an upper bound of O((2 − 1
c )
n+o(n)
) on the size of F . Our results reveal an
exciting new connection between parameterized algorithms and exponential-time algorithms. All
of our algorithms have a randomized and a deterministic variant. The only down-side of using
the deterministic algorithm rather than the randomized one is a 2o(n) multiplicative factor in the
running time, and an additional 2o(n) space requirement. It is possible to reduce the space overhead
to a much smaller (but still super-polynomial) term; however, this would make the presentation
considerably more involved.
For the enumeration algorithm of Theorem 1.4, it is well worth noting that the algorithm only
uses subexponential space if the algorithm is allowed to output the same set multiple times. If
duplicates are not allowed, then the algorithm needs exponential space to store a trio of the sets that
have already been output. Another approach is to use an output-sensitive algorithm. For example,
there is a polynomial-delay polynomial-space algorithm enumerating all feedback vertex sets in a
tournament (Gaspers and Mnich 2013), and its running time is O(1.6667n ) by our combinatorial
upper bound.
Our analysis also reveals that to obtain a (2 − ϵ )
n time algorithm with ϵ > 0 for a subset problem,
it is sufficient to get a O(ck (
n− |X |
k )
1−δ ) algorithm for any constant c and δ > 0 for the extension
problem. This might be a promising route for obtaining better exact exponential-time algorithms
for problems that currently do not have single-exponential-time parameterized algorithms. For
example, it would be interesting to see whether it is possible to improve on Razgon’s O(1.9977n )
time algorithm (Razgon 2007) for Directed Feedback Vertex Set by designing a O(ck (
n− |X |
k )
1−δ )
time algorithm.
APPENDIX
A PROBLEM DEFINITIONS
We list the definitions of the problems considered in this article.
Feedback Vertex Set Parameter: k
Input: An undirected graph G and a positive integer k.
Question: Does there exist a subset S ⊆ V (G) of size at most k such that G − S is acyclic?
Weighted Feedback Vertex Set Parameter: k
Input: An undirected graph G, a positive integer k, a weight function w : V (G) → N, and a
positive integer W .
Question: Is there a set S ⊆ V (G) of size at most k and weight at most W such that G − S is
acyclic?
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019. 
Exact Algorithms via Monotone Local Search 8:19
Subset Feedback Vertex Set Parameter: k
Input: An undirected graph G, a vertex subset T ⊆ V (G), and a positive integer k.
Question: Does there exist a subset S ⊆ V (G) of size at most k such that G − S has no cycle that
contains a vertex from T ?
Let Γ be a finite group with identity element 1Γ. A Γ-labeled graph is a graph G = (V, E)
with a labeling λ : E → Γ such that λ(u,v)λ(v,u) = 1Γ for every edge uv ∈ E. For a cycle C =
(v1,...,vr,v1), define λ(C) = λ(v1,v2) ····· λ(vr,v1).
Group Feedback Vertex Set Parameter: k
Input: A group Γ, a Γ-labelled graph (G, λ), and a positive integer k.
Question: Does there exist a subset S ⊆ V (G) of size at most k such that every cycle C in G − S
has λ(C) = 1Γ?
Node Uniqe Label Cover Parameter: |Σ| + k
Input: An undirected graph G = (V, E), a finite alphabet Σ, an integer k, and for each edge e ∈ E
and each of its endpoints v a permutation ψe,v of Σ such that if e = xy then ψe,x = ψ −1
e,v
Question: Is there a vertex subset S ⊂ V of size at most k and a function Ψ : V \ S → Σ such that
for every edge uv ∈ E(G − S), we have (Ψ(u), Ψ(v)) ∈ ψuv,u ?
For fixed integers r,  ≥ 0, a graph G is called an (r, )-graph if the vertex set V (G) can be partitioned into r independent sets and  cliques.
Vertex (r, )-Partization Parameter: k
Input: A graph G and a positive integer k
Question: Is there a vertex subset S ⊆ V (G) of size at most k such that G − S is an (r, )-graph?
Several special cases of this problem are well known and have been widely studied. For example,
(2, 0)- and (1, 1)-graphs correspond to bipartite graphs and split graphs, respectively. We note that
Vertex (r, )-Partization can be solved inO(1.1996(r+)·n ) by taking r copies of the input graph,
 copies of its complement, making all the copies of a same vertex into a clique and computing
a maximum independent set of this graph using the algorithm from Xiao and Nagamochi (2013).
This is faster than O(2n ) when r +  ≤ 3. We improve on this algorithm for r,  ≤ 2 and r +  ≥ 3.
For the definition of graph classes, including interval graphs, proper interval graphs, block
graphs, cluster graphs, we refer to Brandstädt et al. (1999).
Proper Interval Vertex Deletion Parameter: k
Input: An undirected graph G and a positive integer k.
Question: Does there exist a subset S ⊆ V (G) of size at most k such thatG − S is a proper interval
graph?
Interval Vertex Deletion Parameter: k
Input: An undirected graph G and a positive integer k.
Question: Does there exist a subset S ⊆ V (G) of size at most k such that G − S is an interval
graph?
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.           
8:20 F. V. Fomin et al.
Block Graph Vertex Deletion Parameter: k
Input: An undirected graph G and a positive integer k.
Question: Does there exist a subset S ⊆ V (G) of size at most k such that G − S is a block graph?
Cluster Vertex Deletion Parameter: k
Input: An undirected graph G and a positive integer k.
Question: Does there exist a subset S ⊆ V (G) of size at most k such thatG − S is a cluster graph?
Thread Graph Vertex Deletion Parameter: k
Input: An undirected graph G and a positive integer k.
Question: Does there exist a subset S ⊆ V (G) of size at most k such that G − S is of linear rankwidth one?
Multicut on Trees Parameter: k
Input: A tree T and a set R = {{s1,t1},..., {sr,tr }} of pairs of vertices of T called terminals, and
a positive integer k.
Question: Does there exist a subset S ⊆ E(T ) of size at most k whose removal disconnects each
si from ti , i ∈ [r]?
d-Hitting Set Parameter: k
Input: A family S of subsets of size at most d of a universe U and a positive integer k.
Question: Does there exist a subset S ⊆ U of size at most k such that F is a hitting set for S ?
Weighted d-Hitting Set Parameter: k
Input: A family S of subsets of size at most d of a universe U, a weight function w : U → N,
and positive integers k and W .
Question: Does there exist a subset S ⊆ U of size at most k and weight at most W such that F
is a hitting set for S ?
Min-Ones d-Sat Parameter: k
Input: A propositional formula F in conjunctive normal form (CNF) where each clause has at
most d literals and an integer k.
Question: Does F have a satisfying assignment with Hamming weight at most k?
Weighted d-Sat Parameter: k
Input: A CNF formula F where each clause has at most d literals, a weight functionw : var(F ) →
Z, and integers k and W .
Question: Is there a set S ⊆ var(F ) of size at most k and weight at mostW such that F is satisfied
by the assignment that sets the variables in S to 1 and all other variables to 0?
Tournament Feedback Vertex Set Parameter: k
Input: A tournament G and a positive integer k.
Question: Does there exist a subset S ⊆ V (G) of size at most k such that G − S is a transitive
tournament?
Journal of the ACM, Vol. 66, No. 2, Article 8. Publication date: March 2019.
Exact Algorithms via Monotone Local Search 8:21
Split Vertex Deletion Parameter: k
Input: An undirected graph G and a positive integer k.
Question: Does there exist a subset S ⊆ V (G) of size at most k such that G − S is a split graph?
Cograph Vertex Deletion Parameter: k
Input: An undirected graph G and a positive integer k.
Question: Does there exist a subset S ⊆ V (G) of size at most k such that G − S is a cograph?
Directed Feedback Vertex Set Parameter: k
Input: A directed graph G and a positive integer k.
Question: Does there exist a subset S ⊆ V (G) of size at most k such thatG − S is directed acyclic
graph?