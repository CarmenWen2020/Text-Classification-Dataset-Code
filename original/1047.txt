We establish a theorem called the PCL theorem, which states that it is impossible to design a transactional
memory algorithm that ensures (1) parallelism, i.e., transactions do not need to synchronize unless they
access the same application objects, (2) very little consistency, i.e., a consistency condition, called weak
adaptive consistency, introduced here and that is weaker than snapshot isolation, processor consistency, and
any other consistency condition stronger than them (such as opacity, serializability, causal serializability, etc.),
and (3) very little liveness, i.e., which transactions eventually commit if they run solo.
CCS Concepts: • Computing methodologies → Concurrent algorithms;
Additional Key Words and Phrases: Transactional memory, disjoint-access-parallelism, snapshot isolation, processor consistency, weak adaptive consistency, obstruction-freedom, lower bounds, universal
constructions
1 INTRODUCTION
The dominance of multi-core architectures in chip manufacturing led to the concurrency-at-large
revolution in software that posed the major challenge of overcoming the difficulty of concurrent programming. Transactional memory (TM) [36, 51] has been proposed as a way to tackle
this challenge. It attempts to simplify the production of efficient and correct concurrent programs
by employing the paradigm of transactions (originated in database systems [28]) to synchronize
concurrent accesses to different pieces of data (these pieces of data are called data items or highlevel objects). Each transaction can either commit, in which case all the changes to data items it
performed take effect, or it can abort, in which case all these changes are discarded. TM allows
non-expert programmers to encapsulate pieces of sequential code within transactions that might
run concurrently with each other, in an atomic way, thus providing an easy solution to the introduction of concurrency within modern applications.
A TM algorithm uses base objects (or low-level objects) to store the state of data items and other
metadata, i.e., data needed by the algorithm to manage the transactions, and provides algorithms,
for each process, to implement transactional operations that may read from or write to a data
item, or request to commit a transaction. Base objects are usually provided by the hardware. A base
object typically supports atomic primitives like read, write, and compare-and-swap. TM algorithms
are designed by experts who undertake the task to cope with the synchronization complications
of concurrency.
The appropriate functioning of a TM algorithm is formally specified through two kinds of properties: consistency conditions [16, 32, 43] (sometimes called safety properties) and liveness conditions [4, 17, 43, 45] (sometimes called progress properties). In the context of concurrent computing,
consistency conditions specify which responses of the implemented operations are legitimate in
concurrent executions. Consistency conditions come in many flavors, from weak to strong, resulting in trade-offs between implementing TM easily and efficiently and increasing the degree of
predictability of the implemented operations’ responses. For example, serializability [46], a strong
consistency condition of TM algorithms, ensures that, in any execution of a TM algorithm, all
committed transactions get the same responses as in some sequential execution containing these
transactions. Sometimes, serializability is hard to implement and can negatively affect the performance of TM algorithms. Another consistency condition considered for TM [50], known as snapshot isolation [15], requires that transactions read from some consistent snapshot of the memory,
which is taken when they begin their execution.
Establishing a consistency condition is not enough to build a useful system. Indeed, every consistency condition can be trivially ensured by simply not returning responses. To be meaningful,
an algorithm should guarantee that certain operations eventually get responses and some of their
underlying transactions eventually commit. However, because of contention on data items, transactions get delayed and sometimes abort. One would hope nevertheless that a TM algorithm does
not introduce any contention between transactions beyond that inherently due to data item accesses in the actual sequential code of transactions. Basically, if transactions access disjoint sets
of high-level objects, they should not delay or prevent each other from committing, i.e., the TM
algorithm should not add any artificial contention.
The main contribution of this article is to show that this is in fact impossible even for TM
algorithms that ensure extremely weak notions of consistency.
Elaborating on this result goes first through defining precisely what it means for a TM not to
introduce any artificial contention. We look into this from both a static and a dynamic point of view.
From the static perspective, two transactions whose sequential codes access disjoint sets of
data items (i.e., they do not conflict), should not delay or prevent each other from committing.
Specifically, two transactions T1 and T2 (executed by processes p1 and p2, respectively) are said to
contend on some low-level base object in an execution α, if both p1 and p2 access the object (while
executing T1 and T2, respectively, in α) and at least one of these accesses is a non-trivial primitive
on the object, i.e., it is an instruction that may update the state of the object.T1 andT2 concurrently
contend on the base object if, additionally, there is a specific point (while T1 and T2 are both live)
in α at which p1 and p2 are both poised to access the object. We call c-disjoint-access-parallelism
the requirement that two transactions do not concurrently contend on any low-level base object if
they do not conflict on any high-level object.
A stronger version of this condition, known as strict disjoint-access-parallelism, was presented
in References [2, 29]. Strict disjoint-access-parallelism requires that two transactions do not
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:3
contend on any low-level base object if they do not conflict on any high-level object. Because
every two transactions that concurrently contend on a base object also contend on that object,
c-disjoint-access-parallelism is weaker than strict disjoint-access-parallelism. Although strict
disjoint-access-parallelism nicely captures the requirement of disallowing transactions from
contenting on base objects if they access disjoint sets of data items, it overlook the fact that
transactions may be separated in time. So, even if the execution intervals of two transactions
have no overlap (and therefore they cannot delay each other, independently of the set of base
objects they access), strict disjoint-access-parallelism still constrains them (requiring that they
access disjoint sets of base objects). C-disjoint-access-parallelism is formulated to capture this
time separation in the execution of transactions: transactions whose execution intervals do not
overlap do not constrain each other in accessing shared objects.
As motivated in the original papers [2, 7] introducing disjoint-access-parallelism, an algorithm
that ensures disjoint-access-parallelism is likely to result in less contention and achieve a higher
level of concurrency. Therefore, ensuring a condition of this nature is desirable; indeed, a lot of
previous research [2, 7, 9, 11, 20, 29, 39, 40, 47, 48] has been devoted to studying algorithms that
ensure some form of disjoint-access-parallelism.
From a dynamic perspective, we focus on obstruction-freedom [35], a well-known progress
condition that requires that every transaction eventually commits when it is executed solo for
long enough time, i.e., when its steps are not interleaved with steps by other processes after some
point in time. For a TM algorithm that ensures c-disjoint-access-parallelism, obstruction-freedom
can be thought of as follows: if, at run time, the set of data items accessed by a transactionT are not
accessed by any other transaction, then no transaction can cause T to abort. Obstruction-freedom
and c-disjoint-access-parallelism are complementary: Each of them might be satisfied without
this being necessarily the case for the other condition.
We present and prove a theorem, called the PCL theorem, which states that it is impossible
to ensure obstruction-freedom, c-disjoint-access-parallelism and weak adaptive consistency when
designing TM algorithms. To prove an impossibility result for TM algorithms that ensure a set
of properties, an execution must be constructed that turns out to be “troublesome” for every
TM algorithm that exhibits these properties (specifically, the execution must violate one of the
properties). We assume that an adversarial scheduler controls the order in which processes take
steps. Assuming that the TM algorithm ensures a weak set of properties narrows down the set of
incorrect executions that the adversarial scheduler can utilize and therefore it makes the task of
constructing the troublesome execution more challenging.
Weak adaptive consistency is a very weak consistency condition that we introduce in this
article. Serializability and snapshot isolation necessitate the existence of a sequential execution,
based on which they determine the correct responses of transactional operations independently
of the process that initiated each of these operations. Processor consistency [3, 27] weakens this
requirement by allowing each process to have its own sequential view as long as this sequential
view respects the process-order of writes; additionally, writes to the same data item must appear
in the same order in all sequential views. Processor consistency is a very weak consistency
condition as it enrolls more executions as correct than other common TM consistency conditions,
like opacity [30], strict serializability [46], serializability [46], causal serializability [49], and
virtual world consistency [38]. However, processor consistency is not comparable to snapshot
isolation, because in processor consistency, the sequential views do not necessarily respect the
real-time order imposed by the execution intervals of transactions. Weak adaptive consistency is a
combination of a weak form of snapshot isolation [15] and processor consistency [27] in a way that
it is weaker than both. Specifically, weak adaptive consistency allows to partition transactions in a
given execution into consistency groups so that in each consistency group all transactions satisfy
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
2:4 V. Bushkov et al.
either a weak form of snapshot isolation or processor consistency. We consider a weak form of
snapshot isolation when defining weak adaptive consistency. Specifically, we do not require the
extra constraint (met in snapshot isolation definitions in the literature [15, 22, 50]) that from two
concurrent transactions writing to the same data item, only one can commit. Additionally, we do
not impose any restriction on the value returned by a read operation on some data item x by a
transaction T , if T has written x before invoking this read operation.
To the best of our knowledge, the PCL theorem is the first impossibility result that is proved
under the assumption of such a weak consistency condition. Remarkably, obstruction-freedom
is also considered the weakest among all known non-blocking progress conditions for TM
algorithms. We prove the PCL theorem even for algorithms that are allowed to use powerful
primitives that atomically access several base objects. The PCL theorem is proved assuming that
the TM implementation is deterministic. If it is randomized, then we fix a sequence of coin tosses
for each process and only consider executions using these coin tosses. Thus, the PCL theorem
holds even for randomized TM algorithms.
The proof of the PCL theorem employs indistinguishability arguments [13, 43]. Since we
prove our impossibility result under the assumption of very weak consistency, we face the extra
challenge to make such arguments work in a setting where, on the one hand, read operations
of a transaction are not always considered to occur at the same point as the transactions’ write
operations (as is the case for snapshot isolation), and on the other hand, each process is allowed
to have its own sequential view (as is the case for processor consistency). This led to several
complications, which we had to handle with care, and made the proof challenging.
We study the limits of the PCL theorem in all three different premises. We show that if we
weaken any of the considered properties then the PCL theorem no longer holds.
A natural way to come up with a consistency condition weaker than weak adaptive consistency
would be to give up the requirement that writes to the same data item appear in the same order in
all sequential views. We show that it is trivial to design a TM algorithm that ensures such a weak
consistency condition, as well as strict disjoint-access-parallelism, and wait-freedom [34], which
is a strong progress condition, without any need for synchronization. Therefore, such consistency
conditions are not (theoretically) interesting in the TM context.
We further present SI-DSTM, an example of a TM algorithm, mainly of theoretical interest,
which shows that the impossibility result can be circumvented by assuming a weaker parallelism
property. SI-DSTM is obstruction-free, satisfies a stronger consistency property than weak
adaptive consistency, and ensures the following parallelism property: (1) it guarantees a property
stronger than strict disjoint-access-parallelism between a read-only transaction, i.e., a transaction
that does not perform write operations to data items, and any other transaction, and (2) it
guarantees a form of disjoint-access-parallelism between any two non-read-only transactions,
which is weaker than c-disjoint-access-parallelism. Thus, SI-DSTM is a counter-example TM
algorithm that ensures strong consistency and obstruction-freedom by sacrificing parallelism.
We remark that TL [19] is a blocking lock-based TM algorithm that ensures strict disjointaccess-parallelism and strict serializability [46]. Thus, TL is an example of a TM algorithm that
ensures a strong consistency property and a strong parallelism property but a liveness property
weaker than obstruction-freedom. The blocking TM algorithm presented in Reference [31]
ensures opacity [30], one of the strongest consistency conditions in the TM setting, and strict
disjoint-access-parallelism. Moreover, PermiSTM [10] is a blocking TM algorithm that ensures
strict serializability and strict disjoint-access-parallelism.
Since obstruction-freedom is the weakest known progress property of its kind and a weaker
version of weak adaptive consistency can be implemented without any synchronization, the consistency and progress conditions assumed in the PCL theorem can be considered as fundamental
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:5
Table 1. Comparison of DAP Definitions
Definition Base objects Path/edge in CG Additional constraints
definition of Reference [39] access path constraint on step complexity
definition of References [11, 12] concurrently contend path
d local contention [2, 7] contend path of length d
strict DAP [29] contend edge
c-DAP (this article) concurrently contend edge
limitations of transactional memory systems. Assuming weaker forms of c-disjoint-accessparallelism can circumvent the impossibility result. However, they would result in undesirable
artificial contention between transactions that are not directly related to each other.
The rest of the article is structured as follows. A discussion of the related work is provided in
Section 2. Section 3 presents the system model and some definitions necessary for proving the
results in later sections. The PCL theorem and its proof are provided in Section 4. For clarity, we
present the proof of the impossibility result in two steps. We first present a simplified version
of the PCL theorem that assumes that the TM ensures strict disjoint-access-parallelism and is
implemented using primitives that can access only one base object each. We then present the
general proof, which holds for c-disjoint-access-parallelism and assumes that each primitive can
atomically access up to m base objects. Section 5 investigates the limits of the PCL theorem.
Finally, Section 6 provides some concluding remarks.
2 RELATED WORK
Definitions of disjoint-access-parallelism. The notion of disjoint-access-parallelism (DAP) appeared in the literature in many flavors [2, 11, 20, 30, 39, 48]. Disjoint-access-parallelism was first
introduced in Reference [39] through the notion of conflicting operations. Later variants [2, 11, 20]
employed the concept of a conflict graph of an execution interval α. A conflict graph (CG) of α is a
graph whose nodes represent those transactions (or operations) whose execution intervals overlap
with α and an edge exists between two nodes if the corresponding transactions conflict, i.e., if they
access the same data item. In many of these definitions, disjoint-access-parallelism allows any two
transactions to contend on a base object only if there is a path in the conflict graph of the minimal
execution interval that contains the execution intervals of both transactions. Notice that such a
definition allows transactions to be transitively affected by other transactions to which they are
connected with paths in the conflict graph but with which are otherwise disjoint.
In several cases, conflicting transactions could form long chains and the conflict graph may
end up to be complex. To constrain coordination only among local neighborhoods of contending
operations, References [2, 7, 9, 39] place additional constraints on the length of the path in the
conflict graph resulting in what is known as the d-local contention property, where d is an upper
bound on the length of the path. When d = 1, this definition is equivalent to strict disjoint-accessparallelism. The case where d = 2 was studied in Reference [7]. In Reference [39], where disjointaccess-parallelism originally appeared, an additional constraint that imposes an upper bound on
the step complexity of each operation was provided in the definition.
Table 1 compares the disjoint-access-parallelism definitions that are discussed in this article.
The access characterization in the second column is stronger than the contend characterization
in the same column, which is, in turn, stronger than that of concurrently contend in that column.
Similarly, the edge characterization in the third column is stronger than that of path of length d (in
case d > 1), which is in turn stronger than that of path (in case d is smaller than the diameter of the
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
2:6 V. Bushkov et al.
execution’s conflict graph). We remark that a disjoint-access-parallelism definition is stronger than
another if, in each column, the first definition contains a characterization that is stronger than (or
the same to) that of the second. Given a pair of definitions, if none is stronger than the other, then
the two definitions are incomparable. For instance, c-disjoint-access-parallelism is weaker than
strict disjoint-access-parallelism, stronger than the definition in Reference [12], and incomparable
to the rest of the definitions that appear in Table 1.
Impossibility Results. [29] proved that no strictly disjoint-access-parallel TM algorithm can be
serializable and obstruction-free. However, the result in Reference [29] assumes that the primitives
used by a TM algorithm can atomically access only one base object, whereas we prove our impossibility result for the case where a TM algorithm is allowed to use stronger primitives that atomically access several base objects. Also, it assumes serializability, a consistency condition stronger
than weak adaptive consistency, and strict disjoint-access-parallelism (which is stronger than cdisjoint-access-parallelism). Moreover, it does not answer the question if the three requirements
of strict disjoint-access-parallelism, serializability, and obstruction-freedom are weak enough. Our
work, however, studies the limits of the PCL Theorem by studying weaker conditions in all three
considered requirements.
References [11, 12] employed a version of disjoint-access-parallelism, which requires that if two
transactions concurrently contend on a base object, there must be a path between them in the
conflict graph of the minimal execution interval that contains them. (We remark that c-disjointaccess-parallelism is equivalent to a stronger form of this version in which there is an edge between
the two transactions in the conflict graph of the minimal execution interval that contains them.)
They proved that no TM algorithm that ensures this form of disjoint-access-parallelism, can also
ensure wait-free and invisible read-only transactions and a liveness property, known as minimal
progress, for update transactions. An invisible read-only transaction does not perform non-trivial
primitives on base objects. Minimal progress ensures that a transaction that executes solo starting
from a quiescent configuration (eventually) commits; minimal progress is weaker than obstructionfreedom. In a similar avenue, Reference [40] proved that no strictly disjoint-access-parallel TM
implementation can be strictly serializable and ensure wait-freedom for read-only transactions
and minimal progress for update transactions.
These impossibility results [11, 12, 40] are significantly generalized in References [8, 20, 21],
where it is proved that no TM algorithm that satisfies a weak definition of disjoint-accessparallelism, called feeble disjoint-access-parallelism, can support wait-free read-only transactions
and minimal progress for update transactions. Feeble disjoint-access-parallelism ensures that for
every pair of transactions T1 and T2 and every configuration C in which no process is active (i.e.,
C is quiescent), the solo execution of T1 starting from C and the solo execution of T2 starting from
C, do not contend on any base object, if T1 and T2 access disjoint sets of data items. As proved
in Reference [21], feeble disjoint-access-parallelism is satisfied by every algorithm that ensures
any of the definitions of disjoint-access-parallelism discussed in Table 1. Thus, the impossibility result in References [8, 20, 21] still holds if feeble disjoint-access-parallelism is replaced with
any of these definitions. However, the impossibility results in References [12, 40] hold also for
TM algorithms that support only static transactions whereas that in References [8, 20, 21] utilizes
transactions that create new data items at run time; a transaction is static, if the set of data items
it accesses is from a pre-determined bounded set, otherwise, the transaction is dynamic.
All these impossibility results [8, 11, 12, 20, 21, 40] are incomparable to the PCL theorem, because
they assume a liveness property stronger than obstruction-freedom for read-only transactions
but weaker than it for update transactions. The PCL theorem is proved for a stronger version of
disjoint-access-parallelism than the impossibility results in References [8, 11, 12, 20, 21]. Unlike
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:7
the impossibility result in Reference [11], the PCL theorem holds for TM algorithms in which
read-only transactions are visible, and, unlike the impossibility results in Reference [8], it holds
also for TM algorithms that support only static transactions. Also, unlike all these results that
assume that primitives in a TM algorithm can atomically access only one base object, the PCL
theorem is proved for the case where a TM algorithm is allowed to use stronger primitives that
atomically access several base objects.
In Reference [47], it is proved that no disjoint-access-parallel TM algorithm can guarantee waitfreedom for read-only transactions and obstruction-freedom for update transactions and satisfy
a safety property that has the requirement of preserving the real-time order of transactions; the
paper considers the same disjoint-access-parallelism definition as that of Reference [11] (which
is weaker than c-disjoint-access-parallelism). We prove the PCL theorem for a weaker liveness
condition for read-only transactions. The impossibility result in Reference [47] is also proved for
the case when update transactions are weakly progressive and read-only transactions are invisible.
Weak progressiveness is incomparable to obstruction-freedom. The PCL theorem holds even when
read-only transactions are visible.
In Reference [17], it is proved that if transactions cannot help each other (i.e., execute transactional operations on behalf of each other), then no TM algorithm ensures a property similar to
wait-freedom, called local progress and strict serializability. In Reference [20], it was proved that
no TM algorithm (even when transactions can help each other), ensures strict serializability, waitfreedom, and feeble disjoint-access-parallelism. Thus, weaker consistency or progress properties
must be studied.
Reference [48] proved that no disjoint-access-parallel TM algorithm can be strictly serializable
and MV-permissive. The impossibility result holds under the strong assumptions that the implementations for reading and writing of data items terminate within a finite number of steps.
Perelman et al. [48] considered the same variant of disjoint-access-parallelism as that in Reference [11]. A TM algorithm satisfies MV-permissiveness if a transaction aborts only if it is a write
transaction that conflicts with another write transaction. Our impossibility result holds under a
weaker consistency condition; it also holds even for TM algorithms that are MV-permissive.
Table 2 provides a summary of the related impossibility results.
Disjoint-Access-Parallel Software Transactional Memory Algorithms and Universal Constructions. Software TM algorithms [19, 24, 31, 35, 44, 51, 52] are disjoint-access-parallel: TL [19],
PermiSTM [10], and the simple TM algorithm in Reference [31] ensure strict disjoint-accessparallelism but they are blocking, since they employ locks; the rest satisfy weaker forms of disjointaccess-parallelism [11]. Among them OSTM [24] is lock-free. The TM in Reference [51] is also
lock-free but it has been designed for static transactions that access a pre-determined set of memory locations. Apparently, our impossibility result does not contradict these algorithms, because
all of them, except TL and a simple TM algorithm from Reference [31], ensure weaker variants
of disjoint-access-parallelism and some of them weaker progress as well. Also, our impossibility
result does not contradict TL and the algorithm presented in Reference [31], since both of them
use locks and consequently do not ensure obstruction-freedom.
A universal construction [33, 34] is a general mechanism for automatically executing pieces
of sequential code (atomically) in a concurrent environment. Linearizable universal constructions
that ensure some form of disjoint-access-parallelism, are presented in References [1, 14, 20, 53].
Reference [14] algorithm is lock-free. The universal construction in Reference [20] ensures waitfreedom when there is an upper bound on the number of data items accessed by each piece of
sequential code (provided as input to the universal construction), and it ensures lock-freedom in
other cases. The universal constructions in References [2, 53] are wait-free but they assume that
each piece of sequential code accesses a fixed number of predetermined memory locations. These
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
2:8 V. Bushkov et al.
Table 2. Summary of Impossibility Results Related to the PCL Theorem
Results DAP Consistency Progress Additional constraints
[29] strict serializability obstruction-freedom primitives on one base
object
[11] weak serializability wait-freedom for invisible read-only
[12] read-only transactions,
minimal progress for
update transactions
transactions, primitives on
one base object
[40] strict strict serializability wait-freedom for
read-only transactions,
minimal progress for
update transactions
primitives on one base
object
[20] feeble strict serializability wait-freedom for dynamic data set,
[21] read-only transactions, primitives on
[8] snapshot isolation minimal progress one base object
for update transactions
[47] weak consistency
condition that
preserves
real-time order
wait-freedom for
read-only transactions,
obstruction-freedom for
update transactions
primitives on one base
object
[47] weak consistency
condition that
preserves
real-time order
wait-freedom for
read-only transactions,
weak progressiveness
for update transactions
invisible read-only
transactions, primitives on
one base object
[48] weak strict serializability MV-permissiveness implementations for
reading and writing data
items terminate within a
finite number of steps
This
article
c-DAP weak adaptive
consistency
obstruction-freedom
universal constructions ensure stronger progress properties than obstruction freedom but they
consider weaker versions of disjoint-access-parallelism than c-disjoint-access-parallelism.
Snapshot Isolation and Processor Consistency. Snapshot isolation was originally introduced as an
isolation level for database transactions [15, 22] to increase throughput for long read-only transactions. In TM computing, snapshot isolation has been studied in References [5, 6, 18, 42, 50]. TM
algorithms that ensure snapshot isolation are presented in References [42, 50]. Both of these algorithms employ a global clock mechanism and therefore, they are not disjoint-access-parallel.
In Reference [18], static analysis techniques are presented to detect, at compile time, consistency
anomalies that may arise when the TM algorithm satisfies snapshot isolation or other safety properties. Snapshot isolation on TM for message-passing systems has been studied in Reference [5].
When defining weak adaptive consistency, we consider a weaker form of snapshot isolation
than those considered in References [15, 22, 50]. Specifically, we do not require that from two
concurrent transactions writing to the same data item only one can commit, and we do not impose
any restriction on the value returned by a read t-operation on some data item by a transaction T ,
if T has written this data item before invoking this read operation.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:9
Processor consistency was first introduced in References [25, 27] as a weak shared memory consistency condition for multiprocessor programs. Due to the low cost of maintaining consistency
of shared memory, processor consistency allows building shared memory systems with higher
performance and scalability. In Reference [27], processor consistency was defined as a stronger
variant of PRAM consistency [41]. PRAM consistency ensures just that the process order of operations should be preserved in the sequential view of each process. Processor consistency is stronger
because of the additional requirement that writes to the same shared objects should appear in the
same order in all sequential views. In References [25, 27], processor consistency was defined as
a weaker variant of causal consistency, which requires that the causality relation between reads
and writes should be preserved in all sequential views but does not require process order to be
preserved. Formal definitions of both variants of processor consistency were provided in Reference [3] and were shown to be incomparable to each other. In this work, we adapt the definition
of processor consistency from Reference [27] into the context of transactional memory.
3 PRELIMINARIES
System. We consider a shared-memory system of asynchronous processes that communicate with
each other by accessing base objects. Base objects are simple shared objects, usually provided
by the hardware. A base object has a state and provides atomic primitives to access or modify
its state. An example of a base object is a read/write register o, which stores a value from some
set and supports the atomic primitives read and write; read(o) returns the current value of o
without causing any change to its state, whereas write(o,v) writes the value v into o and returns
an acknowledgement ack. Another example is a CAS object o, which stores a value from some set
and supports, in addition to read, the atomic primitive CAS(o,u,v), which compares the current
value of o with u and, if they are the same, changes the value of o to v and returns u; otherwise, it
returns the current value of o without making any change to o’s state.
To make the PCL theorem stronger, we assume that a primitive can atomically access several
base objects. As an example, consider the atomic primitive xchg(o1, o2), which takes as parameters
two base objects o1 and o2 and exchanges their values. As a second example, an n-CAS is a generalization of CAS, which works on n base objects atomically. A primitive is non-trivial, if it may
change the state of a base object; otherwise, the primitive is trivial.
Processes are asynchronous in the sense that they are executed at arbitrary speeds. Specifically,
we assume that an adversarial scheduler controls the order in which primitives are performed by
processes on base objects.
Well-known books in distributed computing, e.g., References [13, 43], provide detailed formal
definitions of this model.
Transactions. Transactional memory (TM) employs transactions to execute pieces of code in a
concurrent environment providing the illusion that it executes each such piece of code sequentially. Each piece of code may contain accesses to pieces of data, called data items, that may be
accessed by several processes at the same time when the code is executed concurrently. A transaction may either commit in which case all its updates take effect, or abort in which case its updates
are discarded. Each transaction is executed by a single process.
To synchronize concurrent accesses to data items, a TM usually provides a shared representation for each data item by using base objects (see Figure 1). For each process, a TM also provides
algorithms, for the routines: (1) x.read(), which returns a value for a data item x or a special value
A (abort) indicating that the transaction T executing x.read() has to abort, and (2) x.write (v),
which writes the value v for data item x and returns either ack or A if the transaction T executing x.write (v) has to abort. To manage the execution of transactions, a TM additionally provides
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
2:10 V. Bushkov et al.
Fig. 1. Implementation of TM operations using primitives on base objects.
algorithms for the following routines: (1) beдinT , which is called when a transaction T starts and
returns ack, (2)commitT , which is called whenT tries to commit and returns either a special value
C (commit) indicating that T has committed or A, and (3) abortT , which aborts T and returns A.
Finally, a TM might support routines for copying with the creation of new data items, when transactions are not static and allocate data items dynamically. The algorithms of the routines discussed
above for a process p can be thought of as a state machine for p. Each time p calls one of these routines while executing a transactionT , we say that p invokes a transactional operation (or t-operation
for short). For simplicity, we also say that the t-operation is invoked by T (or in T ). When the execution of the routine completes, a response is returned, which is called the matching response of
this t-operation. Each process is executed sequentially, i.e., after invoking any t-operation op, the
process does not invoke any other t-operation until it completes the execution of the algorithm
that implements op and receives a response for op. Later on, when we reason about a particular execution, we add a subscriptT toC andA responses to avoid ambiguity and to distinguish responses
of different transactions from each other in a given execution. For example, for the invocation of
x.write (v) by a transaction T , a matching response would be ack or AT . A process starts the execution of a transaction T by invoking beдinT . The execution of a transaction completes when
either AT is received as a response to one of its t-operations or CT is received as a response to
commitT .
Executions and configurations. A configuration describes the state of the system at some point
in time. Formally, a configuration is a vector with components describing the state of each process
and the state of each base object. In an initial configuration, processes and base objects are in
initial states. A TM algorithm is a collection of state machines, one for each process. To execute a
t-operation, a process p executes a sequence of steps (based on its state machine). Formally, a step
of a process consists of applying a single primitive to one (or more) base objects, the response to
that primitive, and some local computation that may cause the state of the process to change; each
step is executed atomically. Invocations and responses of t-operations (performed by transactions)
are considered as steps; notice that such a step does not apply any primitive. We sometimes say
that a transaction T applies a step s in α instead of saying that the process executing T applies s
in α.
A step s by a process p is legal starting from a configuration C if it follows the state machine for
p (starting from its state inC) and the response of the primitive thats applies is in accordance with
the specification of the objects it accesses (and the values stored in the objects at C). An execution
is a sequence of steps. We use α · β to denote the concatenation of two executions α and β and say
that α is a prefix of α · β. We say that an execution α is legal starting from some configuration C if
each step s performed by every process in α is legal (starting from the configuration that results
from applying the prefix of α up to but not including s starting fromC). A configuration isreachable
if it can result from the application of a legal execution starting from an initial configuration. An
execution is solo if all its steps are performed by the same process. Two executions α1 and α2
starting from configurations C1 and C2, respectively, are indistinguishable to some process p, if the
state of p is the same in C1 and C2, and the sequence of steps performed by p is the same in both
executions. A process is poised to execute a primitive at a (reachable) configuration C, if it will
perform this primitive the first time after C that it will be scheduled by the scheduler.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:11
Consider an execution α in which a transaction T is executed. We say that T commits (or aborts)
in α, if α contains CT (or AT , respectively). T completes in α, if T either commits or aborts in α,
otherwise T is live in α. T has a pending t-operation op in α, if α contains an invocation of op by T
but does not contain a matching response. T is commit-pending in α, if T has a pending commitT
t-operation in α.
The execution interval of a completed transaction T in α is the subsequence of consecutive steps
of α starting with the first step executed by any of the t-operations invoked by T and ending with
the last such step. The execution interval of a transactionT that does not complete in α is the suffix
of α starting with the first step executed by the first t-operation invoked byT . The active execution
interval of a transaction T (completed or not) in α is the subsequence of consecutive steps of α
starting with the first step executed by any of the t-operations invoked by T and ending with the
last such step. Notice that the active execution interval of a completed transaction in α is the same
as its execution interval but this is not the case for a live transaction in α. Two execution intervals
overlap if the first step of one of them occurs before the other ends. The minimal execution interval
of two transactions T1 and T2 in α is the shortest subsequence of consecutive steps of α, which
includes all the steps from and between the execution intervals of T1 and T2. We denote by α |T the
subsequence of α consisting of all steps executed by a transaction T .
Transaction T1 precedes transaction T2 in execution α (denoted T1 <α T2), if T1 is completed in
α and AT1 or CT1 precedes the invocation of beдinT2 in α. If T1 <α T2 and T2 <α T1, then T1 and T2
are concurrent in α. An execution α is sequential if no two transactions are concurrent in α.
Histories. A history H is a sequence of invocations and responses of t-operations performed by
transactions. Notice that <H can be defined for a history H in exactly the same way as <α for an
execution α. Moreover, we can define sequential histories in the same way as we defined sequential
executions.
For each process pi , we denote by H|pi the longest subsequence of H consisting only of invocations and responses of t-operations performed by pi . History H|pi is well-formed if it is sequential
and for each transaction T in H|pi the following hold: (1) H|T is an alternating sequence of invocations and matching responses starting with the invocation of beдinT , and (2) there is at most
one instance of AT or CT in H|T and appears at the end of it. History H is well-formed if, for every
process pi , history H|pi is well-formed.
Given an execution α, we denote by Hα the longest subsequence of α consisting only of invocations and responses of t-operations. We remark that if an execution α is sequential then Hα is
also sequential.
Transaction T is legal in a sequential history S, if for every x.read() performed by T , which
returns some value v the following holds: (1) if T executes x.write () before x.read(), then v is
the argument of the last such x.write () invocation by T ; otherwise, (2) if there is an invocation of
x.write () by some committed transaction that precedes T , then v is the argument of the last such
x.write () invocation in S; otherwise, (3) v is the initial value for x. A sequential history S is legal
if every transaction in S is legal.
Progress. A transaction T executes solo in an execution α, if no other transaction takes steps in
the execution interval of T in α. A TM algorithm A is obstruction-free, if for each execution α
produced by A, the following two conditions are satisfied:
• for each completed transaction T in α that does not invoke abortT , T is aborted only if it
does not execute solo in α, and
• no transaction T , that executes solo in α, takes infinitely many steps to perform a toperation.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.  
2:12 V. Bushkov et al.
Disjoint-access-parallelism. TransactionT accesses a data item x in α, ifT invokes a t-operation
x.write () or x.read() in α. We define the data set D(T, α) of T in an execution α as the set of data
items that T accesses in α.
We say that two transactionsT1 andT2 conflict in α, if D(T1, α) ∩ D(T2, α)  ∅. The conflict graph
of an execution α is an undirected graph whose vertices represent transactions the execution intervals of which overlap with α and an edge connects two transactions T1 and T2 iff T1 conflicts
withT2 in α. We say that two stepss1 and s2 contend on a base object o if they both apply a primitive
that accesses o and at least one of these primitives attempts to change the state of o. We say that
two executions α1 and α2 contend on a base object o if α1 contains a step s1 and α2 contains a step
s2 such that s1 and s2 contend on o. A step s1 by process p1 that applies primitive pr1concurrently
contends with a step s2 by process p2, which applies primitive pr2 at some configuration C, if (1) s1
and s2 contend, (2) p1 is poised to execute pr1 at C, and (3) p2 is poised to execute pr2 at C. Let α be
an execution and T1 and T2 be transactions in α. Then, α |T1 and α |T2 concurrently contend if there
exists a configuration C in α, a step s1 in α |T1, and a step s2 in α |T2 such thats1 and s2 concurrently
contend at C.
A TM algorithm A is strictly disjoint-access-parallel, if in each execution α of A, and for every
two transactions T1 and T2 executed in α, α |T1 and α |T2 contend on some base object, only if T1
and T2 conflict in α.
A TM algorithm A is c-disjoint-access-parallel (where c stands for concurrent), if, for every execution α produced by A and for every two transactions T1 and T2 in α, α |T1 and α |T2 concurrently
contend, only ifT1 andT2 conflict in α. Apparently, when α |T1 and α |T2 concurrently contend then
there exists a base object o such that α |T1 and α |T2 contend on o. Thus, c-disjoint-access-parallelism
is weaker than strict disjoint-access-parallelism, i.e., an algorithm that is strictly disjoint-accessparallel is also c-disjoint-access-parallel, but not vice versa. Thus, an impossibility result proved
for c-disjoint-access-parallelism also holds for strict disjoint-access-parallelism.
To circumvent our impossibility result, we study additional versions of disjoint-accessparallelism. A TM algorithm A is disjoint-access-parallel, if in each execution α of A, and for
every two transactions T1 and T2 executed in α, α |T1 and α |T2 contend on some base object, only if
there is a path between T1 and T2 in the conflict graph of the minimal execution interval of T1 and
T2. A stronger variant is r-strict disjoint-access-parallelism. R-strict disjoint-access-parallelism ensures disjoint-access-parallelism between update transactions but it guarantees a stronger form of
strict disjoint-access-parallelism between each read-only transaction and all other transactions. A
transactionT isread-only in execution α if it does not invoke any t-operations that write data items
in α. Otherwise, it is an update transaction in α. We define the write set W (T, α) of T in an execution α as the set of data items for which T invokes the write () t-operation in α (or the t-operation,
which creates the data item, if such a t-operation is supported). We say that two transactions T1
and T2 w-conflict (write conflict) in α, if eitherW (T1, α) ∩ D(T2, α)  ∅ or D(T1, α) ∩W (T2, α)  ∅.
We can define a w-conflict graph by substituting conflicts with w-conflicts in the definition of a
conflict graph. Formally, we say that a TM algorithm A is r-strictly disjoint-access-parallel, if, for
each execution α of A and every two transactionsT1 andT2 in α, if α |T1 and α |T2 contend on some
base object, then one of the following conditions holds:
• bothT1 andT2 are update transactions and there is a path betweenT1 andT2 in the w-conflict
graph of the minimal execution interval of T1 and T2, or
• at least one of T1 and T2 is a read-only transaction and T1 and T2 w-conflict in α.
Notice that a TM algorithm could include in the algorithm of each t-operation fictitious invocations of additional t-operations to ensure that each transaction accesses all data items. Such an
STM algorithm is trivially strictly disjoint-access-parallel but it works in a fake way. To avoid such
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.   
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:13
fake situations, we have provided our definitions under the natural assumption that to execute a
transaction T , each TM algorithm executes the specified code for T and provides algorithms for
the t-operations, which do not contain further invocations of t-operations.
Consistency. We prove the PCL theorem for a consistency property, called weak adaptive consistency, which combines two weak consistency properties, namely snapshot isolation [15] and
processor consistency [3, 27] (both defined below), in a way that weak adaptive consistency is
weaker than both. Roughly speaking, weak adaptive consistency allows the transactions of each
execution to be partitioned into groups so that either snapshot isolation or processor consistency
is ensured for the transactions of each group.
We first define snapshot isolation (Definitions 3.2 and 3.1) and then provide a formal definition of processor consistency (Definition 3.3). Finally, we provide the definition of weak adaptive consistency (Definition 3.4). Before formalizing each definition, we provide some necessary
machinery.
A read t-operation, x.read(), by some transaction T is global, if T has not invoked x.write ()
before invoking x.read(). LetT be a committed or commit-pending transaction executed by a process p in an execution α. Let Hα |T |readд be the longest subsequence of Hα |T consisting only of
global read invocations and their matching responses. Let Hα |T |other be the longest subsequence
of Hα |T consisting of write invocations and their matching responses and of non-global read invocations and their matching responses. Moreover, let Hα |T |write be the longest subsequence of
Hα |T consisting only of write invocations and their matching responses. Denote by λ the empty
history. We define three histories Hα |Tд, Hα |Trw and Hα |Tw , each containing a single transaction
Tд, Trw , and Tw (executed by p), respectively, in the following way:
• Hα |Tд = beдinT · ack · Hα |T |readд ·commitTд · CTд if Hα |T |readд  λ, and Hα |Tд = λ
otherwise,
• Hα |Trw = beдinT · ack · Hα |T |other ·commitTr · CTr if Hα |T |other  λ, and Hα |Tr = λ
otherwise, and
• Hα |Tw = beдinT · ack · Hα |T |write ·commitTw · CTw if Hα |T |write  λ, and Hα |Tw = λ
otherwise.
We continue to provide two versions of snapshot isolation. The first (Definition 3.1) places restrictions on the values returned only by those read t-operations that are global, whereas the second (Definition 3.2) places additional restrictions on the values returned by other read t-operations
as well. Thus, the second definition is stronger. To make our results stronger, we prove the PCL
theorem assuming the weak version of snapshot isolation (Definition 3.1), whereas we discuss TM
algorithms that ensure the strong version of it (Definition 3.2).
Definition 3.1 (Snapshot isolation). A finite execution α satisfies snapshot isolation, if there exists
a set com(α) consisting of all committed and some of the commit-pending transactions in α for
which the following hold: for each transaction T ∈ com(α), it is possible to insert (in α) a global
read serialization point ∗T,д and a write serialization point ∗T,w , so that if σα is the sequence
defined by these serialization points, the following hold:
(1) ∗T,д precedes ∗T,w in σα ,
(2) both ∗T,д and ∗T,w are inserted within the active execution interval of T ,
(3) if Hσα is the history we get if, for each T ∈ com(α), we replace each ∗T,д with Hα |Tд and
each ∗T,w with Hα |Tw in σα , then Hσα is legal.
Definition 3.2 (R/W-independent snapshot isolation). A finite execution α satisfies R/Windependent snapshot isolation, if there exists a set com(α) consisting of all committed and some
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.   
2:14 V. Bushkov et al.
of the commit-pending transactions in α for which the following holds: for each transaction
T ∈ com(α), it is possible to insert (in α) a global read serialization point ∗T,д and a write serialization point ∗T,rw , so that if σα is the sequence defined by these serialization points, the following
hold:
(1) ∗T,д precedes ∗T,rw in σα ,
(2) both ∗T,д and ∗T,rw are inserted within the active execution interval of T ,
(3) if Hσα is the history we get if, for each T ∈ com(α), we replace each ∗T,д with Hα |Tд and
each ∗T,rw with Hα |Trw in σα , then Hσα is legal.
A TM algorithm A satisfies snapshot isolation (or R/W-independent snapshot isolation), if each
execution of A satisfies snapshot isolation (or R/W-independent snapshot isolation, respectively).
In the above two definitions (as well as in the definitions that follow), we define consistency conditions for finite executions. However, it is possible to define a consistency condition for infinite
executions by requiring that each finite prefix of an infinite execution satisfies the consistency
condition.
Since we require neither consistency for non-global reads nor aborting two concurrent transactions writing to the same data item, our definition of snapshot isolation (Definition 3.1) is
weaker than the definition of snapshot isolation from databases [15]). This makes the PCL theorem stronger.
We continue to define processor consistency. Roughly speaking, processor consistency allows
each process to have its own sequential view (for the committed and some of the commit-pending
transactions in the concurrent execution) but it requires that writes to the same data item occur
in the same order in each sequential view.
Definition 3.3 (Processor consistency). A finite execution α satisfies processor consistency if there
exists a setcom(α) consisting of all committed and some of the commit-pending transactions in α
for which the following holds: for each process pi , it is possible to insert (in α) a serialization point
∗i
T , for each transaction T ∈ com(α), so that if σi
α is the sequence defined by these serialization
points, the following hold:
(1) for each T1,T2 ∈ com(α):
(a) if T1 and T2 are executed by the same process and T1 <α T2, then ∗i
T1 precedes ∗i
T2 in
σi
α ,
(b) if T1 and T2 write to the same data item and ∗i
T1 precedes ∗i
T2 in σi
α , then for each
j ∈ {1,...,n}, ∗
j
T1 precedes ∗
j
T2 in σ j
α ,
(2) if Hσi
α is the history we get if, for each T ∈ com(α), we replace each ∗i
T in σi
α with Hα |T ,
if T commits in α, or with Hα |T · CT , if T is commit-pending in α, then every transaction
executed by pi is legal in Hσi
α .
We remark that in Definition 3.3, the serialization point of each transaction T ∈ com(α) may be
chosen differently for different processes, i.e., σi
α  σ j
α , for i  j. We call σi
α the sequential view of
process pi . For simplicity, we omit the superscript i from ∗i
T when it is clear from the context.
Snapshot isolation is not stronger or weaker than processor consistency. To prove that snapshot
isolation is not stronger than processor consistency, consider the execution α, shown in Figure 2,
in which transaction T1, executed by process p1, reads the value 0 for data item x, writes the value
1 to data items y and z, and commits; moreover, transaction T2, executed by a process p2, reads
the value 0 for y, writes the value 1 to x and z, and commits. Notice that the x-axis represents
time, so T1 and T2 are executed concurrently in α. Execution α satisfies snapshot isolation, since
we can insert the read serialization points of both T1 and T2 before the write serialization points of
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.  
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:15
Fig. 2. An execution α that satisfies snapshot isolation but does not satisfy processor consistency.
Fig. 3. An execution β that satisfies processor consistency but does not satisfy snapshot isolation.
both transactions to satisfy the constraints of Definition 3.1. However, α does not satisfy processor
consistency, since both T1 and T2 write to the same data item z, and therefore in both σ1
α and σ2
α
either ∗T1 precedes ∗T2 or ∗T2 precedes ∗T1 . If ∗T1 precedes ∗T2 , then transaction T2 is not legal in
Hσ 2
α . If ∗T2 precedes ∗T1 , then transaction T1 is not legal in Hσ 1
α .
To prove that snapshot isolation is not weaker than processor consistency, consider the sequential execution β, shown in Figure 3, in which transaction T1, performed by process p1, is executed
solo to write the value 1 to data item x and commit. Then, transaction T2, executed by process p2,
starts its execution, reads the value 0 for x, and commits. We argue that β satisfies processor consistency. Transaction T1 does not contain any read t-operations, and therefore, independently of
the order of ∗T1 and ∗T2 in σ1
β ,T1 is legal in Hσ 1
β
; moreover, if we define sequence σ2
β (for process p2)
to be such that ∗T2 precedes ∗T1 in it, then T2 is legal in Hσ 2
β
. However, β does not satisfy snapshot
isolation. By Definition 3.1, ∗T1,w should be inserted within the execution interval of T1 and ∗T2,д
should be inserted within the execution interval ofT2. Apparently,T1 <β T2, so ∗T1,w must precede
∗T2,д in σβ . Thus, T2,д is not legal in Hσβ .
We are now ready to provide the machinery needed for formulating weak adaptive consistency.
Let Tl and Tr be two transactions in an execution α such that either Tl = Tr (i.e., Tl and Tr are
the same) or the invocation of beдinTl precedes the invocation of beдinTr . A consistency group
G(Tl ,Tr ) of α is a set of transactions from α such that: (1) Tl and Tr belong to G(Tl ,Tr ), and (2) a
transaction Tk belongs to G(Tl ,Tr ) if the invocation of beдinTk occurs in α between the invocation
of beдinTl and the invocation of beдinTr . In other words, a consistency group G(Tl ,Tr ) of α is a
set containing the transactions that start their execution (i.e., they invoke beдinT ) between the
beginning of Tl and the beginning of Tr (inclusive). The active execution interval of G(Tl ,Tr ) is the
longest execution interval of α, which includes all steps in α from the first step of Tl to the last
step of any transaction from G(Tl ,Tr ). A consistency group G(Tl ,Tr ) precedes a consistency group
G(T 
l ,T 
r ) in α, if the last step of any transaction from G(Tl ,Tr ) precedes the first step of T 
l in α.
A consistency partition P (α) of a finite execution α is a sequence G(Tl,1,Tr,1),
G(Tl,2,Tr,2),...G(Tl,n,Tr,n ), where n > 0, of consistency groups such that:
(1) Tl,1 is the transaction that invokes the first beдin in α, and Tr,n is the transaction that
invokes the last beдin in α,
(2) for each k ∈ {1,...,n}, either Tl,k = Tr,k or beдinTl,k precedes beдinTr,k in α,
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
2:16 V. Bushkov et al.
(3) for each k ∈ {1,...,n − 1}, beдinTr,k precedes beдinTl,k+1 in α, and there is no transaction
that invokes beдin between beдinTr,k and beдinTl,k+1 in α.
Definition 3.4 (Weak adaptive consistency). A finite execution α satisfies weak adaptive consistency if it is possible to do all of the following:
• choose a consistency partition P (α),
• partition all groups in P (α) into two disjoint sets of groups: a set SI (P (α)) of snapshot isolation groups and a set PC(P (α)) of processor consistency groups,
• choose a set com(α) consisting of all committed and some of the commit-pending transactions in α, and
• for each processpi , insert (in α) a global read serialization point ∗i
T,д
and a write serialization
point ∗i
T,w , for each transaction T ∈ com(α), so that if σi
α is the sequence defined by these
serialization points, the following hold:
(1) ∗i
T,д precedes ∗i
T,w in σi
α ,
(2) for each T1,T2 ∈ com(α), if T1 and T2 write to the same data item and ∗i
T1,w precedes ∗i
T2,w
in σi
α , then ∀j ∈ {1,...,n}, ∗j
T1,w precedes ∗
j
T2,w in σ j
α ,
(3) for each group G(Tl,k ,Tr,k ) ∈ SI (P (α)) the following holds: for each T ∈ G(Tl,k ,Tr,k ) ∩
com(α), both ∗i
T,д
and ∗i
T,w are inserted within the active execution interval of T ,
(4) for each group G(Tl,k ,Tr,k ) ∈ PC(P (α)) the following holds: for each T ∈ G(Tl,k ,Tr,k ) ∩
com(α), ∗i
T,д
and ∗i
T,w are inserted at the same point within the active execution interval
of G(Tl,k ,Tr,k ),
(5) if Hσi
α is the history we get if, for each T ∈ com(α), we replace each ∗i
T,д
with H|Tд and
each ∗i
T,w with H|Tw in σi
α , then every transaction executed by pi is legal in Hσi
α .
An STM algorithmI satisfies weak adaptive consistency, if each execution produced by I satisfies
weak adaptive consistency. We remark that items (3) and (4) of Definition 3.4 imply that the global
read and write serialization points of any transaction T ∈ com(α) are placed within the active
execution interval of the consistency group to which T belongs.
Lemma 3.5. Consider any execution α that satisfies weak adaptive consistency and letG(Tl,k ,Tr,k )
and G(Tl,k,Tr,k ) be two consistency groups from P (α) such that the active execution interval of
G(Tl,k ,Tr,k ) precedes the active execution interval of G(Tl,k,Tr,k ). Then, for every process pi , the
following holds: for each T ∈ G(Tl,k ,Tr,k ) and for each T  ∈ G(Tl,k,Tr,k ), ∗T,w precedes ∗T 
,д in σi
α .
Weak adaptive consistency is weaker than processor consistency [27], and consequently is
weaker than causal serializability [37], serializability [46], opacity [30], and any other property
stronger than processor consistency. This is so because if an execution α satisfies processor consistency, then there exists a consistency partition P (α) = G(Tl ,Tr ) consisting only of one processor
consistency group such that the active execution interval ofG(Tl ,Tr ) is the entire execution α, and
therefore, serialization points of transactions from G(Tl ,Tr ) can be inserted anywhere in α. Weak
adaptive consistency is also weaker than snapshot isolation, because in the definition of snapshot
isolation there is only one sequential view σα , the same for all processes, and condition (2) of the
above definition trivially holds for the case of a single sequential view σα . In fact, weak adaptive
consistency is weaker than the union of snapshot isolation and processor consistency, if we consider each consistency condition to be a set of executions, namely, those executions that satisfy
the consistency condition.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:17
Fig. 4. Execution β.
4 THE PCL THEOREM
In this section, we present the PCL theorem. For simplicity, we first provide, in Section 4.1, the
proof for the special case where the TM algorithm (1) ensures strict disjoint-access-parallelism
and (2) uses primitives that atomically access only one base object. In Section 4.2, we provide the
proof for the general impossibility result that focuses on c-disjoint-access-parallel TM algorithms
from primitives that can atomically access up to n base objects. The proof for the general case uses
the same line of reasoning as for the special case but it is more complicated.
4.1 Special Case: TM Ensuring Strict Disjoint-Access-Parallelism from Primitives
Operating on Single Objects
In this section, we show that it is impossible to implement a TM that ensures weak adaptive consistency, obstruction-freedom, and strict disjoint-access-parallelism, using primitives that atomically
access only one base object.
The main idea behind the proof is the following. We employ two transactions T1, executed by
process p1, and T2, executed by process p2, which write different values 1 and 2, respectively, for
the same data item a and one transactionT7, which reads a. We show that there are two executions
α = α1 · α2 · s1 · s2 · α7 and α = α1 · α2 · s2 · s1 · α
7, legal from an initial configuration C0, where α1
and α2 are parts of solo executions of T1 and T2, respectively, s1 and s2 are single steps by T1 and
T2, respectively, and α7 and α
7 are solo executions of T7 (by a distinct process p7) until T7 commits.
We derive a contradiction by proving that although α7 and α
7 are indistinguishable to process p7,
T7 reads different values for a in α7 and α
7.
The proof employs several transactions T3,T4,T5,T6, which are used to ensure that the write
serialization points of T1 and T2 should be placed differently in certain executions. These executions, called β and β
, are enhancements of α and α
, respectively, such that β is indistinguishable
from α and β is indistinguishable from α to process p7; executions β and β contain solo executions of some of the transactions T3,T4,T5,T6 until each of them commits. We choose transactions
T3,T4,T5,T6 so that none of them conflicts with T7 in any execution. Therefore, strict disjointaccess-parallelism implies that the solo executions of each of them in β (or in β
) do not contend
with α7 (or α
7, respectively). Additionally, T3,T4 do not conflict with T5,T6 in any execution.
TransactionsT3 andT5 are used to define α1 · s1 and α2 · s2, respectively. TransactionT4 together
with T3 are used to constrain the serialization points of T1 and T2 in β = α1 · α2 · s1 · α3 · α4 · s2 · α7
(see Figure 4), where α3 is the solo execution of transaction T3 until it commits, and α4 is the solo
execution of transaction T4 until it commits. Similarly, transaction T6 together with T5 are used
to constrain the serialization points of T1 and T2 in β = α1 · α2 · s2 · α5 · α6 · s1 · α
7 (see Figure 10),
where α5 is the solo execution of transaction T5 until it commits, and α6 is the solo execution of
transaction T6 until it commits.
For the purpose of simplifying the discussion, assume that the TM algorithm ensures snapshot isolation. We first prove that T3 reads the value 1 for a data item b1 written by T1, in β, and
consequently, the write serialization point of T1 must be placed before the serialization points of
T3 in β. Figure 5 illustrates the order of these serialization points, as well as of those discussed
next. Snapshot isolation implies that the serialization points of T3 and T4 must be placed within
the execution intervals of T3 and T4, respectively. Thus, the serialization points of T3 precede the
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
2:18 V. Bushkov et al.
Fig. 5. The order of write and global read serialization points of transactions in β assuming snapshot
isolation.
serialization points of T4 in β. We also prove that T4 reads the value 0 for a data item d2 written
by T2, in β, and consequently, the write serialization point of T2 must be placed after the read serialization point of T4 in β. Hence, the write serialization point of T2 must be placed after the write
serialization point of T1 in β. Finally, we prove that T7 reads the value 2 for a data item c2 written
by T2, in β, and consequently, the write serialization point of T2 must be placed before the read
serialization point of T7 in β. Since the write of T1 is serialized before the write of T2, which, in
turn, is serialized before the read of T7, it follows that T7 should read the value 2 for a in β. Since
β is indistinguishable from α to process p7, T7 has the same behavior in α.
We use analogous arguments, based on transactions T5 and T6, to prove that in β
, the write
serialization point of T2 precedes the write serialization point of T1, which, in turn, precedes the
read serialization point of T7. Thus, T7 should read 1 for a in β
. Since β is indistinguishable from
α to process p7 and α
7 is indistinguishable from α7 to process p7, T7 must have the same behavior
in α7 as in β
. This contradicts our claim that T7 reads the value 2 for a in α7.
We argue that the order we impose for serialization points in β (as well as in β
) still holds
if we weaken the consistency guarantees to weak adaptive consistency. In this case, we have to
constrain the write serialization points of T1 and T2 in the sequential view of process p7. To do so,
we introduce additional data items that are written by some of the transactions and therefore the
write serialization points of these transactions should appear in the same order in the sequential
views of all processes; for instance, e1,3 is an example of such a data item that is written by both
T1 and T3.
We are now ready to present the formal proof of the following theorem.
Theorem 4.1. There is no TM algorithm from primitives that can atomically access only one
base object, which is strictly disjoint-access-parallel and satisfies weak adaptive consistency and
obstruction-freedom in an asynchronous shared-memory system with at least seven processes.
The proof is by contradiction. Assume that there exists an obstruction-free TM algorithm A
from primitives that can atomically access only one base object, which is strictly disjoint-accessparallel and satisfies weak adaptive consistency.
Consider an execution β of A and any process pi . Since A satisfies weak adaptive consistency,
there exist a consistency partition P (β), a set com(β) of committed and commit-pending transactions from β, and a sequence σi
β of serialization points for process pi , which satisfy the conditions
of Definition 3.4. For simplicity, we use the following notation: ∗T,t1 <i ∗T 
,t2 , whereT,T  ∈ com(β)
and t1,t2 ∈ {д,w}, to identify that ∗T,t1 precedes ∗T 
,t2 in σi
β . For simplicity, we have omitted β from
this notation, since later on, the execution we refer to is always clear from the context. Moreover,
throughout the proof, we use the term execution interval instead of active execution interval, whenever it is clear from the context. For the proof, we assume that the initial value of every data item
is 0. We also assume that each transaction is executed by a distinct process.
We are now ready to introduce seven transactions, T1,...,T7. For describing the t-operations
they perform, we denote by bk ,ck ,dk , 1 ≤ k ≤ 7, data items written by transaction Tk and by ek,m,
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:19
Table 3. Data Items Read and Written
by Transactions T1,...,T7
Data items read Data items written
T1 b3,b7 a,b1,c1,d1, e1,3
T2 b5,b7 a,b2,c2,d2, e2,5, e2,7
T3 b1,b4 b3,c3, e1,3, e3,4
T4 d2,c3 b4, e3,4
T5 b2,b6 b5,c5, e2,5, e5,6
T6 d1,c5 b6, e5,6
T7 a,c1,c2 b7, e2,7
Table 4. Conflicting Transactions
T1 T2 T3 T4 T5 T6 T7
T1 c c c c
T2 c c c c
T3 c c
T4 c c
T5 c c
T6 c c
T7 c c
If a pair of transactions can conflict in some execution, then the cell corresponding to the pair contains the letter “c.”
1 ≤ m ≤ 7, m  k, data items written by both transactions Tk and Tm. We assume that the initial
value of every data item is 0. Transactions T1,...,T7 are presented below:
• T1, executed by process p1: reads data items b3 and b7, and writes the value 1 to data items
a, b1, c1, d1, e1,3,
• T2, executed by process p2: reads data items b5 and b7, and writes the value 2 to data items
a, b2, c2, d2, e2,5, e2,7,
• T3, executed by process p3: reads data items b1 and b4, and writes the value 1 to data items
b3, c3, e1,3, e3,4,
• T4, executed by process p4: reads data items d2 and c3, and writes the value 1 to data items
b4, e3,4,
• T5, executed by process p5: reads data items b2 and b6, and writes the value 1 to data items
b5, c5, e2,5, e5,6,
• T6, executed by process p6: reads data items d1 and c5, and writes the value 1 to data items
b6, e5,6,
• T7, executed by process p7: reads data items a,c1, and c2, and writes the value 1 to data items
b7, e2,7.
We remark that each transaction has a simple code that contains a constant number of invocations to t-operations. Table 3 presents the data items accessed by each of the transactions that
will be used in this proof, and Table 4 indicates whether any pair of these transactions conflict
(in any execution in which they invoke commit). For example, below is the code of transaction
T1, from which it follows that in every execution β, in which transaction T1 invokes commitT1 ,
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018. 
2:20 V. Bushkov et al.
Fig. 6. Execution δ1.
D(T1, β) ⊆ {a,b1,b3,b7,c1,d1, e1,3}. By inspecting the t-operations that each transaction performs,
it becomes clear that if β contains any two transactions from Table 3 for which it holds that the
corresponding cell of Table 4 does not contain the letter “c,” then these transactions do not conflict
in β.
beдinT1 ();
b3.read();
b7.read();
a.write (1);
b1.write (1);
c1.write (1);
d1.write (1);
e1,3.write (1);
commitT1 ();
We remark that obstruction freedom implies that when each of the simple transactions described
above is executed solo, starting from any reachable configuration, it eventually commits. We repeatedly use this argument later on to construct the required executions.
Definition of α1 and s1. Let transaction T1 be executed solo from an initial configuration C0.
Because p1 runs solo and A is obstruction-free, T1 eventually commits. In the resulting execution,
T1 reads the value 0 for data items b3 and b7, because A satisfies weak adaptive consistency and
there is no transaction that writes to these data items in this execution. LetC be the configuration
resulting from the execution of the last step of T1.
IfT3 is executed solo fromC0, then in the resulting execution,T3 reads the value 0 for b1, because
A satisfies weak adaptive consistency and no transaction writes to b1 in this execution.
Consider now the execution δ1 (see Figure 6) where transaction T3 is executed solo from C
until it commits. We prove that T3 reads the value 1 for data item b1 in δ1. Since A satisfies weak
adaptive consistency, there exist a consistency partition P (δ1) and a setcom(δ1) of committed and
commit-pending transactions from δ1, which satisfy the conditions of Definition 3.4. We consider
the following cases:
• Assume first that P (δ1) is such that T1 and T3 belong to different consistency groups G =
G(T1,T1) and G = G(T3,T3), respectively, of P (δ1). Because T1 <δ1 T3, it follows that the
execution interval of G precedes the execution interval ofG in δ1. By Lemma 3.5, it follows
that ∗T1,w <3 ∗T3,д. Hence, T3 reads the value 1 for b1.
• Assume next that P (δ1) is such that T1 and T3 belong to the same consistency group G =
G(T1,T3) andG ∈ SI (P (δ1)). SinceG is a snapshot isolation group, then ∗T1,w must be placed
within the execution interval of T1 and ∗T3,д must be placed within the execution interval
of T3. Since T1 <δ1 T3, then ∗T1,w <3 ∗T3,д. Hence, T3 reads the value 1 for b1.
• Assume now that P (δ1) is such that T1 and T3 belong to the same consistency group
G = G(T1,T3) and G ∈ PC(P (δ1)). Because T1 reads the value 0 for b3 in δ1, it follows that
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:21
Fig. 7. Executions α1, α3, α 
3, and step s1.
∗T1,д <1 ∗T3,w . Since G(T1,T3) is a processor consistency group, no serialization point is inserted between ∗T1,д and ∗T1,w . Thus, ∗T1,w <1 ∗T3,w . Because T1 and T3 write to the same
data item e1,3, it follows that ∗T1,w <3 ∗T3,w . Since no serialization point is inserted between
∗T3,д and ∗T3,w , it follows that ∗T1,w <3 ∗T3,д. Hence, T3 reads the value 1 for b1.
Since in the solo execution ofT3 fromC0,T3 reads the value 0 for b1, whereas in the solo execution
ofT3 fromC
,T3 reads the value 1 forb1, it follows that there exists some steps1 in the solo execution
ofT1 fromC0 such that: (1) if α
3 is the solo execution ofT3 (untilT3 commits) from the configuration
C1 just before s1, then in α
3, T3 reads the value 0 for b1, and (2) if α3 is the solo execution of T3
(until T3 commits) from the configuration just after s1, then in α3, T3 reads the value 1 for b1. (If
there are more than one steps with this property, then let s1 be the first of them.)
Denote by α1 the solo execution of T1 from C0 until C1 is reached (see Figure 7). Note that T3
reads the value 0 for b4 in α3 (and in α
3), since there is no transaction in α1 · s1, which writes to b4.
Property 1.
(1) T3 reads the value 0 for b1 in α
3,
(2) T3 reads the value 1 for b1 in α3, and
(3) T3 reads the value 0 for b4 in both α
3 and α3.
We continue to prove the following lemma.
Lemma 4.2. Transaction T1 invokes commitT1 and reads the value 0 for both b3 and b7 in α1.
Proof. We first prove that T1 invokes commitT1 in α1 · s1. Assume, to derive a contradiction,
that T1 does not invoke commitT1 in α1 · s1. We argue that the execution α1 · s1 · α3 does not satisfy
weak adaptive consistency. This is so because, by Property 1, T3 reads the value 1 for b1 in this
execution but T1 is not yet commit-pending and therefore we cannot assign a write serialization
point to T1 in this execution. Since α1 · s1 is a legal execution of A from C0, this contradicts the
fact that A ensures weak adaptive consistency.
We now argue that T1 does not invoke commitT1 at s1. If T1 invokes commitT1 at s1, then s1 does
not apply any primitive to any base object, and consequently α
3 and α3 are indistinguishable to
process p3. Thus, T3 reads the same value for b1 in α
3 and α3. This contradicts Property 1.
Since no transaction writes b3 and b7 in α1 and α1 satisfies weak adaptive consistency, it follows
that T1 reads the value 0 for both b3 and b7 in α1.
Lemma 4.3. Step s1 applies a non-trivial primitive pr on some base object o1 for which the following
holds: T3 accesses o1 in both α3 and α
3.
Proof. If pr is a trivial primitive on o1, then α3 and α
3 are indistinguishable to p3. So, T3 reads
the same value for b1 in α3 and α
3. This contradicts Property 1.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018. 
2:22 V. Bushkov et al.
Fig. 8. Execution δ2.
IfT3 does not access o1 in α
3, then α
3 is legal from the configuration afters1, so α
3 = α3. Similarly,
if T3 does not access o1 in α3, then α3 is legal from C1, so α3 = α
3. It follows that in either case, T3
reads the same value for b1 in α3 and α
3. This contradicts Property 1.
Definition of α2 and s2. We use arguments similar to those used to define α1 and s1, to define α2
and s2. Let transaction T2 be executed solo from the configuration C1 that results by applying α1
from C0. Because p2 runs solo and A is obstruction-free, T2 eventually commits. In the resulting
execution, T2 reads the value 0 for data items b5 and b7, because A satisfies weak adaptive consistency and there is no transaction that writes to these data items in this execution. Let C be the
configuration resulting from the execution of the last step of T2.
If transaction T5 is executed solo from configuration C1 until T5 commits, then in the resulting execution, T5 reads the value 0 for b2, because A satisfies weak adaptive consistency and no
transaction writes to b2 in this execution.
Consider now the execution δ2 (see Figure 8) where transaction T5 is executed solo from C
until it commits. We prove that T5 reads the value 2 for data item b2 in δ2. Since A satisfies weak
adaptive consistency, there exist a consistency partition P (δ2) and a setcom(δ2) of committed and
commit-pending transactions from δ2, which satisfy the conditions of Definition 3.4. We consider
the following cases:
• Assume first that P (δ2) is such that T2 and T5 belong to different consistency groups G and
G
, respectively, of P (δ2). Because no two transactions have overlapping execution intervals
in δ2 and the execution intervals of T1 and T2 precede the execution interval of T5, it follows
that the execution interval of G precedes the execution interval of G in δ2. By Lemma 3.5,
it follows that ∗T2,w <5 ∗T5,д. Hence, T5 reads the value 2 for b2.
• Assume next that P (δ2) is such that T2 and T5 belong to the same consistency group G and
G ∈ SI (P (δ2)). Since G is a snapshot isolation group, then ∗T2,w must be placed within the
execution interval of T2 and ∗T5,д must be placed within the execution interval of T5. Since
T2 <δ2 T5, then ∗T2,w <5 ∗T5,д. Hence, T5 reads the value 2 for b2.
• Assume now that P (δ2) is such that T2 and T5 belong to the same consistency group G
and G ∈ PC(P (δ2)). Because T2 reads the value 0 for b5 in δ2, it follows that ∗T2,д <2 ∗T5,w .
SinceG is a processor consistency group, no serialization point is inserted between ∗T2,д and
∗T2,w . Thus, ∗T2,w <2 ∗T5,w . BecauseT2 andT5 write to the same data item e2,5, it follows that
∗T2,w <5 ∗T5,w . Since no serialization point is inserted between ∗T5,д and ∗T5,w , it follows that
∗T2,w <5 ∗T5,д. Hence, T5 reads the value 2 for b2.
Since in the solo execution ofT5 fromC1,T5 reads the value 0 for b2, whereas in the solo execution
of T5 from C, T5 reads the value 2 for b2, it follows that there exists some step s2 in the solo
execution of T2 from C1 such that: (1) if α
5 is the solo execution of T5 (until T5 commits) from
the configuration C2 just before s2, then in α
5, T5 reads the value 0 for b2, and (2) if α5 is the solo
execution ofT5 (untilT5 commits) from the configuration just afters2, then in α5,T5 reads the value
2 for b2. (If there are more than one steps with this property, then let s2 be the first of them.)
Denote by α2 the solo execution of T2 from C1 until C2 is reached (see Figure 9). Note that T5
reads the value 0 for b6 in α5 (and in α
5), since there is no transaction in α1 · α2 · s2, which writes
to b6.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018. 
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:23
Fig. 9. Executions α1, α2, α5, α 
5, and step s2.
Property 2.
(1) T5 reads the value 0 for b2 in α
5,
(2) T5 reads the value 2 for b2 in α5, and
(3) T5 reads the value 0 for b6 in both α
5 and α5.
We continue to prove the following lemma.
Lemma 4.4. Transaction T2 invokes commitT2 and reads the value 0 for both b5 and b7 in α2.
Proof. We first prove thatT2 invokescommitT2 in α2 · s2. Assume, to derive a contradiction, that
T2 does not invoke commitT2 in α2 · s2. We argue that the execution α1 · α2 · s2 · α5 does not satisfy
weak adaptive consistency. This is so because, by Property 2, T5 reads the value 2 for b2 in this
execution but T2 is not yet commit-pending and therefore we cannot assign a write serialization
point toT2 in this execution. Since α1 · α2 · s2 · α5 is a legal execution of A fromC0, this contradicts
the fact that A ensures weak adaptive consistency.
We now argue that T2 does not invoke commitT2 at s2. If T2 invokes commitT2 at s2, then s2 does
not apply any primitive to any base object, and consequently α
5 and α5 are indistinguishable to
process p5. Thus, T5 reads the same value for b2 in α
5 and α5. This contradicts Property 2.
Since no transaction writes b5 and b7 in α1 · α2 and α1 · α2 satisfies weak adaptive consistency,
it follows that T2 reads the value 0 for both b5 and b7 in α2.
Lemma 4.5. Step s2 applies a non-trivial primitive pr on some base object o2 for which the following
holds: T5 accesses o2 in both α5 and α
5.
Proof. If pr is a trivial primitive on o2, then α5 and α
5 are indistinguishable to p5. So, T5 reads
the same value for b2 in α5 and α
5. This contradicts Property 2.
IfT5 does not access o2 in α
5, then α
5 is legal from the configuration afters2, so α
5 = α5. Similarly,
if T5 does not access o2 in α5, then α5 is legal from C2, so α5 = α
5. It follows that in either case, T5
reads the same value for b2 in α5 and α
5. This contradicts Property 2.
We next prove that execution α1 · α2 · s1 · α3 is legal from C0.
Lemma 4.6. Execution α1 · α2 · s1 · α3 is legal from C0.
Proof. Consider the execution α1 · α2 · s
1 · γ3, where s
1 is a single step by p1 and γ3 is a solo
execution of T3 by p3 until T3 commits. We argue that s
1 = s1 and γ3 is indistinguishable from α3
to p3. Let pr1 be the primitive applied by p1 in s1. Obviously, since pr1 is the primitive that p1 is
poised to perform after α1, s1 and s
1 access the same base object, namely object o1. Thus, if s1 and
s
1 are different, then they differ in their responses.
Lemma 4.3 implies that α3 accesses base object o1. Since T3 and T2 do not conflict, strict disjointaccess-parallelism implies that α2 does not contain any non-trivial primitive on any base object
accessed in γ3. Thus, the prefix of α3 until the point that o1 is first accessed is also a prefix of γ3.
Therefore, T3 accesses o1 in γ3 (as it does in α3).
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.  
2:24 V. Bushkov et al.
Becauseγ3 accesses o1 andT3 andT2 do not conflict, strict disjoint-access-parallelism implies that
α2 does not contain a non-trivial primitive on o1. It follows that s1 = s
1. This and the fact that T3
and T2 do not conflict imply that γ3 is indistinguishable from α3 to p3. So, execution α1 · α2 · s1 · α3
is legal from C0.
We also prove:
Lemma 4.7. o1  o2.
Proof. To derive a contradiction, assume that o1 = o2. By Lemma 4.6, execution α1 · α2 · s1 · α3
is legal from C0. Let pr2 be the primitive applied by p2 in s2. Since (1) T2 and T3 do not conflict,
(2) p2 is poised to execute pr2, which is a non-trivial primitive on o2 = o1, after α1 · α2 · s1 · α3, and
(3) o1 is read in α3, it follows that in execution α1 · α2 · s1 · α3 · s
2, where s
2 is a single step by p2,
strict disjoint-access-parallelism is violated. This is a contradiction. Thus, o1  o2.
Consider the executions α = α1 · α2 · s1 · s2 · α7 and α = α1 · α2 · s2 · s1 · α
7, where α7 and α
7 are
solo executions of T7 until T7 commits. Since steps s1 and s2 access different base objects (by
Lemma 4.7), α and α are both legal from C0 and α7 is indistinguishable from α
7 to process p7.
Thus, we have the following lemma.
Lemma 4.8. Executions α and α are legal from C0 and execution α7 is indistinguishable from α
7
to process p7.
By Lemma 4.6, execution α1 · α2 · s1 · α3 is legal from C0, and consequently α1 · α2 · s1 · α3 · α4,
where α4 is the solo execution of T4 until T4 commits, is legal from C0. Recall that α
5 is the solo
execution of T5 from configuration C2 (see Figure 9). Since T5 does not conflict with T1, T3, and T4,
strict disjoint-access-parallelism implies that α
5 does not contend with s1, α3, and α4, and therefore,
α1 · α2 · s1 · α3 · α4 · α
5 is legal from C0.
Lemma 4.9. Execution α1 · α2 · s1 · α3 · α4 · α
5 is legal from C0.
Let β = α1 · α2 · s1 · α3 · α4 · s2 · α7 (see Figure 4). We prove, in Lemma 4.10, that β is legal from
C0. We then prove, in Lemma 4.12, that in α7, T7 reads the value 2 for data items a and c2, and the
value 1 for data item c1.
Lemma 4.10. Execution α1 · α2 · s1 · α3 · α4 · s2 · α7 is legal from C0.
Proof. By Lemma 4.9, execution α1 · α2 · s1 · α3 · α4 is legal from C0. Consider the execution
α1 · α2 · s1 · α3 · α4 · s
2 from C0, where s
2 is a single step performed by p2. We argue that s
2 = s2.
Notice that s
2, like s2, accesses o2, since p2 is poised to apply a primitive that accesses o2 after
executing α2. It remains to argue that the response of s
2 is the same as that of s2. Since T2 and
T3 do not conflict, strict disjoint-access-parallelism implies that α3 does not contain a non-trivial
primitive on o2. We argue that the same is true for α4. By Lemma 4.9, execution α1 · α2 · s1 · α3 ·
α4 · α
5 is legal from C0. Since α
5 accesses o2 (by Lemma 4.5) and T5 does not conflict with T4, strict
disjoint-access-parallelism implies that α4 does not contain a non-trivial primitive on o2. It follows
that s
2 = s2. Thus, α1 · α2 · s1 · α3 · α4 · s2 is legal from C0.
Because T7 does not conflict with T3 and T4, it follows that α7 does not contend with α3 and α4.
Because (1) α7 does not contend with α3 and α4, (2) α1 · α2 · s1 · α3 · α4 · s2 is legal from C0, (3) and
α1 · α2 · s1 · s2 · α7 is legal from C0 (by Lemma 4.8), it follows that β is legal from C0.
Our next goal is to prove that in α7, T7 reads the value 2 for a. To restrict the serialization points
of T1 and T2 in β, we first prove the following lemma regarding the values that T4 reads for data
items d2 and c3 in α4.
Lemma 4.11. In execution α4,
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.     
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:25
(1) T4 reads the value 0 for data item d2, and
(2) T4 reads the value 1 for data item c3.
Proof. We first prove that transaction T4 reads the value 0 for d2 in α4. By Lemma 4.9, execution
δ3 = α1 · α2 · s1 · α3 · α4 · α
5 is legal fromC0. Since A satisfies weak adaptive consistency, there exist a consistency partition P (δ3) and a setcom(δ3) of committed and commit-pending transactions
from δ3, which satisfy the conditions of Definition 3.4. We argue that T2  com(δ3). Assume, by
contradiction, that T2 ∈ com(δ3). We consider the following cases.
• Assume first that P (δ3) is such that T2 and T5 belong to different consistency groups G and
G
, respectively. Since (1) the execution interval of T5 starts after the execution interval
of T1 in δ3, (2) T1 starts before the beginning of T2, and (3) the execution intervals of T1
and T2 do not overlap with the execution intervals of T3, T4, and T5, it follows that the
execution interval of G precedes the execution interval of G
. By Lemma 3.5, it follows that
∗T2,w <5 ∗T5,д. Hence, T5 reads the value 2 for b2 in α
5. This contradicts Property 2.
• Assume that P (δ3) is such that T2 and T5 belong to the same consistency group G and G ∈
SI (P (δ3)). Since G is a snapshot isolation group and the execution interval of T2 precedes
the execution interval of T5 in δ3, it follows that ∗T2,w <5 ∗T5,д. Hence, T5 reads the value 2
for b2 in α
5. This contradicts Property 2.
• Assume that P (δ3) is such that T2 and T5 belong to the same consistency group G and
G ∈ PC(P (δ3)). Since G is a processor consistency group, no serialization point is inserted
between ∗T2,д and ∗T2,w and between ∗T5,д and ∗T5,w . Because T2 reads the value 0 for b5
in α2 (by Lemma 4.4), it follows that ∗T2,д <2 ∗T5,w . Since no serialization point is inserted
between ∗T2,д and ∗T2,w , it follows that ∗T2,w <2 ∗T5,w . Because T2 and T5 write to the same
data item e2,5, it follows that ∗T2,w <5 ∗T5,w . Since no serialization point is inserted between
∗T5,д and ∗T5,w , it follows that ∗T2,w <5 ∗T5,д. Hence, T5 reads the value 2 for b2 in α
5. This
contradicts Property 2.
Hence, T2  com(δ3), and consequently T4 reads the value 0 for d2 in α4.
We next prove that transactionT4 reads the value 1 forc3 in α4. Lemma 4.9 implies that δ4 = α1 · α2 ·
s1 · α3 · α4 is legal from C0. Since A satisfies weak adaptive consistency, there exist a consistency
partition P (δ4) and a set com(δ4) of committed and commit-pending transactions from δ4, which
satisfy the conditions of Definition 3.4. We argue that ∗T3,w <4 ∗T4,д by considering the following
cases:
• Assume first that P (δ4) is such that T3 and T4 belong to different consistency groups G and
G
, respectively. Since the execution intervals of T1,T2,T3 precede the execution interval of
T4 in δ4, the execution interval of G precedes the execution interval of G
. By Lemma 3.5, it
follows that ∗T3,w <4 ∗T4,д.
• Assume now that P (δ4) is such that T3 and T4 belong to the same consistency group G
and G ∈ SI (P (δ4)). Since G is a snapshot isolation group and the execution interval of T3
precedes the execution interval of T4 in δ4, it follows that ∗T3,w <4 ∗T4,д.
• Assume now that P (δ4) is such that T3 and T4 belong to the same consistency group G and
G ∈ PC(P (δ4)). Since G is a processor consistency group, no serialization point is inserted
between ∗T3,д and ∗T3,w and between ∗T4,д and ∗T4,w . Since T3 reads the value 0 for b4 in α3
(by Property 1), it follows that ∗T3,д <3 ∗T4,w . Since no serialization point is inserted between
∗T3,д and ∗T3,w , it follows that ∗T3,w <3 ∗T4,w . Because T3 and T4 write to the same data item
e3,4, it follows that ∗T3,w <4 ∗T4,w . Since no serialization point is inserted between ∗T4,д and
∗T4,w , it follows that ∗T3,w <4 ∗T4,д.
In all cases, ∗T3,w <4 ∗T4,д. Hence, T4 reads the value 1 for c3 in α4.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.   
2:26 V. Bushkov et al.
We are now ready to prove that T7 reads the value 2 for data item a. We prove the following:
Lemma 4.12. T7 reads the value 2 for data items a and c2, and the value 1 for data item c1 in α7.
Proof. We first prove that T7 reads the value 2 forc2 in α7. Notice that α1 · α2 · s1 · s2 · α5 is legal
from C0. This is so because (1) α1 · α2 · s2 · α5 is legal from C0 (by definition of α5), (2) s1 and s2
are steps on different base objects (by Lemma 4.7), and (3) and T5 does not conflict with T1, so α5
and s1 do not contend. We argue that δ5 = α1 · α2 · s1 · s2 · α5 · α7 is also legal from C0. This is so
because execution α1 · α2 · s1 · s2 · α5 is legal from C0, execution α1 · α2 · s1 · s2 · α7 is legal from C0
(by Lemma 4.8), and T7 does not conflict with T5.
Since A satisfies weak adaptive consistency, there exist a consistency partition P (δ5) and a set
com(δ5) of committed and commit-pending transactions from δ5, which satisfy the conditions of
Definition 3.4. Since T5 reads the value 2 for b2 (by Property 2) in α5, it follows that T2 ∈ com(δ5)
and ∗T2,w <5 ∗T5,д. We consider the following cases.
• Assume first that P (δ5) is such that T2 and T7 belong to different consistency groups G and
G
, respectively. Since (1) the execution interval of T1 starts before the execution interval of
T2, (2) the execution intervals of T1 and T2 precede the execution intervals of T5 and T7 in
δ5, and (3) the execution interval of T5 precedes the execution interval of T7 , it follows that
the execution interval of G precedes the execution interval of G
. By Lemma 3.5, it follows
that ∗T2,w <7 ∗T7,д. Hence, T7 reads the value 2 for c2 in α7.
• Assume now that P (δ5) is such that T2 and T7 belong to the same consistency group G
and G ∈ SI (P (δ5)). Assume now that P (δ5) includes G(Ti,T7), for some i ∈ {1, 2} and that
G(Ti,T7) ∈ SI (P (δ5)). Since the execution interval of T2 precedes the execution interval of
T7 and T2,T7 ∈ G(Ti,T7), which is a snapshot isolation group, it follows that ∗T2,w <7 ∗T7,д.
Hence, T7 reads the value 2 for c2 in α7.
• Assume now that P (δ5) is such that T2 and T7 belong to the same consistency group G and
G ∈ PC(P (δ5)). Since G is a processor consistency group, no serialization point is inserted
between ∗T2,д and ∗T2,w and between ∗T7,д and ∗T7,w . Because T2 reads 0 for b7 in α2 (by
Lemma 4.4), it follows that ∗T2,д <2 ∗T7,w . Since no serialization point is inserted between
∗T2,д and ∗T2,w , it follows that ∗T2,w <2 ∗T7,w . Because T2 and T7 write to the same data item
e2,7, it follows that ∗T2,w <7 ∗T7,w . Since no serialization point is inserted between ∗T7,д and
∗T7,w , it follows that ∗T2,w <7 ∗T7,д. Hence, T7 reads the value 2 for c2 in α7.
By Property 1, T3 reads the value 1 for b1 in β. Thus, ∗T1,w <3 ∗T3,д <3 ∗T3,w . Because T1 and T3
write to the same data item e1,3, it follows that ∗T1,w <4 ∗T3,w . Since T4 reads the value 0 for d2 and
1 forc3 in α4 (by Lemma 4.11), it follows that ∗T3,w <4 ∗T4,д <4 ∗T2,w . Thus, ∗T1,w <4 ∗T2,w . Because
T1 andT2 write to the same data item a, it follows that ∗T1,w <7 ∗T2,w . SinceT7 reads the value 2 for
c2 in α7, it follows that ∗T2,w <7 ∗T7,д. Thus, ∗T1,w <7 ∗T2,w <7 ∗T7,д, and consequently, it follows
that T7 reads the value 2 for a and 1 for c1 in α7.
Our next goal is to define execution β and prove that although it is indistinguishable from β
to process p7, p7 reads the value 1 for data item a in β
. To define β
, we first prove the following
technical lemma.
Lemma 4.13. Execution α1 · α2 · s2 · α5 · α6 · α
3, where α6 is the solo execution of T6 until T6 commits, is legal from C0.
Proof. By definition of α5, execution α1 · α2 · s2 · α5 is legal from C0, and consequently α1 · α2 ·
s2 · α5 · α6 is legal from C0. Recall that α
3 is the solo execution of T3 from the configuration C1 that
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018. 
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:27
Fig. 10. Execution β
.
results when execution α1 is applied from C0 (see Figure 7). Since T3 does not conflict with T2, T5,
and T6, strict disjoint-access-parallelism implies that α
3 does not contend with α2 · s2, α5, and α6.
Thus, α1 · α2 · s2 · α5 · α6 · α
3 is legal from C0.
Let β = α1 · α2 · s2 · α5 · α6 · s1 · α
7 (see Figure 10). We prove in Lemma 4.14 that β is legal from
C0. We then prove in Lemma 4.16 that in α
7, T7 reads the value 1 for data item a.
Lemma 4.14. Execution β = α1 · α2 · s2 · α5 · α6 · s1 · α
7 is legal from C0.
Proof. Lemma 4.13 implies that execution α1 · α2 · s2 · α5 · α6 is legal from C0. Consider the
execution α1 · α2 · s2 · α5 · α6 · s
1 starting from C0, where s
1 is a single step performed by p1. We
argue that s
1 = s1. Notice that s
1, like s1, accesses o1, since p1 is poised to apply a primitive that
accesses o1 after executing α1. It remains to argue that the response of s
1 is the same as that of s1.
Since T1 and T5 do not conflict, strict disjoint-access-parallelism implies that α5 does not contain
a non-trivial primitive on o1. We argue that the same is true for α6. Consider the execution α1 ·
α2 · s2 · α5 · α6 · α
3, which is legal from C0 (by Lemma 4.13). Since α
3 accesses o1 (by Lemma 4.3)
and T3 does not conflict with T6, strict disjoint-access-parallelism implies that α6 does not contain
a non-trivial primitive on o1. It follows that s
1 = s1. Thus, α1 · α2 · s2 · α5 · α6 · s1 is legal from C0.
BecauseT7 does not conflict withT5 andT6, strict disjoint-access-parallelism implies that α
7 does
not contend with α5 and α6. Since (1) α
7 does not contend with α5 and α6, (2) α1 · α2 · s2 · α5 · α6 · s1
is legal from C0 (by Lemma 4.14), and (3) α1 · α2 · s2 · s1 · α
7 is legal from C0 (by Lemma 4.8), it
follows that β is legal from C0.
Our next goal is to prove that, in α
7,T7 reads the value 1 for data item a. To restrict the serialization points of T1 and T2 in β
, we first prove the following two lemmas regarding the values that
T6 reads for data items d1 and c5 in α6.
Lemma 4.15. In execution α6,
(1) T6 reads the value 0 for data item d1, and
(2) T6 reads the value 1 for data item c5.
Proof. We first prove that transaction T6 reads the value 0 for d1 in α6. By Lemma 4.13, δ6 =
α1 · α2 · s2 · α5 · α6 · α
3 is legal from C0. Since A satisfies weak adaptive consistency, there exist
a consistency partition P (δ6) and a set com(δ6) of committed and commit-pending transactions
from δ6, which satisfy the conditions of Definition 3.4. We argue that T1  com(δ6). Assume, by
contradiction, that T1 ∈ com(δ6). We consider the following cases.
• Assume first that P (δ6) is such that T1 and T3 belong to different consistency groups G and
G
, respectively. Since (1) the execution interval of T1 precedes the execution intervals of
T2, T3, T6, and T5, (2) the execution intervals of any two transactions in δ6 do not overlap,
and (3) the execution interval of any transaction in δ6 other than T3 precedes the execution
interval of T3, it follows that the execution interval of G precedes the execution interval of
G in δ6. By Lemma 3.5, it follows that ∗T1,w <3 ∗T3,д. Hence, T3 reads the value 1 for b1 in
α
3. This contradicts Property 1.
• Assume next that P (δ6) is such that T1 and T3 belong to the same consistency group G
and G ∈ SI (P (δ6)). Since G is a snapshot isolation group and the execution interval of T1
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.   
2:28 V. Bushkov et al.
precedes the execution interval ofT3 in δ6, it follows that ∗T1,w <3 ∗T3,д. Hence,T3 reads the
value 1 for b1 in α
3. This contradicts Property 1.
• Assume next that P (δ6) is such that T1 and T3 belong to the same consistency group G and
G ∈ PC(P (δ6)). Since G is a processor consistency group, no serialization point is inserted
between ∗T1,д and ∗T1,w and no serialization point is inserted between ∗T3,д and ∗T3,w . Because T1 reads the value 0 for b3 in α1 (by Lemma 4.2), it follows that ∗T1,д <1 ∗T3,w . Since
no serialization point is inserted between ∗T1,д and ∗T1,w , it follows that ∗T1,w <1 ∗T3,w . Because T1 and T3 write to the same data item e1,3, it follows that ∗T1,w <3 ∗T3,w . Since no
serialization point is inserted between ∗T3,д and ∗T3,w , it follows that ∗T1,w <3 ∗T3,д. Hence,
T3 reads the value 1 for b1 in α
3. This contradicts Property 1.
Hence, T1  com(δ6), and consequently T6 reads the value 0 for d1 in α6.
We next prove that T6 reads the value 1 forc5 in α6. Lemma 4.13 implies that δ7 = α1 · α2 · s2 · α5 ·
α6 is legal fromC0. Since A satisfies weak adaptive consistency, there exist a consistency partition
P (δ7) and a setcom(δ7) of committed and commit-pending transactions from δ7, which satisfy the
conditions of Definition 3.4. We consider the following cases (to argue that ∗T5,w <6 ∗T6,д):
• Assume first that P (δ7) is such that T5 and T6 belong to different consistency groups G and
G
, respectively. Because the execution intervals of T1, T2, and T5 precede the execution interval ofT6, the execution interval ofG precedes the execution interval ofG
. By Lemma 3.5,
it follows that ∗T5,w <6 ∗T6,д.
• Assume first that P (δ7) is such that T5 and T6 belong to the same consistency group G
and G ∈ SI (P (δ7)). Since G is a snapshot isolation group and the execution interval of T5
precedes the execution interval of T6 in δ7, it follows that ∗T5,w <6 ∗T6,д.
• Assume first that P (δ7) is such that T5 and T6 belong to the same consistency group G and
G ∈ PC(P (δ7)). Since G is a processor consistency group, no serialization point is inserted
between ∗T5,д and ∗T5,w and no serialization point is inserted between ∗T6,д and ∗T6,w . Since
T5 reads the value 0 for b6 in α5 (by Property 2), it follows that ∗T5,д <5 ∗T6,w . Since G is
a processor consistency group, no serialization point is inserted between ∗T5,д and ∗T5,w .
Thus, ∗T5,w <5 ∗T6,w . Because T5 and T6 write to the same data item e5,6, it follows that
∗T5,w <6 ∗T6,w . Since no serialization point is inserted between ∗T6,д and ∗T6,w , it follows
that ∗T5,w <6 ∗T6,д.
In all cases, ∗T5,w <6 ∗T6,д. Thus, T6 reads the value 1 for c5 in α6.
We are now ready to argue about the value that T7 reads for data item a in α
7.
Lemma 4.16. T7 reads the value 1 for a in α
7.
Proof. By Lemma 4.8, α
7 and α7 are indistinguishable to p7. Thus, T7 reads the same values in
α
7 and α7. In particular, T7 reads the value 1 for c1 in α7 (by Lemma 4.12), and consequently, T7
reads the value 1 for c1 in α
7.
By Property 2, T5 reads the value 2 for b2 in α5. Thus, ∗T2,w <5 ∗T5,д <5 ∗T5,w . Because T2 and T5
write to the same data item e2,5, it follows that ∗T2,w <6 ∗T5,w . Since T6 reads the value 0 for d1 and
1 for c5 (by Lemma 4.15), it follows that ∗T5,w <6 ∗T6,д <6 ∗T1,w . Thus, ∗T2,w <6 ∗T1,w . Because T1
and T2 write to the same data item a, it follows that ∗T2,w <7 ∗T1,w . Since T7 reads the value 1 for
c1 in α
7, it follows that ∗T1,w <7 ∗T7,д. Thus, ∗T2,w <7 ∗T1,w <7 ∗T7,д, and consequently,T7 reads the
value 1 for a in α
7.
By Lemma 4.12, T7 reads the value 2 for data item a in α7. By Lemma 4.16, T7 reads the value 1
for data item a in α
7. Since α7 is indistinguishable from α
7 to process p7 (by Lemma 4.8), this is a
contradiction. This completes the proof of Theorem 4.1.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.   
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:29
4.2 The General Case
In this section, we generalize the impossibility result presented in Theorem 4.1 to prove that it
holds even when a primitive may atomically access up to n base objects, provided that if a process
is poised to perform a primitive pr at some configurationC, pr will access the same base objects and
attempt to modify the same subset of them, independently of when the process will be scheduled
to apply its next step by the scheduler. We also generalize Theorem 4.1 to hold for TM algorithms
that are c-disjoint-access-parallel.
To go from the case when a primitive atomically accesses one base object to the case when
a primitive atomically accesses up to n base objects, we consider a set of n + 1 transactions
T 1
1 ,...,T n+1 1 , which do not conflict with each other, from which we will choose one transaction to
play the role of T1 in the proof. Moreover, we choose the transaction to play the role of T3 from a
set of n + 1 transactions T 1
3 ,...,T n+1 3 (which do not conflict with each other). These transactions
are designed so that, for each i, 1 ≤ i ≤ n + 1, Ti
1 conflicts with Ti
3 but not with T j
3 , for every j  i,
1 ≤ j ≤ n + 1.
We also consider a set of n(n + 1) + 1 transactions T 1
2 ,...,T n(n+1)+1
2 , which do not conflict with
each other, from which we will choose one transaction to play the role of T2. Moreover, we choose
the transaction to play the role ofT5 from a set of n(n + 1) + 1 transactionsT 1
5 ,...,T n(n+1)+1
5 (which
do not conflict with each other). These transactions are designed so that, for each i, 1 ≤ i ≤ n(n +
1) + 1, Ti
2 conflicts with Ti
5 , but not with T j
5 , for every j  i, 1 ≤ j ≤ n(n + 1) + 1.
Similarly to what we do in the simple case usingT1 andT3, for each pairTi
1 ,Ti
3 , 1 ≤ i ≤ n + 1, we
define a step si
1 of Ti
1 after which Ti
3 observes an update to a data item that Ti
1 writes and Ti
3 reads;
similarly, for each pair Ti
2 and Ti
5 , we define a step si
2 of Ti
2 after which Ti
5 observes an update to a
data item that Ti
2 writes and Ti
5 reads.
Since each step si
1 accesses up to n base objects, the set of base objects accessed by all steps
s1
1,...,sn+1 1 is n(n + 1). Let A1
2,...,An(n+1)+1
2 be the sets of base objects on which transactions
T 1
2 ,...,T n(n+1)+1
2 , respectively, apply non-trivial primitives. Based on the fact thatT 1
2 ,...,T n(n+1)+1
2
do not conflict with each other, we argue that for each 1 ≤ i, j ≤ n(n + 1) + 1, i  j, Ai
2 and Aj
2 are
disjoint. Therefore, by the pigeonhole principle, there is an index k, 1 ≤ k ≤ n(n + 1) + 1, such that
transaction Tk
2 does not apply non-trivial primitives on any base object accessed by each of the
stepss1
1,...,sn+1 1 . TransactionTk
2 is the transaction that will play the role of T2 in the proof for the
general case.
Likewise, let A1
1,...,An+1 1 be the sets of base objects on which transactionsT 1
1 ,...,T n+1 1 , respectively, apply non-trivial primitives. Based on the fact that transactionsT 1
1 ,...,T n+1 1 do not conflict
with each other, we argue that for each 1 ≤ i, j ≤ n + 1, i  j, Ai
1 and Aj
1 are disjoint. Since step sk
2
accesses up to n base objects, by the pigeonhole principle, there is an l, 1 ≤ l ≤ n + 1, such that
transactionTl
1 does not apply non-trivial primitives on any base object accessed by sk
2 . Transaction
Tl
1 is the transaction that will play the role of T1 in the proof for the general case.
After fixing k and l (as explained above), we consider two sets of n + 1 transactionsT 1
4 ,...,T n+1 4
and T 1
6 ,...,T n+1 6 such that, for each i, 1 ≤ i ≤ n + 1, Ti
4 conflicts only with Tk
2 and Tl
3 , and Ti
6
conflicts only with Tl
1 and Tk
5 . By the pigeonhole principle, we can show that there is a transaction
T m1
4 , which does not apply non-trivial primitives on any base object accessed at step sk
2 , and there
is a transaction T m2
6 , which does not apply non-trivial primitives on any base object accessed at
step sl
1. Transactions T m1
4 and T m2
6 will play the role of T4 and T6, respectively, in the proof for the
general case.
Thus, the general proof uses transactions Tl
1 ,Tk
2 ,Tl
3 ,T m1
4 ,Tk
5 ,T m2
6 , and T7 to play the role of
transactions T1,T2,T3,T4,T5,T6, and T7, respectively, from the proof of Theorem 4.1. Table 5 shows
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.    
2:30 V. Bushkov et al.
Table 5. Correspondence between Data Items
from Theorem 4.1 and Theorem 4.19
Data item from the
proof of Theorem 4.1
Corresponding data items from
the proof of Theorem 4.19
a a1,1,..., an+1,n(n+1)+1
b1 b1
1,...,bn+1 1
b2 b1
2,...,bn(n+1)+1
2
b3 b1
3,...,bn+1 3
b4 b1,1
4 ,...,bn+1,n+1
4
b5 b1
5,...,bn(n+1)+1
5
b6 b1,1
6 ,...,bn+1,n(n+1)+1
6
b7 b1,1
7 ,...,bn(n+1)+1,n+1
7
c1 c1
1,...,cn+1 1
c2 c1
2,...,c
n(n+1)+1
2
c3 c1,1
3 ,...,c
n+1,n+1
3
c5 c1,1
5 ,...,c
n(n+1)+1,n+1
5
d1 d1,1
1 ,...,dn+1,n+1
1
d2 d1,1
2 ,...,dn(n+1)+1,n+1
2
e1,3 e1
1,3,..., en+1 1,3
e2,5 e1
2,5,..., e
n(n+1)+1
2,5
e2,7 e1
2,7,..., e
n(n+1)+1
2,7
e3,4 e1,1
3,4,..., en+1,n+1
3,4
e5,6 e1,1
5,6,..., e
n+1,n(n+1)+1
5,6
which data items from the general proof play a similar role to which data items from the proof of
Theorem 4.1. Using similar techniques as in the proof for the simple case, we construct two executions α and α in which transactionsTl
1 ,Tk
2 , and T7 are executed, such that α and α are indistinguishable to the process executing T7. We also prove that T7 reads different values for some data
item in α and α
. This is a contradiction.
Moreover, we extend the impossibility result to hold even if we consider TM algorithms that
ensure c-disjoint-access-parallelism, a property weaker than strict disjoint-access-parallelism assumed in Theorem 4.1. Recall that c-disjoint-access-parallelism allows the execution intervals
of two non-conflicting transactions to contend on a base object as long as they do not concurrently contend. Using standard indistinguishability arguments [13, 43], we prove two lemmas
that show that given legal executions (with certain properties) in which two transactions contend, we can construct legal executions in which the transactions concurrently contend. These
lemmas generalize a lemma presented in Reference [11]. Specifically, we show that legal solo executions of non-conflicting transactions produced by a c-disjoint-access-parallel TM algorithm,
do not contend. When proving the impossibility result, we let transactions Tl
3 ,T m1
4 ,Tk
5 ,T m2
6 ,T7 be
executed solo. Thus, we use the two lemmas below to show that arguments similar to those for
strict disjoint-access-parallelism (from the proof of Theorem 4.1) can be applied when assuming
c-disjoint-access-parallelism. We assume that the set of base objects that a primitive accesses and
the way those objects are accessed does not depend on the state of any base object the primitive
accesses.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:31
Lemma 4.17. Consider a c-disjoint-access-parallel TM algorithm and let C be a reachable configuration. For each i, 1 ≤ i ≤ 3, let pi be any process and letTi be either the transaction that pi is executing
at C or any other transaction. Consider the following executions (which can be the empty executions)
and configurations:
• Let β1 be a legal solo execution of T1 (not necessarily to completion) by p1 from C and let C1
be the resulting configuration.
• Let β2 be a legal solo execution of T2 (not necessarily to completion) by p2 from C1 such that
β1 does not apply non-trivial primitives on the base objects accessed in β2, so that β2 is legal
from C.
• Let C2 be the configuration resulting from applying β1 · β2 from C and C
2 be the configuration
resulting from applying β2 from C. Let β3 be a legal solo execution of T3 (not necessarily to
completion) by p3 either from C2 or from C
2.
If D(T1, β1) ∩ D(T3, β3) = ∅, then β1 and β3 do not contend.
Proof. To derive a contradiction, assume that β1 and β3 contend. Let s3 be the first step in β3
such that s3 contends with some step s1 in β1 (if there are several such steps in β1, let s1 be the
first of them). Let β
1 and β
3 be the prefixes of β1 and β3 up until (but not including) steps s1 and
s3, respectively. (We remark that these prefixes may be empty.)
Because β1 · β2 is legal from C and β1 does not apply non-trivial primitives on the base objects
accessed in β2, it follows that β
1 · β2 is legal from C.
Because (1) β
1 · β2 is legal from C, and (2) β
3 does not contend with β
1, and (3) either β2 · β3 or
β1 · β2 · β3 is legal from C, it follows that β
1 · β2 · β
3 is legal from C. Let C be the configuration
resulting from applying execution β
1 · β2 · β
3 starting fromC. At configurationC
, processes p1 and
p3 have pending stepss
1 and s
3, respectively, which access the same sets of base objects and apply
the same primitives on them as steps s1 and s3, respectively. Because s1 and s3 contend, it follows
that s
1 and s
3 also contend. Hence, there is a configuration C at which contending steps s
1 and s
3
are pending. Since T1 and T3 do not conflict, this contradicts c-disjoint-access-parallelism.
Lemma 4.18. Consider a c-disjoint-access-parallel TM algorithm and let C be a reachable configuration. Fix any integer m > 0. Consider m distinct processes p1,...,pm and for each i, 1 ≤ i ≤ m,
let Ti be either the transaction that pi is executing at C or any other transaction. Let β1 · ... · βm be
an execution legal from C, where for each i, 1 ≤ i ≤ m, βi is a solo execution of Ti (not necessarily to
completion) by pi . If D(Ti, βi ) ∩ D(Tj , βj) = ∅ for each i  j, 1 ≤ i, j ≤ m, then no pair of executions
among β1,..., βm contend.
Proof. We prove that the claim is true by induction on the number of transactions m.
Base case (m = 1). The claim holds trivially.
Inductive step. Consider anym > 1 and assume that the claim holds for any set ofm − 1 transactions. We prove that the claim holds for any set of m transactions.
To derive a contradiction, assume that there exist a reachable configuration C, and a legal execution β1 · ... · βm from C, where for each i, 1 ≤ i ≤ m, βi is the solo execution of Ti by pi until
Ti commits or a prefix of that execution, such that there is a pair of contending executions among
β1,..., βm, although D(Ti, βi ) ∩ D(Tj , βj) = ∅ for each i  j, 1 ≤ i, j ≤ m, i.e., no pair of transactions conflict in β1 · ... · βm.
We argue that this pair of executions is β1 and βm. Denote byC the configuration resulting from
applying β1 starting from C. By assumption, execution β2 · ... · βm is legal from C and for each
i  j, 2 ≤ i, j ≤ m, D(Ti, βi ) ∩ D(Tj , βj) = ∅. By the induction hypothesis, the claim is true for any
set of m − 1 transactions. Thus, no pair of executions among β2,..., βm contend. By assumption,
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.    
2:32 V. Bushkov et al.
execution β1 · ... · βm−1 is legal from C and for each i  j, 1 ≤ i, j ≤ m − 1, D(Ti, βi ) ∩ D(Tj, βj) =
∅. By the induction hypothesis, the claim is true for any set of m − 1 transactions. Thus, no pair of
executions among β1,..., βm−1 contend. We conclude that the only pair of executions that could
contend is β1 and βm.
Since β1 · ... · βm is legal starting from C and βm does not contend with any of the executions
β2,..., βm−1, it follows that β1 · βm is legal from C. Lemma 4.17 implies that β1 and βm do not
contend. This is a contradiction.
Theorem 4.19 (The PCL Theorem). There is no TM algorithm from primitives that can atomically
access up to n base objects, which is c-disjoint-access-parallel and satisfies weak adaptive consistency
and obstruction-freedom in an asynchronous shared-memory system with Ω(n2) processes.
The proof is by contradiction. Assume that there exists an obstruction-free TM algorithm A
from primitives that can atomically access up to n base objects, which is c-disjoint-access-parallel
and satisfies weak adaptive consistency.
Consider an execution β of A and any process pj
i . Since A satisfies weak adaptive consistency,
there exist a consistency partition P (β), a set com(β) of committed and commit-pending transactions from β, and a sequence σi,j
β of serialization points for process pj
i , which satisfy the conditions
of Definition 3.4. For simplicity, we use the following notation: ∗T,t1 <j
i ∗T 
,t2 , whereT,T  ∈ com(β)
and t1,t2 ∈ {д,w}, to identify that ∗T,t1 precedes ∗T 
,t2 in σi,j
β , in the same way we use the notation
∗T,t1 <i ∗T 
,t2 to identify that ∗T,t1 precedes ∗T 
,t2 in the sequential view σi
β of process pi . For simplicity, we have omitted β from this notation, since later on, the execution we refer to is always
clear from the context. Moreover, throughout the proof, we use the term execution interval instead
of active execution interval, whenever it is clear from the context. For the proof, we assume that the
initial value of every data item is 0. We also assume that each transaction is executed by a distinct
process.
We are now ready to introduce the first two sets of transactions:
• for each i ∈ {1,...,n + 1}, transaction Ti
1 , executed by process pi
1, reads data items bi
3
and b1,i
7 ,...,bn(n+1)+1,i
7 , and writes the value 1 to data items ai,1,..., ai,n(n+1)+1, bi
1, ci
1,
di,1
1 ,...,di,n+1
1 , ei
1,3 (see Table 6),
• for each i ∈ {1,...,n + 1}, transaction Ti
3 , executed by process pi
3, reads data items bi
1 and
b1,i
4 ,...,bn+1,i
4 , and writes the value 1 to data items bi
3, c
i,1
3 ,...,c
i,n+1
3 , ei
1,3, e1,i
3,4,..., en+1,i
3,4
(see Table 6).
As in the proof of Theorem 4.1, we remark that each transaction has a simple code that contains
a constant number of invocations to t-operations. In accordance to Tables 3 and 4, Table 6 presents
the data items accessed by each of the transactions that will be used in this proof, and Table 7
indicates whether any pair of these transactions conflict (in any execution in which they invoke
commitT ). By inspecting the t-operations that each transaction performs, it becomes clear that if
β contains any two transactions from Table 6 for which it holds that the corresponding cell of
Table 7 does not contain the letter “c,” then these transactions do not conflict in β.
We remark that obstruction freedom implies that when each of the simple transactions described
above is executed solo, starting from any reachable configuration, it eventually commits. We repeatedly use this argument later on to construct the required executions.
Definition of executions αi
1 and steps si
1
. For each i, 1 ≤ i ≤ n + 1, we define execution αi
1
and step si
1 by induction on i. Let α0
1 be the empty execution, s0
1 be the empty step, and C0
1 = C0 be
the initial configuration. Fix any 1 ≤ i ≤ n + 1 and assume that for each j, 0 ≤ j < i, αj
1 and s
j
1 have
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.  
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:33
Table 6. Data Items Read and Written by the Transactions Where  and k
(1 ≤  ≤ n + 1, 1 ≤ k ≤ n(n + 1) + 1) are Indices Such that T
1 and Tk
2
Play the Role of T1 and T2, Respectively, in the Proof of Theorem 4.19
Data items read Data items written
Ti
1
1 ≤ i ≤ n + 1
bi
3
b1,i
7 ,...,bn(n+1)+1,i
7
ai,1,..., ai,n(n+1)+1,bi
1,
ci
1 di,1
1 ,...,di,n+1
1 , ei
1,3
Ti
2
1 ≤ i ≤ n(n + 1) + 1
bi
5
bi,1
7 ,...,bi,n+1
7
a1,i
,..., an+1,i
,bi
2,
ci
2 di,1
2 ,...,di,n+1
2 , ei
2,5, ei
2,7
Ti
3
1 ≤ i ≤ n + 1
bi
1
b1,i
4 ,...,bn+1,i
4
bi
3,c
i,1
3 ,...,c
i,n+1
3
ei
1,3, e1,i
3,4,..., en+1,i
3,4
Ti
4
1 ≤ i ≤ n + 1
c ,i
3 ,dk,i
2 bi,
4 , ei,
3,4
Ti
5
1 ≤ i ≤ n(n + 1) + 1
bi
2
b1,i
6 ,...,bn+1,i
6
bi
5,c
i,1
5 ,...,c
i,n+1
5
ei
2,5, e1,i
5,6,..., en+1,i
5,6
Ti
6
1 ≤ i ≤ n + 1
c
k,i
5 ,d,i
1 bi,k
6 , ei,k
5,6
T7 a,k ,cl
1,ck
2 bk,
7 , ek
2,7
Table 7. Conflicting Transactions, Where
i  j, 1 ≤ i ≤ n + 1, 1 ≤ j ≤ n(n + 1) + 1
Ti
1 Ti
2 Ti
3 Ti
4 Ti
5 Ti
6 T7
Ti
1 c c c c
T j
1 c c c
Ti
2 c c c c
T j
2 c c c
Ti
3 c c
T j
3 c
Ti
4 c c
T j
4 c c
Ti
5 c c
T j
5 c
Ti
6 c c
T j
6 c c
T7 c c
If a pair of transactions conflict, then the cell corresponding to the pair contains letter “c.”
been defined. Denote by Ci−1 1 the configuration that results when α0
1 · ... · αi−1 1 is applied from
C0
1. Let transaction Ti
1 be executed solo from configuration Ci−1 1 . Since pi
1 runs solo, obstructionfreedom implies that Ti
1 eventually commits. Let αi
1 be the resulting execution. Then, in αi
1 , Ti
1
reads the value 0 for data itembi
3, because A satisfies weak adaptive consistency and no transaction
writes to bi
3 in the resulting execution. Let C
i
1 be the configuration resulting from the execution
of αi
1 from Ci−1 1 .
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.          
2:34 V. Bushkov et al.
Fig. 11. Executions α1
1 ,..., αi
1, αi
3, α

i
3 , and step si
1.
If transactionTi
3 is executed solo from configurationCi−1 1 , then obstruction-freedom implies that
Ti
3 commits. In the resulting execution, Ti
3 reads the value 0 for bi
1, since A satisfies weak adaptive
consistency and no transaction writes to bi
1 in α0
1 · ... · αi−1 1 .
Consider now an extension δi
1 of α0
1 · ... · αi−1 1 · αi
1 in which transaction Ti
3 is executed solo
from C
i
1 until Ti
3 commits, i.e., δi
1 = α0
1 · ... · αi−1 1 · αi
1 · ζ i
3 , where ζ i
3 is the solo execution of Ti
3
until it commits. We prove that Ti
3 reads the value 1 for bi
1 in δi
1. Since A satisfies weak adaptive consistency, there exist a consistency partition P (δi
1 ) and a set com(δi
1) of committed and
commit-pending transactions from δi
1, which satisfy the conditions of Definition 3.4. We consider
the following cases:
• Assume first that P (δi
1 ) is such that Ti
1 and Ti
3 belong to different consistency groups G and
G
, respectively, of P (δi
1 ). Because no two transactions have overlapping execution intervals
in δi
1 and the execution interval of Ti
1 precedes the execution interval of Ti
3 , it follows that
the execution interval of G precedes the execution interval of G in δi
1. By Lemma 3.5, it
follows that ∗T i
1 ,w <i
3 ∗T i
3 ,д. Hence, Ti
3 reads 1 for bi
1.
• Assume next that P (δi
1 ) is such that Ti
1 and Ti
3 belong to the same consistency group G and
G ∈ SI (P (δi
1 )). Since G is a snapshot isolation group, then ∗T i
1 ,w must be placed within the
execution interval of Ti
1 and ∗T i
3 ,д must be placed within the execution interval of Ti
3 . Since
Ti
1 <δ i
1 Ti
3 , then ∗T i
1 ,w <i
3 ∗T i
3 ,д. Hence, Ti
3 reads 1 for bi
1.
• Assume now that P (δi
1 ) is such that Ti
1 and Ti
3 belong to the same consistency group G
and G ∈ PC(P (δi
1 )). Because Ti
1 reads the value 0 for bi
3 in δi
1, it follows that ∗T i
1 ,д <i
1 ∗T i
3 ,w .
SinceG is a processor consistency group, no serialization point is inserted between ∗T i
1 ,д and
∗T i
1 ,w . Thus, ∗T i
1 ,w <i
1 ∗T i
3 ,w . BecauseTi
1 andTi
3 write to the same data itemei
1,3, it follows that
∗T i
1 ,w <i
3 ∗T i
3 ,w . Since no serialization point is inserted between ∗T i
3 ,д and ∗T i
3 ,w , it follows
that ∗T i
1 ,w <i
3 ∗T i
3 ,д. Hence, Ti
3 reads 1 for bi
1.
Since in the solo execution of Ti
3 from Ci−1 1 , Ti
3 reads the value 0 for bi
1, whereas in the solo
execution of Ti
3 from C
i
1 , Ti
3 reads the value 1 for bi
1, it follows that there exists some step si
1 in the
solo execution of Ti
1 from Ci−1 1 such that: (1) if α

i
3 is the solo execution of Ti
3 (until Ti
3 commits)
from the configuration Ci
1 just before si
1, then Ti
3 reads the value 0 for bi
1 in α

i
3 , and (2) if αi
3 is the
solo execution ofTi
3 (untilTi
3 commits) from the configuration just aftersi
1, thenTi
3 reads the value
1 for bi
1 in αi
3. (If there are more than one steps with this property, then let si
1 be the first of them.)
Denote by αi
1 the solo execution of Ti
1 from Ci−1 1 until Ci
1 is reached (see Figure 11). Note that Ti
3
reads the value 0 for b1,i
4 ,...,bn+1,i
4 in αi
3 (and in α

i
3 ), since A satisfies weak adaptive consistency
and no transaction writes to these data items in α0
1 · ... · αi
1 · si
1.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:35
Property 3. For each i, 1 ≤ i ≤ n + 1,
(1) Ti
3 reads the value 0 for bi
1 in α

i
3 ,
(2) Ti
3 reads the value 1 for bi
1 in αi
3, and
(3) Ti
3 reads the value 0 for b1,i
4 ,...,bn+1,i
4 in both α

i
3 and αi
3.
We continue to prove the following lemma.
Lemma 4.20. For each i, 1 ≤ i ≤ n + 1, transaction Ti
1 invokes commitT i
1 and reads the value 0 for
bi
3,b1,i
7 ,...,bn(n+1)+1,i
7 in αi
1.
Proof. We first prove thatTi
1 invokescommitT i
1 in αi
1 · si
1. Assume, to derive a contradiction, that
Ti
1 does not invoke commitT i
1 in αi
1 · si
1. We argue that in this case the execution α0
1 · ... · αi
1 · si
1 · αi
3
does not satisfy weak adaptive consistency. This is so because, by Property 3, Ti
3 reads the value
1 for bi
1 in α0
1 · ... · αi
1 · si
1 · αi
3, but Ti
1 is not yet commit-pending and therefore we cannot assign a
write serialization point to Ti
1 in this execution. Since α0
1 · ... · αi
1 · si
1 · αi
3 is a legal execution of A
from C0, this contradicts the fact that A ensures weak adaptive consistency.
We now argue thatTi
1 does not invokescommitT i
1 atsi
1. IfTi
1 invokescommitT i
1 atsi
1, then si
1 does
not apply any primitive to any base object, and consequently α

i
3 and αi
3 are indistinguishable to
process pi
3. Thus, Ti
3 reads the same value for bi
1 in α

i
3 and αi
3. This contradicts Property 3.
Because no transaction writes to bi
3,b1,i
7 ,...,bn(n+1)+1,i
7 in α0
1 · ... · αi
1, and α0
1 · ... · αi
1 satisfies
weak adaptive consistency, it follows that Ti
1 reads the value 0 for bi
3,b1,i
7 ,...,bn(n+1)+1,i
7 in αi
1.
We continue to introduce two additional sets of transactions.
• for each i ∈ {1,...,n(n + 1) + 1}, transactionTi
2 , executed by process pi
2, reads data items bi
5
andbi,1
7 ,...,bi,n+1
7 , and writes the value 2 to data items a1,i
,..., an+1,i
, bi
2,ci
2, di,1
2 ,...,di,n+1
2 ,
ei
2,5, ei
2,7 (see Table 6),
• for each i ∈ {1,...,n(n + 1) + 1}, transaction Ti
5 , executed by process pi
5, reads data items
bi
2 and b1,i
6 ,...,bn+1,i
6 , and writes the value 1 to data items bi
5, c
i,1
5 ,...,c
i,n+1
5 , ei
2,5,
e1,i
5,6,..., en+1,i
5,6 (see Table 6).
Definition of executions αi
2 and steps si
2
. Recall that Cn+1 1 is the configuration resulting from applying the execution α1
1 · ... · αn+1 1 starting from the initial configuration. For each
i ∈ {1,...,n(n + 1) + 1}, let transactionTi
2 be executed solo from configuration Cn+1 1 untilTi
2 commits (obstruction-freedom implies that this will occur). Let α2
i be the resulting execution. In α2
i ,
Ti
2 reads the value 0 for data item bi
5, because A satisfies weak adaptive consistency and no transaction writes to bi
5 in α1
1 · ... · αn+1 1 · α2
i . Let C
i
2 be the configuration resulting from the execution
of the last step of α2
i from Cn+1 1 .
If transaction Ti
5 is executed solo from configuration Cn+1 1 until Ti
5 commits, then in the resulting execution, Ti
5 reads the value 0 for bi
2, because A satisfies weak adaptive consistency and no
transaction writes to bi
2 in this execution.
Consider now an extension δi
2 of α0
1 · ... · αn+1 1 · αi
2 in which transaction Ti
5 is executed solo
from C
i
2 until Ti
5 commits. We prove that Ti
5 reads the value 2 for bi
2 in δi
2. Since A satisfies weak
adaptive consistency, there exist a consistency partition P (δi
2 ) and a setcom(δi
2) of committed and
commit-pending transactions from δi
2, which satisfy the conditions of Definition 3.4. We consider
the following cases:
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018. 
2:36 V. Bushkov et al.
Fig. 12. Executions αi
2, αi,1
5 , α

i,1
5 , and step si
2.
• Assume first that P (δi
2 ) is such that Ti
2 and Ti
5 belong to different consistency groups G and
G
, respectively, of P (δi
2 ). Because no two transactions have overlapping execution intervals
in δi
2 and the execution interval of Ti
2 precedes the execution interval of Ti
5 , it follows that
the execution interval of G precedes the execution interval of G in δi
2. By Lemma 3.5, it
follows that ∗T i
2 ,w <i
5 ∗T i
5 ,д. Hence, Ti
5 reads 2 for bi
2.
• Assume next that P (δi
2 ) is such that Ti
2 and Ti
5 belong to the same consistency group G and
G ∈ SI (P (δi
2 )). Since G is a snapshot isolation group, then ∗T i
2 ,w must be placed within the
execution interval of Ti
2 and ∗T i
5 ,д must be placed within the execution interval of Ti
5 . Since
Ti
2 <δ i
2 Ti
5 , then ∗T i
2 ,w <i
5 ∗T i
5 ,д. Hence, Ti
5 reads 2 for bi
2.
• Assume now that P (δi
2 ) is such that Ti
2 and Ti
5 belong to the same consistency group G
and G ∈ PC(P (δi
2 )). Because Ti
2 reads the value 0 for bi
5 in δi
2, it follows that ∗T i
2 ,д <i
2 ∗T i
5 ,w .
SinceG is a processor consistency group, no serialization point is inserted between ∗T i
2 ,д and
∗T i
2 ,w . Thus, ∗T i
2 ,w <i
2 ∗T i
5 ,w . BecauseTi
2 andTi
5 write to the same data itemei
2,5, it follows that
∗T i
2 ,w <i
5 ∗T i
5 ,w . Since no serialization point is inserted between ∗T i
5 ,д and ∗T i
5 ,w , it follows
that ∗T i
2 ,w <i
5 ∗T i
5 ,д. Hence, Ti
5 reads 2 for bi
2.
Since in the solo execution of Ti
5 from Cn+1 1 , Ti
5 reads the value 0 for bi
2, whereas in the solo
execution of Ti
5 from C
i
2 , Ti
5 reads the value 2 for bi
2, it follows that there exists some step si
2 in the
solo execution of Ti
2 from Cn+1 1 such that: (1) if α

i
5 is the solo execution of Ti
5 (until Ti
5 commits)
from the configuration Ci
2 just before si
2, then Ti
5 reads the value 0 for bi
2 in α

i
5 , and (2) if αi
5 is the
solo execution ofTi
5 (untilTi
5 commits) from the configuration just aftersi
2, thenTi
5 reads the value
2 for bi
2 in αi
5. (If there are more than one steps with this property, then let si
2 be the first of them.)
Denote by αi
2 the solo execution of Ti
2 from Cn+1 1 until Ci
2 is reached (see Figure 12). Note that Ti
5
reads the value 0 for b1,i
6 ,...,bn+1,i
6 in αi
5 (and in α

i
5 ), since A satisfies weak adaptive consistency
and no transaction writes to these data items in α1
1 · ... · αn+1 1 · αi
2 · si
2.
Property 4. For each i, 1 ≤ i ≤ n(n + 1) + 1,
(1) Ti
5 reads the value 0 for bi
2 in α

i
5 ,
(2) Ti
5 reads the value 2 for bi
2 in αi
5, and
(3) Ti
5 reads the value 0 for b1,i
6 ,...,bn+1,i
6 in both α

i
5 and αi
5.
We continue to prove the following lemma.
Lemma 4.21. For each i, 1 ≤ i ≤ n(n + 1) + 1, transactionTi
2 invokescommitT i
2 and reads the value
0 for bi
5,bi,1
7 ,...,bi,n+1
7 in αi
2.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:37
Proof. We first prove thatTi
2 invokescommitT i
2 in αi
2 · si
2. Assume, to derive a contradiction, that
Ti
2 does not invoke commitT i
2 in αi
2 · si
2. We argue that in this case the execution α1
1 · ... · αn+1 1 · αi
2 ·
si
2 · αi
5 does not satisfy weak adaptive consistency. This is so because, by Property 4, Ti
5 reads the
value 2 for bi
2 in α1
1 · ... · αn+1 1 · αi
2 · si
2 · αi
5, but Ti
2 is not yet commit-pending and therefore we
cannot assign a write serialization point to Ti
2 in this execution. Since α1
1 · ... · αn+1 1 · αi
2 · si
2 · αi
5 is
a legal execution of A fromC0, this contradicts the fact that A ensures weak adaptive consistency.
We now argue that Ti
2 does not invoke commitT i
2 at si
2. If Ti
2 invokescommitT i
2 at si
2, then si
2 does
not apply any primitive to any base object, and consequently α

i
5 and αi
5 are indistinguishable to
process pi
5. Thus, Ti
5 reads the same value for bi
2 in α

i
5 and αi
5. This contradicts Property 4.
Because no transaction writes to bi
5,bi,1
7 ,...,bi,n+1
7 in α1
1 · ... · α3
1 · αi
2, and α1
1 · ... · α3
1 · αi
2 satisfies weak adaptive consistency, it follows that Ti
2 reads the value 0 for bi
5,bi,1
7 ,...,bi,n+1
7 in αi
2.
• Definition of index k. Let Oi
1 be the set of base objects accessed by step si
1 and O1 = n+1 i=1 Oi
1. Since each step can access at most n base objects, O1 contains at most n(n + 1)
base objects.
Since no pair of transactions among T 1
2 ,...,T n(n+1)+1
2 conflict (see Table 7) and for each i,
1 ≤ i ≤ n(n + 1) + 1, execution αi
2 · si
2 is legal from Cn+1 1 , Lemma 4.17 implies the following:
Lemma 4.22. No pair of executions among α1
2 · s1
2,..., αn(n+1)+1
2 · s
n(n+1)+1
2 contend.
Let Ai
2 be the set of base objects on which Ti
2 applies non-trivial primitives in αi
2 · si
2. Because no pair of executions among α1
2 · s1
2,..., αn(n+1)+1
2 · s
n(n+1)+1
2 contend, it follows that
for each 1 ≤ i, j ≤ n(n + 1) + 1,i  j,Ai
2 ∩ Aj
2 = ∅. Since O1 contains at most n(n + 1) base
objects and the n(n + 1) + 1 sets A1
2,...,An(n+1)+1
2 are disjoint to each other, the pigeonhole
principle implies that there exists an index k, 1 ≤ k ≤ n(n + 1) + 1, such that Ak
2 ∩ O1 = ∅.
Thus, we choose k so that process pk
2 does not apply non-trivial primitives in αk
2 · sk
2 on any
base object accessed in any of the steps s1
1,...,sn+1 1 . We call this Property 5.
Property 5. Process pk
2 does not apply in αk
2 · sk
2 a non-trivial primitive on any base object
accessed in any of the steps s1
1,...,sn+1 1 .
• Definition of index : We first prove that no pair of executions among α1
1 · s1
1,..., αn+1 1 ·
sn+1 1 contend.
Lemma 4.23. No pair of executions among α1
1 · s1
1,..., αn+1 1 · sn+1 1 contend.
Proof. Since for each i, 1 ≤ i ≤ n + 1, α1
1 · ... · αi−1 1 · αi
1 · si
1 is legal from the initial configuration C0 and no pair of transactions among T 1
1 ,...,Ti
1 conflict, Lemma 4.18 implies that
execution αi
1 · si
1 does not contend with any of the executions α1
1 ,..., αi−1 1 . Therefore, for
each i, 1 ≤ i ≤ n + 1, αi
1 · si
1 is legal from C0. Since for each i, 1 ≤ i ≤ n + 1, αi
1 · si
1 is legal
from C0 and no pair of transactions among T 1
1 ,...,T n+1 1 conflict, Lemma 4.17 implies that
no pair of executions among α1
1 · s1
1,..., αn+1 1 · sn+1 1 contend.
Since α1
1 · ... · αn+1 1 is legal from C0, Lemma 4.23 implies that execution α1
1 · ... · αn+1 1 ·
s1
1 · ... · sn+1 1 is legal fromC0. By Property 5, αk
2 does not apply non-trivial primitives on the
base objects accessed in any of the steps s1
1,...,sn+1 1 . Since α1
1 · ... · αn+1 1 · αk
2 is legal from
C0, it follows that α1
1 · ... · αn+1 1 · αk
2 · s1
1 · ... · sn+1 1 is legal from C0.
Lemma 4.24. Execution α1
1 · ... · αn+1 1 · αk
2 · s1
1 · ... · sn+1 1 is legal from C0.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.     
2:38 V. Bushkov et al.
Let Ai
1 be the set of base objects on which Ti
1 applies non-trivial primitives in αi
1 · si
1. By
Lemma 4.23, no pair of executions among α1
1 · s1
1,..., αn+1 1 · sn+1 1 contend. It follows that for
each 1 ≤ i, j ≤ n + 1,i  j,Ai
1 ∩ Aj
1 = ∅. Let Ok
2 be the set of base objects accessed by step
sk
2 . SinceOk
2 contains at most n objects and the n + 1 sets A1
1,...,An+1 1 are disjoint with each
other, the pigeonhole principle implies that there exists an index , 1 ≤  ≤ n + 1, such that
A
1 ∩ Ok
2 = ∅.
Thus, we choose  so that process p
1 does not apply non-trivial primitives in α
1 · s
1 on
any base object accessed in step sk
2 . We call this Property 6.
Property 6. Process p
1 does not apply in α
1 · s
1 non-trivial primitives on the base objects
accessed in sk
2 .
• Definition of index m1: We prove that α
3 does not contend with α+1 1 ,..., αn+1 1 . By
Lemma 4.23, no pair of executions among α1
1 · s1
1,..., αn+1 1 · sn+1 1 contend. It follows that
for each i,  < i ≤ n + 1, the execution α1
1 · ... · α
1 · s
1 · αi
1 is legal from C0. By definition of
α
3 , α1
1 · ... · α
1 · s
1 · α
3 is legal from C0. Since each of the executions α
3 , α+1 1 ,..., αn+1 1
is legal from the configuration resulting when α1
1 · ... · α
1 · s
1 is applied from C0, and
no pair of transactions among T
3 ,T +1 1 ,...,T n+1 1 conflict (see Table 7), Lemma 4.17 implies that α
3 does not contend with any of the executions α+1 1 ,..., αn+1 1 . Because (1) α
3
does not contend with α+1 1 ,..., αn+1 1 , (2) s
1 does not contend with α+1 1 ,..., αn+1 1 (by
Lemma 4.23), and (3) α1
1 · ... · α
1 · s
1 · α
3 is legal from C0 (by definition of α
3 ), it follows
that α1
1 · ... · αn+1 1 · s
1 · α
3 is legal from C0.
Lemma 4.25. Execution α1
1 · ... · αn+1 1 · s
1 · α
3 is legal from C0.
Next, we prove that αk
2 · sk
2 and α
3 do not contend.
Lemma 4.26. Executions αk
2 · sk
2 and α
3 do not contend.
Proof. Since execution α1
1 · ... · αn+1 1 · αk
2 · s1
1 · ... · sn+1 1 is legal from C0 (by Lemma 4.24),
and no pair of executions among α1
1 · s1
1,..., αn+1 1 · sn+1 1 contend (by Lemma 4.23), it follows
that the execution α1
1 · ... · αn+1 1 · αk
2 · s
1 is legal from C0. By Properties 5 and 6, s
1 and sk
2
do not contend. It follows that α1
1 · ... · αn+1 1 · αk
2 · sk
2 · s
1 is legal from C0. Recall that Cn+1 1
is the configuration that results from applying α1
1 · ... · αn+1 1 starting from C0. Notice that
(1) αk
2 · sk
2 · s
1 is legal from Cn+1 1 , and (2) αk
2 · sk
2 does not apply non-trivial primitives on the
base objects accessed in s
1 (by Property 5), (3) s
1 · α
3 is legal from Cn+1 1 (by Lemma 4.25),
and (4) D(Tk
2 , αk
2 · sk
2 ) ∩ D(T
3 , α
3 ) = ∅. Thus, Lemma 4.17 (where β1 = αk
2 · sk
2 , β2 = s
1 , and
β3 = α
3 ) implies that αk
2 · sk
2 and α
3 do not contend.
Consider the following set of transactions:
— for each i ∈ {1,...,n + 1}, transaction Ti
4 , executed by process pi
4, reads data items dk,i
2
and c ,i
3 , and writes the value 1 to data items bi,
4 and ei,
3,4 (see Table 6).
Consider the execution α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · α1
4 · ... · αn+1 4 , where α1
4 ,..., αn+1 4 are
solo executions of transactions T 1
4 ,...,T n+1 4 , respectively, until each of them commits.
Lemma 4.27. For each i, 1 ≤ i ≤ n + 1, the execution α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · αi
4 · α

k
5 is
legal from C0.
Proof. We first prove that the execution α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · α1
4 · ... · αn+1 4 is legal
fromC0. By Lemma 4.26, αk
2 and α
3 do not contend. By Property 5, αk
2 does not apply a nontrivial primitive on any base object accessed in s
1 . By Lemma 4.25, α1
1 · ... · αn+1 1 · s
1 · α
3 is
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.                                                                    
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:39
legal from C0 and by definition of αk
2 , α1
1 · ... · αn+1 1 · αk
2 is legal from C0. It follows that
α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 is legal from C0. Thus, α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · α1
4 · ... · αn+1 4
is legal from C0.
Because no pair of transactions among T 1
4 ,...,T n+1 4 conflict (see Table 7) and α1
1 · ... ·
αn+1 1 · αk
2 · s
1 · α
3 · α1
4 · ... · αn+1 4 is legal from C0 (by Lemma 4.27), Lemma 4.18 implies that
no pair of executions among α1
4 ,..., αn+1 4 contend. Thus, the execution α1
1 · ... · αn+1 1 · αk
2 ·
s
1 · α
3 · αi
4, where 1 ≤ i ≤ n + 1, is legal from C0.
Consider the execution α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · αi
4 · α

k
5 , where 1 ≤ i ≤ n + 1. By definition of α

k
5 , it follows that α1
1 · ... · αn+1 1 · αk
2 · α

k
5 is legal from C0. We next argue that α

k
5
does not contend with s
1 , α
3 , and αi
4.
We start by proving that α

k
5 and s
1 do not contend. Because α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · αi
4
is legal from C0, it follows that α1
1 · ... · αn+1 1 · αk
2 · s
1 is also legal from C0. Since α

k
5 and s
1
are legal from the configuration resulting when α1
1 · ... · αn+1 1 · αk
2 is applied from C0 and
transactions Tk
5 and T
1 do not conflict, Lemma 4.17 implies that α

k
5 and s
1 do not contend.
We continue to prove that α

k
5 and α
3 do not contend. Since α

k
5 and s
1 do not contend,
it follows that α1
1 · ... · αn+1 1 · αk
2 · s
1 · α

k
5 is legal from C0. Because α1
1 · ... · αn+1 1 · αk
2 · s
1 ·
α
3 · αi
4 is legal from C0, it follows that α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 is also legal from C0. Since
α

k
5 and α
3 are legal from the configuration resulting when α1
1 · ... · αn+1 1 · αk
2 · s
1 is applied
from C0 and transactions Tk
5 and T
3 do not conflict, Lemma 4.17 implies that α

k
5 and α
3 do
not contend.
In a similar way, we argue that α

k
5 and αi
4 do not contend. Since α

k
5 does not contend with
α
3 and s
1 , it follows that α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · α

k
5 is legal fromC0. Recall that α1
1 · ... ·
αn+1 1 · αk
2 · s
1 · α
3 · αi
4 is legal from C0. Since α

k
5 and αi
4 are legal from the configuration
resulting when α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 is applied from C0 and transactions Tk
5 and Ti
4 do
not conflict, Lemma 4.17 implies that α

k
5 and αi
4 do not contend.
Since α

k
5 does not contend with s
1 , α
3 , and αi
4, it follows that α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 ·
αi
4 · α

k
5 is legal from C0.
LetA1
4,...,An+1 4 be the sets of base objects on whichT 1
4 ,...,T n+1 4 apply non-trivial primitives in α1
4 ,..., αn+1 4 , respectively. Because no pair of transactions amongT 1
4 ,...,T n+1 4 conflict (see Table 7) and α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · αi
4 is legal from C0, for each 1 ≤ i ≤ n + 1,
(by Lemma 4.27), Lemma 4.17 implies that no pair of executions among α1
4 ,..., αn+1 4 contend. Thus, any two sets among A1
4,...,An+1 4 are disjoint. Since Ok
2 contains at most n base
objects, by the pigeonhole principle, there exists an index m1, 1 ≤ m1 ≤ n + 1, such that
Am1
4 ∩ Ok
2 = ∅.
Thus, we chose m1 so that process pm1
4 does not apply non-trivial primitives in αm1
4 on
any base object accessed in step sk
2 . We call this Property 7.
Property 7. Process pm1
4 does not apply non-trivial primitives in αm1
4 on any base object accessed in step sk
2 .
• Definition of index m2: Consider the following set of transactions:
— for each i ∈ {1,...,n + 1}, transaction Ti
6 , executed by process pi
6, reads data items c
k,i
5
and d,i
1 , and writes the value 1 to data items bi,k
6 and ei,k
5,6 (see Table 6).
Consider the execution α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · α1
6 · ... · αn+1 6 , where α1
6 ,..., αn+1 6 are
solo executions of transactions T 1
6 ,...,T n+1 6 , respectively, until each of them commits. By
definition of αk
5 , α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 is legal from C0. It follows that:
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.                                              
2:40 V. Bushkov et al.
Fig. 13. Execution β.
Lemma 4.28. Execution α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · α1
6 · ... · αn+1 6 is legal from C0.
Let A1
6,...,An+1 6 be the sets of base objects on which T 1
6 ,...,T n+1 6 apply non-trivial primitives in α1
6 ,..., αn+1 6 , respectively. Because no pair of transactions among T 1
6 ,...,T n+1 6
conflict (see Table 7) and α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · α1
6 · ... · αn+1 6 is legal from C0 (by
Lemma 4.28), Lemma 4.18 implies that any two sets among A1
6,...,An+1 6 are disjoint. Since
O
1 contains at most n base objects, by the pigeonhole principle, there exists an index m2,
1 ≤ m2 ≤ n + 1, such that Am2
6 ∩ O
1 = ∅.
Thus, we choose m2 so that process pm2
6 does not apply non-trivial primitives in αm2
6 on
any base object accessed in step s
1 . We call this Property 8.
Property 8. Process pm2
6 does not apply non-trivial primitives in αm2
6 on any base object accessed in step s
1 .
Let T7 be a transaction, executed by a distinct process p7, which reads data items a,k ,c
1 , and ck
2
and writes the value 1 to data items bk,
7 and ek
2,7. Consider the executions α = α1
1 · ... · αn+1 1 · αk
2 ·
s
1 · sk
2 · α7 and α = α1
1 · ... · αn+1 1 · αk
2 · sk
2 · s
1 · α
7, where α7 and α
7 are solo executions of transaction T7 until it commits. Since stepss
1 and sk
2 do not contend (by Properties 5 and 6), executions
α and α are legal from C0 and α7 is indistinguishable from α
7 to process p7.
Lemma 4.29. Executions α and α are legal from C0 and α7 is indistinguishable from α
7 to process
p7.
Let β = α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · αm1
4 · sk
2 · α7 (see Figure 13). We prove in Lemma 4.30 that β
is legal from C0. We then prove in Lemma 4.32 that in α7, T7 reads the value 2 for data items a,k
and ck
2 , and the value 1 for data item c
1 .
Lemma 4.30. Execution β is legal from C0.
Proof. By Lemma 4.27, execution α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · αm1
4 is legal from C0.
Lemma 4.26 implies that α
3 does not contend with sk
2 . By Property 7, αm1
4 does not apply nontrivial primitives on the base objects accessed in sk
2 . By Properties 5 and 6,sk
2 does not contend with
s
1 . Since executions α1
1 · ... · αn+1 1 · αk
2 · sk
2 and α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · αm1
4 are legal from C0,
it follows that α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · αm1
4 · sk
2 is legal from C0.
We continue to argue that α7 and α
3 do not contend. Since α
3 and sk
2 do not contend (by
Lemma 4.26) and α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 is legal fromC0 , it follows that α
3 is legal from the configuration resulting when α1
1 · ... · αn+1 1 · αk
2 · s
1 · sk
2 is applied from C0. Lemma 4.29 implies that
α7 is also legal from that configuration. Since transactions T7 and T
3 do not conflict, Lemma 4.17
(where β1 = α
3 , β2 = λ, and β3 = α7) implies that α7 and α
3 do not contend.
We next argue that α7 and αm1
4 do not contend. Because α1
1 · ... · αn+1 1 · αk
2 · s
1 · sk
2 · α7 is legal
from C0 (by Lemma 4.29) and α
3 does not contend with α7 and sk
2 , and α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3
is legal from C0, it follows that α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · sk
2 · α7 is legal from C0. Let C
3 be the
configuration that results from applying α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 starting from C0. Notice that
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.                                        
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:41
(1) αm1
4 · sk
2 is legal from C
3 , and (2) αm1
4 does not apply non-trivial primitives on the base objects
accessed at step sk
2 (by Property 7), and (3) sk
2 · α7 is legal from C
3 . Thus, Lemma 4.17 (where
β1 = αm1
4 , β2 = sk
2 , and β3 = α7) implies that α7 and αm1
4 do not contend.
Since α7 does not contend with α
3 and αm1
4 , and executions α (Lemma 4.29) and α1
1 · ... · αn+1 1 ·
αk
2 · s
1 · α
3 · αm1
4 · sk
2 are legal from C0, it follows that execution β = α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 ·
αm1
4 · sk
2 · α7 is also legal from C0.
Our next goal is to prove that, in α7, T7 reads the value 2 for data item a,k . To restrict the
serialization points of T
1 and Tk
2 in β, we first prove the following two lemmas regarding the
values that T m1
4 reads for data items dk,m1
2 and c ,m1
3 , respectively, in αm1
4 .
Lemma 4.31. In execution αm1
4 ,
(1) T m1
4 reads the value 0 for data item dk,m1
2 , and
(2) T m1
4 reads the value 1 for data item c ,m1
3 .
Proof. We first prove that transaction T m1
4 reads the value 0 for dk,m1
2 in αm1
4 . By
Lemma 4.27, execution γ1 = α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · αi
4 · α

k
5 is legal from C0. Since A satisfies weak adaptive consistency, there exist a consistency partition P (γ1) and a set com(γ1)
of committed and commit-pending transactions from γ1, which satisfy the conditions of
Definition 3.4. We argue that Tk
2  com(γ1). Assume, by contradiction, that Tk
2 ∈ com(γ1). We consider the following cases.
• Assume first that P (γ1) is such that Tk
2 and Tk
5 belong to different consistency groups G and
G
, respectively. Since (1) the execution interval of Tk
5 starts after the execution interval
of any of T 1
1 ,...,T n+1 1 in γ1, (2) T 1
1 ,...,T n+1 1 start before the beginning of Tk
2 , and (3) the
execution intervals of T 1
1 ,...,T n+1 1 ,Tk
2 do not overlap with the execution intervals of T
3 ,
T m1
4 , and Tk
5 , it follows that the execution interval of G precedes the execution interval of
G
. By Lemma 3.5, it follows that ∗T k
2 ,w <k
5 ∗T k
5 ,д. Hence, Tk
5 reads the value 2 for bk
2 in α

k
5 .
This contradicts Property 4.
• Assume that P (γ1) is such that Tk
2 and Tk
5 belong to the same consistency group G and G ∈
SI (P (γ1)). Since G is a snapshot isolation group and the execution interval of Tk
2 precedes
the execution interval of Tk
5 in γ1, it follows that ∗T k
2 ,w <k
5 ∗T k
5 ,д. Hence, Tk
5 reads the value
2 for bk
2 in α

k
5 . This contradicts Property 4.
• Assume that P (γ1) is such that Tk
2 and Tk
5 belong to the same consistency group G and
G ∈ PC(P (γ1)). Since G is a processor consistency group, no serialization point is inserted
between ∗T k
2 ,д and ∗T k
2 ,w and between ∗T k
5 ,д and ∗T k
5 ,w . By Lemma 4.21, Tk
2 reads the value
0 for bk
5 in αk
2 . Thus, ∗T k
2 ,д <k
2 ∗T k
5 ,w . Since no point is inserted between ∗T k
2 ,д and ∗T k
2 ,w , it
follows that ∗T k
2 ,w <k
2 ∗T k
5 ,w . Because Tk
2 and Tk
5 write to the same data item ek
2,5, it follows
that ∗T k
2 ,w <k
5 ∗T k
5 ,w . Since no point is inserted between ∗T k
5 ,д and ∗T k
5 ,w , it follows that
∗T k
2 ,w <k
5 ∗T k
5 ,д. Hence, Tk
5 reads the value 0 for bk
2 in α

k
5 . This contradicts Property 4.
Hence, Tk
2  com(γ1). Hence, T m1
4 reads the value 0 for data item dk,m1
2 in αm1
4 .
We next prove that transaction T m1
4 reads the value 1 for c ,m1
3 in αm1
4 . Lemma 4.30 implies that
the execution γ2 = α1
1 · ... · αn+1 1 · αk
2 · s
1 · α
3 · αm1
4 (which is a prefix of β), is legal from C0. Since
A satisfies weak adaptive consistency, there exist a consistency partition P (γ2) and a set com(γ2)
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.                    
2:42 V. Bushkov et al.
of committed and commit-pending transactions from γ2, which satisfy the conditions of Definition 3.4. We argue that ∗T
3 ,w <m1
4 ∗T m1 4 ,д by considering the following cases:
• Assume first that P (γ2) is such thatT
3 andT m1
4 belong to different consistency groupsG and
G
, respectively. Since the execution intervals of T 1
1 ,...,T n+1 1 ,Tk
2 ,T
3 precede the execution
interval of T m1
4 in γ2, the execution interval of G precedes the execution interval of G
. By
Lemma 3.5, it follows that ∗T
3 ,w <m1
4 ∗T m1 4 ,д.
• Assume now that P (γ2) is such that T
3 and T m1
4 belong to the same consistency group G
and G ∈ SI (P (γ2)). Since T
3 <γ2 T m1
4 and G is a snapshot isolation group, it follows that
∗T
3 ,w <m1
4 ∗T m1 4 ,д.
• Assume now that P (γ2) is such thatT
3 andT m1
4 belong to the same consistency groupG and
G ∈ PC(P (γ2)). Since G is a processor consistency group, no serialization point is inserted
between ∗T
3 ,д and ∗T
3 ,w and between ∗T m1 4 ,д and ∗T m1 4 ,w . By Property 3, T
3 reads the value
0 for bm1,
4 in α
3 . Thus, ∗T
3 ,д <
3 ∗T m1 4 ,w . Since no point is inserted between ∗T
3 ,д and ∗T
3 ,w ,
it follows that ∗T
3 ,w <
3 ∗T m1 4 ,w . Because T
3 and T m1
4 write to the same data item e
m1,
3,4 , it
follows that ∗T
3 ,w <m1
4 ∗T m1 4 ,w . Since no point is inserted between ∗T m1 4 ,д and ∗T m1 4 ,w , it
follows that ∗T
3 ,w <m1
4 ∗T m1 4 ,д.
In all cases, ∗T
3 ,w <m1
4 ∗T m1 4 ,д. Hence, T m1
4 reads the value 1 for c ,m1
3 in αm1
4 .
We are now ready to prove that T7 reads the value 2 for data item a,k in α7. We prove the
following:
Lemma 4.32. In execution α7, transaction T7 reads the value 2 for data items a,k and ck
2 , and the
value 1 for data item c
1 .
Proof. Consider the execution γ3 = α1
1 · ... · αn+1 1 · αk
2 · s
1 · sk
2 · αk
5 · α7. By definition of αk
5 , execution α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 is legal from C0. By Lemma 4.29, execution α1
1 · ... · αn+1 1 · αk
2 ·
s
1 · sk
2 · α7 is legal from C0. To prove that γ3 is legal from C0, we argue that αk
5 does not contend
with s
1 and α7.
By Lemma 4.29, execution α is legal from C0. Thus, α1
1 · ... · αn+1 1 · αk
2 · sk
2 · s
1 is legal from C0.
By definition of αk
5 , α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 is legal fromC0. Since both s
1 and αk
5 are legal from
the configuration resulting when α1
1 · ... · αn+1 1 · αk
2 · sk
2 is executed fromC0, andT
1 andTk
5 do not
conflict, Lemma 4.17 implies that s
1 and αk
5 do not contend.
By Properties 5 and 6, s
1 does not contend with sk
2 . Since s
1 and αk
5 do not contend, execution
α1
1 · ... · αn+1 1 · αk
2 · s
1 · sk
2 · αk
5 is legal from C0. By Lemma 4.29, execution α = α1
1 · ... · αn+1 1 · αk
2 ·
s
1 · sk
2 · α7 is legal from C0. Since αk
5 and α7 are legal from the configuration resulting when α1
1 ·
... · αn+1 1 · αk
2 · s
1 · sk
2 is applied from C0, and transactions Tk
5 and T7 do not conflict, Lemma 4.17
implies that αk
5 and α7 do not contend.
Since α1
1 · ... · αn+1 1 · αk
2 · s
1 · sk
2 · αk
5 and α1
1 · ... · αn+1 1 · αk
2 · s
1 · sk
2 · α7 are legal fromC0 and αk
5
and α7 do not contend, it follows that γ3 = α1
1 · ... · αn+1 1 · αk
2 · s
1 · sk
2 · αk
5 · α7 is legal from C0.
Since A satisfies weak adaptive consistency, there exist a consistency partition P (γ3) and a set
com(γ3) of committed and commit-pending transactions from γ3, which satisfy the conditions of
Definition 3.4. Since Tk
5 reads the value 2 for ek in αk
5 (by Property 4) , it follows that Tk
2 ∈ com(γ3)
and ∗T k
2 ,w <k
5 ∗T k
5 ,д. We consider the following cases.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.                                            
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:43
Fig. 14. The order of global read and write serialization points of some of the transactions in β in the sequential view of process p7.
Fig. 15. Execution β
.
• Assume first that P (γ3) is such that Tk
2 and T7 belong to different consistency groups G and
G
. Since (1) the execution intervals of T 1
1 ,...,T n+1 1 start before the execution interval of
Tk
2 , (2) the execution intervals of T 1
1 ,...,T n+1 1 and Tk
2 precede the execution intervals of Tk
5
and T7 in γ3, and (3) the execution interval of Tk
5 precedes the execution interval of T7 , it
follows that the execution interval ofG precedes the execution interval ofG
. By Lemma 3.5,
it follows that ∗T k
2 ,w <7 ∗T7,д. Hence, T7 reads 2 for ck
2 in α7.
• Assume now that P (γ3) is such that Tk
2 and T7 belong to the same consistency group G and
G ∈ SI (P (γ3)). Since Tk
2 <γ3 T7 and G is a snapshot isolation group, it follows that ∗T k
2 ,w <7
∗T7,д. Hence, T7 reads 2 for ck
2 in α7.
• Assume now that P (γ3) is such that Tk
2 and T7 belong to the same consistency group G and
G ∈ PC(P (γ3)). Since G is a processor consistency group, no serialization point is inserted
between ∗T k
2 ,д and ∗T k
2 ,w and between ∗T7,д and ∗T7,w . By Lemma 4.21, Tk
2 reads 0 for bk,
7
in αk
2 . Thus, ∗T k
2 ,д <k
2 ∗T7,w . Since G is a processor consistency group, no point is inserted
between ∗T k
2 ,д and ∗T k
2 ,w . So, ∗T k
2 ,w <k
2 ∗T7,w . BecauseTk
2 andT7 write to the same data item
ek
2,7, it follows that ∗T k
2 ,w <7 ∗T7,w . Since G is a processor consistency group, no point is
inserted between ∗T7,д and ∗T7,w . So, ∗T k
2 ,w <7 ∗T7,д. Hence, T7 reads 2 for ck
2 in α7.
By Property 3, T
3 reads the value 1 for b
1 in α
3 . Thus, ∗T
1 ,w <
3 ∗T
3 ,д <
3 ∗T
3 ,w . Because T
1 and
T
3 write to the same data item e
1,3, it follows that ∗T
1 ,w <m1
4 ∗T
3 ,w . By Lemma 4.31, T m1
4 reads
the value 0 for dk,m1
2 and 1 for c ,m1
3 . Thus, ∗T
3 ,w <m1
4 ∗T m1 4 ,д <m1
4 ∗T k
2 ,w . Thus, ∗T
1 ,w <m1
4 ∗T k
2 ,w .
Because T
1 and Tk
2 write to the same data item a,k , it follows that ∗T
1 ,w <7 ∗T k
2 ,w . Since T7 reads
the value 2 for ck
2 (by Lemma 4.32), it follows that ∗T k
2 ,w <7 ∗T7,д. Thus, ∗T
1 ,w <7 ∗T k
2 ,w <7 ∗T7,д,
and consequently, T7 reads the value 2 for a,k and 1 for c
1 in α7 (see Figure 14).
Let β = α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · αm2
6 · s
1 · α
7 (see Figure 15). We argue that (1) β is legal
from C0 and (2) in α
7, T7 reads the value 1 for data item a,k .
Lemma 4.33. Execution β is legal from C0.
Proof. By Lemma 4.28, execution α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · α1
6 · ... · αn+1 6 is legal from C0.
Because each pair of transactions among T 1
6 ,...,T n+1 6 do not conflict, Lemma 4.18 implies that no
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.                          
2:44 V. Bushkov et al.
pair of executions among α1
6 ,..., αn+1 6 contend. Hence, α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · αm2
6 is legal
from C0.
We next argue that s
1 is a legal step at the configuration resulting when α1
1 · ... · αn+1 1 · αk
2 · sk
2 ·
αk
5 · αm2
6 is applied from C0. Lemma 4.29 implies that execution α1
1 · ... · αn+1 1 · αk
2 · sk
2 · s
1 is legal
from C0. Since both αk
5 and s
1 are legal from the configuration resulting when α1
1 · ... · αn+1 1 · αk
2 ·
sk
2 is applied from C0, and Tk
5 and T
1 do not conflict, Lemma 4.17 implies that αk
5 and s
1 do not
contend. By Property 8, αm2
6 does not apply non-trivial primitives on the base objects accessed at
step s
1 . Since (1) αk
5 and s
1 do not contend, (2) αm2
6 does not apply non-trivial primitives on the
base objects accessed at step s
1 , and (3) executions α1
1 · ... · αn+1 1 · αk
2 · sk
2 · s
1 and α1
1 · ... · αn+1 1 ·
αk
2 · sk
2 · αk
5 · αm2
6 are legal fromC0, it follows that α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · αm2
6 · s
1 is legal from
C0.
We continue to argue that α
7 and αk
5 do not contend. Since αk
5 and s
1 do not contend, it follows
that αk
5 is legal from the configuration resulting when execution α1
1 · ... · αn+1 1 · αk
2 · sk
2 · s
1 is applied from C0. Lemma 4.29 implies that α
7 is also legal from that configuration. Since transactions
T7 and Tk
5 do not conflict, Lemma 4.17 implies that α
7 and αk
5 do not contend.
We next argue that α
7 and αm2
6 do not contend. Because (1) α1
1 · ... · αn+1 1 · αk
2 · sk
2 · s
1 · α
7 is legal
fromC0 (by Lemma 4.29), (2) αk
5 does not contend with α
7 and s
1 , and (3) α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5
is legal from C0, it follows that α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · s
1 · α
7 is legal from C0. Let Ck
5 be the
configuration that results from applying α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 starting from C0. Notice that
(1) αm2
6 · s
1 is legal from Ck
5 , (2) αm2
6 does not apply non-trivial primitives on the base objects
accessed at step s
1 (by Property 8), and (3) s
1 · α
7 is legal from Ck
5 . Thus, Lemma 4.17 (where
β1 = αm2
6 , β2 = s
1 , and β3 = α
7) implies that α
7 and αm2
6 do not contend.
Because α
7 does not contend with αk
5 and αm2
6 and executions α = α1
1 · ... · αn+1 1 · αk
2 · sk
2 · s
1 ·
α
7 and α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · αm2
6 · s
1 are legal from C0, it follows that β = α1
1 · ... · αn+1 1 ·
αk
2 · sk
2 · αk
5 · αm2
6 · s
1 · α
7 is legal from C0.
Our next goal is to prove that, in α
7, T7 reads the value 1 for data item a,k . To restrict the
serialization points of T
1 and Tk
2 in β
, we first prove the following two lemmas regarding the
values that T m2
6 reads for data items d,m2
1 and c
k,m2
5 in αm2
6 .
Lemma 4.34. In execution αm2
6 ,
(1) T m2
6 reads the value 0 for data item d,m2
1 , and
(2) T m2
6 reads the value 1 for data item c
k,m2
5 .
Proof. Consider the execution γ4 = α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · αm2
6 · α


3 . By definition of α


3 ,
it follows that α1
1 · ... · α
1 · α


3 is legal from C0. Lemma 4.33 implies that α1
1 · ... · αn+1 1 · αk
2 · sk
2 ·
αk
5 · αm2
6 is legal fromC0. To prove that γ4 is legal fromC0, we argue that α


3 does not contend with
executions α+1 1 ,..., αn+1 1 , αk
2 · sk
2 , αk
5 , and αm2
6 .
We first prove that α


3 does not contend with executions α+1 1 ,..., αn+1 1 . By Lemma 4.23, no pair
of executions among α1
1 · s1
1,..., αn+1 1 · sn+1 1 contend. It follows that for each i,  + 1 ≤ i ≤ n + 1,
the execution α1
1 · ... · α
1 · αi
1 is legal from C0. Since executions αi
1 and α


3 are legal from the
configuration resulting when α1
1 · ... · α
1 is applied from C0, and transactions Ti
1 and T
3 do not
conflict, Lemma 4.17 implies that α


3 does not contend with αi
1. Thus, α


3 does not contend with
any of the executions α+1 1 ,..., αn+1 1 .
We next prove that α


3 does not contend with αk
2 · sk
2 . Since α


3 does not contend with
α+1 1 ,..., αn+1 1 and α1
1 · ... · α
1 · α


3 is legal fromC0, it follows that α1
1 · ... · αn+1 1 · α


3 is legal from
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.                                                 
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:45
C0. Since execution α1
1 · ... · αn+1 1 · αk
2 · sk
2 is also legal from C0 (by Lemma 4.33) and transactions
T
3 and Tk
2 do not conflict, Lemma 4.17 implies that αk
2 · sk
2 and α


3 do not contend.
We continue to argue that α


3 does not contend with αk
5 . Since αk
2 · sk
2 and α


3 do not contend, it
follows that the execution α1
1 · ... · αn+1 1 · αk
2 · sk
2 · α


3 is legal from C0. Lemma 4.33 implies that
α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 is legal from C0. Since transactions Tk
5 and T
3 do not conflict,
Lemma 4.17 implies that α


3 and αk
5 do not contend.
In a similar way, we argue that α


3 does not contend with αm2
6 . Since α


3 and αk
5 do not contend, it
follows that α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · α


3 is legal fromC0. Since α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · αm2
6
is also legal from C0 (by Lemma 4.33), and transactions T
3 and T m2
6 do not conflict, Lemma 4.17
implies that α


3 and αm2
6 do not contend.
Because α


3 does not contend with executions α+1 1 ,..., αn+1 1 , αk
2 · sk
2 , αk
5 , αm2
6 , and executions
α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · αm2
6 (by Lemma 4.33) and α1
1 · ... · α
1 · α


3 (by definition of α


3 ) are
legal from C0, it follows that γ4 = α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · αm2
6 · α


3 is legal from C0.
(1) We now prove that T m2
6 reads the value 0 for data item d,m2
1 in αm2
6 . Since A satisfies
weak adaptive consistency, there exist a consistency partition P (γ4) and a set com(γ4)
of committed and commit-pending transactions from γ4, which satisfy the conditions of
Definition 3.4. We argue that T
1  com(γ4). Assume, by contradiction, that T
1 ∈ com(γ4).
We consider the following cases.
• Assume first that P (γ4) is such that T
1 and T
3 belong to different consistency groups
G and G
, respectively. Since (1) Ti
1 <γ4 T
1 for every 1 ≤ i <  and (2) the execution
interval of T
1 precedes the execution intervals of Tk
2 , T
3 , T m2
6 , Tk
5 and T j
1 for each  <
j ≤ n + 1, (3) the execution intervals of any two transactions in γ4 do not overlap, and
(4) the execution interval of any transaction in γ4 other than T
3 precedes the execution
interval ofT
3 , it follows that the execution interval ofG precedes the execution interval
of G in γ4. By Lemma 3.5, it follows that ∗T
1 ,w <
3 ∗T
3 ,д. Hence, T
3 reads the value 1
for b
1 in α


3 . This contradicts Property 3.
• Assume next that P (γ4) is such that T
1 and T
3 belong to the same consistency group
G and G ∈ SI (P (γ4)). Since T
1 <γ4 T
3 and G is a snapshot isolation group, it follows that ∗T
1 ,w <
3 ∗T
3 ,д. Hence, T
3 reads the value 1 for b
1 in α


3 . This contradicts
Property 3.
• Assume now that P (γ4) is such that T
1 and T
3 belong to the same consistency group G
and G ∈ PC(P (γ4)). Since G is a processor consistency group, no serialization point is
inserted between ∗T
1 ,д and ∗T
1 ,w and no serialization point is inserted between ∗T
3 ,д
and ∗T
3 ,w . By Lemma 4.20,T
1 reads the value 0 for b
3 in α
1 . Thus, ∗T
1 ,д <
1 ∗T
3 ,w . Since
no point is inserted between ∗T
1 ,д and ∗T
1 ,w , it follows that ∗T
1 ,w <
1 ∗T
3 ,w . BecauseT
1
and T
3 write to the same data item e
1,3, it follows that ∗T
1 ,w <
3 ∗T
3 ,w . Since no point
is inserted between ∗T
3 ,д and ∗T
3 ,w , it follows that ∗T
1 ,w <
3 ∗T
3 ,д. Hence, T
3 reads the
value 1 for b
1 in α


3 . This contradicts Property 3.
Hence, T
1  com(γ4). Hence, T m2
6 reads the value 0 for d,m2
1 in αm2
6 .
(2) We next prove that T m2
6 reads the value 1 for data item c
k,m2
5 in αm2
6 . Lemma 4.33 implies
that the execution γ5 = α1
1 · ... · αn+1 1 · αk
2 · sk
2 · αk
5 · αm2
6 (which is a prefix of β
) is legal
from C0. Since A satisfies weak adaptive consistency, there exist a consistency partition
P (γ5) and a set com(γ5) of committed and commit-pending transactions from γ5, which
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.                                                                                 
2:46 V. Bushkov et al.
Fig. 16. The order of global read and write serialization points of some of the transactions in β in the
sequential view of process p7.
satisfy the conditions of Definition 3.4. We argue that ∗T k
5 ,w <m2
6 ∗T m2 6 ,д by considering
the following cases.
• Assume first that P (γ5) is such that Tk
5 and T m2
6 belong to different consistency groups
G and G
, respectively. Since the execution intervals of T 1
1 ,...,T n+1 1 ,Tk
2 ,Tk
5 precede
the execution interval of T m2
6 in γ5, the execution interval of G precedes the execution
interval of G
. By Lemma 3.5, it follows that ∗T k
5 ,w <m2
6 ∗T m2 6 ,д.
• Assume now that P (γ5) is such that Tk
5 and T m2
6 belong to the same consistency group
G and G ∈ SI (P (γ5)). Since Tk
5 <γ5 T m2
6 and G is a snapshot isolation group, it follows
that ∗T k
5 ,w <m2
6 ∗T m2 6 ,д.
• Assume now that P (γ5) is such that Tk
5 and T m2
6 belong to the same consistency group
G and G ∈ PC(P (γ5)). Since G is a processor consistency group, no serialization point is
inserted between ∗T k
5 ,д and ∗T k
5 ,w and no serialization point is inserted between ∗T m2 6 ,д
and ∗T m2 6 ,w . By Property 4, Tk
5 reads the value 0 for bm2,k
6 in αk
5 . Thus, ∗T k
5 ,д <k
5 ∗T m2 6 ,w .
Since no point is inserted between ∗T k
5 ,д and ∗T k
5 ,w , it follows that ∗T k
5 ,w <k
5 ∗T m2 6 ,w .
BecauseTk
5 andT m2
6 write to the same data item e
m2,k
5,6 , it follows that ∗T k
5 ,w <m2
6 ∗T m2 6 ,w .
Since no point is inserted between ∗T m2 6 ,д and ∗T m2 6 ,w , it follows that ∗T k
5 ,w <m2
6 ∗T m2 6 ,д.
In all cases, ∗T k
5 ,w <m2
6 ∗T m2 6 ,д. Hence,T m2
6 reads the value 1 for data item c
k,m2
5 in αm2
6 .
We are now ready to argue about the value that T7 reads for data item a,k in α
7.
Lemma 4.35. T7 reads the value 1 for a,k in α
7.
Proof. By definition of αk
5 , Tk
5 reads the value 2 for bk
2 in β
. Thus, ∗T k
2 ,w <k
5 ∗T k
5 ,д <k
5 ∗T k
5 ,w .
Since Tk
2 and Tk
5 write to the same data item ek
2,5, it follows that ∗T k
2 ,w <m2
6 ∗T k
5 ,w . By Lemma 4.34,
T m2
6 reads the value 0 for d,m2
1 and the value 1 for c
k,m2
5 in β
. So, ∗T k
5 ,w <m2
6 ∗T m2 6 ,д <m2
6 ∗T
1 ,w .
Hence, ∗T k
2 ,w <m2
6 ∗T
1 ,w . Since T
1 and Tk
2 write to the same data item a,k , it follows that ∗T k
2 ,w <7
∗T
1 ,w .
By Lemma 4.29, α
7 and α7 are indistinguishable to p7. Thus, for each data itemT7 reads, it reads
the same value in α
7 and α7. By Lemma 4.32, T7 reads the value 1 for c
1 in α7. Thus, T7 reads the
value 1 for c
1 in α
7. It follows that ∗T
1 ,w <7 ∗T7,д. Thus, ∗T k
2 ,w <7 ∗T
1 ,w <7 ∗T7,д. Hence, T7 reads
the value 1 for a,k in α
7 (see Figure 16).
By Lemma 4.32, T7 reads the value 2 for data item a,k in α7. By Lemma 4.35, T7 reads the value
1 for data item a,k in α
7. Since α7 is indistinguishable from α
7 to process p7 (by Lemma 4.29), this
is a contradiction. This completes the proof of Theorem 4.19.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.                 
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:47
5 THE LIMITS OF THE PCL THEOREM
In this section, we explore the limits of our impossibility result. Specifically, we consider a weaker
version for each of the three properties assumed by the PCL theorem, and we show that in all cases
the impossibility result does not hold.
5.1 Weakening DAP
In this section, we present a simple algorithm that ensures R/W-independent snapshot isolation,
r-strict disjoint-access-parallelism, and obstruction-freedom using an xchg primitive that atomically updates two base objects, as well as CAS objects and read/write registers. The algorithm,
ALGORITHM 1: Data structures of SI-DSTM and code for Begin(), Create(), and Abort(),
where the values that data items can take are of type objType.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
2:48 V. Bushkov et al.
ALGORITHM 1: Continued
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:49
called SI-DSTM, is a simple modification of DSTM [35]. Like DSTM, SI-DSTM is a dynamic TM
algorithm; i.e., it supports the creation of new data items dynamically at runtime. Thus, the algorithm supports an additional t-operation, called Create, to create new data items during the
execution of transactions.
For each live transaction T , SI-DSTM maintains a structure, called transactional record, with
fields: (1) status, which stores the current status of T and takes values Active, Committed, or
Aborted (initially Active), (2) pendinдStatus, which indicates whether T should eventually abort
and takes values Active, Committed or Aborted (initially Committed), (3) readList, which is a list
of elements, one for each data item globally read by T , where each element of the readList stores
information about a data item globally read byT , and (4)writeList, which is a list of elements, one
for each data item written by T , where each element of the writeList stores information about a
data item written by T .
For each data item, the algorithm maintains two structures, Locator and DataItem (see Algorithm 1). Locator consists of three fields: (1) a pointer transaction to the record of the transaction
that holds the ownership of this data item (initially null), (2) a pointer oldV alue to its previous value
(initially null), and (3) a pointer newValue to its new value (i.e., the value being written by each
Write to the data item) or its initial value (set by Create). A record of type DataItem contains
just a pointer to an object of type Locator. Each data item can be created dynamically by invoking
Create , which creates a new data item with the fields of its Locator having initial values.
For each transaction T in α, there is a unique record of type T ransaction, which we denote by
trT . Moreover, for each data item x, there is a pointer to a unique record of type DataItem, which
we denote by dix . This DataItem exists in any configuration C after the response of Create (if x
is created dynamically), or from C0 otherwise. We denote by locx (C) the pointer to the record of
type Locator pointed to by dix→start at some configuration C. We say that transaction T holds
the ownership for data item x in configuration C if locx (C)→transaction points to trT at C.
To read a data item x, a transaction T calls Read , which first finds the value that it will return
for x. If x has already been written byT , then the value of x is taken fromT ’s write list. Otherwise,
the value of x is determined by calling GetCurrentValue (line 29). If the status of the transaction
that holds the ownership of a data item is Active or Aborted, then the value of the data item
is stored in the memory location to which the oldValue field of its locator points; otherwise, it
is stored in the memory location to which the newValue field of its locator points (see pseudocode for GetCurrentValue(), lines 18–21). If there is no element for x in T ’s read list, then such an
element is added there. We remark that read-only transactions never cause any other transaction
to abort.
To write a data item x, Write() checks if the ownership of x is already held by T (line 39),
and if yes, then a pointer to the new value is written in the newValue field of current x’s locator
(line 39) and the existing element corresponding to x inT ’s write list is updated to record newValue
(line 36). Otherwise, a pointer to x and its new value are added to T ’s write list (line 37). Then,
cloning and indirection is employed: a new locator is created for x and its transaction pointer
is initialized to point to the transactional record of T (lines 42–44). Then, T repeatedly tries to
change the start pointer of the DataItem of x to point to this new locator using CAS (line 50).
Before doing so, it writes the value Aborted in the pendinдStatus field of the transaction that
holds the ownership of x.
When T invokes Commit(), it first calls ValidateReadList() to check whether each data item x in
T ’s read list has been written by another transaction, since the first Read for x by T . If validation
is successful, then Commit() executes xchg to atomically exchange the value of the pendinдStatus
field in its transactional record with that of the status field. It then reads status again and returns
true or false depending on whether it reads the value Committed or Aborted from it.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
2:50 V. Bushkov et al.
In SI-DSTM, read-only transactions are invisible, i.e. transactional records of read-only transactions never become shared. Notice that a read-only transaction T never causes any other transaction to abort, so it never applies any non-trivial primitives to any field of the transactional record
of any other transaction. T only reads the status fields of the transactional records of other transactions to discover the current values of the data items read by T .
Obviously, a transaction will manage to eventually finish its execution successfully, if it runs solo
for a sufficient amount of time (it may abort the first time it will callcommit but it will commit the
next time it will be re-started given that no other process takes steps concurrently). However, if a
read-only transaction is executed concurrently with update transactions, then SI-DSTM does not
provide any guarantee that the read-only transaction will not being aborted repeatedly forever.
Moreover, in the presence of contention, an update transaction may never terminate its execution,
since it may execute the body of the while loop of line 45 forever.
To achieve strict disjoint-access-parallelism between any read-only transaction T and update
transactions in SI-DSTM, we employ the pendinдStatus field in Locator. If a transaction T1 performs Write on a data item x for which a transaction T2 holds the ownership, then T1 does not
write Aborted in the status field of T2; it rather writes this value in pendinдStatus to indicate
that T2 should later abort. At commit time, T2 performs an exchange of pendinдStatus and status
and finds out that it has to abort. It is only after this exchange that other transactions become
aware that T2 has aborted. In this way, a read-only transaction T that reads data items owned by
T2 contend only with T2 and not with T1 or other update transactions that write in the transactional record of T2. By inspection of the code, it follows that if T reads the status of T2, then T
and T2 conflict on some data item x. Thus strict disjoint-access-parallelism is ensured between a
read-only transaction and any other transaction.
Consider three transactions T , T 
, and T  and assume that T writes data items x1 and x2, T 
writes x2 and x3, andT  writes x3 and x4. Consider an execution whereT  executes first up until it
is poised to invoke commitT , thenT executes until its completion, and finallyT  executes until its
completion. Notice that T and T  do not conflict in the given execution. Still, they will contend on
the pendinдStatus field of T 
’s transactional record. Thus, strict disjoint-access-parallelism is not
ensured between update transactions. However, it is easy to see that disjoint-access-parallelism is
ensured in this case.
5.1.1 Proof that SI-DSTM Ensures R/W-independent Snapshot Isolation. We start by introducing
useful notation to reason about the correctness of the algorithm.
Consider any execution α and let C be any reachable configuration. We denote by ϕ(C, α) the
sequence of alternating steps and configurations resulting from applying α starting from C.
If C1 and C2 are two configurations in ϕ(C0, α), where C0 is an initial configuration, then we use
C1 < C2 to denote that C1 precedes C2 in ϕ(C0, α). We use C1 ≤ C2 to denote that either C1 < C2 or
C1 is C2. We also write C1 > C2 (C1 ≥ C2) when C2 < C1 (C2 ≤ C1).
We say that a transaction T writes to (reads from) data item x in ϕ(C0, α) if T invokes Write
(Read, resp.) passing a reference to dix as an argument. Denote by R(T ) the set of data items thatT
globally reads in ϕ(C0, α). Similarly, denote byW (T ) the set of data items that T writes in ϕ(C0, α).
For any transaction T that executes line 56 in ϕ(C0, α) with trT →pendinдStatus being equal to
Committed, let Cw (T ) be the configuration immediately after the execution of line 56 by T ; since
trT →pendinдStatus is equal to Committed when T executes line 56, the value of trT →status is
equal to Committed at Cw (T ). Let Cr (T ) be the configuration immediately after the response of
the instance of GetCurrentValue called (on line 29) during the execution of the last instance of
global Read invoked by T .
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:51
For any reachable configuration C, we define the value of x at C, denoted by vx (C), as
follows:
• if locx (C)→transaction is null or locx (C)→transaction→status is Committed, then
vx (C) = locx (C)→newValue;
• otherwise, vx (C) = locx (C)→oldValue.
For any committed transaction T and any x ∈ W (T ), nvx (T ) denotes the pointer (of type
newObject) initiated on line 33 during the execution of the last instance of Write for x executed
by T . Informally, nvx (T ) points to the last value written by T for x.
Let G be any instance of GetCurrentValue invoked by T on line 23 or line 29 in ϕ(C0, α). Denote
by di(G) the data item defined as follows:
• if G is invoked on line 29, then di(G) is the data item passed as the second argument to the
instance of Read , which invokes G;
• if G is invoked on line 23, then di(G) is the data item accessed while executing line 22 just
before the invocation of G.
For convenience, the notation is summarized in Figure 17.
Theorem 5.1. SI-DSTM satisfies R/W-independent snapshot isolation.
We start with a brief outline of the proof. We assign serialization points to every transaction T that executes line 56 with its pendinдStatus field being equal to Committed. The write
serialization point of T is placed at Cw (T ) and its global read serialization point is placed at Cr (T ).
First (in Lemma 5.2), we prove that T holds the ownership for all data items in its write set at
Cw (T ) and for each such data item x, vx (Cw (T )), the value of x at Cw (T ), is equal to nvx (T ), the
last written value for x by T . We then prove (in Lemma 5.3) that the value of x cannot change
from a configuration to another, if there does not exist a transaction that executes line 56 with
its pendinдStatus being equal to Committed between the two configurations. We next prove two
lemmas that will allow us to argue that Tд is legal. The first of these lemmas (Lemma 5.5) proves
that any instance G of GetCurrentValue for a data item x returns the value of x at a configuration
between G’s invocation and response. In other words, we ensure that G does not return a value
that this data item had at some obsolete point in time. Then, Lemma 5.6 argues that the value of x
is the same at every configuration that follows the first invocation of a global Read for x by T and
precedes the invocation of ValidateReadList byT . We employ these lemmas to prove that SI-DSTM
ensures R/W-independent snapshot isolation.
We start with some observations that can be derived by simply inspecting the code. Consider
an execution α and let C be a configuration in ϕ(C0, α).
Each time a data item is updated, a new locator is allocated (lines 43–52), so no transaction
ever updates the transaction and oldValue fields of an existing locator. By inspection of the code
(lines 39–41), it also follows that the newValue field of a locator that has been allocated by a
transaction T can only change during invocations to Write initiated by T itself. Notice that the
first time T calls Write after calling Create for some data item x, it creates a new locator for x
instead of updating the locator that allocated for x during Create.
Observation 1. Let F be either an instance of Create executed by a transaction T , or an instance
of Write executed byT , which returnstrue on line 51 in ϕ(C0, α). Letloc be the object of type Locator
created by T during the execution of F . Then, the following hold:
(1) if F is an instance of Create, then the transaction, newValue, and oldValue fields of loc do
not change after the execution of line 14;
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
2:52 V. Bushkov et al.
Fig. 17. Notation used in this section.
(2) if F is an instance of Write, then the transaction and oldValue fields of loc do not change
after the successful execution of CAS on line 50;
(3) if T executes line 56 in ϕ(C0, α), then the newValue field of loc does not change after the
execution of xchg on line 56.
Notice that dix → start changes only on lines 14 and 50. By inspection of the code (line 43)
and by definition of locx (C), it follows that once locx (C)→transaction takes a non-null value, all
subsequent values of it are also non-null. This and Observation 1 imply the following:
Observation 2. For every data item x and for every configuration C > C the following hold:
(1) if locx (C)→transaction  null, then locx (C
)→transaction  null;
(2) if locx (C)→transaction = null and locx (C) = locx (C
), then locx (C
)→transaction =
null.
Observation 3. For every transaction T in ϕ(C0, α) the following hold:
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.  
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:53
(1) if T executes line 56 in ϕ(C0, α) with trT →status being equal to Committed, then
trT →status = Committed at every configuration C ≥ Cw (T ) and trT →status = Active at
every configuration C < Cw (T ) at which trT exists,
(2) otherwise, trT →status  Committed at every configuration in ϕ(C0, α) at which trT exists.
Observation 4. Consider any transactionT such thattrT .PendinдStatus = Aborted at some configuration C. Then, at each configuration C between C and the configuration at which T executes
line 56, it holds that trT .PendinдStatus = Aborted.
Each time a new locator is created, its newValue field is set to point to a newly allocated object,
which is created either on line 8 or on line 33 by calling newcell(). Therefore, we have the following
observation.
Observation 5. For each pair of configurations C1 and C2 in ϕ(C0, α) the following hold:
(1) if locx (C1)  locx (C2), then locx (C1)→newValue  locx (C2)→newValue;
(2) if C1 ≤ C2, then locx (C1)→oldValue  locx (C2)→newValue.
A transactionT sets the transaction field of the locator of a data item x to point to trT on line 43
while it executes an instance of Write for x. Observation 1 implies that the transaction field of
this locator never changes thereafter. By inspection of the code (lines 35–37), it follows that if
locx (C) → transaction = trT at some configuration C, then x ∈ W (T ).
Observation 6. Consider any data item x and let C be a configuration such that locx (C) →
transaction = trT at C. Then, x ∈ W (T ).
Lemma 5.2. Let T be a transaction that executes line 56 with trT →pendinдStatus being equal to
Committed in ϕ(C0, α). For each x ∈ W (T ), T holds the ownership of x at Cw (T ) and vx (Cw (T )) =
nvx (T ).
Proof. We first prove that there is a configuration in ϕ(C0, α) at which T holds the ownership
of x. Since x ∈ W (T ), the definition of W (T ) implies that T invokes Write for x at least once in
ϕ(C0, α). If W r is the first invocation of Write for x by T in ϕ(C0, α), then the condition of the
if statement on line 39 is evaluated to f alse during the execution of W r. Therefore, W r does
not return on line 41 and proceeds to the execution of the while loop. By assumption, T executes
line 56, i.e.,T invokes Commit in ϕ(C0, α). It follows thatW r, as well as all other Write invocations
by T , successfully return. Thus, the last execution of CAS (line 50) by T duringW r is successful. By
inspection of the code, it follows that after the successful execution of this CAS, dix→start points
to the locator created for x byT inW r. The transaction field of this locator points to trT (line 43). It
follows that at the configuration Cwr resulting from the successful execution of the CAS on line 50
during W r, T holds the ownership of x.
Next, we prove that T holds the ownership of x at any configuration between Cwr and Cw (T ).
Assume, to derive a contradiction, that there is a configuration between Cwr and Cw (T ) at which
T does not hold the ownership of x; letC be the last configuration in ϕ(C0, α) such thatCwr ≤ C <
Cw (T ) and, at C, T holds the ownership of x. Let C be the configuration immediately after C in
ϕ(C0, α). Then, at C
, T no longer holds the ownership of x. Thus, locx (C
)→transaction  trT .
Since locx (C)→transaction = trT , Observation 2 implies that locx (C
)→transaction = trT  for
some transaction T   T . Since locx (C)→transaction  locx (C
)→transaction, Observation 1 implies that dix→start has diffrerent values in C and C
. Since dix→start changes only on line 50, it
follows that the step betweenC andC is a successful execution of the CAS on line 50 on dix→start
by T 
. Let W r be the instance of Write by T  in which this CAS is executed. Since this CAS is successful, it follows that oldLoc, the second argument of CAS, is equal to locx (C) when this CAS is
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.       
2:54 V. Bushkov et al.
executed. By inspection of the code, the value of oldLoc is read on line 38 at some configuration
C < C. Thus, locx (C ) = locx (C). Moreover, before W r successfully executes the CAS on line 50,
T  executes line 46 on which it sets oldT r to be equal to oldLoc→transaction. Since T  executes
line 46 between C and C, Observation 1 implies that locx (C)→transaction is the same at C and
when T  executes line 46. Because oldLoc = locx (C) and locx (C)→transaction = trT when T  executes line 46, it follows that oldT r = trT after the execution of line 46. Since C < Cw (T ), Observation 3 implies that trT →status = Active at C and when T  executes line 47, which happens
before C
. Thus, when T  executes the if statement of line 47, it observes that oldT r  null and
that oldT r→status is Active. By inspection of the code, it follows thatT  executes line 48 at which
it sets the value of trT →pendinдStatus to Aborted. Hence, by Observation 4, T executes line 56
with trT →pendinдStatus being equal to Aborted. This contradicts the assumption thatT executes
line 56 with trT →pendinдStatus being equal to Committed. Thus, T holds the ownership of x at
each configuration between Cwr and Cw (T ), and consequently locx (Cw (T ))→transaction = trT .
Since locx (Cw (T ))→transaction = trT and trT →status is equal to Committed at Cw (T ), it follows that vx (Cw (T )) = locx (Cw (T ))→newValue. Since T holds the ownership of x at any configuration between Cwr and Cw (T ), by inspection of the code (line 40), it follows that each
time T executes Write for x, the newValue field of the locator of T is updated to point to the
memory location pointed to by newObj, which contains the new value to be written. Therefore,
vx (Cw (T )) = nvx (T ).
Lemma 5.3. Consider any two configurations C1 and C2 in ϕ(C0, α) such that C1 < C2 and let x be
any data item. Then, vx (C1)  vx (C2) if and only if there is a transaction T in ϕ(C0, α) such that:
(1) x ∈ W (T ),
(2) T executes line 56 with trT →pendinдStatus being equal to Committed, and
(3) C1 < Cw (T ) ≤ C2.
Proof. Necessary condition. We start by proving that if vx (C1)  vx (C2), there is a transaction T in ϕ(C0, α), which has the required properties. Let C > C1 be the first configuration among
all configurations between C1 and C2 such that vx (C1)  vx (C
) and let C be the configuration
just before C in ϕ(C0, α). Because vx (C) = vx (C1) and vx (C
)  vx (C1), it follows that the step
executed between C and C causes one of the following actions:
• either dix→start is changed to point to a new locator, so locx (C)  locx (C
),
• or locx (C) = locx (C
) and locx (C)→transaction→status is changed from Active to
Committed.
We argue that the first of these actions do not occur. To derive a contradiction, assume that
dix→start is changed to point to a new locator. Then, by inspection of the code, there is a transaction T , which successfully executes a CAS on line 50 changing dix→start from locx (C) to locx (C
).
LetW r be the instance of Write in which this CAS is executed. By inspection of the code, it follows
that the oldLoc local variable of W r has the same value aslocx (C) during the execution of the last
iteration of the while loop in which the successful CAS on line 50 is executed. Before executing this
CAS, T executes line 49. Since oldLoc = locx (C) when line 50 is executed, it follows that T invokes
an instance G of GetCurrentValue on line 49 with locx (C) as its argument and writes the value
that G returns into locx (C
)→oldV alue (since, by assumption, the newLoc local variable ofW r has
the value locx (C
)).
We next argue that G returns vx (C). Notice that G checks the status of locx (C)→transaction on
line 19. Let C be the configuration at which line 19 of G is executed. We consider the following
cases:
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.          
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:55
• Assume that locx (C)→transaction = null when line 18 is executed during G. Thus, G returns locx (C)→newValue on line 20. Because locx (C)→transaction = null, by inspection
of the code, it follows that the locator pointed to by locx (C) was created on line 7 during the
execution of an instance of Create. Thus, Observation 1 implies that locx (C)→newValue
has the same value at the configuration that G executes line 20 and at C. Observation 3
implies that locx (C)→transaction = null at any configuration Q ≥ C. Thus, the definition
of vx (C) implies that vx (C) = locx (C)→newValue and, consequently, G returns vx (C).
• Assume that locx (C)→transaction = trT  for some transaction T  and that T reads
Aborted from locx (C)→transaction→status when it executes line 19 in G. Thus, G returns locx (C)→oldV alue on line 21. By Observation 1, locx (C)→oldValue has the same
value at the configuration that G executes line 21 and at C. Observation 3 implies that
locx (C)→transaction→status is Aborted at any configuration Q ≥ C. Thus, the definition
of vx (C) implies that vx (C) = locx (C)→oldValue and, consequently, G returns vx (C).
• Assume that locx (C)→transaction = trT  for some transaction T  and that T reads
Committed from locx (C)→transaction→status when it executes line 19 in G. Thus, G returns locx (C)→newValue on line 20. Because the status of T  is Committed when T executes line 19 in G, it follows that T  executes line 56 with trT →pendinдStatus being
equal to Committed before T executes line 19 in G. Thus, Observation 1 implies that
locx (C)→newValue has the same value at the configuration that G executes line 20 and
at C. Observation 3 implies that locx (C)→transaction→status is Committed at any configuration Q ≥ C. Thus, the definition of vx (C) implies that vx (C) = locx (C)→newValue and,
consequently, G returns vx (C).
• Assume that locx (C)→transaction = trT  for some transaction T  and that T reads Active
from locx (C)→transaction→status when it executes line 19 in G. Thus, G returns
locx (C)→oldValue on line 21. By Observation 1, locx (C)→oldValue has the same value at
the configuration thatG executes line 21 and atC. Iflocx (C)→transaction→status is Active
or Aborted at C, then the definition of vx (C) implies that vx (C) = locx (C)→oldValue and,
consequently, G returns vx (C).
Assume, to derive a contradiction, that locx (C)→transaction→status is Committed at C.
Then, T  executes line 56 with trT →pendinдStatus being equal to Committed between
the read on line 19 in G and C. By inspection of the code, before executing G on line 49
transaction T executes line 47 on which it reads locx (C)→transaction→status. Because
T reads Active from locx (C)→transaction→status when it executes line 19 in G, Observation 3 implies that T reads Active from locx (C)→transaction→status when it executes line 47. Thus, by inspection of the code, it follows that T executes line 48 on
which it sets locx (C)→transaction→pendinдStatus to be equal to Aborted. This contradicts the fact that later on, between the read on line 21 in G and C, T  executes line 56 with
trT →pendinдStatus being equal to Committed.
In either case, G returns vx (C). By definition of C, vx (C) = vx (C1). It follows that T
sets locx (C
)→oldValue to vx (C1) (on line 49). Before executing line 49, transaction T
changes locx (C
)→transaction to point to trT (on line 43). Observation 1 implies that
locx (C
)→transaction = trT thereafter. By assumption,T does not execute line 56 beforeC
. Thus,
Observation 3 implies that at C
, the value of trT →status cannot be equal to Committed. It follows
that vx (C
) = locx (C
)→oldValue = vx (C1). This contradicts the definition of C
.
Therefore, it must be that locx (C) = locx (C
). It follows that the step executed betweenC andC
changeslocx (C)→transaction→status from Active to Committed. Let T = locx (C)→transaction.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
2:56 V. Bushkov et al.
By inspection of the code, locx (C)→transaction→status can be changed from Active to
Committed only if T executes line 56 with trT →pendinдStatus being equal to Committed. This
and Observation 6 imply that the claim holds.
Sufficient condition. We continue to prove that if there is a transaction in α, which has the
required properties, then vx (C1)  vx (C2). LetT be the last such transaction, i.e.,T is a transaction
in α such that
• x ∈ W (T ),
• T executes line 56 with trT →pendinдStatus being equal to Committed,
• C1 < Cw (T ) ≤ C2, and
• if Cw (T )  C2, then there is no transaction T  in ϕ(C0, α) such that x ∈ W (T 
), T  executes
line 56 with trT →pendinдStatus being equal to Committed, and Cw (T ) < Cw (T 
) ≤ C2.
We argue that vx (Cw (T )) = vx (C2). To derive a contradiction, assume that vx (Cw (T ))  vx (C2).
By the necessary condition (proved above), there is a transaction T  such that x ∈ W (T 
), T  executes line 56 with trT →pendinдStatus being equal to Committed, and Cw (T ) < Cw (T 
) ≤ C2.
Because Cw (T ) < Cw (T 
), T  T 
. This contradicts the definition of T . So, vx (Cw (T )) = vx (C2).
By Lemma 5.2, locx (Cw (T ))→transaction = trT . Since trT →status is equal to Committed
at Cw (T ), it follows that vx (Cw (T )) = locx (Cw (T ))→newValue and, consequently, vx (C2) =
locx (Cw (T ))→newValue. We proceed by case analysis.
Assume that locx (C1) = locx (Cw (T )). Since C1 < Cw (T ), Observation 3 implies that
locx (C1)→transaction→status = Active at C1. Thus, the definition of vx (C1) implies that
vx (C1) = locx (C1)→oldValue. SinceC1 < Cw (T ), Observation 5 implies thatlocx (C1)→oldV alue
locx (Cw (T ))→newValue. Thus, vx (C1)  vx (C2).
Assume now that locx (C1)  locx (Cw (T )). If vx (C1) = locx (C1)→newValue, then Observation 5
implies that locx (C1)→newValue  locx (Cw (T ))→newValue. If vx (C1) = locx (C1)→oldV alue,
then, since C1 < Cw (T ), Observation 5 implies that locx (C1)→oldValue  locx (Cw (T ))→
newValue. It follows that vx (C1)  vx (C2).
Corollary 5.4. Consider any two configurations C1 and C2 in ϕ(C0, α) such that C1 < C2 and let
x be any data item. Ifvx (C1) = vx (C2), then for every configurationC such thatC1 < C < C2, it holds
that vx (C) = vx (C1) = vx (C2).
Proof. Assume, to derive a contradiction, that there exists a configuration C such that C1 <
C < C2 and vx (C)  vx (C1). Then, Lemma 5.3 (necessary condition) implies that there is a transaction T in ϕ(C0, α) such that x ∈ W (T ), T executes line 56 with trT →pendinдStatus being equal
to Committed, and C1 < C < Cw (T ) ≤ C2. Thus, Lemma 5.3 (sufficient condition) implies that
vx (C1)  vx (C2). This is contradiction.
Lemma 5.5. Consider any instance G of GetCurrentValue invoked on line 23 or 29 by some transaction T in ϕ(C0, α). Let x = di(G) and let r be the read of dix→start performed by T (on line 23
or 29) to determine the argument of G. If C1 is the configuration immediately before r, and C2 is the
configuration that follows the response of G, then there exists a configuration C such that G returns
vx (C) and C1 ≤ C < C2.
Proof. By inspection of the code (line 23 or 29), the argument passed to G is locx (C1). By
Observation 1, the transaction and oldValue fields of any Locator object are immutable. By Observation 3, trT →status is not equal to Committed as long as T executes G. We proceed by case
analysis.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.              
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:57
(1) If locx (C1)→transaction = null or locx (C1)→transaction = trT at C1, then let C = C1. We
argue that in either case the claim holds.
Assume first thatlocx (C1)→transaction = null. By inspection of the code,G returns the
value read in locx (C1)→newValue on line 20, i.e., G returns the value that the newValue
field of the locator to which locx (C1) points to has at the configuration that G executes
line 20. By the definition of vx (C), vx (C) has the value stored in locx (C1)→newValue
at C1. Since the transaction field of the locator pointed to by locx (C1) is equal to null,
it follows that this locator is created in some instance of Create. By Observation 1,
locx (C1)→newValue never changes thereafter. Thus, G returns vx (C).
Assume now that locx (C1)→transaction = trT . Since trT →status is not equal to
Committed during the execution of G, by inspection of the code (lines 19 and 21), it
follows that G returns the value stored in locx (C1)→oldValue at the configuration that
line 21 is executed; moreover, by the definition of vx (C), vx (C) has the value stored in
locx (C1)→oldValue at C1. By Observation 1, locx (C1)→oldValue is immutable. Thus, G
returns vx (C).
(2) Assume now that locx (C1)→transaction = trT  for some transaction T   T . Let C be the
configuration just before T reads trT →status (line 19) during the execution of G.
If trT →status is Aborted or Active at C
, then let C = C1. By inspection of the code
(lines 19 and 21), G returns the value stored in locx (C1)→oldV alue at the configuration
that line 21 is executed. Since C1 < C
, Observation 3 implies that trT →status cannot be
equal to Committed atC1. Therefore, by the definition ofvx (C),vx (C) has the value stored
in locx (C1)→oldV alue at C1. By Observation 1, locx (C1)→oldValue is immutable. Thus,G
returns vx (C).
Assume next that trT →status is Committed at C
. By inspection of the code, G returns the value stored in locx (C1)→newValue at C
. Since locx (C1)→transaction = trT 
and trT →status is Committed at C
, it follows that G returns nvx (T 
).
If trT →status is Active at C1, then it holds that C1 < Cw (T 
) ≤ C
; let C = Cw (T 
)
in this case. Otherwise, let C = C1. By the definition of vx (C), vx (C) equals to the
value that locx (C)→newValue has at C. In case C = Cw (T 
), Lemma 5.2 implies that
locx (C)→transaction = trT . Recall that this also holds in case C = C1 (by assumption).
In either case, the value that locx (C)→newValue has at C is equal to nvx (T 
). Thus, G
returns vx (C).
Let T be a transaction that executes line 56 in ϕ(C0, α) and let x ∈ R(T ). Let Gf be the instance
of GetCurrentValue invoked on line 29 in the first instance of Read for x by T , and let Gl be the
instance of GetCurrentValue invoked on line 23 for x during the execution of ValidateReadList
by T . Lemma 5.5 implies that there exists a configuration Cf (Cl , respectively) such that Gf (Gl ,
respectively) returns vx (Cf ) (vx (Cl ), respectively), and this configuration is between the read of
the argument for Gf (Gl , respectively) and the response of Gf (Gl , respectively).
Lemma 5.6. For every configuration C such that Cf ≤ C ≤ Cl , vx (C) = vx (Cf ) = vx (Cl ).
Proof. Notice that trT contains a readList field to store the read list of T . By inspection of the
code, it follows that readList is modified when T executes line 31. Since T invokes Read for x, T
executes line 31 during the first invocation of Read for x, adding x together with the value vx (Cf )
in its read list. The condition of the if statement on line 30 ensures that only the first invocation
of Read for each data item may modify readList. Because T executes line 56, the invocation of
ValidateReadList invoked by T returns true. It follows that vx (Cf ) = vx (Cl ). Corollary 5.4 implies
that vx (C) = vx (Cf ) = vx (Cl ), for every configuration C, Cf < C < Cl .
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.   
2:58 V. Bushkov et al.
By definition of Cr (T ), Cr (T ) occurs before the invocation of ValidateReadList on line 53 by T
and after the response of GetCurrentValue that T invokes on line 29 during the execution of any
of the global Read t-operations that it performs. Thus, Cf < Cr (T ) < Cl . So, Lemmas 5.5 and 5.6
imply the following corollary.
Corollary 5.7. If T is a transaction that invokes Commit in ϕ(C0, α), then for every data item
x ∈ R(T ), each Read for x by T returns vx (Cr (T )).
Lemma 5.8. Let com(α) be the set of all transactions in α that execute line 56 in ϕ(C0, α) with
pendinдStatus being equal to Committed and let σα be a sequence of serialization points defined as
follows: for each T ∈ com(α), its global read serialization point ∗T,д is placed at Cr (T ) and its write
serialization point ∗T,rw is placed at Cw (T ). Then the following hold:
(1) ∗T,д precedes ∗T,rw in σα ,
(2) both ∗T,д and ∗T,rw are placed within the active execution interval of T ,
(3) if Hσα is the history we get if, for each T ∈ com(α), we replace each ∗T,д with Hα |Tд and
each ∗T,rw with Hα |Trw in σα , then Hσα is legal.
Proof. By definitions ofCr (T ) andCw (T ),Cr (T ) < Cw (T ). Additionally, sinceT ∈ com(α), both
Cr (T ) andCw (T ) occur in the active execution interval ofT . So, ∗T,д precedes ∗T,rw in σα and they
are both placed within the active execution interval of T .
To prove that Hσα is legal, we prove that transactions Tд and Trw are legal in Hσα . Notice that
for every Read on a data item x in Trw , there is a Write for x that occurs before the Read. By
inspection of the code, the writeList of T is updated each time T invokes Write for x by either
adding x and the value written for it into T ’s writeList (line 37) if x is not already in the list, or
by replacing the previous value for x in T ’s writeList with the currently written value (line 36)
otherwise. It follows that when a non-global Read for x by T executes line 27 it observes in T ’s
writeList the latest value written so far for x by T and it returns this value. Since each Read in
Trw is non-global, it follows that Trw is legal in Hσα .
We continue to prove that transaction Tд is legal in Hσα . Consider any data item x read in Tд.
Assume first that there is an invocation of Write for x by some transaction that precedesTд inHσα
and let T 
rw be the last such transaction. By the definitions of Hσα and T 
rw , T 
rw contains the same
sequence of Write t-operations as some transaction T  ∈ com(α) such that Cw (T 
) < Cr (T ) and
there is no transactionT  ∈ com(α) such thatCw (T 
) < Cw (T ) < Cr (T ). By Lemma 5.3, it follows
that vx (Cw (T 
)) = vx (Cr (T )). By Lemma 5.2, it follows that vx (Cw (T 
)) = nvx (T 
) = vx (Cr (T )).
By Corollary 5.7 and the definition of nvx (T 
), it follows that each global Read for x in T returns
the latest value written to x by T 
. Since each Read in Tд is global, it follows that each Read for x
in Tд returns the latest value written to x by T 
rw .
Assume now that there is no invocation of Write for x by some transaction that precedes Tд
in Hσα . Let Cr be the instance of Create that creates x in ϕ(C0, α) and let Cx be the configuration
immediately after the assignment (line 12) of the initial value of x to the newValue field of the
locator pointed to by locx (Cx ) during the execution of Cr. By inspection of the code (line 10),
locx (Cx )→transaction = null at Cx . Therefore, the definition of vx (Cx ) implies that vx (Cx ) has
the value that locx (Cx )→newValue has at Cx , which is the initial value of x. Because there is no
transaction that writes x and executes line 56 with its pendinдStatus being equal to Committed
between Cx and Cr (T ), Lemma 5.3 implies that vx (Cx ) = vx (Cr (T )). By Corollary 5.7, it follows
that every instance of GetCurrentValue for x by T returns vx (Cx ), the initial value of x. Therefore,
every Read for x by Tд returns the initial value of x.
By Lemma 5.8 and Definition 3.2, it follows that α satisfies R/W-independent snapshot isolation.
We conclude that SI-DSTM satisfies R/W-independent snapshot isolation.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018. 
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:59
5.1.2 Liveness. In this section, we prove that SI-DSTM is obstruction-free. Consider any execution α.
Lemma 5.9. Let T be a transaction that executes solo in α and let W r be an instance of Write
invoked by T in α. If T executes a CAS primitive on line 50 in W r, then this CAS is successful.
Proof. T initializes oldLoc on line 38 ofW r by setting it to be equal to di→start. By inspection
of the code, it follows that between its initialization on line 38 and the CAS primitive on line 50,
oldLoc is not changed by T . Because T executes solo, it follows that di→start cannot be changed
by other transactions. Thus, when T executes the CAS primitive on line 50, oldLoc and di→start
have the same value, and therefore the CAS is successful.
We are now ready to prove that SI-DSTM ensures obstruction-freedom.
Theorem 5.10. SI-DSTM is obstruction-free.
Proof. LetT be a transaction in α that does not invoke Abort and executes solo in ϕ(C0, α). We
first prove that T is not aborted in ϕ(C0, α). By inspection of the code, it follows that trT →status
can be set to aborted, either on line 48 or on line 54.
We first argue that trT →status cannot be set to aborted on line 48. Notice that T sets
trT →pendinдStatus to be equal to Committed on line 3 (when T initializes trT ). We argue that,
from that point on and untilT completes its execution, no instance of Write executes line 48 with
oldT r being equal to trT . Since no other process takes steps during the execution interval of T , it
suffices to prove that T never executes line 48 with oldT r being equal to trT .
To derive a contradiction, assume that this is not so. Let W r be the first instance of Write in
which T executes line 48 with oldT r being equal to trT , and let x be the data item for which W r
is invoked. Lemma 5.9 implies that whenever T executes the CAS primitive of line 50, it does so
successfully. By inspection of the code, it follows that line 52 is never executed during the execution
ofW r (and therefore line 48 is executed just once during the execution ofW r). Therefore, the value
of oldLoc is always that read by T on line 38 during the execution of W r.
Denote by C the configuration preceding the execution of line 48 in W r by T , and let C be the
configuration preceding the execution of line 38 inW r byT . By executing line 38,T readslocx (C
)
and stores it in the local variable oldLoc ofW r. Since T executes solo and locx (C
)→transaction =
trT , inspection of the code implies that the locator pointed to by locx (C
) was created either in
the previous (to W r) instance of Write for x executed by T or in an instance of Create for x. In
either case, Observation 1 implies that the value of locx (C
)→transaction does not change after
its initiation (which occurred either on line 10 or on line 43). Since locx (C
)→transaction = trT ,
T evaluates the condition of the i f statement on line 39 to true and returns on line 41, before
executing line 48. This contradicts the definition of W r.
We now argue that T is not aborted on line 54. To derive a contradiction, assume that this is not
so. Then, T executes an instance V of ValidateReadList that returns false. Let x be the last data
item accessed in the f or loop of line 22 in V and let G be the last instance of GetCurrentValue
initiated by V that had dix→start as its argument. Lemma 5.5 implies that there exists a configuration C such that G returns vx (C) and this configuration is between the read of the argument
for G and the response of G. Since T executes solo, there is no other transaction T  such that T 
executes line 56 with its pendinдStatus being equal to Committed and Cf < Cw (T 
) ≤ C. Hence,
Lemma 5.3 implies that vx (C) = vx (Cf ), i.e., vx (C) has the same value as the value returned by
Gf .
Since x is a data item accessed in the f or loop of line 22 in V , it follows that x is in the readList
of T when V is invoked, and therefore there is an instance R of a global Read for x by T that adds
x to the readList of T on line 31. By inspection of the code, R executes line 31 only if x was not
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018. 
2:60 V. Bushkov et al.
in the readList of T (this is so because of the check on line 30). Therefore, R is the first instance
of Read for x by T . It follows that the instance of GetCurrentValue executed on line 29 in R is Gf .
When T executes line 31 in R, it adds x together with vx (Cf ) to the readList of T . By inspection of
the code, V returns false only if currentValue  val on line 24, where currentValue is the value
of x returned by G that is equal to vx (C), and val is the value of x stored in the readList in R that
is equal to vx (Cf ). This contradicts the fact that vx (C) = vx (Cf ).
We finally prove thatT does not take infinitely many steps to perform a t-operation. Notice that
the only t-operation that contains a while loop is Write, so this is the only t-operation whose
execution could take infinitely many steps. Since T executes solo in ϕ(C0, α), Lemma 5.9 implies
that the first timeT executes a CAS on line 50, the CAS succeeds. Thus,T returns on line 51, without
executing the body of the loop more than once. This implies that all Write executed by T always
terminate within a finite number of steps.
5.1.3 Disjoint Access Parallelism.
Theorem 5.11. SI-DSTM is r-strictly disjoint-access-parallel.
Proof. Let α be any execution of SI-DSTM, and let T1 and T2 be two transactions in α that
contend on some base object o. Notice that the read set and the write set of a transaction T can be
accessed only byT , and so o cannot be a variable used to implement trTi .readList ortrTi .writeList,
i ∈ {1, 2}.
Without loss of generality, assume that T1 applies a non-trivial primitive on o. We consider the
following cases:
(1) Assume first that o = dix→start for some data item x. By inspection of the code, it follows
thatT1 applies a non-trivial primitive on dix→start either on line 14 during the execution
of Create for x, or on line 50 during the execution of a Write for x. In either case, T1
invokes a t-operation that creates or writes x.
IfT2 applies a non-trivial primitive on dix→start, then we can use a similar argument to
derive thatT2 invokes a t-operation that creates or writes x. Therefore,T1 andT2 w-conflict
on data item x.
Assume that T2 does not apply a non-trivial primitive on dix→start. By inspection of
the code, it follows that T2 may apply a trivial primitive on dix→start in the following
cases:
• on line 23 during the validation of x, which was previously read by T2,
• on line 29 when dix→start is passed as the argument of GetCurrentValue during the
execution of Read t-operation for x by T2,
• on line 38 during the execution of Write t-operation for x by T2,
• on line 52 during the execution of Write t-operation for x by T2.
In all cases, T2 either reads or writes x. Therefore, T1 and T2 w-conflict on data item x.
(2) Assume next that o = dix→start→oldV alue for some data item x. By inspection of the
code, it follows that T1 applies a non-trivial primitive on dix→start→oldValue either on
line 11, during the execution of Create for x, or on line 49, during the execution of a
Write for x. In either case, T1 invokes a t-operation that creates or writes x.
If T2 applies a non-trivial primitive on dix→start→oldV alue, then we can use a similar
argument to derive that T2 invokes a t-operation that creates or writes x. Therefore, T1
and T2 w-conflict on data item x.
Assume that T2 does not apply a non-trivial primitive on dix→start→oldV alue.
By inspection of the code, it follows that T2 may apply a trivial primitive on dix→
start→oldValue only on line 21 to find the response of an instance of GetCurrentValue.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.  
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:61
By inspection of the code, it follows that GetCurrentValue is invoked either on line 23
(during the validation of x, which was previously read by T2), or on line 29, or on line 49.
In all cases, it follows that T2 reads or writes x. Therefore, T1 and T2 w-conflict on data
item x.
(3) Assume now that o = dix→start→newValue for some data item x. By inspection of the
code,T1 applies a non-trivial primitive on dix→start→newValue either on line 12, during
the execution of Create for x, or on lines 40 or 44, during the execution of a Write for
x. In either case, it follows that T1 invokes a t-operation that creates or writes x.
IfT2 applies a non-trivial primitive on dix→start→newValue, then we can use a similar
argument to derive thatT2 invokes a t-operation that creates or writes x. Therefore,T1 and
T2 w-conflict on data item x.
Assume that T2 does not apply a non-trivial primitive on dix→start→newValue.
By inspection of the code, it follows that T2 may apply a trivial primitive on
dix→start→newValue only on line 20 to find the response of an instance of GetCurrentValue. By inspection of the code, it follows that GetCurrentValue is invoked either on
line 23 (during the validation of x, which was previously read by T2), or on line 29, or on
line 49. In all cases, it follows that T2 reads or writes x. Therefore, T1 and T2 w-conflict on
data item x.
(4) Assume next that o = dix→start→transaction for some data item x. By inspection of the
code, it follows that T1 applies a non-trivial primitive on dix→start→transaction either
on line 8, during the execution of Create for x, or on line 43, during the execution of
Write for x. In either case, T1 invokes a t-operation that creates or writes x.
If T2 also applies a non-trivial primitive on dix→start→transaction, then we can use
the same argument to show thatT2 invokes a t-operation that accesses data item x, which,
in turn, implies that T1 and T2 w-conflict on data item x.
Assume that T2 does not apply a non-trivial primitive on dix→start→transaction.
By inspection of the code, it follows that T2 can apply a trivial primitive on
dix→start→transaction in the following cases:
• on line 19 during an instance of GetCurrentValue, which is invoked either on line 23
(during the validation of x, which was previously read byT2), or on line 29, or on line 49;
thus, in all cases T2 performs either an instance of Read or an instance of Write for x,
• on line 39 or 46 during the execution of Write for x.
In all cases, T2 either reads or writes x. Therefore, T1 and T2 w-conflict on data item x.
(5) Assume now that o = trT →status for some transaction T . By inspection of the code, it
follows that only transaction T can apply non-trivial primitives on trT →status. By assumption, T1 applies a non-trivial primitive on o. Thus, T = T1 and T2 does not apply a
non-trivial primitive on trT1→status.
By inspection of the code, T2 applies a trivial primitive on trT1→status either
• on line 19 during the execution of an instance of GetCurrentValue, which has been
called either by an instance of Read for a data item x on line 29, or by an instance of
Write for a data item x on line 49, or on line 23 by the instance of ValidateReadList
executed by T2 (and T2 has previously read x),
• or on line 47, during the execution of an instance of Write for a data item x.
Therefore, T2 reads or writes x. It also follows that T2 may access trT1→status only
when trT1 is referenced by dix→start→transaction. By inspection of the code, it follows
that this cannot occur if T1 has not successfully executed the CAS of line 50 during the
execution of an instance of Write for x. It follows that T1 writes x and T2 reads or writes
x. Therefore, T1 and T2 w-conflict on x.
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.
2:62 V. Bushkov et al.
(6) Assume finally that o = trT →pendinдStatus for some transaction T . We consider the following cases:
• Let T = T1 or T = T2. Without loss of generality, assume that T = T1 (the case where
T = T2 is symmetric). By inspection of the code, T1 may access trT1→pendinдStatus
only when it executes line 3 or line 56. Moreover, T2 may access trT1→pendinдStatus
only when it executes line 48 during the execution of an instance of Write for x. Thus,
T2 writes x. Moreover, by inspection of the code, it follows that T2 executes line 48 only
if trT1 is referenced by some dix→start→transaction for some data item x, and this
cannot occur if T1 has not successfully executed the CAS of line 50 during the execution
of an instance of Write for x. Thus, T1 also writes x. Therefore, T1 and T2 w-conflict on
data item x.
• Let T = T3, where T3 is some transaction other than T1 and T2. Following a similar argument as in the previous case (withT3 playing the role ofT1), we derive that there exists a
data item y such that T2 writes y and T2 and T3 w-conflict on y. Similarly, if T3 plays the
role of T1 and T1 plays the role of T2, we derive that there exists a data item x such that
T1 writes x and T1 and T3 w-conflict on x. Since T1 writes x and T2 writes y, it follows
that both T1 and T2 are update transactions.
Both T1 and T2 access trT3→pendinдStatus on line 48. By inspection of the code, it follows that bothT1 andT2 read Active fortrT3→status on line 47. Thus,T3 was live when
T1 or T2 executed line 47. It follows that the execution interval of T3 overlaps with the
execution interval of T1, as well as with the execution interval of T2. It follows that
the execution interval of T3 overlaps with the minimal execution interval of T1 and T2.
Hence, T3 is in the w-conflict graph G of the minimal execution interval of T1 and T2.
Because T3 w-conflicts with both T1 and T2, it follows that there is a path between T1
and T2 in G.
By inspecting the cases above, we conclude that if at least one of the T1 and T2 is a read-only
transaction, thenT1 andT2 w-conflict. However, if bothT1 andT2 are update transaction, then they
either w-conflict or there is a path betweenT1 andT2 in the w-conflict graph of the minimal execution interval of T1 and T2. It follows that SI-DSTM ensures r-strict disjoint-access-parallelism.
5.2 Weakening Consistency
In this section, we explore the limits of the PCL theorem in whatever concerns consistency. Specifically, we present a weaker consistency condition S than weak adaptive consistency, and we present
a trivial obstruction-free TM algorithm that ensures S and strict disjoint-access-parallelism.
Definition 5.12. A finite execution α satisfies S if it is possible to do all of the following:
• choose a consistency partition P (α),
• partition all groups in P (α) into two disjoint sets of groups: a set SI (P (α)) of snapshot isolation groups and a set PC(P (α)) of processor consistency groups,
• choose a set com(α) consisting of all committed and some of the commit-pending transactions in α, and
• for each processpi , insert (in α) a global read serialization point ∗i
T,д
and a write serialization
point ∗i
T,w , for each transaction T ∈ com(α), so that if σi
α is the sequence defined by these
serialization points, the following holds:
(1) ∗i
T,д precedes ∗i
T,w in σi
α ,
(2) for each group G(Tl,k ,Tr,k ) ∈ SI (P (α)) the following holds: for each T ∈ G(Tl,k ,Tr,k ) ∩
com(α), both ∗i
T,д
and ∗i
T,w are inserted within the active execution interval of T ,
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018. 
The PCL Theorem: Transactions cannot be Parallel, Consistent, and Live 2:63
(3) for each group G(Tl,k ,Tr,k ) ∈ PC(P (α)) the following holds: for each T ∈ G(Tl,k ,Tr,k ) ∩
com(α), no other serialization point is inserted between ∗i
T,д
and ∗i
T,w and both ∗i
T,д
and
∗i
T,w are inserted within the active execution interval of G(Tl,k ,Tr,k ),
(4) if Hσi
α is the history we get if, for each T ∈ com(α), we replace each ∗i
T,д
with H|Tд and
each ∗i
T,w with H|Tw in σi
α , then every transaction executed by pi is legal in Hσi
α .
Note that the only difference between weak adaptive consistency and S is that S does not require
two transactions that write to the same data item to appear in the same order in the sequences
defined by the assigned serialization points for each process.
Consider an algorithm A that does not use any shared memory primitives. Instead, in A, every
process has a copy of each data item in its local space and works entirely with these local copies.
Specifically, to perform a write t-operation for a data item x, each process pi updates its local copy
of x. Similarly, to perform a read t-operation for x, pi reads from its local copy of x. Moreover, the
execution of commit is trivial: the algorithm simply returns CT for each commit invoked by any
transaction T .
Consider any execution α of A. Since no pair of steps ever contend in α, A trivially satisfies strict
disjoint-access-parallelism and it is wait-free, i.e., it guarantees that each transaction commits after
the process initiating it has executed a finite number of steps. Wait-freedom is a stronger liveness
property than obstruction-freedom, and therefore A is also obstruction-free.
To prove that A satisfies S, let P (α) consist only of one processor consistency group G, so that
every transaction in α belongs to G and the execution interval of G is the entire execution. Let
com(α) be such that it consists only of transactions that commit in α. Consider some process pi
and the following sequence σi
α of serialization points:
• for eachT ∈ com(α), ∗i
T,д precedes ∗i
T,w and no other serialization point is inserted between
∗i
T,д
and ∗i
T,w ,
• for each pair T1 and T2 of transactions executed by pi , if T1 precedes T2 in α, then ∗i
T,w
precedes ∗i
T,д,
• let Ti
 be the transaction in com(α) that is executed last by pi . Then, for every process pj ,
j  i, and every transaction T j ∈ com(α) that is executed by pj , ∗T i
l ,w precedes ∗T j,д.
Notice that in σi
α , the serialization points of the transactions executed by process pi appear in
the order they were initiated by pi and occur before the serialization points of any transaction
initiated by every other process.
Since each transaction T executed by pi observes only those changes that have been performed
by transactions that pi initiated before T , it follows that every transaction executed by pi in Hσi
α
is legal.
5.3 Weakening Liveness
A TM algorithm is blocking if a process p may have to wait for another process to take an action
(e.g., to release a lock) in order for p to make progress with the execution of its currently live
transaction. Lock-based TM algorithms are blocking.
Remarkably, the use of locks allows the design of a TM algorithm that satisfies strong versions
of disjoint-access-parallelism and consistency. For example, a simplified version of TinySTM [23],
presented in Reference [31], ensures opacity and strict disjoint-access-parallelism. It also guarantees strong progressiveness, a liveness property that requires that (1) if a transaction does
not conflict with any other concurrent transaction, then it is not aborted and (2) if a group of
Journal of the ACM, Vol. 66, No. 1, Article 2. Publication date: December 2018.  
2:64 V. Bushkov et al.
concurrent transactions conflict on a single data item only, then not all of them are aborted. We
remark that strong progressiveness is incomparable to obstruction-freedom.
The TM algorithm of Reference [31] uses strong try-locks, i.e., locks in which an invocation for
acquiring the lock returns true if the lock is successfully acquired and f alse if the lock is held
by another process; moreover, these locks guarantee that among processes trying to concurrently
acquire a lock at least one succeeds in doing so.
The intuition behind the algorithm is the following. Each data item x is protected by such a
try-lock. When a transaction T wants to write a data item x, it tries to acquire the try-lock for x
and if it fails, it aborts. Otherwise, it marks x as locked, stores the original state of x to the local
memory of the process initiating T , and updates the state of x. The locks held by T are released
when T commits or aborts. If T aborts, then all its changes are rolled back by using the original
state of each data item inT ’s write set, which is stored in the local memory of the process initiating
T .
When a transactionT wants to read a data item x, it checks if x is locked by another transaction.
If this is not the case, then T reads the current state of x and validates its read set by checking if
each data item contained in it has not changed since the first time it was read byT . If the validation
is successful, then T returns the state of x it read before the validation. Otherwise, T aborts.
In the algorithm of Reference [31], each transaction T accesses only those base objects that are
associated with data items contained in T ’s data set. Thus, two transactions that access different
sets of data items in an execution, never contend on the same base object. Thus, the algorithm is
strictly disjoint-access-parallel. The way locks are used ensure opacity and strong progressiveness.
Other examples of lock-based TM algorithms that ensure strict disjoint-access-parallelism and
strict serializability are TL [19] and PermiSTM [10].
6 CONCLUSION
We proved the PCL theorem: it is impossible to design a TM algorithm that ensures c-disjointaccess-parallelism (Parallelism), weak adaptive consistency (Consistency), and obstructionfreedom (Liveness). We also explored the limits of this impossibility result in all its different requirements. Weakening of liveness by considering a blocking version of strong progressiveness,
makes it possible [31] to ensure strict disjoint-access-parallelism and a strong consistency property such as opacity. Likewise, considering a weaker version of consistency makes it possible to
ensure strict disjoint-access-parallelism and strong liveness in a trivial way. Finally, considering
a weaker version of parallelism, which allows update transactions to ensure a weaker disjointaccess-parallelism property results in TM algorithms that ensure obstruction-freedom and snapshot isolation.
In the design of TM algorithms, the PCL theorem draws a sharp line between the properties of cdisjoint-access-parallelism, weak adaptive consistency and obstruction-freedom, and their weaker
variants. Our theorem might, at a first glance, look related to the CAP theorem [26], which states
that it is impossible to ensure consistency, availability, and partition in a distributed system. In
fact, the PCL and the CAP theorem are different results. While consistency can be viewed as a
safety property, and availability can be viewed as a liveness property, partition is not analogous to
disjoint-access-parallelism. Specifically, partition tolerance ensures that the system tolerates arbitrary network partitions. Disjoint-access-parallelism, however, does not ensure tolerance against
failures but imposes that logical components of a system (such as transactions) do not contend
at low level (i.e., on base objects) if they do not conflict at high level (i.e., do not access the same
data items). What is common between the CAP theorem and the PCL theorem, though, is the fact
that weakening any of the requirements in both theorems makes the impossibility result no longer
hold.