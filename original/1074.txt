We define and investigate Frege systems for quantified Boolean formulas (QBF). For these new proof systems,
we develop a lower bound technique that directly lifts circuit lower bounds for a circuit class C to the QBF
Frege system operating with lines from C . Such a direct transfer from circuit to proof complexity lower
bounds has often been postulated for propositional systems but had not been formally established in such
generality for any proof systems prior to this work.
This leads to strong lower bounds for restricted versions of QBF Frege, in particular an exponential lower
bound for QBF Frege systems operating with AC0[p] circuits. In contrast, any non-trivial lower bound for
propositional AC0[p]-Frege constitutes a major open problem.
Improving these lower bounds to unrestricted QBF Frege tightly corresponds to the major problems in
circuit complexity and propositional proof complexity. In particular, proving a lower bound for QBF Frege
systems operating with arbitrary P/poly circuits is equivalent to either showing a lower bound for P/poly or
for propositional extended Frege (which operates with P/poly circuits).
We also compare our new QBF Frege systems to standard sequent calculi for QBF and establish a correspondence to intuitionistic bounded arithmetic.
CCS Concepts: • Theory of computation → Proof complexity; Circuit complexity; Complexity theory
and logic;
Additional Key Words and Phrases: QBF proof complexity, Frege systems, sequent calculus, intuitionistic
logic, strategy extraction, lower bounds, simulations
1 INTRODUCTION
Proof complexity investigates how difficult it is to prove theorems in different formal systems.
The main question asks, given a formula φ and a proof system P, typically composed of axioms
and rules, what is the size of the smallest proof of φ in P? This question bears tight and fruitful
relations to a number of further areas, in particular to computational complexity, where lower
bounds to the size of proofs offer an approach towards the separation of complexity classes (Cook’s
Programme) and to first-order logic (bounded arithmetic theories and their separations). More
recently, the tremendous success of SAT solving has been a main driver for proof complexity, as
the analysis of proof systems underlying SAT solvers provides the main theoretical framework
towards understanding the power and limitations of solving, cf. the survey by Buss [2012].
The bulk of research in proof complexity has concentrated on proof systems for classical propositional logic. Regarding the central question above, propositional proof complexity has made enormous progress over the past three decades in showing tight lower and upper bounds for many principles in various proof systems. Arguably even more important, a number of general lower bound
techniques have been developed that can be employed to show lower bounds to the size of proofs.
These include the seminal size-width relationship by Ben-Sasson and Wigderson [2001], the feasible interpolation technique of Krajíček [1997], or game-theoretic techniques (cf. the overview in
Beyersdorff and Kullmann [2014]).
Notwithstanding these advances, some of the most natural proof systems have resisted all attempts for lower bounds for decades. Frege systems (also known as Hilbert-type systems) are the
typical textbook calculi composed of axiom schemes and rules, and no non-trivial lower bounds are
known for Frege. While the power of Frege does not depend on the choice of axioms or rules [Cook
and Reckhow 1979], their strength can be calibrated by restricting the class of allowed formulas.
In particular, a hierarchy of Frege systems can be obtained by considering Boolean circuits of
increasing strength as lines in Frege. These circuit classes compose the standard non-uniform
classes: AC0, which is the class of Boolean functions computed by families of polynomial-size
constant-depth circuits with unbounded fan-in; AC0[p], which is similar to AC0 but allows modp gates; and TC0, which additionally allows threshold gates. Even stronger, NC1 is composed of
the class of Boolean functions computed by families of polynomial-size logarithmic-depth circuits
with bounded fan-in and P/poly of functions with polynomial-size circuits in general. For uniform
families of circuits, one further imposes the condition that the circuit family can be generated
efficiently. Here, we typically consider non-uniform families, where we just require existence of the
family of small circuits as above. This is analogous to the non-uniform model in proof complexity,
where again only the existence of small proofs for a sequence of formulas is required. The circuit
classes are ordered as AC0 ⊂ AC0[p] ⊂ TC0 ⊆ NC1 ⊆ P/poly, giving rise to a similar hierarchy of
Frege systems.
While the strongest non-uniform lower bounds known in circuit complexity hold for the class
AC0[p] [Razborov 1987; Smolensky 1987], AC0-Frege is the strongest of the above Frege systems
with non-trivial lower bounds [Ajtai 1994; Krajíček et al. 1995; Pitassi et al. 1993]. Despite enormous efforts, all attempts to transfer Razborov’s and Smolensky’s AC0[p] circuit lower to a proof
size lower bound in AC0[p]-Frege have failed so far. More widely, it seems the common belief in
the proof complexity community that substantial progress in circuit complexity would also give
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.
Frege Systems for Quantified Boolean Logic 9:3
rise to major new lower bounds in proof complexity, for Frege (= NC1-Frege) or even extended
Frege (EF = P/poly-Frege). Though this connection has been often postulated (cf. e.g., Beame and
Pitassi [2001]), it could never have been made formal so far.
In this article, we establish a technique to transfer circuit lower bounds to proof size lower
bounds for proof systems for Quantified Boolean Formulas (QBF). Our technique lifts arbitrary
circuit lower bounds to proof size bounds for QBF Frege systems, yielding in particular exponential
lower bounds for AC0[p]-Frege for QBFs via Razborov [1987] and Smolensky [1987].
Before explaining our results in more detail, we discuss recent developments in QBF proof complexity.
QBF proof complexity is a relatively young field studying proof systems for quantified Boolean
logic. Similarly as in the propositional case, one of the main motivations for the field comes via its
intimate connection to solving. SAT and QBF solvers are powerful algorithms that efficiently solve
the classically hard problems of SAT and QBF for large classes of practically relevant formulas,
with modern solvers routinely solving industrial instances in millions of variables for various
applications. Although QBF solving is at an earlier state, due to its PSPACE completeness, QBF
even applies to further fields such as formal verification or planning [Benedetti and Mangassarian
2008; Egly et al. 2017; Rintanen 2007].
The connection to proof complexity comes from the fact that each successful run of a solver on
an unsatisfiable instance can be interpreted as a proof of unsatisfiability; and modern SAT and QBF
solvers (that are sound and complete) are known to correspond to the resolution proof system and
its variants. In comparison to SAT, the picture is more complex in QBF, as there exist two main solving approaches: utilizing CDCL (Conflict-Driven Clause Learning) and expansion-based solving.
To model the strength of these QBF solvers, a number of resolution-based QBF proof systems have
been developed. Q-resolution (Q-Res) by Kleine Büning et al. [1995] forms the core of the CDCLbased systems. To capture further ideas from CDCL solving, Q-Res has been augmented to longdistance resolution by Balabanov and Jiang [2012], universal resolution QU-Res by Van Gelder
[2012], and their combinations [Balabanov et al. 2014]. QBF resolution systems for expansionbased solving were developed by Janota and Marques-Silva [2015] and Beyersdorff et al. [2014].
Recent progress led to a complete understanding of the relative power of all these resolution-type
QBF systems [Balabanov et al. 2014; Beyersdorff et al. 2015; Janota and Marques-Silva 2015].
From a proof complexity perspective, resolution is considered a weak system, witnessed by the
wealth of resolution lower bounds (cf. Segerlind [2007] for a survey); and the same classification
applies to all of the QBF resolution calculi mentioned above, not only due to their reliance on the
weak propositional resolution system, but also because of weak instantiations when dealing with
quantifiers.
In addition to these weak QBF systems, there exists a number of very strong sequent calculi
[Cook and Morioka 2005; Egly 2012; Krajíček and Pudlák 1990] as well as the general proof checking format QRAT [Heule et al. 2017].
However, compared to propositional proof complexity, a number of other approaches is yet
missing in QBF. In particular, algebraic systems such as polynomial calculus [Clegg et al. 1996] or
systems based on integer programming as cutting planes [Cook et al. 1987] have received great
attention in recent years in propositional proof complexity. These systems are interesting, as they
are of intermediate strength: stronger than resolution, but weaker than Frege. No analogues of
these systems had been considered in QBF prior to the conference paper [Beyersdorff et al. 2016a]
underlying this article; and even a QBF version of the propositional Frege hierarchy mentioned
above has not been considered before. Building on our work here, the recent paper [Beyersdorff
et al. 2018] investigates an analogue of the cutting planes proof system for QBF and Beyersdorff
et al. [2019] contains further work in this direction.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.
9:4 O. Beyersdorff et al.
1.1 Summary of Results
Below, we summarize our main contributions of this article, sketching the main results and techniques.
A. From propositional to QBF: new QBF proof systems. We exhibit a general method how to
transform a propositional proof system to a QBF proof system. Our method is both conceptually
simple and elegant. Starting from a propositional proof system P composed of axioms and rules,
we design a system P + ∀red for closed prenex QBFs (Definition 3.1). Throughout the proof, the
quantifier prefix is fixed, and lines in the systemP + ∀red are conceptually the same as lines in P, i.e.,
clauses in resolution, circuits from C in C -Frege (where C is AC0, AC0[p], TC0, NC1, or P/poly), or
inequalities in cutting planes. Our new systemP + ∀red uses all the rules fromP and can apply those
on arbitrary lines, irrespective of whether the variables are existentially or universally quantified.
To make the system complete, we introduce a ∀red rule that allows to replace universal variables by
simple Herbrand functions, which can be represented as lines in P. The link to Herbrand functions
provides a clear semantic meaning for the ∀red rule, resulting in a natural and robust system
P + ∀red.
Our new systems P + ∀red are inspired by the approach taken in the definition of Q-Res [Kleine
Büning et al. 1995]; and, indeed, when choosing resolution as the base system P, our system
P + ∀red coincides with the previously studied QU-Res [Van Gelder 2012]. While our definitions
are quite general and yield for example previously missing QBF versions of polynomial calculus or
cutting planes, we concentrate here on exploring the hierarchy C -Frege + ∀red of new QBF Frege
systems.
B. From circuit to QBF lower bounds: a general technique. As mentioned above, it is a longstanding belief that circuit lower bounds correspond to proof size lower bounds, and clearly some
of the strongest lower bounds in proof complexity as those for AC0-Frege are inspired by proof
techniques in circuit complexity, cf. the survey of Beame and Pitassi [2001]. Here, we give a precise and formal account on how any circuit lower bound for C can be directly lifted to a proof size
lower bound in C -Frege + ∀red.
Conceptually, our lower bound method uses the idea of strategy extraction, an important paradigm in QBF (Theorem 4.3). Semantically, a QBF can be understood as a game between a universal
and an existential player, where the universal player wins if and only if the QBF is false. Winning
strategies for the universal player can be very complex. However, we show that from each refutation of a false QBF in a system C -Frege + ∀red, we can efficiently extract a winning strategy for
the universal player in a simple computational model we call C -decision lists. We observe that C -
decision lists are easy to transform into C circuits itself, with only a slight increase in complexity.
To obtain a proof-size lower bound, we need a function f that is hard for C . From f , we construct
a family Q-fn of false QBFs such that each winning strategy of the universal player on Q-fn has
to compute f . By strategy extraction, refutations of Q-fn in C -Frege + ∀red yield C -circuits for f ;
hence, all such refutations must be long. In fact, we even show the converse implication to hold,
i.e., from small C -circuits for f , we construct short proofs of Q-fn in C -Frege + ∀red.
Our lower bound technique widely generalizes ideas recently used by Beyersdorff et al. [2015]
to show lower bounds for Q-Res and QU-Res for formulas originating from the Parity function.
C. Lower bounds and separations: applying our framework. We apply our proof technique to
a number of famous circuit lower bounds, thus obtaining lower bounds and separations for
C -Frege + ∀red systems that are yet unparalleled in propositional proof complexity. The following
results are contained in Section 5.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.
Frege Systems for Quantified Boolean Logic 9:5
C.(i) Lower bounds and separations for the QBF proof system Frege AC0[p] + ∀red. The seminal
results of Razborov [1987] and Smolensky [1987] showed that Parity and more generally MODq
are the classic examples for functions that require exponential-size bounded-depth circuits with
MODp gates, where p and q are different primes. Using these functions, we define families of QBFs
that require exponential-size proofs in Frege AC0[p] + ∀red by strategy extraction.
To obtain separations of these proof systems, the exact formulation of the QBFs matters. When
defining the Parity or MODq formulas directly from (arbitrary) NC1-circuits computing these
functions, we obtain polynomial-size upper bounds in Frege + ∀red. However, when carefully
choosing specific and indeed very natural encodings, we can prove upper bounds for the MODq
formulas even in Frege AC0[q] + ∀red, thus obtaining exponential separations of all the Frege
AC0[p] + ∀red systems for distinct primes p.
As mentioned before, lower bounds for AC0[p]-Frege (as well as their separations) are major
open problems in propositional proof complexity.
C.(ii) Separating Frege AC0[p] + ∀red and Frege TC0 + ∀red. Majority is another classic function
in circuit complexity, for which exponential lower bounds are known for constant-depth circuits
with MODp gates for each prime p [Razborov 1987; Smolensky 1987]. Using our technique, we
transfer these to lower bounds in Frege AC0[p] + ∀red for all primes p. Carefully choosing the QBF
encoding of Majority, we obtain polynomial upper bounds for the Majority formulas in Frege
TC0 + ∀red, thus proving an exponential separation between the two QBF proof systems Frege
AC0[p] + ∀red and Frege TC0 + ∀red. Again, such a separation is wide open in propositional proof
complexity.
C.(iii) CNFs separating the Frege AC0
d + ∀red hierarchy. As a third example for our approach, we
investigate the fine structure of Frege AC0 + ∀red, composing all Frege AC0
d + ∀red systems, where
all formulas in proofs are required to have at most depth d for a fixed constant d. Resolution is
an important example of such a system for depth d = 1.1 In circuit complexity the Sipserd functions from Boppana and Sipser [1990] provide an exponential separation of depth-(d − 1) from
depth-d circuits [Håstad 1986]. With our technique, this separation translates into a separation of
Frege AC0
d−3 + ∀red from Frege AC0
d + ∀red, where the increased gap of size 3 comes from our
transformation of C -decision lists into C -circuits.
The Sipserd formulas achieving these separations are prenexed CNFs, i.e., the formulas each
have a matrix of depth 2. While in propositional proof complexity the hierarchy of AC0
d -Frege
systems is exponentially separated [Ajtai 1994; Krajíček et al. 1995; Pitassi et al. 1993], such a
separation by formulas of depth independent of d is a major open problem.
C.(iv) Characterizing lower bounds for QBF Frege. The main question left open by the results
described above is whether unconditional lower bounds can be obtained for Frege + ∀red or even
EF + ∀red. We show that such a result would imply either a major breakthrough in circuit complexity (a lower bound for non-uniform NC1 or even P/poly) or a major breakthrough in propositional
proof complexity (lower bounds for classical Frege or even EF); and in fact the opposite implications hold as well (Theorem 5.13).
This means that the problem of lower bounds for QBF Frege very naturally unites the central problem in circuit complexity with the central problem in proof complexity. Conceptually
this is very interesting: The direct connection between progress in circuit complexity and proof
complexity, which has often been postulated (cf. Beame and Pitassi [2001]), directly manifests in
Frege + ∀red, thus highlighting that Frege + ∀red is indeed a natural and important system.
1Although CNF formulas have depth 2, it is customary to consider Resolution being of depth d = 1, as it handles CNF
formulas as sets of clauses, i.e., sets of objects of depth d = 1.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.
9:6 O. Beyersdorff et al.
Fig. 1. The simulation order of QBF Gentzen and Frege systems.
Technically, this result uses a normal form that we achieve for Frege + ∀red proofs: these can
be decomposed into a classical Frege proof followed by a number of ∀red steps (Theorem 4.5). We
further show that even ∀red steps suffice that only substitute constants (Theorem 4.7).
D. Gentzen vs. Frege in QBF: simulations and separations. In classical proof complexity, Frege and
Gentzen’s sequent system LK are p-equivalent, i.e., proofs can be efficiently translated between
the systems [Cook and Reckhow 1979]. In contrast, our findings show a more complex picture for
QBF, induced by the weak methods for handling (universal) quantifiers. We concentrate on the
most important standard Gentzen-style systems G0 and G1 of Cook and Morioka [2005] as well as
the QBF Frege systems Frege + ∀red and EF + ∀red. The indices in G0 and G1 refer to the quantifiers
complexity of formulas allowed in cuts, cf. Section 6.1.1.
For these four systems, the following picture emerges (cf. Figure 1): We prove that tree-like G1
p-simulates EF + ∀red (Theorem 6.4) and tree-like G0 simulates Frege + ∀red under a relaxed notion of p-simulation (Theorem 6.6). However, the converse simulations are unlikely to hold. Under standard complexity-theoretic assumptions, we show that EF + ∀red is strictly weaker than
tree-like G1 (Theorems 6.8, 6.10). Moreover, EF + ∀red is incomparable to both tree-like G0 and G0
(Theorems 6.11, 6.7). Hence, unlike in the propositional framework, Gentzen appears to be stronger
than Frege in QBF.
While all these separations make use of complexity-theoretic assumptions, it will be hard to
improve these results to unconditional lower bounds (see C.(iv) above). However, since we use
a number of different and indeed partly incomparable assumptions, our separations seem very
plausible.
E. QBF Frege corresponds to intuitionistic logic. The strongest tool for an understanding of classical Frege as well as propositional and QBF Gentzen systems comes from their correspondence
to bounded arithmetic [Cook and Nguyen 2010; Krajíček 1995]. Here, we show such a correspondence between EF + ∀red and first-order intuitionistic logic IS1
2, introduced in Buss [1986b] and
Cook and Urquhart [1993]. For this, first-order arithmetic formulas are translated into sequences
of QBFs [Krajíček and Pudlák 1990].
Our main result on the correspondence states that translations of arbitrarily complex prenex
theorems in IS1
2 admit polynomial-size EF + ∀red proofs (Theorem 6.1). Informally, this says that
all IS1
2 consequences can be efficiently derived in EF + ∀red, and moreover, EF + ∀red is the weakest
system with this property.
The second facet of the correspondence is that IS1
2 can prove the correctness of EF + ∀red in a
suitable encoding (Corollary 6.3), and in a certain sense EF + ∀red is the strongest proof system
that is provably sound in the theory IS1
2.
Technically, the correspondence as well as the simulation results mentioned under D. (above)
rest on a formalization of the Strategy Extraction Theorem for QBF Frege systems. We provide two
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.
Frege Systems for Quantified Boolean Logic 9:7
formalizations for this result: in the first, we directly construct Frege proofs for the correctness of
the witnessing properties (Theorem 4.4). In the second, we use first-order logic, where we formalize
strategy extraction in the theory S1
2 (Theorem 6.2). While the first formalization applies to more
systems and gives the simulation structure detailed in D., the second formalization is stronger and
enables the correspondence to IS1
2.
Although intuitionistic bounded arithmetic was already developed by Buss [1986b] in the
mid’80s, no QBF counterpart of this theory was found so far—in sharp contrast to most other
arithmetic theories [Cook and Nguyen 2010]. As we show here, the missing piece in the puzzle is
our new QBF Frege system EF + ∀red.
Indeed, the appealing link between IS1
2 and EF + ∀red comes via their witnessing properties:
similarly as EF + ∀red has strategy extraction for arbitrarily complex QBFs, the theory IS1
2 admits
a witnessing theorem for arbitrary first-order formulas [Cook and Urquhart 1993].
Conceptually, our work draws on the close interplay of ideas and techniques from proof complexity, computational complexity, and bounded arithmetic; and it is really the interaction of these
areas and techniques that form the technical basis of our results (which forces us also to include
rather extensive preliminaries).
1.2 Relations to Previous Work
In addition to the developments in propositional and QBF proof complexity sketched in the beginning, the main precursor of our work is the paper Beyersdorff et al. [2015]. Strategy extraction
for Q-Res and QU-Res was shown by Goultiaeva et al. [2011] and Balabanov and Jiang [2012], but
the idea to turn this into a lower bound argument for the proof size originates from Beyersdorff
et al. [2015], where the AC0 lower bound for Parity is used to obtain exponential lower bounds for
Q-Res and QU-Res. However, the treatment in Beyersdorff et al. [2015] is solely confined to the
resolution case. Here, we widely generalize these concepts and uncover the full potential of that
approach. In fact, quite weak circuit lower bounds would suffice for the proof-size lower bounds of
Beyersdorff et al. [2015], cf. Corollary 5.11 in the present article; and from Beyersdorff et al. [2015],
it is not clear how the full spectrum of the state-of-the-art circuit lower bounds could be used to
get proof size lower bounds.
Feasible interpolation is another technique relating circuit lower bounds to proof size bounds.
Feasible interpolation has been successfully applied to show lower bounds for a number of propositional proof systems, including resolution [Krajíček 1997] and cutting planes [Pudlák 1997]. Indeed, Beyersdorff et al. [2017a] have recently shown that feasible interpolation is also effective for
QBF resolution calculi. Interpolation transfers monotone circuit lower bounds to proof size lower
bounds. Hence, different from strategy extraction, there is no connection between the circuit model
and the lines in the proof system. Also, by results of Krajíček and Pudlák [1998], Bonet et al. [2000],
and Bonet et al. [2004], feasible interpolation is not applicable to strong systems such as AC0-Frege
and beyond. Another restriction of interpolation is that it only applies to special formulas, and for
these—at least in the case of QBF resolution systems—it can be understood as a special case of
strategy extraction [Beyersdorff et al. 2017a].
1.3 Organization of the Article
Contents
1 Introduction 2
1.1 Summary of Results . . . . . . . . . . . . . . . 4
1.2 Relations to previous work . . . . . . . . . . . . . . . 7
1.3 Organization of the paper . . . . . . . . . . . . . . . 7
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.
9:8 O. Beyersdorff et al.
2 Preliminaries 8
2.1 Circuit classes . . . . . . . . . . . . . . . 8
2.2 Proof systems . . . . . . . . . . . . . . . 8
2.3 Frege systems . . . . . . . . . . . . . . . 9
2.4 Quantified Boolean Formulas . . . . . . . . . . . . . . . 10
3 Defining QBF Frege systems 10
4 Strategy extraction 12
4.1 Formalized Strategy Extraction . . . . . . . . . . . . . . . 14
4.2 Normal forms for C -Frege+ 8red proofs . . . . . . . . . . . . . . . 16
5 Separations and lower bounds via circuit complexity 17
5.1 Lower bounds for bounded-depth QBF Frege systems . . . . . . . . . . . . . . . 19
5.2 Lower bounds for constant depth QBF Frege systems . . . . . . . . . . . . . . . 22
5.3 Characterizing QBF Frege and extended Frege lower bounds . . . . . . . . . . . . . . . 24
6 Relation of QBF Frege to sequent systems and bounded arithmetic 25
6.1 Background on sequent systems and bounded arithmetic . . . . . . . . . . . . . . . 25
6.1.1 Sequent Calculi . . . . . . . . . . . . . . . 25
6.1.2 Bounded arithmetic . . . . . . . . . . . . . . . 26
6.2 Intuitionistic logic corresponds to extended Frege for QBFs . . . . . . . . . . . . . . . 27
6.3 Gentzen and Frege for QBFs . . . . . . . . . . . . . . . 29
6.3.1 Formulas hard in Gentzen, but easy in Frege . . . . . . . . . . . . . . . 31
6.3.2 Formulas easy in Gentzen, but hard in Frege . . . . . . . . . . . . . . . 32
7 Conclusion 34
2 PRELIMINARIES
We assume familiarity with basic notions from computational complexity, cf. Arora and Barak
[2009], as well as from logic, cf. Krajíček [1995], but define all specific concepts needed in this
article. For a formula φ, we denote by φ[x1/θ1,..., xk /θk ] the formula φ where variables xi have
been substituted by formulas θi .
2.1 Circuit Classes
We recall the definitions of standard circuit classes used in this article. The class AC0 contains all
languages recognizable by polynomial-size circuits over the Boolean basis ¬, ∨, ∧ with bounded
depth and unbounded fan-in. When fixing the depth to a constant d, we denote the circuit class
by AC0
d . The class AC0[p] uses bounded-depth circuits with MODp gates determining whether
the sum of the inputs is 0 modulo p, and in TC0 bounded-depth circuits with threshold gates are
permitted. Stronger classes are obtained by using NC1 circuits of polynomial size and logarithmic
depth, and by P/poly circuits of polynomial size.
When defining circuit families Cn from a circuit class C, we distinguish between uniform and
non-uniform families. For a uniform family, we require that there exists a Turing machine, which
from input 1n efficiently constructs the circuit Cn. In the non-uniform setting, we merely require
that the circuit Cn ∈ C exists and is of the required size.
For an in-depth account on circuit complexity, we refer to Vollmer [1999].
2.2 Proof Systems
According to Cook and Reckhow [1979] a proof system for a language L is a polynomial-time onto
function P : {0, 1}
∗ → L. Each string φ ∈ L is a theorem and if P (π ) = φ, π is a proof of φ in P.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.
Frege Systems for Quantified Boolean Logic 9:9
Given a polynomial-time function P : {0, 1}
∗ → {0, 1}
∗ the fact that P ({0, 1}
∗) ⊆ L is the soundness
property for L and the fact that P ({0, 1}
∗) ⊇ L is the completeness property for L. Proof systems
for the language TAUT of propositional tautologies are called propositional proof systems and proof
systems for the language TQBF of true QBF formulas are called QBF proof systems. Equivalently,
propositional proof systems and QBF proof systems can be defined, respectively, for the languages
UNSAT of unsatisfiable propositional formulas and FQBF of false QBF formulas, in this second
case, we call them refutational. Given two proof systems P and Q for the same language L, P
p-simulates Q (denoted Q p P) if there exists a polynomial-time function t such that for each
π ∈ {0, 1}
∗, P (t(π )) = Q(π ). Two systems are called p-equivalent if they p-simulate each other. A
proof system P for L is called polynomially bounded if there exists a polynomial p such that every
x ∈ L has a P-proof of size at most p(|x |), where |x | is the size of string x.
2.3 Frege Systems
Frege proof systems are the common “textbook” proof systems for propositional logic based on
axioms and rules [Cook and Reckhow 1979]. The lines in a Frege proof are propositional formulas
built from propositional variables xi and Boolean connectives ¬, ∧, and ∨. A Frege system composed of a finite set of axiom schemes and rules, e.g., φ ∨ ¬φ, is a possible axiom scheme. A Frege
proof is a sequence of formulas where each formula is either a substitution instance of an axiom
or can be inferred from previous formulas by a valid inference rule. Frege systems are required
to be sound and implicationally complete. The exact choice of the axiom schemes and rules does
not matter, as any two Frege systems are p-equivalent, even when changing the basis of Boolean
connectives [Cook and Reckhow 1979; Krajíček 1995, Theorem 4.4.13]. Therefore, we can assume
w.l.o.g. that modus ponens is the only rule of inference. Usually Frege systems are defined as proof
systems where the last formula is the proven formula. To include also weak systems as resolution
in this picture, we use here the equivalent setting of refutation Frege systems where we start with
the negation of the formula that we want to prove and derive the contradiction 0.
Given a circuit class C , a general definition of C -Frege is contained in Jeřábek [2005]. Below,
we explicitly present the definitions of C -Frege for the circuit classes we will need later. There are
several common restrictions that can be imposed on Frege; for example, bounded-depth Frege systems (or AC0-Frege) are Frege systems where lines are formulas with negations only on variables
and with a bounded number of alternations between ∧’s and ∨’s. If the number of alternations is
at most d, then the proof system is called AC0
d -Frege. Bounded-depth Frege is called AC0-Frege,
since lines in an AC0-Frege proof are representable as AC0-circuits.
Resolution (Res) is a particular kind of AC0
1-Frege system2 introduced by Blake [1937] and Robinson [1965]. It is a refutational proof system manipulating unsatisfiable CNFs as sets of clauses,
where clauses are sets of literals. As we treat clauses as sets, factoring (to contract multiple occurrences of the same literal) is done automatically. The only inference rule of Resolution is
C ∨ x D ∨ ¬x
C ∨ D (Res rule),
where C,D denote clauses and x is a variable. A Res refutation derives the empty clause.
Given a prime p, the AC0[p]-Frege systems are defined to be bounded-depth Frege systems in
the language with Boolean connectives ¬, ∨, ∧ and modular gates MODp (x1,..., xn ). The MODp
predicate is true when
i xi ≡ 0 (mod p).
2We will consistently treat C -Frege systems as operating with lines from C . As Res operates with clauses, we will call it a
AC0
1-Frege system even though it refutes CNFs, which are depth 2.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.  
9:10 O. Beyersdorff et al.
The TC0-Frege systems are defined to be bounded-depth Frege systems in the language with
Boolean connectives ¬, ∨, ∧ and threshold gates Tk (x1,..., xn ). The Tk predicate is true when
at least k of its inputs are true. Two different, but equivalent, formalizations of TC0-Frege proof
systems are given by Buss and Clote [1996] and Bonet et al. [2000].
(Unrestricted) Frege systems correspond to the complexity class NC1 in the same sense, as
bounded-depth Frege corresponds to the class AC0. We will sometimes refer to Frege as NC1-Frege.
Extended Frege systems EF allow the introduction of new extension variables that abbreviate
formulas. Consistent with the above treatment of C -Frege, we define EF here as a Frege system
that directly operates with Boolean circuits rather than formulas, where extension variables can be
used to define the circuit gates (see Jeřábek [2005] for the precise formulation). Therefore, we will
refer to EF also as P/poly-Frege. An alternative characterization of EF is through substitution Frege
systems SF that allow arbitrary substitution instances of derived formulas [Cook and Reckhow
1979; Krajíček and Pudlák 1989].
The Frege systems defined above form a hierarchy of proof systems
Res p AC0
-Frege p AC0
[p]-Frege p TC0
-Frege p Frege p EF.
Currently lower bounds are only known for Res [Haken 1985] and AC0-Frege [Ajtai 1994; Krajíček
et al. 1995; Pitassi et al. 1993], whereas super-polynomial lower bounds for any of the stronger
systems constitute major problems in proof complexity.
2.4 Quantified Boolean Formulas
A (closed prenex) Quantified Boolean Formula (QBF) is a formula where quantifiers are introduced
to propositional logic, which has constants 0,1, the usual operators ¬, ∧, ∨, →, ↔, and propositional variables. Each variable is quantified at the beginning of the formula using either an existential or universal quantifier. We denote such formulas as Q φ, where φ is a propositional Boolean
formula called matrix, and Q is its quantifier prefix. We typically use xi for existentially quantified variables and ui for universally quantified variables. Sometimes, we require the matrix to be
a Conjunctive Normal Form (CNF); in particular, when we implement Resolution-style systems.
In a fully quantified prenex QBF, the quantifier prefix determines a total order of the variables.
Given a variable y, we will sometimes refer to the variables preceding y in the prefix as variables
left of y; analogously, we speak of the variables right of y.
The quantifier complexity of QBFs is captured by sets Σq
i and Πq
i , which are defined inductively. Σq
0 = Πq
0 is the set of quantifier-free propositional formulas, Σq
i+1 is the closure of Πq
i under
existential quantification, and Πq
i+1 is the closure of Σq
i under universal quantifiers.
A QBF Q1x1 ···Qkxk φ can be seen as a game between two players: universal (∀) and existential
(∃). In the ith step of the game, the player Qi assigns a value to the variable xi . The existential player
wins if φ evaluates to 1 under the assignment constructed in the game. The universal player wins
if φ evaluates to 0. Given a universal variable u with index i, a strategy for u is a function from all
variables of index < i to {0, 1}. A QBF is false if and only if there exists a winning strategy for the
universal player; that is, if the universal player has a strategy for all universal variables that wins
any possible game [Arora and Barak 2009; Goultiaeva et al. 2011].
3 DEFINING QBF FREGE SYSTEMS
In this section, we provide a general method of transforming a propositional proof system into
a QBF proof system. While this method works for a wide range of proof systems operating with
lines and rules, we will concentrate here on the hierarchy of C -Frege systems introduced in the
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.     
Frege Systems for Quantified Boolean Logic 9:11
previous section. However, our method also works for further propositional proof systems such as
polynomial calculus [Clegg et al. 1996] or cutting planes [Beyersdorff et al. 2018; Cook et al. 1987].
For the following, we fix a circuit class C with some natural properties, e.g., closure under
restrictions.3 In particular, C can be any of the circuit classes mentioned in Section 2.
Definition 3.1 (Frege C+ ∀red). A refutation of a false QBF Q φ in the system C -Frege + ∀red is a
sequence of lines L1,..., L where each line is a circuit from the class C , L1 = φ,
4 L = 0, and each
Li is inferred from previous lines Lj using the inference rules of C -Frege or using the following
rule:
Lj
Lj[u/B]
(∀red),
where Lj[u/B] belongs to the class C , variable u is rightmost (innermost with respect to the prefix)
among the variables of Lj , and B is a circuit from the class C containing only variables left of u.
The formal justification why C -Frege + ∀red is a sound and complete QBF proof system is given
in Theorem 3.2 below. However, let us pause a moment to see why adding the ∀red rule results
in a natural proof system C -Frege + ∀red. Recall that we consider C -Frege + ∀red as a refutation
system; hence, we aim to refute false quantified C formulas. A standard approach to witness the
falsity of quantified formulas is through Herbrand functions, which replace a universal variableu by
a function in the existential variables left of u. These functions can be viewed as “counterexample
functions.” In Definition 3.1, B plays the role of the Herbrand function. Clearly, when restricting
formulas to a class C , we should also restrict B to that class, and substituting the Herbrand function
into the formula should again preserve C .
Note that we are even allowed to choose different Herbrand functions B for the same variable
u in different parts of the proof. In general, this will be unsound (unless variables right of u are
renamed). However, it is safe to do if the line Lj does not contain any variables right of u.
It is illustrative to see how our construction compares to previously studied QBF resolution
systems. Choosing Res as our propositional proof system, which is an AC0
1-Frege system, we obtain
Res + ∀red. In Res + ∀red the ∀red rule can substitute a universal u by either a disjunction of literals
or by a constant 0/1. In the former case, we simply obtain a weakening step. In the latter case, if u
appears positively in the clause, then substituting u by 0 precisely corresponds to an application
of the ∀red rule in Q-Res, whereas substituting u by 1 results in a useless tautology.5 As Res + ∀red
can resolve on existential and universal variables, our system Res + ∀red is exactly the well-known
QU-Res (with weakening).
We now proceed to show soundness and completeness of the new QBF systems.
Theorem 3.2. For every circuit complexity class C , the system C -Frege + ∀red is a refutational
QBF proof system.
Proof. Res + ∀red is complete as it p-simulates Q-Res, which is complete for QBF [Kleine
Büning et al. 1995]. To obtain the completeness for C -Frege + ∀red, we first use de Morgan’s rules
to expand the formula into a CNF. This is possible as, by definition, C -Frege is implicationally
complete. Now, we can refute the CNF by Res + ∀red. C -Frege + ∀red p-simulates Res + ∀red and
hence C -Frege + ∀red is complete.
3In the context of a circuit class, “closure under restriction” means that for any circuit in the class, if we pick a partial
assignment to some of the input variables and substitute in those constants, we still are guaranteed to be in the same
circuit class.
4In the case where C is AC0
1, we require that φ = L1 ∧···∧ Lm where Lj are lines in AC0
1-Frege. 5Note that, contrasting the usual setting of Q-Res [Kleine Büning et al. 1995], our definition of Res + ∀red does not need
to disallow tautologous resolvents, as these will always be reduced to 1.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.  
9:12 O. Beyersdorff et al.
Regarding the soundness of C -Frege + ∀red, let (L1,..., L ) be a refutation of Q φ in the system
C -Frege + ∀red and let
φi =

φ if i = 0,
φ ∧ L1 ∧···∧ Li otherwise.
By induction on i, we prove that Q φ semantically entails Q φi , i.e., Q φ |= Q φi . Hence, at step
i = , we will immediately obtain that Q φ is false, since L = 0 and Q φ ≡ 0.
Since Q φ = Q φ0 the base case of the induction holds.
We show now that Q φ |= Q φi implies Q φ |= Q φi+1. By definition, φi+1 = (φi ∧ Li+1) and Li+1
was either introduced by a C -Frege rule or by the ∀red rule. If Li+1 was introduced by a C -Frege
rule, then φi |= Li+1, so φi |= φi+1 and clearly Q φ |= Q φi |= Q φi+1.
Suppose now that Li+1 was introduced by the ∀red rule, say Li+1 = Lj[u/B] with j  i, u the
innermost variable among the ones in Lj and B relying only on the variables left of u. Moreover,
suppose that Q φi = Q1x ∀u Q2y φ i ; then, we have the following chain of equivalences
Q φi = Q1x ∀u Q2y φ i (1)
≡ Q1x ∀u Q2y φ i ∧ Lj (2)
≡ Q1x
 Q2y φ i[u/0] ∧ Lj[u/0]
∧ 
Q2y φ i[u/1] ∧ Lj[u/1]  (3)
≡ Q1x

Lj[u/0] ∧ Lj[u/1] ∧ 
Q2y φ i[u/0]
∧ 
Q2y φ i[u/1]  (4)
≡ Q1x

Lj[u/0] ∧ Lj[u/1] ∧ ∀uQ2y φ i
 (5)
≡ Q1x

Lj[u/0] ∧ Lj[u/1] ∧ Lj[u/B] ∧ ∀uQ2y φ i
 (6)
≡ Q1x∀uQ2y φ i ∧ Lj[u/0] ∧ Lj[u/1] ∧ Lj[u/B]. (7)
In Equations (3) and (5), we used the definition of semantic expansion of a universal variable in a
QBF; in Equations (4), (6), and (7), we used the fact that Lj[u/0], Lj[u/1] and Lj[u/B] do not contain
y variables. From Equation (7) follows, by weakening, that
Q φi |= Q1x∀uQ2y φ i ∧ Lj[u/B],
hence Q φ |= Q φi+1.
Clearly lower bounds on the complexity of C -Frege + ∀red follow from lower bounds on
C -Frege. The lower bounds we show later will be of a different kind, as they will be “purely for
QBF proof systems” in the sense that they will lower bound the number of occurrences of the ∀red
rule in refutations (cf. also Beyersdorff et al. [2017b] for a formal definition of what qualifies as a
“genuine” QBF lower bound).
4 STRATEGY EXTRACTION
We introduce now the simple computational model of C -decision lists.
Definition 4.1 (C -decision list). A C -decision list is a program of the following form:
if C1 (x) then u ← B1 (x);
else if C2 (x) then u ← B2 (x);
.
.
.
else if C−1 (x) then u ← B−1 (x);
else u ← B (x),
where C1,...,C−1 and B1,..., B are circuits in the class C . Hence, a decision list as above computes a Boolean function u = д(x).
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.                                         
Frege Systems for Quantified Boolean Logic 9:13
This definition generalizes decision lists from Rivest [1987], where the conditions Ci (x) are
expressible as terms. We note that for many cases C -decision lists can be easily transformed into
C -circuits.
Proposition 4.2. Let D be a C -decision list using circuits C1,...,C−1 and B1,..., B, such that
D computes the Boolean function д. Then there exists a circuit D ∈ C computing the same function
д, such that the size of D is linear in the size of D and
depth(D
)  max
max 1i−1
{depth(Ci )}, max
1i
{depth(Bi )}

+ 2.
Proof. We have that
u ≡


j=1



Cj (x) ∧ Bj (x) ∧

1k<j
¬Ck (x)



,
where C is a circuit computing the constant 1 and for j = 1, we have an empty conjunct in the
formula that is true.
Balabanov and Jiang [2012] proved a strategy extraction result for QU-Res. Here, we generalize
that result to the full hierarchy of C -Frege + ∀red QBF proof systems. This result is the main tool
we use to prove size lower bounds in such systems.
Theorem 4.3 (Strategy Extraction). Given a false QBF Q φ and a refutation π of Q φ in
C -Frege + ∀red, it is possible to extract in linear time (w.r.t. |π |) a collection of C -decision lists D
computing a winning strategy on the universal variables of φ.
Proof. Let π = (L1,..., Ls ) be a refutation of the false QBF Q φ and let
πi =

∅ if i = s,
(Li+1,..., Ls ) otherwise.
We show, by downward induction on i, that from πi it is possible to construct in linear time
(w.r.t. |πi |) a winning strategy σi for the universal player for the QBF formula Q φi , where
φi =

φ if i = 0,
φ ∧ L1 ∧···∧ Li otherwise,
such that for each universal variable u in Q φ, there exists a C -decision list Di
u computing σi
u as a
function of the variables in Q left of u, having size O(|πi |).
The statement of the Strategy Extraction Theorem corresponds to the case when i = 0. For the
base case, we can define all the Ds
u as u ← 0, as any strategy will refute this QBF, so σs
u = 0 is just
picked arbitrarily.
We show now how to construct σi−1 u and Di−1 u from σi
u and Di
u :
• If Li is derived by some Frege rule, then for each universal variable u, we set σi−1 u = σi
u and
Di−1 u = Di
u .
• If Li is the result of an application of a ∀red rule, then that is Lj
Lj[u/B], where u is rightmost
among the variables in Lj , Lj[u/B] is a circuit in C using only variables on the left of u, and
Lj (u/B) = Li . Let xu denote all variables on the left of u in the quantifier prefix of Q φ.
Then, we define
σi−1 u (xu ) =
⎧⎪⎪
⎨
⎪⎪
⎩
σi
u (xu ) if u  u,
B(xu ) if u = u and Lj[u/B](xu ) = 0,
σi
u (xu ) if u = u and Lj[u/B](xu ) = 1.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.                              
9:14 O. Beyersdorff et al.
Moreover, for each u  u, we set Di−1 u = Di
u and we set Di−1 u as follows:
if ¬Lj[u/B](xu ) then u ← B(xu );
else Du
i (xu ).
We now check that for each u
, σi−1 u respects all the properties of the inductive claim.
 σi−1 u and Di−1 u are well defined. By construction Lj[u/B] is a formula in the variables x left of
u. This immediately implies that, for each universal variable u
, the strategy σi−1 u is well defined
and Di−1 u is also well defined. By induction hypothesis Di
u is a C -decision list, so Di−1 u is also a
C -decision list.
 σi−1 and Di−1 u are constructed in linear time w.r.t. |πi−1 |. This holds by inductive hypothesis and
the fact that computing ¬Lj (u/B) is linear in |πi−1 | (the number of characters in this subproof).
 Di−1 u computes σi−1 u . For u  u, by induction hypothesis, Di−1 u computes σi
u. The same happens,
by construction, for u = u.
 σi−1 is a winning strategy for Q φi−1. Fix an assignment ρ to the existential variables of φ. Let
τi be the complete assignment to existential and universal variables, constructed in response to ρ
under the strategy σi
. By induction hypothesis τi falsifies φi . We need to show that τi−1 falsifies
φi−1. To show this, we distinguish again two cases.
If Li is derived by some Frege rule, then σi−1 = σi and τi−1 = τi . Hence, by induction hypothesis,
τi falsifies a conjunct from φi . To argue that τi−1 also falsifies a conjunct from φi−1, we only need
to look at the case when the falsified conjunct is Li . As Li is false under τi and Li is derived by
a sound Frege rule, one of the parent formulas of Li in the application of the Frege rule must be
falsified as well. Hence, τi−1 falsifies φi−1.
Now let Li = Lj[u/B] for some j < i. In this case, our strategy σi−1 changes the assignment τi
only when τi made the universal player win by falsifying Li . As we set u to B(τi (x)), the modified
assignment τi−1 falsifies Lj . Otherwise, if τi does not falsify Li , we keep τi−1 = τi and hence falsify
one of the conjuncts of φi−1 by induction hypothesis.
From the proof of the Strategy Extraction Theorem it is clear that the size of the C -decision list
computing the winning strategy extracted from the refutation π has size that is actually linear in
the number of applications of the ∀red rule in π. More precisely, the size of the C -decision list
computing the winning strategy for variable u corresponds exactly to the number of ∀red rules on
u in π. The size of a C -decision list is intended to be its string representation. Interestingly, the
same observation above holds if we consider the number of entries of the C -decision list; i.e., the
C -decision list computing the winning strategy extracted from the refutation π has a number of
entries that is linear in the number of applications of the ∀red rule in π.
4.1 Formalized Strategy Extraction
We now observe that the strategy extraction from Theorem 4.3 is in fact provably correct in the
corresponding Frege system. In Theorem 6.2, we also give a formalization of strategy extraction
in the theory of bounded arithmetic S1
2.
For this subsection (and also later occasionally), we assume w.l.o.g. that QBFs are of the form
∃x1∀y2 ···∃xn∀yn φ(x1,..., xn,y1,...,yn ) with only one variable per quantifier block. This is no
restriction, as a QBF with larger quantifier blocks can be transformed into this form by adding
dummy variables to the prefix, which do not appear in the matrix of the formula. This will simplify
our analysis.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.            
Frege Systems for Quantified Boolean Logic 9:15
Theorem 4.4. Let C be AC0, AC0[p], TC0, NC1, or P/poly. Given a C -Frege + ∀red refutation π
of a QBF
∃x1∀y1 ···∃xn∀yn φ(x1,..., xn,y1,...,yn )
where φ ∈ Σq
0 , we can construct in time |π |
O (1) a C -Frege proof of
n
i=1
(yi ↔ Ci (x1,..., xi,y1,...,yi−1)) → ¬φ(x1,..., xn,y1,...,yn )
for some circuits Ci ∈ C . (The depth of the C -Frege proof increases by a constant compared to the
depth of the C -Frege + ∀red proof.)
Proof. We inspect the proof of the Strategy Extraction Theorem above. Again let π =
(L1,..., Ls ) be a C -Frege + ∀red refutation of a QBF Q φ given as
∃x1∀y1 ···∃xn∀yn φ(x1,..., xn,y1,...,yn )
where φ ∈ Σq
0 and define πi and φi as in the proof of Theorem 4.3. We will show by downward
induction on i that from πi it is possible to construct in linear time a winning strategy
σi = {Ci
1 (x1),...,Ci
n (x1,..., xn,y1,...,yn−1)} ⊆ C
for the universal player for the QBF Q φi . Moreover, the formula
n
l=1
(yl ↔ Ci
l (x1,..., xl ,y1,...,yl−1)) → ¬φi (x1,..., xn,y1,...,yn )
denoted σi (φi ), which witnesses the negation of Q φ will have a C -Frege proof of size K|πi |
K for
a constant K depending only on the choice of the C -Frege system. The statement of the theorem
corresponds to the case i = 0.
In the base case, φs contains a contradiction so the winning strategy can be defined as the set
of trivial circuits {0,..., 0} and it is trivially provably correct.
Assume now that σi (φi ) has a C -Frege proof of size K(s + 1 − i)|πi |
K .
If Li is derived by a C -Frege rule, then σi−1 = σi
.
Now let Li = Lj[u/B] be the result of an application of a ∀red rule on Lj where u is innermost
among the variables in Lj . Then define Ci−1
l = Ci
l if u  yl , otherwise set
Ci−1
l (z) =

B(z) if Lj[u/B](z) = 0,
Ci
l (z) if Lj[u/B](z) = 1.
This constructs strategies σi from π by a D|πi |-time algorithm for a constant D. W.l.o.g. D < K.
In fact, circuitsCi
l are in C . (For constant depth C ’s, we take for circuitsCi
l the equivalent constantdepth circuits from Proposition 4.2).
We want to show that σi−1 (φi−1) has a C -Frege proof of size K(s + 1 − (i − 1))|πi−1 |
K .
If Li is derived by a C -Frege rule, then σi also witnesses ¬φi−1 because
¬Li → ¬(L
1 ∧···∧ L
t )
for some conjuncts L
1,..., L
t in φi−1. Note that Ci−1
l ’s are then Ci
l
’s. The implications
¬φi → ¬φi−1, (8)
σi
(φi ) ∧ (¬φi → ¬φi−1) → σi−1 (φi−1), (9)
can be derived by a fixed sequence of C -Frege rules depending only on the choice of C -Frege.
(Note that the left-hand sides of the implications σi (φi ) and σi−1 (φi−1) are identical, because
σi−1 = σi in this case.) Thus, the common size of C -Frege proofs of both these implications is  K0 |πi−1 |
K0 where w.l.o.g. K0 < K. Therefore, σi−1 (φi−1) has a C -Frege proof of size
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.   
9:16 O. Beyersdorff et al.
 K(s + 1 − i)|πi |
K + K1 |πi−1 |
K1  K(s + 1 − (i − 1))|πi−1 |
K where K1 > K0 depends again on a
fixed sequence of C -Frege rules needed to derive σi−1 (φi−1) from Equations (8), (9), and σi (φi ), so
w.l.o.g. K1 < K.
Assume now that Li = Lj[u/B] is the result of an application of ∀red where u = yl . Then there
is a fixed sequence of C -Frege rules deriving the implications
σi
(φi ) ∧ ¬Lj[u/B] → σi−1 (φi−1), (10)
σi
(φi ) ∧ Lj[u/B] → σi−1 (φi−1). (11)
Equation (10) follows from the provable equation Lj ∧ (u ↔ B) → Lj[u/B], because Lj is a conjunct
in φi−1, u = yl and Ci−1
l is B, because ¬Lj[u/B] holds in this case. Equation (11) follows from the
provable formula φi−1 ∧ Lj[u/B] → φi and 	n
l=1 yl ↔ Ci−1
l → 	n
l=1 yl ↔ Ci
l under the condition
that Ci−1
l = Ci
l
, which is the case if Lj[u/B] holds.
The total size of both C -Frege derivations of Equations (10) and (11) is K0 |πi−1 |
K0 where K0
depends on the choice of C -Frege and the size of Ci−1
l ’s. The size of all Ci−1
l ’s is bounded by
K|πi−1 |
K . Hence, we can assume K0 < K. It follows that σi−1 (φi−1) has a C -Frege proof of size
 K(s + 1 − i)|πi |
K + K1 |πi−1 |
K1  K(s + 1 − (i − 1))|πi−1 |
K where as beforeK1 depends on a fixed
sequence of C -Frege rules needed to simulate a fixed set of “cut” rules, i.e., w.l.o.g. K1 < K.
4.2 Normal forms for C -Frege + ∀red Proofs
We conclude this section with an application of the Strategy Extraction Theorem to obtain normal
forms for C -Frege + ∀red proofs. First, we show that any C -Frege + ∀red refutation can be efficiently rewritten as a C -Frege derivation followed essentially just by ∀red rules. Second, we show
that in the ∀red rule it is sufficient to only substitute constants.
Theorem 4.5. Let C be AC0, AC0[p], TC0, NC1, or P/poly. For any C -Frege + ∀red refutation π
of a QBF ψ of the form
∃x1∀y1 ···∃xn∀yn φ(x1,..., xn,y1,...,yn ),
whereφ ∈ Σq
0 , there is a |π |
O (1)
-size C -Frege + ∀red refutation ofψ starting with a C -Frege derivation
of
n
i=1
(yi  Ci (x1,..., xi,y1,...,yi−1)), (12)
from φ for some circuits Ci ∈ C , followed by n applications of the ∀red rule, gradually replacing the rightmost variable yi by circuit Ci (x1,..., xi,y1,...,yi−1) and cutting the inequality yi
Ci (x1,..., xi,y1,...,yi−1) out of the disjunction (12).
Proof. Given a C -Frege + ∀red refutation π ofψ, by Theorem 4.4, there is a |π |
O (1)
-size C -Frege
proof of
n
i=1
(yi ↔ Ci (x1,..., xi,y1,...,yi−1)) → ¬φ(x1,..., xn,y1,...,yn ).
Having φ freely available in the refutation, C -Frege can derive (12) by applying the cut rule
(derivable in C -Frege).
The refutation then continues by n applications of the ∀red rule, which one-by-one replaces the
rightmost variable yi by Ci (x1,..., xi,y1,...,yi−1) and eliminates
yi  Ci (x1,..., xi,y1,...,yi−1)
from the disjunction 

i yi  Ci (x1,..., xi,y1,...,yi−1).
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.          
Frege Systems for Quantified Boolean Logic 9:17
Theorem 4.5 is an analogue of the midsequent theorem for sequent systems. An immediate
consequence of Theorem 4.5 is the p-equivalence of C -Frege + ∀red and its tree-like version. This is
in contrast to the G1, G0 systems where one has p-simulations of dag systems by tree systems only
for prenex Σq
1 -formulas (see Cook and Morioka 2005, Theorem 6 and the discussion after the proof).
Corollary 4.6. Let C be AC0, AC0[p], TC0, NC1, or P/poly. Then, C -Frege + ∀red is p-equivalent
to tree-like C -Frege + ∀red.
Proof. By Theorem 4.5, any C -Frege + ∀red derivation can be efficiently replaced by a proof
in the normal form. The C -Frege part of such derivation can be efficiently replaced by a tree-like
C -Frege proof, cf. Krajíček [1995], and the rest of the C -Frege + ∀red refutation given in the normal
form is tree-like.
Finally, we further simplify C -Frege + ∀red so every application of the ∀red rule only substitutes
constants 0/1 instead of general circuits. We denote the resulting system as C -Frege + ∀red0,1. This
shows that C -Frege + ∀red systems are indeed very robustly defined.
Theorem 4.7. Let C be AC0, AC0[p], TC0, NC1, or P/poly. Then, C -Frege + ∀red and
C -Frege + ∀red0,1 are p-equivalent.
Proof. It is enough to show that any C -Frege + ∀red refutation can be transformed efficiently into a refutation where the ∀red rule substitutes only constants. By Theorem 4.5, for any
C -Frege + ∀red refutation π of Q φ there is a |π |
O (1)
-size C -Frege derivation of
n
i=1
(yi  Ci (x1,..., xi,y1,...,yi−1))
from φ(x1,..., xn,y1,...,yn ). Applying ∀red0,1 on yn, we can then derive
(Cn (x1,..., xn,y1,...,yn−1)  c) ∨
n
−1
i=1
(yi  Ci (x1,..., xi,y1,...,yi−1))
for both constants c = 0, 1.
However, there is a polynomial-size C -Frege proof of
(Cn (x1,..., xn,y1,...,yn−1) ↔ 1) ∨ (Cn (x1,..., xn,y1,...,yn−1) ↔ 0),
so we can derive 

i<n (yi  Ci (x1,..., xi,y1,...,yi−1)). In this way, we can efficiently cut all
disjuncts and derive a contradiction in C -Frege + ∀red0,1.
5 SEPARATIONS AND LOWER BOUNDS VIA CIRCUIT COMPLEXITY
We now introduce a class of QBFs defined from some circuitsCn computing a function f . Choosing
different functions f , these formulas will form the basis of our lower bounds.
Definition 5.1 (Q-Cn). Let n be an integer and Cn be a circuit with inputs x1,..., xn. Let
t1,...,tm−1 be a topological ordering of the internal gates of Cn, and let the output gate of Cn
be tm. We define
Q-Cn = ∃x1 ···∃xn∀u∃t1 ···∃tm (u ↔ ¬tm ) ∧
m
i=1
Gi,
where u ↔ ¬tm ≡ (u ∨ tm ) ∧ (¬u ∨ ¬tm ) and Gi expresses as a CNF the function computed in the
circuit Cn at gate i, e.g., if node ti computes the ∧ of tj and tk then
Gi = ti ↔ (tj ∧ tk ) ≡ (¬ti ∨ tj) ∧ (¬ti ∨ tk ) ∧ (ti ∨ ¬tj ∨ ¬tk ),
similarly if gate i computes ¬, ∨, ⊕, MODp , Tk or some other Boolean function.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.      
9:18 O. Beyersdorff et al.
Informally, the QBF Q-Cn expresses that there exists an input x such thatCn (x) neither evaluates
to 0 nor 1, an obvious contradiction, as Cn computes a total function on {0, 1}
n. The formulas Gi
can be considered as the result of a Tseitin translation used widely in SAT and QBF solving. We
intentionally place the universal variable u to the left of the Tseitin variables ti , thus making the
Tseitin variables inaccessible when constructing the strategy of u. We note that the hardness of the
formulas crucially depends on this choice of the order of quantification (compare also Beyersdorff
et al. [2016b]).
Using these formulas together with the Strategy Extraction Theorem, we now establish a tight
connection between the circuit class C and C -Frege + ∀red.
Theorem 5.2. Let C be one of the circuit classes AC0, AC0[p], TC0, NC1, P/poly and let (Cn )n∈N
be a non-uniform family of circuits whereCn is a circuit with n inputs. Then the following implications
hold:
(i) if the QBFs Q-Cn have C -Frege + ∀red refutations of size bounded by a function q(n), then
for each n, Cn is equivalent to a circuit C
n where C
n is of size O(q(n)) and uses the gates and
depth allowed in C ;
(ii) if (Cn )n∈N is a polynomial-size circuit family from C , then the QBFs Q-Cn have polynomialsize refutations in C -Frege + ∀red.
Proof. Regarding (i), by the Strategy Extraction Theorem and Proposition 4.2, if the QBF Q-Cn
has a refutation in C -Frege + ∀red of size S, then a winning strategy for the universal player can
be computed by a circuit C
n ∈ C of size O(S). We have that in Q-Cn the quantifier prefix looks
like ∃x1 ···∃xn∀u∃t. Now, by construction, u  Cn (x1,..., xn ), hence a winning strategy for the
universal player must consist of playing u = Cn (x1,..., xn ). This means that the circuit C
n computing the winning strategy for the universal player is equivalent to the circuit Cn and the size
bound follows.
Note that the circuits C
n and Cn are equivalent but not identical. The first one C
n is the strategy
extracted from a decision list and depends on the proof in question, whereas Cn is the original
circuit encoded into Q-Cn with Tseitin variables.
Regarding (ii), we define the ti variables (1  i  m) for Q-Cn as in Definition 5.1. By definition,
the ti are indexed w.r.t. a topological ordering of the nodes of Cn.
We prove, by induction on i, that there exists a circuit Di ∈ C such that ti ↔ Di is derivable in
C -Frege with size polynomial in |Di |.
In the base case, we have that C -Frege is able to prove x ↔ x for every input variable x.
For the inductive step, suppose thatti corresponds to a gate (tj1 ,...,tj ) with fan-in , where 
could be an ∧, ∨, ¬, ⊕, MODp,Tk ,... from the gates allowed in the class C and j1 ... j is a sequence
of indices less than i. By the inductive property, we know thattk ↔ Dk is provable in C -Frege with
proofs of size polynomial in |Dk |, for every k < i (as well as any input variables). Hence, tjk ↔ Djk
is provable in C -Frege with proofs of size polynomial in |Djk | for every input gate variable tjk .
Moreover, C -Frege is able to make the following inference in a polynomial number of steps:
tj1 ↔ Dj1 ··· tj ↔ Dj ti ↔ (tj1 ,...,tj )
ti ↔ (Dj1 ,...,Dj ) .
Then let Di = (Dj1 ,...,Dj ). At themth step C -Frege proves that tm ↔ Dm, from which follows
that
tm ↔ Dm u ↔ ¬tm
u ↔ ¬Dm
.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.              
Frege Systems for Quantified Boolean Logic 9:19
Since now u is universal and the innermost variable of u ↔ ¬Dm, we can apply the ∀red rule
and get 0 ↔ ¬Dm, 1 ↔ ¬Dm, which leads to an immediate contradiction in the QBF proof system
C -Frege + ∀red.
In particular, a Boolean function f is computable by polynomial-size C circuits if and only
if Q-Cn have polynomial-size C -Frege refutations for each choice of Boolean circuits (Cn )n∈N
computing f . Note that the circuits Cn are not necessarily circuits in the class C .
In the remainder of this section, we apply Theorem 5.2 to a number of circuit classes and transfer
circuit lower bounds to proof size lower bounds.
5.1 Lower Bounds for Bounded-depth QBF Frege Systems
Parity is one of the best-studied functions in terms of its circuit complexity. With Theorem 5.2,
we can immediately transfer circuit lower bounds for Parity to Frege AC0[p] + ∀red, regardless of
the encoding for Parity.
Corollary 5.3 (Q-Parity lower bounds). Let Cn be a family of polynomial-size circuits computing Parity. For each odd prime p, the QBFs Q-Cn require refutations of exponential size in Frege
AC0[p] + ∀red.
Proof. The exponential lower bound for the refutation size in Frege AC0[p] + ∀red follows from
Theorem 5.2 and the fact that for each odd prime p any family of bounded-depth circuits with
MODp gates computing Parity must be of exponential size [Razborov 1987; Smolensky 1987].
We highlight that non-trivial lower bounds for AC0[p]-Frege are one of the major open problems
in propositional proof complexity. We complement the lower bound in Corollary 5.3 with an upper
bound for arbitrary NC1 encodings of Parity in Frege + ∀red.
Corollary 5.4 (Q-Parity upper bounds). LetCn be a family of NC1 circuits computing Parity.
Then, the QBFs Q-Cn have polynomial-size refutations in Frege + ∀red.
Proof. By a result of Muller and Preparata [1975], Parity can be computed by circuits in NC1.
Hence, if we consider a family Cn of NC1 circuits computing Parity, then the polynomial upper
bound in Frege + ∀red follows immediately from Theorem 5.2.
In fact, this upper bound can be improved to the QBF proof system Frege AC0[2] + ∀red, albeit
not for arbitrary NC1-encodings of Parity, as it is not clear how these could be handled in bounded
depth. For this purpose, we consider explicit QBFs for Parity, which can be built from its inductive
definition Parity(x1,..., xn ) = Parity(x1,..., xn−1) ⊕ xn . This leads to the QBFs
Φn = ∃x1 ···∃xn∀u∃t2 ···∃tn (t2 ↔ (x1 ⊕ x2)) ∧
n
i=3
(ti ↔ (ti−1 ⊕ xi )) ∧ (u ↔ ¬tn ),
where a ↔ (b ⊕ c) ≡ (¬a ∨ ¬b ∨ ¬c) ∧ (¬a ∨ b ∨ c) ∧ (a ∨ ¬b ∨ c) ∧ (a ∨ b ∨ ¬c). This formulation of Q-Parity was considered by Beyersdorff et al. [2015], where the formulas Φn are shown to
be hard for Q-Res and QU-Res. Here, we obtain:
Corollary 5.5. The Parity-formulas Φn require refutations of exponential size in Frege
AC0[p] + ∀red for each odd prime p, but they have polynomial-size Frege AC0[2] + ∀red refutations.
Proof. The lower bound follows as in Corollary 5.3. For the upper bound, we cannot use Theorem 5.2, but need to give a more direct proof. Without loss of generality, we can assume that our
Frege AC0[2] + ∀red system uses the connectives {∧, ∨, ¬, ↔, ⊕}.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.   
9:20 O. Beyersdorff et al.
Then it is easy to see, by induction on i, that Frege proves ti ↔ ⊕(x1, x2,..., xi ) with a proof of
size linear in i for each i = 2,...,n. Hence, similarly to what was done in Theorem 5.2, we get
u ↔¬⊕ (x1, x2,..., xn ). (13)
Then, u is the rightmost variable in Equation (13); hence, by the ∀red rule, we have
1 ↔¬⊕ (x1, x2,..., xn ) and 0 ↔¬⊕ (x1, x2,..., xn ),
which gives an immediate contradiction.
In fact, we can further strengthen Corollary 5.5 and use Smolensky’s circuit lower bounds for
an even more ambitious separation of all Frege AC0[p] + ∀red systems. For this, we consider the
function
MODp (x1,..., xn ) =

1 if n
i=1 xi ≡ 0 (mod p),
0 otherwise.
For r  p − 1 let
MODp,r (x1,..., xn ) =

1 if n
i=1 xi ≡ r (mod p),
0 otherwise.
If we want to use MODp for a separation of Frege AC0[p] + ∀red and Frege AC0[q] + ∀red for different primes p, q, then MODp has to be encoded as a QBF in the language common to both proof
systems, which means that we cannot use MODp or MODq gates. As for Parity, an arbitrary NC1
encoding as in Corollary 5.3 will also not work (this would just give upper bounds in Frege + ∀red),
so we need to devise again explicit QBF encodings for MODp . Such QBFs can be built using the
fact that MODp—that is, MODp,0—can be defined for r  0 by
MODp,r (x1,..., xi ) = (MODp,r (x1,..., xi−1) ∧ ¬xi ) ∨ (MODp,r−1 (x1,..., xi−1) ∧ xi ),
and for r = 0 by
MODp,0 (x1,..., xi ) = (MODp,0 (x1,..., xi−1) ∧ ¬xi ) ∨ (MODp,p−1 (x1,..., xi−1) ∧ xi ).
Using variables sr
i for MODp,r (x1,..., xi ) this leads to the QBFs
Θp
n = ∃x1 ···∃xn∀u∃s0
1∃s1
1∃s0
2∃s1
2∃s2
2 ···∃s0
n ···∃s
p−1 n (u ↔ ¬s0
n ) ∧ (s1
1 ↔ x1) ∧ (s0
1 ↔ ¬x1) ∧

1<in
0<rp−1

s
r
i ↔ (s
r
i−1 ∧ ¬xi ) ∨ (sr−1 i−1 ∧ xi )

∧

1<in

s0
i ↔ (s0
i−1 ∧ ¬xi ) ∨ (s
p−1
i−1 ∧ xi )

.
Corollary 5.6. For each pair p, q of distinct primes the MODp -formulas Θp
n require refutations of
exponential size in Frege AC0[q] + ∀red, but have polynomial-size refutations in Frege AC0[p] + ∀red.
Proof. The exponential lower bound for the QBF proof system Frege AC0[q] + ∀red follows
from Theorem 5.2 together with the result from Razborov [1987] and Smolensky [1987] that for
distinct primes p, q any family of bounded-depth circuits with MODq gates computing MODp must
be of exponential size.
Regarding the upper bound, without loss of generality, we can assume that our AC0[p]-Frege
system uses the connectives {∧, ∨, ¬, ↔, MODp }. Then it is easy to see, by induction on i, that
AC0[p]-Frege proves
s
r
i ↔ MODp (x1,..., xi, 1, 1,..., 1  p−r
),
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.          
Frege Systems for Quantified Boolean Logic 9:21
with a proof of size linear in i. Hence, similarly to what was done in Theorem 5.2 and Corollary 5.5,
we get
u ↔ ¬MODp (x1,..., xn, 1, 1,..., 1  p
). (14)
Then u is the rightmost variable in (14); hence, by the ∀red rule, we have
1 ↔ ¬MODp (x1,..., xn, 1, 1,..., 1  p
) and 0 ↔ ¬MODp (x1,..., xn, 1, 1,..., 1  p
),
which gives an immediate contradiction.
Another notorious function in circuit complexity is Majority. Again, we can transform circuit
lower bounds to proof size lower bounds for arbitrary encodings of Majority.
Corollary 5.7 (lower bounds for Q-Majority). Let Cn be a family of polynomial-size circuits computing Majority(x1,..., xn ). Then, for every prime p, the QBFs Q-Cn require refutations
of exponential size in Frege AC0[p] + ∀red.
Proof. The lower bound follows again applying Theorem 5.2 and the fact that Majority
requires exponential-size bounded-depth circuits with MODp gates [Razborov 1987; Smolensky
1987].
For general encodings, we can again show Frege + ∀red upper bounds.
Corollary 5.8 (Q-Majority upper bounds). Let Cn be a family of NC1 circuits computing
Majority(x1,..., xn ). Then, the QBFs Q-Cn have polynomial-size refutations in the QBF proof system Frege + ∀red.
Proof. By a result of Muller and Preparata [1975], the function majority is computable in NC1
and hence Q-Cn are well defined. The upper bound then follows from Theorem 5.2.
As for the MODp functions, we can improve on this upper bound by considering explicit QBF
encodings of Majority, thereby even obtaining a separation of Frege AC0[p] + ∀red systems from
Frege TC0 + ∀red.
6 Explicit QBFs for Majority can be defined using the following property of the
k-threshold function:
Tk (x1,..., xi ) ≡ Tk (x1,..., xi−1) ∨ (Tk−1 (x1,..., xi−1) ∧ xi ). (15)
Using variables ti
k for Tk (x1,..., xi ) this gives rise to the QBFs
Ψn = ∃x1 ···∃xn∀u∃t
1
0t
1
1 ···∃t
n
n/2 (u ↔ ¬t
n
n/2) ∧

in
t
i
0 ∧ (t
1
1 ↔ x1) ∧

kn/2
in

t
i
k ↔ t
i−1
k ∨ (t
i−1
k−1 ∧ xi )

.
Corollary 5.9. For each prime p, the Majority-based formulas Ψn require refutations of
exponential-size in the QBF proof system Frege AC0[p] + ∀red, but have polynomial-size refutations
in Frege TC0 + ∀red.
Proof. The exponential lower bound from [Razborov 1987; Smolensky 1987] will give us the
exponential lower bound w.r.t. the size of Ψn in Frege AC0[p] + ∀red, since the size of Ψn is O(n2).
6Clearly, such a separation already follows from Corollary 5.6 together with the simulation of Frege AC0[p] + ∀red by Frege
TC0 + ∀red. Here, we will prove the stronger result that all these systems are separated by one natural principle—namely,
Majority.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.      
9:22 O. Beyersdorff et al.
Regarding the polynomial-size refutations of the QBF formula Ψn in Frege TC0 + ∀red, we can
proceed similarly as for Parity in Frege. The crucial feature here is that Tk are, by definition of
TC0, in the language of TC0-Frege. Hence (15) can be used to prove t
j
k ↔ Tk (x1,..., xj) and we
can easily refute Ψn in Frege TC0 + ∀red.
We note that a separation of AC0[p]-Frege from TC0-Frege constitutes a major open problem in
propositional proof complexity as we are currently lacking lower bounds for AC0[p]-Frege.
5.2 Lower Bounds for Constant Depth QBF Frege Systems
We now aim at a fine-grained analysis of AC0-Frege by studying its subsystems AC0
d -Frege. Our
next result is a version of Theorem 5.2, however, we need to be a bit more careful for circuits of
fixed depth d.
Theorem 5.10. Let (Cn )n∈N be a non-uniform family of circuits whereCn is a circuit with n inputs.
Then the following implications hold:
(i) if the QBFs Q-Cn have Frege AC0
d + ∀red refutations of size bounded by a function q(n), then
for each n, Cn is equivalent to a depth-(d + 2) circuit C
n of size O(q(n));
(ii) if (Cn )n∈N is a family of polynomial-size depth-d circuits, then the QBFs Q-Cn have
polynomial-size refutations in Frege AC0
d + ∀red.
Proof. The proof of (i) follows the proof of the analogous statement of Theorem 5.2. The Strategy Extraction Theorem in this case tells us that from refutations of Q-Cn in Frege AC0
d + ∀red of
size S, we can extract a winning strategy for the universal player that can be computed by AC0
d -
decision lists of size O(S). By Proposition 4.2, this means that the winning strategy can be also
computed by AC0
d+2 circuits and the size upper bound follows.
The proof of point (ii) follows the proof of the analogous statement of Theorem 5.2. That proof
will give us that Q-Cn has polynomial-size refutations in Frege AC0
d+2 + ∀red. Here, we want to
prove that Q-Cn has actually polynomial-size proofs in Frege AC0
d + ∀red. Without loss of generality suppose that the last gate tm of Cn is an 	 with fan-in , that is
Q-Cn = ∃x1 ···∃xn∀u∃t1 ···∃tm (u ↔ ¬tm ) ∧


tm ↔

j
tij



∧ φn,
where each tij is an 
 gate and φn is the encoding of the rest of the circuit Cn. We clearly have
that u ↔ ¬tm tm ↔ 	
j ≤ tij
u ↔ 

j ≤ ¬tij
,
from which we obtain both
u ∨

j
tij , (16)
¬u ∨

j
¬tij . (17)
Now, we can proceed, similarly as in Theorem 5.2. By induction (on the depth of Cn) AC0
d -Frege is
able to substitute tij with Dij where Dij is an AC0
d−1-formula over the x1,..., xn variables starting
with an 
. More precisely, by induction, we can prove that AC0
d -Frege proves both
tij ∨ ¬Dij , (18)
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.            
Frege Systems for Quantified Boolean Logic 9:23
¬tij ∨ Dij . (19)
Hence from (17) and (18) follows that ¬u ∨ 

j ¬Dij , which is an AC0
d -formula only over the
variables u, x1,..., xn. Hence, by the ∀red rule, we get

j
¬Dij . (20)
Similarly, from (16), we get first that 	
j (u ∨ tij ) and then using (19), we get 	
j (u ∨ Dij ),
which, again, is an AC0
d -formula over the variables u, x1,..., xn. By the ∀red rule, we get

j
Dij . (21)
From (20) and (21) follows immediately a contradiction.
From Theorem 5.10, we obtain a wealth of lower bounds for Res + ∀red.
Corollary 5.11. Let f (x1,..., xn ) be a Boolean function requiring exponential-size depth-3 circuits and let (Cn )n∈N be polynomial-size circuits (of unbounded depth) computing f . Then the QBFs
Q-Cn require exponential-size refutations in Frege AC0
1 + ∀red and hence, in particular, in Res + ∀red.
We now prove a separation of constant-depth Frege + ∀red systems. For this, we employ the
Sipser functions separating the hierarchy of constant-depth circuits. We quote the definition of
the Sipserd function from Boppana and Sipser [1990]:
Sipserd =

i1m1

i2m2

i3m3
··· 
id md
xi1i2i3 ...id ,
where  = 
 or 	 depending on the parity of d. The variables x1,..., xn appear as xi1i2i3 ...id
for ij  mj , where m1 = 
m/ logm, m2 = m3 = ··· = md−1 = m, md = 
dm logm/2 and m =
(n
√
2/d)
1/(d−1)
.
Corollary 5.12. Fix an integer d  2. Let (Cn
d )n∈N be a family of polynomial-size depth-(d + 3)
circuits computing the function Sipserd+3 (x1,..., xn ). Then the QBFs Q-Cn
d need exponential-size
refutations in Frege AC0
d + ∀red, but have polynomial-size refutations in Frege AC0
d+3 + ∀red.
Proof. The lower bound follows from Theorem 5.10 and from the result that for every d,
Sipserd+3 needs exponential-size depth-(d + 2) circuits [Håstad 1986]. Regarding the upper bound,
by constructionCn
d has depth d + 3 and polynomial-size. Hence, by Theorem 5.10, the family Q-Cn
d
has polynomial-size refutations in Frege AC0
d+3 + ∀red.
Note that the gap of size 1 in the circuit separation of Håstad [1986] increases to a gap of size
3 in our proof system separation, due to the transformation in Proposition 4.2. We highlight that
in contrast to Corollary 5.12 where our separating formulas are CNFs, a separation of the depth-d
Frege hierarchy with formulas of depth independent of d is a major open problem in propositional
proof complexity.
5.3 Characterizing QBF Frege and Extended Frege Lower Bounds
We finally address the question of lower bounds for Frege + ∀red or even EF + ∀red. Our next result
states that achieving such lower bounds unconditionally will either imply a major breakthrough
in circuit complexity or a major breakthrough in classical proof complexity. (Notice that it might
be much easier to obtain the disjunction than any of the disjuncts.)
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.                 
9:24 O. Beyersdorff et al.
Theorem 5.13. Let C be either P/poly or NC1. C -Frege + ∀red is not polynomially bounded if and
only if PSPACE  C or C -Frege is not polynomially bounded.7
Proof. Clearly if C -Frege is not polynomially bounded then C -Frege + ∀red is not polynomially
bounded. If PSPACE  C , then let f be a Boolean function in PSPACE but not in C . Since QBF is
PSPACE-complete there exists a QBF Qw φ  (w , x1,..., xn ) with a CNF φ such that
f (x1,..., xn ) ≡ Qw φ  (w , x1,..., xn ).
We define
Q-fn = ∃x1 ···∃xn∀u (u ↔ Qw φ  (w , x1,..., xn )),
which can be rewritten into formulas Θn in prenex form. Notice that the only winning strategy for
the universal player on both Q-fn and Θn is to compute u = f (x1,..., xn ). Therefore, the Strategy
Extraction Theorem together with f  C immediately implies super-polynomial lower bounds for
Θn in C -Frege + ∀red.
In the opposite direction, assume that C -Frege + ∀red is not polynomially bounded. Then there
is a sequence of true QBFs Q ψn such that ¬Q ψn do not have polynomial-size refutations in
C -Frege + ∀red. Let Q ψn have the form
∀x1∃y1 ···∀xn∃yn ψn (x1,..., xn,y1,...,yn ).
If PSPACE  C , then we are done. Otherwise, there are polynomial-size circuitsCi witnessing the
existential quantifiers in Q ψn. That is, for any x1,..., xn,y1,...,yn
n
i=1
(yi ↔ Ci (x1,..., xi,y1,...,yi−1)) → ψn (x1,..., xn,y1,...,yn ). (22)
We claim that (22) is a sequence of tautologies without polynomial-size EF proofs. Otherwise,
having ¬ψn, C -Frege can derive 

i yi  Ci (x1,..., xi,y1,...,yi−1) by a polynomial-size proof,
and so as in Theorem 4.5, C -Frege + ∀red can efficiently refute ¬Q ψn.
Recall that a problem is in uniform NC1 if it is in NC1 and, in addition, there is a polynomialtime algorithm that for each input length generates an NC1 circuit solving the problem. We remark that we do have a separation between uniform NC1 and PSPACE, because uniform NC1 ⊆ L
and L  PSPACE by the space hierarchy theorem. Therefore, choosing f ∈ PSPACE \ uniform NC1
and considering the prenex formulas Θn arising from Q-fn, we can infer the weaker result that
Frege + ∀red has no uniform short proofs of Θn.
6 RELATION OF QBF FREGE TO SEQUENT SYSTEMS AND BOUNDED ARITHMETIC
Having defined and analyzed the new QBF Frege systems, it is natural to ask how they compare
to classic sequent calculi—which have a long history for QBF [Cook and Morioka 2005; Dowd
1985; Egly 2012; Krajíček and Pudlák 1990]—and first-order theories of bounded arithmetic. After
reviewing the necessary prerequisites, we approach both of these questions in this section.
6.1 Background on Sequent Systems and Bounded Arithmetic
6.1.1 Sequent Calculi. Gentzen’s sequent calculus [Gentzen 1935] is a classical proof system,
both for first-order and propositional logic, cf. Krajíček [1995]. The propositional sequent calculus
LK operates with sequents Γ −→ Δ with the semantic meaning 	
φ ∈Γ φ |= 

ψ ∈Δ ψ.
7By NC1, we mean non-uniform NC1. Note that by the space hierarchy theorem it is known that PSPACE  uniform NC1,
but this does not suffice for Frege + ∀red lower bounds.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.              
Frege Systems for Quantified Boolean Logic 9:25
An important rule in LK is the cut rule
Γ −→ Δ,A A, Γ −→ Δ
Γ −→ Δ (cut rule),
where A is called the cut formula. Standard axioms such as 0 −→ and −→ 1 are included in the
system LK as well. LK is well known to be p-equivalent to Frege, cf. Krajíček [1995].
The quantified propositional calculus G, as defined by Cook and Morioka [2005], extends
Gentzen’s classical propositional sequent calculus LK by allowing quantified propositional formulas in sequents and by adopting the following extra quantification rules for ∀-introduction:
ϕ(x/ψ ), Γ −→ Δ
∀x ϕ, Γ −→ Δ (∀-l) Γ −→ Δ,ϕ(x/p)
Γ −→ Δ,∀x ϕ (∀-r)
and ∃-introduction
ϕ(x/p), Γ −→ Δ
∃x ϕ, Γ −→ Δ (∃-l) Γ −→ Δ,ϕ(x/ψ )
Γ −→ Δ, ∃x ϕ (∃-r).
For the rules ∀-l and ∃-r, φ(x/ψ ) is the result of substituting ψ for all free occurrences of x in φ.
The formula ψ may be any quantifier-free formula (i.e., without bounded variables) that is free
for substitution for x in φ (i.e., no free occurrence of x in φ is within the scope of a quantifier Qy
such that y occurs in ψ). The variable p in the rules ∀-r and ∃-l must not occur free in the bottom
sequent.
For i  0, Gi is a subsystem of G with cuts restricted to prenex Σq
i ∪ Πq
i -formulas. On propositional formulas G0 is p-equivalent to Frege and G1 is p-equivalent to EF, cf. Krajíček [1995].
The systems G and Gi were originally introduced slightly differently, cf. Krajícek and Takeuti
[1992], Krajíček [1995], and Krajíček and Pudlák [1990], not restricting the formulas ψ in ∀-l and
∃-r to be quantifier-free, and defining Gi as the system G allowing only Σq
i -formulas in sequents.
Hence, Gi’s could not prove all true QBFs. We will, however, use the redefinition of these systems
by Cook and Morioka [2005]. Notably, (for Cook and Morioka’s definition) Jerábek and Nguyen
[2011] showed that the system Gi with cuts restricted to prenex Σq
i -formulas is p-equivalent to
Gi with cuts restricted to prenex Πq
i -formulas and p-equivalent to Gi with cuts restricted to (not
necessarily prenex) Σq
i ∪ Πq
i -formulas. Moreover, these equivalences hold as well for the tree-like
versions of these systems. Cook and Morioka [2005] also proved that their definition of Gi is pequivalent to Gi from Krajíček and Pudlák [1990] for i  0 and prenex Σq
i ∪ Πq
i -formulas (so, by
Jerábek and Nguyen [2011], also for non-prenex ones). Finally, the systems Gi and tree-like Gi have
quite constructive witnessing properties. Whenever there are polynomial-size tree-like G1 proofs of
formulas ∃y An (x,y) for An (x,y) ∈ Σq
1 , there exist polynomial-size circuits Cn witnessing the existential quantifiers, i.e., the formula An (x,Cn (x)) holds, cf. Cook and Morioka [2005], Theorem 7.
In case of G0, the circuits witnessing Σq
1 -formulas are from NC1, cf. Cook and Morioka [2005], Theorem 9. The witnessing theorems can be generalized to systems tree-like Gi and Gi for i  1 w.r.t.
Σq
i -formulas and witnessing functions corresponding to higher levels of the polynomial hierarchy.
6.1.2 Bounded Arithmetic. In first-order logic, it is customary to consider the language L =
{0, S, +, ·, ,  x
2 , |x |, #}, where the function |x | is intended to mean “the length of the binary representation of x” and x#y = 2|x |·|y |
.
A quantifier is bounded if it has the form ∃x, x  t or ∀x, x  t for x not occurring in the term t.
A bounded quantifier issharply bounded if t has the form |s| for some terms. By Σb
0 (=Πb
0 = Δb
0 ), we
denote the set of all formulas in the language L with all quantifiers sharply bounded. Fori  0, the
sets Σb
i+1 and Πb
i+1 are defined inductively. Σb
i+1 is the closure of Πb
i under bounded existential and
sharply bounded quantifiers, and Πb
i+1 is the closure of Σb
i under bounded universal and sharply
bounded quantifiers; that is, the complexity of bounded formulas in the language L (formulas with
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.   
9:26 O. Beyersdorff et al.
all quantifiers bounded) is defined by counting the number of alternations of bounded quantifiers,
ignoring the sharply bounded ones. For i > 0, Δb
i denotes Σb
i ∩ Πb
i .
Bounded formulas capture the polynomial hierarchy: for any i > 0 the ith level Σp
i of the polynomial hierarchy coincides with the sets of natural numbers definable by Σb
i -formulas. Dually for
Πp
i and Πb
i .
Buss [1986a] introduced theories of bounded arithmetic Si
2, Ti
2 for i  1 in the language L. The
axioms of Si
2 consist of a set of basic axioms defining properties of symbols from L, cf. Krajíček
[1995], and length induction Σb
i -LIND, which is the following scheme for Σb
i -formulas A (or equivalently, for A ∈ Πb
i , in which case, we speak of Πb
i -LIND):
A(0) ∧ ∀x (A(x) → A(x + 1)) → ∀x A(|x |).
Theories Ti
2 are defined similarly, but here the induction scheme is
A(0) ∧ ∀x (A(x) → A(x + 1)) → ∀x A(x)
for A ∈ Σb
i .
By FPΣp
i [O(log n)], we denote the set of functions computed by a polynomial-time Turing machine making at most O(logn) queries to a Σp
i -oracle. FPΣp
i is defined analogously but without the
restriction on the number of queries. Ti
2 proves the totality of functions FPΣp
i computable in polynomial time under a Σp
i oracle, cf. Krajíček [1995], Theorem 6.1.2. More precisely, for any f ∈ FPΣp
i
there is a Σb
i+1-formula f (x) = y such that Ti
2  ∀x∃y f (x) = y. In the same way, Si
2 proves the totality of functions in FPΣp
i [O(logn)], which are computed in polynomial time with at mostO(logn)
queries to a Σp
i -oracle, cf. Krajíček [1995], Theorem 6.2.2. By Parikh’s theorem, Ti
2  ∃y f (x) = y
implies Ti
2  ∃y (|y|  p(|x |) ∧ f (x) = y) for some polynomial p, and the same is true for Si
2, cf.
Buss [1986a] and Parikh [1971].
Si
2 can be seen as a first-order non-uniform version of tree-like Gi, i  1. First, for j  1 any Σb
j -
formula φ(x) can be translated into a sequence φ(x)n of Σq
j -formulas, where n denotes the size
of the input x in binary (cf. Krajíček [1995], Definition 9.2.1). Then, for i, j  1, whenever Si
2  A
for A ∈ Σb
j , there is a polynomial p such that formulas An have tree-like Gi-proofs of size p(n).
This also holds for Ti
2 in place of Si
2 if tree-like Gi is replaced by Gi. The ability to use arbitrary
j is due to Cook and Morioka [2005] (Theorem 3), who generalized a standard result, cf. Krajíček
[1995] (Theorem 9.2.6), which worked for j = i.
If A ∈ Πb
1 , then we abuse notation and also denote by An the propositional formulas obtained
as in An, but leaving the universally quantified variables free. S1
2  A for A ∈ Πb
1 implies that
S1
2 proves the existence of polynomial-size tree-like G1-proofs of propositional formulas An, cf.
Krajíček [1995] (Theorems 9.2.6 and 9.2.7).
6.2 Intuitionistic Logic Corresponds to Extended Frege for QBFs
The main information on strong propositional and QBF systems stems from their correspondence
to first-order theories of bounded arithmetic, cf. Beyersdorff [2009], Cook and Nguyen [2010], and
Krajíček [1995]. In this sense, tree-like G1 corresponds to S1
2 and G1 to T1
2 as explained above. Here,
we will establish such a correspondence between first-order intuitionistic logic and EF + ∀red.
Buss [1986b] developed an intuitionistic version of S1
2, denoted IS1
2, and showed that for any formula A, IS1
2  ∃y A(x,y) implies the existence of a polynomial-time function f such thatA(x, f (x))
holds. This witnessing property resembles the Strategy Extraction Theorem for EF + ∀red. Using
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020. 
Frege Systems for Quantified Boolean Logic 9:27
the formalized Strategy Extraction Theorem, we can make the correspondence between these systems formal.8
First, we recall the definition of IS1
2 by Cook and Urquhart [1993]. It is equivalent to Buss’ original
definition, cf. Buss [1986b]. IS1
2 is a theory in the language L (like S1
2), with underlying intuitionistic
predicate logic, a set of basic axioms defining properties of symbols from L, and a polynomial
induction scheme for Σb+
1 -formulas A:
A(0) ∧ ∀x

A

x
2

→ A(x)

→ ∀x A(x),
where Σb+
1 -formulas are Σb
1 -formulas without negation and implication connectives. S1
2 is Σb
0 -
conservative overIS1
2, cf. Cook and Urquhart [1993] (Corollary 1.7); that is, any Σb
0 formula provable
in S1
2 is provable already in IS1
2.
We will also use Cook and Urquhart’s conservative extension of IS1
2 denoted IPV, cf. Cook
and Urquhart [1993] (Chapter 4 and Theorem 4.12). IPV is defined by adding intuitionistic predicate logic to Cook’s theory PV, cf. Cook [1975]. The language of IPV consists of symbols for all
polynomial-time functions. The hierarchy of formulas Πb
i (PV) is defined analogously as Πb
i but in
the language of IPV. Also, propositional translations An for Πb
1 (PV)-formulasA are defined analogously as in the case of A ∈ Πb
1 . Consequently, IPV  A for A ∈ Πb
1 (PV) implies that propositional
formulas An have polynomial-size EF proofs, cf. Krajíček [1995] (Theorem 9.2.7).
Cook and Urquhart [1993] (Corollary 8.18) generalized Buss’ witnessing theorem: Whenever
IPV  ∀x∃y A(x,y) for an arbitrarily complex formula A, then there is a polynomial-time function
f (with an IPV function symbol f ) such that IPV  ∀x A(x, f (x)).
We are now ready to derive the correspondence between IS1
2 and EF + ∀red. The correspondence
consists of two parts (cf. Beyersdorff [2009]). For the first part, we translate first-order formulas
φ into sequences of QBFs [Krajíček and Pudlák 1990] and show that translations of provable IS1
2
formulas have short EF + ∀red proofs.
Theorem 6.1. If IS1
2 proves a statementT in prenex form, then there exist polynomial-size EF + ∀red
refutations of ¬T n where n denotes the size of the input variables in binary.
Proof. By Cook and Urquhart’s improvements of Buss’ witnessing theorem, if IS1
2 proves T of
the form
∀x1∃y1 ···∀xn∃yn T 
(x1,..., xn,y1,...,yn )
for T  ∈ Σb
0 , then there is an IPV-function f1 (x1) such that
IPV  ∀x1∀x2∃y2 ···∀xn∃yn T 
(x1,..., xn, f1 (x1),y2,...,yn ).
Iterating this argument all existential quantifiers of T can be witnessed provably in IPV by
polynomial-time functions f1,..., fn. Therefore, IPV proves the Πb
1 (PV) formula
φ =
n
i=1
(yi ↔ fi (x1,..., xi )) → T 
(x1,..., xn,y1,...,yn ) (23)
and the formulas φn have polynomial-size EF proofs. EF + ∀red can now refute ¬T n in polynomial size by deriving 

i (yi  fi (x1,..., xi )) and cutting all the disjuncts as in the proof of
Theorem 4.5.
8It could be tempting to expect that an adequate counterpart to IS1
2 would be intuitionistic propositional logic. However,
intuitionistic propositional logic admits the feasible interpolation property, cf. Buss and Mints [1999], while IS1
2 can (constructively) prove ∀x, z [A(x, y) ∨ B(x, z)], in principle, without the existence of an efficient interpolant. It is also known,
cf. Ghasemloo and Pich [2013], that IS1
2  ∀y A(x, y) ∨ ∀z B(x, z) implies the existence of an efficient interpolating circuit,
but moving the universal quantifiers inside the disjunction is a priori not allowed in intuitionistic logic.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.  
9:28 O. Beyersdorff et al.
The second part of the correspondence consists in proving the soundness of the proof systems
in the first-order theory. For this, we need to express the correctness of EF + ∀red by QBFs. This is
typically done by the reflection principle of a proof system P, stating that whenever φ has a P-proof
(respectively, a P-refutation), then φ is true (respectively, false).
Here, the Formalized Strategy Extraction Theorem allows us to express the reflection principle
of EF + ∀red by a Πb
1 -formula Ref(EF + ∀red). More precisely, we define Ref(EF + ∀red) as the Πb
1 -
formula expressing that if π is a proof of a QBF, then circuits Ci (x1,..., xi,y1,...,yi−1) obtained
as in the Strategy Extraction Theorem witness the existential quantifiers in the QBF as in the
statement of Theorem 6.2 below.
To show this reflection principle in IS1
2, we return again to the Strategy Extraction Theorem and
provide a different formalization than in Theorem 4.4, this time in the theory S1
2.
Theorem 6.2 (Formalized Strategy Extraction). There is a linear-time algorithm A such that
S1
2 proves the following: Assume that π is an EF + ∀red refutation of a QBF ψ of the form
∃x1∀y1 ···∃xn∀yn φ(x1,..., xn,y1,...,yn ),
where φ ∈ Σq
0 . Then A(π ) outputs n circuits C1 (x1),..., Cn (x1,..., xn,y1,...,yn−1) defining a winning strategy for the universal player on formula ψ; that is,
∀x1 ···∀xn∀y1 ···∀yn
⎡
⎢
⎢
⎢
⎢
⎣
n
i=1
(yi ↔ Ci (x1,..., xi,y1,...,yi−1)) → ¬φ(x1,..., xn,y1,...,yn )
⎤
⎥
⎥
⎥
⎥
⎦
.
Proof. It is just sufficient to inspect the proof of the Strategy Extraction Theorem from Section 4
and point out that it essentially uses a Πb
1 -induction on the number of steps in the proof π; that
is, Πb
1 -LIND available in S1
2. For convenience of the reader, we recap here what was the approach.
Let π = (L1,..., Ls ) be an EF + ∀red refutation of the QBF Q φ given as in Theorem 6.2 and put
πs = ∅, πi = (Li+1,..., Ls ) for i < s,
φ0 = φ, φi = φ ∧ L1 ∧···∧ Li for i > 0.
We show by downward induction on i, that from πi it is possible to construct in linear time a
winning strategy
σi = {Ci
1 (x1),...,Ci
n (x1,..., xn,y1,...,yn−1)}
for the universal player for the QBF Q φi . The statement of the Formalized Strategy Extraction
Theorem corresponds to the case i = 0.
In the base case, φs contains a contradiction, and the winning strategy can be defined as the set
of trivial circuits {0,..., 0}. Assume now that σi is a winning strategy for Q φi . If Li is derived by
an EF rule, then we set σi−1 = σi
. Assume now that Li = Lj[u/B] is the result of an application of
a ∀red rule on Lj where u is the rightmost variable in Lj . We define Ci−1
l = Ci
l if u  yl ; otherwise,
we set
Ci−1
l (z) =

B(z) if Lj[u/B](z) = 0,
Ci
l (z) if Lj[u/B](z) = 1.
This constructs circuitsCi
l from πi by a standardO(|πi |)-time algorithm. To show that the strategies σi are winning for any 0  i  |π |, we need to analyze the inductive step.
Assume that σi is the winning strategy for the universal player on Q φi . If Li is derived by
an EF rule, then the winning strategy for Q φi works also for Q φi−1, because a falsification of
Li by a given assignment implies a falsification of one of its predecessors. If Li is the result of an
application of ∀red, thenCi−1
l (z) is redefined only if Lj[u/B](z) = 0. For z such that Lj[u/B](z) = 1,
the strategy σi has to work also for Q φi−1. Therefore, σi−1 is a winning strategy for the universal
player on Q φi−1.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.    
Frege Systems for Quantified Boolean Logic 9:29
An NP predicate is a set of binary strings accepted by a non-deterministic polynomial-time
machine, and similarly for coNP predicates. The statement that a strategy σ is winning for the
universal player on Q ψ is a coNP predicate (given π) expressible as a well-behaved Πb
1 -formula.
The induction we used is on the number of steps in π. Hence, the presented proof is an S1
2-proof.
This implies the second part of the correspondence of IS1
2 to EF + ∀red.
Corollary 6.3. IS1
2 proves Ref(EF + ∀red).
Proof. The claim follows from Theorem 6.2 together with the Σb
0 -conservativity of S1
2 over IS1
2
[Cook and Urquhart 1993].
Corollary 6.3 implies that EF + ∀red is the weakest proof system that allows short proofs of all IS1
2
theorems, i.e., whenever Theorem 6.1 holds for a “decent” proof system P in place of EF + ∀red, then
P p-simulates EF + ∀red on QBFs: If Theorem 6.1 holds for a proof system P, then by Corollary 6.3,
there are polynomial-size P-proofs of Ref(EF + ∀red)n. Hence, if π is an EF + ∀red proof of a QBF
ψ, then P has |π |
O (1)
-size proofs of ψ with the existential quantifiers witnessed by some circuits.
By P being decent, we mean that P can introduce efficiently the existential quantifiers in place of
the witnessing circuits and this way proveψ efficiently in the size of π; that is, P is decent if it can
derive ψ efficiently in the length of the shortest derivation of ψ witnessed by some circuits.
However, EF + ∀red is intuitively the strongest proof system for which IS1
2 proves the reflection
principle. Technically, this only holds for proof systems that admit the Strategy Extraction Theorem, as for other systems, we would need to define the reflection principle as a more complex
statement. (Nevertheless, IS1
2 provability of the reflection principle for Σq
k -formulas for any fixed
k implies strategy extraction for the given proof system.)
6.3 Gentzen and Frege for QBFs
We now compare the classic Gentzen systems with our new Frege systems. The two formalisms
are well known to be equivalent in the classical propositional case [Krajíček 1995]. By applying the
formalized Strategy Extraction Theorem, we show that Gentzen systems simulate Frege systems
in the QBF context (cf. Figure 1 in Section 1.1). However, the opposite simulations (Gentzen by
Frege) are very likely false as we show by a number of conditional separations.
Theorem 6.4. Tree-like G1 p-simulates EF + ∀red.
Proof. By Theorem 4.5, any EF + ∀red refutation π of a QBF ψ of the form
∃x1∀y1 ···∃xn∀yn φ(x1,..., xn,y1,...,yn )
where φ ∈ Σq
0 can be transformed in time |π |
O (1) into an EF proof of
n
i=1
(yi ↔ Ci (x1,..., xi,y1,...,yi−1)) → ¬φ(x1,..., xn,y1,...,yn )
for certain circuits Ci . We want to derive ¬ψ in tree-like G1. Since we do not distinguish between
a refutation of ψ and provability of ¬ψ, this will prove the theorem.
Claim 6.5. There is a |π |
O (1)
-size tree-like G1 proof of the following sequent
{yi = Ci (x1,..., xi,y1,...,yi−1)}
n
i=1 −→ ¬φ(x1,..., xn,y1,...,yn )
where the encoding of circuits Ci might use some auxiliary variables.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.  
9:30 O. Beyersdorff et al.
Proof of claim. To see that the claim holds, note first that by the p-equivalence of EF and
tree-like G1 (cf. Krajíček [1995]), the EF proof obtained above can be turned into a |π |
O (1)
-size
tree-like G1-proof of the formula
¬

n
i=1
yi ↔ Ci (x1,..., xi,y1,...,yi−1)

∨ ¬φ.
This proof can be easily modified so the ∨ connective is not introduced, leading to a |π |
O (1)
-size
tree-like G1-proof of the sequent
−→ ¬

n
i=1
yi ↔ Ci (x1,..., xi,y1,...,yi−1)

, ¬φ.
Moving ¬(
	n
i=1 yi = Ci (x1,..., xi,y1,...,yi−1)) from the succedent to the antecedent, we obtain
n
i=1
(yi ↔ Ci (x1,..., xi,y1,...,yi−1)) −→ ¬φ.
Finally, tree-like G1 derives the sequent we want by “not introducing” ∧ in the antecedent. This
proves the claim.
Moving ¬φ to the succedent, applying ∀-l and ∃-l introductions, tree-like G1 then derives
∀yn φ(x1,..., xn,y1,...,yn ), Γ, ∃yn (yn ↔ Cn (x1,..., xn,y1,...,yn−1)) −→
where Γ = {yi ↔ Ci (x1,..., xi,y1,...,yi−1)}
n−1 i=1 .
As tree-like G1 proves efficiently −→ ∃y (y ↔ C(x)) for any circuit C, we can cut the formula
∃yn (yn ↔ Cn (x1,..., xn,y1,...,yn−1)) out of the antecedent and derive
∀yn φ, {yi ↔ Ci (x1,..., xi,y1,...,yi−1)}
n−1 i=1 −→ .
Now, we use ∃-l introduction to obtain
∃xn∀yn φ, {yi ↔ Ci (x1,..., xi,y1,...,yi−1)}
n−1 i=1 −→ .
In this way, we can gradually cut out all remaining formulas from the antecedent, quantify all
variables, move ψ to the succedent, and derive ¬ψ in tree-like G1 by a proof of size |π |
O (1)
.
To introduce the quantifier prefix of ψ in the previous proof, we needed to cut Σq
1 -formulas. We
would like to use a similar proof to simulate Frege + ∀red by tree-like G0. However, tree-like G0
is allowed to cut only Σq
0 -formulas. Therefore, we obtain just a simulation of Frege + ∀red by
tree-like G0 where the proven sequent in tree-like G0 contains a non-empty (easily derivable)
antecedent.
Theorem 6.6. There is a polynomial-time function t such that given any Frege + ∀red refutation
of a QBF ψ of the form
∃x1∀y2 ···∃xn∀yn φ(x1,..., xn,y1,...,yn )
where φ ∈ Σq
0 , t(π ) is a tree-like G0 proof of the sequent
∀x1∃y1 ···∀xn∃yn
n
i=1
yi ↔ Ci (x1,..., xi,y1,...,yi−1) −→ ¬ψ
for some formulas Ci . Note that the antecedent has a tree-like G0 proof of size |π |
O (1)
.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.    
Frege Systems for Quantified Boolean Logic 9:31
Proof. By Theorem 4.5, any Frege + ∀red refutation π of a QBF ψ can be transformed in time
|π |
O (1) into a -Frege proof of
n
i=1
(yi ↔ Ci (x1,..., xi,y1,...,yi−1)) → ¬φ(x1,..., xn,y1,...,yn )
for certain formulasCi . Analogously as in the proof of Theorem 6.4, we efficiently obtain a |π |
O (1)
-
size tree-like G0 proof of
n
i=1
yi ↔ Ci (x1,..., xi,y1,...,yi−1) −→ ¬φ.
Applying rules ∀-l, ∃-l, ∀-l, ∃-l (in this order), we derive
∃xn∀yn φ,∀xn∃yn
n
i=1
yi ↔ Ci (x1,..., xi,y1,...,yi−1) −→ .
In this way, we efficiently introduce all quantifiers, then move ψ to the succendent, and derive
the required sequent in tree-like G0.
We now prove some conditional separations between Gentzen and Frege systems for QBF. As
we saw in Section 5.3, improving these separations to unconditional results tightly corresponds to
major open problems in circuit complexity and proof complexity.
6.3.1 Formulas Hard in Gentzen, but Easy in Frege. We first give formulas (conditionally) hard
for G0, but easy for EF + ∀red.
Theorem 6.7. If P/poly  NC1, then there are Σq
1 -formulas with polynomial-size EF + ∀red proofs
but without polynomial-size G0 proofs.
Proof. Let f be a function in P/poly. Then EF + ∀red has simple polynomial-size proofs of Σq
1
formulas ∃y ∃z f (x) = y expressing the totality of f with auxiliary variables z representing nodes
of a polynomial-size circuit computing f . The EF + ∀red proof refutes the propositional formula
f (x)  y by gradually replacing each variable from z,y by the circuit it represents. If the totality of
f has polynomial-sizeG0 proofs, then by the Σq
1 witnessing property, cf. Cook and Morioka [2005]
(Theorem 9), f is in NC1.
Notably, in Section 4.2, we showed that Frege + ∀red and EF + ∀red are p-equivalent to their
tree-like versions. This is open for G0 and G1, thus providing some further evidence for the incomparability of Gentzen and Frege in QBF.
6.3.2 Formulas Easy in Gentzen, but Hard in Frege. We now provide three different properties that are easy for QBF Gentzen systems, but hard for EF + ∀red. Our first conditional result
shows that there are Σq
2 -formulas with polynomial-size tree-like G1 proofs but no polynomial-size
EF + ∀red proofs, and this result generalizes to stronger systems.
Theorem 6.8. Let i  1. Assume f ∈ FPΣp
i is hard for P/poly. Then the formulas ∃y (|y|
p(|x |) ∧ f (x) = y)n, where p is a polynomial and f (x) = y is expressed by a Σb
i+1-formula, have
polynomial-size Gi proofs and require super-polynomial-size EF + ∀red proofs. If f ∈ FPΣp
i [O(logn)],
then Gi can be replaced by tree-like Gi.
Proof. Since Ti
2 proves the totality of FPΣp
i functions [Buss 1986a], it proves the totality of f
and the proof can be transformed into a sequence of polynomial-size Gi proofs [Cook and Morioka
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.     
9:32 O. Beyersdorff et al.
2005; Krajíček and Pudlák 1990]. If the totality of f can be shown by polynomial-size proofs in
EF + ∀red, then, by the Strategy Extraction Theorem, f is in P/poly.
Similarly, Si
2 proves the totality of FPΣp
i [O(logn)] functions and such proofs translate into sequences of polynomial-size tree-like Gi proofs [Buss 1986a; Cook and Morioka 2005; Krajíček and
Pudlák 1990].
It seems that the separation above of tree-like G1 and EF + ∀red by Σq
2 -formulas cannot be improved to Σq
1 -formulas, as it is tight in the following sense. If we had Σq
1 -formulas ∃y An (x,y) with
polynomial-size tree-like G1 proofs but without polynomial-size EF + ∀red proofs, then this would
imply that EF is not polynomially bounded: By the witnessing theorem for tree-like G1, cf. Cook
and Morioka [2005] (Theorem 7), there would be polynomial-size circuits Cn such that formulas
An (x,Cn (x)) are true, and so ¬An (x,Cn (x)) would be hard to refute in EF.
The QBF proof systems tree-like G1 and EF + ∀red can be conditionally separated also on the
bounded collection scheme.
Definition 6.9. The bounded collection scheme BB(φ) is the formula
∃i < |a| ∃w < t(a) ∀u < a ∀j < |a| (φ(i,u) → φ(j,[w]j)),
where φ(i,u) is a formula that can have other free variables, [w]j is the jth element of the sequence
coded by w, and t(a) is a concrete L-term depending on the choice of the encoding of sequences.
Roughly, BB(φ) says that u’s witnessing φ(i,u) can be collected in a sequence w:
∀i < |a| ∃u < a, φ(i,u) → ∃w < t(a) ∀j < |a|, φ(j,[w]j).
Theorem 6.10. The QBF proof system tree-like G1 has polynomial-size proofs of BB(φ)n for all
φ ∈ Σb
1 . In contrast, there exists φ ∈ Σb
1 such that formulas BB(φ)n are hard for EF + ∀red unless
each polynomial-time permutation with n inputs can be inverted by polynomial-size circuits with
probability at least 1 − 1/n.
Proof. The upper bound follows from the S1
2-provability of BB(φ) for φ ∈ Σb
1 , cf. Buss [1986a]
(Theorem 14), and its transformation to tree-like G1 proofs [Cook and Morioka 2005; Krajíček
and Pudlák 1990]. For the lower bound, we will use a result by Cook and Thapen [2006] showing
that Cook’s theory PV does not prove BB(φ) for all φ ∈ Σb
0 unless factoring is in probabilistic
polynomial time.
Let a = 2n and φ(i,u) be the formula f (u) = [y]i for a polynomial-time permutation f (defined
by a Σb
1 formula), and y encoding a sequence of n strings of length n.
Assume that EF + ∀red has polynomial-size proofs of BB(φ)n. By the Strategy Extraction Theorem, there are polynomial-size circuits B, C such that
∃u < 2n, f (u) = [y]C(y) → ∀j < n, f ([B(y)]j) = [y]j . (24)
To invert f , we proceed as follows: Given z ∈ {0, 1}
n, pick randomly n strings si ∈ {0, 1}
n and let
i0 be a position (a non-uniform advice) such that Pry [C(y) = i0]  1/n where y’s are sequences
of n strings of length n. Define yz,s to be the sequence of elements z, f (s1),..., f (sn−1) ordered
so [yz,s ]i0 = z and let xz,s be the sequence of z,s1,...,sn−1 ordered so f ([xz,s ]i ) = [yz,s ]i for
i  i0. For random strings z,s1,...,sn−1, we have that yz,s is a random sequence of n strings
of length n and Prz,s1,...,sn [C(yz,s ) = i0]  1/n. Consequently, with probability at least 1 − 1/n,
f ([xz,s ]C(yz,s )) = [yz,s ]C(yz,s ) holds and by Equation (24) the inverse of f on z is [B(yz,s )]i0 .
While the previous two results exhibited formulas easy for tree-like G1 and hard for EF + ∀red,
we now show that even tree-like G0 can prove Σq
2 -formulas hard for EF + ∀red (modulo a hardness
assumption).
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.     
Frege Systems for Quantified Boolean Logic 9:33
Fig. 2. The tree-like G0 derivation in the proof of Theorem 6.11.
For this, we use a result by Bonet et al. [2000], who showed that Frege systems do not admit the so-called feasible interpolation property unless factoring of Blum integers is solvable by
polynomial-size circuits. (A Blum integer is the product of two distinct primes, which are both
congruent 3 modulo 4.)
It is possible to separate tree-like G0 and EF + ∀red even under the assumption NP  P/poly.
The separating Σq
2 -formulas are of the form
∀x ∃y ∀z (Sat(x,y) ∨ ¬Sat(x, z))
and state that each propositional formula is either satisfiable or unsatisfiable. These formulas have
polynomial-size tree-like G0 proofs, because their two-sorted formulation is easily provable in the
theory known as VNC1, the two-sorted version of tree-like G0, cf. Cook and Morioka [2005]. (In
fact, this is already provable in the two-sorted logic without the extra axioms of VNC1.) However,
if these formulas were easy for EF + ∀red, by strategy extraction, we would get polynomial-size
circuits for SAT. As presenting this argument formally would require to introduce two-sorted theories of bounded arithmetic and the corresponding machinery, we prove here only the separation
based on the stronger assumption of the hardness of factoring.
Theorem 6.11. There are Σq
2 -formulas with polynomial-size tree-like G0 proofs. However, assuming factoring of Blum integers is not computable by polynomial-size circuits, these formulas require
EF + ∀red proofs of super-polynomial size.
Proof. Bonet et al. [2000] showed that there are propositional formulas A0 (x,y), A1 (x, z) with
common variables x such that A0 (x,y) ∨ A1 (x, z) have polynomial-size -Frege proofs but, unless
factoring of Blum integers is computable by polynomial-size circuits, there are no polynomial-size
circuits C(x) recognizing which of A0 (x,y) or A1 (x, z) holds for a given x.
Frege is p-equivalent to tree-like G0 on propositional formulas [Krajíček 1995] and so it is possible to derive in tree-like G0 the sequents in Figure 2.
Therefore, the Σq
2 -formulas
∃b ∀y∀u ((A0 (x,y) ∧ ¬b) ∨ (A1 (x,u) ∧ b))
have polynomial-size tree-like G0 proofs.
If these formulas had polynomial-size EF + ∀red proofs, then, by the Strategy Extraction Theorem, there would be polynomial-size circuits computing b from x and thus recognizing which of
A0 (x,y) and A1 (x,u) holds.
We remark that the assumptions of Theorems 6.10 and 6.11 are stronger than the assumption
of Theorem 6.8. However, while factoring forms a good candidate for a one-way function, it is not
known if the existence of one-way functions implies the existence of one-way permutations.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.  
9:34 O. Beyersdorff et al.
7 CONCLUSION
Our work opens up two lines of research that we believe might have a significant influence on
QBF proof complexity and beyond.
Exploring new QBF proof systems. The first of these is the study of natural and powerful QBF
proof systems that correspond to ideas developed in propositional proof complexity for many
years. While we concentrate here on the hierarchy C -Frege + ∀red of new QBF Frege systems, our
definitions introduce meaningful versions of algebraic and geometric proof systems for QBF. These
systems will be very interesting to study from a theoretical perspective and also might provide an
important stimulus on QBF solving—analogous to the potential of integer linear programming and
polynomial calculus for SAT solving.
Understanding the transfer from circuit to proof complexity. As far as we know, for the first time
in the literature, our lower bound technique via strategy extraction gives a formal and rigorous
account on the relation between a circuit class C and proof systems using lines from C . Building
on the previous work of Beyersdorff et al. [2015], we establish this relation for a full hierarchy of
QBF systems. This yields very strong results in QBF proof complexity. In the recent survey of Buss
[2012], the propositional versions of our results C.(i) and (iii) in Section 1.1 are referenced as “the
main open problems at the ‘frontier’ of Cook’s program.”
We believe that this transfer has the potential to generate lots of further research, both in QBF
and indeed for further logics, possibly even including the most important classical propositional
case. As for QBFs, the hard formulas Q-f that we generate from a Boolean function f have a
special syntactic form, i.e., for all functions we use here they are prefixed by ∃∀∃. Can we also
apply our technique to conceptually different types of QBFs? It is also possible that similar ideas are
effective for further logics, possibly modal or intuitionistic logics, as they share the same PSPACE
complexity, and strong lower bounds are known for Frege systems in these logics as well [Hrubeš
2009; Jeřábek 2009].