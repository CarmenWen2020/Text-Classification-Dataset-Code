We define and investigate Frege systems for quantified Boolean formulas (QBF). For these new proof systems,
we develop a lower bound technique that directly lifts circuit lower bounds for a circuit class C to the QBF
Frege system operating with lines from C . Such a direct transfer from circuit to proof complexity lower
bounds has often been postulated for propositional systems but had not been formally established in such
generality for any proof systems prior to this work.
This leads to strong lower bounds for restricted versions of QBF Frege, in particular an exponential lower
bound for QBF Frege systems operating with AC0[p] circuits. In contrast, any non-trivial lower bound for
propositional AC0[p]-Frege constitutes a major open problem.
Improving these lower bounds to unrestricted QBF Frege tightly corresponds to the major problems in
circuit complexity and propositional proof complexity. In particular, proving a lower bound for QBF Frege
systems operating with arbitrary P/poly circuits is equivalent to either showing a lower bound for P/poly or
for propositional extended Frege (which operates with P/poly circuits).
We also compare our new QBF Frege systems to standard sequent calculi for QBF and establish a correspondence to intuitionistic bounded arithmetic.
CCS Concepts: ‚Ä¢ Theory of computation ‚Üí Proof complexity; Circuit complexity; Complexity theory
and logic;
Additional Key Words and Phrases: QBF proof complexity, Frege systems, sequent calculus, intuitionistic
logic, strategy extraction, lower bounds, simulations
1 INTRODUCTION
Proof complexity investigates how difficult it is to prove theorems in different formal systems.
The main question asks, given a formula œÜ and a proof system P, typically composed of axioms
and rules, what is the size of the smallest proof of œÜ in P? This question bears tight and fruitful
relations to a number of further areas, in particular to computational complexity, where lower
bounds to the size of proofs offer an approach towards the separation of complexity classes (Cook‚Äôs
Programme) and to first-order logic (bounded arithmetic theories and their separations). More
recently, the tremendous success of SAT solving has been a main driver for proof complexity, as
the analysis of proof systems underlying SAT solvers provides the main theoretical framework
towards understanding the power and limitations of solving, cf. the survey by Buss [2012].
The bulk of research in proof complexity has concentrated on proof systems for classical propositional logic. Regarding the central question above, propositional proof complexity has made enormous progress over the past three decades in showing tight lower and upper bounds for many principles in various proof systems. Arguably even more important, a number of general lower bound
techniques have been developed that can be employed to show lower bounds to the size of proofs.
These include the seminal size-width relationship by Ben-Sasson and Wigderson [2001], the feasible interpolation technique of Kraj√≠ƒçek [1997], or game-theoretic techniques (cf. the overview in
Beyersdorff and Kullmann [2014]).
Notwithstanding these advances, some of the most natural proof systems have resisted all attempts for lower bounds for decades. Frege systems (also known as Hilbert-type systems) are the
typical textbook calculi composed of axiom schemes and rules, and no non-trivial lower bounds are
known for Frege. While the power of Frege does not depend on the choice of axioms or rules [Cook
and Reckhow 1979], their strength can be calibrated by restricting the class of allowed formulas.
In particular, a hierarchy of Frege systems can be obtained by considering Boolean circuits of
increasing strength as lines in Frege. These circuit classes compose the standard non-uniform
classes: AC0, which is the class of Boolean functions computed by families of polynomial-size
constant-depth circuits with unbounded fan-in; AC0[p], which is similar to AC0 but allows modp gates; and TC0, which additionally allows threshold gates. Even stronger, NC1 is composed of
the class of Boolean functions computed by families of polynomial-size logarithmic-depth circuits
with bounded fan-in and P/poly of functions with polynomial-size circuits in general. For uniform
families of circuits, one further imposes the condition that the circuit family can be generated
efficiently. Here, we typically consider non-uniform families, where we just require existence of the
family of small circuits as above. This is analogous to the non-uniform model in proof complexity,
where again only the existence of small proofs for a sequence of formulas is required. The circuit
classes are ordered as AC0 ‚äÇ AC0[p] ‚äÇ TC0 ‚äÜ NC1 ‚äÜ P/poly, giving rise to a similar hierarchy of
Frege systems.
While the strongest non-uniform lower bounds known in circuit complexity hold for the class
AC0[p] [Razborov 1987; Smolensky 1987], AC0-Frege is the strongest of the above Frege systems
with non-trivial lower bounds [Ajtai 1994; Kraj√≠ƒçek et al. 1995; Pitassi et al. 1993]. Despite enormous efforts, all attempts to transfer Razborov‚Äôs and Smolensky‚Äôs AC0[p] circuit lower to a proof
size lower bound in AC0[p]-Frege have failed so far. More widely, it seems the common belief in
the proof complexity community that substantial progress in circuit complexity would also give
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.
Frege Systems for Quantified Boolean Logic 9:3
rise to major new lower bounds in proof complexity, for Frege (= NC1-Frege) or even extended
Frege (EF = P/poly-Frege). Though this connection has been often postulated (cf. e.g., Beame and
Pitassi [2001]), it could never have been made formal so far.
In this article, we establish a technique to transfer circuit lower bounds to proof size lower
bounds for proof systems for Quantified Boolean Formulas (QBF). Our technique lifts arbitrary
circuit lower bounds to proof size bounds for QBF Frege systems, yielding in particular exponential
lower bounds for AC0[p]-Frege for QBFs via Razborov [1987] and Smolensky [1987].
Before explaining our results in more detail, we discuss recent developments in QBF proof complexity.
QBF proof complexity is a relatively young field studying proof systems for quantified Boolean
logic. Similarly as in the propositional case, one of the main motivations for the field comes via its
intimate connection to solving. SAT and QBF solvers are powerful algorithms that efficiently solve
the classically hard problems of SAT and QBF for large classes of practically relevant formulas,
with modern solvers routinely solving industrial instances in millions of variables for various
applications. Although QBF solving is at an earlier state, due to its PSPACE completeness, QBF
even applies to further fields such as formal verification or planning [Benedetti and Mangassarian
2008; Egly et al. 2017; Rintanen 2007].
The connection to proof complexity comes from the fact that each successful run of a solver on
an unsatisfiable instance can be interpreted as a proof of unsatisfiability; and modern SAT and QBF
solvers (that are sound and complete) are known to correspond to the resolution proof system and
its variants. In comparison to SAT, the picture is more complex in QBF, as there exist two main solving approaches: utilizing CDCL (Conflict-Driven Clause Learning) and expansion-based solving.
To model the strength of these QBF solvers, a number of resolution-based QBF proof systems have
been developed. Q-resolution (Q-Res) by Kleine B√ºning et al. [1995] forms the core of the CDCLbased systems. To capture further ideas from CDCL solving, Q-Res has been augmented to longdistance resolution by Balabanov and Jiang [2012], universal resolution QU-Res by Van Gelder
[2012], and their combinations [Balabanov et al. 2014]. QBF resolution systems for expansionbased solving were developed by Janota and Marques-Silva [2015] and Beyersdorff et al. [2014].
Recent progress led to a complete understanding of the relative power of all these resolution-type
QBF systems [Balabanov et al. 2014; Beyersdorff et al. 2015; Janota and Marques-Silva 2015].
From a proof complexity perspective, resolution is considered a weak system, witnessed by the
wealth of resolution lower bounds (cf. Segerlind [2007] for a survey); and the same classification
applies to all of the QBF resolution calculi mentioned above, not only due to their reliance on the
weak propositional resolution system, but also because of weak instantiations when dealing with
quantifiers.
In addition to these weak QBF systems, there exists a number of very strong sequent calculi
[Cook and Morioka 2005; Egly 2012; Kraj√≠ƒçek and Pudl√°k 1990] as well as the general proof checking format QRAT [Heule et al. 2017].
However, compared to propositional proof complexity, a number of other approaches is yet
missing in QBF. In particular, algebraic systems such as polynomial calculus [Clegg et al. 1996] or
systems based on integer programming as cutting planes [Cook et al. 1987] have received great
attention in recent years in propositional proof complexity. These systems are interesting, as they
are of intermediate strength: stronger than resolution, but weaker than Frege. No analogues of
these systems had been considered in QBF prior to the conference paper [Beyersdorff et al. 2016a]
underlying this article; and even a QBF version of the propositional Frege hierarchy mentioned
above has not been considered before. Building on our work here, the recent paper [Beyersdorff
et al. 2018] investigates an analogue of the cutting planes proof system for QBF and Beyersdorff
et al. [2019] contains further work in this direction.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.
9:4 O. Beyersdorff et al.
1.1 Summary of Results
Below, we summarize our main contributions of this article, sketching the main results and techniques.
A. From propositional to QBF: new QBF proof systems. We exhibit a general method how to
transform a propositional proof system to a QBF proof system. Our method is both conceptually
simple and elegant. Starting from a propositional proof system P composed of axioms and rules,
we design a system P + ‚àÄred for closed prenex QBFs (Definition 3.1). Throughout the proof, the
quantifier prefix is fixed, and lines in the systemP + ‚àÄred are conceptually the same as lines in P, i.e.,
clauses in resolution, circuits from C in C -Frege (where C is AC0, AC0[p], TC0, NC1, or P/poly), or
inequalities in cutting planes. Our new systemP + ‚àÄred uses all the rules fromP and can apply those
on arbitrary lines, irrespective of whether the variables are existentially or universally quantified.
To make the system complete, we introduce a ‚àÄred rule that allows to replace universal variables by
simple Herbrand functions, which can be represented as lines in P. The link to Herbrand functions
provides a clear semantic meaning for the ‚àÄred rule, resulting in a natural and robust system
P + ‚àÄred.
Our new systems P + ‚àÄred are inspired by the approach taken in the definition of Q-Res [Kleine
B√ºning et al. 1995]; and, indeed, when choosing resolution as the base system P, our system
P + ‚àÄred coincides with the previously studied QU-Res [Van Gelder 2012]. While our definitions
are quite general and yield for example previously missing QBF versions of polynomial calculus or
cutting planes, we concentrate here on exploring the hierarchy C -Frege + ‚àÄred of new QBF Frege
systems.
B. From circuit to QBF lower bounds: a general technique. As mentioned above, it is a longstanding belief that circuit lower bounds correspond to proof size lower bounds, and clearly some
of the strongest lower bounds in proof complexity as those for AC0-Frege are inspired by proof
techniques in circuit complexity, cf. the survey of Beame and Pitassi [2001]. Here, we give a precise and formal account on how any circuit lower bound for C can be directly lifted to a proof size
lower bound in C -Frege + ‚àÄred.
Conceptually, our lower bound method uses the idea of strategy extraction, an important paradigm in QBF (Theorem 4.3). Semantically, a QBF can be understood as a game between a universal
and an existential player, where the universal player wins if and only if the QBF is false. Winning
strategies for the universal player can be very complex. However, we show that from each refutation of a false QBF in a system C -Frege + ‚àÄred, we can efficiently extract a winning strategy for
the universal player in a simple computational model we call C -decision lists. We observe that C -
decision lists are easy to transform into C circuits itself, with only a slight increase in complexity.
To obtain a proof-size lower bound, we need a function f that is hard for C . From f , we construct
a family Q-fn of false QBFs such that each winning strategy of the universal player on Q-fn has
to compute f . By strategy extraction, refutations of Q-fn in C -Frege + ‚àÄred yield C -circuits for f ;
hence, all such refutations must be long. In fact, we even show the converse implication to hold,
i.e., from small C -circuits for f , we construct short proofs of Q-fn in C -Frege + ‚àÄred.
Our lower bound technique widely generalizes ideas recently used by Beyersdorff et al. [2015]
to show lower bounds for Q-Res and QU-Res for formulas originating from the Parity function.
C. Lower bounds and separations: applying our framework. We apply our proof technique to
a number of famous circuit lower bounds, thus obtaining lower bounds and separations for
C -Frege + ‚àÄred systems that are yet unparalleled in propositional proof complexity. The following
results are contained in Section 5.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.
Frege Systems for Quantified Boolean Logic 9:5
C.(i) Lower bounds and separations for the QBF proof system Frege AC0[p] + ‚àÄred. The seminal
results of Razborov [1987] and Smolensky [1987] showed that Parity and more generally MODq
are the classic examples for functions that require exponential-size bounded-depth circuits with
MODp gates, where p and q are different primes. Using these functions, we define families of QBFs
that require exponential-size proofs in Frege AC0[p] + ‚àÄred by strategy extraction.
To obtain separations of these proof systems, the exact formulation of the QBFs matters. When
defining the Parity or MODq formulas directly from (arbitrary) NC1-circuits computing these
functions, we obtain polynomial-size upper bounds in Frege + ‚àÄred. However, when carefully
choosing specific and indeed very natural encodings, we can prove upper bounds for the MODq
formulas even in Frege AC0[q] + ‚àÄred, thus obtaining exponential separations of all the Frege
AC0[p] + ‚àÄred systems for distinct primes p.
As mentioned before, lower bounds for AC0[p]-Frege (as well as their separations) are major
open problems in propositional proof complexity.
C.(ii) Separating Frege AC0[p] + ‚àÄred and Frege TC0 + ‚àÄred. Majority is another classic function
in circuit complexity, for which exponential lower bounds are known for constant-depth circuits
with MODp gates for each prime p [Razborov 1987; Smolensky 1987]. Using our technique, we
transfer these to lower bounds in Frege AC0[p] + ‚àÄred for all primes p. Carefully choosing the QBF
encoding of Majority, we obtain polynomial upper bounds for the Majority formulas in Frege
TC0 + ‚àÄred, thus proving an exponential separation between the two QBF proof systems Frege
AC0[p] + ‚àÄred and Frege TC0 + ‚àÄred. Again, such a separation is wide open in propositional proof
complexity.
C.(iii) CNFs separating the Frege AC0
d + ‚àÄred hierarchy. As a third example for our approach, we
investigate the fine structure of Frege AC0 + ‚àÄred, composing all Frege AC0
d + ‚àÄred systems, where
all formulas in proofs are required to have at most depth d for a fixed constant d. Resolution is
an important example of such a system for depth d = 1.1 In circuit complexity the Sipserd functions from Boppana and Sipser [1990] provide an exponential separation of depth-(d ‚àí 1) from
depth-d circuits [H√•stad 1986]. With our technique, this separation translates into a separation of
Frege AC0
d‚àí3 + ‚àÄred from Frege AC0
d + ‚àÄred, where the increased gap of size 3 comes from our
transformation of C -decision lists into C -circuits.
The Sipserd formulas achieving these separations are prenexed CNFs, i.e., the formulas each
have a matrix of depth 2. While in propositional proof complexity the hierarchy of AC0
d -Frege
systems is exponentially separated [Ajtai 1994; Kraj√≠ƒçek et al. 1995; Pitassi et al. 1993], such a
separation by formulas of depth independent of d is a major open problem.
C.(iv) Characterizing lower bounds for QBF Frege. The main question left open by the results
described above is whether unconditional lower bounds can be obtained for Frege + ‚àÄred or even
EF + ‚àÄred. We show that such a result would imply either a major breakthrough in circuit complexity (a lower bound for non-uniform NC1 or even P/poly) or a major breakthrough in propositional
proof complexity (lower bounds for classical Frege or even EF); and in fact the opposite implications hold as well (Theorem 5.13).
This means that the problem of lower bounds for QBF Frege very naturally unites the central problem in circuit complexity with the central problem in proof complexity. Conceptually
this is very interesting: The direct connection between progress in circuit complexity and proof
complexity, which has often been postulated (cf. Beame and Pitassi [2001]), directly manifests in
Frege + ‚àÄred, thus highlighting that Frege + ‚àÄred is indeed a natural and important system.
1Although CNF formulas have depth 2, it is customary to consider Resolution being of depth d = 1, as it handles CNF
formulas as sets of clauses, i.e., sets of objects of depth d = 1.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.
9:6 O. Beyersdorff et al.
Fig. 1. The simulation order of QBF Gentzen and Frege systems.
Technically, this result uses a normal form that we achieve for Frege + ‚àÄred proofs: these can
be decomposed into a classical Frege proof followed by a number of ‚àÄred steps (Theorem 4.5). We
further show that even ‚àÄred steps suffice that only substitute constants (Theorem 4.7).
D. Gentzen vs. Frege in QBF: simulations and separations. In classical proof complexity, Frege and
Gentzen‚Äôs sequent system LK are p-equivalent, i.e., proofs can be efficiently translated between
the systems [Cook and Reckhow 1979]. In contrast, our findings show a more complex picture for
QBF, induced by the weak methods for handling (universal) quantifiers. We concentrate on the
most important standard Gentzen-style systems G0 and G1 of Cook and Morioka [2005] as well as
the QBF Frege systems Frege + ‚àÄred and EF + ‚àÄred. The indices in G0 and G1 refer to the quantifiers
complexity of formulas allowed in cuts, cf. Section 6.1.1.
For these four systems, the following picture emerges (cf. Figure 1): We prove that tree-like G1
p-simulates EF + ‚àÄred (Theorem 6.4) and tree-like G0 simulates Frege + ‚àÄred under a relaxed notion of p-simulation (Theorem 6.6). However, the converse simulations are unlikely to hold. Under standard complexity-theoretic assumptions, we show that EF + ‚àÄred is strictly weaker than
tree-like G1 (Theorems 6.8, 6.10). Moreover, EF + ‚àÄred is incomparable to both tree-like G0 and G0
(Theorems 6.11, 6.7). Hence, unlike in the propositional framework, Gentzen appears to be stronger
than Frege in QBF.
While all these separations make use of complexity-theoretic assumptions, it will be hard to
improve these results to unconditional lower bounds (see C.(iv) above). However, since we use
a number of different and indeed partly incomparable assumptions, our separations seem very
plausible.
E. QBF Frege corresponds to intuitionistic logic. The strongest tool for an understanding of classical Frege as well as propositional and QBF Gentzen systems comes from their correspondence
to bounded arithmetic [Cook and Nguyen 2010; Kraj√≠ƒçek 1995]. Here, we show such a correspondence between EF + ‚àÄred and first-order intuitionistic logic IS1
2, introduced in Buss [1986b] and
Cook and Urquhart [1993]. For this, first-order arithmetic formulas are translated into sequences
of QBFs [Kraj√≠ƒçek and Pudl√°k 1990].
Our main result on the correspondence states that translations of arbitrarily complex prenex
theorems in IS1
2 admit polynomial-size EF + ‚àÄred proofs (Theorem 6.1). Informally, this says that
all IS1
2 consequences can be efficiently derived in EF + ‚àÄred, and moreover, EF + ‚àÄred is the weakest
system with this property.
The second facet of the correspondence is that IS1
2 can prove the correctness of EF + ‚àÄred in a
suitable encoding (Corollary 6.3), and in a certain sense EF + ‚àÄred is the strongest proof system
that is provably sound in the theory IS1
2.
Technically, the correspondence as well as the simulation results mentioned under D. (above)
rest on a formalization of the Strategy Extraction Theorem for QBF Frege systems. We provide two
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.
Frege Systems for Quantified Boolean Logic 9:7
formalizations for this result: in the first, we directly construct Frege proofs for the correctness of
the witnessing properties (Theorem 4.4). In the second, we use first-order logic, where we formalize
strategy extraction in the theory S1
2 (Theorem 6.2). While the first formalization applies to more
systems and gives the simulation structure detailed in D., the second formalization is stronger and
enables the correspondence to IS1
2.
Although intuitionistic bounded arithmetic was already developed by Buss [1986b] in the
mid‚Äô80s, no QBF counterpart of this theory was found so far‚Äîin sharp contrast to most other
arithmetic theories [Cook and Nguyen 2010]. As we show here, the missing piece in the puzzle is
our new QBF Frege system EF + ‚àÄred.
Indeed, the appealing link between IS1
2 and EF + ‚àÄred comes via their witnessing properties:
similarly as EF + ‚àÄred has strategy extraction for arbitrarily complex QBFs, the theory IS1
2 admits
a witnessing theorem for arbitrary first-order formulas [Cook and Urquhart 1993].
Conceptually, our work draws on the close interplay of ideas and techniques from proof complexity, computational complexity, and bounded arithmetic; and it is really the interaction of these
areas and techniques that form the technical basis of our results (which forces us also to include
rather extensive preliminaries).
1.2 Relations to Previous Work
In addition to the developments in propositional and QBF proof complexity sketched in the beginning, the main precursor of our work is the paper Beyersdorff et al. [2015]. Strategy extraction
for Q-Res and QU-Res was shown by Goultiaeva et al. [2011] and Balabanov and Jiang [2012], but
the idea to turn this into a lower bound argument for the proof size originates from Beyersdorff
et al. [2015], where the AC0 lower bound for Parity is used to obtain exponential lower bounds for
Q-Res and QU-Res. However, the treatment in Beyersdorff et al. [2015] is solely confined to the
resolution case. Here, we widely generalize these concepts and uncover the full potential of that
approach. In fact, quite weak circuit lower bounds would suffice for the proof-size lower bounds of
Beyersdorff et al. [2015], cf. Corollary 5.11 in the present article; and from Beyersdorff et al. [2015],
it is not clear how the full spectrum of the state-of-the-art circuit lower bounds could be used to
get proof size lower bounds.
Feasible interpolation is another technique relating circuit lower bounds to proof size bounds.
Feasible interpolation has been successfully applied to show lower bounds for a number of propositional proof systems, including resolution [Kraj√≠ƒçek 1997] and cutting planes [Pudl√°k 1997]. Indeed, Beyersdorff et al. [2017a] have recently shown that feasible interpolation is also effective for
QBF resolution calculi. Interpolation transfers monotone circuit lower bounds to proof size lower
bounds. Hence, different from strategy extraction, there is no connection between the circuit model
and the lines in the proof system. Also, by results of Kraj√≠ƒçek and Pudl√°k [1998], Bonet et al. [2000],
and Bonet et al. [2004], feasible interpolation is not applicable to strong systems such as AC0-Frege
and beyond. Another restriction of interpolation is that it only applies to special formulas, and for
these‚Äîat least in the case of QBF resolution systems‚Äîit can be understood as a special case of
strategy extraction [Beyersdorff et al. 2017a].
1.3 Organization of the Article
Contents
1 Introduction 2
1.1 Summary of Results . . . . . . . . . . . . . . . 4
1.2 Relations to previous work . . . . . . . . . . . . . . . 7
1.3 Organization of the paper . . . . . . . . . . . . . . . 7
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.
9:8 O. Beyersdorff et al.
2 Preliminaries 8
2.1 Circuit classes . . . . . . . . . . . . . . . 8
2.2 Proof systems . . . . . . . . . . . . . . . 8
2.3 Frege systems . . . . . . . . . . . . . . . 9
2.4 Quantified Boolean Formulas . . . . . . . . . . . . . . . 10
3 Defining QBF Frege systems 10
4 Strategy extraction 12
4.1 Formalized Strategy Extraction . . . . . . . . . . . . . . . 14
4.2 Normal forms for C -Frege+ 8red proofs . . . . . . . . . . . . . . . 16
5 Separations and lower bounds via circuit complexity 17
5.1 Lower bounds for bounded-depth QBF Frege systems . . . . . . . . . . . . . . . 19
5.2 Lower bounds for constant depth QBF Frege systems . . . . . . . . . . . . . . . 22
5.3 Characterizing QBF Frege and extended Frege lower bounds . . . . . . . . . . . . . . . 24
6 Relation of QBF Frege to sequent systems and bounded arithmetic 25
6.1 Background on sequent systems and bounded arithmetic . . . . . . . . . . . . . . . 25
6.1.1 Sequent Calculi . . . . . . . . . . . . . . . 25
6.1.2 Bounded arithmetic . . . . . . . . . . . . . . . 26
6.2 Intuitionistic logic corresponds to extended Frege for QBFs . . . . . . . . . . . . . . . 27
6.3 Gentzen and Frege for QBFs . . . . . . . . . . . . . . . 29
6.3.1 Formulas hard in Gentzen, but easy in Frege . . . . . . . . . . . . . . . 31
6.3.2 Formulas easy in Gentzen, but hard in Frege . . . . . . . . . . . . . . . 32
7 Conclusion 34
2 PRELIMINARIES
We assume familiarity with basic notions from computational complexity, cf. Arora and Barak
[2009], as well as from logic, cf. Kraj√≠ƒçek [1995], but define all specific concepts needed in this
article. For a formula œÜ, we denote by œÜ[x1/Œ∏1,..., xk /Œ∏k ] the formula œÜ where variables xi have
been substituted by formulas Œ∏i .
2.1 Circuit Classes
We recall the definitions of standard circuit classes used in this article. The class AC0 contains all
languages recognizable by polynomial-size circuits over the Boolean basis ¬¨, ‚à®, ‚àß with bounded
depth and unbounded fan-in. When fixing the depth to a constant d, we denote the circuit class
by AC0
d . The class AC0[p] uses bounded-depth circuits with MODp gates determining whether
the sum of the inputs is 0 modulo p, and in TC0 bounded-depth circuits with threshold gates are
permitted. Stronger classes are obtained by using NC1 circuits of polynomial size and logarithmic
depth, and by P/poly circuits of polynomial size.
When defining circuit families Cn from a circuit class C, we distinguish between uniform and
non-uniform families. For a uniform family, we require that there exists a Turing machine, which
from input 1n efficiently constructs the circuit Cn. In the non-uniform setting, we merely require
that the circuit Cn ‚àà C exists and is of the required size.
For an in-depth account on circuit complexity, we refer to Vollmer [1999].
2.2 Proof Systems
According to Cook and Reckhow [1979] a proof system for a language L is a polynomial-time onto
function P : {0, 1}
‚àó ‚Üí L. Each string œÜ ‚àà L is a theorem and if P (œÄ ) = œÜ, œÄ is a proof of œÜ in P.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.
Frege Systems for Quantified Boolean Logic 9:9
Given a polynomial-time function P : {0, 1}
‚àó ‚Üí {0, 1}
‚àó the fact that P ({0, 1}
‚àó) ‚äÜ L is the soundness
property for L and the fact that P ({0, 1}
‚àó) ‚äá L is the completeness property for L. Proof systems
for the language TAUT of propositional tautologies are called propositional proof systems and proof
systems for the language TQBF of true QBF formulas are called QBF proof systems. Equivalently,
propositional proof systems and QBF proof systems can be defined, respectively, for the languages
UNSAT of unsatisfiable propositional formulas and FQBF of false QBF formulas, in this second
case, we call them refutational. Given two proof systems P and Q for the same language L, P
p-simulates Q (denoted Q p P) if there exists a polynomial-time function t such that for each
œÄ ‚àà {0, 1}
‚àó, P (t(œÄ )) = Q(œÄ ). Two systems are called p-equivalent if they p-simulate each other. A
proof system P for L is called polynomially bounded if there exists a polynomial p such that every
x ‚àà L has a P-proof of size at most p(|x |), where |x | is the size of string x.
2.3 Frege Systems
Frege proof systems are the common ‚Äútextbook‚Äù proof systems for propositional logic based on
axioms and rules [Cook and Reckhow 1979]. The lines in a Frege proof are propositional formulas
built from propositional variables xi and Boolean connectives ¬¨, ‚àß, and ‚à®. A Frege system composed of a finite set of axiom schemes and rules, e.g., œÜ ‚à® ¬¨œÜ, is a possible axiom scheme. A Frege
proof is a sequence of formulas where each formula is either a substitution instance of an axiom
or can be inferred from previous formulas by a valid inference rule. Frege systems are required
to be sound and implicationally complete. The exact choice of the axiom schemes and rules does
not matter, as any two Frege systems are p-equivalent, even when changing the basis of Boolean
connectives [Cook and Reckhow 1979; Kraj√≠ƒçek 1995, Theorem 4.4.13]. Therefore, we can assume
w.l.o.g. that modus ponens is the only rule of inference. Usually Frege systems are defined as proof
systems where the last formula is the proven formula. To include also weak systems as resolution
in this picture, we use here the equivalent setting of refutation Frege systems where we start with
the negation of the formula that we want to prove and derive the contradiction 0.
Given a circuit class C , a general definition of C -Frege is contained in Je≈ô√°bek [2005]. Below,
we explicitly present the definitions of C -Frege for the circuit classes we will need later. There are
several common restrictions that can be imposed on Frege; for example, bounded-depth Frege systems (or AC0-Frege) are Frege systems where lines are formulas with negations only on variables
and with a bounded number of alternations between ‚àß‚Äôs and ‚à®‚Äôs. If the number of alternations is
at most d, then the proof system is called AC0
d -Frege. Bounded-depth Frege is called AC0-Frege,
since lines in an AC0-Frege proof are representable as AC0-circuits.
Resolution (Res) is a particular kind of AC0
1-Frege system2 introduced by Blake [1937] and Robinson [1965]. It is a refutational proof system manipulating unsatisfiable CNFs as sets of clauses,
where clauses are sets of literals. As we treat clauses as sets, factoring (to contract multiple occurrences of the same literal) is done automatically. The only inference rule of Resolution is
C ‚à® x D ‚à® ¬¨x
C ‚à® D (Res rule),
where C,D denote clauses and x is a variable. A Res refutation derives the empty clause.
Given a prime p, the AC0[p]-Frege systems are defined to be bounded-depth Frege systems in
the language with Boolean connectives ¬¨, ‚à®, ‚àß and modular gates MODp (x1,..., xn ). The MODp
predicate is true when
i xi ‚â° 0 (mod p).
2We will consistently treat C -Frege systems as operating with lines from C . As Res operates with clauses, we will call it a
AC0
1-Frege system even though it refutes CNFs, which are depth 2.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.  
9:10 O. Beyersdorff et al.
The TC0-Frege systems are defined to be bounded-depth Frege systems in the language with
Boolean connectives ¬¨, ‚à®, ‚àß and threshold gates Tk (x1,..., xn ). The Tk predicate is true when
at least k of its inputs are true. Two different, but equivalent, formalizations of TC0-Frege proof
systems are given by Buss and Clote [1996] and Bonet et al. [2000].
(Unrestricted) Frege systems correspond to the complexity class NC1 in the same sense, as
bounded-depth Frege corresponds to the class AC0. We will sometimes refer to Frege as NC1-Frege.
Extended Frege systems EF allow the introduction of new extension variables that abbreviate
formulas. Consistent with the above treatment of C -Frege, we define EF here as a Frege system
that directly operates with Boolean circuits rather than formulas, where extension variables can be
used to define the circuit gates (see Je≈ô√°bek [2005] for the precise formulation). Therefore, we will
refer to EF also as P/poly-Frege. An alternative characterization of EF is through substitution Frege
systems SF that allow arbitrary substitution instances of derived formulas [Cook and Reckhow
1979; Kraj√≠ƒçek and Pudl√°k 1989].
The Frege systems defined above form a hierarchy of proof systems
Res p AC0
-Frege p AC0
[p]-Frege p TC0
-Frege p Frege p EF.
Currently lower bounds are only known for Res [Haken 1985] and AC0-Frege [Ajtai 1994; Kraj√≠ƒçek
et al. 1995; Pitassi et al. 1993], whereas super-polynomial lower bounds for any of the stronger
systems constitute major problems in proof complexity.
2.4 Quantified Boolean Formulas
A (closed prenex) Quantified Boolean Formula (QBF) is a formula where quantifiers are introduced
to propositional logic, which has constants 0,1, the usual operators ¬¨, ‚àß, ‚à®, ‚Üí, ‚Üî, and propositional variables. Each variable is quantified at the beginning of the formula using either an existential or universal quantifier. We denote such formulas as Q œÜ, where œÜ is a propositional Boolean
formula called matrix, and Q is its quantifier prefix. We typically use xi for existentially quantified variables and ui for universally quantified variables. Sometimes, we require the matrix to be
a Conjunctive Normal Form (CNF); in particular, when we implement Resolution-style systems.
In a fully quantified prenex QBF, the quantifier prefix determines a total order of the variables.
Given a variable y, we will sometimes refer to the variables preceding y in the prefix as variables
left of y; analogously, we speak of the variables right of y.
The quantifier complexity of QBFs is captured by sets Œ£q
i and Œ†q
i , which are defined inductively. Œ£q
0 = Œ†q
0 is the set of quantifier-free propositional formulas, Œ£q
i+1 is the closure of Œ†q
i under
existential quantification, and Œ†q
i+1 is the closure of Œ£q
i under universal quantifiers.
A QBF Q1x1 ¬∑¬∑¬∑Qkxk œÜ can be seen as a game between two players: universal (‚àÄ) and existential
(‚àÉ). In the ith step of the game, the player Qi assigns a value to the variable xi . The existential player
wins if œÜ evaluates to 1 under the assignment constructed in the game. The universal player wins
if œÜ evaluates to 0. Given a universal variable u with index i, a strategy for u is a function from all
variables of index < i to {0, 1}. A QBF is false if and only if there exists a winning strategy for the
universal player; that is, if the universal player has a strategy for all universal variables that wins
any possible game [Arora and Barak 2009; Goultiaeva et al. 2011].
3 DEFINING QBF FREGE SYSTEMS
In this section, we provide a general method of transforming a propositional proof system into
a QBF proof system. While this method works for a wide range of proof systems operating with
lines and rules, we will concentrate here on the hierarchy of C -Frege systems introduced in the
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.     
Frege Systems for Quantified Boolean Logic 9:11
previous section. However, our method also works for further propositional proof systems such as
polynomial calculus [Clegg et al. 1996] or cutting planes [Beyersdorff et al. 2018; Cook et al. 1987].
For the following, we fix a circuit class C with some natural properties, e.g., closure under
restrictions.3 In particular, C can be any of the circuit classes mentioned in Section 2.
Definition 3.1 (Frege C+ ‚àÄred). A refutation of a false QBF Q œÜ in the system C -Frege + ‚àÄred is a
sequence of lines L1,..., L where each line is a circuit from the class C , L1 = œÜ,
4 L = 0, and each
Li is inferred from previous lines Lj using the inference rules of C -Frege or using the following
rule:
Lj
Lj[u/B]
(‚àÄred),
where Lj[u/B] belongs to the class C , variable u is rightmost (innermost with respect to the prefix)
among the variables of Lj , and B is a circuit from the class C containing only variables left of u.
The formal justification why C -Frege + ‚àÄred is a sound and complete QBF proof system is given
in Theorem 3.2 below. However, let us pause a moment to see why adding the ‚àÄred rule results
in a natural proof system C -Frege + ‚àÄred. Recall that we consider C -Frege + ‚àÄred as a refutation
system; hence, we aim to refute false quantified C formulas. A standard approach to witness the
falsity of quantified formulas is through Herbrand functions, which replace a universal variableu by
a function in the existential variables left of u. These functions can be viewed as ‚Äúcounterexample
functions.‚Äù In Definition 3.1, B plays the role of the Herbrand function. Clearly, when restricting
formulas to a class C , we should also restrict B to that class, and substituting the Herbrand function
into the formula should again preserve C .
Note that we are even allowed to choose different Herbrand functions B for the same variable
u in different parts of the proof. In general, this will be unsound (unless variables right of u are
renamed). However, it is safe to do if the line Lj does not contain any variables right of u.
It is illustrative to see how our construction compares to previously studied QBF resolution
systems. Choosing Res as our propositional proof system, which is an AC0
1-Frege system, we obtain
Res + ‚àÄred. In Res + ‚àÄred the ‚àÄred rule can substitute a universal u by either a disjunction of literals
or by a constant 0/1. In the former case, we simply obtain a weakening step. In the latter case, if u
appears positively in the clause, then substituting u by 0 precisely corresponds to an application
of the ‚àÄred rule in Q-Res, whereas substituting u by 1 results in a useless tautology.5 As Res + ‚àÄred
can resolve on existential and universal variables, our system Res + ‚àÄred is exactly the well-known
QU-Res (with weakening).
We now proceed to show soundness and completeness of the new QBF systems.
Theorem 3.2. For every circuit complexity class C , the system C -Frege + ‚àÄred is a refutational
QBF proof system.
Proof. Res + ‚àÄred is complete as it p-simulates Q-Res, which is complete for QBF [Kleine
B√ºning et al. 1995]. To obtain the completeness for C -Frege + ‚àÄred, we first use de Morgan‚Äôs rules
to expand the formula into a CNF. This is possible as, by definition, C -Frege is implicationally
complete. Now, we can refute the CNF by Res + ‚àÄred. C -Frege + ‚àÄred p-simulates Res + ‚àÄred and
hence C -Frege + ‚àÄred is complete.
3In the context of a circuit class, ‚Äúclosure under restriction‚Äù means that for any circuit in the class, if we pick a partial
assignment to some of the input variables and substitute in those constants, we still are guaranteed to be in the same
circuit class.
4In the case where C is AC0
1, we require that œÜ = L1 ‚àß¬∑¬∑¬∑‚àß Lm where Lj are lines in AC0
1-Frege. 5Note that, contrasting the usual setting of Q-Res [Kleine B√ºning et al. 1995], our definition of Res + ‚àÄred does not need
to disallow tautologous resolvents, as these will always be reduced to 1.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.  
9:12 O. Beyersdorff et al.
Regarding the soundness of C -Frege + ‚àÄred, let (L1,..., L ) be a refutation of Q œÜ in the system
C -Frege + ‚àÄred and let
œÜi =

œÜ if i = 0,
œÜ ‚àß L1 ‚àß¬∑¬∑¬∑‚àß Li otherwise.
By induction on i, we prove that Q œÜ semantically entails Q œÜi , i.e., Q œÜ |= Q œÜi . Hence, at step
i = , we will immediately obtain that Q œÜ is false, since L = 0 and Q œÜ ‚â° 0.
Since Q œÜ = Q œÜ0 the base case of the induction holds.
We show now that Q œÜ |= Q œÜi implies Q œÜ |= Q œÜi+1. By definition, œÜi+1 = (œÜi ‚àß Li+1) and Li+1
was either introduced by a C -Frege rule or by the ‚àÄred rule. If Li+1 was introduced by a C -Frege
rule, then œÜi |= Li+1, so œÜi |= œÜi+1 and clearly Q œÜ |= Q œÜi |= Q œÜi+1.
Suppose now that Li+1 was introduced by the ‚àÄred rule, say Li+1 = Lj[u/B] with j  i, u the
innermost variable among the ones in Lj and B relying only on the variables left of u. Moreover,
suppose that Q œÜi = Q1x ‚àÄu Q2y œÜ i ; then, we have the following chain of equivalences
Q œÜi = Q1x ‚àÄu Q2y œÜ i (1)
‚â° Q1x ‚àÄu Q2y œÜ i ‚àß Lj (2)
‚â° Q1x
 Q2y œÜ i[u/0] ‚àß Lj[u/0]
‚àß 
Q2y œÜ i[u/1] ‚àß Lj[u/1]  (3)
‚â° Q1x

Lj[u/0] ‚àß Lj[u/1] ‚àß 
Q2y œÜ i[u/0]
‚àß 
Q2y œÜ i[u/1]  (4)
‚â° Q1x

Lj[u/0] ‚àß Lj[u/1] ‚àß ‚àÄuQ2y œÜ i
 (5)
‚â° Q1x

Lj[u/0] ‚àß Lj[u/1] ‚àß Lj[u/B] ‚àß ‚àÄuQ2y œÜ i
 (6)
‚â° Q1x‚àÄuQ2y œÜ i ‚àß Lj[u/0] ‚àß Lj[u/1] ‚àß Lj[u/B]. (7)
In Equations (3) and (5), we used the definition of semantic expansion of a universal variable in a
QBF; in Equations (4), (6), and (7), we used the fact that Lj[u/0], Lj[u/1] and Lj[u/B] do not contain
y variables. From Equation (7) follows, by weakening, that
Q œÜi |= Q1x‚àÄuQ2y œÜ i ‚àß Lj[u/B],
hence Q œÜ |= Q œÜi+1.
Clearly lower bounds on the complexity of C -Frege + ‚àÄred follow from lower bounds on
C -Frege. The lower bounds we show later will be of a different kind, as they will be ‚Äúpurely for
QBF proof systems‚Äù in the sense that they will lower bound the number of occurrences of the ‚àÄred
rule in refutations (cf. also Beyersdorff et al. [2017b] for a formal definition of what qualifies as a
‚Äúgenuine‚Äù QBF lower bound).
4 STRATEGY EXTRACTION
We introduce now the simple computational model of C -decision lists.
Definition 4.1 (C -decision list). A C -decision list is a program of the following form:
if C1 (x) then u ‚Üê B1 (x);
else if C2 (x) then u ‚Üê B2 (x);
.
.
.
else if C‚àí1 (x) then u ‚Üê B‚àí1 (x);
else u ‚Üê B (x),
where C1,...,C‚àí1 and B1,..., B are circuits in the class C . Hence, a decision list as above computes a Boolean function u = –¥(x).
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.                                         
Frege Systems for Quantified Boolean Logic 9:13
This definition generalizes decision lists from Rivest [1987], where the conditions Ci (x) are
expressible as terms. We note that for many cases C -decision lists can be easily transformed into
C -circuits.
Proposition 4.2. Let D be a C -decision list using circuits C1,...,C‚àí1 and B1,..., B, such that
D computes the Boolean function –¥. Then there exists a circuit D ‚àà C computing the same function
–¥, such that the size of D is linear in the size of D and
depth(D
)  max
max 1i‚àí1
{depth(Ci )}, max
1i
{depth(Bi )}

+ 2.
Proof. We have that
u ‚â°


j=1



Cj (x) ‚àß Bj (x) ‚àß

1k<j
¬¨Ck (x)



,
where C is a circuit computing the constant 1 and for j = 1, we have an empty conjunct in the
formula that is true.
Balabanov and Jiang [2012] proved a strategy extraction result for QU-Res. Here, we generalize
that result to the full hierarchy of C -Frege + ‚àÄred QBF proof systems. This result is the main tool
we use to prove size lower bounds in such systems.
Theorem 4.3 (Strategy Extraction). Given a false QBF Q œÜ and a refutation œÄ of Q œÜ in
C -Frege + ‚àÄred, it is possible to extract in linear time (w.r.t. |œÄ |) a collection of C -decision lists D
computing a winning strategy on the universal variables of œÜ.
Proof. Let œÄ = (L1,..., Ls ) be a refutation of the false QBF Q œÜ and let
œÄi =

‚àÖ if i = s,
(Li+1,..., Ls ) otherwise.
We show, by downward induction on i, that from œÄi it is possible to construct in linear time
(w.r.t. |œÄi |) a winning strategy œÉi for the universal player for the QBF formula Q œÜi , where
œÜi =

œÜ if i = 0,
œÜ ‚àß L1 ‚àß¬∑¬∑¬∑‚àß Li otherwise,
such that for each universal variable u in Q œÜ, there exists a C -decision list Di
u computing œÉi
u as a
function of the variables in Q left of u, having size O(|œÄi |).
The statement of the Strategy Extraction Theorem corresponds to the case when i = 0. For the
base case, we can define all the Ds
u as u ‚Üê 0, as any strategy will refute this QBF, so œÉs
u = 0 is just
picked arbitrarily.
We show now how to construct œÉi‚àí1 u and Di‚àí1 u from œÉi
u and Di
u :
‚Ä¢ If Li is derived by some Frege rule, then for each universal variable u, we set œÉi‚àí1 u = œÉi
u and
Di‚àí1 u = Di
u .
‚Ä¢ If Li is the result of an application of a ‚àÄred rule, then that is Lj
Lj[u/B], where u is rightmost
among the variables in Lj , Lj[u/B] is a circuit in C using only variables on the left of u, and
Lj (u/B) = Li . Let xu denote all variables on the left of u in the quantifier prefix of Q œÜ.
Then, we define
œÉi‚àí1 u (xu ) =
‚éß‚é™‚é™
‚é®
‚é™‚é™
‚é©
œÉi
u (xu ) if u  u,
B(xu ) if u = u and Lj[u/B](xu ) = 0,
œÉi
u (xu ) if u = u and Lj[u/B](xu ) = 1.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.                              
9:14 O. Beyersdorff et al.
Moreover, for each u  u, we set Di‚àí1 u = Di
u and we set Di‚àí1 u as follows:
if ¬¨Lj[u/B](xu ) then u ‚Üê B(xu );
else Du
i (xu ).
We now check that for each u
, œÉi‚àí1 u respects all the properties of the inductive claim.
 œÉi‚àí1 u and Di‚àí1 u are well defined. By construction Lj[u/B] is a formula in the variables x left of
u. This immediately implies that, for each universal variable u
, the strategy œÉi‚àí1 u is well defined
and Di‚àí1 u is also well defined. By induction hypothesis Di
u is a C -decision list, so Di‚àí1 u is also a
C -decision list.
 œÉi‚àí1 and Di‚àí1 u are constructed in linear time w.r.t. |œÄi‚àí1 |. This holds by inductive hypothesis and
the fact that computing ¬¨Lj (u/B) is linear in |œÄi‚àí1 | (the number of characters in this subproof).
 Di‚àí1 u computes œÉi‚àí1 u . For u  u, by induction hypothesis, Di‚àí1 u computes œÉi
u. The same happens,
by construction, for u = u.
 œÉi‚àí1 is a winning strategy for Q œÜi‚àí1. Fix an assignment œÅ to the existential variables of œÜ. Let
œÑi be the complete assignment to existential and universal variables, constructed in response to œÅ
under the strategy œÉi
. By induction hypothesis œÑi falsifies œÜi . We need to show that œÑi‚àí1 falsifies
œÜi‚àí1. To show this, we distinguish again two cases.
If Li is derived by some Frege rule, then œÉi‚àí1 = œÉi and œÑi‚àí1 = œÑi . Hence, by induction hypothesis,
œÑi falsifies a conjunct from œÜi . To argue that œÑi‚àí1 also falsifies a conjunct from œÜi‚àí1, we only need
to look at the case when the falsified conjunct is Li . As Li is false under œÑi and Li is derived by
a sound Frege rule, one of the parent formulas of Li in the application of the Frege rule must be
falsified as well. Hence, œÑi‚àí1 falsifies œÜi‚àí1.
Now let Li = Lj[u/B] for some j < i. In this case, our strategy œÉi‚àí1 changes the assignment œÑi
only when œÑi made the universal player win by falsifying Li . As we set u to B(œÑi (x)), the modified
assignment œÑi‚àí1 falsifies Lj . Otherwise, if œÑi does not falsify Li , we keep œÑi‚àí1 = œÑi and hence falsify
one of the conjuncts of œÜi‚àí1 by induction hypothesis.
From the proof of the Strategy Extraction Theorem it is clear that the size of the C -decision list
computing the winning strategy extracted from the refutation œÄ has size that is actually linear in
the number of applications of the ‚àÄred rule in œÄ. More precisely, the size of the C -decision list
computing the winning strategy for variable u corresponds exactly to the number of ‚àÄred rules on
u in œÄ. The size of a C -decision list is intended to be its string representation. Interestingly, the
same observation above holds if we consider the number of entries of the C -decision list; i.e., the
C -decision list computing the winning strategy extracted from the refutation œÄ has a number of
entries that is linear in the number of applications of the ‚àÄred rule in œÄ.
4.1 Formalized Strategy Extraction
We now observe that the strategy extraction from Theorem 4.3 is in fact provably correct in the
corresponding Frege system. In Theorem 6.2, we also give a formalization of strategy extraction
in the theory of bounded arithmetic S1
2.
For this subsection (and also later occasionally), we assume w.l.o.g. that QBFs are of the form
‚àÉx1‚àÄy2 ¬∑¬∑¬∑‚àÉxn‚àÄyn œÜ(x1,..., xn,y1,...,yn ) with only one variable per quantifier block. This is no
restriction, as a QBF with larger quantifier blocks can be transformed into this form by adding
dummy variables to the prefix, which do not appear in the matrix of the formula. This will simplify
our analysis.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.            
Frege Systems for Quantified Boolean Logic 9:15
Theorem 4.4. Let C be AC0, AC0[p], TC0, NC1, or P/poly. Given a C -Frege + ‚àÄred refutation œÄ
of a QBF
‚àÉx1‚àÄy1 ¬∑¬∑¬∑‚àÉxn‚àÄyn œÜ(x1,..., xn,y1,...,yn )
where œÜ ‚àà Œ£q
0 , we can construct in time |œÄ |
O (1) a C -Frege proof of
n
i=1
(yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1)) ‚Üí ¬¨œÜ(x1,..., xn,y1,...,yn )
for some circuits Ci ‚àà C . (The depth of the C -Frege proof increases by a constant compared to the
depth of the C -Frege + ‚àÄred proof.)
Proof. We inspect the proof of the Strategy Extraction Theorem above. Again let œÄ =
(L1,..., Ls ) be a C -Frege + ‚àÄred refutation of a QBF Q œÜ given as
‚àÉx1‚àÄy1 ¬∑¬∑¬∑‚àÉxn‚àÄyn œÜ(x1,..., xn,y1,...,yn )
where œÜ ‚àà Œ£q
0 and define œÄi and œÜi as in the proof of Theorem 4.3. We will show by downward
induction on i that from œÄi it is possible to construct in linear time a winning strategy
œÉi = {Ci
1 (x1),...,Ci
n (x1,..., xn,y1,...,yn‚àí1)} ‚äÜ C
for the universal player for the QBF Q œÜi . Moreover, the formula
n
l=1
(yl ‚Üî Ci
l (x1,..., xl ,y1,...,yl‚àí1)) ‚Üí ¬¨œÜi (x1,..., xn,y1,...,yn )
denoted œÉi (œÜi ), which witnesses the negation of Q œÜ will have a C -Frege proof of size K|œÄi |
K for
a constant K depending only on the choice of the C -Frege system. The statement of the theorem
corresponds to the case i = 0.
In the base case, œÜs contains a contradiction so the winning strategy can be defined as the set
of trivial circuits {0,..., 0} and it is trivially provably correct.
Assume now that œÉi (œÜi ) has a C -Frege proof of size K(s + 1 ‚àí i)|œÄi |
K .
If Li is derived by a C -Frege rule, then œÉi‚àí1 = œÉi
.
Now let Li = Lj[u/B] be the result of an application of a ‚àÄred rule on Lj where u is innermost
among the variables in Lj . Then define Ci‚àí1
l = Ci
l if u  yl , otherwise set
Ci‚àí1
l (z) =

B(z) if Lj[u/B](z) = 0,
Ci
l (z) if Lj[u/B](z) = 1.
This constructs strategies œÉi from œÄ by a D|œÄi |-time algorithm for a constant D. W.l.o.g. D < K.
In fact, circuitsCi
l are in C . (For constant depth C ‚Äôs, we take for circuitsCi
l the equivalent constantdepth circuits from Proposition 4.2).
We want to show that œÉi‚àí1 (œÜi‚àí1) has a C -Frege proof of size K(s + 1 ‚àí (i ‚àí 1))|œÄi‚àí1 |
K .
If Li is derived by a C -Frege rule, then œÉi also witnesses ¬¨œÜi‚àí1 because
¬¨Li ‚Üí ¬¨(L
1 ‚àß¬∑¬∑¬∑‚àß L
t )
for some conjuncts L
1,..., L
t in œÜi‚àí1. Note that Ci‚àí1
l ‚Äôs are then Ci
l
‚Äôs. The implications
¬¨œÜi ‚Üí ¬¨œÜi‚àí1, (8)
œÉi
(œÜi ) ‚àß (¬¨œÜi ‚Üí ¬¨œÜi‚àí1) ‚Üí œÉi‚àí1 (œÜi‚àí1), (9)
can be derived by a fixed sequence of C -Frege rules depending only on the choice of C -Frege.
(Note that the left-hand sides of the implications œÉi (œÜi ) and œÉi‚àí1 (œÜi‚àí1) are identical, because
œÉi‚àí1 = œÉi in this case.) Thus, the common size of C -Frege proofs of both these implications is  K0 |œÄi‚àí1 |
K0 where w.l.o.g. K0 < K. Therefore, œÉi‚àí1 (œÜi‚àí1) has a C -Frege proof of size
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.   
9:16 O. Beyersdorff et al.
 K(s + 1 ‚àí i)|œÄi |
K + K1 |œÄi‚àí1 |
K1  K(s + 1 ‚àí (i ‚àí 1))|œÄi‚àí1 |
K where K1 > K0 depends again on a
fixed sequence of C -Frege rules needed to derive œÉi‚àí1 (œÜi‚àí1) from Equations (8), (9), and œÉi (œÜi ), so
w.l.o.g. K1 < K.
Assume now that Li = Lj[u/B] is the result of an application of ‚àÄred where u = yl . Then there
is a fixed sequence of C -Frege rules deriving the implications
œÉi
(œÜi ) ‚àß ¬¨Lj[u/B] ‚Üí œÉi‚àí1 (œÜi‚àí1), (10)
œÉi
(œÜi ) ‚àß Lj[u/B] ‚Üí œÉi‚àí1 (œÜi‚àí1). (11)
Equation (10) follows from the provable equation Lj ‚àß (u ‚Üî B) ‚Üí Lj[u/B], because Lj is a conjunct
in œÜi‚àí1, u = yl and Ci‚àí1
l is B, because ¬¨Lj[u/B] holds in this case. Equation (11) follows from the
provable formula œÜi‚àí1 ‚àß Lj[u/B] ‚Üí œÜi and 	n
l=1 yl ‚Üî Ci‚àí1
l ‚Üí 	n
l=1 yl ‚Üî Ci
l under the condition
that Ci‚àí1
l = Ci
l
, which is the case if Lj[u/B] holds.
The total size of both C -Frege derivations of Equations (10) and (11) is K0 |œÄi‚àí1 |
K0 where K0
depends on the choice of C -Frege and the size of Ci‚àí1
l ‚Äôs. The size of all Ci‚àí1
l ‚Äôs is bounded by
K|œÄi‚àí1 |
K . Hence, we can assume K0 < K. It follows that œÉi‚àí1 (œÜi‚àí1) has a C -Frege proof of size
 K(s + 1 ‚àí i)|œÄi |
K + K1 |œÄi‚àí1 |
K1  K(s + 1 ‚àí (i ‚àí 1))|œÄi‚àí1 |
K where as beforeK1 depends on a fixed
sequence of C -Frege rules needed to simulate a fixed set of ‚Äúcut‚Äù rules, i.e., w.l.o.g. K1 < K.
4.2 Normal forms for C -Frege + ‚àÄred Proofs
We conclude this section with an application of the Strategy Extraction Theorem to obtain normal
forms for C -Frege + ‚àÄred proofs. First, we show that any C -Frege + ‚àÄred refutation can be efficiently rewritten as a C -Frege derivation followed essentially just by ‚àÄred rules. Second, we show
that in the ‚àÄred rule it is sufficient to only substitute constants.
Theorem 4.5. Let C be AC0, AC0[p], TC0, NC1, or P/poly. For any C -Frege + ‚àÄred refutation œÄ
of a QBF œà of the form
‚àÉx1‚àÄy1 ¬∑¬∑¬∑‚àÉxn‚àÄyn œÜ(x1,..., xn,y1,...,yn ),
whereœÜ ‚àà Œ£q
0 , there is a |œÄ |
O (1)
-size C -Frege + ‚àÄred refutation ofœà starting with a C -Frege derivation
of
n
i=1
(yi  Ci (x1,..., xi,y1,...,yi‚àí1)), (12)
from œÜ for some circuits Ci ‚àà C , followed by n applications of the ‚àÄred rule, gradually replacing the rightmost variable yi by circuit Ci (x1,..., xi,y1,...,yi‚àí1) and cutting the inequality yi
Ci (x1,..., xi,y1,...,yi‚àí1) out of the disjunction (12).
Proof. Given a C -Frege + ‚àÄred refutation œÄ ofœà, by Theorem 4.4, there is a |œÄ |
O (1)
-size C -Frege
proof of
n
i=1
(yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1)) ‚Üí ¬¨œÜ(x1,..., xn,y1,...,yn ).
Having œÜ freely available in the refutation, C -Frege can derive (12) by applying the cut rule
(derivable in C -Frege).
The refutation then continues by n applications of the ‚àÄred rule, which one-by-one replaces the
rightmost variable yi by Ci (x1,..., xi,y1,...,yi‚àí1) and eliminates
yi  Ci (x1,..., xi,y1,...,yi‚àí1)
from the disjunction 

i yi  Ci (x1,..., xi,y1,...,yi‚àí1).
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.          
Frege Systems for Quantified Boolean Logic 9:17
Theorem 4.5 is an analogue of the midsequent theorem for sequent systems. An immediate
consequence of Theorem 4.5 is the p-equivalence of C -Frege + ‚àÄred and its tree-like version. This is
in contrast to the G1, G0 systems where one has p-simulations of dag systems by tree systems only
for prenex Œ£q
1 -formulas (see Cook and Morioka 2005, Theorem 6 and the discussion after the proof).
Corollary 4.6. Let C be AC0, AC0[p], TC0, NC1, or P/poly. Then, C -Frege + ‚àÄred is p-equivalent
to tree-like C -Frege + ‚àÄred.
Proof. By Theorem 4.5, any C -Frege + ‚àÄred derivation can be efficiently replaced by a proof
in the normal form. The C -Frege part of such derivation can be efficiently replaced by a tree-like
C -Frege proof, cf. Kraj√≠ƒçek [1995], and the rest of the C -Frege + ‚àÄred refutation given in the normal
form is tree-like.
Finally, we further simplify C -Frege + ‚àÄred so every application of the ‚àÄred rule only substitutes
constants 0/1 instead of general circuits. We denote the resulting system as C -Frege + ‚àÄred0,1. This
shows that C -Frege + ‚àÄred systems are indeed very robustly defined.
Theorem 4.7. Let C be AC0, AC0[p], TC0, NC1, or P/poly. Then, C -Frege + ‚àÄred and
C -Frege + ‚àÄred0,1 are p-equivalent.
Proof. It is enough to show that any C -Frege + ‚àÄred refutation can be transformed efficiently into a refutation where the ‚àÄred rule substitutes only constants. By Theorem 4.5, for any
C -Frege + ‚àÄred refutation œÄ of Q œÜ there is a |œÄ |
O (1)
-size C -Frege derivation of
n
i=1
(yi  Ci (x1,..., xi,y1,...,yi‚àí1))
from œÜ(x1,..., xn,y1,...,yn ). Applying ‚àÄred0,1 on yn, we can then derive
(Cn (x1,..., xn,y1,...,yn‚àí1)  c) ‚à®
n
‚àí1
i=1
(yi  Ci (x1,..., xi,y1,...,yi‚àí1))
for both constants c = 0, 1.
However, there is a polynomial-size C -Frege proof of
(Cn (x1,..., xn,y1,...,yn‚àí1) ‚Üî 1) ‚à® (Cn (x1,..., xn,y1,...,yn‚àí1) ‚Üî 0),
so we can derive 

i<n (yi  Ci (x1,..., xi,y1,...,yi‚àí1)). In this way, we can efficiently cut all
disjuncts and derive a contradiction in C -Frege + ‚àÄred0,1.
5 SEPARATIONS AND LOWER BOUNDS VIA CIRCUIT COMPLEXITY
We now introduce a class of QBFs defined from some circuitsCn computing a function f . Choosing
different functions f , these formulas will form the basis of our lower bounds.
Definition 5.1 (Q-Cn). Let n be an integer and Cn be a circuit with inputs x1,..., xn. Let
t1,...,tm‚àí1 be a topological ordering of the internal gates of Cn, and let the output gate of Cn
be tm. We define
Q-Cn = ‚àÉx1 ¬∑¬∑¬∑‚àÉxn‚àÄu‚àÉt1 ¬∑¬∑¬∑‚àÉtm (u ‚Üî ¬¨tm ) ‚àß
m
i=1
Gi,
where u ‚Üî ¬¨tm ‚â° (u ‚à® tm ) ‚àß (¬¨u ‚à® ¬¨tm ) and Gi expresses as a CNF the function computed in the
circuit Cn at gate i, e.g., if node ti computes the ‚àß of tj and tk then
Gi = ti ‚Üî (tj ‚àß tk ) ‚â° (¬¨ti ‚à® tj) ‚àß (¬¨ti ‚à® tk ) ‚àß (ti ‚à® ¬¨tj ‚à® ¬¨tk ),
similarly if gate i computes ¬¨, ‚à®, ‚äï, MODp , Tk or some other Boolean function.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.      
9:18 O. Beyersdorff et al.
Informally, the QBF Q-Cn expresses that there exists an input x such thatCn (x) neither evaluates
to 0 nor 1, an obvious contradiction, as Cn computes a total function on {0, 1}
n. The formulas Gi
can be considered as the result of a Tseitin translation used widely in SAT and QBF solving. We
intentionally place the universal variable u to the left of the Tseitin variables ti , thus making the
Tseitin variables inaccessible when constructing the strategy of u. We note that the hardness of the
formulas crucially depends on this choice of the order of quantification (compare also Beyersdorff
et al. [2016b]).
Using these formulas together with the Strategy Extraction Theorem, we now establish a tight
connection between the circuit class C and C -Frege + ‚àÄred.
Theorem 5.2. Let C be one of the circuit classes AC0, AC0[p], TC0, NC1, P/poly and let (Cn )n‚ààN
be a non-uniform family of circuits whereCn is a circuit with n inputs. Then the following implications
hold:
(i) if the QBFs Q-Cn have C -Frege + ‚àÄred refutations of size bounded by a function q(n), then
for each n, Cn is equivalent to a circuit C
n where C
n is of size O(q(n)) and uses the gates and
depth allowed in C ;
(ii) if (Cn )n‚ààN is a polynomial-size circuit family from C , then the QBFs Q-Cn have polynomialsize refutations in C -Frege + ‚àÄred.
Proof. Regarding (i), by the Strategy Extraction Theorem and Proposition 4.2, if the QBF Q-Cn
has a refutation in C -Frege + ‚àÄred of size S, then a winning strategy for the universal player can
be computed by a circuit C
n ‚àà C of size O(S). We have that in Q-Cn the quantifier prefix looks
like ‚àÉx1 ¬∑¬∑¬∑‚àÉxn‚àÄu‚àÉt. Now, by construction, u  Cn (x1,..., xn ), hence a winning strategy for the
universal player must consist of playing u = Cn (x1,..., xn ). This means that the circuit C
n computing the winning strategy for the universal player is equivalent to the circuit Cn and the size
bound follows.
Note that the circuits C
n and Cn are equivalent but not identical. The first one C
n is the strategy
extracted from a decision list and depends on the proof in question, whereas Cn is the original
circuit encoded into Q-Cn with Tseitin variables.
Regarding (ii), we define the ti variables (1  i  m) for Q-Cn as in Definition 5.1. By definition,
the ti are indexed w.r.t. a topological ordering of the nodes of Cn.
We prove, by induction on i, that there exists a circuit Di ‚àà C such that ti ‚Üî Di is derivable in
C -Frege with size polynomial in |Di |.
In the base case, we have that C -Frege is able to prove x ‚Üî x for every input variable x.
For the inductive step, suppose thatti corresponds to a gate (tj1 ,...,tj ) with fan-in , where 
could be an ‚àß, ‚à®, ¬¨, ‚äï, MODp,Tk ,... from the gates allowed in the class C and j1 ... j is a sequence
of indices less than i. By the inductive property, we know thattk ‚Üî Dk is provable in C -Frege with
proofs of size polynomial in |Dk |, for every k < i (as well as any input variables). Hence, tjk ‚Üî Djk
is provable in C -Frege with proofs of size polynomial in |Djk | for every input gate variable tjk .
Moreover, C -Frege is able to make the following inference in a polynomial number of steps:
tj1 ‚Üî Dj1 ¬∑¬∑¬∑ tj ‚Üî Dj ti ‚Üî (tj1 ,...,tj )
ti ‚Üî (Dj1 ,...,Dj ) .
Then let Di = (Dj1 ,...,Dj ). At themth step C -Frege proves that tm ‚Üî Dm, from which follows
that
tm ‚Üî Dm u ‚Üî ¬¨tm
u ‚Üî ¬¨Dm
.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.              
Frege Systems for Quantified Boolean Logic 9:19
Since now u is universal and the innermost variable of u ‚Üî ¬¨Dm, we can apply the ‚àÄred rule
and get 0 ‚Üî ¬¨Dm, 1 ‚Üî ¬¨Dm, which leads to an immediate contradiction in the QBF proof system
C -Frege + ‚àÄred.
In particular, a Boolean function f is computable by polynomial-size C circuits if and only
if Q-Cn have polynomial-size C -Frege refutations for each choice of Boolean circuits (Cn )n‚ààN
computing f . Note that the circuits Cn are not necessarily circuits in the class C .
In the remainder of this section, we apply Theorem 5.2 to a number of circuit classes and transfer
circuit lower bounds to proof size lower bounds.
5.1 Lower Bounds for Bounded-depth QBF Frege Systems
Parity is one of the best-studied functions in terms of its circuit complexity. With Theorem 5.2,
we can immediately transfer circuit lower bounds for Parity to Frege AC0[p] + ‚àÄred, regardless of
the encoding for Parity.
Corollary 5.3 (Q-Parity lower bounds). Let Cn be a family of polynomial-size circuits computing Parity. For each odd prime p, the QBFs Q-Cn require refutations of exponential size in Frege
AC0[p] + ‚àÄred.
Proof. The exponential lower bound for the refutation size in Frege AC0[p] + ‚àÄred follows from
Theorem 5.2 and the fact that for each odd prime p any family of bounded-depth circuits with
MODp gates computing Parity must be of exponential size [Razborov 1987; Smolensky 1987].
We highlight that non-trivial lower bounds for AC0[p]-Frege are one of the major open problems
in propositional proof complexity. We complement the lower bound in Corollary 5.3 with an upper
bound for arbitrary NC1 encodings of Parity in Frege + ‚àÄred.
Corollary 5.4 (Q-Parity upper bounds). LetCn be a family of NC1 circuits computing Parity.
Then, the QBFs Q-Cn have polynomial-size refutations in Frege + ‚àÄred.
Proof. By a result of Muller and Preparata [1975], Parity can be computed by circuits in NC1.
Hence, if we consider a family Cn of NC1 circuits computing Parity, then the polynomial upper
bound in Frege + ‚àÄred follows immediately from Theorem 5.2.
In fact, this upper bound can be improved to the QBF proof system Frege AC0[2] + ‚àÄred, albeit
not for arbitrary NC1-encodings of Parity, as it is not clear how these could be handled in bounded
depth. For this purpose, we consider explicit QBFs for Parity, which can be built from its inductive
definition Parity(x1,..., xn ) = Parity(x1,..., xn‚àí1) ‚äï xn . This leads to the QBFs
Œ¶n = ‚àÉx1 ¬∑¬∑¬∑‚àÉxn‚àÄu‚àÉt2 ¬∑¬∑¬∑‚àÉtn (t2 ‚Üî (x1 ‚äï x2)) ‚àß
n
i=3
(ti ‚Üî (ti‚àí1 ‚äï xi )) ‚àß (u ‚Üî ¬¨tn ),
where a ‚Üî (b ‚äï c) ‚â° (¬¨a ‚à® ¬¨b ‚à® ¬¨c) ‚àß (¬¨a ‚à® b ‚à® c) ‚àß (a ‚à® ¬¨b ‚à® c) ‚àß (a ‚à® b ‚à® ¬¨c). This formulation of Q-Parity was considered by Beyersdorff et al. [2015], where the formulas Œ¶n are shown to
be hard for Q-Res and QU-Res. Here, we obtain:
Corollary 5.5. The Parity-formulas Œ¶n require refutations of exponential size in Frege
AC0[p] + ‚àÄred for each odd prime p, but they have polynomial-size Frege AC0[2] + ‚àÄred refutations.
Proof. The lower bound follows as in Corollary 5.3. For the upper bound, we cannot use Theorem 5.2, but need to give a more direct proof. Without loss of generality, we can assume that our
Frege AC0[2] + ‚àÄred system uses the connectives {‚àß, ‚à®, ¬¨, ‚Üî, ‚äï}.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.   
9:20 O. Beyersdorff et al.
Then it is easy to see, by induction on i, that Frege proves ti ‚Üî ‚äï(x1, x2,..., xi ) with a proof of
size linear in i for each i = 2,...,n. Hence, similarly to what was done in Theorem 5.2, we get
u ‚Üî¬¨‚äï (x1, x2,..., xn ). (13)
Then, u is the rightmost variable in Equation (13); hence, by the ‚àÄred rule, we have
1 ‚Üî¬¨‚äï (x1, x2,..., xn ) and 0 ‚Üî¬¨‚äï (x1, x2,..., xn ),
which gives an immediate contradiction.
In fact, we can further strengthen Corollary 5.5 and use Smolensky‚Äôs circuit lower bounds for
an even more ambitious separation of all Frege AC0[p] + ‚àÄred systems. For this, we consider the
function
MODp (x1,..., xn ) =

1 if n
i=1 xi ‚â° 0 (mod p),
0 otherwise.
For r  p ‚àí 1 let
MODp,r (x1,..., xn ) =

1 if n
i=1 xi ‚â° r (mod p),
0 otherwise.
If we want to use MODp for a separation of Frege AC0[p] + ‚àÄred and Frege AC0[q] + ‚àÄred for different primes p, q, then MODp has to be encoded as a QBF in the language common to both proof
systems, which means that we cannot use MODp or MODq gates. As for Parity, an arbitrary NC1
encoding as in Corollary 5.3 will also not work (this would just give upper bounds in Frege + ‚àÄred),
so we need to devise again explicit QBF encodings for MODp . Such QBFs can be built using the
fact that MODp‚Äîthat is, MODp,0‚Äîcan be defined for r  0 by
MODp,r (x1,..., xi ) = (MODp,r (x1,..., xi‚àí1) ‚àß ¬¨xi ) ‚à® (MODp,r‚àí1 (x1,..., xi‚àí1) ‚àß xi ),
and for r = 0 by
MODp,0 (x1,..., xi ) = (MODp,0 (x1,..., xi‚àí1) ‚àß ¬¨xi ) ‚à® (MODp,p‚àí1 (x1,..., xi‚àí1) ‚àß xi ).
Using variables sr
i for MODp,r (x1,..., xi ) this leads to the QBFs
Œòp
n = ‚àÉx1 ¬∑¬∑¬∑‚àÉxn‚àÄu‚àÉs0
1‚àÉs1
1‚àÉs0
2‚àÉs1
2‚àÉs2
2 ¬∑¬∑¬∑‚àÉs0
n ¬∑¬∑¬∑‚àÉs
p‚àí1 n (u ‚Üî ¬¨s0
n ) ‚àß (s1
1 ‚Üî x1) ‚àß (s0
1 ‚Üî ¬¨x1) ‚àß

1<in
0<rp‚àí1

s
r
i ‚Üî (s
r
i‚àí1 ‚àß ¬¨xi ) ‚à® (sr‚àí1 i‚àí1 ‚àß xi )

‚àß

1<in

s0
i ‚Üî (s0
i‚àí1 ‚àß ¬¨xi ) ‚à® (s
p‚àí1
i‚àí1 ‚àß xi )

.
Corollary 5.6. For each pair p, q of distinct primes the MODp -formulas Œòp
n require refutations of
exponential size in Frege AC0[q] + ‚àÄred, but have polynomial-size refutations in Frege AC0[p] + ‚àÄred.
Proof. The exponential lower bound for the QBF proof system Frege AC0[q] + ‚àÄred follows
from Theorem 5.2 together with the result from Razborov [1987] and Smolensky [1987] that for
distinct primes p, q any family of bounded-depth circuits with MODq gates computing MODp must
be of exponential size.
Regarding the upper bound, without loss of generality, we can assume that our AC0[p]-Frege
system uses the connectives {‚àß, ‚à®, ¬¨, ‚Üî, MODp }. Then it is easy to see, by induction on i, that
AC0[p]-Frege proves
s
r
i ‚Üî MODp (x1,..., xi, 1, 1,..., 1  p‚àír
),
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.          
Frege Systems for Quantified Boolean Logic 9:21
with a proof of size linear in i. Hence, similarly to what was done in Theorem 5.2 and Corollary 5.5,
we get
u ‚Üî ¬¨MODp (x1,..., xn, 1, 1,..., 1  p
). (14)
Then u is the rightmost variable in (14); hence, by the ‚àÄred rule, we have
1 ‚Üî ¬¨MODp (x1,..., xn, 1, 1,..., 1  p
) and 0 ‚Üî ¬¨MODp (x1,..., xn, 1, 1,..., 1  p
),
which gives an immediate contradiction.
Another notorious function in circuit complexity is Majority. Again, we can transform circuit
lower bounds to proof size lower bounds for arbitrary encodings of Majority.
Corollary 5.7 (lower bounds for Q-Majority). Let Cn be a family of polynomial-size circuits computing Majority(x1,..., xn ). Then, for every prime p, the QBFs Q-Cn require refutations
of exponential size in Frege AC0[p] + ‚àÄred.
Proof. The lower bound follows again applying Theorem 5.2 and the fact that Majority
requires exponential-size bounded-depth circuits with MODp gates [Razborov 1987; Smolensky
1987].
For general encodings, we can again show Frege + ‚àÄred upper bounds.
Corollary 5.8 (Q-Majority upper bounds). Let Cn be a family of NC1 circuits computing
Majority(x1,..., xn ). Then, the QBFs Q-Cn have polynomial-size refutations in the QBF proof system Frege + ‚àÄred.
Proof. By a result of Muller and Preparata [1975], the function majority is computable in NC1
and hence Q-Cn are well defined. The upper bound then follows from Theorem 5.2.
As for the MODp functions, we can improve on this upper bound by considering explicit QBF
encodings of Majority, thereby even obtaining a separation of Frege AC0[p] + ‚àÄred systems from
Frege TC0 + ‚àÄred.
6 Explicit QBFs for Majority can be defined using the following property of the
k-threshold function:
Tk (x1,..., xi ) ‚â° Tk (x1,..., xi‚àí1) ‚à® (Tk‚àí1 (x1,..., xi‚àí1) ‚àß xi ). (15)
Using variables ti
k for Tk (x1,..., xi ) this gives rise to the QBFs
Œ®n = ‚àÉx1 ¬∑¬∑¬∑‚àÉxn‚àÄu‚àÉt
1
0t
1
1 ¬∑¬∑¬∑‚àÉt
n
n/2 (u ‚Üî ¬¨t
n
n/2) ‚àß

in
t
i
0 ‚àß (t
1
1 ‚Üî x1) ‚àß

kn/2
in

t
i
k ‚Üî t
i‚àí1
k ‚à® (t
i‚àí1
k‚àí1 ‚àß xi )

.
Corollary 5.9. For each prime p, the Majority-based formulas Œ®n require refutations of
exponential-size in the QBF proof system Frege AC0[p] + ‚àÄred, but have polynomial-size refutations
in Frege TC0 + ‚àÄred.
Proof. The exponential lower bound from [Razborov 1987; Smolensky 1987] will give us the
exponential lower bound w.r.t. the size of Œ®n in Frege AC0[p] + ‚àÄred, since the size of Œ®n is O(n2).
6Clearly, such a separation already follows from Corollary 5.6 together with the simulation of Frege AC0[p] + ‚àÄred by Frege
TC0 + ‚àÄred. Here, we will prove the stronger result that all these systems are separated by one natural principle‚Äînamely,
Majority.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.      
9:22 O. Beyersdorff et al.
Regarding the polynomial-size refutations of the QBF formula Œ®n in Frege TC0 + ‚àÄred, we can
proceed similarly as for Parity in Frege. The crucial feature here is that Tk are, by definition of
TC0, in the language of TC0-Frege. Hence (15) can be used to prove t
j
k ‚Üî Tk (x1,..., xj) and we
can easily refute Œ®n in Frege TC0 + ‚àÄred.
We note that a separation of AC0[p]-Frege from TC0-Frege constitutes a major open problem in
propositional proof complexity as we are currently lacking lower bounds for AC0[p]-Frege.
5.2 Lower Bounds for Constant Depth QBF Frege Systems
We now aim at a fine-grained analysis of AC0-Frege by studying its subsystems AC0
d -Frege. Our
next result is a version of Theorem 5.2, however, we need to be a bit more careful for circuits of
fixed depth d.
Theorem 5.10. Let (Cn )n‚ààN be a non-uniform family of circuits whereCn is a circuit with n inputs.
Then the following implications hold:
(i) if the QBFs Q-Cn have Frege AC0
d + ‚àÄred refutations of size bounded by a function q(n), then
for each n, Cn is equivalent to a depth-(d + 2) circuit C
n of size O(q(n));
(ii) if (Cn )n‚ààN is a family of polynomial-size depth-d circuits, then the QBFs Q-Cn have
polynomial-size refutations in Frege AC0
d + ‚àÄred.
Proof. The proof of (i) follows the proof of the analogous statement of Theorem 5.2. The Strategy Extraction Theorem in this case tells us that from refutations of Q-Cn in Frege AC0
d + ‚àÄred of
size S, we can extract a winning strategy for the universal player that can be computed by AC0
d -
decision lists of size O(S). By Proposition 4.2, this means that the winning strategy can be also
computed by AC0
d+2 circuits and the size upper bound follows.
The proof of point (ii) follows the proof of the analogous statement of Theorem 5.2. That proof
will give us that Q-Cn has polynomial-size refutations in Frege AC0
d+2 + ‚àÄred. Here, we want to
prove that Q-Cn has actually polynomial-size proofs in Frege AC0
d + ‚àÄred. Without loss of generality suppose that the last gate tm of Cn is an 	 with fan-in , that is
Q-Cn = ‚àÉx1 ¬∑¬∑¬∑‚àÉxn‚àÄu‚àÉt1 ¬∑¬∑¬∑‚àÉtm (u ‚Üî ¬¨tm ) ‚àß


tm ‚Üî

j
tij



‚àß œÜn,
where each tij is an 
 gate and œÜn is the encoding of the rest of the circuit Cn. We clearly have
that u ‚Üî ¬¨tm tm ‚Üî 	
j ‚â§ tij
u ‚Üî 

j ‚â§ ¬¨tij
,
from which we obtain both
u ‚à®

j
tij , (16)
¬¨u ‚à®

j
¬¨tij . (17)
Now, we can proceed, similarly as in Theorem 5.2. By induction (on the depth of Cn) AC0
d -Frege is
able to substitute tij with Dij where Dij is an AC0
d‚àí1-formula over the x1,..., xn variables starting
with an 
. More precisely, by induction, we can prove that AC0
d -Frege proves both
tij ‚à® ¬¨Dij , (18)
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.            
Frege Systems for Quantified Boolean Logic 9:23
¬¨tij ‚à® Dij . (19)
Hence from (17) and (18) follows that ¬¨u ‚à® 

j ¬¨Dij , which is an AC0
d -formula only over the
variables u, x1,..., xn. Hence, by the ‚àÄred rule, we get

j
¬¨Dij . (20)
Similarly, from (16), we get first that 	
j (u ‚à® tij ) and then using (19), we get 	
j (u ‚à® Dij ),
which, again, is an AC0
d -formula over the variables u, x1,..., xn. By the ‚àÄred rule, we get

j
Dij . (21)
From (20) and (21) follows immediately a contradiction.
From Theorem 5.10, we obtain a wealth of lower bounds for Res + ‚àÄred.
Corollary 5.11. Let f (x1,..., xn ) be a Boolean function requiring exponential-size depth-3 circuits and let (Cn )n‚ààN be polynomial-size circuits (of unbounded depth) computing f . Then the QBFs
Q-Cn require exponential-size refutations in Frege AC0
1 + ‚àÄred and hence, in particular, in Res + ‚àÄred.
We now prove a separation of constant-depth Frege + ‚àÄred systems. For this, we employ the
Sipser functions separating the hierarchy of constant-depth circuits. We quote the definition of
the Sipserd function from Boppana and Sipser [1990]:
Sipserd =

i1m1

i2m2

i3m3
¬∑¬∑¬∑ 
id md
xi1i2i3 ...id ,
where  = 
 or 	 depending on the parity of d. The variables x1,..., xn appear as xi1i2i3 ...id
for ij  mj , where m1 = 
m/ logm, m2 = m3 = ¬∑¬∑¬∑ = md‚àí1 = m, md = 
dm logm/2 and m =
(n
‚àö
2/d)
1/(d‚àí1)
.
Corollary 5.12. Fix an integer d  2. Let (Cn
d )n‚ààN be a family of polynomial-size depth-(d + 3)
circuits computing the function Sipserd+3 (x1,..., xn ). Then the QBFs Q-Cn
d need exponential-size
refutations in Frege AC0
d + ‚àÄred, but have polynomial-size refutations in Frege AC0
d+3 + ‚àÄred.
Proof. The lower bound follows from Theorem 5.10 and from the result that for every d,
Sipserd+3 needs exponential-size depth-(d + 2) circuits [H√•stad 1986]. Regarding the upper bound,
by constructionCn
d has depth d + 3 and polynomial-size. Hence, by Theorem 5.10, the family Q-Cn
d
has polynomial-size refutations in Frege AC0
d+3 + ‚àÄred.
Note that the gap of size 1 in the circuit separation of H√•stad [1986] increases to a gap of size
3 in our proof system separation, due to the transformation in Proposition 4.2. We highlight that
in contrast to Corollary 5.12 where our separating formulas are CNFs, a separation of the depth-d
Frege hierarchy with formulas of depth independent of d is a major open problem in propositional
proof complexity.
5.3 Characterizing QBF Frege and Extended Frege Lower Bounds
We finally address the question of lower bounds for Frege + ‚àÄred or even EF + ‚àÄred. Our next result
states that achieving such lower bounds unconditionally will either imply a major breakthrough
in circuit complexity or a major breakthrough in classical proof complexity. (Notice that it might
be much easier to obtain the disjunction than any of the disjuncts.)
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.                 
9:24 O. Beyersdorff et al.
Theorem 5.13. Let C be either P/poly or NC1. C -Frege + ‚àÄred is not polynomially bounded if and
only if PSPACE  C or C -Frege is not polynomially bounded.7
Proof. Clearly if C -Frege is not polynomially bounded then C -Frege + ‚àÄred is not polynomially
bounded. If PSPACE  C , then let f be a Boolean function in PSPACE but not in C . Since QBF is
PSPACE-complete there exists a QBF Qw œÜ  (w , x1,..., xn ) with a CNF œÜ such that
f (x1,..., xn ) ‚â° Qw œÜ  (w , x1,..., xn ).
We define
Q-fn = ‚àÉx1 ¬∑¬∑¬∑‚àÉxn‚àÄu (u ‚Üî Qw œÜ  (w , x1,..., xn )),
which can be rewritten into formulas Œòn in prenex form. Notice that the only winning strategy for
the universal player on both Q-fn and Œòn is to compute u = f (x1,..., xn ). Therefore, the Strategy
Extraction Theorem together with f  C immediately implies super-polynomial lower bounds for
Œòn in C -Frege + ‚àÄred.
In the opposite direction, assume that C -Frege + ‚àÄred is not polynomially bounded. Then there
is a sequence of true QBFs Q œàn such that ¬¨Q œàn do not have polynomial-size refutations in
C -Frege + ‚àÄred. Let Q œàn have the form
‚àÄx1‚àÉy1 ¬∑¬∑¬∑‚àÄxn‚àÉyn œàn (x1,..., xn,y1,...,yn ).
If PSPACE  C , then we are done. Otherwise, there are polynomial-size circuitsCi witnessing the
existential quantifiers in Q œàn. That is, for any x1,..., xn,y1,...,yn
n
i=1
(yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1)) ‚Üí œàn (x1,..., xn,y1,...,yn ). (22)
We claim that (22) is a sequence of tautologies without polynomial-size EF proofs. Otherwise,
having ¬¨œàn, C -Frege can derive 

i yi  Ci (x1,..., xi,y1,...,yi‚àí1) by a polynomial-size proof,
and so as in Theorem 4.5, C -Frege + ‚àÄred can efficiently refute ¬¨Q œàn.
Recall that a problem is in uniform NC1 if it is in NC1 and, in addition, there is a polynomialtime algorithm that for each input length generates an NC1 circuit solving the problem. We remark that we do have a separation between uniform NC1 and PSPACE, because uniform NC1 ‚äÜ L
and L  PSPACE by the space hierarchy theorem. Therefore, choosing f ‚àà PSPACE \ uniform NC1
and considering the prenex formulas Œòn arising from Q-fn, we can infer the weaker result that
Frege + ‚àÄred has no uniform short proofs of Œòn.
6 RELATION OF QBF FREGE TO SEQUENT SYSTEMS AND BOUNDED ARITHMETIC
Having defined and analyzed the new QBF Frege systems, it is natural to ask how they compare
to classic sequent calculi‚Äîwhich have a long history for QBF [Cook and Morioka 2005; Dowd
1985; Egly 2012; Kraj√≠ƒçek and Pudl√°k 1990]‚Äîand first-order theories of bounded arithmetic. After
reviewing the necessary prerequisites, we approach both of these questions in this section.
6.1 Background on Sequent Systems and Bounded Arithmetic
6.1.1 Sequent Calculi. Gentzen‚Äôs sequent calculus [Gentzen 1935] is a classical proof system,
both for first-order and propositional logic, cf. Kraj√≠ƒçek [1995]. The propositional sequent calculus
LK operates with sequents Œì ‚àí‚Üí Œî with the semantic meaning 	
œÜ ‚ààŒì œÜ |= 

œà ‚ààŒî œà.
7By NC1, we mean non-uniform NC1. Note that by the space hierarchy theorem it is known that PSPACE  uniform NC1,
but this does not suffice for Frege + ‚àÄred lower bounds.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.              
Frege Systems for Quantified Boolean Logic 9:25
An important rule in LK is the cut rule
Œì ‚àí‚Üí Œî,A A, Œì ‚àí‚Üí Œî
Œì ‚àí‚Üí Œî (cut rule),
where A is called the cut formula. Standard axioms such as 0 ‚àí‚Üí and ‚àí‚Üí 1 are included in the
system LK as well. LK is well known to be p-equivalent to Frege, cf. Kraj√≠ƒçek [1995].
The quantified propositional calculus G, as defined by Cook and Morioka [2005], extends
Gentzen‚Äôs classical propositional sequent calculus LK by allowing quantified propositional formulas in sequents and by adopting the following extra quantification rules for ‚àÄ-introduction:
œï(x/œà ), Œì ‚àí‚Üí Œî
‚àÄx œï, Œì ‚àí‚Üí Œî (‚àÄ-l) Œì ‚àí‚Üí Œî,œï(x/p)
Œì ‚àí‚Üí Œî,‚àÄx œï (‚àÄ-r)
and ‚àÉ-introduction
œï(x/p), Œì ‚àí‚Üí Œî
‚àÉx œï, Œì ‚àí‚Üí Œî (‚àÉ-l) Œì ‚àí‚Üí Œî,œï(x/œà )
Œì ‚àí‚Üí Œî, ‚àÉx œï (‚àÉ-r).
For the rules ‚àÄ-l and ‚àÉ-r, œÜ(x/œà ) is the result of substituting œà for all free occurrences of x in œÜ.
The formula œà may be any quantifier-free formula (i.e., without bounded variables) that is free
for substitution for x in œÜ (i.e., no free occurrence of x in œÜ is within the scope of a quantifier Qy
such that y occurs in œà). The variable p in the rules ‚àÄ-r and ‚àÉ-l must not occur free in the bottom
sequent.
For i  0, Gi is a subsystem of G with cuts restricted to prenex Œ£q
i ‚à™ Œ†q
i -formulas. On propositional formulas G0 is p-equivalent to Frege and G1 is p-equivalent to EF, cf. Kraj√≠ƒçek [1995].
The systems G and Gi were originally introduced slightly differently, cf. Kraj√≠cek and Takeuti
[1992], Kraj√≠ƒçek [1995], and Kraj√≠ƒçek and Pudl√°k [1990], not restricting the formulas œà in ‚àÄ-l and
‚àÉ-r to be quantifier-free, and defining Gi as the system G allowing only Œ£q
i -formulas in sequents.
Hence, Gi‚Äôs could not prove all true QBFs. We will, however, use the redefinition of these systems
by Cook and Morioka [2005]. Notably, (for Cook and Morioka‚Äôs definition) Jer√°bek and Nguyen
[2011] showed that the system Gi with cuts restricted to prenex Œ£q
i -formulas is p-equivalent to
Gi with cuts restricted to prenex Œ†q
i -formulas and p-equivalent to Gi with cuts restricted to (not
necessarily prenex) Œ£q
i ‚à™ Œ†q
i -formulas. Moreover, these equivalences hold as well for the tree-like
versions of these systems. Cook and Morioka [2005] also proved that their definition of Gi is pequivalent to Gi from Kraj√≠ƒçek and Pudl√°k [1990] for i  0 and prenex Œ£q
i ‚à™ Œ†q
i -formulas (so, by
Jer√°bek and Nguyen [2011], also for non-prenex ones). Finally, the systems Gi and tree-like Gi have
quite constructive witnessing properties. Whenever there are polynomial-size tree-like G1 proofs of
formulas ‚àÉy An (x,y) for An (x,y) ‚àà Œ£q
1 , there exist polynomial-size circuits Cn witnessing the existential quantifiers, i.e., the formula An (x,Cn (x)) holds, cf. Cook and Morioka [2005], Theorem 7.
In case of G0, the circuits witnessing Œ£q
1 -formulas are from NC1, cf. Cook and Morioka [2005], Theorem 9. The witnessing theorems can be generalized to systems tree-like Gi and Gi for i  1 w.r.t.
Œ£q
i -formulas and witnessing functions corresponding to higher levels of the polynomial hierarchy.
6.1.2 Bounded Arithmetic. In first-order logic, it is customary to consider the language L =
{0, S, +, ¬∑, ,  x
2 , |x |, #}, where the function |x | is intended to mean ‚Äúthe length of the binary representation of x‚Äù and x#y = 2|x |¬∑|y |
.
A quantifier is bounded if it has the form ‚àÉx, x  t or ‚àÄx, x  t for x not occurring in the term t.
A bounded quantifier issharply bounded if t has the form |s| for some terms. By Œ£b
0 (=Œ†b
0 = Œîb
0 ), we
denote the set of all formulas in the language L with all quantifiers sharply bounded. Fori  0, the
sets Œ£b
i+1 and Œ†b
i+1 are defined inductively. Œ£b
i+1 is the closure of Œ†b
i under bounded existential and
sharply bounded quantifiers, and Œ†b
i+1 is the closure of Œ£b
i under bounded universal and sharply
bounded quantifiers; that is, the complexity of bounded formulas in the language L (formulas with
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.   
9:26 O. Beyersdorff et al.
all quantifiers bounded) is defined by counting the number of alternations of bounded quantifiers,
ignoring the sharply bounded ones. For i > 0, Œîb
i denotes Œ£b
i ‚à© Œ†b
i .
Bounded formulas capture the polynomial hierarchy: for any i > 0 the ith level Œ£p
i of the polynomial hierarchy coincides with the sets of natural numbers definable by Œ£b
i -formulas. Dually for
Œ†p
i and Œ†b
i .
Buss [1986a] introduced theories of bounded arithmetic Si
2, Ti
2 for i  1 in the language L. The
axioms of Si
2 consist of a set of basic axioms defining properties of symbols from L, cf. Kraj√≠ƒçek
[1995], and length induction Œ£b
i -LIND, which is the following scheme for Œ£b
i -formulas A (or equivalently, for A ‚àà Œ†b
i , in which case, we speak of Œ†b
i -LIND):
A(0) ‚àß ‚àÄx (A(x) ‚Üí A(x + 1)) ‚Üí ‚àÄx A(|x |).
Theories Ti
2 are defined similarly, but here the induction scheme is
A(0) ‚àß ‚àÄx (A(x) ‚Üí A(x + 1)) ‚Üí ‚àÄx A(x)
for A ‚àà Œ£b
i .
By FPŒ£p
i [O(log n)], we denote the set of functions computed by a polynomial-time Turing machine making at most O(logn) queries to a Œ£p
i -oracle. FPŒ£p
i is defined analogously but without the
restriction on the number of queries. Ti
2 proves the totality of functions FPŒ£p
i computable in polynomial time under a Œ£p
i oracle, cf. Kraj√≠ƒçek [1995], Theorem 6.1.2. More precisely, for any f ‚àà FPŒ£p
i
there is a Œ£b
i+1-formula f (x) = y such that Ti
2  ‚àÄx‚àÉy f (x) = y. In the same way, Si
2 proves the totality of functions in FPŒ£p
i [O(logn)], which are computed in polynomial time with at mostO(logn)
queries to a Œ£p
i -oracle, cf. Kraj√≠ƒçek [1995], Theorem 6.2.2. By Parikh‚Äôs theorem, Ti
2  ‚àÉy f (x) = y
implies Ti
2  ‚àÉy (|y|  p(|x |) ‚àß f (x) = y) for some polynomial p, and the same is true for Si
2, cf.
Buss [1986a] and Parikh [1971].
Si
2 can be seen as a first-order non-uniform version of tree-like Gi, i  1. First, for j  1 any Œ£b
j -
formula œÜ(x) can be translated into a sequence œÜ(x)n of Œ£q
j -formulas, where n denotes the size
of the input x in binary (cf. Kraj√≠ƒçek [1995], Definition 9.2.1). Then, for i, j  1, whenever Si
2  A
for A ‚àà Œ£b
j , there is a polynomial p such that formulas An have tree-like Gi-proofs of size p(n).
This also holds for Ti
2 in place of Si
2 if tree-like Gi is replaced by Gi. The ability to use arbitrary
j is due to Cook and Morioka [2005] (Theorem 3), who generalized a standard result, cf. Kraj√≠ƒçek
[1995] (Theorem 9.2.6), which worked for j = i.
If A ‚àà Œ†b
1 , then we abuse notation and also denote by An the propositional formulas obtained
as in An, but leaving the universally quantified variables free. S1
2  A for A ‚àà Œ†b
1 implies that
S1
2 proves the existence of polynomial-size tree-like G1-proofs of propositional formulas An, cf.
Kraj√≠ƒçek [1995] (Theorems 9.2.6 and 9.2.7).
6.2 Intuitionistic Logic Corresponds to Extended Frege for QBFs
The main information on strong propositional and QBF systems stems from their correspondence
to first-order theories of bounded arithmetic, cf. Beyersdorff [2009], Cook and Nguyen [2010], and
Kraj√≠ƒçek [1995]. In this sense, tree-like G1 corresponds to S1
2 and G1 to T1
2 as explained above. Here,
we will establish such a correspondence between first-order intuitionistic logic and EF + ‚àÄred.
Buss [1986b] developed an intuitionistic version of S1
2, denoted IS1
2, and showed that for any formula A, IS1
2  ‚àÉy A(x,y) implies the existence of a polynomial-time function f such thatA(x, f (x))
holds. This witnessing property resembles the Strategy Extraction Theorem for EF + ‚àÄred. Using
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020. 
Frege Systems for Quantified Boolean Logic 9:27
the formalized Strategy Extraction Theorem, we can make the correspondence between these systems formal.8
First, we recall the definition of IS1
2 by Cook and Urquhart [1993]. It is equivalent to Buss‚Äô original
definition, cf. Buss [1986b]. IS1
2 is a theory in the language L (like S1
2), with underlying intuitionistic
predicate logic, a set of basic axioms defining properties of symbols from L, and a polynomial
induction scheme for Œ£b+
1 -formulas A:
A(0) ‚àß ‚àÄx

A

x
2

‚Üí A(x)

‚Üí ‚àÄx A(x),
where Œ£b+
1 -formulas are Œ£b
1 -formulas without negation and implication connectives. S1
2 is Œ£b
0 -
conservative overIS1
2, cf. Cook and Urquhart [1993] (Corollary 1.7); that is, any Œ£b
0 formula provable
in S1
2 is provable already in IS1
2.
We will also use Cook and Urquhart‚Äôs conservative extension of IS1
2 denoted IPV, cf. Cook
and Urquhart [1993] (Chapter 4 and Theorem 4.12). IPV is defined by adding intuitionistic predicate logic to Cook‚Äôs theory PV, cf. Cook [1975]. The language of IPV consists of symbols for all
polynomial-time functions. The hierarchy of formulas Œ†b
i (PV) is defined analogously as Œ†b
i but in
the language of IPV. Also, propositional translations An for Œ†b
1 (PV)-formulasA are defined analogously as in the case of A ‚àà Œ†b
1 . Consequently, IPV  A for A ‚àà Œ†b
1 (PV) implies that propositional
formulas An have polynomial-size EF proofs, cf. Kraj√≠ƒçek [1995] (Theorem 9.2.7).
Cook and Urquhart [1993] (Corollary 8.18) generalized Buss‚Äô witnessing theorem: Whenever
IPV  ‚àÄx‚àÉy A(x,y) for an arbitrarily complex formula A, then there is a polynomial-time function
f (with an IPV function symbol f ) such that IPV  ‚àÄx A(x, f (x)).
We are now ready to derive the correspondence between IS1
2 and EF + ‚àÄred. The correspondence
consists of two parts (cf. Beyersdorff [2009]). For the first part, we translate first-order formulas
œÜ into sequences of QBFs [Kraj√≠ƒçek and Pudl√°k 1990] and show that translations of provable IS1
2
formulas have short EF + ‚àÄred proofs.
Theorem 6.1. If IS1
2 proves a statementT in prenex form, then there exist polynomial-size EF + ‚àÄred
refutations of ¬¨T n where n denotes the size of the input variables in binary.
Proof. By Cook and Urquhart‚Äôs improvements of Buss‚Äô witnessing theorem, if IS1
2 proves T of
the form
‚àÄx1‚àÉy1 ¬∑¬∑¬∑‚àÄxn‚àÉyn T 
(x1,..., xn,y1,...,yn )
for T  ‚àà Œ£b
0 , then there is an IPV-function f1 (x1) such that
IPV  ‚àÄx1‚àÄx2‚àÉy2 ¬∑¬∑¬∑‚àÄxn‚àÉyn T 
(x1,..., xn, f1 (x1),y2,...,yn ).
Iterating this argument all existential quantifiers of T can be witnessed provably in IPV by
polynomial-time functions f1,..., fn. Therefore, IPV proves the Œ†b
1 (PV) formula
œÜ =
n
i=1
(yi ‚Üî fi (x1,..., xi )) ‚Üí T 
(x1,..., xn,y1,...,yn ) (23)
and the formulas œÜn have polynomial-size EF proofs. EF + ‚àÄred can now refute ¬¨T n in polynomial size by deriving 

i (yi  fi (x1,..., xi )) and cutting all the disjuncts as in the proof of
Theorem 4.5.
8It could be tempting to expect that an adequate counterpart to IS1
2 would be intuitionistic propositional logic. However,
intuitionistic propositional logic admits the feasible interpolation property, cf. Buss and Mints [1999], while IS1
2 can (constructively) prove ‚àÄx, z [A(x, y) ‚à® B(x, z)], in principle, without the existence of an efficient interpolant. It is also known,
cf. Ghasemloo and Pich [2013], that IS1
2  ‚àÄy A(x, y) ‚à® ‚àÄz B(x, z) implies the existence of an efficient interpolating circuit,
but moving the universal quantifiers inside the disjunction is a priori not allowed in intuitionistic logic.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.  
9:28 O. Beyersdorff et al.
The second part of the correspondence consists in proving the soundness of the proof systems
in the first-order theory. For this, we need to express the correctness of EF + ‚àÄred by QBFs. This is
typically done by the reflection principle of a proof system P, stating that whenever œÜ has a P-proof
(respectively, a P-refutation), then œÜ is true (respectively, false).
Here, the Formalized Strategy Extraction Theorem allows us to express the reflection principle
of EF + ‚àÄred by a Œ†b
1 -formula Ref(EF + ‚àÄred). More precisely, we define Ref(EF + ‚àÄred) as the Œ†b
1 -
formula expressing that if œÄ is a proof of a QBF, then circuits Ci (x1,..., xi,y1,...,yi‚àí1) obtained
as in the Strategy Extraction Theorem witness the existential quantifiers in the QBF as in the
statement of Theorem 6.2 below.
To show this reflection principle in IS1
2, we return again to the Strategy Extraction Theorem and
provide a different formalization than in Theorem 4.4, this time in the theory S1
2.
Theorem 6.2 (Formalized Strategy Extraction). There is a linear-time algorithm A such that
S1
2 proves the following: Assume that œÄ is an EF + ‚àÄred refutation of a QBF œà of the form
‚àÉx1‚àÄy1 ¬∑¬∑¬∑‚àÉxn‚àÄyn œÜ(x1,..., xn,y1,...,yn ),
where œÜ ‚àà Œ£q
0 . Then A(œÄ ) outputs n circuits C1 (x1),..., Cn (x1,..., xn,y1,...,yn‚àí1) defining a winning strategy for the universal player on formula œà; that is,
‚àÄx1 ¬∑¬∑¬∑‚àÄxn‚àÄy1 ¬∑¬∑¬∑‚àÄyn
‚é°
‚é¢
‚é¢
‚é¢
‚é¢
‚é£
n
i=1
(yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1)) ‚Üí ¬¨œÜ(x1,..., xn,y1,...,yn )
‚é§
‚é•
‚é•
‚é•
‚é•
‚é¶
.
Proof. It is just sufficient to inspect the proof of the Strategy Extraction Theorem from Section 4
and point out that it essentially uses a Œ†b
1 -induction on the number of steps in the proof œÄ; that
is, Œ†b
1 -LIND available in S1
2. For convenience of the reader, we recap here what was the approach.
Let œÄ = (L1,..., Ls ) be an EF + ‚àÄred refutation of the QBF Q œÜ given as in Theorem 6.2 and put
œÄs = ‚àÖ, œÄi = (Li+1,..., Ls ) for i < s,
œÜ0 = œÜ, œÜi = œÜ ‚àß L1 ‚àß¬∑¬∑¬∑‚àß Li for i > 0.
We show by downward induction on i, that from œÄi it is possible to construct in linear time a
winning strategy
œÉi = {Ci
1 (x1),...,Ci
n (x1,..., xn,y1,...,yn‚àí1)}
for the universal player for the QBF Q œÜi . The statement of the Formalized Strategy Extraction
Theorem corresponds to the case i = 0.
In the base case, œÜs contains a contradiction, and the winning strategy can be defined as the set
of trivial circuits {0,..., 0}. Assume now that œÉi is a winning strategy for Q œÜi . If Li is derived by
an EF rule, then we set œÉi‚àí1 = œÉi
. Assume now that Li = Lj[u/B] is the result of an application of
a ‚àÄred rule on Lj where u is the rightmost variable in Lj . We define Ci‚àí1
l = Ci
l if u  yl ; otherwise,
we set
Ci‚àí1
l (z) =

B(z) if Lj[u/B](z) = 0,
Ci
l (z) if Lj[u/B](z) = 1.
This constructs circuitsCi
l from œÄi by a standardO(|œÄi |)-time algorithm. To show that the strategies œÉi are winning for any 0  i  |œÄ |, we need to analyze the inductive step.
Assume that œÉi is the winning strategy for the universal player on Q œÜi . If Li is derived by
an EF rule, then the winning strategy for Q œÜi works also for Q œÜi‚àí1, because a falsification of
Li by a given assignment implies a falsification of one of its predecessors. If Li is the result of an
application of ‚àÄred, thenCi‚àí1
l (z) is redefined only if Lj[u/B](z) = 0. For z such that Lj[u/B](z) = 1,
the strategy œÉi has to work also for Q œÜi‚àí1. Therefore, œÉi‚àí1 is a winning strategy for the universal
player on Q œÜi‚àí1.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.    
Frege Systems for Quantified Boolean Logic 9:29
An NP predicate is a set of binary strings accepted by a non-deterministic polynomial-time
machine, and similarly for coNP predicates. The statement that a strategy œÉ is winning for the
universal player on Q œà is a coNP predicate (given œÄ) expressible as a well-behaved Œ†b
1 -formula.
The induction we used is on the number of steps in œÄ. Hence, the presented proof is an S1
2-proof.
This implies the second part of the correspondence of IS1
2 to EF + ‚àÄred.
Corollary 6.3. IS1
2 proves Ref(EF + ‚àÄred).
Proof. The claim follows from Theorem 6.2 together with the Œ£b
0 -conservativity of S1
2 over IS1
2
[Cook and Urquhart 1993].
Corollary 6.3 implies that EF + ‚àÄred is the weakest proof system that allows short proofs of all IS1
2
theorems, i.e., whenever Theorem 6.1 holds for a ‚Äúdecent‚Äù proof system P in place of EF + ‚àÄred, then
P p-simulates EF + ‚àÄred on QBFs: If Theorem 6.1 holds for a proof system P, then by Corollary 6.3,
there are polynomial-size P-proofs of Ref(EF + ‚àÄred)n. Hence, if œÄ is an EF + ‚àÄred proof of a QBF
œà, then P has |œÄ |
O (1)
-size proofs of œà with the existential quantifiers witnessed by some circuits.
By P being decent, we mean that P can introduce efficiently the existential quantifiers in place of
the witnessing circuits and this way proveœà efficiently in the size of œÄ; that is, P is decent if it can
derive œà efficiently in the length of the shortest derivation of œà witnessed by some circuits.
However, EF + ‚àÄred is intuitively the strongest proof system for which IS1
2 proves the reflection
principle. Technically, this only holds for proof systems that admit the Strategy Extraction Theorem, as for other systems, we would need to define the reflection principle as a more complex
statement. (Nevertheless, IS1
2 provability of the reflection principle for Œ£q
k -formulas for any fixed
k implies strategy extraction for the given proof system.)
6.3 Gentzen and Frege for QBFs
We now compare the classic Gentzen systems with our new Frege systems. The two formalisms
are well known to be equivalent in the classical propositional case [Kraj√≠ƒçek 1995]. By applying the
formalized Strategy Extraction Theorem, we show that Gentzen systems simulate Frege systems
in the QBF context (cf. Figure 1 in Section 1.1). However, the opposite simulations (Gentzen by
Frege) are very likely false as we show by a number of conditional separations.
Theorem 6.4. Tree-like G1 p-simulates EF + ‚àÄred.
Proof. By Theorem 4.5, any EF + ‚àÄred refutation œÄ of a QBF œà of the form
‚àÉx1‚àÄy1 ¬∑¬∑¬∑‚àÉxn‚àÄyn œÜ(x1,..., xn,y1,...,yn )
where œÜ ‚àà Œ£q
0 can be transformed in time |œÄ |
O (1) into an EF proof of
n
i=1
(yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1)) ‚Üí ¬¨œÜ(x1,..., xn,y1,...,yn )
for certain circuits Ci . We want to derive ¬¨œà in tree-like G1. Since we do not distinguish between
a refutation of œà and provability of ¬¨œà, this will prove the theorem.
Claim 6.5. There is a |œÄ |
O (1)
-size tree-like G1 proof of the following sequent
{yi = Ci (x1,..., xi,y1,...,yi‚àí1)}
n
i=1 ‚àí‚Üí ¬¨œÜ(x1,..., xn,y1,...,yn )
where the encoding of circuits Ci might use some auxiliary variables.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.  
9:30 O. Beyersdorff et al.
Proof of claim. To see that the claim holds, note first that by the p-equivalence of EF and
tree-like G1 (cf. Kraj√≠ƒçek [1995]), the EF proof obtained above can be turned into a |œÄ |
O (1)
-size
tree-like G1-proof of the formula
¬¨

n
i=1
yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1)

‚à® ¬¨œÜ.
This proof can be easily modified so the ‚à® connective is not introduced, leading to a |œÄ |
O (1)
-size
tree-like G1-proof of the sequent
‚àí‚Üí ¬¨

n
i=1
yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1)

, ¬¨œÜ.
Moving ¬¨(
	n
i=1 yi = Ci (x1,..., xi,y1,...,yi‚àí1)) from the succedent to the antecedent, we obtain
n
i=1
(yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1)) ‚àí‚Üí ¬¨œÜ.
Finally, tree-like G1 derives the sequent we want by ‚Äúnot introducing‚Äù ‚àß in the antecedent. This
proves the claim.
Moving ¬¨œÜ to the succedent, applying ‚àÄ-l and ‚àÉ-l introductions, tree-like G1 then derives
‚àÄyn œÜ(x1,..., xn,y1,...,yn ), Œì, ‚àÉyn (yn ‚Üî Cn (x1,..., xn,y1,...,yn‚àí1)) ‚àí‚Üí
where Œì = {yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1)}
n‚àí1 i=1 .
As tree-like G1 proves efficiently ‚àí‚Üí ‚àÉy (y ‚Üî C(x)) for any circuit C, we can cut the formula
‚àÉyn (yn ‚Üî Cn (x1,..., xn,y1,...,yn‚àí1)) out of the antecedent and derive
‚àÄyn œÜ, {yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1)}
n‚àí1 i=1 ‚àí‚Üí .
Now, we use ‚àÉ-l introduction to obtain
‚àÉxn‚àÄyn œÜ, {yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1)}
n‚àí1 i=1 ‚àí‚Üí .
In this way, we can gradually cut out all remaining formulas from the antecedent, quantify all
variables, move œà to the succedent, and derive ¬¨œà in tree-like G1 by a proof of size |œÄ |
O (1)
.
To introduce the quantifier prefix of œà in the previous proof, we needed to cut Œ£q
1 -formulas. We
would like to use a similar proof to simulate Frege + ‚àÄred by tree-like G0. However, tree-like G0
is allowed to cut only Œ£q
0 -formulas. Therefore, we obtain just a simulation of Frege + ‚àÄred by
tree-like G0 where the proven sequent in tree-like G0 contains a non-empty (easily derivable)
antecedent.
Theorem 6.6. There is a polynomial-time function t such that given any Frege + ‚àÄred refutation
of a QBF œà of the form
‚àÉx1‚àÄy2 ¬∑¬∑¬∑‚àÉxn‚àÄyn œÜ(x1,..., xn,y1,...,yn )
where œÜ ‚àà Œ£q
0 , t(œÄ ) is a tree-like G0 proof of the sequent
‚àÄx1‚àÉy1 ¬∑¬∑¬∑‚àÄxn‚àÉyn
n
i=1
yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1) ‚àí‚Üí ¬¨œà
for some formulas Ci . Note that the antecedent has a tree-like G0 proof of size |œÄ |
O (1)
.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.    
Frege Systems for Quantified Boolean Logic 9:31
Proof. By Theorem 4.5, any Frege + ‚àÄred refutation œÄ of a QBF œà can be transformed in time
|œÄ |
O (1) into a -Frege proof of
n
i=1
(yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1)) ‚Üí ¬¨œÜ(x1,..., xn,y1,...,yn )
for certain formulasCi . Analogously as in the proof of Theorem 6.4, we efficiently obtain a |œÄ |
O (1)
-
size tree-like G0 proof of
n
i=1
yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1) ‚àí‚Üí ¬¨œÜ.
Applying rules ‚àÄ-l, ‚àÉ-l, ‚àÄ-l, ‚àÉ-l (in this order), we derive
‚àÉxn‚àÄyn œÜ,‚àÄxn‚àÉyn
n
i=1
yi ‚Üî Ci (x1,..., xi,y1,...,yi‚àí1) ‚àí‚Üí .
In this way, we efficiently introduce all quantifiers, then move œà to the succendent, and derive
the required sequent in tree-like G0.
We now prove some conditional separations between Gentzen and Frege systems for QBF. As
we saw in Section 5.3, improving these separations to unconditional results tightly corresponds to
major open problems in circuit complexity and proof complexity.
6.3.1 Formulas Hard in Gentzen, but Easy in Frege. We first give formulas (conditionally) hard
for G0, but easy for EF + ‚àÄred.
Theorem 6.7. If P/poly  NC1, then there are Œ£q
1 -formulas with polynomial-size EF + ‚àÄred proofs
but without polynomial-size G0 proofs.
Proof. Let f be a function in P/poly. Then EF + ‚àÄred has simple polynomial-size proofs of Œ£q
1
formulas ‚àÉy ‚àÉz f (x) = y expressing the totality of f with auxiliary variables z representing nodes
of a polynomial-size circuit computing f . The EF + ‚àÄred proof refutes the propositional formula
f (x)  y by gradually replacing each variable from z,y by the circuit it represents. If the totality of
f has polynomial-sizeG0 proofs, then by the Œ£q
1 witnessing property, cf. Cook and Morioka [2005]
(Theorem 9), f is in NC1.
Notably, in Section 4.2, we showed that Frege + ‚àÄred and EF + ‚àÄred are p-equivalent to their
tree-like versions. This is open for G0 and G1, thus providing some further evidence for the incomparability of Gentzen and Frege in QBF.
6.3.2 Formulas Easy in Gentzen, but Hard in Frege. We now provide three different properties that are easy for QBF Gentzen systems, but hard for EF + ‚àÄred. Our first conditional result
shows that there are Œ£q
2 -formulas with polynomial-size tree-like G1 proofs but no polynomial-size
EF + ‚àÄred proofs, and this result generalizes to stronger systems.
Theorem 6.8. Let i  1. Assume f ‚àà FPŒ£p
i is hard for P/poly. Then the formulas ‚àÉy (|y|
p(|x |) ‚àß f (x) = y)n, where p is a polynomial and f (x) = y is expressed by a Œ£b
i+1-formula, have
polynomial-size Gi proofs and require super-polynomial-size EF + ‚àÄred proofs. If f ‚àà FPŒ£p
i [O(logn)],
then Gi can be replaced by tree-like Gi.
Proof. Since Ti
2 proves the totality of FPŒ£p
i functions [Buss 1986a], it proves the totality of f
and the proof can be transformed into a sequence of polynomial-size Gi proofs [Cook and Morioka
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.     
9:32 O. Beyersdorff et al.
2005; Kraj√≠ƒçek and Pudl√°k 1990]. If the totality of f can be shown by polynomial-size proofs in
EF + ‚àÄred, then, by the Strategy Extraction Theorem, f is in P/poly.
Similarly, Si
2 proves the totality of FPŒ£p
i [O(logn)] functions and such proofs translate into sequences of polynomial-size tree-like Gi proofs [Buss 1986a; Cook and Morioka 2005; Kraj√≠ƒçek and
Pudl√°k 1990].
It seems that the separation above of tree-like G1 and EF + ‚àÄred by Œ£q
2 -formulas cannot be improved to Œ£q
1 -formulas, as it is tight in the following sense. If we had Œ£q
1 -formulas ‚àÉy An (x,y) with
polynomial-size tree-like G1 proofs but without polynomial-size EF + ‚àÄred proofs, then this would
imply that EF is not polynomially bounded: By the witnessing theorem for tree-like G1, cf. Cook
and Morioka [2005] (Theorem 7), there would be polynomial-size circuits Cn such that formulas
An (x,Cn (x)) are true, and so ¬¨An (x,Cn (x)) would be hard to refute in EF.
The QBF proof systems tree-like G1 and EF + ‚àÄred can be conditionally separated also on the
bounded collection scheme.
Definition 6.9. The bounded collection scheme BB(œÜ) is the formula
‚àÉi < |a| ‚àÉw < t(a) ‚àÄu < a ‚àÄj < |a| (œÜ(i,u) ‚Üí œÜ(j,[w]j)),
where œÜ(i,u) is a formula that can have other free variables, [w]j is the jth element of the sequence
coded by w, and t(a) is a concrete L-term depending on the choice of the encoding of sequences.
Roughly, BB(œÜ) says that u‚Äôs witnessing œÜ(i,u) can be collected in a sequence w:
‚àÄi < |a| ‚àÉu < a, œÜ(i,u) ‚Üí ‚àÉw < t(a) ‚àÄj < |a|, œÜ(j,[w]j).
Theorem 6.10. The QBF proof system tree-like G1 has polynomial-size proofs of BB(œÜ)n for all
œÜ ‚àà Œ£b
1 . In contrast, there exists œÜ ‚àà Œ£b
1 such that formulas BB(œÜ)n are hard for EF + ‚àÄred unless
each polynomial-time permutation with n inputs can be inverted by polynomial-size circuits with
probability at least 1 ‚àí 1/n.
Proof. The upper bound follows from the S1
2-provability of BB(œÜ) for œÜ ‚àà Œ£b
1 , cf. Buss [1986a]
(Theorem 14), and its transformation to tree-like G1 proofs [Cook and Morioka 2005; Kraj√≠ƒçek
and Pudl√°k 1990]. For the lower bound, we will use a result by Cook and Thapen [2006] showing
that Cook‚Äôs theory PV does not prove BB(œÜ) for all œÜ ‚àà Œ£b
0 unless factoring is in probabilistic
polynomial time.
Let a = 2n and œÜ(i,u) be the formula f (u) = [y]i for a polynomial-time permutation f (defined
by a Œ£b
1 formula), and y encoding a sequence of n strings of length n.
Assume that EF + ‚àÄred has polynomial-size proofs of BB(œÜ)n. By the Strategy Extraction Theorem, there are polynomial-size circuits B, C such that
‚àÉu < 2n, f (u) = [y]C(y) ‚Üí ‚àÄj < n, f ([B(y)]j) = [y]j . (24)
To invert f , we proceed as follows: Given z ‚àà {0, 1}
n, pick randomly n strings si ‚àà {0, 1}
n and let
i0 be a position (a non-uniform advice) such that Pry [C(y) = i0]  1/n where y‚Äôs are sequences
of n strings of length n. Define yz,s to be the sequence of elements z, f (s1),..., f (sn‚àí1) ordered
so [yz,s ]i0 = z and let xz,s be the sequence of z,s1,...,sn‚àí1 ordered so f ([xz,s ]i ) = [yz,s ]i for
i  i0. For random strings z,s1,...,sn‚àí1, we have that yz,s is a random sequence of n strings
of length n and Prz,s1,...,sn [C(yz,s ) = i0]  1/n. Consequently, with probability at least 1 ‚àí 1/n,
f ([xz,s ]C(yz,s )) = [yz,s ]C(yz,s ) holds and by Equation (24) the inverse of f on z is [B(yz,s )]i0 .
While the previous two results exhibited formulas easy for tree-like G1 and hard for EF + ‚àÄred,
we now show that even tree-like G0 can prove Œ£q
2 -formulas hard for EF + ‚àÄred (modulo a hardness
assumption).
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.     
Frege Systems for Quantified Boolean Logic 9:33
Fig. 2. The tree-like G0 derivation in the proof of Theorem 6.11.
For this, we use a result by Bonet et al. [2000], who showed that Frege systems do not admit the so-called feasible interpolation property unless factoring of Blum integers is solvable by
polynomial-size circuits. (A Blum integer is the product of two distinct primes, which are both
congruent 3 modulo 4.)
It is possible to separate tree-like G0 and EF + ‚àÄred even under the assumption NP  P/poly.
The separating Œ£q
2 -formulas are of the form
‚àÄx ‚àÉy ‚àÄz (Sat(x,y) ‚à® ¬¨Sat(x, z))
and state that each propositional formula is either satisfiable or unsatisfiable. These formulas have
polynomial-size tree-like G0 proofs, because their two-sorted formulation is easily provable in the
theory known as VNC1, the two-sorted version of tree-like G0, cf. Cook and Morioka [2005]. (In
fact, this is already provable in the two-sorted logic without the extra axioms of VNC1.) However,
if these formulas were easy for EF + ‚àÄred, by strategy extraction, we would get polynomial-size
circuits for SAT. As presenting this argument formally would require to introduce two-sorted theories of bounded arithmetic and the corresponding machinery, we prove here only the separation
based on the stronger assumption of the hardness of factoring.
Theorem 6.11. There are Œ£q
2 -formulas with polynomial-size tree-like G0 proofs. However, assuming factoring of Blum integers is not computable by polynomial-size circuits, these formulas require
EF + ‚àÄred proofs of super-polynomial size.
Proof. Bonet et al. [2000] showed that there are propositional formulas A0 (x,y), A1 (x, z) with
common variables x such that A0 (x,y) ‚à® A1 (x, z) have polynomial-size -Frege proofs but, unless
factoring of Blum integers is computable by polynomial-size circuits, there are no polynomial-size
circuits C(x) recognizing which of A0 (x,y) or A1 (x, z) holds for a given x.
Frege is p-equivalent to tree-like G0 on propositional formulas [Kraj√≠ƒçek 1995] and so it is possible to derive in tree-like G0 the sequents in Figure 2.
Therefore, the Œ£q
2 -formulas
‚àÉb ‚àÄy‚àÄu ((A0 (x,y) ‚àß ¬¨b) ‚à® (A1 (x,u) ‚àß b))
have polynomial-size tree-like G0 proofs.
If these formulas had polynomial-size EF + ‚àÄred proofs, then, by the Strategy Extraction Theorem, there would be polynomial-size circuits computing b from x and thus recognizing which of
A0 (x,y) and A1 (x,u) holds.
We remark that the assumptions of Theorems 6.10 and 6.11 are stronger than the assumption
of Theorem 6.8. However, while factoring forms a good candidate for a one-way function, it is not
known if the existence of one-way functions implies the existence of one-way permutations.
Journal of the ACM, Vol. 67, No. 2, Article 9. Publication date: March 2020.  
9:34 O. Beyersdorff et al.
7 CONCLUSION
Our work opens up two lines of research that we believe might have a significant influence on
QBF proof complexity and beyond.
Exploring new QBF proof systems. The first of these is the study of natural and powerful QBF
proof systems that correspond to ideas developed in propositional proof complexity for many
years. While we concentrate here on the hierarchy C -Frege + ‚àÄred of new QBF Frege systems, our
definitions introduce meaningful versions of algebraic and geometric proof systems for QBF. These
systems will be very interesting to study from a theoretical perspective and also might provide an
important stimulus on QBF solving‚Äîanalogous to the potential of integer linear programming and
polynomial calculus for SAT solving.
Understanding the transfer from circuit to proof complexity. As far as we know, for the first time
in the literature, our lower bound technique via strategy extraction gives a formal and rigorous
account on the relation between a circuit class C and proof systems using lines from C . Building
on the previous work of Beyersdorff et al. [2015], we establish this relation for a full hierarchy of
QBF systems. This yields very strong results in QBF proof complexity. In the recent survey of Buss
[2012], the propositional versions of our results C.(i) and (iii) in Section 1.1 are referenced as ‚Äúthe
main open problems at the ‚Äòfrontier‚Äô of Cook‚Äôs program.‚Äù
We believe that this transfer has the potential to generate lots of further research, both in QBF
and indeed for further logics, possibly even including the most important classical propositional
case. As for QBFs, the hard formulas Q-f that we generate from a Boolean function f have a
special syntactic form, i.e., for all functions we use here they are prefixed by ‚àÉ‚àÄ‚àÉ. Can we also
apply our technique to conceptually different types of QBFs? It is also possible that similar ideas are
effective for further logics, possibly modal or intuitionistic logics, as they share the same PSPACE
complexity, and strong lower bounds are known for Frege systems in these logics as well [Hrube≈°
2009; Je≈ô√°bek 2009].