How efficiently can we find an unknown graph using distance or shortest path queries between its vertices?
We assume that the unknown graph G is connected, unweighted, and has bounded degree. In the reconstruction problem, the goal is to find the graph G. In the verification problem, we are given a hypothetical graph
Gˆ and want to check whether G is equal to Gˆ.
We provide a randomized algorithm for reconstruction using O˜ (n3/2) distance queries, based on Voronoi
cell decomposition. Next, we analyze natural greedy algorithms for reconstruction using a shortest path
oracle and also for verification using either oracle, and show that their query complexity is n1+o(1)
. We further
improve the query complexity when the graph is chordal or outerplanar. Finally, we show some lower bounds,
and consider an approximate version of the reconstruction problem.
CCS Concepts: • Networks→ Network algorithms; • Theory of computation→ Graph algorithms analysis;
Data structures design and analysis;
Additional Key Words and Phrases: Reconstruction, verification, network tomography
1 INTRODUCTION
How efficiently can we find an unknown graph using distance or shortest path queries between its
vertices? This is a natural theoretical question from the standpoint of recovery of hidden information. This question is related to the reconstruction of internet networks. Discovering the topology
of the internet is a crucial step for building accurate network models and designing efficient
algorithms for internet applications. Yet, this topology can be extremely difficult to find, due to the
dynamic structure of the network and to the lack of centralized control. Network reconstruction
has been studied extensively [2, 3, 8, 19] . Sometimes we have some idea of what the network should
be like, based perhaps on its state at some time in the past, and we want to check whether our
image of the network is correct. This is network verification and has received attention recently [3,
5]. This is an important task for routing, error detection, or ensuring service-level agreement
compliance and the like. For example, internet service providers offer services that require quality
of service guarantees, such as voice-over IP services, and thus need to check regularly whether
the networks are correct.
The topology of internet networks can be investigated at the router level, where the set of routers
and their physical connections are the vertices and edges of a graph, respectively. Traditionally,
we use tools such as traceroute and mtrace to infer the network topology. These tools generate
path information between a pair of vertices. It is a common and reasonably accurate assumption
that the generated path is shortest, i.e., minimizes the hop distance between that pair. In our first
theoretical model, we assume that we can query any pair of vertices and get in return a shortest
path between them in the graph. Sometimes routers block traceroute and mtrace requests (e.g.,
due to privacy and security concerns). In this case, inference of topology can only rely on delay
information. In our second theoretical model, we assume that we can query any pair of vertices
and get in return the hop distance between them in the graph.
1.1 The Problem
Let G = (V, E) be a hidden graph that is connected, undirected, and unweighted, where |V | = n. We
consider two query oracles. A shortest path oracle receives a pair (u,v) ∈ V 2 and returns a shortest
path between u and v.
1 A distance oracle receives a pair (u,v) ∈ V 2 and returns the number of
edges on a shortest path between u and v.
In the graph reconstruction problem, we are given the vertex set V and have access to either a
distance oracle or a shortest path oracle. The goal is to find every edge in E.
In the graph verification problem, again we are given V and have access to either oracle. In
addition, we are given a connected, undirected, and unweighted graph Gˆ = (V, Eˆ). The goal is to
check whether Gˆ is correct, that is, whether Gˆ = G.
The efficiency of an algorithm is measured by its query complexity,
2 i.e., the number of queries
to an oracle. All our algorithms run in polynomial time and space. We note that O(n2) queries are
enough for reconstruction (and ergo for verification), using either a distance oracle or a shortest
path oracle: we only need to query every pair of vertices, and return the pairs (u,v) whose u-to-v
distance is 1. We call this reconstruction algorithm Exhaustive-Query.
Focusing on bounded degree graphs,3 it is not hard to see that Ω(n) distance or shortest path
queries are required for both reconstruction and verification. The central question in this line of
work is therefore: Is the query complexity linear, quadratic, or somewhere in between? We show
that the query complexity for reconstruction using a distance oracle is subquadratic: O˜ (n3/2), and
that the query complexity for reconstruction using a shortest path oracle or for verification using
either oracle is near-linear: n1+o(1)
. We leave open the following question: Is there a reconstruction
algorithm using a near-linear number of queries to a distance oracle?
1.2 Related Work
The inference of the topology of a network or a graph using queries that reveal partial information
has been studied extensively in different contexts, independently stemming from a number of
applications.
1If there are several shortest paths between u and v, the oracle returns an arbitrary one. 2Expected query complexity in the case of randomized algorithms.
3Without the assumption that the graph has bounded degree, both reconstruction and verification require Ω(n2) distance
or shortest path queries, see Section 5.1.
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.
Graph Reconstruction and Verification 40:3
All Shortest Paths and All Distances. Beerliova et al. [3] studied the network inference problem,
where an oracle receives a node v and returns all shortest paths from v to all other nodes. For
the verification problem, they showed that there is no approximation algorithm of factor o(logn)
unless P = NP; and for the reconstruction problem, they gave a randomized on-line algorithm with
competitive ratioO(

n logn), which was later improved toO(log2 n) by Sen and Muralidhara [18].
Beerliova et al. [3] suggested as a future direction: It would also be interesting to study further query
models. For example, a query could be given by nodes u and v and return all shortest paths between
u and v (or just one shortest path). They mentioned that traceroute experiments in real networks
often reveal only a single shortest path (or at most a few different paths), but not all shortest paths.
Hence our motivation of the shortest path oracle model: the oracle returns an arbitrary shortest
path between a given pair of nodes.
The authors of Reference [3] also considered the distance oracle model: a distance oracle receives
a node v and returns the distances from v to all other nodes in the graph. (This is in contrast to
our distance oracle, which returns the distance between a given pair of nodes.) They noted that, in
many networks, it is realistically possible to obtain the distance information, while it is difficult or
impossible to obtain the path information. In the distance oracle model, they gave a randomized online algorithm for reconstruction with competitive ratioO(

n logn). They proved that minimizing
the number of queries for verification is NP-hard and they gave an approximation algorithm of
factor O(logn), i.e., the number of queries is O(logn) times the optimum number of queries. This
algorithm is based on a reduction to Set-Cover. To achieve this reduction, they showed an easy
property for non-edge verification and more delicate properties for edge verification. Our verification algorithm in Section 3.1 bears similarity: we also use a reduction to Set-Cover. In our model,
edge verification is straightforward since the graph has bounded maximum degree. The focus is
thus on non-edge verification. We develop interesting properties for non-edge verification.
Betweenness Oracle. Recently, Abrahamsen et al. [1] studied a weaker oracle, called the betweenness oracle. This oracle receives three nodes u,v,w and returns whether w lies on a shortest
path between u and v. In particular, the authors achieved a graph reconstruction algorithm with
O˜ (n3/2) betweenness queries by extending our result on graph reconstruction (Theorem 1.1) to
their setting.
Evolutionary Biology. Waterman et al. [21] introduced the problem of reconstructing evolutionary (phylogenetic) trees using a distance oracle. An oracle receives two species and returns their
distance in the tree. When the tree has maximum degree Δ, Hein [9] gave a reconstruction algorithm using O(Δn logΔ n) queries. King, Zhang, and Zhou [13] showed that this bound is tight by
providing a matching lower bound. On the other hand, when the maximum degree is unbounded,
there is an Ω(n2) lower bound [9].
Other Related Work. Dall
Asta et al. [8] studied network inference using a shortest path oracle
which, upon receiving a random pair of vertices, returns a shortest path between them. Chung
et al. [7] studied network realization, where the goal is to determine the sparsest graph given the
distances between certain pairs of vertices. Tarissan, Latapy, and Prieur [19] studied network inference using link queries, where a link query returns whether there is a link between a pair of vertices.
1.3 Our Results
See Table 1 for a summary. The results based on the Voronoi cell decomposition and the greedy
approaches are the main contributions.
Let Δ denote the maximum degree of any vertex in the graph G. The notation O˜ (f (n)) stands
for O(f (n) polylogn) where f (n) is some function of n.
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.   
40:4 S. Kannan et al.
Table 1. Our Results (for Bounded Degree Graphs)
Objective Query complexity
verification (either oracle) n1+o(1) Theorems 1.2 to 1.4 reconstruction (shortest path oracle)
reconstruction(distance oracle)
O˜ (n3/2) Theorem 1.1
Ω(n logn/ log logn) Theorem 5.2
chordal: O˜ (n) Theorem 4.10
outerplanar: O˜ (n) Theorem 4.19
Main results are in bold.
Algorithms Based on Voronoi Cell Decomposition. To design reconstruction and verification algorithms, we apply some algorithmic ideas previously developed for compact routing [20] and for
Voronoi cells [10].
Theorem 1.1. For graph reconstruction using a distance oracle, there is a randomized algorithm
with query complexity O(Δ3 · n3/2 · log2 n · log logn), which is O˜ (n3/2) when the maximum degree
Δ is O(polylogn).
The algorithm of Theorem 1.1 (Section 2.2) selects a set ofO˜ (
√
n) nodes (called centers) partitioning V into Voronoi cells of roughly the same size, and expands them slightly so as to cover every
edge of G (Figure 1). It is then sufficient to reconstruct each cell, which is done using exhaustive
search inside that cell.
Theorem 1.2. For graph verification using a distance oracle, there is a randomized algorithm with
query complexity n1+O (
√(log log n+log Δ)/ log n)
, which is n1+o(1) when the maximum degree Δ is no(1)
.
The algorithm of Theorem 1.2 (Section 2.3) is a more sophisticated recursive version of the algorithm in Theorem 1.1. Again, it selects a set of centers partitioning V into Voronoi cells. To verify
each cell, instead of using exhaustive search, the algorithm applies recursion. This is a challenge
because, when we query a pair (u,v) in a cell, the oracle returns the distance between u and v in
the entire graph, not in the cell. Our approach is to allow selection of centers outside the cell, while
still limiting the subcells to being contained inside the cell (Figure 2).
Greedy Algorithms. We provide simple greedy algorithms for verification and reconstruction.
The main task for verification is to confirm the non-edges of the graph. We develop a necessary
and sufficient condition for a set of queries to confirm all the non-edges. This condition enables
us to reduce the non-edge verification problem to Set-Cover. As a counterpart of the greedy
algorithm for Set-Cover, greedy non-edge verification (Section 3.1) repeatedly makes queries that
confirm the largest number of non-edges that are not yet confirmed. We have:
Theorem 1.3. If there is an algorithm for graph verification using f (n, Δ) distance queries, then
there is a greedy algorithm for verification that uses O(Δn + logn · f (n, Δ)) distance or shortest path
queries.
Next, we extend the idea of greedy verification and obtain a greedy algorithm for reconstruction
(Section 3.2) as in the following theorem.
Theorem 1.4. If there is an algorithm for graph verification using f (n, Δ) distance queries, then
there is a greedy algorithm for reconstruction that uses O(Δn + logn · f (n, Δ)) shortest path queries.
To prove Theorem 1.4, we show that each query to a shortest path oracle makes as much progress
for reconstruction as the corresponding query to a distance oracle would have made for verifying
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.
Graph Reconstruction and Verification 40:5
a given graph. The main observation here is that reconstruction using a shortest path oracle can
be viewed as the verification of a dynamically changing graph using a distance oracle.
Combining Theorems 1.2 to 1.4, we know that greedy algorithms for graph verification using
either oracle and for graph reconstruction using a shortest path oracle have query complexity
n1+o(1)
.
We note that the greedy algorithm for verification is much simpler than the algorithm using
Voronoi cell decomposition (Theorem 1.2), although both algorithms achieve the query complexity
n1+o(1)
.
Algorithms Based on Decomposition by Separators. For chordal graphs and outerplanar graphs,
there exist balanced separators of small size. This property enables us to design reconstruction
algorithms of O˜ (n) query complexity in the distance oracle model. To reconstruct chordal graphs
(Section 4.2) and outerplanar graphs (Section 4.3), our algorithms find a node x that is on many
shortest paths and grow a small separator including x. Next, the algorithms partition the graph into
subgraphs with respect to this separator and recurse on each subgraph. The difficulty is to obtain
the node x. Computing all shortest paths to obtain x would require too many queries. However,
we show that x can be found using random sampling and statistical estimation.
We note that both chordal graphs and outerplanar graphs (of bounded degree) have bounded
treewidth. A natural open problem is the following: Is there a reconstruction algorithm for
treewidth-bounded graphs using a near-linear number of queries to a distance oracle?
Lower Bounds. For graphs of unbounded degree, we give a simple Ω(n2) query lower bound4
for both reconstruction and verification and under both oracle models (Section 5.1). For graphs of
bounded degree, it is easy to see that both reconstruction and verification require Ω(n) distance or
shortest path queries. In addition, there is a slightly better lower bound for reconstructing graphs
of bounded degree using a distance oracle (Section 5.2). We thank Cyril Gavoille and Uri Zwick
for this lower bound.
Approximate Reconstruction. We also study an approximate version of the reconstruction problem for graphs of unbounded degree (Section 6). We give a simple algorithm that achieves the
optimal query complexity.
1.4 Notations and Definitions
Let G = (V, E) be a connected, undirected, and unweighted graph, where V is the vertex set and E
is the edge set. Let δ be the distance metric of G. For a subset of vertices S ⊆ V and a vertex v ∈ V ,
define δ (S,v) to be mins ∈S δ (s,v). For v ∈ V , define the neighborhood of v as N (v) = {u ∈ V :
δ (u,v) ≤ 1}, and define the neighborhood of v within distance 2 as N2 (v) = {u ∈ V : δ (u,v) ≤ 2}.
For S ⊆ V , define the neighborhood of S as N (S) =
s ∈S N (s). We define ˆ
δ, Nˆ, and Nˆ2 similarly,
but with respect to the graph Gˆ.
For a pair of distinct vertices (u,v) ∈ V 2, we say that uv is an edge of G if uv ∈ E, and is a
non-edge of G if uv  E.
For a subset of vertices S ⊆ V , let G[S] be the subgraph induced by S. For a subset of edges
H ⊆ E, we identify H with the subgraph induced by the edges of H. Let δH denote the distance
metric of the subgraph H.
For vertices s,t ∈ V , Query(s,t) returns either the distance δ (s,t) or a shortest s-to-t path,
depending on the oracle model. For a vertex s ∈ V and a subset T ⊆ V , define Query(s,T ) (or
4We note that this lower bound holds even when the graph is restricted to be outerplanar or chordal.
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.  
40:6 S. Kannan et al.
equivalently Query(T,s)) as Query(s,t) for every t ∈ T . For subsets S,T ⊆ V , define Query(S,T )
as Query(s,t) for every (s,t) ∈ S ×T .
In the verification problem, an algorithm, after performing a set of queries, outputs no if some
query gives the wrong distance (or shortest path), and outputs yes if all queries give the right
distances (or shortest paths).
1.5 Organization
In Section 2, we give reconstruction and verification algorithms based on Voronoi cell decomposition. In Section 2.1, we review the center-selecting technique from Reference [20], which is a main
subroutine in our algorithms. In Sections 2.2 and 2.3, we prove Theorems 1.1 and 1.2, respectively.
In Section 3, we give greedy algorithms for verification and for reconstruction. In Sections 3.1 and
3.2, we prove Theorems 1.3 and 1.4, respectively. In Section 4.1, we give some preliminaries on
special graph classes. In Sections 4.2 and 4.3, we focus on chordal graphs and outerplanar graphs
respectively. In Section 5, we study lower bounds. In Section 6, we provide results on the approximate reconstruction.
2 VORONOI CELL DECOMPOSITION
In this section, we design a reconstruction algorithm (Section 2.2) and a verification algorithm
(Section 2.3) using a distance oracle. Both algorithms are based on the center-selecting technique
from Reference [20] for general graphs, which we review in Section 2.1.
2.1 Center-Selecting Technique
Thorup and Zwick [20] gave a compact routing scheme that uses O˜ (n1/2) bits of memory at each
node. The key to this scheme was to select a set of centers. First we recall some notations from [20].
For every node w ∈ V , the cluster of w with respect to a subset of nodes A ⊆ V is defined as
CA(w) := {v ∈ V : δ (w,v) < δ (A,v)}.
Note that if w ∈ A, then CA(w) = ∅, since δ (w,v) ≥ δ (A,v) for every v ∈ V . The subscript A is
omitted when clear from the context. The goal of the center-selecting problem is to select a set of
centers A ⊆ V such that every |CA(w)| is small, i.e., roughly n/|A|.
In Algorithm 1, we review the center-selecting algorithm from Reference [20]. The algorithm
takes as input a graph G = (V, E) and an integer parameter s ∈ [1,n] and outputs a set of centers
A. It uses a subroutine Sample(W ,s), which receives a set W ⊆ V and an integer s and returns a
random subset of W obtained by selecting each element, independently, with probability s/|W |. If
|W | ≤ s, then Sample(W ,s) returns the set W itself. Thorup and Zwick [20] proved the following
lemma.
Lemma 2.1 (Rephrasing of Theorem 3.1 in [20]). With probability at least 1/2, the algorithm
Centers (Algorithm 1) outputs a set A ⊆ V such that |A| ≤ 4s logn and |C(w)| ≤ 4n/s for every
w ∈ V .
We will use modified versions of the center-selecting algorithm (Algorithm 1) in the design of
the reconstruction and the verification algorithms in Sections 2.2 and 2.3, respectively.
2.2 Reconstruction via a Distance Oracle
In this section, we prove the following theorem.
Theorem 2.2. For graph reconstruction using a distance oracle, there is a randomized algorithm
that terminates after O(Δ3 · n3/2 · log2 n · log logn) queries with probability at least 1/4.
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.
Graph Reconstruction and Verification 40:7
ALGORITHM 1: Selecting Centers [20] (see Theorem 2.1)
1: function Centers(G,s)
2: A ← ∅, W ← V
3: while W  ∅ do
4: A ← Sample(W ,s)
5: A ← A ∪ A
6: for w ∈ W do
7: C(w) ← {v ∈ V : δ (w,v) < δ (A,v)}
8: W ← {w ∈ W : |C(w)| > 4n/s}
9: return A
ALGORITHM 2: Selecting Centers by Estimation (see Theorem 2.3)
1: function Estimated-Centers(V,s)
2: A ← ∅, W ← V
3: T ← K · s · logn · log logn  K = O(1)
4: while W  ∅ do
5: A ← Sample(W ,s)
6: Query(A
,V )
7: A ← A ∪ A
8: for w ∈ W do
9: X ← random multi-subset of V with T elements
10: Query(X,w)
11: C˜(w) ← |{v ∈ X : δ (w,v) < δ (A,v)}| · n/T
12: W ← {w ∈ W : C˜(w) ≥ 5n/s}
13: return A
Proof of Theorem 1.1 using Theorem 2.2. If the reconstruction algorithm in Theorem 2.2
does not terminate after O(Δ3 · n3/2 · log2 n · log logn) queries, we stop it and execute it again.
The expected number of executions of the algorithm is a constant. Therefore, we obtain a reconstruction algorithm with expected query complexity O(Δ3 · n3/2 · log2 n · log logn), as stated in
Theorem 1.1.
It only remains to prove Theorem 2.2.
2.2.1 Subroutine: Selecting Centers. The reconstruction algorithm uses a subroutine
Estimated-Centers (Algorithm 2) to select centers A ⊆ V such that the vertices of V are
roughly equipartitioned into the Voronoi cells centered at vertices in A. This algorithm is a
modified version of the algorithm Centers (Algorithm 1). It takes as input the vertex set V of a
graph and a parameter s ∈ [1,n] and outputs a set of centers A. Unlike the algorithm Centers,
it uses sampling to estimate each |C(w)| so as to reduce the query complexity. Recall that the
algorithm Centers eliminates a node w from the set W when |C(w)| ≤ 4n/s. However, in our
query model, computing |C(w)| would require Ω(n) queries for each w. Instead, the algorithm
Estimated-Centers computes an estimate C˜(w) of |C(w)| using fewer queries, and then
eliminates a node w from W when C˜(w) is small. The following lemma analyzes the algorithm
Estimated-Centers. It is a counterpart of Theorem 2.1. Its proof combines arguments from [20]
and Chernoff bounds.
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.         
40:8 S. Kannan et al.
Lemma 2.3. Let K (in Algorithm 2) be some well-chosen constant. With probability at least 1/4,
the algorithm Estimated-Centers (Algorithm 2) terminates after O(s · n · log2 n · log logn) queries,
and outputs a set A ⊆ V such that |A| ≤ 12s logn and |C(w)| ≤ 6n/s for every w ∈ V .
5
Proof. Let Wi be the set W at the beginning of the i-th iteration of the while loop. Let
A = Sample(W ,s) be the centers selected in this iteration, and let A be the union of A with all
previously selected centers. We say that the i-th iteration is successful if

w ∈Wi
|CA(w)| ≤ 2n|Wi |/s. (1)
Thorup and Zwick [20] showed that each iteration is successful with probability at least 1/2.
Consider a node w ∈ Wi . Let X be a random multi-subset of V with T = K · s · logn · log logn
elements for some parameter K. Define Y = |{v ∈ X : δ (w,v) < δ (A,v)}|, which is |X ∩CA(w)|.
Let E[Y] be the expected value of Y. By standard Chernoff bounds, there is an absolute constant
K such that

P [Y ≥ 5T/s] ≥ 1 − 1/(96n logn), if E[Y] > 6T/s,
P [Y < 5T/s] > 1 − 1/(96n logn), if E[Y] < 4T/s.
Note that |CA (w)| = E[Y] · n/T . Define C˜(w) = Y · n/T . Thus, with probability at least 1 −
1/(48n logn), we have

C˜(w) ≥ 5n/s, if |CA(w)| > 6n/s,
C˜(w) < 5n/s, if |CA(w)| < 4n/s. (2)
Since |Wi | ≤ n, with probability at least 1 − 1/(48 logn), Property Equation (2) holds for allw ∈ Wi
in the i-th iteration. We call iterations in which this happens correct iterations. As a consequence,
if the i-th iteration is correct, then for every w ∈ Wi+1, we have |CA (w)| ≥ 4n/s.
If the i-th iteration is both successful and correct, which happens with probability at least 1/2 −
1/(48 logn) > 1/3, then we have
4n|Wi+1 |/s ≤

w ∈Wi
|CA (w)| ≤ 2n|Wi |/s,
and thus |Wi+1 |≤|Wi |/2. Since |W | is non-increasing during the algorithm, the expected number
of iterations is at most 3 logn.
By Markov’s inequality, with probability at least 3/4, the number of iterations is at most
12 logn. The probability that the first (at most) 12 logn iterations are correct is at least 1 −
12 logn/(48 logn) = 3/4. Therefore, with probability at least 1/2, there are at most 12 logn iterations and all iterations are correct. In that case, every w ∈ V that is eliminated from W has
|CA (w)| ≤ 6n/s. Observe that |CA(w)| cannot increase when elements are added to A. Therefore,
|CA (w)| ≤ 6n/s for every w ∈ V when the while loop terminates.
The expected size of A is at most 3s logn, since the expected number of iterations is at most
3 logn, and in every iteration, a set A of expected size s is added to A. By Markov’s inequality,
|A| ≤ 12s logn with probability at least 3/4.
All together, with probability at least 1/4, there are at most 12 logn iterations, |A| ≤ 12s logn,
and |CA (w)| ≤ 6n/s for every w ∈ V . In that case, the number of queries is at most
|A| · n + (12 logn) · nT = O(s · n · log2 n · log logn).
This completes the proof.
5We choose K so that the success probability of the algorithm is at least 1/4 (instead of some large value, say, 1 − 1/poly(n)),
since this is sufficient to obtain the expected query complexity in Theorem 1.1.
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.    
Graph Reconstruction and Verification 40:9
Fig. 1. Partition by centers. Here vertices a1,..., a5 are centers in A. The dotted lines indicate the partition
ofV into Voronoi cells by those centers. Extending the Voronoi cells slightly, we obtain the cells Da1 ,...,Da5 .
ALGORITHM 3: Reconstruction (see Theorem 2.2)
1: procedure Reconstruct(V )
2: A ← Estimated-Centers(V,s)  every pair in A ×V is queried
3: for a ∈ A do
4: Query(N2 (a),V )
5: for b ∈ N2 (a) do
6: C(b) ← {v ∈ V : δ (b,v) < δ (A,v)}
7: Da ←  {C(b) : b ∈ N2 (a)} ∪ N2 (a)
8: Ea ← Exhaustive-Query(Da )
9: return
a Ea
2.2.2 Algorithm and Analysis.
Algorithm. The reconstruction algorithm (Algorithm 3) takes as input the vertex set V and computes the edge set of G. It first selects a set of centers A using Estimated-Centers, and then
partitions the graph into slightly overlapping subgraphs with respect to the centers in A, see
Figure 1. The parameter s is defined later to achieve the desired query complexity. For each a ∈ A,
we define its extended Voronoi cell Da ⊆ V as
Da :=

{C(b) : b ∈ N2 (a)} ∪ N2 (a). (3)
The algorithm then proceeds by exhaustive search within each subgraph G[Da], and returns all
the edges found in these subgraphs.
Correctness Analysis. We show in Theorem 2.4 that these subgraphs together cover every edge
of the graph. Thus, the output of the algorithm is indeed the edge set of G.
Lemma 2.4.
a ∈A G[Da] covers every edge of G.
Proof. Let uv be any edge of G. We prove that there is some a ∈ A such that both u and v
are in Da. Without loss of generality, we assume δ (A,u) ≤ δ (A,v). We choose a ∈ A such that
δ (a,u) = δ (A,u). If δ (a,u) ≤ 1, then both u and v are in N2 (a) ⊆ Da. If δ (a,u) ≥ 2, let b be the
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.    
40:10 S. Kannan et al.
ALGORITHM 4: Selecting Centers for a Subset (see Theorem 2.5)
1: function Subset-Centers(Gˆ,U,s)
2: A ← ∅, W ← V
3: while W  ∅ do
4: A ← Sample(W ,s)
5: A ← A ∪ A
6: for w ∈ W do
7: Cˆ(w) ← {v ∈ V : ˆ
δ (w,v) < ˆ
δ (A,v)}
8: W ← {w ∈ W : |Cˆ(w) ∩U | > 4|U |/s}
9: return A
vertex at distance 2 from a on a shortest a-to-u path in G. By the triangle inequality, we have
δ (b,v) ≤ δ (b,u) + δ (u,v) = δ (b,u) + 1.
Since δ (b,u) = δ (a,u) − 2 and δ (a,u) = δ (A,u) ≤ δ (A,v), we have δ (b,u) < δ (A,u) and δ (b,v) <
δ (A,v). Therefore, both u and v are in C(b), and thus in Da, since b ∈ N2 (a).
Query Complexity Analysis. By Theorem 2.3, with probability at least 1/4, Estimated-Centers
uses O(s · n · log2 n · log logn) queries, and outputs a set A ⊆ V such that |A| ≤ 12s logn, and
|C(w)| ≤ 6n/s, for every w ∈ V . In this case, the subsequent steps of the algorithm Reconstruct
have query complexity:

a ∈A

|N2 (a)| · n + |Da |
2

= O(s logn · Δ2 (n + Δ2
n2
/s2)),
using the bounds on |A| and |C(w)|, and the fact that |N2 (a)| ≤ Δ2 + 1.
Let s = Δ ·
√
n. Then with probability at least 1/4, the algorithm Reconstruct terminates after
O(Δ3 · n3/2 · log2 n · log logn) queries, as stated in Theorem 2.2.
2.3 Verification via a Distance Oracle
In this section, we prove Theorem 1.2, which we now recall.
Theorem 1.2. For graph verification using a distance oracle, there is a randomized algorithm with
query complexity n1+O (
√(log log n+log Δ)/ log n)
, which is n1+o(1) when the maximum degree Δ is no(1)
.
2.3.1 Subroutine: Selecting Centers. The verification algorithm uses the subroutine SubsetCenters (Algorithm 4), which takes as input a graph Gˆ = (V, Eˆ), a subset of vertices U ⊆ V , and
an integer s ∈ [1,n], and outputs a set of centers A ⊆ V such that in the graph Gˆ, the vertices of
the subset U are roughly equipartitioned into the Voronoi cells centered at vertices in A. This algorithm is a generalization of the algorithm Centers (Algorithm 1). When the subset U equals V ,
this algorithm becomes the same as the algorithm Centers. We recall the definition of w’s cluster
CA(w) := {v ∈ V : δ (w,v) < δ (A,v)} for everyw ∈ V . Similarly, we definew’s cluster with respect
to the graphGˆ asCˆ
A(w) := {v ∈ V : ˆ
δ (w,v) < ˆ
δ (A,v)}. The subscriptA is omitted when clear from
the context. The following lemma is a straightforward extension of Theorem 2.1.
Lemma 2.5. With probability at least 1/2, the algorithm Subset-Centers (Algorithm 4) outputs a
set A ⊆ V , such that |A| ≤ 4s logn, and that |Cˆ(w) ∩U | ≤ 4|U |/s, for every w ∈ V . It uses no queries
since Gˆ is given.
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.    
Graph Reconstruction and Verification 40:11
2.3.2 Algorithm and Analysis.
Algorithm and Correctness Analysis. The task of verification comprises verifying that every edge
of Gˆ is an edge of G, and verifying that every non-edge of Gˆ is a non-edge of G. The first part
requires only O(Δn) queries for graphs of bounded degree. Thus, the focus is on the second part,
which is called non-edge verification. In the second part, we assume that the first part is already
done, so we have Eˆ ⊆ E.
We design a recursive algorithm for non-edge verification. Let U ⊆ V represent the set of vertices in a recursive call. The goal is to verify that every non-edge of Gˆ[U ] is a non-edge of G[U ].
This is equivalent to verifying that every edge of G[U ] is an edge of Gˆ[U ].
Let A be a set of centers computed by Subset-Centers. We define, for each a ∈ A, its extended
Voronoi cell restricted on U as
Da := 
{C(b) : b ∈ N2 (a)} ∪ N2 (a)

∩U . (4)
Similarly, with respect to the graph Gˆ, we define
Dˆ a := 
Cˆ(b) : b ∈ Nˆ2 (a)

∪ Nˆ2 (a)

∩U . (5)
The following lemma is a simple extension of Theorem 2.4.
Lemma 2.6.
a ∈A G[Da] covers every edge of G[U ].
Proof. Let uv be any edge of G[U ]. We prove that there is some a ∈ A such that both u and
v are in Da. Without loss of generality, we assume δ (A,u) ≤ δ (A,v). We choose a ∈ A such that
δ (a,u) = δ (A,u). If δ (a,u) ≤ 1, then both u and v are in N2 (a) ∩U ⊆ Da. If δ (a,u) ≥ 2, let b be
the vertex at distance 2 from a on a shortest a-to-u path in G. By the triangle inequality, we have
δ (b,v) ≤ δ (b,u) + δ (u,v) = δ (b,u) + 1.
Since δ (b,u) = δ (a,u) − 2 and δ (a,u) = δ (A,u) ≤ δ (A,v), we have δ (b,u) < δ (A,u) and δ (b,v) <
δ (A,v). Therefore, both u and v are in C(b), and thus in Da, since b ∈ N2 (a).
From Theorem 2.6, to verify that every edge of G[U ] is an edge of Gˆ[U ], we only need to verify
that every edge of G[Da] is an edge of Gˆ[Da], for every a ∈ A. This enables us to apply recursion
on each Da.
The main difficulty is how to obtain Da efficiently. If we compute Da from its definition, we
would need to compute N2 (a), which requires Ω(n) queries since N2 (a) may contain nodes outside
U . Instead, a careful analysis shows that we can check whether Da = Dˆ a without even knowing
N2 (a), whereas Dˆ a can be inferred from the graph Gˆ with no queries. See Theorem 2.7 below,
which is the key to the design of the verification algorithm.
Lemma 2.7. Assume that Eˆ ⊆ E. If δ (b,u) = ˆ
δ (b,u) for every pair (b,u) from
a ∈A Nˆ2 (a) × U ,
then Da = Dˆ a for all a ∈ A.
6
Proof. The proof is delicate but elementary. For every b ∈
a ∈A Nˆ2 (a), we have Cˆ(b) ∩U =
C(b) ∩U , because ˆ
δ (b,u) = δ (b,u) and ˆ
δ (A,u) = δ (A,u) for every u ∈ U . Therefore, Dˆ a can be
rewritten as
Dˆ a = 
C(b) : b ∈ Nˆ2 (a)

∪ Nˆ2 (a)

∩U .
Since Eˆ ⊆ E, we have Nˆ2 (a) ⊆ N2 (a). Therefore, Dˆ a ⊆ Da.
6The statement is non-trivial, since N2 (a) may differ from Nˆ2 (a).
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.        
40:12 S. Kannan et al.
Fig. 2. Two levels of recursive calls of Verify-Subgraph(Gˆ,V,s). The solid points are top-level centers returned by Subset-Centers(Gˆ,V,s). The dotted lines indicate the partition of V into Voronoi cells by those
centers. For a center a, its extended Voronoi cell is Dˆ a. On the second level of the recursive call for Dˆ a, the
hollow points are the centers returned by Subset-Centers(Gˆ,Dˆ a,s). Observe that some of those centers lie
outside Dˆ a. The dashed lines indicate the partition of Dˆ a into Voronoi cells by those centers. For a center a
on the second level, its extended Voronoi cell is Dˆ
a.
On the other hand, we have N2 (a) ∩U ⊆ Nˆ2 (a) ∩U , because ˆ
δ (a,u) = δ (a,u) for every u ∈
N2 (a) ∩U . To prove Da ⊆ Dˆ a, it only remains to show that, for any vertex u  N2 (a) such that
u ∈ C(b) ∩U for some b ∈ N2 (a), we have u ∈ C(x) ∩U for some x ∈ Nˆ2 (a). We choose x to be
the vertex at distance 2 from a on a shortest a-to-u path inGˆ. By the assumption and the definition
of x, we have
δ (x,u) = ˆ
δ (x,u) = ˆ
δ (a,u) − 2 = δ (a,u) − 2.
By the triangle inequality, and using b ∈ N2 (a) and u ∈ C(b), we have
δ (a,u) ≤ δ (a,b) + δ (b,u) ≤ 2 + δ (b,u) < 2 + δ (A,u).
Therefore, δ (x,u) < δ (A,u). Thus, u ∈ C(x) ∩U .
The recursive algorithm Verify-Subgraph for non-edge verification is given in Algorithm 5.
It receives a graph Gˆ = (V, Eˆ) and a subset U ⊆ V , and verifies all the non-edges of Gˆ[U ]. It first
queries every (u,v) ∈
a ∈A Nˆ2 (a) × U , and then recurses on each extended Voronoi cell Dˆ a, see
Figure 2. The parameters s and n0 are defined later to achieve the desired query complexity. Correctness of the algorithm follows from Theorems 2.6 and 2.7.
Query Complexity Analysis. To provide intuition, we first analyze an algorithm of 4 recursive
levels, and show that its query complexity is O˜ (n4/3). To simplify the presentation, we assume
Δ = O(1). Lets = n1/3 and let n0 be some well-chosen constant. Consider any recursive call VerifySubgraph(Gˆ,U ) where |U | > n0. From Theorem 2.5, the expected number of iterations of the
repeat loop is constant. Let A ⊆ V be the centers at the end of the repeat loop. Since Δ = O(1),
every Nˆ2 (a) has constant size for a ∈ A. Every Cˆ(w) ∩U has size O(|U |/n1/3), so every Dˆ a has
size O(|U |/n1/3). Since |A| = O˜ (n1/3), the number of recursive calls on the next level is O˜ (n1/3).
Therefore, during the recursion, on the second level, there are O˜ (n1/3) recursive calls, where every
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.      
Graph Reconstruction and Verification 40:13
ALGORITHM 5: Verification (see Theorem 1.2)
1: procedure Verify-Subgraph(Gˆ,U )
2: if |U | > n0 then
3: repeat
4: A ← Subset-Centers(Gˆ,U,s)
5: until |A| ≤ 4s logn and |Cˆ(w) ∩U | ≤ 4|U |/s for every w ∈ V
6: for a ∈ A do
7: Query(Nˆ2 (a),U )
8: for b ∈ Nˆ2 (a) do
9: Cˆ(b) ← {v ∈ V : ˆ
δ (b,v) < ˆ
δ (A,v)}
10: Dˆ a ← 
Cˆ(b) : b ∈ Nˆ2 (a)

∪ Nˆ2 (a)

∩U
11: Verify-Subgraph(Gˆ,Dˆ a,s)
12: else
13: Query(U,U )
subset has sizeO(n2/3); on the third level, there are O˜ (n2/3) recursive calls, where every subset has
size O(n1/3); and on the fourth level, there are O˜ (n) recursive calls, where every subset has size
O(1). Every recursive call with subset U uses O˜ (n1/3 · |U |) queries. Therefore, the overall query
complexity is O˜ (n4/3).
Next, we give the full proof of the complexity as stated in Theorem 1.2. Define
k0 =
⎢
⎢
⎢
⎢
⎢
⎢
⎣
	
logn
log (logn · 64(Δ2 + 1)2)
⎥
⎥
⎥
⎥
⎥
⎥
⎦
.
Lets = n1/k0 and n0 = (4(Δ2 + 1))k0 . Consider any recursive call when |U | > n0. From Theorem 2.5,
the expected number of iterations of the repeat loop is constant. Let A ⊆ V be the centers at the
end of the repeat loop. Then |A| ≤ 4s logn and every |Cˆ(w) ∩U | is at most 4|U |/s. Since the graph
has maximum degree Δ, the size of every Dˆ a is at most (Δ2 + 1) · max(4|U |/s, 1). Therefore, by
induction, for any 1 ≤ k ≤ k0 + 1, any subset U on the kth level of the recursion has size at most
tk := n(4(Δ2 + 1)/s)
k−1, where tk0+1 = n0. Hence, the maximum level of the recursion is at most
k0 + 1.7
Consider the recursive calls with |U | ≤ n0. There are at most (4s logn)
k0 such calls and each
call takes |U |
2 ≤ (4(Δ2 + 1))2k0 queries. Thus, their overall query complexity is at most n · (logn ·
64(Δ2 + 1)
2)
k0 ≤ n1+1/k0 .
Consider the recursive calls with |U | > n0 on the kth level of the recursion for some fixed k ∈
[1, k0].8 There are at most (4s logn)
k−1 such calls and each takes at most (Δ2 + 1)|A|·|U | queries,
where |U | ≤ tk . Thus, their overall query complexity is at most n1+1/k0 (logn · 16(Δ2 + 1))k . Summing over k from 1 to k0, the query complexity of all recursive calls with |U | > n0 is at most
2 · n1+1/k0 (logn · 16(Δ2 + 1))k0 ≤ 2 · n1+2/k0 .
Therefore, the number of queries for non-edge verification is at most 3 · n1+2/k0 , which is
n1+O (
√(log log n+log Δ)/ log n)
. Since it takes at most Δn = n1+log Δ/ log n queries to verify that Eˆ ⊆ E,
we obtain the overall query complexity as stated in Theorem 1.2.
7The randomness does not have an influence on the maximum level of the recursion, but only on the running time of the
repeat loops. 8We note that there are no recursive calls on the (k0 + 1)
th level (i.e., the last level) of the recursion with |U | > n0.
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.   
40:14 S. Kannan et al.
3 GREEDY ALGORITHMS
In this section, we first give a greedy verification algorithm using a distance oracle and with
roughly the same query complexity, and then extend it to a reconstruction algorithm using a shortest path oracle.
3.1 Verification via a Distance Oracle
Theorem 3.1. If there is an algorithm for graph verification using f (n, Δ) distance queries, then
there is a greedy algorithm for verification that uses O(Δn + logn · f (n, Δ)) distance queries.
Proof of Theorem 1.3 using Theorem 3.1. Each query to a distance oracle can be simulated
by the same query to a shortest path oracle.
It only remains to prove Theorem 3.1. Let N E be the set of the non-edges of Gˆ. For each pair
of vertices (u,v) ∈ V 2, we define a set Su,v ⊆ N E of non-edges. This is the key to the reduction
from graph verification to the Set-Cover problem.
Su,v =
ab ∈ N E : ˆ
δ (u, a) + ˆ
δ (b,v) + 1 < ˆ
δ (u,v)

.
9 (6)
The following lemmas relate the sets {Su,v : (u,v) ∈ V 2} with non-edge verification.
Lemma 3.2. Assume that Eˆ ⊆ E. For every (u,v) ∈ V 2, if δ (u,v) = ˆ
δ (u,v), then every pair ab ∈
Su,v is a non-edge of G.
Proof. Consider any pair ab ∈ Su,v . By the triangle inequality, δ (u, a) + δ (a,b) + δ (b,v) ≥
δ (u,v) = ˆ
δ (u,v). By the definition of Su,v and using Eˆ ⊆ E, we have ˆ
δ (u,v) > ˆ
δ (u, a) + ˆ
δ (b,v) +
1 ≥ δ (u, a) + δ (b,v) + 1. Thus, δ (a,b) > 1, i.e., ab is a non-edge of G.
Lemma 3.3. If a set of queries T verifies that every non-edge of Gˆ is a non-edge of G, then
(u,v)∈T Su,v = N E .
Proof. Assume, for a contradiction, that some ab ∈ N E does not belong to any Su,v for (u,v) ∈
T . Consider adding ab to the set of edges Eˆ: this will not create a shorter path between u and v,
for any (u,v) ∈ T . Thus, including ab in Eˆ is consistent with the answers of all queries in T . This
contradicts the assumption that T verifies that ab is a non-edge of G.
10
Algorithm and Analysis. From Theorems 3.2 and 3.3, the non-edge verification is equivalent
to the Set-Cover problem with the universe N E and the sets {Su,v : (u,v) ∈ V 2}. The SetCover problem can be solved using the well-known greedy algorithm [11], which gives an Hnapproximation. Hence our greedy algorithm for verification (Algorithm 6). For the query complexity, first, verifying that Eˆ ⊆ E takes at most Δn queries, since the graph has maximum degree Δ. The
part of non-edge verification uses a number of queries that is at most (lnn + 1) times the optimum
number of queries. Thus, the overall query complexity is O(Δn + logn · f (n, Δ)). We complete the
proof of Theorem 3.1.
3.2 Reconstruction via a Shortest Path Oracle
In this section, we prove Theorem 1.4 that we recall.
Theorem 1.4. If there is an algorithm for graph verification using f (n, Δ) distance queries, then
there is a greedy algorithm for reconstruction that uses O(Δn + logn · f (n, Δ)) shortest path queries.
9In this definition, a pair ab ∈ N E 	 is not ordered, i.e., ab is identical to ba. 10We assume that Δ is an unknown quantity and cannot be used to rule out the existence of the edge ab.
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.      
Graph Reconstruction and Verification 40:15
ALGORITHM 6: Greedy Verification
1: procedure Verify(Gˆ)
2: for uv ∈ Eˆ do
3: Query(u,v)
4: Y ← ∅
5: while Eˆ ∪ Y does not cover all vertex pairs do
6: choose (u,v) that maximizes |Su,v \ Y |  Su,v defined in Equation (6)
7: Query(u,v)
8: Y ← Y ∪ Su,v
ALGORITHM 7: Greedy Reconstruction
1: procedure Reconstruct(V )
2: u0 ← an arbitrary vertex
3: for u ∈ V \ {u0} do
4: Query(u,u0) to get a shortest u-to-u0 path
5: X ← the union of the above paths
6: Y ← ∅
7: while X ∪ Y does not cover all vertex pairs do
8: choose (u,v) that maximizes |SX
u,v \ Y |  SX
u,v defined in Equation (7)
9: Query(u,v) to get a shortest u-to-v path
10: if δG (u,v) = δX (u,v) then
11: Y ← Y ∪ SX
u,v
12: else
13: e ← some edge of the above u-to-v path that is not in X
14: X ← X ∪ {e}
15: return X
Algorithm. Our greedy algorithm (Algorithm 7) constructs an increasing set X of edges so that in
the endX = E. At any time, the candidate graph is X.
11 Initially,X is the union of the shortest paths
given as answers by n − 1 queries, so that X is a connected subgraph of G spanning all vertices. At
each subsequent step, the algorithm makes a query that leads either to the confirmation of many
non-edges of G, or to the discovery of an edge of G.
Formally, we define, for every pair (u,v) ∈ V 2,
SX
u,v =
ab ∈ non-edges of X : δX (u, a) + δX (b,v) + 1 < δX (u,v)

. (7)
This is similar to Su,v defined in Equation 6. From Theorem 3.2, the pairs in SX
u,v can be confirmed
as non-edges of G if δG (u,v) = δX (u,v). At each step, the algorithm queries a pair (u,v) that
maximizes the size of the set SX
u,v \ Y. After the query, either all pairs in SX
u,v \ Y are confirmed as
non-edges of G, or δG (u,v)  δX (u,v), and in that case, some edge along a shortest u-to-v path in
G that is not in X is revealed; we then add this edge to X.
11We identify X with the subgraph induced by the edges of X.
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.     
40:16 S. Kannan et al.
Correctness Analysis. We note that the algorithm maintains the invariant that all pairs in X are
confirmed as edges ofG, and that all pairs in Y are confirmed as non-edges ofG. Thus, when X ∪ Y
covers all vertex pairs, we have X = E.
Query Complexity Analysis. First, consider the queries that lead to δG (u,v)  δX (u,v). After
each such query, an edge is added to X. This can happen at most |E| ≤ Δn times, since the graph
has maximum degree Δ.
Next, consider the queries that lead to δG (u,v) = δX (u,v). Define R to be the set of vertex
pairs that are not in X ∪ Y. We analyze the size of R during the algorithm. After each query with
δG (u,v) = δX (u,v), the size of R decreases by |SX
u,v \ Y |. To lower bound |SX
u,v \ Y |, we consider
the problem of non-edge verification using a distance oracle on the input graph X, and let T be
an (unknown) optimal set of queries. Since there is a verification algorithm using f (n, Δ) distance
queries, we have |T | ≤ f (n, Δ). By Theorem 3.3, the sets SX
u,v for all pairs (u,v) ∈ T together cover
R ∪ Y, hence R. Therefore, for some pair (u,v) ∈ T we have
|SX
u,v \ Y |≥|R|/|T |≥|R|/f (n, Δ).
Initially, |R| ≤ n(n − 1)/2, and right before the last query, |R| ≥ 1. Thus, the number of queries
with δG (u,v) = δX (u,v) is O(logn) · f (n, Δ).
Therefore, the overall query complexity is O(Δn + logn · f (n, Δ)).
Remark. The above analysis depends crucially on the fact that f (n, Δ) is a uniform bound on
the number of distance queries for verifying any n-vertex graph of maximum degree Δ. Thus,
even though the graph X changes during the course of the algorithm because of the queries (u,v)
such that δG (u,v)  δX (u,v), each query (u,v) with δG (u,v) = δX (u,v) confirms at least 1/f (n, Δ)
fraction of the non-edges.
4 DECOMPOSITION BY SEPARATORS
In this section, we consider special classes of graphs (chordal graphs and outerplanar graphs), and
we give O˜ (n) reconstruction algorithms for these graphs via a distance oracle. Our algorithms use
separators to decompose the graph into subgraphs, and then apply recursion on each subgraph.
4.1 Preliminaries
We review the definition and properties of separators, tree decomposition, chordal graphs, and outerplanar graphs.
Definition 4.1. A subset S ⊆ V is a β-balanced separator of the graph G = (V, E) (for β < 1) if
the size of every connected component of G[V \ S] is at most β |V |. In this case, the partition of
G[V \ S] into connected components is called a β-balanced partition.
Definition 4.2. A tree decomposition of a graph G = (V, E) is a tree T with nodes n1,n2,...,n
where every node ni is identified with a bag Si ⊆ V such that the following conditions hold:
(1) For every vertex v in G, the nodes whose bags contain v form a connected subtree of T .
(2) For every edge uv in G, some bag contains both u and v.
The width of a tree decomposition T is the size of the largest bag minus 1, and the treewidth of G
is the minimum width over all possible tree decompositions T of G.
Lemma 4.3 ([16], Lemma 4.3.1). Every tree decomposition T of G contains a bag S ⊆ V that is a
(1/2)-balanced separator of G.
Definition 4.4. A graph is chordal if every cycle of length greater than three has a chord, an edge
connecting two non-consecutive vertices on the cycle.
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.   
Graph Reconstruction and Verification 40:17
An introduction to chordal graphs can be found in, e.g., Reference [4].
Lemma 4.5 ([4]). Let G be a chordal graph. Then G has a tree decomposition T such that every bag
is a unique maximal clique.12
From Theorems 4.3 and 4.5, we have:
Corollary 4.6. Let G be a chordal graph of maximum degree Δ. Then G has a tree decomposition
T such that every bag is a unique maximal clique of size at most Δ + 1 and that some bag S ⊆ V in
T is a (1/2)-balanced separator of G.
Definition 4.7. A graph is outerplanar if it can be embedded in the plane with all vertices on the
exterior face.
Chartrand and Harary [6] first introduced outerplanar graphs and showed that an outerplanar
graph contains no subgraph homeomorphic to K4 or K2,3.
Definition 4.8. We say that the k-tuple (x1,..., xk ) ∈ Vk (where k ≥ 3) is a polygon if
G[{x1,..., xk }] has exactly k edges: x1x2, x2x3,..., xkx1.
We introduce the notion of a convex subset of vertices.
Definition 4.9. A subset of verticesU ⊆ V is said to be convex if, for every pair of vertices (x,y) ∈
U 2, all shortest paths in G between x and y go through nodes only in U .
4.2 Reconstruction of Chordal Graphs
In this section, we prove the following theorem.
Theorem 4.10. For reconstruction of chordal graphs using a distance oracle, there is a randomized
algorithm (Algorithm 10) with query complexity O(Δ32Δ · n(2Δ + log2 n) logn), which is O˜ (n) when
the maximum degree Δ is O(log logn).
The reconstruction algorithm first computes a vertex that is on many shortest paths, and then
grows a clique separator including this vertex. Next, it partitions the graph into subgraphs with
respect to this separator, and recursively reconstructs each subgraph. Before providing the reconstruction algorithm, we first describe two subroutines: computing a shortest path between a
pair of given vertices (Section 4.2.1) and partitioning the graph with respect to a set of vertices
(Section 4.2.2).
In what follows, the setU represents the set of vertices for which we are currently reconstructing
the induced subgraph G[U ].
4.2.1 Subroutine: Computing a Shortest Path.
Lemma 4.11. Let U be a convex subset of V . Let a and b be vertices in U . The function ShortestPath(U, a,b) (Algorithm 8) outputs a shortest path between a and b in G. Its query complexity is
O(|U | log |U |).
13
The algorithm is based on dichotomy. First, it makes 2|U | queries to get δ (u, a) and δ (u,b) for
every u ∈ U . Then it finds the middle node c on some shortest a-to-b path. Next, it recursively
computes a shortest a-to-c path and a shortest c-to-b path. The concatenation of these two paths
is a shortest a-to-b path.
12A maximal clique is a clique which is not contained in any other clique.
13The log |U | factor comes since there might be several shortest paths between a and b.
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.
40:18 S. Kannan et al.
ALGORITHM 8: Finding a Shortest Path (see Theorem 4.11)
1: function Shortest-Path(U, a,b)
2: if δ (a,b) > 1 then
3: Query(U, a); Query(U,b)
4: T ← {v ∈ U | δ (v, a) + δ (v,b) = δ (a,b)}
5:  ← δ (a,b)/2
6: c ← an arbitrary node in T such that δ (c, a) =
7: U1 ← {v ∈ T | δ (v, a) < }
8: U2 ← {v ∈ T | δ (v, a) > }
9: P1 ← Shortest-Path(U1, a,c)
10: P2 ← Shortest-Path(U2,c,b)
11: return the concatenation of P1 and P2
12: else
13: return the path of a single edge ab
During the recursion, the distance δ (a,b) between the endpoints is reduced by half at every level.
Thus, there areO(log |U |) levels of the recursion. Since the U sets on each level of the recursion are
disjoint, the total number of queries at each level isO(|U |). Therefore, the overall query complexity
of Shortest-Path is O(|U | log |U |).
4.2.2 Subroutine: Partitioning by a Set.
Lemma 4.12. Let U be a convex subset of V . Let S be a subset of U . The function Partition(U, S)
(Algorithm 9) outputs the partition of G[U \ S] into connected components. Its query complexity is
O(Δ|S |·|U |).
The algorithm roughly partitions the vertices ofU \ S according to the second vertex on a shortest path from S to the vertex, expanding slightly so as to cover every edge. Formally, for every
vertex a ∈ W where W := (N (S) ∩U ) \ S, we define the cluster of a as
B(a) = {x ∈ U \ S | δ (a, x) ≤ δ (S, x)}. (8)
Since U is convex, every x ∈ U \ S belongs to some cluster B(a). The Partition algorithm successively merges two clusters that have overlaps. See Figure 3.
ALGORITHM 9: Computing the Partition (See Theorem 4.12)
1: function Partition(U, S)
2: Query(S,U ) and obtain N (S) ∩U
3: Query(N (S) ∩U,U )
4: W ← (N (S) ∩U ) \ S
5: B←{B(a) | a ∈ W }  B(a) defined in Equation (8)
6: while ∃ B1, B2 ∈ B s.t. B1 ∩ B2  ∅ do
7: merge B1 and B2 in B
8: return B
The query complexity of the algorithm is O(|N (S)|·|U |) = O(Δ|S |·|U |). Theorem 4.12 follows
directly from Theorems 4.13 and 4.14.
Lemma 4.13. Let C be a connected component in G[U \ S]. Then C ⊆ B for some set B ∈ B in the
output of the algorithm.
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.      
Graph Reconstruction and Verification 40:19
Fig. 3. Here S = {s1,s2} and W = {a,b,c,d, e}. The clusters B(a), B(b), B(c), B(d), B(e) are indicated by the
circles. Using their overlaps, the algorithm produces the partition B = {B(a) ∪ B(b) , B(c) ∪ B(d) ∪ B(e)}.
Proof. First we argue that every edge of G[U \ S] is contained in some cluster B(a) where
a ∈ W . Consider any edge uv of G[U \ S]. Without loss of generality, we assume δ (S,u) ≤ δ (S,v).
We choose s ∈ S such that δ (s,u) = δ (S,u). Let a be the second vertex on a shortests-to-u path inG.
Then a ∈ N (S) \ S. SinceU is convex, we have a ∈ U . Therefore, a ∈ W . By the triangle inequality,
we have
δ (a,v) ≤ δ (a,u) + δ (u,v) = δ (a,u) + 1.
Since δ (a,u) = δ (s,u) − 1 and δ (s,u) = δ (S,u) ≤ δ (S,v), we have δ (a,u) < δ (S,u) and δ (a,v) ≤
δ (S,v). Therefore, both u and v are in B(a).
Next we consider any pair of vertices that are connected in G[U \ S] and any path connecting
them. After the merging step (Lines 6–7), the entire path belongs to the same set in B.
Lemma 4.14. Let B ⊆ B be a set in the output of the algorithm. Then B ⊆ C for some connected
component C in G[U \ S].
Proof. First we show that for every a ∈ W and every x ∈ B(a), a and x belong to the same
component in G[U \ S]. Suppose there exists some x ∈ B(a), such that x and a belong to different
components in G[U \ S]. Then any shortest path from a to x must pass through the separator S,
so we have δ (a, x) ≥ δ (a, S) + δ (S, x) = 1 + δ (S, x). Contradiction with x ∈ B(a).
Next we prove an invariant on B during the while loop (Lines 6–7): Every set B ∈ B is a subset of
some connected component of G[U \ S]. This invariant holds before the while loop starts. Suppose
the invariant holds before the i
th iteration of the while loop, and in this iteration two sets B1, B2 ∈
B get merged. Since B1 ∩ B2  ∅, there exists some node z ∈ B1 ∩ B2. All nodes in B1 (resp. in B2)
are in the same component of G[U \ S] as z. Thus, all nodes in B1 ∪ B2 are in the same component
ofG[U \ S]. By induction, the invariant holds when the while loop terminates. This completes the
proof.
4.2.3 Algorithm and Analysis. The Reconstruct-Chordal algorithm (Algorithm 10) takes as
input a convex subsetU ⊆ V of a chordal graph and returns the edge set ofG[U ]. The key function
Balanced-Partition-Chordal finds a β-balanced partition of U , for some β. This function first
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.   
40:20 S. Kannan et al.
ALGORITHM 10: Reconstruction of Chordal Graphs (see Theorem 4.10)
1: procedure Reconstruct-Chordal(U )
2: if |U | > n0 then
3: ({Ui}i,K) ←Balanced-Partition-Chordal(U )
4: return
i Reconstruct-Chordal(Ui ∪ K)
5: else
6: return Exhaustive-Query(U )
7: function Balanced-Partition-Chordal(U )
8: repeat
9: {(ai,bi )}1≤i ≤C1 ← uniform and independent random pairs from U
10: for i ← 1 to C1 do
11: Pi ← Shortest-Path(U, ai,bi )  see Algorithm 8
12: x ← the node in U with the most occurrences among {Pi}i
13: Query(x,U ) and obtain N (x) ∩U
14: Query(N (x) ∩U, N (x) ∩U ) and obtain all cliques in U containing x
15: for every clique K in U containing x do
16: PK ← Partition(U,K)  see Algorithm 9
17: until a β-balanced partition (PK,K) is found
computes a vertex that is on many shortest paths in the sampling, and then looks for a β-balanced
clique separator including this vertex. It repeats until a β-balanced partition is found. We set n0 =
2Δ+2 (Δ + 1)
2; C1 = 36(Δ + 1)
2 log |U |; and
β = max 
1 − 1/(Δ · 2Δ+1),

1 − 1/(4(Δ + 1))
.
Lemma 4.15. Reconstruct-Chordal (U ) returns the edge set of G[U ].
Proof. By Theorem 4.12, {Ui}i is the partition of G[U \ K] into connected components. Every
edge of G[U ] belongs to some G[Ui ∪ K], since there is no edge between any Ui and Uj for i  j.
Thus, the edge set ofG[U ] is the union of the edge sets ofG[Ui ∪ K] for all i. The statement follows
by induction.
To bound the query complexity, the key is the following lemma.
Lemma 4.16. In every repeat loop of the function Balanced-Partition-Chordal, a β-balanced
partition is found with probability at least 2/3.
To prove Theorem 4.16, we need Theorems 4.17 and 4.18.
Lemma 4.17. For every v ∈ U , let pv denote the fraction of pairs (a,b) ∈ U 2 such that v is on some
shortest path between a and b. Then maxv pv ≥ 1/(2(Δ + 1)).
Proof. By Theorem 4.6, there is some clique S ⊆ U of size at most Δ + 1 such that every connected component in G[U \ S] has size at most |U |/2. Notice that for any pair of vertices a,b
from different components of G[U \ S], any shortest a-to-b path must go by some node in S.
The number of such pairs is at least |U |
2/2. By the Pigeonhole Principle, there exists some z ∈ S
such that for at least 1/|S | ≥ 1/(Δ + 1) fraction of these pairs, their shortest paths go by z. Thus,
pz ≥ 1/(2(Δ + 1)).
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.       
Graph Reconstruction and Verification 40:21
Lemma 4.18. For every vertex v ∈ U , let p˜v denote the fraction of pairs (ai,bi ) among C1 uniform and independent random pairs from U such that v is on some shortest path between ai and
bi . Let x = arg maxv p˜v . If C1 ≥ 9 log |U |/(maxv pv )
2, then with probability at least 2/3, we have
px > (maxv pv )/2.
Proof. Let z be the node in U which maximizes pz . We will show that P[p˜y ≥ p˜z ] < 1/(3|U |)
for any node y ∈ U with py ≤ pz /2. This implies the lemma statement because we then have
P[∃y ∈ U, s.t. py ≤ pz /2 and p˜y ≥ p˜z ] < 1/3. Thus, with probability at least 2/3, the node x with
the largest p˜x satisfies px > pz /2.
Let y be any node with py ≤ pz /2. For every integeri ∈ [1,C1], define a variable Yi ∈ {0, 1} such
that Yi = 1 if the node y is on a shortest ai-to-bi path and Yi = 0 otherwise. Since {(ai,bi )}i are
uniform and independent random pairs from U , {Yi}i are independent random variables, and each
Yi equals 1 with probability py . We then have E[Yi] = py ≤ pz /2. Similarly, for every i ∈ [1,C1],
define a variable Zi ∈ {0, 1} such that Zi = 1 if the node z is on a shortest ai-to-bi path and Zi = 0
otherwise. Then E[Zi] = pz .
For every i, define Ti = Yi − Zi . Let T be the average of all Ti ’s. Then E[T ] = E[Ti] = E[Yi] −
E[Zi] ≤ −pz /2. We have
P[p˜y ≥ p˜z ] = P
⎡
⎢
⎢
⎢
⎢
⎣

i
Ti ≥ 0
⎤
⎥
⎥
⎥
⎥
⎦
≤ P




T − E[T ]


 ≥ pz /2

.
By Hoeffding’s inequality, the last term is at most 2 · exp(−p2
z · C1/8), which is at most 1/(3|U |) by
the definition of pz and C1. Therefore, we have P[p˜y ≥ p˜z ] < 1/(3|U |).
Proof of Theorem 4.16. By Theorem 4.6, there is a tree decomposition T of G[U ] such that
every bag of T is a unique maximal clique of G[U ]. Consider any iteration of the repeat loop. Let
x be the node computed in Line 12 of Algorithm 10. Let Tx be the subtree of T induced by the bags
containing x. Define F to be the forest after removing Tx from T . For any subgraph H of T , define
V (H) ⊆ U to be the set of vertices in U that appear in at least one bag of H.
Case 1: There exists some connected component T  in F with (1 − β)|U |≤|V (T
)| ≤ β |U |. Consider the (unique) edge K1K2 inT such that K1 ∈ Tx and K2 ∈ T
. K1 ∩ K2 is a β-balanced separator
of G[U ], since V (T
) is a component in G[U \ (K1 ∩ K2)]. Thus, K1 ⊇ K1 ∩ K2 is also a β-balanced
separator. Since K1 contains x, K1 is one of the cliques checked on Line 15. The algorithm succeeds
in finding a β-balanced separator.
Case 2: There exists some connected componentT  in F with |V (T
)| > β |U |. The algorithm then
fails to find a β-balanced separator. We bound the probability of this case by at most 1/3. Again
let K1K2 be the edge in T such that K1 ∈ Tx and K2 ∈ T
. For any vertices u,v of U that are in
V (T
), any shortest u-to-v path cannot go by x. Since there are at least β2 fraction of such pairs in
U 2, we have px ≤ 1 − β2, which is at most 1/(4(Δ + 1)) by the definition of β. This happens with
probability at most 1/3 by Theorems 4.17 and 4.18.
We argue that the two cases above are exhaustive. Suppose, for the sake of contradiction, that
every component T  in F is such that |V (T
)| < (1 − β)|U |. The number of components in F is at
most Δ · 2Δ, because every component has a bag that contains a neighbor of x, and all bags are
unique. Thus, |V (F )| < Δ · 2Δ · (1 − β)|U |, which is at most |U |/2 by the definition of β. On the
other hand, every node v ∈ U \ N (x) is contained in some bag from F , so |V (F )|≥|U | − (Δ + 1),
which is greater than |U |/2 since |U | > n0. Contradiction.
Query Complexity Analysis. First, we analyze the complexity of Balanced-Partition-Chordal.
Computing C1 shortest paths takes O(Δ2 |U | log2 |U |) queries, since a shortest path between two
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.            
40:22 S. Kannan et al.
given nodes can be computed usingO(|U | log |U |) queries (Theorem 4.11). We note that the neighborhood N (x) of x has size at most Δ + 1, and there are at most 2Δ cliques containing x. For every clique K containing x, Partition(U,K) takes O(Δ|K|·|U |) queries by Lemma 4.12, where
|K| ≤ Δ + 1. Therefore, every repeat loop takes O(Δ2 |U |(2Δ + log2 |U |)) queries. By Theorem
4.16, the expected number of repeat loops is constant. Thus, the query complexity of BalancedPartition-Chordal is O(Δ2 |U |(2Δ + log2 |U |)).
Next, we analyze the complexity of Reconstruct-Chordal. Let q(m) be the number of queries
when |U | = m. We have
q(m) = O 
Δ2
m(2Δ + log2m)

+

i
q(|Ui | + |K|),
where {Ui}i is a β-balanced partition of U by the separator K. Hence
q(n) = O


Δ2
n(2Δ + log2 n) log 1
β n

= O 
Δ3
2Δ · n(2Δ + log2 n) logn

.
This completes the proof of Theorem 4.10.
4.3 Reconstruction of Outerplanar Graphs
In this section, we prove the following theorem.
Theorem 4.19. For reconstruction of outerplanar graphs using a distance oracle, there is a randomized algorithm with query complexity O(Δ2 · n log3 n), which is O˜ (n) when the maximum degree
Δ is O(polylogn).
Similar to reconstructing chordal graphs in Section 4.2, the algorithm first finds a separator to
partition the graph into subgraphs and then recurses on each subgraph. However, the separator
here may be a polygon (see Theorem 4.8). In Section 4.3.1, we show how to partition the graph
with respect to a polygon.
4.3.1 Subroutine: Partitioning by a Polygon. In this section, we prove the following lemma.
Lemma 4.20. Suppose the graph G is outerplanar. Let U be a convex subset of V . Let a,b,c ∈ U
be consecutive nodes along some unknown polygon (q1,...,ql ) in U . The function Partition-byPolygon(U, a,b,c) outputs the partition of G[U \ {q1,...,ql}] into connected components. Its query
complexity is O(Δ|U | log |U |).
The function Partition-by-Polygon consists of the following two phases.
Phase 1: Finding the Polygon. The algorithm is given in Algorithm 11. The key is to compute
the a-to-c path along the polygon that does not go through b. First, the algorithm computes the
middle point z of this path. Next, it computes a shortest path P1 between a and z and a shortest
path P2 between z and c. The polygon is the concatenation of the path P1, the path P2, the edge
cb, and the edge ba. In the algorithm, Partition(U, {a,b}) and Partition(U, {b,c}) useO(Δ · |U |)
queries (Theorem 4.12), and computing the shortest paths P1 and P2 uses O(|U | log |U |) queries
(Theorem 4.11). Thus, the overall query complexity of Phase 1 is O(Δ · |U | log |U |).
Phase 2: Partitioning by the Polygon. Given the polygon (q1,...,ql ), we compute the partition
of G[U \ {q1,...,ql}] into connected components. Let m = l/2. First we compute the partition
of G[U \ {q1,qm,qm+1,ql}] into connected components. Then we make two calls to Partitionby-Path (Algorithm 12) for the path q1,...,qm and the path qm+1,...,ql , respectively. Thus, we
obtain the final partition (Figure 4).
The recursive procedure Partition-by-Path receives a convex subset Z ⊆ U of vertices and
two integers s,t such that 1 ≤ s < t ≤ l, and returns the partition of G[Z \ {qs ,qs+1,...,qt }] into
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.
Graph Reconstruction and Verification 40:23
ALGORITHM 11: Finding a Polygon
1: procedure Find-Polygon(U, a,b,c)
2: (A1,...,Ak1 ) ←Partition(U, {a,b})  see Algorithm 9
3: Let Ai be the component containing c
4: (C1,...,Ck2 ) ←Partition(U, {b,c})  see Algorithm 9
5: Let Cj be the component containing a
6: T ← (Ai ∩Cj) ∪ {a,c}
7: Query(a,T ), Query(c,T )
8: d ← minu ∈T {δ (a,u) + δ (u,c)}
9: Let z ∈ T be such that δ (a, z) + δ (z,c) = d and δ (a, z) = d/2
10: P1 ← Shortest-Path(T, a, z)  see Algorithm 8
11: P2 ← Shortest-Path(T, z,c)  see Algorithm 8
12: return the concatenation of P1, P2,cb,ba
ALGORITHM 12: Partition with respect to a path
1: procedure Partition-by-Path(Z,s,t)
2: if t > s + 1 then
3: m ← (s + t)/2
4: P ← Partition(Z, {qm })  see Algorithm 9
5: Let Z1 be the component in P containing qs
6: Let Z2 be the component in P containing qt
7: P1 ← Partition-by-Path(Z1,s,m)
8: P2 ← Partition-by-Path(Z2,m,t)
9: return (P\{Z1,Z2}) ∪ P1 ∪ P2
10: else
11: return Partition(Z, {qs ,qt })  see Algorithm 9
components. We analyze its query complexity. The number of queries of Partition(Z, {qm }) and
Partition(Z, {qs ,qt }) is O(Δ · |Z |) by Theorem 4.12. During the recursion, the length of the path
qs ,...,qt is reduced by half at every level, so there are at most log |U | levels of the recursion.
Since the Z sets on each level are disjoint, the overall query complexity on each level is O(Δ ·
|U |). Thus, the query complexity of Partition-by-Path is O(Δ · |U | log |U |). Since the partition
of G[U \ {q1,qm,qm+1,ql}] into components takes O(Δ · |U |) queries (Theorem 4.12), the overall
query complexity of Phase 2 is O(Δ · |U | log |U |).
4.3.2 Algorithm and Analysis. The reconstruction algorithm (Algorithm 13) takes as input a
convex subset U ⊆ V of an outerplanar graph and returns the edge set of G[U ]. Similar to Section 4.2, the function Balanced-Partition-Outerplanar computes a β-balanced partition of U .
We set n0 = 20; C1 = 324 log |U |, and β = √
11/12.
Correctness of the Reconstruct-Outerplanar algorithm is a trivial adaptation from Theorem 4.15. To bound the query complexity, the key is the following lemma.
Lemma 4.21. In every repeat loop of the function Balanced-Partition-Outerplanar, a βbalanced partition is found with probability at least 2/3.
To prove Theorem 4.21, we need Theorem 4.18 and the following lemma (Theorem 4.22).
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.      
40:24 S. Kannan et al.
Fig. 4. Partition by the polygon q1,...,ql .
ALGORITHM 13: Reconstruction of Outerplanar Graphs
1: procedure Reconstruct-Outerplanar(U )
2: if |U | > n0 then
3: (U1,...,U ) ←Balanced-Partition-Outerplanar(U )
4: return
iReconstruct-Outerplanar(Ui )
5: else
6: return Exhaustive-Query(U )
7: function Balanced-Partition-Outerplanar(U )
8: repeat
9: {(ai,bi )}1≤i ≤C1 ← uniform and independent random pairs from U
10: for i ← 1 to C1 do
11: Pi ← Shortest-Path(U, ai,bi )  see Algorithm 8
12: x ← the node in U with the most occurrences among {Pi}i
13: Query(x,U ) and obtain N (x) ∩U
14: P ← Partition(U, N (x) ∩U )  see Algorithm 9
15: if P is β-balanced thenreturn P  see Fig. 5
16: if x has two consecutive neighbors y and y such that the component between y and
y contains more than β |U | nodes then
17: P ← Partition-by-Polygon(U,y, x,y
)  see Section 4.3.1
18: until a β-balanced partition P is found
Lemma 4.22. For every v ∈ U , let pv denote the fraction of pairs (a,b) ∈ U 2 such that v is on some
shortest path between a and b. Then maxv pv ≥ 1/6.
Proof. Since G[U ] is outerplanar, it has treewidth at most 2. From Theorem 4.3, there exists
some set S ⊆ U of size at most 3 such that every connected component inG[U \ S] has size at most
|U |/2. The following argument is similar to that in the proof of Theorem 4.17. Notice that for any
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.         
Graph Reconstruction and Verification 40:25
Fig. 5. Partition by the neighbors y1,...,y6 of x.
pair of vertices a,b from different components of G[U \ S], any shortest a-to-b path must go by
some node in S. The number of such pairs is at least |U |
2/2. By the Pigeonhole Principle, there
exists some z ∈ S such that for at least 1/|S | ≥ 1/3 fraction of these pairs, their shortest paths go
by z. Thus, pz ≥ 1/6.
Proof of Theorem 4.21. Let x be the node computed in Line 12 of Algorithm 13. If the partition
by the neighbors (Line 14) is β-balanced or the partition by the polygon (Line 17) is β-balanced,
then the algorithm succeeds. Consider the case when no β-balanced partition is found. Then there
must be a convex subset S ⊆ U such that x  S and |S | ≥ β |U |. For every (a,b) ∈ S2, any shortest
path between a and b does not go by x. Thus, px ≤ 1 − (|S |/|U |)
2 ≤ 1 − β2 = 1/12 by the definition of β. Therefore, it is sufficient to bound the probability of px > 1/12 by at least 2/3. From
Theorem 4.22, we haveC1 ≥ 9 log |U |/(maxv pv )
2. Thus, by Theorem 4.18, we have px > 1/12 with
probability at least 2/3.
Query Complexity Analysis. First, we analyze the complexity of Balanced-PartitionOuterplanar. ComputingC1 shortest paths takesO(|U | log2 |U |) queries, since a shortest path between two given nodes can be computed usingO(|U | log |U |) queries (Theorem 4.11). We note that
the neighborhood N (x) of x has size at most Δ + 1. By Theorem 4.12, Partition(U, N (x)) takes
O(Δ2 |U |) queries. The procedure Partition-by-Polygon takesO(Δ|U | log |U |) queries. Therefore,
every repeat loop takes O(Δ2 |U | log2 |U |) queries. From Theorem 4.21, the expected number of
repeat loops is constant. Thus, the overall query complexity is O(Δ2 |U | log2 |U |).
Next, we analyze the complexity of Reconstruct-Outerplanar. Let q(m) be the number of
queries when |U | = m. We have
q(m) = O(Δ2
m log2m) +

i
q(|Ui |),
where {Ui}i is a β-balanced partition of U . Hence q(n) = O(Δ2
n log3 n).
Thus we complete the proof of Theorem 4.19.
Remark. An outerplanar graph is a generalization of a tree. The query complexity of our reconstruction algorithm for outerplanar graphs is only slightly worse than the optimal query complexityO(Δn logΔ n) for reconstructing trees [9]. On the other hand, the tree reconstruction model
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.   
40:26 S. Kannan et al.
typically restricts queries to pairs of tree leaves, but our model allows queries on any pair of vertices, not just leaves.
5 LOWER BOUNDS
In Section 5.1, we give a lower bound for general graphs where the maximum degree is unbounded;
and in Section 5.2, we give a lower bound for graphs of maximum degree Δ.
5.1 General Graphs
Lemma 5.1 (Extension of Proposition 7 in Reference [17]). For graph reconstruction or graph
verification using a distance oracle or a shortest path oracle, any algorithm has query complexity
Ω(n2).
Proof. We extend the lower bound for graph reconstruction by Reyzin and Srivastava [17] to
graph verification. Consider a graph G whose vertices are v1,...,vn and whose edges form a star:
there is an edge v1vi for every 2 ≤ i ≤ n. In addition, G may or may not contain a new edge vivj ,
for 2 ≤ i, j ≤ n. In the graph verification problem, the star graph is given as Gˆ. To check whether
G contains a new edge, we need to perform Ω(n2) distance or shortest path queries.
5.2 Graphs of Bounded Degree
In this section, we prove the following theorem.
Theorem 5.2. For graph reconstruction using a distance oracle, assuming that the maximum degree
Δ is at least 3 and is o(n1/2), any algorithm has query complexity Ω(Δn logn/ log(logn/ log Δ)).
14
Proof. To provide intuition, we first show a lower bound of Ω(Δn logn/ log logn), assuming
that n = 3t − 1, where t = 2k for some integer k. Consider a family G of graphs G as follows: the
vertex set is {v1,...,vn }; the first 2t − 1 vertices form a complete binary tree of height k (with
leaves vt,...,v2t−1); the vertices v2t,...,v3t−1 induce an arbitrary subgraph of maximum degree
Δ − 1; there is an edge between vi and vi+t for every i ∈ [t, 2t − 1] and there are no other edges.
Then every vertex in G has degree at most Δ, and the diameter of the graph is at most 2k + 2 =
O(logn). Every distance query returns a number between 1 and 2k + 2, so it gives O(log logn)
bits of information. From information theory, the number of queries to reconstruct the graph is
at least the logarithm of the number of graphs in G divided by the maximum number of bits of
information per query. The number of graphs in G is the number of different graphs of t vertices
and of maximum degree Δ − 1, which is Ω(nΩ(Δn)
) when Δ = o(
√
n) (see Reference [15]). Therefore,
we have a query lower bound:
log 
Ω 
nΩ(Δn)
 
O(log logn) = Ω

Δn logn
log logn

.
To prove the bound as stated in Theorem 5.2, we only need to replace the above complete binary
tree by a complete (Δ − 1)-ary tree. The diameter of the graph is now O(logn/ log Δ). The theorem
statement follows.
6 APPROXIMATE RECONSTRUCTION
In this section, we study the approximate version of the reconstruction problem using a distance
oracle on general graphs (not necessarily of bounded degree). We first give a simple algorithm
14This result is not comparable with the lower bound by King et al. [13] for tree reconstruction, since we allow querying
any pairs of nodes, not only pairs of leaves in a tree.
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.  
Graph Reconstruction and Verification 40:27
(Algorithm 14, see Theorem 6.1), and then show that this algorithm is optimal by providing a
query lower bound of the same complexity (see Theorem 6.2).
Let G = (V, E) be a connected, undirected, and unweighted graph. Let δ be the distance metric
of G. Let f be any sublinear function of n. An f -approximation ˜
δ of the metric δ is such that, for
every (u,v) ∈ V 2, ˜
δ (u,v) ≤ δ (u,v) ≤ f · ˜
δ (u,v).
Algorithm 14 receives the vertex set V and outputs the approximate metric ˜
δ. The algorithm
repeatedly picks a node u such that the distances between u and some other nodes are not yet
estimated. It then makes queries between u and the other nodes and obtains an estimate ˜
δ (x,y)
for every node x within distance f /2 from u and for every node y in the graph. The algorithm
repeats the above until all distances are estimated.
ALGORITHM 14
1: procedure Approx-Reconstruct(V )
2: S ← V
3: while S  ∅ do
4: u ← arbitrary node from S
5: Query(u, S)
6: Let B be the set of nodes whose distance to u is strictly less than f /2
7: Set ˜
δ (x,y) = 1 for all pairs (x,y) ∈ B × B with x  y
8: Set ˜
δ (x,y) = δ (u,y) − δ (u, x) for all pairs (x,y) ∈ B × (S \ B)
9: Remove B from S
10: return ˜
δ
Theorem 6.1. The algorithm Approx-Reconstruct(V ) computes an f -approximation of the
graph metric δ using O(n2/f ) distance queries.
Proof. We prove that in the end of the algorithm, for every (x,y) ∈ V 2, we have ˜
δ (x,y) ≤
δ (x,y) ≤ f · ˜
δ (x,y). Look at any iteration of the while loop. First, consider any pair (x,y) ∈ B × B
with x  y. We have
˜
δ (x,y) = 1 ≤ δ (x,y) ≤ δ (x,u) + δ (u,y) < (f /2) + (f /2) = f = f · ˜
δ (x,y).
Next, consider any pair (x,y) ∈ B × (S \ B). On the one hand, by the triangular inequality,
δ (x,y) ≥ δ (u,y) − δ (u, x) = ˜
δ (x,y).
On the other hand, by the triangular inequality,
δ (x,y) ≤ (δ (u,y) − δ (u, x)) + 2δ (u, x).
The first term is ˜
δ (x,y). The second term, by the definition of B, is at most (f − 1). Since x ∈ B
and y  B, we have ˜
δ (x,y) ≥ 1, so the second term can be bounded by f − 1 ≤ (f − 1) · ˜
δ (x,y).
Adding completes the proof of the upper bound.
Now we analyze the query complexity of the algorithm. Let U ⊆ V be the set of nodes u chosen
in Line 4 during the algorithm. For every pair of distinct nodes u,u ∈ U , we have δ (u,u
) ≥ f /2.
For every u ∈ U , define N (u, f /4) as the neighborhood of u within distance f /4. Then we have
|N (u, f /4)| ≥ f /4, sinceG is connected. Observe that the sets {N (u, f /4)}u ∈U are disjoint, so there
are at most 4n/f sets, i.e., |U | ≤ 4n/f . For every u ∈ U , the algorithm makes O(n) queries. Thus,
the total number of queries is O(n2/f ).
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.       
40:28 S. Kannan et al.
Fig. 6. In this example, f = 2; The construction of the tree is based on two permutations σ1 and σ2.
For the lower bound, we extend the arguments for the case of f = 1 by Reyzin and Srivastava [17,
Proposition 7] and obtain the following theorem.
Theorem 6.2. To compute an f -approximation of the graph metric δ using a distance oracle, any
algorithm requires Ω(n2/f ) queries.
Proof. To simplify the proof, we assume n = 2f k + 1, for k ∈ N. We define a family of instances
as follows. For each f -tuple (σ1,..., σf ) such that every σi (where i ∈ [1, f ]) is a permutation of
{1,..., k}, we define a tree instance: it has one vertex a0 as the root (on the first level), k vertices a1,..., ak on the second level, k vertices ak+1,..., a2k on the third level, ..., and k vertices
an−k ,..., an−1 on the (2f + 1)
th level. For every l ∈ [2, f ] and every i ∈ [1, k], there is an edge
between the i
th node on level l and the i
th node on level l + 1. For every l ∈ [f + 1, 2f ] and every
i ∈ [1, k], there is an edge between the i
th node on level l and the σl−f (i)
th node on level l + 1. See
Figure 6. We observe that every tree constructed above has k branches from the root, and every
branch is a path of 2f + 1 nodes. We will show that any algorithm requires Ω(n2/f ) queries to
compute an f -approximation of the metric on these instances.
First, notice that for these instances, any f -approximation ˜
δ of the metric can be transformed
into the metric δ without queries: For every nodes u and v on consecutive levels between level
f + 1 and level 2f + 1, uv is an edge of G if and only if ˜
δ (u,v) < 2f . This is because, if u and v are
in the same branch, we have δ (u,v) = 1, so ˜
δ (u,v) ≤ f ; and if u and v are in different branches,
we have δ (u,v) = δ (a0,u) + δ (a0,v) ≥ 2f , so ˜
δ (u,v) ≥ 2f . Therefore, we only need to prove that
any algorithm for the exact reconstruction problem requires Ω(n2/f ) queries on these instances.
Given that an instance is from the constructed family, let A be any algorithm for the exact
reconstruction problem. We assume that A does not make redundant queries, i.e., queries whose
answers can be deduced in advance. Obviously, any query with the root is redundant. For any
two nodes u and v, let lu and lv be their levels. The query (u,v) is redundant when lu ≤ f + 1 and
lv ≤ f + 1, since the first f + 1 levels are fixed. Thus, every query (u,v) is such thatlu > f + 1 and
lv ≥ 2 (we assume lu ≥ lv without loss of generality). The answer is either lu − lv , if u and v are
in the same branch; orlu + lv − 2, if u and v are in different branches. We can equivalently identify
the answer as Yes or No to the question: Are u and v in the same branch? The key is to upper bound
the number of Yes answers during the algorithm. We introduce the component graph H, which
represents the information collected from the Yes answers during the algorithm. The vertex set of
H is defined to be the set of all nodes of level between f + 1 and 2f + 1. At the beginning, the edge
set of H is empty. Each time when A receives a Yes answer to a query (u,v), we add an edge to H
as follows:
ACM Transactions on Algorithms, Vol. 14, No. 4, Article 40. Publication date: August 2018.
Graph Reconstruction and Verification 40:29
Fig. 7. Decision tree of A.
(1) If lu > f + 1 and lv ≥ f + 1, then we add the edge uv to H;
(2) If lu > f + 1 and 2 ≤ lv < f + 1, then we add the edge uw to H, where w is the node on
level f + 1 that is in the same branch as v.
There could not be cycles in H, otherwise there are redundant queries. The number of connected
components in H is at least k, since every connected component in H contains nodes from the
same branch of the tree and there are k branches. The number of edges in H is the number of
vertices minus the number of connected components, which is at most k(f + 1) − k = k f . Since
every Yes answer adds an edge into H, the algorithm A stops after at most k f Yes answers.
Next, we show the lower bound by a decision tree argument. See Figure 7. First, A queries
some pair (u1,v1). If the answer is Yes, it queries some pair (u2,v2), otherwise it queries some pair
(u3,v3), and so on. A stops if and only if it arrives at a leaf of the decision tree. Let h be the height
of the decision tree. We only need to prove that h = Ω(n2/f ). A leaf of the decision tree is identified
by its root-leaf path, a word over {Yes, No} of length at most h and with at most k f Yeses.15 The
total number of leaves in the decision tree is at most

0≤j ≤k f

h
j

≤ 2 ·

h
k f 
≤
2hk f
(k f )!
.
On the other hand, the number of leaves in the decision tree is the number of instances, which is
(k!)
f . Therefore,
(k!)
f ≤
2hk f
(k f )!
.
Using Stirling’s formula, we have h = Ω(k2 f ) = Ω(n2/f ).
7 OPEN QUESTION
The central open question is the following: Is there an algorithm for graph reconstruction using a
near-linear number of queries to a distance oracle? We believe that the resolution of this question
in either direction would lead to new techniques on metric embeddings and the shortest paths
structure of degree-bounded graphs, which are both considered very important by the community 