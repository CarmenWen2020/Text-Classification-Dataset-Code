We show that the Simplex Method, the Network Simplex Method—both with Dantzig’s original pivot rule—
and the Successive Shortest Path Algorithm are NP-mighty. That is, each of these algorithms can be used
to solve, with polynomial overhead, any problem in NP implicitly during the algorithm’s execution. This
result casts a more favorable light on these algorithms’ exponential worst-case running times. Furthermore,
as a consequence of our approach, we obtain several novel hardness results. For example, for a given input
to the Simplex Algorithm, deciding whether a given variable ever enters the basis during the algorithm’s
execution and determining the number of iterations needed are both NP-hard problems. Finally, we close a
long-standing open problem in the area of network flows over time by showing that earliest arrival flows are
NP-hard to obtain.
CCS Concepts: • Theory of computation → Discrete optimization; Network flows; Complexity classes; •
Mathematics of computing → Combinatorial optimization;
Additional Key Words and Phrases: Simplex algorithm, network simplex, successive shortest paths, NPmightiness, earliest arrival flows
1 INTRODUCTION
Understanding the complexity of algorithmic problems is a central challenge in the theory of computing. Traditionally, complexity theory operates from the point of view of the problems we encounter in the world by considering a fixed problem and asking how nice an algorithm the problem
admits with respect to running time, memory consumption, robustness to uncertainty in the input, determinism, and the like. In this article, we advocate a different perspective by considering
a particular algorithm and asking how powerful (or mighty) the algorithm is (i.e., what the most
difficult problems are that the algorithm can be used to solve “implicitly” during its execution).
Related Literature. A traditional approach to capturing the mightiness of an algorithm is to
ask how difficult the exact problem is that the algorithm was designed to solve; thatis, what is
the complexity of predicting the algorithm’s final outcome. For optimization problems, however,
if there are multiple optimum solutions to an instance, predicting which optimum solution a specific algorithm will produce might be more difficult than finding an optimum solution in the first
place. If this is the case, the algorithm can be considered to be mightier than the problem it is
solving suggests. A prominent example for this phenomenon are search algorithms for problems
in the complexity class PLS (for Polynomial Local Search), introduced by Johnson, Papadimitriou,
and Yannakakis [16]. Many problems in PLS are complete with respect to so-called tight reductions, which implies that finding any optimum solution reachable from a specific starting solution
via local search is PSPACE-complete [25]. Any local search algorithm for such a problem can thus
be considered to be PSPACE-mighty. Goldberg, Papadimitriou, and Savani [13] established similar PSPACE-completeness results for algorithms solving search problems in the complexity class
PPAD (for Polynomial Parity Argument in Directed Graphs [24]) and, in particular, for the wellknown Lemke-Howson algorithm [21] for finding Nash equilibria in bimatrix games.
Preliminary versions of our article appeared in Disser and Skutella [6, 7]. As our main result,
we show that the (Network) Simplex Algorithm with Danzig’s original pivot rule implicitly solves
NP-hard problems. Concurrently, Adler, Papadimitriou, and Rubinstein [1] gave an artificial pivot
rule for which it is even PSPACE-complete to decide whether a given basis will appear during
the algorithm’s execution. They show that this is not the case for the Simplex Algorithm with the
shadow vertex pivot rule. Note that the corresponding algorithm might still implicitly solve hard
problems in our sense. Recently, and inspired by our results, Fearnley and Savani [8] strengthened
our results for the Simplex Algorithm with Danzig’s pivot rule. They show that the resulting algorithm even explicitly solves a PSPACE-complete problem. Note that their result is specifically
tailored to the general Simplex Method and does not hold for the Network Simplex Algorithm or
the Successive Shortest Path Algorithm. By showing that the latter are already implicitly solving
hard problems, we are able to infer interesting consequences (e.g., for earliest arrival flows). Other
recent work regarding the complexity of algorithms was conducted by Fearnely and Savani [9],
and by Roughgarden and Wang [26].
A Novel Approach. We propose to take the analysis of algorithms beyond understanding the
complexity of the exact problem an algorithm is solving and argue, instead, that the mightiness
of an algorithm could also be classified by the complexity of the problems that the algorithm can
be made to solve implicitly. In particular, we do not consider an algorithm as a black box that
turns a given input into a well-defined output. Instead, we are interested in the entire process of
computation (i.e., the sequence of the algorithm’s internal states) that leads to the final output, and
we ask how meaningful this process is in terms of valuable information that can be drawn from
it. As we show in this article, sometimes very limited information on an algorithm’s process of
computation can be used to solve problems that are considerably more complex than the problem
the algorithm was actually designed for.
We define the mightiness of an algorithm via the complexity of the problems that it can solve
implicitly in this way, and, in particular, we say that an algorithm is NP-mighty if it implicitly solves
all problems in NP (precise definitions are given later). Note that in order to make mightiness
a meaningful concept, we need to make sure that mindless exponential algorithms like simple
counters do not qualify as being NP-mighty, while algorithms that explicitly solve hard problems
do. This goal is achieved by carefully restricting the allowed computational overhead as well as
the access to the algorithm’s process of computation.
Considered Algorithms. For an algorithm’s mightiness to lie beyond the complexity class of
the problem it was designed to solve, its running time must be excessive for this complexity class.
Most algorithms that are inefficient in this sense would quickly be disregarded as wasteful and not
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.
The Simplex Algorithm Is NP-Mighty 5:3
meriting further investigation. Dantzig’s Simplex Method [4] is a famous exception to this rule.
Empirically, it belongs to the most efficient methods for solving linear programs. However, Klee
and Minty [20] showed that the Simplex Algorithm with Dantzig’s original pivot rule exhibits
exponential worst-case behavior. Similar results are known for many other popular pivot rules
(see, e.g., Amenta and Ziegler [2]). On the other hand, by the work of Khachiyan [18, 19] and later
Karmarkar [17], it is known that linear programs can be solved in polynomial time. Spielman and
Teng [28] developed the concept of smoothed analysis in order to explain the practical efficiency
of the Simplex Method despite its poor worst-case behavior.
Minimum-cost flow problems form a class of linear programs featuring a particularly rich combinatorial structure allowing for numerous specialized algorithms. The first such algorithm is
Dantzig’s Network Simplex Method [5] which is an interpretation of the general Simplex Method
applied to this class of problems. In this article, we consider the primal (Network) Simplex Method
together with Dantzig’s pivot rule, which always selects the nonbasic variable with the most negative reduced cost to enter the basis. We refer to this variant of the (Network) Simplex Method as
the (Network) Simplex Algorithm.
One of the simplest and most basic algorithms for minimum-cost flow problems is the Successive Shortest Path Algorithm, which iteratively augments flow along paths of minimum cost in
the residual network [3, 14]. According to Ford and Fulkerson [10], the underlying theorem stating
that such an augmentation step preserves optimality “may properly be regarded as the central one
concerning minimal cost flows.” Zadeh [31] presented a family of instances forcing the Successive
Shortest Path Algorithm and also the Network Simplex Algorithm into exponentially many iterations. On the other hand, Tardos [29] proved that minimum-cost flows can be computed in strongly
polynomial time, and Orlin [23] gave a polynomial variant of the Network Simplex Method.
Main Contribution. We argue that the exponential worst-case running time of the (Network)
Simplex Algorithm and the Successive Shortest Path Algorithm is, for some instances, due to the
computational difficulty of the solution scheme these algorithms implement, rather than being
caused by excessive repetition of the same operations or the like. While both algorithms sometimes
take longer than necessary to reach their primary objective (namely, to find an optimum solution
to a particular linear program), they perform meaningful computations internally that may require
them to implicitly solve difficult problems. To make this statement more precise, we introduce a
definition of “implicitly solving: that is as minimalistic as possible with regards to the extent in
which we are permitted to use the algorithm’s internal state. The following definition refers to the
complete configuration of a Turing machine (i.e., a binary representation of the machine’s internal
state, contents of its tape, and position of its head).
Definition 1.1. An algorithm given by a Turing machine T implicitly solves a decision problem
P if, for a given instance I of P, it is possible to compute in polynomial time an input I  for T and
a bit b in the complete configuration of T , such that I is a yes-instance if and only if b flips at some
point during the execution of T for input I
.
An algorithm that implicitly solves a particular NP-hard decision problem, implicitly solves all
problems in NP. We call such algorithms NP-mighty.
Definition 1.2. An algorithm is NP-mighty if it implicitly solves every decision problem in NP.
Note that every algorithm that explicitly solves an NP-hard decision problem, by definition, also
implicitly solves this problem (assuming, without loss of generality, that a single bit indicates if
the Turing machine has reached an accepting state) and thus is NP-mighty. Also note that our
definitions are tailored to the class NP but could be generalized to other complexity classes. In that
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.  
5:4 Y. Disser and M. Skutella
context, our notion of implicitly solving a decision problem should be referred to more precisely
as “NP-implicit.”
The preceding definitions turn out to be sufficient for our purposes. We remark, however, that
slightly more general versions of Definition 1.1, involving constantly many bits or broader/free
access to the algorithm’s output, seem reasonable as well. In this context, access to the exact
number of iterations needed by the algorithm also seems reasonable as it may provide valuable
information. In fact, our results below still hold if the number of iterations is all we may use of
an algorithm’s behavior. Most importantly, our definitions have been formulated with some care
in an attempt to distinguish exponential-time algorithms that implement sophisticated solution
schemes from those that instead “waste time” on less meaningful operations. We discuss this
critical point in some further detail.
Constructions of exponential time worst-case instances for algorithms usually rely on gadgets
that somehow force an algorithm to count (i.e., to enumerate over exponentially many configurations). Such counting behavior by itself cannot be considered meaningful, and, consequently, an
algorithm should certainly exhibit more elaborate behavior to qualify as being NP-mighty. As an
example, consider the simple counting algorithm (Turing machine) that counts from a given positive number down to zero; that is, the Turing machine iteratively reduces the binary number on
its tape by one until it reaches zero. To show that this algorithm is not NP-mighty, we need to
assume that PNP, as otherwise the polynomial-time transformation of inputs can already solve
NP-hard problems. Since, for sufficiently large inputs, every state of the simple counting algorithm
is reached, and since every bit on its tape flips at some point, our definitions are meaningful in the
following sense.
Proposition 1.3. Unless P = NP, the simple counting algorithm is not NP-mighty while every
algorithm that solves an NP-hard problem is NP-mighty.
Our main result explains the exponential worst-case running time of the following algorithms
with their computational power.
Theorem 1.4. The Simplex Algorithm, the Network Simplex Algorithm (both with Dantzig’s pivot
rule), and the Successive Shortest Path Algorithm are NP-mighty.
We prove this theorem by showing that the algorithms implicitly solve the NP-complete Partition problem (cf. Garey and Johnson [12]). To this end, we show how to turn a given instance of
Partition in polynomial time into a minimum-cost flow network with a distinguished arc e, such
that the Network Simplex Algorithm (or the Successive Shortest Path Algorithm) augments flow
along arc e in one of its iterations if and only if the Partition instance has a solution. Under the
mild assumption that in an implementation of the Network Simplex Algorithm or the Successive
Shortest Path Algorithm fixed bits are used to store the flow variables of arcs, this implies that
these algorithms implicitly solve Partition in terms of Definition 1.1.
A central part of our network construction is a recursively defined family of counting gadgets
on which these minimum-cost flow algorithms take exponentially many iterations. These counting gadgets are, in some sense, simpler than Zadeh’s 40-year-old “bad networks” [31] and thus
interesting in their own right. By slightly perturbing the costs of the arcs according to the values
of a given Partition instance, we manage to force the considered minimum-cost flow algorithms
into enumerating all possible solutions. In contrast to counters, we show that the internal states of
these algorithms reflect whether or not they encountered a valid Partition solution (in the sense
of Definition 1.1).
Further Results. We mention interesting consequences of our main results just discussed
(proofs in Section 5). We first state complexity results that follow from our proof of Theorem 1.4.
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018. 
The Simplex Algorithm Is NP-Mighty 5:5
Corollary 1.5. Determining the number of iterations needed by the Simplex Algorithm, the Network Simplex Algorithm, and the Successive Shortest Path Algorithm for a given input is NP-hard.
Corollary 1.6. Deciding for a given linear program whether a given variable ever enters the basis
during the execution of the Simplex Algorithm is NP-hard.
Another interesting implication is for parametric flows and parametric linear programming.
Corollary 1.7. Determining whether a parametric minimum-cost flow uses a given arc (i.e., assigns positive flow value for any parameter value) is NP-hard. In particular, determining whether
the solution to a parametric linear program uses a given variable is NP-hard. Also, determining the
number of different basic solutions over all parameter values is NP-hard.
We also obtain the following complexity result on 2-dimensional projections of polyhedra.
Corollary 1.8. Given a d-dimensional polytope P defined by a system of linear inequalities, determining the number of vertices of P’s projection onto a given 2-dimensional subspace is NP-hard.
We finally mention a result for a long-standing open problem in the area of network flows over
time (see, e.g., Skutella [27] for an introduction to this area). The goal in earliest arrival flows is to
find an s-t-flow over time that simultaneously maximizes the amount of flow that has reached the
sink node t at any point in time [11]. It is known since the early 1970s that the Successive Shortest
Path Algorithm can be used to obtain such an earliest arrival flow [22, 30]. All known encodings of
earliest arrival flows, however, suffer from exponential worst-case size, and, ever since, it has been
an open problem whether there is a polynomial encoding which can be found in polynomial time.
The following corollary implies that, in a certain sense, earliest arrival flows are NP-hard to obtain.
Corollary 1.9. Determining the average arrival time of flow in an earliest arrival flow is NP-hard.
Note that an s-t-flow over time is an earliest arrival flow if and only if it minimizes the average
arrival time of flow [15].
Outline. After establishing some minimal notation in Section 2, we proceed to proving Theorem 1.4 for the Successive Shortest Path Algorithm in Section 3. In Section 4, we adapt the construction for the Network Simplex Algorithm. Explanations and proofs of the above-mentioned
corollaries are given in Section 5. Finally, Section 6 highlights interesting open problems for future research.
2 PRELIMINARIES
In the following sections, we show that the Successive Shortest Path Algorithm and the Network
Simplex Algorithm implicitly solve the classical Partition problem. An instance of Partition is
given by a vector of positive numbers a = (a1,..., an ) ∈ Qn and the problem is to decide whether
there is a subset I ⊆ {1,...,n} with
i ∈I ai =
iI ai . This problem is well-known to be NPcomplete (cf. [12]). Throughout this article, we consider an arbitrary fixed instance a of Partition.
Without loss of generality, we assume A := n
i=1 ai < 1/12 and that all values ai , i ∈ {1,...,n}, are
multiples of ε for some fixed ε > 0 (polynomially representable and depending on the instance).
Let v = (v1,...,vn ) ∈ Qn and k ∈ N, with kj ∈ {0, 1}, j ∈ Z≥0, being the jth bit in the binary
representation of k (i.e., kj := k/2j
 mod 2). We define v[k]
i1,i2 := i2
j=i1+1 (−1)
kj−1vj , v[k]
i := v[k]
0,i , and
v[k]
i,i = 0. The following characterization will be useful later.
Proposition 2.1. The Partition instance a admits a solution if and only if there is a k ∈
{0,..., 2n − 1} for which a[k] n = 0.
Throughout this article, we construct instances of the minimum cost (maximum) flow problem that we use as input to the Successive Shortest Path Algorithm and the Network Simplex
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.              
5:6 Y. Disser and M. Skutella
Algorithm. In this context, a network N = (G,u,s,t) consists of a directed graph G = (V, E) together with arc capacities u : E → R≥0 ∪ {∞}, as well as a source s ∈ V and a sink t ∈ V . In the
following, we denote δ−(v) := (V × {v}) ∩ E and δ+(v) := ({v} ×V ) ∩ E for all v ∈ V . A flow in
a network is a function f : E → R≥0 that obeys capacities (i.e., f (e) ≤ u(e) for all e ∈ E) and
conserves flow (i.e.,
e ∈δ −(v) f (e) =
e ∈δ +(v) f (e) for all v ∈ V \ {s,t}). The residual network
Nf = (Gf ,uf ,s,t) of N with respect to f is defined over the residual (multi)graphGf = (V, E ∪ E¯),
where E¯ := {(v,v
) ∈ V ×V : (v
,v) ∈ E} is the set of reverse arcs (for simplicity of notation, we
assume that Gf is a simple graph, and, in general E and E¯ can no longer be expressed as sets of
tuples). The costs of arcs e ∈ E¯ in the residual network Nf are given by c(e) := −c(e¯), where e¯
denotes the reverse arc of e. The capacities uf of the residual network are given by
uf (e) :=

u(e) − f (e) ife ∈ E,
f (e¯) ife ∈ E¯.
A maximum flow is a flow f that maximizes the flow value |f | :=
e ∈δ +(s ) f (e) −
e ∈δ −(s ) f (e).
In the minimum cost (maximum) flow problem, we are given a network N = (G,u,s,t) and need to
find a maximum flow f that minimizes the cost
e ∈E c(e) · f (e) with respect to given arc costsc :
E → R.
In the parametric minimum cost flow problem, we are given a network N with arc costs c
and need to determine a parametric flow f : E × R≥0 → R≥0, such that, for all λ ∈ R≥0, we have
that fλ (e) := f (e, λ) defines a minimum cost flow among all flows of value λ, if such flows exist.
Finally, a flow over time on a network with transit times τ : E → R≥0 is a function f : E × R≥0 →
R≥0, such that the following hold:
— fe (θ ) := f (e, θ ) is Lebesgue-integrable for every fixed e ∈ E.
— fe (θ ) ≤ u(e) for all e ∈ E and θ ∈ R≥0.
—exf (v, θ ) :=
e ∈δ −(v)
 θ−τ (e )
0 fe (ξ) dξ −
e ∈δ +(v)
 θ
0 fe (ξ) dξ = 0 for for every θ ∈ R≥0 and
every v ∈ V \ {s,t}.
An earliest arrival flow is a flow over time f that simultaneously maximizes exf (t, θ ) for all θ ∈
R≥0. For more details regarding flows over time, we refer to Skutella [27].
3 SUCCESSIVE SHORTEST PATH ALGORITHM
Consider a network N with a source node s, a sink node t, and non-negative arc costs. The Successive Shortest Path Algorithm starts with the zero-flow and iteratively augments flow along a
minimum-costs-t-path in the current residual network, until a maximum s-t-flow has been found.
Note that the residual network is a subnetwork of N’s bidirected network, where the cost of a
backward arc is the negative of the cost of the corresponding forward arc.
3.1 A Counting Gadget for the Successive Shortest Path Algorithm
In this section, we construct a family of networks for which the Successive Shortest Path Algorithm
takes an exponential number of iterations. Assume we have a network Ni−1 with source si−1 and
sink ti−1 which requires 2i−1 iterations that each augment one unit of flow. We can obtain a new
network Ni with only two additional nodessi , ti for which the Successive Shortest Path Algorithm
takes 2i iterations. To do this, we add two arcs (si,si−1), (ti−1,ti ) with capacity 2i−1 and cost 0, and
two arcs (si,ti−1), (si−1,ti ) with capacity 2i−1 and very high cost. The idea is that, in the first
2i−1 iterations, one unit of flow is routed along the arcs of cost 0 and through Ni−1. After 2i−1
iterations, both the arcs (si,si−1), (ti−1,ti ) and the subnetwork Ni−1 are completely saturated and
the Successive Shortest Path Algorithm starts to use the expensive arcs (si,ti−1), (si−1,ti ). Each of
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.          
The Simplex Algorithm Is NP-Mighty 5:7
Fig. 1. Recursive definition of the counting gadget Nv
i for the Successive Shortest Path Algorithm and v ∈
{a, −a}. Arcs are labeled by their cost and capacity in this order. The cost of the shortestsi-ti-path in iteration
j = 0,..., 2i − 1 is j +v[j]
i .
Fig. 2. Illustration of the iterations performed by the Successive Shortest Path Algorithm on the counting
gadget Na
2 . The shortest path in each iteration is marked in red, and arcs are oriented in the direction in
which they are used next. Note that, after 2i = 4 iterations, the configuration is the same as in the beginning
if we switch the roles of s2 and t2.
the next 2i−1 iteration adds one unit of flow along the expensive arcs and removes one unit of flow
from the subnetwork Ni−1.
We tune the cost of the expensive arcs to 2i−1 − 1
2 , which turns out to be just expensive enough
(see Figure 1, with vi = 0). This leads to a particularly nice progression of the costs of shortest
paths, where the shortest path in iteration j = 0, 1,..., 2i − 1 simply has cost j (Figure 2).
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.      
5:8 Y. Disser and M. Skutella
Our goal is to use this counting gadget to iterate over all candidate solutions for a Partition instancev (we later use the gadget forv ∈ {a, −a}, where a is the fixed partition instance of Section 2).
Motivated by Proposition 2.1, we perturb the costs of the arcs in such a way that the shortest path
in iteration j has cost j +v[j]
i . We achieve this by adding 1
2vi to the cheap arcs (si,si−1), (ti−1,ti )
and subtracting 1
2vi from the expensive arcs (si,ti−1), (si−1,ti ). If the value of vi is small enough,
this modification does not affect the overall behavior of the gadget. The first 2i−1 iterations now
have an additional cost of vi while the next 2i−1 iterations have an additional cost of −vi , which
leads to the desired cost when the modification is applied recursively.
Figure 1 shows the recursive construction of our counting gadget Nv
n that encodes the Partition instance v. The following lemma formally establishes the crucial properties of the construction.
Lemma 3.1. For v ∈ {a, −a} and i = 1,...,n, the Successive Shortest Path Algorithm applied to
network Nv
i with source si and sink ti needs 2i iterations to find a maximum si-ti-flow of minimum
cost. In each iteration j = 0, 1,..., 2i − 1, the algorithm augments one unit of flow along a path of
cost j +v[j]
i in the residual network.
Proof. We prove the lemma by induction on i, together with the additional property that, after
2i iterations, none of the arcs in Nv
i−1 carries any flow, while the arcs in Nv
i \ Nv
i−1 are fully saturated. First consider the network Nv
0 . In each iteration where Nv
0 does not carry flow, one unit of
flow can be routed from s0 to t0. Conversely, when Nv
0 is saturated, one unit of flow can be routed
from t0 to s0. In either case, the associated cost is 0. With this in mind, it is clear that on Nv
1 the
Successive Shortest Path Algorithm terminates after two iterations. In the first, one unit of flow
is sent along the path s1,s0,t0,t1 of cost v1 = v[0]
1 . In the second iteration, one unit of flow is sent
along the path s1,t0,s0,t1 of cost −v1 = v[1]
1 . Afterward, the arc (s0,t0) does not carry any flow,
while all other arcs are fully saturated.
Now assume the claim holds for Nv
i−1 and consider network Nv
i , i > 1. Observe that every path
using either of the arcs (si,ti−1) or (si−1,ti ) has a cost of more than 2i−1 − 3/4. To see this, note that
the cost of these arcs is bounded individually by 1
2 (2i − 1 −vi ) > 2i−1 − 3/4, since |vi | < A < 1/4.
On the other hand, it can be seen inductively that the shortest ti−1-si−1-path in the bidirected
network associated with Nv
i−1 has cost at least −2i−1 + 1 − A > −2i−1 + 3/4. Hence, using both
(si,ti−1) and (si−1,ti ) in addition to a path from ti−1 to si−1 incurs cost at least 2i−1 − 3/4. By
induction, in every iteration j < 2i−1, the Successive Shortest Path Algorithm thus does not use
the arcs (si,ti−1) or (si−1,ti ) but instead augments one unit of flow along the arcs (si,si−1), (ti−1,ti )
and along an si−1-ti−1-path of cost j +v[j]
i−1 < 2i−1 − 3/4 through the subnetwork Nv
i−1. The total
cost of this si-ti-path is vi + (j +v[j]
i−1) = j +v[j]
i , since j < 2i−1.
After 2i−1 iterations, the arcs (si,si−1) and (ti−1,ti ) are both fully saturated, as well as (by induction) the arcs in Nv
i−1 \ Nv
i−2, while all other arcs are without flow. Consider the residual network
of Nv
i−1 at this point. If we increase the costs of the four residual arcs in Nv
i−1 \ Nv
i−2 by 1
2 (2i−1 − 1)
and switch the roles of si−1 and ti−1, we obtain back the original subnetwork Nv
i−1. The shift of
the residual costs effectively makes every ti−1-si−1-path more expensive by 2i−1 − 1, but does not
otherwise affect the behavior of the network. We can thus use induction again to infer that, in
every iteration j = 2i−1,..., 2i − 1, the Successive Shortest Path Algorithm augments one unit of
flow along a path via si,ti−1, Nv
i−1,si−1,ti . Accounting for the shift in cost by 2i−1 − 1, we obtain
that this path has a total cost of
(2i − 1 −vi ) + 
j − 2i−1 +v[j−2i−1]
i−1

− (2i−1 − 1) = j +v[j]
i ,
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.                                      
The Simplex Algorithm Is NP-Mighty 5:9
Fig. 3. Illustration of network Ga
ssp. The subnetworks Na
n and N−a n are advanced independently by the Successive Shortest Path Algorithm without using arc e, unless the Partition instance a has a solution.
where we used v[j−2i−1]
i−1 = v[j]
i−1 and v[j]
i−1 −vi = v[j]
i for j ∈ [2i−1, 2i ). After 2i iterations the arcs in
Nv
i \ Nv
i−1 are fully saturated and all other arcs carry no flow.
3.2 The Successive Shortest Path Algorithm Implicitly Solves Partition
We use the counting gadget of Section 3.1 to prove Theorem 1.4 for the Successive Shortest Path
Algorithm. Let Ga
ssp be the network consisting of the two gadgets Na
n , N−a
n , connected to a new
source node s and a new sink t (Figure 3). In both gadgets, we add the arcs (s,sn ) and (tn,t) with
capacity 2n and cost 0. We introduce an additional arc e (dashed in the figure) of capacity 1 and
cost 0 from node s0 of gadget Na
n to node t0 of gadget N−a
n . Finally, we increase the costs of the
arcs (s0,t0) in both gadgets from 0 to 1
5 ε. Recall that ε > 0 is related to a by the fact that all ai ’s are
multiples of ε (i.e., a cost smaller than ε is insignificant compared to all other costs).
Lemma 3.2. The Successive Shortest Path Algorithm on network Ga
ssp augments flow along arc e if
and only if the Partition instance a has a solution.
Proof. First observe that our slight modification of the cost of arc (s0,t0) in both gadgets Na
n
and N−a
n does not affect the behavior of the Successive Shortest Path Algorithm. This is because
the cost of any path in G is perturbed by at most 2
5 ε, and hence the shortest path remains the same
in every iteration. The only purpose of the modification is tie-breaking.
Consider the behavior of the Successive Shortest Path Algorithm on the networkGa
ssp with arc e
removed. In each iteration, the shortest s-t-path goes via one of the two gadgets. By Lemma 3.1,
each gadget can be in one of 2n + 1 states, and we number these states increasingly from 0 to 2n
by the order of their appearance during the execution of the Successive Shortest Path Algorithm.
The shortest s-t-path through either gadget in state j = 0,..., 2n − 1 has a cost in the range [j −
A, j + A], and hence it is cheaper to use a gadget in state j than the other gadget in state j + 1. This
means that after every two iterations, both gadgets are in the same state.
Now consider the network Ga
ssp with arc e put back. We show that, as before, if the two gadgets
are in the same state before iteration 2j, j = 0,..., 2n − 1, then they are again in the same state two
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.                       
5:10 Y. Disser and M. Skutella
iterations later. More importantly, arc e is used in iterations 2j and 2j + 1 if and only if a[j]
n = 0. This
proves the lemma since, by Proposition 2.1, a[j]
n = 0 for some j < 2n if and only if the Partition
instance a has a solution.
To prove our claim, assume that both gadgets are in the same state before iteration 2j. Let P+
be the shortest s-t-path that does not use any arc of N−a
n , P− be the shortest s-t-path that does not
use any arc of Na
n , and P be the shortest s-t-path using arc e. Note that one of these paths is the
overall shortests-t-path. We distinguish two cases, depending on whether the arc (s0,t0) currently
carries flow 0 or 1 in both gadgets.
If (s0,t0) carries flow 0, then P+, P− use arc (s0,t0) in forward direction. Therefore, by Lemma 3.1,
the cost of P+ is j + a[j]
n + 1
5 ε, while the cost of P− is j − a[j]
n + 1
5 ε. On the other hand, path P follows
P+ to node s0 of Na
n , then uses arc e, and finally follows P− to t. The cost of this path is exactly j.
If a[j]
n  0, then one of P+, P− is cheaper than P, and the next two iterations augment flow along
paths P+ and P−. Otherwise, if a[j]
n = 0, then P is the shortest path, followed in the next iteration
by the path from s to node t0 of N−a
n along P−, along arc e in the backward direction to node s0 of
Na
n , and finally to t along P+, for a total cost of j + 2
5 ε.
If (s0,t0) carries flow 1, then P+, P− use arc (s0,t0) in a backward direction. By Lemma 3.1, the
cost of P+ is j + a[j]
n − 1
5 ε, while the cost of P− is j − a[j]
n − 1
5 ε. On the other hand, path P follows
P+ to node s0 of Na
n , then uses arc e, and finally follows P− to t. The cost of this path is j − 2
5 ε.
If a[j]
n  0, then one of P+, P− is cheaper than P, and the next two iterations augment flow along
paths P+ and P−. Otherwise, if a[j]
n = 0, then P is the shortest path, followed in the next iteration
by the path from s to node t0 of N−a
n along P−, along arc e in backwards direction to node s0 of Na
n ,
and finally to t along P+, for a total cost of j.
We assume that a single bit of the complete configuration of the Turing machine corresponding
to the Successive Shortest Path Algorithm can be used to distinguish whether arc e carries a flow
of 0 or a flow of 1 during the execution of the algorithm and that the identity of this bit can be
determined in polynomial time. Under this natural assumption, we get the following result, which
implies Theorem 1.4 for the Successive Shortest Path Algorithm.
Corollary 3.3. The Successive Shortest Path Algorithm solves Partition implicitly.
4 SIMPLEX ALGORITHM AND NETWORK SIMPLEX ALGORITHM
In this section, we adapt our construction for the Simplex Algorithm and, in particular, for its interpretation for the minimum-cost flow problem, the Network Simplex Algorithm. In this specialized
version of the Simplex Algorithm, a basic feasible solution is specified by a spanning tree T such
that the flow value on each arc of the network not contained in T is either zero or equal to its capacity. We refer to this tree simply as the basis or the spanning tree. The reduced cost of a residual
non-tree arc e equals the cost of sending one unit of flow in the direction of e around the unique
cycle obtained by adding e to T . For a pair of nodes, the unique path connecting these nodes in
the spanning tree T is referred to as the tree-path between the two nodes. Note that while we set
up the initial basis and flow manually in the constructions of the following sections, determining
the initial feasible flow algorithmically via the algorithm of Edmonds and Karp, ignoring arc costs,
yields the same result. Our construction ensures that all intermediate solutions of the Network
Simplex Algorithm are nondegenerate. Moreover, in every iteration there is a unique non-tree arc
of minimum reduced cost which is used as a pivot element.
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.                      
The Simplex Algorithm Is NP-Mighty 5:11
Fig. 4. Recursive definition of the counting gadget Sv,r
i for the Network Simplex Algorithm, v ∈ {a, −a},
and a parameter r ∈ (2A, 1 − 2A), r  1/2. The capacities of the arcs of Sa,r
i \ Sa,r
i−1 are xi + 1 = 3 · 2i−1. If we
guarantee that there always exists a tree-path from ti to si with sufficiently negative cost outside of the
gadget, the cost of iteration 3k, k = 0,..., 2i − 1, within the gadget is k +v[k]
i . Bold arcs are in the initial
basis and carry a flow of at least 1 throughout the execution.
4.1 A Counting Gadget for the Network Simplex Algorithm
We design a counting gadget for the Network Simplex Algorithm (Figure 4), similar to the gadget Nv
i of Section 3.1 for the Successive Shortest Path Algorithm. Since the Network Simplex
Algorithm augments flow along cycles obtained by adding one arc to the current spanning tree,
we assume that the tree always contains an external tree-path from the sink of the gadget to its
source with a very low (negative) cost. This assumption will be justified in Section 4.2, when we
embed the counting gadget into a larger network.
The main challenge when adapting the gadget Nv
i is that the spanning trees in consecutive iterations of the Network Simplex Algorithm differ in one arc only, since in each iteration a single
arc may enter the basis. However, successive shortest paths in Nv
i differ by exactly two tree-arcs
between consecutive iterations. We obtain a new gadget Sv
i from Nv
i by modifying arc capacities
in such a way that we get two intermediate iterations between every consecutive pair of successive shortest paths in Nv
i . These iterations serve as a transition between the two paths and their
corresponding spanning trees. Recall that in Nv
i the capacities of the arcs of Nv
i \ Nv
i−1 are exactly
the same as the capacity of the subnetwork Nv
i−1. In Sv
i , we increase the capacity of the additional
arcs by one unit relative to the capacity of Sv
i−1. The resulting capacities of the arcs in Sv
i \ Sv
i−1 are
xi (for the moment), where xi = 2xi−1 + 1 and x1 = 2 (i.e., xi = 3 · 2i−1 − 1).
Similar to before, after 2xi−1 iterations, the subnetwork Sv
i−1 is saturated. In contrast, however,
at this point the arcs (si,si−1), (ti−1,ti ) are not saturated yet. Instead, in the next two iterations,
the arcs (si,ti−1), (si−1,ti ) enter the basis and one unit of flow gets sent via the pathssi,si−1,ti and
si,ti−1,ti , which saturates the arcs (si,si−1), (ti−1,ti ) and eliminates them from the basis. Afterward,
in the next 2xi−1 iterations, flow is sent via (si,ti−1), (si−1,ti ) and through Sv
i−1 as before (see
Figure 5 for an example execution of the Network Simplex Algorithm on Sv
2 ).
For the construction to work, we need that, in every nonintermediate iteration, arc (s0,t0) not
only enters the basis but, more importantly, is also the unique arc to leave the basis. In other words,
we want to ensure that no other arc becomes tight in these iterations. For this purpose, we add
an initial flow of 1 along the paths si,si−1,...,s0 and t0,t1,...,ti by adding supply 1 to si , t0 and
demand 1 to s0, ti and increasing the capacities of the affected arcs by 1 (Figure 6). Note that the
path used by the initial flow has lowest cost for a flow of 1. The arcs of the two paths are the only
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.                         
5:12 Y. Disser and M. Skutella
Fig. 5. Illustration of the iterations performed by the Network Simplex Algorithm on the counting gadget
Sa,r
2 for r < 1/2. The external tree-path from t2 to s2 is not shown. Bold arcs are in the basis before each
iteration, the red arc enters the basis, and the dashed arc exits the basis. Arcs are oriented in the direction
in which they are used next. Note that after 2x2 = 3 · 22 − 2 = 10 iterations, the configuration is the same as
in the beginning if we switch the roles of s2 and t2.
arcs from the gadget that are contained in the initial spanning tree. We also increase the capacities
of the arcs (si,ti−1), (si−1,ti ) by one to ensure that these arcs are never saturated.
Finally, we also make sure that, in every iteration, the arc entering the basis is unique. To achieve
this, we introduce a parameter r ∈ (2A, 1 − 2A), r  1/2 and replace the costs of 2i−1 − 1
2 − 1
2vi of
the arcs (si,ti−1), (si−1,ti ) by new costs 2i−1 − r − 1
2vi and 2i−1 − (1 − r) − 1
2vi , respectively.
We later use the final gadget Sv,r n as part of a larger network G by connecting the nodes sn,tn
to nodes in G \ Sv,r n . The following lemma establishes the crucial properties of the gadget used in
such a way as a part of a larger network G.
Lemma 4.1. Let Sv,r
i , v ∈ {a, −a}, be part of a larger network G and assume that, before every
iteration of the Network Simplex Algorithm on G where flow is routed through Sv,r
i there is a treepath from ti to si in the residual network of G that has cost smaller than −2i+1 and capacity greater
than 1. Then, there are exactly 2xi = 3 · 2i − 2 iterations in which one unit of flow is routed from si
to ti along arcs of Sv,r
i . Moreover:
(1) In iteration j = 3k, k = 0,..., 2i − 1, arc (s0,t0) enters the basis carrying flow k mod 2 and
immediately exits the basis again carrying flow (k + 1) mod 2. The cost incurred by arcs of
Sv,r
i is k +v[k]
i .
(2) In iterations j = 3k + 1, 3k + 2, k = 0,..., 2i − 2, for some 0 ≤ i ≤ i, the cost incurred by
arcs of Sv,r
i is k + r +v[k]
i
,i and k + (1 − r) +v[k]
i
,i in order of increasing cost. One of the arcs
(si,si−1), (si−1,ti ) and one of the arcs (si,ti−1), (ti−1,ti ) each enter and leave the basis in
these iterations.
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.                          
The Simplex Algorithm Is NP-Mighty 5:13
Fig. 6. Illustration of the initial flow in the network Sv,r
4 . Thick arcs initially carry a single unit of flow. The
indicated, directed s4-t4-cut (dashed) has capacity 2x4 + 2, which corresponds to a residual capacity of 2x4
when taking into account the initial flow.
Proof. First observe that throughout the execution of the Network Simplex Algorithm on G,
one unit of flow must always be routed along both of the pathssi,si−1,...,s0 and t0,t1,...,ti . This
is because there is an initial flow of one along these paths, all of s0,...,sn−1 have in-degree 1, and
all of t0,...,tn−1 have out-degree 1, which means that the flow cannot be rerouted.
We prove the lemma by induction on i > 0, together with the additional property, that, after
2xi iterations, the arcs in Sv,r
i−1 carry their initial flow values, while the arcs in Sv,r
i \ Sv,r
i−1 all carry
xi additional units of flow (which implies that (si,si−1) and (ti−1,ti ) are saturated). Also, the configuration of the basis is identical to the initial configuration, except that the membership in the
basis of arcs in Sv,r
i \ Sv,r
i−1 is inverted. In the following, we assume that r ∈ (2A, 1/2), which means
that the arc (si−1,ti ) is always selected to enter the basis before the arc (si,ti−1) : the case where
r ∈ (1/2, 1 − 2A) is analogous. In each iteration j, let Pj denote the tree-path outside of Sv,r
i from
ti to si of cost cj < −2i+1 and capacity greater than 1.
Fori = 1, the Network Simplex Algorithm performs the following four iterations involving Sv,r
1
(see Figure 2 for an illustration embedded in Sv,r
2 ). In the first iteration, (s0,t0) enters the basis and
one unit of flow is routed along the cycle s1,s0,t0,t1, P0 of cost v1 + c0 = v[0]
1 + c0. This saturates
arc (s0,t0), which is the unique arc to become tight (since P0 has capacity greater than 1) and thus
exits the basis again. In the second iteration, (s0,t1) enters the basis and one unit of flow is routed
along the cycle s1,s0,t1, P1 of cost r + c1 = r +v[0]
1,1 + c1, thus saturating (together with the initial
flow of 1) arc (s0,s1) of capacity x1 + 1 = 3. Since P1 has capacity greater than 1, this is the only arc
to become tight and it thus exits the basis. In the third iteration, (s1,t0) enters the basis and one
unit of flow is routed along the cycle s1,t0,t1, P2 of cost (1 − r) + c2 = (1 − r) +v[0]
1,1 + c2. Similar
to before, (t0,t1) is the only arc to become tight and thus exits the basis. In the fourth and final
iteration, (s0,t0) enters the basis and one unit of flow is routed along the cycle s1,t0,s0,t1, P3 of
cost 1 −v1 + c3 = v[1]
1 + c3, which causes (s0,t0) to become empty and leave the basis. Thus, after
four iterations, arc (s0,t0) in Sv,r
0 carries its initial flow of value 0, while the arcs in Sv,r
1 \ Sv,r
0 all
carry 2 = x1 additional units of flow. Also, the arcs (s0,t1), (s1,t0) replaced the arcs (s1,s0), (t0,t1)
in the basis.
To see, for i > 0, that Sv,r
i is saturated after 2xi units of flow have been routed from si to ti ,
consider the directed si-ti-cut induced by {si,ti−1,ti−2,...,t0} in the initial residual graph Sv,r
i .
This cut consists of the arcs (si,si−1), (ti−1,ti ). The capacity of the cut is exactly 2xi + 2 and the
initial flow over the cut is 2 (Figure 6).
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.                  
5:14 Y. Disser and M. Skutella
Now assume our claim holds for Sv,r
i−1 and Sv,1−r
i−1 and consider Sv,r
i . Consider the first 2xi−1
iterations j = 0,..., 2xi−1 − 1 and set k := j/3 < 2i−1. It can be seen inductively that the shortest
path from ti−1 to si−1 in the bidirected network associated with Sv,r
i−1 has cost at least −2i−1 + 1 −
A > −2i−1 + 1 − r. Hence, every path from si to ti using either or both of the arcs (si,ti−1) or
(si−1,ti ) has cost greater than 2i−1 − (1 − r) − A > 2i−1 − 1 + A. By induction, we can thus infer
that none of these arcs enters the basis in iterations j < 2xi−1, and instead an arc of Sv,r
i−1 enters
(and exits) the basis and one unit of flow gets routed from si to ti via the arcs (si,si−1), (ti−1,ti ). We
may use induction here since, before iteration j, the path ti−1,ti, Pj ,si,si−1 has cost vi + cj < vi −
2i+1 < −2i and its capacity is greater than 1, since both (si,si−1), (ti−1,ti ) have capacity xi + 1 =
2xi−1 + 2, leaving one unit of spare capacity even after a flow of 2xi−1 has been routed along them
in addition to the initial unit of flow. The additional cost contributed by arcs (si,si−1), (ti−1,ti )
is vi , which is in accordance with our claim since v[k]
,i−1 +vi = v[k]
,i for all  ∈ {0,...,i − 1} and
k ∈ {0,..., 2i−1 − 1}.
Because Sv,r
i−1 is fully saturated after 2xi−1 iterations, in the next iteration j = 2xi−1 = 3 · 2i−1 − 2,
k := j/3 = 2i−1 − 1, arc (si−1,ti ) is added to the basis and one unit of flow is sent along the path
si,si−1,ti , thus saturating the capacity xi + 1 = 2xi−1 + 2 of arc (si,si−1) and incurring a cost of
2i−1 − (1 − r) = k + r +v[k]
i,i . Note that this cost is higher than the cost of each of the previous
iterations. The saturated arc has to exit the basis since, by assumption, Pj has capacity greater
than 1. Similarly, in the following iteration j = 2xi−1 + 1 = 3 · 2i−1 − 1, k := j/3 = 2i−1 − 1, the
cost is 2i−1 − r = k + (1 − r) +v[k]
i,i and arc (ti−1,ti ) is replaced by (si,ti−1) in the basis.
By induction, at this point (si−2,ti−1) and (si−1,ti−2) are in the basis, the arcs of Sv,r
i−1 \ Sv,r
i−2 carry a
flow of xi−1 in addition to their initial flow, and Sv,r
i−2 is back to its initial configuration. To be able to
apply induction on the residual network of Sv,r
i−1 , we shift the costs of the arcs at si−1 by −(2i−2 − r)
and the costs of the arcs at ti−1 by −(2i−2 − (1 − r)) in the residual network of Sv,r
i−1 . Since we shift
costs uniformly across cuts, this only affects the costs of paths but not the structural behavior of
the gadget. Specifically, the costs of all paths from ti−1 to si−1 in the residual network are increased
by exactly 2i−1 − 1. If we switch the roles ofsi−1 and ti−1, say s˜i−1 := ti−1 and t˜
i−1 := si−1, we obtain
the residual network of Sv,1−r
i−1 with its initial flow. This allows us to use induction again for the
next 2xi−1 iterations.
To apply the induction hypothesis, we need the tree-path from t˜
i−1 = si−1 to s˜i−1 = ti−1 to
maintain cost smaller than −2i and capacity greater than 1. This is fulfilled since Pj has cost
smaller than −2i+1, which is sufficient even with the additional cost of 2i − 1 −vi incurred by arcs
(si,s˜i−1), (t˜
i−1,ti ). The residual capacity of (ti,t˜
i−1) and (s˜i−1,si ) is xi > 2xi−1 and thus sufficient
as well. By induction for Sv,1−r
i−1 , we may thus conclude that in iterations j = 2xi−1 + 2,..., 2xi − 1,
k := j/3 ≥ 2i−1, one unit of flow is routed via (si,ti−1), Sv,r
i−1, (si−1,ti ). The cost of (si,s˜i−1) and
(t˜
i−1,ti ) together is 2i − 1 −vi . The cost of iteration j
 = j − 2xi−1 − 2, k := j

/3 = k − 2i−1, in
Sv,1−r
i−1 is k + y +v[k
]
,i−1, for y ∈ {0,r, (1 − r)} and  ∈ {0,...,i − 1} chosen according to the different cases of the lemma. Accounting for the shift by 2i−1 − 1 of the cost compared with the residual
network of Sv,r
i−1 , the incurred total cost in Sv,r
i−1 is
(2i
−1 −vi ) + 
k + y +v[k
]
,i−1

− (2i−1 − 1)
= 2i−1 + k + y −vi +v[k
]
,i−1 = k + y +v[k]
,i ,
where we used −vi +v[k
]
,i−1 = v[k
+2i−1]
,i since k < 2i−1. This concludes the proof.
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.                                                  
The Simplex Algorithm Is NP-Mighty 5:15
Fig. 7. Illustration of network Ga
ns. The subnetworks Sa,1/3 n and S−a,1/3 n are advanced independently by the
Network Simplex Algorithm without using the dashed arc e, unless the Partition instance a has a solution.
Bold arcs are in the initial basis and carry a flow of at least 1 throughout the execution of the algorithm.
4.2 The Network Simplex Algorithm Implicitly Solves Partition
We construct a network Ga
ns similar to the network Ga
ssp of Section 3.2. Without loss of generality,
we assume that a1 = 0. The network Ga
ns consists of the two gadgets Sa,1/3 n , S−a,1/3 n , connected to
a new source node s and a new sink t (Figure 7). Let s+
i , t+
i denote the nodes of Sa,1/3 n and s−
i , t−
i
denote the nodes of S−a,1/3 n . We introduce arcs (s,s+
n ), (s,s−
n ), (t+
n ,t), (t−
n ,t), each with capacity ∞
and cost 0. The supply 1 of s+
n and s−
n is moved to s and the initial flow on arcs (s,s+
n ) and (s,s−
n ) is
set to 1. Similarly, the demand 1 of t+
n and t−
n is moved to t and the initial flow on arcs (t+
n ,t) and
(t−
n ,t) is set to 1. Finally, we add an infinite capacity arc (s,t) of cost 2n+1, increase the supply of s
and the demand of t by 4xn, and set the initial flow on (s,t) to 4xn.
In addition, we add two nodes c+, c− and replace the arc (s+
0 ,t+
0 ) by two arcs (s+
0 ,c+), (c+,t+
0 ) of
capacity 2 and cost 0 (for the moment), and analogously for the arc (s−
0 ,t−
0 ) and c−. Finally, we move
the demand of 1 from s+
0 to c+ and the supply of 1 from t−
0 to c−. The arcs (s+
0 ,c+) and (c−,t−
0 ) carry
an initial flow of 1 and are part of the initial basis. Observe that these modifications do not change
the behavior of the gadgets. In addition to the properties of Lemma 4.1, we have that whenever
the arc (s0,t0) previously carried a flow of 1, now (c+,t+
0 ) or (s−
0 ,c−) is in the basis, and, whenever
(s0,t0) previously did not carry flow, now (s+
0 ,c+) or (c−,t−
0 ) is in the basis.
We increase the costs of the arcs (c+,t+
0 ) and (s−
0 ,c−) from 0 to 1
5 ε, again without affecting the
behavior of the gadgets (note that we can perturb all costs in S−a,1/3 n further to ensure that every
pivot step is unique). Finally, we add one more arc e = (c+,c−) with cost 0 and capacity 1
2 .
Lemma 4.2. Arc e enters the basis in some iteration of the Network Simplex Algorithm on network
Ga
ns if and only if the Partition instance a has a solution.
Proof. First observe that a[2k] n = a[2k+1] n for k ∈ 0,..., 2n−1 since, by assumption, a1 = 0.
Similar to the proof of Lemma 3.2, in isolation, each of the two gadgets can be in one of 2xn states
(Lemma 4.1), which we label by the number of iterations needed to reach each state. Assuming that
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.                
5:16 Y. Disser and M. Skutella
both gadgets are in state 12k after some number of iterations, we show that both gadgets will reach
state 12k + 12 together as well. In addition, we show that, in the iterations in-between, arc e enters
the basis if and only if a[4k] n = 0 and thus a[4k+1] n = 0, or a[4k+2] n = 0 and thus a[4k+3] n = 0. Consider
the situation where both gadgets are in state 12k. Note that in this state the arcs in Sv,1/3
1 and
S−v,1/3
1 are back in their original configuration.
Let P± denote the tree-path from t±
1 to s±
1 , and let P±∓ denote the tree-path from t∓
1 to s±
1 . We
refer to these paths as the outer paths. Observe that, since the gadgets are in the same state, the
costs of the outer paths differ by at most A < 1/4. In the next iterations, flow is sent along a cycle
containing one of the outer paths, and we analyze only the part of each cycle without the outer
path. Let P±
0 , P±
1 , P±
2 , P±
3 be the four successive shortest paths within the gadget S±a,1/3
1 . The costs
of these paths are 1
5 ε, 1/3, 2/3, 1 − 1
5 ε, respectively. Note that, since A < 1/6, the costs of the paths
stay in the same relative order within each gadget throughout the algorithm.
If a[4k] n < 0, then P+ is the cheapest of the outer paths by a margin of more than ε/2. Thus, in the
first iteration, (c+,t+
0 ) replaces (s+
0 ,c+) in the basis closing the path P+
0 . In the next five iterations,
the paths P−
0 , P+
1 , P−
1 , P+
2 , P−
2 are closed in this order. The final two iterations are P+
3 , P−
3 , similar
to the first two iterations, as a[4k+1] n = a[4k] n < 0. At this point, 8 iterations have passed and both
gadgets are in state 12k + 6.
If a[4k] n > 0, then P− is the cheapest of the outer paths by a margin of more than ε/2. Thus, the
first iteration closes the path P−
0 . The next five iterations are via P+
0 , P−
1 , P+
1 , P−
2 , P+
2 , in this order.
The final two iterations are P−
3 , P+
3 , similar to the first two iterations, as a[4k+1] n = a[4k] n > 0. At this
point, 8 iterations have passed and both gadgets are in state 12k + 6.
If a[4k] n = 0, then all four outer paths have the same cost. The first iteration is via the path
s+
1 ,s+
0 ,c+,c−,t−
0 ,t−
1 ; that is, arc e enters and leaves the basis for a cost of 0 and an additional flow
of 1/2. The next two iterations are via P±
1 , each for a cost of 1
5 ε and an additional flow of 1/2. The
fourth iteration is via the path s−
1 ,s−
0 ,c−,c+,t+
0 ,t+
1 (i.e., arc e enters and leaves the basis again for a
cost of 2
5 ε and an additional flow of 1/2). The next iterations are as before: via P+
1 , P−
1 , P−
2 , P+
2 , in
this order. The final four iterations are similar to the first four iterations, again twice using e, as
a[4k+1] n = a[4k] n = 0. At this point, 12 iterations have passed and both gadgets are in state 12k + 6.
The next four iterations (two for each gadget) do not involve the subnetworks Sa,1/3
1 and S−a,1/3
1 ,
and do thus not use e. The iterations going from state 12k + 6 to state 12k + 12 are analogous to
the above if we exchange the roles of s±
1 and t±
1 . This concludes the proof.
Again, we assume that a single bit of the complete configuration of the Turing machine corresponding to the Simplex Algorithm can be used to detect whether a variable is in the basis and
that the identity of this bit can be determined in polynomial time. Under this natural assumption,
we get the following result, which implies Theorem 1.4 for the Network Simplex Algorithm and
thus the Simplex Algorithm.
Corollary 4.3. The Network Simplex Algorithm implicitly solves Partition.
5 CONSEQUENCES
We now give proofs for the Corollaries of Section 1.
Corollary 1.5 Determining the number of iterations needed by the Simplex Algorithm, the Network Simplex Algorithm, and the Successive Shortest Path Algorithm for a given input is NP-hard.
Proof. We first show that determining the number of iterations needed by the Successive Shortest Path Algorithm for a given minimum-cost flow instance is NP-hard. We replace the arc e in
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.                   
The Simplex Algorithm Is NP-Mighty 5:17
Ga
ssp of Section 3 by two parallel arcs, each with a capacity of 1/2 and slightly perturbed costs.
This way, every execution of the Successive Shortest Path Algorithm that previously did not use
arc e is unaffected, while executions using e require additional iterations. Thus, by Lemma 3.2, the
Successive Shortest Path Algorithm on network Ga
ssp takes more than 2n+1 iterations if and only if
the Partition instance a has a solution.
The proof for the Network Simplex Algorithm (and thus the Simplex Algorithm) follows from
the proof of Lemma 4.2, observing that the Network Simplex Algorithm takes more than 4xn iterations for network Ga
ns if and only if the Partition instance a has a solution.
Corollary 1.6 Deciding for a given linear program whether a given variable ever enters the basis
during the execution of the Simplex Algorithm is NP-hard.
Proof. The proof is immediate via Lemma 4.2 and the fact that Partition is NP-hard.
Corollary 1.7 Determining whether a parametric minimum-cost flow uses a given arc (i.e., assigns positive flow value for any parameter value) is NP-hard. In particular, determining whether
the solution to a parametric linear program uses a given variable is NP-hard. Also, determining the
number of different basic solutions over all parameter values is NP-hard.
Proof. This follows from the fact that the Successive Shortest Path Algorithm solves a parametric minimum-cost flow problem, together with Lemma 3.2 and Corollary 1.5.
Corollary 1.8 Given a d-dimensional polytope P defined by a system of linear inequalities, determining the number of vertices of P’s projection onto a given 2-dimensional subspace is NP-hard.
Proof. Let P be the polytope of all feasible s-t-flows in network Ga
ssp of Section 3.2. Consider
the 2-dimensional subspace S defined by flow value and cost of a flow. Let P be the projection of
P onto S. The lower envelope of P is the parametric minimum-cost flow curve for Ga
ssp, while the
upper envelope is the parametric maximum-cost flow curve for Ga
ssp.
The s-t-paths of maximum cost inGa
ssp are the four paths via sn,sn−1,tn or via sn,tn−1,tn in both
of the gadgets. Each of these paths has cost 2n−1 − 1
2 , and the total capacity of all paths together
is 2n+1 which is equal to the maximum flow value from s to t. Therefore, the upper envelope of P
consists of a single edge.
The number of edges on the lower envelope of P is equal to the number of different costs among
all successive shortest paths in Ga
ssp. If we slightly perturb the costs of the two arcs in Ga
ssp with
cost 1
5 ε, we can ensure that each successive shortest path has a unique cost. The claim then follows
by Corollary 1.5.
Corollary 1.9 Determining the average arrival time of flow in an earliest arrival flow is NP-hard.
Proof. Consider network Ga
ssp introduced in Section 3.2 and scale all arc costs by a sufficiently
large integer to make them integral. Moreover, let ξ := 1/2n+2 and change the cost of arc e in Ga
ssp
from 0 to ξ. Notice that this modification does not change the sequence of paths chosen by the
Successive Shortest Path Algorithm. Denote the resulting network by Ga
ξ . Jarvis and Ratliff [15]
proved that an earliest arrival flow has minimum average arrival time (and vice versa). We therefore consider in the following the earliest arrival flow on Ga
ξ that can be obtained from the paths
found by the Successive Shortest Path Algorithm (see, e.g., Skutella [27] for details).
As argued in Section 3, the Successive Shortest Path Algorithm takes 2n+1 iterations on network Ga
ξ . In each iteration i = 0,..., 2n+1 − 1, it augments one unit of flow along some path Pi of
ACM Transactions on Algorithms, Vol. 15, No. 1, Article 5. Publication date: November 2018.                        
5:18 Y. Disser and M. Skutella
cost c(Pi ) in the residual network. Notice that c(Pi ) is integral unless it contains arc e. In the latter case, c(Pi ) = z ± ξ for some z ∈ Z≥0. Let k := |{i ∈ {0,..., 2n+1 − 1} : Pi contains e}| such that
0 ≤ k ≤ 2n+1. In particular, k = 0 if and only if the Partition instance a has a solution.
An earliest arrival flow with integral time horizon T > c(P2n+1 ) ≥ c(Pi ) sends flow at rate 1 into
path Pi from time 0 up to time T − c(Pi ), for i = 0,..., 2n+1 − 1. In particular, the total flow sent
along Pi over time isT − c(Pi ). This flow arrives at the sink at rate 1 between time c(Pi ) and timeT ;
its average arrival time is 1
2 (T + c(Pi )). Thus, the overall average arrival time of flow at the sink is
1
F
2n+1 −1
i=0

T − c(Pi )
 1
2

T + c(Pi )

= 1
2F
2n+1 −1
i=0

T 2 − c(Pi )
2

, (1)
where F is the total amount of flow sent into the sink)i.e., the value of a maximum s-t-flow over
time). Since T is integral, it follows from Equation (1) that 2F times the average arrival time is of
the form α ± βξ − kξ 2 with α, β ∈ Z≥0. Since 0 ≤ k ≤ 2n+1 and ξ = 1/2n+2 divides α, this value is
a multiple of ξ if and only if k = 0; that is, if and only if the Partition instance a has a solution.
Since the maximum value F of an s-t-flow over time can be computed in polynomial time [10],
we can decide Partition by observing the minimum average arrival time of a maximum s-t-flow
over time in Ga
ξ .
6 CONCLUSION
We have introduced the concept of NP-mightiness as a novel means of classifying the computational
power of algorithms. Furthermore, we have given a justification for the exponential worst-case behavior of Successive Shortest Path Algorithm and the (Network) Simplex Method (with Dantzig’s
pivot rule): These algorithms can implicitly solve any problem in NP.
We hope that our approach will turn out to be useful in developing a better understanding
of other algorithms that suffer from poor worst-case behavior. In particular, we believe that our
results can be carried over to the Simplex Method with other pivot rules. Furthermore, even
polynomial-time algorithms with a superoptimal worst-case running time are an interesting subject. Such algorithms might implicitly solve problems that are presumably more difficult than the
problem they were designed for. In order to achieve meaningful results in this context, our definition of “implicitly solving” (Definition 1.1) would need to be modified by further restricting the
running time of the transformation of instances.
Note that the decision problems underlying Corollaries 1.5 through 1.9 do not seem to lie in NP.
For Corollary 1.6, Fearnley and Savani [8] have already shown PSPACE-hardness, and similar results may hold for the other problems. Determining the exact complexity of these problems remains an open question. Similarly, it would be interesting to investigate whether the Successive
Shortest Path Algorithm is PSPACE-mighty    