The Gromov-Hausdorff (GH) distance is a natural way to measure distance between two metric spaces. We
prove that it is NP-hard to approximate the GH distance better than a factor of 3 for geodesic metrics on
a pair of trees. We complement this result by providing a polynomial time O(min{n,
√
rn})-approximation
algorithm for computing the GH distance between a pair of metric trees, where r is the ratio of the longest
edge length in both trees to the shortest edge length. For metric trees with unit length edges, this yields an
O(
√
n)-approximation algorithm.1
CCS Concepts: • Theory of computation → Computational geometry; Problems, reductions and
completeness;
Additional Key Words and Phrases: Metric spaces, embeddings
1 INTRODUCTION
The Gromov-Hausdorff distance (or GH distance for brevity) [11] is one of the most natural distance measures between metric spaces, and has been used, for example, for matching deformable
shapes [4, 16], and for analyzing hierarchical clustering trees [6]. Informally, the GH distance
measures the additive distortion suffered when mapping one metric space to another using a correspondence
between their points. Even when working with spaces of equal size, correspondences
such as those computed for GH distance are often preferable to, say, bijections, because the distance is less sensitive to slight stretching or the exact choice of points sampled from a larger space
(see Figure 1). Multiple approaches have been proposed to estimate the GH distance [4, 15, 16].
Despite much effort, the problem of computing, either exactly or approximately, GH distance
has remained elusive. The problem is not known to be NP-hard, and computing the GH distance,
even approximately, for graphic metrics2 is at least as hard as the graph isomorphism problem.
Indeed, the metrics for two graphs have GH distance 0 if and only if the two graphs are isomorphic.
Motivated by this trivial hardness result, it is natural to ask whether GH distance becomes easier in
more restrictive settings such as geodesic metrics over trees, where efficient algorithms are known
for checking isomorphism [2].
Related work. Most work on associating points between two metric spaces involves embedding
a given high-dimensional metric space into an infinite host space of lower-dimensional metric
spaces. However, there is some work on finding a bijection between points in two given finite
metric spaces that minimizes typically multiplicative distortion of distances between points and
their images, with some limited results on additive distortion.
Kenyon et al. [14] give an optimal algorithm for minimizing the multiplicative distortion of
a bijection between two equal-sized finite metric spaces, and a parameterized polynomia-time
algorithm that finds the optimal bijection between an arbitrary unweighted graph metric and a
bounded-degree tree metric.
Papadimitriou and Safra [18] show that it is NP-hard to approximate the multiplicative distortion
of any bijection between two finite three-dimensional point sets to within any additive constant
or to a factor better than 3.
Hall and Papadimitriou [12] discuss the additive distortion problem—given two equal-sized point
sets S,T ⊂ Rd , find the smallest Δ such that there exists a bijection f : S → T such that d(x,y) −
Δ ≤ d(f (x), f (y)) ≤ d(x,y) + Δ. They show that it is NP-hard to approximate by a factor better
than 3 in R3, and also give a 2-approximation for R1 and a 5-approximation for the more general
problem of embedding an arbitrary metric space onto R1. However, their setting differs from ours
in two major ways: firstly, they consider finite metric spaces of equal size, whereas in this article
the metric spaces may be uncountably infinite; secondly, they consider bijections between metric
spaces, whereas in our work we deal with correspondences between metric spaces which are more
general than bijections. In particular, an optimal correspondence between arbitrary spaces of equal
size may not be a bijection (see Figure 1), so these hardness results do not apply to GH distance.
Thus, their approach cannot be easily extended to our setting.
2A graphic metric measures the shortest path distance between vertices of a graph with unit length edges.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.
Computing the Gromov-Hausdorff Distance for Metric Trees 24:3
The interleaving distance between merge trees [17] was proposed as a measure to compare
functions over topological domains that is stable to small perturbations in a function. Distances
for the more general Reeb graphs are given in [3, 7]. These concepts are related to the GH distance
(Section 4), which we will leverage to design an approximation algorithm for the GH distance for
metric trees.
Our results. In this article, we give the first non-trivial results on approximating the GH distance
between metric trees. First, we prove (in Section 3) that the problem remains NP-hard even for
metric trees via a reduction from 3-Partition. In fact, we show that there exists no efficient algorithm with approximation ratio less than 3 unless P = NP. As noted above, we are not aware of
any result that shows the GH distance problem being NP-hard even for general graphic metrics.
To complement our hardness result, we give an O(
√
n)-approximation algorithm for the GH
distance between metric trees with n nodes and unit length edges. Our algorithm works with arbitrary edge lengths as well; however, the approximation ratio becomes O(min{n,
√
rn}) where r
is the ratio of the longest edge length in both trees to the shortest edge length. Even achieving the
O(n)-approximation ratio presented here for arbitrary r is a non-trivial task, and we hope this first
non-trivial approximation result will stimulate further research on this and similar problems.
Our algorithm uses a reduction, described in Section 4, to the similar problem of computing the
interleaving distance [17] between two merge trees. Given a function f : X → R over a topological
space X, the merge treeTf describes the connectivity between components of the sublevel sets of f
(see Section 2 for a more formal definition). Morozov et al. [17] proposed the interleaving distance
as a way to compare merge trees and their associated functions.3 For us, interleaving distance provides a convenient way to measure distance after rooting the input trees so that correspondences
are more nicely structured. We describe, in Section 5, anO(min{n,
√
rn})-approximation algorithm
for interleaving distance between merge trees, and our reduction provides a similar approximation
for computing the GH distance between two metric trees.
Note on independent work. After writing preliminary versions of the current report, we became
aware of recent work by Schmiedl [19] in which he proves a lower bound of 3 for the approximation ratio of any polynomial-time approximation for GH distance in metric trees. As in our proof,
his ultimately comes down to a reduction from 3-Partition. He also gives an approximation algorithm for arbitrary metrics, but the running time is not guaranteed to be polynomial in the size
of the input.
2 PRELIMINARIES
Metric Spaces and the Gromov-Hausdorff Distance. A metric space X = (X, ρ) consists of a
(potentially infinite) setX and a function ρ : X × X → R≥0 such that the following hold: ρ(x,y) = 0
iff x = y; ρ(x,y) = ρ(y, x); and ρ(x, z) ≤ ρ(x,y) + ρ(y, z).
Given sets A and B, a correspondence between A and B is a set C ⊆ A × B such that (i) for all
a ∈ A, there exists b ∈ B such that (a,b) ∈ C; and (ii) for all b ∈ B, there exists a ∈ A such that
(a,b) ∈ C. We use Π(A, B) to denote the set of all correspondences between A and B.
Let X1 = (X1, ρ1) and X2 = (X2, ρ2) be two metric spaces. The distortion of a correspondence
C ∈ Π(X1,X2) is defined as
Dist(C) = sup
(x,y),(x	
,y	)∈C
|ρ1 (x, x 	
) − ρ2 (y,y	
)|.
3In fact, our hardness result can be easily extended to the GH distance between graphic metrics for trees and the interleaving
distance between merge trees.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.
24:4 P. K. Agarwal et al.
Fig. 2. Merge tree Mf (shown in red) for a function f : X → R, where X = R. epi f is shown in gray, and
¯f −1 (a) is the gray region below the blue horizontal lines in epi f .
The GH distance [15], dGH , between X1 and X2 is defined as
dGH (X1, X2) = 1
2
inf
C ∈Π(X1,X2 )
Dist(C).
Intuitively, dGH measures how close can we can get to an isometric (distance-preserving) embedding between two metric spaces. We note that there are different equivalent definitions of the
GH distance (see, e.g, Theorem 7.3.25 of [5] and Remark 1 of [15]).
A tree T = (V, E) consists of a set of nodes V and edges E connecting pairs of nodes such that
some geometric realization ofT is simply connected. Note our definition allows for nodes of degree
2. The leaves of T are the nodes of degree 1, and its branching nodes are the nodes of degree 3 or
higher.
Given a treeT = (V, E) and a length functionl : E → R≥0, we associate a metric space T = (T,d)
with T as follows. T is a geometric realization of T . For x,y ∈ T, define d(x,y) to be the length of
the unique shortest path π (x,y) ∈ T. It is clear that d is a metric. The metric space thus obtained
is a metric tree. We often do not distinguish between T and T and write T = (T,d).
Merge Trees and the Interleaving Distance. Let f : X → R be a continuous function from
a connected topological space X to the set of real numbers. The sublevel set at a value a ∈ R is
defined as f≤a = {x ∈ X | f (x) ≤ a}. A merge tree Mf captures the evolution of the topology of
the sublevel sets as the function value is increased continuously from −∞ to +∞. Formally, it
is obtained as follows. Let epi f = {(x,y) ∈ X × R | y ≥ f (x)}. Let ¯f : epi f → R be such that ¯f ((x,y)) = y. We may say ¯f ((x,y)) is the height of point (x,y) ∈ X × R. For two points (x,y)
and (x 	
,y	
) in X × R with y = y	
, let (x,y) ∼ (x 	
,y	
) denote them lying in the same component
of ¯f −1 (y)(= ¯f −1 (y	
)). Then ∼ is an equivalence relation, and the merge tree Mf is defined as the
quotient space (X × R)/ ∼.
The sublevel sets fa of f merge as function value a increases, so we get a rooted tree where
branching nodes represent the moments where two components merge and leaves represent the
birth of a new component at a local minimum. Figure 2 shows an example of a merge tree for a
one-dimensional function. Note that the merge tree extends to a height of ∞. Our assumption that
X is connected implies we have only one component in f≤N for some sufficiently large N > 0, and
Mf is, in fact, a single tree.
We define the root of merge tree Mf to be the node with the highest function value. The ancestors
of a point x ∈ Mf are the points lying on the unique path from x to the root of Mf as well as all
points with greater height than the root. We define the length of any edge in a merge tree (other
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.
Computing the Gromov-Hausdorff Distance for Metric Trees 24:5
Fig. 3. Part of trees Mf and Mд showing α and β.
than the edge to infinity) to be the height difference between its two endpoints. Ancestors of points
in Mд are defined similarly.
Since each point x ∈ Mf represents a component of a sublevel set at a certain height, we can
associate this height value with x, denoted by ˆ
f (x). Given a merge tree Mf and ε ≥ 0, an ε-shift
map σε
f : Mf → Mf is the map that maps a point x ∈ Mf to its ancestor at height ˆ
f (x) + ε, that is,
ˆ
f (σε
f (x)) = ˆ
f (x) + ε. Given ε ≥ 0 and merge trees Mf and Mд, two continuous maps α : Mf → Mд
and β : Mд → Mf are said to be ε-compatible if they satisfy the following conditions :
дˆ(α (x)) = ˆ
f (x) + ε,∀x ∈ Mf ; ˆ
f (β (y)) = дˆ(y) + ε,∀y ∈ Mд;
β ◦ α = σ2ε
f ; α ◦ β = σ2ε
д . (1)
See Figure 3 for an example. The interleaving distance [17] is then defined as
dI (Mf , Mд ) = inf{ε ≥ 0 | there exist ε-compatible maps α and β}.
Remark. We can relax the requirements on α and β from their normal definitions as follows.
(i) Instead of requiring exact value changes, we require
ˆ
f (x) ≤ дˆ(α (x)) ≤ ˆ
f (x) + ε,∀x ∈ Mf ; дˆ(y) ≤ ˆ
f (β (y)) ≤ дˆ(y) + ε,∀y ∈ Mд .
(ii) If x1 is an ancestor of x2 in Mf , then α (x1) is an ancestor of α (x2) in Mд. A similar rule
applies for β.
(iii) β (α (x)) must must be mapped to an ancestor of x and α (β (y)) must be mapped to an ancestor of y.
Any pair of maps satisfying the original requirements also satisfies the relaxed requirements for
the same value of ε. Conversely, for any pair of maps satisfying the relaxed requirements, we can
stretch up the images for each map by instead mapping to the ancestors of the appropriate height of
the original images, without changing the value ofε. Thus, both definitions of interleaving distance
are equivalent. For convenience, when two ε-compatible maps are given to us we assume that
they satisfy Equation (1), but we construct ε-compatible maps that satisfy the relaxed conditions
mentioned, knowing that they can be “stretched” as just described to satisfy Equation (1).
If we know α (x) for a point x at height h, then we can compute α (y) for any ancestor y of x at
height h	 ≥ h by simply putting α (y) = σh	
−h
f (α (x)). A similar claim holds for β. Thus, specifying
the maps for the leaves of the trees suffices, because any point in the tree is the ancestor of at least
one of the leaves. Hence, these maps have a representation that requires linear space in the size of
the trees.
Morozov et al. [17] prove several facts about interleaving distance that will prove useful in this
work. In particular, interleaving distance is a metric [17, Lemma 1]. Further, it is a stable distance
measure with respect to small function perturbations; specifically, given two functions f : X → R
and д : X → R, we have dI (Mf , Mд ) ≤  f − д∞ [17, Theorem 2].
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.
24:6 P. K. Agarwal et al.
3 HARDNESS OF APPROXIMATION
We now show the hardness of approximating the GH distance by a reduction from the following
decision problem called balanced partition (or BAL-PART for brevity): given a multiset of positive
integers X = {a1,..., an }, and an integer m such that 1 ≤ m ≤ n, is it possible to partition X into
m multisets {X1,...,Xm } such that all the elements in each multiset sum to the same quantity
μ = (
n
i=1 ai )/m? We prove below that BAL-PART is strongly NP-complete, that is, it remains NPcomplete even if ai ≤ nc for some constant c ≥ 1 for all 1 ≤ i ≤ n.
Lemma 3.1. BAL-PART is strongly NP-complete.
Proof. We reduce 3-Partition, a strongly NP-complete problem [10] to BAL-PART. Given a
multiset of positive integers Y = {a1,..., an } with n = 3m, 3-Partition asks to partition Y into m
multisets {Y1,...,Ym } of size 3 each so that the elements in each multiset sum to the same quantity.
Given a 3-Partition instance, we construct an instance of BAL-PART as follows.
Basically, we add a sufficiently large number to each ai so that if two multisets of the new
numbers have the same sum, they have the same number of elements. In particular, let a¯ = n
i=1 ai .
Then set a	
i = ai + a¯ and X = {a	
1,..., a	
n }. This reduction takes polynomial time, and the new
numbers are polynomially larger than the original ones. We show that there exists an appropriate
partition of Y iff there exists an appropriate partition of X.
Suppose there exists an appropriate partition {Y1,...,Ym } of Y. Then setting Xi = {a	
j | aj ∈ Yi}
for i = 1,...,m gives us the desired partition of X.
Conversely, suppose there exists an appropriate partition {X1,...,Xm } of X. Suppose |Xi | =
n1 > |Xj | = n2 for some i  j. We thus have

a	
k ∈Xi
ak + n1a¯ =

a	
k ∈Xj
ak + n2a¯ ⇒ (n1 − n2)a¯ =

a	
k ∈Xj
ak −

a	
k ∈Xi
ak ⇒

a	
k ∈Xj
ak −

a	
k ∈Xi
ak ≥ a¯,
(2)
a contradiction since
a	
k ∈Xj ak < a¯. Thus, each partition Xi is of equal size. Since n = 3m, the size
of each Xi is 3.
We now reduce an instance of BAL-PART, in which each ai ≤ nc for some constant c ≥ 1, to
GH-distance computation. Consider an instance X = {a1,..., an } and 1 ≤ m ≤ n of BAL-PART. If
m = 1, then a balanced partition into one multiset trivially exists. If m > 1, we construct two trees
T1 andT2 as follows. Let λ > 8 and ρ < λ − 6 be two positive constants. LetTl,k denote a star graph
having k edges, each of length l. T1 has a node r1 incident to an edge (r1,r	
1) of length ρ and to n
edges {(r1,p1),..., (r1,pn )} of length 1. Each node pi is incident to another edge (pi,p	
i ) of length 1,
and each p	
i is the center of a copy of Tλ,ai . T2 consists of a node r2 incident to an edge (r2,r	
2) of
length ρ and to m edges {(r2,q1),..., (r2,qm )} of length 2, where each qi is the center of a distinct
copy of Tλ+1,a¯, and a¯ = (
n
i=1 ai )/m. See Figure 4 for an illustration. We refer to the edges of each
Tλ,ai in T1 and the edges of copies of Tλ+1,a¯ in T2 as bottom edges. Let T1 and T2 denote the metric
trees associated with T1 and T2, respectively. Since λ, ρ are constants and ai ≤ nc for all 1 ≤ i ≤ n,
this construction can be done in polynomial time.
Lemma 3.2. If (X,m) is a yes instance of BAL-PART, then dGH (T1, T2) ≤ 1. Otherwise,
dGH (T1, T2) ≥ 3.
Proof. Suppose X can be partitioned into m subsets X1,...,Xm of equal weight a¯ =
(
n
i=1 ai )/m. We construct a correspondence C between T1 and T2 with distortion at most 2, implying that dGH (T1, T2) ≤ 1. A linearly interpolated bijection between the points of edges (r1,r	
1) and
(r2,r	
2), withr1 mapping to r2 and r	
1 mapping to r	
2, is added to C. If ai ∈ Xj , the linearly interpolated
bijection between edges (r1,pi ) and (r2,qj) is added to C, with pi mapping to qj . Also, using linear
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.             
Computing the Gromov-Hausdorff Distance for Metric Trees 24:7
Fig. 4. The trees Tl,k , T1, and T2.
interpolation, we map the path frompi to each leaf ofTλ,ai to distinct edges going from qj to leaves
of its copy ofTλ+1,a¯; this is possible sinceTλ+1,a¯ has a¯leaves, and
a ∈Xj a = a¯. Note that each edge
(pi,p	
i ) may be mapped to a contiguous part of multiple edges in T2. Overall, the distortion induced
by C is at most 2; this stems from the fact that C is piecewise linear, and the difference between the
length of any node-to-node path in one tree and its image under C in the other tree is at most 2.
Suppose dGH (T1, T2) < 3, and let C be a correspondence between T1 and T2 with distortion < 6.
Consider two leavesl1,l2  r	
2 in T2. Then d(l1,l2) ≥ 2λ + 2. Letl	
1,l	
2 be their corresponding images
in T1 under C. We argue that l	
1,l	
2 lie on distinct bottom edges of T1. Indeed, since Dist(C) < 6, the
distance between l	
1 and l	
2 is d(l	
1,l	
2) > d(l1,l2) − 6 ≥ 2λ − 4. If l	
1,l	
2 lie on the same edge of T1, then
d(l	
1,l	
2) ≤ λ < 2λ − 4, so they have to lie on distinct edges of T1. If either of l	
1,l	
2 lies on an edge
r1pi , for some i ≤ n, then by construction, d(l	
1,l	
2) ≤ λ + 4 < 2λ − 4 (recall that λ > 8). Finally, if
either of l	
1,l	
2 lies on (r1,r	
1), then by the choice of ρ, d(l	
1,l	
2) ≤ ρ + λ + 2 < 2λ − 4. Thus, both l	
1
and l	
2 lie on distinct bottom edges of T1. In particular, the corresponding image l	
1 in T1 of any one
leaf l1 in T2 must lie on a bottom edge of T1, because there exists some other leaf l2 in T2 by the
assumption that m > 1. Hence, C induces a bijection χ between the leaves of T1 and T2, where
χ (l) = l	 for l ∈ T2 and l	 ∈ T1 is the leaf whose incident edge contains the image(s) of l under C.
Note that if li,lj ∈ T2 are incident to qi,qj with qi  qj , then χ (li ) and χ (lj) are incident to pi	,pj	
with pi	  pj	; otherwise d(li,lj) = 2λ + 6 and d(χ (li ), χ (lj)) ≤ 2λ, thereby incurring a distortion
of at least 6. Hence, the bijection χ can be used to partition X into m subsets X1,...,Xm of equal
weight as follows: if χ (l) = l	 for l incident to qi and l	 incident to pj , then aj ∈ Xi . Thus, (X,m)
is a yes instance of BAL-PART.
We may also apply the reduction to metric trees with unit edge lengths by subdividing longer
edges with an appropriate number of vertices. We thus have the following theorem.
Theorem 3.3. Unless P = NP, there is no polynomial-time algorithm to approximate the GH distance between two metric trees to a factor better than 3, even in the case of metric trees with unit edge
lengths.
4 GH AND INTERLEAVING DISTANCES
In this section, we show that the GH distance between two tree metric spaces T1 and T2, and
the interleaving distance between two appropriately defined trees induced by the Ti ’s are within
constant factors of each other.
Given a metric tree T = (T,d), let V (T ) denote the nodes of the tree. Given a point s ∈ T (not
necessarily a node), let fs : T → R be defined as fs (x) = − d(s, x). Equipped with this function, we
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.     
24:8 P. K. Agarwal et al.
obtain a merge tree Ts from T . Intuitively, Ts has the structure of rooting T at s, and then adding
an extra edge incident to s with function value extending from 0 to +∞. If s is an internal node of
T or an interior point of an edge of T , s remains the root of Ts . But if s is a leaf of T , then s gets
merged with the infinite edge and the node of T adjacent to s becomes the root of Ts .
Let T1 = (T1,d1) and T2 = (T2,d2) be two metric trees. Define
Δ = min u ∈V (T1 ),v ∈V (T2 )
dI (T u
1 ,T v
2 ). (3)
We prove that Δ is within a constant factor of dGH (T1, T2). We first prove a lower bound on Δ.
Lemma 4.1. 1
2dGH (T1, T2) ≤ Δ.
Proof. Suppose Δ = dI (Ts
1 ,Tt
2 ) for some s ∈ V (T1) and t ∈ V (T2). Set f := fs and д := ft . Let
α : Ts
1 → Tt
2 , β : Tt
2 → Ts
1 be Δ-compatible maps. We define the functions α∗ : Ts
1 → Tt
2 and β∗ :
Tt
2 → Ts
1 as follows:
α∗ (x) =

α (x) if д(α (x)) ≤ 0.
t otherwise. β∗ (y) =

β (y) if f (β (y)) ≤ 0.
s otherwise.
That is, if α (x) (β (y), respectively) is an ancestor of t (s, respectively), then x (y, respectively) is
mapped to the root t (s, respectively). We note that
f (x) ≤ д(α∗ (x)) ≤ f (x) + Δ,
д(y) ≤ f (β∗ (y)) ≤ д(y) + Δ. (4)
Indeed, if α∗ (x) = α (x), then д(α∗ (x)) = f (x) + Δ. Otherwise, д(α (x)) > 0 and д(α∗ (x)) = 0. Since
f (x) ≤ 0, we obtain д(α∗ (x)) < д(α (x)) = f (x) + Δ. The same argument implies the second set of
inequalities.
Consider the correspondence C ∈ T1 ×T2 induced by α∗ and β∗ defined as
C := {(x, α∗ (x)) | x ∈ T1}∪{(β∗ (y),y) | y ∈ T2}.
We prove that Dist(C) ≤ 4Δ.
Indeed, consider any two pairs (x1,y1), (x2,y2) ∈ C. Let u be the least common ancestor of x1
and x2 in T1 (if T1 is rooted at s), and w the least common ancestor of y1 and y2 in T2 (if T2 is
rooted at t). Note that since T1 and T2 are trees, there is a unique path x1  u  x2 between x1
and x2, such that x1  u and u  x2 are each monotone in function f values. This also implies
that d1 (x1,u) = d1 (s, x1) − d1 (s,u) = f (u) − f (x1); similarly, d1 (x2,u) = f (u) − f (x2). Symmetric
statements hold for y1  w  y2. Hence
d1 (x1, x2) = d1 (x1,u) + d1 (u, x2) = 2f (u) − f (x1) − f (x2),
d2 (y1,y2) = d2 (y1,w) + d2 (w,y2) = 2д(w) − д(y1) − д(y2).
We then have
|d1 (x1, x2) − d2 (y1,y2)| = |2f (u) − f (x1) − f (x2) − 2д(w) + д(y1) + д(y2)|
≤ 2|f (u) − д(w)| + |f (x1) − д(y1)| + |f (x2) − д(y2)|
≤ 2|f (u) − д(w))| + 2Δ (by Equation (4)).
We now wish to bound |f (u) − д(w)|. Consider the case where y1 = α∗ (x1),y2 = α∗ (x2). As we
traverse the path x1  u  x2, the image of this path under α∗ is a path y1  α∗ (u)  y2, where
y1  α∗ (u) and α∗ (u)  y2 are each monotone in function д values. Hence, α∗ (u) is an ancestor
of y1 and y2. Since w is the least common ancestor of y1 and y2, we have that α∗ (u) must be an
ancestor of w. The same claim can be similarly proved for the remaining cases. Further, it can
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.            
Computing the Gromov-Hausdorff Distance for Metric Trees 24:9
be similarly shown that β∗ (w) must be an ancestor of u. Thus, f (u) − Δ ≤ д(w) ≤ f (u) + Δ ⇒
|f (u) − д(w)| ≤ Δ. We thus have
|d1 (x1, x2) − d2 (y1,y2)| ≤ 4Δ.
It then follows that Dist(C) ≤ 4Δ. Since dGH (T1, T2) ≤ 1
2Dist(C), the lemma follows.
Next, we prove an upper bound on Δ.
Lemma 4.2. Δ ≤ 14dGH (T1, T2).
Proof. Set δ = dGH (T1, T2) and let C∗ : T1 ×T2 be an optimal correspondence that achieves
dGH (T1, T2). Note that in general dGH (T1, T2) may only be achieved in the limit. In that case,
our proof can be modified by considering a near-optimal correspondence of distortion δ =
dGH (T1, T2) + ε for some arbitrary ε > 0.
Let s be one of the endpoints of a longest simple path in T1 (i.e., the length of this path realizes
the diameter of T1); s is necessarily a leaf of T1. Let (s,t) be a pair in C∗. Consider the merge trees
Ts
1 and Tt
2 defined by the functions fs and ft , respectively. A result by Dey et al. [8, Corollary 6]
(see also [9]) implies that
dI (Ts
1 ,Tt
2 ) ≤ 6δ .
We prove below in Claim 4.3 that there is a vertex (in fact, a leaf) z ∈ V (T2) such that d2 (t, z) ≤ 8δ.
It is easy to verify that
 ft − fz ∞ ≤ d2 (t, z) ≤ 8δ .
On the other hand, by the stability theorem of the interleaving distance,
dI (Tt
2 ,Tz
2 ) ≤  ft − fz ∞ ≤ 8δ .
By the triangle inequality,
dI (Ts
1 ,Tz
2 ) ≤ dI (Ts
1 ,Tt
2 ) + dI (Tt
2 ,Tz
2 )
≤ 6δ + 8δ
≤ 14δ .
This completes the proof of the lemma.
Claim 4.3. Let s be an endpoint of a longest simple path in T1, and let (s,t) be a pair in C∗. Then
there is a vertex z ∈ V (T2) such that d2 (t, z) ≤ 8δ.
Proof. Assume that there is no tree node within 8δ distance to t. In this case, t must be in the
interior of an edge e ∈ E(T2). Let u1 and u2 be the two points in e from opposite sides of t such
that d2 (t,u1) = d2 (t,u2) = 8δ + ν, where ν > 0 is an arbitrarily small value. Both u1 and u2 exist,
as there is no tree node of T2 within 8δ distance to t, and
d2 (u1,u2) = d2 (t,u1) + d2 (t,u2) = 16δ + 2ν .
Let u˜1,u˜2 ∈ T1 be any corresponding points for u1 and u2 under C∗, that is, (u˜1,u1), (u˜2,u2) ∈ C∗.
Since Dist(C∗) ≤ 2δ, we have
d1 (u˜1,u˜2) ≥ 14δ + 2ν . (5)
On the other hand, since d2 (t,u1) = d2 (t,u2) = 8δ + ν, we have that
d1 (s,u˜1),d1 (s,u˜2) ∈ [6δ + ν, 10δ + ν]. (6)
We now obtain an upper bound on d1 (u˜1,u˜2).
If u˜1 and u˜2 have ancestor/descendant relation in Ts
1 , then d1 (u˜1,u˜2) = |d1 (s,u˜1) − d1 (s,u˜2)| and
by Equation (6), we thus have that d1 (u˜1,u˜2) ≤ 4δ, which contradicts Equation (5). Otherwise, if u˜1
and u˜2 do not have ancestor/descendant relation, let w be the nearest common ancestor of u˜1 and
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.  
24:10 P. K. Agarwal et al.
Fig. 5. w is the nearest common ancestor of u˜1 and u˜2 in Ts
1 .
u˜2 in Ts
1 (see Figure 5). Let c0 = d1 (s,w). For simplicity, set a = d1 (s,u˜1) and b = d1 (s,u˜2). It then
follows that
d1 (u˜1,u˜2) = a + b − 2c0.Note,a ≥ c0,b ≥ c0. (7)
Since s is an endpoint of the longest path in T1, it follows that c0 ≥ min{a − c0,b − c0}. Indeed, if
this were not the case, then without loss of generality, suppose the other point s	 of the diameter
pair is not in the subtree of Ts
1 rooted at u˜1. We then have
d1 (u˜1,s	
) = (a − c0) + (b − c0) > c0 + (b − c0) = d1 (s,s	
), (8)
a contradiction. By Equation (6), a,b ≥ 6δ + ν. Thus,
c0 ≥ min{a − c0,b − c0} ≥ 6δ + ν − c0 ⇒ c0 ≥
1
2
(6δ + ν ). (9)
Combining Equations (7) and (9), we have
d1 (u˜1,u˜2) ≤ a + b − 6δ − ν ≤ 20δ + 2ν − 6δ − ν = 14δ + ν, (10)
contradicting Equation (5). Thus, there exists z ∈ V (T2) such that d2 (t, z) ≤ 8δ.
Remark. The proof of Claim 4.3 actually shows that t lies within distance 8δ of at least one leaf,
as we never use the fact that u1 and u2 lie on the same edge of T2. The only fact we use is that u1
and u2 lie on opposite sides of t at distance 8δ + ν each.
From Lemmas 4.1 and 4.2, we get the following.
Theorem 4.4. Let Δ = minu ∈V (T1 ),v ∈V (T2 ) dI (T u
1 ,T v
2 ). Then
1
2
dGH (T1, T2) ≤ Δ ≤ 14dGH (T1, T2).
In order to approximate dGH (T1, T2), we merely need to approximate the interleaving distance
for each of the O(n2) pairs of merge trees obtained by rooting T1 and T2 at each of their vertices.
Corollary 4.5. If there is a polynomial time,c-approximation algorithm for the interleaving distance between two merge trees, then there is a polynomial time, 28c-approximation algorithm for the
GH distance between two metric trees that runs the algorithm for interleaving distance O(n2) times.
5 COMPUTING THE INTERLEAVING DISTANCE
Let Mf and Mд be merge trees of two functions f and д, respectively. For simplicity, we use f and
д to denote the height functions on Mf and Mд as well. Let n be the total number of nodes in Mf
and Mд, and let r ≥ 1 be the ratio between the lengths of the longest and the shortest edges in Mf
and Mд. We describe a O(min{n,
√
rn})-approximation algorithm for computing dI (Mf , Mд ).
Candidate values and binary search. We first show that a candidate set Λ of O(n2) values can
be computed in O(n2) time such that dI (Mf , Mд ) ∈ Λ. Given Λ, we perform a binary search on Λ.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018. 
Computing the Gromov-Hausdorff Distance for Metric Trees 24:11
Fig. 6. Trees Mf and Mд. Here δv = min{ 1
2 ε1,ε2}.
At each step, we use a c-approximate decision procedure, forc = c1 min{n,
√
rn} for some constant
c1, that given a value ε > 0 does the following: if dI (Mf , Mд ) ≤ ε, it returns a pair ofcε-compatible
maps between Mf and Mд; if dI (Mf , Mд ) > ε, it will either return a pair of cε-compatible maps
between Mf and Mд or report that no pair of ε-compatible maps exist.
We perform the binary search using the c-approximate decision procedure in the following way:
if the procedure returns a pair of cε-compatible maps for a value ε ∈ Λ, we continue the search
using only lesser values of ε. Otherwise, we continue the search using only higher values of ε.
When there are no more candidate values to search, we return the maps for the minimum value
of ε that yielded a pair of maps.
The above procedure returns a pair of cε-compatible maps where dI (Mf , Mд ) ≤ cε ≤
cdI (Mf , Mд ). Indeed, the procedure does not run out of candidate values ε < dI (Mf , Mд ) until
it has tried some ε	 ≤ dI (Mf , Mд ) for which the approximate decision procedure returned a pair
of cε	
-compatible maps. We now describe the candidate set Λ.
LetVf (Vд, respectively) be the set of nodes in Mf (Mд, respectively). We define Λ = Λ11 ∪ Λ22 ∪
Λ12, where
Λ11 = { 1
2 |f (u) − f (v)| | u,v ∈ Vf },
Λ22 = { 1
2 |д(u) − д(v)| | u,v ∈ Vд },
Λ12 = {|f (u) − д(v)| | u ∈ Vf ,v ∈ Vд }.
Lemma 5.1. dI (Mf , Mд ) ∈ Λ.
Proof. Suppose to the contrary that dI (Mf , Mд ) = ε  Λ. Let α : Mf → Mд and β : Mд → Mf
be ε-compatible maps that realize dI (Mf , Mд ) = ε. We will obtain a contradiction by choosing
ε0 > 0 and constructing (ε − ε0)-compatible maps αˆ, ˆ
β.
For any point x ∈ Mf , we define α↓(x) = α (x) if α (x) is a node of Mд, otherwise α↓(x) is the
lower endpoint of the edge of Mд containing α (x). Similarly we define the function β↓ : Mд → Mf .
For every node v ∈ Vf , α (v) (β (α (v)), respectively) lies in the interior of an edge of Mд (Mf ,
respectively), because ε  Λ ⊇ Λ12 (Λ11, respectively). We define
δv = min  1
2

f (β (α (v))) − f (β↓(α (v))),д(α (v)) − д(α↓(v))
.
See Figure 6. Similarly, we define δw for all w ∈ Vд. We set
ε0 = min 
ε, min v ∈Vf ∪Vд
δv

.
Since ε  Λ, we have ε0 > 0. We now construct (ε − ε0)-compatible maps αˆ : Mf → Mд and
ˆ
β : Mд → Mf (note ε0 ≤ ε, so ε − ε0 is non-negative). We describe the construction of αˆ; ˆ
β is
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.  
24:12 P. K. Agarwal et al.
Fig. 7. Figure showing u,v, x,y, and y	
.
constructed similarly. By construction, for any node u ∈ Vf , д(α (u)) − д(α↓(u)) ≥ ε0, so we set
αˆ(u) to be the point w on the edge of Mд containing α (u) such that д(w) = f (u) + ε − ε0. Once
we have defined αˆ(u) and αˆ(v) for an edge uv ∈ Mf , with f (u) < f (v), we set αˆ(x), for a point
x ∈ uv with f (x) = f (u) +γ , to be
αˆ(x) = σγ
д (αˆ(u)).
That is, we set αˆ(x) to be the ancestor of αˆ(u) at height f (u) + ε − ε0 +γ = f (x) + ε − ε0. Now, it is
not too hard to see that if x1 is an ancestor of x2 in Mf , then αˆ(x1) is an ancestor of αˆ(x2) (similarly
for ˆ
β). Further, ˆ
β (αˆ(x1)) is a descendant of β (α (x1)) for all x1 ∈ Mf (a similar result holds for αˆ ◦ ˆ
β
and α ◦ β).
We claim that αˆ, ˆ
β are (ε − ε0)-compatible. Indeed, by construction, д(αˆ(x)) = f (x) + ε − ε0 for
all x ∈ Mf , and f ( ˆ
β (y)) = д(y) + ε − ε0 for all y ∈ Mд. We now prove that
ˆ
β ◦ αˆ = σ2(ε−ε0 )
f .
Suppose to the contrary there is a point x ∈ Mf such that y = ˆ
β (αˆ(x))  σ2(ε−ε0 )
f (x). Since
f (y) = f (x) + 2(ε − ε0), y must not be an ancestor of x. On the other hand, α, β are ε-compatible,
so y	 = β (α (x)) is the ancestor of x at height f (x) + 2ε. By construction of αˆ and ˆ
β, y is a descendant of y	
, in which case there is a node u ∈ Vf that lies between y and y	
. (If y and y	 lie on the
same edge of Mf , then y is also an ancestor of x.) Let u = β↓(α (x)). Let v be the lower endpoint of
the edge e containing x. See Figure 7. Since ε  Λ, f (u)  f (v) + 2ε (i.e., u  β (α (v))). There are
two cases to consider:
(i) f (u) > f (v) + 2ε. Then let u = β (α (z)) for the point z lying between x and v at
height f (z) = f (u) − 2ε. Furthermore, f (x) ≥ f (z) > f (x) − 2ε0 (if f (x) − f (z) ≥ 2ε0, then
f (y	
) − f (u) = f (x) − f (z) ≥ 2ε0, contradicting the fact that f (y	
) − f (y) = 2ε0). Therefore, we can choose a point w  v on e such that f (z) > f (w) > f (x) − 2ε0. We have
ˆ
β (αˆ(w)) is a descendant of y = ˆ
β (αˆ(x)) (sincew is a descendant of x). Moreover, β (α (w)) is
an ancestor of ˆ
β (αˆ(w)). However, since f (β (α (w))) < f (u), β (α (w)) lies between y and u.
Thus, β (α (w)) is not an ancestor of x (hence, w), that is, β (α (w))  σ2ε
f (w), contradicting
the fact that α, β are ε-compatible.
(ii) f (u) < f (v) + 2ε. In this case
f (β (α (v))) − f (β↓(α (v))) ≤ f (β (α (v))) − f (u) < f (y	
) − f (y) = 2ε0 ≤ 2δv ,
which contradicts the definition of δv .
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.     
Computing the Gromov-Hausdorff Distance for Metric Trees 24:13
Hence, we conclude that y is an ancestor of x, that is, ˆ
β ◦ αˆ = σ2(ε−ε0 )
f . Similarly, one can argue
that αˆ ◦ ˆ
β = σ2(ε−ε0 )
д , implying that αˆ, ˆ
β are (ε − ε0)-compatible maps as claimed.
Putting everything together, we conclude that ε ∈ Λ.
We now describe the decision procedure to answer the question “is dI (Mf , Mд ) ≤ ε?” approximately. Given a parameter ε > 0, an edge is called ε-long, or long for brevity, if its length is strictly
greater than 2ε. We first describe an exact decision procedure for the case when all edges in both
trees are long, and then describe an approximate decision procedure for the case when the two
trees have short edges.
Trees with long edges. We remove all degree-two nodes in the beginning. A subtree rooted at a
point x in a merge tree M, denoted Mx , includes all the points in the merge tree that are descendants
of x and an edge from x that extends upward to height ∞. For a node u ∈ V , let C(u) denote the
children of u and let p(u) denote its parent. Assume dI (Mf , Mд ) ≤ ε, and let α : Mf → Mд and
β : Mд → Mf be a pair ofε-compatible maps. As in the proof of Lemma 5.1, we define the functions
α↓ and β↓ but restricted only to the vertices of Mf and Mд. That is, for a node v ∈ Vf , we define
α↓(v) to be the lower endpoint of the edge containing α (v)—if α (v) is a node, then α↓(v) is α (v)
itself. Similarly, we define β↓(w), for a node w ∈ Vд.
The following two properties of α↓ and β↓ will be crucial for the decision procedure.
Lemma 5.2. If all edges in Mf and Mд are ε-long, then the following hold: (i) For a node v ∈ Vf ,
|f (v) − д(α↓(v))| ≤ ε, and (ii) for a node w ∈ Vд, |д(w) − f (β↓(w))| ≤ ε.
Proof. We will prove part (i); part (ii) is similar. By definition, д(α↓(v)) ≤ f (v) + ε. Suppose
д(α↓(v)) < f (v) − ε. Let v	 be a point in Mд lying on the edge containing α (v) and α↓(v) with
height f (v) − ε − ε0, for some sufficiently small ε0. Then β (v	
) lies in one of the subtrees rooted
at the children of v, say M1. Consider a descendant u of v at height д(v	
) − ε lying in a different
subtree M2 rooted at v’s child. Such a descendant exists, because all edges are ε-long. Since by
definition and our choice of v	 there does not exist any node in Mд between α (v) and v	
, we have
α (u) = v	
. But then β (α (u)) = β (v	
) lies in M1, and hence is not an ancestor of u ∈ M2; in other
words, β (α (u))  σ2ε
f (u). This contradicts the fact that α and β are ε-compatible. Thus, д(α↓(v)) ≥
f (v) − ε, and the claim follows.
Lemma 5.3. If all edges in Mf and Mд are ε-long, then α↓ and β↓ are bijections with β↓ = α−1
↓ (and
α↓ = β−1
↓ ).
Proof. We will first show that β↓ = α−1
↓ . Suppose to the contrary there exists a vertex v ∈ Vf
such that β↓(α↓(v)) = w  v. Let α↓(v) = u, for u ∈ Vд. From Lemma 5.2 we have |f (v) − f (w)| ≤
2ε. Since all edges are longer than 2ε and v  w, v cannot be an ancestor/descendant of w in Mf .
By definition of α↓, α (v) is an ancestor of α↓(v) = u. Thus, β (α (v)) is an ancestor of β (u). Further,
|f (v) − д(u)| ≤ ε (Lemma 5.2) and β (α (v)) = σ2ε
f (v) (since α, β are ε-compatible). Hence, β (u) lies
between v and β (α (v)) on the edge e whose lower endpoint is v as e is ε-long. Thus, β (u) is an
ancestor of v. See Figure 8. Also by definition of β↓, β (u) is an ancestor of β↓(u) = w. Thus, w is a
descendant of v, a contradiction since v cannot be an ancestor of w.
We thus have β↓ = α−1
↓ . Similarly, we can show that α↓ = β−1
↓ . This also implies that α↓ and β↓
are bijections.
We define an indicator function Φ : Vf ×Vд → {0, 1} such that
Φ(u,v) =

1, if dI (Mu
f , Mv
д ) ≤ ε,
0, otherwise.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.      
24:14 P. K. Agarwal et al.
Fig. 8. Figure showing β (u) = β (α↓(v)) is an ancestor of v.
The following lemma gives a recursive definition of Φ(u,v).
For two integers, k and  with k ≤ , let [k, ] = {k, k + 1,...,}.
Lemma 5.4. Suppose all the edges in Mf and Mд are ε-long. Let (u,v) ∈ Vf ×Vд, and let ui and vj
denote the i-th and j-th child, respectively, of u and v. We have Φ(u,v) = 1 if and only if the following
conditions hold : (i) |f (u) − д(v)| ≤ ε, (ii) |C(u)| = |C(v)|, and (iii) there exists a permutation π of
[1 : |C(u)|] such that Φ(ui,vπ (i)) = 1 for all i ∈ [1 : |C(u)|].
Proof. Suppose Φ(u,v) = 1, and let α, β be the corresponding ε-compatible maps. Suppose
property (i) does not hold, and let f (u) > д(v) + ε without loss of generality. Thus, β (v) maps to
one of the multiple edges incident to u, and there exists at least one edge e = (u,w) with w ∈ C(u)
such that none of e’s points (other than u) is in the image of β. However, β (α (w)) = σ2ε
f (w) must
lie in the interior of e (since e is ε-long), a contradiction. To prove that (ii) holds, note that by
Lemma 5.3 and monotonicity of α↓ and β↓, there exist bijections α↓, β↓ between the vertices of
Mu
f and Mv
д such that if u1 ∈ C(u2) for a vertex u2 ∈ Mu
f , then α↓(u1) ∈ C(α↓(u2)) (a symmetric
statement holds for β↓ and vertices in Mv
д ). Thus, α↓, β↓ induce bijections between C(u) and C(v),
and hence |C(u)| = |C(v)|. Finally, for (iii), let α↓(u	
) = v	 for some u	 ∈ C(u),v	 ∈ C(v). Then by
definition of α↓ and β↓, α (Mu	
f ) ⊆ Mv	
д and β (Mv	
д ) ⊆ Mu	
f . This means that the restriction of the
pair of ε-compatible maps α and β to Mu	
f and Mv	
д , respectively, remain ε-compatible for Mu	
f and
Mv	
д . Thus, Φ(u	
,v	
) = 1, and the permutation π is defined by α↓, β↓.
We now prove the opposite direction. Suppose properties (i), (ii), and (iii) hold. Let (αi, βi ) be
the pair of ε-compatible maps between Mui
f and Mvπ (i)
д . Then, a pair of ε-compatible maps (α, β)
between Mu
f and Mv
д is obtained as follows: α (x) = {αi (x) | x ∈ Mui
f } (β is defined similarly). Note
that points on the infinite edge from u (v, respectively) upward are shared among all Mui
f (Mvj
д ,
respectively), whereas all other points in Mu
f (Mv
д , respectively) are present in only one Mui
f (Mvj
д ,
respectively). However, since |f (u) − д(v)| ≤ ε, shared points are mapped to shared points and we
have |α (x)| = 1 (|β (y)| = 1|, respectively) for all x ∈ Mu
f (y ∈ Mv
д , respectively). Thus, α and β are
functions and satisfy all the required properties. Hence, Φ(u,v) = 1.
Decision procedure. We compute Φ for all pairs of nodes in Vf ×Vд in a bottom-up manner and
return Φ(rf ,rд ) where rf (rд, respectively) is the root of Mf (Mд, respectively). Let (u,v) ∈ Vf ×Vд.
Suppose we have computed Φ(ui,vj) for all ui ∈ C(u) and vj ∈ C(v). We compute Φ(u,v) as
follows. If (i) or (ii) of Lemma 5.4 does not hold for u and v, then we return Φ(u,v) = 0. Otherwise,
we construct the bipartite graph Guv = {C(u) ∪C(v), E = {(ui,vj) | Φ(ui,vj) = 1}} and determine
in O(k5/2) time whether Guv has a perfect matching, using the algorithm by Hopcroft and Karp
[13]. Here, k = |C(u)| = |C(v)|. IfGuv has a perfect matching M = {(u1,vπ (1)),..., (uk ,vπ (k) )}, we
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.     
Computing the Gromov-Hausdorff Distance for Metric Trees 24:15
Fig. 9. A naive map.
set Φ(u,v) = 1, else we set Φ(u,v) = 0. If Φ(u,v) = 1, we use the ε-compatible maps for Mui
f , Mvπ (i)
д ,
for 1 ≤ i ≤ k, to compute a pair of ε-compatible maps between Mu
f and Mv
д , as discussed in the
proof of Lemma 5.4.
For a node u ∈ Vf ∪Vд, let ku be the number of its children. The total time taken for running
Hopcroft and Karp [13] is

u ∈V (T1 )

v ∈V (T2 )
O 	
kukv


kv

=

u ∈V (T1 )
ku

v ∈V (T2 )
O 	
kv


kv

≤ O 	
n3/2

u ∈V (T1 )
ku ≤ O 	
n5/2

.
Hence, we obtain the following.
Lemma 5.5. Given two merge trees Mf and Mд and a parameter ε > 0 such that all edges of Mf
and Mд are ε-long, then whether dI (Mf , Mд ) ≤ ε can be determined in O(n5/2) time. If the answer is
yes, a pair of ε-compatible maps between Mf and Mд can be computed within the same time.
Trees with short edges. Given two merge trees, a naive map is to map the lowest among all the
leaves in both the trees to a point at height equal to the height of the higher of the two roots of
Mf and Mд (see Figure 9). Thus, all the points in one tree will be mapped to the infinitely long
edge on the other tree. This map produces a distortion equal to the height of the trees, which can
be arbitrarily larger than the optimum. Nevertheless, this simple idea leads to an approximation
algorithm.
Here is an outline of the algorithm. After carefully trimming off short subtrees from the input
trees, the algorithm decomposes the resulting trimmed trees into two kinds of regions: those with
nodes and those without nodes. If the interleaving distance between the input trees is small, then
there exists an isomorphism between trees induced by the regions without nodes. Using this isomorphism, the points in the nodeless regions are mapped without incurring additional distortion.
Using a counting argument and the naive map described above, it is shown that the distortion
incurred while mapping the regions with nodes and the trimmed regions is bounded.
More precisely, given Mf , Mд and ε > 0, define the extent e (x) of a point x (which is not necessarily a tree node) in Mf or Mд as the maximum height difference between x and any of its
descendants. Suppose each edge is at most sε long. Let M	
f and M	
д be subsets of Mf and Mд consisting only of points with extent at least 2(
√
2ns + 1)ε, adding nodes to the new leaves of M	
f and
M	
д as necessary. Note that M	
f and M	
д themselves are trees; however, they might contain nodes
of degree 2. See Figure 10 for an example.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.     
24:16 P. K. Agarwal et al.
Fig. 10. Trimming a tree: (left) original tree, red points have extent < 2(
√
2ns + 1)ε; (right) trimmed tree,
nodes added at the bottom (hollowed nodes).
Lemma 5.6. If dI (Mf , Mд ) ≤ ε, then dI (M	
f , M	
д ) ≤ ε.
Proof. Let α : Mf → Mд and β : Mд → Mf be ε-compatible maps. Let α	 and β	 be restrictions
of the functions’ domains to M	
f and M	
д, respectively. We argue that the ranges of α	 and β	
lie in M	
д and M	
f , respectively. Suppose otherwise. Then without loss of generality, there is a
point x ∈ M	
f with y = α (x) not in M	
д. Because x ∈ M	
f , its extent in Mf is at least 2(
√
2ns + 1)ε.
Therefore, there exists a descendant x 	 of x in Mf with f (x 	
) = f (x) − 2(
√
2ns + 1)ε. Because y is
not in M	
д, the extent of y must be less than 2(
√
2ns + 1)ε and there exists no descendant y	 of y
with д(y	
) = д(y) − 2(
√
2ns + 1)ε = f (x) − 2(
√
2ns + 1)ε + ε = f (x 	
) + ε. Since д(α (x 	
)) = f (x 	
) +
ε, α (x 	
) is not a descendant of α (x), which contradicts the assumption that α, β are ε-compatible
maps.
The above lemma can be easily generalized to say that removing points in both trees with extent
less than or equal to any fixed value does not increase the distance between them.
We now define matching points in M	
f and M	
д. Let H be the set of function values for leaves
and branching nodes in M	
f or M	
д, and let H	 ⊆ H be the subset of H consisting of function values
h for which (h,h + 2ε] does not intersect H. A point x in M	
f is a matching point if f (x) ∈ H	
.
Similarly, a point y in M	
д is a matching point if д(y) ∈ H	
. By this definition, no two matching
points share a function value within 2ε of each other unless they share the exact same function
value. Furthermore, if x is a matching point, then all points with the same function value as x on
both M	
f and M	
д are matching points. There are O(n2) matching points.
Suppose dI (M	
f , M	
д ) ≤ ε, and let α	 : M	
f → M	
д and β	 : M	
д → M	
f be a pair of ε-compatible
maps. Call a matching point x in M	
f and a matching point y in M	
д with f (x) = д(y) matched if
α	
(x) is an ancestor of y.
Lemma 5.7. Let x be any matching point in M	
f . The matched relation between matching points in
M	
f at height f (x) and matching points in M	
д at height f (x) is a bijective function.
Proof. No two distinct matching points y1 and y2 on M	
д with f (x) = д(y1) = д(y2) share the
same ancestor with function value f (x) + ε, because they have no branching node ancestors with
low enough function value. Therefore, a matching point in M	
f can be matched to only one matching point in M	
д.
Let x1 and x2 be two distinct matching points from M	
f with f (x) = f (x1) = f (x2). If α	
(x1)
and α	
(x2) are ancestors of a common matching point y, then α	
(x1) = α	
(x2) and thus x1 and x2
must have a common ancestor x 	 at height f (x) + 2ε. However, x1 and x2 have no branching node
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018. 
Computing the Gromov-Hausdorff Distance for Metric Trees 24:17
Fig. 11. The left tree shows matching points on tree M	
f and the right tree shows M˜ f .
ancestor with low enough function value for x 	 to exist. Hence, the matching relation must be
injective from matching points in M	
f to M	
д.
Finally, consider any matching point y on M	
д with д(y) = f (x). Point x 	
1 = β	
(y) is the ancestor
of a matching point x1 on M	
f with f (x1) ≥ д(y). (Note that by the same argument as the beginning
of this proof, only one such matching point x1 can exist.) Point y	 = α	
(x 	
1) is an ancestor of y with
д(y	
) ≤ д(y) + 2ε. Point y is the only descendant of y	 with function value f (x). Point α	
(x1) must
be an ancestor of y, meaning x1 and y are matched. Thus, the matching relation is surjective.
We now define a rooted tree M˜ f to be a rooted tree consisting of one node per matching point on
M	
f . Let p(v) be the matching point for node v. M˜ f has node v as an ancestor of node u if p(v) is an
ancestor of p(u) (see Figure 11). Define M˜ д similarly. The size of M˜ f and M˜ д is O(n2). Intuitively,
M˜ f and M˜ д represent the trees induced by matching points. By the definition of interleaving distance and Lemma 5.7, M˜ f and M˜ д are isomorphic if M	
f and M	
д satisfy that dI (M	
f , M	
д ) ≤ ε.
Decision procedure. We are now ready to describe the decision procedure. We first construct
the subtrees M	
f and M	
д of Mf and Mд, respectively, consisting of points with extent at least
2(
√
2ns + 1)ε. Next, we compute matching points on M	
f and M	
д and construct the trees M˜ f and
M˜ д on these matching points, as defined above.
Using the algorithm of [2, chap. 3, p. 85], we determine in time linear in the size of the trees
whether M˜ f and M˜ д are isomorphic. If the answer is no, we return no. By Lemma 5.7, dI (Mf , Mд ) >
ε in this case. Otherwise, we construct the following functions α : Mf → Mд and β : Mд → Mf
and return them. Recall, it suffices to perform assignments where the function value increases by
at most cε. For each pair of matching points x and y matched by the isomorphism, the algorithm
sets α (x) = y and β (y) = x. Now, let (ξ1,ξ2) be any maximal range of function values without
any branching nodes or leaves in M	
f or M	
д with ξ2 − ξ1 > 2ε. Let x 	 be any point in M	
f with
f (x 	
) ∈ (ξ1,ξ2). Point x 	 has a unique matching point descendant x at height ξ1, by the definition
of matching points. The algorithm sets α (x 	
) to the point y	 in M	
д where y	 is the ancestor of α (x)
with д(y	
) = f (x 	
), and it sets β (y	
) = x 	
. For every remaining point x 		 in M	
f , the algorithm sets
α (x 		) to α (x) where x is the lowest matching point ancestor of x 		. β (y		) is defined similarly for
remaining points y		 in M	
д that were not paired with some x 	
. We call such points x 		 and y		 lazily
assigned. See Figure 12. Finally, each point z in Mf − M	
f has α (z) set to α (x) where x is the lowest
ancestor of z in M	
f . Similar assignments are done for points in Mд − M	
д.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018. 
24:18 P. K. Agarwal et al.
Fig. 12. Figure showing points x,y, x 	
,y	
, x 		,y		.
Lemma 5.8. (i) For each lazily assigned point x 		 ∈ M	
f ,
д(α (x 		)) ≤ f (x 		) + 2(
√
2ns + 1)ε.
(ii) For each lazily assigned point y		 ∈ M	
д,
f (β (y		)) ≤ д(y		) + 2(
√
2ns + 1)ε.
Proof. We only prove (i); (ii) is symmetric. The higher of the two roots of M	
f and M	
д is a
matching point, and so are all the points at that height. Thus, all lazily assigned points have a
matching point ancestor. We show that the nearest such ancestor cannot be too much higher up.
Let x be a matching point. We show that there exists a region (ξ1,ξ2) as defined above with
f (x) − 2(
√
2ns + 1)ε ≤ ξ2 ≤ f (x).
Consider sweeping over the function values downward starting at f (x) and let ξ2 be the largest
function value possible for a region as defined above. If the sweep line ever goes a distance greater
than 2ε without encountering a branching node or leaf in M	
f or M	
д, then an ξ2 is found. Therefore,
there will be at least one branching node or leaf x 	 in M	
f or M	
д per descent of 2ε until ξ2 is found.
Suppose ξ2 < f (x) − 2(
√
2ns + 1)ε. Let l = √
2ns + 1, and f 	 = f (x) − 2lε.
Let {P1, P2,... } be a set of paths from each branching node of M	
f or M	
д encountered during
the sweep to leaves of Mf and Mд such that for each pair of paths, both paths are disjoint except
possibly at the higher endpoint of one of the two paths. Such a set of paths can be found by
greedily selecting an arbitrary path for each branching node as it is encountered. In addition, let
{Q1,Q2,... } be a set of pairwise-disjoint paths from leaves of M	
f and M	
д to leaves of Mf and Mд.
Because each point in M	
f and M	
д has extent at least 2lε, the lower endpoint of each of these paths
lies below height f 	
. Since edge lengths are at most sε, there are at least (f (x 	
) − f 	
)/sε nodes in
Mf or Mд on the path Pi or Qj from each branching node or leaf x 	 at height f (x 	
) ∈ [f 	
, f (x)),
not counting x 	 itself. In total, these paths contain at least

l
i=1
(l − i)2ε
sε = l(l − 1)
s
nodes, not counting their higher endpoints. Each node counted above appears on at most one path
Pi and at most one path Qj , for at most two paths total, so
l(l − 1)
s ≤ 2n ⇒ l(l − 1) ≤ 2ns,
a contradiction since l = √
2ns + 1. Therefore, eitherξ2 ≥ f (x) − 2(
√
2ns + 1)ε, or the trees M	
f and
M	
д do not extend below height f (x) − 2(
√
2ns + 1)ε. In either case, the lemma follows.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.  
Computing the Gromov-Hausdorff Distance for Metric Trees 24:19
Lemma 5.9. Let Mf and Mд be two merge trees and letε > 0 be a parameter. There is anO(n2) time
algorithm that returns a pair of 4(
√
2ns + 1)ε-compatible maps between Mf and Mд, if dI (Mf , Mд ) ≤
ε and the maximum length of a tree edge is sε. If dI (Mf , Mд ) > ε, then the algorithm may return no
or return a pair of 4(
√
2ns + 1)ε-compatible maps.
Proof. Constructing the trees M˜ f and M˜ д, the corresponding isomorphism between them (if
it exists), and the maps α and β between Mf and Mд (if they exist) takes time O(n2).
Except for the lazily assigned points, all the points in M	
f and M	
д are mapped by α and β,
respectively, to points at the same function value. By Lemma 5.8, each point in M	
f and M	
д has
its function value changed by at most 2(
√
2ns + 1)ε. Points in Mf − M	
f (Mд − M	
д, respectively)
have their nearest ancestors in M	
f (M	
д, respectively) at function value at most 2(
√
2ns + 1)ε away.
Since α and β map them to the images of their nearest ancestors, their function values change by
at most 2 · 2(
√
2ns + 1)ε.
Remark. (i) Since the minimum edge length is ≤ 2ε, the maximum edge length issε, and the ratio
between the lengths of the longest and shortest edges is r; we have r ≥ s/2.
(ii) If s = Ω(n), we modify the above algorithm slightly—we skip the trimming step, but keep
the rest the same. It can be shown, as in Lemma 5.8, that the height of a point and its image differ
by at most 2nε. In particular, the proof no longer requires as complicated a counting argument,
because any path contains at most n nodes.
Putting it together. By Lemmas 5.5 and 5.9, the decision procedure takesO(n5/2) time. If it returns
no, then dI (Mf , Mд ) > ε. If it returns yes, then it also returns O(min{n,
√
rn}ε)-compatible maps
between them. Hence, we conclude the following.
Theorem 5.10. Given two merge trees Mf and Mд with a total of n vertices, there exists an
O(n5/2 logn)-time algorithm with an approximation factor of O(min{n,
√
rn}) for computing the interleaving distance between them, where r is the ratio between the lengths of the longest and the
shortest edge in both trees.
Combining Theorem 5.10 with Corollary 4.5, we have the following.
Corollary 5.11. Given two metric trees T1 and T2 with a total of n vertices, there exists an
O(n9/2 logn)-time algorithm with an approximation factor of O(min{n,
√
rn}) for computing the GH
distance between them, where r is the ratio between the lengths of the longest and the shortest edge in
both trees.
6 CONCLUSION
We have presented the first hardness results for computing the GH distance between metric trees.
We have also given a polynomial-time approximation algorithm for the problem. But the current
gap between the lower and upper bounds on the approximation factor is polynomially large. While
we would like to reduce this gap, doing so seems very difficult. On the algorithmic side of things
in particular, trying for anything less than an O(
√
n)-approximation appears to prevent our use of
algorithms for graph isomorphism, the strongest algorithmic tool used in the above algorithm. We
hope that our current investigation will stimulate more research on the theoretical and algorithmic
aspects of embedding or matching under additive metric distortion 