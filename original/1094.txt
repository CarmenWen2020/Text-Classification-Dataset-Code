The Gromov-Hausdorff (GH) distance is a natural way to measure distance between two metric spaces. We
prove that it is NP-hard to approximate the GH distance better than a factor of 3 for geodesic metrics on
a pair of trees. We complement this result by providing a polynomial time O(min{n,
âˆš
rn})-approximation
algorithm for computing the GH distance between a pair of metric trees, where r is the ratio of the longest
edge length in both trees to the shortest edge length. For metric trees with unit length edges, this yields an
O(
âˆš
n)-approximation algorithm.1
CCS Concepts: â€¢ Theory of computation â†’ Computational geometry; Problems, reductions and
completeness;
Additional Key Words and Phrases: Metric spaces, embeddings
1 INTRODUCTION
The Gromov-Hausdorff distance (or GH distance for brevity) [11] is one of the most natural distance measures between metric spaces, and has been used, for example, for matching deformable
shapes [4, 16], and for analyzing hierarchical clustering trees [6]. Informally, the GH distance
measures the additive distortion suffered when mapping one metric space to another using a correspondence
between their points. Even when working with spaces of equal size, correspondences
such as those computed for GH distance are often preferable to, say, bijections, because the distance is less sensitive to slight stretching or the exact choice of points sampled from a larger space
(see Figure 1). Multiple approaches have been proposed to estimate the GH distance [4, 15, 16].
Despite much effort, the problem of computing, either exactly or approximately, GH distance
has remained elusive. The problem is not known to be NP-hard, and computing the GH distance,
even approximately, for graphic metrics2 is at least as hard as the graph isomorphism problem.
Indeed, the metrics for two graphs have GH distance 0 if and only if the two graphs are isomorphic.
Motivated by this trivial hardness result, it is natural to ask whether GH distance becomes easier in
more restrictive settings such as geodesic metrics over trees, where efficient algorithms are known
for checking isomorphism [2].
Related work. Most work on associating points between two metric spaces involves embedding
a given high-dimensional metric space into an infinite host space of lower-dimensional metric
spaces. However, there is some work on finding a bijection between points in two given finite
metric spaces that minimizes typically multiplicative distortion of distances between points and
their images, with some limited results on additive distortion.
Kenyon et al. [14] give an optimal algorithm for minimizing the multiplicative distortion of
a bijection between two equal-sized finite metric spaces, and a parameterized polynomia-time
algorithm that finds the optimal bijection between an arbitrary unweighted graph metric and a
bounded-degree tree metric.
Papadimitriou and Safra [18] show that it is NP-hard to approximate the multiplicative distortion
of any bijection between two finite three-dimensional point sets to within any additive constant
or to a factor better than 3.
Hall and Papadimitriou [12] discuss the additive distortion problemâ€”given two equal-sized point
sets S,T âŠ‚ Rd , find the smallest Î” such that there exists a bijection f : S â†’ T such that d(x,y) âˆ’
Î” â‰¤ d(f (x), f (y)) â‰¤ d(x,y) + Î”. They show that it is NP-hard to approximate by a factor better
than 3 in R3, and also give a 2-approximation for R1 and a 5-approximation for the more general
problem of embedding an arbitrary metric space onto R1. However, their setting differs from ours
in two major ways: firstly, they consider finite metric spaces of equal size, whereas in this article
the metric spaces may be uncountably infinite; secondly, they consider bijections between metric
spaces, whereas in our work we deal with correspondences between metric spaces which are more
general than bijections. In particular, an optimal correspondence between arbitrary spaces of equal
size may not be a bijection (see Figure 1), so these hardness results do not apply to GH distance.
Thus, their approach cannot be easily extended to our setting.
2A graphic metric measures the shortest path distance between vertices of a graph with unit length edges.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.
Computing the Gromov-Hausdorff Distance for Metric Trees 24:3
The interleaving distance between merge trees [17] was proposed as a measure to compare
functions over topological domains that is stable to small perturbations in a function. Distances
for the more general Reeb graphs are given in [3, 7]. These concepts are related to the GH distance
(Section 4), which we will leverage to design an approximation algorithm for the GH distance for
metric trees.
Our results. In this article, we give the first non-trivial results on approximating the GH distance
between metric trees. First, we prove (in Section 3) that the problem remains NP-hard even for
metric trees via a reduction from 3-Partition. In fact, we show that there exists no efficient algorithm with approximation ratio less than 3 unless P = NP. As noted above, we are not aware of
any result that shows the GH distance problem being NP-hard even for general graphic metrics.
To complement our hardness result, we give an O(
âˆš
n)-approximation algorithm for the GH
distance between metric trees with n nodes and unit length edges. Our algorithm works with arbitrary edge lengths as well; however, the approximation ratio becomes O(min{n,
âˆš
rn}) where r
is the ratio of the longest edge length in both trees to the shortest edge length. Even achieving the
O(n)-approximation ratio presented here for arbitrary r is a non-trivial task, and we hope this first
non-trivial approximation result will stimulate further research on this and similar problems.
Our algorithm uses a reduction, described in Section 4, to the similar problem of computing the
interleaving distance [17] between two merge trees. Given a function f : X â†’ R over a topological
space X, the merge treeTf describes the connectivity between components of the sublevel sets of f
(see Section 2 for a more formal definition). Morozov et al. [17] proposed the interleaving distance
as a way to compare merge trees and their associated functions.3 For us, interleaving distance provides a convenient way to measure distance after rooting the input trees so that correspondences
are more nicely structured. We describe, in Section 5, anO(min{n,
âˆš
rn})-approximation algorithm
for interleaving distance between merge trees, and our reduction provides a similar approximation
for computing the GH distance between two metric trees.
Note on independent work. After writing preliminary versions of the current report, we became
aware of recent work by Schmiedl [19] in which he proves a lower bound of 3 for the approximation ratio of any polynomial-time approximation for GH distance in metric trees. As in our proof,
his ultimately comes down to a reduction from 3-Partition. He also gives an approximation algorithm for arbitrary metrics, but the running time is not guaranteed to be polynomial in the size
of the input.
2 PRELIMINARIES
Metric Spaces and the Gromov-Hausdorff Distance. A metric space X = (X, Ï) consists of a
(potentially infinite) setX and a function Ï : X Ã— X â†’ Râ‰¥0 such that the following hold: Ï(x,y) = 0
iff x = y; Ï(x,y) = Ï(y, x); and Ï(x, z) â‰¤ Ï(x,y) + Ï(y, z).
Given sets A and B, a correspondence between A and B is a set C âŠ† A Ã— B such that (i) for all
a âˆˆ A, there exists b âˆˆ B such that (a,b) âˆˆ C; and (ii) for all b âˆˆ B, there exists a âˆˆ A such that
(a,b) âˆˆ C. We use Î (A, B) to denote the set of all correspondences between A and B.
Let X1 = (X1, Ï1) and X2 = (X2, Ï2) be two metric spaces. The distortion of a correspondence
C âˆˆ Î (X1,X2) is defined as
Dist(C) = sup
(x,y),(x	
,y	)âˆˆC
|Ï1 (x, x 	
) âˆ’ Ï2 (y,y	
)|.
3In fact, our hardness result can be easily extended to the GH distance between graphic metrics for trees and the interleaving
distance between merge trees.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.
24:4 P. K. Agarwal et al.
Fig. 2. Merge tree Mf (shown in red) for a function f : X â†’ R, where X = R. epi f is shown in gray, and
Â¯f âˆ’1 (a) is the gray region below the blue horizontal lines in epi f .
The GH distance [15], dGH , between X1 and X2 is defined as
dGH (X1, X2) = 1
2
inf
C âˆˆÎ (X1,X2 )
Dist(C).
Intuitively, dGH measures how close can we can get to an isometric (distance-preserving) embedding between two metric spaces. We note that there are different equivalent definitions of the
GH distance (see, e.g, Theorem 7.3.25 of [5] and Remark 1 of [15]).
A tree T = (V, E) consists of a set of nodes V and edges E connecting pairs of nodes such that
some geometric realization ofT is simply connected. Note our definition allows for nodes of degree
2. The leaves of T are the nodes of degree 1, and its branching nodes are the nodes of degree 3 or
higher.
Given a treeT = (V, E) and a length functionl : E â†’ Râ‰¥0, we associate a metric space T = (T,d)
with T as follows. T is a geometric realization of T . For x,y âˆˆ T, define d(x,y) to be the length of
the unique shortest path Ï€ (x,y) âˆˆ T. It is clear that d is a metric. The metric space thus obtained
is a metric tree. We often do not distinguish between T and T and write T = (T,d).
Merge Trees and the Interleaving Distance. Let f : X â†’ R be a continuous function from
a connected topological space X to the set of real numbers. The sublevel set at a value a âˆˆ R is
defined as fâ‰¤a = {x âˆˆ X | f (x) â‰¤ a}. A merge tree Mf captures the evolution of the topology of
the sublevel sets as the function value is increased continuously from âˆ’âˆ to +âˆ. Formally, it
is obtained as follows. Let epi f = {(x,y) âˆˆ X Ã— R | y â‰¥ f (x)}. Let Â¯f : epi f â†’ R be such that Â¯f ((x,y)) = y. We may say Â¯f ((x,y)) is the height of point (x,y) âˆˆ X Ã— R. For two points (x,y)
and (x 	
,y	
) in X Ã— R with y = y	
, let (x,y) âˆ¼ (x 	
,y	
) denote them lying in the same component
of Â¯f âˆ’1 (y)(= Â¯f âˆ’1 (y	
)). Then âˆ¼ is an equivalence relation, and the merge tree Mf is defined as the
quotient space (X Ã— R)/ âˆ¼.
The sublevel sets fa of f merge as function value a increases, so we get a rooted tree where
branching nodes represent the moments where two components merge and leaves represent the
birth of a new component at a local minimum. Figure 2 shows an example of a merge tree for a
one-dimensional function. Note that the merge tree extends to a height of âˆ. Our assumption that
X is connected implies we have only one component in fâ‰¤N for some sufficiently large N > 0, and
Mf is, in fact, a single tree.
We define the root of merge tree Mf to be the node with the highest function value. The ancestors
of a point x âˆˆ Mf are the points lying on the unique path from x to the root of Mf as well as all
points with greater height than the root. We define the length of any edge in a merge tree (other
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.
Computing the Gromov-Hausdorff Distance for Metric Trees 24:5
Fig. 3. Part of trees Mf and MĞ´ showing Î± and Î².
than the edge to infinity) to be the height difference between its two endpoints. Ancestors of points
in MĞ´ are defined similarly.
Since each point x âˆˆ Mf represents a component of a sublevel set at a certain height, we can
associate this height value with x, denoted by Ë†
f (x). Given a merge tree Mf and Îµ â‰¥ 0, an Îµ-shift
map ÏƒÎµ
f : Mf â†’ Mf is the map that maps a point x âˆˆ Mf to its ancestor at height Ë†
f (x) + Îµ, that is,
Ë†
f (ÏƒÎµ
f (x)) = Ë†
f (x) + Îµ. Given Îµ â‰¥ 0 and merge trees Mf and MĞ´, two continuous maps Î± : Mf â†’ MĞ´
and Î² : MĞ´ â†’ Mf are said to be Îµ-compatible if they satisfy the following conditions :
Ğ´Ë†(Î± (x)) = Ë†
f (x) + Îµ,âˆ€x âˆˆ Mf ; Ë†
f (Î² (y)) = Ğ´Ë†(y) + Îµ,âˆ€y âˆˆ MĞ´;
Î² â—¦ Î± = Ïƒ2Îµ
f ; Î± â—¦ Î² = Ïƒ2Îµ
Ğ´ . (1)
See Figure 3 for an example. The interleaving distance [17] is then defined as
dI (Mf , MĞ´ ) = inf{Îµ â‰¥ 0 | there exist Îµ-compatible maps Î± and Î²}.
Remark. We can relax the requirements on Î± and Î² from their normal definitions as follows.
(i) Instead of requiring exact value changes, we require
Ë†
f (x) â‰¤ Ğ´Ë†(Î± (x)) â‰¤ Ë†
f (x) + Îµ,âˆ€x âˆˆ Mf ; Ğ´Ë†(y) â‰¤ Ë†
f (Î² (y)) â‰¤ Ğ´Ë†(y) + Îµ,âˆ€y âˆˆ MĞ´ .
(ii) If x1 is an ancestor of x2 in Mf , then Î± (x1) is an ancestor of Î± (x2) in MĞ´. A similar rule
applies for Î².
(iii) Î² (Î± (x)) must must be mapped to an ancestor of x and Î± (Î² (y)) must be mapped to an ancestor of y.
Any pair of maps satisfying the original requirements also satisfies the relaxed requirements for
the same value of Îµ. Conversely, for any pair of maps satisfying the relaxed requirements, we can
stretch up the images for each map by instead mapping to the ancestors of the appropriate height of
the original images, without changing the value ofÎµ. Thus, both definitions of interleaving distance
are equivalent. For convenience, when two Îµ-compatible maps are given to us we assume that
they satisfy Equation (1), but we construct Îµ-compatible maps that satisfy the relaxed conditions
mentioned, knowing that they can be â€œstretchedâ€ as just described to satisfy Equation (1).
If we know Î± (x) for a point x at height h, then we can compute Î± (y) for any ancestor y of x at
height h	 â‰¥ h by simply putting Î± (y) = Ïƒh	
âˆ’h
f (Î± (x)). A similar claim holds for Î². Thus, specifying
the maps for the leaves of the trees suffices, because any point in the tree is the ancestor of at least
one of the leaves. Hence, these maps have a representation that requires linear space in the size of
the trees.
Morozov et al. [17] prove several facts about interleaving distance that will prove useful in this
work. In particular, interleaving distance is a metric [17, Lemma 1]. Further, it is a stable distance
measure with respect to small function perturbations; specifically, given two functions f : X â†’ R
and Ğ´ : X â†’ R, we have dI (Mf , MĞ´ ) â‰¤  f âˆ’ Ğ´âˆ [17, Theorem 2].
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.
24:6 P. K. Agarwal et al.
3 HARDNESS OF APPROXIMATION
We now show the hardness of approximating the GH distance by a reduction from the following
decision problem called balanced partition (or BAL-PART for brevity): given a multiset of positive
integers X = {a1,..., an }, and an integer m such that 1 â‰¤ m â‰¤ n, is it possible to partition X into
m multisets {X1,...,Xm } such that all the elements in each multiset sum to the same quantity
Î¼ = (
n
i=1 ai )/m? We prove below that BAL-PART is strongly NP-complete, that is, it remains NPcomplete even if ai â‰¤ nc for some constant c â‰¥ 1 for all 1 â‰¤ i â‰¤ n.
Lemma 3.1. BAL-PART is strongly NP-complete.
Proof. We reduce 3-Partition, a strongly NP-complete problem [10] to BAL-PART. Given a
multiset of positive integers Y = {a1,..., an } with n = 3m, 3-Partition asks to partition Y into m
multisets {Y1,...,Ym } of size 3 each so that the elements in each multiset sum to the same quantity.
Given a 3-Partition instance, we construct an instance of BAL-PART as follows.
Basically, we add a sufficiently large number to each ai so that if two multisets of the new
numbers have the same sum, they have the same number of elements. In particular, let aÂ¯ = n
i=1 ai .
Then set a	
i = ai + aÂ¯ and X = {a	
1,..., a	
n }. This reduction takes polynomial time, and the new
numbers are polynomially larger than the original ones. We show that there exists an appropriate
partition of Y iff there exists an appropriate partition of X.
Suppose there exists an appropriate partition {Y1,...,Ym } of Y. Then setting Xi = {a	
j | aj âˆˆ Yi}
for i = 1,...,m gives us the desired partition of X.
Conversely, suppose there exists an appropriate partition {X1,...,Xm } of X. Suppose |Xi | =
n1 > |Xj | = n2 for some i  j. We thus have

a	
k âˆˆXi
ak + n1aÂ¯ =

a	
k âˆˆXj
ak + n2aÂ¯ â‡’ (n1 âˆ’ n2)aÂ¯ =

a	
k âˆˆXj
ak âˆ’

a	
k âˆˆXi
ak â‡’

a	
k âˆˆXj
ak âˆ’

a	
k âˆˆXi
ak â‰¥ aÂ¯,
(2)
a contradiction since
a	
k âˆˆXj ak < aÂ¯. Thus, each partition Xi is of equal size. Since n = 3m, the size
of each Xi is 3.
We now reduce an instance of BAL-PART, in which each ai â‰¤ nc for some constant c â‰¥ 1, to
GH-distance computation. Consider an instance X = {a1,..., an } and 1 â‰¤ m â‰¤ n of BAL-PART. If
m = 1, then a balanced partition into one multiset trivially exists. If m > 1, we construct two trees
T1 andT2 as follows. Let Î» > 8 and Ï < Î» âˆ’ 6 be two positive constants. LetTl,k denote a star graph
having k edges, each of length l. T1 has a node r1 incident to an edge (r1,r	
1) of length Ï and to n
edges {(r1,p1),..., (r1,pn )} of length 1. Each node pi is incident to another edge (pi,p	
i ) of length 1,
and each p	
i is the center of a copy of TÎ»,ai . T2 consists of a node r2 incident to an edge (r2,r	
2) of
length Ï and to m edges {(r2,q1),..., (r2,qm )} of length 2, where each qi is the center of a distinct
copy of TÎ»+1,aÂ¯, and aÂ¯ = (
n
i=1 ai )/m. See Figure 4 for an illustration. We refer to the edges of each
TÎ»,ai in T1 and the edges of copies of TÎ»+1,aÂ¯ in T2 as bottom edges. Let T1 and T2 denote the metric
trees associated with T1 and T2, respectively. Since Î», Ï are constants and ai â‰¤ nc for all 1 â‰¤ i â‰¤ n,
this construction can be done in polynomial time.
Lemma 3.2. If (X,m) is a yes instance of BAL-PART, then dGH (T1, T2) â‰¤ 1. Otherwise,
dGH (T1, T2) â‰¥ 3.
Proof. Suppose X can be partitioned into m subsets X1,...,Xm of equal weight aÂ¯ =
(
n
i=1 ai )/m. We construct a correspondence C between T1 and T2 with distortion at most 2, implying that dGH (T1, T2) â‰¤ 1. A linearly interpolated bijection between the points of edges (r1,r	
1) and
(r2,r	
2), withr1 mapping to r2 and r	
1 mapping to r	
2, is added to C. If ai âˆˆ Xj , the linearly interpolated
bijection between edges (r1,pi ) and (r2,qj) is added to C, with pi mapping to qj . Also, using linear
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.             
Computing the Gromov-Hausdorff Distance for Metric Trees 24:7
Fig. 4. The trees Tl,k , T1, and T2.
interpolation, we map the path frompi to each leaf ofTÎ»,ai to distinct edges going from qj to leaves
of its copy ofTÎ»+1,aÂ¯; this is possible sinceTÎ»+1,aÂ¯ has aÂ¯leaves, and
a âˆˆXj a = aÂ¯. Note that each edge
(pi,p	
i ) may be mapped to a contiguous part of multiple edges in T2. Overall, the distortion induced
by C is at most 2; this stems from the fact that C is piecewise linear, and the difference between the
length of any node-to-node path in one tree and its image under C in the other tree is at most 2.
Suppose dGH (T1, T2) < 3, and let C be a correspondence between T1 and T2 with distortion < 6.
Consider two leavesl1,l2  r	
2 in T2. Then d(l1,l2) â‰¥ 2Î» + 2. Letl	
1,l	
2 be their corresponding images
in T1 under C. We argue that l	
1,l	
2 lie on distinct bottom edges of T1. Indeed, since Dist(C) < 6, the
distance between l	
1 and l	
2 is d(l	
1,l	
2) > d(l1,l2) âˆ’ 6 â‰¥ 2Î» âˆ’ 4. If l	
1,l	
2 lie on the same edge of T1, then
d(l	
1,l	
2) â‰¤ Î» < 2Î» âˆ’ 4, so they have to lie on distinct edges of T1. If either of l	
1,l	
2 lies on an edge
r1pi , for some i â‰¤ n, then by construction, d(l	
1,l	
2) â‰¤ Î» + 4 < 2Î» âˆ’ 4 (recall that Î» > 8). Finally, if
either of l	
1,l	
2 lies on (r1,r	
1), then by the choice of Ï, d(l	
1,l	
2) â‰¤ Ï + Î» + 2 < 2Î» âˆ’ 4. Thus, both l	
1
and l	
2 lie on distinct bottom edges of T1. In particular, the corresponding image l	
1 in T1 of any one
leaf l1 in T2 must lie on a bottom edge of T1, because there exists some other leaf l2 in T2 by the
assumption that m > 1. Hence, C induces a bijection Ï‡ between the leaves of T1 and T2, where
Ï‡ (l) = l	 for l âˆˆ T2 and l	 âˆˆ T1 is the leaf whose incident edge contains the image(s) of l under C.
Note that if li,lj âˆˆ T2 are incident to qi,qj with qi  qj , then Ï‡ (li ) and Ï‡ (lj) are incident to pi	,pj	
with pi	  pj	; otherwise d(li,lj) = 2Î» + 6 and d(Ï‡ (li ), Ï‡ (lj)) â‰¤ 2Î», thereby incurring a distortion
of at least 6. Hence, the bijection Ï‡ can be used to partition X into m subsets X1,...,Xm of equal
weight as follows: if Ï‡ (l) = l	 for l incident to qi and l	 incident to pj , then aj âˆˆ Xi . Thus, (X,m)
is a yes instance of BAL-PART.
We may also apply the reduction to metric trees with unit edge lengths by subdividing longer
edges with an appropriate number of vertices. We thus have the following theorem.
Theorem 3.3. Unless P = NP, there is no polynomial-time algorithm to approximate the GH distance between two metric trees to a factor better than 3, even in the case of metric trees with unit edge
lengths.
4 GH AND INTERLEAVING DISTANCES
In this section, we show that the GH distance between two tree metric spaces T1 and T2, and
the interleaving distance between two appropriately defined trees induced by the Ti â€™s are within
constant factors of each other.
Given a metric tree T = (T,d), let V (T ) denote the nodes of the tree. Given a point s âˆˆ T (not
necessarily a node), let fs : T â†’ R be defined as fs (x) = âˆ’ d(s, x). Equipped with this function, we
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.     
24:8 P. K. Agarwal et al.
obtain a merge tree Ts from T . Intuitively, Ts has the structure of rooting T at s, and then adding
an extra edge incident to s with function value extending from 0 to +âˆ. If s is an internal node of
T or an interior point of an edge of T , s remains the root of Ts . But if s is a leaf of T , then s gets
merged with the infinite edge and the node of T adjacent to s becomes the root of Ts .
Let T1 = (T1,d1) and T2 = (T2,d2) be two metric trees. Define
Î” = min u âˆˆV (T1 ),v âˆˆV (T2 )
dI (T u
1 ,T v
2 ). (3)
We prove that Î” is within a constant factor of dGH (T1, T2). We first prove a lower bound on Î”.
Lemma 4.1. 1
2dGH (T1, T2) â‰¤ Î”.
Proof. Suppose Î” = dI (Ts
1 ,Tt
2 ) for some s âˆˆ V (T1) and t âˆˆ V (T2). Set f := fs and Ğ´ := ft . Let
Î± : Ts
1 â†’ Tt
2 , Î² : Tt
2 â†’ Ts
1 be Î”-compatible maps. We define the functions Î±âˆ— : Ts
1 â†’ Tt
2 and Î²âˆ— :
Tt
2 â†’ Ts
1 as follows:
Î±âˆ— (x) =

Î± (x) if Ğ´(Î± (x)) â‰¤ 0.
t otherwise. Î²âˆ— (y) =

Î² (y) if f (Î² (y)) â‰¤ 0.
s otherwise.
That is, if Î± (x) (Î² (y), respectively) is an ancestor of t (s, respectively), then x (y, respectively) is
mapped to the root t (s, respectively). We note that
f (x) â‰¤ Ğ´(Î±âˆ— (x)) â‰¤ f (x) + Î”,
Ğ´(y) â‰¤ f (Î²âˆ— (y)) â‰¤ Ğ´(y) + Î”. (4)
Indeed, if Î±âˆ— (x) = Î± (x), then Ğ´(Î±âˆ— (x)) = f (x) + Î”. Otherwise, Ğ´(Î± (x)) > 0 and Ğ´(Î±âˆ— (x)) = 0. Since
f (x) â‰¤ 0, we obtain Ğ´(Î±âˆ— (x)) < Ğ´(Î± (x)) = f (x) + Î”. The same argument implies the second set of
inequalities.
Consider the correspondence C âˆˆ T1 Ã—T2 induced by Î±âˆ— and Î²âˆ— defined as
C := {(x, Î±âˆ— (x)) | x âˆˆ T1}âˆª{(Î²âˆ— (y),y) | y âˆˆ T2}.
We prove that Dist(C) â‰¤ 4Î”.
Indeed, consider any two pairs (x1,y1), (x2,y2) âˆˆ C. Let u be the least common ancestor of x1
and x2 in T1 (if T1 is rooted at s), and w the least common ancestor of y1 and y2 in T2 (if T2 is
rooted at t). Note that since T1 and T2 are trees, there is a unique path x1  u  x2 between x1
and x2, such that x1  u and u  x2 are each monotone in function f values. This also implies
that d1 (x1,u) = d1 (s, x1) âˆ’ d1 (s,u) = f (u) âˆ’ f (x1); similarly, d1 (x2,u) = f (u) âˆ’ f (x2). Symmetric
statements hold for y1  w  y2. Hence
d1 (x1, x2) = d1 (x1,u) + d1 (u, x2) = 2f (u) âˆ’ f (x1) âˆ’ f (x2),
d2 (y1,y2) = d2 (y1,w) + d2 (w,y2) = 2Ğ´(w) âˆ’ Ğ´(y1) âˆ’ Ğ´(y2).
We then have
|d1 (x1, x2) âˆ’ d2 (y1,y2)| = |2f (u) âˆ’ f (x1) âˆ’ f (x2) âˆ’ 2Ğ´(w) + Ğ´(y1) + Ğ´(y2)|
â‰¤ 2|f (u) âˆ’ Ğ´(w)| + |f (x1) âˆ’ Ğ´(y1)| + |f (x2) âˆ’ Ğ´(y2)|
â‰¤ 2|f (u) âˆ’ Ğ´(w))| + 2Î” (by Equation (4)).
We now wish to bound |f (u) âˆ’ Ğ´(w)|. Consider the case where y1 = Î±âˆ— (x1),y2 = Î±âˆ— (x2). As we
traverse the path x1  u  x2, the image of this path under Î±âˆ— is a path y1  Î±âˆ— (u)  y2, where
y1  Î±âˆ— (u) and Î±âˆ— (u)  y2 are each monotone in function Ğ´ values. Hence, Î±âˆ— (u) is an ancestor
of y1 and y2. Since w is the least common ancestor of y1 and y2, we have that Î±âˆ— (u) must be an
ancestor of w. The same claim can be similarly proved for the remaining cases. Further, it can
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.            
Computing the Gromov-Hausdorff Distance for Metric Trees 24:9
be similarly shown that Î²âˆ— (w) must be an ancestor of u. Thus, f (u) âˆ’ Î” â‰¤ Ğ´(w) â‰¤ f (u) + Î” â‡’
|f (u) âˆ’ Ğ´(w)| â‰¤ Î”. We thus have
|d1 (x1, x2) âˆ’ d2 (y1,y2)| â‰¤ 4Î”.
It then follows that Dist(C) â‰¤ 4Î”. Since dGH (T1, T2) â‰¤ 1
2Dist(C), the lemma follows.
Next, we prove an upper bound on Î”.
Lemma 4.2. Î” â‰¤ 14dGH (T1, T2).
Proof. Set Î´ = dGH (T1, T2) and let Câˆ— : T1 Ã—T2 be an optimal correspondence that achieves
dGH (T1, T2). Note that in general dGH (T1, T2) may only be achieved in the limit. In that case,
our proof can be modified by considering a near-optimal correspondence of distortion Î´ =
dGH (T1, T2) + Îµ for some arbitrary Îµ > 0.
Let s be one of the endpoints of a longest simple path in T1 (i.e., the length of this path realizes
the diameter of T1); s is necessarily a leaf of T1. Let (s,t) be a pair in Câˆ—. Consider the merge trees
Ts
1 and Tt
2 defined by the functions fs and ft , respectively. A result by Dey et al. [8, Corollary 6]
(see also [9]) implies that
dI (Ts
1 ,Tt
2 ) â‰¤ 6Î´ .
We prove below in Claim 4.3 that there is a vertex (in fact, a leaf) z âˆˆ V (T2) such that d2 (t, z) â‰¤ 8Î´.
It is easy to verify that
 ft âˆ’ fz âˆ â‰¤ d2 (t, z) â‰¤ 8Î´ .
On the other hand, by the stability theorem of the interleaving distance,
dI (Tt
2 ,Tz
2 ) â‰¤  ft âˆ’ fz âˆ â‰¤ 8Î´ .
By the triangle inequality,
dI (Ts
1 ,Tz
2 ) â‰¤ dI (Ts
1 ,Tt
2 ) + dI (Tt
2 ,Tz
2 )
â‰¤ 6Î´ + 8Î´
â‰¤ 14Î´ .
This completes the proof of the lemma.
Claim 4.3. Let s be an endpoint of a longest simple path in T1, and let (s,t) be a pair in Câˆ—. Then
there is a vertex z âˆˆ V (T2) such that d2 (t, z) â‰¤ 8Î´.
Proof. Assume that there is no tree node within 8Î´ distance to t. In this case, t must be in the
interior of an edge e âˆˆ E(T2). Let u1 and u2 be the two points in e from opposite sides of t such
that d2 (t,u1) = d2 (t,u2) = 8Î´ + Î½, where Î½ > 0 is an arbitrarily small value. Both u1 and u2 exist,
as there is no tree node of T2 within 8Î´ distance to t, and
d2 (u1,u2) = d2 (t,u1) + d2 (t,u2) = 16Î´ + 2Î½ .
Let uËœ1,uËœ2 âˆˆ T1 be any corresponding points for u1 and u2 under Câˆ—, that is, (uËœ1,u1), (uËœ2,u2) âˆˆ Câˆ—.
Since Dist(Câˆ—) â‰¤ 2Î´, we have
d1 (uËœ1,uËœ2) â‰¥ 14Î´ + 2Î½ . (5)
On the other hand, since d2 (t,u1) = d2 (t,u2) = 8Î´ + Î½, we have that
d1 (s,uËœ1),d1 (s,uËœ2) âˆˆ [6Î´ + Î½, 10Î´ + Î½]. (6)
We now obtain an upper bound on d1 (uËœ1,uËœ2).
If uËœ1 and uËœ2 have ancestor/descendant relation in Ts
1 , then d1 (uËœ1,uËœ2) = |d1 (s,uËœ1) âˆ’ d1 (s,uËœ2)| and
by Equation (6), we thus have that d1 (uËœ1,uËœ2) â‰¤ 4Î´, which contradicts Equation (5). Otherwise, if uËœ1
and uËœ2 do not have ancestor/descendant relation, let w be the nearest common ancestor of uËœ1 and
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.  
24:10 P. K. Agarwal et al.
Fig. 5. w is the nearest common ancestor of uËœ1 and uËœ2 in Ts
1 .
uËœ2 in Ts
1 (see Figure 5). Let c0 = d1 (s,w). For simplicity, set a = d1 (s,uËœ1) and b = d1 (s,uËœ2). It then
follows that
d1 (uËœ1,uËœ2) = a + b âˆ’ 2c0.Note,a â‰¥ c0,b â‰¥ c0. (7)
Since s is an endpoint of the longest path in T1, it follows that c0 â‰¥ min{a âˆ’ c0,b âˆ’ c0}. Indeed, if
this were not the case, then without loss of generality, suppose the other point s	 of the diameter
pair is not in the subtree of Ts
1 rooted at uËœ1. We then have
d1 (uËœ1,s	
) = (a âˆ’ c0) + (b âˆ’ c0) > c0 + (b âˆ’ c0) = d1 (s,s	
), (8)
a contradiction. By Equation (6), a,b â‰¥ 6Î´ + Î½. Thus,
c0 â‰¥ min{a âˆ’ c0,b âˆ’ c0} â‰¥ 6Î´ + Î½ âˆ’ c0 â‡’ c0 â‰¥
1
2
(6Î´ + Î½ ). (9)
Combining Equations (7) and (9), we have
d1 (uËœ1,uËœ2) â‰¤ a + b âˆ’ 6Î´ âˆ’ Î½ â‰¤ 20Î´ + 2Î½ âˆ’ 6Î´ âˆ’ Î½ = 14Î´ + Î½, (10)
contradicting Equation (5). Thus, there exists z âˆˆ V (T2) such that d2 (t, z) â‰¤ 8Î´.
Remark. The proof of Claim 4.3 actually shows that t lies within distance 8Î´ of at least one leaf,
as we never use the fact that u1 and u2 lie on the same edge of T2. The only fact we use is that u1
and u2 lie on opposite sides of t at distance 8Î´ + Î½ each.
From Lemmas 4.1 and 4.2, we get the following.
Theorem 4.4. Let Î” = minu âˆˆV (T1 ),v âˆˆV (T2 ) dI (T u
1 ,T v
2 ). Then
1
2
dGH (T1, T2) â‰¤ Î” â‰¤ 14dGH (T1, T2).
In order to approximate dGH (T1, T2), we merely need to approximate the interleaving distance
for each of the O(n2) pairs of merge trees obtained by rooting T1 and T2 at each of their vertices.
Corollary 4.5. If there is a polynomial time,c-approximation algorithm for the interleaving distance between two merge trees, then there is a polynomial time, 28c-approximation algorithm for the
GH distance between two metric trees that runs the algorithm for interleaving distance O(n2) times.
5 COMPUTING THE INTERLEAVING DISTANCE
Let Mf and MĞ´ be merge trees of two functions f and Ğ´, respectively. For simplicity, we use f and
Ğ´ to denote the height functions on Mf and MĞ´ as well. Let n be the total number of nodes in Mf
and MĞ´, and let r â‰¥ 1 be the ratio between the lengths of the longest and the shortest edges in Mf
and MĞ´. We describe a O(min{n,
âˆš
rn})-approximation algorithm for computing dI (Mf , MĞ´ ).
Candidate values and binary search. We first show that a candidate set Î› of O(n2) values can
be computed in O(n2) time such that dI (Mf , MĞ´ ) âˆˆ Î›. Given Î›, we perform a binary search on Î›.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018. 
Computing the Gromov-Hausdorff Distance for Metric Trees 24:11
Fig. 6. Trees Mf and MĞ´. Here Î´v = min{ 1
2 Îµ1,Îµ2}.
At each step, we use a c-approximate decision procedure, forc = c1 min{n,
âˆš
rn} for some constant
c1, that given a value Îµ > 0 does the following: if dI (Mf , MĞ´ ) â‰¤ Îµ, it returns a pair ofcÎµ-compatible
maps between Mf and MĞ´; if dI (Mf , MĞ´ ) > Îµ, it will either return a pair of cÎµ-compatible maps
between Mf and MĞ´ or report that no pair of Îµ-compatible maps exist.
We perform the binary search using the c-approximate decision procedure in the following way:
if the procedure returns a pair of cÎµ-compatible maps for a value Îµ âˆˆ Î›, we continue the search
using only lesser values of Îµ. Otherwise, we continue the search using only higher values of Îµ.
When there are no more candidate values to search, we return the maps for the minimum value
of Îµ that yielded a pair of maps.
The above procedure returns a pair of cÎµ-compatible maps where dI (Mf , MĞ´ ) â‰¤ cÎµ â‰¤
cdI (Mf , MĞ´ ). Indeed, the procedure does not run out of candidate values Îµ < dI (Mf , MĞ´ ) until
it has tried some Îµ	 â‰¤ dI (Mf , MĞ´ ) for which the approximate decision procedure returned a pair
of cÎµ	
-compatible maps. We now describe the candidate set Î›.
LetVf (VĞ´, respectively) be the set of nodes in Mf (MĞ´, respectively). We define Î› = Î›11 âˆª Î›22 âˆª
Î›12, where
Î›11 = { 1
2 |f (u) âˆ’ f (v)| | u,v âˆˆ Vf },
Î›22 = { 1
2 |Ğ´(u) âˆ’ Ğ´(v)| | u,v âˆˆ VĞ´ },
Î›12 = {|f (u) âˆ’ Ğ´(v)| | u âˆˆ Vf ,v âˆˆ VĞ´ }.
Lemma 5.1. dI (Mf , MĞ´ ) âˆˆ Î›.
Proof. Suppose to the contrary that dI (Mf , MĞ´ ) = Îµ  Î›. Let Î± : Mf â†’ MĞ´ and Î² : MĞ´ â†’ Mf
be Îµ-compatible maps that realize dI (Mf , MĞ´ ) = Îµ. We will obtain a contradiction by choosing
Îµ0 > 0 and constructing (Îµ âˆ’ Îµ0)-compatible maps Î±Ë†, Ë†
Î².
For any point x âˆˆ Mf , we define Î±â†“(x) = Î± (x) if Î± (x) is a node of MĞ´, otherwise Î±â†“(x) is the
lower endpoint of the edge of MĞ´ containing Î± (x). Similarly we define the function Î²â†“ : MĞ´ â†’ Mf .
For every node v âˆˆ Vf , Î± (v) (Î² (Î± (v)), respectively) lies in the interior of an edge of MĞ´ (Mf ,
respectively), because Îµ  Î› âŠ‡ Î›12 (Î›11, respectively). We define
Î´v = min  1
2

f (Î² (Î± (v))) âˆ’ f (Î²â†“(Î± (v))),Ğ´(Î± (v)) âˆ’ Ğ´(Î±â†“(v))
.
See Figure 6. Similarly, we define Î´w for all w âˆˆ VĞ´. We set
Îµ0 = min 
Îµ, min v âˆˆVf âˆªVĞ´
Î´v

.
Since Îµ  Î›, we have Îµ0 > 0. We now construct (Îµ âˆ’ Îµ0)-compatible maps Î±Ë† : Mf â†’ MĞ´ and
Ë†
Î² : MĞ´ â†’ Mf (note Îµ0 â‰¤ Îµ, so Îµ âˆ’ Îµ0 is non-negative). We describe the construction of Î±Ë†; Ë†
Î² is
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.  
24:12 P. K. Agarwal et al.
Fig. 7. Figure showing u,v, x,y, and y	
.
constructed similarly. By construction, for any node u âˆˆ Vf , Ğ´(Î± (u)) âˆ’ Ğ´(Î±â†“(u)) â‰¥ Îµ0, so we set
Î±Ë†(u) to be the point w on the edge of MĞ´ containing Î± (u) such that Ğ´(w) = f (u) + Îµ âˆ’ Îµ0. Once
we have defined Î±Ë†(u) and Î±Ë†(v) for an edge uv âˆˆ Mf , with f (u) < f (v), we set Î±Ë†(x), for a point
x âˆˆ uv with f (x) = f (u) +Î³ , to be
Î±Ë†(x) = ÏƒÎ³
Ğ´ (Î±Ë†(u)).
That is, we set Î±Ë†(x) to be the ancestor of Î±Ë†(u) at height f (u) + Îµ âˆ’ Îµ0 +Î³ = f (x) + Îµ âˆ’ Îµ0. Now, it is
not too hard to see that if x1 is an ancestor of x2 in Mf , then Î±Ë†(x1) is an ancestor of Î±Ë†(x2) (similarly
for Ë†
Î²). Further, Ë†
Î² (Î±Ë†(x1)) is a descendant of Î² (Î± (x1)) for all x1 âˆˆ Mf (a similar result holds for Î±Ë† â—¦ Ë†
Î²
and Î± â—¦ Î²).
We claim that Î±Ë†, Ë†
Î² are (Îµ âˆ’ Îµ0)-compatible. Indeed, by construction, Ğ´(Î±Ë†(x)) = f (x) + Îµ âˆ’ Îµ0 for
all x âˆˆ Mf , and f ( Ë†
Î² (y)) = Ğ´(y) + Îµ âˆ’ Îµ0 for all y âˆˆ MĞ´. We now prove that
Ë†
Î² â—¦ Î±Ë† = Ïƒ2(Îµâˆ’Îµ0 )
f .
Suppose to the contrary there is a point x âˆˆ Mf such that y = Ë†
Î² (Î±Ë†(x))  Ïƒ2(Îµâˆ’Îµ0 )
f (x). Since
f (y) = f (x) + 2(Îµ âˆ’ Îµ0), y must not be an ancestor of x. On the other hand, Î±, Î² are Îµ-compatible,
so y	 = Î² (Î± (x)) is the ancestor of x at height f (x) + 2Îµ. By construction of Î±Ë† and Ë†
Î², y is a descendant of y	
, in which case there is a node u âˆˆ Vf that lies between y and y	
. (If y and y	 lie on the
same edge of Mf , then y is also an ancestor of x.) Let u = Î²â†“(Î± (x)). Let v be the lower endpoint of
the edge e containing x. See Figure 7. Since Îµ  Î›, f (u)  f (v) + 2Îµ (i.e., u  Î² (Î± (v))). There are
two cases to consider:
(i) f (u) > f (v) + 2Îµ. Then let u = Î² (Î± (z)) for the point z lying between x and v at
height f (z) = f (u) âˆ’ 2Îµ. Furthermore, f (x) â‰¥ f (z) > f (x) âˆ’ 2Îµ0 (if f (x) âˆ’ f (z) â‰¥ 2Îµ0, then
f (y	
) âˆ’ f (u) = f (x) âˆ’ f (z) â‰¥ 2Îµ0, contradicting the fact that f (y	
) âˆ’ f (y) = 2Îµ0). Therefore, we can choose a point w  v on e such that f (z) > f (w) > f (x) âˆ’ 2Îµ0. We have
Ë†
Î² (Î±Ë†(w)) is a descendant of y = Ë†
Î² (Î±Ë†(x)) (sincew is a descendant of x). Moreover, Î² (Î± (w)) is
an ancestor of Ë†
Î² (Î±Ë†(w)). However, since f (Î² (Î± (w))) < f (u), Î² (Î± (w)) lies between y and u.
Thus, Î² (Î± (w)) is not an ancestor of x (hence, w), that is, Î² (Î± (w))  Ïƒ2Îµ
f (w), contradicting
the fact that Î±, Î² are Îµ-compatible.
(ii) f (u) < f (v) + 2Îµ. In this case
f (Î² (Î± (v))) âˆ’ f (Î²â†“(Î± (v))) â‰¤ f (Î² (Î± (v))) âˆ’ f (u) < f (y	
) âˆ’ f (y) = 2Îµ0 â‰¤ 2Î´v ,
which contradicts the definition of Î´v .
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.     
Computing the Gromov-Hausdorff Distance for Metric Trees 24:13
Hence, we conclude that y is an ancestor of x, that is, Ë†
Î² â—¦ Î±Ë† = Ïƒ2(Îµâˆ’Îµ0 )
f . Similarly, one can argue
that Î±Ë† â—¦ Ë†
Î² = Ïƒ2(Îµâˆ’Îµ0 )
Ğ´ , implying that Î±Ë†, Ë†
Î² are (Îµ âˆ’ Îµ0)-compatible maps as claimed.
Putting everything together, we conclude that Îµ âˆˆ Î›.
We now describe the decision procedure to answer the question â€œis dI (Mf , MĞ´ ) â‰¤ Îµ?â€ approximately. Given a parameter Îµ > 0, an edge is called Îµ-long, or long for brevity, if its length is strictly
greater than 2Îµ. We first describe an exact decision procedure for the case when all edges in both
trees are long, and then describe an approximate decision procedure for the case when the two
trees have short edges.
Trees with long edges. We remove all degree-two nodes in the beginning. A subtree rooted at a
point x in a merge tree M, denoted Mx , includes all the points in the merge tree that are descendants
of x and an edge from x that extends upward to height âˆ. For a node u âˆˆ V , let C(u) denote the
children of u and let p(u) denote its parent. Assume dI (Mf , MĞ´ ) â‰¤ Îµ, and let Î± : Mf â†’ MĞ´ and
Î² : MĞ´ â†’ Mf be a pair ofÎµ-compatible maps. As in the proof of Lemma 5.1, we define the functions
Î±â†“ and Î²â†“ but restricted only to the vertices of Mf and MĞ´. That is, for a node v âˆˆ Vf , we define
Î±â†“(v) to be the lower endpoint of the edge containing Î± (v)â€”if Î± (v) is a node, then Î±â†“(v) is Î± (v)
itself. Similarly, we define Î²â†“(w), for a node w âˆˆ VĞ´.
The following two properties of Î±â†“ and Î²â†“ will be crucial for the decision procedure.
Lemma 5.2. If all edges in Mf and MĞ´ are Îµ-long, then the following hold: (i) For a node v âˆˆ Vf ,
|f (v) âˆ’ Ğ´(Î±â†“(v))| â‰¤ Îµ, and (ii) for a node w âˆˆ VĞ´, |Ğ´(w) âˆ’ f (Î²â†“(w))| â‰¤ Îµ.
Proof. We will prove part (i); part (ii) is similar. By definition, Ğ´(Î±â†“(v)) â‰¤ f (v) + Îµ. Suppose
Ğ´(Î±â†“(v)) < f (v) âˆ’ Îµ. Let v	 be a point in MĞ´ lying on the edge containing Î± (v) and Î±â†“(v) with
height f (v) âˆ’ Îµ âˆ’ Îµ0, for some sufficiently small Îµ0. Then Î² (v	
) lies in one of the subtrees rooted
at the children of v, say M1. Consider a descendant u of v at height Ğ´(v	
) âˆ’ Îµ lying in a different
subtree M2 rooted at vâ€™s child. Such a descendant exists, because all edges are Îµ-long. Since by
definition and our choice of v	 there does not exist any node in MĞ´ between Î± (v) and v	
, we have
Î± (u) = v	
. But then Î² (Î± (u)) = Î² (v	
) lies in M1, and hence is not an ancestor of u âˆˆ M2; in other
words, Î² (Î± (u))  Ïƒ2Îµ
f (u). This contradicts the fact that Î± and Î² are Îµ-compatible. Thus, Ğ´(Î±â†“(v)) â‰¥
f (v) âˆ’ Îµ, and the claim follows.
Lemma 5.3. If all edges in Mf and MĞ´ are Îµ-long, then Î±â†“ and Î²â†“ are bijections with Î²â†“ = Î±âˆ’1
â†“ (and
Î±â†“ = Î²âˆ’1
â†“ ).
Proof. We will first show that Î²â†“ = Î±âˆ’1
â†“ . Suppose to the contrary there exists a vertex v âˆˆ Vf
such that Î²â†“(Î±â†“(v)) = w  v. Let Î±â†“(v) = u, for u âˆˆ VĞ´. From Lemma 5.2 we have |f (v) âˆ’ f (w)| â‰¤
2Îµ. Since all edges are longer than 2Îµ and v  w, v cannot be an ancestor/descendant of w in Mf .
By definition of Î±â†“, Î± (v) is an ancestor of Î±â†“(v) = u. Thus, Î² (Î± (v)) is an ancestor of Î² (u). Further,
|f (v) âˆ’ Ğ´(u)| â‰¤ Îµ (Lemma 5.2) and Î² (Î± (v)) = Ïƒ2Îµ
f (v) (since Î±, Î² are Îµ-compatible). Hence, Î² (u) lies
between v and Î² (Î± (v)) on the edge e whose lower endpoint is v as e is Îµ-long. Thus, Î² (u) is an
ancestor of v. See Figure 8. Also by definition of Î²â†“, Î² (u) is an ancestor of Î²â†“(u) = w. Thus, w is a
descendant of v, a contradiction since v cannot be an ancestor of w.
We thus have Î²â†“ = Î±âˆ’1
â†“ . Similarly, we can show that Î±â†“ = Î²âˆ’1
â†“ . This also implies that Î±â†“ and Î²â†“
are bijections.
We define an indicator function Î¦ : Vf Ã—VĞ´ â†’ {0, 1} such that
Î¦(u,v) =

1, if dI (Mu
f , Mv
Ğ´ ) â‰¤ Îµ,
0, otherwise.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.      
24:14 P. K. Agarwal et al.
Fig. 8. Figure showing Î² (u) = Î² (Î±â†“(v)) is an ancestor of v.
The following lemma gives a recursive definition of Î¦(u,v).
For two integers, k and  with k â‰¤ , let [k, ] = {k, k + 1,...,}.
Lemma 5.4. Suppose all the edges in Mf and MĞ´ are Îµ-long. Let (u,v) âˆˆ Vf Ã—VĞ´, and let ui and vj
denote the i-th and j-th child, respectively, of u and v. We have Î¦(u,v) = 1 if and only if the following
conditions hold : (i) |f (u) âˆ’ Ğ´(v)| â‰¤ Îµ, (ii) |C(u)| = |C(v)|, and (iii) there exists a permutation Ï€ of
[1 : |C(u)|] such that Î¦(ui,vÏ€ (i)) = 1 for all i âˆˆ [1 : |C(u)|].
Proof. Suppose Î¦(u,v) = 1, and let Î±, Î² be the corresponding Îµ-compatible maps. Suppose
property (i) does not hold, and let f (u) > Ğ´(v) + Îµ without loss of generality. Thus, Î² (v) maps to
one of the multiple edges incident to u, and there exists at least one edge e = (u,w) with w âˆˆ C(u)
such that none of eâ€™s points (other than u) is in the image of Î². However, Î² (Î± (w)) = Ïƒ2Îµ
f (w) must
lie in the interior of e (since e is Îµ-long), a contradiction. To prove that (ii) holds, note that by
Lemma 5.3 and monotonicity of Î±â†“ and Î²â†“, there exist bijections Î±â†“, Î²â†“ between the vertices of
Mu
f and Mv
Ğ´ such that if u1 âˆˆ C(u2) for a vertex u2 âˆˆ Mu
f , then Î±â†“(u1) âˆˆ C(Î±â†“(u2)) (a symmetric
statement holds for Î²â†“ and vertices in Mv
Ğ´ ). Thus, Î±â†“, Î²â†“ induce bijections between C(u) and C(v),
and hence |C(u)| = |C(v)|. Finally, for (iii), let Î±â†“(u	
) = v	 for some u	 âˆˆ C(u),v	 âˆˆ C(v). Then by
definition of Î±â†“ and Î²â†“, Î± (Mu	
f ) âŠ† Mv	
Ğ´ and Î² (Mv	
Ğ´ ) âŠ† Mu	
f . This means that the restriction of the
pair of Îµ-compatible maps Î± and Î² to Mu	
f and Mv	
Ğ´ , respectively, remain Îµ-compatible for Mu	
f and
Mv	
Ğ´ . Thus, Î¦(u	
,v	
) = 1, and the permutation Ï€ is defined by Î±â†“, Î²â†“.
We now prove the opposite direction. Suppose properties (i), (ii), and (iii) hold. Let (Î±i, Î²i ) be
the pair of Îµ-compatible maps between Mui
f and MvÏ€ (i)
Ğ´ . Then, a pair of Îµ-compatible maps (Î±, Î²)
between Mu
f and Mv
Ğ´ is obtained as follows: Î± (x) = {Î±i (x) | x âˆˆ Mui
f } (Î² is defined similarly). Note
that points on the infinite edge from u (v, respectively) upward are shared among all Mui
f (Mvj
Ğ´ ,
respectively), whereas all other points in Mu
f (Mv
Ğ´ , respectively) are present in only one Mui
f (Mvj
Ğ´ ,
respectively). However, since |f (u) âˆ’ Ğ´(v)| â‰¤ Îµ, shared points are mapped to shared points and we
have |Î± (x)| = 1 (|Î² (y)| = 1|, respectively) for all x âˆˆ Mu
f (y âˆˆ Mv
Ğ´ , respectively). Thus, Î± and Î² are
functions and satisfy all the required properties. Hence, Î¦(u,v) = 1.
Decision procedure. We compute Î¦ for all pairs of nodes in Vf Ã—VĞ´ in a bottom-up manner and
return Î¦(rf ,rĞ´ ) where rf (rĞ´, respectively) is the root of Mf (MĞ´, respectively). Let (u,v) âˆˆ Vf Ã—VĞ´.
Suppose we have computed Î¦(ui,vj) for all ui âˆˆ C(u) and vj âˆˆ C(v). We compute Î¦(u,v) as
follows. If (i) or (ii) of Lemma 5.4 does not hold for u and v, then we return Î¦(u,v) = 0. Otherwise,
we construct the bipartite graph Guv = {C(u) âˆªC(v), E = {(ui,vj) | Î¦(ui,vj) = 1}} and determine
in O(k5/2) time whether Guv has a perfect matching, using the algorithm by Hopcroft and Karp
[13]. Here, k = |C(u)| = |C(v)|. IfGuv has a perfect matching M = {(u1,vÏ€ (1)),..., (uk ,vÏ€ (k) )}, we
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.     
Computing the Gromov-Hausdorff Distance for Metric Trees 24:15
Fig. 9. A naive map.
set Î¦(u,v) = 1, else we set Î¦(u,v) = 0. If Î¦(u,v) = 1, we use the Îµ-compatible maps for Mui
f , MvÏ€ (i)
Ğ´ ,
for 1 â‰¤ i â‰¤ k, to compute a pair of Îµ-compatible maps between Mu
f and Mv
Ğ´ , as discussed in the
proof of Lemma 5.4.
For a node u âˆˆ Vf âˆªVĞ´, let ku be the number of its children. The total time taken for running
Hopcroft and Karp [13] is

u âˆˆV (T1 )

v âˆˆV (T2 )
O 	
kukv


kv

=

u âˆˆV (T1 )
ku

v âˆˆV (T2 )
O 	
kv


kv

â‰¤ O 	
n3/2

u âˆˆV (T1 )
ku â‰¤ O 	
n5/2

.
Hence, we obtain the following.
Lemma 5.5. Given two merge trees Mf and MĞ´ and a parameter Îµ > 0 such that all edges of Mf
and MĞ´ are Îµ-long, then whether dI (Mf , MĞ´ ) â‰¤ Îµ can be determined in O(n5/2) time. If the answer is
yes, a pair of Îµ-compatible maps between Mf and MĞ´ can be computed within the same time.
Trees with short edges. Given two merge trees, a naive map is to map the lowest among all the
leaves in both the trees to a point at height equal to the height of the higher of the two roots of
Mf and MĞ´ (see Figure 9). Thus, all the points in one tree will be mapped to the infinitely long
edge on the other tree. This map produces a distortion equal to the height of the trees, which can
be arbitrarily larger than the optimum. Nevertheless, this simple idea leads to an approximation
algorithm.
Here is an outline of the algorithm. After carefully trimming off short subtrees from the input
trees, the algorithm decomposes the resulting trimmed trees into two kinds of regions: those with
nodes and those without nodes. If the interleaving distance between the input trees is small, then
there exists an isomorphism between trees induced by the regions without nodes. Using this isomorphism, the points in the nodeless regions are mapped without incurring additional distortion.
Using a counting argument and the naive map described above, it is shown that the distortion
incurred while mapping the regions with nodes and the trimmed regions is bounded.
More precisely, given Mf , MĞ´ and Îµ > 0, define the extent e (x) of a point x (which is not necessarily a tree node) in Mf or MĞ´ as the maximum height difference between x and any of its
descendants. Suppose each edge is at most sÎµ long. Let M	
f and M	
Ğ´ be subsets of Mf and MĞ´ consisting only of points with extent at least 2(
âˆš
2ns + 1)Îµ, adding nodes to the new leaves of M	
f and
M	
Ğ´ as necessary. Note that M	
f and M	
Ğ´ themselves are trees; however, they might contain nodes
of degree 2. See Figure 10 for an example.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.     
24:16 P. K. Agarwal et al.
Fig. 10. Trimming a tree: (left) original tree, red points have extent < 2(
âˆš
2ns + 1)Îµ; (right) trimmed tree,
nodes added at the bottom (hollowed nodes).
Lemma 5.6. If dI (Mf , MĞ´ ) â‰¤ Îµ, then dI (M	
f , M	
Ğ´ ) â‰¤ Îµ.
Proof. Let Î± : Mf â†’ MĞ´ and Î² : MĞ´ â†’ Mf be Îµ-compatible maps. Let Î±	 and Î²	 be restrictions
of the functionsâ€™ domains to M	
f and M	
Ğ´, respectively. We argue that the ranges of Î±	 and Î²	
lie in M	
Ğ´ and M	
f , respectively. Suppose otherwise. Then without loss of generality, there is a
point x âˆˆ M	
f with y = Î± (x) not in M	
Ğ´. Because x âˆˆ M	
f , its extent in Mf is at least 2(
âˆš
2ns + 1)Îµ.
Therefore, there exists a descendant x 	 of x in Mf with f (x 	
) = f (x) âˆ’ 2(
âˆš
2ns + 1)Îµ. Because y is
not in M	
Ğ´, the extent of y must be less than 2(
âˆš
2ns + 1)Îµ and there exists no descendant y	 of y
with Ğ´(y	
) = Ğ´(y) âˆ’ 2(
âˆš
2ns + 1)Îµ = f (x) âˆ’ 2(
âˆš
2ns + 1)Îµ + Îµ = f (x 	
) + Îµ. Since Ğ´(Î± (x 	
)) = f (x 	
) +
Îµ, Î± (x 	
) is not a descendant of Î± (x), which contradicts the assumption that Î±, Î² are Îµ-compatible
maps.
The above lemma can be easily generalized to say that removing points in both trees with extent
less than or equal to any fixed value does not increase the distance between them.
We now define matching points in M	
f and M	
Ğ´. Let H be the set of function values for leaves
and branching nodes in M	
f or M	
Ğ´, and let H	 âŠ† H be the subset of H consisting of function values
h for which (h,h + 2Îµ] does not intersect H. A point x in M	
f is a matching point if f (x) âˆˆ H	
.
Similarly, a point y in M	
Ğ´ is a matching point if Ğ´(y) âˆˆ H	
. By this definition, no two matching
points share a function value within 2Îµ of each other unless they share the exact same function
value. Furthermore, if x is a matching point, then all points with the same function value as x on
both M	
f and M	
Ğ´ are matching points. There are O(n2) matching points.
Suppose dI (M	
f , M	
Ğ´ ) â‰¤ Îµ, and let Î±	 : M	
f â†’ M	
Ğ´ and Î²	 : M	
Ğ´ â†’ M	
f be a pair of Îµ-compatible
maps. Call a matching point x in M	
f and a matching point y in M	
Ğ´ with f (x) = Ğ´(y) matched if
Î±	
(x) is an ancestor of y.
Lemma 5.7. Let x be any matching point in M	
f . The matched relation between matching points in
M	
f at height f (x) and matching points in M	
Ğ´ at height f (x) is a bijective function.
Proof. No two distinct matching points y1 and y2 on M	
Ğ´ with f (x) = Ğ´(y1) = Ğ´(y2) share the
same ancestor with function value f (x) + Îµ, because they have no branching node ancestors with
low enough function value. Therefore, a matching point in M	
f can be matched to only one matching point in M	
Ğ´.
Let x1 and x2 be two distinct matching points from M	
f with f (x) = f (x1) = f (x2). If Î±	
(x1)
and Î±	
(x2) are ancestors of a common matching point y, then Î±	
(x1) = Î±	
(x2) and thus x1 and x2
must have a common ancestor x 	 at height f (x) + 2Îµ. However, x1 and x2 have no branching node
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018. 
Computing the Gromov-Hausdorff Distance for Metric Trees 24:17
Fig. 11. The left tree shows matching points on tree M	
f and the right tree shows MËœ f .
ancestor with low enough function value for x 	 to exist. Hence, the matching relation must be
injective from matching points in M	
f to M	
Ğ´.
Finally, consider any matching point y on M	
Ğ´ with Ğ´(y) = f (x). Point x 	
1 = Î²	
(y) is the ancestor
of a matching point x1 on M	
f with f (x1) â‰¥ Ğ´(y). (Note that by the same argument as the beginning
of this proof, only one such matching point x1 can exist.) Point y	 = Î±	
(x 	
1) is an ancestor of y with
Ğ´(y	
) â‰¤ Ğ´(y) + 2Îµ. Point y is the only descendant of y	 with function value f (x). Point Î±	
(x1) must
be an ancestor of y, meaning x1 and y are matched. Thus, the matching relation is surjective.
We now define a rooted tree MËœ f to be a rooted tree consisting of one node per matching point on
M	
f . Let p(v) be the matching point for node v. MËœ f has node v as an ancestor of node u if p(v) is an
ancestor of p(u) (see Figure 11). Define MËœ Ğ´ similarly. The size of MËœ f and MËœ Ğ´ is O(n2). Intuitively,
MËœ f and MËœ Ğ´ represent the trees induced by matching points. By the definition of interleaving distance and Lemma 5.7, MËœ f and MËœ Ğ´ are isomorphic if M	
f and M	
Ğ´ satisfy that dI (M	
f , M	
Ğ´ ) â‰¤ Îµ.
Decision procedure. We are now ready to describe the decision procedure. We first construct
the subtrees M	
f and M	
Ğ´ of Mf and MĞ´, respectively, consisting of points with extent at least
2(
âˆš
2ns + 1)Îµ. Next, we compute matching points on M	
f and M	
Ğ´ and construct the trees MËœ f and
MËœ Ğ´ on these matching points, as defined above.
Using the algorithm of [2, chap. 3, p. 85], we determine in time linear in the size of the trees
whether MËœ f and MËœ Ğ´ are isomorphic. If the answer is no, we return no. By Lemma 5.7, dI (Mf , MĞ´ ) >
Îµ in this case. Otherwise, we construct the following functions Î± : Mf â†’ MĞ´ and Î² : MĞ´ â†’ Mf
and return them. Recall, it suffices to perform assignments where the function value increases by
at most cÎµ. For each pair of matching points x and y matched by the isomorphism, the algorithm
sets Î± (x) = y and Î² (y) = x. Now, let (Î¾1,Î¾2) be any maximal range of function values without
any branching nodes or leaves in M	
f or M	
Ğ´ with Î¾2 âˆ’ Î¾1 > 2Îµ. Let x 	 be any point in M	
f with
f (x 	
) âˆˆ (Î¾1,Î¾2). Point x 	 has a unique matching point descendant x at height Î¾1, by the definition
of matching points. The algorithm sets Î± (x 	
) to the point y	 in M	
Ğ´ where y	 is the ancestor of Î± (x)
with Ğ´(y	
) = f (x 	
), and it sets Î² (y	
) = x 	
. For every remaining point x 		 in M	
f , the algorithm sets
Î± (x 		) to Î± (x) where x is the lowest matching point ancestor of x 		. Î² (y		) is defined similarly for
remaining points y		 in M	
Ğ´ that were not paired with some x 	
. We call such points x 		 and y		 lazily
assigned. See Figure 12. Finally, each point z in Mf âˆ’ M	
f has Î± (z) set to Î± (x) where x is the lowest
ancestor of z in M	
f . Similar assignments are done for points in MĞ´ âˆ’ M	
Ğ´.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018. 
24:18 P. K. Agarwal et al.
Fig. 12. Figure showing points x,y, x 	
,y	
, x 		,y		.
Lemma 5.8. (i) For each lazily assigned point x 		 âˆˆ M	
f ,
Ğ´(Î± (x 		)) â‰¤ f (x 		) + 2(
âˆš
2ns + 1)Îµ.
(ii) For each lazily assigned point y		 âˆˆ M	
Ğ´,
f (Î² (y		)) â‰¤ Ğ´(y		) + 2(
âˆš
2ns + 1)Îµ.
Proof. We only prove (i); (ii) is symmetric. The higher of the two roots of M	
f and M	
Ğ´ is a
matching point, and so are all the points at that height. Thus, all lazily assigned points have a
matching point ancestor. We show that the nearest such ancestor cannot be too much higher up.
Let x be a matching point. We show that there exists a region (Î¾1,Î¾2) as defined above with
f (x) âˆ’ 2(
âˆš
2ns + 1)Îµ â‰¤ Î¾2 â‰¤ f (x).
Consider sweeping over the function values downward starting at f (x) and let Î¾2 be the largest
function value possible for a region as defined above. If the sweep line ever goes a distance greater
than 2Îµ without encountering a branching node or leaf in M	
f or M	
Ğ´, then an Î¾2 is found. Therefore,
there will be at least one branching node or leaf x 	 in M	
f or M	
Ğ´ per descent of 2Îµ until Î¾2 is found.
Suppose Î¾2 < f (x) âˆ’ 2(
âˆš
2ns + 1)Îµ. Let l = âˆš
2ns + 1, and f 	 = f (x) âˆ’ 2lÎµ.
Let {P1, P2,... } be a set of paths from each branching node of M	
f or M	
Ğ´ encountered during
the sweep to leaves of Mf and MĞ´ such that for each pair of paths, both paths are disjoint except
possibly at the higher endpoint of one of the two paths. Such a set of paths can be found by
greedily selecting an arbitrary path for each branching node as it is encountered. In addition, let
{Q1,Q2,... } be a set of pairwise-disjoint paths from leaves of M	
f and M	
Ğ´ to leaves of Mf and MĞ´.
Because each point in M	
f and M	
Ğ´ has extent at least 2lÎµ, the lower endpoint of each of these paths
lies below height f 	
. Since edge lengths are at most sÎµ, there are at least (f (x 	
) âˆ’ f 	
)/sÎµ nodes in
Mf or MĞ´ on the path Pi or Qj from each branching node or leaf x 	 at height f (x 	
) âˆˆ [f 	
, f (x)),
not counting x 	 itself. In total, these paths contain at least

l
i=1
(l âˆ’ i)2Îµ
sÎµ = l(l âˆ’ 1)
s
nodes, not counting their higher endpoints. Each node counted above appears on at most one path
Pi and at most one path Qj , for at most two paths total, so
l(l âˆ’ 1)
s â‰¤ 2n â‡’ l(l âˆ’ 1) â‰¤ 2ns,
a contradiction since l = âˆš
2ns + 1. Therefore, eitherÎ¾2 â‰¥ f (x) âˆ’ 2(
âˆš
2ns + 1)Îµ, or the trees M	
f and
M	
Ğ´ do not extend below height f (x) âˆ’ 2(
âˆš
2ns + 1)Îµ. In either case, the lemma follows.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 24. Publication date: April 2018.  
Computing the Gromov-Hausdorff Distance for Metric Trees 24:19
Lemma 5.9. Let Mf and MĞ´ be two merge trees and letÎµ > 0 be a parameter. There is anO(n2) time
algorithm that returns a pair of 4(
âˆš
2ns + 1)Îµ-compatible maps between Mf and MĞ´, if dI (Mf , MĞ´ ) â‰¤
Îµ and the maximum length of a tree edge is sÎµ. If dI (Mf , MĞ´ ) > Îµ, then the algorithm may return no
or return a pair of 4(
âˆš
2ns + 1)Îµ-compatible maps.
Proof. Constructing the trees MËœ f and MËœ Ğ´, the corresponding isomorphism between them (if
it exists), and the maps Î± and Î² between Mf and MĞ´ (if they exist) takes time O(n2).
Except for the lazily assigned points, all the points in M	
f and M	
Ğ´ are mapped by Î± and Î²,
respectively, to points at the same function value. By Lemma 5.8, each point in M	
f and M	
Ğ´ has
its function value changed by at most 2(
âˆš
2ns + 1)Îµ. Points in Mf âˆ’ M	
f (MĞ´ âˆ’ M	
Ğ´, respectively)
have their nearest ancestors in M	
f (M	
Ğ´, respectively) at function value at most 2(
âˆš
2ns + 1)Îµ away.
Since Î± and Î² map them to the images of their nearest ancestors, their function values change by
at most 2 Â· 2(
âˆš
2ns + 1)Îµ.
Remark. (i) Since the minimum edge length is â‰¤ 2Îµ, the maximum edge length issÎµ, and the ratio
between the lengths of the longest and shortest edges is r; we have r â‰¥ s/2.
(ii) If s = Î©(n), we modify the above algorithm slightlyâ€”we skip the trimming step, but keep
the rest the same. It can be shown, as in Lemma 5.8, that the height of a point and its image differ
by at most 2nÎµ. In particular, the proof no longer requires as complicated a counting argument,
because any path contains at most n nodes.
Putting it together. By Lemmas 5.5 and 5.9, the decision procedure takesO(n5/2) time. If it returns
no, then dI (Mf , MĞ´ ) > Îµ. If it returns yes, then it also returns O(min{n,
âˆš
rn}Îµ)-compatible maps
between them. Hence, we conclude the following.
Theorem 5.10. Given two merge trees Mf and MĞ´ with a total of n vertices, there exists an
O(n5/2 logn)-time algorithm with an approximation factor of O(min{n,
âˆš
rn}) for computing the interleaving distance between them, where r is the ratio between the lengths of the longest and the
shortest edge in both trees.
Combining Theorem 5.10 with Corollary 4.5, we have the following.
Corollary 5.11. Given two metric trees T1 and T2 with a total of n vertices, there exists an
O(n9/2 logn)-time algorithm with an approximation factor of O(min{n,
âˆš
rn}) for computing the GH
distance between them, where r is the ratio between the lengths of the longest and the shortest edge in
both trees.
6 CONCLUSION
We have presented the first hardness results for computing the GH distance between metric trees.
We have also given a polynomial-time approximation algorithm for the problem. But the current
gap between the lower and upper bounds on the approximation factor is polynomially large. While
we would like to reduce this gap, doing so seems very difficult. On the algorithmic side of things
in particular, trying for anything less than an O(
âˆš
n)-approximation appears to prevent our use of
algorithms for graph isomorphism, the strongest algorithmic tool used in the above algorithm. We
hope that our current investigation will stimulate more research on the theoretical and algorithmic
aspects of embedding or matching under additive metric distortion 