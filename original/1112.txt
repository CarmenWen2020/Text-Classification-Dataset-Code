We obtain a number of lower bounds on the running time of algorithms solving problems on graphs of
bounded treewidth. We prove the results under the Strong Exponential Time Hypothesis of Impagliazzo and
Paturi. In particular, assuming that n-variablem-clause SAT cannot be solved in time (2 − ϵ )
nmO(1)
, we show
that for any ϵ > 0:
• Independent Set cannot be solved in time (2 − ϵ )
tw(G) |V (G)|
O(1)
,
• Dominating Set cannot be solved in time (3 − ϵ )
tw(G) |V (G)|
O(1)
,
• Max Cut cannot be solved in time (2 − ϵ )
tw(G) |V (G)|
O(1)
,
• Odd Cycle Transversal cannot be solved in time (3 − ϵ )
tw(G) |V (G)|
O(1)
,
• For any fixed q ≥ 3, q-Coloring cannot be solved in time (q − ϵ )
tw(G) |V (G)|
O(1)
,
• Partition Into Triangles cannot be solved in time (2 − ϵ )
tw(G) |V (G)|
O(1)
.
Our lower bounds match the running times for the best known algorithms for the problems, up to the ϵ in
the base.
CCS Concepts: • Theory of computation → Parameterized complexity and exact algorithms;
Additional Key Words and Phrases: Treewidth, SETH, lower bounds

1 INTRODUCTION
It is well-known that many NP-hard graph problems can be solved efficiently if the treewidth
(tw(G)) of the input graphG is bounded. For an example, an expository algorithm to solve Vertex
Cover and Independent Set running in time O∗ (4tw(G)
) is described in the algorithms textbook
by Kleinberg and Tardos [35] (the O∗ notation suppresses factors polynomial in the input size),
while the book by Niedermeier [43] on fixed-parameter algorithms presents an algorithm with
running time O∗ (2tw(G)
). Similar algorithms, with running times on the form O∗ (ctw(G)
) for a
constantc, are known for many other graph problems such as Dominating Set, q-Coloring, and
Odd Cycle Transversal [5, 19, 26, 27, 50]. Algorithms for graph problems on bounded treewidth
graphs have found many uses as subroutines in approximation algorithms [7, 24, 25, 36], parameterized algorithms [4, 21, 23, 34, 41, 49], and exact algorithms [28, 42, 46].
In this article, we show that any improvement over the currently best known algorithms for a
number of well-studied problems on graphs of bounded treewidth would yield a faster algorithm
for SAT. In particular, we show if there exists an ϵ > 0 such that
• Independent Set can be solved in time O∗ ((2 − ϵ )
tw(G)
), or
• Dominating Set can be solved in time O∗ ((3 − ϵ )
tw(G)
), or
• Max Cut can be solved in time O∗ ((2 − ϵ )
tw(G)
), or
• Odd Cycle Transversal can be solved in time O∗ ((3 − ϵ )
tw(G)
), or
• there is a fixed q ≥ 3 such that q-Coloring can be solved in time O∗ ((q − ϵ )
tw(G)
), or
• Partition Into Triangles can be solved in time O∗ ((2 − ϵ )
tw(G)
),
then n-variable SAT can be solved in O∗ ((2 − δ )
n ) time for some δ > 0. Such an algorithm would
violate the Strong Exponential Time Hypothesis (SETH) of Impagliazzo and Paturi [31]. Thus, assuming SETH, the known algorithms for the mentioned problems on graphs of bounded treewidth
are essentially the best possible.
To show our results, we give polynomial time many-one reductions that transform n-variable
boolean formulas ϕ to instances of the problems in question. Such reductions are well-known, but
for our results, we need to carefully control the treewidth of the graphs that our reductions output.
A typical reduction creates n gadgets corresponding to the n variables; each gadget has a small
constant number of vertices. In most cases, this implies that the treewidth can be bounded byO(n).
However, to prove the lower bound of the form O∗ ((2 − ϵ )
tw(G)
), we need that the treewidth of the
constructed graph is (1 + o(1))n. Thus, we can afford to increase the treewidth by at most one per
variable. For lower bounds above O∗ ((2 − ϵ )
tw(G)
), we need even more economical constructions.
To understand the difficulty, consider the Dominating Set problem; here, we want to say that if
Dominating Set admits an algorithm with running time O∗ ((3 − ϵ )
tw(G)
) = O∗ (2log(3−ϵ )tw(G)
)
for some ϵ > 0, then we can solve SAT on input formulas with n-variables in time O∗ ((2 − δ )
n )
for some δ > 0. Therefore, by naïvely equating the exponent in the previous sentence, we get
that we need to construct an instance for Dominating Set whose treewidth is essentially n
log 3 .
In other words, each variable should increase treewidth by less than one. The main challenge in
our reductions is to squeeze out as many combinatorial possibilities per increase of treewidth
as possible. To control the treewidth of the graphs we construct, we upper bound the pathwidth
(pw(G)) of the constructed instances and use the fact that for any graph G, tw(G) ≤ pw(G). Thus,
all of our lower bounds also hold for problems on graphs of bounded pathwidth.
Complexity Assumption: The Exponential Time Hypothesis (ETH) and its strong variant (SETH)
are conjectures about the exponential time complexity of k-SAT. The k-SAT problem is a restriction
of SAT, where every clause in input boolean formula ϕ has at most k literals. Letsk = inf{δ : k-SAT
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.
Known Algorithms on Graphs of Bounded Treewidth Are Probably Optimal 13:3
can be solved in 2δ n time}. The Exponential Time Hypothesis conjectured by Impagliazzo, Paturi,
and Zane [32] is that s3 > 0. In Reference [32], it is shown that ETH is robust, that is s3 > 0 if
and only if there is a k ≥ 3 such that sk > 0. In the same year, it was shown that assuming ETH
the sequence {sk } increases infinitely often [31]. Since SAT has a O∗ (2n ) time algorithm, {sk } is
bounded by above by one, and Impagliazzo and Paturi [31] conjecture that 1 is indeed the limit of
this sequence. In a subsequent article [12], this conjecture is coined as SETH.
ETH is now a widely believed assumption and has been used as a starting point to prove running time lower bounds for numerous problems [9, 14, 15, 18, 22, 29, 38–40]. At the time of the
conference version of this article, SETH was largely untouched [11, 16, 17, 20, 21, 44]. The reason
for this was twofold. First, the assumption that limk→∞ sk = 1 is a very strong one. Second, when
proving lower bounds under ETH, we can utilize the Sparsification Lemma [32], which allows us
to reduce from instances of 3-SAT where the number of clauses is linear in the number of variables. Such a tool does not exist for SETH, and this seems to be a major obstruction for showing
running time lower bounds for interesting problems under SETH. We overcome this obstruction
by circumventing it—to show running time lower bounds for algorithms on bounded treewidth
graphs sparsification is simply not required.
Related Work. In several cases designing the “right algorithm” on graphs of bounded treewidth
or pathwidth is not at all obvious. For example: Alber et al. [5] gave a O∗ (4tw(G)
) time algorithm
for Dominating Set, improving over the natural O∗ (9tw(G)
) algorithm of Telle and Proskurowski
[48]. Later, van Rooij et al. [50] observed that one could use fast subset convolution [8] to improve
the running time of algorithms on graphs of bounded treewidth. Their results include a O∗ (3tw(G)
)
algorithm for Dominating Set and a O∗ (2tw(G)
) time algorithm for Partition Into Triangles.
Interestingly, the effect of applying subset convolution was that the running time for several graph
problems on bounded treewidth graphs became the same as the running time for the problems on
graphs of bounded pathwidth. However, the idea of using subset convolution in designing dynamic
programming algorithm over graphs of bounded treewidth was not enough to design “optimal algorithms” for several connectivity problems such as Hamiltonian Path and Connected Vertex
Cover. In a seminal article, Cygan et al. [21] introduced the method of Cut & Count and designed
the first O∗ (ctw(G)
), where c is a fixed constant, for plethora of connectivity problems including
Hamiltonian Path and Connected Vertex Cover. However, the algorithm for Hamiltonian
Path runs in time O∗ (4tw(G)
), which still is the best known algorithm. Later, in a surprising result, Cygan et al. [20] showed that Hamiltonian Path can be solved in time O∗ ((2 + √
2)
pw(G)
)
on graphs of bounded pathwidth. The algorithms obtained using Cut & Count are randomized.
Later, deterministic algorithms with running time O∗ (ctw(G)
), where c is a fixed constant, were
designed for connectivity problems [10, 30].
Follow-up Work. The problems considered in this article, and the ideas used to resolve them, led
to several follow-up works that showed lower bounds for concrete problems in the parameterized
settings [11, 16, 17, 21]. On the other hand, Roditty and Williams [45] used SETH to show concrete
lower bounds on the running time for problems solvable in polynomial time. This was followed by
a long line of work in this direction [1–3, 6, 13, 51]. The work of Cygan et al. [21] that introduced
the method of Cut & Count to design O∗ (ctw(G)
), where c is a fixed constant, for connectivity
problems, also showed that the base of exponent in their algorithm are optimal unless SETH fails.
Cygan et al. [20] showed that the running time of O∗ ((2 + √
2)
pw(G)
) for Hamiltonian Path on
graphs of bounded pathwidth is, in fact, optimal under SETH. Several other lower bounds for concrete problems were also obtained in Reference [17]. Ideas from the current article were recently
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.
13:4 D. Lokshtanov et al.
used to design tight lower bounds for r-Dominating Set and Connected Dominating Set on
graphs of bounded treewidth [11]. Curticapean and Marx obtained tight lower bounds for counting
perfect matchings on graphs of bounded treewidth, cliquewidth, and genus under SETH [16].
2 PRELIMINARIES
In this section, we give various definitions that we make use of in the article. LetG be a graph with
vertex set V (G) and edge set E(G). A graph G is a subgraph of G if V (G
) ⊆ V (G) and E(G
) ⊆
E(G). For a subset V  ⊆ V (G), the subgraph G = G[V 
] of G is called a subgraph induced by V 
if E(G
) = {uv ∈ E(G) | u,v ∈ V 
} and V (G
) = V 
. By N (u), we denote the (open) neighborhood
of u in graph G, that is, the set of all vertices adjacent to u and by N[u] = N (u) ∪ {u}. Similarly,
for a subset D ⊆ V (G), we define N[D] = ∪v ∈D N[v].
A tree decomposition of a graph G is a pair (X,T ), where T is a tree and X = {Xi | i ∈ V (T )}
is a collection of subsets of V (G) such that: 1.

i ∈V (T ) Xi = V (G), 2. for each edge xy ∈ E(G),
{x,y} ⊆ Xi for some i ∈ V (T ); 3. for each x ∈ V (G) the set {i | x ∈ Xi} induces a connected subtree
of T . The width of the tree decomposition is maxi ∈V (T ){|Xi | − 1}. The treewidth of a graph G is the
minimum width over all tree decompositions of G. We denote by tw(G) the treewidth of graph
G. If in the definition of treewidth we restrict the tree T to be a path, then we get the notion of
pathwidth and denote it by pw(G). For our purpose, we need an equivalent definition of pathwidth
via mixed search games.
In a mixed search game, a graph G is considered as a system of tunnels. Initially, all edges are
contaminated by a gas. An edge is cleared by placing searchers at both its end-points simultaneously or by sliding a searcher along the edge. A cleared edge is re-contaminated if there is a path
from an uncleared edge to the cleared edge without any searchers on its vertices or edges. A search
is a sequence of operations that can be of the following types: (a) placement of a new searcher on a
vertex; (b) removal of a searcher from a vertex; (c) sliding a searcher on a vertex along an incident
edge and placing the searcher on the other end. A search strategy is winning if after its termination
all edges are cleared. The mixed search number of a graph G, denoted by ms(G), is the minimum
number of searchers required for a winning strategy of mixed searching on G. Takahashi, Ueno,
and Kajitani [47] obtained the following relationship between pw(G) and ms(G), which we use
for bounding the pathwidth of the graphs obtained in reduction.
Proposition 1 ([47]). For a graph G, pw(G) ≤ ms(G) ≤ pw(G) + 1.
An instance to SAT consists of a boolean formula ϕ = C1 ∧···∧Cm over n variables
{v1,...,vn }, where each clause Ci is OR of one or more literals of variables. We also denote a
clause Ci by the set {1, 2,...,c } of its literals and denote by |Ci | the number of literals in Ci .
An assignment τ to the variables is an element of {0, 1}
n, and it satisfies the formula ϕ if for every
clauseCi there is literal that is assigned 1 by τ . We say that a variablevi satisfies a clauseCj if there
exists a literal corresponding to vi in {1, 2,...,c } and it is set to 1 by τ . A group of variables
satisfy a clause Cj if there is a variable that satisfies the clause Cj . All the sections in this article
follow the same pattern: definition of the problem; statement of the lower bound; construction
used in the reduction; correctness of the reduction; and the upper bound on the pathwidth of the
resultant graph.
3 INDEPENDENT SET
An independent set of a graph G is a set S ⊆ V (G) such that G[S] contains no edges. In the Independent Set problem, we are given a graph G and the objective is to find an independent set of
maximum size.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.       
Known Algorithms on Graphs of Bounded Treewidth Are Probably Optimal 13:5
We first sketch the main idea of the proof. We give the reduction from an arbitrary SAT instance
on n variables and m clauses. The idea is to create a family of n very long paths P1, P2,..., Pn
of even length, corresponding to variables x1, x2,..., xn. Assume for now that on each of these
paths the solution is allowed to make one of two choices: the independent set either contains all
the odd-indexed vertices or all the even-indexed vertices. Then, for every clause we construct
a clause verification gadget and attach it to some place in the family. The gadget is adjacent
to paths corresponding to variables appearing in the clause, and the attachment points reflect
whether the variable’s appearance is positive or negative. The role of the clause gadget is to verify
that the clause is satisfied. Satisfaction of the clause corresponds to the condition that at least
one of the attachment points of the clause gadget needs to be not chosen into the constructed
independent set; hence, the clause gadget needs to have the following property: the behavior
inside the gadget can be set optimally if and only if at least one of the attachment points is free. It
is possible to construct a gadget with exactly this property, and moreover the gadget has constant
pathwidth, so it does not increase much the width of the whole construction. One technical
problem that we still need to overcome is the first technical assumption about the choices the
solution makes on the paths Pi . It is namely not true that on a path of even length there are only
two maximum-size independent sets: the odd-indexed vertices and the even-indexed vertices.
The solution can first start with picking only odd-indexed vertices, then make a gap of two
vertices, and continue further with even-indexed vertices. Thus, on each path there can be one
“cheat” where the solution flips from odd indices to even indices. The solution to this problem is a
remarkably simple trick that is commonly used in similar reductions. We namely repeat the whole
sequence of clause gadgets n + 1 times, which ensures that at most n copies are spoiled by possible
cheats, and hence at least one of the copies is attached to an area where no cheat happens, and
hence the behavior of the solution on the paths Pi correctly encodes some satisfying assignment
of the variable set. This concludes the sketch, and we move toward giving the formal proof.
Theorem 1. If Independent Set can be solved in O∗ ((2 − ϵ )
tw(G)
) for some ϵ > 0, then SAT
can be solved in O∗ ((2 − δ )
n ) time for some δ > 0.
Construction. Given an instance ϕ of SAT, we construct a graph G as follows (see Figure 1).
We assume that every clause has an even number of variables: if not, we can add a single variable
to all odd size clauses and force this variable to false. First, we describe the construction of clause
gadgets. For a clause C = {1, 2,...,c }, we introduce a gadget C
as follows. We take two paths,
CP = cp1,cp2 ...,cpc and CP = cp
1,cp
2 ...cp
c having c vertices each, and connect cpi with cp
i
for every i. For each literal i , we introduce a vertex i in C
 and make it adjacent to cpi and cp
i .
Finally, we add two verticescstart and cend , such thatcstart is adjacent to cp1 and cend is adjacent
to cpc . Observe that the size of the maximum independent set ofC
isc + 2. Also, since c is even, any
independent set of size c + 2 in C
 must contain at least one vertex in C = {1, 2,...,c }. Finally,
notice that for any i, there is an independent set of size c + 2 in C
that contains i and none of j
for j  i.
We first construct a graph G1. We introduce n paths P1,..., Pn, each path has 2m vertices. Let
the vertices of the path Pi be p1
i ... p2m
i . The path Pi corresponds to the variablevi . For every clause
Ci of ϕ, we introduce a gadget C
i . Now, for every variable vi , if vi occurs positively in Cj , we add
an edge between p2j
i and the literal corresponding to vi inC
j . If vi occurs negatively inCj , then we
add an edge between p2j−1
i and the literal corresponding to vi in C
j . Now, we construct the graph
G as follows. We take n + 1 copies of G1, call them G1,...,Gn+1. For every i ≤ n, we connect Gi
and Gi+1 by connecting p2m
j in Gi with p1
j in Gi+1 for every j ≤ n. This way, the paths Pj in each of
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                   
13:6 D. Lokshtanov et al.
Fig. 1. Reduction to Independent Set: clause gadget C
j attached to the n paths representing the variables.
the n copies Gi together form a long path of 2m(n + 1) vertices. This concludes the construction
of G.
Lemma 1. If ϕ is satisfiable, then G has an independent set of size (mn +
i ≤m (|Ci | + 2))(n + 1).
Proof. Consider a satisfying assignment to ϕ. We construct an independent set I inG. For every
variable vi , if vi is set to true, then pick all the vertices on odd positions from all copies of Pi , that
is p1
i ,p3
i ,p5
i and so on. If vi is false, then pick all the vertices on even positions from all copies of
Pi , that is p2
i ,p4
i ,p6
i and so on. It is easy to see that this is an independent set of size mn(n + 1)
containing vertices from all the paths. We will now consider the gadget C
j corresponding to a
clause Cj . We will only consider the copy of C
j in G1 as the other copies can be dealt identically.
Let us choose a true literal a inCj and let vi be the corresponding variable. Consider the vertex a
inC
j . Ifvi occurs positively inCj , thenvi is true. Then I does not contain p2j
i , the only neighbour of
a outside of C
j . On the other hand, if vi occurs negatively in Cj , then vi is false. In this case I does
not containp2j−1
i , the only neighbour of a outside ofC
j . There is an independent set of size |Cj | + 2
inC
that contains a and none out of b for any b  a. We add this independent set to I and proceed
in this manner for every clause gadget. By the end of the process (

i ≤m (|Ci | + 2))(n + 1), vertices
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                
Known Algorithms on Graphs of Bounded Treewidth Are Probably Optimal 13:7
from clause gadgets are added to I, yielding that the size of I is (mn +
i ≤m (|Ci | + 2))(n + 1),
concluding the proof.
Lemma 2. If G has an independent set of size (mn +
i ≤m (|Ci | + 2))(n + 1), then ϕ is satisfiable.
Proof. Consider an independent set of G of size (mn +
i ≤m |Ci | + 2)(n + 1). Set I can contain
at mostm vertices from each copy of Pi for every i ≤ n and at most |Cj | + 2 vertices from each copy
of the gadgetCj . Since I must contain at least that many vertices from each path and clause gadget
in order to contain at least (mn +
i ≤m |Ci | + 2)(n + 1) vertices, it follows that I has exactly m
vertices in each copy of each path Pi and exactly |Cj | + 2 vertices in each copy of each clause gadget
C
j . For a fixed j, consider the n + 1 copies of the path Pj . Since Pj in Gi is attached to Pj in Gi+1,
these n + 1 copies of Pi together form a path P having 2m(n + 1) vertices. Since |I ∩ P | = m(n + 1)
it follows that I ∩ P must contain every second vertex of P, except possibly in one position where
I ∩ P skips two vertices of P. There are only n paths and n + 1 copies of G1, hence the pigeon-hole
principle implies that in some copy Gy of G1, I contains every second vertex on every path Pi .
From now onward, we only consider such a copy Gy .
In Gy , for every i ≤ n, I contains every second vertex of Pi . We make an assignment to the
variables of ϕ as follows. If I contains all the odd numbered vertices of Pi , then vi is set to true;
otherwise, I contains all the even numbered vertices of Pi and vi is set to false. We argue that this
assignment satisfies ϕ. Indeed, consider any clause Cj , and look at the gadget C
j . We know that I
contains |Cj | + 2 vertices from C
j , and hence I must contain a vertex a in C
j corresponding to a
literal of Cj . Suppose a is a literal of vi . Since I contains a, if a occurs positively in Cj , then I can
not contain p2j
i , and hence vi is true. Similarly, if a occurs negatively in Cj , then I cannot contain
p2j−1
i , and hence vi is false. In both cases, vi satisfies Cj , and hence all clauses of ϕ are satisfied by
the assignment.
Lemma 3. pw(G) ≤ n + 4.
Proof. We give a mixed search strategy to clean G using n + 3 searchers. For every i, we place
a searcher on the first vertex of Pi in G1. The n searchers slide along the paths P1,... Pn in m
rounds. In round j each searcheri starts on p2j−1
i . Then, for every variable vi that occurs positively
in Cj , the searcher i slides forward to p2j
i . Observe that at this point there is a searcher on every
neighbour of the gadget C
j . This gadget can now be cleaned with three additional searchers. After
C
j is clean, the additional three searchers are removed, and each of the n searchers on the paths
P1,... Pn slides forward along these paths, such that searcher i stands on p2(j+1)
i . At that point,
the next round commences. When the searchers have cleaned G1 they slide onto the first vertex
of P1 ... Pn in G2. Then, they proceed to clean G2,...,Gn+1 in the same way that G1 was cleaned.
Now applying Proposition 1, we get that pw(G) ≤ n + 4.
The construction, together with Lemmata 1, 2 and 3 proves Theorem 1.
4 DOMINATING SET
A dominating set of a graph G is a set S ⊆ V (G) such that V (G) = N[S]. In the Dominating Set
problem, we are given a graph G and the objective is to find a dominating set of minimum size.
The basic idea for this reduction is similar to the one for Independent Set. However, we need
one more new idea here, which will also be used in other reductions. We group variables into
an appropriate number of groups of size at most β = log 3p , where p is a constant depending
only on ϵ. Then, for every group, we make a gadget such that an assignment on the group should
correspond to a selection on the gadget. These group gadgets are then connected to clause gadgets
so that every assignment on the group that satisfies the clause results in some desired outcome.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                  
13:8 D. Lokshtanov et al.
Fig. 2. Reduction to Dominating Set: group gadget B
. The set S is shown by the circled vertices.
Theorem 2. If Dominating Set can be solved in O∗ ((3 − ϵ )
pw(G)
) time for some ϵ > 0, then
SAT can be solved in O∗ ((2 − δ )
n ) time for some δ > 0.
Construction. Given ϵ < 1 and an instance ϕ to SAT, we construct a graph G as follows. We
first choose an integer p depending only on ϵ. Exactly how p is chosen will be discussed in the
proof of Theorem 2. We group the variables of ϕ into groups F1, F2,..., Ft , each of size at most
β = log 3p . Hence, t = n/β. We now proceed to describe a “group gadget” B
, which is central
in our construction.
To build the group gadget B
, we introduce p paths P1,..., Pp , where the path Pi contains the
vertices p1
i , p2
i , and p3
i (see Figure 2). To each path Pi , we attach two guards дi and д
i , both of which
are neighbours to p1
i , p2
i , and p3
i . When the gadgets are attached to each other, the guards will
not have any neighbours outside of their own gadget B
, and will ensure that at least one vertex
out of p1
i , p2
i and p3
i are chosen in any minimum size dominating set of G. Let P be the vertex set
containing all the vertices on the paths P1,..., Pp . For every subset S of P that picks exactly one
vertex from each path Pi , we introduce two vertices xS and x 
S , where xS is adjacent to all vertices
of P \ S (all those vertices that are on paths and not in S) and x 
S is only adjacent to xS . We conclude
the construction of B
by making all the vertices x 
S (for every set S) adjacent to each other, that is
making them into a clique, and adding a guard x adjacent to x 
S for every set S. In other words, the
x 
S ’s together with x form a clique and all the neighbors of x reside in this clique.
We construct the graph G as follows (see Figure 3). For every group Fi of variables, we introduce m(2pt + 1) copies of the gadget B
, call them B
j
i for 1 ≤ j ≤ m(2pt + 1). We can imagine
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.       
Known Algorithms on Graphs of Bounded Treewidth Are Probably Optimal 13:9
Fig. 3. Reduction to Dominating Set: arranging the group gadgets. Note that x = m + j, thusc
j is attached
to vertices in B
x
1 , ... , B
x
t .
these t · m(2pt + 1) gadgets arranged in t rows and m(2pt + 1) columns, with the columns being divided into 2pt + 1 regions of m columns each. For every fixed i ≤ t, we connect the gadgets
B
1
i , B
2
i ..., B
m(2pt+1)
i in a pathlike manner. In particular, for every j < m(2pt + 1) and every  ≤ p,
we make an edge between p3
 in the gadget B
j
i with p1
 in the gadget B
j+1
i . Now, we introduce two
new vertices h and h
, with h adjacent to h
, p1
j in B
1
i for every i ≤ t, j ≤ p and to p3
j in B
m(2pt+1)
i
for every i ≤ t, j ≤ p. That is, for all 1 ≤ i ≤ t, h is adjacent to the first and last vertices of “long
paths” obtained after connecting the gadgets B
1
i , B
2
i ..., B
m(2pt+1)
i in a pathlike manner.
For every 1 ≤ i ≤ t and to every assignment of the variables in the group Fi , we designate a
subset S of P in the gadget B
 that picks exactly one vertex from each path Pj . Since there are at
most 2β different assignments to the variables in Fi , and there are 3p ≥ 2β such sets S, we can assign
a unique set to each assignment. Of course, the same set S can correspond to one assignment of the
group F1 and some other assignment of the group F2. Recall that the clauses of ϕ are C1,...,Cm.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                   
13:10 D. Lokshtanov et al.
For every clause Cj , we introduce 2pt + 1 verticesc
j , one for each 0 ≤  < 2pt + 1, corresponding
to the 2pt + 1 regions. The vertex c
j will be connected to the gadgets B
m+j
i for every 1 ≤ i ≤ t
(which appear in the th region). In particular, for every assignment of the variables in the group
Fi that satisfy the clause Cj , we consider the subset S of P that corresponds to the assignment. For
every 0 ≤  < 2pt + 1, we make x 
S in B
m+j
i adjacent toc
j . The best way to view this is that every
clause Cj has 2pt + 1 private gadgets in the i-row, B
j
i , B
m+j
i ,..., B
m2pt+j
i , one in each region. Now,
we have 2pt + 1 vertices corresponding to the clause Cj , each connected to one of these gadgets.
This concludes the construction of G.
Lemma 4. If ϕ has a satisfying assignment, then G has a dominating set of size (p + 1)tm(2pt +
1) + 1.
Proof. Given a satisfying assignment to ϕ, we construct a dominating set D of G that contains
the vertex h and exactly p + 1 vertices in each gadget B
j
i . For each group Fi of variables, we consider
the set S that corresponds to the restriction of the assignment to the variables in Fi . From each
gadget B
j
i , we add the set S to D and also the vertex x 
S to D. It remains to argue that D is indeed a
dominating set. Clearly the size is bounded by (p + 1)tm(2pt + 1) + 1, as the number of gadgets is
tm(2pt + 1).
For a fixed i ≤ t and j consider the vertices on the path Pj in the gadgets B

i for every  ≤
m(2pt + 1). Together these vertices form a path of length 3m(2pt + 1) and every third vertex of
this path is in S. Thus, all vertices on this path are dominated by other vertices on the path, except
perhaps for the first and last one. Both these vertices, however, are dominated by h.
Now, fix some i ≤ t and  ≤ m(2pt + 1) and consider the gadget B

i . Since D contains some
vertex on the path Pj , we have that for every j both дj and д
j are dominated. Furthermore, for
every set S∗ not equal to S that picks exactly one vertex from each Pj , vertex xS∗ is dominated by
some vertex on some Pj—namely by all vertices in S \ S∗  ∅. The last assertion follows, since xS∗
is connected to all the vertices on the paths except S∗. On the other hand, xS is dominated by x 
S ,
and x 
S also dominates all the other vertices x 
S∗ for S∗  S, as well as the guard x.
The only vertices not yet accounted for are the vertices c
j for every j ≤ m and  < 2pt + 1.
Fix a j and a  and consider the clause Cj . This clause contains a literal set to true, and this literal
corresponds to a variable in the group Fi for some i ≤ t. Of course, the assignment to Fi satisfiesCj .
Let S be the set corresponding to this assignment of Fi . By the construction of D, the dominating
set contains x 
S in B
m+j
i and x 
S is adjacent to c
j . This concludes the proof.
Lemma 5. If G has a dominating set of size (p + 1)tm(2pt + 1) + 1, then ϕ has a satisfying assignment.
Proof. Let D be a dominating set of G of size at most (p + 1)tm(2pt + 1) + 1. Since D must
dominate h
, without loss of generality, we can assume that D contains h. Furthermore, inside
every gadget B

i , D must dominate all the guards, namely дj and д
j for every j ≤ p, and also x.
Thus, D contains at least p + 1 vertices from each gadget B

i , which in turn implies that D contains
exactly p + 1 vertices from each gadget B

i . The only way D can dominate дj and д
j for every j
and in addition dominate x with only p + 1 vertices if D has one vertex from each Pj , j ≤ p and in
addition contains some vertex in N[x]. Let S be D ∩ P in B

i . Observe that xS is not dominated by
D ∩ S. The only vertex in N[x] that dominates xS is x 
S , and hence D contains x 
S .
Now, we want to show that for every 1 ≤ i ≤ t there exists one 0 ≤  ≤ 2tp such that for fixed
i, D ∩ P is same in all the gadgets B
m+r i for every 1 ≤ r ≤ m, i.e., it is the same in every gadget of
the ith row in the th region. Consider a gadget B

i and its follower, B
+1 i . Let S be D ∩ P in B

i and
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                                                     
Known Algorithms on Graphs of Bounded Treewidth Are Probably Optimal 13:11
S be D ∩ P in B
+1 i . Observe that if S contains pa
j in B

i and pb
j in B
+1 i then we must have b ≤ a. We
call a consecutive pair bad if for some j ≤ p, D contains pa
j in B

i and pb
j in B
+1 i and b < a. Hence,
for a fixed i, we can at most have 2p consecutive bad pairs, spoiling at most 2p regions. Now, we
mark all the bad pairs that occur among the gadgets corresponding to some Fi . This way we can
mark only 2tp bad pairs. Thus, by the pigeon hole principle, there exists an  ∈ {0,..., 2tp} such
that there are no bad pairs in B
m+r i for all 1 ≤ i ≤ t and 1 ≤ r ≤ m.
We make an assignment ϕ by reading off D ∩ P in each gadget B
m+1 i . In particular, for every
group Fi , we consider S = D ∩ P in the gadget B
m+1 i . This set S corresponds to an assignment of
Fi , and this is the assignment of Fi that we use. It remains to argue that every clause Cr is satisfied
by this assignment.
Consider the vertex cr
 . We know that it is dominated by some x 
S in a gadget B
m+r i . The set S
corresponds to an assignment of Fi that satisfies the clause Cr . Because D ∩ P remains unchanged
in all gadgets from B
m+1 i to B
m+r i , this is exactly the assignment ϕ restricted to the group Fi . This
concludes the proof.
Lemma 6. pw(G) ≤ tp + O(3p ).
Proof. We give a mixed search strategy to clean the graph with tp + O(3p ) searchers. For a
gadget B
, we call the vertices p1
j and p3
j , 1 ≤ j ≤ p, as entry vertices and exit vertices, respectively.
We search the graph in m(2tp + 1) rounds. In the beginning of round  there are searchers on the
entry vertices of the gadgets B

i for every i ≤ t. Let 1 ≤ a ≤ m and 0 ≤ b < 2tp + 1 be integers
such that  = a + mb. We place a searcher on cb
a . Then, for each i between 1 and p in turn, we
first put searchers on all vertices of B

i and then remove all the searchers from B

i except for the
ones standing on the exit vertices. After all gadgets B

1 ... B

t have been cleaned in this manner,
we can remove the searcher from c b
a . To commence the next round, the searchers slide from the
exit positions of B

i to the entry positions of B
+1 i for every i. In total, at most tp + |V (B
)| + 1 ≤
tp + O(3p ) searchers are used simultaneously. This together with Proposition 1 give the desired
upperbound on the pathwidth.
Proof (of Theorem 2). Suppose Dominating Set can be solved in O∗ ((3 − ϵ )
pw(G)
)=
O∗ (3λpw(G)
) time, where λ = log3 (3 − ϵ ) < 1. We choose p large enough such that λ · p
p log 3 =
δ
log 3 for some δ  < 1. Given an instance of SAT, we construct an instance of Dominating Set using
the above construction and the chosen value of p. Then, we solve the Dominating Set instance using the O∗ (3λpw(G)
) time algorithm. Correctness is ensured by Lemmata 4 and 5. Lemma 6 yields
that the total time taken is upper bounded by O∗ (3λpw(G)
) ≤ O∗ (3λ(tp+f (λ)) ) ≤ O∗ (3
λ np
p log 3 ) ≤
O∗ (3
δ n
log 3 ) ≤ O∗ (2δn ) = O∗ ((2 − δ )
n ), for some δ , δ < 1. This concludes the proof.
5 MAX CUT
A cut in a graph G is a partition of V (G) into V0 and V1. The cut-set of the cut is the set of edges
whose one end point is in V0 and the other in V1. We say that an edge is crossing this cut if it has
one endpoint inV0 and one inV1, that is, the edge is in the cut-set. The size of the cut is the number
of edges in G that are crossing this cut. If the edges of G have positive integer weights, then the
weight of the cut is the sum of the weights of edges that are crossing the cut. In the Max Cut
problem, we are given a graph G together with an integer t and asked whether there is a cut of
G of size at least t. In the Weighted Max Cut problem every edge has a positive integer weight
and the objective is to find a cut of weight at least t.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                                                
13:12 D. Lokshtanov et al.
Theorem 3. If Max Cut can be solved in O∗ ((2 − ϵ )
pw(G)
) for some ϵ > 0, then SAT can be
solved in O∗ ((2 − δ )
n ) time for some δ > 0.
Construction. Given an instance ϕ of SAT, we first construct an instance Gw of Weighted
Max Cut as follows. We later explain how to obtain an instance of unweighted Max Cut from
here.
We start with introducing a vertex x0. Without loss of generality, we will assume that x0 ∈ V0
in every solution. We introduce a vertex vi for each variable vi . For every clause Cj , we create a
gadget as follows. We introduce a path P
j having 4|Cj | vertices. All the edges on P
j have weight
3n. Now, we make the first and last vertex of P
j adjacent to x0 with an edge of weight 3n. Thus the
path P
j plus the edges from the first and last vertex of P
j to x0 form an odd cycle C
j . We will say
that the first, third, fifth, and so on, vertices are on odd positions on P
j while the remaining vertices
are on even positions. For every variable vi that appears positively in Cj , we select a vertex p at an
even position (but not the last vertex) on P
j and make vi adjacent to p and p’s successor on P
j with
edges of weight 1. For every variable vi that appears negatively in Cj , we select a vertex p at an
odd position on P
j and make vi adjacent to p and p’s successor on P
j with edges of weight 1. We
make sure that each vertex on P
j receives an edge at most once in this process. There are more than
enough vertices on P
j to accommodate all the edges incident to vertices corresponding to variables
in the clause Cj . We create such a gadget for each clause and set t = m + (12n + 1)
m
j=1 |Cj |. This
concludes the construction.
Lemma 7. If ϕ is satisfiable, then Gw has a cut of weight at least t.
Proof. Suppose ϕ is satisfiable. We put x0 in V0 and for every variable vi , we put vi in V1 if vi
is true and vi in V0 if vi is false. For every clause Cj , we proceed as follows. Let us choose a true
literal of Cj and suppose that this literal corresponds to a vertex pj on P
j . We put the first vertex
on P
j inV1, the second inV0, and then we proceed along P
j putting every second vertex intoV1 and
V0 until we reach pj . The successor p
j of pj on P
j is put into the same set as pj . Then, we continue
along P
j putting every second vertex in V1 and V0. Notice that even though Cj may contain more
than one literal that is set to true, we only select one vertex pj from the path P
j and put pj and its
successor on the same side of the partition. It remains to argue that this cut has weight at least t.
For every clause Cj all edges on the path P
j except for pjp
j are crossing, and the two edges
to x0 from the first and last vertex of P
j are crossing as well. These edges contribute 12n|Cj | to
the weight of the cut. We know that pj corresponds to a literal that is set to true, and this literal
corresponds to a variable vi . If vi occurs positively inCj , then vi ∈ V1 and pj is on an even position
of P
j . Thus, both pj and its successor p
j are in V0, and hence both vipj and vip
j are crossing,
contributing 2 to the weight of the cut. For each of the remaining variables vi appearing in Cj ,
one of the two neighbours ofvi on P
j appear inV0 and one inV1, so exactly one edge fromvi to P
j is
crossing. Thus the total weight of the cut ist = m
j=1 (12n|Cj | + |Cj | + 1) = m + (12n + 1)
m
j=1 |Cj |.
This completes the proof.
Lemma 8. If Gw has a cut of weight at least t, then ϕ is satisfiable.
Proof. Let (V0,V1) be a cut of G of maximum weight, hence the weight of this cut is at least t.
Without loss of generality, let x0 ∈ V0. For every clause Cj , at least one edge of the odd cycle C
j is
not crossing. If more than one edge of this cycle is not crossing, then the total weight of the cut
edges incident to the path P
j is at most 3n(4|Cj | − 1) + 2n < 12n|Cj |. In this case, we could change
the partition (V0,V1) such that all edges of P
j are crossing and the first vertex of P
j is in V1. Using
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                                         
Known Algorithms on Graphs of Bounded Treewidth Are Probably Optimal 13:13
the new partition the weight of the crossing edges in the cycle C
j is at least 12n|Cj | and the edges
not incident to P
j are unaffected by the changes. This contradicts that (V0,V1) was a maximum
weight cut. Thus, it follows that exactly one edge of C
j is not crossing.
Given the cut (V0,V1), we set each variablevi to true ifvi ∈ V1 andvi to false, otherwise. Consider
a clause Cj and a variable vi that appears in Cj . Let uv be the edge of C
j that is not crossing. If
there is a vertex vi adjacent to both u and v, then it is possible that both viu and viv are crossing.
For every other variable vi in Cj , at most one of the edges from vi to P
j is crossing. Thus, the
weight of the edges that are crossing in the gadget C
j is at most (12n + 1)|Cj | + 1. Hence, to find
a cut-set of weight at least t in G, we need to have crossing edges in C
j with sum of their weights
exactly equal to 12n|Cj | + |Cj | + 1. It follows that there is a vertex vi adjacent to both u and v such
that both viu and viv are crossing.
Ifvi occurs inCj positively, then u is on an even position, and hence u ∈ V0. Sinceviu is crossing
it follows that vi is true and Cj is satisfied. On the other hand, if vi occurs in Cj negated then u
is on an odd position, and hence u ∈ V1. Since viu is crossing, it follows that vi is false and Cj is
satisfied. As this holds for each clause individually, this concludes the proof.
For every edge e ∈ E(Gw ), let we be the weight of e in Gw . We construct an unweighted graph
G from Gw by replacing every edge e = uv by we paths from u to v on three edges. Let W be the
sum of the edge weights of all edges in Gw .
Lemma 9. G has a cut of size 2W + t if and only if Gw has a cut of weight at least t.
Proof. Given a partition of V (Gw ), we partition V (G) as follows. The vertices of G that also
are vertices of V (G) are partitioned in the same way as in V (Gw ). On each path of length 3, if the
endpoints of the path are in different sets, we can partition the middle vertices of the path such
that all edges are cut. If the endpoints are in the same set, then we can only partition the middle
vertices such that 2 out of the 3 edges are cut. The reverse direction is similar.
Lemma 10. pw(G) ≤ n + 5.
Proof. We give a search strategy to clean G with n + 5 searchers. We place one searcher on
each vertex vi and one searcher on x0. Then one can search the gadgets C
j one by one. In Gw it
is sufficient to use 2 searchers for each C
j , whereas in G after the edges have been replaced by
multiple paths on three edges, we need 4 searchers. This combined with Proposition 1 gives the
desired upper bound on the pathwidth of the graph.
The construction, together with Lemmata 7, 8, 9, and 10 proves Theorem 3.
6 GRAPH COLORING
A q-coloring of G is a function μ : V (G) → [q]. A q-coloring μ of G is proper if for every edge
uv ∈ E(G) we have μ(u)  μ(v). In the q-Coloring problem, we are given as input a graph G and
the objective is to decide whether G has a proper q-coloring. In the List Coloring problem, every
vertex v is given a list L(v) ⊆ [q] of admissible colors. A proper list coloring of G is a function
μ : V (G) → [q] such that μ is a proper coloring of G that satisfies μ(v) ∈ L(v) for every v ∈ V (G).
In the q-List Coloring problem, we are given a graph G together with a list L(v) ⊆ [q] for every
vertex v. The task is to determine whether there exists a proper list coloring of G.
A feedback vertex set of a graph G is a set S ⊆ V (G) such that G \ S is a forest; we denote by
fvs(G) the size of the smallest such set. It is well-known that tw(G) ≤ fvs(G) + 1. Unlike the
other sections, where we give lower bounds for algorithms parameterized by pw(G), the following
theorem gives also a lower bound for algorithms parameterized by fvs(G). Such a lower bound
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                        
13:14 D. Lokshtanov et al.
follows very naturally from the construction we are doing here, but not from the constructions in
the other sections. It would be interesting to explore whether it is possible to prove tight bounds
parameterized by fvs(G) for the problems considered in the other sections.
Theorem 4. Let q be a fixed positive integer. If q-Coloring can be solved in O∗ ((q − ϵ )
fvs(G)
) or
O∗ ((q − ϵ )
pw(G)
) time for some ϵ > 0, then SAT can be solved in O∗ ((2 − δ )
n ) time for some δ > 0.
Construction. We will show the result for List Coloring first, and then give a simple reduction
that demonstrates that q-Coloring can be solved in O∗ ((q − ϵ )
fvs(G)
) time if and only if q-List
Coloring can.
Depending on ϵ and q, we choose a parameter p. Now, given an instance ϕ to SAT, we will
construct a graph G with a list L(v) for every v, such that G has a proper list-coloring if and only
if ϕ is satisfiable. Throughout the construction, we will call color 1-red, color 2-white, and color
3-black.
We start by grouping the variables of ϕ into t groups F1,..., Ft of size at most logqp . Thus
t =  n
log qp  . We will call an assignment of truth values to the variables in a group Fi a group
assignment. We will say that a group assignment satisfies a clause Cj of ϕ if Cj contains at least
one literal that is set to true by the group assignment. Notice that Cj can be satisfied by a group
assignment of a group Fi , even though Cj also contains variables that are not in Fi .
For each group Fi , we introduce a set Vi of p vertices v1
i ,...,vp
i . The vertices in Vi get full lists,
that is, they can be colored by any color in [q]. The coloring of the vertices in Vi will encode the
group assignment of Fi . There are qp ≥ 2|Fi | possible colorings of Vi . Thus, to each possible group
assignment of Fi , we attach a unique coloring of Vi . Notice that some colorings of Vi may not
correspond to any group assignments of Fi .
For each clause Cj of ϕ, we introduce a gadget C
j . The main part of C
j is a long path P
j that has
one vertex for each group assignment that satisfies C
j . Notice that there are at most tqp possible
group assignments, and that q and p are constants independent of the input ϕ. The list of every
vertex on P
j is {red, white, black}. We attach two vertices pstart
j and pend
j to the start and end of P
j
respectively, and the two vertices are not counted as vertices of the path P
j itself. The list of pstart
j
is {white}. If |V (P
j)| is even, then the list of pend
j is {white}, whereas if |V (P
j)| is odd then the list
of pend
j is {black}. The intention is that to properly color P
j , one needs to use the color red at least
once, and that once is sufficient. The position of the red-colored vertex on the path P
j encodes how
the clause Cj is satisfied.
For every vertex v on P
j , we proceed as follows. The vertex v corresponds to some group assignment to Fi that satisfies the clause Cj . This assignment in turn corresponds to a coloring of
the vertices of Vi . Let this coloring be μi . We build a connector whose role is to enforce that v can
be red only if coloring μi appears on Vi . To build the connector, for each vertex v
i ∈ Vi and color
x ∈ [q] \ {μi (v
i )}, we do the following to enforce that if v is red, then v
i cannot have color x (see
Figure 5).
• If x is red, then we introduce one vertex wy for every color y except for red. We make wy
adjacent to v
i and the list of wy is {red,y}. Then, we introduce a vertex w that is adjacent
to v and to all vertices wy . The list of w is all of [q].
• If x is not red, then we introduce two vertices wy and w
y for each color y except for red.
We make wy adjacent to v
i and w
y adjacent to wy . The list of wy is {x,red}, while the list
of w
y is {y,red}. Finally, we introduce a vertex w adjacent to v and to w
y for all y. The list
of w is all of [q].
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                 
Known Algorithms on Graphs of Bounded Treewidth Are Probably Optimal 13:15
Fig. 4. Reduction to Max Cut. The dashed edges have weight 1 and all the other edges have weight 3n. The
odd and even positions of the paths Pj are shown by black and white, respectively. As an example, we show
potential connections corresponding to the clauses C1 = (v1 ∨v¯2 ∨v4) and C2 = (v¯1 ∨v3 ∨v¯5).
Fig. 5. Reduction to q-Coloring: the way the connector connects a vertex v
i with v for a particular “bad
color” x ∈ [q] \ {μi (v
i )}. The left side shows the case x = red = 1, the right side x = 2 (q = 4).
Notice that in the above construction we have reused the names w, wy and w
y for many different vertices: in each connector, there is a separate vertex w for each vertex v
i ∈ Vi and color
x ∈ [q] \ {μi (v
i )}. Building a connector for each vertex v on P
j concludes the construction of the
clause gadget C
j , and creating one such gadget for each clause concludes the construction of G
(see Figure 6). The following lemma summarizes the most important properties of the connector:
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.      
13:16 D. Lokshtanov et al.
Fig. 6. Reduction to q-Coloring. The t groups of vertices V1, ... , Vt represent the t groups of variables F1,
... , Ft (each of size logqp ). Each vertex of the clause path P
j is connected to one group Vi via a connector
(multiple vertices on the path can be connected to the same group).
Lemma 11. Consider the connector corresponding to a vertex v on P
j and a coloring μi of Vi .
(1) Any coloring on Vi and any color c ∈ {white, black} on v can be extended to the rest of the
connector.
(2) Coloring μi on Vi and any colorc ∈ {red, white, black} on v can be extended to the rest of the
connector.
(3) In any coloring of the connector, if v is red, then μi appears on Vi .
Proof. 1. For each vertex v
i ∈ Vi and color x ∈ [q] \ {μi (v
i )}, we do the following:
• If x is red, then in the construction of C
j we introduced a vertex wy with list {y,red} for
every color y  red adjacent to v
i , and a vertex w with list [q] adjacent to wy for every
y  red. If v
i is colored red, then we color each vertex wy with y and w with red. Notice
that w is adjacent to v, but v is colored either white or black, so it is safe to color w red. If,
on the other hand, v
i is not colored red, then we can color wy red for every y. Then, all the
neighbours of w have been colored with red, except for v, which has been colored white or
black. Thus, it is safe to color w with the color out of black and white that was not used to
color v.
• If x is not red, then in the construction of C
j , we introduced two vertices wy and w
y for
each color y except for red, and also introduced a vertex w. The vertices wy are adjacent to
v
i and for every y  red, the vertex w
y is adjacent to wy . Finally, w is adjacent to all the
vertices w
y and to v. For every y, the list of wy is {x,red} while the list of w
y is {y,red}.
The list of w is [q]. If v
i is colored with x, then we let wy take color red and w
y take color y
for every y  red. We color w with red. In the case that v
i is colored with a color different
from x, we let wy be colored with x and w
y be colored red for every y  red. Finally, all the
neighours of w except for v have been colored red, while v is colored with either black or
white. According to the color of v, we can either color w black or white.
2. We can assume that v is red, otherwise, we are done by the previous statement. For each
vertex v
i ∈ Vi and color x ∈ [q] \ {μi (v
i )}, we do the following.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                   
Known Algorithms on Graphs of Bounded Treewidth Are Probably Optimal 13:17
• If x is red, then in the construction of C
j we introduced a vertex wy with list {y,red} for
every color y  red adjacent to v
i , and a vertex w with list [q] adjacent to wy for every
y  red. Since v
i is not colored red by μi , we can color wy red for every y. Then, all the
neighbours ofw including v have been colored with red and it is safe to colorw with white.
• If x is not red, then in the construction of C
j , we introduced two vertices wy and w
y for
each color y except for red, and also introduced a vertex w. The vertices wy are adjacent
to v
i and for every y  red the vertex w
y is adjacent to wy . Finally, w is adjacent to all the
verticesw
y and to v. For every y, the list ofwy is {x,red} while the list of w
y is {y,red}. The
list of w is [q]. Since μi colors v
i with a color different from x, we let wy be colored with x
and w
y be colored red for every y  red. Finally, all the neighours of w, including v, have
been colored red so it is safe to color w white.
3. Suppose for contradiction that v is red, but some vertex v
i ∈ Vi has been colored with a color
x  μi (v
i ). There are two cases. If x is red, then in the construction, we introduced verticeswy adjacent tov
i for every color y  red. Also, we introduced a vertexw adjacent tov and towy for each
y  red. The list ofwy is{red,y}, and hencewy must have been coloredy for everyy  red. But then
w is adjacent tov, which is colored red, and towy , which is coloredy for everyy  red. Thus, vertex
w has all colors in its neighborhood, a contradiction. In the case when x is not red, then in the construction, we introduced two vertices wy and w
y for each y  red. Each wy was adjacent to v
i and
had {x,red} as its list. Since v
i is colored x, all the wy vertices must be colored red. For every y
red, we have thatw
y is adjacent towy and has {red,y} as its list. Hence, for everyy  red, the vertex
w
y is colored with y. But, in the construction, we also introduced a vertex w adjacent to v and to
w
y for each y  red. Thus again, vertex w has all colors in its neighbourhood, a contradiction.
Lemma 12. If ϕ is satisfiable, then G has a proper list-coloring.
Proof. Starting from a satisfying assignment of ϕ, we construct a coloring γ of G. The assignment to ϕ corresponds to a group assignment to each group Fi . Each group assignment corresponds
to a coloring of Vi . For every i, we let γ color the vertices of Vi using the coloring corresponding
to the group assignment of Fi .
Now, we show how to complete this coloring to a proper coloring of G. Since the gadgets C
j
are pairwise disjoint, and there are no edges going between them, it is sufficient to show that we
can complete the coloring for every gadgetC
j . Consider the clauseCj . The clause contains a literal
that is set to true, and this literal belongs to a variable in some group Fi . The group assignment
of Fi satisfies the clause Cj . Thus, there is a vertex v on P
j that corresponds to this assignment.
We set γ (v) as red (that is, γ colors v red), pstart
j is colored white and pend
j is colored with its only
admissible color, namely black if |V (P
j)| is even and white if |V (P
j)| is odd. The remaining vertices
of P
j are colored alternatingly white or black. By Lemma 11(2), the coloring can be extended to
every vertex of the connector between Vi and v: the coloring appearing on Vi is the coloring μi
corresponding to the group assignment Fi . For every other vertex u on P
j , the color of u is black
or white, thus Lemma 11(1) ensures that the coloring can be extended to any connector on u.
As this procedure can be repeated to color the gadget C
j for every clause Cj , we can complete γ
to a proper list-coloring of G.
Lemma 13. If G has a proper list-coloring γ , then ϕ is satisfiable.
Proof. Given γ , we construct an assignment to the variables of ϕ as follows. For every group
Fi of variables, if γ colors Vi with a coloring that corresponds to a group assignment of Fi , then
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                                  
13:18 D. Lokshtanov et al.
we set this assignment for the variables in Fi . Otherwise, we set all the variables in Fi to false. We
need to argue that this assignment satisfies all the clauses of ϕ.
Consider a clauseCj and the corresponding gadgetC
j . By a simple parity argument, P
j cannot be
colored using only the colors black and white. Thus, some vertex v on P
j is colored red. The vertex
v corresponds to a group assignment of some group Fi that satisfies C
j . As v is red, Lemma 11(3)
implies thatVi is colored with the coloring μi that corresponds to this assignment. The construction
then implies that our chosen assignment satisfiesCj . As this is true for every clause, this concludes
the proof.
Observation 1. The vertices
i ≤t Vi form a feedback vertex set of G. Furthermore,
pw(G) ≤ pt + 4
Proof. Observe that after removing
i ≤t Vi , all that is left are the gadgetsC
j , which do not have
any edges between each other. Each such gadget is a tree, and hence
i ≤t Vi form a feedback vertex
set of G. If we place a searcher on each vertex of
i ≤t Vi , then it is easy to see that each gadget C
j
can be searched with 4 searchers. The pathwidth bound on G follows using Proposition 1.
Lemma 14. If q-List Coloring can be solved in O∗ ((q − ϵ )
fvs(G)
) or O∗ ((q − ϵ )
pw(G)
) time for
some ϵ > 0, then SAT can be solved in O∗ ((2 − δ )
n ) time for some δ > 0.
Proof. Let O∗ ((q − ϵ )
fvs(G)
)= O∗ (qλfvs(G)
) time, where λ = logq (q − ϵ ) < 1. We choose a sufficiently large p such that δ  = λ p
p−1 < 1. Given an instance ϕ of SAT, we construct a graph G
using the construction above, and run the assumed q-List Coloring. Correctness follows from
Lemmata 12 and 13. By Observation 1, the graph G has a feedback vertex set of size p n
p log q .
The choice of p implies that
λp  n
p logq

≤ λp n
(p − 1) logq
+ p ≤ δ  n
logq
+ p ≤ δ n,
for some δ  < 1. Hence, SAT can be solved in time O∗ (2δn ) =O∗ ((2 − δ )
n ), for some δ > 0. By
Observation 1, we also know that pw(G) ≤ pt + 4. Thus, the feedback vertex set size and the pathwidth of the constructed graph just differs by 4. This implies that q-List Coloring cannot be
solved in O∗ ((q − ϵ )
pw(G)
) time.
Finally, observe that we can reduce q-List-Coloring to q-Coloring by adding a clique Q =
{q1,...,qc } on q vertices to G and making qi adjacent to v when i  L(v). Any coloring of Q
must use q different colors, and without loss of generality qi is colored with color i. Then, one can
complete the coloring if and only if one can properly colorG using a color from L(v) for eachv. We
can add the clique Q to the feedback vertex set—this increases the size of the minimum feedback
vertex set by q. Since q is a constant independent of the input, this yields Theorem 4.
7 ODD CYCLE TRANSVERSAL
An equivalent formulation of the Max Cut problem is to ask for a bipartite subgraph with the
maximum number of edges, which is the same as asking for a set of edges of minimum size whose
deletion makes the graph bipartite. We can also consider the vertex-deletion version of this problem. An odd cycle transversal of a graph G is a subset S ⊆ V (G) such that G \ S is bipartite. In the
Odd Cycle Transversal problem, we are given a graph G together with an integer k and asked
whether G has an odd cycle transversal of size k.
Theorem 5. If Odd Cycle Transversal can be solved in O∗ ((3 − ϵ )
pw(G)
) time for ϵ > 0, then
SAT can be solved in O∗ ((2 − δ )
n ) time for some δ > 0.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.               
Known Algorithms on Graphs of Bounded Treewidth Are Probably Optimal 13:19
Fig. 7. Reduction to Odd Cycle Transversal. The arrow A(u,v) from u to v with the passive odd cycle
transversal shown in white (left) and the active odd cycle transversal of A(u,v) \ {u} (right).
Construction. Given ϵ > 0 and an instance ϕ of SAT, we construct a graph G as follows. We
choose an integer p based just on ϵ. Exactly how p is chosen will be discussed at the end of this
section. We start by grouping the variables of ϕ into t groups F1,..., Ft of size at most h = log 3p .
Thus, t =  n
log 3p  . We will call an assignment of truth values to the variables in a group Fi a group
assignment. We will say that a group assignment satisfies a clause Cj of ϕ if Cj contains at least
one literal that is set to true by the group assignment. Notice that Cj can be satisfied by a group
assignment of a group Fi even though Cj also contains variables that are not in Fi .
Now, we describe an auxiliary gadget that will be very useful in our construction (see Figure 7).
For two vertices u and v by adding an arrow from u to v, we will mean adding a path ua1a2a3v
on four edges starting in u and ending in v. Furthermore, we add four vertices b1, b2, b3, and b4
and edges ub1, b1a1, a1b2, b2a2, a2b3, b3a3, a3b4, b4v, and b4v. Denote the resulting graph A(u,v).
None of the vertices in A(u,v) except for u and v will receive any further neighbours throughout
the construction of G. The graph A(u,v) has the following properties, which are useful for our
construction.
• The unique smallest odd cycle transversal of A(u,v) is {a1, a3}. We call this the passive odd
cycle transversal of the arrow.
• In A(u,v) \ {a1, a3}, u and v are in different connected components.
• The set {a2,v} is a smallest odd cycle transversal of A(u,v) \ {u}. We call this the active odd
cycle transversal of the arrow.
The intuition behind an arrow from u to v is that if u is put into the odd cycle transversal, then
v can be put into the odd cycle transversal “for free.” When the active odd cycle transversal of the
arrow is picked, we say the arrow is active; otherwise, we say the arrow is passive.
To construct G, we make t · p paths, {Pi,j} for 1 ≤ i ≤ t, 1 ≤ j ≤ p (see Figure 8). Each path has
3m(tp + 1) vertices, and the vertices of Pi,j are denoted by p
i,j for 1 ≤  ≤ 3m(tp + 1). For a fixed
i, the paths {Pi,j : 1 ≤ j ≤ p} correspond to the set Fi of variables. For every 1 ≤ i ≤ t, 1 ≤ j ≤ p,
and 1 ≤  < 3m(tp + 1), we add three vertices a
i,j , b
i,j and q
i,j adjacent to each other. We also
add the edges a
i,j
p
i,j and b
i,j
p+1 i,j . One can think of the vertices of the paths {Pi,j} layed out as
rows in a matrix, where for every fixed 1 ≤  ≤ 3m(tp + 1) there is a column {p
i,j : 1 ≤ i ≤ t, 1 ≤
j ≤ p}. We group the colums three by three. In particular, for every i ≤ t and 0 ≤  < m(tp + 1),
we define the sets P
i = {p3+1 i,j ,p3+2 i,j ,p3+3
i,j : 1 ≤ j ≤ p}, A
i = {a3+1 i,j , a3+2 i,j , a3+3
i,j : 1 ≤ j ≤ p}, B
i =
{b3+1 i,j ,b3+2 i,j ,b3+3
i,j : 1 ≤ j ≤ p} and Q
i = {q3+1 i,j ,q3+2 i,j ,q3+3
i,j : 1 ≤ j ≤ p}.
For every i ≤ t and 0 ≤  < m(tp + 1), we make two new sets L
i and R
i of new vertices. Both L
i
and R
i are independent sets of size 5p, and we add all the edges possible between L
i and R
i . From
L
i , we pick a special vertex λ
i and from R
i , we pick ρ
i . We make all the vertices in A
i adjacent to
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                                         
13:20 D. Lokshtanov et al.
Fig. 8. Reduction to Odd Cycle Transversal. The path Pi,j with three different ways of removing a set Z
and partitioning the remaining bipartite graph into classes L and R.
all vertices of L
i , and we make all vertices in B
i adjacent to all vertices of R
i . We make λ
i adjacent
to ρ+1 i , except for  = m(tp + 1) − 1.
We will say that a subset S of P
i that picks exactly one vertex from Pi,j for every 1 ≤ j ≤ p is
good. The idea is that there are 3p ≥ 2h good subsets of P
i , so we can make group assignments
of Fi correspond to good subsets of P
i . For every good subset S of P
i , we add a cycle X
i,S . The
cycle X
i,S has length 2p + 1. We select a vertex on X
i,S and call it x
i,S . For every vertex u ∈ P
i \ S,
we add an arrow from u to a vertex of X
i,S . We add arrows in such a way that every vertex of
X
i,S \ {x
i,S } is the endpoint of exactly one arrow.
For every i ≤ t and 0 ≤  < m(tp + 1), we make a cycle Y
i of length 3p . Notice that the length
of the cycle is odd. Every vertex of Y
i corresponds to a good subset S of P
i . For each good subset
S of P
i , we add an arrow from x
i,S of the cycle X
i,S to the vertex in Y
i that corresponds to S.
We say that a good subset of P
i is equal with a good subset S of P
i if for every 1 ≤ j ≤ t, the
distance along Pi,j between the vertex of S on Pi,j and the vertex of S on Pi,j is divisible by 3.
Informally, S and S are equal if they look identical when we superimpose P
i onto P
i . To every
group assignment of variables Fi , we designate a good subset of P
i for every . We designate good
subsets in such a way that good subsets corresponding to the same group assignment are equal.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                                
Known Algorithms on Graphs of Bounded Treewidth Are Probably Optimal 13:21
Finally, for every clauseCj , 1 ≤ j ≤ m, we will introduce tp + 1 cycles. That is, for every 0 ≤ r ≤
tp, we inroduce a cycle C
r
j . The cycle contains one vertex for every i ≤ t and group assignment
to Fi , and potentially one dummy vertex to make it have odd length. Going around the cycle
counterclockwise, we first encounter all the vertices corresponding to group assignments of F1,
then all the vertices corresponding to group assignments of F2, and so on. For i ≤ t and every
good subset S of Prm+j
i that corresponds to a group assignment of Fi that satisfies Cj , we add an
arrow from xrm+j
i,S to the vertex on C
r
j that corresponds to the same group assignment of Fi as S
does. This concludes the construction of G.
The intention behind the construction is that if ϕ is satisfiable, then a minimum odd cycle
transversal of G can pick:
• One vertex from each triangle {a
i,j
,b
i,j
,q
i,j} for each 1 ≤ i ≤ t, 1 ≤ j ≤ p, 1 ≤  < 3m(tp +
1). There are tp(3m(tp + 1) − 1) such triangles in total.
• One vertex from {p3+1 i,j ,p3+2 i,j ,p3+3
i,j } for each 1 ≤ i ≤ t, 1 ≤ j ≤ p, 0 ≤  < m(tp + 1). There
are tpm(tp + 1) such triples.
• Two vertices from every arrow added, without counting the starting point of the arrow. For
each i ≤ t and 0 ≤  < m(tp + 1), there are 2p3p arrows ending in some cycle X
i,S . Hence,
there are 2p3ptm(tp + 1) such arrows. For every i ≤ t and 0 ≤  < m(tp + 1) there are 3p
arrows ending in the cycle Y
i . Hence, there are 3ptm(tp + 1) such arrows. For every clause
Cj , there are tp + 1 arrows added for every group assignment that satisfies that clause. Let
μ be the sum over all clauses of the number of group assignments that satisfy that clause.
The total number of arrows added is then μ(tp + 1) + (2p + 1)3ptm(tp + 1). Thus, the odd
cycle transversal can pick 2μ(tp + 1) + 2(2p + 1)3ptm(tp + 1) vertices from arrows.
• One vertex x
i,S for every i ≤ t and 0 ≤  < m(tp + 1). There are tm(tp + 1) choices fori and
.
We let the α be the value of the total budget, that is the sum of the items above.
Lemma 15. If ϕ is satisfiable, then G has an odd cycle transversal of size α.
Proof. Given a satisfying assignment γ to ϕ, we construct an odd cycle transversal Z of G of
size α together with a partition ofV (G) \ Z into L and R such that every edge ofG \ Z goes between
a vertex in L and a vertex in R. The assignment to ϕ corresponds to a group assignment of each Fi
for 1 ≤ i ≤ t. For every 1 ≤ i ≤ t and 0 ≤  < m(tp + 1), we add to Z the good subset S of P
i that
corresponds to the group assignment of Fi . Notice that for each fixed i, the sets picked from P
i
and P
i are equal for any , 
. At this point, we have picked one vertex from {p3+1 i,j ,p3+2 i,j ,p3+3
i,j }
for each 1 ≤ i ≤ t, 1 ≤ j ≤ p, 0 ≤  < m(tp + 1).
For every fixed 1 ≤ i ≤ t, 1 ≤ j ≤ p, there are three cases. If p1
i,j ∈ Z, then we put p2
i,j into L and
p3
i,j into R. If p2
i,j ∈ Z, then we put p1
i,j into R and p3
i,j into L. If p3
i,j ∈ Z, then we put p1
i,j into L and
p2
i,j into R. Now, for every 4 ≤  ≤ 3m(tp + 1) such that p
i,j  Z, we put p
i,j into the same set out
of {L, R} as p
i,j where 1 ≤  ≤ 3 and  ≡  mod 3.
For every 1 ≤ i ≤ t, 0 ≤  ≤ m(tp + 1), we put L
i into L and R
i into R. For every triple of a,b,q
of pairwise adjacent vertices such that a ∈ A
i , b ∈ B
i , and q ∈ Q
i , we proceed as follows. The
vertex a has a neighbour a in P
i and b has a neighbour b in P
i . There is a j such that b is the
successor of a on Pi,j . Thus, there are three cases:
• a ∈ Z and b ∈ L, we put a in R, q in L and b in Z;
• a ∈ R and b ∈ Z, we put a in Z, q in R and b in L;
• a ∈ L and b ∈ R, we put a in R, q in Z and b in L.
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                                           
13:22 D. Lokshtanov et al.
For every 1 ≤ i ≤ t, 0 ≤  ≤ m(tp + 1), there are many arrows from vertices in P
i to vertices on
cycles X
i,S for good subsets S of P
i . For each arrow, if its endpoint in P
i is in Z, we add the active
odd cycle transversal of the arrow to Z, otherwise, we add the passive odd cycle transversal of the
arrow to Z. In either case, the remaining vertices on the arrow form a forest, and therefore we can
insert the remaining vertices of the arrow into L and R according to which sets out of {L, R,Z} u
and v are in.
For every 1 ≤ i ≤ t, 0 ≤  ≤ m(tp + 1), there is exactly one set S such that the cycle X
i,S only
has passive arrows pointing into it. This is exactly the set S, which corresponds to the restriction
of γ to Fi . Each cycle X
i,S that has at least one arrow pointing into them already contains at least
one vertex in Z—the endpoint of the active arrow pointing into the cycle. Thus, we can partition
the remaining vertices of X
i,S into L and R such that no edge has both endpoints in L or both
endpoints in R. For the cycle X
i,S , we put x
i,S into Z and partition the remaining vertices of X
i,S
into L and R such that no edge has both endpoints in L or both endpoints in R. We add the active
odd cycle transversal in the arrow from x
i,S to the cycle Y
i into Z. For all other good subsets S
,
we add the passive odd cycle transversal in the arrow from x
i,S to the cycle Y
i into Z. Thus, each
cycle Y
i contains one vertex in Z and the remaining vertices of Y
i can be distributed into L and R.
For every arrow that goes from a vertex x
i,S into a cycleC
r
h, we add the active odd cycle transversal of the arrow to Z if x
i,S ∈ Z and add the passive odd cycle transversal to Z, otherwise. Again
the remaining vertices on each arrow can easily be partitioned into L and R such that no edge has
both endpoints in L or both endpoints in R. This concludes the construction of Z. Since we have
put the vertices into Z in accordance to the budget described in the construction it follows that
|Z | ≤ α. All that remains to show, is that for each 1 ≤ h ≤ m and 0 ≤ r ≤ tp, the cycle C
r
h has at
least one active arrow pointing into it.
The cycleC
r
h corresponds to the clauseCh. The clauseCh is satisfied byγ , and hence it is satisfied
by the restriction of γ to some group Fi . This restriction is a group assignment of Fi , and hence it
corresponds to a good subset S of Prm+h
i , which happens to be exactly Z ∩ Prm+h
i . Thus, xrm+h
i,S ∈ Z,
and since the restriction of γ to Fi satisfies Ch, there is an arrow pointing from xrm+h
i,S and into C
r
h.
Since this arrow is active, this concludes the proof.
Lemma 16. If G has an odd cycle transversal of size α, then ϕ is satisfiable.
Proof. Let Z be an odd cycle transversal of G of size α. Since G \ Z is bipartite, the vertices of
G \ Z can be partitioned into L and R such that every edge of G \ Z has one endpoint in L and the
other in R. Given Z, L, and R, we construct a satisfying assignment to ϕ. Every arrow in G must
contain at least two vertices in Z, not counting the startpoint of the arrow. Let Z be a subset of
Z containing two vertices from each arrow, but no arrow start point. Observe that no two arrows
have the same endpoint, and therefore |Z | is exactly two times the number of arrows in G. Let
Z = Z \ Z.
We argue that for any 1 ≤ i ≤ t and 0 ≤  < m(tp + 1), we have |Z ∩ (L
i ∪ R
i ∪ A
i ∪ B
i ∪ Q
i ∪
P
i )| ≥ 4p. Observe that no vertices in L
i , R
i , A
i , B
i , Q
i , or P
i are endpoints of arrows, and hence
they do not contain any vertices of Z. Suppose for contradiction that |Z ∩ (L
i ∪ R
i ∪ A
i ∪ B
i ∪
Q
i ∪ P
i )| < 4p. Then, there is a vertex in λ ∈ L
i \ Z and a vertex ρ ∈ R
i \ Z
. Without loss of
generality, λ ∈ L and ρ ∈ R. Furthermore, there is a 1 ≤ j ≤ p such that
|Z ∩ {p3+1 i,j ,p3+2 i,j ,p3+3
i,j , a3+1 i,j , a3+2 i,j , a3+3
i,j ,b3+1 i,j ,b3+2 i,j ,b3+3
i,j ,q3+1 i,j ,q3+2 i,j ,q3+3
i,j }| < 4.
Since {a3+1 i,j ,b3+1 i,j ,q3+1 i,j }, {a3+2 i,j ,b3+2 i,j ,q3+2 i,j }, and {a3+3
i,j ,b3+3
i,j ,q3+3
i,j } form triangles and must
contain a vertex from Z each, it follows that each of these triangles contain exactly one vertex
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                                                                       
Known Algorithms on Graphs of Bounded Treewidth Are Probably Optimal 13:23
from Z and that Z ∩ {p3+1 i,j ,p3+2 i,j ,p3+3
i,j } = ∅. Since λ ∈ L and ρ ∈ R, λ is adjacent to all vertices
of A
i,j and ρ is adjacent to all vertices of B
i,j , it follows that A
i,j \ Z ⊆ R and B
i,j \ Z ⊆ L.
Hence, there are two cases to consider either (1) {p3+1 i,j ,p3+3
i,j } ⊆ L and p3+2 i,j ∈ R or (2)
{p3+1 i,j ,p3+3
i,j } ⊆ R and p3+2 i,j ∈ L. In the first case, observe that either a3+2 i,j ∈ R or b3+2 i,j ∈ L, and
hence either a3+2 i,j p3+2 i,j or b3+2 i,j p3+3
i,j have both endpoints in the same set out of {L, R}, a contradiction. The second case is similar, either a3+1 i,j ∈ R or b3+1 i,j ∈ L, and hence either a3+1 i,j p3+1 i,j or
b3+1 i,j p3+2 i,j have both endpoints in the same set out of {L, R}, a contradiction. We conclude that
|Z ∩ (L
i ∪ R
i ∪ A
i ∪ B
i ∪ Q
i ∪ P
i )| ≥ 4p.
For any 1 ≤ i ≤ t and 0 ≤  < m(tp + 1), Y
i is an odd cycle so Y
i contains a vertex in Z. If Y
i
contains no vertices of Z
, then it contains a vertex from Z and there is an active arrow pointing
into Y
i . The starting point of this arrow is a vertex x
i,S for some good subset S of P
i . Since the
arrow is active and x
i,S is not the endpoint of any arrow, we know that x
i,S ∈ Z
. Hence, for
any 1 ≤ i ≤ t and 0 ≤  < m(tp + 1), we have that either there is a good subset S of P
i such that
x
i,S ∈ Z or at least one vertex of Y
i is in Z
.
The above arguments, together with the budget constraints, imply that for every 1 ≤ i ≤ t and
0 ≤  < m(tp + 1), we have |Z ∩ (L
i ∪ R
i ∪ A
i ∪ B
i ∪ Q
i ∪ P
i )| = 4p and that |Z ∩ {x
i,S } ∪
V (Y
i )| = 1, where the union is taken over all good subsets S of P
i . It follows Z ∩ P
i is a good
subset of P
i . Let S = Z ∩ P
i . The cycle X
i,S has odd length, and hence it must contain some vertex from Z. On the other hand, all the arrows pointing into X
i,S are passive, so X
i,S cannot contain
any vertices from Z. Thus X
i,S contains a vertex from Z
, and by the budget constraints this must
be x
i,S .
Now, consider three consecutive vertices p
i,j , p+1 i,j , p+2 i,j for some 1 ≤ i ≤ t, 1 ≤ j ≤ p, 1 ≤
 ≤ 3m(tp + 1) − 2. We prove that at least one of them has to be in Z. Suppose not. We know
that neither λ/3
i , ρ /3
i , λ/3+1
i nor ρ /3+1
i are in Z. Thus, without loss of generality
{λ/3
i , λ/3+1
i } ⊆ L and {ρ /3
i , ρ /3+1
i } ⊆ R. There are two cases. Eitherp
i,j ∈ R andp+1 i,j ∈ L or
p+1 i,j ∈ L and p+3
i,j ∈ R. In the first case, we obtain a contradiction, since either a
i,j ∈ R or b
i,j ∈ L. In
the second case, we get a contradiction, since either a+1 i,j ∈ R or b+1 i,j ∈ L. Hence, for any three consecutive vertices on Pi,j , at least one of them is in Z. Since the budget constraints ensure that there
are at most |V (Pi,j)|/3 vertices in Pi,j ∩ Z, it follows from the pigeon hole principle that there is
an 0 ≤ r ≤ tp such that for any 1 ≤ i ≤ t and 1 ≤ h ≤ m and 1 ≤ h ≤ m, the set Prm+h
i ∩ Z equals
Prm+h
i ∩ Z. Here equality is in the sense of equality of good subsets of P
i .
For every 1 ≤ i ≤ t, Prm+1 i ∩ Z is a good subset of Prm+1 i . If Prm+1 i ∩ Z corresponds to a group
assignment of Fi , then we set the variables in Fi to this assignment. Otherwise, we set all the variables in Fi to false. We need to argue that every clause Ch is satisfied by this assignment. Consider
the cycleC
r
h. Since it is an odd cycle, it must contain a vertex fromZ, the budget constraints and the
discussion above implies that this vertex is from Z. Hence, there must be an active arrow pointing
into C
r
h. The starting point of this active arrow is a vertex xmr+h
i,S for some i and good subset S of
Pmr+h
i . The set S corresponds to a group assignment of Fi that satisfiesCh. Since the arrow is active
xmr+h
i,S ∈ Z
, and by the discussion above, we have that Pmr+h
i ∩ Z = S. Now, S = Pmr+h
i ∩ Z and
S is equal to Pmr+1 i ∩ Z
, and hence the assignment to the variables of Fi satisfies Ch. Since this
holds for all clauses, this concludes the proof.
Lemma 17. pw(G) ≤ t(p + 1) + 10p3p .
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                                                                                          
13:24 D. Lokshtanov et al.
Proof. We show how to search the graph using at mostt(p + 1) + 10p3p searchers. The strategy
consists of m(tp + 1) rounds numbered from round 0 to round m(tp + 1) − 1. Each round has t
stages, numbered from 1 to t. In the beginning of round k there is a searcher on p3k+1 i,j and ρk
i
for every 1 ≤ i ≤ t, 1 ≤ j ≤ p. Let r and 1 ≤ h ≤ m be integers such that k + 1 = rm + h. Recall
that as we go around C
r
h counterclockwise, we first encounter vertices corresponding to group
assignments of F1, then to assignments of F2 and so on. In the beginning of round k, we place a
searcher on the first vertex onC
r
h that corresponds to an assignment of F1. IfC
r
h contains a dummy
vertex, then we place a searcher on this vertex as well. These two searchers will remain on their
respective vertices throughout the round. In the beginning of stage s of round k, we will assume
that the vertices on the cycle C
r
h corresponding to group assignments of Fs, s < s have already
been cleaned, and in the beginning of every stage s > 1, there is a searcher standing on the first
vertex corresponding to a group assignment of Fs .
In stage s of round k, we place searchers on all vertices of Pk
s , Ak
s , Bk
s , Qk
s , Lk
s , Rk
s , Yk
s and all
vertices of cycles Xk
s,S for every good subset S of Pk
s , on all vertices of arrows starting or ending
in such cycles, and on all vertices of C
r
h corresponding to group assignments of Fs . In total, this
amounts to less than 10p3p vertices.
In the last part of stage s of round k, we place searchers on p
3(k+1)+1
s,j for every 1 ≤ j ≤ p and
on ρk+1 s . Then, we remove all the searchers that were placed out in the first part of phase s except
for the searcher on the last vertex on C
r
h corresponding to a group assignment of Fs . Unless s = 1
there is also a searcher on the last vertex on C
r
h corresponding to a group assignment of Fs−1. We
remove this searcher, and the next stage can commence. In the end of the last stage of round k,
we remove all the searchers from C
r
h. Then, the last stage can commence. At any point in time, at
most t(p + 1) + 10p3p searchers are placed on G.
Proof (of Theorem 5). Suppose Odd Cycle Transversal can be solved in time O∗ ((3 −
ϵ )
pw(G)
) for some ϵ > 0. Then there is an ϵ  < 1 such that O∗ ((3 − ϵ )
pw(G)
) ≤ O∗ (3ϵ
pw(G)
).
We choose p large enough such that ϵ  · p+1
p−1 = δ  < 1. Given an instance of SAT, we construct
an instance of Odd Cycle Transversal using the above construction and the chosen value of p.
Then, we solve the Odd Cycle Transversal instance using the O∗ ((3 − ϵ )
pw(G)
) time algorithm.
Correctness is ensured by Lemmata 15 and 16. Lemma 17 yields that the total time taken is upper bounded by O∗ ((3 − ϵ )
pw(G)
) ≤ O∗ (3ϵ
pw(G)
) ≤ O∗ (3ϵ
(t(p+1)+f (ϵ
)) ) ≤ O∗ (3
ϵ n p log 3 (p+1)
) ≤
O∗ (3
ϵ n(p+1)
p log 3 ) ≤ O∗ (3
ϵ n(p+1)
(p−1) log 3 ) ≤ O∗ (3
δ n
log 3 ) ≤ O∗ (2δ
n ) =. O∗ ((2 − δ )
n ) for δ < 1.
8 PARTITION INTO TRIANGLES
A triangle packing in a graph G is a collection of pairwise disjoint vertex sets S1, S2,... St in G
such that Si induces a triangle in G for every i. The size of the packing ist. If V (G) =
i ≤t Si , then
the collection S1 ... St is a partition of G into triangles. In the Triangle Packing problem, we are
given a graph G and an integer t and asked whether there is a triangle packing in G of size at least
t. In the Partition Into Triangles problem, we are given a graph G and asked whether G can
be partitioned into triangles. Notice that since Partition Into Triangles is the special case of
Triangle Packing when the number of triangles is the number of vertices divided by 3, the bound
of Theorem 6 holds for Triangle Packing as well.
Theorem 6. If Partition Into Triangles can be solved in time O∗ ((2 − ϵ )
pw(G)
) for ϵ > 0,
then SAT can be solved in O∗ ((2 − δ )
n ) time for some δ > 0.
Construction. First show the lower bound for Triangle Packing and then modify our
construction to also work for the more restricted Partition Into Triangles problem. Given an
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.           
Known Algorithms on Graphs of Bounded Treewidth Are Probably Optimal 13:25
Fig. 9. Reduction to Triangle Packing, showing how the vertices c r
j and d
r
j representing clause Cj = (x1 ∨
x¯2 ∨ x4) are connected to the paths P1, ... , Pn.
instance ϕ of SAT, we construct a graphG as follows (see Figure 9). For every variable vi , we make
a path Pi on 2m(n + 1) + 1 vertices. We denote the th vertex of Pi by p
i . For every i, we add a set
Ti of 2m(n + 1) vertices, and let the th vertex of Ti be denoted t
i . For every 1 ≤  ≤ 2m(n + 1),
we add the edges t
i p
i and t
i p+1 i .
For every clauseCj , we add n + 1 gadgets corresponding to the clause. In particular, for every 0 ≤
r ≤ n, we do the following. First, we add the verticescr
j and d
r
j and the edgecr
j d
r
j . For every variable
vi that occurs in Cj positively, we add the edges cr
j t
2(mr+j)
i and d
r
j t
2(mr+j)
i . For every variable vi
that occurs in Cj negated, we add the edges cr
j t
2(mr+j)−1
i and d
r
j t
2(mr+j)−1
i . Doing this for every r
and every clause Cj concludes the construction of G.
Lemma 18. If ϕ satisfiable, then G has a triangle packing of size mn(n + 1) + m(n + 1).
Proof. Consider a satisfying assignment to ϕ. For every variablevi that is set to true and integer
1 ≤  ≤ m(n + 1), we add {t 2l−1 i ,p2l−1 i ,p2l
i } to the triangle packing. For every variable vi that is set
to false and integer 1 ≤  ≤ m(n + 1), we add {t 2l
i ,p2l
i ,p2l+1 i } to the triangle packing. For every
clause Cj , there is a literal set to true. Suppose this literal corresponds to the variable vi . Notice
that if vi occurs positively in Cj , then vi is set to true, and if it occurs negatively it is set to false.
For each 0 ≤ r ≤ n, if vi occurs positively inCj , then t
2(mr+j)
i has not yet been used in any triangle,
so we can add {cr
j ,d
r
j ,t
2(mr+j)
i } to the triangle packing. On the other hand, if vi occurs negated in
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                       
13:26 D. Lokshtanov et al.
Cj , then t
2(mr+j)−1
i has not yet been used in any triangle, so we can add {cr
j ,d
r
j ,t
2(mr+j)−1
i } to the
triangle packing. In total mn(n + 1) + m(n + 1) triangles are packed.
Lemma 19. If G has a triangle packing of size mn(n + 1) + m(n + 1), then ϕ satisfiable.
Proof. Observe that for any j and r, every triangle that contains cr
j also contains d
r
j and vice
versa. Furthermore, if we remove all the vertices cr
j and d
r
j for every j and r from G, we obtain
a disconnected graph with n connected components, G[Ti ∪V (Pi )] for every i. Thus, the only
way to pack mn(n + 1) + m(n + 1) triangles in G is to pack mn(n + 1) triangles in each component
G[Ti ∪V (Pi )] and in addition make sure that every pair (cr
j ,d
r
j ) is used in some triangle in the
packing.
The only way to pack mn(n + 1) triangles in a component G[Ti ∪V (Pi )] is to use every second
triangle of the form {t
i ,p
i ,p+1 i }, except possibly at one point where two triangles on this form
are skipped. By the pigeon hole principle there is an 0 ≤ r ≤ n such that for every i, every second
triangle of the form {t 2mr+
i ,p2mr+
i ,p2mr++1 i } for 1 ≤  ≤ 2m is used. We make an assignment to
the variables of ϕ as follows. For every i such that {t 2mr+1 i ,p2mr+1 i ,p2mr+2 i } is used, vi is set to true,
and otherwise {t 2mr+2 i ,p2mr+2 i ,p2mr+3
i } is used in the packing and vi is set to false. We prove that
this assignment satisfies ϕ.
For every j, the pair (cr
j ,d
r
j ) is used in some triangle in the packing. This triangle either contains
t
2(mr+j)
i ort
2(mr+j)−1
i for some i. If it containst
2(mr+j)
i , then vi occurs positively inCj . Furthermore,
since the triangle packing contains every second triangle of the form {t 2mr+
i ,p2mr+
i ,p2mr++1 i } for
1 ≤  ≤ 2m, it follows that the triangle packing contains {t 2mr+1 i ,p2mr+1 i ,p2mr+2 i }, and hence vi is
set to true. By an identical argument, if the triangle containing the pair (cr
j ,d
r
j ) containst
2(mr+j)−1
i ,
then vi occurs negated in Cj and vi is set to false. This concludes the proof.
We now modify the construction to work for Partition Into Triangles instead of Triangle
Packing. Given the graph G as constructed from ϕ, we construct a graph G as follows. For every
1 ≤ i ≤ n and 1 ≤ l ≤ m(n + 1), we make a clique Q
i on four vertices. The vertices of Q
i are all
adjacent to t 2l
i and to t 2l−1 i . For every i < n and 1 ≤ l ≤ m(n + 1), we make all vertices of Q
i adjacent to all vertices of Q
i+1. Suppose that 2n + 2 is p modulo 3 for some p ∈ {0, 1, 2}. We remove p
vertices from Q
n for every l ≤ m(n + 1).
Lemma 20. G has a triangle packing of size α if and only if G can be partitioned into triangles.
Here, α is a non-negative integer.
Proof. In the forward direction, consider a triangle packing of size α in G as constructed in
Lemma 18. We can assume that the triangle packing has this form, because by Lemma 19, we have
that ϕ is satisfiable.
For every fixed 1 ≤ l ≤ m(n + 1), we proceed as follows. We know that there exists an i such
that both t 2l
i and t 2l−1 i are used in the packing. For every i  i, exactly one out of t 2l
i and t 2l−1 i is
used in the packing. For each such i
, we make a triangle containing the unused vertex out of t 2l
i
and t 2l−1 i and two vertices of Q
i. Then, we “clean up” Q
1 ,...,Q
n as follows.
In particular, we start with the yet unused vertices ofQ
1 . There are two of them. Make a triangle
containing these two vertices and one vertex of Q
2 . Now Q
2 has one unused vertex left. Make a
triangle containing this vertex and the two unused vertices of Q
3 . Continue in this fashion until
arrive atQ
i. At this point, we have used 0, 1, or 2 vertices ofQ
i a triangle containing some vertices
in Q
i−1. The case when we have used 0 vertices of Q
i also covers the case that i = 1. If we only
used 0 or 1 vertices of Q
i, then we add a triangle that contains 3 vertices of Q
i. If there are still
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                                            
Known Algorithms on Graphs of Bounded Treewidth Are Probably Optimal 13:27
unused vertices in Q
i, then their number is either 1 or 2. We make a triangle containing these
vertices and 1 or 2 of the unused vertices of Q
i+1. Now, we proceed to Q
i+1 and continue in this
manner until we reach Q
n. Since the total number of vertices in
j ≤n Q
j is 4n − p, we know that
2n − 2 of these vertices are used for triangles with vertices of G, and 2n + 2 − p is divisible by 3 the
process described above will partition all the unused vertices of
j ≤n Q
j into triangles.
In the reverse direction, we argue that in any partitioning ofG into triangles, exactly α triangles
must lie entirely within G. In fact, we argue that for any l ≤ m(n + 1) exactly n − 1 vertices out of

i ≤n {t 2l
i ,t 2l−1 i } are used in triangles containing vertices from
i ≤n Q
i .
Pick 1 ≤ j ≤ m and r such thatl = mr + j. Exactly one out of
i ≤n {t 2l
i ,t 2l−1 i } is in a triangle with
cr
j and d
r
j . Furthermore, for each i ≤ n the vertex p2l
i must be in a triangle either containing t 2l
i or
t 2l
i . Hence, at most n − 1 vertices out of
i ≤n {t 2l
i ,t 2l−1 i } are used in triangles containing vertices
from
i ≤n Q
i . Furthermore, any triangle containing t 2l
i or t 2l−1 i } must either contain p2l
i , cr
j or
some vertex in
i ≤n Q
i . Hence, exactly n − 1 vertices out of
i ≤n {t 2l
i ,t 2l−1 i } are used in triangles
containing vertices from
i ≤n Q
i . Thus in the packing, exactly 3α vertices in G are contained in
triangles completely inside G, and hence G has a triangle packing of size α.
To complete the proof for Partition Into Triangles, we need to bound the pathwidth of G
.
Lemma 21. pw(G
) ≤ n + 10.
Proof. We give a search strategy for G that uses n + 10 searchers. The strategy consists of
m(n + 1) rounds and each round has n stages. In the beginning of round l, 1 ≤ l ≤ m(n + 1), there
are n searchers placed, one on each vertex p2l−1 i for every i. Let r and 1 ≤ j ≤ m be integers such
that l = mr + j. We place one searcher on cr
j and one on d
r
j . These two searchers will stay put
throughout the duration of this round. In stage i of round l, we place searchers on all vertices of
Q
i and Q
i+1. Then, we place searchers on t 2l−1 i , t 2l
i , p2l
i and p2l+1 i . At the end of stage i, we remove
the searchers fromQ
i , t 2l−1 i , t 2l
i and p2l
i . We then proceed to the next stage. At the end of the round,
we remove the searchers from cr
j and d
r
j . Notice that now there are searchers on p2l+1 i for every i,
and the next round can commence.
Lemmata 18, 19, 20, and 21 prove Theorem 6.
9 CONCLUSION
We have showed that for a number of basic graph problems, the best-known algorithms parameterized by treewidth are optimal in the sense that base of the exponential dependence on treewidth
is best possible. Recall that for Dominating Set and Partition Into Triangles, this running time
was obtained using the technique of fast subset sum convolutions [50]. Thus, it could have been a
real possibility that the running time is improved for some other problems as well.
The results are proved under the Strong Exponential Time Hypothesis (SETH). While this hypothesis is extremely strong and might not be accepted by everyone, our results at least make
a connection between rather specific graph problems and the very basic issue of better Sat algorithms. Our results suggest that one should not try to find better algorithms on bounded treewidth
graphs for the problems considered in the article: as this would disprove SETH, such an effort is
better spent on trying to disprove SETH directly in the domain of satisfiability. Finally, we suggest
the following open questions for future work:
• Can we prove similar tight lower bounds under the restriction that the graph is planar? Or
is it possible to find improved algorithms on bounded treewidth planar graphs?
ACM Transactions on Algorithms, Vol. 14, No. 2, Article 13. Publication date: April 2018.                                
13:28 D. Lokshtanov et al.
• For the q-Coloring problem, we were able to prove lower bounds parameterized by the
feedback vertex set number. Can we prove such bounds for the other problems as well?
Recently, Jaffke and Jansen [33] strengthened our lower bounds for q-Coloring. In particular, they showed that q-Coloring parameterized by the modulator to linear forests (a
forest where every connected component is a path), say lfvs(G), cannot be solved in time
(q − ϵ )
lfvs(G)
|V (G)|
O(1)
.