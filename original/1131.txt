A seed in a word is a relaxed version of a period in which the occurrences of the repeating subword may
overlap. Our first contribution is a linear-time algorithm computing a linear-size representation of all seeds
of a word (the number of seeds might be quadratic). In particular, one can easily derive the shortest seed
and the number of seeds from our representation. Thus, we solve an open problem stated in a survey by
Smyth from 2000 and improve upon a previous O(n logn)-time algorithm by Iliopoulos et al. from 1996. Our
approach is based on combinatorial relations between seeds and subword complexity (used here for the first
time in the context of seeds).
In previous papers, compact representations of seeds consisted of two independent parts operating on the
suffix tree of the input word and the suffix tree of its reverse, respectively. Our second contribution is a novel
and significantly simpler representation of all seeds that avoids dealing with the suffix tree of the reversed
word. This result is also of independent interest from a combinatorial point of view.
A preliminary version of this work, with a much more complex algorithm constructing a representation of
seeds on two suffix trees, was presented at the 23rd Annual ACM-SIAM Symposium on Discrete Algorithms
(SODA’12).
CCS Concepts: • Theory of computation → Pattern matching;
Additional Key Words and Phrases: Seed of a word, quasiperiodicity, suffix tree, subword complexity
1 INTRODUCTION
The notion of periodicity in words is widely used in many fields, such as combinatorics on words,
pattern matching, data compression, automata theory, formal language theory, and molecular biology (see [44]). The concept of quasiperiodicity, introduced by Apostolico and Ehrenfeucht [7],
Fig. 1. The word aba (above) is the shortest seed of the word w = aabaababaababaabaa. Another seed of w
is abaab (below). Two of its “overhangs” correspond to boundary subwords aab and abaa. In total, the word
w has 35 distinct seeds, but it does not have a non-trivial cover.
is a generalization of the notion of periodicity: A quasiperiodic word is entirely covered by occurrences of another (shorter) word, called the quasiperiod or the cover. The occurrences of the
quasiperiod may overlap, whereas in a periodic repetition the occurrences of the period do not
overlap. Hence, quasiperiodicity enables detection of repetitive structure of words that cannot be
found using the classic characterizations in terms of periods.
An extension of the notion of a cover is the notion of a seed: a cover that is not necessarily
aligned with the ends of the word being covered but is allowed to overflow on either side (see
Figure 1). More formally, a word v is a seed of w if v is a subword of w and w is a subword of some
word u covered by v.
Previous results. Seeds were first introduced and studied by Iliopoulos et al. [33], who gave an
O(n logn)-time algorithm computing a linear representation of all seeds of a given word. For the
next 15 years, no o(n logn)-time algorithm was known for this problem. Smyth [51] formulated
computing all seeds of a word in linear time as an open problem in his survey. Berkman et al. [10]
gave a parallel algorithm computing all seeds in O(logn) time and O(n1+ε ) space (for any positive ε) using n processors in the CRCW PRAM model. Much later, Christou et al. [15] proposed an
alternative sequential O(n logn)-time algorithm for computing the shortest seed.
In contrast, a linear-time algorithm finding the shortest cover of a word was given by Apostolico
et al. [8] and later on improved into an online algorithm by Breslauer [12]. Moore and Smyth [46,
47] proposed a linear-time algorithm computing all covers of a word, whereas Li and Smyth [42]
afterward developed an online algorithm for the problem of representing all covers of all prefixes
of a word.
Both covers and seeds have also been extended in the sense that several subwords are considered
instead of a single subword [35]. This way, the notions of k-covers [16, 32], λ-covers [28], and
λ-seeds [26] were introduced. Notions of approximate quasiperiodicity, including approximate
covers and seeds [4–6, 14, 30, 50], partial covers and seeds [23, 29, 39, 40], and approximate λcovers [27], were also studied.
Another line of research is finding maximal quasiperiodic subwords of a word. This notion resembles maximal repetitions (runs) in a word [41]. Two O(n logn)-time algorithms for reporting
all maximal quasiperiodic subwords of a word of length n have been proposed by Brodal and Pedersen [13] and Iliopoulos and Mouchard [34]; these results improved upon the initial O(n log2 n)-time
algorithm by Apostolico and Ehrenfeucht [7].
Our result. We present a linear-time algorithm computing the set Seeds(w) of all seeds of a given
word w. As illustrated in the following Example 1.1, the number of seeds can be quadratic in the
length |w| (contrary to the number of covers, which is always linear). Consequently, our algorithm
returns a linear-size package representation of the set Seeds(w), which allows finding a shortest
seed and the number of all seeds in a very simple way.
Our procedure assumes that the alphabet Σ of the input word w consists of integers from the
set {0,...,nO(1)
}, where n is the length of the word w.
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.
A Linear-Time Algorithm for Seeds Computation 27:3
Example 1.1. The following word of length 4m + 3 contains Θ(m2) different seeds:
w = ambambambam .
Those seeds are ai
baj with i + j ≥ m and 0 ≤ i, j ≤ m.
Package representation of seeds. We assume that the letters of a word w are numbered from
1 to |w| (i.e., w[1],...,w[|w|]). By w[i . . j], we denote the subword w[i]···w[j]. We introduce
packages that are collections of consecutive prefixes of a subword ofw. More formally, for positive
integers i ≤ j1 ≤ j2 ≤ |w|, we define a package:
pack(i, j1, j2) = {w[i . . j] : j1 ≤ j ≤ j2}.
If L is a set of ordered integer triples, then we denote
PACK(L) =

(i,j1,j2 )∈L
pack(i, j1, j2).
The output of our algorithm, called the package representation of the set Seeds(w), consists of a set
L of ordered integer triples such that Seeds(w) = PACK(L) and all packages in the representation
are pairwise disjoint. (In other words, each seed belongs to exactly one package.)
Let us recall that a suffix trie ofw is the trie of all suffixes ofw and a suffix tree ofw is a compacted
version of the suffix trie, in which nodes with exactly one child become implicit (possibly except
for the root). Every package can be represented as a path in the suffix trie of w, and hence, as a
path in the suffix tree of w that connects two nodes, possibly implicit.
Example 1.2. For a word w = ababaabaab, a package representation of the set Seeds(w) is
L = {(1, 3, 3), (2, 9, 10), (1, 8, 10), (3, 10, 10), (3, 7, 8), (4, 8, 8)}.
It corresponds to the following set PACK(L) of all seeds of w:
ababaaba
babaabaa ababaabaa abaab
aba babaabaab ababaabaab abaabaab abaaba baaba
pack(1, 3, 3) pack(2, 9, 10) pack(1, 8, 10) pack(3, 10, 10) pack(3, 7, 8) pack(4, 8, 8)
This collection of packages is also illustrated in Figure 2 as a set of disjoint paths in the suffix
trie of w.
Previous compact representation of seeds. The original linear-size representation of seeds by
Iliopoulos et al. [33], which was also employed in the preliminary version of our work [37], requires partitioning the set Seeds(w) into two disjoint subsets: Type-A seeds are represented as
paths in the suffix trie of w, whereas (the reversals of) type-B seeds admit a similar representation
in the suffix trie of the reversed word wR. For both types, the number of reported paths is shown
to be linear using a simple argument that each path can be uniquely extended to an edge of the
corresponding suffix tree.
Remark 1. Example 1.2 illustrated in Figure 2 shows that the set of all seeds (rather than just
type-A seeds) does not satisfy this property. Indeed, abaaba and abaabaab are both seeds of w =
ababaabaab that occur in the same edge of the suffix tree, yet they cannot be reported on a single
path because abaabaa is not a seed of w.
The subword complexity of a wordw is a function that gives, for every  = 1,...,n, the number of
different subwords of length . For example, forw = ababaabaab and  = 3, there are four different
length-3 subwords of w (i.e., aab, aba, baa, bab). Subword complexity is a well-studied notion in
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.    
27:4 T. Kociumaka et al.
Fig. 2. The packages from Example 1.2 illustrated as paths (in bold) in the uncompressed suffix trie of w =
ababaabaab.
combinatorics on words (e.g., see Lothaire [43]), and it also has connections with compression [31,
38, 49].
Structure of the article. We start with a preliminary Section 2, where we recall several classic
notions, relate packages to suffix trees, and provide equivalent formal definitions of seeds. Next, in
Section 3, we prove that seeds admit a package representation of linear size. Some of the underlying
arguments are stated in an algorithmic way so that they can be used in the subsequent Section 4 as
subroutines of a procedure efficiently computing seeds of length Θ(n). In Section 5, we provide the
novel relation between seeds and subword complexity, which is the key combinatorial contribution
behind our main recursive algorithm described in Section 6. The implementation of an auxiliary
operation on package representations (applied to merge the results of recursive calls) is deferred to
Section 8. It uses a linear-time offline procedure answering weighted ancestor queries in a weighted
tree, which we develop in Section 7, that is also of independent interest.
Our techniques. Our linear-time solution relies on several combinatorial and algorithmic tools:
—Compact representation of seeds: Despite its quadratic size and the failure of the naive argument (Remark 1), the set Seeds(w) always admits a package representation of linear size
(Section 3). Although this fact is not essential for our algorithm (see [37]), it makes our
results much simpler and cleaner.
—Combinatorial properties of seeds: The connection between seeds and subword complexity
gives an efficient reduction to a set of recursive calls of total size decreased by a constant
factor (see Sections 5 and 6).
—Interpretation of packages as paths on the suffix trie: Packages naturally correspond to paths
in the suffix trie, which can be easily stored using the suffix tree. We use this interpretation
both to derive the combinatorial upper bound on the package representation size (Section 3)
and in the algorithmic construction of the package representation of long seeds (Section 4).
The new linear-time offline algorithm answering weighted ancestor queries (Section 7) lets
us efficiently map packages on the suffix tree.
—Efficient manipulation of package representations: Package representations provide a convenient way of interpreting the results of recursive calls (seeds of certain subwords) as
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.
A Linear-Time Algorithm for Seeds Computation 27:5
families of subwords of the whole word w. This allows for a simple linear-time procedure
aggregating the results of the recursive calls (Section 8).
2 PRELIMINARIES
Let w be a word (a string) over an alphabet Σ ⊆ {0,...,nO(1)
}, where n is the length of the word,
also denoted as |w|. By w[i], for 1 ≤ i ≤ |w|, we denote the ith letter of w. By Alph(w), we denote
the set of letters occurring in w. A word u is a subword (or a substring) of w if u = w[i]···w[j] for
some 1 ≤ i ≤ j ≤ |w|. We then say that u occurs in w at position i, and we denote by Occ(u,w) (or
Occ(u) ifw is clear from the context) the set of positions where u occurs inw. We denote the set of
length- subwords of w by SUB (w). The subword complexity of a word w is a function that gives
the number of subwords of a given length  (i.e., |SUB (w)|). If u is a subword of w, then we also
say that w is a superstring1 of u.
For 1 ≤ i ≤ j ≤ |w|, we denote by w[i . . j] the occurrence of w[i]···w[j] in w at position i. We
callw[i . . j] a fragment ofw; formally, a fragment can be interpreted as a triple (w,i, j) consisting of
the word w and the positionsi, j. We say that two fragments (perhaps in different words) match if
they are occurrences of the same word. The length of the fragmentw[i . . j] is defined as |w[i . . j]| =
j − i + 1. Note that a word w of length n has exactly n −  + 1 length- fragments. However, some
of these fragments may match so that |SUB (w)| < n −  + 1 is possible.
A fragment of w other than the whole word w is called proper. A fragment starting at position
1 is called a prefix of w, and a fragment ending at position |w| is called a suffix of w.
A border of w is a subword of w that occurs both as a prefix and as a suffix of w. An integer
p, 1 ≤ p ≤ n, is a period of a word w if w[i] = w[i + p] for 1 ≤ i ≤ |w| − p. It is well known that
p is a period of w if and only if w has a border of length |w| − p (see [17, 18]). Moreover, the
periodicity lemma of Fine and Wilf [22] asserts that if a word w has periods p and q such that
p + q − gcd(p,q) ≤ |w|, then w also has a period gcd(p,q).
Throughout the article, by w we denote the word whose seeds are to be computed and by n its
length.
2.1 Tries, Suffix Trees, and Package Representations
A trie is a rooted tree whose nodes correspond to prefixes of words in a given (finite) family W . If
ν is a node, then the corresponding prefix v is called the value of the node. The node with value v
is called the locus of v. The parent-child relation in the trie is defined so that the root is the locus
of the empty word, whereas the parent μ of a node ν is the locus of the value of ν with the last
character removed. This character is the label of the edge from μ to ν. In general, if μ is an ancestor
of ν, then the label of the path from μ to ν is the concatenation of edge labels on the path. A trie
of the set W containing all suffixes of a word babaad is shown in Figure 3.
A node is branching if it has at least two children and terminal if its value belongs to W . A
compacted trie is obtained from the underlying trie by dissolving all nodes except for the root,
branching nodes, and terminal nodes. In other words, we compress paths of non-terminal nodes
with single children, and thus the number of remaining nodes becomes bounded by 2|W |. We refer
to all preserved nodes of the trie as explicit (since they are stored explicitly) and to the dissolved
ones as implicit. If ν is the locus of a word v in an uncompacted trie, then the locus of v in the
corresponding compacted trie is defined as (μ,d), where μ is the lowest explicit descendant of
ν, and d is the distance (in the uncompacted trie) from ν to μ. Note that μ = ν and d = 0 if ν is
1Notice that the term superword would be consistent with our notation, but it is not well established, so we decided not to
use it. At the same time, substring complexity is a very rarely used synonym of subword complexity.
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.        
27:6 T. Kociumaka et al.
Fig. 3. The suffix trie of the word babaad. The equivalence classes correspond to compacted edges (excluding their topmost nodes). Two of them are marked in the figure: {ab, aba, abaa, abaad} = pack(2, 3, 6) and
{bab, baba, babaa, babaad} = pack(1, 3, 6).
explicit. Edges of a compacted trie correspond to paths in the underlying trie, and thus their labels
are non-empty words, typically stored as references to fragments of the words in W .
The suffix trie of word w is the trie of all suffixes of w (see Figure 3), with the locus w[i . . n]
labeled by the position i. Consequently, there is a natural bijection between subwords of w and
nodes of the suffix trie; we often use it to identify subwords of w with their loci in the suffix trie.
The suffix tree of w [52] is the compacted suffix trie of w. For a word of length n, it takes O(n)
space and can be constructed in O(n) time either directly [21] or from the suffix array ofw (see [17,
18, 36, 45]).
We say that two subwords u and v ofw are equivalent, which we denote as u ≈ v, if Occ(u,w) =
Occ(v,w). The equivalence classes of this relation correspond to edges of the suffix tree of w, as
shown in the following observation and Figure 3 (see [17]).
Observation 2. Each equivalence class of ≈ is of the form E = pack(i, j1, j2) for some positions
i ≤ j1 ≤ j2 and corresponds to the set of all nodes on an edge of the suffix tree of w (excluding the
topmost explicit node). Hence, there are at most 2|w| equivalence classes.
In Section 8, we heavily use the connections between suffix trees and package representation to
develop the following auxiliary procedure:
Combine (R1,..., Rk ): Given package representations of sets R1,..., Rk of subwords of a word
w, compute a smallest package representation of k
i=1 Ri .
Note that the Combine operation is much more complicated than a simple intersection of sets of
intervals. The following lemma is proved in Section 8.
Lemma 2.1. For a word w of length n and sets R1,..., Rk of subwords of w, given in package
representations of total size N, Combine(R1,..., Rk ) can be implemented in O(n + N) time. The size
of the resulting package representation is at most N.
2.2 Seeds: Formal Definition and Equivalent Characterizations
We say that a fragment w[i . . j] covers a position k (or that the position k lies within w[i . . j]) if
i ≤ k ≤ j. A word v is a cover of word w if the occurrences of v cover all positions in w. A word
v is a seed of word w if it is a subword of w and a cover of a superstring of w. This definition
immediately implies the following observation.
Observation 3. Let v be a seed of word w. If v occurs in a subword w of w, then v is a seed of w
.
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020. 
A Linear-Time Algorithm for Seeds Computation 27:7
We denote by SeedsI (w) the set of all seeds of w with lengths in the interval I. We also
denote Seeds(w) = Seeds[1..n](w), Seeds≤k (w) = Seeds[1..k](w), Seeds≥k (w) = Seeds[k ..n](w),
and Seedsk (w) = Seeds[k ..k](w).
A left-overhang ofv inw is a prefix ofw that matches a proper suffix ofv. Symmetrically, a rightoverhang of v in w is a suffix of w that matches a proper prefix of v. The length of the overhang is
the length of the corresponding prefix/suffix ofw. In this context, usual occurrences are sometimes
called full, whereas a generalized occurrence is a full occurrence or an overhang. A known more
operational definition of seeds can be formulated in terms of generalized occurrences as follows
(e.g., see [39] and Figure 1).
Fact 4 (Alternative definition of seeds). A subword v of word w is a seed of w if and only if
each position in w is covered by a full occurrence, a left-overhang, or a right-overhang of v in w.
Recall that SUBk (w) denotes the set of all length-k subwords of w. Fact 4 lets us show that the
family SUB2−1 (w) of subwords of length 2 − 1 of a word w uniquely determines the length-
seeds of w.
Lemma 2.2. Let v be a non-empty subword of w such that 2|v| − 1 ≤ n. The following conditions
are equivalent:
(1) v is a seed of w;
(2) v is a seed of every subword of w of length 2|v| − 1.
Proof. (1) ⇒ (2). Consider s ∈ SUB2|v |−1 (w) and observe that it occurs as w[i − |v| + 1 . . i +
|v| − 1] for some position i, |v| ≤ i ≤ n − |v| + 1. The position i can only be covered by a full occurrence ofv contained withinw[i − |v| + 1 . . i + |v| − 1], sov is a subword ofs. Due to Observation 3,
v is also a seed of s. Since s can be chosen arbitrarily, v is a seed of every subword of w of length
2|v| − 1.
(2) ⇒ (1). Positions i satisfying |v| ≤ i ≤ n − |v| + 1 are covered by full occurrences of v due
to the fact that v occurs in each subword of w of length 2|v| − 1, including the one occurring as
w[i − |v| + 1 . . i + |v| − 1]. If some position i < |v| or i > n − |v| + 1 in w is not covered by a full
occurrence of v, then it must be covered by a left-overhang of v in w[1 . . 2|v| − 1] or a rightoverhang of v in w[n − 2|v| + 2 . . n], respectively. These overhangs are also present in w.
Corollary 2.3. For each word w and integer k, 1 ≤ k ≤ n+1
2 , we have
Seeds≤k (w) =

u ∈SUB2k−1 (w)
Seeds≤k (u).
Proof. Consider a length  not exceeding k. Note that SUB2−1 (w) = 
s ∈SUB2k−1 (w) SUB2−1 (s),
so Lemma 2.2 yields
Seeds (w) =

u ∈SUB2−1 (w)
Seeds (u) =

s ∈SUB2k−1 (w)

u ∈SUB2−1 (s )
Seeds (u) =

s ∈SUB2k−1 (w)
Seeds (s).
The equality holds for each length  ≤ k, which concludes the proof.
3 REPRESENTATION THEOREM
Let v be a subword of a word w. Let us introduce a decomposition
w = v−vvˆ + (1)
such that vˆ is the longest subword of w having v as a border. In other words,
vˆ = w[min(Occ(v)) . . max(Occ(v)) + |v| − 1]
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.               
27:8 T. Kociumaka et al.
Fig. 4. Generalized occurrences of a seed v of w and the decomposition of w into v−, vˆ, and v+.
Fig. 5. The wordv = ababaa is a quasiseed ofw = aabaababaababaabaa because it coversvˆ = ababaababaa,
whereas the wordv = baab is both a left and a right candidate ofw because it is a seed of bothv−v = aabaab
and vv+ = baabaa. However, neither of them is a seed of w.
(i.e., vˆ can be seen as the shortest fragment of w containing all full occurrences of v in w; see
Figure 4).
Definition 3.1 (See Figure 5). Let us recall the decomposition w = v−vvˆ +. We say that v is a
quasiseed of w if it is a cover of vˆ. If v is a seed of v− v, then v is called a left candidate of w, and
in case v is a seed of v v+, then v is called a right candidate.
By QSeeds(w), LCands(w), and RCands(w), we denote the sets of quasiseeds, left candidates,
and right candidates of w, respectively.
Lemma 3.2. Seeds(w) = LCands(w) ∩ QSeeds(w) ∩ RCands(w).
Proof. We apply the characterization of Fact 4. Observe that there are natural bijections between full occurrences ofv inw and invˆ, between left-overhangs ofv inw and inv−v, and between
right-overhangs of v in w and in vv+.
Next, note that any position of w within vˆ that is covered by an overhang of v must be located
within the leading or trailing |v| characters of vˆ, so it is also covered by a full occurrence of v since
v is a border of vˆ. Thus, v is a quasiseed of w if and only if the positions of w within vˆ are covered
by generalized occurrences of v.
Moreover, observe that v occurs in v−v only as a suffix, so the positions within the leading
v− of v−v and of w can be covered by left-overhangs only. Consequently, v is a left candidate if
and only if the positions within the leading v− of w are covered by generalized occurrences of v.
Symmetrically, v is a right candidate if and only if the positions within the trailing v+ are covered
by generalized occurrences of v.
Combining these three facts, we conclude that v is a seed of w if and only if it is simultaneously
a quasiseed, a left candidate, and a right candidate.
Next, we shall characterize the quasiseeds and candidates in a computationally feasible way and
bound the sizes of their package representations.
3.1 Quasiseeds
For a set X = {x1,..., xk } of integers, x1 < ··· < xk , let us define the value maxgap(X) as
maxgap(X) =

0 if 0 ≤ k ≤ 1,
max{xi+1 − xi : 1 ≤ i < k} if k ≥ 2.
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020. 
A Linear-Time Algorithm for Seeds Computation 27:9
Fig. 6. Uncompressed suffix tree of w = ababaabaab with marked nodes corresponding to quasiseeds. For
example, ab is not a quasiseed, since Occ(ab,w) = {1, 3, 6, 9} and maxgap({1, 3, 6, 9}) = 3; aba is a quasiseed,
since Occ(aba,w) = {1, 3, 6} and maxgap({1, 3, 6}) = 3; and abab is also a quasiseed, since Occ(abab,w) = {1}
and maxgap({1}) = 0 by definition.
For example, maxgap({1, 3, 8, 13, 17}) = 5. There is a known observation that relates this function
to covers (e.g., see [10]). In the following, we state it directly in the context of quasiseeds.
Observation 5. A subword v of word w is a quasiseed of w if and only if maxgap(Occ(v,w)) ≤
|v|.
The set of quasiseeds can be easily represented in the suffix tree (see Figure 6).
Corollary 3.3. For each equivalence class E of ≈, the quasiseeds contained in E form at most one
package. In other words, QSeeds(w) ∩ E has a package representation of size at most 1.
Proof. Consider the shortest subword v ∈ E ∩ QSeeds(w), and let u ∈ E satisfy |u|≥|v|. Due
to Observation 5, maxgap(Occ(u)) = maxgap(Occ(v)) ≤ |v|≤|u|, so u is also a quasiseed. This
completes the proof.
3.2 Left Candidates
The border table B[0 . . n] stores at B[i] the length of the longest proper border (i.e., the longest
proper subword being a border) of w[1 . . i] (we assume B[0] = −1). The following fact was already shown implicitly by Christou et al. [15]; we give its proof for completeness. Let us recall the
decomposition w = v−vvˆ +.
Lemma 3.4. A subword v of word w is a left candidate of w if and only if B[|v−v|] ≥ |v−|.
Proof. Recall that positions within the prefix v− of v−v can only be covered by left-overhangs
of v.
Consequently, if v is a seed of v−v, then there is a prefix of v−v of length at least |v−| equal to
a suffix of v. In other words, there is a proper border of v−v of length at least |v−|.
For a proof of the converse implication, suppose that v−v has a proper border of length at least
|v−|. Sincev has only one occurrence inv−v, the border must be a proper suffix ofv. Consequently,
v has a left-overhang in v−v of length at least |v−|. This fragment covers all positions in v−; the
remaining positions in v−v are trivially covered by the occurrence of v as a suffix of v−v.
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.  
27:10 T. Kociumaka et al.
A classic property of the border table is that 0 ≤ B[i] ≤ B[i − 1] + 1 holds for 1 ≤ i ≤ n. In the
following, we further characterize positions where the right inequality is strict.
Lemma 3.5. If B[i] ≤ B[i − 1] holds for a position i of the word w, then B[i] + B[i − 1] < i − 1.
Proof. We assume B[i] > 0; otherwise, the claim holds trivially: B[i] + B[i − 1] =
B[i − 1] < i − 1. Since w[1 . . i] does not have a border of length B[i − 1] + 1, we must have
w[B[i − 1] + 1]  w[i] = w[B[i]], so B[i − 1] + 1 − B[i] is not a period of w[1 . . i − 1] despite the
fact that both i − B[i] and i − 1 − B[i − 1] are periods of this prefix. By the periodicity lemma, this
yields (i − B[i]) + (i − 1 − B[i − 1]) − 1 > i − 1, so B[i] + B[i − 1] < i − 1 holds as claimed.
Let v be a subword of w, and let v = v
a where a ∈ Σ. We say that v is a critical left candidate of
w if it is a left candidate of w, but
(1) v is not a left candidate of w (in particular, v can be the empty word) or
(2) min(Occ(v
)) < min(Occ(v)).
Let
Active(w) =
j ∈ [1 . . n] : B[j − 1] + 1 = B[j] ≤ j−1
2

.
The following lemma is the main technical contribution in the characterization of left candidates.
Lemma 3.6. A fragment w[i . . j] is
(a) the leftmost occurrence of a left candidate if and only if i − 1 ≤ B[j] ≤ j − i;
(b) the leftmost occurrence of a critical left candidate if and only if i = B[j] + 1 and j ∈
Active(w).
Proof. (a) (⇐). Let us recall the decomposition w = v−vvˆ +. If w[i . . j] is the leftmost occurrence of a left candidate v, then w[1 . . j] = v−v and B[j] ≥ |v−| = i − 1 by Lemma 3.4. Moreover,
B[j] < |v| = j − i + 1, becausew[i − j + B[j] . . B[j]] would otherwise be an earlier occurrence ofv.
These two conditions yield i − 1 ≤ B[j] ≤ j − i.
(⇒). Conversely, assume that
i − 1 ≤ B[j] ≤ j − i. (2)
Suppose for a proof by contradiction that v = w[i . . j] has an earlier occurrence at position
i
—that is, w[i . . i + j − i] = w[i . . j] for some position i < i. Let w = w[i . . j]. The word v is a
border of w
, so w has a period i − i
, which we denote by p1. The shortest period of the whole
prefix w[1 . . j], hence a period of w
, is j − B[j], which we denote by p2. By the first inequality
of (2),
p1 + p2 = i − i
 + j − B[j] ≤ j − i
 + 1 = |w
|.
Hence, p1 and p2 satisfy the assumption of the periodicity lemma and w has period gcd(p1,p2),
which we denote by p. Moreover, by the second inequality of (2),
p1 = i − i
 < i ≤ j − B[j] = p2,
so p < p2. Hence, w[1 . . j] has period p2, whereas its suffix w[i . . j] has period p dividing p2. Consequently, w[1 . . j] has period p,
2 which contradicts the choice of p2 as the shortest period of
w[1 . . j].
Therefore, w[i . . j] indeed is the leftmost occurrence of v and v−v = w[1 . . j]. Due to B[j] ≥
i − 1 = |v−|, we conclude that v is a left candidate by Lemma 3.4.
2One can show by induction that w[k] = w[k + p] for 1 ≤ k ≤ j − p. In the base case of k ≥ i
, this follows from p being
a period of w[i . . j]. For k < i
, on the other hand, we have w[k] = w[k + p2] = w[k + p · p2
p ] = ··· = w[k + p] by the
inductive hypothesis (applied to k + p for 1 ≤  < p2
p ) and since p2 is a period of w[1 . . j] and a multiple of p.
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.      
A Linear-Time Algorithm for Seeds Computation 27:11
(b) (⇒). Let us assume that B[j − 1] + 1 = B[j] ≤ j−1
2 and i = B[j] + 1.
Note that
i − 1 = B[j] = 2B[j] − B[j] ≤ j − 1 − B[j] = j − i.
By part (a),w[i . . j] is therefore the leftmost occurrence of a left candidate. However, B[j − 1] + 1 =
B[j] = i − 1, so w[i . . j − 1] is not the leftmost occurrence of a left candidate. Thus, w[i . . j] is the
leftmost occurrence of a critical left candidate.
(⇐). Let us assume that w[i . . j] is the leftmost occurrence of a critical left candidate. Part (a)
yields i − 1 ≤ B[j] ≤ j − i (since w[i . . j] is the leftmost occurrence of a left candidate) and B[j −
1] < i − 1 or B[j − 1] ≥ j − i (since w[i . . j − 1] is not).
In the latter case, we have B[j − 1] + B[j] ≥ j − i + i − 1 = j − 1, so B[j] = B[j − 1] + 1 holds by
Lemma 3.5. This yields a contradiction:
j − i ≥ B[j] = B[j − 1] + 1 ≥ j − i + 1.
Thus, the only possibility is that B[j − 1] < i − 1, i.e., B[j − 1] ≤ i − 2. We then have
B[j] ≤ B[j − 1] + 1 ≤ i − 1 ≤ B[j],
so B[j − 1] + 1 = B[j] = i − 1. Furthermore,
B[j] = 1
2 (B[j] + B[j]) ≤ 1
2 (j − i + i − 1) = j−1
2
holds as claimed.
For a table A[0 . . n + 1], assuming A[n + 1] = −∞, define the nearest smaller value table NA such
that for 0 ≤ i ≤ n we have NA[i] = min{j > i : A[j] < A[i]}.
Lemma 3.7. Packages pack(B[j] + 1, j, NB[j] − 1) for j ∈ Active(w) form a package representation
of the family of left candidates of w. This representation (of size at most n) can be computed in O(n)
time.
Proof. First, we shall prove that for each j ∈ Active(w), the fragments w[B[j] + 1 . . k] for
j ≤ k ≤ NB[j] − 1 are leftmost occurrences of left candidates. To apply the characterization of
Lemma 3.6(a), we need to show that B[j] ≤ B[k] ≤ k − B[j] − 1. The first inequality follows directly
from the definition of the NB table, whereas for the second one, we observe that B[j] + B[k] ≤
2B[j] + k − j ≤ j − 1 + k − j = k − 1 holds due to B[j] ≤ j−1
2 and the classic property of the border
table.
Consequently, the packages are disjoint and consist of left candidates only.
It remains to prove that we do not leave any left candidate behind. Suppose that w[i . . k] is the
leftmost occurrence of a left candidate. Repeatedly trimming the trailing character, we can reach a
critical left candidate whose leftmost occurrence is w[i . . j] (for j ≤ k). By Lemma 3.6(b), we have
that j ∈ Active(w) and i = B[j] + 1. However, since w[i . . k
] is the leftmost occurrence of a left
candidate for all j ≤ k ≤ k, Lemma 3.6(a) yields B[k
] ≥ i − 1 = B[j] for j ≤ k ≤ k. Consequently,
NB[j] > k. Thus, w[i . . k] ∈ pack(B[j] + 1, j, NB[j] − 1) indeed belongs to one of the packages we
created.
The size of the package representation is |Active(w)| ≤ n. As for the O(n)-time construction
algorithm, we first build the border table B [17, 18, 48] and its nearest smaller value table NB (using
a folklore algorithm; e.g., see [11]). Then, for each position j, we test in constant time whether
j ∈ Active(w), and, if so, we retrieve the corresponding package.
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.  
27:12 T. Kociumaka et al.
3.3 Right Candidates
For wordw, let us define a reverse border array BR[1 . . n] such that BR[i] is the length of the longest
proper border of w[i . . n].
Lemma 3.8. A subword v of a word w is a right candidate of w if and only if BR[n − |vv+| + 1] ≥
|v+|.
Proof. Follows from Lemma 3.4 by the symmetry between B and BR, as well as left and right
candidates.
Even though Lemma 3.8 for right candidates and Lemma 3.4 for left candidates are symmetric, the former allows us to represent right candidates on each edge of the suffix tree of w as a
single package. Thus, a representation for right candidates is much simpler to compute than the
representation for left candidates.
Lemma 3.9. The intersection of RCands(w) with a single equivalence class of ≈ forms at most
one package. Moreover, a package representation (of size at most 2n) of the set RCands(w) can be
computed in O(n) time.
Proof. Let us consider an equivalence class E of the relation ≈, with P = Occ(v) for v ∈ E, and
denote
(E) = n − max(P) + 1 − BR[max(P)].
We will show that v ∈ E is a right candidate if and only if |v| ≥ (E). By Lemma 3.8, v is a right
candidate if and only if BR[n − |vv+| + 1] ≥ |v+|. However, |vv+| = n − max(P) + 1 and |v+| = n −
max(P) + 1 − |v|, so the two conditions are equivalent.
For every equivalence class E that corresponds to an edge of the suffix tree of w, we will show
that RCands(w) ∩ E is either empty or is a single package. We will also show how these intersections can all be computed in O(n) total time.
We construct the array BR [17, 18, 48] and the suffix tree of w. Then we traverse the suffix
tree bottom up and compute max(Occ(v)) for every subword v that corresponds to an explicit
node as the maximum of the values of its explicit children. This lets us compute (E) for the
equivalence class E = pack(i, j1, j2) containing v. We have proved that the right candidates in E
are precisely words in E of length (E) or more. If (E) > |w[i . . j2]|, there are no right candidates
in E. Otherwise, the right candidates form a package
pack(i, max(j1,i + (E) − 1), j2).
3.4 Representation Theorem for Seeds
Theorem 6. For a word w of length n, the set Seeds(w) has a package representation of size at
most 3n.
Proof. By Lemma 3.2, we have Seeds(w) = LCands(w) ∩ QSeeds(w) ∩ RCands(w).
First, we shall prove that the package representation of QSeeds(w) ∩ RCands(w) consists of at
most 2n packages. Indeed, for each equivalence class E of ≈, both QSeeds(w) ∩ E and RCands(w) ∩
E form at most one package. The intersection of two packages forms at most one package, so
QSeeds(w) ∩ RCands(w) has a package representation with at most one package per equivalence
class (i.e., of total size at most 2n).
By Lemma 3.7, LCands(w) has a package representation of size at most n.
Finally, Lemma 2.1 implies that Seeds(w) has a package representation of size at most 3n.
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.         
A Linear-Time Algorithm for Seeds Computation 27:13
Fig. 7. For n = 30, A = {2, 5, 6, 10, 13, 14, 15, 18, 26, 27, 28, 29}, and B = {2, 6, 10, 13, 18, 26, 29}, we have
refine6 (A) = B. From each block of length  = 6 at most two elements are retained—the extreme ones.
4 COMPUTING LONG SEEDS
In this section, we provide a linear-time algorithm computing seeds of length Θ(n). Formally, we
consider the following operation for  = Cn, for some constant C:
LONG-SEEDS(,w): Computes a package representation of Seeds≥ (w).
Let us denote by QSeeds≥ (w) the set of all quasiseeds of w with lengths at least . Our implementation is based on Theorem 6, and it uses the suffix tree of w to determine QSeeds≥ (w).
Let us partition the positions of w into a family F of O(n/) disjoint blocks of length at most
each. For a set of positions X, we define its refined version:
refine (X) =

Y ∈F :Y∩X∅
{min(Y ∩ X), max(Y ∩ X)}
(see Figure 7). Note that |refine (X)| ≤ 2|F | = O(n/) = O(1).
We can now make the following observation.
Observation 7. A subword v of w such that |v| ≥  is a quasiseed if and only if
maxgap(refine (Occ(v))) ≤ |v|.
We traverse the suffix tree ofw bottom up, computing refine (Occ(v)) in constant time for each
subword v whose locus is an explicit node (i.e., a node that is stored explicitly in the suffix tree).
Fact 8. The sets refine (Occ(v)) for all explicit nodes v of the suffix tree can be computed in O(n)
time.
Proof. We compute refine (Occ(v)) for each explicit node v and store it as a sorted list. For
this, we start with an empty set and consider all explicit children u of v. For each child, we merge
the current list with refine (Occ(u)), removing elements that are not extremes in their blocks. This
takes O(|F |) = O(1) time for each edge of the suffix tree, which gives O(n) time in total.
Lemma 4.1 (LONG-SEEDS Implementation). For a threshold  = Θ(n) and a word w of length
n, LONG-SEEDS(,w) can be implemented in O(n) time.
Proof. First, we compute a package representation of the family QSeeds≥ (w) of long quasiseeds. Consider an equivalence class E = pack(i, j1, j2) of the relation ≈. Let P be the common occurrence set Occ(v) for v ∈ E. The longest subword in each package is represented
by an explicit node, so the procedure of Fact 8 computes refine (P). Let us define  :=
max(, maxgap(refine (P))). By Observation 7, a subword v ∈ E is a long quasiseed if and only
if |v| ≥ 
. If j2 − i + 1 < 
, there are no such quasiseeds. Otherwise, we report a package
E ∩ QSeeds≥ (w) = pack(i, max(j1,i +  − 1), j2).
Finally, we apply Lemma 3.2 and compute Seeds≥ (w) = QSeeds≥ (w) ∩ LCands(w) ∩
RCands(w) using Lemma 2.1 to implement the intersection. Linear-size package representations of left candidates and right candidates are constructed using Lemmas 3.7 and 3.9,
respectively. The total running time is O(n).
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.                                   
27:14 T. Kociumaka et al.
Table 1. Subword complexity of w and βk (w)
for w = ababaaba
k 12345678
w[k] ababaaba
|SUBk (w)| 23454321
βk (w) 24688888
We also use the following operation that can be computed using LONG-SEEDS. Let us recall the
notation SeedsI from Section 2.2:
MID-SEEDS(I,w): Computes a package representation of SeedsI (w).
Our implementation of MID-SEEDS(I,w) uses a reduction to Lemmas 4.1 and 2.1, and its running
time is linear provided that I = [..r] is balanced (i.e., if the ratio r
 in bounded by a constant).
In our algorithm, this operation is used only for balanced intervals with r ≤ 8. If the interval
I = [..r] were not balanced, this function could be implemented in O( r
n) time.
Lemma 4.2 (MID-SEEDS Implementation). For an interval I = [..r] and a word w of length n,
MID-SEEDS(I,w) can be implemented in O(n) time if r = O().
Proof. We construct a family R of fragments of length 4r covering w with overlaps of size
2(r − 1) (the last fragment might be shorter). Note that the total length of these fragments is at
most 2n. Furthermore, observe that SUB2r−1 (w) = 
s ∈R SUB2r−1 (s), so Corollary 2.3 yields
Seeds≤r (w) =

u ∈SUB2r−1 (w)
Seeds≤r (u) =

s ∈R

u ∈SUB2r−1 (s )
Seeds≤r (u) =

s ∈R
Seeds≤r (s).
In particular, SeedsI (w) =
s ∈R SeedsI (s). For each s ∈ R, we apply Lemma 4.1 to determine a
package representation of Seeds≥ (s), and we filter out seeds of length greater than r. This takes
O(|s|) time for each s ∈ R, which is O(n) in total. Finally, we combine the package representations
in O(n) time using Lemma 2.1.
5 RELATION AMONG SEEDS, COMPRESSION, AND SUBWORD COMPLEXITY
Recall that subword complexity of a word w maps each length k to the number |SUBk (w)| of
length-k subwords of w. Since |SUBk (w)| is not monotone in general, we define a non-decreasing
sequence (βk )
n
k=1 with
βk (w) = |SUBk (w)| + k − 1
(see Table 1).
Lemma 5.1. The sequence |SUBm (w)| (consequently, also the sequence βm (w)) can be computed in
linear time.
Proof. Each equivalence class E = pack(i, j1, j2) contributes a single subword in SUBm (w) for
eachm ∈ [j1 − i + 1 . . j2 − i + 1]. We obtain at most 2n such intervals; |SUBm (w)| is then the number of intervals that contain the element m. This quantity can be computed in O(n) time using an
auxiliary array A of size n (initially set to zeroes). For an interval [a . . b], A[a] is incremented and
A[b + 1] is decremented. Then |SUBm (w)| = A[1] + ··· + A[m].
A connection between the subword complexity and the existence of seeds of certain lengths is
crucial in this work. More precisely, each seed provides an upper bound on the values βk (w), as
shown in the following Lemma 5.2. This lemma yields a gap in the feasible lengths of seeds of w.
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.           
A Linear-Time Algorithm for Seeds Computation 27:15
Seeds of length 1
6n or more can be determined using the LONG-SEEDS procedure, so it allows us
to focus on computing relatively short seeds.
Lemma 5.2 [Gap Lemma]. If βk (w) > 2
3n for some 1 ≤ k ≤ 1
6n, then w has no seed v whose length
satisfies 2k − 2 ≤ |v| ≤ 1
6n.
Proof. We shall prove that ifv is a seed ofw, then βk (w) ≤ |v| + (k − 1)
n+|v |−2(k−1)
|v | for k ≤ |v|.
Consider length-k fragments starting at positions i,...,i + , where  < |v|. We claim that at
most k − 1 of these fragments are not covered by single occurrences of v. Letw[i . . i + k − 1], for
i ≤ i ≤ i + , be the first such fragment that is not covered by any single occurrence of v. If i does
not exist or i + k − 1 > i + , we are done. Otherwise, the occurrence of v covering position i +
k − 1 must start at some position j, i < j < i + k. Consequently, the length-k fragments starting
at positionsi, j ≤ i ≤ j + |v| − k are all covered by this occurrence of v. We are left with at most
k − 1 remaining length-k fragments (starting at positions i such that i ≤ i < j or j + |v| − k <
i ≤ i + ).
Thus, out of n − k + 1 length-k fragments of w, the number of fragments not covered by single
occurrences of v is at most
(k − 1)

n−k+1
|v |

+ min((n − k + 1) mod |v|, k − 1) ≤ (k − 1) n−k+1
|v | + |v |−(k−1)
|v | (k − 1)
= (k − 1)
n+|v |−2(k−1)
|v | .
As a result, |SUBk (w) \ SUBk (v)| ≤ (k − 1)
n+|v |−2(k−1)
|v | , and we obtain the claimed upper bound
on βk (w):
βk (w) = k − 1 + |SUBk (w)| = k − 1 + |SUBk (v)| + |SUBk (w) \ SUBk (v)|
≤ |v| + (k − 1)
n+|v |−2(k−1)
|v | .
If 2k − 2 ≤ |v| ≤ 1
6n, then, by monotonicity of βk (w) with respect to k, we conclude that
βk (w) ≤ β 1
2 |v |+1 (w) ≤ |v| + |v |
2
n+|v |−|v |
|v | = |v| + 1
2n ≤ 1
6n + 1
2n = 2
3n,
which contradicts the hypothesis of the lemma.
Let us thus focus on computing seeds of length at most 2k − 3. Due to the characterization of
Lemma 2.2, we may ignore some regions of w, as long as we do not miss any subwords of certain
lengths (so that some occurrences of a seed can be missed but not all of them). To formalize this
intuition, we define an operation COMPRk (w), which yields a set S of subwords of w such that
SUBk (w) = 
s ∈S SUBk (s).
Let us take the set of fragments Y that are leftmost occurrences of subwords in SUBk (w). While
there are two fragments in Y covering the same position or containing one of any two consecutive
positions of w each, we remove them from Y and include in Y the minimal fragment containing
both of them. (Formally, while Y contains fragments w[i . . j] and w[i . . j

] such that [i − 1 . . j] ∩
[i − 1 . . j

]  ∅, we remove both fromY and include a fragmentw[min(i,i
) . . max(j, j

)].) Finally,
the subwords indicated by the resulting set of fragments give the family COMPRk (w) (see Figure 8
for an example).
Recall that our motivation is to reduce computing short seeds in w to the analogous operation
on each s ∈ COMPRk (w). This is illustrated by the following result.
Lemma 5.3 [Reduction Lemma]. Consider a wordw of length n. For every integer k, 1 ≤ k ≤ n+1
2 ,
we have
Seeds≤k (w) =

s ∈COMPR2k−1 (w)
Seeds≤k (s).
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.       
27:16 T. Kociumaka et al.
Fig. 8. For a word w = abababacacacacaccbaacbbcbcabad, we have COMPR2 (w) = {w[1 . . 3],w[7 . . 9],
w[16 . . 20],w[22 . . 24],w[29 . . 30]} = {aba, aca, ccbaa, bbc, ad}. And indeed SUB2 (aba) ∪ SUB2 (aca) ∪
SUB2 (ccbaa) ∪ SUB2 (bbc) ∪ SUB2 (ad) = {ab, ba}∪{ac, ca}∪{cc, cb, ba, aa}∪{bb, bc}∪{ad} = SUB2 (w).
Proof. Note that SUB2k−1 (w) = 
s ∈COMPR2k−1 (w) SUB2k−1 (s). Hence, Corollary 2.3 yields
Seeds≤k (w) =

u ∈SUB2k−1 (w)
Seeds≤k (u) =
=

s ∈COMPR2k−1 (w)

u ∈SUB2k−1 (s )
Seeds≤k (u) =

s ∈COMPR2k−1 (w)
Seeds≤k (s).
This concludes the proof.
The values βk (w) can be used to bound the total length of words s ∈ COMPRk (w), denoted
COMPRk (w).
Lemma 5.4 [Compression Lemma]. For each word w and integer k, 1 ≤ k ≤ n+1
2 , we have
COMPRk (w) ≤ β2k−1 (w).
Proof. Let P be the set of positions covered by the leftmost occurrences of subwords from
COMPRk (w). By construction, COMPRk (w) = |P | and i ∈ P if and only if i is included in the
leftmost occurrence of some subword s ∈ SUBk (w). If k ≤ i ≤ n − k + 1, then i is the midpoint
of a length-(2k − 1) fragment w[i − k + 1 . . i + k − 1], which covers all length-k fragments of w
containing position i, including the leftmost occurrence of s ∈ SUBk (w). Thus, w[i − k + 1 . . i +
k − 1] is also the leftmost occurrence of the corresponding subword of length 2k − 1. This yields
an injective mapping from the set of positions i ∈ P ∩ [k . . n − k + 1] to the family SUB2k−1 (w).
The remaining positions (i < k and i > n − k + 1) account for the extra term 2k − 2 = β2k−1 (w) −
|SUB2k−1 (w)| in the upper bound.
From the last two lemmas, we obtain the following corollary that conveys the intuition behind
the main structural theorem in the following section.
Corollary 5.5. Let 1 ≤ k ≤ n+3
4 and S = COMPR2k−1 (w). Then
Seeds≤k (w) =

s ∈S
Seeds≤k (s) and S  ≤ β4k−3 (w).
6 MAIN ALGORITHM
The main algorithm is a recursive procedure based on a structural theorem that combines the
results of the previous section.
Theorem 9 [Decomposition Theorem]. Consider a word w of length n. If n ≤ 6 or |Alph(w)| > 2
3n, then Seeds(w) = Seeds≥ 1
6 n (w). Otherwise, we can compute in linear time a balanced interval I
and a family S of subwords of w such that
(A) Seeds(w) = Seeds≥ 1
6 n (w) ∪ SeedsI (w) ∪

s ∈S
Seeds≤k (s) and (B) S  ≤ 2
3n.
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.  
A Linear-Time Algorithm for Seeds Computation 27:17
Fig. 9. Illustration of Theorem 9 in case 8k ≤  n
6 . There is no seed whose length would be in the forbidden
area. The computation of all seeds is split into recursive computation of short seeds (of length at most k) in
subwords s ∈ S, of seeds with lengths in a balanced interval I, and of long seeds.
Fig. 10. Computation of COMPR2 (w) forw as in Figure 8. The second line contains the array A after the leftmost occurrences of length-2 factors are marked, and the third line shows the final array A that corresponds
to the letters shown in gray.
Proof. We take
k = max
 : 1 ≤  <  n
6  and β4−3 (w) ≤ 2
3n

,
S = COMPR2k−1 (w),
I = [k + 1 . . min(8k,  n
6 ) − 1].
As for the first part of the statement, note that Seeds(w) = Seeds≥ 1
6 n (w) holds trivially if n ≤ 6.
On the other hand, if |Alph(w)| = β1 (w) > 2
3n, then the equality follows directly from the gap
lemma (Lemma 5.2).
Hence, we can assume further that n > 6 and β1 (w) ≤ 2
3n.
Correctness of (B). Now we can guarantee that k is well defined and that it satisfies β4k−3 (w) ≤ 2
3n. Then the compression lemma (Lemma 5.4) implies that S satisfies condition (B).
Correctness of (A). To prove condition (A), we observe that the reduction lemma (Lemma 5.3)
yields Seeds≤k (w) =
s ∈S Seeds≤k (s). Thus, it is enough to prove that
Seeds≥k+1 (w) = Seeds≥ 1
6 n (w) ∪ SeedsI (w)
(i.e., that there is no seed v with 8k ≤ |v| <  n
6 ). This claim holds trivially for k =  n
6  − 1. Otherwise, β4k+1 > 2
3n, and the claim follows directly from the gap lemma (Lemma 5.2).
Computing k and S. By Lemma 5.1, the sequence βm (w) can be computed in linear time. This
allows us to compute k by definition in O(n) time.
Let us show how we compute S = COMPRp (w) for p = 2k − 1. We will iterate over all distinct subwords in SUBk (w) and mark the starting positions of their leftmost occurrences. An auxiliary binary array A[1 . . n] is used, initially set to 0s. We iterate over the equivalence classes
E = pack(i, j1, j2) of ≈—that is, over the edges of the suffix tree of w—in a bottom-up order. For
every such class, we compute the common value x = min(Occ(v)) for v ∈ E (as in the proof of
Lemma 3.9). If an equivalence class E contains a subword of length p (i.e., if p ∈ [j1 − i + 1 . . j2 −
i + 1]), we set A[x] to 1.
Next, for every position x such thatA[x] = 1, we setA[x 
] to 1 for every x  ∈ [x + 1 . . min(y, x +
p − 1)], where y > x is the next 1-position in A or n if no such position exists. See Figure 10 for an
example.
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.      
27:18 T. Kociumaka et al.
ALGORITHM 1: Recursive procedure SEEDS(w)
Input: A word w of length n.
Output: An O(n)-size package representation of Seeds(w).
if n ≤ 6 or |Alph(w)| > 2
3n then return LONG-SEEDS( n
6 ,w)
Let I, S be as in the proof of the decomposition theorem
foreach v ∈ S do
Rv := SEEDS(v)
R := Combine( { Rv : v ∈ S } )
Remove from R seeds of length at least min(I)
return R ∪ LONG-SEEDS( n
6 ,w) ∪ MID-SEEDS(I,w)
(The three package representations contain distinct seeds)
After these two phases, we build a subword w[x . .y] ∈ S out of each maximal interval of 1-
positions [x . .y] in A.
The algorithm computing seeds relies on Theorem 9, with the LONG-SEEDS procedure applied
to compute Seeds≥ 1
6 n (n) and recursive calls made to determine Seeds(s) for each s ∈ S. Finally, a
package representation of SeedsI (w) is computed using MID-SEEDS.
Theorem 10 [Main Result]. An O(n)-size package representation of the set Seeds(w) of all seeds
of a given length-n word w can be found in O(n) time. In particular, a shortest seed and the total
number of seeds can be computed within the same time complexity.
Proof. Correctness of the algorithm SEEDS follows immediately from Theorem 9. To bound
the running time, let us denote by T (n) the maximum number of operations performed by the
SEEDS function executed for a word of length n. Due to Theorem 9 and Lemmas 2.1, 4.2, and 4.1,
T (n) = O(n) +

i
T (ni ), where 
i
ni ≤ 2
3n.
This recurrence yields T (n) = O(n).
7 OFFLINE WEIGHTED ANCESTOR QUERIES
In the weighted ancestor problem, introduced by Farach and Muthukrishnan [20] (also see [25]),
we consider a rooted tree T with an integer weight function weight defined on the nodes. The
weight of the root must be zero, and the weight of any other node must be strictly larger than the
weight of its parent. A classic example is any compacted trie with the weight of a node defined as
the length of its value.
The weighed ancestor queries, given a node ν and an integer value  ≤ weight(ν ), ask for the
highest ancestor μ of ν such that weight(μ) ≥ —that is, such an ancestor μ that weight(μ) ≥
and weight(μ) is the smallest possible. We denote the node μ as ancestor(ν, ).
Weighted ancestor queries in the online setting can be answered in O(log logn) time after O(n)-
time preprocessing [3]. In the special case of the weighted tree being a suffix tree of a word, they
can be answered in O(1) time with a data structure of O(n) space [25]. Nevertheless, no efficient
construction of this data structure is known. In the following, we show that if all queries are given
offline and the weights are polynomially bounded, then q queries can be answered in O(n + q)
time—that is, in time that is linear in the input size.
Our subroutine has already found other applications (e.g., see [1, 2, 9]).
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.      
A Linear-Time Algorithm for Seeds Computation 27:19
Let us first recall the classic union-find data structure. It maintains a partition S of [1 . . n]. Each
set S ∈ S has an identifier id(S) ∈ S. Initially, S is a partition into singletons and id({i}) = i for
1 ≤ i ≤ n.
The union-find data structure supports find(i) queries that, given an integer i ∈ [1 . . n], return
the identifier id(S) of the set S ∈ S containing i. Moreover, a union(i1,i2) operation, given integers
i1,i2 ∈ [1 . . n], replaces the sets S1, S2 ∈ S such that i1 ∈ S1 and i2 ∈ S2 with their union S1 ∪ S2.
Note that union(i1,i2) is void if S1 = S2 (i.e., if find(i1) = find(i2)).
We will only encounter linear union-find instances, in which sets S ∈ S are formed by consecutive integers and id(S) = min(S). In other words, union(i1,i2) is allowed for i1 < i2 only if
find(i1) = find(find(i2) − 1). For such instances, the union-find operations can be implemented
in amortized O(1) time.
Lemma 7.1 [Gabow and Tarjan [24]]. A sequence ofm linear union-find operations on a partition
of [1 . . n] can be implemented in O(n + m) time.
We are now ready to describe an efficient offline procedure answering weighted ancestor
queries.
Lemma 7.2. Given a collection Q of weighted ancestor queries on a weighted treeT on n nodes with
integer weights up to (n + |Q|) O(1)
, all queries from Q can be answered in O(n + |Q|) time.
Proof. We process the tree and the queries according to non-increasing weights. We maintain
a union-find data structure that stores a partition of the set V (T ) of nodes of T . After the nodes
with weight  have been processed, each partition class is either a singleton of a node μ such that
weight(μ) <  or consists of the nodes of a subtree rooted at a node μ such that weight(μ) ≥ . In
either case, μ is the identifier of the set.
Note that to update the partition for the next smaller value of , for each node μ with weight
, it suffices to union the singleton {μ} with the node sets of subtrees rooted at the children
of μ. Moreover, observe that after processing nodes at level , for each node ν, its ancestors μ
with weight(μ) <  form singletons, whereas ancestors μ with weight(μ) ≥  belong to the same
class as ν. Hence, the identifier of this class is the highest ancestor of μ with weight(μ) ≥  (i.e.,
ancestor(ν, ) = find(ν )). Consequently, the weighted ancestor queries can be answered using
Algorithm 2.
Next, we shall prove that Algorithm 2 can be implemented in O(n + |Q|) time. Since node
weights and query weights are integers bounded by (n + |Q|) O(1)
, they can be sorted using radix
sort in O(n + |Q|) time. For union-find operations, we need to identify nodes with integers [1 . . n].
We use the pre-order identifiers, as they guarantee that each partition class (which can be either
a singleton or the node set of a subtree rooted at a given node) consists of consecutive integers.
With n − 1 union operations and |Q| find operations, Lemma 7.1 guarantees O(n + |Q|) overall
running time of the union-find data structure.
8 IMPLEMENTATION OF THE OPERATION COMBINE
We describe here the missing part of the algorithm, which is based on computations on weighted
trees. We first apply offline weighted ancestor queries to the suffix tree to obtain the following
algorithmic tool.
Corollary 8.1. Given a collection of subwordss1,...,sk of a wordw of length n, each represented
by an occurrence in w, in O(n + k) total time we can compute the locus of each subword si in the
suffix tree of w. Moreover, these loci can be made explicit in O(n + k) extra time.
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.           
27:20 T. Kociumaka et al.
ALGORITHM 2: Offline weighted ancestors for a weighted tree T and a set of queries Q
WT = {weight(μ) : μ ∈ V (T )};
WQ = { : (ν, ) ∈ Q};
foreach  ∈ WT ∪WQ in the decreasing order do
foreach μ ∈ V (T ) : weight(μ) =  do
foreach ν : child of μ in the left-to-right order do
union(μ, ν );
foreach ν : (ν, ) ∈ Q do
Report ancestor(ν, ) := find(ν );
Fig. 11. The PATHST (P1, P2) operation: three copies of the same rooted tree T . The first two show P1 and
P2, and the third one shows PATHST (P1, P2).
Proof. Let T be the suffix tree of w. Assume that si = w[a . . b] and consider the following
nodes: the node μ representing w[a . . n] (the terminal node of T annotated with a) and ν =
ancestor(μ,b − a + 1). If we denote by d the depth of ν, then the locus of si is (ν,d − (b − a + 1)).
By Lemma 7.2, the loci of si can be computed in O(n + k) time.
To make the corresponding implicit nodes explicit, we need to group them according to the
nearest explicit descendant and sort them by distances from that node. This can be implemented
in O(n + k) time via radix sort. Then we simply create the explicit nodes in the obtained order.
Let us introduce one more abstract operation on a rooted tree T . A path family is a family of
pairwise disjoint paths in T , each leading downward. A path family is called minimal if there is no
other path family covering the same set of nodes in T and consisting of a smaller number of paths.
Let P1,..., Pm be path families in T . Then by PATHST (P1,..., Pm ), we denote a minimal path
family representing the nodes covered by all families P1,..., Pm (see Figure 11).
Lemma 8.2. The family PATHST (P1,..., Pm ) can be computed in linear time with respect to the
size of the tree T , the number m, and total number of paths in all families Pi .
Proof. For each node μ in T , we would like to compute a value, denoted S[μ], that is equal to
the number of paths in all families Pi that contain node μ. Observe that a node μ is covered by all
families Pi if and only if S[μ] = m.
For each node ν in T , we will store a counter C[ν] so that, for a node μ, S[μ] is equal to the sum
of values C[ν] across the nodes ν in the subtree of μ. The counters C are initially set to zeroes.
For each path leading from μ down to ν in Pi , we increment the counter C at ν and decrement the
counter at the parent of μ (unless μ is the root). Next, for each node μ, we compute S[μ] as the sum
of values C[ν] across the nodes ν in the subtree of μ. This is done in a bottom-up fashion using the
S[·] values of the children of μ.
This way, we compute all nodes represented by PATHST (P1,..., Pm ). Finally, to find the minimal
path family covering all of these nodes, we repeat the following process traversing the tree in a
bottom-up order: If the value S[μ] is m, we create a single-node path {μ}. If also S[ν] = m for a
ACM Transactions on Algorithms, Vol. 16, No. 2, Article 27. Publication date: April 2020.       
A Linear-Time Algorithm for Seeds Computation 27:21
child ν of μ, we merge the paths containing these two nodes. (We choose the child arbitrarily if
S[ν] = m for several children.)
We are now ready to provide an efficient implementation of the Combine operation.
Lemma 8.3. For a word w of length n and sets R1,..., Rk of subwords of w, given in package
representations of total size N, Combine(R1,..., Rk ) can be implemented in O(n + N) time. The size
of the resulting package representation is at most N.
Proof. We reduce the problem to computing PATHST (P1,..., Pm ) for certain path families
P1,..., Pm.
We first apply Corollary 8.1 for subwordsw[i . . j1] andw[i . . j2] across all packages pack(i, j1, j2)
in R1,..., Rm, extending the set of explicit nodes of the suffix tree T of w by the obtained loci. For
each package, we create a path connecting the corresponding two loci. The packages in a package
representation are disjoint, so for each Ri this process results in a path family. We apply Lemma 8.2
to compute a minimal path family P = PATHST (P1,..., Pm ).
Finally, for each path in P, we create a package in T . We assume that each node stores the label
 of any terminal node in its subtree. If a path in P connects two nodes at depths d1 ≤ d2, and the
second one stores the label , then we create a package pack(,  + d1 − 1,  + d2 − 1).
9 CONCLUSION
We presented a linear-time algorithm that computes a representation of all seeds in a word. The
representation that we proposed is simpler than the previous ones, as it uses only the suffix tree
of the word and not the suffix tree of its reversal. Our algorithm is considerably simpler than
the one presented in the preliminary version of the article [37]. A recent preprint [19] provides
implementations of the O(n logn)-time algorithm by Iliopoulos et al. [33], of our algorithm, and
of an O(n logn)-time version of our algorithm that applies an approach using a balanced binary
tree instead of the recursive procedure. An experimental evaluation of the three algorithms presented by Czaka and Radoszewski [19] suggests that the O(n logn)-time version of our algorithm
is superiorly in practice.       