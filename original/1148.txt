Abstract
In the Directed Disjoint Paths problem, we are given a digraph D and a set of requests , and the task is to find a collection of pairwise vertex-disjoint paths  such that each  is a path from  to  in D. This problem is NP-complete for fixed  and W[1]-hard with parameter k in DAGs. A few positive results are known under restrictions on the input digraph, such as being planar or having bounded directed tree-width, or under relaxations of the problem, such as allowing for vertex congestion. Positive results are scarce, however, for general digraphs. In this article we propose a novel global congestion metric for the problem: we only require the paths to be “disjoint enough”, in the sense that they must behave properly not in the whole graph, but in an unspecified part of size prescribed by a parameter. Namely, in the Disjoint Enough Directed Paths problem, given an n-vertex digraph D, a set of k requests, and non-negative integers d and s, the task is to find a collection of paths connecting the requests such that at least d vertices of D occur in at most s paths of the collection. We study the parameterized complexity of this problem for a number of choices of the parameter, including the directed tree-width of D. Among other results, we show that the problem is W[1]-hard in DAGs with parameter d and, on the positive side, we give an algorithm in time  and a kernel of size  in general digraphs. This latter result has consequences for the Steiner Network problem: we show that it is FPT parameterized by the number k of terminals and p, where  and q is the size of the solution.


Keywords
Parameterized complexity
Directed disjoint paths
Congestion
Dual parameterization
Kernelization
Directed tree-widths

1. Introduction
In the Disjoint Paths problem, we are given a graph G and a set of pairs of vertices 
, the requests, and the task is to find a collection of pairwise vertex-disjoint paths 
 such that each 
 is a path from 
 to 
 in G. Since this problem is NP-complete in the directed and undirected cases, even if the input graph is planar [19], [26], algorithmic approaches usually involve approximations, parameterizations, and relaxations. In this article, we focus on the latter two approaches and the directed case.

Previous work. For the undirected case, Robertson and Seymour [32] showed, in their seminal work on graph minors, that Disjoint Paths can be solved in time 
 for some computable function f, where n is the number of vertices of G; that is, the problem is fixed-parameter tractable (FPT) when parameterized by the number of requests.

The directed case, henceforth referred to as the Directed Disjoint Paths (DDP) problem, turns out to be significantly harder: Fortune et al. [19] showed that the problem is NP-complete even for fixed . In order to obtain positive results, a common approach has been to consider restricted input digraphs. For instance, it is also shown in [19] that DDP is solvable in time 
 if the input digraph is acyclic. In other words, DDP is XP in DAGs with parameter k. For some time the question of whether this could be improved to an FPT algorithm remained open, but a negative answer was given by Slivkins [34]: DDP is W[1]-hard in DAGs with parameter k. Johnson et al. introduced in [21] the notion of directed tree-width, as a measure of the distance of a digraph to being a DAG, and provided generic conditions that, if satisfied by a given problem, yield an XP algorithm on graphs of bounded directed tree-width. In particular, they gave an 
 algorithm for DDP on digraphs with directed tree-width at most w. Another restriction considered in the literature is to ask for the underlying graph of the input digraph to be planar. Under this restriction, Schrijver [33] provided an XP algorithm for DDP with parameter k, which was improved a long time afterwards to an FPT algorithm by Cygan et al. [13].

A natural relaxation for the Directed Disjoint Paths problem is to allow for vertex and/or edge congestion. Namely, in the Directed Disjoint Paths with Congestion problem (DDPC for short, or DDPC-c if we want to specify the value of the congestion), the task is to find a collection of paths satisfying the k requests such that no vertex in the graph occurs in more than c paths of the collection. Amiri et al. [2] considered the tractability of this problem when restricted to DAGs. By a simple local reduction to the disjoint version, they showed how to apply the algorithm by Fortune et al. [19] to solve DDPC in time 
, and proved that, for every fixed , not only DDPC is W[1]-hard with relation to the parameter k, but also that the exponent  of n is the best possible under the Exponential Time Hypothesis. Together with the result by Johnson et al. [21], this simple reduction presented in [2] is sufficient to show that DDPC-c admits an XP algorithm with parameters k and w for every fixed  in digraphs with directed tree-width at most w, and the same result also holds when we allow for congestion on the edges. In the main algorithmic result of the article, Amiri et al. [2] proved that DDPC-c admits an XP algorithm with parameter d in DAGs, where .

Motivated by Thomassen's proof [35] that DDP remains NP-complete for  when restricted to β-strongly connected digraphs, for any integer , Edwards et al. [17] recently considered the DDPC-2 problem (this version of the problem is usually called half-integral in the literature) and proved, among other results, that it can be solved in time 
 when restricted to 
-strongly connected digraphs.

Kawarabayashi et al. [23] considered the following asymmetric version of the DDPC-4 problem: the task is to either find a set of paths satisfying the requests with congestion at most four, or to conclude that no set of pairwise vertex-disjoint paths satisfying the requests exists. In other words, we ask for a solution for DDPC-4 or a certificate that there is no solution for DDP. They proved that this problem admits an XP algorithm with parameter k in general digraphs, and claimed –without a proof– that Slivkins' reduction [34] can be modified to show that it is W[1]-hard in DAGs. In their celebrated proof of the Directed Grid Theorem, Kawarabayashi and Kreutzer [24] claimed that an XP algorithm can be obtained for the asymmetric version with congestion at most three. To the best of our knowledge, the existence of an XP algorithm in general digraphs for the DDPC-2 problem, or even for its asymmetric version, remains open.

Summarizing, the existing positive results in the literature for parameterizations and/or relaxations of the Directed Disjoint Paths problem in general digraphs are quite scarce.

Our approach, results, and techniques. In this article, we propose another congestion metric for DDP. In contrast to the usual relaxations discussed above, which focus on a local congestion metric that applies to every vertex, our approach considers, on top of local congestion, a global congestion metric: we want to keep control of how many vertices (a global metric) appear in “too many” paths (a local metric) of the solution. That is, we want the paths to be such that “most” vertices of the graph do not occur in too many paths, while allowing for any congestion in the remaining vertices. In the particular case where we do not allow for local congestion, we want the paths to be pairwise vertex-disjoint not in the whole graph, but in an unspecified part of size prescribed by a parameter; this is why we call such paths “disjoint enough”.

Formally, in the Disjoint Enough Directed Paths (DEDP) problem, we are given a set of requests 
 in a digraph D and two non-negative integers c and s, and the task is to find a collection of paths 
 such that each 
 is a path from 
 to 
 in D and at most c vertices of D occur in more than s paths of the collection. If , for instance, we ask for the paths to be pairwise vertex-disjoint in at least  vertices of the graph, and allow for at most c vertices occurring in two or more paths. Choosing  and , DEDP is exactly the DDP problem and, choosing , DEDP is exactly the Steiner Network problem (see [18] for its definition).

Applying simple reductions from DDP and DDPC, we show that DEDP is NP-complete for fixed  and , and W[1]-hard in DAGs with parameter k, respectively, even if c is large with respect to n in both cases. Namely, if c is at most 
 for some real value . By applying the framework of Johnson et al. [21], we give an 
 algorithm to solve DEDP in digraphs with directed tree-width at most w.

The fact that DEDP is NP-complete for fixed values of , , and  [19] motivates us to consider the “dual” parameter . That is, instead of bounding from above the number of vertices of D that lie in the intersection of many paths of a collection satisfying the given requests, we want to bound from below the number of vertices that occur only in few paths of the collection. Formally, we want to find  with  such that there is a collection of paths  satisfying the given requests such that every vertex in X is in at most s paths of the collection. We first prove, from a reduction from the Independent Set problem, that DEDP is W[1]-hard with parameter d for every fixed , even if the input graph is a DAG and all source vertices of the request set are the same.

Our main contribution consists of positive algorithmic results for this dual parameterization. On the one hand, we give an algorithm for DEDP running in time 
. This algorithm is not complicated, and basically performs a brute-force search over all vertex sets of size d, followed by k connectivity tests in a digraph 
 obtained from D by an appropriate local modification. On the other hand, our most technically involved result is a kernel for DEDP with at most 
  non-terminal vertices. This algorithm first starts by a reduction rule that eliminates what we call congested vertices; we say that the resulting instance is clean. We then show that if D is clean and sufficiently large, and , then the instance is positive and a solution can be found in polynomial time. This fact is used as the base case of an iterative algorithm. Namely, we start with the original instance and proceed through  iterations. At each iteration, we choose one path from some 
 to its destination 
 such that a large part of the graph remains unused by any of the pairs chosen so far (we prove that such a request always exists) and consider only the remaining requests for the next iteration. We repeat this procedure until we arrive at an instance where the number of requests is exactly , and use the base case to output a solution for it. From this solution, we extract in polynomial time a solution for the original instance, yielding a kernel of the claimed size.

Since positive results for the Directed Disjoint Paths problem are not common in the literature, especially in general digraphs, we consider our algorithmic results to be of particular interest. Furthermore, the kernelization algorithm also brings good news for the Steiner Network problem: when  Feldmann and Marx in [18] showed that the tractability of the Steiner Network problem when parameterized by the number of requests depends on how the requests are structured. Our result adds to the latter by showing that the problem remains FPT if we drop this structural condition on the request set but add d, the number of vertices occurring in at most s paths of the solution, as a parameter. More details can be found in Section 2.

Table 1 shows a summary of our algorithmic and complexity results, which altogether provide an accurate picture of the parameterized complexity of the DEDP problem for distinct choices of the parameters.


Table 1. Summary of hardness and algorithmic results for distinct choices of the parameters. A horizontal line in a cell means no restrictions for that case, and here we denote by w the directed tree-width of the input digraph. In all cases, we have that c = n − d.

k	d	s	w	Complexity
fixed ≥3	Ω(nα)	fixed =1	—	NP-complete (Theorem 3)
parameter	Ω(nα)	fixed ≥1	0	W[1]-hard (Theorem 3)
input	parameter	fixed ≥0	—	W[1]-hard (Theorem 4)
parameter	—	—	parameter	XP (Theorem 16)
input	parameter	parameter	—	XP (Theorem 18)
parameter	parameter	parameter	—	FPT (Theorem 27)
Organization. In Section 2 we present some preliminaries relevant to all parts of this article and formally define the Disjoint Enough Directed Paths problem. We provide the hardness results in Section 3 and the algorithms in Section 4. The corresponding notations and definitions related to directed tree-width are presented in Section 4.1, where they are used. We conclude the article in Section 5 with some open questions for further research.

2. Preliminaries and definitions
For a graph , directed or not, and a set , we write  for the graph resulting from the deletion of X from G and  for the graph induced by X. We also write 
 to say that 
 is a subgraph of G. If e is an edge of a directed or undirected graph with endpoints u and v, we may refer to e as . If e is an edge of a digraph, we say that e has tail u, head v and is oriented from u to v.

The in-degree 
 (resp. out-degree 
 of a vertex v in a digraph D is the number of edges with head (resp. tail) v. The degree 
 of v in D is the sum of 
 with 
. The in-neighborhood 
 of v is the set , and the out-neighborhood 
 is the set . We say that u is an in-neighbor of v if 
 and that u is an out-neighbor of v if 
.

A walk in a digraph D is an alternating sequence W of vertices and edges that starts and ends with a vertex, and such that for every edge  in the walk, vertex u (resp. vertex v) is the element right before (resp. right after) edge  in W. A walk is a path if all the vertices in it are distinct. All paths mentioned henceforth, unless stated otherwise, are considered to be directed.

An orientation of an undirected graph G is a digraph D obtained from G by choosing an orientation for each edge . The undirected graph G formed by ignoring the orientation of the edges of a digraph D is the underlying graph of D.

A digraph D is strongly connected if, for every pair of vertices , there is a walk from u to v and a walk from v to u in D. We say that D is weakly connected if the underlying graph of D is connected. A separator of D is a set  such that  is not strongly connected. If  and k is the minimum size of a separator of D, we say that D is k-strongly connected. A strong component of D is a maximal induced subdigraph of D that is strongly connected, and a weak component of D is a maximal induced subdigraph of D that is weakly connected.

Unless stated otherwise, n will always denote the number of vertices of the input graph. For an integer , we denote by  the set . We make use of Menger's Theorem [27] for digraphs. Here a -separator is a set of vertices X such that there is no path from u to v in .

Theorem 1 Menger's Theorem

Let D be a digraph and  such that . Then the minimum size of a -separator equals the maximum number of pairwise internally vertex-disjoint paths from u to v.

2.1. Parameterized complexity
We refer the reader to [12], [15] for basic background on parameterized complexity, and we recall here only some basic definitions. A parameterized problem is a language 
⁎
. For an instance 
⁎
, k is called the parameter.

A parameterized problem is fixed-parameter tractable (FPT) if there exists an algorithm , a computable function f, and a constant c such that given an instance ,  (called an FPT algorithm) correctly decides whether  in time bounded by 
. For instance, the Vertex Cover problem parameterized by the size of the solution is FPT.

A parameterized problem is XP if there exists an algorithm  and two computable functions f and g such that given an instance ,  (called an XP algorithm) correctly decides whether  in time bounded by 
. For instance, the Clique problem parameterized by the size of the solution is in XP.

Within parameterized problems, the W-hierarchy may be seen as the parameterized equivalent to the class NP of classical decision problems. Without entering into details (see [12], [15] for the formal definitions), a parameterized problem being W[1]-hard can be seen as a strong evidence that this problem is not FPT. The canonical example of W[1]-hard problem is Clique parameterized by the size of the solution.

For an instance  of a parameterized problem Q, a kernelization algorithm is an algorithm  that, in polynomial time, generates from  an equivalent instance 
 of Q such that 
, for some computable function . If  is bounded from above by a polynomial of the parameter, we say that Q admits a polynomial kernel.

A polynomial time and parameter reduction is an algorithm that, given an instance  of a parameterized problem A, runs in time 
 and outputs an instance 
 of a parameterized problem B such that 
 is bounded from above by a polynomial on k and  is positive if and only if 
 is positive.

2.2. The Disjoint Enough Directed Paths problem
Before defining the problem, we define requests and satisfying collections.

Definition 2 Requests and satisfying collections

Let D be a digraph and  be a collection of paths of D. A request in D is an ordered pair of vertices of D. For a request (multi)set 
, we say that the vertices 
 are source vertices and that 
 are target vertices, and we refer to them as  and , respectively. We say that  satisfies I if 
 and 
 is a path from 
 to 
, for .

We remark that a request multiset may contain many copies of the same pair, and that when considering the union of two or more of those multisets, we keep all such copies in the resulting request multiset. For instance, if 
 and 
 then 
, and this indicates that a collection of paths satisfying this request set must contain two paths from 
 to 
. To simplify the notation, we simply refer to request multisets as request sets. The DEDP problem is defined as follows.


Download : Download high-res image (62KB)
Download : Download full-size image
Unless stated otherwise, we consider  for the remaining of this article. Intuitively, c imposes an upper bound on the size of the “congested” part of the solution, while d imposes a lower bound on the size of the “disjoint” part. For a parameterized version of DEDP, we sometimes include the parameters before the name. For instance, we denote by -DEDP the Disjoint Enough Directed Paths problem with parameters k and d. We refer to instances of DEDP as .
Notice that if  or , the problem is trivial since every vertex of the graph is allowed to be in all paths of a collection satisfying the requests, and thus we only need to check for connectivity between the given pairs of vertices. Furthermore, if there is a pair 
 in the request set such that there is no path from 
 to 
 in the input digraph D, the instance is negative. Thus we henceforth assume that , that , and that there is a path from 
 to 
 in D for every pair 
 in the set of requests.

Choosing the values of , and s appropriately, we show in Table 2 that the DEDP problem generalizes some problems in the literature.


Table 2. Summary of related problems.

Parameters	Equivalent to	Complexity
d = n, s = 1	Directed Disjoint Paths	NP-complete for k = 2 [19]
d = n, s ≥ 1	Directed Disjoint Paths with Congestion s	W[1]-hard with parameter k [2], [34]
d ≥ 1, s = 0	Steiner Network	FPT with parameters k and d
The last line of Table 2 is of particular interest, and we focus on it in the next two paragraphs. In the Steiner Network problem, we are given a digraph D and a request set R and we are asked to find an induced subgraph 
 of D with minimum number of vertices such that 
 admits a collection of paths satisfying R. For a request set R in a digraph D, let  be the digraph with vertex set  and edge set . The complexity landscape of the Steiner Network problem when parameterized by the size of the request set was given by Feldmann and Marx [18]. They showed that the tractability of the problem depends on . Namely, they proved that if  is close to being a caterpillar, then the Steiner network problem is FPT when parameterized by , and W[1]-hard otherwise. When parameterized by the size of the solution, Jones et al. [22] showed that the Steiner Network problem is FPT when  is a star whose edges are all oriented from the unique source and the underlying graph of the input digraph excludes a topological minor, and W[2]-hard on graphs of degeneracy two [22].

Our algorithmic results for DEDP for the particular case  yield an FPT algorithm for another parameterized variant of the Steiner Network problem. In this case, we want to decide whether D admits a large set of vertices whose removal does not disconnect any pair of requests. That is, we want to find a set  with  such that  contains a collection of paths satisfying R. In Theorem 27 we give an FPT algorithm (in fact, a kernel) for this problem with parameters  and d. We remark that this tractability does not depend on .

3. Hardness results for DEDP
In this section we provide hardness results for the DEDP problem. Namely, we first provide in Theorem 3 a simple reduction from Disjoint Paths with Congestion, implying NP-completeness for fixed values of  when  and W[1]-hardness in DAGs with parameter k when  and . We then prove in Theorem 4 that DEDP is W[1]-hard in DAGs with parameter d.

As mentioned in [22], the Steiner Network problem is W[2]-hard when parameterized by the size of the solution (as a consequence of the results of [28]). Hence (c)-DEDP is W[2]-hard for fixed . As discussed in the introduction, the Directed Disjoint Paths problem is NP-complete for fixed  [19] and W[1]-hard with parameter k in DAGs [34]. In addition, Directed Disjoint Paths with Congestion parameterized by the number of requests is also W[1]-hard in DAGs for every fixed congestion , as observed in [2]. When  and , DEDP is equivalent to the Directed Disjoint Paths with Congestion problem and thus the aforementioned bounds apply to it as well. In the following theorem we complete this picture by showing that DEDP is NP-complete for fixed  and , even if c is quite large with respect to n (note that if  all instances are trivially positive), namely for c as large as 
 with α being any fixed real number such that . The same reduction also allows to prove W[1]-hardness in DAGs with parameter k. The idea is, given the instance of DDPC with input digraph D, build an instance of DEDP where the “disjoint” part corresponds to the original instance, and the “congested” part consists of c new vertices that are necessarily used by  paths of any solution. In this process, we generate an instance of DEDP in a digraph 
 with 
 and . This is why we restrict the value of d to be of the form 
, but not smaller: if we ask d to be “too small”, for example , our procedure would generate an instance of DEDP such that the size of the “disjoint part” d satisfies  which in turn implies that the size of this instance would be exponential on the size of the original instance of DDPC.

Following, we refer to instances of DDPC with input graph D, request set R, , and congestion s as . We remind the reader that we can assume that , since otherwise the problem reduces to a simple connectivity check between every pair of vertices in the request set.

Theorem 3

Let ,  with 
, and . Then, for  and ,

(i)
DEDP is -complete for every fixed  and ; and

(ii)
(k)-DEDP is -hard in DAGs for every fixed .

Proof

We prove items (i) and (ii) at the same time by a simple reduction from the Directed Disjoint Paths with Congestion (DDPC) problem. Given an instance  of DDPC, we output an equivalent instance 
 of DEDP that does not generate any new cycles and such that the size 
 of the disjoint part of the new instance is equal to , with  as in the statement of the theorem. Since DDP, which is exactly the DDPC problem with congestion , is NP-complete for fixed  [19] and k-DDPC is W[1]-hard in DAGs [2], our reduction implies that DEDP with  is NP-complete for every fixed  and , and W[1]-hard in DAGs with parameter k and any fixed . We can assume that  since DEDP is exactly DDPC when  and  (as discussed previously).

Formally, let  be an instance of DDPC with 
 and choose  arbitrarily. We construct an instance of DEDP as follows. Let 
 be a digraph constructed by adding to D a path with vertex set 
 and an edge from 
 to 
. Then, add to 
 all pairs in 
, the pair 
, and s copies of the pair 
. Fig. 1 illustrates this construction. It is easy to verify that  is positive if and only if the instance 
 of DEDP is positive since every solution to the second contains  copies of the path from 
 to 
 (one being to satisfy the pair 
), every vertex in  can occur in at most s paths of any solution.

Fig. 1
Download : Download high-res image (29KB)
Download : Download full-size image
Fig. 1. Example of the construction from Theorem 3 with k = 2, s = 1, and i = 2. Source and target vertices are represented by square vertices in the figure.

Since 
 is formed by adding a path on c vertices to a copy of D, it is constructed in time . Choosing c to satisfy 
, the hypothesis that 
 easily implies that 
 which in turn implies that the procedure ends in polynomial time. ◂

In Theorem 3 we only prove NP-completeness for  since, as we discuss in Section 5, it is not known if DDPC is NP-complete for some fixed k when the congestion is at least two. Nevertheless, a positive answer to this question would also imply the NP-completeness of DEDP for some fixed k and fixed  as the reduction used in the proof of Theorem 3 implies that DEDP is as hard as DDPC. Dealing with the local congestion metric s, however, is not the main objective of this article, which is to focus on the global congestion metric c and its dual .

Next, we show that (d)-DEDP is W[1]-hard, even when the input graph is acyclic and all source vertices of the request set are the same. The reduction is from the Independent Set problem parameterized by the size of the solution, which is W[1]-hard [12], [15].

Theorem 4

The DEDP problem is -hard with parameter d for every fixed , even when the input graph is acyclic and all source vertices in the request set are the same.

Proof

Let  be an instance of the Independent Set problem, in which we want to decide whether the (undirected) graph G contains an independent set of size at least d, and s be a non-negative integer. Let 
 be the set 
 and D a directed graph with vertex set 
. Add to D the following edges:

•
for every , add the edge ; and

•
for every edge  with endpoints u and w, add the edges 
 and 
.

Finally, for every 
, add  copies of the pair 
 to R. Fig. 2 illustrates this construction.
Fig. 2
Download : Download high-res image (10KB)
Download : Download full-size image
Fig. 2. Example of the construction from Theorem 4 with s = 1 and e = (u,w). A dashed line indicates a request in R.

Notice that each vertex 
 of D associated with an edge E of D has out-degree zero in D and r has in-degree zero. Moreover, every edge of D has as extremity either r or a vertex of the form 
. Thus D is a acyclic, as desired. Furthermore  since all of its elements are of the form 
, for . We now show that  is positive if and only if  is positive, where .

For the necessity, let X be an independent set of size d in G. Start with a collection . We classify the edges of G into two sets: the set 
 containing all edges with both endpoints in , and the set 
 containing all edges with exactly one endpoint in X. Now, for each 
, choose arbitrarily one endpoint u of e and add to   copies of the path in D from r to 
 using u. For each 
 with  and , add to   copies of the path in D from r to 
 using w. Since X is an independent set, no vertex in X occurs in any path of , and since 
,  satisfies R and the necessity follows as .

Let  be a solution for  and  be a set of vertices with  and such that each vertex of X occurs in at most s paths of . Such choice is possible since . For contradiction, assume that X is not an independent set in G. Then there is an edge  with  and , and  copies of the request 
 in R. Thus each path satisfying one of those requests uses u or w, but not both, and therefore either u or w occurs in at least  paths of , a contradiction. We conclude that X is an independent set in G and the sufficiency follows. ◂

4. Algorithms for DEDP
In this section we focus on algorithmic results for DEDP. In Theorem 3 we showed that DEDP is NP-complete for every fixed  and a large range of values of c, and showed that considering only d as a parameter is still not enough to improve the tractability of the problem: Theorem 4 states that (d)-DEDP is W[1]-hard in DAGs even if all requests share the same source. Thus DEDP is as hard as the Directed Disjoint Paths problem when k is not a parameter. Here we show that, similarly to the latter, DEDP admits an XP algorithm when parameterized by the number of requests and the directed tree-width of the input digraph. Then, we show how the tractability of DEDP improves when we consider stronger parameterizations including d. Namely, we show that DEDP is XP with parameters d and s (cf. Theorem 18), and FPT with parameters k and d (hence s as well, since we may assume that  as discussed in Section 2.2; cf. Theorem 27). It is worth mentioning that this kind of dual parameterization (remember that ) has proved useful in order to improve the tractability of several notoriously hard problems (cf. for instance [2], [3], [5], [9], [16]).

In Section 4.1 we formally define directed tree-width and arboreal decompositions, as provided by Johnson et al. [21], and apply the ideas and results they used to show an XP algorithm for the Directed Disjoint Paths problem parameterized by the number of requests in digraphs of bounded directed tree-width to show that a similar result holds for DEDP. In Section 4.2 we show our algorithms for parameterizations of DEDP including d as a parameter.

4.1. An  algorithm with parameters k and 
Given the success obtained in the design of efficient algorithms in undirected graphs of bounded tree-width (cf. [10], [11], for example), and the enormous success achieved by the Grid Theorem [31] and by the Bidimensionality framework [14], it is no surprise that there was interest in finding an analogous definition for digraphs. As the tree-width of an undirected graph measures, informally, its distance to being a tree, the directed tree-width of a digraph, as defined by Johnson et al. [21], measures its distance to being a DAG, and an arboreal decomposition of a digraph exposes a (strong) connectivity measure of the original graph. The authors conjectured the existence of a grid-like theorem for their width measure [21]. In a recent breakthrough, Kawarabayashi and Kreutzer [24] proved this conjecture to be true: they showed that there is a computable function g such that every digraph of directed tree-width at least  has a cylindrical grid as a butterfly minor.3 Recently Campos et al. [7] improved the running time of the algorithm that follows from the proof of Kawarabayashi and Kreutzer [24], by locally modifying some steps of the original proof.

The technical contents of this section are mostly taken from [21]. By an arborescence T, we mean an orientation of a tree with root 
 in such a way that all edges are pointing away from 
. If a vertex v of T has out-degree zero, we say that v is a leaf of T. We now define guarded sets and arboreal decompositions of directed graphs. From here on, we refer to oriented edges only, unless stated otherwise, and D will always stand for a directed graph. All the considered directed graphs mentioned may contain directed cycles of length two.

Definition 5

Z-guarded sets
Let D be a digraph, let , and . We say that S is Z-guarded if there is no directed walk in  with first and last vertices in S that uses a vertex of . For an integer , we say that S is w-guarded if S is Z-guarded for some set Z with .

See Fig. 3 for an illustration of a Z-guarded set. If a set S is Z-guarded, we may also say that Z is a guard for S. We remark that in [21], [24], the authors use the terminology Z-normal sets instead of Z-guarded sets. In this article, we adopt the terminology used, for instance, in [4].

Fig. 3
Download : Download high-res image (25KB)
Download : Download full-size image
Fig. 3. A Z-guarded set S. The dashed line indicates that there cannot be a walk from u to v in V(D)∖(Z ∪ S).

Let T be an arborescence, , , and 
 be the head of e. We say that  if there is a path from 
 to r in T (notice that this definition implies that 
). We say that  if r is the head or the tail of e. To define the directed tree-width of directed graphs, we first need to introduce arboreal decompositions.

Definition 6 Arboreal decomposition and directed tree-width

An arboreal decomposition β of a digraph D is a triple  where T is an arborescence, 
, 
, and  are collections of sets of vertices of D (called bags) such that

(i)
 is a partition of  into non-empty sets, and

(ii)
if , then 
 is 
-guarded.

We say that r is a leaf of  if r has out-degree zero in T.
For a vertex , we denote by  the size of the set 
. The width of  is the least integer k such that, for all , . The directed tree-width of D, denoted by , is the least integer k such that D has an arboreal decomposition of width k.

The left hand side of Fig. 4 contains an example of a digraph D, while the right hand side shows an arboreal decomposition for it. In the illustration of the arboreal decomposition, squares are guards 
 and circles are bags of vertices 
. For example, consider the edge  with 
 from the bag 
 to the bag 
. Then 
 and, by item (ii) described above, this set must be -guarded since 
. In other words, there cannot be a walk in  starting in  going to  and then back. This is true in D since every path reaching  from the remaining of the graph must do so through vertices b or c. The reader is encouraged to verify the same properties for the other guards in the decomposition.

Fig. 4
Download : Download high-res image (29KB)
Download : Download full-size image
Fig. 4. A digraph D and an arboreal decomposition of D of width two. A bidirectional edge is used to represent a pair of edges in both directions.

We remark that DAGs have directed tree-width zero. As shown in [21], it is not hard to see that, if D is a digraph constructed by replacing every edge of an undirected graph G by two edges in opposite directions, then the directed tree-width of D is equal to the tree-width of G. This observation also implies that  is at most the tree-width of its underlying graph. Further intuitions of the similarities between the undirected and the directed cases are given by Reed [30]. It is worth noting that, in contrast to the undirected case, the class of digraphs of bounded directed tree-width is not closed under butterfly contractions [1].

The algorithm we present in this section consists of dynamic programming along an arboreal decomposition of the input digraph. Following the notation used by Johnson et al. [21], we refer to the information we want to compute at every step of the algorithm as an itinerary. We provide a formal definition for an itinerary for DEDP later. We recall that a set of vertices S is w-guarded if S is Z-guarded for some Z with  (cf. Definition 5).

Johnson et al. [21] provided two conditions that, if satisfied by a given problem, are sufficient to provide an XP algorithm for it in digraphs with bounded directed tree-width. More precisely, for a digraph D with , they ask that there is a real number α depending on w (and possibly some parameters of the problem, if any) and two algorithms satisfying the following conditions.

Condition 7

Johnson et al. [21]
Let  be two disjoint subsets of  such that there are no edges in D with head in A and tail in B. Then an itinerary for  can be computed from an itinerary for A and an itinerary for B in time 
.

Condition 8

Johnson et al. [21]
Let  be two disjoint subsets of  such that A is w-guarded and . Then an itinerary for  can be computed from an itinerary for A and an itinerary for B in time 
.

Using this notation, the following theorem says how to compute an itinerary for .

Theorem 9

Johnson et al. [21]
Provided that Conditions 7 and 8 hold, there is an algorithm running in time 
 that receives as input a digraph D and an arboreal decomposition for D with width at most w and outputs an itinerary for .

In [21] an XP algorithm for the Directed Disjoint Paths problem in digraphs of bounded directed tree-width is given as an example of application of the aforementioned tools, and a similar approach is claimed to work for the Hamilton Path, Hamilton Path With Prescribed Ends, Even Cycle Through a Specified Vertex problems, and others. We follow their ideas to provide an XP algorithm for -DEDP, where w is the directed tree-width of the input digraph. The main idea, formalized by the following definition and lemma, is that the number of weak components in the digraph formed by the union of the paths in a collection  satisfying the request set is bounded by a function depending on k and w only. Thus we can guess how the paths in  cross a set of vertices A that is w-guarded and use an arboreal decomposition of the input digraph to propagate this information in a dynamic programming scheme. We use the following definition.

Definition 10

Let D be a digraph and  be a collection of paths in D. We denote by  the digraph formed by the union of all paths in .

Definition 11 Limited collections

Let R be a request set in a digraph D with  and  be a collection of paths satisfying R. We say that  is -limited, for some , if  and for every w-guarded set 
, the digraph induced by 
 has at most  weak components.

The following lemma is inspired by [21, Lemma 4.5] and is key to the algorithm.
Lemma 12

Let R be a request set of size k in a digraph D and w be an integer. Then every collection of paths  satisfying R is -limited for every  containing all paths in .

Proof

Let  and S be as in the statement of the lemma and 
 be a w-guarded subset of S. By the definition of w-guarded sets, there is a set  with  such that 
 is Z-guarded. For , let 
 be the collection of paths formed by the subpaths of 
 intersecting 
. Thus, 
 consists of the union of subpaths of 
. Let 
 be the number of weak components of 
. Since 
 is Z-guarded, each subpath of 
 linking two distinct weak components of 
 must intersect Z. Thus, 
 and 
 since a vertex of Z can be in all paths of . We conclude that 
, as desired. ◂

We now formally define an itinerary for DEDP. From this point forward, we say that a request set R in a digraph D is contained in A if every vertex occurring in R is contained in A.

Definition 13 Itinerary

Let Γ be an instance of DEDP with , , and 
 be the set of all request sets on D which are contained in A. For an integer w, a -itinerary for A is a function 
 such that 
 if and only if

(i)
, for 
;

(ii)
; and

(iii)
the instance 
 of DEDP is positive.

With this notation, an instance  is positive if and only if 
 for some 
. We now provide algorithms satisfying Conditions 7 and 8 for the given definition of an itinerary for DEDP. By Lemma 12, we need to consider only request sets of size at most  whenever the input digraph has directed tree-width at most w in the following lemmas. We follow the proofs given by Johnson et al. [21], adapting them to our case. For every , the authors show how to compute a solution containing at most t vertices for a given instance of the Directed Disjoint Paths problem, if one exists, or to decide that no such solution exists. We drop this demand in our algorithm, and instead include the restriction on the congestion c.

Lemma 14

Let Γ be an instance of DEDP with  and  be disjoint subsets of  such that there are no edges in D with head in A and tail in B. Then a -itinerary for  can be computed from itineraries for A and B in time 
.

Proof

Let 
 and 
 be -itineraries for A and B, respectively. Given a request set L contained in , with 
 and , and an integer 
, we show how to correctly define 
 by looking at 
, 
, and the edges in D from A to B.

If L is contained in A we set 
 as there are no edges from B to A in D, and set 
 if L is contained in B. If there is a pair  such that  and , we set 
. Assume now that no such pairs exist in L and that L is not contained in A nor in B.

Define 
. For , do the following:

1.
If 
 and 
, define 
, 
 and include the pair 
 in 
.

2.
If 
 and 
, define 
, 
 and include the pair 
 in 
.

3.
If 
 and 
, define 
, 
, choose 
 and 
 arbitrarily in such way that there is an edge from 
 to 
 in D, include 
 in 
 and 
 in 
.

Fig. 5 illustrates this construction. Now, for 
, if 
 for some 
, 
 with 
, then we set 
. Otherwise, we repeat the procedure used to construct 
 and 
 with a different choice for 
 and/or 
 in the third step. If all possible choices of 
, and 
 have been considered this way, we set 
. We now show that this definition of 
 is correct.
Fig. 5
Download : Download high-res image (32KB)
Download : Download full-size image
Fig. 5. Example of the construction from Lemma 14.

Consider the instance 
 of DEDP, let 
, and 
. If it is positive, then for some choice of 
, 
, 
, and 
, there are collections of paths 
 and 
 and integers 
 and 
 such that 
 and 
 are solutions for the instances 
 and 
 of DEDP, respectively. Thus, 
 since 
 and 
 are at most as large as L. Conversely, if the above equation holds for some choice of 
, and 
 such that 
, we can construct a solution for the instance on  by considering the union of a solution for 
 with a solution for 
, together with edges from targets of 
 to sources of 
 which where considered in step

Image 1
described above. We conclude that the instance 
 is positive if and only if there are integers 
, 
 and request sets 
, 
 such that 
 and
By definition, to compute a -itinerary for  we need to consider every request set of size at most  contained . Thus there are 
 choices of L. By construction, there are at most 
 choices for 
 and 
 in total since we need to choose only the vertices 
 and 
 in step

Image 1
of the construction of those requests sets. Finally, since 
 and , the bound on the running time follows. ◂
Lemma 15

Let Γ be an instance of DEDP with  and  such that A is w-guarded and . Then a -itinerary for  can be computed from -itineraries for A and B in time 
.

Proof

Let 
 be a -itinerary for A, L be a request set contained in  with 
 and , and 
 be the instance 
 of DEDP, for 
.

For each pair , a path from s to t in  in a solution for 
 may be entirely contained in A, entirely contained in B, or it may intersect both A and B. We can test if there is a solution for 
 whose paths are all contained in A by verifying the value of 
, and in time 
 we can test if there is a solution for 
 that is entirely contained in B, since . We now consider the case where all solutions for 
 contain a path intersecting both A and B.

Suppose that P is a path from s to t in a solution  for 
. Let 
 be the set of subpaths of P which are contained in A, with 
, and, for , let 
 and 
 be the first and last vertices occurring in 
, respectively. Furthermore, let 
 be the collection of subpaths of P contained in 
. Then 
 is a collection of disjoint paths satisfying the request set 
, together with 
 if  and 
 if , such that each path of 
 has its extremities in 
 and all internal vertices in B. Fig. 6 illustrates this case.

Fig. 6
Download : Download high-res image (27KB)
Download : Download full-size image
Fig. 6. Collections 
 and 
. A continuous line represents a piece of P contained in A and a dashed line represents a piece of P contained in B.

The number of such collections is a function depending on a and w only and, by Lemma 12 and our assumption that A is w-guarded, we can assume that . We show how we can test whether there is a solution for 
 using an itinerary for A and, for each , searching for a collection 
 as described above. Intuitively, we want to guess how the paths in a solution for 
 intersect A and how those pieces can be connected through B.

For , let 
 and 
 (keeping each copy of duplicated entries) such that

1.
 and 
, for ;

2.
all vertices occuring in 
 are in A except possibly 
 and 
 (which may occur in ); and

3.
.

By Lemma 12, we only need to consider request sets of size at most  in  since every solution for Γ has at most  weak components in A. Let 
 be the set formed by the union of B with all vertices occurring in 
 and in
 
 That is, for each pair 
 that we want to satisfy in A, we want to link this subpath in a (possible) solution for 
 to the next one through a path in 
 satisfying the pair 
. We claim that there is a solution for 
 if and only if, for some choice of 
, 
, and 
, we have 
 and a collection of paths 
 satisfying 
 in 
 such that

(a)
every path of 
 starts and ends in 
 and has all of its internal vertices in B; and

(b)
at most 
 vertices of B occur in more than s paths of 
.

For the necessity, we can choose 
 and 
 as described above in this proof. For the sufficiency, let 
 and 
 be a solution for the instance 
 of DEDP, with 
. Now, since the paths in this collection are not necessarily disjoint, we are guaranteed to find only a directed walk from 
 to 
 for each pair 
 by linking (through the paths in 
) the endpoints of the paths in the collection satisfying 
, with . However, every such directed walk contains a path from 
 to 
 whose set of vertices is contained in the set of vertices of the walk. Thus by following those directed walks and choosing the paths appropriately, we can construct a solution for 
, since shortening the walks can only decrease the number of vertices occurring in  or more paths of the collection.

The number of collections 
 for which (a) and (b) hold is 
 and thus depending on k and w only, since . Since , , and the number of itineraries contained in  is at most 
, the bound on the running time follows. ◂

Finally, we obtain the XP algorithm combining Lemma 14, Lemma 15 together with Theorem 9.

Theorem 16

The DEDP problem is solvable in time 
 in digraphs of directed tree-width at most w.

4.2. Algorithms for the dual parameterization
We now show our algorithmic results for stronger parameterizations of DEDP including d as a parameter. The following definition is used in the description of the algorithms of this section.

Definition 17

Let D be a digraph, R be a request set with 
, and s be an integer. We say that a set  is s-viable for R if there is a collection of paths  satisfying R such that each vertex of X occurs in at most s paths of . We also say that  is certifying X.

Thus an instance  of DEDP is positive if and only if D contains an s-viable set X with . In other words, we want to find a set of vertices X of size at least d such that there is a collection of paths  satisfying R that is “well-behaved” inside of X; that is, the paths of  may intersect freely outside of X, but each vertex of X must be in at most s paths of . When , for instance, instead of asking for the paths to intersect only inside a small set of vertices (size at most c), we ask for them to be disjoint inside a large set of vertices (size at least d). Since we now consider d as a parameter instead of c, from this point onwards we may refer to instances of DEDP as .

The following definition is needed in the next proof. For two positive integers a and b with , the Stirling number of the second kind [6], denoted by , counts the number of ways to partition a set of a objects into b non-empty subsets, and is bounded from above by 
 
 
.

Theorem 18

There is an algorithm running in time 
 for the Disjoint Enough Directed Paths problem.

Proof

Let D be a graph on n vertices and  be an instance of DEDP. Notice that if X is s-viable for R, then any proper subset of X is s-viable for R as well. Therefore, we can restrict our attention to sets of size exactly d.

If , it is sufficient to test whether there is a d-sized set  such that there is a collection of paths satisfying R in , and this can be done in time 
.

Let now , and 
. We claim that a set  is 1-viable for R if and only if there is a partition  of X into sets 
 such that 
 is not an 
-separator, for .

Let  be as stated in the claim. For each , let 
 be a path from 
 to 
 in 
. Now, 
 is a collection satisfying R and no pair of paths in it intersect inside X. Thus X is 1-viable for R as desired. For the necessity, since X is 1-viable for R, there is a collection of paths 
 satisfying R such that 
 for all  with . Thus we choose 
 with 
 for  and 
 and the claim follows.

Assume now that  with . By the previous claim, we can check whether X is 1-viable for R by testing whether X admits a partition into (possibly empty) sets 
 such that 
 is not an 
-separator. Since 
, this yields an algorithm in time 
 for the DEDP problem when .

For , let 
 and construct a graph 
 from D by making s copies 
 of each vertex 
 and adding one edge from each copy to each vertex in the neighborhood of 
 in D, respecting orientations.

For , let 
 and 
. Now, there is a collection of paths  satisfying R in D such that each vertex in X is in at most s paths of  if and only if there is a collection of paths 
 in 
 such that no vertex in 
 occurs in more than one path of 
. To test whether a given X is s-viable for R with , we can just test whether 
 is 1-viable for R in 
. Since 
, this yields an algorithm in time 
 for DEDP. ◂

We now proceed to show that -DEDP is FPT, by providing a kernel with at most 
  vertices. We start with some definitions and technical lemmas. Notice that any vertex in D whose deletion disconnects more than s pairs in the request set R cannot be contained in any set X that is s-viable for R. Hence we make use of an operation to eliminate all such vertices from the input digraph while maintaining connectivity. We remind the reader that, for a request set R, we denote by  the set of source vertices in R and by  the set of target vertices in R (cf. Definition 2).

Definition 19 Non-terminal vertices

Let  be an instance of DEDP. For a digraph 
 such that 
, we define 
⁎
.

That is, 
⁎
 is the set of non-terminal (i.e., neither source nor target) vertices of D.

Definition 20 Congested vertex and blocking collection

Let  be an instance of DEDP. For 
⁎
, we define 
 as the subset of R that is blocked by X, that is, there are no paths from s to t in  for every 
. We say that a vertex 
⁎
 is an -congested vertex of D if 
. The blocking collection of R is the collection 
 where 
⁎
, for . We say that D is clean for R and that  is a clean instance if there are no congested vertices in 
⁎
. When R and s are clear from the context, we drop them from the notation.

We use the following operation to eliminate congested vertices of D while maintaining connectivity. It is used, for instance, in [8] (as the torso operation) and in [25].
Definition 21 Bypassing vertices and sets

Let D be a graph and . We refer to the following operation as bypassing v: delete v from D and, for each 
 add one edge from u to each vertex 
. We denote by  the graph generated by bypassing v in D. For a set of vertices , we denote by  the graph generated by bypassing, in D, all vertices of B in an arbitrary order.

We restrict our attention to vertices in 
⁎
 in Definition 20 because we want to avoid bypassing source or target vertices, and work only with vertices inside 
⁎
. Since , we show later that this incurs an additive term of 2k in the size of the constructed kernel.

In [25, Lemma 3.6] the authors remark that the ending result of bypassing a set of vertices in a digraph does not depend on the order in which those vertices are bypassed. Furthermore, bypassing a vertex of D cannot generate a new congested vertex: if u is a congested vertex of , then u is also a congested vertex of D, for any . Thus any instance  of DEDP is equivalent to the instance , if v is a congested vertex of D, and arbitrarily bypassing a vertex of D can only make the problem harder. We formally state those observations below.

Lemma 22

Let D be a digraph, R be a request set with 
, s be an integer, B be the set of -congested vertices of D, and 
. Then, with respect to R, X is s-viable in D if and only if X is s-viable in 
.

Proof

Let X be an s-viable set for R in D. If , then at least  paths of any collection satisfying R must intersect in X, contradicting our choice for X, and hence 
. Similarly, if 
 then  and the sufficiency follows. ◂

Furthermore, from any solution for an instance resulting from bypassing a set of vertices in 
⁎
, we can construct a solution for the original instance in polynomial time by undoing the bypasses.

Remark 23

Let  be an instance of DEDP and 
⁎
. If  is a solution for , then  is positive and a solution can be constructed from  in polynomial time.

The main ideas of the kernelization algorithm are the following. Let  be an instance of DEDP and 
 be the blocking collection of R. First, we show that, if D is clean for R, there is an  such that 
⁎
⁎
 (Lemma 24). Then, we show that if D is clean and sufficiently large, and , then the instance is positive and a solution can be found in polynomial time (Lemma 25).

Lemma 25 is used as the base case for our iterative algorithm. We start with the first instance, say , and proceed through  iterations. At each iteration, we will choose one path from some 
 to its destination 
 such that a large part of the graph remains unused by any of the pairs chosen so far (by Lemma 24) and consider the request set containing only the remaining pairs for the next iteration. We repeat this procedure until we arrive at an instance where the number of requests is exactly , and show that if n is large enough, then we can use Lemma 25 to output a solution for the last instance. From this solution, we extract a solution for  in polynomial time.

Lemma 24

Let  be an instance of DEDP, 
 be the blocking collection of R, and 
⁎
⁎
. If D is clean, then there is an  such that 
⁎
⁎
 and there is a path P in 
 from 
 to 
 such that 
⁎
⁎
.

Proof

First, notice that 
⁎
 
⁎
 
 
 Now, if 
⁎
 for every , then there must be a vertex in v such that 
, as in this case 
⁎
, contradicting our assumption that D is clean. We conclude that there is an  such that 
⁎
 and thus 
⁎
⁎
⁎
, as desired.

The result trivially follows if there is a path P from 
 to 
 in 
 with 
⁎
. Thus we can assume that every path from 
 to 
 in 
 intersects 
⁎
 (see Fig. 8). Let 
. By Menger's Theorem and since no vertex in 
⁎
 intersects every path from 
 to 
, there are two internally disjoint paths 
 and 
 from 
 to 
 in 
. Without loss of generality, assume that 
 is the shortest of those two paths, breaking ties arbitrarily. Then 
⁎
⁎
 since 
 and 
 are disjoint, and the result follows. ◂

Fig. 8
Download : Download high-res image (24KB)
Download : Download full-size image
Fig. 8. Three paths from si to ti in D/Bi. Square vertices are used to identify vertices in S(R)∪T(R), which may not be bypassed.

Lemma 25

Let  be an instance of DEDP, , and 
⁎
⁎
. If D is clean, 
⁎
, and , then  is positive and a solution can be found in time .

Proof

Let 
 be the blocking collection of R and 
, for . By Lemma 24, there is an  such that 
⁎
⁎
 and a path P from 
 to 
 such that 
⁎
⁎
. Let 
⁎
. Now,
⁎
⁎
 
⁎
 
 and since 
, we are free to choose arbitrarily any collection of paths satisfying 
 in 
. Reversing the bypasses done in D, this collection together with 
 yields a collection of paths satisfying R in D such that all vertices in 
⁎
 are contained in at most s of those paths. Since 
⁎
 by hypothesis, we have that 
⁎
 as required. We can generate the sets 
 in time  by deleting a vertex of D and testing for connectivity between 
 and 
. Thus a solution can be found in time , as desired. ◂

We are now ready to show the main ingredient of the algorithm: we provide a polynomial-time algorithm to solve large clean instances of the Disjoint Enough Directed Paths problem.
Theorem 26

Let  be a clean instance of DEDP with 
⁎
⁎
 . Then  is positive and a solution can be found in time 
.

Proof

Let 
 be the blocking collection of R. We consider 
 to be sorted in non-decreasing order by the size of its elements and, by rearranging R if needed, we assume that this order agrees with R. For , we construct a sequence of sets 
 where 
⁎
⁎
 and

(i)
;

(ii)
 is a collection of paths 
 such that 
 is a path from 
 to 
 in 
, for ; and

(iii)
⁎
 is large enough to guarantee that we can find a path from 
 to 
 avoiding a large part of 
. Formally, we want that
⁎
⁎
 

We begin with 
, 
⁎
⁎
, and 
. Let 
. By applying Lemma 24 with input 
, we conclude that 
⁎
⁎
 and there is a path 
 from 
 to 
 in 
 with 
⁎
⁎
. Let 
⁎
 and 
. Now,
⁎
⁎
 
⁎
 
 and conditions

Image 2
,
Image 3
, and
Image 4
above hold for 
. Assume that  triples have been chosen in this way.
As before, we assume that 
 is sorted in non-increasing order by the size of its elements, and that this order agrees with 
. Furthermore, as 
 is clean, so is 
.

Let 
. Applying Lemma 24 with input 
, we conclude that 
⁎
⁎
 and there is a path 
 from 
 to 
 in 
 with 
⁎
⁎
. Let 
 and 
. Then
⁎
⁎
 
 and by our assumption that

Image 4
holds for 
 it follows that
⁎
⁎
 
 
⁎
 
 as desired and thus
Image 2
,
Image 3
, and
Image 4
hold for 
. The algorithm ends after iteration . Following this procedure, we construct the collection 
 satisfying
Image 3
and the graph 
 with 
 satisfying
Image 4
. Noticing that 
 (that is, only  pairs in R are not accounted for in 
), it remains to show that our choice for 
⁎
 is large enough so that we are able to apply Lemma 25 on the instance 
 of DEDP. That is, we want that 
⁎
. By
Image 4
it is enough to show that
⁎
⁎
 
 and rewriting both sides of the fraction as k! and , respectively, we get
 
 
 
 which holds for
 
 
  as desired.
Applying Lemma 25 with input 
 yields a collection 
 satisfying 
 and a set  of size d (since 
) such that X is disjoint from all paths in 
, since all vertices in 
⁎
 were bypassed in 
 for every 
, and all vertices in X occur in at most s paths of 
. We can construct a collection of paths satisfying R from 
 by reversing all the bypasses done in D and connecting appropriately the paths in the collections (see Remark 23). We output this newly generated collection as a solution for .

For the running time, let . We need time  to order the elements of 
, time  to find the sets 
, for , and  to find each of the paths 
. Hence the algorithm runs in time 
. ◂

We acknowledge that it is possible to prove Theorem 26 without using Lemma 25 by stopping the iteration at the digraph 
 instead of 
. However we believe it is easier to present the proof of Theorem 26 by having separate proofs for the iteration procedure (Lemma 24) that aims to generate an instance of DEDP for which we can apply our base case (Lemma 25).

Since any instance can be made clean in polynomial time, the kernelization algorithm for -DEDP follows easily. Given an instance , we bypass all congested vertices of D to generate 
. If 
⁎
 is large enough to apply Theorem 26, the instance is positive and we can find a solution in polynomial time. Otherwise, we generated an equivalent instance 
 with 
 bounded from above by a function depending on , and s only. As we restrict , if D is clean and 
  we get the desired bound for 
⁎
. Thus, the following is a direct corollary of Theorem 26.

Theorem 27

There is a kernelization algorithm running in time 
 that, given an instance  of DEDP, outputs either a solution for the instance or an equivalent instance 
 with 
 .

5. Concluding remarks
We introduced the Disjoint Enough Directed Paths problem and provided a number of hardness and algorithmic results, summarized in Table 1. Several questions remain open.

We showed that DEDP is NP-complete for every fixed  and  and we leave open the question of whether DEDP is NP-complete for every fixed  and fixed  such that . The reduction used in the proof of Theorem 3 also shows that DEDP is as hard as Directed Disjoint Paths with Congestion. Although it is not known whether the latter is NP-complete for some fixed value of k when the congestion is at least two, a positive answer to this question would also imply the NP-completeness of DEDP for some fixed k and  with . Giannopoulou et al. [20, Conjecture 1.3] conjectured that DDPC is solvable in polynomial time for every fixed  and fixed congestion .

We provided an algorithm running in time 
 to solve the problem. This algorithm tests all partitions of a given  in search for one that respects some properties. Since there are at most  
  subsets of  of size d, this yields an XP algorithm. The second term on the time complexity comes from the number of partitions of X we need to test. The problem may become easier if X is already given or, similarly, if d is a constant. In other words, is the (s)-DEDP problem FPT for fixed d?

Our main result is a kernel with at most 
  vertices. The natural question is whether the problem admits a polynomial kernel with parameters k, d, and s, or even for fixed s. Notice that if there is a constant ℓ such that , then the size of the kernel is 
, which is polynomial on d and k. The case  is also particularly interesting, as DEDP with  is equivalent to the Steiner Network problem. In this case, we get a kernel of size at most 
.

While we do not know whether -DEDP admits a polynomial kernel, at least we are able to prove that a negative answer for  is enough to show that -DEDP is unlikely to admit a polynomial kernel for any value of  when k is “far” from s, via the following polynomial time and parameter reduction.

Remark 28

For any instance  of DEDP and integer , one can construct in polynomial time an equivalent instance 
 of DEDP with 
.

Proof

For a request set R in D, let 
 be the request set in D formed by  copies of each pair in R and let 
. We claim that an instance  of DEDP is positive if and only if the associated instance 
, also of DEDP, is positive.

From any solution  for the first instance, we can construct a solution for the second by taking  copies of each path in  and thus the necessity holds. For the sufficiency, let X be an s-viable set for 
 with certifying collection 
. By the construction of 
 and since at most  paths in 
 can intersect X, we conclude that there is path 
 from s to t in  for each pair . Choosing all such paths we construct a collection  satisfying R in , and the remark follows. ◂

In the undirected case, the Steiner Tree problem is unlikely to admit a polynomial kernel parameterized by k and c, with  (in other words, the size of the solution); a simple proof for this result can be found in [12, Chapter 15]. Even if we consider a stronger parameter (that is, d instead of c), dealing with directed graphs may turn the problem much harder. We also remark that the problem admits a polynomial kernel in the undirected case if the input graph is planar [29]. It may also be the case for directed graphs.