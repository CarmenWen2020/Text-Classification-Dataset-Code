Abstract
In this paper, we define the operational and denotational semantics of a special class of parallel quantum programs, namely disjoint parallel quantum programs. Based on them, a proof system for reasoning about disjoint parallel quantum programs is developed, which is (relatively) complete even when entanglement between different processes appears in the preconditions and postconditions.

Keywords
Quantum programming
Quantum Hoare logic
Parallel programs
Entanglement

1. Introduction
Several classical program logics had been extended to quantum programs [3], [9], [10], [15], [21] more than ten years ago. In particular, the notion of weakest precondition for a quantum program as a physical observable (or mathematically a Hermitian operator) was introduced by D'Hondt and Panangaden in [14], and then a Hoare-like logic for both partial and total correctness of quantum programs with (relative) completeness was built in [37]. In the last few year, some significant progress has been made in further developing quantum Hoare logic. For example, ghost (i.e. auxiliary) variables in quantum Hoare logic were carefully examined in [36]. A simplification of quantum Hoare logic for more convenient applications was obtained in [41] by restricting to projective preconditions and postconditions. Quantum Hoare logic was also generalized in [20], [33] for reasoning about robustness of quantum programs against quantum noise during execution. A relational quantum Hoare logic with subspaces of (equivalently, projection operators on) the state Hilbert space as preconditions and postconditions was first proposed in [35], targeting applications in security verification of quantum cryptographic protocols. It was further extended in [4], [24] to the general case where any Hermitian operators can be used as preconditions and postconditions.

1.1. Why parallel quantum programming?
All of the works mentioned above consider sequential quantum programming. However, parallel programming problem has recently arisen in quantum computing. Firstly, several models of parallel and distributed quantum computing were proposed, mainly with the motivation of using the physical resources of two or more small-capacity quantum computers to realize large-capacity quantum computing, which is out of the reach of current technology [11], [5]. Secondly, quantum algorithms for solving paradigmatic parallel and distributed computing problems that are faster than the known classical algorithms have been discovered; for example, quantum algorithm for the leader election problem [34], quantum protocol for the dinning philosopher problem [1], parallel implementations of the quantum Fourier transform and Shor's quantum factoring algorithm [12], [26]. In particular, Bravyi, Gosset and König recently discovered a parallel quantum algorithm solving a linear algebra problem called HLF (Hidden Linear Function), which gives for the first time an unconditional proof of a computational quantum advantage [8]. Thirdly, parallelism has been carefully considered in the physical level design of quantum computer architecture (for example [25]), in particular instruction parallelism in Rigetti's quantum instruction set architecture [32] and IBM Q [13]. Fourthly, several authors [16] started to consider how to design an operating system for quantum computers, in which parallelism and concurrency will be is a major issue.

1.2. Contribution of this paper
From the above discussion, we see that parallel programming has arisen as an important problem from several different directions of quantum computing, but a formal theory of parallel quantum programming is still missing. This paper is the first attempt (to the best of our knowledge) to develop such a theory. As the first step, we choose to focus on the special case of disjoint parallel quantum programs. More explicitly, we define the operational and denotational semantics of disjoint parallel quantum programs; in particular, we present a (relatively) complete logic for reasoning about them.

Recall that Owicki-Gries and Lamport method [29], [28], [23] - one of the most popular methods for reasoning about classical parallel programs - consists of the Hoare logic for sequential programs, a rule for introducing auxiliary variables recording control flows and a key rule (R.PC) for parallel composition shown in Fig. 1. The rule (R.PC) degenerates to Hoare's parallel rule introduced in [18] when components 
 are disjoint; that is, they do not share variables.

Fig. 1
Download : Download high-res image (14KB)
Download : Download full-size image
Fig. 1. Proof rule for parallel composition.

Our logic is essentially is quantum extension of Owicki-Gries and Lamport method. It is built upon our previous work on quantum Hoare logic [37]. The major challenge is to find an appropriate quantum generalization of inference rule (R.PC) for parallel composition of programs. It is well known that in the classical case, disjoint parallel programs are easy to handle because interference freedom trivially holds. But the quantum case is fundamentally different, and even disjoint parallel quantum programs are hard to deal with due to possible entanglement between different processes. The first issue in defining a quantum generalization of rule (R.PC) is to find an appropriate quantum counterpart of logical conjunctions in the precondition and postcondition of parallel program 
. In the case of disjoint parallelism where 
 do not share variables, conjunctions 
 and 
 in rule (R.PC) have proper quantum counterparts, namely tensor products 
 and 
, respectively. But such a quantum generalization of (R.PC) (more precisely, Hoare's parallel rule) is obviously not strong enough to cope with the situation where entanglement between component programs is present. We propose two novel techniques to tame the difficulty of entanglement:

(a)
Introducing an additional inference rule obtained by invoking a deep theorem about the relation between noise and entanglement from quantum physics [17] (see rule (R.S2E) in Fig. 11); and

(b)
Introducing auxiliary variables (see Subsection 4.5) based on the observation in physics that entanglement may emerge when reducing a state of a composite system to its subsystems [27].

It turns out that both of them are generic. Using each of them, we are able to develop a proof system for disjoint parallel quantum programs and establish its (relative) completeness theorem in presence of entanglement (see Theorem 5.1, Theorem 5.2, Theorem 5.3, Theorem 5.4).
It should be pointed out that although the logic system developed in this paper only deals with disjoint parallel quantum programs, it is powerful enough for verification of some highly nontrivial quantum algorithms. In particular, using this logic, a formal verification of Bravyi-Gosset-König parallel quantum algorithm [8] solving HLF (Hidden Linear Function) - the first unconditional proof of a computational quantum advantage - is given in the expanded version of this paper [40]. On the other hand, this logic can serve as a stepstone toward a general theory of shared-variable parallel and distributed quantum programs.

1.3. Organization of the paper
The paper is organized as follows. For convenience of the reader, we briefly review quantum Hoare logic in Section 2. The operational and denotational semantics of disjoint parallel quantum programs are defined in Section 3. A series of proof rules for reasoning about disjoint parallel quantum programs are introduced in Section 4. Then in Section 5, the rules given in Section 4 are organized into two proof systems, and the (relative) completeness of the two systems are proved. A brief conclusion is drawn in Section 6, where several problems for future research are also pointed out.

2. Quantum Hoare logic
The parallel quantum programs considered in this paper are parallel compositions of quantum while-programs studied in [37], [38]. In this section, we briefly review the syntax and semantics of quantum while-language and quantum Hoare logic from [37], [38]. They will serve as a basis of the subsequent sections.

2.1. Quantum while-programs
We assume a countably infinite set Var of quantum variables. For each , we write 
 for its state Hilbert space. In this paper, it is always assumed to be finite-dimensional or separable. For any , we put 
.

Definition 2.1

Syntax [37], [38]
The quantum while-programs are defined by the grammar:(1)
(2)
(3)

Here,  means that quantum variable q is initialized in a basis state |0〉. 
 denotes that unitary transformation U is applied to quantum register 
, which is a sequence of quantum variables. In the case statement (2), quantum measurement M is performed on the register 
 and then a subprogram 
 is selected for next execution according to the measurement outcome m. In the loop (3), measurement M in the loop guard has only two possible outcomes ; if the outcome is 0 the loop terminates, and if the outcome is 1 the program executes the loop body P and enters the loop again.

For each quantum program P, we write  for the set of quantum variables occurring in P. Let 
 be the state Hilbert space of P. We write 
 for the set of partial density operators, i.e. positive operators with traces ≤1, in 
. A configuration is a pair , where P is a program or the termination symbol ↓, and 
 denotes the state of quantum variables.

Definition 2.2

Operational semantics [37], [38]
The operational semantics of quantum while-programs is defined as a transition relation → by the transition rules in Fig. 2.

Fig. 2
Download : Download high-res image (49KB)
Download : Download full-size image
Fig. 2. Transition Rules for Quantum while-Programs. In rule (In), 
 for an orthonormal basis {|i〉} of 
; e.g. 
 if type(q)=Bool and 
 if type(q)=Int (see [38], page 63 for the definitions of data types Bool and Int). In (SC), we make the convention ↓;P2 = P2. In (IF), m ranges over every possible outcome of measurement M = {Mm}.

Note that the transitions in rules (IF), (L0) and (L1) are essentially probabilistic; for example, for each m, the transition in (IF) happens with probability 
, and the program state ρ is changed to 
. But following Selinger [31], we choose to combine probability 
 and density operator 
 into a partial density operator 
. This convention allows us to present the operational semantics as a non-probabilistic transition system, and it further works for the composition of a sequence of transitions because all transformations in quantum mechanics are linear. Thus, it significantly simplifies the presentation.

Definition 2.3

Denotational semantics [37], [38]
For any quantum while-program P, its semantic function is the mapping 〚〛
 defined by(4)〚〛
⁎
 for every 
, where 
⁎
 is the reflexive and transitive closure of transition relation → given in Definition 2.2, and  denotes a multi-set.

2.2. Correctness
The properties of quantum program states are described by quantum predicates introduced by D'Hondt and Panangaden in [14]. The Löwner order between operators is defined as follows:  if and only if  is positive. Then a quantum predicate in a Hilbert space  is an observable (a Hermitian operator) A in  with , where 0 and I are the zero operator and the identity operator on , respectively. Whenever  is infinite-dimensional, a quantum predicate in it is always required to be a bounded operator.

Definition 2.4

Correctness formula, Hoare triple [14], [37], [38]
A correctness formula (or a Hoare triple) is a statement of the form , where P is a quantum while-program, and both  are quantum predicates in 
, called the precondition and postcondition, respectively.

Definition 2.5

Partial and total correctness [37], [38]
1.
The correctness formula  is true in the sense of total correctness, written 
, if for all 
 we have:〚〛

2.
The correctness formula  is true in the sense of partial correctness, written 
, if for all 
 we have:〚〛〚〛

The defining inequalities of total and partial correctness can be easily understood by noting that the interpretation of  in physics is the expectation (i.e. average value) of observable A in state ρ, and 〚〛 is indeed the probability that with input ρ program P does not terminate.

2.3. Proof system
A Hoare-like logic for quantum while-programs was established in [37], [38]. It includes a proof system qPD for partial correctness and a system qTD for total correctness. The axioms and inference rules of qPD are presented in Fig. 3. Similar to the classical case, qTD is obtained from qPD by adding a ranking function into rule (R.LP) to guarantee termination (with probability 1).

Fig. 3
Download : Download high-res image (65KB)
Download : Download full-size image
Fig. 3. Proof System qPD for Quantum while-Programs. In axiom (Ax.In), {|i〉} is an orthonormal basis of 
. In rule (R.Or), ⊑ stands for the Löwner order.

The soundness and (relative) completeness of both qPD and qTD were proved in [37], [38].

Theorem 2.1

Soundness and completeness [37], [38]
For any quantum while-program P, and for any quantum predicates ,

2.4. Auxiliary rules
Several auxiliary rules for classical programs [2] were generalized in [39] for quantum while-programs. Here, we recall some of them needed in subsequent sections. Let us first introduce several notations. For any  and operator A on 
, 
 is called the cylindric extension of A in 
. If  and . Then the partial trace 
 is a mapping from operators on 
 to operators on 
 defined by 
 for every  in 
 and 
 in 
, together with linearity. Let 
 be a sequence of operators on a Hilbert space . We say that 
 weakly converges to an operator A, written 
, if 
 for all  (see for example [22]). Then we can present the auxiliary axioms and rules in Fig. 4. For detailed explanation of them, see Section 5 of [39].

Fig. 4
Download : Download high-res image (47KB)
Download : Download full-size image
Fig. 4. Auxiliary Axioms and Rules for Quantum while-Programs. In axiom (Ax.Inv), var(P)∩V = ∅ and A = clV∪var(P)(B) for some V ⊆ Var and for some quantum predicate B in 
. In rule (R.TI), V,W ⊆ Var, V ∩ W = ∅, A,B are quantum predicates in 
, IW is the identity operator on 
 and var(P)⊆V. In (R.CC), pi ≥ 0 (i = 1,...,m) and 
. In (R.Lin), 0 ≤ λ and λA,λB⊑I. In (R.Inv), p,q ≥ 0, p + q ≤ 1, and C is a quantum predicate in 
 for some V ⊆ Var with V ∩ var(P)=∅. In (R.SO),  is a super-operator on 
 for some V ⊆ Var with V ∩ var(P)=∅. In (R.Lim), {An} and {Bn} are sequences of quantum predicates.

The following lemma establishes soundness of the auxiliary axioms and rules in Fig. 4.

Lemma 2.1

Soundness of auxiliary axioms and rules [39]
1.
The axiom (Ax.Inv) is sound for partial correctness.

2.
The rules (R.TI), (R.CC), (R.Inv) and (R.Lim) are sound both for partial and total correctness.

3.
The rule (R.SO) is sound for total correctness, and it is sound for partial correctness whenever  is trace-preserving.

4.
The rule (R.Lin) is sound for total correctness, and it is sound for partial correctness whenever .

The auxiliary rules in Fig. 4 will be combined with a rule for parallel composition in Section 5 to obtain a (relatively) complete axiomatization of partial and total correctness of disjoint parallel quantum programs. However, rule (R.CC) for the Convex Combination of preconditions and postconditions is not strong enough in the case of partial correctness. To present a strengthened version of (R.CC), we first introduce:

Definition 2.6

Let A be a quantum predicate and P a quantum program.

1.
We say that A characterizes nontermination of quantum program P, written , if 
, where I is the identity operator on 
; that is, for all density operators ρ:(5)〚〛

2.
We say that A characterizes abortion of P, written , if 
, where 0 is the zero operator on 
; that is, for all density operators ρ:(6)〚〛

Remark 2.1

1.
Note that 〚〛 is the probability that program P with input ρ terminates. Thus, inequality (5) means that its nontermination probability is upper-bounded by predicate A. On the other hand, the intuition behind inequality (6) is that predicate A implies nontermination.

2.
It is obvious from the completeness (Theorem 2.1) that  and  can be verified in qTD and qPD, respectively.

It is clear that with the assumptions 
 and 
, the preconditions in the conclusions of both (R.CC1) and (R.CC2) are weaker than the precondition in the conclusion of (R.CC). We should note that a new predicate A is introduced here for weakening the precondition with the additional premises  and  in (R.CC1) and (R.CC2), respectively. It is interesting to observe the duality between (R.CC1) and (R.CC2).

Lemma 2.2

The rules (R.CC1) and (R.CC2) are sound for partial correctness.

3. Disjoint parallel quantum programs
Now we start to study disjoint parallel quantum programs. In this section, we define their syntax and operational and denotational semantics. As we saw in Definition 2.2, Definition 3.2, the statistical nature of quantum measurements introduces nondeterminism even in the operational semantics of quantum while-programs. Such nondeterminism is much more complicated in parallel quantum programs; in particular when they contain loops and thus can have infinite computations, because it is intertwined with another kind of nondeterminism, namely nondeterminism introduced in parallelism (see Example 3.2). But surprisingly, the determinism is still true for the denotational semantics of disjoint parallel quantum programs, and it further entails that disjoint parallel compositions of quantum programs can always be sequentialized.

3.1. Syntax
Let us first define the syntax of disjoint parallel quantum programs.

Definition 3.1 Syntax

Disjoint parallel quantum programs are generated by the grammar given in equations (1) and (2) together with the following clause:(7)
 where , 
 are quantum while-programs, and 
 for .

Program P in equation (7) is called the disjoint parallel composition of 
. We write: 
 for the set of quantum variables in P. Thus, the state Hilbert space of P is 
.

3.2. Operational semantics
We now start to define the operational semantics of disjoint parallel quantum programs. To accommodate the intertwined nondeterminism in them introduced by quantum measurements and parallelism together, we have to first recast the operational semantics of quantum while-programs in a slightly different way.

3.2.1. Reformulating operational semantics of quantum while-programs
We define a configuration ensemble as a multi-set 
 of configurations with 
. For simplicity, we identify a singleton  with the configuration . Moreover, we need to extend the transition relation between configurations given in Definition 2.2 to a transition relation between configuration ensembles.

Definition 3.2

The transition relation between configuration ensembles is of the form:
 and defined by rules (Sk), (In), (UT), (SC) in Fig. 2 together with the rules presented in Fig. 6.

Fig. 6
Download : Download high-res image (52KB)
Download : Download full-size image
Fig. 6. Extended Transition Rules for Quantum while-Programs. In rule (MS1), C is a configuration and  is a configuration ensembles. In rule (MS2), 
 and 
 are all configuration ensembles. Note that in (MS2), ⋃ stands for union of multi-sets.

We observe that for each possible measurement outcome m, transition rule (IF) in Fig. 2 gives a transition from configuration . So, (IF) is essentially a family of rules. Transition rule (IF') in Fig. 6 is thus a merge of these transitions by collecting all the target configurations into a configuration ensemble. Note that (IF') is a single rule. Similarly, transition rule (L') is a merge of (L0) and (L1) in Fig. 2. Both of transition rules (MS1) and (MS2) are introduced for manipulating configuration ensembles as Multi-Sets of configurations. Rule (MS1) is used simply for lifting transitions of configurations to transitions of configuration ensembles. Rule (MS2) allows us to combine several transitions from some small ensembles into a single transition from a large ensemble.

3.2.2. Defining operational semantics of disjoint parallel quantum programs
With the above preparation, we can define the operational semantics of disjoint parallel quantum programs in a simple way.

Definition 3.3 Operational semantics

Transition rule (PC) define the semantics of (disjoint) Parallel Composition 
 of (sequential) components 
,..., 
. Intuitively, it models interleaving concurrency; more precisely, it means that for a fixed , if the ith component 
 of parallel quantum programs 
 performs a transition, then P can perform the same transition. We will use the convention that 
 when 
 for all i. Rule (PC) is similar to the transition rule for classical parallel programs.

To further illustrate the transition rule (PC), we consider the following simple example. In this paper, to simplify the presentation, for a pure state  and a complex number α with , we often use the vector  to denote the corresponding partial density operator 
.

Example 3.1

Let  be three qubit variables. We consider the following two programs:
 Program 
 performs Pauli gate X on qubit p and then Pauli gate Z on qubit q. Program 
 is a measurement-based conditional. It first performs the measurement in the computational basis, 
, on qubit r. If the measurement outcome is 0 then the program does skip, and if the outcome is 1 then it performs the Hadamard gate H on qubit r. Obviously, 
 and 
 are disjoint. Now let us examine their execution in parallel with an input entangled between the variables  of 
 and the variable r of 
. Let 
 
 be the GHZ (Greenberger-Horne-Zeilinger) state, a maximally entanglement of three qubits . Then
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  is a computation of parallel program 
 starting in state . Here, we use 
 to indicate that the transition is made by 
 according to rule (PC), and 
 
.

It is interesting to see that at the second step of the computation in the above example, measurement M is performed by component 
 and thus certain nondeterminism occurs; that is, two different configurations are produced according to the two different outcomes  of M. Then in steps 3, 4 and 5, the following kind of interleaving appears: an action of component 
 happens between two actions of component 
 executed on the two different configurations that come from the same measurement M. Here, in a sense, nondeterminism caused by quantum measurements is intertwined with nondeterminism introduced by parallelism. It is worth noting that for a classical parallel program 
 with 
  being while-programs, such an interleaving never happens because nondeterminism does not occur in the execution of any component 
.

3.3. Denotational semantics
In this subsection, we define the denotational semantics of disjoint parallel quantum programs based on the operational semantics defined in the last subsection. As a preparation, we need to reformulate the denotational semantics of quantum while-programs, since the operational semantics of them was redefined in terms of the transition between configuration ensembles.

3.3.1. Reformulating denotational semantics of quantum while-programs
The denotational semantics (i.e. semantic function) of a quantum while-program given in Definition 2.3 can be represented using configuration ensembles introduced in the last subsection as follows. For any configuration ensemble , we define:
 It is evident that if  then  because  has no transition; that is,  implies .

Definition 3.4

1.
A computation of a quantum while-program P starting in a state 
 is a maximal finite sequence 
 or an infinite sequence 
.

2.
The value of computation π is defined as follows: 
 

Note that in the case of infinite π, sequence 
 is increasing according to the Löwner order ⊑. On the other hand, we know that 
 with ⊑ is a CPO (see [38], Lemma 3.3.2). So, 
 exists.

The following lemma shows determinism of quantum while-programs.

Lemma 3.1

For any quantum while-program P and 
, there is exactly one computation π of P starting in ρ and 〚〛.

3.3.2. Defining denotational semantics of disjoint parallel quantum programs
Now we are ready to introduce the denotational semantics of disjoint parallel quantum programs. But it cannot be defined by simply mimicking Definition 2.3, Definition 3.4. For each parallel quantum program P, we set:(8) for any 
, where  is given as in Definition 3.4. Then we have:

Definition 3.5 Denotational semantics

The semantic function of a disjoint parallel program P is the mapping 〚〛
 defined by〚〛 for any 
.

The above definition deserves a careful explanation. First, the reader may be wondering why we need to take maximal elements in the definition of 〚〛. For a parallel quantum programs without loop, it is unnecessary to consider maximal elements; for instance, we simply have:〚
〛
 
 in Example 3.1. However, the following example clearly shows that only maximal elements are appropriate whenever infinite computations occur.

Example 3.2

Let 
 be two qubit variables, and for ,
 where 
, and M is the measurement in the computational basis. Then the following are three computations of parallel program 
 starting in state  with 
 
:

1.
All transitions are performed by 
:
 where for every :
 
 
 
 
 
 

2.
All transitions are performed by 
:
 where for every :
 
 
 
 
 
 

3.
The transitions are fairly performed by 
 and 
:
 where
 
 
 
 
 
 
 
 

Obviously, 
 
, and  is a maximal element of 
. Furthermore, we have: 〚
〛
 
.

Second, the output 〚〛 of a parallel program P with input ρ is defined as the set of maximal elements of a partially ordered set. In general, there may be no or more than one maximal element. But in the case of disjoint parallelism, the structure of 〚〛 is simple. As stated at the beginning of this subsection, the denotational semantics of a disjoint parallel quantum program is deterministic although its operational semantics may demonstrate a very complicated nondeterminism; that is, as a generalization of Lemma 3.1, we have:

Lemma 3.2 Determinism

For any disjoint parallel quantum program P and 
, 〚〛 is a singleton.

For a disjoint parallel quantum program P and for any 
, if singleton 〚〛
, then we will always identify 〚〛 with the partial density operator 
. Indeed, 
 must be the greatest element of .

It is well-known that every disjoint parallel composition of classical while-programs can be sequentialized (see [2], Lemma 7.7). This result can also be generalized to the quantum case.

Lemma 3.3 Sequentialization

Suppose that quantum while-programs 
 are disjoint. Then:

1.
For any permutation 
 of , 〚
〛〚
〛.

2.
〚
〛〚
〛.

3.4. Correctness
Due to its determinism (Lemma 3.2), (partial and total) correctness of a disjoint parallel quantum program P can be defined simply using Definition 2.5 provided that for each input ρ, we identify the singleton 〚〛
 with the partial density operator 
.

4. Proof rules for disjoint parallel quantum programs
In this section, we derive a series of rules for proving correctness of disjoint parallel quantum programs. In classical computing, the behavior of a disjoint parallel program is relatively simple due to noninterference between its components; in particular, only a simplified version of rule (R.PC) in Fig. 1 (without noninterference condition) is needed for reasoning about them (see [2], Lemmas 7.6 and 7.7 and Rule 24 on page 255). As we will see shortly, entanglement makes much harder to reason about disjoint parallel quantum programs than their classical counterparts.

Naturally, we first try to find appropriate quantum generalizations of the inference rules for classical disjoint parallel programs. But at the end of this subsection, we will see that some novel rules that have no classical counterpart are needed to cope with entanglement.

4.1. Sequentialization rule
To warm up, let us first consider a simple inference rule. As mentioned in the previous section, all disjoint parallel programs in classical computing can be sequentialized with the same denotational semantics. Accordingly, they can be verified through sequentialization ([2], Section 7.3). For quantum computing, the following sequentialization rule is valid too:

Lemma 4.1

The rule (R.Seq) is sound for both partial and total correctness.

Let us give a simple example to show how rule (R.Seq) can be applied to verify disjoint parallel quantum programs by Sequentialization, i.e. transforming them into equivalent sequential programs. Our example is a quantum analog of the following simple example given in [2] to show the necessity of introducing auxiliary variables: This correctness formula for a disjoint parallel program cannot be proved by merely using the parallel composition rule (R.PC) in Fig. 1. However, it can be simply derived by rule (R.Seq). Similarly, we have:

Example 4.1

Let  be two quantum variables with the same state Hilbert space . For each orthonormal basis 
 of , we define a quantum predicate:(9)
 
 in , where 
 for every i. It can be viewed as a quantum counterpart of equality . It is interesting to note that the quantum counterpart of  is not unique because for different bases 
, 
 are different. For any unitary operator U in , we have:(10)
 where 
 is the quantum counterpart of equality defined by orthonormal basis 
. Clearly, (10) can be proved using rule (R.Seq) together with (Ax.UT) in Fig. 3.

It is worth pointing out that the quantum generalization of a concept in a classical system usually has the flexibility arising from different choices of the basis of its state Hilbert space.

4.2. Tensor product of quantum predicates
Although rule (R.Seq) in Fig. 8 can be used to verify a disjoint parallel program 
, it does not reflect the essence of (disjoint) parallelism where 
 are independent processes. Moreover, it does not allows us to combine local reasoning about each process 
 to form a global judgment about the parallel program 
. So, we will not use it in the sequel. Instead, we now start to consider how the crucial rule for reasoning about parallel programs, rule (R.PC) in Fig. 1, can be generalized to the quantum case. To this end, we first need to identify a quantum counterpart of conjunction 
 (and 
) in rule (R.PC). For disjoint parallel quantum programs, a natural choice is tensor product 
 because it enjoys a nice physical interpretation:
 
 
 
 The above equation shows that the probability that a product state 
 satisfies quantum predicate 
 is the product of the probabilities that each component state 
 satisfies the corresponding predicate 
. This observation motivates an inference rule for tensor product of quantum predicates presented in Fig. 9. It can be seen as the simplest quantum generalization of rule (R.PC) in Fig. 1.

Fig. 8
Download : Download high-res image (7KB)
Download : Download full-size image
Fig. 8. Sequentialization Rule for Disjoint Parallel Programs.

Fig. 9
Download : Download high-res image (10KB)
Download : Download full-size image
Fig. 9. Rule for Tensor Product of Quantum Predicates.

Lemma 4.2

The rule (R.PC.P) is sound with respect to both partial and total correctness.

The rule (R.PC.P) is a quantum generalization of proof rule (R.PC) for classical parallel programs given in Fig. 1. But it can only be used to deal with a special case, namely inferring correctness of disjoint parallel quantum programs with respect to (tensor) Product quantum predicates as preconditions and postconditions. For instance, we can use (R.PC.P) to prove a very special instance of (10) in Example 4.1 with 
 being a degenerate distribution at some 
:
 where 
 and , but it is not strong enough to derive the entire (10).

4.3. Separable quantum predicates
A larger family of predicates in 
 than product predicates is separable predicates defined in the following:

Definition 4.1

Let A be a quantum predicate in 
. Then:

1.
A is said to be separable if there exist 
 and quantum predicates 
 in 
  such that 
 and
 
 
 where m is a positive integer or ∞.

2.
A is entangled if it is not separable.

Obviously, rule (R.PC.S) is also a quantum generalization of proof rule (R.PC) for classical parallel programs given in Fig. 1. It can deal with a more general case than what rule (R.PC.P) does; that is, it can reason about disjoint parallel quantum programs with Separable quantum predicates as preconditions and postconditions; for example, correctness (10) in Example 4.1 can be proved using rule (R.PC.S).

4.4. Entangled quantum predicates
It is well-understood that entangled states are indispensable physical resources [19] that make quantum computers outperform classical computers. Entangled quantum predicates represent quantum non-locality in a dual setup where more information can be revealed by joint (i.e. globally entangled) measurements than can be gained by local operations and classical communications (LOCC) [30], [6].

Obviously, inference rule (R.PC.S) is unable to prove any correctness of the form 
 for a parallel quantum program 
 where A or B is an entangled predicate, as shown in the following:

Example 4.2

We consider a variant of Example 4.1. For each orthonormal basis 
 of , we write:
 
 
 for the maximally entangled state in , where . Then 
 can be seen as another quantum counterpart of equality  (different from 
 defined by equation (9)). Obviously,(11)
 that is, if the input is maximally entangled, so is the output after the same unitary operator is performed separately on two subsystems. Indeed, we can prove correctness (11) by using rules (R.Seq) and (Ax.UT), but (11) cannot be derived by directly using rule (R.PC.S).

4.5. Auxiliary variables
In this subsection, we present the first solution to the verification problem for disjoint parallel quantum program with entangled preconditions and postconditions; namely a combination of (R.PC.S) and several rules in Fig. 4 for introducing auxiliary variables.

For easy understanding, let us introduce the method of using auxiliary variables by considering an example.

Example 4.3

We use rule (R.PC.S) together with (R.TI) and (R.SO) in Fig. 4 to prove correctness (11) in Example 4.2. The key idea is to introduce two auxiliary variables 
 with the same state space . First, by (Ax.UT) we have:(12)
 where we use subscripts 
 to indicate the corresponding subsystems, and 
. Now applying rule (R.PC.S) to (12) yields:(13)
 Finally, we define superoperator: 
 
 for all mixed states ρ of 
 and 
, and obtain (11) by applying rule (R.SO) to (13) because
⁎
 
⁎
 

The idea employed in the above example can be summarized in the following three steps:

(1)
Pushing out: Introducing a fresh copy of each quantum variable as an auxiliary variable;

(2)
Entangling: Establishing the maximal entanglement between each original variable and its corresponding auxiliary variable; and

(3)
Pulling back: Pulling certain entanglement between the auxiliary variables through the entanglement between the original and auxiliary variables to generate indirectly the entanglement between the original variables in precondition and postcondition.

Indeed, as shown in next section, this strategy of introducing auxiliary variables can be generalized to deal with all entangled preconditions and postconditions for disjoint parallel quantum programs.
4.6. Transferring separable predicates to entangled predicates
It was shown in the last subsection that correctness of disjoint parallel quantum programs with entangled preconditions or postconditions can be derived by introducing auxiliary variables. Interestingly, a deep result in the theoretical analysis of NMR (Nuclear Magnetic Resonance) quantum computing provides us with another solution. It was discovered in [42], [7] that all mixed states of n qubits in a sufficiently small neighborhood of the maximally mixed state are separable. The interpretation of this result in physics is that entanglement cannot exist in the presence of too much noise. The result was generalized in [17] to the case of any quantum systems with finite-dimensional state Hilbert spaces. Recall that the Hilbert-Schmidt norm (or 2-norm) of operator A is defined as follows: 
. In particular, if 
 is a matrix, then 
.

Theorem 4.1

Gurvits and Barnum [17]
Let 
 be finite-dimensional Hilbert spaces, and let A be a positive operator on 
. If
 
 where I is the identity operator on 
, then A is separable.

The following corollary can be easily derived from the above theorem.

Corollary 4.1

For any two positive operators  on 
, there exists  such that both  and  are separable.

Motivated by Corollary 4.1, we introduce a new inference rule (R.S2E) in Fig. 11. The name (R.S2E) of this rule is designated for the idea of transforming Separable to Entangled: in order to prove correctness 
 for entangled predicates A and B, we find a parameter  such that  and  are separable, and then we can prove:(14)
 by using rule (R.PC.S). It is worth pointing out that Corollary 4.1 warrants that we can choose the same parameter ϵ in the precondition and postcondition.

Fig. 11
Download : Download high-res image (8KB)
Download : Download full-size image
Fig. 11. Rule for Transforming Separable Predicates to Entangled Predicates. Here, 0 < ϵ ≤ 1.

Example 4.4

For , consider the quantum program 
 given in Example 4.2. We write: 
 
 for a maximally entangled state of a 2-qubit system. Then it holds that(15)
 
 where 
 is the  unit matrix. The correctness formula (15) has entangled precondition and postcondition, and thus cannot be proved by only using rule (R.PC.S). Here, we show that it can be proved by combining rule (R.S2E) with (R.PC.S). In fact, one can first verify that(16)
 for  and any state , where 
 is the  unit matrix. Moreover, we write:
 
 
 Then we have the following decomposition of separable operator:
 
 
 
 and it is derived that(17)
 
 
 
 by applying (16) for  and , respectively, and applying rule (R.PC.S). Finally, correctness (15) is obtained by applying rule (R.S2E) to (17) with 
 
.

We conclude this subsection by presenting the soundness of inference rule R.S2E).

Lemma 4.3

The rule (R.S2E) is sound for both partial and total correctness.

5. Completeness theorems
Two methods for verification of disjoint parallel quantum programs, namely auxiliary variables and entanglement transformation, and the corresponding proof rules were introduced in the last section. In this section, we organize these rules into two formal proof systems and show that both of them are (relatively) complete. It should be noted that the sequentialization rule (R.Seq) is not included in the proof system defined in this section.

5.1. Completeness of the method of auxiliary variables
In this subsection, we present a proof system using the method of auxiliary variables and prove it is (relatively) complete.

5.1.1. Total correctness
Let us first consider total correctness. Let proof systems qTD (quantum Hoare logic for total correctness) be extended with the parallel composition rule (R.PC.P) for tensor products of quantum predicates and appropriate auxiliary rules: As shown in Example 4.3, disjoint parallel quantum programs with entangled preconditions and postconditions can be verified by introducing auxiliary variables using a combination of parallel rule (R.PC.P) and other rules in qTPA. Indeed, we have:

Theorem 5.1 Completeness for total correctness

The proof system qTPA is (relatively) complete for total correctness of disjoint parallel quantum programs; that is, for any disjoint quantum programs 
 and quantum predicates :

Proof

The overall idea of the proof is essentially the same as Example 4.3; that is, the proof can be carried out in the procedure from (1) pushing out to (2) entangling and then (3) pulling back (see detailed description of this procedure at the end of Example 4.3). Now let present the proof formally. Assume that
 We write 〚
〛 for the semantic function of parallel program and for each , let 
 be the semantic function of 
. Then by Lemma 1 in [39] we have 
⁎
, where 
⁎
 stands for the dual of . By rule (R.Or) it suffices to show that(18)
⁎

For simplicity of presentation, for each , we use 
 to denote the state Hilbert space of program 
. We use p to indicate the system of the parallel program 
, called the principal system. Thus, it has the state space 
.

In what follows, we prove (18) in three steps, gradually from a special form of B to a general B.

Step 1: As the first step, let us consider the very special case of  with some constraints on .

Claim 5.1

For any vector  in 
, if its norm is less than or equal to 1 and its reduced density operator to each 
 is of finite rank, then we have:
⁎

Proof of Claim 5.1. For each i, as the reduced density operator of  to 
 is of finite rank, we can use 
 to denote the support of the reduced density operator and assume its rank is 
:
 Obviously, 
. We assume that 
 is an orthonormal basis of 
 and its expansion 
 is an orthonormal basis of 
. Then  can be written as follows: 
 
 
 We define the conjugate vector of  as:
 
⁎
 
 For each i, we further introduce an auxiliary system with the state Hilbert space 
 isomorphic to 
. Let 
 and 
 be the orthonormal basis of 
 and 
 corresponding to 
 and 
, respectively. Then(19)
 
 
 is the maximally entangled state in 
. We use 
 to indicate the composed auxiliary system with state space 
. Then putting all of the entangled states together yields:(20)
 
 which is a density operator in 
.

Now for each program 
, completeness of qTD ensures that:
⁎
 where 
 is the identity super-operator on 
. Applying rule (R.PC.P), we obtain:
 
⁎
 
 or simply,(21)
 where:(22)
 
⁎

We further define a super-operator 
 on 
 as follows:(23)
 
 
 
 for every density operator ρ in 
. It is easy to see that 
 is well-defined and is completely positive and trace non-increasing. Moreover, we observe:

Fact 5.1

⁎
 
⁎
 
 
⁎
 where 
 is the identity super-operator on 
 and 
 the identity operator on 
.

The proof of this fact involves some tedious calculations, we omit them here, but the reader can find them in the expanded version of this paper [40].

Now we can apply (R.SO) with completely positive and trace non-increasing super-operator 
 on 
 to (21) and obtain:
⁎
⁎
 or by Fact 5.1 equivalently,(24)
 
 
⁎
 
 Therefore, applying rules (R.TI) and (R.Lin) to (24) yields:
 
⁎
 as we desired. This complete the proof of Claim 5.1.

Step 2: Our second step is to generalize Claim 5.1 to the case of  with a general .

Claim 5.2

For any pure state , we have:
⁎

Proof of Claim 5.2. For each , assume 
 is an orthonormal basis of 
. We first define a sequence 
 of projectors in 
, the state Hilbert space of the whole program, as follows:
 where: 
  We further define:
 It is obvious that for all , 
 has a finite rank, and therefore, the reduced density operator of 
 on each 
 also has a finite rank and the norm of 
 is less than or equal to 1. Thus we can use Claim 5.1 to derive that(25)
⁎
 Moreover, we observe:

Fact 5.2

(26)
⁎
⁎

For readability, we omit the proof of this fact here, but the reader can find it in the expanded version of this paper [40].

Now we can apply rule (R.Lim) to equation (25) and then use Fact 5.2 to derive:
⁎
 as we desired. This completes the proof of Claim 5.2.

Step 3: Our final step is to deal with a general quantum predicate B.

Claim 5.3

For any quantum predicate B, we have:
⁎

Proof of Claim 5.3. For any quantum predicate B, we can always diagonalize it as follows: 
 
 with 
 being a pure state and 
 for all i (spectral decomposition). Let us set:
 
 for every . Then with Lemma 5.2, we see that for each i,(27)
⁎
 Applying rule (R.CC) to (27) yields:
 
⁎
 
 or simply,(28)
 where:
 
⁎
⁎
 Note that 
 is an increasing sequence with respect to Löwner order. Then we have 
. and 
⁎
. Therefore, applying rule (R.Lim) to (28) yields
⁎
 and we complete the entire proof. □

5.1.2. Partial correctness
Now we turn to deal with partial correctness. Different from the usual, partial correctness in our case is harder to handle than total correctness. We have to strengthen rule (R.PC.P) to (R.PC.SP) and introduce two rules for reasoning about abortion and termination of disjoint parallel programs. They are presented in Fig. 12. Rule (R.A.P) is designed for reasoning about the Abortion of Parallel program 
 from the abortion of its components 
, and rule (R.T.P) is given for proving the Termination of Parallel programs. It is worth comparing rule (R.PC.P) with its Strengthened version (R.PC.SP) carefully. The precondition 
 of the conclusion of rule (R.PC.P) is weakened in rule (R.PC.SP). The precise is that certain abortion and termination conditions are added into the premise. It is particularly interesting to see that cut of 
 between 
 and 
 happens in the premise of (R.PC.SP), and thus 
 does not appear in the conclusion. It is also interesting to note that the postcondition of the conclusion of rule (R.PC.SP) is the same as that of (R.PC.P) and thus is a product quantum predicate, but the precondition can be entangled.

Fig. 12
Download : Download high-res image (41KB)
Download : Download full-size image
Fig. 12. Rules for Partial Correctness of Disjoint Parallel Programs. In this rules, Ii is the identity operator on 
 for each i, and 
 the identity operator on 
.

Let proof systems qPD (quantum Hoare logic for partial correctness defined in Fig. 3) be extended with the parallel composition rule (R.PC.SP) for tensor products of quantum predicates and appropriate auxiliary rules: Then qPPA is (relatively) complete for total correctness of disjoint parallel quantum programs:

Theorem 5.2 Completeness for partial correctness

For any disjoint quantum programs 
 and quantum predicates :

Proof

The proof of this theorem is similar to that of Theorem 5.1, but the calculation is much more involved. We omit its details, but the reader can find them in the expanded version of the paper [40]. □

Remark 5.1

1.
The rule (R.A.P) in the proof system qPP is actually a special case of (R.PC.SP) with 
〚
〛
⁎
 and 
〚
〛
⁎
.

2.
Note that assertions 
 and 
 appear in the premise of rule (R.PC.SP). As pointed out in Remark 2.1, the first assertion can be verified in qPD, and the second can be verified in qTD but not in qPD. So, qPP is only complete relative to a theory about termination assertions , which is a sub-theory of qTD.

5.2. Completeness of the method of entanglement transformation
In this subsection, we present a (relatively) complete proof system using the method of entanglement transformation.

5.2.1. Partial correctness
Let us start from partial correctness and define: The verification of disjoint parallel quantum programs using qPPE is fundamentally different from that using qPPA defined in the above subsection. Whence the precondition or postcondition for a disjoint parallel quantum program are entangled, as discussed in Subsection 4.6, we can use rule (R.S2E) to transform the verification problem to verification of the same program but with a separable precondition and postcondition, which can be dealt with by (R.PC.SP) together with (R.CC.1) and (R.CC2). It turns out that this method is also complete; that is, we have:

Theorem 5.3 Completeness for partial correctness

The proof system qPPE is (relatively) complete for partial correctness of disjoint parallel quantum programs.

Proof

We only need to prove that for any disjoint quantum programs 
 and quantum predicates :
 Assume that 
. We write 〚
〛 for the semantic function of 
. Then by Lemma 1 in [39] we have 
⁎
⁎
, and by rule (R.Or) it suffices to show that(29)
⁎
⁎
 Here, 
⁎
 stands for the dual of  (see [38], Definition 4.1.4). In what follows, we prove Eq. (29) in four steps, gradually from a special form of B to a general B. Note that since 
 are disjoint, we have 
, where for each , 
 is the semantic function of 
.

1.
Let 
 be a product predicate, where 
 acts on 
. Then from the completeness of qPD for quantum while-programs, we obtain for each i, 
⁎
⁎
. Furthermore, we know both 
⁎
 and 
⁎
 by definition. Thus, it follows that
 
⁎
 
⁎
 
 from (R.PC.SP). Then we obtain Eq. (29) from the fact that 
⁎
⁎
 and 
⁎
⁎
.

2.
Let 
 be a separable predicate, where 
 and 
. Then we have:
⁎
 
 
⁎
 and Eq. (29) follows from Step 1 and rules (R.CC.1) and (R.CC.2).

3.
Let B be a quantum predicate supported on a finite dimensional subspace of 
. Then from Theorem 4.1, there exists  such that  is separable. Then from Step 2, we obtain:
⁎
⁎
 and Eq. (29) follows from (R.S2E), since
⁎
⁎
⁎
⁎

4.
Finally, let B be a general quantum predicate in 
. For any integers  and , let 
 and 
 be a subspace of 
 such that 
 and 
. Let 
 be the (finite dimensional) projection onto the space 
. Then obviously, we have 
 and 
⁎
⁎
, and Eq. (29) follows from Step 3 and rule (R.Lim). □

5.2.2. Total correctness
To deal with total correctness using entanglement transformation, rule (R.S2E) needs to be slightly modified as:
⁎
 
 It is clear that the only difference between rules (R.S2E⁎) and (R.S2E) is the abortion condition added in the premise of the former.

Now we define proof system: It is easy to check that rule (R.S2E⁎) and thus qTPE are sound. Furthermore, we have:

Theorem 5.4 Completeness of total correctness

The proof system qTPE is (relatively) complete for total correctness of disjoint parallel quantum programs.

The proof of this theorem is similar to that of Theorem 5.3.

Remark 5.2

It is worth noting that rule (R.S2E⁎) can localized in the precondition to:
 
 so that the (relative) completeness is still true.

6. Conclusion
As the first attempt to develop a theory of parallel quantum programming, this paper defines the operational and denotational semantics of disjoint parallel quantum programs. In particular, two methods for verification of disjoint parallel quantum programs with possible entanglement in pre/postconditions are proposed, namely the method of auxiliary variables and the method of entanglement transformation. For each of these methods, a (relatively) complete proof system is established.

This paper is certainly merely one of the first steps toward a theory of parallel quantum programming. One of the most important and difficult open problem is to define a (relatively) complete logic for verification of parallel quantum programs with shared variables. The key is to find a generalization of rule (R.PC) for parallel quantum programs with shared variables. A possible candidate for such a rule would be based on the notions of join and margin of operators: let 
 and  be a family of subsets of . For each , given a positive operator 
 in 
. If positive operator A in  satisfies: 
 for every , where 
, then A is called a join of 
, and each 
 is called the margin of A in 
. Then we can conceive an inference rule for parallel composition of quantum programs with shared variables as shown in Fig. 13.

Fig. 13
Download : Download high-res image (23KB)
Download : Download full-size image
Fig. 13. Rule for Parallel Quantum Programs with Shared Variables.

As pointed out before, the logic presented in this paper can be used in formal verification of some interesting parallel quantum algorithms, including Bravyi-Gosset-König parallel quantum algorithm [8] solving HLF (Hidden Linear Function). A wider field of applications of this logic is possibly verification of quantum communication and cryptographic protocols, which can be modeled as a distributed system consisting of several disjoint programs. A typical example is quantum teleportation, where Alice (the sender) and Bob (the receiver) can be seen as two disjoint quantum programs. But obviously, our logic cannot be directly applied to these protocols because all of them involve either communicating classical or quantum information. Therefore, another interesting problem for future research is to extend logic for reasoning about distributed systems with classical and quantum communication primitives.