Abstract
The one-visibility cops and robber game is a variation of the classic cops and robber game, where one-visibility means that the information of the robber is known to all cops only when the distance between the robber and at least one cop is at most one. In this paper, we give a lower bound on the one-visibility copnumber of general trees. We present strategies to clear trees according to their structures. We propose a linear-time algorithm for computing the one-visibility copnumber of trees.

Keywords
One-visibility cops and robber
Cops and robbers
Cop number

1. Introduction
Graph searching provides mathematical models of many real-world problems. It is also linked with various graph parameters in literature such as treewidth, pathwidth, and cutwidth. It can give deep insight into graph structures.

The cops and robber game was introduced by Nowakowski and Winkler [7] and Quilliot [8] independently. As a major model in the area of graph searching, it has received much attention in recent years. In this game, the cops and robber occupy only vertices, and they move alternatively to their neighbours. Both opponents have full information about each other's location as well as the structure of the graph. The cops move through the graph attempting to capture the robber, while the robber moves to avoid the cops. A broad overview of many graph searching models are given in [2] and many aspects of the cops and robber game can be found in [1].

The zero-visibility cops and robber game was introduced by Tošić [10], which can be considered as a hybrid of the cops and robber game [7], [8] and the edge searching model [6]. Like the cops and robber game, the cops and robber take turns alternatively and each individual moves from the current vertex to one of its neighbours. Like the edge searching model, the robber is invisible. Tošić [10] characterized the zero-visibility cop-win graphs for paths, cycles, complete graphs, and complete bipartite graphs. Dereniowski et al. [4] established a relationship between the zero-visibility copnumber and the pathwidth of a graph. They introduced a monotonic version of the zero-visibility cops and robber model, and gave an upper bound and a lower bound on the monotonic zero-visibility copnumber. Tang [9] gave a quadratic time algorithm for computing the zero-visibility copnumber of trees. Dereniowski et al. [5] improved it by presenting a linear-time algorithm. They also proved that the problem of determining the zero-visibility copnumber of a graph is NP-complete. Recently, Xue et al. [12] proposed a partition method for proving lower bounds for the zero-visibility cops and robber game. They also investigated the monotonic zero-visibility copnumber of graph products. Xue et al. [11] gave lower bounds and upper bounds on the zero-visibility copnumber of graph joins, lexicographic products of graphs, complete multipartite graphs and split graphs.

In [3], Clarke et al. considered a variation of cops and robber game, called the ℓ-visibility cops and robber game. This game has the same setting as the cops and robber game except that the cops have the information about the location of the robber only when the distance between the cops and the robber is less than or equal to ℓ. There are two sub-tasks for cops: seeing and capturing. In the first phase, the cops move within the distance ℓ of the robber and in the second phase, they capture the robber. They used classes of subtrees to characterize the trees for which k cops can capture the robber for all . Since each of those classes contains exponential number of trees, their characterization is not suitable for designing polynomial time algorithms that can find the minimum number of cops to capture the robber for any . When , the game is called the one-visibility cops and robber game, which was considered in [14].

In this paper, we investigate the one-visibility cops and robber game on trees. In section 3, we give an essential theorem on the lower bound of the copnumber for general trees. In Section 4, we present search strategies. In Section 5 we propose a linear-time algorithm for computing the one-visibility copnumber of trees. This bottom-up algorithm allows us to find the copnumber of all rooted subtrees of a rooted tree. Finally, we conclude the paper in Section 6.

2. Preliminaries
Let G be a graph. The vertex set of G is denoted by . Let . If u and v are joined by an edge, we say that u and v are adjacent or u and v are neighbours. We use uv to denote an edge with endpoints u and v. Similarly, we use 
 to denote a path with end vertices 
 and 
. The length of a path is the number of edges on the path. The distance between u and v, denoted by 
, is the length of the shortest path between u and v in G. Let H be a subgraph of G. The distance between u and H is defined to be
≔
 Let . The distance between u and U can be defined similarly. The neighbourhood of v is the set 
≔
. The closed neighbourhood of v is the set 
≔
. For , we generalize this concept to the k-th closed neighbourhood of v, which is the set
≔
 The closed neighbourhood of U is defined as the set 
. If there is no ambiguity, we omit the subscript G and simply use , 
, , etc.

The degree of v is the number of edges incident upon v, denoted 
. A leaf is a vertex that has degree one. For , we use  to denote the subgraph induced by U, which consists of all vertices of U and all of the edges that connect vertices of U in G. We use  to denote the subgraph . If U contains a single vertex u, then for simplicity, we use  for . Let 
 be a subset of edges of G. Similarly, we use 
 to denote the subgraph obtained from G by deleting all edges of 
 from G.

A rooted tree is a tree where a single vertex is marked as the root. Let 
 denote a rooted tree T with root r. Every vertex  of the tree is connected with r by a unique path, where the parent of v is the sole neighbour of v in this unique path. If u is the parent of v, then v is a child of u. For a vertex 
, if a vertex a is on the unique path from r to v, then we say that v is a descendant of a, and a is an ancestor of v. For a vertex 
, we will use 
 to denote the subtree of 
 induced by v and all its descendants, where v is the root of this subtree. We will extensively use the notation of 
 in Section 5 to denote the forest induced by 
, where 
 is a rooted subtree of 
. Note that each component in the forest 
 is rooted at a vertex that is a child of v in 
.

The one-visibility cops and robber game is played on a graph by two players: cop player and robber player. The cop player controls a set of cops and the robber player controls a single robber. The robber has full information about the locations of all cops, but the cops have the information about the location of the robber only when there is a cop whose distance to the robber is at most one. The game is played over a sequence of rounds. Each round consists of a cops' turn followed by a robber's turn. At round 0, the cops are placed on a set of vertices and then the robber is placed on a vertex. At each of the following rounds, the cops move first and the robber moves next. At round i, , each cop either moves from the current vertex to a neighbouring vertex or stays still, then the robber does the same. The cops see the robber if the closed neighbourhood of the cops contains the robber. The cops capture the robber if one of them occupies the same vertex as the robber. If this happens in a finite number of rounds, then the cops win; otherwise, the robber wins. The one-visibility copnumber of a graph G, denoted by 
, is the minimum number of cops required to capture the robber on G.

Throughout the paper, we assume that both cops and the robber play optimally, which means that the cops want to capture the robber as soon as possible while the robber wants to make the number of rounds of the game as large as possible.

We say that a cop vibrates between two adjacent vertices x and y for a consecutive sequence of rounds if in these rounds, the cop alternates two actions: “sliding from x to y” and “sliding from y to x”. A subgraph known to not contain the robber is called cleared; otherwise, the subgraph is contaminated.

An example of playing one-visibility cops and robber game is given in Fig. 1, where 
 is a rooted tree formed by the solid edges and 
 is a rooted tree formed by the solid edges and the dotted edge. Let us consider 
 first. It is easy to see that one cop cannot capture the robber on 
; so 
. But it is probably not obvious for two cops to capture the robber on 
. Let 
 and 
 be two cops. Here is a cop-win strategy for 
. We first place 
 on the great-grandchild of a in the leftmost branch of a. This cop does not need to visit the adjacent leaf because it is visible to him. Then 
 moves to a and clear all the vertices on the path. We now consider the middle branch of a. If 
 moves to the great-grandchild of a in the middle branch of a, then a is unattended for two consecutive rounds and the robber can pass through a to the cleared branch. Thus we need another cop to guard the cleared branch. We place 
 on a and use 
 to clear all the descendants of a in the middle and the rightmost branches. Then both 
 and 
 move to r along the path . We now consider the rightmost branch of r. Let 
 vibrate between the child and grandchild of r in the rightmost branch of r to guard the cleared zone while 
 moves to c. Then 
 clears the descendants of c in the leftmost branch of c. After that, 
 vibrates between the child and grandchild of c in the rightmost branch of c to guard the cleared zone and to clear the rightmost branch of c. Then 
 clears the middle branch of c and return to r. Now both 
 and 
 move towards b and clear all descendants of b. Hence two cops can clear 
, and therefore 
. For 
, it is easy to see that 
. But to show 
, we need the lower bound theorem in the next section.

Fig. 1
Download : Download high-res image (30KB)
Download : Download full-size image
Fig. 1. 
 and 
.

3. Lower bound on 
Let T be a tree and H a subtree of T. The following observation is implied by Corollary 2.2 in [3].

Observation 3.1

For a tree T and a subtree H of T, 
.

Note that this observation does not hold for general graphs. For example, for any integer , we can apply Theorem 3.4 in this section to construct a tree T with 
, but for any complete graph 
 (with ), we have 
.

Similarly to Lemma 4.4 in [3], we can prove the following result for general trees.

Lemma 3.2

Let T be a tree and . Let H be a component in the forest . If 
, then in any cop-win strategy to clear T, there is a moment at which at least k cops are located on 
.

Proof

Let u be the unique neighbour of v in H, and let 
 be the subtree obtained by adding the vertex v and edge uv to H. Note that 
. Assume, for the sake of contradiction, that there is a cop-win strategy 
 for clearing T such that at any moment there are at most  cops on 
. We construct a pseudo strategy S to clear 
 as follows: In 
, whenever a cop is initially placed in 
, in S we place the corresponding cop on the same vertex. In 
, whenever a cop moves within 
, in S the corresponding cop has the same action in 
. In 
, whenever a cop enters 
, in S we place the corresponding cop on v. In 
, whenever a cop leaves 
, in S we remove the corresponding cop from v. We can easily modify the pseudo strategy S to a cop-win strategy 
 for 
 such that the number of cops used in 
 is the same as that in S. From the assumption, at any moment in S there are at most  cops on 
. So 
 can be cleared by 
 using at most  cops. It follows from Observation 3.1 that H can be cleared by at most  cops. Thus 
, which is a contradiction. □

Let T be a tree and let S be a cop-win strategy that clears T in m rounds. Recall that a vertex v is contaminated at some moment if v is occupied by the robber or the cops do not know if the robber is on v at the moment. Let 
, , be the set of contaminated vertices of T before the cops' move in round i, let 
, , be the set of contaminated vertices of T just after the cops' move in round i, and let 
, , be the set of vertices of T occupied by cops after the cops' move in round i. In the next lemma we show that the set of contaminated vertices is not far away from the set of vertices occupied by cops.

Lemma 3.3

Let T be a tree and let S be a cop-win strategy that clears T in m rounds. Then

(i)
for every component H of 
, , there is a vertex 
 such that 
; and

(ii)
for every component H of 
, , there is a vertex 
 such that 
.

Proof

Let 
, , be the set containing a single vertex that is occupied by the robber after the robber's move in round i. At round 0, cops are placed on vertices of 
, and then the robber is placed on the vertex in 
. So at round 1, 
, and thus, statement (i) holds. Since every cop can move to a neighbouring vertex or stays still, it is easy to see that statement (ii) also holds. Suppose both statements hold at round i. We will show that both of them are true at round .

At round , we have 
. Let H be a component of 
. Since 
, there exists a component 
 in 
 such that 
 is a subgraph of H. By the assumption, there is 
 such that 
. If 
, then 
. If 
, then there is a vertex 
 such that 
, and thus 
. Hence 
 and so statement (i) is true. Just after the cops' move at round , we have 
. Let H be a component in 
. Since 
, there is a component 
 in 
 such that H is a subgraph of 
. By the above, there is 
 such that 
. Then for any vertex 
, 
. Thus statement (ii) is true. □

From the above two lemmas, we can show an essential theorem of this section, which can be considered as an extension of Theorem 4.9 in [3] for general trees in the one-visibility cops and robber game.

Theorem 3.4

Let T be a tree and let k be a positive integer. If there is a vertex  such that the forest 
 contains at least three components with copnumber at least k and the path in T connecting any pair of these three components contains v, then 
.

Proof

Let 
, 
 be three components in 
 with 
, . For , let 
 such that 
. Let 
 be a subtree of T which is formed from the disjoint union of 
, , together with the paths of length four from 
 to v (see Fig. 2). For the sake of contradiction, assume 
 can be cleared by k cops. Then there is a round 
 such that just after the cops' move in this round, only one of the three components, say 
, is cleared and it remains cleared until the end of the game. There is also a round 
 such that just after the cops' move, one of the other two components, say 
, is cleared. Since 
, from Lemma 3.2, there is a round 
 between 
 and 
 such that at the moment 
⁎
 just after the cops' move in round 
, all k cops are simultaneously present in 
. As 
 is contaminated at 
⁎
 and 
, by Lemma 3.3, v is contaminated at 
⁎
. So the robber will recontaminate 
, which derives a contradiction. Therefore 
. It follows from Observation 3.1 that 
. □

Fig. 2
Download : Download high-res image (19KB)
Download : Download full-size image
Fig. 2. T1 consists of X1,X2, X3 and the paths to v.

4. Cop-win strategies on trees
In this section, we first define three basic structures of trees in terms of hub, avenue vertex, and street vertex. We prove that every tree contains exactly one of these three structures. We then give cop-win strategies relying upon these structures.

Note that when the one-visibility cops and robber game is played on a tree, if the robber is seen by a cop at some moment, then the robber can be captured by this cop in a finite number of rounds.

Definition 4.1

Theorem 4.2

Every tree contains a hub, an avenue vertex, or a street vertex.

Proof

Let T be a tree with 
. If there is a vertex v in T such that 
 is empty, then 
 and v is a hub of T. Suppose that there is no vertex v in T such that 
 is empty.

If there is a vertex v such that each component in 
 has copnumber less than k, then by Definition 4.1 v is a hub.

If T does not have a hub, then for every vertex v in T, 
 must contain at least one component of copnumber k. If there is a vertex v such that 
 has three components with copnumber k and the path in T connecting any pair of these three components contains v, then, by Theorem 3.4, 
. This is a contradiction as 
.

If there is a vertex u such that 
 has two components of copnumber k and the path between them contains u, then from Definition 4.1, u is an avenue vertex.

Suppose that T has neither a hub nor an avenue vertex. Let v be an arbitrary vertex in T. Then 
 has at least one component of copnumber k, but it does not have two components with copnumber k such that the path between them contains v. So all components with copnumber k in 
 must be subgraphs of the same component in the forest . Let 
 be a neighbour of v such that all components with copnumber k in 
 be subgraphs of the component in  which contains 
. This component is denoted by 
 which is associated with the edge 
. Since the number of vertices in T is one more than that of edges, by the pigeonhole principle there must exist at least one edge xy that is associated with two components 
 and 
. Thus 
 contains a set 
 of components with copnumber k such that the path in T between any pair of components from 
 does not contain x; similarly, 
 contains a set 
 of components with copnumber k such that the path in T between any pair of components from 
 does not contain y. Note that the components in 
 and 
 are subgraphs of components in 
. Hence 
 has two components with copnumber k, where one is a supergraph of a component in 
 and the other is a supergraph of a component in 
, such that the path in T connecting them contains x. From Definition 4.1, x is a street vertex. Similarly, y is also a street vertex. □

From Definition 4.1 and the proof of Theorem 4.2, every tree has the following property.

Corollary 4.3

Every tree contains exactly one of the three kinds of vertices: (i) hubs, (ii) avenue vertices, and (iii) street vertices.

Lemma 4.4

If a tree contains hubs, then the subgraph induced by all hubs of the tree is connected.

Proof

Let T be tree with 
 and let 
 be the set of all hubs of T. Suppose 
 is not connected and 
 and 
 are two vertices of 
 in two different components of 
. Then there is a vertex 
 on the path in T connecting 
 and 
. Since each component in 
, , has copnumber less than k, we know that 
 cannot contain a component with copnumber k. So u is a hub of T. This is a contradiction. Thus 
 is connected. □

We now describe a cop-win strategy to clear a tree that contains a hub.



Download : Download high-res image (82KB)
Download : Download full-size image
Lemma 4.5

Let T be a tree which has neither a hub nor an avenue vertex. Then T has exactly two street vertices, and they are adjacent to each other.

Proof

Let 
. Since T has neither a hub nor an avenue vertex of T, from the proof of Theorem 4.2, there is at least one edge whose endpoints are street vertices of T. Following that proof, suppose there exist two edge 
 and 
 such that each 
, , is a street vertex of T and the path between 
 and 
 in T contains 
 and 
. From Definition 4.1, 
 has two components with copnumber k such that the path in T connecting them contains 
; similarly, 
 has two components with copnumber k such that the path in T connecting them contains 
. Thus 
 has two components with copnumber k such that the path in T connecting them contains 
. Hence 
 is an avenue vertex of T, which is a contradiction. So there is only one edge whose endpoints are street vertices of T. □

The edge whose endpoints are street vertices of T is called a street of T.

Lemma 4.6

Suppose that T is a tree with 
 and uv is a street of T. Let 
 be a component in the forest  which contains a component of 
 with copnumber k. Then 
 has three properties: (i) 
 contains all components of 
 with copnumber k, (ii) u is a hub of 
, and (iii) v is a hub of 
.

Proof

Since v is a street vertex of T, from Definition 4.1, 
 has two components with copnumber k such that the path in T connecting them contains v. Thus 
 has two components with copnumber k such that the path in T connecting them contains v. Since u is not an avenue vertex of T, all components with copnumber k in 
 must be contained in one component in the forest , which must be 
. Therefore, the forest 
 does not have any component with copnumber k.

Since u is a street vertex of T, 
 has at least two components with copnumber k such that the path in T connecting them contains u. So 
 has at least one component with copnumber k, and thus 
. Hence u is a hub of 
. Similarly, we can define 
, and symmetrically, v is a hub of 
. Note that 
. Therefore, v is a hub of 
. □

From Lemma 4.6, we have the following cop-win strategy to clear a tree that contains a street.



Download : Download high-res image (60KB)
Download : Download full-size image
In the next lemma, we show that the subgraph induced by avenue vertices is a path.

Lemma 4.7

Let A be the set of all avenue vertices of a tree T. Then  is a path.

Proof

Let 
. Suppose that  is not connected. Let 
 and 
 be two vertices of A in two different components of . Let  be a vertex on the path in T connecting 
 and 
. From Definition 4.1, 
, , has two components with copnumber k such that the path in T connecting them contains 
. So 
 has two components with copnumber k satisfying that the path in T connecting them contains u. Thus, u is an avenue vertex, which is a contradiction. Hence  is connected.

Suppose there is a vertex  that has at least three neighbours in A. Then 
 has at least three components with copnumber k such that the path in T connecting any two of them contains v. It follows from Theorem 3.4 that 
. This is a contradiction. Thus  does have a vertex of degree more than two. Therefore  is a path. □

The path  in Lemma 4.7 is called the avenue of T.

Corollary 4.8

Let T be a tree with 
 and let 
 be the avenue of T. Then

(i)
 has a unique neighbour 
 such that 
 has two components with copnumber k satisfying that the path in T connecting them contains v.

(ii)
v is a hub of 
⁎
, where 
⁎
 is a component in  that contains the avenue.

Proof

(i) As 
 is an avenue vertex, by Definition 4.1, 
 has two components 
 and 
 with copnumber k such that the path in T connecting them contains 
. Without loss of generality, suppose that 
 is on the path connecting 
 to 
. Let v be a neighbour of 
 on the path connecting 
 to 
. So 
 is also a component in 
. Note that 
 has a component that contains 
 as a subtree. Let this component be denoted by 
. So 
 has two components, i.e., 
 and 
, with copnumber k such that the path in T connecting them contains v. If 
 has another neighbour 
 such that 
 has two components with copnumber k such that the path in T connecting them contains 
, then from Theorem 3.4, 
. This is a contradiction. Thus v is unique to have the property.

(ii) Note that v is not an avenue vertex. So for any two components with copnumber k in 
, the path in T connecting them does not contain v. So every component with copnumber k in 
 is a subtree of 
⁎
. Hence 
⁎
 does not contain any component with copnumber k. Since 
⁎
 contains the component 
 with copnumber k, we have 
⁎
. Therefore v is a hub of 
⁎
. □

The vertex v in Corollary 4.8 is called a pre-avenue vertex of T. If a tree has an avenue, then it has exactly two pre-avenue vertices, each of which is adjacent to an end vertex of the avenue.

From Lemma 4.7 and Corollary 4.8, we have the following cop-win strategy to clear a tree that contains an avenue.



Download : Download high-res image (95KB)
Download : Download full-size image
5. Algorithm for computing 
In this section, we give a linear-time algorithm for computing the one-visibility copnumber of trees.

5.1. Definitions and notations
We first define
⁎
 It is easy to see that if G is connected, 
⁎
.

For simplicity, we will use 
 for 
, which is the forest obtained from the rooted tree 
 by deleting the vertices of 
. Similarly, if there is no ambiguity we will simply use  and 
 without subscripts.

Definition 5.1

(k-pre-branching, k-weakly-branching, k-branching) Let 
 be a rooted tree with 
. We call v a k-pre-branching vertex if 
⁎
 and 
, where 
 is a tree obtained from two copies of 
 by connecting each root v to a new root u.

We call v a k-weakly-branching vertex if one of the three forests, 
, or 
, or 
, has exactly two components whose root is a k-pre-branching vertex in the component.

We call v a k-branching vertex if 
⁎
, the forest 
 has exactly one component whose root is a k-weakly-branching vertex in the component, and the forest 
 has no component whose root is a k-weakly-branching vertex.

Let u be a child of v in 
. If u is a k-pre-branching vertex (resp. k-weakly-branching vertex, k-branching vertex) in 
, then we say that u is a k-pre-branching child (resp. k-weakly-branching child, k-branching child) of v. Similarly, we can define the k-pre-branching descendant, k-weakly-branching descendant, and k-branching descendant of v.

Definition 5.2

Let 
 be a rooted tree with 
. The k-pre-branching indicator 
 and the k-weakly-branching indicator 
 are defined to be:
 
 

Definition 5.3

Let 
 be a rooted tree with 
. The k-initial-counter 
 and the k-weakly-counter 
 are defined as follows:
⁎
⁎
⁎
⁎
⁎
 
 

Definition 5.4

(label 
, value 
) Let 
 be a rooted tree. The label of v in 
, denoted by 
, is a sequence
 where 
 and 
 are defined in the following procedure:

1.
If 
 contains only one vertex, then 
, 
, 
, and return 
; otherwise, set  and 
.

2.
Set 
. Then we have one of the following cases:

(a)
If v is an 
-branching vertex in 
, then 
, and return 
.

(b)
If v has an 
-branching descendant in 
, let 
 be this vertex. Set 
, , and go back to Step 2.

(c)
If v is an 
-weakly-branching vertex in 
, then 
, 
, and 
 can be determined by Definition 5.3; return 
.

(d)
If v is an 
-pre-branching vertex in 
, then 
, and 
; return 
; .

(e)
, and 
 can be determined by Definition 5.3; return 
.

The value of 
, denoted by 
, is equal to 
. Note that 
.
If there is no ambiguity, we simply use  for 
. In Algorithm 1, we will compute the copnumber of subtrees in the reverse order 
. For convenience, in the rest of the paper we let 
 and 
; i.e.,
 where the superscript v in 
 and 
 are used to refer to the vertex v. So it follows from Definition 5.4 that 
. Note that only 
 can be a “⊥” sign, which means that neither v is an 
-branching vertex in 
 
 nor it has an 
-branching descendant in 
 
. We call the first pair 
 an item associated with 
, and call each pair 
, , an item associated with subtree 
 
. For each item 
, , 
 is called the key of the item and 
 is its attribute.

Algorithm 1
Download : Download high-res image (340KB)
Download : Download full-size image
Algorithm 1. Computing the one-visibility copnumber of a tree

We explain labels with the following example.

Example 5.5

Consider the tree in Fig. 7(a). Suppose that v is the root and 
. From Definition 5.3, we have 
 and 
. It follows from Definition 5.1, Definition 5.2 that 
 and both 
 and 
 are k-pre-branching vertices with label . Note that 
 is also a k-pre-branching vertex with the same label. The vertex w is a k-weakly-branching vertex since there are exactly two components in the forest 
 such that each of the two components is rooted at a k-pre-branching vertex. From Definition 5.3, we have 
 and 
. It follows from Definition 5.1 that the vertex v is a k-branching vertex as it has a k-weakly-branching child y and 
.

Fig. 7
Download : Download high-res image (100KB)
Download : Download full-size image
Fig. 7. Labels of vertices.

In Fig. 7(b), suppose that v is the root and 
; . From Definition 5.1, 
 and 
 are k-branching vertices with labels 
 and 
 respectively. As w has two k-branching children 
 and 
, it follows from Theorem 3.4 that the label of w is . Hence, from Definition 5.1, Definition 5.2, v is a -pre-branching vertex with label .

Definition 5.6

Let 
 be a tree with root u whose children are 
. Suppose 
⁎
. The counters 
, 
, 
, 
 and 
 are defined as follows:
 
 

5.2. The linear-time algorithm
Before we describe the linear-time algorithm for computing the one-visibility copnumber of trees, we show that the labels in Definition 5.4 have the following properties.

Theorem 5.7

Let 
 be a tree with root u whose children are 
. Suppose that 
⁎
 and for ,(1)
 Then the label 
 can be determined as follows:

(1)
If 
, then 
.

(2)
If 
 and 
, then 
; .

(3)
If 
, 
 and 
, then

(3.1)
if 
, then 
.

(3.2)
if 
 and 
, then 
.

(3.3)
if 
 and 
, then 
.

(3.4)
if 
 and 
, then 
.

(3.5)
if 
 and 
, then 
.

(4)
If 
 and 
, then

(4.1)
if 
, then 
.

(4.2)
if 
, then 
.

(4.3)
if 
, then 
.

(5)
If 
, then

(5.1)
if 
, then 
.

(5.2)
if 
, then 
.

(5.3)
if 
, then 
.

(5.4)
if 
, then

(5.4.1)
if 
, then 
.

(5.4.2)
if 
, then 
.

(5.4.3)
if 
, then 
.

Proof

(1) Since 
, we can suppose that 
. For each , from Definition 5.1, 
, 
, or 
 has exactly two components whose root is a k-pre-branching vertex in the component. Let w on 
 be the parent of the two roots of these two components. Thus, in the forest 
, there are at least three components with copnumber k and the path in T connecting any pair of these three components contains w. It follows from Theorem 3.4 that 
. Note that each 
 contains ⊥ (see Eq. (1)), we know that u does not have a descendant that is a k-branching vertex. Since 
⁎
, we can clear 
 by stationing one cop on u and using the other k cops to clear each component with copnumber at most k. Thus 
. Since u and all its descendants are not k-branching, we have 
. Note that neither u is -weakly-branching nor it has a -weakly-branching descendant. So 
 and 
. Similarly, we have 
 and 
. Hence 
.

(2) Since 
 and 
, we can suppose that 
 and 
. From Definition 5.1, 
, 
, or 
 has exactly two components whose root is a k-pre-branching vertex in the component. Let w on 
 be the parent of the two roots of these two components. Similarly to Case (1), in the forest 
, there are at least three components with copnumber k and the path in T connecting any pair of these three components contains w. From Theorem 3.4, we have 
. Similarly to Case (1), we can use  cops to clear T. Thus 
.

(3) Since 
, 
 and 
, in the forest 
, there is exactly one component whose root is a k-weakly-branching vertex. W.l.o.g., suppose that 
 is the k-weakly-branching vertex in 
 and 
 is a child of u with 
.

(3.1) If 
, from Definition 5.3, Definition 5.6, we know 
 and 
⁎
, and further, there is exactly one component in the forest 
 such that the root of this component is a k-weakly-branching vertex in the component. Let w be this k-weakly-branching vertex. From Definition 5.1, we know 
 has at least two components with copnumber k. Furthermore, since 
, 
 has at least three components with copnumber k and the path in T connecting any pair of these three components contains w. From Theorem 3.4, we have 
. Note that we can use  cops to clear T by Hub-Strategy. Thus 
. Similarly to Case (1), we have 
 and 
. Thus 
.

(3.2) If 
 and 
, from Definition 5.3, Definition 5.6, we know 
 and 
⁎
. So there is exactly one component in the forest 
 such that the root of this component is a k-weakly-branching vertex in the component. Let w be this k-weakly-branching vertex (see Fig. 8). From Definition 5.1, we know 
 has at least two components with copnumber k. Since 
 and 
, we know that 
 has at least three components with copnumber k and the path in T connecting any pair of these three components contains w. Thus 
. Similarly to Case (3.1), we have 
.

Fig. 8
Download : Download high-res image (73KB)
Download : Download full-size image
Fig. 8. A tree T[u] with 
, where 
 and 
.

(3.3) If 
 and 
, similarly to Case (3.2), there is exactly one component in the forest 
 such that the root w of this component is a k-weakly-branching vertex in 
 (see Fig. 9). So 
 has two components with copnumber k. Since 
 and 
, we have 
. Note that 
, which implies that 
 has exactly two components with copnumber k. So there is an avenue of 
 that contains w. Note that 
. By Avenue-Strategy, we can use k cops to clear 
. So 
. Since there is no k-branching vertex in 
, it is easy to see that 
. Since 
 and 
, we have 
, 
, 
 and 
. Therefore 
.

Fig. 9
Download : Download high-res image (77KB)
Download : Download full-size image
Fig. 9. A tree T[u] with 
, where 
 and 
. Note that w is an avenue vertex and x1,x2 are pre-avenue vertices of T[u].

(3.4) Similarly to Case (3.2), we have 
.

(3.5) Similarly to Case (3.3), we can show 
.

(4.1) Since 
, 
 and 
, we can suppose that 
. Then 
, 
⁎
 and there is exactly one component in the forest 
 such that the root say w, is a k-weakly-branching vertex in that component. So 
 has exactly two components with copnumber k. As 
, the forest 
 has only two components with copnumber k. Similarly to Case (3.3), we can clear 
 with k cops. Thus 
. Since 
⁎
 and there is exactly one component in the forest 
 whose root w is a k-weakly-branching vertex, we have 
. From the structure of 
, we have 
. Thus 
.

(4.2) Similarly to Case (3.3), we have 
.

(4.3) Similarly to Case (3.3), we can show 
.

(5.1) Suppose that 
 and 
. W.l.o.g., suppose that 
 and 
 are k-pre-branching vertices in 
, 
 and 
, respectively (see Fig. 10). For each , from Definition 5.1, we know 
⁎
. So in the forest 
, there are at least three components with copnumber k and the path in T connecting any pair of these three components contains u. It follows from Theorem 3.4 that 
. We can clear 
 by letting one cop vibrate between 
 and 
, , and using the other k cops to clear each component 
. The  cops can also clear other components in 
. So 
. It is easy to see that 
 and 
. Thus 
.

Fig. 10
Download : Download high-res image (64KB)
Download : Download full-size image
Fig. 10. A tree T[u] with 
, where v1,v2 and v3 are three k-pre-branching children of u.

(5.2) Suppose that 
 and 
. W.l.o.g., suppose that 
 and 
 are k-pre-branching vertices in 
 and 
, respectively (see Fig. 11). So 
 has exactly two components with copnumber k. Furthermore, there is an avenue of 
 that contains u. By Avenue-Strategy, we can use k cops to clear 
. So 
. Since there is no k-branching vertex in 
, it is easy to see that 
. It follows from Definition 5.1, Definition 5.3 that 
 and 
. Hence 
.

Fig. 11
Download : Download high-res image (76KB)
Download : Download full-size image
Fig. 11. A tree T[u] with 
, where 
; 0,0;1,0) and 
.

(5.3) Suppose that 
, 
. Then there is only one child of u, say 
, which is a k-pre-branching vertex. So 
 has exactly one component with copnumber k. It is not hard to see that 
 can be cleared by k cops. Thus 
 and 
. Since there is no k-weakly branching vertex, we have 
. It follows from Definition 5.1 that 
. From Definition 5.3, 
. Therefore 
.

(5.4.1) Suppose that 
, 
 and 
. From Definition 5.6, Definition 5.3, we have 
, 
, and 
. Similarly to Case (5.3), we can show that 
 and 
. Hence 
.

(5.4.2) Suppose that 
, 
 and 
. Similarly to Case (5.4.1), we have 
, 
, and 
. From Definition 5.1, Definition 5.3 that 
 and 
. So 
.

(5.4.3) Similarly to Case (5.4.2), we have 
. □

Corollary 5.8

Let 
 be a tree with root u whose children are 
. Suppose that 
⁎
 and for ,
 If 
, then there is a vertex v in 
 such that 
 contains three components with copnumber k and the path in 
 connecting any pair of these three components contains v.

Proof

In Theorem 5.7, we have six cases where the copnumber of T is , that is, (1), (2), (3.1), (3.2), (3.4), (5.1). From the proof of Theorem 5.7, we know that for (1), (2), (5.1), we can pick the root u as the vertex v in this corollary; it is also not hard to see that for (3.1), (3.2), (3.4), we can choose the vertex w in the proof of Theorem 5.7 as the vertex v in this corollary. □

Algorithm 1 is a bottom-up approach for computing one-visibility copnumber of a tree. In this algorithm, we first assign labels to each vertex that has no children. Then for each vertex whose children have been labelled, we compute the label of this vertex using the rules proved in Theorem 5.7, Theorem 5.9, Theorem 5.10. Finally, the first component in the label of the root is the one-visibility copnumber of the tree. Recall that the label of v in 
 has the form below:(2)
 where the first pair 
 is an item associated with 
, and each pair 
, , is an item associated with subtree 
 
. Note that 
 is called the key of the item and 
 is its attribute.

Theorem 5.9

Let 
 be a rooted tree and let 
 be the children of the root u such that 
, for . Suppose that 
  where 
, 
, are 
-branching vertices of 
. Let 
 
 
.

(i)
If 
 for each 
, then 
.

(ii)
If there is at least one 
 such that 
, then 
.

Proof

(i) For 
, since 
, we can use  cops to clear 
. Let 
 
 
. Since 
, we can clear tree 
 with k cops. We now give a cop-win strategy to clear the whole tree 
 with k cops.

Case 1. Suppose that u is a hub of 
. Then u is also a hub of 
. To clear 
, we first use k cops to clear 
, and then let one cop stay on u and use  cops to clear the subtrees 
, 
.

Case 2. Suppose that u is a street vertex of 
 and 
 is the street. As 
, 
, all components in 
 with copnumber k are the components in 
. So u is also a street vertex of 
. For clearing 
, k cops first clear the subtree 
 rooted at 
 using Hub-Strategy. After that all k cops move to u to clear the subtree 
 rooted at u using Hub-Strategy.

Case 3. Suppose that u is an avenue vertex of 
. Since 
, 
, we know that u is also an avenue vertex of 
. The k cops can clear 
 using Avenue-Strategy, during which when all cops move to the vertex u on the avenue,  cops can clear each subtree 
, 
, attached to u, as 
.

Case 4. Suppose that u is not a hub, a street vertex, or an avenue vertex of 
. Assume that 
 has an avenue 
. Let 
 be the pre-avenue vertex adjacent to 
 and let 
 be the pre-avenue vertex adjacent to 
. Since u is not an avenue vertex of 
, the avenue is contained in only one component of 
. W.l.o.g., suppose that 
 contains all 
, . Since 
 and 
 contains the avenue of 
, we know that 
. Among the vertices in 
, let 
 be the closest vertex to u in 
. We now modify the Avenue-Strategy for clearing 
 to a strategy for clearing 
.

When we use the Avenue-Strategy to clear 
, there is a moment at which all k cops are located at 
. While one cop protects 
 by staying on it or its neighbour 
 between 
 and u, or visiting 
 every other turn, the other  cops can clear all components 
, 
. Since 
 is the same as components 
, 
, and 
, 
, these  cops can also clear components 
, 
. Thus k cops can clear the tree 
.

Similarly, we can show that if 
 has a hub x or a street vertex x and u is a vertex in some component of 
, we can still use k cops to clear 
.

(ii) Suppose that there is 
 such that 
. So 
 is a k-branching child of u in 
, and furthermore, 
 has a k-weakly-branching vertex, say 
, in 
. From Definitions 5.1, there are exactly two components in the forest 
 such that the root of this component is a k-pre-branching vertex. Thus in the forest 
, there exist at least three components with copnumber k. It follows from Theorem 3.4 that 
. We can clear 
 by stationing one cop on u and using the other k cops to clear each component with copnumber at most k. Thus 
. □

The following theorem is an extension of Theorem 3.4.

Theorem 5.10

Let 
 be a rooted tree and let 
 be the children of the root u. Suppose that for ,
 where 
 and 
. Let 
⁎
. If 
, then 
.

Proof

Since 
 and 
 are two k-branching children of u in 
, each 
, , has a k-weakly-branching vertex 
, . From Definition 5.1, there are exactly two components in the forest 
 such that the root of this component is a k-pre-branching vertex. Thus in the forest 
, there exist at least three components with copnumber k. It follows from Theorem 3.4 that 
. We can clear 
 with  cops in the following way: First one cop protects 
 and the other k cops clear all components in 
; then all cops move along the path from 
 to 
 to clear all branches attached on the internal vertices of the path; finally, one cop stays on 
 and the other k cops clear all components in 
. Therefore 
. □

We next show the correctness of Algorithm 1.

Theorem 5.11

For a tree T with at least three vertices, Algorithm 1 computes 
.

Proof

In Steps 1–3, we arbitrarily select a vertex as the root of T, which induces the parent-child relation in the tree. Then the vertices of T can be ordered such that each vertex is listed before its parent. Let 
 be such an ordered list of vertices. So 
 is the root of T. If a vertex has no child, then from Definition 5.4, its label is . In Step 4, suppose u is a vertex in the list whose children's labels have been computed. Let 
 be all children of u with labels in the form of Eq. (2). In Step 5, let 
 be the tree obtained from 
 by deleting vertices of 
 and 
 (for example, see Fig. 12). If u is the only vertex in 
, then 
; otherwise, we can compute 
 by Theorem 5.7. Note that the copnumber of 
 is the largest key k in 
. From the proof of Theorem 5.9, we can use this copnumber k to clear the subtrees whose corresponding items have keys less than k, which results in the lists 
 created in Step 6. If no key in 
 is contained in two different lists, from Theorem 5.9, 
 consists of the items of 
 and 
, and thus, it is indeed the label of u in the subtree 
; otherwise, let 
⁎
 be the largest key appears in at least two lists in 
, which is found in Step 8 (e.g., see Fig. 13). Let 
 be a decreasing sequence created in Step 9, and let the corresponding items be 
, where 
, , is an item with key 
 and attribute 
. Note that 
⁎
. So either u has at least two 
-branching descendants, or u has one 
-branching descendant and the first item of 
 is 
. Similarly to the proof of Theorem 5.10, we can prove 
. If 
, then in Step 10, we have  and we update K by 
, where 
. If 
, then we have 
. Keep going in this way, we can find the smallest index h in K, where , such that 
. Thus we update K by 
, where 
 in Step 10. Therefore, the list X generated in Step 10 is indeed the label of u in the subtree 
.

We repeat Steps 4–10 until the root 
 of the tree has a label 
. From Definition 5.4, we know that 
 is the first component in the label of 
 in 
. □

In the remainder of this section, we analyze the running time of Algorithm 1.

Lemma 5.12

Suppose that each 
, , is a list of strictly decreasing positive integers. Let s be the largest number in 
 which occurs in at least two lists if one exists; otherwise, let . Then s can be determined in 
 time.

Proof

It takes  time to sort the first components 
, , in the lists in descending order using the bucket sort. W.l.o.g., suppose after sorting we have 
. Then s can be determined by the following procedure.


Download : Download high-res image (41KB)
Download : Download full-size image
In this procedure, we scan S from the left (the largest number) to the right to find the target number t or insert it into S. Since S contains at most 
 positive integers, the number of insertions is at most 
. So the runtime of the procedure is 
, which is 
. □
The following result is shown in [13] as Lemma 3.14.

Lemma 5.13

[13] Let  be a function defined on the positive integers by the recurrence equation
  where 
, and 
, and  is a constant. Then  is .

Theorem 5.14

Algorithm 1 can be implemented in linear time.

Proof

Let T be a tree with  vertices. In Algorithm 1, Step 2 requires  time by the topological sort. In each iteration of the loop from Steps 4 to 10, we compute the label of u in the subtree 
. Let 
 be the children of u whose labels have been calculated. When we calculate those labels, we use a linked list for each label. We also use a flag associated with every label to indicate whether the label contains ⊥. So Step 4 requires  time to find 
 and 
.

In Step 5, we construct the subtree 
 and compute the label of u in this subtree from the labels of 
 using Theorem 5.7. In order to save time for scanning the labels, we compress the label representation. For a sub-list of items with consecutive keys in a label, we use an interval to represent them. So by Theorem 5.7, it takes  time to compute 
. In Step 6, it takes  time to modify the labels to obtain the lists 
. Let 
, , be the largest key in 
. In Steps 7 and 8, from Lemma 5.12, it takes 
 time to determine if all keys in 
 are different or find the largest repeated key 
⁎
 in the lists. Using the compressed representation of labels, the runtime of Steps 9 and 10 is 
.

From Lemma 5.13, the total runtime of the loop from Steps 4 to 10 is . Thus Algorithm 1 can be implemented in linear time. □

6. Conclusions
In this paper, we explored the one-visibility cops and robber game on trees. We gave a lower bound for computing one-visibility copnumber of trees, which lead to the structure properties in terms of the hub, avenue and street. We developed a linear-time algorithm for computing 
 of a tree T.

There remains a considerable amount of future work concerning the one-visibility cops and robber game. We have considered only trees, however, playing this game on other graphs is yet to be explored. We believe that finding efficient algorithms for computing the copnumber of planar graphs continues to be a challenge.