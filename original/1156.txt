Abstract
We are lifting classical combinatorial problems from single instances to regular sets of instances. The task of finding a positive instance of the combinatorial problem P in a potentially infinite given regular set is equivalent to the so called intReg-problem of P, which asks for a given DFA A, whether the intersection of P with L(A) is non-empty. The intReg-problem generalizes the idea of considering multiple instances at once and connects classical combinatorial problems with the field of automata theory. While the question of decidability of the intReg-problem has been answered positively for several NP and even PSPACE-complete problems, we are presenting some natural problems even from LOGSPACE with an undecidable intReg-problem. We also discuss alphabet sizes and different encoding-schemes elaborating the boundary between problem-variants with a decidable respectively undecidable intReg-problem.

Keywords
Deterministic finite automaton
Regular intersection emptiness 
problem
Undecidability

1. Introduction and motivation
In many fields multiple problem instances are considered all at once and they are accepted if there is at least one positive instance among them. The instances are described through a strongly compressed representation. For instance, in graph modification problems2 a graph G together with several graph editing operations is given and one asks whether G can be transformed into a graph 
 with a certain property using up to n editing operations [1], [2], [3]. Here, the graph G represents the finite set of graphs which can be generated by G using up to n editing operations. Another example are problems with uncertainty in the instance [4], [5] where some parameters of the instance are unknown and therefore stand for a variety of values. Finding a positive instance among plenty of candidates is also a task in synthesis problems [6]. In [6] the authors generate a finite set of candidate Petri nets among which they search for a solution. The synthesis of an object with a certain property can be seen as the search for an object with this property among several candidates.

A natural generalization of the task of finding a positive instance in a finite set of instances is to search in an infinite set of instances. A well studied class of potentially infinite languages are the regular languages which are also in a compressed way represented by finite automata or regular expressions. We call 
 a deterministic finite automaton (DFA for short) if Q is a finite set of states, Σ a finite alphabet,  a total transition function, 
 the start state and  the set of final states. We generalize δ to words in the usual way, i.e., 
. We denote the language accepted by A with 
⁎
. More generally, if M is a language acceptor, such as a DFA, a regular expression, a grammar, or a Turing machine, we denote with  the language described by M.

Asking whether the accepted language of a DFA A contains a positive instance of a problem P is equivalent to asking whether the intersection  is non-empty. This question was introduced in [7] as the 
-problem of P or 
 for a fixed problem P.

Definition 1

Given: DFA A. Question: Is ?

In [8], [9], [10], 
 was studied for languages L with low computational complexity, but which describe structural word-properties that have high relevance for combinatorics on words and formal language theory (e.g., set of primitive words, palindromes, etc.). There, (efficient) decision procedures are obtained.
The 
-problem was studied independently under the name regular realizability problem , where the filter language L plays the role of problem P above, i.e., 
 (see [8], [11], [12], [13], [14], [15], [16]), motivated by computational complexity questions. In [16] the authors focused on context-free filter languages and presented languages L for which  is either P-complete, NLOGSPACE-complete or has an intermediate complexity. In [13] the decidability of the RR-problem with filter languages over permutations of binary words was studied. The aim of this line of research was to present with the RR-problem ‘a specific class of algorithmic problems that represents complexities of all known complexity classes [. . .] in a unified way’ [15]. It turned out that RR-problems are universal in the sense that for any problem P, there exists an RR-problem  with the same complexity (note that P and L are different languages). In this context,  problems were studied, where the filter language L is obtained by some sort of computation protocol of a machine model called GNA (generalized nondeterministic automata) introduced in [17]. More precisely, the filter language L consists of all prefixes of guess words available to the machine on a read only auxiliary tape [14]. This approach gives RR-problems which are complete under log-space reductions for LOGSPACE, NLOGSPACE, P, NP, PSPACE, EXPTIME, and the class of recursively enumerable languages. As here the filter language is closely related to computations of some machine model, the regularity of the input language is not exploited at all and the hard part of a problem is coded into regular languages consisting of single words only. In [15] the author notes that the presented reductions ‘cut off almost all properties of regular languages’.

In contrast, the line of research in [7], [18], [19], [20], [21] aims to use the 
-problem as a tool to get insights into classes of hard problems as for instance, the class of NP and PSPACE-complete problems. While the decidability of 
 for hard problems P, such as SAT [7], ILP [19], Vertex Cover [20] and TQBF [7], is known, we present in this work problems, with a complexity ranging from contained in LOGSPACE to PSPACE-completeness, with an undecidable 
-problem. These results indicate that the decidability of the 
-problem of a language does not directly coincide with its computational complexity. This study rises the natural question what for instance, NP-complete problems with a decidable 
-problem have in common that separates them from NP-complete problems with an undecidable 
-problem. We also examine for some problems, the size of the input alphabet and the encoding scheme resulting in different decidability results of the considered 
-problem. Hence, more precisely the 
-problem considers a pair of a problem together with the fixed encoding for the problem.

This paper is structured as follows. First, we discuss machine languages for several complexity classes. Then, we consider the problems of bounded and corridor tiling, followed by bounded PCP. We will show that all of these problems have an undecidable 
-problem. Next, we investigate the PSPACE-complete problem of Equivalence of Regular Expressions and prove that the problem in a shuffled encoding has an undecidable 
 problem. As the proof only uses the concatenation operator of regular expressions, we get the undecidability of 
 of the so called String Equivalence Modulo Padding problem in a shuffled encoding, which lies in LOGSPACE. For this problem, we will discuss different alphabet sizes and encoding schemes and show that all other considered variants of this problem have a decidable 
-problem. Next, we consider a generalization of the Dyck language in which we encode derivations of context-free grammars. Finally, we present a graph problem on directed multi-hyper-graphs with an undecidable 
-problem. This contrasts the results in [20], [21] where classes of graph problems with a decidable 
-problem are identified.

We expect the reader to be familiar with regular languages and their description through finite automata and regular expressions. The reader should also be familiar with the complexity classes LOGSPACE, NLOGSPACE, P, NP, and PSPACE. We refer to the textbooks [22] and [23] for details. Each considered space and time bound is taken with respect to the one tape Turing machine model.

This work was presented at ICTCS 2020 [24].

2. Machine languages
For several complexity classes, we can define machine languages which are complete for their complexity classes. We will show that the following machine languages have an undecidable 
-problem. The 
-problem of the machine language for NP was already discussed in [7] and is listed here for the sake of completeness. A nondeterministic Turing machine M (NTM for short, or TM short for Turing machine) is defined as 
␣ where Q is a finite set of states, Γ the finite set of allowed tape symbols, ␣ the symbol representing a blank tape cell, ﹨␣ the input alphabet, 
 the transition function, where L, R, and N indicates that the head moves one cell to the left, right, or stays on the current cell. Finally, 
 is the initial state of the machine and  denotes a set of final state. We call M a deterministic Turing machine if δ maps each input to a singleton set. We refer with  to the encoding of a TM M as a binary string.

Definition 2 Machine Language for NL

Given: Encoded nondeterministic Turing machine , input-word x, and a string 
 with .

Question: Does M accept x visiting only  different tape-positions?

Encoding: 
.

The language 
 is complete for the class NLOGSPACE. Every language in NLOGSPACE can be accepted by a non-deterministic Turing machine which is space-bounded by a logspace-constructible function . A function f is logspace-constructible if there exists a deterministic TM 
 which computes  on the input 
 in logarithmic space. Hence, every fixed problem in NLOGSPACE can be reduced to 
 by hard-wiring the NTM M which decides the problem and is space-bounded by f, followed by the input word w and a unary string of size 
. Note that  is logarithmically smaller than  and hence can be stored using  many cells. A logarithmically space-bounded TM can compute an output string which is exponentially in the size of its used memory. As can be easily verified 
 NLOGSPACE.

The Machine Language for NP, in short 
 is defined analogously demanding that x is accepted in n steps, while the Machine Language for PSPACE, in short 
 demands x to be accepted in n space. With similar arguments 
 is complete for NP and 
 is complete for PSPACE.

For the following results, we obtain undecidability by reducing from the undecidable non-emptiness-problem for recursively enumerable sets [23] defined as 
 is a nondeterministic TM with .

Theorem 1

The problems 
, 
, and 
 are undecidable.

Proof

We give a reduction from 
. Let  be an arbitrary encoded Turing machine with the input alphabet Σ. We define the regular language 
⁎
. Then, 
. The same holds for 
 and 
. Since the emptiness-problem for recursively enumerable sets is undecidable, the undecidability of the problems 
, 
, and 
 follows. □

3. Bounded and corridor tiling
The next problem we want to investigate is about the tiling of the plane. For a given set of tile types and a fixed corner tile, the question is to fill a plane with the given tiles under some conditions. While the problem for an infinite plane, is undecidable [25], [26], it becomes NP-complete if we restrict the plane to an -square and preset the tiles on the edges of the square; it becomes PSPACE-complete if we only restrict the width with preset tiles and ask for a finite height, such that the plane can be tiled according to the preset tiles [27].

First, we will give a formal definition of the problem Bounded Tiling. Then, we will show that this problem has an undecidable 
-problem by reducing 
 to the problem 
(Bounded Tiling).

A tile is a square unit where each of the edges is labeled with a color from a finite set C of colors. The color assignment is described by tile types. A tile type is a sequence  with  of four symbols representing the coloring of the left, top, right, and bottom edges. We denote with 
, respectively 
, 
, 
, the first, respectively second, third, and fourth entry of the tuple t. Tiles can be regarded as instances of tile types. A tile must not be rotated or reflected. In the following problem, we give a finite set of tile types as input. From every tile type arbitrary many tiles can be placed. The tiles have to cover up a square grid region such that adjacent edges have to have the same color. The grid comes with an edge coloring which contains for each border of the square grid, a sequence of colors presetting the adjacent color of tiles resting on the edge. A tiling is a mapping from the square grid region to a set of tile types. With  we denote a proper encoding of the tile type set T and with  we denote the set . We call  a tiling function if for all , it holds that 
 for , and 
 for , meaning that adjacent edges of the tiles have the same color. Here, the bottom left square of a grid region is indexed by .

Definition 3

Bounded Tiling
Given: Finite set T of tile types with colors from a finite color set C and an  square grid region V with a given edge coloring.

Question: Is there a tiling function  that tiles V extending the edge coloring?

Encoding:  followed by an edge coloring , where 
, 
, 
, 
 with 
 for .

Howard Straubing gives in his article “Tiling Problems” [26] a reduction from the complement of the halting problem to the problem of tiling an infinite plane. For that, he gives an algorithm “that takes input  and produces the associated ” (where c is the given corner tile in the unrestricted case of the problem). The tiles represent every possible transition of the Turing machine and are constructed in a way that correctly tiled rows correspond to configurations of the given Turing machine. The four colors of the tiles also ensure that two adjacent rows represent two consecutive configurations. Therefore, the infinite plane can only be tiled if and only if the Turing machine runs forever.

Peter van Emde Boas [27] uses a similar construction to simulate Turing machines and shows that the Bounded Tiling problem is NP-complete. For a given nondeterministic Turing machine, the possible transitions and tape cell labellings are transformed into a set of tile types. The input word, padded with blank symbols, is encoded in the bottom edge coloring b and a distinguished accepting configuration is encoded in the top edge coloring t. The left and right borders are colored with the fixed color white which is a color only occurring on vertical edges and which do not represent any state or alphabet letter of the Turing machine. So, white can be seen as a neutral border color. Blank symbols are trailed to the input word to enlarge the size of the square field to the exact time bound of the Turing machine. The Turing machine is altered in a way that it accepts with one distinguished accepting configuration. The tile types are constructed in a way that this accepting configuration can be repeated over several adjacent rows. Therefore, the constructed edge colored square region can be correctly tiled matching the edge coloring if and only if the given Turing machine accepts the input word within its time bound.

With that construction in mind, we will now prove that the 
-problem for Bounded Tiling is undecidable.

Theorem 2

The problem 
Bounded Tiling) is undecidable.

Proof

We give a reduction from the undecidable problem 
. Let  be the encoding of an arbitrary NTM. We construct a regular language R which contains a positive Bounded Tiling instance if and only if M accepts at least one word. We alter the machine M to an NTM N which behaves like M except having only one distinguished accepting configuration, i.e., an empty tape with the head on the first position of the former input word. According to Straubing [26] and van Emde Boas [27], there is an algorithm which, given a TM N, produces the corresponding set of tile types T such that a correct extending tiling of a given edge colored square field V corresponds to a sequence of successive configurations of the given machine, starting on an input word represented through the coloring of the bottom border.

Let 
 be the corresponding tile type set for the NTM N, and let 
 be the set of colors appearing in 
. Let 
 be the subset of colors representing input alphabet symbols, let 
 be the white color representing a white vertical border edge of the square grid, and let 
 be the color representing an empty tape cell ␣. Finally, let 
 be the color representing the accepting state of the Turing machine. We define the regular set R as 
⁎
⁎
⁎
⁎
⁎
. The set R consists of the set of tile types for the NTM N, together with edge colorings for every possible input word and every possible size of a field V. The top row will always contain the accepting configuration of N padded with arbitrary many blank symbols. The left and right borders of a field V can consist of arbitrary many white edges, while the bottom row can encode every possible input word with arbitrary many added blank symbols allowing an arbitrary time bound for the Turing machine. Note that the edge coloring does not have to define a square, but the square shape is also contained in the set R for every input word and every number of padding symbols. Therefore, for every input word w, the set R contains every size of squared fields with w encoded in the bottom edge coloring. The tile type set of R is constructed in a way that in a valid tiling adjacent rows will represent successive configurations of the Turing machine. So, for every number of steps the TM makes on the input word, there is a square field, with the input word encoded, in the set R preventing enough space for the configurations of the TM. This brings us to our main claim,

Image 1
. □
With the same argument, we can show that the PSPACE-complete problem Corridor Tiling [27] also has an undecidable 
-problem.

Definition 4

Corridor Tiling
Given: Finite set T of tile types with colors from a finite color set C, a top edge coloring t, and a bottom edge coloring b of a grid region V, both of length n.

Question: Is there a finite height h and a tiling function  that tiles V extending the edge coloring.

Corollary 1

The problem

Image 2
is undecidable.
Proof

The proof works analogously to the proof of Theorem 2 with a reduction from 
, the only difference is that R only encodes the bottom and top borders and no left and right borders. □

4. Bounded PCP
Another undecidable problem, which becomes decidable if we restrict the size of the potential solution, is the Post's Correspondence Problem (in short PCP). We show that the NP-complete version Bounded Post Correspondence Problem [22] (in short BPCP) has an undecidable 
-problem by a reduction from the unrestricted undecidable PCP problem [23].

Definition 5

BPCP
Given: Finite alphabet Σ, two sequences 
, 
 of strings from 
⁎
, and a positive integer .

Question: Is there a sequence 
 of  (not necessarily distinct) positive integers 
 such that 
?

Encoding: 
.

The problem PCP is defined analogously but does not contain a bound K on the size of a solution.

Theorem 3

The problem 
(BPCP) is undecidable.

Proof

We give a reduction PCP 
(BPCP). Let 
 and 
 be a PCP instance. We construct a regular language R consisting of the given PCP instance combined with every possible solution bound K. Since K is bounded by the length of list A and B, we will pump those lists up by repeating the last list element of both lists arbitrarily often. Because the same element can be picked multiple times, adding elements already appearing in the given lists does not change the solvability of the instance. We define R as 
⁎
⁎
⁎
. It holds that  BPCP ≠∅ if and only if there is a sequence of indexes 
 such that 
. □

5. Regular expressions in a shuffled encoding
In this next section we show that the problem of Equivalence of Regular Expressions (in short

Image 3
) over a binary alphabet in a shuffled encoding has an undecidable regular intersection emptiness problem. It turns out, that the problem is already undecidable if the regular expressions do not use alternation or the Kleene star. Thus, also the problem of String Equivalence Modulo Padding over a binary alphabet in a shuffled encoding has an undecidable 
-problem. When we consider the String Equivalence Modulo Padding problem over a unary alphabet or in a sequential encoding, the problem becomes decidable. We first define the problem of Equivalence of Regular Expressions (adapted from [22]). For a regular expression E, we denote with  the regular language described by E. We use concatenation implicitly and omit the operator symbol. The alternation is represented by the symbol |.
Definition 6

Shuffled
Image 4
Given: A word 
 with 
⁎ for , such that 
 and 
 are regular expressions over the alphabet Σ using the operators alternation, concatenation, and Kleene star. Note that one regular expression can be padded with ε or ∅ if the regular expression are of unequal length.

Question: Is ?

The problem of equivalence of regular expressions in a sequential encoding is well known to be PSPACE-complete [28]. Since we can change the encoding of an

Image 3
instance from shuffled to sequential and vice versa in quadratic time, the shuffled version of this problem is also PSPACE-complete. We will show that 
(Shuffled
Image 4
) is undecidable by a reduction from the PCP problem [29]. For readability reasons, we will refer to words w∈ Shuffled
Image 5
as  
  
 . From a given PCP instance we will construct a regular language 
, the words of which will describe all possible solutions of the PCP instance. The words will consist of two shuffled regular expressions using only the concatenation as an operator. By construction, the first regular expression will be a concatenation of strings from the A list of the PCP instance while the second regular expression will consists of the concatenated corresponding strings from the B list. Since the regular expressions only use concatenation, languages described by them only contain one element each. The language 
 will contain two shuffled regular expressions describing the same language if and only if the PCP instance has a valid solution.
Theorem 4

The problem

Image 6
is undecidable.
Proof

We give a reduction PCP

Image 7
and translate a given PCP instance into a regular language 
. We emphasize references to the regular expression defining the language 
, while references to the regular expressions encoded in the words of 
 are not emphasized. We also emphasize references to the regular language of shuffled regular expressions.
Let 
 and 
 be a PCP instance. We define a regular expression, describing a regular language 
 of shuffled regular expressions describing concatenations of list elements. Let 
 be defined through the regular expression 
 
 
 
 where the string  
  consists of the two shuffled strings 
, 
 where the shorter string is padded with ε-symbols at the end until both strings have the same length. The ε-symbol is here used as an alphabet symbol of the language 
 and refers to the regular expression ε which will be interpreted as  and not to the empty word itself. Therefore, 
 consists of all possible pairwise concatenations of elements of the lists A and B where the concatenated strings are padded with ε-symbols to have the same length.

For every PCP instance, the described regular expression of the language 
 can be computed by a computable total function. It remains to show that the PCP instance A, B has a solution if and only if

Image 8
. More precisely, the intersection will contain all solutions of the PCP instance.
First, consider the only if direction. Let 
 be a solution of the PCP instance  such that 
. By construction, the regular language 
 contains all possible concatenations of the strings  
  
  corresponding to the pairs 
 of the strings of the lists A and B. Therefore, 
 also contains the word  
  
  
 . The word w consists of the two shuffled regular expressions 
 and 
. Since they are both nonempty strings with padded ε's their described language is a singleton set. By construction, we have 
 and 
. By assumption is 
, therefore, we have  and 
 Shuffled

Image 4
.
For the other direction, assume

Image 9
. Let  
  
  
 
 Shuffled
Image 4
consists of the two shuffled regular expressions 
 and 
. By assumption is . Since  and  each contain only one element, from which the describing regular expressions differ only by padded ε-symbols, it holds by construction that 
. Therefore, 
 is a solution of the PCP instance. □
To show undecidability of the 
(Shuffled

Image 5
) problem we have made use of only one operator of regular expressions, namely the concatenation. If we restrict the Shuffled
Image 5
problem to regular expressions using only letters from Σ, the ε-symbol and the concatenation, we get the much easier problem of Shuffled String Equivalence Modulo Padding, in short Shuffled
Image 10
. Since we are only using the associative operation of concatenation, we can get rid of brackets. All of the following problems are in the complexity class LOGSPACE, since they can be solved deterministically using two pointers.
Definition 7

Shuffled
Image 10
Given: A word 
 such that 
 for .

Question: Is 
 where 
⁎
⁎
 is an erasing homomorphism which leaves all symbols in Σ unchanged and deletes the ε-symbols.

Corollary 2

The problem

Image 11
is undecidable.
Proof

In the proof of Theorem 4 we have constructed a regular language of shuffled regular expressions which described singleton sets by using concatenation and padding with ε-symbols. So, the two regular expressions describe the same language if and only if the regular expressions themselves yield the same string under deleting the ε-symbols. Therefore, the proof of Theorem 4 also works for Corollary 2. □

If we restrict the alphabet Σ to a singleton set, the regular intersection emptiness problem for Shuffled

Image 10
becomes decidable as Shuffled
Image 10
, considered as a language, is a context-free language. Alternatively, if we refrain from the shuffled encoding and consider instead a sequential encoding, the problem also becomes decidable. Here, we identify sub-automata which accept the prefix describing the first string s and sub-automata which accept the suffix describing the second string t. We use a homomorphism h to erase the padding symbol ε and check for each pair of prefix and suffix sub-automata 
 and 
, whether 
.
Definition 8

Unary-Shuffled
Image 10
Given: A word 
 such that 
 with .

Question: Is 
 where 
⁎
⁎
 is an erasing homomorphism which leaves all symbols in Σ unchanged and deletes the ε-symbols.

Theorem 5

The problem

Image 12
is decidable.
Proof

The language Unary-Shuffled
 is context-free, since for a given word, we only have to count the number of letters unequal to ε at the even and at the odd positions in the word. If those numbers are equal, the word is in Unary-Shuffled

Image 13
. This property can be checked by a deterministic pushdown automaton and hence the language is context-free. Since the context-free languages are closed under intersection with regular languages and have a decidable emptiness problem [23], the problem
Image 14
is decidable, too. □
The 
 problem becomes also decidable if we get rid of the shuffled encoding. The following problem (over an arbitrary large alphabet) has a decidable 
 problem as well.

Definition 9

Image 15
Given: A word 
 such that 
 for .

Question: Is 
 where 
⁎
⁎
 is an erasing homomorphism which leaves all symbols in  unchanged and deletes the ε-symbols.

Theorem 6

The problem

Image 16
is decidable.
Proof

Let 
 be an input DFA of

Image 17
. We define for every pair of states of A, the set of sub-words, which can be read before the $-symbol, between which the $-symbol can be read, and which can be read after the $-symbol.
⁎
⁎
Therefore, R can be written as 
. Since A is a DFA, there are only finitely many sets 
, 
, and 
 and all of them are regular, since we easily can alter the automaton A to obtain finite automata for each of those languages.

Let 
⁎
⁎
 be a homomorphism mapping every symbol form  to itself and deleting the ε-symbols. For every pair of states, the languages 
, 
, and 
 are regular. For two regular languages, the intersection emptiness problem is decidable, i.e., it is decidable, whether both languages contain a common word [23].

It holds that

Image 18
if and only if there exists states 
 and a word 
⁎
 such that 
. Since there are only finitely many states in Q, and the membership and intersection-emptiness problems for regular languages are decidable, we can simply test the right-hand condition for every combination of states, to decide whether there exists a word 
⁎
 fulfilling the condition. □
Since

Image 17
is already decidable for an arbitrary alphabet, it is also decidable for a unary alphabet, hence the problem
Image 19
is decidable, too.
Remark 1

We have shown that the problem of Shuffled

Image 4
has an undecidable 
-problem. The decidability statuses of the 
-problems for the problems of Sequential
Image 4
, Unary-Shuffled
Image 5
, and Unary-Sequential
Image 20
, which are defined similarly to the variations of the 
-problems, are still open.
For the problem of Sequential

Image 4
, the reduction from PCP fails because we cannot describe the set of all eventual solutions of the PCP-instance by a regular set of regular expressions. The corresponding list-items in one possible solution are arbitrarily far apart from each other, because the two regular expressions are not in a shuffled but sequential encoding. Therefore, the relation between the corresponding list elements can no longer be generated by a regular expression, even if we allow padding ε-symbols. For the problems Unary-Shuffled
Image 4
and Unary-Sequential
Image 5
, the reduction from PCP fails to prove undecidability of the 
-problem because the PCP-problem over unary alphabets is decidable [30].
At the attempt to prove decidability of the 
-problem for the above listed problems, we have to deal with the fact that we cannot restrict the given regular language to a regular language which only contains correctly encoded problem instances as we can do in all cases of proven 
 decidability [7], [19], [18]. Allowing operators like alternation and star in the regular expressions automatically brings brackets to the regular expressions and therefore the language of all correctly encoded regular expressions is no longer a regular set. The fact that we cannot restrict the given regular language R to a regular language of a known shape, containing the interesting subset of R, makes using pumping arguments difficult.

6. Two level general Dyck-language
In this section we build a bridge from the flat string perspective of the last section to the graph view of the next section by encoding derivation trees of context-free language into strings. The construction might remind the reader of the used techniques in the Chomsky-Schützenberger Theorem [31] and in the proof of Greibach's hardest context-free language [32] of using the Dyck language to ensure matching derivation steps in a general setting of simulating context-free grammar derivations. For  and an alphabet 
 consisting of several matching left and right brackets, the Dyck language 
 contains all words in 
⁎
 which can be reduced to the empty string ε by applying rules of the form 
 for . While in [31], [32] depending on some integer n, a variant of the Dyck language with n different fixed pairs of brackets as the alphabet was considered, here we want to condense this infinite family of Dyck languages into one general language 
 over a fixed alphabet. Therefore, we precede two fixed symbols  and  with a unary string over the fixed symbol a such that 
 encodes the bracket 
 and 
 encodes the bracket 
. Let 
. We define 
⁎
 as the set of words which can be reduced to the empty word by applying rules of the form 
. Clearly, 
 is a deterministic context-free language as it can be accepted by a deterministic pushdown automaton that stores the sub-sequences 
 on the stack and compares the stored number of a's in the topmost block on the stack with the tape content, if a sub-string 
 is read. As context-free languages are closed under intersection with regular languages, the problem 
 is decidable.

We will further consider a non context-free two-level general Dyck language 
⁎
 where the encoded bracket types are partitioned into two sets. Here, opening brackets of one set can only be matched with closing brackets of the same set. A word w is contained in 
, if the brackets of the first set are well matched in w, as well as the brackets of the second set. The idea of the main result of this section is to encode all possible derivations of two context-free grammars into a regular language over 
 such that the first set of brackets checks that the derivations are correct and the second set of brackets checks that the two derivations derive the same word. As the problem of whether two given context-free grammars derive a common word is a well-known undecidable problem [29], we prove that the problem 
 is undecidable.

We call  a context-free grammar in Chomsky normal form (CNF for short), if V is a finite set of variables, T a finite set of terminals, P a finite set of derivation rules of the from  or  with , , and  the start variable. Additionally, P may contain the rule  for the derivation of the empty string, but then S may not appear on the right side of any derivation rule. As a convention, we denote variables in V with capital letters and terminals in T with small letters. We denote with  the set of words in 
⁎
 that can be derived from S by applying derivations rules from P. For a word  we call a sequence of words 
 with 
⁎
, 
 and 
, such that 
 can be obtained from 
 by applying a derivation rule 
 from P to one variable 
, a derivation of w under . We call the binary ordered tree 
 the derivation tree of w induced by τ, if it represents the applied derivation rules in τ by sub-trees, where the variables on the right side of the derivation rule are the children of the variable on the left side, and the order of the variables in the rules is reflected by the order of the children. These sub-trees are connected to the derivation tree 
 by identifying the produced and consumed variables with each other according to τ. Note that concatenating the leaves of 
 from left to right yields the word w. For a derivation tree 
, we call a string 
⁎
 the rightmost derivation of 
 if u is the concatenation of the derivation rules appearing on a path through 
 from the root to all leaves if always the rightmost variable is derived next. Fig. 1 illustrates a derivation τ of the string , the derivation tree 
 of τ, and the rightmost derivation u of 
 for the grammar 
, 
 in CNF.

Fig. 1
Download : Download high-res image (64KB)
Download : Download full-size image
Fig. 1. A derivation τ of the string w = [ [  ] ] [ ] from the grammar 
, together with the derivation tree 
 of τ, and the rightmost derivation u of 
.

Next, we describe how derivations of a context-free grammar can be encoded into words of 
 such that rightmost derivations correspond to correctly stapled terms. Let  be a context-free grammar in CNF. To represent the empty word, we add an additional symbol 
 to T. Assume a linear order on  given by a function  for . We define the homomorphism 
⁎
⁎
 for  as
 

Lemma 1

Let  be a context-free grammar in CNF, and let 
⁎
. Then, 
 if and only if there exists some  and some derivation tree 
 of w such that u is a rightmost derivation of 
.

Proof

First, assume 
. Since the word starts with a left bracket for the start variable S, the string u must start with a derivation with S on the left side as otherwise 
 is matched with a closing bracket 
 of some literal A with . For each derivation of the form  in u, the right variable C must be derived in the next derivation in u until a derived string completely consisting of terminals is obtained before the left variable B is derived. Since the derivation  introduces opening brackets for B and C deriving B before C would introduce a closing bracket for B on the right before the bracket for C was closed, violating the stapling conditions of 
. Further, for every position in u, the next derivation rule must derive the most recently introduced variable in order to prevent bracket mismatches, as otherwise a closing bracket which does not correlated to the latest unmatched opening bracket is introduced. Hence, u encodes a rightmost derivation of some derivation tree for a word w, where w can be read off from 
 by extracting all sub-strings of the form 
 where 
, applying the inverse of f to i and building the reversal3 of the obtained string from 
⁎
.

For the other direction, let w be some string in . Fix some derivation tree 
 for w. Then, listing the derivations in the order in which they appear in the rightmost derivation of 
 gives the string u. As 
 is a derivation tree, the start variable S is the root of 
. As u encodes a rightmost derivation, at each step, the most recent introduced variable is derived. A left variable is not derived until the corresponding right variable is derived to a string completely consisting of terminals. As discussed above, this implies that the string 
 is correctly stapled and hence a word in 
. □

Hence, for every word w derived by some context-free grammar, we can represent the rightmost derivations of w by some words in 
.

Next, we want to lift this construction for the membership problem to the undecidable problem of whether two given context-free languages derive a common word. Therefore, we split the control condition of our general Dyck language, of describing a correctly stapled bracket term, into two phases. This slight modification of the language 
 will lead to an undecidable regular intersection emptiness problem. More precisely, we partition our set of bracket descriptions into two sets where the first one contains all bracket pairs which must match in the first phase while the bracket pairs of the second set are ignored. In a second phase, the bracket pairs of the second set must match, while the ones from the first set are ignored. Only if both phases succeed, the word is accepted. Formally, we define this two-level general Dyck language as 
⁎
 with 
 such that 
, if and only if (1) w can be reduced to ε by applying rules of the form 
, 
, and 
 and (2) w can be reduced to ε by applying rules of the form 
, 
, and 
. The language 
 is no longer context-free but can still be recognized by a deterministic log-space Turing machine. We will now encode all possible combinations of derivation rules for two given context-free grammars into a regular set and use the language 
 to filter out those words that encode correct derivations of a common word by both grammars.

Theorem 7

The problem 
 is undecidable.

Proof

Let 
, 
 be two context-free grammars in CNF with 
. As the class of context-free languages is closed under building the reversal of a language (i.e., reversing every word in the language) let 
 be a context-free grammar in CNF deriving the reversal of 
. Note that 
 can be obtained from 
 by inverting the order of every right side of a derivation rule in 
.

We construct a regular language 
 as a concatenation of two regular languages, where 
 is constructed from 
 and 
 is constructed from 
. The partition of the set of bracket of 
 will separate the variables in 
 and 
 from the terminals in 
, i.e., variables will be encoded via 
 and 
 while terminals will be encoded via 
 and 
. We assume the function f representing a linear order on 
. In the first phase of 
, the stapling of brackets obtained by variables in 
 will be checked as in the discussion for 
 above. Hence, by Lemma 1 only words encoding rightmost derivations of derivation trees pass phase one. Since the two sets of variables 
 and 
 are distinct, the definition of R below ensures that every word in R consists of two parts, where the first corresponds to a derivation of 
 and the second to a derivation of 
. For the second phase, in 
 only opening brackets, while in 
 only closing brackets for terminals are introduced. Hence, in the second phase, the derived words from 
 and 
 are compared and only pass the test in phase two of 
 if we can derive in 
 the reversal of a word derivable from 
 and hence, 
 and 
 derive a common word.

Based on the discussion above, we define for 
 a homomorphism 
⁎
⁎
 for 
 as
  For 
 we define a homomorphism 
⁎
⁎
 for 
 as
 

Finally, we define the regular language 
 such that the intersection 
 if and only if 
 by giving regular expressions for 
 and 
 as
⁎
⁎
 for 
 and 
. Setting 
 and 
 concludes the construction. □

7. An undecidable intreg-problem about graphs
In the last section, we encoded derivations into flat strings. In this section we step into a higher dimension and consider encodings of graphs. Mainly, we will consider a graph problem with an undecidable 
-problem which contrasts the decidability results of 
 for graph problems obtained in [20] and [21].

For a word 
⁎
 and a letter , we denote with 
 the number of σ's in w. We consider directed hyper-multi-graphs with self loops and 2 to 4 vertices per edge. More formally, we consider graphs of the form , where V is a set of vertices and E a set of edges together with the function 
 which assigns each edge with a tuple consisting of 2 to 4 vertices incident to this edge. An edge is called a loop if all of its incident vertices are identical. We encode G by listing its edges separated by $-signs. Vertices appearing in edges are encoded by strings of a's separated by #'s. To extract the encoded graph, we define the following decoding function. For , 
, let
 
 
 where  with 
, 
. We present a graph-problem over this class of graphs for which its 
-problem is undecidable by encoding the sets of derivation trees of two given context-free grammars in Chomsky normal form into a regular set of directed hyper-multi-graphs. The languages of the two grammars will share a common word w if and only if the intersection of the constructed regular language with the graph-problem is non-empty and contains the two derivations of w. We first give the construction and then define the graph problem Embedded Derivation Trees, EDT for short.

Theorem 8

(EDT) is undecidable.

Proof

Let 
, 
 be two context-free grammars in CNF. We alter them, by introducing two new variables 
 and 
, to the grammars 
, 
. From now on we will identify 
 as 
 and 
 as 
. W.l.o.g. assume that the sets 
 are disjoint and both grammars share the terminal alphabet T. We reduce from the undecidable problem [29] of checking that a common word 
⁎
 can be derived from the given context-free grammars 
 and 
.

Let 
, 
, 
 
, 
. We construct a regular set as the concatenation 
, where 
 (respectively 
) is defined as follows: We fix an order on the elements in 
, 
, and T such that 
 is the first element in 
 and 
 is the first element in 
. We refer to the i'th element of a set  as . Let 
, 
 for integers 
 and 
. For the derivation rule 
 in 
, we define the regular expression 
 and for the derivation rule 
 in 
, we define 
. For every derivation rule 
, 
 in 
, we define the regular expression 
⁎
⁎
⁎
. For a derivation rule 
, 
 in 
, we define 
⁎
⁎
⁎
. We define for each  and , a regular expression 
 which encodes a cycle of length j consisting of binary edges. We call these cycles leave-cycle later.
 
 
 
⁎
⁎
 
⁎
 
⁎
 For derivation rules 
 in 
 and 
 in 
, we define: 
⁎
 
⁎
, and 
⁎
 
⁎
. We are now ready to define 
 and 
. We set 
⁎
 for .

We now define our graph property such that it filters out the encoded graphs in the regular set which consists of two derivation trees, one from 
 and one from 
, which derive the same word. It is helpful to consider Fig. 2 while reading though the following arguments.

Fig. 2
Download : Download high-res image (208KB)
Download : Download full-size image
Fig. 2. In the top, two derivation trees for the word 1231 are drawn. Below is the multi-graph embedding of a corresponding instance of EDT. The chosen orders of the variable and letters are: S1,S′,A,B,C,D; S2,S″,E,F,G,H; 1,2,3; n = 26. For every node, the number of letters a in its encoding is depicted.

Definition 10

Multi-Graph Embedding ϕ
Let  be a directed hyper-multi-graph such that each edge contains two, three, or four vertices. The multi-graph embedding ϕ maps G onto a multi-graph 
 with 
 in the following way: 
, for a 4-nary edge , we add the edges  to 
. For a ternary edge , we add the edges  to 
. Binary edges are simply added to 
.

Definition 11

EDT
Input: A directed hyper-multi-graph  with 
.

Question: Does the multi-graph embedding  consist of two connected components 
 and 
 such that the following holds. 
 contains a vertex 
 and 
 contains a vertex 
, such that 
﹨
 and 
﹨
 are (directed) binary trees (where edges are pointing from parents to children) in which the leave layer consists of directed cycles (called leave-cycles). Exactly the root-node and the parents of leave-cycles have out-degree one, all other nodes which are not part of a leave-cycle have out-degree 2. The node 
 is connected to exactly one child of each parent node in 
﹨
 except for the root, as here 
 is pointing to the root and not to the child. The only node pointing towards 
 is the root of 
﹨
. The node 
 has no further connections. The same holds for 
 with respect to 
﹨
. If 
 and 
 are drawn such that 
 and 
 always point to the left child, then the sequence of lengths of the leave-cycles of 
 and 
 (read from left to right) must coincide. Both graphs must not contain multi-edges and loops are only allowed as a leave-cycle. The leave-cycles are not connected to each other.

Clearly, EDT can be solved in polynomial time by checking the described properties for each potential vertices 
 and 
 in V.
We will first argue that for any  with 
 being a positive instance of EDT, the sub-graphs 
 and 
 of 
 must correspond to two derivation trees, one for 
 and one for 
.

Note that for  and , the only vertex labels 
 and 
 which can be a factor of a word in R are 
 and 
. Especially, there are no factors of the form 
 or 
 with  and the vertex 
 is only appearing in sub-graphs corresponding to derivation rules of 
 whereas 
 is only appearing in sub-graphs corresponding to derivation rules of 
. Hence, for a graph 
 with , in order to consist of two disjoint graph 
 and 
 one of them must contain a vertex encoded by 
 and hence be constructed by 
 and the other one must contain a vertex encoded by 
 and be constructed by 
 as one of this elements is part of any regular expression 
.

Note that by the definition of 
 and 
 each string  contains exactly one factor encoding the derivation rule 
 and one factor encoding the derivation rule 
. There are no other derivation rules in which 
 or 
 appear. Hence, there will be no factor 
 and 
 in w with . As 
 and 
 are the only regular expressions allowing to create an edge, the multi-edge embedding of which creates an arc pointing towards 
 (encoded by 
) and 
 (encoded by 
), the root of the tree4 
﹨
 necessarily be 
 with the child 
 and the root of the tree 
﹨
 needs to be 
 with child 
. The sub-tree starting in 
 will then correspond to a derivation tree of 
, when the leave-cycle of length i is interpreted as the i-th letter of T, and the sub-tree starting in 
 will correspond to a derivation tree of 
.

W.l.o.g. we will focus on 
. By the definition of EDT, 
 must be a binary tree with leave-cycles and by previous arguments have the root 
 with the single child 
, all other internal parent-nodes have out-degree two. As 
 does not contain any multi-edges and loops are only allowed as leave-cycles, every inner node 
 has exactly two appearances of its encoding 
 in w namely in the 4-nary hyper-edge where it appears as one child and in the 4-nary hyper-edge where it appears as the parent node. The first edge corresponds to a derivation where the variable represented by 
 is ‘created’ and the second edge to a derivation where this variable is ‘consumed’. Hence, following the inner nodes gives us a derivation tree for derivations of the form  in 
.

Every member of a cycle of length k has its own domain of representatives which is disjoint with the domains of the other elements of the cycle. It is also disjoint with the domains of elements of cycles with different lengths. We show that if  encodes a positive instance of EDT, then for each leave-cycle 
 of length k, which is the child of a node 
 encoding the variable 
, the description of 
 is created by the regular expression 
 which encodes the derivation 
. Let 
 be the first node in the cycle 
, i.e., the child of 
. Then, there is a factor uv in w encoding the edge 
 where u encodes the node 
 and v encodes the node 
. We know that 
 and 
 
. By the definition of R the node 
 can only point to a node 
 encoded by a factor x for which 
 
 for , or to itself for , but the only regular expressions which allow to create such a factor correspond to derivation rules . Indeed single edges between the same type of nodes (where the number of a's have the same remainder modulo n) can be exchanged between different derivation rules with the same letter  on the right side but the number of nodes in a cycle can not be altered that way without losing a cycle structure or introducing forbidden multi-edges. Hence, we can assume that 
 is created by a regular expression encoding the derivation rule 
.

Replacing cycles of length k by the corresponding letters  completes our derivation tree constructed by the inner nodes with derivations of terminals. As the trees 
 and 
 have the same sequence of cycle lengths in the leave-level if the child pointing to 
, respectively 
 is drawn as the left child, the constructed derivations derive the same word.

For the other direction, we can construct a word  for which the graph 
 is a positive instance of EDT from the two derivations of a common word 
 in the following way. We begin with the derivation tree for 
, and continue in the same way for the derivation tree for 
. We go through the derivation tree from the root to the leaves and in every level from left to right. It is clear how to encode the first derivation step 
. For all other derivation steps, we define an index k and increase it with every new considered appearance of a variable in a derivation such that  for 
, as the child of the root. Then, we encode a node with variable 
 by a factor 
. With a consistent variable encoding, the regular expressions 
 tells us how to encode each derivation. For the terminal derivations, we go from left to right. Let 
 be the index (in this sequence) of a terminal  derived from a variable 
 beginning with . Then, we use the regular expression 
 corresponding to the derivation 
 to encode a cycle where each element of the cycle is encoded by a factor of the form 
 where 
 
 
. Clearly, w encodes a positive instance of EDT. □

8. Discussion
For a recursively enumerable language (also called semi-decidable) L we cannot acquire an 
-problem with a higher complexity than recursively enumerable, since we can always solve 
 by enumerating the words in L and checking for each word, whether it is contained in the given regular language. Hence, the highest complexity for an 
-problem, we observed here, of being complete for the class of recursively enumerable languages is already the highest we can hope for.

We also cannot hope to get with 
 an easier problem than L, as we can encode every fixed instance w of a problem L by an automaton in time linear in w, we immediately get 
.

While we observed different complexities regarding the 
-problem of string equivalence modulo padding, depending on whether the problem is given in a sequential or a shuffled encoding, the complexity of 
 for some problem L is preserved under applying to L length preserving homomorphisms where the image of the alphabet is a prefix code [14]. Note that we cannot switch between a sequential and a shuffled encoding via homomorphisms.

Getting more insights into properties of problems yielding an undecidable, respectively decidable, 
-problem is an interesting topic for future research. There might even be a connection to the famous phase-transition phenomena [33], [34] observed on combinatorial problems, where the problem requires a very high running time only on instances where some parameter lies in a small range of potential values.