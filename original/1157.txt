Abstract
We study three classical graph problems – Hamiltonian path, minimum spanning tree, and minimum perfect matching on geometric graphs induced by bichromatic (red and blue) points. These problems have been widely studied for points in the Euclidean plane, and many of them are NP-hard. In this work, we consider these problems for collinear points. We show that almost all of these problems can be solved in linear time in this setting.


Keywords
Hamiltonian path
Minimum spanning tree
Minimum prefect matching
Red-blue points
Collinear points

1. Introduction
In this article, we study three classical graph problems on geometric graphs induced by bichromatic (red and blue) points. Suppose, we are given a set R of n red points and a set B of m blue points in the Euclidean plane. Consider the complete bipartite graph G(R,B,E) on R∪B, where the set E of edges contains all bichromatic edges between the red points and the blue points. Also, suppose the graph G(R,B,E) is embedded in the plane: the points are the vertices and each edge is represented by the line segment between the two corresponding endpoints. We denote these edges as bichromatic segments, where each bichromatic segment connects a red point with a blue point. A subgraph G′ of G(R,B,E) (or equivalently a subset of edges of E) is called non-crossing (or planar) if no pair of the edges of G′ cross each other. Next, we discuss the three graph problems on the bipartite graph G(R,B,E) that we study in this paper.

In the Bichromatic Hamiltonian path problem, the objective is to find a path in G(R,B,E) that spans all the red and blue points. Equivalently, one would like to find a polygonal chain that connects all the red points and the blue points alternately through bichromatic segments. It is not hard to see that a Hamiltonian path exists in G(R,B,E) if and only if m−1≤n≤m+1, and if there exists one, it can be computed efficiently, as G(R,B,E) is a complete bipartite graph. A more interesting problem is the Non-crossing bichromatic Hamiltonian path problem where the objective is to find a non-crossing Hamiltonian path. Note that one can construct instances with m−1≤n≤m+1, for which it is not possible to find any non-crossing Hamiltonian path. In Fig. 1, we demonstrate two such instances.1 Fig. 1(a) has eight points, where four of them lie on a horizontal line L and the remaining four lie on a line parallel to L. Notice that there must be one red and one blue point with degree 1. One can verify by enumerating all possible paths that there is no non-crossing Hamiltonian path that spans these points. The example in Fig. 1(b) has thirteen points in general position, i.e., no three points are collinear, and it also does not admit a non-crossing Hamiltonian path. Indeed, if 2≤n≤12, then for any given ⌊n/2⌋ red (resp. blue) points and ⌈n/2⌉ blue (resp. red) points in general position, there exists a non-crossing Hamiltonian path [18]. Due to the uncertainty of the existence of non-crossing Hamiltonian paths in the general case, researchers have also considered the problem of finding a non-crossing alternating path of length as large as possible [16], [20]. Recently, Mulzer and Valtr [21] showed that for a set of points in convex position, there is an absolute constant ε>0, independent of n and of the bicoloring of the points, such that P always admits a non-crossing alternating path of length at least (1+ε)n. Garcia and Tejel [15] designed polynomial time algorithms for special geometric instances.

Fig. 1
Download : Download high-res image (20KB)
Download : Download full-size image
Fig. 1. Two instances without a non-crossing Hamiltonian path. Figure (a) is not in general position, Figure (b) (borrowed from [17]) is in general position. (For interpretation of the colors in the figure(s), the reader is referred to the web version of this article.)

Next, we consider the Bichromatic spanning tree problem where the objective is to compute a minimum weight spanning tree of G(R,B,E), where the weight of the edge between each pair of points is the Euclidean distance between those two points. Note that this problem can be solved efficiently by any standard minimum spanning tree algorithm. Biniaz et al. [7] showed that minimum bichromatic spanning tree can be computed in O(nlog⁡n) time. Moreover, their algorithm extends to the multicolored version with the time complexity O(nlog⁡nlog⁡k) where k is the number of different colors (or the size of the multipartition in a complete multipartite geometric graph). A more interesting problem is the Non-crossing bichromatic spanning tree problem where additionally the computed tree must be non-crossing. Borgelt et al. [10] showed that this problem is NP-hard. For points in general position, they gave a near-linear time O(n)-approximation. On the other hand, for points in convex position, they gave an exact cubic-time algorithm. Another line of work that received much attention is where the task is to find a degree-bounded non-crossing spanning tree [9].

Finally, we consider the Bichromatic matching problem. Again assume that n=m for simplicity. We would like to find a minimum weight perfect matching in G(R,B,E). The weight of an edge is the Euclidean distance between its corresponding points. It is a well-known fact that a minimum weight bichromatic matching (for points in general position) in the plane is always non-crossing, which follows from the observation that the sum of the diagonals of a convex quadrilateral is strictly larger than the sum of any pair of opposite sides. This implies that using any standard bipartite matching algorithm one can solve a Non-crossing Bichromatic matching exactly. But, algorithms with better running time have been designed by exploiting the underlying geometry of the plane. Recently, Kaplan et al. [19] designed an O(n2poly(log⁡n)) algorithm for the problem improving the O(n2+ϵ) algorithm due to Agarwal et al. [2], where poly(.) is a polynomial function. In [21], Mulzer and Valtr showed that for a set of in convex position, there always exists a non-crossing bichromatic separated matching2 on at least (1+ε)n points of P, where ε>0 that is independent of n and of the bicoloring of the points. Abu-Affash et al. [1] studied the bottleneck variant of the non-crossing matching problem. This problem is known to be NP-Hard. They gave an O(nlog⁡n)-time approximation algorithm which computes a non-crossing matching of size at least 2n5 edges, whose edges have length at most 2+3 times the bottleneck. Biniaz et al. [8] studied the non-crossing geodesic spanning trees, Hamiltonian cycle, and perfect matching in a simple polygon.

In this article, we consider the above mentioned problems for collinear points on a real line.3 We assume that the points are given in their sorted order. We note that the case of non-crossing graphs on collinear points is closely related to 1-page or 2-page book embeddings [6], which have all vertices placed on a line (called the spine) and the edges drawn without crossings in one or two of the halfplanes (but not in both) defined by the spine (called the pages). In our case we assume that the edges are drawn as (circular) arcs or 1-bend polylines either above or below the spine.4 We assume that their weight is given by the Euclidean distance of their endpoints. If the arcs are drawn infinitesimally close to the spine, these weights correspond to the lengths of the arcs.

1.1. Our results
The main results obtained in this work are the following.

➥
Non-crossing Hamiltonian path for collinear points – We prove that for any collinear configuration of the points with |R|=|B|, there always exists a non-crossing Hamiltonian path. Additionally, we give a linear-time algorithm for computing such a path (Section 2). As noted before, if the points are not collinear and lie in the plane, the existential claim is not necessarily true.

➥
Minimum spanning tree for collinear points – We give a linear-time algorithm for computing a minimum-weight spanning tree, and a quadratic-time algorithm for computing a minimum-weight non-crossing spanning tree for collinear points and edges on a single page (Section 3). In contrast, the problem in the non-crossing case is NP-Hard in the plane.

➥
Minimum non-crossing matching for collinear points – We give a linear-time algorithm that computes a minimum-weight non-crossing perfect matching for collinear points and edges on a single page (Section 4). We note that the most efficient algorithm for this problem in the plane runs in O(n2poly(log⁡n)) time.

We note that even in this simple one-dimensional case these problems become sufficiently challenging if one is constrained to use only linear (or near-linear) time. Our study of one-dimensional case is partly motivated due to the intractability of the problems or lack of efficient algorithms in the plane. Note that for all the problems, we have obtained improved or more interesting results compared to the planar case. Our findings give a better understanding of these problems and our work can be considered as a stepping stone towards achieving improved results in the plane.
Remark

In a parallel work, Aichholzer et al. [3] obtained a different linear time algorithm for Non-crossing Hamiltonian path for collinear points.

1.2. Related work
A closely related problem to Bichromatic Hamiltonian path is the Bichromatic traveling salesman problem (Bichromatic TSP) problem, where one would like to find a minimum-weight Hamiltonian cycle in G(R,B,E). The weight of each edge is the (Euclidean) length of the corresponding segment. The weight of a path is the sum of the weights of the edges along the path. We assume n=m, otherwise, there is no Bichromatic Hamiltonian cycle. A straightforward reduction from the (monochromatic) Euclidean TSP [5] (replace each point by a bichromatic pair that is small distance apart) shows that Bichromatic TSP is also NP-hard. One simple, but powerful fact is that an optimum Euclidean TSP is always non-crossing. This helps to obtain a PTAS [5] for the problem. However, an optimum Bichromatic TSP is not necessarily non-crossing which makes its computation much harder compared to Euclidean TSP. The best known approximation factor for the Bichromatic TSP problem is 2 due to Frank et al. [14] who improved the 2.5-approximation of Anily et al. [4]. For a set of collinear points, Evans et al. [13] gave a quadratic time algorithm for computing an optimum non-crossing TSP, every edge of which is a poly-line with at most two bends. We note that, in the existing research literature, the framework used by Evans et al. [13] is the closest to our work.

Colannino et al. [11] gave a near-linear time algorithm for the many-to-many matching problem for red-blue points on a line, which is similar to bichromatic matching. In many-to-many matching, we are given a bipartite graph, and we want to find a minimum-weight subset of edges that span all the vertices. Note that in contrast to our problem, here two edges can share an endpoint.

2. Non-crossing Hamiltonian path for collinear points
If we would require for the collinear point set that each edge of a Hamiltonian path is a straight-line segment, the problem becomes trivial: an input instance can have a non-crossing Hamiltonian path if and only if the colors of the points alternate. Therefore, we consider the case where edges are represented by circular arcs drawn in the halfplane either above or below the line.

Definition 1

Non-crossing Hamiltonian path for collinear points. Given a set R of n red points and a set B of n blue points on a line, find a non-crossing geometric path π in the plane such that π consists of a sequence of circular arcs above or below H, each of which connects a red and a blue point and π spans all the input points.

Note that in the above definition if the path is allowed to use arcs only from above (resp. below) H, then there might not exist such a Hamiltonian path. For example, consider the configuration in Fig. 2, which contains 16 points. Also, consider the continuous monochromatic chunks of points. Thus, the first chunk contains four blue points, the second chunk contains two red points, and so on. Note that the first blue point must be connected to the last red point in any non-crossing Hamiltonian path. Otherwise, there are two options: it gets connected to (i) a different point of the fourth chunk and (ii) a point of the second chunk. In the first case, the last red point cannot get connected to a blue point. In the second case, at least one point of the first chunk cannot get connected to a red point. Thus, the first blue point must be connected to the last red point. Moreover, for similar reasons, the second blue point must be connected to the second to last red point, the third blue point must be connected to the third to last red point and the fourth blue point must be connected to the fourth to last red point. Fig. 2 shows such an example Hamiltonian path. It is easy to verify that this path cannot be completed by connecting all the points.

Fig. 2
Download : Download high-res image (86KB)
Download : Download full-size image
Fig. 2. Example of a set of collinear points for which a non-crossing Hamiltonian path does not exist if the arcs can be drawn only above the spine.

In the light of the above discussion, we would like to find a non-crossing Hamiltonian path each of whose edges is a circular arc that lies either above or below H. First, we give a simple and intuitive construction of such a path for any configuration of points. The construction itself takes polynomial time, hence giving a polynomial-time algorithm for computation of such a path. Later, we give a more involved algorithm that runs in linear time.

2.1. The construction
To construct the path, we start with any bichromatic matching (not necessarily non-crossing) of the points. Note that each matching edge is a segment on H. We will connect these edges to obtain a Hamiltonian path. First, we form a hierarchical (or laminar) structure of these matching edges. Informally, the matching edges are hierarchical if any two edges are either separated or one is nested in the other.

Definition 2

A set of matching edges M are hierarchical (or laminar) if for any two edges (u,v),(w,x)∈M with u<v, w<x and u<w, either u<v<w<x ((u,v),(w,x) are separated) or u<w<x<v ((w,x) is nested in (u,v)).

Given any matching M for R∪B, we can change it to a hierarchical matching in the following way. If there are two edges (u,v),(w,x)∈M with u<v, w<x, u<w that are not separated and none of them is nested in the other, then it must be the case that u<w<v<x. Now, there are two subcases, depending on the colors of u and w. If u,w are red or u,w are blue, we replace the edges (u,v),(w,x) by the two bichromatic edges (u,x),(w,v). Otherwise, either u is red, w is blue or u is blue, w is red. In that case, we replace the edges (u,v),(w,x) by the two bichromatic edges (u,w),(v,x). See Fig. 3 for a demonstration. Note that in all the cases, the new pair of edges does not violate the hierarchical structure. We repeat the process for each pair of edges that violates the condition. Newly formed edges might violate the condition with respect to other edges. However, if an edge is removed, it is never added back, and thus the process will eventually stop at some point when no pair of edges violates the condition any more.

Fig. 3
Download : Download high-res image (56KB)
Download : Download full-size image
Fig. 3. Illustration showing uncrossing of edges in the first ((a),(b)) and second subcases ((c),(d)). (a) and (c) showing edges before uncrossing. (b) and (d) showing edges after uncrossing.

Next, we associate levels with each matching edge of M in a recursive way. In the base case, for each edge that does not nest any other edge, set its level to 1. Now, suppose we have defined edges of level j for each j≤i−1 for i≥2. An edge (u,v) has level i, if it nests a level i−1 edge, and for any level i−1 edge (w,x) that it nests, there is no other edge that is nested in (u,v) that also nests (w,x) (see Fig. 4). Note that the level of each edge is unique. Let L be the maximum level.

Fig. 4
Download : Download high-res image (63KB)
Download : Download full-size image
Fig. 4. Illustration showing the levels of the edges.

For any edge (u,v) of M with level j, call the points that lie between u and v including u and v as a level j block. Thus, a level l block is a union of disjoint blocks of levels at most l−1 and two special points which are the first and last point of the block.

Observation 1

Each block as defined above contains the same number of red and blue points.

Proof

We prove this by induction on the level l of the blocks. In the base case, l=1 and each level 1 block consists of the two endpoints of the corresponding edge. So, the statement holds in this case. Now, suppose the statement is true for all blocks with level l≤j. Consider any block β of level j+1 corresponding to the edge (u,v). Now, let β be the union of the disjoint blocks β1,…,βt along with the points u,v. As each βi has level at most j, by induction, it has the same number of red and blue points. As (u,v) is bichromatic, it follows that β as well has the same number of red and blue points. □

We compute the Hamiltonian path for all the blocks in a bottom up manner. The path of a level 1 block is the matching edge itself which defines the block. Additionally, for each block, we compute a path for the block that satisfies the following two invariants.

•
The first point of the block is an endpoint of the path.

•
If an endpoint p of the path is not an endpoint of the block, then the path cannot contain two edges (u,v),(w,x) with u<v and w<x, such that (u,v) lies above H, (w,x) lies below H, u<p<v, and w<p<x.

Informally, the second condition states that the endpoint of the path that is not an endpoint of the block should be available for connecting with an edge at least from one side. Note that the paths for level 1 blocks trivially satisfy the invariants. Now, assume that we have computed the paths for all the level j blocks for j≤l−1 and l≥2 that satisfy the invariants. We show how to compute the path for a level l block S that also satisfies the invariants. Let u,v be the endpoints of the block. Also let S1,…,St be the blocks, sorted w.r.t. the index of the first point in increasing order, whose union with the set {u,v} forms the block S. As Si has level at most l−1, we have already computed the path of Si for all i. We show, by induction, how to construct the path T′ for the points in ∪j=1iSj for all 2≤i≤t. Then, we show how to join the edge (u,v) with T′ to obtain the path for the block S. For simplicity, we also refer to the set of points ∪j=1iSj as a block. Now, we prove the following lemma.
Lemma 2

A non-crossing Hamiltonian path of ∪j=1iSj can be computed for all 1≤i≤t that satisfies the two invariants.

Proof

We prove this using induction on the values of i. In the base case, for i=1, we know how to compute the path of ∪j=1iSj=S1 that satisfies the two invariants. Now, consider any i≥2. Suppose we have already computed the path Ti−1 of ∪j=1i−1Sj that satisfies the two invariants. Let Πi be the path of Si that also satisfies the two invariants. Let u1,v1 (resp. u2,v2) be the endpoints of the path Ti−1 (resp. Πi) with u1<v1 (resp. u2<v2). As ∪j=1i−1Sj (resp. Si) contains the same number of red and blue points, the color of u1 (resp. u2) will be different from the color of v1 (resp. v2). Now, there are two cases.

1. u1 and u2 have the same color. We add the edge (v1,u2) with Ti−1∪Πi to get the path Ti for ∪j=1iSj (see Fig. 5). To make sure (v1,u2) does not cross the other edges, we can make use of the second invariant. From the invariant it follows that, for v1, all the edges of Ti−1 whose endpoints are on both sides of v1 must lie on the same side of H. Thus, if those edges lie above, we draw the edge (v1,u2) below H. Otherwise, we draw (v1,u2) above H. Note that u1 is an endpoint of Ti which is the first point of ∪j=1iSj. Also v1<u2<v2. Thus, the other endpoint v2, still satisfies the second invariant as before by induction.

Fig. 5
Download : Download high-res image (94KB)
Download : Download full-size image
Fig. 5. Illustration showing Case 1 (upper) and Case 2 (lower) of Lemma 2.

2. u1 and u2 have different colors. We add the edge (v1,v2) with Ti−1∪Πi to get the path Ti for ∪j=1iSj (see Fig. 5). We need to ensure that the edges of Ti−1 and Πi whose endpoints are on both sides of v1 and v2, respectively, lie on the same side of H. If this is not true, the edges of Πi that lie below H can be redrawn above H, and the edges of Πi that lie above H can be redrawn below H. This does not violate any invariant. Hence, (v1,v2) can be drawn without crossing any edge of Ti−1∪Πi. Note that u1 is an endpoint of Ti which is the first point of ∪j=1iSj. The other endpoint u2 was an endpoint of the block Si. Thus, even after the drawing of (v1,v2) one side of u2 still remains available. Hence, the second invariant is also satisfied. □

The next lemma completes the induction step for showing the construction of the path for the level l block.

Lemma 3

A non-crossing Hamiltonian path for the level l block S can be computed that satisfies the two invariants.

Proof

First, we compute the path Tt for the points in ∪j=1tSj using the construction in Lemma 2. Let u1,v1 be the endpoints of Tt such that u1<v1. Note that as mentioned before S=(∪j=1tSj)∪{u,v}. Without loss of generality, assume the color of u and v is red and blue, respectively. The other case can be handled similarly. Now, there can be two cases.

1. u1 is red and v1 is blue. We add the edge (u1,v) with Tt∪{(u,v)} to get the path for S (see Fig. 6(a)). From the second invariant for Tt it follows that, for v1, all the edges of Tt whose endpoints are on both sides of v1 must lie on the same side of H. Thus, if those edges lie above, we draw the edges (u1,v),(u,v) above H. Otherwise, we draw (u1,v),(u,v) below H. Thus, the second invariant is satisfied. Also, note that u is an endpoint of the new path which is the first point of S. Hence, both the invariants are satisfied.

Fig. 6
Download : Download high-res image (81KB)
Download : Download full-size image
Fig. 6. (a) Illustration showing Case 1 of Lemma 3. (b) Illustration showing Case 2 of Lemma 3.

2. u1 is blue and v1 is red. We add the edge (v1,v) with Tt∪{(u,v)} to get the path for S (see Fig. 6(b)). From the second invariant for Tt it follows that, for v1, all the edges of Tt whose endpoints are on both sides of v1 must lie on the same side of H. Thus, if those edges lie above, we draw the edge (v1,v) below H. Otherwise, we draw (v1,v) above H. As u1, an endpoint of the new path, is the second point of S, irrespective of how we draw (u,v), the second invariant is satisfied. Also u is an endpoint of the new path which is the first point of S. Hence, both the invariants are satisfied in this case as well. □

To compute the path of all the points in R∪B one can note that R∪B is the union of a set of blocks having levels at most the maximum level L. By Lemma 3, we can compute the paths for all such blocks that satisfy the invariants. Then we can merge those paths using the construction in Lemma 2 to get the path for the points in R∪B. It is easy to verify that the overall construction can be done in polynomial time. Thus, we get the following theorem.

Theorem 1

For any set R of red points and B of blue points on a line with |R|=|B|, there always exists a non-crossing Hamiltonian path whose edges are circular arcs that lie above or below H. Moreover, such a path can be computed in polynomial time.

2.2. A linear time algorithm for non-crossing Hamiltonian path
In this subsection, we give another algorithm for computing a non-crossing Hamiltonian path. This algorithm uses very different set of ideas than the previous algorithm. Recall that all the input points lie on a line. We assume that the points are given in sorted order with respect to their x coordinates. For a point p (except the last one), let S(p) be the point which is the successor of p in this order. We use the following algorithm to compute a non-crossing Hamiltonian path. In contrast to the previous algorithm, this algorithm processes the points from left to right and extends the Hamiltonian path constructed so far by connecting the current point with an appropriately chosen point. In particular, in every iteration, we consider a point p and connect it by adding one or more edges. Initially, p is the leftmost point. We also maintain a set of active points which is initialized to the set of all points. We store the constructed path in a set of edges Π, which is initially empty.

•
Let Right(r) and Right(b) be the rightmost (or last in the order) red and blue points, respectively, which are active.

•
If the color of p is different from the color of S(p), we simply add an arc (p,S(p)) to Π that lies above H. Make p inactive.

•
Otherwise, there are two cases.

1.
If p is red, add two edges (p,Right(b)) and (Right(b),S(p)) to Π. These two edges are drawn above H as circular arcs. Make p and Right(b) inactive.

2.
If p is blue, add two edges (p,Right(r)) and (Right(r),S(p)) to Π. These two edges are drawn below H as circular arcs. Make p and Right(r) inactive.

•
If S(p) is active, assign S(p) to p (i.e., p←S(p)) and repeat all the steps. Otherwise, terminate the algorithm.

Observation 4

Consider any iteration of the algorithm. Then, any red point on the right of Right(r) (if any) is inactive and has degree 2. Similarly, any blue point on the right of Right(b) (if any) is inactive and has degree 2. Moreover, any point on the left of p (if any) is inactive and except the first point all of them have degree 2.

Lemma 5

The algorithm correctly computes a bichromatic Hamiltonian path.

Proof

Note that when the algorithm terminates, S(p) is inactive. Thus, its degree must be 2. If S(p) is red (resp. blue), then it had become Right(r) (resp. Right(b)) at some point and its degree is 2. By Observation 4, all the points whose colors are same as the color of S(p) and lie on the right of S(p) have degree 2. Also, the degree of all the points on the left of p except the first point is 2. The degree of p and the first point is 1. As the number of red and blue points are same, all the points that lie on the right of S(p) must have degree 2. Thus, Π is a subgraph where each vertex has degree 2 except two special vertices whose degrees are 1. It follows that such a subgraph is a path that spans all the vertices. Also, all the edges on this path Π are bichromatic, and hence Π is a valid bichromatic Hamiltonian path. □

Next, we argue that the computed Hamiltonian path is non-crossing. The arcs that are added between points p and S(p) in the second step do not cross any other drawn edges, as p and S(p) are consecutive points. Also, the edges drawn above H do not cross any edges drawn below H. Moreover, the edges (p,Right(r)) and (Right(r),S(p)) (or (p,Right(b)) and (Right(b),S(p))) drawn in the same iteration do not cross each other. The following observation completes the claim.

Observation 6

Consider two edges (u,v) and (u′,v′) which are drawn as circular arcs above (resp. below) H and added to Π in different iterations. Then, either (u,v) is nested in (u′,v′), or (u′,v′) is nested in (u,v).

The algorithm can be implemented to run in linear time. Note that given the values of p, Right(r) and Right(b), each iteration of the algorithm can be performed in O(1) time. Thus, it is sufficient to show that the number of iterations is at most the number of points. We use three pointers to keep track of p, Right(r) and Right(b) in each iteration. In every iteration, we set S(p) to be the new p. Thus, the pointer to p always moves from left to right, i.e., it tracks each point at most once. Also, in an iteration, when we change Right(r) (resp. Right(b)) the red (resp. blue) point on its left becomes the new Right(r) (resp. Right(b)). Thus, the two pointers to Right(r) and Right(b) always move from right to left. Hence, the linear running time of the algorithm follows.

Theorem 2

For any set R of red points and B of blue points on a line with |R|=|B|, a non-crossing Hamiltonian path can be computed in linear time whose edges are circular arcs that lie above or below H.

3. Minimum spanning tree for collinear points
In this section, we study the Bichromatic spanning tree problem for collinear points. We proceed with the following definition.

Definition 3

Spanning tree for collinear points. Given a set R of n red points and a set B of m blue points all of which lie on a line, find a minimum weight geometric tree T in the plane such that each edge of T is represented by a circular arc that lies above H, each arc connects a red and a blue point, and T spans all the input points. The weight of an arc is given by the Euclidean distance of its endpoints. In the non-crossing version of the problem, one would like to compute such a tree so that the corresponding circular arcs are non-crossing.

First, we discuss a greedy linear time algorithm for computing an optimum, i.e., minimum-weight spanning tree, which potentially has crossings.

3.1. Spanning tree with crossings
Let p1,…,pn+m be the input points sorted in increasing order of their x coordinates. For each point pi, let col(pi) be the color of pi. We assume that the points are given in this order. Our algorithm has two steps. In the first step, we traverse the points in the sorted order and connect each point with its nearest opposite color point using an arc if it is not already connected. This gives us a set of components {C1,…,Ck} for k≤n, where each component contains at least one edge. For any component Ci,1≤i≤k, let l(Ci) and r(Ci) be the leftmost and the rightmost point, respectively. In the second step, we traverse the components from left to right. Consider the first two components C1 and C2. If col(r(C1))≠col(l(C1)), join C1 and C2 by an arc (r(C1),l(C2)). Otherwise, check the distance between r(C1) and its nearest opposite color point in C2, and the same for l(C2) and its nearest opposite color point in C1. Choose the shorter one to join C1 and C2. We repeat the same process for each consecutive pair of the remaining components. See Fig. 8 for an example.

Fig. 8
Download : Download high-res image (54KB)
Download : Download full-size image
Fig. 8. Figure demonstrating the execution of the algorithm on an example. The dashed arcs are added in the second step.

Note that after the first step each component Ci is a tree. In the second step, we add exactly one arc between a consecutive pair of components. Hence, the selected arcs form a valid spanning tree. Next, we move on towards proving the correctness of the algorithm. We need a few definitions for that. Consider any graph G=(V,E) and a subset of edges X in this graph. Also consider a subset S of vertices. An edge e is said to cross the cut (S,V∖S) or be across the cut (S,V∖S) if one of its endpoint is in S and another endpoint is in V∖S. X does not cross the cut (S,V∖S) if none of its edges cross the cut.

To prove the correctness of our algorithm, we need the following standard lemma [12] from the literature of minimum spanning tree.

Lemma 7 Cut property

[12] Suppose the set of edges X are part of a minimum spanning tree of G=(V,E). Pick any subset of vertices S for which X does not cross the cut (S,V∖S), and let e be a minimum weight edge across this cut. Then X∪{e} is part of some minimum spanning tree.

Next, we prove the optimality of our algorithm.

Lemma 8

At any moment, let X be the set of edges added by the algorithm so far. Then there is an optimum bichromatic spanning tree that contains X.

Proof

We prove this lemma by induction. In the base case, X=∅ and the lemma is vacuously true. Now, consider any moment when X is the set of edges added so far by the algorithm such that there is an optimum bichromatic spanning tree that contains X. Let e=(u,v) be the next bichromatic edge added by the algorithm. Now, there can be two cases. e is added in the first or second step.

Suppose e is added in the first step. We show that e is a minimum weight edge across a cut such that X does not cross the edges of this cut. Then the statement of the lemma holds by the Cut property of Lemma 7. Note that in the first step, we connect each point to its nearest opposite color point if it is not already connected. WLOG, suppose (u,v) was added corresponding to u. Then X does not cross the cut (V∖{u},{u}), as u is not yet connected. Also, the way we connect u to its nearest opposite color point, (u,v) must be a minimum weight edge across (V∖{u},{u}) in the (implicit) bichromatic input graph. Thus, the lemma holds in this case.

Next, suppose e=(u,v) is added in the second step. WLOG, let u be in the component Ci and v be in Ci+1. Consider the cut (P1,V∖P1) such that P1=∪j=1iCj. Then, by the way we select the edge across Ci and Ci+1, it follows that (u,v) must be a minimum weight (bichromatic) edge across the cut (P1,V∖P1). Now, consider any edge in X. If it is added in the first step, it cannot cross (P1,V∖P1), as it must lie within a component. Otherwise, the edge is added in the second step. But, in this case its endpoints should lie in P1, as we connect the consecutive components from left to right. By the Cut property, the lemma holds in this case as well. □

Now, we prove the key theorem of this subsection.

Theorem 3

For any set R of red points and B of blue points on a line, an optimum spanning tree can be computed in linear time.

Proof

To prove this theorem, we run the above algorithm. The correctness follows by Lemma 8 when the algorithm terminates. As the nearest neighbors (of opposite color) of all the points can be computed and stored in linear time given the sorted points, the algorithm can be executed in linear time. This completes the proof of the theorem. □

Next, we discuss the algorithm for the non-crossing case.

3.2. Non-crossing spanning tree
Let P1,P2,…,Pk be the alternating monochromatic chunks of points ordered from left to right for k∈{1,…,n}. Thus, the color of the points in Pi is different from the color of the points in Pi+1 for all 1≤i≤k−1. An arc (p,q) is called a consecutive (resp. non-consecutive) arc if it connects points from two consecutive (resp. non-consecutive) chunks. We start with the following observation.

Observation 9

Consider any point p∈Pi. If an arc (p,q) is contained in a minimum spanning tree, then either q∈Pi−1 or q∈Pi+1, i.e., (p,q) must be a consecutive arc.

Proof

Consider any minimum spanning tree T. Suppose there is a non-consecut ive arc in T. Consider an arc (p,q) in T such that (p,q) is a minimal non-consecutive arc, i.e., all arcs nested in (p,q) are consecutive arcs. We claim that it is always possible to replace (p,q) in T by a consecutive arc (p1,q1) such that T1=(T∖{(p,q)})∪{(p1,q1)} is a non-crossing spanning tree and the cost of T1 is strictly less than the cost of T. But, this leads to a contradiction, and hence there cannot be any non-consecutive arc in T. Next, we prove the claim.

Let p′ be the rightmost point between p and q (including p) that is connected to p in T∖{(p,q)} (see Fig. 9(a)). Let q′ be the point on the immediate right of p′. Note that q′ is connected to q in T∖{(p,q)}. If p′ and q′ are of different colors, then we replace (p,q) in T by the consecutive arc (p′,q′) (see Fig. 9(b)). There is no crossings in T1=(T∖{(p,q)})∪{(p′,q′)}, as p′ and q′ are consecutive points. T1 is a spanning tree, as all the points are contained in it and the two connected components in T∖{(p,q)} are joined in T1 by the arc (p′,q′). As (p′,q′) is a consecutive arc nested in the non-consecutive arc (p,q), the cost of T1 is strictly less than the cost of T.

Fig. 9
Download : Download high-res image (144KB)
Download : Download full-size image
Fig. 9. (a), (b) show the case when p′ and q′ are of different colors. (c), (d) show the case when p′ and q′ have same color. (b) shows the tree obtained after replacing (p,q) in (a) by (p′,q′). (d) shows the tree obtained after replacing (p,q) in (c) by (p′,q″).

Now, suppose p′ and q′ have the same color. If q≠q′, consider any arc e1 in T∖{(p,q)} which contains q′ as an endpoint and there is no other arc in T∖{(p,q)} containing q′ which nests e. Let e1=(q′,q″) (see Fig. 9(c)). The color of p′ and q″ are different, as e1 is bichromatic and p′ and q′ have the same color. Note that if q=q′, there might not be any arc in T∖{(p,q)} containing q′, and thus e1 cannot be defined. Similarly, if p≠p′, consider any arc e2 in T∖{(p,q)} which contains p′ as an endpoint and there is no other arc in T∖{(p,q)} containing p′ which nests e2. Let e2=(p′,p″) (see Fig. 9(c)). The color of q′ and p″ are different, as e2 is bichromatic and p′ and q′ have the same color. Note that if p=p′, there might not be any arc in T∖{(p,q)} containing p′, and thus e2 cannot be defined. But, at least one of e1 or e2 must be defined, as p=p′ and q=q′ cannot happen at the same time. Otherwise, (p,q) becomes consecutive. Wlog, suppose e1 exists. In this case, we replace (p,q) in T by the consecutive arc (p′,q″) (see Fig. 9(d)). There is no crossings in T′=(T∖{(p,q)})∪{(p′,q″)}, as (p′,q″) nests (q′,q″) and does not cross any arc in T nested in (p,q). T′ is a spanning tree, as all the points are contained in it and the two connected components in T∖{(p,q)} are joined in T′ by the arc (p′,q″). As (p′,q″) is a consecutive arc nested in the non-consecutive arc (p,q), the cost of T1 is strictly less than the cost of T. This concludes the proof of the claim and so the proof of the observation. □

As the spanning tree we want to compute is non-crossing, by the above observation, it follows that all the arcs between two consecutive chunks are nested.

Observation 10

Consider any two arcs (p1,q1) and (p2,q2) in a minimum non-crossing spanning tree such that p1,p2∈Pi and q1,q2∈Pi+1. Then, either (p2,q2) is nested in (p1,q1) or (p1,q1) is nested in (p2,q2).

Proof

This observation follows from the fact that if none of the two arcs is nested in the other, then they must cross. □

The above observation implies that the outermost arcs between consecutive chunks form a path (an umbrella) between the first and the last point and all the other arcs lie inside this umbrella (see Fig. 10). Next, we give a simple algorithm to compute an optimum spanning tree inside such an outermost arc. Suppose p0,p1,…,pl,…,pτ+1 are points in sorted order such that {p0,p1,…,pl}⊆Pi and {pl+1,…,pτ+1}⊆Pi+1. We would like to construct an optimum spanning tree of the points p0,p1,…,pl,…,pτ+1 which contains the arc (p0,pτ+1). Our algorithm is based on the following observation.

Fig. 10
Download : Download high-res image (24KB)
Download : Download full-size image
Fig. 10. Figure showing a spanning tree with the umbrella shown by dashed arcs.

Observation 11

Any optimum spanning tree that contains (p0,pτ+1) must also contain either (p0,pτ) or (p1,pτ+1) whichever has lower weight.

Proof

Consider any optimum non-crossing spanning tree T that contains the arc (p0,pτ+1). Also, suppose T does not contain a cheaper arc from {(p0,pτ),(p1, pτ+1)}. Otherwise, we are done with the proof. If T does not contain any arc from {(p0,pτ),(p1,pτ+1)}, then at least one of p1 or pτ cannot be connected to T without introducing any crossings. It follows that T contains the arc e from {(p0,pτ),(p1,pτ+1)} having the larger weight. But, in that case one can replace e in T by the cheaper arc e′. T′=(T∖{e})∪{e′} is a non-crossing spanning tree, as the only arc in T that e′ crosses is e which is now removed. But, then the weight of T′ is strictly lesser than that of T, which is a contradiction. Hence, the observation follows. □

In our algorithm to compute an optimum spanning tree inside an outermost arc (p0,pτ+1), first we select the shorter arc among (p0,pτ) and (p1,pτ+1). Then, we recursively solve the problem inside the selected arc by treating it as an outermost arc. This problem can be solved in linear time. We are going to use this algorithm as a subroutine in our algorithm for solving the general problem. Next, we give a Dynamic Programming (DP) based algorithm for this general problem. This algorithm essentially decides which outermost arcs to choose.

Let p1,p2,…,pn+m be the input points. Our DP algorithm incrementally computes a non-crossing spanning tree starting from the left connecting a new point in each step. Let P1={p1,…,pl} and P2={pl+1,…,pτ}. For l+1≤i≤n+m, let MST(i) be the subproblem of computing an optimum spanning tree for the prefix set of points {p1,…,pi}. We store the cost of MST(i) in table M indexed by i, where l+1≤i≤n+m. To initialize, for each l+1≤i≤τ, we compute the cost of an optimum spanning tree of {p1,…,pi}. Note that in this base case, any non-crossing spanning tree contains the outermost arc (p1,pi). Otherwise, either p1 or pi cannot be connected without crossing. Thus, we can compute an optimum spanning tree using the algorithm mentioned above for computing an optimum spanning tree inside an outermost arc. Thus, in the base case we compute all the entries of M with indices in {l+1,…,τ}.

Now, suppose we want to solve MST(i) for any i≥τ+1. Thus, we would like to connect a new point pi∈Pt+1 for some t≥2. We have already computed the entry M[q] for all l+1≤q<i. By Observation 9, in the solution spanning tree of MST(i), pi must be connected to a point ps of Pt, as pi∈Pt+1. For each such ps, we compute the cost of the spanning tree that contains the arc (ps,pi). In particular, the total cost is the sum of three costs: (i) the cost of the arc (ps,pi), (ii) the cost of connecting the points inside the open interval (ps,pi) and (iii) the cost of the optimum spanning tree of {p1,…,ps}. We select the point ps that minimizes the total cost. Thus,M[i]=mins:ps∈Pt⁡‖pips‖+cost(s,i)+M[s]. Here, ‖pips‖ is the cost of (ps,pi) and cost(s,i) is the cost of any optimum spanning tree inside the outermost arc (ps,pi). Note that one can precompute and store the costs cost(s,i) for all possible open intervals (ps,pi) in quadratic time using the algorithm for computing an optimum spanning tree inside an outermost arc. Thus, for a fixed ps, the sum of the three costs mentioned above can be computed using a constant number of table lookups. Thus, each step of this dynamic programming based algorithm takes linear time. Hence, an optimum spanning tree can be computed in quadratic time.

Theorem 4

For any set R of red points and B of blue points on a line, an optimum non-crossing spanning tree can be computed in quadratic time.

4. Minimum non-crossing matching for collinear points
Note that the fact that a minimum-weight bichromatic matching for points in general position is always non-crossing might not hold in the case of collinear points. Indeed, there are point sets for which no non-crossing matching exists if the edges are represented by segments. However, one can show that there is always a non-crossing matching of collinear points such that each matching edge is a circular arc drawn above the line. Again the weight of an arc is the Euclidean distance between its endpoints. We say that two arcs are pairwise disjoint if their endpoints are disjoint.

Definition 4

Non-crossing matching for collinear points. Given a set R of n red points and a set B of n blue points all of which lie on a line, find a set of n pairwise disjoint and non-crossing circular arcs in the plane of minimum total weight such that the arcs lie above H, each arc connects a red and a blue point, and the arcs span all the input points.

Using the bipartite matching algorithm due to Kaplan et al. [19] along with a simple postprocessing (already described in the introduction), one can immediately solve this problem in O(n2poly(log⁡n)) time. Here we design a simple algorithm with improved O(n) time complexity.

Let p1,p2,…,p2n be the input points sorted from left to right based on their x coordinates. We assume that the points are given in this order. For any point pi∈P, let col(pi) denote the color of pi. A subset of points Pi⊆P is called color-balanced if it contains an equal number of red and blue points. We traverse the points from left to right and seek the first balanced subset (denoted by P1). In order to obtain P1 we use a simple method. We start with the leftmost point p1 and maintain a counter C which is used to find the balanced subset and is initialized to 0 at the beginning. If col(p1)= red, we increase the value of C by 1, and decrease by 1, otherwise. Observe that we will get a balanced subset when the value of C becomes 0. Let P1⊆P be the first balanced subset containing 2k (for some k∈{1,…,n}) points. The remaining points P∖P1 also form a balanced subset since P contains exactly n red and n blue points. We prove the following lemma.

Lemma 12

Let P1⊆P be the first color-balanced subset of P and |P1|=2k. Then col(p1)≠col(p2k), and any minimum non-crossing perfect matching MP of P contains the edge (p1,p2k).

Proof

The first part of the lemma is clearly true, otherwise the value of the counter would not be 0 at p2k, which is the termination criteria to obtain the first balanced subset. Now, let us assume that MP does not contain the edge (p1,p2k). Then one of the following two situations can happen: 1) p1 and p2k are matched with two intermediate points from P1; 2) one or both of p1 and p2k are matched with points from P∖P1.

Case 1: p1 and p2k are matched with two intermediate points pτ and pℓ, respectively. Note ℓ>τ, otherwise the matching edges cross each other. We know that {p1,…,pτ} is not a balanced subset since P1 is the first balanced subset. Therefore, there exists at least one point pr (where 1<r<τ) that is matched with a point ps (where s>τ). In that case, the edge (pr,ps) will intersect (p1,pτ). Hence, we get a contradiction.

Case 2: Suppose both of p1 and p2k are matched with points from P∖P1 and no other point from {p2,…,p2k−1} is matched with any point from P∖P1. Then we can construct a new matching by adding the edge (p1,p2k) and by matching the two points in P∖P1. The new matching has lesser cost and is non-crossing; see Fig. 11(a). If any other point in {p2,…,p2k−1} (say px) is also matched with a point in P∖P1, then we know it must be of opposite color of either p1 or p2k, since col(p1)≠col(p2k). Hence, we can either add the edge (p1,px) or (px,p2k) and this reduces the total cost; see Fig. 11(b). The new matching might not be non-crossing. But, using similar argument one can remove all the crossings without increasing the cost. Thus, at the end we get a cheaper non-crossing matching, which contradicts the optimality of MP.

Fig. 11
Download : Download high-res image (52KB)
Download : Download full-size image
Fig. 11. Figure demonstrating the two situations in the case when both p1 and p2k are matched with points from P ∖ P1.

Now, if only one of p1 or p2k is matched with a point from P∖P1, let us assume p1, then we know there must be at least one other point (say px∈P1) that is also matched with a point from P∖P1, and col(p1)≠col(px). We can apply similar arguments as above to get a contradiction, which concludes the proof of the lemma. □

Now, we use Lemma 12 to proceed with the algorithm. First, we obtain the balanced subset P1, and match the points p1 and p2k by an arc and include the edge (p1,p2k) in MP. This edge partitions the point set into two color-balanced subsets, i.e., P2=P∖P1 and P1′=P1∖{p1,p2k}. On each of these subsets we recursively perform the same procedure. This process is repeated until each point of P is matched.

Due to Lemma 12, we know that every edge we choose in our algorithm must be part of the optimum solution, and no two edges cross each other. Next we show how to convert our recursive algorithm to a non-recursive one, in order to implement it in linear time. Consider the points in left to right order, and insert the leftmost point p1 onto a stack. Now, if the next point p2 is of same color as the stack top p1, then push p2 onto the stack; otherwise, match p1,p2 and remove p1 from the stack. Repeat this process until all points are considered. Indeed, this algorithm is same as the algorithm for matching of parentheses.

The above linear time algorithm has the same effect as the recursive algorithm. The only difference is that like before when p1 is matched with p2k, now all the points in between p1 and p2k are already matched. This can be proved by induction, as P1′=P1∖{p1,p2k} is also a color-balanced set. We conclude with the following theorem.

Theorem 5

For any set R of red points and B of blue points on a line with |R|=|B|, an optimum non-crossing matching can be computed in linear time.

5. Conclusion and open problems
In this paper, we have studied three classical graph problems on geometric graphs induced by bichromatic points for collinear points. We have shown that almost all of these problems can be solved in linear time in this setting. We note that the results for circular-arc edges trivially extend to other types of edges drawn in a topologically equivalent way within the same halfplane, e.g., 1-bend polylines. One problem that is left open by our work is the complexity of Bichromatic TSP for collinear points. We have shown that if a Hamiltonian path is forced to lie above the line, then such a path might not exist. One interesting question is to design an algorithm for finding a path in this setting if one exists. Another interesting open problem is to design a subquadratic time algorithm for computing a non-crossing spanning tree.