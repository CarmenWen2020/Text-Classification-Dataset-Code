Abstract
Monotone Boolean circuits are circuits where each gate is either an AND gate or an OR gate. In other words, negation gates are not allowed on monotone circuits. This class of circuits has sparked the attention of researchers working in several subfields of combinatorics and complexity theory. In this work, we consider the notion of certification-width of a monotone Boolean circuit, a complexity measure that intuitively quantifies the minimum number of edges that need to be traversed by a minimal set of positive weight inputs in order to certify that a given circuit is satisfied. We call the problem of computing this invariant as Succinct Monotone Circuit Certification (SMCC). We prove that SMCC is NP-complete even when the input monotone circuit is planar. Subsequently, we show that k-SMCC, the problem parameterized by the size of the solution, is W[1]-hard, but still in W[P]. In contrast, we show that k-SMCC is fixed-parameter tractable when restricted to monotone circuits of bounded genus.

Keywords
Monotone circuits
Planarity
Genus
FPT
Treewidth

1. Introduction
Boolean circuits are one of the earliest combinatorial formalisms for the representation of Boolean functions. Besides being a fundamental object of study in classical complexity theory, Boolean circuits also play a central role in the field of parameterized complexity [10]. More specifically, while the satisfiability problem for general Boolean circuits can be used to define the class NP, the satisfiability problem for Boolean circuits of bounded weft can be used to define the levels of the W-hierarchy [10]. An important, and well-studied, subclass of Boolean circuits is the class of monotone Boolean circuits, i.e., circuits where only AND and OR gates are allowed. While the standard satisfiability problem for monotone Boolean circuits is trivial, since the all-ones vector is always a satisfying assignment, some weighted versions of satisfiability problems are still interesting in this setting. One of these problems is the Weighted Monotone Circuit Satisfiability (WMCS) problem, where we are given a monotone Boolean circuit C as input, and the goal is to find a minimum-weight satisfying assignment for the inputs of C [6], [16], [19]. The WMCS is particularly relevant in the field of circuit design, since the minimum number of inputs necessary to make a monotone circuit evaluate to true is a parameter that is often taken into consideration [18].

In this paper, we deal with the notion of succinct certificates for monotone Boolean circuits. Given a monotone circuit C, a succinct certificate for C is a connected sub-circuit of C with a minimal set of edges that is sufficient to ensure that C is satisfiable. Just like circuit size and circuit depth, the minimum size of a succinct certificate is an interesting complexity measure. Additionally, a succinct certificate may be seen as a minimal map to be followed by a satisfying assignment. This map may find applications in the field of circuit design and may be used as a way of representing solutions to problems modeled through monotone circuits. In the literature similar structures are known as accepting subtree [33], positive proof [9], and proving circuit [21].

We study the complexity of computing the size of a minimum succinct certificate of a given monotone circuit C. We call this invariant the certification-width of C, and name the problem of computing the value of this invariant as the Succinct Monotone Circuit Certification (SMCC) problem. The problem under consideration is both of theoretical and practical relevance. From a theoretic perspective, the minimum size of a succinct certificate naturally gives information about the complexity of a circuit. Therefore, determining the underlying structure that makes SMCC (fixed-parameter) tractable is interesting from the perspective of complexity theory. From a practical perspective, SMCC can be applied in many problem-reduction representations [22], since monotone circuits can be seen as unweighted And/Or graphs [28], [29].

The notion of planarity is well-explored in graph theory and has significant relevance in the field of circuit analysis. In particular, VLSI (Very Large-Scale Integration) circuits, which are widely applied in electronics and engineering, are typically modeled by planar graphs. In addition, there are several studies on circuits and satisfiability problems defined on certain structures that are planar or that satisfy certain structural properties (see [2], [4], [16], [17], [18], [19], [27], [30], [31]).

We show that SMCC is NP-hard when the input monotone circuit is planar, and it is W[1]-hard, but in W[P], when parameterized by solution size. Subsequently, we present a polynomial-time algorithm that takes a monotone circuit as input and either solves the instance or bounds the diameter of the input; then using the notion of contraction obstructions for treewidth we are able to conclude that the treewidth of the resulting circuit is bounded by k+g, where k is the solution size and g is the genus of the input circuit. Thus, by using such a win/win approach and applying a dynamic programming algorithm we solve SMCC in FPT time when parameterized by k+g. This result also implies that SMCC can be solved in time 2O(k)⋅n+m on planar circuits.

An extended abstract of this paper has been presented in COCOON 2020 [1].

2. Preliminaries
We use standard graph-theoretic and parameterized complexity notation, and we refer the reader to [10], [7] for any undefined notation.

A Boolean circuit is a combinatorial model for the representation of Boolean functions. We formalize the notion of a Boolean circuit according to Definition 1. In general, a circuit can have multiples outputs. Nevertheless, for convenience, we will adopt the following definition.

Definition 1

A Boolean circuit is a directed acyclic graph C(V,E) having only one sink, where the set of vertices V is partitioned into (I,G,{vout}): (i) a set of inputs I={i1,i2,…} composed of the vertices of in-degree 0; (ii) a set of gates G={g1,g2,…}, which are vertices labeled with Boolean operators; (iii) and the single output (sink) vertex vout with out-degree equal to 0 and also labeled with a Boolean operator. The input vertices represent Boolean variables that can take values from {0,1} ({false, true}, depending on the conventions), and the label/operator of a gate or output vertex w is given by f(w).

Note that we are considering general circuits with no restrictions on the number of in-neighbors and out-neighbors. Additionally, in this work, we only deal with monotone circuits. Also, for a Boolean circuit C(V,E), in this work, we let n=|V(C)| and m=|E(C)|.

Definition 2

A monotone circuit is a Boolean circuit where the Boolean operators allowed are in {AND,OR}.

Definition 3

An assignment of C is a vector X=[x1,x2,…,x|I|] of values for the set of inputs I, where for each j, xj∈{false,true} is the value assigned to input ij. We say that X is a satisfying assignment if the circuit C evaluates to true when given x as input.

In Fig. 1a, we have an example of a circuit C with six inputs i1,i2,…,i6, four gates g1,g2,g3,g4 and the output vertex vout. Fig. 1b shows an example of the results of an assignment X to the circuit presented in Fig. 1a. In this example, the function AND of vout returns true, thus, X is a satisfying assignment according to Definition 3.

Fig. 1
Download : Download high-res image (189KB)
Download : Download full-size image
Fig. 1. Graph representation of a circuit and a satisfying assignment for it.

We denote by X→C the adapted directed graph in which the values of X were assigned to I, and the label of the gates are replaced by the returned values of their respective functions (see Fig. 1b).

The directions of the edges represent inputs to functions of the gates. When all in-edges of a gate gj have values assigned to them, then gj will be evaluated according to the operator f(gj) under these input values. We note that the value of an input may not reach vout, for example, in Fig. 1b, the assignment sets i5 to true. However, this value cannot reach vout because f(g2) was not satisfied. This situation brings us another important definition: the critical edges.

Definition 4

Given a monotone circuit C with a satisfying assignment X, an edge (vj,vk) is considered critical to X→C if vj evaluates to true and there is a path P from vk to vout in which all gates along P (including vout) also evaluate to true.

According to Definition 4, in Fig. 1 the edge (i5,g2) is not critical while (i2,g1), (i3,g3), (i4,g4), (g1,g3), (g3,vout) and (g4,vout) are critical edges in X→C. This motivates the notion of positive certificate stated in Definition 5.

Definition 5

Given a monotone circuit C, and a satisfying assignment X of C, a positive certificate for X→C is a connected subgraph of C formed by the critical edges and their respective vertices.

Since a positive certificate may have redundant edges, next, we present the notion of succinct certificate; and certification-width of C.

Definition 6

Given a monotone circuit C, and a satisfying assignment X of C, a succinct certificate for X→C, is a connected subgraph SCX→C of its positive certificate such that:

•
vout is a vertex of SCX→C; and

•
for every vertex v of SCX→C holds that

–
if f(v)=AND, then every in-edge of v is in SCX→C;

–
if f(v)=OR, then exactly one in-edge of v is in SCX→C.

The size of a succinct certificate SCX→C is the number of edges of SCX→C.
In the context of counting complexity and arithmetic circuits, the succinct certificates are also known as proving circuits [21].

Definition 7

The certification-width of a monotone circuit C is the minimum size among all possible succinct certificates on all satisfying assignments of C.

We remark that there are similarities between the notions of certification-width and the energy complexity of a circuit C, which is defined as the number of gates evaluating to true among all assignments to C (see [32]).

Now, we have all elements to describe our main problem.


Download : Download high-res image (37KB)
Download : Download full-size image
We denote by k-SMCC the parameterized version of Succinct Monotone Circuit Certification where k is the parameter.
Similar notions of succinct certificate and certification-width were introduced in [25], in that context, defined as accepting computation tree and tree-size of a Alternating Turing Machines (ATM). According to W. L. Ruzzo [25], the main motivation of these notions was defining a novel complexity measure as an abstraction that would provide a spectrum of complexity classes intermediate between non-determinism and full alternation In 1989, H. Venkateswara [34] defined the concept of accepting subtree of a Boolean circuit as an analogy to the notion of accepting computation tree for ATMs. As can be seen in [33], the notion of accepting subtree of a Boolean circuit is similar to what we propose to call a succinct certificate. Also, there are some works which refers to such structures as (positive) proof tree (see [9], [20]). Besides, succinct certificates are also known as proving (sub-)circuits (see [5], [21]). Note that this kind of “witness for acceptance” gives an intuitive and natural idea of important features in different frameworks from complexity theory (see [33], [9], [25], [34], [20]). Nevertheless, these works typically address the relation between the size of the certificate and the characterization of complexity classes. In this paper, we address another direction, we deal with the time complexity of computing such structures with minimum size for (monotone) Boolean circuits.

3. NP-completeness on planar circuits
Now, we dedicate our attention to SMCC restricted to planar circuits. Clearly, SMCC is in NP. Next, we show its NP-hardness. For that, we will use a reduction from Planar Vertex Cover.


Download : Download high-res image (37KB)
Download : Download full-size image
Theorem 1

SMCC is NP-complete even restricted to planar circuits.

Proof

Given a circuit C and an integer k, forming an instance of SMCC, a connected subgraph of C having at most k edges and satisfying Definition 6 can be seen as a certificate for the “yes” answer of this instance. Since it is easy to verify in polynomial time the conditions described in Definition 6, it holds that SMCC is in NP.

In order to prove its NP-hardness, we present a reduction from Planar Vertex Cover. First, consider the following preprocessing: Let (H,c′) be an instance of Planar Vertex Cover. By subdividing twice each edge of H, we obtain a graph G where each edge e=(ab) of H is replaced by a P4 ab′a′b, where a′ and b′ are new vertices. Notice that G is planar; H has a vertex cover of size c′ if and only if G has a vertex cover of size c=c′+|E(H)|; and given a planar embedding of G, the common boundary of any pair of adjacent faces of G contains at least three edges.

From a fixed planar embedding of the instance (G,c) of Planar Vertex Cover, we proceed with the reduction. We will construct an instance (C,k) of SMCC where C is a planar monotone circuit, and k is the target size of the solution. From the original structure of G, we apply the following:

1.
Firstly, set V(C)=V(G);

2.
for each vertex vi∈V(G), create an input vertex viin, assign f(vi)=AND, and add a directed edge (viin,vi);

3.
for each edge ei=(u,v)∈E(G), create a vertex veicover such that f(veicover)=OR, and create the directed edges (v,veicover) and (u,veicover). This step guarantees that if veicover is in the succinct certification, then either v or u will also be on the certificate.

Notice that C is still planar. Now, preserving the planarity, we will ensure that every veicover is in any succinct certification of C as follows:

4.
create an output vertex vout such that f(vout)=AND;

5.
for each vertex veicover which are in the external face of G, create one directed edge from veicover to vout;

Let DG be the dual graph of G, and denote by f1 the vertex representing the external face of G. Let TDG be the spanning tree of DG obtained from a breadth-first search of DG rooted at f1. In a top-down manner, according to a level-order traversal of TDG, we visit each edge e=(fi,fj) of TDG, applying the following:

6.
Let fj be a child of fi in TDG;

By construction of G, it follows that the boundary between fi and fj contains at least three edges, at least one of which being between vertices a′ and b′ that do not exist in H;

Thus, create a vertex vfj, add edges from vfj to such a′ and b′; and for each veℓcover in the face fj that does not reach vout, yet, add an edge from veℓcover to vfj; after that, if vfj has in-degree greater than 0, then set f(vfj)=AND, otherwise vfj is an input vertex;

7.
Finally, set k=c+2⋅|E(G)|+|V(TDG)|−1.

Given a vertex cover S of G with c vertices, without loss of generality, we can assume that S does not contain pairs of adjacent vertices that do not belong to V(H). By setting 1 (true) to the corresponding inputs of S in C, in exactly c edges flows true from vertices viin to its out-neighbor vi; from each vi assigned with true flow positive values to each vecover such that e is an out-edge of vi. Since S is a vertex cover, each vecover receives at least one positive value, which implies that every vertex vfj evaluates to true, and vout also evaluate to true. Thus, C has a succinct certificate SC where all in-edges of vout are in SC; each in-neighbor of vout has as in-neighbor one vertex of S in SC; since the vertices representing faces and vertices of G have the label AND, by construction, every vecover is in SC and has exactly one out-edge in SC; Given that S does not contain pairs of adjacent vertices that do not belong to V(H), each vertex vfj also has exactly one out-neighbor in SC; and as every vecover is labeled OR, one can construct SC in such a way that vecover has as in-neighbor exactly one vertex in S. Thus, SC has size equal to k=c+2⋅|E(G)|+|V(TDG)|−1. (Namely, c in-edges of viin vertices; one in-edge and one out-edge for each vecover; one out-edge for each vertex vfj.)

Fig. 4 illustrates vertex covers of graphs G and H shown in Fig. 2, and the succinct certificate SC of the correspondent circuit C.

Fig. 4
Download : Download high-res image (564KB)
Download : Download full-size image
Fig. 4. Consequences of a minimum vertex cover of H in the circuit C. Recall that each blue vertex is a OR-vertex, vecover, representing an edge e of G, while the other vertices are AND-vertices.

Conversely, suppose that C has a succinct certificate SC with at most k edges. By construction, all |E(G)| vertices vecover are in SC, and each vecover in SC demands exactly two edges in SC (one in-going and another out-going), which form a set of 2⋅|E(G)| edges. Also, by construction, we know that all vfi vertices (created in step 6) must be in SC (recall that these vertices are responsible to connect every inner vecover in a path to vout). The vertices vfi demand at least |V(TDG)|−1 other edges in SC, at least one out-edge by vertex. Note that the in-edges of a vertex vfi have already been considered as out-edges of vecover vertices. Thus, since SC has size at most k=c+2⋅|E(G)|+|V(TDG)|−1, remains at most c edges to be considered in SC. Therefore, there are at most c input vertices viin in SC. At this point, one can construct a vertex set S of G with cardinality at most c by adding vi in S if its corresponding input viin is in SC. Finally, as each vecover vertex is in SC, at least one of its out-neighbors (endpoints of e) and corresponding input are also in SC, which implies that S is a vertex cover of size at most c of G. □

4. Parameterized complexity
In this section, we analyze the parameterized complexity of SMCC. We refer the reader to [10], [7] for basic background on parameterized complexity, and we recall here only some basic definitions.

A parameterized problem is a decision problem whose instances are pairs (x,k)∈Σ⁎×N, where k is called the parameter. A parameterized problem is fixed-parameter tractable (FPT) if there exists an algorithm A, a computable function f, and a constant c such that given an instance I=(x,k), A (called an FPT algorithm) correctly decides whether I∈L in time bounded by f(k)⋅|I|c. The discovery of FPT algorithms fulfills the objective of solving problems more efficiently with exact algorithms spending less time than a brute force algorithm with O(|I|f(k)) time.

A parameterized problem is slice-wise polynomial (XP) if there exists an algorithm A and two computable functions f,g such that given an instance I=(x,k), A (called an XP algorithm) correctly decides whether I∈L in time bounded by f(k)⋅|I|g(k). Within parameterized problems, the class W[1] may be seen as the parameterized equivalent to the class NP of classical optimization problems. Without entering into details (see [10], [7] for the formal definitions), a parameterized problem being W[1]-hard can be seen as a strong evidence that this problem is not FPT. The canonical example of W[1]-hard problem is Clique parameterized by the size of the solution.

To transfer W[1]-hardness from one problem to another, one uses a parameterized reduction, which given an input I=(x,k) of the source problem, computes in time f(k)⋅|I|c, for some computable function f and a constant c, an equivalent instance I′=(x′,k′) of the target problem, such that k′ is bounded by a function depending only on k. Equivalently, a problem is W[1]-hard if there is a parameterized reduction from Clique parameterized by the size of the solution.

In addition to the W[1] class, some classes of parameterized problems are defined according to their parameterized intractability level. These classes are organized in the so-called W-hierarchy FPT ⊆ W[1] ⊆ W[2] ⊆ … ⊆ W[P] ⊆ XP, and it is conjectured that each of the containments is proper [10]. If P = NP, then the hierarchy collapses [10].

Next, we analyze the hardness of SMCC regarding the W-hierarchy by revisiting some results of [26] in the context of And/Or graphs. First, we present the Weighted Circuit Satisfiability problem, a well-known W[P]-complete problem [10].


Download : Download high-res image (37KB)
Download : Download full-size image
The W[P]-membership of k-SMCC follows from a reduction to Weighted Circuit Satisfiability.
Lemma 1

k-SMCC is in W[P].

Proof

Let C be a instance of k-SMCC, we construct a decision circuit D as follows:

1.
For each edge e of C, create (in D) an input ie;

2.
for each non-input AND-gate (resp. OR-gate) v of C, create an AND-gate (resp. OR-gate) gv in D;

3.
if there is an edge e from an input-vertex vi to vj, add an edge from ie to gvj;

4.
if there is an edge e to a vertex vi from a non-input vertex vj, create an AND-gate ge⁎, add edges to ge⁎ from ie and gvj, and add an edge to gvi from ge⁎.

In summary, the inputs of D represent edges outgoing from inputs/gates of C and the gates gv created in step 2, a priori, mimic the same structure of C. In addition, the AND-gates ge⁎ and its respective edges added in step 4, force the evaluation to true of the input ie if the path corresponding to the edge e of C needs to be used in D. In other words, an edge e from a non-input vertex vj to a vertex vi in C is represented by a gadget formed by the path gvj,ge⁎,gvi plus the edge ie,ge⁎. Thus, the evaluation to true of ge⁎ depends of the previous evaluation to true of gvj (preserving the structure of the succinct certificate) and also of the evaluation to true of ie, which produces the correspondence between using e in a succinct certificate of C with the evaluation to true of ie in D. Hence, it holds that: if C has a succinct certificate with k edges, then by assigning exactly the k corresponding inputs of D as true, one can obtain a satisfying assignment with weight k for D; conversely, if D has a satisfying assignment A with weight k then C has a succinct certificate induced by the set of edges {e∈E(C):ie evaluates to true in A}. □

Recall that W[P] ⊆ XP. Therefore, the membership shown in Lemma 1 is a result stronger than an XP algorithm.

Next, we prove the W[1]-hardness of k-SMCC using a reduction from Multicolored Clique, a well-known W[1]-complete problem [12].


Download : Download high-res image (40KB)
Download : Download full-size image
Theorem 2

k-SMCC is W[1]-hard.

Proof

Let (Q,c) be an instance of Multicolored Clique and let V1,V2,…,Vc be the color classes of Q. Without loss of generality, we consider that each vertex in Vi has at least one neighbor in Vj(i≠j). We construct an instance (C,k) of k-SMCC as follows:

1.
create an output gate vout in C and set f(vout)=AND;

2.
for each color ci of Q, create a gate wi with f(wi)=OR and add an edge from wi to vout;

3.
for each color class Vi of Q, create copies Vi1,Vi2,Vi3 and Vi4 in C;

4.
add edges from each vertex in Vi4 to wi;

5.
let v1,v2,v3 and v4 be the copies of a vertex v∈V(Q); add edges (v1,v2),(v2,v3) and (v3,v4) to G; set Vi1 as the input set; and assign f(v2)=f(v3)=OR and f(v4)=AND;

6.
for each vertex v4∈Vi4(1≤i≤c)), create c−1 new or-in-neighbors av4j(1≤j≤c and i≠j), and add an edge to av4j from a vertex u2∈Vj2 if and only if v and u are neighbors in Q;

7.
finally, set k=2c2+3c.

If Q contains a multicolored clique K such that |K|=c, then it is possible to construct a succinct certificate SC of C with k edges as follows: (a) vout and all of its in-edges belong to SC; (b) for each OR-gate wi∈V(SC), include in SC an edge (v4,wi) of C such that v∈K; (c) for each v4∈V(SC), add all of its in-edges to SC; (d) for each v3∈V(SC) add its in-edge to SC; (e) for each v2∈V(SC) add its in-edge to SC; (f) finally, for each av4j in SC, choose an in-edge (u2,av4j) to be added to SC such that u∈K. Thus, SC has exactly k=2c2+3c.

Conversely, if C has a succinct certificate SC with k=2c2+3c edges, then it is possible to obtain a multicolored clique K of Q as follows: a vertex v of Q belongs to K if and only if v2 belongs to V(SC). Since, by construction, any succinct certificate of C has at least k edges, if SC has k=2c2+3c edges, then SC has only c vertices of type v2, and for each pair v2,au4j(u≠v and v2∈Vj2) in SC there is an edge between them in Q, implying that K is a multicolored clique of size c of Q. □

4.1. Bounding the treewidth of monotone circuits with bounded genus
In this section, we bound the treewidth of bounded genus circuits. The strategy adopted in this section is based on the grid minor theorems proposed by Robertson and Seymour [24], [23], see also [15].

First consider the following definitions.

A graph G has genus g if it can be drawn without crossings on a surface of genus g (a sphere with g handles), but not on a surface of genus g−1. We refer the reader to [14] for more information on the genus of a graph. We consider the genus of a circuit as the genus of its underlying undirected graph.

Definition 8

A tree decomposition of an undirected graph G is a pair T=(T,{Xt}t∈V(T)) such that T is a tree where each node t is assigned to a set of vertices Xt⊆V(G), called bags, according to the following conditions:

•
⋃t∈V(T)Xt=V(G), i.e. every vertex must be in at least one bag;

•
for each (u,v)∈E(G), there exist a node t such that {u,v}⊆Xt;

•
for each v∈V(G), the set Tv={t∈V(T):v∈Xt} spans a connected subtree of T.

The width tw(T) of a tree decomposition T is the size of the largest bag of T minus one. The treewidth of G is the minimum treewidth among all its possible tree decompositions.

Definition 9

A graph H is a minor of a graph G if H can be constructed from G by deleting vertices or edges, and contracting edges.

Definition 10

A grid p×q, denoted by ⊞p×q or ⊞p when p=q, is a graph whose set of vertices is V(G)={vij|(i,j)∈{1,2,…,p}×{1,2,…,q}} and there is an edge (vij,vi′j′)∈E(G) exactly if |i′−i|=1 or |j′−j|=1, but not both.

Theorem 3

Excluded Grid Theorem [23]
Let t be a non-negative integer. Then every planar graph G of treewidth at least 9t/2 contains ⊞t as a minor.

Definition 11

[24]
For every face F of a planar embedding M, we define d(F) to be the minimum value of r such that there is a sequence F0,F1,…,Fr of faces of M, where F0 is the external face, F=Fr, and for 1≤j≤r there is a vertex v incident with both Fj−1 and Fj. The radius ρ(M) of M is the minimum value r such that d(F)≤r for all faces F of M. The radius of a planar graph is the minimum across all radii of its planar embeddings.

From the Excluded Grid Theorem, it is easy to see that there is a connection between the radius of a planar graph and its treewidth. In [24], Robertson and Seymour presented a bound for the treewidth of a planar graph with respect to its radius.

Theorem 4

Radius Theorem [24]
If G is planar and has radius at most r, then its treewidth is at most 3r+1.

Using Theorem 4 we are able to either solve k-SMCC on planar circuits or output an equivalent instance C′ with treewidth bounded by a function of k. First consider the following.

Lemma 2

Let (C,k) be an instance of SMCC with n=|V(C)| and m=|E(C)|. There is an algorithm that in O(n+m) time either solves (C,k) or outputs an instance (C′,k) of SMCC such that:

•
(C′,k) is an yes-instance of SMCC if and only if (C,k) is also an yes-instance;

•
C′ is an induced subcircuit of a circuit C⁎ that has diameter at most 2k and it is also an induced subcircuit of C.

Proof

Let (C,k) be an instance of SMCC. Firstly, we apply to C the following preprocessing steps to generate a graph C′:

1.
For each vertex vj such that f(vj)=AND, if |Nvj−|>k, then vj is deleted;

2.
delete every vertex which is at a distance greater than k from vout;

3.
delete all vertices whose in-degree became equal to 0 (the original inputs are not affected by this step);

4.
delete all AND-vertices that lost one of its in-neighbors;

5.
repeat steps 3 and 4 as long as possible;

6.
delete all vertices that have become unreachable from vout;

7.
if C′=∅, then we conclude that (C,k) is a no-instance of SMCC.

It is easy to see that the rules described above are safe. Thus, after this preprocessing, if C′≠∅, then C′ is an induced subgraph of the circuit C⁎, obtained after applying Step 2, which has only vertices at a distance at most k from vout. Now, observe that steps 1-4 and 6-7 can be performed in O(V(C)+E(C)) time (one can use breadth-first search from vout to calculate the distances and degrees); also, note that although Step 5 is described as a loop of previous steps, since the circuit is acyclic, the vertices to be removed by this “Repeat...until” procedure can be identified efficiently by traversing the vertices of C in reverse sequence to a topological order, which takes O(V(C)+E(C)) time. □

Regarding Lemma 2, notice that, after Step 2, the underlying undirected graph of the current circuit has diameter at most 2k, which implies that if it is planar, then it also has a radius at most 2k. Thus, by Theorem 4, it follows that the underlying undirected graph of such a circuit has treewidth at most 6k+1. Since the property of having bounded treewidth is hereditary, it holds that the output circuit C′ also has treewidth at most 6k+1.

Note that the property of having bounded diameter is not hereditary. However, if it is desired that C′ also has bounded diameter, one can modify Step 5 to repeat steps 2-4, so the following holds.

Lemma 3

Let (C,k) be an instance of SMCC. There is an algorithm that in O(n2+nm) time either solves (C,k) or outputs an instance (C′,k) of SMCC having depth at most k, such that (C′,k) is an yes-instance of SMCC if and only if (C,k) is also an yes-instance.

Next, we extend the previous reasoning for bounded genus graphs.

According to [16], for an edge e=uv of a graph G, contracting e means removing the two vertices u and v from G, replacing them with a new vertex w, and for every vertex y in the neighborhood of v or u in G, adding in the new graph an edge wy whose multiplicity is the sum of the multiplicities of the edges of G between v and y and between u and y. If in the above definition we do not sum up multiplicities, and if the initial graph G is a simple graph, then we call the operation simple contraction, or for short s-contraction. Given a vertex-set S⊆V(G) such that the subgraph of G induced by S, denoted G[S], is connected, contracting S means contracting the edges between the vertices in S to obtain a single vertex at the end. We say that a graph H is an s-contraction of a graph G if H can be obtained after applying to G a (possibly empty) sequence of edge s-contractions.

The following is a construction presented in [13] and [16]. Consider an (r×r)-grid. A corner vertex of the grid is a vertex of the grid of degree 2. By Γr we denote the graph obtained from the (r×r)-grid as follows: construct first a graph called Γr′ by triangulating all internal faces of the (r×r)-grid such that all internal vertices of the grid are of degree 6, and all non-corner external vertices of the grid are of degree 4 (Γr′ is unique up to isomorphism). Two of the corners of the initial grid have degree 2 in Γr′; let x be one of them. Now Γr is obtained from Γr′ by adding all the edges having x as an endpoint and a vertex of the external face of the grid that is not already a neighbor of x as the other endpoint (see Fig. 5 for an illustration of Γ7). Observe again that Γr′ is unique up to isomorphism. The following is a lemma from [16] implied from Lemma 6 in [13].

Fig. 5
Download : Download high-res image (102KB)
Download : Download full-size image
Fig. 5. Graph Γ7.

Lemma 4

Lemma 4.5 in [16]
Let G be a graph of genus g, and let r be any positive integer. If G excludes Γr as an s-contraction, then the treewidth of G is at most (2r+4)⋅(g+1)3/2.

Lemma 5

Let C′ be the circuit obtained from Lemma 2. It holds that C′ has treewidth at most (4k+10)⋅(g+1)3/2, where g is the genus of C′.

Proof

First, notice that for each vertex u of a Γ2k+3 there is another vertex v such that the distance between u and v is at least k+1. Now, suppose that C⁎, the circuit obtained after Step 2, has Γ2k+3 as an s-contraction, and let u be a vertex of a Γ2k+3 such that u is either vout or a vertex obtained by contracting S containing vout. Since there is a vertex v such that the distance between u and v is at least k+1, it holds that C⁎ does not have depth greater than k, which is a contradiction. Thus, by Lemma 4 we have that the treewidth of C⁎ is at most (4k+10)⋅(g+1)3/2. Therefore, as the properties of having bounded genus, as well as bounded treewidth, are hereditary, then C′ also has treewidth at most (4k+10)⋅(g+1)3/2. □

4.2. Dynamic programming on tree decomposition
From Lemma 5, in order to solve k-SMCC on bounded genus graphs, it is enough to present an FPT algorithm parameterized by the treewidth of C.

In general, for a tree decomposition (T,{Xt}t∈V(T)) it is common to distinguish one vertex r of T which will be the root of T. This introduces natural parent-child and ancestor-descendant relations in the tree T [7]. To design dynamic programmings based on tree decompositions, it is useful to obtain rooted tree decompositions that satisfy some auxiliary conditions. Such decompositions are so-called nice tree decompositions, and they are defined as follows:

Definition 12

A rooted tree decomposition T=(T,{Xt}t∈V(T)) is nice if the following conditions are satisfied:

•
The root bag Xr and the leaf bags are empty;

•
Every non-leaf bag of T is of one of the following types:

–
Introduce node - a node t with exactly one child t′ such that Xt=Xt′∪{v} for some v∉Xt′; we say that v is introduced at t.

–
Forget node - a node t with exactly one child t′ such that Xt=Xt′﹨{v} for some v∈Xt′; we say that v is forgotten at t.

–
Join node - a node t with two children t1 and t2 such that Xt=Xt1=Xt2.

Additionally, an extended nice tree decomposition is an extended version of a nice tree decomposition where we also have introduce edge nodes. An Introduce edge node is a node t, with exactly one child t′ such that Xt=Xt′, and labeled with an edge (u,v)∈E(G) such that u,v∈Xt; we say that (u,v) is introduced at t. Besides, we assume that each edge of a graph G is introduced precisely once in an extended nice tree decomposition of G.

Based on the following results, we can assume, without loss of generality, that we are given a nice tree decomposition of G.

Theorem 5

[3] There exists an algorithm that, given an n-vertex graph G and an integer k, runs in time 2O(k)×n and either outputs that the treewidth of G is larger than k, or constructs a tree decomposition of G of width at most 5k+4.

Lemma 6

[7] Given a tree decomposition (T,{Xt}t∈V(T)) of G of width at most k, one can in time O(k2⋅max⁡(|V(T)|,|V(G)|)) compute a nice tree decomposition of G with at most O(k⋅|V(G)|) nodes and width at most k.

Theorem 6

k-SMCC can be solved in time 2O(tw)⋅n, where tw is the treewidth of the input.

Proof

Let C be a planar monotone circuit and T=(T,{Xt}t∈V(T)) be an extended nice tree decomposition of C. For convenience, we add the vertex vout to every bag of T; thus, the treewidth of T is increased by 1. The root bag Xr and the leaves are equal to {vout}. This change ensures that for every bag, there exists at least one possible subsolution. It is worth to remember that all succinct certification necessarily contains vout.

Another preprocessing must be made: The introduce edge nodes will be labeled according to Boolean functions of the head of the directed edge, thus, we have “introduce edge of an AND-gate” and “introduce edge of an OR-gate”. The same alteration is applied to forget nodes, i.e., we have “forget node of AND-gate” and “forget node of OR-gate”. This separation of nodes help us to organize the subproblems according to the previous subsolutions already computed.

Let TXt be the subtree of T rooted by Xt and GXt be the graph/circuit having TXt as tree decomposition, and formed by edges already introduced in TXt.

Each subproblem of the dynamic programming is represented by c[t,X,B], which denotes the minimum number of edges of a succinct subcircuit of GXt, where X⊆Xt is the set of vertices of Xt in such a subcircuit, and B is a Boolean vector of size at most |X| such that for each v∈X with f(v)=OR it holds that if B[v]=1, then the OR-gate v has an in-edge in the subcircuit and B[v]=0 means that v does not yet have an out-edge in the subcircuit.

Note that since vout belongs to every solution, we do not need to handle the connectivity issue, as this is a guaranteed property of any minimal solution. Therefore, the optimal solution can be found at c[t,{vout},B] where B=∅ if vout is an AND-gate; otherwise B[vout]=1. The recurrences are presented below.

Leaf node – Let t′ be a leaf node, then Xt={vout} which gives us two possibilities:(1)c[t,X,B]={+∞,if(vout∉X)or(f(vout)=ORandB[vout]=1)0,otherwise

Introduce vertex node – Let t be an introduce vertex node with exactly one child t′ such that Xt=Xt′∪{v}. Since no edge of v was introduced yet, v is isolated in GXt. The recurrence in Eq. (2) resumes the subproblems.(2)c[t,X,B]={c[t′,X﹨{v},B],ifv∈Xc[t′,X,B],ifv∉X

Introduce edge of an AND-gate – Let t be a node that introduces the directed edge (u,v), where f(v)=AND and let t′ be the child of t. For each possible tuple (t,X,B), we have three situations (see Eq. (3)):

1.
If v∈X and u∈X, then the edge (u,v) must be in the solution (increase the recurrence by 1);

2.
if v∉X, then a solution for t′ is recovered;

3.
lastly, if v∈X and u∉X, then the edge (u,v) cannot be used, thus, this solution is invalid because v is an AND-gate.

(3)c[t,X,B]={c[t′,X,B]+1,ifv∈Xandu∈Xc[t′,X,B],ifv∉X+∞ifv∈Xandu∉X.
Introduce edge of an OR-gate – Let t be a node that introduces the edge (u,v) where f(v)=OR and let t′ be the child of t. For each possible tuple (t,X,B), we need to check the following situations:

1.
If u∈X, v∈X and B[v]=1, then the edge (u,v) can be included in the solution depending on the most advantageous conditions in t′:

•
for a tuple of t′ with Boolean vector B′ such that B′[v]=0 and B′[w]=B[w]∀w≠v, the OR-gate v was not satisfied, so we can sum 1 to its corresponding result since we may consider the use of (u,v) in t from this stage;

•
for a tuple t′ with Boolean vector equals B (B[v]=1), the OR-gate v has already been satisfied, i.e., it uses another edge. Thus, it is enough to consider the result of this stage.

2.
Case u∉X, v∉X or B[v]=0, the edge (u,v) can not be utilized in current solution; here we copy the solution of t′ with the same conditions.

(4)c[t,X,B]={min∀B′⁡{c[t′,X,B′]+1,c[t′,X,B]},if{u,v}∈XandB[v]=1c[t′,X,B],ifu∉X,v∉XorB[v]=0
Forget node of an AND-gate – Let t be a forget node and t′ be its child such that Xt=Xt′﹨v and f(v)=AND. In this case, we need to choose the best of two possibilities: v is part of the solution; v is not a part of the current solution. These two situations are represented in Eq. (5).(5)c[t,X,B]=min⁡{c[t′,X,B],c[t′,X∪{v},B]}

Forget node of an OR-gate – Let t be a forget node and t′ be its child such that Xt=Xt′﹨v and f(v)=OR. We need the best of two possibilities:

1.
v is part of the solution – in this case B′[v]=1 and B′[w]=B[w]∀w≠v; if B′[v]=0 the solution would be unfeasible.

2.
If v is not a part of the current solution – in this case we recover the solution from t′ with the similar conditions.

(6)c[t,X,B]=min⁡{c[t′,X,B],c[t′,X∪{v},B′]}
Join node – Let t be a join node with two children t1 and t2. For tabulation of the join nodes, we need to encode the merging of two partial solutions: one originating from GXt1 and another from GXt2. When merging two partial solutions, we need to check if some OR-gate has more than one in-edge. This can be done through a simple strategy: when we merge two solutions, regarding vectors B1 and B2 from t1 and t2, respectively, to form B, we may assume that B[i]=B1[i]+B2[i] for each i. Thus, for each possible tuple (t,X,B), we have:(7)c[t,X,B]=minB1,B2⁡{c[t1,X,B1]+c[t2,X,B2]}

Recall that every bag of T has at most tw+1 vertices, each bag has at most 2tw+1 possible subsets X, and at most 2tw+1 possible Boolean vectors B. Since each entry of the table can be computed in 2O(tw) time, and the correctness of each entry is straightforward from its description, it holds that SMCC can be solved in time 2O(tw)⋅n. □

Corollary 1

k-SMCC can be solved in time 2O(k⋅(g+1)3/2)⋅n+m, where g is the genus of the input.

Proof

It follows immediately from Lemma 2, Lemma 5 and Theorem 6. □

At this point, it is worth investigating how much Corollary 1 can be generalized to encompass larger classes of circuits. Towards this goal, it is convenient to define the notion of the diameter-treewidth property as introduced in [11].

A graph class F is said to have the diameter-treewidth property if there is a function αF:N→N such that every graph in F of diameter at most d has treewidth at most αF(d). By combining Lemma 2 with Theorem 6, we have Corollary 2.

Corollary 2

Let F be a hereditary class of graphs with the diameter-treewidth property. Then k-SMCC on monotone Boolean circuits whose underlying graph belongs to F can be solved in time αF(k)⋅n+m, where αF is a function that depends only on the class F.

We say that a graph H is an apex graph if there is a vertex in V(H) such that H﹨{v} is a planar graph. Classes of graphs that do not contain every apex graph play an important role in algorithmic theory. Indeed, NP-hard combinatorial problems can be solved much more efficiently on graphs belonging to such classes than on general graphs. Classes of bounded genus are an important example of a graph class that fall into this framework. Indeed, for each g∈N, there is some apex graph that does not belongs to the class of graphs of genus at most g. A celebrated theorem due to Eppstein [11] (see also [8]) states that for each minor-closed class of graphs F, F has the diameter-treewidth property if and only if F does not contain every apex graph. By combining this theorem with Lemma 2 and Theorem 6, we have that Corollary 3 holds.

Corollary 3

Let F be a class of graphs that does not contain every apex graph. Then k-SMCC on monotone Boolean circuits whose underlying graph belong to F can be solved in time αF(k)⋅n+m, where αF is a function that depends only on the class F.

Recall that planar graphs have genus 0. Finally, we remark the infeasibility of polynomial kernels for k-SMCC on planar graphs.

Theorem 7

k-SMCC on planar circuits does not admit a polynomial kernel, unless NP ⊆ coNP/poly.

Proof

An or-composition for k-SMCC on planar circuits can be easily obtained by first making a disjoint union of instances and then adding a new OR-gate vout which its in-neighbors are exactly the output gates of the instances provided. Thus, we can build an instance with certification-width at most k+1 if and only if one of the input instances has certification-width at most k. Therefore, by the OR-composition framework (see [10]), it holds that k-SMCC on planar graphs does not admit a polynomial kernel, unless NP ⊆ coNP/poly. □

5. Conclusions
Although several works deal with complexity measures closely related to the notion of a succinct certificate, most of the literature results focus on discovering lower and upper bounds for these measures and characterizing related complexity classes. In this paper, we address another direction, we introduce the Succinct Monotone Circuit Certification problem and investigate its time complexity. We show that SMCC is NP-complete even when the input monotone circuit is planar. Regarding Parameterized Complexity, we show the W[P]-membership of k-SMCC and its W[1]-hardness. In addition, from an approach based on bounding the treewidth of the input, we present an FPT algorithm for k-SMCC on graphs with bounded genus.

In this work, we deal only with monotone circuits. Therefore, it is interesting to investigate the behavior of succinct certificates on general Boolean circuits and consider the number of negations as an aggregate parameter. Also, it seems interesting to analyze the time complexity of SMCC on other circuit classes. Such studies may provide a robust complexity framework for a measure potentially helpful in designing circuits with sparse activation.