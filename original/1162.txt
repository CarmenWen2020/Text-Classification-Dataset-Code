Abstract
Inner product functional encryption (IPFE) is a modern public key paradigm where the master key can derive a secret key 
 for a vector y, which can then be used to decrypt a ciphertext of x to get the inner product  as output. In ASIACRYPT 2019, Tomida proposed the first tightly secure IPFE scheme in the multi-user and multi-challenge setting based on the matrix decisional Diffie-Hellman (MDDH) assumption. However, the construction achieves CPA security only. Up to now, there is no IPFE scheme with tight CCA security available.

In this paper, we construct the first tightly CCA-secure IPFE scheme in the multi-user and multi-challenge setting. The security reduction to the MDDH assumption (including SXDH, k-LIN, etc.) loses only a factor  with λ the security parameter. Moreover, our scheme enjoys full compactness. To support inner product function of dimension m, our SXDH-based IPFE has 
 and  group elements in the master public key and ciphertext respectively. This is comparable to the tightly CPA-secure IPFE proposed by Tomida based on the DDH assumption, whose master public key and ciphertext contain 
 and 3m group elements, respectively.

Furthermore, we construct the first IPFE with both tight CCA-security and function-hiding property, based on our CCA-secure IPFE. The tight function-hiding CCA security is obtained by adapting the techniques in Lin (CRYPTO 2017) and Gay (PKC 2020) to the multi-user and multi-challenge setting.

Previous
Next 
Keywords
Inner product functional encryption

CCA security

Tight security

Function privacy

Multi-user setting

1. Introduction
Functional encryption (FE) [1], [2], [3] is an emerging cryptographic paradigm with appealing features. Unlike traditional encryption that has an “all-or-nothing” access control to the ciphertext (i.e., recovering the entire message with a secret key, or revealing nothing), FE allows fine-grained access control over encrypted message. More precisely, in an FE scheme, a secret key 
 for function  can be derived from the master secret key msk, and one can then use 
 to partially decrypt ciphertext ct for x to get , but nothing else about x. FE is also required to be collusion resistant, which means that a group of colluded recipients holding 
 obtains nothing from the encryption of x beyond 
.

The syntax and security notions of FE were first formalized by Boneh et al. [1]. A variety of encryption concepts, including identity-based encryption (IBE) [4], attribute-based encryption (ABE) [5], [6], and predicate encryption (PE) [3], [7], fall into the category of FE with respect to different function classes . Taking IBE as an example, encryption of message m under identity id can be viewed as an FE encryption of , and the secret key for identity 
 can be viewed as an FE secret key for function 
, where 
 returns m if 
, and a failure symbol ⊥ otherwise.

Generally, FE schemes can be categorized into two types according to the supporting function class . The first type of FE schemes supports general circuits [8], [9], [10], [11]. Though they are powerful to cover all polynomial-size circuits, existing constructions are quite complicated and usually rely on heavy-duty tools such as fully-homomorphic encryption [8], indistinguishability obfuscation [10], or multilinear maps [12]. Therefore, they are all extremely inefficient from a practical point of view. The second type focuses on some specific function classes like inner product [13], [14] or quadratic functions [15]. Usually these schemes are simpler and can be built from standard assumptions, like the decisional Diffie-Hellman (DDH) assumption or the learning with error (LWE) assumption.

In this paper we focus on inner product functional encryption (IPFE). Namely, the function is indexed by a vector 
. Given a secret key 
, one can decrypt a ciphertext of 
 to get the inner product . Inner product is an extremely useful functionality in the context of descriptive statistics [16] (e.g., the weighted mean computing). It also supports a large range of computation including conjunctions, disjunctions, polynomial evaluations, and exact thresholds [16]. In the era of big data and cloud computing, the increasing demand for privacy protection makes IPFE an important research topic [17], [18], [19].

Basic security notions. The basic security for IPFE is indistinguishability under chosen-plaintext attacks (CPA). It requires that a probabilistic polynomial time (PPT) adversary  cannot distinguish encryption of 
 from that of 
, even if  can choose 
, 
 arbitrarily and get secret keys 
 for y via a key generation oracle, as long as 
 holds.

Abdalla et al. [13] first considered constructing IPFE schemes from standard assumptions. They proposed a generic construction for IPFE from public key encryption (PKE) schemes with extra properties, and presented instantiations under the DDH and LWE assumptions respectively. However, their construction can achieve selective security only, where the adversary needs to declare its challenge 
 and 
 before seeing the master public key.

A more reasonable security notion for IPFE is adaptive security (a.k.a. full security). In [20], Agrawal et al. proposed three efficient IPFE schemes with adaptive security based on the DDH, LWE and DCR assumptions, respectively. Inspired by the DDH-based construction, Abdalla et al. [21] later enhanced their generic construction in [13] to achieve adaptive security. Meanwhile, some attractive properties, like function privacy [22] and tight security [23], are considered in the following research of IPFE.

Function privacy. In some applications, the function index y may contain sensitive information, and it is also desirable to protect the privacy of y in IPFE. This is exactly a function-hiding IPFE (fh-IPFE) [22], [16] scheme aims for. The property of function-hiding is characterized by the indistinguishability of 
 and 
, where 
 and 
 are chosen by  arbitrarily.

CCA security. For IPFE, CPA security only covers a small range of attacks. A stronger but more reasonable notion is security under chosen-ciphertext attacks (CCA security). The CCA security allows  to access an additional decryption oracle, which takes a ciphertext ct and a vector y as inputs, generates a secret key 
, and outputs the decryption result under 
. Unlike the key generation queries, there is no restriction on vector y for decryption queries  made by . The decryption oracle may bring more information to . Hence, CCA security is harder to achieve.

Zhang et al. [24] constructed the first CCA-secure IPFE scheme, from Agrawal's CPA-secure scheme [20] and a DDH-based projected hash function (PHF) [25]. Later, Benhamouda et al. [26] proposed a similar generic construction for CCA-secure IPFE, and gave another instantiation based on the DCR assumption. Gay [27] proposed a FE for degree-2 polynomials, which used a CCA-secure partially fh-IPFE scheme as building block. To achieve CCA security, Gay added a quasi-adaptive non-interactive zero knowledge (NIZK) [28] for the language of DDH tuples in Agrawal's scheme [20]. However, all these schemes above are hard to achieve tight security.

Tight security. The security of IPFE (also other cryptographic primitives) is proved via a reduction algorithm. More precisely, once there exists a PPT adversary  which breaks the security of IPFE with advantage ϵ, we can construct another PPT algorithm , that uses 's ability to solve some well-known hard problem P with advantage 
. Usually  and  have roughly the same running time, and we define 
 the security loss factor in the reduction. If L is a constant, the reduction is tight. And if  with λ the security parameter, the reduction is almost tight.

It is desirable that the security of IPFE is tightly relevant with the hardness of P. However, many encryption schemes are deployed in the multi-user and multi-challenge setting. With a standard hybrid argument, we know that security in the single challenge setting implies security in the multi-user and multi-challenge setting, but with a loose factor , where μ and Q are the maximum number of users and challenges in the interaction with  respectively. In many scenarios, μQ can be as large as 250. Given such a loose factor L, the deployment of IPFE has to choose a larger security parameter to compensate the great reduction loss, resulting in larger elements and slower computations in the execution. Therefore, pursuing tight security of IPFE is not only of theoretical value but also of practical significance.

Up to now, there are few studies on tight security of IPFE. The only scheme that achieves tight security was proposed by Tomida [14], and the security is based on the matrix decisional Diffie-Hellman (MDDH) assumption. However, Tomida's scheme achieves CPA security only. Up to now, there is no IPFE scheme with (almost) tight CCA security available. Hence, a challenging question is:

Can we construct an efficient CCA-secure IPFE scheme with (almost) tight security in the multi-user and multi-challenge setting?

1.1. Our contributions
We propose the first IPFE scheme with (almost) tight CCA security in the multi-user and multi-challenge setting (mCCA for short), based on the MDDH assumption (including SXDH, k-LIN, etc.). The security loss factor is only . Moreover, our scheme enjoys full compactness. To encrypt a message x of length m, our SXDH-based IPFE has 
 and  group elements in the master public key msk and ciphertext ct respectively. This is comparable to the tightly mCPA-secure IPFE proposed in [14] based on the DDH assumption, whose mpk and ct contain 
 and 3m group elements, respectively. See Table 1 for details.


Table 1. Comparison of adaptively secure IPFE schemes in the multi-user and multi-challenge setting. |mpk|, |msk|, |ct|, and |sk| denote the size of master public keys, master secret keys, ciphertexts and secret keys, respectively. m denotes the vector length, and Qct denotes the total number of encryption queries made by the adversary.



Furthermore, we construct the first IPFE with (almost) tight mCCA-security and function-hiding property simultaneously (fh-mCCA for short), based on our mCCA-secure IPFE. The tight fh-mCCA security is obtained by adapting the techniques in [29], [27] to the multi-user and multi-challenge setting. The comparison is shown in Table 2.


Table 2. Comparison of function-hiding IPFE schemes. |mpk|, |msk|, |ct|, and |sk| denote the size of master public keys, master secret keys, ciphertexts and secret keys, respectively. m denotes the vector length. Qct and Qsk denote the total number of encryption and key generation queries made by the adversary, respectively. “F-H” is short for function-hiding.



1.2. Technical overview
Firstly, we review Tomida's IPFE scheme [14]. Then we show how to construct a mCCA-secure IPFE scheme from a mCPA-secure IPFE scheme, with the help of a quasi-adaptive non-interactive zero-knowledge (QA-NIZK) argument for linear subspace language. Finally we extend the mCCA-secure IPFE to achieve (full) function-hiding, by adapting the techniques to the multi-user and multi-challenge setting. For simplicity, we express the schemes under the DDH (SXDH) assumption in the single user and multi-challenge setting (see Table 2).

Tomida's IPFE scheme with mCPA-security. Define  as the implicit representation of matrix A in  (see Subsect. 2.2). The algorithms of Tomida's scheme [14] are described as follows. Here 
, 
.

•
: 
, , , return .

•
: Return 
.

•
: Return 
.

The tight mCPA security proof for Tomida's IPFE scheme relies on two essential facts.

(1)
The adversary  can get  from mpk and a collection of secret keys 
 from key generation queries.

(2)
The DDH assumption makes sure that, in challenge ciphertexts 
, these 
 can be replaced by 
 in a computationally indistinguishable way.

(3)
For 
, given  and 
, the remaining entropy in W makes sure that term 
 has the same distribution as 
, conditioned on 
. Thus, mCPA security follows.

Our tightly mCCA-secure IPFE scheme. Our scheme is constructed from Tomida's mCPA-secure scheme [14], and we used the “CPA+NIZK” paradigm [33], [27] to achieve CCA security. More precisely, we need to make sure that the decryption oracle leaks no more information about W to , beyond  and 
. Observe that in Tomida's IPFE, for ciphertext  with , the output of 
 is totally determined by ct,  and the vector y. Hence, we need to add new mechanism in the encryption and decryption algorithms, so that decryption rejects all ciphertexts  with  overwhelmingly. Note that, the soundness of non-interactive zero-knowledge (NIZK) for linear subspace language 
 fulfills this functionality.

Hence, the new encryption algorithm computes ciphertext as where π is a NIZK proof for .

However, the above encryption is still not CCA-secure yet, since it is malleable. That is, given ct, it is easy to forge a new ciphertext 
 with a valid NIZK proof. The reason is that π is bound only with  but not . To solve this problem, we employ a tag-based NIZK and resort to tag to bind  and  together. Now, the final IPFE scheme computes ciphertexts as

Now we are ready to show how the tight mCCA security of our scheme is proved.

(1)
The adversary  can get  from mpk and a collection of secret keys 
 from key generation queries.

(2)
Use the simulation algorithm of NIZK to generate the proofs in challenge ciphertexts, i.e., 
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
.

(3)
Replace 
⁎
⁎
 by 
⁎
 in challenge ciphertexts 
⁎
⁎
⁎
. The MDDH assumption makes sure that this change is computationally indistinguishable.

(4)
The decryption oracle rejects all ciphertexts  with . By the collision resistance of , 
⁎
. Then the unbounded simulation soundness (USS) property of NIZK guarantees that given 
⁎
⁎
⁎
, it is hard to forge a valid proof π for  and 
⁎
. Thus, this rejection makes no difference in the behavior of the decryption oracle.

(5)
Now the decryption oracle reveals no more information about W beyond .

(6)
Finally, we can use Tomida's mCPA proof technique for our mCCA proof. More precisely, for 
⁎
, given  and 
, the remaining entropy in W makes sure that term 
⁎
⁎
 has the same distribution as 
⁎
⁎
, conditioned on 
. Thus, mCCA security follows.

In conclusion, with the help of a NIZK for linear subspace language with tight USS, we improve Tomida's mCPA-secure IPFE scheme to a new IPFE scheme with mCCA-security. The recent works [34], [35] suggest that such an efficient NIZK exists. Consequently, we obtain an efficient IPFE scheme with tight mCCA security.

Tightly function-hiding CCA-secure IPFE scheme. The function-hiding (fh) property requires that 
 leaks no information about the function y. Formally, secret keys for two functions 
 and 
 of 's own choice are indistinguishable, conditioned on 
. We also consider a weaker security called weak function-hiding (w-fh) [36], [37], where the restriction is enhanced to 
. Lin and Vaikuntanathan [36] proposed a conversion from weak function-hiding to (full) function-hiding for IPFE. The transform is security-preserving and compatible with all IPFE schemes. Hence, to achieve tight function-hiding-mCCA security, we just need to construct a mCCA-secure IPFE scheme with weak function-hiding property and tight security.

Moreover, Lin [29] proposed a generic framework to construct a weakly function-hiding Priv-IPFE scheme, from two Pub-IPFE schemes with extra properties. Recall that in Tomida's mCPA-secure IPFE scheme [14], for  and 
, decryption can be viewed as an inner product operation for ct and sk. The idea of [29] is to view sk as a vector to be encrypted, and “encrypt” it under an outer IPFE scheme. To keep synchronization, the encryption algorithm outputs a “secret key” for ct. Now decryption just returns , which is the original result  as we wish. By applying this method, [14] obtained the first tightly w-fh-mCPA-secure IPFE scheme.

We adapt Lin's framework to the scenario of mCCA security to achieve w-fh-mCCA-security, and use the opposite layer construction as that in [27] to get a more efficient CCA-secure scheme. More precisely, we use an outer mCCA-secure scheme 
 and an inner mCPA-secure scheme 
 to build a w-fh-mCCA-secure IPFE scheme as follows.

•
: 
, 
. Return 
.1

•
: 
, 
. Return 
.

•
: 
, 
. Return 
.

Recall that in decryption queries, the adversary submits a ciphertext ct along with a plain vector y. That is, in the security reduction, we do not need the inner scheme to be mCCA-secure, since the reduction algorithm can encrypt y to 
 itself, and do the inner product operation with 
 to get the decryption result. Hence, mCPA security is enough for 
.

Finally, we obtain the first tightly fh-mCCA-secure IPFE scheme, by instantiating 
 with our mCCA-secure IPFE scheme and 
 with Tomida's mCPA-secure IPFE scheme.

2. Preliminaries
Let  denote the security parameter. For , define . For  with , define . Denote by  the operation of assigning y to x. Denote by 
 the operation of sampling x uniformly at random from a set . For a distribution , denote by  the operation of sampling x according to . For an algorithm , denote by , or simply , the operation of running  with input x and randomness r and assigning the output to y. “PPT” is short for probabilistic polynomial-time.

We use bold lower-case letters to denote vectors (e.g., x), and bold upper-case letters to denote matrices (e.g., A). Unless specific description, all vectors are column vectors in this paper. For matrices A and B, we use  for the horizontal concatenation of matrices, and  for the vertical concatenation, and  for their tensor (or Kronecker) product 
. For vectors 
, let  denote their inner product 
. Let 
 and 
 denote the identity and zero matrices respectively.

2.1. Inner product functional encryption
Definition 1 Public-Key Inner Product Functional Encryption

A public-key inner product functional encryption (Pub-IPFE) scheme , ,  consists of five PPT algorithms.

•
: It takes the security parameter λ as input and outputs a public parameter . We assume the following algorithms take  as an implicit input.

•
: It takes the vector length m and  as inputs, and outputs a master public key mpk and a master secret key msk. We implicitly assume msk contains mpk.

•
: It takes mpk and a vector 
 as inputs, and outputs a ciphertext ct.

•
: It takes msk and a vector 
 as inputs, and outputs a secret key sk. We assume sk contains mpk implicitly.

•
: It takes ct and sk as inputs and outputs the decrypted value  or a failure symbol ⊥.

Correctness. For all 
, 
, 
, , , it holds that .

mCCA security. Let  be a Pub-IPFE scheme. Consider the following experiments 
 with .

Let μ be the total number of users, and 
, 
 denote the total number of encryption and key generation queries for index i, respectively. For all , 
 and 
, the

Image 7
queries and
Image 8
queries made by  are restricted to satisfy(⁎)
 is said to be CCA-secure in the multi-user and multi-challenge setting (or mCCA for short), if 
 holds for every PPT adversary , where
 If  is not allowed to ask

Image 9
in 
, then  is turned to be CPA-secure in the multi-user and multi-challenge setting (or mCPA for short), and the advantage of  is denoted by 
.
Definition 2 Private-Key Inner Product Functional Encryption

A private-key inner product functional encryption (Priv-IPFE) scheme  ,  consists of five PPT algorithms.

•
: It takes the security parameter λ as input and outputs a public parameter . We assume the following algorithms take  as an implicit input.

•
: It takes the vector length m and  as inputs, and outputs a master secret key msk.

•
: It takes msk and a vector 
 as inputs, and outputs a ciphertext ct.

•
: It takes msk and a vector 
 as inputs, and outputs a secret key sk.

•
: It takes ct and sk as inputs and outputs the decrypted value  or a failure symbol ⊥.

Correctness. For all 
, 
, 
, , , we have .

Function-hiding mCCA security. Let  be a Priv-IPFE scheme. Consider the following experiments 
 with .

Let μ be the total number of users, and 
, 
 denote the total number of encryption and key generation queries for index i, respectively. For all , 
 and 
, the

Image 7
queries and
Image 12
queries made by  are restricted to satisfy(⁎⁎)
 is said to be function-hiding-CCA-secure in the multi-user and multi-challenge setting (or fh-mCCA for short), if 
 holds for every PPT adversary , where
 Weak function-hiding mCCA security. The experiment 
 is defined almost the same as 
 above, but with a more restrict query condition for . That is, for all , 
 and 
, it requires that(⁎⁎⁎)

 is said to be weakly function-hiding-CCA-secure in the multi-user and multi-challenge setting (or w-fh-mCCA for short), if 
 holds for every PPT adversary , where

Remark 1

As noted in [22], the concept of (weak) function-hiding does not make sense for Pub-IPFE. To see this, consider an adversary that submits 
 and 
 s.t. 
 in a key generation query, and gets 
 back. Then it generates a ciphertext ct for  by itself, i.e., . Via decryption, it can get 
 hence decide β trivially.

Remark 2

The notion of weak function-hiding in [22] is defined in a different way, where the queries from the adversary must satisfy
 Note that 
 implies 
 but not vice verse. Therefore, the security model we used (which follows the definition in [36], [37]) imposes less constraint on the adversary, hence is stronger than that in [22].

2.2. Matrix Diffie-Hellman assumptions and pairing groups
Let  be a bilinear group generation algorithm that inputs 
 and returns a description 
 of an asymmetric pairing group, where 
 are cyclic groups of order q, 
 and 
 are generators of 
 and 
 respectively, and 
 is an efficiently computable (non-degenerated) bilinear map. Define 
 be the generator in 
. For  and matrix 
 with 
, define 
 as the implicit representation of A in 
 [38]. For 
, the linear subspace spanned by A is 
, and similarly, 
; the set consisting of all kernel matrices of A is defined as 
. Note that given 
, it is efficient to sample an 
 from . For matrices , it is efficient to compute 
, given 
 or 
. Define 
.

Let  and . 
 is a matrix distribution if it outputs matrices in 
 of full rank k in polynomial time. If , we denote it by 
. For 
, 
 
 denotes the upper k rows of A, and  
 
  the lower  rows. W.l.o.g., we assume that 
 
 forms a full rank matrix.

Definition 3

-MDDH Assumption
Let 
 be a matrix distribution and . Define the advantage of  in solving the 
-matrix decisional Diffie-Hellman (
-MDDH) problem as
 where 
, 
, 
, and 
. The 
-MDDH assumption states that 
 holds for any PPT adversary .

Remark 3

According to [38], if the 
 distribution outputs a matrix
 
 where 
, then the 
-MDDH assumption becomes k-LIN assumption. 1-LIN assumption is just the DDH assumption. The SXDH assumption holds if the DDH assumption holds in both 
 and 
 in the asymmetric pairing group setting [39].

For , consider the n-fold 
-MDDH problem, which asks to distinguish distributions 
 and 
.

Definition 4

n-fold 
-MDDH Assumption
Let 
 be a matrix distribution and . Define the advantage of  in solving the n-fold 
-MDDH problem as
 where 
, 
, 
, and 
. The n-fold 
-MDDH assumption states 
 holds for any PPT adversary .

Lemma 1

Random Self-Reducibility [38]
Let . For any adversary , there exists an algorithm  with , s.t.
 

Denote by 
 the uniform distribution over all matrices in 
. Let 
. Several relations among MDDH assumptions w.r.t. different matrix distributions were established in [38], [40].

Lemma 2

-MDDH ⇒ 
-MDDH [38] ⇒ 
-MDDH [40]
For any adversary , there exists an adversary  such that  and 
.

For any adversary , there exists an adversary  such that  and 
.

2.3. Collision resistant hash families
Definition 5 Collision Resistant Hash Families

Let  be two finite sets. A family of hash functions  is collision resistant, if for any PPT adversary , it holds that

2.4. Quasi-adaptive non-interactive zero-knowledge argument
Let 
 be a collection of languages indexed by parameter ρ. Each language 
 is determined by a binary relation 
, such that an instance 
 iff there exists a witness w s.t. 
. We consider 
 with a trapdoor 
, which can be used to decide the membership of 
 efficiently.

Quasi-adaptive non-interactive zero-knowledge (QA-NIZK) argument is a special NIZK where the common reference string  depends on the specific language 
. We recall the definition of tag-based QA-NIZK in [41], [35], which serves as an important building block in our construction of mCCA-secure IPFE.

Definition 6 Tag-Based QA-NIZK

A tag-based quasi-adaptive non-interactive zero-knowledge (QA-NIZK) argument consists of four PPT algorithms, namely .

•
. It takes the security parameter λ and a language 
 as inputs, and outputs a common reference string  along with a trapdoor .

•
. It takes , an instance x along with a witness w, and a tag  as inputs, and outputs a proof π.

•
. It takes , x,  and π as inputs, and outputs a bit 1 (accept) or 0 (reject).

•
. It takes , , x and  as inputs, and outputs a simulated proof π.

We require Π to have completeness and zero-knowledge.

Completeness. For all x, w s.t. 
, all tags ,
 Perfect zero-knowledge. For all x, w s.t. 
, all tags , and all 
, the following two distributions are identically distributed,

We recall a stronger version of unbounded simulation soundness (USS) as defined in [42], [43], where an adversary receives a trapdoor 
 for 
 and it is allowed to submit a forgery with a reused tag.

Definition 7 Unbounded Simulation Soundness

The tag-based QA-NIZK has unbounded simulation soundness (USS), if for any PPT adversary 
, the following advantage is negligible in λ: where

Image 14
takes x (not necessarily in 
) and  as inputs, generates a proof via , adds  into the set 
 and returns π to 
.
QA-NIZK for linear subspace with tight USS based on MDDH in [35]. Let 
, define 
 as the linear subspace language generated by 
, and 
 as its trapdoor. We recall the QA-NIZK scheme Π [35] for language 
 in Figure A.3 in Appendix A,2 and present its tight USS in the following theorem. This QA-NIZK will be used as a building block for our tightly mCCA-secure IPFE scheme.

Theorem 1

[35]
Scheme Π defined in Figure A.3 in Appendix A is a QA-NIZK argument with perfect completeness, perfect zero-knowledge and (tight) unbounded simulation soundness, if the 
-MDDH assumption holds in 
, 
-MDDH assumption holds in both 
 and 
, and 
 is a collision resistant hash family. More precisely, for any PPT adversary  that queries

Image 15
at most Q times, there exist PPT algorithms 
 s.t. 
 , and
3. Tightly mCCA secure IPFE scheme
In this section we propose our IPFE scheme 
, which is tightly mCCA-secure under the MDDH assumption (including SXDH, k-LIN, etc.). The IPFE construction is shown in Subsect. 3.1, and its tight mCCA security is proved in Subsect. 3.2.

3.1. Construction
Let 
 be a collision resistant hash family, and  be the tag-based QA-NIZK scheme [35] for linear subspace language 
 (see Figure A.3 in Appendix A).

Our construction of tightly mCCA-secure IPFE scheme 
,  is constructed from  and Π, and is described as follows. The message space is 
, and the inner product function is defined by 
. We require that mXY is a polynomial in λ.

•
: 
, 
, 
 
, 
, 
. Return 
.

•
: 
. Return 
, .

•
: 
, 
, 
, 
, 
. Return 
.

•
: Return 
.

•
: Parse 
, 
, and compute 
. If 
, return ⊥. Otherwise, compute 
. Search d exhaustively in the range of . If such d is found, return d. Otherwise, return ⊥.

Correctness. Since 
 and 
, correctness of 
 follows directly from the perfect completeness of Π and the following fact

Remark 4 On the feasibility of decryption

Like all other existing DH-based IPFE schemes [13], [20], [14], the decryption requires a computation of discrete logarithm. To make decryption efficient, we require 
, 
, and mXY is a polynomial in λ. This requirement is reasonable for many applications in practice. For example, in the computation of weighted mean, entries in databases (e.g., age, height) are generally polynomially bounded.

Remark 5 SXDH-based instantiation and its efficiency

When instantiating 
 under the SXDH assumption by setting , to encrypt a message x of length m, the master public key mpk and the ciphertext ct contain only 
 and  group elements, respectively. This is comparable to the tightly mCPA-secure IPFE proposed in [14], whose mpk and ct contain 
 and 3m group elements, respectively. See Table 1 for details.

Remark 6

Informally, our scheme uses the “1CPA + QA-NIZK” construction, which is similar to the method of constructing partially function-hiding IPFE in [27]. We summarize the differences between our method and theirs as below.

1.
Different syntax. Our definition of IPFE has different syntax with that in [27]. In [27], the encryption and decryption algorithms additionally take a tag as input. In comparison, our definition is tag-free.

2.
Different definitions for CCA security. Our definition of CCA security is different from that in [27]. In [27], the decryption oracle

Image 16
takes a tag τ, a ciphertext ct, and a function y as inputs, with restriction that 
⁎
, where 
⁎
 is the tag used in the generation of challenge ciphertext 
⁎
. In comparison, the decryption oracle
Image 17
in our model is tag-free, and it requires that 
⁎
. Note that our security model cannot be viewed as a special case  of [27], since otherwise the decryption oracle will reject all queries due to the fact 
⁎
.
3.
Different definitions for NIZK soundness. We have different soundness requirement for QA-NIZK from [27]. Recall that we consider tightly CCA-secure IPFE in the multi-user & multi-challenge setting, rather than the single user & single challenge setting considered in [27]. As a result, we require the underlying QA-NIZK to have tight unbound simulation soundness (USS). In comparison, a QA-NIZK with one-time simulation soundness (OT-SS) suffices for [27].

Remark 7

Notice that in [26], Benhamouda et al. combined a hash proof system (used as a DV-NIZK) with a CPA-secure IPFE to obtain a (non-tightly) CCA-secure IPFE. Their framework admits another approach to tightly CCA-secure IPFE. Following this framework, we can resort to a tightly secure DV-NIZK, which works well with Tomida's tightly mCPA-secure IPFE, to obtain a tightly mCCA-secure IPFE. As far as we understand, the special DV-NIZK with linear algebraic structure in [40] is compatible with Tomida's tightly mCPA-secure IPFE. The resulting tightly mCCA-secure IPFE is free of pairings, but it has large size of master public/secret keys, hence is not a compact scheme. Furthermore, to augment function-hiding to IPFE, it seems that pairings are unavoidable up to now.

3.2. Tight mCCA security of 
Theorem 2

 in Subsect. 3.1 is tightly mCCA-secure in the multi-user and multi-challenge setting, if the 
-MDDH assumption holds in 
, the 
-MDDH assumption holds in both 
 and 
, and 
 are collision resistant. Concretely, for any PPT adversary , there exist PPT algorithms 
 s.t. 
 with  independent of , and
 where μ denotes the total number of users, 
, 
, and 
 denote the total number of encryption, key generation, and decryption queries made by , respectively.

Remark 8 Tightness of the mCCA security

According to Theorem 2, our 
 is mCCA-secure with a security loss factor 
. Therefore, our 
 achieves (almost) tight mCCA security under the MDDH assumption.

Proof

Theorem 2 is proved via a sequence of games 
 (). The first two games 
 and 
 are the original mCCA security experiments 
 and 
. We prove that two adjacent games are indistinguishable from the perspective of , and 
, 
 are identical. A brief description of differences between adjacent games is summarized in Table 3. Denote by 
 the event that 
 outputs 1. For the ease of notation, the indexes 
 (the encryption query index w.r.t. user i) and 
 (the key generation query index w.r.t. user i) are simplified to j and ζ.


Table 3. Descriptions of 
 - 
 in the security proof of Theorem 2.

Game 
. This is just the original experiment 
. For all  and 
, the j-th challenge ciphertext (w.r.t. user i) is generated by
 Game 
. This game is the same as 
 except that the experiment uses 
 to do the encryption. That is, Due to the equation 
, we have the following lemma.

Lemma 3

For , 
.

Game 
. This game is the same as 
 except an extra abort rule. Let 
 be the set collecting all challenge ciphertexts indexed by i. Whenever there is a decryption query 
, the decryption oracle checks for all  and 
, whether there is a hash collision s.t. 
 but 
. If this happens, 
 aborts.

Lemma 4

For , 
.

Proof of Lemma 4

If such collision happens, we can easily construct a reduction algorithm  to break the collision resistance property of . □

Game 
. In this game, the challenge ciphertexts are generated with the help of the simulation algorithm . Namely, for all  and 
,

Since Π has perfect zero knowledge, 
 and 
 are identical. Therefore, we have the following lemma.

Lemma 5

For , 
.

Game 
. In this game, we change the generation of challenge ciphertexts. For all  and 
, define 
, and let 
 be a map s.t. 
. The j-th challenge ciphertext is generated by

Lemma 6

For , 
 
.

Proof of Lemma 6

We construct a PPT reduction algorithm 
 to solve the n-fold 
-MDDH problem with 
. Suppose that 
 receives 
 from its own challenger. Let 
 be the ι-th column of T. Note that either 
 for some 
, or 
 is a random vector in 
. 
 simulates the game for  according to the specification of 
, except the generation of challenge ciphertexts. For the j-th encryption query w.r.t. user i, 
 computes

Finally 
 outputs whatever  outputs. It is easy to verify that if 
, then 
 simulates 
, and if 
 is a random vector, then 
 simulates 
. Any difference between 
 and 
 turns into the advantage of 
, hence Lemma 6 follows. □

Game 
. In this game, we add an extra rejection rule. That is, the decryption oracle rejects a query 
 directly if 
.

Define by  the event that  asks a decryption query 
, such that 
, 
, 
, and there is no hash collision. Here 
. 
 and 
 are identical unless  happens.

Lemma 7

For , 
.

Proof of Lemma 7

Let 
 be the j-th challenge ciphertext (for user i), 
, and 
. We can divide  into three cases.

•
Case 1. For some  and 
, 
 but 
. This is impossible due to the extra rejection rule of 
.

•
Case 2. For some  and 
, 
 and 
. Except a negligible probability, we have 
. Since 
, we have that 
.

•
Case 3. For all  and 
, 
.

Define set 
 and 
. No matter in which case, we have 
. Hence, we can construct an algorithm 
 to break the unbounded simulation soundness of Π if  happens.
 simulates 
 for  as follows. It receives 
 from its own challenger, and uses  in the simulation. Whenever there is an encryption query for user i, 
 generates 
 and 
 itself, computes 
, and asks its simulation oracle to get a proof 
. Whenever  asks a decryption query 
 and  happens, 
 computes 
, and returns 
 to its own challenger. Note that 
 can check event  efficiently with A. Due to the analysis above,  implies 
, 
, and 
. Therefore, 
 wins as long as  happens, and Lemma 7 follows. □

Game 
. For , let 
 be a map s.t. 
. In other words, on input ι, 
 returns the first query number j s.t. 
 equals ι. Now in 
, the master secret key 
 is renamed to 
 (which is a conceptual change), and the j-th challenge ciphertext is generated by

Lemma 8

For , 
.

Proof of Lemma 8

Recall that in the mCCA security experiment,  is allowed to ask encryption queries adaptively (after seeing 
). We will use a complexity leveraging argument to prove this lemma.

Firstly we fix 
 for each  and 
, and show 
 and 
 are identical for fixed 
. Let 
 be a vector s.t. 
 and 
 (such 
 can always be found since 
 form a full rank matrix). Define 
, and for , 
 denotes the ι-th row of 
. It is easy to verify that 
. Now, we redefine 
 in 
 as
 
 Obviously 
 is distributed uniformly as in 
.

Observe that in 
 (using 
) and 
 (using 
), the master public keys have the same distribution, and the encryption oracle and key generation oracle behave the same due to the following facts.
 
 
 
 
 Moreover, the decryption oracles in 
 and 
 behave the same as well, since 
, and all decryption queries 
 satisfy 
. Therefore, 
 and 
 are identical for fixed 
.

Then by a complexity leveraging argument, 
 and 
 are also identical for adaptively chosen 
, and Lemma 8 follows. □

Game 
. In this game, the j-th challenge ciphertext is generated by

Lemma 9

For , 
 
.

Proof of Lemma 9

We construct an algorithm 
 that reduce the difference between 
 and 
 to the 
-MDDH problem with 
. Upon receiving 
, 
 computes as follows. Denote by 
 the ι-th column of 
, and 
 the ι-th entry of t. Now 
 simulates the game for  according to the specification of 
, except the generation of challenge ciphertexts. For the j-th encryption query w.r.t. user i, 
 computes
 

Finally 
 outputs whatever  outputs. It is easy to verify that 
 simulates 
 if  for some 
, and simulates 
 if t is random. Therefore, 
. According to Lemma 2, Lemma 9 holds. □

Lemma 10

.

Proof of Lemma 10

Recall that 
. The term 
 is a random vector in the space generated by 
, hence 
 distribute the same as 
. Consequently, 
 and 
 are identical. □

Thanks to Lemma 3, Lemma 10, Theorem 2 is proved. □

4. Tightly mCCA-secure IPFE with function-hiding
We first propose a tightly mCCA-secure IPFE scheme with weak function-hiding in Subsect. 4.1. Then in Subsec. 4.2 we show how to enhance it to achieve (full) function-hiding.

4.1. Tightly mCCA-secure IPFE with weak function-hiding
We use the mCCA-secure scheme 
 in previous section and the mCPA-secure scheme 
 to build a w-fh-mCCA-secure IPFE scheme. The tight w-fh-mCCA security is obtained by adapting Lin's framework in [29] to the multi-user and multi-challenge setting. Notice that in our mCCA-secure scheme 
, the ciphertext is , the secret key is 
, and the decryption just computes their inner product (if it passes the verification of QA-NIZK). Lin's idea [29] is to view the secret key as a message and “encrypt” it, so that the information of the secret key (hence y) is hidden.

Here, we adopt the opposite layer construction as that in [27] to get a more efficient CCA-secure scheme. Let 
 be an outer mCCA-secure scheme as previous sections, and 
 be an inner mCPA-secure scheme with parameters/keys . Here , and r correspond to  and s in the original mCCA-secure scheme. Now, the encryption algorithm of the targeting FH-IPFE scheme first computes a “secret key” 
 under the inner mCPA-secure 
, then outputs an encryption for 
, i.e., 
, and the final ciphertext is 
 with π a QA-NIZK proof. Accordingly, the key generation algorithm outputs 
 with 
 an “encryption” for y under the inner mCPA-secure 
. Now if the verification of QA-NIZK is passed, decryption just returns 
, which is the original result  as we wish. Based on the mCCA security of 
 and mCPA security of 
, the construction above achieves w-fh-mCCA security.

Formally, our tightly w-fh-mCCA-secure scheme 
 is described as follows.3

•
: 
, 
, 
 
, 
, 
. Return 
.

•
: 
, 
. Return .

•
: 
, 
, 
, 
, 
, , 
. Return 
.

•
: 
 
, 
, 
, 
, 
. Return 
.

•
: Parse 
, 
, 
. Compute 
 and check whether
 Return ⊥ if the equation fails. Otherwise, compute 
. Search d exhaustively in the range of . If such d is found, return d. Otherwise, return ⊥.

Correctness. Since 
 and 
, correctness of 
 follows directly from the following fact

Theorem 3

 in Subsect. 4.1 is tightly w-fh-mCCA-secure in the multi-user and multi-challenge setting, if the 
-MDDH assumption holds in 
, 
-MDDH assumption holds in both 
 and 
, and 
 are collision resistant. Concretely, for any PPT adversary , there exist PPT algorithms 
 s.t. 
 with  independent of , and
 where μ denotes the total number of users, 
, 
, and 
 denote the total number of encryption, key generation, and decryption queries made by  respectively.

Proof

Theorem 3 is proved via three hybrid games 
. Game 
 is the original w-fh mCCA security experiment 
, and 
 is 
. We prove that two adjacent games are indistinguishable from the perspective of . A brief description of differences between adjacent games is summarized in Table 4. Denote by 
 the event that 
 outputs 1. For simplicity, we do not specify j or ζ w.r.t. user i any more.


Table 4. Descriptions of 
 - 
 in the security proof of Theorem 3.

Game 
. This is just the original w-fh-CCA security experiment 
. For each encryption query 
 and key generation query 
, the experiment returns:
 
  
 
 
  
 
 Game 
. In this game, we encrypt 
 instead of 
 for an encryption query 
. Lemma 11 shows that this change is indistinguishable to , assuming that the outer scheme 
 is mCCA-secure.

Lemma 11

.

Proof of Lemma 11

Obliviously that all decryption queries  for 
 satisfy 
. Therefore, 
 can resort to

Image 34
to get the decryption result d (d may be ⊥) and complete the simulation.
We also need to argue that all queries to

Image 35
and
Image 36
satisfy the restriction equation (⁎), namely 
. This is guaranteed via the weak function hiding requirement 
, since
 
 
 
 
Therefore, 
 simulates 
 if

Image 35
returns the encryption of 
, and 
 if
Image 35
encrypts 
, which proves Lemma 1. □
Game 
. In this game, we generate secret keys for 
 instead of 
 in the key generation queries. Lemma 12 shows that this change is indistinguishable to , assuming that the inner IPFE scheme 
 is mCPA-secure.

Lemma 12

.

Proof of Lemma 12

One can easily check that 
 simulates the decryption oracle

Image 38
perfectly. Now we argue that all encryption and secret key queries satisfy the restriction equation (⁎) of 
. This is guaranteed via the equation 
 (the requirement of weak function hiding).
Therefore, 
 simulates 
 if

Image 39
returns the encryption of 
, and 
 if
Image 39
encrypts 
, which proves Lemma 12. □
 is just the experiment 
, and Theorem 3 follows from Theorem 2 and Lemma 11, Lemma 12. □

Remark 9

Another approach to tightly w-fh-mCCA-secure IPFE is to use the construction suggested by Lin [29], i.e., 
 
 
 
 with π a proof for 
. However, there is a gap in the tight w-fh-mCCA security proof, since π is bound with only a part of ciphertext. This gap can be filled by adding an extra check
 in the decryption algorithm. The resulting IPFE scheme has a higher decryption complexity hence is less efficient than our scheme.

4.2. Achieving full function-hiding
The scheme above achieves tight mCCA security but weak function-hiding only. Lin and Vaikuntanathan [36] proposed a conversion to transform an IPFE scheme from weak function-hiding to (full) function-hiding. The conversion is security-preserving and rather simple. Namely, we encrypt 
 instead of encrypting x in the original scheme, and generate secret key for 
 instead of y. The security can be proved via a sequence of games.

One can easily check that the indistinguishability of each adjacent pair of hybrids can be tightly reduced to the w-fh-CCA security of 
, based on the fact that 
. Let 
 be the extended scheme. Therefore, we have the following corollary.

Corollary 1

 is tightly fh-mCCA-secure in the multi-user and multi-challenge setting, if the 
-MDDH assumption holds in 
, 
-MDDH assumption holds in both 
 and 
, and 
 are collision resistant.