Abstract
Causal broadcast is a communication abstraction built on top of point-to-point send/receive networks that ensures that any two messages whose broadcasts are causally related (as captured by Lamport's “happened before” relation) are delivered in their sending order. Several causal broadcast algorithms have been designed for failure-free and crash-prone asynchronous message-passing systems.

This article first gives a formal definition of a causal broadcast abstraction in the presence of Byzantine processes, in the form of two equivalent characterizations, and then presents a simple causal broadcast algorithm that implements it. The main difficulty in the design and the proof of this algorithm comes from the very nature of Byzantine faults: Byzantine processes may have arbitrary behavior, and the algorithm must ensure that correct processes (i) maintain a coherent view of causality and (ii) are never prevented from communicating between themselves. To this end, the algorithm is built modularly, namely it works on top of any Byzantine-tolerant reliable broadcast algorithm. Due to this modularity, the proposed algorithm is easy to understand and inherits the computability assumptions (notably the maximal number of processes that may be Byzantine) and the message/time complexities of the underlying reliable broadcast on top of which it is built.

Keywords
Algorithm
Asynchronous message-passing system
Byzantine process
Causal message delivery
Fault-tolerance
Modularity
Reliable broadcast
Simplicity

1. Introduction
On causality.  Modern distributed systems have grown increasingly large, spanning millions of servers in data centers, and billions of devices scattered across the world. In this context, both theoreticians and practitioners have observed the impossibility of building highly available systems that offer strong consistency guarantees while tolerating network partitions [19], [21], [22]. As a result, a number of systems have chosen to rely on communication abstractions that offer causal-ordering guarantees (e.g. [31], [32], [45]). In the context of social networks, causal ordering ensures that users that see Bob's reply to Alice have also seen Alice's original message. In the context of collaborative editors, causal ordering enables large numbers of users to concurrently edit documents without conflicts [39]. In the domain of distributed data stores [15], [32], causal ordering makes automatic conflict resolution possible in the presence of concurrent writes [15].

In the last few years, multiple authors have observed that causal consistency and variants of it constitute the best achievable guarantee in large-scale fault-tolerant available systems [2], [32], [45]. It is therefore surprising that the majority of existing research work only considers and defines causal consistency in the context of crash failures.

Content of the paper.  This article first defines a Byzantine-tolerant causal ordering abstraction (which we call BCO-broadcast). Then it presents (and proves correct) an algorithm implementing it in a system where communication is by message-passing. This algorithm is built on top of a Byzantine reliable broadcast abstraction. Consequently it inherits the t-resilience and the message/time complexities of the specific algorithm chosen to implement the underlying reliable broadcast. While the algorithm is simple, its proof is not, due to the very nature of Byzantine faults. Namely, the main difficulty consists in proving that Byzantine processes can neither destroy the causality relation on the messages broadcast by the correct processes nor prevent the correct processes from delivering (according to causal order) the messages they broadcast.

Roadmap.  The article is composed of 8 sections. Section 2 presents some background and related work. Section 3 presents the computation model and Byzantine reliable broadcast. Section 4 defines Byzantine causal broadcast and presents a property-based characterization of it. Section 5 presents the Byzantine causal broadcast algorithm. Section 6 presents its proof (which is based on the previous characterization theorem). Section 7 presents an example of the use of Byzantine causal broadcast. Finally, Section 8 concludes the paper.

2. Background and related work
On reliable broadcast.  Reliable broadcast [24] is a communication abstraction central to fault-tolerant asynchronous distributed systems. It allows each process to broadcast messages in the presence of process failures, with well-defined delivery properties. More precisely, it guarantees that non-faulty processes deliver the same set of messages, which includes at least all the messages they broadcast. This set may also contain messages broadcast by faulty processes. The fundamental property of reliable broadcast lies in the fact that no two non-faulty processes deliver different sets of messages.

Reliable broadcast in the presence of Byzantine processes (BR-broadcast).  Reliable broadcast has been studied in the context of Byzantine failures since the eighties [7]. Failures are assumed to be Byzantine, meaning that a faulty process can behave in an arbitrary fashion (i.e., its behavior is not the one described by the algorithm it is assumed to execute) [30]. Such a failure can be intentional (also called malicious) or the result of transient faults that altered the content of some local variables at some processes, thereby modifying their intended behavior in unpredictable ways.

An elegant signature-free algorithm that implements the reliable broadcast abstraction in n-process asynchronous systems where the processes communicate by message-passing and up to  of them may be Byzantine was proposed by Bracha [7]. Bracha's algorithm is optimal with respect to t-resilience, since  is an upper bound on the number of Byzantine processes that can be tolerated [8], [40]. From an operational point of view, this algorithm is based on a “double echo” mechanism of the value broadcast by the sender process. For each application message1 it uses three types of protocol messages, requires three consecutive communication steps (one for each message type), and generates  protocol messages. Another Byzantine reliable broadcast algorithm has recently been introduced in [27]. This algorithm implements the reliable broadcast of an application message with only two consecutive communication steps, two message types, and 
 protocol messages. The price to pay for this gain in efficiency is a weaker t-resilience, namely . Hence, these two algorithms differ in their trade-offs between t-resilience and message/time efficiency. Let us also note that in contrast to Consensus, which is not solvable deterministically in an asynchronous setting as soon as one process may crash [18], reliable broadcast can be implemented in such a context in ways that tolerate up to  crashes.

Causal order broadcast.  Causal order broadcast is a communication abstraction that adds “quality of service” on top of reliable broadcast. Denoted CO-broadcast (where CO stands for Causal Order), it was introduced by K. Birman and T. Joseph in a pioneering work on fault-tolerant distributed systems [5]. This seminal work, further discussed in [3], [4], considers process crash failures.

CO-broadcast states that any two messages whose broadcasts are causally related (according to Lamport's happened before relation [29]), are delivered in their causal sending order. Messages whose broadcast are not causally related can be delivered in different orders at different processes. From a causality point of view, CO-broadcast extends the FIFO property–which considers each channel separately–to system-wide causality. Like FIFO broadcast, CO-broadcast constitutes a multi-shot communication abstraction (namely, all the invocations of CO-broadcast are related by the same causality relation).

Theoretical characterizations of CO-broadcast can be found in [28], [37], [40]. Algorithms implementing this communication abstraction can be found in [42], [44] for failure-free asynchronous message-passing systems, and in [6], [9], [36], [40] for asynchronous message-passing systems where any number of processes may crash.

Although, to the best of our knowledge, this paper is the first to propose a Byzantine Causal Broadcast primitive, we believe this contribution chimes in with the recent renewed interest in consensus-free Byzantine objects, which have recently been shown to be particularly interesting in the context of cryptocurrencies [23], trustless eventually consistent distributed objects, and commutative replicated data types [45].

Limit of causal broadcast.  In the context of Byzantine failures, it is possible for a Byzantine process that receives a protocol message carrying an application message to read the content of this application message, despite the fact that it might not yet have been bco-delivered. This creates a kind of “insider trading” behavior that cannot be solved by BCO-broadcast alone. This problem was first addressed in [43]. Up to now, this notion of secure causality has been introduced only for total order broadcast ([43] with further developments in [10], [16]). More generally, we observe that, as for consensus, the definition of BCO-broadcast may need to be customized for the specific problem being solved.2

3. Computation model
3.1. On the process side
Asynchronous processes.  The system is made up of a finite set Π of  asynchronous sequential processes, namely 
. Asynchronous means that each process proceeds at its own speed, which can vary arbitrarily with time, and always remains unknown to the other processes.

Process failure.  Up to t processes can exhibit a Byzantine behavior [30]. A Byzantine process is a process that behaves arbitrarily: it can crash, fail to send or receive messages, send arbitrary messages, start in an arbitrary state, perform arbitrary state transitions, etc. As a simple example, a Byzantine process that is assumed to broadcast a message m to all the processes, can send a message 
 to some processes, a different message 
 to another subset of processes, and no message at all to the remaining processes. Moreover, Byzantine processes can collude to foil non-Byzantine processes. As is common in Byzantine-Fault-Tolerant algorithms, we assume that Byzantine processes cannot spawn, i.e., we exclude Sybil attacks. A process that exhibits a Byzantine behavior is also called faulty. Otherwise, it is correct or non-faulty.

Let us notice that, as each pair of processes is connected by a channel, a process can identify the sender of each message it receives. Hence, no Byzantine process can impersonate another process.

3.2. On the communication side
The Byzantine reliable broadcast communication abstraction.  The BR-broadcast abstraction is a one-shot communication abstraction that provides each process with two operations,  and . One-shot means that a process invokes  at most once, and BR-broadcast instances issued by processes are independent. As in [9], [24], [40], we use the following terminology: when a process invokes , we say that it “br-broadcasts a message”, and when it executes , we say that it “br-delivers a message”. BR-broadcast is defined by the following properties.

•
BR-Validity. If a correct process br-delivers a message m from a correct process 
, then 
 br-broadcast m.

•
BR-Integrity. A correct process br-delivers at most one message m from a process 
.

•
BR-Termination-1. If a correct process br-broadcasts a message, it br-delivers it.

•
BR-Termination-2. If a correct process br-delivers a message m from 
 (possibly faulty) then all correct processes eventually br-deliver m from 
.

On the safety side, BR-validity relates the outputs (messages br-delivered) to the inputs (messages br-broadcast), while BR-integrity states that there is no duplication.

On the liveness side, BR-Termination-1 states that a correct process br-delivers the messages it has br-broadcast, while BR-Termination-2 gives its name to reliable broadcast. Be the sender correct or not, every message br-delivered by a correct process is br-delivered by all correct processes. It follows from these properties that all correct processes br-deliver the same set of messages, and this set contains at least all the messages br-broadcast by the correct processes.

As indicated in Section 2, there are signature-free distributed algorithms that build the BR-broadcast communication abstraction on top of asynchronous message-passing systems in which processes may be Byzantine [7], [27], [40].

From one-shot to multi-shot BR-broadcast.  BR-broadcast is a one-shot communication abstraction: it allows a given process to invoke the operation  only once. Hence, the BR-broadcast instance invoked by 
 can be identified by the process index i.

A simple way to obtain a more general multi-shot BR-broadcast abstraction (MBR-broadcast) consists in associating a specific tag with each invocation of  by a process [9], [40]. Implementing the tags with sequence numbers, a process 
 now invokes 
, where 
 is the current value of the local integer variable used by 
 to generate its sequence numbers. This instance is then identified by the pair 
.

For the MBR-broadcast abstraction the BR-Validity and BR-Integrity property become:

•
MBR-Validity. If a correct process br-delivers a message m from a correct process 
 with sequence number sn, then 
 br-broadcast m with sequence number sn.

•
MBR-Integrity. Given a sequence number sn, a correct process br-delivers at most one message m associated with sn from a process 
.

The properties MBR-Termination-1 and MBR-Termination-2 are the same as their BR-broadcast counterparts, with the addition that sequence numbers are also preserved. Note that at this stage we are not assuming a relationship between sequence numbers and order of emission or of reception of messages. Multi-shot extensions of the one-shot signature-free BR-broadcast algorithms introduced in [7], [27] are presented in Appendix A.

Invocation pattern.  To simplify both the understanding and the presentation of the algorithm implementing the BCO-broadcast abstraction, the invocation previously written 
 by process 
 is replaced by 
.

4. Byzantine causal order broadcast: definition and a characterization
This section first proposes a definition of Byzantine causal order broadcast (BCO-broadcast). This definition is actually an extension of the MBR-broadcast abstraction with a new property called Byzantine Causal Order, that defines a partial order on the set of application messages. Then, this section presents a theorem that characterizes BCO-broadcast with a different set of properties that correspond more closely to the algorithm. This theorem will be used in Section 6 to prove the algorithm described in Section 5.

4.1. Definition
BCO-broadcast is a multi-shot communication abstraction that provides processes with the operations denoted  and  (hence a message is “bco-broadcast” and “bco-delivered”). Similarly to the case of crash-failures, BCO-Broadcast must capture causality in the entire system. This distinguishes it from FIFO-Broadcast that only requires that, for each sender process, messages from this process are delivered in their sending order. We will now give a formal characterization of this requirement.

Let BCO-Validity, BCO-Integrity, BCO-Termination-1, and BCO-Termination-2 denote the same properties as their MBR-broadcast counterparts. The definition of BCO-broadcast is based on the following partial order defined on the (application) messages.

Byzantine causal order.  Let M be the set of (application) messages bco-delivered by correct processes in an execution E of an algorithm  that respects the BCO-Validity, BCO-Integrity, BCO-Termination-1, and BCO-Termination-2 properties. A Byzantine causal order on M is a partial order 
 on M such that:

•
BCO-1. For any (correct or faulty3) process 
, the set of messages from 
 bco-delivered by correct processes is totally ordered by 
.

•
BCO-2. If 
 is correct and bco-delivered or bco-broadcast a message m before bco-broadcasting a message 
, then 
.

A Byzantine causal order 
 captures the causality relation on the set of messages bco-delivered by the correct processes. This set of messages, which includes all the messages bco-broadcast by the correct processes, may also include messages from Byzantine processes.4 BCO-1 ensures the minimal property that all correct processes agree on a same delivery order for the messages they bco-deliver from a given (correct or Byzantine) process. BCO-2 establishes the ordering relationship between the messages bco-broadcast by a correct process and the messages it previously bco-delivered or bco-broadcast.

Byzantine causal order reliable broadcast (BCO-broadcast).  The BCO-broadcast abstraction is defined by the BCO-Validity, BCO-Integrity, BCO-Termination-1, and BCO-Termination-2 properties, plus the following causality-related property.

•
BCO-Causality. There is a Byzantine causal order 
 on the set M, such that, for any pair of messages 
, if 
, then no correct process bco-delivers 
 before m.

We remark that, by the combination of BCO-1 and BCO-2, BCO-Causality states that a correct process must bco-deliver the messages from any other correct process in their sending order.
4.2. A local order property
The aim of this section is to state a theorem giving a characterization of BCO-broadcast. Following the approach introduced in [24] for crash failures, this equivalence will be instrumental in proving the algorithm implementing the BCO-broadcast abstraction. To this end, let us consider the two following properties on message delivery.

•
BCO-Fifo-order. If a correct process 
 bco-delivers two messages m and 
 from the same process 
 in the order first m and then 
, no correct process bco-delivers 
 before m (BCO-Fifo-1). Moreover, if 
 is correct, it bco-broadcast m before 
 (BCO-Fifo-2).

•
BCO-Local-order. If a correct process bco-delivers first a message m and later bco-broadcasts a message 
, no correct process delivers 
 before m.5

The two components of the BCO-Fifo-order property can be understood as follows: BCO-Fifo-1 states that no two correct processes disagree on the delivery order of the messages from the same process 
 (whether 
 is correct or Byzantine). BCO-Fifo-2 states that, if the sender is correct, the delivery order is the same as the sender's broadcast order.

The theorem that follows states a strong equivalence relating BCO-Causality on one side and BCO-Fifo-order plus BCO-Local-order on the other side:

Theorem 1

Under the assumptions of the properties BCO-Validity, BCO-Integrity, BCO-Termination-1, and BCO-Termination-2, the property BCO-Causality is equivalent to BCO-Local-order and BCO-Fifo-order.

Proof

It can be easily seen that BCO-Causality (through BCO-1 and BCO-2) implies the BCO-Fifo-order property as well as the BCO-Local-order property.

In the other direction, let  be an algorithm that satisfies the BCO-Local-order and BCO-Fifo-order properties. Let M be the set of messages bco-delivered by correct processes during an execution of . We have to show that M satisfies BCO-Causality, namely, there is a partial order 
 that is included in the (total) bco-delivery order of any correct process, and that satisfies BCO-1 and BCO-2. Let us define the relation 
 as follows:

A
If any correct process bco-delivered a message m before a message 
, both from the same sender process, then 
.

B
If any correct process bco-delivered a message m before bco-broadcasting 
, then 
.

C
If 
 and 
, then 
.

Let us now show that, for any correct process 
, the relation 
 is included in the (total) bco-delivery order at 
.

•
Case 
 because of (A). In this case, m and 
 are from the same sender and there exists a correct process that bco-delivered them in the order first m, then 
. Therefore, due to the BCO-Termination-2 and the BCO-Fifo-order properties, 
 bco-delivers them in the same order.

•
Case 
 because of (B). In this case, due to the BCO-Termination-1, BCO-Termination-2, and BCO-Local-order properties, 
 bco-delivered m before 
.

•
Case 
 because of (C). The local bco-delivery order at 
 is a total order, therefore transitively closed. Hence, if 
 due to (C), by induction, 
 bco-delivered m before 
.

It follows from the previous items that 
 does not contain cycles, and is consequently a partial order. Let us now show that the partial order 
 satisfies the properties BCO-1 and BCO-2.
•
BCO-1. Let 
 be the set of messages bco-delivered from a process 
 at a correct process. It follows from BCO-Termination-2 that any correct process bco-delivered them. Moreover, due to (A), any pair of messages m and 
 of 
 is ordered by 
. It follows that, for any (correct or faulty) process 
, the set of messages bco-delivered from 
 by correct processes is totally ordered by 
, which is the property BCO-1.

•
BCO-2. First, if a correct process bco-delivers m before bco-broadcasting 
, due to (B) we have 
. Second, if a correct process bco-broadcast m before bco-broadcasting 
, due to the BCO-Termination-1, BCO-Termination-2, and BCO-Fifo properties, all correct processes bco-deliver m before 
, hence, due to (A) we have 
. Combining the two cases, if a correct process 
 bco-delivered or bco-broadcast a message m before bco-broadcasting a message 
, we have 
, which is the statement BCO-2.

Thus 
 is a Byzantine causal order on M and all correct processes bco-deliver the messages of M in an order that contains 
, which concludes the proof of the theorem. □
5. BCO-broadcast on top of MBR-broadcast: an algorithm
While at this point the characterization of a causal order in Byzantine systems is well understood, what remains to be shown is that an algorithm that implements such an ordering and that terminates is possible. This is done in this section and the following, in which we respectively introduce Algorithm 1 that implements the BCO-broadcast abstraction and prove its correctness. This algorithm is based on the simple notion of a causal barrier [24], which we track internally using a vector clock [17], [35], [46]. While the statement of this algorithm is close to the one of existing failure-free or crash-tolerant causal broadcast algorithms, its proof (given in Section 6) is far from being a simple extension of the corresponding proofs. This heightened difficulty comes from

•
the fact that, while in the crash-failure model, a process behaves correctly until it possibly crashes, a Byzantine process can exhibit an arbitrary behavior at any time, and

•
the algorithm must ensure that correct processes (i) are never prevented from communicating between themselves, and (ii) always maintain a coherent view of message causality.

Algorithm 1
Download : Download high-res image (75KB)
Download : Download full-size image
Algorithm 1. BCO-broadcast on top of MBR-broadcast (code for pi).

Local data structures.  Each process manages the following local variables.

•
 is an integer (initialized to 0) used by 
 to associate a sequence number with the messages it co-broadcasts.

•
 is an array of integers such that 
 counts the number of messages that 
 has bco-delivered from 
.

•
 (where cb stands for “causal barrier”) is a set initialized to ∅, whose meaning is explained below.

Basic principle underlying the algorithm: capturing causal barriers.  Let us consider the example given in Fig. 1, where 
 first invoked 
 and later invoked 
. Moreover, between these two consecutive invocations, m, 
 and 
 are the messages bco-delivered by 
, and these messages are not causally related.

Fig. 1
Download : Download high-res image (57KB)
Download : Download full-size image
Fig. 1. Meaning of the set cbi.

This means that, to ensure a correct bco-delivery of 
, a correct process 
 is (i) neither allowed to bco-deliver 
 before 
 (because 
 was bco-broadcast after 
 by the same process 
), (ii) nor allowed to bco-deliver 
 before the messages m, 
 and 
 (because their bco-deliveries at 
 causally precede the bco-broadcast of 
). Hence, 
 stores in 
 the identity of the messages it bco-delivers (after the bco-broadcast of 
) that are immediate causal predecessors of the next message it will bco-broadcast in the future (here 
).

Let us remark that, if after the bco-broadcast of 
 and before the bco-broadcast of 
, 
 bco-delivers a message 
⁎
 that causally precedes 
 (where 
 is m or 
 or 
), the identity of 
⁎
 is first saved in 
 and later suppressed from it when 
 is bco-delivered. As already said, 
 contains the identities of the messages that are immediate predecessors (from a message causality point of view) of the next message that 
 will bco-broadcast.

Notations.  We use the following notations. Let m be an application message bco-delivered by a correct process, and  its identity (i.e., the identity of its BCO-broadcast instance).

•
 returns the identity of m, namely the pair .

•
 returns the message m identified by .

•
 returns the identities of the messages that define the causal barrier of m. In Fig. 1, we have 
.

Crash failures vs Byzantine failures: validity predicate.  In the crash failure model, a process always executes correctly its algorithm until it terminates or crashes. Crashes are “syntactic” in the sense that they are only due to the environment in which the application executes. The situation is different in the case of Byzantine faults, which can cause fake data to be communicated by Byzantine processes. As a result, in a Byzantine context, correct processes might need to check the validity of an incoming message in terms of application logic before delivering this message. Although such validity checks are application specific, they need to be injected within the causal broadcast algorithm. This dependency injection [20] allows correct processes to ensure that the causal past of bco-delivered messages only includes messages that are valid in terms of application semantics. This ability to ignore invalid messages while tracking causality is a natural requirement in many applications in order to curtail the disruptive power of Byzantine processes. Hence, according to the application and if needed, an appropriate predicate must allow processes to check the validity of the data contained in the messages they receive.

Following an idea introduced in [10] and used in [14], we assume an application-dependent predicate to address this issue. This predicate must be provided by application developers and invoked from within the implementation of the BCO-broadcast abstraction to control or even prevent the bco-delivery of invalid messages.6 This predicate is named  in the BCO-broadcast algorithm that follows. (The properties this predicate should satisfy will be detailed in the proof of Theorem 2.) Its parameters j and m are the identity of the sender process and the application message to be bco-delivered, respectively. For the applications based on BCO-broadcast that do not need such a predicate, it is assumed that it always returns true. An example of the use of this predicate is given in Section 7.2.

Algorithm.  The algorithm is quite simple. When a process 
 invokes , it calls the underlying  operation with the protocol message  and sequence number 
, where  is the current value of 
. Then, it resets 
 to the empty set.

When it br-delivers the message  identified  from 
, 
 waits until the associated delivery condition becomes satisfied. This condition states that the previous message bco-broadcast from 
 and all the immediate causal predecessors of m have been locally bco-delivered (which is operationally captured by the predicate 
 (line 5)).

When this occurs, 
 updates 
 to reflect the causality links created by the bco-delivery of m, namely, it suppresses from 
 the message identities that are in  (as these messages are no longer immediate predecessors of the next message 
 that 
 will bco-broadcast), and replaces them by the identity of m (line 6). Process 
 then bco-delivers m from 
 and accordingly increases 
.

Trivially, the computability assumption and the messages/time complexities of Algorithm 1 are the ones of the underlying Byzantine reliable broadcast algorithm it uses.

6. Proof of the algorithm
This section first shows that Algorithm 1 satisfies the characterization properties introduced in Section 4.2. The proof that the algorithm implements BCO-broadcast then follows from Theorem 1.

The proof consists in showing that, while correct processes may bco-deliver messages from Byzantine processes (and consequently these messages participate in the causality relation), they cannot prevent the correct processes from bco-delivering all the messages they bco-broadcast. Hence the central parts are the proof of the Termination properties (see Theorem 2), and the proof of BCO-Local-order property (see Theorem 3).

As the predicate  is application-dependent, the proofs of the BCO-Termination-1, BCO-Termination-2 and BCO-Causality properties assume that the predicate  always returns true. In the general case, the validity predicate  offers application developers a broad control of the termination properties of the BCO-broadcast algorithm. More precisely, a validity predicate conserves the termination properties of BCO-broadcast if (i) correct processes ensure that the predicate is true for the messages they broadcast, and (ii) a predicate that is true for a message m can only be invalidated by a message from the same sender as m. In this case, the FIFO-delivery of messages and the reliability of the underlying MBR-broadcast used by BCO-broadcast continue to guarantee the termination of BCO-broadcast. As to the causal delivery order of messages, the validity predicate has no influence on the BCO-Causality property of the algorithm, as it can only be used to introduce new delivery constraints, but not to cancel the causal order delivery constraints coded by the wait statement of line 5.

Theorem 2

Algorithm 1 satisfies the BCO-Validity, BCO-Integrity, BCO-Termination-1, and BCO-Termination-2 properties.

Proof

Let us remember that the underlying MBR-broadcast abstraction ensures that all correct processes br-deliver the same set of messages and this set includes at least the messages they br-broadcast.

•
Proof of the BCO-Validity property. This property directly follows from MBR-Validity. This is because for a message m to be bco-delivered (by a correct process) from a correct process 
 (line 7), it has to be br-delivered from that same process, meaning it was br-broadcast by 
 at line 2) and consequently 
 bco-broadcast m.

•
Proof of the BCO-Integrity property. The proof follows the fact that each message m that is bco-delivered by a correct process 
 has an identity , and MBR-Integrity guarantees that no two messages are br-delivered with the same identity. Consequently, 
 cannot bco-deliver another message 
 from 
 with the same identity.

•
Proof of the BCO-Termination-1. It follows from the bco-delivery procedure (lines 5-8) that, for any correct process 
 and at any time, we have 
. Therefore, when a correct process 
 bco-broadcasts a message m with sequence number sn, it br-broadcasts  (line 2), and will br-deliver it (by MBR-termination-2), and the middle term of the wait condition (line 5) is already verified. The first term of the wait condition imposes that the process's own messages are bco-delivered in FIFO order: it becomes true for the first sequence number not yet bco-delivered. Since all sequence numbers are br-delivered, all messages from 
 preceding m (if any) and m itself are eventually bco-delivered by 
.

•
Proof of the BCO-Termination-2. Let 
 be a correct process, and 
 the sequence of messages bco-delivered by 
. We show by induction the following property: if 
 bco-delivers all the messages 
, then all correct processes bco-deliver all the messages 
.

–
Base case: . The property is true because the set of messages bco-delivered by 
 is then empty.

–
General case. Suppose that, for a given , all correct processes bco-delivered 
. We need to show that all correct processes bco-deliver 
. When 
 bco-delivers 
 the wait condition at line 5 is verified at 
 with the following values (where  and  are the sequence number and the sender process of m, respectively, and ):(1)

Let 
 be another correct process. After it bco-delivered 
, a similar property is verified for 
:(2)

In equation (2), “=” is replaced by “≥” since 
 may have bco-delivered messages other than 
. This equation remains true in subsequent steps, as 
 can only increase. Thus after 
 bco-delivered 
 and br-delivered 
, the second term of the wait condition of line 5 is true.

Let us note 
 the sender of 
. When 
 bco-delivers 
, we also have 
, which combined with (1) yields(3)

There is a moment when 
 has bco-delivered 
 and has br-delivered 
 but not yet bco-delivered it. At this moment, since by MBR-Integrity 
 is the only message with sequence number 
 from 
 that 
 ever br-delivers, and because the first part of line 5 imposes a FIFO order delivery, we have 
. Including the bound from (2), we obtain:(4)

Rewriting using (3) we obtain:(5)

Thus 
, which is the first condition of line 5, thus the wait statement at line 5 terminates at this moment and 
 bco-delivers 
. □

Theorem 3

Algorithm 1 satisfies the BCO-Fifo-order and BCO-Local-order properties.

Proof

•
Proof of the BCO-Fifo property. Suppose a correct process 
 bco-delivers first a message m, then a message 
, both from the same sender 
. These messages were br-delivered to 
 with some sequence numbers, sn and 
. As 
 bco-delivers message from any process in the order defined by their sequence numbers, we have 
. It follows then from the MBR-Termination-2 property that all correct processes bco-deliver m and 
 with sequence numbers sn and 
, respectively. It follows that any correct process bco-delivers m before 
.

If the sender 
 of m and 
 is correct, it associated the sequence number sn with m and the sequence number 
 with 
. It follows that 
 bco-broadcast m before 
.

•
Proof of the BCO-Local-order property. Let → be the relation defined on application messages as follows:

R1
If m is a message bco-delivered by a correct process 
, and  is the associated protocol message, then for each 
 we have 
.

R2
If m and 
 are any two messages successively bco-broadcast by the same correct process 
, with no other bco-broadcast invocation between them, then we have 
.

The condition in the  statement at line 5 directly encodes the relation →. Therefore, if 
, no correct process bco-delivers 
 before m. Let 
⁎
 denote the reflexo-transitive closure of →. The bco-delivery order at correct processes also respects 
⁎
.

Let 
 be a correct process that bco-delivers a message m before bco-broadcasting a message 
, and let 
 be a correct process that bco-delivers 
. We have to show that 
 bco-delivers m before 
.

To this end, let 
 be the first message that 
 bco-broadcast after bco-delivering m. We have 
⁎
 (either because 
 or by recursively applying (R2)). What remains to be shown is that 
⁎
.

Let us now consider the sequence of messages 
 bco-delivered by 
, starting at 
 and ending at 
, which is the last message 
 bco-delivered before bco-broadcasting 
. Let 
 be the value of 
 just before 
 bco-delivered 
 (lines 6-7). To prove BCO-Local Order we need to show that
⁎
 For , due to the update of 
 just before the bco-delivery of 
, we have 
. As 
⁎
, the property follows. Let us now assume that, for a given  we have 
⁎
. When 
 bco-delivers 
 there are two cases.

–
If 
, due to update of 
 just before the bco-delivery of 
 at 
 (line 6), we have 
. We then take 
.

–
If 
, due to (R1) we have 
. Moreover, due to the update of 
 at line 5, we have 
. Hence 
 is such that 
⁎
. We then take 
.

Therefore, in both cases we have 
⁎
. It follows by induction that 
⁎
.
By definition, 
 is the last message bco-delivered by 
 before bco-broadcasting 
, and thus 
. Moreover, we have 
, therefore due to (R1) we have 
. It follows that 
⁎
, from which we conclude that 
 bco-delivers m before 
, which concludes the proof of the theorem. □

Theorem 4

Algorithm 1 implements the BCO-broadcast abstraction.

Proof

By applying Theorem 1 to the results of Theorem 2 and Theorem 3, we obtain that Algorithm 1 satisfies the BCO-Causality property. With Theorem 2, this proves that it implements the BCO-broadcast abstraction. □

7. Byzantine causal broadcast in action
7.1. Building the partial order on the messages
If needed by the application, each correct process 
 can easily build the partial order on the set of messages it bco-delivers. Let 
 be the message causality directed graph (initially empty) known by process 
. A vertex is a message identity . It is initially not marked, and becomes marked when the corresponding message is bco-delivered.

To build the graph 
, we modify Algorithm 1 as described in Algorithm 2. Lines 1-4 are the same. But, for clarity, we use a different invocation model for  than in Algorithm 1. When the argument of the wait operation in line 5 is satisfied, Algorithm 2 marks the message as “ready to be delivered” by adding a new vertex and its associated directed edges to the graph 
 (line 7-M, replacing line 7). The application then chooses to deliver messages when needed by invoking  (lines 9-12) explicitly as opposed to using a callback like in Algorithm 1.

Algorithm 2
Download : Download high-res image (96KB)
Download : Download full-size image
Algorithm 2. Extended algorithm (code for pi).

7.2. Money transfer based on BCO-broadcast
A money transfer algorithm.  Guerraoui et al. presented in [23] an important result related to money transfer, a service that is for instance provided by cryptocurrencies [38]. One of the main issues in such systems is to prevent double spending attacks, i.e. to prevent users from using the very same money to buy different goods. In [23], Guerraoui et al. proposed two algorithms to solve the money transfer problem when, for each account, there is a single process that is allowed to transfer money from this account to other accounts. This process is called the owner of the account.7

The first algorithm, which only tolerates crash failures, relies on a single writer/multi reader snapshot object [1], which can be implemented despite asynchrony and process failures.8 The second algorithm is made to tolerate Byzantine failures. It eschews snapshot objects and directly implements money transfers in an asynchronous message-passing system where up to  processes can be Byzantine. This algorithm, which uses an underlying secure broadcast abstraction [34], requires processes to exchange message carrying “histories” which are data structures that grow indefinitely.

A rewriting of Guerraoui et al.'s money transfer algorithm.  The reader is referred to [23] for a formal specification of the money transfer problem and the proof of the associated algorithms. Algorithm 3, described below, is a simple rewriting based on BCO-broadcast of the message-passing algorithm presented and proved in [23]. A process invokes the operation  to know the balance of 
, and the operation  to transfer the amount v to 
. Without loss of generality, we assume a correct process 
 does not transfer money to itself.

Algorithm 3
Download : Download high-res image (137KB)
Download : Download full-size image
Algorithm 3. BCO-broadcast-based rewriting of [23] (code for pi).

As in [23], a money transfer of the quantity v by a process 
 to a process 
 is internally represented by a pair , and each process 
 manages a local multiset9 denoted 
 that records all the transfer operations as known by 
. More explicitly, 
 means that 
 knows that 
 transferred the quantity v to 
. In particular, 
 contains all the transfers performed by 
. In our formulation, two transfers of the same amount v by the same process 
 to the same process 
, appear as identical pairs () in the multiset 
 of a process 
. This multi-set representation is equivalent to that of [23], in which 
 is a set that stores quadruples of the form  instead of pairs: in the quadruple, sn is the sequence number associated by 
 with the transfer identified by .10

BCO-broadcast-based description of the algorithm.  Let us first look at the function  invoked by 
. All the processes are initialized with the same constant array  where  is the initial value of 
's account. The transfers from 
 to the other processes that are known to 
 are stored in 
, as explained just above. Hence, from 
's local point of view,  collects all the transfers to 
, (line 1), while  collects all the transfers from 
 (at line 2). When invoked by a process 
, the operation  returns the current value of 
's account, as known by 
 (line 3).

When invoked by a process 
, the operation  transfers the quantity v from 
 to 
. To this end, 
 first checks its own account balance (line 5). If the balance is not greater than or equal to v, the transfer aborts (line 6). Otherwise, the transfer can occur. In this case, 
 bco-broadcasts the message transfer (line 7) and waits until the transfer is locally committed (line 8).

When 
 bco-delivers a message transfer issued by a process 
, it locally updates its view concerning 
's transfers, namely 
 (line 10). Moreover, if 
 is 
, it switches 
 to true (line 11), which allows it to terminate its transfer (line 8).

To prevent over-spending, the predicate  where m= transfer must guarantee that each correct process 
 locally sees that 
 owns enough money in its account to transfer the quantity v to 
. Hence ,transfer
11 (line 12). Since a money transfer that has been accepted can never be undone, double-spending attacks cannot occur in this system. It is not difficult to see that the validity predicate of Algorithm 3 fully maintains the termination of BCO-broadcast, as: (i) a correct process 
 ensures that  before broadcasting transfer, and (ii)  can only be invalidated by withdrawing money from 
's account, which only 
 can do.

8. Conclusion
After proposing a definition of the Byzantine causal broadcast abstraction, this paper presented an algorithm that implements this specification in asynchronous message-passing systems (a simplified version of it can be trivially obtained if one is interested in FIFO message delivery only). As far as we know, this algorithm is the first ensuring causal message delivery in the presence of Byzantine processes.

Its design relies on a modular decomposition (such as the ones presented in [24], [40]), which makes algorithms easier to understand and prove. In particular, the algorithm relies on an underlying multi-shot reliable broadcast algorithm. It works with any such underlying algorithm and inherits is computability bound and time/message complexities. When instantiated with the reliable broadcast algorithm described in [7] it requires  (which is resilience optimal), 3 consecutive communication steps and  protocol messages. When instantiated with the reliable broadcast algorithm described in [27] it requires , 2 consecutive communication steps (which is optimal), and 
 protocol messages.