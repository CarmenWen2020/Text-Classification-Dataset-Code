Abstract
All spanning tree generation of a simple connected graph is a well-approached problem in graph theory. In this paper, an algorithm based on a new technique, namely divide-and-conquer, has been proposed. The performance of the proposed algorithm has also been benchmarked against several existing algorithms, including one algorithm implemented in parallel, in this domain. The basis of comparison is on the number of circuits generated and CPU time taken by each of the algorithms compared, using a set of randomly generated graph instances on a common platform.

Keywords
Divide-and-conquer
Graph theory
Spanning tree

1. Introduction
Spanning trees have always been an area of focus for academicians while dealing with different graph related problems for its huge application area in the fields of medical science, computer science, chemistry, biology, astronomy, and so on. Different areas of computer science like image processing, networking, social media, and many others use either minimum spanning trees or all possible spanning trees.

Like computation of a minimum spanning tree of a graph, computation of all possible spanning trees has also gone through evolutions in approaches adopted for its solutions. Despite so many existing algorithmic techniques and even a large number of distinct algorithms, we have developed a new algorithm in this paper for solving the same problem of about sixty years old. Our algorithm makes use of a completely different approach of divide-and-conquer to generate all spanning trees of a simple and connected graph. Divide-and-conquer, a well-known algorithmic paradigm works on three phases: divide, conquer, and combine. As per the divide-and-conquer paradigm, we recursively break the given problem into several subproblems that are smaller in size but possess all the properties of the original problem, solve the subproblems recursively, and then combine these solutions to find a solution to the original one.

A rigorous comparison of our algorithm with other standard algorithms (of different approaches) in this problem domain has been carried out in this paper with respect to a varied set of instances. We anticipate that our unique approach towards solving the problem, comparison results and the graphs generated will enrich the concerned problem domain.

2. Applications
The problem of finding all possible spanning trees of a given connected graph can be restated as:

Given a set of nodes, find all possible distinct edge combinations which minimally connect (without introducing any cycle) all the nodes.

Let us try to map this problem in real-life situations. It is quite essential for the public transportation authorities to identify all possible routes that may exist between sets of pairs of locations/destinations within a city. This is one of the primary inputs in determining—

∘
The routes for public transportation.

∘
How to apply restrictions (such as one-way traffic in certain routes, only right-turn is allowed, etc.) on different routes during busy hours and still be able to connect the locations.

∘
The evacuation strategies during an emergency.

Similarly, it is extremely important for network planners/designers to determine and understand all possible routes that may exist in a telecom network which connects all the nodes, to help them in determining—

∘
How fault tolerant the network is when more than one link failure occurs simultaneously in the network.

∘
Supportive simulations necessary to prevent and/or overcome various link failure scenarios for impact analysis and take proactive measures.

Nowadays, social networking has become a mainstream communication mechanism. A number of companies across the globe are monetizing the social networking data in various ways. Social network data is typically modelled as graphs, where individuals are modelled as nodes and any form of communication between individuals gets modelled as links. Now to be able to monetize raw social network data, it is quite essential to identify influencers, detect communities so that various advertising agencies use such data to run targeted campaigns for their products. Post detecting communities, it is quite essential to understand “How many ways all the nodes within the community are connected?”. To answer this question one needs to find all possible spanning trees that exist and allows the advertisement agencies to define optimal campaign strategy.

While discussing the application areas of spanning trees, the Minimum Spanning Tree (MST) computation probably has a significant number of practical applications. The problem of finding MST can be visualized as, more constraint version of finding all possible spanning trees for a given graph. However, a number of applications require to compute not only the MST of the given graph but also to find the ordered MSTs (sorted based on cost or other parameters as required) in a given graph. To find the ordered MSTs of a given graph, the following approach can be adopted.

a.
Find all possible spanning trees of the input graph.

b.
Associate edge weights to the individual branches of the trees.

c.
Determine the sum of edge weights for individual spanning trees.

d.
Sort and Report.

Hence, to generalize further the application areas of “finding all possible spanning trees for a given connected graph”, we may say that: any real-life problem which can be modelled as a connected undirected graph and there is a need to find all possible edge combinations which minimally connect (without forming any cycle) all the nodes of the graph, to address various scenarios of the real-life problem under consideration, would require a similar algorithm as has been proposed in this article. During the algorithm selection phase, the end users can refer to the benchmarking results obtained in this research article along with considering additional constraints like computing platform, programming language chosen, and so on and so forth.

3. Literature survey
Generation of all possible spanning trees of a simple and connected graph is a well-explored area of research in graph theory. There are different methods adopted by different academicians for this purpose, namely, tree testing method [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], elementary tree transformation method [11], [12], [13], [14], [15], [16], [17], [18], [19], and successive reduction method [20], [21], [22].

(i)
Tree testing method: The algorithms adopting this method generate different combinations of  edges (n is the order of the graph being considered) and test whether the sequence is a tree or not. Some of the algorithms following this method are by Berger [1], Char [2] (further extended and modified by Jayakumar et al. [23], [24], [25]), Gabow and Myers [3], McIlroy [4], Naskar et al. [5], [6], [7], Piekarski [8], Sen Sarma [9], Trent [10], and many more.

(ii)
Elementary tree transformation method: Starting with an initial tree, this method generates trees from other trees by replacing one or more suitable edges. The algorithms by Cherkasskii [11], Hakimi [12], Kapoor and Ramesh [13], [14], Matsui [15], [16], Mayeda [17], Shioura and Tamura [18], Shioura et al. [19] fall under this category.

(iii)
Successive reduction method: The given graph is reduced to smaller subgraphs and trees of the original graph are obtained from the trees of the subgraphs. Algorithms by Minty [20], Smith [21], Winter [22] are some such algorithms.

Among the twenty-five above-mentioned algorithms, we have taken only six of them (with at least one from each of the three categories or families discussed above) for implementation and subsequent comparison with our algorithm devised in this paper.

Let us also mention, in this regard, that the above-mentioned classification is not exhaustive. Many other methods/techniques for spanning tree generation are being developed continuously, and many more may come up in the near future. It is worth mentioning that the algorithms by Chakraborty et al. [26] generate all spanning trees using entirely different techniques, which do not fall under any of the three categories, highlighted above. One of them initiates the generation process by converting the given graph into its weighted and complete equivalent, while the other does not, though the underlying approach they have used is very similar.

4. Algorithm ASTG-by-DCC at a glance
Algorithm ASTG-by-DCC (All Spanning Tree Generation-by-Divide Conquer Combine), as has been proposed in this paper, generates all spanning trees using divide-and-conquer paradigm. It starts with , a graph with or without pendant edge(s), as input and terminates after generating all possible spanning trees from it. The steps of the algorithm, to see it at a glance, are briefly discussed in Fig. 1.

Fig. 1
Download : Download high-res image (547KB)
Download : Download full-size image
Fig. 1. Algorithm ASTG-by-DCC.

In the following section, Section 5, we go for a detailed description of the development of ASTG-by-DCC. The removal of pendant edges (as mentioned in Step 2 of Fig. 1) has been discussed in Section 5.1. The Divide, Conquer, and Combine phases of the algorithm, as mentioned in Steps 3, 4, and 5 of Fig. 1, have been discussed vividly in Sections 5.2, 5.3, and 5.4, respectively. Phase 1 and Phase 2 tree generations have been done in Sections 5.4.2 and 5.4.3, respectively.

5. Development of new algorithm, ASTG-by-DCC
This section focuses on the development of our new algorithm for All Spanning Tree Generation by Divide-Conquer-Combine, algorithm ASTG-by-DCC, with illustrations and suitable examples. Divide-and-conquer [27] is a top-down technique for designing algorithms that consists of the following three phases.

•
Divide (Splitting the graph into fundamental circuits),

•
Conquer (Generation of a collection of components, satisfying certain predefined criteria), and

•
Combine (Combining edges of components by creating a special data-structure named component table to form trees of the original graph).

The different stages involved in the development of the algorithm are as follows.
5.1. Removal of pendant edges
In this section, we need to remove the pendant edges (if any) recursively from the given graph, say .

Pendant vertex:
A vertex of a graph with degree one.

Pendant edge:
An edge of a graph incident on a pendant vertex.

The concept behind this step is that the pendant edges of a graph are always present in all its spanning trees. Thus, removing them at the beginning and re-joining them to the spanning trees of G (a graph which has been obtained post removal of pendant edges) at the end will ensure their presence in the resultant spanning trees of the original graph .

Recursive removal of pendant edges means, if there is a pendant edge and removal of it gives rise to more pendant edge(s), then the resultant pendant edge(s) also needs to be removed. This process continues until there are no remaining pendant edges in G. Here we present a recursive algorithm, Remove_PE to remove pendant edge(s) of any given input graph, in Fig. 2. It is obvious that  will be equivalent to G if the original graph has no pendant edges and the cardinality of both ES and VS will be zero.

Fig. 2
Download : Download high-res image (102KB)
Download : Download full-size image
Fig. 2. Algorithm Remove_PE.

5.2. Divide: splitting the graph into circuits
In this phase of algorithm ASTG-by-DCC, we divide the graph into circuits, preferably fundamental circuits. An initial spanning tree T of a given graph can be obtained by applying either BFS (Breadth First Search) or DFS (Depth First Search) traversal technique.

Let us assume G to be a simple graph with n vertices and m edges. The edge-set of G (consisting of m edges) can be split up into two sets: those which are in T (termed as branches) and those which are not in T (termed as chords). Since, the number of branches in any spanning tree of G is always , so the number of chords of G must be . If we label the branches of T as  and the chords or non-branches of T as ; then there exists one and only one circuit in T+ (which is the subgraph of G induced by the branches of T and ). We call this circuit a fundamental circuit (a circuit formed by adding edges to T from ﹨. The set of () chords and the initial spanning tree together may result in maximum () number of fundamental circuits. In our algorithm, the fundamental circuits have been generated from an initial DFS tree, obtained from G, by selecting an arbitrary vertex, as the start vertex.

5.3. Conquer: generation of basic components
This is the most important phase of our algorithm, where we define the components which are mostly responsible for the generation of trees and which effectively determines the efficiency of the algorithm. Here we first classify the above-mentioned fundamental circuits into a group of Edge-Adjacent Circuits (EACs) and Vertex-Adjacent Circuits (VACs), select a pivotal circuit from them, and then form the three types of components, namely, Type-X, Type-Y, and Type-Z based on criteria that are being discussed in subsequent sections.

5.3.1. Classification of circuits and creation of EAC and VAC lists
The algorithm defines two types of circuits, vertex-adjacent circuits (VACs) and edge-adjacent circuits (EACs).

Vertex-Adjacent Circuits:
Two adjacent circuits in a given graph are said to be vertex-adjacent if and only if they are connected by a single vertex, i.e., there is only one vertex common in between them.

Edge-Adjacent Circuits:
Two adjacent circuits in the graph are said to be edge-adjacent if and only if there is at least one edge common to both the circuits.

A list of all circuits with their VACs and EACs for the graph G is to be created.

5.3.2. Selection of pivotal circuit
Pivotal Circuit:
A circuit with the maximum number of EACs.

In case multiple circuits with the same (maximum) number of EACs exist in an input graph, then the tie has been resolved arbitrarily, and only one such circuit has been designated as the pivotal circuit.

The selection of pivotal circuit has an underlying significance, which has been discussed later in this article, in Section 5.6, as it requires knowledge of the following sections.

5.3.3. Selection of Type-X edges
If a circuit is chosen from the set of fundamental circuits, then it is termed as a Type-X component. All the vertices and edges of that circuit are then marked as visited (i.e. included in a component). This is a mandatory component, i.e. there must be at least one Type-X component created from the given graph.

The pivotal circuit selected in the previous section is the first and foremost Type-X component of the given graph. In the list of circuits created from the graph, if there is any circuit vertex-adjacent to the pivotal circuit or any other circuit forming Type-X component, then that circuit is also considered to be a Type-X component. Note that if there are at least two circuits, say  and , vertex-adjacent to any circuit selected as a Type-X component, then we select both  and  if and only if  and  are not adjacent to each other (neither edge-adjacent nor vertex-adjacent); otherwise, we select the one smaller in size. This process continues till all the circuits get scanned. In the theorem mentioned below, we prove that the vertex-adjacent circuits never create any circuit during spanning tree generation.

Theorem 1

If two circuits are vertex-adjacent to each other, then any edge-combination (or edge-sequence) taken from these two circuits does not create any resultant circuit during generation of spanning trees using ASTG-by-DCC.

Proof

Vertex-adjacent circuits are adjacent through vertices only, not edges, as articulation points. As the vertex-adjacent circuits under consideration do not form a cycle, they may form a chain of circuits only through articulation points. Now, if we consider an edge combination where only one edge is excluded from each circuit, the resulting graph structure obtained must be a spanning tree. However, if the resultant graph obtained is not a spanning tree, at least two circuits under consideration inevitably form a composite circuit (i.e., edge-adjacency is there) that contradicts the basic assumption of this theorem. □

In this regard, let us also mention that sometimes we may have some circuits in a graph that are neither vertex-adjacent nor edge-adjacent to each other. There may be disjoint fundamental circuits in a given graph. In such cases, all the disjoint circuits may be treated as separate Type-X components, as they will never form a circuit among themselves. Let us consider the following example to clarify the above-mentioned case.

In Fig. 3, we have shown a graph with two vertex-disjoint fundamental circuits  and , connected by a bridge . A bridge is such an edge in a graph removing which disconnects the graph. When two (or more) circuits are connected by a bridge, removing the bridge will result into disconnection of the circuits as well as the graph itself. Though  and  are not vertex-adjacent to each other, both of them will be treated as separate Type-X components here.

Fig. 3
Download : Download high-res image (12KB)
Download : Download full-size image
Fig. 3. Vertex-disjoint circuits.

5.3.4. Selection of Type-Y edges
Type-Y component is chosen based on a vertex that does not belong to any Type-X component or an unvisited vertex. After the creation of the Type-X component(s), we go for searching Type-Y component, which we may or may not find, and is influenced by the selection of the pivotal circuit. In this regard, note that there are two different cases which may arise:

Case 1: If there is more than one such unvisited vertex, and if the vertices are connected to each other in such a way that no edges of Type-X component are included, then only one Type-Y component is formed with them. In other words, the Type-Y partition is composed of a maximal set of unvisited connected vertices along with the edges incident on them, excluding the edges that are already included by one/more Type-X partition(s).

Case 2: If the vertices are not directly connected to each other, they form separate Type-Y components.

In Fig. 4, we have considered the above two cases of Type-Y components, as mentioned above. In Fig. 4(a), if the circuit  (constituting vertices , , , and ) is considered to be a Type-X component, then vertices , , and  remain unvisited, and they are connected by some edges that are not part of the Type-X component. Hence, they form a single Type-Y component along with the edges , , , and . We may note that the vertices  and  are shared between the Type-X and Type-Y components, whereas the vertices , , and  are exclusive to the Type-Y component.

Fig. 4
Download : Download high-res image (53KB)
Download : Download full-size image
Fig. 4. (a) Case 1: Graph with single Type-Y component with connected vertices, (b) Case 2: Graph with multiple Type-Y components with disconnected vertices, (c) Cases 1 and 2 of Figs. 4(a) and 4(b) combined.

On the other hand, in Fig. 4(b), if the circuit  (constituting vertices , , , and ) is again considered to be a Type-X component, then vertices  and  remain unvisited. However, they are not connected to each other directly with some edges that are not part of the Type-X component. Hence,  (along with the two edges incident on it) and  (along with the two edges incident on it) form two separate Type-Y components. We may note that vertices  and  are exclusive to the two Type-Y components, respectively, while vertices , , , and  are shared ones.

There may be some situations where both the above-mentioned cases are found in the same graph. To understand this, we may consider the graph in Fig. 4(c). In this graph, there are two types of Type-Y partitions. The first Type-Y partition consists of vertices , , and , along with edges , , , and . Hence, it is the maximal set of unvisited connected vertices together with the unvisited edges incident on them. The second Type-Y partition consists of only one vertex  and the edges incident on it, namely  and . Since  remains unvisited after the identification of the Type-X partition and it was not connected with the other unvisited vertices,  forms a separate Type-Y partition with its incident edges.

5.3.5. Selection of Type-Z edges
A component (consisting of a single edge) is Type-Z if it contains an edge whose end vertices are shared by one or more Type-X or Type-Y component(s) or both. Similar to Type-Y component, the generation of Type-Z component is also influenced by the selection of a pivotal circuit. It is also necessary to determine if a Type-Z component is a bridge or not for a given graph.

5.3.6. More on Type-X, Type-Y, and Type-Z components
It has already been mentioned in the previous sections that, one or more Type-X, Type-Y, and Type-Z components can be defined for a given input graph. Let us state in this regard that cardinality of a Type-X component set (denoted by |Type-X|) refers to the number of Type-X components for a given graph. Similarly, |Type-Y| and |Type-Z| have their usual meaning. Each of the components in a component set (of any type) is termed as the member of that set.

Lemma 1

Any pair of members of Type-X, Type-Y, and/or Type-Z component set is edge-disjoint.

Proof

Type-X components always contain the fundamental circuits encompassing certain vertices and edges. The vertices belonging to these circuits may have some other edges (that do not belong to the circuits) incident on them. These edges can lead to the formation of Type-Y or Type-Z components. If any such edge has its other endpoint still unvisited, then it forms a Type-Y, or else, Type-Z component. According to the basic guideline towards the formation of components, Type-Y components (if any) are always formed after formation of Type-X, and Type-Z components (if any) are formed after the formation of Type-Y (if any). No edges from the circuits forming Type-X components ever get included in Type-Y or Type-Z components. While vertices can be shared among Type-X, Type-Y, and Type-Z components, edges are never shared. □

Corollary 1

If  and  be the sets of vertices included in the Type-X and Type-Y component sets and  be the set of vertices shared by all three types of components, then , where V is the set of all vertices for a given graph G.

Corollary 1 is eventually true as Type-Z component set contains only shared vertices.

Corollary 2

If  and  be the sets of edges included in the Type-X and Type-Y component sets, then the cardinality of Type-Z component set or |Type-Z| is , where E is the set of edges for a given graph G.

As mentioned earlier that Type-X is a mandatory component, whereas Type-Y and Type-Z are optional ones, let us take examples to illustrate this concept. In the graph in Fig. 5(a), if  is the start vertex and we apply DFS, to visit the next vertex with least number among the adjacent vertices, then we get a DFS tree as follows:  (shown with brown lines in Figs. 5(a) and 5(b)). Subsequently, the fundamental circuits formed are , , and . Now, following the concept of selection of Type-X component (using VAC and EAC, mentioned in Section 5.3.1, we find that  is the only Type-X component for the given graph (shown with bold lines in Fig. 5(a)). As a result, vertices  and  remain unvisited (with respect to the selected Type-X component), and hence, forms two Type-Y components encompassing , ,  and the other with , , . The Type-Y edges , , and ,  are shown with dotted lines in Fig. 5(a). Thus, it has no remaining edge or Type-Z component. On the other hand, the graph in Fig. 5(b) has only one Type-X component , shown with bold lines. Consequently, the remaining edges  and  form two distinct Type-Z components (shown with dashed lines in Fig. 5(b)). Thus, we find no Type-Y component in the graph in Fig. 5(b).

Fig. 5
Download : Download high-res image (84KB)
Download : Download full-size image
Fig. 5. (a) A graph with Type-X and Type-Y but no Type-Z component, and (b) A graph with Type-X and Type-Z but no Type-Y component.

Corollary 3

If the given graph is a tree, all edges are eliminated during removal of pendant edges, and only one vertex is left behind.

5.4. Combine: combining edges of components
This section is mainly responsible for the generation of trees. For this purpose, we form a component table so that we can combine all the three types of components properly in a systematic manner to give rise to the resultant spanning trees in two phases.

5.4.1. Formation of component table
A component table with the following parameters is formed.

(a)
Components denote a serial number for each component. Each of the Type-X, Type-Y, and Type-Z components are being assigned a unique number .

(b)
The component type is either Type-X or Type-Y or Type-Z.

(c)
The total number of edges denotes the total number of edges which are the members of a specific component.

(d)
The number of exclusive vertices denotes the total number of vertices that are exclusive to a component and are not members of any other component.

(e)
The exclusive vertices are the list of vertices, exclusive to a component.

(f)
The minimum number of edges denotes the least number of edges that we must include from a component during combination. This is the same as the number of exclusive vertices of the component so that no vertex gets disconnected.

(g)
The maximum number of edges denotes the maximum number of edges that can be included from each component. For Type-Y and Type-Z it is same as the total number of edges. Whereas, it is one less than the total number of edges for a Type-X component since each Type-X component is essentially a circuit.

(h)
The key value is chosen to be the maximum number of edges for a Type-X component, minimum number of edges for a Type-Y component, and zero for a Type-Z component (which is not a bridge). If a Type-Z component is a bridge, then the key value for that component is one. The key values for all the different components help to generate the key combination in Phase 1.

5.4.2. Phase 1: generation of spanning trees
In this phase, we generate spanning trees by making all possible combinations of key number of edges (given by key values) from each component obtained from the component table. If k is the key value for any component, then we need to choose k edges from the set of edges included in the component. While choosing these edges from a specific component, exclusive vertices play a major role. For a specific component, the edge combinations which do not traverse all the exclusive vertices of that component are treated to be invalid and have to be discarded. Only a valid edge combination (consisting of k edges) of any component can be combined with another valid edge combination of other component(s) to form the key combination in Phase 1. Consequently, no non-tree is generated in this phase of spanning tree generation, as has been claimed in the following theorem.

Theorem 2

An edge sequence generated in Phase 1 for the key combination would always be a spanning tree.

Proof

Let us first claim that an edge sequence generated in Phase 1 for the key combination will never result in a spanning tree.

As per the proposed algorithm, the input graph , with n vertices and m edges can be broken into one or more Type-X, zero or more Type-Y, and zero or more Type-Z components, where:

•
Each Type-X component comprises one Fundamental Circuit.

•
Each Type-Y component comprises connected vertices and its incident edges (which are not in any Type-X component). In case of unvisited vertices, which are not directly connected, separate Type-Y components are being formed comprising each unvisited vertex and the corresponding incident edges.

•
Each Type-Z component comprises a single edge whose end points also belong to one or more Type-X or Type-Y component(s) or both.

Now to prove the initial claim made is wrong, one need to evaluate four different scenarios that may occur:

Case 1: The ‘Conquer’ step of the proposed algorithm divides the input graph G into one Type-X component only.

As per the ‘Phase 1’ of the proposed algorithm, the edge combinations which traverses all the exclusive vertices have been considered as valid combinations and being considered for final tree generation. Now since each Type-X component consists of one fundamental circuit, the maximum number of edges which have been considered for tree generation is always one less than the total number of edges in any Type-X component. Therefore, if the input graph G results in one Type-X component then the edge selection strategy adopted in Phase 1 will never result in a circuit and will always generate spanning tree(s).

Case 2: The ‘Conquer’ step divides the input graph G into more than one Type-X components only.

As per the proposed algorithm, the Type-X component set comprises a set of vertex-adjacent circuits, where individual Type-X component contains one fundamental circuit. A set of vertex-disjoint circuits may also form a set of Type-X components. Neither vertex-adjacent circuits ever create any resultant circuits (as per Theorem 1) nor do the vertex-disjoint circuits. Therefore, the edge selection strategy adopted in Phase 1 will never result in a circuit and will always generate spanning trees.

Case 3: The ‘Conquer’ step divides the input graph G into one or more Type-X component(s) and one or more Type-Y component(s).

As per the proposed algorithm, each Type-Y component may consist of two types of edges, one type of edge(s) which maintains the relationship between Type-X and Type-Y component and the other type maintains the connectivity between adjacent vertices. Now the proposed algorithm only considers those edge combinations which traverse all the exclusive vertices to maintain the connectivity and for the Type-Y components it puts a further restriction on the total number of edges, which is same as the number of exclusive vertices per Type-Y component. Therefore, this selection process ensures incorporating the members of Type-Y component(s) along with the members of Type-X component(s) will never result in a circuit formation and will always generate spanning tree(s).

Case 4: The ‘Conquer’ step divides the input graph G into one or more Type-X component(s), zero or more Type-Y component(s) and one or more Type-Z component(s).

As per Phase 1, Type-Z component(s) (which are not bridge(s)) does not play any role and hence will neither contribute in any circuit formation nor tree generation. Type-Z components, which are bridges, will also never contribute to circuit formation.

In Table 1, we have explained these four different cases at a glance for better understanding.


Table 1. Four different scenarios at a glance which led to the proof of Theorem 2.

Number of Type-X component(s)	Number of Type-Y component(s)	Number of Type-Z component(s)	Observation
Case 1	1 (one circuit)	0	0	Max. no. of edges =Total no. of edges in Type-X −1, so no resultant circuit

Case 2	More than 1 (vertex-adjacent/vertex-disjoint circuits)	0	0	Vertex-adjacent/vertex-disjoint circuits do not form circuits (according to Theorem 1)

Case 3	1 or more	1 or more	0	Only the edges which traverse all the exclusive vertices (which maintain connectivity) per Type-Y component are considered, along with members of Type-X component(s), so no circuit formation.

Case 4	1 or more	0 or more	1 or more	Type-Z component(s) (which are not bridges) are not included in Phase 1, so no circuit formation. Bridges do not form circuit.
As per the ‘Conquer’ step of the proposed algorithm, any connected undirected input graph will be broken into any one of the scenarios discussed above. Since due to the selection process adopted in Phase 1 will never result in formation of a circuit, hence the initial claim made has been proven false. □

From the above discussion, we can now infer that the following need to be satisfied to guarantee tree formation in Phase 1.

•
The key combination should consist of combinations of one less than |Max(EType-X)| number of edges from Type-X, |Min(EType-Y)| number of edges from Type-Y, and no edge from Type-Z component or a single edge from Type-Z component which is a bridge.

While considering the stipulated number of edges from a Type-X, Type-Y or Type-Z component, care is taken such that all the exclusive vertices of that component get traversed.

5.4.3. Phase 2: generation of spanning trees
In this phase, we generate different combinational values of edges (number of edges to be combined), for each of the components (defined in the component table) in such a way so that the total number of edges selected from all the components is  (since the graph is n-ordered). The combinations will be treated as valid if they adhere to the minimum and the maximum number of edges that a component can provide. Note that the total number of selected edges being  is also a necessary condition towards attaining validity. Moreover, key combination (generated in Phase 1) must not be considered in Phase 2 tree generation; otherwise, duplication arises. Unlike Phase 1, in Phase 2, where combinations of edges from different components have been taken, possibilities are there that some non-trees could be generated. Non-trees are the sequences of edges other than trees, or, disjoint components formed while computing a tree, which certainly contains at least one cycle (or circuit) and more than one component. In order to discard non-trees, we do apply DFS on each and every edge-sequence generated in Phase 2 for the detection and elimination of those subgraphs containing circuits. Let us mention in this regard that for a disconnected graph with a cycle, DFS results into more than one component.

An important observation in this regard would be that most of the circuits formed in this phase are because of the Type-Z component(s) for given graph G (the discovery of any relationship between the number of generated circuits and any other input graph properties are left, as future research scope). This is because the endpoints of a Type-Z edge cannot be exclusive to any Type-Z component, or in other words, Type-Z components never contribute solely towards maintaining connectivity of any single vertex in the subgraph (formed by joining different combinations of edges from different components). Thus, the endpoints of any Type-Z edge are also shared by either Type-X or Type-Y component or both. Hence, if Type-X and Type-Y components are mainly responsible for covering or traversing each vertex in the given graph, then there is a high possibility that the inclusion of Type-Z edge may introduce a circuit. In this regard, we can conclude the following.

(i)
If more Type-X components (i.e., more circuits) can be formed, a smaller number of unvisited vertices remains. As a result, a smaller number of Type-Y components is formed. Hence, more number of unvisited edges may remain, with their already visited vertices, i.e., more number of Type-Z components may be formed. Thus, more and more circuits or non-tree sequences are probable to get generated.

(ii)
If less Type-X components (or circuits) are formed, more number of unvisited vertices may be there. Hence, more Type-Y components are formed. This results in a smaller number of unvisited edges, thus, a smaller number of Type-Z components. Hence, a lesser number of circuits or non-tree sequences are likely to be generated.

In Phase 2, the edge selection process is governed by few important aspects:

a)
The Phase 2 doesn't include the pendant vertices and their incident edges present in original input graph because those have already been eliminated before Phase 1 of the proposed method.

b)
The edge combinations are formed by selecting edges from individual components (Type-X, Type-Y and Type-Z) only, instead of selecting edges randomly from the given input graph.

c)
Furthermore, the number of edges which get selected from each component is governed by the maximum and minimum number of edge criteria defined as part of the component table definition.

The adoption of above governing rules ensures the approach is different compared to a brute-force method where distinct () edges will be selected blindly from a given input graph with n vertices and then perform tree testing on individual () edge combinations.

The optimization achieved by the above governing rules is significant compared to the standard brute-force method, which has also been highlighted in Table 5, where the comparison between Char's algorithm (which can be considered as the brute-force method of generating all possible spanning trees of a given connected undirected graph) and the proposed algorithm (ASTG-by-DCC) has been evaluated. There we find that the number of circuits generated for each of the input graph instances is significantly higher in case of Char's algorithm compared to ASTG-by-DCC. This is primarily due to the influence of Phase 1 of the proposed method. Thus ASTG-by-DCC achieves significant savings during run-time by reducing circuit testing compared to brute-force method.

5.5. Rejoining pendant edges
In Sections 5.2 through 5.4, we obtained the trees of the graph without pendant edges. Now to get the trees of the original graph, , we need to merge the pendant edges that have been removed and stored in set ES (in Section 5.1), with the trees obtained in the previous sections so that the remaining vertices get connected with the rest of the vertices. Hence, the trees of  are essentially all trees of G joined with all removed pendant edges stored in ES, as because .

Theorem 3

Before termination of algorithm ASTG-by-DCC, it generates all possible spanning trees without any duplication.

Proof

Let us first claim that ASTG-by-DCC does not guarantee to generate all possible spanning trees of . By analyzing the steps of the proposed approach, we will prove that the claim is false.

Now it is clear that if ASTG-by-DCC generates all possible edge combinations of size (), then applying tree testing algorithm (e.g. DFS, BFS) on each such combination and finally removing duplicate trees as well as circuits (or non-trees) will result in the generation of all possible spanning trees of . Since the proposed algorithm does not consider all possible edge combinations of size () for tree testing, the doubt arises whether the algorithm will generate all possible spanning trees for any input graph  or not.

The proposed algorithm starts by removing pendant edges (Section 5.1) from the input graph  to form G, but at the end (Section 5.5) it combines the pendant edges to the intermediate results computed so far to ensure none of the pendant edges (and the corresponding vertices) remains unconsidered during tree generation. Therefore, we can conclude that the proposed method takes special care of pendant edges and eliminates any possibility for those edges to become unconsidered.

The ‘Divide’ phase (Section 5.2) works upon graph G, which results from  by excluding its pendant edges and the corresponding vertices. The primary objective of this phase is to divide G into a set of fundamental circuits. From this proof point of view, the most noticeable fact of the ‘Divide’ phase is, it does not eliminate any edge of G from further consideration.

The ‘Conquer’ phase (Section 5.3) first attempts to group fundamental circuits identified in the ‘Divide’ phase, based on edge and vertex adjacency among various circuits. Then the proposed algorithm nominates one circuit arbitrarily with highest edge adjacency and designates that as a ‘Pivotal’ circuit. In case of the vertex-disjoint circuits, any one of the circuits may be treated as a ‘Pivotal’ circuit. Post this step, the algorithm forms three different components, namely, Type-X, Type-Y, and Type-Z based on the criteria which ensures none of the vertices or edges of G is left unconsidered. The most noticeable fact of the ‘Conquer’ phase is, irrespective of the number of Type-X (|Type-X| ≥ 1), Type-Y (|Type-Y| ≥ 0) and Type-Z (|Type-Z| ≥ 0) components created in this phase, it does include all the components (vertices and edges) of G.

The ‘Combine’ phase has been primarily divided into two phases. In Phase 1 (Section 5.4.2), the algorithm smartly selects few of the edge combinations  and creates a set of spanning trees which later gets combined with the set of spanning trees generated in Phase 2.

In Phase 2 (Section 5.4.3), the algorithm generates all possible edge combinations S considering all the three types of components, of size  each, where  is the total number of vertices in graph G. Then the algorithm excludes edge combinations generated in Phase 1 and results in a set of edge combinations . Afterwards, the algorithm applies DFS to perform tree testing on the set  to report the rest of the spanning trees for G.

Now essentially, Phase 1 of ‘Combine’ step of the proposed algorithm is the place where few of the potential spanning trees might get missed due to the proposed ‘smart’ selection process. Phase 2, anyway, generates all possible spanning trees and excludes the ones generated in Phase 1 for tree testing. Therefore, let us evaluate the validity of the selection process to check whether there is any gap in the ‘smart’ selection process adopted in Phase 1.

In Phase 1, the algorithm considers only the Type-X and Type-Y components and does not include the edges present in the non-bridge Type-Z component. However, that should not be an issue since all the edges present in Type-Z component gets considered anyways in Phase 2.

As per the selection process, the edge combinations which do not include all the exclusive vertices of either Type-X or Type-Y component have been discarded. Now, will that create an issue of missing some of the legitimate spanning trees? The answer is clearly no, because, in Phase 2, those discarded edges will get considered anyways. Moreover, selecting edge combinations which traverse all the exclusive vertices of each component allows immediate reporting of the spanning trees without the need of any further tree testing for those edge combinations. Therefore, in the ‘Combine’ phase, the combination of Phase 1 and Phase 2 always results in the desired set of spanning trees of G. Finally, to obtain all the spanning trees of , the algorithm appends all initially removed pendant edges and reports altogether the desired spanning trees of the initial graph .

In last few paragraphs, we tried to analyze each and every individual step of the proposed algorithm to determine whether, any of the proposed steps will result in discarding any edge or edge combinations which may eliminate any of the legitimate spanning trees from reporting, but we found otherwise and hence the initial claim made is false. □

5.6. Few observations
In this section, we will be discussing more on the selection of Type-X, Type-Y, and Type-Z components and how it affects the final tree generation process.

Let us first explain the motivation and logic behind the selection of pivotal circuit, which we talked about earlier in Section 5.3. Selecting circuits with the highest edge-adjacency produces more left-over vertices, and hence more Type-Y components, which gives rise to a smaller number of Type-Z components. On the other hand, selecting circuits with less edge-adjacency produces more VACs, thus less left-over vertices; hence, a smaller number of Type-Y components, which may give rise to more Type-Z components.

We see that the first phase of tree generation produces no circuit, whereas Phase 2 may produce some. Now, Phase 1 does not include any non-bridge Type-Z component as done by the second phase. Consequently, it is evident that most of the non-trees (or circuits) generated in Phase 2 are due to the presence of edges from Type-Z component(s). It is worth mentioning that, even in the absence of Type-Z component(s), non-trees can be generated in this phase. However, indeed in the presence of Type-Z component(s) the number of non-trees increases.

Since we always want a smaller number of circuits to be generated in our algorithm, it is desirable if there are less Type-Z components, and hence, the circuit with highest edge-adjacency is selected as the pivotal circuit or the first Type-X component.

Corollary 4

If  does not contain any Type-X component, then it is a tree, and the only tree we like to compute.

Let us also mention in this regard that, the selection of the initial DFS tree, as well as the vertex from which DFS is initiated, plays a major role in the formation of the components. Different fundamental circuits get formed from different DFS trees which result in different sets of Type-X, Type-Y, and Type-Z components; however, all the trees will eventually be generated along with a few different non-tree sequences.

There is another important observation regarding the bridge edges (if present) that needs to be discussed here. If bridge edges are present in the input graph, then they can be removed in the very first step and then rejoined once again at the end, just like the pendant edges, since every tree includes these edges. After removal of bridge edges, every component of  is 2-connected (a graph having more than two vertices that remains connected on removal of any of its vertices). Then, the algorithm can be run separately for each of the components. Hence, the Type-Z edges need not be considered in Phase 1 anymore. As a result, the description may get simpler and the efficiency of the algorithm may get increased further. More graph instances with bridge edges need to be considered during the implementation to draw an inference about the efficiency of the above-stated method. This is indeed one of the future scopes of the algorithm which is left for exploration of the future researchers in this domain.

6. Example
Let us consider the given graph  (in Fig. 6(a)) with a pendant edge  due to the pendant vertex . After its removal, there is another resultant pendant edge  due to  (now). Further removing  results into the graph G, shown in Fig. 6(b), with no more pendant edges.

Fig. 6
Download : Download high-res image (33KB)
Download : Download full-size image
Fig. 6. (a) A graph Gp with pendant edges, and (b) Resultant graph G after removal of pendant edges from Gp (of Fig. 6(a)).

For the graph G in Fig. 6(b), we start with any DFS tree  initiated from the start-vertex , on the basis of which the fundamental circuits are found out in Fig. 7. The circuits formed are  ,  , and  .

Fig. 7
Download : Download high-res image (83KB)
Download : Download full-size image
Fig. 7. Decomposition of G (of Fig. 6(b)) into fundamental circuits.

Now we scan them in order to find whether there is only a vertex or at least an edge common among them. We find that all three circuits , , and  (as in Fig. 7) are edge-adjacent to each other. In Table 2, we show the list of all circuits (of Fig. 6(b)) with their VACs and EACs for graph G and the assumed DFS tree as mentioned above, where we find all the three circuits are having the same number of EACs, and no VAC. Hence, any one, say , is chosen as the pivotal circuit and therefore, marked as Type-X component (). Since there is no VAC of , no more Type-X component is there for the example graph G.


Table 2. EAC and VAC List for graph G in Fig. 6(b).

EAC	VAC
C1: C2, C3	C1: none
C2: C1, C3	C2: none
C3: C1, C2	C3: none
As  is the only Type-X component, the vertex  does not get visited and hence forms Type-Y component () along with the edges incident on it, namely  and . As a result, all the edges of G except  have been included as Type-X or Type-Y edges. Hence  forms the only non-bridge Type-Z component () for G. Now we compute the component table, Table 3, for the example graph G (in Fig. 6(b)), with the help of which trees are generated in two phases.


Table 3. Component table for graph G in Fig. 6(b).

Components	Component Type	Total # of edges	# of exclusive vertices	Exclusive vertices	Minimum # of edges	Maximum # of edges	Key value
P1	Type-X	4	1	v4	1	3	3
P2	Type-Y	2	1	v1	1	2	1
P3	Type-Z	1	0	-	0	1	0
For the example graph G (in Fig. 6(b)), the key values for , , and  are 3, 1, and 0, respectively. Thus, the edge combinations for  are , , , and  and for  either  or  gets included. Now the above edge combinations for , , and  are combined together to form trees of Phase 1. Hence, the trees generated in this phase are , , , , , , , and .

Let us now find out the sequences generated in Phase 2 for the example graph G (in Fig. 6(b)). The different combinations, in  format, where x, y, and z being the number of edges taken from the three components , , and , respectively, are being generated such that the sum total of the number of edges taken from them is exactly , for an n-ordered graph. Incidentally, some of them are not valid, that is they are not the structures that we desire to compute. The validity is maintained keeping their maximum and minimum number of edges as a constraint, as mentioned before. Different such valid combinations (other than the key combinations used in Phase 1), generated from the component table, Table 3, are , , and .

(a)
Edge sequences generated from :  
 
 , , ,  
 
 ,  
 
 , .

(b)
Edge sequences generated from :  
 
 ,  
 
 , , ,  
 
 ,  
 
 , , , , , , .

(c)
Edge sequences generated from : , .

The edge sequences thus generated consist of both tree and non-tree sequences. Applying DFS, we detect the tree sequences and discard the non-tree sequences (the underlined sequences as shown above).

Finally, we merge back the pendant edges  and  with the Phase 1 and Phase 2 trees of graph G (in Fig. 6(b)), to get the spanning trees of  (in Fig. 6(a)). Hence, the trees of  are essentially all trees of G including  and .

In the example graph of Fig. 7, we have already seen that Type-Z component(s) can never have a vertex exclusive to itself, as the endpoints of a Type-Z component are always shared by one/more Type-X and/or Type-Y component(s) or both. On the other hand, Type-Y component(s) are formed only when certain vertices remain unvisited after the formation of Type-X component(s). Hence, Type-Y components may contain one or more exclusive vertices as well as one or more shared vertices. Interestingly, Type-X components are such that they may or may not have one or more exclusive vertices included. In the example graph of Fig. 7, Type-X component had only one exclusive vertex, namely .

Let us consider the graph given in Fig. 8. Here, if the circuit  forms a Type-X component, then it is interesting to note that  is no longer an exclusive vertex of the Type-X component as it is shared by another Type-Z component, namely . Thus, there is no exclusive vertex for the Type-X component in the graph of Fig. 8.

Fig. 8
Download : Download high-res image (19KB)
Download : Download full-size image
Fig. 8. A graph with a Type-X component having no exclusive vertex.

Corollary 5

A Type-Y component (if present) always has one or more exclusive vertices, a Type-Z component (if present) never has an exclusive vertex, whereas a Type-X component may or may not have one or more exclusive vertex/vertices.

7. Data structures and complexity issues
An adjacency list is used to store the given graph, whose storage requirement is , where n is the number of vertices (or the order of the graph) and m is the number of edges (or the size). Hence, the space complexity of our algorithm is . Removal of pendant edges may at most take  time. Since the number of branches in a spanning tree of an n-ordered graph is , thus, the number of fundamental cycles in the graph becomes . Hence, detection of circuits takes  time. Computation of EAC list and VAC list, selection of pivotal circuit can be done in  time. Searching for Type-X components require a search through the vertex-adjacent/vertex-disjoint circuits which once again can consume  time. On the other hand, Type-Y component searches for exclusive vertices and can take  time in the worst case. Forming Type-Z component(s) also need at most  time.

Let us represent the average size (in terms of the number of edges) of a Type-X component as , Type-Y component as , and Type-Z component as . The average minimum and maximum number of edges from a Type-X, Type-Y, and Type-Z component that can be considered are represented as , , , , , and , respectively. Moreover, let X, Y, and Z be the number of Type-X, Type-Y, and Type-Z components formed from the given graph, where , , and . It can be mentioned in this context that, the relationship between X, Y, Z for any given graph is considered as a future scope of the research. Therefore, the average complexity of Phase 1 tree generation is , where , , and . Similarly, the average complexity of Phase 2 tree generation is ⁎, where , , , and . The  multiplier has been introduced for the tree checking step using DFS. The complexity of Phase 2 obviously dominates over the complexity of Phase 1 tree generation. Hence, we may conclude this section by mentioning the computational complexity of the algorithm devised in this paper with the following theorem.

Theorem 4

Algorithm ASTG-by-DCC computes all spanning trees of a simple, undirected, and connected graph, and it takes ⁎ time, where , , , and ; X, Y, and Z being the number of Type-X, Type-Y, and Type-Z components formed from the given graph, respectively; , , and  being the average size of a Type-X, a Type-Y, and a Type-Z component, respectively, and n and m being the order and size of the given graph.

8. Experimental results
The newly devised algorithm ASTG-by-DCC has been extensively benchmarked against five sequentially implemented algorithms (Char [2], Hakimi [12], Matsui [15], Mayeda and Seshu [17], Shioura and Tamura [18]) and one algorithm (Winter [22]), implemented in parallel, in this problem domain on an Intel Core i3 quad-core processor running at 2.4 GHz clock speed, with 6 GB RAM capacity. The implementation has been carried out on random graph instances whose order ranges from 10 to 40. The intent of this exercise was primarily twofold:

•
To demonstrate how the proposed algorithm stands in terms of CPU time taken by other sequential algorithms, most of which have never been implemented before and the ones which have been implemented used graphs of lower magnitude compared to the magnitude of the graphs used in this research work.

∘
The outcome is quite impressive since the CPU time taken by the newly proposed algorithm is not only comparable with the existing algorithms, but in certain cases, it is faster compared to the others.

•
Intentionally, we have implemented one algorithm (Winter's) in parallel, in this benchmarking exercise, to demonstrate where the sequential algorithms (combination of both existing and the proposed one) stand in terms of running time compared to the algorithms, parallel in nature, proposed so far, to solve the same problem. Of course, we knew that the algorithm implemented in parallel would be faster compared to any of the sequentially implemented algorithms investigated, but our intent was to obtain a result which clearly depicts the order of magnitude by which the algorithm implemented in parallel is faster compared to the sequentially implemented ones because previously, no such benchmarking has been done.

Table 4 shows the behaviour of the algorithms with respect to CPU time for the same set of instances. Here, we have assumed that  is the i-th instance of a graph with x number of vertices and y number of edges. The CPU time thus taken by all the algorithms are shown in a dd-hh-mm-ss format, where dd, hh, mm, and ss stand for the number of days, hours, minutes, and seconds, respectively. It is also apparent from Table 4 that all the standard algorithms as well as our algorithm, ASTG-by-DCC, generate the same number of trees for all the graph instances considered, which undoubtedly and eventually proves that all the referenced existing algorithms are right, and also have been implemented correctly.


Table 4. Experimental results of computing all (valid) spanning trees for randomly generated graph instances, where the order of the graph varies from 10 to 40.

Instances with Vertex# and Edge#	Number of trees generated	Shioura and Tamura [18]	Matsui [15]	Mayeda and Seshu [17]	Hakimi [12]	Char [2]	Winter [22]	Algorithm ASTG-by-DCC
(dd-hh-mm-ss)	(dd-hh-mm-ss)	(dd-hh-mm-ss)	(dd-hh-mm-ss)	(dd-hh-mm-ss)	(dd-hh-mm-ss)	(dd-hh-mm-ss)
 (10, 14)	364	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00
 (10, 15)	636	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00
 (10, 18)	6210	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-01	00-00-00-00	00-00-00-00
 (15, 21)	1320	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00
 (15, 21)	2858	00-00-00-00	00-00-00-00	00-00-00-01	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00
 (15, 23)	6054	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-00	00-00-00-01	00-00-00-00	00-00-00-00
 (19, 37)	104757368	00-00-56-02	00-00-11-51	00-02-04-16	00-00-53-23	00-00-36-52	00-00-03-39	00-00-47-00
 (20, 28)	32854	00-00-00-03	00-00-00-01	00-00-00-05	00-00-00-01	00-00-00-05	00-00-00-00	00-00-00-03
 (20, 31)	248120	00-00-00-17	00-00-00-03	00-00-00-33	00-00-00-10	00-00-05-43	00-00-00-02	00-00-00-11
 (20, 35)	13100220	00-00-09-35	00-00-02-20	00-00-25-30	00-00-08-24	00-00-09-41	00-00-00-38	00-00-05-54
 (22, 32)	616642	00-00-01-17	00-00-00-13	00-00-02-28	00-00-01-14	00-00-12-04	00-00-00-07	00-00-00-18
 (25, 37)	6073612	00-00-16-12	00-00-03-41	00-00-27-47	00-00-13-54	00-01-58-51	00-00-00-45	00-00-09-31
 (25, 38)	2373413	00-00-05-11	00-00-01-26	00-00-15-22	00-00-03-57	00-00-46-27	00-00-00-15	00-00-01-05
 (25, 38)	11289965	00-00-25-39	00-00-06-53	00-01-02-30	00-00-19-46	00-03-04-28	00-00-01-11	00-00-05-11
 (28, 41)	5490987	00-00-16-53	00-00-03-50	00-00-38-50	00-00-15-44	00-02-20-47	00-00-00-47	00-00-11-03
 (30, 43)	18992781	00-01-21-59	00-00-17-09	00-02-32-51	00-00-46-56	00-06-11-39	00-00-01-50	00-01-34-01
 (30, 45)	21110724	00-01-53-56	00-00-23-41	00-02-43-58	00-01-01-21	00-06-53-06	00-00-01-22	00-01-45-53
 (30, 46)	196120504	00-14-16-26	00-03-40-11	00-21-37-21	00-09-04-37	02-15-57-42	00-00-11-40	00-14-25-40
 (35, 48)	11412698	00-00-47-29	00-00-10-05	00-02-52-51	00-00-32-21	00-03-43-20	00-00-01-17	00-00-46-49
 (35, 49)	183870707	01-20-26-22	00-00-24-37	00-19-04-48	00-11-58-19	02-11-58-03	00-00-02-45	00-16-45-08
 (35, 52)	1338241348	05-11-37-04	01-03-23-35	12-00-56-56	03-17-11-18	18-04-27-21	00-01-12-45	05-15-44-37
 (40, 55)	1738456174	09-07-55-18	02-19-45-46	14-06-05-22	05-17-35-01	24-15-58-44	00-02-54-28	09-17-43-51
 (40, 56)	336855096	01-18-39-49	00-12-56-11	02-18-17-08	00-22-12-09	04-13-51-42	00-00-33-25	02-15-06-57
 (40, 58)	2845424302	28-08-51-59	05-19-04-03	30-06-34-57	02-06-11-17	38-16-00-16	00-04-42-17	22-05-08-29
Some important observations that can be drawn from Table 4 are as follows.

(a)
The order of the graph instances varies from 10 to 40, whereas density (number of edges present / number of maximum edges possible in a graph) ranges from 10 to 40 percent only.

(b)
Some of the graph instances take days to execute and also generate billions of trees.

(c)
Time taken to execute an instance by an algorithm depends on factors like order and size of instances, as well as number of spanning trees generated.

(d)
The number of spanning trees generated also depends on how edges are distributed / concentrated / clustered (among a subset of vertices) over the graph. In some other words, the degree variation of the vertices talks about how the edges of the graph are connecting the vertices. If the edges are evenly distributed among the vertices, the possibility of computing number of trees is relatively low.

(e)
The best results in terms of CPU time have been obtained by Winter's algorithm [22] (which is parallel in nature). Winter's algorithm examines only those sequences for which at least one spanning tree exists, reducing the time required for circuit checking. Moreover, unlike many other algorithms which examine one sequence at a time, Winter's algorithm examines several different sequences simultaneously. As we have pointed out earlier, the inherent parallelism of Winter's algorithm is the major cause behind the reduction in time to execute it.

Among all the algorithms listed above, the algorithm by Char [2], as well as algorithm ASTG-by-DCC has incorporated some circuit testing. A comparative study of these two algorithms (for all the instances of Table 4) depicting the number of non-tree sequences (or circuits) being generated is listed in Table 5.


Table 5. Comparative study of circuits generated by Char and Algorithm ASTG-by-DCC.

Instances with # of vertices and # of edges	Number of trees generated	Number of circuits generated by	(ASTG-by-DCC/Char) × 100 (in %)
Char [2]	ASTG-by-DCC
 (10, 14)	364	5396	1015	18.81
 (10, 15)	636	13764	1788	12.99
 (10, 18)	6210	51390	17843	34.72
 (15, 21)	1320	309720	3735	1.21
 (15, 21)	2858	384214	8118	2.11
 (15, 23)	6054	1030746	17313	1.68
 (19, 37)	104757368	7698614152	346746878	4.5
 (20, 28)	32854	6042146	94949	1.57
 (20, 31)	248120	552711880	722028	0.13
 (20, 35)	13100220	2375686980	42313721	1.78
 (22, 32)	616642	1146001214	1800596	0.16
 (25, 37)	6073612	61146878708	18038618	0.03
 (25, 38)	2373413	12439226587	6977833	0.06
 (25, 38)	11289965	141076454035	34773102	0.02
 (28, 41)	5490987	13431437013	16198413	0.12
 (30, 43)	18992781	671827407219	61726528	0.01
 (30, 45)	21110724	752446857276	69454292	0.01
 (30, 46)	196120504	1238434279000	657003688	0.05
 (35, 48)	11412698	4551955307000	36406497	0.0007
 (35, 49)	183870707	22754447480000	612289464	0.003
 (35, 52)	1338241348	80261911680000	4590167834	0.006
 (40, 55)	1738456174	6687073598000000	6032442914	0.000001
 (40, 56)	336855096	948109302800000	1141938765	0.0001
 (40, 58)	2845424302	4514804963000000	9958985067	0.0002
Table 5 captures the difference in the number of circuits generated by Char's algorithm compared to the algorithm ASTG-by-DCC. In this regard, we would like to mention the following:

1.
The total number of edge sequences generated by Char's algorithm is the sum total of the number of trees and the number of circuits (as shown in the two consecutive columns in Table 5). Each and every such sequence has to undergo a circuit checking procedure. On the other hand, as mentioned earlier, algorithm ASTG-by-DCC has two phases of operation, Phase 1 and Phase 2. Phase 1 deterministically computes only trees; thus, no circuit checking is required. Circuit checking is only involved in Phase 2 (which deterministically computes both trees and non-trees), which generates only a subset of the total number of possible sequences as tested by Char. Hence, we find that the amount of redundant computation (computation involved in testing each and every sequence) is more for Char's algorithm.

2.
It is also evident from the last column of Table 5 that the number of circuits formed by algorithm ASTG-by-DCC is only a very small percentage of the circuits formed by that of Char's algorithm. Some of the possible reasons behind this behaviour have been analysed as follows.

a.
If we go back to Section 5 in this paper, we find that the number of edges taken from each type (Type-X, Type-Y, and Type-Z) is guided by some rules, which definitely reduces the redundant checking as that of Char, where no such guideline is there. In a bit more detail, we mention that a large number of trees are generated in Phase 1 for none of which circuit checking is necessary. As we have observed that only an edge in Type-Z is mostly responsible in introducing a cycle, so our algorithm performs (or executes) the step of circuit checking only for the generated sub-graphs in Phase 2. Some of the rules have already been discussed; further improvements in this regard are also encouraged from future researchers such that few more guidelines/rules may be introduced in checking a smaller number of generated subgraphs, for cycle testing.

b.
We have observed that the devised algorithm ASTG-by-DCC has defined only three types of components (Type-X, Type-Y, and Type-Z), each having its inherent specialities and limitations. If there have been more than three such types and the boundaries would have been more precise and guided, then there might have been a possibility of a smaller number of circuits being generated. Exploring this remains another open problem for future researchers.

3.
A close observation of Table 5 also reveals that as the size of the graph instances increases, total number of sequences generated by Char [2] also increases; whereas performance of algorithm ASTG-by-DCC exceeds that of Char in the sense that it produces much lesser (almost negligible) percentage of circuits than that computed by Char's algorithm. The number of circuits generated by the algorithm of Char [2] and the algorithm developed in this paper have been plotted against the number of trees generated for the same set of graph instances in Fig. 9. This figure clearly indicates the random behaviour of Char's algorithm and interestingly the almost linear computational behaviour (in the log-log scale) of our algorithm.

Fig. 9
Download : Download high-res image (102KB)
Download : Download full-size image
Fig. 9. Graphical representation of the number of circuits formed by the algorithm of Char [2] and algorithm ASTG-by-DCC against the number of trees generated for a variety of differently sized graph instances.

Here, we like to highlight a few additional points regarding the implementation of all spanning tree generation algorithms.

•
Among all the 25 works that have been studied as part of our survey, 15 of them have not been implemented before.

•
Among the ones that have been implemented, Naskar et al. [5] have taken the maximum order of graphs, which is 33.

•
Among the ones that have been implemented here in this paper, only Winter [22] has done his implementation with a graph of order 14. We have implemented them with graphs of maximum order 40.

•
Due to the computational limitation of our machine, we restricted ourselves with graphs of order 40. Future researchers are encouraged to work with graphs of higher dimensions to explore more interesting behaviours of the algorithms.

•
The graph instances generated are arbitrary (without any biases) or random. For any other instance, Char's data may get some new shape (other than that shown in Fig. 9).

•
The computation's variation of our algorithm is much less, in the log-log scale (see Fig. 9) because of a lesser number of circuits generated by the proposed algorithm than that of Char.

•
50 different instances of graphs for the same pair of V and E values with different mappings can be checked to investigate whether our algorithm gives similar linear behaviour and also find out how Char's algorithm behaves. It is undoubtedly a question of large-scale experimentation and is kept for future research.

Let us also mention in this regard that one of the earlier algorithms by Kapoor and Ramesh [13] has also used the concept of fundamental circuits like our present algorithm. As already mentioned, the fundamental circuits help us to initiate the division process (to divide the graph into components) associated with our algorithm. On the other hand, the fundamental circuits in the algorithm by Kapoor and Ramesh [13] are used for the purpose of generating one tree from the other, by exchanging the edges of each fundamental circuit (keeping the vertices encompassed being connected with each other). In other words, Kapoor's algorithm follows the elementary tree transformation technique, described earlier in Section 3.

As mentioned earlier, each of the fundamental circuits of a graph contains a chord (not an edge of initial DFS tree) and two or more branches (edges of initial DFS tree). To form circuit-free trees, each of these branches can be replaced by a set of chords, one at a time, for the corresponding fundamental circuit. This concept has been utilized for tree generation by Kapoor and Ramesh [13]. On the other hand, the present algorithm, ASTG-by-DCC, has selected fundamental circuit as just a standard unit for the division phase. Some other standards could have been chosen, which would have resulted in changes in the conquer and combine stages as well. Moreover, in ASTG-by-DCC, for a given graph, we may start from any vertex as the initial vertex; accordingly, Type-X, Type-Y, and Type-Z component sets may vary, however, all the trees will eventually be generated. Similarly, Kapoor's algorithm can start with any initial DFS tree; the trees generated at each level may differ based on that selection, but eventually, all trees are guaranteed to be generated.

9. Conclusion
In this paper, a divide-and-conquer based new algorithm, ASTG-by-DCC, has been developed for computing all possible spanning trees of a simple, undirected and connected graph. The algorithm divides the given graph into a number of components, where the components have been categorized into three distinct groups. The first group of components contains only circuits, the second group comprises exclusive vertices along with their adjacent edges (not belonging to earlier circuits), whereas the third group consists of the remaining edges that are not included in earlier two groups. These components are made one after another after removing the pendant edges, if any, of the given graph.

The algorithm is successful in generating all spanning trees of a given graph in two phases. Phase 1 guarantees that there is no non-tree generation. Phase 2, however, generates some non-tree sequences, which can be discarded using a DFS circuit checking algorithm. As an open problem, future researchers may consider improving the performance of Phase 2 by introducing some innovative approach. Some other procedure, if followed during the Divide phase (that is how we are defining the Type-X, Type-Y, and Type-Z components) may result in further improvement of Phase 2 tree generation. As a result, the performance of the entire algorithm may get better in comparison to many other algorithms in this domain. This is, indeed, an area to be further explored. Another important achievement that may enhance the efficiency of the present algorithm and needs to be mentioned here is the removal of bridges (if present) from the input graph at the beginning and rejoining them at the end, just like pendant edges. This is because the pendant edges are all essentially bridges; here the connected components (excluding the bridges) need to be assumed in separation for their execution.

The algorithm ASTG-by-DCC has also been implemented along with some other standard algorithms (both sequential as well as parallel in nature) in the domain of computing all spanning trees of a graph on the basis of CPU time taken. All these articles are well-established in computing all spanning trees. These algorithms can also be compared in terms of their theoretical complexities, which have been explicitly mentioned only by some authors. In any case, novelties and weaknesses of the algorithms have been compared experimentally. The implementations have been carried out in a common environment and with a common set of randomly generated graph instances. Circuit generation in ASTG-by-DCC has also been compared exhaustively with that of Char's algorithm. The performance of Char's algorithm and that of ASTG-by-DCC has also been compared, which once again can be a domain of further research with further experimentation for a larger number of graph instances with identical  and . Not only that, various other combinations of higher values of  and  can be explored in future to judge further the performance and efficiency of the algorithm.