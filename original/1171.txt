Abstract
The problem of timeline-based planning (TP) over dense temporal domains is known to be undecidable in the general case. We first prove that the restriction to the future semantics does not suffice to recover decidability. Then, we introduce two semantic variants of TP, called strong minimal and weak minimal semantics, and show that they allow one to express meaningful properties. Both semantics are based on the minimality in the time distances of the existentially-quantified time events from the universally-quantified reference one, but the weak minimal variant distinguishes minimality in the past from minimality in the future. Surprisingly, we show that, despite the (apparently) small differences between the two semantics, the TP problem is still undecidable for the strong minimal one, while it is PSPACE-complete for the weak minimal one. Membership in PSPACE is determined by exploiting a strictly more expressive extension (ECA+) of the well-known robust class of Event-Clock Automata (ECA), that allows us to encode the weak minimal TP problem and to reduce it to non-emptiness of Timed Automata (TA). Finally, an extension of ECA+(ECA++) is considered, proving that its non-emptiness problem is undecidable. We believe that the two extensions of ECA (ECA+ and ECA++), introduced for technical reasons, are actually valuable per sé in the field of TA.1

Keywords
Timeline-based planning
Dense time
Complexity
Timed automata
Event-clock automata

1. Introduction
Timeline-based planning. Timelines provide an approach to planning alternative to the classic action-based one [3], [4]. In the action-based approach of classical planning, the task of the planner is to find a sequence of actions that, applied from an initial state, allow an actor to achieve a given goal. Timeline-based planning (TP), instead, originates from the integration of planning and scheduling concepts in the context of space operations. Unlike action-based planning, timeline-based one does not explicitly distinguish among states, actions, and goals. It models the domain as a set of independent, but interacting, components, whose behavior over time (the timelines) is ruled by a set of temporal constraints, called synchronization rules. In such a framework, a solution plan is a set of timelines expressing a behavior of the system components that satisfies all the rules. Compared to classical action-based temporal planning, TP adopts a more declarative paradigm which focuses on the constraints that sequences of actions have to fulfil to reach a given goal. The declarative flavor allows knowledge engineers to focus on what has or has not to happen, instead of on what the agent has to do to achieve a goal. Moreover, the modular structure makes it possible to separately model distinct system components. Over the years, TP has been successfully applied in many complex tasks, ranging from long- to short-term mission planning to on-board autonomy [5], [6], [7], [8], [9], [10].

In TP, the planning domain is modeled as a set of independent, but interacting, components, each one modeled by a state variable. The temporal behavior of a single state variable (component) is described by a sequence of tokens (timeline), where each token specifies a value of the variable (state) and the period of time during which it takes that value. The overall temporal behavior (set of timelines) is constrained by a set of synchronization rules that specify quantitative temporal requirements between the time events (start-time and end-time) of distinct tokens. Synchronization rules have a very simple format: either trigger rules, expressing invariants and response properties (for each token in a given state, called trigger, there exist some other tokens satisfying some mutual temporal relations), or trigger-less ones, expressing goals (there exist some tokens satisfying some mutual temporal relations). Notice that the way in which requirements are specified by synchronization rules corresponds to the “freeze” mechanism in the well-known timed temporal logic  [11], which uses the freeze quantifier to bind a variable to a specific temporal context (a token in the TP setting).

TP has been successfully exploited in a number of application domains, including space missions, constraint solving, and activity scheduling (see, e.g., [12], [13], [14], [15], [16], [17]). A systematic study of expressiveness and complexity of TP has been undertaken only very recently in both the discrete-time and the dense-time settings [18], [19], [20], [21], [22].

In the discrete-time case, the TP problem turns out to be EXPSPACE-complete, and expressive enough to capture action-based temporal planning (see [21], [22]).

In this paper we will consider TP over a dense temporal domain, without having recourse to any form of discretization, which is quite a common trick. A reason for assuming this different version of time domain is, basically, to increase expressiveness: in this way one can abstract from unnecessary (or even “forced”) details, often artificially added due to the necessity of discretizing time, and can suitably represent actions with duration, accomplishments and temporally extended goals. However, despite the simple format of synchronization rules, the shift to a dense-time domain dramatically increases expressiveness and complexity, depicting a scenario which resembles that of the well-known timed linear temporal logics MTL and TPTL, under a point-wise semantics, which are undecidable in the general setting [11], [23]. Known results about the TP problem over dense time are reported in Table 1. The problem in its full generality is undecidable [20], undecidability being caused by the high expressiveness of trigger rules (if only trigger-less rules are used, it is just NP-complete [24]). Decidability can be recovered by imposing suitable syntactic/semantic restrictions on the trigger rules. In particular, two significant restrictions have been considered [18], [19]: (i) the first one limits the comparison to tokens whose start times follow the start time of the trigger (future semantics of trigger rules); (ii) the second one imposes that a non-trigger token can be referenced at most once in the time constraints of a trigger rule (simple trigger rules). By imposing the above two restrictions, the TP problem becomes decidable with a non-primitive recursive complexity [19] and can be solved by reducing it to model checking of Timed Automata (TA) [25] against MTL specifications over finite timed words, the latter being a known decidable problem [26]. It is worth pointing out that both restrictions effectively contribute to decidability. Indeed, the TP problem is still undecidable when restricted to simple trigger rules [20] and when the future semantics is assumed, but rules are not constrained to be simple. The latter result is illustrated in the next section; a preliminary account of it was given in [1]. As in the case of MTL [27], in the setting of simple trigger rules, better complexity results can be obtained if, in addition, we restrict the type of intervals used to compare tokens in simple trigger rules [18], [19]. In particular, the problem is EXPSPACE-complete when only intervals with a non-null duration are considered (non-singular intervals) and PSPACE-complete for intervals which start at time 0 or are unbounded (the set of these intervals is denoted by 
).


Table 1. TP problem with standard semantics.

TP problem	Future TP problem
Unrestricted	Undecidable	Undecidable
Simple trigger rules	Undecidable	Decidable (non-primitive recursive)
Simple trigger rules,	?	EXPSPACE-complete
non-singular intervals
Simple trigger rules,	?	PSPACE-complete
intervals in Intv(0,∞)
Trigger-less rules	NP-complete	NP-complete
Paper contributions. The first contribution of the paper is the already-mentioned proof of undecidability of the TP problem under the future semantics. Its most relevant contributions are the introduction and systematic investigation of alternative semantics for the trigger rules in the dense-time setting, called minimal semantics. In the standard semantics of trigger rules, if there are many occurrences of non-trigger tokens carrying the same specified value, say v, nothing forces the choice of a specific occurrence for satisfying the given constraints. As an example, suppose that the trigger token represents a prompt for which a v-valued token is required in response. If many v-valued tokens occur in the timeline, the chosen one is not guaranteed to be the first token occurring after issuing the prompt. In a reactive context, one is usually interested in relating an issued prompt to the first response to it and not to an arbitrarily delayed one. In this paper, we define and study semantics requiring that the rule constraints are satisfied by the suitably-valued tokens occurring close to the trigger one. A similar idea is exploited by Event-Clock Automata (ECA) [28], a well-known robust subclass of Timed Automata (TA) [25]. In ECA, each symbol a of the alphabet is associated with a recorder, or past clock, recording (at the current time) the time elapsed since the last occurrence of a, and a predictor, or future clock, measuring the time required for the next occurrence of a.

In more detail, the minimal semantics of trigger rules is based on the minimality in the time distances of the start times of existentially quantified tokens from the start time of the trigger token in a trigger rule. In fact, the minimality constraint can be used to express two alternative semantics: the weak minimal semantics, which distinguishes minimality in the past, with respect to the trigger token, from minimality in the future, and the strong minimal semantics, which considers minimality over all the start times (both in the past and in the future). Surprisingly, this apparently small difference in the definitions of weak and strong minimal semantics leads to a dramatic difference in the complexity-theoretic characterization of the TP problem: while the TP problem under the strong minimal semantics is still undecidable, the TP problem under the weak minimal semantics turns out to be PSPACE-complete (which is the complexity of the emptiness problem for TA and ECA [25], [28]). PSPACE membership of the weak minimal TP problem is shown by a non-trivial exponential-time reduction to non-emptiness of TA. To handle the trigger rules under the weak minimal semantics, we exploit, as an intermediate step in the reduction, a strictly more expressive extension of ECA, called ECA+. This novel extension of ECA is obtained by allowing a larger class of atomic event-clock constraints, namely, diagonal constraints between clocks of the same polarity (past or future) and sum constraints between clocks of opposite polarity. In [29], these atomic constraints are used in event-zones to obtain symbolic forward and backward analysis semi-algorithms for ECA, which are not guaranteed to terminate. We show that, in analogy to ECA, ECA+ are closed under language Boolean operations and can be translated in exponential time into equivalent  with an exponential number of control states, but a linear number of clocks. We also investigate an extension of ECA+, called ECA++, where the polarity requirements in the diagonal and sum constraints are relaxed, and we show that the nonemptiness problem for such a class of automata is undecidable.

To summarize, the proposed weak minimal semantics allows one to solve the TP problem in the dense-time setting with a reasonable computational complexity, without imposing any syntactic restriction to the format of synchronization rules. Moreover, it turns out to be still quite expressive and relevant for practical applications. As a by-product, two original extensions of ECA (ECA+ and ECA++) have been introduced to prove the main complexity results, which are interesting per se, as they shed new light on the landscape of event-clock and timed automata.

Outline. The paper is organized as follows. In Section 2, we recall the TP framework, we proof the undecidability of the TP problem under the future semantics and, then, we introduce the strong and weak minimal semantics. In Section 3, we prove that the TP problem under the strong minimal semantics is still undecidable. Next, in Section 4, we introduce ECA+ and ECA++and study their expressiveness and complexity. Finally, in Section 5, by exploiting the results for ECA+, we prove PSPACE-completeness of the weak minimal TP problem. Conclusions provide an assessment of the work done and outline future research themes.

2. The timeline-based planning problem
In this section, we first recall the standard TP framework, as described in [9], [21], [18], and then we introduce the strong and weak minimal semantics.

2.1. The standard TP problem
In TP, the domain knowledge is encoded by a set of state variables, whose behavior over time is described by transition functions and constrained by synchronization rules. We will adopt the following notation. Let  be the set of natural numbers, 
 be the set of non-negative real numbers, and Intv be the set of intervals in 
 whose endpoints are in . Given a finite word w over some alphabet (or, equivalently, a finite sequence of symbols),  denotes the length of w and for all ,  is the -th letter of w.

Definition 1

A state variable x is a triple 
, where 
 is the finite domain of the variable x, 
 is the value transition function, which maps each 
 to the (possibly empty) set of successor values, and 
 is the constraint function that maps each 
 to an interval.

Example 1

As an example of state variable, we consider the modeling of the temporal behavior of an autonomous elevator which operates between two floors. The elevator can stop either at the first floor or the second floor. When the elevator arrives at a certain floor, its door automatically open. It takes at least 2 seconds from its arrival before the door opens but the door must definitely open within 5 seconds. Whenever the elevator's door is open, passengers can enter. The door can close only 4 seconds after the last passenger entered. After the door closes, the elevator travels up or down to the other floor. It takes at least 4 seconds for moving from a floor to the other floor.

The requested elevator behavior can be described by the state variable 
, where the domain 
 consists of the states 
, 
, 
, 
, 
, 
, up, and . For each , the values 
 and 
 describes the door operations (opening and closure) at floor i, while 
 describes the entering of passengers at floor i. Moreover, the value up (resp., ) represents the movement of the elevator from the first to the second floor (resp., from the second to the first floor). The value transition function 
 is deterministic and is defined as follows: (i) 
 and 
 for each , (ii) 
 and 
, and (iii) 
 and 
.

Finally, the constraint function 
 is defined as: (i) 
, 
, and 
 for each , and (ii) 
.

A token for a variable x is a pair  consisting of a value 
 and a duration 
 such that 
. For a token ,  denotes the first component v of t. Intuitively, a token for x represents an interval of time where the state variable x takes value v. The behavior of the state variable x is specified by means of timelines, which are non-empty sequences of tokens 
 consistent with the value transition function 
, that is, such that 
, for all . We associate with the i-th token () of the timeline π two punctual events: (i) the start point, whose timestamp (start time), denoted by , is 0 if , and 
 otherwise (i.e., the sum of the durations of the tokens preceding the ith one along π), and (ii) the end point whose timestamp (end time), denoted by , is 
.

Given a finite set SV of state variables, a multi-timeline of SV is a mapping Π assigning to each state variable  a timeline for x.

Example 2

Let us consider a set of transactions, e.g., database transactions, that access a common shared resource A for read/write operations. The resource A can be unlocked (
), read_locked (
), or write_locked (
). A state variable 
, with 
, is used to describe the availability/locking of the resource A over time. The value transition function 
 is represented as a graph in Fig. 1 (left). Each node is labeled by a value v and by the constraint 
. The constants m and M are the lower and upper bound, respectively, for the duration of read/write locking.

Fig. 1
Download : Download high-res image (47KB)
Download : Download full-size image
Fig. 1. State variables xA and xK.

A state variable 
, with K ranging over transaction names, describes the read/write locking requests issued by transaction K for the use of the resource A. A transaction can be idle (
), issuing a read or write lock for accessing the resource (
 or 
, respectively), or reading or writing the resource (
 or 
, respectively). We have 
. An issued lock request can be accepted, thus allowing the use of the resource, or reejected. There is a timeout  for waiting the availability of the resource. The value transition and constraint functions 
 and 
 are depicted in Fig. 1 (right). A multi-timeline for the state variables 
 (shared resource A), 
 and 
 (for two transactions K and H accessing A) is depicted in Fig. 2. Each rectangle of width d corresponds to a token of duration d. For instance, the timeline for 
 represented in Fig. 2 is the sequence of tokens 
.

Fig. 2
Download : Download high-res image (54KB)
Download : Download full-size image
Fig. 2. A multi-timeline for the state variables xA, xK and xH of Example 2.

Synchronization rules. Let SV be a finite set of state variables. Multi-timelines of SV can be constrained by a set of synchronization rules, which relate tokens, possibly belonging to different timelines, through temporal constraints on the start/end-times of tokens (point constraints) and on the difference between start/end-times of tokens (difference constraints). The synchronization rules exploit an alphabet Σ of token names to refer to the tokens along a multi-timeline, and are based on the notions of atom and existential statement.

An atom is either a clause of the form  (point atom), or of the form 
 (difference atom), where 
, , and 
. Intuitively, an atom  asserts that the ev-time (i.e., the start-time if , and the end-time otherwise) of the token referenced by o is in the interval I, while an atom 
 requires that the difference between the ev-time and the 
-time of the tokens referenced by o and 
, respectively, is in I. Formally, an atom is evaluated with respect to a Σ-assignment 
 for a given multi-timeline Π of SV which is a mapping assigning to each token name  a pair 
 such that π is a timeline of Π and  is a position along π (intuitively,  represents the token of Π referenced by the name o). An atom  (resp., 
) is satisfied by 
 if 
 (resp., 
).

An existential statement  (for SV) is a statement of the form
 where  is a conjunction of atoms, 
, 
, and 
 for each . The elements 
 are called quantifiers. A token name used in , but not occurring in any quantifier, is said to be free. Intuitively, the quantifier 
 binds the name 
 to some token in the timeline for variable 
 having value 
. A Σ-assignment 
 for a multi-timeline Π of SV satisfies  if each atom in  is satisfied by 
, and for each quantified token name 
, 
 where 
 and the h-th token of π has value 
. A multi-timeline Π of SV satisfies  if there exists a Σ-assignment 
 for Π which satisfies .

Definition 2

A synchronization rule  for the set SV of state variables has one of the forms
 where 
, 
, 
, and 
 are existential statements. In trigger rules, the quantifier 
 is called trigger, and it is required that only 
 may appear free in 
 (for ). For trigger-less rules, it is required that no token name appears free.

Intuitively, a trigger 
 acts as a universal quantifier, which states that for all the tokens of the timeline for the state variable 
 with value 
, at least one of the existential statements 
 must be true. Trigger-less rules simply assert the satisfaction of some existential statement. Formally, the standard semantics of the synchronization rules is defined as follows. A multi-timeline Π of SV satisfies a trigger-less rule  of SV if Π satisfies some existential statement of . Π satisfies a trigger rule  of SV with trigger 
 if for every position i of the timeline 
 for 
 such that 
, there is an existential statement  of  and a Σ-assignment 
 for Π such that 
 and 
 satisfies .

Trigger-less are usually exploited to express initial conditions or the goals of the problem, while trigger rules are useful to specify invariants and response requirements.

Example 3

With reference to Example 2, we introduce a set of synchronization rules to guarantee that the shared resource A is accessed in mutual exclusion during writing by transactions K and H. We preliminarily define some shorthand (conjunctions of atoms) to express interval relations between tokens associated with token names o and 
:

•
 requires that the token referenced by 
 occurs during the token referenced by o;

•
 states that token 
 does not start before token o and crosses the end point of token o.

The pair of trigger-less rules below state the initial conditions: the resource A is initially unlocked and transactions K and H are idle. The first trigger rule ensures that when transaction K reads resource A, the resource is locked for reading (the same can be required for H). The second trigger rule requires that when transaction K writes A (
), there is a write locking token (
) of A with the same temporal window as token 
.

•
 and 
;

•
;

•
.

The two trigger rules above ensure also the mutual exclusion among reads and writes of the resource A by the same transaction K. The next rule is added to guarantee mutual exclusion when both transactions K and H write A, that is, it ensures that K and H do not feature tokens of value 
 and 
, respectively, with the same temporal window. 
 
  Notice that the multi-timeline of Fig. 2 satisfies all the above rules.

Domains and plans. A TP domain  is specified by a finite set SV of state variables and a finite set R of synchronization rules modeling their admissible behaviors. A plan of  is a multi-timeline of SV satisfying all the rules in R. The TP problem consists of checking, given a domain , whether there is a plan of .

We also consider the discrete-time versions of the previous problems, where the durations of the tokens in a plan are restricted to be natural numbers.

2.2. The TP problem with future semantics
As already mentioned, the TP problem is undecidable in the general setting. The first negative result presented in the paper is that the problem remain undecidable under a stronger notion of satisfaction of trigger rules, called satisfaction under the future semantics. The future semantics requires that all the non-trigger selected tokens do not start strictly before the start-time of the trigger token.

Definition 3

A multi-timeline Π of SV satisfies a trigger rule 
 under the future semantics if Π satisfies the trigger rule obtained from  by replacing each existential statement 
 with 
. A future plan of  is a multi-timeline of SV satisfying all the rules in R under the future semantics. The future TP problem consists of checking, given a domain , whether there is a future plan of .

Notice that the multi-timeline of Fig. 2 is a future plan for the domain described in Example 2. The following result negatively answers a question left open in [18].

Theorem 1

Future TP problem with one state variable is undecidable even if the intervals are in 
.2

Theorem 1 is proved by a polynomial-time reduction from the halting problem for Minsky 2-counter machines [30]. For the sake of completeness, we recall the definition of halting problem for Minsky 2-counter machines (the notion will be useful in the proof of Theorem 2 as well).

A nondeterministic Minsky 2-counter machine is a tuple 
, where Q is a finite set of (control) locations, 
 is the initial location, 
 is the halting location, and  is a transition relation over the instruction set . For a transition 
, we define , , and 
. Without loss of generality, we assume that:

•
for each transition , 
 and 
, and

•
there is exactly one transition , denoted 
, such that 
.

An M-configuration is a pair  consisting of a location  and a counter valuation . A computation of M is a non-empty finite sequence 
 of configurations such that for all , there is some instruction 
 so that 
 and: (i) 
 if 
; (ii) 
 if 
; (iii) 
 and 
 if 
; and (iv) 
 if 
. The halting problem consist of deciding whether, for a machine M, there is a computation starting at the initial configuration 
, where 
, and leading to some halting configuration 
 (it was proved to be undecidable in [30]).

Proposition 1

Given a Minsky 2-counter M, one can construct (in polynomial time) a TP instance (domain) 
, where the intervals in P are in 
 such that M halts if and only if there exists a future plan for P.

The proof of above proposition is given in [1], and it is reported in Appendix A for the sake of self containment.

2.3. The TP problem with minimal semantics
In this subsection, we define the variant of the semantics for trigger rules newly proposed and investigated in this paper. In the standard semantics of trigger rules, if there are many occurrences of non-trigger tokens carrying the same specified value, nothing forces the choice of a specific occurrence for satisfying the required constraints. With reference to Example 2, consider the trigger rule 
 requiring that each read lock request of transaction K is ultimately satisfied. The timeline 
 for 
 depicted in Fig. 2 fulfils the trigger rule both with the Σ-assignment 
, 
 and the assignment 
, 
, namely the witness of the satisfaction of first read lock request is either the first read lock or the last read lock. Actually, the more natural choice would be the following Σ-assignments providing the closest 
 token to the 
 trigger occurrence: 
 and 
; 
 and 
; 
 and 
.

Following this idea, the minimal semantics is obtained from the standard semantics by additionally requiring that the given Σ-assignment 
 selects for each (existential) quantifier  a token for variable x with value v whose start point has a minimal time distance from the start point of the trigger.

Actually, the constraint of minimality can be used to express two alternative semantics: the weak minimal semantics which distinguishes minimality in the past (w.r.t. the trigger token) from the minimality in the future, and the strong minimal semantics which considers minimality over all the start times (both in the past and in the future) of the tokens for a variable x and x-value v.

Definition 4 Weak and strong minimal semantics of trigger rules

Let 
. A Σ-assignment 
 for a multi-timeline Π of SV is weakly minimal w.r.t. 
 if for each  with 
, the following holds:

•
minimality in the past: if 
, then there is no position ℓ along the timeline π such that  and 
;

•
minimality in the future: if 
, then there is no position ℓ along the timeline π such that  and 
.

A Σ-assignment 
 for Π is strongly minimal w.r.t. 
 if for each  with 
, there is no position ℓ along the timeline π such that  and 
.
The weak minimal (resp., strong minimal) semantics of the trigger rules is obtained from the standard one by imposing that the considered Σ-assignment 
 is weakly minimal (resp., strongly minimal) w.r.t. the trigger token 
.

Note that we consider start points of tokens for expressing minimality. Equivalent semantics can be obtained by considering end points of tokens instead. A weak (resp., strong) minimal plan of  is a multi-timeline of SV satisfying all the rules in R under the weak (resp., strong) minimal semantics of trigger rules. The weak (resp. strong) minimal TP problem is checking given a domain , whether there is a weak (resp. strong) minimal plan of . Obviously, any weak minimal or strong minimal plan is also a plan and any strong minimal plan is also a weak minimal plan. Hence, the strong minimal semantics is a refinement of the weak minimal one, which is in turn a refinement of the standard semantics.

Example 4

With reference to Example 3, one can easily check that any plan for the particular domain is a weak minimal plan. For instance, consider the synchronization rule 
 and an assignment satisfying R in the standard semantics binding o and 
 to tokens 
 and 
, respectively, for some 
 and 
. Since token 
 covers token 
, there cannot be another token 
, with , such that 
, implying that the same assignment satisfies R also in the weak minimal semantics. Similar arguments can be used for all the other rules. Conversely, a plan is not necessarily a strongly minimal one. As an example, consider the timeline 
 for the state variable 
 and the timeline 
. The given multi-timeline satisfies the synchronization rule R both in the standard and in the weak minimal semantics binding the symbol o to 
. In the strong minimal semantics, the synchronization rule is not satisfied since the symbol o can only be bound to 
 (
).

The idea underlying the introduction of the weak and strong minimal semantics of the trigger rules is inspired by research in formal verification and synthesis where in the last two decades many papers have focused on quantitative aspects, in particular boundedness requirements. We observe that the trigger rules represent a first-order formalism for expressing quantitative temporal liveness requirements such as the (future) non-punctual bounded-time request-response condition: “every request p is followed by a response q within k time units”. It is well-known that quantitative verification problems which take into account unrestricted quantitative liveness properties are undecidable in the dense-time setting. For example, for the class of Timed Automata (TA) [25], the verification problem (model checking) against the fragment of  [27] with past expressing punctual bounded-time response properties is in general undecidable, and with a non-primitive recursive complexity if the past modalities are disallowed [26]. Therefore, in the literature, some subclasses of  and fragments of timed temporal logics have been introduced to recover decidability and tractability, which are still interesting in practice since they can express non-punctual bounded-time response properties. In particular, the idea behind the minimal semantics of trigger rules is exploited in the class of Event-Clock Automata (ECA) [28], a well-known robust subclass of , and in the fragment of  represented by Event-Clock Temporal Logic (EC_TL) [31]. These frameworks allow to specify bounds on the time distance between the “trigger” event (the event occurring at the current time) and a “response” event in the future (resp., in the past), where the latter is uniquely determined by requiring that its distance from the trigger is minimal among all events in the future (resp., in the past) associated with a given observable atomic proposition. Note that differently from the format of trigger rules which is based on existential and universal quantification,  and  have explicit mechanisms to refer to the past and to the future. In particular,  distinguish between past clock and future clocks, while the logic  has past and future temporal modalities. In the setting of trigger rules, the most natural notion of minimality in the choice of the existential tokens leads to the strong minimal semantics. On the other hand, the weak minimal semantics seems more interesting from a practical point of view since allows to keep separated the choices made in the past from those made in the future (w.r.t. the starting time of the trigger token). As we will see in the next sections, the weak minimal semantics is also drastically preferable from a complexity-theoretic point of view. As clearly illustrated in the following example, there is a subtlety in the strong minimal semantics which is the basis of an high expressive power. While in the weak minimal semantics, the “minimal” token is uniquely determined, in the strong semantics there may be two minimal tokens: one in the past and one in the future. In this way, it is possible to enforce that two adjacent temporal intervals have the same duration, which is a key ingredient for encoding counting operations also in the discrete-time setting.

We provide the following example to stress the difference between the weak minimal and strong minimal semantics enlightening the expressive power of the strong minimal one.

Example 5

Let us consider two state variables: 
, with 
, 
, and 
; 
, with 
 and 
. Before defining the synchronization rules, we introduce some shorthand (conjunctions of atoms) to express interval relations between tokens associated with token names o and 
:

•
 requires that the token referenced by o is an initial subinterval of the token referenced by 
;

•
symmetrically, 
 requires that the token referenced by o is a final subinterval of the token referenced by 
.

We require that: (i) timelines for 
 start with A-valued tokens; (ii) each A-valued (resp, B-valued) token is an initial subinterval (resp, final subinterval) of a C-valued token; (iii) each B-valued token is preceded and followed by a C-valued token.

•
;

•
;

•
;

•
;

•
.

Fig. 3 shows two examples of multi-timelines for the considered domain. Both of them are plans in the weak minimal semantics, whereas only the second multi-timeline is a plan for the strong minimal one. As a matter of fact, a plan in the strong minimal semantics satisfies the quite expressive property that every pair of tokens 
, 
 of the timeline for 
 included in the same token 
 of the timeline for 
 must fulfill 
 and then 
. This implies that the strong minimal semantics allows one to enforce very expressive constraints on the duration of tokens (they will be exploited in the following to prove the undecidability of the TP problem under the strong minimal semantics).
Fig. 3
Download : Download high-res image (37KB)
Download : Download full-size image
Fig. 3. Multi-timelines for Example 5.

Assumption 1 Strict time monotonicity

In the following, for simplifying the technical presentation of some results, without loss of generality, we assume that given a state variable 
, the duration of a token for x is never zero, i.e., for each 
, 
.

3. Undecidability of the strong minimal TP problem
In this section, we prove the undecidability of the strong minimal TP problem by a polynomial-time reduction from the halting problem for Minsky 2-counter machines [30]. The key feature in the reduction is the ability of expressing for a given value v, a temporal equidistance requirement w.r.t. the start point of the trigger token for the start points of the last token before the trigger with value v and the first token after the trigger with value v (the same feature exemplified in Example 5). It is meaningful to observe that the reduction does not exploit the power of dense-time domain. Thus, the undecidability of the strong minimal TP can be stated also in a discrete time domain. Such a result is surprising since the TP problem in the standard semantics with discrete time domain is decidable.

Theorem 2

The strong minimal TP problem is undecidable even in the discrete-time setting.

Proof

The proof is by a polynomial-time reduction from the halting problem for Minsky 2-counter machines [30]. For a Minsky 2-counter machines 
 we construct a TP instance 
 such that M halts if and only if there exists a strong minimal discrete-time plan for 
.

We exploit a state variable 
 for encoding the evolution of the machine M and additional state variables for checking that the values of counters in the timeline for 
 are correctly updated. The domain 
 of the state variable 
 is 
 where 
 is the set of pairs 
, where 
, , and 
 if 
, and 
 otherwise. Intuitively, in the pair 
, δ is the transition currently taken by M from the current non-halting configuration C, while 
 is ⊥ if C is the initial configuration, and 
 is the transition taken by M in the previous computational step, otherwise.

A configuration  of M is encoded by the timelines 
 (configuration codes) of length 9 for the state variable 
 depicted in the figure above, where 
 (called 
-value of 
) is of the form 
 such that . Note that the configuration code 
 consists of two parts.


Download : Download high-res image (27KB)
Download : Download full-size image
In the left part (resp., right part), the encoding of counter 1 (resp., 2) precedes the encoding of counter 2 (resp., 1). The value  of counter 1 is encoded by the duration, which is , of the counter token with value marked by 
 in the left part, and the counter token with value marked by 
 in the right part, and similarly for counter 2. The four tokens with values marked by 
, 
, 
, and 
, respectively, are called tagged tokens and their duration is always 1: they are used to check by trigger rules (under the strong minimal semantics) that increment and decrement M-instructions are correctly encoded. Moreover, we require that the configuration code 
 satisfies the following additional requirement (
-requirement), with 
 and 
:
•
 if 
, and 
 is of the form 
 otherwise (consecution);

•
if 
 then the counter tokens have duration 1;

•
if  (resp., ), then the durations of the counter tokens with values 
 and 
 are greater than 1 (resp., are equal to 1).

A pseudo-configuration code is defined as a configuration code but allowing that the counter tokens (i.e., the tokens with values in 
) have arbitrary duration provided that the restriction that the 
-requirement is fulfilled. In particular, in a pseudo-configuration code, the requirement that for each counter , the duration of the counter token marked by 
 coincides with the duration of the counter token marked by 
 is relaxed.

A pseudo-computation code 
 is a sequence of the form 
 such that

(i)
 and 
 are pseudo-configuration codes for all ;

(ii)
if  (resp., ), the 
-value of 
 (resp., 
) is 
 (initialization);

(iii)
the 
-value of 
 is of the form 
 such that 
 (halting).

By construction, we can easily define the transition function 
 and the constraint function of 
 in such a way that (i) the timelines for 
 whose first token has value 
 correspond to the prefixes of pseudo-computation codes, and (ii) 
 for all 
. Hence, for capturing the timelines of 
 representing all and only the pseudo-computation codes it suffices to exploit a trigger-less rule 
 requiring that a timeline of 
 visits a token with value 
 (initialization) and a token with value 
 such that 
 (halting).

We now consider the crucial part of the reduction which has to guarantee that along a pseudo-computation code (i.e., a timeline of variable 
 satisfying the trigger-less rule 
) the counters are correctly encoded (i.e., the durations of the left and right tokens for each counter in a pseudo-configuration code coincide) and are updated accordingly to the M-instructions. For each instruction  of the machine M, let 
 be the subset of 
 consisting of the pairs 
 such that 
 and 
. We exploit an additional state variable 
 and, for each instruction op of M, the additional state variable 
. Each of such variables x has domain 
 and captures the timelines 
 such that the duration of each token is at least 1 and the untimed projection (first component of each token) of 
 is an arbitrary non-empty word over 
. Variable 
 is used in conjunction with trigger rules for enforcing that along a pseudo-computation code 
 the durations of the left and right tokens for counter 1 (resp., 2) coincide (left-right requirement), while for each instruction op, variable 
 is used in conjunction with trigger rules for ensuring that the durations of the counter tokens in the non-initial pseudo-configuration codes 
 of 
 whose 
 values are in 
 are updated consistently with the instruction op (op-requirement). For this, we first require that the timelines associated to distinct state variables are synchronized, i.e., they have the same length and for each position i, the start-times of the ith tokens of the different timelines coincide. Since the duration of a token is not zero, the synchronization requirement can be easily expressed by simple trigger rules (under the strong minimal semantics). Then, for all variables 
, values 
, and values 
, we have the two trigger rules
 
 
 Next, we define trigger rules capturing under the strong minimal semantics, the left-right requirement and the op-requirement for each M-instruction op.

Trigger rules for the left-right requirement. The encoding ensures that the left-right requirement is fulfilled along a pseudo-computation code 
 if and only if for each token 
 marked by 
, the following holds: for the last token marked by 
 (resp., 
) preceding token 
 and the first token marked by 
 (resp., 
) following token 
, their start points have the same time distance from the start point of 
 (see the figure in the following). For this, we first require by trigger rules that for the timeline 
 for 
 (synchronized with 
), a token has value trigger (resp., has value 
, resp., has value 
) iff the associated token along 
 has a value in 
 (resp., in 
, resp., in 
). The trigger rules ensuring the previous requirement are similar to the ones exploited for the synchronization requirement. Finally, we require that for each trigger-token 
 along the timeline 
 for 
, and for each , the start points of the last 
-token of 
 preceding token 
 and the first 
-token following token 
 have the same time distance from the start point of 
 (check requirement for variable 
). By the strong minimal semantics, the check requirement for variable 
 can be expressed by the following two trigger rules which ensure that for the 
-tokens () of the timeline for 
 whose start points have the smallest time distance from the start point of the trigger, there is one preceding the trigger and one following the trigger (recall that under the strong minimal semantics, each non-trigger selected token needs to have the smallest time distance from the trigger token over the tokens belonging to the same variable and having the same value):
 
 



Download : Download high-res image (32KB)
Download : Download full-size image
Trigger rules for increment, zero-test, and decrement instructions.

Let  and c be the counter associated with op. Given a pseudo-computation code 
 and a non-initial pseudo-configuration code 
 of 
 with 
-value in 
, let 
 and 
 be the tokens for counter 1 and 2, respectively, in the left part of 
, and 
 and 
 be the tokens for counter 1 and 2, respectively, in the right part of the pseudo-configuration code 
 preceding 
 along 
 (see the following figure). We need to ensure that the durations of tokens 
 and 
 coincide, and

•
case : the duration of 
 is the duration of 
 plus one;

•
case : the duration of 
 is the duration of 
 minus one;

•
case : the durations of tokens 
 and 
 coincide.

Here, we focus on the case where  for some  (the cases of zero-test and increment instructions being similar). In particular, in the figure we report the timeline for . Our encoding ensures that the previous requirement is fulfilled iff for each token 
 of 
 with value in 
, the following holds, where 
 if , and 
 otherwise: for the last token marked by 
 (resp., 
) preceding token 
 and the first token marked by 
 (resp., 
) following token 
, their start points have the same time distance from the start point of 
. The previous requirement can be enforced as done for the case of the left-right requirement.


Download : Download high-res image (40KB)
Download : Download full-size image
4. Some novel extensions of Event-Clock Automata (ECA)
As we shall prove in Section 5, the TP problem under the weak minimal semantics is PSPACE-complete. Such a complexity result is proved by a non-trivial exponential-time reduction to the non-emptiness of TA. To handle the trigger rules under the weak minimal semantics, we shall exploit, as an intermediate step in the reduction, a strictly more expressive extension of ECA (Event Clock Automata) [28], called ECA+, which is introduced and studied in this paper. This novel extension of ECA is obtained by allowing a larger class of atomic event-clock constraints, namely, diagonal constraints between clocks of the same polarity (past or future) and sum constraints between clocks of opposite polarity. We show that, similarly to ECA, ECA+ are closed under language Boolean operations and can be translated in exponential time into equivalent  with an exponential number of control states, but a linear number of clocks. This result will be exploited in Section 5 for handling the trigger rules of the given TP domain under the weak minimal semantics in order to obtain an exponential-time reduction of the weak minimal TP problem to nonemptiness of TA. We believe that such an extension, which is motivated by technical reasons, is interesting per se.

In order to understand in depth this new class of automata, we show that if we relax the requirements in the diagonal and sum constraints, the resulting class of automata, called ECA++, turns out to be very expressive, and its nonemptiness problem becomes undecidable.

The rest of the section is organized as follows. In Subsection 4.1, we briefly recall the class of Timed Automata [25]. Next, in Subsection 4.2, we introduce and address expressiveness issues and closure properties for ECA+ and ECA++. Then, in Subsection 4.3, we define a mapping of ECA+ into equivalent TA. Finally, in Subsection 4.4, we show undecidability of the nonemptiness problem for ECA++.

4.1. Timed Automata
In this section, we recall the class of Timed Automata (TA) [25] over (finite) timed words.

Let Σ be a finite alphabet. A timed word w over Σ is a finite word 
 over 
 (intuitively, for each i, 
 is the time at which 
 occurs) such that 
 for all  (monotonicity). The timed word w is also denoted by , where σ is the finite untimed word 
 and τ is the sequence of timestamps 
. A timed language over Σ is a set of timed words over Σ.

Definition 5 Timed Automata

A TA over Σ is a tuple 
, where Q is a finite set of (control) states, 
 is the set of initial states, C is a finite set of clocks,  is the set of accepting states, and Δ is the finite set of transitions 
 such that 
, ,  is a clock reset set, and θ is a clock constraint over C, that is a conjunction of atomic formulas of the form  (simple constraints) with , , and .

We denote by 
 the maximal constant used in the clock constraints of .

Intuitively, in a TA , while transitions are instantaneous, time can elapse in a control state. The clocks progress at the same speed and can be reset independently of each other when a transition is executed, in such a way that each clock keeps track of the time elapsed since the last reset. Moreover, clock constraints are used as guards of transitions to restrict the behavior of the automaton. Formally, a configuration of  is a pair , where  and 
 is a clock valuation for C assigning to each clock a non-negative real number. For 
 and a reset set , the valuations  and  are defined as: for all , , and  if  and  otherwise. For a clock constraint θ, val satisfies θ, written , if for each conjunct  of θ, .

A run r of  on a timed word 
 over Σ is a sequence of configurations 
 starting at an initial configuration 
, with 
 and 
 for all , and such that for all  (we let 
): 
 for some constraint θ and reset set Res, 
 and 
. The run r is accepting if 
. The timed language 
 of  is the set of timed words w over Σ such that there is an accepting run of  over w.

4.2. ECA+ and ECA++
In this section, we introduce an extension, denoted by ECA+, of Event Clock Automata (ECA) [28], the latter being a well-known determinizable subclass of TA where the explicit reset of clocks is disallowed. In ECA, clocks have a predefined association with the input alphabet symbols and their values refer to the time distances from previous and next occurrences of input symbols. ECA+ extend ECA by allowing a larger class of atomic event-clock constraints, namely diagonal constraints (alias difference constraints) between clocks of the same polarity (i.e., between past clocks or between future clocks) and sum constraints between clocks of opposite polarity (i.e. between a past clock and a future clock). Additionally, we consider the extension of ECA+, denoted by ECA++, where the polarity requirements in the diagonal and sum constraints are relaxed.

Here, we adopt a propositional-based approach where the input alphabet is given by 
 for a given set of atomic propositions. The set 
 of event clocks associated with  is given by

Image 1
. Thus, for each proposition , there are two event clocks: the event-recording or past clock
Image 2
which records the time elapsed since the last occurrence of p in the input word (if any), and the event-predicting or future clock
Image 3
which provides the time required to the next occurrence of p (if any). A special value ⊥ is exploited to denote the absence of a past (resp., future) occurrence of proposition p. Formally, the values of the event clocks at a position i of a timed word w can be deterministically determined as follows.
Definition 6 Deterministic clock valuations

An event-clock valuation (over 
) is a mapping 
, assigning to each event clock a value in 
 (⊥ is the undefined value). For a timed word  over 
 and a position , the event-clock valuation 
, specifying the values of the event clocks at position i along w, is defined as follows for each :

Definition 7

ECA+ and ECA++
An ECA+ over 
 is a tuple 
, where Q is a finite set of states, 
 is a set of initial states,  is a set of accepting states, and Δ is a finite set of transitions 
, where 
, 
, and θ is an ECA+ event-clock constraint that is a conjunction of atomic formulas of the following forms, where 
, , and 
:

•
Image 6
or
Image 7
(simple constraints);
•
Image 8
or
Image 9
(diagonal constraints between event clocks of the same polarity);
•
Image 10
(sum constraints between event clocks of opposite polarity).
We denote by 
 the maximal constant used in the event-clock constraints of .
An ECA [28] is an ECA+ which does not use diagonal and sum constraints. We also consider the extension of ECA+, denoted by ECA++, where the transition guards also exploit as conjuncts diagonal (resp., sum) constraints over event clocks of opposite polarity (resp., of the same polarity).

Let us fix an event-clock valuation val. We extend in the natural way the valuation val to differences (resp., sums) of event clocks: for all 
, 
 and 
 where each sum or difference involving ⊥ evaluates to ⊥. Given an event-clock constraint θ, val satisfies θ, written , if for each conjunct 
 of θ, either (i) , 
, and 
, or (ii) , 
, and .

A run π of an ECA+ (resp., ECA++)  over a timed word  is a sequence of states 
 such that 
 and for all , 
 for some constraint θ such that 
. The run π is accepting if 
. The timed language 
 of  is the set of timed words w over 
 such that there is an accepting run of  on w.

We observe that the standard class of ECA allows to express atomic constraints on the time distance between two events where one of them occurs at the current time. In this way, it is possible to specify standard bounded-time response requirements such as “every request p is followed by a response q within k time units”. The novel class of ECA+ extends ECA by the additional ability to temporally compare two events where none of them occurs at the current time. This allows, for instance, to express a context-based version of bounded-time response properties. In order to illustrate this, we consider a simple example. Assume that a client can send two kinds of requests to the server: default and critical ones. While there is no bound on the time for processing a default request, we require that every critical request is processed within a given amount of time, say 1 time unit. This scenario is modeled by the ECA+ in Fig. 4, where proposition  () models the sending of a default (resp., critical) request to the server,  represents the starting of request processing by the server, and proposition  represents the termination of server processing and the sending of a response to the client.

Fig. 4
Download : Download high-res image (41KB)
Download : Download full-size image
Fig. 4. Example of an ECA+ specifying a context-based bounded-time response requirement.

We now formally show that ECA+ are more expressive than ECA, i.e. the class of ECA+ timed languages includes strictly the class of ECA timed languages. Let us consider the ECA+ 
, depicted below, whose set  of atomic propositions consists of a unique proposition p.



Download : Download high-res image (14KB)
Download : Download full-size image
The automata 
 accepts timed words w of length 3 of the form 
 such that the time difference between the first and last symbol is 1, i.e. 
. We show that there is no ECA accepting 
. Indeed, let 
 and 
 be the timed words over 
 (with ) of length 3 defined as follows:
•
;

•
.

For each , let us denote by 
 and 
 the event-clock valuations over 
 associated with 
 and 
, respectively, at position i. By construction, the following easily follows for all positions  and event-clocks 
: either (i) 
, or (ii) 
 and 
. Hence, simple atomic event-clock constraints cannot distinguish the valuations 
 and 
. It follows that for each ECA  over 
, 
 iff 
. On the other hand, by definition of the language 
, 
 and 
. Hence, 
 is not definable by ECA and we obtain the following result.
Theorem 3

For a proposition p, there is a timed language over 
 which is definable by ECA+ but is not definable by ECA. Hence, ECA+ are strictly more expressive than ECA.

For completeness, we also investigate the class of ECA++, the extension of ECA+ where the polarity requirements in the diagonal and sum constraints are relaxed. ECA++ extend ECA+ by adding a very powerful layer of modeling facilities. In particular, arbitrary sum constraints allow to compare the durations of two temporal intervals where one of them ends at the current time and the other one starts at the current time. Moreover, arbitrary diagonal constraints can enforce a bound on the sum of durations of two temporal intervals both starting (resp., ending) at the current time. As a simple example, depicted in Fig. 5, we consider a variant of the ECA+ illustrated in Fig. 4, where the server processing of a client request is subdivided in two phases of equal duration. Note that in Fig. 5 the starting of the first phase (resp., second phase) is modeled by proposition 
 (resp., 
).

Fig. 5
Download : Download high-res image (26KB)
Download : Download full-size image
Fig. 5. Example of an ECA++.

Closure properties. Similarly to the case of ECA [28], the class of timed languages accepted by ECA+ (resp., ECA++) is closed under Boolean operations.

Theorem 4 Closure properties

Given two ECA+ (resp., ECA++)  and 
 over 
 with n and 
 states, respectively, one can construct ECA+ (resp., ECA++) 
, 
, and 
 such that:

•
 (resp., 
) accepts 
 (resp., 
) and has 
 (resp., 
) states and greatest constant 
;

•
 accepts the complement of 
 and has 
 states and greatest constant 
.

In the remaining part of the subsection we give the proof of Theorem 4. Actually, the results for union and intersection are straightforward and omitted, and we focus on the closure under complementation which is crucially based on the fact that event-clock values are purely determined by the input timed word. We prove the complementation result for the class of ECA++ (the result for ECA+ being similar). We define an homomorphism from ECA++ to standard Nondeterministic Finite Automata (NFA) over finite words and vice versa. Note that an NFA is defined as an ECA++ but we omit the set of event clocks, and the set of clock constraints occurring in the transition function.

Let us fix an ECA++ 
 over 
 and let 
 be the set of constants used in the event-clock constraints of  ordered for increasing values, i.e. such that 
. The finite set 
 of intervals over  is defined as follows:
 
 Note that we also consider the interval  consisting of the negative real numbers. The set Terms of ECA++ terms over  is the set of expressions of the form c, or 
, or 
, where 
 (i.e., the set of left-hand side expressions in the atomic event-clock constraints of ECA++ over 
). For a term t and an interval 
, we denote by , the event-clock constraint  defined as follows:

•
if , then ;

•
if , then ;

•
if 
 (resp., , resp., ) where 
, then 
 (resp., , resp., ).

A region g of  is a mapping 
 assigning to each term in Terms an interval in 
 such that for each , if , then 
 for some clocks c and 
 and 
. The mapping g induces the ECA++ event-clock constraint 
. We denote by  the (possibly empty) set of event-clock valuations over 
 satisfying the event-clock constraint associated with g, and by Reg the set of regions of . For an ECA++ event-clock constraint θ over 
, let  be the set of event-clock valuations over 
 satisfying θ.
Remark 1

By construction, the following properties hold.

•
The set Reg of regions represents a partition of the set of event-clock valuations over 
:

(i) for all event-clock valuations val over 
, there is a region  such that ,

(ii) for all regions 
, 
.

•
for each event-clock constraint θ of  and region , either  or .

We associate with the alphabet 
 and the set of regions Reg the alphabet 
, called interval alphabet. Elements of Λ are pairs of the form , where 
 and g is a region of  which is meant to represent the associated event-clock constraint 
. A word 
 over Λ induces in a natural way a set of timed words over 
, denoted , defined as follows:  iff 
 and for all , 
. We extend the mapping tw to languages  over Λ in the obvious way: 
. By means of the mapping tw, words over Λ define a partition of the set of timed words over 
.

Lemma 1

The following two statements hold:

1.
for each timed word w over 
, there is a word λ over Λ such that ;

2.
for all words λ and 
 over Λ, if 
, then 
.

Proof

As for Statement 1, let 
 be a timed word over 
. By Remark 1, for all , there is a region 
 such that 
. Let 
. We have that , and the result follows.

As for Statement 2, let λ and 
 be two distinct words over Λ. Let us assume that 
 and derive a contradiction. Hence, by construction, 
 for some n, 
, 
, and there is a timed word w over Σ of the form 
 such that 
 for all . Since 
, there exists  such that 
. By Remark 1, 
 which is a contradiction since 
, and the result follows. □

The following two propositions establish an untimed homomorphism from ECA++ to NFA, and a timed homomorphism from NFA to ECA++, respectively.

Proposition 2 Untimed homomorphism

Let 
 be an ECA++, and Λ be the interval alphabet induced by . Then, one can construct an NFA  over Λ of the form 
 such that 
.

Proof

The transition relation 
 of  consists of the transitions 
 such that there is some event-clock constraint θ of  so that  and 
. By Remark 1 and Lemma 1(1), we easily derive the correctness of the construction. □

Proposition 3 Timed homomorphism

Let 
 be an NFA over an interval alphabet associated with 
. Then, one can construct an ECA++  over 
 of the form 
 such that 
.

Proof

The transition relation 
 of  consists of the transitions 
 such that there is 
 so that 
. By Remark 1 and Lemma 1(1), we easily derive the correctness of the construction. □

By Lemma 1, Proposition 2, Proposition 3, and the known closure properties of NFA, we have the following result.

Theorem 5

Closure under complementation of ECA++
Given an ECA++  over 
 with n states, one can construct in singly exponential time an ECA++ 
 
 over 
 accepting the complement of 
 having 
 states and greatest constant 
.

Proof

Let  be an ECA++ over 
 with n states, and Λ be the interval alphabet induced by . By Proposition 2, we can construct an NFA  over Λ with n states such that 
. By classical results, starting from the NFA , one can construct in singly exponential time an NFA 
 
 over Λ accepting 
⁎
 with 
 states. Applying Proposition 3 to the NFA 
 
, one can construct in linear time an ECA++ 
 
 over 
 with 
 states such that 
 
⁎
. Since 
, by Lemma 1, 
 
 accepts all and only the timed words over 
 which are not in 
, and the result follows. □

4.3. From ECA+ to Timed Automata
It is known that ECA can be translated in singly exponential time into equivalent TA [28]. In this section, we generalize this result to the class of ECA+.

Theorem 6

From ECA+ to TA
Given an ECA+  over 
, one can construct in exponential time a TA 
 over 
 such that 
 and 
. Moreover, 
 has 
 states and  clocks, where n is the number of -states and p is the number of event-clock atomic constraints used by .

Proof

We sketch the main ideas underlying the translation providing full details in Appendix B. Let 
 be an ECA+ over 
. The TA 
 accepting 
 is essentially obtained from  by replacing each atomic event-clock constraint of  with a set of standard clocks together with associated reset operations and clock constraints. To remove simple event-clock constraints of , we can proceed as in [28]. Therefore, we focus on the removal of diagonal constraints (over clocks of the same polarity) and sum constraints (over clocks of opposite polarity).

Removal of diagonal predicting constraints. Let us consider a diagonal predicting clock constraint

Image 11
of  with 
. We consider the case 
 (the case 
 being simpler). For handling the constraint η, the TA 
 exploits the fresh standard clock 
 and in case 
 and , the additional fresh standard clock 
. The first (resp., second) clock is reset only if proposition 
 (resp., p) occurs in the current input symbol. Assume that the prediction η is done by  at position i of the input word for the first time. Then, the simulating TA 
 carries the obligation η in its control state in order to check that there are next positions where p and 
 occur and 
 holds, where 
 (resp., 
) is the timestamp associated with the first next position 
 (resp., 
) where p (resp., 
) occurs. Note that all the predictions η done by  before positions 
 and 
 correspond to the same obligation. First, assume that the first next position 
 where 
 occurs strictly precedes position 
. In this case, on reading position 
, 
 resets the clock 
 and replaces the old obligation η with the updated obligation 
 in order to check that the constraint 
 holds when the next p occurs (i.e., at position 
). If a new prediction η is done at a position 
 strictly preceding 
, the fresh obligation η is carried in the control state together with the obligation 
. We distinguish two cases:
•
 occurs in some position strictly following 
 and strictly preceding 
. Let 
 be the smallest of such positions. On reading position 
, 
 replaces the old obligations η and 
 with 
 and resets the clock 
 iff η is a lower bound constraint, i.e., . This is safe since if η is a lower bound, then the fulfillment of prediction η at 
 guarantees the fulfillment of prediction η at position i. Vice versa, if η is an upper bound, then the fulfillment of prediction η at i guarantees the fulfillment of prediction 
 at position 
. Thus, when η is a lower bound, new obligations 
 rewrite the old ones, while when η is an upper bound, new obligations 
 are ignored.

•
there is no position strictly following 
 and strictly preceding 
, where 
 occurs. In this case, when 
 is read, the old obligation η is replaced by the obligation  unless 
 occurs at position 
 (in the latter case, 
 simply checks that 
).

In both cases on reading position 
, the constraint 
 is checked and the obligation 
 is discarded. The case where 
 is trivial (on reading position i, 
 checks that 
 holds). Finally, assume that 
 strictly precedes 
. The cases where either  or , since in these cases if η is a lower bound (resp., upper bound), then the prediction η done at position i is not satisfied (resp., is satisfied). Thus, we focus on the case where  and . If ∼ is ≥ (resp., ∼ is <), then on reading position 
, the clock 
 is reset and the old obligation η is replaced by the updated obligation  in order to check that the constraint 
 (resp., 
) holds when the next 
 occurs (i.e., at position 
). Moreover, if ∼ is ≥, then new obligations  occurring before position 
 are ignored, i.e., the clock 
 is not reset at such positions. On the other hand, if ∼ is <, then the new obligations  occurring before position 
 rewrite the old ones. i.e. clock 
 is reset at such positions.

Finally, in order to ensure that raised obligations about η are eventually checked, the accepting states of 
 do not contain such obligations.

Removal of diagonal recording constraints. Let us consider a diagonal recording clock constraint

Image 12
of  where 
. For each proposition 
 whose associated event-recording clock
Image 13
occurs in some constraint of , the TA 
 exploits a standard clock 
 which is reset whenever 
 occurs in the current input symbol. Moreover, 
 keeps tracks in the control state of the set of propositions occurred in the prefix w of the input read so far together with the past information concerning the indication whether the following requirement holds or not (such an indication is represented by the presence or not in the control state of the constraint η): the prefix w contains occurrences of both propositions p and 
 and in case 
, 
 holds, where 
 and 
 are the timestamps associated with the last occurrences of p and 
 in the prefix w, respectively. In order to check these conditions when 
, 
 exploits the clock constraint 
 whenever 
 occurs in the current input symbol a, , and p previously occurred, and the clock constraint 
 (resp., 
) whenever p occurs in the current input symbol a, 
, 
 previously occurred, , and ∼ is ≥ (resp., ∼ is <). Thus, when the constraint η is exploited by  in the current transition, the simulating TA 
 simply checks that the past indication η is present (resp., is not present) in the current control state if 
 (resp., 
). If the check is negative, the input is rejected.
Removal of sum constraints. Now, let us consider a sum constraint

Image 14
of  where 
. We consider the case 
 (the other case being simpler). In this case, the TA 
 exploits two fresh standard clocks, namely 
 and 
, which are reset only if the proposition p (associated with the event-recording clock of η) occurs in the current input symbol. In particular,  operates in two modes which alternate each other: the η-mode and the 
-mode. Initially 
 is in the η-mode. When there is no obligation about η, the clocks 
 and 
 are reset whenever proposition p occurs in the current input position. When instead there is an obligation about η, in the η-mode (resp., 
-mode), the clock 
 (resp., 
) is reset whenever proposition p occurs, while the clock 
 (resp., 
) is never reset. Moreover, we have two types of obligations mutually exclusive: η and 
. The obligation η (resp., 
) is raised when the ECA  exploits the constraint η and the TA 
 is in the η-mode (resp., 
-mode) in order to check that the constraint 
 (resp., 
) holds at the first next position where the proposition 
 occurs. More precisely, we first consider the case where η is an upper bound constraint, i.e. . Assume that at the current input position i, 
 is in the η-mode, there are no obligations about the constraint η in the current control state of 
, and  exploits in the current transition the event-clock constraint η. If p did not occur in a previous input position, the TA 
 rejects the input. Otherwise, 
 carries the obligation η in its control state in order to check that the constraint 
 holds at the first position 
 where the proposition 
 occurs (if any). If a proposition p occurs at a position  of the input strictly preceding 
, the TA proceeds as follows:
•
 switches to the 
-phase (if j is the first position following i and preceding 
 where p occurs) and the clock 
 is reset at position j in order to handle the obligations raised at positions h of the input following or coinciding with 
. When position 
 is read, the constraint 
 is checked and the obligation η is discarded unless the constraint η is used in the current transition of . In the latter case, since the 
-mode is active,  replaces the obligation η with the new obligation 
.

•
The clock 
 is not reset at position j. Being η an upper bound constraint, if η is used by  at a position 
 strictly preceding 
, then the choice of not resetting 
 is safe: the fulfillment of the upper bound constraint η at the previous position i guarantees the fulfillment of the constraint at a position 
 such that 
.

The case where η is a lower bound constraint (i.e. ) is similar, but this time new obligations rewrite the old ones. In particular, whenever η is used by  and 
 is in the η-phase (resp., 
-phase) and 
 does not hold at the current input position, the old obligation (if any) is replaced by the new obligation η (resp., 
) in order to check that the constraint 
 (resp., 
) holds at the first next position where the proposition 
 occurs.

For ensuring that raised obligations about η are eventually checked, the accepting states of 
 do not contain such obligations. The above described construction is formally reported in Appendix B. □

4.4. Undecidability of nonemptiness of ECA++
Since the nonemptiness problem for TA is decidable, as a corollary of Theorem 6 we have that the nonemptiness problem for ECA+ is decidable as well. If we consider ECA++ we have a completely different picture since the counterpart of Theorem 6 cannot be stated for this class of automata. In fact, we show that the nonemptiness problem for ECA++ is undecidable using a reduction from the halting problem for Minsky 2-counter machines [30] similar to the one provided for the strong minimal TP problem.

Theorem 7

The nonemptiness problem of ECA++ is undecidable even for the subclass of ECA++ which use only simple atomic event-clock constraints and diagonal constraints over event clocks of opposite polarity of the form

Image 15
.
Proof

The proof is by a polynomial-time reduction from the halting problem for Minsky 2-counter machines [30]. We fix such a machine 
 and we adopt for the machine M the same notational conventions as in the proof of Theorem 2. Let  be the set of atomic propositions given by 
. We construct an ECA++ 
 over  such that 
 iff M halts.

First, we define a suitable encoding of the computations of M which is similar to the one exploited in the proof of Theorem 2. A configuration  of M is encoded by the timed word 
 over 
 of length 9 (uniquely determined modulo the initial timestamp) illustrated in the following figure.


Download : Download high-res image (29KB)
Download : Download full-size image
Note that the configuration code 
 is subdivided in two parts. In the left part (resp., right part), the encoding of counter 1 (resp., 2) precedes the encoding of counter 2 (resp., 1). The value  of counter 1 is encoded by the time distance to the next point, which is , of the counter point marked by 
 in the left part, and the counter point marked by 
 in the right part, and similarly for counter 2. The four points marked by 
, 
, 
, and 
, respectively, are called tagged points and their time distance to the next point is always 1 (tag requirement). Intuitively, they are used to check by event clock constraints that increment and decrement M-instructions are correctly encoded.
A computation 
 of M is then encoded by a timed word 
 of the form 
 such that (i) 
 is a code of configuration 
 for all , and (ii) the last timespamp of 
 coincides with the first timestamp of 
 for all . Note that 
 is uniquely determined modulo the initial timestamp.

We now illustrate the construction of the ECA++ 
 over 
 which accepts all and only the timed words over 
 which encode the computations of M starting at the initial configuration and leading to a halting configuration (hence, 
 iff M halts). The control structure and the acceptance condition of 
 capture the timed words w of the form 
 such that for each , (i) the untimed part of 
 coincides with the untimed part of some configuration code, i.e., it is of the form
 for some , (ii) the state associated with 
 is 
, and (iii) the state associated with 
 is 
. We say that each subword 
 is a pseudo-code. Moreover, in order to ensure that each pseudo-code is indeed a code of some M-configuration and 
 is faithful to the evolution of M, 
 exploits event-clock constraints as follows.

 ensures timestamp consistency of the tagged points of a pseudo-code 
 (tag requirement): i.e., the time distance from a point marked by a proposition in 
 to the next point is 1. To that purpose, when the 
-point (resp., 
-point) of the left part of 
 is read, 
 exploits in the current transition the predicting event-clock constraint

Image 16
(resp.,
Image 17
). Moreover, when the 
-point (resp., 
-point) of the right part of 
 is read, 
 exploits in the current transition the predicting event-clock constraint
Image 18
(resp.,
Image 19
).
 ensures timestamp consistency of the left part and right part of a pseudo-code 
: i.e., the time distance of the counter 
-point (resp., 
-point) to the next point coincides with the time distance of the counter 
-point (resp., 
-point) to the next point. For capturing these requirements, when the 
-point of 
 is read, 
 exploits in the current transition, together with the predicting event-clock constraint ensuring the tag requirement for 
, the event-clock constraint

Image 20
.
 ensures that the timestamp of the last point of 
 coincides with the timestamp of the first point of 
 if . When an end-point which is not associated with the halt state of M is read, 
 exploits in the current transition the predicting constraint

Image 21
.
 keeps track whether the values of counters encoded by the current pseudo-code 
 are 0 or not. When the first point (which is a 
-point) of a pseudo-code 
 is read, 
 guesses if the value of the first counter (resp., second counter) encoded by 
 is zero or not, and keeps tracks of the associated information in the control state until the first point of the next pseudo code (if any) is read. In order to check that the guess is correct, when the counter 
-point (resp., 
-point) of the right part of 
 is read, 
 exploits in the current transition the event-clock constraint

Image 22
or
Image 23
(resp.,
Image 24
or
Image 25
), depending on whether the value of the second counter (resp. first counter) is guessed to have a zero (resp., non-zero) value. In particular, 
 ensures that the first pseudo-code 
 encodes the initial configuration of M.
 ensures that the pseudo-code 
 is a code of some configuration of M which is a successor of the configuration encoded by 
. When the first point of 
 is read, 
 guesses an instruction  of M (recall that ) such that for each , if the value of counter ℓ in 
 is 0 (resp., is not 0), then  (resp., ). Moreover, 
 checks that 
 is a transition of M, where 
 (resp., 
) is the state associated with 
 (resp., 
). If the check is negative, the input is rejected. Otherwise, 
 proceeds as follows. Here, we crucially exploit the requirements on the tagged points, and the fact that the left part of 
 is preceded by the right part of 
 (in particular, the encoding of counter 1 in the left part of 
 is preceded by the encoding of counter 1 in the right part of 
). Note that we can assume that 
 is the code of some M-configuration, and we denote by 
 the value of counter  in 
.

•
 for some : 
 needs to ensure that the values of counter 1 (resp., 2) in 
 and 
 coincide. For this, 
 exploits in the transition from the first point of 
 (i.e., the counter 
-point of 
) the event-clock constraint

Image 26
.
•
 for some : 
 needs to ensure that the values of counter  in 
 and 
 coincide, and the value of counter ℓ in 
 is 
. If , then 
 exploits in the transition from the first point of 
 (the counter 
-point of 
) the event-clock constraint

Image 27
. The previous constraint (together with the tag requirements) ensures that the value of counter 1 in 
 is 
, and the sum of the counter values in 
 is 
. Similarly, if , then, 
 exploits in the transition from the first point of 
 the event-clock constraint
Image 28
.
•
 for some : 
 needs to ensure that the values of counter  in 
 and 
 coincide, and the value of counter ℓ in 
 is 
. If , then 
 exploits in the transition from the first point of 
 (the counter 
-point of 
) the event-clock constraint

Image 29
. The previous constraint (together with the tag requirements) ensures that the value of counter 1 in 
 is 
, and the sum of the counter values in 
 is 
. Similarly, if , then, 
 exploits in the transition from the first point of 
 the event-clock constraint
Image 30
.
Note that the ECA++ 
 uses only simple atomic event-clock constraints and diagonal constraints over event clocks of opposite polarity of the form

Image 31
. □
5. Decidability of the weak minimal TP problem
In this section, by exploiting the results of Section 4, we show that the weak minimal TP problem is decidable and PSPACE-complete. The upper bound is obtained by an exponential-time reduction to nonemptiness of Timed Automata (TA) [25]. In order to handle the trigger rules under the weak minimal semantics, we exploit as an intermediate step the class of ECA+, introduced and investigated in Section 4.

In the following, we fix a TP domain . We construct a TA accepting suitable encodings of the multi-timelines of SV which satisfy the rules in R under the weak minimal semantics. For each , let 
. We first define an encoding of the multi-timelines of SV by means of timed words over 
 for the set  of propositions given by 
 where for each , 
. We use the propositions in 
 to encode the tokens tk along a timeline for x: the start point and end point of tk are specified by propositions  and , respectively, where  and v is the value of tk. The meaning of the bit  is explained below. The additional proposition  is used to mark the first point of a multi-timeline code in order to check point atoms of trigger rules by ECA+ event-clock constraints. A code for a timeline for x is a timed word w over 
 of the form 
  such that for all :

•
 if ;

•
 and 
;

•
let 
 be the greatest index  such that 
 if such an index exists, and let 
 otherwise. Then, 
 if 
, and 
 otherwise.

Intuitively, for each value 
 occurring along w, the associated bit acts as a modulo 2 counter which is incremented at each visit of v along w. In the handling of the trigger rules under the weak minimal semantics, such a bit is used by ECA+ event-clock constraints to reference the end-event of a token whose start-event  is the first occurrence of  for some  after the current input position. The timed word w encodes the timeline for x of length  given by 
. Note that since the duration of a token is not zero, we have that 
 for all .

A code for a multi-timeline for SV is obtained by shuffling different timelines (one for each variable ), i.e., it is a non-empty timed word 
 over 
 such that:

•
for all , the timed word obtained from 
 by removing the pairs 
 is a code of a timeline for x;

•
, 
 for all , and 
 for all  (initialization).

Now, we show that the trigger rules in R under the weak minimal semantics can be handled by ECA+ over 
. The start and end points of the chosen non-trigger tokens are mapped to last and next occurrences of propositions in  w.r.t. the current input position (trigger) of a multi-timeline encoding, while the atoms in the rules are mapped to ECA+ event-clock constraints. Note that ECA+ cannot express trigger-less rules since the semantics of these rules does not constraint the chosen punctual events to be closest as possible to a reference event. In the following, the maximal constant 
 of  is the greatest integer occurring in the atoms of R and in the constraint functions of the variables in SV.

Lemma 2

One can construct in exponential time an ECA+ 
 over 
 such that for each multi-timeline Π of SV and encoding 
 of Π, 
 is accepted by 
 iff Π satisfies the trigger rules in R under the weak minimal semantics. Moreover, 
 has a unique state, 
 atomic event-clock constraints, and maximal constant 
, where 
 is the overall number of atoms in the trigger rules in R.

Proof

Let  be a trigger rule for SV with trigger 
. We show how to build an ECA+ 
 over 
 satisfying Lemma 2 with 
 and R replaced with 
 and , respectively. Hence, by applying the closure of ECA+ under language intersection (Theorem 4), the general result where R contains an arbitrary number of trigger rules follows.

Essentially, given the encoding 
 of a multi-timeline Π of SV, at each position i of 
 where a trigger start-event 
 of  occurs for some , the ECA+ 
 guesses an existential statement  of  and a weak minimal assignment 
 of Π w.r.t. 
 such that 
 and 
 is consistent with the bindings in the quantifiers  of  (-binding consistency), and checks by event-clock constraints that 
 satisfies the atoms in .

Fix an existential statement  of , and let  be the set of token names (existentially) quantified by . Let 
 and for each , let  be the pair state variable/value referenced by o in the associated quantifier of . A weak minimal assignment w.r.t. 
 restricted to the set of token names in 
 can be specified by a tuple  (called symbolic assignment of ), where P, C, and F are sets in 
, 
 assigns to each token name o in 
 a bit in , and the following holds:

•
The sets P, C, and F represent a partition of the set 
, i.e. 
 and P, C, and F are pairwise disjunct;

•
;

•
for each 
, if  (resp., ), then .

Given an input symbol 
, the symbolic assignment  of  is consistent with a if the following holds:

•
for all , ;

•
for all , if  for some  and , then  and .

Intuitively, given the encoding 
 of a multi-timeline Π of SV and a -trigger position i of 
 (i.e., a position where the trigger start-event 
 of  occurs for some ), a symbolic assignment  of  consistent with the current input symbol 
 encodes a weak minimal assignment 
 of Π w.r.t. 
 such that 
 and 
 is -binding consistent. Since the duration of a token is never zero (strict time monotonicity), accordingly to the weak minimal semantics, each start pair  in P (resp., in C, resp., in F) references the last previous occurrence (resp., current occurrence, resp., first next occurrence) of a start event of the form  in 
 w.r.t. position i,  (start weak minimal requirement), and the associated end pair  references the matching end event . Note that we need to ensure that the start weak minimal requirement is fulfilled, the associated events exist and the start-event  and the end-event  for a name o in 
 are associated to the same token. Additionally, for encoding the weak minimal semantics, we also need to ensure that for each start pair  in P (resp., in F), if the last previous occurrence (resp., first next occurrence) of the start event  in 
 w.r.t. position i has a time distance from the current position i greater than zero, then for each , the first next occurrence (resp., last previous occurrence) of a start event (if any) of the form  in 
 w.r.t. position i also has a time distance from i greater than zero. For checking the previous requirements, we exploit the following ECA+ event-clock constraint over 
 denoted by 
.

Image 32
Image 33
Image 34
Image 35
Image 36
Image 37
Note that in the above constraint, we exploit Boolean disjunction. The latter can be removed by using nondeterminism in the transition relation. We crucially observe that the module 2 counter used in the encoding of tokens and the above event-clock constraint also ensure that each end pair  in P (resp., in F) references the last previous occurrence (resp., first next occurrence) of the end event  in 
 w.r.t. position i.

We now associate to the symbolic assignment  an event-clock constraint over 
, denoted by , obtained from the body of the existential statement  by replacing each difference atom (resp., point atom) with the generalized atomic event-clock constraint indicated in Table 2 (resp., Table 3). Note that in the definition of such event-clock constraints, we use the Boolean constants true and false. Moreover, note that in Table 2, Table 3, we exploit generalized ECA+ atomic event-clock constraints of the form  for an interval  which correspond to a conjunction  of ECA+ atomic constraints, where  and ,  and  (if , i.e. I is unbounded, then the upper-bound conjunct is not exploited).


Table 2. Event-clock constraints for the difference atoms of  and the assignment (P,C,F,g) of .

P	C	F	ev(o2)−ev(o1)∈I
Image 38
Image 39
(o1,ev1)		(o2,ev2)	
Image 40
(o2,ev2)		(o1,ev1)	
Image 41
(o1,ev1)	(o2,ev2)		
Image 42
(o2,ev2)	(o1,ev1)	
Image 43
(o2,ev2)	(o1,ev1)		
Image 44
(o1,ev1)	(o2,ev2)	
Image 45
true if 0 ∈ I, false otherwise

Table 3. Event-clock constraints for the point atoms of  and the assignment (P,C,F,g) of .

The ECA+ 
 is then defined as follows. 
 has a unique state q and for each input symbol 
, 
 is a transition of 
 iff either (i) 
 for all  and , or (ii) 
 for some  and there exists an existential statement  of  and a symbolic assignment  of  consistent with the input symbol a such that 
. This concludes the proof of Lemma 2. □

For the trigger-less rules in R, the following result (Lemma 3) has been established in [19] for a slightly different encoding of the multi-timelines. The result can be easily adapted to the encoding proposed here.

Lemma 3

One can construct in exponential time a TA 
 over 
 accepting the codes of the multi-timelines of SV which satisfy the trigger-less rules in R. Moreover, 
 has 
 states, 
 clocks, and maximal constant 
, where 
 is the overall number of quantifiers in the trigger-less rules of R.

We can now establish the main result of this section.

Theorem 8

Given a TP domain , one can build in exponential time a TA 
 with 
 states,  clocks, and maximal constant 
, where N is the overall number of quantifiers and atoms in the rules of R, such that 
 iff there is a weak minimal plan of . Moreover, the weak minimal TP problem is PSPACE-complete.

Proof

By Theorem 6 and Lemma 2, Lemma 3, the first part of Theorem 8 concerning the construction of the  
 for the TP domain , directly follows (recall that TA are effectively and polynomial-time closed under language intersection). For the second part of Theorem 8, we recall that non-emptiness of a TA  can be solved by an NPSPACE search algorithm in the region graph of  which uses space logarithmic in the number of states of  and polynomial in the number of clocks and in the length of the encoding of the maximal constant of  [25]. Thus, since 
 can be built on the fly, and the search in the region graph of 
 can be done without explicitly constructing 
, membership in PSPACE of the weak minimal TP problem follows.

Finally, we show PSPACE-hardness of the weak minimal TP problem by a polynomial time reduction from a domino-tiling problem for grids with rows of linear length [32]. Fix an instance  of such a problem which is a tuple 
, where C is a finite set of colors, 
 is a set of tuples 
 of four colors, called domino-types,  is a natural number encoded in unary, and 
 are two distinguished domino-types (respectively, the initial and final domino-types). A grid of  is a mapping  for some . Note that each row of a grid consists of n cells and each cell contains a domino type. A tiling of  is a grid  satisfying the following additional requirements.

•
two adjacent cells in a row have the same color on the shared edge, namely, for all , 
 (row constraint);

•
two adjacent cells in a column have the same color on the shared edge, namely, for all , 
 (column constraint);

•
 (initialization) and 
 (acceptance).

Without loss of generality, we can assume that if there is a tiling of , then there is a tiling  of  satisfying the following additional requirements: the first cell of f is the unique containing 
, and the last cell of f is the unique containing 
.

It is well-known that checking the existence of a tiling of  is a PSPACE-complete problem [32]. We construct in polynomial time a TP instance 
 such that there exists a weak minimal plan of  iff there exists a tiling of . Hence, the result follows.

First, we define a suitable encoding of the tilings of  by timelines of the state variable 
. The finite domain V of the state variable 
 is given by .

We encode the row of a tiling by concatenating the codes of the row's cells starting from the first cell, and by marking the encoding with a tag which is a bit in . Each cell is in turn encoded by a token of overall duration 1 which keeps track of the associated content and position along the row. Formally, a row-code is a timeline π of 
 of length n having the form 
 such that the following holds:

•
for all , 
 (row constraint);

•
for all , 
 (cell duration requirement).

We say that  is the tag of the row-code π. A sequence ν of row-codes is well-formed if for each non-last row-code in ν with tag b, the next row-code in ν has tag  for all . Tilings f are then encoded by timelines corresponding to well-formed concatenations of the codes of the rows of f starting from the first row. The following claim is straightforward.
Claim 1

One can construct a state variable 
 such that the timelines of 
 whose first token has value 
 for some  correspond to the prefixes of well-formed concatenations of row-codes. Moreover, 
 for all , , and , and 
 for all .

We now define the set 
 of synchronization rules which under the weak minimal semantics of trigger rules captures the timelines of 
 encoding tilings of . By Claim 1 and the assumption that the first cell (resp., last cell) of a tiling is the unique containing the domino type 
 (resp., 
), in order to capture the well-formed concatenations of row-codes satisfying the initialization and halting requirements, it suffices to ensure that a timeline of 
 has a token with value 
 and a token with value 
 for some 
. This can be expressed by the trigger-less rules 
 and 
.

Finally, in order to capture the column constraint, we exploit trigger rules under the weak minimal semantics. Note that our encoding ensures that the difference 
 of the start times of two tokens tk and 
 encodings cells of the same position and belonging to two consecutive row codes is always n. Thus, by Claim 1, the column constraint can be enforced by requiring that for each token tk with value  (encoding the ith cell of a row), either (i) tk is followed by a token 
 with value 
 such that 
 (i.e., tk belongs to the last row-code), or (ii) tk is followed by a token 
 with value 
 such that 
 and 
 (column constraint). Thus, for each 
, we have the following trigger rule, where 
: 
 
  Note that for the previous trigger rules, our encoding ensures that the weak minimal semantics coincides with the standard one. This concludes the proof of Theorem 8. □

6. Conclusions
In this paper, we addressed the TP problem in the dense-time setting. First, we negatively answered the question of decidability of the TP problem with future semantics, which was left open in [18]. Then, we introduced and investigated two novel semantics in the dense-time domain (the weak and strong minimal semantics) aimed at overcoming the structural restrictions on rule formats introduced in [18] to recover decidability. Surprisingly, we showed that, despite the apparently small difference between the two semantics, the strong minimal one leads to an undecidable TP problem, while the weak minimal one leads to a PSPACE-complete TP problem. In order to solve the weak minimal TP problem, we investigated two novel and strictly more expressive extensions of ECA which are interesting per se in the field of timed automata. As for future work, the most relevant issue we want to investigate is the expressiveness comparison between the TP framework with standard semantics and the TP framework with (weak or strong) minimal semantics. We expect the two frameworks to be incomparable from the expressiveness viewpoint. In fact, since the syntax of synchronization rules does not feature negation, it is not clear how to force minimality in the standard semantics. Conversely, it is not clear how to mimics the free token name assignments of the standard semantics in the framework enforcing the minimal semantics. As for more technical issues, we will study the strong minimal TP problem when just one or two state variables are used, whose decidability remains an open issue. Moreover, we aim at investigating the TP problem in the controllability setting, where the values of some variables are not under the system control, but depend on the environment.

Appendix A. Undecidability of future TP problem
In this section we report the complete proof of Theorem 1. The result is stated by the following Proposition.

Proposition 1

Given a Minsky 2-counter machine 
, one can construct (in polynomial time) a TP instance (domain) 
 where the intervals in P are in 
 such that M halts iff there exists a future plan for P.

Proof

First, we define a suitable encoding of a computation of M as the untimed part of a timeline (i.e., neglecting tokens' durations and accounting only for their values) for 
. For this, we exploit the finite set of symbols 
 corresponding to the finite domain of the state variable 
. The set of main values 
 is the set of M-transitions, i.e. 
. The set of secondary values 
 is defined as 
, where #, beg, and end are three special symbols used as markers. Intuitively, in the encoding of an M-computation a main value keeps track of the transition used in the current step of the computation, while the set 
 is used for encoding counter values.

For , a c-code for the main value  is a finite word 
 over 
 of the form 
 for some  such that  if . The c-code 
 encodes the value for counter c given by h (or equivalently 
). Note that only the occurrences of the symbols  encode units in the value of counter c, while the symbol  (resp., ) is only used as left (resp., right) marker in the encoding.

A configuration-code w for a main value  is a finite word over V of the form 
 such that for each counter , 
 is a c-code for the main value δ. The configuration-code w encodes the M-configuration , where 
 for all . Note that if , then .

A computation-code is a non-empty sequence of configuration-codes 
, where for all , 
 is a configuration-code with main value 
, and whenever , it holds that 
. Note that by our assumptions 
 for all , and 
 for all . The computation-code π is initial if the first configuration-code 
 has the main value 
 and encodes the initial configuration, and it is halting if for the last configuration-code 
 in π, it holds that 
. For all , let 
 be the M-configuration encoded by the configuration-code 
 and 
. The computation-code π is well-formed if, additionally, for all , the following holds:

•
 if either 
 or 
 (equality requirement);

•
 if 
 (increment requirement);

•
 if 
 (decrement requirement).

Clearly, M halts iff there exists an initial and halting well-formed computation-code.

Definition of 
 and 
. We now define a state variable 
 and a set 
 of synchronization rules for 
 with intervals in 
 such that the untimed part of every future plan of 
 is an initial and halting well-formed computation-code. Thus, M halts if and only if there is a future plan of P.

Formally, variable 
 is given by 
, where for each , . Thus, we require that the duration of a token is always greater than zero (strict time monotonicity). The value transition function T of 
 ensures the following property.

Claim

The untimed parts of the timelines for 
 whose first token has value 
 correspond to the prefixes of initial computation-codes. Moreover, 
 for all .

By construction, it is a trivial task to define T so that the previous requirement is fulfilled.

Let 
. By Claim above and the assumption that 
 for each transition , in order to enforce the initialization and halting requirements, it suffices to ensure that a timeline has a token with value 
 and a token with value in 
. This is captured by the trigger-less rules 
 and 
.

Finally, the crucial well-formedness requirement is captured by the trigger rules in 
 which express punctual time constraints.3 We refer the reader to Fig. A.6, that gives an intuition on the properties enforced by the rules we are about to define. In particular, we essentially take advantage of the dense temporal domain to allow for the encoding of arbitrarily large values of counters in two time units.

Fig. A.6
Download : Download high-res image (119KB)
Download : Download full-size image
Fig. A.6. The figure shows two adjacent configuration-codes, w (highlighted in cyan) and w′ (in green), the former for 
 and the latter for δ′ = (q′,…)∈Δ; w encodes the M-configuration (q,ν) where ν(1)=ν(2)=1, and w′ the M-configuration (q′,ν′) where ν′(1)=2 and ν′(1)=1. The ‘‘1-Time distance between consecutive main values requirement’’ (represented by black lines with arrows) forces a token with a main value to be followed, after exactly one time instant, by another token with a main value. Since , the value of counter 2 does not change in this computation step, and thus the values for counter 2 encoded by w and w′ must be equal. To this aim the ‘‘equality requirement’’ (represented by blue lines with arrows) sets a one-to-one correspondence between pairs of tokens associated with counter 2 in w and w′ (more precisely, a token tk with value (δ,2,_) in w is followed by a token tk′ with value (δ′,2,_) in w′ such that 
 and 
). Finally, the ‘‘increment requirement’’ (red lines) performs the increment of counter 1 by doing something analogous to the previous case, but with a difference: the token tk′ with value (δ′,1,#) is in w′ in the place where the token tk with value (δ,1,beg) was in w (i.e., 
 and 
). The token tk″ with value (δ′,1,beg) is ‘‘anticipated’’, in such a way that 
 (this is denoted by the dashed red line): the token with main value δ′ in w′ has a shorter duration than that with value δ in w, leaving space for tk″, so as to represent the unit added by δ to counter 1. Clearly density of the time domain plays a fundamental role here. (For interpretation of the colors in the figure(s), the reader is referred to the web version of this article.)

Trigger rules for 1-Time distance between consecutive main values. We define non-simple trigger rules requiring that the overall duration of the sequence of tokens corresponding to a configuration-code amounts exactly to two time units. By Claim above, strict time monotonicity, and the halting requirement, it suffices to ensure that each token tk having a main value in 
 is eventually followed by a token 
 such that 
 has a main value and 
 (this denotes—with a little abuse of notation—that the difference of start times is exactly 1). To this aim, for each 
, we write the non-simple trigger rule with intervals in 
:
 
 Trigger rules for the equality requirement. In order to ensure the equality requirement, we exploit the fact that the end time of a token along a timeline corresponds to the start time of the next token (if any). Let 
 be the set of secondary states 
 such that 
, and either  or . Moreover, for a counter  and a tag , let 
 be the set of secondary states given by . We require the following:

(*)
each token tk with a 
-value is eventually followed by a token 
 with a 
-value such that 
 (i.e., the difference of start times is exactly 1). Moreover, if , then 
 (i.e., the difference of end times is exactly 1).

Condition (*) is captured by the following non-simple trigger rules with intervals in 
:
•
for each 
 and , 
 

•
for each 
,
 

We now show that Condition (*) together with strict time monotonicity and 1-Time distance between consecutive main values ensure the equality requirement. Let π be a timeline of 
 satisfying all the rules defined so far, 
 and 
 two adjacent configuration-codes along π with 
 preceding 
 (note that 
), and  a counter such that either  or . Let 
 (resp., 
) be the sequence of tokens associated with the c-code of 
 (resp., 
). We need to show that 
. By construction 
 and 
 have value in 
, 
 and 
 have value in 
, and for all  (resp., 
), 
 has value in 
 (resp., 
 has value in 
). Then strict time monotonicity, 1-Time distance between consecutive main values, and Condition (*) guarantee the existence of an injective mapping 
 such that 
, 
, and for all , if 
 (note that 
), then 
 (we recall that the end time of a token is equal to the start time of the next token along a timeline, if any). These properties ensure that g is surjective as well. Hence, g is a bijection and 
.

Trigger rules for the increment requirement. Let 
 be the set of secondary states 
 such that 
 and . By reasoning like in the case of the rules ensuring the equality requirement, in order to express the increment requirement, it suffices to enforce the following conditions for each counter :

(i)
each token tk with a 
-value is eventually followed by a token 
 with a 
-value such that 
 (i.e., the difference between the end time of token 
 and the start time of token tk is exactly 1);

(ii)
for each , each token tk with a 
-value is eventually followed by a token 
 with a 
-value such that 
 and 
 (i.e., the difference of start times and end times is exactly 1). Observe that the token with a 
-value is associated with a token with 
-value anyway;

(iii)
each token tk with a 
-value is eventually followed by a token 
 with a 
-value such that 
 (i.e., the difference of start times is exactly 1);

Intuitively, if w and 
 are two adjacent configuration-codes along a timeline of 
, with w preceding 
, (i) and (ii) force a token 
 with a 
-value in 
 to ‘‘take the place’’ of the token tk with 
-value in w (i.e., they have the same start and end times). Moreover a token with 
-value must immediately precede 
 in 
.
These requirements can be expressed by non-simple trigger rules with intervals in 
 similar to the ones defined for the equality requirement.

Trigger rules for the decrement requirement. For capturing the decrement requirement, it suffices to enforce the following conditions for each counter , where 
 denotes the set of secondary states 
 such that 
 and :

(i)
each token tk with a 
-value is eventually followed by a token 
 with a 
-value such that 
 (i.e., the difference between the start time of token 
 and the end time of token tk is exactly 1);

(ii)
each token tk with a 
-value is eventually followed by a token 
 with a 
-value where  such that 
 and 
 (i.e., the difference of start times and end times is exactly 1);

(iii)
each token tk with a 
-value is eventually followed by a token 
 with a 
-value such that 
 (i.e., the difference of start times is exactly 1).

Analogously, (i) and (ii) produce an effect which is symmetric w.r.t. the case of increment.
Again, these requirements can be easily expressed by non-simple trigger rules with intervals in 
 as done before for expressing the equality requirement.

By construction, the untimed part of a future plan of 
 is an initial and halting well-formed computation-code. Vice versa, by exploiting denseness of the temporal domain, the existence of an initial and halting well-formed computation-code implies the existence of a future plan of P. This concludes the proof of Proposition 1. □

Appendix B. From ECA+ to Timed Automata
Full details of the construction for Theorem 6

Theorem 6

From ECA+ to TA
Given an ECA+  over 
, one can construct in exponential time a TA 
 over 
 such that 
 and 
. Moreover, 
 has 
 states and  clocks, where n is the number of -states and p is the number of event-clock atomic constraints used by .

Proof

Let 
 be an ECA+ over 
. We now provide the formal definition of the TA 
 accepting 
 starting with some additional notation.

A past event of  is

•
either a diagonal constraint of  over event-recording clocks,

•
or a proposition  s.t. the recording clock

Image 2
occurs in some clock constraint of ,
•
or the element 
 or 
 for some sum constraint η of  which does not involve the special value ⊥.

Intuitively, a past event  indicates that proposition p occurred in some previous input position, while a past event

Image 12
indicates that the prefix w of the input read so far contains occurrences of both propositions p and 
 and in case 
, 
 holds, where 
 and 
 are the timestamps associated with the last occurrences of p and 
 in the prefix w, respectively. Finally, a past event 
 (resp., 
) for a sum constraint η denotes the η-mode (resp., 
-mode) in the handling of constraint η. A past set of  is a set P of past events such that for each sum constraint η of  which does not involve the special value ⊥, 
 iff 
. An obligation of  is
•
either a simple predicting constraint

Image 7
of ,
•
or a sum clock constraint of ,

•
or an element of the form 
 for some sum constraint η of  which does not involve the special value ⊥,

•
or an element of the form η (resp., , resp., 
), where η is a diagonal predicting constraint

Image 11
of  involving the predictor clocks
Image 3
and
Image 50
.
An obligation set of  is a set of obligations O such that: (i) for each diagonal predicting constraint

Image 11
of , it is not the case that both  and 
 are in O, and (ii) for each sum constraint η of  which does not involve the special value ⊥, it is not the case that both η and 
 are in O.
Let 
 be the finite set consisting of the following standard clocks:

•
the clock 
 for each recording clock

Image 2
which occurs in some atomic event-clock constraint of  that does not involve the special value ⊥.
•
the clock 
 for each atomic constraint η of  which does not involve the spacial value ⊥ such that either η is a simple predicting constraint, or a diagonal constraint over event-predicting clocks, or a sum constraint.

•
the clock 
 for each diagonal predicting constraint

Image 51
of .
•
the clock 
 for each sum constraint η of  which does not involve the special value ⊥.

Finally, let Ψ be the finite set consisting of the following simple atomic constraints over 
:

•
the constraint 
 for each simple recording constraint

Image 6
(resp., diagonal recording constraint
Image 8
) of  with 
;
•
the constraint 
 for each diagonal recording constraint

Image 52
of ;
•
the constraint 
 for each sum constraint

Image 14
(resp., simple predicting constraint
Image 53
, resp., diagonal predicting constraint
Image 11
) of  with 
;
•
the constraint 
 for each diagonal predicting constraint

Image 51
of ;
•
the constraint 
 for each sum constraint

Image 14
of  with 
.
The TA 
 is formally given by 
. The set 
 of states consists of the triples of the form  such that q is a state of , P is a past set of , and O is an obligation set of . The set 
 of initial states consists of the states of the form 
 such that 
 and 
 is the set of elements of the form 
 (η-mode) where η is a sum constraint of  which does not involve the value ⊥ (initially there are neither obligations nor past events associated with propositions in P and diagonal recording constraints). The set 
 of accepting states consists of the states of the form  such that  and O contains only obligations associated with atomic constraints involving the ⊥ value.

Finally, the transition relation 
 of the TA 
 is defined as follows. For each transition 
 of the ECA+ , we have in the TA 
 the transitions of the form 
, where the sets of past events P and 
, the sets of obligations O and 
, the reset set Res, and the clock constraint 
 satisfy the following requirements:

•
The clock constraint 
 has as conjuncts only simple atomic constraints in Ψ.

•
For each past event p in , (i) 
 iff either  or , and (ii) 
 iff .

•
For each simple recording clock constraint

Image 54
of :
–
if η is a conjunct of θ, then  iff 
;

–
if 
 and η is a conjunct of θ, then 
 is a conjunct of 
.

•
For each diagonal recording clock constraint

Image 12
of :
–
if η is a conjunct of θ, then  iff 
;

–
if 
, then 
 iff either  or 
;

–
if 
, then 
 iff

*
either  and 
,

*
or , 
, and 
 is a conjunct of 
,

*
or 
 and 
 holds,

*
or 
, , and either (i) ∼ is ≤, or (ii) ∼ is < and 
, or (iii) ∼ is <, 
, and 
 is a conjunct of 
, or (iv) ∼ is ≥, 
, and 
 is a conjunct of 
.

•
For each simple predicting clock constraint

Image 53
of :
–
 iff either η is a conjunct of θ, or  and ;

–
if 
, then 
 iff η is a conjunct of θ and either  or ;

–
if 
, then 
 is a conjunct of 
 iff  and ;

–
if 
, then either  or .

•
For each sum clock constraint

Image 55
:
–
 iff  and either η is a conjunct of θ, or  and 
;

–
either  or 
.

•
For each sum clock constraint

Image 56
of  such that :
–
if η occurs in θ, then ;

–
 iff , 
, and either (i) 
 and , or (ii) 
 and 
;

–
 (resp., 
) iff  and either 
 or 
 (resp., 
);

–
 (resp., 
) is a conjunct of 
 iff  (resp., 
) and 
;

–
if  (upper bound), then 
 iff  and either (i)  and 
, or (ii) η is a conjunct of θ, 
 (η-mode), and (
 implies that 
);

–
if  (upper bound), 
 iff  and either (i) 
 and 
, or (ii) η is a conjunct of θ, 
 (
-mode), and (
 implies that 
);

–
if  (lower bound), then 
 iff  and either (i) , 
, and θ is not a conjunct of θ, or (ii) η is a conjunct of θ and 
;

–
if  (lower bound), then 
 iff  and either (i) 
, 
, and θ is not a conjunct of θ, or (ii) η is a conjunct of θ and 
.

•
For each diagonal predicting clock constraint

Image 11
of :
–
 iff either η is a conjunct of θ, or  and 
;

–
 iff either (i)  and 
, or (ii) , , and 
;

–
 iff either (i) 
 and , or (ii) , 
, and ;

–
if 
, then 
 iff 
, , , and either 
 or ;

–
if 
 and ∼ is ≥, then 
 iff , 
, , and ;

–
if 
 and ∼ is <, then 
 iff , 
, and ;

–
if 
, , and 
 then 
 holds;

–
if 
, 
 and , then 
 is a conjunct of 
;

–
if 
,  and 
, then either (i) ∼ is ≤, or (ii) ∼ is < and 
, or (iii) ∼ is <, 
, and 
 is a conjunct of 
, or (iv) ∼ is ≥, 
, and 
 is a conjunct of 
;

–
if 
 and  (resp., , resp., 
), then 
 (resp., 
, resp., ).

This concludes the proof of Theorem 6. □