Abstract
Power consumption is the major cost factor in data centers. It can be reduced by dynamically right-sizing the data center according to the currently arriving jobs. If there is a long period with low load, servers can be powered down to save energy. For identical machines, the problem has already been solved optimally by Lin et al. (2013) and Albers and Quedenfeld (2018).

In this paper, we study how a data-center with heterogeneous servers can dynamically be right-sized to minimize the energy consumption. There are d different server types with various operating and switching costs. We present a deterministic online algorithm that achieves a competitive ratio of 2d as well as a randomized version that is 1.58d-competitive. Furthermore, we show that there is no deterministic online algorithm that attains a competitive ratio smaller than 2d. Hence our deterministic algorithm is optimal. In contrast to related problems like convex body chasing and convex function chasing, we investigate the discrete setting where the number of active servers must be integral, so we gain truly feasible solutions.

Keywords
Heterogeneous machines
Online algorithm
Lower bound
Discrete setting

1. Introduction
Energy management is an important issue in data centers. A huge amount of a data center's financial budget is spent on electricity that is needed to operate the servers as well as to cool them [1], [2]. However, server utilization is typically low. In fact there are data centers where the average server utilization is as low as 12% [3]; only for a few days a year is full processing power needed. Unfortunately, idle servers still consume about half of their peak power [4]. Therefore, right-sizing a data center by powering down idle servers can save a significant amount of energy. However, shutting down a server and powering it up immediately afterwards incurs much more cost than holding the server in the active state during this time period. The cost for powering up and down does not only contain the increased energy consumption but also, for example, wear-and-tear costs or the risk that the server does not work properly after restarting [5]. Consequently, algorithms are needed that manage the number of active servers to minimize the total cost, without knowing when new jobs will arrive in the future. Since about 3% of the global electricity production is consumed by data centers [6], a reduction of their energy consumption can also decrease greenhouse emissions. Thus, right-sizing data centers is not only important for economical but also for ecological reasons.

Modern data centers usually contain heterogeneous servers. If the capacity of a data center is no longer sufficient, it is extended by including new servers. The old servers are still used however. Hence, there are different server types with various operating and switching costs in a data center. Heterogeneous data centers may also include different processing architectures. There can be servers that use GPUs to perform massive parallel calculations. However, GPUs are not suitable for all jobs. For example, tasks with many branches can be computed much faster on common CPUs than on GPUs [7].

Problem formulation We consider a data center with d different server types. There are 
 servers of type j. Each server has an active state where it is able to process jobs, and an inactive state where no energy is consumed. Powering up a server of type j (i.e., switching from the inactive into the active state) incurs a cost of 
 (called switching cost); powering down does not cost anything. We consider a finite time horizon consisting of the time slots . For each time slot , jobs of total volume 
 arrive and have to be processed during the time slot. In practice, the job volume might be predicted from history or it is assumed that the jobs arriving during a time slot have to be finished in the next time slot. In our model, all servers have the same computational power and can process a job volume of 1 per time slot. Hence, there must be at least 
 active servers at time t to process the arriving jobs. We consider a basic setting where the operating cost of a server of type j is load- and time-independent and denoted by 
. Hence, an active server incurs a constant but type-dependent operating cost per time slot.

A schedule X is a sequence 
 with 
 where each 
 indicates the number of active servers of type j during time slot t. At the beginning and the end of the considered time horizon all servers are shut down, i.e., 
. A schedule is called feasible if there are enough active servers to process the arriving jobs and if there are not more active servers than available, i.e., 
 and 
 for all  and . The cost of a feasible schedule is defined by(1)≔
 
 
 
 where 
≔. The switching cost is only paid for powering up. However, this is not a restriction, since all servers are inactive at the beginning and end of the workload. Thus the cost of powering down can be folded into the cost of powering up. A problem instance is specified by the tuple  where 
, 
, 
 and 
. The task is to find a schedule with minimum cost.

We focus on the central case without inefficient server types. A server type j is called inefficient if there is another server type 
 with both smaller (or equal) operating and switching costs, i.e., 
 and 
. This assumption is natural because a better server type with a lower operating cost usually has a higher switching cost. An inefficient server of type j is only powered up, if all servers of all types 
 with 
 and 
 are already running. Therefore, excluding inefficient servers is not a relevant restriction in practice. In related work, Augustine et al. [8] exclude inefficient states when operating a single server.

Our contribution We analyze the online setting of this problem where the job volumes 
 arrive one-by-one. The vector of the active servers 
 has to be determined without knowledge of future jobs 
 with 
 and the input length T. A main contribution of our work, compared to previous results, is that we investigate heterogeneous data centers and examine the online setting when truly feasible (integral) solutions are sought.

In Section 2, we present a 2d-competitive deterministic online algorithm, i.e., the total cost of the schedule calculated by our algorithm is at most 2d times larger than the cost of an optimal offline solution. Roughly, our algorithm works as follows. It calculates an optimal schedule for the jobs received so far and ensures that the operating cost of the active servers is at most as large as the operating cost of the active servers in the optimal schedule. If this is not the case, servers with high operating cost are replaced by servers with low operating cost. If a server is not used for a specific duration depending on its switching and operating costs, it is shut down.

In Section 3, we devise a randomized version of our algorithm achieving a competitive ratio of 
 
 against an oblivious adversary.

In Section 4, we show that there is no deterministic online algorithm that achieves a competitive ratio smaller than 2d. Therefore, our algorithm is optimal. Additionally, for a data center that contains m unique servers (that is 
 for all ), we show that the best achievable competitive ratio is 2m.

Related work The design of energy-efficient algorithms has received quite some research interest over the last years, see e.g. [9], [10], [11] and references therein. Specifically, data center right-sizing has attracted considerable attention lately. Lin and Wierman [12], [5] analyzed the data-center right-sizing problem for data centers with identical servers (). The operating cost is load-dependent and modeled by a convex function. In contrast to our setting, continuous solutions are allowed, i.e., the number of active server 
 can be fractional. This allows for other techniques in the design and analysis of an algorithm, but the created schedules cannot be used directly in practice. They gave a 3-competitive deterministic online algorithm for this problem. Bansal et al. [13] improved this result by randomization and developed a 2-competitive online algorithm. In our previous paper [14], we showed that 2 is a lower bound for randomized algorithms in the continuous setting; this result was independently shown by [15]. Furthermore, we analyzed the discrete setting of the problem where the number of active servers is integral (
). We presented a 3-competitive deterministic and a 2-competitive randomized online algorithm. Moreover, we proved that these competitive ratios are optimal.

Data-center right-sizing of heterogeneous data centers is related to convex function chasing, which is also known as smoothed online convex optimization [16]. At each time slot t, a convex function 
 arrives. The algorithm then has to choose a point 
 and pay the cost 
 as well as the movement cost 
 where  is any metric. The problem described by equation (1) is a special case of convex function chasing if fractional schedules are allowed, i.e., 
 instead of 
. The operating cost 
 in equation (1) together with the feasibility requirements can be modeled as a convex function that is infinite for 
 and 
. The switching cost equals the Manhattan metric if the number of servers is scaled appropriately. Sellke [17] gave a -competitive algorithm for convex function chasing. A similar result was found by Argue et al. [18].

In the discrete setting, convex function chasing has at least an exponential competitive ratio, as the following setting shows. Let 
 and 
 for all , so the possible server configurations are 
. The arriving convex functions 
 are infinite for the current position 
 of the online algorithm and 0 for all other positions 
. After ≔
 functions arrived, the switching cost paid by the algorithm is at least 
 (otherwise it has to pay infinite operating costs), whereas the offline schedule can go directly to a position without any operating cost and only pays a switching cost of at most d. Formally, the offline schedule chooses any position in 
 which contains at least one element since 
.

Already for the 1-dimensional case (i.e. identical machines), it is not trivial to round a fractional schedule without increasing the competitive ratio (see [5] and [19]). In d-dimensional space, it is completely unclear, if continuous solutions can be rounded without arbitrarily increasing the total cost. Simply rounding up can lead to arbitrarily large switching costs, for example if the fractional solution rapidly switches between 1 and . Using a randomized rounding scheme like in [19] (that was used for homogeneous data centers) independently for each dimension can result in an infeasible schedule (for example, if 
 and 
 is rounded down to ). Therefore, Sellke's result does not help us for analyzing the discrete setting. Other publications handling convex function chasing or convex body chasing are [20], [21], [22].

Goel and Wierman [23] developed a -competitive algorithm called Online Balanced Descent (OBD) for convex function chasing, where the arriving functions were required to be μ-strongly convex. A function f is called μ-strongly convex with , if 
 holds for all 
. We remark that the operating cost 
  defined by equation (1) is not strongly convex, i.e., . Hence their result cannot be used for our problem. A similar result is given by Chen et al. [16] who showed that OBD is -competitive if the arriving functions are locally α-polyhedral. In our case, 
, so α can be arbitrarily small depending on the problem instance.

The discrete data-center right-sizing problem is a special case of metrical task systems. A metrical task system is defined by a finite set of states S and a metric distance function 
. For each time slot, a cost function 
 arrives and the online algorithm has to choose a state 
 causing a cost of 
. Borodin et al. [24] developed a -competitive deterministic online algorithm and showed that no deterministic algorithm can achieve a better competitive ratio for general metrical task systems. In our case, ≔
 is set of all possible server configurations and δ is the Manhattan metric. If there are d unique servers, the general algorithm of Borodin et al. only achieves an exponential competitive ratio of 
.

Another similar problem is the Parking Permit Problem by Meyerson [25]. There are d different permits which can be purchased for 
 dollars and have a duration of 
 days. Certain days are driving days where at least one parking permit is needed (
). The permit cost corresponds to our switching cost. However, the duration of the permit is fixed to 
, whereas in our problem the online algorithm can choose for each time slot if it wants to power down a server. Furthermore, there is no operating cost. Even if each server type is replaced by an infinite number of permits with the duration t and the cost 
, it is still a different problem, because the algorithm has to choose the time slot for powering down in advance (when the server is powered up).

Data-center right-sizing of heterogeneous data centers is related to geographical load balancing analyzed in [26] and [27]. Other applications are shown in [28], [29], [30], [31], [32], [33], [34].

Notation

Let ≔, 
≔ and ≔ where 
.

2. Deterministic online algorithm
In this section we present a deterministic 2d-competitive online algorithm for the problem described in the preceding section. The basic idea of our algorithm is to calculate an optimal schedule for the problem instance that ends at the current time slot. Based on this schedule, we decide when a server is powered up. If a server is idle for a specific time, it is powered down.

Formally, given the original problem instance , the shortened problem instance 
 is defined by 
≔
 with 
. Let 
 denote an optimal schedule for 
 and let 
 be the schedule calculated by our algorithm .

W.l.o.g. there are no server types with the same operating and switching costs, i.e., 
 and 
 implies 
. Furthermore, let 
, i.e., the server types are sorted by their operating costs. Since inefficient server types are excluded, this implies that 
.

We separate a problem instance into ≔
 lanes. At time slot t, there is a single job in lane , if and only if 
. We can assume that 
 holds for all , because otherwise there is no feasible schedule for the problem instance. Let X be an arbitrary feasible schedule with 
. We define(2)
≔ 
  to be the server type that handles the k-th lane during time slot t (see Fig. 1).

Fig. 1
Download : Download high-res image (69KB)
Download : Download full-size image
Fig. 1. Example of a job sequence (upper plot) and a feasible schedule X written in both notations xt,j (middle) and yt,k (lower plot). Outside of the rectangles in the lower plot, the value of yt,k is 0.

If 
, then there is no active server in lane k at time slot t. By definition, the values 
 are sorted in descending order, i.e., 
 for 
. Note that 
 implies 
, because otherwise there are not enough active servers to handle the jobs at time t. For the schedule 
, the server type used in lane k at time slot 
 is denoted by 
. Our algorithm calculates 
 directly, the corresponding variables 
 can be determined by 
. A tabular overview of the notation is shown in Appendix A.

Our algorithm works as follows: First, an optimal solution 
 is calculated. If there are several optimal schedules, we choose a schedule that fulfills the inequality 
 for all time slots 
 and lanes , so 
 never uses smaller server types than the previous schedule 
. We will see in Lemma 5 that such a schedule exists and how to construct it.

If there is a server type j with 
, then in an optimal schedule such a server can be powered up before it is needed, although 
 holds for this time slot. Similarly, such a server can run for more time slots than necessary. W.l.o.g. let 
 be a schedule where servers are powered up as late as possible and powered down as early as possible.

Beginning from the lowest lane (), it is ensured that  uses a server type that is not smaller than the server type used by 
, i.e., 
 must be fulfilled. If the server type 
 used in the previous time slot is smaller than 
, it is powered down and server type 
 is powered up. A server of type j that is not replaced by a greater server type stays active for 
≔
 time slots. If 
 uses a smaller server type 
 in the meantime, then server type j will run for at least 
 further time slots (including time slot t). Formally, a server of type j in lane k is powered down at time slot t, if 
 holds for all server types 
 and time slots 
.

The pseudocode below clarifies how algorithm  works. The variables 
 for  store the time slot when the server in the corresponding lane will be powered down. Fig. 2 visualizes how the schedule 
 changes from time slot  to t.

Fig. 2
Download : Download high-res image (35KB)
Download : Download full-size image
Fig. 2. (Figure is colored.) Example of an update in algorithm  from time slot t − 1 to t. The schedule of  (upper plot) at t − 1 is shown in blue, the changes after reacting to λt are printed in green. The optimal schedule 
 is shown in the lower plot in red. Let 
≔. In the lowest lane k = 1, we have 
, so server type 
 will run for at least 
 further time slots (including the current time slot t), i.e., 
 will be powered down after time slot t + 4. In lane k = 2, server type 
 is powered down (because 
) and replaced by 
. In lane k = 3, Algorithm  has no active server during time slot t − 1, so server type 
 is powered up.

The optimal schedule 
 can be calculated by dynamic programming in 
 time. A polynomial-time algorithm based on a minimum-cost flow computation is presented in [35].

Structure of optimal schedules Before we can analyze the competitiveness of algorithm , we have to show that an optimal schedule with the desired properties required by line 3 actually exists. First, we will investigate basic properties of optimal schedules. The following lemma shows that in an optimal schedule, a server of type j that runs in lane k does not change the lane while being active.

Lemma 1 No lane switching

Let 
 be an optimal schedule. If 
 and 
, then there exists no other lane 
 with 
 and 
.


Algorithm 1
Download : Download high-res image (70KB)
Download : Download full-size image
Algorithm 1. Algorithm .

Proof

Let 
 and 
. To get a contradiction, assume that there exists a lane 
 with 
 and 
. We differentiate between the cases (1) 
 and (2) 
. In case 1, the server type 
 must be greater than j, since the server types are sorted. Furthermore, at time slot  there are at least 
 active servers whose types are greater than j, and at time slot t there are at most 
 active servers whose types are greater than j. Therefore a server of type 
 is powered down after . Let 
 be the first time slot where 
 (if no such 
 exists, then let ≔). By replacing one server of type j during the time slots 
 by 
 (i.e., 
 is not powered down at t, but instead at 
), we reduce the operating cost without increasing the switching cost. Therefore, 
 cannot be an optimal schedule.

Case 2 works analogously: we have 
, so the server type 
 must be greater than j. At time slot  there are at most  active servers whose types are greater than j, and at time slot t there are at least k active servers whose types are greater than j. Therefore a server of type 
 is powered up after . Let 
 be the last time slot where 
. We replace server type j during 
 by 
. The operating cost is decreased while the switching cost stays the same, so 
 cannot be an optimal schedule. Therefore, a lane 
 with 
 and 
 cannot exist. □

The next lemma shows that in an optimal schedule, a server is only powered up or powered down if the number of jobs is increased or decreased, respectively. To simplify the notation,
≔ 
  indicates whether an active server is needed in lane k at time t, i.e., 
 implies 
 for any feasible schedule.

Lemma 2

Let 
 be an optimal schedule. If 
 and 
, then 
 and 
. Analogously, 
 and 
 implies 
 and 
.

Proof

Let 
 and 
. By Lemma 1, we know that a server of type ≔
 is powered down after time slot . There cannot be a job in lane k at time t, because there is no active server in 
, so 
. Assume that there is no job for the previous time slot, i.e., 
. Then we get a better schedule by powering down the server in lane k one time slot earlier (i.e., after time slot ), because the operating cost is reduced by 
, so 
 would not be optimal. Therefore, 
 must hold. For 
 and 
 the proof works analogously. □

The following lemma shows that in an optimal schedule in a given lane k, the server type does not change immediately, i.e., there must be at least one time slot, where no server is running in lane k.

Lemma 3 No immediate server changes

Let 
 be an optimal schedule. If 
 and 
, then 
 holds.

Proof

Assume that this lemma does not hold. Let t be the first time slot and k the lowest lane during this time slot where 
 and 
, but 
. To simplify the notation, let ≔
 and 
≔
. We differentiate between the cases (1) 
 and (2) 
. In case 1, let 
 be the last time slot where the server type j in lane k was powered up. By replacing server type j by 
 during 
, we reduce the operating cost without increasing the switching cost. If this violates the condition 
, we instead choose the last time slot 
 where 
 is powered down. By replacing j with 
 during 
 we reduce the operating cost and save the cost for powering up server type 
. It can happen that j has to be powered up one more time, however, the switching cost of 
 is smaller than the switching cost of j, so the total switching cost is reduced. Case 2 works analogously. We have shown that the total cost can be decreased, so 
 would not be an optimal schedule. Therefore, the lemma must hold. □

Given the optimal schedules 
 and 
 with , we construct a minimum schedule 
 with 
≔
. Note that  does not denote the minimum of u and v (which would be written as  in this paper), but  is a special symbol for the minimum schedule.

Furthermore, we construct a maximum schedule 
 as follows. Let 
 be the last time slot 
 with 
 (no active servers in both schedules) and let 
 be the first time slot 
 with 
. The schedule 
 is defined by(3)
≔ 
 
 Another way to construct 
 is as follows. First, we take the maximum of both schedules (analogously to 
). However, this can lead to situations where the server type changes immediately, so the necessary condition of Lemma 3 for optimal schedules would not be fulfilled. Therefore, we replace the lower server type by the greater one until there are no more immediate server changes. This construction is equivalent to equation (3). An example of the construction of 
 and 
 can be found in Fig. 3 (at this point, just ignore the colors and arrows in the figure).

Fig. 3
Download : Download high-res image (48KB)
Download : Download full-size image
Fig. 3. (Figure is colored.) Visualization of the proof of Lemma 5. The number inside each block refers to the used server type. The blocks of the sets 
 and 
 are marked in blue and green, respectively. Block Bmax, which contains the largest server type, is drawn in red. Note that the third block 
 in Xmin is mapped to the second block 
 in 
, but it uses the server type 
 instead of 
. However, since β7 < β9, the switching cost of 
 is smaller than the switching cost of the assigned block 
.

We will see in Lemma 5 that the maximum schedule is an optimal schedule for 
 and fulfills the property required by algorithm  in line 3, which says that the server type used in lane k at time t never decreases when the considered problem instance is expanded. To prove this property, first we have to show that 
 and 
 are feasible schedules for the problem instances 
 and 
, respectively.

Lemma 4

 and 
 are feasible for 
 and 
, respectively.

Proof

(a)
Feasibility of 

First, we will show that the demand requirements are fulfilled, so for all  and , there must be an active server in lane k at time t, if 
. Since 
 and 
 are feasible schedules, 
 and 
 holds for all  and . Thus, 
 holds.

Second, we have to check if there are not more active servers in 
 than available, i.e. 
 for all  and . Assume that this is not the case, so there exists a time slot t and a server type j with 
. Since the server types of 
 and 
 are sorted, the server types of 
 are sorted too. Thus, there must be at least 
 consecutive lanes with 
. Let 
 be the topmost and 
 be the lowermost lane with 
. W.l.o.g. let 
 (the case 
 works analogously), so 
. It is not possible that 
, because then there would be 
 active servers of type j in 
. On the other hand, 
 implies that 
, since the server types are sorted, so there would be at least 
 active servers of type j in 
. Thus, our assumption was wrong and 
 is a feasible schedule for 
.

(b)
Feasibility of 

Consider the schedule 
 with 
≔
 (similar to 
, but without eliminating immediate server changes). Analogous to part (a), it can be shown that 
 is a feasible schedule for 
. Furthermore, we observe that the server types of 
 are sorted for a given time slot, since the server types of 
 and 
 are sorted. Taking the maximum preserves this order.

The schedule 
 fulfills the demand requirements of 
, because 
 implies 
.

Assume that there are more active servers in 
 than available, i.e., there exists a time slot  and a server type  with 
. Let 
 be the topmost lane with 
. There must be a time slot 
 such that 
 and 
 for all 
 between t and 
 (i.e., 
), because otherwise 
 cannot be fulfilled. Let 
 be the lowest lane with 
. Since the server types in 
 are sorted and since 
 is a feasible schedule, 
 holds, because 
 would imply that 
 uses server type j in all lanes 
, but 
. However, for all 
 between t and 
 we have 
, since there is an active server in the higher lane 
, so 
 which is a contradiction to our assumption. Therefore, 
 is a feasible schedule for 
. □

Now, we are able to show that the maximum schedule is optimal for the problem instance 
.

Lemma 5

Let  with . 
 is optimal for 
.

Proof

To simplify the notation, let 
≔
 and 
≔
. Analogously to the previous notation, we use 
 and 
 to denote the server types used in 
 and 
. Since 
 and 
 are optimal schedules for 
 and 
, respectively, we know from Lemma 4 that 
 and 
. In the following we will show that 
 which implies that 
 must be an optimal schedule for 
 and 
 must be an optimal schedule for 
. First, we compare the operating cost and afterwards the switching cost of the schedules.

The operating costs of 
 and 
 in lane k at time slot t are(4)
 with 
≔ (if , then there is no active server, so the operating cost for this time slot is zero). Note that 
 by definition of 
 and 
 because 
.

Inequality (4) indicates that the sum of the operating costs of 
 and 
 are smaller than or equal to the sum of the operating costs of 
 and 
. In the following we will show that the same holds for the switching costs.

Each lane k in the schedule 
 is divided into blocks such that at the beginning of a block a server is powered up and at the end of the block it is powered down. In the following we consider one single block. Let j denote the server type used in that block and let a and b denote the start and end time slot, respectively. Note that in the time slot immediately before the begin and after the end of the block in both 
 and 
 there is no active server, i.e. 
 and 
. For , there is always an active server in at least one of the schedules.

For the time interval  we divide lane k of the schedules 
, 
 and 
 into blocks 
 with  such that at the beginning of the block a server is powered up and at the end of the block it is powered down. Let 
 denote the server type used in block 
 with  and 
.

In 
 or 
 (or both) there must be one block 
 with 
 where  (if there are several blocks that fulfill this property, then we choose an arbitrary one). Let 
 denote the start time slot of 
. Let 
 be the blocks in 
 and 
 that start before 
 and let 
 be the blocks that start after 
. Note that 
 is a partition of 
.

Each block 
 which starts before 
 is mapped to the block in 
 which has the same end time slot. There must be a block 
 which starts at 
. This block is mapped to the last block in 
 (which cannot end before 
, so it was not mapped yet). Each block 
 which starts after 
 is mapped to the block in 
 which has the same start time slot. The mapping procedure is visualized in Fig. 3. It ensures that all blocks 
 with 
 are mapped to a block of 
 or 
, but not to the block 
. Since 
 uses the smaller server type of 
 and 
, the switching cost of 
 is smaller than or equal to the switching cost of the mapped block 
 with .

Let  denote the switching cost of block B. The switching costs of 
 and 
 in lane k during the time interval  are equal to 
. The switching cost of 
 in lane k during  is at most 
 and the switching cost of 
 is exactly 
, because 
 only consists of one single block. By using this result for all blocks of 
 and with equation (4), we get 
 which implies that 
 must be an optimal schedule for 
. □

Feasibility In the following, let 
 be optimal schedules that fulfill the inequality 
 for all 
 and  as required by algorithm . Lemma 5 ensures that such a schedule sequence exists (and also shows how to construct it). Before we can prove that algorithm  is 2d-competitive, we have to show that the computed schedule 
 is feasible.

The following lemma shows that the running times 
 are sorted in ascending order, i.e., 
. In other words, the higher the server type is, the longer it stays in the active state.

Lemma 6

For 
, it holds that 
.

Proof

Since 
, we have 
 and 
, so 
. □

In an optimal schedule 
, the values 
 are sorted in descending order by definition. This also holds for the schedule calculated by our algorithm.

Lemma 7

For all time slots , the values 
 are sorted in descending order, i.e., 
 for 
.

Proof

Assume that Lemma 7 does not hold. Let t be the first time slot with 
. If 
 is powered up at time t, then 
 holds. By the definition of algorithm , the server types used during a given time slot are greater than or equal to the server types used by 
, so 
. The server types in 
 are sorted, so we get 
 which contradicts our assumption.

If 
 is already running at time t, we consider the time slot 
 when the value of 
 has changed for the last time. Formally, let 
 be the last time slot such that 
. We have 
, so by Lemma 6, 
 runs at least as long as 
. Therefore, the fact 
 implies 
 which is a contradiction to our assumption. □

Now, we are able to prove the feasibility of 
.

Lemma 8

The schedule 
 is feasible.

Proof

A schedule is feasible, if (1) there are enough active servers to handle the incoming jobs (i.e., 
) and (2) there are not more active servers than available (i.e., 
).

(1)
By the definition of algorithm , the server types used during a given time slot are greater than or equal to the server types used by 
, so there are at least as many active servers as in 
. Therefore, 
 holds for all .

(2)
Assume that there exist  and  such that 
. Let t be the first time slot where algorithm  wants to use server type j in lane k, although it is used already 
 times in the lower lanes during the same time slot. Let K be the set of lanes where j is already used, i.e., 
 for all 
. We differentiate between case 1 where 
 is set in line 6 and case 2 where 
 is set in line 9.

In the first case (
 is set in line 6), we know that 
 uses j in lane k. Since the server types of 
 are sorted, the server types of 
 in the lower lanes cannot be smaller than k. Formally, we have 
 for all 
. In the lanes where  uses server type j, the optimal schedule 
 cannot use a greater server type. Thus, there are exactly 
 lanes below lane k where 
 holds, so 
 cannot use j in lane k.

In the second case (
 is set in line 9), we know that 
, but 
, so there must be a lane 
 with 
 by Lemma 7. We consider the time slot 
 when the value of 
 has changed for the last time. Formally, let 
 be the last time slot such that 
. We know that 
, because 
 cannot be powered up during 
 and powered down at t, as 
 implies 
. Since 
 holds, the running time of 
 in lane 
 was extended at time slot 
, so it still runs during time slot t. This is a contradiction to 
.  □

Competitiveness To show the competitiveness of , we divide the schedule 
 into blocks 
 with  and . Each block 
 is described by its creation time t, its start time 
, its end time 
, the used server type 
 and the corresponding lane k. The start time is the time slot when 
 is powered up and the end time is the first time slot, when 
 is inactive, i.e., during the time interval 
 the server of type 
 is in the active state.

There are two types of blocks: new blocks and extended blocks. A new block starts when a new server is powered up, i.e., lines 6 and 7 of algorithm  are executed because 
 or 
 (in words: the previous block ends and 
 has an active server in lane k, but the server type is smaller than the server type used by  in the previous time slot). The block ends after 
 time slots. Thus 
≔ and 
≔
 (i.e., 
 equals 
 after executing line 7).

An extended block is created when the running time of a server is extended, i.e., the value of 
 is updated, but the server type remains the same (that is 
). We have 
≔
 (i.e., the value of 
 after executing line 10 or 7) and 
≔
, where 
 is the previous block in the same lane. Note that an extended block can be created not only in line 10, but also in line 7, if 
 and 
. If line 9 and 10 are executed, but the value of 
 does not change (because 
 is smaller than or equal to the previous value of 
), then the block 
 does not exist. Fig. 4 visualizes the definition of 
.

Fig. 4
Download : Download high-res image (70KB)
Download : Download full-size image
Fig. 4. (Figure is colored.) Visualization of the definition of the blocks At,k for one specific lane k. The first line shows the values of 
 for t ∈ [0:18] and the second line the resulting schedule of algorithm . In this example, we have 
. The blocks At,k are printed as rectangles that show the start and end time st,k and et,k, e.g., s4,k = 5 and e4,k = 7 (note that the server is in the active state during [st,k:et,k − 1]). The dashed line after A1,k indicates that e1,k = 3, since the block is interrupted by A2,k. New blocks are drawn in green and extended blocks are drawn in blue. The arrows indicate the creation time t of a block. The used server type jt,k is equal to 
. Blocks that are not printed do not exist, e.g., A3,k does not exist, because 
, so ek is not updated at t = 3.

Let 
≔
 be the duration of the block 
 and let 
 be the cost caused by 
 if the block 
 exists or 0 otherwise. The next lemma describes how the cost of a block can be estimated.

Lemma 9

The cost of the block 
 is upper bounded by(5)
 

Proof

If 
 is a new block, its length is 
 with 
. Therefore the total cost of 
 is 
. If 
 is an extended block, then the server 
 is already running, so there is no switching cost and 
. □

To show the competitiveness of algorithm , we introduce another variable that will be used in Lemma 11, Lemma 12. Let
≔ 
 
 be the largest server type used in lane k by the schedule 
 at time slot 
 for 
. The next lemma shows that 
 is monotonically decreasing with respect to t as well as k and increasing with respect to u.

Lemma 10

Let 
, 
 and 
. It holds that 
.

Proof

First, we analyze the special cases where two inequalities are fulfilled with equality.

1.
If 
 and 
 holds, then we have(6)
 
 

2.
Let 
 and 
. By using the definition of 
, we get(7)
 
 
 since 
.

3.
If 
 and 
, then we can use the fact that the server types of 
 at time slot 
 are sorted, i.e., 
 holds for all 
 and 
. Therefore,(8)
 
 

By combining the inequalities (6), (7) and (8), we get
 □

The cost of schedule X in lane k during time slot t is denoted by(9)
≔
  The total cost of X can be written as 
. The technical lemma below will be needed for our induction proof in Theorem 13. Given the optimal schedules 
 and 
 with , the inequality 
 is obviously fulfilled (because 
 is an optimal schedule for 
, so 
 cannot be better). The lemma below shows that this inequality still holds if the cost 
 is scaled by 
.

Lemma 11

Let  with . It holds that(10)
 
 
 
 

Proof

For , let
≔ 
  such that 
. In other words, 
 means that the largest server type in the sequence 
 is at least j.

To deduce a contradiction, we assume that there exists a  such that(11)
 
 
 
 
 We consider the schedule 
 which is constructed in two steps. First, we insert the schedule 
 for all lanes k and time slots t where 
 holds into 
. Afterwards, we eliminate immediate server changes after 
 switches from 1 to 0 by using the greater server type (equivalent to the construction of the maximum schedule). By Lemma 10, 
 implies 
 for all , 
 and 
, so if 
 uses the schedule 
 for a given time slot t and lane k, then it also uses 
 for the previous time slots 
 and lanes 
.

The schedule 
 is feasible for 
, because for a given time slot t and lane k, the server type used by 
 is greater than or equal to the server type used by 
, so in 
 there cannot be more active servers than available. Furthermore the demand requirements are obviously fulfilled.

The total cost of 
 is
 
 
 
 
 
 
 
 
 
 
 
 
 In the first step, we simply split 
 into two parts (note that 
). The first inequality uses the definition of 
: for 
, we have 
 and for 
, we have 
, because 
 can use servers of larger types with lower operating costs than 
 due to the elimination of immediate server changes. The last inequality uses our assumption given by inequality (11).

We have shown that 
, however, this is a contradiction to the fact that 
 is an optimal schedule. Therefore, our assumption was wrong and for all ,
 
 
 
 
 holds. By summing up these inequalities for all  and by using the fact 
, we get
 
 
 
 
 □

The next lemma shows how the cost of a single block 
 can be folded into the term 
 which is the right hand side of inequality (10) given in the previous lemma with .

Lemma 12

For all lanes  and time slots , it is(12)
 
 

Proof

If the block 
 does not exist, inequality (12) holds by Lemma 10 and 
.

If 
 is a new block, then 
 with ≔
 by Lemma 9. Since 
 is a new block, server type j was not used in the last time slot of the last 
 schedules, i.e., 
 for 
. If 
 would hold, then 
 and there would be an extended block at time slot v. By using the facts above and the definition of 
, for 
, we get(13)
 
 
 By using Lemma 10 and inequality (13), we can estimate the first sum in (12):(14)
 
 
 
 
 For the second inequality, we add 
 and use 
 which holds because either a server of type j was powered up in 
 during 
 (then there is the switching cost of 
) or a server of type j runs for 
 time slots resulting in an operating cost of 
.

Recall that we want to prove inequality (12). We begin from the left hand side, use inequality (14) as well as Lemma 9 and get
 
 
 

If 
 is an extended block, then 
 with ≔
 and ≔
 by Lemma 9. Let 
≔
 be the server type in 
 that provoked the extended block. For each , 
 holds, because otherwise the duration of 
 would be smaller than d. Analogously to new blocks, inequality (13) holds for all . The first sum of inequality (12) is at most(15)
 
 
 
 
 
 
 

The last term in (15) satisfies(16)
 
 because either 
 runs for d time slots in 
 during  (then the operating cost is exactly 
) or 
 was powered up during this interval resulting in a cost of
 
 as the duration d of block 
 is upper bounded by 
.

Altogether, we get
 
 
 
 
 The last inequality holds, because 
 implies 
. □

Theorem 13

Algorithm  is 2d-competitive.

Proof

The feasibility of 
 was already proven in Lemma 8, so we have to show that 
. Let 
≔
 denote the cost of algorithm  up to time slot v. We will show by induction that(17)
 
 
 holds for all 
.

For , we have no costs for both 
 and 
, so inequality (17) is fulfilled. Assume that inequality (17) holds for . By using the induction hypothesis as well as Lemma 11, Lemma 12, we get(18)
 
 
 
 
 
 
 Since 
, we get
 
 
 
 
 The schedule 
 is optimal for the problem instance , so algorithm  is 2d-competitive. □

3. Randomized online algorithm
The 2d-competitive algorithm can be randomized to achieve a competitive ratio of 
 
 against an oblivious adversary. The randomized algorithm  chooses  according to the probability density function 
 for . The variables 
 are set to 
, so the running time of a server is randomized. Then, algorithm  is executed. Note that γ is determined at the beginning of the algorithm and not for each block. The density function 
 ensures that the expected cost of a block 
 is minimized. The pseudocode below summarizes how algorithm  works.


Algorithm 2
Download : Download high-res image (23KB)
Download : Download full-size image
Algorithm 2. Algorithm .

Lemma 1, Lemma 8 as well as 10 and 11 still hold, because they do not depend on the exact value of 
. Only Lemma 9, Lemma 12 have to be adapted. First of all, we have to introduce a new variable. Let
≔
 be the number of time slots we have to go backwards in time to find an optimal schedule 
 that uses a server type greater than or equal to 
 in its last time slot in lane k. The following lemma replaces Lemma 9 and estimates the expected cost of the block 
 depending on 
.

Lemma 14

Let , ≔
 and ≔
 The expected cost of the block 
 is upper bounded by 
.

Proof

Let ≔
 
 (note that both j and τ do not depend on random decisions). We estimate the cost of 
 depending on γ.

If , then the server 
 is still running at time slot t, since 
 implies
 Therefore, 
 is an extended block with duration at most τ (or 
 does not exist which is equivalent to an extended block with duration 0). Furthermore, server type 
 used in 
 is greater than or equal to 
, so 
. Thus, for , we have 
.

If , then there can be a new block at time slot t. Note that this is only a necessary, not a sufficient condition for a new block (e.g., if 
). If 
 is a new block, then its cost is given by 
. If 
 still runs at time slot t, then 
 is an extended block whose cost is at most 
, since 
. Thus, for , we have 
.

Now, we can estimate the expected cost of 
 by using the density function 
. We get
 
 
 
 
where 
≔
 
 denotes the distribution function. The last inequality uses 
, so the integrals can easily be calculated. By using 
 (which follows from the definition of q), we get
 
 
 □

The following lemma replaces Lemma 12 and shows how the expected cost of block 
 can be folded into the term 
 which is the right hand side of inequality (10).

Lemma 15

For all lanes  and time slots , it holds(19)
 
 

Proof

If 
, then 
 does not exist, so 
 and therefore inequality (19) holds by 
 (see Lemma 10).

Thus, in the following we consider the case 
. For all  with ≔
, the inequality 
 holds (see inequality (13) in the proof of Lemma 12). Therefore, we get(20)
 
 
 
 
 
 For the last inequality, we add the term 
 which is positive, since 
.

The last term in (20) satisfies(21)
 
 with ≔
, because either j runs for τ time slots in 
 or j is powered up during  resulting in a cost of
 
 as 
 by definition.

By using Lemma 14, we get
 
 
 
 
 □

Theorem 16

Algorithm  is 
 
-competitive against an oblivious adversary.

Proof

Lemma 8 still holds for algorithm , so the schedule 
 is feasible. We have to show that 
 with 
 
. Let
≔
 
 
 
 
 denote the expected cost of algorithm  up to time slot v. We will show by induction that(22)
 
 
 holds for all 
.

For , we have no costs for both 
 and 
, so inequality (22) is fulfilled. Assume that inequality (22) holds for . By using the induction hypothesis as well as Lemma 11, Lemma 15, we get(23)
 
 
 
 
 
 
 
 
 

Since 
, we get
 
 
 
 
 The schedule 
 is optimal for the problem instance , so algorithm  is cd-competitive. □

4. Lower bound
In this section, we show that there is no deterministic online algorithm that achieves a competitive ratio that is better than 2d. We consider the following problem instance: Let 
≔
 and 
≔
 where N is a sufficiently large number that depends on the number of server types d. The value of N will be determined later. The adversary will send a job for the current time slot if and only if the online algorithm has no active server during the previous time slot. This implies that the online algorithm has to power up a server immediately after powering down any server. Note that 
, i.e., it is never necessary to power up more than one server. The optimal schedule is denoted by 
⁎
. Let  be an arbitrary deterministic online algorithm and let 
 be the schedule computed by .

W.l.o.g., in 
 there is no time slot with more than one active server. If this were not the case, we could easily convert the schedule into one where the assumption holds without increasing the cost. Assume that at time slot t a new server of type k is powered up such that there are (at least) two active servers at time t. If we power up the server at , the schedule is still feasible, but the total costs are reduced by 
. We can repeat this procedure until there is at most one active server for each time slot.

Lemma 17

Let . If 
 only uses servers of type lower than or equal to k and if the cost of  is at least 
, then the cost of  is at least(24)
⁎
 with 
 and .

Proof

We will prove the lemma by induction.

For , let t be the length of the schedule 
 and let n denote how often server type 1 is powered up in 
. The cost of 
 is 
. We use two strategies to estimate the cost of an optimal schedule. In the first strategy the server runs for the whole time, so the cost is 
. The second strategy is to power down the server when it is idle, so the cost is 
.

We differentiate between the cases  (case 1) and  (case 2). In case 1, the competitive ratio is(25)
⁎
 
⁎
 
 
 
 
 
 For the inequality, we split the cost of 
 into two terms and estimate the cost of 
⁎
 in left quotient with the second strategy and 
⁎
 in the right quotient with the first strategy.

The quotient 
 
 can be estimated by using 
, the definitions of 
 and 
 as well as the precondition of the lemma that requires .
 
 
 
 

By using this result in inequality (25) as well as , we get
⁎
 
 
 
 since 
.

In case 2, we use the fact that 
, so the competitive ratio is at least
⁎
 
 
 
 In the first inequality, we use the second strategy to estimate the cost of 
⁎
. The second inequality holds because  and 
.

For both cases, we have shown that 
⁎
 holds, so inequality (24) is fulfilled for .

Next, assume that Lemma 17 holds for . We divide the schedule 
 into phases 
 such that in the phases 
 server type k is used exactly once, while in the intermediate phases 
 the other server types  are used. A phase 
 begins when a server of type k is powered up and ends when it is powered down. The phases 
 can have zero length (if the server type k is powered up immediately after it is powered down, so between 
 and 
 an empty phase 
 is inserted).

The operating cost during phase 
 is denoted by 
. The operating and switching costs during phase 
 are denoted by 
. We divide the intermediate phases 
 into long phases where 
 holds and short phases where 
. Note that we can use the induction hypothesis only for long phases. The index sets of the long and short phases are denoted by  and , respectively.

To estimate the cost of an optimal schedule we consider two strategies (see Fig. 5): In the first strategy, a server of type k is powered up at the first time slot and runs for the whole time except for phases 
 with 
, then powering down and powering up are cheaper than keeping the server in the active state (
 vs. 
). The operating cost for the phases 
 is 
⁎
 with 
⁎
≔
 and the operating cost for the phases 
 is at most 
 
, because algorithm  uses servers whose types are lower than k and therefore the operating cost of  is at least 
 times larger. Thus, the total cost of this strategy is upper bounded by(26)
⁎
 
⁎
 
 

Fig. 5
Download : Download high-res image (42KB)
Download : Download full-size image
Fig. 5. (Figure is colored.) Visualization of the two strategies to estimate the cost of an optimal schedule. The schedule of algorithm  and the incoming jobs λt are shown in the middle. Long phases are marked in blue and short phases are marked in green (L1 is a short phase with zero length). Strategy 1 simply uses server type k the whole time. During the short phases, strategy 2 behaves like algorithm . For the long phases, there is a solution that results in only 1/α of the cost of 
 with α≔2k − 2 − ϵk−1. In the red blocks server type 1 is activated for exactly one time slot.

The second strategy is defined as follows. For the phases 
, we run the server type 1 for exactly one time slot (note that in 
 we only have 
 in the first time slot of the phase). For the short phases , we just behave like algorithm , and for the long phases , we use the strategy implicitly given by our induction hypothesis. Actually, the induction hypothesis only states the competitive ratio, however, this proof recursively defines how to construct the corresponding offline schedule. The total cost of the second strategy is at most(27)
⁎
 
 
 
 with ≔
.

The total cost of  is equal to 
, so the competitive ratio is given by
⁎
 
⁎
 
 
⁎
 
 
⁎
 
 
⁎
 
 In the first step, the numerator is separated into two parts. Then 
⁎
 in the first fraction is estimated by inequality (26) (first strategy). In the next step, we transform the second fraction.(28)
⁎
 
 
 
⁎
 
 
⁎
 
 
⁎
 
 
 
⁎
 
 
 
 
 
⁎
 
 
 
⁎
 
 In the last step, we use inequality (27) (second strategy) to estimate 
⁎
. In particular, we have
 
 
 
 
 
 
 
 The fraction 
 
⁎
 
 of (28) is transformed as follows
⁎
 
 
 
⁎
 
 
⁎
 
 
 
⁎
 
 with . By using inequality (26) and 
⁎
 for all , we get
⁎
 
 
 
⁎
 
 
 
⁎
 
 
 
 
⁎
 
 For the last estimation we used the following inequalities: 
 
 
 
 
 
 
 With 
, ≔, , the definition of 
 and , we get(29)
⁎
 
 
⁎
 

If 
⁎
 
 holds, then 
 (a precondition of Lemma 17) implies 
⁎
, so inequality (24) is fulfilled and Lemma 17 holds. If 
⁎
 
, then 
⁎
 
 
 and inequality (29) gives
⁎
 
 
 
 
 
 □

Theorem 18

There is no deterministic online algorithm for the data-center right-sizing problem with heterogeneous servers and time- and load-independent operating costs whose competitive ratio is smaller than 2d.

Proof

Assume that there is an -competitive deterministic online algorithm . Let ≔
. We construct a workload as described at the beginning of Section 4 until the cost of  is greater than 
 (note that 
 for all , so the cost of  can be arbitrarily large). By using Lemma 17 with , we get
⁎
 
⁎
⁎
 which is a contradiction to our assumption that algorithm  is -competitive. Therefore, there is no deterministic online algorithm whose competitive ratio is smaller than 2d. □

The schedule constructed for the lower bound only uses at most one job in each time slot, so there is no reason for an online algorithm to utilize more than one server of a specific type. Thus, for a data center with m unique servers (i.e. 
 for all ), the best achievable competitive ratio is .

Corollary 19

There is no deterministic online algorithm for the data-center right-sizing problem with m unique servers and time- and load-independent operating costs whose competitive ratio is smaller than 2m.

5. Summary
In this paper, we have settled the competitive ratio of online algorithms for right-sizing heterogeneous data centers with d different server types. We investigated a basic setting where each server type has a constant operating cost per time unit. In contrast to related publications like [12] or [17], we studied the discrete setting where the number of active servers must be an integral number. Thereby we gain truly feasible solutions. We developed a 2d-competitive deterministic online algorithm and showed that 2d is a lower bound for deterministic algorithms. Hence our algorithm is optimal. Furthermore, we presented a randomized version that achieves a competitive ratio of 
 
 against an oblivious adversary.

For randomized online algorithms, there is a trivial lower bound of 
 
 given by the Ski-Rental problem [36]. For future work, it would be interesting to improve this bound. So far, it is even unknown whether or not a sublinear competitive ratio is achievable. There are many possibilities to extend the heterogeneous data-center right-sizing problem examined in this paper. This includes, for example, servers with different computational power or operating costs that not only depend on the server type but also on the load of a server like in [14] and [12] who investigated homogeneous data centers.