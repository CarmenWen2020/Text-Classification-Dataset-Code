Abstract
We develop a randomized approximation algorithm for the size of set union problem , which is given a list of sets  with approximate set size  for  with , , and biased random generators with probability  for each input set  and element , where  and . The approximation ratio for  is in the range   for any . The complexity of the algorithm is measured by both time complexity and round complexity. One round of the algorithm has non-adaptive accesses to those  functions , and membership queries (?) to input sets  with . Our algorithm gives an approximation scheme with  running time and  rounds in contrast to the existing algorithm [1] that needs  rounds in the worst case with  running time, where m is the number of sets. Our algorithm gives a flexible tradeoff with time complexity  and round complexity  for any . Our algorithm runs sublinear in time under certain condition that each element in  belongs to  sets for any fixed , to our best knowledge, we have not seen any sublinear results about this problem. Our algorithm can handle input sets that can generate random elements with bias, and its approximation ratio depends on the bias. We prove that it is #P-hard to count the number of lattice points in a set of balls, and we also show that there is no polynomial time algorithm to approximate the number of lattice points in the intersection of n-dimensional balls unless P=NP. As applications of our algorithm, we propose approximation algorithms for counting the number of lattice points in a union of high dimensional balls and for the maximal coverage problem with balls.

Keywords
#P-hard
Randomized approximation
Lattice points
Rounds
Sublinear time

1. Introduction
Computing the cardinality of set union is a basic algorithmic problem that has a simple and natural definition. It is related to the following problem: given a list of sets 
 with random generators 
, and set size 
 for each input set 
, where , compute 
. This problem is #P-hard if each set contains -lattice points of a high dimensional cube [2]. Karp, Luby, and Madras [1] developed a -randomized approximation algorithm for approximating the number of distinct elements in the union 
 in linear 
 time. The input of the algorithm includes the exact size of each set and a uniform random element generator of each set. Bringmann and Friedrich [3] applied Karp, Luby, and Madras' algorithm in deriving approximate algorithms for approximating the volume of unions and intersections of high-dimensional geometric objects with uniform random sampling. They also proved that it is #P-hard to compute the volume of the intersection of high dimensional boxes and showed that there is no polynomial time 
-approximation unless NP=BPP. A similar problem has been studied in the streaming model [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15]: given a list of elements appearing in multisets, count the number of distinct items in the list. This problem has a more general format to compute frequency moments 
 
, where 
 denotes the number of occurrences of i in the sequence. Of the algorithms mentioned above, some of them were based on random sampling, some of them provided exact set sizes when approximating the cardinalities of multisets of data and some of them accessed all the elements from the input sets. However, in reality, it is really hard to have uniform sampling and exact set size, especially when dealing with high dimensional problems.

Motivation: The existing approximate set union algorithm [1] needs each input set has a uniform random generator. In order to have approximate set union algorithm with broad application, it is essential to have algorithms with biased random generator for each input set and see how approximation ratio depends on the bias. In this paper, we propose a randomized approximation algorithm to approximate the size of set union problem by extending the model used in [1]. In order to show why approximate randomization method is useful, we generalize the algorithm that was designed by Karp, Luby, and Madras [1] to an approximate randomization algorithm. In our algorithm, each input set 
 is a black box that can provide its size 
, generate a random element 
 of 
, and answer the membership query 
 in  time. Our algorithm can handle input sets that can generate random elements with bias with 
 
 
 for each input set 
 and approximate set size 
 for 
 with 
.

As the communication complexity is becoming important in distributed environment, data transmission among variant machines may be more time consuming than the computation inside a single machine. The round complexity is related a distributed computing complexity if input sets are stored in a distributed environment, and the number of rounds indicates the complexity of interactions between a central server, which runs the algorithm to approximate the size of set union, and clients, which save one set each. It is essential to have algorithm to reduce the number of rounds when approximating the size of set union in a distributed environment. Our algorithm complexity is measured by the number of rounds. The algorithm is allowed to make multiple membership queries and get random elements from the input sets in one round. Our algorithm makes adaptive accesses to input sets with constant rounds to approximate the size of set union. The algorithms developed in the streaming model [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15] access all the elements from the input sets, however, our algorithm developed in the randomized model only accesses a few (i.e., small number of) elements from the input sets.

Computation via bounded queries to another set has been well studied in the field of structural complexity theory. Polynomial time truth table reduction has a parallel way to access oracle with all queries to be provided in one round [16]. Polynomial time Turing reduction has a sequential way to access oracle by providing a query and receiving an answer in one round [17]. The constant-round truth table reduction (for example, see [18]) is between truth table reduction, and Turing reduction. Our algorithm is similar to a bounded round truth table reduction to input sets to approximate the size set union. Karp, Luby, and Madras [1]'s algorithm runs like a Turing reduction, which has the number of adaptive queries proportional to the time.

It is a classical problem in analytic number theory for counting the number of lattice points in d-dimensional ball, and a series of articles [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32], [33], [34], [35] have studied on constructing analytical expression for the number of lattice points in d-dimensional ball. A typical problem called “Gauss Circle Problem” which was proposed by Gauss to count the number of lattice points in a circle. Counting the number of lattice points inside a 4-dimensional ball efficiently implies an efficient algorithm to factorize the product of two prime numbers () as  (see [36], [37]). Therefore, a fast exact counting of lattice points inside a 4-dimensional ball implies a fast algorithm to crack RSA public key system. Therefore, it is important to design effective and efficient algorithm to count the number of lattice points in high dimensional balls. In this paper, we design approximation scheme for counting the number of lattice points in a d-dimensional ball with its center in , where  be the set points 
 with 
 for an integer , another arbitrary integer i, an arbitrary real number l and a real number λ. The algorithm returns an approximation in the range  in a time 
 
, where  is the number of lattice points in a d-dimensional ball with radius r and center . We also show how to generate a random lattice point in a d-dimensional ball with its center at . The algorithm generates each lattice point inside the ball with a probability of 
 
 
 in a time 
 
, where the d-dimensional ball has radius r and center . Without the condition that a ball center is inside , counting the number of lattice points in a ball may have time complexity that depends on dimension number d exponentially, even the radius is as small as d.

Our Contributions: We have the following contributions to approximate the size of set union. 1. Our algorithm is based on a new approach that is different from that in [1]. 2. Our algorithm has a constant number of rounds to access the input sets, which is in contrast to the existing algorithm [1] that needs  rounds in the worst case with m be the number of sets. This reduces an important complexity in a distributed environment where each set stays a different machine. 3. Our algorithm handles the approximate input set sizes and biased random sources. The existing algorithm [1] assumes uniform random source from each set. 4. Our algorithm runs in sublinear time when each element belongs to at least 
 sets for any fixed . We have not seen any sublinear results about this problem. 5. We show a tradeoff between the number of rounds, and the time complexity. Our algorithm takes  rounds with time complexity 
, and takes 
 
 rounds, with a time complexity 
 for any . We still maintain the time complexity nearly linear time in the classical model. 6. We identify two additional parameters 
 and 
 that affect both the complexity of rounds and time, where 
 is the least number of sets that an element belongs to, and 
 is the largest number of sets that an element belongs to. 7. We give a natural example to apply our approximation scheme to the number of lattice points on a list of balls. We prove that it is #P-hard to count the number of lattice points in a set of balls, and we also show that there is no polynomial time algorithm to approximate the number of lattice points in the intersection d-dimensional balls unless P=NP. We found that it is an elusive problem to develop a 
 
 time -approximation algorithm for counting the number of lattice points of d-dimensional ball with a small radius. We are able to handle the case with ball centers in , which can approximate an arbitrary center by adjusting parameters λ and l. This is our main technical contributions about lattice points in a high dimensional ball.

Organization: The rest of paper is organized as follows. Section 2 defines the computational model and round complexity. Section 3 presents some theorems that play an important role in accuracy analysis. In Section 4, a randomized approximation algorithm is proposed to approximate the size of set union problem; time and round complexities are analyzed. Section 5 discusses a natural problem that counting of lattice points in high dimensional balls to support the useful of approximation randomized algorithm. An application of high dimensional balls for maximal coverage problem gives in Section 6. Section 7 summarizes the conclusions.

2. Computational model and complexity
In this section, the model of computation, and the definition of round complexity are defined.

2.1. Model of randomization
Definition 1

Let A be a set of elements:

1.
A α-biased random generator for set A is a generator that each element in A is generated with probability in the range 
 
 
.

2.
A 
-biased random generator for set A is a generator that each element in A is generated with probability in the range 
 
 
.

Definition 2

Let L be a list of sets 
 such that each supports the following operations:

1.
The size of 
 has an approximation 
 for . Both 
 
 and m are part of the input.

2.
Function RandomElement
 returns a 
-biased approximate random element x from 
 for .

3.
Function query
) function returns 1 if 
, and 0 otherwise.

Definition 3

For a list L of sets 
 and real numbers 
, 
, it is called 
-list if each set 
 is associated with a number 
 with 
 for , and the set 
 has a 
-biased random generator RandomElement(
).

Definition 4

The model of randomized computation for our algorithm is defined below:

1.
The input is a list L defined in Definition 2.

2.
It allows all operations defined in Definition 2.

2.2. Round and round complexity
The round complexity is the total number of rounds used in the algorithm. Our algorithm has several rounds to access input sets. At each round, the algorithm sends non-adaptive (i.e., parallel) requests to random generators, membership queries, and receives the answers from them.

Our algorithm is considered as a client-server interaction. The algorithm is controlled by the server side, and each set is a client. In one round, the server asks some questions to clients which are selected. The parameters  may be used to determine the time complexity and round complexity, where ϵ controls the accuracy of approximation, γ controls the failure probability, and m is the number of sets.

3. Preliminaries
Hoeffding Inequality [38] and Chernoff Bound [39] play an important role during the accuracy analysis. They show how the number of samples determines the accuracy of approximation.

Theorem 1

Let 
 be m independent random 0-1 variables, where 
 takes 1 with probability at least p for . Let 
 
, and . Then for any , 
 
.

Theorem 2

Let 
 be m independent random 0-1 variables, where 
 takes 1 with probability at most p for . Let 
 
. Then for any , 
 
.

Define 
 
, 
 
 and 
. We give a bound for . First, we give a bound for 
 
. Let 
 
. We consider the case . We have
 
 
 Therefore,(1)
 
 for all . We let(2)
⁎
 
 Hence, we have 
⁎
 for all  as 
 
 
.

A well-known fact, called union bound, in probability theory is the inequality
 where 
 are m events that may not be independent. In the analysis of our randomized algorithm, there are multiple events such that the failure from any of them may fail the entire algorithm. We often characterize the failure probability of each of those events, and use the above inequality to show that the whole algorithm has a small chance to fail after showing that each of them has a small chance to fail.

4. Algorithm based on adaptive random sampling
In this section, a randomized algorithm is developed for the size of set union when the approximate set sizes and biased random generators are given for the input sets. Some definitions are given before the presentation of the algorithm. The algorithm developed in this section has an adaptive way to access the random generators from the input sets. All the random elements from input sets are generated in the beginning of the algorithm, and the number of random samples are known in the beginning of the algorithm. The results in this section show a tradeoff between the time complexity and the round complexity.

Definition 5

Let 
 be a list of finite sets:

1.
For an element x, define 
 and 
.

2.
For an element x, and a subset H of indices with multiplicity of , define 
 and 
.

3.
Define 
.

4.
Define 
.

5.
Let W be a subset with multiplicity of 
, define 
 
 
 
, and 
 
 
 
, where h and s are real numbers.

6.
For a , partition 
 into 
 such that 
 and 
 where . Define 
, which is the number of sets in the partition under the condition that 
.

Remark

Our algorithm is based on random sampling, therefore, the random elements could be repeatedly chosen from the sets. For example, a subset H of indices with multiplicity of  could be .

4.1. Overview of algorithm
For a list L of input sets 
, each set 
 has an approximate size 
 and a random generator. It is easy to see that 
 
 
 
. In the first round, the algorithm approximates 
 
 
 
 by 
 
 
 
 via generating a set of 
 of sufficient random samples from the list of input sets. The algorithm has constant rounds to approximate the thickness  for each 
. In each round, the algorithm selects some number of subsets and checks how frequently chosen (i.e., thickness) elements appear in the chosen subsets. Naturally, samples appearing in many (i.e., a large number of) subsets would require a few subsets to approximate its thickness accurately, and samples appearing in a few subsets would require many subsets to approximate its thickness accurately. As rounds proceed, the algorithm targets with decreasing thickness and samples more subsets. Finally, as the thickness  for every 
 have been approximated, 
 
 
 
 can be used to approximate 
 
 
 
, which is equal to 
.

Example 1

Let L be a list of 10 sets 
, where 
 with  and 
 for . In the beginning of the algorithm, we generate a set 
 of 
 random samples from list L, where 20 random samples with higher thickness  coming from C and 200 random samples with lower thickness  coming from 
. At the first round, we only need to select sets 
, and 
 to approximate the thickness  of the 20 random samples locating at C. Then at the second round, we have to select all the sets 
, to approximate the thickness  of the 200 random samples coming from 
 (see Fig. 1).

Fig. 1
Download : Download high-res image (35KB)
Download : Download full-size image
Fig. 1. Set union of ten sets.

4.2. Algorithm description
Before giving the algorithm, an operation that selects a set of random elements from a list L of sets 
 is defined.  is assumed throughout the paper.

Definition 6

Let L be a list of m sets 
 with 
 and 
-biased random generator RandomElement(
) for , and 
. A random choice of L is to get an element x via the following two steps:

1.
With probability 
 
, select a set 
 among 
.

2.
Get an element x from set 
 via RandomElement
.

Some definitions of the parameters and functions that affect our algorithm are given below. Assume that  is used to control the accuracy of approximation, and  is used to control the failure probability. In the following algorithm, the two integer parameters 
 and 
 with 
 can help speed up the computation. The algorithm is still correct if we use default case with 
 and 
.

1.
Function 
 is used to control the number of rounds of the algorithm. Its growth rate is mainly determined by the parameter 
 that will be determined later:(3)

2.
Function 
 determines the number of random samples from the input sets in the beginning of the algorithm, and 
 
:(4)
 
⁎
 
 
 
⁎
 

3.
Function 
 affects the number of random indices in the range . Those random indices will be used to choose input sets to detect the approximate  for those random samples x:(5)
⁎
⁎
 
⁎
 
⁎
 
 
 
⁎⁎
 

Algorithm 1
Download : Download high-res image (256KB)
Download : Download full-size image
Algorithm 1. ApproximateUnion(L,zmin,zmax,M,γ,ϵ).

Note that the algorithm runs in a sublinear time when 
 and 
 are part of the input for a fixed , otherwise, the algorithm has to spend  time to compute M.

4.3. Proof of algorithm performance
The accuracy and complexity of algorithm ApproximateUnion(.) will be proven in the following lemmas.

Lemma 3 gives an upper bound for the number of rounds of the algorithm. It shows how round complexity depends on 
 and constant 
.

Lemma 3

The number of rounds of the algorithm is 
 
 
.

Proof

By line 1 of the algorithm, we have 
 and by line 10 of the algorithm, we have 
 is reduced by a factor 
 each round. Let y be the number of rounds of the algorithm, by the termination condition of line 26 of the algorithm, we have 
, where 
 is any integer with 
 
. Therefore, 
 
 
 
 
, where 
. □

Lemma 4 shows the random samples, which are saved in 
 in the beginning of the algorithm, will be enough to approximate the size of set union via 
. In the next a few rounds, algorithm will approximate 
.

Lemma 4

With probability at least 
, 
 
.

Proof

Let 
 and 
. For an arbitrary set 
 in the list L, and an arbitrary element 
, with at least the following probability, x is selected via 
 at line 2 of Algorithm ApproximateUnion(.),
 
 
 
 
 

Similarly, by the line 2 of Algorithm ApproximateUnion(.), x is chosen via 
 with at most the following probability,
 
 
 
 
 

Define 
 and 
. Each element x in 
 is selected via 
 at line 2 with probability in 
 
 
.

Define 
 
, and 
 
 (see 6 of Definition 5), where 
 
 
 
 and 
 
.

Let 
. We discuss two cases:

Case 1: 
. When one element x is chosen, the probability that 
 is in the range 
 
 
. Let 
 
 
. Since 
, we have 
. Let 
 
 (see line 1 of the algorithm). It is easy to see that . We have
 
 
 
 
 
(6)
 
 
 Let 
 
. Thus, 
.

Let 
 be the elements of 
 and also in 
. By Theorem 2, with probability at most 
⁎
⁎
 
 (by inequality (6)), there are more than 
 
 
 elements to be chosen from 
 into 
. Thus,(7)
 
 
 with probability at most 
 to fail.

Case 2: 
. When 
 elements are selected for 
, let 
 be the number of elements selected in 
. When one element x is chosen, the probability that 
 is in the range 
 
 
.

Let 
 
 and 
 
.

We have(8)
 
 
 
 
 
 

We have(9)
 
 
 
 
 
 
 
 

With probability at most 
⁎
 
 (by inequality (8)),
 
 

With probability at most 
⁎
 
 (by inequality (9)),
 
 

Therefore, with probability at least 
, we have(10)
 
 
 Thus, we have that there are sufficient elements of 
 to be selected with high probability, which follows from Theorem 1 and Theorem 2.

In the rest of the proof, we assume that inequality (7) holds if the condition of Case 1 holds, and inequality (10) holds if the condition of Case 2 holds.

Now we consider(11)
 
 
 
 
  
 
 
  
 
 
 
 
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
(12)
 
 

For the lower bound part, we have the following inequalities:(13)
 
 
 
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
(14)
 
 
 
 

Therefore, we have
 
 □

Lemma 5 shows that at round i, it can approximate  for all random samples with highest  in 
. Those random elements with highest  will be removed in round i so that the algorithm will look for random elements with smaller  in the coming rounds.

Lemma 5

After the execution of round i, with probability at least 
, we have the following three statements:

1.
Every element 
 with 
 
 has 
 
 
.

2.
Every element 
 with 
 
, it satisfies the condition in line 8 of the algorithm.

3.
Every element 
 with 
 
, it does not satisfy the condition in line 8 of the algorithm.

Proof

It follows from Theorem 1 and Theorem 2. There are 
 indices are selected among . Let 
 
.

Statement 1: We have 
 
 
 
 
 
 
 
.

Then with probability at most 
⁎
 
, 
 
, and with probability at most 
⁎
 
, 
 
.

Let 
 
. There are at most 
 elements in 
, therefore, with probability at most 
 
,
 
 

Statement 2: This statement of the lemma follows from Statement 1.

Statement 3: This part of the lemma follows from Theorem 1 and Theorem 2. For 
, 
 
. Let 
 
. With probability at most 
⁎
 
, we have 
. Let 
 
. There are at most 
 elements in 
, therefore, with probability at most 
 
, there exists one 
 with 
 
 to satisfy 
. □

Lemma 6

Let x and y be positive real numbers with . Then we have:

1.
.

2.
If , then 
.

3.
If 
, then 
, and 
.

Proof

By Taylor formula, we have 
 
 for some . Thus, we have 
. Note that the function 
 
 is increasing, and  
 
 
. We also have 
 
.

It is trivial to verify Statement 3. 
. Clearly, 
. □

Lemma 7 shows that how to gradually approximate 
 via several rounds. It shows that the left random samples stored in 
 after round i is enough to approximate 
.

Lemma 7

Let y be the number of rounds. Let 
 be the set of elements removed from 
 in round i. Then we have the following facts:

1.
With probability at least 
, 
 
, and

2.
with probability at least 
, 
 
, where 
.

Proof

Let 
. If a local is too small, it does not affect the global sum much. In 
, we deal with the elements x of 
 
. By Lemma 5, with probability at least 
, 
 does not contain any x with 
 
.

Let 
 be the number of elements of 
 in 
 with multiplicity. Let 
 be the set of elements in both 
 and 
 with multiplicity.

Statement 1: We discuss two cases:

Case 1: 
. This case is trivial since 
 and 
 according to the algorithm (line 15 to line 18).

In the following Case 2, we assume the condition of Case 1 is false. Thus, 
.

Case 2: 
. Let 
 
, we have
 
 
 
 
 
 
 

Two subcases are discussed below.

Subcase 2.1: 
, in this case, 
 has a small impact on the global sum.

Let 
 
, where 
 
 
 and 
 
. By Theorem 1 and Theorem 2, with probability at least 
⁎
⁎
 
 
,
 
 
 
 
 
 

We assume 
. We have 
 
 
. Clearly, 
. Let 
 
, thus, we have
 
 
 
 

Subcase 2.2: 
 in 
, in this case, 
 does not lose much accuracy. From 
 to 
, 
 
 elements are selected.

Let 
 
. We have
 
 
 
 

With probability at most 
⁎
 
, we have that 
. With probability at most 
⁎
 
, we have that 
. They follow from Theorem 1 and Theorem 2.

We assume 
. Thus, 
. So, 
 
. Let 
 
.

We have
 

We have
 
 
 

Statement 2: In the rest of the proof, we assume that if 
, then 
, and if 
, then 
.

In order to prove Statement 2, we give an inductive proof that 
 
. It is trivial for . Assume that 
 
.

Since 
, we have 
.

Thus, we have
 
 
 
 
 
 Similarly, we have
 
 
 
 
 
 Thus, we have 
 
.

Therefore, with probability at least 
, 
 
 by Lemma 6. □

Lemma 8 gives the time complexity of the algorithm. The running time depends on several parameters.

Lemma 8

The algorithm ApproximateUnion(.) takes 
 
 
 
 time.

Proof

Let y be the total number of rounds. We have 
 
 
 by Lemma 3.

The time of each round is 
 
, which is mainly from line 8 of the algorithm, and
 
⁎
 
 
 
⁎⁎
 
 Therefore, the total time is 
 
 
. □

Theorem 9 shows the performance of the algorithm. The algorithm is sublinear if 
 for a fixed , and has a 
 with 
 for a positive fixed b (b may not be equal to a) to be part of input to the algorithm.

Theorem 9

The algorithm ApproximateUnion(.) takes 
 
 
 rounds and 
 
 
 
 time such that with probability at least , it gives
 where 
 and 
 are parameters with 
, and 
.

Proof

Let y be the number of rounds. By Lemma 5, with probability at least 
,
 
 

By Lemma 7, with probability at least 
,
 
 By Lemma 4, with probability at least 
,
 
 

Therefore, with probability at least 
,
 
 Now assume
 

Let 
 
 
 
 
 
, by Statement 3 of Lemma 6, we have

The algorithm may fail at the case after selecting 
, or one of the rounds. By the union bound, the failure probability is at most 
 with 
 
 and 
 
. We have that with probability at least  to output the sum that satisfies the accuracy described in the theorem. The running time and the number of rounds of the algorithm follow from Lemma 8 and Lemma 3, respectively. □

Since 
, we have the following Corollary 10. Its running time is almost linear in the classical model.

Corollary 10

There is a 
 time and  rounds algorithm for 
 such that with probability at least , it gives 
, where 
.

Proof

We let 
 with 
 in equation (3). Let 
 and 
. It follows from Theorem 9 as
 
 
 
 □

Corollary 11

For each , there is a 
 time and 
 
 rounds algorithm for 
 such that with probability at least , it gives 
, where 

Proof

We let 
 with 
 
 in equation (3). Let 
 and 
. It follows from Theorem 9 as
 
 
 
 □

An interesting open problem is to find an  time and  rounds approximation scheme for 
 with a similar accuracy performance as Corollary 10.

5. Approximate random sampling for lattice points in high dimensional ball
In this section, algorithms are introduced to approximate the number of lattice points in a high dimensional ball and generate a random lattice point inside a high dimensional ball. Before presenting the algorithms, some definitions are given below.

Definition 7

Let integer  be a dimensional number, 
 be the d-dimensional Euclidean space:

1.
For two points 
, define  to be Euclidean distance.

2.
A point 
 is a lattice point if 
 with 
 for .

3.
Let 
, and . Define 
 be a d-dimensional ball of radius r with center at p.

4.
Let 
. Define 
 
.

5.
Let 
, and . Define  be the number of lattice points in the d-dimensional ball of radius r with the center at p.

6.
Let λ, l be real numbers. Define 
 with 
 for an integer 
, and another arbitrary integer 
 for .

7.
Let λ, l be real numbers. Define 
⁎
 with 
 for an integer 
 with .

8.
Let 
, where a and m are integers and . Define 
⁎⁎
 with 
 for an integer 
, and another arbitrary integer 
 for .

5.1. Randomized algorithm for approximating lattice points for high dimensional ball
In this subsection, algorithms are developed to approximate the number of lattice points in a d-dimensional ball 
. Two sub-subsections will be discussed below.

5.1.1. Counting lattice points of high dimensional ball with small radius
In this sub-subsection, a dynamic programming algorithm is developed to count the number of lattice points in d-dimensional ball 
. Some definitions and lemmas used to prove the performance of algorithm are given before showing the algorithm.

Definition 8

Let p be a point in 
, and . Define 
 be the set of k-dimensional balls 
 of radii 
 with center at 
 where  is the number of initial integers of the center q and 
 for .

Lemma 12 shows that for any two balls with same dimensional number, if both their radii and the number of initial integers of their center equal, then they have the same number of lattice points.

Lemma 12

For two k-dimensional balls 
 and 
, if 
  and 
, then 
.

Proof

In order to prove that 
, we need to show that there is a bijection between the set of lattice points inside ball 
 and the set of lattice points inside ball 
, where 
 and 
 with 
 for .

Statement 1: 
, where 
 for .

We have
 then

Therefore, there exists a lattice point 
 corresponding to 
.

Statement 2: 
, where 
 for .

We have
 and

Therefore, there exists a lattice point 
 corresponding to 
.

Based on above two statements, there exists a bijection between the set of lattice points inside ball 
 and the set of lattice points inside ball 
.

Therefore, 
. □

Lemma 13 shows that the number of lattice points of the ball 
 will not be changed even if it is moved by an integer unit among every dimension.

Lemma 13

Let λ be a real number. For two k-dimensional balls 
 and 
, where 
, 
, 
 with 
, , and 
, 
 is an integer and 
 for 
, if 
, then we have 
.

Proof

Since 
 and 
 with , we have 
 via Lemma 12. □

We define  be a set of radii 
 for the balls that generated by the intersection of 
 with hyper-plane 
, ..., 
, ..., 
.

Definition 9

For a d-dimensional ball 
 of radius r with center at 
:

1.
Define 
 
 
.

Lemma 14 shows that the cardinality of  could be reduced from exponential to polynomial when the element of the ball's center with same type (i.e., .

Lemma 14

Let 
 be a d-dimensional ball of radius r with center at p, where 
⁎
, then 
 and  can be generated in 
 time.

Proof

Since 
 
 for , we have 
 as:

Let 
, it is easy to see that 
 then 
.

Let
  then we have:(15)
 

For each 
, we have 
 with , , and . For each 
, we have 
 with , , and . Therefore, 
 via inequality (15). Then  can be generated in 
 time. □

Lemma 15 is a special case of Lemma 14. It shows that there are at most 
 cases of the radii when the elements of the center are the type like fractions in base a. For example, 
.

Lemma 15

Let 
 where a is an integer with . Let 
 be a d-dimensional ball of radius r with center at 
⁎⁎
, then 
 and  can be generated in 
 time.

Proof

We have
 via Lemma 14.

For each 
, it can be transformed into 
 with  and z are integers, and(16)
 

Therefore, 
 via inequality (16). Then  can be generated in 
 time. □

Definition 10

For a d-dimensional ball 
 of radius r with center at 
:

1.
Define 
 for some integer .

2.
Define  with 
 if , where t is an integer and .

A dynamic programming algorithm is proposed below to count the number of lattice points in a d-dimensional ball 
.


Algorithm 2
Download : Download high-res image (69KB)
Download : Download full-size image
Algorithm 2. CountLatticePoint(r, p, d).

Note that if  then 
, otherwise 
 is in  (i.e., 
 is available in the table).

Theorem 16

Assume λ be a real number and , then there is a 
 time algorithm to count .

Proof

Line 2 has d iterations, line 3 takes 
 to compute 
 via Lemma 14, and line 4 has at most  items to add up.

Therefore, the algorithm CountLatticePoints(.) takes 
 running time. □

Remark

A special case of Theorem 16 is 
 
. In this case, the running time of the algorithm is 
. Note that the algorithm could be used to count the lattice points of a high dimensional ball if the element of the center of the ball has the same type like  even though λ is an irrational number.

Theorem 17 shows that the algorithm can count the number of lattice points of high dimensional ball if the element of the center of the ball has the same type like fractions in base a.

Theorem 17

Assume 
 and 
⁎⁎
, where m and a are integers with , then there is a 
 time algorithm to count .

Proof

Line 2 has d iterations, line 3 takes 
 to compute 
 via Lemma 15, and line 4 has at most  items to add up.

Therefore, the algorithm CountLatticePoints(.) takes 
 running time. □

Corollary 18

Assume 
 and 
⁎⁎
, where m is an integer, then there is a 
 time algorithm to count .

5.1.2. Approximating lattice points in high dimensional ball with large radius
In this sub-subsection, an -approximation algorithm is presented to approximate the number of lattice points in a d-dimensional ball 
 of large radius with an arbitrary center p, where β is used to control the accuracy of approximation. Some definitions are presented before proving theorems.

Definition 11

For each lattice point 
 with 
 for .

1.
Define  to be d-dimensional unit cube with center at 
 
 
.

2.
Define 
.

3.
Define 
 .

Theorem 19 gives an -approximation with running time  algorithm to approximate the number of lattice point  with p is an arbitrary center and 
 
 
.

Theorem 19

For an arbitrary , there is a -approximation algorithm to compute  of d-dimensional ball 
 with running time  for an arbitrary center p when 
 
 
.

Proof

Let 
 be the number of lattice points 
, 
 be the number of lattice points 
, and 
 be the volume of a d-dimensional ball with radius r.

Now consider two d-dimensional balls 
 and 
 that have the same center as ball 
. Since every lattice point q corresponds to a  via Definition 11, then we have: 
  Therefore,
 Then the bias is 
 
 when using 
 to approximate .

The volume formula for a d-dimensional ball of radius r is
 where 
 
 
 and  is Euler's gamma function. Then
 
 
 
 
 
 
 
 
 Similarly, we have
 
 
 
 
 
 
 
 
 From above two inequalities, we have
 
 
 
 
 then we have
 
 
 
 
 
 

Simplify the above inequality, we have
 
 
 
 
 
 
 Thus, we have(17)
 with 
 
 
 
.

It takes  to compute 
, since it takes  to compute  where 
 
 
. Therefore, the algorithm takes  running time to approximate  because of equation (17). □

Theorem 20

There is an -approximation algorithm with running time  to approximate  of 
 with an arbitrary center p when 
 
 
; and there is a dynamic programming algorithm with running time 
 
 
 
 
 to count  with center  when 
 
 
.

Proof

We discuss two cases based on the radius of the d-dimensional ball.

Case 1: When counting the number of lattice points of a d-dimensional ball with center  for 
 
 
, apply Theorem 16.

Case 2: When approximating the number of lattice points of a d-dimensional ball with an arbitrary center p for 
 
 
, apply Theorem 19. □

Corollary 21

There is a dynamic programming algorithm to count  of 
 with running time 
 
 
 
 
 for  when 
 
 
.

5.2. A randomized algorithm for generating random lattice point of high dimensional ball
In this subsection, algorithms are proposed to generate a random lattice point inside a high dimensional ball. Two sub-subsections will be discussed below.

5.2.1. Generating a random lattice point inside high dimensional ball with small radius
In this sub-subsection, a recursive algorithm is developed to generate a random lattice point inside a d-dimensional ball 
 of small radius with center .

The purpose of the algorithm RecursiveSmallBallRandomLatticePoint is to recursively generate a random lattice point in the ball 
.

Algorithm 3
Download : Download high-res image (90KB)
Download : Download full-size image
Algorithm 3. RecursiveSmallBallRandomLatticePoint(r, p, t, d).

Note that  is available at C-Table in  step and the implementation of line 5 of the algorithm is formally defined below: Partition  into 
, where 
 is uniquely corresponds to an integer 
 satisfying 
, 
, and 
. Generate a random number . If 
 (
 maps to 
), then it returns RecursiveSmallBallRandomLatticePoint
,  with 
.

The algorithm RandomSmallBallLatticePoint is to generate a random lattice point in the ball 
. It calls the function RecursiveSmallBallRandomLatticePoint(.).

Algorithm 4
Download : Download high-res image (36KB)
Download : Download full-size image
Algorithm 4. RandomSmallBallLatticePoint(r, p, d).

Theorem 22

For an arbitrary , assume λ be a real number and , then there is a 
 
 
 
 
 time algorithm to generate a lattice point inside a d-dimensional ball 
.

Proof

By algorithm RandomSmallBallLatticePoint(.), we can generate a random lattice point inside d-dimensional ball 
 with probability 
 
 
 
 
.

It takes 
 
 
 
 
 to compute  via Theorem 20, so algorithm SmallBallRandomLatticePoint(.) takes 
 
 
 
 
  running time. Thus, the algorithm takes 
 
 
 
 
 running time. □

5.2.2. Generating a random lattice point of high dimensional ball with large radius
In this sub-subsection, an -approximation algorithm is developed to generate a random lattice point inside a d-dimensional ball 
 of large radius r with arbitrary center p, where α is used to control the accuracy of approximation.

An approximation algorithm RecursiveBigBallRandomLatticePoint(.) is first proposed to generate a random lattice point inside a d-dimensional ball 
 of radius r with lattice point center p, then it is called by algorithm BigBallRandomLatticePoint(.) to generate an approximate random lattice point in a d-dimensional ball 
 of radius 
 with arbitrary center p.

Before presenting the algorithms, some definitions and lemmas that are used to analyze algorithm RecursiveBigBallRandomLatticePoint(.) are given.

Definition 12

For an arbitrary , let 
 be k-dimensional ball of radius r with arbitrary center q. Define  as 
 
 
  where  is the number of lattice point of k-dimensional ball 
 and 
 is the volume of ball 
.

Lemma 23 shows that  could be used to approximate  for k-dimensional ball 
 no matter how much the radius r it is.

Lemma 23

For an arbitrary . Let 
 be k-dimensional ball of radius r with arbitrary center q, then .

Proof

Two cases are considered.

Case 1: If 
 
 
, we have  via Definition 12.

Case 2: If 
 
 
, we have:
 via Theorem 19, where 
 be the volume of k-dimensional ball 
 with radius r.

Therefore, we have because 
 via Definition 12.

By combining the above two cases, we conclude that: . □

Lemma 24 shows that for two k-dimensional balls, if their radii are almost equal, so do the number of their lattice points.

Lemma 24

For an arbitrary  and a real number δ, let 
 be a k-dimensional ball of radius 
 with lattice center at q and 
 be a k-dimensional ball of radius 
 
 
 with lattice center at q, where 
 with 
 and , if 
, then 
 
.

Proof

Let 
 be the volume of d-dimensional ball of radius r. Since the volume formula for a d-dimensional ball of radius r is
 where 
 
 
 and  is Euler's gamma function. Then, we have the following as:

Since 
 
 
, 
 
 
, then we have(18) 
 
 
 
 
  via Theorem 19,

Plugging inequality (18) to above inequality, then we have
 
 
 
 
 
 and we also have

Therefore, 
 
. □

Definition 13

For an integer interval , , , and , an -partition for  is to divide  into 
 that satisfies the following conditions:

1.
 for .

2.
For any 
, 
 and 
.

3.
For any 
 and 
, 
 or 
.

The purpose of the algorithm RecursiveBigBallRandomLatticePoint(.) is to recursively generate a random lattice point inside the d-dimensional ball 
 of radius r with a lattice point center p.


Algorithm 5
Download : Download high-res image (117KB)
Download : Download full-size image
Algorithm 5. RecursiveBigBallRandomLatticePoint(r, p, t, d).

The following algorithm is proposed to generate an approximate random lattice point in a large ball with an arbitrary center, which may not be a lattice point.

Definition 14

Let integer  be a dimensional number, 
 be the d-dimensional Euclidean Space:

1.
A point 
 
 is the nearest lattice point of 
 if it satisfies
 
 
 
 
 
 


Algorithm 6
Download : Download high-res image (56KB)
Download : Download full-size image
Algorithm 6. BigBallRandomLatticePoint(r, p, d).

Theorem 25

For an arbitrary , there is an algorithm with running time 
 
 and -bias for a d-dimensional ball 
 to generate a random lattice point with radius 
 
 that centered at 
 with 
, .

Proof

In line 5 of algorithm RecursiveBigBallRandomLatticePoint(.), define
 
  and
 
 

Let 
, and 
 
 
, then we have 
 
 

Since 
 
 
, then
 
 
 
 and
 
 via Lemma 24, where 
 
.

Via Lemma 23 we have
 
 
 
 and
 
 

Thus, we have
 
 
 
 
 

From above inequality, we have
 
 
 
 
 
 
 

Via Lemma 23 we have
 
 
 
 
 
 
 
 Let 
, 
 
 and 
 
. Since Algorithm RecursiveBigBallRandomLatticePoint(.) has d iteration, we can generate a random lattice point with bias of probability as:
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 and
 
 
 
 
 
 
 
 
 
 
 
 
⁎
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Therefore, we can generate a random lattice point with the probability between
 
 

In line 3 of algorithm RecursiveBigBallRandomLatticePoint(.), it forms a 
 
-partition 
 for 
 and 
. Then, there are at most w number of 
, where w such that 
 
 
. Solving w, we have 
 
. And there are d iterations in algorithm RecursiveBigBallRandomLatticePoint(.).

Thus, the running time of the algorithm is 
 
 
 
. □

Remark

Note that there are at most one -dimensional ball of radius 
 
 with center at a lattice point, where . For this case, we can apply Theorem 22 with .

Theorem 26

For arbitrary , and 
, there is an 
-bias algorithm with running time 
 
 for a d-dimensional ball 
 to generate a random lattice point of radius 
 
 
 with an arbitrary center.

Proof

Consider another ball 
 of radius 
 with lattice center 
 that contains ball 
, where 
. Let 
 be the volume of a d-dimensional ball with radius r, then probability that a lattice point in 
 belongs to 
 is at least 
 
.

Via Theorem 19, we have 
 
 
 
 
  then we have
 
 
 
 
 

The formula for a d-dimensional ball of radius r is
 where 
 
 
 and  is Euler's gamma function. Let 
 
 and 
 
 
,
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 Therefore, the probability a lattice point in 
 belongs to 
 fails is at most 
 
 
 
, where 
 
 
 
, which means the algorithm BigBallRandomLatticePoint(.) fails with a small possibility.

The probability to generate a random lattice point in ball 
 is in the range of
 
 
 via Theorem 25. Then the bias to generate a random lattice point in ball 
 is 
 
, where 
 
 
.

Then, we have
 
 
 
 
 
 
 
 
 
 and
 
 
 
 
 
 
 
 
 
 
 

Therefore, the probability to generate a random lattice point in 
 is range of
 
 
 where 
 
.

It takes 
 
 running time to generate a random lattice point inside a d-dimensional ball 
 with a lattice point center via Theorem 25. Thus, the algorithm BigBallRandomLatticePoint(.) takes 
 
 running time to generate a random lattice. □

Theorem 27

For an arbitrary , there is an algorithm with running time 
 
 and -bias for a d-dimensional ball 
 to generate a random lattice point of radius 
 
 
 with an arbitrary center; and there is a 
 
 
 
 
 time algorithm to generate a lattice point inside a d-dimensional ball 
 of radius 
 
 
 with center .

Proof

We discuss two cases based on the radius of the d-dimensional ball.

Case 1: When generate a random lattice point inside a d-dimensional ball of radius 
 
 
 with center arbitrary center p, apply Theorem 26.

Case 2: When generate a random lattice point inside a d-dimensional ball of radius 
 
 
 with center , apply Theorem 22. □

5.3. Count lattice point in the union of high dimensional balls
In this subsection, the algorithm developed in Section 4 is leveraged to count the total number of lattice point in the union of high dimensional balls.

Theorem 28

There is a 
 
 
 time and  rounds algorithm for the number of lattice points in 
 such that with probability at least , it gives a 
, where each ball 
 satisfy that either its radius 
 
 
 or its center  and 
 is the total number of lattice point of union of m high dimensional balls.

Proof

Apply Theorem 20 and Theorem 27, we have 
 for each ball 
 with
 and biased random generators with
 
 
 for each input ball 
, where 
 is the number of lattice point of t-dimensional ball 
 of radius 
 for . Then apply Theorem 9. □

5.4. Hardness to count lattice points in a set of balls
In this subsection, the hardness to count the number of lattice points in a set of balls will be proved.

Theorem 29

It is #P-hard to count the number of lattice points in a set of d-dimensional balls, even the centers are of the format 
 that has each 
 to be either 1 or 
 
 for some integer .

Proof

We derive a polynomial time reduction from DNF problem to it. For each set of lattice points in a h-dimensional cube 
, we design a ball with radius 
 
 and center at 
 
 
. It is easy to see that this ball only covers the lattice points in 
. Every -lattice point in  has a distance to the center C equal to r. For every lattice point 
 that is not in 
 has distance d with 
 
 
. □

Definition 15

For a center 
 and an even number  and a real , a d-dimensional k-degree ball 
 is 
 and 
 
.

Theorem 30

Let k be an even number at least 2. Then we have:

1.
There is no polynomial time algorithm to approximate the number of lattice points in the intersection n-dimensional k-degree balls unless P=NP.

2.
It is #P-hard to count the number of lattice points in the intersection n-dimensional k-degree balls.

Proof

We derive a polynomial time reduction from 3SAT problem to it. For each clause 
⁎
⁎
⁎
, we can get a ball to contain all lattice points in the 0-1-cube to satisfy C, each 
⁎
 is a literal to be either 
 or its negation 
.

Without loss of generality, let 
. Let . Let center 
 
 
 
, which has value  in the first three positions, and 
 
 in the rest. For  assignment 
 of n variables, if it satisfies C if and only if 
 
 
. Therefore, we can select radius 
 that satisfies 
 
. We have the following inequalities:(19) 
 
 
 

This is because we have the following equalities:(20)
 
 
 

If 
 is not a -lattice point, we discuss two cases:

1.
Case 1. 
 for some i with .

In this case we know that dist
 by inequality (20).

2.
Case 2. 
 for some i with .

In this case we know that dist
 by inequality (20).

If 
 is a -lattice point, we discuss two cases:

1.
Case 1. Y satisfies C.

In this case we know that dist
.

2.
Case 2. Y does not satisfy C.

In this case we know that dist
 by inequality 
.

The ball 
 with center at 
 and radius 
 contains exactly those 0,1-lattice points that satisfy clause C. This proves the first part of the theorem.

If there were any factor c-approximation to the intersection of balls, it would be able to test if the intersection is empty. This would bring a polynomial time solution to 3SAT.

It is well known that #3SAT is #P-hard. Hence, it is #P-hard to count the number of lattice points in the intersection n-dimensional balls. This proves the second part of the theorem. □

6. Approximation for the maximal coverage with balls
In this section, the technologies developed in this paper are leveraged to the maximal coverage problem when each set is a set of lattice points in a ball with center in .

The classical maximum coverage is that given a list of sets 
 and an integer k, find k sets from 
 to maximize the size of the union of the selected sets in the computational model defined in Definition 2. For real number , an approximation algorithm is a -approximation for the maximum coverage problem that has input of integer parameter k and a list of sets 
 if it outputs a sublist of sets 
 such that 
, where 
 is a solution with maximum size of union.

Theorem 31

[40] Let ρ be a constant in . For parameters  and 
, there is an algorithm to give a 
 
-approximation for the maximum cover problem, such that given a 
 )-list L of finite sets 
 and an integer k, with probability at least , it returns an integer z and a subset  that satisfy

1.
 
⁎
 and ,

2.
, and

3.
its complexity is  with
 
 
 
 where 
 
 and 
⁎
 is the number of elements to be covered in an optimal solution.

Lemma 32 is used to transform the approximation ratio given by Theorem 31 to constant 
 
 to match the classical ratio for the maximum coverage problem.

Lemma 32

For each integer , and real , we have:

1.
 
 
 
 
.

2.
If 
 
 
, then 
 
 
, where 
 
.

Proof

Let function 
. We have . Taking differentiation, we get 
 
 for all 
 
.

Therefore, for all 
 
,(21)
 The following Taylor expansion can be found in standard calculus textbooks. For all ,
 
 

Therefore, we have(22)
 
 
 
 
 
 
 
 
 
(23)
 
 
 
 
 Note that the transition from (22) to (23) is based on inequality (21).

Following from part 1, we have 
 
 
 
 
 
. □

Theorem 33

There is a poly time 
 
-approximation algorithm for maximal coverage problem when each set is the set of lattice points in a ball with center in .

Proof

Let 
 
 with , and 
 
. It is easy to see 
 
 
. Let 
 
 
 
. It follows from Theorem 31, Lemma 32, Theorem 20 and Theorem 27. □

7. Conclusions
We introduce an almost linear bounded rounds randomized approximation algorithm for the size of set union problem 
, which given a list of sets 
 with approximate set size and biased random generators. The definition of round is introduced. We prove that our algorithm runs sublinear in time under certain condition. A polynomial time approximation scheme is proposed to approximate the number of lattice points in the union of d-dimensional ball if each ball center satisfies . We prove that it is #P-hard to count the number of lattice points in a set of balls, and we also show that there is no polynomial time algorithm to approximate the number of lattice points in the intersection of n-dimensional k-degree balls unless P=NP.