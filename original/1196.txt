In the allocation problem asynchronous processors must partition a set of items so that each processor leaves knowing all items exclusively allocated to it. We introduce a new variant of the allocation problem called the assignment problem in which processors might leave having only partial knowledge of their assigned items. The missing items in a processor s assignment must eventually be announced by other processors.While allocation has consensus number we show that the assignment problem is solvable read write wait free when k processors compete for at least k items. Moreover we propose a long lived read write wait free assignment algorithm which is fair allocating no more than items per processor and in which a slow processor may delay the assignment of at most n items where n is the number of processors.The assignment problem and its read write solution may be of practical interest for implementing resource allocators and work queues which are pervasive concurrent programming patterns as well as stream processing systems. Assignment Resource allocation Renaming Wait freeShared memory Mutual exclusion. Introduction We consider the problem of uniquely allocating items to processors in an asynchronous shared memory system. This problem is pervasive in concurrent and distributed programming such as in work queues where jobs are to be dispatched to several processors or in resource allocation systems such as for memory allocation allocation of process descriptors in an operating system etc. .Classical examples of resource allocation problems include the dining philosophers problem the mutual exclusion problem and its generalization in the L exclusion problem . Because some processors may have acquired all the resources while others are trying to acquire resources these problems trivially admit no wait free solutions and they are therefore usually studied under the assumptions that processors are scheduled fairly. For example Peterson s mutual exclusion algorithm or Lamport s Bakery algorithm solve the mutual exclusion problem under fair scheduling but may only be as fast as the slowest processor in the system.The long lived renaming problem is a relaxed form of allocation in which processors repeatedly acquire and release a single item each taken among a number of items larger than the number of processors. Because of the availability of spare items there is still possibility for progress even if processors do not release acquired items. Moreover given enough spare items the flexibility processors have in choosing their items allows to solve the long lived renaming problem wait free and using only atomic registers.Leaving spare items unallocated may be considered wasteful. Nevertheless read write wait free algorithms are advantageous atomic registers are implementable from some of the most unreliable communication primitives e.g. safe registers and wait freedom provides the highest degree of fault tolerance in crash prone systems A processor has to make progress regardless of the behavior of other processors including when any number of other processors stop taking steps i.e. crash .We ask whether there is a trade off between long lived renaming which is solvable read write wait free but leave some items unallocated and problems like mutual exclusion which allow full allocation but are only implementable read write under fair scheduling of all processors. To simplify our analysis we start by considering single use allocation type problems in which processors try to acquire items only once and do not release them .The first problem we consider is the single use allocation problem where a set of items R numbered to r must be allocated to a set of n≤r processors. Processors cannot express preferences as to which items they want. Instead we require that for a given strictly increasing function f N→N such that f and f n r each item is allocated to a unique processor each processor get at least one item and when k processors request items and terminate then exactly the first f k items no more no less are allocated this condition precludes trivial solutions and starvation . As we will see in Section the single use allocation problem cannot be solved wait free with registers and synchronization primitives such as test and set are needed.Can a relaxed allocation problem be solved read write wait free Single use renaming can but we have seen that it wastes items.For applications such as work queues or stream processing it may be sufficient to give a processor a partial allocation of items letting this processor work with its partial allocation before coming back to get its remaining allocated items. If items are jobs to be completed this would allow a processor to start working on a job before knowing the full set of jobs it has been allocated and to come back later when it finishes its first jobs to retrieve its remaining allocated jobs. If items are resources needed for some task a processor may start working with restricted resources while waiting for its full resource allocation to be revealed.To capture the intuition above we propose the assignment problem. In the single use version of the assignment problem each processor p must announce a set of items D p and the corresponding assignment a p D p →P describing for each item i∈D p the processor a p i to which i is assigned to. To solve the assignment problem given a non triviality parameter f N→N where f is strictly increasing four conditions must be met Fairness every processor that terminates announces an assignment in which it gets at least one item.Consistency if two processors announce an assignment for item i then they assign i to the same processor.Non Triviality for every k if k processors take steps then.only the first f k items may be assigned and.if all k processors terminate then every item in { … f k } is announced.In formulating the assignment problem we hope to obtain a problem that is solvable read write wait free. However one can see that this will depend on the non triviality condition if the non triviality condition stipulates that exactly the first f k k items must be allocated when k processors participate then the allocation problem and the assignment problem coincide and consensus number will be needed. Hence the question under what non triviality condition is the assignment problem solvable read write wait free We can derive a non triviality lower bound by observing that the assignment problem offers a solution to the f k adaptive renaming problem . As Gafni et al. have shown k ⌈kn ⌉ adaptive renaming can be used to solve n set consensus and is therefore impossible to solve read write wait free. Therefore f k k ⌈kn ⌉ is a lower bound under which the assignment problem is not solvable read write wait free. As we will see this lower bound is tight. Moreover given this bound the best we can hope for in terms of fairness of the assignment is that each processor gets at most two items. Surprisingly this is achievable. The assignment problem and its read write wait free solution are presented in Section .In Section we extend our investigation to a long lived version of the assignment problem in which processors repeatedly come back to get new items from an infinite stream of items i.e. items are consumed and need not be deallocated and we propose a read write wait free solution based on the single use algorithm. We then present an optimized version of the long lived algorithm which bounds by a constant the number of items that may be left unassigned because of a slow processor. In a solution based on mutual exclusion e.g. using the Bakery algorithm a slow processor can arbitrarily delay the whole system even when the slow processor is not in its critical section. In contrast the optimized long lived assignment algorithm presented in Section ensures that a slow processor delays the assignment of at most n items while the other processors suffer no delay.All the algorithms presented are formalized in the PlusCal language and their properties in a system of processors have been verified using the TLC model checker . In Section we give full PlusCal formalizations. Finally the last section presents related work and concludes this paper.. ModelWe consider a set P of asynchronous processors communicating through a single writer multi reader shared memory and optionally through tasks and linearizable objects. When P is finite we write n for the number of processors. Each processor has a private local state and a private read only input. The memory consists in one register Lp per processor p. A processor can take local steps read steps write steps object invocation steps task input steps and task output steps. The next step of a processor is always enabled i.e. a processor cannot wait for a condition. In a read write algorithm processors can only take locate steps read steps and write steps.A write operation by processor p writes to register Lp only and a read operation returns an atomic snapshot of the entire shared memory. Objects are sequential state machines with a transition relation relating pre state operation response and post state an object invocation step taking an operation as parameter changes the object state and returns a response to the invoking processor in a single step and according to the transition relation of the object.Let an input vector be a partial function from processor to input and an output vector be a partial function from processor to output. A task is a partial function mapping an input vector to a set of output vectors which have the same domain as the input vector. Informally given the set of participating processors in a run and their input a task describes the allowed outputs of those processors. A task input step does not return any response to a processor while a task output step non deterministically produces a response such that the output vector of the task as observed so far can be completed to an output vector in relation with the input vector of the task as observed so far.An algorithm assigns an initial local state and a deterministic sequential program to every processor subject to the constraint that if a processor takes a task input step then its next step must be the corresponding task output step . A run of an algorithm consists of an input vector and an infinite sequence of processor steps where each processor starts with the input assigned to it by the input vector and takes steps according to the algorithm. A processor may terminate by finishing its program and writing an output in its local state in which case it only takes stuttering steps i.e. steps that do not change its state thereafter. An algorithm is wait free if every processor that takes infinitely many steps eventually terminates.We say that a processor p participates in a run if p takes at least one step. Throughout the paper we write Q for the set of participating processors in a run and k for their number k Q .An algorithm solves a task Δ when .the algorithm is safe in every run in which the input vector is in the domain of Δ and all participating processors terminate the input vector is related by the task Δ to the output vector observed in the run and.the algorithm is wait free. Note that in most of the tasks that we use in this paper a processor receives no input. In this case a task reduces to a relation between participating sets and output vector.In the consensus task a processor receives an input its proposal. When a processor gets an output v from the consensus task we say that the processor decide v. The specification of the consensus task ensures that if two processors decide they decide the same value and if a processor decides some value v v has been proposed by some processor. Herlihy proved that objects that solve the consensus problem for n processors in shared memory can be used to obtain a wait free implementation of any object for n or fewer processors. This leads to the idea of classifying object types according to their consensus number.The consensus number of a task or object type is the maximum number of processors for which there exists a wait free algorithm that solves the consensus task using registers and instances of the task or object type. By convention every task or object has consensus number at least . Consensus is impossible to solve with registers even for two processors therefore registers have consensus number .Throughout the paper we make use of solutions to the following three input less tasks. In the test and set task exactly one participant must output while all others must output . Test and set has consensus number therefore it has no read write wait free solution. However test and set can be solved using processors consensus.In the immediate snapshot task each participating processor p must output a set of participating processors is p such that p∈is p and for every two processors p and q is p ⊆is q or is q ⊆is p and if p∈is q then is p ⊆is q . The immediate snapshot task is solvable read write wait free. From the definition of the immediate snapshot we get the following property Property If processors that invoke immediate snapshot form a set Q then one of them gets Q as output.Consider a run of the algorithm in which a set Q of k processors participate and consider the immediate snapshots IS … ISm obtained by the participants ordered by inclusion and let IS ∅. Define the sequence of sets of processors G … Gm where Gi ISi∖ISi and let G ∅. By definition of immediate snapshot a processor of G gets IS a processor of G gets IS Property A processors gets immediate snapshot ISi if and only if it belongs to Gi.In the k adaptive renaming task each participating processor p must output a unique integer name p called p s name such that for every k when k processors participate ≤name p ≤k . The k adaptive renaming task is solvable read write wait free.In a long lived problem a processor receives a new input each time it produces an output and must match the new input with an output. We consider long lived problems that can be specified as tasks for infinitely many processors i.e. such that there is a task Δ for infinitely many processors such that a solution to Δ can be transformed into a solution to the long lived problem by having each processor pick a fresh identifier for itself each time it receives a new input e.g. by using identifiers of the form 〈p i〉 where i is an integer incremented each time a fresh identifier is needed .Note that this class of long lived problem excludes problems in which a processor operation is constrained by the operations it performed before. An example of task that is outside the class is the long lived renaming problem in which a processor can release a name only if it previously acquired it. Also note that in a long lived problem for n processors the number of concurrent processors is trivially bounded by n. Therefore since we consider tasks for infinitely many processors only as a model of long lived problems we will assume that the number of processors active at any given moment i.e. the number of participants minus the number of processors that terminated is always bounded by n.. The allocation problemConsider a set R of r≥n items numbered to r to allocate to the processors. In the allocation problem we would like each processor p∈P to output a set D p ⊆R such that the family {D p }p∈P is a partition of R. We additionally require that if k processors participate then the allocation forms a partition of the first f k items for some strictly increasing function f N→N known by all processors such that f and f n r hence there are at least as many items as participants and all items are allocated if all processors participate . We also require that each processor gets at least one item.This definition is motivated by the following observations. If all we had required is that each processor get at least one item then the problem is trivial we can statically pre allocate items to processors and solve the problem without any synchronization. But we would still waste items if not all processors participate. Moreover if we allow the first processors to come to take all items then other processors may not get at least one item. By requiring that the first k processors get the first f k items we preclude trivial solutions while ensuring that each processor gets at least one item. Moreover this may help at least for provisioning items e.g. if one knows that only k processors will request items no need to provision more than f k .To define the allocation task we give the partial function mapping an input vector to a set of output vectors Definition In the allocation task given a strictly increasing function f N→N such that f and f n r processors have no input and each participating processor p must output a set D p ⊆R such that D p ≠∅ and if a set Q of k processors participate then {D p p∈Q} must be a partition of { … f k }.Given a solution to allocation processors can solve the consensus problem as follows. A processor p first posts its consensus proposal to shared memory and then participates in allocation and obtains an output D p . If ∈D p then p decides its own proposal. Otherwise p decides the proposal of the only other processor q. Observe that when a processor p is the only participant p must necessarily obtain ∈D p because according to the definition of allocation we must have D p {i ≤i≤f }. Therefore if a processor p sees ∉D p then there must be another participant and its proposal must be posted to shared memory. In the case of a system of processors the other participant q is determined and it must see ∈Dq because {D p D q } must be a partition of {i ≤i≤f } and therefore decide its own value. Therefore both participants decide the same value. This shows that allocation has consensus number at least .The allocation problem can be solved for any f using an array T of n test and set objects {T i ≤i≤n}. To solve allocation a processor p accesses the test and set objects one by one in order and stops at the first test and set object T i that it wins returning the set of items D p {j f i j≤f i }.This algorithm is presented in the PlusCal language in Fig. . The variables statement declares the global variables D and ret and initialize them to be arrays indexed by the set P of processors with D p and ret p initially Bot for each processor p. Bot means that these variables have an undefined value. N is the cardinal of P. The process statement declares there to be one process for each element of P the statement s body giving the code for processor self. The variable j is local to processor self current processor and cannot be read or written by other processors.Download Download high res image KB Download Download full size imageFig. . Algorithm for solving the allocation problem.In PlusCal an atomic action is the execution of code from one label to the next where there is an implicit label Done at the end. Line ret stores the return value of the TestAndSet procedure call Line . D is used to store the output of Allocation for each processor. Finally x..y is the set of integer k with x≤k≤y.Since allocation is solvable using test and set which is implementable from processors consensus it has consensus number at most . Theorem The allocation problem has consensus number .. Single use assignmentGiven a set R of items to allocate and function f N→N we formally define the assignment task as follows. Definition In the assignment task if a set Q of k processors participate each terminating processor must output a function a p D p →P whose domain D p is a set of items and such that Fairness For every processor p in Q there is r∈D p such that a p r p.Consistency For every processors p and q in Q if r∈D p and r∈D q then a p r a q r .Non Triviality .for every p∈Q D p ⊆{ … f k } and a p ranges over Q and.for every item i∈{ … f k } there is a processor p∈Q such that i∈D p . When a processor p terminates with output a p D p →P we say that p announces the items in D p . This definition is a formalization of the intuitive definition given in the introduction and restarted below. Fairness every processor that participates announces an assignment in which it gets at least one item.Consistency if two processors announce an assignment for item i then they assign i to the same processor.Non Triviality for every k if k processors participate then.only the first f k items may be assigned and.if all k processors terminate then every item in { … f k } is announced.We now present an algorithm for solving the assignment task assuming that f k k and R n . As noted in the introduction this matches a lower bound obtained by reducing the renaming problem to the assignment problem. The algorithm uses immediate snapshot and adaptive renaming sub routines. A formalization of the algorithm in PlusCal appears in Fig. . The variables statement declares the global variables participating firstitem is and a and initialize them to be arrays indexed by the set P of processors. name is an array indexed by a subset of processors. If i is a subset of processors name i is an array indexed by the set of processors. It will give a new name to processor in the set i. The define statement define the operators Name Assign. An action corresponds to each label. Weak fairness of an action a means that a process cannot halt at a if a remains forever enabled. Writing fair process instead of just process asserts that all actions of the process are by default weakly fair. is Lines contains the output of the procedure ImmediateSnapshot call Line . name contains the output of the procedure Renaming name is used Line to define Name and used Line after the call of the procedure Renaming Line . The with statement sets a self with Participant assign to the set the processors that participate Line .Download Download high res image KB Download Download full size imageFig. . Read write algorithm solving single use assignment.A processor p first writes in shared memory that it participates and then takes an immediate snapshot label l . Then p invokes an instance of adaptive renaming in which only the members of p s immediate snapshot participate obtaining the output Name p label l . Processor p then considers the item number is p Name p assigned to itself and writes it to shared memory in the variable firstItem p label l . At this point we say that p posted its first item moreover if firstItem q i for some q∈P and i∈R then we say that i has been posted. Finally at label l p checks whether there is a participant that did not post its first item. If this is the case then p announces only its first assigned item i.e. it outputs a p firstItem p ↦p .Otherwise when all the k participants posted their first item p announces the assignment of all first k items as follows. Let us say that an item among the first k is free if it has not been posted. Processor p assigns every posted item i to the processor q that posted firstItem q i this processor is unique by Lemma below and p assigns the ith free item to the processor q that posted the ith biggest item also unique by Lemma .To show that Fig. solves the assignment task we need the following definitions. Consider a run of the algorithm in which a set Q of k processors participate and consider the immediate snapshots IS … ISm obtained by the participants ordered by inclusion and let IS ∅. Define the sequence of sets of processors G … Gm where Gi ISi∖ISi and let G ∅. Finally define the sequence of intervals I … Im where Ii { ISi … ISi }. Note that if i j then Max Ii ≤Min Ij and that Ii Gi . Those definitions are best understood by considering the following lemmas.Lemma For every i∈{ … m} the members of Gi obtain unique first items in the interval Ii and only processors in Gi obtain items in Ii. ProofBy Property a processor obtains the immediate snapshot ISi if and only if it belongs to Gi. Moreover by definition of the algorithm only the members of Gi ever access the adaptive renaming instance for the set of processors Ii. Therefore by property of adaptive renaming as only Gi processors participate the members of Gi obtain unique names in { … Gi } and only processors in Gi obtain items in Ii { Ii … Ii }. Thus by definition of the algorithm at label l the members of Gi obtain unique first items in Ii and only processors in Gi obtain items in Ii. □ Note that Lemma implies that every processor gets a unique first item.Lemma Every processor p that takes the else branch at label l does so with Participant ISi for some i∈{ … m}. ProofBy definition of the algorithm when p takes the else branch at label l every processor invoked and returned the immediate snapshot at label l. Therefore by Property at least one processor obtained an immediate snapshot containing all the participants. □Let PostedBy i p if i is posted by processor p in the run under consideration and PostedBy i ⊥∉P otherwise. By Lemma PostedBy i is well defined.Lemma If p announces i and PostedBy i q then a p i q. ProofFirst since PostedBy i q when p announces its output note that q posted its item before p reached l. Consider two cases. First suppose p q. Therefore if p takes the if branch at l then it announces i↦p and we are done. If p takes the else branch then by definition of the Assign operator we have a p i p and we are done.Second suppose that p≠q. If p takes the if branch at l then it announces j↦p where PostedBy j p. By Lemma we must have i≠j and we are done. If p takes the else branch at l then by Lemma there is j∈{ … m} such that a p Assign ISj ISj is exactly the set of participants at this point and all members of ISj posted their first item. Therefore either a q did not participate yet and q∉ISj or b q∈ISj and q posted its first item.In case a q∈Gl for some l j therefore by Lemma item i is strictly greater than Max Ii . Moreover the domain of a p Assign ISj is Ij by definition of the Assign operator. Thus i∉a p and p does not announce i a contradiction.In case b we have a p i q by definition of the Assign operator and we are done. □Lemma If p takes the else branch at l before q takes the same else branch then for every item i announced by p i∈D q and a q i a p i . ProofBy Lemma there are j k∈{ … m} such that all members of ISk posted their first item by the time q takes the else branch at l and a p Assign ISj and a q Assign ISk .Note that at the time p takes the else branch at l all members of ISj posted their first item. A processor has rank i when its first item is the ith smallest posted item. Therefore by definition of the Assign operator the rank of a processors p∈ISj is the same in the definition of Assign ISj and in the definition Assign ISk . Moreover by Lemma the free items in the range { … Ij } do not change after p takes the else branch at l. Thus by definition of the Assign operator if i is announce by p then i is announce by q. Moreover if i is announced by p then a q i a p i . □Lemma If p takes the else branch at label l when there are k participants then p announces all items in D p { … k }. ProofBy definition of the Assign operator. □Lemma If all participants terminate at least one participant pl finds at label l that all participants posted their first item. ProofThe last participant to post its first item finds at l that all participants posted their first item. □Theorem The single use assignment algorithm of Fig. solves the assignment task using only registers. ProofThe algorithm clearly uses only registers and so does its immediate snapshot and adaptive renaming sub routines. Moreover its immediate snapshot and its adaptive renaming sub routines are wait free and every processor performs at most atomic steps in the algorithm therefore the algorithm is wait free. It remains to show that outputs satisfy the assignment task.Notice that every processor announces at least the item that it posted. Therefore the Fairness property of the assignment task is satisfied.To show the Consistency property consider two processors p and q that both announce item i. If both p and q take the if branch at label l then by Lemma they cannot both announce i. Therefore without loss of generality either p takes the if branch and q takes the else branch or both take the else branch at label l. Suppose p takes the if branch and q takes the else branch. Then i must be the item posted by p and by Lemma both p and q announce the same assignment for i and we are done. Suppose both p and q take the else branch at label l and without loss of generality that p does so before q. Then by Lemma if i is in the domain of a p then a q i a p i and we are done.Part of the Non Triviality property follows from Lemma because for every i∈{ … m} Ii⊆{ … k }. Part follows from Lemma the last participant to post its item pl sees all k participants and takes the else branch at l therefore by Lemma pl announces all the first k items. □Note that the algorithm is as fair as can be it guarantees that a processor gets at least one item and at most . Since k items are assigned when k processors participate this is optimal.Finally note that we can modify the algorithm to work with any function f such that f ≥ and f k f j ≥ k j for every k j∈N. For this we first change the first item of a processor p to be the item number f IS p Name p at label l and we change how a processor p that sees all the renaming output of the participants at label l else branch allocates the remaining items. Let k be the number of participants that p sees when it takes its step at label l. Processor p uses a larger domain {i ≤i≤f k } and for every j from to k p allocates the next f j f j free items to the processor of rank j when j k there may not remain enough items and in this case only the remaining free items are assigned .. Long lived assignmentWe now consider solving the assignment task for infinitely many processors assuming that the number of concurrently active processors is bounded by a constant. As explained in Section when the set of processors is fixed this allows processors to repeatedly invoke the task by picking a fresh identifier for each new invocation.The definition of the task is the same as in the single use case except that the set of processors P is infinite and the set of items R is also infinite. Items and processors are numbered … and we assume that f N→N is such that f k k .Note that we do not consider releasing items already assigned but only assigning new items from an infinite stream of items. The non triviality condition of the assignment task ensures that only the first k items may be assigned when k processors participate. In the long lived setting this means that processors cannot get items arbitrarily far in the stream if m is the number of times that processors invoked the task then only the first m items may be assigned.Obtaining a long lived assignment algorithm is simple it suffices to replace the immediate snapshot subroutine in the algorithm of Section by an immediate snapshot for infinitely many processors but bounded concurrency as provided e.g. by Afek et al. .Note that in the long lived setting if all processors progress at the same speed then the stream of items will be consumed without leaving holes. If not some items may be left unassigned while more and more items farther in the stream are assigned. In fact a processor can arbitrarily delay the allocation of an arbitrary large number of items if a processor p after reaching label l delays its posting of its first item then after p reached l every processor will only ever get a single item because at label l every processor will always find that p did not write firstItem p .We now present an optimization of the long lived algorithm in which a processor that stops can prevent the allocation of at most n items where n is the fixed number of processors that repeatedly invoke the algorithm. To achieve this property we first introduce a new label lb immediately after l where a processor posts to shared memory the immediate snapshot it obtained at label l. Second we modify the code at label l as follows a processor p at label l first checks whether it can find two immediate snapshots IS and IS that have been posted to shared memory such that p∈IS p∉IS and all members of IS∖IS have written their first item to shared memory. Two immediate snapshots 〈IS IS〉 with properties and are called a frame for p. Two immediate snapshots 〈IS IS〉 with properties and are called a complete frame for p. p checks this for any pair of immediate snapshot posted in shared memory.If p cannot find such a complete frame 〈IS IS〉 then it terminates with the output a p firstItem p ↦p . Otherwise p picks 〈IS IS〉 satisfying conditions and and such that IS∖IS is maximal among the complete frames for p. Finally p uses the same ranking mechanism as in the single use case to compute its output using the Assign IS IS operator except that it restricts the domain of its output to the items in the range { IS … IS }. A PlusCal formalization of the optimized long lived algorithm appears in Fig. .Download Download high res image KB Download Download full size imageFig. . Read write algorithm solving assignment for infinitely many processors when at most n are concurrent. A slow processor can block at most n items.Theorem The long lived assignment algorithm of Fig. solves the long lived assignment task using only registers.Proof sketch The algorithm correctness relies on essentially the same arguments as Theorem . The main difference is in Lemma and Lemma . If all participants terminate we consider the last participant pℓ to post its first item. Let ISmax the maximal immediate snapshot posted by the participants. By Property ISmax is exactly the set of participants. By the algorithm when p checks its frame ISmax is already posted. Thus pℓ finds that all participants posted their first item. Hence 〈{} ISmax〉 is a complete frame of pℓ. Moreover 〈{} ISmax〉 is maximal. Then pℓ announces all items in { ..m }. □Theorem When at most n processors can be active at the same time the long lived assignment algorithm of Fig. ensures that a processor that stops prevents the allocation of at most n items. ProofA processor can block the assignment of some items only if it stops after its first step but before it posts its first item. Consider a run in which p does so. Consider the immediate snapshots IS … ISm obtained by the participants ordered by inclusion. Let ISi i∈{ … m} be the biggest immediate snapshot in the run such that p∉ISi. By the definition of the algorithm at label l processor p prevents the allocation of all items in Ii { ISi … ISi } that are not posted by any processor. By property of immediate snapshot at worse ISi ISi n thus Ii ≤n . Among those n will be posted if only p stops and therefore p can prevent the allocation of n items at most. □. PlusCal specificationsPlusCal specifications of all the algorithms presented in this paper appear in this section. PlusCal has a formal semantics defined by a translation to TLA and those specifications therefore constitute unambiguous descriptions of the algorithms described in this paper.The PlusCal specifications can be model checked using the TLC model checker and using TLC we have verified their properties in a system of processors.Note that we specify tasks such as immediate snapshot and renaming as PlusCal procedures which return an arbitrary output that satisfies the relational specification of the task and to express the relational specification of the task we track which outputs have been produced so far.In each PlusCal specification the main algorithm appears in a process declaration at the end of the module... AllocationDownload Download high res image KB Download Download full size image.. AssignmentDownload Download high res image KB Download Download full size image.. LongLivedAssignmentDownload Download high res image KB Download Download full size image. Related workBelow we briefly survey related work on resource allocation and on the adaptive renaming problem whose solution we rely on in solving read write assignment.In the dining philosophers problem or the mutual exclusion problem a number of resources are to be acquired to perform a task and then released but there are not enough resources for all processor to perform their task at the same time. In the dining philosophers problem processors are placed in a ring with one resource between each neighboring pair of processors a processor contends for the two resources immediately adjacent to it in the ring. In the mutual exclusion problem processors share a single resource that they all contend for. Under the assumption that all processors progress fairly solutions to those problems must guarantee that no processor starve. The specification of the problem does not leave room for failures as it becomes trivially unsolvable when some resources are not released. Failures complicate allocation and increase the number of resources necessary to make the problem solvable. At the very least enough resources should be available to satisfy one processor should all others fail when holding resources.The L exclusion problem is a generalization of mutual exclusion in which at most L n processors can be in the critical section simultaneously. Here the failure of L processors in the critical section trivially halts the system but the algorithm presented in may also deadlocks if L processors fail when trying to enter the critical section.In the m renaming problem n processors must exclusively acquire a name between and m under one of two non triviality conditions either the initial identifiers of the processors are assumed to come from an unbounded namespace or in adaptive renaming the range of names used must depend on the set of processors that participate. The adaptive renaming problem is not solvable read write wait free when k processors out of n must perform renaming using the first k ⌈k/ n ⌉ names . With k names several wait free adaptive renaming algorithms are known . Increasing this bound one can obtain long lived wait free adaptive renaming algorithms in which names can be released by their owner . The musical chairs problem is a variant of renaming in which processors come with preferences and must rename themselves such that a processor gets his preferred name if no other participant has the same preference. The musical chairs problem is equivalent to renaming. The assignment problem defined in this paper differs from renaming or musical chairs in that all items must be assigned to some processor long lived assignment differs from the long lived version of renaming in that instead of releasing items processors consume items from an infinite stream.Castaneda et al. study single use assignment under preferences and constraints. The problem they study is a generalization of the renaming and musical chairs problems where processors must choose names subject to preferences that must be satisfied in the absence of conflict and subject to constraints that precludes certain assignments. As in the renaming problem the problem they formulate has no requirements to assign all the items. While the algorithms presented in this paper rely on renaming Castaneda et al. exhibit instances of the coordination task under preferences and constraints in which renaming based solutions may not be optimal.L assignment or “distinct CS” is a variant of L exclusion in which processors entering the critical section must additionally be assigned a unique slot out of a number L of slots. The At Most Once problem of Kentros et al. is closely related to L assignment and renaming. It is a single use allocation problem in which some items may be left unallocated. Kentros et al. give bounds on the number of items that can be allocated read write out of the total number of items called the efficiency of an algorithm depending on the number of processor failures. In contrast to our work Kentros et al. do not consider the possibility for a processor to leave with a partial allocation whose missing items will be revealed later by other processors. In follow up work Kentros et al. study deterministic solutions to the At Most Once problem that minimize the work that processors have to perform as well as randomized solutions under fair scheduling assumptions .In the Write All problem introduced by Kanellakis and Schwarzmann all positions in a shared array must be set using the minimal amount of work as measured in number of steps . The Write All problem differs from the allocation problem in that some positions in the array may be set by multiple processors while an item in the allocation and assignment problems must be allocated exclusively to one processor. In the terminology of this paper the Write All problem requires each item to be allocated at least once while the allocation and assignment problems requires each item to be allocated at most once. Dwork et al. study the Do All problem a variant of the Write All problem in message passing systems.The assignment algorithms presented in this paper are inspired by the adaptive renaming algorithm of Borowsky and Gafni . In this recursive algorithm processors use immediate snapshot to split themselves in disjoint groups that each is implicitly assigned a unique part of the namespace then each group recursively solves adaptive renaming among the members of the group. The part of the namespace allocated to a group is sufficiently big to place the outputs of the corresponding adaptive renaming sub problem in that part of the namespace. We reuse the idea of using immediate snapshot to split processors into groups that are implicitly assigned a unique part of the namespace that is big enough to solve renaming among the group members.. Conclusion We have shown that allocating items to asynchronous processors requires primitives of consensus number but that a new variation on the allocation problem the assignment problem is solvable read write wait free. Moreover we have presented a long lived assignment algorithm in which a failed processor can only prevent the allocation of a constant number of items. Long lived assignment can readily be solved using a mutual exclusion algorithm such as Lamport s Bakery algorithm . However in the Bakery algorithm a slow processor can arbitrarily delay the whole system even when the slow processor is not in its critical section. In contrast the optimized long lived assignment algorithm presented in Section ensures that a slow processors delays the assignment of at most n items while the other processors suffer no delay. The long lived assignment problem and its solution may therefore be of interest to implement resource allocators work queues and stream processing systems.We have studied long lived assignment without deallocation and we leave the investigation of deallocation to future work. Because long lived renaming i.e. with deallocation is solvable wait free we conjecture that long lived assignment with deallocation is solvable under a small lower bound on the number of “pending” items. In practice this bound would translate into a minimum required buffer space for pending items.Declaration of Competing InterestThe authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.