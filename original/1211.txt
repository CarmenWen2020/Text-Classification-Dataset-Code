Abstract
Public-key encryption with equality (PKEET) test enables testing if two ciphertexts, possibly under two different public keys, encrypt the same messages. Recent research on PKEET considers the setting where the testing ability is delegated to semi-trusted parties to negate unfettered chosen-plaintext attacks. In this work, we revise and enhance the PKEET security model, and introduce a new property of unmaskability which further prevents an attacker from skirting the test. We then propose a simple and efficient PKEET system with adaptive chosen-ciphertext security, provably secure under our revised security model, from either plain or ring lattice assumptions. The construction adopts a direct approach which significantly departs from the existing way of building such systems. Compared with existing literature, our system relies on weaker learning-with-errors assumptions while also being more efficient and providing better security.

Keywords
Public-key encryption
Equality test
CCA security
Lattices

1. Introduction
Public-key (randomised) encryption with equality test (PKEET) allows detecting encryptions of the same message. Specifically, given two ciphertexts , 
 encrypted under two (possibly different) public keys  and 
, a PKEET system allows performing an efficient testing procedure to reveal whether  and 
 are encryptions of the same message, without decrypting them. This feature is desirable and it naturally enables many interesting applications such as searching keywords over encrypted data, de-duplication, and partitioning encrypted data [1].

Yang et al. [1] originally introduced the notion of PKEET and proposed the first such system. In their system, the equality test can be performed by any party using any two ciphertexts. As noted in [1], such an unrestricted equality test leaks non-trivial information of the plaintexts from the corresponding ciphertexts. Therefore, the standard ciphertext indistinguishability notions for public-key encryption, e.g., IND-CPA or IND-CCA, are unachievable. Follow-up works (e.g., [2], [3]) considered delegating testability to semi-trusted agents from the private key holders, in the so-called testability-delegation model. For instance, the private-key holders of  and 
 would generate testing tokens  and 
, respectively. An authorised agent having obtained both tokens can then perform equality tests on ciphertexts encrypted under  and 
. In this model, ciphertext indistinguishability notions can be achieved against unauthorised parties or outsiders, i.e., adversaries who do not have the testing tokens.

When it comes to message confidentiality against insiders, i.e., testing token holders, the security models used by existing works consider the so-called one-wayness for random messages. More specifically, the notion stipulates that the adversary who has the testing token, i.e., an insider, should not be able to fully recover the message from the ciphertext, provided the message is drawn uniformly at random from a sufficiently large set (e.g., 
 for some security parameter ), independent of the adversary's view. This is a rather limited security notion since encrypting completely random messages independent of the adversary's view is not realistic, not least because side-channel information about the messages is often available to the adversary (especially insider ones).

There have been a number of constructions of PKEET based on number-theoretic assumptions (e.g., hardness of the discrete logarithm) in the testability-delegation model [2], [3], [4], [5]. However, these constructions are not secure under scalable quantum computers, as their underlying number-theoretic assumptions are contradicted by Shor's algorithm [6]. Existing quantum-secure candidate constructions of PKEET are based on lattice assumptions, e.g., [7], [8]. These lattice-based constructions largely follow one approach, the so-called “one system, two instances” construction. This approach independently uses two instances of one public-key encryption system. One instance is used to encrypt the actual message, and the other one is used to encrypt a (one-way) hash of the message. A token is simply the private decryption key of the instance that encrypts the hash of the message. Unfortunately, this approach is undesirable in terms of ciphertext overhead and general efficiency. Characteristically, those PKEET constructions suffer from a doubled ciphertext size compared to the underlying “one system”. Even more importantly, the “one-system, two-instances” approach is inherently vulnerable to malicious ciphertext constructions intended to mask the existence of identical plaintexts: something which we remedy in this work with the introduction of a new “unmaskability” property.

Moreover, the known lattice-based constructions of PKEET [7], [8] use heavy lattice cryptographic machinery, including ABB lattice-basis delegation [9], [10], [11] (for constructing a lattice 2-level hierarchical identity-based encryption in [12]), Boyen lattice-mixing technique [9], [13], and GPV pre-image samplings [14], [15]. The use of all this machinery seems a bit overkill for what amounts to mere public-key encryption. Not only does it lower the computational efficiency and increase the public-key size of the resulting systems, but it also forces the use of (quantitatively) stronger lattice assumptions, which, in turn, further decreases efficiency for a given security level. A natural question is whether we can construct efficient lattice-based public-key encryption systems with equality test while avoiding the two-instance structure and heavy lattice cryptographic machinery.

1.1. Our contributions
Our contributions is twofold. First, we revise the widely used security model of PKEET, and propose new and enhanced security notions that capture realistic threats to PKEET systems. Second, we provide a lattice-based post-quantum construction of PKEET with chosen-ciphertext security in the plain model that meet our new security notions.

Revised PKEET security model  Foremost, we explicitly consider that the adversary may craft malformed ciphertexts that decrypt to the same message, but at the same time, fail to reveal this through the testing function, (i.e., the test would say “not equal” even though they are equal). We define the security notion against this attack, and name it “unmaskability”. It means that no adversary should be able to “mask” the fact that two ciphertexts decrypt to the same message. We stress that this is a necessary security property for many of the practical applications of PKEET, e.g., searchable encryption and encrypted database partitioning, originally suggested by Yang et al. [1]. For instance, breaking unmaskability allows the adversary to come up with two encryptions with the same keyword but prevent the searching functionality from correctly detecting the keywords.

We note that in the existing PKEET systems [2], [3], [4], [5], [7], [8] under the delegated testability model, a ciphertext contains an encryption of the message and an encryption of the hash value of the message. The private decryption key allows recovery of the message and the hash value. After recovering the message and the hash value, the decryption algorithm checks whether the hash value matches the message, and only returns the message if the check passes. Though quite a natural thing to do, this appears to be “folklore”, as to the best of our knowledge, none of the existing PKEET proposals have provided a formal explanation on why the hash matching check is done. It turns out that such an extra check in decryption ensures unmaskability. Thus, according to our unmashability notion, performing the hash matching check in “one system, two instances” PKEET constructions indeed increases their security. In fact, there exists PKEET systems, e.g., [4], that do not do the matching check and are thus subject to the unmaskability attack.

The reader will have noticed that “unmaskability” as we define it is an asymmetric notion, in that it requires that equal plaintexts always be detected as such, but does not impose the converse requirement that two different plaintexts always be found unequal, which is akin to “collision resistance”. The reality is that a failure of the latter would typically result in mere denial-of-service (DoS) inconveniences, while a failure of the former may have much more serious security implications, e.g., when using PKEET as the basis for a CCA-secure simulator construction where a negative equality test result is used to allow decryption to proceed. The interesting question of constructing PKEET with both unmaskability and collision resistance without extraneous overhead is left for future research.

Our second enhancement to the security model is on message confidentiality against insiders (i.e., the test token holders). Our new confidentiality notion requires that the adversary who has the testing token cannot distinguish between a random ciphertext and a ciphertext that encrypts a message from a sufficiently unpredictable distribution, i.e., a high-min-entropy distribution. Such a definition draws inspirations from the notion of public-key deterministic encryption, e.g., [16], [17]. We note that Lu et al. [18] address a similar issue but in the model where equality test can be performed without tokens (i.e. the model proposed in [1]).

An efficient CCA-secure PKEET system from lattices  We propose an efficient construction of lattice-based PKEET in the plain model, which satisfies our enhanced security notions for message confidentiality and testing unmaskability. The construction departs from the “one system, two instances” structure, and also avoids “heavy” lattice machinery, such as the previously mentioned hierarchical IBE (used by Lee et al. [7]), pre-image sampling (used by Duong et [19]), and lattice mixing (also used by Duong et [19]).

To explain our idea, we start from the dual-Regev public-key encryption system [14]. The public key of the system includes random matrices 
 and 
. The private key is a low-norm matrix 
 such that . The ciphertext for a string 
 is 
 and 
 where 
 is random and 
, 
 are low-norm noise vectors. Decryption is done by computing 
 and rounding the entries of the resulted vector to the nearest integers. Note that D is not useful in solving the instance of LWE problem 
, i.e., finding the secret s. To see this, 
 can also be constructed using 
 and D (without s) by LWE sample amplifications [20], [21], [22], i.e.,
 where v is a discrete Gaussian and 
. For appropriately chosen parameters and without knowing D, the distribution of 
 is statistically close the distribution of e. In this paper, we use the LWE sample re-randomisation algorithm  from [20] to implement this procedure. Using this observation, we can use dual-Regev encryption to encrypt , i.e., the hash  of the message , and encrypt the actual message  with additional LWE samples. As a result, the ciphertext becomes 
, 
, and 
. The matrix 
 is included in the public key, a low-norm matrix R such that 
 is the decryption key, and D can be safely given to a testing agent without leaking the information of , which is protected by the other LWE samples 
 and 
. To perform equality test, a semi-trusted agent applies two tokens 
 to recover and compare the hashes of the messages, i.e.,  and 
.

Obviously, we cannot invoke the hardness of the LWE problem to argue that 
 retains the secrecy of  (and thus ) in any distinguishing attack, when D is known to the adversary. However,  can retain meaningful secrecy against plaintext recovery in the case where  is drawn from a source with high min-entropy which is retained by H, in similar way to the security notions of deterministic public-key encryption, e.g., [16], [17], [23].

We leverage the above idea to construct our CCA-secure PKEET system in the plain model by interoperating it into the CCA1-secure public-key encryption system given in [15], and then applying the BCHK transformation [24] with a strongly unforgeable one-time signature system. We note that by using the techniques from [25], [26], strongly unforgeable one-time signatures can also be avoided. We also note that our construction can be directly adapted to the (more efficient, but arguably riskier) ring lattice setting. Analysis provided in Section 6 demonstrates that our construction outperforms the known lattice-based PKEET constructions.

1.2. Organisation
The rest of the paper is organised as follows. Background on randomness extraction, lattices, discrete Gaussians and computational assumptions are provided in Section 2. We formally define the syntax and security of PKEET in Section 3. Section 4 describes our CCA-secure PKEET system from plain lattices and its security proofs. Section 5 gives the ring lattice version of our PKEET system. Efficiency comparison and concrete parameters are given in Section 6, then wrapping up with our Conclusion.

2. Preliminaries
Let R be a matrix in 
. We use  to denote the Euclidean norm of the longest column of R, and 
 to denote the largest magnitude of the entries in R. Let 
 denote the operator norm of R, i.e., 
. We use symbol “⊺” for matrix/vector transpose, e.g., 
 means the transpose of A. For any integer q, 
, the algorithm  returns 0 if x is closer to 0 than to  modulo q; otherwise, it returns 1. The rounding algorithm naturally extends component-wise to vectors. We will be using standard asymptotic notations, e.g., O, Ω, ω. Letting , the function  is said to be negligible if 
; this is written . The following lemma is useful in our security proofs.

Lemma 1

Lemma 1 of [27]
Let 
, 
, B be events defined in some probability distribution, and suppose that 
. Then 
.

Randomness extraction  Let X and Y be two random variables over some finite set S. The statistical distance between X and Y, denoted as , is defined as 
 
. Let 
 and 
 be ensembles of random variables indexed by the security parameter λ. We say X and Y are statistically close for some security parameter λ if 
. The min-entropy of a random variable X over a set S is defined as 
.

Lemma 2

[28] Lemma 2.1
Let 
 is universal, i.e., for all 
, with 
, 
 
 over the random choice of . Then for any random variable W over 
, and 
 where , then 
.

2.1. Lattices and discrete Gaussians
Let q be a prime, 
 and 
. A q-ary lattice is defined as 
. Let  be a positive integer and 
. For any real vector 
 and positive parameter 
, let the Gaussian function 
 on 
 with centre 0 and parameter σ. Define the discrete Gaussian distribution over Λ with centre 0 and parameter σ as 
 for , where 
.

Lemma 3

[15]
Let  and 
 where  is polynomial in n. If A and B be matrices chosen uniformly in 
 and 
 respectively, then, the distribution  is statistically close to the distribution .

The following lemma bounds the length of a discrete Gaussian vector.
Lemma 4

[29]
For any lattice Λ of integer dimension m, and parameter , 
.

The following lemma, due to Katsumata and Yamada, is very useful in the security analysis of our constructions.

Lemma 5

[20], Lemma 1
Let  be positive integers and r a positive real satisfying . Let 
 be arbitrary and 
. Then there exists an efficient algorithm  such that for any 
 and positive real 
, the output of 
 is distributed as 
 where the distribution of 
 is within 
 statistical distance of 
.

Lemma 6

Special case of Lemma 2.9, [15]
Let ,  be integers and  be a Gaussian parameter. For 
, there exists a universal constant  such that for any , 
 except with probability at most 
.

Lattice trapdoor  Let ,  and . Set , and the n-by-w gadget matrix ([15]) is defined as 
. The following lemma which is directly derived from the Theorem 4.1 and Theorem 5.4 and of [15].

Lemma 7

Let  where 
, 
, 
 is invertible in 
, and 
 is the gadget matrix. Given 
 where 
, there exists an efficient algorithm  that output s and e when 
.

2.2. Computational assumptions
The security of our constructions are based on the earning-with-errors (LWE) problem introduced by Regev [22]. Below we follow the work of [30] for the formulation of the LWE problem.

Definition 2.1 LWE

Let  be the security parameter and  be a positive integer. For integers  and an error distribution χ over 
, the advantage of a p.p.t. adversary  for the learning with errors problem 
 is defined as
 where 
, 
, 
 and 
. We say 
 assumption holds if for all p.p.t. adversary , 
.

These definitions depend on a parameter  which captures the noise-to-module ratio (i.e., how relatively large the errors are) in the LWE problem: the larger α becomes, the noiser the data and the harder the problem is. Regev [22] shows that for  is as hard as approximating some traditional worst-case lattice problems, e.g., the Shortest Independent Vectors problem (SIVP). We refer to [22] for details.

Definition 2.2

Let κ be the security parameter, , . Let 
 be a collection of functions. We say  is collision resistant if for all p.p.t. adversary, over the random choice of , 
 

2.3. One-time signature
Our PKEET scheme uses a one-time signature that is strongly unforgeable under chosen-message attacks to achieve chosen-ciphertext security. This method was originally proposed by Boneh et al. [24]. A one-time signature consists of three p.p.t. algorithms. The key generation algorithm  takes as input the security parameter and returns a pair of verification key and signing key . The signing algorithm takes as input ,  and a message M and returns σ a signature of M. The verification algorithm  takes as input , a massage M and a signature σ and outputs 1 indicating σ is a valid signature on M or outputs 0, otherwise.

Definition 2.3

Let κ be the security parameter. An adversary 's advantage in attacking a one-time signature scheme Σ is termed as 
 where the experiment 
 is defined in Fig. 1. We say a one-time signature scheme is strongly unforgeable under chosen-message attacks if for any p.p.t. adversary ,
 for some negligible function .

Fig. 1
Download : Download high-res image (36KB)
Download : Download full-size image
Fig. 1. Security Experiment for Unforgeability.

There are several efficient strongly unforgeable one-time signature schemes suitable for our PKEET scheme. For example, the Lamport one-time signature system [31] (instantiated using a secure collision-resistant hash function) and the Lyubashevsky-Micciancio one-time signature [32].

3. Definitions
3.1. Syntax of PKEET
A PKEET system consists of six efficient algorithms. The algorithm 
 takes as input the security parameter , and returns public parameters .  also defines the message space . We assume that the other algorithms implicitly take  as a part of their inputs. The algorithm  returns a pair of public key and private key . The encryption algorithm  encrypts a message  and returns a ciphertext . The decryption algorithm  decrypts the ciphertext  using . It returns a message in , or special symbol ⊥ indication an error happens. The token generation algorithm  returns a token . The testing algorithm 
 takes as input ciphertext-token pairs  and 
. It outputs 1, indicating  and 
 are the encryption of the same message, or 0, otherwise. It may also output ⊥ indicating an error happens.

A PKEET system should satisfy the standard correctness of decryption. That is for any security parameter λ, and any 
, any , and any message , we have where the probability is over the randomness of the algorithms.

We require the PKEET system to have testing correctness. That is, for any security parameter λ, any 
, any , 
, , 
, for any messages  and 
 from the message space, and , 
,

•
if 
, then 
, and

•
if 
, then 
,

where the probability is taken over the randomness of the algorithms.
3.2. Security of PKEET
For plaintext confidentiality, we consider two types of adversary depending on the possession of testing tokens. We stress that the private key of the target is not given to either type of adversary.

•
Type-I (Insider) Adversary: The adversary obtains tokens from users who have the private keys, including the target user. The adversary can therefore test plaintext equality among ciphertexts.

•
Type-II (Outsider) Adversary: The adversary does not have the testing token from the target user.

A random variable X is called a k-source if the entropy of X is no less than k, i.e., 
.
Security against a Type-I adversary is defined by its advantage against the PKEET scheme while being allowed to choose the distribution of the messages (or more precisely, efficient algorithms to sample from those distributions). The advantage of a Type-I adversary  for k-sources messages against a PKEET scheme Π is defined as
 where the experiment 
 is defined in Fig. 2. Similarly to the common confidentiality definition of public-key deterministic encryption (e.g. [16]), we allow the adversary to specify challenge message distributions that are independent of the public key , which is a reasonable assumption as argued in [16]. We remark that one can easily define a stronger security notion by allowing the adversary to choose the challenge message distributions after seeing ; but, similarly to the setting of public-key deterministic encryption, constructing an efficient PKEET scheme that achieves such security appears to be very challenging. We leave it as a future work.

Fig. 2
Download : Download high-res image (94KB)
Download : Download full-size image
Fig. 2. Security Experiments for Confidentiality.

Definition 3.1 PRIV-CCA2 Security

A PKEET scheme Π is PRIV-CCA2-secure if for all Type-I adversary  for k-sources messages,
 where  is some negligible function in λ.

Security against a Type-II adversary is defined in the traditional way, i.e., ciphertext indistinguishability against adaptive chosen-ciphertext attacks, where the adversary directly chooses the challenge messages. The advantage of a Type-II adversary against a PKEET scheme Π is defined as
 where the experiment 
 is defined in the right part of Fig. 2.

Definition 3.2 IND-CCA2 Security

A PKEET scheme Π is IND-CCA2-secure if for all Type-II adversary ,
 where  is some negligible function in λ.

Additionally, we consider a new security property for PKEET called unmaskability. We define unmaskability in a very strong sense that even with the private keys and testing tokens, no adversary can fool the test by “masking” the fact that two ciphertexts decrypt to the same plaintext in the message space. We also define two weaker versions of unmaskability where (1) the private keys, and (2) even the testing tokens, are withheld from the adversary. We define the advantage of an adversary  against unmaskability of a PKEET scheme Π as
 where the experiment 
 is showed in Fig. 3.

Fig. 3
Download : Download high-res image (44KB)
Download : Download full-size image
Fig. 3. Security Experiment for Unmaskability.

Definition 3.3 Strong Unmaskability

We say that a PKEET scheme Π has strong unmaskability if for any p.p.t. adversary , 
.

4. CCA-secure PKEET scheme from plain lattices
In this section, we describe our PKEET system using plain lattices. We remark that our construction extends immediately to ring lattice setting. This is because the techniques our construction makes use of, i.e., the gadget lattice trapdoor [15], LWE noise re-randomisation method [20], full-rank difference encodings [9], [33] and strongly unforgeable one-time signatures (e.g., [31], [32]) can be straightforwardly adopted to ring setting. For completeness, we describe our ring lattice-based construction in §5.

We use the function  several times so we recall its definition here. For any integer q, 
, the algorithm  returns 0 if x is closer to 0 than to  modulo q; otherwise, it returns 1. The function  naturally extends coordinate-wise to vectors over 
.

4.1. The construction from plain lattices
Let  be a security parameter. We assume all other parameters to be functions of λ. The construction uses a set of public parameters  that we specify here. We assume that all algorithms in the construction implicitly take  as inputs. The construction is described as follows.

•
 The system setup algorithm does:

–
Choose positive integers ; Set  and  and define the message space 
. For integer , set  where  is negligible in λ.

–
Choose Gaussian parameters  (which will be specified later).

–
Choose a strongly unforgeable one-time signature scheme  with verification key space .

–
Choose a full-rank difference (FRD) encoding function 
 where for any  and ,  is invertible in 
. We refer to [9] for actual constructions of φ.1

–
Choose a function 
 uniformly at random a family of hash functions 
 that are collision-resistant and universal.

–
Return public parameters is .

•
 The key generation algorithm does:

1.
Sample 
, 
 and compute .

2.
Sample 
; Sample 
 and compute 
.

3.
Output 
, .

 To encrypt a message 
, the algorithm does:

1.
Generate 
.

2.
Sample 
, 
, 
, 
, 
.

3.
Set  and compute
 and

4.
Compute a signature 
.

5.
Output the ciphertext as

•
 The decryption algorithm works as follows:

1.
Parse 
; Output ⊥ and abort if  fails to parse.

2.
Output ⊥ and abort if 
.

3.
Invoke 
 to get s, 
, and 
. If the call of  fails, output ⊥ and abort.

4.
If 
, or 
, or 
, output ⊥ and abort.

5.
Set 
, compute 
.

6.
If 
, or 
, output ⊥ and abort.

7.
If , return ; otherwise output ⊥ and abort.

•
 The testing-token extraction algorithm returns .

•
 The testing algorithm does the followings:

1.
Parse 
 and 
; Return ⊥ and abort if the ciphertexts do not parse.

2.
Return ⊥ if 
 or 
.

3.
Let 
, 
; compute 
 and 
.

4.
Output 1 if 
 at every component; output 0 otherwise.

Remark 1

In step 4 of the decryption algorithm, our construction checks the norm of 
 and of the product 
. This is for ensuring unmaskability, to ensure that the testing token can recover the hash of the message, i.e., . Without this check, the adversary with knowledge of D may be able to sample 
 “in alignment with” D such that the norm of 
 is large enough to prevent the testing function from recovering h, even though 
 is still small. Incidentally, the fortuitous occurrence of such alignments, even without adversarial action, is a primary reason why many lattice-based ciphers generally can have negligibly close but not perfect correctness.

Another way to ensure unmaskability would be to recover  and compare  against  during decryption, as several PKEET systems [2], [3], [4], [5], [7], [8] already do (if only perhaps for reasons of folklore as noted in the introduction). Such a test forces the decryption algorithm to reject the ciphertext when the embedded hash value is incompatible with the decrypted message. To fool such an equality test, the adversary would need to create two ciphertexts such that 
 and 
, which is clearly impossible for a deterministic hash function. Although we do not know why such tests were proposed in the first place, our notion of unmaskability provides a neat ex post justification for intuitively correct design.

4.2. Correctness
In order to rely on known hardness conjectures regarding the LWE problem, i.e., [22], we first select a parameter  for . Let 
, the operator norm of R, where 
. We set , and apply Lemma 4 to get 
, 
, and , with all but negligible probability. Per Lemma 7, also with all but negligible probability,
 So, the algorithm 
 will output s (thus 
 and 
) except with negligible probability. Since with overwhelming probability 
 and 
, it follows that 
 returns  with overwhelming probability.

To show testing correctness, without loss of generality, let 
 and 
 be two ciphertexts that encrypt messages , 
, and  and 
 be two testing tokens. By our parameter settings, we have
 Therefore, 
 and 
 give  and 
 respectively with all but negligible probability. If 
, we must have 
, and the algorithm  returns 1 with overwhelming probability. On the other hand, if 
, 
 happens with probability 
 which is negligible in λ, and therefore,  returns 1 with negligible probability.

4.3. CCA security against type-II adversary
In this section, we provide security proofs for our constructions. We first prove chosen-ciphertext security against Type-II adversaries. This shows that, for outsiders who do not have the testing token, both  and  remain hidden and indistinguishable. Security against Type-I adversaries follows from the intuition given in Section 1. That is, the testing token D does not help the attacker to extract any non-trivial information about  hidden in 
. The only information about  that the attacker can obtain is from  (encoded in 
). However, this is again not viable, because H is universal and  has sufficiently high min-entropy from the adversary's view.

Theorem 8 IND-CCA2 Security

The proposed PKEET scheme Π has IND-CCA2 security against Type-II adversaries. Particularity, if there is a p.p.t. adversary  who has advantage 
, there are efficient adversaries 
, 
, such that
 for some negligible function .

Proof (Proof of Theorem 8)

We define several security games and prove that the neighbouring games are indistinguishable either statistically or computationally. For , we denote by 
 the i-th security game, and by 
 the event that the adversary wins the security game 
, i.e., outputs 
.

:
This is the same as the real IND-CCA2 security game, i.e., 
, defined in Fig. 2. In particular, the public key and private key are generated as in the real scheme. The challenge ciphertext, which is created following the real encryption algorithm , is given as 
⁎
⁎
⁎
⁎
⁎
⁎
⁎
 where
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
 Decryption queries are answered by the decryption algorithm .

:
The game is the same as 
 except that it generates 
⁎
⁎
, a pair of verification key and signing key of the one-time signature scheme before running . 
⁎
 will still be used for constructing the challenge ciphertext as in 
.

:
The game is the same as 
 except any decryption query 
⁎
 (i.e., that contains the verification key 
⁎
 from the challenge ciphertext) is rejected.

:
This is the same as 
 except that in , 
⁎
, instead of  as in 
.

:
This is the same as 
 except that the challenge ciphertext components 
 and 
 are computed differently: now, 
⁎
⁎
⁎
 and 
⁎
⁎
.

:
This is the same as 
 except that the challenge ciphertext components 
⁎
⁎
⁎
⁎
 are chosen uniformly at random from their spaces, i.e., 
⁎
, 
⁎
, 
⁎
, and 
⁎
.

We proceed to provide the proof by showing that 
, the real attacking game, is computationally indistinguishable from 
, a modified attacking game in which the adversary has no advantage to win. Since 
 is the real attacking game, and the probability that the game outputs 1 (i.e., the adversary  successfully guesses the bit value b) is the same as 
, by definition, we have(1)
 The modification made in 
 from 
 doesn't change 's view. In particular, 
⁎
 is only available to  until the challenge ciphertext is published. So, we have(2)
 We then show the 
 is computationally indistinguishable from 
. In 
, let  be the event that  makes a valid decryption query 
⁎
, i.e.,  can be properly decrypted to a message in 
 and is different from the challenge ciphertext 
⁎
. We note that in 
, all decryption queries  with 
⁎
 are directly rejected. So, 
 and 
 are different if  happens and by Lemma 1 
.

We bound  by the strong unforgeability of the one-time signature scheme Σ. Let 
 be an algorithm that breaks Σ. The reduction works as follows. First, from its challenger, 
 receives 
⁎
 upon which it needs to make a forgery. 
 generates , , 
⁎
 (using 
⁎
), and simulates the decryption oracle as in 
. 
 aborts the simulation and returns 
 as its forgery as soon as  happens with query 
⁎
. We note that 
 is indeed a valid forgery: (1) we must have 
⁎
⁎
⁎
⁎
⁎
 because  is not allowed to submit the challenge ciphertext itself for a decryption query; (2) 
⁎
. Therefore, we must have 
 which gives(3)

Next, we show that 
 and 
 are statistically close. We note that the only difference between 
 and 
 is how the public parameter B is computed. In particular,  in 
 and 
⁎
 in 
 (where 
⁎
 has been chosen before the algorithm  is ran). By Lemma 3, the distributions of B in these two cases are statistically close. Therefore, the distributions of pk in 
 and 
 are statistically close.

We note that the simulation can answer all decryption queries using the algorithm  with the private key R. First, any decryption query with verification key 
⁎
 has already been rejected. Given a decryption query 
 where 
⁎
, we must have 
⁎
 and 
⁎
 is invertible over 
. Thus, we have
⁎
 and the algorithm 
⁎
 can be applied to recover s, 
, and 
. This shows that(4)
 for some negligible function 
 that captures the statistical errors.

Then, we show 
 and 
 to be statistically indistinguishable. Recall that in 
, the challenge ciphertext component 
⁎
⁎
 for some 
 from 
. Moreover, the challenge ciphertext component 
⁎
 in both 
 and 
. By Lemma 5 and the fact that 
 and 
, we have
⁎
⁎
⁎
⁎
⁎
⁎
 for some 
, a sample from a distribution statistically close to 
, and
⁎
⁎
⁎
⁎
⁎
 for some 
, a sample from a distribution which is statistically close to 
. Since 
⁎
 and 
⁎
 are the only changes we make in 
, we have(5)
 for some negligible function 
 that captures the statistically errors.

We show that 
 and 
 are computationally indistinguishable under the LWE assumption. We construct a reduction as follows. Let 
 be an LWE problem solver. It receives from its challenger an 
 problem instance 
 and needs to decide if 
 or if 
 for 
, 
, and 
. 
 sets the public key parameters 
 using the first m columns of 
 and sets 
 using the last t columns of 
. Since 
 is a uniformly random matrix, A and 
 are of correct distributions. 
 then generates the public key and private key as follows:

1.
Set 
⁎
⁎
.

2.
Sample 
 and compute 
⁎
.

3.
Sample 
 and set 
.

4.
Output 
 and .

 simulates the decryption oracle as in 
.
We can see that  has the correct distribution (
 and 
 have the same public key distribution). Moreover, 
 can properly simulate the decryption query as it knows the trapdoor R and all decryption queries with verification key 
⁎
 would have already been rejected. Next, 
 sets 
 (for unknown 
, 
) to be the left m coordinates of 
, and 
 (for unknown 
, 
) to be the right t coordinates of 
. Note, based on the LWE challenge, it is the case that either 
 and 
, or 
 and 
, are uniformly random. Given two messages 
⁎
⁎
 from , 
 flips a coin  and constructs the challenge ciphertext 
⁎
⁎
⁎
⁎
⁎
⁎
⁎
 as
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
 If 
 received its LWE challenge from LWE distribution, i.e., 
, then we have 
 and 
. Thus, 
⁎
 is a properly distributed ciphertext in 
. Otherwise, if b is uniformly random, i.e., 
 are random, we have
⁎
⁎
⁎
⁎
 for some 
 with a distribution statistically close to 
, and
⁎
⁎
 for some 
 with a distribution statistically close to 
. By Lemma 3, we have 
  
 
  
  
  
 
  
  where 
, 
, 
, and 
. This shows that 
⁎
⁎
⁎
⁎
 are masked by uniformly random terms 
, respectively, and they don't leak any information about R and D. In this case, 
 is simulating 
, which gives(6)
 Also, since the challenge ciphertext components 
⁎
⁎
⁎
⁎
 are all random, and, in particular, they are independent of the bit value , the adversary  has no advantage in guessing b correctly to win the game. So, we have(7)

Combining Eqs. (1) through (7) using the triangle inequality gives
 for some negligible function 
, which proves the theorem. □

4.4. CCA security against type-I adversary
Theorem 9 PRIV-CCA2 Security

The proposed PKEET scheme has PRIV-CCA2 security against Type-I adversaries. In particular, if there is a p.p.t. adversary  that has advantage 
, there are efficient adversaries 
, 
 such that
 for some negligible function .

Proof

We define several security games and prove that the neighbouring games are indistinguishable either statistically or computationally. For , we denote by 
 the i-th security game and 
 be the event that the adversary wins the security game 
, i.e., by outputting 
.

:
This is the same as the real security game 
 as defined in 2. In the beginning of the game, on input the security parameter λ, the adversary  outputs a message distribution  which is a k-source over the message space 
 where . Then, the public key and private key are generated by 
 and the testing token are generated by . After that, two chosen messages 
⁎
 and 
⁎
 and a bit  are sampled, and the challenge ciphertext 
⁎
⁎
⁎
⁎
⁎
⁎
⁎
 is constructed as
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
 The adversary  is then given pk, 
⁎
 and the token . The decryption queries from  are answered by the real decryption algorithm . Finally,  returns a guess 
 and it wins the game if 
.

:
This game is the same as 
 except that 
⁎
⁎
 is generated before running . 
⁎
 will, still be used for constructing the challenge ciphertext 
⁎
.

:
This is the same as 
 except that any decryption query 
⁎
⁎
, i.e., wherein the ciphertext contains the verification key 
⁎
, is rejected.

:
This is the same as 
 except that in , now 
⁎
, instead of  as in 
.

:
This is the same as 
 except that the challenge ciphertext components 
 and 
 are computed differently. Now, 
⁎
⁎
⁎
 and 
⁎
⁎
.

:
This is the same as 
 except that the challenge ciphertext components 
⁎
⁎
⁎
 are chosen uniformly at random from their spaces, i.e., 
⁎
, 
⁎
, and 
⁎
.

:
This is the same as 
 except 
⁎
 is constructed as 
⁎
⁎
 for a random string 
 and 
.

We proceed to provide the proof by showing that 
, the real attacking game, is computationally indistinguishable from 
, an modified attacking game in which the adversary has no advantage to win. Since 
 is the real attacking game, and the probability that the game outputs 1 (i.e., that the adversary  successfully guesses the bit value b) is the same as 
, by definition, we have(8)

Next, we argue that 
 and 
 are the same to the adversary. This is because in both games, 
⁎
 and  are generated independent of 's view. 
 differs from 
 simply by swapping the order of generation of  and 
⁎
, but the order is not visible to . Therefore, we have(9)

We then show that 
 and 
 is computationally indistinguishable. In 
, let  be the event that  makes a valid decryption query 
⁎
, i.e., s.t.,  can be properly decrypted to a message in 
 and is different from the challenge ciphertext 
⁎
. We note that in 
, all decryption queries  with 
⁎
 are directly rejected. So, 
 and 
 are different if  happens, and by Lemma 1 
.

We bound  by the strong unforgeability of the one-time signature scheme Σ. Let 
 be an algorithm that breaks Σ. The reduction works as follows. First, from its challenger 
 receives 
⁎
 upon which it needs to make a forgery. 
 generates , , 
⁎
 (using 
⁎
) as well as  (using ), and simulates the decryption oracle as in 
. 
 aborts the simulation and returns 
 as its forgery as soon as  happens with query 
⁎
. We note that 
 is indeed a valid forgery, since: (1) we must have 
⁎
⁎
⁎
⁎
⁎
 because  is not allowed to submit the challenge ciphertext as a decryption query; (2) 
⁎
. Therefore, we must have 
 which gives(10)

Next, we show that 
 and 
 are statistically indistinguishable. We note that the only difference between 
 and 
 is how the public parameter B is computed. In particular,  in 
 and 
⁎
 in 
 (where 
⁎
 has been chosen before the algorithm  is ran). By Lemma 3, the distributions of B in these two cases are both statistically close to the uniform distribution over 
. Therefore, the distributions of pk in 
 and 
 are statistically close.

We note that the simulation can answer all decryption queries using the algorithm  with the private key R. First, any decryption query with verification key 
⁎
 (which can not be decrypted using R) has already been rejected. Given a decryption query 
 where 
⁎
, we must have 
⁎
 and hence (by definition of FRD encodings) invertible over 
. Thus,
⁎
 and the algorithm 
, which is a subroutine of , can recover s, 
, and 
. This shows that(11)
 for some negligible function 
 that captures the statistical errors.

We then show 
 to be statistically indistinguishable from 
. Recall that in 
, the challenge ciphertext components 
⁎
⁎
 and 
⁎
⁎
 for some 
 and 
. Moreover, the challenge ciphertext component 
⁎
 with 
 in both 
 and 
. By Lemma 5 and the fact that 
 and 
, we have in 
⁎
⁎
⁎
⁎
⁎
⁎
 for some 
, a sample from a distribution statistically close to 
, and
⁎
⁎
⁎
⁎
⁎
 for some 
, a sample from a distribution which is statistically close to 
. Since 
⁎
 and 
⁎
 are the only changes we make in 
, we have(12)
 for some negligible function 
 that captures the statistical errors.

We prove that 
 is computationally indistinguishable from 
 if the LWE assumption holds. We construct a reduction that if 
 and 
 can be efficient distinguished, i.e., if there is an efficient adversary that can distinguish between 
 and 
, then there exists an efficient algorithm that can solve 
 problem. The reduction works as follows.

Let 
 be the LWE problem attacker; let it receive from its challenger an 
 problem instance 
. It needs to decide if 
 or if 
 for 
, 
, and 
.2 Given two messages 
⁎
⁎
 from k-sources 
 and 
, respectively, 
 sets the public key parameters 
 and 
 using the first m columns of 
 and the last t columns of 
, respectively. Since 
 is a uniformly random matrix, A and 
 are of correct joint distribution. 
 then generates the public key and private key as follows:

1.
Set 
⁎
⁎
.

2.
Sample 
 and compute 
⁎
.

3.
Sample 
 and set 
.

4.
Output 
 and .

 simulates the decryption oracle as in 
.
We can see that  has the correct distribution (
 and 
 have the same public key distribution up to negligible statistical distance). Moreover, 
 can properly simulate the decryption query as it knows the trapdoor R and all decryption queries with verification key 
⁎
 would have already been rejected. Next, 
 sets 
 (for unknown 
, 
) be the left m coordinates of 
, and 
 (for unknown 
, 
) be the right t coordinates of 
. Based on the LWE challenge, we have that, either 
 and 
, or 
 and 
, are uniformly random. 
 flips a coin  and constructs the challenge ciphertext 
⁎
⁎
⁎
⁎
⁎
⁎
⁎
 as
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
 If 
 received its LWE challenge from the LWE distribution, i.e., 
, we have 
 and 
; hence 
⁎
 is a properly distributed ciphertext in 
. Otherwise, if b is uniformly random, i.e., 
 are random, we have
⁎
⁎
⁎
⁎
 for some 
 with a distribution statistically close to 
 and independent of D (by Lemma 5, the distribution of 
 only depends on σ, the singular norm bound which is publicly known), and
⁎
⁎
 for some 
 with a distribution statistically close to 
. By Lemma 3, we have 
  
 
  
  where 
, and 
. This shows that 
⁎
⁎
⁎
 are uniformly random (since 
 are random) and do not leak any information about R. To sum up, in this case, 
 is simulating 
, and we have(13)

Finally, we show that 
 and 
 are statistically indistinguishable, and that in 
, the bit value b is completely hidden from the adversary 's view. Recall that in 
, 
⁎
⁎
 and the token D is known to . We note that 
 is an independently and randomly sampled universal hash function and 
⁎
 is a sample of the k-source 
 over 
 with 
 for some negligible function 
. By Lemma 2, we have
⁎
 where the random string 
. This leads to
⁎
 which means 
 and 
 are statistically indistinguishable, i.e.,(14)
 Moreover, we can see that in 
, the challenge 
⁎
 does not contain or depend on the chosen message 
⁎
, so the bit b is independent of 's view. This shows(15)
 Combining Eqs. (8) through (15), we have
 for some negligible function 
. This completes the proof. □

Theorem 10

The proposed PKEET scheme has strong unmaskability. In particular, letting λ be the security parameter, 
.

Proof

Following the security experiment, the challenger runs  (with the security parameter λ),  and  to generate two public keys 
, 
, their corresponding private keys 
, 
, and two testing tokens 
, 
. The adversary is given 
, 
, 
, 
, 
, 
. Finally, the adversary outputs two ciphertexts 
, 
. Two win the game, 
, 
 should be valid (i.e., not decrypt to the special symbol ⊥), they should decrypt to the same message in the message space, and the algorithm  should return 0.

We focus on one ciphertext, say 
, first. We assume the corresponding token is D, and 
 where
 and
 Since 
 decrypts to some message in the message space (as required by a successful attack), in step 4 of the decryption process, we have 
 and 
. Therefore, if the ciphertext 
 can be decrypted to a message 
, the testing algorithm can use D to recover 
 with probability negligibly close to 1 (by correctness of ).

Applying the same analysis, if 
 decrypts to a message 
, the testing algorithm 
 will recover the hash value 
 of the message 
, i.e., 
 from 
 using 
. This shows that if the testing algorithm returns 0, indicating 
, and 
 and 
 correctly decrypt to two messages 
 and 
, we must have 
. That is, the adversary has no advantage in winning the unmaskability security game, which proofs the theorem. □

5. The ring version of our PKEET construction
For completeness and to facilitate the efficiency comparison, we provide a ring-lattice version of our construction.3 In the construction, we denote the ring 
 where n is a power of 2. We denote 
. Let 
, and define the coefficient embedding function 
, i.e.,  returns the coefficients of a. The Euclidean norm of  with coefficients 
, written as  is defined as 
. For , the Euclidean norm of 
 is defined by 
 where 
 is the ith -element of a. The discrete Gaussian distribution 
 with Gaussian parameter  is defined as the distribution over  where the coefficients are sampled identically and independently from the Discrete Gaussian distribution 
. For , we use the gadget matrix 
 which is the ring extension of the gadget matrix defined over the integer ring 
. As per a series of works (e.g., [9], [33], [15], [34], [35], [20]), the gadget matrix, the lattice trapdoor, the LWE inversion method , the re-randomisation method (i.e., Theorem 5), and the full-rank difference encoding, translate to the ring lattice setting straightforwardly. We refer to the above references for further details.

Similar to our PKEET system using plain lattices, we utilise a collision-resistant and universal hash family, and a strongly unforgeable one-time signature system, which can be instantiated by the ring version of Ajtai's short integer solution (SIS) function (with regularity/leftover hash lemmas, e.g., [34], Theorem 7.4 and [35], Lemma 7) and its application to one-time signature applications, e.g., [32].

•
 The setup algorithm does:

1.
Choose positive integers  where ; Set  and define the message space 
; We also require the  where  is negligible in λ.

2.
Choose Gaussian parameters .

3.
Choose (parameters for) a strongly unforgeable one-time signature scheme  with verification key space .

4.
Choose a full-rank difference encoding 
 where 
 is the set of units in 
.4

5.
Choose a function 
 uniformly at random from a family of hash functions 
 that are collision-resistant and universal. We implicitly assume the inputs of H are elements in 
 which are bijectively mapped to bit strings in 
 via the reverse of coefficient embedding. The outputs of H, i.e., strings in 
, are coded as encoded as elements in  via coefficient embedding.

6.
Return the public parameters is .

•
 The key generation algorithm does:

1.
Choose 
, 
, and compute 
.

2.
Sample 
; Sample 
 and compute 
.

3.
Output 
, 
.

•
 To encrypt a message 
, the algorithm does:

1.
Sample 
.

2.
Sample 
, 
, 
, 
, 
.

3.
Set 
 which is encoded as an element in 
, and then compute
 and

4.
Compute a signature 
.

5.
Output the ciphertext as

•
 The decryption algorithm works as follows:

1.
Parse 
; Output ⊥ if  doesn't parse.

2.
Output ⊥ if 
 and abort.

3.
Invoke 
 to get s, 
, and 
. If the call of  fails, output ⊥ and abort.

4.
If 
 or 
, output ⊥ and abort.

5.
Set 
, compute 
.

6.
If 
, or 
, or 
, output ⊥ and abort.

7.
If , return ; Otherwise output ⊥.

•
 The algorithm returns 
.

•
 The testing algorithm does the followings:

1.
Parse 
 and 
; Return ⊥ if the ciphertexts do not parse.

2.
Return ⊥ if 
 or 
.

3.
Let 
, 
; Compute 
 and 
.

4.
Output 1 if 
, or 0 otherwise.

Encrypting larger messages  To encrypt messages in 
 where  for a positive integer Δ, the following standard technique for LWE encryption can be used [14], [9]: The system chooses a vector 
 (rather than a single element 
) and encodes the message into a element in 
 through coefficient embedding.

6. Efficiency consideration
In this section, we compare our two PKEET systems, from plain and ring lattices, with the various existing constructions of PKEET from lattices. We also give examples of concrete parameters which show that our (ring) lattice-based construction (whose parameters have not been optimised) is in fact efficient.

6.1. Efficiency comparison
We compare our PKEET system with the PKEET systems proposed by Lee et al. [7] and Duong et al. [19].5 These systems follow the “one system, two instance approach”, i.e., using two sets of independent randomness to the underlying encryption system to encrypt the message and the hash of the message. Lee et al. [7] proposed a generic construction of PKEET from level-2 hierarchical identity-based encryption (IBE) which can be instantiated by (ring) lattices, e.g., via the hierarchical IBE system from [9]. In the most recent version of [19], Duong et al. presented two PKEET constructions. The first one is based on the IBE system of Bert et al. [36], which is a ring variant of the plain lattice IBE system from [9]. The second construction applies the lattice mixing technique from [13] over plain lattices. Both of the two constrictions from [19] involve lattice pre-image samplings [14], [15] which can be quite inefficient, especially for parameter generation.

We consider the lattice instantiation of the scheme from [7] by directly following the 2-level ABB hierarchical identity-based encryption [9] and the BCHK transformation [24] (using a strongly unforgeable one-time signature and the signature verification keys are encoded as identities) as suggested in [7]. We note that the decryption process of the construction does not need the HIBE key extraction process. We also note that our instantiation extends to the ring setting immediately. We refer to Appendix B for the details of the construction for comparison purposes.

We compare our constructions with the PKEET systems proposed in [7], [19], in terms of LWE assumption parameters, size of public keys , size of private keys , size of ciphertexts , and size of testing tokens . Since all constructions can use the same one-time signature system, we leave it uninstantiated. The parameter  is known as the LWE noise-to-modulus ratio. The larger α is, the weaker the LWE assumption is (i.e., the harder the LWE problem becomes, and the safer the system, quantitatively speaking.).

In the tables, q and n denote the modulus and dimension of the (ring-)LWE secret, respectively.  and ψ respectively denote a verification key and a signature of the strongly unforgeable one-time signature used by the constructions. There are many strongly unforgeable one-time signature systems suitable for instantiating our constructions. We remark that Duong et al. considered using the signature system from [32] and proposed re-using some public parameters (e.g., the matrix 
 in the plain-lattice construction, or the element 
 in the ring-lattice one) as part of the signature verification key to reduce the ciphertext size. For fairness and for maximum efficiency, we applied this idea to all competing constructions when making our comparisons.

As noted in the introduction, we stress that the security model used in [7], [19] does not address unmaskability, and only considers a security notion against insiders (i.e., testing-token holders) that requires all messages to be truly random, which seems rather unrealistic in light of the stated purpose of PKEET.

Plain-lattice constructions  Table 1 compares our plain-lattice PKEET construction with the plain-lattice PKEET constructions given in Appendix B, i.e., a plain lattice instantiation of the PKEET system from [7] and from Section 4 of [19]. In the table, λ is the security parameter; the parameter , and, in order to invoke Lemma 3 in security proofs, . The value  is the smoothing parameter of the lattice 
, an important metric which inter alia measures how wide a discrete Gaussian sampled over the lattice (in this case, 
) needs to be to provide a good approximation of a continuous Gaussian over the same (further details in [29]). The parameter t is the bit length of the hashes of messages (required to be  to ensure λ-bit collision-resistance security against generic birthday-paradox attacks). In the constructions from [7], [19], the messages and their hashes have the same length, which is denoted by this t. In our construction, we hash t-bits messages into ℓ-bit hashes, as we need the hash function to be universal and compressing.


Table 1. Comparison Among the Plain Lattice Constructions.

Parameter α				
[7] (Appendix B)	
[19]	
This work	
Table 1 indicates that our plain lattice construction quantitatively outperforms the other two in terms of parameter sizes, thanks to avoiding the “one system, two instances” approach. Additionally, as it avoids much of the heavy lattice machinery using in earlier constructions (e.g., hierarchical identity-based encryption, trapdoor delegation, and pre-image sampling), our construction is also qualitatively better than the other two in the sense that our construction relies on weaker computational assumptions, as indicated by a larger α. In other words, for same parameters n, q, our construction would be more secure. Conversely, the testing tokens of Lee's et al. system described in Appendix B have a larger Gaussian parameter than testing tokens obtained via lattice trapdoor delegations, while the plain-lattice construction given in [19] suffers from a large public key size (i.e.,  public matrices) due to the use of the lattice mixing technique [13].

Ring-lattice constructions  Table 2 compares the ring-lattice version of our PKEET construction from Section 5, the ring-lattice construction by Duong et al. [19] restated for reference in Appendix A, as well as a ring-lattice instantiation of the generic construction from [7] which we spell out in Appendix B.


Table 2. Comparison Among the Ring Lattice Constructions.

Parameter α				
[7]	
[19]	
This work	
Let n be the dimension of the underlying ring-LWE problem (often referred to as the security parameter of LWE),  (per [35], Lemma 7, to ensure that private keys remain statistically hidden from public keys), and  (which is the dimension of the gadget matrix). As in the plain-lattice setting, λ denotes the security parameter of the PKEET system, α is the (ring-)LWE noise-to-modulus ratio, and .

We consider encrypting n-bit messages which can be handled by a single element in 
 (to encrypt messages with bit length larger than n, more 
-elements may be used). Table 2 shows that our construction is more efficient, in terms of parameter size, and more secure due to relying on a weaker LWE assumption.

Compared to plain-lattice constructions, ring-lattice constructions are more space-efficient and may bring substantial computational efficiency benefits owing to their richer algebraic structures. However, those richer algebraic structures also make these constructions potentially vulnerable to heretofore unknown, novel attacks, to which the plain-lattice constructions might be naturally immune. To put it bluntly, making quantitative comparisons of, say, α values, between constructions that rely on qualitatively different assumptions, such as plain-LWE versus ring-LWE, might lead to less-than-meaningful conclusions. We refer to [37] for further discussions.

6.2. Concrete parameters
We provide examples of concrete parameters for the various constructions in Table 3 and Table 4, based on the hardness of the 
 problem and its ring variant (over 
) respectively, and matching concrete instantiations of the strongly unforgeable one-time signature. The parameters n, m, q, α of the LWE problem are set to ensure correctness of decryption for all constructions and 128-bit security for our constructions. We use the LWE hardness estimator [38] for estimating the security level of the constructions. We use the same Lamport scheme [31] as the strongly unforgeable one-time signature subsystem in all PKEET systems.6 We instantiate the Lamport signature by using a collision resistant hash function with 256-bit outputs (e.g., SHA-256) for 128-bit security.7 We consider signing 256-bit messages (the messages being signed may themselves be hashes of the actual messages). The public verification key of the one-time signature contains  hash outputs, which is of size 217 bits. The signature of the system constitutes 256 pre-images of the hash function, which can be of size 216 bits.


Table 3. Concrete Parameters for Plain Lattice Constructions.

αq	 (KB)	 (KB)	Security
[7] (Plain Lattice)	1.04	15603.84	90.49	88-bit
[19] (Plain Lattice)	0.8	625467.28	69.43	84-bit
This work (Plain Lattice)	5.2	11168.64	47.84	128-bit

Table 4. Concrete Parameters for Ring Lattice Constructions.

αq	 (KB)	 (KB)	Security
[7] (Ring Lattice)	61.32	15.6	147.216	80-bit
[19] (Ring Lattice)	1.15	74.76	100.17	90-bit
This work (Ring Lattice)	5.2	38.64	63.22	128-bit
In Table 3, we use the parameters , , 
 and different αq (recall that the PKEET systems from [7], [19] require smaller α) for the plain-lattice constructions. We consider encrypting messages of  bits, with message hashes having length  bits. We do not consider the concrete sizes of the private keys and testing tokens, which are small (as they are discrete Gaussian matrices with small entries) compared to the sizes of public keys and ciphertexts, and would not be transmitted. We note that the construction from [19] has large . This is due to the use of the lattice-mixing technique which induces public keys of size 
.

In Table 4, we give concrete parameters for ring-lattice constructions using the same parameters n and q as above, as those are the parameters that directly affect the size of the messages that the systems can carry. Here we set  in order to apply [35], Lemma 7. For the sake of expediency, and only for the purpose of this cursory comparison, we shall suspend disbelief and assume that plain 
 and its ring version achieve the same level of actual security for the same values of the parameters , since no better attack against the ring version of the 
 problem is presently known [34].

The data from Table 3 and Table 4 show that:

•
In both instances, our systems offer the smallest sizes for both  and  — owing to the avoidance of the “one system, two instances” approach).

•
Only our systems achieve 128-bit security within the stated constraints, benefitting from a larger α — itself the result of avoiding heavy lattice machinery, whose complexity is generally antagonist to tightness.

We note that to match the security level in the other systems, one would have to increase n and q commensurately, which would further significantly increase the sizes of their keys and ciphertexts.
7. Conclusion
In this paper, we took another look at the widely used security model for public-key encryption with equality test (PKEET), and proposed two new security notions to capture scenarios of realistic importance: one is a stronger definition of insider security which supports flexible message distributions; the other is a novel but natural notion of unmaskability to preclude evasion of the equality test by active attackers.

We then proposed a new construction of PKEET, secure in our stronger model, from simple general lattice building blocks, which we separately instantiated in the plain and the ring lattice settings. Comparing with the existing constructions from the literature, our constructions enjoy higher computational efficiency and relying on weaker (more secure) plain or ring learning-with-errors (LWE) assumptions.