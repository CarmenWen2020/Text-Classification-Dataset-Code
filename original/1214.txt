Abstract
The Exact Satisfiability problem asks if we can find a satisfying assignment to each clause such that exactly one literal in each clause is assigned 1, while the rest are all assigned 0. We can generalise this problem further by defining that a Cj clause is solved iff exactly j of the literals in the clause are 1 and all others are 0. We now introduce the family of Generalised Exact Satisfiability problems called GiXSAT as the problem to check whether a given instance consisting of Cj clauses with j∈{0,1,…,i} for each clause has a satisfying assignment. In this paper, we present faster exact polynomial space algorithms, using a nonstandard measure, to solve GiXSAT, for i∈{2,3,4}, in O(1.3674n) time, O(1.5687n) time and O(1.6545n) time, respectively, using polynomial space, where n is the number of variables. This improves the current state of the art for polynomial space algorithms from O(1.4203n) time for G2XSAT by Zhou, Jiang and Yin and from O(1.6202n) time for G3XSAT by Dahllöf and from O(1.6844n) time for G4XSAT which was by Dahllöf as well. In addition, we present faster exact algorithms solving G2XSAT, G3XSAT and G4XSAT in O(1.3188n) time, O(1.3407n) time and O(1.3536n) time respectively at the expense of using exponential space.

Keywords
Measure and conquer
DPLL
Exponential time algorithms

1. Introduction
The Satisfiability problem, SAT, is an important problem in computational complexity theory because it has been commonly used as a framework to solve other combinatorial problems and it is known to be NP-complete [4]. In addition, SAT has found many uses in practice as well. Applications include AI-planning and software model checking [15], [16]. The current state of the art is that solving SAT and its variants need exponential time in worst case and a whole field of exact exponential time algorithms has been developed to explore this further, see for example [1], [2], [6], [7], [10], [11], [12], [19], [20], [21].

Because of its importance, many variants have also been explored and studied. One such variant is the Exact Satisfiability problem, XSAT, where it asks if one can find a satisfying assignment such that exactly one literal in each clause is assigned 1 (true), while the rest are assigned 0 (false). XSAT is also known as 1-in-SAT. This problem has been widely studied; Dahllöf [6] provided an algorithm running in ; a prior algorithm of Byskov, Madsen and Skjernaa [2] was running in . Recent work of Hoi [13] improved the bound to . One may generalise the XSAT problem by considering a constant bound i and allowing an arbitrary collection of  clauses as an instance, , where each  clause must have exactly j literals true for being satisfied. This class of problems is also known as the General Exact Satisfiability problem and we distinguish each individual problem as GiXSAT (General i Exact Satisfiability) with the bound i as just described; the problem is also known as i-in-SAT or XiSAT. GiXSAT is of interest because one can use it to represent cardinality constraints in propositional logic modelling. GiXSAT sits in the middle of XSAT and Knapsack. The implication XSAT to GiXSAT is immediate by the definition and the standard reduction of XSAT to the Knapsack problem can easily be modified to a reduction of the GiXXSAT problem to the Knapsack problem where the number of variables does not increase. Note that there is no restriction on the length of the clauses here. Therefore, XSAT is also equivalent to G1XSAT. For any , GiXSAT is known to be NP-complete [5], [6], [18].

In this paper, we focus on GiXSAT, where . Dahllöf gave the first polynomial space algorithm solving G2XSAT running in  time. In his same paper [5], he improved the bound to  time. In addition, he also gave an algorithm to solve G3XSAT and G4XSAT in  time and  time respectively. More recently, Zhou, Jiang and Yin [21] gave an algorithm to solve G2XSAT in  time, improving upon Dahllöf's G2XSAT algorithm. These algorithms all use polynomial space.

In his paper, Dahllöf also gave an exact algorithm to solve G2XSAT in  time, at the expense of using  space. His result is a direct application of the Split and List technique by Schroeppel and Shamir [17].

In this paper, we propose an algorithm to solve G2XSAT, G3XSAT and G4XSAT in time  time,  time and in  time respectively.  clauses are more complex than  clauses as there are many more ways to satisfy them, the complexity of GXSAT is expected to be larger than that of GiXSAT and the running time of the so far published algorithms reflect this. The improved bounds were obtained by more comprehensive case-distinctions (in the case of G2XSAT) as well as the use of a nonstandard measure for all three variants. Furthermore, for G2XSAT, we use nonstandard measure in the form of a state based measure to bring down the timing further.

In addition, we propose faster exact algorithms to solve G2XSAT, G3XSAT and G4XSAT in time  time,  time and in  time, respectively, using exponential space. To achieve this, we modify the technique of Schroeppel and Shamir by doing asymmetric splits of the set of variables such that the larger one of the two “halves” is a union of clauses and there we exploit that for each  clause of ℓ literals not all  possible values of the literals apply but only  
  many and this effect brings down the overall number of assignments for this larger half; however, one cannot do this for both halves, as one cannot guarantee that the smaller half is fully covered by clauses using only variables from that half.

2. Preliminaries
2.1. Branching factor and vector
In this section, we will introduce some definitions that we will use repeatedly in this paper and also the techniques needed to understand the analysis of the algorithm. The algorithm that we design is a Davis–Putnam–Logemann–Loveland (DPLL) [8], [9] style algorithm, or also known as branch and bound or branch and reduce algorithms. DPLL algorithms are recursive in nature and have two kinds of rules associated with them: Simplification and Branching rules. Simplification rules help us to simplify a problem instance or to act as a case to terminate the algorithm. Branching rules on the other hand, help us to solve a problem instance by recursively solving smaller instances of the problem. To help us to better understand the execution of a DPLL algorithm, the notion of a search tree is commonly used. We can assign the root node of the search tree to be the original problem, while subsequent child nodes are assigned to be the smaller instances of the problem whenever we invoke a branching rule. For more information of this area, one may refer to the textbook written by Fomin and Kratsch [11].

In order for us to analyse the running time of the DPLL algorithm, one may just bound the number of leaves generated by the search tree. We let μ be the choice of our measure. Then we let  denote the maximum number of leaves based on the measure μ on a branching rule. Therefore, in order to know the worst case complexity of running the algorithm, we need to analyse each branching rule separately and use the worst case runtime over all the branching rules as an upper bound of the algorithm.

Now given any branching rule, let  be the number of instances generated from this rule. Let  be the change of measure for each instance for a branching rule, then we have that , which is a linear recurrence. We can employ techniques in [14] to solve it. The number of leaves generated of this branching rule is therefore given as β, where β is the unique positive root of . For ease of writing, we denote the branching factor of this branching rule as  and  is also known as the branching vector.

If there are k branching rules in the entire DPLL algorithm, with each having a branching factor of , then the entire algorithm runs in , where .

We will introduce some known results about branching factors. If  and  then we have that , for all positive . In other words, comparing two branching factors, if in each branch the first one eliminates at least as much weight as the second, then the first one is as a number better or equal (that is, as a number less or equal) than the second branching factor. The same is true for multiple-way branching provided that the number of entries for both branching factors is the same. Suppose that , for some , then . In other words, a more balanced tree will result in a smaller branching factor.

Finally, suppose that we have a branching vector of  for some branching rule. Suppose that for the first branch, we immediately do a follow up branching to get a branching vector of , then we can apply branching vector addition to get a combined branching vector of . This technique can sometimes help us to bring down the overall complexity of the algorithm further.

Finally, correctness of DPLL algorithms usually follows from the fact that all cases have been covered. Now, we give a few definitions before moving onto the actual algorithm.

2.2. Definitions
Definition 1

A clause C is a disjunction of literals. Alternatively, we also say that a clause C is a multiset of literals. A k-literal clause C is a clause where . Finally, α is a subclause of C if .

For example, if , then  is a 4-literal clause. In addition, let . Then δ is a subclause of C since  and we can write . We will use Greek letters for subclauses.

Definition 2

Two clauses  and  are called neighbouring clauses if they share a common variable. Let  denote the set of variables that appear in the clause C. In other words,  and  are neighbours when . Let two clauses  and  be given such that . We say that they  and  have  overlapping variables.

For example, if we have a clause , then .

Definition 3

We call a clause  if it needs exactly i literal(s) to be assigned true. Likewise, we say that a clause is exact-i-satisfiable if we can assign i literals 1, and the rest 0 in that clause. For simplicity, we will just say that the clause is satisfiable instead of exact-i-satisfiable.

In the midst of branching a  clause, it can drop to a  clause, where . Therefore, we introduce this definition to distinguish the different types of clauses present in the formula.

Definition 4

We say that two variables, x and y, are linked when we can deduce either  or . When this happens, we can proceed to remove one of the linked variables, either x or y.

For example, if we have a  clause  and if , we can deduce that . Then, we can replace all occurrences of y by ¬z and ¬y by z.

Definition 5

Let  denote the degree of a variable x, which is the number of times that the literal x and ¬x appears in the formula. We call a variable heavy if .

This definition will be mainly used in our G2XSAT (polynomial space) algorithm where we have to deal with heavy variables in  clauses. Let ,  and . Since , x is heavy in this case.

Definition 6

Let φ be a formula given. Then we denote  () as the formula obtained after assigning  (). Likewise, we denote  be the formula obtained after replacing all occurrences of x by y. Let α be a subclause of some clause C. We denote  as the formula obtained by adding α as an additional  clause into φ, . On the other hand, we denote  as the formula obtained by assigning all literals in α to 0.

The above are common kinds of branching techniques that we will deploy in our paper. An example of branching  can be seen in this example: Suppose we have , for some  clause C. Then if α is added as new  clause into φ, we know that the literals in  must be assigned to 0.

Resolution

Resolution is a technique that allows us to remove variables that appear both negated and unnegated, at the same time, preserving the overall satisfiability of the formula. We use it only in the case that a variable x occurs positive and negative in  clauses  and , where α, β are subclauses. Now we can replace every clause  clause  by  which is also a  clause for the same h and every  clause  by  which is also a  clause for the same ℓ.

3. G2XSAT (polynomial space)
In this section, we give a  time and polynomial space algorithm to solve G2XSAT. We will first introduce the design of our nonstandard measure, followed by the debt-taking technique, then the algorithm and its analysis.

3.1. Nonstandard measure for the G2XSAT algorithm
We say that a variable x strongly appears in a clause C iff the truth-value of C depends properly on the value of x. So x strongly appears in the  clause  and the  clause  but not in the  clause , as here the truth-value of x cancels out. Therefore letting  and removing the  clause  does not make the measure of x to go up. Note that whenever in a situation in the algorithm G2XSAT below Lines 1–4 do not apply, then for each  clause C and each variable x, x appears in C iff x strongly appears in C; hence when handling Lines beyond Line 4, these two notions are equivalent.

Let  be a variable in φ. We define the weight  for  as follows: 
  The value 0.8039 is an optimal value chosen by our linear search computer program to bring down the overall runtime of the algorithm to as low as possible. In addition, note that our measure . Therefore, this gives us .

Example 7

Say we have a clause  and a clause . Then the weights for each variable are as such: weights for , while . Even though the variable x appears in the above two clauses, as long as it appears in a  clause, we assign that lower weight to it.

Remark 1

In the course of the algorithm, it might occur that a -clause is dissolved and therefore some surviving variables in the clause are increasing their weight from 0.8039 to 1. This can happen when a variable receives a new value and only two literals remain in the clause, two variables are linked or there is a resolution. The following description shows what happens.

1.
Dissolving a clause by setting the value of a variable: The first case is that there is a variable x and quite a number of clauses of the form  for variables ; here one can conclude  and simplify accordingly, but then the k  clauses are removed and this might cause  no longer to appear in a -clause. This problem is solved by defining in the measure that only variables which appear strongly in a  clause are receiving the lower weight and the  in the above clauses satisfy that  is always 1 and thus the value  does not depend on the actual choice of the value of , so  does not appear strongly in the clauses. In the case that a literal in a three literal -clause is set to 1, all other literals are set to 0 and thus no gain of weight is left. The remaining case is that a literal is set to 0 and only one or two literals remain. The case of one literal assigns to that one the value 1 and again no variable is left to gain weight. The case of two literals either leads to linking (see next item) or to an elimination of variables as above or to the clause being unsatisfiable (like  for a  clause).

2.
The second case is linking. Here one concludes that a variable y is becoming either z or ¬z and that therefore a clause simplifies accordingly. For linked variables, in cases where the value of the variable can go up, the verification assigns only a change of measure of  as two variables of weight 0.8039 are replaced by a variable of weight 0.6078, in order to address the fact of weight gain of the resulting variable. However, in some cases one can avoid the weight gain and then this is stated explicitly in the verification.

3.
Resolution is used only in Line 14 of the G2XSAT algorithm. Prior to this line, Line 9 has removed all overlaps between  formulas and Lines 10 and 11 have removed all multiple occurrences of variables in  clauses and Line 12 has removed multiple overlaps between  and  clauses. There are only three subcases where clauses of the form ,  are resoluted and the literal z is the result of two literals getting the opposite value due to a case distinction and linking (they had different variables before). As the  clauses have no overlap before the linking and the surviving part of the  clause, which might be downgraded to a -clause, does no longer depend on z and thus z does not strongly appear in it, the only variables affected by the resolution which might gain weight are those in β and γ, however, as none of these variables occurs twice in  (neither as  nor as ), these variables also continue to strongly appear in  which is a  clause; hence the weight of these variables does not change. For that reason, the applications of resolution inside the algorithm G2XSAT do not increase the weight of any variable. For more details, see the verification of the branching numbers for Line 14.

3.2. Debt taking
This is a method where one can borrow - up to constant size - measure in order to get a better branching number for a splitting; for consistency reasons, it is however required that immediate follow-up operations in those branches where the debts were taken out restore the debt to the original value. Note that the debt is taken out by the outgoing branch and does therefore not affect the other branches; however, all branches in the follow-up operations must restore the debt. In some cases, several branches take out a debt simultaneously which then requires also for all of these branches a subsequent action to immediately repay the debt.

This technique is a state based measure [3], [19]. One can define a state  where it is debt-free. For each branching rules r that borrows up to a certain constant , we can define a state  such that when  transitions there, we add  to our change of measure. Likewise, when  transitions to , we minus  from our change of measure. The debt taking technique free us from the trouble of keeping track of the different states we are in, by just repaying the debt immediately after we borrow. This simplifies our writing. For more information on state based measures, one may refer to the book of Gaspers [12] and the doctoral thesis of Wahlström [20].

3.3. Algorithm (overview)
In this section, we give the algorithm to solve G2XSAT. It takes in a formula φ in CNF and checks whether the formula is satisfiable and then outputs the value of 1 or 0; here 1 denotes satisfiable and 0 denotes unsatisfiable. If there are neither heavy variables nor multiple overlaps of clauses nor multiple occurrences of variables in the formula, then we can solve the instance in polynomial time by an algorithm of Dahllöf [6]. Therefore, the idea here is to remove all heavy variables and all multiple overlaps of clauses and multiple occurrences of variables so that we can solve the resulting G2XSAT instance in polynomial time. The algorithm goes through line by line in this order of decreasing priority. Line 1 has the highest priority, followed by 2 and so on. When we are at a certain line of the algorithm, we will assume that the earlier lines of the algorithm no longer apply. We will call our recursive (branch and bound) algorithm G2XSAT(.).

Algorithm: G2XSAT

Input: φ

Output: 1 for satisfiable φ and 0 for unsatisfiable φ.

1.
If there is a clause , , that is not satisfiable, then return 0.

2.
If there is a  clause  or , then we do the following: If , then . Return G2XSAT and drop the clause C. Else if , then drop C from  to  clause, and let  and update φ as . Return G2XSAT.

3.
If there is a  clause , then update  and update φ as . Return G2XSAT.

4.
If there is a clause  containing a literal x appearing j times, , then return G2XSAT.

5.
If there is a  clause C with k literals, each appearing exactly twice, , then drop it to a  clause , with each of the k literals appearing exactly once. Update φ as  and then return G2XSAT.

6.
If there is a  clause C such that , then let  be the literals in C. Return G2XSAT.

7.
If there is a  3-literal clause , then replace C by the  clause , where  is a  3-literal clause. Update φ as  and then return G2XSAT.

8.
If C is a  clause with , then we choose  in C and branch  and . Return G2XSAT() ∨ G2XSAT().

9.
If C and  are  3-literal clauses such that . Then we either simplify this case further or we branch  and . If we simplify this case further, then let  be the updated formula after simplifying. Return G2XSAT(). If we are branching  and , then return G2XSAT() ∨ G2XSAT().

10.
If C is a  clause with at least two literals x and y appearing twice. We either simplify some of these cases further, or we branch  and . If we simplify some of the cases, then let  be the new formula after updating φ and we return G2XSAT(). Else if we branch, then return G2XSAT() ∨ G2XSAT().

11.
If C is a  clause containing exactly one literal x appearing twice. We either branch or simplify the cases further. If we simplify some of the cases, then let  be the new formula after updating φ and we return G2XSAT(). Else if we branch, we choose a literal u to branch  and  and then return G2XSAT() ∨ G2XSAT().

12.
If there is a  clause C and  clause  such that . Then we can update  from φ after simplifying some cases. Return G2XSAT().

13.
If there are  4-literal clause . We choose variables , , ...  and branch them with values , , ..., , for some k. Return G2XSAT() ∨ G2XSAT()  G2XSAT(). More details on the choosing and branching of variables in the next section.

14.
If there are  clauses C and  clauses  such that . Then choose a variable x and branch  and . Return G2XSAT() ∨ G2XSAT().

15.
If there are  clauses C and  such that , then we can either simplify further or we have to branch some of these cases. If we are simplifying some of these cases, then let  be the new formula from φ. Return G2XSAT(). If we are branching, then choose variables , , ...  and branch them with values , , ..., , for some k. Return G2XSAT() ∨ G2XSAT()  G2XSAT().

16.
In this line, we deal with heavy variable x in the formula that matches the specific subcases (more details later) and we branch  and . Return G2XSAT() ∨ G2XSAT().

17.
Brute force the remaining heavy variables in the formula.

18.
Solve the rest of the formula in polynomial time. Return 1 if it is satisfiable, else return 0.

We describe the algorithm here. Line 1 of the algorithm says that if there is any clause that is unsatisfiable, return 0. Line 2 of the algorithm deals with constants 1 appearing in a clause. If it is a  clause, then by definition, all literals in α can be assigned 0. On the other hand, if it is a  clause, then α becomes the new  clause. Line 3 of the algorithm deals with constants 0 appearing in a clause. We can then remove 0 from the clause safely. After Line 3, there will be no more constants in any clause. In Line 4 of the algorithm, if there are literals x occurring j times in a  clause, where , then set . This is because we are not allowed to over-satisfy by definition of the problem. So after this, every literal can only appear at most i times, in a  clause. In Line 5 of the algorithm, we deal with  clauses with every literal appearing twice. This is equivalent to solving  clauses with each literal appearing exactly once in it. In Line 6 of the algorithm, if there is a 2-literal  clause containing the literals x and y, then we can just set . After Line 6, all  clauses must be at least k-literal, where . In Line 7 of the algorithm, when we have a 3-literal  clause say , then we can set  to be a  clause. This is valid since C was originally was a  clause, requiring exactly 2 literals to be assigned 1 and a literal assigned 0. Now if we were to negate all the literals, then now exactly a literal needs to be assigned 1 and 2 literals assigned 0. After this, all  clause must be at least a k-literal clause, where . Note that Lines 1 to 7 of the algorithm are simplification rules. These will only take polynomial time.
From Line 8 of the algorithm onwards, these lines contribute to the exponential growth of the algorithm. Hence, an indepth analysis of their time complexity will be studied in greater detail in the next section. In Line 8 of the algorithm, we deal with  k-literal clauses, where . This means that after this line, only  3-literal clauses are left in the formula with  clauses. We delay handling of  3-literal clauses because directly handling them now would increase the bottleneck of the entire algorithm. In Line 9 of the algorithm, we deal with two  3-literal clauses that have variables in common. After this, all  3-literal clauses C can only appear with  clauses ; . In Line 10 of the algorithm, we deal with  clauses containing at least two literals appearing twice. In Line 11 of the algorithm, we deal with  clauses that contains a literal appearing twice in the clause. After Line 11, any literal appearing in any  clause must only appear once. Line 12 of the algorithm deals with  clause C and  clause  such that . After Line 12 of the algorithm, we know that if any  clause C and  clause  have variables in common, then we have . In Line 13 of the algorithm, we deal with  4-literal clause. After which, all  clauses must be k-literal clauses, where . In Line 14 of the algorithm, we deal with  clause C and  clause  such that . After which, we will no longer deal with  3-literal clauses. In Line 15 of the algorithm, we deal with  clauses C and  such that . After which, we know that given any two  clauses C and , we must have that . We are now ready to deal with heavy variables in the formula. Line 16 and 17 of the algorithm deals with heavy variables in the formula. We branch certain cases in Line 16, and brute force the remaining heavy variables in Line 17. After which, we can solve the remaining formula in polynomial time and then return 1 if satisfiable and 0 otherwise.

Note that we have covered every case above and therefore shows the correctness of our branch and bound algorithm.

3.4. Analysis of algorithm
Note that whenever we perform linking in a  clause, the surviving variable may have its weight increased from 0.8039 to 1 in the worst case scenario. This is due to the fact that the variable might not appear in any other  clauses, hence we need to account for this increase in weight. For example, if we have  and when , we have that  and we remove y. Now the surviving variable z may not appear in any more  clauses and its weight may increase from 0.8039 to 1, a decrease in measure of 0.1961. On the other hand, we remove y, which has weight 0.8039. Therefore, the net change of measure is  whenever we perform linking in a  clause.

In this section, we will present the analysis of the algorithm from Line 8 of the algorithm onwards. Lines 1 to 7 are simplification rules which only take polynomial time. Lines 8 onwards are branching rules which contribute to the exponential growth of the algorithm. Finally, Line 18 also takes polynomial time once no heavy variables exist in the formula. Therefore, we will analyse Lines 8 to 17 of our algorithm here. Note that from Line 4 onwards, the notion of appear and strongly appear coincide.

8.
If C is a  clause with , then we choose  in C and branch  and .

We consider the branching factor for each .

•
If . Then let  be the 4 literals in C. We branch  and . When , then  and thus we remove . This gives us a change of measure of . When , we link . This gives us a change of measure of . The branching factor is .

•
If . Choose two literals  and branch  and . If , then all the other literals in C must be 0, removing at least 3 variables here. This gives us a change of measure of . On the other hand, when , we remove only 2 variables , giving us a change of measure of . Therefore, the branching factor for this case is .

After this line of the algorithm has been executed, the only  clauses left are 3-literal clauses. We have factored in the increase of weights due to linking variables while branching in our branching factors above.
9.
If C and  are  3-literal clauses such that . Then do the following:

•
. If we have  and . Then we branch  and . When , we remove x, α and link two of the variables in β. This gives us a change of measure of . The case for  is symmetric. This gives us a branching factor of . Else, we must have  and . If , then we remove x, α and δ. This gives us a change of measure of . If , we remove x and link the two variables in α and β. This gives us . This gives us a branching factor of .

•
.

If  and . Then link . If  and , then . If  and , then  and .

•
. The case  and ,  and ,  and  are not satisfiable. If we have  and , then  and .

After this line of the algorithm,  3-literal clauses can only appear with  clauses. Here, the increase in weights due to linking have also been factored in our branching factors.
10.
If C is a  clause with at least two literals x and y appearing twice. We simplify some of these cases further.

Line 5 of the algorithm helps us to handle the following cases: ,  and . Therefore, it suffices to only consider other cases. Note that .

•
. . Then .

•
. . Then we must have that .

•
 and . Then .

•
In all other subcases we have at least five variables. We branch  and . As the weight of each variable is at least 0.8039 (it is possible that they may appear in  clauses at this point in time) and as the measure of  might go up when they get linked, we apply the same analysis as in the case  of Line 8: If , then all the other literals in C must be 0, removing at least 3 variables here. This gives us a change of measure of . On the other hand, when , we remove only 2 variables , giving us a change of measure of . Therefore, the branching factor for this case is .

After this line of the algorithm, every  clause must contain at most a literal appearing twice in it. The increase in weights due to linking variables have been factored in our branching factors.

11.
If C is a  clause containing exactly one literal x appearing twice. We either branch or simplify the cases further.

Note that by the previous line of the algorithm, every  clause can only have at most one literal appearing twice in it.

•
. Then . Then .

•
. Then . Then .

•
. Then . We deal with this case by case.

–
Now if all the variables in C have weight 1. We branch  and . If , we remove all 4 variables, giving us a change of measure of 4. If , then we remove x, and the other variables drop their weight from 1 to 0.8039, giving us a change of measure of . This gives us .

–
For the next few cases, we must have that some variables in C have weight 0.8039. This means that some variables in C appear in a  3-literal clause. Let  be the  3-literal clause. We enumerate the cases here.

–
. In this case,  can be any literal (including ). Then we branch  and . We treat all the variables here as having weight 0.8039 to upper bound our branching factor. When , we remove all 4 variables in C, giving us a change of measure of . When , we remove the literals , giving us a change of measure of . This gives us a branching factor of . For the remaining cases below, we will assume that ¬x does not occur in .

Now, we deal with the case that . Now the literal u can be any literal for the cases below.

. Then  cannot happen, else some clauses are not satisfiable. Therefore .

. If u and w are the same variable then drop C and add in their sum which is the  clause , which may then be further simplified to  clause ; one can afterwards conclude that  and simplify further. If u and w are different variables, one adds again C and  and gets the  clause  which allows to link  and thus leads to some simplification.

. Now, if , then  and . Else if , then  and . Therefore, in either case, we see that .

. Then we know that if , then  and , which makes the  not satisfiable. Therefore, .

. Then  and therefore, . Therefore, . . The literal u is not in . Then we branch  and . If , then , and . This gives us a change of measure of . If , we remove u and then . This gives us a change of measure of . This gives us a branching factor of .

–
For the remaining cases, we deal with .

. Note that the literals . We branch  and . Here the worst case is that  do not appear in  3-literal clauses, else when , we can factor in additional measure via linking. Therefore, when , , giving us a change of measure of . When , then , giving us a change of measure of . This gives a branching factor of .

Finally, we have the case that x does not appear in any other  3-literal clauses, but the literals  may. Note that at this point, , for any 3-literal clause . Let k be the number of 3-literal clauses that are neighbours to C, each containing one of the variable in . When , then we remove all variables . Now if there are k many 3-literal clauses, then our change of measure is . When , the change of measure for the variables not appearing in 3-literal clauses, giving us a change of measure of . The worst case happens when , giving us a branching factor of .

•
 and thus . So we analyse the most critical case . We branch  and , but for this case, we need a case-distinction in the analysis of the situation.

If x appears in a  clause , then x must have weight 0.8039. We treat all the other variables in C having weight 0.8039 to act as an upper bound on our branching factor. When , we remove at least 5 variables in C, giving us a change of measure of . When , we remove x and link the 2 variables in , giving us . This gives us a branching factor of .

If x does not appear in any , then it must have weight 1. Now when , our change of measure is . When , we remove only x, giving us a change of measure of 1. Therefore, this gives us a branching factor of .

The increase in weights due to linking (for the respective branching cases) has already been factored in our branching factors.

12.
If there is a  clause C and a  clause  such that .

Note that at this point onwards, all literals appearing in any  clause can only appear once and any  clause must be a 3-literal clause at this point. Note that some of the cases here overlaps with those shown in the previous line, when dealing with the case .

. Let .

•
. Then we can drop  and add in the  clause α.

•
. Then from these two clauses C and , we arrive at the  clause  (after removing redundant terms on both sides). So we replace  by  and handle the resulting set of clauses as in Line 10 of the algorithm.

•
. If  then  and , giving that  has three literals satisfied, a contradiction. Thus  and we can simplify accordingly.

•
. Then all the literals in α must be assigned 0.

. Let .

•
. Therefore,  and then  and . This is a  clause which can be added in and we can drop the clause  to decrease the overall measure.

•
. Then we can replace  as  and this case will be handled by the earlier line of the algorithm (same literal appearing twice).

•
. Then we can replace  by the  clause , which will be handled by earlier lines of the algorithm.

After this line, for any  3-literal clause C and  clause , we must therefore have . In this line, we mainly simplify most of the cases. Hence, no increase in weights for any of the variables in any of the cases here.
13.
If there are  4-literal clause . We choose specific variable(s) and branch based on the different case scenario below.

By the previous line of the algorithm, if any  clause C and  clause  overlap, then we must have .

•
All variables in C have weight 1. Then we branch ,  and , , . For the 1st branch, we remove 2 variables of weight 1, giving us a change of measure of 2. For the 2nd branch, we remove 3 variables of weight 1, giving us a change of measure of 3. This gives us a branching factor of .

•
Exactly 1 of the variable appears in a further 3-literal clause. We do exactly the same as in the previous case, but make sure that only the variables of weight 1 get eliminated (replaced by other variables via linking). Thus again the branching factor is .

•
At least 2 of the variables appears in a further 3-literal clause. Let these two variables be  and the two  clauses be  and , for some subclauses α and β. We treat all variables here as having weight 0.8039 to upper bound our branching factor. Then we branch ,  and . Now, when , then all literals in α and β,  are all assigned 0. This gives us a change of measure of . When , then , removing two variables of weight 0.8039, giving us a change in measure of . Finally, when , then , and we can link up the two variables in α and β, giving us a change of measure of . This gives us a branching factor of . Note that if the above -clauses are  and , then one has a symmetric situation and again the branching factor 1.3620. If the -clauses are  and , then one has a mixed situation where for  as well as  one eliminates six variables and links two and for the middle case, one eliminates two variables by linking. This gives .

Likewise, the increase of weights due to linking variables have also been factored in the respective branching factors above.
14.
If there are  clauses C and  clauses  such that .

By the previous line of the algorithm, all  clauses  must be . We consider the different cases below:

•
There are at least three  3-literal clauses that are neighbours to . Let , for some subclause δ, and the other clauses be ,  and , where ,  and . We choose two of the literals in  such that they appear as both positive literals or negative literals. Without any loss of generality, we let the literals be y and z and we have  and  (or alternatively  and ). Then we branch  and .

Case . When , all literals in α are assigned 0. This gives us a change of measure of . On the other hand, when , we link up the literals in α to get a change of measure of 1.4117. For the 1st branch, we take a debt of 0.98 to get a branching factor of .

Case . This case is symmetric to the above case. We take a debt of 0.98 when . This gives us a branching factor of .

Follow up: Note that in both cases above, we took a debt of 0.98 when . We need to clear this debt in their subsequent child nodes where the debt took place.

We branch  and .

Case  and .

. When , then all literals in δ are assigned 0. Then we have the clauses  and  where we can apply resolution to remove z. This gives us a change of measure of . When , we can link the two literals in β and γ, giving us a change of measure of . The branching factor is .

. When , then the two literals in δ are assigned 0. Then we have the clauses  and  where we can apply resolution to remove z. This gives us a change of measure of . When , we can link the two literals in β, γ and δ, giving us a change of measure of . The branching factor is .

Case  and .

When , then all literals in δ are assigned 0, then we remove at least 3 variables. Then we have the clauses  and  where we can apply resolution to remove z. This gives us a change of measure of . On the other hand, when , we remove all the literals in β and γ, giving us a change of measure of . This gives us a branching factor of .

•
There are two  3-literal clauses that are neighbours to . Suppose we have ,  and  clauses , . We branch  and . When , we remove x and all literals in α, and all variables in δ drop in measure to 0.8039 from 1. This gives us a change of measure of . When , we remove x and link the variables in α, giving us a change of measure of . We take a debt of 0.39 for the first branch. This gives us a branching factor of . Symmetrically, if we have . Then branching  will give us , and branching  will give us . We again, take a debt of 0.39 for the  branch. This gives us a branching factor of .

Follow up: In the  branch, we are left with a  clause , with y also appearing in another 3-literal clause . Now we branch  and . When , we remove all the literals in δ and β, giving us a change of measure of . When , we remove y and link the literals in β, giving us a change of measure of . Paying off the earlier debt of 0.39 will give us . Symmetrically, if we have , then  will give us a change of measure of . On the other hand, when , this gives us 2.4117. This gives us .

•
There is exactly one  3-literal clause that is a neighbour to . Suppose we have , , and a  clause , where . We analyse it by different case.

Case . Suppose we have  and when , we remove all literals in α, and the variables in δ drop from 1 to 0.8039, giving us a change of measure of . When , we remove x and link the literals in α, giving us a change of measure of . This gives us a branching factor of .

Case . Therefore, all the variables appearing in δ have weight 1 and we also have a  clause , where . If we have , when , we remove x, link the literals in α, and all the variables in δ drop their weight from 1 to 0.8039, giving us a change in measure of . When , all literals in α are assigned 0, giving us a change in measure of . This gives us a branching factor of . If we have , if we have , all the literals in α are assigned 1, and the variables in δ will drop in measure, giving us . When , we remove x and link up the literals in α, giving us a change of measure of . For the  branch, we take a debt of 0.2 to give us the branching factor of .

Follow up: For the  branch, we are left with a  clause δ with all variables having weight 1. From Line 13, we will have a branching factor of .

Note that for the cases above that uses linking, the increase in weights have been factored in the branching factors above. For the cases where we first use linking, and then followed by resolution, no increase in weights for the variables after resolution due to the fact that we only apply it on  3-literal clauses. Resolution will increase the length of the clause, but not the weights in the clause due to how we define our nonstandard measure.
15.
If there are  clauses C and  such that , then we do the following:

From this point onwards, all variables appearing in  must all have weight 1. From Line 13, we know that both  and . All clauses are  clauses by default unless specifically mentioned.

•
We deal with some special cases here.

, then set all literals in  to be 0.

 and . Then α combines with both  in  clauses and is just either 0 or 1; thus we can conclude that  to get C satisfied and simplify according.

 and . We can derive  and by adding  on both sides will give us ; that is, a  clause . This  clause replaces  in φ and it will be handled as in Line 10 of the algorithm.

 and . The sum of these two gives the  clause  and we set all literals in α to 0 and replace  by the  clause β.

•
If we have  or , then we deal it case by case.

 and . One can derive that . Therefore, adding ¬x to both sides, we have . Therefore,  is a  clause. We can add this in to reduce the measure of the overall formula.

 and . Note that . We branch  and . When , then , removing 1 variable here. When , then , which means we remove at least 5 variables here. This gives us .

 and . Note that . Let . Note that  is impossible, as otherwise  and therefore all literals in α and β must be assigned 0, a contradiction. Therefore, we can only branch  and . When , then , removing 1 variable here. When , then all literals in γ are assigned 0, allowing us to remove at least 3 variables here. In addition, . Therefore, we remove 5 variables here, giving us .

 and . Then ; as  by the fact that , so no branching is required here.

 and . Then .

•
. We can either have  and  (first case),  and  (second case),  and  (third case). Note that  and . For the first case, we branch  (first branch),  (second branch) and  (third branch).

The first branch removes all variables, second branch removes x, and drops the rest of the variables in α and β from 1 to 0.8039 and finally the third branch removes  and we are left with  clauses α and β.

Case  and .

. First branch removes all 8 variables. Second branch gives us a change of measure of . For the third branch, α and β can be downgraded to a  3-literal clause by Line 7 of the algorithm, giving us a change of measure of . This gives us .

. First branch removes all 9 variables. Second branch gives us . Third branch gives . This gives .

. First branch removes 10 variables. Second branch gives us . Third branch gives us 2. We take a debt of 0.4 for the third branch, this gives us . The debt of 0.4 will be repaid by the clauses α and β, each repaying 0.2. From Line 13, this gives .

. First branch removes 11 variables. Second branch gives . Third branch gives 2. This gives .

Case  and .

With the earlier cases not applying, we know that  and , with  and . When , we set all literals in α to 0, giving us a change of measure of 5. When , we remove x, and at least 4 variables will drop in measure, giving us . When , then set all literals in β to 0, giving us a change of measure of 5. This gives us .

Case  and . We branch  (first branch),  (second branch) and  (third branch). For the first branch, we remove all the variables in C and drop β to a  clause, for the second branch, we remove all the variables in  and drop α to a  clause, and third only x.

. First branch gives . Second branch is similar, giving 5.5883. For the third branch, we have removed 1 variable. We take two times a debt of 0.23, in total 0.46 on the third branch. This gives us . The clearing of the debt of  will be done by two 4-literal  clauses  and . First one branches  such that the variable y survives the linking (though other variables might be linked into it); then one branches the other clause, so that we will get the branching factor of .

. First branch gives . Second branch gives . Third branch gives 1. We take a debt of 0.23 for the third branch, giving us . The debt clearance will be done on a  4-literal clause, giving us .

. First and second branch gives at least . The third branch gives 1. This gives us .

This completes the case for 2 overlapping variables between C and .

•
. In this case, then we are able to choose 3 variables  from C and  such that we either have  and ,  and γ contains , or  and .

Note that  and . We distinguish two subcases.

–
Case  and . We branch  (first branch) and  (second branch). Note that we cannot have  here, else one of the clause is not satisfiable. The first branch removes y and sets all the variables in α, β and z to be a  clause. The second branch removes .

First branch gives . Second branch gives 2. Taking a debt of 0.54 for the first branch, we have . For the first branch, note that we are left with the following  clauses:  and . We branch  and .

. In either  (), we remove the variables in α (β) and link up the literals in β (α), giving us . Then we have .

. When , we remove all variables in α, giving us . When , we remove all the variables in β, and link up the variables in α, giving us . This gives us .

. When  (), we remove all the x and the variables in α (β), giving us . This gives us a branching factor of .

–
Case  and . Then we branch , , and . Note also that  and . When , all variables in α and β are removed. When , then γ, α and β drops to become  clauses. When , then all literals in γ are assigned 0. Note that .

. When , we remove 4 variables. When , we link up the two literals in α and β, giving us . When , we remove all 7 variables, since all literals in α and β must be assigned 1. This gives us .

. When , we remove 5 variables. When , we link up the two literals in α, giving us . When , then all literals in α are assigned 1, and the variables in β drop their weight from 1 to 0.8039, giving us a change of measure of . This gives us .

. When , we remove 6 variables. When , we can only factor in the change of measure of . When , we remove 3 variables and the variables in α and β drop their weight, giving us . This gives us .

. When , we remove 7 variables. When , we can only factor in the change of measure of . When , we remove 3 variables and the variables in α and β drop their weight, giving us . This gives us .

. When , we remove 8 variables. When , we can only factor in the change of measure of . When , we remove 3 variables and the variables in α and β drop their weight, giving us 3. This gives us .

This completes the case where , for any two clause C and .
From this line onwards, we do not have to worry about the increase of weights of variable, since they are all already at weight 1, the maximum weight.

16.
If there is a heavy variable x in the formula that matches the subcases below, we branch it  and .

By the earlier lines of the algorithm, any  clause must be at least length 5. In addition, given any two  clauses, we can only have .

•
If we have ,  and . Note that  and . We split into two cases.

Case: . When , then α and β drops to a  clause, giving us a change of measure of . When , we remove x and γ drops to a  clause, giving us a change of measure of . Now, this gives .

Case: . When , then α and β drops to  clauses, giving us a change of measure of . In addition, γ becomes a  4-literal clause. We take a debt of 0.23 for this branch. When , we remove x and γ drops to a  clause, giving us a change of measure of . This gives us . In the branch of , we subsequently clear the debt by branching the  4-literal clause γ which gives us .

•
If we have ,  and . Note that ,  and . We deal with this case by case. When , δ, α and β drops to a  clause. When , we remove only x.

Case: , , . When , this gives us a change of measure of . When , we remove x and we take a debt of 0.69. This gives us . The follow up debt clearance will be done by the three  4-literal clause, each paying back 0.23, giving us .

Case: , , . When , this gives us a change of measure of . When , we take a debt of 0.46. This gives us . The debt will be cleared by the two  4-literal clause, each paying back 0.23, giving us again .

Case: , , . When , this gives us a change of measure of . When , we take a debt of 0.23. This gives us . Again, the debt clearance is the same as above.

Case: , , . When , this gives us a change of measure of . When , we remove only x. We take a debt of 0.2 when , this gives us . The debt of 0.2 will be repaid by γ, which is by then a  clause under that branch. Choose two literals  from β and branch  and . The  gives us . When , this gives us . This gives us .

•
Two heavy variables x and y appear in the same clause. With the earlier cases not applying, for this case to happen, x and y must both appear in three  6-literal clauses, with a  6-literal clause containing both x and y. Let , , ,  and  and  and . We branch  (first branch),  (2nd branch),  (third branch) and  (fourth branch). Note that . First branch, we remove  and the variables in α, then β, γ, δ and ε will drop in measure, giving us . Though  have 20 variables altogether, it cannot be excluded that  share both one variable with each of , therefore only 16 variables are taken into account in order to avoid double counting. For the second branch, when we remove x, α, β and γ will drop to a  clause, giving us a change of measure of . The third branch is symmetric to the second, only using  in place of . For the fourth branch, it gives us 2. We take a debt of 0.0390 on the first, second and third branch and 0.2450 on the fourth branch. This gives us .

Debt of 0.2450 will be cleared by α, which is  4-literal clause, giving us . On the other hand, the debt of 0.039 will be cleared by branching two disjoint  5-literal clauses, each paying back 0.0195. Choose two literals  in β, and branch , . This gives us . Either  or  are two created  5-literal clauses which are disjoint.

17.
When the other earlier cases no longer apply, then we brute force the remaining heavy variables.

We bound the number of heavy variables that we need to branch in this case. Note that all the variables must have weight 1 at this point in time. Now let x be a heavy variable. The only case that is left is that x appears in three  6-literal clauses, ,  and . Note that . For each , y can be neighbours to at most 2 heavy variables (1 of them being x). Note that by the previous lines of the algorithm, y cannot be neighbours to 3 heavy variables. Since y is neighbour to at most two heavy variable and since there are 15 neighbours to x, they contribute a total ratio of 
 
 (non-heavy variables to heavy variables). Therefore, for each heavy variable x, we have a ratio of 
 
 
. The number of heavy variables among all the variables is then 
 
. Therefore branching these heavy variables will take at most 
 
 time.

By the algorithm above, we see that all heavy variables have been dealt with, and therefore, we can safely solve the problem in polynomial time once that happens in Line 18 of the algorithm. Correctness of the algorithm comes from the fact that all cases have been handled as shown in the previous section. Comparing all the branching factors that we have computed earlier, we have the following result.
Theorem 8

Our G2XSAT algorithm runs in  time.

4. G3XSAT (polynomial space)
In this section, we give a  time algorithm to solve G3XSAT. Unlike our G2XSAT algorithm which has a lot of cases, our G3XSAT algorithm is simpler and deals directly with ,  and  clauses by branching and removing them in that order. The idea here is to take advantage of the change in measure when a  clause drops to a  clause, .

4.1. Nonstandard measure for the G3XSAT algorithm
Let  be a variable in φ. Let j be the lowest number such that  appears in a  clause; without loss of generality, every variable appears in a clause, as other variables can be ignored. We define the weight  for  as the following for a  clause:
  Like in the G2XSAT algorithm, the weights chosen here are optimal values given by our linear search computer program to bring our overall runtime for this algorithm to as low as possible. Variables in  have weight 0.6985, variables in  have weight 0.875, and finally variables in  have weight 1. If a variable v appears in clauses  and , where  then we assign v the lower weight. Again, note that our measure . Therefore, this gives us .

4.2. Algorithm
Similar to our G2XSAT algorithm, we will give each line of the algorithm, followed by an analysis of different cases per line. Again, Line 1 has highest priority, followed by Line 2, etc. We call our branch and bound algorithm G3XSAT(.).

Input: A formula φ

Output: 1 for satisfiable φ and 0 for unsatisfiable φ.

1.
If there are any clauses  which is not satisfiable, return 0.

2.
If there are clauses  where there is a literal x appearing j times, , then return G3XSAT.

3.
If there is a  clause  or , for some literal x and δ, then let the new clause be , for . Let  be the updated formula and return G3XSAT. If , remove that clause and return G3XSAT.

4.
If there is a  clause , then update the  clause as δ. Update the formula as . Return G3XSAT().

5.
If there is a  clause, for , with each literal in that clause appearing exactly i times, then drop the clause to a  clause with each literal appearing exactly once. Let  be the new formula and return G3XSAT.

6.
Let C be a  clause. Then we choose any literal x and y and branch  and . Return G3XSAT() ∨ G3XSAT().

7.
Let C be a  clause with , for some literal x. Then we can either simplify this case further or branch  and . If we simplify this case, then let  bet the updated formula. Return G3XSAT(). Else, then return G3XSAT() ∨ G3XSAT().

8.
Let C be a  clause, where . We deal with such clauses by choosing and branching certain variables. We choose k literals  to branch . Return G3XSAT() ∨ G3XSAT()  G3XSAT().

9.
A  clause C containing a literal x appearing more than once. Therefore, we can have  or , for some literal x and some subclause δ. If we can either simplify this further or branch the variable  and . If we were to simplify this case, then let  be the new updated formula. Return G3XSAT(). If we were to branch, then return G3XSAT() ∨ G3XSAT().

10.
Let C be a  clause. Choose variables and then branch on them. Let the variables be  taking on values . Return G3XSAT() ∨ G3XSAT()  G3XSAT().

We now show that all cases have been covered in this algorithm. Line 1 helps us to deal with any clauses that are not satisfiable. Line 2 helps us to remove literals appearing j times in a  clause where . Line 3 helps us to remove the constant 1 in  clauses, by either removing them (if they are satisfied) or by downgrading them to a  clause, where . Line 4 helps us to remove the constant 0 in the clause. After this line, no constants exist in the formula. Line 5 helps us to deal with special cases where a literal i times in a  clause, allowing us to downgrade it to a  clause. Lines 1 to 5 are simplification rules. Line 6 onwards are all branching rules.
Line 6 helps us to remove all  clauses by branching them. After which, no  clauses exist in the formula. Line 7 helps us to deal with  clauses having a literal appearing more than once. Line 8 helps us to deal with the remaining  clauses (clause where each literal only appears once). Line 9 helps us to deal with  clauses having a literal appearing more than once. Finally, Line 10 helps us to deal with the remaining  clauses (clause where each literal only appears once). This completes all the case in our algorithm. Note that we have covered every case in our algorithm to solve G3XSAT. Therefore, this shows the correctness of our algorithm.

4.3. Analysis of our algorithm
Note that when linking variables in  or  clauses, the measure of the surviving variable may increase. Therefore, we will fix the following change in measure when linking in  and  clauses:  when linking in  clauses, and  when linking in  clauses.

As shown in the previous section, Lines 1 to 5 of the algorithm are simplification rules. We will therefore analyse the algorithm indepth from Lines 6 onwards, since they are branching rules.

6.
Let C be a  clause. Then we choose any literal x and y and branch  and .

This line deals with all the  clauses. Now let C be a  clause. If , then for the two literals  in C, we know that . Therefore, .

•
. Let . When , we remove z, giving us a change of measure of . When , then . This gives us . Therefore, we have .

•
. Let . When , we remove , giving us a change of measure of . When , then we know that . This also gives . Therefore, we have a branching factor of .

•
. We branch  to remove at least 4 variables, with 1 of them via linking. This gives us a change of measure of . On the other hand, when , we only remove 2 variables, giving a change of measure of . This gives us a branching factor of at most .

This completes the case for  clauses. Note that the increase of weights due to linking variables have been factored in our branching factors above.
7.
Let C be a  clause with , for some literal x. Then we can either simplify this case further or branch  and .

At this point in time, no  clauses are in the formula. Hence, all variables must have weight at least 0.875. We deal with the different cases below.

•
. Then . Say y is the only literal in δ. Then we must have that  and . No branching is required here.

•
. Since Line 3 of the algorithm does not apply anymore, we know that . Here, we branch  and . When , we remove y and z. Giving us a change of measure of . When , . This gives us a change of measure of  as well. Therefore, we have a branching factor of .

•
. Note that if we have the clause , then we know that . So, we can simplify this case further. Therefore, with Line 3 not applying, if , we must have at least 3 different variables in δ. Branching  will remove all variables, giving us a change of . On the other hand, when , we only remove x, with a change of measure of 0.875. This gives us .

This completes the case for  clauses containing a literal that appears twice. Here, since we are either simplifying some cases or branching  and  and are not doing any linking here, there will not be an increase in weights for any variable.
8.
Let C be a  clause, where . We deal with such clauses by choosing and branching certain variables.

At this point, all literals in any  clause must appear once. We handle the different cases below.

•
. Let . Then we negate all the literals in C to get . Then C becomes a  3-literal clause and the overall measure drops.

•
. Then let . We branch ,  and  and . For the branch , , we get a change of measure of . For the branch  and , we get a change of measure of . This gives us a branching factor of .

•
. Let . Then when  (first branch), δ becomes a  4-literal clause. This gives us a change of measure of . When  (second branch), δ becomes a  4-literal clause., giving us a change of measure of 0.875. This gives us an initial branching factor of . Now we apply vector addition on the 1st and 2nd branch. For the 1st branch, we remove a  4-literal clause, giving us a change of measure of . For the second branch, we remove a  4-literal clause, giving us a change of measure of . This gives us a total branching factor of .

•
. We choose two literals  and branch  (1st branch),  (2nd branch) and  (3rd branch). When , we remove all variables, giving us a change of measure of . When , we remove x and the remaining clause drops to a  4-literal clause, giving us a change of measure of . When , we remove , giving us . This gives us an initial branching factor of . We apply vector addition to the 3rd branch. For the 2nd branch, we get a  4-literal clause, which gives us a branching factor of  from . Applying branching vector addition to the 2nd branch, we get the following branching factor .

•
. We choose two literals  and branch ,  and . When , we remove all 7 variables, giving us a change of measure of . When , then the clause drops to a  5-literal clause, giving us a change of measure of . When , we remove , giving us a change of measure of . This gives us a branching factor of at most .

This completes the case for all  clauses. Note that for the above cases where we perform linking of variables, the increase in weights for that surviving variable has been factored into our branching factors.
9.
A  clause C containing a literal x appearing more than once. Therefore, we can have  or , for some literal x and some subclause δ. If we can either simplify this further or branch the variable  and .

At this point onwards, all the variables in the formula must have weight 1. If , then branch  and .

•
, then .

•
. Note that if  and since Line 3 of the algorithm does not apply anymore, we know that there must be at least two different variables in δ. Therefore, branching  removes all 3 variables, while  only removes 1. This gives us a branching factor of .

Now, we deal with the case that  and there are no literals y appearing three times.

•
. Then δ must have two different variables. If not, then the case  is not satisfiable. For this case, . No branching is involved here.

•
. If , then we have . Then . Else . Here, we branch  and . When , we remove x, while the clause drops to a  clause, giving us a change of measure of . When , we remove the variable x with weight 1, while the rest of the literals in δ be assigned 1. This gives us a branching factor of .

•
. Then δ cannot contain only 2 different variables. Else, we will have a case of , which is not satisfiable. Therefore, δ must contain at least 3 different variables. Now if . Then we must have that . No branching is required here. If , with 4 different variables in δ, then we branch  and . When , we remove x and it drops to a  4-literal clause. This gives us a change of measure of . Now , we have a change of measure of 1. This gives us an initial branching factor of . For the first branch, δ becomes a  4-literal clause, giving us a branching factor of . This gives us a branching factor of .

•
. If , then we know that . Hence, no branching is involved here. If , then we branch  and . When , then δ drops to a  clause. In this case, y must then be set to 0. This gives us a change of measure of . On the other hand, when , we have a change of measure of 1. This gives us a branching factor of . If , then we again branch  and . When , we have a change of measure of . When , we have a change of measure of 1. This gives us a branching factor of .

•
. If , then we must have . This case is not satisfiable. , then we must either have  (i),  (ii) or  (iii). For (i), we have . For (ii), we must have  and (iii) is not satisfiable. No branching is required here. Finally, if , then we branch  and . When , then we have a change of measure of . When , we have a change of measure of 1. This gives us a branching factor of .

This completes the case for a  clause containing a literal x appearing more than once. For this line onwards, we do not have to worry about increase in weights of variables due to linking since every variable has weight 1 now.

10.
Let C be a  clause. Choose x in C and branch  and .

At this point, all literals in C must appear once. We consider all cases here with .

•
. Let . Then let . Then C becomes a  4-literal clause and the overall measure drops.

•
. Let . Then let . Then C becomes a  clause and the overall measure drops.

•
. Let , for some literal x and subclause δ. When , δ becomes a  clause, this gives us . On the other hand, when , δ is a  5-literal clause, which we can downgrade to a  5-literal clause by negating all the literals, giving us a change of measure of . This gives us a branching factor of .

•
. Let . We branch ,  and . When , δ drops to a  clause, giving us . When , we remove x and δ drops to a  clause, giving us . When , δ becomes a  5-literal clause, which we can downgrade to a  5-literal clause, giving us . This gives us a branching factor of .

•
. Let . We branch  (first branch),  (second branch) and  (third branch). When , δ drops to a  clause, giving us . When , we remove x and δ drops to a  clause, giving us . When , we remove , giving us a change of measure of 2. This gives us an initial branching factor of . We apply vector addition on the 1st branch, where δ is a  6-literal clause. The branching factor of a  6-literal clause is . This gives us a branching factor of .

•
. Let . We branch ,  and . When , δ drops to a  clause, giving us . When , we remove x and δ drops to a  clause, giving us . When , we remove only , a change of measure of 2. This gives us a branching factor of at most .

Comparing all the branching factors in the analysis above, we have the following result:
Theorem 9

The algorithm that solves G3XSAT runs in  time.

5. G4XSAT (polynomial space)
In this section, we present an  time algorithm to solve G4XSAT. Our algorithm for G4XSAT is similar to our algorithm to solve G3XSAT and extends it. However, we assign in the G4XSAT algorithm to the variables other weights than in the corresponding cases of the G3XSAT algorithm.

5.1. Nonstandard measure for the G4XSAT algorithm
Let  be a variable in φ. Let j be the lowest number such that  appears in a  clause; without loss of generality, every variable appears in a clause, as other variables can be ignored. We define the weight  for  as the following in dependence of j:
  Similar to our G3XSAT algorithm, the weights chosen here are optimal values given by our linear search computer program to bring our overall runtime for this algorithm to as low as possible. Variables in  have weight 0.6464, variables in  have weight 0.8376, variables in  have weight 0.9412, and finally variables in  have weight 1.

5.2. Algorithm
Similar to the earlier algorithms, Line 1 has highest priority, followed by Line 2, etc. We call our recursive algorithm G4XSAT(.).

Algorithm: G4XSAT.

Input: A CNF formula φ.

Output: 1 for satisfiable φ and 0 for unsatisfiable φ.

1.
If any clause is not satisfiable, then return 0. If there are no clauses left, return 1.

2.
If there are clauses  where there is a literal x appearing j times, , then return G4XSAT.

3.
If there is a  clause  or , for some literal x and δ, then let the new clause be , for . Let  be the updated formula and return G4XSAT. If , remove that clause and return G4XSAT.

4.
If there is a  clause , then let the new clause be δ. Update it as  and return G4XSAT.

5.
If there is a  clause, for , with each literal in that clause appearing exactly i times, then drop the clause to a  clause with each literal appearing exactly once. If there is a  clause C with each literal x appearing  times, for some j, then drop C to a  clause with each literal x appearing j times. Let  be the new formula and return G4XSAT.

6.
If there is a  clause C, then we choose two literals  and branch  and . Then return G4XSAT() ∨ G4XSAT().

7.
Let C be a  clause with . We branch  and . Return G4XSAT() ∨ G4XSAT().

8.
Let C be a  clause. We choose k literals  to branch . Return G4XSAT() ∨ G4XSAT()  G4XSAT().

9.
A  clause C containing a literal x appearing more than once. Then  or , for some literal x and some subclause δ. We will either simplify the cases further or branch the variable  and . If we simplify, let  be the updated formula. Return G4XSAT(). If we branch x, then return G4XSAT() ∨ G4XSAT().

10.
Let C be a  clause. We will either simplify the cases or applying branching here. If we were to simplify the case, we update the formula as . Return G4XSAT(). Else if we are branching, then we choose k literals  to branch . Return G4XSAT() ∨ G4XSAT()  G4XSAT().

11.
A  clause C containing a literal x appearing more than once. We can either simplify the cases further or we branch  and . If we simplify the case, then update the formula as  and return G4XSAT(). Else we branch  and  and return G4XSAT() ∨ G4XSAT().

12.
Let C be a  clause. We will either simplify the cases or applying branching here. If we were to simplify the case, we update the formula as . Return G4XSAT(). Else if we are branching, then we choose k literals  to branch . Return G4XSAT() ∨ G4XSAT()  G4XSAT().

Again, we show that we have covered all the cases in our algorithm. In Line 1, if there is any clause that is not satisfiable, then we return 0. In Line 2, if there are any literals appearing j times in a  clause, , then we can set  since we are not allowed to over satisfy. In Line 3 of the algorithm, if there are constants 1 in the formula, we can either downgrade the clause or remove the clause, depending whether the clause is satisfied or not. In Line 4 of the algorithm, we remove the constants 0 in the formula. After Line 4, no more constants exist in the formula. In Line 5, we deal with special cases where every literal in the clause appears i times in a  clause, allowing us to downgrade it to a  clause. Lines 1 to 5 are simplification rules.
From Line 6 onwards, they are branching rules which contribute to the exponential time growth of the algorithm. In Line 6 of the algorithm, we branch and deal with all  clauses. In Line 7 of the algorithm, we deal with  clauses containing literals x appearing twice. In Line 8 of the algorithm, we remove the remaining  clauses by branching them (now all  clauses have literals in it appearing only once). After which, no more  clauses exist in the formula. In Line 9 of the algorithm, we deal with  clauses with literals appearing more than once. In Line 10, we remove the remaining  clauses, where every literal appearing in the  clauses only appears once. In Line 11, we deal with  clauses with literals appearing more than once in it. Finally, in Line 12, we remove all  clauses, where every literal in the clause appears only one. Therefore, we have covered all cases and hence the algorithm is correct. Note that our G4XSAT algorithm is just an extension of our G3XSAT algorithm, by handling  clauses.

5.3. Analysis of our algorithm
In this section, we analyse the time complexity of our G4XSAT algorithm. Similar to our previous algorithm, whenever we link variables in  clauses, where , we need to factor in the increase of measure because the surviving variable may now appear in a  clause. We have to factor in an increase of measure of  when linking in  clauses, and  when linking in  clauses, and  when linking in  clauses.

Since Lines 1 to 5 are simplification rules, they will only take polynomial time. Hence, we will analyse from Lines 6 onwards since they are all branching rules.

6.
If there is a  clause C, then we choose two literals  and branch  and .

•
. Then let . When , we remove z, giving us a change of measure of . When , then , giving us a change of measure of . This gives us a branching factor of .

•
. Then let . Then when , then . This gives a change of . When , then . This gives us a change of measure of . Therefore, we have a branching factor of .

•
. Let . When , then . This gives us a change of measure of . On the other hand, when , we only remove the 2 variables, giving us a change of measure of . This gives us a branching factor of .

This completes the case for all  clause. Note that the increase of weights due to linking variables have been factored in our branching factors above.

7.
Let C be a  clause with .

From this point on, all variables have at least weight 0.8376. Then we can either simplify this case further or branch  and .

•
. Then . No branching is involved here.

•
. Then if , then this case would have already been handled by Line 5 of the algorithm. If , for some literal , then .

•
. Then if , then . If , then when , we remove all 4 variables, giving us a change of measure of . When , we only have a change of measure of 0.8376. This gives us a branching factor of .

•
. Since Line 5 of the algorithm does not apply anymore, then we know that . Branching  and  will give us a branching factor of at most .

This concludes the case for  clauses having a literal appearing twice in it. Here, since we are only simplifying the cases or branching  and , there will be no increase in weights of variables.

8.
Let C be a  clause. At this point in time, there are no literals in C that appears twice. We handle this case by case again.

•
. Let . Then let  be the new clause obtained by negating all the literals in it. In this case, C becomes a  3-literal clause and the overall measure decreases. No branching is needed for this case.

•
. Let . Then we branch ,  and  and then . The first branch gives us . The second branch gives . This gives a branching factor of .

•
. Let . We branch  (first branch) and  (second branch). When , we have a change of measure of . When , we remove x, giving us a change of measure of 0.8376. This gives us an initial branching factor of . For the first branch, δ becomes a  4-literal clause. This gives us a branching factor of . For the second branch, δ becomes a  4-literal clause, giving us a branching factor of . Applying branching vector addition to the first and second branch respectively, this gives us .

•
. Let . We branch  (first branch),  (second branch),  (third branch). When , then we remove at least 6 variables having weight 0.8376, this gives us a change of measure of . When , we remove x and δ drops to a  clause of at least 4-literal, giving us a change of measure of . Finally, when , we remove 2 variables of weight 0.8376, giving us a change of measure of . This gives us a branching factor of .

This completes the case for all  clauses. The increase in weights of variable due to linking variables have been factored into our branching factors above.
9.
A  clause C containing a literal x appearing more than once. Therefore, we can have  or , for some literal x and some subclause δ. If we can either simplify this further or branch the variable  and .

At this point onwards, all the variables in the formula must have weight at least 0.9412. If , for some literal x, then we split it into different cases.

•
. Then , no branching involved here.

•
. Since Line 5 does not run anymore, we know that δ contains at least two other variables. Therefore, branching , will remove at least 3 variables in C, giving us a change of measure of . On the other hand, when , we have a change of measure of 0.9412. This gives us a branching factor of .

Now, if literals in C appear at most twice, then let .

•
. Now If , then all literals must be assigned 1. Now, if  and , then this is not satisfiable. Now if we have , then we know that  and .

•
. If , then . If , then we branch  and . When , δ drops to a  3-literal clause, giving us a change of measure of . When , then , giving us a change of measure of . This gives us a branching factor of .

•
. If , then C is not satisfiable. If , then (i)  or (ii) . For (ii),  and no branching is involved here. For (i), when , then  and . When , then  and . In either case, we can simplify this case by setting . Finally, if , then we branch  and . When , δ drops to a  clause of at least 4-literal, giving us a change of measure of . When , we have a change of measure of 0.9412. This gives us a branching factor of .

This completes the case of a literal x appearing in a  clause more than once. Here, since we are only simplifying the cases or branching  and , there will be no increase in weights of variables.

10.
Let C be a  clause. At this point, every literal appearing in a  clause can only appear once.

•
. Assign all literals 1.

•
. Let . Then let . C becomes a  4-literal clause and the overall measure drops.

•
. Let . Then let . Then C becomes a  clause and the overall measure drops.

•
. Let . We branch  and . When , we remove x and δ drops to a  5-literal clause, giving us a change of measure of . When , we remove x and δ becomes a  5-literal clause, where we can drop it to a  5-literal clause by negating all the literals, giving us a change of measure of . This gives .

•
. Let . We branch ,  and . When , we remove , with δ becoming a  5-literal clause, giving us a change of measure of . When , we remove x via linking and δ drops to a  clause, giving us . When , δ drops to a  5-literal clause, where it can be further dropped to a  5-literal clause, giving us . This gives us .

•
. Let . We branch  (first branch),  (second branch) and  (third branch). Now when , δ drops to a  clause, giving us . When , we remove x via linking and δ drops to a  clause, giving us . When , we remove , giving us . This gives us . On the third branch, δ becomes a  6-literal clause, with branching factor of . Applying vector addition on the third branch, the sum of these vectors gives us a branching factor of .

•
. Let . We branch ,  and . When , we remove  and δ drops to a  7-literal clause, giving us a change of measure of . When , we remove x via linking and we are left with a  7-literal clause, giving us a change of measure of . Finally, when , we remove 2 variables, giving us a change of measure of . This gives us a branching factor of at most .

This completes the case for all  clauses. The increase in weights due to linking variables have been factored into our branching factors above.

11.
A  clause containing a literal x appearing at least twice in it.

At this point, all variables in the formula have weight 1. If , then . Branch  and . When , we will remove another variable, giving us a change of measure of 2. On the other hand, when , we remove only 1 variable. This gives us a branching factor of at most .

Now, now suppose that a literal only appears at most three times in C, then let , for some literal x.

•
. Assign all literals in C to be 1.

•
. Then . Let  be the two literals in δ. Then  and .

•
. If , then this case is not satisfiable. If , then  and . If , then  as x cannot be 0.

•
. If , then  and . If , then  and . If , or in general , then we branch  and . When , we remove x, and then δ drops to a  clause, this gives . On the other hand, when , we remove x. This gives us a branching factor of .

•
. If δ has only two different variables, then the only cases we have are either  or . For both cases, C is not satisfiable. Therefore, there must be at least 3 different variables in δ. Therefore, branching  and  will give us again the branching factor .

This completes the case of a literal appearing at three times in C. Now if there is a literal x appearing twice in C, then let . Note that if every literal appears twice in C, then C can be downgraded to a  clause with the same literal appearing exactly once. Such cases will then be handled by earlier lines of the algorithm.

•
. Assign all literals in C to be 1.

•
. If , then  and . If , then .

•
. If , then we downgrade C into a  clause. If , then . If , then branching  will remove x, and cause the clause to drop to a  4-literal clause, giving us a change of measure of . On the other hand, when , then the clause drops to a 4-literal clause, where all literals must be assigned 1 then. This gives us a branching factor of .

•
. If , then . If , then we branch  and . When , δ drops to a  clause, giving us a change of measure of . When , then , this gives us a change of measure of at least 2. Therefore, we have . Now if , then we branch  and . This gives us  for . When , δ is a  5-literal clause. We can negate all the literals in δ, and hence δ drops to a  5-literal clause, giving us a total change of measure of . Therefore, we have .

•
. If , then . C can be downgraded to a  clause with . If , then we can either have  or . We have  for the former and  for the latter. If , then (i)  or (ii)  or (iii)  or (iv) . For (iii), we can set . For (iv), we can set . For (i) and (ii), we branch ,  and . When , we get a change of measure of 6. When , then the remaining clause drops to a  clause, this gives us . Finally, when , we get a change of measure of 2. This gives us a branching factor of . Finally, when , then we branch  and . When , δ drops to a  clause, this gives us . On the other hand, when , we have a change of measure of 1. This gives us a branching factor of .

This completes the case where a literal appears more than once in a  clause. From this point onwards, all variables have weight 1. Hence, there will not be any increase in variable weights.

12.
Let C be a  clause. At this point in time, all literals must only appear once in C.

•
. Assign all literals to 1.

•
. Let . Then we can negate all the literals in C to get , and then C becomes a  clause and the overall measure drops.

•
. Let . Then we can negate all the literals in C to get , and then C becomes a  clause and the overall measure drops.

•
. Let . Then we can negate all the literals in C to get , and then C becomes a  clause and the overall measure drops.

•
. Let . Now we branch  and . When , δ drops to a  clause, this gives us . On the other hand, when , δ becomes a  7-literal clause, which can be downgraded to a  clause, giving us . Therefore, we have a branching factor of .

•
. Let . Then we branch  (first branch),  (second branch) and  (third branch). When , we remove , and δ drops to a  7-literal clause, giving us . When , we remove x and δ drops to a  7-literal clause, giving us . Finally, when , we have δ becomes a  7-literal clause, where we can further drop it to a  7-literal clause, giving us . Therefore, we have a branching factor of .

•
. Let . We again branch  (first branch),  (second branch) and  (third branch). Now when , we remove  and δ drops to a  8-literal clause, giving us . When , we remove x and δ drops to a  8-literal clause, giving us . When , we remove , giving us a change of measure of 2 and δ is a  8-literal clause. This gives us . For the first branch, δ is a  8-literal clause with a branching factor of . For the third branch, we have a branching factor of . Applying vector addition to the first and third, we have the branching factor of .

•
. Let . We branch  (first branch),  (second branch) and  (third branch). When , δ drops to a  9-literal clause, giving us a change of measure of . When , we remove x and δ drops to a  9-literal clause, giving us a change of measure of . Finally, when , we have a change of measure of 2. This gives us an initial branching factor of . For the first branch, we have a  9-literal clause, with a branching factor of . Applying vector addition to the first branch, we get a branching factor of .

•
. Let . We branch , , . When , δ drops to at least a  10-literal clause, giving us a change of measure of . When , we remove x and δ drops to at least a  10-literal clause, giving us a change of measure of . Finally, when , we have a change of measure of 2. This gives us a branching factor of at most .

We have therefore covered all the cases needed in the algorithm. This proves the correctness of the algorithm as well. By comparing all the branching factors obtained above, we have the following result:
Theorem 10

The algorithm that solves G4XSAT runs in  time.

6. Exponential space algorithms
Let m denote the number of clauses in the formula φ. Here, we present faster exact algorithms to solve GiXSAT. This is a modification of Schroeppel and Shamir's result to bring down the complexity of generalised XSAT and Knapsack algorithms from  to  using exponential space. Roughly speaking, they just note down for each clause how many satisfying literals are required and then they calculate for each possible assignment of the first half of variables how many of literals of each clause are satisfied. Each of these up to  vectors is written into a database; note that by standard database techniques, reading (= checking whether a vector is in the database) and writing into a database takes time logarithmic in the size of the database and thus is polynomial time for our purposes. After that one processes the variables of the second half and for each possible assignment y, one computes the vector s of literals which need to made true in the first half of the variables in order to have a match; if this vector is in the database then a solution exists. One major achievement of Schroeppel and Shamir [17] is that their space usage is roughly  instead of  what our sketch of the algorithm gives; we do not intend to optimise the space here and do therefore settle for the conceptually easier algorithm outlined. Dahllöf verified that the result of Schroeppel and Shamir is indeed applicable to GiXSAT and solved this problem for  in  time.

In this section, we modify the results of Schroeppel and Shamir to derive faster exact algorithms to solve GiXSAT in exponential space. We do this with an asymmetric splitting in which we exploit that this splitting of the variables can be done such that for the larger half of the variables, the vectors are all the solutions of the smaller GiXSAT problem which consists of all clauses fully covered by the half they are in and as the larger half is a union of clauses, one therefore can enumerate all the possible solutions of that smaller problem only which will be less than 2 to the number of variables; these savings then allows to handle αn variables instead of 0.5n variables for some larger α and the number of tuples generated and time used is then actually equal within . For the smaller half, one computes for every possible choice of the remaining variables the corresponding vector to be checked to be in the data base for a match and if found, the instance of the GiXSAT problem is satisfiable. We now explain our algorithm and then the verification more formally.

Algorithm to solve GiXSAT

Input: φ.

Output: 1 for satisfiable φ and 0 for unsatisfiable φ (see Step 5 of the algorithm).

1.
We choose α strictly between 0 and 1. Then we split the n variables into two groups, one containing αn many, while the other containing . For the αn variables, we choose them such that they are all those variables which belong to some set of clauses S; in order to meet our cut-off, there can be one clause which is used only partially, say it has  variables which h going into the set and k not being in. Then we split it into a h-literal and k-literal clause and branch over the  cases on how many of the h literals are true in the clause of S; this only imposes a constant additional factor on the runtime of the algorithm. Let  be the set of all other clauses.

2.
Branch clause by clause for each clause ; for this we substitute the fixed variables in a branched clause in all other clauses by their values so that some  clauses can be reduced to  clauses for some  where  is the number of literals in the clause already set to 1; in some cases like ℓ being negative, the corresponding branch is unsatisfiable.

3.
Note down for each possible choice of the αn variables and for each clause in , how many literals in each of these clauses they made true (and discard solutions which satisfy too many or too few literals) and write the corresponding vector into a database (which can be updated and checked in polynomial time).

4.
For every possible choice of values of the remaining  variables, compute the vector of how many literals in each clause in S' must have been satisfied by the other half of the splitting to combine to a full solution and check whether this vector is in the database.

5.
If for one possibility the corresponding vector is found in the database then output 1, else output 0.

6.1. Single occurrence
We first investigate the case that each variable occurs in a clause at most once. This is a restriction assumption, but it is easier to deal with mathematically. Once we have obtained the values for the single occurrence case, we will show that the values for the multi-occurrence case (where a variable can occur several times) are the same. Note that the choosing the value of α is different for each GiXSAT, . When branching clause by clause, we do not take all combinations of the variables, but only those which make the clause true. This allows us to improve the time further.

We give here the values of α for G2XSAT, G3XSAT and G4XSAT. The numbers in the table are  
 . This is the branching factor, if one branches a  clause with all k distinct variables (independent on whether these are negated). Note that only  clauses with  are interesting, as one can negate all variables in a  clause to obtain an equivalent  clause. Furthermore, if one branches only the first variable in a repetition-free  clause with k variables and if  then one either has to solve a  clause of  variables or a  clause with  variables. As  
  
  
  and as branching a  
  clause has k possibilities (depending on which literal is 1), one has for the problem to determine the branching factor of repetition-free  k-literal clauses that this one is  
  possibilities for k variables; now in order to normalise this to the average of 1 variable, the branching factor is  
  per variable. This allows to compute the overall branching factor, when brute-forcing clause by clause (and not variable by variable) a repetition-free GiXSAT instant of  clauses with  and  (where k is the number of variables in the current clause considered) is then the largest number c occurring within the first i column in of the corresponding entry in the first or second table below (where void entries are ignored as there ). If one does the splitting of variables in αn variables branched clause by clause and  variables branched by brute force per variable, then one needs that  for the optimal α chosen. The k in these calculations refers also to the row number in the table.

6.2. G2XSAT

Length of clause	Time Complexity	Branching factor for h = 1,2 w/o α
k	formula for  
 	value  
 
2	 
 	1.4143
3	 
 	1.4423, 1.4423
4	 
 	1.4143, 1.5651
5	 
 	1.3798, 1.5849
6	 
 	1.3481, 1.5705
7	 
 	1.3205, 1.5449
In the table above, the values in each row denote the branching factor of a clause of that length. The first value denotes the branching factor of branching a  clause, while the second value denotes the branching factor of branching a  clause. For example, for the clause of length 5, we have  
  and  
 .

Let k denote the length of the clause. For the verification that for  it holds that , note that one can write this as , where e is Euler's constant of approximately 2.71828 and log is in this paragraph the natural logarithm. Now this is equivalent to  and . The derivative of this is  and as  is approximately 0.4574, for ,  and the derivative is negative. So for all  it holds that  does not grow and has a negative value, as the term is at  already approximately −0.0365. This justifies the conclusion, that 1.5849 is the maximal value of a term  for all k which are natural numbers; not only for those k in the table but also for the larger ones. Similarly one can derive that  is bounded by 1.5849 for all natural numbers k.

From the table, we see the max branching factor comes from branching  5-literal clauses, which gives 1.5849.

Since we want the overall timing for both sides of the split to be the same, we solve for α by having . Therefore, this gives . Since , our G2XSAT algorithm runs in  time.

6.3. G3XSAT and G4XSAT
We expand the number of columns and rows in the table from the previous section.


Length of clause	Time Complexity	Branching factor for h = 1,2,3,4 w/o α
k	formula for  
 	value  
 
2	 
 	1.4143
3	 
 	1.4423, 1.4423
4	 
 	1.4143, 1.5651
5	 
 	1.3798, 1.5849, 1.5849
6	 
 	1.3481, 1.5705, 1.6476
7	 
 	1.3205, 1.5449, 1.6619, 1.6619
8	 
 	1.2969, 1.5167, 1.6540, 1.7008
9	 
 	1.2766, 1.4891, 1.6361, 1.7115
10	 
 	1.2590, 1.4633, 1.6141, 1.7070
11	 
 	1.2436, 1.4396, 1.5908, 1.6942
...	...	...
We expand the number of columns and rows in the table from the previous section. The values are interpreted in the similar manner as in the previous table.

For G3XSAT, from the above table, we see that the max branching factor comes from branching  7-literal clauses, which gives 1.6619. Again, we solve for α by having . This gives . Therefore,  and G3XSAT algorithm runs in  time.

For G4XSAT, we see from the same table that the max branching factor comes from  9-literal clauses, which gives 1.7115.

Taking , we have . Therefore . Hence, our G4XSAT algorithm takes  time.

6.4. Multi-occurrences
Note that in the previous section, for our GiXSAT algorithm, , we made an assumption that each literal appearing in any clause only appears once. However, it is possible that a literal in that clause may appear more than once. We assume that a  clause of the form  is simplified to the  clause α and therefore we assume that every literal either occurs only positive or only negative. To keep notation simple, as we treat clause by clause, we assume that in the clause investigated, all variables appear positive.

In this section, we show that even if such cases happen, the number of cases that we can have to satisfy our clauses are satisfied are bounded above by the number of cases that we have shown in the previous section. This therefore implies that we get a better branching factor. Hence, the worst case is such that each literal appears exactly once in any clause.

Given a  clause C, for , we let  denote the number of possible ways to satisfy that clause where . Then we define  as the maximum number of ways to satisfy a clause  clause, with  which has ℓ variables. If , then , for any h. Next, we define , which is the maximum number of possible ways to satisfy a  clause, , with ℓ many variables, where each variable appears only once in that clause;  are therefore the numbers which we investigated in the single-occurrence case. By definition, we have  
 . We recall that in the sections for the single occurrence case and the tables there we used that  
  in the case that  and  
  in the case that one can choose this k such that  and .

Our goal is now to show that  for all ℓ and . For , we run a computer program to display the values of  and  to show that . After which, we prove by induction that , for , for .

1.
. Then  
 . Every literal in C must appear exactly once. Therefore, we have ℓ many possible options to satisfy C. Similarly we have  
 . Therefore, .

2.
. Let b denote the number of variables that appears twice (as the same literal) in C and a denote the number of variables that appear once in C. Note that . Then  denotes the number of possible combinations to satisfy a  clause given that it has ℓ number of variables, with a many variables appearing once and b many variables appearing twice. We define  as the maximum number of possible choices to satisfy a  clause, , with ℓ many number of variables. Hence . We give the recursion formula for  below.

•
. When there are no variables in this clause, C is unsatisfiable.

•
. When there are only 1 variable in C, with only 1 variable appearing once, then C is unsatisfiable.

•
. When there is a variable appearing twice in a  clause, then there is only 1 way to satisfy this clause, by assigning the literals to 1.

•
For , we define the following:
 	
  The recursion formula of  can be seen as follows: We choose any variable x appearing twice to branch. If , then the clause is satisfied and this counts as a way of satisfying the clause. Hence the “+1” in the formula. On the other hand, when , then the number of choices to satisfy it is given in . When , then we are only left with variables appearing once in the formula. Then to satisfy the  clause, there are  
  many choices to satisfy it.

With this, we compare  with  below:


ℓ	1	2	3	4	5	6	7	8
F(ℓ,2)	1	2	3	6	10	15	21	28
G(ℓ,2)	1	2	3	6	10	15	21	28
With this, we see that  for all .

3.
. Let c denote the number of variables that appears three times in C, b denote the number of variables that appear twice and a denote the number of variables that appear once in C. Note that . Then  denotes the number of possible combinations to satisfy a  clause given that it has ℓ number of variables, with a many variables appearing once, b many variables appearing twice and c many variables appearing three times. We define  as the maximum number of possible choices to satisfy a  clause, , with ℓ many number of variables. Hence  ( was defined in the case ). We give the recursion formula for  below.

•
. If there are no variables, then this clause is not satisfiable.

•
. If there is only 1 variable that also appears once, then this clause is not satisfiable.

•
. If there is only 1 variable that also appears twice, then this clause is not satisfiable.

•
. If there is only 1 variable that also appears three times, then the only way to satisfy this clause is to assign this literal as 1.

•
For , we define the following:
 	
  The recursion formula of  can be seen as follows: We choose any variable x appearing three times to branch. If , then the clause is satisfied and this counts as a way of satisfying the clause. Hence a “+1” in the formula. On the other hand, when , then the number of choices to satisfy it is given in . When , then we are only left with variables appearing at most twice in the formula. Suppose now we choose any variable y appearing twice to branch. When , then the clause becomes a  clause where we can choose any of the a variables to follow up to branch. This explains the “+a” portion. When , we have  many choices left. Finally, when , then to satisfy a  clause, we can have  
  choices to choose from. This explains the recursion formula.

With this, we compare  with  below:


ℓ	1	2	3	4	5	6	7	8
F(ℓ,3)	1	2	3	6	10	20	35	56
G(ℓ,3)	1	2	3	6	10	20	35	56
With this, we see that  for all .

4.
. Let d denote the number of variables that appears four times in C, c denote the number of variables that appears three times, the number of variables that appear twice as b and finally the number of variables that appear once as a. Note that . Then  denotes the number of possible combinations to satisfy a  clause given that it has ℓ number of variables, with a many variables appearing once, b many variables appearing twice, c many variables appearing three times and finally d many variables appearing four times. We define  as the maximum number of possible choices to satisfy a  clause, , with ℓ many number of variables. Hence  ( was defined in the case ). We give the recursion formula for  below.

•
. If there is a clause with no variables, then it is not satisfiable.

•
. If there is a variable appearing once, then it cannot satisfy a  clause.

•
. If there is a variable appearing twice, then it cannot satisfy a  clause.

•
. If there is a variable appearing three times, then it cannot satisfy a  clause.

•
. If there is a variable appearing four times, then that literal must be assigned 1, which is the only way to satisfy this clause.

•
For , we define the following:
 	
 	
  The recursion formula of  can be seen as follows: We choose any variable x appearing four times to branch. If , then the clause is satisfied and this counts as a way of satisfying the clause. Hence a “+1” in the formula. On the other hand, when , then the number of choices to satisfy it is given in . When , then we are only left with variables appearing at most three times in the clause. Suppose now we choose any variable y appearing three times to branch. When , then the clause becomes a  clause where we can choose any a many variable to follow up to branch. This explains the “+a” portion. When , we have  many choices left. Next, if , then the clause contains only variables that appear at most twice. We choose any variable z that appears twice in the clause to branch. When , the clause becomes a  clause. Here, we can choose from the remaining  variables (that appear twice) or choose any two of the variables that appear once ( 
 ). Therefore, we have  
 . On the other hand, when , we have  many choices. Finally, when , then to satisfy a  clause, we can have  
  choices to choose from. This explains the recursion formula.

With this, we compare  with  below:


ℓ	1	2	3	4	5	6	7	8
F(ℓ,4)	1	2	3	6	10	20	35	70
G(ℓ,4)	1	2	3	6	10	20	35	70
With this, we see that , .

Now, for any , we prove the remaining  by induction, with  shown above. Suppose by induction hypothesis that . Now for all , we know that  
  
  
  
 . Therefore,  
 . We need to show that .
Let x be a variable in a  clause, , with  many variables. When , then there are at most  many possibilities to satisfy the clause. When ,  clause can be satisfied, or drop to a  clause, for . Therefore we can have at most  many possible ways to satisfy the clause when . Therefore . Note that for any ℓ, we have . Therefore,  
  
  
 . This completes the inductive proof. Therefore, even if multi-occurrences occur in a clause, the worst case scenario of the algorithm still comes from dealing with clauses with every single variable appearing once in the clause.

7. Summary and future work
In this paper, we gave polynomial space algorithms to solve G2XSAT in  time, G3XSAT in  time and G4XSAT in  time. These algorithms were designed with a nonstandard measure in mind and the use of state based measure to optimize the current time bound for our G2XSAT algorithm. For our G3XSAT and G4XSAT algorithms, our goal is to introduce simple algorithms (removing , ,  clauses in that order) with the help of nonstandard measure to improve the current state of the art algorithm, without having to deal with an explosion of cases. However, we did not spend as much effort on these algorithms as we did for the G2XSAT algorithm, so there might still be some room to improve the bound further.

We also gave exponential space algorithms to solve G2XSAT, G3XSAT and G4XSAT. The idea here is to split the variables asymmetrically; on one side we branch clause after clause and obtain a better branching factor, while we brute force the variables on the other side; we balance the load such that both sides need the same runningtime. This allows us to improve on the EXPSPACE algorithm given by Schroeppel and Shamir with complexity  where our bounds are then  for G2XSAT,  for G3XSAT and  for G4XSAT. We note that this can be done for all GiXSAT with  and that the sequence of the corresponding complexities converges from below to .

Furthermore, our polynomial space algorithms are quite complex. Future investigations might try to find better ways to improve the algorithm timings without getting the explosion of cases which every small improvement on the current timings gave in our attempts; however, we ourselves did not find a way to do this.