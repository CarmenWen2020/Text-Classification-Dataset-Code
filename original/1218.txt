Abstract
We propose a technique to construct physical Zero-Knowledge Proof (ZKP) protocols for puzzles that require a single loop draw feature. Our approach is based on the observation that a loop has only one hole and this property remains stable by some simple transformations. Using this trick, we can transform a simple big loop, which is visible to anyone, into the solution loop by using transformations that do not disclose any information about the solution. We illustrate our technique by applying it to construct physical ZKP protocols for two Nikoli puzzles: Slitherlink and Masyu.

Previous
Next 
Keywords
Cryptography

Physical zero-knowledge proof

Nikoli

Masyu

Slitherlink

1. Introduction
Introduced by Goldwasser, Micali, and Rackoff [13], Zero-Knowledge Proof (ZKP) systems are cryptographic protocols between a prover P and a verifier V. Given an instance  of a problem, only the prover P knows its solution w. The prover P wants to convince the verifier V that he/she knows w without revealing any information about w. In cryptography, the ZKPs are used to allow a party to prove that it has data without leaking any information on this data. A zero-knowledge proof should satisfy the following three properties:

Completeness.
If P knows w, then P can convince V.

Extractability.
If P does not know w, then P cannot convince V. This property involves the standard soudness and proof-of-knowledge. If there is a machine, called the extractor, that can interact P and extract w, then the extractability holds.

Zero-Knowledge.
V cannot obtain any information about w. Assuming a probabilistic polynomial time simulator  that can emulate the interaction between P and V but does not contain w, if it outputs of the protocol and  follow the same probability distribution, then the zero-knowledge holds.

It is well known that for any NP-complete problem, there exists an interactive ZKP protocol [12]. Later, one of the first physical ZKP protocols was introduced by Gradwohl et al. [14] for a popular puzzle, Sudoku. A player of Sudoku who knows a solution wants to prove to someone else that he/she knows the solution using only physical objects. For this, the authors utilized physical cards. Recently, more efficient ZKP protocols [35] have been proposed. They used envelopes and physical tricks to improve the original protocol. Notice that for each specific puzzle, there exists a specific ZKP; indeed, one cannot simply use a ZKP for Sudoku to be applied to Masyu.

Nikoli1 is a Japanese company famous for designing puzzles. The list of puzzles created by Nikoli contains more than 40 different kinds of puzzles including Sudoku. We focus on two puzzles that aim at drawing a single loop: Slitherlink and Masyu.

•
Slitherlink is one of the most famous pencil puzzles published in the puzzle magazine Nikoli. It was introduced in 1989 in the 26th of Nikoli's Puzzle Times. It is also known as Loop-the-Loop. It is explained on Nikoli's website as follows: “Getting the loop right is absorbing and addictive. Watch out not to get lost in Slitherlink. It's amazing to see how endless patterns can be made using only four numbers (0, 1, 2 and 3)”. The puzzle instance consists of lattice-like dots where some squares contain numbers between 0 and 3. The goal of the puzzle is to draw lines that satisfy the following rules [1]:

1.
Loop Rule: Connect vertically/horizontally adjacent dots with lines to make a single loop and the loop never crosses itself and never branches off.

2.
Numbers Rule: Each number indicates the number of lines that should surround its square, while empty squares may be surrounded with any number of lines.

Fig. 1 shows an example of a Slitherlink puzzle and its solution; one can easily verify that all conditions are satisfied. Slitherlink was proven to be NP-complete in [40] and other variants in [21].
Fig. 1
Download : Download high-res image (78KB)
Download : Download full-size image
Fig. 1. Example of a standard Slitherlink challenge, and its solution.

•
Masyu was invented by Ryuou Yano, originally called Pearl Necklace, and it was introduced in Puzzle Communication Nikoli #84. The goal of this puzzle is to draw a single continuous non-intersecting loop according to some constraints that depend on “black” (filled) or “white” (empty) circles placed on a rectangular grid of squares. The loop can only have 90-degree turns and has to pass through all circles as follows: White circles must be traveled straight through, but the loop must turn in the previous and/or next cell in its path. Black circles must be turned upon, but the loop must travel straight through the next and previous cells in its path. More precisely, it consists of rectangular lattice-like dots where some dots are replaced by black or white circles. We present an example of an initial grid in Fig. 2 and its solution in Fig. 3. The goal is to draw lines that satisfy the following rules:

1.
Loop Rule: Connect vertically/horizontally adjacent dots with lines to make a single loop that never crosses itself.

2.
Through Circle Rule: The loop must pass through all circles.

3.
4.
Fig. 2
Download : Download high-res image (14KB)
Download : Download full-size image
Fig. 2. Initial grid of Masyu puzzle.

Fig. 3
Download : Download high-res image (19KB)
Download : Download full-size image
Fig. 3. Solution of Masyu puzzle.

In 2002, Erich Freidman proved that this puzzle is NP-complete in [11], [17].

Since these two puzzles are NP-complete, we can apply the technique of O. Goldreich [12] to construct a ZKP. Hence our aim is to propose a physical ZKP protocol for puzzles that require to draw a single continuous non-intersecting loop. Taking into account this feature is clearly a challenge that was not present in the previous physical ZKP protocols for Nikoli's puzzles [4], [5], [6], [10], [14].

Contributions  We introduce a technique to construct a ZKP protocol for a puzzle where constructing a single loop is one of the requirements of the solution. The difficulty is to avoid leaking any information regarding the solution to the verifier. For this, we use a topological point of view; more precisely, we use the notion of homology that defines and categorizes holes in a manifold. The main idea is that after any continuous transformations, the number of holes always remains the same. Using this simple idea, we construct transformations that preserve the number of loops in the solution. First, the verifier checks that the initial configuration has only a single big loop. Then, by transforming in several steps this trivial big loop into the solution, the prover convinces step after step that the solution has only one loop at the end by proving that the transformation does not break the loop or introduce an extra hole. This construction is applied to Slitherlink and Masyu, two Nikoli puzzles that aim at drawing a single loop. This technique can be used for any other puzzles that require such type of features in their rules.

Related works  Since Gradwohl et al. [14] introduced the first physical ZKP protocol for Sudoku, physical ZKPs for other puzzles have been proposed, e.g., Nonogram [6], Akari, Takuzu, Kakuro, Kenken [5], Makaro [4], Norinori [10], Numberlink [33], Juosan [24], Suguru [31], and Ripple Effect [34]. Almost all these ZKPs deal with numbers.

There are many physical cryptographic protocols without relying on computers: such examples are a PEZ dispenser [2], [3], tamper-evident seals [28], visual secret sharing schemes [8], and a deck of cards [9]. Among them, card-based cryptography using a deck of cards has been widely studied. Especially, for secure computation of the logical AND function, the number of required cards have been reduced [7], [18], [20], [25], [26], [27], [29], [37], and necessary and sufficient numbers of cards and/or shuffles have been provided [16], [18], [20], [36]. Some recent studies applied card-based techniques to propose practical implementations of Yao's millionaire protocol [23] and secure ranking computation [38].

However, these works do not deal with proving the topological feature of having a single loop in the solution.

Outline  In Section 2, we introduce some notations and useful sub-protocols used for physical ZKP based on cards. In Section 3, we explain how to make a ZKP for a single loop. In Section 4, we describe our ZKP protocol for Slitherlink. In Section 5, we show the security proofs of our ZKP for Slitherlink. In Section 6, we present our ZKP protocol for Masyu. In the next section, we give the security proofs for Masyu before concluding.

2. Preliminaries
In this section, we first introduce some notation of a deck of cards and shuffling actions used in our constructions. Then, we introduce useful sub-protocols.

2.1. Notations
We use a sequence of physical cards denoted by

Image 1
; the black
Image 2
and red
Image 3
cards are called binary cards and
Image 4
are numbered cards. The backs of all cards are identical and denoted by
Image 5
. As seen later, we use binary cards to encode the existence of a line while numbered cards are used for rearranging the positions of cards.
Encoding  Boolean values are encoded with two binary cards as follows:

Image 6
and
Image 7
. Two face-down cards
Image 8
encoding 0 and 1 are called a 0-commitment and a 1-commitment, which are denoted by
Image 9
and
Image 10
, respectively.
In our protocols, a 0-commitment placed on a gap between two adjacent dots means that there is no line on the gap, and a 1-commitment means that there is a line on the gap. Following this encoding, one can represent a loop by putting a commitment on each gap. Note that given an x-commitment for , the negated 
-commitment can be easily obtained by swapping the two cards of the commitment.

Shuffle  Let  denote the symmetric group of degree m. Given a sequence of m face-down cards , a shuffle outputs a sequence of face-down cards , where  is a uniformly distributed random permutation.

Pile-shifting shuffle  This is to cyclically shuffle piles of cards [30]; given m piles, each of which consists of the same number of face-down cards, denoted by , applying a pile-shifting shuffle (denoted by ) outputs , : where s is uniformly and randomly chosen from . A possible implementation of a pile-shifting shuffle is the use of physical cases that can store a pile of cards, such as boxes and envelopes; a player (or players) cyclically shuffle them by hand until everyone lost track of the offset.

If each pile consists of one face-down card, then the shuffle action is called a random cut. An implementation of random cut has been studied using the so-called Hindu Cut without any additional tool [39].

Pile-scramble shuffle  This is a shuffle operation on a sequence of m piles  [15]. For such a sequence of piles, applying a pile-scramble shuffle outputs , where  is a uniformly distributed random permutation. A pile-scramble shuffle uses similar materials as a pile-shifting shuffle but its operation is similar to a shuffle.

Chosen pile cut  The chosen pile cut [19] enables a prover to choose a pile  from m piles () without revealing i to a verifier. The chosen pile cut proceeds as follows, given m piles along with m additional cards:

1.
The prover P holds 

Image 12
s and one
Image 13
. Then, P places m face-down cards below the piles such that only the i-th card is
Image 13
:
2.
Regarding the cards in the same column as a pile, apply a pile-shifting shuffle to the piles: where s is generated uniformly at random from  by this shuffle action.

3.
Reveal all the cards in the second row; then, one

Image 3
should appear in the -th, and the pile above the revealed
Image 3
is , and hence, P can choose the desired . Note that no information about i (i.e., the index of the chosen pile) is leaked because a red
Image 3
appears in the -th in the second row.
2.2. Sub-protocols
Chosen pile protocol  This is an extended version of the chosen pile cut [19] explained above. Given m piles  with 2m additional cards, this protocol enables P to choose the i-th pile  and regenerate the original sequence of m piles.

1.
In the same way as Step 1 of the chosen pile cut, the prover P places m face-down cards such that only the i-th is

Image 13
. We further put m face-down cards below the cards such that only the first card is
Image 13
:
2.
Similar to Step 2 of the chosen pile cut, apply a pile-shifting shuffle to the sequence of piles: where s is generated uniformly at random from .

3.
Similar to Step 3 of the chosen pile cut, reveal all the cards in the second row; then, one

Image 3
should appear in the -th, and the pile above the revealed
Image 3
is the i-th pile (and hence, P can choose ).
When this protocol is invoked, the chosen pile will be picked, and certain operations will be applied to the chosen pile. Then, the chosen pile is placed back to the -th in the sequence.

4.
Remove the revealed cards, i.e., the cards in the second row. Then, apply a pile-shifting shuffle: where  is generated uniformly at random from .

5.
Reveal all the cards in the second row; then, one

Image 3
should appear in the -th, and the pile above the revealed
Image 3
is . Therefore, by shifting the sequence of piles (such that  becomes the first pile in the sequence), we can obtain a sequence of piles whose order is the same as the original one without revealing any information about the order of the input sequence.
Verifying-degree protocol  This protocol enables P to convince V that the “degree” of a target vertex (dot) is not four without revealing anything beyond that. Here, the degree means the number of 1-commitments placed around a target vertex. The idea behind this protocol is that it suffices for P to choose one 0-commitment around the target vertex by using the chosen pile protocol explained above (when only P knows what the four commitments around the target are).

The verifying-degree protocol proceeds as follows.

1.
Given four commitments placed around the target vertex, regard them as a sequence of four commitments:

2.
By using the chosen pile protocol, P chooses one of the 0-commitments. Then, reveal the chosen pile, namely the chosen 0-commitment, to prove that it is surely 0. Now, V is convinced that the degree of the target vertex is not four. Then, turn over the revealed cards. Note that no information about the four commitments is leaked because a 0-commitment is always revealed in this step.

3.
V performs the remaining steps in the chosen pile protocol. Then, place all the commitments back to their original positions.

Five-card trick  This sub-protocol will be used for the Masyu puzzle. Given two commitments to  (along with a red card

Image 13
), the five-card trick [9] starts by adding an extra card as follows: The sub-protocol proceeds as follows to compute :
1.
Rearrange the sequence as follows:

Image 21
.
2.
Apply a random cut to the sequence:

Image 22
.
3.
Reveal the sequence.

(a)
If the resulting sequence is

Image 23
(up to cyclic shifts), the output is .
(b)
If it is

Image 24
(up to cyclic shifts), the output is .
Input-preserving function evaluation technique  Assume that we have a protocol (e.g., the five-card trick) to evaluate some function with m input piles of cards. The input-preserving function evaluation technique enables us to obtain the m input piles again after evaluating some function by using m number cards, as follows [24].

1.
Attach a corresponding numbered card to each of m input piles: Then, together with the added numbered cards, execute a designated protocol to evaluate some function.

2.
Apply a pile-scramble shuffle to the sequence of piles.

3.
Reveal only the numbered cards. Then, rearrange the sequence of piles so that the revealed numbered cards become in ascending order to obtain m input piles.

3. How to make a single loop
As mentioned before, both Slitherlink and Masyu have the same constraint: making a single loop. In this section, we present a generic way for the prover P to convince the verifier V that the constraint is satisfied. Let us first show that achieving this is somewhat difficult.

3.1. Naive approach does not work well
By using binary cards and the encoding rule shown in Section 2, we can consider a naive approach to construct physical ZKP protocols for both Slitherlink and Masyu, as follows.

Naive setup.
P places a commitment on each gap according to the solution.

Verification.
V verifies that the placement of the commitments satisfies all the constraints.

To the best of our knowledge, all the existing ZKP protocols for puzzles were constructed based on this approach. As one might imagine, verifying the Numbers Rule in Slitherlink is relatively simple, which will be seen later. However, how can V verify the Loop Rule? One might consider the use of a Boolean circuit, as follows.
1.
For each gap, numbered i, consider a Boolean variable . That is,  means the existence of a line on the gap.

2.
Construct a Boolean circuit C that outputs 1 if and only if all the variables , represent a single loop.

3.
Perform a secure computation of C using all the commitments placed on the gaps; if it outputs 0, V rejects it.

With ignoring the efficiency, the above approach would work. However, we note that constructing C is not feasible; C could be large and complicated. It means that a different approach needs.
3.2. Our approach: topology-preserving computation
As we mentioned in Section 1, our idea is to transform a single loop into another one while preserving the properties of the single loop without leaking any information about its specific shape. We call this transformation the topology-preserving computation. This will be used in both our ZKP protocols for Slitherlink and Masyu.

Let us explain the idea behind our topology-preserving computation. This protocol changes a given loop into another loop by applying one of the three transformations given in Fig. 8. Each transformation changes the lines surrounding a square, represented by dash line in Fig. 8. Remember that a line is expressed by a commitment (i.e., two face-down binary cards) in our protocols. Therefore, for example, the (2,2)-transformation means This can be performed by swapping the two cards of each commitment. (Remember that swapping the two cards performs negation of a commitment.) The (3,1)-transformation and the (1,3)-transformation can also be performed by swapping the two cards of each commitment:

Fig. 8
Download : Download high-res image (96KB)
Download : Download full-size image
Fig. 8. The three transformations.

Now, suppose that P wants to apply one of the three transformations while the applied transformation is hidden from V. Furthermore, P needs to show that the commitments around a target square are “transformable.” Note that the three transformations are applicable to the four commitments around a square if and only if a 0-commitment facing a 1-commitment exists among the four commitments.

Given four commitments around a target square

Image 28
, the topology-preserving computation proceeds as follows.
1.
P chooses a 0-commitment facing a 1-commitment using the chosen pile protocol.

2.
V reveals the chosen commitment as well as the commitment that is two piles away from it: Then, V checks that the two commitments are a 0-commitment and a 1-commitment to be convinced that any transformation can be applied.

3.
After turning over all the opened cards of the commitments, V performs the remaining steps of the chosen pile protocol to place all the commitments back to their original positions.

4.
Swap the two cards of each of the four commitments. (Remember that this results in negating all the four commitments, and hence, one of the three transformations has been applied.)

5.
V applies the verifying-degree protocol to each of the four dots of the target square. Then, V is convinced that no dots of degree four has arisen as the result of transformation. As will be proved in Section 5, this guarantees that the loop was not split and thus, it remains a single loop.

As Lemma 2 in Section 5, we will prove that the resulting placement of 1-commitments after the topology-preserving computation always represents a single loop.
3.3. Input phase
We describe a generic procedure for an input before applying the topology-preserving computation, which aims to convince a verifier V that the commitments placed by a prover P form a single, non-intersecting loop. Note that this phase is applied for Slitherlink and Masyu, but it can be applied to any puzzle where the constraint of a single non-intersecting loop is mandatory.

The verifier V puts a 1-commitment on every gap on the boundary of the puzzle board and 0-commitments on all the other gaps. This placement corresponds to the single loop with the same size as the board. The following is an example of the placement of a ()-square puzzle board: P applies the topology-preserving computation to these commitments to transform the shape of the loop into the solution. To hide the position of the target square, we make a sequence of piles from the placed cards, pick the four target commitments using the chosen pile protocol, and apply the topology-preserving computation. To properly pick the four commitments, a sequence of piles is formed, as follows.

First, we expand the puzzle board by adding dots around the original board. The expanded dots are denoted by ⊙. Note that the expanded area is unrelated to the actual puzzle board. V puts “dummy” commitments on the gaps at the expanded area other than the right and the bottom ends. Each dummy commitment consists of two black cards

Image 32
to prevent the loop from spreading over the expanded area. We denote a dummy commitment by
Image 33
. Next, V makes a sequence of 4-card piles as follows. For each square, V first makes a pile from the commitments placed on the left and the top.2(1) Then, pick 4-card piles from top to bottom: to make a sequence of piles:
Image 37
.
4. Zero-knowledge proof for Slitherlink
In this section, we show our physical zero-knowledge proof protocol for Slitherlink. The outline of our protocol is as follows:

Input Phase:
As described in Section 3.3, the verifier V puts commitments on every gap.

Topology-Preserving Computation Phase:
The prover P transforms the big loop into the solution loop. After this phase, V is convinced that the placement of 1-commitments satisfies the Loop Rule of Slitherlink without revealing any information about its shape.

Verification Phase:
V verifies that the placement of 1-commitments satisfies the Numbers Rule of Slitherlink.

4.1. Our construction
4.1.1. Input phase
As described in Section 3.3, the verifier V puts a 1-commitment on every gap on the boundary of the puzzle board and 0-commitments on all the other gaps. This placement corresponds to the single loop with the same size as the board. Next, make a sequence of 4-card piles, as described in Section 3.3.

4.1.2. Topology-preserving computation phase
In this phase, P applies the transformations (explained in Section 3.2) to step-wise change the loop. Let n be the size of the puzzle instance, namely the number of squares on the puzzle board. Then, note that P can make the solution loop by at most n transformations.

1.
P applies the following exactly  times such that either the resulting loop is already the solution, or one more transformation will end up the solution.3 (This is possible because successive two transformations (of the same) to the same square keep the loop unchanged.)

(a)
P applies the chosen pile protocol to the sequence of 4-card piles: P picks a 4-card pile composed of the left and top edges of the square that P wants to transform. The remaining edges can be picked by counting the distance from the chosen pile.4

(b)
P applies the topology-preserving computation to the four picked commitments.

(c)
V performs the remaining steps of the chosen pile protocol to place the cards back to their original positions.

2.
P chooses either to apply one more transformation or not to change the solution loop so that V does not learn which action occurs:

(a)
Similarly to Step 1 (a) above, P picks four commitments around the target square.

(b)
By applying Steps 1 to 3 of the topology-preserving computation, V confirms that any transformation is applicable.

(c)
V arranges the four commitments vertically and makes a pile from each column:

Image 38
.
Note that swapping the two piles results in negating each commitment. Thus, it is equivalent to applying a transformation.

(d)
Using the chosen pile cut, if P wants to transform the target square, then P chooses the right pile; otherwise, the left pile is chosen.

(e)
Rearrange the cards vertically such that the chosen pile is placed on the left:

(f)
V makes four commitments from each row, performs the remaining steps of the chosen pile protocol, and places each commitment back to their original positions.

3.
Finally, all cards are placed on the puzzle board and the cards in the dummy area are removed.

4.1.3. Numbers verification phase
V is now convinced that the placement of 1-commitments represents a single loop and it never branches off (the Loop Rule). Finally, V verifies that the placement satisfies the Numbers Rule of Slitherlink. That is, the number on each square is equal to the number of lines surrounding it. The verification proceeds as follows, where we virtually assume that the board is colored like a checkered pattern so that all squares in the first row are alternation of blue and yellow, those in the second row are alternation of yellow and blue, and so on.

1.
V picks all the left cards (if the square is virtually blue) or all the right cards (if the square is yellow) of four commitments around a numbered square:

Image 40
. Let m denote that number.
2.
P shuffles the four cards.

3.
V reveals the four cards.

•
If V picked all the left cards of four commitments in Step 1, V checks that the number of red cards

Image 3
is equal to m.
•
If V picked all the right cards, V checks that the number of black cards

Image 2
is equal to m.
4.
Apply Steps 1 to 3 to all the other numbered squares. (Note that every commitment is related to exactly one blue square and one yellow square.)

Performance evaluation
When we have a  board, our protocol uses  cards in the Input phase and  cards in the Topology-Preserving Computation phase:  cards in total. Note that in the chosen pile protocol, cards placed in the second and third rows can be reused after revealing them.

5. Security proofs for our construction
We show that our construction for Slitherlink satisfies the completeness, extractability, and zero-knowledge properties.

Completeness  Note that P uses only (3,1)-, (1,3)-, and (2,2)-transformations in the topology-preserving computation to transform a single loop into the shape of the solution. We now prove that this is possible in Theorem 1.

Theorem 1

Let n be the number of squares in the puzzle instance (namely, the big loop), and let k be the number of squares inside its solution loop. By applying a transformation to the loop exactly  times, the big loop can be transformed into the solution loop.

To prove Theorem 1, we first show Lemma 1, Lemma 2.
Lemma 1

After the topology-preserving computation, the resulting placement of 1-commitments represents a single loop.

Proof

Remember Steps 1 and 5 in the topology-preserving computation in Section 3.2: Due to Step 1, the target square is guaranteed to be none of the following two ones (up to rotations).



Download : Download high-res image (3KB)
Download : Download full-size image
That is, one of the (2,2)-, (3,1)-, and (1,3)-transformations is always applied to the target square.

Due to the execution of the verifying-degree protocol in Step 5, the following two transformations that make a loop split cannot occur (up to rotations).



Download : Download high-res image (30KB)
Download : Download full-size image
Therefore, it remains a single loop. We note that a dot of degree three (or one) cannot exist in a loop. Since the (2,2)-, (3,1)-, and (1,3)-transformations affect the lines between each of four dots (in a square), the resulting degrees of the four dots cannot be odd (after Step 4). Therefore, it suffices to verify that a dot of degree four does not exist in the target square in Step 5. □

Lemma 2

For any single loop, at least one of the (3,1)-, (1,3)-, and (2,2)-transformations exists, which increases the number of squares inside the loop by exactly one without causing a degree four.

Proof

Consider a single loop; let ℓ be the number of squares inside the loop. To prove this lemma, we show that there always exists a square on the board such that the (3,1)-, (1,3)-, or (2,2)-transformation can be applied to the square such that ℓ increases without causing a degree four.

If , then the (1,3)-transformation increases the number of squares by one. Thus, one may assume that . Then, any square outside the loop can be classified in one of the following five types (up to rotations):



Download : Download high-res image (10KB)
Download : Download full-size image
If none of types (a), (b), and (c) exists, we cannot have a loop because only squares of types (d) and (e) cannot make a loop. Therefore, at least one square of type (a), (b), or (c) must exist outside the loop.

When the loop is convex, applying the (3,1)-, (1,3)-, or (2,2)-transformation to such an external square results in increasing ℓ by one without causing a vertex of degree four. When the loop is not convex, there exists a square of type (b) (where the dot having no line is of degree zero), or (c) inside the convex hull, and similarly, applying the transformation results in increasing ℓ by one without causing a degree four. □

By these lemmas, Theorem 1 can be proved.
Proof of Theorem 1

By Lemma 1, Lemma 2, we can always increase the number of squares inside the solution loop by a transformation. Therefore, we can repeat the transformation so that the solution loop becomes the big loop. This means that, conversely, the big loop can be transformed into the solution loop by applying the (3,1)-, (1,3)-, or (2,2)-transformation exactly  times. □

Extractability  Intuitively, the extractability holds because after executing the Topology-preserving Computation phase, the placement of 1-commitments encodes exactly a solution P knows. If the placement passes the verification phase, then it means that the placement satisfies the Numbers Rules (and the Loop Rule), and hence, it is the solution (and P knows the solution).

More formally, to prove the extractability, we show that any shape that does not satisfy the Loop Rule or Numbers Rule, is always rejected during the protocol, and there is an extractor that can extract a solution.

Theorem 2

If the prover does not know a solution for a given Slitherlink puzzle, then the verifier rejects regardless of the prover's behavior.

To prove Theorem 2, let us first show that the resulting loop after the Topology-preserving Computation phase always satisfies the Loop Rule (as in Lemma 1) and any single loop that does not satisfy the Numbers Rule is always rejected in the verification phase (as in Lemma 3). Therefore, any single loop except for a solution is always rejected.
Lemma 3

Any (single) loop that does not satisfy the Numbers Rule is always rejected in the verification phase.

Proof

Consider any (single) loop that does not satisfy the Numbers Rule, i.e., there are four commitments surrounding a numbered square such that the number of 1-commitments among them is not equal to the number. Due to Step 3 in the verification phase, all the left (or right) cards of four commitments are turned over (after shuffling them), and hence, the number of 1-commitments is revealed. This means that the verifier can always reject any (single) loop that does not satisfy the Numbers Rule. □

Proof of Theorem 2

By Lemma 1, the resulting loop after the Topology-preserving Computation phase is always single, i.e., it satisfies the Loop Rule. By Lemma 3, if it does not satisfy the Numbers Rule, the verifier always rejects it in the verification phase. That is, any loop except for the solution cannot go through the verification phase.

The extractor for this protocol can be simply constructed: after executing the Topology-preserving Computation phase, the extractor takes all the face-down cards on the board and look at them to obtain a solution. □

Zero-knowledge  In our construction, all cards to be opened have been shuffled before being opened. Therefore, all distributions of opened cards can be simulated by a simulator  who does not know the solution. For example, at Step 2 in the verification phase, a shuffle has been applied to the opened commitments; thus, this is indistinguishable from a simulation putting randomly 1-commitments such that the number of them is equal to the number of the squares.

6. Zero-knowledge proof for Masyu
In this section, we construct a physical zero-knowledge proof protocol for Masyu. The outline of our protocol is as follows:

Input Phase:
The verifier V puts a 1-commitment (i.e., two face-down cards encoding 1) on every gap on the boundary of the puzzle board and 0-commitments on all the remaining gaps. In other words, V creates a single big loop whose size is the same as the board.

Topology-Preserving Computation Phase:
The prover P transforms the shape of the loop according to the solution. After this phase, V is convinced that the placement of 1-commitments satisfies the Loop Rule of Masyu without the disclosure of any information about the shape.

Crossing Verification Phase:
The verifier V verifies that the placement of 1-commitments satisfies all the remaining rules.

6.1. Our construction
The main idea behind this protocol is that V creates a big loop (on the edge of the grid) and then P transforms the loop according to the solution. Once V is convinced of the Loop Rule, the verification phase is run, leading to convincing V that the black and white circles satisfy their respective constraints.

Input phase  As described in Section 3.3, V prepares a placement corresponding to the single loop with the same size as the board.

Topology-preserving computation phase  In this part of the protocol, P transforms a big loop into the solution loop. The process is exactly the same as in Section 4.1.2. In addition, V replaces each dummy commitment

Image 44
with a 0-commitment
Image 9
for the verification.
Crossing verification phase  The verifier V is now convinced that the placement of 1-commitments forms a non-intersecting single loop (the Loop Rule). Now, V needs to verify that the placement satisfies the rules about circles. This verification is done during a single phase.

We divide the phase in two cases: one for white circles and one for black circles.

Black circle: We want to show that V can verify that there is a line passing through a black circle, and the entering line is perpendicular to the exiting line. In addition, V can verify that the next lines of entering and exiting lines are straight.

At this step we only pick the left card of each commitment. Thus, the presence of a line is encoded as

Image 3
and the absence is
Image 12
. We want to show that the line passing through a black circle forms a perpendicular shape and that the line continues in straight line for the two extremities.
Consider the center of the black circle of coordinate . The left dot is then , the bottom dot is , and so on. The following verification is done for each black circle of the grid.

1.
V picks the left cards of the commitments between the  dot horizontally (namely, the two commitments to the left of the black circle) to form a pile. V keeps the closest card from the circle at the beginning of the pile. Do the same for each direction i.e., commitments between , , .5

At this point, there are four piles (one for each direction) composed of two cards where the first card of each pile is the closest from the black circle.

2.
They do the following steps enhanced by the input-preserving function evaluation technique shown in Section 2.2. That is, the above four piles will go back to their original positions after the last step.

3.
V applies a pile-shifting shuffle to those four piles.

4.
P puts the first card of each pile in a row, and does the same for the second cards.

•
V reveals the first row (namely, the closest commitments from the circle); a valid configuration is (up to a cyclic shift):

Image 45
. This verifies that the line forms a perpendicular shape.
•
Then V reveals the cards of the second row where a

Image 3
card appears in the first row. If there are also
Image 3
cards then the second constraint holds (line must continue straightforward for at least one other dot). If a
Image 2
is revealed then the verifier rejects.
White circle: We now describe how the verifier V can be convinced that the White Circle Rule holds.

1.
V forms the same piles as before except that it picks the two consecutive commitments so that each pile has now four cards in it: the first two correspond to the closest commitments of the circle.

2.
They do the following enhanced by the input-preserving function evaluation technique.

3.
P applies a pile-shifting shuffle to those four piles.

4.
V now verifies the constraint that a straight line must pass through a white circle: reveal the first card of each pile. A valid configuration (up to a cyclic shift) is:

Image 46
.
5.
Next V picks the two last cards of each pile where a

Image 3
appears previously. Those picked cards correspond to the farthest commitment from the circle in each pile. At this point we have four face-down cards (since two
Image 13
s must appear in the previous step).
V applies the five-card trick using them: If the output is 1, then the line passing through the white circle continues straightforward (as in Fig. 7), and thus, the configuration is not valid. If the output is 0, then the two extremities are perpendicular or only one of them is perpendicular (as in Fig. 6).

Performance evaluation  When we have a  board, our protocol uses  cards in the Input phase,  cards in the Topology-Preserving Computation phase and 10 cards during the Verification phase (nine numbered cards used for the input-preserving function and one red card for the five-card trick):  cards in total.

7. Security proofs for Masyu
We show that the construction for Masyu satisfies the completeness, extractability, and zero-knowledge properties. As mentioned in the construction, we apply the same topology-preserving computation as the Slitherlink protocol. Hence, the completeness of the Masyu protocol is already proved (see Section 5). It remains to prove the extractability and the zero-knowledge properties.

Extractability  The extractability for the protocol holds similarly to our proposed protocol for Slitherlink shown in Section 5. The extractor is exactly the same: it simply reveals all the face-down cards placed after the Topology-preserving computation phase.

Theorem 3

If the prover does not know a solution for the Masyu puzzle, then the verifier rejects regardless of the prover's behavior.

To prove Theorem 3, let us show that the resulting loop after the Topology-preserving Computation phase always satisfies the Loop Rule (as in Lemma 1) and any single loop that does not satisfy the other rules is always rejected in the Crossing Verification phase (as in the following Lemma 4). Therefore, any single loop except for the solution is always rejected.
Lemma 4

Any (single) loop that does not satisfy the Through Circle Rule, Black Circle Rule, and White Circle Rule is always rejected in the Crossing Verification Phase.

Proof

Consider any (single) loop that does not satisfy the Through Circle Rule i.e., there are circles where the loop does not pass through. Due to Step 3 in the Crossing Verification Phase, all the left cards of four commitments are turned over (after shuffling them), and hence, the number of 1-commitments is revealed. This means that the verifier can always reject any (single) loop that does not satisfy the Through Circle Rule.

Now, consider any (single) loop that does not satisfy the Black Circle Rule and White Circle Rule, i.e., there are black and white circles where the loop does not respect their respective constraints. Also in Step 3, all the left cards of four closest commitments are turned over (up to cyclic shift), and hence, the perpendicular or straight constraint can be verified. Since the four farthest cards are also turned over, the second part of the constraint in the Black Circle Rule and White Circle Rule are also verified. This notifies the verifier if the loop does not satisfy the Through Circle Rule, Black Circle Rule, and White Circle Rule. □

Proof of Theorem 3

By Lemma 1, the resulting loop after the topology-preserving computation is always single, i.e., it satisfies the Loop Rule. By Lemma 4, if it does not satisfy the remaining rules, the verifier always rejects it in the Crossing Verification phase. That is, any loop except for the solution cannot go through the Crossing Verification phase. □

Zero-knowledge  In our construction, all the cards to be opened have been shuffled before being opened. Therefore, all distributions of opened cards can be simulated by a simulator  who does not know the solution. For example, at Step 3 in the Crossing Verification phase, a pile-shifting shuffle has been applied to opened commitments; thus, this is indistinguishable from a simulation putting randomly 1-commitments such that their placement respects the constraint of black circle (perpendicular and then straight line) or white circle (straight line and then at least one perpendicular extremity).

8. Conclusion
We proposed a technique to perform physical ZKP for puzzles that aim to draw a single loop that never crosses itself and never branches off. For this we transform a single loop encoded with physical objects into a new geometrical figure while preserving the single loop. To illustrate our approach, we used this secure computation to construct physical zero-knowledge proof protocols for two Nikoli puzzles: Slitherlink and Masyu.

Of course, our construction has been designed to be used for other puzzles that require a feature of drawing a single loop. For example, Moon-or-Sun published by Nikoli aims at drawing a single loop as Slitherlink or Masyu. However, there is an extra rule in this puzzle that are not so easy to take into account in a ZKP protocol. In particular, the following rule is very difficult to deal with: after the loop goes through the moons in one room, it has to go through all the suns in the next room it enters and vice versa.

It should be noted that our latest work [32] for Nurikabe and Hitori was inspired by this study. In that work, we proposed a technique to prove that cells with the same color are connected to each other. In the future work, we aim to deal with famous NP-complete graph theoretic problems such as the Hamiltonian path (and cycle) problem.