Abstract
We consider the problem of computing the diameter of a unicycle graph (i.e., a graph with a unique cycle). We present an O(n) time algorithm for the problem, where n is the number of vertices of the graph. This improves the previous best O(nlog⁡n) time solution [Oh and Ahn, ISAAC 2016]. Using this algorithm as a subroutine, we solve the problem of adding a shortcut to a tree so that the diameter of the new graph (which is a unicycle graph) is minimized; our algorithm takes O(n2log⁡n) time and O(n) space. The previous best algorithms solve the problem in O(n2log3⁡n) time and O(n) space [Oh and Ahn, ISAAC 2016], or in O(n2) time and O(n2) space [Bilò, ISAAC 2018].

Keywords
Diameter
Unicycle graphs
Augmenting trees
Shortcuts

1. Introduction
Let G be a graph of n vertices such that each edge has a positive length. A shortest path connecting two vertices s and t in G is a path of minimum total edge length; the length of the shortest path is also called the distance between s and t in G. The diameter of G is the maximum distance between all pairs of vertices of G. G is a unicycle graph if it has only one cycle, i.e., G is a tree plus an additional edge.

We consider the problem of computing the diameter of a unicycle graph G. Previously, Oh and Ahn [20] solved the problem in  time, where n is the number of vertices of G. We present an improved algorithm of  time. Using our new algorithm, we also solve the diameter-optimally augmenting tree (DOAT for short) problem, defined as follows.

Let T be a tree of n vertices such that each edge has a positive length. We want to add a new edge (called shortcut) to T such that the new graph (which is a unicycle graph) has the minimum diameter. We assume that there is an oracle that returns the length of any given shortcut in  time. Previously, Oh and Ahn [20] solved the problem in 
 time and  space, and Bilò [3] reduced the time to 
 but the space increases to 
. As observed by Oh and Ahn [20], the problem has an 
 lower bound on the running time as all 
 possible shortcuts have to be checked in order to find an optimal shortcut. Hence, Bilò's algorithm is time-optimal. In this paper, we propose an algorithm with a better time and space trade-off, and our algorithm uses 
 time and  space.

1.1. Related work
The diameter is an important measure of graphs and computing it is one of the most fundamental algorithmic graph problems. For general graphs or even planar graphs, the only known way to compute the diameter is to first solve the all-pair-shortest-path problem (i.e., compute the distances of all pairs of vertices of the graph), which inherently takes 
 time, e.g., [11], [25]. Better algorithms exist for special graphs. For example, the diameter of a tree can be computed in linear time, e.g., by first computing its center [19]. If G is an outerplanar graph and all edges have the same length, its diameter can be computed in linear time [10]. The diameter of interval graphs (with equal edge lengths) can also be computed in linear time [21]. Our result adds the unicycle graph (with different edge lengths) to the linear-time solvable graph category.

The DOAT problem and many of its variations enjoy an increasing interest in the research community. If the tree T is embedded in a metric space (so that the triangle inequality holds for edge lengths), Große et al. [15] first solved the problem in 
 time. Bilò [3] later gave an  time and  space algorithm, and another -approximation algorithm of 
 
 
 time and 
 
 space for any . A special case where T is a path embedded in a metric space was first studied by Große et al. [14], who gave an 
 time algorithm, and the algorithm was later improved to  time by Wang [23]. Hence, Bilò's work [3] generalizes Wang's result [23] to trees.

A variant of the DOAT problem which aims to minimize the continuous diameter, i.e., the diameter of T is measured with respect to all the points of the tree (including the points in the interior of the edges), has also been studied. If T is a path embedded in the Euclidean plane, De Carufel et al. [5] solved the problem in  time. If T is a tree embedded in a metric space, De Carufel et al. [6] gave an  time algorithm. If T is a general tree, Oh and Ahn [20] solved the problem in 
 time and  space.

The DOAT problem is to minimize the diameter. The problem of minimizing the radius was also considered. For the case where T is a path embedded in a metric space, Johnson and Wang [17] presented a linear time algorithm which adds a shortcut to T so that the radius of the resulting graph is minimized. The radius considered in [17] is defined with respect to all points of T, not just the vertices. Wang and Zhao [24] studied the same problem with radius defined with respect to only the vertices, and they gave a linear time algorithm.

The more general problem in which one wants to add k shortcuts to a graph to minimize the diameter is NP-hard [22] and some variations are even W[2]-hard [12], [13]. Approximation algorithms have been proposed [4], [7], [9], [12], [18]. The upper and lower bounds on the values of diameters of certain augmented graphs were also studied, e.g., [1], [8], [16]. Bae et al. [2] considered the problem of adding k shortcuts to a circle in the plane to minimize the diameter of the resulting graph.

1.2. Our approach
To compute the diameter of a unicycle graph G, Oh and Ahn [20] reduces the problem to a geometric problem and then uses a one-dimensional range tree to solve the problem. We take a completely different approach. Let C be the unique cycle of G. We define certain “domination” relations on the vertices of C so that if a vertex v is dominated by another vertex then v is not important to the diameter. We then present a pruning algorithm to find all undominated vertices (and thus those dominated vertices are “pruned”); it turns out that finding the diameter among the undominated vertices is fairly easy. In this way, we compute the diameter of G in linear time.

For the DOAT problem on a tree T, Oh and Ahn [20] considered all possible shortcuts of T by following an Euler tour of T; they used the aforementioned one-dimensional range tree to update the diameter for the next shortcut. Bilò's method [3] is to transform the problem to adding a shortcut to a path whose edge lengths satisfy a property similar in spirit to the triangle inequality (called graph-triangle inequality) and then the problem on P can be solved by applying the  time algorithm for trees in metric space [3]. Unfortunately, the problem transformation algorithm relies on using 
 space to store the lengths of all possible 
 shortcuts of T. The algorithm has to consider all these 
 shortcut lengths in a global manner and thus it inherently uses 
 space. Note that Bilò's method [3] does not need an algorithm for computing the diameter of a unicycle graph.

We propose a novel approach. We first compute a diametral path P of T. Then we reduce the DOAT problem on T to finding a shortcut for P. To this end, we consider vertices of P individually. For each vertex 
 of P, we want to find an optimal shortcut with the restriction that it must connect 
, dubbed a 
-shortcut. For this, we define a “domination” relation on all 
-shortcuts and we show that those shortcuts dominated by others are not important. We then design a pruning algorithm to find all shortcuts that are not dominated by others; most importantly, these undominated shortcuts have certain monotonicity properties that allow us to perform binary search to find an optimal 
-shortcut by using our diameter algorithm for unicycle graphs as a subroutine. With these efforts, we find an optimal 
-shortcut in  time and  space. The space can be reused for computing optimal 
-shortcuts of other vertices of P. In this way, the total time of the algorithm is 
 and the space is .

Outline. In the following, we present our algorithm for computing the diameter of a unicycle graph in Section 2. Section 3 is concerned with the DOAT problem.

2. Computing the diameter of unicycle graphs
In this section, we present our linear time algorithm for computing the diameter of unicycle graphs.

For a subgraph 
 of a graph G and two vertices u and v from 
, we use 
 to denote a shortest path from u to v in 
 and use 
 to denote the length of the path. We use  to denote the diameter of G. A pair of vertices  is called a diametral pair and 
 is called a diametral path if 
.

In the following, let G be a unicycle graph of n vertices. Our goal is to compute the diameter  (along with a diametral pair). Let C denote the unique cycle of G.

2.1. Observations
Removing all edges of C (while keeping its vertices) from G results in a forest. Each component is a tree that contains a vertex v of C; we use  to denote the tree. Let 
 be the vertices ordered clockwise on C. Let 
. Note that the sets of vertices of all trees of  form a partition of the vertex set of G.

Consider a diametral pair 
⁎
⁎
 of G. There are two cases: (1) both 
⁎
 and 
⁎
 are in the same tree of ; (2) 
⁎
 and 
⁎
 are in two different trees of . To handle the first case, we compute the diameter of each tree of , which can be done in linear time (e.g., using the algorithm of [19]). Computing the diameters for all trees takes  time. The longest diameter of these trees is the diameter of G. In the following, we focus on the second case.

Suppose 
 contains 
⁎
 and 
 contains 
⁎
 for . Observe that the diametral path 
⁎
⁎
 is the concatenation of the following three paths: 
⁎
, 
, and 
⁎
. Further, 
⁎
 is the farthest vertex in 
 from 
; the same holds for 
⁎
 and 
. On the basis of these observations, we introduce some concepts as follows.

For each vertex 
, we define a weight 
 as the length of the path from 
 to its farthest vertex in 
. The weights for all vertices on C can be computed in total  time. With this definition in hand, we have 
. We say that 
 is a vertex-weighted diametral pair of C if 
 contains 
⁎
 and 
 contains 
⁎
 for a diametral pair 
⁎
⁎
 of G. To compute , it suffices to find a vertex-weighted diameter pair of C.

We introduce a domination relation for vertices on C.

Definition 1

For two vertices 
, we say that 
 dominates 
 if 
.

The following lemma shows that if a vertex is dominated by another vertex, then it is not “important”.

Lemma 2

For two vertices 
 and 
 of C, if 
 dominates 
, then 
 cannot be in any vertex-weighted diametral pair of C unless 
 is such a pair.

Proof

We assume that 
 is not a vertex-weighted diametral pair. Assume to the contrary that 
 is a vertex-weighted diametral pair of C. Then,  and 
. Note that 
 holds. Since 
 dominates 
, we have 
. Consequently, we can derive
 But this contradicts with the definition of . The lemma thus follows. □

2.2. A pruning algorithm
In the sequel, we describe a linear time pruning algorithm to find all vertices of C that are dominated by other vertices (and thus those dominated vertices are “pruned”). As will be seen later, the diameter can be easily found after these vertices are pruned.

Let  denote the sum of the lengths of all edges of C. For any vertex 
 of C, we define 
 as the set of vertices 
 of C such that the path from 
 to 
 counterclockwise along C has length at most  (e.g., see Fig. 1); define 
 as the set of vertices of C not in 
. We assume that 
 and 
.

Fig. 1
Download : Download high-res image (17KB)
Download : Download full-size image
Fig. 1. Illustrating the definitions of Cccw(vi) (the disks except vi) and Ccw(vi) (the squares). We assume that p is a point on C that together with vi partitions C into two half-cycles of equal length.

Lemma 3

With  time preprocessing, given any two vertices 
 and 
 of C, we can do the following in  time: (1) compute 
; (2) determine whether 
 is in 
; (3) determine whether one of 
 and 
 dominates the other.

Proof

We first compute the weight 
 for all vertices 
. This can be done in  time. Then, we compute the length . Next, by scanning the vertices 
 on C, we compute an array  with  equal to the length of the path from 
 to 
 clockwise along C. Hence, for any ,  is the length of the path from 
 to 
 clockwise along C and  is the length of the path from 
 to 
 counterclockwise along C. Note that 
.

Consider any two vertices 
 and 
 of C. Without loss of generality, we assume . By comparing  with , we can determine whether 
 is in 
 in  time. As 
 and 
 are both available, whether one of 
 and 
 dominates the other can be determined in  time. □

With Lemma 3 in hand, starting from 
, our pruning algorithm processes the vertices of C from 
 to 
 in order (see Algorithm 1 for the pseudocode). The algorithm maintains a stack S, which is empty initially. Consider a vertex 
. If , then we push 
 into S. Otherwise, let v be the vertex at the top of S. If v is not in 
, then we also push 
 into S. Otherwise, we check whether one of v and 
 dominates the other. If they do not dominate each other, then we push 
 into S. Otherwise, if 
 dominates v, we pop v out of S, and then we continue to pop the new top element v of S out as long as the following three conditions are all satisfied: (1) ; (2) 
; (3) 
 dominates v. Once one of the three conditions is not satisfied, we push 
 into S. If v dominates 
, we do nothing.

Algorithm 1
Download : Download high-res image (160KB)
Download : Download full-size image
Algorithm 1. The pruning algorithm.

After 
 is processed, the first stage of the pruning algorithm is over. In the second stage, we process the vertices in the stack S in a bottom-up manner until a vertex not in 
; the processing of a vertex is done in the same way as above (the vertex should be removed from S first). Specifically, let 
 be the vertex at the bottom of S. If 
 is not in 
, then we stop the algorithm and return the vertices in the current stack S. Otherwise, we remove 
 from S and then apply the same processing algorithm as above in the first stage (i.e., begin with checking whether S is empty).

Intuitively, the first stage of the algorithm does a “full-cycle” scan on C while the second stage does a “half-cycle” scan (i.e., the half-cycle clockwise from 
). With Lemma 3, the algorithm can be implemented in  time. The following lemma establishes the correctness of the algorithm.

Lemma 4

Let S be the stack after the algorithm is over.

1.
Each vertex of C that is not in S is dominated by a vertex in S.

2.
No two vertices of S dominate each other.

Proof

We first prove an observation about two transitive properties of the domination relation, which will be used to prove the lemma.

Observation 1

Let 
 be any three vertices of C. We have the following transitive properties.

1.
If 
 dominates 
 and 
 dominates 
, then 
 dominates 
.

2.
If 
 and 
 do not dominate each other, 
 and 
 do not dominate each other, and 
, then 
 and 
 do not dominate each other.

Proof of Observation 1.

1.
Since 
 dominates 
 and 
 dominates 
, we have 
 and 
. Thus, 
. Hence, 
 dominates 
.

2.
As 
 and 
 do not dominate each other, 
. As 
 and 
 do not dominate each other, 
. Since 
, we have
 and
 Therefore, 
 and 
 do not dominate each other.

This proves Observation 1.
We are now in a position to prove the lemma.

Proof of Lemma 4(1). We start with the first lemma statement. Consider a vertex 
 of C that is not in S. According to Algorithm 1, 
 may or may not be processed in the second stage. If 
 is processed in the second stage, then 
 was pushed into S during the first stage but is removed from S in the second stage (hence 
 was processed twice in the algorithm). If 
 is not processed in the second stage, then 
 was not in S at the end of the first stage (hence 
 is processed only once in the algorithm). In either case, 
 must be dominated by a vertex 
 that was in S. If 
 is still in S at the end of Algorithm 1, then Lemma 4(1) is proved; otherwise, we can prove inductively that 
 is dominated by a vertex 
 in S. By Observation 1, 
 is dominated by 
 and thus Lemma 4(1) follows.

Proof of Lemma 4(2). We next prove the second lemma statement. We first prove a claim: at any moment during Algorithm 1, for any two vertices v and u of S such that v is above u in the stack S and 
, v and u do not dominate each other. We use mathematical induction to prove it, as follows.

The claim is vacuously true in the beginning of the algorithm because . We assume that the claim holds on S right before a vertex 
 is processed. We show below that the claim still holds on S after 
 is processed. We first consider the processing of 
 in the first stage of the algorithm. Let S refer to the stack right before 
 is processed. Let v be the top element of S if . According to Algorithm 1, 
 is pushed into S in the following four cases.

1.
. In this case, 
 after 
 is processed. Hence, the claim trivially holds.

2.
, and 
. In this case, 
, and thus the claim holds after 
 is processed.

3.
, 
, and v and 
 do not dominate each other. Let 
 be any vertex of S such that 
. To prove the lemma, it suffices to show that 
 and 
 do not dominate each other.

Indeed, if 
, then we know that v and 
 dot not dominate each other. Otherwise, 
 is below v. As 
, since 
, 
 is also in 
. Since v is above 
 in S, by the induction hypothesis 
 and v do not dominate each other. Since both 
 and v are in 
, 
 holds. By Observation 1, 
 and 
 do not dominate each other. Hence, the claim holds after 
 is processed.

4.
, 
, and 
 dominates v. In this case, 
 is pushed into S after some vertices including v are popped out of S. First of all, since the claim holds on S, after vertices popped out of S, the claim still holds on the new S. Let S refer to the stack right before 
 is pushed in. Hence, the claim holds on S.

If , then the claim still holds after 
 is pushed in since 
 will be the only vertex in S. Otherwise, let 
 be the top element of S. If 
, then the claim still holds on S after 
 is pushed in. Otherwise, 
 does not dominate 
 and both v and 
 are in 
, and thus 
 is in 
. By the induction hypothesis, v and 
 do not dominate each other. As 
 dominates v, 
 cannot dominate 
 since otherwise 
 would dominate v by Observation 1. Hence, 
 and 
 do not dominate each other. By the same argument as the above third case, 
 and 
 do not dominate each other for any vertex 
 of S with 
. Hence, the claim holds after 
 is pushed into S.

The above proves that the claim still holds after 
 is processed in the first stage of the algorithm. Now consider processing 
 in the second stage. If 
, then the algorithm stops without changing S and thus the claim still holds on S. Otherwise, 
 is removed from S, after which the claim still holds on S. Next, the algorithm processes 
 in the same way as in the first stage and thus we can use the same argument as above to prove that the claim still holds after 
 is processed. This proves the claim.

In the sequel we prove Lemma 4(2) by using the claim.

Consider two vertices 
 and 
 in S at the end of Algorithm 1. Notice that either 
 or 
. Without loss of generality, we assume that the former case holds. Our goal is to show that 
 and 
 do not dominate each other.

If 
 is above 
 in S at the end of Algorithm 1, then by the above claim, 
 and 
 do not dominate each other. Otherwise, according to Algorithm 1, 
 must be last pushed into S in the second stage while 
 must be last pushed into S in the first stage. Further, 
 was also pushed into S in the first stage before 
 was processed and 
 was never popped out of S in the first stage. Hence, at the moment of Algorithm 1 right before 
 was processed, 
 was already in S. At the moment of Algorithm 1 right after 
 was processed, 
 was at the top of S and 
 was also in S. Since 
, by the above claim, 
 and 
 do not dominate each other. This proves Lemma 4(2). □

2.3. Computing the diameter
In the following, we use S to refer to the stack after the pruning algorithm. Note that S cannot be empty. The following lemma shows how S can help to find a vertex-weighted diametral pair of C.

Lemma 5

If , then any vertex-weighted diametral pair of C must contain the only vertex in S. Otherwise, for any vertex v of C that is not in S, v cannot be in any vertex-weighted diametral pair of C.

Proof

Suppose  and let v be the only vertex in S. Then, by Lemma 4, every vertex of  is dominated by v. Let 
⁎
⁎
 be a vertex-weighted diametral pair of C. At least one of 
⁎
 and 
⁎
 is not v. Without loss of generality, we assume 
⁎
. Hence, 
⁎
 is dominated by v. Since 
⁎
⁎
 is a vertex-weighted diametral pair, by Lemma 2, 
⁎
 must be v. This proves the lemma for the case .

Now assume . Let v be a vertex of C that is not in S. By Lemma 4, S has a vertex u that dominates v. Assume to the contrary that v is in a vertex-weighted diametral pair. Then by Lemma 2, the pair must be . As , S has another vertex 
 that is not in . Since u dominates v, we have 
. Since u and 
 do not dominate each other, we have 
. Consequently, we can derive
 But this incurs contradiction since  is a vertex-weighted diametral pair. □

In light of Lemma 5, if , we compute the diameter  as follows. Let v be the only vertex in S. We find the vertex  that maximizes the value 
, which can be done in  time with Lemma 3. By Lemma 5,  is a vertex-weighted diametral pair and 
.

If , by Lemma 5, 
. The following lemma finds a vertex-weighted diametral pair and thus computes  in linear time.

Lemma 6

A pair  of vertices in S that maximizes the value 
 can be found in  time.

Proof

Consider a vertex . Let 
 and 
 be two vertices in 
 such that 
 (e.g., see Fig. 2). Note that 
. We claim that 
. Indeed, by Lemma 4(2), 
 and 
 do not dominate each other. Hence, 
. The claim follows. The claim implies that if we consider the vertices v of 
 from u along C in clockwise order, then the value 
 is monotonically increasing. Similarly, if we consider the vertices v of 
 from u along C in counterclockwise order, then the value 
 is monotonically increasing. Let 
 (resp., 
) refer to the farthest vertex from u in 
 (resp., 
); e.g., see Fig. 2. Based on the above discussion, it holds that 
.

Fig. 2
Download : Download high-res image (18KB)
Download : Download full-size image
Fig. 2. Illustrating the proof of Lemma 6: we assume that p is a point on C that together with u partitions C into two half-cycles of equal length.

To find 
 and 
, notice that if we traverse the vertices u of S along C in clockwise order, then both 
 and 
 are also ordered along C in clockwise order. Hence, 
 and 
 for all vertices u of S can be found in total  time by traversing the vertices of S along C. Consequently, we have 
, which can be computed in  time. □

The proof of the following theorem summarizes our algorithm.

Theorem 7

The diameter (along with a diametral pair) of a unicycle graph can be computed in linear time.

Proof

Recall that there are two cases for a diametral pair 
⁎
⁎
 of G: (1) both 
⁎
 and 
⁎
 are in the same tree of ; (2) 
⁎
 and 
⁎
 are in two different trees of .

•
The first case can be handled by computing the diameter and the corresponding diametral pair of each tree of , which can be done in total  time. The longest diameter of these trees is kept as a candidate diameter of G and the corresponding diametral pair is kept as a candidate diametral pair.

•
For the second case, we first compute the weights 
 for all vertices 
 of the cycle C; for each 
, we also store its farthest vertex 
 in 
. Then, we perform the preprocessing of Lemma 3. Next, we run the pruning algorithm to obtain S. If , we find a vertex-weighted diametral pair of C as described above; otherwise, we use Lemma 6 to find such a pair. In either case, let  denote the pair. Then, a candidate diameter is 
. In addition,  is a candidate diametral pair of G.

We compare the candidate diameters obtained from the above two cases and return the larger one as the diameter of G; the corresponding diametral pair is a diametral pair of G. The running time of the overall algorithm is . □

3. The Diameter-Optimally Augmenting Trees (DOAT)
In this section, we solve the DOAT problem in 
 time and  space. Our algorithm for computing the diameter of a unicycle graph will be used as a subroutine.

3.1. Observations
We follow the same notation as in Section 2 such as 
, 
, .

Let T be a tree of n vertices such that each edge of T has a positive length. For any two vertices u and v of T, we use  to refer to the shortcut connecting u and v; note that even if T already has an edge connecting them, we can always assume that there is an alternative shortcut (or we could also consider the shortcut as the edge itself with the same length). Let  denote the length of . Again, there is an oracle that can return the value  in  time for any shortcut . Denote by  the graph after adding  to T. The goal of the DOAT problem is to find a shortcut  so that the diameter of the new graph  is minimized. Let 
⁎
 be the diameter of an optimal solution. In the following we assume that 
⁎
, since otherwise any shortcut would be sufficient.

For any shortcut , T has a unique path 
 between u and v. We make an assumption that 
 since otherwise  can never be used (indeed, whenever  was used in a shortest path, we could always replace it with 
 to get a shorter path). This assumption is only for the argument of the correctness of our algorithm; the algorithm itself still uses the true value of  (this does not affect the correctness, because if 
, then  cannot be an optimal shortcut). For the reference purpose, we refer to this assumption as the shortcut length assumption.

At the outset, we compute a diametral path P of T in  time. Let 
 be the vertices of P ordered along it. Removing the edges of P from T results in m connected components of T, each of which is a tree containing a vertex of P; we let 
 denote the tree containing 
. For each 
, we define a weight 
 as the distance from 
 to its farthest vertex in 
. Let 
.

For any pair  of indices with , we define a critical pair of vertices  with 
 and 
 such that they minimize the value 
 among all vertex pairs 
 with 
 and 
.

The following lemma will be used on several occasions later on.

Lemma 8

For any vertex v in any tree 
, it holds that 
. Also, 
 and 
.

Proof

Assume to the contrary that 
. Without loss of generality, we assume 
. Then, 
, a contradiction.

The second part of the lemma holds because P is a path of T. □

The following lemma demonstrates why critical pairs are “critical”.

Lemma 9

Suppose 
⁎
⁎
 is an optimal shortcut with 
⁎
 and 
⁎
. Then,  and any critical pair of  also defines an optimal shortcut.

Proof

Because P is a diametral path of T, if , then P is still the shortest path from 
 to 
 in the new graph 
⁎
⁎
, and thus we have 
⁎
⁎
⁎
. But this contradicts with our assumption 
⁎
. Hence, .

Let  be a critical pair of  with 
 and 
. Define 
 and 
⁎
⁎
⁎
⁎
⁎
. By the definition of critical pairs, we have 
⁎
. Also, due to the shortcut length assumption, it holds that 
.

In the following, we prove that 
⁎
⁎
 for any two vertices . This will prove the lemma. To simplify the notation, let 
 and 
⁎
⁎
⁎
.

First of all, if 
⁎
, then 
⁎
⁎
. Below we assume 
⁎
. Thus, 
⁎
 and the shortest path 
⁎
 must contain the shortcut 
⁎
⁎
.

Let 
 and 
 be the trees of  that contain u and v, respectively, with . Based on relationship of the indices k, h, i, and j, there are several cases.

1.
; e.g., see Fig. 3. In this case, we have
⁎
⁎
⁎
 Note that 
⁎
⁎
 because 
⁎
 contains 
⁎
⁎
 and .

Fig. 3
Download : Download high-res image (26KB)
Download : Download full-size image
Fig. 3. Illustrating the case {k,h}∩{i,j}=∅.

2.
 and ; e.g., see Fig. 4. In this case, we have
 By Lemma 8, 
 and 
. Hence, we can obtain
⁎
⁎
⁎

Fig. 4
Download : Download high-res image (12KB)
Download : Download full-size image
Fig. 4. Illustrating the case k = i and h = j.

3.
, , and ; e.g., see Fig. 5. In this case, we have
⁎
 On the other hand, since , we also have
 Notice that 
⁎
⁎
. Combining the above two inequalities, we derive 
⁎
⁎
.

Fig. 5
Download : Download high-res image (16KB)
Download : Download full-size image
Fig. 5. Illustrating the case k = i, h > i, and h ≠ j.

4.
, , and . This is case is symmetric to Case 3 and we can prove 
⁎
 by a similar argument.

5.
; e.g., see Fig. 6. We claim that this case cannot happen. Indeed, recall that 
⁎
 contains 
⁎
⁎
. Since both u and v are in 
, 
⁎
 must also contain 
, where 
 is the subpath of P between 
 and 
. On the other hand, 
, which is equal to the length of P. Since 
⁎
⁎
, 
⁎
 must contain the shortcut 
⁎
⁎
 but cannot contain 
. This implies that 
 is not a shortest path between 
 and 
 in 
⁎
. However, since 
⁎
, which is a shortest path between u and v in 
⁎
, contains 
, 
 must be a shortest path between 
 and 
 in 
⁎
. We thus obtain contradiction.

Fig. 6
Download : Download high-res image (14KB)
Download : Download full-size image
Fig. 6. Illustrating the case k = h = i.

6.
. This case is symmetric Case 5. By a similar argument, we can show that it cannot happen.

7.
8.
 and . This case is symmetric to Case 7. By a similar argument, we can show that it cannot happen.

In summary, 
⁎
 holds in all possible cases. The lemma thus follows. □

3.2. Reducing DOAT to finding a shortcut for P
In light of Lemma 9, we reduce our DOAT problem on T to finding a shortcut for the vertex-weighted path P as follows.

For an index pair  with , we define a shortcut 
 connecting 
 and 
 with length 
, where  is a critical pair of . The diameter 
 is defined as 
. The diameter-optimally augmenting path (DOAP) problem on P is to find a shortcut 
 so that the diameter 
 is minimized; we use 
⁎
 to denote the minimized diameter.

With the help of Lemma 9, the following lemma shows that the DOAT problem on T can be reduced to the DOAP problem on P. Similar problem reductions were also used in [3], [14].

Lemma 10

1.
For any index pair  with , it holds that 
, where  is a critical pair of .

2.
If 
 is an optimal shortcut for the DOAP problem on P, then  is an optimal shortcut for the DOAT problem on T, where  is a critical pair of .

3.
⁎
⁎
.

Proof

Before proving Lemma 10(1), we first use it to prove Lemma 10(2) and Lemma 10(3).

Proof of Lemma 10(2). Suppose 
 is an optimal shortcut for the DOAP problem on P. By Lemma 10(1), we have 
. Assume to the contrary that  is not an optimal shortcut for the DOAT problem for T, and let 
⁎
⁎
 instead be an optimal shortcut, with 
⁎
 and 
⁎
. Then, 
⁎
⁎
. By Lemma 9,  and the critical pair 
 of  also defines an optimal shortcut for T. Hence, 
⁎
⁎
. By Lemma 10(1), 
. Combining all above, we obtain
⁎
⁎
 But this incurs contradiction since 
 is an optimal shortcut for the DOAP problem on P. Hence, Lemma 10(2) is proved.

Proof of Lemma 10(3). Lemma 10(3) follows immediately from Lemma 10(1) and Lemma 10(2). Indeed, suppose 
 is an optimal solution for the DOAP problem on P. Then, by Lemma 10(2),  is an optimal shortcut for the DOAT problem on T, where  is a critical pair of . Hence, we have 
⁎
 and 
⁎
. By Lemma 10(1), 
. Hence, 
⁎
⁎
.

Proof of Lemma 10(1). We now prove the first lemma statement. To simplify the notation, let 
 and 
. Our goal is to prove 
.

First of all, because  is a critical pair of , 
 holds for any two vertices 
 and 
 of P with .

We first prove that 
. Let 
 and 
 be any two vertices of P with . It suffices to show that 
.

Let u be the vertex of 
 farthest from 
, i.e., 
. Similarly, let v be the vertex of 
 farthest from 
. Recall that  and . Depending on the values of , there are several cases.

1.
 and ; e.g., see Fig. 8. In this case, 
 and 
. By Lemma 8, 
 and 
. Hence, we can derive

Fig. 8
Download : Download high-res image (11KB)
Download : Download full-size image
Fig. 8. Illustrating the case i = k and j = h.

2.
; e.g., see Fig. 9. In this case, the shortest path 
 between u and v in 
 must contain 
 and 
. Hence, we have

Fig. 9
Download : Download high-res image (18KB)
Download : Download full-size image
Fig. 9. Illustrating the case {i,j}∩{k,h}=∅.

3.
 and ; e.g., see Fig. 10. In this case, the shortest path 
 between 
 and v in 
 must contain 
 and 
. Hence, we have

Fig. 10
Download : Download high-res image (14KB)
Download : Download full-size image
Fig. 10. Illustrating the case i = k and j ≠ h.

4.
 and . This case is symmetric to Case 3. By a similar argument, we can show that 
.

5.
; e.g., see Fig. 11. In this case, we claim that 
 is 
. Indeed, assume to the contrary that this is not true. Then, 
 must contain the shortcut . This further implies that 
 must contain 
, which is the subpath of P between 
 and 
 (
). Since  is a critical pair of , 
 is no shorter than the path 
. Therefore, if we replace 
 by 
 in 
, we can obtain another shortest path 
 from u to 
 in 
. However, 
 cannot be a shortest path as it contains  twice. This incurs contradiction and thus the claim follows.

Fig. 11
Download : Download high-res image (15KB)
Download : Download full-size image
Fig. 11. Illustrating the case j = k.

Due to the claim, we have 
. We can now obtain

6.
. This case is symmetric to Case 5. By a similar argument, we can show that 
.

This proves that 
.

Next we prove that 
. Let u and v be any two vertices of T with 
 and 
, with . It suffices to show that 
.

If , then we can deduce

If , then both u and v are in 
; e.g., see Fig. 12. Hence, it holds that 
. By Lemma 8, 
. On the other hand, notice that the shortest path from u to either 
 or 
 in 
 does not contain the shortcut . Without loss of generality, we assume that the shortest path 
 from u to 
 in 
 does not contain . Thus, 
 must contain 
, implying that 
 is 
. Note that 
 is 
, which is the portion of P between 
 and 
. Hence, 
 is also the shortest path from 
 to 
 in 
 (i.e., 
 does not contain the shortcut 
). Therefore, 
. Since 
, 
. Combining all above we can derive

Fig. 12
Download : Download high-res image (15KB)
Download : Download full-size image
Fig. 12. Illustrating the case where both u and v are in T(vk).

This proves Lemma 10(1) and thus the entire lemma. □

In light of Lemma 10, we will focus on solving the DOAP problem on the vertex-weighted path P. Notice that the lengths of the shortcuts of P have not been computed yet.

3.3. Computing an optimal shortcut for P
To find an optimal shortcut for the DOAP problem on P, for each , we will compute an index  that minimizes the diameter 
 among all indices , i.e., 
, as well as the diameter 
. After that, the optimal shortcut of P is the one that minimizes 
 among the shortcuts 
 for all . We refer to the shortcuts for 
 for all  as 
-shortcuts. Therefore, our goal is to find an optimal 
-shortcut 
 for each .

Let 
 denote the number of vertices in 
, for each . Note that 
. Fix an index i with . In the following, we will present an algorithm that computes an optimal 
-shortcut 
 and the diameter 
 in 
 time and  space. In this way, solving the DOAP problem on P takes 
 time and  space in total.

We introduce a domination relationship among 
-shortcuts.

Definition 11

For any two indices j and k with , , we say that 
 dominates 
 if 
; e.g., see Fig. 13.

Fig. 13
Download : Download high-res image (24KB)
Download : Download full-size image
Fig. 13. 
 dominates 
 if 
, i.e., the length of the red path is less than or equal to the length of the blue path. (For interpretation of the colors in the figure(s), the reader is referred to the web version of this article.)

The following lemma implies that if 
 dominates 
, then shortcut 
 can be ignored or “pruned”.

Lemma 12

If 
 dominates 
, then 
.

Proof

Let u and v be any two vertices of P. To prove the lemma, it suffices to show that 
. We assume that , since the proof for the case  is similar.

If 
, then 
. Otherwise, the shortest path 
 contains the shortcut 
. Hence, 
 is equal to either 
 or 
. We assume that it is the former case. Then we have
 The lemma thus follows. □

Let 
 be the set of all 
-shortcuts, i.e., 
. In the following, we describe a pruning algorithm (which we refer to as Algorithm 2) that computes a subset S of 
 such that no two shortcuts of S dominate each other and S contains at least one optimal 
-shortcut. As will be seen later, these properties of S allow an efficient algorithm to find an optimal 
-shortcut.

Before running the pruning algorithm, we compute the lengths of shortcuts of 
 by brute force as follows. First, with  time preprocessing, given any two vertices u and v with 
 and 
 for , we can compute 
 in constant time. Consider a tree 
 with . Computing the length of 
 reduces to finding a critical pair of . To this end, we compute 
 for all vertices 
 and all vertices 
, which can be done in 
 time (and  space). As such, computing the lengths of all shortcuts of 
 takes 
 time.

Our pruning algorithm processes the shortcuts 
 for all  one by one. A stack S is maintained and  initially. Consider any . If , then we push 
 into S. Otherwise, let 
 be the shortcut at the top of S. If 
 and 
 do not dominate each other, then we push 
 into S. Otherwise, if 
 dominates 
, then we proceed on , i.e., 
 is pruned. If 
 dominates 
, then we pop 
 out of S (i.e., 
 is pruned). Next, we keep popping the top element out of S until either S becomes ∅ or 
 does not dominate it; in either case we push 
 into S.

As the lengths of the shortcuts of 
 are available, Algorithm 2 runs in  time. The following lemma proves the correctness of Algorithm 2.

Lemma 13

After Algorithm 2, no two shortcuts of S dominate each other and S contains at least one optimal 
-shortcut.

Proof

We first prove the following observation, which will be used for proving the lemma.

Observation 2

Consider any three indices j, k, and h with . We have the following transitive properties.

1.
If 
 dominates 
, and 
 dominates 
, then 
 dominates 
.

2.
If 
 and 
 do not dominate each other, and 
 and 
 do not dominate each other, then 
 and 
 do not dominate each other.

Proof of Observation 2. Since , 
.
1.
If 
 dominates 
, and 
 dominates 
, then we have
 Hence, 
 dominates 
.

2.
If 
 and 
 do not dominate each other, and 
 and 
 do not dominate each other, then we have
 Hence, 
 does not dominate 
.
 Hence, 
 does not dominate 
.

Therefore, 
 and 
 do not dominate each other.

This proves Observation 2.
We are now in a position to prove the lemma.

We first show that no two shortcuts in S dominate each other by mathematical induction. Initially the statement holds, for . We assume that the statement holds right before 
 is processed. Let S refer to the stack right before 
 is processed; let 
 be the shortcut at the top of S if . According to Algorithm 2, 
 is pushed into S in the following cases.

1.
. In this case, S has only one shortcut after 
 is pushed in. Hence, the statement trivially holds.

2.
, and 
 and 
 do not dominate each other. Let 
 be any shortcut in S. To prove the statement holds on S after 
 is pushed in, it suffices to show that 
 and 
 do not dominate each other. If 
, then this is obviously true. Otherwise, by the induction hypothesis, 
 and 
 do not dominate each other. As 
 and 
 do not dominate each other, by Observation 2, 
 and 
 do not dominate each other.

3.
, and 
 dominates 
. In this case, 
 is popped out of S, and afterwards, the algorithm keeps popping out the top element of S until either S becomes ∅ or 
 does not dominate the current top element of S, denoted by 
. In the former case, the statement trivially holds. In the latter case, we claim that 
 does not dominate 
. Indeed, by the induction hypothesis, 
 and 
 do not dominate each other. Since 
 dominates 
, 
 cannot dominate 
 since otherwise 
 would dominate 
 by Observation 2. Then, following the same argument as Case 2, 
 and 
 do not dominate each other for any 
 in the current stack S. The statement thus holds after 
 is pushed into S.

This proves that no two shortcuts in S dominate each other.
We next show that S contains at least one optimal 
-shortcut. Let 
⁎
 be an optimal 
-shortcut. If 
⁎
 is in S, then we are done with the proof. Otherwise, according to Algorithm 2, 
⁎
 must be dominated by another shortcut 
 of 
. By Lemma 12, 
 is also an optimal 
-shortcut. If 
 is in S, then we are done with the proof. Otherwise, we can inductively show that S contains an optimal 
-shortcut.

This completes the proof of the lemma. □

Using the algorithm for Theorem 7 as a subroutine, the following lemma provides a binary search algorithm that finds an optimal 
-shortcut from S in  time and  space.

Lemma 14

An optimal 
-shortcut in S can be found in  time and  space.

Proof

We first prove some properties that our algorithm relies on.

Consider the graph 
 for an index j with . By slightly abusing the notation, let 
. Suppose 
 is a diametral pair of 
 with . Then, 
.

We claim that if , then 
 is also a diametral pair. Indeed, since , by Lemma 8 and the definition of 
, we have 
. Hence, we can derive
 Hence, 
 is also a diametral pair.

Similarly, we claim that if , then 
 is also a diametral pair. The claim can be proved by a similar argument as above.

Note that since ,  and . Due to the above two claims, we assume that  and . Based on the values of a and b, we define the following five functions (e.g., see Fig. 14).

1.
For the case  and , we define
 Hence, if  and , we have .

2.
For the case  and , we define
 
 Hence, if  and , we have .

3.
For the case  and , we define 
 
 Note that 
 is equal to 
 if 
, and 
 otherwise.

Hence, if  and , we have .

4.
For the case , we define 
 
 Hence, if , we have .

5.
For the case  and , we define 
 
 Hence, if  and , we have .

Fig. 14
Download : Download high-res image (124KB)
Download : Download full-size image
Fig. 14. (a) α(i,j) is the distance between v1 and vm. (b) β(i,j) is the maximum distance between v1 and all vertices on (i,j). (c) γ(i,j) is the maximum distance between vm and all vertices on (i,m). (d) δ(i,j) is the maximum distance between two vertices on (i,j). (e) λ(i,j) is the maximum distance between v1 and all vertices on (1,i].

With the above definitions, we have Hence, if j changes in , the graph of  is the upper envelope of the graphs of the five functions.

Recall that our goal is to find an optimal 
-shortcut in S. Let I denote the set of the indices j of all shortcuts 
 of S. We consider these indices of I in order. We intend to show that  is a unimodal function (first decreases and then increases) as j changes in I. To this end, we prove that each of the above five functions is a monotonically increasing or decreasing function as j changes in I. Note that each index of I is in . To simplify the notation, we simply let , or equivalently, one may consider that our pruning algorithm does not prune any shortcut from 
 and thus 
.

As no two shortcuts of S dominate each other, 
 and 
 do not dominate each other for any , i.e., 
 and 
. Relying on this property, we prove monotonicity properties of the five functions as follows. Consider any index .

1.
.

Proof:

Hence,  is monotonically decreasing as j increases.

2.
.

Proof: For each 
, we have
 Hence,  holds and  is monotonically increasing as j increases.

3.
.

Proof:

Let 
 be the index such that 
. Depending on whether 
 or 
, there are two cases.

•
If 
, then
 On the other hand, 
. Hence, 
.

•
If 
, then
 Since 
 and 
 do not dominate each other, we have
 Hence,
 If 
, then we have 
; otherwise, 
. As such, in either case  holds.

Hence,  is monotonically decreasing as j increases.

4.
.

Proof: For each 
, we have,
 Hence,  and  is monotonically increasing as j increases.

5.
.

Proof: By definition,  is constant for all indices j. Thus, .

On the basis of the above monotonicity properties of the functions, we present a binary search algorithm that finds an optimal 
-shortcut in  time and  space.

Our algorithm performs binary search on the indices , with  and  initially. In each step, we decide whether we will proceed on  or on , where 
 
. To this end, we compute  and . By Lemma 10,  where  is a critical pair of . Since  is a unicycle graph, we compute  in  time by Theorem 7. Therefore,  can be computed in  time. Note that the algorithm of Theorem 7 also returns a diametral pair for , and we can decide which of the five cases for the functions α, β, γ, δ, and λ the diametral pair belong to. We do the same for . Assume that  and , for two functions f and g in . Then we have the following cases

1.
. We have the following subcases.

•
. In this case, our algorithm proceeds on the interval . To see this, since both β and δ are monotonically increasing functions, we have , for any . As such, the diameter  would increase if we proceed on .

•
. In this case, we proceed on the interval  because both functions are monotonically decreasing.

•
. In this case, we stop the algorithm and return 
 as an optimal 
-shortcut. To see this,  for any . Hence,  achieves the minimum at  among all .

2.
. We have the following subcases.

•
One of f and g is λ. In this case, by a similar argument as before, we return 
 as an optimal 
-shortcut if , and return 
 as an optimal 
-shortcut if .

•
. In this case, since both β and δ are increasing functions, by a similar argument as before, we proceed on the interval .

•
. In this case, since both α and γ are decreasing functions, by a similar argument as before, we proceed on the interval .

•
One of f and g is in  and the other is in . In this case, one of 
 and 
 is an optimal 
-shortcut, which can be determined by comparing  with . To see this, without loss of generality, we assume that  and . Hence,  for any , and  for any . As such,  for all .

The algorithm will find an optimal 
-shortcut in  iterations. As each iteration takes  time, the total time of the algorithm is . The space is . □

The proof of the following theorem summarizes our algorithm for the DOAT problem.

Theorem 15

The DOAT problem on the tree T can be solved in 
 time and  space.

Proof

We first compute a diametral path P of T as well as the weights 
 for all vertices 
 of P, which takes  time. Then, for each , we compute an optimal 
-shortcut 
 and its diameter 
 for the DOAP problem on the vertex-weighted path P. To do so, we first compute the critical pairs of  for all  and thus the lengths of the set 
 of the shortcuts 
 for all . This step takes 
 time and  space. Next, we run a pruning algorithm to prune those shortcuts that are dominated by others from 
 and obtain a subset S of 
 such that no two shortcuts of S dominate each other and S contains an optimal 
-shortcut; this step takes  time.

After having S, by using the algorithm of Theorem 7 as a subroutine, a binary search algorithm can find an optimal 
-shortcut 
 as well as the diameter 
. Recall that the critical pairs of  for all  have been computed. Let 
 be the critical pair of . We store 
 and 
. Other space used in this step will be disregarded when we run the same algorithm to compute the optimal 
-shortcuts for other i's; so the total space used in the algorithm is bounded by . After the optimal 
-shortcuts for all  are computed, we determine the index i with minimum 
 and return 
 as the optimal shortcut for the DOAT problem on T and return 
 as the diameter. It takes 
 time and  space to compute an optimal 
-shortcut for each . Hence, computing optimal 
-shortcuts for all  takes 
 time in total, for 
. The space is  because only constant space is occupied (for storing 
 and 
) after an optimal 
-shortcut is computed for each i. □