Session types describe patterns of interaction on communicating channels. Traditional session types include a form of choice whereby servers offer a collection of options, of which each client selects exactly one. Mixed choices blur the distinction between servers and clients (that is, external and internal choice) by allowing options to be both offered and selected in the same choice. We introduce mixed choices in the context of session types and argue that they increase the flexibility of program development at the same time that they reduce the number of synchronisation primitives down to exactly one. We present a type system incorporating subtyping and prove preservation and absence of runtime errors for well-typed processes. We further show that classical (conventional) sessions can be faithfully and tightly embedded in mixed choices, and conversely that there is a minimal encoding from mixed choices to classical sessions. Finally, we discuss algorithmic type checking and a runtime system built on top of a conventional (choice-less) message-passing architecture.

Keywords
Type systems
Session types
Mixed choice

1. Introduction
Session types provide for describing series of continuous interactions on communication channels [1], [2], [3], [4], [5]. When used in type systems for programming languages, session type systems statically verify that programs follow protocols, and hence that they do not engage in communication mismatches.

In order to motivate mixed sessions, suppose that we want to describe a process that asks for a fixed but unbounded number of integer values from some producer. The consumer may be in two states: happy with the values received so far, or ready to ask the producer for a new value. In the former case it must notify the producer so that this may stop sending numbers. In the latter case, the client must ask the producer for another integer, after which it “goes back to the beginning”. Using classical sessions, and looking from the consumer side, the communication channel can be described by a (recursive) session type

Image 1
of the form

Download : Download high-res image (7KB)
Download : Download full-size image
where
Image 3
denotes internal choice (the consumer decides), the two branches in the choice are labelled with
Image 4
and
Image 5
, type
Image 6
denotes a channel on which no further interaction is possible, and
Image 7
denotes the reception of an integer value. Reception is a prefix to a type, the continuation is
Image 1
(in this case the “goes back to the beginning” part). The code for the consumer (and the producer as well) features parts that exchange messages in both directions:
Image 4
and
Image 5
selections from the consumer to the producer, and
Image 8
messages from the producer to the consumer. In particular, the consumer must first select option
Image 4
(outgoing) and then receive an integer (incoming).
Using mixed sessions one can invert the direction of the

Image 5
selection and write the type of the channel (again as seen from the side of the consumer) as

Download : Download high-res image (8KB)
Download : Download full-size image
The changes seem merely cosmetic, but now labels are followed by a mandatory polarity (
Image 10
or
Image 11
) and label-polarity pairs constitute the keys of the choice type when seen as a map. The integer value is piggybacked on top of selection
Image 5
. As a result, the classical session primitive operations: selection and branching (that is, internal and external choice) and communication (output and input) become one only: mixed choice. The producer can be safely written as a recursive process whose body is

Download : Download high-res image (7KB)
Download : Download full-size image
offering a choice on channel end
Image 13
featuring mixed branches with labels
Image 14
and
Image 15
, where
Image 16
denotes the terminated process and
Image 17
a recursive call to the producer. The example is further developed in Section 2.
Mixed sessions build on Vasconcelos presentation of session types which we call classical sessions [3], by adapting choice and input/output as needed, but keeping everything else unchanged as much as possible. The result is a language with

•
a single synchronisation/communication primitive: mixed choice on a given channel that

•
allows for duplicated labels in choice processes, leading to non-determinism in a pure linear setting, and

•
replicated output processes arising naturally from replicated mixed choices, and that

•
enjoys preservation and absence of runtime errors for typable processes,

•
provides for embedding classical sessions in a tight type and operational correspondence, and

•
that can be embedded in classical sessions up to a minimal encoding [6].

The present paper gathers material from previous work presented at ESOP 2020 and PLACES 2020 [7], [8]. The former paper introduces mixed sessions together with an embedding of classical into mixed sessions. The latter paper presents an encoding of a sublanguage of mixed choices into classical sessions; here we address the full language.

The rest of the paper is organised as follows: the next section shows mixed sessions in action; Section 3 introduces the technical development of the language, and Section 4 proves the main results (preservation and absence of runtime errors for typable processes). Section 5 recalls classical session types and the encoding criteria. Section 6 presents the classical-to-mixed and Section 7 presents the mixed-to-classical encoding. Section 8 discusses implementation details, and Section 9 explores related work. Section 10 concludes the paper.

2. There is room for mixed sessions
This section introduces the main ideas behind mixed sessions via examples. We address mixed choices, duplicated labels in choices, and unrestricted output, in this order.

2.1. Mixed choices
Consider the producer-consumer problem where the producer produces only insofar as so requested by the consumer. Here is the code for a producer that writes numbers starting from

Image 18
on channel end
Image 13
.

Download : Download high-res image (15KB)
Download : Download full-size image
Syntax
Image 20
introduces a choice between
Image 21
and
Image 22
on channel end
Image 13
. Qualifier
Image 23
is either
Image 24
or
Image 25
and controls whether the process is persistent (remains after reduction) or is ephemeral (is consumed in the reduction process). Each branch in a choice is composed of a label (
Image 4
or
Image 5
), a polarity mark (input
Image 11
or output
Image 10
), a variable or a value (
Image 26
or
Image 18
), and a continuation process (the syntax after the dot). The terminated process is represented by
Image 16
; notation
Image 27
introduces a recursive process. The
Image 27
syntax and its encoding in the base language is from the Pict programming language [9] and taken up by Sepi [10].
A consumer that requests

Image 18
integer values on channel end
Image 28
can be written as follows, where
Image 29
represents the only value of type
Image 30
.

Download : Download high-res image (21KB)
Download : Download full-size image
Suppose that
Image 13
and
Image 28
are two ends of the same channel. When choices on
Image 13
and on
Image 28
get together, a pair of matching label-polarities pairs is selected and a value transmitted from the output continuation to the input continuation.
Types for the two channel ends ensure that synchronisation succeeds. The type of

Image 13
is
Image 32
where the qualifier
Image 25
says that the channel end must be used in exactly one process,
Image 33
denotes external choice, and each branch is composed of a label, a polarity mark, the type of the communication, and that of the continuation. The type
Image 6
states that no further interaction is possible at the channel and
Image 34
introduces a recursive type. The type of
Image 28
is obtained from that of
Image 13
by inverting views (
Image 3
and
Image 33
) and polarities (
Image 10
and
Image 11
), yielding
Image 35
. The choice at
Image 13
in the
Image 36
process contains all branches in the type and so we select an external choice view
Image 33
for
Image 13
. The choices at
Image 28
contain only part of the branches, hence the internal choice view
Image 3
. This type discipline ensures that processes do not engage in runtime errors when trying to find a match for two choices at the two ends of a same channel.
A few type and process abbreviations simplify coding: i) the

Image 25
qualifier can be omitted, ii) the terminated process
Image 16
together with the trailing dot can be omitted; iii) the terminated type
Image 6
together with the trailing dot can be omitted; and iv) we introduce wildcards
Image 37
in variable binding positions (in input branches).
2.2. Duplicated labels in choices for types and for processes
Classical session types require distinct identifiers to label distinct branches. Mixed sessions relax this restriction by allowing duplicated labels whenever paired with distinct polarities. The next example describes two processes—

Image 38
and
Image 39
—that bidirectionally exchange a fixed number of
Image 40
-labelled messages. The number of messages that flow in each direction is not fixed a priori, but instead decided by the non-deterministic operational semantics. The type that describes channel
Image 13
in the code of process
Image 38
below is
Image 41
, where one can see the
Image 40
label in two distinct branches, but with different polarities.
Process

Image 38
features a parameter
Image 18
that controls the number of messages exchanged (sent or received). The end of the interaction (when
Image 18
reaches 0) is signalled by a
Image 42
message.

Download : Download high-res image (42KB)
Download : Download full-size image
Process

Image 39
sees the channel from the dual viewpoint, obtained by exchanging
Image 11
with
Image 10
and
Image 3
with
Image 33
. Parameter
Image 18
in this case denotes the number of messages received. When
Image 42
, the process writes the result on channel end
Image 44
, global to the
Image 39
process.

Download : Download high-res image (35KB)
Download : Download full-size image
Mixed sessions allow for duplicated message-polarity pairs permitting a new form of non-determinism that uses exclusively linear channels. A process of the form

Image 46
declares a channel with end points
Image 13
and
Image 28
to be used in process
Image 47
. The process

Download : Download high-res image (15KB)
Download : Download full-size image
featuring two linear choices may reduce to either
Image 49
or to
Image 50
. Non-determinism in the π-calculus without choice ([11], [12] for example) can only be achieved by introducing race conditions on
Image 24
channels. For example, the π-calculus process

Download : Download high-res image (8KB)
Download : Download full-size image
reduces either to
Image 52
or to
Image 53
, leaving for the runtime the garbage collection of the inert residuals. Also note that in this case, channel
Image 28
cannot remain linear.
Duplicated message-polarities in choices lead to elegant and concise code. A random number generator with a given number

Image 18
of bits can be written with two processes. The first process sends
Image 18
messages on channel end
Image 13
. The contents of the messages are irrelevant (we use value
Image 29
of type
Image 30
); what is important is that
Image 18
Image 5
messages are sent, followed by a
Image 42
message, followed by silence.

Download : Download high-res image (29KB)
Download : Download full-size image
The reader process reads the

Image 5
messages in two distinct branches and interprets the messages received on one branch as bit
Image 55
, and on the other as
Image 56
. Upon the reception of a
Image 42
message, the accumulated random number is conveyed on channel end
Image 44
, a variable global to the
Image 57
process.

Download : Download high-res image (32KB)
Download : Download full-size image
Notice that mixed sessions allow duplicated label-polarity pairs in processes but not in types. This point is further discussed in Section 3. Also note that duplicated message labels could be easily added to traditional session types.

2.3. Unrestricted output
Mixed sessions allow for replicated output processes. The original version of the π-calculus [13], [14] features recursion on arbitrary processes. Subsequent versions [12] introduce replication but restricted to input processes. When compared to languages with unrestricted input only, unrestricted output allows for more concise programs and fewer message exchanges for the same effect. Here is a process (call it P) containing a pair of processes that exchange

Image 59
-labelled messages ad-aeternum,

Download : Download high-res image (7KB)
Download : Download full-size image
where
Image 13
is of type
Image 61
. The
Image 24
prefix denotes replication: an
Image 24
choice survives reduction. Because none of the two sub-processes features a continuation, process P reduces to P in one step. The behaviour of
Image 62
can be mimicked by a process without output replication, namely,

Download : Download high-res image (9KB)
Download : Download full-size image
Even if unrestricted output can be simulated with unrestricted input, the encoding requires one extra channel (
Image 64
) and an extra message exchange (on channel
Image 64
) in order to reestablish the output on channel end
Image 28
.
It is a fact that unrestricted output can be added to any flavour of the π-calculus (session-typed or not). In the case of mixed sessions it arises naturally: there is only one communication primitive—choice—and this can be classified as

Image 25
or
Image 24
. If an
Image 24
-choice happens to behave in “output mode”, then we have an
Image 24
-output. It is not obvious how to design the language of mixed choices without allowing unrestricted output, while still allowing unrestricted input (which is mandatory for unbounded behaviour).
3. The syntax and semantics of mixed sessions
This section introduces the syntax and the semantics of mixed sessions. Inspired in Vasconcelos' formulation of session types for the π-calculus [3], [4], mixed sessions replace input and output, selection and branching (internal and external choice), with a single construct which we call choice.

3.1. Syntax
Fig. 1 presents the syntax of values and processes. Let  range over a (countable) set of variables, and let l range over a set of labels. Metavariable v ranges over values. Following the tradition of the π-calculus set up by Milner et al. [13], [14], variables are used both as placeholders for channels and for incoming values in communication. Linearity constraints, central to session types but absent in the π-calculus, dictate that the two ends of a channel must be syntactically distinguished; we use one variable for each end [3]. Even if values can be faithfully encoded in the π-calculus, they become quite handy as primitive constructs. Here we pick the boolean values (so that we may have a conditional process) and unit that plays its role in the embeddings (Sections 6 and 7).

Fig. 1
Download : Download high-res image (54KB)
Download : Download full-size image
Fig. 1. The syntax of processes.

Metavariables P and Q range over processes. Choices are processes of the form 
 offering a choice of 
 alternatives on channel end x, where I denotes a finite, non-empty, set of indices. Qualifier q describes how choice behaves with respect to reduction. If q is

Image 65
, then the choice is consumed in reduction, otherwise q must be
Image 66
, and in this case the choice persists after reduction. The type system in Fig. 9 rejects nullary (empty) choices. Choices are composed of two kinds of branches: output  and input . An output branch sends value v and continues as P. An input branch receives a value and continues as P with the value replacing variable x. The type system in Fig. 9 makes sure that value v in  is a variable.
The remaining process constructors are standard in the π-calculus. Processes of the form  denote the parallel composition of processes P and Q. Scope restriction  binds together the two channel ends x and y of a same channel in process P. The conditional process

Image 67
behaves as process P if v is
Image 68
and as process Q otherwise. Since we do not have nullary choices, we include 0—called inaction—as primitive to denote the terminated process.
3.2. Operational semantics
The variable bindings in the language are as follows: variables x and y are bound in P in a process of the form ; variable x is bound in P in a choice of the form . The sets of bound and free variables, as well as substitution, , are defined accordingly. We take processes “up to renaming of bound variables”, in the sense that we identify processes that differ only in the names of bound variables. In other words, we follow Barendregt variable convention: the bound variables of processes that occur in a mathematical context are taken to be different from the free variables [15].

Fig. 2 summarizes the operational semantics of mixed sessions. Following the tradition of the π-calculus, a binary relation on processes—structural congruence—rearranges processes when preparing these for reduction. Such an arrangement reduces the number of rules to be included in the operational semantics. Structural congruence was introduced by Milner [11], [12]. It is defined as the least congruence relation closed under the axioms in Fig. 2. The first three rules state that parallel composition is commutative, associative, and takes inaction as the neutral element. The fourth rule allows exchanging the two channel ends in channel creation; this rule is absent in Vasconcelos [3] but allows reducing the number of otherwise necessary communication axioms in reduction. The fifth rule is commonly known as scope extrusion [13], [14] and allows extending the scope of channel ends  to process Q. The side-condition “x and y not free in Q” is redundant in face of the variable convention. The penultimate rule allows collecting channel bindings no longer in use, and the last rule allows for rearranging the order of channel bindings in a process.

Fig. 2
Download : Download high-res image (107KB)
Download : Download full-size image
Fig. 2. Operational semantics.

Reduction includes six axioms, two for the destruction of boolean values (via a conditional process), and four for communication. The axioms for communication take processes of a similar nature. Scope restriction  identifies the two ends of the channel engaged in communication. Under the scope of the channel one finds three processes: the first contains an output process on channel end x, the second contains an input process on channel end y, and the third (R) is an arbitrary process that may contain other references to x and y (the witness process). Communication proceeds by identifying a pair of compatible branches, namely  and . The result contains the continuation process P and the continuation process Q with occurrences of the bound variable z replaced by value v (together with the witness process). The four axioms differ in the treatment of the process qualifiers:

Image 65
(ephemeral) and
Image 66
(persistent). Ephemeral processes are consumed in reduction, persistent processes remain in the contractum.
Choices apart, rules R-LinLin and R-LinUn are already present in the works of Milner and Vasconcelos [12], [3]. Rules R-UnLin and R-UnUn are absent on the grounds of economy: replicated output can be simulated with a new channel and a replicated input. In mixed choices these rules cannot be omitted for there is no distinction between input and output: choice is the only (symmetrical) communication primitive.

We have designed mixed choices in such a way that labels may be duplicated in choices; more: label-polarity pairs may be also duplicated. This allows for non-determinism in a linear setting. For example, process reduces in one step to either

Image 70
or
Image 71
.
The examples in Section 2 take advantage of a

Image 72
notation, a derived process construct inspired in the SePi [10] and the Pict languages [9]. A process of the form
Image 73
is understood as and calls to the recursive procedure, of the form , are interpreted as
Image 75
, for ℓ an arbitrarily chosen label. The derived syntax hides channel end y and simplifies the syntax of calls to the procedure. Procedures with more than one parameter require tuple passing, a notion that is not primitive to mixed sessions but that is easy to encode; see Vasconcelos [3].
3.3. Typing
Fig. 3 summarises the syntax of types. We rely on an extra set, that of type variables,  Types describe values, including boolean and unit values, and channel ends. A type of the form 
 denotes a channel end. Qualifier q states the number of processes that may contain references to the channel end: exactly one for

Image 76
, zero or more for
Image 77
. View ♯ distinguishes internal (⊕) from external (&) choice. This distinction is not present in processes but is of paramount importance for typing purposes, as we shall see. The branches are either of output——or of input——nature. In either case, T denotes the object of communication and U describes the subsequent behaviour of the channel end. Type
Image 78
denotes the channel end on which no more interaction is possible. Types  and a cater for recursive types.
Fig. 3
Download : Download high-res image (38KB)
Download : Download full-size image
Fig. 3. The syntax of types.

Types are subject to a few syntactic restrictions: i) choices must have at least one branch; ii) label-polarity pairs—l⋆—are pairwise distinct in the branches of a choice type (unlike in processes); iii) recursive types are assumed contractive (that is, containing no subterm of the form 
 with ). New variables, new bindings: type variable a is bound in T in type . Again the definitions of bound and free names as well as that of substitution——are defined accordingly.

The coinductive rules for type equivalence are presented in Fig. 4. By coinductive rules, we are stating that, in fact, the type equivalence relation is defined via a fixed-point construction in the following manner: two types  are equivalent——if the pair  belongs to the greatest fixed-point of the monotone operator 
 defined from the rules as

Fig. 4
Download : Download high-res image (28KB)
Download : Download full-size image
Fig. 4. Coinductive type equivalence.

Duality is a notion central to session types. In order for channel communication to proceed smoothly, the types for the two channel ends must be compatible: if one end says input, the other must say output; if one end says external choice, the other must say internal choice. In presence of recursive types, the problem of building the dual of a given type has been elusive, as works by Bernardi and Hennessy, Bono and Padovani, Gay et al., and Lindley and Morris suggest [16], [17], [18], [19]. Here we eschew the problem by working with a duality relation, as in Gay et al. [18], [20] and other works, such as Kouzapas et al. [6].

We define what it means for two types to be dual using a fixed point construction and present the coinductive rules in Fig. 5. Type

Image 78
is the dual of itself. The rule for choice types requires dual views (& is the dual of ⊕, and vice-versa) and dual polarities (? is the dual of !, and vice-versa). Furthermore, the objects of communication must be equivalent and the continuations must be again dual. The other two rules unfold a recursive type on the left and on the right. As an example, we can establish that
Lemma 1 Properties of duality

1.
Duality is symmetric, that is, if , then .

2.
Duality is an involution, that is, if  and , then .

Proof

We sketch the first case. Consider the operator 
 defined from the rules of Fig. 5 and the set . We need to show that 
 to conclude the result using the coinduction principle. We show the choice case: when T is 
 then U is 
, which from the duality rule we know that 
. Given that the view and polarity dualities are symmetric, and the type equivalence is also symmetric, we conclude that 
. Furthermore, given that 
, by definition of S, 
. Thus, by definition of 
, 
. □

Mixed sessions come equipped with a notion of subtyping. We define both type and branch subtyping simultaneously, using the coinductive rules in Fig. 6. These are essentially the rules of Gay and Hole [20] for algorithmic subtyping. Base types (

Image 78
,
Image 81
,
Image 82
) are subtypes to themselves. Subtyping behaves differently in presence of external or internal choice. For external choice we require the branches in the supertype to contain those in the subtype: exercising less options cannot cause difficulties on the receiving side. For internal choice we require the opposite: here offering more choices can not cause runtime errors. For branches we distinguish output from input: output is contravariant on the contents of the message, input is covariant. In either case, the continuation is covariant. Choices, input/output, and recursive types receive no different treatment than those in classical sessions [20]. The operator handles recursion in the exact same way as the operator 
. We can show that subtyping is a preorder.
Lemma 2 Subtyping is a pre-order

For  either all types or all branches,

1.
.

2.
If  and , then .

Proof

Item 1. Consider the operator 
 defined from the rules of Fig. 6 and the set we need to show that 
, which via the coinduction principle allows to conclude that 
, the greatest fixed-point of 
. Let  and consider the possible cases: if T is

Image 83
or
Image 82
, then 
 by definition of 
; if T is 
, since  for any branch, we have 
; if T is , since , by definition of 
, we have 
. Finally, since , by definition of 
, 
. The case of branches is also direct. This concludes that 
, which by the coinduction principle shows that the elements in  are indeed in the greatest fixed point of 
.
Item 2. Consider the set . We sketch the external choice case: consider that Y is a type of the form 
, which makes X of the form 
 and Z as 
. Furthermore, from the subtyping rules we know that 
 and 
. Thus, we conclude that  and 
, which from the definition of 
, follows that 
. □

A similar reasoning shows that .

Before presenting the type system, we need to introduce two operations that manipulate typing contexts. The rules in Fig. 8 define the meaning of context split and context update. These two relations are taken verbatim from Vasconcelos [3]; context split is originally from Walker [21] (cf. Kobayashi et al. [22], [23]). Context split is used when type checking processes with two sub-processes. In this case we split the context in two, by copying unrestricted entries to both contexts and linear entries to one only. Context update is used to add to a given context an entry representing the continuation (after a choice operation) of a channel. If the variable in the entry is not in the context, then we add the entry to the context. Otherwise we require the entry to be present in the context and the type to be unrestricted.

Fig. 8
Download : Download high-res image (35KB)
Download : Download full-size image
Fig. 8. Context split and context update.

The typing rules for values should be straightforward: constants have their own types, the type for a variable is read from the context, and T-Sub is the subsumption rule, allowing a type for a value to be replaced by a supertype.

The rules for branches— T-Out and T-In —follow those for output and input in classical session types. To type an output branch we split the context in two: one part for the value, the other for the continuation process. To type an input branch we add an entry with the bound variable x to the context under which we type the continuation process. Rule T-In rejects branches of the form  when v not a variable. The continuation type T is not used in neither rule; instead it is incorporated in Γ via the type for the channel of the choice process (cf. rule T-Choice below).

The rules for inaction, parallel composition, and conditional are from Vasconcelos [3]. That for scope restriction is adapted from Gay and Hole [20]. Rule T-Inact follows the general pattern for axioms, requiring an

Image 77
context. Rule T-Par splits the context in two, providing each subprocess with one part. Rule T-If splits the context and uses one part to type guard v. Because v is unrestricted, we know that 
 contains exactly the
Image 77
entries in 
 and that 
 is equal to 
. Context 
 is used to type both branches of the conditional, for only one of them will ever execute. Rule T-Res introduces in the typing context entries for the two channel ends, x and y, at dual types.
The rule for choice, T-Choice, is new. We first introduce predicates Γ q on contexts, for . Predicate Γ un is the pointwise extension of the predicate with the same name for types, in Fig. 7. Predicate Γ lin is true of all Γ. Hence, all contexts are linear and only some contexts are unrestricted.

The incoming context is split in two: one for the subject x of the choice, the other for the various branches in the choice. The process qualifier, 
, dictates the nature of the incoming context—

Image 77
or
Image 76
—as witnessed by the first premise to the rule. This allows for a linear choice to contain channels of an arbitrary nature, but limits unrestricted choices to unrestricted channels only (for one cannot predict how many times such choices will be exercised). The second premise extracts a type 
 for x. The third premise types each branch in turn: type 
 is used to type values 
 in the branches and each type 
 is used to type the corresponding continuation. The rule updates context 
 with the continuation type of x: if 
 is
Image 76
, then x is not in 
 and the update operation simply adds the entry to the context. If, on the other hand, 
 is
Image 77
, then x is in 
 and the context update operation (together with rule T-Sub ) insists that type 
 is a subtype of
Image 87
, meaning that 
 is a recursive type.
The last premise to rule T-Choice dictates that the set of labels in the choice type coincides with that in the choice process. That does not mean that the label-polarity pairs are in a one-to-one correspondence: label-polarity pairs are pairwise distinct in types (see the syntactic restrictions in Section 3.3), but not in processes. For example, process

Image 88
can be typed against context
Image 89
. Furthermore, from the fact that the two sets must coincide does not follow that the label-polarity pairs type in the context must coincide with those in the process. Taking advantage of subtyping, the above process can still be typed against context
Image 90
because
Image 91
. The opposite phenomenon happens with external choice, where one may remove branches by virtue of subtyping.
We complete this section by discussing examples that illustrate options taken while building the typing system (we postpone the formal justification to Section 4). Suppose we allow empty choices in the syntax of types. Then process would be typable by taking , yet the process would not reduce. We could add an extra reduction rule for the effect which would satisfy preservation (Theorem 7). We decided not to include it in the reduction rules as we felt no need for the extra complexity. Including the rule also does not bring any apparent benefit.

The syntax of processes places no restrictions on the label-polarity pairs in choices; yet that of types does. What if we relax the restriction that label-polarities pairs in choice types must be pairwise distinct? Then process could be typed under the empty context, yet the process might reduce to

Image 93
which is a runtime error.
4. Well-typed mixed sessions do not lead to runtime errors
This section introduces the main results of mixed choices: absence of runtime errors and preservation, both for well-typed processes.

We say that a process is a runtime error if it is structurally congruent to:

•
a process of the form
 
 
 where 
 with each 
 is obtained by dualising 
, or

•
a process of the form  and v is not a variable, or

•
a process of the form

Image 67
and v is neither
Image 68
nor
Image 94
.
Examples of processes which are runtime errors include:

Notice that processes of the form

Image 96
cannot be classified as runtime errors for they may be typed. Just think of
Image 97
, typable under the empty context. Unlike the interpretations of session types in linear logic by Caires, Pfenning and Wadler [24], [25], [26], [27], typable mixed session processes can easily deadlock. Similarly, processes with more than one
Image 76
-choice on the same channel end can be typed. For example process
Image 98
can be typed under context
Image 99
. Recall the relationship between qualifiers in processes 
 and those in types 
 in the discussion of the rules for choice in Section 3.
Theorem 3 Well-typed processes are not runtime errors

If , then P is not a runtime error.

Proof

In view of a contradiction, assume that  with P of the form
 
 
 and that 
 with 
. From the typing derivation for P, using T-Par and T-Res, we obtain a context 
 
 with 
 for all  and that 
 and 
 and 
. From the premises of rule T-Choice we know that 
 with 
, and 
 with 
, for some 
 and 
. Given that 
 and 
 have dual types, we know that 
. Assume that 
 (the other case is similar) and that set of labels in 
 is 
. Then, the set of labels for 
 is 
. Subtyping gives 
 and 
. Because the sets of labels are nonempty, there is a label in 
 contradicting the assumption.

When P is  and v is not a variable, the contradiction is with rule T-Out, which can only be applied when the value v is a variable.

When P is

Image 67
and v is not a boolean value, then v must be a variable, but P is typed in the empty context, hence v cannot be a variable. □
In order to prepare for the preservation result we introduce a few lemmas.

Lemma 4 Unrestricted weakening

Let T un.

1.
If , then .

2.
If , then .

3.
If , then .

Proof

Item 1 by rule induction; Items 2 and 3 by mutual rule induction. □

Lemma 5 Preservation for ≡

If  and , then .

Proof

As in Vasconcelos [3, Lemma 7.4] since we share most of the structural congruence axioms. For  use the fact that duality is symmetric (Lemma 1). □

Lemma 6 Substitution

Let 
 and 
.

1.
If 
, then .

2.
If 
, then .

3.
If 
, then .

Proof

Item 1 by rule induction; Items 2 and 3 by mutal rule induction. □

Theorem 7 Preservation

If  and , then .

Proof

By rule induction on the hypothesis on reduction, making use of weakening, preservation for structural congruence, and substitution (Lemma 4, Lemma 5, Lemma 6). We sketch a couple of cases.

When reduction ends with rule R-Par, the premises to rule T-Par (the only rule that applies) read 
 and 
. Then induction gives 
 and we conclude the case with rule T-Par.

When reduction ends with rule R-LinLin, we know that rule T-Res introduces  with  in the context Γ. From there, with applications of T-Par and T-Choice, we have 
 and

Image 100
and
Image 101
and 
. Furthermore, 
 and
Image 102
and 
. From the T-Out rule, 
 and 
. For the y side,
Image 103
and 
. From the T-In rule, 
. We also have that 
 from the duality of T and U. Using the substitution lemma, we get 
. Using T-Par and T-Res we build a derivation for the conclusion of R-LinLin. □
5. Classical session types and the encoding criteria
This section introduces the syntax and semantics of classical session types and the Kouzapas et al. [6] correctness criteria for typed encodings.

5.1. Classical session types
The syntax and semantics of classical session types are in Fig. 10; we follow Vasconcelos [3]. The syntax and the rules for the various judgements extend those of Fig. 1, Fig. 2, Fig. 3, Fig. 4, Fig. 5, Fig. 6, Fig. 7, Fig. 8, Fig. 9, where we remove choice both from grammar productions (for processes and types) and from the various judgements (operational semantics, subtyping, duality, and typing). On what concerns the syntax of processes, the choice construct of Fig. 1 is replaced by new process constructors: output, linear (

Image 76
) and replicated (
Image 77
) input, selection (internal choice) and branching (external choice). The four reduction axioms in Fig. 2 that pertain to choice ( R-LinLin, R-LinUn, R-UnLin, R-UnUn ) are replaced by the three axioms in Fig. 10. Rule R-LinCom describes the output against ephemeral-input interaction, rule R-UnCom the output against replicated-input interaction, and rule R-Case selects a label in the menu at the other channel end.
Fig. 10
Download : Download high-res image (85KB)
Download : Download full-size image
Fig. 10. Classical session types: syntax and reduction.

Typing for classical session types is in Fig. 11. The syntax of types features new constructs—linear and unrestricted input and output, and linear and unrestricted external and internal choice—replacing the choice construct in Fig. 3. The

Image 66
predicate for the classical types is true of
Image 66
qualified types. The
Image 65
predicate is as in mixed choices (Fig. 7). The subtyping and duality rules for the new type constructors are taken from Gay and Hole [20]. The new rules for type equivalence——should be easy to extract from the new syntax in Fig. 11 and are therefore omitted.
Fig. 11
Download : Download high-res image (178KB)
Download : Download full-size image
Fig. 11. Classical session types: typing.

The typing rule for choice in Fig. 9 is replaced by the four typing rules in Fig. 11. All rules but T-OutC are taken verbatim from Vasconcelos [3]. Rule T-OutC increases typability and ensures proper alignment with the translation from mixed sessions to classical sessions discussed in Section 7. Let T be the type

Image 104
, hence
Image 105
. Process  is not typable under context  using the original rule for output [3], but becomes typable with rule T-OutC, as the following derivation shows.
5.2. Minimal encodings
A typed calculus is a five tuple composed of a set of types , a set of processes , a reduction relation → on processes, an equivalence relation ≈ on processes, and a typing relation ⊢. Given two typed calculi 
, , a typed encoding is a pair of maps, one on types 〚〛
, the other on processes 〚〛
. We assume that both calculi include the inaction process 0, parallel composition , scope restriction  and that typing contexts are equipped with a context splitting operation. We denote by ⇒ the reflexive and transitive closure of the reduction relation →. A barb 
 is an observable on an output or selection prefix with subject x in process P [28]. A weak barb 
 is a barb after zero or more reduction steps.

Given two typed calculi 
, and a typed encoding from 
 to 
, we say that the encoding is:

Syntax preserving:
If it is

Homomorphic wrt parallel composition:
If 〚
〛
〚
〛, then 〚〛〚
〛
〚〛〚
〛.

Compositional wrt channel restriction:
If 〚〛
〚〛, then 〚〛
〚〛.

Name invariant:
If 〚〛
〚〛, then 〚〛
〚〛, for any injective renaming of variables σ.

Type sound:
If 
, then 〚〛
〚〛.

Barb preserving:
If 
, then 〚〛
〚〛
.

Operationally complete:
If 
 and 
, then 〚〛
〚
〛.

Operationally sound:
If 〚〛
〚〛 and 〚〛
, then 
 and 
〚
〛.

Minimal:
If it is syntax preserving, barb preserving, and operationally complete.

5.3. The classical and the mixed typed calculi
The mixed typed calculus  is composed of the type language in Fig. 3, the process language in Fig. 1, the reduction relation in Fig. 2, syntactic equality as the equivalence relation, and the typing relation in Fig. 9.

The classical typed calculus  is composed of the type language in Fig. 11, the process language and the reduction relation Fig. 10, the equivalence relation defined below, and the typing relation in Fig. 11.

The behavioural equivalence 
 for classical sessions we are interested in extends structural congruence ≡ with the following rule(C-Equiv ) 
 ◁
 The new rule allows collecting processes that are left by the encoding of non-deterministic choice. We call it extended structural congruence. This equation could be an axiom in a suitable strong bisimulation (cf. Honda [29]), but extended structural congruence suffices for our purposes. It should be easy to see that the axiom preserves typability by choosing a type

Image 107
for channel end x, and that 
 is an equivalence relation, given that ≡ is.
We now turn our attention to barbs. A typed mixed session process P has a barb in x, notation 
, if 
 and

•
 where 
 and 
.

Notice that only types can reveal barbs in processes since internal choice is indistinguishable from external choice at the process level in .
On the other hand, a typed classical session process P has a barb in x, written 
, if 
 and

•
either 
 where 

•
or 
◁ where 
.

Similarly to Kouzapas et al. [6], we consider selections as barbs.
6. Classical sessions as mixed sessions
Input and output types are translated into choice types. For output we arbitrarily pick an external choice (⊕), and conversely for the input. The label in the only branch is

Image 40
in order to match our pick for processes, and the qualifier is read from the incoming type. For classical choices, we read the qualifier and the view from the incoming type. The type of the communication in the branches of the mixed choice is
Image 84
, again so that it matches our pick for processes.
The rest of this section discusses the properties of classical-to-mixed encoding, based on the criteria discussed in Section 5.2.

Theorem 8 Syntax Preservation

The classical-to-mixed encoding is

1.
Homomorphic wrt parallel composition: if 〚
〛
〚
〛, then 〚〛〚
〛
〚〛〚
〛.

2.
Compositional wrt channel restriction: if 〚〛
〚〛, then 〚〛
〚〛.

3.
Name invariant: if 〚〛
〚〛, then 〚〛
〚〛, for any injective renaming of variables σ.

Proof

Items 1 and 2: immediate from the definition of the translation of processes in Fig. 12. Item 3: the encoding transforms each channel in itself, hence is trivially name invariant. □

The type soundness result for the classical-to-mixed encoding is the Item 9 of Theorem 9 below. The remaining items are intermediate results necessary to prove type soundness.

Theorem 9 Type Soundness

1.
If 
, then 〚〛
.

2.
If 
, then 〚〛
.

3.
If , then 〚〛〚〛

4.
If 
, then 〚〛
〚〛.

5.
If 
, then 〚〛〚
〛
〚
〛.

6.
If 
, then 〚〛〚
〛〚〛.

7.
If , then 〚〛〚〛.

8.
If , then 〚〛〚〛.

9.
If 
, then 〚〛
〚〛.

Proof

Item 1: Immediate from Fig. 12; the encoding preserves the qualifiers.

Item 2 By rule induction on the hypothesis using Item 1.

Item 3: By coinduction using the set 〚〛〚〛.

Item 4: By rule induction on the hypothesis, using Items 2 and 3.

Items 5 and 6: By rule induction on the hypothesis.

Item 7: By coinduction using the set 〚〛〚〛.

Item 8: By coinduction using the set 〚〛〚〛 and Item 7.

Item 9: By rule induction on the hypothesis. We sketch a few cases. When the derivation ends with T-InC, we use Item 1, Item 6, and induction. When the derivation ends with T-Branch, we obtain

Image 108
from the induction hypothesis 〚
〛〚
〛〚
〛 using Item 6 and weakening (Lemma 4). □
Theorem 10 Barb Preservation

The typed encoding 〚〛 preserves barbs, that is, if 
, then 〚〛
〚〛
.

Proof

By case analysis for a classical typed barb.

Case 
 where 
. Then,

Image 109
where
Image 110
from type soundness, and 
, which makes 〚〛 a typed mixed barb.
Case 
◁ where 
. Then

Image 111
where
Image 112
and 
, which makes 〚〛 a typed mixed barb. □
Operational correspondence states that the embedding preserves and reflects reduction. In our case, the embedding is quite tight: one reduction step in classical sessions corresponds to one reduction step in mixed sessions. There is no runtime penalty in running classical sessions on a mixed sessions machine. Further notice that we do not rely on any equivalence relation on mixed sessions to establish the result: mixed-sessions images leave no “junk” in the process of simulating classical sessions.

Theorem 11 Operational correspondence

Let P, 
 be classical session processes and Q a mixed session process.

Completeness
If 
, then 〚〛
〚
〛.

Soundness
If 〚〛
, then 
 and 〚
〛, for some 
.

Proof

Straightforward rule induction on the hypotheses, relying on the fact that 〚〛〚〛 and 
 in the translation of ▷
. □

7. Mixed sessions as classical sessions
This section shows that the language of mixed sessions can be embedded in that of classical sessions.

7.1. Motivation
One of the novelties in mixed sessions is the possible presence of duplicated label-polarity pairs in choices. This introduces a form of non-determinism that can be easily captured in classical sessions. Adapted from the non-deterministic summation of Honda [29], the NDChoice classical session process creates a race condition on a new channel with endpoints  featuring multiple selections on the s endpoint, for only one branch on the t endpoint. This guarantees that exactly one of the branches is non-deterministically selected. The remaining selections must eventually be garbage collected. We assume that 
 denotes the process 
 for , and that Π binds tighter than the parallel composition operator.
 ◁
▷

The type of channel end s is

Image 107
. The qualifier must be
Image 66
because s occurs in multiple threads in NDChoice; recursion arises because of the typing rules for processes reading or writing in unrestricted channels.
Equipped with the NDChoice operator we describe the translation of mixed sessions to classical sessions via a few examples, all of which fully type check and run in SePi [10]. To handle duplicated label-polarity pairs in choices, we organize choice processes by label-polarity fragments. Each such fragment represents a part of a choice operation where all possible outcomes have the same label and polarity. When a reduction occurs, one of the branches is taken, non-deterministically, using the NDChoice operator. After a non-deterministic choice of the branch, and depending on the polarity of the fragment, the process continues by either writing on or reading from the original channel.

The translation of choice processes is guided by their types. For each choice we need to know its qualifier (

Image 113
) and its view (), and this information is present in types alone.
In general, an external choice is translated into a classical branching (

Image 118
) over the unique labels of the fragments of the process, but where the polarity of each label is inverted. The internal choice, in turn, is translated as (possibly nondeterministic collection of) classical
Image 119
process but keeps the label polarity. This preserves the behaviour of the original process: in mixed choices, a reduction occurs when a branch  matches against another branch  with the same label but with dual polarity (l! against l?), while in a classical session the labels alone must match (l against l). Needless to say, we could have followed the strategy of dualizing internal choices rather than external.
If we label reduction steps with the names of the channel ends on which they occur, we can see that, in this case a 
 reduction step in mixed sessions is mimicked by a long series of classical reductions, namely 
 
 or 
. Notice the three reductions to resolve non-determinism (on 
) and the two reductions on xy to encode branching followed by message passing, an atomic operation in mixed sessions.

7.2. The mixed-to-classical encoding
The translation of mixed choice processes is in Fig. 17, Fig. 18. Since the translation is guided by the type of the process to be translated, we also provide the typing context to the translation function, hence the notation ⦇⦈. Because label-polarity pairs may be duplicated in choice processes, we organize such processes in label-polarity fragments, so that a process of the form 
 is written as 
  
 
 
 Each label-polarity fragment (
 or 
) groups together branches with the same label and the same polarity. Such fragments may be empty for external choices, for not all label-polarity pairs in an external choice type need to be covered in the corresponding process (internal choice processes do not need to cover all choices offered by the external counterpart). The essence of the translation is discussed in the three examples above.

Fig. 17
Download : Download high-res image (253KB)
Download : Download full-size image
Fig. 17. Translation of mixed choice processes into classical processes (1/2).

Fig. 18
Download : Download high-res image (31KB)
Download : Download full-size image
Fig. 18. Translation of mixed choice processes into classical processes (2/2).

We distinguish six cases for choices, according to qualifiers (

Image 65
or
Image 66
) and views (⊕ or &) in types, but also to the qualifiers (
Image 65
or
Image 66
) in processes. In all of them an NDChoice process takes care of duplicated label-polarity pairs in branches. The six cases cover all possible cases, making the translation function total. Internal choice types feature an extra occurrence of NDChoice to non-deterministically select between output and input on the same label. Notice that external choice must still accept both choices, so that it is not equipped with an NDChoice. Finally, unrestricted processes with unrestricted types require the encoding of a loop, accomplished by creating a new channel for the effect , installing a replicated input—
Image 142
—at one end of the channel, and invoking——the input once to “start” the loop and again at the end of the interaction on channel end x. The contents of the messages are of no interest and so we use the unit value (). However, linear processes with unrestricted types do not require the new channel (uv) to encode a loop. This case is similar to the case with linear types, but uses channel  to enable communication with unrestricted processes.
Following the encoding for types, the encoding for external choice processes exchanges the polarities of choice labels: a label 
 in mixed sessions is translated into 
, and vice-versa, in the cases for

Image 143
and
Image 144
choices. This allows reduction to happen in classical sessions, where we require an exact match between the label of the
Image 119
process and that of the
Image 118
process.
Take for T the type

Image 145
, that is
Image 146
. We can show that
Image 147
. The encoding of this process includes the classical process  as a subterm, which cannot be typed under a linear type with the original T-Out rule [3]. The new T-OutC rule in Fig. 11 allows typing such a process.
7.3. The mixed-to-classical encoding is minimal
This section covers typing and operational correspondences; we aim at a minimal encoding according to the definition in Section 5. The pair of maps ⦇⦈ in Fig. 16, Fig. 17, Fig. 18 constitutes the typed encoding that translates types and processes from  to .

Theorem 12 Syntax Preservation

The mixed-to-classical encoding is

1.
Homomorphic wrt parallel composition: if ⦇
⦈
⦇
⦈, then ⦇⦈⦇
⦈
⦇
⦈⦇
⦈;

2.
Compositional wrt channel restriction: if ⦇⦈
⦇
⦈, then ⦇⦈
⦇
⦈, where ;

3.
Name invariant: if ⦇⦈
⦇
⦈, then ⦇⦈
⦇
⦈, for any injective renaming of variables σ.

Proof

Items 1 and 2: immediate from Fig. 17, Fig. 18. Item 3: our encoding transforms each channel in itself, so is name invariant. □

We now move to type soundness, but before we need to type the NDChoice operator.

Lemma 13

The following is an admissible typing rule for NDChoice.(T-NDChoice )
 

Proof

The typing derivation of the expansion of NDChoice leaves open the derivations for 
 alone. □

The type soundness theorem for the mixed-to-classical encoding is Item 9 of Theorem 14 below; the remaining items help in building the main result.

Theorem 14 Type Soundness

1.
If 
, then ⦇⦈
.

2.
If 
, then ⦇⦈
.

3.
If , then ⦇⦈⦇⦈.

4.
If 
, then ⦇⦈
⦇⦈.

5.
If 
, then ⦇⦈⦇
⦈
⦇
⦈.

6.
If 
, then ⦇⦈⦇
⦈⦇⦈.

7.
If , then ⦇⦈⦇⦈.

8.
If , then ⦇⦈⦇⦈.

9.
If 
, then ⦇⦈
⦇⦈.

Proof

Item 1: By rule induction on the hypothesis.

Item 2: By rule induction on the hypothesis using Item 1.

Item 3: By coinduction using the set ⦇⦈⦇⦈.

Item 4: By case analysis on the hypothesis using Items 2 and 3.

Items 5 and 6: By case analysis on the hypothesis.

Item 7: By coinduction using the set ⦇⦈⦇⦈.

Item 8: By coinduction using the set ⦇⦈⦇⦈ and Item 7.

Item 9: By rule induction on the hypothesis. We sketch a few cases.

Case T-Par. The premises read 
 and 
 and 
. Item 5 and induction give ⦇⦈⦇
⦈⦇
⦈ and ⦇
⦈
⦇⦈ and ⦇
⦈
⦇⦈. Conclude with the T-Par rule for classical processes.

Case T-Choice. The premises read 
 and 
 and 
 and 
 and 
. We distinguish six cases according to Fig. 17, Fig. 18.

Subcase

Image 148
. Then we have
Image 149
and . From 
, the premises to rules T-Out and T-In read 
 and 
 and 
 and 
. Item 4 gives ⦇
⦈
⦇
⦈ and by induction we know ⦇
⦈
⦇
⦈ and also ⦇
⦈
⦇
⦈. We now build a derivation for the conclusion. From the induction hypotheses, using the rules T-OutC and T-NDChoice (Lemma 13), and T-Sel we know that⦇
⦈
◁
⦇
⦈
 Similarly, using rules T-InC, T-NDChoice, and T-Sel we know that and we conclude the case using rule T-NDChoice again.
Subcase

Image 143
. Here we have
Image 151
and . Similarly to the previous case, from the premises of T-Out, T-In and the induction hypothesis, we get ⦇
⦈
⦇
⦈ and ⦇
⦈
⦇
⦈ and ⦇
⦈
⦇
⦈. We build a derivation using T-OutC, T-NDChoice, and obtaining Similarly, using T-InC and T-NDChoice, we obtain We conclude using rule T-Branch.
Subcase

Image 154
,
Image 155
. In this case
Image 156
and . We have Γ un, hence 
. Because the type for x is
Image 66
, in order for 
 to be defined 
 must be equal to
Image 157
, hence of the form
Image 158
. We now proceed as in the subcases above and build the (long) derivation for the classical process using the typing rules (Fig. 11 and Lemma 13). A type for c is
Image 159
and that of d a dual. The type of u is
Image 160
and that of v is dual.
Subcase

Image 144
,
Image 155
. This case is analogous to the previous one, results from a long derivation using the typing rules in Fig. 11 and Lemma 13, but now considering
Image 156
and . The type of x is
Image 161
.
Subcases

Image 162
,
Image 163
. Due to the absence of uv, the derivations for these cases are similar but simpler than those for subcases
Image 162
,
Image 155
. □
The following lemma characterizes the reductions of NDChoice processes: they reduce to one of the choices and leave an inert term G.

Lemma 15

, for any .

Proof

, where 
◁
 and 
. □

The following theorem fulfils the barb preservation criterion: if a mixed process has a barb, its translation has a weak barb on the same channel.

Theorem 16 Barb Preservation

The typed encoding ⦇⦈ preserves barbs, that is, if 
, then ⦇⦈
⦇
⦈
.

Proof

By analysis of the translation of processes with barbs. In the case that x is linear, rearranging the choice in P in fragments, we obtain that

Image 164
and so its translation is
This process makes internal reduction steps in the resolution of the outermost NDChoice, non-deterministically choosing one of the possible fragments, via Lemma 15. However, independently of which branch is chosen, they are all of the form ◁, which has a barb in x. That is: ⦇⦈
◁⦇
⦈, which has a barb in x. The G term is the inert remainder of the NDChoice reduction. In the unrestricted case, we have

Image 166
. So, The process starts by reducing via R-UnCom on the  channels to the process where U is the persistent part of the unrestricted process. This process, in turn, reduces via the NDChoice (Lemma 15) to one of the possible branches which are all of the form ,⦇⦈
⦇
⦈ Since P has a barb in x, 
 and so this process also has a barb in x, concluding that ⦇⦈ has indeed a weak barb in x. □
We now address operational completeness. Operational completeness relates the behaviour of mixed sessions against their classical sessions images: any reduction step in mixed sessions can be mimicked by a sequence of reductions steps in classical sessions, modulo extended structural congruence. The ghost reductions result from the new channels and communication inserted by the translation, namely those due to the NDChoice and to the encoding of “loops” for

Image 66
mixed choices.
Theorem 17 Operational completeness

The typed encoding ⦇⦈ is operationally complete, that is, if 
, then ⦇⦈
⦇
⦈.

Proof

By rule induction on the derivation of 
. We detail a few cases.

Case R-Par. We have ⦇
⦈⦇
⦈⦇
⦈ with 
. By induction we have ⦇
⦈
⦇
⦈. Using rule R-Par and the fact that 
 is a congruence, we get ⦇
⦈⦇
⦈
⦇
⦈
⦇
⦈⦇
⦈⦇
⦈. The cases for R-Res and R-Struct are similar.

Case R-LinLin. Considering 
 with

Image 169
and
Image 170
, and 
, and using the definition of the translation on
Image 171
, we get By a sequence of applications of the rules R-Case, C-Equiv, and R-LinCom, we obtain⦇
⦈⦇
⦈⦇
⦈ where 
 and 
 and 
 and 
. Notice that 
 where 
 is
Image 66
, hence 
 is in 
. The same reasoning applies to 
. Since context 
 is used to type v, the substitution lemma [3] reintroduces it in the context for . Applying the definition of the translation, we conclude that translation of the original mixed process reduces to ⦇⦈.
The case for R-UnUn is similar, albeit more verbose.

Case R-UnLin. Using the definition of the translation for the ν constructor, we know that the process

Image 173
translates to
Image 174
, where . Then, U is of the form
Image 175
and
Image 176
. We are then reduced to the translation rules in Fig. 17. Using the rule R-UnCom to reduce u and v in the translation of
Image 177
, and applying the rules R-Case, C-Equiv, and R-LinCom, we obtain
The case for R-LinUn is similar.

The cases for R-IfT and R-IfF are direct. □

We can show that the translation does not enjoy reduction soundness. Consider the classical process Q to be the encoding of process P of the form

Image 179
, described in the right part of Fig. 15. Soundness requires that if 
, then 
 and 
⦇
⦈. Clearly, Q has an initial reduction step (on channel 
), which cannot be mimicked by P. But this reduction is a transition internal to process Q. Equipped with a suitable notion of weak bisimulation that ignores internal transitions, we expect soundness to hold.
8. What is in the way of a compiler?
This section discusses algorithmic type checking and the implementation of choice in message passing architectures.

We start with type checking and then move to the runtime system. Gay and Hole present an algorithmic subtyping system for classical sessions [20]. Algorithmic subtyping for mixed sessions can be obtained by adapting the rules in Gay and Hole. T-Sub is the only non syntax-directed rule in Fig. 9. We delete this rule and distribute subtype checking among all rules that use, in their premises, sequents , as usual. Most of the rules include a non-deterministic context split operation. Take rule T-Par, for example. Rather than guessing the right split, we take the incoming context and give it all to process P, later reclaiming the unused part. This outgoing context is then passed to process Q. The outgoing context of the parallel composition  is that of Q. See, e.g., Vasconcelos or Walker for details [3], [21]. Rule T-Res requires guessing the type of the two channel ends, so that one is dual to the other. Rather than guessing the type of channel end x, we seek the help of the programmer by working with an explicitly typed syntax——as in Franco and Vasconcelos [3], [10], where T refers to the type of channel end x. For the type of channel end y, rather than guessing, we build it from type T; cf. [16], [17], [19], [30].

Running mixed sessions on a message passing architecture need not be an expensive operation. Take one of the communication axioms in Fig. 2. We set up a broker process that receives the label-polarity pairs of both processes (
 and 
), decides on a matching pair (guaranteed to exist for typed processes), and communicates the result back to the two processes. The processes then exchange the appropriate value, and proceed. If the broker is an independent process, then we exchange five messages per choice synchronisation. This basic broker is instantiated for two processes in Fig. 19a.

Fig. 19
Download : Download high-res image (43KB)
Download : Download full-size image
Fig. 19. Broker is an independent process.

We can do better by piggybacking the values in the output choices together with the label-polarities pairs. The broker passes its decision to the input side in the form of a triple label-polarity-value, yielding one less message exchanged, as showcased in Fig. 19b.

Finally, we observe that the broker need not be an independent process; it can be located at one of the choice processes. This reduces the number of messages down to two messages in the general case, as described in Figs. 20a and 20b where either P is the broker or Q is the broker. Even if the value was already sent by Q in the case that P is the broker, P must still let Q know which choice was taken, so that Q may proceed with the appropriate branch.

Fig. 20
Download : Download high-res image (20KB)
Download : Download full-size image
Fig. 20. Broker is P or Q.

However, in particular cases one message may be enough. Take, for instance a process

Image 181
. Independently of which branch is taken, the process proceeds as 
. Thus, if the broker is located in a process Q, then P needs not be informed of the selected choice. The same is true for classical sessions where selection is a mixed-out choice of a single branch.
There are two other aspects that one should discuss when implementing mixed sessions on a message passing architecture other than the number of messages exchanged.

The first is related the type of broker used and to which values are revealed in a choice to the other party. In the case of the basic broker, only the chosen option value is revealed, and never to the broker itself. However, when we piggyback the values in the second type of broker, all values in the choice branches are revealed to the broker, even if they are not used in the end. This is even more striking in the case where one of the processes is the broker—the other party has access to all the possible values, independently of the choice that is taken.

The second aspect is also related to the values themselves which, in order to be presented in the choice, values must be computed a priori, even if they are not used in the choice. When dealing with the privacy of the values, we can choose which type of broker to use depending on how much we want to reveal to the other party.

9. Related work
The origin of choice  Free (completely unrestricted) choice is central to process algebras, including BPA and CCS [31], [32]. Here we usually find processes of the form , where P and Q are arbitrary process. Free choice is also present in the very first proposal of the π-calculus [13], [14], even if Milner later uses guarded choice [33]. Sangiorgi and Walker's book builds on the pi-calculus with guarded (mixed) choice [34]. Guarded choices in all preceding proposals operate on possibly distinct channels—

Image 182
— whereas choices on mixed sessions run on a common channel—
Image 183
.
Labelled-choices were embedded in the theory of session types by Honda et al. [2], [35], [36], where one finds primitives for value passing—

Image 184
and —and, separately, for choice in the form of labelled selection—◁—and branching—▷
—see Section 5.1. Coalescing label selection with output and branching with input was proposed by Vasconcelos [37] (and later used by Sangiorgi [38]) as a means to describe concurrent objects. Demangeon and Honda use a similar language to study embeddings of calculi for functions and for session-based communication [39]. All these languages offer only separated (unmixed) choices and only on the input side.
Choices and labels  In process algebras choices are usually guarded by channels. For example, the interprocess communication rule for the pi-calculus, as in Sangiorgi and Walker [34] is
 where x denotes a channel and 
 and 
 denote sums of prefixed processes (each of the form  or ). When one moves to algebras ruled by session types, labelled-prefixed choices are instead the norm, even if one can think of distilled choices in the form of (unlabelled) binary choice as in Caires et al. [24]. Labelled (n-ary) choices, as introduced by Honda et al. [2], [36], provide a better programming experience, in the same way that labelled sums (or variants) offer extra flexibility with respect to binary sums in functional programming.

Labels in mixed choice take a different flavour. To start with, they do not constitute keys to choices when seen as maps. Instead, labels in mixed choices are always paired with polarities and thus the obtained pairs are keys to type choices (but not to process choices), again for extra programming flexibility. Duplicated label-polarity choices in processes allow for controlled non-determinism and is much in line with the process algebra approach embodied by the above reduction rule, where channel x may prefix processes in 
 or 
.

As in the pi calculus, mixed choice process are not endowed with a “point of view”: a choice is simply a choice. Communication safety (Theorem 3) however requires typed processes to take a view: internal or external (thus precluding unicity of types). Once classified, all options in the internal side must be included in the options of the external side. This is in clear contrast with the pi calculus, where choices such as 
 and 
 above may not have channels in common.

Mixed choices in the singularity operating system  Concrete syntax apart, the language of linear mixed choices is quite similar to that of channel contracts in Sing♯ [40]. Rather than explicit recursive types, Sing♯ contracts uses named states (akin to typestates [41]), providing for more legible contracts. In Sing♯, each state in a contract corresponds to a mixed session

Image 185
(contracts are always written from the consumer side) where each 
 denotes a message tag, ⋆ the message direction (! or ?), 
 the type of the value in the message, and 
 the next state.
Stengel and Bultan showed that processes that follow Sing♯ contracts can engage in communication errors [42]. They further provide a realizability condition for contracts that essentially rules out mixed choices. Bono and Padovani present a calculus and a type system that models Sing♯ [17], [43]. The type system ensures that well-typed processes are exempt from communication errors, but the language of types excludes mixed-choices. So it seems that Sing♯-like languages only function properly under separated choice, yet our work survives under mixed choices. Contradiction? No! Sing♯ features asynchronous (or buffered) semantics whereas mixed sessions run under synchronous semantics. The operational semantics makes all the difference in this case.

Synchronicity, asynchronicity, and choice  Pierce and Turner identified the problem: “In an asynchronous language guarded choice should be restricted still further since an asynchronous output in a choice is sensitive to buffering” [9] and Peters et al. state that “a discussion on synchrony versus asynchrony cannot be separated from a discussion on choice” [44], [45]. Based on classical sessions, mixed sessions are naturally synchronous. The naive introduction of an asynchronous semantics would ruin the main results of the language (see Section 4). Asynchronous semantics are known to be compatible with classical sessions; see Honda et al. [46], [47] for multiparty asynchronous session types and Fowler et al. [48] and Gay and Vasconcelos [1] for two examples of functional languages with session types and asynchronous semantics. So one can ask whether a language can be designed where mixed-choices are handled synchronously and separated-choices asynchronously, where a type-guided operational semantics with by-default asynchronous semantics reverts to a synchronous semantics when in presence of mixed-choices.

Separation results  Palamidessi shows that the π-calculus with mixed choice is more expressive than its subset with separated choice [49]. Gorla provides a simpler proof [50] of the same result and Peters and Nestmann analyse the problem from the perspective of breaking initial symmetries in separated-choice processes [51]. Unlike the choices in both π-calculus with mixed and separated choice, choices in mixed sessions operate on the same channel and are guided by types. In particular, there is a communication safety property enforced by the type system in which all the options of the internal side must be included into the options of the external side. Another difference to these separation results is that our translation from mixed to classical sessions is guided by the type of the process. Due to the simple syntax of mixed sessions, we can write a process which translates to different classical sessions processes, depending on its type. A process of the form  where P is and σ a substitution of x by y, would in principle be a symmetric network which elects a leader as in [51]. However, its translation will not be symmetric as one of P or  will be the external choice and the other the internal. One may ask if we could make the translation to classical sessions independent of the type of the process, for instance, by annotating the type information at the syntax level (e.g., writing ⊕ and & explicitly in processes). From the viewpoint of usability and software-engineering, processes would be harder to write and code reuse made difficult. On the other hand, translation from such a syntax would be closer to that of Peters and Nestmann [51]. This is a direction to be explored in the future.

The origin of mixed sessions  Mixed sessions dawned on us when looking into an algorithm to decide the equivalence of context-free session types [52], [53]. The algorithm translates types into (simple) context-free grammars. The decision procedure runs on arbitrary simple grammars: the right-hand sides of grammar productions may start with a label-output or a label-input pair for the same non-terminal symbol at the left of the production. We then decided to explore mixed sessions and picked the simplest possible language for the effect: the π-calculus. It would be interesting to look into mixed context-free session types, given that decidability of type equivalence is guaranteed.

10. Conclusion
We introduce mixed sessions: session types with mixed choice. Classical session types feature separated choices; in fact all the proposals in the literature we are aware of provide for choice on the input side only, even if we can easily think of choice on the output side. In contrast to separated choices, where output operations are inherently associated with the endpoint that initiates the communication, mixed choices allow to unfasten this association. Mixed sessions increase flexibility in programming and are easily realisable in conventional message passing architectures.

Mixed choices come with a type system featuring subtyping. Typability is preserved by reduction. Furthermore well-typed programs are exempt from runtime errors. We provide suggestions on how to derive a type checking procedure, even if we do not formalise one.

Classical session types can be embedded in mixed sessions: we provide for an encoding and show typing and operational correspondences. Conversely, mixed sessions can be encoded into classical session types: we present an encoding and show that it is minimal, according to the criteria of Kouzapas et al. [6].

An interesting avenue for further development is looking for a suitable notion of weak bisimulation for mixed choices in such a way that the mixed-to-classical encoding may enjoy reduction soundness. Another looks for a hybrid type-guided semantics, asynchronous by default, that reverts to synchronous when in presence of an output choice.

The generalisation of mixed choices to the multiparty setting is also an interesting topic to be explored. The multiparty session types programme has global types projected onto diverse binary session types, each describing the behaviour of one particular participant. So, one could think of developing mixed-session global types to be projected into the types proposed in this paper.

Mixed sessions are not exempt from deadlocks (see Section 4). There are different approaches to ensure the absence of deadlocks in session-based systems. One is to start from global types, an avenue discussed in the previous paragraph. Another approach is to look into extensions of the linear logic interpretations of session types [24], [27] but that may raise difficulties at the level of the logic. A third possibility is to look into type systems that capture some form dependency between actions (see [54, Chapter 7]).