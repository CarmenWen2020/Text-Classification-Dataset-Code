Abstract
After two decades of research on signcryption, recently a new cryptographic primitive, named higncryption, was proposed at ACM CCS'16. Higncryption can be viewed as privacy-enhanced signcryption, which integrates public key encryption, digital signature and identity concealment (which is not achieved in signcryption) into a monolithic primitive. Here, identity concealment means that the transcript of protocol runs should not leak participants' identity information.

In this work, we propose the first identity-based higncryption (IBHigncryption, for short). We present the formal security model for IBHigncryption, under which security proof of the proposed scheme is conducted. The most impressive feature of IBHigncryption, besides other desirable properties it offers, is its simplicity and efficiency, which might be somewhat surprising in retrospect. Our IBHigncryption has a much simpler setup stage with smaller public parameters and particularly no need of computing master public key. It is essentially as efficient as (if not more than) the fundamental CCA-secure Boneh-Franklin identity-based encryption scheme [14], and has significant efficiency advantage over the IEEE 1363.3 standard of identity-based signcryption [8].

Keywords
Identity-based cryptography
Signcryption
Identity-concealment
Higncryption

1. Introduction
Identity-based cryptography (-based) was proposed by Shamir in 1984 [47], with the motivation to simplify certificate management in traditional public-key cryptography. In an -based cryptosystem, the identity of a user acts as its public key, so the certificate issuance and management problem is simplified in an -based system. In general, -based cryptography includes identity-based signature (IBS), identity-based encryption (IBE), etc. -based signature schemes appeared much earlier [24], [23]. However, the first practical and fully functional identity-based encryption scheme was only proposed by Boneh and Franklin [14] in 2001 based on bilinear maps. The Boneh-Franklin's IBE scheme is further standardized with ISO/IEC 18033-5 and IETF RFC 5091 [15], and is now widely deployed (e.g., in HPE Secure Data by Voltage security [4]).1

The concept of signcryption was proposed by Zheng [50]. It enables the sender to send an encrypted message such that only the intended receiver can decrypt it, and meanwhile, the intended receiver has the ability to authenticate that the message is indeed from the specified sender. It provides a more economical and safer way to integrate encryption and signature (compared to sequential composition). Since its introduction, research and development (including international standardizations) of signcryption have been vigorous. For example, a list of public-key signcryption schemes was standardized in ISO 29150, and a pairing-based -based signcryption scheme [8] was adopted as IEEE P1363.3 standard.

With signcryption, the sender's identity information has to be exposed, as otherwise, the ciphertext cannot be decrypted and the message cannot be verified. However, identity is a fundamental privacy concern, and identity confidentiality is now mandated by a list of prominent standards such as TLS1.3 [43], QUIC [45], EMV [16], and the 5G telecommunication standard [2] by 3GPP (the 3rd Generation Partnership Project), etc. Under this motivation, Zhao [49] introduced a new cryptographic primitive called identity-hiding signcryption (higncryption, for short). Higncryption can be viewed as a novel monolithic integration of public key encryption, digital signature, and identity concealment. Here, identity concealment means that the transcript of protocol runs should not leak participants' identity information. Moreover, a higncryption scheme satisfies the following features simultaneously:

–
Forward -privacy, which means that player's -privacy preserves even when its static secret-key is compromised.

–
Receiver deniability [30], in the sense that the session transcript can be simulated from the public parameters and the receiver's secret-key.

–
x-security [30], in the sense that the leakage of some critical intermediate randomness (specifically, -exponent x) does not cause the exposure of the sender's static secret-key or the pre-shared secret (from which session-key is derived).

We note that the work in [49] only considered higncryption in the traditional public-key setting. In this work, we study identity-based highcryption and its applications.

1.1. Motivation and application scenarios
5G is the fifth generation of cellular mobile communication, which succeeds the 4G (LTE/Wi-Max), 3G (UMTS) and 2G (GSM) systems. 5G performance targets include high data rate, reduced latency, and massive device connectivity (for low-power sensors and smart devices), which are far beyond the levels 4G technologies can achieve. Among the services 5G supported, mission critical services and communications require ultra reliability and virtual zero latency. The platform for mission critical (MC) communications and MC Services has been a key priority of 3GPP in recent years and is expected to evolve further in the future [36]. In June 2018, 3GPP has identified the following essential requirements related to user privacy [1], [34] for 5G communications.

–
User identity confidentiality: The permanent identity of a user to whom a service is delivered cannot be eavesdropped on the radio access link.

–
User untraceability: An intruder cannot deduce whether different services are delivered to the same user by eavesdropping on the radio access link.

–
User location confidentiality: The presence or the arrival of a user in a certain area cannot be determined by eavesdropping on the radio access link.

At the heart of the security architecture specified by 3GPP [2] is an identity-based authenticated key transport (IB-AKT) protocol inherited from 4G, which is the identity-based version of Multimedia Internet KEYing (MIKEY) specified in IETF RFC 3830 [32]. This IB-AKT protocol involves the sequential composition of an identity-based encryption scheme (i.e., SAKKE specified in IETF RFC 6508 [29] and 6509 [28]) and an identity-based signature scheme (i.e., ECCSI specified in IETF RFC 6507 [27]). In MIKEY-SAKKE, the user's identity  takes the form of a constrained “tel” URI, in front of “tel” URI is a monthly-updated timestamp for refreshing the key of the user periodically. It also provides a mechanism with identity privacy, but this mechanism is too simple. Concretely, in MIKEY-SAKKE with identity hiding, a user's URI is replaced by its , which is generated by hashing the user's related strings [3]. Further, UID shall be used as the identifier within MIKEY-SAKKE with identity hiding. Clearly, MIKEY-SAKKE does not satisfy the above requirements on identity privacy mandated by 5G now.

Considering that the sequential composition of an identity-based encryption scheme and an identity-based signature scheme is less efficient, signcryption may be a candidate for the service. We note that there already has been IEEE P1363.3 standard for -based signcryption [8]. However, as mentioned ahead, the sender's identity information has to be exposed with signcryption. In this sense, -based identity-concealed signcryption takes place. Moreover, for enhancing privacy and strengthening security, forward -privacy, receiver deniability, and x-security are all desirable in such settings. This is just our motivation for developing -based identity-concealed signcryption ().

Fig. 1 illustrates the application of  in MIKEY-based mission critical communications. If Alice (the session initiator) wants to make a private call to Bob (the session receiver), she  s her request and her identity using her private key generated by the public key generator (PKG) on her public identity, and then sends it to Bob via internet or wireless channel. On receiving Alice's request, Bob  s the ciphertext, and gets Alice's request and her identity information. By verifying the message decrypted (which is equivalent to verification of Alice's signature), Bob can determine whether the request is indeed from Alice. Based on the verification, Bob can choose whether he accepts the session. Meanwhile, if there is an authority who needs to intercept the communications between Alice and Bob, it contacts PKG to request the private key of Bob, with which the authority can inspect the session lawfully.

Fig. 1
Download : Download high-res image (168KB)
Download : Download full-size image
Fig. 1. 's Application in 4G-LTE.

1.2. Our contribution
In this work, we propose the first identity-based higncryption (, for short). We present the formal security model for , under which the security proof of the proposed scheme is conducted. The most impressive feature of , among others (including the desirable properties it offers, such as forward -privacy, receiver deniability, and x-security), is its simplicity and efficiency, which might be somewhat surprising in retrospect. Specifically, our  has a much simpler setup stage with smaller public parameters, which in particular does not need to generate the traditional master public key. The implementation of our  is provided, with source code available from Github.

The proposed  scheme is essentially as efficient as (if not more than) the fundamental CCA-secure Boneh-Franklin IBE scheme [14], while offering entity authentication and identity concealment simultaneously. Compared to the identity-based signcryption scheme [8], which is adopted as IEEE P1363.3 standard, our generalized construction of  (when implemented on asymmetric bilinear groups) is much simpler, and has significant efficiency advantage in total (particularly on the receiver side). Besides, our generalized  enjoys forward -privacy, receiver deniability and x-security simultaneously, while the IEEE 1363.3 standard of -based signcryption satisfies none of them.

IMPLEMENTATION for TYPE 1 and 3. We implement the  scheme for pairings of Type 1 and 3, where the codes are (anonymously) available from https://github.com/IBHigncryption2018/IBHigncryption. The implementations use the PBC (pairing-based cryptography) library of Stanford University http://crypto.stanford.edu/pbc, and the underlying authenticated encryption is implemented with AES-GCM-256.

2. Preliminaries
2.1. Notations
If S is a finite set,  is its cardinality, and  is the operation of picking an element uniformly at random from S. If S denotes a probability distribution,  is the operation of picking an element according to S. We overload the notion for probabilistic or stateful algorithms, where  means that algorithm  runs and outputs value V. A string or value α means a binary number, and  denotes its length. Let  denote a simple assignment statement, which means assigning b to a, and  is the concatenation of two elements 
⁎
.

2.2. Authenticated encryption
Briefly speaking, an authenticated encryption (AE) scheme transforms a message M and a public header information H (e.g., a packet header, an IP address, some predetermined nonce or initial vector) into a ciphertext C in such a way that C provides both privacy (of M) and authenticity (of C and H) [10], [44], [35]. In practice, when AE is used within cryptographic systems, the associated data H is usually implicitly determined from the context (e.g., the hash of the transcript of the protocol run or some pre-determined states).

Let 
 be a symmetric encryption scheme. The probabilistic polynomial-time () algorithm 
 takes the security parameter κ as input and samples a key K from a finite and non-empty set 
. For presentation simplicity, we assume 
. The polynomial-time (randomized or stateful)2 encryption algorithm 
⁎
⁎
⁎
, and the (deterministic) polynomial-time decryption algorithm 
⁎
⁎
 satisfy: for any , any associated data 
⁎
 and any message 
⁎
, if 
 outputs , 
 always outputs M. Here, for presentation simplicity, we assume that the ciphertext C bears the associated data H in plain.

Let  be an adversary. Table 1 describes the security game for authenticated encryption. We define the advantage of  to be
 We say that the  scheme is AE-secure, if for any sufficiently large κ, the advantage of any probabilistic polynomial-time () algorithm adversary is negligible.


Table 1. AEAD security game.



The above AE definition is based on that given in [10], but with the public header data H explicitly taken into account. The definition of authenticated encryption with associated data (AEAD) given in [35] is stronger than ours in that: (1) it is length-hiding; and (2) both the encryption and the decryption algorithms are stateful.

The above AE security is quite strong. In particular, it means that, after adaptively seeing a polynomial number of ciphertexts, an efficient adversary is unable to generate a new valid ciphertext in the sense that its decryption is not “⊥”. Also, for two independent keys 
 and any message M and any header information H, 
 is negligible.

3. Bilinear pairings, and hard problems
Definition 1

Bilinear paring [46], [14]
Let 
 and 
 be three multiplicative groups of the same prime order q, and let 
 be generators of 
 and 
, respectively. Assume that the discrete logarithm problems in 
 and 
 are intractable. We say that 
 is an admissible bilinear pairing, if it satisfies the following properties:

1.
Bilinear: For all 
⁎
, 
 = 
.

2.
Non-degenerate: For each 
, there exists 
, such that 
.

3.
Computable: For all 
, 
 is efficiently computable.

Bilinear pairings are powerful mathematical tools for numerous cryptographic applications (e.g., [14], [12], [13], [8], [40], [19], [33], [9], [22], [31], [37], [11]). Generally, there are three types of bilinear pairing [26], [48], [17], [18], [42]:

Type 1:
, it is also called symmetric bilinear pairing.

Type 2:
There is an efficiently computable isomorphism either from 
 to 
 or from 
 to 
.

Type 3:
There exists no efficiently computable isomorphism between 
 and 
.

A brief history of pairings is presented in [6]. In recent years, much progress on number field sieve (NFS) has been made against pairing-friendly curves, which imposes new estimation of the security of parings. The reader is referred to [7] for updated key size estimation of some popular pairing-friendly curves (e.g., BN, BLS, KSS).

The computationally intractable problems considered in this work are defined as follows, which are described w.r.t. Type 1 pairings for presentation simplicity. Let 
 be two multiplicative groups of the same prime order q, g be a generator of 
, 
 be an admissible symmetric bilinear pairing.

Definition 2

Bilinear Diffie-Hellman ()
The bilinear Diffie-Hellman () problem [38] in 
 is to compute 
, given 
, where 
⁎
. The  assumption says that no PPT algorithm can solve the  problem with non-negligible probability.

Definition 3

Square bilinear Diffie-Hellman ()
The square bilinear Diffie-Hellman () problem in 
 is to compute 
, given 
, where 
⁎
. The  assumption says that no PPT algorithm can solve the  problem with non-negligible probability.

Below, we show that the  assumption is equivalent to the  assumption. To the best of our knowledge, the equivalence between the two problems is first proved in this work, which might be of independent interest.

Proposition 1

Let 
⁎
. Then the statistical distance between  and z is just 
 
.

Proof

For presentation simplicity, we omit the modular arithmetic. Firstly, we consider the distribution of . There are two cases to consider. For any 
, (1) if , then 
⁎
 
; (2) if , then 
⁎
 
 
 
. Therefore the statistical distance between  and z is:
 
 
 
 
 
 
 
 
 
 
 
 
 □

Theorem 1

The  assumption and the  assumption are equivalent.

Proof

:

Suppose that there is an oracle 
, which, on input (
, 
, 
) 
, outputs 
 with non-negligible probability. Then, there must exist a PPT algorithm 
, which, on input 
, outputs 
 with the same probability. The algorithm 
 chooses 
⁎
, and computes 
, 
. Therefore, 
 is able to compute 
. It follows that 
 can be computed from 
 immediately with the same advantage.

:

Suppose that there is an oracle 
, which, on input (g, 
, 
) 
, outputs 
 with non-negligible probability ϵ, where 
⁎
. Then, we show that there exists a PPT algorithm 
, which, on input 
, outputs 
 also with non-negligible probability. The algorithm 
 chooses 
⁎
, and by querying the oracle 
, 
 gets the following values with probability 
: 
, and 
 = 
. Finally, 
 gets 
 = 
 from which 
 can be computed as  are known already, with probability at least 
 
 according to Proposition 1; Specifically, the statistical distance between  and the uniform distribution over 
⁎
 is 
 
. We conclude that, with probability at least 
 
, 
 can solve the BDH problem. □

Definition 4

Gap bilinear Diffie-Hellman ()
The gap bilinear Diffie-Hellman () problem [38], [5] is to compute 
, given 
, where 
⁎
, but with the help of a decisional bilinear Diffie-Hellman () oracle for 
 and 
. Here, on arbitrary input 
, the  oracle outputs 1 if and only if 
. The  assumption says that no PPT algorithm can solve the  problem with non-negligible probability.

Definition 5 Gap square bilinear Diffie-Hellman

The gap square bilinear Diffie-Hellman () problem is to compute 
, given 
, where 
⁎
, but with the help of a decisional bilinear Diffie-Hellman () oracle for 
 and 
. Here, on arbitrary input 
, the  oracle outputs 1 if and only if 
. The  assumption says that no PPT algorithm can solve the  problem with non-negligible probability.

Clearly, by Theorem 1, the  assumption and the  assumption are equivalent.
4. Identity-based higncryption: definition and security model
4.1. Definition of IBHigncryption
In an identity-based identity-concealed signcryption scheme () (denoted by ), there is a private key generator (PKG) who is responsible for the generation of private keys for the users in the system. The PKG computes the private key for each user using its master secret key on the user's public identity. Next, we give the formal definition of an .

Definition 6

An  scheme  with associated data, consists of the following four polynomial-time algorithms: , and .

–
: The algorithm is run by the PKG. On input of the security parameter κ, it outputs the system's common parameters  and the master secret key . Finally, the PKG outputs , and it keeps the master secret key  in private. We assume that the security parameter and an admissible identity space  are always (implicitly) encoded in .

–
: On input of the system's public parameters , the master secret key  of the PKG, and a user's identity , the PKG computes and outputs the private key sk of  using  if . The public identity and its private key are for algorithm  and algorithm  respectively.

–
: It is a  algorithm. On input of the system's public parameters , a sender's private key 
, and his public identity 
, a receiver's public identity 
, a message 
⁎
 and its associated data 
⁎
 to be , it outputs an  
⁎
, or ⊥ indicating 's failure. The associated data H, if there is any, appears in clear in the  C, when .

–
: It is a deterministic algorithm. On input of the system's public parameters , the receiver's private key 
, the receiver's public identity 
, and an  C, it outputs 
 if the verification is successful, or ⊥ indicating an error, where 
 is the sender's public identity, and 
⁎
 is the message  by 
. It is different from the traditional identity-based signcryption in that  does not need to take the sender's public identity 
 as input.

Definition 7 Correctness

We say an  scheme  is correct, if for any sufficiently large security parameter κ, any key pairs 
, and 
, where 
 and 
 are output by  on 
 and 
 respectively, it holds that  (
, 
,  (, 
, 
, 
, H,  = 
 for any 
⁎
 such that

.

Definition 8 Receiver deniability

We say that an  scheme  has receiver deniability, if the same  can be generated either by the sender or the receiver. Specifically, there exists a PPT algorithm 
, satisfying: the output of 
 has the same distribution as that of 
, for any security parameter κ, any 
⁎
, and any key pairs 
 and 
 where 
 and 
 are output by  on 
 and 
 respectively.

Remark 1

Deniability has always been a central privacy concern in personal and business communications, with off-the-record communication serving as an essential social and political tool [21]. Given that many of these interactions now happen over digital media (e.g., email, instant messaging, web transactions, virtual private networks), it is critically important to provide these communications with “off-the-record” or deniability capability to protocol participants.3 For these applications, we may only concern about the authentication of the communication, and less care about the non-repudiation of the communication.

4.2. Security model for IBHigncryption
We focus on the security model for  in the multi-user environment, where each user possesses a single key pair for both  and , and the sender can  messages to itself. Our security model is stronger than that of an identity-based signcryption, since it allows the adversaries to access more oracles.

The private keys of all the users in the system are generated by the challenger by running the specified key generation algorithm. All the users' public identities are given to the adversary initially. Throughout this work, denote by 
, the public identity of user i, and denote by 
 (resp., 
) the public identity of the sender (resp., the receiver). For presentation simplicity, throughout this work we assume that all the users in the system have public identity information of equal length. But our security model and protocol construction can be extended to the general case of different lengths of identities, by incorporating length-hiding authenticated encryption [39] in the underlying security model and protocol construction.

The security of an  includes two parts: outsider unforgeability (OU) and insider confidentiality (IC). In order to formally define the above security, we introduce two types of adversaries in our system, one is called OU-adversary, 
, and the other is called IC-adversary, 
. The goal of an 
 is to forge a valid  on behalf of an uncorrupted sender 
⁎
 to an uncorrupted receiver 
⁎
, where 
⁎
 may be equal to 
⁎
. The goal of an 
 adversary is to break the confidentiality of the message or the privacy of the sender's identity for any  from any (even corrupted) sender to any uncorrupted receiver, even if 
 is allowed to corrupt the sender and to expose the intermediate randomness used for generating other  s. Likewise, here the sender may be equal to the receiver. The terminology “insider” (resp., “outsider”), which is traditional in this literature, refers to the situation that the target sender can (resp., cannot) be corrupted.

Now, we describe the oracles to which 
 or 
 gets access in our security model for .

–
: This oracle is used to respond to the  queries made by an adversary, including 
 or 
. On input 
 by an adversary, where 
 may be equal to 
, and 
⁎
, this oracle returns C=  (, 
, 
, 
, H, M) to the adversary. In order to respond to some  queries against C by the adversary, the  needs to store some specified offline-computable intermediate randomness (which is used in generating C) into an initially empty table 
 privately.

–
: This oracle is used to respond to the  queries made by an adversary, including 
 or 
. On input 
 by an adversary, this oracle returns 
 to the adversary, where 
 is the private key of the receiver 
.

–
: This oracle is used to respond to the intermediate randomness used in generating an  of an earlier  query. It is an additional oracle in our security model that makes our security stronger than the traditional security for signcryption; This feature is considered and named as x-security in [30]. On input an  C, this oracle returns the value (i.e., the offline-computable intermediate randomness used in generating C) stored in the table 
, if  and C was an output of an earlier  query. If there is no such a record in 
, this oracle returns ⊥ to the adversary.

–
: This oracle is used to respond to the private key queries for any user in the system. On input a user's identity 
, this oracle returns the private key 
, and 
 is then marked as a corrupted user. Denote by 
 the set of corrupted users in the system, which is initially empty. This oracle updates 
 with 
 whenever the private key of 
 is returned to the adversary.

Next, we describe the security games for insider confidentiality (IC) and outsider unforgeability (OU).

Definition 9 Insider Confidentiality (IC)

Let 
 be an IC-adversary against . We consider the following game, denoted by 
, in which an adversary 
 interacts with a challenger .

–
: The challenger  runs  to generate the system public parameters  and a master secret key . The challenger returns  to the adversary 
, and keeps the  secretly for itself.

–
: In this phase, 
 issues any polynomial number of queries, including , , , and .

–
: At the end of , 
 selects in the identity space  two different target senders, 
⁎
 and 
⁎
, and an uncorrupted target receiver 
⁎
, a pair of messages 
⁎
⁎
 of equal length from the message space, and associated data 
⁎
. 
 submits 
⁎
⁎
, 
⁎
, and 
⁎
⁎
⁎
 to the challenger .

The challenger  chooses , and gives the challenge 
⁎
⁎
⁎
⁎
⁎
⁎
 to the adversary 
. Here, we stress that there is no restriction on selecting the target senders 
⁎
 and 
⁎
. It implies that both target senders can be corrupted, which captures forward -privacy; And either one of the target senders can be the target receiver (i.e., it may be the case that 
⁎
⁎
).

–
: 
 continues to make queries as in  with the following restrictions:

1.
 is not allowed to issue 
⁎
.

2.
 is not allowed to issue 
⁎
⁎
.

3.
 is not allowed to issue 
⁎
.

–
: Finally, 
 outputs 
 as his guess of the random bit σ. 
 wins the game if 
.

With respect to the above security game 
, we define the advantage of an 
 adversary in 
 as:
 We say that an  scheme  has insider confidentiality, if for any  adversary 
, its advantage 
 is negligible for any sufficiently large security parameter.

Definition 10 Outsider Unforgeability (OU)

Let 
 be an OU-adversary against . We consider the following game, denoted by 
, in which an adversary 
 interacts with a challenger .

–
: The challenger  runs  to generate the system public parameters  and a master secret key . The challenger returns  to the adversary 
, and keeps the  for itself in private.

–
: In this phase, 
 issues any polynomial number of queries, including , , , and .

–
: In this , 
 outputs 
⁎
⁎
 as its forgery, where 
⁎
 and the associated data contained in 
⁎
 in clear is denoted by 
⁎
. We say the forgery 
⁎
⁎
 is a valid  created by an uncorrupted sender 
⁎
 for an uncorrupted receiver 
⁎
 if and only if the following conditions hold simultaneously:

1.
⁎
⁎
⁎
⁎
⁎
, where 
⁎
, 
⁎
⁎
, and 
⁎
 may be equal to 
⁎
.

2.
 is not allowed to issue  queries on 
⁎
 or 
⁎
.

3.
 is allowed to issue 
 for any 
⁎
⁎
⁎
⁎
. In particular, 
 can make an  query on 
⁎
, 
⁎
, 
, 
⁎
, where 
⁎
. It can even make the query 
⁎
⁎
⁎
⁎
, as long as the output returned is not equal to 
⁎
. Moreover, 
 is allowed to issue an 
⁎
 to expose the intermediate randomness used in generating 
⁎
.

Let 
 denote the advantage that 
 outputs a valid forgery in the above security game 
. We say an  scheme  has outsider unforgeability, if for any  adversary 
, its advantage 
 is negligible for any sufficiently large security parameter.

Remark 2

Note that the above definition of outsider unforgeability implies the x-security considered and named in [30]. Specifically, getting access to the oracle  in an arbitrary way does not allow the adversary to forge  (in particular, to recover the secret key of any uncorrupted user).

5. IBHigncryption: construction and discussion
For presentation simplicity, below we only present the construction of IBHigncryption based on bilinear pairings of Type 1. The extensions to Type 2 and 3 pairings are straightforward, and are presented in Appendix A.

Our  scheme consists of the following four algorithms:

-
: The algorithm is run by the PKG in order to produce the system's public parameters and the master secret key. On input of the security parameter κ, it chooses two multiplicative bilinear map groups 
 and 
 of the same prime order q such that the discrete logarithm problems in both 
 and 
 are intractable. The algorithm constructs a bilinear pairing 
, and chooses 
⁎
. Additionally, it selects a one-way collision-resistant cryptographic hash function, 
⁎
. Finally, the algorithm outputs the public parameters 
, and the PKG's master secret key . The PKG makes  public to the users in the system, but keeps  secret for itself. Note that the setup stage is much simpler, where in particular no modular exponentiation is performed in order to generate a traditional master public key as in [14] and [8]. For presentation simplicity, we assume the admissible identity space 
⁎
.

-
: On input of the system's public parameters , the master secret key  of PKG, and a user's identity 
⁎
, the PKG computes 
, and outputs 
 as the private key associated with identity .

-
: Let  = (
, , ) be an authenticated encryption (AE) scheme as defined in Section 2.2, 
⁎
 be the message to be  with associated data 
⁎
, and 
⁎
⁎
 be a key derivation function that is modelled to be a random oracle, where  is the key space of 
. For presentation simplicity, we denote by 
 the sender's public identity whose private key is 
, and by 
 the receiver's public identity whose private key is 
.

To IBHigncrypt a message 
⁎
 with the sender's identity 
 concealed, the sender 
 runs the following steps: (1) selects 
⁎
, and computes 
; (2) computes the pre-shared secret 
; (3) derives the AE key 
; (4) computes 
; and finally (5) sends the  
 to the receiver 
.

-
: On receiving C = (H, X, 
), the receiver 
 with private key 
 does the following: (1) computes the pre-shared secret 
, and derives the key 
; (2) runs 
. If 
 returns ⊥, it aborts; Otherwise, the receiver gets 
, and outputs 
 if 
, 
⁎
, and 
. Otherwise, it outputs “⊥” and aborts.

Remark 3

The correctness and the property of receiver deniability of the above  are straightforward. It also enjoys x-security and forward ID-privacy, which are implied by the formal analyses of outsider unforgeability and insider confidentiality to be given in Section 6.

Remark 4

The construction of  is fundamentally different from the PKI-based higncrypiton from [49], and cannot be transformed each other.

Briefly recall the construction by directly transforming the higncryption scheme from [49] into ID-based setting. Let 
 and 
⁎
 be the master public and private keys of PKG. Let 
 and 
 be the private keys of sender 
 and receiver 
 respectively. Let 
⁎
, 
, 
, where 
 and 
⁎
⁎
 is a cryptographic hash function. Let 
. The sender computes and sends 
. The receiver decrypts 
 and checks whether 
. This is indeed the starting point of our design of . This straightforward design is much less efficient, and has the traditional master public key.

Our actual design of  embeds a technique similar to the FO-transformation [25], and critically relies on the properties of pairings. So, the construction of  is fundamentally different from the direct transformation of the higncryption scheme from [49].

5.1. Comparison and discussion
In this section, we briefly compare our  scheme with the CCA-secure Boneh-Franklin IBE [14] (referred to as BF-IBE), and the IEEE P1363.3 standard of -based signcryption [8] (referred to as IEEE P1363.3 for simplicity). The schemes of BF-IBE and IEEE P1363.3 are reviewed in Appendix B and C, respectively.

The comparisons between our  scheme based on symmetric bilinear pairings of Type 1 and BF-IBE [14], and our  scheme based on asymmetric bilinear pairings of Type 2 and the IEEE P1363.3 standard [8], are briefly summarized in Table 2 and Table 3 respectively. Therein, ⊥ denotes “unapplicable”, “-” denotes no exponentiation operation, “E” denotes modular exponentiation, “P” denotes paring, “
” denotes a plain hashing, “
” denotes a hashing onto the bilinear group, “A” denotes modular addition, “M” (resp., 
) denotes modular multiplication in 
 or 
 (resp., 
), “INV” denotes modular inversion, and ψ denotes isomorphism. Note that modular inverse is a relatively expensive operation, which is typically performed by the extended Euclid algorithm.


Table 2. Brief comparison between  and CCA-secure BF-IBE.

BF-IBE [14]
efficiency		-	1 E
1 E + 1 H2	1 E + 1 H2
Sender	2 E + 1 P + 2 H2 + 1 	2 E + 1 P + 1 H2 + 3 H1
Receiver	1 E + 1 P + 1 H2 + 1 	1 E + 1 P + 3 H1
message space	{0,1}⁎	{0,1}n
bandwidth	
assumption	-SBDH	

Table 3. Brief comparison between  and IEEE P1363.3.

IEEE P1363.3 [8]
efficiency		1 ψ	1 E + 1 P + 1 ψ
1 E + 1 H2	1 E + 1 INV + 1 H1 + 1 A
Sender	2 E + 1 P + 2 H2 + 1 ψ + 1 	4 E + 2 ψ + 3 H1 + 1 M + 1 A
Receiver	1 E + 1 P + 1 H2 + 1 ψ + 1 	2 E + 2 P + 3 H1 + 1 MT +1 M + 1 A
message space	{0,1}⁎	{0,1}n
bandwidth	
forward -privacy	✓	×
x-security	✓	×
receiver deniability	✓	×
consider 
✓	×
assumption	-SBDH	q-BDHIP
In comparison with BF-IBE [14] and IEEE P1363.3 [8]),  has a much simpler setup stage. Specifically, the setup stage of our  has much smaller public parameters, and actually does not need to perform exponentiation to generate the master public key (corresponding to 
 in BF-IBE, and 
 in IEEE P1363.3). The much simpler setup stage of , particularly waiving the master public key, brings the following advantages:

–
The computational and space complexity for generating and storing the system parameters is reduced.

–
The attack vector (for recovering the master secret key) is decreased, e.g., for some mission critical applications.

–
It eases deployment and compatibility with existing identity-based cryptosystems. Specifically, when deploying our  scheme in reality with other existing identity-based cryptosystems, the system parameters and particularly the master public key can remain unchanged.

For IEEE P1363.3 [8], if the secret x is exposed one can compute from the corresponding signcryptext the following values: the message M being signcrypted, and more importantly the secret key value 
 which then allows the attacker to impersonate the sender in an arbitrary way. This shows that IEEE P1363.3 lacks the x-security (specifically, cannot be outsider unforgeable when getting access to the  oracle is allowed). We also note that the provable security of IEEE P1363.3 [8] does not consider the case of 
.

To reduce communication bandwidth and storage, in the implementation of elliptic curves, only the value of x is saved for the element , because y can be computed by x. Thus, the communication bandwidth of BF-IBE [14] and IEEE P1363.3 [8] is 
 and 
, respectively. In , an encryption algorithm needs to be embedded in the protocol, and we use AES-GCM [41] to instantiate it. The output of AES-GCM is an authentication tag H and ciphertext 
. Let  and 
 be the length of the tag and ciphertext, so the bandwidth of  is 
.

For computational efficiency, briefly speaking, our  is essentially as efficient as BF-IBE [14], while providing the functionalities of encryption, authentication, and -privacy simultaneously and with a much simpler setup stage. In other words, compared with BF-IBE, the functionalities of authentication and -privacy are gotten almost for free with . In comparison with IEEE P1363.3 [8], besides the extra properties of forward -privacy, x-security, receiver deniability,  is also computationally more efficient in total. Note that the plaintext spaces for BF-IBE and IEEE P1363.3 are pre-specified to be 
. If one employs the hybrid encryption approach to encrypt messages of arbitrary length with BF-IBE or IEEE P1363.3, it also needs to employ some appropriate symmetric-key encryption scheme in reality.

6. Security proof of IBHigncryption
Due to space limitation, we focus on the security proof of our  construction with symmetric bilinear groups. The extension to the asymmetric bilinear groups is straightforward. In the following security analysis, KDF and the hash function h are modelled as random oracles (RO) which are controlled by the challenger.

Theorem 2

The  scheme presented in Fig. 2 is outsider unforgeable in the random oracle model under the AEAD security and the  assumption. Concretely, suppose that there exists a ()-adversary 
 who can break outsider unforgeability of the  scheme with non-negligible advantage ϵ and running time t, then, there exists another (
)-algorithm, which can solve the  problem with non-negligible advantage 
 
 and running time 
, where 
, 
, and 
 are the adversary's query times to Hash, KDF, CORRUPT, HO, UHO, and DBDH oracles, and 
 and 
 represent the running time of an exponentiation, pairing, Enc, and Dec operation, respectively.

Fig. 2
Download : Download high-res image (62KB)
Download : Download full-size image
Fig. 2. Protocol Structure of .

Theorem 3

The  scheme presented in Fig. 2 has insider confidentiality in the random oracle model under the AEAD security and the  assumption. Concretely, suppose that there exists a ()-adversary 
 who can break insider confidentiality of the  scheme with non-negligible advantage ϵ and running time t, then, there exists another (
)-algorithm, which can solve the  problem with non-negligible advantage 
 
 and running time 
, where 
, 
, and 
 are the adversary's query times to Hash, KDF, CORRUPT, HO, UHO, and DBDH oracles, and 
 and 
 represent the running time of an exponentiation, pairing, Enc, and Dec operation, respectively.

6.1. Proof of outsider unforgeability
In this section, we prove Theorem 2 in detail.

At first, the challenger  accepts a tuple 
, 
, 
 ∈ 
 and a paring 
 as inputs. The goal of  is to compute 
 with the help of a  oracle (denoted by 
), which is regarded as the gap square bilinear Diffie-Hellman hard problem () [38], [5], conditioned on that unforgeability of  is broken with non-negligible probability by the adversary 
. The  oracle 
 for 
 and 
 on arbitrary input 
, outputs 1 if and only if 
.

During the simulation, the challenger  maintains four tables 
, and 
. They are all initialized to be empty.

: The challenger  sets the public parameters 
, where q is the prime order of 
 and 
, and 
⁎
 is a collision-resistant cryptographic hash function, which is modelled as a random oracle and controlled by  in our security proof. The challenger  defines the master secret key , (where  are unknown to ). Finally,  gives  to the adversary 
.

 on 
⁎
:

On input of a user's identity 
, the challenger chooses a random 
⁎
. Using the techniques of Coron [20],  flips a biased coin 
 satisfying 
 with probability γ and 0 otherwise [20]. If 
,  sets 
. Otherwise, if 
,  sets 
. The challenger returns 
 to 
, and stores 
 into the table 
.

: 
 issues a number of queries adaptively, including , , , and . With respect to each kind of queries, the challenger  responds to 
 as follows:

–
:

For a  query on user 
,  first visits table 
. If 
,  returns 
. Otherwise,  aborts. Let 
 be the set of corrupted users in the system, which is initialized to be empty. On each  query on 
, if the challenger  returns the private key of 
 to the adversary, it sets 
.

–
:

For an  query on 
, there is no restriction on H and M, which means that H can even be 
⁎
, and M can even be 
⁎
 (here, 
⁎
 is the associated data in the adversary's forgery, and 
⁎
 is the message  in the adversary's forgery).  first visits table 
, and get the values of 
 and 
, i.e., 
 and 
. We further consider the following cases:

1.

———————————————–

the challenger  selects 
⁎
;

  sets 
;

if 

 computes

;

;

else

 computes

;

;

 stores the tuple 
 into 
;

endif

 computes 
 ← 
 (H, 
);

 returns C = (H, X, 
) to 
;

 stores the tuple  into the table 
.

———————————————–

2.

———————————————–

the challenger  selects 
⁎
;

  sets 
;

if 

 computes

;

;

else

 sets 
 to be a string taken uniformly at random from  of AEAD;

 stores the tuple 
 into 
;

endif

 computes 
 ← 
 (H, 
);

 returns C = (H, X, 
) to 
;

 stores the tuple  into the table 
.

———————————————–

–
:

For an  query on C, the challenger  first visits the table 
. If there is an entry in the table,  returns the corresponding x to the adversary. Otherwise,  returns ⊥ to the adversary.

Note that in the above  queries, if 
, or 
, 
 is derived based on the correctly computed PS, therefore, the simulation of  is perfect. If 
, though the challenger  cannot compute PS, X is computed correctly, and 
 is set uniformly at random and can be used to correctly  the output of the . Due to the fact that KDF is a random oracle, the simulation of  in this case is also perfect.

Also note that in the above cases, if 
, the challenger  cannot compute the pre-shared secret:
 and consequently , 
. In order to keep the consistency of the random oracle KDF, whenever the adversary 
 makes an oracle of the form 
 for some 
 whose corresponding value 
, based on the table 
 and 
, the challenger  checks whether 
 oracle returns 1, which implies 
 = , 
; If yes, it returns the corresponding pre-shared key 
 in the table 
 to the adversary, meanwhile,  stores the tuple 
 into the table 
.

So far, all the simulations for , and  is perfect.

–
:

For an  query on 
: If 
's corresponding value 
,  can perfectly simulate the game. Therefore, we only consider the case where 
.  first checks whether C was ever output by 
 for some 
⁎
 and 
, and outputs 
 if so; Otherwise, for each KDF oracle query of the form 
 made by 
,  checks if there is a match in the table 
. If so,  gets 
, and uses 
 to decrypt 
. The challenger  further verifies the decryption results. If the verification is successful, it returns the results to 
; Otherwise,  returns ⊥ indicating C is an invalid  for user 
. Let 
 be the event that on the query of the form 
 by 
,  returns ⊥ while C is a valid . On conditioned that the 
 does not occur, the simulation for  is perfect. Below, we show that the 
 can occur with at most negligible probability.

Note that the 
 has already ruled out the possibility that C was the output of 
 for some 
 whose corresponding value 
, and for arbitrary 
 and arbitrary (). The other case, if 
 is the output of 
 made by 
 for 
 whose corresponding value 
, (and arbitrary 
, H, M), the challenger can decrypt the message correctly, which implies that  will not output ⊥ for a valid .

Therefore, when the 
 event occurs with respect to 
, C = 
, where 
 is the receiver whose corresponding value 
, 
 covers the following three cases with overwhelming probability: (1) C was never output by the  oracle; (2) 
 did not make the 
 query for 
; and (3) 
 is a valid AEAD ciphertext with respect to 
 =  =  (X, 
, 
), 
. 
 can be further divided into the following two cases which can occur with negligible probability:

1.
 was set by  uniformly at random for an  query when that 
. It implies that by the KDF security, with overwhelming probability, X is a part of the output of  queries when 
 generated by  for 
. Let 
 be the challenger's output when it deals with the query 
. Note that 
, 
 is the only AEAD ciphertext output by  with respect to 
. As we assume 
 was never output by  in the above  query, it means that 
. It implies that the adversary 
 has output a new valid AEAD ciphertext 
 with respect to 
. It is obvious that this 
 can occur with negligible probability by the AEAD security.

2.
Otherwise, with overwhelming probability, 
 was neither set by  nor ever defined for the KDF oracle. It can also be expected to occur with negligible probability by the AEAD security.

Then, we conclude that the 
 event can occur with at most negligible probability, and consequently the view of 
 in the simulation is indistinguishable from that in its real attack experiment.

: 
 outputs 
⁎
⁎
 as its forgery and the associated data contained in 
⁎
 in plain is denoted 
⁎
. If the forgery 
⁎
⁎
 is a valid  created by the uncorrupted user 
⁎
 for the uncorrupted user 
⁎
, it must satisfy the following conditions simultaneously:

1.
⁎
⁎
⁎
⁎
⁎
, and 
⁎
.

2.
If there is any 
⁎
⁎
⁎
⁎
 query by 
 in , then 
⁎
 must not be the output of  (
⁎
, 
⁎
, 
⁎
, 
⁎
.

Now, let 
⁎
⁎
⁎
⁎
⁎
 be the successful forgery output by 
, which satisfies the above two conditions. Here, we require that 
⁎
 and 
⁎
 are the uncorrupted users and corresponding values 
⁎
⁎
. From the above analysis showing 
 occurs with negligible probability in the  simulation, by the AEAD security, for the adversary 
's successful forgery 
⁎
⁎
⁎
⁎
⁎
, it must have made a KDF query on 
⁎
⁎
⁎
 with non-negligible probability, where 
⁎
 may be generated by the adversary itself; Otherwise, 
⁎
⁎
⁎
 returns ⊥ with overwhelming probability in the random oracle model. By looking up the table 
,  gets 
 and 
⁎
 corresponding to 
⁎
⁎
. With the help of 
,   s 
⁎
, and gets the corresponding 
⁎
 which is used to generate 
⁎
 by the adversary.  verifies whether 
⁎
⁎
⁎
 (for a successful forgery, 
⁎
 must not be 0, and the verification must be successful), then,  computes 
⁎
⁎
⁎
⁎
 
⁎
⁎
⁎
⁎
⁎
 
⁎
⁎
⁎
⁎
⁎
⁎
 
⁎
⁎
⁎
⁎
⁎
⁎
 
.

Remark 5

For the case where the target sender and the target receiver are the same, we denote by 
⁎
 the user. In this case, 
⁎
⁎
⁎
⁎
, 
⁎
⁎
⁎
⁎
⁎
⁎
. It is obvious that the security is based on the  assumption, on input 
, the challenger  can compute 
⁎
⁎
⁎
 
.

The observation here is that, for any pair 
, the probability of 
, i.e., 
 
, where 
, q is the prime order of 
 and 
, and 
⁎
. For an identity 
, if 
,  aborts when it deals with a . When the adversary 
 outputs a forgery from 
⁎
 to 
⁎
,  does not abort if 
⁎
⁎
. Suppose that the adversary makes 
 times of . The total probability that  does not abort is 
. Suppose that the adversary 
's running time is polynomial time t, and can break outsider unforgeability of  with non-negligible probability ϵ, then the challenger  can solve the  hard problem with the probability 
 
, and its running time 
. Up to now, we finish the proof of outsider unforgeability.

6.2. Proof of insider confidentiality
In this section, we present the proof of Theorem 3.

At first, the challenger  accepts a tuple
 and a paring 
 as inputs. The goal of  is to compute 
 with the help of a  oracle 
, which is regarded as the gap square bilinear Diffie-Hellman hard problem (), assuming that the confidentiality of the message or the privacy of the sender's identity of  is broken with non-negligible probability by the adversary 
. The  oracle for 
 and 
 on arbitrary input 
, outputs 1 if and only if 
.

During the simulation, the challenger  also need to maintain four tables 
, and 
. Similarly, they are all initialized to be empty. The simulation is divided into the following five phases:

: The challenger  sets the public parameters 
, where q is the prime order of 
 and 
, and 
⁎
 is a collision-resistant cryptographic hash function, which is modelled as a random oracle and controlled by  in our security proof. The challenger  defines the master secret key , which is unknown to . Finally, the challenger  gives  to the adversary 
.

 on 
⁎
:

On input of a user's identity 
, the challenger chooses a random 
⁎
. Using the techniques of Coron [20],  flips a biased coin 
 satisfying 
 with probability γ, and 
 with probability 1 - γ [20]. If 
,  sets 
. Otherwise, if 
,  sets 
. The challenger returns 
 to 
, and stores 
 into the table 
.

: 
 issues a number of queries adaptively, including , , , and . With respect to each kind of queries, the challenger  responds to 
 as follows:

–
:

For a  query on user 
,  first visits table 
. If 
,  returns 
. Otherwise,  aborts. Let 
 be the set of corrupted users in the system, which is initialized to be empty. On each  query on 
, if the challenger  returns the private key of 
 to the adversary, it sets 
.

–
:

For an  query on 
, where there is no restriction on H and M, which means that H can even be 
⁎
, and M can even be 
⁎
, the challenger  performs:

1.

———————————————–

the challenger  selects 
⁎
;

  sets 
;

if 

 computes

;

;

else

 computes

;

;

 stores the tuple 
 into 
;

endif

 computes 
 ← 
 (H, 
);

 returns C = (H, X, 
) to 
;

 stores the tuple  into the table 
.

———————————————–

2.

———————————————–

the challenger  selects 
⁎
;

  sets 
;

if 

 computes

;

;

else

 sets 
 to be a string taken uniformly at random from  of AEAD.

 stores the tuple 
 into 
;

endif

 computes 
 ← 
 (H, 
);

 returns C = (H, X, 
) to 
;

 stores the tuple  into the table 
.

———————————————–

–
:

For an  query on C, the challenger  first visits the table 
. If there is an entry in the table,  returns the corresponding x to the adversary. Otherwise,  returns ⊥ to the adversary.

We note that in an  query, 
 is derived based on the correctly computed PS as long as 
 or 
 equals to 1, therefore, the simulation of  is perfect. If both 
, the challenger  cannot compute PS. However, X is computed correctly, and 
 is set uniformly at random and can be used to correctly  the output of the . Due to the fact that KDF is a random oracle, the simulation of  in this case is also perfect.

Also note that in the above cases, if 
, the challenger  cannot compute the pre-shared secret:
 and consequently 
. In order to keep the consistency of the random oracle KDF, whenever the adversary 
 makes an oracle of the form 
 for some 
 whose corresponding 
, based on the table 
 and 
, the challenger  checks whether 
 (X, 
), 
, 
 oracle returns 1, which implies 
 = 
 =  (X, 
, 
); If yes, it returns the pre-shared key 
 to the adversary, meanwhile, the challenger  stores the tuple 
 into the table 
.

So far, all the simulations for , and  is perfect.

–
:

For an  query on 
: If 
,  can perfectly simulate the game. Therefore, we only consider the case where 
. In this case, the challenger  does what he does in the proof of outsider unforgeability with respect to 
. The simulation analysis is also identical to the proof of Theorem 2.

: At the end of , 
 selects two target senders 
⁎
, 
⁎
, and a target receiver 
⁎
⁎
, a pair of messages 
⁎
⁎
 of equal length from 
⁎
, and the associated data 
⁎
⁎
. 
 submits 
⁎
⁎
⁎
, and 
⁎
⁎
⁎
 to the challenger , where 
⁎
. If 
⁎
, the challenger  aborts; Otherwise : (1) chooses  (here, 
⁎
 may be equal to 
⁎
); (2) if 
⁎
,  chooses 
⁎
⁎
, and computes 
⁎
⁎
⁎
⁎
⁎
; (3) otherwise, if 
⁎
,  sets 
⁎
 (which is unknown to the challenger ), and computes 
⁎
⁎
⁎
⁎
;(4) checks whether there is a record 
⁎
⁎
 in the table 
. If yes, it outputs “”. Otherwise, the challenger chooses 
 uniformly at random from the key space  of AEAD, and stores the tuple (
⁎
⁎
) into the table 
; (5) if 
⁎
,  computes 
⁎
⁎
⁎
⁎
⁎
; otherwise,  selects 
⁎
⁎
, and computes 
⁎
⁎
⁎
⁎
⁎
; (6) gives the challenge  
⁎
⁎
⁎
 to 
. From this point on, with the aid of its  oracle 
 and based upon the table 
 and 
, whenever  finds that 
 makes an query of the form KDF (
⁎
, 
⁎
⁎
), the challenger checks whether 
 (
⁎
, 
⁎
, 
, 
⁎
) oracle returns 1, which implies 
⁎
 = e (
⁎
, 
⁎
 = 
⁎
⁎
 when 
, or 
⁎
 = e (
⁎
, 
⁎
 = 
⁎
 when 
; If yes, it returns the pre-shared key 
 to the adversary, meanwhile, the  stores the tuple 
⁎
⁎
⁎
 into the table 
.

: 
 continues to make queries as in  with the following restrictions:

1.
 is not allowed to issue an  query with the form 
⁎
⁎
.

2.
 is not allowed to issue an  query on 
⁎
, i.e., 
⁎
 is not allowed.

3.
 is allowed to issue a  query on any identity 
⁎
, i.e., only  (
⁎
 is not allowed.

: Finally, 
 outputs 
 as his guess of the random bit σ.
Similar to the proof of outsider unforgeability, if 
, the adversary must have made a KDF query on 
⁎
⁎
⁎
 with non-negligible probability in the random oracle model, where 
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
 when 
⁎
, and 
⁎
⁎
⁎
⁎
⁎
⁎
⁎
 when 
⁎
. Since  has recorded the value 
⁎
 = 
⁎
, 
⁎
, 
, it can compute 
⁎
⁎
⁎
⁎
 
 if 
⁎
, or 
⁎
⁎
⁎
 
 if 
⁎
.

Remark 6

For the case, one of the target senders is equal to the target receiver and chosen by  in generating the final challenge , w.l.g., denote by 
⁎
 the sender, i.e., 
⁎
⁎
⁎
. In this case, 
⁎
⁎
⁎
. It is obvious that the security is based on the  assumption on input 
, where 
⁎
⁎
⁎
⁎
⁎
⁎
.

Remark 7

The probability analysis is similar to the proof of outsider unforgeability. Suppose that the adversary makes 
 times of . The total probability that  does not abort is 
. Suppose that the adversary 
's running time is polynomial time t, and can break the insider confidentiality of  with non-negligible probability ϵ, then the challenger  can solve the  hard problem with the probability 
 
, and its running time 
.

Appendix A. IBHigncryption constructions with asymmetric bilinear pairings
In this part, we describe our  constructions based on bilinear pairings of Type 2 and Type 3, respectively.

A.1. Construction with bilinear pairings of Type 2
The construction of our  in this section, as well as the IEEE P1363.3 standard [8] for -Based signcryption, is based on asymmetric bilinear parings of Type 2. The extension of our  construction to the Type 2 bilinear parings is straightforward, which is described below from scratch for ease of reference.

-
: On input of the security parameter κ, the algorithm chooses three multiplicative bilinear map groups 
 and 
 of the same prime order q, generators 
, 
, and a bilinear paring 
 such that the discrete logarithm problems in 
 and 
 are intractable, where 
 is an efficient, publicly computable isomorphism. The algorithm chooses a master secret key 
⁎
. Additionally, it selects a one-way collision-resistant cryptographic hash function, 
⁎
. Finally, the algorithm outputs the public parameters 
, and the PKG's master secret key . The PKG makes  public to the users in the system, but keeps  secret for itself.

-
: On input of the system's public parameters , the master secret key  of the PKG, and a user's identity 
⁎
, the PKG computes 
, and outputs sk as the private key associated with identity .

-
: Let  = (
, , ) be an authenticated encryption scheme, 
⁎
 be the message to be  with associated data 
⁎
, and 
⁎
⁎
 be a key derivation function, where  is the key space of 
. For presentation simplicity, we denote by 
 the sender's public identity whose private key is 
, and by 
 the receiver's public identity whose private key is 
.

To IBHigncrypt a message 
⁎
 with the sender's identity 
 concealed, the sender: (1) selects 
⁎
, and computes 
; (2) computes the pre-shared secret 
; (3) derives 
; (4) computes 
; and finally (5) sends the  
 to the receiver 
.

-
: Upon receiving C = (H, X, 
), the receiver: (1) computes the pre-shared secret 
, and derives the key 
; (2) runs 
. If 
 returns ⊥, it aborts; Otherwise, the receiver gets 
, and outputs 
 if 
⁎
 and 
; Otherwise, it outputs “⊥” and aborts.

A.2. Construction with bilinear pairings of Type 3
The construction of our  in this subsection is based on the bilinear parings of Type 3.

-
: On input of the security parameter κ, the algorithm chooses three multiplicative bilinear map groups 
 and 
 of the same prime order q, generators 
, 
, and a bilinear paring 
 such that the discrete logarithm problems in 
 and 
 are intractable. The algorithm chooses a master secret key 
⁎
. Additionally, it selects two one-way collision-resistant cryptographic hash functions, 
⁎
, and 
⁎
. Finally, the algorithm outputs the public parameters 
, and the PKG's master secret key . The PKG makes  public to the users in the system, but keeps  secret for itself.

-
: On input of the system's public parameters , and a user's identity 
⁎
, the PKG computes 
, and outputs sk as the private key associated with identity .

-
: Let  = (
, , ) be an authenticated encryption scheme, 
⁎
 be the message to be  with associated data 
⁎
, and 
⁎
⁎
 be a key derivation function, where  is the key space of 
. For presentation simplicity, we denote by 
 the sender's public identity whose private key is 
, and by 
 the receiver's public identity whose private key is 
.

To IBHigncrypt a message 
⁎
 with the sender's identity 
 concealed, the sender: (1) selects 
⁎
, and computes 
; (2) computes the pre-shared secret 
; (3) derives 
; (4) computes 
; and finally (5) sends the  
 to the receiver 
.

-
: On receiving C = (H, X, 
), the receiver: (1) computes the pre-shared secret 
, and derives the key 
; (2) runs 
. If 
 returns ⊥, it aborts; Otherwise, the receiver gets 
, and outputs 
 if 
⁎
 and 
; Otherwise, it outputs “⊥” and aborts.

Remark 8

For presentation simplicity, the above Type 3 pairing based implementation of  is described w.r.t. a pair of secret keys 
 for each user in the system. But from the protocol description, it is clear that: if a user only performs the role of sender (resp., receiver), it only needs a single secret key 
 (resp., 
).

Appendix B. CCA-secure Boneh-Franklin IBE
The identity-based encryption from Weil paring [14] (referred to as BF-IBE for simplicity) is the first practical identity-based encryption from pairing. In [14], both a CPA-secure IBE, and a CCA-secure IBE via the Fujisaki-Okamoto transformation [25], are proposed. Below, we briefly review the CCA-secure BF-IBE construction.

The CCA-secure BF-IBE scheme consists of the following four algorithms:

–
: Given a security parameter 
, this algorithm: (1) generates a prime q, two bilinear map groups 
 and 
 of order q, and an admissible bilinear map 
; (2) chooses a random generator 
; (3) picks 
⁎
 and sets the master public key 
; (4) chooses a cryptographic hash function 
⁎
, and three cryptographic hash functions 
⁎
, and 
 for some n. The message space is 
, and the ciphertext space is 
. The system parameters are
 and the master secret key is 
⁎
.

–
: For a given string 
⁎
, this algorithm: (1) computes 
, and (2) sets the private key 
, where 
⁎
 is the master secret key.

–
: To encrypt a message 
 under the public key , this algorithm: (1) computes 
; (2) chooses a random 
; (3) sets 
; and (4) sets the ciphertext as:
 where 
.

–
: Let  be a ciphertext encrypted using the public key . If 
, this algorithm rejects the ciphertext; Otherwise, it decrypts C using the private 
:

1.
compute 
;

2.
compute 
;

3.
set 
. Test whether 
. If not, the algorithm rejects the ciphertext;

4.
Otherwise, the algorithm outputs M as the decryption of C.

Appendix C. IEEE P1363.3 ID-based signcryption
The identity-based signcryption from Type 2 bilinear maps [8], adopted as IEEE P1363 standard, consists of the following algorithms.

–
: Given a security parameter κ, the PKG chooses bilinear map groups (
) of prime order 
, an admissible bilinear map 
; and generators 
, where 
 is an efficient, publicly computable (but not necessarily invertible) isomorphism such that 
. It then chooses a master secret key 
⁎
, computes a system-wide master public key 
, and chooses hash functions 
⁎
⁎
, 
⁎
⁎
, and 
. The public parameters are
 and the master secret key is 
⁎
.

–
: For a given string 
⁎
, this algorithm computes the private key 
 
.

–
: Given a message 
, a receiver's identity 
 and a sender's private key 
, the algorithm:

1.
picks 
⁎
, computes 
, and 
;

2.
sets 
⁎
;

3.
computes 
;

4.
computes 
.

The ciphertext is 
.
–
: Give , and some sender's identity 
, the receiver:

1.
computes 
, 
, and 
;

2.
accepts the message if and only if 
. If this condition holds, returns the message M and the signature 
⁎
.