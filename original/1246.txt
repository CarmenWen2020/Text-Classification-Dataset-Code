Abstract
The main aim of this paper is to give a simple transparent proof of the result showing that the problem of bisimulation equivalence on the class of Basic Parallel Processes (BPP), denoted by BPP-Bisim, can be decided by a polynomial-space algorithm. This result (by the author) has been previously only presented in a conference version, in a rather technical form that is not easily readable and verifiable. Since the result has clarified the complexity of the problem BPP-Bisim, namely its PSPACE-completeness (using the lower bound by Srba), and the problem deals with a fundamental behavioural equivalence and with one of the simplest models that naturally extend finite-state systems into infinite-state ones, it seems appropriate to have a transparent version of the proof.

Keywords
Verification
Concurrency
Equivalence checking
Bisimulation equivalence
Basic parallel processes

1. Introduction
The main aim of this paper is to give a simple transparent proof of the result showing that the problem of bisimulation equivalence on the class of Basic Parallel Processes (BPP), denoted by BPP-Bisim, can be decided by a polynomial-space algorithm. This result (by the author) has been only presented in a conference version, namely in [1], in a rather technical form that is not easily readable and verifiable (as the author has also learned from other researchers). The result has thus clarified the complexity of the problem BPP-Bisim, namely its PSPACE-completeness, since its PSPACE-hardness was known due to Srba [2] (with the journal version [3]).

Since bisimulation equivalence is a fundamental behavioural equivalence in concurrency theory, having also natural connections with logics used in computer science (we can recall, e.g., [4] as one of the classical books), and Basic Parallel Processes constitute probably the simplest model that extends finite-state systems with a parallel-composition operation resulting in infinite-state systems (as discussed below), it seems appropriate to have also a reviewed journal version of the former conference presentation, which is now thoroughly rewritten.

We recall that bisimilarity (which is another name for bisimulation equivalence) is decidable in polynomial time on finite-state systems that can be presented as finite labelled transitions systems, or nondeterministic finite automata; the classical algorithms are given in [5], [6]. We can also recall that bisimilarity is PTIME-complete for finite-state systems [7]. Regarding infinite-state systems, we can name [8] as a seminal paper showing the decidability of bisimilarity for one such class, namely for the class of normed BPA (Basic Process Algebra) processes. For further results in this area we can refer, e.g., to the surveys [9] and [10]; the latter has an updated online version.

The class BPP (in this paper meaning Basic Parallel Processes, not the complexity class with the same acronym) is, in fact, a parallel counterpart of the “sequential” class BPA. We can imagine that in a nondeterministic finite automaton, with the state set

Image 1
(deliberately denoted by
Image 1
to anticipate a representation by a Petri net with the set
Image 1
of places) we replace standard transitions 
 with transitions 
 where M is generally a finite multiset of states in
Image 1
; hence a “program thread” in state p can perform an action a by which it spawns a (maybe empty) collection of new threads in the prescribed states that run further in parallel (with no mutual communication). There are no accepting/rejecting states but we study the problem BPP-Bisim, i.e. the question if two multisets 
, 
 (also called configurations, or markings in the respective Petri nets) exhibit the same behaviour, in the sense that they are bisimilar, which is denoted by 
. (We recall that 
 iff each move 
 can be matched with a move 
 with the same action a so that 
; moreover, ∼ is symmetric.)
The decidability of BPP-Bisim was shown by Christensen, Hirshfeld, and Moller [11], without any complexity upper bound. The problem Normed-BPP-Bisim, for the normed BPP, where from each multiset M we can reach the empty multiset 0, turned out to be substantially easier: it was shown to be in PTIME [12] (which was in [13] even extended to a class of normed BPP where a synchronization of parallel threads is allowed).

As already discussed, the proof presented here establishes that BPP-Bisim is in PSPACE, and is thus PSPACE-complete by using [3]. When the presented polynomial-space algorithm is restricted to the instances of Normed-BPP-Bisim, then it works in polynomial time; this yields a proof of the PTIME-membership that substantially differs from the proof in [12].1

The crux of the presented algorithm is that a certain semilinear (i.e. Presburger-arithmetic) representation of bisimulation equivalence on a BPP system, with the state set

Image 1
, can be constructed effectively, and the membership of a given pair 
 in the represented set can be checked in polynomial space. In more detail, this check amounts to verify if
Image 2
for certain (maybe exponentially many) “important” sets
Image 3
, where
Image 4
is the norm of a configuration M w.r.t. the set Q, i.e., the length of a shortest path from M to a multiset whose intersection with Q is empty (the value
Image 4
is infinite if no such multiset is reachable from M).
All this is informally explained, and then rigorously proved, in Section 3, after the preliminaries given in Section 2. Section 4 looks at the used approach from a more abstract viewpoint, of the “distance-to-disabling” functions on general labelled transition systems. In Section 5 we then briefly discuss related research on BPP and BPA, including the open problems regarding the equivalences called weak bisimilarity and branching bisimilarity, which are relevant in the presence of silent transitions. In particular, we also discuss a relation to the interesting notion of a certain semantic norm of configurations introduced by Yuxi Fu in [16], which initiated further research especially on the class BPA.

2. Notation, basic notions, and some standard facts
The aim of this section is to give a rigorous definition of the problem of bisimilarity on basic parallel processes (BPP), together with the used notation and some standard facts.

2.1. Numbers (with ω), multisets, partitions of sets
By 
 we denote the sets of integers, nonnegative integers, and positive integers, respectively. We use ω just as a symbol denoting an infinite amount, and put 
 and 
. For any  we put , , and for 
 we put . Moreover, , and .

For a finite set B,  denotes its cardinality, and  is the set of all subsets of B. By 
 we denote the set of all finite multisets of elements of B, identifying a multiset 
 with a function ;  denotes the multiplicity (the number of occurrences) of  in M. As usual, for multisets 
 we rather write 
 instead of 
.

By a partition of a (finite) set B we understand a set  of nonempty pairwise disjoint subsets of B such that their union is B. The elements of a partition  are its classes. The set of all partitions of a set B is denoted by . By ⊑ we denote the standard refinement-order on : 
 if each class 
 is a subset of some class 
. We also use the standard notational variants: e.g.,

Image 5
denotes that 
 is a proper refinement of 
 (hence 
 and 
).
Given 
, by 
 we denote the meet of 
 and 
, i.e., the greatest lower bound  for 
 w.r.t. ⊑ (hence two elements of B are in the same class of 
 iff they are in the same class of 
 and in the same class of 
); more generally, ⨅
 is the meet of the set 
.

2.2. Labelled transition systems and bisimulation equivalence
A labelled transition system (LTS) is a tuple

Image 6
where S is the set of states,
Image 7
is the set of actions and 
 is the set of a-transitions (transitions labelled with a), for each
Image 8
. We usually write 
 instead of 
. The relations 
 are naturally extended to 
 for
Image 9
(i.e., for finite words over
Image 7
): we have 
 (where ε denotes the empty word), and 
 and 
 entails 
. We say that 
 is reachable from s if 
 for some
Image 9
.
Given an LTS

Image 6
, a binary relation  is a bisimulation if for each 
 the following conditions hold:
•
if 
, then there is 
 such that 
 and 
,

•
if 
, then there is 
 such that 
 and 
.

Two states 
 are bisimulation equivalent, or bisimilar, which is denoted by 
, if there is a bisimulation  such that 
. It is standard to note that bisimulation equivalence (or bisimilarity), i.e. the relation , is an equivalence relation and the largest bisimulation on S.

Though we have defined bisimulation equivalence on the states of one LTS, it can also relate states of two different LTSs, in which case we implicitly refer to the disjoint union of respective LTSs.

2.3. Basic Parallel Processes (BPP), presented as (markings of) BPP-nets
Image 10
, and the related LTSs
Image 11
Basic parallel processes (BPP) can be viewed as a fragment of Milner's calculus of communicating systems (CCS) [4] (without restriction, relabelling and communication). An alternative definition is given in the framework of process rewrite systems [17]. Here we use a technically convenient representation of BPP systems by “BPP-nets”, a special type of labelled Petri nets where each transition has exactly one input place.

Formally, a BPP-net is a tuple

Image 12
where
Image 1
,
Image 13
and
Image 7
are finite sets of places, transitions, and actions (or transition-labels), respectively;
Image 14
is a function attaching a unique input place
Image 15
to a transition t,
Image 16
is a function attaching a multiset of output places
Image 17
to a transition t, and
Image 18
labels each transition by an action. The function
Image 19
is also extended to
Image 20
, so that for
Image 21
we have
Image 22
.
An example of a BPP-net

Image 12
is shown in Fig. 1, where and
Image 24
are depicted in an obvious way: e.g., for 
 we have
Image 25
,
Image 26
, and
Image 27
; the multiplicity of a transition-to-place edge is omitted when it is 1.
Fig. 1
Download : Download high-res image (55KB)
Download : Download full-size image
Fig. 1. Example of a BPP-net

Image 12
, with marking M = (x1,x2,x3,x4,x5,x6).
A marking M of

Image 10
is a multiset of places, hence a function
Image 28
. A transition t is enabled in M if
Image 29
. A transition t that is enabled in M can be performed, which results in the marking
Image 30
; we write 
. E.g., if the marking 
 in Fig. 1, written as 
 for short, satisfies 
, then we have 
.
A BPP net

Image 12
generates the LTS
Image 31
where
Image 32
is the set of markings of
Image 10
, and we have 
 if 
 for
Image 33
with
Image 34
.
2.4. Problem of deciding bisimilarity on BPP
We are interested in the complexity of the following decision problem:

BPP-Bisim

Instance: a BPP-net

Image 10
and two markings
Image 35
.
Question: is 
?

In the next section we show that the problem BPP-Bisim is in PSPACE (and thus PSPACE-complete), assuming a standard encoding of problem instances. Since there are numbers in the instances, namely in the presentations of multisets
Image 17
(for transitions t of
Image 10
) and 
, we stress that we assume a standard binary (or decimal) presentation of these numbers. We note that Srba [3] showed a PSPACE lower bound for
Image 36
that also applies when the numbers are presented in unary.
In the next two subsections we recall some standard notions and facts that are useful in the later proofs.

2.5. Traps, marked traps,
Image 37
, restrictions 
Given a BPP-net

Image 12
, we say that
Image 38
is a trap if for each
Image 33
with
Image 39
we have
Image 40
. E.g., the set 
 in Fig. 1 is a trap. We note that ∅ is the least trap and
Image 41
is a trap } is the largest trap (since the union of traps is a trap).
Given

Image 3
, we can compute the largest trap contained in Q, denoted by
Image 37
, by a standard polynomial-time algorithm:
;

repeat

for each

Image 33
such that
Image 39
and
Image 42
do
Image 43
until R is a trap (⋆ here

Image 44
⋆).
By 
 we denote the restriction of marking M to Q (hence 
 where 
 for all ). By 0 we denote the empty multiset (over a domain clear from context). We say that
Image 3
is unmarked in M if 
; Q is marked in M if 
 (hence  for some ).
We observe that if a trap is marked in M then it is also marked in all 
 reachable from M.

2.6. Norms of sets of places, and normed BPP (nBPP)
In our later reasoning, an important role will be played by functions

Image 45
, for
Image 3
in a given BPP-net
Image 12
. The value
Image 4
is the length of a shortest
Image 9
such that 
 where 
; we put
Image 46
if there is no such w. In fact, we have already observed that
Image 47
entails
Image 46
(if
Image 37
is marked in M, then it remains marked in all 
 reachable from M).
If we assume that the places in

Image 1
are ordered, viewing
Image 1
as a tuple 
, then
Image 4
, where M is viewed as a vector 
, can be obviously expressed as a linear function (of type 
) of the form
 for some coefficients 
; in fact,
Image 48
. E.g., in Fig. 1 for 
 we have
Image 49
,
Image 50
,
Image 51
, and
Image 52
. Hence (Recall that we have put ,  for all 
, and  for all .)
There is a straightforward polynomial-time algorithm computing the coefficients 
: if

Image 54
, then 
; if
Image 55
, then 
; computing the coefficients for places
Image 56
is clear from the following inductive fact:
Image 57
.
A BPP-net

Image 12
is normed if 0 is reachable from each marking
Image 58
; in other words, if
Image 59
.
3. Bisimilarity on BPP is in PSPACE (and in PTIME on normed BPP)
We start with a sketch of the ideas on which the later polynomial-space algorithm is based; the ideas are illustrated on the BPP-net

Image 12
in Fig. 1.
Let us consider the partition

Image 60
of the set
Image 13
, where
Image 61
. In our example we have
Image 62
where(1)
 The partition
Image 63
is trivially match-constraining in the sense that 
 entails that if 
 then there is 
 from the same partition-class as t such that 
 and 
. Hence 
 also entails that
Image 64
for each
Image 8
.
Indeed: If

Image 65
where
Image 66
for some
Image 8
, say
Image 67
, then there is a shortest word
Image 9
such that 
 where
Image 68
, and the fact
Image 67
entails that for all 
 where 
 we have
Image 69
; hence each such 
 enables an a-transition (
Image 70
) while 
 enables no a-transition (
Image 71
). Hence 
 cannot be matched by any 
 for which 
; this entails that 
.
Hence each set of places

Image 3
from the collection
Image 72
for some
Image 73
is important in the sense that the equality of the values of the function
Image 74
is a necessary condition for two markings to be bisimilar. We thus have
 where for each
Image 75
we put
Image 76
for all .
In our example the collection 
 is 
 where(2) The relation 
 is not a bisimulation in general: in our example we have 
 (since the norms of 
 are, respectively, , 1 in both markings) but the transition 
 can only be matched by 
, and these two transitions cause different changes for

Image 78
since
Image 79
.
Our aim will be to (stepwise) extend the collection 
 to a collection

Image 80
of important sets for which we will achieve
Image 81
(hence the equality of the values of
Image 74
for all
Image 82
will be not only necessary but also sufficient for two markings to be bisimilar). The main idea is captured by the observation that if 
 and 
, then there is 
 such that
Image 83
, 
, and the transitions 
 cause the same changes of the values of
Image 74
for all important sets
Image 3
; this leads to natural refinements of given match-constraining partitions.
We observe that if a set

Image 3
is important in the above sense (hence 
), then also
Image 37
, i.e. the largest trap in Q, is important (since 
 entails that
Image 84
iff
Image 85
). In our case (2) we have For each important trap R, 
 simply entails that R is either marked in both 
 and 
 or unmarked in both of them. We note that the union of two important traps is an important trap; hence 
 is also important. In our example there is one more trap, namely 
; it will later turn out to be important as well. Generally, there might be traps that are not important: a simple example arises by adding a place 
 and a transition 
 to Fig. 1, with
Image 87
,
Image 88
,
Image 89
; the markings 
 and 
 are then clearly bisimilar, but the trap 
 is marked in one of them and unmarked in the other.
The idea of the presented algorithm deciding BPP-Bisim is to stepwise refine the match-constraining partition

Image 63
: if two transitions in a current partition-class cause different changes on the norm of some important set, these transitions get separated in the refined partition. The refined partition might then reveal further important sets, which might lead to a further refinement of the current match-constraining partition, etc.; this process must obviously reach a fixpoint, which presents the required collection
Image 80
for which
Image 81
. But there is a subtle point: it is intuitively clear that the mentioned fixpoint-partition will depend on which important traps are currently marked (i.e., for which important sets Q we have that the value of
Image 74
is ω); in our example in Fig. 1, the a-transitions 
 and 
 cause different changes on
Image 90
(
Image 91
), namely 23 and 14. It thus seems that 
 should be separated in the final partition; but this is not true when
Image 90
is ω (i.e., when
Image 92
is marked), in which case 
 and 
 do not influence the value of
Image 90
since this remains ω forever.
Hence we will have more “fixpoint-partitions”: each important trap R will have a related partition

Image 93
. The partition
Image 93
will be the intended match-constraining partition in the case when R is the largest unmarked important trap. The fact that there can be exponentially many important traps (e.g., the union of traps chosen out of possibly many small important traps is an important trap) makes the algorithm exponential, though realizable in polynomial space as we will show.
Let us now try to explore for which 
 we have 
 in the example in Fig. 1 in the simplest case, i.e. when the largest unmarked important trap is ∅ (in other words, when all nonempty important traps are marked). So we aim to find when 
 where(3)
 (i.e., 
 and 
), assuming that both 
 and 
 are marked in 
 as well as in 
 (i.e., 
, 
, 
, 
). In this case the norms of

Image 91
and
Image 94
are ω in all markings reachable from 
 and 
, so we can concentrate just on keeping the equality
Image 95
for
Image 96
. Let us look at the changes 
 caused by transitions t on the value of
Image 78
, hence
Image 97
; these changes are given in the next two lines.
 The values 
 give us the partition Hence we refine the initial match-constraining partition
Image 63
(1) by
Image 99
, which yields
Image 100
where(4)
 Besides 
 from (2), we have thus got the new important sets this was related to the assumption that the trap ∅ is unmarked, which holds trivially. Since
Image 102
, we have got no new important traps. Moreover, in our current case, which assumes that ∅ is the largest unmarked important trap, we also have that the values of
Image 103
and
Image 104
are ω; hence the partition 
 (4) is a fixpoint partition (since among
Image 105
, , only
Image 78
is finite, and
Image 106
), and it is thus the partition
Image 107
.
In fact, we have shown that if

Image 108
for all , then the equality
Image 109
is not only necessary but also sufficient for 
 to be bisimilar. We can verify that the relation is a bisimulation; we note that
Image 95
means 
 in the notation (3). In particular, if 
 and 
, then there is 
 from the same partition-class of  (4) as t such that 
 where 
.
Now we look at the case where the largest unmarked important trap is 
; in this situation also the important traps that are proper subsets of 
 are unmarked. To construct

Image 111
, we thus start with the meet (⊓) of the partitions
Image 93
where R are the important traps that are proper subsets of 
; in our case we have just one such trap R, namely 
. We thus start with the partition 
 given by (4), which we aim to refine by
Image 112
for those sets
Image 113
, , for which
Image 74
is finite in the current situation (when 
 is the largest unmarked important trap), hence for which
Image 114
; this holds for
Image 115
,
Image 116
, and
Image 117
(but not for
Image 118
).
E.g., the class 
 breaks down to the singleton classes 
, 
, 
 since 
, 
, 
 for

Image 119
. We stress that this does not entail that, e.g.,
Image 120
is an important set; since we have got the partition-class 
 under the assumption that 
 is unmarked, we only deduce that
Image 121
is an important set (and
Image 122
can serve for further partition-refinements by 
, to construct
Image 111
, since
Image 123
).
We can also note that a refinement of the class 
 in (4) yields the singleton class 
 since 
 while 
 for

Image 124
(as well as for other relevant Q). The new important set
Image 125
also yields a new important trap, namely
Image 126
, which is a proper superset of 
; this new important trap is marked in the currently considered situation (when 
 is the largest unmarked important trap), hence 
 for
Image 127
will play no role in constructing
Image 111
.
Now we make the above intuitively described process formal, for a fixed general BPP-net

Definition 1

(Partitions

Image 63
,
Image 112
,
Image 129
,
Image 130
of the set
Image 13
of transitions)
1.
Image 131
where
Image 132
.
2.
For

Image 3
we define:
•
Image 133
where
Image 134
(using our conventions for ω that include );

•
Image 112
is the partition of
Image 13
such that 
 and 
 are in the same class iff 
.
3.
Given a trap

Image 38
and a partition  of
Image 13
, we define:
•
Image 135
, T is a class of , and
Image 136
(hence we do not use
Image 137
where
Image 138
is larger than R);
•
Image 130
is the partition 
 that is stable, i.e.
Image 139
, and occurs in the sequence 
 where 
 and
Image 140
for .
In particular, in the normed case, when

Image 10
is an nBPP-net, we have
Image 59
. In this case, our later more general result (namely Theorem 3) entails that 
 iff
Image 2
for all
Image 141
where T is a class of the partition
Image 142
. In this case, the respective algorithm deciding 
 obviously works in polynomial time, since it just constructs the sequence
Image 143
where
Image 144
,
Image 145
for , and
Image 146
, and checks if
Image 2
for all
Image 141
where T is a class of 
.
We recall that 
 entails

Image 147
. The value 
 is thus relevant only when
Image 4
is finite; we can view the partition
Image 112
as irrelevant for M (and all markings reachable from M) when
Image 46
. This is reflected by the condition
Image 148
in defining
Image 129
in the point 3 of Definition 1 (here
Image 148
is equivalent to
Image 149
since ), which should be viewed as capturing the markings where R is the largest important trap that is unmarked.
Definition 2 below formalizes the notions of “important traps”

Image 38
, and “match-constraining partitions”
Image 93
of
Image 13
; the definition uses mutually related inductions, and also yields the notion of “important sets of places” (of the form
Image 150
where T is a class of
Image 93
). The aim of the introduced notions is clear from Theorem 3, on which a polynomial-space algorithm is built, as is shown in the proof of Theorem 4. The definition should be understandable due to the previous informal discussion; we stress that we indeed have 
 for all important sets Q but we do not claim that 
 entails that Q is important in the sense of the following technical definition.
Definition 2

(Important traps R, partitions

Image 93
, important sets
Image 150
)
•
Important traps

Image 38
and important sets
Image 3
are defined inductively as follows:
–
∅ is an important trap;

–
if R is an important trap and T is a class of

Image 93
, then
Image 150
is an important set, also called an important set related to R, and
Image 37
is an important trap;
–
if 
 and 
 are important traps, then 
 is an important trap.

•
If

Image 38
is an important trap, then the match-constraining partition related to R, denoted by
Image 93
, is the following partition of the set
Image 13
of transitions:
The chosen form of the defined notions should serve for smooth proofs of Theorem 3, Theorem 4.
We recall that for each set

Image 3
we have
Image 154
iff
Image 155
. Hence the set(5) of the important sets with finite norms in M is tightly related to the largest important trap that is unmarked in M, which is the set(6) We note that
Image 160
and 
 can only get smaller by transition performing: if 
, then
Image 161
and 
 (which is related to the fact that if 
 and
Image 46
, then
Image 162
). We will prove that 
 entails that
Image 163
, and thus 
. The aim of the (match-constraining) partition
Image 93
is to capture the matching pairs of moves 
 and 
, where
Image 164
and 
, for the pairs 
 where 
. It is thus clear that for 
 we should have
Image 165
, since the match-constraints are stronger when the set of important sets with finite norms is larger. In more detail, the inequality 
 matters in the situations when the norm of Q is finite but it does not matter when this norm is infinite. This is the reason why
Image 112
is used carefully: both
Image 166
in Definition 2 and
Image 129
in Definition 1 require that
Image 149
(and thus the norm of Q is finite in the intended situations where R is unmarked).
The above intuition is now formalized in the proofs of the announced theorems.

Theorem 3

Given a BPP-net

Image 167
, for all markings 
 we have
Proof

We put

Image 169
is an important set } and define the relation
Image 170
on the set of markings: We thus need to show that
Image 172
, i.e., We show the “if” part (soundness) and the “only-if” part (completeness) separately.
“If” (soundness, i.e.,

Image 174
).
We will show that

Image 170
is a bisimulation, which entails that
Image 174
. Let we will be done once we show that there is a transition 
 such that
Image 164
and 
 where
Image 176
. Since
Image 177
, we have
Image 163
and 
 (recall (5) and (6)). We put
Image 178
, 
, and note that (R is the largest unmarked important trap both in 
 and in 
.)
Let T be the class of

Image 93
containing 
 (for which 
). For the important set we thus have
Image 181
, since 
 for some
Image 182
due to the fact that 
 is enabled in 
. Since
Image 183
and 
, there is
Image 184
such that 
; we can thus fix some 
 that is enabled in 
. Since
Image 185
, we have
Image 164
.
Let 
 be the marking for which 
; we will show

Image 176
, by which the proof will be finished. To this aim we consider an arbitrary set
Image 186
, hence where 
 is an important trap and 
 is a class in
Image 188
, and show that
Image 189
:
•
If

Image 190
(hence
Image 191
is marked in 
 and in 
), then the claim is trivial since
Image 192
.
•
If

Image 193
(hence
Image 194
, and thus
Image 195
), then
Image 196
, and this entails that
Image 197
. Indeed:
–
either 
, in which case

Image 198
and thus
Image 199
[by Definition 2], and the fact that
Image 200
[by Definition 1, Definition 2] entails that
Image 197
,
–
or

Image 201
, hence
Image 202
, and we have
Image 197
since
Image 93
is stable (
Image 203
).
Hence 
, which entails that
“Only-if” (completeness, i.e.,

Image 205
).
We show the implication

Image 206
by using a structural induction based on Definition 2, Definition 1. First we recall that for each important trap R the definitions yield the sequence where 
 and
Image 208
for  (and
Image 209
). This leads us to an extension of the notion of important sets: we say that
Image 3
is an ext-important set if it has an -presentation, i.e.,
Image 150
where R is an important trap and 
 (hence 
).
There is a natural order on the set of presentations of ext-important sets: we say that
 We will now show that(7) Our desired implication

Image 206
is then a corollary.
We prove (7) by contradiction. Let such that w.l.o.g. we assume

Image 67
. Since
Image 213
is finite, there is a shortest word
Image 9
such that 
 where
Image 68
. By the assumption 
 we derive that there is 
 such that 
 and 
; since
Image 67
, our choice of (shortest) w entails that
Image 69
. Hence we can safely choose 
 and 
 so that We now show that 
, and 
 enables some , while 
 enables no :
•
Since

Image 215
, we have
Image 216
; in particular, no  is enabled in 
.
•
Since

Image 217
, we have
Image 218
.
If there was some  such that 
, then we had

Image 219
for some important set
Image 198
, where
Image 220
for an important trap 
 and
Image 221
. (This follows easily from the inductive definition of important traps [Definition 2].) But this would entail that
Image 222
and
Image 223
, hence
Image 224
, and the set 
 with its 
-presentation would thus violate our minimality assumption on  (since 
 related to 
 is smaller than  related to Q).
Hence 
 and

Image 225
, which entails that some  is enabled in 
.
We fix some 
 that is enabled in 
; let 
. Since 
, there must be a matching move 
 where
Image 164
and 
. Since 
, we get that(8) We now show a desired contradiction, namely the existence of an ext-important set 
 such that
1.
Image 220
where 
 is an important trap and 
;
2.
 is smaller than ;

3.
Image 194
(for the above chosen 
);
4.
 (i.e., 
 belong to different classes of

Image 227
).
This indeed yields a contradiction, since 
 and the value
Image 228
differs from the value
Image 229
, which contradicts with the minimality assumption on .
The existence of 
 satisfying conditions  follows by a simple inspection of Definition 1, Definition 2 and the following analysis, where we consider two separate cases, a) and b), while recalling the fact (8).

a)
Transitions 
 belong to different classes of

Image 230
(i.e., of 
).
In this case  (recall (8)), and 
 belong to different classes of

Image 227
for some
Image 220
where 
, 
 is an important trap,
Image 221
, and
Image 231
. (Recall
Image 230
in Definition 2.)
Since 
 is smaller than ,

Image 231
, and 
, we have
Image 194
(where the equality follows from our minimality assumption on ).
b)
There is the largest 
 such that 
 belong to the same class of 
.

By (8) we have 
, and 
 belong to different classes of

Image 232
; this entails that 
 for some
Image 233
where 
 and
Image 234
. (Recall
Image 129
in Definition 1.) 
 is smaller than , and we deduce
Image 194
as in a). □
Theorem 4

The bisimilarity problem on BPP (the problem BPP-Bisim) is in PSPACE.

Proof

Theorem 3 suggests a straightforward algorithm to decide whether 
, when given a BPP-net

Image 12
and two markings 
: A question is if such an algorithm can be implemented to run in polynomial space.
In fact, Definition 2, Definition 1 describe an inductive construction of all important sets, by constructing all important traps R and their related partitions

Image 93
, from the smaller traps with coarser partitions to the larger traps with finer partitions. A direct implementation, constructing and remembering all important traps R and their related partitions
Image 93
, yields in general an exponential-time algorithm that also uses exponential space (in the worst case); indeed: there might be many small traps for which we have to consider the union of each collection of these traps.
As already explicitly or implicitly discussed, the operations like computing

Image 4
and partitions
Image 63
,
Image 112
,
Image 129
, as well as
Image 130
are performable in polynomial time. Hence the crucial problem is to generate (and check) all important sets
Image 150
, by constructing all important traps R and their related partitions
Image 93
, while not storing all of them in memory.
We use a standard trick: instead of remembering all computed important traps and their related partitions, these are (re)computed repeatedly in the situations when they are really needed. This can be realized by two interdependent recursive procedures:

•
one boolean procedure

Image 236
returning true for
Image 38
iff R is an important trap, and
•
a procedure

Image 237
returning the partition
Image 93
of the set
Image 13
of transitions, when given an important trap R.
The procedures are described by the pseudocodes in Fig. 2.
Fig. 2
Download : Download high-res image (94KB)
Download : Download full-size image
Fig. 2. Pseudocodes of two crucial procedures.

We note that the depth of recursion in the invocations of

Image 238
and
Image 239
is at most
Image 240
: the argument
Image 241
in every recursive invocation of these procedures is a proper subset of the argument
Image 242
of the invoking procedure. It is also obvious that each individual invocation
Image 243
of the procedures uses at most polynomial space, when not counting the space used by the invocations that
Image 243
causes, so the total amount of memory used by these procedures can be indeed bounded by a polynomial. □
4. Distance-to-disabling functions (on general LTSs)
In this section we briefly look at the previous proof of Theorem 3 from a more general perspective. If we consider the problem of deciding bisimilarity on an LTS we can think of various properties of two states 
 that are necessary for them to be bisimilar. A simplest such property is that the sets of enabled actions must be the same for both 
 and 
; equivalently, the sets of disabled actions must be the same for both of them.

Let us call a predicate  bisimulation-invariant if 
 entails that 
. Instead of  we also write , or simply . More generally, a function  (where  is any set, maybe a set of numbers) is bisimulation-invariant if 
 entails 
. Hence for any set  of some bisimulation-invariant functions we have 
, where
 We call such a set  sound if 
. (From another viewpoint, such  could be also called “full” or “complete”.)

In fact, in Theorem 3 we have implicitly used that a set of inductively defined “distance-to-disabling functions” constitutes an example of a sound set of bisimulation-invariant functions. This is formalized below, for general LTSs.

Definition 5

We assume an LTS

Image 6
.
•
Given a predicate , the distance-to-P function is 
 where 
 is the length of a shortest

Image 9
such that 
 and 
. If there is no such sequence, we put 
 (in which case we have 
 for all 
 that are reachable from s).
•
Let 
 be 
 for some predicate P. The change on d caused by a transition 
 is 
 where 
. (By our conventions,  iff 
, even if  as well).

•
Given a tuple 
 of functions 
, and a tuple 
 of values 
, for , we define the predicate

Image 245
, for each
Image 8
, as follows:
 (Hence
Image 247
iff either 
 for some 
 in 
, or there is a transition 
 for which 
 for all .)
•
The set  of distance-to-disabling functions on , or of DD-functions on  for short, is the least set of functions of the type 
 for which we have:

for all

Image 8
, 
, and 
, where , 
 and 
 for , the function
Image 248
, denoted by 
, belongs to .
We note that the predicate
Image 249
(where  and the tuples 
, 
 are empty) is true for the states  where a is disabled (i.e., there is no 
 such that 
). The functions 
 can be also viewed as constituting a base case of an inductive definition of the set .
Proposition 6

Given an image-finite LTS

Image 250
, i.e. the set 
 is finite for each pair
Image 251
, the set  is a sound set of bisimulation-invariant functions, hence
Proof

Soundness (
)

We show that 
 is a bisimulation. For the sake of contradiction, suppose that 
, i.e., 
 for all , and let 
 be such that for each transition 
 we have 
. There is some transition 
 since otherwise 
 (which contradicts with 
). Since there are only finitely many 
 such that 
 (since  is image-finite), there are finitely many 
 such that 
 for all  and for each such 
 (
) there is  for which 
. We thus derive that

Image 252
and
Image 253
for 
 and 
 where 
 (for all ); but this entails that 
, which contradicts with 
.
Completeness (
); this part does not depend on the image-finiteness of .

We will show that 
 entails 
 for all , by using the inductive definition of . It thus suffices to show that 
 entails 
 for where

Image 8
, 
, and 
, assuming (by the induction hypothesis) that 
 for 
.
For the sake of contradiction, we suppose that 
 and 
. Then there is a shortest word

Image 9
such that 
 where 
, which entails that
Image 255
, and thus also 
 for all . Since 
, there is 
 such that 
, 
, and 
; hence
Image 256
but 
 for all  (since 
).
We thus have 
 where 
 for all . Since 
, we have 
 where 
; we thus cannot have that 
 and 
 are empty, since

Image 257
means that a is disabled in 
. Nevertheless, we necessarily have 
 for some . We have thus got 
 where 
 for some ; this contradicts with (the induction hypothesis) 
. □
We note that the LTSs

Image 11
for BPP-nets
Image 10
are image-finite, and the respective functions
Image 258
correspond to the functions
Image 74
for certain sets Q of places; this also entails that the sets
Image 259
are finite, in fact. Some remarks about this issue are added in the next section.
5. Some remarks on related research and open problems
The author conjectured in [1] that the technique of distance-to-disabled functions, presented in the case of (strong) bisimilarity on the class BPP, could turn out useful also for showing decidability of weak bisimilarity on BPP. In this case we also consider silent transitions 
 where τ denotes a silent (i.e. internal) action of the systems. Then each move 
 can be matched by a “long” move 
, i.e. by a sequence(9)
 a move 
 can be also matched by 
. Nevertheless, the conjecture has not been confirmed so far, and the decidability of weak bisimilarity on BPP remains open. It is known to be semidecidable [18] but a crucial problem is that the respective LTSs, with transition-relations 
 (for

Image 260
) are not image-finite (since there is no bound on τ-sequences, which can thus generate multisets of arbitrary sizes). For normed BPP, this problem was handled in [19] for a finer equivalence called branching bisimilarity, another established behavioural equivalence (see, e.g. [20]). Here the τ-moves in the matching sequence (9) are required to not change the equivalence-class.
The problem of decidability of branching bisimilarity was studied also by Yuxi Fu, but for the related model of normed BPA processes (where transitions are of the type 
 where α is a finite sequence rather than a finite multiset). He answered this decidability question positively in [16], by introducing a nice notion of a norm that is defined semantically: instead of counting the smallest number of moves needed to reach the empty process, we count the smallest number of equivalence-class changes on paths to the empty process. Unlike the standard (“syntactic”) norm, such a semantic norm is not clearly computable. Nevertheless, reasoning about this norm allowed Fu to derive a decision algorithm and proving its correctness. Fu's result initiated a research effort to clarify the complexity of this decidable problem. An original observation that EXPTIME-hardness should follow by Mayr's result for weak bisimilarity [21] turned out not so obvious, but was nicely confirmed in [22]. Regarding the upper bound, there are two papers published at the same conference, [23] and [24], and one journal paper [25]. We note that the decidability questions for unnormed versions, of BPP and BPA, are open for both weak bisimilarity and branching bisimilarity.

We finish with a note on (strong) bisimilarity on BPA. Unlike for BPP, the complexity is not fully clarified so far. The problem is known to be EXPTIME-hard [26] and in 2-EXPTIME (claimed in [27] and explicitly proven in [28]). Though in this case the respective labelled transition systems are image-finite, the set of distance-to-disabling functions for a given LTS is generally infinite, unlike the case of BPP that has been studied in this paper.