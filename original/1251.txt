Abstract
The complexity classes PPA-k, k≥2, have recently emerged as the main candidates for capturing the complexity of important problems in fair division, in particular Alon's Necklace-Splitting problem with k thieves. Indeed, the problem with two thieves has been shown complete for PPA = PPA-2. In this work, we present structural results which provide a solid foundation for the further study of these classes. Namely, we investigate the classes PPA-k in terms of (i) equivalent definitions, (ii) inner structure, (iii) relationship to each other and to other TFNP classes, and (iv) closure under Turing reductions.

Keywords
Computational complexity
TFNP
Necklace Splitting

1. Introduction
The complexity class TFNP is the class of all search problems such that every instance has a least one solution and any solution can be checked in polynomial time. It has attracted a lot of interest, because, in some sense, it lies between P and NP. Moreover, TFNP contains many natural problems for which no polynomial-time algorithm is known, such as Factoring (given a integer, find a prime factor) or Nash (given a bimatrix game, find a Nash equilibrium). However, no problem in TFNP can be NP-hard, unless NP = co-NP [29]. Furthermore, it is believed that no TFNP-complete problem exists [32], [34]. Thus, the challenge is to find some way to provide evidence that these TFNP problems are indeed hard.

Papadimitriou [32] proposed the following idea: define subclasses of TFNP and classify the natural problems of interest with respect to these classes. Proving that many natural problems are complete for such a class, shows that they are “equally” hard. Then, investigating how these classes relate to each other, yields a relative classification of all these problems. In other words, it provides a unified framework that gives a better understanding of how these problems relate to each other. TFNP subclasses are based on various non-constructive existence results. Some of these classes and their corresponding existence principle are:

•
PPAD: given a directed graph and an unbalanced vertex (i.e., out-degree ≠ in-degree), there must exist another unbalanced vertex.

•
PPA: given an undirected graph and vertex with odd degree, there must exist another vertex with odd degree (Handshaking Lemma).

•
PPP: given a function mapping a finite set to a smaller set, there must exist a collision (Pigeonhole Principle).

Other TFNP subclasses are PPADS, PLS [25], CLS [11], PTFNP [20], EOPL and UEOPL [15]. It is known that ,  and . Very recently it was shown that in fact  [14]. Any separation between TFNP subclasses would imply P ≠ NP, but various oracle separations exist [2], [31], [4], [5] (see Section 2 for more details).
TFNP subclasses have been very successful in capturing the complexity of natural problems. The most famous result is that the problem Nash is PPAD-complete [10], [7], but various other natural problems have also been shown PPAD-complete [9], [6], [8], [26]. Many local optimisation problems have been proved PLS-complete [25], [33], [27], [13], [12]. Recently, the first natural complete problems were found for PPA [16], [17] and PPP [35]. The famous Factoring problem has been partially related to PPA and PPP [22].

Necklace-Splitting. The natural problem recently shown PPA-complete is a problem in fair division, called the 2-Necklace-Splitting problem [17]. For , the premise of the k-Necklace-Splitting problem is as follows. Imagine that k thieves have stolen a necklace that has beads of different colours. Since the thieves are unsure of the value of the different beads, they want to divide the necklace into k parts such that each part contains the same number of beads of each colour. However, the string of the necklace is made of precious metal, so the thieves don't want to use too many cuts. Alon's famous result [1] says that this can always be achieved with a limited number of cuts.

The corresponding computational problem can be described as follows. We are given an open necklace (i.e., a segment) with n beads of c different colours, i.e., there are 
 beads of colour i and 
. Furthermore, assume that for each i, 
 is divisible by k (the number of thieves). The goal is to cut the necklace in (at most)  places and allocate the pieces to the k thieves, such that every thief gets exactly 
 beads of colour i, for each colour i. By Alon's result [1], a solution always exists, and thus the problem lies in TFNP.

The complexity of this problem has been an open problem for almost 30 years [32]. While the 2-thieves version is now resolved, the complexity of the problem with k thieves () remains open. The main motivation of the present paper is to investigate the classes PPA-k, which are believed to be the most likely candidates to capture the complexity of k-Necklace-Splitting. Indeed, in the conclusion of the paper where they prove that 2-Necklace-Splitting is PPA-complete, Filos-Ratsikas and Goldberg [17, arXiv version] mention:

“What is the computational complexity of k-thief Necklace-splitting, for k not a power of 2? As discussed in [30], [28], the proof that it is a total search problem, does not seem to boil down to the PPA principle. Right now, we do not even know if it belongs to PTFNP [20].

Interestingly, Papadimitriou in [32] (implicitly) also defined a number of computational complexity classes related to PPA, namely PPA-p, for a parameter . [...] Given the discussion above, it could possibly be the case that the principle associated with Necklace-Splitting for k-thieves is the PPA-k principle instead.”

PPA-p. The TFNP subclasses PPA-p were defined by Papadimitriou almost 30 years ago in his seminal paper [32]. Recall that the existence of a solution to a PPA problem is guaranteed by a parity argument, i.e., an argument modulo 2. The classes PPA-p are a generalisation of this. For every prime p, the existence of a solution to a PPA-p problem is guaranteed by an argument modulo p. In particular, . Surprisingly, these classes have received very little attention. As far as we know, they have only been studied in the following:

•
Papadimitriou [32] defined the classes PPA-p and proved that a problem called Chevalley-mod-p lies in PPA-p and a problem called Cubic-Subgraph lies in PPA-3.

•
In an online thread on Stack Exchange [23], Jeřábek provided two other equivalent ways to define PPA-3. The problems and proofs can be generalised to any prime p.

•
In his thesis [24], Johnson defined the classes 
 for any , which were intended to capture the complexity of counting arguments modulo k. He proved various oracle separation results involving his classes and other TFNP classes. While the PPA-p classes are not mentioned by Johnson, using Jeřábek's results [23] it is easy to show that 
 for any prime p. In Section 6, we characterise 
 in terms of the classes PPA-p when k is not prime. In particular, we show that 
 only partially captures existence arguments modulo k.

Our contribution. In this paper, we use the natural generalisation of Papadimitriou's definition of the classes PPA-p to define PPA-k for any . We then provide a characterisation of PPA-k in terms of the classes PPA-p. In particular, we show that PPA-k is completely determined by the set of prime factors of k. In order to gain a better understanding of the inner structure of the class PPA-k, we also define new subclasses that we denote PPA- and investigate how they relate to the other classes. We show that PPA- is completely determined by the set of prime factors of .

Furthermore, we provide various equivalent complete problems that can be used to define PPA-k and PPA- (Section 4). While these problems are not “natural”, we believe that they provide additional tools that can be very useful when proving that natural problems are complete for these classes. In Section 7, we provide an additional tool for showing that problems lie in these classes: we prove that PPA-
 (p prime, ) and PPA- () are closed under Turing reductions. On the other hand, we provide evidence that PPA-k might not be closed under Turing reductions when k is not a prime power.

Finally, in Section 6 we investigate the classes 
 defined by Johnson [24] and provide a full characterisation in terms of the classes PPA-k. In particular, we show that 
 if k is a prime power. However, when k is not a prime power, we provide evidence that 
 does not capture the full strength of existence arguments modulo k, unlike PPA-k. This characterisation of 
 in terms of PPA-k leads to some oracle separation results involving PPA-k and other TFNP classes (using Johnson's oracle separation results).

We note that a significant fraction of our results were also obtained by Göös, Kamath, Sotiraki and Zampetakis in concurrent and independent work [21]. In their work, they have also provided the first “natural” complete problem for the classes PPA-p (a variant of Chevalley-mod-p), namely the first complete problem that does not involve circuits or other computational devices in its description. The present work, and in particular the equivalent characterisations of the classes PPA-k, have been pivotal in subsequent work [18] showing that the k-Necklace-Splitting problem lies in PPA-k under Turing reductions. However, the question of whether k-Necklace-Splitting is also PPA-k-hard remains open.

2. Preliminaries
TFNP. Let 
⁎
 denote the set of all finite length bit-strings and for 
⁎
 let  be its length. A computational search problem is given by a binary relation 
⁎
⁎
. The problem is: given an instance 
⁎
, find an 
⁎
 such that , or return that no such s exists. The search problem R is in FNP (Functions in NP), if R is polynomial-time computable (i.e.,  can be decided in polynomial time in ) and there exists some polynomial p such that . Thus, FNP is the search problem version of NP (and FNP-complete problems are equivalent to NP-complete problems under Turing reductions).

The class TFNP (Total Functions in NP [29]) contains all FNP search problems R that are total: for every 
⁎
 there exists 
⁎
 such that . With a slight abuse of notation, we can say that P lies in TFNP. Indeed, if a decision problem is solvable in polynomial time, then both the “yes” and “no” answers can be verified in polynomial time. In this sense, TFNP lies between P and NP.

Note that TFNP problems are not promise problems, i.e., we are not allowed to restrict the instance space 
⁎
. This means that for any instance in 
⁎
, there must always exist at least one solution. Nevertheless, TFNP can indirectly capture various settings where the instance space is restricted. For example, if a problem R in FNP is total only on a subset L of the instances and , then we can transform it into an equivalent TFNP problem by adding  to R for all instances .

Reductions. Let R and S be total search problems in TFNP. We say that R (many-one) reduces to S, denoted , if there exist polynomial-time computable functions  such that Note that if S is polynomial-time solvable, then so is R. We say that two problems R and S are (polynomial-time) equivalent, if  and .

There is also a more general type of reduction. A Turing reduction from R to S is a polynomial-time oracle Turing machine that solves problem R with the help of queries to an oracle for S. Note that a Turing reduction that only makes a single oracle query immediately yields a many-one reduction.

Encoding of sets. Many of the computational problems we consider in this paper involve Boolean circuits whose output is interpreted as a set. For example, it will often be the case that a circuit C takes as input a bit-string in 
 and outputs a set of at most m bit-strings in 
. We will denote this by 
. Of course, a Boolean circuit has a fixed number of output bits and so the circuit will in fact be of the form 
, for some t that is sufficiently large so that there are enough bits to encode any set of size at most m. It is easy to see that taking  is enough. Indeed, we can for example use the following encoding: the set 
, , is represented by the bit-string 
. Clearly, we can efficiently check whether a bit-string in 
 is a valid representation of a set, and if not, we can just interpret it as the empty set 
.

PPA. The class PPA (Polynomial Parity Argument) [32] is defined as the set of all TFNP problems that many-one reduce to the problem Leaf [32], [2]: given an undirected graph with maximum degree 2 and a leaf (i.e., a vertex of degree 1), find another leaf. The important thing to note is that the graph is not given explicitly (in which case the problem would be very easy), but it is provided implicitly through a succinct representation.

The vertex set is 
 and the undirected graph is represented by a Boolean circuit 
. By this we mean that for any 
, we interpret  as the set of potential neighbours of x, where we syntactically enforce that . We say that there is an edge between x and y if  and . Thus, every vertex has at most two neighbours. Note that the size of the graph can be exponential with respect to its description size.

The full formal definition of the problem Leaf is: given a Boolean circuit 
 representing an undirected graph on the vertex set 
 such that 
 (i.e., 
 is a leaf), find

•
 such that  (another leaf)

•
or  such that  but  (an inconsistent edge)

Type 2 problems and oracle separations. We work in the standard Turing machine model, but TFNP subclasses have also been studied in the black-box model. In this model, one considers the type 2 versions of the problems, namely, the circuits in the input are replaced by black-boxes. In that case, it is possible to prove unconditional separations between type 2 TFNP subclasses (in the standard model this would imply P ≠ NP). The interesting point here is that separations between type 2 classes yield separations of the corresponding classes in the standard model with respect to any generic oracle (see [2] for more details on this). This technique has been used to prove various oracle separations between TFNP subclasses [2], [31], [4], [5]. In Section 6 we provide some oracle separations involving PPA-k and other TFNP subclasses.

On the other hand, any reduction that works in the type 2 setting, also works in the standard setting. Indeed, it suffices to replace the calls to the black boxes by the corresponding circuits that compute them. In this paper, our reductions are stated in the standard model, but they also work in the type 2 setting, because they don't examine the inner workings of the circuits.

3. Definition of the classes
3.1. PPA-k: polynomial argument modulo k
For any prime p, Papadimitriou [32] defined the class PPA-p as the set of all TFNP problems that many-one reduce to the following problem, that we call Bipartite-mod-p: We are given an undirected bipartite graph (implicitly represented by a circuit) and a vertex with degree  (which we call the trivial solution). The goal is to find another such vertex. This problem lies in TFNP: if all other vertices had degree , then the sum of the degrees of all vertices on each side would have a different value modulo p, which is impossible.

The problem remains well-defined and total if p is not a prime, and so we will instead define it for any . Let us now provide a formal definition of the problem. A vertex of the bipartite graph is represented as a bit-string in 
, where the first bit indicates whether the vertex lies on the “left” or “right” side of the bipartite graph. The graph will be represented by a Boolean circuit that outputs a set of potential neighbours, just as we did for Leaf. Instead of at most two neighbours, here we allow at most k neighbours (see Remark 1 for why this is enough). Note that we can syntactically enforce that the graph is bipartite, i.e., that a vertex 0x can only have neighbours of the type 1y and vice versa.

Definition 1

Bipartite-mod-k [32]
Let . The problem Bipartite-mod-k is defined as: given a Boolean circuit 
 representing a bipartite graph on the vertex set 
 with 
, find

•
 such that 

•
or  such that  but .

Here the trivial solution is the vertex 
. The first type of solution corresponds to a vertex with degree . The second type of solution corresponds to an edge that is not well-defined. We can always ensure that all edges are well-defined by doing some pre-processing. Indeed, in polynomial time we can construct a circuit 
 such that all solutions are of the first type and yield a solution for C. On input 0x the circuit 
 first computes 
 and then for each i removes 
 from this set, if 
.
Remark 1

Note that in this problem statement we require that all degrees lie in . This is easily seen to be equivalent to the more general formulation where vertices can have more than k neighbours. Indeed, any vertex that has more than k edges can be split into multiple copies such that all the copies have 0 or k edges, except for one copy which is allowed to have any number of edges in . A solution of the original instance is then easily recovered from a solution of this modified instance. Note that since the set of neighbours is given as the output of a circuit, it will have length bounded by some polynomial in the input size and so this argument can indeed be applied.

Definition 2

PPA-k [32]
For any , the class PPA-k is defined as the set of all TFNP problems that many-one reduce to Bipartite-mod-k.

As a warm-up let us show the following:
Proposition 1

[32]
PPA-2 = PPA

Proof

Recall that PPA can be defined using the canonical complete problem Leaf [32], [2]: given an undirected graph where every vertex has degree at most 2, and a leaf (i.e., degree =1), find another leaf. This immediately yields PPA-2 ⊆ PPA, since Bipartite-mod-2 is just a special case of Leaf where the graph is bipartite.

Given an instance of Leaf with graph 
 we construct an instance of Bipartite-mod-2 on the vertex set 
 as follows. For any 
 we have a vertex 
 on the left side of the bipartite graph. For any edge  ( ordered lexicographically) we have a vertex 
 on the right side of the bipartite graph and we create the edges 
 and 
. All other vertices in 
 are isolated. In polynomial time we can construct a circuit that computes the neighbours of any vertex. Furthermore, 
 is a leaf, if and only if 
 has degree 1. Finally, all vertices on the right-hand side have degree 0 or 2. □

3.2. PPA-: fixing the degree of the trivial solution
In the definition of the PPA-k-complete problem Bipartite-mod-k (Definition 1) the degree of the trivial solution 
 can be any number in . In this section we define more refined classes where the degree of the trivial solution is fixed. In Section 5, these classes will be very useful to describe how the PPA-k classes relate to each other. These definitions are inspired by the corresponding “counting principles” studied in Beame et al. [3] that were also defined in a refined form in order to describe how they relate to each other. We believe that these refined classes will also be useful to capture the complexity of natural problems. Note that for , the degree of the trivial solution will always be 1 and thus the question does not even appear in the study of PPA.

Definition 3

Let  and . The problem Bipartite-mod- is defined as Bipartite-mod-k (Definition 1) but with the additional condition 
.

Note that this problem remains in TFNP, since the condition can be checked efficiently.
Definition 4

PPA-
Let  and . The class PPA- is defined as the set of all TFNP problems that many-one reduce to Bipartite-mod-.

If k is some prime p, then these classes are not interesting. Indeed, it holds that PPA- = PPA-p for all . This can be shown using the following technique: take multiple copies of the instance and “glue” the trivial solutions together. If p is prime, then any other degree of the glued trivial solution can be obtained (by taking the right number of copies). In fact this technique yields the stronger result:
Lemma 1

If 
 divides 
, then PPA-
 ⊆ PPA-
.

Proof

Since 
 divides 
, there exists  such that 
. Given an instance of Bipartite-mod-
, take the union of m copies of the instance, i.e., 
 vertices on each side (and any additional isolated vertices needed to reach a power of 2). Then, merge the m different copies of the trivial solution into one (by redirecting edges to a single one). This vertex will have degree 
. Finally, apply the usual trick to ensure all degrees are in  (Remark 1). □

In particular, we also get the nice result PPA- = PPA-. Applying the result to the case , we get that PPA- = PPA-, PPA- = PPA-, as well as PPA- ⊆ PPA- and PPA- ⊆ PPA-. Thus, we have three “equivalence classes” ,  and {3} and the relationships  and . In Section 5, we will show that  corresponds to PPA-3, {3} to PPA-2 and  to PPA-2 ∩ PPA-3.

Now let us introduce some notation that will allow us to precisely describe the relationship between PPA-k and the PPA-.

Definition 5

& operation [5]
Let 
 and 
 be two TFNP problems. Then the problem 
 is defined as: given an instance 
 of 
, an instance 
 of 
 and a bit , find a solution to 
.

This operation is commutative and associative (up to many-one equivalence). Indeed, 
 is many-one equivalent to 
, and 
 is many-one equivalent to 
. Since the & operation is associative, the problem 
 is well-defined up to many-one equivalence. It is also equivalent to the following problem: given instances 
 of 
 and an integer , find a solution to 
.
We extend the & operation to TFNP subclasses in the natural way. Let 
 and 
 be TFNP subclasses with complete problems 
 and 
 respectively. Then 
 is the class of all TFNP problems that many-one reduce to 
. Note that the choice of complete problems does not matter. Intuitively, this class contains all problems that can be solved in polynomial time by a Turing machine with a single oracle query to either 
 or 
.

Using this definition we obtain:

Lemma 2

For all  we have PPA-k = 
 
 PPA-.

Proof

One containment immediately follows from the fact that  for all . For the other containment, note that for any instance I of Bipartite-mod-k we can easily compute  such that I is also an instance of Bipartite-mod-. □

Together with Lemma 1, Lemma 2 yields, e.g., PPA-6 = PPA- & PPA-.

4. Equivalent definitions
In this section we show that PPA-k can be defined by using other problems instead of Bipartite-mod-k. The totality of these problems is again based on arguments modulo k. By showing that these problems are indeed PPA-k-complete, we provide additional support for the claim that PPA-k captures the complexity of “polynomial arguments modulo k”. While these problems are not “natural” and thus not interesting in their own right, they provide equivalent ways of defining PPA-k, which can be very useful when working with these classes. In particular, we make extensive use of these equivalences in this work.

The TFNP problems we consider are the following:

•
Imbalance-mod-k: given a directed graph and a vertex that is unbalanced-mod-k, i.e., out-degree − in-degree , find another such vertex.

•
Hypergraph-mod-k: given a hypergraph and a vertex that has degree , find another such vertex or a hyperedge that has size ≠k.

•
Partition-mod-k: given a set of size  and a partition into subsets, find a subset that has size ≠k.

As usual, the size of the graph (respectively hypergraph, set) can be exponential in the input size, and the edges (resp. hyperedges, subsets) can be computed efficiently locally. We also define the corresponding problems Imbalance-mod-, Hypergraph-mod- and Partition-mod- analogously. The formal definitions of all these problems are provided in Section 4.1.
Theorem 1

Let  and .

•
Imbalance-mod-, Hypergraph-mod-, Partition-mod- are PPA--complete,

•
Imbalance-mod-k, Hypergraph-mod-k, Partition-mod-k are PPA-k-complete.

In his online post [23], Jeřábek proves that Bipartite-mod-3, Imbalance-mod-3 and Partition-mod-3 are equivalent and (correctly) claims that the proof generalises to any other prime. Thus, our contribution is the definition of the problems for any  (and the ℓ-parameter versions) and the generalisation of the result to any  (not only primes) and to the ℓ-parameter versions of the problems, as well as to the new problem Hypergraph-mod-k. The proof of Theorem 1 can be found in Section 4.2.

The problem Imbalance-mod-k is a generalisation of the PPAD-complete problem Imbalance [2], [19]: given a directed graph and a vertex that is unbalanced (i.e., out-degree − in-degree ≠0), find another unbalanced vertex. It is known [19] that in Imbalance we can assume without loss of generality that the given vertex has imbalance exactly 1. As a result, Imbalance trivially reduces to Imbalance-mod-k, and thus Theorem 1 also yields1:

Corollary 1

For all , we have PPAD ⊆ PPA-k.

Furthermore, if we use the convention that  if and only if , then Imbalance-mod-0 actually corresponds to Imbalance. Thus, in a certain sense we could define . On the other hand, Imbalance-mod-1 is a trivial problem.

4.1. Formal definitions
Imbalance. A directed graph on the vertex set 
 is represented by Boolean circuits 
 that output the successor and predecessor set of a given vertex, respectively. As before, it is enough to consider the case where the in- and out-degree of any vertex is at most k, since the general case reduces to this (analogously to Remark 1). We syntactically enforce that  and we interpret  (respectively, ) as the set of potential successors (respectively, predecessors) of x. There is a directed edge from x to y if  and . The following problem was defined by Jeřábek [23], but only for prime k and without the ℓ-parameter version.

Definition 6

Let . The problem Imbalance-mod-k is defined as: given Boolean circuits 
 representing a directed graph on the vertex set 
 with 
, find

•
 such that 

•
or  such that  but , or  but .

For , Imbalance-mod- is defined with the additional condition 
.
Hypergraph. A hypergraph on the vertex set 
 is represented as follows. For every vertex 
, a circuit 
 outputs the set  of all hyperedges containing x, where each hyperedge is a set of vertices in 
. As usual, we only need to consider the case where every vertex is contained in at most k hyperedges and every hyperedge has size at most k. A hyperedge 
 exists in the hypergraph, if all the vertices involved indeed agree that it is present, i.e., if 
 for all .

Definition 7

Let . The problem Hypergraph-mod-k is defined as: given a Boolean circuit 
 representing a hypergraph on the vertex set 
 with 
, find

•
 such that 

•
or x such that  contains a hyperedge of size ≠k

•
or  such that  and  are not consistent with one another.

For , Hypergraph-mod- is defined with the additional condition 
.
Note that for  this problem essentially corresponds to the PPA-complete problem Leaf and its (equivalent) generalisation Odd [32], [2]: given an undirected graph and a vertex with odd degree, find another one.
Partition. A partition of 
 is represented by a Boolean circuit 
 as follows: 
 lies in the subset given by the orbit of x with respect to C, i.e., 
, where 
 (i times). The problem we define below is based on the simple observation that a base set of size  cannot be partitioned into sets of size k. The base set consists of all elements in 
 except for m elements that have been removed, for some 
 such that 
. Here it is convenient to identify 
 with 
 in the natural way. Thus, we can think of the base set as simply being 
.

Definition 8

Partition-mod-k
Let . The problem Partition-mod-k is defined as: given 
 with 
 and a Boolean circuit 
, such that  for all , find

•
 and  such that 
 and , 

•
or 
 such that 

where  means that d divides k.
For , Partition-mod- is defined with the additional condition 
.

The condition “ for all ” corresponds to excluding elements that do not lie in the base set and it can be enforced syntactically. The first solution type corresponds to finding a set in the partition such that its size divides k (but is ≠k), while the second solution type corresponds to finding a set such that its size does not divide k. Note that a solution is guaranteed to exist since 
.
The definition of this problem is inspired by the 
 problems defined by Buss and Johnson [5] (for prime ) and by Johnson [24] (for any ). In Section 6 we argue that, unlike the problem defined above, the 
 problems only partially capture the complexity of arguments modulo k (when k is not a prime power). The problem was also defined by Jeřábek [23], but only for k prime and without the ℓ-parameter version. Finally, note that Partition-mod-2 essentially corresponds to the PPA-complete problem Lonely [2].

The definition of this problem can be modified in various ways without changing its complexity. For instance, the first solution type can be changed to simply ask for  such that 
 for some . We have defined the problem in a slightly more complicated way to make the connection with the 
 problems more immediate (see Section 6). Yet another equivalent way of defining the problem would be to consider a Boolean circuit 
 where 
 is interpreted as the set containing x in the partition. A solution would then be any  with  or any  witnessing an inconsistency in the partition given by C.

4.2. Proof of Theorem 1
We omit some details that are easy to fill in. For example, when given an instance of Imbalance-mod-, we assume that all the edges are well-defined, i.e., solutions of the second type never occur. Indeed, given a generic instance of the problem, it can be reduced to an instance where this holds by modifying the circuits so that they check and correct the successor/predecessor list before outputting it. Note that in the new instance only solutions of the first type can occur, but they can yield a solution of the second type of the original problem. The same observation also holds for Bipartite-mod- (edges well-defined), Hypergraph-mod- (hyperedges well-defined) and Partition-mod- (size of any subset divides k).

Image 1
: We construct a hypergraph on the vertex set 
. We identify every vertex u of the hypergraph with the vertex 0u on the left-hand side of the bipartite graph. The hyperedges are given by the vertices on the right-hand side of the bipartite graph. More precisely, if for every right-hand side vertex 1v we let  be the set of neighbours (on the left-hand side), then the set of hyperedges is exactly 
. Note that given 
, we can find all the hyperedges containing u in polynomial time. Furthermore, since the vertex 
 has degree ℓ in the bipartite graph, the corresponding vertex 
 in the hypergraph will also have degree ℓ. It is easy to check that any solution of the Hypergraph-mod- instance (in particular also any hyperedge that does not have size k) yields a solution to the Bipartite-mod- instance.
Image 2
: We construct a directed graph on the vertex set 
. For each vertex u of the hypergraph there is a vertex 
 in the directed graph (e.g., 
) and for each hyperedge e of the hypergraph there is a vertex 
 in the directed graph (e.g., 
 where 
 is ordered lexicographically). We put a directed edge from 
 to 
 iff  (i.e., iff e appears in the hyperedge list of u). All other vertices are isolated. Note that 
 has imbalance ℓ and for any vertex in 
 we can compute the predecessors and successors in polynomial time. If there is an imbalance modulo k in a vertex 
, then the corresponding hyperedge e does not have size k. If there is an imbalance modulo k in a vertex 
, then u has degree  in the hypergraph.
Image 3
: Consider an instance of the problem Imbalance-mod-. Split every vertex v into two vertices 
 and 
, such that 
 gets all the incoming edges and 
 gets all the outgoing edges. If v was balanced, i.e., in-deg(v) = out-deg(v) =d, then we add  edges from 
 to 
. We can assume that out-deg(
) =ℓ and in-deg(
) =0 (just create a copy of 
 that takes in-deg(
) incoming and outgoing edges), and thus out-deg(
) =ℓ and in-deg(
) =0. Note that we are using multi-edges, which are not allowed in the definition of the problem. However, this is not an issue, since this is just an intermediate step of the reduction. This new instance has the property that no vertex has both incoming and outgoing edges. Furthermore, any solution (i.e., a vertex with in- or out-degree not in , except 
) yields a solution of the original instance.
Thus, we can assume wlog that the Imbalance-mod- instance (with multi-edges) is such that no vertex has both incoming and outgoing edges. We construct an instance of Partition-mod- on the set 
. Every vertex u of the directed graph has k corresponding elements in the set 
, namely 
, …, 
. If u does not have any outgoing edges, then 
 form a subset of the partition, i.e., 
. If u has outgoing edges to 
 (, ordered lexicographically), then for every  we put 
 in a subset that we denote 
. 
 are put into isolated subsets, i.e., 
 for all . Note that if v has k incoming edges, then 
 will contain k elements. Given any element 
, we can compute all the elements in its subset in polynomial time (and thus efficiently construct C that cycles through them in lexicographic order). Furthermore, since out-deg(
) =ℓ, the vertices 
 will be in singleton sets. Consider the subset of 
 
. Then 
. It is easy to check that any element in X that is not contained in a subset of size k (according to C), must yield a solution to the Imbalance-mod- instance. Finally, the last step is to construct an efficient bijection between X and the set of all integers 
, which is easy to do. Thus, we have reduced the original instance to an instance of Partition-mod- with inputs 
 and C (modified according to the bijection).

Image 4
: Let us consider any instance  of Partition-mod- with parameter n. In particular, it holds that 
 and 
. We construct a bipartite graph as follows. The vertex sets on the left and right side are 
 and 
 respectively. We can define a canonical partition of the numbers 
 into sets of size k (and one set of size ℓ). For example, , , etc. Each set of the canonical partition corresponds to a vertex in A as follows: a set containing k numbers 
 is represented by the vertex 
. For the set of size ℓ in the canonical partition, we introduce a special case: it is represented by 
. Note that many vertices in A will not correspond to any set of the canonical partition. For a number , we let  denote the vertex in A representing the set containing x in the canonical partition.
Another partition of the numbers 
 into sets of size at most k is given by the instance  of Partition-mod-. Similarly to what we did above, we can associate each set in the partition given by C with a vertex in B. We let  denote the vertex of B representing the set containing x in the partition given by C. Note that for any vertex in A or B we can efficiently determine whether it represents a set of one of the two partitions and if so, which set exactly it represents.

For every  we add an edge between  and , i.e., between the sets that contain x in the two different partitions. This construction might introduce multi-edges (if some x and y lie in the same set in both partitions) but this can easily be resolved by using the Mitosis gadgets described below. It is easy to see that for any vertex of the bipartite graph we can efficiently compute the set of all its neighbours. Finally, note that the vertex 
 has degree ℓ, and any other vertex with degree  must necessarily lie in B and correspond to a set in the partition given by C that contains strictly less than k elements. Thus any such vertex immediately yields a solution to the original Partition-mod- instance.

Mitosis gadgets. Let . We now show how to construct a small bipartite graph such that exactly one vertex on each side has degree 1 and all other vertices have degree k (or 0). This “gadget” can then be used to increase the degree of two vertices (one on each side of the bipartite graph) without adding any solutions, i.e., vertices with degree .

The gadget is a bipartite graph with  vertices on each side: 
 and 
. It contains all the edges 
 for , except the edge 
. It also contains the edges 
 and 
. Thus, all vertices have degree k, except for 
 and 
 which have degree 1.

We call this the “Mitosis” gadget, because it allows us to duplicate edges that already exist. Let u and v be two vertices in a bipartite graph, one on each side. Furthermore, consider the case where there is an edge . We would like to increase the degree of u and v by 1, but without introducing any new solutions, in particular without introducing any vertex with degree . Using the Mitosis gadget, we can just add new vertices 
 and 
, and identify 
 with u and 
 with v. Adding the corresponding vertices of the gadget yields a bipartite graph where the degree of u and v has increased by 1, but no new solutions have been introduced. Note that this gadget can, in particular, be used to turn a bipartite graph with multi-edges into one without them, without changing the degree of existing vertices and without adding any new solutions.

5. Relationship between the classes
In this section, we present some results that provide deeper insights into how the classes relate to each other. For any ,  denotes the set of all prime factors of k. The main conceptual result is that PPA-k is entirely determined by the set of prime factors of k:

Theorem 2

For any  we have PPA-k =  
  PPA-p.

This equation can be understood as saying the following:

•
Given a single query to an oracle for PPA-k, we can solve any problem in PPA-p for any 

•
Given a single query to an oracle that solves any PPA-p problem for any , we can solve any problem in PPA-k.

Corollary 2

In particular, we have:

•
For 
, if 
, then PPA-
 ⊆ PPA-
.

•
For all 
, PPA-
 = PPA-
 & PPA-
.

•
For all  and all  we have PPA-
 = PPA-k.

Using the PPA- classes, we can formulate an even stronger and more detailed result. For any , , we define . In this case the conceptual result says that PPA- is entirely determined by the set of prime factors of .

Theorem 3

For any integer constants k and ℓ with  and , it holds that 
  
 

The proof of Theorem 3 can be found in the next section. Before we move on to that, let us briefly show that Theorem 2 follows from Theorem 3.
Proof of Theorem 2

Using Lemma 2 and Theorem 3 we can write
 
 
  
  where the last equality follows by noting that  for all ℓ, and  for all . □

5.1. Proof overview
Proof of Theorem 3

All containment results follow from Theorem 4 below, except 
  
 

Let 
. We will show how to combine a set of instances 
, …, 
, where 
 is an instance of Partition-mod-
, into a single instance of Partition-mod-, where 
, such that any solution to this instance yields a solution to one of the 
 instances. Without loss of generality, we can assume that the parameter n is the same for all 
 instances. Without loss of generality, we can assume that 
 for all i, because we can add at most 
 sets of size 
 to achieve this (see the proof of Lemma 5). Note that we then have 
. Furthermore, for 
 and 
 with 
 we can define  if and only if 
 for all i, where 
 means that 
 and 
 lie in the same set in instance 
. If for all i, 
 lies in a set of size 
 in 
, then x will lie in a set of size s. Thus any solution yields a solution to one of the original instances. The details to fully formalise this are very similar to the proof of Lemma 6. □

In [3] Beame et al. investigated the relative proof complexity of so-called “counting principles”. These counting principles are formulas that represent the fact that a set of size  cannot be partitioned into sets of size k. They investigated the relationship between these principles in terms of whether one can be proved from the other by using a constant-depth, polynomial-size Frege proof. Their main result is a full characterisation of when this is possible or not. As noted by Johnson [24], these counting formulas do not yield NP search problems, but they can be related to corresponding NP search problems (TFNP, in fact). Indeed, Johnson uses this connection to obtain some separation results between his 
 classes (see Section 6) from Beame et al.'s negative results. Our contribution is using Beame et al.'s positive results in order to prove inclusion results about the PPA- classes. More precisely, we modify their proofs to obtain polynomial-time reductions between our Partition-mod- problems. Thus, we obtain the following analogous result:

Theorem 4

Let 
 and 
 for . If 
, then 
.

Proof

From Lemma 1 we know that PPA-
 = PPA-
 for . The result then follows from a few technical lemmas proved in Appendix A:
 
 
 
 
 
 □

6. Johnson's 
 classes and oracle separations
Inspired by the definition of the PPA-complete problem Lonely [2], Buss and Johnson [5] defined TFNP problems called 
 to represent arguments modulo some prime p. Their main motivation was to use these problems to show separations (in the type 2 setting) between Turing reductions with m oracle queries and Turing reductions with  oracle queries. In his thesis [24], Johnson generalised the definition of 
 to any  and defined corresponding classes 
. He also proved some separations between these classes and other TFNP classes in the type 2 setting (which yield oracle separations in the standard setting). It seems that Johnson was not aware of Papadimitriou's [32] PPA-p classes.

In this section, we study the classes 
 and prove a characterisation in terms of the classes PPA-p. In particular, we show that 
 does not capture the full strength of arguments modulo k, when k is not a prime power. This characterisation also allows us to use Johnson's separations to obtain some oracle separations involving PPA-k and other TFNP classes.

Informally, the problem 
 can be defined as follows. We are given a partition of 
 into subsets and the goal is to find one of these subsets that has size ≠k. If k is not a power of 2, then such a subset must exist. If k is a power of 2, then we instead consider 
 and the problem remains total.

Definition 9

 [5], [24]
Let . The problem 
 is defined as: given a Boolean circuit C with n inputs and outputs,

•
If k is not a power of 2: Find

–
 and  such that 
 and , 

–
or 
 such that 

•
If k is a power of 2: Let additionally 
 and find

–
 and  such that 
 and , 

–
or 
 such that 

where 
 (ℓ times) and  means that d divides k.
Definition 10

 [24]
For any , the class 
 is defined as the set of all TFNP problems that many-one reduce to 
.

Note that the problem 
 is a special case of our problem Partition-mod-k (which was indeed inspired by this definition). As a result, we immediately get that 
. Unless k is a prime power, we don't expect this to hold with equality. The intuition is that restricting the size of the base set to always be a power 2 has the effect of only achieving a subset of the possible ℓ-parameter values of PPA-. Namely, only 
 are achieved (for k not a power of 2).
Johnson proves a lemma [24, Lemma 7.4.5] that gives some idea of how the 
 classes relate to each other. It can be stated as follows: if 
, where the 
 are distinct primes, then 
. He proves this if all 
 and claims that the proof also works if some 
. However, if some 
 then the proof does not work. This is easy to see, since our results below prove that 
 which is not equal to 
, unless 
. However, Johnson proves that 
 in the type 2 setting.

The following result provides a full characterisation of 
 in terms of the classes PPA-p.

Theorem 5

Let .

•
If k is not a power of 2, then 
 where 
 is the largest odd divisor of k

•
If k is a power of 2, then 
.

The proof of Theorem 5 is given below in Section 6.1.

Corollary 3

In particular, we have:

•
for all primes p and , 

•
for all , 

•
for all odd , 

If k is a prime power, then 
 is the same as PPA-k. However, for other values of k, we argue that 
 fails to capture the full strength of arguments modulo k. For example, 
, whereas . This means that PPA-15 can solve any problem that lies in PPA-3 or PPA-5, while 
 can only solve problems that lie both in PPA-3 and PPA-5. In particular, if 
, then it would follow that , which is not believed to hold (see oracle separations below). Even worse perhaps, is the fact that 
 for any . In particular, this means that 
, which indicates that 
 does not really capture arguments modulo 6.

Nevertheless, Johnson's oracle separation results (obtained from the corresponding type 2 separations as in [2]) also yield corresponding results for the PPA-k classes (using Theorem 5). We briefly mention a few of the results obtained this way. See Johnson [24, Chapter 8] for additional results. Relative to any generic oracle (see [2]):

•
 for any distinct primes 

•
, ,  for any 

•
,  for any prime p

6.1. Proof of Theorem 5
For , 
 corresponds to the PPA-complete problem Lonely [2], and thus 
. Let . Consider an instance  of Partition-mod-
 on the set 
. Without loss of generality, assume . Then 
 and thus 
. This means that we can (efficiently) partition  into subsets of size 
, leaving only 
 out. Thus, we have reduced Partition-mod-
 to 
. Since 
 (Theorem 3), we obtain 
. On the other hand we also have 
 by Corollary 2.

Consider some  that is not a power of 2. First, let us show that 
. 
 reduces to 
 by splitting every subset into two subsets of size k (or less, if the subset has size ). Conversely, consider an instance of 
 on the set 
. Make a copy of the instance, thus obtaining an instance on the set 
. For every subset of the original instance, take the union with its copy. If the subset had size k, the new subset has size 2k. Thus, we have reduced to 
.

Let  be coprime with 2. We will show 
. Consider an instance of 
 on the set 
. Since k and 2 are coprime, there exists  such that 
 (e.g., by using Euler's theorem). Thus, we take 
 copies of the instance and obtain an instance on the set 
, which is an instance of Partition-mod- (with ), since 
. Conversely, consider an instance  of Partition-mod- on the set 
. As before, there exists  such that 
. We construct an instance 
 of 
 on 
 as follows. The element 
 of the original instance corresponds to the element 
 of the new instance. If , set 
. The number of elements that have not yet been assigned to a subset is 
. Thus, we can efficiently partition them into subsets of size k without introducing any solution. We have obtained an instance of 
.

7. Many-one vs Turing reductions
Theorem 6

For any prime , PPA-p is closed under Turing reductions.

In particular, PPA-
 = PPA-p is also closed under Turing reductions. The proof of Theorem 6 can be found in Section 7.1. Furthermore, we also obtain:

Corollary 4

For all  and , PPA- is closed under Turing reductions.

Proof of Corollary 4

Using Theorem 3, we have 
, where we let 
. Consider a Turing reduction from some problem to PPA-. Since 
, this yields a Turing reduction to PPA-
, in particular. By Theorem 6, it follows that there exists a many-one reduction to PPA-
, i.e., the problem lies in PPA-
. Since this holds for all 
, the result follows. □

If k is not a prime power, then it is not known whether PPA-k is closed under Turing reductions. Using our results from Section 6, we can actually provide an oracle separation between PPA-k and the Turing-closure of PPA-k, i.e., an oracle under which PPA-k is not closed under Turing reductions. Let 
 be TFNP problems. Following Johnson [24] we define 
 as the problem: given instances 
, where 
 is an instance of 
, solve 
 for all j. As we did with the & operation, with a slight abuse of notation, we can also use the operation ⊗ with the PPA-k classes. In [24, Theorem 7.6.1], Johnson proved that for  and distinct primes 
, 
 
 does not many-one reduce to 
 
 in the type 2 setting. Together with our Theorem 2, Theorem 5 this yields:

Theorem 7

Let  not a power of a prime. Relative to any generic oracle, it holds that 
. In particular, relative to any generic oracle, PPA-k is not closed under Turing reductions.

 corresponds to solving PPA-p for all prime factors p of k simultaneously. In particular, this can be done by using  queries to PPA-k, i.e., a Turing reduction to PPA-k. Thus, S lies in the Turing closure of PPA-k, but not in PPA-k (relative to any generic oracle).

7.1. Proof of Theorem 6
We essentially apply the same technique that was used by Buss and Johnson [5] to show that PPA, PPAD, PPADS and PLS are closed under Turing reductions.

Let Π be a problem that Turing-reduces to some problem in PPA-p. This means that there exists a Turing machine M with access to a PPA-p-oracle that solves Π in polynomial time. Since Imbalance-mod-p is PPA-p-complete (Theorem 1), we assume that the oracle provides solutions to Imbalance-mod-p instances. Our goal is to show that all the oracle queries can be combined into a single one. Indeed, a Turing reduction that always uses a single oracle query immediately yields a many-one reduction. Thus, by the definition of PPA-p, this would yield .

We begin by showing that any Imbalance-mod-p-instance can be efficiently transformed into an instance that has a particular form, namely: the starting node has imbalance +1 (in-degree 0 and out-degree 1), and any solution has imbalance −1 (in-degree 1 and out-degree 0). This can be achieved by the following steps:

1.
Ensure that all vertices have in- and out-degree at most p (by splitting vertices into multiple copies).

2.
Ensure that any unbalanced vertex has in- or out-degree 0 (by creating a copy that will take all the edges that yield the imbalance).

3.
Since p is prime, we can ensure that the starting vertex has imbalance +1.

4.
Ensure that all vertices that have imbalance , actually have imbalance +1 or −1 (by splitting every such vertex into p vertices, each getting at most one edge).

5.
Transform every solution that has imbalance +1 into  solutions with imbalance −1 instead (by pointing to  new vertices).

From now on we assume that all Imbalance-mod-p-instances have this form. Given an instance I of problem Π, let 
 denote the first oracle query made by M on input I, where 
 is the Imbalance-mod-p graph (represented implicitly by circuits) and 
 is the starting vertex. From now on we omit the superscript I for better readability. For any solution 
 to 
, let 
 be the second oracle query made by M, if the first query returned 
. We construct a big graph G that contains a copy of 
 and a copy of 
 for each solution 
 of 
. A vertex u in 
 is represented as 
 in G. For each such 
, we add an edge from 
 to 
. Note that these two vertices are now balanced. Thus, the instance 
 has the following property: all solutions are of the form 
, where 
 is a solution to 
, and 
 is a solution to 
. The straightforward generalisation of this construction for a polynomial number of queries (instead of 2), yields a graph G such that any solution yields consistent query answers for a complete run of M on input I. Thus, we obtain a Turing reduction that only needs to make one oracle query and then simulates M with these query answers.

It remains to show that this graph G can be constructed in polynomial time from I, i.e., we can efficiently construct circuits that compute the edges incident on any given node. This is easy to see, because any node contains enough information to simulate a run of M up to the point that is needed to determine the neighbours in G. We omit the full details, since the formal arguments are analogous to the ones in the corresponding proofs in [5], [24].