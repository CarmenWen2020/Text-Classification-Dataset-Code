Abstract
Attribute-Based Group Signature (ABGS) schemes permit any group member with required attributes to generate signatures for the sake of the group anonymously. Even though existing ABGS schemes with Verifier-local Revocation (VLR) method facilitate efficient user and attribute revocation, they cannot achieve stronger security for the users and user attributes. In this paper, we present a new approach to overcome this weakness delivering a new ABGS scheme with VLR that achieves stronger security, almost full anonymity, for both users and their attributes. We construct our scheme from lattices as lattice cryptography is quantum resist. Moreover, we present a simple member joining protocol and a new zero-knowledge argument system that supports the new scheme. Finally, we prove that the proposed scheme meets the security requirements of almost full anonymity, traceability, and non-frameability.

Keywords
Almost full anonymity
Attribute-based group signatures
Verifier-local revocation
Member registration
Lattice cryptography

1. Introduction
Chaum and van Heyst [2] put forwarded Group Signature (GS) schemes in 1991. The naive group signature schemes facilitate anonymity and traceability. While the anonymity ensures the signer's identity is secured, the traceability guarantees to reveal the correct signer of the given signature if required. Thus, the group signatures grant any group member to produce a signature using his secret keys while hiding in the crowd. On the other hand, group signatures privilege the authorities to cancel the anonymity of the signatures. As a result of these two components, anonymity and traceability, people tend to secure their systems like e-commerce systems, IoT systems, and digital-right management systems with the group signature schemes. For instance, company A may require a signature from company B for a document. Any authorized person like the financial department manager of company B can send off a signature sake of the company. However, company A cannot identify that the financial department manager produced the signature. He can only know that the particular company sent the signature. In a requirement of investigation, company B's high authority can identify the financial department manager as the signer. However, when it comes to different scenarios, where the required signers should satisfy the verifier's conditions, traditional group signature schemes cannot be applied merely.

In 2007, Khader [3] suggested a new variant of group signatures called Attribute-based Group Signatures (ABGS) answering the requirement of conditional signing. ABGS requires the signer to be a group member with the required attributes. The members of an ABGS scheme have secret signing keys that are given based on the possessing attributes. Thus only a member, who can satisfy the required attributes, can produce a signature. For instance, company A requires the signer of company B to be at least a junior manager from the financial department or a senior manager from the Human Resource department. ABGS ensures that only group members, who have the required attributes, can generate a valid signature anonymously. After the proposal of ABGS by Khader [3], there has been a subsequent line of works [4], [5], [6], [7], [8] in different flavors. For instance, Emura et al. [7] delivered a dynamic property for attributes. The constructions provided by Ali and Amberker [5] hide the attributes used for signing, i.e., achieve attribute anonymity. Moreover, Veronika et al. [8] gave a generic framework for ABGS. Even so, most of the previous constructions of group signatures and attribute-based group signatures are not secure in front of quantum computers.

Lattice-cryptography seems to be the most eminent solution for quantum attacks. It offers strong security proofs based on the worst-case hardness of the lattice problems and efficient implementation. In 2010, Gorden et al. [9] delivered the first lattice-based group signature scheme. Since then, numerous group signature schemes were presented with different aspects, resolving the matter of the increasing size of the public key with the members' count [10], providing strong security [11], efficient member revocation [12], and member registration [13]. Recently, Kuchta et al. [14] submitted the first attribute-based group signature scheme from lattice assumptions. In their scheme, they suggested a new zero-knowledge argument system for the ABGS scheme with member registration. Later, Zhang et al. [15] delivered a new ABGS scheme based on lattices facilitating member revocation by employing Verifier-local Revocation (VLR).

The revocation mechanism, Verifier-local Revocation (VLR), was first suggested by Brickell [16] in 2003. Then Boneh et al. [17] formalized VLR in their group signature scheme. VLR administrates the revocation process via tokens. Thus VLR group signature schemes assign tokens to each member of the group. To remove a member, the authority has to add the particular member's token to a list. We call this list Revocation List (RL). The signature verifiers get the latest revocation list. In most settings, since the number of signature verifiers is less than the number of group members, the group manager can easily update the verifiers. The use of the token system and updating only the verifiers make VLR an efficient revocation mechanism. Moreover, VLR-GS has an implicit tracing mechanism identifying the signer by executing the verification algorithm for all the member revocation tokens until the signer is detected. As in GS schemes, using VLR, we can manage attribute revocation in the attribute-based group signature schemes [18], [19]. In VLR-ABGS schemes, the manager can revoke any group member's attributes, which the member does not hold anymore, without affecting the other members or other attributes. The manager can add revoking attribute tokens to RL. However, while showing efficient revocation, VLR shows a weakness regardless of the security. VLR schemes fulfill a weaker security notion called Selfless-Anonymity. Thus, the recently proposed ABGS scheme with VLR from lattice assumptions [15] also achieved a low-level of security.

Comparing to full-anonymity, which was declared in [20] for the static group settings, the selfless-anonymity is a much weaker security notion. The full-anonymity requires the signatures to be anonymous even though an outsider (possibly be an attacker) knows all the user secret signing keys. In traditional VLR schemes, the tokens are part of the secret signing keys. Since revealing secret signing keys provides free access to tokens, which supports destroying the owner's anonymity, we cannot achieve the full-anonymity in traditional VLR signature schemes. Thus, the construction of traditional VLR schemes settles in the selfless-anonymity.

1.1. Difficulties of achieving full-anonymity for VLR schemes
Traditional VLR group signature (VLR-GS) schemes satisfy a weaker security notion, namely, selfless anonymity. Besides, group signature schemes without the VLR mechanism can achieve a strong security version of anonymity, called full-anonymity. In full anonymity, we assume even an outsider, probably an adversary, sees all the users' secret signing keys; he still cannot distinguish the signer. Moreover, the adversary can query any signature (except the challenging signature) to understand the signer.

In traditional VLR group signature schemes, providing all the users' secret keys to the adversary makes the scheme insecure. VLR group signature scheme's users have a secret property called tokens, which is a part of their secret signing keys. While each member (user) has a token in VLR group signature schemes, in VLR-ABGS schemes, each user attribute has a revocation token. This token is used to maintain the status of the related user or attribute. Thus, to expel a group member, the group manager adds the revoking member token to the revocation list (RL) and transfers RL to the verifier. Accordingly, the verifier can confirm that the signer of a given signature is not being revoked. In VLR-ABGS schemes, when removing a user's attribute, the related attribute-token is added to RL and passes to the verifiers. As a result, any member cannot generate a valid signature with withdrawn attributes to succeed in the signature verification step.

Most of the lattice-based VLR signature schemes [12], [15] also construct the tokens as a part of the secret signing keys. For instance, the token of a member in the lattice-based scheme in [12] is the combination of the first vector of the secret signing key and the first matrix of the public key. In the lattice-based VLR-ABGS scheme in [15], the secret signing key of an attribute is a concatenation of two vectors. The first vector of the secret signing key and the public key's first matrix is the attribute token. In this case, if the secret signing key of any user or attribute is revealed to the adversary, then he can retrieve the related token and realize the signer. The adversary can execute the verification algorithm for the given signature while treating each revocation token as a revoked token to confirm the related token owner generated the signature. In other words, exposing secret signing keys breaks the anonymity of users in traditional VLR schemes. Because of these limitations, naive VLR-GS schemes and VLR-ABGS schemes could not meet the full-anonymity requirements. Thus, they relied on the weaker security, the selfless-anonymity.

Even though achieving stronger security for VLR-GS and VLR-ABGS schemes is desirable, it requires significant amendments in the settings and algorithms in VLR-GS and VLR-ABGS schemes. In the GS scheme of [21], Perera and Koshiba discussed a method that allows the adversary to access all the users' secret signing keys without the revocation tokens. Thus they achieve stronger user anonymity, the almost-full anonymity, in their VLR fully dynamic group signature scheme. Their scheme assists both member registration and member revocation.

We propose a fully dynamic ABGS scheme with member registration and VLR for attributes and users by employing the almost-full anonymity idea.

1.2. Contribution
This paper addresses achieving strong security for VLR-ABGS schemes. It extends the VLR-ABGS scheme given in [1] to support member registration via a simple member joining protocol and proposes a new VLR-ABGS scheme with a new key-generation method. Moreover, this paper amends the signing and verification algorithms of [1] to support the signer to prove the verifiers that he has a valid secret signing key and a member certificate, and his attributes are not being revoked. Thus, it provides a new underlying interactive argument system in Section 4 to convince the signers' validity to the signature verifiers in zero-knowledge.

The simple joining protocol facilitates new users to select secret signing keys as they wish and issues member certificates for valid users. To achieve strong anonymity for signers and their attributes, we employ the techniques in [21] and achieve almost-full anonymity. Accordingly, we make the revocation tokens of the user's attributes as a part of the membership certificate. Thus in our scheme, adversaries can access all user secret signing keys without the revocation token part. Because the adversary can get the secret signing keys of all the users without retrieving the tokens, the scheme can achieve the almost-full anonymity. Thus our scheme satisfies stronger security than the traditional VLR-ABGS schemes and becomes the first VLR-ABGS scheme that fulfills the almost-full anonymity. Since the users do not require to show their tokens' validity separately at the signing time, it decreases the signers' burden. Moreover, we deliver a new zero-knowledge interactive protocol. The scheme in [21] is for the GS scheme, not for the ABGS scheme. Thus we need to propose a new underlying zero-knowledge argument to support our VLR-ABGS scheme to convince the verifier that the attributes used for signing satisfy the given predicate and they are valid. The new protocol supports persuading the verifier that the signer, indeed a valid group member with required attributes, and his attribute tokens are not being revoked. To this end, the signer's secret keys and the member certificate should satisfy the pre-defined statements with public keys. Since the signer's keys should be kept secret, the signer uses masking parameters to satisfy those statements. Finally, we prove almost-full anonymity, traceability, and non-frameability of the proposed scheme as in [21].

1.3. Our results
In this paper, we present a new fully dynamic ABGS scheme with reasonable privacy for users. Compared to the known previous lattice-based ABGS schemes, i.e., ABGS scheme with member registration [14] and VLR-ABGS scheme [15], the proposing scheme is advantageous as it provides member registration and member and attribute revocation. Moreover, compared to the previous VLR-ABGS scheme [15] it achieves stronger anonymity for users and attributes.

Table 1 compares the efficiency and security of the proposed scheme with the existing ABGS schemes. The terms gpk, sk, and sig refer to group public key, user secret key, and signature. Terms reg and rev mean member registration and revocation, respectively. Moreover, anon means anonymity, trace means traceability, and q-res is referred to quantum resistance. The standard ABGS scheme presented by Khader [18] and the quantum-safe ABGS scheme presented by Ali et al. [14] satisfy strong anonymity, i.e., full anonymity (FA) for users against CPA and CCA adversaries. On the other hand, existing member revocable ABGS schemes that employ the efficient revocation method called verifier-local revocation (VLR) satisfy a weaker security notion called selfless-anonymity (SA). The proposing quantum-safe VLR-ABGS scheme satisfies somewhat stronger anonymity called almost-full anonymity (AFA) for group users and attributes. The first three schemes [18], [19], [14] mentioned in Table 1 satisfy full-traceability (FT). Our scheme achieves traceability and non-frameability separately. Thus we mention that our proposal satisfies traceability (trace), not full traceability.


Table 1. Comparison with known related ABGS schemes.

Scheme	gpk size	sk size	sig. size	reg	rev	anon	trace	q-res
[18]				no	yes	FA	FT	no
[19]				no	yes	SA	FT	no
[14]	
yes	no	FA	FT	yes
[15]	
no	yes	SA	trace	yes
Ours	
yes	yes	AFA	trace	yes
Given the security parameter λ, integer . Let 
 be the maximum number of group members,  is the universal attribute set size, and  is the number of attributes possess by a user. Let  be the threshold value.

Compared to the existing lattice-based (q-res) related works [14], [15] the proposing scheme enjoys group public key (gpk) and secret signing keys (sk) with bit-size 
 and 
. The user-selected secret key size is 
. However the size of the member certificate received at the member registration is 
. Thus one can argue that the user input keys at the signing are secret key and certificate, and the total user key input size is 
. The proposing scheme shows improved efficiency. Moreover, it supports member registration (reg) and member and attribute revocation (rev). The existing schemes did not support both together. ABGS schemes satisfy user anonymity (anon) and traceability (trace). ABGS scheme with member registration [14] mentioned that the scheme achieves attribute anonymity other than achieving full anonymity and full traceability. On the other hand, the work with the VLR-ABGS scheme [15] states that the scheme satisfies selfless-anonymity (SA), attribute-anonymity, traceability, and non-frameability. Selfless anonymity is a weaker security notion. The proposing quantum-resistant scheme achieves stronger security, almost-full anonymity for users. Moreover, it achieves attribute-anonymity, traceability, and non-frameability. In the proposing scheme, we achieve non-frameability separate from traceability. Since an attacker can generate non-traceable signatures with dummy users by corrupting the group manager, we cannot achieve full anonymity for ABGS schemes with member registration. Thus we achieve traceability. However, even with a corrupted group manager, we can achieve non-frameability for the scheme. We define those security notions in Section 3 and prove these security notions in Section 6. Thus the proposing scheme satisfies reasonably stronger security for VLR-ABGS.

1.4. Organization
The remainder of this paper structures as below. In Section 2, we recall the necessary definitions and relevant background of our work. We present the high-level idea of our lattice-based-VLR-ABGS scheme with member registration in Section 3. In Section 4, we provide the construction of the supporting zero-knowledge argument system, and in Section 5, we give the construction of the new scheme from lattices. In Section 6, we prove the security of the scheme. Finally, we conclude our paper in Section 7.

2. Primitives
In this section, we outline some notations and cryptographic primitives which we use in this paper.

2.1. Notations
Throughout this paper, we denote all the matrices by bold upper-case letters such as A and vectors by bold lower-case letters such as x. We express the concatenation of matrices as  and vectors as . If 
, its Euclidean norm and infinity norm are denoted by  and 
 respectively. For any vector 
, by replacing each entry of v by its binary expansion, we obtain 
. For any integer , we present a set of integers  by [p]. If S is a finite set, we express its size by .  indicates its permutations of p elements and  denotes that b is sampled from a uniformly random distribution D. The standard notations of  and ω are used to classify the growth of functions. All algorithms are of base 2.

Let  and the sequence of integers 
 be as follows.

.

2.2. Discrete Gaussian distribution
We consider a discrete Gaussian distribution with respect to a lattice.

For 
 and c with real , we express a Gaussian function centered in c as 
. Over a lattice Λ, , we define the discrete Gaussian distribution as 
. Since 
 is also a lattice, we can express a discrete Gaussian distribution for 
.

2.3. Lattices
We concern about q-ary lattices, for some prime .

Definition 1

For , and prime , q-ary lattices 
 and 
 are defined as
 where 
 is an arbitrary matrix and 
.

2.4. Hardness assumptions
We construct our scheme based on the hardness of the following lattice problems.

Definition 2

Approximate shortest independent vector problem (
) [22]
For a given basis B of a full-rank n-dimensional lattice  find a set 
 of n linearly independent lattice vectors for all , where 
 and λ is the length of the nonzero lattice vector. Here, 
 is the first successive minima of  (i.e., the length of the shortest non-zero vector in ) and 
 is the n'th successive minima of .

Definition 3 Learning with errors (LWE)

For integers , and , a vector 
, and the Gaussian error distribution χ, the distribution 
 is obtained by sampling 
 uniformly at random and choosing , and outputting the pair (
). LWE problem (decision-LWE problem) requires to distinguish LWE samples from truly random samples 
.

For a prime power q, , and distribution χ, solving 
 problem is at least as hard as solving 
 (Shortest Independent Vector Problem), where 
 [23], [24].

Definition 4 Small integer solution (SIS) and inhomogeneous small integer solution (ISIS)

Given uniformly random matrix 
 and a vector 
, find non-zero vector 
 such that , 
 and , 
 respectively.

For any m, , and , solving 
 problem or 
 problem with non-negligible probability is at least as hard as solving 
 problem, for some 
 [23], [11].

2.5. Lattice-related algorithms
•
GenTrap(n, m, q). For given integers , and sufficiently large , this efficient randomized algorithm outputs a matrix 
 and a trapdoor matrix 
, where the distribution of A is negl(n)-far from the uniform distribution.

2.6. Zero-knowledge argument of knowledge
We work with statistical zero-knowledge argument systems called interactive protocol systems. An interactive protocol system has two properties; zero-knowledge property and soundness property. While the zero-knowledge property retains against any cheating verifier, the soundness property holds against computationally bounded cheating provers.

For any x, its witness set  is the set of w such that , where R is some relation in NP language. In a zero-knowledge proof system, the prover and the verifier share a common string s. The prover persuades the verifier that he knows a specific property x with witness w and satisfying some relation R with respect to the commonly known string s, such that .

Definition 5

A two party game () is called an interactive argument system for the relation R with soundness error ϵ, if the following two conditions satisfy.

1.
Completeness. 

2.
Soundness. Even a cheating prover 
 cannot persuade the verifier  to falsely accept x on a randomly selected s:

Definition 6

An interactive proof system for relation R is zero-knowledge if there exists a random polynomial time simulator  such that for any , the two sets () and  are polynomially distinguishable.


3. Attribute-based group signature scheme with VLR and member registration
We propose an ABGS scheme from lattices that supports member registration, that provides member and attribute revocation, and that achieves stronger security, the almost full anonymity for both users and their attributes. In this section, we define the VLR-ABGS scheme with member registration and related security definitions, and we give an overview of our new attribute-based group signature scheme.

Our scheme consists of six algorithms, and in the request of tracing a signer, our scheme traces the signer using an implicit tracing mechanism as in VLR signature schemes [12], [15]. Moreover, the new scheme satisfies the security requirements, traceability, and non-frameability other than the almost-full anonymity. Since non-frameability can be achieved, even the group manager is corrupted, we prove traceability and non-frameability separately.

3.1. VLR-ABGS scheme with member registration
Definition 7

A VLR-ABGS Scheme with member registration includes of six algorithms, namely, Setup, KeyGen, Join, Sign, Verify, and Revoke.

•
Setup: On input the security parameter λ and selected universal attribute set , this algorithm results a set of public parameters pp.

•
KeyGen: On input the set of public parameters pp, this algorithm outputs a group public parameter gpk, and the group manager's secret key gmsk.

•
Join: On input the public parameter pp and the group public key gpk, this algorithm facilitates a new user, who selected his secret and public keys (sk, pk) to communicate with the group manager to receive the member certificate. For a valid user, this algorithm outputs the member certificate cert.

•
Sign: On input the public parameters pp, the group public key gpk, the secret signing key sk, the member certificate cert, the possessing attribute set S, a message M, and a policy Γ (access attribute tree/predicate) this algorithm returns a signature Σ.

•
Verify: On input the public parameters pp, the group public key gpk, the policy Γ, message-signature pair (M, Σ), and the revocation list RL, this deterministic algorithm returns 1 if the signature Σ is valid and the signer and his attributes are valid against RL. Otherwise it outputs 0.

•
Revoke: On input the public parameters pp, the group public key gpk, the revocation list RL, and the tokens set to be revoked 
, this algorithm adds tokens in 
 to RL and returns the updated RL.

3.2. Correctness and security definitions
Definition 8 Correctness

For all , for all , and , the VLR-ABGS scheme with member registration is correct if

, where for any user  with attribute set 
, for any message M, and for all 
.

Here, the secret signing key  is selected by the user b before joining the group.

Definition 9 Almost full anonymity

An VLR-ABGS scheme with member registration is almost-fully anonymous if the advantage of adversary  in winning the following experiment 
 is negligible.




⁎
⁎

Select 
⁎
⁎
⁎

⁎

Return 1 if 
, else return 0.

The adversary  gets all the existing users' secret keys (sk) and he can query Join, Open, and ReqCert oracles. When he accesses the Join oracle with a new user secret key and attribute set, the oracle returns a member certificate. When he accesses the Open oracle with a signature Σ, the oracle returns the index i of the signer. He can request member certificates of users through the ReqCert oracle. However, at the challenging phase, the adversary  cannot select 
 and 
 from the users that he knows the member certificate, i.e., that he introduced or that he requested the certificate. The member certificate consists of revocation tokens. Moreover, the attribute sets of both 
 and 
 should satisfy the given predicate Γ, i.e., 
. Otherwise, using different sets of attributes, the signer can be recognized. After receiving challenging signature 
⁎
, the adversary can access oracles as before without querying details related to 
 or 
.

An ABGS scheme is almost-fully anonymous for any PPT adversary , if the advantage

 is negligible.

Definition 10 Traceability

An VLR-ABGS scheme with member registration is traceable if the advantage of adversary  in winning the following experiment 
 is negligible.




⁎
⁎
⁎
⁎

If 
⁎
⁎
⁎
⁎
, then return 0.

If the (implicit) tracing algorithm traces to a user i, where i is used in querying ReqKey oracle, then return 0.

If 
⁎
 is obtained from querying Sign oracle, then return 0.

Otherwise return 1.

The adversary  gets the group public key (gpk), and he can request secret signing keys of any user via the ReqKey oracle and signatures via the Sign oracle for selected inputs. In traditional signature schemes, when the adversary requests the user's secret signing key with index d, the challenger returns the user's secret signing key, produced based on the index d. Since the member certificate maintains this relation in our scheme, we return both the secret signing key and member certificate.

An ABGS scheme is traceable for any PPT adversary , if the advantage

 is negligible.

Definition 11 Non-frameability

An VLR-ABGS scheme with member registration is non-frameable if the advantage of adversary  is winning the following experiment 
 is negligible.



⁎
⁎
⁎
⁎

If 
⁎
⁎
⁎
⁎
, then return 0.

If the (implicit) tracing algorithm traces to a user i, where , then return 1.

The adversary  gets the group public key and the group manager's secret key gmsk. Thus he can behave as a corrupted group manager. He adds new users to the group and updates the new user list RU. Finally, he will generate a signature that traces back to a user who is not in the list RU. An ABGS scheme is non-frameable for any PPT adversary , if the advantage

 is negligible.

3.3. Overview of the new scheme
The new scheme, VLR-ABGS scheme with member registration, offers three significant features: simple member registration protocol, efficient revocation for attributes and members via VLR method, and stronger privacy for signers almost-full anonymity. Moreover, it ensures the signers' privacy and prevention of forgeries using the underlying zero-knowledge argument system.

We concern threshold-ABGS with VLR and member registration. Thus a signer should satisfy at least t attributes from the required  attributes in the predicate Γ. We construct our ABGS scheme from lattices. Thus the security of the scheme is based on the hardness of the SIS and LWE problems. Moreover, we build the underlying ZK-protocol using the linearity properties of LWE and SIS. To convince the verifiers, the signer's validity in zero-knowledge without revealing the signer's secret information, we use permuting, extending, and masking techniques on those secret variables as explained in Section 4. Thus without seeing the original signer properties, the verifier knows that the signer is valid or not if the signer provided details can satisfy the pre-agreed statements.

In this section, we concisely explain the new scheme and use of lattices in our scheme.

In this scheme, we enable simple user joining protocol as in [21] for member registration. In our scheme, compared to the scheme in [1] there is an extra matrix 
 and a vector 
 in the public key, that supports users to select their secret keys. The user can select his secret signing key and relevant public key. If the user joins with a valid secret key, then the group manager selects a fresh ℓ-bit id and a revocation token for the user. Unlike in [21], in our new VLR-ABGS scheme, the user token consists of a set of tokens related to his attribute set. The group manager issues the member certificate using user id and revocation tokens.

There is a set of universal attributes in size u and each attribute i has a public vector 
. First a user who wants to join the group selects a secret key (sk), a short vector 
 and another short vector 
 as user public key (pk), where . The user signs v using his long term secret key usk and sends to the group manager with the possessing attribute set 
. We presume that each user has a long term public and secret key pair upk, usk for a digital signature as in [21] and [13]. Once the group manager receives v and 
, he validates v is not used before and selects a fresh ℓ bit string as the user index d and a vector 
 for each attribute in 
 such that 
 and 
, where 
, for 
 public keys, and 
. The group manager selects random vectors z, such that 
 for attributes in universal set but not possessed by the user. Then the group manager saves new member details and sends member certificate 
 to the user. Here, 
 and 
 is the revocation token of related attribute. Thus user revocation token 
.

A user signs a message using his secret key and member certificate, if he can satisfy the given predicate  as in [15] and [1]. The predicate  demands the signer to possess at least t attributes out of . At the time of signing equipped with the secret key x and member certificate 
, the signer proves that he has a valid secret key associated to a certified public key 
 in zero knowledge. Moreover, he argues that he knows at least t valid message-signature pairs (
) for Boyen's signature scheme and his revocation tokens are correctly committed via LWE function.

Thus the signer proves, that

1. He has a valid secret key; ,

2. He has at least t satisfying attributes; 
 and 
,

3. His revocation tokens are not in revocation list (his tokens satisfy the LWE function); 
 and 
,

by executing the protocol given in Section 4 for  times.

4. The underlying interactive zero-knowledge protocol
Our goal is to construct a zero-knowledge (ZK) argument system that allows prover  to convince his validity to a verifier  in a system where, the prover (signer) d carries valid credentials for the attributes 
 and the given predicate is  out of 
. Let 
 and 
, where 
 and 
.

We explain the underlying interactive protocol below.

•
The public parameters are: a set of matrices 
, a matrix 
, a vector 
, a set of vectors 
, a threshold predicate , matrices 
, and a set of vectors 
.

•
The prover's witnesses are: the index d, x, v, t vectors 
 such that 
,  vectors 
 such that 
, and p vectors 
. Here 
.

•
The prover's goal is to persuade the verifier in zero knowledge that

–
;

–
For , 
 and 
, where 
;

–
For , 
 and a vector 
;

–
At least for , 
 and 
.

4.1. Notations and techniques
Before detailing our protocol, we first present several notations and techniques we use.

4.1.1. Specific sets
We define four specific sets of vectors and permutations defined in [12], [25], [11] and that we use in this paper.

•
: The set of all vectors in 
 having exactly m coordinates −1, m coordinates 0, and m coordinates 1.

•
: The set of vectors in 
 having Hamming weight ℓ.

For a given binary string 
 and 
,

•
: The set of vectors 
 and 
.

•
⁎
: The set of vectors 
, where 
⁎
 is an extension of d and 
.

4.1.2. The decomposition - extension technique
Let 
.

Ling et al. [25] presented a core technique called “Decomposition - Extension,” and Langlois et al. [12] adapted their technique and delivered the following procedures.

•
Decomposition (Dec): For a given vector v = (
) 
, where 
, Dec outputs k vectors 
, where 
, by working as below.

1.
For each , present 
 as 
, where 
.

2.
For each , let 
 and output 
.

•
Extension (Ext): For a given vector 
, Ext extends 
 to a vector 
 as follows.

1.
, and 
 are the number of coordinates of 
 that equal to , and 1 respectively.

2.
Select a random vector 
 that has exactly (
) coordinates −1, (
) coordinates 0, and (
) coordinates 1, and output 
.

•
Matrix Extension (MatrixExt): For a given matrix 
, MatrixExt outputs an extended matrix 
⁎
 as below.

1.
Append 2m zero-columns to each of the component-matrices and a   block to the end.

2.
Output 
⁎
.

4.1.3. Permutations
For a given vector 
 and permutations 
, 
, and 
 we present the following composition of these permutations [11], [15], [26].

 is a computation of four permutations. It rearranges the order of the 2ℓ blocks 
 according to τ. Then 
 permutes block 
 according to π and the other blocks according to ψ. Further permutation ξ rearranges the position of the attributes within the commitments [26].

4.2. Preparation
The prover should prove his validity while hiding his identity. Thus, first, we turn the public matrices independent of the prover's id d.

Let 
, where 
 and 
 [11]. Then we get,
 

Next, before executing the protocol, we require both the prover  and the verifier  to obtain extended matrices of the public matrices as below.

•
⁎
.

•
For ; 
⁎
.

•
⁎
, where each 
⁎
 is obtained by appending 2m  to the identity matrix of order m.

To argue that prover's id 
, first, we require him to extend d to 
⁎
. Thus he can show that a random permutation of 
⁎
 resides to the set 
, which signifies that the original 
.

Using the Decomposition-Extension techniques, the prover acquires the followings for his witness vectors.

•
For , apply Dec and Ext techniques on 
 and y to get 
 and 
, such that 
⁎
, 
, and 
⁎
⁎
.

•
For , apply Dec and Ext techniques on 
 and y to get 
 and 
, such that 
, and 
⁎
⁎
.

•
For , let 
, then for each , let 
 such that 
.

Next,  obtains the followings extensions.

1.
.

For :

2.
⁎
⁎
.

3.
⁎
⁎
.

To argue that above extended statements are true, using the Stern's framework [27] we instead show that,

•
;

•
⁎
⁎
⁎
⁎
.

•
⁎
⁎
⁎
⁎
.

For each , let 
.

4.3. Description of the protocol
Commitments:

•
Generate masking terms 
 and 
⁎
.

•
Sample permutations 
, 
, 
, and 
.

The prover  generates commitments 
, and sends to the verifier .

•
⁎
⁎
⁎
⁎
 

•
⁎
 

•
⁎
⁎
 

Challenge: The verifier  arbitrarily selects a challenge , and sends it to .

Response: Based on the challenge CH, the prover  answers as below.

•
: Let 
⁎
⁎
 and 
⁎
⁎
.

Compute

 
, 
,

 
,

 
,

 
.

Output

⁎
⁎
 

•
: Let 
⁎
⁎
⁎
.

Compute

 
,

 
.

Output

⁎
 

•
:

Output

⁎
 

Verification: The verifier  checks the received response RSP as below.

•
: Check that 
⁎
, for : 
 and 
, for at least t set of vectors and all ; 
 and 
 are valid with respect to 
⁎
, i.e., 
⁎
, and 
. Then check that,

–
⁎
,

–
⁎
⁎
 

•
: Check that

–
⁎
⁎
⁎
⁎
 

–
⁎
 

•
: Check that

–
⁎
⁎
⁎
⁎
 

–
⁎
 

The verifier  outputs 1 if and only if all the conditions hold, otherwise he outputs 0.

4.4. Analysis of the protocol
We summarize the properties of the proposed interactive protocol in the following theorem.

Theorem 12

The proposed interactive zero-knowledge protocol has perfect completeness and communication cost . If COM is a statistically hiding and computationally binding string commitment scheme, then the above protocol is a statistical zero-knowledge argument of knowledge with soundness error 2/3.

Analysis of the protocol is given in Appendix A

5. Construction of the new ABGS scheme from lattices
We build our scheme based on the modified Boyen's Signature scheme [28] given in [11].

Let λ be the security parameter and 
 be the maximum number of members in a group.

•
: On input the security parameter λ, set the public parameters param as below.

Let integer , the modulus 
, and the dimension . Gaussian parameter . The infinity norm bound for signature is 
.

Then the attribute authority continues as below.

1.
Define the universal set of attributes 
, where 
 is uniform random and . Each attribute 
 is associated to a uniform random vector 
 via a list 
.

2.
Let the hash function 
⁎
, to be modeled as a random oracle, where .

3.
Output the public parameters .

•
: This is a randomized algorithm. KeyGen produces the signature verification key and the authority key. It takes the public parameters PP as the inputs and proceeds as below.

1.
Generate (
) pair by executing the PPT algorithm GenTrap(), where A is statistically close to uniform over 
 and its trapdoor 
.

2.
Sample 
 and 
.

3.
Select an additional random matrix 
.

4.
Output the group public key 
 and the group manager's secret key gmsk = 
.

•
Join(PP, gpk): This algorithm enables a new user to join the group with his keys and a set of attributes. Moreover, it allows the group manager to issue member certificates for valid users. While steps 1 - 3 are executed by the user who wants to join the group, the group manager performs steps 4 - 9.

1.
Sample secret key sk=
 and public key pk= 
 such that , where binary representation of v is 
.

2.
Generate an ordinary digital signature , where usk is the long-term secret key of the user.

3.
Send , and the possessing attribute set , where  to the group manager to join the group.

4.
Validate sig on v with respect to upk of the user and confirm v is not being used before. If these conditions fail abort.

5.
Select a fresh ℓ-bit string as the index d of the user and compute 
.

6.
For all the attributes , that the user possesses, sample 
 such that 
 and 
.

7.
For the universal attributes , that the user does not possess, sample fake credentials 
, such that 
 and 
.

8.
Set revocation token grt of each attribute as 
 from 
 and save user data in database.

9.
Return the member certificate 
 to the user.

•
: On input the group public key gpk, and a message M, the user d having a secret signing key sk[d], a member certificate , and a set of attributes 
, generate a signature for the threshold predicate 
, where , as below.

1.
Let 
 be the identical attributes that the user d have, where 
.

2.
Encrypt attributes' tokens. For all the attributes ,

(a)
Sample 
 
 
, let 
 = 
 (
⁎
), where 
.

(b)
Sample 
 (
 with overwhelming probability).

(c)
Compute 
.

3.
Create a non-interactive zero-knowledge argument of knowledge Π to show that the signer d is in fact a valid group member possessing at least non revoked t attributes within  and has a certified membership. That is, the signer proves that he can satisfy the below statements. For all :

This is done by repeating the underlying interactive protocol given in Section 4,  times with public inputs (
) and witness parameters (
), then making it non-interactive via the Fiat-Shamir heuristic as a triple 
, where 
.

4.
Output a signature 
.

•
: This deterministic algorithm takes as inputs PP, the group public key gpk = 
, a threshold predicate 
, a signature Σ on a message M, and a list of revocation tokens 
, where , and verifies the signature as below.

1.
Parse the signature Σ as 
.

2.
Get 
, where 
.

3.
Parse Π as 
.

4.
Return 0, if 
.

5.
For  to t, run the verification steps of the protocol given in Section 4 with the public inputs (
) to check the validity of 
 with respect to 
 and 
. If any of the conditions fails then return 0.

6.
For each 
 in the given revocation list RL, where  and  compute 
 to check whether there exists an index i such that 
. If so return 0.

7.
Return 1.

•
: On input gpk, the revocation list RL, and a revoking attribute set 
, the group manager, do the following steps.

1.
For each 
.

2.
Return RL.

6. Security analysis
We prove the proposed scheme's security in the random oracle model under the hardness of lattice problems LWE and SIS. We prove the anonymity of users and attributes under the proof of almost-full anonymity, and we provide the proof of traceability and non-frameability separately as given in [21].

Theorem 13

The proposed VLR-ABGS scheme with member registration is almost fully-anonymous for users and attributes under the hardness of the LWE problem and based on the simulation soundness and zero-knowledge properties of the underlying interactive protocol.

Theorem 14

The proposed VLR-ABGS scheme with member registration is traceable under the assumption that the SIS problem is hard.

Theorem 15

The proposed VLR-ABGS scheme with member registration is non-frameable under the assumption that the SIS problem is hard.

6.1. Proof of almost full anonymity
Proof. We prove that the proposed VLR-ABGS scheme with member registration is almost fully anonymous for users and attributes using a succession of games between an adversary  and a challenger  as follows.

Game 1. In this game, the challenger  sets everything honestly. First, the challenger  generates group public key, secret signing keys, and member certificates for all the users. Then he gives the group public key and all the existing user secret signing keys to the adversary . The challenger  replies all the queries that the adversary delivers for Join, Open, and ReqCert oracles as given in Definition 9. Finally, the challenger produces a signature 
⁎
 with the honest identities (
⁎
⁎
) that the adversary sent, and transmits 
⁎
 to the adversary. Here 
⁎
⁎
, and neither 
's nor 
's member certificate is known by the adversary. The 
⁎
 is generated by using either 
 or 
 with the related attribute set 
. The adversary succeeds the game if he can identify the index of the signer 
 correctly.

Game 2. In this game,  imitates the zero-knowledge argument 
⁎
 for the challenging signature 
⁎
 without creating an honest non-interactive zero-knowledge argument Π. Thus, this game is as same as the former game except for the imitated 
⁎
. Since the underlying argument system is statistically zero-knowledge, the distribution of simulated 
⁎
 is statistically close to the distribution of legitimate Π. Thus, Game 1 and Game 2 are identical.

Game 3. The real game has 
 for , where 
 is uniformly random over 
, 
 is sampled from the error distribution χ, and 
 are the tokens of attributes, that are used to generate the signature. In this game, the challenger  samples uniformly random vectors 
 and replaces the original revocation tokens of the attributes by 
. Thus 
. Since  replaces only the revocation tokens, the rest of the game is as same as Game 2. Thus, the two games are statistically indistinguishable.

Game 4. In this game, the challenger  makes revocation tokens of the attributes totally independent of the bit b. He makes 
 truly uniform by sampling 
 and setting 
. In the previous game (
) pairs are proper 
 instances. Thus, the distribution of the pairs (
) is computationally close to the uniform distribution over 
. If  can distinguish any b and y, then he can solve Decision-LWE problem. Thus, Game 3 and Game 4 are indistinguishable under the assumption of the hardness of 
 problem.

The above set of games proves that the proposed scheme is almost full anonymous for users and attributes.

6.2. Traceability
In traceability game three queries are possible, namely, Random Oracle Query, Secret Signing Key Query, and Signing Query. In signature schemes Secret Signing Key Query returns the secret key related to the user id d. In our scheme, the member certificate is related to the user id d. According to Boyen's signature scheme, we produced a member certificate. Thus, in Secret Signing Key Query, we return z, which is our scheme's member certificate.

We take a PPT traceability adversary  with noticeable advantage ε. Thus the adversary  can produce a valid message signature pair (
⁎
⁎
) with a predicate (
⁎
) which cannot trace the user or which traces a user (not controlled by the adversary) who did not sign (
⁎
). Then we construct a reduction PPT forgery  that uses  to deliver a forgery Boyen's signature with advantage polynomially smaller than ε. Since Boyen's signature is unforgeable based on the SIS problem's hardness, we show that our scheme is secure.

•
SETUP: The verification key (
) for Boyen's signature scheme is given to the forgery B. Then  interacts with  by giving the verification key and answering 's queries.

•
QUERIES:  sets  and manages 's queries as follows.

–
Random Oracle Query: Queries on  are handled by continuously resulting suitable random values. We denote the answer to the k-th query by 
.

–
Secret Signing Key Query: When  queries the secret signing key of any user d, then  queries his own signing oracle for Boyen's signature of d and returns the received 
 (
 consists of set of attribute secret keys related to the member certificate). Then,  updates .

–
Signing Query: On signature query on a message M, predicate 
 for user d with attribute set 
, the reduction algorithm  returns a simulated signature 
. He generates (
) honestly while the NIZKAoK 
 is simulated without using the legitimate secret signing key. The zero-knowledge proof of the underlying argument system ensures that Σ is statistically indistinguishable from a real signature.

•
OUTPUT:  outputs a message 
⁎
, a forgery signature 
⁎
, a revocation list 
⁎
, and a threshold predicate 
⁎
, which satisfies the requirements of the traceability game, where 
⁎
, and passes the signature verification.

The rest of the proof is as same as proofs given in [11] and [12]. The improved Forking Lemma [29] assurances that, with probability at least 1/2,  can obtain 3-fork involving tuple (
) running  up to 
 times with the same tape.

Employing the knowledge extractor of the underlying argument system  can extract (
⁎
⁎
⁎
⁎
⁎
⁎
), such that 
⁎
 is the Boyen's signature for the message 
⁎
. Moreover,  must have 
⁎
 which implies that (
⁎
⁎
) is a forgery for Boyen's signature. Finally, we observe that if  has non-negligible success probability and runs in polynomial time, then same applies for .

This proves the traceability of the proposed scheme.

6.3. Non-frameability
We take a frameable adversary  with advantage ϵ, who delivers a forgery (
⁎
⁎
) that traces to an innocent user 
⁎
 who did not sign 
⁎
. We build a PPT algorithm  that solves  problem.

 produces all the public keys and authorities' keys honestly and communicates with  by transmitting group public key gpk and authorities' keys gmsk. The adversary  can act as a corrupted group manager and add a new user i to the group. When  queries signing oracle with a message M and a predicate Γ for a user i,  creates and returns the signature Σ.

Finally,  outputs 
⁎
 signed on a message 
⁎
 and a predicate 
⁎
, which traces to an innocent user 
⁎
 who did not sign the message. Thus, (
⁎
⁎
⁎
) should frame user 
⁎
. Thus  should have a short vector 
⁎
⁎
 and to solve SIS instance  should have another short vector 
. To figure such a vector,  continues by running  adequate times and applying Improved Forking Lemma [29]. From the corresponding responses of 
⁎
, B can draw a short vector 
, where 
⁎
. In accordance with the Stern-like proof of knowledge, with overwhelming probability, we say 
⁎
. The difference 
⁎
 is a suitable short non-zero vector, which is a solution for SIS problem.

This shows the non-frameability of the proposed scheme.

7. Conclusion
This paper proposed an ABGS scheme from lattices that support member registration via a simple joining protocol and efficient revocation for both members and attributes via VLR. The proposed scheme achieves almost-full anonymity, a stronger anonymity notion than selfless anonymity and weaker than full anonymity. Since disclosing tokens destroy the scheme's anonymity, we also refrain from exposing tokens to the outsiders in this scheme. Revealing tokens of users and achieving full anonymity and efficient revocation is an open problem in ABGS schemes. Moreover, we did not discuss introducing new attributes to the users after joining the group in this scheme. On the other hand, we did not verify the almost-full anonymity using automatic verification tools. We discuss these matters in future.

Appendix A. Analysis of the interactive ZK-protocol
Theorem 16

The proposed interactive zero-knowledge protocol has perfect completeness and communication cost . If COM is a statistically hiding and computationally binding string commitment scheme, then the above protocol is a statistical zero-knowledge argument of knowledge with soundness error 2/3.

A.1. Completeness
The property Completeness guarantees that if an honest prover  with valid witnesses (
, 
) follows the protocol for a policy , then he should always get accepted by the verifier . Here 
.

Proof of completeness:

The prover obtains 
⁎
, 
, 
⁎
, 
 satisfying at least for ,

 ∧

⁎
⁎
 ∧

⁎
⁎
.

, and 
⁎
, 
⁎
, and 
⁎
 are extended matrices of the public inputs.

Now we demonstrate that  correctly computed the responses to pass the verification steps for all .

•
CH=1: Since 
⁎
, and the set 
 is invariant under permutations, we get 
⁎
. Again, 
 and for at least t set of vectors () and all ; 
⁎
, and 
.

•
CH=2: The honest prover should be able to produce 
, 
 and related 
, 
 such that the following expressions are true.

–
.

–
⁎
⁎
⁎
⁎
.

–
⁎
⁎
⁎
⁎
.

This proves that the proposed protocol has perfect completeness.

A.2. Communication cost
We rely on the commitment scheme COM from [30]. Thus, at the beginning of the interaction, the prover sends 3 commitments having  bit-size. Subsequently the challenger sends  . The response RSP from  is a subset of the following set of elements.

- 2 vectors in 

- 1 pk vector in 

- 1 k vector in 

- pk vectors in 

- 1 vector in 

- 2 permutations of m elements

- 3 pk permutations of 3m elements

- 2 k permutations of 3m elements

- 1 permutation of 2ℓ elements

- 1 permutation of p elements

Thus, the bit-size of RSP is bounded by . As a result, the overall communication cost of the protocol is bounded by .

A.3. Statistical zero-knowledge property
To prove that the proposed interactive protocol has the property of statistical zero-knowledge, we build a simulator  interacting with a verifier 
 for some given public input. The simulator outputs with probability close to 2/3 a simulated transcript that is statistically close to an honestly produced transcript by the honest prover in the real interaction. The simulator predicates the challenge to take values 
, 
, or 
.

For each case  proceeds as follows.

•
Case 
 
:

1.
Using linear algebra obtain,

–
, 
 for  such that,

*
,

for ,

*
⁎
⁎
,

*
⁎
⁎
,

and get
–
 such that 
.

2.
Sample uniformly random vectors and permutations as below.(A.1)
 

3.
Then send commitment 
 to 
.(A.2)
⁎
⁎
⁎
⁎
 

For a challenge CH from 
, the simulator  responses as follows.

–
If CH=1: Output ⊥ and abort.

–
If CH=2: Output

 

–
If CH=3: Output

 

•
Case 
 
:  samples(A.3)
 

Then  sends the commitment CMT as in (A.2).

For a challenge CH of 
, the simulator  responds as follows.

–
If CH=1: Output 
,

.

–
If CH=2: Output ⊥ and abort.

–
If CH=3: Output

 

•
Case 
 
:

The simulator  proceeds as in the 
 
 with the following 
.

⁎
⁎
⁎
⁎
 

For the selections of the verifier 
,  responds as below.

•
If CH=1: Output RSP as in the case 
 
, CH=1.

•
If CH=2: Output RSP as in the case 
 
, CH=2.

•
If CH=3: Output ⊥ and abort.

Since COM is statistically hiding, the distribution of commitments and challenges of 
 is close to those in real interaction. Thus the probability of  outputting ⊥ and aborting is negligibly close to 1/3. On the other hand,  outputs valid transcripts that are distributed statistically close to those in real interaction. Thus, we have built a simulator that can imitate an honest prover with probability 2/3.

A.4. Argument of knowledge
It is enough to show that the protocol has soundness property to prove that the proposed protocol is an argument of knowledge. Thus we construct an efficient knowledge extractor . If there exists a (probably cheating) prover 
 who can respond to all 3 challenges for the same commitment CMT, then the knowledge extractor  can output (
).

Let the extractor  obtains three valid responses (
) to CMT = (
) as below.

•
⁎
⁎
 

•
⁎
 

•
⁎
 

Based on the above responses of 
, the extractor  can extract the followings.
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
 

As COM is computationally binding,  gets,
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
 

Now  obtains inverse of each value as below.

•
⁎
⁎
⁎
⁎
.

•
For  and : 
,

.

Then it follows that,

⁎
⁎
.

Let 
⁎
 and 
.

Then  extracts z for each  as follows. First we extract single z which is the secret key of 
.

Let 
⁎
⁎
. Then it follows that, 
⁎
. Since 
⁎
⁎
 for all , we have 
⁎
⁎
⁎
⁎
⁎
. By dropping the last 2m coordinates in each 3m-block of 
⁎
 we obtain 
, where 
.

By repeating the above process for  we can obtain all the secret keys 
.

Note that, for ; 
⁎
⁎
.

Thus we can extract 
.

Moreover, since  and we can obtain, x and v.

Next extract e for each .

Let 
. By dropping the last 2m coordinates from 
 we get 
. Thus we can obtain 
 for all .

We have the relation
⁎
 
⁎
 

Finally,  outputs a witness (
).