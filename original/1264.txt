Abstract
We give recursion-theoretic characterizations of all levels of the polynomial hierarchy of time and of the hierarchy itself. We characterize both, the  and the  levels. In this work, only composition and recursion schemes are used. We identify the recursion scheme which added to  leads to the full polynomial hierarchy.

Keywords
Implicit complexity
Tree-recursion
Polynomial hierarchy

1. Introduction
The Meyer-Stockmeyer polynomial hierarchy, , is a polynomial-time analog of the arithmetical hierarchy.  is a class of boolean functions (or predicates) introduced based on non-deterministic oracle Turing machines. All its levels and the hierarchy itself lay between  and .  and  are the classes of boolean functions computable in polynomial-time, respectively polynomial-space, by deterministic Turing machines. The class  is the union of all 
 complexity classes, where 
 and 
 with . 
 is the class of boolean functions computable in polynomial-time by non-deterministic Turing machines with 
-oracles.

Boolean functions are two valued functions. Buss in [6] extends the concepts above to classes of functions ranging over . We write an extra F to denote classes of functions ranging over , like in ,  and . Following the notation in [6], for , 
 — the class of functions computable in polynomial time by deterministic Turing machines with 
-oracles. The polynomial hierarchy of functions, , is the union of all 
 for .

The levels of the polynomial hierarchy of functions and the hierarchy itself have been described in different ways. In [2], Bellantoni characterizes  using a minimization scheme. Ben-Amram et al., in [5], approach  via monotonicity constraints in characterizations of . Here, we do it purely recursion-theoretically. We use neither minimization schemes nor monotonicity constraints.

In this paper we define function algebras, in style of Bellantoni-Cook's characterization of  [3]. A function algebra is a characterization of a set of functions by the inductive closure, under some operators 
, of an initial set of functions I. We write 
. This concept is frequently used in recursion theory, namely to obtain characterizations of complexity classes [7]. We denote by 
 and 
 the function algebras corresponding to 
 and 
, respectively ( for Box and  for Sigma). We give a recursion-theoretic description of the □-classes, which is in line with their definitions. 
 is the closure of 
 under  computations. So, 
 is going to be the closure of the algebra 
 under the Bellantoni-Cook schemes of . Therefore, 
 and 
 are defined simultaneously, in a kind of interleaving process. The challenge is to identify composition and recursion schemes with the appropriated strength to define 
. The definition of 
 is crucial to make this interleaving process work, leading us to descriptions of 
 and 
. In the paper, we also identify a recursion scheme that takes us from 
 (i.e. ) to the full polynomial hierarchy, .

2. The non-sorted background
Let  be the word algebra generated by one nullary and two unary constructors, respectively, ϵ, 
 and 
.  can be interpreted over the set of all finite binary words. We write  for 
, and  for 
. We consider functions defined over . As usual in word algebra contexts, one considers a destructor (or predecessor) symbol of arity one — . One also introduces a symbol , of arity 4, for the conditional function of the algebra. They are defined as follows: ,  and 
, 
, .

We consider two recursion schemes. 1) The recursion on notation scheme, also called -recursion: 
 and 
, ; and 2) The disjunctive tree-recursion scheme: 
 and 
, , where ∨ returns  if at least one of its inputs ends by , and  otherwise. In (2) the last input of f is called pointer or path information. A general tree-recursion scheme is used in [11] to characterize FPspace. A recursion scheme of the same sort is also used in [4] and [10] to characterize NC, but there, the starting algebra is  — the tree algebra generated by ,  and ⁎, of arity 0, 0 and 2 respectively. Tree-recursion schemes with pointers can be seen as a restriction of recursion schemes with substitution — see work of Leivant [9].

3. The input-sorted term systems
3.1. The classes 
 and 
We describe classes of input-sorted function terms following notation introduced by Bellantoni and Cook in [3]. Function terms have two sorts of input positions — tier 1 and tier 0 (or, respectively, normal and safe). As usual, we write tier 1 and tier 0 inputs by this order, and we separate them by a semicolon — 
.

Definition 1

Let  be the class of function terms composed by the constructors of  — ϵ, 
, 
 —, the destructor , conditional  and projection functions (over both input-tiers). For any integer , define:

1.
,

2.
,

3.
,

where
SC — input-sorted composition: 
,

 — restricted input-sorted composition: as above, but 
,

SR — input-sorted recursion on notation:
  — disjunctive tree-recursion (with tier 0 pointer):
 with  and, omitting the inputs of g, 
 abbreviates .

The function  returns  if at least one of its inputs ends by , and  otherwise.
In the recursion schemes above g is designated by base function and h by step function. In the disjunctive tree recursion scheme the step function is fixed (it is ∨). Moreover, outputs of functions defined by disjunctive tree recursion are single bits. 
 is used to force that to happen at the base level as well. For simplicity we often write g instead of 
, but in the context of this scheme g must be understood as a boolean function. In [12] a scheme similar to , but with pointers in tier 1, is used to describe 
. Here pointers are in tier 0, therefore one cannot recurse on pointers (recursion inputs are tier 1). This is an issue because in [12] recursion on the pointers is used to establish the result. So the proof for the level 1, i.e. for 
, is more challenging here than in [12]. However, the pointers in tier 0 are crucial to lift Proposition 1(3) below, from  to higher levels in the hierarchy. Such lifting is essential to prove that, for , all 
-functions are definable in 
.

From the definition, we have that:

Remark 1

For all ,

1.
,

2.
For all 
 (or 
) there exists 
 (or, respectively, 
), such that 
.

A class of input-sorted functions  and a class of (non-sorted) functions A coincide, and we write , if the following conditions are satisfied:
(i)
For all  there exists  such that 
,

(ii)
For all  there exists  such that 
.

The main goal of this paper is to establish the following result.

Theorem 1

For all integer ,

1.
 characterizes 
,

2.
 characterizes 
.

In the theorem above, (1) means 
. (2) is a statement about an algebra of functions and a class of boolean functions. “
 characterizes 
” means that the boolean part of 
 is 
. To be more precise, we prove that 
.
3.2. What is already known?
The function algebra 
 is the Bellantoni-Cook characterization of 
 (i.e. ) [3], rewritten over . The proposition below compiles the known results concerning 
 that are relevant for this work.

Proposition 1

1.
 characterizes 
 (i.e. ).

2.
For all polynomial q, there exists 
 such that 
.

3.
For all 
 (i.e. ) there exist 
 and a polynomial q such that 
.

4.
For all 
 there exists a polynomial 
 such that 
.

The proofs are in [3]. See [12] for details of (2).
(1) is the main result. The other items correspond to important technical statements. (3) and (4) are crucial to establish the Theorem 1. We need to extend them to all levels of the polynomial hierarchy. To extend (4) is more or less straightforward, but the extension of (3) to higher levels is delicate. The difficulties show up already at level 
 and those issues are the reason for having here the  scheme formulated with tier 0 pointers. Since one cannot recurse on tier 0 inputs, one cannot recurse on the pointers. This is the major difference between 
 and the characterization of 
 (i.e. ) given in [12]. There pointers are tier 1, and so one can recurse on them.

In the proposition above and all along the paper, polynomials have coefficients over .

4. Extending technical results to higher levels
To prove that the function algebras 
 and 
 correspond to the complexity classes as stated in Theorem 1, we extend some technical results from 
 to higher levels.

Lemma 1

(Bounding lemma) For all 
 (or 
) there exists a polynomial 
 such that
 

Proof

The proof is straightforward, by induction on the function definitions. It suffices to show that (I) holds for functions in , and that the  and  schemes preserve the property (I).

For functions in , defined by SC (or 
) or  the result is immediate. Notice that functions defined by  have single bit outputs.

For f defined by SR based on g and h, consider 
. Prove by induction on  that such polynomial 
 satisfies (I). This finishes the proof. □

Under this semi-colon discipline, the recursion values are placed in tier 0 (on the right side of the semi-colon). Thus, the definitional strength of the algebras depend on the amount of functions with tier 0 inputs (because they — and only they — can be used in a meaningful way as step functions in the recursion). The next proposition tells us about the strength of the algebras 
 and 
. It is crucial in our proof that complexity classes that are defined by Turing machines (such as 
) can be characterized by certain function algebras (such as 
).

Given a input-sorted function-algebra , consider the statement that we denote by  for further reference: For all  there exist  and a polynomial 
 such that 
.

Proposition 2

For all ,

1.
If 
, then the property (II) holds,

2.
If 
, then the property (II) holds.

This proposition is a consequence of the following lemmas.

Lemma 2

For all , if (II) holds for 
, then it also holds for 
.

Proof

Fix . By assumption the result holds for 
, the initial functions of 
. To ensure that the closure under SC and SR schemes preserves the property  inspect the proof of the similar result given in [3]. Some auxiliary functions are required, but they all are in 
 and therefore a fortiori they are in 
. We need the 
-functions to have the length of the outputs polynomially bounded, but that is ensured by Lemma 1. So, the mentioned proof applies here smoothly. □

Lemma 3

For all , if (II) holds for 
, then it also holds for 
.

Hint of the proof of Lemma 3: The hard case occurs when F is defined by disjunctive tree-recursion, because the recursion variable — z — must be pushed into a tier 0 position. The new tier 1 variable w, see , is then used to simulate the recursion on z. Notice that terms defined by disjunctive tree-recursion have the shape


Download : Download high-res image (12KB)
Download : Download full-size image
where the height of the tree is the length of the recursion input, and G is the base function evaluated over the path (for writing simplification we omit the side variables). To calculate , in the figure above each G is evaluated on the path linking the root of the tree to the respective node.
If instead of recursing on z, one recurses on w (for the sake of the argument let us assume that ), then one gets a higher tree than before. The Δ's, on figure below, denote these tree extensions.


Download : Download high-res image (15KB)
Download : Download full-size image
The idea is to change the base function g. We do not want it to be evaluated on the paths from the root to the leaves, but on the paths from the root (of the main tree) to the roots of the Δ-trees. This is done, in the proof below, via a function denoted by sp — significant part of the path. Therefore, all labels of a given Δ are the same. Obviously the first tree has a leaf ‘labeled by ’ iff the second also has.
Notice that this requires that the base function uses recursion on notation. So, to compute the labels we want, the tier 1 input w must be preserved. This means that at the beginning of the process we have to duplicate it, because one w is consumed to spawn the big tree in the figure. Moreover, if instead of  we want to consider the general case , then the definition of sp must take into account that input p. Thus, we also duplicate p, in order to have it available when needed.

Proof of Lemma 3

Given , we proceed by induction on the function definitions. The result holds for 
 by assumption. For 
, the proof uses the Bounding lemma for 
-functions, and it is straightforward. We prove here the statement for F defined by  with base function G: 
 and 
, with . By induction hypothesis, there exist 
 and a polynomial 
 such that 
.

It is well known that concatenation and truncation are  functions, i.e. 
 functions. Thus their composition is in 
. Let us denote by SP the 
-function: 
, where 
 stands for the first  bits of p. The property  holds for any function in 
, so there exist 
 and a polynomial 
 such that 
.

Define 
 in 
 by  as: 
 and 
, with . Consider the polynomial 
 and 
.

Whenever 
, one has 
. This finishes the proof. □

Proof of Proposition 2

We prove (1) and (2) simultaneously, by induction on the integer . For : (1) is consequence of items (1) and (3) of Proposition 1; (2) follows from statement (1) that we have just proved together with Lemma 3. Assume that the result holds for a given  and prove it for . By induction hypothesis,  holds for 
. Therefore, it holds for 
 by Lemma 2. Now that we proved that  holds for 
, by Lemma 3,  holds for 
. This finishes the proof. □

5. From functions to function terms
In order to establish the inclusions 
 and 
, for all integer , we formalize the notion of non-deterministic Turing machines (NTMs) that we work with. Here we use NTMs as described in [1], but we assume that they have only one-tape. Thus, a NTM is five-tuple 
 where Q is the finite set of internal states, Σ is the tape alphabet,  is the transition function, 
 is the initial state and 
 is the set of accepting final states. We assume that non-terminating configurations have two successor configurations. Therefore, we split the transition function of NTMs, δ, into 
 and 
. We have 
. An input 
 is accepted by a NTM M if and only if there exists a computation of M on 
 ending in an accepting configuration.

Lemma 4

.

Proof

Let M be a non-deterministic Turing machine which runs in time q for some polynomial q on the length of the input. We are going to simulate M by 
 function terms. We assume that all configuration codes end with the code of the respective state. Codes of accepting final states end with  and any other state ends with . One may also assume that, for a given input 
, all the configuration codes have the same length, 
, which is polynomial in 
. There exist 
 and 
 in 
 which return the next configuration code according to 
 and 
 respectively if c is the code of a non-final configuration, and return c itself otherwise. By Proposition 1(3), for , there exist 
 and polynomials 
 such that 
. Define 
 in 
. 
 and 
 are the 
 functions associated to the polynomials 
 and l, given by Proposition 1(2).

Let 
, in 
, be the code of the initial configuration. We define in 
, by SR, the function
 which simulates the (sequential) computation performed by M along the branch p starting with the configuration code 
. Formally, the distinction between 
 and 
, in the definition of the function RUN, is done via the initial function  taking pi as first argument.

By Proposition 2(1), there exist 
 and a polynomial 
 such that 
. Let 
 and 
 be 
-functions associated in terms of length to the polynomials q (bounding the running time of M) and 
, respectively, as described in Proposition 1(2). Define in 
, by , the function:
 One has that 
. □

Proposition 3

For all integer ,

1.
,

2.
.

Proof

We prove (1) and (2) by induction on n. To make the reasoning clear, given n, we denote 
 by 
, and similarly for 
.

The statements 
 and 
 are given by Proposition 1(1) and Lemma 4, respectively. Fix  and assume that 
 and 
 hold. We want to prove 
 and 
.

Proof of 
: Let F be an arbitrary function in 
. There exists M single-tape oracle Turing machine, that computes the function F in polynomial time by means of an oracle function 
. Let us denote by r the polynomial bounding the running time of M, and by 
 the correspondent 
 function given by Proposition 1(2). We assume that M has a work tape, an oracle tape, an output tape and a distinguished state — the query state. Whenever M enters this state, the content of the oracle tape, 
, is instantaneously replaced by 
. By 
, 
. Proposition 2(2) ensures the existence of 
 and a polynomial 
 such that whenever 
 we have 
.

We encode a configuration of M as a word , where: q is the current state; x, y represent portions of the work-tape before and after the head position (the head is scanning the first symbol of y); similarly u, v for the oracle tape; and w is the content of the output tape (which is write-only). Each symbol of this word is encoded in binary, using a fixed number of bits. Since M runs in polynomial time we can assume that every reachable configuration on input 
 can be encoded (with padding if necessary) in exactly 
 bits, for some polynomial l.

This encoding can be manipulated by the functions below. They are  functions, therefore definable in 
 (over tier 1 inputs). To have them involving tier 0 inputs one applies Proposition 1(3).

•
 encodes the initial configuration of M on input 
.

•
 encodes the next configuration of c according to the instruction of M, provided that c is a configuration code and 
 for some polynomial 
 given by Proposition 1(3). If c is in the query state, then a is interpreted as the word written on the answer tape. If c is in a final state, then .

•
 is the word in the query tape of M at configuration c, provided that c is a configuration code and 
 for some polynomial 
 given by Proposition 1(3).

•
 is the word corresponding to the output tape of the configuration c, provided c is a configuration code.

Now define in 
, by sorted recursion on notation, the function ():
 Let 
 be a valid configuration. Then 
 — remember that we assumed that all configurations have the same length. Let 
 and 
 be polynomials bounding the output length of o and , respectively. The existence of such polynomials is ensured via Lemma 1. Consider the polynomial
 It follows that for 
, 
 encodes the configuration of M with oracle O on input 
 after  steps. And so, we have 
, where 
 is the 
 function associated by Proposition 1(2) to the polynomial 
.
Proof of 
: Let F be an arbitrary function in 
. There exists M computing F by means of an oracle function 
 as described in the proof of case 
, but here M is a NTM and so no output tape is required. Encode a configuration in a similar way, and consider l a polynomial as above. Assume that accepting final states end with  and any other state ends with .

In order to simulate the computation performed by M consider some auxiliary -functions, i.e. functions definable in 
 (over tier 1 inputs) described as above: , 
 and 
 (similar to δ), and . We define RUN in 
, by SR, as follows ():
 which simulates the (sequential) computation performed by M along the branch p starting with the configuration code 
, provided 
 with 
 defined as in the proof of 
, but 
. Consider 
 with 
 corresponding to 
 by Proposition 1(2).

Again by Proposition 2(1), there exist 
 and a polynomial 
 such that 
. Let 
 and 
 be 
-functions associated in terms of length to the polynomials r (bounding the running time of M) and 
, respectively, as described in Proposition 1(2). Define in 
, by , the function:
 One has that 
. □

6. From function terms to functions
Lemma 5

Given functions 
 of appropriate arities, consider 
.

1.
If 
, then 
.

2.
If 
 and 
, then 
.

Proof

(1) is trivial. For (2), notice that the machines computing H and 
 are non-deterministic and deterministic, respectively, but in both cases they allow 
 oracles. So, one describes a non-deterministic Turing machine for F, with 
 oracle, in the obvious way. To check that such a machine works in polynomial time is also straightforward. □

Lemma 6

Consider
 If 
 and there exists a polynomial 
 such that 
, then 
.

Proof

For simplicity of writing, in this simulation we omit the side variables 
. We assume that each component of the input is placed in one of the tapes, and that the machines are initialized with the heads scanning the rightmost non-empty cell (if there is one). There is an additional tape, the oracle tape, which is empty at the end of the computation.

, so there exist deterministic Turing machines with 
 oracle, 
 and 
, which computes G and H in polynomial time. Let r be a polynomial bounding the running time of both — 
 and 
.

A machine with 
 oracle for F, 
, can then be described as follows: 
 has two tapes (the outputs are written in the second one), plus a clock tape and an oracle tape. We assume that 
 does not change the content of the first tape, and it halts with the head of the first tape scanning the cell immediately after the rightmost non-empty cell. 
 erases the first tape, copying its content to the clock tape and halts with the heads placed in the leftmost non-empty cell. 
 moves the head of the clock tape one cell to the right. The machine is initialized with z in the first tape, the head on the rightmost bit, and all the other tapes empty.

(1)
run 
; run 
 over the second tape (plus the oracle tape) and (2);

(2)
if the head of the clock tape scans , then (3);

otherwise, halt;

(3)
copy i to tape 1, move the clock head one cell to the right, and (4);

(4)
run 
 over tapes 1 and 2 (and oracle tape) and (2).

In order to determine the computing time of 
 notice that the only possibility of going into a loop is when an instruction calls a previous one, i.e. in (4). Moreover, notice that, inputting 
 to the machine, (2) is called  times, and each loop performs at most 
 steps, for some constant c. By hypothesis the length of the outputs of F is polynomially bounded. Thus, 
 works in time bounded by a polynomial: 
. Therefore, F is in 
. □

Lemma 7

If 
 then the function F defined by
 is also in 
.

Proof

For this proof we consider NTMs with as many tapes as the arity of F (and G) plus an oracle tape (not numbered). We also assume that each component of the input is placed in one of the tapes (in the order that they show up in), i.e. the nth input is on the nth tape, and that the machines are initialized with the heads scanning the rightmost non-empty cell (if there is one).

Let 
 be a NTM which works according to two “transition functions” — 
 and 
. Informally speaking, 
 adds the bit  at the end of the pointer, and deletes the last bit of the first input (the recursion input). The heads move one cell to the right and one cell to the left, respectively. 
 proceeds in an analogous way, but adds the bit . This can be done in constant time.

, so there exists an NTM 
 with 
 oracle, which computes G, in time bounded by a polynomial r.

A NTM for F, 
, with 
 oracle can then be described as follows:

(1)
if the head of the first tape scans ϵ, go to (3);

otherwise, (2);

(2)
run 
 and (1);

(3)
run 
.

In order to determine the computing time of 
 notice that the only loop occurs when (2) calls (1). Moreover, notice that, inputting 
 to the machine, (1) is called  times, and each loop uses constant time. Therefore, before reaching the instruction (3) the machine performs  steps, for some constant c. (3) uses at most r steps (notice that the inputs change during the process, but  remains constant). Thus 
 runs in time bounded by 
. This finishes the proof. □

Proposition 4

For all integer ,

1.
,

2.
.

Proof

Proceed by induction on n. Given n, 
 denotes 
. Similarly for 
.

 is known, see Proposition 1(1).

 is proved by sub-induction on the definition of functions inside 
. For the initial function, the statement is a consequence of 
. If f is defined by 
 based on 
 and 
, then by sub-induction hypothesis 
 and by 
 
. Thus, by Lemma 5, 
. For f defined by the  scheme, based on 
. By sub-induction hypothesis 
. Actually 
, because 
 is boolean and all boolean 
-functions are in 
. Lemma 7 ensures the desired result.

Given n, assume that 
 and 
 hold. The proof of 
 is by sub-induction on the definition of functions inside 
. The result for the initial functions is true due to 
. For functions defined by SC and SR use Lemmas 5(1) and 6, respectively.

The proof of 
 is by sub-induction on the definition of functions inside 
. The result for the initial functions is true due to 
. For functions defined by 
 based on 
 and 
, then by sub-induction hypothesis 
 and by 
 
. Thus, by Lemma 5, 
. If f is defined by , based on the boolean function 
. By sub-induction hypothesis 
 but, because 
 is boolean, 
. Apply now the Lemma 7 to get the result. □

7. Conclusion
We establish now the main result, Theorem 1: For all ,

1.
,

2.
.

Proof of Theorem 1

The inclusions established in Proposition 3, Proposition 4 entail this theorem. □

All levels of the polynomial hierarchy of functions are here described as the closure of  under combinations of three schemes: sorted composition (SC), sorted recursion (SR) and disjunctive tree-recursion (). Now we describe, recursion-theoretically, the polynomial hierarchy of functions, , as a natural extension of Bellantoni-Cook's characterization of . Recall that .
Definition 2

Define .

Theorem 2

.

Proof

If , then 
 for some integer . Evoking Theorem 1, we have that .

For , let 
 be the number of times the scheme  occurs in the definition of f. We prove, by induction on n, that
 If , then  i.e. 
. Given n, assume that 
 (⁎). Let us prove that 
. Given f such that 
, we have to consider different situations: (i) If 
, then by (⁎) 
; (ii) If 
 and f is defined by  based on g, then (⁎) applies to g. Thus 
, and consequently 
; (iii) If 
 and f is defined by SC or SR based on functions 
, then apply the reasoning above to those functions. Go deeper in the sub-terms up to the moment (i) and/or (ii) apply. In both cases, we get 
. The closure of 
 under SC and SR is 
, thus 
.

We have shown that 
, and so . This concludes the proof. □

Similar characterizations of 
 and  can be achieved working in a non-sorted context, by use of explicit bounds on the recursion scheme. Such characterizations, here denoted by 
 and 
, are the parallels of Cobham's characterization of  [8], now for the polynomial hierarchy and its levels.

Definition 3

Let  be the class of function terms composed by the constructors of  — ϵ, 
, 
 —, the destructor , conditional  and projection functions. For any integer , define:

1.
,

2.
,

3.
,

4.
,

where
C — composition: 
,

 — restricted composition: 
,

BR — bounded recursion on notation:
 where t is a function explicitly definable from 
, string concatenation, and string product. 
 denotes x truncated to the length of y.

 — disjunctive tree-recursion:
 with  and, omitting the inputs of g, 
 abbreviates .

String product, , is the function that concatenates x with itself -times. It corresponds to the smash function of Buss [6].
Theorem 3

For all integer ,

1.
,

2.
,

3.
.

Proof

Evoking Lemma 1, 
 and 
. Therefore, due to Theorem 1, Theorem 2, 
 and 
.

For the inclusions 
, 
, and 
, observe that outputs of 
 and 
 functions have polynomially bounded lengths. The proof of the corresponding inclusions in the sorted context adapts here smoothly. Notice that Lemma 5, Lemma 7 are formulated in a unsorted context. □

The unsorted version presented here might be of interest for further research, namely for discussing induction schemes in the context of bounded arithmetic.