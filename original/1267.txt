Abstract
This paper concerns the verification of continuous-time polynomial spline trajectories against linear temporal logic specifications (LTL without ‘next’). Each atomic proposition is assumed to represent a state space region described by a multivariate polynomial inequality. The proposed approach samples a trajectory strategically, to capture every one of its region transitions. This yields a discrete word called a trace, which is amenable to established formal methods for path checking. The original continuous-time trajectory is shown to satisfy the specification if and only if its trace does. General topological conditions on the sample points are derived that ensure a trace is recorded for arbitrary continuous paths, given arbitrary region descriptions. Using techniques from computer algebra, a trace generation algorithm is developed to satisfy these conditions when the path and region boundaries are defined by polynomials. The proposed PolyTrace algorithm has polynomial complexity in the number of atomic propositions, and is guaranteed to produce a trace of any polynomial path. Its performance is demonstrated via numerical examples and a case study from robotics.

Keywords
MITL
Runtime verification
Dense-time
Continuous
Trace
Root isolation

1. Introduction
Path checking [1] is about testing whether a particular signal (or word) satisfies a given formal specification. By contrast, the aim in model checking [2] is to establish whether all outputs from a model satisfy the specification. Path checking is generally much easier than model checking [3], particularly for infinite state models, for which the model checking problem is usually undecidable. Hence runtime verification, a popular approach to formal system verification [4], abandons model checking in favour of path checking, at the expense of exhaustive coverage. Path checking algorithms for discrete words are well studied [1], [3], [5]. We focus here on path checking continuous-time signals. Signal Temporal Logic (STL) is introduced in [6] as part of a framework for path checking the outputs of continuous-time and hybrid systems. STL is defined there as a fragment of Metric Temporal Logic (MTL) [7] in which each atomic proposition is associated with a region of the state-space. A procedure is then developed in [6] for path checking continuous-time signals against STL specifications with bounded temporal operators. This procedure relies on sampling the continuous-time signal in a manner assumed dense enough to capture all signal transitions between the relevant state space regions [6]. Satisfying this assumption is a decidedly non-trivial problem. Here, we present a sampling strategy that guarantees it, assuming that the signal to be verified is a polynomial spline, and that the state space regions of interest are semi-algebraic sets.

A useful comparison between path checking and model checking is provided in [5, Section 1.1]. A recurring issue relates to word length: most temporal logics are interpreted over infinite words, but we are practically constrained to store and process only finite words. In discrete-time, one way to resolve this is by restricting attention to lasso words, which are infinite words of the form 
, for finite . Path checking algorithms for such words are developed in [1], [3]. Other ways to tackle the finite length issue for discrete words are discussed in [8]. In continuous time, a different approach has been to only path check fragments of MTL with bounded temporal operators [6], [9], [10], the satisfaction of which are fully determined by signal prefixes over finite time horizons. In contrast to this, we focus on Linear Temporal Logic (LTL) specifications, which can be considered fragments of MTL restricted to unbounded temporal operators. This choice is motivated by the control systems literature [11], [12], [13], in which controllers for continuous-time systems are synthesised to meet closed-loop LTL specifications. We address the verification problem, not the synthesis problem. The proposed sampling strategy generates a trace of the continuous-time signal to be verified, in line with the definition of such from [13]. Intuitively, a trace is a discrete word that captures every region transition taken by the continuous-time signal. In Section 4.2 we formalise the relationship between traces and the timed state sequences (TSSs) of [14]. We also identify a class of continuous-time signals having lasso word traces, and argue these are the only continuous-time signals with unbounded domains that are practically amenable to LTL path checking.

The notion of a robustness margin has proved valuable for path checking continuous-time signals by sampling. Intuitively, a robustness margin quantifies how robustly a formal specification is satisfied or how severely it is violated. In order to conclude that a continuous-time signal satisfies the specification, its sampled version is typically required to satisfy a corresponding discrete-time specification, with a sufficiently large positive robustness margin. Such an approach is proposed in [9], in which MTL semantics that can be interpreted over both discrete and continuous-time signals are developed. The signals are assumed to take values in a metric space, and a robustness margin is defined based on the metric. Moreover, the continuous-time signals are assumed to satisfy a generalised global Lipschitz condition [9, Assumption 35], and an upper bound on the sampling time is also required. Then, continuous-time satisfaction can be inferred from sufficiently robust discrete-time satisfaction. The same approach is adopted in [15]. The drawback is that the required sampling frequency may not be known a priori. Thus, if the robustness margin is not large enough for a particular sampled signal, then violation of the specification for the continuous-time signal cannot be inferred. The test can only be repeated with a different sampling strategy, which may again yield an inconclusive result. It is indeed possible for a continuous-time signal to satisfy or violate a specification with zero robustness, in which case the test never yields a conclusive result. A distinctive feature of our approach is that it does not rely on robustness margins at all. Since our algorithm is guaranteed to produce a trace, the trace can be checked against any LTL specification to always yield a conclusive result, even when the robustness margin is zero. To generate the trace, our sampling strategy does not depend on the specification imposed, neither does it rely on an upper bound between sampling times, thereby avoiding unnecessary sampling over intervals in which no transitions occur. This comes at the cost of considering a narrower class of continuous signals and regions of interest, specifically, those that are fully characterised by polynomials. However, such polynomial signals need not satisfy [9, Assumption 35].

Building on [9], subsequent works have estimated the robustness margin of a continuous-time signal from its samples by computing the robustness margin of its reconstructed version. Linear interpolation between sample points is assumed in [10], [16]. This approach is generalised in [17] to allow for reconstruction via polynomial spline interpolation. Error bounds between the robustness margin of the original signal and the reconstructed spline are also derived. Our approach relates to the computation of the spline robustness margins in [17], but with some key differences. Firstly, we focus only on evaluating the boolean satisfaction of a specification by a signal, without attempting to compute its robustness margin. This allows us to verify edge cases that have zero (or almost zero) robustness, which would otherwise yield an inconclusive result. Secondly, [17] relies on numerical root finding to find inflection and intersection points of polynomials, without specifying a particular algorithm. Numerical root finding can be expensive. It also introduces errors, because, in general, polynomial roots are irrational, and cannot be found exactly for polynomials of degree five and higher. The choice of root finding algorithm is important, because this determines the overall complexity of the algorithm, and some root finders are not guaranteed to find every root (e.g. Newton's method [18, Chapter 9]). Polynomial roots are also central to our approach, however we adopt root isolation techniques from computer algebra, which rely on symbolic computation over the rationals, and come with theoretical guarantees. The roots do not actually need to be found, only isolated. As a result, no numerical errors are introduced during our computations. Finally, the procedure in [17] appears to be sound, but it is stated without proof. A key contribution of our work is to provide a rigorous proof of correctness.

The restriction of scope to polynomial signals and semi-algebraic regions of interest may at first appear severe, however this class of verification problems is of practical significance. The use of polynomial splines for signal reconstruction in [17] has already been mentioned. Robotic motion planning is also frequently solved by constructing a polynomial spline through a sequence of waypoints [19], [20], [21], [22]. Our algorithm can be used to verify a proposed motion plan against mission requirements expressed in LTL. This is illustrated by a case study in Section 7.2. A special case of this problem, focused only on detecting collisions, is treated in [23]. Collision detection is also the focus of [24], which assumes rational rather than polynomial spline paths. Semi-algebraic regions include half-spaces, circles, ellipses, hyperbolas, and finite intersections and unions thereof. These suffice to approximate obstacles or target regions to any desired degree of fidelity. Polynomials are of theoretical interest as well, because the celebrated Weierstrass Approximation Theorem assures us that any continuous function can be approximated uniformly and arbitrarily closely by a polynomial. Polynomials, then, are worthy of special attention, and our work exploits their properties for verification, by using the appropriate tools from computer algebra.

Overview: At its core, our algorithm involves sampling a continuous-time trajectory on either side of (and sometimes at) every crossing of the boundary of a region of interest. Since boundaries are a topological property, Section 2.2 provides some basic definitions and results from point-set topology, which are used along the way. We also rely on the preliminaries from algebra reviewed in Section 2.3 to exploit the algebraic properties of polynomials for their verification. The general problem we consider is formulated precisely in Section 3, which reviews the continuous-time semantics of MITL, and then presents LTL without next as a fragment of MITL. Section 4 lays the theoretical foundations of the paper. A distinction is made between two types of continuous signals: paths and trajectories, the former having a finite trace, and the latter an infinite one. This enables us to verify the class of trajectories that can be decomposed into a finite number of paths, because such trajectories have lasso word traces. Sections 4.1 and 4.3 address the decomposition of trajectories into paths, and the related construction of trajectory traces from path traces. The first main result of the paper is Theorem 1 in Section 4.4, which presents topological conditions to ensure that samples are taken on either side of every boundary crossing, and when necessary, at the crossings themselves. These conditions are stated in terms of sampling functions, which are introduced in Section 4.2 to describe arbitrary sampling strategies. The theory developed in Section 4 is applied in Section 5 to polynomial paths travelling through semi-algebraic regions of interest. Section 5.2, in particular, identifies the algebraic conditions that require samples to be taken exactly on a boundary. This precedes Theorem 2, which expresses the topological conditions of Theorem 1 in terms of polynomial roots. Section 6 then constructs the PolyTrace algorithm to satisfy the conditions of Theorem 2. An important result is Lemma 7 (the Isolation Lemma), which permits a trajectory to be sampled exactly on a boundary, with only approximate knowledge of the crossing point. PolyTrace relies on root isolation algorithms and a root existence test from computer algebra, which are discussed in Sections 6.2 and 6.3. The final main result is Theorem 3, which establishes the correctness of PolyTrace. Numerical examples demonstrate the capabilities of the algorithm in Section 7, and a case study applies it to the verification of a robot motion plan. In particular, the case study imposes an LTL specification that can only be satisfied with zero robustness. Such specifications simply cannot be verified using existing methods, but yield readily to PolyTrace. Concluding remarks are then made in Section 8.

2. Preliminaries
2.1. Notation
Let  denote the real numbers,  the rational numbers,  the integers, and  the natural numbers. For any , let 
. The subset relation is denoted by ⊂, and the strict subset relation by ⊊. A set is countable iff it is either finite or countably infinite. If , then let  denote the image of , and 
 the preimage of . The composition of  with  is denoted by . The restriction of f to  is denoted by 
. For two integers , let 
. For products taken over the empty set, define 
.

2.2. Topology
Let X be a topological space. A set  is a neighbourhood of  iff U is open and . A topological space is connected iff it is not the union of two of its disjoint open subsets [25, §23]. A point  is an isolated point of X iff  is open [26, Section 1.3]. Let  denote the set of isolated points of X. Moreover, let  and  denote the interior and closure of , respectively. Then  denotes the boundary of A, and  the exterior of A. A point  iff every neighbourhood of x intersects both A and  [26, Proposition 1.3.1]. The result below is a corollary of this.

Proposition 1

For any topological space X, .

Any  becomes a topological space when endowed with the subset topology. That is,  is declared open in S iff  for some  open in X. Then S is referred to as a subspace of X. It follows from the definition of the subset topology that  iff there exists , open in X, such that . We refer to  as a S-neighbourhood of  iff V is open in S and .
Proposition 2

Let , where X is a topological space. If X contains no isolated points, then .

Proof

Let . There then exists  open in X such that(1) Choose any neighbourhood V of a. Now . Furthermore,  is open in X. If , then . Assume X contains no isolated points. Then , and there exists  such that . If , then , which contradicts (1). Thus , and , so . Clearly also . Thus . □

Proposition 3

Let , where X is a topological space. Then .

Proof

By [26, Theorem 1.3.2, (iv)], . □

Lemma 1

Let , where X is a topological space. Then .

Proof

Suppose(2) Then , for some neighbourhood V of s. Suppose in addition that . Then (2) implies  [26, Theorem 1.3.2, (i)]. Thus,(3) for some neighbourhood U of s. Observe that  is also a neighbourhood of s. In particular, , and (2) then implies . Furthermore,  by (3), and therefore , which implies . □

Suppose , and let  respectively denote the interior, closure, boundary and exterior of A relative to S (i.e., with respect to the subset topology on S).

Remark 1

Since S is a topological space when endowed with the subset topology, Proposition 2, Proposition 3 and Lemma 1 all hold when  is replaced with , provided that .

We will assume the standard topology on 
, which in particular implies that 
 (and hence ) have no isolated points.
Lemma 2

Let , and suppose  for some interval . Then

Proof

Firstly, , and therefore(4) By definition of the subset topology,  and  are open in I. Suppose . Since , this implies . If , then (4) implies I is the union of two non-empty disjoint open subsets. However, I is an interval and therefore connected, which is a contradiction. Thus , and (4) then implies . □

2.3. Algebra
Let 
 denote the ring of polynomials in the variables 
 with coefficients in R, where R is a commutative ring with multiplicative identity [27, Chapter 9]. Since  is an infinite integral domain, we do not distinguish between a polynomial 
 and the polynomial function 
 associated with it [28, Chapter 3, Section 5.1]. Let  denote the degree of p. In what follows, we are particularly concerned with the Euclidean domain  of univariate polynomials with real coefficients. Take note of the standard definitions below.

•
A polynomial  divides , denoted by , iff  for some , which can also be written as . The expression  asserts there is no such q.

•
A polynomial is monic if its leading coefficient is 1.

•
Let  denote the unique monic greatest common divisor of p and q. If , then , where  is the leading coefficient of p. Also,  is undefined.

•
Polynomials  are coprime iff .

•
A polynomial  is reducible if  for some . A polynomial is irreducible iff it is both non-constant and not reducible [18, Chapter 25].

•
A polynomial  is square-free [29] over  iff 
.

•
Let 
 denote the derivative of .

Proposition 4

Let  be non-constant, and let 
. Then  is square-free. Furthermore, , for any irreducible .

Proof

Proposition 6.6 of [28] states that q is square-free. Now it follows from [29, Corollary 1] that 
, where 
 is the irreducible factorisation [28, Chapter 3.4] of p. If u is an irreducible factor of p, then 
 for some i, which implies . □

Corollary 1

Let  be non-constant and 
. Then  iff .

The polynomial 
 is referred to as the square-free part of p. Proposition 4 demonstrates that q contains every irreducible factor of p, but without multiplicities.
Proposition 5

Let  be non-zero. Then 
 iff both  and 
.

Proof

The result holds trivially if . Assume u is non-constant. If 
 for some , then 
, and therefore 
. Suppose now that  for some . Then p is non-constant, and(5)
 Recall that 
, and therefore 
. If in addition 
, then (5) implies  for some , which in turn yields 
. □

For any polynomial 
, the inequalities 
 hold, where 
 and 
 [30, Chapter 3].
3. Problem formulation
3.1. Trajectories and observation maps
Definition 1

A trajectory is a continuous function .

A trajectory represents the evolution of a system over continuous time. We refer to X as the state space of the trajectory, which at this stage need only be a topological space. Note the variable x is used to represent both state values and trajectories, but its type is always clear from the context.
Given a finite set G of atomic propositions, an observation map is a function 
, which associates each state with a set of propositions. Specifically,  is viewed as the set of propositions satisfied by the state . Consequently, the set of states that satisfy the proposition  is given by 〚〛. Any state space region that can be generated by taking a finite number of set unions, intersections and complements over the family 〚〛 is called a region of interest generated by h.

Remark 2

Consider a map , with A a finite set. The state space X can be partitioned into the family of subsets 
. By definition,1 h is constant over each 
. Moreover, if h is an observation map, then 
 and 
〚〛
〚〛, which shows that every 
 is a region of interest generated by h.

Clearly  is the set of atomic propositions satisfied by the trajectory  at time . Thus, the composition 
 is the primary object to be verified. Since it is a map from the non-negative reals into a finite set, we can expect  to be piecewise constant when the trajectory and observation map are well-behaved. This property is typically expressed as a finite variability condition, which requires that  change value only a finite number of times over any bounded time interval [14].
Definition 2 Interval sequence

An interval sequence 
 is a set of non-empty intervals satisfying

2.a)

2.b)
 and 
 as 

2.c)

2.d)
.

Definition 2 implies , and it is equivalent to [14, Definition 2.2.1], but has been stated here in a manner that is easier for us to check. Note it is impossible for both 
 and 
 to be singletons, as this would contradict 2.a) together with 2.c). A function z with domain S is constant over  iff 
 for all 
. By this definition, every function is constant over the empty set.
Definition 3 Finite variability

A function , with  an interval, is of finite variability iff there exists an interval sequence  such that z is constant over  for every .

A trajectory x is said to be of finite variability under an observation map h [12, Definition 3] iff  is of finite variability. Only pathological pairs of trajectories and observation maps fail to meet this criterion. We exclude such cases from consideration, because they are of no practical interest.
3.2. Temporal logic semantics for continuous-time signals
In order to reason precisely about , a temporal logic that can be interpreted over continuous-time signals is required. We adopt MITL [14, Section 2], which can be interpreted over finite variability signals via timed state sequence (TSS) representations. Note the definition below is a restatement of [14, Definition 2.2.1].

Definition 4

A TSS over a finite set G is a pair  such that  is an interval sequence and 
.

This differs from the definition adopted in [9], which replaces each interval in  with a single point sampled from it. Given a TSS  over G, and an MITL formula φ over G, the satisfaction relation  is defined in [14, Definition 2.3.2.1]. A grammar that generates MITL formulae is presented in [14, Definition 2.3.1.1]. These precise definitions are not critical to the development of this paper so we do not repeat them here, but focus instead on presenting the pertinent relationships between our work and the wider literature.
Definition 5

A TSS , with 
, is a TSS representation of 
 iff

Clearly every TSS represents a unique continuous-time signal, which by Definition 3 is of finite variability. Furthermore, given 
 of finite variability, it is clear how a TSS representation  may be constructed from the interval sequence in Definition 3. Finally by [14, Remark 2.3.2.2], if 
 and 
 are both TSS representations of 
, then for any MITL formula φ,
 MITL satisfaction can therefore be extended to continuous-time finite variability signals as follows.

Definition 6 MITL satisfaction

Let G be a finite set of atomic propositions, φ an MITL formula over G, and 
 a function of finite variability. The relation  holds iff there exists a TSS representation  of z such that . Otherwise, .

Having defined the satisfaction relation for well-behaved continuous-time signals precisely, we are now in a position to state the general problem.
Problem 1 MITL verification

Given an MITL formula φ over a finite set of atomic propositions G, and a trajectory  of finite variability under an observation map 
, determine whether .

The works [6], [9] address this problem for various fragments of MITL. In this paper, we restrict attention to a fragment of MITL that has temporal operators only over , which corresponds to LTL without the next operator.
3.3. LTL as a fragment of MITL
The MITL operator 
 in [14, Definition 2.3.2.1] is a strict non-matching until operator [31], which only imposes requirements at future times. The standard semantics of LTL [32] are stated in terms of the non-strict non-matching until , which includes the current time within its scope. The relationship between the two is formalised below.

Definition 7 LTL without next

An MITL formula φ, over a finite set of atomic propositions G, is an 
⃠
 formula over G iff it is generated by the restricted grammar where , and 
.

In the context of trajectory verification, nothing is lost by omitting the LTL next operator from the above grammar. That operator would only have meaning for a fixed sampling strategy, which we do not wish to assume. In its place, nested  operators could be used to impose a desired sequence of transitions without specifying when they must occur. More generally, for 
⃠
 formulas, the precise timing information in  is not pertinent to the verification. The MITL satisfaction question for a TSS then reduces to an LTL satisfaction question for a discrete word, as per the remark below.
Remark 3

If φ is an 
⃠
 formula, then  holds for the TSS  iff  under standard discrete-time LTL semantics.

Remark 4

Definition 7 adopts the non-strict non-matching until  for consistency with the standard discrete-time semantics of LTL. However, any of the other variants in [31] could just as well be adopted, without affecting the results in this paper. The only requirement is that the same until variant be adopted for both 
⃠
 and its discrete-time counterpart.

Given LTL path checking has been well studied, and algorithmic solutions to it exist [1], [3], the missing step in the 
⃠
 verification of  is the construction of the first component ζ of its TSS representation, which we call an infinite trace.
Definition 8 Infinite trace

A function 
 is an infinite trace of 
 iff there exists an interval sequence  such that  is a TSS representation of z.

Thus we have shown that for 
⃠
 requirements, Problem 1 reduces to Problem 2 below.
Problem 2 Infinite trace construction

Given a trajectory  of finite variability under an observation map 
, construct an infinite trace of .

The remainder of this paper is devoted to Problem 2. A complete algorithmic solution is provided for particular classes of trajectories and observation maps.

4. Sampling trajectories
4.1. Trajectories and paths
A path is a standard object in topology, which can be used to describe the geometry and ordering of portions of a trajectory, while abstracting away the timing information.

Definition 9

A path is a continuous function .

A path has a compact domain, which forces its image to also be compact. This need not be true of a trajectory, and so not every trajectory can be fully represented by a path. Consider however the path , which describes the restriction of trajectory x to . The coordinate transformation  preserves the geometry and direction of x. All the information relevant to the LTL verification of  within the time interval  is retained in .
The relationship between paths and trajectories in continuous time mirrors the relationship between finite and infinite words in discrete time. As shown below, the prefix of a trajectory is a path, and the suffix of a trajectory is a trajectory.

Definition 10 Trajectory prefix and suffix

Let  be a trajectory. Then for a given , the path 
 is the prefix of x, and the trajectory 
 is the suffix of x.

Definition 11 Path prefix and suffix

Let  be a path. Then for a given , the path 
 is the prefix of r, and the path 
 is the suffix of r.

The concatenation operation defined below is called the path product in [25].
Definition 12 Path concatenation

Let 
 be paths such that 
. Then the concatenation 
 is defined by
 
 
 

The concatenation of two paths is a path [25, Chapter 9]. Trajectories may evolve along the same path in different ways. These correspond to having  for different mappings , which we refer to as motions.
Definition 13

A continuous map  is a direct motion iff it is non-decreasing, , and  as .

If u is a direct motion, then  is called a direct trajectory, which either arrives at the endpoint  in finite time, or approaches it asymptotically. Although many direct motions are possible, we can expect the resulting trajectories to retain similar LTL properties when defined along the same path.
Definition 14

A loop is a path r such that .

The map , given by , returns s modulo 1.
Definition 15

A mapping  is a cyclic motion iff there exists a non-decreasing surjection  such that .

If r is a loop, and u is a cyclic motion, the trajectory  moves perpetually around the loop in one direction. Such trajectories are referred to as cyclic. They need not be periodic, because they can move around the loop at different speeds each time. Thus, with the aid of path concatenation and direct/cyclic motions, a rich class of trajectories can be constructed from a finite number of paths.
Remark 5

This framework of paths, motions and trajectories is consistent with the decomposition of the robotic motion planning problem into a path planning stage followed by a path tracking stage, discussed in [33]. Path planning generates the path r, and path tracking prescribes a motion u along the path. Together, they yield the trajectory , which constitutes the motion plan.

4.2. Sampling functions for traces
Let  be a TSS representation of . According to Definition 5, the infinite trace ζ is sampled from  once within each interval of . A sampling function can be used to represent this, as done in [9].

Definition 16 Infinite sampling function

A map  is an infinite sampling function iff σ is strictly increasing,  and  as .

Observe that if σ is an infinite sampling function, then 
 is a discrete word, but not necessarily an infinite trace (see Definition 8). In the same way, paths can be sampled to obtain finite words.
Definition 17 Finite sampling function

A map  is a finite sampling function iff σ is strictly increasing,  and .

Definition 18 Sampling function

A sampling function is a finite sampling function or an infinite sampling function.

We refer to the values  taken by a sampling function as checkpoints. Beyond Definition 16, extra conditions on σ are required to guarantee that  is an infinite trace. These are made explicit in the definition below, which generalises Definition 8 to allow for finite traces.
Definition 19 Trace

Let A be a non-empty finite set,  an interval containing 0, and either  or . Then  is a trace of  iff there exist both a sampling function  and set 
⁎
⁎
 such that all of the following hold:

19.a)

19.b)

19.c)
⁎

19.d)
⁎

19.e)
⁎

19.f)
⁎
.

The sampling function σ is then said to record a trace of z. The checkpoints  are the sample points, which are always distinct by Definitions 16 – 18. The set 
⁎
 includes all times (or path parameter values) at which z changes value, but z is not required to change value at every 
⁎
. It is possible that 
⁎
⁎
 for some k, and this case is discussed further in Remark 8.
Remark 6 Finiteness of trace

Clause 19.b) requires that σ be a finite sampling function when , and an infinite sampling function when . Thus a trace of  must have a finite domain if y is a path, and domain  if y is a trajectory.

Remark 7 Origins of trace definition

Definition 19 is based on [13, Definition 2], which in turn derives from [11], [12]. Note some differences that are introduced here for convenience. Firstly, Definition 19 defines a trace in terms of a sampling function, and generalises [13, Definition 2] to permit traces with finite domains. Secondly, [13, Definition 2] is stated for x directly, whereas Definition 19 applies to . Specifically, 
 is a trace of  under Definition 19 iff it is a trace of x under [13, Definition 2].

The following result establishes that Definition 8, Definition 19 are consistent when . Its proof is more involved than the simplicity of the result might suggest, because of the number of clauses in both Definition 19, Definition 2 that must be verified.
Proposition 6

A mapping 
 is a trace of 
 iff it is an infinite trace of z.

Proof

 Suppose ζ is a trace of z. Then by Remark 6, there exist an infinite sampling function  and set 
⁎
⁎
 satisfying all clauses of Definition 19. By Clause 19.a), . Since σ is strictly increasing, Clause 19.c) implies 
⁎
⁎
, where each 
⁎
⁎
. An interval sequence  is now constructed by choosing 
⁎
⁎
⁎
 as the endpoints of every 
. To ensure mutual disjointness, the right endpoint 
⁎
 should be included in 
 iff(6)
⁎
⁎
⁎
 where the predicate ψ, defined over all , has been introduced to clarify the subsequent presentation. Let(7)
⁎
⁎
  and for each ,(8)
⁎
⁎
⁎
⁎
⁎
⁎
⁎
⁎
  Clearly the above case definition covers all possibilities. It must be shown that 
 is an interval sequence. Each 
 is an interval by construction, so it must now be shown that they are non-empty. If 
⁎
, then 
. Suppose on the other hand that 
⁎
. Then because σ is strictly increasing,
⁎
 by Clause 19.c), which implies  is true. Equation (7) in turn implies 
. Consider now . If 
⁎
⁎
, then 
. Suppose instead that 
⁎
⁎
. Then
⁎
⁎
⁎
 because σ is strictly increasing. This implies  is true and  is false, and (8) in turn implies 
⁎
⁎
⁎
. This establishes that 
 for all , as required by Definition 2. Given this, Clause 2.a) clearly follows from (7) – (8). To establish Clause 2.b), first note that 
 by (7). Now since  by Definition 16, Clause 19.c) then implies 
⁎
 as . Turning to the next clause, Equations (7) – (8) imply 
⁎
 for all . If 
⁎
, then (7) – (8) imply  is true, which further implies 
⁎
. This establishes Clause 2.c). Conversely, if 
⁎
, then  is false, which implies 
⁎
 by (8), establishing Clause 2.d). Thus  is an interval sequence.

It remains to be shown that  is a TSS representation of z. Choose any 
⁎
. If 
⁎
, then Clause 19.d) implies . Suppose instead that 
⁎
. Since 
, (7) then implies  is true, by which 
⁎
. Thus  for all 
. Now choose any  and 
⁎
⁎
. If 
⁎
⁎
⁎
⁎
, Clauses 19.d) – 19.e) imply . Alternatively, if 
⁎
, then  is true by (8), implying 
⁎
. The only remaining possibility for 
 is that 
⁎
. In that case,  is false, which implies that 
⁎
 or 
⁎
⁎
. If the latter, then 
⁎
 and it has already been shown that . If the former, then Clause 19.f) implies 
⁎
. It has been shown that, for any , for any 
, , satisfying Definition 5. Therefore ζ is an infinite trace of z by Definition 8.

 Suppose  is a TSS representation of z. A sampling function σ and a set 
⁎
 must now be constructed to satisfy all clauses of Definition 19. Definition 2 implies each 
 is non-empty. Define 
⁎
⁎
 where 
⁎
 for all 
. Let  be a function such that  and 
 for all  (e.g., choose  to be the midpoint of 
). It then follows from Definition 5 that , satisfying Clause 19.a). Note also that 
 by Clause 2.b). Clause 2.a) now implies that σ is non-decreasing, and Clause 2.c) then that it is strictly increasing. Clauses 2.a) and 2.b) also imply that 
, and therefore . Thus σ is an infinite sampling function by Definition 16, which in particular, satisfies Clause 19.b). To establish Clause 19.c), 
⁎
 for all . To establish Clause 19.d), choose any . If 
⁎
, then Clause 19.d) holds trivially for that k. Assume instead that 
⁎
 and choose any 
⁎
. Since 
 and 
⁎
, it follows that 
. Since also 
, Definition 5 then implies . To establish Clause 19.e), choose any . If 
⁎
, then Clause 19.e) holds trivially for that k. Assume instead that 
⁎
 and choose any 
⁎
. Since 
 and 
⁎
, it follows that 
. Since also 
, Definition 5 then implies . Finally, Clause 19.f) is directly implied by Clause 2.d) together with Definition 5. □

Remark 8

The proof of Proposition 6 reveals that 
⁎
 in Definition 19 consists of the endpoints of the intervals in the corresponding interval sequence in Definition 8. If some 
 is a singleton, then 
⁎
⁎
, which makes Clause 19.d) vacuous at  and Clause 19.e) vacuous at . In this case, it is possible that all three of the following hold:(9)
⁎
(10)
⁎
(11)
⁎
 indicating that z only holds its value at 
⁎
 instantaneously. To record a trace, the sampling function must place checkpoint  exactly at 
⁎
. A uniform sampling strategy almost surely fails to achieve this. The coming sections develop a trace generation algorithm capable of computing 
⁎
⁎
 exactly, for polynomial trajectories x, and observation maps h that only generate semi-algebraic regions of interest.

4.3. Manipulating traces
In this subsection it is shown how traces of paths may be combined, and traces of trajectories decomposed, into traces of paths. We first specify some relevant operations on discrete words.

Definition 20 Word operations

The definitions below hold for any  and , with  an interval and  a finite interval such that . Define .

20.a)
Letter repetition: 
, given .

20.b)
Word repetition: 
, with 
 for all .

20.c)
Word prefix: 
 and 
, given .

20.d)
Word concatenation: , where 
 

20.e)
Letter concatenation: 
, where 
, given .

Remark 9

Every non-decreasing surjection  is continuous, and can be viewed as a path reparameterisation.

Proposition 7 Path reparameterisation

Let  be a path,  a non-decreasing surjection, and , with A finite. Every trace of  is a trace of .

Proof

Let ζ be a trace of . By Remark 6, there exist a finite sampling function  and set 
⁎
⁎
 that satisfy all clauses of Definition 19. Clause 19.a) implies . First observe that, for any , 
 is non-empty because γ is surjective, and closed because γ is continuous (see Remark 9). Define  as(12) 
  and construct the set 
⁎
⁎
 by choosing(13)
⁎
⁎
 for all . Given that σ and 
⁎
 satisfy all clauses of Definition 19 for , the task is now to show that θ is a sampling function, and that θ and 
⁎
 satisfy all clauses of Definition 19 for .

By Definition 17, , implying that  for all . It follows that , and therefore . Thus θ satisfies Clause 19.a). Furthermore, σ is injective by Definition 17, which implies 
 whenever . This in turn implies that θ is injective, and hence strictly increasing because γ and σ are both non-decreasing. Recall that , which implies that . This establishes that θ is a finite sampling function, which in particular satisfies Clause 19.b). By Clause 19.c), 
⁎
 for all . For , 
⁎
 by definition. Consider now any . If 
⁎
, then 
⁎
 because γ is non-decreasing. Alternatively if 
⁎
, then it follows from (12) and (13) that 
⁎
. In the same way, it can be shown that 
⁎
 for all , establishing Clause 19.c). Turning to Clause 19.d), let  and suppose 
⁎
. Then 
⁎
⁎
, which implies . Clause 19.e) can be established in a similar manner, and Clause 19.f) holds because  and 
⁎
⁎
 for all . □

Corollary 2

Let  be a path,  a direct motion, and , with A finite. Then for any , every trace of 
 is a trace of 
.

Proof

If , then  for all , and therefore 
 for all . If instead , then 
, where 
 
 is a non-decreasing surjection. □

Propositions 8 – 12 below are consequences of the preceding developments, stated here without proof.
Proposition 8 Snipping Lemma

Let  be a path, and , with A finite. Suppose  is a sampling function that records the trace ζ of , and  for some 
. If , then 
 is a trace of 
. Otherwise, 
 is a trace of 
.

The concatenation of 
 with  in the Snipping Lemma is necessary to handle the case where , because Definition 19 requires the domain of a trace to contain at least two elements, but the domain of 
 is a singleton.
Proposition 9 Path concatenation

Let 
 be paths such that 
, and , with A finite. If 
 is a trace of 
, and 
 a trace of 
, then 
 is a trace of 
.

We refer to a trajectory x as invariant under h iff  is constant.
Proposition 10 Invariant trajectories

Let  be a trajectory, and , with A finite. If  is constant, then 
 is a trace of .

Proposition 11 Trajectory suffixes and prefixes

Let  be a trajectory, and , with A finite. For any , if 
 is a trace of 
 and 
 a trace of 
, then 
 is a trace of .

Corollary 3 Invariant suffixes

Let  be a trajectory, and , with A finite. Suppose there exists  such that 
 is constant. If  is a trace of 
, then 
 is a trace of .

Proof

The result follows directly from Proposition 10, Proposition 11. □

Proposition 12 Cyclic trajectories

Let  be a loop,  a cyclic motion, and , with A finite. If ζ is a trace of , then 
 is a trace of .

Corollary 4 Cyclic suffixes

Let  be a trajectory, and , with A finite. Suppose there exist a loop , cyclic motion , and  such that 
. If 
 is a trace of 
 and 
 a trace of , then 
 is a trace of .

Proof

The result follows directly from Proposition 11, Proposition 12. □

Surprisingly, direct trajectories require a more verbose result. The complication arises when one asymptotically approaches a point on the boundary of a region of interest, because it never actually gets there. Notwithstanding this, all direct trajectories have invariant suffixes, as established below.
Proposition 13 Direct trajectories

Let  be a path,  a direct motion, and , with A finite. Suppose  is a trace of . Then, for , there exists  such that 
 is constant. Moreover, if at least one of the following hold:(14)(15) then 
 is a trace of . Otherwise, 
 is a trace of .

Proof

Since ζ is a trace of , by Remark 6, there exist a finite sampling function  and set 
⁎
⁎
 that satisfy all clauses of Definition 19. Clause 19.a) implies . There are now three cases to consider, which cover all possibilities.

•
Suppose (14) holds, and choose any  such that . Since u is non-decreasing, it follows that  for all . Noting that , it follows that  for all , implying that 
 is constant. Now Corollary 2 implies that ζ is a trace of 
 because it is a trace of , and applying Corollary 3 then yields the result.

•
Suppose (15) holds. Choose  as in (15). Since u is non-decreasing and ,(16) by which (15) implies  for all . This shows that 
 is constant, and in particular that . Noting also that  by (16), the Snipping Lemma then implies that ζ is a trace of 
. Corollary 2 in turn implies that ζ is a trace of 
, and applying Corollary 3 then yields the result.

•
Suppose (14) and (15) are both false. If 
⁎
, then Clause 19.e) implies (15), which is a contradiction. Thus 
⁎
. Since , it follows that(17)
⁎
 Thus,  for all . This shows that 
 is constant, and in particular that . Noting also that  by (17), the Snipping Lemma then implies that 
 is a trace of 
. Corollary 2 in turn implies that 
 is also a trace of 
, and applying Corollary 3 yields the result. □

Remark 10

Only trajectories with cyclic or invariant suffixes are practically amenable to path checking, because in the absence of a model for the underlying dynamics, these are the only types of trajectories that offer information infinitely far into the future. Corollary 3, Corollary 4 establish that both have lasso word traces constructed from the traces of at most two paths. LTL verification of these traces can be performed using the discrete path-checking algorithms of [1], [3].

Remark 10 implies that all practical solutions to Problem 2 can be constructed from solutions to the problem below, which is conducive to an algorithmic solution because it always has a finite output. Just as for trajectories, we say that a path r is of finite variability under an observation map h iff  is of finite variability.
Problem 3 Finite trace construction

Given a path  of finite variability under an observation map 
, construct a trace of .

Observe that this places no restrictions on the LTL formula that can be satisfied. For any LTL formula φ, there exists a non-deterministic Buchi automaton (NBA) that accepts all and only the words satisfying φ [34, Corollary 23]. Furthermore, if the language accepted by an NBA is nonempty, it contains a lasso word [35, Proposition 3.3.1]. The remark below is a corollary of this.
Remark 11

An LTL formula is satisfiable iff there exists a lasso word that satisfies it.

Remark 12 Implications for robotic motion planning

In Corollary 4 and Propositions 12 – 13, the trace of  depends primarily on the path r, and is invariant to the motion u under only mild conditions. In the context of robotic motion planning (see Remark 5), this means that verification of the entire motion plan depends only on the path r, provided that the path tracking stage is restricted to produce a suitable class of motions.

4.4. Topological conditions on sampling functions
The result below provides a topological condition that is sufficient for  or  to be constant over an interval.

Corollary 5

Let , with A finite and  an interval, and let  also be an interval. If(18)
 then z is constant over I.

Proof

The result is trivial for , so assume . For all , 
. In particular, choose 
 for some 
. Clearly 
, and if (18) holds, then Lemma 2 implies 
. Thus, . □

A necessary topological condition for the situation described in Remark 8 is given in the next result. Specifically, that situation may only occur at isolated points.
Lemma 3

Let , with A finite and  an interval. Let 
, where 
, and suppose z is constant on 
 and on 
. If 
, where 
, then 
.

Proof

Suppose 
. Then clearly 
. Choose 
 and 
. By assumption, 
 for all 
, and 
 for all 
. Thus 
, which implies 
. □

We now combine these results to derive sufficient conditions for a sampling functions to record a trace. Though abstract, the result is crucial to the construction of our algorithm in Section 6. Although the focus of subsequent sections is on paths, notice that the result is also applicable to trajectories.
Theorem 1

Suppose that either  and  is finite, or  and . Let  be continuous, and , with A finite. Define 
 for , and(19) 
 
 
 If  is a sampling function such that

i)
,

ii)
,

then  is a trace of .
Before proceeding with the proof, we pause to interpret this theorem. Each 
 is a state space region over which h is constant, and the family 
 partitions X (see Remark 2). Given the path (or trajectory) r, 
 is the set of parameter values s at which 
. The set  contains only the parameter values at which r enters or leaves some 
, and  contains the parameter values at which the path locally touches some 
 at only a single point. Condition i) forces a checkpoint at such isolated points, and Condition ii) ensures there can be no more than one boundary crossing between consecutive checkpoints. Since S is an interval and 
, it follows that  by Proposition 2.
Proof

Suppose Conditions i) and ii) hold. Clauses 19.a) and 19.b) of Definition 19 follow directly from the theorem hypotheses. Below, we construct the set 
⁎
⁎
, which is then shown to satisfy the remaining clauses of Definition 19. For all 
, define(20)
⁎
  Condition ii) ensures the above case definition is exhaustive. Clearly 
⁎
 for all 
, satisfying Clause 19.c).

Suppose, for a contradiction, that there exists 
 for which 
⁎
. Then there exists  such that(21)
⁎
 Since 
⁎
 and , Condition ii) implies . Then 
⁎
 by (20), which contradicts (21). Thus, 
⁎
 for all 
. Further, using (19),
⁎
 Corollary 5 then implies  is constant over 
⁎
, whereby(22)
⁎
 which establishes Clause 19.d).

Suppose now there exists 
 for which 
⁎
. Then there exists  such that(23)
⁎
 Since 
⁎
 and , Condition ii) implies . Then 
⁎
 by (20), which contradicts (23). Thus, 
⁎
 for all 
. Moreover, using (19),
⁎
 Corollary 5 then implies  is constant over 
⁎
, therefore(24)
⁎
 which establishes Clause 19.e).

Now let 
, and suppose that both the following hold:(25)
⁎
(26)
⁎
 Together with (22) and (24), Lemma 3 then implies 
⁎
, where 
⁎
. Condition i) further implies 
⁎
 for some , and (20) in turn implies . However (25) and (26) imply . Since there is no natural number strictly between k and , a contradiction ensues. Therefore, for any 
, (25) and (26) cannot both be true, and Clause 19.f) has been established. □

Remark 13

The final paragraph of the proof demonstrates that if (9) – (11) of Remark 8 hold for , then 
⁎
.

We conclude this section with a lemma that simplifies the application of Theorem 1 to an observation map, which has codomain 
. The result introduces a computationally cheaper over-approximation 
 to the set of boundary crossing points Γ.
Lemma 4

Let  be an interval,  a continuous function, and 
, with G finite. Let 〚〛 for , and 
 for . Then(27) 
 
 
〚〛

Proof

Let 〚〛
〚〛. For any ,
 〚〛 
 〚〛 
 〚〛 
 〚〛
 and therefore(28)
 
〚〛 
 
〚〛
 where 
. Applying Proposition 3, and noting that the boundary of a set is equal to the boundary of its complement,
 
〚〛 
 
〚〛
 
〚〛 Since the above hold for any , (27) then follows. □

The set 
 in (27) is a union of -many sets, a saving when compared with Γ, which is a union of 
-many sets. The set inclusion in Lemma 4 permits us to replace Γ with 
 in Condition ii) of Theorem 1, without otherwise changing the result.
5. Sampling polynomial paths
5.1. Polynomial path and region assumptions
In this section, we focus on solving a special case of Problem 3 in which r is a polynomial and h only generates semi-algebraic regions of interest. Proposition 9 on path concatenation allows the results of this section to be directly extended to polynomial splines.

Assumption 1 Polynomial paths and region boundaries

Let .

i)
Given 
, let(29)
 where 
 is continuously differentiable for each .

ii)
Suppose in addition that 
 for each .

iii)
Let 
 for some 
.

Thus,  is the number of atomic proposition and  is the dimension of the state space. Under Clause ii), h can be made to generate any semi-algebraic region of interest by choosing M and the 
 appropriately. Note that 
 in Clause iii) is a vector function, each component of which is a univariate polynomial, and thus 
. The key property that makes an algorithmic solution possible is that every 
 is also a univariate polynomial, having a finite number of roots if non-zero. Lemma 6 and Corollary 7 in the next subsection characterise the isolated points discussed in Remark 8, Remark 13. They provide insight in a more general context that only requires the 
 to be continuously differentiable, which is the reason for separating Clauses i) and ii) in Assumption 1.
Take note of the relationship(30)
〚
〛
 The following lemma assures us that if  lies on the relative boundary of some 
〚
〛, then for that i, we have 
.

Lemma 5

Let  be continuous, with  an interval. Then

Proof

Let 
 and 
⁎
. Suppose that 
⁎
. Since g is continuous, there exists some U that is an S-neighbourhood of 
⁎
, such that  for all . Clearly , and therefore 
⁎
 is not a boundary point of G relative to S. Similarly, if 
⁎
, there exists some U that is an S-neighbourhood of 
⁎
, such that  for all . In this case , and therefore 
⁎
 is not a boundary point of G relative to S. This proves that 
⁎
⁎
. □

The next result implies that if 
 is the zero polynomial, or has no roots in , then the relative boundary of 
〚
〛 is empty.
Corollary 6

Let  be continuous, with  an interval. If 
, then .

Proof

Suppose 
. Then Lemma 5 implies . If , then 
 by Proposition 1, which is a contradiction. □

We now pause to consider polynomial trajectories, which (if non-zero) have unbounded images. This case violates Clause iii) of Assumption 1, however the result below reveals that such trajectories always have invariant suffixes when the remaining clauses hold. Therefore, according to Corollary 3, the trace of a polynomial trajectory can still be constructed from the trace of a suitable prefix, which does satisfy Assumption 1. Hence, traces of polynomial trajectories can also be computed within the current framework.
Proposition 14 Unbounded polynomial trajectories

Let Clauses i) and ii) of Assumption 1 hold, 
, 
, and . Define
 
 If  for all , then 
 is constant.

Proof

Suppose 
 is non-constant. Then by Corollary 5,
 Noting that 
 for , this implies 
 
 and Lemma 4 in turn implies 
 
〚〛 Recalling that 
〚
〛
 for every 
,
 
 Lemma 5 and Corollary 6 then imply
 Thus  for some , which establishes the contrapositive of the result. □

Remark 14

To obtain an invariant 
 in Proposition 14, L can be any strict upper bound on the real roots of P. Various upper bounds for polynomial roots are provided in [28, Theorem 4.2].

5.2. Isolated point characterisation
The next result characterises the isolated points in Θ in terms of the relative boundaries of the 
〚
〛, and the derivatives 
. A more intuitive restatement is then provided in Corollary 7, along with an illustration in Fig. 1.

Lemma 6

Suppose Clause i) of Assumption 1 holds. Let 
 also be continuously differentiable, and 〚
〛
. If 
 
 where 
 for , then at least one of the following hold:(31)
〚
〛(32)
〚
〛
〚
〛(33)
〚
〛

Proof

Note that  has no isolated points, and 
 for every . Then recalling Remark 1, Proposition 2 implies 
, and therefore 
.

Let . Then Lemma 4 implies there exists  such that(34)
〚
〛
 This in turn implies 
 by Lemma 5, and therefore(35)
〚
〛 To obtain a contradiction, suppose (31) – (33) are all false. Since (34) is true and (31) false, . Furthermore, (33) is false, and therefore 
. This implies s is not a local minimum of 
, so for any S-neighbourhood V of s, there exists 
 such that 
. Therefore(36)
〚
〛 Since , there exists  such that(37)
 Now recall (28), which is restated below:
 
〚〛 
 
〚〛
 From (35) it follows that 
, because if 
, then 
〚
〛
. The above equation can therefore be re-written as(38)
〚
〛
 where
 
〚〛 
 
〚〛
 Given (38), Lemma 1 implies(39)
〚
〛 and applying Proposition 3 to the definition of 
,
 
〚〛 
 
〚〛
 
〚〛 Since (32) is also false, 
〚
〛 for every . Then clearly 
, and together with (37), (39) implies 
〚
〛, which contradicts (36). □

Corollary 7 Necessary conditions for isolated points

Under the hypotheses of Lemma 6, let
 If  then at least one of the following hold:

i)
 and there exists  such that 

ii)
there exist  with  such that 

iii)
there exists  such that 
.

Proof

Applying (30) and Lemma 5 to (31) – (33) yields i) – iii), respectively, but for . Corollary 6 additionally confirms that . □

Remark 15

Consider the case in Remark 8 for . Equations (9) – (11) imply 
⁎
, and Remark 13 implies 
⁎
. Corollary 7 now makes it clear that, for 
⁎
, ii) and iii) are the only possible conditions under which (9) – (11) occur. Specifically, 
⁎
 is a root of two distinct non-zero 
, or a shared root of some non-zero 
 with its derivative. Thus, potential isolated points can be identified by testing for the presence of double roots.

In view of Fig. 1, we refer to points satisfying (32) and (33) as double crossing and bounce points, respectively.
Fig. 1
Download : Download high-res image (43KB)
Download : Download full-size image
Fig. 1. Points s1,s2,s3 ∈ [0,1] depict the three types of isolated points in (31) – (33), respectively, from each of which follow i) – iii) of Corollary 7, respectively.

5.3. Algebraic conditions on sampling functions
We are now ready to state the main result, which specialises Theorem 1 to the setting described by Assumption 1.

Theorem 2

Suppose Assumption 1 holds. Define(40)
 let  be a non-zero polynomial such that(41) 
 
 and 
. If  is a finite sampling function such that(42)
(43)
 then  is a trace of .

Once again, we pause for interpretation before proceeding with the proof. Recall that r is the restriction of the vector polynomial ρ to . Equation (40) can therefore be expanded to(44)
 Thus  selects all non-zero 
 with roots in  to be factors of P in (41). Referring to Theorem 1, all boundary points in Γ are roots of P. Similarly, any isolated points in Θ are repeated roots of P, and therefore roots of V. Conditions (42) – (43) then ensure the conditions of Theorem 1 are satisfied. The next section considers how to construct a sampling function that satisfies (42) – (43).
Proof

Let , 
 for , and define Γ and Θ as in (19). First note that each 
, because 
 and 
 by Assumption 1. The following chain of equalities and inclusions is now established:(45) 
 
〚〛
 
 
(46) 
 
 
 The first inclusion of (45) follows from Lemma 4, and (30) establishes the subsequent equality. For any , if , the contrapositive of Corollary 6 implies 
, which in turn establishes the second equality of (45). The first inclusion of (46) follows from Lemma 5, and the second holds because r is a restriction of ρ. If 
 for  and , then (41) implies , which establishes the final inclusion. If (43) is satisfied, then (45) – (46) imply Condition ii) of Theorem 1 is also satisfied. Also since 
 is non-zero for all , P can indeed be non-zero, as assumed.

Now suppose 
. Then at least one of i) – iii) of Corollary 7 hold true. If i), then 
 by Definition 17. Consider now the latter two points. If ii) holds, then 
 for some distinct , and it follows from (41) that 
. If iii), then 
 for some , which implies 
 by Proposition 5, which in turn implies 
. In either case then, 
. Now  is square-free by Proposition 4, and . If 
, then 
, which is a contradiction. Thus 
, and 
. If (42) holds, then 
. It has been shown that , satisfying Condition i) of Theorem 1. □

Remark 16

Condition (41) permits some flexibility in the choice of P, which is useful for the algorithm designer. This issue is discussed further in Section 6.5, but it is worth noting that there is no clear choice of P that yields optimal computational complexity for all problem instances.

Remark 17

Throughout this section, it has not been necessary to explicitly assume finite variability in any of the results. In fact, Assumption 1 guarantees that  is of finite variability, because all univariate polynomials have a finite number of roots.

6. Algorithmic implementation
6.1. Overview of sampling strategy
According to Theorem 2, we can compute a trace of  by constructing a sampling function that places checkpoints

1)
on either side of every root of P in  to satisfy (43); and

2)
exactly at every root of V in  to satisfy (42).

Since P and V are univariate polynomials, we can exploit some concepts and subroutines from Computer Algebra to do this algorithmically. In particular, we require a root existence test and a root isolation algorithm.
Before proceeding with a discussion of these subroutines, recall that any polynomial  with rational coefficients can be scaled to form a polynomial  with integer coefficients, without changing its roots. Specifically, let

Image 1
multiply p by the product of the denominators of its coefficients. Its arithmetic complexity is 
.
6.2. Root existence test
The result below, based on Descartes' Rule of Signs, provides a computationally robust test to determine whether a univariate polynomial has any real roots in an open interval.

Proposition 15

Let  be non-zero, , and(47)
 
 where . All the non-zero coefficients of q have the same sign iff p has no roots in the interval .

Proof

As noted in [36, Section 3], the Möbius transformation 
 
 is a bijection from  to . Furthermore, . Thus for any , 
, where 
 
. Let  denote the number of sign changes in the sequence of coefficients of q [36]. If , then q has no roots in  by [37, Theorem 4], which implies p has no roots in . Conversely, if p has no roots in , then q has no roots in , which implies  by [37, Theorem 5]. □

Suppose  is given by 
, and consider the following operators of type  for :
 
 
 
 
 
 
 The transformed polynomial q in (47) can then be computed according to 
. Operator  is the reciprocal transformation [38, Definition 4, Remark 6], which simply reverses the order of the coefficients. The Taylor shift [30, Chapter 4.1] operation 
 can be performed in 
 arithmetic operations [30, Theorem 4.3].

Remark 18

The existence of roots of  in the interval  can be determined in 
 arithmetic operations. This can obviously be extended to the closed interval by evaluating  and .

6.3. Root isolation subroutine
Given a polynomial  with root 
, a bounded interval is an isolating interval for 
 iff it is either open or a singleton, contains 
, and contains no other roots of p. An isolating interval for 
⁎
 is a strict isolating interval iff it is open and its closure contains no other roots of p.

We focus below on constructing isolating intervals for the roots of polynomials in . For computational reasons, attention is restricted to polynomials with rational coefficients and intervals with rational endpoints.

Definition 21 Root isolation algorithm

Given , a root isolation algorithm returns a set of intervals(48)
 of cardinality , such that all of the following hold:

21.a)
each 
 is either open or a singleton

21.b)
each 
 has rational endpoints

21.c)
 for all 

21.d)
every root of p in  is contained in some 

21.e)
every 
 contains exactly one root of p.

The output (48) is represented in pseudocode by 
RootIsolation(p). Clearly each 
 is an isolating interval for some root of p. Letting 
 and 
 for , the interval endpoints satisfy
 The Vincent, Collins and Akritas (VCA) Algorithm [39], also known as the Modified Uspensky or Descartes method, is a well-studied root isolation algorithm that performs a bisection search using Descartes Rule of Signs. Its output complies with Definition 21, and the algorithm is presented concisely in [36, Algorithm 1].
Remark 19

If  is square-free, then the bit complexity of the VCA algorithm is 
, where  and 
 [40, Theorem 4.1].

Our strategy is to use a root isolation algorithm to place a checkpoint on either side of the roots of P. However, Definition 21 permits roots at the boundaries of the isolating intervals, which leads to problems. In order to guarantee (43), all the isolating intervals must be strict. We therefore adopt the more stringent definition below. Note that singleton intervals are not permitted.
Definition 22 Strict root isolation algorithm

Given any , a strict root isolation algorithm returns a set of intervals
⁎
 of cardinality , such that all of the following hold:

22.a)
 for all 

22.b)

22.c)
every root of p in  is contained in some interval 

22.d)
every interval 
 contains exactly one root of p

22.e)
.

Remark 20

It follows from Definition 22 that. for all , the closed interval 
 contains exactly one root of p. Also observe there is at most one root of p in 
, which can only occur if . Similarly, there is at most one root of p in 
, which only occurs when . The proof of Theorem 3 in Section 6.4 relies on these properties to establish (43).

Using lower bounds on polynomial root separation [41], the output of a root isolation algorithm is readily modified into the output of a strict root isolation algorithm. Algorithm 2, StrictIsolatingIntervals, offers a procedure for doing this. Since this procedure is somewhat distracting, and motivated by aspects of the main algorithm yet to be presented, the details are deferred to Algorithm 2 in Appendix A.

6.4. PolyTrace algorithm
Recall the two-step procedure outlined in Section 6.1. Step 1) can be achieved by means of a root isolation algorithm. Step 2) is problematic, because in general the roots of V cannot be computed exactly. And even if they could, the roots may not be rational. Approximate roots will not do, because the roots of V extract isolated points, which by definition capture information absent from their neighbouring points. The following result demonstrates that, even if an isolated point 
 is not known precisely, the set 
 needed to construct a trace can still be evaluated by means of a root existence test. Only a strict isolating interval for 
 is required.

Lemma 7 Isolation Lemma

Under the Assumptions of Theorem 2, suppose there exist 
 such that(49)
 Then 
.

The Isolation Lemma tells us that, given a strict isolating interval  for the root 
 of P, the set 
 can be computed by evaluating , and then adding to it all 
 for which 
 has a root in .
Proof

Define 
. It is first shown that (i) 
, then that (ii) 
, and finally that (iii) 
.

Observe that(50)
 (i) Suppose 
. Then 
 for some 
. Recall (44), restated below:(44)
 If , then (44) implies 
 and therefore 
, which in turn implies 
 by (50). Suppose instead that . Then 
 by (41), and furthermore 
. The assumption (49) then implies 
, by which 
 and therefore 
. Thus 
.

(ii) Suppose now that 
, which implies(51)
 If , then by (44) either 
, which implies 
, or 
 has no roots in , which implies 
, and moreover, that 
 due to continuity. In either case, 
, hence 
. Suppose instead that . Then 
 by (41), and since 
, (49) implies . Since 
, it follows that 
, and therefore 
 by (51). If 
, then 
 by (50). If 
, then by the Intermediate Value Theorem there exists 
 such that 
, and therefore 
. Thus 
, which establishes that 
.

(iii) Finally, suppose 
, which implies 
. If 
, then 
. Suppose now 
. If 
, then 
. Alternatively if 
, then by the Intermediate Value Theorem there exists 
 such that 
, and therefore 
. Thus 
. □

Lemma 7 is exploited in Lines 21 – 24 of Algorithm 1, the correctness of which is now established.
Theorem 3

Suppose Assumption 1 is satisfied. In addition, let , 
, and 
 for all . Then the output

Image 2
of Algorithm 1 is a trace of .
Proof

First note that a checkpoint is placed at 0 and 1 by virtue of Lines 2 and 32, to satisfy Definition 17.

Lines 3 – 9 form(52) 
 
 where  is given by (44). This definition clearly satisfies (41), and V is then computed in Line 10 as prescribed by Theorem 2. The square-free part Q of P is computed in Line 11. Strict isolating intervals for the roots of Q in  are computed in Lines 12 – 16. By Corollary 1, these are also strict isolating intervals for the roots of P in , because P and Q share exactly the same roots. Checkpoints are placed at the start 
 of each isolating interval in Line 19, and at the end of the final isolating interval 
 in Line 27. Any remaining roots of P in  are included in the checkpoints at 0 and 1. As noted in Remark 20, there is exactly one root of P in 
 for any . Furthermore, there is at most one root in 
 and in 
. Thus, (43) is satisfied.

Line 21 tests for potential isolated points by checking the degree of V. If , then V has no roots in . Otherwise, , and Lines 21 – 24 exploit Lemma 7 to evaluate  at the unique root of P within every strict isolating interval. Since , this includes all roots of V in . Any additional roots of V in  are included in the checkpoints at 0 and 1. Thus, (42) is satisfied.

Finally, if no 
 has roots in , the empty set is returned in Line 12, implying that . In this case,  and . It is still possible that P has roots at both endpoints . Therefore, a checkpoint  is placed at their midpoint in Line 29, to ensure there is no more than one root in  for each , as required by (43). □

Algorithm 1
Download : Download high-res image (125KB)
Download : Download full-size image
Algorithm 1. Computes a trace of h∘ρ↾[0,1], where 
, and h(x):={i ∈ {1,...,M}|gi(x)≤0}.

6.5. Computational complexity of PolyTrace
The complexity of Algorithm 1 depends heavily on the subroutines chosen for the individual steps. In this section, it is assumed that for every , 
 has no more than N non-zero coefficients and 
, where each 
 is formed in Line 5 of Algorithm 1. To understand how N and D can be derived from upper bounds on , 
, and the state space dimension n, refer to Appendix B.

•
Formation of P: forming each 
 requires 
 arithmetic operations (see Appendix B). Each root existence test in Line 6 requires 
 arithmetic operations. These are both done M times. Finally, , and therefore forming P requires 
 arithmetic operations [30, Lemma 3.15]. Overall, Lines 3 – 9 require 
 arithmetic operations.

•
G.c.d computation: [42, Algorithm 10.1], which has 
 arithmetic complexity, performs Lines 10–11 and returns both Q and V with integer coefficients. Implementations with polynomial bit complexity exist [42, Remark 10.19]. See [18, Chapters 3, 6, 11 ] for a detailed discussion of the available algorithms for g.c.d computation, and their complexities.

•
Root isolation: this step has bit complexity 
 for  by Remark 19, where  is any constant such that 
.

•
•
Computing 
: this requires at most MD root existence tests for polynomials of degree D or less, yielding an overall arithmetic complexity of 
 for Lines 13 – 15.

While a more detailed analysis of the growth in polynomial coefficients sizes is required to obtain a precise estimate, the bit complexity of PolyTrace is clearly polynomial. The root isolation step appears likely to dominate.
Now as noted in Remark 16, the choice P affects the complexity of the algorithm. Given the above complexity estimate of the root isolation step, omitting unnecessary factors from P in (41) potentially offers significant improvements. The definition (52) adopted by Algorithm 1 constructs the lowest degree polynomial that satisfies (41). However, this requires the root existence test in Line 6, which adds 
 complexity. An alternative definition 
 
 dispenses with the root existence test, but makes no attempt to reduce . Both approaches have the same worst-case asymptotic complexity, because it may well be that all 
 have roots in , making the test redundant. If it is known a priori that only a few boundaries are likely to be crossed within a given segment, we expect that (52) leads to a net reduction in complexity.

7. Numerical examples
7.1. Randomly generated examples
Fig. 2 depicts a randomly generated instance of Problem 3 involving a two-dimensional polynomial spline path, and atomic propositions that are mapped to either ellipses or half-spaces. Algorithm 1 has been implemented in Wolfram Mathematica 12.1, taking advantage of the native RootIntervals root isolation function. The output of PolyTrace for each segment is concatenated and included in Fig. 2, after a post-processing step that removes consecutive repetitions from the trace. Region 8 has been constructed to induce a bounce point between the first and second waypoints, and Regions 6 and 7 to induce a double crossing point between the second and third waypoints. Equipped with this knowledge, the reader is invited to visually confirm the trace produced.

Fig. 2
Download : Download high-res image (545KB)
Download : Download full-size image
Fig. 2. Polynomial spline path connecting 8 waypoints under 9 atomic propositions. (For interpretation of the colours in the figure(s), the reader is referred to the web version of this article.)

7.2. Case study: verification of a robot motion plan
Consider a mobile robot on a factory floor, tasked with fetching a hazardous chemical compound and returning to a target zone, without colliding with obstacles. The chemical is stored in a 0.5 m diameter drum, and the robot also has a circular perimeter, 1.5 m in diameter. The drum attaches to the side of the robot, via a latching system. Both robot and drum must remain within a predefined 20 m x 20 m safe zone, which is guaranteed to be clear of moving obstacles throughout the operation. The drum, and any static obstacles, are detected using a system of cameras, and are represented within the robot's map by enclosing ellipses. The surface of the robot must make contact with the surface of the drum in order to trigger the latching system. The unstable nature of the chemical compound requires contact to be made gently, and this imposes precise requirements on the robot trajectory. Here, we encode these requirements in 
⃠
, and use PolyTrace to certify a cubic spline proposed by a path planner for the robot. The subsequent path tracking stage (see Remark 5) is guaranteed to produce only direct motions. Since this is a safety critical mission, the resulting motion plan must be verified independently, prior to execution. Here, as explained in Remark 12, the verification of the motion plan depends only on the path proposed by the path planner.

Fig. 4 depicts the path superimposed on the robot's map. Obstacles are shown in solid black, the drum in red, and the safe zone corresponds exactly to the plot axes limits. We model the robot as a disk. Since the path is to be tracked by the centre of the robot, collisions can be avoided by expanding the obstacles in the map by the radius of the robot. These expanded obstacles are represented by Ovals 4, 6 and 8. In general, the expanded obstacles are no longer ellipses, but are instead defined by the 8th-order polynomial in [43, Example 4]. After the robot has latched onto the drum, collision avoidance for their composite shape can be achieved by further expanding the obstacles by the diameter of the drum, yielding Ovals 5, 7 and 9. Similarly, Halfspaces 10, 12, 14 and 16 enclose the safe zone contracted by the robot radius, and Halfspaces 11, 13, 15 and 17 contract it again by the drum diameter. Oval 2 expands the drum by the robot radius, so that the robot touches the drum iff its centre touches Oval 2. Finally, the target zone is represented by Oval 1.

Fig. 4
Download : Download high-res image (527KB)
Download : Download full-size image
Fig. 4. The proposed path for the robot is shown in red. Black filled regions represent obstacles, and the red disk at (3,-7) represents the drum. The boundaries of Oval 2 and Exterior 3 coincide. Units are in meters.

We now work with the set of atomic propositions 
. The observation map h associates each 
 with the ith region (either Oval i or Halfspace i) in Fig. 4. In order to specify the surface contact requirement, we have also defined the region ‘Exterior 3’ by the polynomial 
. Thus, Exterior 3 is the complement of the interior of Oval 2, and the two regions only intersect on their common boundary. The formula 
 then permits the robot to make contact with the surface of the drum, without penetrating its interior. The complete mission requirement can be expressed in 
⃠
 as 
, where
 The mission goal is expressed by 
, which requires the robot to eventually make contact with the drum, before entering the target zone and remaining there. Formula 
 prohibits the robot from colliding with the inner boundaries of the obstacles and ‘unsafe’ zone, which have been expanded by the robot radius. Formula 
 does the same for the outer boundaries, which have been expanded by the drum diameter as well. Formula 
 only requires 
 to hold from the point of contact with the drum.

The trace of the proposed path, computed by PolyTrace, is given at the bottom of Fig. 4. This path 
 can then be composed with a direct motion  to generate the direct trajectory . Invoking Proposition 13, the resulting trace is
 where σ is the corresponding sampling function. It is straightforward to verify that , which holds for any direct motion u produced by the path tracking stage.

Remark 21

The surface contact requirement 
 is an example of an 
⃠
 formula that can only be satisfied with zero robustness. To the best of the authors' knowledge, there are no other approaches in the literature capable of verifying a continuous-time trajectory against such a specification, because the existing verification approaches rely on strictly positive robustness margins. For a real-world implementation, it is, of course, acceptable to relax 
 by expanding the contact boundary into a contact area. In practice, a sufficiently small expansion does not jeopardise the mission, because the use of feedback control makes the latching system robust to small deviations from the ideal path. However, the existing approaches, which are based on [9], still demand high frequency sampling at a rate that is not known beforehand. The tighter the expansion, the harder it becomes to verify any path proposed. As discussed in the introduction, multiple attempts may be made without guarantee of an outcome. By contrast, even in the most extreme cases, PolyTrace never fails to return a conclusive result, as this example serves to demonstrate.

8. Conclusion
This paper culminates in an algorithmic solution to a special case of Problem 3, in which the path is a polynomial, and the observation map generates semi-algebraic regions of interest. First, the more general problem of verifying a trajectory under an observation map against a temporal logic specification is formally stated as Problem 1. Its formulation relies on the MITL semantics of [14], which can be interpreted over continuous-time signals of finite variability via their TSS representations. The trace of such a signal is identified with the first component of its TSS representation. The specification language 
⃠
 is then introduced as a fragment of MITL, and Remark 3 emphasises that for 
⃠
 formulas, MITL satisfaction of a continuous-time signal can be inferred from LTL satisfaction of its trace. Narrowing the scope to 
⃠
 formulas, the focus of the paper shifts to Problem 2: generating a trace of a trajectory. As argued in Remark 10, the only trajectories that are practically amenable to path checking have infinite traces that are lasso words composed of the finite traces of paths. Thus, we arrive at Problem 3: generating the trace of a path. This can be done by sampling the path judiciously, and Theorem 1 presents topological conditions for a sampling function to achieve this. Section 5 applies this result to sample polynomial paths under observation maps that only generate semi-algebraic regions of interest, deriving more concrete conditions in terms of the roots of univariate polynomials. The PolyTrace algorithm proposed in Section 6 invokes root isolation and root existence subroutines from computer algebra to satisfy these conditions. One novel feature of this algorithm is its ability to sample at the isolated points characterised in Corollary 7. Correctness of the algorithm is proved, and its complexity shown to be polynomial in the number of atomic propositions. Numerical examples and a case study are provided in Section 7, including an example of an LTL specification that cannot be verified using other existing methods.

An obvious extension to our work is to relax the restriction to 
⃠
 specifications by permitting bounded temporal operators. In this case, satisfaction no longer depends exclusively on the trace, so new analysis is required. The precise locations of the polynomial roots are then of greater importance, because they correspond to crossing times. Furthermore, we expect the polynomial assumptions to simplify the calculation of robustness margins, and improve on the margin estimates in [9], [10], [16], [44]. This paper has only considered the verification problem, but it is possible that the synthesis problem (i.e., generating polynomial trajectories guaranteed to satisfy formal specifications) may also benefit from the methods we have discussed.