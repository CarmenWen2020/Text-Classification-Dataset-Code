Abstract
Dendrite P (DeP) systems are a new variant of neural-like P systems, abstracted by the information processing and feedback mechanisms of dendrites. In the variant, a global block is assumed to synchronize all of neurons, hence, DeP systems work in synchronous mode. This paper investigates sequential version of the variant, that is, sequential dendrite P (SDeP) systems. Based on maximum number of spikes in neurons, two sequential modes are distinguished: max-sequentiality and max-pseudo-sequentiality strategies. SDeP systems have two interesting and recognizable features: (i) it behaves as a firing-storing process; (ii) cooperative firing mechanism. The computational completeness of SDeP systems is discussed. We prove that SDeP systems can be used as Turing universal number generating/accepting devices for max-sequentiality and max-pseudo-sequentiality strategies. We also establish a small universal function computing device of SDeP systems with 91 neurons in max-sequentiality strategy.

Keywords
Membrane computing
Neural-like P systems
Sequential dendrite P systems
equential mode
Computational completeness

1. Introduction
As one of membrane computing models [1], [2], [3], [4], spiking neural P (SNP) systems [5] were inspired from the phenomenon that neurons send the spikes along synapses in biological nervous systems. Generally, an SNP system can be expressed by a directed graph, where the nodes denote the neurons and the arcs indicate the synapses between these neurons. SNP systems have two ingredients: data (the number of spikes) and rules. There are two types of rules: spiking/firing rules and forgetting rules. The data is used to describe the state of SNP systems and is evolved by rules. SNP systems have been used in a lot of real-life applications [6], for example, combinatorial optimization [7], [8], fault diagnosis [9], image processing [10], [11], [12], [13], [14], [15], [16], and information fusion [17].

A variety of biological phenomena and mechanisms derived from neuroscience have been introduced to propose various variants of SNP systems in the past years. In inspiration to inhibitory and exciting effects of astrocytes on synapses, SNP systems with astrocytes have been investigated [18], [19]. Moreover, inhibitory spike of neurons has inspired the proposal of SNP systems with anti-spike [20]. In inspiration to multiple chemical channels in the synapses of neurons, SNP systems with multiple channels have been proposed [21], and other working modes were discussed in Refs. [22], [23], [24]. The positive and negative charges were introduced in neurons to develop SNP systems with polarization [25], [26]. By moving rules from neurons to synapses, SNP systems with rules on synapses have been investigated [27], and other versions with different strategies were further discussed [28]. Moreover, SNP systems with request rules [29], structural plasticity [30], communication on request [31], delay on synapses [32] and nonlinear structure [33] have been discussed. Some biological mechanisms have inspired several new variants of SNP systems, for example, dynamic threshold mechanism [34], [35], nonlinear coupled mechanism [36], inhibitory rules [37] and evolution-communication [38]. Moreover, fuzzy logics have been introduced to propose fuzzy SNP systems [39]. Computational power of SNP systems as number generating/accepting devices, function computing devices and language generating devices has been investigated [40], [41], [42], [43].

Usually, three working modes are considered: synchronous, asynchronous and sequential modes. SNP systems mentioned above all work in synchronous mode: a global clock is assumed to synchronize all neurons. However, from the perspective of biological nervous systems, it is unrealistic to build a global clock to synchronize the triggering of all neurons. For this reason, Turing universality of SNP systems working in asynchronous mode has been investigated [44], [45], [46]. Moreover, SNP systems working in sequential mode have been discussed [47], [48], [49], [50], [51], [52].

It has been revealed that dendrites not only show passive channels and can be abstracted as information processors, and dendrites have a feedback mechanism. The scientific discovery has inspired the proposal of dendrite P (DeP) systems [53]. DeP systems work in synchronous mode since a global clock is assumed to synchronize all neurons. The motivation of this work is to propose a sequential version of DeP systems, sequential DeP systems (in short, SDeP systems), and to establish computational completeness of SDeP systems. In sequential mode, all rules in each neuron are applied sequentially and all neurons work in sequential way. Max-sequential mode is considered: only the activated neurons with maximum number of spikes can apply their rules. Moreover, two strategies are further discriminated: max-sequentiality strategy (one of neurons with maximum number of spikes fires) and max-pseudo-sequentiality strategy (neurons with maximum number of spikes fire). From an application perspective, SDeP systems have the dynamics different from DeP systems. The contributions of this paper can be summarized as follows:

(1)
We prove that SDeP systems can be used as Turing universal number generating devices in max-sequentiality strategy and max-pseudo-sequentiality strategy respectively.

(2)
We prove that SDeP systems can be used as Turing universal number accepting devices in max-sequentiality strategy and max-pseudo-sequentiality strategy respectively.

(3)
We establish a small universal function computing device of SDeP systems with 91 neurons and working in max-sequentiality mode.

The rest of this paper is organized as follows. Section 2 provides some preliminaries for our results. SDeP systems and an illustrative example are introduced in Section 3. The computation power of SDeP systems as number generating/accepting devices is discussed in Section 4. Section 5 discusses a small universal function computing device for SDeP systems. Finally, the conclusions are drawn in Section 6.

2. Preliminaries
To more easily define that SDeP systems, it is necessary to review some concepts related to SNP system and formal language theory. More details can be found in Refs. [1], [54]. Let Σ be an alphabet. The empty string is denoted by λ, 
⁎
 denotes the set of all finite strings on Σ, and 
 denotes the set of all non-empty strings on Σ. If , then 
⁎
 and 
 can be simply represented by 
⁎
 and 
 respectively. The regular expression on Σ can be recursively defined: (i) λ and  are regular expressions; (ii) if 
 and 
 are two regular expressions on Σ, then 
, 
, and 
 are regular expressions on Σ; (iii) there is nothing else that is regular expression on Σ. Language  can be defined as follows: (i)  and , ; (ii) for any two regular expressions 
, 
, 
, 
 and 
.

A register machine is defined by a tuple 
, where m is the number of registers, H is the set of instruction labels, 
 is the starting label, and 
 is the halting instruction label, and I is the instruction set. Each instruction in I is associated with a label in H. Starting from the instruction with label 
 and all empty registers, the machine continues to apply the instructions distinguished by the labels until it halts; at this time, the number contained in the first register is called the computed result of M. There are three types of instructions:

(1)
 (add 1 to register r, and then go to instruction 
 or instruction 
 non-deterministically);

(2)
 (if the number in register r is greater than 0, decrease 1 from it and then go to instruction 
; otherwise, go directly to instruction 
);

(3)
 (halting instruction).

The register machine 
 can be used to compute the function 
. Initially, k parameters are introduced in k special registers (usually, the first k registers are used), and all registers are assumed to be empty. The register machine starts from instruction 
 and continues to execute the instructions until halting instruction 
 arrives. At this time, the value of function f is a number stored in another special register 
. Let 
 denote the fixed permissible enumeration of unary partially recursive functions. There is a recursive function g such that 
 for all natural numbers .

A small universal register machine for computing functions has been introduced in Korec [55]: 
. The machine 
 has 23 instructions and 8 registers (labeled from 0 to 7). Two numbers  and y are introduced into registers 1 and 2, respectively. The machine 
 can compute any 
. When the register machine halts, the computed value is stored in register 0. An SDeP system will be designed to simulate register machine 
. For simplicity, register machine 
 is modified as 
 by adding a new register 8 and using 
, 
, 
 instead of the original halting instruction, shown in Table 1. Therefore, register machine 
 contains 24 ADD and SUB instructions, 9 registers and 25 labels.


Table 1. Universal register machine 
.

l0:(SUB(1),l1,l2)	l1:(ADD(7),l0)	l2:(ADD(6),l3)
l3:(SUB(5),l2,l4)	l4:(SUB(6),l5,l3)	l5:(ADD(5),l6)
l6:(SUB(7),l7,l8)	l7:(ADD(1),l4)	l8:(SUB(6),l9,l0)
l9:(ADD(6),l10)	l10:(SUB(4),l0,l11)	l11:(SUB(5),l12,l13)
l12:(SUB(5),l14,l14)	l13:(SUB(2),l18,l19)	l14:(SUB(5),l16,l17)
l15:(SUB(3),l18,l20)	l16:(ADD(4),l11)	l17:(ADD(2),l21)
l18:(SUB(4),l0,l22)	l19:(SUB(0),l0,l18)	l20:(ADD(0),l0)
l21:(ADD(3),l18)	l22:(SUB(0),l23,l24)	l23:(ADD(8),l22)
l24:HALT		
3. SDeP systems
In this section, SDeP systems are first defined, and then an example is provided to illustrate the working mechanism in two sequential modes.

3.1. Definition
Definition 1

An SDeP system with degree  is a tuple:
 where

(1)
 is the singleton alphabet, where a is known as the spike;

(2)
 are m neurons and work in sequential mode; neuron 
 has the form 
 where

(a)
 is the initial number of spikes in neuron 
;

(b)
 denotes the finite set of dendrite rules with the form:
 where 
 is a regular expression, 
, , and index 
 indicates the number of prepositive (source) neurons of neuron 
;

(3)
 with  for all ,  (synapse connections);

(4)
in and out indicate the input and output neurons, respectively.

From a topological perspective, an SDeP system can be denoted by a directed graph, where the nodes denote neurons and the arcs indicate synapses. In the directed graph, neuron 
 is called a prepositive (source) neuron of neuron 
 if there is an arc from neuron 
 to neuron 
.

SDeP systems work in sequential mode: all neurons fire in sequential way and the rules in each neuron are applied sequentially. In any time, if some neurons can be applied, then they are called the activated neurons. In this study, max-sequential mode is considered: only the activated neurons with maximum number of spikes can apply their rules. Moreover, if several activated neurons have the maximum number of spikes, then two strategies are further distinguished: max-sequentiality strategy and max-pseudo-sequentiality strategy. The two sequential strategies are defined as follows:

(1)
max-pseudo-sequentiality strategy: all the activated neurons containing maximum number of spikes will be applied.

(2)
max-sequentiality strategy: only one of the activated neurons containing maximum number of spikes will be nondeterministically chosen and applied.

In an SDeP system, dendrite rule has the form 
, where the right part of the arrow “←” indicates the number of spikes consumed in the prepositive (source) neurons. The neuron that the dendrite rule resides is connected to several prepositive (source) neurons through its dendrites. Therefore, each dendrite rule has a set of regular expressions, 
. The dendrite rule can be also written by 
. It is worth noting that the firing condition of dendrite rule corresponds to the numbers of spikes in its prepositive (source) neurons. The firing condition can be expressed by a conjunction 
, where 
 is the number of spikes in the jth prepositive (source) neuron, . It can be observed from the firing condition whether the dendrite rule is applied is independent of the state of the neuron that the rule resides. If the firing condition of the dendrite rule is satisfied, then we say that the neuron is an activated neuron. When the dendrite rule is applied, 
 spikes in the jth prepositive (source) neuron is consumed (
 spikes is retained), and p spikes are generated and stored in the neuron that the rule resides. In the dendrite rule, if 
 (or ), then 
 (or 
) can be written by λ. In particular, when , we say the rule is a forgetting rule.

For any neuron, two dendrite rules, such as 
 and 
, may satisfy their firing conditions simultaneously: 
 and 
. In this case, one of the rules is nondeterministically chosen and applied.

The main differences between dendrite rules in SDeP systems and spiking rules in SNP systems can be summarized as follows:

(1)
The firing of dendrite rule can be viewed as a retrieving-storing process: it retrieves the spikes from its prepositive (source) neurons, and then generates p spikes and stored them in the neuron that the rule resides.

(2)
The firing of usual spiking rule can be viewed as a firing-sending process: c spikes in the neuron that the rule resides are consumed and p spikes are generated, and then the p spikes are sent to its all subsequent neurons.

(3)
The dendrite rule has a cooperative firing mechanism: all prepositive (source) neurons simultaneously satisfy their firing conditions: 
, the rule can be applied. If some prepositive (source) neurons satisfy their firing conditions but other neurons do not satisfy the firing conditions, then the dendrite rule will wait for the other neurons to satisfy the conditions and then it is applied. However, usual spiking rule lacks the cooperative firing mechanism.

The configuration of the system at time t is characterized by the number of spikes stored in each neuron. A computation is any sequence of transitions starting from the initial configuration. The computation halts if a configuration for which no rule can be applied is reached. The output of an SDeP system is a spike train exported by the output neuron. However, each neuron in an SDeP system only stores the received spikes and does not send out spikes in a forward direction. To facilitate the discussion of universality, we assume that the spike train in an SDeP system is received by the output neuron instead of the environment. Thus the number of spikes received by the output neuron is regarded as the computation result.

An DeP system Π can work in generating mode. Initially, 2n spikes are placed in neuron 
, and Π begins to work until it halts. When it halts, the number of spikes received by the output neuron is regarded as the computation result. When an SDeP system Π works in generating mode, the input neuron will be omitted, and the set of all numbers generated by Π is denoted by 
.

An DeP system Π can also work in accepting mode. Initially, a spike train that codes number n is introduced from the environment through neuron 
. Then system Π begins to work until it halts. When it halts, we say that the number n is accepted by Π. When an SDeP system Π works in accepting mode, the output neuron is deleted, and the set of all numbers accepted by Π is denoted by 
.

Let 
 denote the sets of all numbers generated or accepted by SDeP systems with at most m neurons and at most n rules in each neuron, where  (indicating that the systems work in geneting mode or accepting mode, and  (indicating that the systems use max-sequential strategy or max-pseudo-sequence strategy respectively). Note that if not restricted, the symbol “*” can be used instead of m or n.

3.2. An example
An SDeP system working in max-sequentiality strategy or max-pseudo-sequentiality strategy is shown in Fig. 1. Initially, there are four spikes and two spikes stored in neurons 
 and 
, respectively. Thus, the initial configuration is 
. At this time, no dendrite rules in neuron 
 can be applied. But, rule 
 in neuron 
 can be applied, so two spikes are consumed in neuron 
 and a spike in neuron 
 is removed, and a spike is generated and stored in neuron 
 by the dendrite rule. Thus, 
. Note that neurons 
 and 
 have two and a spike, respectively.

(i)
If the system works in max-sequentiality strategy, then rule 
 
 in neuron 
 and rule 
 in neuron 
 can be applied, and one of them will be chosen non-deterministically and applied. There are two cases:

(a)
When rule 
 in neuron 
 is applied, a spike in neuron 
 is consumed and a spike is generated and stored in neuron 
. Thus, 
. Because no rule can be applied, the system halts.

(b)
When rule 
 in neuron 
 is applied, two spikes in neuron 
 are consumed and two spikes are generated and stored in neuron 
. Thus, 
. And then, rule 
 in neuron 
 is applied, so two spikes in neuron 
 are consumed and a spike is generated and stored in neuron 
. Thus, 
 and the system halts.

(ii)
If the system works in max-pseudo-sequentiality strategy, then rule 
 
 in neuron 
 and rule 
 in neuron 
 can be applied simultaneously. As a result, two spikes in neuron 
 are consumed by dendrite rule in neuron 
 and two spikes are generated and stored in neuron 
, and a spike in neuron 
 is removed by dendrite rule in neuron 
 and a spike is generated and stored in neuron 
. Thus, 
 and the system halts.

Fig. 1
Download : Download high-res image (24KB)
Download : Download full-size image
Fig. 1. An SDeP system.

The simple example indicates that SDeP systems have the different dynamic behaviors, respectively, in max-sequentiality and max-pseudo-sequentiality strategies. Moreover, SDeP systems have the dynamic behavior different from synchronous DeP systems. In addition, SDeP systems have a cooperative control mechanism, however, the existing variants of SNP systems lack this mechanism.

4. Computational power of SDeP systems
In this section, we will prove Turing universalities of SDeP systems working in max-sequentiality strategy and max-pseudo-sequentiality strategy as number generating and accepting devices. If an SDeP system works in generating mode, in order to facilitate the discussion of universality, it is assumed that a spike train is received by the output neuron instead of the environment. Therefore, the number of spikes received by the output neuron is regarded as the computed result. If an SDeP system works in accepting mode, the input neuron reads a spike train 
 (the time interval of spikes is ) from the environment, indicating that number n is introduced into a specified neuron in the form of 2n spikes. It is said that the system accepts number n when the computation halts. We will construct four SDeP systems working respectively in max-sequentiality strategy and max-pseudo-sequentiality strategy to prove that they can generate and accept any set of recursively enumerable numbers (denoted by NRE).

4.1. Working in max-sequentiality strategy
Theorem 1

⁎

Proof

Since its reverse conclusion is obvious, it is only necessary to prove 
⁎
. It is well known that 
 can characterize NRE in generating mode. Generally, it is assumed that all registers different from register 1 are empty, and the value in register 1 will never decrease during the computation. We construct an SDeP system 
 working in max-sequentiality strategy to simulate register machine 
. The system 
 has three modules: (1) ADD module shown in Fig. 2, simulating ADD instructions of 
, (2) SUB module shown in Fig. 3 simulating SUB instructions of 
, and (3) FIN module shown in Fig. 4, outputting the computed result of the system.

Fig. 2
Download : Download high-res image (22KB)
Download : Download full-size image
Fig. 2. ADD module working in max-sequentiality strategy and generating mode.

Fig. 3
Download : Download high-res image (38KB)
Download : Download full-size image
Fig. 3. SUB module working in max-sequentiality strategy and generating mode or working in max-sequentiality strategy and accepting mode or working in max-pseudo-sequentiality strategy and generating mode or working in max-pseudo-sequentiality strategy and accepting mode.

Fig. 4
Download : Download high-res image (15KB)
Download : Download full-size image
Fig. 4. FIN module working in max-sequentiality strategy and generating mode.

Suppose that each register r in 
 corresponds to a neuron 
 in 
. In addition, number n in register r is encoded as follows: if number  is contained in register r, then neuron 
 has 2n spikes. Neuron 
 is associated with an instruction l in H, and some auxiliary neurons are considered in the modules. Initially, each auxiliary neuron has no spike, and only neuron 
 receives three spikes.

When neuron 
 receives three spikes, system 
 starts to simulate instruction 
 (OP is one of ADD or SUB). Starting from the activated 
, the simulation will process neuron 
 based on the OP, and then one of neurons 
 or 
 will receive three spikes. Once neuron 
 receives three spikes, the system completes simulating register machine 
. In the simulation, output neuron 
 applies its dendrite rule to receive a series of spikes, and the computed result is the number of spikes received, that is, the number in register 1.

To prove that 
 can be simulated correctly by 
, it is explained in detail how ADD and SUB modules simulate ADD and SUB instructions respectively and how FIN module outputs the computed result.

(1) ADD module - simulating instruction 

Fig. 2 shows ADD module, which is used to simulate instruction 
. Suppose that an ADD instruction 
 is simulated at time t. Thus, neuron 
 applies rule 
 to generate three spikes. At time , rule 
 in neuron 
 is applied, so neuron 
 receives two spikes. At this time, neurons 
 and 
 contain a spike and two spikes, respectively. At time , rule 
 in neuron 
 is applied to consume a spike in neurons 
 and 
 respectively, and two spikes are received. This means that the number in neuron 
 is increases by 1. At time , since neuron 
 has only one spike, rule 
 in neurons 
 and 
 can be applied. So one of them is non-deterministically chosen. Therefore, there are the following two cases:

(i)
At time , if rule 
 in neuron 
 is applied, it will receive three spikes, indicating that system 
 starts to simulate instruction 
.

(ii)
At time , if rule 
 in neuron 
 is applied, it will receive three spikes, indicating that system 
 starts to simulate instruction 
.

Hence, the ADD module correctly simulates ADD instruction.

(2) SUB module - simulating instruction 

Fig. 3 shows SUB module, which is used to simulate SUB instruction of 
. Assume that a SUB instruction 
 is simulated at time t. Thus, rule 
 in neuron 
 is applied, and three spikes are generated. At time , neuron 
 applies rule 
 to receive a spike. At time , neuron 
 has two spikes, so neuron 
 applies rule 
 to receive three spikes. At this time, neuron 
 receives three spikes and neuron 
 receives a spike. According to the number of spikes contained in neuron 
, the following two cases are considered:

(i)
At time , if neuron 
 has  () spikes (at this time, register r stores number n), then rule 
 in neuron 
 can be applied, but rule 
 in neuron 
 cannot be applied. So five spikes in neuron 
 are consumed, a spike in neuron 
 is removed, and at the same time neuron 
 receives a spike. At time , neuron 
 receives three spikes by using rule 
, indicating that system 
 starts to simulate instruction 
.

(ii)
At time , if neuron 
 has only three spikes (at this time, register r does not store any number), then rule 
 in neuron 
 can be applied, but rule 
 in 
 cannot be applied. Therefore, the number of spikes in neuron 
 becomes 0, while the neuron 
 receives a spike. At time , neuron 
 receives three spikes by using rule 
, indicating that system 
 starts to simulate instruction 
.

Neurons in other modules connected to neuron 
 may be applied. Therefore, if rule 
 in neuron 
 is applied, but neuron 
 in SUB module can not fire (so, rules in neuron 
 are not applied because neuron 
 has no spike), then rule 
 in neuron 
 can not be applied to consume three extra spikes in neuron 
.

Therefore, the SUB module correctly simulates SUB instruction: the system starts from neuron 
 receiving three spikes, and then neuron 
 receives three spikes (if register r contains a number greater than zero) or neuron 
 receives three spikes (if register r has no number).

(3) FIN module, outputting the computed result

Fig. 4 gives FIN module, which is used to export the computed result. Suppose that at time t, neuron 
 applies rule 
 to receive three spikes, indicating that the register machine halts (i.e., the halting instruction 
 arrives), and neuron 
 has 2n spikes (i.e., the number stored in register 1 is n). Since neuron 
 has three spikes, rule 
 in neuron 
 is applied at time  to receive a spike. At this time, the spikes in neuron 
 become odd. At time , rule 
 in neuron 
 is applied to receive a spike. At this time, two spikes are consumed in neuron 
 (meaning that the number in register 1 is decreased by 1). Repeat this step, and at each step neuron 
 will receive a spike until neuron 
 has only one spike. At time , because there is only one spike in neuron 
, neuron 
 applies rule , so a spike in neuron 
 is consumed. Therefore, if n = 0, then at time  neuron 
 applies forgetting rule; if , then from time  to time , neuron 
 receives a total of n spikes, where n indicates the number in register 1 when the computation halts.

From the discussion above, system 
 correctly simulates register machine 
 working in generating mode, where each neuron contains two rules at most. Therefore, the theorem holds. □

Theorem 2

⁎

Proof

The proof of this theorem is similar to Theorem 1, but only a deterministic register machine 
 in accepting mode is considered. To this end, an SDeP system 
 working in max-sequentiality strategy is designed for the simulation of 
, which contains an INPUT module shown in Fig. 5, a deterministic ADD module shown in Fig. 6, and a SUB module that is the same as SUB module in generating mode in Fig. 3.

Fig. 5
Download : Download high-res image (44KB)
Download : Download full-size image
Fig. 5. INPUT module working in max-sequentiality strategy and accepting mode or working in max-pseudo-sequentiality strategy and accepting mode.

Fig. 6
Download : Download high-res image (19KB)
Download : Download full-size image
Fig. 6. ADD module working in max-sequentiality strategy and accepting mode or working in max-pseudo-sequentiality strategy and accepting mode.

The INPUT module is shown in Fig. 5. A spike train 
 is imported from the environment through neuron 
 (neuron 
 reads the spike train 
 from the environment), where number “3” indicates three spikes to be received. After reading the spike train, neuron 
 will receive 2n spikes, which means that the register machine has received number n.

Suppose that at time t, neuron 
 receives the first “3” spikes by applying rule 
 from the environment. At this time, neuron 
 has two spikes, and neuron 
 has no spike. At time , dendrite rule 
 in neuron 
 is applied. At this time, neuron 
 generates four spikes, and neuron 
 consumes a spike and remain a spike. At time , rule 
 in neuron 
 satisfies the firing condition, so rule 
 is applied to consume three spikes in neuron 
 and two spikes are received, which means that the value in neuron 
 is increased by 1. At time , neurons 
 and 
 each have a spike, so rule 
 in neuron 
 is applied to consume a spike in neuron 
 and generate four spikes. At time , neurons 
 and 
 have zero and four spikes respectively, so neuron 
 applies rule 
 to consume three spikes in neuron 
 and receives two spikes, and neuron 
 receives two spikes, hence the value in neuron 
 is increased by 1. At time , neurons 
 and 
 each have a spike, so rule 
 in neuron 
 is applied to consume a spike in neuron 
 and generate four spikes. From time  to time , the above process is repeated, and then in every two steps, two spikes will be received by neuron 
. According to whether number n inputted by the system is odd and even, there are the following two cases:

(i)
If n is an even number, then at time , when the last “3” spikes in the input spike train arrives, neuron 
 needs three spikes to fire, but neuron 
 needs four spikes. And at this time, neuron 
 and neuron 
 are both firable neurons, and due to max-sequentiality strategy, rule 
 in neuron 
 is applied. Therefore, neuron 
 receives a total of 2n spikes from time  to time , indicating that the number stored in register 1 is n. At time , the rules in neuron 
 can be applied, but neuron 
 and neuron 
 needs two spikes and three spikes to fire, respectively. Obviously neurons 
 and 
 are all firable neurons. Because of max-sequentiality strategy, neuron 
 applies rule 
 to receive the last “3” spikes from the environment. At time , neurons 
, 
 and 
 have three spikes, a spike and no spike, respectively. The dendrite rule 
 in neuron 
 is applied to remove the spikes in neurons 
 and 
 and generate a spike. At time , neuron 
 applies rule 
 to generate three spikes, hence, system 
 starts to simulate instruction 
.

(ii)
If n is an odd number, then at time , rule 
 in neuron 
 is applied to receive two spikes due to max-sequentiality strategy. Therefore, neuron 
 receives a total of 2n spikes from time  to time , indicating that the number stored in register 1 is n. At time , rule 
 in neuron 
 can be applied. The rule needs 2 spikes to be executed, and neuron 
 needs 3 spikes to fire. Because of max-sequentiality strategy, neuron 
 applies rule 
 to receive the last “3” spikes from the environment. At time , neurons 
, 
 and 
 have three spikes, no spike and a spike, respectively. The dendrite rule 
 in neuron 
 is applied to remove the spikes in neurons 
 and 
 and generate a spike. At time , rule 
 in neuron 
 is applied to generate three spikes, hence, system 
 starts to simulate instruction 
.

When a register machine is used in accepting mode, its ADD instructions are deterministic. Fig. 6 shows ADD module that is used to simulate the deterministic ADD instruction 
. Suppose that at time t, neuron 
 receives three spikes by using rule 
. Therefore, at time , rule 
 in neuron 
 is applied to receive two spikes. At this time, neuron 
 has a spike. At time , neurons 
 and 
 contain a spike and two spikes, respectively. The firing condition of neuron 
 is satisfied, so rule 
 is applied to consume a spike in neurons 
 and 
 respectively, and two spikes are received, which means that the value in register r is increased by 1. At time , neuron 
 applies rule 
 to receive three spikes, so system 
 starts to simulate instruction 
.

We use the SUB module shown in Fig. 3 to simulate the SUB instruction 
. The FIN module is removed, but neuron 
 remains in the system. Once neuron 
 receives three spikes, the computation will halt, indicating that system 
 starts to simulate instruction 
.

It can be found from the above description that when each neuron contains at most two rules, SDeP system 
 correctly simulates register machine 
 in accepting mode. The theorem holds. □

4.2. Working in max-pseudo-sequentiality strategy
In the following, we discuss Turing universality of SDeP systems working in max-pseudo-sequentiality strategy as number generating and accepting devices respectively.

Theorem 3

⁎

Proof

The proof of this theorem is similar to Theorem 1, we only prove 
⁎
. We construct an SDeP system 
 working in max-pseudo-sequentiality strategy to simulate register machine 
 in generating mode. The system contains an ADD module shown in Fig. 7, a SUB module shown in Fig. 3, and a FIN module shown in Fig. 4. It can be observed from the proof of Theorem 1 that, FIN module and SUB module have only one neuron that is active and has the maximum number of spikes at each step during the computation. This means that SUB and FIN modules can also work in max-pseudo-sequentiality strategy. Therefore, we only describe how ADD module simulates ADD instruction.

Fig. 7
Download : Download high-res image (36KB)
Download : Download full-size image
Fig. 7. ADD module working in max-pseudo-sequentiality strategy and generating mode.

(1) ADD module - simulating instruction 

Fig. 7 shows ADD module, which is used to simulate instruction 
. Suppose that at time t, an ADD instruction 
 is simulated, meaning that neuron 
 applies rule 
 to receive three spikes. At time , neuron 
 has three spikes, so two rules in neuron 
 can be applied according to max-pseudo-sequentiality strategy. Since the rules require the same spikes in neuron 
, one of them is chosen non-deterministically. Two cases are considered as follows:

(i)
At time , if rule 
 is applied, then neuron 
 will receive two spikes. At time , neurons 
 and 
 have a spike and two spikes respectively, satisfying the firing conditions of the first rule in neuron 
 and neuron 
. Because of max-pseudo-sequentiality strategy, rule 
 in neuron 
 is applied to consume two spikes in neuron 
 and generate two spikes, while rule 
 cannot be applied, which means that the number in neuron 
 is increased by 1. At the same time, dendrite rule 
 in neuron 
 is applied to consume a spike in neuron 
 and generate a spike, but forgetting rule 
 in neuron 
 cannot be applied. At time , neuron 
 has only one spike, so neuron 
 applies rule 
 to receive three spikes, hence, system 
 starts to simulate instruction 
.

(ii)
At time , if rule 
 is applied, then neuron 
 will receive a spike. At this time, neurons 
 and 
 have two spikes and one spike, respectively. At time , firing conditions of the second dendrite rule in neurons 
 and 
 are the same and are met. Due to max-pseudo-sequentiality strategy, rule 
 in neuron 
 is applied to consume a spike in neuron 
 and generate two spikes, which means that the number in neuron 
 is increased by 1. At the same time, forgetting rule 
 in neuron 
 is applied to consume a spike in neuron 
. At time , neuron 
 has a spike, so only neuron 
 can apply rule 
 to receive three spikes, thus, system 
 begins to simulate instruction 
.

Hence, the ADD instruction is correctly simulated by ADD module. □
Theorem 4

⁎

Proof

We construct an SDeP system working in max-pseudo-sequentiality strategy to simulate a deterministic register machine 
 in accepting mode. The system contains an INPUT module shown in Fig. 5, a deterministic ADD module shown in Fig. 6, and a SUB module shown in Fig. 3. From the proof in Theorem 2, it can be found that in INPUT module of Fig. 5 and ADD module of Fig. 6, only one neuron is active and has the maximum number of spikes, therefore, the two modules can be also used in max-pseudo-sequentiality strategy. Moreover, it has been proven in Theorem 3 that SUB module in Fig. 3 can also work in max-pseudo-sequentiality strategy. Therefore, the theorem holds. □

5. Small universal SDeP systems for computing functions
In this section, we will construct a small universal SDeP system working in max-sequentiality strategy for computing functions.

Theorem 5

There is a universal SDeP system working in max-sequentiality strategy and having 91 neurons for computing function.

Proof

We can construct an SDeP system 
 working in max-sequentiality strategy to simulate small universal register machine 
. The system 
 contains an INPUT module, shown in Fig. 8, an ADD module, shown in Fig. 6, a SUB module, shown in Fig. 3, and an OUTPUT module, shown in Fig. 9. The ADD and SUB modules simulate ADD and SUB instructions, respectively, of register machine 
. The INPUT module is used to read the spike train from the environment, and the OUTPUT module exports the computed result.

Fig. 8
Download : Download high-res image (85KB)
Download : Download full-size image
Fig. 8. INPUT module working in max-sequentiality strategy.

Fig. 9
Download : Download high-res image (13KB)
Download : Download full-size image
Fig. 9. OUTPUT module working in max-sequentiality strategy.

When designing SDeP system 
, each register r in 
 is associated with a neuron 
. If  is stored in register r, then 2n spikes are contained in neuron 
. In addition, each instruction 
 in 
 corresponds to a neuron 
 in 
. If neuron 
 receives three spikes, then it will start to simulate instruction 
. If neuron 
 contains the spikes, then system 
 will complete the computation of 
, and the number of spikes received by output neuron 
 is regarded as the computed result of 
 (in register 8). Assume that all auxiliary neurons in the initial configuration are empty.

The INPUT module is shown in Fig. 8. The input spike train is encoded as 
, where number “5” indicates that five spikes are imported. Therefore, this means that the system will generate  spikes in neuron 
 and 2y spikes in neuron 
.

Suppose that at time t, neuron 
 receives the first group of “5” spikes from the environment by using rule 
.

At time , rule 
 in neuron 
 is applied to consume a spike in neuron 
 and generate four spikes. At time , neurons 
 and 
 have four spikes and no spike respectively. At this time, dendrite rule 
 in neuron 
 is applied to consume two spikes in neuron 
 and generate two spikes. At time , there are two spikes in neuron 
 and neuron 
 respectively, which satisfy the firing condition of dendrite rule 
 in neuron 
, so it is applied to consume two spikes in neuron 
, but two spikes in neuron 
 are not consumed, and four spikes are generated. At time , neurons 
 and 
 have no spike and four spikes respectively, which satisfy the firing condition of dendrite rule 
 in neuron 
, so rule 
 in neuron 
 is applied to consume neurons two spikes in 
 and generate two spikes. At time , there are two spikes in neuron 
 and neuron 
 respectively, which satisfy the firing condition of dendrite rule 
 in neuron 
, so it is applied to consume two spikes in neuron 
, but two spikes in neuron 
 are not consumed, and four spikes are generated. Repeat the above process until time , and at every time the rule in neuron 
 is applied to generate two spikes. Thus, neuron 
 will receive  spikes, indicating that the number stored in register 1 is .

At time , the second group of “5” spikes reaches in neuron 
. At this time, neurons 
, 
 (if  is odd) or 
 (if  is even) are all active neurons. And five spikes are required to fire neuron 
, and four spikes are required to excite rule 
 in neuron 
 or neuron 
. Due to max-sequentiality strategy, the rule in neuron 
 is applied first to receive three spikes. At time , neuron 
 (when  is odd) or neuron 
 (when  is even) still retains two spikes. And neuron 
 has five spikes, which meets the firing condition of dendrite rule 
 in neuron 
, so this rule is applied to consume four spikes in neuron 
 and generate four spikes. At time , rule 
 in neuron 
 is applied to consume a spike in neuron 
 and generate two spikes. At time , neurons 
 and 
 have one spike and three spikes respectively, so rule 
 in neuron 
 is applied to consume the remaining three spikes in neuron 
 and retain a spike in neuron 
, and four spikes are generated. At time , the second rule 
 in neuron 
 is applied to consume a spike in neuron 
 and generate two spikes. At time , neurons 
 and 
 have a spike and three spikes respectively, so rule 
 in neuron 
 is applied to generate four spikes. Repeating the above steps, neuron 
 will receive two spikes every time after the rule is applied. Thus, neuron 
 will receive 2y spikes until at time , indicating that the number stored in register 2 is y.

At time , the last group of “5” spikes reaches in neuron 
. At this time, rule 
 in neurons 
, 
 and 
 are all in the firing state, but the rules of neuron 
 or 
 need a total of four spikes for executing, so the rule in neuron 
 is applied because it takes a total of five spikes.

Therefore, according to max-sequentiality strategy, neuron 
 first applies the rule to receive three spikes, and at this time neuron 
 has four spikes. According to whether the input y is odd, even or 0, the following three cases are considered:

(i)
If y is an odd number, then at time , neuron 
 has three spikes. Then at , neurons 
 and 
 have four spikes and three spikes respectively, so dendrite rule 
 in neuron 
 is applied. Three spikes in neurons 
 and 
 are consumed respectively.

(ii)
If y is an even number, then at time , neuron 
 has three spikes. Then at time , neurons 
 and 
 have four spikes and three spikes respectively, so dendrite rule 
 in neuron 
 is applied to consume three spikes in neurons 
 and 
 respectively.

(iii)
If y is zero, then at time , the last group of “5” spikes reaches in neuron 
, thus, rule 
 in neuron 
 can be applied again, and rule 
 in neuron 
 is also in a excited state. Since at time , the firing of neurons 
 and 
 requires the same number of spikes, so one of neurons 
 and 
 are chosen non-deterministically. The following two cases are considered:

(a)
At time , when rule 
 in neuron 
 is applied to generate four spikes. At time , due to the max-sequentiality strategy, the rule in neuron 
 can be applied. At time , neurons 
 and 
 contain four spikes respectively, so forgetting rule 
 in neuron 
 is applied.

(b)
At time , when rule 
 in neuron 
 is applied to generate three spikes. Then at time , neuron 
 has eight spikes, and forgetting rule 
 in neuron 
 is applied.

At time , neuron 
 still retains the last spike, and neurons 
 or 
 also retains two spikes. Based on  being odd or even, there are the following two cases:

(i)
If  is an odd number, then at time , neuron 
 has more than two spikes, and neuron 
 has no spike. Therefore, at time , rule 
 in neuron 
 is applied to remove the remaining spikes in neurons 
 and 
, and it generates a spike.

(ii)
If  is an even number, then at , neuron 
 has more than two spikes, and neuron 
 has no spike. Therefore, at time , rule 
 in neuron 
 is applied to remove the remaining spikes in neurons 
 and 
, and it generates a spike.

At time , neuron 
 applies rule 
 to receive three spikes, hence, system 
 starts to simulate instruction 
 of 
.

When  is equal to 0, rule 
 in neuron 
 is applied twice continuously at time t and . At time , neuron 
 has six spikes, and neurons 
 and 
 have no spike. At this time, rule 
 in neuron 
 is applied to consume five spikes in neuron 
 and generate four spikes. When y is greater than 0, neuron 
 will continue to perform the operation at time . When y is equal to 0, at time , rule 
 in neurons 
 and 
 are both in the excited state. Because of max-sequentiality strategy, the rule in neuron 
 is executed first. At time , neurons 
 and 
 each have four spikes, so rule 
 is applied to consume three spikes in neuron 
 and four spikes in neuron 
. At time , neuron 
 has only one spike, so rule  in neuron 
 is applied to generate a spike. At time , neuron 
 applies rule 
 to generate three spikes, thus, system 
 starts to simulate instruction 
 of 
.

It can be found from Table 1 that the format of all ADD instructions is 
. Therefore, each ADD instruction can be simulated by the deterministic ADD module in Fig. 6, and all SUB instructions 
 can be simulated by the SUB module in Fig. 3. Now suppose that register machine 
 halts, that is, halting instruction 
 arrives. The register 8 stores the computed result, which will not decrease during the computation. The computed result will be exported by the OUTPUT module, shown in Fig. 9.

Now suppose that at time t neuron 
 receives three spikes by using rule 
, indicating that 
 halts (that is, the halting instruction 
 is reached), and neuron 
 has 2n spikes (i.e., numbers n is contained in register 8). At time , since neuron 
 has three spikes, rule 
 in neuron 
 is applied to receive a spike, and the spike number in neuron 
 becomes odd. At time , rule 
 in neuron 
 is applied to receive one spike, at this time two spikes in neuron 
 are consumed. Repeat this step until only one spike is left in neuron 
. At time , forgetting rule in neuron 
 is applied to consume the last spike. Therefore, if , then at time , neuron 
 applies forgetting rule; if , then from time  to time , neuron 
 receives a total of n spikes, where n indicates the number in register 8 when system 
 halts.

According to the above discussion, register machine 
 is correctly simulated by SDeP system 
. In SDeP system 
, a total of 91 neurons are used: (i) 9 neurons with 9 registers; (ii) 25 neurons with 25 instructions; (iii) 10 neurons for 10 ADD instructions; (iv) 42 neurons in 14 SUB instructions; (v) 5 neurons in the input module. □

6. Conclusions
This paper proposed dendrite P systems in sequential mode, sequential Dep systems (in short, SDeP systems). Based on the number of spikes in active neurons, max-sequential mode is considered, and two sequential strategies are distinguished, including max-sequentiality and max-pseudo-sequentiality. We discussed computational power of SDeP systems in two sequentiality modes as number generating device and number accepting device, respectively. We proved that SDeP systems in max-sequentiality and max-pseudo-sequentiality are Turing universal number generating device and number accepting device (Theorem 1 - Theorem 4). Finally, We construct a small universal function computing device of SDeP systems with 91 neurons working in max-sequentiality mode.

From an application point of view, SDeP systems are a sequential computing model. The sequential model has the dynamic behaviors different from its synchronization version, DeP systems. Moreover, SDeP systems have two recognizable features: (1) cooperative firing of dendrite rule; (2) the state of the neuron that dendrite rule resides depends on the states of its prepositive neurons and is not related to its own state. The sequential working mode and two recognizable features above are potentially suitable to some real-life problems, for example, some discrete control problems. The discrete control problems often need the mechanisms: (i) the sequential working mode of components instead of maximum parallelism, and (ii) cooperative working mechanism. Our future work will focus on how to apply SDeP systems to these real-life applications, for example, supervisory control problems in discrete event systems and modeling and simulation of flexible manufacturing systems.