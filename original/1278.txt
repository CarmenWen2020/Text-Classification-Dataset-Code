Abstract
The graph search problem is the problem of searching for a mobile evader in a dark cave by a group of mobile searchers, where the cave is modeled by an undirected connected graph G. An offline and centralized version of the graph search problem is formalized as a pebble game on G, and has been extensively investigated under the name of the edge search problem. By  we denote the number of pebbles (i.e., searchers) necessary and sufficient to edge search G.

An online and distributed version of the graph search problem is the graph search by mobile agents. We investigate the graph search problem under a weaker online and distributed setting called the dark cave model, which models the dark cave more directly than a graph; G is completely anonymous, and we do not introduce any artificial facilities in G such as a port numbering, a homebase, and a whiteboard. Instead, we assume that the searchers can exchange information wherever they meet. Under the dark cave model, we propose a search algorithm OLSEARCH for  searchers, and show that it is optimal in terms of the number of searchers.

Keywords
Anonymous graph
Asynchronous searcher
Dark cave model
Graph search problem
Pursuit and evasion in graph

1. Introduction
Parsons' Dark Cave Search Problem Parsons [1] addressed the problem of finding an evader in a dark cave by a group of searchers. When the topology of the cave is represented by a finite undirected connected graph , he modeled the cave by a straight line representation  of G in 
, i.e., an embedding of G in 
 such that every edge in E is embedded as a line segment without any crossing. Then a schedule for a searcher 
 is a continuous function 
 from  to , where 
 denotes the position of 
 at time t. A set 
 is said to be a search schedule on  for k searchers, if for any continuous function ε from  to , which represents the move of the evader, there are a searcher 
 and a time instant t such that 
. The minimum k sufficient to construct a search schedule F on  for k searchers is the search number. This is an offline and centralized setting: We design a search schedule F knowing the whole , and the k searchers synchronously execute F, i.e. they are simultaneously at positions 
 at time t.

Graph Search as a Pebble Game The edge search game, which is a discrete version of the Parsons' dark cave search problem under the offline and centralized setting, is formulated as a form of pebble game, in which the main goal is to simultaneously clear all edges of a given graph , where an edge is said to be clear if the evader cannot be hidden in the edge. Initially all edges are contaminated (i.e., not clear). The player can (1) place a pebble at a node, (2) remove a pebble from a node, or (3) slide a pebble along the edge from a node to another. We can clear an edge  by placing two pebbles at u, and then sliding one pebble to v along e. A clear edge  remains clear as long as every path 
 connecting e and a contaminated edge 
 contains a pebble. On the contrary, a clear edge  is recontaminated as soon as a path 
 connecting e and a contaminated edge 
 that contains no pebbles emerges. When all edges incident on u except an edge  are clear and there is a pebble at u, we can thus clear e and expand the set of clear edges by sliding the pebble from u to v along e, regardless of whether or not there is a second pebble at u. The minimum number of pebbles sufficient to clear the whole E, denoted by , is called the edge search number of G.

The player operates exactly one pebble at a time in the edge search game, while more than one searcher (i.e., pebble) can simultaneously move under the Parsons' model. Nevertheless, as was pointed out by Parsons,  is equivalent to the search number of , for any straight line representation  of G.

We say that a search is monotone if no edges are recontaminated during the search. LaPaugh [2] showed that recontamination does not help in the edge search game. Thus there is a monotone search schedule on G for k pebbles, if there is a search schedule on G for k pebbles.

Since the total number of times that a monotone search clears edges is , the problem of deciding if  is in NP, and it is indeed an NP-complete problem [3]. Let 
. If 
 and H is a minor of G, then 
. That is, 
 is minor-closed. Then by the Graph Minor theorem, (1) there is a finite set 
 of minor-minimal graphs for 
 such that 
 if and only if G does not contain a graph M in 
 as a minor, and (2) determining whether or not M is a minor of G is solvable in polynomial time for a fixed graph M. Thus the problem of determining  is fixed parameter tractable [4], [5].

Graph Search under Mobile Agent Model The above two problems examine offline and centralized graph search. In distributed computing, some problems such as the termination detection and the orphaned process problems require to search the whole network to decide if there remains a harmful process. They are regarded as instances of online and distributed graph search. The mobile agent model is best fit under which this version of graph search is formalized. Consider a set of autonomous and asynchronous mobile agents (i.e., searchers) in a graph . Searchers have distinct identifiers, but the graph is anonymous and the nodes are not labeled, except the homebase 
 from which the searchers start searching.1 For the searchers to specify to which edge they proceed, each edge incident to any node  is labeled by a distinct integer in , where  is the degree of u. These labels are called port numbers. Each node has a local memory called whiteboard, in which the searchers can read, erase and write symbols in a mutually exclusive manner. There are no other communication tools. The searchers execute the same search algorithm and are asked to clear a given graph G, (typically) using very limited a priori knowledge of G. Note however that the mobile agent models proposed in [6], [7], [8], [9] are slightly different from each other.

The papers which investigate this graph search problem by mobile agents typically respect the monotone and connected search strategy, since it ensures secure communication between searchers – the evader cannot access to a whiteboard to compromise information. Here a search is said to be connected if the set of clear edges always induces a connected subgraph of G. Let 
 be the minimum number k of searchers sufficient to edge search G from 
 in a monotone and connected way under the offline and centralized setting. By definition 
 holds. The algorithm in [6] enables 
 searchers to clear G in a connected way, which however may not be monotone. Ilcinkas et al. [9] proposed a monotone and connected search algorithm that requires 
 
 searchers to search any graph G of order n from any node 
, and showed its optimality in terms of the number of searchers, provided the monotone and connected search. See also [10], [7], [8] for other search algorithms, which assume some a priori information about G, based on the monotone and connected graph search.

Graph Search under Dark Cave Model We introduce a weaker online and distributed model that directly models the Parsons's original motivation of searching an evader in a dark cave. We call it the dark cave model. Roughly, under this model, the cave is not equipped with any artificial facilities such as a homebase, whiteboards or port numbers, and communication is possible only when searchers meet:

1.
Similar to several mobile agent models, we consider a set of autonomous and asynchronous searchers having unique identifiers.

2.
The graph does not have any distinguished nodes, i.e., the nodes are completely anonymous. In particular, agents do not have the homebase from which all searchers start searching. The searchers start from arbitrary nodes, and they cannot mark these nodes as their homebases.

3.
We imagine that a node is a round room with doors (i.e., ports) aligned on the wall, each of which is “open” to one of the edges incident to the node. The doors are anonymous and indistinguishable. In particular, they do not have port numbers. Instead, we assume that each searcher in a room can select a door, can specify the door from which it enters the room as long as it stays in the room, and has the common sense of clockwise direction so that it can specify the h-th door clockwise from the door from which it entered the room. Note that the graph is dark; a searcher cannot perceive through which door another searcher arrives or leaves the node.

4.
Each node does not have a local memory. In particular, it does not have a whiteboard to support communication between searchers. Instead, each searcher has a local memory of sufficient size, and searchers exchange information with an identifier tag wherever they meet, even in an edge, which implies that a searcher is always aware of the identifier and the contents of local memory of each of the searchers occupying the same place.

Our Contribution Let  be the number of searchers necessary and sufficient to search G under the dark cave model. We show the following theorem.
Theorem 1

For any graph G, .

To show  in Proposition 1, given a search schedule of G for  searchers under the dark cave model, we present an algorithm to construct an edge search schedule on G for  pebbles. To show  in Section 4, on the other hand, we present a search algorithm OLSEARCH for  searchers. OLSEARCH does not require any global information on G like an upper bound Ξ on the order n of G as initial information; nevertheless, it is optimal in terms of the number of searchers.

Related Works There is huge volume of literature on graph search and related topics. Since we will touch only a few of closely related theoretical works, see e.g., surveys [11], [12] for other directions of research.

The node search game is a variant of the edge search game. In the node search game, in which the main goal is the same as the edge search game, the player cannot execute the sliding operation of the edge search game, and an edge e is declared clear if both of its endpoints are occupied by pebbles. The minimum number of pebbles to clear the whole graph G is called the node search number and is denoted by  [13]. Then  for some G, and  for any G. Another variant is the mixed search game [14], in which the player is allowed to perform all operations including sliding, and can clear an edge either by sliding a pebble at an endpoint or by simultaneously placing pebbles at both endpoints. Next theorem is first proven by LaPaugh [2] for the edge search game, then by Kirousis and Papadimitriou [15] for the node search game, and finally by Bienstock and Seymour [14] for the mixed search.

Theorem 2

[14], [15], [2]
Recontamination does not help to search a graph.

This theorem guarantees that, for each of the edge search, the node search and the mixed search, there is a monotone search schedule on  for k searchers, if there is a search schedule on G for k searchers. Thus there is an optimal search schedule in terms of the number of times that edges are cleared as well as the number of searchers necessary to search. The problem of deciding the search number is also NP-complete [14], [15], for each of the edge search, the node search and the mixed search. As for the trees, however, the search number is computable in linear time, and an optimal schedule is constructible in  time.

Returning to the original Parson's graph search problem, observe that the cave is more naturally modeled by a polygon possibly with holes. Under this geometric setting, an evader is caught by a searcher when he is in the visibility range of the searcher. This polygon search problem was first introduced in [16] and has been extensively studied [17], [18]. An interesting difference between the graph setting and the geometric setting is that unlike the former [2], recontamination does help in the latter [17], [16]. The impact of the visibility range of a searcher to its search power is a typical research topic. One flashlight is strictly less powerful [16], but two flashlights are already as powerful as full visibility [19], [18]. These results however are for a single searcher.

Polygon search by a group of searchers has also been investigated [20], [21], [22]. In [20], [21], searching a polygonal region by a chain of searchers is considered; the searchers form a polygonal chain such that neighboring searchers are mutually visible, and the chain is swept across the region. It is shown that searchers with one flashlight have the same search power as ones with full visibility, as long as this strategy is adopted [21]. To search a polygon with bushiness β,2 
 searchers with one flashlight are sometimes necessary and always sufficient [22]. See e.g., [23] for more information.

The dark cave model was introduced in [24] for tree exploration by a single agent with local memory of size , where n is the order of the graph. In the literature, an algorithm to assign local port labels at each node was presented based on a perpetual Euler tour on the graph and node degrees.

Organization After introducing the dark cave model and defining the graph search problem in Section 2, we prepare some notions necessary to construct and analyze our search algorithm OLSEARCH in Section 3. Section 4 presents OLSEARCH, and shows that  searchers are sufficient to search G by OLSEARCH. We give concluding remarks and open problems in Section 5.

2. Dark cave model and graph search problem
2.1. Dark cave model
Consider a set of k searchers 
 in a finite undirected connected graph . G is anonymous and neither the nodes nor the edges are labeled. A node u with degree  is a tiny round room with  ports (i.e., doors to incident edges) aligned on the wall, among which the clockwise direction is defined, provided that every searcher in u has the sense of clockwise direction. These ports are however anonymous, and port numbers are not attached to them. Node u does not support local memory (or whiteboard).

Each searcher 
 has a unique identifier 
, where N is the set of natural numbers, and has sufficiently large local memory. Initially, 
 is placed at a node 
 sometimes called the “homebase.” Each searcher does not know the topology of G and an upper bound on . Additionally, each searcher does not know the number of searchers in G. Searcher 
 does not have a marking device like pebbles, thus 
 cannot mark 
 as its homebase to distinguish it from the other nodes. The homebases of searchers may not be distinct. When a searcher 
 is on a node v, 
 is aware of the degree of v. Searcher 
 catches the evader when they meet, and to meet is the only way to catch the evader.

Each searcher 
 in  can traverse any edge  incident to u by “choosing” the port p corresponding to e. Recall however that the ports are anonymous. The algorithm specifies p in one of the following two ways:

1.
The algorithm can instruct 
 to choose an arbitrary port. Then 
 non-deterministically chooses a port, which is assumed to be the worst port for the algorithm. That is, the selection is governed by an adversary.

2.
When 
 arrived u from another node, the algorithm can use the port q from which 
 entered u and the clockwise direction among the ports to specify p. We assume that 
 remembers q as long as it stays in u. Then the algorithm can specify a port by stating e.g., the h-th port from q clockwise, where the 0-th port from q is q itself. Note that 
 forgets q as soon as it leaves u.

We assume that every edge  is a form of a corridor, and searcher 
 who enters e from u remembers the forward direction from u to v as long as it stays in e, and monotonically moves towards v. It then reaches and enters v within a finite time, unless it meets the evader (and ends the search) or another searcher. Next paragraph explains what happens when searchers meet.

Recall that a node does not have a whiteboard to support communication between searchers. Instead, two searchers can communicate with each other wherever they meet, even in an edge. That is, when searchers meet, each of them immediately terminates the action it was executing and starts a communication and computation operation: If ℓ searchers 
 meet at time t, every searcher 
 automatically receives information 
, where 
 is the contents of local memory of 
 at time t, and then examines I to decide the next action based on a given algorithm. This communication and computation operation is assumed to be instantaneous.

Finally, the searchers are fully asynchronous. This means that each searcher at a node can start moving at any time. Additionally, speed of searcher traversing an edge is arbitrary.

2.2. Graph search problem
We are interested in designing a graph search algorithm A given to every searcher. An instance of the problem is a triple  of a graph , the identifiers 
 and the homebases 
 of k searchers 
. A searcher 
 does not have any a priori knowledge of  besides 
. The set of full trajectories of the searchers executing A for , which is simply called the (global) behavior, is by no means deterministic, as A may instruct a searcher to choose an arbitrary port, and the searchers' motions are not synchronized. Let  be the set of all possible behaviors. We say that A solves the graph search problem for  when the following conditions hold:

1.
If there is an evader in G, then a searcher eventually meets the evader, for any behavior in .

2.
If there is no evader in G, then every searcher eventually terminates A reporting that it did not meet any evaders in any behavior in .

We say that A solves the graph search problem on G by k searchers, if A solves the graph search problem for any instance , where ID and HB are a list of k distinct natural numbers and a list of k nodes in V, respectively. If there is an algorithm A that solves the graph search problem on G by k searchers, G is searchable by k searchers. The search number of G, denoted by , is the minimum number k of searchers sufficient to search G.
Proposition 1

For any graph G, .

Proof

Suppose that G is searchable by k searchers. We show that there is an edge search schedule on G for k pebbles. Let A be an algorithm that solves the graph search problem for G by k searchers. Then for any instance , A solves the graph search problem for , where ID and HB are the identifiers and the homebases of the k searchers. Since the searchers are asynchronous, there is a behavior  that satisfies the following condition: No two searchers move simultaneously, and once a searcher 
 in some node u enters an edge , the other searchers do not move until 
 reaches v. That is, in B, at most one searcher traverses an edge, and it does not meet another searcher in an edge. It is now easy to construct an edge search schedule on G for k pebbles, by simulating the trajectory of searcher 
 by the i-th pebble. □

We did not specify the correct behavior of a search algorithm when there are less than  searchers in G, in the above definition of searchability; the searchers are allowed to keep moving in vain without recognizing this fact. Our graph search algorithm OLSEARCH given in Section 4 has a good property from this aspect: It can declare the impossibility of search and instruct the searchers to terminate, when the number of searchers is less than , provided that there are at least two searchers.

3. Ingredients of OLSEARCH
Next section presents the proposed algorithm OLSEARCH that solves the graph search problem under the dark cave model. In this section, after describing an outline of OLSEARCH, we explain some of its key ingredients. Specifically, we introduce and investigate the meeting problem, the gathering problem, the exploration problem and the problem of sharing information among the searchers.

3.1. Outline of OLSEARCH
A path graph is obviously searchable by a single searcher. We thus concentrate on searching a graph G, provided that it is not a path graph. Since  if G is not a path graph, we assume without loss of generality that there are at least two searchers in G by Proposition 1.

In OLSEARCH, all searchers first gather at a node and elect one searcher as the leader. Roughly speaking, the searcher with the smallest identifier becomes the leader; however, in Subsection 4.3 we adopt slightly different definition to make the algorithm simpler. The leader then recognizes G and constructs a monotone edge search schedule π of G if ; otherwise, OLSEARCH declares that G is not searchable. Finally the searcher with the i-th smallest identifier simulates the move of the i-th pebble in π.

The gathering problem is the hardest problem to solve among the three problems mentioned above. All searchers, who do not know the number k of searchers in G a priori, need to agree that they all have gathered. To this end, every searcher first explores all nodes and edges of G to search for another searcher by repeatedly exploring the whole G. By using the meeting algorithm we will present in Subsection 4.1, a pair of searchers can eventually meet. More clearly, the algorithm guarantees that any pair of searchers can meet no matter where they are initially located, and that an upper bound B on the number of edge traversals necessary for them to meet can be calculated from an upper bound Ξ on the order n of G.

When two searchers meet, they conduct an algorithm based on the breadth first search to estimate an upper bound Ξ, and one of them executes the meeting algorithm for B steps without terminating it even if it meets a searcher. Then it will have met all searchers after B steps, and can count the number k of searchers. Now it is easy to solve the gathering problem.

Needless to say, collaborations between searchers need an algorithm to share information.

3.2. Meeting problem
The meeting problem defined for a set of  searchers in a graph G requires that at least one pair of searchers meet in G. The rendezvous problem is the meeting problem for . Let n be the order of G. Then the meeting problem in G is trivially solvable when . The meeting number  of G is the minimum number k of searchers for which the meeting problem in G is solvable; more formally,  is the smallest number of searchers such that there is an algorithm A which solves the meeting problem for any instance . The meeting problem in G is obviously solvable for any .

Lemma 1

Suppose that . Then there is no search algorithm for k searchers in G, if there is no meeting algorithm for k searchers in G. That is, .

Proof

Graph G is not a path graph, since . To derive a contradiction, suppose that there is a search algorithm A for k searchers in G, but there is no meeting algorithm for k searchers in G. Since A is not a meeting algorithm in G, no two searchers meet in G during the search.

Let  be any global behavior of the searchers executing A. To define B formally, let us use the Parsons' model we explained in Section 1. Fix any straight line representation  of G in 
. The trajectory of a searcher s in B is denoted by a function  from  to . We define a trajectory  of evader ε in  such that any searcher cannot catch ε in B. Let ℓ and 
 denote the minimum length of any edge and the minimum distance between any pair of searchers in B, respectively. That is, 
 holds for any two searchers s and 
 and for any time t, where  is the Euclidean distance between u and v. Since A is not a meeting algorithm, 
. Let 
.

Arbitrarily choose a searcher s and fix it. We construct  so that  will hold for all t, which is sufficient to conclude the lemma, since no searcher 
 (including s) can catch ε because 
 holds for all t. It is worth emphasizing that we can use the behavior of s in B in the construction of .

The basic move of ε is the following: If s leaves, then ε follows s, keeping . If s approaches, then ε leaves s, keeping . All what we need to explain is that ε is never driven into a leaf, i.e., ε is safe forever. Observe that ε is not safe only when (1) there is exactly one path between ε and the leaf, (2) the path does not contain a node with degree more than two, and (3) s is approaching ε to go to the leaf.

We first show that there is a safe point  at time . By definition  is at a node . Suppose first that the degree of  is at least three. Then there is a node v adjacent to u such that s does not enter  when s starts moving. Then we take  in  with distance  from u. Suppose otherwise that the degree of  is less than three. Then there is a shortest path connecting u and a node w with degree at least three since G is not a path graph. Let v be the node in the path adjacent to u. Then again we take  in  with distance  from u. Obviously  is safe in both cases.

We next show that ε can be kept safe forever. Suppose that ε is safe at t and s is approaching. If s does not reach a point within distance  from a leaf, obviously the basic move mentioned above can avoid a near miss forever. If s reaches a point within distance  from a leaf, let 
 be the sequence of nodes that s visits to reach a point near from leaf 
, where 
 is the leaf that s approaches next. Since ε is safe at t, there is a node 
 with degree at least three. Then there is a node v adjacent to 
 besides 
 and 
, and s does not enter edge 
. Now, evader ε can enter 
 when ε reaches 
, and follow s after s passes 
 to 
, to keep its situation safe. □

In Subsection 4.1, we present a meeting algorithm MEET, and show that two searchers executing MEET eventually meet; that is, we show  for any G.

3.3. Gathering problem
The gathering problem for a set of  searchers in a graph G asks all searchers to gather in a node. The gathering number  of G is the minimum number  of searchers for which the gathering problem in G is solvable; more formally,  is the smallest number  of searchers such that there is an algorithm A which solves the gathering problem on any instance . Obviously , since a pair of searchers must meet in order for all searchers to gather. In Subsection 4.3, we will present a gathering algorithm GATHER, which uses MEET as a main subroutine, and show that, if the meeting problem is solvable, so is the gathering problem. Thus, like the meeting problem, for any G, the gathering problem in G is solvable for any .

3.4. Exploration problem
Let  be the set of all undirected connected graphs with the order at most Ξ and the maximum degree at most Δ. A universal traversal sequence (UTS) for  is a sequence 
 of non-negative integers less than Δ satisfying the following condition: For any graph , any (global) port numbering function λ for G and any node 
, define 
 for  by 
 if 
 and 
 otherwise, where λ is a function from V to a (local) port numbering function, i.e., for each , 
 is a one-to-one function from 
 to the set 
 of nodes adjacent to u. Here 
 is the degree of u in G. In other words, 
 is the trajectory of a searcher when it follows port numbers 
 in this order starting from 
. Then 
, i.e., the searcher can visit all nodes in G. For any Ξ and Δ, there is a UTS of length 
 [25]. Thus any graph of order at most Ξ can be explored by using a UTS of length 
, since .

Koucky [26] showed that a universal sequence with the same property as UTS is also given as a sequence 
 of offsets; if a searcher reaches 
 via a port (number) 
, then it leaves 
 via the port (number) 
, i.e., 
. Here we assume 
 in the rest of this paper, although we can take any port number as 
. Then again 
 holds. The same upper bound 
 on the length of such a sequence O can be obtained by the proof mentioned above for UTS in [25]. This sequence O is called a universal exploration sequence (UXS). Notice a small difference between UTS and UXS. In UTS, 
 whenever 
, while in UXS, 
 can hold, even if 
.

Reingold [27] gives an algorithm to create a UXS  when an upper bound Ξ of order n of G is given. We use  to create a trajectory that visits not only all nodes but also all edges, by instructing a searcher who reaches a node u following  to take a round trip to each of the u's neighbors 
 in this order before moving to the next node. Here 
 is the neighbor of u reachable from u through the edge with port number i. Let 
 be the trajectory of a searcher who follows  and round trips to each neighbor whenever it reaches a node in , starting from a node 
. Although the searcher does not know 
 since the nodes are anonymous, by definition, 
 is integral, which means that it visits all nodes and all edges.

UXS 
 also creates a universal trajectory under the dark cave model, under which the port numbers are not attached: If the searcher is in 
 then it enters the edge 
 corresponding to the 
-th port clockwise from the port 
 from which it enters 
. Here the searcher can select an arbitrarily port when  to leave 
; it leaves 
 through the 
-th port 
 clockwise from the selected port. Let 
 be the trajectory of the searcher who follows  starting from 
 under the dark cave model, in which, like 
, whenever the searcher reaches a node u (including 
), it takes a round trip to each of the u's neighbors 
 in this order before moving to the next node. Here 
 is the edge corresponding to the i-th port clockwise from the port from which it enters u (or 
 when 
).

Let us observe that indeed the searcher can follow 
 under the dark cave model. Suppose that the searcher enters a node u from a port p and  instructs it to leave u from the o-th port clockwise from p. It needs to take round trips to each of the u's neighbors. To this end, it counts the number c of round trips it has taken. In the first round trip, it takes p to leave u and arrives 
 and leaves 
 through the port from which it enters 
. When it returns u from the c-th round trip via port q, if 
, it leaves u from the first port clockwise from q to reach 
, and then returns to u through the port from which it arrives 
. Otherwise, if 
, all neighbors have been visited. Thus it leaves u from the -st port clockwise from q. Observe that the first port clockwise from q is p. Obviously 
 is integral, but 
 in general.

3.5. Trajectory sharing problem
Collaborations by a group of searchers are done based on sharing their trajectories, each of which could be described as a sequence of port numbers if there were. Since port numbers are not attached under the dark cave model, we introduce a way to describe a trajectory and a method to share it with another searcher. Suppose that a searcher s at a node 
 in  has traversed a path 
, where 
 for . Then s can memorize X as a sequence 
 of offsets, where the port leading to 
 in 
 is the 
-th port clockwise from the port from which it arrives 
 (through 
) for . Searcher s can also remember the port 
3 from which it enters 
 as long as it stays in 
, but cannot specify which port in 
 it used to start traversing X. Nevertheless, s can traverse 
 
, i.e., traverse X in reverse direction, and can return to 
 using P; we use the port 
 to reach 
, and use the 
-th port counter-clockwise to reach 
 from 
. Thus another searcher 
 in 
 can also traverse 
 
 (and hence X), if it can perceive the port 
 of s.

An algorithm PORT-INFO solves this problem as follows: First s moves to 
 through port 
. However 
 cannot perceive from which port s leaves by definition – the cave is dark. Then for each 
, 
 chooses the p-th port clockwise starting from its 0-th port, and examines if this choice is successful. That is, 
 moves to the adjacent node u through the p-th port, and checks if s is in u. If 
 meets s, it returns to 
 and remember p as the port 
 of s.

Searchers s and 
 meeting in an edge  may also need to share information from which node they each arrive. Suppose that s has a smaller identifier than 
 and it moves from u to v. Then s first resumes the traverse of e to v. Next 
 resumes the traverse of e. If 
 meets s in e or in v, then they traversed e in the same direction. Otherwise, when 
 reaches u and s is not there, it returns v to tell s that they have traversed e in different directions.

In what follows, we assume that, wherever searchers exchange their trajectories in terms of a sequence of offsets and whenever it is necessary, they also exchange the ports through which they have reached the node by using PORT-INFO, although we will not explicitly state it.

4. Searching graph by optimal number of searchers
In this section, we present an online graph search algorithm OLSEARCH, which verifies . For the convenience of description, we first present another graph search algorithm OLS. OLSEARCH is obtained as a modification of OLS. OLS is an online graph search algorithm for  searchers, provided that G is not a path graph. Obviously  if and only if G is not a path graph. Then OLS requires  searchers to search G, since we will show  in this section. OLSEARCH is an extension of OLS so that it can search a path graph by one searcher. It implies that OLSEARCH can search any graph G by  searchers. Algorithm OLS consists of the following five phases (sub-algorithms):

(MEET)
Solve the meeting problem in G.

(UPBOUND)
Find an upper bound Ξ on the order n of G.

(GATHER)
Solve the gathering problem in G.

(TOPOLOGY)
Recognize G.

(SEARCH)
Simulate a monotone edge search schedule on G.

Among the five algorithms, we borrow algorithm RV-asynch-poly from [28] to create MEET. More clearly, as MEET, we use RV-asynch-poly after slight modifications. RV-asynch-poly (and hence MEET) guarantee that a pair of searchers initially located in any nodes can eventually meet, and an upper bound B on the time complexity in the number of edge traversals is computable from an upper bound Ξ on the order n. Thus every searcher can meet every other searcher if it does not terminate RV-asynch-poly when it meets another searcher. Then it is easy to gather at a node that the searcher with the smallest identifier specifies.4 Algorithm UPBOUND is designed to estimate an upper bound Ξ based on the breadth first search. Algorithm TOPOLOGY recognizes G again based on the breadth first search. Finally SEARCH computes a monotone edge-search schedule on G, and simulates it. This simulation requires some tricks to correctly simulate a sequential schedule by a set of asynchronous searchers without the help of a global synchronizer.

4.1. MEET
4.1.1. RV-asynch-poly
The model under which algorithm RV-asynch-poly solves the meeting problem is exactly the same as the dark cave model, except that G has a port numbering [28]. Consider two searchers with distinct identifiers in an unknown anonymous graph . The graph G has a port numbering λ, but nodes have no whiteboards, unlike the mobile agent model. The searchers are asynchronous, and they do not even know an upper bound Ξ on the order . Algorithm RV-asynch-poly is presented in terms of combinations of  that starts from  and visits all nodes and all edges with a given upper bound j of the order of a graph. See Subsection 3.4 again for the definition. We prepare three notations. Let 
 be a trajectory. By 
 
, we denote the reversal of T. When 
 and 
, by 
, we denote the concatenation of T and 
. Here we assume that we delete 
 from 
 when 
. When 
, by 
, we denote  of the concatenation of m copies of T. RV-asynch-poly uses the following trajectories.

1.
 
.

2.
.

3.
 
, where 
 and 
.

4.
.

5.
 
, where 
 and 
.

6.
, where  is the number of edges that are traversed by following trajectory  for any node .

7.
, where  (resp., ) is the number of edges that are traversed following trajectory  (resp., ) for any node .

8.
, where  is the number of edges that are traversed by following trajectory  for any node .

All trajectories defined above are well-defined. Particularly, observe that 
 and hence  are well-defined, since 
 ends in node 
 for all  and 
 for .

When 
 is the binary representation of identifier L of a searcher, by , we denote the sequence 
. We present RV-asynch-poly [28] for the convenience of readers.


Algorithm 1
Download : Download high-res image (88KB)
Download : Download full-size image
Algorithm 1. RV-asynch-poly [28].

Theorem 3

[28]
Algorithm RV-asynch-poly solves the meeting problem for two searchers for any global port numbering.

Their proof of this theorem depends on the following properties.

Property 1

(I)
For any  and node , , and hence , , , , , ,  and  are integral.

(II)
For any  and node , , and hence ,  and  contain, for each  and ,  as a subtrajectory.

(III)
For any  and node ,  contains, for each  and ,  as a subtrajectory.

4.1.2. RVAP
We present an algorithm RVAP which works under the dark cave model, and show that it simulates RV-asynch-poly and solves the meeting problem. Recall the definition of 
. If , it is integral, i.e., a searcher that follows 
 visits all nodes and all edges. RVAP uses the following trajectories which correspond to those in RV-asynch-poly. We also explain how a searcher can follow each trajectory under the dark cave model.

1.
 
.

2.
.

3.
, where 
, 
, and 
 is the port through which a searcher traversing 
 reaches 
 for .

4.
 
.

5.
.

6.
, where 
, 
, and 
 is the port through which a searcher traversing 
 reaches 
 for .

7.
 
.

8.
, where 
 is the number of edges that are traversed by following trajectory 
 for any node  and port p in u.

9.
, where 
 (resp., 
) is the number of edges that are traversed following trajectory 
 (resp., 
) for any node  and port p in u.

10.
, where 
 is the number of edges that are traversed by following trajectory 
 for any node  and port p in u.

Proposition 2

A searcher can follow each of the trajectories defined above, provided that it is initially in .

Proof

(1) 
: By the argument in Subsection 3.5, the searcher can follow 
, since it can follow 
. Observe that the searcher will return v through p after traversing 
 by the definition of 
, since it first takes a round trip through port p to follow 
.

(2) 
: Since the searcher traversing 
 returns v through port p, it can easily follow 
 by remembering the current index i of 
 and return to v from p after traversing 
.

(3) 
: Since the searcher returns to v from p after traversing 
, to follow 
, when finishing the traversal of 
, it simply moves to 
 specified by 
.

(4) 
: Obviously the searcher can follow 
 and return to v from p after traversing 
.

(5) 
: Since the searcher traversing 
 returns v through port p, it can easily follow 
 by remembering the current index i of 
 and return to v from p after traversing 
.

(6) 
: Since the searcher returns to v from p after traversing 
, to follow 
, when finishing the traversal of 
, it simply moves to 
 specified by 
.

(7) 
: Obviously the searcher can follow 
 and return to v from p after traversing 
.

(8) 
: Since the searcher returns to v from p after traversing 
, obviously it can follow 
, provided that 
 is computable.

(9) 
: Since the searcher returns to v from p after traversing 
, obviously it can follow 
, provided that 
 is computable.

(10) : Since the searcher returns to v from p after traversing 
, obviously it can follow 
, provided that 
 is computable. □

Please note that, in Proposition 2, the searcher can follow these trajectories only if 
, 
 and 
 are computable. In order to construct RVAP, for the time being, we assume that they are computable. We will then solve this problem in the next subsection. Like RV-asynch-poly, when 
 is the binary representation of identifier L of a searcher, by , we denote the sequence 
. Now we present RVAP in the following:

Algorithm 2
Download : Download high-res image (94KB)
Download : Download full-size image
Algorithm 2. RVAP.

The next properties are basis of the correctness proof of RVAP.

Property 2

(I)
For any , any node  and any port p in v, 
, and hence 
, 
, 
, 
, 
, 
, 
 and 
 are integral.

(II)
For any , any node  and any port p in v, 
, and hence 
, 
 and 
 contain, for each , node  and port q in u, 
 as a subtrajectory.

(III)
For any , any node  and any port p in v, 
 contains, for each , node  and port q in u, 
 as a subtrajectory.

Proof

(I) Claim (I) is trivial by the fact that 
 is integral; 
 and the other trajectories containing it also contain 
.

(II) To show Claim (II), it is sufficient to show the claim for 
, since the other trajectories contain it. Since 
 contains 
 for any , it suffices to show that 
 contains 
 for any  and any port q in u. By the definition of 
 and since it is integral, it eventually reaches u and takes round trips to its neighbors. That is, for any port q in u, 
 leaves u via q and returns to u through q. By the definition of 
, 
 is constructed from 
 by adding 
 when it reaches a node u via a port q.

(III) A proof for Claim (III) is similar to the one for Claim (II). □

Lemma 2

Algorithm RVAP solves the meeting problem for two searchers under the dark cave model.

Proof

The correctness proof for RV-asynch-poly also proves the correctness of RVAP, when the trajectories for RV-asynch-poly in the proof are replaced by their counterparts in RVAP. □

4.1.3. MEET
Although RVAP correctly solves the meeting problem under the dark cave model, there is a flaw; even when , 
 and 
 are not computable, since G is not recognizable.5

To overcome this problem, we start with an approximation  of 
, where D is the maximum degree that a searcher has encountered so far in the execution of RVAP. Note that  is computable. If , then D is the maximum degree of G, and hence 
 for any  and any port p in v. Recalling the definitions of 
, 
 and 
, we define

1.
,

2.
, and

3.
.

Then, for any  and any port p in v,
1.
,

2.
, and

3.
,

if .
Now we present a meeting algorithm MEET that works under the dark cave model. Let

1.
⁎
,

2.
⁎
, and

3.
⁎
,

where D be the maximum degree that the searcher executing MEET has encountered so far.

Algorithm 3
Download : Download high-res image (109KB)
Download : Download full-size image
Algorithm 3. MEET.

Theorem 4

Algorithm MEET solves the meeting problem for two searchers under the dark cave model. That is, .

Proof

By Lemma 2 and its proof, it suffices to observe that when , 
, 
 and 
 are bounded from above by 
, 
 and 
, respectively, which are indeed obvious by their definitions. □

4.2. UPBOUND
To solve the gathering problem, at least a searcher must meet all other searchers. Observe that a searcher s who executes MEET eventually meets all other searchers 
 (who also execute MEET), if it does not terminate MEET when it meets searchers. Hence s can collect the identifiers of all searchers and count the number k of the searchers. Although this incremental feature of MEET is not sufficient for s to convince that it has already met all other searchers, an upper bound B on the number of edge traversals that MEET requires to solve the meeting problem on G in the worst case helps, since B is obviously a sufficient number of edge traversals for s to meet all other searchers. And importantly, B can be calculated by using an upper bound Ξ on the order n of G by the definition of MEET. This subsection presents an algorithm UPBOUND for computing Ξ on G, provided that two searchers s and 
 at the same node 
 invoke UPBOUND. Without loss of generality, we assume that s has a smaller identifier than 
. In the design of UPBOUND, we do not move 
 during the execution of UPBOUND to guarantee the correctness of MEET executed by other searchers 
 who may not meet s (since s is executing UPBOUND, not MEET); 
 must meet 
 and can get information on s from 
.

Hence UPBOUND (for 
) is simple: It stays at 
 waiting for s returning and finishing UPBOUND (for s). We call 
 the anchor.

UPBOUND (for s) is based on the breadth first search (BFS), and s explores all nodes in V; nevertheless, s may not be able to count the exact n because of the reason we explain shortly. We call s the explorer. UPBOUND makes use of a queue Q that contains nodes v which have been discovered but have not been visited yet to examine their neighbors. It also uses a set U that contains the nodes which have been visited. Since nodes are anonymous, in both Q and U, each node v is identified by a shortest path 
 from 
, and Q keeps v in the increasing order of its length 
. Recall however that 
 is represented by a sequence of offsets: Suppose that, for , 
 is the edge corresponding to the 
-st port clockwise from the port through which the searcher reaches 
 Then 
 is denoted by a sequence 
.

What we need to emphasize here is that, in Q or U, a node v may occur more than once, since v may have two (or more) shortest paths denoted by offset sequences P and O representing v, and in general s cannot determine whether or not two nodes represented by P and O are identical. For the sake of accuracy, we define Q and U as follows: Q contains the set of paths 
 such that v has been discovered but has not been visited yet, while U contains the set of paths 
 such that v has been visited.

To calculate an upper bound on n, s counts the number of all shortest paths 
 of v from 
 for each node v. Now we present UPBOUND (for s):

(0)
Initially Q contains an empty sequence ϵ that represents 
, and U is empty. As long as , s repeats .

(1)
Searcher s picks the first element 
 from Q and visits v following 
 to examine each neighbor of v.

(2)
Searcher s executes the following test for each neighbor 
 of v, where 
 for some integer 
, where 
 is the list of offsets constructed from 
 by appending p. Let 
. Then s moves to 
 through the p-th port clockwise from the port q, through which s reached v from 
 following 
, and decides if h is the distance between 
 and 
, or in other words 
 is a shortest path between 
 and 
, by conducting a BFS with the maximum depth  with 
 being the initial node. If s encounters 
 during the BFS, i.e., if the distance between 
 and 
 is at most , it discards 
, since 
 is not a shortest path (connecting 
 and 
). Otherwise, s puts it at the end of Q.

(3)
Searcher s puts 
 in U.

The next property is obvious from the definition of UPBOUND.

Property 3

When UPBOUND terminates, U contains every shortest path 
 from 
 to v, for each . That is,  is an upper bound Ξ on the order n of G.

Before going on the next subsection of explaining algorithm GATHER, we would like to solve a small issue that we did not touch in UPBOUND. Two searchers executing MEET may meet at a point x in an edge, not at a node. In such a case, we allow them start UPBOUND from x, considering x as a “virtual node,” and letting the anchor remember this fact. It is indeed feasible, since the anchor does not move during UPBOUND until the explore returns and a searcher (in particular, an explorer) can distinguish a virtual node from a node. As a result, the explorer (and hence the anchor) know an upper bound Ξ on the number of nodes which includes this virtual node by Property 3.

4.3. GATHER
We present algorithm GATHER to solve the gathering problem under the dark cave model, which uses MEET and UPBOUND as subroutines. We first illustrate an outline of GATHER.

1.
Every searcher executes MEET. Then two searchers eventually meet at a node, which may be a virtual node. Suppose that searchers s and 
 meet at a node 
, where the identifier of s is smaller than that of 
.

2.
Searchers s and 
 execute UPBOUND intermitting MEET, where s is the explorer and 
 is the anchor. Then s eventually returns with an upper bound Ξ and computes B, which is an upper bound on the number of edge traversals sufficient for MEET to finish even in the worst case.

3.
Searcher s resumes MEET until the total number of edge traversals (i.e., including the ones before intermission) becomes B.

4.
When s has traversed B edges and terminates MEET, all other searchers have already been discovered by s. Now s becomes the leader and teaches a node 
 to each searcher as the gathering node. (We will embed a trick to guarantee the uniqueness of the leader in the description of GATHER.)

5.
Finally every searcher moves to 
 to solve the gathering problem.

This outline of GATHER does not describe full interactions among searchers. For example, it does not state how two explores act when they meet. GATHER consists of the following four phases:

MEET1:
The execution of MEET before the intermission.

UPBOUND:
The execution of UPBOUND.

MEET2:
The execution of MEET after the intermission.

GATHER:
The execution to move to the gathering node 
.

A searcher executing GATHER executes these four phases in this order, but it may stop the execution of a phase or skip to another phase. In order to define the flow of control, GATHER uses the following seven states of a searcher s:

FindPartner:
s is executing MEET to look for a searcher before the intermission.

Explorer:
s is executing UPBOUND as an explore.

Anchor:
s is executing UPBOUND as an anchor.

FindMember:
s is executing MEET after the intermission to meet all the searchers.

Leader:
s has terminated MEET after executing B edge traversals.

Follower:
s does not move and waits for the leader who teaches it 
.

Gathering:
s is moving to 
.

Assume that each searcher s has a local variable  to hold its state. By 
, we denote that the identifier of s is smaller than that of 
, i.e., 
 if and only if 
. When s starts GATHER, . We present GATHER:[Phase MEET1]

(1)
Every searcher s starts MEET with  FindPartner.

(2)
Searcher s eventually meets another searcher 
 in a node 
, which may be a virtual node, i.e., they may meet in an edge.

(2.1)
If 
, s (and 
) start UPBOUND. That is, if 
, s updates its state to Explorer and starts UPBOUND as an explorer; otherwise if 
, s updates its state to Anchor and starts UPBOUND as an anchor.

(2.2)
If 
, s updates its state to Follower and waits for the leader, i.e., the process with state Leader, who teaches s the gathering node 
. Note that this rule applies even to the case when 
.

[Phase UPBOUND]
Suppose that two searchers s and 
 meet at a node 
 in Phase MEET 1 and start executing UPBOUND as an explorer and an anchor, respectively; i.e., 
 and their states are Explorer and Anchor, respectively. An important role of 
 is to remember the “potential” state of s: To this end, it prepares a local variable 
, whose initial value is Explorer. It also remembers 
. In Phase UPBOUND, s updates its state only when it meets 
 at 
.

(1)
Explorer s executing UPBOUND conducts the BFS to visit all nodes and returns to 
 frequently to test if a given path is a shortest path, while anchor 
 continue to stay in 
 until UPBOUND is terminated by s.

(2)
s or 
 may meet with a third searcher 
 during UPBOUND.

(2.1)
When s meets 
: s does not take any action, ignoring this meeting event.

(2.2)
When 
 meets 
 at 
: If 
 and 
, or 
= FindMember, then 
 updates 
 to Follower. If 
= Leader, then 
 updates 
 to Gathering and, in addition, 
 and 
 wait for s to share the gathering node 
. Otherwise, 
 does not take any action, (while 
 becomes a follower as explained in Phase MEET1).

(3)
s returns to 
, at which 
 is waiting.

(3.1)
When 
 of 
 is Explorer, s and 
 continue to execute UPBOUND if it is in the middle of execution.

Otherwise, if UPBOUND is terminating and an upper bound Ξ on the order n of G has been computed, s updates its state to FindMember and start Phase MEET2, while s updates its state to Follower and waits for the leader.

(3.2)
When 
 of 
 is Follower, s and 
 update their states to Follower and “abort” UPBOUND; intuitively, s has lost at the survival race for the leader because there is an explorer 
 with 
 in Phase UPBOUND.

(3.3)
When 
 of 
 is Gathering, s and 
 update their states to Follower and “abort” UPBOUND. s, 
 and 
 share the 0-th port of 
 and s and 
 receive 
. s and 
 update their states to Gather and start Phase GATHER, to move to 
.

[Phase MEET2]
A searcher s with  FindMember resumes MEET from 
. It prepares a list Members which contains, for each of the searchers 
 that s will meet in Phase MEET2, the pair of its identifier 
 and the node 
 at which s and 
 meet. Here 
, as well as 
, may be a virtual node. When s resumes MEET at 
, there are several searchers at 
, including the (previous) anchor 
 of s, whose data comprise the initial Members.

(1)
s with state FindMember resumes MEET from 
.

(2)
s may meet a searcher 
 at a node v, which may be a virtual node.

(2.1)
When 
 Anchor, s puts pairs 
 and 
⁎
 in its Members to remember 
 and 
⁎
 as a follower it has met, where 
⁎
 is the explorer of 
, to remember 
 and 
⁎
 as future followers it has met.

(2.2)
When 
 Follower, or 
 FindMember and 
, s puts a pair 
 in its Members, to remember 
 as a follower it has met.

(2.3)
When 
 and 
, s updates its state to Follower and aborts MEET; intuitively, s has lost at the survival race for the leader because there is a searcher 
 with 
 in Phase MEET2.

(3)
When s has traversed B edges in total and finished Phase MEET2, it updates its state to Leader to become the leader. As we will show, the leader is unique and Members contains all searchers except s. Observe that the leader may not be the searcher with the smallest identifier.

[Phase GATHER]
(1)
The leader s with state Leader visits all searchers in Members and teach them the gathering node 
, which we will define later. Specifically, leader s visits all other searchers as follows: Since s meets all other searchers in MEET and does not meet any searcher in Phase MEET1 except its anchor 
 (which is included in Members as an initial member), it meets all other searchers in Phase MEET2 but 
 and includes them in Members, when we regard the location of an explorer as the location of its anchor.

Let T be the trajectory that s took in MEET2. Then s takes trajectory 
 
 to systematically visit all other searchers.

(2)
Every searcher 
 eventually meets the leader s. Recall how 
 acts when it meets the leader which we have already specified: If its state is Follower, then it updates its state to Gathering and moves to 
. If it is Explorer, it does not take any action. If it is Anchor, s and 
 wait for its explorer returning, and then 
 and its explorer receive 
 from s and update their state to Gathering and move to 
. Note that the state of 
 is neither FindPartner nor FindMember.

(3)
When the leader s returns to 
 traversing 
 
, it updates its state to Gathering and moves to 
.

(4)
When the leader confirms that all searchers in Members have gathered in 
, it declares the completion of gathering.

[Gathering Node] We still need some explanations to make the description of GATHER complete, including the definition of gathering node 
. Consider the trajectory 
 of the leader s in Phase MEET2 who starts this phase at 
. We define 
 if 
, i.e., if 
 is not a virtual node. If 
 is a virtual node, it is located in an edge , where we assume 
, without loss of generality. Then we define 
.
Recall that T is specified as a sequence 
 of offsets. If a searcher s with state FindMember meets a searcher 
 when it is traversing the i-th edge in Phase MEET2, we define the location of 
 by 
. It is easy to observe that given 
 and the direction of 
, in terms of the port leading to it, 
 can move to 
.

When the leader s returns to 
 in Phase GATHER, it teaches 
 and the direction of 
 (i.e., the port it takes to return to 
) to 
 so that 
 can move to 
.

Theorem 5

Algorithm GATHER solves the gathering problem under the dark cave model.

Proof

By the definition of Phase MEET1, at least one pair of searchers s and 
 meets and initiates UPBOUND, one as an explorer and the other as an anchor.

If s has the smallest identifier among the explorers, it finishes UPBOUND and updates its state to FindMember to start Phase MEET2. It then terminates this phase and becomes the leader.

To show the uniqueness of the leader, let us assume that there are two searchers s and 
 who terminate MEET2, where 
. By definition, in Phase MEET1 or Phase MEET2, s meets with 
 or its corresponding anchor 
, which implies that 
 aborts MEET2 (when s and 
 meet) or 
 becomes a follower possibly aborting UPBOUND (when s and 
 meet). A contradiction is derived.

To each searcher 
, the leader teaches the gathering node 
, as well as the offsets 
 and the direction of 
. Then 
 can move to 
.

Since the leader knows the number k of searchers, it can confirm that the gathering has completed. □

Corollary 1

For any G, . Furthermore, the gathering problem is solvable for any .

4.4. TOPOLOGY
We present algorithm TOPOLOGY to recognize G by conducting the BFS using queue Q and set U like UPBOUND. Without loss of generality, we assume that the gathering problem has been solved at a node 
, and the leader 
 (determined in GATHER) is the searcher with the smallest identifier. Otherwise, the leader simply declares to rename its identifier to be a smallest one. Let 
 be the searcher with the smallest identifier but 
. We also assume that all searchers, in particular 
 and 
, recognize the port 
 through which 
 returned 
 for the last time.

In TOPOLOGY, only 
 and 
 move, and 
 recognizes G by constructing for any node  its adjacency list 
. That is, 
 if and only if 
. Since the nodes are anonymous, a crucial work of TOPOLOGY is to give them unique names. In UPBOUND, a node v is represented by possibly several shortest paths connecting 
 and v, where 
 is the node at which UPBOUND is initiated. In TOPOLOGY, to each v, we associate the unique shortest path 
 connecting 
 and v that occurs in the BFS for the first time. Since 
 is denoted by a sequence 
 of offsets (and 
) like in UPBOUND, the name of v is indeed 
.

Two sequences of offsets P and O are said to be equivalent with respect to 
, if they both correspond to shortest paths connecting 
 and v, for some . We describe algorithm TOPOLOGY, whose skeleton is BFS:

(0)
Both of 
 and 
 are in 
 and recognize the port 
. 
 maintains a queue Q and a set U. Initially, Q contains an empty sequence ϵ that represents 
, and U is empty. As long as , 
 and 
 repeat .

(1)
Searcher 
 picks the first element 
 from Q, and both 
 and 
 visit v following 
 to examine each neighbor of v. Let 
. Searcher 
 creates an array 
; it knows 
, since it is in v.

(2)
For each 
, 
 and 
 decides if 
 and 
 are equivalent, for some 
 in . An equivalence test procedure between 
 and 
 in  is the following: First, 
 and 
 move to 
. After confirming that both 
 and 
 are in 
, 
 returns to 
 by taking 
 
 and then moves to 
 by following 
. It then checks if 
 is there; if the result is positive, then 
 and 
 are equivalent. Otherwise, if 
 is not there, 
 returns to 
 to share the result with 
. Finally they both return to v.

If 
 is not equivalent with any element in , then 
 puts 
 both in Q and 
. Otherwise, if 
 and 
 are equivalent for some 
 in , then 
 puts 
 in 
.

(3)
Leader 
 puts 
 in U, and both 
 and 
 return to 
 by taking 
 
.

Obviously, the next theorem holds:

Theorem 6

When 
 and 
 terminate TOPOLOGY, 
 has the adjacency list 
 of G for each . Both 
 and 
 recognize 
 when they return to 
 and terminate TOPOLOGY.

4.5. SEARCH
We present algorithm SEARCH. When SEARCH is initiated all searchers are gathered at a node 
. The leader 
 knows the graph  and the set ID of the identifiers of all searchers, which implies that all searchers know G and k, since they exchange all information when they meet by definition. By Theorem 6, all searchers also recognize the port 
, with respect to which a node  is represented by a sequence 
 of offsets corresponding to a shortest path 
 connecting 
 and v, in the description of G. Hence any searcher can indeed follow 
 and reach v by using 
 and 
, which is a crucial observation during SEARCH; 
 can give an instruction to any searcher in terms of a sequence of offsets.

In SEARCH, if , 
 declares that they give up searching G.

In what follows, we assume . The leader 
 first computes a monotone search schedule π of G for  pebbles, whose existence is guaranteed by Theorem 2. Recall the definition of edge search game. Schedule π uses  pebbles . The player can (1) place a pebble i at a node u — , (2) remove a pebble i from a node u — , or (3) slide a pebble i along the edge from a node u to another v — . That is, π is a sequence of operations 
, where 
 specifies the operation at time t; 
 
 is the name of pebble the player operates, and 
 is the action for pebble 
. More clearly, the action 
 for 
 starts at t and ends by . Since π is monotone, each edge  is traversed exactly once by a pebble to clear it, and all edges traversed by time 
 are clear at 
.

Suppose that, at time t, a pebble i is placed at a node , where we say that pebble i is placed in node ⊥ when it is not placed in G. Let 
 be the set of pebbles placed in v at t when . By definition, 
. For completeness, let 
 if . We call the sequence 
 the local schedule for pebble i, where 
 if 
, and 
, which means no action, if 
. Then 
 specifies the sequence of actions taken for pebble i, and each 
, for , specifies the synchronization condition necessary to initiate action 
 for i.

Although in π, exactly one pebble is assumed to be moved, the player may be able to move plural pebbles in an asynchronous fashion. Imagine that each pebble i is an autonomous mobile agent i in G which asynchronously moves following the local schedule . That is, the index t of 
 and 
 specifies only the order, not the real time, and 
 and 
 take arbitrary time duration. We call such an execution of π an asynchronous execution ASYNC(π) of π. In order to define ASYNC(π) formally, we use the Parsons' model in Section 1. Consider a straight line representation  of G in 
. Then a schedule for a pebble i is a continuous function 
 from  to , where 
 denotes the position of i at time t. Obviously ASYNC(π) is given as a set F of  functions 
.

Lemma 3

If π is a monotone search schedule of graph G for  pebbles, so is any asynchronous execution  of π.

Proof

Let 
 be the part of  that is clear at t for any time t. Then it suffices to show that 
 is monotone, i.e., 
 for all 
, since all edges are traversed at least once (because π is a schedule).

To derive a contradiction, suppose otherwise that 
 is not monotone, and the monotonicity is violated at time 
, i.e., 
 is monotone between time instants 0 and 
, but is not between 0 and 
 for any small real number . 
 consists of several connected components. Thus without loss of generality, let D be the connected component of 
 such that the monotonicity of D is violated at 
. More specifically, let Z be the set of points z in  which separates D from 
 
. Then for each z, there is a pebble i such that 
. Some of the pebbles are in edges, but sliding these pebbles in the edges by a sufficiently small distance never recontaminate D.

Thus the violation is introduced when one or more pebbles leave nodes. Suppose that at most one pebble i is leaving a node u at 
. Let 
 be the corresponding action in , i.e., 
 is either a slide action  or a remove action . Since, in π, the player takes the same action 
 at time t when the same set 
 of pebbles are gathered in u, without introducing recontamination, a contradiction is derived.

Thus two or more pebbles are leaving nodes at 
, which cause recontamination. If at most one pebble leaves each node, then a contradiction is derived by the same argument. Suppose that h pebbles 
 simultaneously leave a node u to traverse different edges 
, . Assume that 
 is the last pebble that leaves u in π without loss of generality. Then of course in π, this traversal of 
 does not introduce recontamination of u, provided that all 
,  are clear, which implies that u is clear when all pebbles 
 leave u simultaneously; a contradiction is derived. □

Next we modify π so that (1) all pebbles will be initially placed at a node 
 and (2) all pebbles will be always placed in G. The modified schedule is denoted by 
. To describe 
, we introduce a new action 
, which makes a pebble move from a node u to another node v through a shortest path 
 in G. The next procedure describes how to modify π to obtain 
:

1.
If 
 is the first place operation for i, where , i.e., if v is the initial node of pebble i in π, we replace  of 
 with 
, where 
 is an arbitrary shortest path from 
 to v, i.e., we have pebble i move from the initial node 
 in 
 to v.

2.
If 
 is a remove operation for i, where , and there is no place operation for i after time t, i.e., if pebble i will not be placed again in G, we remove 
, i.e., we have pebble i keep staying in u.

3.
If 
 is a remove operation for i, where , and there is an immediately succeeding place operation 
 for i, where 
, 
, and 
 is not a place operation for i for any 
, i.e., pebble i is removed from u at t, but will be placed in v at 
, we replace  of 
 with 
 and remove 
, where 
 is an arbitrary shortest path from u to v, i.e., we have pebble i move from u to v.

Note that 
 may not be monotone. We however have the following property, since 
 is obtained from π by introducing additional moves by redundant pebbles:

Property 4

If π is a search schedule of G, so is 
 for any 
.

Consider 
. We assume that 
 in 
 instructs pebble i to move from u to v through 
 without interacting other pebbles, i.e., without affecting the behaviors of the other pebbles. Then by the same argument we have:

Property 5

If π is a monotone search schedule of G, ASYNC(
) is a search schedule of G for any 
.

We assume that 
 has computed 
 for each , in which the trajectory that 
 is instructed to traverse in 
 is given as a sequence of offsets with respect to 
; 
 in 
, for example, is given as a sequence of offsets so that 
 can follow 
. We present algorithm SEARCH for searcher 
, which executes 
. SEARCH uses two states JUMP and NORM. We design SEARCH so that a searcher cannot affect other searchers, when its state is JUMP. Initially, all searchers 
 are in NORM state.

(0)
Leader 
 declares that G is not searchable if  and SEARCH terminates.

If , 
 computes π, 
 for  and sends 
 to each searcher 
.

(1)
If , 
 immediately terminates SEARCH.

If , 
 executes local schedule 
 by repeating (1.1) and (1.2) for 
, where 
 is the length of 
.

(1.1)
SYNCHRONIZE: If 
 is in JUMP state, it goes to (1.2).

If 
 is in NORM state, it waits until 
 holds and goes to (1.2), where NM is the set of searchers with state NORM staying in the same node with 
, including 
. Note that NM is easily recognizable, since the members automatically exchange information by definition, whenever the members change.

(1.2)
MOVE: If 
, then 
 updates its state to JUMP and takes trajectory 
 (given by a sequence of offsets) to v. Finally, 
 updates its state to NORM, as soon as it reaches v.

If 
, then 
 updates its state to NORM and moves to a neighbor node v of u.

Theorem 7

If π is a monotone search schedule of G for  pebbles, algorithm SEARCH is a search schedule of G using  searchers, under the dark cave model, provided that all searchers are in node 
 when SEARCH is invoked.

Proof

Any execution of the searchers 
, each executing 
, can be described as an ASYNC(
), which is a search schedule for G by Property 5. □

We finally present an online graph search algorithm OLS for k searchers:

(1)
All searchers execute GATHER. The searchers then gather at a node 
, elect the leader 
, and recognize the number k of searchers.

(2)
Searchers 
 and 
 execute TOPOLOGY and return to 
. Then 
 recognizes G, all searchers share G.

(3)
All searchers execute SEARCH. In SEARCH, 
 computes . If , they terminate SEARCH.

If , 
 computes a monotone search schedule π for  pebbles, produces, for each searcher 
, the local search schedule 
 by modifying π, and sends it to 
. Finally, all searchers 
 execute their local search schedules to asynchronously simulate π.

By Theorem 5, Theorem 6, Theorem 7, we have the following corollary.

Corollary 2

For any graph G such that , OLS is an online search algorithm for  searchers under the dark cave model.

4.6. OLSEARCH
If G is a path graph and , a single searcher on G executing OLS cannot successfully search G, since MEET does not terminate. In this subsection, we present an algorithm 
⁎
 as a modification of MEET. Algorithms 
⁎
 and MEET are exactly the same, except that 
⁎
 can successfully search a path graph by a single searcher. OLSEARCH invokes 
⁎
 instead of MEET (in GATHER).

If a searcher s has reached two different leaves ℓ and 
 before visiting a node with degree at least three, s can terminate OLSEARCH and declare the end of search, since G is a path graph and it has been successfully searched. However, if we tried to extend MEET by simply adding a second leaf detection algorithm in front of MEET, the resulting algorithm 
⁎
 might not work as a correct meeting algorithm when at least two searchers are in G, since the trajectory that s takes in 
⁎
 might be different from the one in MEET. In order to avoid this problem, we let s traverse the trajectory that MEET exactly instructs, and “embed” a second leaf detection procedure in this trajectory. The procedure we embed is straightforward: After reaching the first leaf ℓ, whenever a node v is reached, s keeps the direction of this move, either it is leaving from ℓ or approaching to ℓ. When s reaches a leaf 
 when it is leaving from ℓ (before reaching a node with degree at least three), then 
 is the second leaf.

Specifically, in 
⁎
, we introduce a new local variables , whose initial value is − (resp. ⊥, ⊤), if the degree of 
 is one (resp. two, at least three), where 
 is the initial node of s.

That  means that s has not visited the first leaf ℓ. Whenever s reaches a node with degree at least three, regardless of the current value of θ, it is updated to ⊤, which means that θ will be ignored in the rest of 
⁎
; it is identical with MEET in the rest of its execution. When s reaches the first leaf ℓ, θ is updated to −, and  holds in what follows, as long as s does not reach a node with degree at least three. Here  (resp. −) means that s is leaving from (resp. approaching to) ℓ. If s reaches a leaf 
 from a node with , then θ is updated to E, which means the end of search, since 
 is the second leaf. Thus s declares the end of search, successfully terminating 
⁎
 (and hence OLSEARCH) when θ becomes E.

Specifically, in 
⁎
, s follows the trajectory that MEET instructs, and updates θ whenever it reaches a node, in addition to the original operations specified in MEET. Suppose that s moves from a node u to another node v through the p-th port clockwise from the port through which s reached u. Recall that  means that s takes a round trip between v and u; s moved from v to u, and then moves back to v. Algorithm SECOND_LEAF defines how s updates the value θ when it reaches v: Let 
 be the updated value.

(1)
, if  or the degree of v is at least three.

(2)
, if  and v is a leaf,  and , or ,  and the degree of v is at most two.

(3)
, if  and , or ,  and the degree of v is exactly two.

(4)
, if ,  and v is a leaf.

Then the next property obviously holds, since the trajectory of MEET is integral and by algorithm SECOND_LEAF.

Property 6

1.
Searcher s executing 
⁎
 eventually reaches a node v with .

2.
If s reaches a node  with , then G is a path graph and it has been searched.

3.
If s reaches a node  with , then 
⁎
 works as if it were MEET.

Let OLSEARCH be the algorithm which is constructed from OLS by invoking 
⁎
, instead of MEET, in GATHER.

Theorem 8

For any graph G, OLSEARCH is an online graph search algorithm for  searchers on G.

Now, we can conclude that Theorem 1 holds by Theorem 8.

5. Conclusions
We have investigated the problem of searching an unknown graph for a mobile evader by a group of mobile searchers under a weaker online and distributed setting called the dark cave model, which directly models the Parsons's dark cave. The graph, which models the cave, is completely anonymous and ports are not labeled. Furthermore, nodes have no whiteboards for communication. Instead, we assume that searchers can exchange information wherever they meet. Our algorithm OLSEARCH searches any graph G by  searchers without requiring any a priori information on G, where  is the edge search number of G, and hence OLSEARCH is obviously optimal in terms of the number of searchers.

A problem left unsolved is the graph search problem by anonymous searchers under the dark cave model. Provided unique identifiers, we have shown that the graph search problem is solvable if the meeting problem is solvable. It seems to be interesting if this theorem holds for anonymous searchers.

In this paper, we have not discussed the time complexity. As usual, a trade-off between the time and the space complexities is another interesting research topic.