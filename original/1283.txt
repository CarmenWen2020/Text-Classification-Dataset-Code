Abstract
Wildcard identity-based encryption (WIBE) is a generalization of hierarchical identity-based encryption (HIBE) where a sender can simultaneously encrypt messages to a group of users matching a certain pattern, defined as a sequence of identities and wildcards. This special feature makes WIBE a promising solution to distributed IoT data security. In this paper, we propose the first construction of a post-quantum WIBE scheme. Our scheme is proven secure in the standard model, and it enjoys the security in the future quantum computer era.

Previous
Next 
Keywords
Identity-based encryption

Wildcard

Standard model

Lattices

Learning with errors

1. Introduction
The Internet of Things (IoT) has emerged as a set of technologies from Wireless Sensors Networks (WSN) to Radio Frequency Identification (RFID), that provide the ability to measure, communicate and act all over the world. The key idea of the IoT is to obtain information about our environment to understand and control and act on it [13]. However, the current IoT paradigm with traditional cloud-based architecture is not scaled for the future, and requires all data to be transferred to a central point for analysis and action. One solution to overcome these hurdles is to bring the concept of decentralization to the IoT space to build distributed IoT [19] which has received more and more attention in recent years [12], [20], [23], [31]. In such distributed systems, messages are often to be securely delivered to a specific group of devices or users for communication and management [21]. In regard to IoT data security, public key encryption is not suitable since it is very inefficient: the message is encrypted as many as the number of receivers. In addition, public key encryption system also requires a public key infrastructure (PKI) which increases the communication and storage costs. It is then necessary to consider a type of encryption which is able to send message to a group at once in the IoT system [22].

Identity-based encryption (IBE) provides a public-key encryption mechanism where a user's public key is an arbitrary string such as email address or a telephone number, which hence helps reduce the use of a PKI. The concept of IBE was introduced by Shamir [27]. In 2001, Boneh and Franklin [9] proposed the first practical identity-based encryption (IBE) scheme based on bilinear map. In an IBE system, the private key of a user can only be generated by a Private-key Generator (PKG) who has knowledge of a master secret key. Hierarchical IBE (HIBE) is an extension of IBE in which each level can issue secret keys for identities of the next level, hence HIBE can be utilized in many large networks, to reduce the workload of PKG for private key generation, identity verification and secure private key transmissions. The idea of HIBE was originated from the work of Gentry and Silverberg [18]. Since then, there have been many efficient constructions of (H)IBE, ranging from classical setting [7], [8], [30] to post-quantum setting [3], [4], [11].

One of the main applications proposed for IBE is that of email encryption, in which given an email address, one can encrypt a message to the owner of the email address. Motivated by the fact that many email addresses correspond to groups of users rather than single individuals, as in the case of aforementioned distributed IoT system, Abdalla et al. [2], [1] introduced the notion of wildcarded identity-based encryption (WIBE), a generalization of HIBE, which allows the encrypter to replace any component of the recipient identity with a wildcard so that identities matching the pattern can decrypt. For example, by encrypting to pattern *@.cs.university.edu, any user from computer science department of univ can decrypt to achieve the message. Abdalla in [2], [1] also proposed three different WIBE constructions by extending the previous HIBE schemes in [7], [8], [30]; however, all constructions suffer form large ciphertext. In 2018, Kim et al. [21], based on the work of Abdalla et al. [2], [1], by extending the BBG-HIBE scheme [8], described a WIBE scheme called Scalable wildcarded identity-based encryption (SWIBE) that generates a constant size ciphertext regardless of the depth of the identities with fast encryption. However, all of those WIBE schemes above are constructed on the structure of bilinear groups, and hence insecure in the quantum-computer era [28].

According to the best of our knowledge, there has been no specific lattice-based WIBE instantiation. In fact, Abdalla et al. [2], [1] presented a generic construction of WIBE from any HIBE scheme. Hence it is straightforward to obtain a lattice-based WIBE construction by applying the transformation to one of the existing lattice-based HIBE schemes [3], [4], [11]. However, the resulting WIBE scheme has a secret key size that is exponential in the depth of the hierarchy tree; see [1, Section 3.3] for the detail. It still remains an open question of how to yield a direct construction of WIBE from lattice assumptions.

Our contribution: In this paper, we present, for the first time, a direct construction of a WIBE scheme based on lattice. Our scheme is proven secure in the standard model. In fact, our design is inspired from the direct constructions of WIBE from HIBE schemes in [7], [8], [30] by Abdalla et al. [1]. In such constructions, the authors cleverly modified the ciphertext components corresponding to the wildcards in such a way that decryption is still possible for users with matching pattern while keeping the public key and secret key remain the same with the trade-off of bigger ciphertext; see [1, Section 5] for more detail. Our design follows the same route and starts from the efficient lattice-based HIBE scheme by Agrawal et al. [3] and two basis delegation algorithms in [4]. However, it is not straightforward to adapt their techniques into our design. The reason is that it is error-free in pairing-based settings while there exist errors in lattice encryption, which makes it challenging in moving from a pairing-based construction to a lattice-based one. In order to overcome this, we need to add to the ciphertext one extra element in 
 compared to the HIBE scheme [3], independently of the number of wildcards in the encrypting pattern, as opposed to three direction constructions by Abdalla et al. [1] whose ciphertext size is increased linearly in the number of corresponding pattern.

Specifically, our lattice-based WIBE construction has the following characteristics:

–
It reserves the idea of the HIBE scheme of Agrawal et al. in [3], and hence is efficient.

–
The ciphertext is independent of the number of wildcards in the corresponding pattern. The ciphertext in our WIBE scheme is one 
-element larger compared to the ciphertext in the HIBE scheme of Agrawal et al. [3].

–
It offers selective CPA security in the standard model. The CCA security can be obtained by using the generic transformation from [10].

Table 1 gives a comparison of our scheme with WIBE schemes that are constructed on the structure of bilinear groups. Table 2 provides a comparison between our scheme with the efficient lattice-based HIBE schemes.


Table 1. Comparison of WIBE schemes.

Assumption	ROM
BB-WIBE [2]	2d + 3	d + 1	2d + 2	BDH	No
BBG-WIBE [2]	d + 4	d + 2	d + 3	L-BHDI	Yes
Waters-WIBE [2]	(n + 1)d + 3	d + 1	(n + 1)d + 2	BDDH	No
SWIBE [21]	d + 4	2d + 3	4	L-BDHE	Yes

This work	d + 2	1	d + 3	LWE	No
Here d is the maximal hierarchy depth, n is the bit length of an identity string;  are the size of the public key, secret key and ciphertext size, respectively. Size of [2] and [21] indicates group elements while in this work it represents the number of needed 
 matrices in ,  and 
 vectors in .


Table 2. Comparison of HIBE and our WIBE scheme.

Param. 1/α			Wildcard use	ROM
HIBE [11]	
No	No
HIBE [3]	
No	No

This work	
Yes	No
Here λ is the security parameter. The parameter α is related to the LWE problem.  is the number of 
 matrices;  is the number of 
 vectors.

2. Preliminaries
2.1. Wildcarded identity-based encryption (WIBE)
In this section, we will recall some of the recent results about the concept of Wildcarded Identity-based Encryption (WIBE) and its security model in a more general setting, following [3], [2].

WIBE, a generalization of hierarchical identity-based encryption (HIBE) scheme, allows the sender to simultaneously encrypt messages to a group of users whose identities match a certain pattern. A pattern is defined by a vector 
⁎
⁎
, where ⁎ - a wildcard symbol - can be replaced by any identity string. We say that identity 
 matches , denoted 
⁎
, if and only if 
 and for all 
 we have that 
 or 
⁎. For a pattern , we denote  is the set of all wildcard indices in , i.e., 
⁎.

Definition 1 WIBE

A WIBE scheme consists of the following four algorithms:

–
: On input a security parameter λ and the hierarchical depth d, it outputs the public parameters  and a master key .

–
 On input public parameters  and a secret key corresponding to an identity at depth , it outputs the secret key 
 for the identity 
 at depth l ().

–
: On input the public parameters , a pattern  and a message b, it outputs a ciphertext .

–
: On input the public parameters , a ciphertext  for pattern , a secret key 
. Any user in possession of the secret key for an identity  that matches  can decrypt using 
 and the algorithm outputs a message b.

Note that, being of the highest privilege, the master secret key  can be used to generate the secret key of any identity in the identity space. Moreover, it is also required that the secret key of an identity 
 generated by a secret key 
 must have the same distribution as the one generated by the master secret key .

Correctness. We will use the master secret key  in the  algorithm in the correctness and security model for the generic case.
We say that a WIBE scheme is correct if for all key pairs  output by , all , all patterns 
⁎
⁎
, all identities 
⁎
 and all messages , it holds that
 
 

Security model of WIBE. For the security model, we defined WIBE selective security similar to HIBE in [3], using a game in which the challenge ciphertext is indistinguishable from a random element in the ciphertext space. An adversary is allowed to choose an arbitrary pattern to attack and is not allowed to query the key derivation oracle for any identity matching with the challenge pattern. The  security model is defined through the following game, played between an adversary  and a challenger :

–
Init: The adversary  is given the maximum depth of the hierarchy d and decides a target pattern 
⁎
⁎
⁎
, .

–
Setup: The challenger  runs  to obtain  and gives the adversary  the resulting public parameters .

–
Phase 1:  make queries polynomial many times adaptively to a key derivation oracle 
 that on input of an identity 
 returns the output of .

–
Challenge:  chooses message  and pass to , who then selects a random bit . If ,  runs 
⁎
⁎
; otherwise it chooses a random ciphertext 
⁎
 in the ciphertext space and sends 
⁎
 to .

–
Phase 2:  continues to issue additional key derivation queries and  responds as in Phase 1.

–
Guess:  outputs its guess 
.

The adversary  wins the above game if 
 and the advantage of  is defined as
 

The adaptive security game is defined analogously to the above  game except that the Init phase is removed from the game and allowing the adversary to wait until the Challenge phase to announce the pattern 
⁎
 it wishes to attack. In Phase 1, the adversary is allowed to make arbitrary secret key queries before choosing the target pattern 
⁎
. The only restriction is that any matching  of 
⁎
 is not one of the identity queries which have been made in Phase 1. The resulting security notion of the game above is denoted .

2.2. Lattices
Lattices are discrete subgroups of 
. Specially, a lattice Λ in 
 with basis 
, where each 
 is written in column form, is defined as
 
 We call n the rank of Λ and if  we say that Λ is a full rank lattice. In this paper, we mainly consider full rank lattices containing 
, called q-ary lattices, defined as the following, for a given matrix 
 and 
 Note that if 
 then 
.

Let 
 be a set of vectors in 
. We denote by 
 the maximum 
 length of the vectors in S. We also denote 
 the Gram-Schmidt orthogonalization of the vectors 
 in that order. We refer to 
 the Gram-Schmidt norm of S.

The following theorem proposes how to sample a uniform matrix 
 together with an associated basis 
 of 
 with low Gram-Schmidt norm. We refer to [5], [6] for details.

Theorem 2

Let  be odd and . There is a probabilistic polynomial-time algorithm  that outputs a pair 
 such that A is statistically close to a uniform matrix in 
 and S is a basis for 
 satisfying
 with all but negligible probability in n.

Gaussian distribution. We will use the following definitions of the discrete Gaussian distributions.

Definition 3

Let 
 be a lattice. For a vector 
 and a positive parameter , define:
 
 
 The discrete Gaussian distribution over Λ with center c and parameter σ is
 

For convenience, we will denote by 
 and 
 for 
 and 
 respectively. When  we will write ρ instead of 
.
It is well-known that for a vector x sampled in 
, one has that  with overwhelming probability.

Definition 4

For 
, let 
 denote the distribution on matrices in 
 defined as 
 conditioned on the resulting matrix being 
-invertible.

Definition 5

For each , we denote 
 
 the distribution of the random variable  where X is a normal random variable with mean 0 and standard deviation .

The following lemma about the distribution 
 
 will be needed in showing that decryption works correctly. The proof is implicit in [16, Lemma 8.2].
Lemma 6

Let e be some vector in 
 and let 
 
. Then the quantity 
 treated as an integer in  satisfies
 with all but negligible probability in m.

Peikert [25] shows how to construct a basis for 
 from a basis for 
.

Theorem 7

For , let 
 be a matrix in 
 and let 
. Let 
 be a basis of 
. There is a deterministic polynomial time algorithm  that output a basis T for 
 such that 
.

Using this algorithm, with the matrix 
 of the form
⁎
 and having a basis 
 for 
 for some , we can easily generate a basis T for 
 where l is the hierarchy depth of .

We recall in the following theorem some useful results. The first two properties follow from [24, Lemma 4.4] and [16], respectively. The next two algorithms for generating short bases of lattices are from [11] and formulated in the work of Agrawal et al. [3, Theorem 17] and [3, Theorem 19].

Theorem 8

Let  and let  be matrices in 
 with  and . Let 
 be bases for 
 and 
 respectively. Then for 
:

1.
For 
, we have 
.

2.
For 
, there is a PPT algorithm 
 that returns 
 sampled from a distribution statistically close to 
, whenever 
 is not empty.

3.
Let M be a matrix in 
 and 
. Then there exists a PPT algorithm 
 that outputs a vector 
 distributed statistically close to 
 where 
. In particular 
, i.e., 
. In addition, if A has rank n then there is a PPT algorithm 
 that outputs a basis of 
.

4.
Let R be a matrix in 
 and let 
. Let 
. Then for 
, there exists a PPT algorithm 
 that outputs a vector 
 distributed statistically close to 
. In particular 
, i.e., 
. In addition, if A has rank n then there is a PPT algorithm 
 that outputs a basis of 
.

Note that when R is a random matrix in 
 then 
 with overwhelming probability (cf. [3, Lemma 15]).

Basis Delegation. The following theorem recalls a basis delegation algorithm without dimension increase from [4, Theorem 3]. It will be used to respond secret key queries in security game.

Theorem 9

Let 
. Let A be a rank n matrix in 
 and 
 is a basis for 
. Let R be a matrix sampled from 
 and 
. Then there exits a PPT algorithm 
 that outputs a basis 
 of 
 where 
.

The security of our construction reduces to the LWE (Learning With Errors) problem introduced by Regev [26].

Definition 10 LWE problem

Consider a prime q, a positive integer n, and a distribution χ over 
. An 
-LWE problem instance consists of access to an unspecified challenge oracle , being either a noisy pseudorandom sampler 
 associated with a secret 
, or a truly random sampler 
 whose behaviors are as follows:

:
samples of the form 
 where 
 is a uniform secret key, 
 is uniform and 
 is a noise withdrawn from χ.

:
samples are uniform pairs in 
.

The 
-LWE problem allows responds queries to the challenge oracle . We say that an algorithm  decides the 
-LWE problem if
 is non-negligible for a random 
.
Regev [26] showed that (see Theorem 11 below) when χ is a distribution 
 
 with , the LWE problem is hard.

Theorem 11

If there exists an efficient, possibly quantum, algorithm for deciding the 
 
-LWE problem for  then there is an efficient quantum algorithm for approximating the SIVP and GapSVP problems, to within 
 factors in the 
 norm, in the worst case.

The theorem implies, for  is a polynomial in n, the LWE problem is as hard as approximating the SIVP and GapSVP problems in lattices of dimension n to within polynomial (in n) factors.

We will need the following lemma for the LWE reduction in the security proof of our WIBE. It follows from a generalization of the left over hash lemma [14], the proof is implicit in [3, Lemma 13].

Lemma 12

Suppose that 
 and that  is prime. Let R be an  matrix chosen uniformly in 
 where  is polynomial in n. Let A and B be matrices chosen uniformly in 
 and 
 respectively. Then, for all vectors w in 
, the distribution 
 is statistically close to the distribution 
.

3. WIBE construction over integer lattices
In this section, we describe the proposed Wildcarded Identity-based Encryption (WIBE) scheme. We follow [4, Section 4] to build a matrix 
 using a function H described below.

For an identity 
⁎
 () at level l, we assume that there exists a hash function H that outputs matrices in 
: 
⁎
  in which the resulting matrix 
 is distributed as 
 over the choice of the function H.

Our WIBE scheme consists of the following algorithms:

Setup()
On input a security parameter λ and a maximum hierarchy depth d, set the parameters 
 as specified in section 3.1

1.
Invoke algorithm  to generate a uniformly random -matrix 
 together with a short basis 
 for 
 such that 
.

2.
Select  uniformly random  matrices 
.

3.
Select a uniformly random vector 
.

4.
Output the public parameters and the master key

Derive(
)
On input public parameters  and a secret key corresponding to an identity 
 at depth , with 
.

1.
Without loss of generality, 
 is a short basis for 
 and 
, we can construct 
 by running:
 where 
.

2.
Output 
.

Encrypt()
On input the public parameters , a pattern 
 and a message :

1.
Choose a uniformly random vector 
.

2.
Choose a uniformly random  matrix 
 and a uniformly random  matrix 
.

3.
Choose noise vectors 
 
 and 
 
, set 
.

Parse 
.

4.
Compute
 
 For  do: 
 

5.
The ciphertext is

Decrypt(
)
On input public parameters , a secret key 
 where 
 is a matching identity of 
 and a ciphertext 
, do the followings:

1.
Set 
, then we have 

2.
Sample 
 from
 Then 
 and 
.

Let 
.

3.
For  do: 
 

4.
Compute 
.

5.
Compare w and 
 
. If they are close, i.e., if 
 
 
 in  output 1 and otherwise output 0.

This completes the description of the system. The remainder of this section will be devoted to the calculation of parameters and the security proof.

3.1. Parameters and correctness
When the cryptosystem is operated as specified, during decryption of a ciphertext encrypted to a pattern  at level l we have
 
 
  
 

Lemma 13

The norm of the error term is bounded by

Proof

According to [3, Lemma 32], we have
 
 Since 
, 
 and 
 for all , by Lemma 6 we have
 
 Then the errors term is bounded by 
 which proves the lemma. □

We follow [3, Section 8.3] with a slight change for choosing parameters for our scheme. Now for the system to work correctly we need to ensure:
–
that the  can operate, i.e., 

–
the error term in decryption is less than  with high probability, i.e., 
 and 
,

–
that the  can operate, i.e., ,

–
that σ is large enough for  and , i.e.,

–
that Regev's reduction applies, i.e., 
.

To satisfy all of the above requirements, we set the parameters 
 as follows, taking n to be the security parameter:(1)
 and round up m to the nearest larger integer and q to the nearest larger prime with the assumption that δ is such that 
.

3.2. Security analysis
The following theorem addresses that our proposed WIBE scheme is INDr-sWID-CPA secure.

Theorem 14

The WIBE scheme with parameters 
 as in (1) is  secure for depth d provided that the hardness of 
-LWE assumption holds.

Proof

We will show that our lattice-based WIBE scheme is secure under a selective identity attack ().

Let  be a PPT adversary that attacks the WIBE scheme. We will then construct a simulator  that solves the LWE problem using .

We will proceed the proof via a sequence of games where the first game is identical to the original  game and the adversary has no advantage in winning the last game.

Game 0.
This is the original  game between the attacker  against our scheme and an  challenger.

Game 1.
Game 1 is analogous to Game 0 except that we slightly change the way that the challenger generates 
 in the public parameters. Let 
⁎
⁎
⁎
 be the pattern with w wildcards that  intends to attack. At the beginning of the game, instead of choosing d random matrices in 
 as in Game 0, the Game 1 challenger  choose  random matrices 
⁎
⁎
 and 
 in 
 at Setup phase and constructs 
 as 
⁎
⁎
⁎
⁎
⁎
   sets 
 
⁎
⁎
⁎
 and use 
 
⁎
 and 
 when generating the challenge ciphertext in the Challenge phase. The remainder of the game is unchanged.

Using [3, Lemma 13], we can prove that the matrices 
 are statistically close to uniform. Hence, in the adversary's point of view, 
 in Game 0 and Game 1 are indistinguishable.

Game 2.
In this game, we change the way that 
 and B in  are chosen. Namely, we generate 
 as a uniformly random matrix in 
 and use algorithm  to generate a uniformly random matrix B together with its trapdoor 
 for 
. The construction of 
 remains as in Game 1: 
⁎
⁎
⁎
⁎
⁎
  The simulator  responds to secret key queries using the trapdoor 
. For an identity 
 which does not match 
⁎
,  responds by producing a short basis for 
 where
 
⁎
 where 
 
⁎
 and 
 are defined as
 
⁎
⁎
⁎
⁎
 for all 
⁎
 and 
⁎
.

Then  generates secret keys using trapdoor 
 as follows:

–
Let  be the shallowest level at which 
⁎
 then use algorithm 
 with 
 to generate a basis 
 for 
, then 
.

–
Use algorithm  to extend the basis 
 for 
 to a basis T for 
.

–
Run
 
⁎

Since the public parameters and responses to the secret key queries of Game 1 and Game 2 are statistically close in the adversary's point of view, the adversary's advantage against Game 2 will be the same as Game 1.
Game 3.
In this game, the challenge ciphertext 
⁎
 is now chosen uniformly random in 
.

We now show that Game 3 and Game 2 are computationally indistinguishable for  by constructing reduction from the LWE problem.

Reduction from LWE. Recall that an LWE problem instance is provided as a sampling oracle . Sampling oracle  can be either truly random 
 or a noisy pseudo-random 
 for some secret random 
. Suppose now  has non-negligible advantage in distinguishing Game 2 and Game 3, we use  to construct the simulator  which can solve the LWE problem as follows:
1.
:  requests from oracle  and receives  samples 
 as an instance of the decisional LWE problem.

2.
: Let  choose 
⁎
⁎
⁎
 as target pattern.

3.
:  constructs the system's public parameters  as follows:

–
Assemble the random matrix 
 from m previously LWE samples by letting the i-th column of 
 be the n-vector 
 for all .

–
The LWE sample 
 is the public random n-vector.

–
The remainder of the public parameters, 
 and B, are constructed as in Game 2 using 
⁎
 and 
⁎
.

4.
:

–
 answers each secret key extraction query as in Game 2.

5.
:  chooses 
⁎
 and sends 
⁎
 to , a challenge ciphertext for the target pattern 
⁎
⁎
⁎
 is created as follows:

–
Let 
 be entries from the LWE instance. Set 
⁎
 
.

–
Let
⁎
⁎
 
⁎
⁎
⁎
⁎
 where 
 is chosen uniformly random in 
.

–
Let 
 
⁎
⁎
⁎
 and set 
⁎
 
⁎
⁎
⁎
⁎
.

–
Choose a random bit 
.

•
If ,  sends 
⁎
⁎
⁎
⁎
⁎
⁎
 to the adversary .

•
If ,  chooses a random 
 and sends  to the adversary .

When LWE oracle is pseudorandom (i.e. 
 then 
⁎
 
⁎
 and 
⁎
 for some random noise vector 
 distributed as 
 
. Therefore, 
⁎
 satisfies
⁎
⁎
⁎
 
⁎
 Set 
 
⁎
, then
⁎
⁎
⁎
 and thus 
⁎
⁎
⁎
⁎
⁎
⁎
⁎
  One can easily see that
⁎
 Since B is a uniformly random matrix in 
, by Lemma 12 the distribution 
 is statistically close to the distribution 
. It follows that in the adversary's view, 
⁎
 is just as the 
 part of the challenge ciphertext in Game 2. Therefore, 
⁎
 is a valid challenge ciphertext that distributes exactly as in Game 2.

When LWE oracle is random oracle (i.e. 
), we have that 
 is uniformly random in 
 and 
⁎
 is uniformly random in 
. Then 
 is uniform and independent in 
 by the standard left over hash lemma ([29, Theorem 8.38]). Therefore, the challenge ciphertext 
⁎
 is always uniform in 
, as in Game 3.

6.
: The adversary  is again allowed to make additional secret key derivation queries in Phase 2 before guessing if it is interacting with Game 2 or Game 3 challenger.  then outputs 's guess as the answer to the LWE challenge it is trying to solve.

We already claimed that when 
 then the adversary's view is as in Game 2. When 
, the adversary's view is as in Game 3. Hence, 's advantage in solving LWE is the same as 's advantage in distinguishing between Game 2 and Game 3, as required. This completes the description of the simulator  which is the desired conclusion. □
4. Implementation
In this section, we first explain how to select parameters appropriately for the proposed WIBE scheme and give some sets of suggested parameters. Then we describe the platform information of our implementation and provide some experimental data.

4.1. Parameter choices
We first choose appropriate parameters for the trapdoor generation and sampling algorithms according to [6] and [11] to make them work well. Then we choose the maximum level of identity and other parameters which determine the discrete Gaussian distribution and the error distribution respectively. As in Table 3, we provide 4 parameter sets for our WIBE scheme.


Table 3. WIBE Scheme Parameters.

Para.	Set I	Set II	Set III	Set IV
n	5	5	7	7
q	5	11	7	11
m	71	105	119	147
l	1	1	1	1
0.917214309068898	0.426557814090872	0.785928946018455	0.521045692920835
18.3410510411930	27.7593222310244	22.7682286251184	30.1807540286394
σR	15.2800548646378	18.7086982529750	19.9609398370902	22.1949350394383
|MK|	15123	44100	42483	86436
60492	176400	169932	345744
|PP|	3210	6320	7518	12376
|CT|	642	1264	1074	1768
Now we give a detailed explanation about parameter choices. n is a positive integer which denotes the dimension of the q-ary lattice 
. q denotes the modulus which is chosen to be a prime. m denotes the rank of the q-ary lattice 
. To run the  algorithm, we have to choose m such that  following the second construction of trapdoor generation algorithm in [6], where δ could be any fixed constant which is larger than 0. In this paper, we set a small δ as 1/3 to reduce the computation overhead and keep . l denotes the maximum identity level which influences the computation overhead and running time. Once we choose a large value for l, we need to enlarge relevant matrices and call the sample algorithms much more times. 
 denotes the Gaussian parameter used in error distribution which controls the hardness of LWE assumption. To make Regev's reduction work, we should keep 
. 
 denotes the Gaussian parameter used in the  and  algorithms. 
 denotes the Gaussian parameter which determines the distribution of hash function . In general, we set it as 
 following [4].

Next, we explain how to compute the master key, secret key, public parameter and ciphertext sizes. We take the concrete parameters from Set I listed in Table 3 as an example. The master key  is in 
 and it is a basis of the q-ary lattice 
, where 
, so the size of it could be computed as at most 
 bit. The secret key 
 is in 
 and it is the basis of 
, where 
, so the size of 
 could be computed as at most 
 bit. The public parameter  consists of matrices 
 and a vector 
, so the size of  could be computed as  bit. The ciphertext  consists of a number 
 and vectors 
, so the size of  could be computed as  bit.

4.2. Experimental results
We implement the proposed WIBE scheme by using SageMath 9.41 which is based on Python 3.9.7. We ran our experiments on macOS 11.2 with Apple M1 and 16GB RAM. For each parameter set in Table 3, we run 3 times and report the average time of setup, derive, encryption and decryption algorithms in Fig. 1.

Fig. 1
Download : Download high-res image (217KB)
Download : Download full-size image
Fig. 1. Comparison of running time in experiment.

As shown in Fig. 1, the derive algorithm consumes much more time than other algorithms. With larger parameters, the time of derive and decryption algorithm goes larger. The reason behind is that it runs the Gaussian sampling algorithm over lattices many times in the  algorithm to achieve lattice basis delegation. Similarly, the  algorithm in decryption also calls the Gaussian sampling algorithm for some times which take much time. We implement the Gaussian sampling algorithm proposed in [17], which is not quite efficient. Therefore, our implementation is not optimal. The experimental results could be better if we use more efficient Gaussian sampling algorithm over lattices like [15].

5. Conclusion
In this paper, we propose the first lattice-based wildcard identity-based encryption (WIBE) and prove that our scheme is selective secure in the standard model based on the decisional LWE assumption. The scheme enjoys the efficiency as the HIBE scheme by Agrawal et al. [3]. Designing a WIBE scheme that is adaptive secure and scalable (as in [21]) is an interesting direction, which we leave as a future work.