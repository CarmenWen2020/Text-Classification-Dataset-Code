Abstract
In this paper, we discuss the copy complexity of Horn formulas with respect to unit resolution. A Horn formula is a boolean formula in conjunctive normal form (CNF) with at most one positive literal per clause. Horn formulas find applications in a number of domains, such as program verification (abstract interpretation) and logic programming (answer set programming). Quantified Horn clauses are used extensively in temporal verification of universal properties. Resolution is one of the oldest proof systems (refutation systems) for the boolean satisfiability problem (SAT), when the input is presented in conjunctive normal form (CNF). It is both sound and complete, although inefficient, when compared to other stronger proof systems for boolean formulas. Despite its inefficiency, the simple nature of resolution makes it an integral part of several theorem provers. Unit resolution is a restricted form of resolution in which each resolution step needs to use a clause with only one literal (unit literal clause). While not complete for general CNF formulas, unit resolution is complete for Horn formulas. Read-once resolution is a form of resolution in which each clause (input or derived) may be used in at most one resolution step. As with unit resolution, read-once resolution is incomplete in general and complete for Horn clauses. This paper focuses on a combination of unit resolution and read-once resolution called unit read-once resolution. Unit read-once resolution is incomplete for Horn clauses. In this paper, we study the copy complexity problem in Horn formulas with respect to unit read-once resolution. Briefly, the copy complexity of a formula with respect to unit read-once resolution, is the smallest number k, such that replicating each clause k times guarantees the existence of a unit read-once resolution refutation (UROR). This paper focuses on two problems related to the copy complexity of Horn formulas with respect to unit read-once resolution. We first relate the copy complexity of Horn formulas with respect to unit read-once resolution to the copy complexity of the corresponding Horn constraint system with respect to the addition rule. We also examine a form of copy complexity in which we permit replication of derived clauses, in addition to the input clauses. Finally, we provide a polynomial time algorithm for the problem of checking if a 2-CNF formula has a UROR.

Keywords
Resolution
Read-once
Copy complexity
Proof system
Unit read-once

1. Introduction
This paper is concerned with the analysis of a new proof system (refutation system) called unit read-once resolution for a well-studied class of formulas, viz., Horn formulas. A Horn formula is a boolean formula in conjunctive normal form (CNF) with at most one positive literal per clause [8]. Horn clausal systems have been used to model problems in a wide variety of domains, viz., deductive databases [30], abstract interpretation [3], logic programming [1] and machine learning [2].

Resolution is a well-known refutation system for Boolean formulas in CNF [34]. Over the years, a number of different resolution schemes have been studied in the literature [33]. Some of these schemes are complete, while others are not. This paper focuses on a type of resolution called unit read-once resolution. Unit resolution is a restricted form of resolution in which each resolution step needs to use a clause with only one literal (unit clause). Likewise, in read-once resolution, each clause (input or derived) can be part of at most one resolution step. Neither of these schemes is complete for CNF formulas in general. However, both unit resolution and read-once resolution are complete for Horn formulas. On the other hand, unit read-once resolution is incomplete for Horn formulas as well. It was shown in [24] that the problem of finding a unit read-once resolution refutation of a Horn formula is NP-complete. In this paper, we provide an alternative proof of NP-completeness for this problem.

The primary focus of this paper is copy complexity with respect to unit read-once resolution. The notion of copy complexity is closely related to the concept of clause duplication described in [16]. A CNF formula Φ has copy complexity k, with respect to read-once resolution, if the formula 
 formed by taking k copies of each clause 
 has a resolution refutation that uses each clause at most once. i.e., a read-once resolution refutation. This paper deals exclusively with Horn formulas. Note that Horn formulas always have read-once resolution refutations [8], but do not always have unit read-once resolution refutations (URORs); for instance, see Example 12. Thus, we are interested in the problem of determining the copy complexity of an arbitrary Horn formula, with respect to unit read-once resolution.

Additionally, we examine a variant of copy complexity which allows for copies of derived clauses in addition to copies of clauses from the original CNF formula. Associated with a Horn clausal formula is a Horn constraint system (see Section 6). We relate the copy complexity of a Horn formula (with respect to unit read-once resolution) to the copy complexity of the corresponding Horn constraint system (under the addition rule). Finally, we show that the problem of determining if a 2-CNF formula has a unit read-once resolution refutation can be solved in polynomial time. This is in contrast to the result from [21] which showed that the problem of determining if a 2-CNF formula has a read-once resolution (not necessarily a unit read-once resolution) refutation is NP-complete.

The principal contributions of this paper are as follows:

1.
An alternate proof that the problem of finding a unit read-once resolution refutation of a Horn formula is NP-complete (see Section 5).

2.
Establishing the relationship between copy complexity of Horn formulas with respect to unit read-once resolution and the copy complexity of the corresponding Horn constraint system (see Section 6).

3.
Establishing that the copy complexity of Horn formulas with respect to unit read-once resolution is  when copies of derived clauses are allowed (see Section 7).

4.
An algorithm that can determine if a 2-CNF formula with m clauses over n variables has a UROR in 
 time (see Section 8).

5.
An alternate algorithm that can determine if a 2-Horn formula with m clauses over n variables has a UROR in 
 time (see Section 8.1).

An extended abstract of this paper was presented in [40]. This paper expands on the work in [40] by including additional examples and the algorithm for 2-Horn formulas.

The rest of the paper is organized as follows. Section 2 details the problems under consideration. The motivation for our work is described in Section 3. Related approaches in the literature are described in Section 4. In Section 5, we examine the UROR problem for Horn formulas. Section 6 relates the copy complexity of unit resolution in Horn formulas to the copy complexity of the corresponding Horn constraint system. In Section 7, we examine the copy complexity of Horn formulas when copies of derived clauses are permitted. Section 8 describes our work on the UROR problem for 2-CNF formulas. Finally, Section 9 summarizes our results and describe avenues for future work.

2. Statement of problems
In this section, we briefly discuss the terms used in this paper. We assume that the reader is familiar with elementary propositional logic.

Definition 2.1

A literal is a variable x or its complement ¬x.

Note that x is called a positive literal and ¬x is called a negative literal.

Definition 2.2

A CNF clause is a disjunction of literals. The empty clause, which is always false, is denoted as ⊔.

Example 1

The following are CNF clauses:

1.
.

2.
.

Definition 2.3

A CNF formula is a conjunction of CNF clauses.

Example 2

The following is a CNF formula:

Throughout this paper, we use m to denote the number of clauses in a CNF formula Φ and n to denote the number of variables. Note that an unsatisfiable CNF formula Φ is said to be minimal unsatisfiable if removing any clause from Φ makes Φ satisfiable.

Definition 2.4

A k-CNF clause is a CNF clause with at most k literals.

Example 3

The following are 3-CNF clauses:

1.
.

2.
.

The following are 2-CNF clauses:
1.
.

2.
.

Definition 2.5

A Horn clause is a CNF clause which contains at most one positive literal.

Example 4

The following are Horn clauses:

1.
.

2.
.

A clause that is both a k-CNF clause and a Horn clause is called a k-Horn clause.

For a single resolution step with parent clauses  and  with resolvent , we write

The variable x is called the matching or resolution variable. If for initial clauses 
, a clause π can be generated by a sequence of resolution steps we write

Example 5

Consider the Horn clauses 
 and 
. Resolving these clauses results in

Definition 2.6

A resolution refutation is a sequence of resolution steps that results in the empty clause, ⊔.

Example 6

Let Φ be the following set of Horn clauses 
, 
, and 
. Φ has the following resolution refutation

1.
Image 4
.
2.
Image 5
.
If a resolution step involves a unit clause, a clause of the form (x) or , then it is called a unit resolution step. If a resolution refutation consists of only unit resolution steps, then it is called a unit resolution refutation.

Example 7

Consider the Horn clauses 
 and 
. Resolving these clauses results in

Since 
 is a unit clause, this is a unit resolution step.

We now formally define the types of resolution refutation discussed in this paper.
Definition 2.7

A read-once resolution refutation is a resolution refutation in which each clause, π, can be used in only one resolution step.

Example 8

Consider the resolution refutation in Example 6. Note that each clause is used in at most one resolution step. Thus, the resolution refutation in Example 6 is a read-once resolution refutation.

Note that the notion of read-once applies to clauses present in the original formula and those derived as a result of previous resolution steps. In a read-once resolution refutation, a clause can be reused if it can be rederived from a set of unused input clauses.

More formally, a resolution derivation

Image 7
is a read-once resolution derivation, if for all resolution steps
Image 8
, we delete one instance of the clauses 
 and 
 from, and add a copy of the resolvent π to, the current multi-set of clauses. In other words, if U is the current multi-set of clauses, we replace U with 
.
It is important to note read-once resolution is an incomplete refutation procedure. This means that there exist infeasible CNF formulas that do not have read-once resolution refutations.

We can similarly define unit read-once resolution.

Definition 2.8

A unit read-once resolution refutation is a unit resolution refutation in which each clause, π, can be used in only one unit resolution step.

Note that the notion of read-once applies to clauses present in the original formula and those derived as a result of previous unit resolution steps.

Example 9

Consider the read-once resolution refutation in Example 6. Note that the first resolution step involves two non-unit clauses. Thus, the read-once resolution refutation in Example 6 is not a unit read-once resolution refutation.

Let Φ be the Horn formula in Example 6. The only unit resolution steps that can be made using the clauses in Φ are

Image 9
and
Image 10
. Note that both of these resolution steps use the clause 
. Thus, the clause 
 cannot be used again in a unit read-once resolution refutation. This means that the literal 
 cannot be eliminated from the other clause in Φ. It follows that Φ does not have a unit read-once resolution refutation.
Let Φ be the following set of Horn clauses 
, 
, and 
. Φ has the following unit read-once resolution refutation

1.
Image 11
.
2.
Image 5
.
Now that we have defined unit read-once resolution, we can define the concept of copy complexity with respect to unit read-once resolution.
Definition 2.9

A CNF formula Φ has copy complexity k with respect to unit read-once resolution, if k is the smallest positive integer such that, there exists a multi-set of CNF clauses, 
 such that:

1.
Every clause in Φ appears at most k times in 
.

2.
Every clause in 
 appears in Φ.

3.
 has a unit read-once resolution refutation.

Example 10

Let Φ be the Horn formula in Example 6. As shown in Example 9, Φ does not have a unit read-once resolution refutation. However, if Φ has two copies of the clause 
, then Φ has the following unit read-once resolution refutation:

1.
Image 9
.
2.
Image 10
.
3.
Image 12
.
Thus, Φ has a copy complexity of 2 with respect to unit read-once resolution.
In this paper, we also deal with the copy complexity of Horn constraint systems that correspond to CNF formulas.
From a CNF formula Φ, we create the constraint system  as described in [14].  is constructed as follows:

1.
For each boolean variable 
 create the variable 
.

2.
For each clause 
, create the constraint 
. Let 
 denote the left-hand side of this constraint and let 
 denote the right-hand side of the constraint.

In these constraints, the variables can take any real values. For a set of clauses 
 and non-negative integers 
 we write 
, if the constraint obtained by summing the constraints 
 though 
 is the constraint .

Note that every constraint can be expressed in the form 
 where 
 and 
. If, for each , 
 and 
, then 
, if and only if 
 and 
.

We can now define the concept of constraint-copy complexity.

Definition 2.10

A CNF formula 
 has constraint-copy complexity k, if k is the smallest positive integer such that, there exist non-negative integers 
 such that 
 for  and
 
 

Example 11

Let Φ be the Horn formula in Example 6. Φ corresponds to the following Horn constraint system:

1.
.

2.
.

3.
.

Note that constraint 
 is the only constraint with a positive right-hand side. If 
, then 
. Thus, it must be the case that 
.

To get the left-hand side of the summation to be zero, we must use constraints 
 and 
 the same number of times. Otherwise, 
 will have a non-zero coefficient in the final summation. Thus, 
. Similarly, it must be the case that 
. Since 
, 
. Thus, 
 and 
. Consequently, Φ cannot have a constraint-copy complexity smaller than 2.

Summing together constraint 
, constraint 
, and two copies of constraint 
, results in the constraint . Thus, Φ has a constraint-copy complexity of 2.

In Section 6, we establish a relationship between the constraint-copy complexity of a CNF formula and the copy complexity of that formula with respect to unit read-once resolution. In particular, we show that a CNF formula Φ has a constraint-copy complexity of k, if and only if Φ has a copy complexity of k with respect to unit read-once resolution. Note that not all CNF formulas have a unit read-once resolution. Thus, a CNF formula has a well-defined (non-negative, finite) constraint-copy complexity, if and only if, it has a well-defined (non-negative, finite) copy complexity with respect to unit read-once resolution.

From the definition of copy complexity with respect to unit read-once resolution, a CNF formula has a well-defined copy complexity with respect to unit read-once resolution if and only if we can construct a unit read-once resolution refutation of that formula by copying input clauses. Clearly, this can be done, if and only if the formula has a unit resolution refutation. Thus, a CNF formula has a well-defined constraint-copy complexity if and only if it has a unit resolution refutation. In particular, an arbitrary, unsatisfiable 2-CNF formula may not have a unit resolution refutation and thus may not have a well defined constraint-copy complexity.

Since every Horn formula has a unit resolution refutation, every Horn formula has a well-defined constraint-copy complexity. Theorem 6.1, Theorem 6.2 will establish that it suffices to focus on the derived constraint is  in order to demonstrate the relationship between constraint-copy complexity and copy complexity with respect to unit read-once resolution.

Note that, in Definition 2.10, a limit is placed upon the multiplier associated with each constraint. This limits the number of times each constraint can be used in a refutation. Thus, this definition effectively extends the notion of copy complexity to Horn constraint systems.

The problem of determining if a read-once resolution refutation or unit read-once resolution refutation exists is only interesting for unsatisfiable formulas. Thus, for all of the problems studied in this paper, we assume that the formula provided is unsatisfiable. For both the formula types considered, Horn [8] and 2-CNF [27], the problems of determining satisfiability are in P.

3. Motivation
In this section, we briefly motivate the constraint systems (Horn clauses and Horn clausal systems) and the proof system (unit read-once resolution) under consideration.

Horn formulas are heavily used in several areas of computer science and mathematics [29]; in particular, they are widely used in domains such as logic programming [11], SAT solvers [5] and artificial intelligence [2]. Automata theory is yet another domain in which horn clauses occur. In [31], a connection is established between the probability of satisfiability of certain Horn formulas and the nonemptiness problem of finite tree automata. Horn formulas are also used to solve more general CNF formulas. In [39], it was shown that the complexity of solving a CNF formula depends on the fraction of Horn constraint in that formula. Deductive databases is another domain in which Horn clauses find applications [30].

Horn clausal logic is used extensively in disjunctive logic programming paradigms such as Datalog and Answer Set Programming [28]. Indeed, in [17], techniques for extending answer set programming to include linear constraints are discussed. The work in this paper can be used to provide certificates of infeasibility which will enhance trust in answers provided by solvers [35].

The use of Constrained Horn Clauses (CHCs) and Constraint Logic Programming (CLP) for program verification has received significant attention in recent years. These approaches rely on establishing the satisfiability or unsatisfiability of logical implications that capture program dynamics. This provides a natural conduit for HCSs to be leveraged as a solution to the CHCs used for program verification. Indeed, it has been shown that proof rules for program verification have corresponding Horn clause representations [10]. Given a program and property to be checked within the program, these sets of logical implications can be automatically generated. Consider, for example, a safety property for a program wherein the property to be checked is that no execution of the program terminates in a bad state. This bad state can be defined in various ways, for example the violation of an assert statement in a programming language. In the field of CLP, a refutation is used to prove such behavior. Indeed, note that this property is violated if the quantified formula 
 is satisfiable, where each 
 is a predicate dependent on the free variables x of any run of the program and the operators ¬ and ∨ denote logical negation and disjunction, respectively. This is logically equivalent to 
, which can be encoded using an HCS. If the system is infeasible, then this would correspond to an unsatisfiable CLP formula, which means the program satisfies the safety property. That is, this would establish that no run of the program violates the predicates 
. Although CLP and CHCs are syntactically equivalent [6] and can both be used in program verification, the former often reasons about unsatisfiability, as we have illustrated, while the latter uses a different approach and generally reasons about satisfiability. That is, a set of CHCs is satisfiable if and only if the underlying program satisfies the given property [9].

This connection between program verification and CHC representations has catalyzed the development, extension, and application of several tools to solve the CHC satisfiability problem. Tools include VeriMAP [6], FreqHorn [9], HSF [10], ELDARICA [13], RAHFT [18], Spacer [25], and the popular Z3 solver [7]. However, the problem of generating explanations for the violation of a property within a program has received little attention. In particular, we argue that the proposed approach to generating refutations of minimum size for a given HCS and the corresponding theoretical results on the bounds of such refutations are useful for generating such explanations. These could, in turn, be used by programmers to aid in code debugging or by automated tools for program synthesis.

Resolution as a proof system is widely used in the study of proof complexity. This is due to the simple nature of resolution based proofs [4]. Although inefficient in general, resolution remains the backbone of several theorem provers and SMT solvers on account of its simplicity and wide applicability [36]. The motivation for studying restricted forms of resolution is described at length in [15]. The principal idea is that weakening the proof (refutation) system results in “shorter proofs”, although completeness is sacrificed.

4. Related work
In this paper, we focus on the copy complexity of Horn formulas with respect to unit read-once resolution.

In [38], Tseitin showed that a restricted form of resolution had an exponential lower bound. This result was improved in [12]. In that paper, it was established that CNF formulas have exponentially long resolution refutations even without the restrictions imposed by [38]. This was accomplished by showing that any resolution refutation of the pigeonhole principle is necessarily exponentially long in the size of the input. Additional lower bounds on the length of resolution proofs are discussed in [4], [32]. Finding the copy complexity of certain classes of Horn formulas helps establish additional bounds on the lengths of resolution refutations for those formulas.

This is similar to the concept of clause duplication introduced in [16]. That paper examined read-once refutations of CNF formulas under two inference rules, resolution and duplication. The duplication rule removes a clause from the formula only to add two copies of that clause. [16] classified CNF formulas based on the number of times the duplication rule needed to be used in a read-once refutation. Note that since these refutations can use both the duplication and resolution rules, they are not necessarily resolution refutations.

For each integer k, the class  is the set of CNF formulas with a read-once refutation using the duplication rule at most k times. Note that this differs from the concept of copy complexity in the following ways:

1.
The duplication rule can be applied to derived clauses as well as clauses from the original system. In this way, the concept of clause duplication is closer to derived-copy complexity than it is to regular copy complexity.

2.
The class  is interested in the total number of clauses copied instead of the number of times any particular clause is used.

[16] showed that for general CNF formulas, the class  is NP-complete. Note that  is the set of CNF formulas with a read-once resolution refutation. The paper also showed that the class  is 
-complete for any positive integer k.
Other papers have examined the read-once resolution refutation problem for restricted forms of CNF formulas. In [23], it was shown that the problem of checking if a 3-CNF formula has a read-once resolution refutation is still NP-hard. It was later shown that the problem of checking if a CNF formula has a read-once resolution refutation is NP-complete even for 2-CNF formulas [21]. This result is particularly interesting since the satisfiability of a 2-CNF formula can be determined in polynomial time. Thus, the paper establishes a class of CNF formulas for which the satisfiability problem is in P [27] but the read-once resolution refutation problem is NP-complete. Another main class of CNF formulas for which the satisfiability problem is in P is Horn formulas [8]. However, every unsatisfiable Horn formula has a read-once refutation [8]. Thus, Horn formulas do not provide the same difference in complexities between the read-once resolution refutation and satisfiability problems that is provided by 2-CNF formulas.

As stated before, an extended abstract of this work appears in [40]. The copy complexity of Horn formulas with respect to unit read-once resolution is also explored in [22]. While this paper establishes the NP-completeness of checking if the copy complexity is bounded by some number, [22] focuses on structural results with respect to copy complexity. Likewise, while this paper describes an algorithm for checking for the presence of read-once unit resolution refutations in 2-CNF and 2-Horn formulas, [40] describes an algorithm for the same problem in 2-Horn formulas. However, the algorithms in the two papers utilize different techniques and have different run times.

5. The UROR problem for Horn formulas
In this section, we explore the problem of finding unit read-once resolution refutations for Horn formulas. If we restrict ourselves to unit resolution refutations, then Horn formulas are no longer guaranteed to have read-once resolution refutations.

Example 12

Consider the Horn formula

This formula has the following read-once resolution refutation:

However, we will now show that this formula does not have a unit read-once resolution refutation.

There are three possibilities for the final resolution step.

1.
The final resolution step is

Image 14
: Note that in this case it is impossible to generate the clause 
 by unit resolution.
2.
The final resolution step is

Image 15
: To generate the clause 
 we need to use the clause 
. However, we also need to use this clause to generate 
.
3.
The final resolution step is

Image 16
: To generate the clause 
 via unit resolution, we need to use the clause 
 twice. Once to resolve with 
 and once to resolve with 
.
Thus, it is not always possible to find a unit read-once resolution refutation.
Observation 5.1

For a CNF formula Φ, a unit read-once resolution refutation of Φ has at most  resolution steps, where m is the number of clauses in the formula.

Proof

Recall that a read-once resolution step is equivalent to removing the two parent clauses from the formula and adding the resolvent. Thus, each read-once resolution step effectively reduces the number of clauses in the formula by 1. Since Φ initially has m clauses, there can be at most  such resolution steps. □

It was shown in [24] that the UROR problem for Horn formulas is NP-complete.
We now provide an alternative proof that the UROR problem is NP-complete for Horn formulas. This is done by a reduction from the set packing problem. This problem is defined as follows:

Definition 5.1

The set packing problem is the following: Given a set S of size n, m subsets 
 of S, and an integer k, does 
 contain k mutually disjoint sets?

This problem is known to be NP-complete [19].
Example 13

Let S be the set 
. If 
, 
, and 
, then the sets 
 and 
 are mutually disjoint. Thus 
 contains 2 mutually disjoint sets.

Theorem 5.1

The UROR problem for Horn formulas is NP-complete.

Proof

The number of resolutions in a unit read-once resolution refutation is limited by the number of clauses in the Horn formula. Thus, a unit read-once resolution can also be verified in polynomial time. Consequently, the UROR problem is in NP.

Let us consider an instance of the set packing problem. We construct the Horn formula Φ as follows.

1.
For each 
, create the boolean variable 
 and the clause 
.

2.
For , create the boolean variable 
.

3.
For each subset 
,  create the k clauses
 

4.
Finally create clause 
.

We now show that Φ has a unit read-once resolution refutation if and only if 
 contains k mutually disjoint sets.

Suppose that 
 does contain k mutually disjoint sets. Without loss of generality, assume that these are the sets 
.

Let us consider the sets of clauses
 

By the construction of Φ, 
 for . Since the sets 
 are mutually disjoint, so are the sets 
.

It is easy to see that the clause 
 can be derived from the set 
 by unit read-once resolution. Since this holds for every  and since the sets 
 are mutually disjoint, the set of clauses 
 can be derived from Φ by unit read-once resolution.

Together with the clause 
, this set of clauses has a unit read-once derivation of the empty clause. Thus, Φ has a unit read-once resolution refutation.

Now suppose that Φ has a unit read-once resolution refutation R. Note that 
 can be satisfied by setting every variable 
 and 
 to true. Thus, R must use the clause 
.

To eliminate the clause 
, R must either derive the clauses 
, or reduce 
 to a unit clause and then resolve it with another clause. Without loss of generality, we can assume that this unit clause is 
. In either case, R must derive the clauses 
.

Thus, we must derive the clauses 
. Let us consider the clause 
, . By the construction of Φ, this clause must be derived from one of the clauses
 
 To perform this derivation, we must use the set of clauses 
 for some 
.

Since the refutation is read-once, the sets 
 for  are mutually disjoint. Thus, the sets 
 for  are also mutually disjoint.

If R derives the clause 
, then, by the construction of Φ, this clause must be derived from one of the clauses
 
 To perform this derivation, we must use the set of clauses 
 for some 
.

If R reduces 
 to the clause 
, then we must resolve 
 with one of the clauses
 
 This results in the clause 
 for some 
. To eliminate this clause, we must use the set of clauses 
.

Since R is read-once, the set 
 does not share any clauses with the sets 
, . Thus, the sets 
 for  are also mutually disjoint. This means that 
 contains k mutually disjoint sets.

Thus, Φ has a unit read-once resolution refutation if and only if 
 contains k mutually disjoint sets. As a result of this, the UROR problem for Horn formulas is NP-complete. □

We now compare the Horn formulas generated by our reduction from set packing to the Horn formulas generated by the reduction from 3-CNF used in [24]. Let H be a horn formula generated by our reduction from a set packing instance with m subsets, n elements, and target k. Additionally, let 
 be the horn formula generated by the reduction in [24] from a 3-CNF instance with 
 clauses over 
 variables. These two Horn formulas have the properties shown in Table 1.


Table 1. Comparison of reductions.

Horn formula H	Horn formula H′
# of variables	k + n	m′ + 8 ⋅ n′
# of clauses	1 + k ⋅ m + n	1 + 3 ⋅ m′ + 10 ⋅ n′
# of resolutions	k + n	5 ⋅ m′
Let  be the number of clauses in Horn formula H, and let 
 be the number of clauses in 
. As Table 1 shows, the number of resolutions in a unit read-once resolution refutation of H is , if it exists. This is in contrast to the formula 
 which has a unit read-once resolution refutation with 
 resolutions, if one exists. Thus, the key difference between the Horn formulas generated by these two reductions is the number of resolutions in the refutation compared to the number of clauses in each Horn formula.

6. Copy complexity and Horn constraint systems
In this section, we relate the copy complexity of Horn formulas to the copy complexity of the corresponding Horn constraint system.

Theorem 6.1

If Φ has copy complexity k with respect to unit read-once resolution, then Φ has constraint-copy complexity k.

Proof

Let 
 be a CNF formula. Assume that Φ has a copy complexity of k with respect to unit resolution. Thus, we can construct the multi-set 
 where each clause 
 appears 
 times for  and 
 has a unit read-once resolution refutation. We will show that 
.

Let

Image 17
be a resolution step in the unit read-once resolution refutation of ϕ. Observe that 
 corresponds to the constraint 
 and 
 corresponds to the constraint 
. Summing these constraints results in  which is the constraint that corresponds to β. Thus, each resolution step corresponds to the summation of the corresponding constraints.
Since the last resolution step is

Image 18
, it follows that the last summation is summing 
 and 
 to get . Thus,  is the result of the entire summation and 
 as desired. □
Theorem 6.2

If a CNF formula Φ has constraint-copy complexity k, then Φ has copy complexity k with respect to unit resolution.

Proof

We will show a stronger result: If 
 for some coefficients 
, , then Φ has a unit resolution refutation using 
 copies of the clause 
. The theorem follows immediately from this.

Let 
, we will obtain the desired result by induction on K.

If , then Φ must have two clauses with 
. Thus, . This formula obviously has a unit read-once resolution refutation.

Now assume that the desired result holds for all formulas Φ for which there exists a set of coefficients such that .

Let Φ be a formula with coefficients 
 such that . Let 
 be the number of positive literals in clause 
 and let 
 be the number of negative literals.

Since 
, we have that
 
 
 Since 
, we must have that the total number of negative literals is equal to the total number of positive literals. This means that 
. Thus, we have the following:
 
 
 
 
 
 
 
 
 
 We want this sum to be 2. The only way for this sum to be positive is if there exists a clause such that 
. Thus, Φ must have a unit clause. Let (λ) be that unit clause. Thus, we have that Φ is of the form:

We can resolve (λ) and 
 to obtain 
. If 
, this results in the formula 
 where

Let us consider the summation 
. Since addition is commutative, we can assume without loss of generality that the first addition performed in this summation is

Thus, in the summation 
, we can replace one instance of the constraints  and 
 with the constraint 
.

Thus, for each clause 
 we can create the coefficient 
 such that 
. This set of coefficients has the following properties:

1.
 since we have removed an instance of the constraint  from the summation.

2.
 since we have removed an instance of the constraint 
 from the summation.

3.
 since we have added the new constraint 
.

4.
 for , since we have not modified the number of times any other constraint appears in the summation.

Thus, we have
 
 
 
 By the inductive hypothesis, 
 has a unit resolution refutation in which the clause 
 is used 
 times. We can add the resolution step
Image 19
onto the beginning of this refutation. This results in a unit resolution refutation of Φ where the clause 
 is used 
 times, as desired.
If 
, then there exists a clause 
 such that 
. We can assume without loss of generality that 
. Thus, the resolution step

Image 19
results in the formula 
. As before, for each clause 
 we can create the coefficient 
 such that 
. This set of coefficients has the following properties:
1.
 since we have removed an instance of the constraint  from the summation.

2.
 since we have removed an instance of the constraint 
 from the summation.

3.
 since we have added an instance of the constraint 
.

4.
 for , since we have not modified the number of times any other constraint appears in the summation.

Thus, we have
 
 
 
 By the inductive hypothesis, 
 has a unit resolution refutation in which the clause 
 is used 
 times. We can add the resolution step
Image 19
onto the beginning of this refutation. This results in a unit resolution refutation of Φ where the clause 
 is used 
 times, as desired. □
Theorem 6.1, Theorem 6.2 imply the following corollaries.

Corollary 6.1

A CNF formula Φ has a constraint-copy complexity of k, if and only if Φ has a copy complexity of k with respect to unit read-once resolution.

Corollary 6.2

A CNF formula Φ has a constraint-copy complexity of 1, if and only if Φ has a unit read-once resolution refutation.

We now show that for any fixed k, determining if a Horn formula has copy complexity 
 with respect to unit read-once resolution is NP-complete.

Theorem 6.3

For any fixed k, determining if a Horn formula has copy complexity 
 with respect to unit read-once resolution is NP-complete.

Proof

This problem is in NP, because k is fixed. We have only to guess coefficients less than or equal to 
 and to compute the weighted sum of the inequalities of the corresponding Horn constraint system.

The NP-hardness will be shown by induction on k.

For , the problem is exactly the problem of deciding whether a unit read-once resolution exists. This problem has been shown to be NP-complete for Horn formulas [24] (see Theorem 5.1).

Assume that the problem of determining if a Horn formula has copy complexity 
 with respect to unit read-once resolution is NP-complete.

Let 
 be a Horn formula. In polynomial time, we can construct a Horn formula 
 as follows:

1.
For each clause 
, create the variables 
, 
, and 
.

2.
For each clause 
, add the clauses 
, 
, 
, and 
 to 
.

Thus, we have
 
By construction, 
 is a Horn formula.

We now show that Φ has a copy complexity of 
 if and only if 
 has a copy complexity of 
.

Assume that Φ has a copy complexity of 
 with respect to unit resolution. Then, by Corollary 6.1, there exist coefficients 
 such that:
 
 

We construct a set of coefficients for 
 as follows:

1.
For each clause 
, create the coefficient 
.

2.
For each clause 
, create the coefficient 
.

3.
For each clause 
, create the coefficient 
.

4.
For each clause 
, create the coefficient 
.

Then we obtain:
 
 
 and
 
 
 

Thus, 
 has copy complexity 
 with respect to unit resolution.

Now assume that 
 has copy complexity 
 with respect to unit read-once resolution. Thus, there are coefficients 
 and 
 less than or equal to 
 such that: 
 
 In this summation 
 appears positively 
 times and negatively 
 times, thus 
. Similarly, 
 appears positively 
 times and negatively 
 times, thus 
. We also have that 
 appears positively 
 times and negatively 
 times, thus 
.

This means that 
 and 
.

We also have that
 
 
 
 

Thus, Φ has copy complexity 
 with respect to unit read-once resolution. □

7. Derived-copy complexity
In this section, we study a variant of copy complexity that allows for copies of derived clauses. This is different from regular copy complexity which allows only copies of clauses in the original system. We refer to this as derived-copy complexity.

Example 14

Let Φ be the following Horn formula:

1.

2.
.

3.
.

4.
.

If Φ has two copies of the clause 
 and three copies of the clause 
, then Φ has the following unit read-once resolution refutation:

1.
Image 20
.
2.
Image 10
.
3.
Image 21
.
4.
Image 20
.
5.
Image 9
.
6.
Image 22
.
Thus, Φ has a copy complexity of 3 with respect to unit read-once resolution.
If instead, we only had two copies of the clause 
 and made a copy of the derived clause 
, then Φ has the following unit read-once resolution refutation:

1.
Image 20
.
2.
Image 10
.
3.
Image 21
.
4.
Image 9
.
5.
Image 22
.
Thus, Φ has a derived copy complexity of 2 with respect to unit read-once resolution.
Theorem 7.1

The derived-copy complexity of a Horn formula with m clauses with respect to unit read-once resolution is at most .

Proof

Let Φ be an unsatisfiable Horn formula. Note that adding clauses to Φ cannot increase the copy complexity. Thus, we can assume without loss of generality that Φ is minimal unsatisfiable.

First, assume that Φ has  clauses. Thus, Φ has the form  and the derived-copy complexity is 1.

Now assume that every Horn formula with k clauses has derived-copy complexity .

Let Φ be a Horn formula with  clauses. Thus, Φ has the form 
 for some .

Since Φ is minimal unsatisfiable, 
 and 
 do not contain the literal x. By construction, they also do not contain the literal ¬x.

If we generate t copies of the clause (x), then for each , we can apply the resolution step

Image 23
. Applying these resolution steps results in the Horn formula 
.
 is minimal unsatisfiable and consists of k clauses. By the induction hypothesis, we know that the derived-copy complexity of 
 is at most .

Thus, the derived-copy complexity of Φ is at most  as desired. □

Theorem 7.2

For each value of m, there exists a Horn formula with m clauses and derived-copy complexity 

Proof

We inductively define 
 as follows:

1.
.

2.
If 
, then

Note that for each m, 
 consists of m clauses and is an unsatisfiable Horn formula.

We now show by induction, that 
 has derived-copy complexity . 
 has a unit read-once resolution refutation consisting of the single resolution step

Image 14
.
Now assume that 
 has derived-copy complexity . To derive 
 from 
 by unit read-once resolution, we need to resolve the clause 
 with every other clause in 
. This requires  copies of the clause 
. By the inductive hypothesis, this derived formula has derived-copy complexity . Thus, the formula 
 has derived-copy complexity  as desired. □

From Theorem 7.1 and Theorem 7.1, it follows that the derived-copy complexity for Horn formulas with m clauses is .

8. The UROR problem for 2-CNF formulas
In this section, we show that the UROR Problem for 2-CNF formulas is in P. This is done by reducing the problem to minimum weight perfect matching using a similar construction to the one in [37]. Note that the problem of finding read-once resolution refutations for 2-CNF formulas is NP-complete [21].

Let Φ be a 2-CNF formula with m clauses over n variables. We construct a weighted undirected graph . Note that the edge weights can be negative. Throughout this section, we will use

Image 24
to denote an edge of weight b between 
 and 
. The graph G is constructed as follows:
1.
For each variable 
 in Φ, add the vertices 
, 
, 
, and 
 to V. Additionally, add the edges

Image 25
and
Image 26
to E.
2.
Add the vertices 
 and 
 to V.

3.
For each constraint 
 of Φ, add the vertices 
 and 
 to V and the edge

Image 27
to E. Additionally:
(a)
If 
 is of the form 
, add the edges

Image 28
,
Image 29
,
Image 30
, and
Image 31
to E.
(b)
If 
 is of the form 
, add the edges

Image 28
,
Image 29
,
Image 32
, and
Image 33
to E.
(c)
If 
 is of the form 
, add the edges

Image 34
,
Image 35
,
Image 30
, and
Image 31
to 
.
(d)
If 
 is of the form 
, add the edges

Image 34
,
Image 35
,
Image 32
, and
Image 33
to E.
(e)
If 
 is of the form 
, add the edges

Image 28
,
Image 29
,
Image 36
, and
Image 37
to E.
(f)
If 
 is of the form 
, add the edges

Image 34
,
Image 35
,
Image 36
, and
Image 37
to E.
Under this construction, each variable is represented by a pair of 0-weight edges. Thus, each variable can be used twice in a resolution refutation. Note that each 2-CNF formula has a resolution refutation that uses each variable at most twice [20]. However, we only have one 0-weight edge for each clause. This prevents the refutation from reusing clauses. Observe that G has  vertices and  edges.

Example 15

Consider the following 2-CNF formula.(1) 
 

Theorem 8.1

Φ has a unit read-once resolution refutation if and only if G has a negative weight perfect matching.

Proof

First, assume that Φ has a unit read-once resolution refutation R. Let 
 be the set of clauses in Φ used in any resolution step in R. Since R is a sequence of resolution steps, we can order the clauses in 
 according to the order in which they are used by resolution steps in R. Thus, if a clause 
 is used in an earlier resolution step in R than the clause 
, then 
 is earlier in the ordering of 
 than 
.

We can construct a negative weight perfect matching P of G as follows:

1.
For each variable 
 in Φ:

(a)
If no clause in 
 contains the literal 
, add the edges

Image 38
and
Image 39
to P.
(b)
If only one clause in 
 contains the literal 
, add the edge

Image 39
to P.
2.
For each clause 
 in Φ:

(a)
If 
, add the edge

Image 40
to P.
(b)
If 
 is a two variable clause:

i.
If 
 is the first clause in 
 to contain the literal 
, add the edge

Image 28
(or
Image 41
) to P. If it is the second, add the edge
Image 29
(or
Image 42
) instead.
ii.
If 
 is the first clause in 
 to contain the literal 
, add the edge

Image 34
(or
Image 43
) to P. If it is the second, add the edge
Image 35
(or
Image 44
) instead.
(c)
If 
 is a unit clause:

i.
If 
 is the first clause in 
 to contain the literal 
, add the edge

Image 28
to P. If it is the second, add the edge
Image 29
instead.
ii.
If 
 is the first clause in 
 to contain the literal 
, add the edge

Image 34
to P. If it is the second, add the edge
Image 35
instead.
iii.
If 
 is the first unit clause in 
, add the edge

Image 36
to P. If it is the second, add the edge
Image 37
instead.
Every vertex in G is an endpoint of exactly one edge in P. Thus, P is a perfect matching. Since 
, P has negative weight.

Now assume that G has a negative weight perfect matching P. We can construct a unit read-once resolution refutation R as follows:

1.
Since there is no edge between 
 and 
, P must use the edge

Image 36
for some unit clause 
. Thus, the edge
Image 27
is not in P. Note that 
 is the clause 
 or 
 for some 
.
2.
Without loss of generality, assume 
 is the clause 
. This means that the edge

Image 28
(or
Image 45
) must be in P. Thus, the edge
Image 38
(or
Image 46
) is not in P. This means that for some clause 
, the edge
Image 47
(or
Image 48
) is in P. If 
 corresponds to the clause 
 or 
 for some 
, then we add either
Image 49
or
Image 50
to R. If 
 corresponds to the clause 
, then we add
Image 51
to R.
3.
If 
 is a non-unit clause, then we can repeat step 2 from either 
 or 
. This continues until a second unit clause is encountered, completing the refutation. By construction, R is a unit read-once resolution refutation.

 □
Observe that the minimum weight perfect matching of an undirected graph having 
 vertices and 
 edges can be found in 
 time using Edmond's Blossom Algorithm in Section 11 of [26]. Since in our case, G has  vertices and  edges, it follows that we can detect the presence of a negative weight perfect matching in 
 time. Hence, using the above reduction, the UROR problem for 2-CNF formulas can be solved in 
 time.

8.1. Alternate approach to the UROR problem for 2-Horn formulas
We now provide an alternate algorithm for Horn formulas with only two literals per clause. Instead of constructing the graph G that was constructed for the 2-CNF case, we convert Φ into a system of Unit Two Variables per Inequality (UTVPI) constraints. By definition, a UTVPI constraint has at most two non-zero coefficients and those coefficients belong to the set .

We convert the 2-Horn formula Φ into a system of UTVPI constraints U as follows:

1.
For each clause 
, create the constraint 
.

2.
For each clause 
, create the constraint 
.

3.
For each clause 
, create the constraint 
.

4.
For each clause 
, create the constraint 
.

We now use refutations of U to find unit read-once resolution refutations of Φ. However, not every refutation of U corresponds to a unit read-once resolution refutation of Φ.

Example 16

Let Φ be the following Horn formula. 
  From Φ, we obtain the following system of UTVPI constraints U. 
  Note that U has a refutation obtained by summing all of the constraints with the constraint 
 included twice in the summation.

However, Φ does not have a unit read-once resolution refutation. Note that the clause 
 needs to be derived twice, once to resolve with 
 and once to resolve with 
. However the only clause with 
 as a positive literal is 
. Thus, the clause 
 needs to be used twice in any unit resolution refutation of Φ.

This occurred because the constraint 
 needed to be used twice in the refutation of U.

Note that U can also be obtained by negating every constraint in .

By Corollary 6.2, any read-once refutation of U corresponds to a unit read-once resolution refutation of Φ. Thus, to find a unit read-once resolution refutation of Φ, we can simply find a read-once linear refutation of U. This can be accomplished in 
 time [37].

Note that the running time of this procedure is the same as the procedure for general 2-CNF. However, if an algorithm for finding read-once refutations in systems of UTVPI constraints is found that is faster than the MWPM algorithm, then this method will represent an improvement over the more general algorithm.

9. Conclusion
In this paper, we examined several properties of the copy complexity of Horn formulas with respect to unit read-once resolution. In particular, we established that the copy complexity of a Horn formula with respect to unit read-once resolution equals the copy complexity of the corresponding Horn constraint system with respect to constraint addition.

Additionally, we studied a variant of copy complexity known as derived-copy complexity. Under this variant, we are allowed to copy derived constraints in addition to constraints in the original formula. We established both upper and lower bounds on the derived-copy complexity of Horn formulas with respect to unit read-once resolution.

Finally, we designed and analyzed algorithms that check for the existence of URORs. The first of these algorithms determines if a 2-CNF formula has a unit read-once refutation in 
 time. This algorithm solves the problem by converting it into the problem of checking if a graph has a negative weight perfect matching.

The second algorithm determines if a 2-Horn formula has a UROR in 
 time. This algorithm converts the 2-Horn formula into a UTVPI constraint system and then checks if the UTVPI constraint system has a read-once refutation.

From our perspective, the following problems are worth pursuing:

1.
Derived-copy complexity: In this paper, we established upper and lower bounds on the derived-copy complexity of a Horn formula with respect to unit read-once resolution. We have not established the complexity of, for a given k, determining if a Horn formula has derived-copy complexity at most k. Note that when , this is the problem of determining if a Horn formula has a UROR. However, the complexity may change for other values of k.

2.
Algorithms for determining copy complexity - In our work on the copy complexity of Horn formulas with respect to unit read-once resolution, we have not yet developed algorithms for this problem. Thus, an avenue of future research would be the design and analysis of both exact exponential and parameterized algorithms for this problem.