Abstract
We present a dynamic algorithm for the recognition of proper circular-arc (PCA) graphs, that supports the insertion and removal of vertices (together with its incident edges). The main feature of the algorithm is that it outputs a minimally non-PCA induced subgraph when the insertion of a vertex fails. Each operation cost O(log⁡n+d) time, where n is the number vertices and d is the degree of the modified vertex. When removals are disallowed, each insertion is processed in O(d) time. The algorithm also provides two constant-time operations to query if the dynamic graph is proper Helly (PHCA) or proper interval (PIG). When the dynamic graph is not PHCA (resp. PIG), a minimally non-PHCA (resp. non-PIG) induced subgraph is obtained.

Keywords
Dynamic representation
Certifying algorithm
Proper circular-arc graphs
Proper interval graph
Proper Helly circular-arc graphs

1. Introduction
A circular-arc (CA) model is a family of arcs of a circle. A graph G admits a CA model  when its vertices are in a one-to-one correspondence with the arcs of  in such a way that two vertices of G are adjacent if and only if their corresponding arcs have a nonempty intersection. Those graphs that admit a CA model are called circular-arc (CA) graphs. Proper circular-arc graphs and proper interval graphs form two of the most studied subclasses of CA graphs. A CA model  is proper when no arc of  is properly contained in another arc of , while  is an interval (IG) model when the union of its arcs does not cover the entire circle. A graph is a proper circular-arc (PCA) graph when it admits a proper CA model, while it is a proper interval (PIG) graph when it admits a proper IG model.

The (static) recognition problem for PCA (resp. PIG) graphs asks if an input graph G is PCA (resp. PIG). A recognition algorithm that outputs YES or NO is not that useful in practice for two reasons. First, there are many applications in which PIG and PCA models of G are looked for, while several algorithms work more efficiently when a PIG or PCA model of G is available [1], [2], [3]. Second, and not less important, a buggy implementation can lead to incorrect answers that a user cannot corroborate. A certifying recognition algorithm yields a witness W proving that the output is correct for G. Besides proving correctness, two additional properties are required for W [4]. First, there exists a checker with a “trivial” implementation that, given G and W, authenticates that the output is correct for G. Second, there is a simple proof that the existence of W implies the output on G. With these two ingredients, a user can test that the output for G is correct, even when the implemented algorithm has bugs [4].

Witnesses are classified as positive or negative according to the output given for G. The former prove that G is PCA (YES output), while the latter prove that G is not PCA (NO output). A priori, there are many certifying algorithms for the recognition of PCA graphs, as we can chose different kinds of witnesses. Although all of them can be used to authenticate the output, they need not be equally useful for the user. This statement is obvious in those application where the goal is to produce a PCA model of G, but it also holds for those applications on PCA graphs that require a specific kind of input. Thus, a positive witness with the required interface is better than one that has to be further processed. Similarly, a negative witness should highlight the reason why G is not PCA. Arguably, PCA models are the most useful positive witnesses, while minimally forbidden subgraphs are the most useful negative witnesses.

Unfortunately, the positive witnesses that we use in this article are not PCA models, but round representations [5]. Roughly speaking, a round (resp. straight) representation Φ is like a PCA (resp. PIG) model in which the actual position of the arcs is missing. Instead, we know the order of the arcs and which are the leftmost and rightmost arcs intersected by a given arc. Fortunately, Φ is enough for all those applications in which knowing the actual position of an arc is not required, e.g. [2]. Also, it is trivial to obtain a PCA (PIG) model  associated to Φ in  time, where n is the number of arcs of ; by associated, we mean that the arcs of Φ and  appear in the same order.

In this article we consider a dynamic version of the recognition problem for PCA graphs. The goal is to keep a round representation Φ of a graph G while some operations are applied. We allow two kinds of updates: the insertion of a new vertex (and the edges incident to it), and the removal of an existing vertex (and its incident edges). Those insertions that yield non-PCA graphs have no effects on Φ; instead, an error message is obtained. Also, the algorithm must answer if G is PIG or not and, if affirmative, then Φ must be a straight representation. Consequently, Φ can be immediately applied on algorithms that work on PIG graphs. When efficiency does not matter, the dynamic problem is solved by applying any static recognition algorithm for each update. The idea, however, is to reduce the complexity of the operations.

To motivate the development of dynamic algorithms for PIG graphs, Hell et al. [6] describe an application to physical mapping of DNA. The problem is to find a straight representation Φ of an input graph G that encodes some biological data, or to prove that no such model exists. As time goes by, further experiments may prove that the initial biological data is not accurate. The resulting changes in the data correspond to the insertion and removal of vertices and edges from G. Instead of building a new straight representation from scratch, the goal is to “fix” Φ efficiently.

The concerns about the reliability and usefulness of the outputs, that we had for the static recognition algorithms, hold also for the dynamic ones. The existence of a round representation Φ proves that G is a PCA graph, thus Φ can be taken as the positive witness. However, when the algorithm rejects an update claiming that it leads to a non-PCA graph, can we trust this claim blindly? And, even if we do trust, we still want a negative witness to check if, and where, the input data is incorrect. This is particularly true for the above application to physical mapping of DNA, since we expect the experiments to be inaccurate at some point, and we cannot assume that the erroneous data yields a PCA graph. A certifying and dynamic algorithm for the recognition of PCA graphs outputs a minimally forbidden subgraph when some update is rejected.

Authenticating that a round representation Φ encodes G or that F is minimally forbidden subgraph of G are trivial tasks, as desired. However, the time required for these authentications is linear on the size of G. Thus, we cannot expect the user to authenticate the witnesses after each operation, as doing so throws out the efficiency benefits of the dynamic algorithm. The difference between static and dynamic algorithms is that the latter are not, strictly speaking, algorithms. Instead, they are abstract data types that keep a certain data structure that reacts to the different operations. Thus, Φ is not given as output when an insertion or removal is applied and, so, Φ should be authenticated against G only occasionally.

We can conceive three types of checkers, which we call static, dynamic, and monitors. Static checkers are static algorithms that authenticate the witness against the static graph G. Dynamic checkers are also static algorithms, but they check one update of the dynamic algorithm against the round representation Φ. Finally, monitors are dynamic algorithms that ensure the correctness of the data structure 
 implementing Φ [4], [7]. Thus, a monitor is an abstract data type that sits between the user and the recognition algorithm. The user interacts with the monitor as if it were a round representation. In turn, the monitor forwards each operation to 
, while it checks the correct behavior of 
 and the generated output. In case of an error, the monitor raises an exception. The main difference between checkers and monitors is that the latter may require access to operations that are restricted to the user. Checkers are usually simpler, as they have no knowledge of 
, and can be implemented even when the source code of the recognition algorithm is unavailable. However, the same reason could make them less efficient. Thus, checkers and monitors are complementary tools.

Previous work. Linear-time algorithms for generating PIG models of graphs are known since more than twenty years, e.g. [5], [8], [9]. While dealing with the correctness of their algorithm, Deng et al. [5] prove that a minimally forbidden subgraph F must exist when the algorithm fails. Although it is not discussed in [5], F can be obtained in  time. A second way to find a F is to apply the dynamic recognition algorithm by Hell et al. [6]. In a first phase, the algorithm finds a set of vertices V such that the subgraph  induced by V is PIG, and  is not PIG. In a second phase, the algorithm transforms  into F by removing vertices from V. This strategy, which is discussed in [10] for PCA graphs, costs linear time for PIG graphs. A similar approach using only incremental graphs is discussed in [4] for planar graphs and in [11] for interval graphs. Arguably, the simpler linear time algorithm to find F was presented in 2004 by Hell and Huang [12], who extend the LexBFS algorithm by Corneil [13] to exhibit such a forbidden when the input is not PIG. Meister [14] also applies LexBFS to find a negative witness, but this witness is not always a minimally forbidden subgraph.

The problem of building a PCA model of a graph G is also well settled, but fewer algorithms are known [5], [10], [15]. Regarding the certification problem, Hell and Huang [12] show how to obtain a minimally forbidden subgraph F when G is co-bipartite and not PCA. The first algorithm that shows how to obtain a negative witness when G is not co-bipartite was presented in 2009 by Kaplan and Nussbaum [15]. Unfortunately, their witnesses are not forbidden subgraphs, but odd cycles of incompatibility graphs. Up to this date, the only algorithm that is able to compute F in linear time for every PCA graphs was given by the author [10] in 2015. The idea is to apply a dynamic recognition algorithm in two phases as discussed above.

Lin and Szwarcfiter [16] survey different algorithms for the recognition of other classes of circular-arc graphs, while McConnell et al. [4] discuss a theoretical framework for certifying algorithms and explain why they are preferred over non-certifying ones. McConnell et al. survey certifying recognition algorithms for other classes of graphs as well.

In the last years, dynamic recognition algorithms for many classes of graphs were developed [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28]. Among these examples, the only ones that provide negative witnesses are the one by Crespelle and Paul [17] for the recognition of directed cographs and the one by Springer [27] for the recognition of interval graphs. We remark that the minimally forbidden subgraphs for these classes consume  space, where x is the time required to generate the certificate when an operation fails. Thus, the forbidden subgraphs are generated from scratch when required. On the other hand, we want to spend  time when the insertion of a vertex with degree d fails. Since a minimally forbidden subgraph for PCA graphs can have  vertices with degree , the computation of such a forbidden must be dynamic.

Our results. We conceive our manuscript as the fourth in a series of articles. The series begins in 1996 with the recognition algorithm for PCA graphs developed by Deng et al. [5]. As part of their algorithm, Deng et al. devise a vertex-only incremental algorithm for the recognition of connected PIG graphs that runs in  time per vertex insertion, where d is the degree of the inserted vertex. The data structure that supports their recognition algorithm is a straight representation. The second article of the series dates back to 2001, where Hell et al. [6] extend the algorithm by Deng et al. to solve the dynamic recognition of PIG graphs. Their algorithm runs in 
 time per vertex insertion, 
 time per vertex removal, 
 time per edge insertion, and 
 time per edge removal. The values of 
 and 
 depend on the data structure employed to implement the straight representations, as depicted in Table 1. Note that the algorithm is optimal if only insertions are allowed, while it is almost optimal when both operations are allowed. Indeed, Hell et al. prove that  amortized time is required by the fully dynamic algorithm in the cell probe model of computation with word size b. Finally, in 2015, the author [10] extended the algorithm by Hell el al. for the recognition of PCA graphs. The algorithm works with round representations and has the same complexity as the one by Hell et al. Moreover, the round representation is straight when the input graph is PIG, thus the algorithm solves the dynamic recognition of PIG graphs as well.


Table 1. The actual values of ep+ and ep− according to the data structure employed.

Type of data structure	ep+	ep−
Incremental	O(1)	O(n)
Decremental	O(n)	O(1)
Fully dynamic		
In this article we further extend the algorithm in [10] to provide a certifying and dynamic algorithm for the recognition of PCA graphs as discussed above. The algorithm is restricted to the insertion and removal of vertices, and we ignore the problem for edge operations. Specifically, the algorithm implements a round representation Φ of the input graph G, and it yields a minimally forbidden subgraph when a vertex insertion fails. Our algorithm is as efficient as the one by Hell et al., as it handles the insertion of a new vertex v in 
 time, while the removal of v costs 
 time. The user can also ask, at any point, if G is a PIG graph; this query costs  time. If affirmative, then Φ is a straight representation of G. Otherwise, a minimally forbidden subgraph is obtained.

We remark that when the insertion of a vertex v with  neighbors fails, the minimally forbidden subgraph F can be of size . However, only 
 time is available to generate F. Thus, besides keeping Φ, the dynamic algorithm stores a partial forbidden subgraph . When an insertion fails,  is extended with v to yield F. This scheme is similar to the one used for the positive witness. The difference is that  is not accessible by the user, who observes the dynamic algorithm as an implementation of Φ. As is the case with Φ, the output F must provide an efficient and convenient interface to the user. Of course, because of the inevitable aliasing between F and G, no updates on F are possible, and any modification on G invalidates F. If required, a copy of F can be obtained in  time.

Organization of the manuscript. Section 2 introduces the basic terminology and notation. Section 3 presents the Reception Theorem, which characterizes when a graph H is PCA knowing that  is PCA. The Reception Theorem sums up the theory we require from [5], [6], [10], and guides the certifying algorithm that we develop later. Section 4 describes the abstract data types that we employ together with their implementations. The presentation given here not only extends the algorithmic results in [5], [6], [10] to show how to maintain the partial forbidden subgraph , but it also sets the boundaries of what can be done with the structures in abstract terms, so that we do not have to deal with low level operations in the rest of the manuscript. Section 5 shows the certifying algorithm we use when a vertex is inserted. Section 6 depicts the complete recognition algorithm, including the insertion and removal of vertices and the query for the recognition of PIG graphs. Section 6 also discusses the authentication problems. Finally, Section 7 has some further remarks and open problems.

2. Preliminaries
For a graph G, we use  and  to denote the sets of vertices and edges of G, respectively, and  and . The neighborhood of a vertex v is the set 
 of all the neighbors of v, while the closed neighborhood of v is 
. If 
, then v is a universal vertex, while if 
, then v is an isolated vertex. Two vertices v and w are twins when 
. The cardinality of 
 is the degree of v and is denoted by 
. We omit the subscripts from N and d when there is no ambiguity about G.

The subgraph of G induced by  is the graph  that has V as its vertex set, where two vertices of  are adjacent if and only if they are adjacent in G. A clique is a subset of pairwise adjacent vertices. We also use the term clique to refer to the corresponding subgraph. An independent set is a set of pairwise non-adjacent vertices. A semiblock of G is a nonempty set of twin vertices, and a block of G is a maximal semiblock.

The complement of G, denoted by 
 
, is the graph that has the same vertices as G and such that two vertices are adjacent in 
 
 if and only if they are not adjacent in G. Each component of 
 
 is called a co-component of G, and G is co-connected when 
 
 is connected. The union of two vertex-disjoint graphs G and H is the graph  with vertex set  and edge set . The join of G and H is the graph 
 
 
 
, i.e.,  is obtained from  by inserting all the edges vw, for  and .

A graph G is bipartite when there is a partition 
 of  such that both 
 and 
 are independent sets. Contrary to the usual definition of a partition, we allow one of the sets 
 and 
 to be empty. So, the graph with one vertex is bipartite for us. The partition of  into 
, denoted by 
, is called a bipartition of G. When 
 
 is bipartite, G is a co-bipartite graph and each bipartition of 
 
 is a co-bipartition of G.

For  and , we say that v and W are: adjacent if , co-adjacent if , and fully adjacent if . Two disjoint semiblocks B and W are adjacent if some vertex in B is adjacent to some vertex in W; observe that B and W are adjacent if and only if every vertex in B is fully adjacent to W. If  is a semiblock, then B is a twin of W. A semiblock B is universal when its vertices are universal, and isolated when the vertices in B are not adjacent to . For a disjoint family of semiblocks , the subgraph  of G induced by  is obtained from  by removing all but one vertex from each semiblock of . Clearly,  is an induced subgraph of G.

2.1. Orderings and ranges
In this article, an order is a pair  where S is a finite, and possibly empty, set that admits an enumeration 
 of its elements such that 
 for every  and 
 for some undefined value . We say that  is linear when 
, while  is circular when 
. When  is linear, 
 and 
 are the leftmost and rightmost elements of . The enumeration X of S is said to be an ordering of .

Clearly, every enumeration X of a finite set S defines a linear order and a circular order , both of which have X as its ordering. Thus, we say that X is a linear (resp. circular) ordering to mean that  is a linear (resp. circular) order. In such a case, we write 
 as a shortcut for R; we omit the superscript X when X is clear by context. For each , the element  is the right near neighbor of x. When we want to make no distinctions about X being linear or circular, we simply state that X is an ordering. Note, however, that every ordering is either linear or circular, and it cannot be both at the same time.

Every ordering 
 that we shall consider is embedded in some larger circular order. Hence, all the operations on the indices of X are taken modulo n, regardless of whether X is linear or circular. We use the standard interval notation applied to orders, though we call them ranges to avoid confusions with interval graphs. So, the range 
 of X is the linear ordering 
 where, as stated before, indices are modulo n. Similarly, the range 
 is obtained by removing the rightmost element of 
, the range 
 is obtained by removing the leftmost element from 
, and the range 
 is obtained by removing both the leftmost and rightmost elements from 
. The reverse of X is the ordering 
 = 
, …, 
, where 
 is linear if and only if X is linear. We write 
 as a shortcut for 
 and we omit X when it is clear from context. Note that 
 for every , while 
 equals 
 if and only if X is circular. For each , the element  is the left near neighbor of x. If X and Y = 
, …, 
 are linear orderings, then  denotes the linear ordering 
, …, 
, 
, …, 
.

The notation that we use for ranges clashes with the usual notation for ordered pairs. Thus, we write  to denote the ordered pair . The unordered pair formed by x and y is, as usual, denoted by . Also, for the sake of notation, we sometimes write #S to denote the cardinality of a range S. For any function f, we write 
 to mean the identity and 
.

2.2. Contigs, round representations, and proper circular-arc graphs
In this section we present an alternative definition of proper circular-arc graphs that follows from [5], [29]. These definitions are based on the notion of round representations, which are combinatorial views of proper circular-arc models (see [30]), and the terminology that we use follows that of [6], [10].

A contig is a pair 
 where 
 is an ordering of pairwise disjoint sets, and 
 is a mapping from  to  such that:

(i)
, for every ,

(ii)
 is linear and 
, or 
, and

(iii)
 for every .

We classify each contig ϕ as being either linear or circular according to whether  is linear or circular. Note that ϕ is linear if and only if 
.
We use a convenient notation for dealing with the range 
. For , we write 
 to mean that 
. Similarly, we write

Image 1
to indicate that 
, and
Image 2
to indicate that either  or 
. With the ⟶-notation, we can rewrite conditions (i)–(iii) as follows:
(i)
 and

Image 3
for every ,
(ii)
ϕ is linear and

Image 4
, or 
 and
Image 5
, and
(iii)
either

Image 6
or
Image 7
for every .
Fig. 1 depicts three contigs with their corresponding ⟶ relation.
Fig. 1
Download : Download high-res image (79KB)
Download : Download full-size image
Fig. 1. Two linear contigs ϕ and ψ and a circular contig ρ. Each contig • is depicted with their corresponding ⟶• relations that corresponds to the semiblock ordering  and the mappings R• and 
. The mapping 
 is also shown.

The sets in  are referred to as semiblocks of ϕ, while  is the set of vertices of ϕ. For simplicity, we write 
 and 
 as shortcuts for 
 and 
. Recall that 
 and 
 are the left and right near neighbors of B for every . Similarly, we say that 
 is the right far neighbor of B. The left far neighbor of B is the unique semiblock 
 such that 
 if and only if 
, for every . Two other mappings are highly used in this manuscript: 
 and 
 are the unreached right and unreached left semiblocks, respectively. As usual, we do not write the subscript and superscript ϕ for L, R, 
, 
, 
, 
, and ⟶ when ϕ is clear by context. Fig. 1 shows the values of R, 
, and 
 for some contigs. Note that ϕ is linear if and only if  (and 
) for some semiblock B.

A round representation is a family 
 of vertex-disjoint contigs such that either  or 
 is linear for every . A straight representation is a round representation whose contigs are all linear. We extend the notation used for contigs to round representations:

•
 and 
,

•
if 
, then 
 for every 
,

•
if 
, then 
 if and only if  and 
, and

•
Image 8
if and only if  or
Image 9
.
As usual, we omit Φ from the previous notation. Note that Φ is uniquely determined by the triplet 
, thus sometimes we write 
 as an alternative definition of Φ.1 Any (linear) contig ϕ can be regarded as the (straight) round representation 
, thus all the definitions that follow for round representations hold for contigs as well. We say that a semiblock  is a left (resp. right) end semiblock when 
 (resp. 
). Equivalently, B is a left (resp. right) end semiblock of Φ if and only if B is the leftmost (resp. rightmost) of its contig, which happens if and only if  (resp. ). We treat ⊥ as a special semiblock outside , one for which  for every 
. In Fig. 1,  and  are round representations, whereas  is not. Moreover, 
 and 
 are the left end semiblocks of Φ, while γ has no end semiblocks. Indeed, a round representation is straight if and only if it contains end semiblocks.
Each round representation Φ defines a graph  that has  as it vertex set, where  and  are adjacent, for , if and only if

Image 10
, or
Image 11
. Observe that: each contig  defines a component  of , each semiblock of Φ is a semiblock of , and 
 for every vertex  of Φ. We say a semiblock of  is isolated or universal according to whether it is isolated or universal in . Similarly, two semiblocks of  are adjacent or twins when they are adjacent or twins in . We write 
 to denote the set of semiblocks adjacent to B and 
; we drop the subindex Φ as usual. Note that 
. In Fig. 1,  is obtained from a cycle with four vertices 
, 
, 
, 
 by adding 
 twins of 
, for . Also, 
 is universal in  but not in .
A graph G is a proper circular-arc (PCA) graph if it is isomorphic to  for some round representation Φ. In such a case, G admits Φ, while Φ represents G. It is a well known fact that PCA graphs, as defined here, are precisely those graphs that admit a PCA model, as defined in Section 1 [5], [10], [29]. PCA graphs are characterized by a family of minimal forbidden induced subgraphs, as in Theorem 1. There, 
⁎
 denotes the graph that is obtained from H by inserting an isolated vertex, while 
 denotes the cycle with n vertices. Graph 
 
⁎
 is also denoted by 
.

Theorem 1

[31]
Proper interval graphs are defined as PCA graphs, by replacing round representations with straight representations. That is, a graph is a proper interval graph (PIG) graph when it is isomorphic to  for some straight representation Φ. It is well known that PIG graphs are precisely those graphs that admit PIG models [5], [6]. PIG graphs are also characterized by minimal forbidden induced subgraphs.

Theorem 2

[32]
A PCA graph is a PIG graph if and only if it does not contain 
 for , and 
 as induced subgraphs.

Two semiblocks  of a round representation Φ are indistinguishable when 
 and 
 (e.g., 
 and 
 in Fig. 1). Clearly, if , then all the semiblocks in  are pairwise indistinguishable in Φ. It is not hard to see that B and W are twins when they are indistinguishable. We say that Φ and a round representation Ψ are equal when Φ can be obtained from Ψ by permuting some indistinguishable semiblocks in the contigs of Ψ. Of course, Ψ is an alternative round representation of . A PCA graph can also have non-equal representations. Indeed, 
, which is called the reverse of Φ, is a representation of . By definition, 
, 
, and 
.

For , we write  to denote the round representation Ψ such that  and 
 if and only if 
 for every . Observe that Ψ is a round representation of , thus Ψ is referred to as the representation of Φ induced by . Similarly, the removal of  from Φ is the representation ; this time, .

We find convenient to extend the notion of ranges to round representations; the rationale behind these extension is discussed later. Let 
 be a semiblock of a contig 
 of the round representation Φ, for . When 
, the range 
 of Φ is defined as the range 
 of 
. When 
, the range 
 of Φ is defined as the range 
 of 
. That is, 
 is obtained by traversing 
 from 
 to its right end semiblock, followed by the range obtained by traversing 
 from its left end semiblock to 
. This non-standard definition is useful to deal with the different possible orderings of the contigs of Φ; in this case, 
 would immediately precede 
. For instance, 
 of  in Fig. 1 is 
. The ranges , , and  of Φ are defined analogously.

Our definition of ranges allows us to define some robust versions of L, R, 
, and 
. By definition, any range 
 of Φ is a linear ordering, thus 
 is the semiblock that follows B in , for any 
. Let 
 and 
 be the contigs that contain 
 and 
, respectively. By definition,  could contain the right end semiblock 
 of 
 followed by the left end semiblock 
 of 
. Although 
 and 
, the semiblocks 
 and 
 are well defined. The robust version 
 of 
 behaves exactly as 
, with the exception that it maps 
 to 
. Similarly, the robust version 
 of 
 maps 
 to 
 and B to 
 for 
. The robust versions 
 of 
, and 
 of 
 are defined analogously. For the sake of notation, we write 
, 
, 
 and 
 when Φ and  are clear. Thus, if we consider the range 
 of  in Fig. 1, then 
, 
, thus 
, and 
; note, however, that 
.

Before we advance, we describe the rationale behind our definitions of round representations, ranges, and the robust mappings 
 and 
. Our main goal in this article is to insert a new vertex v into a round representation Φ to obtain a new round representation Ψ. As we shall see, v can have neighbors in at most two contigs 
 and 
 of Φ (possibly 
). To insert v, we must join the semiblocks in 
 together with v to form a new contig ψ that “replaces” both 
 and 
, i.e., 
. Since ψ is a contig, 
 must be somehow together in Ψ. Prior to the insertion of v, any pair of contigs of Φ could play the role of 
 and 
, thus it is inconvenient to prefix an ordering of the contigs of Φ. As this ordering is absent, it makes no sense to define the follower (resp. predecessor) of a right (resp. left) end semiblock. However, once v and  are given, we have access to the neighbor semiblocks in 
 and 
. As we shall see, there is no efficient way to determine if 
; all we can query is if v is adjacent to end semiblocks. Yet, since ψ is a contig, the semiblocks adjacent to v must appear consecutively in ψ. In other words,  should be a range of 
 of 
. We want to make no case distinctions according to whether 
 or whether 
 has end semiblocks. This is the reason why ranges are defined for semiblocks in different contigs, and why the range of an ordering can contain its rightmost element. Finally, to test if v can be inserted, we have to check some conditions on 
 for 
. However, this semiblock is not well defined when 
 and, in this case, the role of this semiblock is played by the left end semiblock of 
. The robust definition of 
 allows us to treat the case in which 
 in the same way as we treat the other case.

Although we need access to  for the robust versions to be efficient, there is one case in which specifying  is not required. If 
 for (possibly equal) contigs 
, then 
 and 
 for the left end semiblock 
 of 
 and the right end semiblock 
 of 
 (if existing), , while 
 and 
 for every other semiblock. In this case, we refer to Φ as being robust.

By definition, each contig ϕ of a straight representation Φ is “equivalent” to a range 
 of Φ, where 
 is a left end semiblock, 
 is a right end semiblock, and 
 has no end semiblocks. The term “equivalent” employed here means that  equals 
; moreover, 
 is a round representation of some component 
 of . We refer to 
 simply as a contig range of Φ that describes 
. The following observation then follows.

Observation 3

If Φ is a straight representation of a graph G, then every component of G is described by a contig range.

In a similar way, the co-components of co-bipartite PCA graphs are described by co-contig pairs (see Fig. 3). Let Φ be a round representation of a co-bipartite graph G, and observe that Φ is robust. Say that a non-universal semiblock  is a left co-end semiblock of Φ if 
; similarly, B is a right co-end semiblock of Φ when 
. A co-contig range is a range 
 such that 
 is a left co-end semiblock, 
 is a right co-end semiblock, and 
 has no co-end semiblocks. As it is shown in [10], [29], 
 
 is also a co-contig range for any co-contig range 
. Moreover, 
 
 is a co-component of G, and 
 
 is a co-bipartition of 
. The pair 
 
 is said to be a co-contig pair of Φ that describes 
, while 
 
 is a co-contig of Φ.

Fig. 3
Download : Download high-res image (78KB)
Download : Download full-size image
Fig. 3. A round representation Φ with three co-contigs ϕ1, ϕ2, and ϕ3 (gray lines are used to depict the edges that are implied by black edges). The left co-end semiblocks of Φ are B1, B2, B3, B6, and B7, while its right co-end semiblocks are B1, B2, B5, B6, and B8. Note that each co-contig pair other than 〈B2,∅〉 describes a co-component of G(Φ).

Theorem 4

[10], [29]
If Φ is a round representation of a co-bipartite graph G, then Φ is robust and every co-component of G with at least two vertices is described by a co-contig pair.

Our definition of co-contig pairs above explicitly excludes universal semiblocks. Clearly, each vertex in a universal semiblock induces a co-component of G. We say that a universal semiblock B is both a left co-end and right co-end semiblock. Hence,  is a co-contig range,  is a co-contig pair that describes 
, and  is a co-contig of Φ.

As defined so far, co-contigs only represent co-bipartite graphs. For the sake of generality, we say that a round representation Φ is a co-contig of Φ when  is co-connected. Note that, consequently, we may not assume that co-contigs are robust or have co-contig ranges. Also, to make clear the parallelism between contigs and co-contigs, we use lowercase Greek letters to name the co-contigs of Φ when  need not be co-connected.

3. The reception theorem: a certification roadmap
Receptive pairs are the main concept used in [10] for dealing with the insertion of a non-isolated vertex v into G. In simple terms, a pair of semiblocks is receptive when it witnesses that  is PCA. Its definition, however, depends on whether v belongs to an end semiblock or not. Suppose H is represented by a round representation Ψ and  is a semiblock of Ψ. Let 
 if  is not a left end semiblock, and 
 otherwise. Similarly, 
 if  is not a right end semiblock, while 
 otherwise. By definition,  is a round representation of G. The pair 
 is referred to as being receptive in Φ, while Ψ is the -reception of 
 in Φ. Strictly speaking, v plays no role when deciding if a pair is receptive; 
 is receptive if and only if  is a PCA graph for any w with 
 (recall v is not isolated). When applied to H and v, we obtain that H is a PCA graph if and only if G admits a round representation Φ with a receptive pair 
 such that 
.

As defined, the concept of receptive pairs applies to any round representation. Yet, the dynamic algorithm deals with a rather restricted subset of round representations. Say that a semiblock B of a round representation Ψ is a block when B is a block of . If every semiblock of Ψ is a block, then Ψ is a round block representation and all its (co-)contigs are referred to as block (co-)contigs. When Ψ is a round block representation, the round representation  is almost a block representation. In fact, it can be easily observed that 
 and 
 are the unique possible pairs of indistinguishable semiblocks of Φ, while Φ has at most two universal semiblocks, one in 
 and the other outside 
. For the sake of notation, we refer to Φ as v-receptive when it contains a receptive pair 
 such that:

•
, and

•
no pair of semiblocks in 
 are indistinguishable.

Theorem 5

Let H be a graph such that  is not isolated. Then, H is PCA if and only if  admits a round representation Φ that is v-receptive. Furthermore, the -reception of Φ is a round representation of H.

The above observation is quite straightforward, but it tells us little about the v-receptive representations of G. In [5], [6], [10], tools for efficiently finding and transforming Φ into a round representation of H are developed. The Receptive Pair Lemma of [10], that generalizes some results in [5], [6], is one of such tools. For the sake of simplicity, we present a unified view of [5], [6], [10].

Let Φ be a round representation and 
 be semiblocks of . A semiblock 
 witnesses that 
 is receptive in Φ when (see Fig. 4):

(wita)
 is an end semiblock,

Image 12
, and
Image 13
, or
(witb)
Image 12
,
Image 14
,
Image 15
, and
Image 16
.
The essence of the insertions methods in [5], [6], [10] is captured in the next lemma.
Fig. 4
Download : Download high-res image (102KB)
Download : Download full-size image
Fig. 4. The possibilities for a semiblock Bm to witness that 〈Bl,Br〉 is receptive. A dashed edge from X to Y means that

Image 17
, while X⟶Y is possible when the edge is missing (and Φ is a round representation). Also, some of the depicted semiblocks could be equal. The corresponding {v}-receptions are drawn in gray.
Lemma 6

Receptive Pair Lemma [5], [6], [10]
Let 
 be two (possibly equal) contigs that contain the semiblocks 
 and 
, respectively. Then, 
 is receptive in 
 if and only if 
 witnesses that 
 is receptive in 
.

The Receptive Pair Lemma can be proved with not much effort by following the definitions (see [10] and Fig. 4). Indeed, if 
 witnesses that 
 is receptive, then a -reception is obtained by: inserting  immediately to the right of 
 if (witb) or 
; or inserting  immediately to the left of 
 if (wita). On the other hand, if Ψ is a -reception of 
, then either  or  (if ) witnesses that 
 is receptive. The Receptive Pair Lemma is an asymmetric tool: it suffices to find one v-receptive representation of G to claim that H is PCA, while all the round representations of G must be discarded before claiming that H is not PCA. Moreover, a round representation of H is available when H is PCA, whereas no minimally forbidden is found when H is not PCA. The Reception Theorem combines Theorem 5 with a slight generalization of the Receptive Pair Lemma that takes  into account. For a better exposition, we consider only the case in which H is connected. Nevertheless, conditions (rec1)–(rec3) are general.

Corollary 7 Reception Theorem

Let H be a connected graph with a vertex v. Then, H is PCA if and only if  admits a round representation Φ that contains two semiblocks 
, 
 such that:

(rec1)
,

(rec2)
no pair of semiblocks in 
 are indistinguishable,

(rec3)
 witnesses that 
 is receptive in Φ.

Technically speaking, (rec1)–(rec3) are statements dealing with pairs of semiblocks. For the sake of simplicity, we say that a round representation Φ satisfies a subset P of (rec1)–(rec3) when Φ has two semiblocks 
 and 
 that simultaneously satisfy all the conditions in P.

Despite the simplicity of the Reception Theorem, the problem of finding a v-receptive representation is not an easy task, specially when the time constraints are tight. Most of the effort in [5], [6], [10] is spent on finding such a v-receptive representation efficiently. The problem of finding a minimally forbidden is mostly, but not completely, ignored in these articles. In fact, the Reception Theorem made its first appearance in [5], where the authors consider a rather restricted case in which G is PIG and both G and H are connected. The advantage of this case is that G admits only two contigs, namely γ and 
. By (rec1),  must be a range of γ, which implies that there are exactly two contigs ϕ and 
 that can satisfy (rec1) and (rec2). In their proof of the Reception Theorem, Deng et al. [5] exhibit a minimally forbidden of H when either  is not consecutive in γ or ϕ does not satisfy (rec3). Although it is not explicit in [5], an  time algorithm for obtaining such a minimally forbidden, when γ and  are given as input, follows as a by-product. It is not hard to extend this certified algorithm to the case in which the PIG graph G can be disconnected.

Our aim in the present manuscript is to design a certifying and dynamic algorithm for the recognition of PCA graphs, following the framework discussed in Section 1. Thus, we ought to compute a minimally forbidden each time an insertion of a vertex v fails. The main idea is to prove the Reception Theorem following the same path as Deng et al. That is, we show a minimally forbidden of H when no round representation of  is v-receptive. However, we spend 
 time to build the minimally forbidden.

4. The abstract data types
As anticipated, the algorithm keeps two differentiated high-level data structures. One implements a round block representation to witness that G is PCA, while the other represents an induced path of G that is extended to a negative witness when the insertion of a vertex fails. In turn, these high-level structures depend on other low-level data structures that implement contigs and connectivity queries. The purpose of this section is to introduce the different data types, focusing mainly on their abstract interface, while still giving enough implementation details. The goals behind the interface-driven presentation are twofold. On the one hand, many of the operations presented here were developed in the previous articles of the series, although some tweaking is required. So, this section both sums up the work in [5], [6], [10] and presents the new details required to hide the low-level manipulation of structures from the other, more theoretical, sections. On the other hand, the interface is the sole point of access to the witnesses from the outside world and, as previously stated, the user must be granted an efficient and convenient way of manipulating the witnesses.

4.1. Contigs
The data structure we use to implement contigs is the same as discussed in [10]. For completeness, we describe its interface as an abstract data type; for implementations details see [10].

Each contig ϕ presents itself as the collection of semiblocks , where each  stores its set of vertices. Also, each  and each  allow the user to store some additional data. The internal structure and the semiblocks and vertices of ϕ are exclusively owned by ϕ, thus the modifications applied on ϕ have no impact on the data structures of other contigs. Moreover, a user cannot directly access ϕ, a semiblock , or a vertex . Instead, a semiblock (resp. vertex) pointer 
 (resp. 
) associated to ϕ must be employed to access B (resp. v). For simplicity, we also say that ϕ is referenced by 
 (resp. 
). The pointer 
 is aware of the internal structure of ϕ, thus it can be used to manipulate both B and ϕ. However, 
 knows nothing about the other semiblock pointers associated to ϕ or the semiblocks in . Hence, there is no way to answer, in  time, if 
 is associated to the same contig as other pointer 
. (Roughly speaking, ϕ is similar to doubly linked lists in which the semiblocks play the role of nodes and semiblock pointers are pointers to the nodes.)

The following functions that operate on contigs and semiblocks are provided in [5], [6], [10]. As usual, we use lower case Greek letters for contigs, capital Roman letters for semiblocks, and tildes to indicate pointers.

newContig()
creates a new contig that contains only one block  and returns the pointers to B and v. Complexity:  time.

vertices(
)
returns (an iterator to) 
. Complexity:  time.

semiblock(
)
returns a pointer to the semiblock that contains v. Complexity  time.

returns a semiblock pointer to  for 
. Complexity:  time.

returns a list of semiblocks pointers that represents the range 
 of 
, where 
 is the contig referenced by 
 for . The ranges 
, 
 and 
 work similarly. Complexity: 
 time.

receptive(
, 
)
is true when 
 is receptive in 
, where 
 and 
 are the contigs referenced by 
 and 
, respectively. Complexity: 
 time.

reception(
, 
)
transforms 
 into the -reception ψ of 
, where 
 and 
 are the contigs referenced by 
 and 
, respectively. Returns a pointer to . Requires 
 to be receptive in 
. Complexity: 
 time.

remove(
)
transforms the contig ψ referenced by 
 into the contigs of  and the contig γ whose only semiblock is B. Note that  has either one or two contigs, thus at most three contigs are generated. Complexity: 
 time.

separate(
, W)
transforms the contig γ referenced by 
 into a contig ϕ representing  that is obtained by splitting B into two indistinguishable semiblocks  and W in such a way that 
, 
, and 
. The other semiblocks of γ are not affected by this operation. It requires , and it has no effects when either  or . Note that W is not a semiblock pointer, but a set of vertex pointers. Complexity:  time. (See Fig. 5.)

Fig. 5
Download : Download high-res image (124KB)
Download : Download full-size image
Fig. 5. Effects of some operations on contigs: γ equals compact(
) for ; ϕ equals separate(
, W) for ; ψ equals join(
, 
) for B1 ∈ ϕ1 and B2 ∈ ϕ2; and {ϕi,ϕ2} equals split(
, 
) for B1,B2 ∈ ψ. Dashed lines represent non-edges, while missing lines represent edges that could be present of absent. Note that some blocks may be equal, while B3 (resp. B4) does not exist when B1 (resp. B2) is universal.

separate(W, 
)
implements separate(
, ) in  time.

compact(
)
transforms the contig ϕ referenced by 
 into a contig γ representing  that is obtained by joining the indistinguishable semiblocks B and  into one semiblock  in such a way that 
 and 
. The other semiblocks of ϕ are not affected by this operation. It has no effects when B and  are not indistinguishable. Complexity:  time. (See Fig. 5.)

join(
, 
)
transforms 
 and 
 into a new contig ψ that represents 
, where 
 is the contig referenced by 
 for . The semiblocks of ψ appear as in the ordering 
 • 
 • 
 • 
. It has an undefined behavior when either 1. 
 or 
 is not a left co-end block or 2. 
 and 
 are associated to the same contig. Time complexity:  time, where u is the number of universal semiblocks in ψ. (See Fig. 5.)

split(
, 
)
transforms the contig ψ referenced by 
 and 
 into two co-contigs 
 and 
 in such a way that 
. The semiblocks of 
 appear as in the ordering 
, while the semiblocks of 
 appear as in the ordering 
. It has an undefined behavior when either 1. 
 or 
 is not a left co-end block or 2. 
 and 
 are associated to different contigs. Note that this operation requires 
; if this is not the case, then 
, thus the operation works as if the parameters where inverted. Time complexity:  time, where u is the number of universal semiblocks in ψ. (See Fig. 5.)

Several of the above operations transform a contig ϕ into a new contig ψ. This means that the physical structure of ϕ is changed to obtain ψ, thus ϕ ceases to exist as such. The semiblock pointers associated to ϕ are not invalidated, though; instead, they get associated to ψ. We remark, also, that split(
) reverses the effects of join(
, 
), but the converse is not true in general. The subtle problem is that split outputs co-contigs, and co-contigs involve two contigs when they represents disconnected graphs (see Fig. 3 (
) and Fig. 5 (
)). We deal with this problem in Section 4.3.
4.2. Semiblock paths
Together with each contig ϕ, the dynamic algorithm keeps a path of ϕ that is used for the generation of negative witnesses. Say that a semiblock  is long when 
; those semiblocks that are not long are referred to as short. A semiblock path  of ϕ is an ordering 
 of a subset of  such that:

•
 and

Image 18
for every  and .
•
If ϕ is linear, then  is linear and 
 and 
 are the end semiblocks of ϕ.

•
If ϕ is circular, then  is circular and 
 and

Image 19
.
•
If ϕ contains a long semiblock, then .

Each semiblock path 
 is implemented with a doubly linked list of semiblock pointers 
; the list is circular if and only if  is circular. Conversely, each semiblock  stores a path pointer to the position that 
 occupies in ; this is a null value when . Thus,  time is enough to detect if B belongs , to access and remove 
 from , and to insert new semiblock pointers in  to the left or right of 
.
We now show how to efficiently update  (and the path pointers of ϕ) each time ϕ is updated. As discussed in the previous section, there are eight operations that change the structure of a contig: newContig, leftSeparate, rightSeparate, compact, join, split, reception, and remove. Updating  in  time is trivial for the first four operations. Regarding join and split, note that the input and output contigs represent co-bipartite graphs. Thus, the semiblock paths of the input contigs can be erased in  time because they have at most four semiblock pointers. After the semiblock paths are erased, we build the new semiblock paths from scratch as in the next lemma.

Lemma 8

Let 
 be a left co-end semiblock of a contig ϕ. If a semiblock pointer to 
 is given, then a semiblock path can be computed in  time.

Proof

First suppose ϕ is a linear contig and observe that, in this case, 
 is the left end semiblock of ϕ. Indeed, if 
 is not a left end semiblock, then 
, 
, and 
 are pairwise non-adjacent semiblocks, which contradicts the fact that  is co-bipartite. Similarly, 
 is the right end semiblock of ϕ. Thus, 
 is a semiblock path, where  is the minimum such that 
 is a right co-end semiblock. Clearly, this semiblock path can be computed in  time.

Now suppose ϕ is circular and let 
, 
 and 
. Recall that 
 is a left co-end block while 
 and 
 are right co-end blocks. If 
, then 
 is long and 
, 
, 
 is a semiblock path. Otherwise, 
 and 
 is a partition of . Moreover, 
 and 
 because ϕ is circular. We consider two cases:

Case 1:
ϕ contains a semiblock path 
, 
, 
. Note that at least one of 
, 
, 
 belongs to 
 (resp. 
); say 
 and 
. If 
, then 
 and 
, which implies that 
, 
, 
 is a semiblock path. Similarly, if 
, then 
, 
, 
 is a semiblock path.

Case 2:
ϕ contains no semiblock B such that 
. In this case, 
, 
, 
, 
 is a semiblock path.

Note that
Image 20
, thus 
, 
, 
 is a semiblock path if and only if 
. Similarly, 
, 
, 
 is a semiblock path if and only if 
. By Cases 1 and 2, we can compute a semiblock path in  time. □
In the case of reception(
, 
) we have to modify both 
 and 
 to obtain , where 
 and 
 are the contigs referenced by 
 and 
, and ψ is the -reception of 
. This update is applied after reception is completed, thus we have access to a semiblock pointer of . The following lemma shows how to obtain  spending no more time than the required for reception.

Lemma 9

Let 
 and 
 be two (possibly equal) contigs such that 
 contains a receptive pair 
 for 
 and 
, and ψ be the -reception of 
 in 
. Given a semiblock pointer to  in ψ, it takes 
 time to transform the semiblocks paths 
 and 
 into a semiblock path of ψ.

Proof

Recall that, by definition, 
 and 
. Consider the following alternatives.

Alternative 1:
B is an end semiblock of ψ. Suppose B is the left end semiblock as the other case is analogous. By definition, 
, 
 is the left end semiblock of 
, and 
. Traversing 
 in ψ, we can check if 
 for the semiblock 
 that follows 
 in 
. If affirmative, then a semiblock path of ψ is obtained by replacing 
 with B in 
; otherwise, a semiblock path of ψ is obtained by inserting B before 
 in 
.

Alternative 2:
B is not an end block of ψ, thus 
 in ψ, 
, and 
. Traversing 
, we can check if 
. If affirmative, then B is long and B, 
, 
 is a semiblock path. Suppose, from now on, that

Image 21
. By traversing 
 we can find the leftmost semiblock 
 and the rightmost semiblock 
 of 
 such that 
 and 
 (possibly 
). Similarly, we can obtain the leftmost semiblock 
 and the rightmost semiblock 
 of 
 such that 
 and 
. Note that these semiblocks exist because ψ is a contig. If 
, then 
 is not an end semiblock of 
, thus 
 and 
; consequently, 
 is a semiblock path of . Otherwise, 
 is the right end semiblock of 
 and 
 is the leftmost end semiblock of 
 (perhaps 
). Then, the ordering obtained from 
 by inserting B between 
 and 
 (removing 
 if 
 and 
 if 
) is a semiblock path of ψ.
Using the path pointers, we can apply all the modifications required on 
 and 
 in  time. We conclude, therefore, that 
 time suffices to transform 
 and 
 into a semiblock path of ψ. □
Finally, to update  after remove(
), where ψ is the contig referenced by 
, we have to revert the process done in the previous lemma. After the completion of remove, we obtain at most three contigs, namely 
, 
, and γ, where 
 is referenced by 
, 
 is referenced by 
, and γ is referenced by 
. The computation of  is trivial; to compute 
 and 
 we apply the following lemma before invoking remove.

Lemma 10

Let B be a semiblock of a contig ψ. Given a semiblock pointer to B, it takes 
 time to transform  into 
, where 
 is the family of contigs of .

Proof

If , then 
 and  is a semiblock path of 
. Suppose, then, that  and consider the following alternatives.

Alternative 1:
B is an end semiblock of ψ. Suppose B is a left end semiblock, as the other case is analogous, and note that 
 and 
 is the leftmost end semiblock of 
. Let  be the ordering obtained by replacing B with 
 in 
. In  time we can obtain the first two semiblocks 
 and 
 that follow B in 
. If 
, then  is a semiblock ordering of 
; otherwise, the ordering obtained by removing 
 from 
 is a semiblock ordering of 
.

Alternative 2:
B is not an end semiblock of ψ, thus 
 for 
 and 
. First we search if 
 has a long semiblock. This happens only if , in which case 
, 
, and, thus, 
 for every 
. Marking the position of every semiblock in 
, we can check in  time if 
 appears after 
 in 
 for some 
. If affirmative, then W is long and 
, W, 
 is a semiblock path of 
; otherwise, 
 has no long semiblocks. When 
 has no long semiblocks, we traverse 
 to check if 1. 
, 2. 
, 3. 
, and 
, where 
, 
, 
, and 
 are the semiblocks of  such that 
, 
, 
, and 
 (unless 
 or 
 in which case 
 and 
, respectively). Replacing B with  if 1. and removing 
 if 3., or replacing B with  if 2. and removing 
 if 4., we obtain a semiblock path of 
. If neither 1. nor 2. holds, then we transform  into the ordering  that is obtained by first replacing B with  and then removing 
 if 3. and 
 if 4. If  or  is circular, then  is a semiblock path of 
; otherwise, 
, thus we split  into the suborderings that have  as rightmost and  as leftmost to obtain semiblock paths of 
 and 
, respectively. □

4.3. Round representations
To implement a round representation Φ we use a pair of doubly linked list 
 and a connectivity structure (see below). For each , a semiblock pointer associated to ϕ (resp. 
) is kept in 
 (resp. 
). (The semiblock 
 of ϕ plays the same role as the pointer to the first node in a linked lists when implementing the abstract data type; that is, 
 is used to access ϕ.) Thus, both physical contigs ϕ and 
 are stored for each contig . The reason why 
 is kept is to avoid the cost of reversing ϕ. If 
 is associated to ϕ, then ; moreover, B is the left end semiblock of ϕ when ϕ is linear. Conversely, B keeps a contig pointer to the position of 
 inside 
 and a round pointer to the list that contains 
 (i.e., 
 or 
). The contig pointer is used, among other things, to remove 
 from 
 when its associated contig is joined to some other contig. Of course, these pointers have a null value when B is not referenced by a pointer in 
. Finally, each vertex v of a contig  keeps a reverse pointer to its incarnation in 
.

Recall that all the contigs of a round representation Φ are linear when ; this invariant must be satisfied by the data structure. Thus, we need some way to detect if an operation on a linear contig ϕ yields a circular contig ψ. Actually, the only operation in which we are ignorant about the linearity of ψ is when we compute the -reception of 
. As it is shown in [6], the only possibility for ψ to be circular is when 
 contains the right end semiblock of ϕ. To detect this case, we need to know if two end semiblocks belong to the same contig. As it was proved in [6], the connectivity problem is not solvable in  time when both insertions and removal of semiblocks are allowed. Thus, a connectivity data structure is kept to solve this problem. Its interface provides the following operations:

create()
returns an empty connectivity structure. Complexity:  time.

add(
)
adds 
 to the connectivity structure. Complexity: 
 time.

remove(
)
removes 
 from the connectivity structure. Complexity: 
) time.

opposite(
)
if B is an end semiblock, then returns a pointer to the other end semiblock of the contig that contains B; otherwise it returns ⊥. Complexity: 
 time.

There are three flavors of the structure according to the operations supported by the main algorithm. In the incremental structure 
 and 
, in the decremental structure 
 and 
, and in the fully dynamic structure 
 [6], [10].
Suppose we need to traverse the range 
 of 
 for some contigs 
 and 
 of Φ, where 
 and 
. A simple method is to apply R and L from semiblock pointers 
 and 
 associated to 
 and 
, respectively. Obviously, each pointer 
 is computed from those given by the user as input. However, as some operations reverse contigs without informing the user, we cannot assume that the pointers given by the user are associated to contigs of Φ. If, say, 
 is associated to 
 and 
 is associated to 
, then the method above ends up traversing the range 
 of 
. To simplify the specification of the algorithms, we say that 
 is a Φ-pointer, or that it has type Φ, when 
 is associated to some contig . Of course, every semiblock pointer has type either Φ of 
. Each semiblock pointer to B of type 
 is called a reverse of 
. Using our new terminology, the method above requires 
 and 
 to be Φ-pointers. We remark that round representations provide no efficient operations to query the type of an arbitrary semiblock pointer.

To avoid dealing with the pointers of round representations, we implement several operations that define an interface similar to the one used for contigs. As usual, we use capital Greek letters for round representations, capital Roman letters for semiblocks, and tildes for pointers.

straight(Φ)
returns true if Φ is straight. For the implementation we test if a pointer in 
 references an end semiblock. Complexity:  time.

newContig(Φ)
adds to Φ a new contig whose only block is , and returns 
. Requires Φ to be straight. For the implementation, we add a new physical contig to both 
 and 
. Complexity:  time.

reversed(
)
returns a reverse of 
. For the implementation, we invoke semiblock(
) for the reverse pointer 
 of . Complexity:  time.

type(
)
returns the type of 
, i.e., a pointer to either Φ or 
. Requires B to be an end semiblock. Let ϕ be the contig referenced by 
. For the implementation we access the round pointer of the physical semiblock referenced by either 
 (if B is a left end semiblock in ϕ) or a reverse of 
 (if B is a right end semiblock in 
). Complexity:  time.

reverse(
)
reverses the contig of Φ that contains B. Requires B to be an end semiblock. Applying reversed if required, assume B is a left end semiblock of a contig ϕ. Moreover, suppose, w.l.o.g., that 
, as the other case is analogous. For the implementation, we use the contig and round pointers of B to move 
 from 
 to 
. Then, we use the connectivity structure together with reversed to obtain a 
-pointer 
 to the right end semiblock of ϕ. Finally, we move 
 from 
 to 
. Complexity: 
 time.

receptive(
, 
)
takes two Φ-pointers and returns true if 
 is receptive in Φ. Let 
 and 
 be the contigs referenced by 
 and 
, respectively. For the implementation, observe that 
 is receptive in Φ if and only if 
 is receptive in 
 and either the -reception ψ of 
 is linear or 
 is the unique contig in Φ. When 
, the contig ψ is linear if and only if 
 has no right end semiblocks or W and 
 lie in different contigs, where 
 a right end semiblock. If 
 is an end semiblock, then we can check if 
 is the unique contig in Φ using the round pointer of 
. To check if W and 
 lie in different contigs, a query to the connectivity structure is required. Complexity 
 time.

reception(
, 
)
takes two Φ-pointers to update Φ into the -reception Ψ of 
. Requires 
 to be receptive in Φ, and returns a pointer to v. For the implementation, suppose 
 and 
 are the contigs referenced by 
 and 
, respectively. The first step is to apply reception(
, 
) to transform 
 and 
 into a contig ψ that represents the v-reception of 
. Let 
, and observe that 
 is a left end block of Φ if and only 
. In this case, we access the contig pointer of 
 to remove it from 
. Similarly, if  is a left end semiblock of Ψ, then we add a semiblock pointer to  in Φ and we update the contig pointer of . Finally, we test if 
. This happens when 
 is linear and ψ is circular, in which case  belongs to . Thus, again, we add a pointer to  in 
. Once the update is completed, we apply the same procedure to reversed(
) and reversed(
) to update 
. Finally, we update the connectivity structure. Complexity: 
 time.

remove(Ψ, 
)
transforms Ψ into a round representation Φ of . Requires 
 to be of type 
. For the implementation, we first call remove(
) to transform the contig 
 referenced by 
 into two (possible equal) physical contigs 
 and 
, where 
 contains 
. In the next step we remove 
 from 
 when the contig pointer of B is not null. Then, we check if 
 is a left end semiblock of 
. If affirmative, then there are two possibilities. If  is not straight, then we replace the unique pointer in 
 with a pointer to 
. Otherwise, we insert 
 to 
. After completion, we apply the same transformations to 
 using a reverse of 
. Finally, we remove B from the connectivity structure. We remark that the obtained round representation Φ is not necessarily equal to 
. The reason is that we are not aware of the type of 
. Thus, if 
 has type 
, then when we decide to insert 
 to 
, we are actually computing 
. Complexity: 
.

separate(
, W), separate(W, 
), and compact(
)
work as their contig versions on the contig of Φ that contains B. For the implementation, we apply the corresponding operations on ϕ and 
, where ϕ is the contig referenced by 
. Also, we take care of the contig and round pointers when B is an end semiblock. The details are similar to those described for the previous operations. Complexity:  time for separate and  time for compact.

join(
, 
)
takes a 
-pointer 
 and a 
-pointer 
 and builds the round representation  such that ψ satisfies the same specifications as the contig version of join. Requires 
 and 
 to be left co-end blocks and 
. The differences between this version of join and the one for contigs are the following. First, 
 could be a disconnected co-contig for . In this case, 
 has only two contigs, each of which represents a clique. Second, the output Ψ is implemented as a round representation. To compute join, we apply one, two, or three calls to the contig version of join, according to whether 
 and 
 are disconnected or not. Since ψ is connected, it takes  time to restore all the pointers required by the data structure of Ψ. Finally, the connectivity structure can be updated in 
 time as discussed in [10]. Time complexity: 
 time, where u is the number of universal semiblocks in Ψ.

split(
, 
)
has the same effects as its contig version, but it returns the co-contigs implemented as round representations. Requires 
 and 
 to be left end blocks of the same type. Note that Ψ has a unique contig , thus generating the pointer of the output representations is trivial. The connectivity structure can be updated in 
 time as well [10]. Complexity: 
 time, where u is the number of universal semiblocks in Ψ.

4.4. The witnesses
From the point of view of the end user, the dynamic algorithm keeps a round block representation Γ of the dynamic graph . To work with Γ, users can iterate through the semiblock pointers associated to contigs in Γ, while they execute the operations described in Section 4.1. However, only those operations that do not modify the internal structure of contigs are available, e.g., vertices, L, 
, etc. To update , one of the following operations is applied.

create()
returns an empty round block representation Γ. Complexity:  time.

insert(Γ, N)
transforms Γ into a round block representation Ψ of a graph H such that  for some vertex  with . Returns a pointer to the new vertex v. The operation fails if H is not PCA and, in this case, a minimally forbidden of H is obtained (see below). Complexity: 
 time.

remove(v)
transforms the round block representation Γ containing v into a round block representation of . Complexity: 
 time.

Our goal is not only to implement the above operations that deal with PCA graphs, but also to provide a certifying algorithm for the recognition of PIG graphs. With respect to the positive witness, the latter problem is solved by satisfying the straightness invariant that guarantees that every contig of Γ is linear when  is a PIG graph. Regarding the negative certificate, we implement the following operation.

forbiddenPIG(Γ)
returns a minimally forbidden witnessing that  is not PIG (i.e., a structure that represents a graph of Theorem 2). Complexity:  time.

When insert(Γ, ) is executed and H is not PCA, for , the end user obtains a negative witness. We say that a pair  is a forbidden of H (w.r.t. Γ) when:

•
Φ is a round block representation of an induced subgraph of H,

•
v is fully adjacent to every block in  and not adjacent to every block outside , and

•
 is not PCA.

If every subgraph of 
 obtained by removing  is PCA, then  is a minimally forbidden of H.
In case of failure, the output of insert is a minimally forbidden . To be useful to the end user,  has to be as efficient as possible. The least a user can expect is that 
, 
, 
, and 
 take constant time. This allows the user to traverse the corresponding forbidden graph in  time per edge, and to take advantage of the PCA structure of . Therefore, Φ is implemented with a data structure that satisfies these time bounds. As a consequence, finding a minimal  such that  is not PCA is not enough. We also have to find the near and far neighbors of , and decide which vertices of  survive when v is both adjacent and co-adjacent to B. As it is expected due to the time bounds, Φ shares some of the internal structure of Γ and, consequently, Φ must be discarded (or copied) before applying further operations on Γ.

5. An incremental and certified algorithm
This section is devoted to the implementation of insert (Section 4.4), whose aim is to insert a vertex  into a round block representation Γ of  in 
 time. An algorithm for this problem was given in [10], and the method we present takes advantage of the tools developed in [10]. However, the algorithm in [10] is unable to output a minimally forbidden (or any witness whatsoever) when the insertion fails. The purpose of this section is to complete the algorithm by providing the negative witness. To show that our algorithm is correct, we prove of the Reception Theorem, following the same path as Deng et al. [5]. That is, we show a minimally forbidden of H when no round representation of G is v-receptive.

Because of the 
 time bound, we face two major inconveniences. First, we cannot traverse all the blocks of Γ. Thus, it is impossible to determine whether  (in 
 time) when B and W are arbitrary blocks. This means that we need to infer some of the adjacencies by making appropriate queries on Γ. For this reason, in this section we assume that Γ, and every round representation obtained by transforming Γ, have been preprocessed as in the next observation, even if we are not explicit about this fact. This allows us to answer basic adjacencies queries as in Observation 12.

Observation 11

see e.g. [10]
Let H be a graph and Φ be a round representation of  for some . Given  as input, it is possible to preprocess the semiblocks of Φ in  time so that determining whether v is (fully) adjacent to B can be answered in  time for any  when a semiblock pointer to B is given.

Observation 12

Let H be a graph, Φ be a round representation of  for , and 
, 
 be (possibly equal) semiblocks of Φ. Given semiblock Φ-pointers to 
, the following problems can be solved in 
 time:

(a)
obtain a Φ-pointer to the leftmost (resp. rightmost) semiblock of 
 co-adjacent to v.

(b)
determine whether 
 and 
 (resp. 
 and 
), when a semiblock Φ-pointer to 
 (resp. 
) is given.

The second inconvenience that arises when we want to compute a minimally forbidden, is that doing so requires a heavy amount of case by case analysis. The case by case analysis is somehow inherent to this kind of proofs, as we need to proceed differently according to whether some edge exists or not (and the existence of such an edge may or may not imply the existence of other edges). To alleviate this situation, we make use of adequate forbidden. We say a family  of semiblocks of H is forbidden when  is not PCA;  is adequate (with respect to a round representation Φ) when all the adjacencies between the semiblocks in  can be computed in  time when  and Φ are given as input. Clearly, if  is an adequate forbidden, then a minimally forbidden of H can be obtained in  time when , , and Φ are given. To prove that  is an adequate forbidden family we still have to prove that 
 is not PCA. This task, however, can done by a computer2 (see Appendix A).

We divide our exposition in two major sections, according to whether G and H are co-connected or not. In the remaining of this section, we always use v to denote the vertex being inserted. So, for  we write +B and −B as shortcuts for  and , respectively, and we write ±B to mean a nonempty semiblock in . Also, we write v as a shortcut for  when a semiblock of H is expected.

5.1. Both H and G are co-connected
Throughout this section we consider that both H and  are co-connected. The advantage of this case is that 
 for every pair of block co-contigs Ψ and Γ representing G [29]. By (rec1), we obtain that H is PCA only if the blocks fully adjacent to v are “consecutive”3 in some block co-contig representing G, say Γ. In this case, Γ (and 
) can be “associated” to at most two co-contigs that simultaneously satisfy (rec1) and (rec2). Therefore, it suffices to consider only these  co-contigs to prove the Reception Theorem. We first show how to obtain a minimally forbidden when  is consecutive in none of the block co-contigs representing G. But, before dealing with the consecutiveness of , we solve a rather restricted case in which the input representation Γ contains some “bad” blocks. The existence of such “bad” blocks is what makes it hard to test whether two blocks of Γ are adjacent. Without this hurdle, we can answer more powerful adjacencies queries.

We say that a semiblock B of a co-contig Φ is good when v is not adjacent to B or v is fully adjacent to all the semiblocks in either 
 or 
. If B is good and v is either fully or not adjacent to B, then B is perfect, while B is bad when it is not good. It is not hard to see that Φ satisfies (rec1) only if all its semiblocks are perfect. For such a co-contig Φ to exist, all the blocks of Γ must be good. Lemma 16 shows how to obtain a minimally forbidden when some block in Γ is bad. We consider two prior cases in Lemma 14, Lemma 15 whose common parts appear in the next lemma.

Lemma 13

Let H be a graph with a vertex v, Γ be a block co-contig representing , and 
 be blocks of Γ such that 
 and 
. Given semiblock Γ-pointers to 
, 
, and 
, a minimally forbidden of H can be obtained in  time when any of the following conditions holds.

(a)
v is co-adjacent to 
 and 
 and adjacent to every block in 
, and

Image 22
.
(b)
v is co-adjacent to 
 and to 
, and 

(c)
v is co-adjacent to 
 and 
 and adjacent to every block in 
, 
, 
, 
, and the query 
 costs  time.

(d)
v is co-adjacent to 
 and 
 and adjacent to every block in 
, 
, 
, 
, and the query 
 costs  time.

Proof

We provide  time algorithms to find an adequate forbidden in each case.

(a)
First, we query if 
 as in Observation 12 (b) with input 
, 
, 
; if false, then {
, v, 
, 
} induces a 
 of H. Suppose, then, that 
. Let  be the minimum such that either 
 or

Image 23
. It is not hard to observe that such a value a always exists because the blocks not adjacent to W form the range 
 for every . Moreover (see Fig. 6 (a)):
(i)
 and 
 for every ,

(ii)
 for every .

Thus, by marking every block in 
, the sequence 
, …, 
 can be obtained in 
 time.
Fig. 6
Download : Download high-res image (41KB)
Download : Download full-size image
Fig. 6. Adjacencies of 
 
 in Lemma 13 (a). The blocks are drawn as they appear in the circular ordering . Dotted lines are used for continuity, while dashed lines means an edge could be present or absent.

If

Image 23
, then, by (i) and (ii), it follows that {v, 
, 
, …, 
, 
} induces a co-cycle in H, whose semiblocks are all adjacent to 
. Consequently, a minimally forbidden can be obtained in 
 time. Suppose, then, that 
, thus 
 and 
 are right co-end blocks of Γ.
By (i), the co-end blocks of Γ belong to 
. Since Γ is a co-contig, we conclude that 
 and 
 belong to the same co-contig range, thus v is fully adjacent to all the blocks in the co-contig range that contains 
. Let b be the minimum such that 
, 
, …, 
, 
 induces a co-path (see Fig. 6 (b)). This co-path can be found in  time because v is fully adjacent to 
 for every . Moreover, since 
, it follows that .

If  or v is fully adjacent to 
, then {v, 
, 
, …, 
, 
} is an adequate forbidden (as it contains an induced 
 
 () or 
 
). If  and v is co-adjacent to 
, then, as 
 and 
, it follows that 
, 
, 
, 
, 
, 
 appear in this order, thus 
 is not adjacent to 
. Hence, {v, 
, 
, 
, 
, 
, 
} induces an 
 
 of H (Appendix A.1).

Before dealing with (b), we consider two subcases that are also solved in  time.

(e)
v is co-adjacent to 
, 
, and 
, and 
. By inspection, it can be observed that  = {v, 
, 
, 
, 
, 
, 
 is a forbidden (Appendix A.2). Moreover,  is adequate because we can determine all the adjacencies in  time. Indeed, as 
, it follows that 
; since

Image 24
, then
Image 25
, while the adjacencies between 
 and 
 are obtained in  time by Observation 12 (b) (with input 
, 
, and 
).
(f)
v is co-adjacent to 
 and 
 and 
. Let 
 be the rightmost block in 
 co-adjacent to v, and 
 be the leftmost block in 
 co-adjacent to v. By Observation 12 (a), 
 and 
 can be obtained in  time. By Observation 12 (b), the query of whether 
 can also be answered in  time. If affirmative, then we obtain a minimally forbidden by invoking (e) with input 
. Otherwise, we obtain that 
 and, thus, 
. Again, by Observation 12 (b),  time suffices to find out whether 
; if negative, then we obtain a minimally forbidden by invoking (a) with input 
. When 
, we query whether 
 using Observation 12 (b); if negative, then {
, v, 
, 
} induces a 
, while if affirmative, then 
 and we can obtain a minimally forbidden by invoking (e) with input 
.

(b)
Let W be the rightmost block in 
 that is co-adjacent to v. If 
, then we obtain a minimally forbidden by invoking (f). When 
, we query whether 
 and 
 using Observation 12 (b). If 
, then we obtain a minimally forbidden by invoking (f) with input 
. If 
, then we run (f) with input 
. Finally, if

Image 26
and
Image 27
, then {
, v, −W, 
} induces a 
.
(c)
By Observation 12 (b), we can query in  whether 
 (resp. 
); if so, then we obtain a forbidden using (b) with input 
, 
, 
 (resp. 
). Otherwise, it follows that 
 and, so, {v, 
, 
, 
, 
, 
} is a forbidden (Appendix A.3). Moreover, it is adequate as the only unknown edge is 
 and this edge can be queried in  time.

(d)
As Γ is a block representation, it contains no indistinguishable blocks. Thus,

Image 28
and
Image 29
(hence 
 and 
). Observe that 
 if and only if 
 and 
. By hypothesis, we can query, in  time, whether 
; hence, we can also find out if 
 in  time. Two cases then follow.
Case 1:
. We first check if v is co-adjacent to 
 or 
. If so, then we find a forbidden by calling (b) with input 
, 
, and 
 (in the former case) or 
, 
, 
 (in the latter case). Otherwise,  = {v, 
, 
, 
, 
, 
, 
} is a forbidden (Appendix A.4).

Case 2:
Image 30
. In this case,  = {
, 
, 
, 
, 
, 
, 
} is a forbidden (Appendix A.5).
Whichever the case, the forbidden  is adequate as it has at most two unknown edges, namely 
 and 
. The former can be queried in  time by hypothesis. To find out if the latter edge exists, we observe that 
 if and only if 
. Since 
, then 
. So, by Observation 12 (b) —with input 
, 
, 
—,  time suffices to determine if 
. □

The next lemma describes how to find a forbidden when a long bad block B is given. Recall that B is long when 
. How B was found, or why do we know that B is long are irrelevant questions at this point.

Lemma 14

Let H be a graph with a vertex v, Γ be a block co-contig representing , and  be a long bad block. Given a semiblock Γ-pointer to B, a minimally forbidden of H can be obtained in  time.

Proof

If v is co-adjacent to a block W in 
, then a minimally forbidden can be obtained by invoking Lemma 13 (b) with input 
, 
, 
. Analogously, a minimally forbidden is obtained in  time when v is co-adjacent to a block in 
. Let 
 be the rightmost block in 
 that is co-adjacent to v, and 
 be the leftmost block in 
 that is co-adjacent to v. By Observation 12, 
 and 
 are found in  time, while we can also query whether 
 in  time. If

Image 31
, then we compute a minimally forbidden by invoking Lemma 13 (a). Using Observation 12 (a), we search for a block 
 co-adjacent to v. Moreover, when such a block exists, we query whether 
 and 
 with Observation 12 (b). When 
 and 
, we find a forbidden by calling Lemma 13 (b), while when
Image 32
(resp.
Image 33
), the family {
, v, 
, −W} (resp. {
, v, 
, −W}) induces a 
. Therefore, we may suppose from now on that v is fully adjacent to every block in 
.
Note that, by hypothesis, 
 and

Image 34
. Hence, we can obtain a minimally forbidden in  by invoking Lemma 13 (c) with input 
, 
, and 
 when 
 and 
. Analogously, we obtain a minimally forbidden in  time when 
, by calling Lemma 13 (d). By exchanging the roles of Γ and 
 if required, suppose 
 and, hence, 
.
Recall that

Image 35
by definition. For the next step, we proceed according to whether 
 or not. If 
, then {v, 
, +B, 
, 
, 
, 
} induces an 
 
 (Appendix A.6). When 
, we determine in  time if 
 is a left co-end block by querying whether 
. If 
 is not a left co-end block, then 
 is a block such that 
 and 
. In this case, we obtain a minimally forbidden by calling Lemma 13 (c) with input 
, 
, and 
. (As 
 and 
, we can find out whether 
 by traversing 
. Recall that v is adjacent to every block in 
, thus  time suffices to answer the query). We can suppose, then, that 
 and 
 are left co-end blocks.
Let 
 if v is co-adjacent to 
, and 
 otherwise. Since Γ is a co-contig, 
 and 
 are the only left co-end blocks. Consequently 
, …, 
 induce a co-path for every  such that 
. Moreover, the order of these blocks in  is as in Fig. 7 (a). Let k be the minimum such that either:

(i)
 is co-adjacent to v,

(ii)
k is odd and

Image 36
, or
(iii)
k is even and

Image 37
,
and consider the following cases.
Case 1:
(i) holds; Fig. 7 (b). Then,  = {v, 
, 
, …, 
, 
} induces a co-cycle of length . Suppose k is even and note that 
. Hence 
. Moreover, 
 because otherwise 
 would be a left co-end block different to 
 and 
. Therefore, either 
 or 
, which implies that v is fully adjacent to 
. Consequently,  and  is a forbidden. When k is odd, 
 for every odd , while, because of the minimality of k, 
 for every even . Therefore, 
 is a forbidden.

Case 2:
(ii) holds and (i) does not; see Fig. 7 (c) with . Then,  = {v, 
, 
, …, 
} induces an odd co-path. Moreover, by the minimality of k, we obtain that 
 is adjacent to every block in 
, while 
 and 
 are adjacent to every block in . Hence, 
 is a forbidden.

Case 3:
(iii) holds and (i) does not; see Fig. 7 (c) with . This time,  = {v, 
, 
, 
, …, 
} induces an odd co-cycle. As in case (i), 
 is adjacent to every block of 
, while, by the minimality of k, 
, thus 
. Consequently, 
 is a forbidden.

To compute 
, we proceed as follows. First, we mark with 1 the blocks in 
 and with 2 the blocks in 
. Then we traverse 
 for each  until we find a block co-adjacent to v or a marked block. In the former case (i) holds for k, while in the latter case (ii) or (iii) holds for  when 
 is marked with 1 or 2, respectively. We conclude that  time is enough to find the forbidden. □
Fig. 7
Download : Download high-res image (54KB)
Download : Download full-size image
Fig. 7. Co-paths of H in Lemma 14: (a) shows the position of the blocks in , (b) depicts Case 1 for k odd, and (c) shows Cases 2 and 3. The label 
 means 
.

The case in which B is a short bad block is solved next. Note that, a priori, Γ could contain long bad blocks; yet, we have no evidence about the existence or non-existence of long bad blocks.

Lemma 15

Let H be a graph with a vertex v, Γ be a block co-contig representing , and  be a short bad block. Given a semiblock Γ-pointer to B, a minimally forbidden of H can be obtained in  time.

Proof

Let 
 be the rightmost block in 
 co-adjacent to v, and 
 be the leftmost block in 
 co-adjacent to B. We can find 
 and 
 and test whether 
 with Observation 12. If

Image 31
, we find a minimally forbidden as in Lemma 13 (a).
By hypothesis,

Image 38
; hence, 
 if and only if 
. Similarly, 
 if and only if 
 and either 
 or 
. We conclude, therefore, that  time suffices to determine whether 
 and whether 
. Therefore, by Lemma 13 (c), we can suppose that 
. Otherwise, we obtain a minimally forbidden in  time. Similarly, by Lemma 13 (d) we find a minimally forbidden if 
 and 
 is not an end block. Then, two cases remain:
Case 1:
. Thus, 
 and, as Γ has no pair of indistinguishable blocks,

Image 39
and, so, 
. Under this situation, {v, 
, +B, 
, 
, 
} is an adequate forbidden (Appendix A.7).
Case 2:
 and 
 is an end block. Note that 
 and 
 because Γ has no indistinguishable blocks. If 
 is not a right end block, then let 
 and note that

Image 40
. Otherwise, since 
 is not universal, it follows that Γ has some other contig with a block X. Whichever the case, {v, 
, 
, 
, +B, 
, ±X} is an adequate forbidden (Appendix A.8). We remark that X can be obtained in  time by using the representation and contig pointers of 
. □
We are now ready to deal with the existence of bad blocks, regardless of their type. The main idea is to find a bad block B which can be used as input of either Lemma 14 or Lemma 15. In order to apply either lemma, we need to find out whether B is short or long. However, we do not know how to test, in  time, whether 
 when only B is given. The solution to this problem is to take advantage of the dynamic nature of the algorithm. That is, the answer to 
 was found when the last vertex of G was inserted and it is implicitly encoded in the semiblock paths.

Lemma 16

Let H be a graph with a vertex v, and Γ be block co-contig representing . Given , it costs  time to test if Γ has bad blocks. Furthermore, if Γ has bad blocks, then a minimally forbidden of H can be obtained within the same amount of time.

Proof

The algorithm has two main phases. In the first phase, all the bad blocks of Γ are marked; in the second phase a minimally forbidden is obtained.

To find the bad blocks we first mark all the blocks of Γ that are fully adjacent to v in such a way that  have the same mark if and only if B and W lie in the same contig, v is fully adjacent to all the blocks in  (or ), and  (or ) has no right end blocks. Then, a block B adjacent to v is bad if and only if B is not an end block and either:

•
 and  are unmarked, or

•
 and 
 have different marks, and  and 
 have different marks.

It is not hard to both steps can be achieved in  time (see e.g. [10]). After these steps we can test if any block in Γ is bad in  time.
Let 
 be the blocks of  for any . Recall that, by definition, Γ has a long block if and only if  and  is circular. Hence, if  or  is linear, then we obtain a minimally forbidden by invoking Lemma 15 with and any bad block as input. When  and 
, we first check if v is co-adjacent to 
, 
, and 
; if true, then we obtain the minimally forbidden via Lemma 13 (b) with input 
, 
, 
. Suppose, then, that v is fully adjacent to 
. If 
 is a bad block, then we obtain the forbidden with Lemma 14 using 
 as input. Otherwise, v is fully adjacent to all the blocks in either 
 or 
. Assume the former, as the proof for the latter is analogous.

Let 
 and 
 be the leftmost and rightmost blocks co-adjacent to v in 
, respectively, and observe that

Image 31
because
Image 41
. We can both find 
 and 
 and query if 
 in  time by Observation 12. If any 
 is bad, then 
 and 
 because v is fully adjacent to all the blocks in 
. When
Image 42
, the family {v, +B, 
, 
} induces a 
, while when 
 we find a minimally forbidden by calling Lemma 14 with input B. Whichever the case,  time is enough to obtain a minimally forbidden when some block in 
 is bad.
For the final case, suppose no block in 
 is bad, thus the bad block B belongs to 
. Note that either 
 or 
, we assume the former as the other case is analogous. This means that 
 is good, thus 
 belongs to 
 as well. Hence, we can check if 
 as in Observation 12 (b) (with input 
, 
, and ). Then we find the minimally forbidden calling Lemma 14 (if affirmative) or Lemma 15 (if negative) with input B. We conclude, therefore, that a minimally forbidden can be obtained in  time. □

Having dealt with bad blocks, we now consider the case in which  is not consecutive in Γ. That is, we discuss how to find a forbidden when no co-contig representing G satisfies (rec1). The core of the proof is given in the next lemma.

Lemma 17

Let H be a graph with a vertex v, and Γ be a block co-contig representing  with no bad blocks. If 
, and X are blocks of Γ such that:

•
, and v is adjacent to every block in 
,

•
if 
, then v is co-adjacent 
; otherwise v is co-adjacent to 
, and

•
if 
, then v is co-adjacent 
; otherwise v is co-adjacent to 
,

then a (minimally) forbidden of H can be obtained in  time when semiblock Γ-pointers to 
 and 
 and a semiblock pointer 
 to X are given.
Proof

The first step of the algorithm is to decide if 
. Even though we are unaware of the type of 
, we can answer this query in  time by observing that, since 
 is good and v is co-adjacent to 
 or 
, then either 
 or 
. In the former case

Image 43
. In the latter case 
 if and only if 
, which happens if and only if 
 or 
. (Here 
 is a reverse of 
.) In a similar way, we can test if 
 in  time. If
Image 43
and
Image 44
, then
Image 45
and:
•
{v, 
, 
, +X} induces a 
 if

Image 46
, and
•
{v, 
, 
, +X, 
, 
} induces an 
 
 if 
 (Appendix A.9). We remark that 
 is not the left end block in this case, thus 
. Otherwise, 
 is not the right end block and, since 
 is good and v is co-adjacent to 
, it follows that v is fully adjacent to 
. This is a contradiction because v is co-adjacent to 
. In a similar way 
.

From now on suppose 
, as the proof when 
 is analogous. Hence, X and 
 lie in the same contig. Moreover, by applying reversed if required, we may assume that 
 is a Γ-pointer, thus we can invoke Observation 12 whenever it is required.
Let 
, 
 if 
, and 
 otherwise. Since 
 is good and 
, we observe that

Image 47
. Similarly, since 
 and X is good, we obtain that v is adjacent to 
 and, since 
 is good, it follows that
Image 48
. By checking if 
, we can decide if 
; if negative, then 
 induces a 
⁎
. Suppose, then, that 
 (hence 
), thus
Image 49
because Γ has no indistinguishable blocks. Next we query if 
. If affirmative, then 
 because Γ has no indistinguishable semiblocks. So, 
 is adjacent to v, which implies that
Image 50
. Consequently, {v, 
, 
, +X, 
} induces a 
⁎
. Finally, if 
, then {v, 
, 
, 
, 
, +X, 
} is a forbidden (Appendix A.10) which is adequate by Observation 12. □
We are now ready to find a minimally forbidden when  is not consecutive in Γ. Before doing so, it is convenient to state precisely what we mean by consecutive. We remark that the definition holds for any round representation and not only for co-contigs. We say that  is consecutive in a round representation Φ when there exist two (possibly equal) semiblocks 
 and 
 such that 
. In such a case, 
 witnesses that  is consecutive in Φ. Clearly, if 
 satisfies (rec1), then 
 is consecutive in Φ. However, consecutiveness is a slight generalization of condition (rec1) that allows v to be co-adjacent to 
 and 
. The next result applies Lemma 17 to find a minimally forbidden when  is not consecutive in any co-contig representing .

Lemma 18

Let H be a graph with a non-isolated vertex , and Γ be block co-contig representing  with no bad blocks. Given , it takes 
 time to transform Γ into a block co-contig 
 representing  in which  is consecutive. The algorithm outputs 
-pointers to the blocks 
 witnessing that  is consecutive in 
, or a minimally forbidden of H when such a representation 
 does not exist.

Proof

As discussed in [6], [10],  time suffices to find a set 
 of semiblock pointers such that:

(a)
 and 
 are associated to the same contig 
,

(b)
v is fully adjacent to every block in 
,

(c)
 is a partition of the blocks adjacent to v, and

(d)
either 
 (resp. 
) or v is co-adjacent to 
 (resp. 
).

We remark that the type of 
 is unknown, as we are unaware of whether 
 or 
. In (b) and (c) above, 
 refers to the range in 
, that could be a range of 
. For the sake of notation, we write 
 and 
 as shortcuts for 
 and 
, as in (d) above.
When , 
 witnesses that  is consecutive in 
, where 
 is the type of 
. Suppose, then, that . If either none of 
 () are end blocks or 
 and v is co-adjacent to the end blocks in 
, then we obtain a minimally forbidden by invoking Lemma 17 with input 
, 
, and 
 for . If , then {v, 
, 
, 
} induces a 
, where 
 is the end block of 
. Therefore, , 
 () is an end block, and v is fully adjacent to 
 if 
. Exchanging the roles of 
 and 
 if required, we may assume that 
 is a right end block and 
 is a left end block. If 
 has the same type 
 as 
, then 
 witnesses that  is consecutive in 
; otherwise, 
 witnesses that  is consecutive in 
. As discussed in Section 4.3,  time is enough to query the types of 
 and 
, while replacing 
 with 
 costs 
 time. □

By definition,  is consecutive in a round block representation Γ when it has two (possibly equal) blocks 
 and 
 such that 
. We can separate 
 and 
 in pairs of consecutive indistinguishable semiblocks 
 and 
, respectively, to obtain a new round representation of G. Of course, if either 
 (resp. 
) or 
 (resp. 
) is empty, then nothing is separated out of 
 (resp. 
). Similarly, if 
, then 
 is separated to either the left or the right of 
. We refer to the round representation so obtained as being v-associated to Γ. Observe that v is simultaneously adjacent and co-adjacent to at most two blocks of Γ, namely 
 and 
. Thus, no matter which pair witnesses that  is consecutive in Γ, only 
 and 
 could be separated. Moreover, both 
 and 
 get separated only if v is co-adjacent to both 
 and 
, in which case either 
 or 
 is the only pair witnessing that  is consecutive. We conclude, therefore, that at most two round representations v-associated to Γ exist.

Recall that, when v is not isolated, the co-connected graph H is PCA if and only if  admits a v-receptive round representation Φ. By the Reception Theorem (applied to the component that contains v), Φ has a pair of semiblocks 
 that satisfies (rec1)–(rec3). Recall that 
 satisfies (rec1) if and only if 
, while 
 satisfies (rec2) when no pair of semiblocks in 
 are indistinguishable. It is not hard to see that Φ satisfies (rec1) and (rec2) if and only if Φ is a round representation v-associated to Γ, for some round block representation Γ of G. Indeed, by (rec2), Φ has at most two pair of indistinguishable semiblocks, namely 
 and 
. By compacting 
 into 
 and 
 into 
, we obtain a round block representation Γ that has Φ as its v-associated representation. We record this fact for future reference.

Observation 19

Let H be a co-connected graph with a vertex non-isolated vertex v. A round representation Φ of  satisfies (rec1) and (rec2) if and only if Φ is v-associated to a round block representation of .

By definition, a round representations is just a family of contigs with no order. Consequently, G admits only two round block representations in which  is consecutive, namely Γ and 
. Therefore, the only round representations of G that satisfy (rec1) and (rec2) are those v-associated with Γ and 
. We show how to obtain a minimally forbidden when none of the representations v-associated to Γ satisfies (rec3). Before doing so, we find it convenient to recall that 
 satisfies (rec3) when there exists 
 witnessing that 
 is receptive. Also, recall that 
 witnesses that 
 is receptive when (see Fig. 4):

(wita)
 is an end semiblock,

Image 12
, and
Image 13
, or
(witb)
Image 12
,
Image 14
,
Image 15
, and
Image 16
.
Lemma 20

Let H be a graph with a non-universal vertex , Γ be a block co-contig representing  with no bad blocks, and 
 be a pair witnessing that  is consecutive in Γ. Given semiblock Γ-pointers to 
 and 
, it takes  time to transform Γ into a co-contig Φ representing  that satisfies (rec1)–(rec3). The algorithm outputs the semiblock Φ-pointers to a pair 
 that satisfies (rec1)–(rec3), or a minimally forbidden of H when such a representation Φ does not exist.

Proof

If 
, then 
 is an end block because it is good. Thus, one of the representations Φ v-associated to Γ has 
 as an end semiblock and, so, 
 satisfies (wit1). Then, by Observation 19, 
 satisfies (rec1)–(rec3) in Φ. Suppose, from now on, that 
. Let Φ be the co-contig v-associated to Γ such that 
 for 
 and 
. By Observation 19, Φ satisfies both (rec1) and (rec2). With the operations discussed in Section 4.3, we can transform Γ into Φ and test if Φ satisfies (rec3) in  time. If affirmative, then we return 
. Suppose, then, that Φ does not satisfy (rec3).

Claim 1:
Image 46
. If 
, then neither 
 nor 
 is an end semiblock because 
 does not satisfy (wita). So, 
 and 
 and, since 
 and 
 are good, it follows that 
 and 
. Consequently, 
, thus
Image 12
and 
. Moreover, since
Image 14
and 
 does not satisfy (witb), it follows that 
, a contradiction because 
 is good.
Claim 2:
Image 51
. Suppose 
, thus 
 and 
. If 
, then 
 witnesses that 
 is receptive by (witb). Otherwise, 
, thus 
. Consequently,
Image 12
and, since by definition
Image 14
and
Image 52
, we obtain that 
. This is a contradiction, because 
 is good and 
.
Claim 3:
Image 53
. Otherwise, 
 satisfies (witb). Just note that, by Claim 2,
Image 54
.
Let 
 and 
. By Claims 1–3, we observe that 
, 
, 
, 
, 
, and 
 appear in this order in a traversal of 
 where, possibly, 
, 
, and 
. In  time we can check whether 
; if negative, then 
 induces a 
. Thus, we assume that 
. Hence, 
 is not an end block and, by Claim 3, 
 are pairwise different and appear in this order in a traversal of the contig that contains 
 and 
.

Claim 4:
if 
 has some semiblock W that is indistinguishable to neither 
 nor 
, then a minimally forbidden can be obtained in  time. By (rec2), there are  blocks that are indistinguishable to either 
 or 
, thus W can be obtained in  time. Clearly, v is not adjacent to W by (rec1). First we test if 
 by looking whether 
. If affirmative, then, since no pair of 
, W, and 
 are indistinguishable, it follows that 
 and 
. Note that, consequently, 
, 
, 
, and 
 are pairwise different. Hence, {v, 
, 
, 
, 
, 
, −W} induces an 
 
 (Appendix A.11). Suppose, then, that

Image 55
, thus 
. Then we check whether 
, i.e., whether 
. If affirmative, then, as before, 
 is different to 
 and 
. Then, {v, 
, 
, 
, 
, 
, −W} is a forbidden (Appendix A.12). When
Image 56
, we test if 
 by looking if 
. If false, then 
 and {v, 
, 
, 
, 
, 
, −W} is a forbidden (Appendix A.13). Otherwise, since W and 
 are not indistinguishable, we obtain that
Image 57
. Consequently, 
 and {v, 
, 
, 
, 
, 
, −W} is a forbidden (Appendix A.14). Note that every computed forbidden is adequate by Observation 12.
By Claim 4, we may assume that every semiblock in 
 is indistinguishable to either 
 or 
. By (rec2), 
 has at most two semiblocks, namely 
 and 
, that are indistinguishable to 
 and 
. Then, two cases remain.

Case 1:
. In this case, 
 and 
 are both pairs of indistinguishable semiblocks and, since 
 y 
 are not indistinguishable, then either

Image 58
or
Image 59
. Suppose the former, as the other case is analogous. Then 
 and {v, 
, 
, 
, 
, 
, 
} is an adequate forbidden (Appendix A.15).
Case 2:
. Applying Claims 1–4 to 
, we observe that 
 is indistinguishable to either 
 or 
. As 
, we observe that either 
 is indistinguishable to 
 or 
 is indistinguishable to 
. Assume the former, as the other case is analogous. Now, if

Image 60
, then 
 and {v, 
, 
, 
, 
, 
, 
} is an adequate forbidden (possibly 
; Appendix A.16). Suppose, then, that 
, and let Ψ be the co-contig that is obtained from Φ by exchanging the order between 
 and 
. (For the rest of the proof, whenever we write f without a superscript we mean 
.) Clearly, Ψ represents , 
 in Ψ, while 
 and 
 are the only possible pair of indistinguishable semiblocks. That is, 
 satisfies (rec1)–(rec2) for Ψ. Moreover, since 
, we obtain, by Claim 3 applied to Ψ, that 
 satisfies (rec3). □
The main theorem of this section follows by combining Lemma 16, Lemma 18, Lemma 20 while filling the missing cases.

Theorem 21

Let H be a graph with a non-universal vertex , and Γ be block co-contig representing . Given Γ and , it costs 
 time to determine if H is PCA. Furthermore, within the same amount of time, Γ can be transformed into a block co-contig representing H, unless a minimally forbidden of H is obtained.

Proof

First suppose v is isolated in H. In this case there are three possibilities. First, if Γ is straight, then H is PCA and  is a block co-contig representing H for any contig ψ whose only vertex is v. Second, if  is not straight and , then  induces a cycle plus an isolated vertex. Thus,  is a minimally forbidden of H. Finally, if  is not straight and 
, then we can obtain a minimally forbidden by invoking Lemma 13 (b) with input 
.

Now suppose . To compute a co-contig representing H, we first apply Lemma 16 with input  to verify that Γ has only good blocks. If negative, then we obtain a minimally forbidden. Otherwise, we apply Lemma 18 with input  to transform Γ into a block co-contig 
 representing  in which  is consecutive. This time we obtain either a minimally forbidden or a pair of blocks 
 witnessing that  is consecutive in 
. In the latter case, we apply Lemma 20 with input 
 to transform 
 into a co-contig Φ representing  that satisfies (rec1)–(rec3). By Lemma 6, we obtain either a minimally forbidden or a pair 
 that is v-receptive in 
, where 
 are the contigs that contain 
 and 
, respectively. Finally, we check if 
 is receptive in Φ and we proceed as follows according to the answer.

Case 1:
 is receptive in Φ. We first transform Φ into the -reception Ψ of 
 in Φ. Then, we compact  if it is indistinguishable to either 
 or 
. As a result, Ψ is a round block representation of H.

Case 2:
 is not receptive in Φ. As discussed in Section 4.3, the only case in which 
 is receptive in 
 and not receptive in Φ is when 
, 
 contains the left end semiblock 
 of ϕ, and  has some contig ρ. Moreover, the v-reception  of  is not straight in this case. Thus,  is not PCA for every . Then, we can obtain a minimally forbidden of H by trying to insert a vertex  into . Since x has no neighbors in , this insertion trial costs  time, while we can find  in  time by using the round pointer of 
.

As discussed in Section 4.3, 
 time suffices to test if 
 is receptive in Φ and to compute the -reception of 
 in Φ and . By Lemma 16, Lemma 18, and 20, we conclude that the whole algorithm costs 
 time. □
5.2. H and G need not be co-connected
In this section we deal with the general case in which H and  need not be co-connected. In other words, 
 where:

•
 contains the universal vertices of G in , for some ,

•
For , 
 is a co-component with 
, and

•
 contains only vertices in .

We are taking a loose definition of  and + here, as it could happen that 
, , or ; the missing details are obvious though. The algorithm in [10] builds a round block representation of H in two phases. The first phase finds a block co-contig 
 of 
, where 
 for every . The second phase joins 
 and a round block representation 
 of 
 into a round block representation Ψ of H. Our certifying algorithm mimics these two phases; the internal details are different, though.
The purpose of the first phase is to find a co-contig 
 of 
. To fulfill its goal, the algorithm in [10] computes all the round block representations of 
 to see if  is consecutive in one of them. For those in which  is consecutive, it checks if some of its v-associated representations is v-receptive. The algorithm is correct by the Reception Theorem and Observation 19, but it could require exponential time. A key observation in [10] is that H is not PCA when , thus only  round representations need to be examined, hence the algorithm is efficient. The problem with this “brute force” strategy is that it makes it difficult to find a negative certificate when H is not PCA. An alternative approach is to note that, as 
 is co-connected, at most two of the generated representations, Φ and 
, are v-receptive. The idea is to characterize how does Φ look like so that a minimally forbidden can be obtained when 
 has no v-receptive representations.

Instead of dealing with 
 as a whole, we use an iterative approach. Before the algorithm is executed, we have a round block representation 
 of G and we build a new block co-contig 
 of . After i iterations, we have transformed Γ into a round block representation 
 of 
 and 
 into a block co-contig of 
. To cope with iteration , we use Steps 1–3 below. In brief terms, this procedure works a follows:

Step 1
splits from 
 a block co-contig 
 having blocks co-adjacent to v. Let 
.

Step 2
updates 
 into a block co-contig 
 of 
.

Step 3
joins 
 and 
 to obtain a block co-contig of 
.

Once the iterative process is completed, we have round block representations 
 of 
 and 
 of 
. We use Phase 2 below to combine these representations into a representation of H. Of course, any of these steps can fail, and a minimally forbidden is provided if so.
5.2.1. Step 1: split 
 out of 
To split 
 out of 
, we traverse 
 until the first block B co-adjacent to v is found. If no such block exists, then Phase 1 concludes and Phase 2 begins. Otherwise, we invoke Lemma 22 below to obtain the family E of co-end blocks of 
, where 
 is the co-contig of 
 that contains B. If Lemma 22 outputs a minimally forbidden, then the algorithm halts; otherwise, we check if B is a universal block. If affirmative, then we separate B into +B and −B, and we update 
 to be the co-contig containing −B. The separation is done in  time, as discussed in Section 4.3. Finally, we split 
 out of 
. Note that the case  is trivial, as 
 and 
, while the split when  costs  time as discussed in Section 4.1. Therefore, Step 1 costs  time.

Lemma 22

Let H be a graph with a vertex v, ϕ be a co-contig of a round representation Φ of , and  be co-adjacent to v. Given a Φ-pointer to B, it takes  time to determine if  is co-bipartite when H is PCA. The algorithm outputs either a minimally forbidden of H or a set containing Φ-pointers to all the co-end semiblocks of ϕ.

Proof

The algorithm outputs ∅ when Φ is not robust, and 
 when B is universal. In the remaining case, the algorithm tries to locate the left co-end semiblocks of ϕ. For this, it computes the minimum  such that:

1.
 is a left co-end semiblock,

2.
 for some , or

3.
 and v is co-adjacent to 
, 
, 
, and 
.

Observe that 
 because B is not universal. Therefore: if 1. holds, then 
 and 
 are the left co-end semiblock of ϕ; if 2. holds, then  is not co-bipartite because 
 induces a co-cycle of odd length; and if 3. holds (and 2. does not), then H is not PCA because {v, 
, 
, 
, 
} induces a 
⁎
. Clearly, i can be obtained in  time. Indeed, each semiblock is traversed  times by 1. and 2., while at most  blocks co-adjacent to v are visited by 3. (See [10] for a better bound.) When 1. holds, the algorithm computes the right co-end semiblocks of ϕ by replacing 
 with 
 in 1–3. □
5.2.2. Step 2: update of 
 into 
There are two possibilities for Step 2, according to whether 
 has a unique (universal) block or not. In the former case,  is a block of 
 co-adjacent to the clique 
, thus computing the block co-contig 
 in  time is trivial. In the latter case, both 
 and 
 are co-connected. Thus, we invoke Theorem 21, with input 
 and 
, to transform 
 into a round block representation 
 of 
. By Lemma 23,  time suffices to compute 
, thus Step 2 requires 
 time.

Lemma 23

Let H be a graph with a vertex v, ϕ be a co-contig of a round representation Φ of , and 
 be a left co-end block of ϕ. Given  and a semiblock pointer to 
, it takes  time to compute  when H is PCA. When H is not PCA, the algorithm outputs either  or a minimally forbidden of H.

Proof

For each  adjacent to v, we find a pointer  to a left co-end semiblock of the co-contig 
 that contains B; initially, . To compute E, we traverse each  to process the semiblock B that contains w. If B is universal, then we set  and pass to the next vertex. Otherwise, we look for the minimum  such that:

1.
,

2.
 is a left co-end semiblock, or

3.
 and v is co-adjacent to 
, 
, 
, and 
.

Since B is not universal, it follows that B and 
 belong to the same co-component for every . Hence, 
 is a left co-end semiblock of 
 if 1., while 
 is a left co-end semiblock of 
 if 2. Therefore: if 1., then we set 
 for every ; if 2., then we set 
 for every ; and if 3., then we output that H is not PCA because {v, 
, 
, 
, 
} induces a 
⁎
. The computation of E ends after all the vertices in  have been considered. After E is computed, the algorithm outputs 
, where  is the semiblock that contains w. Clearly, by 1. and 2., the algorithm traverses each semiblock B adjacent to v only  times, while, by 3., it traverses at most  blocks co-adjacent to v. □
5.2.3. Step 3: join of 
 and 
Step 3 has to join 
 and 
 into a block co-contig representing 
. This is trivial when  as we replace 
 with 
. When , at most one between 
 and 
 is a clique. Thus, we can combine 
 and 
 in  time with the following lemma.

Lemma 24

Let H be a co-connected graph with a vertex v such that  is a PCA graph isomorphic to 
 for some 
 and 
, and let 
 be the block that contains v in a block co-contig 
 representing 
, for . Suppose 
 is not a block of 
. Then, H is a PCA graph if and only if either:

(i)
 and 
 are co-end blocks of 
 and 
,

(ii)
 is a block of 
, 
 is robust, and 
, or

(iii)
 is a block of 
 and 
 has exactly three non-adjacent blocks: {v, 
, 
}.

Consequently,  time suffices to determine if H is PCA, when 
-pointers to 
 are given. The algorithm either transforms 
 and 
 into a block co-contig representing H or outputs a minimally forbidden of H.
Proof

First we prove that H is a PCA graph when some of (i)–(iii) holds.

(i) holds.
The proof is implicit in [10]. By reversing 
 and 
 if required, suppose 
 is a right co-end block and 
 is a left co-end block. As discussed in Section 4.3, we can join 
 and 
 into a block co-contig ρ representing 
 in which 
 and 
 are consecutive. Clearly, 
 witnesses that 
 is receptive in ρ, thus the -reception of 
 is a block co-contig representing a graph 
 with three vertices 
, 
 and w such that: 
 and 
. Consequently, 
 is PCA.

(ii) holds.
Let ρ be the co-contig that is obtained from 
 by a separation of 
 into 
, and note that 
 witnesses that 
 is receptive in ρ. Consequently, the 
-reception of 
 is a block co-contig that represents H because v is the unique vertex not adjacent to 
.

(iii) holds.
Trivial.

It is not hard to obtain the block co-contig ρ in  time using the operations described in Section 4.3 with some low-level manipulation of the contigs (i.e., avoiding reception); see [10].
Now suppose none of (i)–(iii) holds. To prove that H is not PCA we show an  time algorithm that computes a minimally forbidden of H. If 
 is not a co-end block, then 
 is not a block, thus we may replace 
 and 
 without affecting the hypothesis of the lemma. Hence, as (i) is false, we suppose 
 is not a co-end block. Through the proof we work only with 
 and two blocks of 
, called X and Y, which are not adjacent to 
 and X, respectively. Also,  unless 
. Note that X and Y are obtainable in  time.

The first step of the algorithm is to verify if 
 is robust. By Theorem 1, 
 is co-bipartite because  is not co-connected. Then, 
 is robust, thus either 
 is robust or 
 is isolated in 
 and 
 has exactly two non-adjacent blocks 
, 
. Therefore, we can decide if 
 is robust in  time, obtaining pointers to 
 and 
 if negative. Moreover,  because (iii) is false. Consequently, 
 contains either a 
 or a 
⁎
. Such a minimally forbidden can be obtained in  time. From now on we assume 
 is robust, hence 
, 
, 
, and 
 are well defined for 
. Moreover, as 
 is not a co-end block, we obtain that

Image 61
and
Image 62
.
The second step is to check if

Image 63
and if
Image 64
. If 
 and
Image 65
, then
Image 66
because 
 and 
 are not indistinguishable. So, 
 because, otherwise, 
, 
, 
 are pairwise non-adjacent blocks, contradicting the fact that 
 is co-bipartite. Similarly, 
 because 
, 
, 
 cannot be pairwise non-adjacent. Hence, 
, 
, 
, 
 are pairwise different and appear in this order in a traversal of 
. The minimally forbidden we generate depends on whether 
 or not. In the affirmative case, {
, 
, 
, 
, 
, 
, X} induces an 
 
 (Appendix A.17). In the negative case we observe that, as before,
Image 67
and 
. This implies 
 because {
, 
, 
, 
, 
} does not induce a 
, thus {
, 
, 
, 
, 
, 
, X} induces an 
 
 (Appendix A.18). From now on, we assume
Image 63
and, similarly,
Image 64
. Hence, 
.
Note that 
 are either equal or appear in this order in a traversal of 
; otherwise, any block inside 
 would be indistinguishable to 
. For the third step, the algorithm tests if 
 has some block W. If true, then 
 since, otherwise, W, 
, 
 are pairwise non-adjacent. Consequently, 
, 
, 
, and 
 are all different. This implies that 
 because no subset of 
 induces an 
 
 or 
. Consequently {
, X, W, 
, 
, 
, 
} induces an 
 
 (Appendix A.19).

Finally, note that  when 
 or 
. Indeed, in the former case  because 
 and X are not twins, while in the latter case  because (ii) is false. Consequently, 
, X, 
, 
, 
, 
} is a forbidden (Appendix A.20) whose edges can be obtained in  time. We remark that not all the blocks in  are pairwise different. □

5.2.4. Phase 2: join of 
 and Γ
After the first phase is completed, we have a round block representation Γ of 
 and a block co-contig 
 representing 
 for 
. The goal of the second phase is to find a round block representation of H. This is trivial when 
, as 
 is the desired representation. For the other case, we invoke Theorem 25 using v and  as input.

Theorem 25

Let H be a graph such that 
 for 
, and 
 be a round block representation of 
, for . Then, H is PCA if and only if 
 and 
 are PCA and co-bipartite. Furthermore, if semiblock 
-pointers to 
 are given, then 
 time suffices to determine if H is PCA. The algorithm either transforms 
 and 
 into a round block representation of H or outputs a minimally forbidden of H.

Proof

The fact that H is PCA if and only if 
 and 
 are co-bipartite PCA graphs follows from Theorem 1.

The algorithm to detect if H is PCA is as follows. Let 
 be any block of 
 (), and q be the minimum such that either

Image 68
or 
. Note that, since
Image 69
, the blocks 
, 
, 
, 
 appear in this order in 
 for every  (see Fig. 8 (a)). Consequently, the value q is well defined, and the blocks of 
 appear as in Fig. 8 (b). Therefore, if p is the maximum such that
Image 70
, then either  or 
 induces an odd co-cycle. In the former case, 
 is a co-end block, while, in the latter case, 
 is a minimally forbidden of H for every 
. Replacing i by j, we can find a minimally forbidden when 
 has no co-end blocks. When both 
 and 
 have co-end blocks, we can join 
 and 
 into a round block representation of H as in Section 4.3.
Fig. 8
Download : Download high-res image (31KB)
Download : Download full-size image
Fig. 8. Adjacencies of 
 
 in Theorem 25. The blocks are drawn as they appear in the circular ordering 
. Note that 
 when H[Vi] is co-bipartite.

To compute the sequence 
 we proceed as follows. First, we mark all the blocks in 
. Then, 
 if and only if 
 is marked; thus, q is the minimum value such that 
 is not marked. Then, to obtain the value p, first note that  if . When , we traverse 
 while looking for 
; then 
 is the last block of the traversed sequence. Since 
 and 
 are adjacent to every block in 
, this algorithm costs 
 time. □

6. The certifying recognition algorithms
By Theorem 1, at most three iterations of Phase 1 in Section 5 can be completed without finding a minimally forbidden. Hence, since each iteration of Phase 1 costs 
 time, and Phase 2 costs  time, we obtain the main result of the previous section: there is an 
 algorithm that transforms a round block representation Γ of  into a round block representation Ψ of H, unless a minimally forbidden is obtained. Note that the algorithm ignores the straightness invariant of Γ, and it does not ensure the straightness invariant for Ψ. The straightness invariant, instead, is required for the recognition of PIG graphs. Fortunately, we can restore the straightness invariant in  time with Corollary 29 below. Before describing this corollary, we define what a locally straight representation is.

Recall a semiblock B of a round representation Φ is long when 
. When no block of Φ is long, Φ is said to be a locally straight representation. A graph G is a proper Helly circular-arc (PHCA) graph if it is isomorphic to  for some locally straight representation Φ. As it is shown in [33], G is a PHCA graph if and only if it admits a PCA model in which no two nor three arcs cover the circle. The following results imply Corollary 29 below.

Theorem 26

[34]
A PCA graph is a PHCA graph if and only if it contains no 
 or 
 as induced subgraphs, where 
 is the graph obtained after inserting a universal vertex in 
.

Theorem 27

[34]
If B is the universal block of a contig ϕ, then either 1. ϕ is linear, 2. 
 or 3.  is not PHCA. If 2., then 
 witnesses that  is receptive in , and its B-reception is a linear contig representing .

Lemma 28

[34]
If a round representation Φ has three non-universal blocks 
, 
, 
 such that 
, 
, and 
, then  is not PHCA.

Corollary 29

Given a round block representation Ψ, it takes  time to transform Ψ into a round block representation 
 of  that satisfies the straightness invariant. Moreover, 
 is locally straight when  is PHCA.

Proof

By Theorem 2, Theorem 26, Theorem 27, and Lemma 28, the algorithm has nothing to do in the following situations because either 1. Ψ is straight, 2. Ψ is locally straight and  has an induced cycle, or 3.  is not PHCA:

•
,

•
 and ,

•
,  and no block of  is universal, or

•
, ,  is universal, and 
.

Finally, if , ,  is universal, and 
, the algorithm moves B to the position that follows 
 in a traversal of . The block representation 
 so obtained is straight by Theorem 27. Clearly,  time is enough to test the above conditions and to apply the required move using split and join (see Section 4.3). □
The main theorems of this article then follow.

Theorem 30

Let H be a graph with a vertex v, and Γ be a round block representation of . Given Γ and , it takes 
 time to determine if H is a PCA graph. The algorithm transforms Γ into a round block representation of H that satisfies the straightness invariant, unless a minimally forbidden of H is obtained.

Theorem 31

When a vertex v of a round block representation Ψ is given, 
 time is enough to transform Ψ into a round block representation of  that satisfies the straightness invariant.

Proof

Let B be the block that contains v. If , then we remove v out of B; otherwise we call remove(B) to transform Ψ into a round block representation Φ of . Afterwards, we apply Corollary 29 on Φ to restore the straightness invariant. □

Theorem 32

Given a round block representation Γ of a graph H that satisfies the straightness invariant, it takes  time to determine if H is PHCA. If H is not PHCA, then the algorithm outputs  for a family of blocks  such that  is isomorphic to either 
 or 
.

Proof

The algorithm answers yes when  or  and . Conversely, if  and 
, then, by the straightness invariant, H is not PHCA. Moreover,  is not PHCA for  = {
, 
, 
, 
, 
, 
} [34]. As discussed in Lemma 13, we can compute all the adjacencies of  in  time. □

Theorem 33

Given a round block representation Γ of a graph H that satisfies the straightness invariant, it takes  time to determine if H is PIG. If H is not PIG, then the algorithm outputs  for a family of blocks  such that  is either a 
 or a 
 ().

Proof

By the straightness invariant, all we need to do to test if H is PIG is to call straight (Section 4.3). If H is not straight, then we test if H is PHCA. If negative, then we extract an induced 
 or 
 from the output . Otherwise,  and  induces a 
 (). □

6.1. The authentication problems
As discussed in Section 1, we can conceive three types of checkers, namely static, dynamic, and monitors. A static checker, which has the simplest implementation, authenticates the witnesses against the static graph G. A dynamic checker, instead, test the witness obtained after one operation is applied on a round block representation Φ. Although it is more efficient than applying the static checker for each update, the dynamic checker requires some extra effort as different tests are performed for the different updates. Finally, a monitor is a new layer between the end user and the dynamic algorithm that checks the correct behavior of Φ and the witnesses it generates. To do its work in the most efficient way, the monitor requires privileged access to some operations that are restricted to the final user [7]. Thus, the implementation of a monitor is not as simple as for the checkers, as it requires some knowledge about the internal workings of Φ. In this section we briefly discuss the static and dynamic checkers, and we skim through two possible designs for a monitor.

6.1.1. The static checker
The static checker authenticates that a witness W is correct for a graph G. Of course, the correctness depends on the recognition problem we are dealing with and on whether W is positive or negative. Since we consider three problems, i.e., the recognition of PIG, PHCA, and PCA graphs, the static checker has to solve six problems.

When G is claimed to be PCA, the witness is a round block representation Φ of G. To authenticate Φ, the checker tests if:

•
each  is a block contig,

•
 is isomorphic to G,

•
every block of G corresponds to a block of Φ, and

•
if required, Φ is (locally) straight.

On the other hand, if G is declared as not being a member of the class, then the negative witness is a minimally forbidden , where  when the problem is the recognition of PIG or PHCA graphs. To authenticate that  is correct, the checker builds the graph F represented by , and then it tests that F is isomorphic to an induced subgraph of G.
It is not hard to see that these problems can be solved in  time. Moreover, the implementation of the checker is simple as desired.

6.1.2. The dynamic checker
The static checker is optimal for the authentication of static graphs. However, its time complexity is excessive when compared to the time required by an update of the round block representation Γ. Thus, the static checker is not well suited for the dynamic algorithm. The dynamic checker, instead, tries to authenticate the witness against Γ. Of course, the authentication depends on the applied update and the kind of witness obtained.

Suppose we want to authenticate a successful insertion. In this case, the input is  and a round block representation Γ. The output is the vertex v, and the witness is the round block representation Ψ of G that satisfies the straightness invariant. Let B be the block of Ψ that contains v. To authenticate Ψ, we check that:

(i)
Ψ is a round block representation that satisfies the straightness invariant,

(ii)
,

(iii)
 is isomorphic to , and

(iv)
the vertices of  appear in the same blocks in  and Γ.

There is a large asymmetry between the insert operation and its authentication. Whereas the former deals mostly with , the latter tests all the blocks of Ψ. There are three reasons why the checker must look at the complete structure. First, because the dynamic algorithm could modify  far neighbors even when  (e.g., when the universal block  is separated into −B and +B). Second, and most important, because we cannot assure that a buggy implementation of insert updates only the blocks it is supposed to. Third, because the specification of insert requires  to be isomorphic to , and no more guaranties are provided.
It is not hard to see that (i) and (ii) can be implemented in  time. For (iii) and (iv), the checker works as follows. Let . First, the checker looks for all the co-end blocks in both Φ and Γ. Note that Φ need not be a block representation. However, it is not hard to consider the twin semiblocks of Φ as being part of the same block; we omit the details. Also, observe that Φ is not actually computed; instead v is ignored in Ψ. In the second step, the algorithm checks that the co-end blocks of Φ and Γ coincide. If not, the checker reports that the implementation is buggy. When all the co-end blocks coincide, the checker traverses each co-contig ϕ of Φ to test that the remaining blocks appear in the same order as in Γ (or its reversal). If negative, then the checker outputs that the implementation is buggy; otherwise, both (iii) and (iv) hold. The correctness of this algorithm follows from the fact that co-connected PCA graphs admit exactly two round block representations, one the reverse of the other [29]. Note that the dynamic checker for the insertion runs in  time. Its implementation, however, is not as simple as the one for the static checker.

The authentication required for remove is similar and can be implemented in  time as well. Analogously, the authentication that Φ is either straight or locally straight, required for forbiddenPIG and forbiddenPHCA, takes  time. Finally, to verify a negative witness , the checker tests that Φ is indeed a representation induced from Γ, and that  contains the neighbors of v in Φ. Both of these tests can be easily implemented in  time.

6.1.3. The monitors
Although the dynamic checker is much faster than the static one, it is still too expensive when compared to the update operations. Unfortunately, the dynamic checker is optimal when no details about the implementation can be exploited. When we have access to some details of the implementation, we can monitor each operation of the dynamic algorithm to ensure its correctness. We discuss two possible implementations of such monitors, which we refer to as the bookkeeping and supervisor monitors.

The bookkeeping monitor. In this method (see e.g. [27]) the monitor M keeps a separate implementation of the data types to ensure that the dynamic algorithm A works as supposed. When the user applies some operation, the monitor forwards this requirement to A who answers with the list of modifications it has applied to the different data types. Then, M updates its own data structures to verify the answer given by A.

In our problem, M would keep its own round block representation Γ and semiblock path . When an insert is invoked by the user, M forwards this operation to A. If successful, then A informs, among other things, how the co-contigs were permuted, which semiblocks were separated, which semiblocks were inserted and where, and into which semiblock B was v added. Then, M can emulate these operations to transform Γ into its own version of the updated representation Ψ while it verifies that  was not updated for , and that 
.

From a theoretical point of view,  is a monitor for A. Thus, the existence of a bookkeeping monitor that has the same efficiency as A is guaranteed. However, the authenticator M should have a simple implementation, and so it should be simpler to implement than the algorithm A. That is, M should not implement all the logic in A; for instance, to authenticate a successful insert, M is not required to check that all the blocks of v are good in Γ. Yet, M still has to apply the operations informed by A, thus M must implement some of the logic in A (i.e., to separate, split, etc.). Because of this overlap of non-trivial logic, it is open to question whether we can blindly trust the implementation of M to claim that A is correct.

The supervising monitor. In this method (see e.g. [4], [7]) each data type T implemented by the dynamic algorithm A has its own dedicated monitor 
 to ensure that T works as expected. This time, 
 does not store its own implementation of T; instead, 
 is granted access to the data structure that implements T. When a user applies some operation, 
 forwards this requirement to T and then it asserts that the data structure of T is in a valid state and that the answer given by T is consistent with this state.

To make the above statement more precise, suppose we want to implement a monitor M for contigs. As part of its work, M has to check that separate is well implemented. Recall that separate(
, W) transforms the contig γ referenced by 
 into the contig ϕ that represents  by splitting B into two indistinguishable semiblocks  and W in such a way that 
, 
, and 
. To verify that separate is correct, a static checker must guarantee, among other things, that ϕ represents . There are at least two inconveniences that such a checker must confront. First, a buggy implementation could fail to update 
 for some neighbor of B. Second, there could be  semiblocks that have B as its right far neighbor in Φ, and all of them should reference W in Γ. Thus, if the data structure is unknown, then the checker must traverse  semiblocks to authenticate γ. However, the implementation spends  time to simultaneously update all the right far neighbors. In fact, the algorithm consists of swapping two self pointers [6], [10]. If M is given access to the self pointers, then it can test that the swap is correct. Given that M knows how contigs are implemented, a second and more pragmatic approach is to consider that such a swap is correct by definition. The reason is that proving the correctness of an implementation of swap is as simple, if not simpler, than authenticating the output of swap. Moreover, if we cannot trust the implementation of swap, then we cannot trust the implementation of M either.

In a similar way as described for the update of far pointers, we may assume that a contig ϕ provides other basic operations, which are accessible only by M, that are correct by definition. However, other operations are harder to implement and should be checked by M. We differentiate three types of errors that impact on the design of ϕ and M.

(Improper) access errors
arise when a portion of the data structure that should not be accessed is modified. For instance, only the semiblocks in 
 need to be updated in reception(
, 
). We consider those modifications to semiblocks outside 
 as access errors. There are at least two basic methods for dealing with access errors. The simplest one is to ignore the error; this strategy is appropriate if we can assure that the error will be caught when the modified portion of the structure is accessed. The alternative method is to use some kind of supervised memory that tracks all the updates of the data structure. Then, M can refuse those operations that access a restricted portion of the memory. The first approach is used in [4] for ordered dictionaries. When the monitor asks the dictionary to insert a pair , the dictionary could (erroneously) erase an item 
. Such misbehavior is not detected by the monitor until it tries to access 
. Thus, the monitor is not certifying the whole data structure for insert, but only that the insertion takes place where it should. We remark that missing such an error is not critical for dictionaries, because the elements that it holds are independent of each other. For contigs, perhaps it is better to take actions immediately using the supervised memory solution.

Memory errors
occur when an uncontrolled memory location is accessed. To deal with uncontrolled memory locations, we can follow the same technique as in [4]. That is, each semiblock  keeps the position of a semiblock pointer 
 in an array T of “trusted” memory. This array is controlled by M to ensure that each access to B is correct. To authenticate the access to B, the monitor access its position of T and uses 
 to control that B was under the control of the data structure.

Logical errors
happen when an operation does not behave as it is supposed to, but accessing only the portions of the data structure to which it has access. Suppose, for instance, that M is asked to perform reception(
, 
) on ϕ. The monitor forwards this operation to the data structure and it obtains the semiblock B that contains v on ψ. When B is not an end semiblock, M outputs that the implementation is buggy if some of the following check fails.

•
 and 
,

•
 for every 
 such that 
,

•
 for every 
 such that 
,

•
 for every 
 such that 
, and

•
 for every 
 such that 
.

The case in which B is an end semiblock is handled similarly.
Using the above techniques, M can authenticate all the operations on contigs. The remaining data types (i.e., semiblock paths, round representations, connectivity structures, and witnesses) should be monitored as well. Suppose we need to check that reception(
, 
) works as specified for a round representation Φ. A priori, the only operation of contigs that should be invoked is the trusted reception with inputs 
 and 
. Thus, any other update on the contigs should be regarded as an access error. Following the supervised memory solution, we may ask M to track the updates that it performs. Then, the monitor of Φ can observe that the only update on its contigs was the reception of 
 and 
. Since this operation is under supervision, we many assume it is correct, thus we only need to check the logical errors. In this case, that the obtained contig is not circular when  for the obtained round representation.

7. Conclusions
We designed a new dynamic algorithm for the recognition of PCA, PHCA, and PIG graphs that works only with vertex updates. The algorithm keeps a round block representation Φ of the input graph G that can be regarded as being a positive witness. When the insertion of v into  fails, the algorithms exhibits a minimally forbidden induced subgraph F of H. To work as fast as possible, the algorithm keeps a partial view of  that contains all but  vertices of F. The problem of finding a negative certificate when edges updates are allowed is left open.

The certifying algorithm is optimal when applied for the recognition of static graphs, as it runs in  time per inserted vertex. When both insertions and removals of vertices are allowed, the algorithm is almost optimal, as it takes  time and the lower bound for the problem is  in the cell probe model of computation with word-size b [6].

Regarding the authentication problem, we considered three possibilities, each one giving rise to a different kind of checker. Static checkers test the result of the algorithm for a static graph G. Its input is G together with either a round representation Φ or a graph F, and the goal is to verify that Φ is a round block representation of G or that F is a minimally forbidden induced subgraph of G. Dynamic checkers, instead, test that an operation on a round block representation Φ is successful. Its input, then, is Φ plus the input of the operation and either a round representation Ψ or a minimally forbidden F. The goal in this case is to verify that Ψ is a round block representation of the graph H that should be obtained from  when the operation is applied or to test that F represents a minimally forbidden induced subgraph of H. By definition, the problems associated to the static and dynamic checkers are static and require  and  time in the worst case as either G or Φ have to be traversed, respectively. Monitors, instead, are dynamic algorithms (i.e., data structures) that sit between the user and the round block representation Φ of the dynamic graph G. When a monitor has access to some privileged information, the time required for the authentication can be reduced. In this article we skim through the process of designing a bookkeeping and a supervising monitors. The advantage of the former kind of monitors is that they need no access to the implementation of the data structures. The disadvantage is that they have to re-implement some non-trivial logic of the dynamic algorithm and its correctness could be not simple to prove. We believe that both monitors could be used to authenticate each operation in  time, where t is the time required by the operation itself. There is no proof of this fact, as the monitors are incomplete; yet, we discussed some issues that can arise when these monitors are developed.