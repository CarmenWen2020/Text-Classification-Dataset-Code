Abstract
We propose notions of effective Hausdorff function dimension for subcomputable classes such that while the classical numerical Hausdorff dimension notions coincide as shown by Downey, Merkle and Reimann for Computable and Schnorr dimensions, the corresponding function dimensions disagree.

Keywords
Hausdorff dimension
Algorithmic randomness

Introduction
Hausdorff dimension [8] extends to non-integral values the notion of dimension. Ryabko [18], Staiger [20], Cai and Hartmanis [4] investigated the domain by means of kolmogorov information complexity. Lutz [11], [12] was first to fully effectivize Hausdorff dimension through the use of gales. His notion applies to individual binary sequences and to resource bounded contexts.

The effective Hausdorff dimension of a binary sequence can be viewed as measuring its degree of randomness. Hence to different notions of randomness (possibly weaker than the standard Martin-Löf randomness) correspond different notions of Hausdorff dimensions. By a result of Wang [27], Computable randomness and Schnorr randomness are two strictly different notions of randomness. But Downey, Merkle and Reimann [15], [6] showed that the associated Hausdorff dimensions coincide.

In [24], we focused on the subcomputable situation and studied for a subcomputable class C the notions of C-randomness, C-Schnorr randomness and C-Kurz randomness. Our original motivation here was to consider the corresponding Hausdorff dimensions denoted respectively 
 and 
.

A key point in [6] proof that computable and Schnorr dimension agree, relies on the use of the basic order (natural number valued unbounded and non-decreasing function) , for . One possible way to reintroduce differentiation between the two dimension notions is to consider more complex orders - whose inverse might fail to belong to the class C. Hence one has to extend the numerical Hausdorff dimension to function (or gauge) dimension.

Falconer [7, Ch.2.5] proposes an example of Hausdorff function dimension in the classical framework. The notion has then been developed in the resource bounded and the effective setting by Hitchcock, Lutz and Mayodormo in [10] and by Staiger in [21], [22], [23].

More precisely, the concept of ith order dimension was introduced in [10] via an extension of the notion of s-gales, and it was applied to subcomputable complexity classes. Staiger in [21], [22], [23] studied the notion in the constructive and 
 framework, relating it to Kolmogorov complexity and developing the concept of exact Hausdorff (function) dimension.

Our general notion of Hausdorff function dimension is similar to the one in Staiger's papers, it is formulated in terms of f-gales for an order f; we use a definition much alike [10] (but dropping their parameter ): an f-gale d satisfies for any binary string x, 
.

Another interesting notion of dimension is Packing dimension. Althreya, Hitchcock, Lutz and Mayordomo [1] obtained an elegant characterization in gale terms. They proposed an effectivization of the notion relatively to a class C, called the C strong dimension (see [1, Definition p. 680 (6)]) which is denoted by 
 (one considers the values 
 for s-gales d in C to define 
, and the values 
 to define 
). Through f-gales, one can thus obtain a corresponding notion of Packing function dimension . Motivated by weak randomness notions, we propose two weak notions of dimension 
, 
 as well as their function versions and compare them with the Packing function dimension 
.

The set of orders in a class C is not totally ordered - even asymptotically - as is the set of orders , for , or as are the classes of functions considered in [10] where one obtains a numerical value for the notion of ith dimension. In this article, the notion of function dimension is understood as a predicate rather than as a value. This is also the case for Staiger's notion of exact dimension [21] which requires more control. If C is some class, f some unbounded function from the set of natural numbers into itself and ξ an infinite binary sequence, then we set
  (We add a superscript  to denote the function dimension.)

If C is the class of computable functions, the class of primitive recursive functions or PSPACE, then the following holds: for an infinite binary sequence ξ, 
 

In the function dimension situation, dealing with a class C and given , can we hope for the following equivalences?

The equivalences do hold for the class C of computable functions. For our subcomputable classes, the implications from left to right are satisfied but the implications from right to left are not. For instance, if C is the class of primitive recursive functions, h the (polynomial time computable) inverse of the Ackermann function and Id the identity function, then we obtain:

(1)
there is a computable sequence 
 such that 
 and for no order , 
,

(2)
there is a computable sequence 
 such that 
,

 and for no order , 
.

More generally, we investigate the field of Hausdorff function dimension in the subcomputable framework.
1. A few classical definitions
1.1. Some notation
 denote respectively the set of natural, integer, rational, dyadic rational and real numbers (dyadic rational numbers are of the form 
, for  and ). Id denotes the identity function on the set of natural integers.

Cantor space 
 is the set of infinite binary sequences, 
 denotes the set of finite binary sequences (or strings on ).

• If x is a finite sequence, then  represents its length. For an integer , 
 is the restriction of x onto the set  (we identify i with the set ).

We consider the (prefix) partial ordering ≼ defined on finite binary sequences by 
  • To distinguish the length of a string from the absolute value of a real number, we denote by  the absolute value of the real number .

• Now for 
 and , we also write 
 for the restriction of α onto the set

. If 
, the notation  means 
.

If 
, we write  for the corresponding concatenation.

The function  is the classical polynomial time computable bijection (with regard to binary representation) defined as

 
, for .

Let 
 be the polynomial time inverse functions (again with respect to binary representation): for 
.

• Concerning topology and measure, we consider the classical product topology on 
 (see [5], [14]). If 
, then we denote by  the basic open set 
 and if 
,  is the open subset of 
 generated by X, that is

.

μ is the uniform (Lebesgue) measure on 
: if 
, then 
.

1.2. Basic complexity definitions
We shall consider time-complexity classes C of functions of the form: 
  for 
 a class with appropriate closure properties of time-constructible functions.

Such classes C will be in this article:

Definition 1.2.1

(1)
P 
,

(2)
Let  be the function recursively defined by  
 

Then TOWER-EXP
.

We shall consider the space related class:

Definition 1.2.2

PSPACE = 
.

The following classical classes will also be dealt with:

Definition 1.2.3

•
PRIM-REC is the class of primitive recursive functions.

•
COMPUT is the class of computable functions.

(We denote by C both the class of functions in C and the class of predicates whose characteristic function belongs to C.)

When dealing with functions , martingales 
 or approximations 
 of -valued martingales, to decide whether these functions belong to one of the above classes C, we must fix a representation of the different inputs and outputs, and hence a measurement of their size.

•
integers will be under unary representation:  is thus viewed as 
 and its size is n,

•
strings 
 have classically size ,

•
in clear contexts, for functions associated with time bounds, we may interpret a function  as a function from ω into ω by considering the mapping , for instance  denotes 
 (and 
 is 
,

•
we consider a reasonable coding of the dyadic rational numbers: there is a constant  such that any 
, for  and , is coded by a string in 
 of length .

When dealing with function dimension, we shall consider “gales” belonging to the complexity classes C. But in the classical (numerical) case, we shall use C approximations (as in [12]):

Definition 1.2.4

Let C be some complexity class. A function 
 is C approximable if there exists 
 in C such that for any 
.

We shall be interested in finding low complexity counterexamples (i.e. in the class C+ below) to statements about the class C. We thus define

Definition 1.2.5

If C = P, then C 
 
,

if C = TOWER-EXP, then C 
 ,

if C = PSPACE, then C 
 
,

if C = PRIM-REC, then C 
 COMPUT.

For each class C, we shall consider 
 enumerating infinitely often each martingale d in C with  and the “optimal” martingale associated with it: 
. It is possible to define 
 so that there is a 
-valued martingale 
 in a subclass of C+ satisfying for any 
 (see [2] or [24] for more details). We thus state:

Claim 1.2.6

Let C be one of our subcomputable complexity classes. There is a 
-valued martingale 
 such that

(a)
 and for any martingale d in C with  and index e (relatively to 
), one has 

(b)
•
for C = P, 
 DTIME
 
,

•
for C = TOWER-EXP, 
 DTIME
 
,

•
for C = PSPACE, 
 DSPACE
 
,

•
for C = PRIM-REC, 
 is computable.

In the final section about function Packing dimension, we shall need more control on the bounded resources required to compute 
. We shall then return to its definition.

1.3. Orders and complexity classes
We recall a few definitions and facts:

Definition 1.3.1

(i)
A function  is an order if it is non-decreasing and unbounded.

(ii)
Given an order , one defines the “inverse” of f as follows:

for , 
.

(iii)
Let C be one of our complexity classes. An order h is a true C-order if both h and 
 belong to C.

When dealing with the class PSPACE, we shall restrict to true P orders:

Result 1.3.2

[24, 3.22]
Let f be a true PSPACE order. Then there is a true P order h such that for any .

For each subcomputable class C, we shall consider a function 
 in a subclass of C+, majorizing (asymptotically) all functions of C. Its inverse 
 which will turn out to be polynomial time computable (integers under unary representation) will minorize (asymptotically) all true C orders.

Definition 1.3.3

•
If C = P or PSPACE, then 
 for .

•
If C = TOWER-EXP, then 
 for .

•
If C = PRIM-REC, then 
 where A is the Ackermann function defined by 
 

We refer to [25] for all needed properties of the Ackermann function. The following holds:

Fact 1.3.4

Let C be one of our subcomputable classes.

(a)
The functions 
 are all strictly increasing.

(b)
For any function 
 in C, 
 a.e.

We shall consider the inverse of 
:

Definition 1.3.5

For C one of our subcomputable classes, let 
.

Let us note:

Fact 1.3.6

Given C, 
 is an order and (since 
 is strictly increasing) we have:

•
for any 
,

•
for any 
.

Concerning the complexity of 
, one has the following:

Fact 1.3.7

For any of our subcomputable classes C, 
 is polynomial time computable (with integers under unary representation).

2. Hausdorff dimensions
We refer to Falconer's book [7] for classical Hausdorff dimension. For a treatment of effective Hausdorff dimension, Schnorr dimension, Packing dimension or the connection with randomness, we shall resort to the exhaustive exposition of [5]. Important fundational development is proposed in [11], [13], [16] and [1]. We recall now the usual numerical notions of Hausdorff dimension. The next section will introduce the function dimension notions.

2.1. Some definitions and notation
Definition 2.1.1

For , in analogy with Lebesgue measure (and omitting the brackets), one sets:

•
for 
,

•
for 
 not necessarily prefix-free, 
.

The classical Hausdorff dimension is obtained as follows (see [5, 13.1.3]):

Definition 2.1.2

•
For 
 and ,

D is an n-cover of X   iff   and for any .

•
For  and 
, one sets:

–
 is an n-cover of ,

–
,

–
.

•
For 
, let

.

One can check the following:

Result 2.1.3

For 
, 
.

The connection with gales and the effectivization of the concept has been developed by Lutz [11], [13]. 
 
 denotes the limit sup.

Definition 2.1.4

[11]
For 

(1)
•
 is an s-gale if for any 
.

•
Given an s-gale d, 
 
. is the success set of d.

(2)
•
Let 
. If 
 is defined as: 
, then

d is an s-gale   iff  
 is a martingale.

•
If f is a non-decreasing, unbounded function from ω to , then let

 
 
.

•
For d and 
 as above, then by definition 
.

The essential result is:
Theorem 2.1.5

[11], [12]
For 
.

In order to obtain effectivizations and to consider weaker settings: computable and below, Lutz introduced the following:

Definition 2.1.6

[12]
Given a complexity class C,

 

Lutz effective notion of dimension can be applied to individual sequences: for 
, one sets 
.

2.2. Schnorr dimension and computable dimension
Wang [26] showed that computable randomness is strictly stronger than Schnorr randomness. But Reimann [15] proved that the corresponding (numerical) dimensions coincide. We refer to the development in [6].

Definition 2.2.1

[6]
1.
A Schnorr s-test is a uniformly c.e. sequence 
 of subsets of 
 such that 
 and the reals 
, for , are uniformly computable.

2.
 is Schnorr s-null if there is a Schnorr s-test 
 such that 
.

3.
dim
 is Schnorr s-null}.

Referring to Definition 2.1.6 for C the class of computable functions, the following holds:

Theorem 2.2.2

[15], [6]
For any 
, dim
 dim
.

In [6], [15], the following definition which is equivalent to 2.1.6 is used:

dim
.

As in Schnorr's result [19], there is a characterization of Schnorr s-nullness in terms of s-gales and orders. This underlies the above theorem.

Downey, Merkle and Reimann noted in [6] that as for Schnorr randomness, in the definition of Schnorr s-tests 
 (Definition 2.2.1), one could require 
. Hence if we want to extend the definition of Schnorr dimension to the subcomputable case, we cannot simply require 
 to be uniformly in C (
 is primitive recursive). One must control more closely the obtention of 
 in C. A possible definition is the following one (we refer to [24, 3.5,3.7] for more details):

Definition 2.2.3

Let M be a Turing machine and .

(1)
For 
, we set

- 
 

- 
 

(2)
Let 
 be a recursively enumerable set such that . For ,

•
,

•
,

•
.

Definition 2.2.4

Let C be some complexity class and let .

(1)
A C Schnorr s-test is a uniformly computably enumerable sequence 
 of 
 such that there is a machine M, a function φ in C such that if 
, then for any , 
 and 
.

(2)
A set 
 is called C Schnorr s-null if there is a C Schnorr s-test 
 such that 
.

(3)
.

If C is the class of computable functions, then C Schnorr s-nullness is [6] Schnorr s-nullness of Definition 2.2.1.

When developing Schnorr function dimension in the subcomputable context, we shall mention (without proof) Result 3.2.2 which connects C Schnorr s-nullness, s-gales and orders. As in [6] for C = COMPUT, it gives that for C = PSPACE, TOWER-EXP and PRIM-REC, 
 and 
 coincide. In this article, we shall only need the following result (restricting ourselves to ).

We recall that 
 is termed C Schnorr random iff  is not C Schnorr-1-null.

Proposition 2.2.5

[24, Thm 3.38]
Let C be the class PSPACE, TOWER-EXP or PRIM-REC. Then for any 
, 
 

2.3. Kurz dimension and packing dimension
Wang [27] and Buss, Cenzer and Remmel [3] studied different versions of Kurz randomness in the subcomputable framework. We built in [24] on their work. In order to include the class PSPACE, given a class C, let us say about the sequence 
 of finite subsets of 
 that
 

Let us set:

Definition 2.3.1

Let C be some complexity class (possibly C = COMPUT) and let 
.

(1)
ξ is C -Kurz random  
 

(2)
ξ is C-weak random  
 

By results of [3] and an application of the saving account method, we obtained in [24, 4.19] that the two notions are equivalent for C = PRIM-REC (we shall propose a brief argument at the end of this article to show that it is also the case when C = PSPACE or TOWER-EXP). But we have been unable to obtain a similar equivalence for s-gales and 
 “measures” (no saving account method works for s-gales). We thus consider two notions:

Definition 2.3.2

For a complexity class C and 
, let

•
 

•
 

By classical arguments, one obtains:

Result 2.3.3

For C = P, PSPACE, TOWER-EXP, PRIM-REC or COMPUT, and any 
,

Dim

(If d is an s-gale in C, h a true C order such that for any 
. and 
 and 
, then 
 is the expected sequence of finite sets in C such that 
 and 
).

Let us note that if “
 a.e” for an order g, then  
 
 
 (where  
 
  denotes the limit inf). Hence by the work of Athreya et al. characterizing Packing dimension in gale terms, there is some connection between 
 and Packing dimension. This is why we use an upper case in the dimension notation. We refer now to [1].

Definition 2.3.4

[1]
Given a complexity class C and 
 let

- 
 
 
, and

- Dim
.

One can check

Result 2.3.5

Given a complexity class C and 
, 
.

The argument is that if 
 with 
 and d is a C-approximable t-gale such that for any ,  
 
 
, then there is a 
-gale 
 in C such that for any , 
. (see (a)+(b)+(c) of [6] argument that dim 
 
 at the end of subsection 3.2).

A nice characterization of 
 in terms of (strong) entropy rate is proposed in [1, thm 6.4] and can be extended to subcomputable classes by the methods of [9, 5.4, 5.5]. But it does not seem to be adaptable to the function dimension context (the proof is based on the convergence of 
, for  and would not work with  in place of ). We thus omitted this formulation.

3. Hausdorff function (or gauge) dimension
We present first the notion in the non effective situation and restate the definitions in [10] and [23]. We shall then focus on the Schnorr and Kurz definitions for complexity classes C.

3.1. First definitions
Since we deal with asymptotic behaviors of orders, let us set some notation.

Definition 3.1.1

- Let 
 is non-decreasing and unbounded and ,

- For 
, let  
 
 
 

Falconer proposes in [7, Ch. 2.5] a finer notion of dimension on subsets of 
, called “function or gauge dimension”. This was reformulated by Hitchcock et al. [10] and by Staiger (see [23, p. 7,8, Def. 1] in the context of Cantor space:

let  be an increasing function (in the classical numerical dimension situation, one restricted oneself to the functions 
, for )

•
For 
 (not necessarily prefix-free), one sets 
,

•
for 
 and , 
 n-cover of X},

•
.

This partitions the class of increasing functions h into two sets: those for which 
 is finite and those for which it is infinite.

Reimann and Stephan in [17] considered a more general situation: given a function 
 called premeasure, in order to define a notion of ρ-randomness, they set 
 
.

The measure 
 is thus a particular case termed length invariant measure [17, Def. 1].

We shall soon modify the definition above on two inessential points:

•
Instead of the increasing function  used in the sum 
, we shall focus on the function 
, unbounded and increasing, such that 
, for .

•
To limit the consideration of C approximations, we shall then replace the unbounded and increasing function 
 by the order .

Let us first propose some basic definitions for the functions 
. The definition of an f-gale is similar (in spirit) to the one in [10]:

Definition 3.1.2

For 
, one sets

•
if 
, then let 
.

•
 is an f-gale   iff  for all 
,

•
For an f-gale d, 
 
.

Staiger uses (super)martingales instead of f-gales, considering corresponding “success sets”.

The function dimension is not generally a function because of the lack of a total ordering (modulo ≡), but the notion can be perceived intuitively as a class of functions. The following notation reflects this intuition, but rigorously we only deal with a predicate on 
:

Definition 3.1.3

For 
, 
 and 
,

(a)
 iff  
 

(b)
•
 is an n-cover of X},

•
,

•
   iff  
.

If  is the set of functions , for , then this defines the classical numerical Hausdorff dimension. In [10], one considers totally ordered sets 
 obtaining a minimal value which corresponds to the ith dimension. Generally one gets:

Result 3.1.4

For any 
, 
 and 
, 
   iff  
.

Remark 3.1.5

We also note: 
 

Let us introduce the gale characterization. By adapting usual arguments, one gets:

Lemma 3.1.6

(1)
Let 
 and . If 
 is defined by 
, for 
, then d is an f-gale   iff  
 is a martingale.

(2)
Let d be an f-gale. Then for any  and any prefix-free set 
, one has 
 
.

(2) stems from the fact that if d is an f-gale, then 
, for 
, defines a measure representation (see [14, 1.9.2]). This allows the adaptation of Lutz' arguments in [12, Thm. 3.6]:
Proposition 3.1.7

For 
, and 
, 
   iff  
 in -gale s.t. .

The definition of 
 via gales is thus susceptible of being effectivized and applied to a single sequence.

For simplicity, in the following lines, we work with  in place of 
. In the numerical case, dealing with C approximable s-gales, one often had to consider reals s such that 
. This way the function 
 belonged to C (this is used in showing that [6] and [12] definitions of dimCOMPUT coincide).

Similarly to insure that 
 belongs to C- and this way obtaining f-gales in C (rather than C approximable f-gales) - and also to get “quantity measures” 
 in , for a finite set X, we note the following:

Result 3.1.8

For 
, let 
 define its integer part: 
, for .

(1)
Then for any 
 and any f-gale d,

•
 
,

•
 defined by 
 is an 
-gale such that 
, and hence such that 
.

(2)
Hence if 
 
, then for any , 
   iff  
 
.

Because of the two previous facts, even with variants of the notion of function dimension (Schnorr, Kurz weak or Packing), one can limit oneself to orders without loss of generality.
We now introduce complexity classes:

Definition 3.1.9

Let  be the set of orders (from ω into ω). For any f in , any , any complexity class C and any 
, 
   iff  
 in  C, -gale in C s.t. .

Remark 3.1.10

We required f to be an order when considering the relation 
 because it is the meaningful information. But at some points in the article (introduction, Proposition 4.2.3, Proposition 4.3.19), to allow a clearer formulation, we relaxed the requirement.

One can justify it as follows: if  is unbounded and below Id, then 
 defined as 
 is an order and for any order g, 
.
Hence 
.

3.2. Schnorr function dimension
In analogy with the numerical case and referring to Definition 2.2.3, we set:

Definition 3.2.1

Let C be some complexity class and let  C.

(1)
A C Schnorr g-test is a uniformly computably enumerable sequence 
 of 
 such that there is a machine M, a function φ in C such that 
 and for any , 
, 
, 
.

(2)
A set 
 is called C Schnorr g-null if there is a C Schnorr g-test 
 such that 
.

(3)
For  and , 
  iff  
 in  C, .

It is possible to adapt the arguments of [24, Thm. 3.38] to obtain a form of Schnorr's theorem (the proof in [24] is proposed for a single 
, but it works for an arbitrary 
, not necessarily the singleton ). Since we shall not need it, we mention it without proof:

Proposition 3.2.2

Let C be the class PRIM-REC, TOWER-EXP, PSPACE (or COMPUT) and let  be any order in C. Then for any 
, the following are equivalent:

(a)
X is C Schnorr g-null,

(b)
there is a g-gale 
  in C, a true C order h such that for any 

.

Hence if C = PSPACE, TOWER-EXP or PRIM-REC, 
 can be formulated in terms of gales and orders.

Let us return now to the argument of [6] giving the identity dim
 dim
, for 
. The proof of dim
 dim
 consists of the following steps:

let dim
 for  and let 
 (for simplicity, we argue with  in place of 
).

(a)
There are  and d a COMPUT approximable t-gale with . Then for any 
 such that 
, 
 is a COMPUT approximable 
-gale such that 
.

(b)
There must exist a computable 
-gale 
 (by the property on martingales and 
).

(c)
Let  be a rational number such that 
. The function  is a computable order and 
.

(d)
One can then argue as in Schnorr's proof with 
 in place of μ (since 
, the quantity 
 for a finite D belongs to ). One deduces the existence of a Schnorr 
-test 
 such that 
.

(e)
Hence 
.

Let us note that the function  is actually a true P order. Hence by (the numerical subcase of) Proposition 3.2.2, we also deduce that for C = PSPACE, TOWER-EXP or PRIM-REC, the numerical dimensions 
 and 
 coincide.

Let us consider now the function dimension situation when C is a subcomputable class. Let 
. Following the same type of argumentation as above, we shall consider 
 in C such that 
 and a 
-gale d with 
. But even if we can find an order λ in C such that 
., this order may fail to be a true C order when C is a subcomputable class. Thus we cannot conclude 
.

On the opposite, when C is the class of computable functions, since any computable order is a true computable order, (by Proposition 3.2.2) the argument goes through and for any computable order f, 
.

3.3. Kurz function dimension and packing function dimension
We generalize the numerical notions introduced in Subsection 2.3. For a class C, a sequence 
 of finite subsets of 
 and a function g in , we set:
 

Definition 3.3.1

Let C be one of our complexity classes, 
,  and .

(1)
   iff  
.

(2)
   iff   
 

(3)
   iff   
 
 
 

We note

(a)
,

(b)
 (by the classical argument as in the comment after Result 2.3.3).

We saw that 
 in the numerical case. Again if C is the class of computable functions and if f is a computable order, then 
  But for subcomputable classes C, we shall give an example of 
 with 
 and 
 “strictly above” 
.

4. Composed sequences and associated martingales
We recall some usual tools for producing sequences with non-integral effective Hausdorff dimension and adapt them to our situation.

4.1. A few tools
The following notions will be applied in both the Schnorr and the Kurz contexts.

Definition 4.1.1

[5, p. 259]
For X infinite and coinfinite, let 
 and 
 be respectively strictly increasing enumerations of X and of its complement 
. Then for 
, the composed sequence via X of 
 and 
 is defined as follows 
 

We shall consider the following infinite and coinfinite set:

Definition 4.1.2

Let C be one of our subcomputable classes and let 
 be as in Definition 1.3.5. Then 
 is the polynomial time computable (by Fact 1.3.7) set 
.

Both in Schnorr and in Kurz contexts, we shall consider composed sequences of the form 
, for an appropriate 
. By Fact 1.3.6, 
. Hence there is no enumeration of 
 in C. The situation is different for 
:

Claim 4.1.3

For any 
, 
 implies 
.

Proof

One can check that if (C = PRIM-REC and ), or if (C = TOWER-EXP and ), or if (C = P or PSPACE, and 
), then 
. The claim follows by Fact 1.3.6. □

We thus deduce a polynomial time enumeration of 
 (as previously, we identify n with ):

Definition 4.1.4

Let 
 be an increasing enumeration of 
. Then one defines inductively the polynomial time sequence: for 
 

Let us state a few properties of 
 and 
:

Claim 4.1.5

(a)
For any 
,

(b)
For any 
.

Proof

(a)
By Fact 1.3.6, for any 
. Hence for ,
 

(b)
By (a) applied to 
, one has
 □

We can now consider

Definition 4.1.6

Let C be one of our subcomputable classes and let 
 be the increasing enumeration of 
. For 
, let 
. That is 
 

The definition of 
 depends on C, but we omit the subscript C. Since 
 P, we note:

Fact 4.1.7

If ξ∈ C+, then also 
 C+.

In order to argue with martingales (or gales) on ξ and 
, we must finitize the definition of 
:

Definition 4.1.8

(a)
The function 
  is defined as follows:

•
,

•
if , then 
 and  
 

(b)
Let 
 be a left inverse of Hat
 given for 
 by 
 and for any 
. Let us notice that for 
 by Claim 4.1.5.

We also note the following:

Fact 4.1.9

(a)
For 
 and ,

•
If 
, then 
, and otherwise, 
,

•
If 
, then 
, and otherwise, 
.

(b)
HatC and 
 belong to P.

(c)
The link between the finite and the infinite “hat” is the following one: for 
, if 
, then 
.

(d)
Let 
 be such that 
 and for 
. Then 
 is onto 
, and for any 
, there is  such that 
 and 
.

Proof

We justify (c) and (d).

(c) If 
 and 
, then by Claim 4.1.5(b), 
.

Hence 
. By Definition 4.1.8(a), 
  (d) One can check that for any 
. Hence 
 is a surjective order. Moreover if 
 and 
, then 
 (by Claim 4.1.3) and we obtain

. □

Associating martingales, we set:

Definition 4.1.10

Let C be some subcomputable class. Given a martingale 
, let 
 be defined as follows (we again omit the subscript C)

- 
,

- let now 

(1)
if there is  such that 
 and , then 
,

(2)
otherwise 
.

One can deduce from Fact 4.1.9(a),(b):

Claim 4.1.11

 is a martingale. If d belongs to P, then it is also true of 
.

Concerning success sets, one obtains:

Claim 4.1.12

Let C be a subcomputable class, 
 and let 
 (depending on C) be defined from a martingale d as above.

If , then 
.

Proof

Since for 
, 
, we obtain 
. Applying this identity to 
, we deduce from Fact 4.1.9(c): if 
, then 
  Now since , there is 
 above 
 such that 
. By Fact 4.1.9(d), for any , there is 
 such that 
 and 
.

We thus deduce, for all , 
 and
 
 
 
 
 

Hence we can deduce 
 
 
. □

Starting with an arbitrary martingale d, we defined the martingale 
 such that for 
, 
  We now proceed the opposite way: starting with an arbitrary martingale Δ, we define a martingale 
 (r for reduced) such that for 
, 
  An inductive definition of 
 is possible (and more intuitive) but the global definition gives immediately the properties of 
 and shortens the proofs. We thus propose it now:

Definition 4.1.13

Let Δ be a (non identically null) 
-valued martingale. 
 is defined as follows:

- 
,

- For ,

(a)
if 
, then 
 
 
.

(b)
If 
, then let 
 be the longest string ≺σ such that 
.

One sets 
 (which is defined by (a)).

Let us note that if  and 
, then 
. Hence if σ is in case (a), 
. Therefore 
 is well defined. We obtain:

Claim 4.1.14

 is a -valued martingale.

Proof

We compute 
.

Let us note that 
 is independent of j because 
 .

We thus consider two cases:

• Case 1: for both  and , 
.

Hence both 
's are defined as in (b). If 
 is the largest string such that 
 and 
, then 
. Since also 
 (possibly 
), we deduce 
.

• Case 2: for any 
.

Since 
, then also 
. Hence 
 and both 
, for , are defined as in (a).

- If 
, then
 
 
 
 

One deduces
 
 
 
 

- If 
, then
 
 
 
 
 

Hence
 
 
 
 
 
 
 
 
 □

Assuming there is a constant A≥1 such that any rational number  is coded by a string of length , we derive from the definition of 
:

Claim 4.1.15

Let C be one of our complexity classes. If Δ belongs to C, then the -valued 
 also belongs to C.

Since 
 is -valued and in C, by Euclidian algorithm, one can find 
 in C approximating 
. Therefore by usual arguments (see [2], [14]), one obtains:

Claim 4.1.16

Since 
 (-valued) belongs to C, there is a 
-valued martingale 
 in C such that 
.

It remains to check:

Lemma 4.1.17

For any 
.

Proof

We assume 
. Hence 
 is defined as in (a) of Definition 4.1.13:(4.1)
 
 
 Since 
, for any τ, one has(4.2)
 
 

Now for any 
, there is  such that 
 (because by Claim 4.1.3, there is i such that 
 and hence 
).

We thus deduce from (1)+(2): 
 
  □

4.2. C-Schnorr function dimension and C function dimension may disagree
Given C one of our subcomputable classes, we shall produce a sequence 
 such that 
 and 
 disagree. This will be carried out in two steps: we shall first obtain a sequence 
 with appropriate properties (for instance 
 will be C-Schnorr random), we shall then check that 
 is the expected counterexample η.

By a modification of the proof of [24, Prop. 4.3] which is a separation result between C Schnorr randomness and C randomness inspired from [27], we obtain the following:

Proposition 4.2.1

Let C be one of our subcomputable classes. There exists 
 in 
 such that:

(a)
for any martingale d in C with , any , 
 a.e.

(b)
there is a polynomial time martingale 
 such that 
.

We refer to the proof of [24, Prop. 4.3]. We were insuring there that for all true C orders λ, 
 a.e. The computation time of these λ's was varying. Here we deal with a single computation: that of the function 
, which can be carried out in polynomial time. This simplifies the definition of 
.

Sketch of proof

We shall give the new definition of the martingale 
 but we shall propose only very brief justifications. We send here to the arguments in [24].

Let 
 be two functions defined inductively as follows:

•
,

•
We assume that 
 and 
 are defined for all  and that 
.

Case 1: For any 
, one has 
,

one then sets  
  and  
 

Case 2: Otherwise  
 

 belongs to P. Let 
 be the martingale defined in Claim 1.2.6. The sequence 
 is defined inductively as follows:

Definition 4.2.2

Let  and 
 be defined.

(i)
if 
 is in case 1, then 
,

(ii)
otherwise 
 is the (least) value  such that 
.

By the time bounds on 
 (Claim 1.2.6), we note that 
.

• One checks that since 
 is an order, for any 
, case 1 must occur infinitely often along α. By definition (i) of 
 and by definition of 
, one must have 
. This insures (b) of Proposition 4.2.1.

• Now concerning (a), we note that 
 is the number of times case 1 occurred along 
. Moreover 
, for , does increase (at most doubles) only when case 1 occurs. This gives the bound: for all , 
.

The bound required in case 1: 
 combined with the previous bound (and Claim 1.2.6) implies that for e fixed, 
 a.e.

Hence let d be an arbitrary martingale in C with  and let  be such that . If  is such that for any 
, 
. Then 
  □

Our goal is now to derive:

Proposition 4.2.3

If C is one of our subcomputable classes, then there is 
 in C+ such that

(i)
 and for any , 
.

(ii)
η is C-Schnorr random and hence if C is PSPACE, TOWER-EXP or PRIM-REC then for any 
, 
 does not hold.

Since 
, 
 and 
 do not agree on 
.

Proof: Let 
 C+ satisfy the requirements (a) and (b) of Proposition 4.2.1.

We check that 
 is the expected sequence.

(i) Let 
 for a polynomial time martingale 
. We consider the polynomial time martingale 
 defined from 
 as in Definition 4.1.10. Then by Claim 4.1.12, 
.

 is an order in P. Let us consider the 
-gale d in P defined as follows: for 
, 
.

Hence 
 and 
.

• We now show that for any 
.

Claim 4.2.4

For any martingale Δ in C and any , there is  such that

 a.e.

Proof

We consider the 
-valued martingale in C 
 obtained from Δ as in Claim 4.1.16. Claim 4.1.17 gives us for any ,(4.1)

By Proposition 4.2.1 (a), if 
, then for any ,(4.2)
 • If 
, then by Fact 4.1.9 (c), one derives from (3) 
  By (4), for n large enough and 
, one has(4.3)
 • We assume now 
. Then 
. Hence applying inequality (5) to  for n large enough, we get: 
  From 
 and 
, we deduce:

. □

To prove the second part of (i), we argue by contradiction, assuming there is 
 such that(4.4)

Let  be such that 
. The function 
 is not strictly speaking an order. Hence let 
 be defined by  
  
  By (6), there must exist a 
 gale d in C such that 
.

Let us apply the previous claim to the martingale 
. Thus for some , 
  Hence 
 

This contradicts 
 and concludes the proof of part (i).

(ii) By Claim 4.2.4, for any martingale Δ in C, there is  such that 
  Since for any true C order f, 
 a.e., we deduce 
.

Hence by Proposition 2.2.5, if C is PSPACE, TOWER-EXP or PRIM-REC, then 
 is C Schnorr random for the ML characterization: there cannot exist a C Schnorr (Id) test 
 such that 
.

By Definition 3.2.1, for any 
, 
 does not hold.  □

4.3. C Weak, C Kurz and C Packing function dimensions
Given a class C, we shall argue as in the previous subsection: producing a sequence 
 with appropriate properties. We shall then check that 
 satisfies:

,

- 
,

- 
 (Definition 2.3.1).

We shall need an 
-gale in P which succeeds on 
 and which never vanishes. To obtain such a gale, we replace the integer valued 
 by a strictly increasing -valued function 
.

Definition 4.3.1

•
Let 
 satisfy for , 
 
,

•
and let 
 be such that  
 
 

One notes

Fact 4.3.2

For any 
, and for 
.

The difficulty is that 
 is not -valued. It is possible to use P-approximations but the fastest way is to consider the following:

Claim 4.3.3

For any , 
.

Proof

For , let 
. Then 
 
.

• Since 
 
,

- if 
, then 
 
 
,

- if 
, then 
 
 
.

One can check that  
 
 

We deduce that for 

- if 
, then 
 
 
.

- if 
, then 
 
 
. □

We can now set:

Definition 4.3.4

(1)
For , let 
. Then 
 and 
.

(2)
Let F be the 
-valued polynomial time martingale defined inductively by:

•
,

•
 and .

Let us recall that if 
 belongs to 
 then  denotes the length of the string coding q ( where ). If , then 
.

For 
 defined in 1.3.3 and 
, we set:

Definition 4.3.5

Let 
 be the function defined by 
 and let 
 
.

Claim 4.3.6

For any 
, 
.

Proof

We must check that for 
 
.

Let us first note that 
 and hence(4.1)
 
 
 
 By definition of F, 
 .

By 4.3.4, for any 
. Hence we deduce:
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 □

Definition 4.3.7

Let 
 be such that 
.

We have all required tools to obtain an 
-gale succeeding on our expected sequence. Let us deal now with the C-weak randomness aspect. We recall that 
 enumerates (infinitely often) each martingale d in C with  (to compute the complexity of 
, we shall need more care than in the Schnorr subsection and we shall thus return soon to the definition and the complexity of 
).

Definition 4.3.8

(a)
For , let 
 
.

(b)
For , and 
 let 
 be the extension of length 
 of σ defined inductively as follows:

- 
,

- for 
, if 
 is defined, then 
 is the least  such that 
.

Claim 4.3.9

For any 
 and , 
.

Proof

Since 
, one has 
. Also by construction, 
, we thus deduce: 
 
. □

This motivates the following:

Definition 4.3.10

(1)
Let 
 be such that 
 

(2)
 is the sequence of strings such that:

- 

- for , 
.

(3)
Let 
 (the sequence  
 is strictly increasing).

F being the martingale defined in 4.3.4, we shall check the following:

Proposition 4.3.11

(i)
 
 i.o.

(ii)
For any martingale d  in  C with  and any , 
 
 i.o.

Proof

(i) For each e odd, 
. Hence by Claim 4.3.6, it belongs to 
; that is 
 
. Hence 
 
 i.o.

(ii) If e is even, then by Claim 4.3.9, 
 
. Now any martingale d in C with  is enumerated as 
 for infinitely many even e's. Hence for any such , 
 
 and 
 
 i.o. □

To evaluate the complexity of 
, we must deal first with 
. If C is PRIM-REC, then clearly 
 is computable. We consider the other classes:

Claim 4.3.12

(a)
If C = P, then 
 DTIME
.

(b)
If C = PSPACE, then 
 DSPACE
.

(c)
If C = TOWER-EXP, then 
 DTIME
.

Proof

(a) Let C = P. Then 
, 
 and 
.

Since F belongs to P, there are  such that for any σ,  is computed in time 
. In particular, 
.

 is time-constructible (i.e. 
 can be obtained in time 
. Hence for some constant D, 
 can be obtained in less than 
 steps.

One can check that there is  such that 
 a.e.

Since 
 a.e. we deduce that 
 DTIME
.

(b) For C = PSPACE, 
. Hence 
.

(c) Let C = TOWER-EXP. Then 
. 
 is also time-constructible. Let  be computed in time 
.(4.2)
(4.3)
 By applying (8) and (9) to respectively the first and the second arguments of the function T, we obtain:
 One derives that 
 DTIME
. □

Now to obtain the complexity of 
, with e even, we must be more careful in the evaluation of the resource needed in the computation of the “universal” martingale 
. We shall distinguish the weights of  and of 
 rather than considering the global measure . This is motivated by the fact that in computing 
, we shall apply 
 to  with  and 
, for some n (the distinction is crucial for C = P and C = TOWER-EXP).

By traditional arguments, one obtains:

Claim 4.3.13

(a)
Let C = P.

• There are a function 
 enumerating (infinitely often) each polynomial time function from 
 into 
 and  such that the computation of 
 on  requires at most 
 steps (one considers a universal machine 
 simulating the machine 
 during 
 steps).

• 
 enumerating all P-martingales d with  is deduced from 
 as in [2], and for some , requires on input  at most 
 steps.

(b)
let C = PSPACE. There are  such that

• 
 enumerates all PSPACE functions 
. Its computation on  requires at most 
 cells.

• 
 enumerates (infinitely often) all PSPACE martingales d with , using on input  at most 
 cells.

(c)
Let C = TOWER-EXP.

• 
 on  will need at most 
 steps.

• 
 on  will need at most 
 steps.

(If necessary in the arguments, we assume ) we deduce from the previous claim:

Claim 4.3.14

(a)
For C = P, 
 DTIME
.

(b)
For C = PSPACE, 
 DSPACE
.

(c)
For C = TOWER-EXP, 
 DTIME
.

Proof

We need to check how much time or space, 
 needs on an input  for e even.

(a) Let C = P. By Claim 4.3.13(a), there is 
 such that at each stage i with 
, one needs at most 
 steps to compute 
. Hence the whole process for obtaining 
 requires time 
.

Now 
. Hence if we set , then 
.

Also 
 a.e. Combining this with Claim 4.3.12(a) and the fact that checking parity can be done in linear time, we deduce 
 DTIME
.

(b) We argue in a similar way for C = PSPACE (this is actually a little easier).

(c) Let now C = TOWER-EXP and 
. By Claim 4.3.13(c), there is  such that each stage 
 requires at most 
 steps. Hence the whole process requires time θ with 
.

Let again . Then 
. Also(4.4)
 Hence for some 
,
 Hence 
 DTIME
. □

We can now deduce:

Lemma 4.3.15

For C one of our subcomputable classes, 
 belongs to the class C+.

Proof

Let . To obtain 
, we must find the least 
 such that 
. Then 
. We must thus compute all 
, for 
. By definition of 
, 
. Hence 
. For all 
, 
.

(a) Let C = P. By Claim 4.3.14(a), there is  such that for each 
, the computation of 
 takes time at most 
. The computation of all steps 
 and hence of 
 takes time at most 
. But 
 a.e. Hence 
 DTIME
.

(b) Let C = PSPACE. By a similar (but slightly simpler) argument, we obtain 
 DSPACE
.

(c) Let C = TOWER-EXP. By Claim 4.3.14(c), there is  such that the computation of 
 takes time at most 
. Using 
., one can check that 
 a.e. Hence 
 DTIME.

(d) Let C = PRIM-REC. Since 
 is computable, 
 is also computable. □

Let 
 C+ satisfy Proposition 4.3.11. We consider 
. Then by 4.1.7, 
 C+.

Lemma 4.3.16

There is a polynomial time 
-gale 
 such that 
.

Proof

By Proposition 4.3.11(i), there is 
 above 
 strictly increasing such that for ,(4.5)
 
 By Fact 4.1.9(d), for each , there is 
 such that 
 and 
.

Let us consider the polynomial time martingale 
 defined from F as in Definition 4.1.10. Hence 
, for .

From Fact 4.1.9(c) and 
, we deduce 
.

Therefore if , 
.

By (11), for ,
 
 
 
 Let 
 be the 
-gale defined by 
. Then for all , 
 
. Hence 
. □

Let us recall that 
 is C-weak random if for any true C-order λ and any martingale Δ in C, 
 i.o.

Lemma 4.3.17

For C = P, PSPACE, TOWER-EXP and PRIM-REC, 
 is C-weak random.

Proof

Let Δ be an arbitrary 
-valued martingale in C. We then define 
 and 
 which is 
-valued in C such that 
 as in Definition 4.1.13 and Claim 4.1.16. By Claim 4.1.17, for any ,(4.6)
 By (ii) of Proposition 4.3.11, there is  (
) such that 
 i.o.

Let 
 above 
 be a strictly increasing sequence of integers such that for any ,(4.7)
 Again by Fact 4.1.9(c),(d), for , let 
 be so that 
.

We deduce from (12) and (13): for  
  Now any true C-order λ satisfies 
 a.e. Hence 
 i.o. □

Let us state now the results concerning the Packing function dimension.

Lemma 4.3.18

Let C be one of our subcomputable classes.

(a)
.

(b)
For any , 
.

Proof

(a) Let d be the polynomial time martingale defined as follows: 
 
 
  Then for any ,(4.8)
 
 Let f be a polynomial time order such that 
. Then 
 defines a polynomial time f-gale such that, because of (14), for any , 
 
.

Since 
,  
 
 
. Hence 
.

(b) We now argue by contradiction and suppose there is 
 such that(4.9)
 Let 
. As in the proof of Proposition 4.2.3(i), since 
 
 is not strictly speaking an order, we consider the order:

 
. We note:(4.10)
 
(4.11)

By (15) and (17), there must exist a 
-gale d in C such that  
 
 
.

Then 
 is a martingale in C. As in the proof of Lemma 4.3.17, we consider the martingales 
 and 
 defined from Δ such that  
 

By Proposition 4.3.11(ii), there are  and a strictly increasing sequence of integers 
 above 
 such that(4.12)
 
 For each , let 
 be such that 
 and 
. Then for (4.13)
 
 
 Hence for ,
 
 
 
 
 This contradicts  
 
 
. □

Let us collect all previous results in the following:

Proposition 4.3.19

Let C be one of our subcomputable classes. Then there exists 
 in C+ such that

(a)
,

(b)
 and for any ,

 
,

(c)
for any 
, 
. Moreover if C = PSPACE, TOWER-EXP or PRIM-REC, then one can strengthen (c): for any 
, 
. In particular 
.

We recall that in the numerical situation, we had 
.

Proof

(a), (b), (c) derive from Fact 4.1.7 and Lemma 4.3.16, Lemma 4.3.17, Lemma 4.3.18. Let us note that the association of (a) and (c) mirrors [1, Thm. 6.5].

Concerning the strengthening of (c), this stems from the fact that for C = PSPACE, TOWER-EXP or PRIM-REC, the following equivalence holds: for any 
, 
  Let us justify it briefly:

• The argument for ⇐ is as for Result 2.3.3.

• For ⇒, one argues by contradiction, assuming ξ C weak random and 
 with 
, for f∈C, 
 and 
 in C.

(Dealing with the measure μ) we can suppose 
 with f strictly increasing.

Let d be the martingale defined by 
 where for 
,  is the conditional probability 
 
.

If C is PSPACE or closed under exponentiation, then d is C-approximable. Let 
 C be such that 
. Then for all , 
. By the method of Saving accounts (see [24, Fact 4.19] for a similar situation), if , then there exists a martingale 
 in C such that 
 a.e. 
 is a true C-order because g is in C and strictly increasing. Hence ξ is not C-weak random. □

Some recapitulation and induced questions:

•
If C is any of our subcomputable classes, we exhibited in Propositions 4.2.3(i) and 4.3.19, sequences 
, 
 in C+ such that

•
By Propositions 4.2.3(i) and 4.3.19(b), 
 and 
 are “almost exactly” 
: the dimensions are intuitively below 
 and above 
, for all . This evokes Staiger's notion of exact (function) dimension (see [23, Thm. 4]). The arguments of this article do not show that 
 is the exact function dimension of 
 or 
 for some notion of C exact function dimension, but it is worth studying it.

•
There also remain many questions regarding Packing or weak dimensions. For instance:

- Is it possible to extend the notion of (strong) entropy rate (see [1], [9]) to the function dimension case in order to obtain a nice characterization of “
” (we mentioned the difficulty after Result 2.3.5)?

- We know 
. Does the reverse implication hold?