Abstract
Adaptive oblivious transfer (OT) is a protocol where a sender initially commits to a database . Then, a receiver can query the sender up to k times with private indexes  so as to obtain  and nothing else. Moreover, for each , the receiver's choice  may depend on previously obtained messages . Oblivious transfer with access control (OT-AC) is a flavor of adaptive OT where database records are protected by distinct access control policies that specify which credentials a receiver should obtain in order to access each . So far, all known OT-AC protocols only support access policies made of conjunctions or rely on ad hoc assumptions in pairing-friendly groups (or both). In this paper, we provide an OT-AC protocol where access policies may consist of any branching program of polynomial length, which is sufficient to realize any access policy in . The security of our protocol is proved under the Learning-with-Errors () and Short-Integer-Solution () assumptions. As a result of independent interest, we provide protocols for proving the correct evaluation of a committed branching program on a committed input.


Keywords
Lattice assumptions
Standard assumptions
Zero-knowledge arguments
Adaptive oblivious transfer

1. Introduction
Oblivious transfer (OT) is a central cryptographic primitive coined by Rabin [52] and extended by Even et al. [23]. It involves a sender  with a database of messages 
 and a receiver  with an index . The protocol allows  to retrieve the ρ-th entry 
 from  without letting  infer anything on 's choice ρ. Moreover,  only obtains 
 learns nothing about 
.

In its adaptive flavor [47], OT allows the receiver to interact k times with  to retrieve 
 in such a way that, for each , the i-th index 
 may depend on the messages 
 previously obtained by .

OT is known to be a complete building block for cryptography (see, e.g., [28]) in that, if it can be realized, then any secure multiparty computation can be. In its adaptive variant, OT is motivated by applications in privacy-preserving access to sensitive databases (e.g., medical records or financial data) stored in encrypted form on remote servers, oblivious searches or location-based services.

As far as efficiency goes, adaptive OT protocols should be designed in such a way that, after an inevitable initialization phase with linear communication complexity in N and the security parameter λ, the complexity of each transfer is at most poly-logarithmic in N. At the same time, this asymptotic efficiency should not come at the expense of sacrificing ideal security properties. The most efficient adaptive OT protocols that satisfy the latter criterion stem from the work of Camenisch, Neven and shelat [14] and its follow-ups [30], [31], [32].

In its basic form, (adaptive) OT does not restrict in any way the population of users who can obtain specific records. In many sensitive databases (e.g., DNA databases or patients' medical history), however, not all users should be able to download all records: it is vital access to certain entries be conditioned on the receiver holding suitable credentials delivered by authorities. At the same time, privacy protection mandates that authorized users be able to query database records while leaking as little as possible about their interests or activities. In medical datasets, for example, the specific entries retrieved by a given doctor could reveal which disease his patients are suffering from. In financial or patent datasets, the access pattern of a company could betray its investment strategy or the invention it is developing. In order to combine user-privacy and fine-grained database security, it is thus desirable to enrich adaptive OT protocols with refined access control mechanisms in many of their natural use cases.

This motivated Camenisch, Dubovitskaya and Neven [12] to introduce a variant named oblivious transfer with access control (OT-AC), where each database record is protected by a different access control policy 
⁎
. Based on their attributes, users can obtain credentials generated by pre-determined authorities, which entitle them to anonymously retrieve database records of which the access policy accepts their certified attributes: in other words, the user can only download the records for which he has a valid credential 
 for an attribute string 
⁎
 such that . During the transfer phase, the user demonstrates possession of a pair 
 and simultaneously convinces the sender that he is querying some record 
 associated with a policy P such that . The only information that the database holder eventually learns is that some user retrieved some record which he was authorized to obtain.

Camenisch et al. formalized the OT-AC primitive and provided a construction in groups with a bilinear map [12]. While efficient, their solution “only” supports access policies consisting of conjunctions: each policy P is specified by a list of attributes that a given user should obtain a credential for in order to complete the transfer. Several subsequent works [57], [13], [11] considered more expressive access policies while even hiding the access policies in some cases [13], [11]. Unfortunately, all of them rely on non-standard assumptions (known as “q-type assumptions”) in groups with a bilinear map. For the sake of not putting all one's eggs in the same basket, a primitive as powerful as OT-AC ought to have alternative realizations based on firmer foundations.

In this paper, we propose a solution based on lattice assumptions where access policies consist of any branching program of width 5, which is known [6] to suffice for the realization of any access policy in . As a result of independent interest, we provide protocols for proving the correct evaluation of a committed branching program. More precisely, we give zero-knowledge arguments for demonstrating possession of a secret input 
 and a secret (and possibly certified) branching program  such that .

Related Work. Oblivious transfer with adaptive queries dates back to the work of Naor and Pinkas [47], which requires  interaction rounds per transfer. Naor and Pinkas [49] also gave generic constructions of (adaptive) k-out-of-N OT from private information retrieval (PIR) [17]. The constructions of [47], [49], however, are only secure in the half-simulation model, where simulation-based security is only considered for one of the two parties (receiver security being formalized in terms of a game-based definition). Moreover, the constructions of Adaptive OT from PIR [49] require a complexity 
 at each transfer where Adaptive OT allows for  cost. Before 2007, many OT protocols (e.g., [48], [3], [56]) were analyzed in terms of half-simulation.

While several efficient fully simulatable protocols appeared the last 15 years (e.g., [19], [43], [51] and references therein), full simulatability remained elusive in the adaptive k-out-of-N setting [47] until the work [14] of Camenisch, Neven and shelat, who introduced the “assisted decryption” paradigm. The latter consists in having the sender obliviously decrypt a re-randomized version of one of the original ciphertexts contained in the database. This technique served as a blueprint for many subsequent protocols [30], [31], [32], [36], including those with access control [12], [13], [11], [1] and those presented in this paper. In the adaptive k-out-of-N setting (which we denote as 
 ), the difficulty is to achieve full simulatability without having to transmit  bits at each transfer. To our knowledge, except the oblivious-PRF-based approach of Jarecki and Liu [36], all known fully simulatable 
 protocols rely on bilinear maps.2 A recent work of Döttling et al. [21] uses non-black-box techniques to realize -based 2-round oblivious PRF (OPRF) protocols [25]. However, while fully simulatable OPRFs imply [36] fully simulatable adaptive OT, the OPRF construction of [21] does not satisfy the standard notion of full simulation-based security against malicious adversaries (which is impossible to achieve in two rounds). It also relies on the full power of homomorphic encryption, which we do not require.

A number of works introduced various forms of access control in OT. Priced OT [3] assigns variable prices to all database records. In conditional OT [20], access to a record is made contingent on the user's secret satisfying some predicate. Restricted OT [33] explicitly protects each record with an independent access policy. Still, none of these OT flavors aims at protecting the anonymity of users. The model of Coull, Green and Hohenberger [18] does consider user anonymity via stateful credentials. For the applications of OT-AC, it would nevertheless require re-issuing user credentials at each transfer.

While efficient, the initial OT-AC protocol of Camenisch et al. [12] relies on non-standard assumptions in groups with a bilinear map and only realizes access policies made of conjunctions. Abe et al. [1] gave a different protocol which they proved secure under more standard assumptions in the universal composability framework [15]. Their policies, however, remain limited to conjunctions. It was mentioned in [12], [1] that disjunctions and DNF formulas can be handled by duplicating database entries. Unfortunately, this approach rapidly becomes prohibitively expensive in the case of -threshold policies with . Moreover, securing the protocol against malicious senders requires them to prove that all duplicates encrypt the same message. More expressive policies were considered by Zhang et al. [57] who gave a construction based on attribute-based encryption [54] that extends to access policies expressed by any Boolean formulas (and thus  circuits). Camenisch, Dubovitskaya, Neven and Zaverucha [13] generalized the OT-AC functionality so as to hide the access policies. In [11], Camenisch et al. gave a more efficient construction with hidden policies based on the attribute-based encryption scheme of [50]. At the expense of a proof in the generic group model, [11] improves upon the expressiveness of [13] in that its policies extend into CNF formulas. While the solutions of [13], [11] both hide the access policies to users (and the successful termination of transfers to the database), their policies can only live in a proper subset of . As of now, threshold policies can only be efficiently handled by the ABE-based construction of Zhang et al. [57], which requires ad hoc assumptions in groups with a bilinear map.

Our Results and Techniques. We describe the first OT-AC protocol based on lattice assumptions. Our construction supports access policies consisting of any branching program of width 5 and polynomial length – which suffices to realize any  circuit – and prove it secure under the  and  assumptions. We thus achieve the same level of expressiveness as [57] with the benefit of relying on well-studied assumptions. In its initial version, our protocol requires the database holder to communicate  bits to each receiver so as to prove that the database is properly encrypted. In the random oracle model, we can eliminate this burden via the Fiat-Shamir heuristic and make the initialization cost linear in the database size N, regardless of the number of users.

As a first step, we build an ordinary 
 protocol (i.e., without access control) via the “assisted decryption” approach of [14]. In short, the sender encrypts all database entries using a semantically secure cryptosystem. At each transfer, the receiver gets the sender to obliviously decrypt one of the initial ciphertexts without learning which one. Security against malicious adversaries is achieved by adding zero-knowledge (ZK) or witness indistinguishable (WI) arguments that the protocol is being followed. The desired ZK or WI arguments are obtained using the techniques of [40] and we prove that this basic protocol satisfies the full simulatability definitions of [14] under the  and  assumptions. To our knowledge, this protocol is also the first 
 realization to achieve the standard simulation-based security requirements under lattice assumptions.

So far, all known “beyond-conjunctions” OT-AC protocols [57], [11] rely on ciphertext-policy attribute-based encryption (CP-ABE) and proceed by attaching each database record to a CP-ABE ciphertext. Our construction departs from the latter approach for two reasons. First, the only known -based CP-ABE schemes are obtained by applying a universal circuit to a key-policy system, making them very inefficient. Second, the ABE-based approach requires a fully secure ABE (i.e., selective security and semi-adaptive security are insufficient) since the access policies are dictated by the environment after the generation of the issuer's public key, which contains the public parameters of the underlying ABE in [57], [11]. Even with the best known -based ABE candidates [29], a direct adaptation of the techniques in [57], [11] would incur to rely on a complexity leveraging argument [8] and a universal circuit. Instead, we take a different approach and directly prove in a zero-knowledge manner the correct evaluation of a committed branching program for a hidden input.

At a high level, our OT-AC protocol works as follows. For each , the database entry 
 is associated with branching program 
. In the initialization step, the database holder generates a Regev ciphertext 
 of 
, and issues a certificate for the pair 
, using the signature scheme from [40]. At each transfer, the user  who wishes to get a record  must obtain a credential 
 for an attribute string 
 such that 
. Then,  modifies 
 into an encryption of 
, for some random string 
, and re-randomizes the resulting ciphertext into a fresh encryption 
 of 
. At this point,  proves that 
 was obtained by transforming one of the original ciphertexts 
 by arguing possession of a valid certificate for 
 and knowledge of all randomness used in the transformation that yields 
. At the same time,  proves possession of 
 for a string x which is accepted by the committed 
. To demonstrate these statements in zero-knowledge, we develop recent techniques [45], [42], [40] for lattice-based analogues [37], [44] of Stern's protocol [55].

As a crucial component of our OT-AC protocol, we need to prove knowledge of an input 
 satisfying a hidden  of length L, where L and κ are polynomials in the security parameter. For each , we need to prove that the computation of the θ-th state(1)
 is done correctly, for permutations 
 and for integer  specified by . To date, equations of the form (1) have not been addressed in the context of zero-knowledge proofs for lattice-based cryptography. In this work, we are not only able to handle L such equations, but also manage to do so with a reasonable asymptotic cost. Below, we will explain the latter aspect.

In order to compute 
 as in (1), we have to fetch the value 
 in the input 
 and provide evidence that the searching process is conducted honestly. If we perform a naive left-to-right search in the array 
, the expected complexity is  for each step, and the total complexity amounts to . If we instead perform a dichotomic search over 
, we can decrease the complexity at each step down to . However, in this case, we need to prove in zero-knowledge a statement “I obtained 
 by conducting a correct dichotomic search in my secret array.”

We solve this problem as follows. For each , we employ a SIS-based commitment scheme [37] to commit to 
 as 
, and prove that the committed bits are consistent with the ones involved in the credential 
 mentioned above. Then we build a SIS-based Merkle hash tree [42] of depth 
 on top of the commitments 
. Now, for each , we consider the binary representation 
 of . We then prove knowledge of a bit 
 such that these conditions hold: “If one starts at the root of the tree and follows the path determined by the bits 
, then one will reach the leaf associated with the commitment opened to 
.” The idea is that, if the Merkle tree and the commitment scheme are both secure, then it should be true that 
. In other words, this enables us to provably perform a “binary search” for 
. Furthermore, this process can be done in zero-knowledge, by adapting the recent techniques from [42]. As a result, we obtain a protocol with communication cost just .

We believe that our idea of bringing Merkle trees into the context of privacy-preserving protocols for branching programs to decrease the asymptotic complexity will be of independent interest. For instance, it may find applications in the private computation of branching programs [46], [35].

2. Background and definitions
Vectors are denoted in bold lower-case letters and bold upper-case letters will denote matrices. The Euclidean and infinity norm of any vector 
 will be denoted by  and 
, respectively. The Euclidean norm of matrix 
 with columns 
 is 
. When B has full column-rank, we let 
 denote its Gram-Schmidt orthogonalization.

When S is a finite set, we denote by  the uniform distribution over S, and by  the action of sampling x according to this distribution. Finally, for any integers , we let  and  denote the sets  and , respectively.

2.1. Lattices
A lattice L is the set of integer linear combinations of linearly independent basis vectors 
 living in 
. We work with q-ary lattices, for some prime q.

Definition 1

Let , a prime  and 
 and 
, define 
 as well as

For a lattice L, let 
 for a vector 
 and a real . The discrete Gaussian of support L, center c and parameter σ is 
 for any , where 
. The distribution centered in  is denoted by 
.
It is well-known that one can efficiently sample from a Gaussian distribution with lattice support given a sufficiently short basis of the lattice.

Lemma 1

[10, Le. 2.3]
There exists a PPT algorithm  that takes as inputs a basis B of a lattice 
 and a rational 
, and outputs vectors  with distribution 
.

We also rely on the trapdoor generation algorithm of Alwen and Peikert [4], which refines the technique of Gentry et al. [26].

Lemma 2

[4, Th. 3.2]
There is a PPT algorithm  that takes as inputs 
, 
 and an integer  with , and outputs a matrix 
 and a basis 
 of 
 such that A is within statistical distance 
 to 
, and 
.

We use the basis delegation algorithm [16] that inputs a trapdoor for 
 and produces a trapdoor for any 
 containing A as a submatrix. A technique from Agrawal et al. [2] is sometimes used in our proofs.
Lemma 3

[16, Le. 3.2]
There is a PPT algorithm  that inputs 
 whose first m columns span 
, and a basis 
 of 
 where 
 is a submatrix of B, and outputs a basis 
 of 
 with 
.

Lemma 4

[2, Th. 19]
There is a PPT algorithm  that inputs 
, a small-norm 
, a short basis 
 of 
, a vector 
 and a rational σ such that 
, and outputs 
 such that  
  and with distribution statistically close to 
 where 
 .

2.2. Hardness assumptions
Definition 2

Let  be functions of . The Short Integer Solution problem 
 is, given 
, find 
 with .

If  and , then standard worst-case lattice problems with approximation factors 
 reduce to 
 (see, e.g., [26, Se. 9]).
Definition 3

Let , , and let χ be a probability distribution on . For 
, let 
 be the distribution obtained by sampling 
 and , and outputting 
. The Learning With Errors problem 
 asks to distinguish m samples chosen according to 
 (for 
) and m samples chosen according to 
.

If q is a prime power, , 
, then there exists an efficient sampleable B-bounded distribution χ (i.e., χ outputs samples with norm at most B with overwhelming probability) such that 
 is as least as hard as 
 (see, e.g., [53], [10]).

2.3. Adaptive oblivious transfer
In the syntax of [14], an adaptive k-out-of-N OT scheme 
 is a tuple of stateful  algorithms 
. The sender 
 consists of two interactive algorithms 
 and 
 and the receiver has a similar representation as algorithms 
 and 
. In the initialization phase, the sender and the receiver run interactive algorithms 
 and 
, respectively, where 
 takes as input messages 
 while 
 has no input. This phase ends with the two algorithms 
 and 
 outputting their state information 
 and 
 respectively.

During the i-th transfer, , both parties run an interactive protocol via the 
 and 
 algorithms. The sender starts runs 
 to obtain its updated state information 
 while the receiver runs 
 on input of its previous state 
 and the index 
 of the message it wishes to retrieve. At the end, 
 outputs an updated state 
 and a message 
.

Correctness mandates that, for all 
, for all 
 and all coin tosses ϖ of the (honestly run) algorithms, we have 
 for all i.

We consider protocols that are secure (against static corruptions) in the sense of simulation-based definitions. The security properties against a cheating sender and a cheating receiver are formalized via the “real-world/ideal-world” paradigm. The security definitions of [14] are recalled in Appendix B.1.

2.4. Adaptive oblivious transfer with access control
Camenisch et al. [12] define oblivious transfer with access control (OT-AC) as a tuple of PPT algorithms/protocols  such that:

:
takes as inputs public parameters  specifying a set  of access policies and generates a key pair 
 for the issuer.

:
is an interactive protocol between the issuer I and a stateful user  under common input , where x is an attribute string. The issuer I takes as inputs its key pair 
 and a user pseudonym 
. The user takes as inputs its state information 
. The user  outputs either an error symbol ⊥ or a credential 
, and an updated state 
.

:
is an algorithm that takes as input the issuer's public key 
, a database 
 containing records 
 whose access is restricted by an access policy 
 and outputs a database public key 
, an encryption of the records 
 and a database secret key 
.

:
is a protocol between the database  and a user  with common inputs 
.  inputs 
 and  inputs 
, where  is a record index to which  is requesting access. The interaction ends with  outputting ⊥ or a string 
 and an updated state 
.

We assume private communication links, so that communications between a user and the issuer are authenticated, and those between a user and the database are anonymized: otherwise, anonymizing the  protocol is impossible.

The security definitions formalize two properties called user anonymity and database security. The former captures that the database should be unable to tell which honest user is making a query and neither can tell which records are being accessed. This should remain true even if the database colludes with corrupted users and the issuer. As for database security, the intuition is that a cheating user cannot access a record for which it does not have the required credentials, even when colluding with other dishonest users. In case the issuer is colluding with these cheating users, they cannot obtain more records from the database than they retrieve. Precise security definitions [12] are recalled in Appendix B.2.

2.5. Vector decompositions
We will employ the decomposition technique from [44], [40], which allows transforming vectors with infinity norm larger than 1 into vectors with infinity norm 1.

For any 
, define the number 
 and the sequence 
, where 
 
, 
. This sequence satisfies 
 and any integer  can be decomposed to 
 such that 
. We describe this decomposition procedure in a deterministic manner as follows:

1.
Set 
; For  to 
 do:

If 
 then 
, else 
; 
.

2.
Output 
.

For any positive integers , we define 
 and the following injective functions:
(i)
 that maps vector 
 to vector 
 
. Note that 
.

(ii)
 that maps vector 
 to vector 
, where for each : 
 if 
; 
 if 
; 
 if 
. Note that 
.

3. Building blocks
We will use two distinct signature schemes because one of them only needs to be secure in the sense of a weaker security notion and can be more efficient. This weaker notion is sufficient to sign the database entries and allows a better efficiency in the scheme of Section 4. In particular, by making it stateful (which also suffices since all database entries are signed at once), we can reduce the public key size to  matrices if N is the number of database entries. The second scheme must be stateful and secure in the standard EUF-CMA sense since the issuer uses it to certify users' attributes. The signature scheme of Section 3.1 is only used in the OT-AC protocol of Section 4 while the scheme of Section 3.2 is used in the adaptive OT protocol of Section 5 as well.

3.1. Signatures supporting efficient zero-knowledge proofs
We use a signature scheme proposed by Libert et al. [40] who extended the Böhl et al. signature [7] in order to sign messages comprised of multiple blocks while keeping the scheme compatible with zero-knowledge proofs.

:
Given a security parameter  and the number of blocks 
, choose , a prime modulus 
, a dimension ; an integer  and Gaussian parameters . Define the message space as 
.

1.
Run 
 to get 
 and a short basis 
 of 
. This basis allows computing short vectors in 
 with a Gaussian parameter σ. Next, choose  random 
.

2.
Pick random matrices 
, 
 for 
, as well as a random vector 
.

The private signing key consists of 
 while the public key is comprised of 
.
:
To sign an 
-block 
,

1.
Choose 
. Using 
, compute a short basis 
 for 
, where 
.

2.
Sample 
. Compute the vector 
 as a chameleon hash of 
. Namely, compute 
, which is used to define 
. Using the delegated basis 
, sample a vector 
 in 
.

Output the signature 
.
:
Given 
 and 
, return 1 if ,  and(2)
 

3.2. A simpler variant with bounded-message security and security against non-adaptive chosen-message attacks
We consider a stateful variant of the scheme in Section 3.1 where a bound  on the number of signed messages is fixed at key generation time. In the context of 
, this is sufficient and leads to efficiency improvements. In the modified scheme hereunder, the string 
 is an ℓ-bit counter maintained by the signer to keep track of the number of previously signed messages. This simplified variant resembles the -based signature scheme of Böhl et al. [7].

In this version, the message space is 
 so that vectors of 
 can be signed by first decomposing them using 
.

:
Given  and the maximal number  of signatures, choose , a prime 
, , an integer  and Gaussian parameters . The message space is 
, for some 
 with 
.

1.
Run 
 to get 
 and a short basis 
 of 
, which allows sampling short vectors in 
 with a Gaussian parameter σ. Next, choose  random 
.

2.
Choose 
 as well as a random vector 
.

The counter τ is initialized to . The private key consists of 
 and the public key is 
.
:
To sign a message 
,

1.
Increment the counter by setting  and interpret it as a string 
. Then, using 
, compute a short delegated basis 
 for the matrix 
.

2.
Compute the vector 
. Then, using the delegated basis 
, sample a short vector 
 in 
.

Output the signature 
.
:
Given PK, 
 and a signature 
, return 1 if  and 
.

For our purposes, the scheme only needs to satisfy a notion of bounded-message security under non-adaptive chosen-message attack. In this relaxed model, the adversary only obtains a bounded number of signatures for messages that are chosen non-adaptively (i.e., all at once and before seeing the public key) by the adversary. This security notion is sufficient for signing the N database entries. Note that the queries are non-adaptive but the adversary can adaptively choose its forgery message.

Theorem 1

The scheme is bounded message secure under non-adaptive chosen-message attacks if the  assumption holds. (The proof is in Appendix C.1.)

4. A fully simulatable adaptive OT protocol
Our basic 
 protocol builds on the “assisted decryption” technique [14]. The database's holder encrypts all entries using a multi-bit variant [51] of Regev's cryptosystem [53] and proves the well-formedness of its public key and all ciphertexts. In addition, all ciphertexts are signed using a signature scheme. At each transfer, the receiver statistically re-randomizes a blinded version of the desired ciphertext, where the blinding is done via the additive homomorphism of Regev. Then, the receiver provides a witness indistinguishable (WI) argument that the modified ciphertext (which is submitted for oblivious decryption) is a transformation of one of the original ciphertexts by arguing knowledge of a signature on this hidden ciphertext. In response, the sender obliviously decrypts the modified ciphertext and argues in zero-knowledge that the response is correct.

Adapting the technique of [14] to the lattice setting requires the following building blocks: (i) A signature scheme allowing to sign ciphertexts while remaining compatible with ZK proofs; (ii) A ZK protocol allowing to prove knowledge of a signature on some hidden ciphertext which belongs to a public set and was transformed into a given ciphertext; (iii) A protocol for proving the correct decryption of a ciphertext; (iv) A method of statistically re-randomizing an -encrypted ciphertext in a way that enables oblivious decryption. The first three ingredients can be obtained from [40]. Since component (i) only needs to be secure against random-message attacks as long as the adversary obtains at most N signatures, we use the simplified -based signature scheme of Section 3.2. The statistical re-randomization of Regev ciphertexts is handled via the noise flooding technique [5], which consists in drowning the initial noise with a sub-exponentially larger noise. While recent results [22], [9] provide potentially more efficient alternatives, we chose the flooding technique for simplicity because it does not require the use of FHE (and also because the known multi-bit version [34] of the GSW FHE [27] incurs an ad hoc circular security assumption).

4.1. Description
Our scheme works with security parameter λ, modulus q, lattice dimensions  and . Let 
, and let χ be a 
-bounded distribution. We also define an integer B as a randomization parameter such that 
 and 
 (to ensure decryption correctness). Our basic 
 protocol goes as follows.

:
In this protocol, the sender 
 has a database 
 of N messages, where 
 for each , for some . It interacts with the receiver 
 as follows.

1.
Generate a key pair for the signature scheme of Section 3.2 in order to sign  messages of length 
 each. This key pair consists of 
 and 
, where  and 
, 
. The counter is initialized to .

2.
Choose 
 that will serve as a secret key for an -based encryption scheme. Then, sample 
, 
 and compute(3)
 so that 
 forms a public key for a t-bit variant of Regev's encryption scheme [53].

3.
Sample vectors 
 and 
 to compute(4)

4.
For each , generate a signature 
 on the decomposition 
.

5.
 sends 
 to 
 and interactively proves knowledge of small-norm 
, 
, short vectors 
 and t-bit messages 
, for which (3) and (4) hold. To this end, 
 plays the role of the prover in the ZK argument system described in Section 6.3. If the argument of knowledge does not verify or if there exists  such that 
 is an invalid signature on the message 
 w.r.t. 
, then 
 aborts.

6.
Finally, 
 defines 
, which it keeps to itself.

:
At the i-th transfer, the receiver 
 has state 
 and an index 
. It interacts as follows with the sender 
 that has state 
 in order to obtain 
 from DB.

1.
 samples vectors 
, 
 and a random 
 to compute(5)
 which is a re-randomization of 
. The ciphertext 
 is sent to 
. In addition, 
 provides an interactive WI argument that 
 is indeed a transformation of 
 for some 
, and 
 knows a signature on 
. To this end, 
 runs the prover in the ZK argument system in Section 6.5.

2.
If the argument of step 1 verifies, 
 uses S to decrypt 
 and obtain 
, which is sent back to 
. In addition, 
 provides a zero-knowledge argument of knowledge of vector 
 of norm 
 and small-norm matrices 
, 
 satisfying (modulo q)(6)
 To this end, 
 runs the prover in the ZK argument system in Section 6.4.

3.
If the ZK argument produced by 
 does not properly verify at step 2, 
 halts and outputs ⊥. Otherwise, 
 recalls the random string 
 that was chosen at step 1 and computes 
. The transfer ends with 
 and 
 outputting 
 and 
, respectively.

In the initialization phase, the sender has to repeat step 5 with each receiver to prove that 
 are well-formed. Using the Fiat-Shamir heuristic [24], we can decrease this initialization cost from  to  (regardless of the number of users U) by making the proof non-interactive. This modification also reduces each transfer to 5 communication rounds since, even in the transfer phase, the sender's ZK arguments can be non-interactive and the receiver's arguments only need to be WI, which is preserved when the basic ZK protocol (which has a ternary challenge space) is repeated  times in parallel. To keep the security proof simple, we derive the matrix 
 from a second random oracle. Knowing a short basis of 
, the simulator can extract the columns of S from the public key 
. Details are given in Appendix D.

4.2. Security
The security of the above 
 protocol against static corruptions is stated by the following theorems.

Theorem 2

The 
 protocol provides receiver security under the  assumption. (The proof is available in Appendix E.1.)

Theorem 3

The 
 protocol provides sender security under the  and  assumptions. (The proof is available in Appendix E.2.)

5. OT with access control for branching programs
In this section, we extend our protocol of Section 4 into a protocol where database entries can be protected by access control policies consisting of branching programs. In a nutshell, the construction goes as follows.

When the database is set up, the sender signs (a binary representation of) each database entry 
 together with a hash value 
 of the corresponding branching program. For each possessed attribute 
, the user  obtains a credential 
 from the issuer.

If  has a credential 
 for an attribute x satisfying the ρ-th branching program,  can re-randomize 
 into 
, which is given to the sender, while proving that: (i) He knows a signature  on some message 
 such that 
 is a re-randomization of 
; (ii) The corresponding 
 is the hash value of (the binary representation of) a branching program 
 that accepts an attribute 
 for which he has a valid credential 
 (i.e., 
).

While statement (i) can be proved as in Section 4, handling (ii) requires a method of proving the possession of a (committed) branching program  and a (committed) input 
 such that  while demonstrating possession of a credential for x.

Recall that a branching program  of length L, input space 
 and width 5 is specified by L tuples of the form 
 where

-
 is a function that associates the θ-th tuple with the coordinate 
 of the input 
.

-
 are permutations that determine the θ-th step of the evaluation.

On input 
,  computes its output as follows. For each bit , let 
 denote the bit . Let 
 denote the state of computation at step θ. The initial state is 
 and, for , the state 
 is computed as
 Finally, the output of evaluation is  if 
, otherwise .
We now let 
 and note that each integer in  can be determined by 
 bits. In particular, for each , let 
 be the bits representing . Then, we consider the following representation of :(7)
 where 
.

5.1. The OT-AC protocol
We assume public parameters  consisting of a modulus q, integers n, m such that , a public matrix 
, the maximal length  of branching programs and their desired input length .

:
Given public parameters 
, this algorithm generates a key pair 
 for the signature scheme in Section 3.1 in order to sign single-block messages (i.e., 
) of length 
. Letting 
, this key pair contains 
 and

:
On common input 
, the issuer  and the user  interact in the following way:

1.
If 
,  creates a pseudonym 
, for a randomly chosen 
, which is sent to . It sets 
. Otherwise,  parses its state 
 as 
.

2.
The issuer  defines the message 
. Then, it runs the signing algorithm of Section 3.1 to obtain and return 
, which binds 's pseudonym 
 to the attribute string 
.

3.
 checks that 
 satisfies (2) and that 
. If so,  sets 
, 
 and updates its state 
. If 
 does not properly verify,  aborts the interaction and leaves 
 unchanged.

:
The sender  has 
 which is a database of N pairs made of a message 
 and a policy realized by a length-L branching program 
.

1.
Choose a random matrix 
 which will be used to hash the description of branching programs.

2.
Generate a key pair for the signature scheme of Section 3.2 in order to sign  messages of length 
 each. This key pair consists of 
 and 
, where  and 
, 
 with , 
. The counter is initialized to .

3.
Sample 
 which will serve as a secret key for an -based encryption scheme. Then, sample 
, 
 to compute(8)
 so that  forms a public key for a t-bit variant of Regev's system.

4.
Sample vectors 
 and 
 to compute(9)

5.
For each  to N, 
 is bound to 
 as follows.

a.
Let 
 be the binary representation of the branching program. Compute its digest 
.

b.
Using 
, generate a signature 
 on the message 
 obtained by decomposing 
.

6.
The database's public key is defined as 
 while the encrypted database is 
. The sender  outputs 
 and keeps 
.

:
Given an index , a record 
 and a policy 
, the user  parses 
 as 
. If 
 does not contain any 
 s.t. 
 and 
 contains the corresponding 
,  outputs ⊥. Otherwise, he selects such a pair 
 and interacts with :

1.
If 
,  interacts with  for the first time and requires  to prove knowledge of small-norm 
, 
, 
 and t-bit messages 
 satisfying (8)-(9). To do this,  uses the ZK argument in Section 6.3. If there exists  such that 
 is an invalid signature on 
 or if the ZK argument does not verify,  aborts. Otherwise,  updates 
 and sets 
.

2.
 re-randomizes the pair 
 contained in 
. It samples vectors 
, 
 and 
 to compute(10)
 which is sent to DB as a re-randomization of 
. Then,  provides an interactive WI argument that 
 is a re-randomization of some 
 associated with a policy 
 for which  has a credential 
 for some 
 such that 
. In addition,  demonstrates possession of: (i) a preimage 
 of 
; (ii) a credential 
 for the corresponding 
 and the private key 
 for the pseudonym 
 to which x is bound; (iii) the coins leading to the randomization of some 
. Then entire step is conducted by arguing knowledge of
  satisfying the relations (modulo q)(11)
 
 
 
 
 
 
  and such that 
 encodes 
 such that 
. This is done by running the argument system described in Section 6.6.

3.
If the ZK argument of step 2 verifies,  decrypts 
 to obtain 
, which is returned to . Then,  argues knowledge of 
 of norm 
 and small-norm 
, 
 satisfying (modulo q)
 To this end,  uses the ZK argument system of Section 6.4.

4.
If the ZK argument produced by  does not verify,  outputs ⊥. Otherwise,  recalls the string 
 and outputs 
.

Like our construction of Section 4, the above protocol requires the  to repeat a ZK proof of communication complexity  with each user  during the initialization phase. By applying the Fiat-Shamir heuristic as in Appendix D, the cost of the initialization phase can be made independent of the number of users: the sender can publicize 
 along with a universally verifiable non-interactive proof of well-formedness.

The security of the above protocol against static corruptions is proved in Appendix F, under the  and  assumptions.

6. Our zero-knowledge arguments of knowledge
This section provides all the zero-knowledge arguments of knowledge (ZKAoK) used as building blocks in our two adaptive OT schemes. Our argument systems operate in the framework of Stern's protocol [55], which was originally introduced in the context of code-based cryptography but has been developed [44], [45], [42], [40], [41] into a useful tool for lattice-based cryptography.

In Section 6.1, we first recall Stern's protocol in a generalized, abstract manner suggested in [40]. Then, using various transformations, we will demonstrate that all the required ZKAoKs can be obtained from this abstract protocol. Our basic strategy and techniques are summarized in Section 6.2, while the details of the protocols are given in the next subsections. In particular, our treatment of hidden branching programs in Section 6.6 is rather sophisticated as it requires to handle a number of secret objects nested together via branching programs, commitments, encryptions, signatures and Merkle trees. This protocol introduces new techniques and insights of which we provide the intuition hereafter.

6.1. Abstracting Stern's protocol
Let K, D, q be positive integers with  and , and let  be a subset of 
. Suppose that  is a finite set such that every  can be associated with a permutation 
 of D elements satisfying the following conditions:(12) 
  We aim to construct a statistical ZKAoK for the following abstract relation:

Note that, Stern's original protocol corresponds to the special case when 
, where  denotes the Hamming weight and  is a given integer, 
 is the set of all permutations of D elements and 
.

The conditions in (12) play a crucial role in proving in ZK that . To this end, the prover samples a random  and lets the verifier check that 
 without learning any additional information about w due to the randomness of ϕ. Furthermore, to prove in a zero-knowledge manner that the linear equation is satisfied, the prover samples a masking vector 
, and convinces the verifier instead that 
.

Theorem 4

The protocol in Fig. 1 is a statistical ZKAoK with perfect completeness, soundness error 2/3, and communication cost . Namely:

•
There exists a polynomial-time simulator that, on input , outputs an accepted transcript statistically close to that produced by the real prover.

•
There exists a polynomial-time knowledge extractor that, on input a commitment CMT and 3 valid responses 
 to all 3 possible values of the challenge Ch, outputs 
 such that 
.

The proof of the theorem relies on standard simulation and extraction techniques for Stern-like protocols [37], [44], [40]. It is given in Appendix G.
6.2. Our strategy and basic techniques, in a nutshell
Before going into the details of our protocols, we first summarize our governing strategy and the techniques that will be used in the next subsections.

In each protocol, we prove knowledge of (possibly one-dimensional) integer vectors 
 that have various constraints (e.g., smallness, special arrangements of coordinates, or correlation with one another) and satisfy a system(13) 
 
 where 
, 
 are public matrices (which are possibly zero or identity matrices) and vectors. Our strategy consists in transforming this entire system into one equivalent equation , where matrix M and vector v are public, while the constraints of the secret vector w capture those of witnesses 
 and they are provable in zero-knowledge via random permutations. For this purpose, the Stern-like protocol from Section 6.1 comes in handy.

A typical transformation step is of the form 
, where there exists public matrix 
 such that 
. This subsumes the decomposition and extension mechanisms which first appeared in [44].

•
Decomposition: Used when 
 has infinity norm bound larger than 1 and we want to work more conveniently with 
 whose norm bound is exactly 1. In this case, 
 is a decomposition matrix (see Section 2.5).

•
Extension: Used when we insert “dummy” coordinates to 
 to obtain 
 whose coordinates are somewhat balanced. In this case, 
 is a -matrix with zero-columns corresponding to positions of insertions.

Such a step transforms the term 
 into 
 
, where 
 
 is a public matrix. Also, using the commutativity property of addition, we often group together secret vectors having the same constraints.
After a number of transformations, we will reach a system equivalent to (13):(14)
  where integers  and matrices 
 are public. Defining
 
 
 
 we obtain the unified equation . At this stage, we will use a properly defined composition of random permutations to prove the constraints of w. We remark that the crucial aspect of the above process is in fact the manipulation of witness vectors, while the transformations of public matrices/vectors just follow accordingly. To ease the presentation of the next subsections, we will thus only focus on the secret vectors.

In the process, we will employ various extending and permuting techniques which require introducing some notations. The most frequently used ones are given in Table 1. Some of these techniques appeared (in slightly different forms) in previous works [44], [45], [42], [40], [41]. The last three parts of the table summarize newly-introduced techniques that will enable the treatment of secret-and-correlated objects involved in the evaluation of hidden branching programs.


Table 1. Basic notations and extending/permuting techniques used in our protocols.

Notation	Meaning/Property/Usage/Technique
•
The set of vectors in 
 with Hamming weight .

•
.

•
To prove 
: Extend x to 
, then permute 
.

•
The set of vectors in 
 that have exactly  coordinates equal to j, for every .

•
.

•
To prove 
: Extend x to 
, then permute 
.

 and T2[⋅](⋅)	
•
For 
.

•
For  and 
:  
.

•
Property: 
.

•
To prove  simultaneously satisfies many relations: Extend it to 
, then permute and use the same b at all appearances.

 and 
•
For  and 
:  
.

•
For 
,  
 
:  
 .

•
Property: 
.

[⋅]5	For : [k]5 denotes the integer t ∈ {0,1,2,3,4}, s.t. t = k mod 5.
 and T5[⋅](⋅)	
•
For 
.

•
For  and 
:

•
Property: 
.

•
To prove  simultaneously satisfies many relations: Extend it to 
, then permute and use the same c at all appearances.

•
: 
 is the 5-dim unit vector 
 with 
.

•
For 
: 
.

→ Allow proving 
 for some  satisfying other relations.

 and T5×2[⋅,⋅](⋅)	
•
For  and :

•
For  and 
:

•
Property: 
.

→ Allow proving  for some  satisfying other relations: Extend z to 
, then permute and use the same  at all appearances of , respectively.

In particular, the intriguing technique of the last row will be used for proving knowledge of secret integer z of the form  for some  satisfying other relations. The following example illustrates how it works.

Example 1

Let  and . Then we have:
 Note that: 
.

6.3. Protocol 1
Let 
 be the parameters defined in Section 4. The protocol allows the prover to prove knowledge of LWE secrets and the well-formedness of ciphertexts. It is summarized as follows.

Common input:
, 
; 
.

Prover's goal
is to prove knowledge of 
, 
, 
 such that the following equations hold:

(15) 
  For each , let 
 be the j-th column of matrices , respectively. For each , let 
 denote the j-th coordinate of vectors 
, respectively. Then, observe that (15) can be rewritten as:(16) 
  Then, we form the following vectors:
Next, we run 
 to decompose 
 into 
 and then extend 
 to 
⁎
. We also extend 
 into 
⁎
 and we then form 
⁎
⁎
, where 
.

Observe that relations (16) can be transformed into one equivalent equation of the form , where M and v are built from the common input.

Having performed the above unification, we now define  as the set of all vectors 
, where 
 and 
. Clearly, our vector w belongs to the set .

Next, we specify the set  and permutations of D elements 
, for which the conditions in (12) hold.

•
.

•
For 
 and for 
, where 
 and 
, we define 
.

By inspection, it can be seen that the desired properties in (12) are satisfied. As a result, we can obtain the required ZKAoK by running the protocol from Section 6.1 with common input  and prover's input w. The protocol has communication cost 
 bits.
While this protocol has linear complexity in N, it is only used in the initialization phase, where  bits inevitably have to be transmitted anyway.

6.4. Protocol 2
Let  be system parameters. The protocol allows the prover to prove knowledge of LWE secrets and the correctness of decryption.

Common input:
, 
; 
, 
.

Prover's goal
is to prove knowledge of 
, 
 and 
 such that the following equations hold:

(17)
 For each , let 
 be the j-th column of matrices , respectively; and let 
 be the j-th entry of vectors 
, respectively. Then, observe that (17) can be re-written as:(18) 
  Next, we form vector 
, then decompose it to 
, and extend 
 to 
⁎
.
At the same time, we decompose vector 
 to 
, and then extend 
 to 
⁎
.

Defining the ternary vector 
⁎
⁎
 of dimension 
, we finally obtain the equation , for public matrix M and public vector v. Using similar arguments as in Section 6.3, we can obtain the desired zero-knowledge argument system. The protocol has communication cost 
 bits.

6.5. Protocol 3
Let 
 be the parameters defined in Section 4. The protocol allows the prover to argue that a given ciphertext is a correct randomization of some hidden ciphertext and that he knows a valid signature on that ciphertext. Let β be the infinity norm bound of these valid signatures.

Common input:
It consists of matrices 
, 
, 
, 
, 
 and vectors 
.

Prover's goal
is to prove knowledge of 
, 
, 
, 
, 
, 
 such that the following equations hold:

(19)
  
 
  
  
 
  For this purpose, we perform the following transformations on the witnesses.
Decompositions. Decompose vectors 
 to vectors 
, 
, 
, respectively.

Extensions/Combinations.

•
Let 
 and extend it into 
⁎
.

•
Let 
 and extend it into the vector 
⁎
.

•
Extend 
 into 
. Then, for each , define 
. (We refer to Table 1 for details about .)

Now, we form vector 
⁎
⁎
, where 
. At this point, we observe that the equations in (19) can be equivalently transformed into , where the matrix M and the vector v are built from the public input.
Having performed the above transformations, we now define  as the set of all vectors 
 for which there exists 
 such that:
 It can be seen that w belongs to this tailored set. Now, let us specify the set  and permutations of D elements 
 satisfying the conditions in (12).

•
.

•
For 
, we define the permutation 
 that transforms vector 
 as follows:

By inspection, it can be seen that the properties in (12) are indeed satisfied. As a result, we can obtain the required argument of knowledge by running the protocol from Section 6.1 with common input  and prover's input w. The protocol has communication cost 
 bits.
6.6. Protocol 4: a treatment of hidden branching programs
We now present the proof system run by the user in the OT-AC system of Section 5. It allows arguing knowledge of an input 
 satisfying a hidden branching program 
 of length for . The prover should additionally demonstrate that: (i) He has a valid credential for x; (ii) The hashed encoding of  is associated with some hidden ciphertext of the database (and he knows a signature guaranteeing this link); (iii) A given ciphertext is a re-randomization of that hidden ciphertext.

Recall that, at each step  of the evaluation of , we have to look up the value 
 in 
 to compute the θ-th state 
 as per(20)

To prove that each step is done correctly, it is necessary to provide evidence that the corresponding search is honestly carried out without revealing 
,  nor 
. To this end, a first idea is to perform a left-to-right search on 
: namely, (20) is expressed in terms of a matrix-vector relation where 
 is encoded as a unit vector of dimension 5; 
 are represented as permutation matrices; and 
 is computed using a matrix 
 containing exactly one 1 per row. While this approach can be handled using proofs for matrix-vector relations using the techniques of [41], the expected complexity is  for each step, so that the total complexity becomes . Fortunately, a better complexity can be achieved.

If we instead perform a dichotomic search on 
, we can reduce the complexity of each step to . To this end, we need to prove a statement “I performed a correct dichotomic search on my secret array x”.

In order to solve this problem, we will employ two existing lattice-based tools (which we recall in Appendix H.1, for the sake of completeness):

(i)
A variant of the SIS-based computationally binding and statistically hiding commitment scheme from [37], which allows committing to one-bit messages;

(ii)
The SIS-based Merkle hash tree proposed in [42].

Let 
 and 
. For each , we let the receiver commit to 
 as 
, with 
, and reveal 
 to the sender. We build a Merkle tree of depth 
 on top of the leaves 
 using the -based hash function 
 of [42]. Our use of Merkle trees is reminiscent of [42] in that the content of the leaves is public. The Merkle tree will actually serve as a “bridge” ensuring that: (i) The same string x is used in all steps while enabling dichotomic searches; (ii) At each step, the prover indeed uses some coordinate of x (without revealing which one), the choice of which is dictated by a path in the tree determined by .

Since 
 are public, both parties can deterministically compute the root 
 of the Merkle tree. For each , we consider the binary representation 
 of , which is part of the encoding of  defined in (7). We then prove knowledge of a bit 
 satisfying the statement “From the root 
 of the tree, the path determined by the bits 
 leads to the leaf associated with the commitment opened to 
.” If the Merkle tree and the commitment scheme are both secure, it should hold that 
. Said otherwise, we can provably perform a “dichotomic search” for 
. Moreover, the techniques from [42] can be adapted to do this in zero-knowledge manner, i.e., without revealing the path nor the reached leaf.

Now, our task can be divided into 3 steps: (i) Proving that the searches on Merkle tree yield 
; (ii) Proving that the branching program evaluates to  if 
 are used in the evaluation; (iii) Proving all the other relations mentioned above, as well as the consistency of 
 and the fact that they open to a certified 
.

Thanks to dichotomic searches, the communication cost drops to 
. These steps can be treated as explained below.

6.6.1. The Merkle tree step
At each step , the prover demonstrates knowledge of a path consisting of 
 nodes 
 determined by 
, as well as their sibling nodes 
. Also, the prover argues knowledge of an opening 
 for the commitment of which 
 is a binary decomposition. As shown in [42] (and recalled in Appendix H.1), it suffices to prove the following relations (mod q):(21)
  where  is defined in Table 1.

Extending.

•
For each 
: Extend 
 to 
, respectively. Then, let 
 and 
.

•
For each , extend the bit 
 into the vector 
.

•
Let 
, then extend it into the vector 
.

Combining. Next, we let 
 and define(22)
 Then, observe that, the above 
 equations can be combined into one:(23)
 where matrix 
 and vector 
 are built from the public input.

6.6.2. The branching program step
The last three parts of Table 1 describe the vector transformations that will be used to handle the secret vectors appearing in the evaluation of . The following equations emulate the evaluation process. In particular, for each , we introduce an extra vector 
 to enable the extraction of the values 
, and 
.(24)
 

Extending.

•
For each , extend 
 to 5-dimensional vector 
.

•
For each , extend 
 to 
.

•
For each , extend 
 to 
.

•
Extend the products 
 and 
 into 10-dimensional vectors 
 and 
, respectively.

•
For each , extend the products 
 and 
 into 10-dimensional vectors 
 and 
.

•
For , extend the products 
 and 
 into 
 and 
, respectively.

Combining. Let 
, and form 
 of the form:(25)
 Then, observe that the vector 
 of (25) satisfies one equation of the form:(26)
 where matrix 
 and vector 
 are obtained from the common input. Note that we work with integers in , which are much smaller than q. As a result,(27)
 Conversely, if we can prove that (27) holds for a well-formed vector 
, then that vector should also satisfy (26).

6.6.3. The third step
In the third layer, we have to prove knowledge of:(28)
 
 
  which satisfy the equations of (11) for 
 and, , the bit 
 is committed in 
 with randomness 
:
 
 
 
 

Decomposing. We use 
 to decompose 
 into 
, respectively. Similarly, we decompose vector 
 into vector 
.

Extending and Combining. Next, we perform the following steps:

•
For each 
, extend 
 to 
.

•
For each , extend 
 to 
.

•
Let 
 
, where 
. Then extend 
 
 to 
.

•
Define the vector 
 
 of dimension 
 and extend it into 
.

•
Extend 
 to 
. Then for , form vector 
.

•
Extend 
 to 
. Then for 
, form 
.

Given the above transformations, let 
 and construct vector 
 of the form:(29)
 Observe that the given five equations can be combined into one of the forms:(30)
 where matrix 
 and vector 
 can be built from the public input.

6.6.4. Putting pieces altogether
At the final stage of the process, we connect the three aforementioned steps. Indeed, all the equations involved in our process are captured by (23), (27), and (30) - which in turn can be combined into:(31) where 
, for

The components of w all have constraints listed in Table 1. By construction, these blocks either belong to the special sets 
, 
 or they have the special forms , 
, 
, 
, which are invariant under the permutations defined in Table 1. As a result, we can specify suitable sets ,  and permutations of D elements 
, for which the conditions of (12) are satisfied. The description of ,  and 
 is detailed in Appendix H.2.

Our desired argument system then works as follows. At the beginning of the interaction, the prover computes commitments 
 and sends them once to the verifier. Both parties construct matrix M and vector v based on the public input as well as 
, while the prover prepares vector w, as described. Finally, they run the protocol of Section 6.1, which has communication cost .