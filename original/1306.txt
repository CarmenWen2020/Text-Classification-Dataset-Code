Abstract
In the degree-constrained graph orientation problem, the input is an unweighted, undirected graph G=(V,E) and nonnegative integers av and bv (with av≤bv) for each v∈V, and the objective is to assign a direction to every edge in E in such a way that for each v∈V, the number of outgoing edges in the resulting directed graph lies in the interval [av,bv]. When such an orientation does not exist, it is desirable to find an orientation that best fits the condition instead. In this paper, we consider the problem of finding an orientation that minimizes the total penalty ∑v∈Vcv, where cv is a penalty incurred whenever a vertex v violates its degree constraints. As penalty functions, convex, concave, and step functions are considered in this paper. We show that the problem with any convex penalty function can be solved in O(|E|1.5min⁡{log⁡(|E|⋅C),|E|0.5log⁡Δlog⁡|E|}) time, where Δ and C are the maximum degree and the largest magnitude of a penalty, respectively. In contrast, we show APX-hardness of the problem with step or concave functions. For trees and graphs with treewidth τ, the problem with any penalty function can be solved exactly in O(|V|log⁡Δ) time and O(τ2Δ2τ+2|V|) time, respectively. Finally, we consider the generalization of the problem to edge-weighted graphs and establish strong bounds on its inapproximability that hold even in the special case of stars. On the positive side, we can extend our algorithms for unweighted version of the problem to obtain pseudo-polynomial-time algorithms for the edge-weighted problem variant when restricted to trees and graphs with bounded treewidth. Also, we design a PTAS and a linear-time algorithm for stars with further restrictions on the degree constraints and edge weights.

Keywords
Graph orientation
Degree constraint
Penalty function
Inapproximability
Tree
Treewidth

1. Introduction
1.1. Notation and problem definition
Let  be an unweighted undirected graph, where V and E denote the sets of vertices and edges, respectively. The vertex set and the edge set of G is also denoted by  and . We allow G to have parallel edges; G is possibly a multi-graph. Throughout the paper, let  and  for the graph. Two vertices u and v are called adjacent to each other if . Let 
 be the set of adjacent vertices of u in G, i.e., 
, and 
 is called degree of u in G. We omit the subscripts G's of 
 and 
 if it is clear from the context; sometimes we use  and  instead of 
 and 
. We denote  by Δ. An orientation Λ of G is a set of an assignment of a direction to each edge , i.e.,  or . We simply use Λ to represent 
 if no confusion arises. We denote the directed graph obtained from G and Λ by . The outdegree of a vertex u in  is , which is denoted by 
.

Assume that 
 and that a sequence of 2n nonnegative integers 
 and 
 satisfying 
 for  is given. A degree-constrained orientation is an orientation Λ of G such that 
 holds for every 
. Obviously, G does not always have a degree-constrained orientation. In such a case, we would like to find an orientation that “best” fits the degree constraint.

For a graph , an orientation Λ of G, and a vertex 
, we define a cost function 
 such that 
 if 
, 
 if 
, and 
 otherwise. Then the violation vector 
 for a graph G and its orientation Λ is defined as 
. For a vertex 
 with outdegree k under some orientation, we sometimes denote its cost by 
, that is, 
 if 
, 
 if 
, 
 otherwise. The purpose of defining 
 is to estimate the cost on a vertex 
 only depending on its outdegree regardless of orientations. For an orientation Λ of G, it holds that 
. A penalty function p is a finite, nonnegative, and nondecreasing function with n variables. By using these, we define the best-fit orientation to the degree constraint by an orientation Λ of G that minimizes the total penalty 
 (of Λ)

Given an input graph  and two nonnegative integers 
 and 
 for each  satisfying 
, the Minimum Penalty Degree-Constrained Orientation problem with a fixed penalty function p (MPDCOp for short) asks for the best-fit orientation of G.

As an example of an instance of MPDCOp, see the undirected graph  in Fig. 1-(a). Let 
 and 
 for any . Figs. 1-(b) and (c) are two directed graphs obtained by orientations Λ and 
, respectively. We first consider the case when p is a summation of a convex function 
 for each vertex, i.e., 
. By the orientation Λ of Fig. 1-(b), the outdegree sequence of the vertices is  in the column-major order from the left to the right. Thus its violation vector 
 is  and so the total penalty 
 is 
. On the other hand, by the orientation 
 in Fig. 1-(c), 
 and 
.

Fig. 1
Download : Download high-res image (36KB)
Download : Download full-size image
Fig. 1. Example of MPDCOp: (a) An undirected graph G = (V,E); (b) an orientation Λ of G with outdegree sequence (1,1,5,0,2,2,0,2) from the left top to the right bottom; (c) an orientation Λ′ of G with outdegree sequence (1,1,3,0,3,3,0,2).

As another example, consider the case that p is a summation of the following concave function 
 instead of 
:
  Then, the total penalty 
 of Λ is 
, and the total penalty 
 of 
 is 
. The “balanced” orientation 
 in Fig. 1-(c) is worse than the “unbalanced” orientation Λ in Fig. 1-(b) for the pair of G and 
. Also, note that the total penalty highly depends on the values of 
 and 
.

In this paper, we assume that all penalty functions are linearly separable, i.e., any penalty function can be written as 
 for some nonnegative nondecreasing one-variable function g with . The function g is called the separated penalty function (of the penalty function p). Namely, the penalty on each vertex v under an orientation Λ is represented by 
. Throughout the paper, we assume that g is a fixed function, and can be evaluated in constant time; for a nonnegative real x, the value of  is obtained in  time. In this setting, we focus on the following types of functions as typical examples of g: convex, concave, and step functions. A function g is convex or a convex function if 
 for any 
, 
, and α satisfying . Similarly, a function g is concave or a concave function if 
 for any 
, 
, and α satisfying . Also, a function g is a step function if it can be written as 
, where , 
's are real numbers, 
's are intervals, and 
 is the indicator function of an interval A such that 
 if , and 
 otherwise. We say that a penalty function p is linearly separable with a convex (concave, or step) function (g) if p is linearly separable and the separated penalty function of p is a convex (concave, or step) function (g). If the penalty function p of MPDCOp is linearly separable with a (convex, concave, or step) function (g), we simply indicate it by writing “MPDCOp with a (convex, concave, or step) function (g).”

An algorithm for MPDCOp is an α-approximation algorithm, or its approximation ratio is α, if it holds that 
⁎
 for any input graph G, where Λ and 
⁎
 are orientations obtained by the algorithm and an optimal algorithm, respectively. Then, an algorithm for MPDCOp is a polynomial-time approximation scheme (PTAS) if it takes a parameter ϵ and a graph G as input, then outputs an orientation Λ such that 
⁎
 with running time which is polynomial in n and m for a fixed ϵ. Also, an algorithm for MPDCOp is a fixed parameter tractable (FPT) algorithm parameterized by a parameter if it runs in  time, where  is a function only depending on the size k of the parameter and  is polynomial in n and m.

1.2. Summary of results
In this paper, we study the relationship between the computational complexity of MPDCOp and linearly separable penalty functions. Clearly, the nature of MPDCOp depends on the penalty function p.

The results in this paper are summarized as follows:

•
MPDCOp with a convex function g can be solved in 
 time (Theorem 2 in Section 2). Hence, if g is a polynomial function, such as 
 with a positive constant k, the running time is 
.

•
MPDCOp with a step (or concave) function has no polynomial-time approximation algorithm whose approximation ratio is better than  unless P=NP; it is APX-hard (Theorem 1 in Section 1.3).

•
For trees, MPDCOp with any function g can be solved in  time (Theorem 3 in Section 3.1.1). Also, for some restricted functions, MPDCOp on trees can be solved in  time (Theorem 4 in Section 3.1.2). This running time is attainable for any function g as long as basic arithmetic operations can be done in  time; g does not have to be convex or concave. In addition, for graphs with treewidth τ, MPDCOp with any function can be solved in 
 time (Theorem 9 in Section 3.2). This algorithm is an FPT algorithm parameterized by treewidth plus the maximum degree. On the other hand, we show W[1]-hardness of MPDCOp with a step (or concave) function parameterized by treewidth only (Theorem 10 in Section 3.3).

•
For the edge-weighted version of MPDCOp with a convex, concave, or step function, there is no polynomial-time -approximation algorithm, where  is any polynomial-time computable function (Corollary 14 in Section 4.1 and Corollary 18) in Section 4.3. The inapproximability results are shown based on the strong NP-hardness of the problem for edge-weighted planar bipartite graphs and the weak NP-harness for edge-weighted stars (Theorem 13 in Section 4.1 and Theorem 17 in Section 4.3).

•
For the edge-weighted version of MPDCOp, we extend the polynomial-time algorithm in Sections 3.1 and the FPT algorithm in 3.2 (Theorem 15, Theorem 16 in Section 4.2). In addition, we design polynomial-time (approximation) algorithms for edge-weighted stars (Theorem 21, Theorem 22 in Section 4.3).

1.3. Related work
Graph orientation itself is a fundamental problem in the area of graph theory and combinatorial optimization. In general, graph orientation is a problem of finding an orientation to a given undirected graph to meet some given requirement. Various kinds of requirements such as connectivity, reachability, acyclicity, etc. have been considered [1], [2], [3], and in particular, there is a large literature devoted to graph orientation with degree constraints; see, e.g., Sections 61.1 in [4], 7.4.3 in [5], and 2.3 in [6].

Many fundamental graph problems such as graph routing, matching, and covering can be formalized as degree-constrained graph orientations. One of the earliest related results was published in 1953 by Landau [7], who proved a necessary and sufficient condition on the sum of the outdegrees of any subset of vertices in a directed complete graph.1 Hakimi [8], Frank and Gyárfás [9], Chrobak and Eppstein [10], and Gabow [11] studied a variant of the degree-constrained orientation problem in which the goal is to orient as many edges as possible in an undirected graph, subject to the upper and lower bounds on the outdegree of each vertex (or equivalently, the upper bounds on the indegree and outdegree of each vertex). In [8], Hakimi gave the necessary and sufficient conditions of graphs that can be oriented so that every outdegree is at most a given upper bound. These were generalized by Frank and Gyárfás in [9] to a characterization of graphs that can be oriented so that every outdegree is between given upper and lower bounds.

In [10], Chrobak and Eppstein studied orientations of planar graphs and showed that an orientation with maximum outdegree 3 as well as an acyclic orientation with maximum outdegree 5 can be obtained in linear time for any planar graph. In another line of research, Gabow considered the partial orientation problem in [11], which formulates the degree-constrained orientation problem as an optimization problem. A partial orientation assigns a unique direction to a subset of the edges, leaving the remaining edges unoriented. Then, the goal is to orient as many edges as possible in the input undirected graph without breaking the degree constraints. He proved that the partial orientation problem is MAXSNP-hard and provided an LP-rounding algorithm which achieves approximation ratio 3/4.

In situations where it is impossible to orient the edges of a given graph so that all of the specified degree constraints are satisfied at the same time, one may still need a reasonably good orientation. MPDCOp resolves this issue by interpreting the degree constraints as soft constraints that may be violated, and returning an orientation that minimizes the total penalty charged for the violated constraints. It should be noted that MPDCOp is a natural generalization of several optimization problems to control the outdegrees of an undirected graph. For example, the Minimum Maximum Outdegree Orientation problem (MinMaxO for short) is to find an orientation of an input graph G minimizing 
 (e.g., [12], [13], [14], [15]). MinMaxO can be used in efficient dynamic data structures for graphs that support fast vertex adjacency queries under a series of edge operations [16]. Furthermore, MinMaxO is a special case of the Minimum Makespan problem (e.g., [17]). MinMaxO can be expressed as MPDCOp with a convex function 
 for an , e.g.,  (<m) by setting 
 for every  in the input graph G, which defines the total penalty of an orientation Λ as 
, where 
. As mentioned in the previous section, MPDCOp with a convex function  can be solved in 
 time, i.e., MinMaxO can be solved in 
 time. This result can be compared to the result that MinMaxO on unweighted graphs can be solved in 
 time [13].

Finally, we will discuss a related problem called Min W-Heavy and show how the known results for it immediately imply the APX-hardness of MPDCOp with a step function. For an input undirected graph and a positive number W, the problem Min W-Heavy is to find an orientation such that the number of vertices of outdegree at least W is minimized in the resulted directed graph. Min W-Heavy is APX-hard for any fixed W [18]. By a reduction from Min 1-Heavy, the APX-hardness of MPDCOp with a step function is straightforwardly obtained by letting 
  Note that the above function g is also a concave function. We observe that the minimum total penalty for MPDCOp with the above g is obtained by minimizing the number of vertices of outdegree at least one under an orientation, which is equivalent to solving Min 1-Heavy. Then the APX-hardness of MPDCOp with a step function (or a concave function) follows directly from the APX-hardness of Min 1-Heavy. It is shown that Min-1-Heavy cannot be approximated within a ratio of 1.3606 unless  [18] based on the lower bound 1.3606 of polynomial-time approximation ratio of Minimum Vertex Cover [19]. Recently, this lower bound has been increased to  [20], [21] and hence we have the following theorem.

Theorem 1

For MPDCOp with a step function or a concave function, there is no polynomial-time algorithm whose approximation ratio is better than , unless .

Also note that the problem Min W-Heavy for  can be viewed as MPDCOp with a step function g such that  if  and  otherwise.
1.4. Organization of the paper
The remainder of the paper is organized as follows. In Section 2, we present a polynomial-time algorithm for MPDCOp with convex functions. Section 3 presents a polynomial-time algorithm for trees and an FPT algorithm parameterized by treewidth plus the maximum degree for MPDCOp with general functions. In Section 4, we consider the edge-weighted version of the problem. Section 5 discusses further research on the problems and concludes the paper.

2. Polynomial-time algorithms for convex functions
In this section, we present a simple approach to solve MPDCOp with a convex function g. For simplicity, MPDCO
 represents this variant of the problem. The approach is based on the reduction to the Convex Cost Flow problem (CCF for short). Using a strongly polynomial-time algorithm for CCF, the approach for MPDCO
 runs in 
 time.

In general, a network flow problem is the problem of finding some optimal flow on a given network that satisfies capacity constraints on arcs (directed edges) and supply/demand conditions on vertices, and many types of network flow problems are intensively and extensively studied. See [22]. Among them, CCF is an optimization problem on a network in which each arc is associated with a convex function whose variable is flow through the arc. The cost of flow is the total sum of flow costs on the arcs, and the convex cost flow problem is the problem of finding a flow whose cost is minimum. If the convex functions are just linear functions, the problem is simply called the Minimum Cost Flow problem, which is a well studied problem. It is known that CCF can be solved in 
 time, where N, M and U are the number of vertices, the number of edges, and the largest magnitude of the lower and upper bounds on capacities in the network, respectively [23]. Fortunately, our problem belongs to a relatively smaller class of the flow problems; the capacity of every arc is integral. For this class, faster algorithms by [22] and [24] can be applied, which yields the next theorem.

Theorem 2

MPDCO
 can be solved in 
 time.

Proof

From graph , sequence of 2n integers 
 and 
, and convex function g, we construct the following network 
:
 
 where 
. The capacity of an arc  in 
 is defined by 
, and those of the other arcs are 1. The supply of source s and the demand of sink t are set to be m. See Fig. 2 as an example of this construction. In Fig. 2, the dotted arcs represent 
.

Fig. 2
Download : Download high-res image (71KB)
Download : Download full-size image
Fig. 2. Network construction in the proof of Theorem 2: (Left) An undirected graph G; (Right) the network  constructed from G.

For this network, a flow of  is a function 
, where 
 is the set of nonnegative real numbers, which satisfies the following three conditions.

•
 for 
,

•
 for 
, and

•
 and 
.

We define the cost function of an arc 
 as
  where x is the amount of flow on this arc. For any other arc , 
 for any x. Note that the cost functions are all convex under the assumption g is a convex function with . See Fig. 3 for an example of  and 
.

Fig. 3
Download : Download high-res image (25KB)
Download : Download full-size image
Fig. 3. Example of cost(v,t)(x): av = 3, bv = 5, and g(x)=x2.

Here, we can see that if f is an integral flow, it can be regarded as an orientation of G. In fact, in any feasible integral flow of , for any , exactly one of the following cases holds:  and , or  and , which can be interpreted as an orientation  or  of e, respectively. Then,  corresponds to the outdegree of v, which implies that 
 is the penalty on v under the orientation, and hence 
 is the total penalty of the orientation. Therefore, our problem is to find an integral flow that minimizes 
, which is CCF with integral constraints.

Since it is known that CCF with integral capacities has an integral optimal flow [24], the integral constraints can be removed. Then, we can utilize algorithms in [24] and [22]: Let N and M be the number of vertices and the number of edges in the network, respectively. Also, U and C respectively denote the largest magnitude of the lower and upper bounds on capacities of an arc and the largest magnitude of a cost on an arc in the network. The running time of the first algorithm in [24] is 
 time, where 
 is the total capacity of edges. In our reduction, , , , 
, and C is the largest penalty on a vertex, i.e.,  since  and g is convex. Hence this algorithm runs in 
 time. The running time of the second algorithm in [22] is  corresponding to 
 for our setting, which is smaller than the first one when  is very large, e.g., 
. Consequently, we can solve MPDCO
 in 
 time. □

According to this theorem, the problem can be solved in 
 time for natural polynomial penalty functions, such as 
 with a constant k, since 
 for this function g.

Remark 1

This reduction is also available for hypergraph orientation. A hypergraph  is an extension of ordinary graphs, in which each hyperedge  can have more than two vertices. An orientation Λ of a hypergraph is an assignment of a hyperedge e to a vertex in e, which is a generalization of graph orientation [6]. The reduction in the proof of Theorem 2 also works for hypergraphs, and achieves essentially the same time complexity, i.e., 
, where 
.

3. General penalty setting for graphs with bounded treewidth
As seen in Sec. 1.3, MPDCOp with a function g is APX-hard for general graphs if g is a step function or a concave function, although if g is a convex function, the problem can be solved in polynomial time as in Section 2. In this section, we restrict our attention to graphs with bounded treewidth. In Section 3.1, we first propose an -time algorithm that solves MPDCOp with any functions on trees for general functions (Section 3.1.1), and then propose an -time algorithm for restricted functions (Section 3.1.2). Then, in Section 3.2, we design an FPT algorithm parameterized by treewidth plus the maximum degree, which also solves MPDCOp with any functions. Finally, in Section 3.3, we show that MPDCOp parameterized by treewidth is W[1]-hard for a step (or concave) function, i.e., it seems difficult to design any FPT algorithm parameterized by treewidth only.

3.1. Polynomial-time algorithm for trees
3.1.1. -time algorithm
Our algorithm is based on dynamic programming. To explain the idea, we first introduce some notation. We denote the optimal value of MPDCOp of a graph G by  in the following. For a tree T rooted at a vertex r, we consider a tree  in which a vertex s is attached with r, that is,  with rooted at s. In the context of MPDCOp, s is a virtual vertex for which no penalty is charged in any orientation (or, we assume 
 and 
).

In this setting, we consider two “optimal” orientations of ; one is an optimal orientation under the constraint that  is oriented as , and the other is the one under the constraint that  is oriented as . We denote the values of such orientations by 
 and 
, respectively. That is, these can be represented by
  
 
 
 
 where  is the set of orientations of T. Note that 
. Clearly, 
.

Now we show a “principle of optimality” equation. Let
 and 
 be the subtree of T rooted at a vertex s. Then, we have
  
 
  
 
 where 
  
 
 
 Here  is the minimum total penalty among all orientations of T, ignoring the cost on r under the constraint that 
.

The values 
 and 
 depend only on k (they do not depend how T is oriented). Hence, 
 and 
 are transformed to
 
 
 
 

Also, the condition  is implied by the definition of , in which the two conditions 
 and 
 are satisfied, edges 's for 
 are oriented towards v, and all other edges incident to r are oriented towards r. Therefore, 
 is transformed to just  without “
.” Hence 
 and 
 are simplified to(1)
 
(2)
 

In addition,  can be rewritten as(3) 
 
  
 
 where 
. Namely, 
 and 
 can be essentially computed by 
-times evaluation of(4)
  
 
 Without loss of generality, let 
, , and 
 for , where 
 for simplicity. By sorting 
's, we can obtain a list 
 such that 
 and 
 for . Then, it holds that(5)
 

Based on these ideas, we can compute 
 and 
 of T rooted at r from the values of 
 and 
 for 
 as follows: Let 
 which is the first term of the right hand side of (3). The same value Q is used to compute  for every k. Thus, we compute Q in 
 time only once. Then, we compute 
 for each 
 in 
 time, and construct a list L of 
's, whose length is 
. Spending 
 time, L is sorted, say, by the merge sort. After that, based on the value 
 and the sorted list L, we obtain 
 and 
 for each 
 by the following procedure.

1.
Compute Q and construct the sorted list L. This step takes 
 time as described above.

2.
Let  and 
 which corresponds to 
. This step takes constant time.

3.
If , add the kth value in L to 
, which obtains 
 based on (5). This step takes constant time.

4.
Compute 
 in constant time by the equation (3), based on Q and 
.

5.
Compute 
 and 
.

6.
If 
, then let  and go back to Step 3. Otherwise, i.e., if 
, then halt. This step also takes constant time.

In the above, each of Steps 2 through 6 spends constant time only for each 
. Hence, in total, we need 
 time to obtain the values 
 and 
 for every k. After that, we need to take the minimum from those 
 values in (1) and (2), which takes 
 time.
In summary, 
 and 
 can be computed in 
 time, provided 
 and 
 for every 
. Thus, for an input tree G, 
 and 
 are obtained by the bottom up manner and the total running time is(6) 
 

Finally we have the following theorem.

Theorem 3

For any linearly separable penalty function, MPDCOp can be solved in  time when the input graph is a tree.

Remark 2

The above -time algorithm works for any rational-valued penalty function as long as basic arithmetic operations can be done in  time; it is not necessary for g to be monotone or to satisfy .

3.1.2. -time algorithm for restricted functions
In this section, we show that the running time of the algorithm in the previous section can be reduced if the separated penalty function has some special property. An important observation is that we do not need to check every 
 in (1) and (2) for such functions. We continue to use the symbols used in the previous section.

Consider a step function g such that  and  for  with some positive constant c. The shape of this function g is drawn by only one segment  with a point . Namely, it can be written as 
 such that 
, 
, 
, and 
, where 
 is the indicator function of an interval A such that 
 if  and 
 otherwise. Note that the domain of the separated penalty functions is . In general, a step function can be written as 
 for some 
's and 
's. As for convex and concave functions, some of them are piecewise linear functions. Namely, a convex or a concave function can be written as 
, where 
 is a linear function with constants 
 and 
, defined on an interval 
. In this section, we consider functions such that the number k of intervals is a constant. We call such function a function with constant intervals.

Let us consider the case that separated penalty function is a step function g such that  and  for  with some positive constant c. Let L and R be the largest indices such that 
 and 
, respectively, i.e., 
 are all 0. Thus, it holds that 
. Moreover, 
 is decreasing when  and increasing when . If 
, we let . In below, we show that the equations (1) and (2) in the previous section can be simplified for such a function g, which leads to the linear-time algorithm.

We consider two cases (Case 1) , and (Case 2) , where  represents a closed interval between x and y. Note that a, b, L, and R are all integers between 0 and Δ.

Case 1
:

See Fig. 4-(Left) for an example. Let κ be the smallest integer in . Then, since 
 implying that 
 and 
 is the minimum, it holds that
 

Fig. 4
Download : Download high-res image (31KB)
Download : Download full-size image
Fig. 4. Computation of q−(T) and q+(T): (Left) [a,b]∩[L,R]≠∅. According to the definition of κ, we have κ = L in this example. (Right) [a,b]∩[L,R]=∅.

For 
, we combine 
 and  in (2). Even if  takes the minimum, it may happen 
 when . However, in this case,  is the only other possibility which gives the minimum based on the property of 
 mentioned in the above. Therefore we can obtain 
 as follows.
 

Case 2
:

See Fig. 4-(Right) for an example. Since , either of  or  holds. Assume that . In this case, 
 takes the minimum when  or . (k can be either of , when we only consider 
. However we prefer setting  for 
 in the discussion below.) Hence, we observe that
 
 As for 
, 
 becomes 0 if . Thus, setting  may yield 
. This is the reason that we chose  in the above. Hence, we take the minimum among two settings  and :
 
 Similarly, for the case , we can obtain
 
 

We estimate the running time to compute the above equations for 
 and 
. By scanning 
's once, we can know L and R as the numbers of 
's which are negative or zero. There is an algorithm which can finds the k-th smallest number in a given list L in  time [25] where  is the number of elements in the list L. We can utilize this algorithm to find 
 and 
 in 
 time. After we find 
 (or 
), we can pick 
 through 
 (or 
) by scanning 
's again, breaking ties arbitrarily, in 
 time. According to this, for Case 1, we can compute κ in constant time, 
 and 
 in 
 time. Similarly, for Case 2, 
, 
, 
, and 
 are all computed in 
 time. Finally, 
 and 
 are computed in constant time based on these values, where Q is computed only once in advance spending 
 time similarly to the estimation for Theorem 3. In total, we need a constant number of 
-time computations, i.e. 
 and 
 can be computed in 
 time. This implies that the total running time of the algorithm becomes .

In the above, we only considered a step function having only two segments. When the separated penalty function is a function with constant intervals, a similar algorithm works. In order to find the minimum for 
 and 
, we need to check the points corresponding to endpoints of an interval, and its neighbors based on the observation that

•
the sum of a constant (by a step function) and a linear function (by 
) on an interval is also a linear function,

•
the sum of two linear functions (by a convex/concave function and by 
) on an interval is also a linear function,

and hence a minimum value appears at either end of the interval. Then, since the number of intervals is a constant, the total number of candidates is also a constant for each of the above equations. This increases the total running time by a constant number of 
-computations, which is still 
. Therefore, an optimal solution is obtained in 
 time for such functions with constant intervals.
Theorem 4

If the separated penalty function is a function with constant intervals, MPDCOp can be solved in  time when the input graph is a tree.

3.2. FPT algorithm parameterized by treewidth and the maximum degree
In this section, we propose an FPT algorithm parameterized by treewidth plus the maximum degree for any linearly separable penalty functions.

3.2.1. Overview and notation
Intuitively, the treewidth is a measure of the tree-likeness of a graph. A tree decomposition of a graph  is a pair , where T is a tree with node set I and 
, with the following three properties [26], [27].

(i)
.

(ii)
For every , there exists an  satisfying 
.

(iii)
For all 
, if 
 is on the path between 
 and 
 in T, then 
.

The width of a tree decomposition 
 is defined by 
. The treewidth  of G is the minimum width over all tree decompositions of G. A tree decomposition of G with minimum width t can be obtained in 
 time [28]. A tree decomposition 
 is a nice tree decomposition with introduce-edge nodes if it satisfies four more conditions in the following [29], [30], [31].
(iv)
The tree decomposition is rooted at a node  such that 
.

(v)
Every node in I has at most two children.

(vi)
For every edge in E, there is exactly one introduce-edge node (defined in the next condition (vii)) in T.

(vii)
Each node  belongs to one of the following five types:

•
Leaf node: it has no children and 
;

•
Introduce-vertex node: it has exactly one child  with 
 for a vertex ;

•
Forget node: it has exactly one child  with 
 for a vertex ;

•
Introduce-edge node: it has exactly one child  and is labeled with an edge  such that 
 and 
; and

•
Join node: it has exactly two children j and 
 such that 
.

In this paper, we simply say that a tree decomposition is nice if it is a nice tree decomposition with introduce-edge nodes. A tree decomposition of width τ for a graph having n vertices can be transformed to a nice tree decomposition with  nodes and width τ in 
 time [31]. Thus we assume that a tree decomposition is nice and has  nodes in the following. Also, we can assume that if 
 for a node i, then i is either a leaf or the root r, because otherwise the input graph G is disconnected, and the algorithm in this section can be applied to each connected component.
We assume that for an input graph G, a nice tree decomposition  of width τ is given, where the node set of T is I, T is rooted at a node , and 
. For a node i of T, let  denote the subtree of T induced by i and all descendants of i. Also, we define a partition 
 of E according to 
's, which is always possible due to property (vi): 
 is the set of all edges introduced in node i.

Now we design a dynamic programming algorithm (DP for short) that runs from leaves of T to the root r. Since each subtree of the form  corresponds to a subgraph of G, we let  be the subgraph whose vertex set is 
 and edge set is 
. The DP computes the optimal penalty of  from the optimal penalty of subgraph(s) defined by its child(ren).

For simplicity, we assume that  in the following. Consider a subset 
 of  such that 
 and 
. Let 
 be a set of all vectors 
 such that each 
 is a nonnegative integer satisfying 
 for 
 (recall that 
 is the degree of the vertex 
 in G). That is, 
 is a set of 
-dimensional vectors representing sequence of (possible) outdegrees of vertices in 
. Such a vector 
 is called an outdegree vector for i, and 
 represents the k-th component of d. As in the definition of the nice tree decomposition, 
 is allowed to be an empty set, and we define , where “()” represents a zero dimensional vector. Since 
 and each 
 is at most Δ, the size 
 of 
 is 
.

Assume 
 such that 
. For the graph  and an outdegree vector d for i, we define a function  which represents the optimal (minimum) penalty of an orientation of  under the constraint that the sequence of the outdegrees of every vertex 
 in the resulting orientation is 
. Namely,  for a non-leaf node i is defined as(7) 
  where 
. We say that an orientation  follows d. In case i is a leaf node, we define . Thus, 
 is the optimal penalty of MPDCOp for , and then the optimal penalty for G is 
, where  and 
. We show that  can be computed from the information on i's child(ren) according to the type of i as follows. In the following subsections, we consider four cases, each of which corresponds to a type of a node in (vii) (except for leaf nodes) of the definition of the nice tree decomposition.

3.2.2. Introduce-vertex node
Let i be an introduce-vertex node. Without loss of generality, assume that

•
j is the child of i,

•
 such that 
,

•
A vertex 
 is introduced in i for some 
, i.e., 
, and

•
 such that 
, 
 for , and 
 for 
.

If j is a leaf node, i.e., 
 is the only vertex in  having no edges, then we set which takes constant time. For 
, we set which also takes constant time for each h, since we can not orient any edge in  and so the outdegree of 
 must be zero.

Suppose that j is not a leaf node. Since the vertex 
 is introduced as an isolated vertex, an optimal orientation of  can be also used as an optimal orientation for the part  in . Namely, an optimal orientation of  is the same as an optimal orientation of . See Fig. 5. Thus, for outdegree vectors i for i and j for j, if 
 for , 
, and 
 for 
 hold, then we set considering that an optimal orientation for  is also applied to the part  in . For each 
, it takes  time to obtain an outdegree vector j which satisfies the condition if it exists, since 
 and so i is an -dimensional vector. If such an outdegree vector j for j does not exist, then we set meaning that such an orientation following the outdegree vector i does not exist. Thus, it takes  time for the case j is not a leaf node.

Fig. 5
Download : Download high-res image (35KB)
Download : Download full-size image
Fig. 5. Illustrating a node of type introduce-vertex node: (Left) A graph G[j] and an orientation of G[j]; (Right) A graph G[i] in which the vertex ik is introduced, and an orientation of G[i].

Since 
 and it takes  time for each case, the recursive formula for an introduce-vertex node i can be computed in 
 time in total:

Claim 5

For an introduce-vertex node i whose child is j and 
,(8)
  which can be computed in  time. Hence we spend 
 time for each introduce-vertex node i.  □

3.2.3. Forget node
Let i be a forget node. Without loss of generality, assume that

•
j is the child of i,

•
 such that 
, and

•
A vertex 
 is removed from j for some k such that 
, i.e., 
.

Note that j must be a non-leaf node with 
, since i removes a vertex 
 from 
. The set 
 may be empty for the case i is the root node r. If 
, then it must hold that  and j is a node including only one vertex 
. Then the outdegree of the vertex 
 in  can be any value between 0 and 
. Hence we take the minimum among penalties of orientations of  following an outdegree vector (h) for 
 in this case: 
  which takes 
 time with checking whether 
 and  in constant time. If  but , then we set which takes constant time.

Assume that 
. Consider outdegree vectors i for i and j for j, and an optimal orientation of  which follows i. Suppose that 
 for  and 
 for 
 hold. Then if we use an orientation of  following j as an orientation of , it follows i. Under such an orientation of , the outdegree of the vertex 
 in  can be any value between 0 and 
. See Fig. 6. Let 
 be a set of 
-dimensional vector j's such that 
 for , 
 for 
, and 
. We take the minimum among penalties of such orientations following i if 
: 
  Since 
 is at most Δ and i is an -dimensional vector, 
 and 
 can be obtained in  time. Taking the minimum spends  time, as a result, this can be computed in  time. If 
 but 
, we set which takes constant time.

Fig. 6
Download : Download high-res image (37KB)
Download : Download full-size image
Fig. 6. Illustrating a node of type forget node: (Left) A graph G[j] and an orientation of G[j]; (Right) A graph G[i] constructed by removing the vertex jk, and an orientation of G[i].

Since 
 and it takes  time for each case, the recursive formula for a forget node i can be computed in 
 time in total:

Claim 6

For a forget node i whose child is j and 
,(9)
  where 
 is a set of 
-dimensional vector j's such that 
 for , 
 for 
, and 
. The above recursive formula can be computed in  time for each i, and hence the total time required for a forget node i is 
.  □

3.2.4. Introduce-edge node
Let i be an introduce-edge node. Without loss of generality, assume that

•
j is the child of i,

•
, and

•
An edge 
 is introduced in i for some k and 
 such that 
 and 
.

See Fig. 7. The edge 
 is oriented in either way 
 or 
 in an orientation. In the former case, the outdegree of 
 increases by one. Similarly, in the latter case, the outdegree of 
 is increased by one. In both cases, outdegrees of other vertices do not change. Suppose that we construct an orientation 
 of  by adding 
 to an orientation 
 of . Then if 
 and 
 respectively follow outdegree vectors i and j, then it holds that 
 and 
 for . If we add 
 to 
 instead of 
, then it holds that 
 and 
 for 
. An important thing here is that the increment of the outdegree of the vertex 
 (or 
) increases the penalty on 
 (or 
) from 
 to 
 (or from 
 to 
). Penalties on other vertices do not change.

Fig. 7
Download : Download high-res image (42KB)
Download : Download full-size image
Fig. 7. Illustrating a node of type introduce-edge node: (Left) A graph G[j] and an orientation of G[j]; (Right) A graph G[i] constructed by inserting an edge 
, and an orientation of G[i] in which the edge 
 is oriented as 
.

Let 
 be an 
-dimensional vector such that 
 and 
 for . Similarly let 
 be an 
-dimensional vector such that 
 and 
 for 
. Since 
, obtaining 
 and 
 takes  time. Here, 
 and/or 
 may not belong to 
, e.g., if 
, then 
 and hence 
. Thus, by checking whether 
 and 
 are positive in constant time, we can know whether 
 and 
 belong to 
. If 
 but 
, then the edge 
 can be oriented only as 
. Thus, we set(10)
 which takes constant time assuming 
 is given. Similarly, if 
 but 
, then we set(11)
 which again takes constant time assuming 
 is given. In the case that both of 
 and 
 belong to 
, we need to take the minimum of penalties of the two orientations in which the edge 
 is oriented either way 
 or 
. Namely, we set(12)
 which also takes constant time assuming 
 and 
 are given. Note that the above equations (10), (11), and (12) can be computed depending on 
 and 
, since the penalty function p is linearly separable with a function g.

Since 
 and it takes  time for each case, the recursive formula for an introduce-edge node i can be computed in 
 time in total:

Claim 7

For an introduce-edge node i whose child is j and 
,(13)
  where 
 (
, resp.) is an 
-dimensional vector such that 
 and 
 for  (
 and 
 for 
, resp.). The above recursive formula can be computed in  time for each i, and hence the total time required for an introduce-edge node i is 
.  □

3.2.5. Join node
Let i be a join node. Without loss of generality, assume that

•
j and 
 are the children of i and

•
.

Since  and 
 are disjoint, we can construct an orientation 
 of  by combining an orientation 
 of  with an orientation 
 of 
. See Fig. 8. Under the resulting orientation 
 of , it holds that 
. Thus, if 
, 
, and 
 respectively follow outdegree vectors i, j, and 
, then it holds that 
 for 
. At this moment, the penalty on the vertex 
 under 
 is 
, while under 
 and 
, the penalties on 
 are 
 and 
, respectively.

Fig. 8
Download : Download high-res image (42KB)
Download : Download full-size image
Fig. 8. Illustrating a node of type join node: (Left) A graph G[j] and an orientation Λj of G[j]; (Center) A graph G[j′] and an orientation 
 of G[j′]; (Right) A graph G[i] which merges G[j] and G[j′], and an orientation of G[i] constructed from Λj and 
.

Let 
 denote the amount of difference 
, which can be computed in constant time for a given triple i, j, and 
. Since there may exist more than one combination of j and 
 satisfying the above condition, we take the minimum among such pairs of j and 
. Let  be the set of pairs 
 of two 
-dimensional vectors j and 
 such that 
 for 
. If , we set 
 
 
 Since the penalty function p is linearly separable, 
 can be computed in constant time for each triple i, j, and 
. The size  of  is at most 
, since each 
 for 
. Then for each pair of 
, the formula (inside “min”) 
 can be computed in 
 time, where the most time consuming part is to compute 
. Hence for an outdegree vector i, it takes 
 time to set the above recursive formula. As the remainder of the cases, if , then we set which takes constant time.

Since 
 and it takes 
 time for each case, the recursive formula for a join node i can be computed in 
 time in total:

Claim 8

Let i be a join node whose two children are j and 
. Then, for 
,(14) 
  where  is the set of pairs 
 of two 
-dimensional vectors j and 
 such that 
 for 
, and 
. The above recursive formula can be computed in 
 time for each i, and hence the total time required for a join node i is 
.  □

3.2.6. Running time
The optimal penalty can be obtained by computing  in the bottom up manner from leaves to the root r. For each node i, the recursive formula can be computed in 
 time, where the case that i is a join node spends the longest time. Since the number of nodes in a nice tree decomposition of a graph G with treewidth τ is , we have the next theorem.

Theorem 9

For an input graph, suppose that its nice tree decomposition with treewidth τ and  nodes is given. Then, for any linearly separable penalty function, MPDCOp can be solved in 
 time.

3.3. W[1]-hardness with respect to treewidth
The algorithm presented in the previous section is an FPT algorithm with respect to , where τ and Δ are treewidth and the maximum degree. Then, a new question arises: is it possible to design an FPT algorithm parameterized only by τ? As we see in this section, the answer is likely “no”; we show that the next theorem, i.e., MPDCOp is -hard with respect to τ.

Theorem 10

MPDCOp with a step (or concave) function parameterized by treewidth is -hard.

We show this theorem by a reduction from k-Multicolor Clique:

Problem:
k-Multicolor Clique

Input:
A connected undirected graph , where the vertices of  induce an independent set for every i, .

Question:
Is there a clique of size k (k-clique) in G?

The problem k-Multicolor Clique is known to be -hard with respect to the solution (clique) size k [32]. Actually, the proof utilizes the same graph of the reduction from k-Multicolor Clique to Capacitated Vertex Cover shown in [33], though we give the detail of the construction of the graph below for completeness.
From an instance G of k-Multicolor Clique, we construct a new graph H, a cost function 
, and a penalty function p satisfying the followings: (i) G has a clique of size k if and only if H has an orientation Λ whose penalty 
 is at most , (ii) the treewidth of H is 
. As mentioned above, our H is identical to that in Section 3.2 of [33], where it is claimed that the treewidth of H is 
. This leads to the W[1]-hardness of MPDCOp with respect to the treewidth, based on the W[1]-hardness of k-Multicolor Clique with respect to k. Thus we prove only (i) below. We first give the reduction, and then show the equivalence by Lemma 11, Lemma 12.

The graph H
We construct H for , where E is partitioned into 's of 
 for . First we assume , since 2-Multicolor Clique is trivial. Also, for some integers ℓ and 
, we can assume that  for all i and 
 for all i and j, since adding an isolated vertex and/or adding an edge with two vertices which are not incident to any other edges does not change the existence of k-clique in G when .

We give a vertex in  for each i a unique number between 1 and ℓ as an identifier in . In the proof below, a symbol to represent a vertex in  (e.g., u) also represents its unique identification number between 1 and ℓ. We prepare a vertex gadget for each , an edge gadget for each , and incidence gadgets that connect the vertex and edge gadgets according to their incidence relations, and H consists of these three types of gadgets. For two vertices u (left) and 
 (right) in some gadget, we may add an identifier component , which consists of α paths with length 2 and β pendant vertices attached with 
 (see Fig. 9). The vertices between the left and right vertices are called intermediate vertices. Note that the construction of an identifier component is additive. For example, if 
 is a right part of two identifier components  and 
, 
 has 
 pendant vertices in total.

Fig. 9
Download : Download high-res image (31KB)
Download : Download full-size image
Fig. 9. (Left) Identifier component I(α,β) and (Right) its actual structure.

We now define the vertex gadget for . A vertex gadget has three types of components, one representative vertex, original vertices, and connector vertices. The representative vertex of  is 
. The original vertices correspond to the vertices in  of G. For original vertices, we use the same symbols of G. The connector vertices are 
's and 
's for every . The representative vertex 
 is adjacent to all the original vertices. An original vertex u is connected with a connector vertex via an identifier component; for every , u and 
 (resp., 
) are connected by  (resp., ), where u is left and 
 (resp., 
) is right in the identifier component. Fig. 10 shows an example of a vertex gadget.

Fig. 10
Download : Download high-res image (62KB)
Download : Download full-size image
Fig. 10. Vertex gadget for V[i].

We next define the edge gadget for . An edge gadget also has three types of components, one representative vertex, edge vertices, and connector vertices. The representative vertex of  is 
. The edge vertices correspond to the edges in  of G. The connector vertices are four vertices 
, 
, 
, and 
. The representative vertex 
 is adjacent to all the edge vertices. For edge 
 with  and 
 in  of G, the corresponding edge vertex e is connected with connector vertices 
, 
, 
, and 
 via identifier component , , 
, and 
, respectively, where e is left in the identifier components. Fig. 11 shows an example of an edge gadget.

Fig. 11
Download : Download high-res image (56KB)
Download : Download full-size image
Fig. 11. Edge gadget for E[i,j].

We finally define an incidence gadget, which consists of vertices 
's and 
's for all pairs of i and . A vertex 
 is connected with 
 and 
 via two identifier components 's, and similarly, a vertex 
 is connected with 
 and 
 via two identifier components 's. Fig. 12 shows how an incidence gadget is.

Fig. 12
Download : Download high-res image (18KB)
Download : Download full-size image
Fig. 12. Incidence gadget.

Degree constraints
We now specify the degree constraints. First we set the degree constraints for the vertices (except for left and right vertices) in identifier components as follows. Although identifier components are included in vertex, edge, and incidence gadgets, we use the same degree constraints for every intermediate (or pendant) vertex:

•
intermediate vertex v: 

•
pendant vertex v: 

Let us describe the degree constraints for other vertices than these intermediate and pendant vertices. We set the degree constraints of the vertices in the vertex gadget for  as follows:
•
representative vertex 
: 

•
original vertex v: 

•
connector vertex 
 for : 

•
connector vertex 
 for : 

Next we set the degree constraints of the vertices in the edge gadget for  as follows:
•
representative vertex 
: 

•
edge vertex e: 

•
connector vertex 
: 

•
connector vertex 
: 

•
connector vertex 
: 

•
connector vertex 
: 

Lastly we set the degree constraints for the vertices in the incident gadgets for every pair of i and :
•
vertex 
: 

•
vertex 
: 

Penalty function
The remainder of the reduction is to choose a penalty function. We let the penalty function p be the summation of a step function g such that  for  and  for . This function g is a step function and also a concave function. This completes the reduction.

Lemmas
In the following, we show that G has a clique of size k if and only if H has an orientation Λ such that 
 by Lemma 11, Lemma 12. Theorem 10 follows from these two lemmas and the fact that the treewidth of H is 
.

Lemma 11

If G has a clique of size k, then H has an orientation whose penalty is at most .

Proof

Let 
 be a clique of size k in G, where we assume that 
 without loss of generality. We construct an orientation of H whose penalty is at most (more precisely, equal to)  from C. First we orient the edges which are incident to the original vertex 
 in the vertex gadget for  outward from 
 for . After that similarly for edges which are incident to the edge vertex 
 for every pair of 
, we orient them outward from e. By these, the degree constraints of these vertices corresponding to C and its edges in G are violated, and the total penalty on these vertices is . Since the penalty is already  at this moment, we need to orient the other edges so as to satisfy the degree constraints of all the remaining vertices. In below, we describe such an orientation.

First of all, every edge incident to a pendant vertex in identifier components is oriented toward the pendant vertex, since every pendant vertex must have outdegree 0 by its degree constraints. We orient the edges in the vertex gadget for  as follows.

•
For the representative vertex 
, we orient the edges incident to 
 outward from 
, except for the edge 
 (which is already oriented as 
 in the above). The outdegree of 
 becomes  since , and satisfies the degree constraint for 
.

•
For any original vertex 
, we orient all the edges incident to v toward v. (Note that this does not contradict the orientation 
 of the edge 
 already determined in the above.) These original vertices have outdegree 0 which satisfies their degree constraints.

•
For any intermediate vertex v between an original vertex u and 
 (or 
), the edge  is already oriented as  for 
 or  for 
. In order to satisfy the degree constraint of v, i.e., 
, the orientation of the edge 
 (or 
) is uniquely determined.

The above guarantees that the penalties on representative vertex, original vertices, and intermediate vertices in a vertex gadget are 0. On the other hand, the outdegrees of 
's and 
's have not been determined only by the above, although the number of edges already oriented outward from 
 (or 
) is 
 (or 
); the outdegree of those vertices will be determined after we decide orientations for the edges in incidence gadgets.
Similar to the vertex gadgets, we orient the edges in the edge gadget for  as follows.

•
For the representative vertex 
, we orient the edges incident to 
 outward from 
, except for the edge 
 (which is already oriented as 
 in the above). The outdegree of 
 becomes 
 since 
, and satisfies the degree constraint for 
.

•
For any edge vertex 
, we orient all the edges incident to e toward e. (Note that this does not contradict the orientation 
 of the edge 
 already determined in the above.) These edge vertices have outdegree 0 which satisfies their degree constraints.

•
For any intermediate vertex v between an edge vertex e and 
 (
, 
, or 
), the edge  is already oriented as  for 
 or  for 
. In order to satisfy the degree constraint of v, i.e., 
, the orientation of the edge 
 (
, 
, or 
) is uniquely determined.

By the above, the numbers of outgoing edges of 
 (or 
) and 
 (or 
) are 
 and 
, respectively.
Let us look at an incidence gadget between 
 and 
. By the above, 
 already has 
 outgoing edges. Thus, to meet the degree constraint, 
 edges between 
 and 
 in the identifier component are oriented toward 
, while the other 
 edges are oriented toward 
. Similarly, since 
 already has 
 outgoing edges, 
 edges between 
 and 
 are oriented toward 
, while other 
 edges are oriented toward 
. By these orientations of the edges in the incidence gadget, 
 has outdegree 2ℓ, which satisfies the degree constraint for 
.

As for an incidence gadget between 
 and 
, similar arguments to the above indicate that 
 edges and 
 edges between 
 and 
 are oriented toward 
 and toward 
, respectively, and then 
 edges and 
 edges between 
 and 
 are oriented toward 
 and toward 
, respectively. Hence, all of 
, 
, and 
 satisfy their degree constraints. The discussion for incidence gadgets between 
's and 
's or between 
's and 
's are similar. This completes the proof. □

Lemma 12

If H has an orientation whose penalty is at most , G has a clique of size k.

Proof

Let Λ be the orientation of H, whose penalty is at most , that is, at most  vertices violate the degree constraints under Λ. We can assume that all the representative vertices satisfy their degree constraints under Λ by the following reason. If a representative vertex 
 violates the degree constraint under Λ, its outdegree is either ℓ or at most  since 
 and 
. In the former case, even if all the original vertices in  satisfy the degree constraints (i.e., their outdegrees are all 0), we choose one  and flip 
 to 
. Then 
 gets to satisfy the degree constraint instead of u and u violates its degree constraint, which does not increase the total penalty. In the latter case, we suppose that the outdegree of 
 is , where , which implies that at least γ vertices in  violate their degree constraints. We arbitrarily choose  vertices from them and flip the edges between 
 and them. As a result 
 gets to satisfy the degree constraint, and each of those  vertices still violates its degree constraint or also gets to satisfy its degree constraint. Thus we could make the representative vertex 
 satisfy its degree constraint without increasing the number of vertices violating the degree constraints, i.e., without increasing the total penalty. Since a similar argument holds for a representative vertex 
 in each edge gadget , we can assume that every representative vertices in the vertex gadgets and the edge gadgets satisfy their degree constraints under Λ.

For each vertex gadget for , the representative vertex 
 is assumed to satisfy its degree constraint 
 under Λ as mentioned above. Since 
, exactly one edge between 
 and original vertices is oriented outward from 
. Thus at least one original vertex 
 in each vertex gadget for  violates its degree constraint 
, where other original vertices than 
 may also have outdegree at least one. Similarly, at least one edge vertex in each edge gadget violates its degree constraint. Since the number of the vertex and the edge gadgets is , at least  vertices violate their degree constraints under Λ. However, we have assumed that the total penalty of Λ is at most . This implies that exactly one original vertex (resp., edge vertex) in a vertex gadget (resp., an edge gadget) violates the degree constraint and no other vertices in a vertex gadget (resp., an edge gadget) violate the degree constraints. In particular, every edge incident to a pendant vertex v in an identifier component is oriented toward v, since the degree constraint of v is 
. We also assume that such edges are oriented toward pendant vertices in Λ.

Let 
 (resp., 
) be the vertex violating the degree constraints in the vertex gadget for  (resp., the edge gadget for ). Since the vertices 
 (resp., 
) in a vertex gadget (resp. an edge gadget) satisfy the degree constraints, all the edges incident to them are oriented toward them. By the degree constraints of intermediate vertices (they must have outdegree one) and pendant vertices (they must have outdegree zero) in an identifier component, the above orientation for representative vertices, original vertices, and edge vertices determines orientation of edges in identifier components between 
 and 
 (or 
), and also edges in between 
 and 
 (or 
, 
, 
). The numbers of these (already determined) outgoing edges from 
 and 
 are 
 and 
, respectively, where edges incident to pendant vertices are already oriented. Similarly, the number of (already determined) outgoing edges from 
, 
, 
, and 
 are 
, 
, 
, and 
 respectively. In the following, we discuss about the remaining edges, i.e., paths between 
 and 
 via connector vertices and identifier components.

For an identifier component 
 between a left vertex v and a right vertex 
, if we decide to orient γ edges () between v and intermediate vertices in 
 outward from v, it determines orientation of the other unoriented edges in 
 to meet the degree constraints:  edges between v and intermediate vertices in 
 are oriented toward v, and then γ (or ) edges between 
 and intermediate vertices in 
 are oriented toward 
 (or outward from 
), where all edges incident to pendant vertices are already oriented outward from 
 in the above. We say this process γ-propagation from v to 
 in the following. Note that we have seen 0-propagation in the above, say, from an original vertex 
 to 
 in a vertex gadget.

We here focus on a path from 
 to 
 via 
, 
, 
, and identifier components. Let γ be the number of edges oriented from 
 to intermediate vertices in the identifier component 
 between 
 and 
, where 
. Then γ-propagation from 
 to 
 orients 
 (or γ) edges in 
 outward from 
 (or toward 
). Since 
 already has other 
 outgoing edges mentioned above, total number of outgoing edges from 
 so far is 
. In order to meet the degree constraint of 
, 
, γ more edges should be oriented outward from 
. Thus γ-propagation from 
 to 
 occurs, and then it causes another γ-propagation from 
 to 
, which increases the outdegree of 
 by . Together with the already oriented 
 outgoing edges, 
 has outdegree at least 
. Since 
 satisfies the degree constraint, 
 must hold. This implies that 
.

Similarly, we focus on a path from 
 to 
 via 
, 
, 
, and identifier components. Recall that the numbers of the predetermined outgoing edges from 
 and 
 are 
 and 
, respectively. Let 
 be the number of edges oriented from 
 to intermediate vertices in the identifier component between 
 and 
, where 
. By a similar argument to the above, 
 edges are oriented from 
 to intermediate vertices in an identifier component between 
 and 
. Hence 
 has outdegree at least 
. Since 
 satisfies the degree constraint 
, 
 must hold. This implies that 
. Combining this with above 
, we have 
.

Since 
 holds by a similar argument, an edge vertex 
 violating its degree constraint under Λ corresponds to the edge between 
 and 
 in G, both of which violate the degree constraints in . These imply that vertices violating the degree constraints under Λ for H correspond to a clique of size k in G. This completes the proof. □

4. Edge-weighted graphs
In the previous sections, the problem MPDCOp is defined on unweighted graphs. As a generalization, we can define the weighted version of MPDCOp (MPDCO
 for short), in which the input is a weighted graph , where V and E are the set of vertices and edges, respectively, and w is a weight function that assigns a weight (a nonnegative integer) to each edge. In this problem variant, the outdegree of a vertex is defined as the sum of weights of outgoing arcs incident to it in MPDCO
. Let W denote the maximum possible outdegree, i.e., 
.

First, we show an inapproximability result for MPDCO
 for planar bipartite graphs in Section 4.1. Then Section 4.2 extends the algorithms in Sections 3.1 and 3.2 for MPDCO
 on trees and graphs with bounded treewidth. Lastly, in Section 4.3, we restrict our attention to stars, a rather restricted subclass of trees and planar bipartite graphs, and then show some tractability and intractability results.

4.1. Planar bipartite graphs
In Theorem 1, we show that it is strongly NP-hard to approximate the unweighted version MPDCOp within a ratio of  for concave and step functions. In this section, we show much stronger inapproximability of MPDCO
; it is impossible to approximate MPDCO
 within a ratio of any polynomial-time computable function unless , although we can solve the problem in polynomial time for unweighted graphs with convex functions as in Section 2.

First we show the next theorem.

Theorem 13

It is strongly NP-hard to distinguish  and  for MPDCO
 with a convex, concave, or step function on weighted planar bipartite graphs.

Proof

We give a reduction from the decision version of MinMaxO with target value k, i.e., checking whether there is an orientation of G such that the maximum weighted outdegree is at most k. This problem is strongly NP-hard for weighted planar bipartite graphs [13].

Let  be an instance of the decision version of MinMaxO, i.e., G is a weighted planar bipartite graph and k is a nonnegative integer at least 2. We use the graph G itself as a part of the instance of MPDCO
. Then we set 
 and 
 for every vertex , and choose a function g in the penalty function satisfying the condition that  if and only if . Note that many convex, concave, and step functions satisfy this condition for g. This reduction is done in polynomial time.

Let  be the total penalty for G in the problem MPDCO
. It is easy to see that there is an orientation for G in which the maximum outdegree of a vertex is at most k if and only if . Namely, MPDCO
 contains the decision version of MinMaxO as a subproblem. Thus, the strong NP-hardness of MPDCO
 on weighted planar bipartite graphs is implied by the strong NP-hardness of the decision version of MinMaxO on planar bipartite graphs. □

Based on the above theorem, we show the next corollary.

Corollary 14

Suppose that  is any polynomial-time computable function. Then, there is no polynomial-time -approximation algorithm for MPDCO
 on weighted planar bipartite graphs whose penalty function is linearly separable and convex (concave, or step) unless .

Proof

For the purpose of obtaining a contradiction, assume that there exists a polynomial-time -approximation algorithm ALG for MPDCO
. The algorithm ALG finds an orientation of G having total penalty  such that , where  is the minimum total penalty for G. Hence, one can determine whether  or  in polynomial time using ALG based on the observation that  if and only if . This contradicts Theorem 13. The corollary follows. □

4.2. Graphs with bounded treewidth
In the previous section, we showed the strong NP-hardness of MPDCO
 on planar bipartite graphs. A typical subclass of planar bipartite graphs is trees. In Section 3, we designed a polynomial-time algorithm for MPDCOp on unweighted trees. In this section, we first extend it to a pseudo-polynomial-time algorithm for MPDCO
 on weighted trees.

Let us consider the algorithm for trees in Section 3.1. The computation of (4) could be done using a sorting algorithm for the unweighted version MPDCOp. For MPDCO
, we need to find a subset 
 such that 
 and 
 is minimum. Using an algorithm for the KNAPSACK problem [34], we can find such 
 in time 
: Given a sequence of pairs 
 of nonnegative integers for  and a value B, KNAPSACK asks to find 
 such that 
 and 
 is the maximum among all such subsets. The algorithm in [34] runs in  time, and finds a subset 
 satisfying 
 for every 
, which maximizes 
. Thus, replacing 
 with 
 for a large value C such that 
, the algorithm in [34] can obtain a subset 
 such that 
 and 
 is minimum, which takes 
 time. In practice, we do not need to compute once for every k; only spending 
 time for the case , we can construct a table which stores the information on the relation between k and the value 
. Then we can refer entries in the table for each k in constant time.

If 
 and 
 are given, (3) can be computed in constant time. Here, since 
 is common for every k, we can compute it once in advance spending 
 time. Since it takes 
 time to compute 
 and 
 for each , (1) and (2) can be computed in 
 time. In summary, for each k, it takes 
 time, where the first and the second terms in the left hand side are respectively for solving KNAPSACK and computing 
 described in the above. Thus the estimation of the total running time in the equation (6) is modified as 
 
 and we have the following theorem.

Theorem 15

For any linearly separable penalty function, MPDCO
 can be solved in  time when the input graph is a tree.

Next, we consider the FPT algorithm parameterized by treewidth τ and the maximum degree Δ in Section 3.2. Since the outdegree of each vertex is at most W in MPDCO
, the set 
 of outdegree vectors has size at most 
, although this size was 
 for the unweighted version MPDCOp. The time complexity for each case is modified as follows.

•
The node i is a leaf node.

The initial formula  for the unweighted version can be used as it is, and it can be computed in constant time, too.  □

•
The node i is an introduce-vertex node.

The recursive formula (8) can be used as it is. Since 
, the total time increases to 
 from 
.  □

•
The node i is a forget node.

In the recursive formula (9), we need to take the minimum. For the first case in (9), the range of h is 
, however in MPDCO
, it is replaced with . For the second case in (9), the size of 
 increases to  from  since 
, and hence 
 can be obtained in  time. Thus, for each 
, it takes  time, and hence the total time needed increases to 
 from 
.  □

•
The node i is an introduce-edge node.

The crucial difference from before is that when orienting an edge 
, the increase of outdegree is 
 instead of one for the unweighted version MPDCOp. Thus, we define 
 as an 
-dimensional vector such that 
 and 
 for . The vector 
 is defined similarly. Here, by checking 
 (or 
), we can know whether 
 (or 
) belongs to 
. (This differs from checking whether 
 and 
 are positive for the unweighted version of the problem.) Therefore, to handle this case, the recursive formula (13) in Claim 7 is modified as follows.
  The above can still be computed in  time for each 
. Since 
, the total time increases to 
 from 
.  □

•
The node i is a join node.

The recursive formula (14) can be used as it is, however the size of  increases to 
 since the maximum outdegree of a vertex is at most W in MPDCO
. Thus for each 
, the recursive formula (14) can be computed in 
, and hence the total time needed is 
.  □

From the above observations, the algorithm spends 
 time, since the number of nodes in a nice tree decomposition is .
Theorem 16

For an input graph, suppose that its nice tree decomposition with treewidth τ and  nodes is given. Then, for any linearly separable penalty function, MPDCO
 can be solved in 
 time.

4.3. Stars
In the previous sections, we saw that MPDCO
 is intractable for planar bipartite graphs although we could design pseudo-polynomial-time algorithms for graphs with bounded treewidth. A natural question is that whether we can design any polynomial-time algorithm for weighted trees or not. In this section, we investigate stars, which is more restricted class of graphs than trees. First we show that MPDCO
 is weakly NP-hard even for stars with some restrictions on degree constraints, and then propose an algorithm to cope with those instances.

We only consider stars having at least three vertices in this section (since a star of two vertices has only one edge and an optimal orientation can be obtained easily by orienting the edge in either way). For a star G, a vertex incident to only one edge is called a leaf, and the vertex incident to at least two vertices is called the center.

For a weighted graph  and degree constraints on its vertices of an instance of MPDCO
, let  be the set of pairs of a lower bound and an upper bound of degrees for each vertex, i.e., 
. The size  of  represents the number of variations of the degree constraints.  denotes the optimal penalty for G. We define restricted sets  and  of edge-weighted stars based on . The set  contains every edge-weighted star G satisfying the following two conditions.

•
, i.e., 
 for some 
 and 
 (possibly 
).

•
The maximum weight of an edge of G is at most 
.

Similarly, the set  contains every edge-weighted star G satisfying the following two conditions.
•
, i.e.,  for some a and b.

•
The maximum weight of an edge of G is at most b.

Even for these rather restricted instances  and , 
 is weakly NP-hard.

Theorem 17

(I)
It is weakly NP-hard to distinguish  and  for 
 on  with a convex, concave, or step function.

(II)
Suppose that k is a positive number. It is weakly NP-hard to distinguish  and  for 
 on  with a concave or step function.

Proof

We give reductions from the problem Partition, which is weakly NP-hard [35]. Given a set X of non-negative integers 
, where y is the number of the integers, Partition asks whether there is a set 
 satisfying 
. Let 
. Note that we can assume that 
, since if 
 then clearly 
 is not included in the solution 
, and if 
 for some j, then it can be easily found. Construct an instance of MPDCO
, i.e., a star G, a penalty function, and degree constraints, from an instance of Partition as follows. We prepare the center r and its children (leaves) 
. The weight of an edge 
 is set to 
 for .

Let us describe penalty functions and degree constraints for (I) and (II).

(I)
The degree constraint is set to  for r, and  for every 
, where . As the penalty function, we choose a non-decreasing function g such that  and  if , where g can be a convex function, a concave function, or a step function.

(II)
The degree constraint is set to  for every vertex, where . As the penalty function, we choose a non-decreasing function g such that  and  if , where g can be regarded as a concave function and also as a step function.

Clearly, the above reductions can be done in polynomial time. One important property of G is that the penalty of a leaf 
 is always 0 for (I) and  for (II) regardless of the orientation of the edge 
, since 
.
We show that there is a set 
 such that 
 if and only if  for (I) (or  for (II)).

(⇒) Suppose that there is a set 
 such that 
. For each edge 
, orient it as 
 if 
, and 
 otherwise. Under this orientation, r has outdegree B and hence its penalty is 0. As mentioned above, every leaf has penalty 0 for (I) (or  for (II)). Thus the total penalty of this orientation is 0, i.e.,  for (I) (or  for (II)).

(⇐) Assume there is an orientation of G with total penalty 0 for (I) (or k for (II)). Since the total penalty of this orientation is 0 for (I) (or k for (II)), the center r has outdegree B. Let 
 be the set of edges oriented outward from r. Since the outdegree of r is B, it satisfies 
. Thus, based on 
, a set 
 such that 
 can be constructed as 
. □

Theorem 17(I) gives an inapproximability for :

Corollary 18

Let  be any polynomial-time computable function. For any linearly separable penalty function with a non-decreasing function, 
 on  has no polynomial-time -approximation algorithm unless .

Proof

The proof is similar to the one for Corollary 14. If there is a polynomial-time -approximation algorithm ALG for MPDCO
 on , it can determine whether  or  in polynomial time since . Thus, by the reduction in Theorem 17, we can solve Partition using ALG in polynomial time, which contradicts the weak NP-hardness of Partition. □

Compared to the above inapproximability for , checking whether  or  for  can be done in linear time.

Theorem 19

For any linearly separable penalty function, there is a linear-time algorithm which can check whether  or  for 

Proof

Let the common degree constraint be , and the maximum weight of an edge be 
. Since G is a star, it holds that . This implies that there is a vertex having outdegree 0 under any orientation. Hence, if , then we can know that . Assume  in below.

Since every edge is oriented and its weight is contained as a part of outdegree of a vertex, we observe that the maximum outdegree of a vertex is at least 
 under any orientation. By this observation, 
 holds if . Consider a linear-time algorithm in which every edge is oriented toward the center in turn. The maximum outdegree of a vertex under this orientation is 
. Namely, if 
, the total penalty of this orientation is 0, i.e., . Hence, 
 holds if and only if .

By the above discussion, we can check whether  or  by checking whether both of  and 
 hold or not. Note that, in the above, we construct an orientation by an algorithm, however we do not need to construct any orientation if we just want to know whether  or not; we just need to scan the edges in linear time and know the maximum weight of an edge. The theorem follows. □

Remark 3

Also for an edge-weighted tree G with , checking whether  or  can be done in linear time by checking  and 
. Consider a linear-time algorithm in which an arbitrary vertex is chosen as root and every edge is oriented toward the root. Under the obtained orientation, the outdegree of an vertex is at least 0 and at most 
. Then, exactly the same argument as the above proof also shows that there is a vertex of outdegree 0 and another vertex of outdegree at least 
 under any orientation for edge-weighted trees.

By Theorem 19, we can easily know whether  or not for a star in . Hence there may be an approximation algorithm for , despite the inapproximability for . Indeed we propose a polynomial-time approximation scheme (PTAS) for  in below.

For a star, the inward orientation represents the orientation in which every edge is oriented toward the center. We say that an edge is oriented inward if it is oriented toward the center, outward otherwise. Clearly the inward orientation is obtained in linear time. The next lemma relates the penalty of inward orientation with that of an optimal orientation.

Lemma 20

For a star , suppose that  edges are oriented outward in an optimal orientation. Then, for any linearly separable penalty function, , where  is the total penalty of the inward orientation.

Proof

Let  and the penalty function be linearly separable with a function g. The center and leaves of G are denoted by r and 
, respectively. The weight of an edge 
 is denoted by 
, where 
 holds since . Let 
⁎
 and Λ be an optimal orientation and the inward orientation, respectively. Also  and  denote the total penalties of 
⁎
 and Λ, respectively.

Without loss of generality, in the optimal orientation, suppose that edges 
 are oriented outward for some , and the rest of the edges are oriented inward, where no edge is oriented inward when . Let 
. We partition the vertices 
 into two sets S and M depending on edge weights such that 
 and 
. Let P be the sum of the penalties imposed on 
, i.e., 
⁎
 if , and 0 if .

One can see that 
 
 where the second term  is the penalty on the center r, the third term represents the penalties on the vertices in S, and then no penalty is imposed on the vertices in M.

On the other hand, depending on 
, there are three cases for :

(i)
: 
, where 
 is the penalty on the center, and  is the total penalty imposed on 
.

(ii)
: .

(iii)
: 
.

In all these three cases, it holds that(15)
It satisfies that 
 for any 
 since g is nondecreasing (recall that any separated function g is assumed to be nondecreasing in our problem setting described in Section 1.1). Thus, it holds that(16) 
 
 where the inequality comes from the facts that 
 for any 
 and . Since , we observe that
 
 
 
 
 □

Based on the above lemma, we design the following algorithm, which takes  and a nonnegative constant k as input and then outputs an orientation of G.

Step 1:
Construct all orientations in which at most k edges are oriented outward (including the inward orientation). Let  be the set of obtained orientations.

Step 2:
For each orientation , compute its total penalty 
.

Step 3:
Output an orientation with 
.

We show that the above algorithm is a PTAS for MPDCO
 on  with a concave or step function. (Note that the above algorithm is also a PTAS for convex functions, however we will see that the inward orientation is optimal for MPDCO
 on  with convex functions later.)

Theorem 21

For any ϵ satisfying , there is an 
-time -approximation algorithm for 
 on  with a concave or step function.

Proof

If at most k edges are oriented outward in an optimal orientation, then Step 1 finds it. Otherwise, the inward orientation has the penalty at most  from Lemma 20, since the optimal orientation has at least  outward edges. Namely the approximation ratio of the algorithm is .

Let us estimate the running time of the algorithm. Step 1 needs 
 time since there are 
 orientations satisfying the condition, i.e., 
 and each orientation is constructed in  time. Step 2 spends 
 time since  time is needed to compute the total penalty 
 of an orientation . Step 3 spends 
 time to find the minimum among  values of penalties. Thus the total running time is 
.

Setting , the above algorithm is an 
-time -approximation algorithm, where  since . □

In Theorem 17(II), the weak NP-hardness of MPDCO
 on  is shown for a concave function or a step function. Hence the above PTAS is a possibly best algorithm for MPDCO
 on  with a concave function or step function. As for convex functions, a more careful estimation in the proof of Lemma 20 shows that the inward orientation is optimal for . Namely, we can solve the problem MPDCO
 on  with a concave function in linear time.

Theorem 22

The inward orientation is optimal for MPDCO
 on  with a convex function, i.e., there is a linear-time algorithm to solve 
 on  with a convex function.

Proof

We consider what happens in the proof of Lemma 20 when the separated penalty function is restricted to be a convex function. Let g be the separated function of the penalty function. We show that the inward orientation is optimal for MPDCO
 on  with a convex function.

If , then (16) can be replaced with 
 
 since 
 for any 
. In this case  since  from (15), i.e., ; the inward orientation is optimal.

Assume that , i.e., every edge oriented outward in 
⁎
 has weight less than a. Let 
, where 
. Note that 
 if 
 and 0 otherwise. We observe that for any ,
 holds, since 
, 
, and g is convex. Hence, 
 
 
 Since  and hence 
, we have(17) 
 
 If 
, then 
. Thus, based on (17) and (i) in the proof of Lemma 20, it holds that
 
 i.e., the inward orientation is optimal. If 
, then 
. Again based on (17), it holds that 
 
 where the first inequality comes from (15). Hence, the inward orientation is optimal also for the case 
.

For all the cases, the inward orientation is optimal. This shows that there is a linear-time algorithm for MPDCO
 on  with a convex function. □

5. Concluding remarks
In this paper, we studied a type of degree-constrained orientation of undirected graphs. The problem is formulated as an optimization problem that minimizes penalties for violation. We showed inapproximability results of the problem with concave or step functions. Then we designed polynomial-time algorithms for the problem with convex functions and for the case where the input is restricted to trees or graphs with bounded treewidth. Finally, we presented several tractability and intractability results for the edge-weighted variant of the problem.

Designing approximation algorithms for the problem on unweighted general graphs with concave or step functions is a further research topic. Also, it may be interesting to investigate other restricted graph classes, e.g., interval graphs. To further consider the hypergraph setting and the edge-weighted variant of the problem, as seen in Sections 2 and 4, respectively is another topic. Finally, there may be many other possible extensions of the problem to be considered.