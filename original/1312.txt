Abstract
In recent years, several compressed indexes based on variants of the Burrowsâ€“Wheeler transform have been introduced. Some of these are used to index structures far more complex than a single string, as was originally done with the FM-index (Ferragina and Manzini in J. ACM 52(4):552â€“581, https://doi-org.ezproxy.auckland.ac.nz/10.1145/1082036.1082039, 2005). As such, there has been an increasing effort to better understand under which conditions such an indexing scheme is possible. This has led to the introduction of Wheeler graphs (Gagie et al. in Theor Comput Sci 698:67â€“78, https://doi-org.ezproxy.auckland.ac.nz/10.1016/j.tcs.2017.06.016, 2017). Gagie et al. showed that de Bruijn graphs, generalized compressed suffix arrays, and several other BWT related structures can be represented as Wheeler graphs, and that Wheeler graphs can be indexed in a space-efficient way. Hence, being able to recognize whether a given graph is a Wheeler graph, or being able to approximate a given graph by a Wheeler graph, could have numerous applications in indexing. Here we resolve the open question of whether there exists an efficient algorithm for recognizing if a given graph is a Wheeler graph. We show:

The problem of recognizing whether a given graph ğº=(ğ‘‰,ğ¸) is a Wheeler graph is NP-complete for any edge label alphabet of size ğœâ‰¥2, even when G is a DAG. This holds even on a restricted subset of graphs called d-NFAs for ğ‘‘â‰¥5. This is in contrast to recent results demonstrating the problem can be solved in polynomial time for d-NFAs where ğ‘‘â‰¤2. We also show that the recognition problem can be solved in linear time for ğœ=1 on graphs without self-loops;

There exists an 2ğ‘’logğœ+ğ‘‚(ğ‘›+ğ‘’) time exact algorithm where ğ‘›=|ğ‘‰| and ğ‘’=|ğ¸|. This algorithm relies on graph isomorphism being computable in strictly sub-exponential time;

We define an optimization variant of the problem called Wheeler Graph Violation, abbreviated WGV, where the aim is to identify the smallest set of edges that have to be removed from a graph to obtain a Wheeler graph. We show WGV is APX-hard, even when G is a DAG, implying there exists a constant ğ¶>1 for which there is no C-approximation algorithm (unless P = NP). Also, conditioned on the Unique Games Conjecture, for all ğ¶>1, it is NP-hard to find a C-approximation, implying WGV is not in APX;

We define the Wheeler Subgraph problem, abbreviated WS, where the aim is to find the largest subgraph which is a Wheeler Graph (the dual of WGV). In contrast to WGV, we give an ğ‘‚(ğœ)-approximation algorithm for the WS problem, implying it is in APX for ğœ=ğ‘‚(1).

The above findings suggest that most problems under this theme are computationally difficult. However, we identify a class of graphs for which the recognition problem is polynomial-time solvable, raising the question of which properties determine this problemâ€™s difficulty.

Access provided by University of Auckland Library

Introduction
Within the last two decades, there has been the development of Burrowsâ€“Wheeler Transform (BWT) [9] based indices for compressing a diverse collection of data structures. This list includes labeled trees [38], certain classes of graphs [17, 36], and sets of multiple strings [19, 33]. These new techniques have motivated the search for a set of general conditions under which a structure can be indexed by a BWT based index, which led to the recent introduction of Wheeler graphs by Gagie et al. [20] (also see [4]). A Wheeler graph is a directed graph that has edge labels and satisfies two simple properties related to the ordering of its vertices. Although not general enough to encompass all BWT-based structures (e.g., [21]), Gagie et al. demonstrated that Wheeler graphs offer a unified way of modeling several BWT based data structures such as representations of de Bruijn graphs [8, 14], generalized compressed suffix arrays [38], multi-string BWTs [34], XBWTs [17], wavelet matrices [12], and certain types of finite automata [1, 6, 29]. They also showed that there exists an encoding of a Wheeler graph ğº=(ğ‘‰,ğ¸) which requires only 2(ğ‘’+ğ‘›)+ğ‘’logğœ+ğœlogğ‘’+ğ‘œ(ğ‘›+ğ‘’logğœ) bits where ğœ is the size of the edge label alphabet, ğ‘’=|ğ¸|, and ğ‘›=|ğ‘‰|. This encoding allows for the efficient traversal of multiple edges while processing characters in a string, using an algorithm similar to the backward search in the FM-index [18]. Since their introduction, Wheeler graphs have been the subject of significant study. This includes the study of the languages that are accepted by automata that are also Wheeler graphs [3], as well as the extension of a technique for compression known as tunneling to the BWTs of Wheeler graphs [4]. Additionally, Wheeler graphs give us insight into the more general problem of exact pattern matching on arbitrary labeled graphs, the computational complexity of which has been studied in several recent works [13, 16, 22]. It is clear that not all directed edge labeled graphs are Wheeler graphs, but despite being the subject of an increasing amount of research, it remained unknown how to recognize whether a given graph is a Wheeler graph. This made the authors of [20] explicitly pose the question of how to efficiently recognize whether a graph is a Wheeler graph.

The question is of both theoretical and practical value, as it might be the first step before attempting to apply some compression scheme to a given graph. For example, one could use the existence of a Wheeler subgraph to encode a graph. To do so, one maintains an encoding of the subgraph using the framework presented in [20] in addition to an adjacency list of the edges not included in the encoding. Depending on the size of the subgraph, such an encoding might provide large space savings at the cost of a modest time trade-off while traversing the graph. This concept also motivates the portion of the paper where we look at two optimization versions of this problem that seek subgraphs of the given graph which are Wheeler graphs. These problems turn out to be computationally difficult as well. As a positive result, we show that, for a constant sized alphabet, the problem of finding a maximum Wheeler subgraph admits a polynomial-time algorithm that outputs a solution with size within some constant factor of optimal. We also show that the problem of recognizing Wheeler graphs is related to that of identifying the queue number of a graph. This suggests a class of graphs where the problem becomes computationally tractable, a topic investigated in the last section of this work.

Wheeler Graphs
The notation (u, v, a) is used for the directed edge from u to v with label a. We will assume the usual ordering on the edge labels, which come from the alphabet {1,2,â€¦,ğœ}.

Definition 1
A Wheeler graph is a directed graph with edge labels where there exists an ordering <ğœ‹ on the vertices such that for any two edges (u, v, a) and (ğ‘¢â€²,ğ‘£â€²,ğ‘â€²) the following properties hold:

Property 1
ğ‘<ğ‘â€² implies ğ‘£<ğœ‹ğ‘£â€² and vertices with in-degree zero are placed first in the ordering;

Property 2
ğ‘=ğ‘â€² and ğ‘¢<ğœ‹ğ‘¢â€² implies ğ‘£â‰¤ğœ‹ğ‘£â€².

We consider an ordering of the vertices of the graph a proper ordering if it satisfies the properties of the Wheeler graph definition. See Fig. 1 for an illustration.

Fig. 1
figure 1
A Wheeler graph with ğœ=3. Ordering on edge labels: red (solid) < blue (long-dash) < green (short-dash) (Color figure online)

Full size image
The following list of additional properties of Wheeler graphs can be deduced from Definition 1.

Property 3
All edges inbound to a vertex v have the same edge label.

Property 4
In a proper ordering, all vertices with the same inbound edge label are ordered consecutively.

Property 5
A vertex can have multiple outbound edges with the same label. It is also possible for a vertex to have more than ğœ inbound or outbound edges.

Property 6
For a vertex ordering ğœ‹, two edges with the same label, (u, v, a) and (ğ‘¢â€²,ğ‘£â€²,ğ‘), where ğ‘¢<ğœ‹ğ‘¢â€² and ğ‘£â€²<ğœ‹ğ‘£ are called a monochromatic rainbow. No monochromatic rainbows can exist in a proper ordering (see Fig. 2).

Fig. 2
figure 2
In a proper ordering the above configurations cannot occur with edges that have the same label

Full size image
Problem Definitions
The first question we wish to answer is: given a directed graph with edge labels, does there exist a proper ordering <ğœ‹ for its vertices? We define this problem formally as the following.

Problem 1
(Wheeler Graph Recognition) Given a directed edge labeled graph ğº=(ğ‘‰,ğ¸), answer â€˜YESâ€™ if G is a Wheeler graph and â€˜NOâ€™ otherwise.

Although we do not demand it here, ideally, a solution to the above problem would also return a proper ordering.

Next, we define two optimization versions of Problem 1 where we seek to find Wheeler subgraphs.

Problem 2
(Wheeler Graph Violation (WGV)) Given a directed edge labeled graph ğº=(ğ‘‰,ğ¸), identify the smallest ğ¸â€²âŠ†ğ¸ such that ğºâ€²=(ğ‘‰,ğ¸âˆ–ğ¸â€²) is a Wheeler graph.

We also consider the dual of this problem.

Problem 3
(Wheeler Subgraph (WS)) Given a directed edge labeled graph ğº=(ğ‘‰,ğ¸), identify the largest ğ¸â€³âŠ†ğ¸ such that ğºâ€³=(ğ‘‰,ğ¸â€³) is a Wheeler graph.

Our Contribution
In Sect. 2 we show that the problem of recognizing whether a given graph is a Wheeler graph is NP-complete, even for an edge alphabet of size ğœ=2. This result holds even when the input is a directed acyclic graph (DAG) and when the number of edges leaving a vertex with the same label is at most five.

In Sect. 3 we relate the notion of queue number to Wheeler graphs, allowing us to place a bound on the number of edges of any Wheeler graph.

In Sect. 4 we provide an exponential time algorithm which solves the recognition problem on a graph ğº=(ğ‘‰,ğ¸) in time 2ğ‘‚(ğ‘›+ğ‘’logğœ) where ğ‘›=|ğ‘‰| and ğ‘’=|ğ¸|. It uses the idea of enumerating through all possible encodings of Wheeler graphs (of bounded size), and the fact that we can test whether there exists an isomorphism between two undirected graphs in sub-exponential time. This technique also gives us exact algorithms with the same time complexity for the optimization variants introduced in this work.

In Sect. 5 we examine the optimization variants of this problem called Wheeler Graph Violation (WGV) and Wheeler Subgraph (WS). We show via a reduction of the Minimum Feedback Arc Set problem that the Wheeler Graph Violation problem is APX-hard, and assuming the Unique Games Conjecture, cannot be approximated within a constant factor. This holds even when the graph is a DAG. On the other hand, we show that the Wheeler Subgraph problem is in the complexity class APX for ğœ=ğ‘‚(1). We do so by providing a polynomial-time algorithm whose solution size is Î©(1/ğœ) times the optimal value.

In Sect. 6, by using PQ-trees and ideas similar to those used to detect whether a DAG is leveled-planar, we demonstrate a class of graphs where Wheeler graph recognition can be done in linear time.

NP-Completeness of Wheeler Graph Recognition
Theorem 1
The Wheeler Graph Recognition Problem is NP-complete for any ğœâ‰¥2.

We first show a simple reduction from the Betweenness problem to Wheeler Graph Recognition. Although straightforward, it requires graphs with either Î˜(ğ‘›) sources, or Î˜(ğ‘›) edges with the same label leaving a single vertex. In Sect. 2.3, by expanding on the techniques used in the first reduction, we show that even if these quantities are limited to at most five, the recognition problem remains NP-complete.

The Betweenness Problem
The Betweenness problem was established as NP-complete by OpatrnÃ½ in 1979 [37]. Like our problem, it deals with finding a total ordering on a set of elements. The input to the Betweenness problem is a set of elements ğ‘‡={ğ‘¡1,â€¦,ğ‘¡ğ‘›} and a collection of ordered triples ğ¶âŠ†ğ‘‡3 called constraints. For a total ordering <ğœ™ on T, we say a constraint (ğ‘¡ğ‘—1,ğ‘¡ğ‘—2,ğ‘¡ğ‘—3)âˆˆğ¶ is satisfied if ğ‘¡ğ‘—1<ğœ™ğ‘¡ğ‘—2<ğœ™ğ‘¡ğ‘—3 or ğ‘¡ğ‘—3<ğœ™ğ‘¡ğ‘—2<ğœ™ğ‘¡ğ‘—1. The decision problem is to determine whether such a total ordering <ğœ™ exists.

As an example, consider the input ğ‘‡={1,2,3,4,5,6}, and constraints ğ¶={(5,2,3),(1,5,2),(4,5,6),(4,6,2)}. An ordering that satisfies the given constraints is 1, 4, 5, 6, 2, 3. An ordering that does not satisfy the given constraints is 1, 2, 3, 4, 5, 6 since it violates the constraints (5, 2, 3), (1, 5, 2), and (4, 6, 2).

Reduction from Betweenness to Wheeler Graph Recognition
Suppose we are given as input to the Betweenness problem the set ğ‘‡={ğ‘¡1,ğ‘¡2,â€¦,ğ‘¡ğ‘›}, and constraints ğ¶={(ğ‘¡ğ‘—1,ğ‘¡ğ‘—2,ğ‘¡ğ‘—3)âˆ£1â‰¤ğ‘—â‰¤ğ‘˜}. Construct a DAG G of size O(nk) as follows:

1.
Create a source vertex ğ‘£0.

2.
For 1â‰¤ğ‘—â‰¤ğ‘˜, 1â‰¤ğ‘–â‰¤ğ‘›, create vertex ğ‘£ğ‘—ğ‘–.

3.
For each constraint (ğ‘¡ğ‘—1,ğ‘¡ğ‘—2,ğ‘¡ğ‘—3)âˆˆğ¶, create a vertex for each element, we call them ğ‘¤ğ‘—1, ğ‘¤ğ‘—2, and ğ‘¤ğ‘—3 respectively.

4.
For 1â‰¤ğ‘–â‰¤ğ‘›, create the edge (ğ‘£0,ğ‘£1ğ‘–,1).

5.
For 1â‰¤ğ‘—â‰¤ğ‘˜âˆ’1, 1â‰¤ğ‘–â‰¤ğ‘›, create the edge (ğ‘£ğ‘—ğ‘–,ğ‘£ğ‘—+1ğ‘–,1).

6.
For 1â‰¤ğ‘—â‰¤ğ‘˜, 1â‰¤ğ‘–â‰¤ğ‘›, create the edge(s):

(ğ‘£ğ‘—ğ‘–,ğ‘¤ğ‘—1,2) and (ğ‘£ğ‘—ğ‘–,ğ‘¤ğ‘—2,2) if ğ‘¡ğ‘–=ğ‘¡ğ‘—1;

(ğ‘£ğ‘—ğ‘–,ğ‘¤ğ‘—2,2) if ğ‘¡ğ‘–=ğ‘¡ğ‘—2;

(ğ‘£ğ‘—ğ‘–,ğ‘¤ğ‘—3,2) and (ğ‘£ğ‘—ğ‘–,ğ‘¤ğ‘—2,2) if ğ‘¡ğ‘–=ğ‘¡ğ‘—3.

Fig. 3
figure 3
An example of the reduction with input list 1, 2, 3, 4, 5, 6 and the constraints (5, 2, 3), (1, 5, 2), (4, 5, 6)

Full size image
Figure 3 provides an illustration. The intuition is that the vertices with inbound red (solid) edges labeled 1 represent the permutation of the elements in T repeated k times. The vertices with the inbound blue (dashed) edges labeled 2 represent the elements in the constraints. An ordering can be obtained from a vertex arrangement like that in Fig. 3 as follows: vertices with inbound red edges are ordered from bottom-to-top, followed by the vertices with inbound blue edges, ordered from bottom-to-top. If the ordering we obtain is a proper ordering, the arrangement in the figure will have no edges of the same color crossing. The relation that this ordering has with constraints being satisfied can be observed in Fig. 3. For example, with the top-most betweenness constraint gadget for constraint (4, 5, 6), one can check that reversing the positions of the vertices for 4 and 6 with inbound blue edges will still avoid dashed blue edges crossing dashed blue edges as long as the same change happens for vertices with inbound red edges. However, any order where 5 is not between 4 and 6 will not satisfy this property. Hence, we can relate solutions to the Wheeler graph recognition problem to solutions to the Betweenness problem. We will formalize this argument next.

Lemma 1 first formalizes the way in which the vertices with inbound red edges represent a permutation being repeated k times.

Lemma 1
Let ğºâ€²=(ğ‘‰â€²,ğ¸â€²) be the subgraph of G consisting of the vertices ğ‘£0 ğ‘£11, ğ‘£12,..., ğ‘£1ğ‘›,...,ğ‘£21, ğ‘£22,..., ğ‘£2ğ‘›,..., ğ‘£ğ‘˜1, ğ‘£ğ‘˜2,..., ğ‘£ğ‘˜ğ‘› and the edges (ğ‘£0,ğ‘£1ğ‘–,1) for 1â‰¤ğ‘–â‰¤ğ‘› and (ğ‘£ğ‘—ğ‘–,ğ‘£ğ‘—+1ğ‘–,1) for 1â‰¤ğ‘–â‰¤ğ‘›, 1â‰¤ğ‘—â‰¤ğ‘˜âˆ’1. Then the Wheeler graph properties are satisfied on ğºâ€² iff the ordering ğœ‹ on ğ‘‰â€² is of form

ğ‘£0,ğ‘£1ğœ™(1),ğ‘£1ğœ™(2),â€¦,ğ‘£1ğœ™(ğ‘›),ğ‘£2ğœ™(1),ğ‘£2ğœ™(2),â€¦,ğ‘£2ğœ™(ğ‘›),â€¦,ğ‘£ğ‘˜ğœ™(1),ğ‘£ğ‘˜ğœ™(2),â€¦,ğ‘£ğ‘˜ğœ™(ğ‘›)
where ğœ™ is a permutation of {1,2,â€¦,ğ‘›}.

Proof
First consider when the vertices are ordered in the form stated in the lemma. Clearly, Property 1 is satisfied. Let (ğ‘£ğ‘—ğ‘–,ğ‘£ğ‘—+1ğ‘–,1) and (ğ‘£ğ‘—â€²ğ‘–â€²,ğ‘£ğ‘—â€²+1ğ‘–â€²,1) be arbitrary edges. If ğ‘—<ğ‘—â€², then ğ‘£ğ‘—ğ‘–<ğœ‹ğ‘£ğ‘—â€²ğ‘–â€², and ğ‘£ğ‘—+1ğ‘–<ğœ‹ğ‘£ğ‘—â€²+1ğ‘–â€². Thus the edges satisfy Property 2. The case where ğ‘—â€²<ğ‘— is symmetric. Hence, we can assume ğ‘—â€²=ğ‘—. If we assume WLOG that ğ‘£ğ‘—ğ‘–<ğœ‹ğ‘£ğ‘—ğ‘–â€², then ğ‘£ğ‘—+1ğ‘–<ğœ‹ğ‘£ğ‘—+1ğ‘–â€² and Property 2 is satisfied.

Conversely, assume the Wheeler graph properties are satisfied by an ordering <ğœ‹â€². Then, by Property 1, ğ‘£0 is ordered first. If all vertices in {ğ‘£1ğ‘–âˆ£1â‰¤ğ‘–â‰¤ğ‘›} do not appear prior to all {ğ‘£ğ‘—ğ‘–âˆ£1â‰¤ğ‘–â‰¤ğ‘›} where ğ‘—>1, then there exists some leftmost vertex ğ‘£ğ‘—ğ‘– such that ğ‘£ğ‘—ğ‘–<ğœ‹â€²ğ‘£1ğ‘–â€² for some 1â‰¤ğ‘–,ğ‘–â€²â‰¤ğ‘›. Then the edges (ğ‘£0,ğ‘£1ğ‘–â€²,1) and (ğ‘£ğ‘—âˆ’1ğ‘–,ğ‘£ğ‘—ğ‘–,1) contradict Property 2 since ğ‘£0<ğœ‹â€²ğ‘£ğ‘—âˆ’1ğ‘– but ğ‘£1ğ‘–â€²>ğœ‹â€²ğ‘£ğ‘—ğ‘–. This argument can then be extended to show that the set {ğ‘£2ğ‘–âˆ£1â‰¤ğ‘–â‰¤ğ‘›} must immediately follow {ğ‘£1ğ‘–âˆ£1â‰¤ğ‘–â‰¤ğ‘›}, and then repeated to prove the partial ordering

ğ‘£0<ğœ‹â€²ğ‘£11,â€¦ğ‘£1ğ‘›<ğœ‹â€²ğ‘£21,ğ‘£22,â€¦,ğ‘£2ğ‘›<ğœ‹â€²â€¦<ğœ‹â€²ğ‘£ğ‘˜1,ğ‘£ğ‘˜2,â€¦,ğ‘£ğ‘˜ğ‘›
must hold.

Let ğœ™ denote the permutation applied to the vertices in {ğ‘£1ğ‘–âˆ£1â‰¤ğ‘–â‰¤ğ‘›} by the vertex ordering <ğœ‹â€². If ğœ™ is not applied to the vertices in {ğ‘£2ğ‘–âˆ£1â‰¤ğ‘–â‰¤ğ‘›} by <ğœ‹â€², then there exists an i and an ğ‘–â€² such that ğ‘£1ğ‘–<ğœ‹â€²ğ‘£1ğ‘–â€² and ğ‘£2ğ‘–â€²<ğœ‹â€²ğ‘£2ğ‘–, causing the edges (ğ‘£1ğ‘–,ğ‘£2ğ‘–,1) and (ğ‘£1ğ‘–â€²,ğ‘£2ğ‘–â€²,1) to contradict Property 2. The same argument can then be repeated to show the same permutation ğœ™ applied to {ğ‘£2ğ‘–âˆ£1â‰¤ğ‘–â‰¤ğ‘›} must be applied to {ğ‘£3ğ‘–âˆ£1â‰¤ğ‘–â‰¤ğ‘›}. Continuing this argument to {ğ‘£ğ‘˜ğ‘–âˆ£1â‰¤ğ‘–â‰¤ğ‘›} shows that <ğœ‹â€² orders the vertices in the desired form.â—» â—»

Lemma 2
An instance of the Betweenness problem has an ordering satisfying all of the constraints iff the graph G is a Wheeler graph.

Proof
We first assume that there exists a solution to the instance of the Betweenness problem. Let <ğœ™ be the ordering on the elements in T such that all constraints are satisfied. We abuse notation and also use ğœ™ to denote the permutation where ğ‘¡ğœ™(1)<ğœ™ğ‘¡ğœ™(2)<ğœ™â€¦<ğœ™ğ‘¡ğœ™(ğ‘›). For constraint (ğ‘¡ğ‘—1,ğ‘¡ğ‘—2,ğ‘¡ğ‘—3) let ğ‘“ğ‘— be 0 if ğ‘¡ğ‘—1<ğœ™ğ‘¡ğ‘—2<ğœ™ğ‘¡ğ‘—3 and 2 if ğ‘¡ğ‘—3<ğœ™ğ‘¡ğ‘—2<ğœ™ğ‘¡ğ‘—1.

Order the vertices as follows:

ğ‘£0,ğ‘£1ğœ™(1),â€¦,ğ‘£1ğœ™(ğ‘›),ğ‘£2ğœ™(1),â€¦,ğ‘£2ğœ™(ğ‘›),â€¦,ğ‘£ğ‘˜ğœ™(1),â€¦,ğ‘£ğ‘˜ğœ™(ğ‘›),ğ‘¤11+ğ‘“1,ğ‘¤12,ğ‘¤13âˆ’ğ‘“1,ğ‘¤21+ğ‘“2,ğ‘¤22,ğ‘¤23âˆ’ğ‘“2,â€¦,ğ‘¤ğ‘˜1+ğ‘“ğ‘˜,ğ‘¤ğ‘˜2,ğ‘¤ğ‘˜3âˆ’ğ‘“ğ‘˜.
Let <ğœ‹ denote this vertex ordering. The first property of Wheeler graphs is satisfied since ğ‘£0 with in-degree zero is ordered first, all vertices with inbound edges having label 1 are next, followed by all vertices having inbound edges with label 2. Violations of Property 2 with edges having label 1 are avoided by Lemma 1. We show next that violations of Property 2 with edges having label 2 are avoided as well. Consider the constraint (ğ‘¡ğ‘—1,ğ‘¡ğ‘—2,ğ‘¡ğ‘—3) where ğ‘¡ğ‘–=ğ‘¡ğ‘—1, ğ‘¡â„=ğ‘¡ğ‘—2, and ğ‘¡â„“=ğ‘¡ğ‘—3. Either ğ‘¡ğ‘–<ğœ™ğ‘¡â„<ğœ™ğ‘¡â„“ and the vertex order has ğ‘£ğ‘—ğ‘–<ğœ‹ğ‘£ğ‘—â„<ğœ‹ğ‘£ğ‘—â„“ and ğ‘¤ğ‘—1<ğœ‹ğ‘¤ğ‘—2<ğœ‹ğ‘¤ğ‘—3; or ğ‘¡â„“<ğœ™ğ‘¡â„<ğœ™ğ‘¡ğ‘– and the vertex order has ğ‘£ğ‘—â„“<ğœ‹ğ‘£ğ‘—â„<ğœ‹ğ‘£ğ‘—ğ‘– and ğ‘¤ğ‘—3<ğœ‹ğ‘¤ğ‘—2<ğœ‹ğ‘¤ğ‘—1. In both cases, for every pair of edges in (ğ‘£ğ‘—ğ‘–,ğ‘¤ğ‘—1,2), (ğ‘£ğ‘—ğ‘–,ğ‘¤ğ‘—2,2), (ğ‘£ğ‘—â„,ğ‘¤ğ‘—2,2), (ğ‘£ğ‘—â„“,ğ‘¤ğ‘—3,2), and (ğ‘£ğ‘—â„“,ğ‘¤ğ‘—2,2) Property 2 is satisfied.

In the other direction, we assume that the graph constructed in the reduction is a Wheeler graph. First, by Property 1, ğ‘£0 must be ordered before all vertices in {ğ‘£ğ‘—ğ‘–âˆ£1â‰¤ğ‘—â‰¤ğ‘˜,1â‰¤ğ‘–â‰¤ğ‘›}, followed by all vertices {ğ‘¤ğ‘—ğ‘–âˆ£1â‰¤ğ‘—â‰¤ğ‘˜,1â‰¤ğ‘–â‰¤3}. Again by Lemma 1, to avoid violations of Property 2 for edges with label 1 there must be some permutation ğœ™ such that ğ‘£0 and the vertices in the first set are ordered

ğ‘£0,ğ‘£1ğœ™(1),â€¦,ğ‘£1ğœ™(ğ‘›),ğ‘£2ğœ™(1),â€¦,ğ‘£2ğœ™(ğ‘›),â€¦,ğ‘£ğ‘˜ğœ™(1),â€¦,ğ‘£ğ‘˜ğœ™(ğ‘›).
Since there are no violations of Property 2 for blue edges, for all 1â‰¤ğ‘—â‰¤ğ‘˜âˆ’1 we have that ğ‘¤ğ‘—1, ğ‘¤ğ‘—2, and ğ‘¤ğ‘—3 are all ordered before ğ‘¤ğ‘—+11, ğ‘¤ğ‘—+12, ğ‘¤ğ‘—+13. Furthermore, for a particular j where ğ‘¡ğ‘–=ğ‘¡ğ‘—1, ğ‘¡â„=ğ‘¡ğ‘—2, and ğ‘¡â„“=ğ‘¡ğ‘—3, it must be that the partial order induced on ğ‘£ğ‘—ğ‘–, ğ‘£ğ‘—â„, and ğ‘£ğ‘—â„“ is also induced on ğ‘¤ğ‘—1, ğ‘¤ğ‘—2, and ğ‘¤ğ‘—3. Additionally, for there to be no violations of Property 2, ğ‘£ğ‘—â„ (and hence ğ‘¤ğ‘—2) must lie between ğ‘£ğ‘—ğ‘– and ğ‘£ğ‘—â„“ (ğ‘¤ğ‘—1, ğ‘¤ğ‘—3 resp.). This implies that the ordering ğœ™ satisfies the constraint (ğ‘¡ğ‘—1,ğ‘¡ğ‘—2,ğ‘¡ğ‘—3) in C when ğœ™ is applied to T. Since this is true for all constraints in C, ğœ™ provides a solution to the Betweenness problem. â—»

Theorem 1 then follows directly from Lemma 2.

NP-Completeness of Wheeler Graph Recognition on d-NFAs
Now we restrict the number of edges with the same label that can leave a single vertex. We adopt the terminology used by Alanko et al., and consider the problem of recognizing whether a d-NFA is also a Wheeler graph [2]. A d-NFA is defined as follows:

Definition 2
A d-NFA G is an NFA where the number of edges with the same character leaving a vertex is at most d. We refer to the value d as the non-determinism of G.

Here an NFA contains a single start state, from which we assume each vertex is reachable.

The results in this section are in contrast to the recent work of Alanko et al., who showed that it can be recognized in polynomial time whether a 2-NFA is a Wheeler graph [2]. Their result, coupled with the observation that the reduction in Sect. 2 requires a ğ‘›Î˜(1)-NFA, suggests an interesting question about what role non-determinism plays in the tractability of Wheeler graph recognition. To this end, we prove Theorem 2.

Theorem 2
The Wheeler Graph Recognition Problem is NP-complete for d-NFAs, ğ‘‘â‰¥5.

The strategy of the proof will be to reduce the NP-complete problem 4-NAESAT to Wheeler Graph Recognition. In 4-NAESAT each clause is of length 4, and an instance is satisfiable iff there exists a truth assignment such that each clause contains both a true literal and a false literal. We start with 4-NAESAT to obtain a 3-NAESAT instance. The reduction is folklore knowledge, but we include it for completeness and to highlight a desired property.

Lemma 3
An instance ğœ“ of 4-NAESAT can be reduced in polynomial-time to an instance ğœ“â€² of 3-NAESAT where a variable occurring in the middle of a clause appears at most twice in ğœ“â€².

Proof
Convert the 4-NAESAT instance ğœ“ to a 3-NAESAT instance ğœ“â€² by converting each clause (ğ‘ğ‘˜,ğ‘ğ‘˜,ğ‘ğ‘˜,ğ‘‘ğ‘˜) into the clauses (ğ‘ğ‘˜,ğ‘¤ğ‘˜,ğ‘ğ‘˜) and (ğ‘ğ‘˜,ğ‘¤ğ‘˜â¯â¯â¯â¯â¯â¯â¯,ğ‘‘ğ‘˜) where ğ‘¤ğ‘˜ is a new variable. One can quickly check that it is always possible to find a satisfying not-all-equal assignment for both clauses, unless ğ‘ğ‘˜=ğ‘ğ‘˜=ğ‘ğ‘˜=ğ‘‘ğ‘˜. We also note that the variable used in the middle of the clauses, ğ‘¤ğ‘˜, is used only twice in all of ğœ“â€².    â—»

For convenience, we define the set of 3-NAESAT instances where any variable occurring in the middle of a clause occurs at most twice in the whole Boolean formula as 3-NAESATâˆ—. We next describe the construction of a one source DAG from an instance of 3-NAESATâˆ—.

Fig. 4
figure 4
Vertex ğ‘1 and ğ‘2 could be for clauses (ğ‘¥1,ğ‘¥2,ğ‘¥3), (ğ‘¥2,ğ‘¥3â¯â¯â¯â¯â¯â¯,ğ‘¥4). Each â€˜betweennessâ€™ constraint adds a layer. Layer for constraint (ğ‘¥4,ğ‘‹,ğ‘¥4â¯â¯â¯â¯â¯â¯) is shown

Full size image
Suppose we are given an instance ğœ“ of 3-NAESATâˆ— with variables ğ‘¥1,ğ‘¥2,â€¦,ğ‘¥ğ‘› and the clauses (ğ‘ğ‘˜,ğ‘ğ‘˜,ğ‘ğ‘˜) where we assume ğ‘ğ‘˜, ğ‘ğ‘˜, ğ‘ğ‘˜ can represent either a Boolean variable or its negation. We create a single source DAG G based on ğœ“. The first step creates a menorah like structure which allows for the vertices representing ğ‘¥ğ‘– and ğ‘¥ğ‘–â¯â¯â¯â¯â¯ to swap places in G, but otherwise fixes the positions of the vertices. We begin by adding the vertices which represent the literals, ğ‘¥1,â€¦,ğ‘¥ğ‘›,ğ‘‹,ğ‘¥1â¯â¯â¯â¯â¯â¯,â€¦,ğ‘¥ğ‘›â¯â¯â¯â¯â¯â¯ (the role of X will become clear). We will use the literals to refer to the vertices. Next, we add a structure to constrain their possible positions (see Fig. 4 for an example).

To create this structure, do as follows:

Create the vertices ğ‘ 01,ğ‘ 02,â€¦,ğ‘ 0ğ‘›.

Create the red (solid) edges (ğ‘ 01,ğ‘ 02,1), (ğ‘ 02,ğ‘ 03,1), â€¦ (ğ‘ 0ğ‘›,ğ‘‹,1).

For 1â‰¤ğ‘–â‰¤ğ‘›âˆ’1, 1â‰¤ğ‘—â‰¤ğ‘›âˆ’ğ‘–, create the vertices ğ‘ ğ‘—ğ‘– and ğ‘ ğ‘—ğ‘–â¯â¯â¯â¯â¯.

For 1â‰¤ğ‘–â‰¤ğ‘›âˆ’1, 1â‰¤ğ‘—â‰¤ğ‘›âˆ’ğ‘–, create the red (solid) edges (ğ‘ ğ‘—âˆ’1ğ‘–,ğ‘ ğ‘—ğ‘–,1) and (ğ‘ ğ‘—âˆ’1ğ‘–â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯,ğ‘ ğ‘—ğ‘–â¯â¯â¯â¯â¯,1).

For 1â‰¤ğ‘–â‰¤ğ‘›, create the red (solid) edges (ğ‘ ğ‘›âˆ’ğ‘–ğ‘–,ğ‘¥ğ‘–,1) and (ğ‘ ğ‘›âˆ’ğ‘–ğ‘–â¯â¯â¯â¯â¯â¯â¯â¯â¯,ğ‘¥ğ‘–â¯â¯â¯â¯â¯,1).

For clause k, denoted as (ğ‘ğ‘˜,ğ‘ğ‘˜,ğ‘ğ‘˜), we add a vertex ğ‘ğ‘˜. Suppose the middle variable of the clause, ğ‘ğ‘˜, is ğ‘¥â„ (positive or negated), then we add the vertices ğ‘§ğ‘—ğ‘˜ for 1â‰¤ğ‘—â‰¤ğ‘›âˆ’â„, and red edges (ğ‘ 0â„,ğ‘§1ğ‘˜,1),(ğ‘§1ğ‘˜,ğ‘§2ğ‘˜,1) â€¦(ğ‘§ğ‘›âˆ’â„ğ‘˜,ğ‘ğ‘˜,1).

Now we wish to add a set of betweenness type constraints on any proper ordering given of the vertices îˆ¸0={ğ‘¥1,â€¦,ğ‘¥ğ‘›,ğ‘‹,ğ‘¥ğ‘›â¯â¯â¯â¯â¯â¯,â€¦,ğ‘¥1â¯â¯â¯â¯â¯â¯,ğ‘1,ğ‘2,â€¦}. We first add a layer of new vertices îˆ¸1={ğ‘¥11,â€¦,ğ‘¥1ğ‘›,ğ‘‹1,ğ‘¥1ğ‘›â¯â¯â¯â¯â¯â¯,â€¦,ğ‘¥11â¯â¯â¯â¯â¯â¯,ğ‘11,ğ‘12,â€¦} and red (solid) edges labeled 1 from each vertex in layer îˆ¸0 to its corresponding vertex in îˆ¸1. We will utilize the same gadget that was used in Sect. 2.2. To add a betweenness constraint (ğ‘¦1,ğ‘¦2,ğ‘¦3) to arbitrary vertices ğ‘¦1, ğ‘¦2, ğ‘¦3 in îˆ¸1, we add the vertices ğ‘¤11, ğ‘¤12, and ğ‘¤13 and the blue (dashed) edges (ğ‘¦1,ğ‘¤11,2), (ğ‘¦1,ğ‘¤12,2), (ğ‘¦2,ğ‘¤12,2), (ğ‘¦3,ğ‘¤13,2), and (ğ‘¦3,ğ‘¤12,2). Additional betweenness constraints can be similarly enforced by adding a new layer îˆ¸2 on top of îˆ¸1 with a new gadget. Using this technique of adding a new layer for every new betweenness constraint, we next add the constraints (ğ‘ğ‘˜,ğ‘ğ‘˜,ğ‘ğ‘˜) and (ğ‘ğ‘˜,ğ‘‹,ğ‘ğ‘˜) for every clause (ğ‘ğ‘˜,ğ‘ğ‘˜,ğ‘ğ‘˜) and the constraints (ğ‘¥ğ‘–,ğ‘‹,ğ‘¥ğ‘–â¯â¯â¯â¯â¯) for 1â‰¤ğ‘–â‰¤ğ‘›.

Before proving the correctness of the reduction, we make the observation that because any variable occurring in the middle of a clause occurs at most twice in the whole Boolean formula, the maximum number of edges leaving a vertex ğ‘ 0ğ‘– is bounded by 3+2=5. All of the other vertices have at most three edges with the same label leaving them.

Lemma 4
The leveled graph G constructed as above from an instance ğœ“ of 3-NAESATâˆ— is a Wheeler graph iff ğœ“ is satisfiable.

Proof
Given a truth assignment that satisfies the 3-NAESATâˆ— instance ğœ“, put the vertices in îˆ¸0 whose literals are assigned the value T (true) on the left side of X (as in Fig. 4), and the vertices whose literals are assigned F (false) on the right side of X. For example, if ğ‘¥1=ğ‘‡ and ğ‘¥2=ğ¹, the two left-most vertices on level îˆ¸0 would be ğ‘¥1 followed by ğ‘¥2â¯â¯â¯â¯â¯â¯. For all of the possible not-all-equal arrangements of the literals for ğ‘ğ‘˜, ğ‘ğ‘˜, and ğ‘ğ‘˜, relative to X, we will always be able to find a place in the ordering for ğ‘ğ‘˜ that respects the betweenness constraints. For instance, if the variable for ğ‘ğ‘˜ is ğ‘¥â„, this is possible because ğ‘ğ‘˜ is able to â€˜freely pivotâ€™ around the vertex ğ‘ â„ in the spine of the menorah structure and find the betweenness-constraint-respecting position immediately to the left or right of ğ‘¥â„ or ğ‘¥â„â¯â¯â¯â¯â¯â¯. This can be confirmed by examining all possible cases, as is shown in Table 1. For clause (ğ‘ğ‘˜,ğ‘ğ‘˜,ğ‘ğ‘˜), Table 1 shows all possible not-all-equal truth assignments, and the corresponding relative orderings of îˆ¸0 we can apply to the vertices that satisfy the Wheeler graph properties.

Table 1 Possible relative orderings of ğ‘ğ‘˜, ğ‘ğ‘˜, ğ‘ğ‘˜, ğ‘ğ‘˜, X subject to constraints (ğ‘ğ‘˜,ğ‘ğ‘˜,ğ‘ğ‘˜) and (ğ‘ğ‘˜,ğ‘‹,ğ‘ğ‘˜)
Full size table
Table 2 Orderings implied by all-equal assignment
Full size table
In the other direction, assume G is a Wheeler graph so we have a proper ordering on the vertices of G. The proper ordering of the menorah structure is fixed with the exception of ğ‘§ğ‘—ğ‘– vertices, the ordering duplicated across layers îˆ¸0,îˆ¸1,â€¦. We will show that in a proper ordering of the vertices, the ordering given to îˆ¸0 must have every clause in ğœ“ getting a not-all-equal assignment when we apply the following map: vertices for a non-negated literal on the left of X in îˆ¸0 map back to a T assignment for that variable, and vertices for a non-negated literal to the right of X in îˆ¸0 map back to an F assignment for that variable.

Suppose to the contrary that this mapping did not provide a valid not-all-equal assignment. Then îˆ¸0 was given an ordering where the vertices for ğ‘ğ‘˜,ğ‘ğ‘˜, and ğ‘ğ‘˜ are all either on the left or the right side of X. The possible arrangements for this are presented in Table 2. In contrast to the cases listed in Table 1, for all cases listed in Table 2, placing ğ‘ğ‘˜ between ğ‘ğ‘˜ and ğ‘ğ‘˜ violates the constraint (ğ‘ğ‘˜,ğ‘‹,ğ‘ğ‘˜), which by our reduction implies it violates Wheeler graph Property 2 as well. This contradicts the assumption that we have a proper ordering on the vertices. We conclude that a proper ordering of the vertices of G must map back to a truth assignment that gives each clause in ğœ“ a not-all-equal assignment. â—»

This leaves open the complexity of the recognition problem for 3-NFAs and 4-NFAs.

Fig. 5
figure 5
(Top) A Wheeler graph with an alphabet of size three. (Middle) The same graph with edge orientations removed. (Bottom) Processing of edges with three queues. A Wheeler graph with an alphabet of size three is guaranteed to have queue number at most three. Note the undirected graph actually has queue number less than three, which can be seen by coloring the two green (dotted) edges red (solid) (Color figure online)

Full size image
Wheeler Graphs and Queue Number
Queue Number
The concept of queue number and queue layout were introduced by Heath and Rosenberg, originally for undirected graphs in [28], and later expanded to DAGs in [27]. We describe it first for DAGs. Let the vertices of a DAG G be given a total ordering that is also a topological ordering. We will say the edges of G can be processed using a set of queues if we can iterate through the vertices in the given ordering and every time the tail of an edge is encountered that edge is enqueued in one of the queues, and when the head of that same edge is encountered, that edge is then dequeued from its assigned queue. If we assign every edge a color according to its queue, this is equivalent to the ordering not creating any monochromatic rainbows like those in the left of Fig. 2. Over all possible orderings of the vertices, there is some ordering which requires the minimum number of queues to perform this processing. That minimum number of queues is called the queue number of G. For undirected graphs, when processing the edges we make an edge enqueued the first time either of the vertices it is incident to is encountered, and dequeued when the other vertex it is incident to is encountered. Again, the minimum number of queues required to do this over all possible vertex orderings is the queue number of the graph. Figure 5 provides an illustration of the edges of an undirected graph being processed in this way. The problem of detecting whether a graph is a one-queue DAG was shown to be solvable in linear time by Heath and Pemmaraju [26,27,28]. Using a few additional steps, we can extend their techniques to a specific subset of Wheeler graphs.

Theorem 3
The Wheeler graph recognition problem can be solved in linear time for an edge alphabet of size ğœ=1 on graphs without self-loops.

Proof
When ğœ=1 and the graph has no self-loops, any proper Wheeler ordering is a topological ordering. The problem of finding a one-queue ordering and a proper Wheeler ordering are almost equivalent. The only difference is that for a proper Wheeler ordering all of the vertices with in-degree zero must be placed first. To overcome this, we first let ğ‘‰0âŠ†ğ‘‰ represent all vertices in V with in-degree zero. Create a new vertex u with in-degree zero and add an edge from u to each vertex in ğ‘‰0. Since a valid one-queue ordering is a topological ordering, ğ‘£0 must be first in the one-queue ordering. Moreover, any vertices in the set ğ‘‰âˆ’ğ‘‰0 must be in the one-queue ordering after the last position given to a vertex in ğ‘‰0, otherwise a rainbow is created. Thus, the above modification ensures that one-queue orderings on V place the vertices in ğ‘‰0 before any vertices in ğ‘‰âˆ’ğ‘‰0, so these orders are also proper Wheeler orderings. â—»

We can use additional results on the queue number of undirected simple graphs to obtain an upper bound on the number of edges that can be in a Wheeler graph. The queue number of the underlying undirected graph of a Wheeler graph with alphabet size ğœ, is at most ğœ. This is since, when edge orientations are removed, the absence of monochromatic rainbows enforced by the properties of Wheeler graphs is exactly what is required for processing edges having the same color using a single queue. See Fig. 5. As a result, we get the bound presented in Theorem 4.

Theorem 4
The number of edges in a Wheeler graph is at most (2ğœ+1)ğ‘›âˆ’ğœ(2ğœ+1).

Proof
The number of edges in a undirected graph with queue number at most q is bound by 2ğ‘ğ‘›âˆ’ğ‘(2ğ‘+1) [15]. By removing self edges and the edge orientations, the Wheeler graph becomes an undirected graph with queue number at most ğœ. Finally, there are at most n additional edges added due to self-loops. â—»

An Exponential Time Algorithm
We can apply the encoding introduced by Gagie et al. [20] to develop exponential time algorithms to solve all of the problems presented in this paper. The idea is to enumerate over all possible encodings of Wheeler graphs with the proper number of vertices, edges, and labels, checking whether the encoding is isomorphic with the given graph. This idea exploits the fact that having such a space-efficient encoding also implies having a limited search space of Wheeler graphs, and that graph isomorphism can be checked in sub-exponential time. We have the following theorem.

Theorem 5
Recognizing whether ğº=(ğ‘‰,ğ¸) is a Wheeler graph can be done in time 2ğ‘’logğœ+ğ‘‚(ğ‘›+ğ‘’), where ğ‘›=|ğ‘‰|, ğ‘’=|ğ¸|, and ğœ is the size of the edge label alphabet.

Before describing the algorithm that proves Theorem 5, we need to describe the encoding of a Wheeler graph given in [20]. A Wheeler graph can be completely specified by three bit vectors; two bit vectors O and I both of length ğ‘’+ğ‘› and a bit vector L of length ğ‘’logğœ. We assume that the vertices of the Wheeler graph G are listed in a proper ordering ğ‘¥1<ğœ‹ğ‘¥2<ğœ‹â€¦<ğœ‹ğ‘¥ğ‘›. The array O is of the form 0â„“110â„“21â€¦0â„“ğ‘›1 and I is of the form 0ğ‘˜110ğ‘˜21â€¦0ğ‘˜ğ‘›1. Here â„“ğ‘– is the out-degree of ğ‘¥ğ‘–, whereas ğ‘˜ğ‘– is the in-degree of ğ‘¥ğ‘–. The array L indicates which character symbol is assigned to each edge. Specifically, the ğ‘–ğ‘¡â„ character in L gives us the label of the edge corresponding to the ğ‘–ğ‘¡â„ zero in O. All of these arrays are equipped with additional rank and select structures to allow for efficient traversal as is done in the FM-index [18]. In [20] an additional array that stores character counts is added. For our purposes however, the arrays O, I, and L are adequate.

figure a
Psuedocode for our algorithm is given in Algorithm 1. It essentially enumerates all bit vectors of a given length, checks whether or not the bit vector encodes a valid Wheeler graph, and if so, then checks whether the encoding matches our given graph G. Let S represent the set of all possible encodings we wish to check. Note that |ğ‘†|â‰¤2ğ‘‚(ğ‘’+ğ‘›)+ğ‘’logğœ. The Wheeler graph corresponding to an encoding can be extracted by working from right to left reading the array I. For each zero in I, we know which symbol should be on the inbound edge going into the corresponding vertex. We only need to decide where the edgeâ€™s tail was. Let a be the edge label and j be the index of the label a in L that is furthest to the right in L and yet to be used. If no such j exists we reject the encoding. When assigning the tail for an edge, take as the tail the vertex ğ‘¥ğ‘– where ğ‘–=ğ‘Ÿğ‘ğ‘›ğ‘˜1(ğ‘‚,ğ‘ ğ‘’ğ‘™ğ‘’ğ‘ğ‘¡0(ğ‘‚,ğ‘—))+1. We call the graph constructed in this way ğºâ€².

We now wish to check whether ğºâ€² and G are the same graphs, only with a reordering of the vertices, that is, ğºâ€² is the result of applying an isomorphism to G. Unlike the typical isomorphism for labeled graphs, where a bijection between the symbols on the edge alphabet is all that is required, here we wish for the adjacency and the label on the edge to be preserved in the mapping between G and ğºâ€². Specifically, we wish to know if there exists a bijective function ğ‘“:ğ‘‰(ğº)â†’ğ‘‰(ğºâ€²), such that if ğ‘¢,ğ‘£âˆˆğ‘‰(ğº) are adjacent via an edge (u, v, a) with label a in G, then f(u) and f(v) are also adjacent via an edge (f(u), f(v), a) with label a in ğºâ€². Using ideas similar to those presented by Miller in [35], this problem can be reduced in polynomial time to checking whether two undirected graphs are isomorphic.

Lemma 5
The problem of checking whether the directed edge labeled graph ğºâ€² is edge-label-preserving isomorphic to G can be reduced in polynomial time to checking if two undirected graphs are isomorphic.

Proof
Define the transformation ğ›¼ from the directed edge labeled graph G to an undirected graph ğ›¼(ğº) as follows: For every directed edge (u, v, a) replace it with the a-gadget in Fig. 6. We will show that there exists an edge-label-preserving isomorphism from V(G) to ğ‘‰(ğºâ€²) if and only if there exists a (standard) isomorphism between ğ›¼(ğº) and ğ›¼(ğºâ€²).

We first assume that there exists an edge-label-preserving isomorphism f from V(G) to ğ‘‰(ğºâ€²). This implies that when ğ›¼ is applied to ğºâ€² the same gadget is used to replace the edge (f(u), f(v), a) as the gadget used to replace the edge (u, v, a) in G. Therefore, the function f can be naturally extended to an isomorphism ğ‘“Ìƒ  on the vertices of ğ›¼(ğº) providing an isomorphism between ğ›¼(ğº) and ğ›¼(ğºâ€²).

Fig. 6
figure 6
An a-gadget replacing directed labeled edge (u, v, a)

Full size image
Now, consider the case where ğ‘“Ìƒ  is an isomorphism between ğ›¼(ğº) and ğ›¼(ğºâ€²). We wish to show that G and ğºâ€² must be related by an edge-label-preserving isomorphism. Let ğ‘›â€²=|ğ‘‰(ğ›¼(ğº))|. We define a ğ‘›â€²-tuple of numbers for each vertex ğ‘£âˆˆğ‘‰(ğ›¼(ğº)) as ğ›½(ğ‘£)=(ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›â€²) where ğ‘ğ‘– is the number of vertices with graph distance i from v, i.e., minimum path length measured in edges. In Fig. 6, ğ›½(ğ‘¥)=(1,1,â€¦,1,2,â€¦) where the leading 1â€™s are repeated ğ‘+1 times. Also, ğ›½(ğ‘¦)=(1,1,â€¦,1,2,â€¦) where the leading 1â€™s are repeated ğœ+1 times. For example, when ğœ=1, we have ğ›½(ğ‘¦)=(1,1,2,â€¦). Notice first that ğ›½(ğ‘£)=ğ›½(ğ‘“Ìƒ (ğ‘£)), i.e., ğ›½(ğ‘£) is invariant under ğ‘“Ìƒ . Now observe that for any vertex ğ‘¢âˆˆğ‘‰(ğº) of degree d we have that ğ›½(ğ›¼(ğ‘¢))=(ğ‘‘,2ğ‘‘,â€¦) (where ğ›¼(ğ‘¢) denotes the vertex u is mapped onto when ğ›¼ is applied to G). It follows that any vertex which is an x vertex of an a-gadget is mapped by ğ‘“Ìƒ  onto an x vertex of an a-gadget. Similarly, any vertex which is a y vertex of an a-gadget is mapped by ğ‘“Ìƒ  onto a y vertex of an a-gadget. Hence, a-gadgets are mapped by ğ‘“Ìƒ  onto a-gadgets. This also implies that vertices in ğ‘‰(ğ›¼(ğº)) originally in G are mapped by ğ‘“Ìƒ  onto vertices in ğ‘‰(ğ›¼(ğºâ€²)) that were originally in ğ‘‰(ğºâ€²). If we restrict ğ‘“Ìƒ  to only the vertices originally in V(G), then this restriction provides us with an edge-label-preserving isomorphism between G and ğºâ€². The reduction clearly takes polynomial time. â—»

The final step in this algorithm is to check whether ğ›¼(ğº) and ğ›¼(ğºâ€²) are isomorphic. Using well established techniques, this can be done in time 2ğ‘›â€²âˆš+ğ‘‚(1) where ğ‘›â€² is the number of vertices in ğ›¼(ğº) [5]. The total time complexity of Algorithm 1 is the number of bit strings tested, multiplied by the time it takes to validate whether the bit string encodes a Wheeler graph ğºâ€² and decode it, convert G and ğºâ€² to undirected graphs ğ›¼(ğº) and ğ›¼(ğºâ€²), and test whether ğ›¼(ğº) and ğ›¼(ğºâ€²) are isomorphic. This yields an overall time complexity of |ğ‘†|ğ‘›ğ‘‚(1)2ğ‘›+2ğ‘’(ğœ+1)âˆš+ğ‘‚(1), i.e., 2ğ‘’logğœ+ğ‘‚(ğ‘›+ğ‘’) for Algorithm 1.

Optimization Variants of Wheeler Graph Recognition
The Wheeler Graph Violation Problem is APX-Hard
In this section we show that obtaining an approximate solution to the WGV problem whose objective value comes within some constant factor of the optimal solutionâ€™s objective value is NP-hard. We do this through a reduction that shows that WGV is at least as hard as solving the Minimum Feedback Arc Set problem (FAS). FAS in its original formulation is phrased in terms of a directed graph where the objective is to find the minimum number of edges that need to be removed in order to make the directed graph a DAG. A slightly different formulation proves more useful for us. Letting ğ¹ğœ‹={(ğ‘£ğ‘–,ğ‘£ğ‘—)âˆˆğ¸ âˆ£ ğ‘£ğ‘—<ğœ‹ğ‘£ğ‘–}, we have the following:

Lemma 6
(Younger [39]) Determining a minimum feedback arc set for ğº=(ğ‘‰,ğ¸) is equivalent to finding an ordering <ğœ‹ on V for which |ğ¹ğœ‹| is minimized.

From this, we can present an equivalent formulation of FAS.

Definition 3
(Minimum Feedback Arc Set (FAS)) The input is a set ğ‘‡={ğ‘¡1,ğ‘¡2,â€¦,ğ‘¡ğ‘›} of n numbers and a set of k inequalities of the form ğ‘¡ğ‘–<ğ‘¡ğ‘—. This task is to compute an ordering <ğœ‹ on T such that the number of inequalities violated is minimized.

Interestingly, we could not have used FAS for proving that the Wheeler graph recognition problem is NP-complete, as FAS is fixed-parameter tractable in terms of the size of the feedback arc set [10]. Indeed, setting the size of the feedback arc-set to zero is equivalent to checking if the given graph is a DAG and the problem becomes solvable in linear time.

On the other hand, it has been shown that FAS is APX-hard, meaning that every problem in APX is reducible to it [31]. It also implies, assuming NP â‰  P, that there is a constant ğ¶â‰¥1 such that there is no polynomial time algorithm which provides a C-approximation. The reduction provided in this section implies:

Theorem 6
The WGV problem is APX-hard.

In addition, Guruswami et al. demonstrated that assuming the Unique Games Conjecture holds, and NP â‰  P, there is no constant ğ¶â‰¥1 such that a polynomial-time algorithmâ€™s approximate solution to FAS is always a factor C from the optimal solution. We state this as a lemma.

Lemma 7
(Guruswami et al. [24]) Conditioned on the Unique Games Conjecture, for every ğ¶â‰¥1, it is NP-hard to find a C-approximation to FAS.

An approximation preserving reduction from FAS to WGV, combined with Lemma 7, proves the other main result of this section:

Theorem 7
Conditioned on the Unique Games Conjecture, for every constant ğ¶â‰¥1, it is NP-hard to find a C-approximation to WGV, implying WGV is not in APX.

The Reduction from FAS to WGV
Let ğ‘‡={ğ‘¡1,ğ‘¡2,â€¦,ğ‘¡ğ‘›} and inequalities ğ‘¡11<ğ‘¡12,ğ‘¡21<ğ‘¡22,â€¦,ğ‘¡ğ‘˜1<ğ‘¡ğ‘˜2 be the input to FAS. We define a heavy edge between the vertices u and v with label a as ğ‘˜+1 subdivided edges between u and v each with label a. That is, a heavy edge between u and v with label a consists of the edges (ğ‘¢,ğ‘¤ğ‘–,ğ‘) and (ğ‘¤ğ‘–,ğ‘£,ğ‘) for 1â‰¤ğ‘–â‰¤ğ‘˜+1. See Fig. 7 for an illustration. Heavy edges are useful to us, as a violation of Property 2 involving two heavy edges will require ğ‘˜+1 edges to be removed if the ordering is to be maintained. We use the following steps to create a graph (which is a DAG):

Create a vertex ğ‘£0.

For 1â‰¤ğ‘—â‰¤2ğ‘˜âˆ’1, 1â‰¤ğ‘–â‰¤ğ‘›+1, create vertex ğ‘£ğ‘—ğ‘–.

For each inequality ğ‘¡ğ‘—1<ğ‘¡ğ‘—2, create a vertex for both ğ‘¡ğ‘—1 and ğ‘¡ğ‘—2, labeled ğ‘¤ğ‘—1 and ğ‘¤ğ‘—2, respectively.

For 1â‰¤ğ‘–â‰¤ğ‘›+1, create heavy edges (ğ‘£0,ğ‘£1ğ‘–,1).

For 1â‰¤ğ‘–â‰¤ğ‘›+1,1â‰¤ğ‘—â‰¤2ğ‘˜âˆ’2, create heavy edges (ğ‘£ğ‘—ğ‘–,ğ‘£ğ‘—+1ğ‘–,1).

Create heavy edge (ğ‘£0,ğ‘¤11,2).

For 1â‰¤ğ‘—â‰¤2ğ‘˜âˆ’1,

if j is odd, create the heavy edge (ğ‘£ğ‘—ğ‘›+1,ğ‘¤ğ‘—+122,2),

if j is even, create the heavy edge (ğ‘£ğ‘—ğ‘›+1,ğ‘¤ğ‘—2+11,2).

For 1â‰¤ğ‘—â‰¤2ğ‘˜âˆ’1, 1â‰¤ğ‘–â‰¤ğ‘›,

if j is odd, create the regular (not heavy) edge:

(ğ‘£ğ‘—ğ‘–,ğ‘¤ğ‘—+121,2) if ğ‘¡ğ‘–=ğ‘¡ğ‘—+121,

(ğ‘£ğ‘—ğ‘–,ğ‘¤ğ‘—+122,2) if ğ‘¡ğ‘–=ğ‘¡ğ‘—+122.

Fig. 7
figure 7
A heavy(bold) edge in Fig. 8 is actually ğ‘˜+1 subdivided edges

Full size image
Fig. 8
figure 8
Reduction from FAS to WGV where ğ‘‡={1,2,3,4,5,6} and the inequalities are 5<3, 1<5, and 6<4

Full size image
An example of the reduction is given in Fig. 8. The intuition is that the vertices with an inbound heavy edge labeled 1 represent the permutation of the elements in T. The heavy edges labeled 1 force the permutation to be duplicated k times, once for each constraint. The vertices with the inbound edges labeled 2 represent the elements in each inequality. We will show that this is an approximation preserving reduction.

Let ğ¸â€² be an optimal solution to WGV and ğºâ€²=(ğ‘‰,ğ¸âˆ–ğ¸â€²). Let <ğœ‹ represent a proper ordering on the vertices of ğºâ€². Lemma 8 indicates that, other than permuting the ordering found on the vertices ğ‘£ğ‘—ğ‘– for 1â‰¤ğ‘–â‰¤ğ‘› (with the ordering duplicated for 1â‰¤ğ‘—â‰¤2ğ‘˜âˆ’1), the ordering for the vertices in Fig. 8 is fixed.

Lemma 8
Let ğœ™ represent a permutation of the set {1,2,â€¦,ğ‘›+1}. Any ordering <ğœ‹ which provides a solution to the constructed instance of WGV with at most k edges violating the Wheeler graph properties orders the vertices in the form

ğ‘£0,ğ‘£1ğœ™(1),ğ‘£1ğœ™(2),â€¦ğ‘£1ğœ™(ğ‘›+1),â€¦ğ‘£2ğ‘˜âˆ’1ğœ™(1),ğ‘£2ğ‘˜âˆ’1ğœ™(2),â€¦ğ‘£2ğ‘˜âˆ’1ğœ™(ğ‘›+1),ğ‘¤11,ğ‘¤12,ğ‘¤21,ğ‘¤22,â€¦ğ‘¤ğ‘˜1,ğ‘¤ğ‘˜2.
Proof
The ordering given from the statement of the lemma would require at most k edges to be removed to satisfy the Wheeler graph properties, so we know that |ğ¸â€²|â‰¤ğ‘˜. If any of the w vertices is placed before a v vertex, that would cause at least ğ‘˜+1 edges to need to be removed, and is hence sub-optimal. Similarly, ğ‘£0 must be placed first in the ordering.

Again by Lemma 1, if the v vertices are not ordered in the form

ğ‘£0,ğ‘£1ğœ™(1),ğ‘£1ğœ™(2),â€¦,ğ‘£1ğœ™(ğ‘›+1),â€¦,ğ‘£2ğ‘˜âˆ’1ğœ™(1),ğ‘£2ğ‘˜âˆ’1ğœ™(2),â€¦,ğ‘£2ğ‘˜âˆ’1ğœ™(ğ‘›+1),
this will cause a violation of Property 2. However, since these are now heavy edges, this will require at least ğ‘˜+1 edges to be removed in order to satisfy the Wheeler graph properties.

For the w vertices, the vertex ğ‘¤11 must be ordered before ğ‘¤12, else the heavy edges (ğ‘£0,ğ‘¤11,2) and (ğ‘£1ğ‘›+1,ğ‘¤12,2) would cause the removal of at least ğ‘˜+1 edges to be necessary. The vertex ğ‘¤12 must be ordered before ğ‘¤21, else the heavy edges (ğ‘£1ğ‘›+1,ğ‘¤12,2) and (ğ‘£2ğ‘›+1,ğ‘¤21,2) would cause the removal of at least ğ‘˜+1 edges to be necessary. This argument can be repeated until ğ‘¤ğ‘˜1 and ğ‘¤ğ‘˜2, proving that the ordering has the desired form. â—»

Let f(x) refer to the reduction described above applied to an instance x of FAS. Hence, f(x) is an instance of WGV. We also refer to the optimal solution to either of these problems as OPT(â‹…), and the objective value (or cost) of a solution as ğ‘£ğ‘ğ‘™(â‹…). For FAS, ğ‘£ğ‘ğ‘™(â‹…) is the number of violated inequalities. For WGV, ğ‘£ğ‘ğ‘™(â‹…) is the minimum number of edges that need to be removed to obtain a Wheeler graph when the ordering given by the solution is applied.

Lemma 9
Given an instance x of FAS, a solution ğ‘¦â€² to the instance f(x) of WGV that has ğ‘£ğ‘ğ‘™(ğ‘¦â€²)=â„“â‰¤ğ‘˜ yields a solution to x with â„“ violated inequalities.

Proof
By Lemma 8, we can assume the ordering of the vertices given by ğ‘¦â€² is of the form stated in Lemma 8, and is completely determined by the ordering given to ğ‘£11,ğ‘£12,â€¦,ğ‘£1ğ‘›,ğ‘£1ğ‘›+1. Ignore the vertex ğ‘£1ğ‘›+1 and apply the remaining ordering to T. Any edge that has to be removed is one of the two edges in a pair (ğ‘£ğ‘—ğ‘–1,ğ‘¤ğ‘—+121,2) and (ğ‘£ğ‘—ğ‘–2,ğ‘¤ğ‘—+122,2), where ğ‘¡ğ‘–1=ğ‘¡ğ‘—1 and ğ‘¡ğ‘–2=ğ‘¡ğ‘—2 for a constraint (ğ‘¡ğ‘—1,ğ‘¡ğ‘—2). Since ğ‘¤ğ‘—1<ğœ‹ğ‘¤ğ‘—2, this removal is only necessary if ğ‘£ğ‘—ğ‘–2<ğœ‹ğ‘£ğ‘—ğ‘–1. Hence, if one these edges must be removed, it implies that in our solution to x, ğ‘¡ğ‘–2<ğ‘¡ğ‘–1, and our solution does not satisfy the inequality ğ‘¡ğ‘—1<ğ‘¡ğ‘—2. On the other hand, if Property 2 holds for the edges (ğ‘£ğ‘—ğ‘–1,ğ‘¤ğ‘—+121,2) and (ğ‘£ğ‘—ğ‘–2,ğ‘¤ğ‘—+122,2), then in our solution for x, ğ‘¡ğ‘–1<ğ‘¡ğ‘–2, and the inequality ğ‘¡ğ‘—1<ğ‘¡ğ‘—2 is satisfied. â—»

The next lemma is an immediate consequence of Lemma 9.

Lemma 10
Given an instance x of FAS, a C-approximation to the solution OPT(f(x)) yields a C-approximation to the solution OPT(x).

Theorem 6 follows from Lemma 10 and Theorem 7 follows from Lemmas 7 and 10.

The Wheeler Subgraph Problem is in APX
The dual problem to WGV is the problem of finding the largest subgraph of ğº=(ğ‘‰,ğ¸) which is a Wheeler graph. This problem (defined in Sect. 1.2) is called the Wheeler Subgraph problem, abbreviated WS. Unlike WGV, this problem yields a Î˜(1)-approximate solution for constant ğœ.

We first prove the result for ğœ=1. We then apply this result to get an approximation for ğœ>1. The proof for ğœ=1 uses a branching of a directed graph. A branching is a set of arborescences, where an arborescence is a directed, rooted tree with all maximal paths starting at the root.

Lemma 11
There exists a linear time Î˜(1)-approximation algorithm for WS when the alphabet size is ğœ=1.

Proof
We consider G to be at least weakly connected. In the case where G is not weakly connected, the approximate solutions can be combined to obtain a solution for G with a Î˜(1)-approximation factor. First, remove all singleton vertices (vertices with in-degree and out-degree zero), and let ğ‘›â€² be the number of remaining vertices. By doing this we know that the number of edges in the remaining graph is at least ğ‘›â€²âˆ’1. Next, remove any edges that are self-loops. Let ğºâ€² denote the resulting graph and ğ‘‰+ denote the set of vertices with out-degree greater than zero in ğºâ€². There are two cases:

Case: |ğ‘‰+|â‰¤ğ‘›â€²/2: In this case, take a branching îˆ² such that each vertex with in-degree greater than zero is included in some arborescence whose root is in ğ‘‰+. This is always possible, as can be shown using induction on the number of vertices not in ğ‘‰+. In particular, if you take a vertex u not in ğ‘‰+, since there are no singleton vertices, u has in-degree greater than zero. Applying the inductive hypothesis to the graph ğºâ€²âˆ’{ğ‘¢}, you get that u has some edge from a vertex in ğºâ€²âˆ’{ğ‘¢}, which can be used to add u to an arborescence whose root is in ğ‘‰+. Let |îˆ²| denote the total number of arborescences in îˆ². Since |ğ‘‰+|â‰¤ğ‘›â€²/2, it follows that |îˆ²|â‰¤ğ‘›â€²/2 as well.

We create a planar leveling (ğ¿0,ğ¿1,â€¦) of îˆ² by aligning all roots of the branching on level ğ¿0 in an arbitrary order. Then set ğ¿ğ‘– to be all of the vertices that are distance i from some root in ğ¿0. Because these are trees, we can order the vertices within the levels in such a way that the leveling is planar. For our purposes, we say the levels increase from left to right. We claim that îˆ² is a Wheeler graph and that we can obtain a proper ordering <ğœ‹ for the vertices of îˆ² from this leveling. To obtain the proper ordering, start with ğ¿0 and read the order of the vertices on each level from the bottom to the top, then proceed right to the next level.

The number of edges in îˆ², denoted ğ‘’(îˆ²), is equal to ğ‘›â€²âˆ’|îˆ²|. And since |îˆ²|â‰¤ğ‘›â€²/2, we have that ğ‘’(îˆ²)â‰¥ğ‘›â€²/2. At the same time, by Theorem 4, the optimal number of edges, denoted |ğ¸âˆ—| (including the ğ‘‚(ğ‘›â€²) self-loops we removed earlier) is ğ‘‚(ğ‘›â€²). Hence, the ratio of the optimal solution value over the branching solution value is bounded by a constant. In particular, |ğ¸âˆ—|/ğ‘’(îˆ²)â‰¤ğ‘‚(ğ‘›â€²)/(ğ‘›â€²/2)=ğ‘‚(1). The construction of the branching, the planar leveling, and the extraction of <ğœ‹, can all be done in linear time.

Case |ğ‘‰+|>ğ‘›â€²/2: Here we first select a vertex ğ‘¢âˆˆğ‘‰+ and take an edge (u, v, 1) in ğºâ€² to be included in our solution. If u is no longer the tail of any unselected edges, remove u from ğ‘‰+. If ğ‘£âˆˆğ‘‰+, we remove from v from ğ‘‰+. We then continue taking vertices from ğ‘‰+ until it is empty. This creates a graph which is a collection of stars, and hence a Wheeler graph. Moreover, since every step adds an edge to our solution and removes at most two vertices from ğ‘‰+, the resulting graph has at least |ğ‘‰+|/2>ğ‘›â€²/4 edges. This gives us a solution with an approximation ratio of |ğ¸âˆ—|/|ğ‘‰+|<ğ‘‚(ğ‘›â€²)/(ğ‘›â€²/4)=ğ‘‚(1).

In both cases, we obtain an approximate solution with Î˜(|ğ¸âˆ—|) edges. â—»

Next, we consider when ğœ>1. Suppose ğºâˆ—=(ğ‘‰,ğ¸âˆ—) is the optimal solution for G. Then ğ¸âˆ—=ğ¸âˆ—1âˆªğ¸âˆ—2âˆªâ€¦âˆªğ¸âˆ—ğœ where ğ¸âˆ—ğ‘={(ğ‘¢,ğ‘£,ğ‘)âˆˆğ¸âˆ—}. Let ğºğ‘=(ğ‘‰,ğ¸ğ‘) where ğ¸ğ‘={(ğ‘¢,ğ‘£,ğ‘)âˆˆğ¸} and let ğºâ€²ğ‘=(ğ‘‰,ğ¸â€²ğ‘) be the optimal solution for ğºğ‘. Then, since |ğ¸âˆ—ğ‘|â‰¤|ğ¸â€²ğ‘| we have

|ğ¸âˆ—|=âˆ‘ğ‘=1ğœ|ğ¸âˆ—ğ‘|â‰¤ğœâ‹…maxğ‘|ğ¸âˆ—ğ‘|â‰¤ğœâ‹…maxğ‘|ğ¸â€²ğ‘|.
Applying the result for ğœ=1 (Lemma 11), we can approximate maxğ‘|ğ¸â€²ğ‘| with a solution having ğ›¼â‹…maxğ‘|ğ¸â€²ğ‘| edges for some constant ğ›¼â‰¤1. Since

ğ›¼ğœ|ğ¸âˆ—|â‰¤ğ›¼maxğ‘|ğ¸â€²ğ‘|â‰¤maxğ‘|ğ¸â€²ğ‘|â‰¤|ğ¸âˆ—|,
the solution provides a Î©(1/ğœ)-approximation.

Theorem 8
There exists a linear time Î©(1/ğœ)-approximation algorithm for WS.

We close this section by noting that the algorithm presented in Sect. 4 also provides us with an exponential time solution to the two optimization problems considered here in Sect. 5. The solution is to iterate over all possible subsets of edges in E, take the corresponding induced subgraph, and apply Algorithm 1 to identify if the induced subgraph is isomorphic to a Wheeler graph. For both the WGV and WS problems, the optimal solution is the encoding with the fewest edges removed. The resulting time complexity is the same as in Theorem 5 with the addition of one e term in the exponent. We have shown the following:

Theorem 9
The WGV problem and WS problem for an input ğº=(ğ‘‰,ğ¸) with ğ‘›=|ğ‘‰|, ğ‘’=|ğ¸|, and ğœ the size of the edge label alphabet, can be solved in time 2ğ‘’logğœ+ğ‘‚(ğ‘›+ğ‘’).

A Class of Graphs with Linear Time Solution for Recognition
As mentioned earlier, it was shown by Alanko et al. [2] that there exists an algorithm that solves the recognition problem on 2-NFAs in linear time. Their algorithm works by reducing the recognition problem to a 2-SAT instance, which can then be efficiently solved. However, this approach fails to generalize for d-NFAs where ğ‘‘>2. Here we allow for arbitrary levels of non-determinism, but we place rather stringent conditions on the graphs so that our techniques will work. It is also important to note that the motivation of pattern matching on graphs is not particularly well suited for this class of graphs (one of the main motivations of the work of Alanko et al.). We will see that these graphs can be easily converted into equivalent (from the pattern matching perspective) DFAs, which are trees, and hence Wheeler graphs. Instead, we take the viewpoint that these are ordering problems, where the edges in conjunction with Properties 1 and 2 form constraints, and the vertices need to be ordered in a way as to satisfy these constraints. The below characteristics make this ordering problem solvable in polynomial time.

We let ğ‘‰0 denote the set of vertices with in-degree zero. We require that the graph G must have at least one vertex with in-degree zero, making ğ‘‰0 non-empty. We also insist that all vertices in G must be reachable from some vertex in ğ‘‰0. The following definitions describe the additional characteristics we require in order for our algorithm to work.

Definition 4
We consider a graph G to have full-spectrum-outputs if for every vertex v of out-degree greater than zero, every label appears on an edge leaving from v.

Definition 5
A graph G has the unique-string-traversal property if for every vertex v, all walks from ğ‘‰0 to v form the same string when the walkâ€™s edge labels are concatenated.

Definition 6
A graph G is prefix-free if for every vertex v having out-degree zero, the string obtained by concatenating edge labels when traversing from ğ‘‰0 to v is not a proper prefix of any string obtained by concatenating edge labels on a walk from ğ‘‰0.

As a consequence of the unique-string-traversal property and all vertices being reachable from ğ‘‰0, the graph G must also be a DAG. Indeed, a cyclic graph would have a least one vertex v such that walks of different lengths start in ğ‘‰0 and end at v.

In Fig. 9 we see a simple example of two graphs that satisfy all of the stated conditions, however one is a Wheeler graph and the other is not. Furthermore, it can be seen from the reductions used in Sect. 2.2 that even when the input graphs satisfy the unique-string-traversal property and are prefix-free, the recognition problem remains NP-hard. We leave open whether the problem is NP-hard when restricted to instances that have full-spectrum-outputs and do not have the unique-string-traversal property and are not prefix-free.

Fig. 9
figure 9
On the left is an example of a small graph that has full-spectrum-outputs and the unique-string-traversal property, but is not a Wheeler graph. On the right is an example of a small graph that has all three properties and is a Wheeler graph

Full size image
Fig. 10
figure 10
Here p-nodes are represented by circles and q-nodes by rectangles. In this PQ-Tree the order on the leaves 1, 2, 3 can be reversed to 3, 2, 1, the leaves 4, 5, 6 can be permuted arbitrarily, and the order of the sets of leaves {1,2,3} and {4,5,6}, can be swapped

Full size image
The stated conditions make the recognition problem tractable through the use of techniques similar to those used to detect leveled-planar DAGs. Before presenting our solution, we introduce an essential data structure, and the process by which it is used to detect whether a DAG is leveled-planar.

PQ-Trees
PQ-trees were introduced by Booth and Lueker for the purpose of solving the consecutive ones problem [7] and have since found applications in a wide range of problems, including planarity detection, detecting interval graphs, and graph embedding [7, 11, 25, 30, 32]. PQ-trees represent a set of possible orderings of the leaves which are subject to certain constraints. These constraints specify that some subset of the leaves must be contiguous in the ordering. The trees are made up of three types of nodes, p-nodes, q-nodes, and leaves. The p-nodes allow for arbitrary permutations of their child nodes, whereas q-nodes only allow for the reversal of the ordering on their child nodes. The leaves represent the actual elements whose ordering we are interested in. See Fig. 10 for an example.

A universal PQ-tree is a p-node, v, where all of the leaves are vâ€™s children. The ğœ–-tree, ğ‘‡ğœ– is a special tree which represents the empty set of orderings. We can take the intersection of two PQ-trees in time proportional to the sum of their two tree sizes [7]. The resulting PQ-tree represents the intersection of the orderings represented by each PQ-tree. Deletion of a leaf can be done in constant time.

Detecting Leveled-Planar DAGs
Detecting whether a DAG is leveled-planar is an important sub-step in determining whether a graph is a one-queue DAG [26, 27]. A DAG, ğº=(ğ‘‰,ğ¸), is leveled-planar if and only if it has a leveling (a partition of V into sets ğ‘‰1, ğ‘‰2,..., ğ‘‰â„“ where edges exists only from ğ‘‰ğ‘– to ğ‘‰ğ‘–+1, 1â‰¤ğ‘–â‰¤â„“âˆ’1), and there exists an ordering of vertices for each level that when combined provide a planar layout of G. An algorithm for determining if a DAG is leveled-planar is given in [27]. We describe the most relevant portions of this algorithm below.

The restrictions we place on our recognition problem allow for a simplified version of their algorithm that only works when every vertex is reachable from the first level of the leveling. We start with a leveling ğ‘‰1,..., ğ‘‰â„“ of G. The idea is to process the leveling from left-to-right. For 1â‰¤ğ‘–â‰¤â„“, we will build a PQ-tree ğ‘‡ğ‘– whose leaves represent the vertices in ğ‘‰ğ‘–. The PQ-tree ğ‘‡ğ‘– captures all possible orderings of vertices in ğ‘‰ğ‘– that still permit a leveled-planar layout of the subgraph induced by ğ‘‰1,..., ğ‘‰ğ‘–. To start, we make ğ‘‡1 the universal PQ-tree whose leaves represent the vertices in ğ‘‰1. For ğ‘–>1, we construct the tree ğ‘‡ğ‘– based on the PQ-tree ğ‘‡ğ‘–âˆ’1 and the edges between ğ‘‰ğ‘–âˆ’1 and ğ‘‰ğ‘–.

The key to being able to do this is the IDENTIFY operation, whose implementation can be found in [27]. The IDENTIFY operation takes four arguments: a PQ-tree T, two leaves x and y in T, and a new leaf z. IDENTIFY transforms T into a new PQ-tree, ğ‘‡â€², that contains z and does not contain the leaves x and y. The PQ-tree ğ‘‡â€² represents the subset of the permutations represented by T where x and y are adjacent. For these permutations the leaves are modified so that x and y are now a single leaf z. If no such permutations exist, ğ‘‡â€² is made into the ğœ–-tree.

Equipped with the IDENTIFY operation, we can next describe how to obtain ğ‘‡ğ‘– from ğ‘‡ğ‘–âˆ’1. The PQ-tree ğ‘‡ğ‘– for level ğ‘‰ğ‘– is obtained from the PQ-tree ğ‘‡ğ‘–âˆ’1 for level ğ‘‰ğ‘–âˆ’1 as follows: Start by making ğ‘‡ğ‘– identical to ğ‘‡ğ‘–âˆ’1. For a vertex ğ‘¢âˆˆğ‘‰ğ‘–âˆ’1, if u has no out neighbors then u is deleted. If a vertex ğ‘¢âˆˆğ‘‰ğ‘–âˆ’1 has only a single neighbor ğ‘£âˆˆğ‘‰ğ‘–, then replace u with a new leaf v[u]. If u has out neighbors ğ‘£1,..., ğ‘£ğ‘–, then u is made into a p-node with children ğ‘£1[ğ‘¢],..., ğ‘£ğ‘–[ğ‘¢]. This is repeated for all ğ‘¢âˆˆğ‘‰ğ‘–âˆ’1. Then for a fixed v, all nodes of the form ğ‘£[â‹…] are merged into a single node using the IDENTIFY operation. If at any point the ğœ–-tree is returned, we stop and declare that the graph is not leveled-planar. A technical detail is that the order in which this operation must be applied is governed by the ordering of the nodes in ğ‘‰ğ‘– within the initial leveling. We refer the reader to [27] for details. Our algorithm for detecting Wheeler graphs under the stated restrictions will build on this algorithm. For convenience, we will call the combined steps that create ğ‘‡ğ‘– from ğ‘‡ğ‘–âˆ’1 pushing.

Linear Time Solution
The basic approach to solving this problem is to use a depth-first search, treating sets of vertices as a single vertex. These vertex sets will have PQ-trees pushed across them in a similar fashion as was done in the solution described above. The situation is slightly more complicated here as we have multiple edge types. This results in a tree structure, rather than a path of vertex sets. We will label the vertices representing vertex sets with capital letters and label the PQ-tree for a vertex set ğ‘ŠâŠ†ğ‘‰ as ğ‘‡ğ‘Š.

We split the algorithm into two parts. The first part is to create a tree where vertex sets play the role of vertices. It is a depth-first search using the edges between neighborhoods as connecting edges. The pseudocode is given in Algorithm 2. Let ğ‘ğ‘(ğ‘Š) denote the set of neighbors of the set W connected by an edge with label a. The function CREATEVERTEX takes a set of vertices and creates a new instance of a vertex class that can maintain pointers to its parent, children, internal vertices, and a string. Lemma 12 can be proven by applying induction to the number of edge labels, ğœ.

figure b
Lemma 12
If the given graph G is a Wheeler graph, in a proper ordering, the vertex sets obtained as above are ordered by the lexicographical ordering of their strings.

An example of a tree obtained from Algorithm 2 is shown in Fig. 11. The vertex sets are disjoint due to the unique-string-traversal property. During Algorithm 2, we can identify if the graph satisfies the unique-string-traversal property by checking that every vertex in V gets included into exactly one vertex set. The prefix-free property can be easily checked as well.

Fig. 11
figure 11
On the right is the tree resulting from Algorithm 2 applied to the Wheeler graph shown on the left. For the graph on the left, red (solid) edges correspond to edges labeled 1, and blue (dashed) edges correspond to edges labeled 2. For the tree, an oval in the tree corresponds to a set of vertices in the Wheeler graph. The labels for these vertices are shown inside each oval. For each set of vertices inside an oval, the strings obtained by concatenating the edge labels on the path from the source is the same. These strings are shown to the side of each oval within the tree. In the tree, the edge colors indicated which type of edge was taken at each step along a path to that set

Full size image
Moving forward, the next portion of the algorithm is a recursive procedure that starts with the set of vertices having in-degree zero. Pseudocode is given in Algorithm 3. Letting ğ‘‰â€² be the vertices processed prior to reaching W, we assume inductively that the PQ-tree ğ‘‡ğ‘Š represents all orderings of W such that if we fixed any one of these orderings there still exists a proper ordering of the vertices in ğ‘‰â€². Then, after performing the first line of the for-loop, the PQ-tree ğ‘‡ğ‘Š1 represents all orderings of ğ‘Š1 such that if we fixed any one of these orderings there still exists a proper ordering of the vertices in ğ‘‰â€²âˆªğ‘Š. After performing the second line in the for-loop, ğ‘‡ğ‘Š1 now represents all orderings of ğ‘Š1 such that if we fixed any one of these orderings there still exists a proper ordering of the vertices in ğ‘‰â€²âˆªğ‘Š and vertices that are descendants of ğ‘Š1. After completing the third line in the loop, ğ‘‡ğ‘Š represents all orderings of W such that if we fixed any one of them there still exists a proper ordering of the vertices in ğ‘‰â€²âˆªğ‘Š1 and any descendants of ğ‘Š1. We repeat this process for each of Wâ€™s children. When finally returned, ğ‘‡ğ‘Š represents all orderings of W such that there exists working orderings on ğ‘‰â€² and all descendants of W. The pseudocode for the whole algorithm is given in Algorithm 4.

The full-spectrum-output and prefix-free conditions are necessary to apply this algorithm. We need that every vertex in W maps onto some vertex in each of Wâ€™s children. Thanks to these properties, when the PQ-tree ğ‘‡ğ‘Šğ‘– gets pushed back from a child ğ‘Šğ‘– and the new PQ-tree ğ‘‡ğ‘Š is created, all the vertices in W are also leaves in ğ‘‡ğ‘Š, and we can take the intersection with the previous PQ-tree for W.

figure c
figure d
Time Complexity: Each set of edges between two vertex sets has PQ-trees pushed across it twice. These pushes can be done in time proportional to the number of edges. In addition, all intersections can be done in time proportional to the number of vertices. As a result of these two facts, the overall algorithm can be performed in linear time. We have demonstrated the following:

Theorem 10
It can be determined in linear time if a directed, edge labeled graph that has full-spectrum-outputs, is prefix-free, and has the unique-string-traversal property, is a Wheeler graph.

Discussion and Open Problems
We have shown that recognizing Wheeler graphs is indeed a hard problem in general. We have also shown a special case where the recognition problem can be performed efficiently. The most important directions to expand this research appear to be in identifying more classes of graphs where this can be done in polynomial time. We can also ask for improvements on the algorithms presented here. Specifically, we ask:

Is the Wheeler graph recognition problem NP-complete for 3-NFA and 4-NFA?

For which other classes of graphs can Wheeler graph recognition be done efficiently?

Is there a fixed-parameter-tractable exponential time algorithm for any of the hard problems given in this paper?

Can we provide a better approximation algorithm for the optimization variants?

Constructive answers to these questions will contribute to our knowledge on finding vertex orderings â€œcloseâ€ to that required for a Wheeler graph. It will aid in our ability to apply BWT based indices to various structures, as well as our ability to find useful compressible subgraphs.