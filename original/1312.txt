Abstract
In recent years, several compressed indexes based on variants of the Burrows–Wheeler transform have been introduced. Some of these are used to index structures far more complex than a single string, as was originally done with the FM-index (Ferragina and Manzini in J. ACM 52(4):552–581, https://doi-org.ezproxy.auckland.ac.nz/10.1145/1082036.1082039, 2005). As such, there has been an increasing effort to better understand under which conditions such an indexing scheme is possible. This has led to the introduction of Wheeler graphs (Gagie et al. in Theor Comput Sci 698:67–78, https://doi-org.ezproxy.auckland.ac.nz/10.1016/j.tcs.2017.06.016, 2017). Gagie et al. showed that de Bruijn graphs, generalized compressed suffix arrays, and several other BWT related structures can be represented as Wheeler graphs, and that Wheeler graphs can be indexed in a space-efficient way. Hence, being able to recognize whether a given graph is a Wheeler graph, or being able to approximate a given graph by a Wheeler graph, could have numerous applications in indexing. Here we resolve the open question of whether there exists an efficient algorithm for recognizing if a given graph is a Wheeler graph. We show:

The problem of recognizing whether a given graph 𝐺=(𝑉,𝐸) is a Wheeler graph is NP-complete for any edge label alphabet of size 𝜎≥2, even when G is a DAG. This holds even on a restricted subset of graphs called d-NFAs for 𝑑≥5. This is in contrast to recent results demonstrating the problem can be solved in polynomial time for d-NFAs where 𝑑≤2. We also show that the recognition problem can be solved in linear time for 𝜎=1 on graphs without self-loops;

There exists an 2𝑒log𝜎+𝑂(𝑛+𝑒) time exact algorithm where 𝑛=|𝑉| and 𝑒=|𝐸|. This algorithm relies on graph isomorphism being computable in strictly sub-exponential time;

We define an optimization variant of the problem called Wheeler Graph Violation, abbreviated WGV, where the aim is to identify the smallest set of edges that have to be removed from a graph to obtain a Wheeler graph. We show WGV is APX-hard, even when G is a DAG, implying there exists a constant 𝐶>1 for which there is no C-approximation algorithm (unless P = NP). Also, conditioned on the Unique Games Conjecture, for all 𝐶>1, it is NP-hard to find a C-approximation, implying WGV is not in APX;

We define the Wheeler Subgraph problem, abbreviated WS, where the aim is to find the largest subgraph which is a Wheeler Graph (the dual of WGV). In contrast to WGV, we give an 𝑂(𝜎)-approximation algorithm for the WS problem, implying it is in APX for 𝜎=𝑂(1).

The above findings suggest that most problems under this theme are computationally difficult. However, we identify a class of graphs for which the recognition problem is polynomial-time solvable, raising the question of which properties determine this problem’s difficulty.

Access provided by University of Auckland Library

Introduction
Within the last two decades, there has been the development of Burrows–Wheeler Transform (BWT) [9] based indices for compressing a diverse collection of data structures. This list includes labeled trees [38], certain classes of graphs [17, 36], and sets of multiple strings [19, 33]. These new techniques have motivated the search for a set of general conditions under which a structure can be indexed by a BWT based index, which led to the recent introduction of Wheeler graphs by Gagie et al. [20] (also see [4]). A Wheeler graph is a directed graph that has edge labels and satisfies two simple properties related to the ordering of its vertices. Although not general enough to encompass all BWT-based structures (e.g., [21]), Gagie et al. demonstrated that Wheeler graphs offer a unified way of modeling several BWT based data structures such as representations of de Bruijn graphs [8, 14], generalized compressed suffix arrays [38], multi-string BWTs [34], XBWTs [17], wavelet matrices [12], and certain types of finite automata [1, 6, 29]. They also showed that there exists an encoding of a Wheeler graph 𝐺=(𝑉,𝐸) which requires only 2(𝑒+𝑛)+𝑒log𝜎+𝜎log𝑒+𝑜(𝑛+𝑒log𝜎) bits where 𝜎 is the size of the edge label alphabet, 𝑒=|𝐸|, and 𝑛=|𝑉|. This encoding allows for the efficient traversal of multiple edges while processing characters in a string, using an algorithm similar to the backward search in the FM-index [18]. Since their introduction, Wheeler graphs have been the subject of significant study. This includes the study of the languages that are accepted by automata that are also Wheeler graphs [3], as well as the extension of a technique for compression known as tunneling to the BWTs of Wheeler graphs [4]. Additionally, Wheeler graphs give us insight into the more general problem of exact pattern matching on arbitrary labeled graphs, the computational complexity of which has been studied in several recent works [13, 16, 22]. It is clear that not all directed edge labeled graphs are Wheeler graphs, but despite being the subject of an increasing amount of research, it remained unknown how to recognize whether a given graph is a Wheeler graph. This made the authors of [20] explicitly pose the question of how to efficiently recognize whether a graph is a Wheeler graph.

The question is of both theoretical and practical value, as it might be the first step before attempting to apply some compression scheme to a given graph. For example, one could use the existence of a Wheeler subgraph to encode a graph. To do so, one maintains an encoding of the subgraph using the framework presented in [20] in addition to an adjacency list of the edges not included in the encoding. Depending on the size of the subgraph, such an encoding might provide large space savings at the cost of a modest time trade-off while traversing the graph. This concept also motivates the portion of the paper where we look at two optimization versions of this problem that seek subgraphs of the given graph which are Wheeler graphs. These problems turn out to be computationally difficult as well. As a positive result, we show that, for a constant sized alphabet, the problem of finding a maximum Wheeler subgraph admits a polynomial-time algorithm that outputs a solution with size within some constant factor of optimal. We also show that the problem of recognizing Wheeler graphs is related to that of identifying the queue number of a graph. This suggests a class of graphs where the problem becomes computationally tractable, a topic investigated in the last section of this work.

Wheeler Graphs
The notation (u, v, a) is used for the directed edge from u to v with label a. We will assume the usual ordering on the edge labels, which come from the alphabet {1,2,…,𝜎}.

Definition 1
A Wheeler graph is a directed graph with edge labels where there exists an ordering <𝜋 on the vertices such that for any two edges (u, v, a) and (𝑢′,𝑣′,𝑎′) the following properties hold:

Property 1
𝑎<𝑎′ implies 𝑣<𝜋𝑣′ and vertices with in-degree zero are placed first in the ordering;

Property 2
𝑎=𝑎′ and 𝑢<𝜋𝑢′ implies 𝑣≤𝜋𝑣′.

We consider an ordering of the vertices of the graph a proper ordering if it satisfies the properties of the Wheeler graph definition. See Fig. 1 for an illustration.

Fig. 1
figure 1
A Wheeler graph with 𝜎=3. Ordering on edge labels: red (solid) < blue (long-dash) < green (short-dash) (Color figure online)

Full size image
The following list of additional properties of Wheeler graphs can be deduced from Definition 1.

Property 3
All edges inbound to a vertex v have the same edge label.

Property 4
In a proper ordering, all vertices with the same inbound edge label are ordered consecutively.

Property 5
A vertex can have multiple outbound edges with the same label. It is also possible for a vertex to have more than 𝜎 inbound or outbound edges.

Property 6
For a vertex ordering 𝜋, two edges with the same label, (u, v, a) and (𝑢′,𝑣′,𝑎), where 𝑢<𝜋𝑢′ and 𝑣′<𝜋𝑣 are called a monochromatic rainbow. No monochromatic rainbows can exist in a proper ordering (see Fig. 2).

Fig. 2
figure 2
In a proper ordering the above configurations cannot occur with edges that have the same label

Full size image
Problem Definitions
The first question we wish to answer is: given a directed graph with edge labels, does there exist a proper ordering <𝜋 for its vertices? We define this problem formally as the following.

Problem 1
(Wheeler Graph Recognition) Given a directed edge labeled graph 𝐺=(𝑉,𝐸), answer ‘YES’ if G is a Wheeler graph and ‘NO’ otherwise.

Although we do not demand it here, ideally, a solution to the above problem would also return a proper ordering.

Next, we define two optimization versions of Problem 1 where we seek to find Wheeler subgraphs.

Problem 2
(Wheeler Graph Violation (WGV)) Given a directed edge labeled graph 𝐺=(𝑉,𝐸), identify the smallest 𝐸′⊆𝐸 such that 𝐺′=(𝑉,𝐸∖𝐸′) is a Wheeler graph.

We also consider the dual of this problem.

Problem 3
(Wheeler Subgraph (WS)) Given a directed edge labeled graph 𝐺=(𝑉,𝐸), identify the largest 𝐸″⊆𝐸 such that 𝐺″=(𝑉,𝐸″) is a Wheeler graph.

Our Contribution
In Sect. 2 we show that the problem of recognizing whether a given graph is a Wheeler graph is NP-complete, even for an edge alphabet of size 𝜎=2. This result holds even when the input is a directed acyclic graph (DAG) and when the number of edges leaving a vertex with the same label is at most five.

In Sect. 3 we relate the notion of queue number to Wheeler graphs, allowing us to place a bound on the number of edges of any Wheeler graph.

In Sect. 4 we provide an exponential time algorithm which solves the recognition problem on a graph 𝐺=(𝑉,𝐸) in time 2𝑂(𝑛+𝑒log𝜎) where 𝑛=|𝑉| and 𝑒=|𝐸|. It uses the idea of enumerating through all possible encodings of Wheeler graphs (of bounded size), and the fact that we can test whether there exists an isomorphism between two undirected graphs in sub-exponential time. This technique also gives us exact algorithms with the same time complexity for the optimization variants introduced in this work.

In Sect. 5 we examine the optimization variants of this problem called Wheeler Graph Violation (WGV) and Wheeler Subgraph (WS). We show via a reduction of the Minimum Feedback Arc Set problem that the Wheeler Graph Violation problem is APX-hard, and assuming the Unique Games Conjecture, cannot be approximated within a constant factor. This holds even when the graph is a DAG. On the other hand, we show that the Wheeler Subgraph problem is in the complexity class APX for 𝜎=𝑂(1). We do so by providing a polynomial-time algorithm whose solution size is Ω(1/𝜎) times the optimal value.

In Sect. 6, by using PQ-trees and ideas similar to those used to detect whether a DAG is leveled-planar, we demonstrate a class of graphs where Wheeler graph recognition can be done in linear time.

NP-Completeness of Wheeler Graph Recognition
Theorem 1
The Wheeler Graph Recognition Problem is NP-complete for any 𝜎≥2.

We first show a simple reduction from the Betweenness problem to Wheeler Graph Recognition. Although straightforward, it requires graphs with either Θ(𝑛) sources, or Θ(𝑛) edges with the same label leaving a single vertex. In Sect. 2.3, by expanding on the techniques used in the first reduction, we show that even if these quantities are limited to at most five, the recognition problem remains NP-complete.

The Betweenness Problem
The Betweenness problem was established as NP-complete by Opatrný in 1979 [37]. Like our problem, it deals with finding a total ordering on a set of elements. The input to the Betweenness problem is a set of elements 𝑇={𝑡1,…,𝑡𝑛} and a collection of ordered triples 𝐶⊆𝑇3 called constraints. For a total ordering <𝜙 on T, we say a constraint (𝑡𝑗1,𝑡𝑗2,𝑡𝑗3)∈𝐶 is satisfied if 𝑡𝑗1<𝜙𝑡𝑗2<𝜙𝑡𝑗3 or 𝑡𝑗3<𝜙𝑡𝑗2<𝜙𝑡𝑗1. The decision problem is to determine whether such a total ordering <𝜙 exists.

As an example, consider the input 𝑇={1,2,3,4,5,6}, and constraints 𝐶={(5,2,3),(1,5,2),(4,5,6),(4,6,2)}. An ordering that satisfies the given constraints is 1, 4, 5, 6, 2, 3. An ordering that does not satisfy the given constraints is 1, 2, 3, 4, 5, 6 since it violates the constraints (5, 2, 3), (1, 5, 2), and (4, 6, 2).

Reduction from Betweenness to Wheeler Graph Recognition
Suppose we are given as input to the Betweenness problem the set 𝑇={𝑡1,𝑡2,…,𝑡𝑛}, and constraints 𝐶={(𝑡𝑗1,𝑡𝑗2,𝑡𝑗3)∣1≤𝑗≤𝑘}. Construct a DAG G of size O(nk) as follows:

1.
Create a source vertex 𝑣0.

2.
For 1≤𝑗≤𝑘, 1≤𝑖≤𝑛, create vertex 𝑣𝑗𝑖.

3.
For each constraint (𝑡𝑗1,𝑡𝑗2,𝑡𝑗3)∈𝐶, create a vertex for each element, we call them 𝑤𝑗1, 𝑤𝑗2, and 𝑤𝑗3 respectively.

4.
For 1≤𝑖≤𝑛, create the edge (𝑣0,𝑣1𝑖,1).

5.
For 1≤𝑗≤𝑘−1, 1≤𝑖≤𝑛, create the edge (𝑣𝑗𝑖,𝑣𝑗+1𝑖,1).

6.
For 1≤𝑗≤𝑘, 1≤𝑖≤𝑛, create the edge(s):

(𝑣𝑗𝑖,𝑤𝑗1,2) and (𝑣𝑗𝑖,𝑤𝑗2,2) if 𝑡𝑖=𝑡𝑗1;

(𝑣𝑗𝑖,𝑤𝑗2,2) if 𝑡𝑖=𝑡𝑗2;

(𝑣𝑗𝑖,𝑤𝑗3,2) and (𝑣𝑗𝑖,𝑤𝑗2,2) if 𝑡𝑖=𝑡𝑗3.

Fig. 3
figure 3
An example of the reduction with input list 1, 2, 3, 4, 5, 6 and the constraints (5, 2, 3), (1, 5, 2), (4, 5, 6)

Full size image
Figure 3 provides an illustration. The intuition is that the vertices with inbound red (solid) edges labeled 1 represent the permutation of the elements in T repeated k times. The vertices with the inbound blue (dashed) edges labeled 2 represent the elements in the constraints. An ordering can be obtained from a vertex arrangement like that in Fig. 3 as follows: vertices with inbound red edges are ordered from bottom-to-top, followed by the vertices with inbound blue edges, ordered from bottom-to-top. If the ordering we obtain is a proper ordering, the arrangement in the figure will have no edges of the same color crossing. The relation that this ordering has with constraints being satisfied can be observed in Fig. 3. For example, with the top-most betweenness constraint gadget for constraint (4, 5, 6), one can check that reversing the positions of the vertices for 4 and 6 with inbound blue edges will still avoid dashed blue edges crossing dashed blue edges as long as the same change happens for vertices with inbound red edges. However, any order where 5 is not between 4 and 6 will not satisfy this property. Hence, we can relate solutions to the Wheeler graph recognition problem to solutions to the Betweenness problem. We will formalize this argument next.

Lemma 1 first formalizes the way in which the vertices with inbound red edges represent a permutation being repeated k times.

Lemma 1
Let 𝐺′=(𝑉′,𝐸′) be the subgraph of G consisting of the vertices 𝑣0 𝑣11, 𝑣12,..., 𝑣1𝑛,...,𝑣21, 𝑣22,..., 𝑣2𝑛,..., 𝑣𝑘1, 𝑣𝑘2,..., 𝑣𝑘𝑛 and the edges (𝑣0,𝑣1𝑖,1) for 1≤𝑖≤𝑛 and (𝑣𝑗𝑖,𝑣𝑗+1𝑖,1) for 1≤𝑖≤𝑛, 1≤𝑗≤𝑘−1. Then the Wheeler graph properties are satisfied on 𝐺′ iff the ordering 𝜋 on 𝑉′ is of form

𝑣0,𝑣1𝜙(1),𝑣1𝜙(2),…,𝑣1𝜙(𝑛),𝑣2𝜙(1),𝑣2𝜙(2),…,𝑣2𝜙(𝑛),…,𝑣𝑘𝜙(1),𝑣𝑘𝜙(2),…,𝑣𝑘𝜙(𝑛)
where 𝜙 is a permutation of {1,2,…,𝑛}.

Proof
First consider when the vertices are ordered in the form stated in the lemma. Clearly, Property 1 is satisfied. Let (𝑣𝑗𝑖,𝑣𝑗+1𝑖,1) and (𝑣𝑗′𝑖′,𝑣𝑗′+1𝑖′,1) be arbitrary edges. If 𝑗<𝑗′, then 𝑣𝑗𝑖<𝜋𝑣𝑗′𝑖′, and 𝑣𝑗+1𝑖<𝜋𝑣𝑗′+1𝑖′. Thus the edges satisfy Property 2. The case where 𝑗′<𝑗 is symmetric. Hence, we can assume 𝑗′=𝑗. If we assume WLOG that 𝑣𝑗𝑖<𝜋𝑣𝑗𝑖′, then 𝑣𝑗+1𝑖<𝜋𝑣𝑗+1𝑖′ and Property 2 is satisfied.

Conversely, assume the Wheeler graph properties are satisfied by an ordering <𝜋′. Then, by Property 1, 𝑣0 is ordered first. If all vertices in {𝑣1𝑖∣1≤𝑖≤𝑛} do not appear prior to all {𝑣𝑗𝑖∣1≤𝑖≤𝑛} where 𝑗>1, then there exists some leftmost vertex 𝑣𝑗𝑖 such that 𝑣𝑗𝑖<𝜋′𝑣1𝑖′ for some 1≤𝑖,𝑖′≤𝑛. Then the edges (𝑣0,𝑣1𝑖′,1) and (𝑣𝑗−1𝑖,𝑣𝑗𝑖,1) contradict Property 2 since 𝑣0<𝜋′𝑣𝑗−1𝑖 but 𝑣1𝑖′>𝜋′𝑣𝑗𝑖. This argument can then be extended to show that the set {𝑣2𝑖∣1≤𝑖≤𝑛} must immediately follow {𝑣1𝑖∣1≤𝑖≤𝑛}, and then repeated to prove the partial ordering

𝑣0<𝜋′𝑣11,…𝑣1𝑛<𝜋′𝑣21,𝑣22,…,𝑣2𝑛<𝜋′…<𝜋′𝑣𝑘1,𝑣𝑘2,…,𝑣𝑘𝑛
must hold.

Let 𝜙 denote the permutation applied to the vertices in {𝑣1𝑖∣1≤𝑖≤𝑛} by the vertex ordering <𝜋′. If 𝜙 is not applied to the vertices in {𝑣2𝑖∣1≤𝑖≤𝑛} by <𝜋′, then there exists an i and an 𝑖′ such that 𝑣1𝑖<𝜋′𝑣1𝑖′ and 𝑣2𝑖′<𝜋′𝑣2𝑖, causing the edges (𝑣1𝑖,𝑣2𝑖,1) and (𝑣1𝑖′,𝑣2𝑖′,1) to contradict Property 2. The same argument can then be repeated to show the same permutation 𝜙 applied to {𝑣2𝑖∣1≤𝑖≤𝑛} must be applied to {𝑣3𝑖∣1≤𝑖≤𝑛}. Continuing this argument to {𝑣𝑘𝑖∣1≤𝑖≤𝑛} shows that <𝜋′ orders the vertices in the desired form.◻ ◻

Lemma 2
An instance of the Betweenness problem has an ordering satisfying all of the constraints iff the graph G is a Wheeler graph.

Proof
We first assume that there exists a solution to the instance of the Betweenness problem. Let <𝜙 be the ordering on the elements in T such that all constraints are satisfied. We abuse notation and also use 𝜙 to denote the permutation where 𝑡𝜙(1)<𝜙𝑡𝜙(2)<𝜙…<𝜙𝑡𝜙(𝑛). For constraint (𝑡𝑗1,𝑡𝑗2,𝑡𝑗3) let 𝑓𝑗 be 0 if 𝑡𝑗1<𝜙𝑡𝑗2<𝜙𝑡𝑗3 and 2 if 𝑡𝑗3<𝜙𝑡𝑗2<𝜙𝑡𝑗1.

Order the vertices as follows:

𝑣0,𝑣1𝜙(1),…,𝑣1𝜙(𝑛),𝑣2𝜙(1),…,𝑣2𝜙(𝑛),…,𝑣𝑘𝜙(1),…,𝑣𝑘𝜙(𝑛),𝑤11+𝑓1,𝑤12,𝑤13−𝑓1,𝑤21+𝑓2,𝑤22,𝑤23−𝑓2,…,𝑤𝑘1+𝑓𝑘,𝑤𝑘2,𝑤𝑘3−𝑓𝑘.
Let <𝜋 denote this vertex ordering. The first property of Wheeler graphs is satisfied since 𝑣0 with in-degree zero is ordered first, all vertices with inbound edges having label 1 are next, followed by all vertices having inbound edges with label 2. Violations of Property 2 with edges having label 1 are avoided by Lemma 1. We show next that violations of Property 2 with edges having label 2 are avoided as well. Consider the constraint (𝑡𝑗1,𝑡𝑗2,𝑡𝑗3) where 𝑡𝑖=𝑡𝑗1, 𝑡ℎ=𝑡𝑗2, and 𝑡ℓ=𝑡𝑗3. Either 𝑡𝑖<𝜙𝑡ℎ<𝜙𝑡ℓ and the vertex order has 𝑣𝑗𝑖<𝜋𝑣𝑗ℎ<𝜋𝑣𝑗ℓ and 𝑤𝑗1<𝜋𝑤𝑗2<𝜋𝑤𝑗3; or 𝑡ℓ<𝜙𝑡ℎ<𝜙𝑡𝑖 and the vertex order has 𝑣𝑗ℓ<𝜋𝑣𝑗ℎ<𝜋𝑣𝑗𝑖 and 𝑤𝑗3<𝜋𝑤𝑗2<𝜋𝑤𝑗1. In both cases, for every pair of edges in (𝑣𝑗𝑖,𝑤𝑗1,2), (𝑣𝑗𝑖,𝑤𝑗2,2), (𝑣𝑗ℎ,𝑤𝑗2,2), (𝑣𝑗ℓ,𝑤𝑗3,2), and (𝑣𝑗ℓ,𝑤𝑗2,2) Property 2 is satisfied.

In the other direction, we assume that the graph constructed in the reduction is a Wheeler graph. First, by Property 1, 𝑣0 must be ordered before all vertices in {𝑣𝑗𝑖∣1≤𝑗≤𝑘,1≤𝑖≤𝑛}, followed by all vertices {𝑤𝑗𝑖∣1≤𝑗≤𝑘,1≤𝑖≤3}. Again by Lemma 1, to avoid violations of Property 2 for edges with label 1 there must be some permutation 𝜙 such that 𝑣0 and the vertices in the first set are ordered

𝑣0,𝑣1𝜙(1),…,𝑣1𝜙(𝑛),𝑣2𝜙(1),…,𝑣2𝜙(𝑛),…,𝑣𝑘𝜙(1),…,𝑣𝑘𝜙(𝑛).
Since there are no violations of Property 2 for blue edges, for all 1≤𝑗≤𝑘−1 we have that 𝑤𝑗1, 𝑤𝑗2, and 𝑤𝑗3 are all ordered before 𝑤𝑗+11, 𝑤𝑗+12, 𝑤𝑗+13. Furthermore, for a particular j where 𝑡𝑖=𝑡𝑗1, 𝑡ℎ=𝑡𝑗2, and 𝑡ℓ=𝑡𝑗3, it must be that the partial order induced on 𝑣𝑗𝑖, 𝑣𝑗ℎ, and 𝑣𝑗ℓ is also induced on 𝑤𝑗1, 𝑤𝑗2, and 𝑤𝑗3. Additionally, for there to be no violations of Property 2, 𝑣𝑗ℎ (and hence 𝑤𝑗2) must lie between 𝑣𝑗𝑖 and 𝑣𝑗ℓ (𝑤𝑗1, 𝑤𝑗3 resp.). This implies that the ordering 𝜙 satisfies the constraint (𝑡𝑗1,𝑡𝑗2,𝑡𝑗3) in C when 𝜙 is applied to T. Since this is true for all constraints in C, 𝜙 provides a solution to the Betweenness problem. ◻

Theorem 1 then follows directly from Lemma 2.

NP-Completeness of Wheeler Graph Recognition on d-NFAs
Now we restrict the number of edges with the same label that can leave a single vertex. We adopt the terminology used by Alanko et al., and consider the problem of recognizing whether a d-NFA is also a Wheeler graph [2]. A d-NFA is defined as follows:

Definition 2
A d-NFA G is an NFA where the number of edges with the same character leaving a vertex is at most d. We refer to the value d as the non-determinism of G.

Here an NFA contains a single start state, from which we assume each vertex is reachable.

The results in this section are in contrast to the recent work of Alanko et al., who showed that it can be recognized in polynomial time whether a 2-NFA is a Wheeler graph [2]. Their result, coupled with the observation that the reduction in Sect. 2 requires a 𝑛Θ(1)-NFA, suggests an interesting question about what role non-determinism plays in the tractability of Wheeler graph recognition. To this end, we prove Theorem 2.

Theorem 2
The Wheeler Graph Recognition Problem is NP-complete for d-NFAs, 𝑑≥5.

The strategy of the proof will be to reduce the NP-complete problem 4-NAESAT to Wheeler Graph Recognition. In 4-NAESAT each clause is of length 4, and an instance is satisfiable iff there exists a truth assignment such that each clause contains both a true literal and a false literal. We start with 4-NAESAT to obtain a 3-NAESAT instance. The reduction is folklore knowledge, but we include it for completeness and to highlight a desired property.

Lemma 3
An instance 𝜓 of 4-NAESAT can be reduced in polynomial-time to an instance 𝜓′ of 3-NAESAT where a variable occurring in the middle of a clause appears at most twice in 𝜓′.

Proof
Convert the 4-NAESAT instance 𝜓 to a 3-NAESAT instance 𝜓′ by converting each clause (𝑎𝑘,𝑏𝑘,𝑐𝑘,𝑑𝑘) into the clauses (𝑎𝑘,𝑤𝑘,𝑏𝑘) and (𝑐𝑘,𝑤𝑘⎯⎯⎯⎯⎯⎯⎯,𝑑𝑘) where 𝑤𝑘 is a new variable. One can quickly check that it is always possible to find a satisfying not-all-equal assignment for both clauses, unless 𝑎𝑘=𝑏𝑘=𝑐𝑘=𝑑𝑘. We also note that the variable used in the middle of the clauses, 𝑤𝑘, is used only twice in all of 𝜓′.    ◻

For convenience, we define the set of 3-NAESAT instances where any variable occurring in the middle of a clause occurs at most twice in the whole Boolean formula as 3-NAESAT∗. We next describe the construction of a one source DAG from an instance of 3-NAESAT∗.

Fig. 4
figure 4
Vertex 𝑍1 and 𝑍2 could be for clauses (𝑥1,𝑥2,𝑥3), (𝑥2,𝑥3⎯⎯⎯⎯⎯⎯,𝑥4). Each ‘betweenness’ constraint adds a layer. Layer for constraint (𝑥4,𝑋,𝑥4⎯⎯⎯⎯⎯⎯) is shown

Full size image
Suppose we are given an instance 𝜓 of 3-NAESAT∗ with variables 𝑥1,𝑥2,…,𝑥𝑛 and the clauses (𝑎𝑘,𝑏𝑘,𝑐𝑘) where we assume 𝑎𝑘, 𝑏𝑘, 𝑐𝑘 can represent either a Boolean variable or its negation. We create a single source DAG G based on 𝜓. The first step creates a menorah like structure which allows for the vertices representing 𝑥𝑖 and 𝑥𝑖⎯⎯⎯⎯⎯ to swap places in G, but otherwise fixes the positions of the vertices. We begin by adding the vertices which represent the literals, 𝑥1,…,𝑥𝑛,𝑋,𝑥1⎯⎯⎯⎯⎯⎯,…,𝑥𝑛⎯⎯⎯⎯⎯⎯ (the role of X will become clear). We will use the literals to refer to the vertices. Next, we add a structure to constrain their possible positions (see Fig. 4 for an example).

To create this structure, do as follows:

Create the vertices 𝑠01,𝑠02,…,𝑠0𝑛.

Create the red (solid) edges (𝑠01,𝑠02,1), (𝑠02,𝑠03,1), … (𝑠0𝑛,𝑋,1).

For 1≤𝑖≤𝑛−1, 1≤𝑗≤𝑛−𝑖, create the vertices 𝑠𝑗𝑖 and 𝑠𝑗𝑖⎯⎯⎯⎯⎯.

For 1≤𝑖≤𝑛−1, 1≤𝑗≤𝑛−𝑖, create the red (solid) edges (𝑠𝑗−1𝑖,𝑠𝑗𝑖,1) and (𝑠𝑗−1𝑖⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯,𝑠𝑗𝑖⎯⎯⎯⎯⎯,1).

For 1≤𝑖≤𝑛, create the red (solid) edges (𝑠𝑛−𝑖𝑖,𝑥𝑖,1) and (𝑠𝑛−𝑖𝑖⎯⎯⎯⎯⎯⎯⎯⎯⎯,𝑥𝑖⎯⎯⎯⎯⎯,1).

For clause k, denoted as (𝑎𝑘,𝑏𝑘,𝑐𝑘), we add a vertex 𝑍𝑘. Suppose the middle variable of the clause, 𝑏𝑘, is 𝑥ℎ (positive or negated), then we add the vertices 𝑧𝑗𝑘 for 1≤𝑗≤𝑛−ℎ, and red edges (𝑠0ℎ,𝑧1𝑘,1),(𝑧1𝑘,𝑧2𝑘,1) …(𝑧𝑛−ℎ𝑘,𝑍𝑘,1).

Now we wish to add a set of betweenness type constraints on any proper ordering given of the vertices 0={𝑥1,…,𝑥𝑛,𝑋,𝑥𝑛⎯⎯⎯⎯⎯⎯,…,𝑥1⎯⎯⎯⎯⎯⎯,𝑍1,𝑍2,…}. We first add a layer of new vertices 1={𝑥11,…,𝑥1𝑛,𝑋1,𝑥1𝑛⎯⎯⎯⎯⎯⎯,…,𝑥11⎯⎯⎯⎯⎯⎯,𝑍11,𝑍12,…} and red (solid) edges labeled 1 from each vertex in layer 0 to its corresponding vertex in 1. We will utilize the same gadget that was used in Sect. 2.2. To add a betweenness constraint (𝑦1,𝑦2,𝑦3) to arbitrary vertices 𝑦1, 𝑦2, 𝑦3 in 1, we add the vertices 𝑤11, 𝑤12, and 𝑤13 and the blue (dashed) edges (𝑦1,𝑤11,2), (𝑦1,𝑤12,2), (𝑦2,𝑤12,2), (𝑦3,𝑤13,2), and (𝑦3,𝑤12,2). Additional betweenness constraints can be similarly enforced by adding a new layer 2 on top of 1 with a new gadget. Using this technique of adding a new layer for every new betweenness constraint, we next add the constraints (𝑎𝑘,𝑍𝑘,𝑏𝑘) and (𝑐𝑘,𝑋,𝑍𝑘) for every clause (𝑎𝑘,𝑏𝑘,𝑐𝑘) and the constraints (𝑥𝑖,𝑋,𝑥𝑖⎯⎯⎯⎯⎯) for 1≤𝑖≤𝑛.

Before proving the correctness of the reduction, we make the observation that because any variable occurring in the middle of a clause occurs at most twice in the whole Boolean formula, the maximum number of edges leaving a vertex 𝑠0𝑖 is bounded by 3+2=5. All of the other vertices have at most three edges with the same label leaving them.

Lemma 4
The leveled graph G constructed as above from an instance 𝜓 of 3-NAESAT∗ is a Wheeler graph iff 𝜓 is satisfiable.

Proof
Given a truth assignment that satisfies the 3-NAESAT∗ instance 𝜓, put the vertices in 0 whose literals are assigned the value T (true) on the left side of X (as in Fig. 4), and the vertices whose literals are assigned F (false) on the right side of X. For example, if 𝑥1=𝑇 and 𝑥2=𝐹, the two left-most vertices on level 0 would be 𝑥1 followed by 𝑥2⎯⎯⎯⎯⎯⎯. For all of the possible not-all-equal arrangements of the literals for 𝑎𝑘, 𝑏𝑘, and 𝑐𝑘, relative to X, we will always be able to find a place in the ordering for 𝑍𝑘 that respects the betweenness constraints. For instance, if the variable for 𝑏𝑘 is 𝑥ℎ, this is possible because 𝑍𝑘 is able to ‘freely pivot’ around the vertex 𝑠ℎ in the spine of the menorah structure and find the betweenness-constraint-respecting position immediately to the left or right of 𝑥ℎ or 𝑥ℎ⎯⎯⎯⎯⎯⎯. This can be confirmed by examining all possible cases, as is shown in Table 1. For clause (𝑎𝑘,𝑏𝑘,𝑐𝑘), Table 1 shows all possible not-all-equal truth assignments, and the corresponding relative orderings of 0 we can apply to the vertices that satisfy the Wheeler graph properties.

Table 1 Possible relative orderings of 𝑎𝑘, 𝑏𝑘, 𝑐𝑘, 𝑍𝑘, X subject to constraints (𝑎𝑘,𝑍𝑘,𝑏𝑘) and (𝑐𝑘,𝑋,𝑍𝑘)
Full size table
Table 2 Orderings implied by all-equal assignment
Full size table
In the other direction, assume G is a Wheeler graph so we have a proper ordering on the vertices of G. The proper ordering of the menorah structure is fixed with the exception of 𝑧𝑗𝑖 vertices, the ordering duplicated across layers 0,1,…. We will show that in a proper ordering of the vertices, the ordering given to 0 must have every clause in 𝜓 getting a not-all-equal assignment when we apply the following map: vertices for a non-negated literal on the left of X in 0 map back to a T assignment for that variable, and vertices for a non-negated literal to the right of X in 0 map back to an F assignment for that variable.

Suppose to the contrary that this mapping did not provide a valid not-all-equal assignment. Then 0 was given an ordering where the vertices for 𝑎𝑘,𝑏𝑘, and 𝑐𝑘 are all either on the left or the right side of X. The possible arrangements for this are presented in Table 2. In contrast to the cases listed in Table 1, for all cases listed in Table 2, placing 𝑍𝑘 between 𝑎𝑘 and 𝑏𝑘 violates the constraint (𝑐𝑘,𝑋,𝑍𝑘), which by our reduction implies it violates Wheeler graph Property 2 as well. This contradicts the assumption that we have a proper ordering on the vertices. We conclude that a proper ordering of the vertices of G must map back to a truth assignment that gives each clause in 𝜓 a not-all-equal assignment. ◻

This leaves open the complexity of the recognition problem for 3-NFAs and 4-NFAs.

Fig. 5
figure 5
(Top) A Wheeler graph with an alphabet of size three. (Middle) The same graph with edge orientations removed. (Bottom) Processing of edges with three queues. A Wheeler graph with an alphabet of size three is guaranteed to have queue number at most three. Note the undirected graph actually has queue number less than three, which can be seen by coloring the two green (dotted) edges red (solid) (Color figure online)

Full size image
Wheeler Graphs and Queue Number
Queue Number
The concept of queue number and queue layout were introduced by Heath and Rosenberg, originally for undirected graphs in [28], and later expanded to DAGs in [27]. We describe it first for DAGs. Let the vertices of a DAG G be given a total ordering that is also a topological ordering. We will say the edges of G can be processed using a set of queues if we can iterate through the vertices in the given ordering and every time the tail of an edge is encountered that edge is enqueued in one of the queues, and when the head of that same edge is encountered, that edge is then dequeued from its assigned queue. If we assign every edge a color according to its queue, this is equivalent to the ordering not creating any monochromatic rainbows like those in the left of Fig. 2. Over all possible orderings of the vertices, there is some ordering which requires the minimum number of queues to perform this processing. That minimum number of queues is called the queue number of G. For undirected graphs, when processing the edges we make an edge enqueued the first time either of the vertices it is incident to is encountered, and dequeued when the other vertex it is incident to is encountered. Again, the minimum number of queues required to do this over all possible vertex orderings is the queue number of the graph. Figure 5 provides an illustration of the edges of an undirected graph being processed in this way. The problem of detecting whether a graph is a one-queue DAG was shown to be solvable in linear time by Heath and Pemmaraju [26,27,28]. Using a few additional steps, we can extend their techniques to a specific subset of Wheeler graphs.

Theorem 3
The Wheeler graph recognition problem can be solved in linear time for an edge alphabet of size 𝜎=1 on graphs without self-loops.

Proof
When 𝜎=1 and the graph has no self-loops, any proper Wheeler ordering is a topological ordering. The problem of finding a one-queue ordering and a proper Wheeler ordering are almost equivalent. The only difference is that for a proper Wheeler ordering all of the vertices with in-degree zero must be placed first. To overcome this, we first let 𝑉0⊆𝑉 represent all vertices in V with in-degree zero. Create a new vertex u with in-degree zero and add an edge from u to each vertex in 𝑉0. Since a valid one-queue ordering is a topological ordering, 𝑣0 must be first in the one-queue ordering. Moreover, any vertices in the set 𝑉−𝑉0 must be in the one-queue ordering after the last position given to a vertex in 𝑉0, otherwise a rainbow is created. Thus, the above modification ensures that one-queue orderings on V place the vertices in 𝑉0 before any vertices in 𝑉−𝑉0, so these orders are also proper Wheeler orderings. ◻

We can use additional results on the queue number of undirected simple graphs to obtain an upper bound on the number of edges that can be in a Wheeler graph. The queue number of the underlying undirected graph of a Wheeler graph with alphabet size 𝜎, is at most 𝜎. This is since, when edge orientations are removed, the absence of monochromatic rainbows enforced by the properties of Wheeler graphs is exactly what is required for processing edges having the same color using a single queue. See Fig. 5. As a result, we get the bound presented in Theorem 4.

Theorem 4
The number of edges in a Wheeler graph is at most (2𝜎+1)𝑛−𝜎(2𝜎+1).

Proof
The number of edges in a undirected graph with queue number at most q is bound by 2𝑞𝑛−𝑞(2𝑞+1) [15]. By removing self edges and the edge orientations, the Wheeler graph becomes an undirected graph with queue number at most 𝜎. Finally, there are at most n additional edges added due to self-loops. ◻

An Exponential Time Algorithm
We can apply the encoding introduced by Gagie et al. [20] to develop exponential time algorithms to solve all of the problems presented in this paper. The idea is to enumerate over all possible encodings of Wheeler graphs with the proper number of vertices, edges, and labels, checking whether the encoding is isomorphic with the given graph. This idea exploits the fact that having such a space-efficient encoding also implies having a limited search space of Wheeler graphs, and that graph isomorphism can be checked in sub-exponential time. We have the following theorem.

Theorem 5
Recognizing whether 𝐺=(𝑉,𝐸) is a Wheeler graph can be done in time 2𝑒log𝜎+𝑂(𝑛+𝑒), where 𝑛=|𝑉|, 𝑒=|𝐸|, and 𝜎 is the size of the edge label alphabet.

Before describing the algorithm that proves Theorem 5, we need to describe the encoding of a Wheeler graph given in [20]. A Wheeler graph can be completely specified by three bit vectors; two bit vectors O and I both of length 𝑒+𝑛 and a bit vector L of length 𝑒log𝜎. We assume that the vertices of the Wheeler graph G are listed in a proper ordering 𝑥1<𝜋𝑥2<𝜋…<𝜋𝑥𝑛. The array O is of the form 0ℓ110ℓ21…0ℓ𝑛1 and I is of the form 0𝑘110𝑘21…0𝑘𝑛1. Here ℓ𝑖 is the out-degree of 𝑥𝑖, whereas 𝑘𝑖 is the in-degree of 𝑥𝑖. The array L indicates which character symbol is assigned to each edge. Specifically, the 𝑖𝑡ℎ character in L gives us the label of the edge corresponding to the 𝑖𝑡ℎ zero in O. All of these arrays are equipped with additional rank and select structures to allow for efficient traversal as is done in the FM-index [18]. In [20] an additional array that stores character counts is added. For our purposes however, the arrays O, I, and L are adequate.

figure a
Psuedocode for our algorithm is given in Algorithm 1. It essentially enumerates all bit vectors of a given length, checks whether or not the bit vector encodes a valid Wheeler graph, and if so, then checks whether the encoding matches our given graph G. Let S represent the set of all possible encodings we wish to check. Note that |𝑆|≤2𝑂(𝑒+𝑛)+𝑒log𝜎. The Wheeler graph corresponding to an encoding can be extracted by working from right to left reading the array I. For each zero in I, we know which symbol should be on the inbound edge going into the corresponding vertex. We only need to decide where the edge’s tail was. Let a be the edge label and j be the index of the label a in L that is furthest to the right in L and yet to be used. If no such j exists we reject the encoding. When assigning the tail for an edge, take as the tail the vertex 𝑥𝑖 where 𝑖=𝑟𝑎𝑛𝑘1(𝑂,𝑠𝑒𝑙𝑒𝑐𝑡0(𝑂,𝑗))+1. We call the graph constructed in this way 𝐺′.

We now wish to check whether 𝐺′ and G are the same graphs, only with a reordering of the vertices, that is, 𝐺′ is the result of applying an isomorphism to G. Unlike the typical isomorphism for labeled graphs, where a bijection between the symbols on the edge alphabet is all that is required, here we wish for the adjacency and the label on the edge to be preserved in the mapping between G and 𝐺′. Specifically, we wish to know if there exists a bijective function 𝑓:𝑉(𝐺)→𝑉(𝐺′), such that if 𝑢,𝑣∈𝑉(𝐺) are adjacent via an edge (u, v, a) with label a in G, then f(u) and f(v) are also adjacent via an edge (f(u), f(v), a) with label a in 𝐺′. Using ideas similar to those presented by Miller in [35], this problem can be reduced in polynomial time to checking whether two undirected graphs are isomorphic.

Lemma 5
The problem of checking whether the directed edge labeled graph 𝐺′ is edge-label-preserving isomorphic to G can be reduced in polynomial time to checking if two undirected graphs are isomorphic.

Proof
Define the transformation 𝛼 from the directed edge labeled graph G to an undirected graph 𝛼(𝐺) as follows: For every directed edge (u, v, a) replace it with the a-gadget in Fig. 6. We will show that there exists an edge-label-preserving isomorphism from V(G) to 𝑉(𝐺′) if and only if there exists a (standard) isomorphism between 𝛼(𝐺) and 𝛼(𝐺′).

We first assume that there exists an edge-label-preserving isomorphism f from V(G) to 𝑉(𝐺′). This implies that when 𝛼 is applied to 𝐺′ the same gadget is used to replace the edge (f(u), f(v), a) as the gadget used to replace the edge (u, v, a) in G. Therefore, the function f can be naturally extended to an isomorphism 𝑓̃  on the vertices of 𝛼(𝐺) providing an isomorphism between 𝛼(𝐺) and 𝛼(𝐺′).

Fig. 6
figure 6
An a-gadget replacing directed labeled edge (u, v, a)

Full size image
Now, consider the case where 𝑓̃  is an isomorphism between 𝛼(𝐺) and 𝛼(𝐺′). We wish to show that G and 𝐺′ must be related by an edge-label-preserving isomorphism. Let 𝑛′=|𝑉(𝛼(𝐺))|. We define a 𝑛′-tuple of numbers for each vertex 𝑣∈𝑉(𝛼(𝐺)) as 𝛽(𝑣)=(𝑐1,𝑐2,…,𝑐𝑛′) where 𝑐𝑖 is the number of vertices with graph distance i from v, i.e., minimum path length measured in edges. In Fig. 6, 𝛽(𝑥)=(1,1,…,1,2,…) where the leading 1’s are repeated 𝑎+1 times. Also, 𝛽(𝑦)=(1,1,…,1,2,…) where the leading 1’s are repeated 𝜎+1 times. For example, when 𝜎=1, we have 𝛽(𝑦)=(1,1,2,…). Notice first that 𝛽(𝑣)=𝛽(𝑓̃ (𝑣)), i.e., 𝛽(𝑣) is invariant under 𝑓̃ . Now observe that for any vertex 𝑢∈𝑉(𝐺) of degree d we have that 𝛽(𝛼(𝑢))=(𝑑,2𝑑,…) (where 𝛼(𝑢) denotes the vertex u is mapped onto when 𝛼 is applied to G). It follows that any vertex which is an x vertex of an a-gadget is mapped by 𝑓̃  onto an x vertex of an a-gadget. Similarly, any vertex which is a y vertex of an a-gadget is mapped by 𝑓̃  onto a y vertex of an a-gadget. Hence, a-gadgets are mapped by 𝑓̃  onto a-gadgets. This also implies that vertices in 𝑉(𝛼(𝐺)) originally in G are mapped by 𝑓̃  onto vertices in 𝑉(𝛼(𝐺′)) that were originally in 𝑉(𝐺′). If we restrict 𝑓̃  to only the vertices originally in V(G), then this restriction provides us with an edge-label-preserving isomorphism between G and 𝐺′. The reduction clearly takes polynomial time. ◻

The final step in this algorithm is to check whether 𝛼(𝐺) and 𝛼(𝐺′) are isomorphic. Using well established techniques, this can be done in time 2𝑛′√+𝑂(1) where 𝑛′ is the number of vertices in 𝛼(𝐺) [5]. The total time complexity of Algorithm 1 is the number of bit strings tested, multiplied by the time it takes to validate whether the bit string encodes a Wheeler graph 𝐺′ and decode it, convert G and 𝐺′ to undirected graphs 𝛼(𝐺) and 𝛼(𝐺′), and test whether 𝛼(𝐺) and 𝛼(𝐺′) are isomorphic. This yields an overall time complexity of |𝑆|𝑛𝑂(1)2𝑛+2𝑒(𝜎+1)√+𝑂(1), i.e., 2𝑒log𝜎+𝑂(𝑛+𝑒) for Algorithm 1.

Optimization Variants of Wheeler Graph Recognition
The Wheeler Graph Violation Problem is APX-Hard
In this section we show that obtaining an approximate solution to the WGV problem whose objective value comes within some constant factor of the optimal solution’s objective value is NP-hard. We do this through a reduction that shows that WGV is at least as hard as solving the Minimum Feedback Arc Set problem (FAS). FAS in its original formulation is phrased in terms of a directed graph where the objective is to find the minimum number of edges that need to be removed in order to make the directed graph a DAG. A slightly different formulation proves more useful for us. Letting 𝐹𝜋={(𝑣𝑖,𝑣𝑗)∈𝐸 ∣ 𝑣𝑗<𝜋𝑣𝑖}, we have the following:

Lemma 6
(Younger [39]) Determining a minimum feedback arc set for 𝐺=(𝑉,𝐸) is equivalent to finding an ordering <𝜋 on V for which |𝐹𝜋| is minimized.

From this, we can present an equivalent formulation of FAS.

Definition 3
(Minimum Feedback Arc Set (FAS)) The input is a set 𝑇={𝑡1,𝑡2,…,𝑡𝑛} of n numbers and a set of k inequalities of the form 𝑡𝑖<𝑡𝑗. This task is to compute an ordering <𝜋 on T such that the number of inequalities violated is minimized.

Interestingly, we could not have used FAS for proving that the Wheeler graph recognition problem is NP-complete, as FAS is fixed-parameter tractable in terms of the size of the feedback arc set [10]. Indeed, setting the size of the feedback arc-set to zero is equivalent to checking if the given graph is a DAG and the problem becomes solvable in linear time.

On the other hand, it has been shown that FAS is APX-hard, meaning that every problem in APX is reducible to it [31]. It also implies, assuming NP ≠ P, that there is a constant 𝐶≥1 such that there is no polynomial time algorithm which provides a C-approximation. The reduction provided in this section implies:

Theorem 6
The WGV problem is APX-hard.

In addition, Guruswami et al. demonstrated that assuming the Unique Games Conjecture holds, and NP ≠ P, there is no constant 𝐶≥1 such that a polynomial-time algorithm’s approximate solution to FAS is always a factor C from the optimal solution. We state this as a lemma.

Lemma 7
(Guruswami et al. [24]) Conditioned on the Unique Games Conjecture, for every 𝐶≥1, it is NP-hard to find a C-approximation to FAS.

An approximation preserving reduction from FAS to WGV, combined with Lemma 7, proves the other main result of this section:

Theorem 7
Conditioned on the Unique Games Conjecture, for every constant 𝐶≥1, it is NP-hard to find a C-approximation to WGV, implying WGV is not in APX.

The Reduction from FAS to WGV
Let 𝑇={𝑡1,𝑡2,…,𝑡𝑛} and inequalities 𝑡11<𝑡12,𝑡21<𝑡22,…,𝑡𝑘1<𝑡𝑘2 be the input to FAS. We define a heavy edge between the vertices u and v with label a as 𝑘+1 subdivided edges between u and v each with label a. That is, a heavy edge between u and v with label a consists of the edges (𝑢,𝑤𝑖,𝑎) and (𝑤𝑖,𝑣,𝑎) for 1≤𝑖≤𝑘+1. See Fig. 7 for an illustration. Heavy edges are useful to us, as a violation of Property 2 involving two heavy edges will require 𝑘+1 edges to be removed if the ordering is to be maintained. We use the following steps to create a graph (which is a DAG):

Create a vertex 𝑣0.

For 1≤𝑗≤2𝑘−1, 1≤𝑖≤𝑛+1, create vertex 𝑣𝑗𝑖.

For each inequality 𝑡𝑗1<𝑡𝑗2, create a vertex for both 𝑡𝑗1 and 𝑡𝑗2, labeled 𝑤𝑗1 and 𝑤𝑗2, respectively.

For 1≤𝑖≤𝑛+1, create heavy edges (𝑣0,𝑣1𝑖,1).

For 1≤𝑖≤𝑛+1,1≤𝑗≤2𝑘−2, create heavy edges (𝑣𝑗𝑖,𝑣𝑗+1𝑖,1).

Create heavy edge (𝑣0,𝑤11,2).

For 1≤𝑗≤2𝑘−1,

if j is odd, create the heavy edge (𝑣𝑗𝑛+1,𝑤𝑗+122,2),

if j is even, create the heavy edge (𝑣𝑗𝑛+1,𝑤𝑗2+11,2).

For 1≤𝑗≤2𝑘−1, 1≤𝑖≤𝑛,

if j is odd, create the regular (not heavy) edge:

(𝑣𝑗𝑖,𝑤𝑗+121,2) if 𝑡𝑖=𝑡𝑗+121,

(𝑣𝑗𝑖,𝑤𝑗+122,2) if 𝑡𝑖=𝑡𝑗+122.

Fig. 7
figure 7
A heavy(bold) edge in Fig. 8 is actually 𝑘+1 subdivided edges

Full size image
Fig. 8
figure 8
Reduction from FAS to WGV where 𝑇={1,2,3,4,5,6} and the inequalities are 5<3, 1<5, and 6<4

Full size image
An example of the reduction is given in Fig. 8. The intuition is that the vertices with an inbound heavy edge labeled 1 represent the permutation of the elements in T. The heavy edges labeled 1 force the permutation to be duplicated k times, once for each constraint. The vertices with the inbound edges labeled 2 represent the elements in each inequality. We will show that this is an approximation preserving reduction.

Let 𝐸′ be an optimal solution to WGV and 𝐺′=(𝑉,𝐸∖𝐸′). Let <𝜋 represent a proper ordering on the vertices of 𝐺′. Lemma 8 indicates that, other than permuting the ordering found on the vertices 𝑣𝑗𝑖 for 1≤𝑖≤𝑛 (with the ordering duplicated for 1≤𝑗≤2𝑘−1), the ordering for the vertices in Fig. 8 is fixed.

Lemma 8
Let 𝜙 represent a permutation of the set {1,2,…,𝑛+1}. Any ordering <𝜋 which provides a solution to the constructed instance of WGV with at most k edges violating the Wheeler graph properties orders the vertices in the form

𝑣0,𝑣1𝜙(1),𝑣1𝜙(2),…𝑣1𝜙(𝑛+1),…𝑣2𝑘−1𝜙(1),𝑣2𝑘−1𝜙(2),…𝑣2𝑘−1𝜙(𝑛+1),𝑤11,𝑤12,𝑤21,𝑤22,…𝑤𝑘1,𝑤𝑘2.
Proof
The ordering given from the statement of the lemma would require at most k edges to be removed to satisfy the Wheeler graph properties, so we know that |𝐸′|≤𝑘. If any of the w vertices is placed before a v vertex, that would cause at least 𝑘+1 edges to need to be removed, and is hence sub-optimal. Similarly, 𝑣0 must be placed first in the ordering.

Again by Lemma 1, if the v vertices are not ordered in the form

𝑣0,𝑣1𝜙(1),𝑣1𝜙(2),…,𝑣1𝜙(𝑛+1),…,𝑣2𝑘−1𝜙(1),𝑣2𝑘−1𝜙(2),…,𝑣2𝑘−1𝜙(𝑛+1),
this will cause a violation of Property 2. However, since these are now heavy edges, this will require at least 𝑘+1 edges to be removed in order to satisfy the Wheeler graph properties.

For the w vertices, the vertex 𝑤11 must be ordered before 𝑤12, else the heavy edges (𝑣0,𝑤11,2) and (𝑣1𝑛+1,𝑤12,2) would cause the removal of at least 𝑘+1 edges to be necessary. The vertex 𝑤12 must be ordered before 𝑤21, else the heavy edges (𝑣1𝑛+1,𝑤12,2) and (𝑣2𝑛+1,𝑤21,2) would cause the removal of at least 𝑘+1 edges to be necessary. This argument can be repeated until 𝑤𝑘1 and 𝑤𝑘2, proving that the ordering has the desired form. ◻

Let f(x) refer to the reduction described above applied to an instance x of FAS. Hence, f(x) is an instance of WGV. We also refer to the optimal solution to either of these problems as OPT(⋅), and the objective value (or cost) of a solution as 𝑣𝑎𝑙(⋅). For FAS, 𝑣𝑎𝑙(⋅) is the number of violated inequalities. For WGV, 𝑣𝑎𝑙(⋅) is the minimum number of edges that need to be removed to obtain a Wheeler graph when the ordering given by the solution is applied.

Lemma 9
Given an instance x of FAS, a solution 𝑦′ to the instance f(x) of WGV that has 𝑣𝑎𝑙(𝑦′)=ℓ≤𝑘 yields a solution to x with ℓ violated inequalities.

Proof
By Lemma 8, we can assume the ordering of the vertices given by 𝑦′ is of the form stated in Lemma 8, and is completely determined by the ordering given to 𝑣11,𝑣12,…,𝑣1𝑛,𝑣1𝑛+1. Ignore the vertex 𝑣1𝑛+1 and apply the remaining ordering to T. Any edge that has to be removed is one of the two edges in a pair (𝑣𝑗𝑖1,𝑤𝑗+121,2) and (𝑣𝑗𝑖2,𝑤𝑗+122,2), where 𝑡𝑖1=𝑡𝑗1 and 𝑡𝑖2=𝑡𝑗2 for a constraint (𝑡𝑗1,𝑡𝑗2). Since 𝑤𝑗1<𝜋𝑤𝑗2, this removal is only necessary if 𝑣𝑗𝑖2<𝜋𝑣𝑗𝑖1. Hence, if one these edges must be removed, it implies that in our solution to x, 𝑡𝑖2<𝑡𝑖1, and our solution does not satisfy the inequality 𝑡𝑗1<𝑡𝑗2. On the other hand, if Property 2 holds for the edges (𝑣𝑗𝑖1,𝑤𝑗+121,2) and (𝑣𝑗𝑖2,𝑤𝑗+122,2), then in our solution for x, 𝑡𝑖1<𝑡𝑖2, and the inequality 𝑡𝑗1<𝑡𝑗2 is satisfied. ◻

The next lemma is an immediate consequence of Lemma 9.

Lemma 10
Given an instance x of FAS, a C-approximation to the solution OPT(f(x)) yields a C-approximation to the solution OPT(x).

Theorem 6 follows from Lemma 10 and Theorem 7 follows from Lemmas 7 and 10.

The Wheeler Subgraph Problem is in APX
The dual problem to WGV is the problem of finding the largest subgraph of 𝐺=(𝑉,𝐸) which is a Wheeler graph. This problem (defined in Sect. 1.2) is called the Wheeler Subgraph problem, abbreviated WS. Unlike WGV, this problem yields a Θ(1)-approximate solution for constant 𝜎.

We first prove the result for 𝜎=1. We then apply this result to get an approximation for 𝜎>1. The proof for 𝜎=1 uses a branching of a directed graph. A branching is a set of arborescences, where an arborescence is a directed, rooted tree with all maximal paths starting at the root.

Lemma 11
There exists a linear time Θ(1)-approximation algorithm for WS when the alphabet size is 𝜎=1.

Proof
We consider G to be at least weakly connected. In the case where G is not weakly connected, the approximate solutions can be combined to obtain a solution for G with a Θ(1)-approximation factor. First, remove all singleton vertices (vertices with in-degree and out-degree zero), and let 𝑛′ be the number of remaining vertices. By doing this we know that the number of edges in the remaining graph is at least 𝑛′−1. Next, remove any edges that are self-loops. Let 𝐺′ denote the resulting graph and 𝑉+ denote the set of vertices with out-degree greater than zero in 𝐺′. There are two cases:

Case: |𝑉+|≤𝑛′/2: In this case, take a branching  such that each vertex with in-degree greater than zero is included in some arborescence whose root is in 𝑉+. This is always possible, as can be shown using induction on the number of vertices not in 𝑉+. In particular, if you take a vertex u not in 𝑉+, since there are no singleton vertices, u has in-degree greater than zero. Applying the inductive hypothesis to the graph 𝐺′−{𝑢}, you get that u has some edge from a vertex in 𝐺′−{𝑢}, which can be used to add u to an arborescence whose root is in 𝑉+. Let || denote the total number of arborescences in . Since |𝑉+|≤𝑛′/2, it follows that ||≤𝑛′/2 as well.

We create a planar leveling (𝐿0,𝐿1,…) of  by aligning all roots of the branching on level 𝐿0 in an arbitrary order. Then set 𝐿𝑖 to be all of the vertices that are distance i from some root in 𝐿0. Because these are trees, we can order the vertices within the levels in such a way that the leveling is planar. For our purposes, we say the levels increase from left to right. We claim that  is a Wheeler graph and that we can obtain a proper ordering <𝜋 for the vertices of  from this leveling. To obtain the proper ordering, start with 𝐿0 and read the order of the vertices on each level from the bottom to the top, then proceed right to the next level.

The number of edges in , denoted 𝑒(), is equal to 𝑛′−||. And since ||≤𝑛′/2, we have that 𝑒()≥𝑛′/2. At the same time, by Theorem 4, the optimal number of edges, denoted |𝐸∗| (including the 𝑂(𝑛′) self-loops we removed earlier) is 𝑂(𝑛′). Hence, the ratio of the optimal solution value over the branching solution value is bounded by a constant. In particular, |𝐸∗|/𝑒()≤𝑂(𝑛′)/(𝑛′/2)=𝑂(1). The construction of the branching, the planar leveling, and the extraction of <𝜋, can all be done in linear time.

Case |𝑉+|>𝑛′/2: Here we first select a vertex 𝑢∈𝑉+ and take an edge (u, v, 1) in 𝐺′ to be included in our solution. If u is no longer the tail of any unselected edges, remove u from 𝑉+. If 𝑣∈𝑉+, we remove from v from 𝑉+. We then continue taking vertices from 𝑉+ until it is empty. This creates a graph which is a collection of stars, and hence a Wheeler graph. Moreover, since every step adds an edge to our solution and removes at most two vertices from 𝑉+, the resulting graph has at least |𝑉+|/2>𝑛′/4 edges. This gives us a solution with an approximation ratio of |𝐸∗|/|𝑉+|<𝑂(𝑛′)/(𝑛′/4)=𝑂(1).

In both cases, we obtain an approximate solution with Θ(|𝐸∗|) edges. ◻

Next, we consider when 𝜎>1. Suppose 𝐺∗=(𝑉,𝐸∗) is the optimal solution for G. Then 𝐸∗=𝐸∗1∪𝐸∗2∪…∪𝐸∗𝜎 where 𝐸∗𝑎={(𝑢,𝑣,𝑎)∈𝐸∗}. Let 𝐺𝑎=(𝑉,𝐸𝑎) where 𝐸𝑎={(𝑢,𝑣,𝑎)∈𝐸} and let 𝐺′𝑎=(𝑉,𝐸′𝑎) be the optimal solution for 𝐺𝑎. Then, since |𝐸∗𝑎|≤|𝐸′𝑎| we have

|𝐸∗|=∑𝑎=1𝜎|𝐸∗𝑎|≤𝜎⋅max𝑎|𝐸∗𝑎|≤𝜎⋅max𝑎|𝐸′𝑎|.
Applying the result for 𝜎=1 (Lemma 11), we can approximate max𝑎|𝐸′𝑎| with a solution having 𝛼⋅max𝑎|𝐸′𝑎| edges for some constant 𝛼≤1. Since

𝛼𝜎|𝐸∗|≤𝛼max𝑎|𝐸′𝑎|≤max𝑎|𝐸′𝑎|≤|𝐸∗|,
the solution provides a Ω(1/𝜎)-approximation.

Theorem 8
There exists a linear time Ω(1/𝜎)-approximation algorithm for WS.

We close this section by noting that the algorithm presented in Sect. 4 also provides us with an exponential time solution to the two optimization problems considered here in Sect. 5. The solution is to iterate over all possible subsets of edges in E, take the corresponding induced subgraph, and apply Algorithm 1 to identify if the induced subgraph is isomorphic to a Wheeler graph. For both the WGV and WS problems, the optimal solution is the encoding with the fewest edges removed. The resulting time complexity is the same as in Theorem 5 with the addition of one e term in the exponent. We have shown the following:

Theorem 9
The WGV problem and WS problem for an input 𝐺=(𝑉,𝐸) with 𝑛=|𝑉|, 𝑒=|𝐸|, and 𝜎 the size of the edge label alphabet, can be solved in time 2𝑒log𝜎+𝑂(𝑛+𝑒).

A Class of Graphs with Linear Time Solution for Recognition
As mentioned earlier, it was shown by Alanko et al. [2] that there exists an algorithm that solves the recognition problem on 2-NFAs in linear time. Their algorithm works by reducing the recognition problem to a 2-SAT instance, which can then be efficiently solved. However, this approach fails to generalize for d-NFAs where 𝑑>2. Here we allow for arbitrary levels of non-determinism, but we place rather stringent conditions on the graphs so that our techniques will work. It is also important to note that the motivation of pattern matching on graphs is not particularly well suited for this class of graphs (one of the main motivations of the work of Alanko et al.). We will see that these graphs can be easily converted into equivalent (from the pattern matching perspective) DFAs, which are trees, and hence Wheeler graphs. Instead, we take the viewpoint that these are ordering problems, where the edges in conjunction with Properties 1 and 2 form constraints, and the vertices need to be ordered in a way as to satisfy these constraints. The below characteristics make this ordering problem solvable in polynomial time.

We let 𝑉0 denote the set of vertices with in-degree zero. We require that the graph G must have at least one vertex with in-degree zero, making 𝑉0 non-empty. We also insist that all vertices in G must be reachable from some vertex in 𝑉0. The following definitions describe the additional characteristics we require in order for our algorithm to work.

Definition 4
We consider a graph G to have full-spectrum-outputs if for every vertex v of out-degree greater than zero, every label appears on an edge leaving from v.

Definition 5
A graph G has the unique-string-traversal property if for every vertex v, all walks from 𝑉0 to v form the same string when the walk’s edge labels are concatenated.

Definition 6
A graph G is prefix-free if for every vertex v having out-degree zero, the string obtained by concatenating edge labels when traversing from 𝑉0 to v is not a proper prefix of any string obtained by concatenating edge labels on a walk from 𝑉0.

As a consequence of the unique-string-traversal property and all vertices being reachable from 𝑉0, the graph G must also be a DAG. Indeed, a cyclic graph would have a least one vertex v such that walks of different lengths start in 𝑉0 and end at v.

In Fig. 9 we see a simple example of two graphs that satisfy all of the stated conditions, however one is a Wheeler graph and the other is not. Furthermore, it can be seen from the reductions used in Sect. 2.2 that even when the input graphs satisfy the unique-string-traversal property and are prefix-free, the recognition problem remains NP-hard. We leave open whether the problem is NP-hard when restricted to instances that have full-spectrum-outputs and do not have the unique-string-traversal property and are not prefix-free.

Fig. 9
figure 9
On the left is an example of a small graph that has full-spectrum-outputs and the unique-string-traversal property, but is not a Wheeler graph. On the right is an example of a small graph that has all three properties and is a Wheeler graph

Full size image
Fig. 10
figure 10
Here p-nodes are represented by circles and q-nodes by rectangles. In this PQ-Tree the order on the leaves 1, 2, 3 can be reversed to 3, 2, 1, the leaves 4, 5, 6 can be permuted arbitrarily, and the order of the sets of leaves {1,2,3} and {4,5,6}, can be swapped

Full size image
The stated conditions make the recognition problem tractable through the use of techniques similar to those used to detect leveled-planar DAGs. Before presenting our solution, we introduce an essential data structure, and the process by which it is used to detect whether a DAG is leveled-planar.

PQ-Trees
PQ-trees were introduced by Booth and Lueker for the purpose of solving the consecutive ones problem [7] and have since found applications in a wide range of problems, including planarity detection, detecting interval graphs, and graph embedding [7, 11, 25, 30, 32]. PQ-trees represent a set of possible orderings of the leaves which are subject to certain constraints. These constraints specify that some subset of the leaves must be contiguous in the ordering. The trees are made up of three types of nodes, p-nodes, q-nodes, and leaves. The p-nodes allow for arbitrary permutations of their child nodes, whereas q-nodes only allow for the reversal of the ordering on their child nodes. The leaves represent the actual elements whose ordering we are interested in. See Fig. 10 for an example.

A universal PQ-tree is a p-node, v, where all of the leaves are v’s children. The 𝜖-tree, 𝑇𝜖 is a special tree which represents the empty set of orderings. We can take the intersection of two PQ-trees in time proportional to the sum of their two tree sizes [7]. The resulting PQ-tree represents the intersection of the orderings represented by each PQ-tree. Deletion of a leaf can be done in constant time.

Detecting Leveled-Planar DAGs
Detecting whether a DAG is leveled-planar is an important sub-step in determining whether a graph is a one-queue DAG [26, 27]. A DAG, 𝐺=(𝑉,𝐸), is leveled-planar if and only if it has a leveling (a partition of V into sets 𝑉1, 𝑉2,..., 𝑉ℓ where edges exists only from 𝑉𝑖 to 𝑉𝑖+1, 1≤𝑖≤ℓ−1), and there exists an ordering of vertices for each level that when combined provide a planar layout of G. An algorithm for determining if a DAG is leveled-planar is given in [27]. We describe the most relevant portions of this algorithm below.

The restrictions we place on our recognition problem allow for a simplified version of their algorithm that only works when every vertex is reachable from the first level of the leveling. We start with a leveling 𝑉1,..., 𝑉ℓ of G. The idea is to process the leveling from left-to-right. For 1≤𝑖≤ℓ, we will build a PQ-tree 𝑇𝑖 whose leaves represent the vertices in 𝑉𝑖. The PQ-tree 𝑇𝑖 captures all possible orderings of vertices in 𝑉𝑖 that still permit a leveled-planar layout of the subgraph induced by 𝑉1,..., 𝑉𝑖. To start, we make 𝑇1 the universal PQ-tree whose leaves represent the vertices in 𝑉1. For 𝑖>1, we construct the tree 𝑇𝑖 based on the PQ-tree 𝑇𝑖−1 and the edges between 𝑉𝑖−1 and 𝑉𝑖.

The key to being able to do this is the IDENTIFY operation, whose implementation can be found in [27]. The IDENTIFY operation takes four arguments: a PQ-tree T, two leaves x and y in T, and a new leaf z. IDENTIFY transforms T into a new PQ-tree, 𝑇′, that contains z and does not contain the leaves x and y. The PQ-tree 𝑇′ represents the subset of the permutations represented by T where x and y are adjacent. For these permutations the leaves are modified so that x and y are now a single leaf z. If no such permutations exist, 𝑇′ is made into the 𝜖-tree.

Equipped with the IDENTIFY operation, we can next describe how to obtain 𝑇𝑖 from 𝑇𝑖−1. The PQ-tree 𝑇𝑖 for level 𝑉𝑖 is obtained from the PQ-tree 𝑇𝑖−1 for level 𝑉𝑖−1 as follows: Start by making 𝑇𝑖 identical to 𝑇𝑖−1. For a vertex 𝑢∈𝑉𝑖−1, if u has no out neighbors then u is deleted. If a vertex 𝑢∈𝑉𝑖−1 has only a single neighbor 𝑣∈𝑉𝑖, then replace u with a new leaf v[u]. If u has out neighbors 𝑣1,..., 𝑣𝑖, then u is made into a p-node with children 𝑣1[𝑢],..., 𝑣𝑖[𝑢]. This is repeated for all 𝑢∈𝑉𝑖−1. Then for a fixed v, all nodes of the form 𝑣[⋅] are merged into a single node using the IDENTIFY operation. If at any point the 𝜖-tree is returned, we stop and declare that the graph is not leveled-planar. A technical detail is that the order in which this operation must be applied is governed by the ordering of the nodes in 𝑉𝑖 within the initial leveling. We refer the reader to [27] for details. Our algorithm for detecting Wheeler graphs under the stated restrictions will build on this algorithm. For convenience, we will call the combined steps that create 𝑇𝑖 from 𝑇𝑖−1 pushing.

Linear Time Solution
The basic approach to solving this problem is to use a depth-first search, treating sets of vertices as a single vertex. These vertex sets will have PQ-trees pushed across them in a similar fashion as was done in the solution described above. The situation is slightly more complicated here as we have multiple edge types. This results in a tree structure, rather than a path of vertex sets. We will label the vertices representing vertex sets with capital letters and label the PQ-tree for a vertex set 𝑊⊆𝑉 as 𝑇𝑊.

We split the algorithm into two parts. The first part is to create a tree where vertex sets play the role of vertices. It is a depth-first search using the edges between neighborhoods as connecting edges. The pseudocode is given in Algorithm 2. Let 𝑁𝑎(𝑊) denote the set of neighbors of the set W connected by an edge with label a. The function CREATEVERTEX takes a set of vertices and creates a new instance of a vertex class that can maintain pointers to its parent, children, internal vertices, and a string. Lemma 12 can be proven by applying induction to the number of edge labels, 𝜎.

figure b
Lemma 12
If the given graph G is a Wheeler graph, in a proper ordering, the vertex sets obtained as above are ordered by the lexicographical ordering of their strings.

An example of a tree obtained from Algorithm 2 is shown in Fig. 11. The vertex sets are disjoint due to the unique-string-traversal property. During Algorithm 2, we can identify if the graph satisfies the unique-string-traversal property by checking that every vertex in V gets included into exactly one vertex set. The prefix-free property can be easily checked as well.

Fig. 11
figure 11
On the right is the tree resulting from Algorithm 2 applied to the Wheeler graph shown on the left. For the graph on the left, red (solid) edges correspond to edges labeled 1, and blue (dashed) edges correspond to edges labeled 2. For the tree, an oval in the tree corresponds to a set of vertices in the Wheeler graph. The labels for these vertices are shown inside each oval. For each set of vertices inside an oval, the strings obtained by concatenating the edge labels on the path from the source is the same. These strings are shown to the side of each oval within the tree. In the tree, the edge colors indicated which type of edge was taken at each step along a path to that set

Full size image
Moving forward, the next portion of the algorithm is a recursive procedure that starts with the set of vertices having in-degree zero. Pseudocode is given in Algorithm 3. Letting 𝑉′ be the vertices processed prior to reaching W, we assume inductively that the PQ-tree 𝑇𝑊 represents all orderings of W such that if we fixed any one of these orderings there still exists a proper ordering of the vertices in 𝑉′. Then, after performing the first line of the for-loop, the PQ-tree 𝑇𝑊1 represents all orderings of 𝑊1 such that if we fixed any one of these orderings there still exists a proper ordering of the vertices in 𝑉′∪𝑊. After performing the second line in the for-loop, 𝑇𝑊1 now represents all orderings of 𝑊1 such that if we fixed any one of these orderings there still exists a proper ordering of the vertices in 𝑉′∪𝑊 and vertices that are descendants of 𝑊1. After completing the third line in the loop, 𝑇𝑊 represents all orderings of W such that if we fixed any one of them there still exists a proper ordering of the vertices in 𝑉′∪𝑊1 and any descendants of 𝑊1. We repeat this process for each of W’s children. When finally returned, 𝑇𝑊 represents all orderings of W such that there exists working orderings on 𝑉′ and all descendants of W. The pseudocode for the whole algorithm is given in Algorithm 4.

The full-spectrum-output and prefix-free conditions are necessary to apply this algorithm. We need that every vertex in W maps onto some vertex in each of W’s children. Thanks to these properties, when the PQ-tree 𝑇𝑊𝑖 gets pushed back from a child 𝑊𝑖 and the new PQ-tree 𝑇𝑊 is created, all the vertices in W are also leaves in 𝑇𝑊, and we can take the intersection with the previous PQ-tree for W.

figure c
figure d
Time Complexity: Each set of edges between two vertex sets has PQ-trees pushed across it twice. These pushes can be done in time proportional to the number of edges. In addition, all intersections can be done in time proportional to the number of vertices. As a result of these two facts, the overall algorithm can be performed in linear time. We have demonstrated the following:

Theorem 10
It can be determined in linear time if a directed, edge labeled graph that has full-spectrum-outputs, is prefix-free, and has the unique-string-traversal property, is a Wheeler graph.

Discussion and Open Problems
We have shown that recognizing Wheeler graphs is indeed a hard problem in general. We have also shown a special case where the recognition problem can be performed efficiently. The most important directions to expand this research appear to be in identifying more classes of graphs where this can be done in polynomial time. We can also ask for improvements on the algorithms presented here. Specifically, we ask:

Is the Wheeler graph recognition problem NP-complete for 3-NFA and 4-NFA?

For which other classes of graphs can Wheeler graph recognition be done efficiently?

Is there a fixed-parameter-tractable exponential time algorithm for any of the hard problems given in this paper?

Can we provide a better approximation algorithm for the optimization variants?

Constructive answers to these questions will contribute to our knowledge on finding vertex orderings “close” to that required for a Wheeler graph. It will aid in our ability to apply BWT based indices to various structures, as well as our ability to find useful compressible subgraphs.