Computing shortest paths in networks that exhibit a time-dependent metric is a core routine for many applications, with route planning in road networks being a prime example. In this work, we present an axiomatic approach which shows that for directed networks that satisfy certain properties we can provide time-dependent distance oracles that provably exhibit subquadratic preprocessing time and space (independent of the metricâ€™s amount of disconcavity), query time sublinear on the network size or the actual Dijkstra rank of the query at hand (measuring the distance ordering of the destination from the origin), and small stretch factor (approximation error).

Access provided by University of Auckland Library

Introduction
Contemporary technological infrastructures (e.g., road networks, social networks, e-commerce platforms, energy-management systems) are typically of very large scale and impose as a routine task the computation of min-cost paths in real-time, while their characteristics usually evolve with time. The large-scale and real-time response challenges have been addressed in the last 20 years by means of a new algorithmic trend: the provision of oracles. That is, data structures created by appropriately selecting precomputed information (summaries) and which subsequently support query algorithms with real-time responses. The quality of an oracle is assessed by its preprocessing space and time requirements, the time-complexity of the query algorithm and the approximation guarantee (stretch). Numerous oracles have been proposed and analyzed (see e.g., [1, 22, 23, 26,27,28, 31, 32] and references therein) for large-scale, mostly undirected networks, accompanied by a static arc-cost metric. In tandem with oracles, an equally important effort (with similar characteristics) has also emerged in the last 20 years under the tag of speedup techniques for approaches tailored to work extremely well in real-life instances (see e.g., [3] and references therein).

The temporality of the network characteristics is often depicted by some kind of predetermined dependence of the metric on the actual time that each resource is used (e.g., traversal time of individual segments in road networks, packet-loss rate in IT networks, arc availability in social networks, etc). Perhaps the most typical application scenario, motivating also our work, is route planning in road networks, where the time for traversing an arc ğ‘=ğ‘¢ğ‘£ (modeling a road segment) depends on the temporal traffic conditions while traversing it, and thus on the departure time from its tail u. This gives rise to time-varying network models and to computing min-cost (a.k.a. shortest) paths in such networks. Several variants of this model try to capture time-variation of the underlying graph structure and/or the arc-cost metric, e.g., dynamic shortest paths, parametric shortest paths, stochastic shortest paths, temporal networks, etc; see [17] for a discussion on these variants and their comparison.

In this work, we consider the case in which the cost variation of each arc a is determined by a function D[a], which is considered to be a continuous, piecewise linear (pwl) and periodic functionFootnote1 of the time at which the resource is actually being used [7, 8, 13, 21]. When providing route plans in such so-called time-dependent road networks, arc-cost values are determined by evaluating arc-travel-time functions, while time-dependent shortest paths are construed as minimum-travel-time paths. The goal is then to determine the cost (minimum-travel-time) of an optimal path from an origin o to a destination d, as a function of the departure-time ğ‘¡ğ‘œ from o. Due to the time-dependence of the arc-cost metric, the actual arc-cost value of each arc ğ‘=ğ‘¢ğ‘£ can be computed only for specific departure-times from u, e.g., for the earliest presence-time ğ‘¡ğ‘¢â‰¥ğ‘¡ğ‘œ at u, which is the earliest possible time that uv may start being traversed by a commuter originating from (ğ‘œ,ğ‘¡ğ‘œ).

Problem Statements and Related Work
Two variants of the time-dependent shortest path problem have been considered in the literature:

ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ) (resp. ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,â‹†,ğ‘¡ğ‘œ)) focuses on the one-to-one (resp. one-to-all) determination of the scalar cost of a minimum-travel-time (shortest) path to the destination d (resp. for all d), when departing from the origin o at time ğ‘¡ğ‘œ.

TDSP(o, d) (resp., ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,â‹†)) focuses on the one-to-one (resp., one-to-all) succinct representation of the time-dependent minimum-travel-time function(s) D[o, d] from o to d (resp. towards all reachable d), and all departure-times from o.

Tractability of TDSP Problems
ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ) has been studied as early as [5]. The first work concerning ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ) with continuous departure-times axis was [11] where it was proved that, if waiting-at-nodes is allowed unconditionally, then ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ) is solvable in quasilinear time via a time-dependent variant of Dijkstraâ€™s algorithm (we call it ğšƒğ™³ğ™³, for Time-Dependent Dijkstra), which relaxes arcs by computing the arc costs â€œon the flyâ€, upon settling their tails. A more complete treatment for the continuous case, considering various limitations in the waiting-times at the nodes of the network, was provided in [14]; an algorithm was also given for ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ), whose complexity cannot be bounded by a function of the network topology. An excellent overview of the problem is provided in [21]. Among other results, it was proved that for affine arc-cost functions possessing the FIFO property (according to which all the arc-cost functions have slopes at least âˆ’1), in addition to ğšƒğ™³ğ™³, a time-dependent variant of the label-correcting Bellman-Ford algorithm works. Moreover, if waiting-at-nodes is forbidden and the arc-costs do not preserve the FIFO property, then subpath-optimality of shortest paths is not necessarily preserved. In such a case, many variants of the problem are also ğğ-hard [25]. Additionally, when shortest path costs are well defined and optimal waiting-times at nodes always exist, a non-FIFO arc with unrestricted-waiting-at-tail policy is equivalent to a FIFO arc in which waiting at the tail is not beneficial [21]. For all these reasons, we focus in this work on instances for which the FIFO property holds, as indeed is the case with most of past and recent work on ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ); see e.g., [7, 8, 13, 15,16,17, 20].

The complexity of TDSP(o, d) was first questioned in [6, 7] and remained open until recently, when it was proved in [13] that, in case of FIFO-abiding pwl arc-cost functions, for a single origin-destination pair (o, d) the space complexity for succinctly representing D[o, d] is (1+ğ¾)â‹…ğ‘›ğ›©(logğ‘›), where n is the number of vertices and K is the total number of breakpoints (or legs) of all the arc-cost functions. Note that K can be substituted by the number ğ¾âˆ— (ğ¾âˆ—â‰¤ğ¾) of concavity-spoiling breakpoints (at which the arc-cost slopes increase) of the arc-cost functions [17, Section 3]. Several output-sensitive algorithms for the exact computation of D[o, d] have been presented in [7, 8, 13, 21], the most efficient ones being those in [8, 13].

Polynomial-Time Approximation Algorithms
Due to the above mentioned hardness of TDSP(o, d), and also since the time-dependent arc-costs are typically only (e.g., pwl) approximations of the actual costs, it is quite natural to seek for succinct representations of approximations to D[o, d], which aim at trading-off accuracy for computational effort. Several polynomial-time one-to-one (i.e., for a given (o, d) pair), (1+ğœ€)-approximation algorithms for TDSP(o, d) have recently appeared in the literature [8, 13, 20]. The algorithm proposed in [8] requires

îˆ»(1ğœ€â‹…(ğ·max[ğ‘œ,ğ‘‘]âˆ’ğ·min[ğ‘œ,ğ‘‘]))
calls of ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘‘,ğ‘œ,ğ‘¡ğ‘‘) in the reverse instance,Footnote2 for producing a (1+ğœ€)-upper-approximating function ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘] of the min-travel-time function D[o, d], where ğ·max[ğ‘œ,ğ‘‘]=maxğ‘¡âˆˆ[0,ğ‘‡)ğ·[ğ‘œ,ğ‘‘](ğ‘¡), ğ·min[ğ‘œ,ğ‘‘]=minğ‘¡âˆˆ[0,ğ‘‡)ğ·[ğ‘œ,ğ‘‘](ğ‘¡), and T is the time period. Another one-to-one (1+ğœ€)âˆ’approximation algorithm was provided in [13]. That algorithm makes

îˆ»(ğ¾ğœ€log(ğ·max[ğ‘œ,ğ‘‘]ğ·min[ğ‘œ,ğ‘‘])â‹…log(ğ‘‡ğ¾ğœ€ğ·min[ğ‘œ,ğ‘‘]))
calls to ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ). Two further one-to-one (1+ğœ€)-approximation algorithms for D[o, d] were given in [20]. The first algorithm requires

îˆ»(ğ¾ğœ€â‹…[log(ğ·max[ğ‘œ,ğ‘‘]ğ·min[ğ‘œ,ğ‘‘])+log(ğ‘‡ğ¾ğ·min[ğ‘œ,ğ‘‘])])
and the second algorithm requires

îˆ»(ğ¾â‹…[1ğœ€log(ğ·max[ğ‘œ,ğ‘‘]ğ·min[ğ‘œ,ğ‘‘])+log(ğ¿ğ¾ğœ€ğ·min[ğ‘œ,ğ‘‘])])
calls to ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ).

The first one-to-all (1+ğœ€)-approximation algorithm for ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,â‹†), called the bisection (ğ™±ğ™¸ğš‚) method, was given in [17]. It is based on bisecting the (common to all functions) axis of departure-times from o and considers slightly stricter assumptions than just the FIFO property for the arc-cost metric. ğ™±ğ™¸ğš‚ requires

îˆ»(ğ¾âˆ—log(1/ğœ€)ğœ€â‹…log2(ğ‘›))
calls to ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,â‹†,ğ‘¡ğ‘œ) to approximate the one-to-all problem ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,â‹†). In the worst-case, this is a comparable amount of ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,â‹†,ğ‘¡ğ‘œ) calls to those required by all known [8, 13, 20] (and aforementioned) one-to-one approximation algorithms, which solve just the TDSP(o, d) (single-pair) case.

Oracles for Time-Dependent Networks
Minimum-travel-time oracles for time-dependent networksâ€”from now on being referred to as TD-oraclesâ€”had received no attention until recently [17].

A TD-oracle consists of an offline-precomputed data structure, which consequently allows the real-time evaluation of an upper-approximation ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ) (summary) of the unknown function ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ), for any possible query (ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ)âˆˆğ‘‰Ã—ğ‘‰Ã—â„â‰¥0 that may appear in an online fashion. The maximum value of the ratio ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)/ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ) is referred to as stretch factor or approximation guarantee.

One trivial oracle would be to precompute a succinct representation of ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘] for each origin-destination pair (ğ‘œ,ğ‘‘)âˆˆğ‘‰Ã—ğ‘‰, for the sake of rapid evaluations in the future, but at the expense of superquadratic space.

Another trivial oracle would be to precompute nothing and just execute ğšƒğ™³ğ™³ â€œon-the-flyâ€ for each new query (ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ), at the expense of superlinear query-time.

A non-trivial TD-oracle should thus aim to trade-off smoothly preprocessing requirements with query-response times and stretch factors. In particular, it should precompute a data structure in subquadratic time and space, provide a query algorithm which evaluates efficiently (i.e., much faster than ğšƒğ™³ğ™³) ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ), and provide a provably good approximation guarantee for ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘]. Note that there exists important applied work (speedup heuristics) for computing approximately optimal routes in time-dependent road networks (e.g., [4, 9, 10, 19]), which however provide mainly empirical evidence on the success of the adopted approaches.

The first non-trivial TD-oracles were provided in [17]. Their high-level construction works as follows: a subset of vertices (landmarks) is selected uniformly at random and subsequently upper-approximations of the minimum travel-time functions (called travel-time summaries) from any landmark to all other vertices were computed, using the ğ™±ğ™¸ğš‚ one-to-many approximation algorithm. Two query algorithms, ğ™µğ™²ğ™° (simple) and ğšğš€ğ™° (recursive), exploit these preprocessed travel-time summaries in order to answer any possible online query, by executing proper calls of ğšƒğ™³ğ™³ from the origin up to the closest landmarks, and then complementing the travel-time information with the preprocessed data. Under certain conditions (cf. Sect. 4), those TD-oracles required îˆ»(ğ‘›2âˆ’ğ›½(ğ¾âˆ—+1)) preprocessing space and time, for some constant ğ›½âˆˆ(0,1), and are able to answer queries in time îˆ»(ğ‘›ğ›¿), for some constant ğ›¿âˆˆ(0,1). When ğ¾âˆ—âˆˆo(ğ‘›), the oracles can be fine-tuned so as to assure sublinear query-times, small stretch factor, and subquadratic preprocessing requirements in n. An extensive experimental evaluation of those oracles on a real-world road network was provided in [15], demonstrating their practicality, at the expense, however, of large memory consumption due to the linear dependence of the preprocessing requirements on ğ¾âˆ—, which can be ğ›º(ğ‘›).

Challenge and Our Contributions
The main challenge addressed in this work is to provide TD-oracles that achieve:

Subquadratic preprocessing requirements, independent of ğ¾âˆ—.

Query algorithms delivering arrival times with small stretch factor (smaller than 2) for any possible (ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ)âˆˆğ‘‰Ã—ğ‘‰Ã—â„â‰¥0 query.

Query-times sublinear, not only in the worst-case (i.e., in n), but also in the number ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ) of settled vertices when executing ğšƒğ™³ğ™³(ğ‘œ,â‹†,ğ‘¡ğ‘œ) (i.e., ğšƒğ™³ğ™³ for solving ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,â‹†,ğ‘¡ğ‘œ)) until d is settled, known as the Dijkstra-rankFootnote3 of that query.

We provide an axiomatic approach to address positively the aforementioned challenge. Our approach is axiomatic in the sense that: (a) we define certain properties which the underlying time-dependent network should satisfy; (b) we carry out an experimental analysis on real-world networks stemming from our prime application scenario (road networks), which shows that these networks indeed satisfy these properties; and (c) we provide new TD-oracles and perform a theoretical analysis on their performance on the class of networks satisfying these properties.

At a high-level, the construction of our new TD-oracles resemble those in [17]. However, to avoid the dependence on ğ¾âˆ—, a new approximation method for preprocessing travel-time summaries (other than ğ™±ğ™¸ğš‚) is required. Moreover, the requirement for achieving sublinear query time not only on network size, but also on the Dijkstra-rank, requires a different (hierarchical) approach than the (flat) approaches in [17], for constructing the sought TD-oracles and for answering queries. In particular, our specific contributions are as follows. We provide:

(i)
A novel and remarkably simple algorithm, called ğšƒğšğ™°ğ™¿ (cf. Sect. 5), for constructing one-to-many (1+ğœ€)-upper-approximations ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘] (summaries) of minimum-travel-time functions D[o, d], for all â€œsufficiently distantâ€ destinations d from the origin o. The ğšƒğšğ™°ğ™¿ algorithm requires o(ğ‘›) calls to ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,â‹†,ğ‘¡ğ‘œ), which is independent of the degree of disconcavity ğ¾âˆ—. Its novelty is that it does not require the concavity of the unknown function to approximate.

(ii)
Two new TD-oracles, ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ and ğ™µğ™»ğ™°ğšƒ (cf. Sect. 7). ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ exploits ğšƒğšğ™°ğ™¿, while ğ™µğ™»ğ™°ğšƒ exploits a proper combination of both ğšƒğšğ™°ğ™¿ and ğ™±ğ™¸ğš‚, to construct minimum-travel-time summaries from randomly selected landmarks towards all reachable destinations. The preprocessed data structures of both TD-oracles require subquadratic space and time, independent of ğ¾âˆ—. The query algorithms of both ğ™µğ™»ğ™°ğšƒ and ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ are based on proper extensions of the ğšğš€ğ™° algorithm [17], in order to recover missing summaries for local neighborhoods around a landmark. In both cases sublinear query-times are achieved.

(iii)
A new hierarchical TD-oracle, called ğ™·ğ™¾ğšğ™½ (cf. Sect. 8). ğ™·ğ™¾ğšğ™½ sets up a hierarchy of landmarks, from many local landmarks possessing summaries only for small neighborhoods of destinations around them, up to a few global landmarks possessing summaries for all reachable destinations. ğ™·ğ™¾ğšğ™½â€™s preprocessing requirements are again subquadratic. We then devise and analyze a novel query algorithm (ğ™·ğš€ğ™°) which exploits this hierarchy and achieves a query-time sublinear in the Dijkstra-rank of the query at hand.

Except for the choice of landmarks, our algorithms are deterministic. The stretch factor of all query algorithms is 1+ğœ, where ğœâˆˆ(ğœ€,1) depends on the preprocessing approximation factor ğœ€ and the network properties. Table 1 summarizes the bounds of the TD-oracles presented here and their comparison with the oracles in [17].

Table 1 Bounds of new oracles for TD-instances, as functions of the parameters ğ›¼,ğ›½,ğ›¿âˆˆ(0,1)
Full size table
A recent experimental study [16] demonstrates the excellent performance of our oracles in practice, achieving considerable memory savings and query times about three orders of magnitude faster than ğšƒğ™³ğ™³, and more than 70% faster than those in [15]. Preliminary parts of this work appeared in [18].

Preliminaries
A time-dependent network instance, or TD-instance henceforth, consists of a directed graph ğº=(ğ‘‰,ğ´) with |ğ‘‰|=ğ‘› vertices and |ğ´|=ğ‘š arcs. As is typical for shortest-path computations, we focus on strongly-connected graphs. Queries for non-strongly-connected instances could then be answered by separate calls to algorithms for strongly-connected components which lie on the way from the originâ€™s towards the destinationâ€™s components.

Each arc ğ‘âˆˆğ´ is accompanied with a continuous, pwl arc-cost function ğ·[ğ‘]:â„â‰¥0â†¦â„>0. We assume that all these functions are periodic with period ğ‘‡>0 and are defined as follows: âˆ€ğ‘˜âˆˆâ„•,âˆ€ğ‘¡âˆˆ[0,ğ‘‡), ğ·[ğ‘](ğ‘˜ğ‘‡+ğ‘¡)=ğ‘‘[ğ‘](ğ‘¡), where ğ‘‘[ğ‘]:[0,ğ‘‡)â†’[ ğ·â¯â¯â¯[ğ‘] , ğ·â¯â¯â¯â¯â¯[ğ‘] ] is such that limğ‘¡â†‘ğ‘‡ğ‘‘[ğ‘](ğ‘¡)=ğ‘‘[ğ‘](0), for some fixed integers 0<ğ·â¯â¯â¯[ğ‘]â‰¤ğ·â¯â¯â¯â¯â¯[ğ‘]. ğ·â¯â¯â¯[ğ‘] and ğ·â¯â¯â¯â¯â¯[ğ‘] denote the minimum (i.e., free-flow) and maximum (i.e., full-congestion) traversal-times ever seen for arc a.

Since D[a] is periodic, continuous and pwl function, it can be represented succinctly by a sequence of ğ¾ğ‘ breakpoints (i.e., pairs of departure-times and arc-cost values) defining d[a]. Let ğ¾=âˆ‘ğ‘âˆˆğ´ğ¾ğ‘ be the number of breakpoints representing all arc-cost functions, ğ¾max=maxğ‘âˆˆğ´ğ¾ğ‘, and let ğ¾âˆ— be the number of concavity-spoiling breakpoints (the ones at which the arc-cost function slopes increase). Clearly, ğ¾âˆ—â‰¤ğ¾, and ğ¾âˆ—=0 for concave arc-cost functions. It is assumed in this work that the traversal-time function d[a] of each arc ğ‘âˆˆğ´ requires a small (e.g., sublinear) number of breakpoints: ğ¾ğ‘âˆˆo(ğ‘›). This is justified by real-world scenarios, where these breakpoints are periodically sampled traversal-times within the period [0, T), which are mainly collected via crowd-sourced information provided automatically (e.g., per minute) by the commuters. In other words, we anticipate ğ¾ğ‘âˆˆîˆ»(ğ‘‡) breakpoints per arc, or ğ¾âˆˆîˆ»(ğ‘šâ‹…ğ‘‡) breakpoints in overall for the entire graph. Under certain conditions (sparsity and scaling) that will be explained later in this section, the required space to store the instance would remain subquadratic in the graph size. Moreover, the two extreme traversal times ğ·â¯â¯â¯[ğ‘] (for the free-flow metric) and ğ·â¯â¯â¯â¯â¯[ğ‘] (for the full-congestion metric) are also assumed to be part of the input. For example, during the preprocessing we determine and store them along with the representation of each d[a] as a collection of breakpoints. This is done only once per arc, so that we have the entire (static) free-flow and full-congestion metrics at our disposal. Since each arc only has at most ğ¾maxâˆˆîˆ»(ğ‘‡) breakpoints (0<ğ›¼<1), we need in total an amount of îˆ»(ğ‘šâ‹…ğ‘‡) operations and îˆ»(ğ‘š) space, to determine and store these extreme traversal-times, for all the arcs in the network.

To ease the exposition and also for the sake of compliance with terminology in previous works (inspired by the primary application scenario of route planning in time-dependent road networks), we consider arc-costs as arc-travel-times and time-dependent shortest paths as minimum-travel-time paths. This terminology facilitates the following definitions.

The arc-arrival-time function of an arc ğ‘¢ğ‘£âˆˆğ´ is ğ´ğ‘Ÿğ‘Ÿ[ğ‘¢ğ‘£](ğ‘¡ğ‘¢)=ğ‘¡ğ‘¢+ğ·[ğ‘¢ğ‘£](ğ‘¡ğ‘¢), âˆ€ğ‘¡âˆˆ[0,âˆ), i.e., it provides the actual arrival-time at v, depending on the departure-time ğ‘¡ğ‘¢ from u. In this work we focus on time-dependent instances abiding with the strict-FIFO property, i.e., for which all the arc-arrival-time functions Arr[uv] are strictly increasing. Equivalently, all the arc-travel-time functions D[uv] have slope strictly larger than âˆ’1. We can also express the arc-travel-time function D[uv] of an arc uv as a function of the arrival-time ğ‘¡ğ‘£=ğ‘¡ğ‘¢+ğ·[ğ‘¢ğ‘£](ğ‘¡ğ‘¢) at the head v. This is particularly useful when we need to work with the reverse TD-instance (ğºâƒ– =(ğ‘‰,ğ´,(ğ·âƒ– [ğ‘])ğ‘âˆˆğ´), where ğ·âƒ– [ğ‘¢ğ‘£](ğ‘¡ğ‘£)=ğ‘¡ğ‘£âˆ’ğ‘¡ğ‘¢ is the time for traversing uv, measured now as a function of the arrival-time ğ‘¡ğ‘£ at v. In ğºâƒ– , we traverse an arc ğ‘¢ğ‘£âˆˆğ´ backwards in time (there is no need to actually reverse the direction of a), that is, from (ğ‘£,ğ‘¡ğ‘£) we move back to to (ğ‘¢,ğ‘¡ğ‘¢), by setting ğ‘¡ğ‘¢=ğ‘¡ğ‘£âˆ’ğ·âƒ– [ğ‘¢ğ‘£](ğ‘¡ğ‘£). The reverse TD-instance is used when we seek, starting from (ğ‘‘,ğ‘¡ğ‘‘), a minimum-travel-time od-path of latest-departure ğ‘¡ğ‘œ from o such that we can be at d by time ğ‘¡ğ‘‘.

The path-arrival-time function of a path ğ‘=âŸ¨ğ‘1,â€¦,ğ‘ğ‘˜âŸ© in G is the composition ğ´ğ‘Ÿğ‘Ÿ[ğ‘](ğ‘¡)=ğ´ğ‘Ÿğ‘Ÿ[ğ‘ğ‘˜](ğ´ğ‘Ÿğ‘Ÿ[ğ‘ğ‘˜âˆ’1](â‹¯(ğ´ğ‘Ÿğ‘Ÿ[ğ‘1](ğ‘¡))â‹¯)) of the arc-arrival-time functions of its constituent arcs ğ‘1,â€¦,ğ‘ğ‘˜. The path-travel-time function is then ğ·[ğ‘](ğ‘¡)=ğ´ğ‘Ÿğ‘Ÿ[ğ‘](ğ‘¡)âˆ’ğ‘¡.

For any (ğ‘œ,ğ‘‘)âˆˆğ‘‰Ã—ğ‘‰, let îˆ¼ğ‘œ,ğ‘‘ denote the set of od-paths. For any ğ‘âˆˆîˆ¼ğ‘œ,ğ‘¥ and ğ‘âˆˆîˆ¼ğ‘¥,ğ‘‘, the path ğ‘ =ğ‘âˆ™ğ‘âˆˆîˆ¼ğ‘œ,ğ‘‘ is the concatenation of p and q at x. The earliest-arrival-time function is defined as ğ´ğ‘Ÿğ‘Ÿ[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)=minğ‘âˆˆîˆ¼ğ‘œ,ğ‘‘{ğ´ğ‘Ÿğ‘Ÿ[ğ‘](ğ‘¡ğ‘œ)}, âˆ€ğ‘¡ğ‘œâ‰¥0, while the minimum-travel-time ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)=minğ‘âˆˆîˆ¼ğ‘œ,ğ‘‘{ğ·[ğ‘](ğ‘¡ğ‘œ)}=ğ´ğ‘Ÿğ‘Ÿ[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)âˆ’ğ‘¡ğ‘œ. Observe that, when the FIFO property is not fulfilled, the above mentioned definition may not refer to pure travel-times, as it may possibly contain waiting times at the origin and/or intermediate vertices. As previously mentioned, the present work focuses on FIFO-abiding TD-instances, for which it is the case that ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ) is indeed the actual travel-time along some od-path with no waits, since it never pays-off to wait in those instances.

For a query (ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ), ğ‘†ğ‘ƒ[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)={ğ‘âˆˆğ‘ƒğ‘œ,ğ‘‘:ğ´ğ‘Ÿğ‘Ÿ[ğ‘](ğ‘¡ğ‘œ)=ğ´ğ‘Ÿğ‘Ÿ[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)} denotes the set of earliest-arrival-time (equivalently, minimum-travel-time, for FIFO TD-instances) paths, and ğ´ğ‘†ğ‘ƒ[ğ‘œ,ğ‘‘;ğœ€](ğ‘¡ğ‘œ)={ğ‘âˆˆğ‘ƒğ‘œ,ğ‘‘:ğ·[ğ‘](ğ‘¡ğ‘œ)â‰¤(1+ğœ€)â‹…ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)} denotes the set of od-paths whose travel-time values are (1+ğœ€)-approximations of the minimum-travel-time among all od-paths.

When we say that we â€œgrow a ğšƒğ™³ğ™³ ball from (ğ‘œ,ğ‘¡ğ‘œ)â€, or â€œcentered at (ğ‘œ,ğ‘¡ğ‘œ)â€, we refer to the execution of ğšƒğ™³ğ™³ for discovering time-dependent shortest paths from ğ‘œâˆˆğ‘‰ for departure time ğ‘¡ğ‘œâˆˆ[0,ğ‘‡), i.e., solutions to the problem ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,â‹†,ğ‘¡ğ‘œ) (resp. to ğ‘‡ğ·ğ‘†ğ‘ƒ(ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ), for a specific destination d). Such a call, which we denote as ğšƒğ™³ğ™³(ğ‘œ,â‹†,ğ‘¡ğ‘œ) (resp. ğšƒğ™³ğ™³(ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ)), takes time:

îˆ»(ğ‘šâ‹…maxğ‘âˆˆğ´{ğ¸ğ‘£ğ‘ğ‘™(ğ·[ğ‘])}+ğ‘›log(ğ‘›))=îˆ»(ğ‘šloglog(ğ¾max)+ğ‘›log(ğ‘›))
where Eval(D[a]) is the worst-case cost for evaluating the arc-travel-time function D[a]. It is noted that, since D[a] is periodic, continuous and pwl, Eval(D[a]) can be implemented either in time îˆ»(log(ğ¾ğ‘)) by a binary search among the ğ¾ğ‘ breakpoints describing the function for identifying the right leg of D[a] in which the departure time lies, or even in time îˆ»(loglog(ğ¾ğ‘)), while still requiring space îˆ»(ğ¾), by using more advanced predecessor-search data structures like the van Emde Boas trees [29, 30].

Apart from the travel-time metric for measuring distances of destinations from the origin, another metric is also implicitly considered when using Dijkstra-like algorithms (e.g., ğšƒğ™³ğ™³) for serving a query (ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ), called the Dijkstra-rank ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ), which is the number of settled vertices up to d, when executing ğšƒğ™³ğ™³(ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ). This is an important metric because the performance of Dijkstra-like algorithms is quasi-linear, not only in the network size, but indeed in the actual Dijkstra-rank of the query at hand.

Returning to the travel-time metric, for each ğ‘=ğ‘¢ğ‘£âˆˆğ´ and [ğ‘¡ğ‘ ,ğ‘¡ğ‘“)âŠ†[0,ğ‘‡), we define upper- and lower-bounding travel-time metrics. In particular, the minimally-congested travel-time is

ğ·â¯â¯â¯[ğ‘¢ğ‘£](ğ‘¡ğ‘ ,ğ‘¡ğ‘“)=infğ‘¡ğ‘¢âˆˆ[ğ‘¡ğ‘ ,ğ‘¡ğ‘“){ğ·[ğ‘¢ğ‘£](ğ‘¡ğ‘¢)}
and the maximally-congested travel-time is

ğ·â¯â¯â¯â¯â¯[ğ‘¢ğ‘£](ğ‘¡ğ‘ ,ğ‘¡ğ‘“)=supğ‘¡ğ‘¢âˆˆ[ğ‘¡ğ‘ ,ğ‘¡ğ‘“){ğ·[ğ‘¢ğ‘£](ğ‘¡ğ‘¢)}.
If [ğ‘¡ğ‘ ,ğ‘¡ğ‘“)=[0,ğ‘‡), we refer to the static free-flow and full-congestion metrics ğ‘‘â¯â¯,ğ‘‘â¯â¯â¯:ğ´â†’(0,âˆ), respectively. In particular, as already mentioned, each arc ğ‘âˆˆğ´ is also accompanied with scalars ğ·â¯â¯â¯[ğ‘]=ğ·â¯â¯â¯[ğ‘](0,ğ‘‡) and ğ·â¯â¯â¯â¯â¯[ğ‘]=ğ·â¯â¯â¯â¯â¯[ğ‘](0,ğ‘‡) for these static metrics. For any arc-cost metric D, diam(G, D) is the diameter (largest possible vertex-to-vertex distance) of the graph in that metric. For example, ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯) and ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯â¯â¯) denote the free-flow and full-congestion diameters of G, respectively.

In our TD-instance, we can assume without loss of generality (wlog) that ğ‘‡â‰¥ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯) and ğ‘‡=ğ‘›ğ›¼ for some given constant ğ›¼âˆˆ(0,1) of our control. If either of these two assumptions is violated, we can easily transform our TD-instance to comply with it:

If ğ‘‡<ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯), then we pick a positive integer ğ‘â‰¥1 so that (ğ‘âˆ’1)â‹…ğ‘‡<ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯)â‰¤ğ‘â‹…ğ‘‡=ğ‘‡â€². Consequently we consider c consecutive copies of each d[a] as a single function ğ‘‘â€²[ğ‘]:[0,ğ‘‡â€²)â†¦â„>0 and we use the new periodic arc-travel-time function ğ·â€²[ğ‘](ğ‘¡+ğ‘˜â‹…ğ‘‡â€²)=ğ‘‘â€²[ğ‘](ğ‘¡), âˆ€ğ‘¡âˆˆ[0,ğ‘‡â€²). The new TD-instance obviously has period ğ‘‡â€²=ğ‘â‹…ğ‘‡â‰¥ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯â€²)>(ğ‘âˆ’1)â‹…ğ‘‡. We make here the assumption that ğ‘âˆˆîˆ»(1), i.e., at most a constant number of copies of [0, T) would be required. This assumption is quite reasonable for our motivating examples, since in a typical road network instance the period T is either 24 hours (single-day) or (most usually) 7 days. Even in a continental-size road network, like that of Europe, the free-flow diameter cannot be dramatically larger than T.

If ğ‘‡â‰ ğ‘›ğ›¼, then we exploit the fact that, for all the involved functions in our TD-instance, both the domain and the codomain determine (travel-, earliest-arrival-, or presence-) time points. We represent values in both the domain and the codomain in each of these functions as multiples of a new unit of time, ğ‘‡ğ‘›ğ›¼. For instance, we might have to move from second-units to either millisecond- or to minute-units, depending on how T compares with ğ‘›ğ›¼. Along the domain (x-) axis of the arc-travel-time functions, all values ğ‘¡â‰¥0 are now mapped to ğ‘¡â€³=ğ‘¡â‹…ğ‘›ğ›¼ğ‘‡ units. Thus, the domain of each function d[a] is now confined to [0,ğ‘‡â€³=ğ‘‡â‹…ğ‘›ğ›¼ğ‘‡=ğ‘›ğ›¼). Along the codomain (y-) axis of the involved (arc-travel-time / arc-arrival-time) functions, we have that ğ·â€³[ğ‘](ğ‘¡â€³)=ğ·[ğ‘](ğ‘¡)â‹…ğ‘›ğ›¼ğ‘‡ as well. I.e., all (including free-flow, time-dependent, or fully-congested) travel-times in the TD-instance are also scaled by the same multiplicative factor ğ‘›ğ›¼ğ‘‡. In particular, the comparison of ğ‘‡â€³ with ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯â€³) is the same as that of T with ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯).

Consequently, from now on we can safely consider TD-instances with ğ‘‡=ğ‘›ğ›¼â‰¥ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯).

We now proceed with some definition of balls under the travel-time metrics. For any ğ‘£âˆˆğ‘‰, departure-time ğ‘¡ğ‘£âˆˆâ„â‰¥0, integer ğ¹âˆˆ[ğ‘›]Footnote4 and scalar ğ‘…>0:

ğµ[ğ‘£;size=ğ¹](ğ‘¡ğ‘£) denotes a TD-ball from (ğ‘£,ğ‘¡ğ‘£) containing the first F settled vertices (i.e., a ball of size F), in the time-dependent travel-time metric.

ğµ[ğ‘£;radius=ğ‘…](ğ‘¡ğ‘£) denotes a TD-ball from (ğ‘£,ğ‘¡ğ‘£) containing all the settled vertices with distance from (ğ‘£,ğ‘¡ğ‘£) at most R (i.e., a ball of radius R), in the time-dependent metric.

Analogously, ğµâ¯â¯â¯[ğ‘£;size=ğ¹] and ğµâ¯â¯â¯â¯[ğ‘£;size=ğ¹] denote the size-F balls from v, whereas ğµâ¯â¯â¯[ğ‘£;radius=ğ‘…]) and ğµâ¯â¯â¯â¯[ğ‘£;radius=ğ‘…] denote the radius-R balls from v, in the free-flow and fully-congested travel-time metrics respectively.

For arbitrary ğœ€â¯â¯â¯,ğœ€â¯â¯>0, a pair of continuous, pwl, periodic functions ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘] and ğ›¥â¯â¯â¯[ğ‘œ,ğ‘‘]), with a (hopefully) small number of breakpoints, are (1+ğœ€â¯â¯â¯)-upper-approximation and (1+ğœ€â¯â¯)-lower-approximation of D[o, d] respectively, if the following holds: âˆ€ğ‘¡ğ‘œâ‰¥0,

ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)1+ğœ€â¯â¯â‰¤ğ›¥â¯â¯â¯[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)â‰¤ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)â‰¤ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)â‰¤(1+ğœ€â¯â¯â¯)â‹…ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)
Clearly, when we only know that these functions are upper- and lower approximations of D[o, d] but we cannot specify the exact quality of the approximations because D[o, d] is hard to compute, it would suffice to prove that âˆ€ğ‘¡ğ‘œâ‰¥0, ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)â‰¤(1+ğœ€)â‹…ğ›¥â¯â¯â¯[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ), in order to claim that ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘] is a (1+ğœ€)-upper-approximation of D[o, d], for some ğœ€>0.

Finally, we consider TD-instances on sparse graphs. This is because our goal is to design TD-oracles using subquadratic preprocessing space, sublinear query time, and small stretch factor, e.g., smaller than 2. In [1, 23] it was shown that, even in the much lighter case of static and undirected networks, a stretch factor less than 2 would be possible with subquadratic preprocessing space and sublinear query time only when ğ‘šâˆˆo(ğ‘›2). For the much more demanding case of time-dependent instances that we consider in this work, we concentrate on instances with n vertices and ğ‘šâˆˆîˆ»(ğ‘›) arcs for two reasons: (i) they are interesting from a practical point of view, since almost all real-world instances stemming from our main application scenario (route planning in road networks) fulfill this property; (ii) any Dijkstra-like query algorithm would probably fail to achieve sublinear query time, due to the existence of many high-degree vertices.

For convenience, the notation used throughout the paper is summarized in â€œAppendix Aâ€.

Properties, Validity and Implications
The directedness and time-dependence in the underlying network imply an asymmetric arc-cost metric that also evolves with time. To achieve a smooth and measurable transition from static and undirected graphs towards time-dependent and directed graphs, we need a quantification of the degrees of asymmetry and evolution of our metric over time. These are captured via a set of parameters ğ›¬min,ğ›¬max,ğœ,ğœ† of the input instance (that will be formally defined in Sect. 3.1), which are also provided as part of the input, depicting the steepness of the minimum-travel-time functions, the ratio of minimum-travel-times in opposite directions, and the relation between graph expansion and travel-times.

In the rest of this section, we start by defining three properties for the values of these parameters. These properties constitute the foundations of our axiomatic approach. We then discuss the characteristics of the TD-instances as they result from the TD-oracle requirements and the implications of these properties. Finally, we present our experimental analysis which validates the three properties on real-world TD-instances stemming from our main application scenario (road networks).

Properties
The first property states that all minimum-travel-time partial derivatives (a.k.a slopes) are bounded within a given interval.

Proposition 1
(Bounded travel-time slopes) For constants ğ›¬minâˆˆ[0,1) and ğ›¬maxâ‰¥0, the following holds:

âˆ€(ğ‘œ,ğ‘‘)âˆˆğ‘‰Ã—ğ‘‰, âˆ€0â‰¤ğ‘¡1<ğ‘¡2, ğ·[ğ‘œ,ğ‘‘](ğ‘¡2)âˆ’ğ·[ğ‘œ,ğ‘‘](ğ‘¡1)ğ‘¡2âˆ’ğ‘¡1âˆˆ[âˆ’ğ›¬min,ğ›¬max].
The lower-bound of âˆ’1 in the minimum-travel-time function slopes is indeed a direct consequence of the FIFO property, which is typically assumed to hold in several time-dependent road network instances. The parameter ğ›¬max represents the maximum possible rate of change of minimum-travel-times in the network, which only makes sense to be bounded (in particular, independent of the network size) in realistic instances such as the ones representing urban-traffic time-dependent road networks.

The second property asserts that the ratio of minimum-travel-times in opposite directions between two vertices, for any specific departure-time but not necessarily via the same path, is upper bounded by a given constant.

Proposition 2
(Bounded opposite trips) âˆƒ ğœâ‰¥1, âˆ€(ğ‘œ,ğ‘‘)âˆˆğ‘‰Ã—ğ‘‰, âˆ€ğ‘¡âˆˆ[0,ğ‘‡), ğ·[ğ‘œ,ğ‘‘](ğ‘¡)â‰¤ğœâ‹…ğ·[ğ‘‘,ğ‘œ](ğ‘¡).

This property holds naturally in road networks. For instance, it is rather unlikely that a trip in one direction is more than, say, 10 times longer than the trip in the opposite direction, when departing from either endpoint of the trip at a given time.

The next property guarantees that, when we extend (under the free-flow metric) the radius of a size-F free-flow ball, up to the value of the full-congestion radius in it, the blow-up in the size of the new (free-flow again) ball is bounded by a slowly growing (in particular, polylogarithmic) function in the network size. Figure 1 visualizes this property, which is formally stated as follows.

Fig. 1
figure 1
Visualization of Property 3

Full size image
Proposition 3
(Bounded growth of free-flow balls) For ğ‘…>1, consider any free-flow ball ğµâ¯â¯â¯=ğµâ¯â¯â¯[â„“;ğ‘Ÿğ‘ğ‘‘ğ‘–ğ‘¢ğ‘ =ğ‘…] around some vertex â„“, which also has size ğ¹=|ğµâ¯â¯â¯|. Let ğ‘…âˆ—=maxğ‘£âˆˆğµâ¯â¯â¯{ğ·â¯â¯â¯â¯â¯[â„“,ğ‘£]} be the maximum travel-time of a vertex ğ‘£âˆˆğµâ¯â¯â¯ from â„“, under the full-congestion metric, and ğ¹âˆ—=|ğµâ¯â¯â¯[â„“;radius=ğ‘…âˆ—]| is the size of the (extended) free-flow ball around â„“ of radius ğ‘…âˆ—â‰¥ğ‘…. Then, it holds that ğ¹âˆ—âˆˆîˆ»(ğ¹polylog(ğ¹)).

Property 3 is significant in our analysis, because it guarantees the following: Whenever we restrict our efforts to a small subgraph of the entire network, e.g. a free-flow ball B from ğ‘£âˆˆğ‘‰ with the F closest destinations, then we can safely assume that, under either the time-dependent or the full-congestion metric, the smallest ball from v containing all these destinations of B has size îˆ»(ğ¹polylog(ğ¹)). We have assessed the meaningfulness of Property 3 by verifying it in the real-world road network instances that we have at our disposal (cf. [16, Section 2]).

Finally, we need a systematic way to correlate the travel-time metric with the Dijkstra-rank metric induced by it. For this reason, inspired by the notion of the doubling dimension (e.g., see [2] and references therein), we consider some scalar ğœ†â‰¥1 and a function ğ‘“:â„•â†¦[1,âˆ), such that the following holds: âˆ€(ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ)âˆˆğ‘‰Ã—ğ‘‰Ã—[0,ğ‘‡), (i) (ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ))ğœ†â‰¤ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)â‰¤ğ‘“(ğ‘›)â‹…(ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ))ğœ†.

This property trivially holds, e.g., for ğœ†=1, ğ‘“(ğ‘›)=ğ‘›minğ‘¢ğ‘£âˆˆğ´ğ·â¯â¯â¯[ğ‘¢ğ‘£]. Our interest is for the largest allowable value for ğœ†, for slow-growing (e.g., at most polylogarithmic) function f(n). Observe that, for vertices whose travel-time distance is ğ·[ğ‘œ,ğ‘‘]>1, it holds that ğœ†â‰¤log(ğ‘›) would suffice, since ğ›¤[ğ‘œ,ğ‘‘]â‰¤ğ‘›=2log(ğ‘›)âˆˆîˆ»(ğ·[ğ‘œ,ğ‘‘]log(ğ‘›)). Our last property quantifies exactly the boundedness of this correlation by restricting ğœ† and f(n).

Proposition 4
(Correlation of travel time and Dijkstra-rank) There exist ğœ†,ğ‘âˆˆîˆ»(1) and ğ‘“(ğ‘›)âˆˆîˆ»(logğ‘(ğ‘›)), for which the following holds, for any ğ‘¡ğ‘œâˆˆ[0,ğ‘‡) and travel-time value ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)>1:

ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)ğœ†â‰¤ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)â‰¤ğ‘“(ğ‘›)â‹…ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)ğœ†.
Analogous inequalities hold for the free-flow and the full-congestion metrics ğ·â¯â¯â¯ and ğ·â¯â¯â¯â¯â¯.

The importance of Property 4, is that it allows us to bound within small multiplicative factors the penalization that we undergo, when we have to â€œjumpâ€ from the travel-time metric to the Dijkstra-rank metric and vice versa.

Note that static oracles based on the doubling dimension (e.g., [2]) typically concern undirected graphs for which they require the second inequality of the property, for some constant value for the exponent ğœ† of the expansion. In the present work, since we have to deal with directed graphs, we additionally require the first inequality. However, we also introduce some slackness by allowing some divergence from the corresponding powers by polylogarithmic factors.

Implications of Properties and TD-Oracle Requirements
We proceed with some simple consequences of the requirements of TD-oracles set in Sect. 1, as well as of the aforementioned properties, in order to shed light on the implications they impose on the considered TD-instance G.

We begin with an implication of Property 1 on the variation of travel-time distances from an origin to a destination, under the time-dependent metric.

Lemma 1
(Variation between free-flow and full-congestion metrics) For any pair of vertices (ğ‘œ,ğ‘‘)âˆˆğ‘‰Ã—ğ‘‰, ğ·max[ğ‘œ,ğ‘‘]=maxğ‘¡âˆˆ[0,ğ‘‡){ğ·[ğ‘œ,ğ‘‘](ğ‘¡)} and ğ·min[ğ‘œ,ğ‘‘]=minğ‘¡âˆˆ[0,ğ‘‡){ğ·[ğ‘œ,ğ‘‘](ğ‘¡)}, it holds that ğ·max[ğ‘œ,ğ‘‘]âˆ’ğ·min[ğ‘œ,ğ‘‘]â‰¤ğ›¬minâ‹…ğ›¬maxğ›¬min+ğ›¬maxâ‹…ğ‘‡<ğ‘‡.

Proof
(Lemma 1) Assume without loss of generality (e.g., by shifting times over the time-axis) that ğ·min[ğ‘œ,ğ‘‘]=ğ·[ğ‘œ,ğ‘‘](0) and ğ·max[ğ‘œ,ğ‘‘]=ğ·[ğ‘œ,ğ‘‘](ğ‘¡â¯â¯). We apply Property 1 for the time points ğ‘¡1=ğ‘¡â¯â¯âˆ’ğ‘‡<ğ‘¡2=0<ğ‘¡3=ğ‘¡â¯â¯.


The maximum value of the upper-bounding lower envelope (as a function of ğ‘¡â¯â¯) in the RHS of this last inequality is achieved at ğ‘¡â¯â¯=ğ›¬minğ›¬min+ğ›¬maxâ‹…ğ‘‡. Therefore, we conclude that

ğ·max[ğ‘œ,ğ‘‘]âˆ’ğ·min[ğ‘œ,ğ‘‘]â‰¤ğ›¬minğ›¬maxğ›¬min+ğ›¬maxâ‹…ğ‘‡<ğ‘‡
since ğ›¬minğ›¬maxğ›¬min+ğ›¬max<ğ›¬minâ‰¤1, for ğ›¬minâˆˆ(0,1) and ğ›¬ğ‘šğ‘ğ‘¥â‰¥0. â—»

Property 2 implies that our TD-instance should be strongly connected, which is indeed the case for almost all real-world TD-instances (e.g., road networks). Moreover, it quantifies the â€œdegree of directednessâ€ by the value of the ğœ parameter.

We now turn to the implications of Property 4 on the density of free-flow balls with small radius, which are materialized in Lemma 2. This lemma demonstrates that radius-1 free-flow balls are small in their size. This allows the exclusion from the preprocessing phase of all those destinations which are very close to a given landmark, since they can easily be dealt with by the query algorithm for a controllable additional cost. Moreover, Lemma 2 gives a nice natural interpretation of f(n): It expresses the maximum number of destinations at free-flow distance at most 1 from any given landmark, after scaling the travel-time metric so that ğ‘‡=ğ‘›ğ›¼.

Lemma 2
(Polylogarithmic Size of Radius-1 Free-Flow Balls) The number of destinations at free-flow travel-time at most 1 from an arbitrary vertex â„“âˆˆğ‘‰ is at most f(n).

Proof
(Lemma 2) Consider the ball ğµ=ğµâ¯â¯â¯[â„“;radius=1]. We exploit the fact a ball around â„“ may only expand, as we increase its radius. That is, âˆ€ğœ”>0 it holds that ğµâ¯â¯â¯[â„“;radius=1]âŠ†ğµâ¯â¯â¯[â„“;radius=1+ğœ”]. Since Property 4 holds for the free-flows, we have:

|ğµâ¯â¯â¯[â„“;radius=1]|â‰¤|ğµâ¯â¯â¯[â„“;radius=1+ğœ”]|â‰¤ğ‘“(ğ‘›)â‹…(1+ğœ”)ğœ†â†’ğœ”â†“0ğ‘“(ğ‘›)
â—»

Finally, we wish to specify the connection of our scaling of the time-axis so that ğ‘‡=ğ‘›ğ›¼ and ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯)=ğ‘›ğ›¼ğœˆ for a constant ğœˆâˆˆ(0,1) with the value of ğœ†. This is indeed the appropriate scaling factor which guarantees both the low density of radius-1 balls and the validity of Property 4.

Lemma 3
(ğ›¼ğœ†ğœˆâ‰ˆ1) Consider an instance for which the time axis is scaled so that ğ‘‡=ğ‘›ğ›¼ and ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯)=ğ‘›ğ›¼ğœˆ for ğœˆâˆˆ(0,1). Then, the following holds:

1ğœ†â‹…(1âˆ’log(ğ‘“(ğ‘›))log(ğ‘›))â‰¤ğ›¼ğœˆâ‰¤1ğœ†
Proof
(Lemma 3) Under the free-flow metric, observe that along the longest min-travel-time path (which determines the free-flow diameter), if we consider one terminal point as the origin then the other terminal point is at travel-time distance ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯) and at Dijkstra-rank distance exactly n from it, assuming strong connectivity in the network.

The upper bound is quite simple to be proved, taking into account that Property 4 holds:

ğ‘›ğ›¼ğœˆ=ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯)â‰¤ğ‘›1/ğœ†â‡’ğ›¼ğœˆâ‰¤1ğœ†
Analogously, for the lower bound we exploit again Property 4:

ğ‘›ğ›¼ğœˆ=ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯)â‰¥(ğ‘›ğ‘“(ğ‘›))1/ğœ†â‡’(ğ‘“(ğ‘›))1/ğœ†â‰¥ğ‘›1/ğœ†âˆ’ğ›¼ğœˆâ‡’1ğœ†log(ğ‘“(ğ‘›))â‰¥(1ğœ†âˆ’ğ›¼ğœˆ)log(ğ‘›)â‡’ğ›¼ğœˆâ‰¥1ğœ†(1âˆ’log(ğ‘“(ğ‘›))log(ğ‘›))
â—»

To summarize, in the rest of the paper we consider sparse, strongly connected TD-instances, possessing the features described in Properties 1, 2, 3 and 4, with ğ‘‡=ğ‘›ğ›¼, and with no more than f(n) vertices at free-flow distance 1 from any vertex.

Validity of Properties
The aforementioned properties were verified through an experimental analysis on three TD-instances.

A real-world TD-instance concerning the road network of the urban-area of the city of Berlin, kindly provided to us by TomTom (in the frame of [12]), consisting of ğ‘›=473,253 vertices and ğ‘š=1,126,468 arcs, in which the arc-delay functions are the continuous, pwl interpolants of five-minute samples of the average travel-times in each road segment.

A real-world TD-instance concerning the national road network of Germany, kindly provided to us by PTV AG [24] for scientific use, consisting of ğ‘›=4,692,091 vertices and ğ‘š=10,805,429 arcs, with similar (to the Berlin instance) arc-delay functions.

A real-world benchmark TD-instance of Western Europeâ€™s (WE) road network, kindly provided by PTV AG [24] for scientific use, consisting of ğ‘›=18,010,173 vertices and ğ‘š=42,188,664 arcs. The time-dependent arc travel time functions were generated as described in [19], reflecting a high amount of traffic for all types of roads (highways, national roads, urban roads), all of which posses non-constant time-dependent arc travel time functions.

We performed 50, 000 random queries (ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ) on all the aforementioned TD-instances, by selecting 50, 000 random (o, d) pairs and focusing on the harder case of rush-hour departure times ğ‘¡ğ‘œ.

Our experimental analysis (a preliminary version of which was reported in [16]) exhibited the following numbers for the parameters ğ›¬max (Property 1) and ğœmax (maximum value of ğœ, Property 2):

Berlin TD-instance: ğ›¬max<0.225, ğœmax<2.043.

Germany TD-instance: ğ›¬max<0.454, ğœmax<2.256.

W. Europe TD-instance (heavy-traffic variant): ğ›¬max<8.33, ğœğ‘šğ‘ğ‘¥<2.331.

Property 3 has also been verified in our benchmark networks, where the blow-up in the ball size ğ¹âˆ— is less than 10 times that of F. For more details on this experiment, the reader is deferred to [16, Section 6.2 and Table 4].

As for Property 4, the value of ğœ† depends on the choice of the scaling parameter ğ›¼, for the travel-time metric. In particular, as we explain in the next section, ğœ†â‰¤1ğ›¼. Moreover, f(n) concerns the maximum number of vertices contained in a radius-1 ball under the free-flow metric.

In summary, the experimental analysis on the aforementioned TD-instances reveals that real-world time-dependent networks indeed possess features captured by the parameters described in the four properties and that the values of these parameters are small constants.

Review of TD Oracles in [17] and New Variants
We now give an overview of the TD-oracles presented and analyzed in [17]. Those oracles are essential for understanding the new oracles presented and analyzed in this work. Recall that at a high-level, these oracles comprise of two phases: a preprocessing phase (landmark selection and computation of approximation summaries from these landmarks to all other vertices using ğ™±ğ™¸ğš‚) and a query phase. Note also that the analysis of the TD-oracles in [17] is based on sparse TD-instances possessing Properties 1 and 2.

Review of TD Oracles in [17]
The TD-oracles in [17] start by first determining, for some ğœŒâˆˆ(0,1), a set L of ğœŒğ‘› ğ¢ğ®ğšğ«Footnote5 selected landmarks (vertices acting as reference points). During the preprocessing phase, all (1+ğœ€)-upper-approximating functions (travel-time summaries) ğ›¥â¯â¯â¯â¯[â„“,ğ‘£] are constructed from each landmark â„“âˆˆğ¿ towards every reachable destination ğ‘£âˆˆğ‘‰, using the ğ™±ğ™¸ğš‚ approximation algorithm that keeps bisecting the common axis of departure-times from â„“, until the desired approximation guarantee is achieved in each subinterval, for all destinations. It is proved in [17] that ğ™±ğ™¸ğš‚ requires

îˆ»(ğ¾âˆ—ğœ€maxğ‘‘âˆˆğ‘‰{log(ğ‘‡â‹…(ğ›¬max+1)ğœ€minğ‘¡ğ‘œ{ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)})}maxğ‘‘âˆˆğ‘‰{log(maxğ‘¡ğ‘œ{ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)}minğ‘¡ğ‘œ{ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)})})
calls to ğšƒğ™³ğ™³(ğ‘œ,â‹†,ğ‘¡ğ‘œ), for a given origin ğ‘œâˆˆğ‘‰ and all reachable destinations from it. This in turn implies at most îˆ»(ğ¾âˆ—â‹…log(1/ğœ€)ğœ€log2(ğ‘›)) calls, when ğ‘‡,ğ·â¯â¯â¯â¯â¯[ğ‘œ,ğ‘‘]âˆˆpoly(ğ‘›) and ğ·â¯â¯â¯[ğ‘œ,ğ‘‘]â‰¥1.

Two query algorithms were proposed in [17], ğ™µğ™²ğ™° and ğšğš€ğ™°, which provide constant and (1+ğœ)-approximations (for constant ğœ>ğœ€) to minimum-travel-times, respectively.

ğ™µğ™²ğ™° is a simple sublinear-time algorithm for evaluating ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ), guaranteeing a constant approximation w.r.t. ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ). In particular, it grows a ğšƒğ™³ğ™³ ball ğµ[ğ‘œ](ğ‘¡ğ‘œ)={ğ‘¥âˆˆğ‘‰:ğ·[ğ‘œ,ğ‘¥](ğ‘¡ğ‘œ)â‰¤ğ·[ğ‘œ,â„“ğ‘œ](ğ‘¡ğ‘œ)} from (ğ‘œ,ğ‘¡ğ‘œ), until either d or the closest landmark â„“ğ‘œâˆˆargminâ„“âˆˆğ¿{ğ·[ğ‘œ,â„“](ğ‘¡ğ‘œ)} is settled. ğ™µğ™²ğ™° then returns either the exact travel-time value, or the approximate travel-time value via â„“ğ‘œ, ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)=ğ·[ğ‘œ,â„“ğ‘œ](ğ‘¡ğ‘œ)+ğ›¥â¯â¯â¯â¯[â„“ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ·[ğ‘œ,â„“ğ‘œ](ğ‘¡ğ‘œ)), which is a guaranteed (1+ğœ€+ğœ“)-approximation; ğœ“ is a constant depending on ğœ€,ğœ and ğ›¬max, but not on the size of the network.

ğšğš€ğ™° improves the approximation guarantee provided by ğ™µğ™²ğ™°, by exploiting carefully a number of recursive accesses to the preprocessed information, each of which produces (via calls to ğ™µğ™²ğ™°) additional candidate od-paths. The tuning parameter ğ‘Ÿâˆˆâ„• â€“ the recursion budget â€“ is the depth of the produced recursion tree. ğšğš€ğ™° works as follows: As long as the destination vertex has not yet been discovered in the explored area around the origin, and there is still some remaining recursion budget, it â€œguessesâ€ (by exhaustively searching for it) the next vertex ğ‘¤ğ‘˜ at the boundary of the current ball, along the (unknown) shortest od-path. Then, it grows a new ğšƒğ™³ğ™³ ball from the new center

(ğ‘¤ğ‘˜ , ğ‘¡ğ‘˜=ğ‘¡ğ‘œ+ğ·[ğ‘œ,ğ‘¤1](ğ‘¡ğ‘œ)+ğ·[ğ‘¤1,ğ‘¤2](ğ‘¡1)+â‹¯+ğ·[ğ‘¤ğ‘˜âˆ’1,ğ‘¤ğ‘˜](ğ‘¡ğ‘˜âˆ’1)),
where ğ‘¤ğ‘–, 1â‰¤ğ‘–â‰¤ğ‘˜âˆ’1 are the centers found so far, until it reaches the closest landmark â„“ğ‘˜ to it, at distance ğ‘…ğ‘˜=ğ·[ğ‘¤ğ‘˜,â„“ğ‘˜](ğ‘¡ğ‘˜) from ğ‘¤ğ‘˜. Landmark â„“ğ‘˜ offers an alternative od-path ğ‘†ğ‘‚ğ¿ğ‘˜=ğ‘ƒğ‘œ,ğ‘¤1âˆ™â‹¯âˆ™ğ‘ƒğ‘¤ğ‘˜âˆ’1,ğ‘¤ğ‘˜âˆ™ğ‘„ğ‘˜âˆ™ğ›±ğ‘˜ by a new application of ğ™µğ™²ğ™°, where ğ‘ƒğ‘¤ğ‘–,ğ‘¤ğ‘–+1âˆˆğ‘†ğ‘ƒ[ğ‘¤ğ‘–,ğ‘¤ğ‘–+1](ğ‘¡ğ‘–), ğ‘„ğ‘˜âˆˆğ‘†ğ‘ƒ[ğ‘¤ğ‘˜,â„“ğ‘˜](ğ‘¡ğ‘˜), and ğ›±ğ‘˜âˆˆğ´ğ‘†ğ‘ƒ[â„“ğ‘˜,ğ‘‘;ğœ€](ğ‘¡ğ‘˜+ğ‘…ğ‘˜) is the approximate suffix subpath provided by the oracle. Observe that ğ‘†ğ‘‚ğ¿ğ‘˜ uses a longer (optimal, if all centers lie on the unknown shortest path) prefix-subpath ğ‘ƒğ‘œ,ğ‘¤1âˆ™â‹¯âˆ™ğ‘ƒğ‘¤ğ‘˜âˆ’1,ğ‘¤ğ‘˜ which is then completed with a shorter approximate suffix-subpath ğ‘„ğ‘˜âˆ™ğ›±ğ‘˜.

It is proved in [17], and is also analytically explained (for the sake of completeness) in â€œAppendix Bâ€, that the expected time complexity of ğšğš€ğ™° is îˆ»(ğœŒâˆ’ğ‘Ÿâˆ’1â‹…polylog(ğ‘›)).

It is also proved that the minimum-travel-time over all approximate od-paths discovered by ğšğš€ğ™° is a (1+ğœ)âˆ’approximation of ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ), for a constant ğœ=ğœ(ğ‘Ÿ)>ğœ€.

New Variants
In [17] there was no scaling of the instance, other than the assumption that the minimum travel-time ever observed is at least 1. In this work, we need to connect the travel-time metric with the Dijkstra-rank metric more tightly. Therefore, we scale the instance so that ğ‘‡=ğ‘›ğ›¼, for a properly chosen scaling factor ğ›¼â‰ˆ1ğœˆğœ† that also affects Property 4. Of course, we can no longer take for granted that the minimum travel-time ever seen in the network is at least 1. But we have also shown (cf. Lemma 2) that the number of destinations at travel-time at most 1 around any origin is îˆ»(ğ‘“(ğ‘›)). Therefore, we consider a variant of ğ™±ğ™¸ğš‚, which we call ğ™±ğ™¸ğš‚+, that simply ignores all destinations at free-flow distance smaller than 1 from the origin vertex. The following lemma clarifies this under the lens of our TD-instance.

Lemma 4
For a TD-instance with scaled travel-times metric so that ğ‘‡=ğ‘›ğ›¼, which also abides with Properties 1,  2 and 4, the one-to-many travel-time approximation algorithm ğ™±ğ™¸ğš‚+ requires îˆ»(ğ¾âˆ—â‹…log(1/ğœ€)ğœ€â‹…log2(ğ‘›)) calls of ğšƒğ™³ğ™³(ğ‘œ,â‹†,ğ‘¡ğ‘œ) to provide summaries of minimum-travel-time functions from a given origin ğ‘œâˆˆğ‘‰ towards all destinations at free-flow travel-time distance ğ·â¯â¯â¯[ğ‘œ,ğ‘‘]>1 from o.

Proof
(Lemma 4) The crucial observation, which is a direct consequence of Lemma 1, is the following:

ğ·max[ğ‘œ,ğ‘‘]âˆ’ğ·min[ğ‘œ,ğ‘‘]â‰¤ğ‘‡=ğ‘›ğ›¼â‡’ğ·max[ğ‘œ,ğ‘‘]ğ·min[ğ‘œ,ğ‘‘]â‰¤1+ğ‘›ğ›¼ğ·min[ğ‘œ,ğ‘‘]<1+ğ‘›ğ›¼,
exploiting the fact that ğ™±ğ™¸ğš‚+ only accounts for od-pairs with ğ·min[ğ‘œ,ğ‘‘]â‰¥ğ·â¯â¯â¯[ğ‘œ,ğ‘‘]>1. Adapting the analysis of [17, Theorem 1], we conclude that ğ™±ğ™¸ğš‚+ requires îˆ»(ğ¾âˆ—â‹…log(1/ğœ€)ğœ€â‹…log2(ğ‘›)) calls of ğšƒğ™³ğ™³(ğ‘œ,â‹†,ğ‘¡ğ‘œ) for computing (1+ğœ€)-approximate travel-time functions which lie at distance more than 1 from any given origin ğ‘œâˆˆğ‘‰. â—»

Since ğ™±ğ™¸ğš‚+ excludes from the preprocessing of landmarks all the (free-flow) radius-1 balls around each landmark, we have to extend both ğ™µğ™²ğ™° and ğšğš€ğ™° so that each time a new landmark is settled, this excluded ball around it is explored â€œon-the-flyâ€ during the query phase. We call these extensions ğ™µğ™²ğ™°+ and ğšğš€ğ™°+, respectively. Because all these balls are only of size îˆ»(ğ‘“(ğ‘›))âŠ‚o(ğ‘›) (cf. Lemma 2), this extension does not severely affect the overall performances of the query algorithms.

The next theorem is a consequence of the analysis presented in [17], and summarizes the performances of the previously described (new) variants of the oracles presented in that work. To avoid unnecessary repetition, we detail in its proof only the extension steps required to the proofs of the results in [17].

Theorem 1
Assume that a TD-instance with ğ‘šâˆˆîˆ»(ğ‘›) and compliant with Properties 1, 2 and 4, is preprocessed using ğ™±ğ™¸ğš‚+ for constructing travel-time summaries from ğœŒğ‘› ğ¢ğ®ğšğ« chosen landmarks, where 1ğœŒâˆˆğ›º(ğ‘“(ğ‘›)). Moreover, each query is served by the query algorithm ğšğš€ğ™°+ with recursion depth ğ‘Ÿâˆˆâ„• (for ğ‘Ÿ=0 we get ğ™µğ™²ğ™°+). Then, the expected preprocessing space ğ‘†ğ™±ğ™¸ğš‚+ and time ğ‘ƒğ™±ğ™¸ğš‚+ for ğ™±ğ™¸ğš‚+, and the expected query time ğ‘„ğšğš€ğ™°+ for ğšğš€ğ™°+, are:

ğ”¼{ğ‘†ğ™±ğ™¸ğš‚+}ğ”¼{ğ‘ƒğ™±ğ™¸ğš‚+}ğ”¼{ğ‘„ğšğš€ğ™°+}âˆˆîˆ»(ğ¾âˆ—ğœŒğ‘›2log2(ğ‘›))âˆˆîˆ»(ğ¾âˆ—ğœŒğ‘›2log3(ğ‘›))âˆˆ(1ğœŒ)ğ‘Ÿ+1+o(1)
As for the approximation guarantees, the following hold: For ğ‘Ÿ=0, ğšğš€ğ™°+ (i.e., ğ™µğ™²ğ™°+) returns either an exact od-path, or an approximate od-path via the landmark â„“ğ‘œ closest to o, such that ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)â‰¤ğ‘…ğ‘œ+ğ›¥â¯â¯â¯â¯[â„“ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ‘…ğ‘œ)â‰¤(1+ğœ€)â‹…ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)+ğœ“â‹…ğ‘…ğ‘œâ‰¤(1+ğœ€+ğœ“)â‹…ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ), where ğ‘…ğ‘œ=ğ·[ğ‘œ,â„“ğ‘œ](ğ‘¡ğ‘œ) is the minimum-travel-time to â„“ğ‘œ, and ğœ“=1+ğ›¬max(1+ğœ€)(1+2ğœ+ğ›¬maxğœ)+(1+ğœ€)ğœ is a cost-metric dependent constant. When ğ‘Ÿâ‰¥1, ğšğš€ğ™°+ returns an od-path that guarantees stretch 1+ğœ, where ğœ=ğœ(ğ‘Ÿ)â‰¤ğœ€â‹…(1+ğœ€/ğœ“)ğ‘Ÿ+1(1+ğœ€/ğœ“)ğ‘Ÿ+1âˆ’1.

Proof
(Theorem 1) From the analysis in [17, Theorem 2] we know that for each of the ğœŒğ‘› landmarks we conduct îˆ»(ğ¾âˆ—â‹…log(1/ğœ€)â‹…log2(ğ‘›)ğœ€) TDSP probes, each requiring îˆ»(ğ‘›log(ğ‘›)+ğ‘šloglog(ğ¾max))=îˆ»(ğ‘›log(ğ‘›)) additional time and îˆ»(ğ‘›) additional space. Compared to the analysis in [17], the extra polylogarithmic factor in the number of TDSP probes is due to the fact that the period T and the travel-time ratio ğ·â¯â¯â¯â¯â¯ / ğ·â¯â¯â¯ can no longer be assumed to be independent of the network size, but they are both upper-bounded by ğ‘›ğ›¼, as it has already been explained.

The stretch factors of ğ™µğ™²ğ™°+ and ğšğš€ğ™°+ follow from the proofs of [17, Theorems 3 and 5]. As for the query times, the size of each ball that we grow is îˆ»((1/ğœŒ)â‹…log(ğ‘›)) with high probability, and each ball stops at the very first (new) landmark that will be settled in it. At this time, we have to also grow a radius-1 ball from that landmark, of size at most f(n). Therefore, exploiting a union bound on all the grown balls (as shown in â€œAppendix Bâ€), the expected cost per ball is (with high probability) at most

îˆ»((log(ğ‘›)/ğœŒ)[log(log(ğ‘›)/ğœŒ)+loglog(ğ¾max)]+ğ‘“(ğ‘›)[log(ğ‘“(ğ‘›))+loglog(ğ¾max)])âŠ†îˆ»((1/ğœŒ)1+o(1)),
for 1/ğœŒâˆˆğ›º(ğ‘“(ğ‘›)). Now, the claimed query times are obtained by following the proofs of [17, Theorems 4 and 6]. â—»

When ğ¾âˆ—âˆˆo(ğ‘›) the TD-oracles of [17], as well as their extensions presented in this section, achieve both sublinear query times and subquadratic preprocessing requirements.

The ğšƒğšğ™°ğ™¿ Approximation Method
We now introduce the ğšƒğšğ™°ğ™¿ approximation method, a novel algorithm for computing one-to-many upper-approximations of the unknown min-travel-time functions from a given vertex â„“ towards all sufficiently distant destinations from it. Typically â„“ is perceived as a critical node in the network, a landmark. In particular, for a given landmark â„“, a positive scalar ğœ€>0 and a positive integer ğ¹âˆˆâ„¤>0, the goal is to provide, (1+ğœ€)-upper-approximating functions ğ›¥â¯â¯â¯â¯[â„“,ğ‘£] of the actual min-travel-time functions ğ·[â„“,ğ‘£] for all reachable destinations from â„“, except for a small subset of F â€œnearbyâ€ destinations for which the achieved approximation is not required to reach the required guarantee.Footnote6

Fig. 2
figure 2
The upper- and lower-approximating functions ğ›¿â¯â¯â¯ğ‘˜[â„“,ğ‘£] (thick orange, upper pwl) and ğ›¿â¯â¯ğ‘˜[â„“,ğ‘£] (thick green, lower pwl) for the unknown min-travel-time function ğ·[â„“,ğ‘£] (blue pwl), within the interval ğ¼ğ‘˜=[ğ‘¡ğ‘ =(ğ‘˜âˆ’1)ğœ,ğ‘¡ğ‘“=ğ‘˜ğœ) (Color figure online)

Full size image
ğšƒğšğ™°ğ™¿ is a remarkably simple algorithm, which in a nutshell works as follows (cf. the pseudocode of the algorithm in Fig. 3). In step 1, for each destination v we determine the maximum time-interval for the consecutive departure-time samples, that would suffice in order to get a (1+ğœ€)-approximation of ğ·[â„“,ğ‘£]. Consequently (steps 2-4) we determine the value of ğœâˆ—, so that the required approximation guarantee is achieved for all the ğ‘›âˆ’ğ¹ â€œfarawayâ€ destinations from â„“. Then, in steps 5-16, the interval [0, T) is split into a number of âŒˆğ‘‡ğœâˆ—âŒ‰ consecutive length-ğœâˆ— subintervals. We proceed with the sampling of travel-times to all â€œfarawayâ€ destinations, for all the selected sampled departure times. We also determine the zenith-point (ğ‘¡â¯â¯ğ‘š,ğ·â¯â¯â¯â¯â¯ğ‘š) and the nadir-point (ğ‘¡â¯ğ‘š,ğ·â¯â¯â¯ğ‘š) in our upper- and lower-approximating functions per subinterval (cf. Fig. 2). Finally, we do the same calculations of the zenith-point and the nadir-point also w.r.t. the last sample point, for the last subinterval of the [0, T); cf. steps 17-21 in ğšƒğšğ™°ğ™¿â€™s pseudocode.

The tuning parameter ğœâˆ—, a function of F and ğœ€, will be fixed later in such a way that (i) the required approximation guarantee for the upper-approximating travel-time functions is achieved, for all ğ‘›âˆ’ğ¹ â€œfarawayâ€ destinations from each landmark â„“; and (ii) the number ğ‘‡ğœâˆ— of sampled departure-times from the landmarks are not more than needed, since this would lead to an increase in the required preprocessing time and space. Then, for each subinterval [ğ‘¡ğ‘ ,ğ‘¡ğ‘“=ğ‘¡ğ‘ +ğœâˆ—)âŠ†[0,ğ‘‡), a (1+ğœ€)-upper-approximation of the projection ğ·[â„“,ğ‘£]:[ğ‘¡ğ‘ ,ğ‘¡ğ‘“)â†¦â„>0 is constructed. The concatenation of all these (1+ğœ€)-upper-approximations per subinterval constitutes the requested (1+ğœ€)-upper-approximation ğ›¥â¯â¯â¯â¯[â„“,ğ‘£] of ğ·[â„“,ğ‘£]:[0,ğ‘‡)â†¦â„>0. Figure 2 provides a visualization of ğšƒğšğ™°ğ™¿â€™s rationale: the unknown (blue) function is â€œtrappedâ€ between an upper- (orange) and a lower- (green) approximating function.

Note that, contrary to the ğ™±ğ™¸ğš‚ approximation method [17], no assumption is made on the shapes of the travel-time functions to approximate within each subinterval; in particular, no assumption is made on them being concave, as was the case for ğ™±ğ™¸ğš‚. ğšƒğšğ™°ğ™¿ only exploits the fact that ğœâˆ— can be chosen to be sufficiently small so as to guarantee the required approximation for all â€œfarawayâ€ destinations, along with Property 1 on the boundedness of travel-time slopes.

Fig. 3
figure 3
The pseudocode for the ğšƒğšğ™°ğ™¿ approximation algorithm. Each (continuous, pwl) upper-approximating function ğ›¥[â„“,ğ‘£] is stored, and eventually returned, as a sequence of breakpoints, i.e., a list of pairs of sampled departure times from â„“ and the corresponding min-travel-time values

Full size image
The pseudocode of ğšƒğšğ™°ğ™¿, provided in Fig. 3, is discussed and analyzed in the rest of this section. We start by describing the upper-approximating (ğ›¿â¯â¯â¯ğ‘˜[â„“,ğ‘£]) and lower-approximating (ğ›¿â¯â¯ğ‘˜[â„“,ğ‘£]) functions of ğ·[â„“,ğ‘£] that we consider within the subinterval ğ¼ğ‘˜=[ğ‘¡ğ‘ =(ğ‘˜âˆ’1)ğœâˆ—,ğ‘¡ğ‘“=ğ‘˜ğœâˆ—)âŠ‚[0,ğ‘‡), ğ‘˜âˆˆ[âŒŠğ‘‡ğœâŒ‹], or for ğ¼âŒŠğ‘‡/ğœâˆ—âŒ‹+1=[ğ‘¡ğ‘ =âŒŠğ‘‡/ğœâˆ—âŒ‹â‹…ğœâˆ—,ğ‘¡ğ‘“=ğ‘‡) (cf. Fig. 2): âˆ€ğ‘˜âˆˆâŒˆğ‘‡/ğœâˆ—âŒ‰, âˆ€ğ‘¡âˆˆğ¼ğ‘˜,

ğ›¿â¯â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡):=min{ğ·[â„“,ğ‘£](ğ‘¡ğ‘“)+ğ›¬minğ‘¡ğ‘“âˆ’ğ›¬minğ‘¡ , ğ·[â„“,ğ‘£](ğ‘¡ğ‘ )âˆ’ğ›¬maxğ‘¡ğ‘ +ğ›¬maxğ‘¡ }
(1)
ğ›¿â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡):=max{ğ·[â„“,ğ‘£](ğ‘¡ğ‘“)âˆ’ğ›¬maxğ‘¡ğ‘“+ğ›¬maxğ‘¡ , ğ·[â„“,ğ‘£](ğ‘¡ğ‘ )+ğ›¬minğ‘¡ğ‘ âˆ’ğ›¬minğ‘¡}
(2)
The following lemma demonstrates that indeed these are upper- and lower- approximations of ğ·[â„“,ğ‘£] within ğ¼ğ‘˜.

Lemma 5
For all ğ‘˜âˆˆ[âŒˆğ‘‡ğœâˆ—âŒ‰] and ğ‘¡âˆˆğ¼ğ‘˜, it holds that ğ›¿â¯â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡)â‰¥ğ·[â„“,ğ‘£](ğ‘¡)â‰¥ğ›¿â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡).

Proof
(Lemma 5) By Property 1, for any departure-time ğ‘¡âˆˆğ¼ğ‘˜ from â„“ and any destination vertex ğ‘£âˆˆğ‘‰, the following inequalities hold:


Combining the two inequalities we get the following bounding functions for ğ·[â„“,ğ‘£] within ğ¼ğ‘˜: âˆ€ğ‘£âˆˆğ‘‰,âˆ€ğ‘¡âˆˆğ¼ğ‘˜:

ğ·[â„“,ğ‘£](ğ‘¡)â‰¥ğ·[â„“,ğ‘£](ğ‘¡)â‰¤max{âˆ’ğ›¬minğ‘¡+ğ›¬minğ‘¡ğ‘ +ğ·[â„“,ğ‘£](ğ‘¡ğ‘ ) , ğ›¬maxğ‘¡âˆ’ğ›¬maxğ‘¡ğ‘“+ğ·[â„“,ğ‘£](ğ‘¡ğ‘“)}=ğ›¿â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡)min{ğ›¬maxğ‘¡âˆ’ğ›¬maxğ‘¡ğ‘ +ğ·[â„“,ğ‘£](ğ‘¡ğ‘ ) , âˆ’ğ›¬minğ‘¡+ğ›¬minğ‘¡ğ‘“+ğ·[â„“,ğ‘£](ğ‘¡ğ‘“)}=ğ›¿â¯â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡)
â—»

Let (ğ‘¡â¯ğ‘š[â„“,ğ‘£](ğ‘˜),ğ·â¯â¯â¯ğ‘š[â„“,ğ‘£](ğ‘˜)) and (ğ‘¡â¯â¯ğ‘š[â„“,ğ‘£](ğ‘˜),ğ·â¯â¯â¯â¯â¯ğ‘š[â„“,ğ‘£](ğ‘˜)) be the intersections of the legs in the definitions of ğ›¿â¯â¯ğ‘˜[â„“,ğ‘£] and ğ›¿â¯â¯â¯ğ‘˜[â„“,ğ‘£], respectively (see Fig. 2). The three breakpoints determining the (continuous, pwl) function ğ›¿â¯â¯â¯ğ‘˜[â„“,ğ‘£], which are computed and stored by ğšƒğšğ™°ğ™¿ in steps 8â€“21, are the following:

âŸ¨ (ğ‘¡ğ‘˜âˆ’1,ğ·[â„“,ğ‘£](ğ‘¡ğ‘˜âˆ’1)) , (ğ‘¡â¯â¯ğ‘š[â„“,ğ‘£](ğ‘˜),ğ·â¯â¯â¯â¯â¯ğ‘š[â„“,ğ‘£](ğ‘˜)) , (ğ‘¡ğ‘˜,ğ·[â„“,ğ‘£](ğ‘¡ğ‘˜)) âŸ©
The lower-approximating function ğ›¿â¯â¯ğ‘˜[â„“,ğ‘£] is only used for our analysis, and is not actually stored by ğšƒğšğ™°ğ™¿. Since ğ·[â„“,ğ‘£] lies between these two approximations within the interval ğ¼ğ‘˜, the maximum additive error ğ‘€ğ´ğ¸[â„“,ğ‘£](ğ¼ğ‘˜) for ğ›¿â¯â¯â¯ğ‘˜[â„“,ğ‘£] in ğ¼ğ‘˜ (i.e., the length of the purple dashed line in Fig. 2) is defined as follows:

ğ‘€ğ´ğ¸[â„“,ğ‘£](ğ¼ğ‘˜):===â‰¤maxğ‘¡âˆˆğ¼ğ‘˜{ğ›¿â¯â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡)âˆ’ğ›¿â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡)}ğ›¿â¯â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡â¯ğ‘š[â„“,ğ‘£](ğ‘˜))âˆ’ğ·â¯â¯â¯ğ‘š[â„“,ğ‘£](ğ‘˜)ğ·â¯â¯â¯â¯â¯ğ‘š[â„“,ğ‘£](ğ‘˜)âˆ’ğ›¿â¯â¯[â„“,ğ‘£](ğ‘¡â¯â¯ğ‘š[â„“,ğ‘£](ğ‘˜))ğ·â¯â¯â¯â¯â¯ğ‘š[â„“,ğ‘£](ğ‘˜)âˆ’ğ·â¯â¯â¯ğ‘š[â„“,ğ‘£](ğ‘˜)
(3)
The following lemma proves that, for ğœâˆ— sufficiently small, ğ‘€ğ´ğ¸[â„“,ğ‘£](ğ¼ğ‘˜) cannot be large. In particular, it provides a sufficient condition for the value of ğœâˆ— so that ğ›¿â¯â¯â¯ğ‘˜[â„“,ğ‘£] is indeed a (1+ğœ€)-upper-approximation of ğ·[â„“,ğ‘£] within ğ¼ğ‘˜.

Lemma 6
For all (â„“,ğ‘£)âˆˆğ¿Ã—ğ‘‰ and ğ‘˜âˆˆ[âŒˆğ‘‡ğœâˆ—âŒ‰], the following hold:

(i)
ğ‘€ğ´ğ¸[â„“,ğ‘£](ğ¼ğ‘˜)â‰¤ğ›¬maxâ‹…ğœâˆ—;

(ii)
ğ›¿â¯â¯â¯ğ‘˜[â„“,ğ‘£] is a (1+ğœ€)-upper-approximation of ğ·[â„“,ğ‘£] within ğ¼ğ‘˜, if

ğ·â¯â¯â¯[â„“,ğ‘£]â‰¥(ğ›¬minğ›¬min+ğ›¬max+1ğœ€)â‹…ğ›¬maxâ‹…ğœâˆ—
Proof
(Lemma 6) In order to simplify notation within the proof, we drop the dependence of ğ‘¡â¯ğ‘š, ğ‘¡â¯â¯ğ‘š, ğ·â¯â¯â¯ğ‘š and ğ·â¯â¯â¯â¯â¯ğ‘š from â„“, v and k. Since (ğ‘¡â¯ğ‘š,ğ·â¯â¯â¯ğ‘š) is the intersection of two lines, it is easy to show that:

ğ‘¡â¯ğ‘š=ğ·[â„“,ğ‘£](ğ‘¡ğ‘ )âˆ’ğ·[â„“,ğ‘£](ğ‘¡ğ‘“)ğ›¬min+ğ›¬max+ğ›¬minğ‘¡ğ‘ +ğ›¬maxğ‘¡ğ‘“ğ›¬min+ğ›¬max
(4)
ğ·â¯â¯â¯ğ‘š=ğ›¬maxğ·[â„“,ğ‘£](ğ‘¡ğ‘ )+ğ›¬minğ·[â„“,ğ‘£](ğ‘¡ğ‘“)ğ›¬min+ğ›¬maxâˆ’ğ›¬minâ‹…ğ›¬maxğ›¬min+ğ›¬maxâ‹…(ğ‘¡ğ‘“âˆ’ğ‘¡ğ‘ )
(5)
Analogously, (ğ‘¡â¯â¯ğ‘š,ğ·â¯â¯â¯â¯â¯ğ‘š) is also the intersection of two lines. Therefore:

ğ‘¡â¯â¯ğ‘š=ğ·[â„“,ğ‘£](ğ‘¡ğ‘“)âˆ’ğ·[â„“,ğ‘£](ğ‘¡ğ‘ )ğ›¬min+ğ›¬max+ğ›¬minğ‘¡ğ‘“+ğ›¬maxğ‘¡ğ‘ ğ›¬min+ğ›¬max
(6)
ğ·â¯â¯â¯â¯â¯ğ‘š=ğ›¬maxğ·[â„“,ğ‘£](ğ‘¡ğ‘“)+ğ›¬minğ·[â„“,ğ‘£](ğ‘¡ğ‘ )ğ›¬min+ğ›¬max+ğ›¬minğ›¬maxğ›¬min+ğ›¬max(ğ‘¡ğ‘“âˆ’ğ‘¡ğ‘ )
(7)
(i)
We start with the upper bound on the maximum absolute error:

ğ‘€ğ´ğ¸[â„“,ğ‘£](ğ¼ğ‘˜)â‰¤ğ·â¯â¯â¯â¯â¯ğ‘šâˆ’ğ·â¯â¯â¯ğ‘š=ğ›¬maxğ·[â„“,ğ‘£](ğ‘¡ğ‘“)+ğ›¬minğ·[â„“,ğ‘£](ğ‘¡ğ‘ )ğ›¬min+ğ›¬max+ğ›¬minğ›¬maxğ›¬min+ğ›¬max(ğ‘¡ğ‘“âˆ’ğ‘¡ğ‘ )âˆ’ğ›¬maxğ·[â„“,ğ‘£](ğ‘¡ğ‘ )+ğ›¬minğ·[â„“,ğ‘£](ğ‘¡ğ‘“)ğ›¬min+ğ›¬max+ğ›¬minğ›¬maxğ›¬min+ğ›¬max(ğ‘¡ğ‘“âˆ’ğ‘¡ğ‘ )=(ğ›¬maxâˆ’ğ›¬min)[ğ·[â„“,ğ‘£](ğ‘¡ğ‘“)âˆ’ğ·[â„“,ğ‘£](ğ‘¡ğ‘ )]+2ğ›¬minğ›¬ğ‘šğ‘ğ‘¥(ğ‘¡ğ‘“âˆ’ğ‘¡ğ‘ )ğ›¬min+ğ›¬max=(ğ›¬maxâˆ’ğ›¬min)[ğ·[â„“,ğ‘£](ğ‘¡ğ‘“)âˆ’ğ·[â„“,ğ‘£](ğ‘¡ğ‘ )]ğ‘¡ğ‘“âˆ’ğ‘¡ğ‘ +2ğ›¬minğ›¬ğ‘šğ‘ğ‘¥ğ›¬min+ğ›¬max(ğ‘¡ğ‘“âˆ’ğ‘¡ğ‘ )â‰¤/âˆ—Property 1âˆ—/(ğ›¬maxâˆ’ğ›¬min)ğ›¬max+2ğ›¬minğ›¬ğ‘šğ‘ğ‘¥ğ›¬min+ğ›¬max(ğ‘¡ğ‘“âˆ’ğ‘¡ğ‘ )=ğ›¬maxğœâˆ—
(ii)
From the definition of MAE (see Eq. 3) we have that âˆ€ğ‘¡âˆˆğ¼ğ‘˜,

ğ›¿â¯â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡)â‰¤â‰¤â‰¤ğ›¿â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡)+ğ‘€ğ´ğ¸[â„“,ğ‘£](ğ¼ğ‘˜)ğ›¿â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡)+ğ›¬maxğœâˆ—=ğ›¿â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡)â‹…(1+ğ›¬maxğœâˆ—ğ›¿â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡))ğ·[â„“,ğ‘£](ğ‘¡)â‹…(1+ğ›¬maxğœâˆ—ğ›¿â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡))
In order to deduce a (1+ğœ€)-approximation, the following condition is sufficient:


A weaker sufficient condition is when we assure this last inequality for the minimum value ğ·â¯â¯â¯ğ‘š[â„“,ğ‘£](ğ‘¡ğ‘ ,ğ‘¡ğ‘“) (actually, for its equivalent given in eq. (5)) of ğ›¿â¯â¯ğ‘˜[â„“,ğ‘£](ğ‘¡) within the entire length-ğœâˆ— subinterval ğ¼ğ‘˜:

ğ›¬maxğœâˆ—ğœ€â‰¤ğ›¬maxğ·[â„“,ğ‘£](ğ‘¡ğ‘ )+ğ›¬minğ·[â„“,ğ‘£](ğ‘¡ğ‘“)ğ›¬min+ğ›¬maxâˆ’ğ›¬minâ‹…ğ›¬maxğ›¬min+ğ›¬maxâ‹…ğœâˆ—
We make this sufficient condition even weaker by substituting all travel-times ğ·â¯â¯â¯[â„“,ğ‘£] from â„“ to v with the minimum possible (i.e., the free-flow) value:


â—»

It is noted that the sufficient condition (ii) in Lemma 6 is independent of the actual departure time ğ‘¡âˆˆğ¼ğ‘˜, and only depends on the free-flow travel-time ğ·â¯â¯â¯[â„“,ğ‘£], the length ğœâˆ— that we choose for the subintervals, the targeted approximation guarantee, and parameters of the travel-time metric.

Having this sufficient condition at hand, it is now straightforward to determine the appropriate value of ğœâˆ— so that a good approximation is guaranteed for all but the F closest (under the free-flow metric) destinations from â„“. This is exactly what ğšƒğšğ™°ğ™¿ does (cf. steps 1â€“4 in Fig. 3): First, for each destination vertex v, the appropriate (candidate) value ğœ[â„“,ğ‘£] for ğœâˆ— is determined, so that v gets also a good approximation. The vertices are then ordered according to these candidate values, and ğœâˆ— is set to the F-th smallest value in this order. The set ğ‘‰[â„“](ğœâˆ—)={ğ‘£âˆˆğ‘‰:ğœ[â„“,ğ‘£]>ğœâˆ—} contains ğ‘›âˆ’ğ¹ â€œfarawayâ€ destinations for which we must get a good approximation within ğ¼ğ‘˜. Unfortunately, an analogous approximation guarantee does not necessarily hold for the F â€œnearbyâ€ vertices from â„“, therefore these destinations are simply ignored by ğšƒğšğ™°ğ™¿.

The next theorem states that ğšƒğšğ™°ğ™¿ provides a (1+ğœ€)-upper-approximation ğ›¥â¯â¯â¯â¯[â„“,ğ‘£] for the entire period, and all the faraway destinations v from â„“. It also estimates the requirements of ğšƒğšğ™°ğ™¿ in space, in terms of the number of breakpoints to store per travel-time summary, and running time, in terms of ğšƒğ™³ğ™³ calls for computing the sampled departure-times from â„“.

Theorem 2
For a given landmark â„“âˆˆğ‘‰, ğœ€>0 and integer ğ¹>ğ‘“(ğ‘›), let ğœ[â„“,ğ‘£], ğœâˆ— and ğ‘‰[â„“](ğœâˆ—) be defined as follows:

ğœ[â„“,ğ‘£]ğœâˆ—ğ‘‰[â„“](ğœâˆ—):=ğ·â¯â¯â¯[â„“,ğ‘£](1ğœ€+ğ›¬minğ›¬min+ğ›¬max)ğ›¬max, âˆ€ğ‘£âˆˆğ‘‰:= the ğ¹âˆ’ th  smallest ğœ[â„“,ğ‘£]âˆ’ value .:={ğ‘£âˆˆğ‘‰:ğœ[â„“,ğ‘£]>ğœâˆ—}
For each ğ‘£âˆˆğ‘‰[â„“](ğœâˆ—), let ğ›¥â¯â¯â¯â¯[â„“,ğ‘£] be the concatenation of all upper-approximating functions ğ›¿â¯â¯â¯ğ‘˜[â„“,ğ‘£] that ğšƒğšğ™°ğ™¿ returns per subinterval ğ¼ğ‘˜=[ ğ‘¡ğ‘ ğ‘˜=(ğ‘˜âˆ’1)ğœâˆ— , ğ‘¡ğ‘“ğ‘˜=min{ğ‘˜ğœâˆ—,ğ‘‡} ):ğ‘˜âˆˆ[âŒˆğ‘‡ğœâˆ—âŒ‰]. Then the following hold, for all ğ‘£âˆˆğ‘‰[â„“](ğœâˆ—):

(i)
ğ›¥â¯â¯â¯â¯[â„“,ğ‘£] is a (1+ğœ€)-upper-approximation of ğ·[â„“,ğ‘£] in [0, T).

(ii)
The number of calls to ğšƒğ™³ğ™³(â„“,â‹†,ğ‘¡) for the construction of travel-time summaries for all ğ‘£âˆˆğ‘‰[â„“](ğœ) is âŒˆğ‘‡ğœâˆ—âŒ‰âˆˆîˆ»(ğ‘›ğ›¼ğœ€).

(iii)
The overall space for succinctly representing the summaries from â„“ to all the faraway destinations ğ‘£âˆˆğ‘‰[â„“](ğœ) is at most 2âŒˆğ‘‡ğœâˆ—âŒ‰â‹…(ğ‘›âˆ’ğ¹)âˆˆîˆ»(ğ‘›1+ğ›¼ğœ€) breakpoints.

Proof
(Theorem 2) Recall first that for each ğ‘£âˆˆğ‘‰[â„“](ğœâˆ—) it holds that ğ·â¯â¯â¯[â„“,ğ‘£]>1, because of our choice of ğ¹>ğ‘“(ğ‘›) (cf. Lemma 2).

Regarding statement (i) note that, by definition, the following holds for all ğ‘£âˆˆğ‘‰[â„“](ğœ): ğœ[â„“,ğ‘£]â‰¥ğœâˆ—â‡’ğ·â¯â¯â¯[â„“,ğ‘£]â‰¥(1ğœ€+ğ›¬minğ›¬min+ğ›¬max)â‹…ğ›¬maxâ‹…ğœâˆ—. Therefore, by Lemma 6, the produced upper-approximation within each subinterval ğ¼ğ‘˜ is a (1+ğœ€)-upper-approximation of ğ·[â„“,ğ‘£]. The concatenation of all these functions constitutes ğ›¥â¯â¯â¯â¯[â„“,ğ‘£], which is then also an (1+ğœ€)-upper-approximation of ğ·[â„“,ğ‘£] within [0, T).

We proceed now with statements (ii) and (iii). ğšƒğšğ™°ğ™¿ preprocesses concurrently all the summaries from â„“ to each ğ‘£âˆˆğ‘‰[â„“](ğœâˆ—), by making âŒˆğ‘‡ğœâˆ—âŒ‰â‰¤1+ğ‘‡â‹…ğ›¬maxâ‹…(1ğœ€+ğ›¬minğ›¬min+ğ›¬max)âˆˆîˆ»(ğ‘›ğ›¼ğœ€) calls to ğšƒğ™³ğ™³(â„“,â‹†,ğ‘¡). This is because we sample endpoints of consecutive subintervals of length ğœâˆ—â‰¥1(1ğœ€+ğ›¬minğ›¬min+ğ›¬max)ğ›¬max, since we only care about destinations v at free-flow distance from â„“ that is ğ·â¯â¯â¯[â„“,ğ‘£]>1.

As for the succinct representation of all these summaries, ğšƒğšğ™°ğ™¿ needs at most 2âŒˆğ‘‡ğœâˆ—âŒ‰(ğ‘›âˆ’ğ¹)âˆˆîˆ»(ğ‘‡â‹…ğ‘›â‹…ğ›¬maxğœ€â‹…(1+ğœ€ğ›¬minğ›¬min+ğ›¬max))âŠ†îˆ»(ğ‘›1+ğ›¼ğœ€) breakpoints, because there is at most one intermediate breakpoint (ğ‘¡â¯â¯ğ‘š,ğ·â¯â¯â¯â¯â¯ğ‘š) per subinterval (cf. Fig. 2), and there exist ğ‘›âˆ’ğ¹ â€œfarawayâ€ destinations in ğ‘‰[â„“](ğœâˆ—). â—»

Overview of Our Results
Recall from Sect. 4 that the performance of TD-oracles in [17] depends on ğ¾âˆ— (the degree of disconcavity of the input TD-instance). Achieving both subquadratic preprocessing requirements and sublinear query time is only possible when ğ¾âˆ—âˆˆo(ğ‘›). Unfortunately, experimental evidence [15] demonstrated that it may be the case that ğ¾âˆ—âˆˆğ›º(ğ‘›). In this work, we devise and analyze novel oracles, whose performance is independent of ğ¾âˆ—, without compromising the subquadratic preprocessing requirements and the sublinearity in the query performance. Moreover, we provide a novel hierarchical oracle, which achieves query performance that is essentially sublinear in the Dijkstra-rank of the query at hand, rather than the network size. Before digging into the details of our new TD-oracles, we provide in this section a more detailed overview of our results, to serve as a roadmap in what follows.

The preprocssing phase of all oracles starts with a random landmark set ğ¿âŠ‚ğ¢ğ®ğšğ«(ğœŒ)ğ‘‰, i.e., we decide independently and uniformly at random whether each vertex is a landmark, with probability ğœŒ=ğ‘›âˆ’ğœ” for a constant ğœ”âˆˆ(0,1). Clearly, the expected number of landmarks is ğ”¼{|ğ¿|}=ğœŒğ‘›=ğ‘›1âˆ’ğœ”.

We consider as â€œnearbyâ€ vertices of â„“âˆˆğ¿, all the vertices at free-flow distance at most ğ‘…â¯â¯â¯=ğ‘‡ğœƒ from it, for a constant ğœƒâˆˆ(0,1) to be determined later.

Let ğ¹=maxâ„“âˆˆğ¿{|ğµâ¯â¯â¯[â„“;radius=ğ‘…â¯â¯â¯]|} be the maximum number of â€œnearbyâ€ destinations from any landmark â„“. The remaining (at most ğ‘›âˆ’ğ¹) vertices are perceived as â€œfarawayâ€ destinations from â„“.

The next lemma shows that the main parameters we should consider w.r.t. a TD-instance are ğœ† (cf. Property 4) and ğ›¼âˆˆ(0,1) such that ğ‘‡=ğ‘›ğ›¼. All the other parameters essentially adjust their values to them.

Lemma 7
Let ğœˆâˆˆ(0,1) and ğœƒâˆˆ(0,ğœˆ) such that ğ‘‡=ğ‘›ğ›¼=ğ‘‘ğ‘–ğ‘ğ‘š(ğº,ğ·â¯â¯â¯)1/ğœˆ, ğ‘…â¯â¯â¯=ğ‘‡ğœƒ=ğ‘›ğ›¼ğœƒ, and ğœˆğœƒâˆˆîˆ»(1). Assume also that ğœ†,ğ‘“(ğ‘›) are compliant with Property 4.

Then, the following hold:

(i)
ğ›¼ğœ†ğœˆâˆˆ1âˆ’o(1).

(ii)
ğ¹âˆˆğ‘›[1Â±o(1)]ğœƒ/ğœˆ.

Proof
(Lemma 7) Property (i) trivially holds, as a consequence of Lemma 3. As for property (ii), this is also an implication of Property 4 and Lemma 3. In particular, for the upper bound on F we have:

ğ¹=â‰¤/âˆ—Property 4âˆ—/â‰¤/âˆ—Lemma 3âˆ—/âˆˆâŠ†maxâ„“âˆˆğ¿{|ğµâ¯â¯â¯[â„“;radius=ğ‘…â¯â¯â¯]|}ğ‘“(ğ‘›)â‹…ğ‘…â¯â¯â¯ğœ†=ğ‘›log(ğ‘“(ğ‘›))log(ğ‘›)â‹…ğ‘›ğ›¼ğœƒğœ†ğ‘›log(ğ‘“(ğ‘›))log(ğ‘›)+ğœƒğœˆğ‘›ğœƒğœˆâ‹…(1+ğœˆğœƒlog(ğ‘“(ğ‘›))log(ğ‘›))ğ‘›ğœƒğœˆâ‹…[1+o(1)]
The last step is because we consider instances with ğ‘“(ğ‘›)âˆˆo(ğ‘›), and moreover due to the fact that we set our (yet unspecified) tuning parameter ğœƒ so that ğœˆğœƒâˆˆo(log(ğ‘›)log(ğ‘“(ğ‘›))).

As for the lower bound on F, we exploit the fact that ğ‘…â¯â¯â¯ is the radius of at least one size-F free-flow ball around a landmark. Thus, by Property 4 and Lemma 3 we have:

ğ¹â‰¥ğ‘…â¯â¯â¯ğœ†â‰¥ğ‘›ğ›¼ğœƒğœ†=ğ‘›ğœƒğœˆâ‹…ğ›¼ğœ†ğœˆâ‰¥ğ‘›ğœƒğœˆâ‹…(1âˆ’log(ğ‘“(ğ‘›))log(ğ‘›))âˆˆğ‘›ğœƒğœˆâ‹…[1âˆ’o(1)]
â—»

The complexity bounds of our TD-oracles, as well as the trade-offs between preprocessing requirements and query performance that will be presented in the rest of the paper, are summarized in Table 2.

Table 2 Trade-offs of oracles for TD-instances, among the tuning parameters ğ›½ (for the preprocessing requirements), ğ›¿ (for the query performance) and r (for the targeted approximation guarantee), as functions of the input parameters ğœ†âˆˆîˆ»(1) (determined in Property 4) and ğ›¾>1 (determining the Dijsktra ranks per level of the ğ™·ğ™¾ğšğ™½ oracle, cf. Sect. 8)
Full size table
Oracles with Fully-Informed Landmarks
In this section we describe two novel oracles, the ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ oracle and the ğ™µğ™»ğ™°ğšƒ oracle, with landmarks possessing summaries for all reachable destinations (fully-informed landmarks), excluding possibly a small neighborhood of destinations around them. Their preprocessing phase makes calls to ğšƒğšğ™°ğ™¿ and/or ğ™±ğ™¸ğš‚+. Whenever called, ğ™±ğ™¸ğš‚+ will handle the (at most F) â€œnearbyâ€ destinations from â„“ which are also at free-flow distance from â„“ at least 1. ğšƒğšğ™°ğ™¿ will take over the (at least ğ‘›âˆ’ğ¹) â€œfarawayâ€ destinations from â„“.

The ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ Oracle
A first attempt towards avoiding the dependency of the preprocessing requirements on ğ¾âˆ—, is to develop an oracle whose preprocessing phase is based solely on the one-to-many approximation algorithm ğšƒğšğ™°ğ™¿. We call this oracle ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ. We now present separately the preprocessing phase and the query algorithm of the oracle.

Preprocessing of ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ: The entire period [0, T) is first split into subintervals of length

ğœâˆ—=ğ‘…â¯â¯â¯(1+ğœ€ğ›¬minğ›¬min+ğ›¬max)â‹…ğ›¬maxğœ€â‰¥ğœ€ğ‘…â¯â¯â¯(1+ğœ€)ğ›¬max
each. Then, for each landmark â„“âˆˆğ¿ the approximation algorithm ğšƒğšğ™°ğ™¿ is executed, which constructs the (1+ğœ€)-upper-approximation functions ğ›¥[â„“,ğ‘£], for all the â€œfarawayâ€ destinations ğ‘£âˆˆğ‘‰[â„“](ğœâˆ—) from â„“ (cf. Theorem 2). These functions are succinctly stored as sequences of breakpoints, for future use.

Recursive Query Algorithm for ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ: The oracle uses a variant of the ğšğš€ğ™° query algorithm, which we call ğšğš€ğ™°+. This algorithm proceeds exactly as ğšğš€ğ™°, the only difference being an explicit handling of each newly settled landmark. In particular, whenever a new landmark â„“ is settled, ğšğš€ğ™°+ computes (on-the-fly) also the time-dependent distances from â„“ to each of the â€œnearbyâ€ vertices (which were excluded from â„“â€™s preprocessed data structure) by growing a small TDD-ball from it until all its â€œnearbyâ€ vertices are settled. The size of this ğšƒğ™³ğ™³ ball is at most ğ¹polylog(ğ¹) (cf. Property 3). Then ğšğš€ğ™°+ proceeds exactly as ğšğš€ğ™°.

The following theorem analyzes the performance of ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ.

Theorem 3
The expected query time and the expected preprocessing space and time requirements of ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ are: ğ”¼{ğ‘„ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ}âˆˆğ‘›ğœ”ğ‘Ÿ+max{ğœ”,ğœƒğœˆ}+o(1), ğ”¼{ğ‘†ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ}âˆˆîˆ»(ğ‘›2âˆ’ğœ”+ğ›¼â‹…(1âˆ’ğœƒ)), and ğ”¼{ğ‘ƒğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ}âˆˆğ‘›2âˆ’ğœ”+ğ›¼â‹…(1âˆ’ğœƒ)+o(1). The achieved approximation guarantee for the queries is the same as that of Theorem 1.

Proof
(Theorem 3) Starting with the approximation guarantee, since the query algorithm (ğšğš€ğ™°+) is the same and is based on the same (either preprocessed, or discovered on-the-fly) landmark-to-vertex travel-times, it is clear that the approximation guarantee of ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ is exactly the one described in Theorem 1.

We therefore focus on the preprocessing requirements and the query-time performance of the oracle.

By Theorem 2, during its preprocessing ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ makes at most âŒˆğ‘‡ğœâˆ—âŒ‰â‰¤1+ğ‘‡ğœâˆ—â‰¤1+1+ğœ€ğœ€â‹…ğ›¬maxâ‹…ğ‘›ğ›¼(1âˆ’ğœƒ)âˆˆîˆ»(ğ‘›ğ›¼(1âˆ’ğœƒ)) calls to ğšƒğ™³ğ™³(â„“,â‹†,ğ‘¡), for departure-times ğ‘¡âˆˆ{0,ğœâˆ—,2ğœâˆ—,â€¦,âŒˆğ‘‡ğœâˆ—âŒ‰âˆ’1} and each landmark â„“âˆˆğ¿.

The preprocessing-time is dominated by the aggregate time for all these ğšƒğ™³ğ™³ probes. Taking into account that each ğšƒğ™³ğ™³ probe takes time îˆ»(ğ‘šloglog(ğ¾max)+ğ‘›log(ğ‘›))=îˆ»(ğ‘›log(ğ‘›)) and that ğ”¼{|ğ¿|}=ğœŒğ‘›=ğ‘›1âˆ’ğœ”, we get the following:

ğ”¼{ğ‘ƒğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ}=âŠ†ğ”¼{|ğ¿|}â‹…âŒˆğ‘‡ğœâˆ—âŒ‰â‹…îˆ»(ğ‘›log(ğ‘›))îˆ»(ğ‘›1âˆ’ğœ”+ğ‘(1âˆ’ğœƒ)+1+loglog(ğ‘›)log(ğ‘›))âŠ†ğ‘›2âˆ’ğœ”+ğ›¼â‹…(1âˆ’ğœƒ)+o(1)
The calculations are analogous for the required preprocessing space. By Theorem 2, for all landmarks â„“âˆˆğ¿ and all their â€œfarawayâ€ destinations ğ‘£âˆˆğ‘‰[â„“](ğœâˆ—), the total number of breakpoints to store is:

ğ”¼{ğ‘†ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ}=âˆˆğ”¼{|ğ¿|}â‹…2âŒˆğ‘‡ğœâŒ‰â‹…(ğ‘›âˆ’ğ¹)ğ‘›1âˆ’ğœ”â‹…îˆ»(ğ‘›ğ›¼(1âˆ’ğœƒ))â‹…ğ‘›=îˆ»(ğ‘›2âˆ’ğœ”+ğ›¼â‹…(1âˆ’ğœƒ))
As for the query-time complexity of ğšğš€ğ™°+, which is used by ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ, recall from Sect. 4 that the expected number of ğšƒğ™³ğ™³ balls that it grows around ball centers is 1+(1/ğœŒ)ğ‘Ÿ. Additionally, ğšğš€ğ™°+ grows 1+(1/ğœŒ)ğ‘Ÿ ğšƒğ™³ğ™³ balls from the corresponding closest landmarks.

A ğšƒğ™³ğ™³ ball from a new center up to the closest landmark takes time

îˆ»((1/ğœŒ)[loglog(ğ¾max)+log(1/ğœŒ)])=îˆ»(ğ‘›ğœ”+loglog(ğ‘›)log(ğ‘›))
By Lemma 7, a ğšƒğ™³ğ™³ ball from a landmark, until all F â€œnearbyâ€ destinations are settled, requires time

îˆ»(ğ¹polylog(ğ¹)loglog(ğ¾max))âŠ†ğ‘›[1+o(1)]ğœƒğœˆ
Thus, the expected query-time is upper-bounded as follows:

ğ”¼{ğ‘„ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ}âˆˆîˆ»((1/ğœŒ)ğ‘Ÿâ‹…[(1/ğœŒ)â‹…(loglog(ğ¾max)+log(1/ğœŒ))+ğ¹polylog(ğ¹)loglog(ğ¾max)])=îˆ»(ğ‘›ğœ”ğ‘Ÿâ‹…[ğ‘›ğœ”+loglog(ğ‘›)log(ğ‘›)+ğ‘›[1+o(1)]ğœƒ/ğœˆ])âŠ†ğ‘›ğœ”ğ‘Ÿ+max{ğœ”,ğœƒğœˆ}+o(1)
â—»

The next corollary is a parameter-tuning example showcasing the trade-offs among the sublinearity of query-time, the subquadratic preprocessing requirements and the achieved stretch of the chosen paths.

Corollary 1
Consider the execution of ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ on a TD-instance with a recursion budget ğ‘Ÿâˆˆ{0,1,â€¦,ğœ†âˆ’1} and setup of parameters ğœ”=ğ›¿ğ‘Ÿ+1 and ğœƒ=ğœ”ğœˆ, where ğœˆâˆˆ1âˆ’o(1). Then, ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ achieves (sublinear) expected query time ğ‘›ğ›¿+o(1) and (subquadratic) expected preprocessing requirements ğ‘›2âˆ’ğ›½+o(1) for all constants 1>ğ›¿>ğ‘Ÿ+1ğœ†+ğœˆâ‰ˆğ‘Ÿ+1ğœ†+1 and ğ›½=ğ›¿ğ‘Ÿ+1â‹…(1+1ğœ†)âˆ’1ğœ†>0.

Proof
(Corollary 1) By Lemma 7, we know that ğ›¼ğœ†ğœˆâˆˆ1âˆ’o(1). Since ğœˆâˆˆ1âˆ’o(1) as well, it must also hold that ğ›¼âˆˆ1Â±o(1)ğœ†. Then, we get the following performances for ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ:

ğ”¼{ğ‘„ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ}ğ”¼{ğ‘ƒğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ} , ğ”¼{ğ‘†ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ}âˆˆâˆˆ=ğ‘›ğœ”ğ‘Ÿ+max{ğœ”,ğœƒ/ğœˆ}+o(1)=ğ‘›ğœ”(ğ‘Ÿ+1)+o(1)=ğ‘›ğ›¿+o(1)ğ‘›2âˆ’ğœ”+ğ›¼(1âˆ’ğœƒ)+o(1)=ğ‘›2âˆ’ğœ”+ğ›¼âˆ’ğ›¼ğœˆğœ”+o(1)ğ‘›2âˆ’[ğœ”(1+ğ›¼ğœˆ)âˆ’ğ›¼]+o(1)=ğ‘›2âˆ’[ğœ”(1+ğœˆğœ†)âˆ’1ğœ†]+o(1)
To achieve the claimed subquadratic preprocessing requirement (i.e., ğ›½>0), we must ensure the following:

ğ›½:=ğœ”(1+1ğœ†)âˆ’1ğœ†=ğ›¿ğ‘Ÿ+1ğœ†+1ğœ†âˆ’1ğœ†>0â‡”ğ›¿ğ‘Ÿ+1ğœ†+1ğœ†>1ğœ†â‡”ğ›¿>ğ‘Ÿ+1ğœ†+1
Along with the query-time sublinearity requirement (i.e., 1>ğ›¿), we conclude that it suffices to choose a recursion budget 0â‰¤ğ‘Ÿâ‰¤ğœ†âˆ’1. â—»

Remark 1
Note that the query-time performance of ğšğš€ğ™°+ is analogous to that of ğšğš€ğ™° (cf. [17]) for ğœ”=ğœƒğœˆ.

Table 3 provides a clear picture of the trade-off between query-sublinearity, preprocessing-subquadraticity and the achieved stretch factor. In particular, we assume a TD-instance with ğœ†=10, ğ›¼=1ğœ†, ğœˆ=1âˆ’o(1), ğ›¿âˆˆ(ğ‘Ÿ+1ğœ†+1,1), ğ›½=ğ›¿ğ‘Ÿ+1â‹…ğœ†+ğœˆğœ†âˆ’1ğœ†â‰ˆğ›¿ğ‘Ÿ+1â‹…(1+1ğœ†)âˆ’1ğœ†, ğœ”=ğ›¿ğ‘Ÿ+1, and ğœƒ=ğœ”ğœˆ. The cells of the table (except for the last row) indicate the exponent of subquadraticity, 2âˆ’ğ›½=1+(1+1ğœ†)â‹…(1âˆ’ğ›¿ğ‘Ÿ+1). The red values in the table correspond to pairs of ğ›¿- and r-values which cannot guarantee subquadratic preprocessing requirements. The last row gives the worst-case approximation guarantee that the query algorithm achieves, for the corresponding values of the recursion budget r. The metric-dependent (but scaling-invariant) parameters, which also affect the stretch factor 1+ğœ, are set to the values ğœ=2.043 and ğ›¬max=0.225, as they were measured for the Berlin TD-instance (cf. Sect. 3.3). The preprocessing parameter concerning the summariesâ€™ approximation guarantee is set to ğœ€=0.01.

Table 3 Trade-offs of ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ among query-sublinearity îˆ»(ğ‘›ğ›¿), preprocessing-subquadraticity îˆ»(ğ‘›2âˆ’ğ›½), and achieved worst-case approximation guarantee 1+ğœ(ğ‘Ÿ,ğœ€,ğœ“)
Full size table
The ğ™µğ™»ğ™°ğšƒ Oracle
Our second attempt, the ğ™µğ™»ğ™°ğšƒ oracle, provides preprocessed information for almost all reachable destinations (except for a few â€œtoo closeâ€ destinations) from each landmark. We consider again ğšğš€ğ™°+ as the query algorithm of ğ™µğ™»ğ™°ğšƒ. That is, upon settling a new landmark â„“, a quite small (in particular, of radius 1 under the free-flow metric) ğšƒğ™³ğ™³ ball from â„“ must be grown, in order to cover an intentionally left â€œholeâ€ in the preprocessed information w.r.t. â„“.

The preprocessing phase of ğ™µğ™»ğ™°ğšƒ is based on a proper combination of ğ™±ğ™¸ğš‚+ and ğšƒğšğ™°ğ™¿ for constructing travel-time summaries (cf. Fig. 4). Each landmark â„“âˆˆğ¿ possesses summaries for all reachable destinations ğ‘£âˆˆğ‘‰, except for the â€œtoo closeâ€ destinations (i.e., at free-flow distance at most 1 from â„“). In particular, (i) travel-time summaries from â„“ towards the â€“ at most ğ¹=maxâ„“âˆˆğ¿{|ğµâ¯â¯â¯[â„“;radius=ğ‘…â¯â¯â¯]|} â€“ â€œnearbyâ€ (but not â€œtoo closeâ€) destinations ğ‘£âˆˆğµâ¯â¯â¯[â„“;radius=ğ‘…â¯â¯â¯] are precomputed using ğ™±ğ™¸ğš‚+; (ii) travel-time summaries from â„“ towards the â€œfarawayâ€ destinations ğ‘£âˆˆğ‘‰âˆ–ğµâ¯â¯â¯[â„“;radius=ğ‘…â¯â¯â¯] are precomputed using ğšƒğšğ™°ğ™¿ by setting, again, ğœâˆ—=ğ‘…â¯â¯â¯(1+ğœ€ğ›¬minğ›¬min+ğ›¬max)â‹…ğ›¬maxğœ€â‰¥ğœ€ğ‘…â¯â¯â¯(1+ğœ€)ğ›¬max.

Fig. 4
figure 4
The preprocessing scheme of the ğ™µğ™»ğ™°ğšƒ oracle

Full size image
The preprocessing requirements for the summaries created by ğšƒğšğ™°ğ™¿ are exactly the same as in ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ. As for the summaries computed by ğ™±ğ™¸ğš‚+, we tackle the linear dependence of the algorithm on ğ¾âˆ— by ensuring that F is sufficiently small and exploiting Property 3 which guarantees that the involved subgraph ğµâ¯â¯â¯[â„“;radius=ğ‘…âˆ—] in the preprocessing phase of ğ™±ğ™¸ğš‚+ on behalf of â„“ has size îˆ»(ğ¹polylog(ğ¹)).

The next lemma shows that ğ™±ğ™¸ğš‚+ is only affected by the concavity-spoiling breakpoints of arc-travel-time functions in the free-flow ball ğµâ¯â¯â¯[â„“;radius=ğ‘…âˆ—], rather than the entire graph (cf. Lemma 3 for the notation).

Lemma 8
Fix any â„“âˆˆğ¿, the free-flow ball ğµ=ğµâ¯â¯â¯[â„“;radius=ğ‘…] from it, and the maximum full-congestion distance from â„“ within B, ğ‘…âˆ—=maxğ‘§âˆˆğµ{ ğ·â¯â¯â¯â¯â¯[â„“,ğ‘§] }.

Then, for any departure time ğ‘¡âˆˆ[0,ğ‘‡) from â„“, and any destination ğ‘£âˆˆğµ, there is no intermediate vertex ğ‘¢âˆˆğ‘‰âˆ–ğµâ¯â¯â¯[â„“;radius=ğ‘…âˆ—] along the corresponding time-dependent shortest path from â„“ to v.

Proof
(Lemma 8) From the definitions of the involved Dijkstra balls under the free-flow and full-congestion metrics, and from Property 3, the following holds: âˆ€ğ‘¡âˆˆ[0,ğ‘‡), ğ·[â„“,ğ‘£](ğ‘¡)â‰¤ğ·â¯â¯â¯â¯â¯[â„“,ğ‘£]â‰¤ğ‘…âˆ—<ğ·â¯â¯â¯[â„“,ğ‘¢]â‰¤ğ·[â„“,ğ‘¢](ğ‘¡). â—»

The following theorem summarizes the complexities of the ğ™µğ™»ğ™°ğšƒ oracle.

Theorem 4
The expected query-time ğ‘„ğ™µğ™»ğ™°ğšƒ as well as the expected preprocessing time ğ”¼{ğ‘ƒğ™µğ™»ğ™°ğšƒ} and space ğ”¼{ğ‘†ğ™µğ™»ğ™°ğšƒ} of ğ™µğ™»ğ™°ğšƒ are:

ğ”¼{ğ‘„ğ™µğ™»ğ™°ğšƒ}âˆˆğ”¼{ğ‘ƒğ™µğ™»ğ™°ğšƒ} , ğ”¼{ğ‘†ğ™µğ™»ğ™°ğšƒ}âˆˆğ‘›ğœ”(ğ‘Ÿ+1)+o(1)ğ‘›1âˆ’ğœ”+o(1)â‹…[ğ‘›2ğœƒ/ğœˆ+ğ‘›1+ğ›¼â‹…(1âˆ’ğœƒ)]
Proof
(Theorem 4) Recall that ğšğš€ğ™°+ grows an expected number of îˆ»(1+(1/ğœŒ)ğ‘Ÿ) ğšƒğ™³ğ™³ balls from the centers to their closest landmarks. By Theorem 1 and recalling that ğœŒ=ğ‘›âˆ’ğœ”, the time complexity of this is

îˆ»((1/ğœŒ)ğ‘Ÿ+1[log(1/ğœŒ)+loglog(ğ¾max)])âˆˆîˆ»(ğ‘›ğœ”(ğ‘Ÿ+1)[log(ğ‘›ğœ”)+loglog(ğ‘›)])âŠ‚ğ‘›ğœ”(ğ‘Ÿ+1)+o(1)
Moreover, for each of the îˆ»((1/ğœŒ)ğ‘Ÿ) settled landmarks, a small-sized ball has to be grown, in order to cover the destinations which are â€œtoo closeâ€ to â„“. The size of each such ball is only ğ‘“(ğ‘›)polylog(ğ‘“(ğ‘›))âŠ‚polylog(ğ‘›). The expected time for growing all these landmark-centered balls is

îˆ»((1/ğœŒ)ğ‘Ÿâ‹…polylog(ğ‘›))âŠ‚îˆ»(ğ‘›ğœ”ğ‘Ÿ+o(1))
From the above we conclude that ğ”¼{ğ‘„ğ™µğ™»ğ™°ğšƒ}âˆˆâŠ‚ğ‘›ğœ”(ğ‘Ÿ+1)+o(1).

Regarding the preprocessing phase, ğ™µğ™»ğ™°ğšƒ is charged the entire space and time of ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ for preprocessing â€œfarawayâ€ destinations, plus the space and time consumed by ğ™±ğ™¸ğš‚+ for the â€œnearbyâ€ destinations, from each landmark.

In particular, per landmark â„“âˆˆğ¿ we need:

(i)
îˆ»(ğ¹2polylog(ğ¹)âŠ‚polylog(ğ‘›)) space required by ğ™±ğ™¸ğš‚+, since by Lemma 8 the involved graph for computing travel-time summaries of all the (at most) F â€œnearbyâ€ destinations around â„“, only contains îˆ»(ğ¹polylog(ğ¹)) vertices and concavity-spoiling breakpoints at the arc-travel-time functions;

(ii)
2âŒˆğ‘‡ğœâˆ—âŒ‰(ğ‘›âˆ’ğ¹)âˆˆîˆ»(ğ‘›ğ›¼(1âˆ’ğœƒ)) space, required by ğšƒğšğ™°ğ™¿ for storing travel-time summaries of all the ğ‘›âˆ’ğ¹<ğ‘› â€œfarawayâ€ destinations.

Summarizing, the expected preprocessing space of ğ™µğ™»ğ™°ğšƒ is:

ğ”¼{ğ‘†ğ™µğ™»ğ™°ğšƒ}==ğ”¼{|ğ¿|}â‹…(ğ¹2polylog(ğ¹)+2âŒˆğ‘‡ğœâˆ—âŒ‰â‹…(ğ‘›âˆ’ğ¹))âˆˆ/âˆ—Lemma 7âˆ—/ğ‘›1âˆ’ğœ”â‹…[ğ‘›(2ğœƒ/ğœˆ)â‹…[1+o(1)]+ğ‘›1+ğ›¼â‹…(1âˆ’ğœƒ)]ğ‘›1âˆ’ğœ”+o(1)â‹…[ğ‘›2ğœƒ/ğœˆ+ğ‘›1+ğ›¼â‹…(1âˆ’ğœƒ)]
The preprocessing-time bound is computed similarly. Again, it consists of the ğ™±ğ™¸ğš‚+ time for the â€œnearbyâ€ destinations, plus the ğšƒğšğ™°ğ™¿ time for the â€œfarawayâ€ destinations, per landmark â„“.

ğ”¼{ğ‘ƒğ™µğ™»ğ™°ğšƒ}âˆˆğ”¼{|ğ¿|}â‹…( ğ¹2polylog(ğ¹)loglog(ğ¾max)+âŒˆğ‘‡ğœâˆ—âŒ‰â‹…îˆ»((ğ‘›âˆ’ğ¹)â‹…[log(ğ‘›âˆ’ğ¹)+loglog(ğ¾max)]) )=/âˆ—Lemma 7âˆ—/ğ‘›1âˆ’ğœ”[ğ‘›(2ğœƒ/ğœˆ)â‹…[1+o(1)]+ğ‘›1+ğ›¼â‹…(1âˆ’ğœƒ)[1+o(1)]]=ğ‘›1âˆ’ğœ”+o(1)â‹…[ğ‘›2ğœƒ/ğœˆ+ğ‘›1+ğ›¼â‹…(1âˆ’ğœƒ)]
â—»

We provide a corollary which shows a parameter-tuning example for trading off the sublinearity of query-time, the subquadratic preprocessing requirements and the worst-case approximation of the chosen paths, in the case of ğ™µğ™»ğ™°ğšƒ.

Corollary 2
Consider the execution of ğ™µğ™»ğ™°ğšƒ on a TD-instance with a recursion budget ğ‘Ÿâˆˆ{0,1,â€¦,2ğœ†âˆ’1} and set up of parameters ğœ”=ğ›¿ğ‘Ÿ+1 and ğœƒ=ğœˆ+ğ›¼ğœˆ2+ğ›¼ğœˆ, where ğœˆâˆˆ1âˆ’o(1). Then, ğ™µğ™»ğ™°ğšƒ achieves (sublinear) expected query time ğ‘›ğ›¿+o(1) and (subquadratic) expected preprocessing requirements ğ‘›2âˆ’ğ›½+o(1) for all constants 1>ğ›¿>ğ‘Ÿ+12ğœ†+1 and ğ›½=ğ›¿ğ‘Ÿ+1âˆ’12ğœ†+1>0.

Proof
(Corollary 2) We already know from the proof of Corollary 1 that the particular choice of ğœ” ensures sublinearity of the expected query time, ğ‘›ğ›¿+o(1). As for the requirement for subquadratic preprocessing space and time, observe that:

ğ‘›2âˆ’ğœ”+ğ›¼(1âˆ’ğœƒ)+o(1)=ğ‘›2âˆ’ğ›¿ğ‘Ÿ+1+ğ›¼âˆ’ğ›¼ğœƒ+o(1)=ğ‘›2âˆ’ğ›¿ğ‘Ÿ+1+1ğœ†âˆ’1+1/ğœ†2ğœ†+1+o(1)=ğ‘›2âˆ’[ğ›¿ğ‘Ÿ+1âˆ’12ğœ†+1]+o(1)
This is because ğ›¼ğœƒ=ğ›¼ğœˆ+ğ›¼2ğœˆ2+ğ›¼ğœˆ=1+1/ğœ†2ğœ†+1Â±o(1). Moreover, the choice of ğœƒ guarantees that ğœˆğœƒ=2+ğ›¼ğœˆ1+ğ›¼<3, as it is required in the proof of Lemma 7. Finally, it must also hold that

ğ›½=ğ›¿ğ‘Ÿ+1âˆ’12ğœ†+1>0â‡”ğ›¿>ğ‘Ÿ+12ğœ†+1
which indeed is the case. â—»

Table 4 provides a concrete example of the trade-off of the ğ™µğ™»ğ™°ğšƒ oracle among the query-sublinearity, the preprocessing-subquadraticity and the achieved worst-case approximation guarantee, for a TD-instance with ğœ†=10, ğ›¼=1ğœ†, ğ›¿âˆˆ(ğ‘Ÿ+12ğœ†+1,1), ğ›½=ğ›¿ğ‘Ÿ+1âˆ’12ğœ†+1, ğœ”=ğ›¿ğ‘Ÿ+1, and ğœƒ=ğœˆ+ğ›¼ğœˆ2+ğ›¼ğœˆ. The cells of the table (except for the last row) indicate the exponent of subquadraticity, 2âˆ’ğ›½. The red values in the table correspond to pairs of ğ›¿- and r-values which cannot guarantee subquadratic preprocessing requirements. The last row gives the worst-case approximation guarantees that the query algorithm achieves, for the corresponding values of the recursion budget r. The metric-dependent (but scaling-invariant) parameters, which also affect the stretch factor 1+ğœ, are set to the values ğœ=2.043 and ğ›¬max=0.225, as they were measured for the Berlin TD-instance (cf. Sect. 3.3). The preprocessing parameter concerning the summariesâ€™ approximation guarantee is set to ğœ–=0.01. Because of the looser dependence of ğ›¿ on r in Corollary 2, the recursion budget that we can afford in ğ™µğ™»ğ™°ğšƒ is essentially doubled, compared to the recursion budget of ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ. As a consequence, ğ™µğ™»ğ™°ğšƒ allows for even better approximation guarantees, for essentially the same requirements for sublinearity in query-times and subquadraticity in preprocessing.

Table 4 Trade-offs of ğ™µğ™»ğ™°ğšƒ among query-sublinearity îˆ»(ğ‘›ğ›¿), preprocessing quadraticity îˆ»(ğ‘›2âˆ’ğ›½), and achieved worst-case approximation guarantee 1+ğœ(ğ‘Ÿ,ğœ€,ğœ“)
Full size table
Comparison of ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ and ğ™µğ™»ğ™°ğšƒ
Both ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ and ğ™µğ™»ğ™°ğšƒ depend on the travel-time metric, but are independent of the degree of disconcavity ğ¾âˆ—. On the one hand, ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ is a simpler oracle, at least w.r.t. its preprocessing phase. On the other hand, ğ™µğ™»ğ™°ğšƒ achieves a better worst-case approximation guarantee, for the same TD-instance and the same anticipations for sublinearity of query-time and subquadraticity of the preprocessing requirements. This is because ğ™µğ™»ğ™°ğšƒ can afford roughly two times the recursion budget of ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ, and r has an exponential effect on the approximation guarantee that ğšğš€ğ™°+ achieves.

Quality of Approximation Provided by ğ™µğ™»ğ™°ğšƒ
At this point we provide a detailed justification why the query algorithm of ğ™µğ™»ğ™°ğšƒ actually constitutes a PTAS for the TDSP problem. A similar argument would also apply for ğšƒğšğ™°ğ™¿ğ™¾ğ™½ğ™»ğšˆ, with some straightforward modifications.

As already mentioned, all variants of ğšğš€ğ™° achieve an approximation guarantee of

1+ğœ(ğ‘Ÿ,ğœ€,ğœ“)=1+ğœ€â‹…(1+ğœ€/ğœ“)ğ‘Ÿ+1(1+ğœ€/ğœ“)ğ‘Ÿ+1âˆ’1
given the approximation guarantee (1+ğœ€) for the preprocessed landmark-to-vertex distances, and the parameter ğœ“=1+ğ›¬max(1+ğœ€)(1+2ğœ+ğ›¬maxğœ)+(1+ğœ€)ğœ. It should be noted at this point that ğœ“ is only dependent on the parameters ğ›¬max,ğœ of the arc-cost metric. In particular, it does not depend on scalings (i.e., change in units) of time in the instance at hand. Clearly ğœâ†“ğœ€ as r tends to infinity. But we simply cannot afford an infinite recursion budget to the query algorithm. On the other hand, assuming that an approximation guarantee 1+ğœ is targeted, then there is a lower bound on the recursion budget required to achieve it:


This then implies, using standard inequalities ğ‘¥â‰¥ln(1+ğ‘¥)â‰¥ğ‘¥âˆ’ğ‘¥22 and straightforward calculations, that a recursion budget ğ‘Ÿâ‰¥ğœ“ğœâˆ’ğœ€ would suffice to achieve approximation guarantee 1+ğœ for ğšğš€ğ™°, given that the one for the preprocessed distances is 1+ğœ€ and that ğœ“â‰¥(ğœâˆ’ğœ€)ğœ€2ğœâˆ’3ğœ€.

For example, one can demand an approximation guarantee of 1+ğœ€=1+ğœ3 for the preprocessed information and then afford a recursion budget ğ‘Ÿâ‰¥3ğœ“2ğœ in order to achieve this. As mentioned in Table 2, ğšğš€ğ™°â€™s recursion budget in ğ™µğ™»ğ™°ğšƒ is at most ğ‘Ÿâ‰¤2ğœ†âˆ’1. Demanding both the aforementioned upper and lower bound for r, it should hold that ğœ†â‰¥3ğœ“4ğœ+12, i.e., not all values of ğœ would be achievable for an instance with given values for ğœ† and ğœ“.

In any case, a lower bound on ğ™µğ™»ğ™°ğšƒâ€™s approximation guarantee for the queries is given by the following:


On the other hand, as previously mentioned, ğœ“ is a constant that is only dependent on the arc-cost metric, and is not affected by any scaling (change in units) of time in the instance. On the other hand, as we show in Lemma 7, ğœ†â‰ˆ1ğ›¼ğœˆ>1ğ›¼. This allows us to choose 1ğ›¼âˆˆğ›º(ğœ“), in order to be able to afford a recursion budget which will guarantee that ğœ converges to ğœ€.

A Hierarchical Oracle with Partially-Informed Landmarks
We now describe and analyze the Hierarchical ORacle for time-dependent Networks (ğ™·ğ™¾ğšğ™½), whose query algorithm is highly competitive against ğšƒğ™³ğ™³, not only for long-range queries (i.e., having Dijkstra-rank proportional to the network size) but also for medium- and short-range queries, while ensuring subquadratic preprocessing space and time.

It should be noted that, although short- and medium-range queries are a quite small minority (at least) when sampling origin-destination pairs uniformly at random, in practice most of the queries are of these types in real-world scenarios. Therefore, it is important and practically relevant to achieve provable approximation guarantees and sublinear query-time that depends on the actual Dijkstra-rank of the query at hand and not on the network size.

The main idea of ğ™·ğ™¾ğšğ™½ is to preprocess:

many landmarks, each possessing summaries for a few destinations around them, so that all short-range queries can be answered using only these landmarks;

landmark sets of exponentially decreasing sizes, organized in a hierarchy according to their sizes, possessing summaries for more and more (but still not all) destinations around them, so that medium-range queries can be answered by them;

a single set at the top of the hierarchy, of only a few landmarks with preprocessed information for all reachable destinations, as in ğ™µğ™»ğ™°ğšƒâ€™s preprocessing phase.

For a landmark â„“, the area of coverage ğ¶[â„“]âŠ‚ğ‘‰ of â„“ is the set of its surrounding vertices, for which â„“ possesses travel-time summaries. The landmark â„“ is called informed for each ğ‘£âˆˆğ¶[â„“], and uninformed for each ğ‘£âˆˆğ‘‰âˆ–ğ¶[â„“]. Particularly for the destinations which are â€œtoo closeâ€ from â„“, i.e., at free-flow distance at most 1, we consider that â„“ is always informed, although no travel-time summaries are ever computed for them, since the query algorithm will deal with them anyway â€œon-the-flyâ€. The query-time overhead for dealing with the â€œtoo closeâ€ destinations per settled landmark is only îˆ»(ğ‘“(ğ‘›)polylog(ğ‘›)), and therefore is actually negligible.

The landmarks are organized in a hierarchy, according to the sizes of their areas of coverage. Each level ğ¿ğ‘– in the hierarchy is accompanied with a targeted Dijkstra-rank ğ‘ğ‘–âˆˆ[ğ‘›]. The goal of ğ™·ğ™¾ğšğ™½ is to ensure that ğ¿ğ‘– suffices for ğšğš€ğ™°+ to successfully address queries (ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ) with ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)â‰¤ğ‘ğ‘–, in time o(ğ‘ğ‘–). The difficulty of this approach lies in the analysis of the query algorithm. We want to execute a variant of ğšğš€ğ™°+ which, based on a minimal subset of landmarks, would guarantee a (1+ğœ(ğ‘Ÿ))-approximate solution for any query (ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ) (as in ğ™µğ™»ğ™°ğšƒ), but also a time-complexity sublinear in ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ), rather than the sublinearity in the network size that is guaranteed by ğ™µğ™»ğ™°ğšƒ.

Towards this direction, we propose the Hierarchical Query Algorithm (ğ™·ğš€ğ™°) which initially grows a ball from (ğ‘œ,ğ‘¡ğ‘œ), until an informed landmark â„“ w.r.t. d is settled that is also at the â€œright distanceâ€ from o, given the density of landmarks belonging to the same level with â„“. ğ™·ğš€ğ™° uses the level ğ¿ğ‘– in the hierarchy that contains â„“ (actually, the size of the corresponding areas of coverage) as a baseline and continues with the execution of ğšğš€ğ™°+, considering only landmarks having coverage at least equal to that of â„“ (cf. Fig. 5).

In the rest of this section, we provide the details and analysis of the ğ™·ğ™¾ğšğ™½ TD-oracle.

Fig. 5
figure 5
Demonstration of execution of ğ™·ğš€ğ™°. Dashed circles indicate areas of coverage. Solid circular stripes indicate the rings of the corresponding levels in the hierarchy. Landmark â„“1,ğ‘œ is uninformed and â„“3,ğ‘œ, although informed, comes too early. â„“2,ğ‘œ is both informed and within the ring of its own level, leading ğ™·ğš€ğ™° to deduce that the appropriate level is ğ‘–=2

Full size image
Setting-Up ğ™·ğ™¾ğšğ™½
We use the following parameters to set up the hierarchical construction required by ğ™·ğ™¾ğšğ™½:

(i)
The parameter ğ‘˜âˆˆîˆ»(loglog(ğ‘›)) determines the number of levels (minus one) comprising the hierarchy of landmarks.

(ii)
The parameter ğ›¾>1 determines the actual values of the targeted Dijkstra-ranks, one per level of the hierarchy. In particular, as ğ›¾ gets closer to 1, the targeted Dijkstra-ranks accumulate closer to small- and medium-rank queries.

(iii)
The parameter ğ›¿âˆˆ(0,1) quantifies the anticipated sublinearity of the query algorithm (ğ™·ğš€ğ™°), in each level of the hierarchy, compared to the targeted Dijkstra-rank of this level. In particular, if ğ‘ğ‘– is the targeted Dijkstra-rank corresponding to level ğ¿ğ‘– in the hierarchy, then ğ™·ğš€ğ™° should be executed in time îˆ»((ğ‘ğ‘–)ğ›¿+ğ‘œ(1)), if only the landmarks in this level and in higher levels are allowed to be used.

Preprocessing of ğ™·ğ™¾ğšğ™½
The preprocessing phase of ğ™·ğ™¾ğšğ™½ consists of the following steps.

1.
For each ğ‘–âˆˆ[ğ‘˜]:

The targeted Dijkstra-rank for level-i is set to ğ‘ğ‘–=ğ‘›(ğ›¾ğ‘–âˆ’1)/ğ›¾ğ‘–.

A randomly chosen (we call it level-i) landmark set ğ¿ğ‘–âŠ‚ğ¢ğ®ğšğ«(ğœŒğ‘–)ğ‘‰ is constructed, where ğœŒğ‘–=ğ‘âˆ’ğ›¿/(ğ‘Ÿ+1)ğ‘–=ğ‘›âˆ’ğ›¿(ğ›¾ğ‘–âˆ’1)/[(ğ‘Ÿ+1)ğ›¾ğ‘–].

For each landmark â„“ğ‘–âˆˆğ¿ğ‘–, let ğ¶[â„“ğ‘–] be the smallest free-flow ball centered at â„“ğ‘– containing ğ‘ğ‘–=ğ‘ğ‘–â‹…ğ‘›ğœ‰ğ‘–=ğ‘›(ğ›¾ğ‘–âˆ’1)/ğ›¾ğ‘–+ğœ‰ğ‘– vertices, for a sufficiently (but not too) small constant ğœ‰ğ‘–>0, whose range will be determined by Theorem 5 (in particular, by the analysis of ğ™·ğš€ğ™°). Let ğ¹ğ‘–=ğ‘ğœ’ğ‘– be the number of â€œnearbyâ€ vertices around â„“ğ‘–, where ğœ’=ğœƒğœˆ=1+ğ›¼2+ğ›¼ğœˆâˆˆ[12,22+ğœˆ] is an appropriate value determined so as to ensure the correctness of ğ™µğ™»ğ™°ğšƒâ€™s analysis w.r.t. the level-i of the hierarchy (cf. Theorem 4 and Corollary 2).

2.
An ultimate level ğ¿ğ‘˜+1âŠ‚ğ¢ğ®ğšğ«(ğœŒğ‘˜+1)ğ‘‰ of landmarks is constructed, with ğœŒğ‘˜+1=ğ‘›âˆ’ğ›¿ğ‘Ÿ+1, to ensure that ğ™·ğ™¾ğšğ™½ is also competitive against queries with Dijkstra-ranks greater than ğ‘›(ğ›¾ğ‘˜âˆ’1)/ğ›¾ğ‘˜. We choose in this case ğ‘ğ‘˜+1=ğ‘ğ‘˜+1=ğ‘›, ğ¹ğ‘˜+1=ğ‘›ğœ’ and ğ¶[â„“ğ‘˜+1]=ğ‘‰, âˆ€â„“ğ‘˜+1âˆˆğ¿ğ‘˜+1.

3.
For each level ğ‘–âˆˆ[ğ‘˜+1] and landmark â„“ğ‘–âˆˆğ¿ğ‘–, the travel-time summaries are constructed, for almost all destinations ğ‘£âˆˆğ¶[â„“ğ‘–].

The summaries for the ğ¹ğ‘– â€œnearbyâ€ vertices around â„“ğ‘– are constructed with ğ™±ğ™¸ğš‚+. Again, the â€œtoo closeâ€ destinations (i.e., at free-flow travel-time distance less than 1) around â„“ğ‘– are excluded from the preprocessing, but this will only impose a negligible overhead for the query algorithm, as it was explained in the analysis of ğ™µğ™»ğ™°ğšƒ.

The summaries for the remaining ğ‘ğ‘–âˆ’ğ¹ğ‘– â€œfarawayâ€ vertices of â„“ğ‘– are constructed with ğšƒğšğ™°ğ™¿.

Description of the Hierarchical Query Algorithm
We now turn to the description of the hierarchical query algorithm (ğ™·ğš€ğ™°) for answering a query (ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ). Recall that â„“ğ‘œ is the closest landmark to the origin o (cf. Sect. 4). We start by defining two stopping or termination criteria that are used by ğ™·ğš€ğ™°.

Early Stopping Criterion (ESC): Some landmark â„“ğ‘œâˆˆğ¿=âˆªğ‘–âˆˆ[ğ‘˜+1]ğ¿ğ‘– is settled which is also â€œinformedâ€ (i.e., ğ‘‘âˆˆğ¶[â„“ğ‘œ]) and, moreover, for some tuning parameter ğœ‘â‰¥1 it holds that

ğ›¥â¯â¯â¯â¯[â„“ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ·[ğ‘œ,â„“ğ‘œ](ğ‘¡ğ‘œ))ğ·[ğ‘œ,â„“ğ‘œ](ğ‘¡ğ‘œ)â‰¥(1+ğœ€)â‹…ğœ‘â‹…(ğ‘Ÿ+1)+ğœ“âˆ’1
where ğœ“ is defined in Theorem 1.

Appropriate Level of Hierarchy (ALH): For ğ‘–âˆˆ[ğ‘˜+1], some level-i landmark â„“ğ‘–,ğ‘œâˆˆğ¿ğ‘– is settled, for which the following hold:

(i)
â„“ğ‘–,ğ‘œ is â€œinformedâ€: ğ‘‘âˆˆğ¶[â„“ğ‘–,ğ‘œ];

(ii)
â„“ğ‘–,ğ‘œ is at the â€œright distanceâ€: ğ‘ğ›¿/(ğ‘Ÿ+1)ğ‘–ln(ğ‘›)â‰¤ğ›¤[ğ‘œ,â„“ğ‘–,ğ‘œ](ğ‘¡ğ‘œ)â‰¤ln(ğ‘›)â‹…ğ‘ğ›¿/(ğ‘Ÿ+1)ğ‘–.

In a nutshell, if (ESC) holds then already â„“ğ‘œ provides ğ™·ğš€ğ™° with a very good approximation and its execution is terminated. If on the other hand (ALH) holds, then ğ™·ğš€ğ™° concludes that i is the appropriate level of the hierarchy to consider w.r.t. (ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ). The main steps of ğ™·ğš€ğ™° are shown in Fig. 6.

Fig. 6
figure 6
The main steps of the query algorithm ğ™·ğš€ğ™°

Full size image
Observe that the level-(ğ‘˜+1) landmarks are always â€œinformedâ€. Thus, if no level-(â‰¤ğ‘˜) â€œinformedâ€ landmark is discovered at the â€œright distanceâ€, then the first level-(ğ‘˜+1) landmark that will be found at distance larger than ln(ğ‘›)â‹…ğ‘ğ›¿/(ğ‘Ÿ+1)ğ‘˜ will be considered to be at the â€œright distanceâ€, and ğ™·ğš€ğ™° will conclude that the appropriate level is ğ‘˜+1.

Observe also that ğšğš€ğ™°+ğ‘– (cf. Fig. 6) may fail to construct approximate solutions via each settled landmark contained in ğ‘€ğ‘–=âˆªğ‘˜+1ğ‘—=ğ‘–ğ¿ğ‘—, since some of the settled landmarks may not be â€œinformedâ€ about d. Nevertheless, as we shall show shortly, this is not a problem for the analysis of our algorithm: all the landmarks of ğ‘€ğ‘– which are settled by ğ™·ğš€ğ™° and correspond to balls whose centers lie on the (unknown) shortest path, will indeed be â€œinformedâ€, and this is enough for our approximation guarantee whose proof is only based on these balls.

Theorem 5, whose proof is provided in Sect. 8.4, summarizes the performance of ğ™·ğ™¾ğšğ™½.

Theorem 5
Consider a sparse TD-instance, abiding with Properties 1, 2, 3 and 4, a recursion budget ğ‘Ÿâˆˆ{0,1,â€¦,2ğœ†âˆ’âŒˆ2ğœ†+1ğ›¾âŒ‰}, and the following setup of the involved parameters: ğœ‘â‰¥ğœ“â‹…(1+ğœ€/ğœ“)ğ‘Ÿ+1âˆ’1ğœ€â‹…(ğ‘Ÿ+1), ğ‘˜âˆˆîˆ»(loglog(ğ‘›)), ğ›¿âˆˆ(ğ›¾(ğ‘Ÿ+1)(ğ›¾âˆ’1)(2ğœ†+1) , 1), ğœ”=ğ›¿ğ‘Ÿ+1, ğœƒ=ğœˆ+ğ›¼ğœˆ2+ğ›¼ğœˆ, ğœˆâˆˆ1âˆ’o(1), ğ›½=(ğ›¾âˆ’1)ğ›¿ğ›¾(ğ‘Ÿ+1)âˆ’12ğœ†+1, ğœ‰ğ‘–âˆˆ(ğ›º(loglog(ğ‘›)log(ğ‘›)),1âˆ’ğ›¾âˆ’ğ‘–) for all ğ‘–âˆˆ[ğ‘˜].

Then, ğ™·ğ™¾ğšğ™½ achieves preprocessing requirements ğ”¼{ğ‘ƒğ™·ğ™¾ğšğ™½} and ğ”¼{ğ‘†ğ™·ğ™¾ğšğ™½}âˆˆğ‘›2âˆ’ğ›½+o(1). Moreover, for any query (ğ‘œ,ğ‘‘,ğ‘¡ğ‘œ) such that ğ‘ğ‘–âˆ—âˆ’1<ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)â‰¤ğ‘ğ‘–âˆ— for some ğ‘–âˆ—âˆˆ[ğ‘˜+1], ğ™·ğ™¾ğšğ™½â€™s query algorithm (ğ™·ğš€ğ™°) achieves expected time complexity ğ”¼{ğ‘„ğ™·ğš€ğ™°}âˆˆ(ğ‘ğ‘–âˆ—)ğ›¿+o(1), and approximation guarantee 1+ğœ€(1+ğœ€/ğœ“)ğ‘Ÿ+1(1+ğœ€/ğœ“)ğ‘Ÿ+1âˆ’1, with probability at least 1âˆ’îˆ»(1ğ‘›).

Analysis of ğ™·ğ™¾ğšğ™½
The construction of the travel-time summaries for ğ™·ğ™¾ğšğ™½ is based on ğ™µğ™»ğ™°ğšƒâ€™s preprocessing scenario, i.e., a proper combination of ğ™±ğ™¸ğš‚+ and ğšƒğšğ™°ğ™¿ for each level in the landmark-hierarchy. The queries are served by the ğ™·ğš€ğ™° query algorithm.

The oracle exploits two fundamental invariants:

I1
The approximation guarantee of a path via some landmark â„“ strongly depends on the relative distance of the landmark from the origin o, compared to the distance of the destination d from o.

I2
Given that the expected distance of the closest level-i landmark from the origin is roughly 1ğœŒğ‘–, it is rather unlikely that it will appear too early or too late, i.e., outside a sufficiently wide ring-stripe around (ğ‘œ,ğ‘¡ğ‘œ).

Invariant I1 is exploited by the (ESC) criterion, in order to handle the exceptional case where a higher-level landmark (which also happens to be â€œinformedâ€) appears before the first â€œinformedâ€ landmark from the appropriate level. Invariant I2 is actually an event that holds with high probability, as is shown in the detailed analysis of the oracle below, and is exploited by the (ALH) criterion. Therefore, the event that an â€œinformedâ€ landmark is settled which is also at the â€œright distanceâ€, whereas the previously discovered landmarks (most likely of smaller levels) were â€œuninformedâ€, reveals an asymptotic bound for the unknown Dijkstra-rank ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ) of the destination.

We now provide a sequence of lemmata, which will eventually be used in the proof of our main technical result (Theorem 5) concerning the complexities of ğ™·ğ™¾ğšğ™½. In the following, when we mention an (ESC) termination (resp. (ALH) termination), we refer to the termination of ğ™·ğš€ğ™° due to the (ESC) criterion (resp. (ALH) criterion). We start with an upper bound on the free-flow distance of a discovered landmark â„“ğ‘œ from d. At this point we do not require that ğ‘‘âˆˆğ¶[â„“ğ‘œ].

Lemma 9
If â„“ğ‘œâˆˆğ¿ was settled by the initial ğšƒğ™³ğ™³ ball grown by ğ™·ğš€ğ™° from (ğ‘œ,ğ‘¡ğ‘œ), then the following holds: ğ·â¯â¯â¯[â„“ğ‘œ,ğ‘‘]â‰¤ğœ1âˆ’ğ›¬minâ‹…ğ·[ğ‘œ,â„“ğ‘œ](ğ‘¡ğ‘œ)+ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ).

Proof
(Lemma 9) By Property 2 we know that:

ğ·[â„“ğ‘œ,ğ‘œ](ğ‘¡ğ‘œ)â‰¤ğœâ‹…ğ·[ğ‘œ,â„“ğ‘œ](ğ‘¡ğ‘œ)
(8)
By Property 1 we also know that:

âˆ€ğ‘¥>0,â‡’âˆ’ğ›¬minâ‹…ğ‘¥â‰¤ğ·[â„“ğ‘œ,ğ‘œ](ğ‘¡ğ‘œâˆ’ğ‘¥)â‰¤ğ·[â„“ğ‘œ,ğ‘œ](ğ‘¡ğ‘œ)âˆ’ğ·[â„“ğ‘œ,ğ‘œ](ğ‘¡ğ‘œâˆ’ğ‘¥)ğ·[â„“ğ‘œ,ğ‘œ](ğ‘¡ğ‘œ)+ğ›¬minâ‹…ğ‘¥
(9)
We look for a particular departure-time ğ‘¡ğ‘œâˆ’ğ‘¥ğ‘œ, and the corresponding minimum-travel-time ğ·[â„“ğ‘œ,ğ‘œ](ğ‘¡ğ‘œâˆ’ğ‘¥ğ‘œ), so as to be at the origin o exactly at time ğ‘¡ğ‘œ. That is:

ğ‘¡ğ‘œ=â‡’ ğ‘¥ğ‘œ=â‡’ ğ‘¥ğ‘œâ‰¤ğ‘¡ğ‘œâˆ’ğ‘¥ğ‘œ+ğ·[â„“ğ‘œ,ğ‘œ](ğ‘¡ğ‘œâˆ’ğ‘¥ğ‘œ)ğ·[â„“ğ‘œ,ğ‘œ](ğ‘¡ğ‘œâˆ’ğ‘¥ğ‘œ)â‰¤/âˆ—(9)âˆ—/ğ·[â„“ğ‘œ,ğ‘œ](ğ‘¡ğ‘œ)+ğ›¬minâ‹…ğ‘¥ğ‘œğ·[â„“ğ‘œ,ğ‘œ](ğ‘¡ğ‘œ)1âˆ’ğ›¬minâ‰¤/âˆ—(8)âˆ—/ğœ1âˆ’ğ›¬minâ‹…ğ·[ğ‘œ,â„“ğ‘œ](ğ‘¡ğ‘œ)
(10)
Finally, we upper-bound the free-flow distance of â„“ğ‘œ from d by exploiting the triangle inequality:

ğ·â¯â¯â¯[â„“ğ‘œ,ğ‘‘]â‰¤ğ·[â„“ğ‘œ,ğ‘‘](ğ‘¡ğ‘œâˆ’ğ‘¥ğ‘œ)â‰¤ğ·[â„“ğ‘œ,ğ‘œ](ğ‘¡ğ‘œâˆ’ğ‘¥ğ‘œ)+ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)â‰¤/âˆ—(10)âˆ—/ğœ1âˆ’ğ›¬minâ‹…ğ·[ğ‘œ,â„“ğ‘œ](ğ‘¡ğ‘œ)+ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)
which is exactly the desired inequality. â—»

The following lemma provides an upper bound on the approximation guarantee of ğ™·ğš€ğ™°, when an (ESC) termination occurs.

Lemma 10
Assume that â„“ğ‘œâˆˆğ¿ is â€œinformedâ€ (i.e., ğ‘‘âˆˆğ¶[â„“ğ‘œ]) and settled by the initial ğšƒğ™³ğ™³ ball that ğ™·ğš€ğ™° grows from (ğ‘œ,ğ‘¡ğ‘œ). Then, the following hold whenever ğ™·ğš€ğ™° terminates due to the (ESC) criterion:

(i)
For any ğœ‘>0, the reported travel-time is a (1+ğœ€+ğœ“ğœ‘â‹…(ğ‘Ÿ+1))-approximation of the minimum travel-time.

(ii)
For ğœ‘â‰¥ğœ“â‹…[(1+ğœ€/ğœ“)ğ‘Ÿ+1âˆ’1]ğœ€â‹…(ğ‘Ÿ+1), the reported travel-time is a (1+ğœ€â‹…(1+ğœ€/ğœ“)ğ‘Ÿ+1(1+ğœ€/ğœ“)ğ‘Ÿ+1âˆ’1)-approximation of the minimum travel-time.

Proof
(Lemma 10) Let ğ‘…ğ‘œ=ğ·[ğ‘œ,â„“ğ‘œ](ğ‘¡ğ‘œ) and ğ‘…ğ‘‘=ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ). We begin with the proof of the first statement. By Theorem 1 (cf. also the analysis of ğ™µğ™²ğ™° in [17]) we know that:

â‡’ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)=ğ‘…ğ‘œ+ğ›¥â¯â¯â¯â¯[â„“ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ‘…ğ‘œ)â‰¤(1+ğœ€)â‹…ğ‘…ğ‘‘+ğœ“â‹…ğ‘…ğ‘œâ§â©â¨âªâªğ›¥â¯â¯â¯â¯[â„“ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ‘…ğ‘œ)ğ‘…ğ‘œâ‰¤(1+ğœ€)â‹…ğ‘…ğ‘‘ğ‘…ğ‘œ+ğœ“âˆ’1ğ›¥â¯â¯â¯â¯[â„“ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ‘…ğ‘œ)ğ‘…ğ‘‘â‰¤1+ğœ€+(ğœ“âˆ’1)â‹…ğ‘…ğ‘œğ‘…ğ‘‘
By the (ğ„ğ’ğ‚) termination criterion we also know that:

ğ›¥â¯â¯â¯â¯[â„“ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ‘…ğ‘œ)ğ‘…ğ‘œâ‰¥(1+ğœ€)â‹…ğœ™â‹…(ğ‘Ÿ+1)+ğœ“âˆ’1
Therefore, we deduce that:

â‡’(1+ğœ€)â‹…ğœ‘â‹…(ğ‘Ÿ+1)+ğœ“âˆ’1â‰¤(1+ğœ€)â‹…ğ‘…ğ‘‘ğ‘…ğ‘œ+ğœ“âˆ’1ğ‘…ğ‘‘ğ‘…ğ‘œâ‰¥ğœ‘â‹…(ğ‘Ÿ+1)â‡’ğœ“â‹…ğ‘…ğ‘œğ‘…ğ‘‘â‰¤ğœ“ğœ‘â‹…(ğ‘Ÿ+1)
from which comes the first statement of the lemma:

ğ›¥â¯â¯â¯â¯[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)ğ‘…ğ‘‘â‰¤1+ğœ€+ğœ“â‹…ğ‘…ğ‘œğ‘…ğ‘‘â‰¤1+ğœ€+ğœ“ğœ‘â‹…(ğ‘Ÿ+1)
As for the second statement in the lemma, it suffices to observe that, since ğœ‘â‰¥ğœ“â‹…[(1+ğœ€/ğœ“)ğ‘Ÿ+1âˆ’1]ğœ€â‹…(ğ‘Ÿ+1), it holds that:

1+ğœ€+ğœ“ğœ‘â‹…(ğ‘Ÿ+1)â‰¤1+ğœ€â‹…(1+ğœ€/ğœ“)ğ‘Ÿ+1(1+ğœ€/ğœ“)ğ‘Ÿ+1âˆ’1
â—»

We proceed now by studying the first appearance of a level-i landmark within the unique outgoing ball from (ğ‘œ,ğ‘¡ğ‘œ). The next lemma shows that, with high probability, this first appearance of a level-i landmark will take place in the following ring around o w.r.t. level-i:

ğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘–](ğ‘¡ğ‘œ):=ğµ[ğ‘œ ; size=(ğ‘ğ‘–)ğ›¿/(ğ‘Ÿ+1)â‹…ln(ğ‘›)](ğ‘¡ğ‘œ) âˆ– ğµ[ğ‘œ ; size=(ğ‘ğ‘–)ğ›¿/(ğ‘Ÿ+1)ln(ğ‘›)](ğ‘¡ğ‘œ)=ğµ[ğ‘œ ; size=ln(ğ‘›)ğœŒğ‘–](ğ‘¡ğ‘œ) âˆ– ğµ[ğ‘œ ; size=1ğœŒğ‘–ln(ğ‘›)](ğ‘¡ğ‘œ)
since ğœŒğ‘–=ğ‘âˆ’ğ›¿/(ğ‘Ÿ+1)ğ‘–.

Lemma 11
For each ğ‘–âˆˆ[ğ‘˜], there exists a level-i landmark in ğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘–](ğ‘¡ğ‘œ), with probability 1âˆ’îˆ»(1ğ‘›).

Proof
(Lemma 11) Consider any subset of vertices ğ‘†âŠ†ğ‘‰, of size ğ‘ =|ğ‘†|âˆˆâ„•. The probability that none of the vertices in S is a level-i landmark, i.e., ğ¿ğ‘–âˆ©ğ‘†=âˆ…, is (1âˆ’ğœŒğ‘–)ğ‘ â‰¤exp(âˆ’ğ‘ ğœŒğ‘–).

Observe now that, for ğ‘–âˆˆ[ğ‘˜], ğ‘ ğ‘–=|ğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘–](ğ‘¡ğ‘œ)|=ln(ğ‘›)ğœŒğ‘–âˆ’1ğœŒğ‘–ln(ğ‘›). Thus, we conclude that:

â„™{|ğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘–](ğ‘¡ğ‘œ)âˆ©ğ¿ğ‘–|=0}â‰¤exp(âˆ’ğ‘ ğ‘–â‹…ğœŒğ‘–)=exp(1ln(ğ‘›))ğ‘›âˆˆîˆ»(1ğ‘›).
â—»

The next lemma states that whenever a landmark is settled at the â€œright distanceâ€ and it happens to have coverage at least as large as the actual (but unknown) Dijkstra-rank ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ) of the query at hand, it must also hold that this landmark is â€œinformedâ€ about d.

Lemma 12
Assume that, during the initial ğšƒğ™³ğ™³ ball grown by ğ™·ğš€ğ™°, some landmark â„“ğ‘–,ğ‘œâˆˆğ¿ğ‘–âˆ©ğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘–](ğ‘¡ğ‘œ) is settled â€œat the right distanceâ€. Assume also that ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)â‰¤ğ‘ğ‘–. Then it holds that â„“ğ‘–,ğ‘œ is also â€œinformedâ€: ğ‘‘âˆˆğ¶[â„“ğ‘–,ğ‘œ].

Proof
(Lemma 12)

Let ğ‘…ğ‘–,ğ‘œ=ğ·[ğ‘œ,â„“ğ‘–,ğ‘œ](ğ‘¡ğ‘œ) and recall that ğ‘…ğ‘‘=ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ). Assume also that ğ‘…ğ‘‘>ğ‘…ğ‘–,ğ‘œ, because otherwise an exact solution will be anyway discovered before â„“ğ‘–,ğ‘œ is settled and no (ALH) termination could have occurred. Then we have, by Lemma 9:

ğ·â¯â¯â¯[â„“ğ‘–,ğ‘œ,ğ‘‘]â‰¤=â‡’ğ›¤â¯â¯â¯[â„“ğ‘–,ğ‘œ,ğ‘‘]â‰¤=â‰¤ğœ1âˆ’ğ›¬minğ‘…ğ‘–,ğ‘œ+ğ‘…ğ‘‘<(1+ğœ1âˆ’ğ›¬min)â‹…ğ‘…ğ‘‘â‰¤/âˆ— Property  4âˆ—/(1+ğœ1âˆ’ğ›¬min)â‹…ğ‘1/ğœ†ğ‘–(1+ğœ1âˆ’ğ›¬min)â‹…ğ‘›(ğ›¾ğ‘–âˆ’1)/(ğœ†ğ›¾ğ‘–)â‰¤/âˆ— Property  4âˆ—/ğ‘“(ğ‘›)â‹…(ğ·â¯â¯â¯[â„“ğ‘–,ğ‘œ,ğ‘‘])ğœ†ğ‘“(ğ‘›)â‹…(1+ğœ1âˆ’ğ›¬min)ğœ†â‹…ğ‘›(ğ›¾ğ‘–âˆ’1)/ğ›¾ğ‘–ğ‘›ğ‘loglog(ğ‘›)log(ğ‘›)â‹…ğ‘›ğœ†log(1+ğœ1âˆ’ğ›¬min)/log(ğ‘›)â‹…ğ‘›(ğ›¾ğ‘–âˆ’1)/ğ›¾ğ‘–ğ‘›(ğ›¾ğ‘–âˆ’1)/ğ›¾ğ‘–+ğœ‰ğ‘–
for a small constant ğœ‰ğ‘–âˆˆğ›º(loglog(ğ‘›)log(ğ‘›)), i.e., not converging too fast to 0, since ğ‘,ğœ,ğ›¬min,ğœ†âˆˆîˆ»(1), and ğ‘“(ğ‘›)âˆˆîˆ»(logğ‘(ğ‘›)), according to Properties 1, 2 and 4. The last inequality implies that ğ‘‘âˆˆğ¶[â„“ğ‘–,ğ‘œ]. â—»

Assume now some level-j in the hierarchy, such that 1â‰¤ğ‘—<ğ‘–âˆ— where ğ‘–âˆ— is the actual level that corresponds to the query at hand: ğ‘ğ‘–âˆ—âˆ’1<ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)â‰¤ğ‘ğ‘–âˆ— (cf. statement of Theorem 5). The next lemma states that ğ™·ğš€ğ™° will not settle within its initial ball any landmark â„“âˆˆğ¿ğ‘— that is both at the â€œright distanceâ€ (i.e., â„“âˆˆğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘—](ğ‘¡ğ‘œ)) and informed (i.e., ğ‘‘âˆˆğ¶[â„“]). In other words, thre is no chance for the (ALH) termination, if it occurs first, to cause an incorrect â€œguessâ€ by ğ™·ğš€ğ™° for the appropriate level for the query at hand.

Lemma 13
For ğ‘–âˆˆ[ğ‘˜], assume that ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)>ğ‘ğ‘– and also that, while ğ™·ğš€ğ™° grows the initial ball from (ğ‘œ,ğ‘¡ğ‘œ), no (ESC) termination occurs. Then, âˆ€ğ‘—âˆˆ[ğ‘–], no landmark of ğ¿ğ‘—âˆ©ğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘—](ğ‘¡ğ‘œ) contains d in its coverage:

ğ‘‘âˆ‰âˆª1â‰¤ğ‘—â‰¤ğ‘–âˆªâ„“âˆˆğ¿ğ‘—âˆ©ğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘—](ğ‘¡ğ‘œ)ğ¶[â„“]
Proof
(Lemma 13) Let ğ‘…ğ‘‘=ğ·[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ), while ğ‘…ğ‘—,ğ‘œ=ğ·[ğ‘œ,â„“ğ‘—,ğ‘œ](ğ‘¡ğ‘œ) is the actual distance of some level-j landmark â„“ğ‘—,ğ‘œâˆˆğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘—](ğ‘¡ğ‘œ)âˆ©ğ¿ğ‘— from o.

We start by providing a simple proof for the cases of 1â‰¤ğ‘—â‰¤ğ‘–âˆ’1. We shall then handle the case ğ‘—=ğ‘– separately, since it is a little bit more involved.

Fix an arbitrary ğ‘—âˆˆ[ğ‘–âˆ’1]. By the triangle inequality, the following holds:

ğ·[â„“ğ‘—,ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ‘…ğ‘—,ğ‘œ)â‰¥ğ‘…ğ‘‘âˆ’ğ‘…ğ‘—,ğ‘œâ‰¥/âˆ— Property  4âˆ—/(ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)ğ‘“(ğ‘›))1/ğœ†âˆ’(ğ›¤[ğ‘œ,â„“ğ‘—,ğ‘œ](ğ‘¡ğ‘œ))1/ğœ†>(ğ‘ğ‘–ğ‘“(ğ‘›))1/ğœ†âˆ’(ln(ğ‘›)â‹…ğ‘ğ›¿/(ğ‘Ÿ+1)ğ‘—)1/ğœ†=1ğ‘“1/ğœ†(ğ‘›)ğ‘›(ğ›¾ğ‘–âˆ’1)/(ğœ†ğ›¾ğ‘–)âˆ’ln1/ğœ†(ğ‘›)â‹…ğ‘›ğ›¿(ğ›¾ğ‘—âˆ’1)/((ğ‘Ÿ+1)ğœ†ğ›¾ğ‘—)=ğ‘›(ğ›¾ğ‘—âˆ’1)/(ğœ†ğ›¾ğ‘—)â‹…[ğ‘›(ğ›¾ğ‘–âˆ’ğ‘—âˆ’1)/(ğœ†ğ›¾ğ‘–)ğ‘“1/ğœ†(ğ‘›)âˆ’ln1/ğœ†(ğ‘›)ğ‘›(1âˆ’ğ›¿ğ‘Ÿ+1)(ğ›¾ğ‘—âˆ’1)/(ğœ†ğ›¾ğ‘—)]
The strict inequality is due to the facts that ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)>ğ‘ğ‘– and â„“ğ‘—,ğ‘œâˆˆğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘—](ğ‘¡ğ‘œ)â‡’ğ›¤[ğ‘œ,â„“ğ‘—,ğ‘œ](ğ‘¡ğ‘œ)â‰¤ğ‘ğ›¿/(ğ‘Ÿ+1)ğ‘—â‹…ln(ğ‘›).

We apply once more Property 4, to get a lower bound on the Dijkstra-rank ğ›¤[â„“ğ‘—,ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ‘…ğ‘—,ğ‘œ):

ğ›¤[â„“ğ‘—,ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ‘…ğ‘—,ğ‘œ)â‰¥>(ğ·[â„“ğ‘—,ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ‘…ğ‘—,ğ‘œ))ğœ†ğ‘›(ğ›¾ğ‘—âˆ’1)/(ğ›¾ğ‘—)â‹…[ğ‘›(ğ›¾ğ‘–âˆ’ğ‘—âˆ’1)/(ğœ†ğ›¾ğ‘–)ğ‘“1/ğœ†(ğ‘›)âˆ’ln1/ğœ†(ğ‘›)ğ‘›(1âˆ’ğ›¿ğ‘Ÿ+1)(ğ›¾ğ‘—âˆ’1)/(ğœ†ğ›¾ğ‘—)]ğœ†
Recall that, according to Property 3, the rank of d from â„“ğ‘—,ğ‘œ may vary within the TD-metric only by polylogarithmic factors. Therefore, the following inequality is deduced for the free-flow Dijkstra-rank of d from â„“ğ‘—,ğ‘œ:

ğ›¤â¯â¯â¯[â„“ğ‘—,ğ‘œ,ğ‘‘]â‰¥>â‰¥â‰¥>ğ›¤[â„“ğ‘—,ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ‘…ğ‘—,ğ‘œ)polylog(ğ‘›)ğ‘›(ğ›¾ğ‘—âˆ’1)/(ğ›¾ğ‘—)polylog(ğ‘›)â‹…[ğ‘›(ğ›¾ğ‘–âˆ’ğ‘—âˆ’1)/(ğœ†ğ›¾ğ‘–)ğ‘“1/ğœ†(ğ‘›)âˆ’ln1/ğœ†(ğ‘›)ğ‘›(1âˆ’ğ›¿ğ‘Ÿ+1)(ğ›¾ğ‘—âˆ’1)/(ğœ†ğ›¾ğ‘—)]ğœ†ğ‘›(ğ›¾ğ‘—âˆ’1)/(ğ›¾ğ‘—)polylog(ğ‘›)ğ‘“(ğ‘›)â‹…[ğ‘›(ğ›¾ğ‘–âˆ’ğ‘—âˆ’1)/(ğœ†ğ›¾ğ‘–)âˆ’ğ‘“1/ğœ†(ğ‘›)ln1/ğœ†(ğ‘›)ğ‘›(1âˆ’ğ›¿ğ‘Ÿ+1)(ğ›¾ğ‘—âˆ’1)/(ğœ†ğ›¾ğ‘—)]ğœ†ğ‘›ğ›¾ğ‘—âˆ’1ğ›¾ğ‘—+ğ›¾ğ‘–âˆ’ğ‘—âˆ’1ğ›¾ğ‘–â‹…[1âˆ’o(1)]âˆ’îˆ»(loglog(ğ‘›)log(ğ‘›))ğ‘›(ğ›¾ğ‘—âˆ’1)/(ğ›¾ğ‘—)+ğœ‰ğ‘—
where the last inequality holds for

ğœ‰ğ‘—<ğ›¾âˆ’1ğ›¾ğ‘˜â‰¤ğ›¾âˆ’1ğ›¾ğ‘–=1ğ›¾ğ‘–âˆ’1âˆ’1ğ›¾ğ‘–â‰¤1ğ›¾ğ‘—âˆ’1ğ›¾ğ‘–=ğ›¾ğ‘–âˆ’ğ‘—âˆ’1ğ›¾ğ‘–.
This last inequality implies also that ğ‘‘âˆ‰ğ¶[â„“ğ‘—,ğ‘œ].

We shall now study the case ğ‘—=ğ‘–. We fix an arbitrary level-i landmark which is at the â€œright distanceâ€: â„“ğ‘–,ğ‘œâˆˆğ¿ğ‘–âˆ©ğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘–](ğ‘¡ğ‘œ). For sake of contradiction, we assume that, if it is ever settled by the initial ğšƒğ™³ğ™³ ball from (ğ‘œ,ğ‘¡ğ‘œ), â„“ğ‘–,ğ‘œ does not cause an (ESC) termination. This implies (cf. proof of Lemma 10) that:

ğ›¥â¯â¯â¯â¯[â„“ğ‘–,ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ‘…ğ‘–,ğ‘œ)ğ‘…ğ‘–,ğ‘œ<â‡’ğ‘…ğ‘–,ğ‘œ>â‡’ğ‘…ğ‘–,ğ‘œ>(1+ğœ€)ğœ‘(ğ‘Ÿ+1)+ğœ“âˆ’1=:ğœ’ğ›¥â¯â¯â¯â¯[â„“ğ‘–,ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ‘…ğ‘–,ğ‘œ)ğœ’â‰¥ğ·[â„“ğ‘–,ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ+ğ‘…ğ‘–,ğ‘œ)ğœ’â‰¥/âˆ— triangle  ineq. âˆ—/ğ‘…ğ‘‘âˆ’ğ‘…ğ‘–,ğ‘œğœ’ğ‘…ğ‘‘1+ğœ’>/âˆ— Property  4âˆ—/ğ‘›(ğ›¾ğ‘–âˆ’1)/(ğœ†ğ›¾ğ‘–)(1+ğœ’)ğ‘“1/ğœ†(ğ‘›)
(11)
Nevertheless, we also know that for any â„“ğ‘–,ğ‘œâˆˆğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘–](ğ‘¡ğ‘œ) the following holds:

ğ›¤[ğ‘œ,â„“ğ‘–,ğ‘œ](ğ‘¡ğ‘œ)â‰¤â‡’/âˆ— Property  4âˆ—/ğ‘…ğ‘–,ğ‘œ=ğ·[ğ‘œ,â„“ğ‘–,ğ‘œ](ğ‘¡ğ‘œ)â‰¤â‰¤ğ‘ğ›¿/(ğ‘Ÿ+1)ğ‘–ln(ğ‘›)=ğ‘›ğ›¿(ğ›¾ğ‘–âˆ’1)/((ğ‘Ÿ+1)ğ›¾ğ‘–)â‹…ln(ğ‘›)(ğ›¤[ğ‘œ,â„“ğ‘–,ğ‘œ](ğ‘¡ğ‘œ))1/ğœ†ğ‘›ğ›¿(ğ›¾ğ‘–âˆ’1)/((ğ‘Ÿ+1)ğœ†ğ›¾ğ‘–)â‹…ln1/ğœ†(ğ‘›)
(12)
Inequalities (11) and (12) may hold at the same time only if

ğ‘›(1âˆ’ğ›¿ğ‘Ÿ+1)(ğ›¾ğ‘–âˆ’1)/(ğœ†ğ›¾ğ‘–)<(1+ğœ’)ğ‘“1/ğœ†(ğ‘›)ln1/ğœ†(ğ‘›)â‡’(1âˆ’ğ›¿ğ‘Ÿ+1)ğ›¾ğ‘–âˆ’1ğ›¾ğ‘–log(ğ‘›)âˆ’log(ln(ğ‘›))âˆ’log(ğ‘“(ğ‘›))<ğœ†log(1+ğœ’)â‡’log(ğ‘›)<ğ›¾ğ‘–â‹…[log(ln(ğ‘›))+log(ğ‘“(ğ‘›))+ğœ†log(1+ğœ’)](ğ›¾ğ‘–âˆ’1)â‹…(1âˆ’ğ›¿ğ‘Ÿ+1)âˆˆîˆ»(loglog(ğ‘›))
which is certainly impossible for ğ›¾,ğ›¿,ğœ†,ğœ’,ğ‘Ÿâˆˆîˆ»(1), and ğ‘“(ğ‘›)âˆˆpolylog(ğ‘›). This contradiction implies that any landmark ğ‘–âˆˆğ¿ğ‘–âˆˆğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘–](ğ‘¡ğ‘œ) will certainly trigger the (ESC) termination criterion. â—»

The last lemma proves that when an (ALH) termination occurs, ğ™·ğš€ğ™° achieves the desired approximation guarantee with high probability, and also sublinearity in the targeted Dijkstra-rank.

Lemma 14
For ğ‘–âˆ—âˆˆ{2,3,â€¦,ğ‘˜+1}, let ğ‘ğ‘–âˆ—âˆ’1<ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)â‰¤ğ‘ğ‘–âˆ—. Assume also that ğ™·ğš€ğ™° terminated due to the (ALH) criterion. Then, with probability 1âˆ’îˆ»(1ğ‘›), ğ™·ğš€ğ™° returns an (1+ğœ€(1+ğœ€/ğœ“)ğ‘Ÿ+1(1+ğœ€/ğœ“)ğ‘Ÿ+1âˆ’1)âˆ’approximate solution. The expected query-time is îˆ»((ğ‘ğ‘–âˆ—)ğ›¿+ğ‘œ(1)).

Proof
(Lemma 14) We start with the upper bound on the expected query time.

As it was already explained by Lemmas 11â€“13, we know that a successful â€œguessâ€ of ğ‘–âˆ— occurs with probability 1âˆ’îˆ»(1ğ‘›). Then, ğ™·ğš€ğ™° proceeds with the execution of ğšğš€ğ™°+ğ‘–âˆ—, whose expected time is (cf. Theorem 1):

îˆ»((1/ğœŒğ‘–âˆ—)ğ‘Ÿ+1log(1/ğœŒğ‘–âˆ—))=îˆ»((ğ‘ğ‘–âˆ—)ğ›¿+ğ‘œ(1))
since ğœŒğ‘–âˆ—=ğ‘âˆ’ğ›¿/(ğ‘Ÿ+1)ğ‘–âˆ—. In the unlikely event of a wrong guess for the appropriate level, in worst-case ğ™·ğš€ğ™° will falsely assume that ğ‘–âˆ—=ğ‘˜+1, therefore the contribution of a wrong guess to the expected query time is at most îˆ»(1ğ‘›)â‹…ğ‘›ğ›¿+o(1)=ğ‘›âˆ’1+ğ›¿+o(1)âˆˆo(1), i.e., it is indeed negligible.

As for the approximation guarantee, since the analysis for ğšğš€ğ™°+ğ‘–âˆ— is based solely on the quality of the paths via landmarks discovered from ball centers located along a minimum-travel-time od-path ğ‘âˆ—âˆˆğ‘†ğ‘ƒ[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ) (cf. Sect. 4 and the corresponding proof for ğšğš€ğ™° in [17]), it suffices to prove that all the level-(â‰¥ğ‘–âˆ—) landmarks discovered from ball centers which reside at the (unknown) shortest od-path, are â€œinformedâ€ about d.

For an arbitrary ball center ğ‘¤ğ‘–âˆ—,ğ‘—âˆˆğ‘âˆ— and its closest level-i landmark for some ğ‘–â‰¥ğ‘–âˆ—, â„“ğ‘–,ğ‘—âˆˆğ¿ğ‘–, let ğ‘…ğ‘–âˆ—,ğ‘—=ğ·[ğ‘¤ğ‘–âˆ—,ğ‘—,â„“ğ‘–,ğ‘—](ğ‘¡ğ‘œ+ğ·[ğ‘œ,ğ‘¤ğ‘–âˆ—,ğ‘—](ğ‘¡ğ‘œ)). Then, either ğ‘…ğ‘‘â‰¤ğ‘…ğ‘–âˆ—,ğ‘œ+â€¦+ğ‘…ğ‘–âˆ—,ğ‘—, in which case an exact solution is returned, or else the following holds (cf. Lemma 9):

ğ·â¯â¯â¯[â„“ğ‘–,ğ‘—,ğ‘‘]â‰¤ğœ1âˆ’ğ›¬minğ‘…ğ‘–âˆ—,ğ‘—+ğ‘…ğ‘‘<(1+ğœ1âˆ’ğ›¬min)â‹…ğ‘…ğ‘‘â‰¤/âˆ— Property  4âˆ—/(1+ğœ1âˆ’ğ›¬min)â‹…ğ‘›(ğ›¾ğ‘–âˆ’1)/(ğœ†ğ›¾ğ‘–)â‡’ğ›¤â¯â¯â¯[â„“ğ‘–,ğ‘—,ğ‘‘]â‰¤/âˆ— Property  4âˆ—/ğ‘“(ğ‘›)â‹…(ğ·â¯â¯â¯[â„“ğ‘–,ğ‘—,ğ‘‘])ğœ†â‰¤ğ‘“(ğ‘›)â‹…(1+ğœ1âˆ’ğ›¬min)ğœ†â‹…ğ‘›(ğ›¾ğ‘–âˆ’1)/ğ›¾ğ‘–â‰¤ğ‘›[ğ‘loglog(ğ‘›)+ğœ†log(1+ğœ1âˆ’ğ›¬min)]log(ğ‘›)+ğ›¾ğ‘–âˆ’1ğ›¾ğ‘–â‰¤ğ‘›ğ›¾ğ‘–âˆ’1ğ›¾ğ‘–+ğœ‰ğ‘–
for ğ‘,ğœ,ğ›¬min,ğœ†âˆˆîˆ»(1), ğ‘“(ğ‘›)â‰¤logğ‘(ğ‘›), and ğœ‰ğ‘–âˆˆğ›º(loglog(ğ‘›)log(ğ‘›)). Therefore, we conclude again that ğ‘‘âˆˆğ¶[â„“ğ‘–,ğ‘—].

Since all the level-(â‰¥ğ‘–âˆ—) landmarks which were settled from ball centers along the unknown min-cost path are indeed â€œinformedâ€, the analysis of ğšğš€ğ™°+ğ‘–âˆ— (cf. Theorem 1 and [17]) provides the claimed approximation guarantee. â—»

We are now ready to provide the proof of our main theorem for ğ™·ğ™¾ğšğ™½.

Proof
(Theorem 5) Recall that for each level ğ‘–âˆˆ[ğ‘˜]: (i) the targeted Dijkstra-rank is ğ‘ğ‘–=ğ‘›(ğ›¾âˆ’1)/ğ›¾ğ‘–; (ii) the coverage of each level-i landmark contains ğ‘ğ‘–=ğ‘ğ‘–â‹…ğ‘›ğœ‰ğ‘–=ğ‘›(ğ›¾âˆ’1)/ğ›¾ğ‘–+ğœ‰ğ‘– destinations; (iii) the at most ğ¹ğ‘–=(ğ‘ğ‘–)ğœƒ/ğœˆ â€œnearbyâ€ (but not â€œtoo closeâ€) destinations are preprocessed with ğ™±ğ™¸ğš‚+, while the remaining ğ‘ğ‘–âˆ’ğ¹ğ‘– â€œfarawayâ€ destinations are preprocessed with ğšƒğšğ™°ğ™¿.

We start with the analysis of the preprocessing requirements of ğ™·ğ™¾ğšğ™½. We wish to bound the preprocessing requirements with (ğ‘˜+1)â‹…ğ‘›2âˆ’ğ›½, for a sufficiently small (but still, away from 0) ğ›½>0. We make the appropriate choices of our tuning parameters (cf. Theorem 4 and Corollary 2), so that in each level we are able to guarantee that the expected preprocessing requirements are ğ”¼{ğ‘†ğ‘–} , ğ”¼{ğ‘ƒğ‘–}âˆˆğ‘›2âˆ’ğ›½+o(1).

We compute the requirements of level-i, for each ğ‘–âˆˆ[ğ‘˜]. For this level, we generate |ğ¿ğ‘–|=ğ‘›1âˆ’ğœ”ğ‘– landmarks, where ğœ”ğ‘–=ğ›¿ğ‘Ÿ+1â‹…ğ›¾ğ‘–âˆ’1ğ›¾ğ‘–, each of which possesses summaries for (almost) all the ğ‘ğ‘– destinations contained in its own area of coverage. Based on the analysis of the preprocessing phase of ğ™µğ™»ğ™°ğšƒ (cf. Theorem 4), but now restricting ourselves within the coverage of each landmark, we know that the overall space preprocessing requirements of level-i are bounded as follows.

ğ”¼{ğ‘†ğ‘–}âˆˆ=âŠ†îˆ»(ğ”¼{|ğ¿ğ‘–|}â‹…(ğ¹2ğ‘–polylog(ğ¹ğ‘–)+ğ‘‡1âˆ’ğœƒ(ğ‘ğ‘–âˆ’ğ¹ğ‘–)))îˆ»(ğ‘›1âˆ’ğœ”ğ‘–â‹…[ğ‘›2ğœƒğœˆ(ğ›¾ğ‘–âˆ’1ğ›¾ğ‘–+ğœ‰ğ‘–)+o(1)+ğ‘›ğ›¼(1âˆ’ğœƒ)+ğ›¾ğ‘–âˆ’1ğ›¾ğ‘–+ğœ‰ğ‘–])ğ‘›1âˆ’ğœ”ğ‘–+o(1)â‹…[ğ‘›2ğœƒğœˆ+ğ‘›1+ğ›¼(1âˆ’ğœƒ)]
since we chose ğœ‰ğ‘–âˆˆ(ğ›º(loglog(ğ‘›)log(ğ‘›)) , 1âˆ’ğ›¾âˆ’ğ‘–). Similarly, the time preprocessing is bounded as follows.

ğ”¼{ğ‘ƒğ‘–}âˆˆîˆ»(ğ”¼{|ğ¿ğ‘–|}â‹…(ğ¹2ğ‘–polylog(ğ¹ğ‘–)loglog(ğ¾max)+ğ‘‡1âˆ’ğœƒ(ğ‘ğ‘–âˆ’ğ¹ğ‘–)log(ğ‘ğ‘–âˆ’ğ¹ğ‘–)))=îˆ»(ğ‘›1âˆ’ğœ”ğ‘–â‹…[ğ‘›2ğœƒğœˆ(ğ›¾ğ‘–âˆ’1ğ›¾ğ‘–+ğœ‰ğ‘–)+o(1)+ğ‘›ğ›¼(1âˆ’ğœƒ)+ğ›¾ğ‘–âˆ’1ğ›¾ğ‘–+ğœ‰ğ‘–+ğ‘œ(1)])âŠ†ğ‘›1âˆ’ğœ”ğ‘–+o(1)â‹…[ğ‘›2ğœƒğœˆ+o(1)+ğ‘›1+ğ›¼(1âˆ’ğœƒ)]
Since we have chosen ğœƒ=ğœˆ+ğ›¼ğœˆ2+ğ›¼ğœˆ, we can ensure that:

ğ”¼{ğ‘†ğ‘–} , ğ”¼{ğ‘ƒğ‘–}âˆˆğ‘›2âˆ’ğœ”ğ‘–+ğ›¼(1âˆ’ğœƒ)+o(1)=ğ‘›2âˆ’ğ›½ğ‘–+o(1)
where we have set ğ›½ğ‘–=ğœ”ğ‘–+ğ›¼(1âˆ’ğœƒ)=ğ›¿â‹…(ğ›¾ğ‘–âˆ’1)(ğ‘Ÿ+1)â‹…ğ›¾ğ‘–âˆ’12ğœ†+1. Observe that, by demanding that ğ›¿>ğ›¾ğ›¾âˆ’1â‹…ğ‘Ÿ+12ğœ†+1, we can be sure that ğ›½=ğ›¿â‹…(ğ›¾âˆ’1)(ğ‘Ÿ+1)â‹…ğ›¾âˆ’12ğœ†+1=minğ‘–âˆˆ[ğ‘˜+1]{ğ›¿â‹…(ğ›¾ğ‘–âˆ’1)(ğ‘Ÿ+1)â‹…ğ›¾ğ‘–âˆ’12ğœ†+1}>0.

The overall preprocessing requirements of ğ™·ğ™¾ğšğ™½ are ğ”¼{ğ‘†ğ™·ğ™¾ğšğ™½} , ğ”¼{ğ‘ƒğ™·ğ™¾ğšğ™½}âˆˆ(ğ‘˜+1)â‹…ğ‘›2âˆ’ğ›½+o(1)=ğ‘›2âˆ’ğ›½+log(ğ‘˜+1)log(ğ‘›)+o(1)=ğ‘›2âˆ’ğ›½+o(1) for ğ‘˜âˆˆîˆ»(loglog(ğ‘›)).

We continue with the analysis of the query algorithm ğ™·ğš€ğ™° of ğ™·ğ™¾ğšğ™½. We begin with the probability of ğ™·ğš€ğ™° making a correct guess for the appropriate level ğ‘–âˆ— for the query at hand, provided that it was terminated due to the (ğ€ğ‹ğ‡) criterion.

Lemma 11 proves that, with probability 1âˆ’îˆ»(1ğ‘›), at least one appearance of a level-ğ‘–âˆ— landmark occurs in the ring of ğ‘–âˆ— around (ğ‘œ,ğ‘¡ğ‘œ): ğ¿ğ‘–âˆ—âˆ©ğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘–âˆ—](ğ‘¡ğ‘œ)â‰ âˆ….

Lemma 12 then proves that the first level-ğ‘–âˆ— landmark â„“ğ‘–âˆ—,ğ‘œ settled by the initial ğšƒğ™³ğ™³ ball within ğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘–âˆ—](ğ‘¡ğ‘œ) is indeed an â€œinformedâ€ landmark: ğ‘‘âˆˆğ¶[â„“ğ‘–âˆ—,ğ‘œ].

Lemma 13 proves that no landmark of a previous level ğ‘—<ğ‘–âˆ—, which is settled before â„“ğ‘–âˆ—,ğ‘œ, can be at the â€œright distanceâ€ and â€œinformedâ€, without causing an (ESC) termination: âˆ€â„“âˆˆâˆªğ‘—âˆˆ[ğ‘–âˆ—âˆ’1](ğ¿ğ‘—âˆ©ğ‘…ğ¼ğ‘ğº[ğ‘œ;ğ‘—](ğ‘¡ğ‘œ)), ğ‘‘âˆ‰ğ¶[â„“], or settling â„“ implies (ESC) termination.

For any landmark â„“âˆˆâˆªğ‘˜+1ğ‘—=ğ‘–âˆ—+1ğ¿ğ‘—, if we settle â„“ before â„“ğ‘–âˆ—,ğ‘œ and it happens that ğ‘‘âˆˆğ¶[â„“] (i.e., â„“ is â€œinformedâ€), this event will not interrupt the guessing procedure of ğ™·ğš€ğ™°, because it is not in the ring corresponding to the level containing â„“.

Therefore we conclude that, in the case of an (ALH) termination, with probability 1âˆ’îˆ»(1ğ‘›), the â€œguessâ€ of the appropriate level-ğ‘–âˆ— is indeed correct.

We now turn to the approximation guarantee. If ğ™·ğš€ğ™° terminates because of settling d then we have an exact answer. If the (ğ„ğ’ğ‚) criterion caused termination, then Lemma 10.(ii) shows that we get the claimed approximation guarantee. If the (ğ€ğ‹ğ‡) criterion caused termination, then Lemma 14 states that we get the same approximation guarantee, with high probability.

Finally, regarding the query-time of ğ™·ğš€ğ™°, note that this is dominated by the scenario in which the (ALH) criterion causes termination (if the initial ğšƒğ™³ğ™³ ball settled the destination d, or terminated due to the (ESC) criterion, this can only improve the performance of ğ™·ğš€ğ™°). Again from Lemma 14 we know that the expected query time in this case is îˆ»(ğ‘ğ›¿+o(1)ğ‘–âˆ—), where ğ‘–âˆ—âˆˆ{2,3,â€¦,ğ‘˜+1} is the appropriate level for the query at hand: ğ‘ğ‘–âˆ—âˆ’1=ğ‘›ğ›¾ğ‘–âˆ—âˆ’1âˆ’1ğ›¾ğ‘–âˆ—âˆ’1<ğ›¤[ğ‘œ,ğ‘‘](ğ‘¡ğ‘œ)â‰¤ğ‘›ğ›¾ğ‘–âˆ—âˆ’1ğ›¾ğ‘–âˆ—=ğ‘ğ‘–âˆ—. The unlikely event of guessing a wrong value instead of ğ‘–âˆ— has, as was already explained in the the proof of Lemma 14, a negligible contribution to the overall expected query-time. â—»

Conclusions
We presented and theoretically analyzed three oracles for sparse networks with a time-dependent, piecewise linear, and periodic travel-time metric via an axiomatic approach based on four fundamental properties of the arc-cost metric. These properties were inspired and verified in real-world road network instances. Our axiomatic approach achieves (for the first time): (a) subquadratic time and space preprocessing, which is independent in the amount of disconcavity of the travel-time metric (expressed by the parameter ğ¾âˆ—, which is the number of concavity spoiling breakpoints in all arc functions); (b) sublinear query time not only on the network size n but also on the (unknown) Dijkstra-rank of the query at hand.

The key novelties of our approach are: (i) a remarkably simple and novel FPTAS (ğšƒğšğ™°ğ™¿) for efficiently computing one-to-all distance summaries (a.k.a. query profiles in the algorithm engineering jargon) from a selected vertex to all other vertices in the network; (ii) the organization of a small subset of vertices (landmarks) in a hierarchical structure in such a way that landmarks at the lower levels of the hierarchy posses travel-time summaries to â€œnearbyâ€ destinations, while landmarks at the upper levels of the hierarchy possess distance summaries also to â€œfarawayâ€ (and eventually to all) destinations. This allowed for an adaptive query algorithm (ğ™·ğš€ğ™°) which achieves sublinearity compared to the Dijkstra-rank of the query at hand, rather than just the network size.

Directions for future research constitute the further improvement of the bounds of the presented TD-oracles, as well as an extensive practical assessment and simplification of the hierarchical (ğ™·ğ™¾ğšğ™½) oracle.

