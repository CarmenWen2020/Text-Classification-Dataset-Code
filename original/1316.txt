Abstract
We consider the following dynamic load-balancing process: given an underlying graph G with n nodes, in each step ğ‘¡â‰¥0, a random edge is chosen, one unit of load is created, and placed at one of the endpoints. In the same step, assuming that loads are arbitrarily divisible, the two nodes balance their loads by averaging them. We are interested in the expected gap between the minimum and maximum loads at nodes as the process progresses, and its dependence on n and on the graph structure. Peres et al. (Random Struct Algorithms 47(4):760â€“775, 2015) studied the variant of this process, where the unit of load is placed in the least loaded endpoint of the chosen edge, and the averaging is not performed. In the case of dynamic load balancing on the cycle of length n the only known upper bound on the expected gap is of order îˆ»(ğ‘›logğ‘›), following from the majorization argument due to the same work. In this paper, we leverage the power of averaging and provide an improved upper bound of îˆ»(ğ‘›âˆšlogğ‘›). We introduce a new potential analysis technique, which enables us to bound the difference in load between k-hop neighbors on the cycle, for any ğ‘˜â‰¤ğ‘›/2. We complement this with a â€œgap coveringâ€ argument, which bounds the maximum value of the gap by bounding its value across all possible subsets of a certain structure, and recursively bounding the gaps within each subset. We also show that our analysis can be extended to the specific instance of Harary graphs. On the other hand, we prove that the expected second moment of the gap is lower bounded by Î©(ğ‘›). Additionally, we provide experimental evidence that our upper bound on the gap is tight up to a logarithmic factor.

Introduction
This paper considers balls-into-bins processes where a sequence of m weights are placed into n bins via some randomized procedure, with the goal of minimizing the load imbalance between the most loaded and the least loaded bin. This family of randomized processes has been used to model several practical allocation problems, such as load-balancing [3, 14, 20], hashing [9], or even relaxed data structures [1, 2].

The classic formulation of this problem is known as d-choice process, in each step, a new weight is generated, and is placed in the least loaded of d randomly chosen bins. If ğ‘‘=1, then we have the uniform random choice scheme, whose properties are well understood, e.g. [18]. In particular, if we place ğ‘š=ğ‘› unit weights into the bins, then it is known that the most loaded bin will have expected Î˜(logğ‘›/loglogğ‘›) load, whereas if ğ‘š=Î©(ğ‘›logğ‘›) we have that the expected maximum load is ğ‘š/ğ‘›+Î˜(ğ‘šlogğ‘›/ğ‘›â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆš). Seminal work by Azar et al. [3] showed that, if we place n unit weights into n bins by the d-choice process with ğ‘‘â‰¥2, then, surprisingly, the maximum load is reduced to Î˜(loglogğ‘›/logğ‘‘). A technical tour-de-force by Berenbrink, Czumaj, Steger, and VÃ¶cking [4] extended this result to the â€œheavily-loadedâ€ case where ğ‘šâ‰«ğ‘›, showing that in this case the maximum load is ğ‘š/ğ‘›+loglogğ‘›/logğ‘‘+ğ‘‚(1) with failure probability at most 1/ polyğ‘›. An elegant alternative proof for a slightly weaker version of this result was later provided by Talwar and Wieder [23].

More recently, Peres et al. [17] considered the graphical version of this process, where the bins are the vertices of a graph, an edge is chosen at every step, and the weight is placed at the less loaded endpoint of the edge, breaking ties arbitrarily. (The reader will notice that the classic 2-choice process corresponds to the case where the graph is a clique.) The authors focus on the evolution of the gap between the highest and lowest loaded bins, showing that, for graphs of ğ›½-edge-expansion [17], this gap is ğ‘‚(logğ‘›/ğ›½), with probability 1âˆ’1/polyğ‘›.

Another closely related line of work considers static load-balancing processes, where each node in a graph starts with an arbitrary initial load, and the endpoints average their current loads at each step. Note that load balancing schemes which are commonly used in this setting are usually more involved than simply averaging the loads of the endpoints of the randomly chosen node, but the tools used in their analysis are still applicable to the static version of our process. To analyze such processes, it is common to map the process to a Markov chain and analyse its convergence [6, 10, 12], or derive an upper bound on a potential function which captures the discrepancy between the loads [5]. In both cases, the gap between the highest and lowest loaded bins can be characterized by the spectral gap of the graph [7, 11, 19, 21, 22].

By contrast to these two lines of previous work, in this paper we consider a graphical load balancing in the dynamic case, where weights arrive at each step rather than being statically allocated initially, but we allow balancing via continuous averaging, i.e. the resulting weights after the balancing step equal the average of the sum of the weights of the two nodes prior to balancing. Thus, our averaging step is more powerful relative to d-choice or static averaging, but it is applied in the more challenging dynamic scenario.

We will focus on the gap in the dynamic case on graphs of low expansion, specifically on cycles. In [17], it is shown that, in this case (but without averaging), the gap is ğ‘‚(ğ‘›logğ‘›) both in expectation and with high probability. The techniques used in [17] imply that the averaging of the loads does not worsen the gap in expectation, our aim is to show that it actually helps to reduce it. Also, directly applying the tools from the static process to the dynamic one results in the upper bound which is larger than ğ‘‚(ğ‘›logğ‘›). Upper bounding the gap for cycle graphs is known to be a challenging open problem [16]. As suggested in [17], to deal with the cycle case, there is a need for a new approach, which takes the structure of the load balancing graph into account.

Contribution
In this paper, we address this question for the case where averaging is performed on a cycle graph. Let Gap(t) be a difference between highest and lowest loads of the nodes at time step t. We provide the upper bound on the gap in the dynamic, heavily-loaded case, via a new potential argument. More formally, for any ğ‘¡>0, we show that for a cycle graph with n vertices:

ğ”¼[ğºğ‘ğ‘(ğ‘¡)]=ğ‘‚(ğ‘›âˆšlog(ğ‘›)).
(1)
We show that our technique can be used to upper bound the gap for the 4-connected Harary Graph. We complement this result with a lower bound of Î©(ğ‘›) on ğ”¼[(ğºğ‘ğ‘(ğ‘¡))2]. Further, we provide experimental evidence that the gap is of order Î˜(ğ‘›âˆš), making our upper bound accurate up to a logğ‘› factor. Our results extend to the case where the load generated at each node is weighted according to some distribution whose second moment is bounded. Formally, we allow our input to come from any distribution W, such that ğ”¼[ğ‘Š2]â‰¤ğ‘€2, for some ğ‘€>0.

Technical Overview
Our upper bound result is based on two main ideas. The first introduces a new parametrized hop-potential function, which measures the squared difference in load between any k-hop neighbors on the graph, where ğ‘˜â‰¥1 is a fixed hop parameter. Let ğº=(ğ‘‰,ğ¸) be our input graph, where ğ‘‰={1,2,â€¦,ğ‘›}. Throughout the paper, for any 1â‰¤ğ‘–â‰¤ğ‘› we assume that the nodes ğ‘–+ğ‘› and ğ‘–âˆ’ğ‘› are the same as the node i. Let ğ‘¥ğ‘–(ğ‘¡) be the load of node i at step t. Then, we define the k-hop potential as:

ğœ™ğ‘˜(ğ‘¡)=âˆ‘ğ‘–=1ğ‘›(ğ‘¥ğ‘–(ğ‘¡)âˆ’ğ‘¥ğ‘–+ğ‘˜(ğ‘¡))2.
The first technical step in the proof is to understand the expected (â€œsteady-stateâ€) value of the k-hop potential. We show that, in expectation, the k-hop potential has a recursive structure. While the expected values of k-hop potentials cannot be computed precisely, we can isolate upper and lower bounds on their values for cycles. In particular, for the k-hop potential on an n-cycle, we prove the following bound:

ğ”¼[ğœ™ğ‘˜(ğ‘¡)]â‰¤ğ‘˜(ğ‘›âˆ’ğ‘˜)âˆ’1,âˆ€ğ‘˜â‰¥1.
(2)
In the second technical step, we shift gears, aiming to bound the maximum possible value of the gap between any two nodes, leveraging the fact that we understand the hop potential for any ğ‘˜â‰¥1. We achieve this via a â€œgap coveringâ€ technique, which characterizes the maximum value of the gap across all possible subsets of a certain type.

More precisely, in the case of a cycle of length ğ‘›=2ğ‘š, for each node i and hop count k, we define the set family ğ´ğ‘–ğ‘˜ to be formed of nodes {ğ‘–,ğ‘–+2ğ‘šâˆ’ğ‘˜,ğ‘–+2Ã—2ğ‘šâˆ’ğ‘˜,ğ‘–+3Ã—2ğ‘šâˆ’ğ‘˜,â€¦} (since we are on a cycle, ğ‘–=ğ‘–+2ğ‘šâˆ’ğ‘˜2ğ‘˜). Then for any 1â‰¤ğ‘˜â‰¤ğ‘š, we will have

âˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡)â‰¤âˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡)+ğ‘›2ğ‘šâˆ’ğ‘˜â€¾â€¾â€¾â€¾â€¾âˆšğœ™2ğ‘šâˆ’ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆš,
(3)
where ğºğ‘ğ‘ğ‘‹(ğ‘¡) is the maximal gap inside the set X at time t. Intuitively, this result allows us recursively characterize the gap value at various â€œresolutionsâ€ across the graph.

Finally, we notice that we can â€œcoverâ€ the gap between any two nodes by carefully unwinding the recursion in the above inequality, considering all possible subsets of a well-chosen structure, and recursively bounding the gaps within each subset (this step is particularly delicate in the case where n is not a power of two, please see Sect. 5). We obtain that

ğ”¼[ğºğ‘ğ‘(ğ‘¡)]=ğ‘‚(ğ‘›âˆšlog(ğ‘›)),
(4)
as claimed. The logarithmic slack is caused by the second term on the right-hand-side of (2). We note that this technique extends to the case where inserted items are weighted, where the weights are coming from some distribution of bounded second moment.

Lower Bound
It is interesting to ask whether this upper bound is tight. To examine this question, we revisit the recursive structure of the k-hop potential, which we used to obtain the upper bound in Eq. (3). We can leverage this structure to obtain a lower bound on the expected k-hop potential as well. Starting from this lower bound, we can turn the upper bound argument â€œinside out,â€ to obtain a linear lower bound on the expected squared gap:

ğ”¼[ğºğ‘ğ‘(ğ‘¡)2]=Î©(ğ‘›).
(5)
We conjecture that both upper and lower bounds on the expected gap are of order ğ‘‚(ğ‘›âˆš) (given that ğ¸[ğ‘Š2] is constant), and examine this claim empirically in Sect. 6.

Extensions and Discussion
We believe that the analysis template we described above is general, and can be extended to other graph families, such as regular expanders. Here, we focus on obtaining tight bounds on the gap for cycles, which is technically non-trivial, and leave the extensions for other graph families as future work. To substantiate our generality claim, we exhibit an application of our analysis technique to the specific instance of Harary graphs [13] in Sect. 7. More precisely, we provide the upper bound on a gap for a graph on n vertices, where each vertex i is connected with edges to vertices ğ‘–âˆ’2,ğ‘–âˆ’1,ğ‘–+1 and ğ‘–+2.

We discuss the relation between our results and bounds for the graphical power-of-two process on a cycle [17] in Sect. 8.

Related Work
As we have already discussed broad background, we will now mainly focus on the technical differences from previous work. As stated, we are the first to specifically consider the dynamic case for continuous averaging on cycles. The static case has been studied both with continuous averaging [5,6,7, 10,11,12, 19, 22] and discrete averaging [21]. However, their techniques would not apply (or would result in a worse bound) in our case, since we consider that weights would be introduced dynamically, during the processesâ€™ execution.

To our knowledge, the only non-trivial upper bound on the gap of the process we consider which would follow from previous work is of îˆ»(ğ‘›logğ‘›), by the potential analysis of [17]: they consider 2-choice load balancing, and one can re-do their potential analysis for (continuous) averaging load balancing, yielding the same bounds. (Specifically, one can use the same definition of the potential Î“(ğ‘¡) as in this reference, and will obtain the same upper bounds, since the pairwise load balancing we consider has slightly stronger guarantees.) However, as our bounds show, the resulting analysis is quite loose in the case of cycle graphs, yielding an Î©(ğ‘›âˆš) gap between the bounds yielded by these techniques. Technically, this is a consequence of the majorization technique used in [17], which links dynamic averaging on the cycle with a very weak form of averaging on the clique. Reference [8] studies the performance differences between various load-balancing techniques; specifically, it shows that continuous averaging cannot improve the bound on the gap relative to d-choice on the clique. Unfortunately, this result does not seem to extend to arbitrary graphs.

Our potential analysis is substantially different from that of [17], as they track a sum of exponential potentials across the entire graph. By contrast, our analysis tracks the squared load differences between k-hop neighbors, establishing recurrences between these potentials. We note that this is also different from the usual square potentials used for analyzing averaging load balancing, e.g. [15], which usually compare against the global mean, as opposed to pairwise potential differences. Our approach is also different from the classic analyses of e.g. [3], which perform probabilistic induction on the number of bins at a given load, assuming a clique.

Generally, our technique can be seen as performing the induction needed to bound the gap not on the bin loads, as is common in previous work, e.g. [3], but over the topology of the graph. This approach is natural, since we wish to obtain tight, topology-specific bounds, but we believe we are the first to propose and analyze it successfully.

Averaging on the Cycle: Upper Bounding the Gap
Preliminaries
We consider a cycle graph ğº=(ğ‘‰,ğ¸) where ğ‘‰={1,2,â€¦,ğ‘›}, such that each node i is connected to its left and right neighbors, ğ‘–âˆ’1 and ğ‘–+1 (recall that for any 1â‰¤ğ‘–â‰¤ğ‘› the nodes ğ‘–+ğ‘› and ğ‘–âˆ’ğ‘› are the same as the node i).

We consider a stochastic process following real time ğ‘¡â‰¥0, in which, at each step ğ‘¡+1, a ball of weight ğ‘¤(ğ‘¡)â‰¥0 is generated from a same distribution W. We associate a real-valued load ğ‘¥ğ‘–(ğ‘¡) with each node i (ğ‘¥ğ‘–(ğ‘¡) is the value after t steps). Initially, we have that ğ‘¥ğ‘–(0)=0 for every node i. At step ğ‘¡+1, an edge (ğ‘–,ğ‘–+1) is chosen uniformly at random, and the two endpoint nodes update their weights as follows:

ğ‘¥ğ‘–(ğ‘¡+1)=ğ‘¥ğ‘–+1(ğ‘¡+1)=ğ‘¥ğ‘–(ğ‘¡)+ğ‘¥ğ‘–+1(ğ‘¡)+ğ‘¤(ğ‘¡)2.
We will assume that the second moment of the distribution W is bounded. That is: ğ¸[ğ‘Š2]â‰¤ğ‘€2, for some ğ‘€>0. For simplicity, we will assume that weights are normalized by M. This gives us that ğ”¼[ğ‘Š2]â‰¤1.

Let ğ‘‹(ğ‘¡)=(ğ‘¥1(ğ‘¡),ğ‘¥2(ğ‘¡),â€¦,ğ‘¥ğ‘›(ğ‘¡)) be the vector of the bin weights after step t. First, we define the following potential functions:

âˆ€ğ‘˜âˆˆ{1,2,â€¦,ğ‘›âˆ’1}:ğœ™ğ‘˜(ğ‘¡):=âˆ‘ğ‘–=1ğ‘›(ğ‘¥ğ‘–(ğ‘¡)âˆ’ğ‘¥ğ‘–+ğ‘˜(ğ‘¡))2.
Notice that for every 1â‰¤ğ‘–â‰¤ğ‘›, we have that ğœ™ğ‘–(ğ‘¡)=ğœ™ğ‘›âˆ’ğ‘–(ğ‘¡). We want to analyze what is the value of these functions in expectation after an additional ball is thrown, for a given load vector X(t).

We start with ğœ™1(ğ‘¡+1):

ğ”¼[ğœ™1(ğ‘¡+1)|ğ‘‹(ğ‘¡),ğ‘¤(ğ‘¡)]=âˆ‘ğ‘–=1ğ‘›1ğ‘›((ğ‘¥ğ‘–(ğ‘¡)+ğ‘¥ğ‘–+1(ğ‘¡)+ğ‘¤(ğ‘¡)2âˆ’ğ‘¥ğ‘–+2(ğ‘¡))2+(ğ‘¥ğ‘–(ğ‘¡)+ğ‘¥ğ‘–+1(ğ‘¡)+ğ‘¤(ğ‘¡)2âˆ’ğ‘¥ğ‘–âˆ’1(ğ‘¡))2+âˆ‘ğ‘—â‰ ğ‘–âˆ’1,ğ‘–,ğ‘–+1(ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+1(ğ‘¡))2).
(6)
Notice that:

âˆ‘ğ‘–=1ğ‘›âˆ‘ğ‘—â‰ ğ‘–âˆ’1,ğ‘–,ğ‘–+1(ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+1(ğ‘¡))2=(ğ‘›âˆ’3)ğœ™1(ğ‘¡).
(7)
Hence we need to bound the remaining terms:

âˆ‘ğ‘–=1ğ‘›((ğ‘¥ğ‘–(ğ‘¡)+ğ‘¥ğ‘–+1(ğ‘¡)+ğ‘¤(ğ‘¡)2âˆ’ğ‘¥ğ‘–+2(ğ‘¡))2+(ğ‘¥ğ‘–(ğ‘¡)+ğ‘¥ğ‘–+1(ğ‘¡)+ğ‘¤(ğ‘¡)2âˆ’ğ‘¥ğ‘–âˆ’1(ğ‘¡))2)=âˆ‘ğ‘–=1ğ‘›(2ğ‘¥ğ‘–(ğ‘¡)2+2ğ‘¥ğ‘–+1(ğ‘¡)2+2ğ‘¤(ğ‘¡)2+4ğ‘¥ğ‘–(ğ‘¡)ğ‘¥ğ‘–+1(ğ‘¡)4+ğ‘¥ğ‘–+2(ğ‘¡)2+ğ‘¥ğ‘–âˆ’1(ğ‘¡)2âˆ’(ğ‘¥ğ‘–(ğ‘¡)+ğ‘¥ğ‘–+1(ğ‘¡))(ğ‘¥ğ‘–âˆ’1(ğ‘¡)+ğ‘¥ğ‘–+2(ğ‘¡))).
where we used the fact that terms, which are linear in w(t), cancel out.

The right side of the above equation can be rewritten as:

âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–(ğ‘¡)22+âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–+1(ğ‘¡)22+âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–+2(ğ‘¡)2+âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–âˆ’1(ğ‘¡)2+âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–(ğ‘¡)ğ‘¥ğ‘–+1(ğ‘¡)âˆ’âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–(ğ‘¡)ğ‘¥ğ‘–âˆ’1(ğ‘¡)âˆ’âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–+1(ğ‘¡)ğ‘¥ğ‘–+2(ğ‘¡)âˆ’âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–(ğ‘¡)ğ‘¥ğ‘–+2(ğ‘¡)âˆ’âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–+1(ğ‘¡)ğ‘¥ğ‘–âˆ’1(ğ‘¡)+ğ‘›ğ‘¤(ğ‘¡)22=3âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–(ğ‘¡)2âˆ’âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–(ğ‘¡)ğ‘¥ğ‘–+1(ğ‘¡)âˆ’2âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–(ğ‘¡)ğ‘¥ğ‘–+2(ğ‘¡)+ğ‘›ğ‘¤(ğ‘¡)22=âˆ‘ğ‘–=1ğ‘›(ğ‘¥ğ‘–(ğ‘¡)âˆ’ğ‘¥ğ‘–+1(ğ‘¡))22+âˆ‘ğ‘–=1ğ‘›(ğ‘¥ğ‘–(ğ‘¡)âˆ’ğ‘¥ğ‘–+2(ğ‘¡))2+ğ‘›ğ‘¤(ğ‘¡)22=ğœ™1(ğ‘¡)2+ğœ™2(ğ‘¡)+ğ‘›ğ‘¤(ğ‘¡)22.
By using the above equation and Eq. (7) in Eq. (6) we get that

ğ”¼[ğœ™1(ğ‘¡+1)|ğ‘‹(ğ‘¡),ğ‘¤(ğ‘¡)]=ğ‘›âˆ’2ğ‘›ğœ™1(ğ‘¡)+12(ğ‘¤(ğ‘¡)2âˆ’ğœ™1(ğ‘¡)ğ‘›)+ğœ™2(ğ‘¡)ğ‘›.
Now, we proceed with calculating the expected value of ğœ™ğ‘˜(ğ‘¡+1),

for 2â‰¤ğ‘˜â‰¤âŒŠğ‘›/2âŒ‹:

ğ”¼[ğœ™ğ‘˜(ğ‘¡+1)|ğ‘‹(ğ‘¡),ğ‘¤(ğ‘¡)]=âˆ‘ğ‘–=1ğ‘›1ğ‘›((ğ‘¥ğ‘–(ğ‘¡)+ğ‘¥ğ‘–+1(ğ‘¡)+ğ‘¤(ğ‘¡)2âˆ’ğ‘¥ğ‘–âˆ’ğ‘˜(ğ‘¡))2+(ğ‘¥ğ‘–(ğ‘¡)+ğ‘¥ğ‘–+1(ğ‘¡)+ğ‘¤(ğ‘¡)2âˆ’ğ‘¥ğ‘–+1âˆ’ğ‘˜(ğ‘¡))2+(ğ‘¥ğ‘–(ğ‘¡)+ğ‘¥ğ‘–+1(ğ‘¡)+ğ‘¤(ğ‘¡)2âˆ’ğ‘¥ğ‘–+ğ‘˜(ğ‘¡))2+(ğ‘¥ğ‘–(ğ‘¡)+ğ‘¥ğ‘–+1(ğ‘¡)+ğ‘¤(ğ‘¡)2âˆ’ğ‘¥ğ‘–+1+ğ‘˜(ğ‘¡))2+âˆ‘ğ‘—â‰ ğ‘–âˆ’ğ‘˜,ğ‘–+1,ğ‘–,ğ‘–+1(ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+ğ‘˜(ğ‘¡))2).
Notice that:

1ğ‘›âˆ‘ğ‘–=1ğ‘›âˆ‘ğ‘—â‰ ğ‘–âˆ’ğ‘˜,ğ‘–+1âˆ’ğ‘˜,ğ‘–+ğ‘˜,ğ‘–+1+ğ‘˜(ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+ğ‘˜(ğ‘¡))2=ğ‘›âˆ’4ğ‘›ğœ™ğ‘˜(ğ‘¡).
In the similar way as for ğœ™1(ğ‘¡) the remaining terms can be rewritten as:

âˆ‘ğ‘–=1ğ‘›1ğ‘›(ğ‘¥ğ‘–(ğ‘¡)2+ğ‘¥ğ‘–+1(ğ‘¡)2+ğ‘¤(ğ‘¡)2+2ğ‘¥ğ‘–(ğ‘¡)ğ‘¥ğ‘–+1(ğ‘¡)+4ğ‘¥2ğ‘–(ğ‘¡)âˆ’(ğ‘¥ğ‘–(ğ‘¡)+ğ‘¥ğ‘–+1(ğ‘¡))(ğ‘¥ğ‘–+ğ‘˜(ğ‘¡)+ğ‘¥ğ‘–+ğ‘˜+1(ğ‘¡)+ğ‘¥ğ‘–âˆ’ğ‘˜(ğ‘¡)+ğ‘¥ğ‘–âˆ’ğ‘˜+1(ğ‘¡)))=1ğ‘›(ğ‘›ğ‘¤(ğ‘¡)2+6âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–(ğ‘¡)2+2âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–(ğ‘¡)ğ‘¥ğ‘–+1(ğ‘¡)âˆ’4âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–(ğ‘¡)ğ‘¥ğ‘–+ğ‘˜(ğ‘¡)âˆ’2âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–(ğ‘¡)ğ‘¥ğ‘–+ğ‘˜+1(ğ‘¡)âˆ’2âˆ‘ğ‘–=1ğ‘›ğ‘¥ğ‘–(ğ‘¡)ğ‘¥ğ‘–+ğ‘˜âˆ’1(ğ‘¡))=2ğ‘›ğœ™ğ‘˜(ğ‘¡)+(ğ‘¤(ğ‘¡)2âˆ’ğœ™1(ğ‘¡)ğ‘›)+ğœ™ğ‘˜+1(ğ‘¡)ğ‘›+ğœ™ğ‘˜âˆ’1(ğ‘¡)ğ‘›.
Hence, we get that:

ğ”¼[ğœ™ğ‘˜(ğ‘¡+1)|ğ‘‹(ğ‘¡),ğ‘¤(ğ‘¡)]=ğ‘›âˆ’2ğ‘›ğœ™ğ‘˜(ğ‘¡)+(ğ‘¤(ğ‘¡)2âˆ’ğœ™1(ğ‘¡)ğ‘›)+ğœ™ğ‘˜+1(ğ‘¡)ğ‘›+ğœ™ğ‘˜âˆ’1(ğ‘¡)ğ‘›.
If we remove conditioning on w(t) (note that ğ”¼[ğ‘¤(ğ‘¡)2]=ğ”¼[ğ‘Š2]) and express these equations for

ğœ™1(ğ‘¡+1),ğœ™2(ğ‘¡+1),â€¦,ğœ™ğ‘›âˆ’1(ğ‘¡+1) (recall that ğœ™ğ‘˜(ğ‘¡)=ğœ™ğ‘›âˆ’ğ‘˜(ğ‘¡)), we get:

â§â©â¨âªâªâªâªâªâªâªâªâªâªâªâªâªâªğ”¼[ğœ™1(ğ‘¡+1)|ğ‘‹(ğ‘¡)]=(ğ‘›âˆ’2ğ‘›)ğœ™1(ğ‘¡)+12(ğ”¼[ğ‘Š2]âˆ’ğœ™1(ğ‘¡)ğ‘›)+ğœ™2(ğ‘¡)ğ‘›.ğ”¼[ğœ™2(ğ‘¡+1)|ğ‘‹(ğ‘¡)]=(ğ‘›âˆ’2ğ‘›)ğœ™2(ğ‘¡)+(ğ”¼[ğ‘Š2]âˆ’ğœ™1(ğ‘¡)ğ‘›)+ğœ™1(ğ‘¡)ğ‘›+ğœ™3(ğ‘¡)ğ‘›.â€¦ğ”¼[ğœ™âŒŠğ‘›2âŒ‹(ğ‘¡+1)|ğ‘‹(ğ‘¡)]=(ğ‘›âˆ’2ğ‘›)ğœ™âŒŠğ‘›2âŒ‹(ğ‘¡)+(ğ”¼[ğ‘Š2]âˆ’ğœ™1(ğ‘¡)ğ‘›)+ğœ™âŒŠğ‘›2âŒ‹âˆ’1(ğ‘¡)ğ‘›+ğœ™âŒŠğ‘›2âŒ‹+1(ğ‘¡)ğ‘›.â€¦ğ”¼[ğœ™ğ‘›âˆ’2(ğ‘¡+1)|ğ‘‹(ğ‘¡)]=(ğ‘›âˆ’2ğ‘›)ğœ™ğ‘›âˆ’2(ğ‘¡)+(ğ”¼[ğ‘Š2]âˆ’ğœ™1(ğ‘¡)ğ‘›)+ğœ™ğ‘›âˆ’3(ğ‘¡)ğ‘›+ğœ™ğ‘›âˆ’1(ğ‘¡)ğ‘›.ğ”¼[ğœ™ğ‘›âˆ’1(ğ‘¡+1)|ğ‘‹(ğ‘¡)]=(ğ‘›âˆ’2ğ‘›)ğœ™ğ‘›âˆ’1(ğ‘¡)+12(ğ”¼[ğ‘Š2]âˆ’ğœ™1(ğ‘¡)ğ‘›)+ğœ™ğ‘›âˆ’2(ğ‘¡)ğ‘›.
(8)
Using the above equations we can prove the following:

Lemma 1
For every ğ‘¡â‰¥0 and 1â‰¤ğ‘˜â‰¤ğ‘›âˆ’1, we have that

ğ”¼[ğœ™ğ‘˜(ğ‘¡)]â‰¤(ğ‘˜(ğ‘›âˆ’ğ‘˜)âˆ’1)ğ”¼[ğ‘Š2]â‰¤ğ‘˜(ğ‘›âˆ’ğ‘˜)âˆ’1.
(9)
Proof
Let Î¦(ğ‘¡)=(ğœ™1(ğ‘¡),ğœ™2(ğ‘¡),â€¦,ğœ™ğ‘›âˆ’1(ğ‘¡)) be the vector of values of our potentials at time step t and let ğ‘Œ=(ğ‘¦1,ğ‘¦2,â€¦,ğ‘¦ğ‘›âˆ’1), be the vector containing our desired upper bounds for each potential. That is: for each 1â‰¤ğ‘–â‰¤ğ‘›âˆ’1, we have that ğ‘¦ğ‘–=(ğ‘–(ğ‘›âˆ’ğ‘–)âˆ’1)ğ”¼[ğ‘Š2].

An interesting and easily checkable thing about the vector Y is that

ğ”¼[Î¦(ğ‘¡+1)|Î¦(ğ‘¡)=ğ‘Œ]=ğ‘Œ.
(10)
Next, consider the vector ğ‘(ğ‘¡)=(ğ‘§1(ğ‘¡),ğ‘§2(ğ‘¡),â€¦ğ‘§ğ‘›âˆ’1(ğ‘¡))=ğ‘Œâˆ’Î¦(ğ‘¡). Our goal is to show that for every step t and coordinate i, ğ”¼[ğ‘§ğ‘–(ğ‘¡)]â‰¥0.

We have that

ğ”¼[ğ‘§1(ğ‘¡+1)|ğ‘‹(ğ‘¡)]=ğ‘¦1âˆ’ğ”¼[ğœ™1(ğ‘¡+1)|ğ‘‹(ğ‘¡)]=(ğ‘›âˆ’2ğ‘›)ğ‘¦1+12(ğ”¼[ğ‘Š2]âˆ’ğ‘¦1ğ‘›)+ğ‘¦2ğ‘›âˆ’((ğ‘›âˆ’2ğ‘›)ğœ™1(ğ‘¡)+12(ğ”¼[ğ‘Š2]âˆ’ğœ™1(ğ‘¡)ğ‘›)+ğœ™2(ğ‘¡)ğ‘›)=(ğ‘›âˆ’2ğ‘›)ğ‘§1(ğ‘¡)âˆ’ğ‘§1(ğ‘¡)2ğ‘›+ğ‘§2(ğ‘¡)ğ‘›.
and for 2â‰¤ğ‘–â‰¤âŒŠğ‘›2âŒ‹, we have that

ğ”¼[ğ‘§ğ‘–(ğ‘¡+1)|ğ‘‹(ğ‘¡)]=(ğ‘›âˆ’2ğ‘›)ğ‘§ğ‘–(ğ‘¡)âˆ’ğ‘§1(ğ‘¡)ğ‘›+ğ‘§ğ‘–+1(ğ‘¡)ğ‘›+ğ‘§ğ‘–âˆ’1(ğ‘¡)ğ‘›.
Hence we get the following equations (recall that ğ‘§ğ‘–(ğ‘¡)=ğ‘§ğ‘›âˆ’ğ‘–(ğ‘¡)):

â§â©â¨âªâªâªâªâªâªğ‘›Ã—ğ”¼[ğ‘§1(ğ‘¡+1)|ğ‘‹(ğ‘¡)]=(ğ‘›âˆ’2âˆ’12)ğ‘§1(ğ‘¡)+ğ‘§2(ğ‘¡).ğ‘›Ã—ğ”¼[ğ‘§2(ğ‘¡+1)|ğ‘‹(ğ‘¡)]=âˆ’ğ‘§1(ğ‘¡)+ğ‘§1(ğ‘¡)+(ğ‘›âˆ’2)ğ‘§2(ğ‘¡)+ğ‘§3(ğ‘¡).ğ‘›Ã—ğ”¼[ğ‘§3(ğ‘¡+1)|ğ‘‹(ğ‘¡)]=âˆ’ğ‘§1(ğ‘¡)+ğ‘§2(ğ‘¡)+(ğ‘›âˆ’2)ğ‘§3(ğ‘¡)+ğ‘§4(ğ‘¡).â€¦ğ‘›Ã—ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡+1)|ğ‘‹(ğ‘¡)]=âˆ’ğ‘§1(ğ‘¡)+ğ‘§âŒŠğ‘›2âŒ‹âˆ’1(ğ‘¡)+(ğ‘›âˆ’2)ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡)+ğ‘§âŒŠğ‘›2âŒ‹+1(ğ‘¡).
(11)
Next, using induction on t, we show that for every ğ‘¡â‰¥0

0â‰¤ğ”¼[ğ‘§1(ğ‘¡)]â‰¤ğ”¼[ğ‘§2(ğ‘¡)]â‰¤â‹¯â‰¤ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡)].
(12)
The base case holds trivially since ğ‘(0)=ğ‘Œ. For the induction step, assume that

0â‰¤ğ”¼[ğ‘§1(ğ‘¡)]â‰¤ğ”¼[ğ‘§2(ğ‘¡)]â‰¤â‹¯â‰¤ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡)]. First, we have that

ğ‘›ğ”¼[ğ‘§1(ğ‘¡+1)]=ğ‘›ğ”¼ğ‘‹(ğ‘¡)[ğ”¼[ğ‘§1(ğ‘¡+1)|ğ‘‹(ğ‘¡)]]=(ğ‘›âˆ’2âˆ’12)ğ”¼[ğ‘§1(ğ‘¡)]+ğ”¼[ğ‘§2(ğ‘¡)]â‰¥0.
Additionally, we have that:

ğ‘›ğ”¼[ğ‘§1(ğ‘¡+1)]=(ğ‘›âˆ’2âˆ’12)ğ”¼[ğ‘§1(ğ‘¡)]+ğ”¼[ğ‘§2(ğ‘¡)]â‰¤(ğ‘›âˆ’2)ğ”¼[ğ‘§1(ğ‘¡)]+ğ”¼[ğ‘§2(ğ‘¡)]â‰¤(ğ‘›âˆ’2)ğ”¼[ğ‘§2(ğ‘¡)]+ğ”¼[ğ‘§3(ğ‘¡)]=ğ‘›ğ”¼[ğ‘§2(ğ‘¡+1)].
For 2â‰¤ğ‘–â‰¤âŒŠğ‘›2âŒ‹âˆ’2, we have that

ğ‘›ğ”¼[ğ‘§ğ‘–(ğ‘¡+1)]=âˆ’ğ”¼[ğ‘§1(ğ‘¡)]+ğ”¼[ğ‘§ğ‘–âˆ’1(ğ‘¡)]+(ğ‘›âˆ’2)ğ”¼[ğ‘§ğ‘–(ğ‘¡)]+ğ”¼[ğ‘§ğ‘–+1(ğ‘¡)]â‰¤âˆ’ğ”¼[ğ‘§1(ğ‘¡)]+ğ”¼[ğ‘§ğ‘–(ğ‘¡)]+(ğ‘›âˆ’2)ğ”¼[ğ‘§ğ‘–+1(ğ‘¡)]+ğ”¼[ğ‘§ğ‘–+2(ğ‘¡)]=ğ‘›ğ”¼[ğ‘§ğ‘–+1(ğ‘¡+1)].
Next, observe that by our assumption:

ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹+1(ğ‘¡)]=ğ”¼[ğ‘§âŒˆğ‘›2âŒ‰âˆ’1(ğ‘¡)]â‰¥ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹âˆ’2(ğ‘¡)]. Finally, by using this observation we get that

ğ‘›ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹âˆ’1(ğ‘¡+1)]=âˆ’ğ”¼[ğ‘§1(ğ‘¡)]+ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹âˆ’2(ğ‘¡)]+(ğ‘›âˆ’2)ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹âˆ’1(ğ‘¡)]+ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡)]â‰¤âˆ’ğ”¼[ğ‘§1(ğ‘¡)]+ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹+1(ğ‘¡)]+ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹âˆ’1(ğ‘¡)]+(ğ‘›âˆ’3)ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹âˆ’1(ğ‘¡)]+ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡)]â‰¤âˆ’ğ”¼[ğ‘§1(ğ‘¡)]+ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹+1(ğ‘¡)]+ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹âˆ’1(ğ‘¡)]+(ğ‘›âˆ’2)ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡)]=ğ‘›ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡+1)].
This completes the proof of the lemma. â—»

Upper Bound on the Gap for ğ‘›=2ğ‘š
In this section we upper bound a gap in expectation for the case when ğ‘›=2ğ‘š. is quite technical but not necessarily more interesting, and is provided in the Sect. 5.

We begin with some definitions. For a set ğ´âŠ†{1,2,â€¦,ğ‘›}, let

ğºğ‘ğ‘ğ´(ğ‘¡)=maxğ‘–âˆˆğ´ğ‘¥ğ‘–(ğ‘¡)âˆ’minğ‘–âˆˆğ´ğ‘¥ğ‘–(ğ‘¡).
Also, let ğ´ğ‘–ğ‘˜ be {ğ‘–,ğ‘–+2ğ‘šâˆ’ğ‘˜,ğ‘–+2Ã—2ğ‘šâˆ’ğ‘˜,ğ‘–+3Ã—2ğ‘šâˆ’ğ‘˜,â€¦} (Notice that ğ‘–=ğ‘–+2ğ‘šâˆ’ğ‘˜2ğ‘˜). Our proof works as follows: for each 1â‰¤ğ‘–â‰¤ğ‘› and 1â‰¤ğ‘˜â‰¤ğ‘š, we look at the vertices given by the sets ğ´ğ‘–ğ‘˜âˆ’1 and ğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1 and try to characterise the gap after we merge those sets (note that this will give us the gap for the set ğ´ğ‘–ğ‘˜=ğ´ğ‘–ğ‘˜âˆ’1âˆªğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1). Using this result, we are able to show that âˆ‘ğ‘›ğ‘–=1ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡) is upper bounded by âˆ‘ğ‘›ğ‘–=1ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡) plus n times maximum load difference between vertices at hop distance 2ğ‘šâˆ’ğ‘˜. Next, we use 2ğ‘šâˆ’ğ‘˜ hop distance potential ğœ™2ğ‘šâˆ’ğ‘˜(ğ‘¡) to upper bound maximum load difference between the vertices at hop distance 2ğ‘šâˆ’ğ‘˜. By summing up the derived inequality for ğ‘˜=1 to m, we are able to upper bound âˆ‘ğ‘›ğ‘–=1ğºğ‘ğ‘ğ´ğ‘–ğ‘š(ğ‘¡) in terms of âˆ‘ğ‘›ğ‘–=1ğºğ‘ğ‘ğ´ğ‘–0(ğ‘¡) and âˆ‘ğ‘šğ‘˜=1ğœ™2ğ‘šâˆ’ğ‘˜(ğ‘¡). Notice that by our definitions, for each i, ğºğ‘ğ‘ğ´ğ‘–0(ğ‘¡)=0 (ğ´ğ‘–0 contains only vertex i) and ğºğ‘ğ‘ğ´ğ‘–ğ‘š(ğ‘¡)=ğºğ‘ğ‘(ğ‘¡) (ğ´ğ‘–ğ‘š contains all vertices). Hence, what is left is to use the upper bounds for the hop distance potentials, which we derived in the previous section.

We start by proving the following useful lemma.

Lemma 2
For any 1â‰¤ğ‘–â‰¤ğ‘› and 1â‰¤ğ‘˜â‰¤ğ‘š, we have that

2ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡)â‰¤2maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|+ğºğ‘ğ‘ğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1(ğ‘¡)+ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡).
(13)
Proof
Fix vertex i. Recall that ğ´ğ‘–ğ‘˜=ğ´ğ‘–ğ‘˜âˆ’1âˆªğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1.

Let ğ‘¢=argmaxğ‘—âˆˆğ´ğ‘–ğ‘˜ğ‘¥ğ‘—(ğ‘¡) and let ğ‘£=argminğ‘—âˆˆğ´ğ‘–ğ‘˜ğ‘¥ğ‘—(ğ‘¡). We consider several cases on the membership of nodes u and v, and bound the gap in each one:

Case 1 ğ‘¢âˆˆğ´ğ‘–ğ‘˜âˆ’1 and ğ‘£âˆˆğ´ğ‘–ğ‘˜âˆ’1. Then ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡)=ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡) and we have that

ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡)=|ğ‘¥ğ‘¢(ğ‘¡)âˆ’ğ‘¥ğ‘£(ğ‘¡)|â‰¤|ğ‘¥ğ‘¢+2ğ‘šâˆ’ğ‘˜(ğ‘¡)âˆ’ğ‘¥ğ‘¢(ğ‘¡)|+|ğ‘¥ğ‘£+2ğ‘šâˆ’ğ‘˜(ğ‘¡)âˆ’ğ‘¥ğ‘£(ğ‘¡)|+|ğ‘¥ğ‘¢+2ğ‘šâˆ’ğ‘˜(ğ‘¡)âˆ’ğ‘¥ğ‘£+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|â‰¤|ğ‘¥ğ‘¢+2ğ‘šâˆ’ğ‘˜(ğ‘¡)âˆ’ğ‘¥ğ‘¢(ğ‘¡)|+|ğ‘¥ğ‘£+2ğ‘šâˆ’ğ‘˜(ğ‘¡)âˆ’ğ‘¥ğ‘£(ğ‘¡)|+ğºğ‘ğ‘ğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1(ğ‘¡)â‰¤2maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|+ğºğ‘ğ‘ğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1(ğ‘¡),
where we used the fact that both ğ‘¢+2ğ‘šâˆ’ğ‘˜ and ğ‘£+2ğ‘šâˆ’ğ‘˜ belong to ğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1. This gives us that

2ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡)â‰¤2maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|+ğºğ‘ğ‘ğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1(ğ‘¡)+ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡).
(14)
Case 2 ğ‘¢âˆˆğ´ğ‘–ğ‘˜âˆ’1 and ğ‘£âˆˆğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1. Then we have that:

ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡)=|ğ‘¥ğ‘¢(ğ‘¡)âˆ’ğ‘¥ğ‘£(ğ‘¡)|â‰¤|ğ‘¥ğ‘¢(ğ‘¡)âˆ’ğ‘¥ğ‘£+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|+|ğ‘¥ğ‘£+2ğ‘šâˆ’ğ‘˜(ğ‘¡)âˆ’ğ‘¥ğ‘£(ğ‘¡)|â‰¤ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡)+maxğ‘—âˆˆğ´ğ‘–ğ‘˜(|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|)
and

ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡)=|ğ‘¥ğ‘¢(ğ‘¡)âˆ’ğ‘¥ğ‘£(ğ‘¡)|â‰¤|ğ‘¥ğ‘¢(ğ‘¡)âˆ’ğ‘¥ğ‘¢+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|+|ğ‘¥ğ‘¢+2ğ‘šâˆ’ğ‘˜(ğ‘¡)âˆ’ğ‘¥ğ‘£(ğ‘¡)|â‰¤ğºğ‘ğ‘ğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1(ğ‘¡)+maxğ‘—âˆˆğ´ğ‘–ğ‘˜(|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|),
where we used ğ‘£+2ğ‘šâˆ’ğ‘˜âˆˆğ´ğ‘–ğ‘˜âˆ’1 and ğ‘¢+2ğ‘šâˆ’ğ‘˜âˆˆğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1. Hence, we again get that

2ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡)â‰¤2maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|+ğºğ‘ğ‘ğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1(ğ‘¡)+ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡).
(15)
Case 3 ğ‘¢âˆˆğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1 and ğ‘£âˆˆğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1, is similar to Case 1.

Case 4 ğ‘£âˆˆğ´ğ‘–ğ‘˜âˆ’1 and ğ‘¢âˆˆğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1, is similar to Case 2.

â—»

Next, we upper bound the quantity âˆ‘ğ‘›ğ‘–=1maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|.

Lemma 3
For any 1â‰¤ğ‘˜â‰¤ğ‘š:

âˆ‘ğ‘–=1ğ‘›maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|â‰¤ğ‘›2ğ‘šâˆ’ğ‘˜â€¾â€¾â€¾â€¾â€¾âˆšğœ™2ğ‘šâˆ’ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆš.
(16)
Proof
Notice that for any i and ğ‘–â€²âˆˆğ´ğ‘–ğ‘˜, we have that ğ´ğ‘–ğ‘˜=ğ´ğ‘–â€²ğ‘˜,

hence maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|=maxğ‘—âˆˆğ´ğ‘–â€²ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)| and this means that

âˆ‘ğ‘–=1ğ‘›maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|=ğ‘›2ğ‘šâˆ’ğ‘˜âˆ‘ğ‘–=12ğ‘šâˆ’ğ‘˜maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|â‰¤ğ¶ğ‘ğ‘¢ğ‘â„ğ‘¦âˆ’ğ‘†ğ‘â„ğ‘¤ğ‘ğ‘Ÿğ‘§ğ‘›2ğ‘šâˆ’ğ‘˜2ğ‘šâˆ’ğ‘˜â€¾â€¾â€¾â€¾â€¾âˆšâˆ‘ğ‘–=12ğ‘šâˆ’ğ‘˜maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|2â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾î€â·î€€î€€â‰¤ğ‘›2ğ‘šâˆ’ğ‘˜2ğ‘šâˆ’ğ‘˜â€¾â€¾â€¾â€¾â€¾âˆšâˆ‘ğ‘—=1ğ‘›|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|2â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾î€â·î€€î€€=ğ‘›2ğ‘šâˆ’ğ‘˜â€¾â€¾â€¾â€¾â€¾âˆšğœ™2ğ‘šâˆ’ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆš,
where in the last inequality we used a fact that sets ğ´1ğ‘˜,ğ´2ğ‘˜,â€¦,ğ´2ğ‘šâˆ’ğ‘˜ğ‘˜ are disjoint. â—»

Finally, using the above lemmas we can upper bound the expected gap at step t:

Theorem 1
For every ğ‘¡â‰¥0, we have that

ğ”¼[ğºğ‘ğ‘(ğ‘¡)]=ğ‘‚(ğ‘›âˆšlog(ğ‘›)).
Proof
From Lemma 2 we have that

âˆ‘ğ‘–=1ğ‘›2ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡)â‰¤âˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡)+âˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1(ğ‘¡)+âˆ‘ğ‘–=1ğ‘›2maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|=2âˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡)+2âˆ‘ğ‘–=1ğ‘›maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|.
After dividing the above inequality by 2 and applying Lemma 3 we get that:

âˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡)â‰¤âˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡)+ğ‘›2ğ‘šâˆ’ğ‘˜â€¾â€¾â€¾â€¾â€¾âˆšğœ™2ğ‘šâˆ’ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆš.
Next, we sum up the above inequality for ğ‘˜=1 to m:

âˆ‘ğ‘˜=1ğ‘šâˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡)â‰¤âˆ‘ğ‘˜=1ğ‘šâˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡)+âˆ‘ğ‘˜=1ğ‘šğ‘›2ğ‘šâˆ’ğ‘˜â€¾â€¾â€¾â€¾â€¾âˆšğœ™2ğ‘šâˆ’ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆš.
Recall that âˆ‘ğ‘›ğ‘–=1ğºğ‘ğ‘ğ´ğ‘–ğ‘š(ğ‘¡)=ğ‘›ğºğ‘ğ‘(ğ‘¡) and âˆ‘ğ‘›ğ‘–=1ğºğ‘ğ‘ğ´ğ‘–0(ğ‘¡)=0. Hence, we get that

ğ‘›ğºğ‘ğ‘(ğ‘¡)â‰¤âˆ‘ğ‘˜=1ğ‘šğ‘›2ğ‘šâˆ’ğ‘˜â€¾â€¾â€¾â€¾â€¾âˆšğœ™2ğ‘šâˆ’ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆš.
Next, we apply Jensenâ€™s inequality and Lemma 1:

ğ‘›ğ”¼[ğºğ‘ğ‘(ğ‘¡)]â‰¤âˆ‘ğ‘˜=1ğ‘šğ‘›2ğ‘šâˆ’ğ‘˜â€¾â€¾â€¾â€¾â€¾âˆšğ”¼ğœ™2ğ‘šâˆ’ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆšâ‰¤âˆ‘ğ‘˜=1ğ‘šğ‘›2ğ‘šâˆ’ğ‘˜â€¾â€¾â€¾â€¾â€¾âˆšğ”¼[ğœ™2ğ‘šâˆ’ğ‘˜(ğ‘¡)]â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆšâ‰¤âˆ‘ğ‘˜=1ğ‘šğ‘›2ğ‘šâˆ’ğ‘˜â€¾â€¾â€¾â€¾â€¾âˆš2ğ‘šâˆ’ğ‘˜(ğ‘›âˆ’2ğ‘šâˆ’ğ‘˜)â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆšâ‰¤ğ‘šğ‘›ğ‘›âˆš=ğ‘›(logğ‘›)ğ‘›âˆš.
This gives us the proof of the theorem. â—»

Gap Lower Bound
Next we prove the following theorem, which lower bounds the second moment of the gap in expectation.

Theorem 2
The following limit holds:

limğ‘¡â†’âˆğ”¼[ğºğ‘ğ‘(ğ‘¡)2]=Î©(ğ‘›ğ”¼[ğ‘Š2])).
Proof
In this case we want to prove that not only does vector Z(t) have positive coordinates in expectation, but also ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹] converges to 0. This will give us that ğœ™âŒŠğ‘›2âŒ‹ approaches its upper bound (âŒŠğ‘›2âŒ‹âŒˆğ‘›2âŒ‰âˆ’1)ğ”¼[ğ‘Š2] in expectation. Then, we can show that there exist two nodes (at distance âŒŠğ‘›2âŒ‹) such that the expected square of difference between their loads is Î©(ğ‘›ğ”¼[ğ‘¤2]).

Recall from Eq. (11) that

ğ‘›ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡+1)]=âˆ’ğ”¼[ğ‘§1(ğ‘¡)]+ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹+1(ğ‘¡)]+ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹âˆ’1(ğ‘¡)]+(ğ‘›âˆ’2)ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡)].
We also know that Inequalities (12) hold for every t, hence we get that

ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡+1)]â‰¤ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡)]âˆ’ğ”¼[ğ‘§1(ğ‘¡)]ğ‘›.
The above inequality in combination with Inequalities (12) means that

ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡+âŒŠğ‘›2âŒ‹+1)]â‰¤ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡+1)]âˆ’âˆ‘ğ‘–=ğ‘¡ğ‘¡+âŒŠğ‘›2âŒ‹ğ”¼[ğ‘§1(ğ‘–)]ğ‘›â‰¤ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡+1)]âˆ’ğ”¼[ğ‘§1(ğ‘¡+âŒŠğ‘›2âŒ‹)]ğ‘›
(17)
Again by using Eq. (11) and Inequalities (12), we can show that for every 1â‰¤ğ‘–â‰¤âŒŠğ‘›2âŒ‹âˆ’1:

ğ”¼[ğ‘§ğ‘–(ğ‘¡+1)]â‰¥ğ”¼[ğ‘§ğ‘–+1(ğ‘¡)]ğ‘›.
This gives us that:

ğ”¼[ğ‘§1(ğ‘¡+âŒŠğ‘›2âŒ‹)]â‰¥(1ğ‘›)ğ”¼[ğ‘§2(ğ‘¡+âŒŠğ‘›2âŒ‹âˆ’1)]â‰¥(1ğ‘›)2ğ”¼[ğ‘§3(ğ‘¡+âŒŠğ‘›2âŒ‹âˆ’2)]â‰¥â‹¯â‰¥(1ğ‘›)âŒŠğ‘›2âŒ‹âˆ’1ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡+âŒŠğ‘›2âŒ‹âˆ’(âŒŠğ‘›2âŒ‹âˆ’1))]=(1ğ‘›)âŒŠğ‘›2âŒ‹âˆ’1ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡+1)].
By plugging the above inequality in Inequality (17). we get that

ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡+âŒŠğ‘›2âŒ‹+1)]â‰¤ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡+1)]âˆ’ğ”¼[ğ‘§1(ğ‘¡+âŒŠğ‘›2âŒ‹)]ğ‘›â‰¤ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡+1)]âˆ’(1ğ‘›)âŒŠğ‘›2âŒ‹ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡+1)]=(1âˆ’(1ğ‘›)âŒŠğ‘›2âŒ‹)ğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡+1)].
Because (1âˆ’(1ğ‘›)âŒŠğ‘›2âŒ‹)<1 and does not depend on t, we get that

limğ‘¡â†’âˆğ”¼[ğ‘§âŒŠğ‘›2âŒ‹(ğ‘¡)]=0.
This means thatlimğ‘¡â†’âˆğ”¼[ğœ™âŒŠğ‘›2âŒ‹(ğ‘¡)]=Î©(ğ‘›2ğ”¼[ğ‘Š2]).

Let ğºğ‘ğ‘âŒŠğ‘›2âŒ‹(ğ‘¡)=max1â‰¤ğ‘–â‰¤ğ‘›|ğ‘¥ğ‘–(ğ‘¡)âˆ’ğ‘¥ğ‘–+âŒŠğ‘›2âŒ‹(ğ‘¡)|. Note that:

ğºğ‘ğ‘(ğ‘¡)2â‰¥ğºğ‘ğ‘âŒŠğ‘›2âŒ‹(ğ‘¡)2â‰¥ğœ™âŒŠğ‘›2âŒ‹(ğ‘¡)ğ‘›.
Hence

limğ‘¡â†’âˆğ”¼[ğºğ‘ğ‘(ğ‘¡)2]=Î©(ğ‘›ğ”¼[ğ‘Š2]).
Unfortunately we are not able to obtain the lower bound on the gap, since our approach uses the fact that the upper bounds on k-hop potentials are â€™tightâ€™. Since our potentials are quadratic, we are not able to derive any kind of lower bound for the gap itself. Intuitively, this will be an issue with any argument which uses convex potential. â—»

Upper Bound on the Gap, General Case
To prove Theorem 1 for the general case, we need to redefine our sets ğ´ğ‘–ğ‘˜. In order to do this, for each k we define 2ğ‘˜ dimensional vector Î”ğ‘˜=(ğ›¿1ğ‘˜,ğ›¿2ğ‘˜,â€¦,ğ›¿2ğ‘˜ğ‘˜). For ğ‘˜=0, we have that Î”ğ‘˜=(ğ‘›). For âŒŠlogğ‘›âŒ‹â‰¥ğ‘˜>0 we set Î”ğ‘˜=(ğ›¼ğ‘˜,ğ›¿1ğ‘˜âˆ’1âˆ’ğ›¼ğ‘˜,ğ›¼ğ‘˜,ğ›¿2ğ‘˜âˆ’1âˆ’ğ›¼ğ‘˜,â€¦,ğ›¼ğ‘˜,ğ›¿2ğ‘˜âˆ’1ğ‘˜âˆ’1âˆ’ğ›¼ğ‘˜). where

ğ›¼ğ‘˜=â§â©â¨âªâªâŒŠğ‘›2ğ‘˜âˆ’1âŒ‹/2,ifâŒŠğ‘›2ğ‘˜âˆ’1âŒ‹is even.âŒŠâŒˆğ‘›2ğ‘˜âˆ’1âŒ‰/2âŒ‹,otherwise.
First we prove the following Lemma:

Lemma 4
For any âŒŠlogğ‘›âŒ‹â‰¥ğ‘˜â‰¥0, we have that

1. âˆ‘2ğ‘˜ğ‘–=1ğ›¿ğ‘–ğ‘˜=ğ‘›.

2. For any 1â‰¤ğ‘–â‰¤2ğ‘˜, ğ›¿ğ‘–ğ‘˜âˆˆ{âŒˆğ‘›2ğ‘˜âŒ‰âŒŠğ‘›2ğ‘˜âŒ‹} (notice that this means ğ›¼ğ‘˜=âŒŠğ‘›2ğ‘˜âŒ‹ or ğ›¼ğ‘˜=âŒˆğ‘›2ğ‘˜âŒ‰).

Proof
We prove the lemma using induction on k. Base case ğ‘˜=0 holds trivially. For the induction step, assume that Properties 1 and 2 hold for ğ‘˜âˆ’1, we aim to prove that they hold for k as well. We have that âˆ‘2ğ‘˜ğ‘–=1ğ›¿ğ‘–ğ‘˜=âˆ‘2ğ‘˜âˆ’1ğ‘–=1(ğ›¼ğ‘˜+ğ›¿ğ‘–ğ‘˜âˆ’1âˆ’ğ›¼ğ‘˜)=âˆ‘2ğ‘˜âˆ’1ğ‘–=1ğ›¿ğ‘–ğ‘˜âˆ’1=ğ‘›. To prove Property 2 we consider several cases:

Case 1 ğ‘›2ğ‘˜âˆ’1=2ğ‘, for some integer q.

We have that ğ›¼ğ‘˜=ğ‘, and hence for any 1â‰¤ğ‘–â‰¤2ğ‘˜âˆ’1, ğ›¿ğ‘–ğ‘˜âˆ’1âˆ’ğ›¼ğ‘˜=ğ‘. Since âŒŠğ‘›2ğ‘˜âŒ‹=ğ‘, Property 2 holds.

Case 2 ğ‘›2ğ‘˜âˆ’1=2ğ‘+1, for some integer q.

We have that ğ›¼ğ‘˜=ğ‘, and hence for any 1â‰¤ğ‘–â‰¤2ğ‘˜âˆ’1, ğ›¿ğ‘–ğ‘˜âˆ’1âˆ’ğ›¼ğ‘˜=ğ‘+1. Since âŒŠğ‘›2ğ‘˜âŒ‹=ğ‘ and âŒˆğ‘›2ğ‘˜âŒ‰=ğ‘+1, Property 2 holds.

Case 3 ğ‘›2ğ‘˜âˆ’1=2ğ‘+ğœ–, for some integer q and 0<ğœ–<1.

We have that âŒŠğ‘›2ğ‘˜âˆ’1âŒ‹=2ğ‘ and âŒˆğ‘›2ğ‘˜âˆ’1âŒ‰=2ğ‘+1. Additionally, ğ›¼ğ‘˜=ğ‘, and hence for any 1â‰¤ğ‘–â‰¤2ğ‘˜âˆ’1, (ğ›¿ğ‘–ğ‘˜âˆ’1âˆ’ğ›¼ğ‘˜)âˆˆ{ğ‘,ğ‘+1}. Since âŒŠğ‘›2ğ‘˜âŒ‹=ğ‘ and âŒˆğ‘›2ğ‘˜âŒ‰=ğ‘+1, Property 2 holds.

Case 4 ğ‘›2ğ‘˜âˆ’1=2ğ‘+1+ğœ–, for some integer q and 0<ğœ–<1.

We have that âŒŠğ‘›2ğ‘˜âˆ’1âŒ‹=2ğ‘+1 and âŒˆğ‘›2ğ‘˜âˆ’1âŒ‰=2ğ‘+2. Additionally, ğ›¼ğ‘˜=ğ‘+1, and hence for any 1â‰¤ğ‘–â‰¤2ğ‘˜âˆ’1, (ğ›¿ğ‘–ğ‘˜âˆ’1âˆ’ğ›¼ğ‘˜)âˆˆ{ğ‘,ğ‘+1}. Since âŒŠğ‘›2ğ‘˜âŒ‹=ğ‘ and âŒˆğ‘›2ğ‘˜âŒ‰=ğ‘+1, Property 2 holds. â—»

Next, for âŒŠlogğ‘›âŒ‹â‰¥ğ‘˜>0 we set

ğ´ğ‘–ğ‘˜={ğ‘–,ğ‘–+ğ›¿1ğ‘˜,ğ‘–+ğ›¿1ğ‘˜+ğ›¿2ğ‘˜,â€¦,ğ‘–+âˆ‘ğ‘—=12ğ‘˜âˆ’1ğ›¿ğ‘—ğ‘˜}.
It is easy to see that for any âŒŠlogğ‘›âŒ‹â‰¥ğ‘˜>0 and i, we have that |ğ´ğ‘–ğ‘˜|=2ğ‘˜, ğ´ğ‘–ğ‘˜=ğ´ğ‘–ğ‘˜âˆ’1âˆªğ´ğ‘–+ğ›¼ğ‘˜ğ‘˜âˆ’1 and ğ´ğ‘–ğ‘˜âˆ’1âˆ©ğ´ğ‘–+ğ›¼ğ‘˜ğ‘˜âˆ’1=âˆ…. Also notice that for any ğ‘¢âˆˆğ´ğ‘–ğ‘˜âˆ’1, ğ‘¢+ğ›¼ğ‘˜âˆˆğ´ğ‘–+ğ›¼ğ‘˜ğ‘˜âˆ’1 and for any ğ‘¢âˆˆğ´ğ‘–+ğ›¼ğ‘˜ğ‘˜âˆ’1, ğ‘¢âˆ’ğ›¼ğ‘˜âˆˆğ´ğ‘–ğ‘˜âˆ’1.

Next we prove the lemma which is similar to the Lemma 2 for ğ‘›=2ğ‘š case:

Lemma 5
For any 1â‰¤ğ‘–â‰¤ğ‘› and âŒŠlogğ‘›âŒ‹â‰¥ğ‘˜>0, we have that

2ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡)â‰¤2maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+ğ›¼ğ‘˜(ğ‘¡)|+ğºğ‘ğ‘ğ´ğ‘–+ğ›¼ğ‘˜ğ‘˜âˆ’1(ğ‘¡)+ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡).
(18)
Proof
Notice that the statement we need to prove is identical to that of Lemma 2, with the exception that in the letter we use 2ğ‘šâˆ’ğ‘˜ instead of ğ›¼ğ‘˜. The proofs are also almost identical (2ğ‘šâˆ’ğ‘˜ can be simply replaced with ğ›¼ğ‘˜). The only difference is that the proof of Lemma 2 uses the property that for any ğ‘¢âˆˆğ´ğ‘–+2ğ‘šâˆ’ğ‘˜ğ‘˜âˆ’1, |ğ‘¥ğ‘¢(ğ‘¡)âˆ’ğ‘¥ğ‘¢+2ğ‘šâˆ’ğ‘˜(ğ‘¡)|â‰¤maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+2ğ‘šâˆ’ğ‘˜(ğ‘¡)| and ğ‘¢+2ğ‘šâˆ’ğ‘˜âˆˆğ´ğ‘–ğ‘˜âˆ’1. Instead, we will use the property that for any ğ‘¢âˆˆğ´ğ‘–+ğ›¼ğ‘˜ğ‘˜âˆ’1, |ğ‘¥ğ‘¢(ğ‘¡)âˆ’ğ‘¥ğ‘¢âˆ’ğ›¼ğ‘˜(ğ‘¡)|â‰¤maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+ğ›¼ğ‘˜(ğ‘¡)| and ğ‘¢âˆ’ğ›¼ğ‘˜âˆˆğ´ğ‘–ğ‘˜âˆ’1. â—»

Next, we upper bound âˆ‘ğ‘›ğ‘–=1maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+ğ›¼ğ‘˜(ğ‘¡)|, by proving the following lemma, which is the analogue of Lemma 3.

Lemma 6
âˆ‘ğ‘–=1ğ‘›maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+ğ›¼ğ‘˜(ğ‘¡)|â‰¤âŒˆğ‘›âŒŠğ‘›2ğ‘˜âŒ‹âŒ‰âŒŠğ‘›2ğ‘˜âŒ‹â€¾â€¾â€¾â€¾â€¾âˆšğœ™ğ›¼ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾âˆš
(19)
Proof
Notice that for any 1â‰¤ğ‘¢â‰¤ğ‘› and the sets ğ´ğ‘¢ğ‘˜,ğ´ğ‘¢+1ğ‘˜,â€¦,ğ´ğ‘¢+âŒŠğ‘›2ğ‘˜âŒ‹âˆ’1ğ‘˜ are disjoint, because for any 1â‰¤ğ‘—â‰¤2ğ‘˜, ğ›¿ğ‘—ğ‘˜â‰¥âŒŠğ‘›2ğ‘˜âŒ‹ (this means that for any 1â‰¤ğ‘–â‰¤ğ‘›, distances between consecutive vertices in ğ´ğ‘–ğ‘˜ are at least âŒŠğ‘›2ğ‘˜âŒ‹). Using this fact and Cauchyâ€“Schwarz inequality we get that

âˆ‘ğ‘–=ğ‘¢ğ‘¢+âŒŠğ‘›2ğ‘˜âŒ‹âˆ’1maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+ğ›¼ğ‘˜(ğ‘¡)|â‰¤âŒŠğ‘›2ğ‘˜âŒ‹â€¾â€¾â€¾â€¾â€¾âˆšâˆ‘ğ‘–=ğ‘¢ğ‘¢+âŒŠğ‘›2ğ‘˜âŒ‹âˆ’1maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+ğ›¼ğ‘˜(ğ‘¡)|2â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾î€â·î€€î€€î€€â‰¤âŒŠğ‘›2ğ‘˜âŒ‹â€¾â€¾â€¾â€¾â€¾âˆšâˆ‘ğ‘—=1ğ‘›|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+ğ›¼ğ‘˜(ğ‘¡)|2â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾î€â·î€€î€€=âŒŠğ‘›2ğ‘˜âŒ‹â€¾â€¾â€¾â€¾â€¾âˆšğœ™ğ›¼ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾âˆš
Since the above inequality holds for any u we can write that:

âˆ‘ğ‘–=1ğ‘›maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+ğ›¼ğ‘˜(ğ‘¡)|â‰¤âŒˆğ‘›âŒŠğ‘›2ğ‘˜âŒ‹âŒ‰âŒŠğ‘›2ğ‘˜âŒ‹â€¾â€¾â€¾â€¾â€¾âˆšğœ™ğ›¼ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾âˆš.â—»
â—»

With the above three lemmas in place, we are ready to prove Theorem 1 for general n.

From Lemma 5 we have that

âˆ‘ğ‘–=1ğ‘›2ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡)â‰¤âˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡)+âˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–+ğ›¼ğ‘˜ğ‘˜âˆ’1(ğ‘¡)+âˆ‘ğ‘–=1ğ‘›2maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+ğ›¼ğ‘˜(ğ‘¡)|=2âˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡)+2âˆ‘ğ‘–=1ğ‘›maxğ‘—âˆˆğ´ğ‘–ğ‘˜|ğ‘¥ğ‘—(ğ‘¡)âˆ’ğ‘¥ğ‘—+ğ›¼ğ‘˜(ğ‘¡)|.
After dividing the above inequality by 2 and applying Lemma 6, we get that:

âˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–ğ‘˜(ğ‘¡)â‰¤âˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–ğ‘˜âˆ’1(ğ‘¡)+âŒˆğ‘›âŒŠğ‘›2ğ‘˜âŒ‹âŒ‰âŒŠğ‘›2ğ‘˜âŒ‹â€¾â€¾â€¾â€¾â€¾âˆšğœ™ğ›¼ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾âˆš.
Notice that for any i, ğºğ‘ğ‘ğ‘–ğ´0(ğ‘¡)=0. Hence, after summing up the above inequality for ğ‘˜=1 to âŒŠlogğ‘›âŒ‹ we get that

âˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–âŒŠlogğ‘›âŒ‹(ğ‘¡)â‰¤âˆ‘ğ‘˜=1âŒŠlogğ‘›âŒ‹âŒˆğ‘›âŒŠğ‘›2ğ‘˜âŒ‹âŒ‰âŒŠğ‘›2ğ‘˜âŒ‹â€¾â€¾â€¾â€¾â€¾âˆšğœ™ğ›¼ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾âˆš.
Let ğ‘–â€²=argminğ‘–ğºğ‘ğ‘ğ´ğ‘–âŒŠlogğ‘›âŒ‹(ğ‘¡). Notice that consecutive vertices in ğ´ğ‘–â€²âŒŠlogğ‘›âŒ‹ are 1 or 2 edges apart, hence for any 1â‰¤ğ‘–â‰¤ğ‘›, either ğ‘–âˆˆğ´ğ‘–â€²âŒŠlogğ‘›âŒ‹ or ğ‘–+1âˆˆğ´ğ‘–â€²âŒŠlogğ‘›âŒ‹. This gives us that

ğºğ‘ğ‘(ğ‘¡)â‰¤ğºğ‘ğ‘ğ´ğ‘–â€²âŒŠlogğ‘›âŒ‹(ğ‘¡)+2maxğ‘–|ğ‘¥ğ‘–(ğ‘¡)âˆ’ğ‘¥ğ‘–+1(ğ‘¡)|=ğºğ‘ğ‘ğ´ğ‘–â€²âŒŠlogğ‘›âŒ‹(ğ‘¡)+2maxğ‘–|ğ‘¥ğ‘–(ğ‘¡)âˆ’ğ‘¥ğ‘–+1(ğ‘¡)|2â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆšâ‰¤ğºğ‘ğ‘ğ´ğ‘–â€²âŒŠlogğ‘›âŒ‹(ğ‘¡)+2ğœ™1(ğ‘¡)â€¾â€¾â€¾â€¾â€¾âˆš.
By combining the above two inequalities we get that

ğ‘›ğºğ‘ğ‘(ğ‘¡)â‰¤ğ‘›ğºğ‘ğ‘ğ´ğ‘–â€²âŒŠlogğ‘›âŒ‹(ğ‘¡)+2ğ‘›ğœ™1(ğ‘¡)â€¾â€¾â€¾â€¾â€¾âˆšâ‰¤âˆ‘ğ‘–=1ğ‘›ğºğ‘ğ‘ğ´ğ‘–âŒŠlogğ‘›âŒ‹(ğ‘¡)+2ğ‘›ğœ™1(ğ‘¡)â€¾â€¾â€¾â€¾â€¾âˆšâ‰¤âˆ‘ğ‘˜=1âŒŠlogğ‘›âŒ‹âŒˆğ‘›âŒŠğ‘›2ğ‘˜âŒ‹âŒ‰âŒŠğ‘›2ğ‘˜âŒ‹â€¾â€¾â€¾â€¾â€¾âˆšğœ™ğ›¼ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾âˆš+ğ‘›ğœ™1(ğ‘¡)â€¾â€¾â€¾â€¾â€¾âˆš.
Next, we apply Jensenâ€™s inequality and Lemma 1 (we are going to use a looser upper bound: ğ”¼[ğœ™ğ‘–(ğ‘¡)]â‰¤ğ‘–(ğ‘›âˆ’ğ‘–)âˆ’1â‰¤ğ‘–ğ‘›)

ğ‘›ğ”¼[ğºğ‘ğ‘(ğ‘¡)]â‰¤2ğ‘›ğ”¼[ğœ™1(ğ‘¡)]â€¾â€¾â€¾â€¾â€¾â€¾âˆš+âˆ‘ğ‘˜=1âŒŠlogğ‘›âŒ‹âŒˆğ‘›âŒŠğ‘›2ğ‘˜âŒ‹âŒ‰âŒŠğ‘›2ğ‘˜âŒ‹â€¾â€¾â€¾â€¾â€¾âˆšğ”¼ğœ™ğ›¼ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾âˆšâ‰¤2ğ‘›ğ”¼[ğœ™1(ğ‘¡)]â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆš+âˆ‘ğ‘˜=1âŒŠlogğ‘›âŒ‹âŒˆğ‘›âŒŠğ‘›2ğ‘˜âŒ‹âŒ‰âŒŠğ‘›2ğ‘˜âŒ‹â€¾â€¾â€¾â€¾â€¾âˆšğ”¼[ğœ™ğ›¼ğ‘˜(ğ‘¡)]â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆšâ‰¤2ğ‘›ğ‘›âˆš+âˆ‘ğ‘˜=1âŒŠlogğ‘›âŒ‹âŒˆğ‘›âŒŠğ‘›2ğ‘˜âŒ‹âŒ‰âŒŠğ‘›2ğ‘˜âŒ‹â€¾â€¾â€¾â€¾â€¾âˆšğ›¼ğ‘˜ğ‘›â€¾â€¾â€¾â€¾âˆš=ğ‘‚(ğ‘›ğ‘›âˆšlogğ‘›).
This completes the proof.

Experimental Validation
On the practical side, we implemented our load balancing algorithm with unit weight increments on a cycle. The results confirm our hypothesis that the gap is of order Î˜(ğ‘›âˆš). In our experiment we observe the evolution of gap as we perform up to 109 increment operations. In Fig. 1 we ran our experiment 100 times and calculated average gap over all runs. x-axis shows number of balls thrown (which is the same as the number of increments) and y-axis is current average gap divided by ğ‘›âˆš. The experiment shows that once the number of thrown balls is large enough, the gap stays between ğ‘›âˆš and 1.4ğ‘›âˆš.

Fig. 1
figure 1
The evolution of average gap divided by square root of n, where n is the number of bins

Full size image
Harary Graph, Upper Bound on the Gap
Recall that the Harary graph ğ»ğ‘˜,ğ‘› is a k-connected graph with n vertices, which has the smallest possible number of edges. In this section we show that our approach can be extended to the Harary graph ğ»4,ğ‘› (unless specified we will assume ğ»4,ğ‘› to be the Harary graph): each vertex i is connected with edges to vertices ğ‘–âˆ’1, ğ‘–+1 (called cycle edges), ğ‘–âˆ’2 and ğ‘–+2 (called extra edges). As before, the operation consists of picking an edge u.a.r and doing increment and averaging (for the simplicity we assume that increments have unit weights, the result can be extended to the random weights, in the similar fashion to the cycle case). After careful calculations which mimic the calculations for the cycle case, but by taking extra edges of the Harary graph into the account, we can derive the following equations for the hop potentials (hop distance is counted over the cycle edges only):

â§â©â¨âªâªâªâªâªâªğ”¼[ğœ™1(ğ‘¡+1)]=ğ‘›âˆ’2ğ‘›ğ”¼[ğœ™1(ğ‘¡)]+34+ğ”¼[ğœ™1(ğ‘¡)]4ğ‘›+ğ”¼[ğœ™3(ğ‘¡)]2ğ‘›ğ”¼[ğœ™2(ğ‘¡+1)]=ğ‘›âˆ’2ğ‘›ğ”¼[ğœ™2(ğ‘¡)]+34âˆ’ğ”¼[ğœ™2(ğ‘¡)]4ğ‘›+ğ”¼[ğœ™3(ğ‘¡)]2ğ‘›+ğ”¼[ğœ™4(ğ‘¡)]2ğ‘›â€¦ğ”¼[ğœ™ğ‘˜(ğ‘¡+1)]=ğ‘›âˆ’2ğ‘›ğ”¼[ğœ™ğ‘˜(ğ‘¡)]+1âˆ’ğ”¼[ğœ™1(ğ‘¡)]2ğ‘›âˆ’ğ”¼[ğœ™2(ğ‘¡)]2ğ‘›+ğ”¼[ğœ™ğ‘˜âˆ’2(ğ‘¡)]2ğ‘›+ğ”¼[ğœ™ğ‘˜âˆ’1(ğ‘¡)]2ğ‘›+ğ”¼[ğœ™ğ‘˜+1(ğ‘¡)]2ğ‘›+ğ”¼[ğœ™ğ‘˜+2(ğ‘¡)]2ğ‘›
Recall that for the cycle potential ğœ™ğ‘˜(ğ‘¡+1) depends on the potentials ğœ™ğ‘˜(ğ‘¡), ğœ™ğ‘˜+1(ğ‘¡), ğœ™ğ‘˜âˆ’1(ğ‘¡) and ğœ™1(ğ‘¡) (please see Eq. (8)). In the case of Harary graph ğœ™ğ‘˜(ğ‘¡+1) depends on the potentials ğœ™ğ‘˜+2(ğ‘¡), ğœ™ğ‘˜+1(ğ‘¡), ğœ™ğ‘˜(ğ‘¡), ğœ™ğ‘˜âˆ’1(ğ‘¡), ğœ™ğ‘˜âˆ’2(ğ‘¡), ğœ™1(ğ‘¡) and ğœ™2(ğ‘¡). The reason is that we are able to perform load balancing operation on two hop neighbours. Similarly, if we have a graph where each vertex is connected with all vertices which are at hop distance at most â„“ (this is the Harary graph ğ»2â„“,ğ‘›), then ğœ™ğ‘˜(ğ‘¡+1) will depend on ğœ™ğ‘˜+â„“(ğ‘¡), â€¦, ğœ™ğ‘˜+1(ğ‘¡), ğœ™ğ‘˜(ğ‘¡), ğœ™ğ‘˜âˆ’1(ğ‘¡), â€¦, ğœ™ğ‘˜âˆ’â„“(ğ‘¡), and ğœ™1(ğ‘¡), ğœ™2(ğ‘¡), â€¦, ğœ™â„“(ğ‘¡). Next step is to find the stationary points for the hop potentials. That is: the values which stay the same after we apply step given by the above equations. As before (please see Lemma 1), these values will be used as the upper bounds for the expected values of potentials. In the case of ğ»4,ğ‘›, we get that for every t and k:

ğ”¼[ğœ™ğ‘˜(ğ‘¡)]â‰¤25ğ‘˜(ğ‘›âˆ’ğ‘˜)+ğ›¼.
(20)
Here, extra term ğ›¼ has a closed form, which we omit and instead concentrate on the property that it is upper bounded by 2n. Observe that since the Harary graph contains cycle and we defined our hop potentials based on the hop counts of that cycle, we can upper bound the gap by using:

ğ”¼[ğºğ‘ğ‘(ğ‘¡)]â‰¤âˆ‘ğ‘˜=1ğ‘š12ğ‘šâˆ’ğ‘˜â€¾â€¾â€¾â€¾â€¾âˆšğ”¼ğœ™2ğ‘šâˆ’ğ‘˜(ğ‘¡)â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆšâ‰¤ğ‘‚(ğ‘›âˆšlogğ‘›).
(21)
Notice that since ğ›¼â‰¤2ğ‘›, for large enough k and n, the upper bound for ğ”¼[ğœ™ğ‘˜(ğ‘¡)] can be two times smaller than the upper bound for the cycle case, which was shown in Lemma 1. Hence, we can use this to slightly improve the constant hidden by big O notation in the upper bound. In general, we conjecture that for any pair of parameters 1â‰¤ğ‘™1<ğ‘™2â‰¤ğ‘›, a gap for the Harary graph ğ»2ğ‘™2,ğ‘› is smaller than a gap for the Harary graph ğ»2ğ‘™1,ğ‘›. Unfortunately, we are not able to provide the exact dependence of a gap on the Harary graph parameter.

Discussion and Future Work
We have shown that in the case of dynamic averaging on a cycle the gap between highest and lowest loaded bins is upper bounded by ğ‘‚(ğ‘›âˆšlogğ‘›) in expectation. Additionally we showed that the expected square of the gap is lower bounded by Î©(ğ‘›). It the future, it would be interesting to further tighten our results, matching our experimental analysis. We conjecture that the â€œcorrectâ€ bound on the expected gap is Î˜(ğ‘›âˆš). As already discussed, we also plan to extend our results to more general graph families, in particular grid graphs.

Comparison of Two-Choice and Averaging Load Balancing
Finally, it is interesting to ask if it is possible to extend our gap bounds to the case of the classic two-choice load balancing process. In particular, is it possible to show that the gap in the case of averaging process is always smaller in expectation than the gap in the case of two choice process? Intuitively this should be the case, since the load balancing operation in the case of averaging can be viewed as picking up a random edge, incrementing the load of the less loaded endpoint, and then averaging the values. The extra averaging step should not make the gap larger. Indeed, the exponential potential used to analyse the gap in [17] can be used to upper bound the gap for the averaging process, since the exponential function is convex and averaging values does not increase it (by Jensenâ€™s inequality).

Unfortunately, it is not clear if averaging helps to actually decrease the exponential potential. Additionally, this argument shows that averaging does not make the gap worse if applied to the particular technique of upper bounding the gap, and it is not clear if the gap itself is actually smaller, if we use averaging on top of the two-choice process. We conjecture that there exists a majorization argument which is based on how often the process performs the averaging step. More precisely, we consider the setting where after the increment step (using two choice), we perform averaging with probability ğ›½. The gap should decrease in expectation as we increase ğ›½. Note that the only result which lower bounds the gap for the two-choice process on the cycle is the straightforward Î©(logğ‘›) lower bound which can be shown for the clique [17]. Where The lower bound comes from the observation that if Î©(ğ‘›logğ‘›) balls of weight one are placed into n bins according to the two choice process, then the average load is Î©(logğ‘›) and with constant probability there exists a bin which is empty. What would make the existence of the majorization argument interesting is that it would allow us to show that the lower bound we derived on the second moment of the gap while always performing averaging step on the cycle (ğ›½=1) can be automatically used as the lower bound on the gap for two choice on the cycle (ğ›½=0). We plan to investigate this connection in future work.