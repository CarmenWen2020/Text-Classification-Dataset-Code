Abstract
The Fréchet distance is a popular similarity measure between curves. For some applications, it is desirable to match the curves under translation before computing the Fréchet distance between them. This variant is called the Translation Invariant Fréchet distance, and algorithms to compute it are well studied. The query version, finding an optimal placement in the plane for a query segment where the Fréchet distance becomes minimized, is much less well understood. We study Translation Invariant Fréchet distance queries in a restricted setting of horizontal query segments. More specifically, we preprocess a trajectory in (𝑛2log2𝑛) time and (𝑛3/2) space, such that for any subtrajectory and any horizontal query segment we can compute their Translation Invariant Fréchet distance in (polylog𝑛) time. We hope this will be a step towards answering Translation Invariant Fréchet queries between arbitrary trajectories.

Access provided by University of Auckland Library

Introduction
The Fréchet distance is a popular measure of similarity between curves as it takes into account the location and ordering of the points along the curves, and it was introduced by Fréchet [12]. Measuring the similarity between curves is an important problem in many areas of research, including computational geometry [2, 4, 11], computational biology [15, 26], data mining [16, 21, 24], image processing [1, 22] and geographical information science [17, 19, 20, 23].

The Fréchet distance is most commonly described as the dog-leash distance. Let a trajectory be a polygonal curve in Euclidean space. Consider a man standing at the starting point of one trajectory and the dog at the starting point of another trajectory. A leash is required to connect the dog and its owner. Both the man and his dog are free to vary their speed, but they are not allowed to go backward along their trajectory. The cost of a walk is the maximum leash length required to connect the dog and its owner from the beginning to the end of their trajectories. The Fréchet distance is the minimum length of the leash that is needed over all possible walks. More formally, for two curves A and B each having complexity n, the Fréchet distance between A and B is defined as:

𝛿𝐹(𝐴,𝐵)=inf𝜇max𝑎∈𝐴dist(𝑎,𝜇(𝑎))
where dist(𝑎,𝑏) denotes the Euclidean distance between point a and b and 𝜇:𝐴→𝐵 is a continuous and non-decreasing function that maps every point in 𝑎∈𝐴 to a point in 𝜇(𝑎)∈𝐵.

Since the early 90’s the problem of computing the Fréchet distance between two polygonal curves has received considerable attention. Alt and Godau [2] were the first to consider the problem and gave an (𝑛2log𝑛) time algorithm for the problem. The only improvement since then is a randomized algorithm with running time (𝑛2(loglog𝑛)2) in the word RAM model by Buchin et al. [7]. Bringmann [4] showed that, conditional on the Strong Exponential Time Hypothesis (SETH), there cannot exist an algorithm with running time (𝑛2−𝜀) for any 𝜀>0. Even for realistic models of input curves, such as c-packed curves [11], where the total length of edges inside any ball is bounded by c times the radius of the ball, exact distance computation requires 𝑛2−𝑜(1) time under SETH [4]. Only by allowing a (1+𝜀)-approximation can one obtain near-linear running times in n and c on c-packed curves [5, 11].

In some applications, it is desirable to match the two curves under translation before computing the Fréchet distance between them. For example, in sign language or in handwriting recognition, translating an entire movement pattern in space does not change the meaning of the pattern. Other applications where this is true include finding common movement patterns of athletes in sports, of animals in behavioural ecology, or to find similar proteins.

Formally, we match two polygonal curves A and B under the Fréchet distance by computing the translation 𝜏 so that the Fréchet distance between 𝐴+𝜏 and B is minimised. This variant is called the Translation Invariant Fréchet distance, and algorithms to compute it are well studied [3, 6, 15, 25]. Algorithms for the Translation Invariant Fréchet distance generally carry higher running times than for the standard Fréchet distance, moreover, these running times depend on the dimension of the input curves and on whether the discrete or continuous variant of the Fréchet distance is used.

For a discrete sequence of points in two dimensions, Bringmann et al. [6] recently provided an (𝑛14/3) time algorithm to compute the Translation Invariant Fréchet distance, and showed that the problem has a conditional lower bound of Ω(𝑛4) under SETH. For continuous polygonal curves in two dimensions, Alt et al. [3] provided an (𝑛8log𝑛) time algorithm, and Wenk [25] extended this to an (𝑛11log𝑛) time algorithm in three dimensions. If we allow for a (1+𝜀)-approximation then there is an (𝑛2/𝜀2) time algorithm [3], which matches conditional lower bound for approximating the standard Fréchet distance [4].

For both the standard Fréchet distance and the Translation Invariant Fréchet distance, subquadratic and subquartic time algorithms respectively are unlikely to exist under SETH [4, 6]. However, if at least one of the trajectories can be preprocessed, then the Fréchet distance can be computed much more efficiently.

Querying the standard Fréchet distance between a given trajectory and a query trajectory has been studied [9,10,11, 13, 14], but due to the difficult nature of the query problem, data structures only exist for answering a restricted class of queries. There are three results which are most relevant. The first is De Berg et al.’s [10] data structure, which answers Fréchet distance queries between a horizontal query segment and a vertex-to-vertex subtrajectory of a preprocessed trajectory. Their data structure can be constructed in (𝑛2log2𝑛) time using (𝑛2) space such that queries can be answered in (log2𝑛) time. The second is a follow up paper by Buchin et al. [8], which proves that the data structure of De Berg et al.’s [10] requires only (𝑛3/2) space. The third is Driemel and Har-Peled’s [11] data structure, which answers approximate Fréchet distance queries between a query trajectory of complexity k and a vertex-to-vertex subtrajectory of a preprocessed trajectory. The data structure can be constructed in (𝑛log3𝑛) using (𝑛log𝑛) space, and a constant factor approximation to the Fréchet distance can be answered in (𝑘2log𝑛log(𝑘log𝑛)) time. In the special case when 𝑘=1, the approximation ratio can be improved to (1+𝜀) with no increase in preprocessing or query time in terms of n. New ideas are required for exact Fréchet distance queries on arbitrary query trajectories. Other query versions for the standard Fréchet distance have also been considered [9, 13, 14].

Querying the Translation Invariant Fréchet distance is less well understood. This is not surprising given the complexity of computing the Translation Invariant Fréchet distance. Nevertheless, in our paper we are able to answer exact Translation Invariant Fréchet queries in a restricted setting of horizontal query segments. We hope this will be a step towards answering exact Translation Invariant Fréchet queries between arbitrary trajectories.

In this paper, we answer exact Translation Invariant Fréchet distance queries between a subtrajectory (not necessarily vertex-to-vertex) of a preprocessed trajectory and a horizontal query segment. The data structure can be constructed in (𝑛2log2𝑛) time using (𝑛3/2) space such that queries can be answered in (polylog𝑛) time. We use Megiddo’s parametric search technique [18] to De Berg et al.’s [10] data structure to optimise the Fréchet distance. We hope that as standard Fréchet distance queries become more well understood, similar optimisation methods could lead to improved data structures for the Translation Invariant Fréchet distance as well.

Preliminaries
Let 𝑝1,…,𝑝𝑛 be a sequence of n points in the plane. We denote 𝜋=(𝑝1,𝑝2…, 𝑝𝑛) to be the polygonal curve defined by this sequence. Let 𝑥0≤𝑥1 and 𝑦∈ℝ, and define 𝑝=(𝑥0,𝑦) and 𝑞=(𝑥1,𝑦) so that 𝑄=𝑝𝑞 is a horizontal segment in the plane. Let u and v be two points on the trajectory 𝜋, then from [10], the Fréchet distance between 𝜋[𝑢,𝑣] and Q can be computed by using the formula:

𝛿𝐹(𝜋[𝑢,𝑣],𝑝𝑞)=max{‖𝑢𝑝‖,‖𝑣𝑞‖,𝛿ℎ→(𝜋[𝑢,𝑣],𝑝𝑞),𝐵(𝜋[𝑢,𝑣],𝑦)}.
The first two terms are simply the distance between the starting points of the two trajectories, and the ending points of the two trajectories. The third term is the directed Hausdorff distance between 𝜋[𝑢,𝑣] and Q which can be computed from:

𝛿ℎ→(𝜋[𝑢,𝑣],𝑄)=max{max𝑝𝑖⋅𝑥∈(−∞,𝑥0]‖𝑝−𝑝𝑖‖,max𝑝𝑖⋅𝑥∈[𝑥1,∞)‖𝑞−𝑝𝑖‖,max𝑖‖𝑦−𝑝𝑖⋅𝑦‖},
where each 𝑝𝑖 in the formula above is a vertex of the subtrajectory 𝜋[𝑢,𝑣], and 𝑝𝑖.𝑥 denotes the x-coordinate of 𝑝𝑖. The formula handles three cases for mapping every point of 𝜋[𝑢,𝑣] to its closest point on Q. The first term describes mapping points of 𝜋[𝑢,𝑣] to the left of p to their closest point p. The second term describes mapping points of 𝜋[𝑢,𝑣] to the right of q analogously. The third term describes mapping points of 𝜋[𝑢,𝑣] that are in the vertical strip between p and q to their orthogonal projection onto Q. In later sections we refer to these three terms as 𝛿ℎ→(𝐿), 𝛿ℎ→(𝑅) and 𝛿ℎ→(𝑀) for the left, right, and middle terms of the Hausdorff distance respectively.

The fourth term in our formula for the Fréchet distance is the maximum backward pair distance over all backward pairs. A pair of vertices (𝑝𝑖,𝑝𝑗) (with 𝑗>𝑖) is a backward pair if 𝑝𝑗 lies to the left of 𝑝𝑖. The backward pair distance of 𝜋[𝑢,𝑣] can be computed from:

𝐵(𝜋[𝑢,𝑣],𝑦)=max∀𝑝𝑖,𝑝𝑗∈𝜋[𝑢,𝑣]:𝑖≤𝑗,𝑝𝑖.𝑥≥𝑝𝑗.𝑥𝐵(𝑝𝑖,𝑝𝑗)(𝑦),
where 𝐵(𝑝𝑖,𝑝𝑗)(𝑦) is the backward pair distance for a given backward pair (𝑝𝑖,𝑝𝑗) and is defined as

𝐵(𝑝𝑖,𝑝𝑗)(𝑦)=min𝑥∈ℝmax{‖𝑝𝑖−(𝑥,𝑦)‖,‖𝑝𝑗−(𝑥,𝑦)‖}.
The distance terms in the braces compute the distance between a given point (x, y) and the farthest of 𝑝𝑖 and 𝑝𝑗. Let us call this the backward pair distance of (x, y). Then the function 𝐵(𝑝𝑖,𝑝𝑗)(𝑦) denotes the minimum backward pair distance of a given backward pair (𝑝𝑖,𝑝𝑗) over all points (x, y) which have the same y-coordinate. Taking the maximum over all backward pairs gives us the backward pair distance for 𝜋[𝑢,𝑣]. Note that the backwards pair distance doesn’t need a restriction to the x-coordinates of the horizontal segment and only depends on the y-coordinate of the horizontal segment.

In Fig. 1, on the left, we show in red the point with minimum backward pair distance for (𝑝𝑖,𝑝𝑗), for each y-coordinate. We show in red the associated distance for the minimum backwards pair distance on the right, where the distance is plotted along the x-axis. We see in the figure that the function 𝐵(𝑝𝑖,𝑝𝑗)(𝑦) consists of two linear functions joined together in the middle with a hyperbolic function.

Fig. 1
figure 1
For each y-coordinate, Left: the point with minimum backward pair distance, Right: the minimum backward pair distance

Full size image
We extend the work of De Berg et al. [10] in two ways. First, we provide a method for answering Fréchet distance queries between 𝜋[𝑢,𝑣] and Q when u and v are not necessarily vertices of 𝜋, and second, we optimise the placement of Q to minimise its Fréchet distance to 𝜋[𝑢,𝑣]. We achieve both of these extensions by carefully applying Megiddo’s parametric search technique [18] to compute the optimal Fréchet distance.

In order to apply parametric search, we are required to construct a set of critical values (which we will describe in detail at a later stage) so that an optimal solution is guaranteed to be contained within this set. Since this set of critical values is often large, we need to avoid computing the set explicitly, but instead design a decision algorithm that efficiently searches the set implicitly. Megiddo’s parametric search [18] states that if:

the set of critical values has polynomial size, and

the Fréchet distance is convex with respect to the set of critical values, and

a comparison-based decision algorithm decides if a given critical value is equal to, to the left of, or to the right of the optimum,

then there is an efficient algorithm to compute the optimal Fréchet distance in (𝑃𝑇𝑝+𝑇𝑝𝑇𝑠log𝑃) time, where P is the number of processors of the (parallel) algorithm, 𝑇𝑝 is the parallel running time and 𝑇𝑠 is the serial running time of the decision algorithm. For our purposes, 𝑃=1 since we run our queries serially, and 𝑇𝑝=𝑇𝑠 = (polylog𝑛) for the decision versions of our query algorithms.

Computing the Fréchet Distance
The first problem we apply parametric search to is the following. Given any horizontal query segment Q in the plane and any two points u, v on 𝜋 (not necessarily vertices of 𝜋), determine the Fréchet distance between Q and the subtrajectory 𝜋[𝑢,𝑣].

Fig. 2
figure 2
The points 𝑝′ and 𝑞′ mapped to the vertices 𝑝𝑢 and 𝑝𝑣 of the trajectory

Full size image
Let 𝑝𝑢 be the first vertex of 𝜋 along 𝜋[𝑢,𝑣] and let 𝑝𝑣 be the last vertex of 𝜋 along 𝜋[𝑢,𝑣], as illustrated in Fig. 2. If 𝑝𝑢 and 𝑝𝑣 do not exist then 𝜋[𝑢,𝑣] is a single segment so the Fréchet distance between 𝜋[𝑢,𝑣] and Q can be computed in constant time. Otherwise, our goal is to build a Fréchet mapping 𝜇:𝜋[𝑢,𝑣]→𝑄 which attains the optimal Fréchet distance. We build this mapping 𝜇 in several steps. Our first step is to compute points 𝑝′ and 𝑞′ on the horizontal segment pq so that 𝑝′=𝜇(𝑝𝑢) and 𝑞′=𝜇(𝑝𝑣).

If the point 𝑝′ is computed correctly, then the mapping 𝑝′→𝑝𝑢 allows us to subdivide the Fréchet computation into two parts without affecting the overall value of the Fréchet distance. In other words, we obtain the following formula:

𝛿𝐹(𝜋[𝑢,𝑣],𝑝𝑞)=max{𝛿𝐹(𝑢𝑝𝑢,𝑝𝑝′),𝛿𝐹(𝜋[𝑝𝑢,𝑣],𝑝′𝑞)}
(1)
We now apply the same argument to 𝑝𝑣. We compute 𝑞′ optimally on the horizontal segment 𝑝′𝑞 optimally so that mapping 𝑝𝑣→𝑞′ does not increase the Fréchet distance between the subtrajectory 𝜋[𝑝𝑢,𝑣] and the truncated segment 𝑝′𝑞. In other words, we have:

𝛿𝐹(𝜋[𝑢,𝑣],𝑝𝑞)=max{𝛿𝐹(𝑢𝑝𝑢,𝑝𝑝′),𝛿𝐹(𝜋[𝑝𝑢,𝑝𝑣],𝑝′𝑞′),𝛿𝐹(𝑝𝑣𝑣,𝑞′𝑞)}
(2)
Now that 𝑝𝑢 and 𝑝𝑣 are vertices of 𝜋, [10] provides an efficient data structure for computing the middle term 𝛿𝐹(𝜋[𝑝𝑢,𝑝𝑣],𝑝′𝑞′). The first and last terms have constant complexity and can be handled in constant time. All that remains is to compute the points 𝑝′ and 𝑞′ efficiently.

Theorem 1
Given a trajectory 𝜋 with n vertices in the plane. There is a data structure that uses (𝑛2log2𝑛) preprocessing time and (𝑛3/2) space, such that for any two points u and v on 𝜋 (not necessarily vertices of 𝜋) and any horizontal query segment Q in the plane, one can determine the exact Fréchet distance between Q and the subtrajectory from u to v in (log8𝑛) time.

Proof
Decision Algorithm Let S be the set of critical values (defined later in this proof), let s be the current candidate for the point 𝑝′, and let 𝐹(𝑠)=max{𝛿𝐹(𝑝𝑠,𝑢𝑝𝑢),𝛿𝐹(𝑠𝑞,𝜋[𝑝𝑢,𝑣])} be the minimum Fréchet distance between pq and 𝜋[𝑢,𝑣] subject to 𝑝𝑢 being mapped to s. Our aim is to design a decision algorithm that runs in (log4𝑛) time that decides whether the optimal 𝑝′ is equal to s, to the left of s or to the right of s. This is equivalent to proving that all points to one side of s cannot be the optimal 𝑝′ and may be discarded.

We use the Fréchet distance formula from Sect. 2 to rewrite 𝐹(𝑠)=max(‖𝑢𝑝‖,‖𝑣𝑞‖, ‖𝑝𝑢𝑠‖, 𝛿ℎ→(𝜋[𝑝𝑢,𝑣],𝑠𝑞),𝐵(𝜋[𝑝𝑢,𝑣],𝑦)). Then we take several cases for which of these five terms attains the maximum value F(s), and in each case we either deduce that 𝑝′=𝑠 or all critical values to one side of s may be discarded.

If 𝐹(𝑠)=max(‖𝑢𝑝‖,‖𝑣𝑞‖,𝐵(𝜋[𝑝𝑢,𝑣],𝑦)), then 𝑝′=𝑠. We observe that none of the three terms on the right hand side of the equation depend on the position of s. Hence, 𝐹(𝑠)=max(‖𝑢𝑝‖,‖𝑣𝑞‖,𝐵(𝜋[𝑝𝑢,𝑣],𝑦))≤𝐹(𝑝′), and since 𝐹(𝑝′) is the minimum possible value, 𝐹(𝑠)=𝐹(𝑝′). We have found a valid candidate for 𝑝′ and can discard all other candidates in the set S.

If 𝐹(𝑠)=‖𝑝𝑢𝑠‖ and 𝑝𝑢 is to the right (left) of s (see Fig. 3), then 𝑝′ is to the right (left) of s. We will argue this for when 𝑝𝑢 is to the right of s, but an analogous argument can be used when 𝑝𝑢 is to the left. We observe that all points t to the left of s will now have ‖𝑝𝑢𝑡‖>‖𝑝𝑢𝑠‖. Hence, 𝐹(𝑠)=‖𝑝𝑢𝑠‖<‖𝑝𝑢𝑡‖≤𝐹(𝑡) for all points t to the left of s, therefore all points to the left of s may be discarded.

If 𝐹(𝑠)=𝛿ℎ→(𝜋[𝑝𝑢,𝑣],𝑠𝑞), then 𝑝′ is to the left of s (see Fig. 4). The directed Hausdorff distance maps every point in 𝜋[𝑝𝑢,𝑣] to their closest point on sq, so by shortening sq to tq for some point t on sq to the right of s, the directed Hausdorff distance cannot decrease. Hence, 𝐹(𝑠)≤𝐹(𝑡) for all t to the right of s, so all points to the right of s may be discarded.

Fig. 3
figure 3
The decision algorithm moving to the right of the current candidate

Full size image
Fig. 4
figure 4
The decision algorithm moving to the left of the current candidate

Full size image
To determine 𝑞′ for a fixed candidate s for 𝑝′, we treat the problem in a similar way. We consider the subtrajectory 𝜋[𝑝𝑢,𝑣] and the horizontal line segment sq. Defining a function G(t) representing the Fréchet distance when 𝑝𝑣 is mapped to t, we obtain a similar decision algorithm. The most notable difference is that since we now consider the end of the subtrajectory, the decisions for moving t left and right are reversed.

Convexity We will prove that F(s) is convex, and it will follow similarly that G(t) is convex. It suffices to show that F(s) is the maximum of convex functions, since the maximum of convex functions is itself convex. The three terms ‖𝑢𝑝‖, ‖𝑣𝑞‖, 𝐵(𝜋[𝑝𝑢,𝑣],𝑦) are constant. The term ‖𝑝𝑢𝑠‖ is an upward hyperbola and is convex. If suffices to show that 𝛿ℎ→(𝜋[𝑝𝑢,𝑣],𝑠𝑞) is convex.

We observe that the Hausdorff distance 𝛿ℎ→(𝜋[𝑝𝑢,𝑣],𝑠𝑞) must be attained at a vertex 𝑝𝑖 of 𝜋[𝑝𝑢,𝑣], and that each of 𝛿ℎ→(𝑝𝑖,𝑠𝑞) as a function of s is a constant function between p and 𝑝∗𝑖, and a hyperbolic function between 𝑝∗𝑖 and q. Thus, the function for each 𝑝𝑖 is convex, so the overall Hausdorff distance function is also convex.

Critical Values A critical value is a value c which could feasibly attain the minimum value 𝐹(𝑐)=𝐹(𝑝′). We represent F(s) as the minimum of n simple functions and then argue that the minimum of F can only occur at the minimum of one of these functions, or at the intersection of a pair of these functions.

First, ‖𝑢𝑝‖,‖𝑣𝑞‖,𝐵(𝜋[𝑝𝑢,𝑣],𝑦) are constant functions in terms of s. Next, ‖𝑝𝑢𝑠‖ is a hyperbolic function. Finally, 𝛿ℎ→(𝜋[𝑝𝑢,𝑣],𝑠𝑞) is not itself simple, but it can be rewritten as the combination of n simple functions as described in the above section.

Hence, F(s) is the combination (maximum) of n simple functions, and these functions are simple in that they are piecewise constant or hyperbolic. Hence F(s) attains its minimum either at the minimum of one of these n functions, or at a point where two of these functions intersect. Therefore, there are at most (𝑛2) critical values for F(s).

Query Complexity Computing 𝑞′ for a given candidate s for 𝑝′ takes (log4𝑛) time: We can compute the terms ‖𝑢𝑝‖, ‖𝑝𝑢𝑠‖, ‖𝑣𝑞‖, and ‖𝑝𝑣𝑞′‖ in constant time. The terms 𝐵(𝜋[𝑝𝑢,𝑝𝑣],𝑦) and 𝛿ℎ→(𝜋[𝑝𝑢,𝑝𝑣],𝑠𝑞′) can be computed in (log2𝑛) time using the existing data structure by De Berg et al. [10]. We need to determine the time complexity of the sequential algorithm 𝑇𝑠, parallel algorithm 𝑇𝑝, and the number of the processor P. To find 𝑞′, the decision algorithm takes 𝑇𝑠=(log2𝑛). The parallel form runs on one processor in 𝑇𝑝=(log2𝑛). Substituting these values in the running time of the parametric search of (𝑃𝑇𝑝+𝑇𝑝𝑇𝑠log𝑃) leads to (log4𝑛) time.

The above analysis implies that 𝑝′ itself can be computed in (log8𝑛) time: For a given s, the decision algorithm runs in 𝑇𝑠=(log4𝑛) as mentioned above. The parallel form of the decision algorithm runs on one processors in 𝑇𝑝=(log4𝑛). Substituting these values in the running time of the parametric search of (𝑃𝑇𝑝+𝑇𝑝𝑇𝑠log𝑃) leads to (log8𝑛) time.

Preprocessing and Space To compute the second term of Formula 2, we use the data structure by De Berg et al. [10]. This data structure uses (𝑛2log2𝑛) preprocessing time and supports (log2𝑛) query time. Recently, the data structure was shown to require only (𝑛3/2) space [8]. ◻

We note that the set of critical values can be restricted significantly, while still being guaranteed to contain optimal elements to use as 𝑝′ and 𝑞′. Specifically, we can reduce the size of this set from (𝑛2) to (𝑛). Since this does not improve the running time of the above algorithm, details on this improvement are deferred to Appendix A.

Minimizing the Fréchet Distance Under Vertical Translation
We move on to the problem of minimising Fréchet distance under translations. We first focus on a special case where the horizontal segment can only be translated vertically. In Sect. 5 we consider arbitrary translations of the horizontal segment.

To this end, let us consider the following problem. Let 𝜋 be a trajectory in the plane with n vertices. We preprocess 𝜋 into a data structure such that for a query specified by

1.
two points u and v on the trajectory 𝜋,

2.
two vertical lines 𝑥1 and 𝑥2 such that ‖𝑥2−𝑥1‖=𝐿,

one can quickly find a horizontal segment 𝑙𝑦 that spans the vertical strip between 𝑥1 and 𝑥2 such that the Fréchet distance between 𝑙𝑦 and the subtrajectory 𝜋[𝑢,𝑣] is minimised; see Fig. 5.

Fig. 5
figure 5
Finding a horizontal segment 𝑙𝑦 in the vertical strip between 𝑥1 and 𝑥2 that minimises the Fréchet distance between 𝑙𝑦 and 𝜋[𝑢,𝑣]

Full size image
In the next theorem, we present a decision problem 𝐷𝜋[𝑢,𝑣](𝑥1,𝑥2,𝑙𝑐𝑦) that, for a given trajectory 𝜋 with two points u and v on 𝜋 and two vertical lines 𝑥=𝑥1 and 𝑥=𝑥2, returns whether the line 𝑙𝑦 is above, below, or equal to the current candidate line 𝑙𝑐𝑦. We then use parametric search to find 𝑙𝑦 that minimises the Fréchet distance.

Theorem 2
Given a trajectory 𝜋 with n vertices in the plane. There is a data structure that uses (𝑛2log2𝑛) preprocessing time and (𝑛3/2) space, such that for any two points u and v on 𝜋 (not necessarily vertices of 𝜋) and two vertical lines 𝑥=𝑥1 and 𝑥=𝑥2, one can determine the horizontal segment 𝑙𝑦 with left endpoint on 𝑥=𝑥1 and right endpoint on 𝑥=𝑥2 that minimises its Fréchet distance to the subtrajectory 𝜋[𝑢,𝑣] in (log16𝑛) time.

Proof
Decision Algorithm Let 𝑙𝑐𝑦 be the current horizontal segment. To decide whether the line segment that minimises the Fréchet distance lies above or below 𝑙𝑐𝑦, we must compute the maximum of the terms that determine the Fréchet distance: ‖𝑢𝑝‖, ‖𝑣𝑞‖, 𝛿ℎ→(𝜋[𝑢,𝑣],𝑝𝑞), and 𝐵(𝜋[𝑢,𝑣],𝑙𝑐𝑦). As mentioned in Sect. 2, we divide the directed Hausdorff distance into three different terms: 𝛿ℎ→(𝐿), 𝛿ℎ→(𝑅), and 𝛿ℎ→(𝑀). We first consider when one term determines the Fréchet distance, in which we have the following cases:

‖𝑢𝑝‖, ‖𝑣𝑞‖, 𝛿ℎ→(𝐿), and 𝛿ℎ→(𝑅): since the argument for these terms is analogous, we focus on ‖𝑢𝑝‖. If u is located above 𝑙𝑐𝑦, the next candidate lies above 𝑙𝑐𝑦 (search continues above 𝑙𝑐𝑦). If u lies below 𝑙𝑐𝑦, the next candidate lies below 𝑙𝑐𝑦 (search continues below 𝑙𝑐𝑦). If u and p have the same y-coordinate, we can stop, since moving 𝑙𝑐𝑦 either up or down increases the Fréchet distance.

𝐵(𝜋[𝑢,𝑣],𝑙𝑐𝑦): if the midpoint of the segment between the backward pair determining the current Fréchet distance is located above 𝑙𝑐𝑦, the next candidate lies above 𝑙𝑐𝑦, since this is the only way to decrease the distance to the further of the two points of the backward pair. If this midpoint lies below 𝑙𝑐𝑦, the next candidate lies below 𝑙𝑐𝑦. If the midpoint is located on 𝑙𝑐𝑦, we can stop, because the term 𝐵(𝑝𝑖,𝑝𝑗)(𝑙𝑐𝑦) increases by either moving 𝑙𝑐𝑦 up or down.

𝛿ℎ→(𝑀): if the point with maximum projected distance is located above 𝑙𝑐𝑦, the next candidate lies above 𝑙𝑐𝑦. If the point is below 𝑙𝑐𝑦, the next candidate lies below 𝑙𝑐𝑦. If the point is on 𝑙𝑐𝑦, then we stop, but unlike in the first case, this maximum term and the overall Fréchet distance must both be zero in this case.

If more than one term determine the current Fréchet distance, we must first determine the direction of the implied movement for each term. If this direction is the same, we move in that direction. If the directions are opposite, we can stop, because moving in either direction would increase the other maximum term resulting in a larger Fréchet distance.

Convexity It suffices to show the Fréchet distance between 𝜋[𝑢,𝑣] and 𝑙𝑐𝑦 as a function of y is convex. We show that this function is the maximum of several convex functions, and therefore must be convex. The first two terms for computing the Fréchet distance are ‖𝑢𝑝‖ and ‖𝑣𝑞‖, which are hyperbolic in terms of y. Similarly to the previous section, we handle each of the Hausdorff distances by splitting them up Hausdorff distances for each vertex 𝑝𝑖. The left and right Hausdorff distances 𝛿ℎ→(𝐿) and 𝛿ℎ→(𝑅) for a single vertex 𝑝𝑖 is a hyperbolic function. The middle Hausdorff distance 𝛿ℎ→(𝑀) for a single vertex 𝑝𝑖 is a shifted absolute value function. In all cases, Hausdorff distance for a single vertex is convex, so the overall Hausdorff distance is also convex. Finally, the backward pair distance 𝐵(𝜋[𝑢,𝑣],𝑙𝑐𝑦) as a function of y is shown by De Berg et al. [10] to be two rays joined together in the middle with a hyperbolic arc. It is easy to verify that this function is convex.

Critical Values A horizontal segment 𝑙𝑐𝑦 is a critical value of a decision algorithm if the decision algorithm could feasibly return that 𝑙𝑐𝑦=𝑙𝑦. These critical values are the y-coordinates of the intersection points of two hyperbolic functions for each combination of two terms of determining the Fréchet distance or the minimum point of the upper envelope of two such hyperbolic functions. Therefore, there are only a constant number of critical values for each two terms. Each term gives rise to (𝑛2) hyperbolic functions (specifically, 𝐵(𝜋[𝑢,𝑣],𝑙𝑐𝑦) can be of size Θ(𝑛2) in the worst case). Thus, there are (𝑛4) critical values.

Query Complexity The decision algorithm runs in 𝑇𝑠=𝑇𝑝=(log8𝑛) time since we use Theorem 1 to compute the Fréchet distance for a fixed 𝑙𝑐𝑦. Substituting this in the running time of the parametric search (𝑃𝑇𝑝+𝑇𝑝𝑇𝑠log𝑃) leads to a query time of (log16𝑛).

Preprocessing and Space Since we compute the Fréchet distance of the current candidate 𝑙𝑐𝑦 using Theorem 1, we require (𝑛2log2𝑛) preprocessing time and (𝑛3/2) space. ◻

Minimizing the Fréchet Distance for Arbitrary Placement
Finally, we consider minimising the Fréchet distance of a horizontal segment under arbitrary placement. Let 𝜋 be a trajectory in the plane with n vertices. We preprocess 𝜋 into a data structure such that for a query specified by two points u and v on 𝜋 and a positive real value L, one can quickly determine the horizontal segment l of length L such that the Fréchet distance between l and the subtrajectory 𝜋[𝑢,𝑣] is minimised.

In the following theorem, we present a decision problem 𝐷𝜋[𝑢,𝑣](𝐿,𝑥1) that, for a given trajectory 𝜋 with two points u and v on 𝜋 and a length L and an x-coordinate 𝑥1, returns whether the line l has its left endpoint to the left, on, or to the right of 𝑥1. We then apply parametric search to this decision algorithm to find the horizontal segment l of length L with minimum Fréchet distance to 𝜋[𝑢,𝑣].

Theorem 3
Given a trajectory 𝜋 with n vertices in the plane. There is a data structure that uses (𝑛2log2𝑛) preprocessing time and (𝑛3/2) space, such that for any two points u and v on 𝜋 (not necessarily vertices of 𝜋) and a length L,  one can determine the horizontal segment l of length L that minimises the Fréchet distance to 𝜋[𝑢,𝑣] in (log32𝑛) time.

Proof
Decision Algorithm For the decision algorithm, we only need to decide whether 𝑙𝑐 should be moved to the left or right, with respect to its current position. We classify the terms that determine the Fréchet distance in two classes:

𝐶1: this class contains the terms whose value is determined by the distance from a point on 𝜋(𝑢,𝑣) to p or q. Hence, it consists of ‖𝑢𝑝‖, ‖𝑣𝑞‖, 𝛿ℎ→(𝑅), and 𝛿ℎ→(𝐿).

𝐶2: this class contains the terms whose value is determined by the distance from a point on 𝜋(𝑢,𝑣) to the closest point on pq. Hence, it consists of 𝛿ℎ→(𝑀) and 𝐵(𝜋[𝑢,𝑣],𝑙𝑦).

Next, we show how to decide whether the next candidate line segment lies to the left or right of 𝑙𝑐 (i.e., the x-coordinate of its left endpoint lies to the left or right of the left endpoint of 𝑙𝑐) for each case where 𝐷𝜋[𝑢,𝑣](𝑥1,𝑥2,𝑙𝑦) stops.

We decide this by considering each 𝐶1 and 𝐶2 term and the restriction they place on the next candidate line segment pq. After we do this for each individual 𝐶1 or 𝐶2 term, we take the intersection of all these restrictions. If the intersection is empty, then our placement of pq was optimal, and our decision algorithm stops. Otherwise we can either move pq to the left or to the right to improve the Fréchet distance.

First, consider the 𝐶1 terms. Let us assume for now that the 𝐶1 term is the distance term ‖𝑢𝑝‖. Then in order to improve the Fréchet distance to u, we need to place the horizontal segment pq in such a way that p lies inside the open disk centered at u with radius equal to the current Fréchet distance d. A similar condition holds for the other 𝐶1 terms: each defines a disk of radius d and the point it maps to in the next candidate needs to lie inside this disk.

Similarly, the 𝐶2 terms define horizontal open half-planes. Consider the term 𝛿ℎ→(𝑀). This term is reduced when the vertical projection distance to the line segment is reduced. Hence, if the point defining this term lies above 𝑙𝑐, this term can be reduced by moving the line segment upward and thus the half-plane is the half-plane above 𝑙𝑐. An analogous statement holds if the point lies below 𝑙𝑐. For the term 𝐵(𝜋[𝑢,𝑣],𝑙𝑦), we need to consider the midpoint of the bisector, since the implied Fréchet distance is the distance from 𝑙𝑐 to the further of the two points defining the bisector. Thus, the half-plane that improves the Fréchet distance is the one that lies on the same side of 𝑙𝑐 as this midpoint.

To combine all the terms we do the following: First, we take all disks induced by the 𝐶1 terms whose distance is with respect to q and translate them horizontally to the left by a distance of L. This ensures that the disks constructed with respect to p can now be intersected with the disks constructed with respect to q. We take the intersection of all 𝐶1 and 𝐶2 terms that defined the stopping condition of the vertical optimisation step. If this intersection is empty, by construction there is no point where we can move p to in order to reduce the Fréchet distance. If it is not empty, we will show that it lies entirely to the left or entirely to the right of p and thus implies the direction in which the next candidate lies.

Now that we have described our general approach, we show which cases can occur and show that for each of them we can determine in which direction to continue (if any).

Case 1 𝐷𝜋[𝑢,𝑣](𝑥1,𝑥2,𝑙𝑦) stops because of terms in 𝐶1. If only a single term of 𝐶1 is involved, say ‖𝑢𝑝‖, this implies that the y-coordinate of u is the same as that of 𝑙𝑐 and thus its disk lies entirely to the left of p. Hence, we can reduce the Fréchet distance by moving 𝑙𝑐 horizontally towards u and thus we pick our next candidate in that direction. The same argument follows analogously the 𝐶1 term is ‖𝑣𝑞‖, 𝛿ℎ→(𝑅), or 𝛿ℎ→(𝐿), the same argument follows analogously the distance is between a point on the trajectory

If two terms of 𝐶1 are involved, say ‖𝑢𝑝‖ and ‖𝑣𝑞‖, their intersection can be empty (see Fig. 6a) or non-empty (see Fig. 6b). If it is empty, the midpoint of pq is the same as the midpoint of uv, which implies that we cannot reduce the Fréchet distance. If the intersection is not empty, moving the endpoint of the line segment into this region potentially reduces the Fréchet distance. We note that since ‖𝑢𝑝‖ and ‖𝑣𝑞‖ stopped the vertical optimisation, they lie on opposite sides of 𝑙𝑐. Hence, the intersection of their disks lies entirely to the left or entirely to the right of p and thus determines in which direction the next candidate lies.

If three terms in 𝐶1 are involved, we again construct the intersection as described earlier. If this intersection is empty (see Fig. 7b), we are again done. If it is not (see Fig. 7a), it again determines the direction in which the our next candidate lies, as the intersection of three disks is a subset of the intersection of two disks.

If there are more than three 𝐶1 terms, we reduce this to the case of three 𝐶1 terms. If the intersection of these disks is non-empty, then trivially the intersection of a subset of three of them is also non-empty. If the intersection is empty, we select a subset of three whose intersection is also empty. The three disks can be chosen as follows. Insert the disks in some order and stop when the intersection first becomes empty. The set of three disks consists of the last inserted disk and the two extreme disks among the previously inserted disks. Since the boundary of all the disks must go through a single point and the disks have equal radius, these three disks will have an empty intersection. Hence, the case of more than three disks reduces to the case of three disks.

Case 2 𝐷𝜋[𝑢,𝑣](𝑥1,𝑥2,𝑙𝑦) stops because of a term in 𝐶2. Since the vertical optimisation stopped, we know that at least two 𝐶2 terms are involved and there exists a pair that lies on opposite sides of 𝑙𝑐. These two terms define open half-planes whose intersection is empty, hence we cannot reduce the Fréchet distance further.

Case 3 𝐷𝜋[𝑢,𝑣](𝑥1,𝑥2,𝑙𝑦) stops because of terms in 𝐶1 and terms in 𝐶2. If there are at least three terms in 𝐶1, then we can ignore the 𝐶2 terms and use the analysis provided in Case 1 on the three terms in 𝐶1. If there are at least two terms in 𝐶2, then we can ignore the 𝐶1 terms and use the same analysis provided in Case 2 on the two terms in 𝐶2. Therefore, without loss of generality, we can assume that there are at most two 𝐶1 terms and at most one 𝐶2 terms.

The 𝐶2 term can be either 𝛿ℎ→(𝑀) (see Fig. 8a, where h is the point at distance d) or 𝐵(𝜋[𝑢,𝑣],𝑙𝑦) (see Fig. 8b, where (𝑝𝑖,𝑝𝑗) is the backward pair with distance d). The region R shows the intersection of the disk of a single 𝐶1 term and the 𝐶2 term. We note that since the point of the 𝐶1 term and the point of the 𝐶2 term lie on opposite sides of 𝑙𝑐, this intersection lies either entirely to the left or entirely to the right of p or q, determining the direction in which our next candidate must lie.

The same procedure can be applied when there are two 𝐶1 terms and using similar arguments, it can be shown that if the intersection is not empty, the direction to improve the Fréchet distance is uniquely determined.

Convexity Next, we show that 𝐷𝜋[𝑢,𝑣](𝐿,𝑥1) is a convex function with respect to the parameter 𝑥1. Let 𝑙𝑐𝑦 be the current horizontal segment and assume without loss of generality that the decision algorithm moves right to a new segment 𝑙𝑦′; see Fig. 9a. Consider a linear interpolation from 𝑙𝑐𝑦 to 𝑙𝑦′. Let 𝑙𝑦″ be the segment at the midpoint of this linear interpolation. Since 𝐷𝜋[𝑢,𝑣](𝐿,𝑥1) is a continuous function, for continuous functions, convex is the same as midpoint convex, this implies that we only need to show that 𝐷𝜋[𝑢,𝑣](𝐿,𝑥1) is midpoint convex.

Consider the two mappings that minimise the Fréchet distance between 𝜋[𝑢,𝑣] and the horizontal segments 𝑙𝑐𝑦 and 𝑙𝑦′. Let r be any point on 𝜋[𝑢,𝑣] and let a and c be the points where r is mapped to on 𝑙𝑦 and 𝑙𝑦′. Construct a point b on 𝑙𝑦″ where r will be mapped to by linearly interpolating a and c. Performing this transformation for every point on 𝜋[𝑢,𝑣], we obtain a valid mapping for 𝑙𝑦″, though not necessarily one of minimum Fréchet distance.

We bound the distance between r and b in terms of ‖𝑟𝑎‖ and ‖𝑟𝑐‖. Consider the parallelogram consisting of a, r, b, and a point 𝑟′ that is distance ‖𝑟𝑎‖ from c and distance ‖𝑟𝑐‖ from a; see Fig. 9b. Since b is the midpoint of ac, it is also the midpoint of 𝑟𝑟′ in this parallelogram. We can conclude that ‖𝑟𝑏‖≤(‖𝑟𝑎‖+‖𝑟𝑐‖)/2 in this mapping.

Since this property holds for any point r on 𝜋[𝑢,𝑣] and the Fréchet distance is the minimum over all possible mappings, the Fréchet distance of 𝑙𝑦″ is upper bounded by the average of the Fréchet distances of 𝑙𝑐𝑦 and 𝑙𝑦′. Therefore, the decision problem is convex.

Critical Values An x-coordinate 𝑥1 is a critical value of a decision algorithm if the decision algorithm could feasibly return that the left endpoint of l has x-coordinate 𝑥1.

For the 𝐶1 class, these critical values are determined by up to three 𝐶1 terms: the vertices themselves, the midpoint of any pair of vertices, and the center of the circle through the three (translated) points determining the Fréchet distance. Since each term in 𝐶1 consists of at most n points, there are (𝑛3) critical values in Case 1.

For the 𝐶2 class, these critical values are the x-coordinates of the intersection points and minima of two hyperbolic functions, one for each element of each pair of two terms. Therefore, there are only a constant number of critical values for each two terms. Each term gives rise to at most (𝑛2) hyperbolic functions (specifically, 𝐵(𝜋[𝑢,𝑣],𝑙𝑦) can be of size Θ(𝑛2) in the worst case). Thus, there are at most (𝑛4) critical values in Case 2.

Using similar arguments, it can be shown that there are at most (𝑛4) critical values in Case 3, as they consist of at most two 𝐶1 terms and at most one 𝐶2 term.

Query Complexity The decision algorithm runs in 𝑇𝑠=(log16𝑛) time since we use Theorem 2 to compute the optimal placement for a fixed left endpoint. The parallel form of the decision algorithm runs on one processor in 𝑇𝑝=(log16𝑛) time. Substituting these values in the running time of the parametric search of (𝑃𝑇𝑝+𝑇𝑝𝑇𝑠log𝑃) leads to (log32𝑛) time.

Preprocessing and Space Since we use the algorithm of Theorem 2 to the optimal placement of 𝑙𝑐 for a given x-coordinate of its left endpoint, this requires (𝑛2log2𝑛) preprocessing time and (𝑛3/2) space. ◻

Fig. 6
figure 6
Determining where 𝑙𝑐 should be moved to reduce the Fréchet distance

Full size image
Fig. 7
figure 7
The case where we have three 𝐶1 terms

Full size image
Fig. 8
figure 8
Reduce the Fréchet distance when it is determined by a term of 𝐶1 and a term of 𝐶2

Full size image
Fig. 9
figure 9
The decision algorithm is a convex function with respect to the left endpoint of the line segment

Full size image
Conclusion
In this paper, we answered Translation Invariant Frechet distance queries between a horizontal query segment and a subtrajectory of a preprocessed trajectory. The most closely related result is that of De Berg et al. [10], which computes the normal Fréchet distance between a subtrajectory and a horizontal query segment. We extended this work in two ways. Firstly, we considered all subtrajectories, not just vertex-to-vertex subtrajectories. Secondly, we computed the optimal translation for minimising the Fréchet distance, thus our approach allowed us to compute both the normal Fréchet distance and the Translation Invariant Fréchet distance. All our queries can be answered in polylogarithmic time.

In terms of future work, one avenue would be to improve the query times. While our approach has polylogarithmic query time, the (log32𝑛) time needed for querying the optimal placement under translation is far from practical. Furthermore, reducing the preprocessing time or space of the data structure would this would make the approach more appealing.

Other future work takes the form of generalising our queries further. In our most general form, we still work with a fixed length line segment with a fixed orientation. An interesting open problem is to see if we can also determine the optimal length of the line segment efficiently at query time. Allowing the line segment to have an arbitrary orientation seems a difficult problem to generalise our approach to, since the data structures we use assume that the line segment is horizontal. This can be extended to accommodate a constant number of orientations instead, but to extend this to truly arbitrary orientations, given at query time, will require significant modifications and novel ideas.