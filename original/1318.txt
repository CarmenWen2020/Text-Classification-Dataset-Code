Abstract
This study considers the soft capacitated vertex cover problem in a dynamic setting. This problem generalizes the dynamic model of the vertex cover problem, which has been intensively studied in recent years. Given a dynamically changing vertex-weighted graph ğº=(ğ‘‰,ğ¸), which allows edge insertions and edge deletions, the goal is to design a data structure that maintains an approximate minimum vertex cover while satisfying the capacity constraint of each vertex. That is, when picking a copy of a vertex v in the cover, the number of vâ€™s incident edges covered by the copy is up to a given capacity of v. We extend Bhattacharya et al.â€™s work [SODAâ€™15 and ICALPâ€™15] to obtain a deterministic primal-dual algorithm for maintaining a constant-factor approximate minimum capacitated vertex cover with ğ‘‚(logğ‘›/ğœ–) amortized update time, where n is the number of vertices in the graph. The algorithm can be extended to (1) a more general model in which each edge is associated with a non-uniform and unsplittable demand, and (2) the more general capacitated set cover problem.

Access provided by University of Auckland Library

Introduction
Dynamic algorithms have received fast-growing attention in the past decades, especially for some classical combinatorial optimization problems such as connectivity [1, 10, 13, 15], routing [2, 8, 21, 22], vertex cover and maximum matching [3,4,5,6, 16,17,18,19,20]. This paper focuses on the fully dynamic model for the vertex cover problem, which has been intensively studied in recent years. Given a vertex-weighted graph ğº=(ğ‘‰,ğ¸), here we called the weight on each vertex as cost to avoid abusing this term in the following section. Such a graph is constantly updated due to a sequence of edge insertions and edge deletions, where the objective is to maintain a subset of vertices ğ‘†âŠ†ğ‘‰ at any given time, such that every edge is incident to at least one vertex in S and the total cost of S is minimized. We consider a generalization of the problem, where each vertex is associated with a given capacity. When picking a copy of a vertex v in the multiset S, the number of its incident edges that can be covered by such a copy is bounded by vâ€™s given capacity. The objective is to find a soft capacitated weighted vertex cover S with minimum cost, i.e. âˆ‘ğ‘£âˆˆğ‘†ğ‘ğ‘£ğ‘¥ğ‘£ is minimized, as well as an assignment of edges such that the number of edges assigned to a vertex v in S is at most ğ‘˜ğ‘£ğ‘¥ğ‘£, where ğ‘ğ‘£ is the cost of v, ğ‘˜ğ‘£ is the capacity of v, and ğ‘¥ğ‘£ is the number of selected copies of v in S. Assume there is no bound on ğ‘¥ğ‘£. The static model of this generalization is the so-called soft capacitated vertex cover problem, introduced by Guha et al. [11], whereas if each ğ‘¥ğ‘£ is associated with a bound, it is called the hard capacitated vertex cover problem, introduced by Chuzhoy and Naor [9].

Prior work For the vertex cover problem in a dynamic setting, Ivkovic and Lloyd [14] presented the pioneering work wherein their fully dynamic algorithm maintains a 2-approximation factor to vertex cover with ğ‘‚((ğ‘›+ğ‘š)0.7072) update time, where n is the number of vertices and m is the number of edges. Onak and Rubinfeld [17] designed a randomized data structure that maintains a large constant approximation ratio with ğ‘‚(log2ğ‘›) amortized update time in expectation; this is the first result that achieves a constant approximation factor with polylogarithmic update time. Baswana et al. [3] designed another randomized data structure which improves the approximation ratio to two, and simultaneously improved the amortized update time to ğ‘‚(logğ‘›). Recently, Solomon [20] gave the currently best randomized algorithm, which maintains a 2-approximate vertex cover with O(1) amortized update time.

For deterministic data structures, Onak and Rubinfeld [17] presented a data structure that maintains an ğ‘‚(logğ‘›)-approximation algorithm with ğ‘‚(log2ğ‘›) amortized update time. Bhattacharya et al. [6] proposed the first deterministic data structure that maintains a constant ratio, precisely, a (2+ğœ–)-approximation to vertex cover with polylogarithmic ğ‘‚(logğ‘›/ğœ–2) amortized updated time. Existing work also considered the worst-case update time. Neiman and Solomon [16] provided a 2-approximation dynamic algorithm with ğ‘‚(ğ‘šâ€¾â€¾âˆš) worst-case update time. Peleg and Solomon [18] improved the worst-case update time to ğ‘‚(ğ›¾/ğœ–2), where ğ›¾ is the arboricity of the input graph. Very recently, Bhattacharya et al. [4] extended their hierarchical data structure to achieve the currently best worst-case update time of ğ‘‚(ğ‘ğ‘œğ‘™ğ‘¦(1/ğœ–)â‹…log3ğ‘›)Footnote1. Note that the above studies only discussed the unweighted vertex cover problem, the objective of which is to find a vertex cover with minimum cardinality.

Consider the dynamic (weighted) set cover problem. In the statics setting, given a universe U of n elements and a family F of m sets. Each set is associated with non-negative costs. The objective is to find a subfamily of sets ğ‘†âˆˆğ¹ of minimum cost that covers U. The dynamic set cover problem follows a sequence of element insertions and deletions, the objective is to maintain a subfamily of sets ğ‘†âˆˆğ¹ at any given time, such that the union of S covers the elements that we seen so far.

Bhattacharya et al. [7] used a hierarchical data structure similar to that reported in [6], and and presented an algorithm with ğ‘‚(ğ‘“2)-approximation ratio and ğ‘‚(ğ‘“log(ğ‘›+ğ‘š)) amortized updated time, where f is the maximum frequency of an element. Very recently, Gupta et al. [12] improved the amortized update time to ğ‘‚(ğ‘“2), albeit the dynamic algorithm achieves a higher approximation ratio of ğ‘‚(ğ‘“3). They also offered another ğ‘‚(logğ‘›)-approximation dynamic algorithm in ğ‘‚(ğ‘“logğ‘›) amortized update time. Bhattacharya et al. [5] simultaneously derived the same outcome with ğ‘‚(ğ‘“3)-approximation ratio and ğ‘‚(ğ‘“2) amortized update time for the unweighted set cover problem. Table 1 presents a summary of the above results.

Table 1 Summary of results for unweighted (resp. weighted) minimum vertex cover (UMVC (resp. WMVC)), unweighted (resp. weighted) minimum set cover (UMSC (resp. WMSC)), where f is the maximum frequency of an element, and weighted minimum capacitated vertex (resp. set) cover (WMCVC (resp. WMCSC))
Full size table
Our Contribution In this study we investigate the soft capacitated vertex cover problem in the dynamic setting, where there is no bound on the number of copies of each vertex that can be selected. We refer to the primal-dual technique reported in [11], and present the first deterministic algorithm for this problem, which can maintain an O(1)-approximate minimum capacitated (weighted) vertex cover with ğ‘‚(logğ‘›/ğœ–) amortized update time. The algorithm can be extended to a more general model in which each edge is associated with a given demand, and the demand has to be assigned to an incident vertex. That is, the demand of each edge is non-uniform and unsplittable. Also, it can be extended to solve the more general capacitated set cover problem, where the input graph is a hyper-graph, and each edge may connect to multiple vertices.

The proposed dynamic mechanism builds on Bhattacharya et al.â€™s (ğ›¼,ğ›½)-partition structure [6, 7], but a careful adaptation has to be made to cope with the newly introduced capacity constraint. In dynamic vertex cover [6], the authors considered dynamically maintaining the dual problem of the relaxed vertex cover, that is, the fractional matching problem. They partitioned all of the vertices into different levels and designed a weight function for the fractional matching problem.

Briefly, applying the fractional matching technique in Bhattacharya et al.â€™s algorithm cannot directly lead to a constant approximation ratio in the capacitated vertex cover problem. The crux of our result is the re-design of a key parameter, weight function of a vertex, in the dual model. Details are shown in the next section.

Overview of Our Technique
First, we recall the mathematical model of the capacitated vertex cover problem which was first introduced by Guha et al. [11]. In this model, ğ‘¦ğ‘’ğ‘£ serves as a binary variable that indicates whether an edge e is covered by a vertex v. Let ğ‘ğ‘£ be the set of incident edges of v, ğ‘˜ğ‘£ and ğ‘ğ‘£ be the capacity and the cost of a vertex v, respectively. Let ğ‘¥ğ‘£ be the number of selected copies of a vertex v. An integer program (IP) model of the problem can be formulated as follows (the minimization program on the left):

figure a
If we allow a relaxation of the above primal form, i.e., dropping the integrality constraints, its dual problem yields a maximization problem. The linear program for the dual can be formulated as shown in the above (the maximization program on the right; also see [11]). One may consider this as a variant of the packing problem, where we want to pack a value of ğœ‹ğ‘’ for each edge e, so that the sum of the packed values is maximized. Packing of e is limited by the sum of ğ‘ğ‘£ and ğ‘™ğ‘’ğ‘£, where ğ‘ğ‘£ is the global ability of a vertex v emitted to vâ€™s incident edges, and ğ‘™ğ‘’ğ‘£ is the local ability of v distributed to its incident edge e.

In this study, we incorporate the above IP model with its LP relaxation for capacitated vertex cover into the dynamic mechanism proposed Bhattacharya et al.â€™s [6, 7]. They devised the weight function of a vertex (in the dual model). Based on the weight function, we can select a subset of vertices that obtains a feasible vertex cover. They also allowed a flexible range for weight function to quickly adjust the solution for dynamic updates while preserving its approximation quality. Due to the additional capacity constraint in our problem, a new weight function is obviously required.

Technical Challenges There are two major differences between our algorithm and Bhattacharya et al.â€™s [6, 7]. First, the capacity constraint in the primal problem leads to the two variables ğ‘ğ‘£ and ğ‘™ğ‘’ğ‘£ in the dual problem in which we have to balance their values when approaching ğ‘ğ‘£ to maximize the dual objective. By contrast, the previous work considered one dual variable ğ‘™ğ‘’ğ‘£ without the restriction on the coverage of a vertex. We thus re-design weight function of a vertex to specifically consider the capacitated scenario. Yet, even with the new definition of weight function, there is still a second challenge on how to approximate the solution within a constant factor in the dynamic environment. In order to achieve polylogarithmic amortized update time, Bhattacharya et al.â€™s fractional matching approach assigns the value of all vâ€™s incident edges to v, which, however, may result in a non-constant h, hidden in the approximation ratio, where h is the largest number of copies selected in the cover. We observe that we cannot remove h from the approximation guarantee based on the (ğ›¼,ğ›½)-partition structure if we just select the minimum value of ğ›¼, as it is done in (Bhattacharya et al. [6, 7]). The key insight is that we show a bound on the value of ğ›¼, which restricts the updates of the dynamic mechanism. With the help of this insight, we are able to revise the setting of ğ›¼ to derive a constant approximation ratio, while maintaining the ğ‘‚(logğ‘›/ğœ–) update time.

Level Scheme and Its Key Property
The core of Bhattacharya et al.â€™s (ğ›¼,ğ›½)-partition structure [6, 7]) is a level scheme [17] that is used to maintain a feasible solution in their dual problem. In this section, we demonstrate (in a different way from the original papers) how this scheme can be applied to our dual problem, and describe the key property that the scheme guarantees.

A level scheme is an assignment â„“:ğ‘‰â†’{0,1,â€¦,ğ¿} such that every vertex ğ‘£âˆˆğ‘‰ has a level â„“(ğ‘£). Let ğ‘min and ğ‘max denote the minimum and maximum costs of a vertex, respectively. For our case, we set ğ¿=âŒˆlogğ›½(ğ‘›ğœ‡ğ›¼/ğ‘min)âŒ‰ for some ğ›¼,ğ›½>1 and ğœ‡>ğ‘max. Based on â„“, each edge (u, v) is also associated with a level â„“(ğ‘¢,ğ‘£), where â„“(ğ‘¢,ğ‘£)=max{â„“(ğ‘¢),â„“(ğ‘£)}. An edge is assigned to the higher-level endpoint, and ties are broken arbitrarily if both endpoints have the same level. Conceptually, based on the level status of the vertices, the level scheme transforms an undirected graph into a directed structure. Each edge (u, v) has a weight w(u, v) according to its level, such that ğ‘¤(ğ‘¢,ğ‘£)=ğœ‡ğ›½âˆ’â„“(ğ‘¢,ğ‘£). Each vertex v also has a weight ğ‘Šğ‘£, which is defined based on the incident edges of v and their corresponding levels. Before giving details on ğ‘Šğ‘£, we first define some notations. Let ğ‘ğ‘£={ğ‘¢âˆ£(ğ‘¢,ğ‘£)âˆˆğ¸} be the set of vertices adjacent to v (i.e., the neighbors of v). Let ğ‘ğ‘£(ğ‘–) denote the set of level-i neighbors of v, and ğ‘ğ‘£(ğ‘–,ğ‘—) denote the set of vâ€™s neighbors whose levels are in the range [i, j]. That is, ğ‘ğ‘£(ğ‘–)={ğ‘¢âˆ£(ğ‘¢,ğ‘£)âˆˆğ¸âˆ§â„“(ğ‘¢)=ğ‘–} and ğ‘ğ‘£(ğ‘–,ğ‘—)={ğ‘¢âˆ£(ğ‘¢,ğ‘£)âˆˆğ¸âˆ§â„“(ğ‘¢)âˆˆ[ğ‘–,ğ‘—]}. The degree of a vertex v is denoted by ğ·ğ‘£=|ğ‘ğ‘£|. Similarly, we define ğ·ğ‘£(ğ‘–)=|ğ‘ğ‘£(ğ‘–)| and ğ·ğ‘£(ğ‘–,ğ‘—)=|ğ‘ğ‘£(ğ‘–,ğ‘—)|. Finally, we use ğ›¿(ğ‘£) to denote the set of edges assigned to a vertex v. Now, the weight ğ‘Šğ‘£ of a vertex v is defined as follows:

Case 1 ğ·ğ‘£(0,â„“(ğ‘£))>ğ‘˜ğ‘£:

ğ‘Šğ‘£=ğ‘˜ğ‘£ğœ‡ğ›½âˆ’â„“(ğ‘£)+âˆ‘ğ‘–>â„“(ğ‘£)min{ğ‘˜ğ‘£,ğ·ğ‘£(ğ‘–)}ğœ‡ğ›½âˆ’ğ‘–
Case 2 ğ·ğ‘£(0,â„“(ğ‘£))â‰¤ğ‘˜ğ‘£:

ğ‘Šğ‘£=ğ·ğ‘£(0,â„“(ğ‘£))ğœ‡ğ›½âˆ’â„“(ğ‘£)+âˆ‘ğ‘–>â„“(ğ‘£)min{ğ‘˜ğ‘£,ğ·ğ‘£(ğ‘–)}ğœ‡ğ›½âˆ’ğ‘–
The intuition behind this weight function refers to the primal-dual algorithm proposed by Guha et al. [11], where by the capacity constraint, in each iteration, a vertex can increase its dual value by at most ğ‘˜ğ‘£ edges, no matter how many incident edges it has. By a similar idea, we consider whether the number of level-i neighbors of v, 0â‰¤ğ‘–â‰¤ â„“(ğ‘£), is larger than the capacity of v, and use it to define the weight of a vertex v. Note that the total weight of the edges that are assigned to v or incident to v can contribute at most ğ‘˜ğ‘£ğ‘¤(ğ‘¢,ğ‘£) to ğ‘Šğ‘£, which is different from the [6, 7]. (In Bhattacharya et al. [6, 7], since they do not need to consider the capacity constraint, the weight of a vertex is simply the sum of the weights of all its incident edges; that is, ğ‘Šğ‘£=âˆ‘ğ‘¢âˆˆğ‘(ğ‘£)ğ‘¤(ğ‘¢,ğ‘£).) Moreover, our proposed weight function provides a relationship between the weights of different levels, which plays an essential role when we consider the dynamic setting. Briefly, the weight of a vertex has two components: one that is dependent on the incident edges with level â„“(ğ‘£), and the other that is dependent on the remaining incident edges. For convenience, we call the former component ğ¼ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘›ğ‘ğ‘™ğ‘£ and the latter component as ğ¸ğ‘¥ğ‘¡ğ‘’ğ‘Ÿğ‘›ğ‘ğ‘™ğ‘£. Moreover, we have:

ğ¸ğ‘¥ğ‘¡ğ‘’ğ‘Ÿğ‘›ğ‘ğ‘™ğ‘£â‰¤ğ‘˜ğ‘£âˆ‘ğ‘–>â„“(ğ‘£)ğœ‡ğ›½âˆ’ğ‘–  â‰¤  (1/(ğ›½âˆ’1))ğ‘˜ğ‘£ğœ‡ğ›½âˆ’â„“(ğ‘£).
In general, an arbitrary level scheme cannot be used to solve our problem. What we need is a valid level scheme, which is defined as follows.

Definition 1
A level scheme is valid if ğ‘Šğ‘£â‰¤ğ‘ğ‘£, for every vertex v.

Lemma 1
Let ğ‘‰0 denote the set of level-0 vertices in a valid level scheme. Then, ğ‘‰âˆ–ğ‘‰0 forms a vertex cover of G.

Proof
Consider any edge (ğ‘¢,ğ‘£)âˆˆğ¸. We claim that at least one of its endpoints must be in ğ‘‰âˆ–ğ‘‰0. Suppose that the claim is false which implies that â„“(ğ‘¢)=â„“(ğ‘£)=0 and ğ‘¤(ğ‘¢,ğ‘£)=ğœ‡>ğ‘max. Since w(u, v) appears in ğ¼ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘›ğ‘ğ‘™ğ‘£, we have ğ‘Šğ‘£â‰¥ğ‘¤(ğ‘¢,ğ‘£). As a result, ğ‘ğ‘£â‰¥ğ‘Šğ‘£â‰¥ğœ‡>ğ‘max, which leads to a contradiction. The claim thus follows, and so does the lemma.

â—»

The above lemma implies that no edge is assigned to any level-0 vertex. In our mechanism, we will maintain a valid level scheme, based on which each vertex in ğ‘‰âˆ–ğ‘‰0 picks enough copies to cover all the edges assigned to it; this forms a valid capacitated vertex cover.

Next, we define the notion of tightness, which is used to measure how good a valid level scheme performs.

Definition 2
A valid level scheme with an associated edge assignment is ğœ€-tight if for every vertex v with |ğ›¿(ğ‘£)|>0, ğ‘Šğ‘£âˆˆ(ğ‘ğ‘£/ğœ€,ğ‘ğ‘£].

Lemma 2
Given an ğœ€-tight valid level scheme, we can obtain an ğœ€(2(ğ›½/(ğ›½âˆ’1))+1)-approximate solution to the weighted minimum capacitated vertex cover (WMCVC) problem.

Proof
First, we fix an arbitrary edge assignment that is consistent with the given valid level scheme. For each vertex v with |ğ›¿(ğ‘£)|>0, we pick âŒˆ|ğ›¿(ğ‘£)|/ğ‘˜ğ‘£âŒ‰ copies to cover all the |ğ›¿(ğ‘£)| edges assigned to it. To analyze the total cost of this capacitated vertex cover, we relate it to the value âˆ‘ğ‘’ğœ‹ğ‘’ of a certain feasible solution of the dual problem, whose corresponding values of ğ‘ğ‘£ and ğ‘™ğ‘’ğ‘£ are as follows:

For every vertex v:

âˆ™ if âŒˆ|ğ›¿(ğ‘£)|/ğ‘˜ğ‘£âŒ‰>1: ğ‘ğ‘£=ğœ‡ğ›½âˆ’â„“(ğ‘£), and ğ‘™ğ‘’ğ‘£=0;

âˆ™ if âŒˆ|ğ›¿(ğ‘£)|/ğ‘˜ğ‘£âŒ‰â‰¤1: ğ‘ğ‘£=ğœ‡âˆ‘ğ‘–âˆ£ğ·ğ‘£(ğ‘–)>ğ‘˜ğ‘£ğ›½âˆ’ğ‘–,

ğ‘™ğ‘’ğ‘£=0 if ğ·ğ‘£(â„“(ğ‘’))>ğ‘˜ğ‘£, and ğ‘™ğ‘’ğ‘£=ğœ‡ğ›½âˆ’â„“(ğ‘’) otherwise.

For every edge e: ğœ‹ğ‘’=ğœ‡ğ›½âˆ’â„“(ğ‘’).

It is easy to verify that the above choices of ğ‘ğ‘£, ğ‘™ğ‘’ğ‘£, and ğœ‹ğ‘’ give a feasible solution to the dual problem.

For the total cost of our solution, we separate the analysis into two parts, based on the multiplicity of the vertex:

Case 1 âŒˆ|ğ›¿(ğ‘£)|/ğ‘˜ğ‘£âŒ‰>1: In this case, the external component of ğ‘Šğ‘£ is at most 1/(ğ›½âˆ’1) of the internal component, so ğ‘Šğ‘£â‰¤(ğ›½/(ğ›½âˆ’1))ğ‘˜ğ‘£ğ‘ğ‘£. Then, the cost of all copies of v is:

âŒˆ|ğ›¿(ğ‘£)|/ğ‘˜ğ‘£âŒ‰â‹…ğ‘ğ‘£â‰¤âŒˆ|ğ›¿(ğ‘£)|/ğ‘˜ğ‘£âŒ‰â‹…ğœ€â‹…ğ‘Šğ‘£â‰¤2â‹…|ğ›¿(ğ‘£)|ğ‘˜ğ‘£â‹…ğœ€â‹…(ğ›½/(ğ›½âˆ’1))ğ‘˜ğ‘£ğ‘ğ‘£ = 2ğœ€(ğ›½/(ğ›½âˆ’1))â‹…âˆ‘ğ‘’âˆˆğ›¿(ğ‘£)ğœ‹ğ‘’.
Case 2 âŒˆ|ğ›¿(ğ‘£)|/ğ‘˜ğ‘£âŒ‰ =1: In this case, we pick one copy of vertex v, whose cost is:

ğ‘ğ‘£â‰¤ğœ€â‹…ğ‘Šğ‘£ â‰¤ğœ€â‹…âˆ‘ğ‘’âˆ¼ğ‘£ğœ‹ğ‘’ = ğœ€â‹…(âˆ‘ğ‘’âˆˆğ›¿(ğ‘£)ğœ‹ğ‘’+âˆ‘ğ‘’âˆ‰ğ›¿(ğ‘£),ğ‘’âˆ¼ğ‘£ğœ‹ğ‘’),
where ğ‘’âˆ¼ğ‘£ denotes e is an edge incident to v.

In summary, the total cost is bounded by

âˆ‘ğ‘£(max{ğœ€,2ğœ€(ğ›½/(ğ›½âˆ’1))}âˆ‘ğ‘’âˆˆğ›¿(ğ‘£)ğœ‹ğ‘’+ğœ€âˆ‘ğ‘’âˆ‰ğ›¿(ğ‘£),ğ‘’âˆ¼ğ‘£ğœ‹ğ‘’)=âˆ‘ğ‘£(2ğœ€(ğ›½/(ğ›½âˆ’1))âˆ‘ğ‘’âˆˆğ›¿(ğ‘£)ğœ‹ğ‘’+ğœ€âˆ‘ğ‘’âˆ‰ğ›¿(ğ‘£),ğ‘’âˆ¼ğ‘£ğœ‹ğ‘’)=ğœ€(2(ğ›½/(ğ›½âˆ’1))+1)âˆ‘ğ‘’ğœ‹ğ‘’â‰¤ğœ€(2(ğ›½/(ğ›½âˆ’1))+1)â‹…ğ‘‚ğ‘ƒğ‘‡,
where OPT denotes the optimal solution of the dual problem, which is also a lower bound of the cost of any weighted capacitated vertex cover. â—»

The next section discusses how to dynamically maintain an ğœ€-tight level scheme, for some constant factor ğœ€ and with amortized ğ‘‚(logğ‘›/ğœ–) update time. Before that, we show a greedy approach to get a (ğ›½+1)-tight level scheme to the static problem as a warm up.

First, we have the following definition.

Definition 3
A valid level scheme ğœ† is improvable if some vertex can drop its level to get another level scheme ğœ†â€² such that ğœ†â€² is valid; otherwise, we say ğœ† is non-improvable.

Lemma 3
If a valid level scheme ğœ† is non-improvable, then ğœ† is (ğ›½+1)-tight.

Proof
To prove this lemma, we compare the weight ğ‘Šğ‘£ of a vertex v when its level is set to i and ğ‘–+1, respectively (while the level of every other vertex remains unchanged).

Case 1 ğ·ğ‘£(0,ğ‘–)<ğ‘˜ğ‘£ and ğ·ğ‘£(0,ğ‘–+1)<ğ‘˜ğ‘£:

ğ‘Šğ‘£(ğ‘–+1)ğ‘Šğ‘£(ğ‘–)=ğ·ğ‘£(0,ğ‘–+1)ğœ‡ğ›½âˆ’(ğ‘–+1)+âˆ‘ğ‘—>ğ‘–+1min{ğ‘˜ğ‘£,ğ·ğ‘£(ğ‘—)}ğœ‡ğ›½âˆ’ğ‘—;=ğ·ğ‘£(0,ğ‘–)ğœ‡ğ›½âˆ’(ğ‘–)+ğ·ğ‘£(ğ‘–+1)ğœ‡ğ›½âˆ’(ğ‘–+1)+âˆ‘ğ‘—>ğ‘–+1min{ğ‘˜ğ‘£,ğ·ğ‘£(ğ‘—)}ğœ‡ğ›½âˆ’ğ‘—â‰¤ğ›½ğ‘Šğ‘£(ğ‘–+1);
Case 2 ğ·ğ‘£(0,ğ‘–+1)â‰¥ğ‘˜ğ‘£:

ğ‘Šğ‘£(ğ‘–+1)ğ‘Šğ‘£(ğ‘–)=ğ‘˜ğ‘£ğœ‡ğ›½âˆ’(ğ‘–+1)+âˆ‘ğ‘—>ğ‘–+1min{ğ‘˜ğ‘£,ğ·ğ‘£(ğ‘—)}ğœ‡ğ›½âˆ’ğ‘—;=min{ğ·ğ‘£(0,ğ‘–),ğ‘˜ğ‘£}ğœ‡ğ›½âˆ’(ğ‘–)+min{ğ‘˜ğ‘£,ğ·ğ‘£(ğ‘–+1)}ğœ‡ğ›½âˆ’(ğ‘–+1)+âˆ‘ğ‘—>ğ‘–+1min{ğ‘˜ğ‘£,ğ·ğ‘£(ğ‘—)}ğœ‡ğ›½âˆ’ğ‘—â‰¤(ğ›½+1)ğ‘Šğ‘£(ğ‘–+1);
In both cases, the weight ğ‘Šğ‘£(ğ‘–) is at most (ğ›½+1) times of ğ‘Šğ‘£(ğ‘–+1). Thus, if a vertex cannot drop its level, either its current level is 0, or by doing so we have ğ‘Šğ‘£(â„“(ğ‘£)âˆ’1)>ğ‘ğ‘£; the latter implies that the current value of ğ‘Šğ‘£=ğ‘Šğ‘£(â„“(ğ‘£)) is larger than ğ‘ğ‘£/(ğ›½+1). Thus, if no vertex can drop its level, then the level scheme is (ğ›½+1)-tight. â—»

If we set the level of every vertex to L initially, it is easy to check that by our choice of L as âŒˆlogğ›½(ğ‘›ğœ‡ğ›¼/ğ‘min)âŒ‰, such a level scheme is valid. Next, we examine each vertex one by one, and drop its level as much as possible while the scheme remains valid. In the end, we will obtain a non-improvable scheme, so that by the above lemma, the scheme is (ğ›½+1)-tight. This implies a (ğ›½+1)(2(ğ›½/(ğ›½âˆ’1))+1)-approximate solution for the WMCVC problem.

Maintaining an ğ›¼(ğ›½+1)-tight Level Scheme Dynamically
Fig. 1
figure 1
Framework of Sect. 3

Full size image
In this section, we present our O(1)-approximation algorithm for the WMCVC problem, with amortized ğ‘‚(logğ‘›) update time for each edge insertion and edge deletion. We first state an invariant that is maintained throughout by our algorithm, and show how the latter is done. Next, we analyze the time required to maintain the invariant with the potential method, and show that our proposed method can be updated efficiently as desired. Similar to [6, 7], we allow a flexible range for the weight of a vertex, ğ‘Šğ‘£, by a multiplicative constant ğ›¼ so that we can obtain an ğ‘‚(logğ‘›) amortized update time. See Fig. 1 for an illustration of the overall framework.

Let ğ‘âˆ—ğ‘£ be ğ‘ğ‘£/ğ›¼(ğ›½+1). The invariant that we maintain is as follows.

Invariant 1
(1) For every vertex ğ‘£âˆˆğ‘‰âˆ–ğ‘‰0, it holds that ğ‘âˆ—ğ‘£â‰¤ğ‘Šğ‘£â‰¤ğ‘ğ‘£, and (2) for every vertex ğ‘£âˆˆğ‘‰0, it holds that ğ‘Šğ‘£â‰¤ğ‘ğ‘£ .

By maintaining the above invariant, we will automatically obtain an ğ›¼(ğ›½+1)-tight valid scheme. As mentioned, we will choose a value for ğ›¼ in order to remove h from the approximation ratio, where h is the largest number of copies selected in the cover. In particular, we will set ğ›¼=(2ğ›½+1)/ğ›½+2ğœ–, where 0<ğœ–<1 to balance the update time, and ğ›½=2.43 to minimize the approximation ratio, so that we achieve the following theorem.

Theorem 2
There exists a dynamic level scheme ğœ† which can achieve a constant approximation ratio (â‰ˆ36) for the WMCVC problem with ğ‘‚(logğ‘›/ğœ–) amortized update time.

The remainder of this section is devoted to proving Theorem 2.

The Algorithm: Handling Insertion or Deletion of an Edge
We now show how to maintain the invariant under edge insertions and deletions. A vertex is called dirty if it violates Invariant 1, and clean otherwise. Initially, the graph is empty, so that every vertex is clean and is at level zero.

Assume that at the time instant just prior to the ğ‘¡ğ‘¡â„ update, all vertices are clean. When the ğ‘¡ğ‘¡â„ update takes place, which either inserts or deletes an edge ğ‘’=(ğ‘¢,ğ‘£), we need to adjust the weights of u and v accordingly. Due to this adjustment, the vertices u, or v, or both may become dirty. To recover from this, we call the procedure FIX. The pseudo code of the update algorithm (Algorithm 1) appears in the next page.

figure b
figure c
The proposed algorithm ensures that Invariant 1 is maintained after each update, so that the dynamic scheme is ğ›¼(ğ›½+1)-tight as desired. To complete the discussion, as well as the proof of Theorem 2, it remains to show that each update can be performed efficiently, in amortized ğ‘‚(logğ‘›) time.

Time Complexity
Each update involves two steps, namely the adjustment of weights of the endpoints, and the running of procedure FIX. We now give the time complexity analysis, where the main idea is to prove the following two facts: (Fact 1) the amortized time of the adjustment step is ğ‘‚(logğ‘›), and (Fact 2) the amortized time of the procedure FIX is zero, irrespective of the number of vertices or edges that are affected during this step. Once the above two facts are proven, the time complexity analysis follows.

We use the standard potential method in our amortized analysis. Imagine that we have a bank account B. Initially, the graph is empty, and the bank account B has no potential. For each adjustment step during an edge insertion or deletion, we deposit some potential into the bank account B; after that, we use the potential in B to pay for the time of the procedure FIX.

Following the definition of [7], we say a vertex ğ‘£âˆˆğ‘‰ is active if its degree in G is non-zero, and passive otherwise. Now, the value of B is set by the following formula:

ğµ = 1ğœ–â‹…(âˆ‘ğ‘’âˆˆğ¸ğœ™(ğ‘’)+âˆ‘ğ‘£âˆˆğ‘‰ğœ“(ğ‘£)),
where 0<ğœ–<1, and ğœ™ and ğœ“ are functions defined as follows:

figure d
The following lemma proves Fact 1.

Lemma 4
After the adjustment step, the potential B increases by at most ğ‘‚(logğ‘›/ğœ–).

Proof
We separate the discussion into two cases: edge insertion and edge deletion. Let t be the moment where the update occurs.

Edge Insertion The inserted edge e generates a change of at most (ğ›½(ğ›½âˆ’1)+ğœ–)ğ¿ in ğœ™(ğ‘’). So, the summation âˆ‘ğœ™(ğ‘’) increases by at most ğ‘‚(logğ‘›). For each endpoint v of e, there are two possible cases for the change in ğœ“(ğ‘£):

Case 1 The vertex v was passive at moment ğ‘¡âˆ’1. By the definition of ğœ“(ğ‘£), we had ğœ“(ğ‘£)=0 and â„“(ğ‘£)=0 before the insertion of the edge e. Hence, after the insertion of e, we have

ğœ“(ğ‘£) = ğ›½ğœ‡(ğ›½âˆ’1)â‹…max{0,ğ›¼ğ‘âˆ—ğ‘£âˆ’ğ‘Šğ‘£} â‰¤ ğ›½ğœ‡(ğ›½âˆ’1)â‹…ğ›¼ğ‘âˆ—ğ‘£â‰¤ ğ›½ğœ‡(ğ›½âˆ’1)â‹…ğ‘ğ‘£ < ğ›½ğ›½âˆ’1.
Therefore, the summation âˆ‘ğœ“(ğ‘£) increases by at most O(1).

Case 2 The vertex v was active at moment ğ‘¡âˆ’1. In this case, the vertex v remains active at moment t. Thus, the weight ğ‘Šğ‘£ increases, and ğœ“(ğ‘£) can only decrease.

In both cases, the total potential B increases by at most ğ‘‚(logğ‘›/ğœ–) after an edge insertion.

Edge Deletion If an edge e is deleted from E, then ğœ™(ğ‘’) drops to zero, so that the summation âˆ‘ğœ™(ğ‘’) decreases. In contrast, the weight ğ‘Šğ‘£ of each endpoint v of e decreases by at most ğœ‡ğ›½âˆ’â„“(ğ‘£). So, ğœ“(ğ‘£) increases by at most

ğ›½(â„“(ğ‘£)+1)ğœ‡(ğ›½âˆ’1) â‹… ğœ‡ğ›½âˆ’â„“(ğ‘£)=ğ›½ğ›½âˆ’1,
which is a constant. Thus, the summation âˆ‘ğœ“(ğ‘£) increases by at most O(1). In summary, the total potential B increases by at most ğ‘‚(1/ğœ–) after an edge deletion.

By the above arguments, the lemma follows. â—»

We now switch our attention to Fact 2. Observe that the procedure FIX performs a series of level up and level down events. For each such event, the level of a specific vertex v will be changed, which will then incur a change in its weight, and changes in the weights of some of the incident edges and their endpoints. The illustration and corresponding lemmas can refer to Fig. 1 first. Let ğ‘¡0 denote the moment before a level up or a level down event, and ğ‘¡1 denote the moment after the weights of the edges and vertices are updated due to this event. Let COUNT denote the number of times an edge in the graph G is updated (for simplicity, we assume that in one edge update, the weight and the assignment of the edge may be updated, and so do the weights of its endpoints, where all these can be done in O(1) time).

For ease of notation, in the following, a superscript t in a variable denotes the variable at moment t. For instance, ğ‘Šğ‘¡0ğ‘£ stands for the weight ğ‘Šğ‘£ of v at moment ğ‘¡0. Also, we use Î”ğ‘¥ to denote the quantity ğ‘¥ğ‘¡0âˆ’ğ‘¥ğ‘¡1, so that

|Î”COUNT|=|COUNTğ‘¡0âˆ’COUNTğ‘¡1|=COUNTğ‘¡1âˆ’COUNTğ‘¡0
represents the number of incident edges whose weights are changed between ğ‘¡0 and ğ‘¡1.

Briefly speaking, based on the level scheme and the potential function B, we can show:

For each level up event, each of the affected edges e would have its ğœ™(ğ‘’) value dropped, so that an ğœ– fraction can pay for the weight updates of itself and its endpoints, while the remaining fraction can be converted into the increase in ğœ“(ğ‘£) value.

For each level down event, the reverse happens, where the vertex v would have its ğœ“(ğ‘£) value dropped, so that an ğœ– fraction can pay for the weight updates of the affected edges and their endpoints, while the remaining fraction can be converted into the increase in ğœ™(ğ‘’) values of the affected edges. The ğ›¼ value controls the frequency of the level down events, while trading this off with the approximation guarantee.

Sections 3.2.1 and 3.2.2 present the details of the amortized analysis of these two types of events, respectively. Finally, note that there is no potential input to the bank B after the adjustment step, so that the analysis implies that the procedure FIX must stop (as the potential in the bank is finite).

Amortized Time of Level Up
Let v be the vertex that undergoes the level up event, and ğ‘–=â„“(ğ‘£) denote its level at moment ğ‘¡0. By our notation, Î”ğµ=ğµğ‘¡0âˆ’ğµğ‘¡1 denotes the potential drop in the bank B from moment ğ‘¡0 to moment ğ‘¡1. To show that the amortized time of a level up event is at most zero, it is equivalent to show that Î”ğµâ‰¥|Î”COUNT|.

Recall that after a level up event, only the value of ğœ“(ğ‘£), the values of ğœ™(ğ‘’) and ğœ“(ğ‘¢) for an edge (u, v) may be affected. In the following, we will examine carefully the changes in these values, and derive the desired bound for Î”ğµ. First, we have the following simple lemma.

Lemma 5
|Î”COUNT|â‰¤ğ·ğ‘¡0ğ‘£(0,ğ‘–).

Proof
When v changes from level i to ğ‘–+1, only those incident edges with levels i will be affected.

â—»

The next three lemmas examine, respectively, the changes Î”ğœ“(ğ‘£), Î”ğœ™(ğ‘’), and Î”ğœ“(ğ‘¢).

Lemma 6
Î”ğœ“(ğ‘£)=0.

Proof
Since v undergoes a level up event, we have ğ‘Šğ‘¡0ğ‘£>ğ‘ğ‘£>ğ›¼ğ‘âˆ—ğ‘£, so that

ğœ“ğ‘¡0(ğ‘£)=0.
Next, we look at ğœ“ğ‘¡1(ğ‘£). To begin with, we show a general relationship between ğ‘Šğ‘¡0ğ‘£ and ğ‘Šğ‘¡1ğ‘£, similar to that in the proof of Lemma 3. Let i denote the level â„“(ğ‘£) of v at moment ğ‘¡0.

Case 1 ğ·ğ‘¡0ğ‘£(0,ğ‘–)>ğ‘˜ğ‘£

ğ‘Šğ‘¡0ğ‘£ğ‘Šğ‘¡1ğ‘£=ğ‘Šğ‘£(ğ‘–)=ğ‘˜ğ‘£â‹…ğœ‡ğ›½âˆ’ğ‘–+min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(ğ‘–+1)}â‹…ğœ‡ğ›½âˆ’(ğ‘–+1)+âˆ‘ğ‘—>ğ‘–+1min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(ğ‘—)}ğœ‡ğ›½âˆ’ğ‘—=ğ‘Šğ‘£(ğ‘–+1)=ğ‘˜ğ‘£â‹…ğœ‡ğ›½âˆ’(ğ‘–+1)+âˆ‘ğ‘—>ğ‘–+1min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(ğ‘—)}ğœ‡ğ›½âˆ’ğ‘—â‰¥1ğ›½+1ğ‘Šğ‘¡0ğ‘£
Case 2 ğ·ğ‘¡0ğ‘£(0,ğ‘–)â‰¤ğ‘˜ğ‘£

ğ‘Šğ‘¡0ğ‘£ğ‘Šğ‘¡1ğ‘£=ğ‘Šğ‘£(ğ‘–)=ğ·ğ‘¡0ğ‘£(0,ğ‘–)â‹…ğœ‡ğ›½âˆ’ğ‘–+min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(ğ‘–+1)}â‹…ğœ‡ğ›½âˆ’(ğ‘–+1)+âˆ‘ğ‘—>ğ‘–+1min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(ğ‘—)}ğœ‡ğ›½âˆ’ğ‘—=ğ‘Šğ‘£(ğ‘–+1)=min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(0,ğ‘–+1)}â‹…ğœ‡ğ›½âˆ’(ğ‘–+1)+âˆ‘ğ‘—>ğ‘–+1min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(ğ‘—)}ğœ‡ğ›½âˆ’ğ‘—â‰¥1ğ›½+1ğ‘Šğ‘¡0ğ‘£
Thus, ğ‘Šğ‘¡1ğ‘£â‰¥ğ‘Šğ‘¡0ğ‘£/(ğ›½+1)>ğ‘ğ‘£/(ğ›½+1)=ğ›¼ğ‘âˆ—ğ‘£, which implies

ğœ“ğ‘¡1(ğ‘£)=0.
In summary, we have Î”ğœ“(ğ‘£)=0âˆ’0=0 as desired. â—»

Lemma 7
For every edge e incident to v,

figure e
Proof
As mentioned, only those edges that are at the level in the range [0, i] are affected, so that

Î”ğœ™(ğ‘¢,ğ‘£)=ğœ™ğ‘¡0(ğ‘¢,ğ‘£)âˆ’ğœ™ğ‘¡1(ğ‘¢,ğ‘£)=(ğ›½(ğ›½âˆ’1)+ğœ–)(ğ¿âˆ’ğ‘–)âˆ’(ğ›½(ğ›½âˆ’1)+ğœ–)(ğ¿âˆ’(ğ‘–+1))=(ğ›½(ğ›½âˆ’1)+ğœ–).
â—»

Lemma 8
For every vertex ğ‘¢âˆˆğ‘ğ‘¡0ğ‘£, Î”ğœ“(ğ‘¢)â‰¥âˆ’ğ›½/(ğ›½âˆ’1).

Proof
If â„“(ğ‘¢)âˆˆ[ğ‘–+1,ğ¿], then ğ‘¤ğ‘¡0(ğ‘¢,ğ‘£)=ğ‘¤ğ‘¡1(ğ‘¢,ğ‘£) and thus Î”ğ‘¤(ğ‘¢,ğ‘£)=0, which implies that Î”ğœ“(ğ‘¢)= 0. The potential ğœ“(ğ‘¢) changes only when the level of vertex u is in the range [0, i]. Without loss of generality, we assume â„“(ğ‘¢)=ğ‘– and prove the lemma by considering the relationship between ğ‘˜ğ‘¢, ğ·ğ‘¡0ğ‘¢(0,ğ‘–) and ğ·ğ‘¡0ğ‘¢(ğ‘–+1). For those vertices u with â„“(ğ‘¢)âˆˆ[0,ğ‘–âˆ’1], we replace the term ğ·ğ‘¡0ğ‘¢(0,ğ‘–) with ğ·ğ‘¡0ğ‘¢(ğ‘–) while maintaining the same result.

Case 1ğ·ğ‘¡0ğ‘¢(0,ğ‘–)>ğ‘˜ğ‘¢, ğ·ğ‘¡0ğ‘¢(ğ‘–+1)â‰¥ğ‘˜ğ‘¢

ğ‘Šğ‘¡0ğ‘¢ = ğ‘Šğ‘¡1ğ‘¢â‡’Î”ğœ“(ğ‘¢) = 0.
Case 2ğ·ğ‘¡0ğ‘¢(0,ğ‘–)>ğ‘˜ğ‘¢, ğ·ğ‘¡0ğ‘¢(ğ‘–+1)<ğ‘˜ğ‘¢

ğ‘Šğ‘¡1ğ‘¢Î”ğœ“(ğ‘¢) = ğ‘Šğ‘¡0ğ‘¢+ğœ‡ğ›½âˆ’(ğ‘–+1) = ğ›½(â„“(ğ‘¢)+1)ğœ‡(ğ›½âˆ’1)â‹…ğœ‡ğ›½âˆ’(ğ‘–+1) = 1ğ›½âˆ’1â‹…ğ›½â„“(ğ‘¢)âˆ’ğ‘– > 0.
Case 3ğ·ğ‘¡0ğ‘¢(0,ğ‘–)â‰¤ğ‘˜ğ‘¢, ğ·ğ‘¡0ğ‘¢(ğ‘–+1)<ğ‘˜ğ‘¢

ğ‘Šğ‘¡1ğ‘¢Î”ğœ“(ğ‘¢) = ğ‘Šğ‘¡0ğ‘¢âˆ’ğœ‡(ğ›½âˆ’ğ‘–âˆ’ğ›½âˆ’(ğ‘–+1)) = âˆ’ğ›½(â„“(ğ‘¢)+1)ğœ‡(ğ›½âˆ’1)â‹…ğœ‡(ğ›½âˆ’ğ‘–âˆ’ğ›½âˆ’(ğ‘–+1)) = âˆ’ğ›½(â„“(ğ‘¢)+1)ğ›½ğ‘–+1 â‰¥ âˆ’1.
Case 4ğ·ğ‘¡0ğ‘¢(0,ğ‘–)â‰¤ğ‘˜ğ‘¢, ğ·ğ‘¡0ğ‘¢(ğ‘–+1)â‰¥ğ‘˜ğ‘¢

ğ‘Šğ‘¡1ğ‘¢Î”ğœ“(ğ‘¢) =ğ‘Šğ‘¡0ğ‘¢âˆ’ğœ‡ğ›½âˆ’ğ‘– = âˆ’ğ›½(â„“(ğ‘¢)+1)ğœ‡(ğ›½âˆ’1)â‹…ğœ‡ğ›½âˆ’ğ‘– = âˆ’ğ›½ğ›½âˆ’1(ğ›½â„“(ğ‘¢)âˆ’ğ‘–) â‰¥ âˆ’ğ›½ğ›½âˆ’1.
â—»

Based on the above lemmas, we derive the following and finish the proof for the case of level up.

Î”ğµ = 1ğœ–â‹…â›ââœâœÎ”ğœ“(ğ‘£)+âˆ‘ğ‘’âˆˆğ¸Î”ğœ™(ğ‘’)+âˆ‘ğ‘¢âˆˆğ‘ğ‘¡0ğ‘£Î”ğœ“(ğ‘¢)ââ âŸâŸ â‰¥ 1ğœ–â‹…(0+(ğ›½(ğ›½âˆ’1)+ğœ–)ğ·ğ‘¡0ğ‘£(0,ğ‘–)âˆ’ğ›½ğ›½âˆ’1ğ·ğ‘¡0ğ‘£(0,ğ‘–)) = ğ·ğ‘¡0ğ‘£(0,ğ‘–)  â‰¥  |Î”COUNT|.
Amortized Time of Level Down
We now show that the amortized time of level down for a vertex v is at most zero. Similar to the case of level up, we examine Î”ğœ“(ğ‘£), Î”ğœ™(ğ‘’), and Î”ğœ“(ğ‘¢), and show that Î”ğµâ‰¥|Î”COUNT|.

Before starting the proof of the level down case, recall that we have mentioned the parameter h at the end of the introduction, where h is the largest number of selected copies of all the vertices. That is, â„=maxğ‘£{âŒˆ|ğ›¿ğ‘¡0(ğ‘£)|/ğ‘˜ğ‘£âŒ‰}. Also, we let â„â€²=maxğ‘£{âŒˆğ·ğ‘¡0ğ‘£(0,â„“(ğ‘£))/ğ‘˜ğ‘£âŒ‰}, where â„â€²â‰¥â„, and set ğœ‰â‰¥0 such that â„â€²=â„+ğœ‰.

Lemma 9
|Î”COUNT|â‰¤ğ·ğ‘¡0ğ‘£(0,ğ‘–)<â„â€²â‹…ğ›½ğ‘–ğ‘âˆ—ğ‘£ğœ‡.

Proof
When the vertex v moves from level i to ğ‘–âˆ’1, only those edges whose levels are at most i are affected. This shows the first part of the inequality. Also, because v undergoes level down, we have ğ‘Šğ‘¡0ğ‘£<ğ‘âˆ—ğ‘£. Then, for the latter inequality, we partition the proof into two cases:

Case 1    âŒˆ|ğ›¿ğ‘¡0(ğ‘£)|/ğ‘˜ğ‘£âŒ‰=1

ğ‘Šğ‘¡0ğ‘£=& ğ·ğ‘¡0ğ‘£(0,ğ‘–)â‹…ğœ‡ğ›½âˆ’ğ‘–+âˆ‘ğ‘—>ğ‘–min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(ğ‘—)}ğœ‡ğ›½âˆ’ğ‘—â‡’& ğ‘âˆ—ğ‘£ > ğ·ğ‘¡0ğ‘£(0,ğ‘–)â‹…ğœ‡ğ›½âˆ’ğ‘–â‡’& ğ·ğ‘¡0ğ‘£(0,ğ‘–) < ğ›½ğ‘–ğ‘âˆ—ğ‘£ğœ‡.
Case 2    âŒˆ|ğ›¿ğ‘¡0(ğ‘£)|/ğ‘˜ğ‘£âŒ‰>1

ğ‘Šğ‘¡0ğ‘£=& ğ‘˜ğ‘£â‹…ğœ‡ğ›½âˆ’ğ‘–+âˆ‘ğ‘—>ğ‘–min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(ğ‘—)}ğœ‡ğ›½âˆ’ğ‘—â‡’& ğ‘âˆ—ğ‘£>ğ‘˜ğ‘£â‹…ğœ‡ğ›½âˆ’ğ‘–â‡’& â„â€²ğ‘âˆ—ğ‘£>ğ·ğ‘¡0ğ‘£(0,ğ‘–)ğ‘˜ğ‘£â‹…ğ‘˜ğ‘£â‹…ğœ‡ğ›½âˆ’ğ‘–â‡’& ğ·ğ‘¡0ğ‘£(0,ğ‘–)<â„â€²â‹…ğ›½ğ‘–ğ‘âˆ—ğ‘£ğœ‡.
â—»

Now, we are ready to examine Î”ğœ“(ğ‘£), Î”ğœ™(ğ‘’), and Î”ğœ“(ğ‘¢), through the following lemmas.

Lemma 10
For every vertex ğ‘¢âˆˆğ‘ğ‘¡0ğ‘£, Î”ğœ“(ğ‘¢)â‰¥âˆ’1/(ğ›½âˆ’1).

Proof
If â„“(ğ‘¢)âˆˆ[ğ‘–,ğ¿], then ğ‘¤ğ‘¡0(ğ‘¢,ğ‘£)=ğ‘¤ğ‘¡1(ğ‘¢,ğ‘£) and Î”ğ‘¤(ğ‘¢,ğ‘£)=0, which implies Î”ğœ“(ğ‘¢)=0. The changes of potentials only occur at the vertex whose level is in the range [0,ğ‘–âˆ’1]. Without loss of generality, we assume â„“(ğ‘¢)=ğ‘–âˆ’1 and we consider the relationship between ğ‘˜ğ‘¢, ğ·ğ‘¡0ğ‘¢(0,ğ‘–âˆ’1) and ğ·ğ‘¡0ğ‘¢(ğ‘–). For those vertices u and â„“(ğ‘¢)âˆˆ[0,ğ‘–âˆ’2], we replace the term ğ·ğ‘¡0ğ‘¢(0,ğ‘–âˆ’1) with ğ·ğ‘¡0ğ‘¢(ğ‘–âˆ’1) while maintaining the same result.

Case 1 ğ·ğ‘¡0ğ‘¢(0,ğ‘–âˆ’1)â‰¥ğ‘˜ğ‘¢, ğ·ğ‘¡0ğ‘¢(ğ‘–)>ğ‘˜ğ‘¢

ğ‘Šğ‘¡0ğ‘¢ = ğ‘Šğ‘¡1ğ‘¢â‡’Î”ğœ“(ğ‘¢) = 0.
Case 2 ğ·ğ‘¡0ğ‘¢(0,ğ‘–âˆ’1)â‰¥ğ‘˜ğ‘¢, ğ·ğ‘¡0ğ‘¢(ğ‘–)â‰¤ğ‘˜ğ‘¢

ğ‘Šğ‘¡1ğ‘¢Î”ğœ“(ğ‘¢) = ğ‘Šğ‘¡0ğ‘¢âˆ’ğœ‡ğ›½âˆ’ğ‘– = âˆ’ğ›½(â„“(ğ‘¢)+1)ğœ‡(ğ›½âˆ’1)â‹…ğœ‡ğ›½âˆ’ğ‘– = âˆ’ğ›½ğ›½âˆ’1â‹…ğ›½â„“(ğ‘¢)âˆ’ğ‘–(âˆµâ„“(ğ‘¢)â‰¤ğ‘–âˆ’1) â‰¥ âˆ’1ğ›½âˆ’1.
Case 3ğ·ğ‘¡0ğ‘¢(0,ğ‘–âˆ’1)<ğ‘˜ğ‘¢, ğ·ğ‘¡0ğ‘¢(ğ‘–)>ğ‘˜ğ‘¢

â‡’& ğœ“ğ‘¡0(ğ‘¢) ğœ“ğ‘¡1(ğ‘¢)â‡’Î”ğœ“(ğ‘¢) > 0. ğ‘Šğ‘¡1ğ‘¢=ğ‘Šğ‘¡0ğ‘¢+ğœ‡ğ›½âˆ’(ğ‘–âˆ’1)
Case 4ğ·ğ‘¡0ğ‘¢(0,ğ‘–âˆ’1)<ğ‘˜ğ‘¢, ğ·ğ‘¡0ğ‘¢(ğ‘–)â‰¤ğ‘˜ğ‘¢

â‡’& ğœ“ğ‘¡0(ğ‘¢) ğœ“ğ‘¡1(ğ‘¢)â‡’Î”ğœ“(ğ‘¢) > 0.ğ‘Šğ‘¡1ğ‘¢=ğ‘Šğ‘¡0ğ‘¢+ğœ‡(ğ›½âˆ’(ğ‘–âˆ’1)âˆ’ğ›½âˆ’ğ‘–)
â—»

Next, we partition ğ‘ğ‘¡0ğ‘£ into three subsets: X, ğ‘Œ1 and ğ‘Œ2, i.e. ğ‘ğ‘¡0ğ‘£=ğ‘‹âˆªğ‘Œ1âˆªğ‘Œ2, where

ğ‘‹ğ‘Œ1ğ‘Œ2={ğ‘¢âˆ£ğ‘¢âˆˆğ‘ğ‘¡0ğ‘£(0,ğ‘–âˆ’1)},={ğ‘¢âˆ£ğ‘¢âˆˆğ‘ğ‘¡0ğ‘£(ğ‘–)},={ğ‘¢âˆ£ğ‘¢âˆˆğ‘ğ‘¡0ğ‘£(ğ‘–+1,ğ¿)}.
Lemma 11
For every edge (u, v) incidents to a vertex v,

figure f
Proof
Fix any vertex ğ‘¢âˆˆğ‘ğ‘¡0ğ‘£. We consider the following two possible scenarios.

Case 1ğ‘¢âˆˆğ‘Œ1âˆªğ‘Œ2 When the level of the vertex v decreases from i to ğ‘–âˆ’1, â„“ğ‘¡0(ğ‘¢,ğ‘£)=â„“ğ‘¡1(ğ‘¢,ğ‘£) and thus ğœ™ğ‘¡0(ğ‘¢,ğ‘£)=ğœ™ğ‘¡1(ğ‘¢,ğ‘£), which implies Î”ğœ™(ğ‘¢,ğ‘£)=0.

Case 2 ğ‘¢âˆˆğ‘‹

When the level of the vertex v decreases from i to ğ‘–âˆ’1, we have â„“ğ‘¡0(ğ‘¢,ğ‘£)=ğ‘– and â„“ğ‘¡1(ğ‘¢,ğ‘£)=(ğ‘–âˆ’1). The following result is thus derived:

Î”ğœ™(ğ‘¢,ğ‘£)=(ğ›½(ğ›½âˆ’1)+ğœ–)(ğ¿âˆ’ğ‘–)âˆ’(ğ›½(ğ›½âˆ’1)+ğœ–)(ğ¿âˆ’ğ‘–+1)=âˆ’(ğ›½(ğ›½âˆ’1)+ğœ–).
â—»

Next, let ğ‘Šğ‘¡0ğ‘£=ğ‘¥+ğ‘¦1+ğ‘¦2, where x, ğ‘¦1 and ğ‘¦2 on the right-hand-side correspond to the weights generated by the subsets X, ğ‘Œ1, ğ‘Œ2, respectively. So, we get the following lemmas:

Lemma 12
âˆ‘ğ‘¢âˆˆğ‘ğ‘¡0ğ‘£Î”ğœ™(ğ‘¢,ğ‘£)â‰¤âˆ’(ğ›½(ğ›½âˆ’1)+ğœ–)(â„ğ‘¥ğ›½ğ‘–/ğœ‡).

Proof
We consider |X| in the following two cases:

Case 1|ğ‘‹| â‰¤ ğ‘˜ğ‘£

ğ‘¥=|ğ‘‹|â‹…ğœ‡ğ›½âˆ’ğ‘–â‡’|ğ‘‹|=ğ‘¥ğ›½ğ‘–ğœ‡â‰¤â„ğ‘¥ğ›½ğ‘–/ğœ‡(âˆµhâ‰¥1)
Case 2|ğ‘‹| > ğ‘˜ğ‘£. Here, we may assume, without loss of generality, that ğ‘¦1=0. Then, we have

 ğ‘¥=ğ‘˜ğ‘£â‹…ğœ‡ğ›½âˆ’ğ‘–â‡’ |ğ‘‹|=|ğ‘‹|ğ‘˜ğ‘£â‹…ğ‘¥ğ›½ğ‘–ğœ‡â‰¤âŒˆğ›¿ğ‘¡0(ğ‘£)ğ‘˜ğ‘£âŒ‰â‹…ğ‘¥ğ›½ğ‘–ğœ‡â‰¤â„â‹…ğ‘¥ğ›½ğ‘–ğœ‡.
Finally, since

âˆ‘ğ‘¢âˆˆğ‘ğ‘¡0ğ‘£Î”ğœ™(ğ‘¢,ğ‘£)=|ğ‘‹|â‹…âˆ’(ğ›½(ğ›½âˆ’1)+ğœ–),
the lemma thus follows. â—»

Lemma 13
Î”ğœ“(ğ‘£)=(ğ›¼ğ‘âˆ—ğ‘£âˆ’ğ‘¥âˆ’ğ‘¦1âˆ’ğ‘¦2)â‹…ğ›½ğ‘–+1ğœ‡(ğ›½âˆ’1)âˆ’max{0,ğ›¼ğ‘âˆ—ğ‘£âˆ’ğ›½ğ‘¥âˆ’ğ‘¦1âˆ’ğ‘¦2}â‹…ğ›½ğ‘–ğœ‡(ğ›½âˆ’1).

Proof
We have ğ‘Šğ‘¡0ğ‘£=ğ‘¥+ğ‘¦1+ğ‘¦2<ğ‘âˆ—ğ‘£, and we have to consider the following relationship between ğ‘¥+ğ‘¦1 and ğ‘˜ğ‘£â‹…ğœ‡ğ›½âˆ’ğ‘–. With the above relationship, we compute ğ‘Šğ‘¡1ğ‘£ by the following:

Case 1 |ğ‘‹|<ğ‘˜ğ‘£ and |ğ‘‹+ğ‘Œ1|â‰¤ğ‘˜ğ‘£:

ğ‘Šğ‘¡0ğ‘£ğ‘Šğ‘¡1ğ‘£=ğ‘Šğ‘£(ğ‘–)=ğ·ğ‘¡0ğ‘£(0,ğ‘–)ğœ‡ğ›½âˆ’(ğ‘–)+âˆ‘ğ‘—>ğ‘–min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(ğ‘—)}ğœ‡ğ›½âˆ’ğ‘—;=ğ‘Šğ‘£(ğ‘–âˆ’1)=ğ·ğ‘¡0ğ‘£(0,ğ‘–âˆ’1)ğœ‡ğ›½âˆ’(ğ‘–âˆ’1)+ğ·ğ‘¡0ğ‘£(ğ‘–)ğœ‡ğ›½âˆ’(ğ‘–)+âˆ‘ğ‘—>ğ‘–+1min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(ğ‘—)}ğœ‡ğ›½âˆ’ğ‘—=ğ›½ğ‘¥+ğ‘¦1+ğ‘¦2;
Case 2 |ğ‘‹+ğ‘Œ1|>ğ‘˜ğ‘£:

ğ‘Šğ‘¡0ğ‘£ğ‘Šğ‘¡1ğ‘£=ğ‘Šğ‘£(ğ‘–)=ğ‘˜ğ‘£ğœ‡ğ›½âˆ’(ğ‘–)+âˆ‘ğ‘—>ğ‘–min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(ğ‘—)}ğœ‡ğ›½âˆ’ğ‘—;=ğ‘Šğ‘£(ğ‘–âˆ’1)=min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(0,ğ‘–âˆ’1)}ğœ‡ğ›½âˆ’(ğ‘–âˆ’1)+min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(ğ‘–)}ğœ‡ğ›½âˆ’(ğ‘–)+âˆ‘ğ‘—>ğ‘–min{ğ‘˜ğ‘£,ğ·ğ‘¡0ğ‘£(ğ‘—)}ğœ‡ğ›½âˆ’ğ‘—â‰¤(ğ›½+1)ğ‘¥+ğ‘¦1+ğ‘¦2;
By the above cases, we have a weight change of at least ğ›½ğ‘¥+ğ‘¦1+ğ‘¦2 in ğ‘Šğ‘£. The desired bound on Î”ğœ“(ğ‘£) can thus be obtained by direct substitution. â—»

Finally, depending upon the value of ğ›¼ğ‘âˆ—ğ‘£âˆ’ğ›½ğ‘¥âˆ’ğ‘¦1âˆ’ğ‘¦2, we consider two possible scenarios, where we show that in each case, Î”ğµâ‰¥â„â€²â‹…ğ›½ğ‘–ğ‘âˆ—ğ‘£/ğœ‡. This in turn implies Î”ğµâ‰¥|Î”COUNT| as desired.

Case 1ğ›¼ğ‘âˆ—ğ‘£â‰¤ğ›½ğ‘¥+ğ‘¦1+ğ‘¦2

ğœ–â‹…Î”ğµ=â›ââœâœâˆ‘ğ‘¢âˆˆğ‘ğ‘¡0ğ‘£Î”ğœ“(ğ‘¢)+âˆ‘ğ‘’âˆˆğ¸Î”ğœ™(ğ‘’)+Î”ğœ“(ğ‘£)ââ âŸâŸâ‰¥âˆ’1ğ›½âˆ’1â‹…â„ğ‘¥ğ›½ğ‘–ğœ‡âˆ’(ğ›½(ğ›½âˆ’1)+ğœ–)â‹…â„ğ‘¥ğ›½ğ‘–ğœ‡+(ğ›¼ğ‘âˆ—ğ‘£âˆ’ğ‘¥âˆ’ğ‘¦1âˆ’ğ‘¦2)â‹…ğ›½ğ‘–+1ğœ‡(ğ›½âˆ’1)â‰¥ğ›½ğ‘–ğœ‡(âˆ’1ğ›½âˆ’1â„ğ‘âˆ—ğ‘£âˆ’(ğ›½(ğ›½âˆ’1)+ğœ–)â„ğ‘âˆ—ğ‘£+(ğ›¼âˆ’1)ğ›½ğ›½âˆ’1ğ‘âˆ—ğ‘£)(âˆµğ‘âˆ—ğ‘£â‰¥ğ‘¥+ğ‘¦1+ğ‘¦2)=ğ›½ğ‘–ğ‘âˆ—ğ‘£ğœ‡(ğ›½âˆ’1)((ğ›¼âˆ’1)ğ›½âˆ’â„âˆ’(ğ›½+(ğ›½âˆ’1)ğœ–)â„)=ğ›½ğ‘–ğ‘âˆ—ğ‘£ğœ‡((ğ›¼âˆ’1)ğ›½(ğ›½âˆ’1)âˆ’â„(ğ›½+1ğ›½âˆ’1+ğœ–))if let ğ›¼=ğ›½âˆ’1ğ›½(â„(ğ›½+1ğ›½âˆ’1+2ğœ–)+ğœ‰ğœ–)+1â‰¥ğœ–â„â€²â‹…ğ›½ğ‘–ğ‘âˆ—ğ‘£ğœ‡.
Case 2 ğ›¼ğ‘âˆ—ğ‘£>ğ›½ğ‘¥+ğ‘¦1+ğ‘¦2

ğœ–â‹…Î”ğµ=â›ââœâœâˆ‘ğ‘¢âˆˆğ‘ğ‘¡0ğ‘£Î”ğœ“(ğ‘¢)+âˆ‘ğ‘’âˆˆğ¸Î”ğœ™(ğ‘’)+Î”ğœ“(ğ‘£)ââ âŸâŸâ‰¥âˆ’1ğ›½âˆ’1â‹…â„ğ‘¥ğ›½ğ‘–ğœ‡âˆ’(ğ›½(ğ›½âˆ’1)+ğœ–)â‹…â„ğ‘¥ğ›½ğ‘–ğœ‡+(ğ›¼ğ‘âˆ—ğ‘£âˆ’ğ‘¥âˆ’ğ‘¦1âˆ’ğ‘¦2)â‹…ğ›½ğ‘–+1ğœ‡(ğ›½âˆ’1)âˆ’(ğ›¼ğ‘âˆ—ğ‘£âˆ’ğ›½ğ‘¥âˆ’ğ‘¦1âˆ’ğ‘¦2)â‹…ğ›½ğ‘–ğœ‡(ğ›½âˆ’1)=ğ›½ğ‘–ğœ‡(ğ›½âˆ’1)â‹…(âˆ’ğ‘¥â„âˆ’(ğ›½+(ğ›½âˆ’1)ğœ–)ğ‘¥â„+ğ›¼(ğ›½âˆ’1)ğ‘âˆ—ğ‘£âˆ’(ğ›½âˆ’1)(ğ‘¦1+ğ‘¦2))=ğ›½ğ‘–ğœ‡(ğ›½âˆ’1)â‹…(ğ›¼(ğ›½âˆ’1)ğ‘âˆ—ğ‘£âˆ’(ğ›½+1+(ğ›½âˆ’1)ğœ–)ğ‘¥â„âˆ’(ğ›½âˆ’1)(ğ‘¦1+ğ‘¦2))â‰¥ğ›½ğ‘–ğ‘âˆ—ğ‘£ğœ‡â‹…(ğ›¼âˆ’â„(ğ›½+1ğ›½âˆ’1+ğœ–))if let ğ›¼=ğ›½âˆ’1ğ›½(â„(ğ›½+1ğ›½âˆ’1+2ğœ–)+ğœ‰ğœ–)+1â‰¥ğœ–â„â€²â‹…ğ›½ğ‘–ğ‘âˆ—ğ‘£ğœ‡.
Thus, the level scheme remains ğ›¼(ğ›½+1)-tight after a level down event. However, the value of h is bounded by n, and h appears inside ğ›¼, so that the approximation ratio of the scheme may become n in the worst-case. Fortunately, with the help of the following lemma, we can choose ğ›¼ carefully, which in turn improves the approximation ratio from n to O(1).

Lemma 14
Suppose we set ğ›¼â‰¥ğ›½/(ğ›½âˆ’1). By the time a level down event occurs at v at moment ğ‘¡0, exactly one copy of v is selected. That is, âŒˆ|ğ›¿ğ‘¡0(ğ‘£)|/ğ‘˜ğ‘£âŒ‰=1.

Proof
Assume to the contrary that v could decrease its level even if more than one copy of v is selected. Since v levels down, its weight ğ‘Šğ‘£ must have decreased; this can happen only in one of the following cases:

Case 1 An incident edge whose level is in the range [0,â„“(ğ‘£)] is deleted. In this case, since more than one copy of v is selected, ğ‘Šğ‘£ is unchanged. Thus, this case cannot happen.

Case 2 An incident edge whose level is in the range [â„“(ğ‘£)+1,ğ¿] is deleted. In this case, the weight ğ‘Šğ‘¡0ğ‘£ at moment ğ‘¡0 is less than ğ‘âˆ—ğ‘£. On the other hand, at the moment ğ‘¡â€² when v attains the current level â„“(ğ‘£) (from level â„“(ğ‘£)âˆ’1), its weight ğ‘Šğ‘¡â€²ğ‘£ was at least ğ‘ğ‘£ before it leveled up, and became at least ğ‘ğ‘£/(ğ›½+1) after it leveled up.

(The reason is from the proof of Lemma 3: the weight change between consecutive levels is at most a factor of ğ›½+1.) This implies that:

ğ‘âˆ—ğ‘£& > ğ‘Šğ‘¡0ğ‘£ â‰¥ ğ‘˜ğ‘£ğœ‡ğ›½âˆ’â„“(ğ‘£)
The above relation is true because v has to decrease its level at moment ğ‘¡0, which implies the first inequality.

Next, the second inequality holds because more than one copy of v is selected. Also, we have the following relation:

(ğ›½/(ğ›½âˆ’1))ğ‘˜ğ‘£ğœ‡ğ›½âˆ’â„“(ğ‘£) â‰¥ğ‘Šğ‘¡â€²ğ‘£ â‰¥ ğ‘ğ‘£/(ğ›½+1)
To see why the above is true, notice that the first inequality holds since the leftmost term is the maximum possible value of ğ‘Šğ‘£, while the second inequality holds naturally with the non-zero level of v. Combining the above two inequalities, we would have

ğ‘ğ‘£ğ›¼(ğ›½+1) = ğ‘âˆ—ğ‘£ > ğ‘˜ğ‘£ğœ‡ğ›½âˆ’â„“(ğ‘£) â‰¥ ğ‘ğ‘£(ğ›½âˆ’1)ğ›½(ğ›½+1),
so that ğ›¼<ğ›½/(ğ›½âˆ’1). Which leads to a contradiction

Thus, the lemma follows. â—»

The above lemma states that if we choose ğ›¼â‰¥ğ›½/(ğ›½âˆ’1), then level down of v occurs only when âŒˆ|ğ›¿ğ‘¡0(ğ‘£)|/ğ‘˜ğ‘£âŒ‰ is one. Then, Case 2 inside the proof of Lemma 9 will not occur, so that we can strengthen Lemma 9 to get |Î”COUNT|â‰¤ğ·ğ‘¡0ğ‘£(0,ğ‘–)<ğ›½ğ‘–ğ‘âˆ—ğ‘£/ğœ‡. Similarly, the proof of Lemma 12 can be revised, so that we can strengthen Lemma 12 by replacing h with one. On the other hand, we need ğ›¼â‰¥(2ğ›½+1)/ğ›½+2ğœ– to satisfy the amortized time analysis. Consequently, we set ğ›¼=(2ğ›½+1)/ğ›½+2ğœ–, and we can achieve the desired bound Î”ğµâ‰¥ğ›½ğ‘–ğ‘âˆ—ğ‘£/ğœ‡â‰¥|Î”COUNT|. The proof for the level down case is complete.

Summary and Extensions
With the appropriate setting of ğ›¼=(2ğ›½+1)/ğ›½+2ğœ–, where 0<ğœ–<1, we get an ğ›¼(ğ›½+1)-tight level scheme. Then, by setting ğ›½=2.43, Theorem 2 is proven so that we get an approximate solution of ratio close to 36 with ğ‘‚((logğ‘›)/ğœ–) amortized update time. Finally, we consider two natural extensions of the capacitated vertex cover problem, and show how to adapt the proposed level scheme to handle these extensions

Capacitated Set Cover Here, we consider the capacitated set cover problem which is equivalent to the capacitated vertex cover problem in hyper-graphs. A hyper-graph ğº=(ğ‘‰,ğ¸) has |ğ‘‰|=ğ‘› vertices and |ğ¸|=ğ‘š hyper-edges, where each hyper-edge is incident to a set of vertices. Suppose that each hyper-edge is incident to at most f vertices. Our target is to find a subset of vertices, each with a certain number of copies, so that every edge in E is covered, while the total cost of the selected vertices (each of which is weighted by the corresponding number of copies) is minimized. Here, we treat the hyper-graph vertex cover problem as if the original vertex cover problem, and use the same level scheme and the definition of the weight of a vertex ğ‘Šğ‘£. That is, the weight ğ‘Šğ‘£ of a vertex v is defined as follows:

Case 1 ğ·ğ‘£(0,â„“(ğ‘£))>ğ‘˜ğ‘£:

ğ‘Šğ‘£=ğ‘˜ğ‘£ğœ‡ğ›½âˆ’â„“(ğ‘£)+âˆ‘ğ‘–>â„“(ğ‘£)min{ğ‘˜ğ‘£,ğ·ğ‘£(ğ‘–)}ğœ‡ğ›½âˆ’ğ‘–
Case 2 ğ·ğ‘£(0,â„“(ğ‘£))â‰¤ğ‘˜ğ‘£:

ğ‘Šğ‘£=ğ·ğ‘£(0,â„“(ğ‘£))ğœ‡ğ›½âˆ’â„“(ğ‘£)+âˆ‘ğ‘–>â„“(ğ‘£)min{ğ‘˜ğ‘£,ğ·ğ‘£(ğ‘–)}ğœ‡ğ›½âˆ’ğ‘–
We also use the same conditions for level up and level down. However, we still need to do some adjustments for this problem. First, we re-design the number of levels, L, to be âŒˆlogğ›½(ğ‘šğœ‡ğ›¼/ğ‘min)âŒ‰. Next, we adjust the flexible range by multiplying it by f so that ğ‘Šğ‘£âˆˆ(ğ‘ğ‘£/ğ‘“ğœ€,ğ‘ğ‘£]. In Lemma 2, we have proved that if there are more than ğ‘˜ğ‘£ edges assigned to a vertex v, then every edge is accounted for at most 2(ğ›½/(ğ›½âˆ’1))ğœ‹ğ‘’. But here, a hyper-edge e may be incident to at most f vertices so that the total time for a hyper-edge is bounded by at most (2(ğ›½/(ğ›½âˆ’1))+(ğ‘“âˆ’1))ğœ‹ğ‘’ instead.

By the arguments of Sect. 2, we observe that the approximation ratio comes from (1) the flexible range of weight function ğ‘Šğ‘£ and (2) the total number of times an edge is used. Since both of these terms are increased by a factor of f in the dynamic set cover problem; thus, the approximation ratio here becomes ğ‘‚(ğ‘“2).

When we consider the updated time in the dynamic setting, we modify our potential function as follows:

figure g
From Sect. 3, we know that the update time in the dynamic vertex cover problem is related to the number of levels in the level scheme. Here, this number will be adjusted to ğ‘‚(log(ğ‘š+ğ‘›)). Furthermore, a hyper-edge is incident to at most f vertices (instead of at most two vertices in the vertex cover problem). Thus, it will affect at most f vertices when there is an edge insertion or deletion. Combining these, we can readily show that our scheme achieves ğ‘‚(ğ‘“log(ğ‘š+ğ‘›)) amortized update time.

Capacitated Vertex Cover with Non-uniform Unsplittable Demand In this part, we consider a more general model in which each edge has an unsplittable demand. That is, the demand of each edge must be covered by exactly one of its endpoints. We first show that, in a static setting, with some modification, our approach in Sect. 2 already gives an O(1)-approximate solution. First, when we consider the general case, we have to revise the capacity constraint in the primal problem to ğ‘˜ğ‘£ğ‘¥ğ‘£âˆ’âˆ‘ğ‘’âˆˆğ‘ğ‘£ğ‘¦ğ‘’ğ‘£ğ‘‘ğ‘’â‰¥0, and we also have to change the vertex constraint in the dual problem to ğ‘ğ‘£ğ‘‘ğ‘’+ğ‘™ğ‘’ğ‘£â‰¥ğœ‹ğ‘’.

To cope with these changes, we will revise the number of levels of our level scheme to be ğ¿=âŒˆlogğ›½(ğ‘˜maxğœ‡ğ›¼/ğ‘min)âŒ‰, where ğ‘˜max denotes the maximum capacity of a vertex. Moreover, we adjust our definition of the weight ğ‘Šğ‘£ of a vertex as follows:

Case 1 âˆ‘ğ‘’âˆ£ğ‘’âˆ¼ğ‘£,â„“(ğ‘’)=â„“(ğ‘£)ğ‘‘ğ‘’>ğ‘˜ğ‘£:

ğ‘Šğ‘£=ğ‘˜ğ‘£ğœ‡ğ›½âˆ’â„“(ğ‘£)+âˆ‘ğ‘—âˆ£â„“(ğ‘’)=ğ‘—>â„“(ğ‘£)min{ğ‘˜ğ‘£,âˆ‘ğ‘’ğ‘‘ğ‘’}ğœ‡ğ›½âˆ’ğ‘—
Case 2 âˆ‘ğ‘’âˆ£ğ‘’âˆ¼ğ‘£,â„“(ğ‘’)=â„“(ğ‘£)ğ‘‘ğ‘’â‰¤ğ‘˜ğ‘£:

ğ‘Šğ‘£=âˆ‘ğ‘’âˆ£ğ‘’âˆ¼ğ‘£,â„“(ğ‘’)=â„“(ğ‘£)ğ‘‘ğ‘’ğœ‡ğ›½âˆ’â„“(ğ‘£)+âˆ‘ğ‘—âˆ£â„“(ğ‘’)=ğ‘—>â„“(ğ‘£)min{ğ‘˜ğ‘£,âˆ‘ğ‘’ğ‘‘ğ‘’}ğœ‡ğ›½âˆ’ğ‘—
where ğ‘’âˆ¼ğ‘£ denotes e is an edge incident to v.

Due to the change of the mathematical model in both primal and dual problems, we need a slightly different strategy from that in Sect. 2. We use the total demand of the unassigned edges to replace the number of unassigned edges to determine the value of ğ‘ğ‘£ and ğ‘™ğ‘’ğ‘£. In particular:

If âŒˆâˆ‘ğ‘’âˆˆğ›¿(ğ‘£)ğ‘‘ğ‘’/ğ‘˜ğ‘£âŒ‰>1: ğ‘ğ‘£=ğœ‡ğ›½âˆ’â„“(ğ‘£), and ğ‘™ğ‘’ğ‘£=0;

If âŒˆâˆ‘ğ‘’âˆˆğ›¿(ğ‘£)ğ‘‘ğ‘’/ğ‘˜ğ‘£âŒ‰â‰¤1: ğ‘ğ‘£=ğœ‡âˆ‘ğ‘–âˆ£âˆ‘â„“(ğ‘’)=ğ‘–ğ‘‘ğ‘’â‰¥ğ‘˜ğ‘£ğ›½âˆ’ğ‘–, ğ‘™ğ‘’ğ‘£=0 if âˆ‘â„“(ğ‘’)=ğ‘–ğ‘‘ğ‘’â‰¥ğ‘˜ğ‘£, and ğ‘™ğ‘’ğ‘£=ğ‘‘ğ‘’â‹…ğœ‡ğ›½âˆ’â„“(ğ‘’) otherwise.

For every edge e: ğœ‹ğ‘’=ğ‘‘ğ‘’â‹…ğœ‡ğ›½âˆ’â„“(ğ‘’).

Then, we use the same technique as that in Sect. 2, and it is easy to verify that the above choices of ğ‘ğ‘£, ğ‘™ğ‘’ğ‘£, and ğœ‹ğ‘’ give a feasible solution to the dual problem. Again, for the total cost of our solution, we separate the analysis into two parts, based on the multiplicity of the vertex v:

Case 1 âŒˆâˆ‘ğ‘’âˆˆğ›¿(ğ‘£)ğ‘‘ğ‘’/ğ‘˜ğ‘£âŒ‰>1: In this case, the external component of ğ‘Šğ‘£ is at most 1/(ğ›½âˆ’1) of the internal component, so that ğ‘Šğ‘£â‰¤(ğ›½/(ğ›½âˆ’1))ğ‘˜ğ‘£ğ‘ğ‘£. Then, the cost of all copies of v is:

âŒˆâˆ‘ğ‘’âˆˆğ›¿(ğ‘£)ğ‘‘ğ‘’/ğ‘˜ğ‘£âŒ‰â‹…ğ‘ğ‘£â‰¤âŒˆâˆ‘ğ‘’âˆˆğ›¿(ğ‘£)ğ‘‘ğ‘’/ğ‘˜ğ‘£âŒ‰â‹…ğœ€â‹…ğ‘Šğ‘£â‰¤2â‹…âˆ‘ğ‘’âˆˆğ›¿(ğ‘£)ğ‘‘ğ‘’ğ‘˜ğ‘£â‹…ğœ€â‹…(ğ›½/(ğ›½âˆ’1))ğ‘˜ğ‘£ğ‘ğ‘£=2(ğ›½/(ğ›½âˆ’1))ğœ€â‹…âˆ‘ğ‘’âˆˆğ›¿(ğ‘£)ğ‘‘ğ‘’ğ‘ğ‘£ = 2(ğ›½/(ğ›½âˆ’1))ğœ€â‹…âˆ‘ğ‘’âˆˆğ›¿(ğ‘£)ğœ‹ğ‘’.
Case 2 âŒˆâˆ‘ğ‘’âˆˆğ›¿(ğ‘£)ğ‘‘ğ‘’/ğ‘˜ğ‘£âŒ‰ =1: In this case, we pick one copy of vertex v, whose cost is:

ğ‘ğ‘£â‰¤ğœ€â‹…ğ‘Šğ‘£â‰¤ğœ€â‹…âˆ‘ğ‘’âˆ¼ğ‘£ğœ‹ğ‘’ = ğœ€â‹…(âˆ‘ğ‘’âˆˆğ›¿(ğ‘£)ğœ‹ğ‘’+âˆ‘ğ‘’âˆ‰ğ›¿(ğ‘£),ğ‘’âˆ¼ğ‘£ğœ‹ğ‘’),
As compared to the uniform demand case, every edge multiplies its demand. Yet, the selected copies also multiply the same constant. Thus, with an analogous analysis, the approximation ratio of the revised algorithm in this section (for non-uniform demand) is the same for the uniform demand case.

Unfortunately, when we consider the dynamic operations, an edge insertion or deletion may cause a vertex to adjust its level severely because the edge weight, in this case, connects to the edgeâ€™s demand. It is open whether we can maintain a constant approximation ratio with polylogarithmic update time for this general problem where edges have non-uniform unsplittable demands.

However, we still present two simple approaches for this problem by combining other techniques with the initially proposed level scheme in Sect. 2.

The first approach is to partition all of the edges into log2(ğ‘‘max) clusters according to its demand (where the ith cluster contains edges with demand in the range [2ğ‘–âˆ’1,2ğ‘–)), and maintain each cluster by its own data structure. In every cluster, we set value of ğ›¼=2((2ğ›½+1)/ğ›½+2ğœ–). Whenever there is an edge insertion or edge deletion, we run the proposed algorithm in the corresponding cluster. That is, only the data structure of one cluster is updated per each edge update event. For the output, we select the vertices, and their corresponding number of copies, in each of the clusters to cover all the edges in that cluster. After these changes, we obtain an ğ‘‚(logğ‘‘max) approximation ratio solution with ğ‘‚(ğ¿/ğœ–)=ğ‘‚(logğ‘˜max/ğœ–) update time, where ğ‘‘max=maxğ‘’{ğ‘‘ğ‘’} and ğ‘˜max=maxğ‘£{ğ‘˜ğ‘£}.

The second approach works for integral demands. We view an edge e with demand d as d edges ğ‘’1,ğ‘’2,â€¦,ğ‘’ğ‘‘ with uniform demand between the same endpoints. Then, we execute the proposed level scheme. The only problem is that those edges ğ‘’1,ğ‘’2,â€¦,ğ‘’ğ‘‘ corresponding to the original edge e may be assigned to the different endpoints. We simply assign all edges to the endpoint that is covering the majority of these edges, based on the solution in the proposed level scheme. After that, the total time is increased by at most a factor of 2, so that we obtain an O(1)-approximate solution with the ğ‘‚(ğ‘‘maxğ¿/ğœ–)=ğ‘‚(ğ‘‘maxlogğ‘˜max/ğœ–) amortized update time.

Concluding Remarks
We have extended dynamic vertex cover to the more general WMCVC problem, and developed a constant-factor dynamic approximation algorithm with ğ‘‚(logğ‘›/ğœ–) amortized update time, where n is the number of the vertices. Note that, in Gupta et al.â€™s very recent paper [12], their greedy algorithm with minor adaptions is also able to work for the soft dynamic capacitated vertex cover problem. However, it only gives a logarithmic-factor approximation algorithm with ğ‘‚(logğ‘›) amortized update time. Moreover, our proposed algorithm can also be extended to solve the (soft) capacitated set cover problem, and the soft capacitated vertex cover problem with non-uniform unsplittable edge demand.

We conclude this paper with some open problems. First, recall that in the static model, the soft capacitated vertex cover problem [11] can be approximated within a factor of two and three for the uniform and non-uniform edge demand cases, respectively. Here, we have shown that it is possible to design a dynamic scheme with O(1) approximation ratio with polylogartihmic update time for the uniform edge demand case. Thus, designing an O(1)-approximation ratio algorithm with ğ‘‚(logğ‘˜max), or polylogarithmic, update time for the non-uniform edge demand case seems promising.

Moreover, it would also be of significant interest to explore whether it is possible to derive a constant approximation ratio for the WMCVC problem under constant update time. Also, in recent years, more studies on the worst-case update time for dynamic algorithms have been conducted. It would be worthwhile to examine update time in the worst-case analysis.