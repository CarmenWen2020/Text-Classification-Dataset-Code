Let C be an arithmetic circuit of size s, given as input that computes a polynomial ğ‘“âˆˆğ”½[ğ‘¥1,ğ‘¥2,â€¦,ğ‘¥ğ‘›], where ğ”½ is a finite field or the field of rationals. Using the Hadamard product of polynomials, we obtain new algorithms for the following two problems first studied by Koutis and Williams (Faster algebraic algorithms for path and packing problems, 2008, https://doi-org.ezproxy.auckland.ac.nz/10.1007/978-3-540-70575-8_47; ACM Trans Algorithms 12(3):31:1â€“31:18, 2016, https://doi-org.ezproxy.auckland.ac.nz/10.1145/2885499; Inf Process Lett 109(6):315â€“318, 2009, https://doi-org.ezproxy.auckland.ac.nz/10.1016/j.ipl.2008.11.004):

(k,n)âˆ’MLC: is the problem of computing the sum of the coefficients of all degree-k multilinear monomials in the polynomial f. We obtain a deterministic algorithm of running time (ğ‘›â†“ğ‘˜/2)â‹…ğ‘›ğ‘‚(logğ‘˜)â‹…ğ‘ ğ‘‚(1). This improvement over the ğ‘‚(ğ‘›ğ‘˜) time brute-force search algorithm answers positively a question of Koutis and Williams (2016). As applications, we give exact counting algorithms, faster than brute-force search, for counting the number of copies of a tree of size k in a graph, and also the problem of exact counting of m-dimensional k-matchings.

kâˆ’MMD: is the problem of checking if there is a degree-k multilinear monomial in the polynomial f with non-zero coefficient. We obtain a randomized algorithm of running time ğ‘‚(4.32ğ‘˜â‹…ğ‘›ğ‘‚(1)). Additionally, our algorithm is polynomial space bounded.

Other results include fast deterministic algorithms for (k,n)âˆ’MLC and kâˆ’MMD problems for depth three circuits.

Access provided by University of Auckland Library

Introduction
Let ğ”½ be any field and ğ‘‹={ğ‘¥1,ğ‘¥2,â€¦,ğ‘¥ğ‘›} be a set of commuting variables. Let ğ”½[ğ‘‹] denote the commutative polynomial ring of multivariate polynomials over the field ğ”½ in the variables X. That is, the elements of ğ”½[ğ‘‹] are ğ”½-linear combinations of monomials in the variables X, where monomials are variable products of the form

ğ‘š=ğ‘¥ğ‘’11ğ‘¥ğ‘’22â‹¯ğ‘¥ğ‘’ğ‘›ğ‘›,
where the ğ‘’ğ‘– are nonnegative integers. The degree of the monomial m, defined above, is ğ‘’1+ğ‘’2+â‹¯+ğ‘’ğ‘›. We denote by ğ‘‹ğ‘‘ the set of all degree-d monomials in the variables X. The degree of a polynomial f is the maximum degree of a nonzero monomial occurring in f.

We denote the coefficient of a monomial m in f by [m]f. Thus, if f is a polynomial of degree d we can write it as a sum

ğ‘“=âˆ‘ğ‘šâˆˆğ‘‹ğ‘‘[ğ‘š]ğ‘“â‹…ğ‘š,
A polynomial ğ‘“âˆˆğ”½[ğ‘‹] is homogeneous if all its nonzero monomials have the same degree. A linear form is a homogeneous degree-1 polynomial. For a degree-d polynomial ğ‘“âˆˆğ”½[ğ‘‹], its homogeneous component of degree â„“â‰¤ğ‘‘, denoted ğ»â„“(ğ‘“) is

ğ»â„“(ğ‘“)=âˆ‘ğ‘šâˆˆğ‘‹â„“[ğ‘š]ğ‘“â‹…ğ‘š.
Thus, we can write ğ‘“=âˆ‘ğ‘‘â„“=0ğ»â„“(ğ‘“).

Computationally, a polynomial f in ğ”½[ğ‘‹] can be given as input in different representations. When f is given explicitly as a list of all its nonzero monomials with coefficients, that is called the sparse representation. The sparse representation is usually inefficient because a degree d polynomial can have (ğ‘›+ğ‘‘ğ‘‘) nonzero monomials. There are more compact representations of polynomials, defined below, well-studied in algebraic complexity theory (see e.g. the survey by Shpilka and Yehudayoff [33]), that are central to the present paper.

Definition 1.1
(Arithmetic Circuit) An arithmetic circuit C over ğ”½ is a directed acyclic graph such that each indegree 0 node is labeled with an input variable from X or a scalar from ğ”½. Each internal node is called a gate. It has indegree (called fan-in) 2, and is labelled either (+) or (Ã—) (addition or multiplication gate). Each gate of the circuit computes a polynomial. Each input gate computes the variable/scalar labelling it. The polynomial computed at a + (or Ã—) gate is the sum (respectively, product) of the polynomials computed at its inputs. The polynomial computed by C is the polynomial computed at the output gate of the circuit.

An arithmetic circuit C is said to be homogeneous if every gate in C computes a homogeneous polynomial.

Definition 1.2
(Algebraic Branching Programs (ABP)) [26, 29] An algebraic branching program (ABP) is a directed acyclic graph with one in-degree-0 vertex called the source, and one out-degree-0 vertex called the sink. The vertex set of the graph is partitioned into layers 0,1,â€¦,â„“, with directed edges only between adjacent layers (i to ğ‘–+1). The source and the sink are at layers zero and â„“ respectively. Each edge is labeled by a linear form over variables ğ‘¥1,ğ‘¥2,â€¦,ğ‘¥ğ‘›. Let ğ‘ƒ=(ğ‘’1,ğ‘’2,â€¦,ğ‘’â„“) be a source-to-sink directed path and let ğ¿ğ‘– be the linear form labeling the edge ğ‘’ğ‘– on the path. Then the polynomial computed by the ABP is defined as the sum of products

âˆ‘ğ‘ƒâˆğ‘–=1â„“ğ¿ğ‘–,
(1)
where the sum is over all source-to-sink directed paths P. An ABP is homogeneous if all edge labels are homogeneous linear forms.

The Problems
Koutis and Williams [21, 22, 40] introduced and studied two natural algorithmic problems on arithmetic circuits:

1.
Given as input an arithmetic circuit C computing a polynomial ğ‘“âˆˆğ”½[ğ‘‹], the k-multilinear monomial counting problem, denoted (k,n)âˆ’MLC is to compute the sum of the coefficients of all degree-k multilinear monomials in the polynomial f.Footnote1

2.
The k-multilinear monomial detection problem, denoted kâˆ’MMD, is to test if there is a degree-k multilinear monomial in the polynomial f with non-zero coefficient.

Both (k,n)âˆ’MLC and kâˆ’MMD can be solved in time ğ‘‚âˆ—(ğ‘›ğ‘˜) by a brute-force computation:Footnote2 Suppose the input polynomial f is represented by an arithmetic circuit C of size s. We can first easily compute from C a homogeneous circuit ğ¶â€² of size ğ‘‚(ğ‘˜2â‹…ğ‘ ) that represents the degree-k homogeneous component ğ»ğ‘˜(ğ‘“). This computation is done by keeping track of the different homogeneous components of C at every gate, discarding the homogeneous components of degree more than k [34] (or see the survey for details [33, Theorem 2.2]). Note that ğ»ğ‘˜(ğ‘“) has at most (ğ‘›+ğ‘˜ğ‘˜) monomials. We can compute the sparse representation of ğ»ğ‘˜(ğ‘“) in time ğ‘‚âˆ—((ğ‘›+ğ‘˜ğ‘˜)), again gate by gate, bottom up, in the circuit ğ¶â€².

The above two problems have attracted significant attention in recent times. In particular, Koutis [21], Williams [40], and Koutis-Williams [22] have studied (k,n)âˆ’MLC and kâˆ’MMD problems from the viewpoint of parameterized and exact algorithms. These problems are natural generalizations of the well-studied k-path detection and counting problems in a given graph [21]. Moreover, some other combinatorial problems like kâˆ’Tree, mâˆ’Dimensional kâˆ’Matching [22], well-studied in the parameterized complexity, reduce to these problems. In fact, the first randomized FPT algorithms for the decision version of these combinatorial problems were obtained from an ğ‘‚âˆ—(2ğ‘˜) algorithm for kâˆ’MMD for monotone circuits using an algebraic technique based on group algebras [21, 22, 40]. Recently, Brand et al. [9] have given the first randomized FPT algorithm for kâˆ’MMD for general circuits that runs in time ğ‘‚âˆ—(4.32ğ‘˜). Their method is based on exterior algebra and color coding [1].

In general, the exact counting versions of the k-path problem and many related problems are #W[1]-hard with respect to parameter k. For these counting problems, improvements to the trivial ğ‘‚âˆ—(ğ‘›ğ‘˜) time exhaustive search algorithm are known only in some cases (like counting k-paths) [7]. In this connection, Koutis and Williams [22] ask if there is an algorithm for (k,n)âˆ’MLC that improves upon the naive ğ‘‚âˆ—(ğ‘›ğ‘˜) time algorithm. It would yield faster algorithms for several exact counting problems. Indeed, Koutis and Williams in [22] give an algorithm of running time ğ‘‚âˆ—(ğ‘›ğ‘˜/2) to compute the parity of the sum of coefficients of degree-k multilinear monomials.

This Paper
In this paper, we make progress on the Koutis and Williams problem, mentioned above, by giving an ğ‘‚âˆ—(ğ‘›ğ‘˜/2) algorithm for the (k,n)âˆ’MLC problem. Broadly, we develop a new approach to the kâˆ’MMD, (k,n)âˆ’MLC problems, and related problems. Our algorithms are based on computing the Hadamard product of polynomials. The Hadamard product (also known as Schur product) generally refers to Hadamard product of matrices and is widely used in matrix analysis. We consider the Hadamard product of polynomials (e.g., see [4]).

The Hadamard product of polynomials has turned out to be a useful tool in noncommutative computation [4, 6]. A contribution of the present paper is to develop a new method for computing the Hadamard product in the commutative setting (as defined above), which turns out to be useful for designing efficient FPT and exact algorithms. An initial application of the Hadamard product of polynomials in arithmetic circuit complexity was in the context of proving hardness, e.g., showing hardness of the noncommutative determinant [6]. In contrast, the main application of Hadamard product in the present paper is in showing upper bound results. Broadly speaking, transferring techniques from circuit complexity to algorithm design is an important recent area of research. We refer the reader to the articles of Williams [39, 41].

At this point, before giving an overview of our results, we give some formal basic definitions and set up the notation for the paper.

Basic Definitions and Notation
We begin with the definition of the Hadamard product.

Definition 1.3
The Hadamard product of polynomials f and g in ğ”½[ğ‘‹] is defined as

ğ‘“âˆ˜ğ‘”=âˆ‘ğ‘š([ğ‘š]ğ‘“â‹…[ğ‘š]ğ‘”)â‹…ğ‘š,
where m runs over all monomials nonzero in f or g, and [m]f denotes the coefficient of the monomial m in f.

The underlying field ğ”½ for the polynomials rings we study in this paper is either the field of rationals â„š or a finite field ğ”½ğ‘ğ‘š, where ğ‘ğ‘š is a prime power. We briefly describe the complexity of field arithmetic in these fields. Details can be found in the textbook by von zur Gathen and Gerhard [37]. For ğ”½=â„š, the field elements are given as a/b for integers ğ‘,ğ‘,ğ‘â‰ 0, encoded in binary. The complexity of field arithmetic in â„š is governed by the complexity of integer multiplication. By the well-known SchÃ¶nhage-Strassen algorithm two n bit integers can be multiplied with ğ‘‚(ğ‘›logğ‘›loglogğ‘›) bit operations. Recently, this has been improved to ğ‘‚(ğ‘›logğ‘›) by Harvey and van der Hoeven [19]. Consequently, field arithmetic in â„š can be performed in with ğ‘‚(ğ‘›logğ‘›) bit operations for rationals a/b, where a and ğ‘â‰ 0 are n-bit integers.

For a finite field ğ”½ğ‘ğ‘š, the field is given by the prime p in binary, along with a univariate irreducible polynomial p(z) of degree m which defines ğ¹ğ‘ğ‘š as the quotient ring ğ”½ğ‘[ğ‘§]/(ğ‘(ğ‘§)). The elements of ğ”½ğ‘ğ‘š are then representable as polynomials q(z) of degree at most ğ‘šâˆ’1 with coefficients from the prime field ğ”½ğ‘. In this representation each element of ğ”½ğ‘ğ‘š requires ğ‘šlogğ‘ bits. Addition in ğ”½ğ‘ğ‘š can be performed with ğ‘‚(ğ‘šlogğ‘) bit operations. The complexity of multiplication is governed by the complexity of multiplying polynomials in ğ”½ğ‘[ğ‘§]. There is a long line of work on fast polynomial multiplication [37], and the current best bound [18] has bit complexity ğ‘‚(ğ‘šlogğ‘log(ğ‘šlogğ‘)â‹…4logâˆ—(ğ‘šlogğ‘)), where logâˆ—(ğ‘¥) is the number of times that the natural log function must be iteratively applied to x to make the resulting value bounded by 1.

A polynomial ğ‘“âˆˆğ”½[ğ‘‹] is said to be multilinear if for every nonzero monomial ğ‘š=ğ‘¥ğ‘’11ğ‘¥ğ‘’22â‹¯ğ‘¥ğ‘’ğ‘›ğ‘› of f we have ğ‘’ğ‘–â‰¤1.

An important family of polynomials for this paper are the elementary symmetric polynomials which are defined over any field ğ”½ as follows:

The elementary symmetric polynomial ğ‘†ğ‘›,ğ‘˜âˆˆğ”½[ğ‘‹] of degree k over the n variables ğ‘‹={ğ‘¥1,ğ‘¥2,â€¦,ğ‘¥ğ‘›} is defined as

ğ‘†ğ‘›,ğ‘˜=âˆ‘ğ‘†âŠ‚[ğ‘›]:|ğ‘†|=ğ‘˜âˆğ‘–âˆˆğ‘†ğ‘¥ğ‘–.
By definition, ğ‘†ğ‘›,ğ‘˜ is the sum of all the degree-k multilinear monomials.

Two other important families of multilinear polynomials relevant for this paper, again defined over all fields, are the determinant and permanent polynomials:

Let X={ğ‘‹ğ‘–ğ‘—}1â‰¤ğ‘–,ğ‘—â‰¤ğ‘› be an ğ‘›Ã—ğ‘› matrix of commuting indeterminates. The ğ‘›ğ‘¡â„ permanent polynomial is defined as:

Per(X)=âˆ‘ğœâˆˆğ‘†ğ‘›âˆğ‘–=1ğ‘›ğ‘‹ğ‘–,ğœ(ğ‘–).
It is a homogeneous degree-n multilinear polynomial. The ğ‘›ğ‘¡â„ determinant polynomial is defined as

Det(X)=âˆ‘ğœâˆˆğ‘†ğ‘›(âˆ’1)sgn(ğœ)âˆË™ğ‘›ğ‘–=1ğ‘‹ğ‘–,ğœ(ğ‘–).
Noncommutative Computation
Let ğ‘Œ={ğ‘¦1,ğ‘¦2,â€¦,ğ‘¦ğ‘›} be n noncommuting variables. Monomials over Y are essentially words over Y, treated as an alphabet, and the free monoid ğ‘Œâˆ— is the set of all monomials over Y. The degree of a monomial is just its length. For a field ğ”½, we have the free noncommutative ring ğ”½âŸ¨ğ‘ŒâŸ©, whose elements are finite ğ”½-linear combinations of monomials, with addition defined coefficient-wise and multiplication inherited from monomial multiplication by distributivity. The degree of a noncommutative polynomial g is the maximum degree of a nonzero monomial occurring in it, and g is called homogeneous if all its monomials have the same degree.

Noncommutative Circuits and ABPs

A noncommutative arithmetic circuit computing a polynomial in ğ”½âŸ¨ğ‘ŒâŸ© is defined like commutative arithmetic circuits (Definition 1.1). The only difference is that at each multiplication gate of the circuit the order of multiplication is important. This is taken care of by prescribing an order of the inputs at each multiplication gate.

A noncommutative ABP is also defined like commutative ABPs. The crucial difference again is the order of multiplication: more precisely, in Equation 1 of Definition 1.2 the product âˆâ„“ğ‘–=0ğ¿ğ‘– is left to right in increasing order of indices.

We note that when an input polynomial f is given by black-box access, in the commutative setting it means evaluating f at chosen scalar points ğ‘Â¯âˆˆğ”½ğ‘›, and in the noncommutative setting it means evaluating f at any matrix tuple (ğ‘€1,ğ‘€2,â€¦,ğ‘€ğ‘›) substituted for the variables.

An important ingredient of our main results in the following theorem [6] that allows us to compute in polynomial time the Hadamard product of a noncommutative ABP with a noncommutative polynomial f, even with only black-box access to f.

Theorem 1.4
[6, Corollary 4] Given a noncommutative ABP of size ğ‘ 1 computing a degree-d polynomial ğ‘”âˆˆğ”½âŸ¨ğ‘ŒâŸ© and another degree-d polynomial ğ‘“âˆˆğ”½âŸ¨ğ‘ŒâŸ© by an arithmetic circuit of size ğ‘ 2 we can compute an arithmetic circuit of size ğ‘‚(ğ‘ 31â‹…ğ‘ 2) for ğ‘“âˆ˜ğ‘” in time polynomial in ğ‘ 1,ğ‘ 2 and d. Furthermore, if f is given by black-box access then we can evaluate ğ‘“âˆ˜ğ‘” at any matrix-valued input (ğ‘€1,ğ‘€2,â€¦,ğ‘€ğ‘›), where the ğ‘€ğ‘– are ğ‘¡Ã—ğ‘¡ matrices over ğ”½ in time polynomial in ğ‘ 1,ğ‘‘ and t.

Further details on noncommutative computation can be found in Nisanâ€™s work [26] and the survey paper [33].

From Commutative to Noncommutative

A crucial element of our results on Hadamard product computation is going from the commutative to the noncommutative setting.

Let ğ‘‹={ğ‘¥1,ğ‘¥2,â€¦,ğ‘¥ğ‘›} be n commuting variables and ğ‘Œ={ğ‘¦1,ğ‘¦2,â€¦,ğ‘¦ğ‘›} be n corresponding noncommuting variables.Footnote3 Suppose ğ‘“âˆˆğ”½[ğ‘‹] is a homogeneous degree-k polynomial represented by an arithmetic circuit C. We define its noncommutative version ğ¶Ë† which computes a noncommutative homogeneous degree-k polynomial denoted ğ‘“Ì‚ âˆˆğ”½âŸ¨ğ‘ŒâŸ© as follows.

Definition 1.5
Let C be a commutative arithmetic homogeneous circuit C computing a homogeneous degree-k polynomial ğ‘“âˆˆğ”½[ğ‘‹]. The noncommutative version of C, ğ¶Ë† is the noncommutative circuit obtained from C by fixing an ordering of the inputs to each product gate in C and replacing ğ‘¥ğ‘– by the noncommuting variable ğ‘¦ğ‘–,1â‰¤ğ‘–â‰¤ğ‘›. The polynomial computed by ğ¶Ë† is denoted ğ‘“Ì‚ âˆˆğ”½âŸ¨ğ‘¦1,ğ‘¦2,â€¦,ğ‘¦ğ‘›âŸ©.

We similarly define the noncommutative version ğµË† of an ABP B.

The arithmetic circuit complexity of a polynomial f is the size s(f) of the smallest circuit representing f. The ABP complexity of f is the size b(f) of the smallest ABP representing f. This notation is used for both commutative and noncommutative polynomials.

Remark 1.6
The definition of the noncommutative ğ¶Ë† is entirely dependent on the ordering of the inputs to each product gate of C. This could, for instance, be by increasing order of the gate names of the circuit C. Since C is a homogeneous circuit, we note that the circuit ğ¶Ë† is also a homogeneous circuit.

We introduce the following notation:

ğ‘‹ğ‘˜ğ‘Œğ‘˜â‰œ{all degree ğ‘˜ monomials over ğ‘‹}.â‰œ{all degree ğ‘˜ monomials over ğ‘Œ}.
For mapping noncommutative polynomials back to commutative polynomials, we use the substitution map:

ğœˆ:ğ‘Œâ†’ğ‘‹ defined as ğœˆ(ğ‘¥ğ‘–)=ğ‘¦ğ‘–,1â‰¤ğ‘–â‰¤ğ‘›.
This map extends to ğœˆ:ğ‘Œğ‘˜â†’ğ‘‹ğ‘˜ and, by linearity, gives a ring homomorphism (it is easily checked that ğœˆ(ğ‘“+ğ‘”)=ğœˆ(ğ‘“)+ğœˆ(ğ‘”) and ğœˆ(ğ‘“ğ‘”)=ğœˆ(ğ‘“)ğœˆ(ğ‘”)):

ğœˆ:ğ”½âŸ¨ğ‘ŒâŸ©â†’ğ”½[ğ‘‹],
and its kernel, ker(ğœˆ), is precisely all those noncommutative polynomials over Y that vanish if the variables are allowed to commute.

Each monomial ğ‘šâˆˆğ‘‹ğ‘˜ can appear as a different noncommutative monomial ğ‘šÌ‚ âˆˆğœˆâˆ’1(ğ‘š) in ğ‘“Ì‚ âˆˆğ”½âŸ¨ğ‘ŒâŸ©. We will use the notation ğ‘šÌ‚ â†’ğ‘š to denote that ğ‘šÌ‚ âˆˆğœˆâˆ’1(ğ‘š). Observe that

[ğ‘š]ğ‘“=âˆ‘ğ‘šÌ‚ âˆˆğœˆâˆ’1(ğ‘š)[ğ‘šÌ‚ ]ğ‘“Ì‚ =âˆ‘ğ‘šÌ‚ :ğ‘šÌ‚ â†’ğ‘š[ğ‘šÌ‚ ]ğ‘“Ì‚ .
The noncommutative circuit ğ¶Ë† is not directly useful for computing Hadamard product. However, the following symmetrization helps. We first explain how permutations ğœâˆˆğ‘†ğ‘˜ act on the set ğ‘Œğ‘˜ of degree-k monomials. The action extends, by linearity, to all homogeneous degree-k polynomials.

For each monomial ğ‘šÌ‚ =ğ‘¦ğ‘–1ğ‘¦ğ‘–2â‹¯ğ‘¦ğ‘–ğ‘˜, the permutation ğœâˆˆğ‘†ğ‘˜ maps ğ‘šÌ‚  to the monomial ğ‘šÌ‚ ğœ defined as

ğ‘šÌ‚ ğœ=ğ‘¦ğ‘–ğœ(1)ğ‘¦ğ‘–ğœ(2)â‹¯ğ‘¦ğ‘–ğœ(ğ‘˜).
By linearity, the polynomial ğ‘“Ì‚  is mapped by ğœ to the polynomial

ğ‘“Ì‚ ğœ=âˆ‘ğ‘šÌ‚ âˆˆğ‘Œğ‘˜[ğ‘šÌ‚ ]ğ‘“Ì‚ â‹…ğ‘šÌ‚ ğœ.
Definition 1.7
(Symmetrized polynomial) The symmetrized polynomial ğ‘“âˆ—âˆˆğ”½âŸ¨ğ‘ŒâŸ© obtained from ğ‘“âˆˆğ”½[ğ‘‹] is defined as the degree-k homogeneous polynomial

ğ‘“âˆ—=âˆ‘ğœâˆˆğ‘†ğ‘˜ğ‘“Ì‚ ğœ.
Polynomial Identity Testing
A fundamental algorithmic problem concerning arithmetic circuits and algebraic branching programs is polynomial identity testing: Given a polynomial ğ‘“âˆˆğ”½[ğ‘‹] as input, check if f is identically zero (which means that there are no nonzero monomials in f).

The polynomial identity testing (or PIT) problem is a central problem in the field of randomized and algebraic computation and has received a lot of attention over the years (see the survey [31, 33] for more details). When the field ğ”½ is larger than the degree, there is a simple randomized test using the Demillo-Lipton-Schwartz-Zippel Lemma [15, 32, 42]. The PIT problem has been studied both in the commutative and noncommutative settings [33].

The input polynomial f can be represented by an arithmetic circuit or an ABP, or simply given black-box access.

Complexity Theory Background
The basic complexity classes of interest in this paper are P and NP, which are the classes of decision problems solvable in deterministic polynomial time and nondeterministic polynomial time, respectively. Polynomial time as the notion of feasible computation, and the accompanying hardness theory of NP-completeness, is refined in the world of parameterized computation where the input instance is augmented with a fixed parameter k. Feasible parameterized computation means that the running time is of the form ğ‘¡(ğ‘˜)â‹…ğ‘›ğ‘‚(1) for inputs of size n and fixed parameter k, where ğ‘¡(â‹…) can be an arbitrary function that depends solely on parameter k. The parameterized analogue of P is denoted FPT. It is the class of fixed parameter time solvable problems, and algorithms with such running time are called FPT algorithms. The analogue of NP is denoted W[1], but the hardness theory has more technical details that can be found in the textbook by Downey and Fellows [16]. Cygan et al. [12] is a very good source for parameterized algorithms.

The notation ğ‘‚âˆ—(ğ‘‡(ğ‘›,ğ‘˜)) suppresses polynomial factors. Thus, a function in ğ‘‚âˆ—(ğ‘‡(ğ‘›,ğ‘˜)) is of the form ğ‘‚(ğ‘‡(ğ‘›,ğ‘˜)â‹…poly(ğ‘›,ğ‘˜)), where the notation poly(ğ‘›,ğ‘›â€²) is used as an alternative to ğ‘‚(ğ‘›ğ‘‚(1)ğ‘›â€²ğ‘‚(1)).

The following is a convenient notation for ascending sums of binomial coefficients:

(ğ‘›â†“ğ‘–)â‰œâˆ‘ğ‘—=0ğ‘–(ğ‘›ğ‘—).
Overview of Results
We apply the Hadamard product of polynomials in the setting of commutative computation. This is achieved by combining earlier ideas [4, 6] with a symmetrization trick described in Sect. 2. We then use it to design new algorithms for (k,n)âˆ’MLC, kâˆ’MMD, and related problems.

Firstly, computing the Hadamard product of the elementary symmetric polynomial ğ‘†ğ‘›,ğ‘˜âˆˆğ”½[ğ‘‹] with a polynomial ğ‘“âˆˆğ”½[ğ‘‹] sieves out precisely the degree-k multilinear component of f. This connection with the symmetric polynomial gives the following result.

Theorem 1.8
For input polynomials ğ‘“âˆˆğ”½[ğ‘¥1,ğ‘¥2,â€¦,ğ‘¥ğ‘›] to the (k,n)âˆ’MLC problem, where f is represented by an algebraic branching program of size s, there is a deterministic ğ‘‚âˆ—((ğ‘›â†“ğ‘˜/2))-time algorithm. For input polynomials f represented by an arithmetic circuit C of size s, there is a deterministic ğ‘‚âˆ—((ğ‘›â†“ğ‘˜/2)â‹…ğ‘ ğ‘â‹…logğ‘˜)-time algorithm, where c is a constant.

In the above theorem, the underlying field ğ”½ could be the rationals or any finite field. We note that the above running time beats the naive ğ‘‚âˆ—(ğ‘›ğ‘˜) bound, answering the question asked by Koutis and Williams [22].

An important ingredient of the proof is Theorem 1.4, which a result in [6].

The other ingredient is an algorithm of BjÃ¶rklund et al. [8] for evaluating the rectangular permanent over noncommutative rings, that can be viewed as an algorithm for evaluating ğ‘†âˆ—ğ‘›,ğ‘˜ (a symmetrized noncommutative version of ğ‘†ğ‘›,ğ‘˜, defined in Sect. 2) over matrices.

This yields a deterministic ğ‘‚âˆ—((ğ‘›â†“ğ‘˜/2))-time algorithm when the input polynomial is given by an algebraic branching program (ABP).

When the input polynomial f is given by an arithmetic circuit, we can first obtain from it a circuit for the degree-k homogeneous component of f. Now, applying a standard transformation via depth-reduction we can transform this degree-k n-variate commutative arithmetic circuit of size, say s to an ABP of size ğ‘ ğ‘‚(logğ‘˜) [33] which yields the claimed algorithm for (k,n)âˆ’MLC.

Theorem 1.9
The kâˆ’MMD problem for input polynomials ğ‘“âˆˆğ”½[ğ‘‹], represented as arithmetic circuits, has a randomized ğ‘‚âˆ—(4.32ğ‘˜)-time algorithm that is polynomial space-bounded, and ğ”½ is either the rationals or a finite field.

We briefly sketch the proof idea. Suppose that C is the input arithmetic circuit computing a homogeneous polynomial f of degree k. We essentially show that kâˆ’MMD is reducible to checking if the Hadamard product ğ‘“âˆ˜ğ¶â€² is nonzero for some circuit ğ¶â€² from a collection îˆ¯ of homogeneous degree-k depth two circuits. This collection of depth two circuits is obtained by application of color coding [1].

Furthermore, the commutative Hadamard product ğ‘“âˆ˜ğ¶â€² turns out to be computable in ğ‘‚âˆ—(2ğ‘˜) time by a symmetrization trick combined with Ryserâ€™s formula for the permanent. The overall running time (because of trying several choices for ğ¶â€²) turns out to be ğ‘‚âˆ—(4.32ğ‘˜). Finally, checking if ğ‘“âˆ˜ğ¶â€² is nonzero reduces to an instance of polynomial identity testing which can be solved in randomized polynomial time using Demillo-Lipton-Schwartz-Zippel Lemma [15, 32, 42].

Next, we state the results showing fast deterministic algorithms for depth three circuits. We use the notation Î£[ğ‘ â€²]Î [ğ‘˜]Î£ to denote depth-three circuits with the output gate as a + gate of fan-in ğ‘ â€², with the next layer of Ã— gates of fan-in k, each computing the product of k homogeneous linear forms over X. The overall size of the circuit is then ğ‘ =ğ‘‚(ğ‘ â€²â‹…ğ‘˜â‹…ğ‘›).

Theorem 1.10
Given any homogeneous depth three Î£[ğ‘ â€²]Î [ğ‘˜]Î£ circuit of degree k, the (k,n)âˆ’MLC problem can be solved in deterministic ğ‘‚âˆ—(2ğ‘˜)-time. Over â„¤, the kâˆ’MMD problem can be solved in deterministic ğ‘‚âˆ—(4ğ‘˜)-time. Over finite fields, kâˆ’MMD problem can be solved in deterministic ğ‘’ğ‘˜ğ‘˜ğ‘‚(logğ‘˜)ğ‘‚âˆ—(2ğ‘ğ‘˜+2ğ‘˜) time, where ğ‘â‰¤5.

It is well-known that the elementary symmetric polynomial ğ‘†ğ‘›,ğ‘˜ can be computed using an ABP of size poly(ğ‘›,ğ‘˜).

We then compute the Hadamard product of the given depth three circuit with that homogeneous ABP for ğ‘†ğ‘›,ğ‘˜, and check whether the resulting depth three circuit is identically zero or not. The same idea yields the algorithm to compute the sum of the coefficients of the multilinear terms as well.

Related Work We briefly discuss here some related work (we have a more detailed discussion appears in Sect. 7).

Soon after the first version of our paper [2] appeared in ArXiv, an independent work by Pratt [27, v1] and [28] also considers the kâˆ’MMD and (k,n)âˆ’MLC problems. The main ingredient of [27] is the application of Waring decomposition over the rationals of symmetric polynomials [23] which does not have any known analogue over finite fields of small characteristic.

The algorithms obtained [27] for kâˆ’MMD and (k,n)âˆ’MLC over the rationals are faster (ğ‘‚âˆ—(4.08ğ‘˜)-time for kâˆ’MMD and ğ‘‚âˆ—(ğ‘›ğ‘˜/2)-time for (k,n)âˆ’MLC). In comparison, our algorithms work both over the rationals and finite fields. As already mentioned, the algorithm of Koutis and Williams [22] for (k,n)âˆ’MLC works over ğ”½2 and the running time is ğ‘‚âˆ—(ğ‘›ğ‘˜/2). In this sense, our algorithm for (k,n)âˆ’MLC can also be viewed as a generalization that is independent of the fieldâ€™s characteristic. It is to be noted that over fields of small characteristic a Waring decomposition of the input polynomial may not even exist. For example, over ğ”½2 the polynomial xy has no Waring decomposition. The more recent work of Brand and Pratt [10], extending Prattâ€™s results [28] in explained in Sect. 7.

Our algorithm obtained in Theorem 1.9 for kâˆ’MMD appears quite different from the exterior algebra based algorithm [9], but it has the same running time of ğ‘‚âˆ—(4.32ğ‘˜) because of the specific application of color coding due to HÃ¼ffner et al. [20]. However, we note that our algorithm requires only poly(ğ‘›,ğ‘˜) space, whereas the algorithm in [9] takes exponential space.

The field of parameterized approximate counting has seen several interesting directions in recent years. We refer the reader to [13, 14, 38] for results showing reductions from approximate counting to the decision problem.

Organization. The rest of this paper is organized as follows. In Sect. 2 we explain the Hadamard product framework. The proof of Theorem 1.8 and its consequences are given in Sect. 3. Section 5 contains the proof of Theorem 1.9. The proof of Theorem 1.10 is given in Sect. 6.

Hadamard Product Framework
Given two arithmetic circuits ğ¶1 and ğ¶2 computing polynomials ğ‘“1 and ğ‘“2, it is in general unlikely that ğ‘“1âˆ˜ğ‘“2 can be computed by an arithmetic circuit C of size poly(|ğ¶1|,|ğ¶2|). This can be observed from the fact that for the symbolic matrix X=(ğ‘¥ğ‘–,ğ‘—)1â‰¤ğ‘–,ğ‘—â‰¤ğ‘›, the Hadamard product of the determinant polynomial Det(X) with itself is the permanent polynomial Per(X) which does not have polynomial-size circuit assuming Valiantâ€™s VPâ‰ VNP hypothesis [35]. However, it is well known that Det(X) can be computed by a polynomial-size ABP [24].

Nevertheless, we develop a method for computing the scaled Hadamard product of commutative polynomials in some special cases.

Definition 2.1
The scaled Hadamard product of polynomials ğ‘“,ğ‘”âˆˆğ”½[ğ‘‹] is defined as

ğ‘“âˆ˜ s ğ‘”=âˆ‘ğ‘š(ğ‘š!â‹…[ğ‘š]ğ‘“â‹…[ğ‘š]ğ‘”)â‹…ğ‘š,
where for monomial ğ‘š=ğ‘¥ğ‘’1ğ‘–1ğ‘¥ğ‘’2ğ‘–2â€¦ğ‘¥ğ‘’ğ‘Ÿğ‘–ğ‘Ÿ we define ğ‘š!=ğ‘’1!â‹…ğ‘’2!â‹¯ğ‘’ğ‘Ÿ!.

Computing the scaled Hadamard product is key to our algorithmic results for kâˆ’MMD and (k,n)âˆ’MLC. Broadly, it works as follows: we transform polynomials f and g to suitable noncommutative polynomials. We compute their (noncommutative) Hadamard product (Theorem 1.4) [4, 6], and then recover the scaled commutative Hadamard product ğ‘“âˆ˜ s ğ‘” (or evaluate it at a desired point ğ‘âƒ— âˆˆğ”½ğ‘›).

Suppose ğ‘“âˆˆğ”½[ğ‘¥1,ğ‘¥2,â€¦,ğ‘¥ğ‘›] is a homogeneous degree-k polynomial given by a circuit C. We have its noncommutative version ğ¶Ë† which computes the noncommutative homogeneous degree-k polynomial ğ‘“Ì‚ âˆˆğ”½âŸ¨ğ‘¦1,ğ‘¦2,â€¦,ğ‘¦ğ‘›âŸ© (see Definition 1.5).

Recall from Sect. 1.2.1 that ğ‘‹ğ‘˜ denotes the set of all degree-k monomials over X, ğ‘Œğ‘˜ denote all degree-k noncommutative monomials over Y, and we have [ğ‘š]ğ‘“=âˆ‘ğ‘šÌ‚ â†’ğ‘š[ğ‘šÌ‚ ]ğ‘“Ì‚ , where ğ‘šâˆˆğ‘‹ğ‘˜ and ğ‘šÌ‚ âˆˆğ‘Œğ‘˜. We will use the symmetrized polynomial (see Definition 1.7), ğ‘“âˆ—=âˆ‘ğœâˆˆğ‘†ğ‘˜ğ‘“Ì‚ ğœ, to compute the scaled Hadamard product ğ‘“âˆ˜ s ğ‘”.

Lemma 2.2
For a homogeneous degree-k commutative polynomial ğ‘“âˆˆğ”½[ğ‘‹] given by circuit C, and its noncommutative version ğ¶Ë† computing polynomial ğ‘“Ì‚ âˆˆğ”½âŸ¨ğ‘ŒâŸ©, consider the symmetrized noncommutative polynomial ğ‘“âˆ—=âˆ‘ğœâˆˆğ‘†ğ‘˜ğ‘“Ì‚ ğœ. Then for each monomial ğ‘šâˆˆğ‘‹ğ‘˜ and each word ğ‘šâ€²âˆˆğ‘Œğ‘˜ such that ğ‘šâ€²â†’ğ‘š, we have: [ğ‘šâ€²]ğ‘“âˆ—=ğ‘š!â‹…[ğ‘š]ğ‘“.

Proof
Let ğ‘“=âˆ‘ğ‘š[ğ‘š]ğ‘“â‹…ğ‘š and ğ‘“Ì‚ =âˆ‘ğ‘šÌ‚ [ğ‘šÌ‚ ]ğ‘“Ì‚ â‹…ğ‘šÌ‚ . As already observed, [ğ‘š]ğ‘“=âˆ‘ğ‘šÌ‚ â†’ğ‘š[ğ‘šÌ‚ ]ğ‘“Ì‚ . Now, we write ğ‘“âˆ—=âˆ‘ğ‘šâ€²[ğ‘šâ€²]ğ‘“âˆ—â‹…ğ‘šâ€². The group ğ‘†ğ‘˜ acts on ğ‘Œğ‘˜ by permuting the positions. Suppose ğ‘š=ğ‘¥ğ‘’1ğ‘–1â‹¯ğ‘¥ğ‘’ğ‘ğ‘–ğ‘ is a type ğ‘’ğ‘’=(ğ‘’1,â€¦,ğ‘’ğ‘) monomial over ğ‘‹ğ‘˜ and ğ‘šâ€²â†’ğ‘š. Then, by the well-known Orbit-Stabilizer Theorem [11, Chapter 1] the orbit ğ‘‚ğ‘šâ€² of ğ‘šâ€² under the action of ğ‘†ğ‘˜ has size ğ‘˜!ğ‘š!. It follows that

[ğ‘šâ€²]ğ‘“âˆ—=âˆ‘ğ‘šÌ‚ âˆˆğ‘‚ğ‘šâ€²ğ‘š!â‹…[ğ‘šÌ‚ ]ğ‘“Ì‚ =ğ‘š!âˆ‘ğ‘šÌ‚ â†’ğ‘š[ğ‘šÌ‚ ]ğ‘“Ì‚ =ğ‘š!â‹…[ğ‘š]ğ‘“.
It is important to note that for some ğ‘šÌ‚ âˆˆğ‘Œğ‘˜ such that ğ‘šÌ‚ â†’ğ‘š, even if [ğ‘šÌ‚ ]ğ‘“Ì‚ =0 then also [ğ‘šÌ‚ ]ğ‘“âˆ—=ğ‘š!â‹…[ğ‘š]ğ‘“. â—»

Next, we apply Lemma 2.2 to compute scaled Hadamard product in the commutative setting via noncommutative Hadamard product.

Remark 2.3
We note that given a commutative circuit C computing f, the noncommutative polynomial ğ‘“Ì‚  depends on the circuit structure of C. However, ğ‘“âˆ— depends only on the polynomial f.

Lemma 2.4
Let ğ‘”âˆˆğ”½[ğ‘‹] be a homogeneous degree-k polynomial and C be some arithmetic circuit for g. For any homogeneous degree-k polynomial ğ‘“âˆˆğ”½[ğ‘‹] and any point ğ‘âƒ— âˆˆğ”½ğ‘›

(ğ‘“âˆ˜ s ğ‘”)(ğ‘âƒ— )=(ğ‘“âˆ—âˆ˜ğ‘”Ì‚ )(ğ‘âƒ— ),
where the noncommutative polynomial ğ‘”Ì‚  is defined by the given circuit C.

Proof
We write ğ‘“=âˆ‘ğ‘š[ğ‘š]ğ‘“â‹…ğ‘š and ğ‘”=âˆ‘ğ‘šâ€²[ğ‘šâ€²]ğ‘”â‹…ğ‘šâ€². By definition, we have ğ‘“âˆ˜ s ğ‘”=âˆ‘ğ‘šğ‘š!â‹…[ğ‘š]ğ‘“â‹…[ğ‘š]ğ‘”â‹…ğ‘š.

The polynomial computed by ğ¶Ë† is ğ‘”Ì‚ (ğ‘Œ)=âˆ‘ğ‘šâˆˆğ‘‹ğ‘˜âˆ‘ğ‘šÌ‚ â†’ğ‘š[ğ‘šÌ‚ ]ğ‘”Ì‚ â‹…ğ‘šÌ‚ . By Lemma 2.2, the noncommutative polynomial ğ‘“âˆ—(ğ‘Œ)=âˆ‘ğ‘šâˆˆğ‘‹ğ‘˜âˆ‘ğ‘šÌ‚ â†’ğ‘šğ‘š!â‹…[ğ‘š]ğ‘“â‹…ğ‘šÌ‚ . Therefore,

(ğ‘“âˆ—âˆ˜ğ‘”Ì‚ )(ğ‘Œ)=âˆ‘ğ‘šâˆˆğ‘‹ğ‘˜âˆ‘ğ‘šÌ‚ â†’ğ‘šğ‘š!â‹…[ğ‘š]ğ‘“â‹…[ğ‘šÌ‚ ]ğ‘”Ì‚ â‹…ğ‘šÌ‚ =âˆ‘ğ‘šâˆˆğ‘‹ğ‘˜ğ‘š!â‹…[ğ‘š]ğ‘“â‹…(âˆ‘ğ‘šÌ‚ â†’ğ‘š[ğ‘šÌ‚ ]ğ‘”Ì‚ )â‹…ğ‘šÌ‚ .
Consequently, for any point ğ‘âƒ— âˆˆğ”½ğ‘› we have

(ğ‘“âˆ—âˆ˜ğ‘”Ì‚ )(ğ‘âƒ— )=âˆ‘ğ‘šâˆˆğ‘‹ğ‘˜ğ‘š!â‹…[ğ‘š]ğ‘“â‹…(âˆ‘ğ‘šÌ‚ â†’ğ‘š[ğ‘šÌ‚ ]ğ‘”Ì‚ )â‹…ğ‘šÌ‚ (ğ‘âƒ— ).
Since [ğ‘š]ğ‘”=âˆ‘ğ‘šÌ‚ â†’ğ‘š[ğ‘šÌ‚ ]ğ‘”Ì‚ , we have

(ğ‘“âˆ—âˆ˜ğ‘”Ì‚ )(ğ‘âƒ— )=âˆ‘ğ‘šâˆˆğ‘‹ğ‘˜ğ‘š!â‹…[ğ‘š]ğ‘“â‹…ğ‘š(ğ‘âƒ— )â‹…[ğ‘š]ğ‘”=(ğ‘“âˆ˜ s ğ‘”)(ğ‘âƒ— ).
â—»

We note an immediate corollary of the above.

Corollary 2.5
Let ğ‘“1,ğ‘“2 be homogeneous degree-k polynomials in ğ”½[ğ‘‹]. Given a noncommutative circuit C computing the polynomial ğ‘“Ì‚ 1âˆ˜ğ‘“âˆ—2âˆˆğ”½âŸ¨ğ‘ŒâŸ©, one can obtain a commutative circuit ğ¶Ìƒ  for ğ‘“1âˆ˜ s ğ‘“2âˆˆğ”½[ğ‘‹] by replacing the noncommutative variables ğ‘¦ğ‘– in C by the commutative variables ğ‘¥ğ‘–.

Proof
Let ğ‘“1=âˆ‘ğ‘š[ğ‘š]ğ‘“1â‹…ğ‘š1. So, ğ‘“Ì‚ 1=âˆ‘ğ‘šÌ‚ [ğ‘šÌ‚ ]ğ‘“Ì‚ â‹…ğ‘šÌ‚  and [ğ‘š]ğ‘“=âˆ‘ğ‘šÌ‚ â†’ğ‘š[ğ‘šÌ‚ ]ğ‘“Ì‚ . Then, ğ‘“Ì‚ 1âˆ˜ğ‘“âˆ—2(ğ‘Œ)=âˆ‘ğ‘šÌ‚ [ğ‘šÌ‚ ]ğ‘“Ì‚ 1â‹…[ğ‘šÌ‚ ]ğ‘“âˆ—2â‹…ğ‘šÌ‚ =âˆ‘ğ‘šÌ‚ [ğ‘šÌ‚ ]ğ‘“Ì‚ 1â‹…ğ‘š![ğ‘š]ğ‘“2â‹…ğ‘šÌ‚  where ğ‘šÌ‚ â†’ğ‘š. Now replacing the noncommutative variables by commutative variables, we obtain

ğ‘“Ì‚ 1âˆ˜ğ‘“âˆ—2(ğ‘‹)=âˆ‘ğ‘šğ‘š!â‹…(âˆ‘ğ‘šÌ‚ â†’ğ‘š[ğ‘šÌ‚ ]ğ‘“Ì‚ 1)â‹…[ğ‘š]ğ‘“2â‹…ğ‘š
Since, [ğ‘š]ğ‘“=âˆ‘ğ‘šÌ‚ â†’ğ‘š[ğ‘šÌ‚ ]ğ‘“Ì‚ , we further simplify and get ğ‘“Ì‚ 1âˆ˜ğ‘“âˆ—2(ğ‘‹)=ğ‘“1âˆ˜ s ğ‘“2(ğ‘‹). â—»

Remark 2.6
A key conceptual tool in [27] is the apolar inner product for homogeneous degree-k polynomials f and g in ğ”½[ğ‘‹], which is defined as

âŸ¨ğ‘“,ğ‘”âŸ©=ğ‘“(âˆ‚ğ‘¥1,â€¦,âˆ‚ğ‘¥ğ‘›)âˆ˜ğ‘”(ğ‘¥1,â€¦,ğ‘¥ğ‘›).
We note that in the Hadamard product framework, we can express the apolar inner product of f and g as ğ‘“âˆ˜ s ğ‘” evaluated at the all-ones vector 1âƒ— âˆˆğ”½ğ‘›. In Sect. 7 we present more details.

The Sum of Coefficients of Multilinear Monomials
In this section we prove Theorem 1.8. As already sketched in Sect. 1, the main idea is to apply the symmetrization trick to reduce the (k,n)âˆ’MLC problem to evaluating the rectangular permanent over a suitable matrix ring. Then we use a result of [8] to solve the instance of the rectangular permanent evaluation problem.

Before we present the results we recall the definition of ABPs (Definition 1.2) and the following different but equivalent formulation of ABPs:

A homogeneous ABP of width w computing a degree-k polynomial over X can be thought of as the (1,ğ‘¤)ğ‘¡â„ entry of the product of ğ‘¤Ã—ğ‘¤ matrices ğ‘€1â‹¯ğ‘€ğ‘˜ where entries of each ğ‘€ğ‘– are homogeneous linear forms over X. By [ğ‘¥ğ‘—]ğ‘€ğ‘–, we denote the ğ‘¤Ã—ğ‘¤ matrix over ğ”½, such that (ğ‘,ğ‘)ğ‘¡â„ entry of the matrix,([ğ‘¥ğ‘—]ğ‘€ğ‘–)(ğ‘,ğ‘)=[ğ‘¥ğ‘—](ğ‘€ğ‘–(ğ‘,ğ‘)), the coefficient of ğ‘¥ğ‘— in the linear form of the (ğ‘,ğ‘)ğ‘¡â„ entry of ğ‘€ğ‘–.

Permanent of Rectangular Matrices
We now define the permanent of a rectangular matrix. The permanent of a rectangular ğ‘˜Ã—ğ‘› matrix ğ´=(ğ‘ğ‘–ğ‘—),ğ‘˜â‰¤ğ‘›, with entries over a ring R is defined as

rPer(ğ´)=âˆ‘ğœâˆˆğ¼ğ‘˜,ğ‘›âˆğ‘–=1ğ‘˜ğ‘ğ‘–,ğœ(ğ‘–),
where ğ¼ğ‘˜,ğ‘› is the set of all injections from [k] to [n]. We define the noncommutative polynomial ğ‘†âˆ—ğ‘›,ğ‘˜ as

ğ‘†âˆ—ğ‘›,ğ‘˜(ğ‘¦1,ğ‘¦2,â€¦,ğ‘¦ğ‘›)=âˆ‘ğ‘‡âŠ†[ğ‘›]:|ğ‘‡|=ğ‘˜âˆ‘ğœâˆˆğ‘†ğ‘˜âˆğ‘–âˆˆğ‘‡ğ‘¦ğœ(ğ‘–),
which is the symmetrized version of the elementary symmetric polynomial ğ‘†ğ‘›,ğ‘˜ as defined in Lemma 2.2. Given a set of ğ‘¡Ã—ğ‘¡ matrices ğ‘€1,â€¦,ğ‘€ğ‘› over some field ğ”½ define the rectangular (block) matrix ğ´=(ğ‘ğ‘–,ğ‘—)ğ‘–âˆˆ[ğ‘˜],ğ‘—âˆˆ[ğ‘›] such that ğ‘ğ‘–,ğ‘—=ğ‘€ğ‘—. Thus, A is a ğ‘˜Ã—ğ‘› matrix with entries from the ring of ğ‘¡Ã—ğ‘¡ matrices over the field ğ”½. The following observation is crucial.

Observation 3.1
ğ‘†âˆ—ğ‘›,ğ‘˜(ğ‘€1,â€¦,ğ‘€ğ‘›)=rPer(ğ´).

Proof
To see this, observe that ,

rPer(ğ´)=âˆ‘ğ‘‡âŠ†[ğ‘›]:|ğ‘‡|=ğ‘˜Per(ğ´ğ‘‡)=âˆ‘ğ‘‡âŠ†[ğ‘›]:|ğ‘‡|=ğ‘˜âˆ‘ğœâˆˆğ‘†ğ‘˜âˆğ‘–âˆˆğ‘‡ğ‘€ğœ(ğ‘–).
Here ğ´ğ‘‡ is the minor of A such that the columns are indexed by the set T. â—»

In the sequel, we will apply a result from [8], showing that over any ring R, the permanent of a rectangular ğ‘˜Ã—ğ‘› matrix can be evaluated with ğ‘‚âˆ—((ğ‘›â†“ğ‘˜/2)) ring operations. In particular, if R is the matrix ring ğ•„ğ‘ (ğ”½), the algorithm runs in time ğ‘‚(ğ‘˜(ğ‘›â†“ğ‘˜/2)poly(ğ‘›,ğ‘ )). We now present the proof of Theorem 1.8.

Proof
We first prove a special case of the theorem when the polynomial f is given by a homogeneous degree-k ABP B of width w. Notice that we can compute the sum of the coefficients of the degree-k multilinear terms in f by evaluating (ğ‘“âˆ˜ğ‘†ğ‘›,ğ‘˜)(1âƒ— ). Now to compute the Hadamard product efficiently, we will transfer the problem to the noncommutative domain. Let ğµË† define the noncommutative version of the commutative ABP B for the polynomial f. By Lemma 2.4, it suffices to compute (ğµË†âˆ˜ğ‘†âˆ—ğ‘›,ğ‘˜)(1âƒ— ). Now, the following lemma reduces this computation to evaluating ğ‘†âˆ—ğ‘›,ğ‘˜ over a suitable matrix ring. We recall the following result from [5] (see, also [6]). â—»

Lemma 3.2
(Theorem 2 of [5]) Let f be a homogeneous degree-k noncommutative polynomial in ğ”½âŸ¨ğ‘ŒâŸ© and B be an ABP of width w computing a homogeneous degree-k polynomial ğ‘”=(ğ‘€1â‹¯ğ‘€ğ‘˜)(1,ğ‘¤) in ğ”½âŸ¨ğ‘ŒâŸ©.

Then (ğ‘“âˆ˜ğ‘”)(1âƒ— )=(ğ‘“(ğ´ğµ1,â€¦,ğ´ğµğ‘›))(1,(ğ‘˜+1)ğ‘¤) where for each ğ‘–âˆˆ[ğ‘›], ğ´ğµğ‘– is the following (ğ‘˜+1)ğ‘¤Ã—(ğ‘˜+1)ğ‘¤ block superdiagonal matrix,

ğ´ğµğ‘–=â¡â£â¢â¢â¢â¢â¢â¢00â‹®00[ğ‘¦ğ‘–]ğ‘€10â‹®000[ğ‘¦ğ‘–]ğ‘€2â‹±00â€¦â€¦â‹±â€¦â€¦00â‹®[ğ‘¦ğ‘–]ğ‘€ğ‘˜0â¤â¦â¥â¥â¥â¥â¥â¥.
Proof
We sketch the proof as we will require some details for the proof of Theorem 1.8. For any monomial ğ‘šÌ‚ =ğ‘¦ğ‘–1ğ‘¦ğ‘–2â‹¯ğ‘¦ğ‘–ğ‘˜âˆˆğ‘Œğ‘˜,

(ğ´ğµğ‘–1ğ´ğµğ‘–2â‹¯ğ´ğµğ‘–ğ‘˜)(1,(ğ‘˜+1)ğ‘¤)=([ğ‘¦ğ‘–1]ğ‘€1â‹…[ğ‘¦ğ‘–2]ğ‘€2â‹¯[ğ‘¦ğ‘–ğ‘˜]ğ‘€ğ‘˜)(1,ğ‘¤)=[ğ‘šÌ‚ ]ğ‘”,
from the definition. Hence, we have,

ğ‘“(ğ´ğµ1,ğ´ğµ2,â€¦,ğ´ğµğ‘›)(1,(ğ‘˜+1)ğ‘¤)=âˆ‘ğ‘šÌ‚ âˆˆğ‘Œğ‘˜[ğ‘šÌ‚ ]ğ‘“â‹…ğ‘šÌ‚ (ğ´ğµğ‘–1,ğ´ğµğ‘–2,â€¦,ğ´ğµğ‘–ğ‘˜)(1,(ğ‘˜+1)ğ‘¤)=âˆ‘ğ‘šÌ‚ âˆˆğ‘Œğ‘˜[ğ‘šÌ‚ ]ğ‘“â‹…[ğ‘šÌ‚ ]ğ‘”.
â—»

Now, we construct a ğ‘˜Ã—ğ‘› rectangular matrix ğ´=(ğ‘ğ‘–,ğ‘—)ğ‘–âˆˆ[ğ‘˜],ğ‘—âˆˆ[ğ‘›] from the ABP ğµË† (obtained from the given ABP B) by setting ğ‘ğ‘–,ğ‘—=ğ´ğµË†ğ‘— as defined. Using Observation 3.1, we now have,

rPer(ğ´)(1,(ğ‘˜+1)ğ‘¤)=ğ‘†âˆ—ğ‘›,ğ‘˜(ğ´ğµË†1,â€¦,ğ´ğµË†ğ‘›)(1,(ğ‘˜+1)ğ‘¤).
Now by Lemmas 2.4 and 3.2, we conclude that,

ğ‘†âˆ—ğ‘›,ğ‘˜(ğ´ğµË†1,â€¦,ğ´ğµË†ğ‘›)(1,(ğ‘˜+1)ğ‘¤).=(ğ‘†âˆ—ğ‘›,ğ‘˜âˆ˜ğµË†)(1âƒ— )=(ğ‘†ğ‘›,ğ‘˜âˆ˜ s ğµ)(1âƒ— ).
Hence applying the algorithm of BjÃ¶rklund et al. for evaluating the rectangular permanent over noncommutative ring [8], we compute the sum of the coefficients deterministically in time ğ‘‚(ğ‘˜(ğ‘›â†“ğ‘˜/2)poly(ğ‘›,ğ‘˜,ğ‘¤)).

Now, we prove the general case. We apply a standard transformation from circuits to ABPs [33, 36] and reduce the problem to the ABP case. More precisely, given an arithmetic circuit of size s computing a polynomial f of degree k, f can also be computed by a homogeneous ABP of size ğ‘ ğ‘‚(logğ‘˜). In particular, if f is given by an arithmetic circuit of size s, we first get a circuit of poly(ğ‘˜,ğ‘ ) size for degree-k part of f using a standard method of homogenization [33, Theorem 2.2]. Then, we convert the homogeneous circuit to a homogeneous ABP of size ğ‘ ğ‘‚(logğ‘˜). The width w of the new ABP is also bounded by ğ‘ ğ‘‚(logğ‘˜). Next, we apply the first part of the proof on the newly constructed ABP. Notice that the entire computation can be done in deterministic ğ‘‚(ğ‘˜(ğ‘›â†“ğ‘˜/2)poly(ğ‘›,ğ‘˜,ğ‘¤)) time which is ğ‘‚âˆ—((ğ‘›â†“ğ‘˜/2)â‹…ğ‘ ğ‘â‹…logğ‘˜) for some constant c. â—»

Some Applications
We show some applications of Theorem 1.8 and the technique developed there. The first two are algorithmic applications and the last is a hardness result.

Applying Theorem 1.8, we improve the counting complexity of two combinatorial problems studied in [22]. To the best of our knowledge, nothing better than the brute-force exhaustive search algorithms were known for the counting version of these problems. We start with the kâˆ’Tree problem: Let T be a tree with k vertices and G be an n-vertex graph. A homomorphic embedding of T in G is defined by an injective map ğœ‘:ğ‘‰(ğ‘‡)â†’ğ‘‰(ğº) such that for all ğ‘¢,ğ‘£âˆˆğ‘‰(ğ‘‡)

ğ‘¢ğ‘£âˆˆğ¸(ğ‘‡)âŸ¹ğœ‘(ğ‘¢)ğœ‘(ğ‘£)âˆˆğ¸(ğº).
A copy of T in G is ğœ‘(ğ‘‡) for some homomorphic embedding ğœ‘ of T in G. Let ğ‘’ğ‘‡,ğº denote the number of homomorphic embeddings of T in G and ğ‘ğ‘‡,ğº denote the number of copies of T in G. Let Aut(ğ‘‡) denote the automorphism group of T. For two such homomorphic embeddings ğœ‘1 and ğœ‘2 we have ğœ‘1(ğ‘‡)=ğœ‘2(ğ‘‡) if and only if ğœ‘âˆ’11ğœ‘2âˆˆAut(ğ‘‡). Hence,

ğ‘ğ‘‡,ğº=ğ‘’ğ‘‡,ğº|Aut(ğ‘‡)|.
(2)
The exact counting version of kâˆ’Tree is the problem of counting the number of copies of T in G for an input pair (T, G). Clearly, there is a trivial ğ‘‚âˆ—(ğ‘›ğ‘˜) exhaustive search algorithm for the problem. We apply Theorem 1.8 to obtain an essentially quadratic speed-up.

Corollary 4.1
The exact counting kâˆ’Tree problem of counting the number of copies of a given k-vertex tree in a given n-vertex graph can be computed in deterministic ğ‘‚âˆ—((ğ‘›â†“ğ‘˜/2)) time.

Proof
By Eq. 2 it suffices to count the number of homomorphic embeddings of T in G, as counting the number of automorphisms |Aut(ğ‘‡)| of T can be done in poly(ğ‘˜) time.

To this end, we will use a modification of the construction defined in [22, Theorem 2.2]. Let the nodes of T be {1,2,â€¦,ğ‘˜} and the nodes of G be {1,2,â€¦,ğ‘›}. W.l.o.g., we can consider T to be a tree rooted at 1. As a consequence, every node ğ‘–âˆˆ[ğ‘˜] of T uniquely defines a subtree ğ‘‡ğ‘– rooted at i. Let ğ‘‹={ğ‘¥1,ğ‘¥2,â€¦,ğ‘¥ğ‘›} be the set of n commuting variables corresponding to the n vertices of G. We inductively define a polynomial ğ¶ğ‘–ğ‘— in ğ”½[ğ‘‹] as follows:

If i is a leaf node of the tree T then ğ¶ğ‘–ğ‘—=ğ‘¥ğ‘—.

Otherwise, let ğ‘–1,ğ‘–2,â€¦,ğ‘–â„“ be the children of i in T. Inductively, we can assume that the polynomials ğ¶ğ‘–ğ‘¡,ğ‘—,1â‰¤ğ‘¡â‰¤â„“,1â‰¤ğ‘—â‰¤ğ‘› are already defined. We define

ğ¶ğ‘–ğ‘—=ğ‘¥ğ‘—âˆğ‘¡=1â„“(âˆ‘ğ‘—â€²:(ğ‘—,ğ‘—â€²)âˆˆğ¸(ğº)ğ¶ğ‘–ğ‘¡,ğ‘—â€²).
Finally, we define the polynomial Q as

ğ‘„(ğ‘‹)=âˆ‘ğ‘—=1ğ‘›ğ¶1ğ‘—.
By definition, it follows that ğ¶ğ‘–ğ‘— is a homogeneous polynomial of degree |ğ‘‰(ğ‘‡ğ‘–)| for each ğ‘–âˆˆ[ğ‘˜]. Consequently, Q(X) is a homogeneous degree-k polynomial. â—»

Claim 4.2
Let ğ‘–âˆˆ[ğ‘˜] and the subtree ğ‘‡ğ‘– have r nodes. Then the number of degree-r multilinear monomials in ğ¶ğ‘–ğ‘— is exactly the number of homomorphic embeddings of ğ‘‡ğ‘– in G that maps i to j. Hence, the number of degree-r multilinear monomials in âˆ‘ğ‘—âˆˆğ‘‰(ğº)ğ¶ğ‘–ğ‘— is the number of homomorphic embeddings of ğ‘‡ğ‘– in G.

The above claim is easily proved by induction on the size of ğ‘‡ğ‘–. It is clearly true for |ğ‘‰(ğ‘‡ğ‘–)|=1. In general, suppose ğ‘–1,ğ‘–2,â€¦,ğ‘–â„“ are the children of i in tree T. Any homomorphic embedding ğœ‘:ğ‘‡ğ‘–â†’ğº that maps i to j is defined uniquely by homomorphic embeddings ğœ‘ğ‘¡:ğ‘‡ğ‘–ğ‘¡â†’ğº such that the ranges of the ğœ‘ğ‘¡ are all disjoint and the ğ‘–ğ‘¡ map to distinct G-neighbors of j. Clearly, from the definition of ğ¶ğ‘–ğ‘— and induction, it follows that there is a unique multilinear monomial of ğ¶ğ‘–ğ‘— that corresponds to ğœ‘. Conversely, each multilinear monomial defines a unique homomorphic embedding ğœ‘:ğ‘‡ğ‘–â†’ğº that maps i to j.

Thus, the exact counting kâˆ’Tree problem is solved by counting the number of multilinear monomials in Q. By Theorem 1.8, it suffices to construct for Q an ABP of size poly(ğ‘›,ğ‘˜).

From the recursively defined structure of the noncommutative formula for ğ¶ğ‘–ğ‘— we can analyze the size. Let sizeâ„“ bound the noncommutative formula size for the polynomial ğ‘„â„“ defined as above for trees of size â„“ (note that ğ‘„ğ‘˜=ğ‘„). We note from the formula structure that size1=ğ‘› and

sizeğ‘˜=ğ‘›ğ‘˜+âˆ‘ğ‘¡=1â„“sizeğ‘˜ğ‘¡,
where ğ‘˜ğ‘¡ are the subtree sizes and ğ‘˜1+ğ‘˜2+â‹¯+ğ‘˜â„“=ğ‘˜âˆ’1. Clearly, sizeğ‘˜â‰¤ğ‘›ğ‘˜2. Thus, Q has a formulas of size at most ğ‘›ğ‘˜2 which can be converted to an ABP of size ğ‘‚(ğ‘›ğ‘˜2) by standard techniques [33]. â—»

We now consider the exact counting version of the mâˆ’Dimensional kâˆ’Matching problem: Let ğ‘ˆ1,ğ‘ˆ2,â€¦,ğ‘ˆğ‘š be mutually disjoint sets, and let C be a collection of m-tuples from their cartesian product ğ‘ˆ1Ã—â‹¯Ã—ğ‘ˆğ‘š. An m-dimensional k-matching in C is a subcollection of k m-tuples such that no two of these m-tuples share a common coordinate. Koutis and Williams [22] obtain a faster parameterized algorithm for the decision version of this problem. We present an exact counting algorithm as an application of Theorem 1.8.

Corollary 4.3
Given mutually disjoint sets ğ‘ˆğ‘–, ğ‘–âˆˆ[ğ‘š], and a collection C of m-tuples from ğ‘ˆ1Ã—â‹¯Ã—ğ‘ˆğ‘š , we can count the number of m-dimensional k-matchings in C in deterministic ğ‘‚âˆ—((ğ‘›â†“(ğ‘šâˆ’1)ğ‘˜/2)) time.

Proof
Following [22], encode each element u in ğ‘ˆ=âˆªğ‘šğ‘–=2ğ‘ˆğ‘– by a variable ğ‘¥ğ‘¢âˆˆğ‘‹. Encode each m-tuple ğ‘¡=(ğ‘¢1,â€¦,ğ‘¢ğ‘š)âˆˆğ¶âŠ†ğ‘ˆ1Ã—â‹¯Ã—ğ‘ˆğ‘š by the monomial ğ‘€ğ‘¡=âˆğ‘šğ‘–=2ğ‘¥ğ‘¢ğ‘–. Assume ğ‘ˆ1={ğ‘¢1,1,â€¦,ğ‘¢1,ğ‘›}, and let ğ‘‡ğ‘—âŠ†ğ¶ denote the subset of m-tuples whose first coordinate is ğ‘¢1,ğ‘—. Consider the polynomial,

ğ‘ƒ(ğ‘‹,ğ‘§)=âˆğ‘—=1ğ‘›â›ââœâœ1+âˆ‘ğ‘¡âˆˆğ‘‡ğ‘—(ğ‘§â‹…ğ‘€ğ‘¡)ââ âŸâŸ
Clearly, P(X, z) has an ABP of size poly(ğ‘›,ğ‘š,|ğ¶|). Let ğ‘„(ğ‘‹)=[ğ‘§ğ‘˜]ğ‘ƒ(ğ‘‹,ğ‘§). In polynomial time we can obtain an ABP of size poly(ğ‘›,ğ‘š,|ğ¶|) for Q(X) by standard method of Vandermonde matrix based interpolation on the variable z. Clearly, Q(X) is a homogeneous degree-km polynomial and the nonzero multilinear monomials of Q(X) are in 1âˆ’1 correspondence with the m-dimensional k-matchings in C. Therefore, the number of multilinear terms in Q(X) is the required count. We can now apply the first part of Theorem 1.8 to count the number of multilinear terms in Q(X).

â—»

Hardness of the Rectangular Permanent Over General Rings
In [8], it is shown that the ğ‘˜Ã—ğ‘› rectangular permanent can be evaluated over commutative rings and commutative semirings in ğ‘‚(â„(ğ‘˜)â‹…poly(ğ‘›,ğ‘˜)) time for some computable function h. In other words, the problem is in FPT, parameterized by the number of rows. An interesting question is to ask whether one can get any FPT algorithm when the entries are from noncommutative rings (in particular, matrix rings). We prove that such an algorithm is unlikely to exist. We show that counting the number of k-paths in a graph G, a well-known #W[1]-complete problem, reduces to this problem. So, unless ETH fails we do not have such an algorithm [16].

Theorem 4.4
Given a ğ‘˜Ã—ğ‘› matrix X with entries ğ‘¥ğ‘–ğ‘—âˆˆğ•„ğ‘¡Ã—ğ‘¡(â„š), computing the rectangular permanent of X is #W[1]-hard with k as the parameter where ğ‘¡=(ğ‘˜+1)ğ‘› under polynomial-time many-one reduction.

Proof
If we have an algorithm to compute the permanent of a ğ‘˜Ã—ğ‘› matrix over noncommutative rings which is FPT in parameter k, that yields an algorithm which is FPT in k for evaluating the polynomial ğ‘†âˆ—ğ‘›,ğ‘˜ on matrix inputs. This follows from Observation 3.1. Now, given a graph G we can compute a homogeneous ABP of width n and k layers for the graph polynomial ğ¶ğº defined as follows.

Let G(V, E) be a directed graph with n vertices where ğ‘‰(ğº)={ğ‘£1,ğ‘£2,â€¦,ğ‘£ğ‘›}. A k-walk is a sequence of k vertices ğ‘£ğ‘–1,ğ‘£ğ‘–2,â€¦,ğ‘£ğ‘–ğ‘˜ where (ğ‘£ğ‘–ğ‘—,ğ‘£ğ‘–ğ‘—+1)âˆˆğ¸ for each 1â‰¤ğ‘—â‰¤ğ‘˜âˆ’1. A k-path is a k-walk where no vertex is repeated. Let A be the adjacency matrix of G, and let ğ‘¦1,ğ‘¦2,â€¦,ğ‘¦ğ‘› be noncommuting variables. Define an ğ‘›Ã—ğ‘› matrix B

ğµ[ğ‘–,ğ‘—]=ğ´[ğ‘–,ğ‘—]â‹…ğ‘¦ğ‘–,  1â‰¤ğ‘–,ğ‘—â‰¤ğ‘›.
Let 1âƒ—  denote the all 1â€™s vector of length n. Let ğ‘¦âƒ—  be the length n vector defined by ğ‘¦âƒ— [ğ‘–]=ğ‘¦ğ‘–. The graph polynomial ğ¶ğºâˆˆğ”½âŸ¨ğ‘ŒâŸ© is defined as

ğ¶ğº(ğ‘Œ)=1âƒ— ğ‘‡â‹…ğµğ‘˜âˆ’1â‹…ğ‘¦âƒ— .
Let W be the set of all k-walks in G. The following observation is folklore. â—»

Observation 4.5
ğ¶ğº(ğ‘Œ)=âˆ‘ğ‘£ğ‘–1ğ‘£ğ‘–2â€¦ğ‘£ğ‘–ğ‘˜âˆˆğ‘Šğ‘¦ğ‘–1ğ‘¦ğ‘–2â‹¯ğ‘¦ğ‘–ğ‘˜.
Hence, G contains a k-path if and only if the graph polynomial ğ¶ğº contains a multilinear term.

Clearly the number of k-paths in G is equal to (ğ¶ğºâˆ˜ğ‘†ğ‘›,ğ‘˜)(1âƒ— ). By Lemma 2.4, we know that it suffices to compute (ğ¶Ë†ğºâˆ˜ğ‘†âˆ—ğ‘›,ğ‘˜)(1âƒ— ). We construct ğ‘˜ğ‘›Ã—ğ‘˜ğ‘› matrices ğ´1,â€¦,ğ´ğ‘› from the ABP of ğ¶Ë†ğº following Lemma 3.2. Then from Lemma 3.2, we know that (ğ¶Ë†ğºâˆ˜ğ‘†âˆ—ğ‘›,ğ‘˜)(1âƒ— )=ğ‘†âˆ—ğ‘›,ğ‘˜(ğ´1,â€¦,ğ´ğ‘›)(1,ğ‘¡) where ğ‘¡=(ğ‘˜+1)ğ‘›. So if we have an algorithm which is FPT in k for evaluating ğ‘†âˆ—ğ‘›,ğ‘˜ over matrix inputs, we also get an algorithm to count the number of k-paths in G in FPT(k) time. â—»

Multilinear Monomial Detection
In this section, we prove Theorem 1.9. First, we give an algorithm for computing the Hadamard product for a special case in the commutative setting. Any depth two Î [ğ‘˜]Î£ circuit computes the product of k homogeneous linear forms over the input set of variables X.

Lemma 5.1
Given an arithmetic circuit C of size s computing ğ‘”âˆˆğ”½[ğ‘‹], and a homogeneous Î [ğ‘˜]Î£ circuit computing ğ‘“âˆˆğ”½[ğ‘‹], and any point ğ‘âƒ— âˆˆğ”½ğ‘›, we can evaluate (ğ‘“âˆ˜ s ğ‘”)(ğ‘âƒ— ) in ğ‘‚âˆ—(2ğ‘˜) time and in polynomial space.

Proof
By standard homogenization technique [33, Theorem 2.2] we can extract the homogeneous degree-k component of C and thus we can assume that C computes a homogeneous degree-k polynomial. Write ğ‘“=âˆğ‘˜ğ‘—=1ğ¿ğ‘—, for homogeneous linear forms ğ¿ğ‘—. The corresponding noncommutative polynomial ğ‘“Ì‚  is defined by the natural order of the j indices (and replacing ğ‘¥ğ‘– by ğ‘¦ğ‘– for each i). â—»

Claim 5.2
The noncommutative polynomial ğ‘“âˆ— has a (noncommutative) Î£[2ğ‘˜]Î [ğ‘˜]Î£ circuit, which we can write as ğ‘“âˆ—=âˆ‘2ğ‘˜ğ‘–=1ğ¶ğ‘–, where each ğ¶ğ‘– is a (noncommutative) Î [ğ‘˜]Î£ circuit.

Before we prove the claim, we show that it easily yields the desired algorithm. First we notice that

ğ¶Ë†âˆ˜ğ‘“âˆ—=âˆ‘ğ‘–=12ğ‘˜ğ¶Ë†âˆ˜ğ¶ğ‘–.
Now, by Theorem 1.4, we can compute in poly(ğ‘›,ğ‘ ,ğ‘˜) time a poly(ğ‘›,ğ‘ ,ğ‘˜) size circuit for the (noncommutative) Hadamard product ğ¶Ë†âˆ˜ğ¶ğ‘–. As argued in the proof of Lemma 2.4, for any ğ‘âƒ— âˆˆğ”½ğ‘› we have

(ğ‘”âˆ˜ s ğ‘“)(ğ‘âƒ— )=(ğ¶âˆ˜ s ğ‘“)(ğ‘âƒ— )=(ğ¶Ë†âˆ˜ğ‘“âˆ—)(ğ‘âƒ— ).
Thus, we can evaluate (ğ‘”âˆ˜ s ğ‘“)(ğ‘âƒ— ) by incrementally computing (ğ¶Ë†âˆ˜ğ¶ğ‘–)(ğ‘âƒ— ) and adding up for 1â‰¤ğ‘–â‰¤2ğ‘˜. This can be clearly implemented using only polynomial space. â—»

Proof of Claim 5.2
By definition,

ğ‘“âˆ—=âˆ‘ğœâˆˆğ‘†ğ‘˜ğ¿Ì‚ ğœ(1)ğ¿Ì‚ ğœ(2)â‹¯ğ¿Ì‚ ğœ(ğ‘˜).
Now define the ğ‘˜Ã—ğ‘˜ matrix T such that the elements in each row of T are the linear forms ğ¿Ì‚ 1,ğ¿Ì‚ 2,â€¦,ğ¿Ì‚ ğ‘˜ in this order. Then the (noncommutative) permanent of T is given by

Perm(ğ‘‡)=âˆ‘ğœâˆˆğ‘†ğ‘˜âˆğ‘—=1ğ‘˜ğ¿Ì‚ ğœ(ğ‘—)
which is just ğ‘“âˆ—.

We will now apply Ryserâ€™s formula [30] to express Perm(ğ‘‡) as a depth-3 homogeneous noncommutative Î£[2ğ‘˜]Î [ğ‘˜]Î£ formula. We recall Ryserâ€™s formula [30] for Per(ğ´), where A is a ğ‘˜Ã—ğ‘˜ matrix with noncommuting entries ğ´ğ‘–ğ‘—:

Per(ğ´)=âˆ‘ğ‘†âŠ†[ğ‘˜](âˆ’1)|ğ‘†|âˆğ‘–=1ğ‘˜âˆ‘ğ‘—âˆˆğ‘†ğ´ğ‘–ğ‘—.
It is a Î£[2ğ‘˜]Î [ğ‘˜]Î£ formula for the ğ‘˜Ã—ğ‘˜ noncommutative permanent. Now, substituting ğ¿Ì‚ ğ‘— for ğ´ğ‘–ğ‘— 1â‰¤ğ‘–,ğ‘—â‰¤ğ‘˜, it follows that ğ‘“âˆ—=Per(ğ‘‡) has a Î£[2ğ‘˜]Î [ğ‘˜]Î£ noncommutative formula. Note that Ryserâ€™s formula is usually given for the commutative permanent. It is easy to observe that the same proof, based on the principle of inclusion-exclusion, also holds for the noncommutative permanent. â—»

Remark 5.3
Over the rationals, we can get an alternative proof of Lemma 5.1 by using Fischerâ€™s identity [17] to obtain a Î£[2ğ‘˜]Î [ğ‘˜]Î£ formula for ğ‘“âˆ—.

Now we are ready to prove Theorem 1.9.

Proof
By homogenization, we can assume that C computes a homogeneous degree k polynomial f.

We will refer to maps ğœ:[ğ‘›]â†’[ğ‘˜] as coloring maps. The map ğœ can be seen as assigning colorsFootnote4 to the elements of [n]: ğœ(ğ‘–) is the color of i.

We will pick a collection of coloring maps {ğœğ‘–:[ğ‘›]â†’[ğ‘˜]} each picked independently and uniformly at random. For each coloring map ğœğ‘– we define a Î [ğ‘˜]Î£ formula

ğ‘ƒğ‘–=âˆğ‘—=1ğ‘˜âˆ‘â„“:ğœğ‘–(â„“)=ğ‘—ğ‘¥â„“.
A monomial is covered by a coloring map ğœğ‘– if the monomial is nonzero in ğ‘ƒğ‘–. The probability that a random coloring map covers a given degree-k multilinear monomial is

ğ‘˜!â‹…ğ‘˜âˆ’ğ‘˜â‰ˆğ‘’âˆ’ğ‘˜.
Hence, for a collection îˆ¯ of ğ‘‚âˆ—(ğ‘’ğ‘˜) many coloring maps îˆ¯={ğœğ‘–:[ğ‘›]â†’[ğ‘˜]} picked independently and uniformly at random, it holds with constant probability that every multilinear monomial of degree k is covered at least once by some ğœğ‘– in îˆ¯. This probability bound is by a simple and standard union bound argument. Now, for each coloring map ğœğ‘–âˆˆîˆ¯ we consider the circuit ğ¶â€²ğ‘–=ğ¶âˆ˜ s ğ‘ƒğ‘–.

Notice that for each multilinear monomial m, the multiplicative factor m! is 1. Also, the coefficient of each monomial is exactly 1 in each ğ‘ƒğ‘–, and if f contains a multilinear term then it is covered by some ğ‘ƒğ‘–. Now, we perform the randomized polynomial identity test on each circuit ğ¶â€²ğ‘– by applying the Demillo-Lipton-Schwartz-Zippel Lemma [15, 32, 42] in randomized polynomial time to complete the procedure. More precisely, we pick a random ğ‘âƒ— âˆˆğ”½ğ‘› and evaluate ğ¶â€²ğ‘– at ğ‘âƒ—  to check if it is nonzero. By Lemma 5.1, the computation of ğ¶â€²ğ‘–(ğ‘âƒ— ) can be done deterministically in time ğ‘‚âˆ—(2ğ‘˜) time and poly(ğ‘›,ğ‘˜) space.Footnote5 Hence the total running time of the procedure is ğ‘‚âˆ—((2ğ‘’)ğ‘˜).

In order to improve the running time to ğ‘‚âˆ—(4.32ğ‘˜), we apply the color coding technique of HÃ¼ffner et al. [20]. The idea is to use more than k colors to reduce the number of coloring maps required to cover the degree-k monomials. But this would increase the formal degree of each depth two circuit which we need to handle.

We will use 1.3k colorsFootnote6 and each circuit ğ‘ƒğ‘– will now be a Î [1.3ğ‘˜]Î£ circuit. For each coloring map ğœğ‘–:[ğ‘›]â†’[1.3ğ‘˜] chosen uniformly at random, we define the following Î [1.3ğ‘˜]Î£ circuit

ğ‘ƒğ‘–(ğ‘¥1,ğ‘¥2,â€¦,ğ‘¥ğ‘›,ğ‘§1,â€¦,ğ‘§1.3ğ‘˜)=âˆğ‘—=11.3ğ‘˜(âˆ‘â„“:ğœğ‘–(â„“)=ğ‘—ğ‘¥â„“+ğ‘§ğ‘—).
Since each ğ‘ƒğ‘– is of degree 1.3k, we need to modify the circuit C to another circuit ğ¶â€² of degree 1.3k in order to apply Hadamard products. To that end, we define the circuit ğ¶â€²âˆˆğ”½[ğ‘‹,ğ‘] as follows

ğ¶â€²(ğ‘‹,ğ‘)=ğ¶(ğ‘‹)â‹…ğ‘†1.3ğ‘˜,0.3ğ‘˜(ğ‘§1,â€¦,ğ‘§1.3ğ‘˜),
where ğ‘†1.3ğ‘˜,0.3ğ‘˜(ğ‘§1,â€¦,ğ‘§1.3ğ‘˜) is the elementary symmetric polynomial of degree 0.3k over the variables ğ‘§1,â€¦,ğ‘§1.3ğ‘˜. By the result of [20], for ğ‘‚âˆ—(1.752ğ‘˜) random coloring maps, with high probability each multilinear monomial in C is covered by the monomials of some ğ‘ƒğ‘– (over the X variables).

Now to compute ğ¶â€²Ë†âˆ˜ğ‘ƒâˆ—ğ‘– for each i, we symmetrize the polynomial ğ‘ƒğ‘–. Of course, the symmetrization happens over the X variables as well as over the Z variables. But in ğ¶â€²Ë† we are only interested in the monomials (or words) where the rightmost 0.3k variables are over Z variables. In the noncommutative circuit ğ¶â€²Ë†, every subword ğ‘§ğ‘–1ğ‘§ğ‘–2â€¦ğ‘§ğ‘–0.3ğ‘˜ receives a natural ordering ğ‘–1<ğ‘–2<â€¦<ğ‘–0.3ğ‘˜.

Notice that

ğ‘ƒâˆ—ğ‘–(ğ‘Œ,ğ‘)=âˆ‘ğœâˆˆğ‘†1.3ğ‘˜âˆğ‘—=11.3ğ‘˜(âˆ‘â„“:ğœğ‘–(â„“)=ğœ(ğ‘—)ğ‘¦â„“+ğ‘§ğœ(ğ‘—)).
Our goal is to understand the part of ğ‘ƒâˆ—ğ‘–(ğ‘Œ,ğ‘) where each monomial ends with a subword of the form ğ‘§ğ‘–1ğ‘§ğ‘–2â€¦ğ‘§ğ‘–0.3ğ‘˜ and the top k symbols are over the X variables. For a fixed set of indices ğ‘Š={ğ‘–1<ğ‘–2<â€¦<ğ‘–0.3ğ‘˜}, define the set ğ‘‡=[1.3ğ‘˜]âˆ–ğ‘Š. Let ğ‘†[ğ‘˜],ğ‘‡ be the set of permutations ğœâˆˆğ‘†1.3ğ‘˜ such that ğœ:[ğ‘˜]â†’ğ‘‡ and ğœ(ğ‘˜+ğ‘—)=ğ‘–ğ‘— for 1â‰¤ğ‘—â‰¤0.3ğ‘˜. As we have fixed the last 0.3k positions, each ğœâˆˆğ‘†[ğ‘˜],ğ‘‡ corresponds to some ğœâ€²âˆˆğ‘†ğ‘˜. Let ğ‘ğ‘Š=ğ‘§ğ‘–1ğ‘§ğ‘–2â€¦ğ‘§ğ‘–0.3ğ‘˜. Now we notice the following. â—»

Observation 5.4
The part of ğ‘ƒâˆ—ğ‘–(ğ‘Œ,ğ‘) where each monomial ends with the subword ğ‘ğ‘Š is ğ‘ƒâˆ—ğ‘–,ğ‘Šâ‹…ğ‘ğ‘Š, where

ğ‘ƒâˆ—ğ‘–,ğ‘Š(ğ‘Œ)=âˆ‘ğœâˆˆğ‘†[ğ‘˜],ğ‘‡âˆğ‘—=1ğ‘˜(âˆ‘â„“:ğœğ‘–(â„“)=ğœ(ğ‘—)ğ‘¦â„“)=âˆ‘ğœâ€²âˆˆğ‘†ğ‘˜âˆğ‘—=1ğ‘˜â›ââœâœâˆ‘â„“:ğœğ‘–(â„“)=ğœâ€²(ğ‘—)ğ‘¦â„“ââ âŸâŸ.
Now, just like the case above, it suffices to perform polynomial identity testing for

(ğ¶â€²Ë†âˆ˜ğ‘ƒâˆ—ğ‘–)(ğ‘Œ,ğ‘)=âˆ‘ğ‘ŠâŠ†[1.3ğ‘˜]:|ğ‘Š|=0.3ğ‘˜(ğ¶Ë†(ğ‘Œ)âˆ˜ğ‘ƒâˆ—ğ‘–,ğ‘Š(ğ‘Œ))â‹…ğ‘ğ‘Š.
for each i. But this is same as testing ğ¶â€²âˆ˜ s ğ‘ƒğ‘– for identity. Now we eliminate the Z variables by substituting 1 and evaluate X variables on a random point ğ‘âƒ— âˆˆğ”½ğ‘›. By Lemma 5.1, (ğ¶â€²âˆ˜ s ğ‘ƒğ‘–)(ğ‘âƒ— ,1âƒ— ) can be computed in ğ‘‚âˆ—(21.3ğ‘˜)=ğ‘‚âˆ—(2.46ğ‘˜) time and poly(ğ‘›,ğ‘˜) space. The bound on the success probability follows from Demillo-Lipton-Schwartz-Zippel Lemma [15, 32, 42].

We repeat the above procedure for each coloring map and obtain a randomized ğ‘‚âˆ—(4.32ğ‘˜) algorithm. This completes the proof of Theorem 1.9. â—»

Deterministic Algorithms for Depth Three Circuits
In this section we obtain fast deterministic algorithms for (k,n)âˆ’MLC and kâˆ’MMD for depth-three arithmetic circuits. These are obtained by a simple application of Hadamard product combined with symmetrization. We will require the following.

Theorem 6.1
[4, Theorem 4] Let A and B be noncommutative ABPs of sizes ğ‘ 1 and ğ‘ 2, computing homogeneous degree-k polynomials ğ‘“1,ğ‘“2âˆˆğ”½âŸ¨ğ‘ŒâŸ©, respectively. Then, we can compute an ABP of size ğ‘‚(ğ‘ 1ğ‘ 2) for the Hadamard product ğ‘“1âˆ˜ğ‘“2 in deterministic poly(ğ‘ 1,ğ‘ 2) time. Furthermore, if A and B are Î [ğ‘˜]Î£ circuits, then we can compute a Î [ğ‘˜]Î£ circuit for ğ‘“1âˆ˜ğ‘“2 in poly(ğ‘ 1,ğ‘ 2) time.

We now prove Theorem 1.10.

Proof
Let C be the given Î£[ğ‘ â€²]Î [ğ‘˜]Î£ circuit computing the polynomial ğ‘“âˆˆğ”½[ğ‘‹]. We first consider the kâˆ’MMD problem.

Suppose the coefficients are integers (without loss of generality, if we assume the underlying field is rationals). Let ğ¶=âˆ‘ğ‘ â€²ğ‘–=1ğ¶ğ‘– where each ğ¶ğ‘– is a Î [ğ‘˜]Î£ circuit. We obtain a circuit for ğ¶âˆ˜ s ğ¶(ğ‘‹) as follows. By Corollary 2.5, it suffices to obtain a circuit for ğ¶Ë†âˆ˜ğ¶âˆ—(ğ‘Œ). Notice that ğ¶âˆ—=âˆ‘ğ‘ â€²ğ‘–=1ğ¶âˆ—ğ‘– and by Claim 5.2 we know that each ğ¶âˆ—ğ‘– is a Î£[2ğ‘˜]Î [ğ‘˜]Î£ circuit which can be computed in ğ‘‚âˆ—(2ğ‘˜) time. By distributivity, the problem of computing ğ¶Ë†âˆ˜ğ¶âˆ—(ğ‘Œ) reduces to computing the noncommutative Hadamard product of ğ‘ â€²â‹…2ğ‘˜ many pairs of depth-two Î [ğ‘˜]Î£ circuits. By Theorem 6.1, each such Hadamard product can be computed in poly(ğ‘›,ğ‘˜) time. Hence, we obtain a depth three commutative Î£[ğ‘ â€²â‹…2ğ‘˜]Î [ğ‘˜]Î£ circuit ğ¶Ìƒ  for ğ¶âˆ˜ s ğ¶(ğ‘‹) in ğ‘‚âˆ—(2ğ‘˜) time. Note that m is a nonzero monomial in C if and only if [ğ‘š]ğ¶Ìƒ >0.

Let B be the poly(ğ‘›,ğ‘˜) size ABP for ğ‘†ğ‘›,ğ‘˜. Now the idea is to compute ğ¶Ìƒ âˆ˜ s ğµ(1âƒ— ), and if it is nonzero, we know that C contains a degree-k multilinear term. Again this reduces to computing ğ‘ â€²â‹…2ğ‘˜ scaled Hadamard products, each of the form Î [ğ‘˜]Î£âˆ˜ s ğµ(1âƒ— ). By Lemma 5.1, each such computation can be done in ğ‘‚âˆ—(2ğ‘˜) time incurring a overall running time ğ‘‚âˆ—(4ğ‘˜).

In the case of finite fields, the above proof does not work since ğ¶Ìƒ âˆ˜ s ğµ(1âƒ— ) could be zero modulo the characteristic.The idea is similar to the proof of Theorem 1.9. But instead of random coloring maps we pick ğœğ‘–:[ğ‘›]â†’[ğ‘˜] from the explicit (n, k)-family perfect hash functions constructed in [25], which is of size ğ‘’ğ‘˜ğ‘˜ğ‘‚(logğ‘˜)logğ‘›, and define a Î [ğ‘˜]Î£ formula

ğ‘ƒğ‘–=âˆğ‘—=1ğ‘˜âˆ‘â„“:ğœğ‘–(â„“)=ğ‘—ğ‘¥â„“
for each coloring map ğœğ‘–. Now for each i, we construct the circuit ğ¶â€²ğ‘–=ğ¶âˆ˜ s ğ‘ƒğ‘–. As already explained each ğ¶â€²ğ‘–(ğ‘‹) is a Î£[ğ‘ â€²â‹…2ğ‘˜]Î [ğ‘˜]Î£ circuit and it can be obtained in deterministic ğ‘‚âˆ—(2ğ‘˜) time. Clearly, if C contains a multilinear monomial, we can detect it by doing identity testing of each ğ¶â€²ğ‘–. Now we apply a result of Saxena [31] where he shows that the identity testing of a Î£Î [ğ‘˜]Î£ circuit over finite fields can be done in deterministic ğ‘‚âˆ—(2ğ‘ğ‘˜) time where the constant ğ‘â‰¤5. The final running time is ğ‘’ğ‘˜ğ‘˜ğ‘‚(logğ‘˜)ğ‘‚âˆ—(2ğ‘ğ‘˜+2ğ‘˜).

As a by-product of the above technique, we get a fast deterministic algorithm to compute the sum of the coefficients of degree-k multilinear monomials in a depth there circuit, solving the (k,n)âˆ’MLC problem. Notice that, we need to compute ğ¶âˆ˜ s ğµ(1âƒ— ). As already explained, it can be obtained in deterministic ğ‘‚âˆ—(2ğ‘˜) time.

â—»

Remark 6.2
The main result of [31, Theorem 1] is actually a polynomial identity testing algorithm for a larger class of circuits. It also uses the identity testing algorithm for noncommutative ABPs [29]. Indeed, the bound ğ‘â‰¤5 is from [29, Theorem 4].

Discussion
In conclusion, we broadly compare the Hadamard product used in this paper with the apolar inner product used in the work of Pratt and others [10, 27, 28].

Recall, given two commutative homogeneous degree d polynomials f and g in ğ”½[X], the apolar inner product âŸ¨ğ‘“,ğ‘”âŸ© is defined as follows.

âŸ¨ğ‘“,ğ‘”âŸ©=ğ‘“(âˆ‚âˆ‚ğ‘¥1,â€¦,âˆ‚âˆ‚ğ‘¥ğ‘›)ğ‘”=âˆ‘ğ‘šğ‘š![ğ‘š]ğ‘“â‹…[ğ‘š]ğ‘”,
where the sum is over all degree-d monomials ğ‘š=ğ‘¥ğ‘’11ğ‘¥ğ‘’22â€¦ğ‘¥ğ‘’ğ‘›ğ‘›âˆˆğ‘‹ğ‘‘.

The Waring rank of a homogeneous degree-d polynomial ğ‘“âˆˆğ”½[ğ‘‹] is the least r such that ğ‘“=âˆ‘ğ‘Ÿğ‘—=1ğ›¼ğ‘—â‹…ğ¿ğ‘‘ğ‘—, where for each j, ğ›¼ğ‘—âˆˆğ”½ and ğ¿ğ‘— is a homogeneous linear form. If f has Waring rank r and g is given by an arithmetic circuit Pratt [27, 28] has shown that the apolar inner product of f and g can be computed in ğ‘‚âˆ—(ğ‘Ÿ) time. Hence, using the Waring decomposition of the elementary symmetric polynomials (over the field of rationals) [23] yields faster algorithms [28] for kâˆ’MMD and (k,n)âˆ’MLC: ğ‘‚âˆ—(4.08ğ‘˜)-time for kâˆ’MMD and ğ‘‚âˆ—(ğ‘›ğ‘˜/2)-time for (k,n)âˆ’MLC) over the field of rationals.

However, the Waring decomposition does not appear to have a finite field analogue. For example, over ğ”½2 the polynomial xy has no Waring decomposition. In comparison, our algorithms are essentially oblivious to the underlying field.

More recently, Brand and Pratt [10] have shown that the apolar inner product of commutative polynomials f and g can be computed in ğ‘‚âˆ—(ğ‘Ÿ) time if the partial derivative space of f has rank r. This strengthens Prattâ€™s result [28] as the Waring rank of f is an upper bound on its partial derivative rank.

It is interesting to compare this with the Hadamard product based approach of our paper. We first note that the apolar inner product of polynomials ğ‘“,ğ‘”âˆˆğ”½[ğ‘‹] can be computed by first computing their scaled Hadamard product (see Sect. 2) and evaluating the resulting polynomial at ğ‘¥ğ‘–=1 for each ğ‘–âˆˆ[ğ‘›]. Furthermore, the computation of Hadamard product of f and g can be done efficiently, as shown in Lemma 2.4 (Sect. 2), in time polynomial in the noncommutative algebra branching program complexity ğ‘(ğ‘“âˆ—) (i.e. the minimum size of the ABP computing ğ‘“âˆ—) of the noncommutative polynomial ğ‘“âˆ—. The partial derivative space rank of f essentially coincides with ğ‘(ğ‘“âˆ—):

Fact 7.1
For any commutative polynomial f, the ABP complexity ğ‘(ğ‘“âˆ—) of ğ‘“âˆ— is the dimension of the space of partial derivatives of f.

Proof
Let ğ‘“âˆˆğ”½[ğ‘‹] be a homogeneous degree-k commutative polynomial, where ğ‘‹={ğ‘¥1,ğ‘¥2,â€¦,ğ‘¥ğ‘›} is a set of commuting variables. Let ğ‘Œ={ğ‘¦1,ğ‘¦2,â€¦,ğ‘¦ğ‘›} be a corresponding set of free noncommuting variables.

Recall that Nisan [26] has shown that the ABP complexity b(g) of a noncommutative polynomial ğ‘”âˆˆğ”½âŸ¨ğ‘ŒâŸ© of degree k is exactly âˆ‘ğ‘˜â„“=1rank(ğ‘€â„“(ğ‘”)) where the matrix ğ‘€â„“(ğ‘”) is defined as follows. The rows of ğ‘€â„“(ğ‘”) are indexed by words in ğ‘Œâ„“ and the columns of ğ‘€â„“(ğ‘”) are indexed by words in ğ‘Œğ‘˜âˆ’â„“. For some ğ‘¤1âˆˆğ‘Œâ„“ and ğ‘¤2âˆˆğ‘Œğ‘˜âˆ’â„“, the (ğ‘¤1,ğ‘¤2)ğ‘¡â„ entry of ğ‘€â„“(ğ‘”) is [ğ‘¤1ğ‘¤2]ğ‘”.

We now consider the matrix ğ‘€â„“(ğ‘“âˆ—) for the noncommutative polynomial ğ‘“âˆ—âˆˆğ”½âŸ¨ğ‘ŒâŸ©. Let ğ‘¤1âˆˆğ‘Œâ„“ and ğ‘¤2âˆˆğ‘Œğ‘˜âˆ’â„“. Let ğœâˆˆğ‘†â„“ and ğœâˆˆğ‘†ğ‘˜âˆ’â„“ be any permutations. By definition of ğ‘“âˆ—, it is clear that

ğ‘€â„“(ğ‘“âˆ—)(ğ‘¤1,ğ‘¤2)=ğ‘€â„“(ğ‘“âˆ—)(ğ‘¤ğœ1,ğ‘¤ğœ2).
In particular, the row of ğ‘€â„“(ğ‘“âˆ—) indexed by ğ‘¤1 is identical to the row indexed by ğ‘¤ğœ1.

Furthermore, the row of ğ‘€â„“(ğ‘“âˆ—) indexed by ğ‘¤1 has the following structure for any ğ‘¤1âˆˆğ‘Œâ„“: the ğ‘¤2-th entry of this row is the same as the ğ‘¤ğœ2-th entry of this row.

Now consider the partial derivative matrix of f, ğ‘€Ìƒ â„“(ğ‘“) defined as follows. The rows of ğ‘€Ìƒ â„“(ğ‘“) are indexed by commuting degree-â„“ monomials in Xâ„“. For some ğ‘šâˆˆXâ„“, the corresponding row is the coefficient vector of âˆ‚ğ‘“âˆ‚ğ‘š.

It follows from the above considerations that a subset of rows of ğ‘€Ìƒ â„“(ğ‘“) labeled by monomials ğ‘š1,ğ‘š2,â€¦,ğ‘šğ‘Ÿ are linearly independent iff for noncommuting monomials ğ‘¤1,ğ‘¤2,â€¦,ğ‘¤ğ‘Ÿ, such that ğ‘¤ğ‘–â†’ğ‘šğ‘–, the rows of row of ğ‘€â„“(ğ‘“âˆ—) indexed by the ğ‘¤ğ‘– are linearly independent.

Therefore, rank(ğ‘€â„“(ğ‘“âˆ—))=rank(ğ‘€Ìƒ â„“(ğ‘“)), which completes the proof. â—»

We conclude with the following arithmetic circuit complexity question, a positive answer to which would have interesting algorithmic implications: Is there a polynomial f over the rationals that is positively weakly equivalentFootnote7 to the elementary symmetric polynomial ğ‘†ğ‘›,ğ‘˜ such that the ABP complexity ğ‘(ğ‘“âˆ—) is ğ‘‚âˆ—(2ğ‘˜)? It would even suffice to show that ğ‘“âˆ— has arithmetic circuits of size ğ‘‚âˆ—(2ğ‘˜) to improve on the current best deterministic algorithm for the k-path problem.