In this paper we study regular expression matching in cases in which the identity of the symbols received is subject to uncertainty. We develop a model of symbol emission and uses a modification of the shortest path algorithm to find optimal matches on the Cartesian Graph of an expression provided that the input is a finite list. In the case of infinite streams, we show that the problem is in general undecidable but, if each symbols is received with probability 0 infinitely often, then with probability 1 the problem is decidable.

Introduction
Regular expressions are a useful and compact formalism to express regular languages, and are frequently used in text-based application such as text retrieval, query languages or computational genetics. Approximate string matching is one of the classical problems in this area [1]. Given a text of length n, a pattern of length m and a number k of errors allowed, we want to find all the sub-strings in the text that match the pattern with at most k errors. If the text is not known in advance (viz., if the algorithm must work on-line, without pre-processing the text), then dynamic programming can provide a solution of complexity O(mn) [18, 26], while improved algorithms can run in O(kn) [10, 31, 32].

Regular expressions can be used as pattern detectors in more general situations, such as activity detection [5]. In this context, the approximation problem takes a new form: the problem is not just matching despite the absence of expected symbols or the presence of spurious ones. The problem is that, in many applications, the identity of the symbols received is uncertain, and known only probabilistically. That is, at each input position, rather than having a symbol drawn from an alphabet Σ, we have a probability distribution on Σ. The problem, in this case, is to find the most likely sequence of symbols that matches the expression.

In this paper, we present algorithms to solve this problem, and we study their properties, both for matching sub-strings of finite strings and of infinite streams.

Our matching model is in some measure related to Markov models used for sequence alignment, a technique quite common in bioinformatics [16]. In particular, our model bears some resemblance to Profile Hidden Markov Models (PHMM: Markov models with states representing symbol insertion and symbol deletion) for multiple alignments of sequences [8, 27]. In both PHMM and our algorithms. matching can be seen as traversing a maximal path with additive logarithmic weights. PHMM have been developed to align sequences with gaps and insertions; it should be in principle possible to extend them to matching regular expressions, but the derivation of a PHMM from an expression appears to be quite complex.

Weighted automata [7] have also been used for problems related to ours. As a matter of fact, the Cartesian graph, which we use in this paper, can be seen as an equivalent formalism and as an implementation of matching using weighted automata. Graphs provide a more direct implementation and a simple instrument for studying the properties of the methods.

Early work on infinite streams has generally focused on the recognition of the whole infinite sequence (𝜔-word): an 𝜔-word is accepted ih the automaton can read it while going through a sequence of states in which some final state occurs infinitely often (Büchi acceptance, [28, 29]), an approach that has been extended to infinite trees [21, 22]. The problem that we are considering here is different in that we are trying to match finite sub-words of an infinite word. This problem, without dealing with uncertainty, was considered in [25].

Matching with uncertain symbols—the problem that we are considering here—is gaining prominence in fields in which uncertainty in the data is the norm due to the imprecision of detection algorithms. The detection of complex audio or video events is an example. Some attempts at the definition of high-level languages for video events were made in the 1990s using temporal logic [6], Petri Nets [11] or semi-orders [2]; they had little impact at the time due to the relative immaturity of detection techniques and to the paucity of video data sets available.

With the progress of detection techniques and the availability of more data to train sophisticated classifiers, things have begun to change, and researchers "have started working on complex video event detection from videos taken from unconstrained environment (sic), where the video events consist of a long sequence of actions and interactions that lasts tens of seconds to several minutes" [17]. These new possibilities open up opportunities for video event detection but also new semantic problems [12, 19, 20].

In this new scenario, researchers have begun to explore complex event languages. Francois et al. [9] define complex events from simple ones using an event algebra with operations such as sequence, iteration, and alternation. In [15] and [23] stochastic context-free grammars are used, while in [13] event models are defined using case frames. As in other cases, these systems assume that different events are separated (no event is part of another one) and that their length is known, thus eschewing the length bias and the decidability problems that figure prominently in this paper.

In our model, we consider the alphabet symbols as elementary events that the system can recognize (we assume that there are a finite number of them) and whose detection is subject to uncertainty, so that the uncertainty of event detection translates to an uncertainty over which symbol is present in input. We assume that the information that we have can be represented as a stochastic observation process 𝜈, where 𝜈[𝑘](𝑎) is the probability that the alphabet symbol a were the kth symbol of the input sequence.

Within this general framework, we consider the following problems:

Finite estimation:
we consider a finite sequence of uncertain input symbols (that is, a finite stochastic process on Σ), called the observation. Assuming that at least one sub-string of the sequence matches the expression, which is the most likely matching sub-string given the observation?

Finite matching:
given a finite number of observations, what is the probability that at least one sub-string matches the expression?

Infinite estimation:
we show that, in general, estimation is undecidable in infinite stream. However, if for each symbol the probability of observing it is zero infinitely often, then with probability one estimation can be decided in finite time.

The paper is organized as follows. In Sect. 2 we remind a few facts about regular expression in order to establish the language and the basic facts that we shall use in the rest of the paper. In Sect. 3 we present a matching algorithm based on the Cartesian Graph; although this algorithm is equivalent to standard NFA algorithms, it provides a more convenient formalism to discuss the extension to uncertain data. In Sect. 4 we present our model of uncertainty, modeling it as the emission of an unobservable string on a noisy channel. Section 5 presents the algorithm for finite estimation, while in Sect. 6 we present the algorithm for finite matching. Section 7 proves the properties of matching algorithms on infinite streams, while Sect. 8 draws some conclusions.

Some facts about regular expressions
We present here a brief review of some relevant facts about regular expressions, limited to what we shall use in the remainder of the paper. The interested reader may find more detailed information in the many papers and texts on the subject [3, 14].

Let Σ be a finite set of symbol, which we call the alphabet. We shall denote with Σ∗ the set of finite sequences of symbols of Σ, including the empty string 𝜖. A word, or string on Σ is an element 𝑎0⋯𝑎𝐿−1∈Σ∗. We indicate with |𝜔| the number of symbols of the string 𝜔. String concatenation will be indicated by juxtaposition of symbols. Ranges of 𝜔 will be indicated using pairs of indices in square brackets, that is,

𝜔[𝑖:𝑗]=𝑎𝑖⋯𝑎𝑗−1  0≤𝑖≤𝑗≤|𝜔|,
(1)
with 𝜔[𝑖:𝑖]=𝜀 (the empty string). If a string is composed only of the (𝑖+1)th symbols of 𝜔 (viz., 𝑎𝑖), we shall use the notation 𝜔[𝑖] in lieu of 𝜔[𝑖:𝑖+1], and we shall use the notations 𝜔[:𝑗]=𝜔[0:𝑗] and 𝜔[𝑗:]=𝜔[𝑗:|𝜔|]; note that 𝜔[𝑖:𝑗]𝜔[𝑗:𝑘]=𝜔[𝑖:𝑘]. For the sake of consistency, we shall always use subscript to range over elements of Σ and square brackets to range over positions of a string: 𝜔[𝑘]=𝑎𝑖 means that the (𝑘+1)th element of 𝜔 is 𝑎𝑖∈Σ.

Syntactically, the regular expressions that we use in this paper are standard:

𝜙::=𝑎|𝜙𝜙|𝜙∗|𝜙+𝜙|(𝜙)|𝜀|𝜂
(2)
with 𝑎∈Σ. The symbol 𝜖 represents the expression that only generates the empty string, while the symbol 𝜂 is the expression that doesn’t generate any string. Given an expression 𝜙 its length |𝜙| is the number of symbols it contains.

Our semantics is derived from the standard semantics for 𝜔⊨𝜙 [14]. The language generated by 𝜙, 𝐿(𝜙) is defined as 𝐿(𝜙)={𝜔|𝜔∈Σ∗∧𝜔⊨𝜙}. Note that 𝐿(𝜖)={𝜀}, and 𝐿(𝜂)=∅. Two expressions are equivalent if they generate the same language. The recognition problem for regular expressions can be defined as follows: given an expression 𝜙 on an alphabet Σ and a string 𝜔∈Σ∗, is it the case that 𝜔∈𝐿(𝜙) (or, equivalently, that 𝜔⊨𝜙)? If the answer is yes, we say that 𝜙 recognizes 𝜔.

One important aspect of regular expressions is their connection with finite state automata.

Definition 1
A (nondeterministic) finite state automaton (NFA) is a 5-tuple =(𝑄,Σ,𝑞0,𝐹,𝛿) where Q is a finite set of states, Σ is the input alphabet, 𝑞0∈𝑄 is the initial state, 𝐹⊆𝑄 is the set of final states, and 𝛿⊆𝑄×(Σ∪{𝜀})×𝑄 is the state transition relation

In the following, we shall mostly restrict our attention to a class of NFA that we call simple. An NFA is simple if it doesn’t have multiple transitions between pairs of states, except possibly for the presence of 𝜖-transitions. That is, we never have a fragment of state diagram such as

	(3)
Formally we have:

Definition 2
A NFA =(𝑄,Σ,𝑞0,𝐹,𝛿) is simple if for all 𝑞,𝑞′∈𝑄 and all 𝑎,𝑎′∈Σ, 𝑎,𝑎′≠𝜖, if 𝛿(𝑞,𝑎,𝑞′) and 𝛿(𝑞,𝑎′,𝑞′) then 𝑎=𝑎′.

It is easy to transform an NFA into simple form: for each multiple arc from q to 𝑞′ and for each symbol a in that arc, one creates a new state 𝑞𝑎 connected to 𝑞′ with an 𝜖-transition and connects q to 𝑞𝑎 with an arc labeled a. That is, if 𝛿 contains a subset

𝛿′={𝛿(𝑞,𝑎1,𝑞′),…,𝛿(𝑞,𝑎𝑘,𝑞′)}
(4)
which violates the condition, this subset is eliminated from 𝛿 and replaced with

𝛿″={𝛿(𝑞,𝑎1,𝑞𝑎1),…,𝛿(𝑞,𝑎𝑘,𝑞𝑎𝑘),𝛿(𝑞𝑎1,𝜖,𝑞′),…,𝛿(𝑞𝑎𝑘,𝜖,𝑞′)}.
(5)
It is easy to see that the NFA with transitions (𝛿∖𝛿′)∪𝛿″ is simple and equivalent to the original one. Graphically, the process can be represented (for 𝑘=2) as

	(6)
Note that the most common algorithms for building an NFA given an expression 𝜙, such as Thompson’s [30] create simple automata.

Matching as path finding
The matching algorithm that we use in this paper is a modification of a method known as the Cartesian graph (also known as the DB-Graph) [24]. Let =(𝑄,Σ,𝑞0,𝐹,𝛿) be the (nondeterministic) automaton that recognizes a regular expression 𝜙, and let 𝜔=𝑎0⋯𝑎𝐿−1 be a finite string of length L. We build the Cartesian graph 𝐶(𝜙,𝜔)=(𝑉,𝐸) as follows:

(i)
V is the set of pairs (q, k) with 𝑞∈𝑄 and 𝑘∈[0,…,𝐿];

(ii)
(𝑢,𝑣)∈𝐸 if either:

(a)
𝑢=(𝑞,𝑘−1), 𝑣=(𝑞′,𝑘) and 𝛿(𝑞,𝑎𝑘−1,𝑞′), or

(b)
𝑢=(𝑞,𝑘), 𝑣=(𝑞′,𝑘) and there is an 𝜀-transition between q and 𝑞′, that is 𝛿(𝑞,𝜀,𝑞′).

In order to simplify the representation, in the figures we shall indicate the vertex (𝑞𝑖,𝑘) as 𝑞𝑘𝑖. Recognition using the graph is based on the following result:

Theorem 1
𝜔⊨𝜙 iff 𝐶(𝜙,𝜔) has a path (𝑞0,0)⟶∗(𝑞,𝐿) with 𝑞∈𝐹.

Proof
𝜔⊨𝜙 iff the automaton has an accepting run, that is, a sequence of states 𝑞0𝑞1⋯𝑞𝑛 such that 𝛿(𝑞𝑖−1,𝑎𝑖−1,𝑞𝑖) and 𝑞𝑛∈𝐹. It is immediate to see from the definition of the graph that such a run exists iff there is a path

(𝑞0,0)→⋯→(𝑞𝑛,𝐿)
(7)
in 𝐶(𝜙,𝜔) (𝐿≤𝑛)Footnote1. ◻

In many cases we shall be interested in determining whether there is a sub-string 𝜔[𝑖:𝑗] of 𝜔 that matches 𝜙. To this end, it is easy to verify the following result:

Corollary 1
𝜔[𝑖:𝑗]⊨𝜙 iff 𝐶(𝜙,𝜔) has a path (𝑞0,𝑖)⟶∗(𝑠,𝑗) with 𝑠∈𝐹.

Example I
Consider the expression 𝜙≡(𝑎𝑏𝑎)∗𝑎∗𝑏𝑏∗, corresponding to the NFA

	(8)
and the string 𝜔=𝑎𝑏𝑎𝑎𝑏𝑎𝑏𝑏. The graph 𝐶(𝜙,𝜔) is

	(9)
The double edges show a path from 𝑞00 to 𝑞84 corresponding to the accepting run 𝑞0𝑞3𝑞2𝑞0𝑞3𝑞2𝑞0𝑞1𝑞4𝑞4, which shows that the string matches the expression. Note that the sub-string 𝜔[3:7]=𝑎𝑏𝑎𝑏 also matches the expression, corresponding to the path 𝑞30→𝑞43→𝑞52→𝑞60→𝑞61→𝑞74.

Example II: Consider the same expression and the string 𝜔=𝑎𝑏𝑎; the graph 𝐶(𝜙,𝜔) is now

	(10)
The graph has no path from 𝑞00 to 𝑞34, indicating that the string doesn’t match the expression. However, there is a path from 𝑞00 to 𝑞24, indicating that the sub-string 𝜔[:2]=𝑎𝑏 does match the expression

The uncertainty model
We consider the probabilistic model of string production and detection shown schematically in Fig. 1.

Fig. 1
figure 1
The model of string production and detection. The string 𝜔, of length L, is generated by a Markov chain over the alphabet Σ. A channel noise corrupts the stream so that at the output we observe the stochastic process 𝜈, where 𝜈[𝑘] is the probability distribution of the kth element of 𝜔 and 𝜈[𝑘](𝑎) is 𝑃{𝜔[𝑘]=𝑎}. This process is fed to the recognition algorithm, which determines the most likely interpretation of 𝜈 that matches the expression

Full size image
The module M emits a string 𝜔=𝑎0⋯𝑎𝐿−1∈Σ∗. In many cases of practical interest, the elements 𝜔[𝑘] are not emitted independently. Rather, the fact that 𝜔[𝑘]=𝑎𝑘 skews the probability distribution of 𝜔[𝑘+1]. Correspondingly, we assume that M is a Markov chain with transition probabilities 𝜏(𝑎|𝑏), 𝑎,𝑏∈Σ. In this case, 𝜏(𝑎𝑖|𝑎𝑖−1) is the conditional probability distribution of the ith element of 𝜔. In order to simplify the equations that follow, we formally define 𝜏(𝑎0|𝑎−1)=△𝜏(𝑎0), the a priori probability that the first symbol of the chain were 𝑎0

The channel N introduces some noise so that, when the symbol 𝜔[𝑘]=𝑎 is emitted, we observe a probability distribution 𝜈[𝑘] over Σ such that

𝜈[𝑘](𝑎)=𝑃{𝜔[𝑘]=𝑎}
(11)
the values 𝜈[𝑘](𝑎) are the observations on which we base the estimation, and constitute, together with the transition probabilities 𝜏(𝑎|𝑏), the input of the problem.

Suppose that a string 𝜔 is produced by the module M, that the transition probabilities 𝜏 are known a priori, and that the stochastic process 𝜈 is observed. The string 𝜔 is, of course, unobservable. We are interested in two problems:

finite estimation:
assuming that there is at least one substring of 𝜔, 𝜔[𝑖:𝑗] such that 𝜔[𝑖:𝑗]⊨𝜙, which is the most likely matching substring?

finite matching:
can we determine (with a prescribed confidence) whether there is at least one substring 𝜔[𝑖:𝑗] such that 𝜔[𝑖:𝑗]⊨𝜙?

The solution of the second problem can be based on the solution of the first, to which we now turn.

Finite estimation
Given that the module M emits a string 𝜔 of length L, in this section we are interested in finding the most likely substring 𝜔[𝑖:𝑗] that matches 𝜙.

When we match substrings, we are trying to match 𝜙 with strings of different length, and this entails that we must compensate a bias towards shorter strings. The a posteriori probability of a string 𝜔 is given by the product of the probabilities of its constituent symbols. These probabilities, in general, will be composed of two terms: a probability that 𝜔[𝑘] were in the string given the observations 𝜈[𝑘], and the probability 𝜏(𝜔[𝑘]|𝜔[𝑘−1]) that the symbol 𝜔[𝑘] were generated. Both these terms have values in [0, 1], and so has their product. This means that the a posteriori probability of 𝜔[𝑖:𝑗] is the product of (𝑗−𝑖) terms smaller than one. That is, cœteris paribus, a shorter string, being the product of a smaller number of terms, will have a higher probability and will therefore be chosen.

We avoid this bias by considering the information carried by a string. If we have no a priori information on the string that is produced, its being revealed to us would carry an information 𝜄(𝜔)=−log𝑃(𝜔). If we have observed the process 𝜈, we already possess some information about the string, and its being revealed to us would give us an information 𝜄𝜈(𝜔)=−log𝑃(𝜔|𝜈)≤𝜄(𝜔). The information that the process 𝜈 gives us about the string 𝜔 is the difference of these two values:

𝐼(𝜔,𝜈)=𝜄(𝜔)−𝜄𝜈(𝜔)=log𝑃(𝜔|𝜈)−log𝑃(𝜔)=log𝑃(𝜔|𝜈)𝑃(𝜔).
(12)
Given 𝜈, we search the string 𝜔 that maximizes 𝐼(𝜔,𝜈). The term 𝑃(𝜔) at the denominator (which comes from considering the a priori information 𝜄(𝜔)) avoids the bias toward shorter strings. Given two strings 𝜔1 and 𝜔2 with the same a posteriori probability and 𝜔2 longer than 𝜔1, 𝜔2 will be selected since 𝑃(𝜔2)<𝑃(𝜔1). The rationale here is that longer strings are less likely to be emitted by chance so if we have equal evidence to support the hypothesis that either 𝜔1 and 𝜔2 were emitted, it is reasonable to select 𝜔2.

In order to compute 𝐼(𝜔,𝜈), we begin by computing 𝑃(𝜔|𝜈). Let 𝜔=𝑎0⋯𝑎𝐿−1. Then

𝑃(𝜔∣∣∣𝜈)=𝑃(𝜔[𝐿−1],𝜔[:𝐿−2]∣∣∣𝜈[𝐿−1],𝜈[:𝐿−2])=𝑃(𝜔[𝐿−1]∣∣∣𝜈[𝐿−1],𝜈[:𝐿−2],𝜔[:𝐿−2])𝑃(𝜔[:𝐿−2]∣∣∣𝜈[𝐿−1],𝜈[:𝐿−2])=𝑃(𝜔[𝐿−1]∣∣∣𝜈[𝐿−1],𝜔[:𝐿−2])𝑃(𝜔[:𝐿−2]∣∣∣𝜈[:𝐿−2]).
(13)
The last equality reflects the fact that 𝜔[𝐿−1] only depends on observations at time 𝐿−1. We make the hypothesis that the conditional probability of 𝑎𝑘 occurring in position t conditioned on 𝜈[𝑡] depends only on the observation on 𝑎𝑘, at step t, that is,

𝑃(𝑎𝑘∣∣∣𝜈[𝑡])=𝑃(𝑎𝑘∣∣∣𝜈[𝑡](𝑎𝑘));
(14)
this is tantamount to considering that our observations are complete: the value 𝜈[𝑡](𝑎) gives us all the information available on a. With this hypothesis we have

𝑃(𝑎𝐿−1∣∣∣𝜈[𝐿−1],𝜔[:𝐿−2])=𝑃(𝑎𝐿−1∣∣∣𝜈[𝐿−1](𝑎𝐿−1),𝜔[:𝐿−2])=𝑃(𝜈[𝐿−1](𝑎𝐿−1)∣∣∣𝑎𝐿−1,𝜔[:𝐿−2])𝑃(𝑎𝐿−1∣∣∣𝜔[:𝐿−2])𝑃(𝜈[𝐿−1](𝑎𝐿−1))=(*) 𝑃(𝜈[𝐿−1](𝑎𝐿−1)∣∣∣𝑎𝐿−1)𝑃(𝑎𝐿−1∣∣∣𝑎𝐿−2)𝑃(𝜈[𝐿−1](𝑎𝐿−1))=𝜈[𝐿−1](𝑎𝐿−1)𝜏(𝑎𝐿−1|𝑎𝐿−2)𝑃(𝜈[𝐿−1](𝑎𝐿−1)).
(15)
The equality (*) depends on two properties: first, the measure on 𝜔[𝐿−1] does not depend on the previous values of 𝜔 and, second, on the Markov property

𝑃(𝜔[𝐿−1]∣∣∣𝜔[:𝐿−2])=𝑃(𝜔[𝐿−1]∣∣∣𝜔[𝐿−2]).
(16)
Putting this result in (13), we have

𝑃(𝜔∣∣∣𝜈)=𝜈[𝐿−1](𝑎𝐿−1)𝜏(𝑎𝐿−1|𝑎𝐿−2)𝑃(𝜈[𝐿−1](𝑎𝐿−1))𝑃(𝜔[:𝐿−2]∣∣∣𝜈[:𝐿−2]);
(17)
the value

𝑃𝜈(𝜔)=△∏𝑘=0𝐿−1𝑃(𝜈[𝑘](𝑎𝑘))
(18)
is the a priori probability of observing 𝜔. Working out the recursion and using this definition we have:

𝑃(𝜔∣∣∣𝜈)=1𝑃𝜈(𝜔)∏𝑘=0𝐿−1𝜈[𝑘](𝑎𝑘)𝜏(𝑎𝑘|𝑎𝑘−1).
(19)
Substituting (19) in (12), the criterion that we want to maximize is

(𝜔)=𝐼(𝜔,𝜈)=log[1𝑃𝜈(𝜔)𝑃(𝜔)∏𝑘=0𝐿−1𝜈[𝑘](𝑎𝑘)𝜏(𝑎𝑘|𝑎𝑘−1)]=1𝑃𝜈(𝜔)𝑃(𝜔)∑𝑘=0𝐿−1log𝜈[𝑘](𝑎𝑘)𝜏(𝑎𝑘|𝑎𝑘−1).
(20)
The a priori probabilities 𝑃𝜈(𝜔) and 𝑃(𝜔) will be estimated assuming that no a priori information is available, that is, assuming a uniform distribution

𝑃(𝜔)=𝑃𝜈(𝜔)=1|Σ|𝐿,
(21)
leading to

(𝜔)=∑𝑘=0𝐿−1log(|Σ|2𝜈[𝑘](𝑎𝑘)𝜏(𝑎𝑘|𝑎𝑘−1)).
(22)
We are interested not only in detecting maximum length strings, but in detecting sub-strings 𝜔[𝑖:𝑗] as well. To this end, we define the partial information difference:

𝑖,𝑗(𝜔)=∑𝑘=𝑖𝑗−1log(|Σ|2𝜈[𝑘](𝑎𝑘)𝜏(𝑎𝑘|𝑎𝑘−1))=(𝑗−𝑖)log|Σ|2+∑𝑘=𝑖𝑗−1log(𝜈[𝑘](𝑎𝑘)𝜏(𝑎𝑘|𝑎𝑘−1)).
(23)
The second expression highlights the effect of considering prior information: the term (𝑗−𝑖)log|Σ|2 is the bias that, all else being equal, favors the detection of longer strings.

Our problem can therefore be expressed as finding the sub-string:

𝜔¯=argmax𝜔[𝑖:𝑗]⊨𝜙𝑖,𝑗(𝜔).
(24)
Two simplified cases are of importance in applications. The first is when the generation of the symbols has no temporal dependence, in which case 𝜏(𝑎𝑘|𝑎𝑘−1)=𝜏(𝑎𝑘), and

𝑖,𝑗(𝜔)=∑𝑘=𝑖𝑗−1log(|Σ|2𝜈[𝑘](𝑎𝑘)𝜏(𝑎𝑘)),
(25)
the second is when the symbols are generated with uniform a priori probability, in which case 𝜏(𝑎𝑘)=1/|Σ| and

𝑖,𝑗(𝜔)=∑𝑘=𝑖𝑗−1log(|Σ|𝜈[𝑘](𝑎𝑘)).
(26)
Finding the string that maximizes  is the basis on which we define several forms of matching.

Definition 3
Given the string 𝜔 and the expression 𝜙, we say that the sub-string 𝜔[𝑖:𝑗] matches 𝜙 with strength 𝛽 (or 𝛽-matches 𝜙), written 𝜔[𝑖:𝑗]⊨𝛽𝜙, if 𝜔[𝑖:𝑗]⊨𝜙, and 𝑖,𝑗(𝜔)=𝛽.

Matching is defined as an optimality criterion over 𝛽-matchings. We use two such criteria: the first (weakly optimal) restricts optimality to continuations of a string, while the second (strongly optimal) extends it to all matching sub-strings.

Definition 4
Given the string 𝜔 and the expression 𝜙, 𝜔 weakly-optimally matches 𝜙 (wo-matches 𝜙, written 𝜔⊨𝑤𝜙) if:

(i)
𝜔⊨𝛽𝜙;

(ii)
for all 𝜔′∈Σ∗, if 𝜔𝜔′⊨𝛽′𝜙, then 𝛽≥𝛽′.

Definition 5
Given the string 𝜔 and the expression 𝜙, 𝜔 strongly-optimally matches 𝜙 (so-matches 𝜙, written 𝜔⊨𝑠𝜙) if:

(i)
𝜔⊨𝛽𝜙;

(ii)
for all 𝜔′∈Σ∗, if 𝜔′⊨𝛽′𝜙, then 𝛽>𝛽′.

The following property is obvious from the definition

Lemma 1
For all 𝜔, 𝜙, if 𝜔⊨𝑠𝜙, then 𝜔⊨𝑤𝜙.

Matching method
We match the expression to uncertain data using a modification of the Cartesian graph. Let =(𝑄,Σ,𝑞0,𝐹,𝛿) be the NFA that recognizes the expression 𝜙, 𝜈 the observed process of length n and, for 𝑖=0,…,𝑛−1, 𝑎𝑖∈Σ, let 𝜈[𝑖](𝑎) be given. We shall assume that  is simple. The modified Cartesian graph is a weighted graph 𝐼(𝜙,𝜈)=(𝑉,𝐸,𝑤), 𝑤:𝐸→ defined as follows:

(i)
𝑉={(𝑞,𝑘)∣∣∣𝑞∈𝑄,𝑘∈{0,…,𝐿}}

(ii)
(𝑢,𝑣)∈𝐸 and 𝑤(𝑢,𝑣)=𝑟 if either

a.
𝑢=(𝑞,𝑘), 𝑣=(𝑞′,𝑘+1), there is a such that 𝛿(𝑞,𝑎,𝑞′), 𝑟=𝜈[𝑘](𝑎)>0 (note that 0<𝑟≤1);

b.
𝑢=(𝑞,𝑘), 𝑣=(𝑞′,𝑘), 𝛿(𝑞,𝜖,𝑞′) and 𝑟=1.

For such an edge, we set 𝜎[(𝑢,𝑣)]=𝑎∈Σ if ii.a applies, and 𝜎[(𝑢,𝑣)]=𝜖 if ii.b applies; that is, given an edge e, 𝜎[𝑒] is the symbol that causes e to be crossed.

In order to use the graph to find -matches, we need a way to associate possible strings (viz., strings with non-zero probability) to paths in the graph. Given the path 𝜋=[𝜋0,…,𝜋𝑛] with 𝜋𝑘=(𝑠𝑘,ℎ), ℎ≤𝑘, we build the string 𝜔[𝜋] applying the function mstr in Fig. 2.

Fig. 2
figure 2
The function that builds the string 𝜔[𝜋] associated to a path 𝜋 in the Cartesian graph C. If 𝜋 is not a path in C, the function returns the empty string 𝜖

Full size image
Lemma 2
If the NFA is simple then for each path 𝜋,  mstr (𝐶,𝜋) is unique.

This lemma is a consequence of the fact that, if the NFA is simple, for each edge there is only one 𝑎∈Σ that causes it to be traversed, that is, 𝜎[𝑒] is a well-defined function.

Lemma 3
Let 𝜋 be a path and 𝜔= mstr (𝐶,𝜋)=𝑎0⋯𝑎𝐿−1. Then, for all 𝑘=0,…,𝐿−1, 𝜈[𝑘](𝑎𝑘)>0.

Proof
If 𝜔[𝑘]=𝑎𝑘, then, by step 3, (𝜋𝑘,𝜋𝑘+1)∈Σ and by step 4, 𝑎𝑘=𝜎[(𝜋𝑘,𝜋𝑘+1)]. By condition ii.a of the definition of the graph C (page 11), this entails that 𝜈[𝑘](𝑎𝑘)>0. ◻

Theorem 2
Given the path 𝜋=[𝜋0,…,𝜋𝑛], if 𝜔= mstr (𝐶,𝜋), 𝜋0=(𝑠0,𝑘) and 𝜋𝑛=(𝑠,𝑘+ℎ) with 𝑠∈𝐹, then 𝜔⊨𝜙.

Proof
Let 𝐶′ be the Cartesian graph (without uncertainty) generated by 𝜔 on 𝜙. Let ((𝑞,𝑡),(𝑞′,𝑡+1)) be an edge on 𝐶′ caused by 𝑎𝑡∈Σ. By Lemma 3, 𝜈[𝑡](𝑎𝑡)>0, so the edge will also be an edge of G, that is, 𝐺′ is a subgraph of G.

By construction, 𝐺′ has a path 𝜋′:(𝑞0,0)→(𝑞𝑓,|𝜔|), with 𝑞𝑓∈𝐹, and so has G. Because of Theorem 1, 𝜔⊨𝜙. ◻

Finding the optimal match to the expression is akin to finding the shortest path on a weighted graph, with some modifications. In a typical shortest path algorithm, each edge (u, v) has a weight w(u, v) and, given a path 𝜋=[𝑢0,𝑢2,…,𝑢𝑛], the weight of the path is the sum of the weights of its edges, that is 𝑤[𝜋]=∑𝑛−1𝑖=0𝑤(𝑢𝑖,𝑢𝑖+1). Moreover, each vertex u has associated a distance value d[u]. When the vertex is analyzed,Footnote2 its in-edges are analyzed. If the situation is the following:


then the distance value of u is updated as

𝑑[𝑢]←min{𝑑[𝑣𝑖]+𝑤𝑖,𝑖=1…,𝑛}
(27)
In our case, rather than with a weight w, we mark each edge with a pair (𝑎,𝜈[⋅](𝑎)), where 𝑎∈Σ is the symbol that causes that edge to be crossed, and 𝜈 is the probability that the symbol emitted at that particular step were a. We look for the most probable path, that is, we are trying to maximize, rather than minimize, a suitable (additive) function of the weights of the graph.

We also have, with respect to the standard algorithm, a complication due to the conditional probabilities of the Markov chain: in the general case, the estimation that we have to minimize for the node u depends not only on the in-neighbors 𝑣1,…,𝑣𝑛, but also on the label of the edges of the optimal paths that enter the nodes 𝑣1,…,𝑣𝑛. To clarify this point, given a node u, let [𝑢] be the estimate of the criterion that we are maximizing for the paths through u. Suppose we are evaluating a path entering u:


The estimation [𝑢] for this path is given by

[𝑢]=[𝑣]+log(|Σ|2𝜈[⋅](𝑏)𝜏(𝑏|𝑎))
(28)
So, in order to update the estimate [𝑢] we need to look at one edge further back than we would for a normal path-finding algorithm. In general, given the edges entering u:


we have

[𝑢]=max{[𝑣𝑖]+log(|Σ|2𝜈[⋅](𝑏𝑖)𝜏(𝑏𝑖|𝑎𝑖))}
(29)
This complication is not present if the symbols are generated independently, that is, if we are optimizing (25).

It would not be hard to adapt one of the standard shortest path algorithms to work for this case, but it is more efficient to take advantage of the structure of the Cartesian graph. In the graph, we have only two kinds of edges: forward edges (𝑞,𝑘)→(𝑞′,𝑘+1) and 𝜖-edges, corresponding to the 𝜀-transitions, (𝑞,𝑘)→(𝑞′,𝑘); 𝜖-edges can be traversed at any time without changing the value of the objective function.

Table 1 Symbols used in the path finding algorithm
Full size table
The algorithm is composed of two parts: the first is the top level function match that receives the NFA for the expression and the observations 𝜈, builds the graph 𝐶(𝜙,𝜈) with the edges marked by the probability of having received the corresponding symbol, and manages the traversal of forward edges. The second is a local relaxation function that checks whether the criterion estimation of some nodes can be improved by traversing some 𝜖-edges. This function also checks whether it is convenient to start a new path: if the state 𝑞0 has a negative estimation, then its estimation is set to 0 and a new path is started. Table 1 shows the symbols used in the algorithm. The function relax is shown in Fig. 3.

Fig. 3
figure 3
The relaxation function. The function initializes a new path (lines 2, 3) if the start state has a negative value for  and attempts to traverse all 𝜖-edges to check whether some value can be improved by traversing them

Full size image
The auxiliary function  (Fig. 4) receives a pair of states q and 𝑞′ and a time t, and determines the value [𝑞,𝑡] resulting by arriving at (q, t) from (𝑞′,𝑡−1). If there is no edge between the two states, then the function returns −∞.

Fig. 4
figure 4
Auxiliary function: computes the value of the objective function [𝑞,𝑡] that one obtains traversing the edge ((𝑢,𝑡−1),(𝑣,𝑡)). If no such edge exists, the function returns −∞

Full size image
The main function of the algorithm is shown in Fig. 5. The algorithm proceeds time-wise from the first symbol received to the last. The main loop adjusts the objective taking into account the edges from the previous time step, and then calls the function relax to take into account 𝜖-edges and possible re-initializations of the path.

The algorithm returns the node that maximizes [ q,k]; the loops of steps 9 and 10 go through the nodes of the graph and for each node (q, k), steps 11 and 13 choose the predecessor (𝑞′,𝑘−1) that maximizes [ q,k] among all symbols read at step 𝑘−1. If there is a node (𝑞′,𝑘) that provides a better [ q,k], that is, if the objective at step k is maximized by not reading any symbol and doing instead an 𝜀-transition, then that option will be discovered at step 9 of the function relax and the value [ q,k] will be updated at step 10.

Finally, step 17 of match will return the final state with the highest value of the objective function, that is, the state where the optimal accepting path ends.

At the end, 𝑞𝑓 contains the final state that represents the end of the most likely path. A simple recursive function (Fig. 6) can then be used to return the optimal path.

Fig. 5
figure 5
The main matching algorithm. The main loop of lines 10–14 proceeds time-wise updating at each step the objective estimation for all the states after symbol i. Once the "best" predecessor of a state has been found (line 11), the value of the objective for that cost as well as its predecessor are updated (lines 12–13). At the end, w contains the final state that represents the end of the most likely path. The path can be reconstructed following the predecessor pointers until an initial path

Full size image
Fig. 6
figure 6
The function that creates a path ending at a given state. The predicate initial is true if the parameter q is the initial state of the automaton

Full size image
As an implementation note, observe that we have presented here a fairly naïve implementation of the algorithm, one that explicitly generates the whole graph. In a more optimized version, one can generate at step k only the states (q, k) with finite cost, and keep track only of the open paths for each node. This implementation is akin to the standard implementation of an NFA, with the additional complication that, if the optimal string is to be reported (as opposed to requiring a simple yes/no answer), one must keep track of the open paths.

The following property is an easy consequence of the maximization of .

Theorem 3
Let 𝜙 be an expression, N the associated NFA, and 𝜈 a series of L observations of a string. If

𝜔= mstr ( cartesian (𝑁), path ( match (𝑁,𝜈,𝐿)))
then 𝜔⊨𝑠𝜙

Example II
Consider, once more, the regular expression of Example I. We detect eight symbols from the alphabet Σ={𝑎,𝑏}, with probabilities as in Table 2.

Table 2 The sequence of symbols detected in input for example II, with the probabilities of detection of each one
Full size table
We assume that the symbols are independent and equiprobable, so we can apply (26). Before the first iteration, the first column of the graph has been initialized as:


Note that the state 𝑞1 has value 0 as the 𝜖-edge that joins it to 𝑞0 has been relaxed. During the second iteration, we consider the edges to the second column, with the following weights:


At this point, each node in the second column computes its value adding |Σ|𝜈[0](𝜎[𝑒]) to the value of the predecessor for each incoming edge, and taking the maximum. If the start state has a negative value or if some value may be increased by traversing an 𝜖-edge, this is done in the function relax. The graph is now:


The state 𝑞0 had a negative value of −∞, so it has been reset to 0, making it possible to start a new path. Continuing until all the symbols have been processed, we arrive to the graph of Fig. 7.

Fig. 7
figure 7
The graph corresponding to the expression of Example I with the input probabilities of Example II. The optimal path ends at the bottom-right state of the figure. The path is highlighted using double arrows, and corresponds to the input ababb

Full size image
The state at the bottom-right of the figure, with a value =3.56 is the final state where the optimal path ends. The optimal path is indicated by double arrows. Note that it does not extend to the whole input, but it begins at step 3, and corresponds to the input ababb. The reason for this is the very low probability of the symbol a in step 3, a symbol that would be necessary to continue the sequence ab that began in the first step. At the third step, the state that precedes 𝑞0 and that would have to transition to 𝑞0 to permit the continuation (state 𝑞2) has a value 0.68; given that a has a probability of only 0.01, this gives:

[𝑠0,3]=[𝑠2,2]+log|Σ|𝜈(𝑎)=0.68+log2⋅0.01=−4.96
(30)
This negative value causes (𝑞0,3) to be reset to 0 in the function relax and a new path to be started.

Probability of misdetection
In this section we are interested in studying some illustrative examples of detection error. With reference to Fig. 1, we assume that the module M emits a string 𝜔=𝑎0⋯𝑎𝐿−1 and that an initial substring 𝜔′ matches 𝜙. We introduce some error in N, and we are interested in determining under which conditions the algorithm will misclassify, that is, it will estimate a 𝜔″≠𝜔′ as the best match for the expression.

Note that this can be seen as a constrained estimation problem: we estimate 𝜔 based not only on the probabilities 𝜈(𝑎) but also on the constraint that our estimation must be such that 𝜔⊨𝜙.

Example III
Consider the following situation: we have an alphabet Σ with 𝑎,𝑏∈Σ and the expression 𝜙=𝑎∗. Assume that the module M of Fig. 1 emits the string 𝑎⋯𝑎𝑏, where the symbol a is repeated n times. The detection probabilities are assumed to be constant, independent of the position:

𝜈[⋅](𝑎)𝜈[⋅](𝑏)=𝑐=1−𝑐|Σ|−1
(31)
We are interested in analyzing the following two scenarios:

(i)
the symbol "b" in 𝜔 is correctly detected; consequently, the algorithm will detect that 𝜔⊭𝜙, but that 𝜔[:𝑛]⊨𝜙 (correct classification), or

(ii)
the symbol "b" is misinterpreted as an "a", in which case the algorithm will match the whole 𝜔 to 𝜙 (misclassification).

In the first case, the value of the objective function will be

=∑𝑘=0𝑛−1log|Σ|𝜈[𝑘](𝜔𝑘)=∑𝑘=0𝑛−1log|Σ|𝑐=𝑛log|Σ|+𝑛log𝑐
(32)
The second will give a value

′=∑𝑘=0𝑛log|Σ|𝜈[𝑘](𝜔𝑘)=∑𝑘=0𝑛−1log|Σ|𝜈[𝑘](𝑎)+log|Σ|𝜈[𝑛](𝑏)=𝑛log|Σ|+𝑛log𝑐+log|Σ|1−𝑐|Σ|−1
(33)
The algorithm will produce the solution ii) (viz., it will misclassify) if ′−>0, that is, if

log|Σ||Σ|−1(1−𝑐)>0
(34)
or

𝑐<1|Σ|
(35)
If c is relatively high, then the probability of confusion is small, the algorithm will assume that the last symbol is a "b" and match (correctly) the shorter string. On the other hand, if c is small, then the uncertainty on the symbol that has actually been emitted is higher, and the cost of assuming that the symbol is actually an "a" gives a higher value of the objective function, as it permits the identification of a longer string. Note that in this case the threshold at which misclassification occurs is independent of n, the length of the string.

Example IV
In this example, we consider a case of considerable interest in applications: spike noise (noise on a single symbol). Consider again the expression 𝜙=𝑎∗ and the string 𝑎𝑛𝑎𝑎𝑚. We call central a the symbol that comes between the two sequences 𝑎𝑛 and 𝑎𝑚, and we are interested in determining the effect of spike noise in the central a on the detection of the string. Assume, for the sake of this example, that we are interested only in detecting initial sub-strings of 𝜔. Suppose that the observations are the same for all symbols except the central a, that is

𝜈[𝑘](𝑥)=⎧⎩⎨⎪⎪⎪⎪𝑐𝑐′1−𝑐|Σ|−11−𝑐′|Σ|−1𝑥=𝑎,𝑘≠𝑛𝑥=𝑎,𝑘=𝑛𝑥≠𝑎,𝑘≠𝑛𝑥≠𝑎,𝑘=𝑛
(36)
In our scenario, most of the symbols are detected with low noise, in particular 𝑐>1/|Σ|, while at the central a the noise spikes, that is 𝑐′<𝑐. The scenarios in which we are interested are the following:

(i)
the central a is mistakenly interpreted as a different symbol, and the algorithm chooses 𝑎𝑛 as the best initial matching string;

(ii)
the central a is correctly interpreted, and the algorithm identifies 𝑎𝑛+𝑚+1 as the best initial matching string.

The value of the objective function in the first case is

=∑𝑡=0𝑛−1log|Σ|𝜈[𝑡](𝑎)=𝑛log|Σ|𝑐
(37)
while in the second it is

′=(𝑛+𝑚)log|Σ|𝑐+log|Σ|𝑐′
(38)
The correct interpretation is chosen if ′>, that is

|Σ|𝑐′>(|Σ|𝑐)−𝑚
(39)
Note that the value of 𝑐′ for which misinterpretation occurs does not depend on n, that is, it does not depend on the part of the string before the noise spike, as this part contributes equally to both scenarios. It does, on the other hand, depend on m, that is, on the length of the portion of string that follows the spike. The relation (39) is illustrated in Fig. 8.

Fig. 8
figure 8
The relation (39), |Σ|𝑐′ is represented as a function of |Σ|𝑐 for 𝑚=1,2,5,10,20. The portion above each curve corresponds to the area in which the correct decision is made. Note that if the string that follows the spike (of length m) is short, the wrong interpretation will prevail for relatively small errors but as m grows, matching becomes more robust, and the correct interpretation is maintained for larger errors (viz. small 𝑐′)

Full size image
The condition 𝑐>1/|Σ| translates to |Σ|𝑐>1, hence the lower limit of the abscissas.

For constant |Σ|, the limiting value of 𝑐′ decreases when c increases as well as when m does. In other words, we can tolerate more noise in the central a if we have a smaller error on the other symbols or if the input string is longer: both cases provide more evidence that the whole string matched 𝜙, thus offsetting the effects of uncertainty on the central a.

Also, all else being equal, the threshold value for 𝑐′ behaves as 𝑐′∼|Σ|−(𝑚−1), that is, it decreases as |Σ| increases. This is due mostly to the characteristics of our setup: if the probability of observing the correct symbol is held fixed to c so, as |Σ| increases, the probability of the incorrect ones decreases as 1/(|Σ|−1).

Remark 1
This example, its simplicity notwithstanding, is quite general. Each time we have an expression 𝜙 and strings 𝜔, 𝜔′ such that 𝜔⊨𝜙 and 𝜔𝜔′⊨𝜙, and an error spike on a symbol of 𝜔′, the considerations of this example apply with 𝑚=|𝜔′|.

Finite match
We now turn to the second problem introduced in Sect. 4: finite match. Given the expression 𝜙 and an (unknown) string 𝜔=𝑎0⋯𝑎𝐿−1, information about which is only available through the stochastic process 𝜈, we want to know the probability that 𝜔⊨𝜙. We begin by considering matching the whole string only; we then extend the method to determine the probability that (at least) a sub-string of 𝜔 match 𝜙.

We begin by determining, using the Cartesian graph, the probability that starting from a state (𝑞𝑠,𝑡𝑠), we arrive at a state (𝑞′,𝑡), 𝑡≥𝑡𝑠. The structure of the algorithm is similar to that of the algorithm match of Fig. 5 but, in this case, instead of computing the value [𝑞,𝑡] for each state we compute the probability 𝔭[𝑞,𝑡] of reaching it. We begin by setting 𝔭[𝑞𝑠,𝑡𝑠]=1 and 𝔭[𝑞′,𝑡′]=0 for (𝑞′,𝑡′)≠(𝑞𝑠,𝑡𝑠). We then operate iteratively in two steps: the first is a relaxation function that corrects the probability of reaching (q, t) from another state (𝑞′,𝑡) through an 𝜖-edge that is, the function operates the transformation shown in Fig. 9.

Fig. 9
figure 9
Updating the estimated probability of reaching the state (q, t) through an 𝜖-transation. The structure of the graph fragment that we are considering is shown in a. In b, the value 𝔭[𝑞,𝑡] is the estiated probability of reaching state (q, t) without considering the 𝜖-transition, and 𝔭[𝑞′,𝑡] is the probability of reaching (𝑞′,𝑡), the source of the transition. In c the updated probabilities are shown

Full size image
We assume that in the previous step we had already estimated the probability of arriving at (q, t) from states of type (𝑞″,𝑡−1). This step updates the estimate by considering the 𝜖-translation as

𝔭[𝑞′,𝑡]←𝔭[𝑞,𝑡]+𝔭[𝑞′,𝑡]
(40)
This entails, coherently with our model, that the probability of executing an 𝜀-transition is 1. The second step is a forward projection step, in which we estimate the probability of reaching states at 𝑡+1 based on the probabilities at t. The projection operation is shown in Fig. 10.

Fig. 10
figure 10
Updating the estimated probability of reaching the state (𝑞,𝑡+1) from the states (𝑞1,𝑡),…,(𝑞𝑛,𝑡). The structure of the graph fragment that we are considering is shown in a. In b, the values 𝔭[𝑞𝑢,𝑡] have been estimated at a previous step. In c the probability of reaching (𝑞,𝑡+1) is estimated (without considering the 𝜖-transitions between states at 𝑡+1) as the weighted sum of the probabilities of reaching (𝑞𝑢,𝑡), weighted by the probability of having observed the input that causes the transition (𝑞𝑢,𝑡)→(𝑞,𝑡+1)

Full size image
The probability of reaching (𝑞,𝑡+1) is a weighted sum of the probabilities of reacing the abutting (𝑞𝑢,𝑡) states, each weighted by the probability of observing in input the symbol that causes the transition (𝑞𝑢,𝑡)→(𝑞,𝑡), that is

𝔭[𝑞,𝑡+1]←∑𝑢=1𝑛𝔭[𝑞𝑢,𝑡]𝜈[𝑡](𝑎𝑢)
(41)
This procedure, alternating forward projections and relaxations, correctly determines, given the start state, the probability of reaching any other state, with an exception. If a portion of the graph has a configuration like

	(42)
then it is easy to see that 𝑝2=𝑝3=𝑝1⋅𝜈[𝑘](𝑎), while our recursion computes 𝑝3=2⋅𝑝1⋅𝜈[𝑘](𝑎). This configuration, however, is never encountered as the automata that we are considering are simple (see Definition 2).

The algorithm takes in input a point t of the input string and the initial state 𝑞0, and produces an array 𝔭 with the probabilities of reaching the other states: that is, 𝔭[𝑞,𝑡′], 𝑡′>𝑡 is the probability of reaching (𝑞,𝑡′) starting from (𝑞0,𝑡).

The function prelax, analogous to relax of Fig. 3 works based on a topological ordering of the sub-graph of the NFA induced by the 𝜀-transitions. The 𝜀-transitions are acyclical, so the set of states of the NFA with the edges corresponding to the 𝜀-transitions is a DAG, and the topological ordering is well defined. The function eps_sort (not described here) returns the list of states topologically sorted (Fig. 11).

Fig. 11
figure 11
The relaxation function for the probability determination algorithm. The set of states is topologically sorted using the graph induced by the 𝜀-transition and each node propagates its probability value to its followers in the order

Full size image
The main function, MatchProb takes an initial node of the Cartesian graph and determines the probability of reaching all the other nodes that can be reached from the initial one (Fig. 12).

Fig. 12
figure 12
The main function for determining the probability of matching. The initial node is (𝑞0,𝑡0), which is reached with probability 1 (set in line 7). The following loop (lines 9–16) goes one step at the time updating at each one the probability that a state is reached through a non-𝜀 symbol (loop of lines 10–14) or through an 𝜖-transaction (relax of line 15)

Full size image
The probability that the whole string match the expression is the probability that, starting at the first symbol one reaches a final at time L, being L the length of the string. That is,

𝔭𝑃= MatchProb ( NFA ,𝜈,𝐿,0)=∑𝑞∈𝐹𝔭[𝑞,𝐿−1]
(43)
To determine the probability of one matching substring, let

𝔭𝑘= MatchProb ( NFA ,𝜈,𝐿,𝑘)
(44)
Then 𝔭𝑘[𝑞,𝑡]=0 for 𝑡<𝑘, and for 𝑡≥𝑘, 𝔭𝑘[𝑞,𝑡] is the probability that, starting from state 𝑞0 at symbol number k, and based on the observations, the unknown substring 𝜔[𝑘:𝑡] will lead to state q. The probability that 𝜔[𝑘:𝑡]⊨𝜙 is therefore

𝔓[𝑘,𝑡]=△∑𝑞∈𝐹𝔭𝑘[𝑞,𝑡]
(45)
The probability that at least one of the sub-strings 𝜔[𝑘:𝑡] for 𝑡>𝑘 match the expression is

𝑄[𝑘]=△1−∏𝑡=𝑘+1𝐿−1(1−𝔓[𝑘,𝑡])
(46)
Finally, the probability that at least one sub-string match the expression is

𝑃=△1−∏𝑘=0𝐿−1(1−𝑄[𝑘])=1−∏𝑘=0𝐿−1∏𝑡=𝑘+1𝐿−1(1−𝔓[𝑘,𝑡])
(47)
Remark 2
The applicability of the probability approach is limited in the case of expressions that can be satisfied by short strings. In this case, even if the probability if seeing the right symbol is relatively low, the sheer number of possible short expressions makes the probability of at least one match quite high.

Fig. 13
figure 13
Two views of the behavior of 𝑃𝑀 (viz. the probability that at least one substring of 𝜔=𝑎𝐿 match 𝜙=𝑎∗) as a function of c for various values of L (a). Due to the presence of many short subexpressions, the probability approaches 1 very rapidly as c or n increase. To give a better idea of the speed of convergence to 1, in b the value 1−𝑃𝑀 is shown on a logarithmic scale: this value approaches 0 as c or n increase

Full size image
Example V
Consider again the expression 𝜙≡𝑎∗ and the string 𝜔=𝑎𝑛, with 𝑎∈Σ and 𝜈[𝑘](𝑎)=𝑐 for 𝑘=0,…,𝐿−1.

If we take a specific one-symbol substring, say 𝜔𝑘=𝑎, we have ℙ(𝜔𝑘⊨𝜙)=𝑐. There are L such sub-strings, so the probability that at least one of them match 𝜙 is

𝑃1=△1−∏𝑢=0𝐿−1(1−𝑐)=1−(1−𝑐)𝐿
(48)
For a specific two-symbol substring we have ℙ(𝜔𝑘𝜔𝑘+1⊨𝜙)=𝑐2 and, since there are 𝐿−1 such string, we have

𝑃2=△1−∏𝑢=0𝐿−2(1−𝑐2)=1−(1−𝑐2)𝐿−1
(49)
In general, the probability that at least one k-symbol substring match 𝜙 is

𝑃𝑘=△1−∏𝑢=0𝐿−𝑘(1−𝑐𝑘)=1−(1−𝑐𝑘)𝐿−𝑘+1
(50)
The probability that at least one substring match the expression is

𝑃𝑀=1−∏𝑘=0𝐿−1(1−𝑃𝑘)=1−∏𝑘=0𝐿−1(1−𝑐𝑘)𝐿−𝑘+1
(51)
Figure 13a shows the behavior of 𝑃𝑀 as a function of c for various values of L. In order to have a better view of the speed of convergence of the function, in Fig. 13b we show the value log(1−𝑃𝑀), which converges to −∞ as 𝑃𝑀 converges to 1.

The probability of having at least one match is very close to 1 for 𝑛>4 or 𝑐>0.4; this constantly high probability limits the discriminating power of the probability test.

Remark 3
The problem highlighted in the previous example is present only for expressions that can be matched by short strings. In the example, most of the probability of match is due to the probability of matching one-symbol strings: Fig. 14 shows (𝑃−𝑃1)/𝑃.

Fig. 14
figure 14
The value of (𝑃−𝑃1)/𝑃 as a function of c for various values of L

Full size image
In most cases, the error that one would commit by replacing P with 𝑃1 is less than 10%; this entails that the probability method is viable for expressions that do not match short string as the fast convergence to the probability 1 would not occur in those cases.

If short matching strings are common, a viable solution for practical applications is to find the best matching substring 𝜔[𝑖:𝑗] and use the value 𝑖,𝑗(𝜔) as an indicator of the likelihood of matching. We shall not pursue this possibility in this paper.

Infinite streams
Many applications, especially on-line applications, require the detection of certain combinations of symbols in an infinite stream of data. Most of these applications are real-time and use a terminology a bit different from what we use here: what we have called symbols are often elementary events detected in the stream, and our position in the string corresponds to the time of detection (in a discrete time system).

In the case of infinite streams, we are not interested in finding the one sub-string that best matches the expressions: in general there will be infinitely many string in different parts of the stream, possibly partially overlapping, that match the expressions. We are interested in catching them all. This multiplicity causes several problems for the definition of a proper semantics for collecting matching strings (many problems arise out of having to decide what to do when matching strings overlap) which, in turn, may cause decidability issues [25]. We shall not consider those issues here, as they are orthogonal to the problems caused by uncertainty: if we can solve the basic problem of deciding whether 𝜔⊨𝑤𝜙 under uncertainty, then all the problems related to the definition of a proper semantics in a stream can be worked out using the theory in [25] (in which these problems were considered under the hypothesis of no uncertainty).

In the case of streams, we are not typically interested in strong semantics, which represents too strong a condition for practical applications. Given a (finite) portion of the stream 𝜔 such that 𝜔⊨𝛽𝜙, it is clearly undecidable in an infinite stream whether there will be, at some future time, a portion 𝜔′ such that 𝜔′⊨𝛽′𝜙 with 𝛽′>𝛽. Moreover, in streams we are interested in determining a collection of finite strings that match the expression, so the use of an absolute criterion such as the strong semantics (only one string can match the expression in the strong sense) is not very useful.

We shall therefore make use of the weak semantics throughout this section. Since the stream is infinite and we are interested in chunks of it, we shall assume, without loss of generality, that the strings we are testing start at the beginning of the relevant part of the stream, that is, all the strings that we test are sub-strings of type 𝜔[:𝑘].

The problem we are interested in is therefore the following:

STREAM-WEAK: Given a string 𝜔, and expression 𝜙, and an infinite stream of observations 𝜈, is it the case that 𝜔⊨𝑤𝜙?

As we mentioned, we assume that if |𝜔|=𝐿, the recognition of 𝜔 is based on the first L observations of the stream 𝜈.

Our first result is a simple and negative one.

Theorem 4
STREAM-WEAK is undecidable.

Proof
Suppose the problem is decidable. Then there is an algorithm  such that, for each expression 𝜙, observations 𝜈, and string 𝜔, (𝜙,𝜈,𝜔) stops in finite time with "yes" if 𝜔⊨𝑤𝜙, and with "no" otherwise.

Consider the expression 𝜙≡𝑎∗, and an alphabet Σ with |Σ|>1 and 𝑎∈Σ. Suppose that the observations are such that (𝑎𝐿)=𝛽 and, for 𝑘>𝐿, 𝜈[𝑘](𝑎)=𝑞<1/|Σ|. Then, for 𝑁>𝐿:

(𝑎𝑁)=(𝑎𝐿)+(𝑁−𝐿)log|Σ|𝑞<𝛽
(52)
Since the algorithm is correct, it will stop after M steps on "yes". Note that (𝑎𝑀)=𝛽′<𝛽.

Consider now a new stream of observations 𝜈′ with 𝜈′[𝑘]=𝜈[𝑘] for 𝑘≤𝑀 and, for 𝑘>𝑀, 𝜈′[𝑘](𝑎)=𝑐>1/|Σ|, that is, log|Σ|𝑐>0. Take 𝑄>𝑀, then

(𝑎𝑄)=(𝑎𝑀)+(𝑄−𝑀)log|Σ|𝑐=𝛽′+(𝑄−𝑀)log|Σ|𝑐
(53)
If

𝑄>𝑀+𝛽−𝛽′log|Σ|𝑐
(54)
then (𝑎𝑄)>(𝑎𝐿)=𝛽, therefore 𝑎𝐿⊭𝑤𝜙. On the other hand  is working as in the previous case on the same data: it will only visit at most M elements on 𝜈′, so it will stop on "yes", contradicting the hypothesis that it is correct. ◻

Remark 4
Note that we have proven something stronger than undecidability: undecidability is related to Turing machines, while we have proven that with the available information no finite method can decide the problem, that is, we have problem the unrealizability of the problem [4, 22].

The undecidability result depends on having 𝜈[𝑘](𝑎)>0 for all k. If for some m we have 𝜈[𝑚](𝑎)=0, then for all 𝑘≥𝑚 we have (𝑎𝑘)=−∞ independently of the values 𝜈[𝑘](𝑎) for 𝑘>𝑚. This entails that, in the previous example, in order to ascertain whether 𝑎𝐿⊨𝑤𝜙 we only have to check strings 𝑎𝑘 for 𝑘<𝑚 and the problem is therefore decidable.

In terms of the Cartesian graph, 𝑎𝐿 corresponds to a path 𝜋𝐿 and decidability depends on the fact that in order to check matching we only have to extend the path up to m: after that the value of the objective in all paths that extend 𝜋𝐿 is −∞.

The presence of zero-valued observations, even an infinite number of them, does not always guarantee decidability.

Example VI
Let 𝜙≡(𝑎𝑏)∗, 𝑎,𝑏∈Σ, and |Σ|>2. Suppose 𝜈[𝑘](𝑎)=0 for k odd and 𝜈[𝑘](𝑏)=0 for k even. Then ((𝑎𝑏)𝑛)>−∞ for all n, and the same considerations of the theorem apply considering sequences of groups ab (for which 𝜈[2𝑘](𝑎)⋅𝜈[2𝑘+1](𝑏)>0) in lieu of the symbol a of the demonstration.

However, if the values of k and a for which 𝜈[𝑘](𝑎)=0 are in sufficient number and randomly distributed, then the problem is almost always decidable.

Theorem 5
Suppose that for each 𝑎∈Σ, 𝜈[𝑘](𝑎)=0 infinitely often. Then with probability 1 STREAM-WEAK can be decided in finite time.

Before we prove the theorem, we need some additional constructions and results. For each 𝑎∈Σ, define the list

[𝑎]=[𝑘𝑎1,𝑘𝑎2,…]
(55)
with 𝑘𝑎𝑖<𝑘𝑎𝑖+1 and for each 𝑖∈ℕ, 𝜈[𝑘𝑎𝑖](𝑎)=0. That is, [a] is the list of indices of the observations in which a has zero probability of occurrence. Because of our hypothesis, each [a] is an infinite list of finite numbers.

Also, set

[𝑎]|𝑛=[𝑘|𝑘∈[𝑎],𝑘>𝑛];
(56)
[𝑎]|𝑛 is the portion of the list [a] with indices greater than n, that is, the list of indices 𝑘>𝑛 such that 𝜈[𝑘](𝑎)=0. From these lists, we build a list Ξ as follows:

figure a
where uniform(Σ) is a function that picks an element of Σ at random with uniform distribution. The list Ξ is a list of indices such that, for each 𝑘∈Ξ, there is an 𝑎∈Σ with 𝜈[𝑘](𝑎)=0. The particularity of Ξ is that we pick the indices i such a way that, for each k, the probability that 𝜈[𝑘](𝑎)=0 is uniform over Σ. The construction of the list Ξ is possible due to the hypothesis that each a has zero probability of observation infinitely often. Note that the list

Ξ=[𝜉1,𝜉2,…]
(57)
is also infinite, so it can never be built completely and, consequently, the algorithm never stops. However, in the proof of the theorem we shall only use finite parts of Ξ so one can imagine a lazy evaluation of the algorithm that only computes the portions that we need for the proof. From the construction of Ξ, it is easy to see that, for each 𝜉 and a,

ℙ[𝜈[𝜉𝑖](𝑎)=0]=1|Σ|
(58)
and, consequently,

ℙ[𝜈[𝜉𝑖](𝑎)>0]=|Σ|−1|Σ|
(59)
Lemma 4
Let 𝜋 be a path in a Cartesian graph. 𝜔[𝜋]∈Σ∗ the string that causes it to be followed, and let (𝜋)>−∞. Then, with probability 1, 𝜋 is finite.

Proof
Suppose that the lemma is not true, then there is 𝜖>0 such that

ℙ[𝜋 finite ]<1−𝜖
(60)
That is, ℙ[𝜋 infinite ]>𝜖, or

∀𝑛∈ℕ  ℙ[|𝜋|>𝑛]>𝜖
(61)
Consider the list Ξ, and the element 𝜉𝑘, with

𝑘>log1/𝜖log|Σ||Σ|−1
(62)
If |𝜋|>𝜉𝑘 then, for each 𝑖≤𝑘, if 𝜋[𝜉𝑖]=𝑎𝑖, it must be 𝜈[𝜉𝑖](𝑎𝑖)>0 (since, by hypothesis, (𝜔[𝜋])>−∞). This event has probability (|Σ|−1)/|Σ|, therefore

ℙ[𝜈[𝜉1](𝑎1)>0,…,𝜈[𝜉𝑘](𝑎𝑘)>0]=(|Σ|−1|Σ|)𝑘<𝜖
(63)
which contradicts (61). ◻

Proof of Theorem 5
Let 𝜔⊨𝛽𝜙; it is 𝜔⊭𝑤𝜙 if and only if there is 𝜔′ such that 𝜔𝜔′⊨𝛽′𝜙 with 𝛽′>𝛽. The string 𝜔𝜔′ corresponds to a path 𝜋 that, because of lemma 4, with probability 1 is finite, so the hypothesis 𝜔⊨𝑤𝜙 can be checked in finite time with respect to 𝜔′. With probability 1, there is a finite number of such finite paths, so the hypothesis can be checked, with probability 1, in finite time. ◻

Conclusions
In this paper we have considered the problem of detecting whether a string (or part of it) matches a regular expression when the symbols that we observe are subject to uncertainty. The main contributions of this paper are two: on the one hand, we consider the problem of matching the most likely substring of the input, a problem of considerable interest in applications, as the duration of the event that one want to detect may be unknown, and different events of interest may have overlapping structures. We have seen that considering sub-strings produces a bias towards shorter strings, a bias that can be compensated by minimizing the residual information—the information carried by the string that matching does not recover. On the other hand, we show that optimal detection in an infinite stream is undecidable, but becomes decidable with probability one under hypotheses often met in practical applications.

The regular expressions that we are presenting here are quite limited. In particular, they do not allow an efficient definition of counting (expressions like 𝑎[𝑛,𝑚], which is matched if the string contains between n and m symbols a). In principle, regular expressions do allow counting, as the previous expression is equivalent to

𝑎⋯𝑎⏞𝑛(𝜖+𝑎+𝑎𝑎+⋯+𝑎⋯𝑎⏞𝑚−𝑛)
(64)
but the implementation of such an expression is so inefficient as to make it impractical in all but the most trivial cases. One possibility to introduce counting as as part of a more general algebra (e.g., a query algebra) of which matching is part. In the example above, the query would be translated into a query with 𝑎∗ as a regular expression plus a condition on the result to ensure that the number of as is the desired. It is not an optimal solution, and the efficient integration of better solutions in the framework presented here is still an open problem.

