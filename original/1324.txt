We study an agglomerative clustering problem motivated by interactive glyphs in geo-visualization. Consider a set of disjoint square glyphs on an interactive map. When the user zooms out, the glyphs grow in size relative to the map, possibly with different speeds. When two glyphs intersect, we wish to replace them by a new glyph that captures the information of the intersecting glyphs. We present a fully dynamic kinetic data structure that maintains a set of n disjoint growing squares. Our data structure uses 𝑂(𝑛log𝑛loglog𝑛) space, supports queries in worst case 𝑂(log2𝑛) time, and updates in 𝑂(log5𝑛) amortized time. This leads to an 𝑂(𝑛𝛼(𝑛)log5𝑛) time algorithm to solve the agglomerative clustering problem. This is a significant improvement over the current best 𝑂(𝑛2) time algorithms.

Introduction
We study an agglomerative clustering problem motivated by interactive glyphs in geo-visualization. Our specific use case stems from the eHumanities, but similar visualizations are used in a variety of application areas. GlamMap [6]Footnote1 is a visual analytics tool which allows the user to interactively explore datasets which contain (at least) the following metadata of a book collection: author, title, publisher, year of publication, and location (city) of publisher. Each book is depicted by a square, color-coded by publication year, and placed on a map according to the location of its publisher. Overlapping squares (many books are published in Leipzig, for example) are recursively aggregated into a larger glyph until all glyphs are disjoint (see Fig. 1). As the user zooms out, the glyphs “grow” relative to the map to remain legible. As a result, glyphs start to overlap and need to be merged into larger glyphs to keep the map clear and uncluttered. It is straightforward to compute the resulting agglomerative clustering whenever a data set is loaded and to serve it to the user as needed by the current zoom level. However, GlamMap allows the user to filter by author, title, year of publication, or other applicable meta data. It is impossible to pre-compute the clustering for any conceivable combination of filter values. To allow the user to browse at interactive speeds, we hence need an efficient agglomerative clustering algorithm for growing squares (glyphs). Interesting bibliographic data sets (such as the catalogue of WorldCat, which contains more than 321 million library records at hundreds of thousands of distinct locations) are too large by a significant margin to be clustered fast enough with the current state-of-the-art 𝑂(𝑛2) time algorithms (here n is the number of squares or glyphs).

Fig. 1
figure 1
Zooming out in GlamMap will merge overlapping squares. This figure shows a sequence of three steps zooming out from the surroundings of Leipzig

Full size image
In this paper we formally analyze the problem and present a fully dynamic data structure that uses 𝑂(𝑛log𝑛loglog𝑛) space, supports updates in 𝑂(log5𝑛) amortized time, and queries in 𝑂(log2𝑛) time, which allows us to compute the agglomerative clustering for n glyphs in 𝑂(𝑛𝛼(𝑛)log5𝑛) time. Here, 𝛼 is the extremely slowly growing inverse Ackermann function. To the best of our knowledge, this is the first fully dynamic clustering algorithm which beats the classic 𝑂(𝑛2) time bound.

Formal problem statement. Let P be a set of points in ℝ2 (the locations of publishers from our example). Each point 𝑝∈𝑃 has a positive weight 𝑝𝑤 (number of books published in this city). Given a “time” parameter t, we interpret the points in P as squares. More specifically, let ◻𝑝(𝑡) be the square centered at p with width 𝑡𝑝𝑤. For ease of exposition we assume all x and y coordinates to be unique. With some abuse of notation we may refer to P as a set of squares rather than the set of center points of squares. Observe that initially, i.e. at 𝑡=0, all squares in P are disjoint. As t increases, the squares in P grow, and hence they may start to intersect. When two squares ◻𝑝(𝑡) and ◻𝑞(𝑡) intersect at time t, we remove both p and q and replace them by a new point z, which is located at the weighted average of p and q and has the sum of their weights as its weight. More formally, 𝑧=𝜔𝑝+(1−𝜔)𝑞, with 𝜔=𝑝𝑤/(𝑝𝑤+𝑞𝑤), and has weight 𝑧𝑤=𝑝𝑤+𝑞𝑤 (see Fig. 2).

Fig. 2
figure 2
The timeline of squares that grow and merge as they touch

Full size image
Related Work. Funke, Krumpe, and Storandt [7] introduced so-called “ball tournaments”, a related, but simpler, problem, which is motivated by map labeling. Their input is a set of balls in ℝ𝑑 with an associated set of priorities. The balls grow linearly and whenever two balls touch, the ball with the lower priority is eliminated. The goal is to compute the elimination sequence efficiently. Bahrdt et al. [4] and Funke and Storandt [8] improved upon the initial results and presented bounds which depend on the ratio 𝛥 of the largest to the smallest radius. Specifically, Funke and Storandt [8] show how to compute an elimination sequence for n balls in 𝑂(𝑛log𝛥(log+𝛥𝑑−1)) time in arbitrary dimensions and in 𝑂(𝐶𝑛polylog𝑛) time for 𝑑=2, where C denotes the number of different radii. In our setting eliminations are not sufficient, since merged glyphs need to be re-inserted. Furthermore, as opposed to typical map labeling problems where labels come in a fixed range of sizes, the sizes of our glyphs can vary by a factor of 10.000 or more (Amsterdam with its many well-established publishers vs. Kaldenkirchen with one obscure one).

Ahn et al. [2] recently and independently developed the first sub-quadratic algorithms to compute elimination orders for ball tournaments. Their results apply to balls and boxes in two or higher dimensions. Specifically, for squares in two dimensions they can compute an elimination order in 𝑂(𝑛log4𝑛) time. Their results critically depend on the fact that they know the elimination priorities at the start of their algorithm and that they only have to handle deletions. Hence they do not have to run an explicit simulation of the growth process and can achieve their results by the clever use of advanced data structures. In contrast, we are handling the fully dynamic setting with both insertions and deletions, and without a specified set of priorities. In fact, our algorithm can easily be adapted to solve the ball tournament problem for squares without increasing the running time.

Our clustering problem combines both dynamic and kinetic aspects: squares grow, which is a restricted form of movement, and squares are both inserted and deleted. There are comparatively few papers which tackle dynamic kinetic problems. Alexandron et al. [3] present a dynamic and kinetic data structure for maintaining the convex hull of points (or analogously, the lower envelope of lines) moving in ℝ2. Their data structure processes (in expectation) 𝑂(𝑛2𝛽𝑠+2(𝑛)log𝑛) events in 𝑂(log2𝑛) time each. Here, 𝛽𝑠(𝑛)=𝜆𝑠(𝑛)/𝑛, and 𝜆𝑠(𝑛) is the maximum length of a Davenport-Schinzel sequence on n symbols of order s. Agarwal et al. [1] present dynamic and kinetic data structures for maintaining the closest pair and all nearest neighbors. The expected number of events processed is again roughly 𝑂(𝑛2𝛽𝑠+2(𝑛)polylog𝑛), each of which can be handled in 𝑂(polylog𝑛) expected time. We are using some ideas and constructions which are similar in flavor to the structures presented in their paper.

Results. We present a fully dynamic data structure that can maintain a set P of disjoint growing squares. At any time, it supports inserting a new square that is disjoint from the squares in P, or removing an existing square from P. Our data structure will produce an intersection event at every time t when two squares ◻𝑝 and ◻𝑞, with 𝑝,𝑞∈𝑃, start to intersect (i.e. at any time before t, all squares in P remain disjoint). At such a time, we then have to delete some of the squares, to make sure that the squares in P are again disjoint. Our data structure can handle a sequence of 𝑚≥𝑛 updates in a total of 𝑂(𝑚𝛼(𝑛)log5𝑛) time, each update is performed in 𝑂(log5𝑛) amortized time.

Our Approach. In order to efficiently keep track of which squares in our set P are about to intersect, we combine the following two ideas.

The first is that we can focus on specific kinds of intersections. In particular, if we can, for a given square ◻𝑞, track which square ◻𝑝 will intersect the right side of ◻𝑞 first, then we can analogously track similar intersection events for the left, top and bottom sides of ◻𝑞. Moreover, we only need to explicitly consider two sides of ◻𝑞, say the top and right sides: if, e.g., the left side of ◻𝑞 intersects some square ◻𝑟, then symmetrically the right side of ◻𝑟 intersects ◻𝑞 and thus we already track that event. We describe our data structure, built on two-layered range trees, for intersections with the right side of ◻𝑞, and then combine two copies to make sure that all squares in P remain disjoint. We formalize this in Sect. 2.

The second idea is that, instead of having each square ◻𝑞 independently track which ◻𝑝 will intersect it first, we can intelligently group squares that track (roughly) the same subset of P. We do so efficiently using the layers of search trees. This saves on space used by our data structure, in the form of certificates. It also reduces the running time of handling a sequence of updates, simply because fewer certicates fail or need to be updated. We concretize this in Sect. 3.

While our data structure is conceptually simple, the exact implementation is somewhat intricate, and the details are numerous. Our initial analysis shows that our data structure maintains 𝑂(log2𝑛) certificates for every secondary node in our range trees, so 𝑂(𝑛log3𝑛) in total, and supports dynamic updates in 𝑂(log5𝑛) amortized time. This allows us to simulate the process of growing the squares in P –and thus solve the agglomerative glyph clustering problem– in 𝑂(𝑛𝛼(𝑛)log5𝑛) time using 𝑂(𝑛log3𝑛) space. In Sect. 4 we analyze the relation between canonical subsets in dominance queries. We show that for two range trees 𝑇𝑅 and 𝑇𝐵 in ℝ𝑑, the number of pairs of nodes 𝑟∈𝑇𝑅 and 𝑏∈𝑇𝐵 for which r occurs in the canonical subset of a dominance query defined by b and vice versa is only 𝑂(𝑛(log𝑛loglog𝑛)𝑑−1), where n is the total size of 𝑇𝑅 and 𝑇𝐵. This implies that the number of linking certificates that our data structure maintains, as well as the total space used, is actually only 𝑂(𝑛log𝑛loglog𝑛). Since the linking certificates provide an efficient representation of all dominance relations between two point sets (or within a point set), we believe that this result is of independent interest as well.

In the preliminary version of this paper, we partitioned space in a different way [5]. This gave us an 𝑂(𝑛𝛼(𝑛)log7𝑛) time algorithm that used 𝑂(𝑛(log𝑛loglog𝑛)2) space. The improvements we made, which we describe in this paper, lead to a reduction of two log factors in the running time, and a log𝑛loglog𝑛 factor of space usage.

Geometric Properties
Fig. 3
figure 3
Squares E(q) east of ◻𝑞. ◻𝑝∈𝐸(𝑞) intersects ◻𝑞 when 𝑥(𝑟𝑞)≥𝑥(ℓ𝑝)

Full size image
Our approach, as described above, will be to focus on specific types of intersections. In particular, for any given square ◻𝑞 we are interested in tracking intersections with the right side of ◻𝑞. We observe that the first square ◻𝑝 that is to intersect the right side of ◻𝑞 will have (i) its left side touch ◻𝑞 first, and (ii) its center p in a cone east of q. We refer to all squares having their center in this cone as E(q). See Fig. 3 for an example. Let us introduce some notation and formally capture these two observations.

We are interested, for all points 𝑞∈𝑃, in a cone east of them, which is the set of points {(𝑥,𝑦)∈ℝ2 | 𝑥−𝑥(𝑞)≥|𝑦−𝑦(𝑞)|}. North, south and west cones can be defined analogously. Let ℓ𝑞 denote the midpoint of the left edge of a square ◻𝑞, and let 𝑟𝑞 denote the midpoint of the right edge of ◻𝑞. Similarly, let the midpoints of the top and bottom edges of ◻𝑞 be denoted by ↑𝑞 and ↓𝑞, respectively. Furthermore, let E(q) denote the subset of points of P lying in the cone east of q, and let 𝐿(𝑞)={ℓ𝑝∣𝑝∈𝐸(𝑞)} denote the set of midpoints of left edges of the squares of those points.

We remark that points 𝑝∈𝑃 can simultaneously lie in, e.g., the east and south cones induced by any 𝑞∈𝑃. This means that the top left corner of ◻𝑝 will first intersect with the bottom right corner of ◻𝑞. In such cases it is not necessary to track the square in both copies of our data structure. An arbitrary choice to break this degeneracy can be made. The same holds for the other pairs of neighboring cones.

Observation 1
Let 𝑝∈𝐸(𝑞) be a point east of point q. The squares ◻𝑞(𝑡) and ◻𝑝(𝑡) intersect at time t if and only if 𝑥(𝑟𝑞(𝑡))≥𝑥(ℓ𝑝(𝑡)) at time t.

Proof
Clearly, when 𝑥(𝑟𝑞(𝑡))<𝑥(ℓ𝑝(𝑡)), then since the rightmost point of ◻𝑞 is left of the leftmost point of ◻𝑝, the squares do not intersect. For the other direction, observe that because p is in the cone east of q, it holds that 𝑥(𝑝)−𝑥(𝑞)≥|𝑦(𝑝)−𝑦(𝑞)|. Since 𝑥(𝑟𝑞(𝑡))≥𝑥(ℓ𝑝(𝑡)), it holds that 𝑥(𝑟𝑞(𝑡))−𝑥(ℓ𝑝(𝑡))+𝑥(𝑝)−𝑥(𝑞)≥𝑥(𝑝)−𝑥(𝑞)≥|𝑦(𝑝)−𝑦(𝑞)|. Because ◻𝑞 and ◻𝑝 are squares, either 𝑦(↓𝑞(𝑡))≤𝑦(↑𝑝(𝑡)) or 𝑦(↑𝑞(𝑡))≥𝑦(↓𝑝(𝑡)). In either case, both the horizontal and vertical intervals of ◻𝑞 and ◻𝑝 overlap, and hence they intersect. ◻

Following the above observations, we observe another important detail:

Observation 2
Let 𝑡∗ be the first time at which a square ◻𝑝 of a point 𝑝∈𝐸(𝑞) intersects ◻𝑞. We then have that 𝑥(𝑟𝑞(𝑡∗))=𝑥(ℓ𝑝(𝑡∗)), and ℓ𝑝(𝑡∗) is the point with minimum x-coordinate among the points in L(q) at time 𝑡∗.

Proof
It is easy to see that 𝑥(𝑟𝑞(𝑡∗))=𝑥(ℓ𝑝(𝑡∗)). To see that ℓ𝑝(𝑡∗) has minimum x-coordinate, we assume it is not for a contradiction. Let r be the point that does have minimum x-coordinate, thus 𝑥(ℓ𝑟(𝑡∗))<𝑥(ℓ𝑝(𝑡∗)). Since 𝑥(𝑟𝑞(𝑡∗))=𝑥(ℓ𝑝(𝑡∗)), we get 𝑥(ℓ𝑟(𝑡∗))<𝑥(𝑟𝑞(𝑡∗)). But r is east of q, so 𝑥(𝑟)>𝑥(𝑞) and thus, following a same type of argument as for Observation 1, ◻𝑞 and ◻𝑟 intersect. Because all squares grow linearly, there must be some 𝑡′<𝑡∗ when 𝑥(𝑟𝑞(𝑡′))=𝑥(ℓ𝑟(𝑡′)), and ◻𝑞 first intersected ◻𝑟. But then 𝑡∗ is not the first time at which a square east of q intersects ◻𝑞. Contradiction, thus ℓ𝑝(𝑡∗) has minimum x-coordinate in L(q) at time 𝑡∗. ◻

A Kinetic Data Structure for Growing Squares
In this section we present a data structure that can detect the first intersection among a dynamic set of disjoint growing squares. In particular, we describe a data structure that can detect intersections between all pairs of squares ◻𝑝,◻𝑞 in P such that  𝑝∈𝐸(𝑞). We then use two copies of this data structure, one for east/west and one for north/south intersections, to detect the first intersection among all pairs of squares.

We describe the data structure itself in Sect. 3.1, and we briefly describe how to query it in Sect. 3.2. We deal with updates –inserting a new square into P or deleting an existing square from P– in Sect. 3.3. In Sect. 3.4 we analyze the total number of events that we have to process, and the time required to do so, when we simulate growing the squares.

The Data Structure
Our data structure consists of two trees 𝑇𝐿 and 𝑇𝑅, both with two layers, and a set of certificates linking nodes in 𝑇𝐿 to nodes in 𝑇𝑅. These trees essentially form two 2D range trees on the centers of the squares in P, using rotated axes (see Sect. 2), so that we can easily query the tree for E(q), for any 𝑞∈𝑃. The second layer of 𝑇𝐿 will double as a kinetic tournament tracking the left midpoints of the squares. Similarly, 𝑇𝑅 will track the right midpoints of the squares.

The Layered Trees. The tree 𝑇𝐿 is a 2D-range tree storing the center points in P: in the rotated plane suggested in Sect. 2, the first layer indexes the first coordinate 𝑥′, while the second layer indexes the second coordinate 𝑦′. Each layer is implemented by a weight-balanced binary search tree (BB[𝛼] tree) [10], and each node 𝜇 corresponds to a canonical subset 𝑃𝜇 of points stored in the leaves of the subtree rooted at 𝜇. Let 𝐿𝜇 denote the set of left midpoints of squares corresponding to the set 𝑃𝜇.

Consider the associated structure 𝑋𝐿𝑢 of some primary node 𝑢∈𝑇𝐿. We consider 𝑋𝐿𝑢 as a kinetic tournament on the x-coordinates of the points 𝐿𝑢 [1]. More specifically, every node 𝑣∈𝑋𝐿𝑢 stores the midpoint ℓ𝑝 in 𝐿𝑣 with minimum x-coordinate, and will maintain certificates that guarantee this [1].

The tree 𝑇𝑅 has the same structure as 𝑇𝐿, but the associated structure 𝑋𝑅𝑢, for some primary node u, –which again doubles as a kinetic tournament– maintains not the minimum, but the maximum x-coordinate of the points in 𝑅𝑢. Analogous to 𝐿𝑢, 𝑅𝑢 is the set of right midpoints of the squares (with center points) in 𝑃𝑢. Hence, every secondary node 𝑣∈𝑋𝑅𝑢 stores the midpoint 𝑟𝑞 in 𝑅𝑣 with maximum x-coordinate.

Linking the Trees. Kinetic data structures maintain certicates that guarantee that some property holds at least until some point in the (nearby) future. Maintaining a kinetic data structure revolves for a large part around updating certificates as they reach that point in time and break. We want to maintain the property that all squares in P are disjoint, and thus we next describe how to add linking certificates between the kinetic tournament nodes in the trees 𝑇𝐿 and 𝑇𝑅 that guarantee that the squares are disjoint. More specifically, a secondary node 𝑣∈𝑇𝐿 represents a set 𝑃𝑣⊆𝑃 of squares (the canonical subset of node v). We describe how we add certificates that guarantee that any ◻𝑞, with 𝑞∈𝑃𝑣, is disjoint from all ◻𝑝, with 𝑝∈𝐸(𝑞). These points q are represented by secondary nodes 𝑤∈𝑇𝑅, and so we can discuss linking nodes instead of squares.

Consider a point q. There are 𝑂(log2𝑛) nodes in the secondary tree of 𝑇𝐿 whose canonical subsets together represent exactly E(q). These nodes, in their secondary function as kinetic tournament nodes, represent the points in L(q). So, in total q is interested in a set 𝑄𝐿(𝑞) of 𝑂(log2𝑛) kinetic tournament nodes. It now follows from Observation 2 that if we were to add certificates certifying that 𝑟𝑞 is left of the point stored at the nodes in 𝑄𝐿(𝑞), we can detect when ◻𝑞 intersects with a square of a point in E(q). However, as there may be many points q interested in a particular kinetic tournament node v (an example is given in Fig. 4), we cannot afford to maintain all of these certificates. The main idea is to represent all of these points q by a number of canonical subsets of nodes in 𝑇𝑅, and add certificates to only these nodes.

Fig. 4
figure 4
The red points, on two convex chains, are all interested in the same set 𝑄𝐿(𝑞). In general a linear number of points may be interested in a given kinetic tournament node

Full size image
Consider a point p. Symmetric to the above construction, there are 𝑂(log2𝑛) nodes in kinetic tournaments associated with 𝑇𝑅 that together exactly represent the (right sides of) squares ◻𝑞 west of p, for which 𝑝∈𝐸(𝑞). Let 𝑄𝑅(𝑝) denote this set.

Fig. 5
figure 5
The points 𝑚⎯⎯⎯⎯𝑤 and 𝑚⎯⎯⎯𝑣 are defined by a pair of secondary nodes 𝑤∈𝑇𝑅𝑢′, and 𝑣∈𝑇𝐿𝑢. If 𝑣∈𝑄𝐿(𝑚⎯⎯⎯⎯𝑤) and 𝑤∈𝑄(𝑚⎯⎯⎯𝑣), then we add a linking certificate between the rightmost midpoint 𝑟𝑞, 𝑞∈𝑃𝑤, and the leftmost midpoint ℓ𝑝, 𝑝∈𝑃𝑣, certifying that the squares in 𝑃𝑤 are disjoint from those in 𝑃𝑣

Full size image
Next, we extend the definitions of 𝑄𝐿 and 𝑄𝑅 to kinetic tournament nodes. To this end, we first associate each kinetic tournament node with a (query) point in ℝ2. Consider a kinetic tournament node v in a tournament 𝑋𝐿𝑢, associated with node u in the primary 𝑇𝐿. We denote the coordinates of a point p in the rotated coordinate system using 𝑥′(𝑝) and 𝑦′(𝑝). Let, in coordinates of the rotated system, 𝑚⎯⎯⎯𝑣=(min𝑎∈𝑃𝑢𝑥′(𝑎),min𝑏∈𝑃𝑣𝑦′(𝑏)) be the point associated with v (note that we take the minimum over different sets 𝑃𝑢 and 𝑃𝑣 for the different coordinates), and define 𝑄𝑅(𝑣)=𝑄𝑅(𝑚⎯⎯⎯𝑣). Symmetrically, for a node w in a tournament 𝑋𝑅𝑢, with 𝑢∈𝑇𝑅, we define 𝑚⎯⎯⎯⎯𝑤=(max𝑎∈𝑃𝑢𝑥′(𝑎),max𝑏∈𝑃𝑣𝑦′(𝑏)) and 𝑄𝐿(𝑤)=𝑄𝐿(𝑚⎯⎯⎯⎯𝑤) (see Fig. 5).

We now add a linking certificate between every pair of secondary nodes 𝑣∈𝑇𝐿 and 𝑤∈𝑇𝑅 for which (i) v is a node in the canonical subset of w, that is 𝑣∈𝑄𝐿(𝑤), and (ii) w is a node in the canonical subset of v, 𝑤∈𝑄𝑅(𝑣). Such a certificate will guarantee that the midpoint 𝑟𝑞 currently stored at w lies left of the point ℓ𝑝 stored at v.

Lemma 3
Every kinetic tournament node is involved in 𝑂(log2𝑛) linking certificates, and thus every point p is associated with at most 𝑂(log4𝑛) certificates.

Proof
We start with the first part of the lemma statement. Every secondary node 𝑣∈𝑇𝐿 can be associated with at most 𝑂(log2𝑛) linking certificates: one with each node in 𝑄𝑅(𝑣). Analogously, every secondary node 𝑤∈𝑇𝑅 can be associated with at most 𝑂(log2𝑛) linking certificates: one for each node in 𝑄𝐿(𝑤).

Every point p occurs in the canonical subset of at most 𝑂(log2𝑛) kinetic tournament nodes in the second layers of both 𝑇𝐿 and 𝑇𝑅: p is stored in 𝑂(log𝑛) leaves of the kinetic tournaments, and in each such a tournament it can participate in 𝑂(log𝑛) certificates (at most two tournament certificates in 𝑂(log𝑛) nodes). As we argued above, each such a node itself occurs in at most 𝑂(log2𝑛) certificates. ◻

What remains to argue is that we can still detect the first upcoming intersection.

Lemma 4
Consider two sets of elements, say blue elements B and red elements R, stored in the leaves of two binary search trees 𝑇𝐵 and 𝑇𝑅, respectively, and let 𝑝∈𝐵 and 𝑞∈𝑅, with 𝑞<𝑝, be leaves in trees 𝑇𝐵 and 𝑇𝑅, respectively. There is a pair of nodes 𝑏∈𝑇𝐵 and 𝑟∈𝑇𝑅, such that (i) 𝑝∈𝑃𝑏 and 𝑏∈𝐶(𝑇𝐵,[𝑥′,∞)), and (ii)  𝑞∈𝑃𝑟 and 𝑟∈𝐶(𝑇𝑅,(−∞,𝑥]), where 𝑥′=max𝑃𝑟, 𝑥=min𝑃𝑏, and 𝐶(𝑇𝑆,𝐼) denotes the minimal set of nodes in 𝑇𝑆 whose canonical subsets together represent exactly the elements of 𝑆∩𝐼.

Fig. 6
figure 6
The nodes b and r in the trees 𝑇𝐵 and 𝑇𝑅

Full size image
Proof
Let b be the first node on the path from the root of 𝑇𝐵 to p such that the canonical subset 𝑃𝑏 of b is contained in the interval [𝑞,∞), but the canonical subset of the parent of b is not. We define b to be the root of 𝑇𝐵 if no such node exists. We define r to be the first node on the path from the root of 𝑇𝑅 to q for which 𝑃𝑟 is contained in (−∞,𝑥] but the canonical subset of the parent is not. We again define r as the root of 𝑇𝑅 if no such node exists. See Fig. 6. Clearly, we now directly have that r is one of the nodes whose canonical subsets form 𝑅∩(−∞,𝑥], and that 𝑞∈𝑃𝑟 (as r lies on the search path to q). It is also easy to see that 𝑝∈𝑃𝑏, as b lies on the search path to p. All that remains is to show that b is one of the canonical subsets that together form 𝐵∩[𝑥′,∞). This follows from the fact that 𝑞≤𝑥′<𝑥≤𝑝 –and thus 𝑃𝑏 is indeed a subset of [𝑥′,∞)– and the fact that the subset of the parent v of b contains an element smaller than q, and can thus not be a subset of [𝑥′,∞). ◻

Lemma 5
Let ◻𝑝 and ◻𝑞, with 𝑝∈𝐸(𝑞), be the first pair of squares to intersect, at some time 𝑡∗. There is a pair of nodes v, w with a linking certificate that fails at time 𝑡∗.

Proof
Consider the leaves representing p and q in 𝑇𝐿 and 𝑇𝑅, respectively. Applying Lemma 4, we get that there is a pair of nodes 𝑢∈𝑇𝐿 and 𝑢′∈𝑇𝑅 that, among other properties, have 𝑝∈𝑃𝑢 and 𝑞∈𝑃𝑢′. Hence, we can apply Lemma 4 again on the associated trees of u and 𝑢′, giving us nodes 𝑣∈𝑋𝐿𝑢 and 𝑤∈𝑋𝑅𝑢′ with 𝑝∈𝑃𝑣 and 𝑞∈𝑃𝑤. In addition, these two applications of Lemma 4 give us two points (x, y) and (𝑥′,𝑦′) –with coordinates in the rotated system– such that:

𝑃𝑢 occurs as a canonical subset representing 𝑃∩([𝑥′,∞)×ℝ), and

𝑃𝑣 occurs as a canonical subset representing 𝑃𝑢∩(ℝ×[𝑦′,∞)),

and such that

𝑃𝑢′ occurs as a canonical subset representing 𝑃∩((−∞,𝑥]×ℝ), and

𝑃𝑤 occurs as a canonical subset representing 𝑃𝑢′∩(ℝ×(−∞,𝑦]).

We combine these first two facts and observe that 𝑚⎯⎯⎯⎯𝑤=(𝑥′,𝑦′). This gives us that 𝑃𝑣 occurs as a canonical subset representing 𝑃∩([𝑥′,∞)×[𝑦′,∞))=𝐸((𝑥′,𝑦′)), and hence 𝑣∈𝑄𝐿(𝑚⎯⎯⎯⎯𝑤)=𝑄𝐿(𝑤). Analogously, combining the latter two facts and 𝑚⎯⎯⎯𝑣=(𝑥,𝑦) gives us 𝑤∈𝑄𝑅(𝑣). Therefore, v and w have a linking certificate. This linking certificate involves the leftmost left edge midpoint ℓ𝑎 for some point 𝑎∈𝑃𝑣 and the rightmost right edge midpoint 𝑟𝑏 for some point 𝑏∈𝑃𝑤. Since 𝑝∈𝑃𝑣 and 𝑞∈𝑃𝑤, we have that 𝑟𝑞≤𝑟𝑏 and ℓ𝑎≤ℓ𝑝, and thus we detect their intersection at time 𝑡∗. ◻

From Lemma 5 it follows that we can now detect the first intersection between a pair of squares ◻𝑝 and ◻𝑞, with 𝑝∈𝐸(𝑞), so any east/west intersection. We define an analogous data structure for detecting north/south intersections.

Space Usage. Our trees 𝑇𝐿 and 𝑇𝑅 are range trees in ℝ2, and thus use 𝑂(𝑛log𝑛) space. However, it is easy to see that this is dominated by the space required to store the certificates. For all 𝑂(𝑛log𝑛) kinetic tournament nodes we store at most 𝑂(log2𝑛) certificates (Lemma 3), and thus the total space used by our data structure is 𝑂(𝑛log3𝑛). In Sect. 4 we will show that the number of certificates we maintain, and thus the space our data structure uses, is actually only 𝑂(𝑛log𝑛loglog𝑛).

Answering Queries
The basic query that our data structure supports is testing if a query square ◻𝑞 currently intersects with a square ◻𝑝 in P, with 𝑝∈𝐸(𝑞). To this end, we simply select the 𝑂(log2𝑛) kinetic tournament nodes from 𝑇𝐿 whose canonical subsets together represent E(q). For each such a node v we check if the x-coordinate of the left midpoint ℓ𝑝 stored at that node (which has minimum x-coordinate among 𝐿𝑣) is smaller than the x-coordinate of 𝑟𝑞. If so, the squares intersect. The correctness of our query algorithm directly follows from Observation 1. The total time required for a query is equivalent to the query time of a 2D range tree, which is 𝑂(log2𝑛). We can similarly test if a given query point q is contained in a square ◻𝑝, with 𝑝∈𝐸(𝑞).

To check for intersections with squares p west of q, we can use 𝑇𝑅 in a way symmetrical to the procedure described above. Our full data structure will contain trees analogous to 𝑇𝐿 and 𝑇𝑅 that can be used to check if there is a square ◻𝑝∈𝑃, with p either north or south of q, that intersects ◻𝑞. Again, a similar query for containment of a query point q in a square ◻𝑝 is also supported.

In summary, we can at any point in time test if a given query square ◻𝑞 currently intersects any ◻𝑝 in P, in 𝑂(log2𝑛) time. We can in the same running time test if a query point q is currently contained in any square ◻𝑝 in P.

Inserting or Deleting a Square
At an insertion or deletion of a square ◻𝑝 we proceed in three steps. First, we update the individual trees 𝑇𝐿 and 𝑇𝑅, making sure that they once again represent 2D range trees of all center points in P, and that the secondary data structures are, by themselves, correct kinetic tournaments. For each kinetic tournament node in 𝑇𝐿 affected by the update, we then query 𝑇𝑅 to find a new set of linking certificates. We update the affected kinetic tournament nodes in 𝑇𝑅 analogously. Finally, we update the global event queue that stores all certificates.

Lemma 6
Inserting a square into 𝑇𝐿 or deleting a square from 𝑇𝐿 takes 𝑂(log2𝑛) amortized time.

Proof
We use the following standard procedure for updating the two-level BB[𝛼] trees 𝑇𝐿 in 𝑂(log2𝑛) amortized time. An update (insertion or deletion) in a secondary data structure can easily be handled in 𝑂(log𝑛) time. When we insert into or delete an element x in a BB[𝛼] tree that has associated data structures, we add or remove the leaf that contains x, rebalance the tree by rotations, and finally add or remove x from the associated data structures. When we do a left rotation around an edge (𝜇,𝜈) we have to build a new associated data structure for node 𝜇 from scratch. See Fig. 7. Right rotations are handled analogously. It is well known that if building the associated data structure at node 𝜇 takes 𝑂(|𝑃𝜇|log𝑐|𝑃𝜇|) time, for some 𝑐≥0, then the costs of all rebalancing operations in a sequence of m insertions and deletions takes a total of 𝑂(𝑚log𝑐+1𝑛) time, where n is the maximum size of the tree at any time [9]. We can build a new kinetic tournament 𝑋𝐿𝑢 for node u (using the associated data structures at its children) in linear time. Note that this cost excludes updating the global event queue.

It then follows that the cost of our rebalancing operations is at most 𝑂(𝑚log𝑛). This is dominated by the total number of nodes created and deleted, 𝑂(𝑚log2𝑛), during these operations. Hence, we can insert or delete a point (square) in 𝑇𝐿 in 𝑂(log2𝑛) amortized time. ◻

Fig. 7
figure 7
After a left rotation around an edge (𝜇,𝜈), the associated data structure 𝑇𝜇 of node 𝜇 (pink) has to be rebuilt from scratch as its canonical subset has changed. For node 𝜈 we can simply use the old associated data of node 𝜇. No other nodes are affected

Full size image
Analogous to Lemma 6 we can update 𝑇𝑅 in 𝑂(log2𝑛) amortized time. Next, we update the linking certificates. We say that a kinetic tournament node v in 𝑇𝐿 is affected by an update if (i) the update added or removed a leaf node in the subtree rooted at v, (ii) node v was involved in a tree rotation, or (iii) v occurs in a newly built associated tree 𝑋𝐿𝑢 (for some node u). Let 𝐿𝑖 denote the set of nodes affected by update i. Analogously, we define the set of nodes 𝑅𝑖 of 𝑇𝑅 affected by the update. For each node 𝑣∈𝐿𝑖, we query 𝑇𝑅 to find the set of 𝑂(log2𝑛) nodes whose canonical subsets represent 𝑄𝑅(𝑣). For each node w in this set, we test if we have to add a linking certificate between v and w. As we show next, this takes constant time for each node w, and thus 𝑂(∑𝑖|𝐿𝑖|log2𝑛) time in total, for all nodes v. We update the linking certificates for all nodes in 𝑅𝑖 analogously.

We have to add a link between a node 𝑤∈𝑄𝑅(𝑣) and v if and only if we also have 𝑣∈𝑄𝐿(𝑤). We test this as follows. Let u be the node whose associated tree 𝑋𝐿𝑢 contains v. We have that, using the notation introduced in Lemma 4 and coordinates in the rotated system, 𝑣∈𝑄𝐿(𝑤) if and only if 𝑢∈𝐶(𝑇𝐿,[𝑚⎯⎯⎯⎯𝑤𝑥,∞)), and 𝑣∈𝐶(𝑋𝐿𝑢,[𝑚⎯⎯⎯⎯𝑤𝑦,∞)). We can test each of these conditions in constant time:

Observation 7
Let q be a query point in ℝ1, let v be a node in a binary search tree T, and let 𝑥𝑝=min𝑃𝑝 of the parent p of v in T, or 𝑥𝑝=−∞ if no such node exists. We have that 𝑣∈𝐶(𝑇,[𝑞,∞)) if and only if 𝑞≤min𝑃𝑣 and 𝑞>𝑥𝑝.

Proof
We start with the if direction. Since 𝑞>𝑥𝑝, it holds that 𝑃𝑝⊄[𝑞,∞) and hence, 𝑝∉𝐶(𝑇,[𝑞,∞)). However 𝑞≤min𝑃𝑣 and so 𝑃𝑣⊂[𝑞,∞). Clearly 𝑣∈𝐶(𝑇,[𝑞,∞)).

For the other direction, observe that 𝑣∈𝐶(𝑇,[𝑞,∞)) implies that 𝑃𝑣⊂[𝑞,∞) and so, 𝑞≤min𝑃𝑣. It also implies that 𝑝∉𝐶(𝑇,[𝑞,∞)), hence, 𝑃𝑝∖𝑃𝑣⊄[𝑞,∞).

It therefore must hold that 𝑞>𝑥𝑝. ◻

Finally, we delete all certificates involving no longer existing nodes from our global event queue, and replace them by all newly created certificates. This takes 𝑂(log𝑛) time per certificate. We charge the cost of deleting a certificate to when it gets created. Since every node v affected creates at most 𝑂(log2𝑛) new certificates, all that remains is to bound the total number of affected nodes. We can show this using basically the same argument as we used to bound the update time. This leads to the following result.

Lemma 8
Inserting a disjoint square into P, or deleting a square from P takes 𝑂(log5𝑛) amortized time.

Proof
An update visits at most 𝑂(log2𝑛) nodes itself (i.e. leaf nodes and nodes on the search path). All other affected nodes occur as newly built trees due to rebalancing operations. As in Lemma 6, the total number of nodes created due to rotations in a sequence of m updates is 𝑂(𝑚log2𝑛). It follows that the total number of affected nodes in such a sequence is 𝑂(𝑚log2𝑛). Therefore, we create 𝑂(𝑚log4𝑛) linking certificates in total, and we can compute them in 𝑂(𝑚log4𝑛) time. Updating the event global queue therefore takes 𝑂(𝑚log5𝑛) time. ◻

Running the Simulation
All that remains is to analyze the number of events processed. We show that in a sequence of m operations, our data structure processes at most 𝑂(𝑚𝛼(𝑛)log2𝑛) events. This leads to the following result.

Theorem 9
We can maintain a set P of n disjoint growing squares in a fully dynamic data structure such that we can detect the first time that a square ◻𝑞 intersects with a square ◻𝑝, with 𝑝∈𝐸(𝑞). Our data structure uses 𝑂(𝑛log𝑛loglog𝑛) space, supports updates in 𝑂(log5𝑛) amortized time, and queries in 𝑂(log2𝑛) time. For a sequence of m operations, the structure processes a total of 𝑂(𝑚𝛼(𝑛)log2𝑛) events in a total of 𝑂(𝑚𝛼(𝑛)log5𝑛) time.

Proof
We argued the bounds on the query and the update times before. We argue the space bounds in Sect. 4. All that remains is to bound the number of events processed, and the time to do so.

We start by the observation that each failure of a linking certificate produces an intersection, and thus a subsequent update. It follows that, since we process m updates by definition, the number of such events is at most m.

To bound the number of events created by the tournament trees we extend the argument of Agarwal et al. [1]. For any kinetic tournament node v in 𝑇𝐿, the minimum x-coordinate corresponds to a lower envelope of line-segments in the t, x-space. This envelope has complexity 𝑂(|𝑃∗𝑣|𝛼(|𝑃∗𝑣|))=𝑂(|𝑃∗𝑣|𝛼(𝑛)), where 𝑃∗𝑣 is the multiset of points that ever occur in 𝑃𝑣, i.e. that are stored in a leaf of the subtree rooted at v at some time t. Hence, the number of tournament events involving node v is also at most 𝑂(|𝑃∗𝑣|𝛼(𝑛)). It then follows that the total number of events is proportional to the size of these sets 𝑃∗𝑣, over all v in our tree. As in Lemma 6, every update directly contributes one point to 𝑂(log2𝑛) nodes. The remaining contribution is due to rebalancing operations, and this cost is again bounded by 𝑂(𝑚log2𝑛). Thus, the total number of events processed is 𝑂(𝑚𝛼(𝑛)log2𝑛).

At every event, we have to update the 𝑂(log2𝑛) linking certificates of v. Because all events incur not only an EXTRACTMIN operation (which takes constant time in some priority queue implementations), but also an insertion into or deletion from the priority queue, every event incurs a 𝑂(log𝑛) time cost. We can thus update the linking certicates in 𝑂(log3𝑛) time (including the time to update the global event queue). Thus, the total time for processing all kinetic tournament events in 𝑇𝐿 is 𝑂(𝑚𝛼(𝑛)log5𝑛). The analysis for the tournament nodes in 𝑇𝑅 is analogous. ◻

To simulate the process of growing the squares in P, we now maintain two copies of the data structure from Theorem 9: one for east/west intersections and one for north/south intersections. We thus obtain the following result.

Theorem 10
We can maintain a set P of n disjoint growing squares in a fully dynamic data structure such that we can detect the first time that two squares in P intersect. Our data structure uses 𝑂(𝑛log𝑛loglog𝑛) space, supports updates in 𝑂(log5𝑛) amortized time, and queries in 𝑂(log2𝑛) time. For a sequence of m operations, the structure processes 𝑂(𝑚𝛼(𝑛)log2𝑛) events in a total of 𝑂(𝑚𝛼(𝑛)log5𝑛) time.

And so we can solve the agglomerative glyph clustering problem as follows.

Theorem 11
Given a set of n initial square glyphs, we can compute an agglomerative clustering of the squares in 𝑂(𝑛𝛼(𝑛)log5𝑛) time using 𝑂(𝑛log𝑛loglog𝑛) space.

Efficient Representation of Dominance Relations
Our cones for each cardinal direction around a square ◻𝑞 (defined in Sect. 2) closely resemble dominance relations: essentially they are a dominance relation in a rotated plane. The linking certificates of our data structure, which are built on these cones, actually comprise an efficient representation of all dominance relations between two point sets. We therefore think that this representation, and in particular the tighter analysis in this section, is of independent interest.

Let R and B be two point sets in ℝ𝑑 with |𝑅|=𝑛 and |𝐵|=𝑚, and let 𝑇𝑅 and 𝑇𝐵 be range trees built on R and B, respectively. We assume that each layer of 𝑇𝑅 and 𝑇𝐵 consists of a BB[𝛼]-tree, although similar analyses can be performed for other types of balanced binary search trees. By definition, every node u on the lowest layer of 𝑇𝑅 or 𝑇𝐵 has an associated d-dimensional range 𝑄𝑢 (the hyper-box, not the subset of points). For a node 𝑢∈𝑇𝑅, we consider the subset of points in B that dominate all points in 𝑄𝑢, which can be comprised of 𝑂(log𝑑𝑚) canonical subsets of B, represented by nodes in 𝑇𝐵. Similarly, for a node 𝑣∈𝑇𝐵, we consider the subset of points in R that are dominated by all points in 𝑄𝑣, which can be comprised of 𝑂(log𝑑𝑛) canonical subsets of R, represented by nodes in 𝑇𝑅. We now link a node 𝑢∈𝑇𝑅 and a node 𝑣∈𝑇𝐵 if and only if v represents such a canonical subset for u and vice versa. By repeatedly applying Lemma 4 for each dimension, it can easily be shown that these links represent all dominance relations between R and B.

As a d-dimensional range tree consists of 𝑂(𝑛log𝑑−1𝑛) nodes, a trivial bound on the number of links is 𝑂(𝑚log2𝑑−1𝑛) (assuming 𝑛≥𝑚). Below we show that the number of links can be bounded by 𝑂(𝑛(log𝑛loglog𝑛)𝑑−1). We first consider the case for 𝑑=1.

Analyzing the Number of Links in 1D
Let R and B be point sets in ℝ with |𝑅|=𝑛, |𝐵|=𝑚, and 𝑛≥𝑚. Now, every associated range of a node u in 𝑇𝑅 or 𝑇𝐵 is an interval 𝐼𝑢. We can extend the interval to infinity in one direction; to the left for 𝑢∈𝑇𝑅, and to the right for 𝑢∈𝑇𝐵. For analysis purposes we construct another range tree T on 𝑅∪𝐵, where T is not a BB[𝛼]-tree, but instead a perfectly balanced tree with height ⌈log(𝑛+𝑚)⌉. For convenience we assume that the associated intervals of T are slightly expanded so that all points in 𝑅∪𝐵 are always interior to the associated intervals. We associate a node u in 𝑇𝑅 or 𝑇𝐵 with a node v in T if the endpoint of 𝐼𝑢 is contained in the associated interval 𝐼𝑣 of v.

Observation 12
Every node of 𝑇𝑅 or 𝑇𝐵 is associated with at most one node per level of T.

For two intervals 𝐼𝑢=(−∞,𝑎] and 𝐼𝑣=[𝑏,∞), corresponding to a node 𝑢∈𝑇𝑅 and a node 𝑣∈𝑇𝐵, let [a, b] be the spanning interval of u and v. We now want to charge spanning intervals of links to nodes of T. We charge a spanning interval 𝐼𝑢𝑣=[𝑎,𝑏] to a node w of T if and only if [a, b] is a subset of 𝐼𝑤, and [a, b] is cut by the splitting coordinate of w. Clearly, every spanning interval can be charged to exactly one node of T.

Now, for a node u of T, let ℎ𝑅(𝑢) be the height of the highest node of 𝑇𝑅 associated with u, and let ℎ𝐵(𝑢) be the height of the highest node of 𝑇𝐵 associated with u.

Lemma 13
The number of spanning intervals charged to a node u of T is 𝑂(ℎ𝑅(𝑢)⋅ℎ𝐵(𝑢)).

Proof
Let x be the splitting coordinate of u and let 𝑟∈𝑇𝑅 and 𝑏∈𝑇𝐵 form a spanning interval that is charged to u. We claim that, using the notation introduced in Lemma 4, 𝑟∈𝐶(𝑇𝑅,(−∞,𝑥]) (and symmetrically, 𝑏∈𝐶(𝑇𝐵,[𝑥,∞))). Let 𝐼𝑏=[𝑥′,∞) be the associated interval of b, where 𝑥′>𝑥. By definition, 𝑟∈𝐶(𝑇𝑅,(−∞,𝑥′]). If 𝑟∉𝐶(𝑇𝑅,(−∞,𝑥]), then the right endpoint of 𝐼𝑟 must lie between x and 𝑥′. But then the spanning interval of r and b would not be charged to u. As a result, we can only charge spanning intervals between ℎ𝑅(𝑢) nodes of 𝑇𝑅 and ℎ𝐵(𝑢) nodes of 𝑇𝐵, of which there are at most 𝑂(ℎ𝑅(𝑢)⋅ℎ𝐵(𝑢)). ◻

Using Lemma 13, we count the total number of charged spanning intervals and hence, links between 𝑇𝑅 and 𝑇𝐵. We refer to this number as numLinks(𝑇𝑅,𝑇𝐵). This is simply ∑𝑢∈𝑇𝑂(ℎ𝑅(𝑢)⋅ℎ𝐵(𝑢))≤∑𝑢∈𝑇𝑂(ℎ𝑅(𝑢)2+ℎ𝐵(𝑢)2). We can split the sum and assume w.l.o.g. that numLinks(𝑇𝑅,𝑇𝐵)≤2∑𝑢∈𝑇𝑂(ℎ𝑅(𝑢)2). Rewriting the sum based on heights in 𝑇𝑅 gives

numLinks(𝑇𝑅,𝑇𝐵)≤∑ℎ𝑅=0height(𝑇𝑅)𝑛𝑇(ℎ𝑅)⋅𝑂(ℎ2𝑅),
where 𝑛𝑇(ℎ𝑅) is the number of nodes of T that have a node of height ℎ𝑅 associated with it.

To bound 𝑛𝑇(ℎ) we use Observation 12 and the fact that 𝑇𝑅 is a BB[𝛼] tree. Let 𝑐=11−𝛼, then we get that height(𝑇𝑅)≤log𝑐(𝑛) from properties of BB[𝛼] trees. Therefore, the number of nodes in 𝑇𝑅 that have height h is at most 𝑂(𝑛𝑐ℎ).

Lemma 14
𝑛𝑇(ℎ)=𝑂((𝑛+𝑚)ℎ𝑐ℎ).

Proof
As argued, there are at most 𝑂(𝑛/𝑐ℎ) nodes in 𝑇𝑅 of height h. Consider cutting the tree T at level log(𝑛/𝑐ℎ). This results in a top tree of size 𝑂(𝑛/𝑐ℎ), and 𝑂(𝑛/𝑐ℎ) bottom trees. Clearly, the top tree contributes at most its size to 𝑛𝑇(ℎ). All bottom trees have height at most ⌈log(𝑛+𝑚)⌉−log(𝑛/𝑐ℎ)=𝑂(log(𝑐ℎ)+log(1+𝑚/𝑛))=𝑂(ℎ+𝑚/𝑛). Every node in 𝑇𝑅 of height h can, in the worst case, be associated with one distinct node per level in the bottom trees by Observation 12. Hence, the bottom trees contribute at most 𝑂(𝑛(ℎ+𝑚/𝑛)/𝑐ℎ)=𝑂((𝑛ℎ+𝑚)/𝑐ℎ)=𝑂((𝑛+𝑚)ℎ/𝑐ℎ) to 𝑛𝑇(ℎ). ◻

Using this bound on 𝑛𝑇(ℎ) in the sum we previously obtained gives:

numLinks(𝑇𝑅,𝑇𝐵)≤∑ℎ𝑅=0ℎ𝑒𝑖𝑔ℎ𝑡(𝑇𝑅)𝑂((𝑛+𝑚)ℎ3𝑅𝑐ℎ𝑅)≤𝑂(𝑛+𝑚)∑ℎ=0∞ℎ3𝑐ℎ=𝑂(𝑛+𝑚).
Where indeed, ∑∞ℎ=0ℎ3𝑐ℎ=𝑂(1) because 𝑐>1. Thus, we conclude:

Theorem 15
The number of links between two 1-dimensional range trees 𝑇𝑅 and 𝑇𝐵 containing n and m points, respectively, is bounded by 𝑂(𝑛+𝑚).

Extending to Higher Dimensions
We now extend the bound to d dimensions. The idea is very simple. We first determine the links for the top-layer of the range trees. This results in links between associated range trees of 𝑑−1 dimensions (see Fig. 8). We then determine the links within the linked associated trees, which number can be bounded by induction on d.

Fig. 8
figure 8
Two layered trees with two layers, and the links between them (sketched in black). We are interested in bounding the number of such links

Full size image
Theorem 16
The number of links between two d-dimensional range trees 𝑇𝑅 and 𝑇𝐵 containing respectively n and m (𝑛≥𝑚) points is bounded by 𝑂(𝑛(log𝑛loglog𝑛)𝑑−1).

Proof
We show by induction on d that the number of links is bounded by the minimum of 𝑂(𝑛(log𝑛loglog𝑛)𝑑−1) and 𝑂(𝑚log2𝑑−1𝑛). The second bound is simply the trivial bound given at the start of Sect. 4. The base case for 𝑑=1 is provided by Theorem 15. Now consider the case for 𝑑>1. We first determine the links for the top-layer of 𝑇𝑅 and 𝑇𝐵. Now consider the links between an associated tree 𝑇𝑢 in 𝑇𝑅 containing k points and other associated trees 𝑇0,…,𝑇𝑟 that contain at most k points. Since 𝑇𝑢 can be linked with only one associated tree per level, and because both range trees use BB[𝛼] trees, the number of points 𝑚0,…,𝑚𝑟 in 𝑇0,…,𝑇𝑟 satisfy 𝑚𝑖≤𝑘/𝑐𝑖 (0≤𝑖≤𝑟) where 𝑐=11−𝛼. By induction, the number of links between 𝑇𝑢 and 𝑇𝑖 is bounded by the minimum of 𝑂(𝑘(log𝑛loglog𝑛)𝑑−2) and 𝑂(𝑚𝑖log2𝑑−3𝑛). Now let 𝑖∗=log𝑐(log𝑑−1𝑛)=𝑂(loglog𝑛). Then, for 𝑖≥𝑖∗, we get that 𝑂(𝑚𝑖log2𝑑−3𝑛)=𝑂(𝑘log𝑑−2𝑛). Since the sizes of the associated trees decrease geometrically, the total number of links between 𝑇𝑢 and 𝑇𝑖 for 𝑖≥𝑖∗ is bounded by 𝑂(𝑘log𝑑−2𝑛). The links with the remaining trees can be bounded by 𝑂(𝑘log𝑑−2𝑛(loglog𝑛)𝑑−1). Finally note that the top-layer of each range tree has 𝑂(log𝑛) levels, and that each level contains n points in total. Thus, we obtain 𝑂(𝑛log𝑑−1𝑛(loglog𝑛)𝑑−1) links in total. The remaining links for which the associated tree in 𝑇𝐵 is larger than in 𝑇𝑅 can be bounded in the same way. ◻

It follows from Theorem 16 that our data structure from Sect. 3 actually maintains only 𝑂(𝑛log𝑛loglog𝑛) certificates. That number is significantly lower than our initial analysis showed: at the end of Sect. 3.1 we analyzed the space usage to be 𝑂(𝑛log3𝑛). The number of certicates, even under the tighter analysis, however still slightly dominates the space usage of the 2D range trees and kinetic tournaments, which is 𝑂(𝑛log𝑛). Our data structure thus uses only 𝑂(𝑛log𝑛loglog𝑛) space.

Conclusion and Future Work
We presented an efficient fully dynamic data structure for maintaining a set of disjoint growing squares. This leads to an efficient algorithm for agglomerative glyph clustering. The main future challenge is to improve the analysis of the running time. Our analysis from Sect. 4 shows that at any time, we need only few linking certificates. However, we would like to bound the total number of linking certificates used throughout the entire sequence of operations. An interesting question is if we can extend our argument to this case. This may also lead to a more efficient algorithm for maintaining the linking certificates during updates.