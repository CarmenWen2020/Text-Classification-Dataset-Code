We study an agglomerative clustering problem motivated by interactive glyphs in geo-visualization. Consider a set of disjoint square glyphs on an interactive map. When the user zooms out, the glyphs grow in size relative to the map, possibly with different speeds. When two glyphs intersect, we wish to replace them by a new glyph that captures the information of the intersecting glyphs. We present a fully dynamic kinetic data structure that maintains a set of n disjoint growing squares. Our data structure uses ğ‘‚(ğ‘›logğ‘›loglogğ‘›) space, supports queries in worst case ğ‘‚(log2ğ‘›) time, and updates in ğ‘‚(log5ğ‘›) amortized time. This leads to an ğ‘‚(ğ‘›ğ›¼(ğ‘›)log5ğ‘›) time algorithm to solve the agglomerative clustering problem. This is a significant improvement over the current best ğ‘‚(ğ‘›2) time algorithms.

Introduction
We study an agglomerative clustering problem motivated by interactive glyphs in geo-visualization. Our specific use case stems from the eHumanities, but similar visualizations are used in a variety of application areas. GlamMap [6]Footnote1 is a visual analytics tool which allows the user to interactively explore datasets which contain (at least) the following metadata of a book collection: author, title, publisher, year of publication, and location (city) of publisher. Each book is depicted by a square, color-coded by publication year, and placed on a map according to the location of its publisher. Overlapping squares (many books are published in Leipzig, for example) are recursively aggregated into a larger glyph until all glyphs are disjoint (see Fig. 1). As the user zooms out, the glyphs â€œgrowâ€ relative to the map to remain legible. As a result, glyphs start to overlap and need to be merged into larger glyphs to keep the map clear and uncluttered. It is straightforward to compute the resulting agglomerative clustering whenever a data set is loaded and to serve it to the user as needed by the current zoom level. However, GlamMap allows the user to filter by author, title, year of publication, or other applicable meta data. It is impossible to pre-compute the clustering for any conceivable combination of filter values. To allow the user to browse at interactive speeds, we hence need an efficient agglomerative clustering algorithm for growing squares (glyphs). Interesting bibliographic data sets (such as the catalogue of WorldCat, which contains more than 321 million library records at hundreds of thousands of distinct locations) are too large by a significant margin to be clustered fast enough with the current state-of-the-art ğ‘‚(ğ‘›2) time algorithms (here n is the number of squares or glyphs).

Fig. 1
figure 1
Zooming out in GlamMap will merge overlapping squares. This figure shows a sequence of three steps zooming out from the surroundings of Leipzig

Full size image
In this paper we formally analyze the problem and present a fully dynamic data structure that uses ğ‘‚(ğ‘›logğ‘›loglogğ‘›) space, supports updates in ğ‘‚(log5ğ‘›) amortized time, and queries in ğ‘‚(log2ğ‘›) time, which allows us to compute the agglomerative clustering for n glyphs in ğ‘‚(ğ‘›ğ›¼(ğ‘›)log5ğ‘›) time. Here, ğ›¼ is the extremely slowly growing inverse Ackermann function. To the best of our knowledge, this is the first fully dynamic clustering algorithm which beats the classic ğ‘‚(ğ‘›2) time bound.

Formal problem statement. Let P be a set of points in â„2 (the locations of publishers from our example). Each point ğ‘âˆˆğ‘ƒ has a positive weight ğ‘ğ‘¤ (number of books published in this city). Given a â€œtimeâ€ parameter t, we interpret the points in P as squares. More specifically, let â—»ğ‘(ğ‘¡) be the square centered at p with width ğ‘¡ğ‘ğ‘¤. For ease of exposition we assume all x and y coordinates to be unique. With some abuse of notation we may refer to P as a set of squares rather than the set of center points of squares. Observe that initially, i.e. at ğ‘¡=0, all squares in P are disjoint. As t increases, the squares in P grow, and hence they may start to intersect. When two squares â—»ğ‘(ğ‘¡) and â—»ğ‘(ğ‘¡) intersect at time t, we remove both p and q and replace them by a new point z, which is located at the weighted average of p and q and has the sum of their weights as its weight. More formally, ğ‘§=ğœ”ğ‘+(1âˆ’ğœ”)ğ‘, with ğœ”=ğ‘ğ‘¤/(ğ‘ğ‘¤+ğ‘ğ‘¤), and has weight ğ‘§ğ‘¤=ğ‘ğ‘¤+ğ‘ğ‘¤ (see Fig. 2).

Fig. 2
figure 2
The timeline of squares that grow and merge as they touch

Full size image
Related Work. Funke, Krumpe, and Storandt [7] introduced so-called â€œball tournamentsâ€, a related, but simpler, problem, which is motivated by map labeling. Their input is a set of balls in â„ğ‘‘ with an associated set of priorities. The balls grow linearly and whenever two balls touch, the ball with the lower priority is eliminated. The goal is to compute the elimination sequence efficiently. Bahrdt et al. [4] and Funke and Storandt [8] improved upon the initial results and presented bounds which depend on the ratio ğ›¥ of the largest to the smallest radius. Specifically, Funke and Storandt [8] show how to compute an elimination sequence for n balls in ğ‘‚(ğ‘›logğ›¥(log+ğ›¥ğ‘‘âˆ’1)) time in arbitrary dimensions and in ğ‘‚(ğ¶ğ‘›polylogğ‘›) time for ğ‘‘=2, where C denotes the number of different radii. In our setting eliminations are not sufficient, since merged glyphs need to be re-inserted. Furthermore, as opposed to typical map labeling problems where labels come in a fixed range of sizes, the sizes of our glyphs can vary by a factor of 10.000 or more (Amsterdam with its many well-established publishers vs. Kaldenkirchen with one obscure one).

Ahn et al. [2] recently and independently developed the first sub-quadratic algorithms to compute elimination orders for ball tournaments. Their results apply to balls and boxes in two or higher dimensions. Specifically, for squares in two dimensions they can compute an elimination order in ğ‘‚(ğ‘›log4ğ‘›) time. Their results critically depend on the fact that they know the elimination priorities at the start of their algorithm and that they only have to handle deletions. Hence they do not have to run an explicit simulation of the growth process and can achieve their results by the clever use of advanced data structures. In contrast, we are handling the fully dynamic setting with both insertions and deletions, and without a specified set of priorities. In fact, our algorithm can easily be adapted to solve the ball tournament problem for squares without increasing the running time.

Our clustering problem combines both dynamic and kinetic aspects: squares grow, which is a restricted form of movement, and squares are both inserted and deleted. There are comparatively few papers which tackle dynamic kinetic problems. Alexandron et al. [3] present a dynamic and kinetic data structure for maintaining the convex hull of points (or analogously, the lower envelope of lines) moving in â„2. Their data structure processes (in expectation) ğ‘‚(ğ‘›2ğ›½ğ‘ +2(ğ‘›)logğ‘›) events in ğ‘‚(log2ğ‘›) time each. Here, ğ›½ğ‘ (ğ‘›)=ğœ†ğ‘ (ğ‘›)/ğ‘›, and ğœ†ğ‘ (ğ‘›) is the maximum length of a Davenport-Schinzel sequence on n symbols of order s. Agarwal et al. [1] present dynamic and kinetic data structures for maintaining the closest pair and all nearest neighbors. The expected number of events processed is again roughly ğ‘‚(ğ‘›2ğ›½ğ‘ +2(ğ‘›)polylogğ‘›), each of which can be handled in ğ‘‚(polylogğ‘›) expected time. We are using some ideas and constructions which are similar in flavor to the structures presented in their paper.

Results. We present a fully dynamic data structure that can maintain a set P of disjoint growing squares. At any time, it supports inserting a new square that is disjoint from the squares in P, or removing an existing square from P. Our data structure will produce an intersection event at every time t when two squares â—»ğ‘ and â—»ğ‘, with ğ‘,ğ‘âˆˆğ‘ƒ, start to intersect (i.e. at any time before t, all squares in P remain disjoint). At such a time, we then have to delete some of the squares, to make sure that the squares in P are again disjoint. Our data structure can handle a sequence of ğ‘šâ‰¥ğ‘› updates in a total of ğ‘‚(ğ‘šğ›¼(ğ‘›)log5ğ‘›) time, each update is performed in ğ‘‚(log5ğ‘›) amortized time.

Our Approach. In order to efficiently keep track of which squares in our set P are about to intersect, we combine the following two ideas.

The first is that we can focus on specific kinds of intersections. In particular, if we can, for a given square â—»ğ‘, track which square â—»ğ‘ will intersect the right side of â—»ğ‘ first, then we can analogously track similar intersection events for the left, top and bottom sides of â—»ğ‘. Moreover, we only need to explicitly consider two sides of â—»ğ‘, say the top and right sides: if, e.g., the left side of â—»ğ‘ intersects some square â—»ğ‘Ÿ, then symmetrically the right side of â—»ğ‘Ÿ intersects â—»ğ‘ and thus we already track that event. We describe our data structure, built on two-layered range trees, for intersections with the right side of â—»ğ‘, and then combine two copies to make sure that all squares in P remain disjoint. We formalize this in Sect. 2.

The second idea is that, instead of having each square â—»ğ‘ independently track which â—»ğ‘ will intersect it first, we can intelligently group squares that track (roughly) the same subset of P. We do so efficiently using the layers of search trees. This saves on space used by our data structure, in the form of certificates. It also reduces the running time of handling a sequence of updates, simply because fewer certicates fail or need to be updated. We concretize this in Sect. 3.

While our data structure is conceptually simple, the exact implementation is somewhat intricate, and the details are numerous. Our initial analysis shows that our data structure maintains ğ‘‚(log2ğ‘›) certificates for every secondary node in our range trees, so ğ‘‚(ğ‘›log3ğ‘›) in total, and supports dynamic updates in ğ‘‚(log5ğ‘›) amortized time. This allows us to simulate the process of growing the squares in P â€“and thus solve the agglomerative glyph clustering problemâ€“ in ğ‘‚(ğ‘›ğ›¼(ğ‘›)log5ğ‘›) time using ğ‘‚(ğ‘›log3ğ‘›) space. In Sect. 4 we analyze the relation between canonical subsets in dominance queries. We show that for two range trees ğ‘‡ğ‘… and ğ‘‡ğµ in â„ğ‘‘, the number of pairs of nodes ğ‘Ÿâˆˆğ‘‡ğ‘… and ğ‘âˆˆğ‘‡ğµ for which r occurs in the canonical subset of a dominance query defined by b and vice versa is only ğ‘‚(ğ‘›(logğ‘›loglogğ‘›)ğ‘‘âˆ’1), where n is the total size of ğ‘‡ğ‘… and ğ‘‡ğµ. This implies that the number of linking certificates that our data structure maintains, as well as the total space used, is actually only ğ‘‚(ğ‘›logğ‘›loglogğ‘›). Since the linking certificates provide an efficient representation of all dominance relations between two point sets (or within a point set), we believe that this result is of independent interest as well.

In the preliminary version of this paper, we partitioned space in a different way [5]. This gave us an ğ‘‚(ğ‘›ğ›¼(ğ‘›)log7ğ‘›) time algorithm that used ğ‘‚(ğ‘›(logğ‘›loglogğ‘›)2) space. The improvements we made, which we describe in this paper, lead to a reduction of two log factors in the running time, and a logğ‘›loglogğ‘› factor of space usage.

Geometric Properties
Fig. 3
figure 3
Squares E(q) east of â—»ğ‘. â—»ğ‘âˆˆğ¸(ğ‘) intersects â—»ğ‘ when ğ‘¥(ğ‘Ÿğ‘)â‰¥ğ‘¥(â„“ğ‘)

Full size image
Our approach, as described above, will be to focus on specific types of intersections. In particular, for any given square â—»ğ‘ we are interested in tracking intersections with the right side of â—»ğ‘. We observe that the first square â—»ğ‘ that is to intersect the right side of â—»ğ‘ will have (i) its left side touch â—»ğ‘ first, and (ii) its center p in a cone east of q. We refer to all squares having their center in this cone as E(q). See Fig. 3 for an example. Let us introduce some notation and formally capture these two observations.

We are interested, for all points ğ‘âˆˆğ‘ƒ, in a cone east of them, which is the set of points {(ğ‘¥,ğ‘¦)âˆˆâ„2 | ğ‘¥âˆ’ğ‘¥(ğ‘)â‰¥|ğ‘¦âˆ’ğ‘¦(ğ‘)|}. North, south and west cones can be defined analogously. Let â„“ğ‘ denote the midpoint of the left edge of a square â—»ğ‘, and let ğ‘Ÿğ‘ denote the midpoint of the right edge of â—»ğ‘. Similarly, let the midpoints of the top and bottom edges of â—»ğ‘ be denoted by â†‘ğ‘ and â†“ğ‘, respectively. Furthermore, let E(q) denote the subset of points of P lying in the cone east of q, and let ğ¿(ğ‘)={â„“ğ‘âˆ£ğ‘âˆˆğ¸(ğ‘)} denote the set of midpoints of left edges of the squares of those points.

We remark that points ğ‘âˆˆğ‘ƒ can simultaneously lie in, e.g., the east and south cones induced by any ğ‘âˆˆğ‘ƒ. This means that the top left corner of â—»ğ‘ will first intersect with the bottom right corner of â—»ğ‘. In such cases it is not necessary to track the square in both copies of our data structure. An arbitrary choice to break this degeneracy can be made. The same holds for the other pairs of neighboring cones.

Observation 1
Let ğ‘âˆˆğ¸(ğ‘) be a point east of point q. The squares â—»ğ‘(ğ‘¡) and â—»ğ‘(ğ‘¡) intersect at time t if and only if ğ‘¥(ğ‘Ÿğ‘(ğ‘¡))â‰¥ğ‘¥(â„“ğ‘(ğ‘¡)) at time t.

Proof
Clearly, when ğ‘¥(ğ‘Ÿğ‘(ğ‘¡))<ğ‘¥(â„“ğ‘(ğ‘¡)), then since the rightmost point of â—»ğ‘ is left of the leftmost point of â—»ğ‘, the squares do not intersect. For the other direction, observe that because p is in the cone east of q, it holds that ğ‘¥(ğ‘)âˆ’ğ‘¥(ğ‘)â‰¥|ğ‘¦(ğ‘)âˆ’ğ‘¦(ğ‘)|. Since ğ‘¥(ğ‘Ÿğ‘(ğ‘¡))â‰¥ğ‘¥(â„“ğ‘(ğ‘¡)), it holds that ğ‘¥(ğ‘Ÿğ‘(ğ‘¡))âˆ’ğ‘¥(â„“ğ‘(ğ‘¡))+ğ‘¥(ğ‘)âˆ’ğ‘¥(ğ‘)â‰¥ğ‘¥(ğ‘)âˆ’ğ‘¥(ğ‘)â‰¥|ğ‘¦(ğ‘)âˆ’ğ‘¦(ğ‘)|. Because â—»ğ‘ and â—»ğ‘ are squares, either ğ‘¦(â†“ğ‘(ğ‘¡))â‰¤ğ‘¦(â†‘ğ‘(ğ‘¡)) or ğ‘¦(â†‘ğ‘(ğ‘¡))â‰¥ğ‘¦(â†“ğ‘(ğ‘¡)). In either case, both the horizontal and vertical intervals of â—»ğ‘ and â—»ğ‘ overlap, and hence they intersect. â—»

Following the above observations, we observe another important detail:

Observation 2
Let ğ‘¡âˆ— be the first time at which a square â—»ğ‘ of a point ğ‘âˆˆğ¸(ğ‘) intersects â—»ğ‘. We then have that ğ‘¥(ğ‘Ÿğ‘(ğ‘¡âˆ—))=ğ‘¥(â„“ğ‘(ğ‘¡âˆ—)), and â„“ğ‘(ğ‘¡âˆ—) is the point with minimum x-coordinate among the points in L(q) at time ğ‘¡âˆ—.

Proof
It is easy to see that ğ‘¥(ğ‘Ÿğ‘(ğ‘¡âˆ—))=ğ‘¥(â„“ğ‘(ğ‘¡âˆ—)). To see that â„“ğ‘(ğ‘¡âˆ—) has minimum x-coordinate, we assume it is not for a contradiction. Let r be the point that does have minimum x-coordinate, thus ğ‘¥(â„“ğ‘Ÿ(ğ‘¡âˆ—))<ğ‘¥(â„“ğ‘(ğ‘¡âˆ—)). Since ğ‘¥(ğ‘Ÿğ‘(ğ‘¡âˆ—))=ğ‘¥(â„“ğ‘(ğ‘¡âˆ—)), we get ğ‘¥(â„“ğ‘Ÿ(ğ‘¡âˆ—))<ğ‘¥(ğ‘Ÿğ‘(ğ‘¡âˆ—)). But r is east of q, so ğ‘¥(ğ‘Ÿ)>ğ‘¥(ğ‘) and thus, following a same type of argument as for Observation 1, â—»ğ‘ and â—»ğ‘Ÿ intersect. Because all squares grow linearly, there must be some ğ‘¡â€²<ğ‘¡âˆ— when ğ‘¥(ğ‘Ÿğ‘(ğ‘¡â€²))=ğ‘¥(â„“ğ‘Ÿ(ğ‘¡â€²)), and â—»ğ‘ first intersected â—»ğ‘Ÿ. But then ğ‘¡âˆ— is not the first time at which a square east of q intersects â—»ğ‘. Contradiction, thus â„“ğ‘(ğ‘¡âˆ—) has minimum x-coordinate in L(q) at time ğ‘¡âˆ—. â—»

A Kinetic Data Structure for Growing Squares
In this section we present a data structure that can detect the first intersection among a dynamic set of disjoint growing squares. In particular, we describe a data structure that can detect intersections between all pairs of squares â—»ğ‘,â—»ğ‘ in P such that  ğ‘âˆˆğ¸(ğ‘). We then use two copies of this data structure, one for east/west and one for north/south intersections, to detect the first intersection among all pairs of squares.

We describe the data structure itself in Sect. 3.1, and we briefly describe how to query it in Sect. 3.2. We deal with updates â€“inserting a new square into P or deleting an existing square from Pâ€“ in Sect. 3.3. In Sect. 3.4 we analyze the total number of events that we have to process, and the time required to do so, when we simulate growing the squares.

The Data Structure
Our data structure consists of two trees ğ‘‡ğ¿ and ğ‘‡ğ‘…, both with two layers, and a set of certificates linking nodes in ğ‘‡ğ¿ to nodes in ğ‘‡ğ‘…. These trees essentially form two 2D range trees on the centers of the squares in P, using rotated axes (see Sect. 2), so that we can easily query the tree for E(q), for any ğ‘âˆˆğ‘ƒ. The second layer of ğ‘‡ğ¿ will double as a kinetic tournament tracking the left midpoints of the squares. Similarly, ğ‘‡ğ‘… will track the right midpoints of the squares.

The Layered Trees. The tree ğ‘‡ğ¿ is a 2D-range tree storing the center points in P: in the rotated plane suggested in Sect. 2, the first layer indexes the first coordinate ğ‘¥â€², while the second layer indexes the second coordinate ğ‘¦â€². Each layer is implemented by a weight-balanced binary search tree (BB[ğ›¼] tree) [10], and each node ğœ‡ corresponds to a canonical subset ğ‘ƒğœ‡ of points stored in the leaves of the subtree rooted at ğœ‡. Let ğ¿ğœ‡ denote the set of left midpoints of squares corresponding to the set ğ‘ƒğœ‡.

Consider the associated structure ğ‘‹ğ¿ğ‘¢ of some primary node ğ‘¢âˆˆğ‘‡ğ¿. We consider ğ‘‹ğ¿ğ‘¢ as a kinetic tournament on the x-coordinates of the points ğ¿ğ‘¢ [1]. More specifically, every node ğ‘£âˆˆğ‘‹ğ¿ğ‘¢ stores the midpoint â„“ğ‘ in ğ¿ğ‘£ with minimum x-coordinate, and will maintain certificates that guarantee this [1].

The tree ğ‘‡ğ‘… has the same structure as ğ‘‡ğ¿, but the associated structure ğ‘‹ğ‘…ğ‘¢, for some primary node u, â€“which again doubles as a kinetic tournamentâ€“ maintains not the minimum, but the maximum x-coordinate of the points in ğ‘…ğ‘¢. Analogous to ğ¿ğ‘¢, ğ‘…ğ‘¢ is the set of right midpoints of the squares (with center points) in ğ‘ƒğ‘¢. Hence, every secondary node ğ‘£âˆˆğ‘‹ğ‘…ğ‘¢ stores the midpoint ğ‘Ÿğ‘ in ğ‘…ğ‘£ with maximum x-coordinate.

Linking the Trees. Kinetic data structures maintain certicates that guarantee that some property holds at least until some point in the (nearby) future. Maintaining a kinetic data structure revolves for a large part around updating certificates as they reach that point in time and break. We want to maintain the property that all squares in P are disjoint, and thus we next describe how to add linking certificates between the kinetic tournament nodes in the trees ğ‘‡ğ¿ and ğ‘‡ğ‘… that guarantee that the squares are disjoint. More specifically, a secondary node ğ‘£âˆˆğ‘‡ğ¿ represents a set ğ‘ƒğ‘£âŠ†ğ‘ƒ of squares (the canonical subset of node v). We describe how we add certificates that guarantee that any â—»ğ‘, with ğ‘âˆˆğ‘ƒğ‘£, is disjoint from all â—»ğ‘, with ğ‘âˆˆğ¸(ğ‘). These points q are represented by secondary nodes ğ‘¤âˆˆğ‘‡ğ‘…, and so we can discuss linking nodes instead of squares.

Consider a point q. There are ğ‘‚(log2ğ‘›) nodes in the secondary tree of ğ‘‡ğ¿ whose canonical subsets together represent exactly E(q). These nodes, in their secondary function as kinetic tournament nodes, represent the points in L(q). So, in total q is interested in a set ğ‘„ğ¿(ğ‘) of ğ‘‚(log2ğ‘›) kinetic tournament nodes. It now follows from Observation 2 that if we were to add certificates certifying that ğ‘Ÿğ‘ is left of the point stored at the nodes in ğ‘„ğ¿(ğ‘), we can detect when â—»ğ‘ intersects with a square of a point in E(q). However, as there may be many points q interested in a particular kinetic tournament node v (an example is given in Fig. 4), we cannot afford to maintain all of these certificates. The main idea is to represent all of these points q by a number of canonical subsets of nodes in ğ‘‡ğ‘…, and add certificates to only these nodes.

Fig. 4
figure 4
The red points, on two convex chains, are all interested in the same set ğ‘„ğ¿(ğ‘). In general a linear number of points may be interested in a given kinetic tournament node

Full size image
Consider a point p. Symmetric to the above construction, there are ğ‘‚(log2ğ‘›) nodes in kinetic tournaments associated with ğ‘‡ğ‘… that together exactly represent the (right sides of) squares â—»ğ‘ west of p, for which ğ‘âˆˆğ¸(ğ‘). Let ğ‘„ğ‘…(ğ‘) denote this set.

Fig. 5
figure 5
The points ğ‘šâ¯â¯â¯â¯ğ‘¤ and ğ‘šâ¯â¯â¯ğ‘£ are defined by a pair of secondary nodes ğ‘¤âˆˆğ‘‡ğ‘…ğ‘¢â€², and ğ‘£âˆˆğ‘‡ğ¿ğ‘¢. If ğ‘£âˆˆğ‘„ğ¿(ğ‘šâ¯â¯â¯â¯ğ‘¤) and ğ‘¤âˆˆğ‘„(ğ‘šâ¯â¯â¯ğ‘£), then we add a linking certificate between the rightmost midpoint ğ‘Ÿğ‘, ğ‘âˆˆğ‘ƒğ‘¤, and the leftmost midpoint â„“ğ‘, ğ‘âˆˆğ‘ƒğ‘£, certifying that the squares in ğ‘ƒğ‘¤ are disjoint from those in ğ‘ƒğ‘£

Full size image
Next, we extend the definitions of ğ‘„ğ¿ and ğ‘„ğ‘… to kinetic tournament nodes. To this end, we first associate each kinetic tournament node with a (query) point in â„2. Consider a kinetic tournament node v in a tournament ğ‘‹ğ¿ğ‘¢, associated with node u in the primary ğ‘‡ğ¿. We denote the coordinates of a point p in the rotated coordinate system using ğ‘¥â€²(ğ‘) and ğ‘¦â€²(ğ‘). Let, in coordinates of the rotated system, ğ‘šâ¯â¯â¯ğ‘£=(minğ‘âˆˆğ‘ƒğ‘¢ğ‘¥â€²(ğ‘),minğ‘âˆˆğ‘ƒğ‘£ğ‘¦â€²(ğ‘)) be the point associated with v (note that we take the minimum over different sets ğ‘ƒğ‘¢ and ğ‘ƒğ‘£ for the different coordinates), and define ğ‘„ğ‘…(ğ‘£)=ğ‘„ğ‘…(ğ‘šâ¯â¯â¯ğ‘£). Symmetrically, for a node w in a tournament ğ‘‹ğ‘…ğ‘¢, with ğ‘¢âˆˆğ‘‡ğ‘…, we define ğ‘šâ¯â¯â¯â¯ğ‘¤=(maxğ‘âˆˆğ‘ƒğ‘¢ğ‘¥â€²(ğ‘),maxğ‘âˆˆğ‘ƒğ‘£ğ‘¦â€²(ğ‘)) and ğ‘„ğ¿(ğ‘¤)=ğ‘„ğ¿(ğ‘šâ¯â¯â¯â¯ğ‘¤) (see Fig. 5).

We now add a linking certificate between every pair of secondary nodes ğ‘£âˆˆğ‘‡ğ¿ and ğ‘¤âˆˆğ‘‡ğ‘… for which (i) v is a node in the canonical subset of w, that is ğ‘£âˆˆğ‘„ğ¿(ğ‘¤), and (ii) w is a node in the canonical subset of v, ğ‘¤âˆˆğ‘„ğ‘…(ğ‘£). Such a certificate will guarantee that the midpoint ğ‘Ÿğ‘ currently stored at w lies left of the point â„“ğ‘ stored at v.

Lemma 3
Every kinetic tournament node is involved in ğ‘‚(log2ğ‘›) linking certificates, and thus every point p is associated with at most ğ‘‚(log4ğ‘›) certificates.

Proof
We start with the first part of the lemma statement. Every secondary node ğ‘£âˆˆğ‘‡ğ¿ can be associated with at most ğ‘‚(log2ğ‘›) linking certificates: one with each node in ğ‘„ğ‘…(ğ‘£). Analogously, every secondary node ğ‘¤âˆˆğ‘‡ğ‘… can be associated with at most ğ‘‚(log2ğ‘›) linking certificates: one for each node in ğ‘„ğ¿(ğ‘¤).

Every point p occurs in the canonical subset of at most ğ‘‚(log2ğ‘›) kinetic tournament nodes in the second layers of both ğ‘‡ğ¿ and ğ‘‡ğ‘…: p is stored in ğ‘‚(logğ‘›) leaves of the kinetic tournaments, and in each such a tournament it can participate in ğ‘‚(logğ‘›) certificates (at most two tournament certificates in ğ‘‚(logğ‘›) nodes). As we argued above, each such a node itself occurs in at most ğ‘‚(log2ğ‘›) certificates. â—»

What remains to argue is that we can still detect the first upcoming intersection.

Lemma 4
Consider two sets of elements, say blue elements B and red elements R, stored in the leaves of two binary search trees ğ‘‡ğµ and ğ‘‡ğ‘…, respectively, and let ğ‘âˆˆğµ and ğ‘âˆˆğ‘…, with ğ‘<ğ‘, be leaves in trees ğ‘‡ğµ and ğ‘‡ğ‘…, respectively. There is a pair of nodes ğ‘âˆˆğ‘‡ğµ and ğ‘Ÿâˆˆğ‘‡ğ‘…, such that (i) ğ‘âˆˆğ‘ƒğ‘ and ğ‘âˆˆğ¶(ğ‘‡ğµ,[ğ‘¥â€²,âˆ)), and (ii)  ğ‘âˆˆğ‘ƒğ‘Ÿ and ğ‘Ÿâˆˆğ¶(ğ‘‡ğ‘…,(âˆ’âˆ,ğ‘¥]), where ğ‘¥â€²=maxğ‘ƒğ‘Ÿ, ğ‘¥=minğ‘ƒğ‘, and ğ¶(ğ‘‡ğ‘†,ğ¼) denotes the minimal set of nodes in ğ‘‡ğ‘† whose canonical subsets together represent exactly the elements of ğ‘†âˆ©ğ¼.

Fig. 6
figure 6
The nodes b and r in the trees ğ‘‡ğµ and ğ‘‡ğ‘…

Full size image
Proof
Let b be the first node on the path from the root of ğ‘‡ğµ to p such that the canonical subset ğ‘ƒğ‘ of b is contained in the interval [ğ‘,âˆ), but the canonical subset of the parent of b is not. We define b to be the root of ğ‘‡ğµ if no such node exists. We define r to be the first node on the path from the root of ğ‘‡ğ‘… to q for which ğ‘ƒğ‘Ÿ is contained in (âˆ’âˆ,ğ‘¥] but the canonical subset of the parent is not. We again define r as the root of ğ‘‡ğ‘… if no such node exists. See Fig. 6. Clearly, we now directly have that r is one of the nodes whose canonical subsets form ğ‘…âˆ©(âˆ’âˆ,ğ‘¥], and that ğ‘âˆˆğ‘ƒğ‘Ÿ (as r lies on the search path to q). It is also easy to see that ğ‘âˆˆğ‘ƒğ‘, as b lies on the search path to p. All that remains is to show that b is one of the canonical subsets that together form ğµâˆ©[ğ‘¥â€²,âˆ). This follows from the fact that ğ‘â‰¤ğ‘¥â€²<ğ‘¥â‰¤ğ‘ â€“and thus ğ‘ƒğ‘ is indeed a subset of [ğ‘¥â€²,âˆ)â€“ and the fact that the subset of the parent v of b contains an element smaller than q, and can thus not be a subset of [ğ‘¥â€²,âˆ). â—»

Lemma 5
Let â—»ğ‘ and â—»ğ‘, with ğ‘âˆˆğ¸(ğ‘), be the first pair of squares to intersect, at some time ğ‘¡âˆ—. There is a pair of nodes v, w with a linking certificate that fails at time ğ‘¡âˆ—.

Proof
Consider the leaves representing p and q in ğ‘‡ğ¿ and ğ‘‡ğ‘…, respectively. Applying Lemma 4, we get that there is a pair of nodes ğ‘¢âˆˆğ‘‡ğ¿ and ğ‘¢â€²âˆˆğ‘‡ğ‘… that, among other properties, have ğ‘âˆˆğ‘ƒğ‘¢ and ğ‘âˆˆğ‘ƒğ‘¢â€². Hence, we can apply Lemma 4 again on the associated trees of u and ğ‘¢â€², giving us nodes ğ‘£âˆˆğ‘‹ğ¿ğ‘¢ and ğ‘¤âˆˆğ‘‹ğ‘…ğ‘¢â€² with ğ‘âˆˆğ‘ƒğ‘£ and ğ‘âˆˆğ‘ƒğ‘¤. In addition, these two applications of Lemma 4 give us two points (x, y) and (ğ‘¥â€²,ğ‘¦â€²) â€“with coordinates in the rotated systemâ€“ such that:

ğ‘ƒğ‘¢ occurs as a canonical subset representing ğ‘ƒâˆ©([ğ‘¥â€²,âˆ)Ã—â„), and

ğ‘ƒğ‘£ occurs as a canonical subset representing ğ‘ƒğ‘¢âˆ©(â„Ã—[ğ‘¦â€²,âˆ)),

and such that

ğ‘ƒğ‘¢â€² occurs as a canonical subset representing ğ‘ƒâˆ©((âˆ’âˆ,ğ‘¥]Ã—â„), and

ğ‘ƒğ‘¤ occurs as a canonical subset representing ğ‘ƒğ‘¢â€²âˆ©(â„Ã—(âˆ’âˆ,ğ‘¦]).

We combine these first two facts and observe that ğ‘šâ¯â¯â¯â¯ğ‘¤=(ğ‘¥â€²,ğ‘¦â€²). This gives us that ğ‘ƒğ‘£ occurs as a canonical subset representing ğ‘ƒâˆ©([ğ‘¥â€²,âˆ)Ã—[ğ‘¦â€²,âˆ))=ğ¸((ğ‘¥â€²,ğ‘¦â€²)), and hence ğ‘£âˆˆğ‘„ğ¿(ğ‘šâ¯â¯â¯â¯ğ‘¤)=ğ‘„ğ¿(ğ‘¤). Analogously, combining the latter two facts and ğ‘šâ¯â¯â¯ğ‘£=(ğ‘¥,ğ‘¦) gives us ğ‘¤âˆˆğ‘„ğ‘…(ğ‘£). Therefore, v and w have a linking certificate. This linking certificate involves the leftmost left edge midpoint â„“ğ‘ for some point ğ‘âˆˆğ‘ƒğ‘£ and the rightmost right edge midpoint ğ‘Ÿğ‘ for some point ğ‘âˆˆğ‘ƒğ‘¤. Since ğ‘âˆˆğ‘ƒğ‘£ and ğ‘âˆˆğ‘ƒğ‘¤, we have that ğ‘Ÿğ‘â‰¤ğ‘Ÿğ‘ and â„“ğ‘â‰¤â„“ğ‘, and thus we detect their intersection at time ğ‘¡âˆ—. â—»

From Lemma 5 it follows that we can now detect the first intersection between a pair of squares â—»ğ‘ and â—»ğ‘, with ğ‘âˆˆğ¸(ğ‘), so any east/west intersection. We define an analogous data structure for detecting north/south intersections.

Space Usage. Our trees ğ‘‡ğ¿ and ğ‘‡ğ‘… are range trees in â„2, and thus use ğ‘‚(ğ‘›logğ‘›) space. However, it is easy to see that this is dominated by the space required to store the certificates. For all ğ‘‚(ğ‘›logğ‘›) kinetic tournament nodes we store at most ğ‘‚(log2ğ‘›) certificates (Lemma 3), and thus the total space used by our data structure is ğ‘‚(ğ‘›log3ğ‘›). In Sect. 4 we will show that the number of certificates we maintain, and thus the space our data structure uses, is actually only ğ‘‚(ğ‘›logğ‘›loglogğ‘›).

Answering Queries
The basic query that our data structure supports is testing if a query square â—»ğ‘ currently intersects with a square â—»ğ‘ in P, with ğ‘âˆˆğ¸(ğ‘). To this end, we simply select the ğ‘‚(log2ğ‘›) kinetic tournament nodes from ğ‘‡ğ¿ whose canonical subsets together represent E(q). For each such a node v we check if the x-coordinate of the left midpoint â„“ğ‘ stored at that node (which has minimum x-coordinate among ğ¿ğ‘£) is smaller than the x-coordinate of ğ‘Ÿğ‘. If so, the squares intersect. The correctness of our query algorithm directly follows from Observation 1. The total time required for a query is equivalent to the query time of a 2D range tree, which is ğ‘‚(log2ğ‘›). We can similarly test if a given query point q is contained in a square â—»ğ‘, with ğ‘âˆˆğ¸(ğ‘).

To check for intersections with squares p west of q, we can use ğ‘‡ğ‘… in a way symmetrical to the procedure described above. Our full data structure will contain trees analogous to ğ‘‡ğ¿ and ğ‘‡ğ‘… that can be used to check if there is a square â—»ğ‘âˆˆğ‘ƒ, with p either north or south of q, that intersects â—»ğ‘. Again, a similar query for containment of a query point q in a square â—»ğ‘ is also supported.

In summary, we can at any point in time test if a given query square â—»ğ‘ currently intersects any â—»ğ‘ in P, in ğ‘‚(log2ğ‘›) time. We can in the same running time test if a query point q is currently contained in any square â—»ğ‘ in P.

Inserting or Deleting a Square
At an insertion or deletion of a square â—»ğ‘ we proceed in three steps. First, we update the individual trees ğ‘‡ğ¿ and ğ‘‡ğ‘…, making sure that they once again represent 2D range trees of all center points in P, and that the secondary data structures are, by themselves, correct kinetic tournaments. For each kinetic tournament node in ğ‘‡ğ¿ affected by the update, we then query ğ‘‡ğ‘… to find a new set of linking certificates. We update the affected kinetic tournament nodes in ğ‘‡ğ‘… analogously. Finally, we update the global event queue that stores all certificates.

Lemma 6
Inserting a square into ğ‘‡ğ¿ or deleting a square from ğ‘‡ğ¿ takes ğ‘‚(log2ğ‘›) amortized time.

Proof
We use the following standard procedure for updating the two-level BB[ğ›¼] trees ğ‘‡ğ¿ in ğ‘‚(log2ğ‘›) amortized time. An update (insertion or deletion) in a secondary data structure can easily be handled in ğ‘‚(logğ‘›) time. When we insert into or delete an element x in a BB[ğ›¼] tree that has associated data structures, we add or remove the leaf that contains x, rebalance the tree by rotations, and finally add or remove x from the associated data structures. When we do a left rotation around an edge (ğœ‡,ğœˆ) we have to build a new associated data structure for node ğœ‡ from scratch. See Fig. 7. Right rotations are handled analogously. It is well known that if building the associated data structure at node ğœ‡ takes ğ‘‚(|ğ‘ƒğœ‡|logğ‘|ğ‘ƒğœ‡|) time, for some ğ‘â‰¥0, then the costs of all rebalancing operations in a sequence of m insertions and deletions takes a total of ğ‘‚(ğ‘šlogğ‘+1ğ‘›) time, where n is the maximum size of the tree at any time [9]. We can build a new kinetic tournament ğ‘‹ğ¿ğ‘¢ for node u (using the associated data structures at its children) in linear time. Note that this cost excludes updating the global event queue.

It then follows that the cost of our rebalancing operations is at most ğ‘‚(ğ‘šlogğ‘›). This is dominated by the total number of nodes created and deleted, ğ‘‚(ğ‘šlog2ğ‘›), during these operations. Hence, we can insert or delete a point (square) in ğ‘‡ğ¿ in ğ‘‚(log2ğ‘›) amortized time. â—»

Fig. 7
figure 7
After a left rotation around an edge (ğœ‡,ğœˆ), the associated data structure ğ‘‡ğœ‡ of node ğœ‡ (pink) has to be rebuilt from scratch as its canonical subset has changed. For node ğœˆ we can simply use the old associated data of node ğœ‡. No other nodes are affected

Full size image
Analogous to Lemma 6 we can update ğ‘‡ğ‘… in ğ‘‚(log2ğ‘›) amortized time. Next, we update the linking certificates. We say that a kinetic tournament node v in ğ‘‡ğ¿ is affected by an update if (i) the update added or removed a leaf node in the subtree rooted at v, (ii) node v was involved in a tree rotation, or (iii) v occurs in a newly built associated tree ğ‘‹ğ¿ğ‘¢ (for some node u). Let î‰„ğ¿ğ‘– denote the set of nodes affected by update i. Analogously, we define the set of nodes î‰„ğ‘…ğ‘– of ğ‘‡ğ‘… affected by the update. For each node ğ‘£âˆˆî‰„ğ¿ğ‘–, we query ğ‘‡ğ‘… to find the set of ğ‘‚(log2ğ‘›) nodes whose canonical subsets represent ğ‘„ğ‘…(ğ‘£). For each node w in this set, we test if we have to add a linking certificate between v and w. As we show next, this takes constant time for each node w, and thus ğ‘‚(âˆ‘ğ‘–|î‰„ğ¿ğ‘–|log2ğ‘›) time in total, for all nodes v. We update the linking certificates for all nodes in î‰„ğ‘…ğ‘– analogously.

We have to add a link between a node ğ‘¤âˆˆğ‘„ğ‘…(ğ‘£) and v if and only if we also have ğ‘£âˆˆğ‘„ğ¿(ğ‘¤). We test this as follows. Let u be the node whose associated tree ğ‘‹ğ¿ğ‘¢ contains v. We have that, using the notation introduced in Lemma 4 and coordinates in the rotated system, ğ‘£âˆˆğ‘„ğ¿(ğ‘¤) if and only if ğ‘¢âˆˆğ¶(ğ‘‡ğ¿,[ğ‘šâ¯â¯â¯â¯ğ‘¤ğ‘¥,âˆ)), and ğ‘£âˆˆğ¶(ğ‘‹ğ¿ğ‘¢,[ğ‘šâ¯â¯â¯â¯ğ‘¤ğ‘¦,âˆ)). We can test each of these conditions in constant time:

Observation 7
Let q be a query point in â„1, let v be a node in a binary search tree T, and let ğ‘¥ğ‘=minğ‘ƒğ‘ of the parent p of v in T, or ğ‘¥ğ‘=âˆ’âˆ if no such node exists. We have that ğ‘£âˆˆğ¶(ğ‘‡,[ğ‘,âˆ)) if and only if ğ‘â‰¤minğ‘ƒğ‘£ and ğ‘>ğ‘¥ğ‘.

Proof
We start with the if direction. Since ğ‘>ğ‘¥ğ‘, it holds that ğ‘ƒğ‘âŠ„[ğ‘,âˆ) and hence, ğ‘âˆ‰ğ¶(ğ‘‡,[ğ‘,âˆ)). However ğ‘â‰¤minğ‘ƒğ‘£ and so ğ‘ƒğ‘£âŠ‚[ğ‘,âˆ). Clearly ğ‘£âˆˆğ¶(ğ‘‡,[ğ‘,âˆ)).

For the other direction, observe that ğ‘£âˆˆğ¶(ğ‘‡,[ğ‘,âˆ)) implies that ğ‘ƒğ‘£âŠ‚[ğ‘,âˆ) and so, ğ‘â‰¤minğ‘ƒğ‘£. It also implies that ğ‘âˆ‰ğ¶(ğ‘‡,[ğ‘,âˆ)), hence, ğ‘ƒğ‘âˆ–ğ‘ƒğ‘£âŠ„[ğ‘,âˆ).

It therefore must hold that ğ‘>ğ‘¥ğ‘. â—»

Finally, we delete all certificates involving no longer existing nodes from our global event queue, and replace them by all newly created certificates. This takes ğ‘‚(logğ‘›) time per certificate. We charge the cost of deleting a certificate to when it gets created. Since every node v affected creates at most ğ‘‚(log2ğ‘›) new certificates, all that remains is to bound the total number of affected nodes. We can show this using basically the same argument as we used to bound the update time. This leads to the following result.

Lemma 8
Inserting a disjoint square into P, or deleting a square from P takes ğ‘‚(log5ğ‘›) amortized time.

Proof
An update visits at most ğ‘‚(log2ğ‘›) nodes itself (i.e. leaf nodes and nodes on the search path). All other affected nodes occur as newly built trees due to rebalancing operations. As in Lemma 6, the total number of nodes created due to rotations in a sequence of m updates is ğ‘‚(ğ‘šlog2ğ‘›). It follows that the total number of affected nodes in such a sequence is ğ‘‚(ğ‘šlog2ğ‘›). Therefore, we create ğ‘‚(ğ‘šlog4ğ‘›) linking certificates in total, and we can compute them in ğ‘‚(ğ‘šlog4ğ‘›) time. Updating the event global queue therefore takes ğ‘‚(ğ‘šlog5ğ‘›) time. â—»

Running the Simulation
All that remains is to analyze the number of events processed. We show that in a sequence of m operations, our data structure processes at most ğ‘‚(ğ‘šğ›¼(ğ‘›)log2ğ‘›) events. This leads to the following result.

Theorem 9
We can maintain a set P of n disjoint growing squares in a fully dynamic data structure such that we can detect the first time that a square â—»ğ‘ intersects with a square â—»ğ‘, with ğ‘âˆˆğ¸(ğ‘). Our data structure uses ğ‘‚(ğ‘›logğ‘›loglogğ‘›) space, supports updates in ğ‘‚(log5ğ‘›) amortized time, and queries in ğ‘‚(log2ğ‘›) time. For a sequence of m operations, the structure processes a total of ğ‘‚(ğ‘šğ›¼(ğ‘›)log2ğ‘›) events in a total of ğ‘‚(ğ‘šğ›¼(ğ‘›)log5ğ‘›) time.

Proof
We argued the bounds on the query and the update times before. We argue the space bounds in Sect. 4. All that remains is to bound the number of events processed, and the time to do so.

We start by the observation that each failure of a linking certificate produces an intersection, and thus a subsequent update. It follows that, since we process m updates by definition, the number of such events is at most m.

To bound the number of events created by the tournament trees we extend the argument of Agarwal et al. [1]. For any kinetic tournament node v in ğ‘‡ğ¿, the minimum x-coordinate corresponds to a lower envelope of line-segments in the t, x-space. This envelope has complexity ğ‘‚(|ğ‘ƒâˆ—ğ‘£|ğ›¼(|ğ‘ƒâˆ—ğ‘£|))=ğ‘‚(|ğ‘ƒâˆ—ğ‘£|ğ›¼(ğ‘›)), where ğ‘ƒâˆ—ğ‘£ is the multiset of points that ever occur in ğ‘ƒğ‘£, i.e. that are stored in a leaf of the subtree rooted at v at some time t. Hence, the number of tournament events involving node v is also at most ğ‘‚(|ğ‘ƒâˆ—ğ‘£|ğ›¼(ğ‘›)). It then follows that the total number of events is proportional to the size of these sets ğ‘ƒâˆ—ğ‘£, over all v in our tree. As in Lemma 6, every update directly contributes one point to ğ‘‚(log2ğ‘›) nodes. The remaining contribution is due to rebalancing operations, and this cost is again bounded by ğ‘‚(ğ‘šlog2ğ‘›). Thus, the total number of events processed is ğ‘‚(ğ‘šğ›¼(ğ‘›)log2ğ‘›).

At every event, we have to update the ğ‘‚(log2ğ‘›) linking certificates of v. Because all events incur not only an EXTRACTMIN operation (which takes constant time in some priority queue implementations), but also an insertion into or deletion from the priority queue, every event incurs a ğ‘‚(logğ‘›) time cost. We can thus update the linking certicates in ğ‘‚(log3ğ‘›) time (including the time to update the global event queue). Thus, the total time for processing all kinetic tournament events in ğ‘‡ğ¿ is ğ‘‚(ğ‘šğ›¼(ğ‘›)log5ğ‘›). The analysis for the tournament nodes in ğ‘‡ğ‘… is analogous. â—»

To simulate the process of growing the squares in P, we now maintain two copies of the data structure from Theorem 9: one for east/west intersections and one for north/south intersections. We thus obtain the following result.

Theorem 10
We can maintain a set P of n disjoint growing squares in a fully dynamic data structure such that we can detect the first time that two squares in P intersect. Our data structure uses ğ‘‚(ğ‘›logğ‘›loglogğ‘›) space, supports updates in ğ‘‚(log5ğ‘›) amortized time, and queries in ğ‘‚(log2ğ‘›) time. For a sequence of m operations, the structure processes ğ‘‚(ğ‘šğ›¼(ğ‘›)log2ğ‘›) events in a total of ğ‘‚(ğ‘šğ›¼(ğ‘›)log5ğ‘›) time.

And so we can solve the agglomerative glyph clustering problem as follows.

Theorem 11
Given a set of n initial square glyphs, we can compute an agglomerative clustering of the squares in ğ‘‚(ğ‘›ğ›¼(ğ‘›)log5ğ‘›) time using ğ‘‚(ğ‘›logğ‘›loglogğ‘›) space.

Efficient Representation of Dominance Relations
Our cones for each cardinal direction around a square â—»ğ‘ (defined in Sect. 2) closely resemble dominance relations: essentially they are a dominance relation in a rotated plane. The linking certificates of our data structure, which are built on these cones, actually comprise an efficient representation of all dominance relations between two point sets. We therefore think that this representation, and in particular the tighter analysis in this section, is of independent interest.

Let R and B be two point sets in â„ğ‘‘ with |ğ‘…|=ğ‘› and |ğµ|=ğ‘š, and let ğ‘‡ğ‘… and ğ‘‡ğµ be range trees built on R and B, respectively. We assume that each layer of ğ‘‡ğ‘… and ğ‘‡ğµ consists of a BB[ğ›¼]-tree, although similar analyses can be performed for other types of balanced binary search trees. By definition, every node u on the lowest layer of ğ‘‡ğ‘… or ğ‘‡ğµ has an associated d-dimensional range ğ‘„ğ‘¢ (the hyper-box, not the subset of points). For a node ğ‘¢âˆˆğ‘‡ğ‘…, we consider the subset of points in B that dominate all points in ğ‘„ğ‘¢, which can be comprised of ğ‘‚(logğ‘‘ğ‘š) canonical subsets of B, represented by nodes in ğ‘‡ğµ. Similarly, for a node ğ‘£âˆˆğ‘‡ğµ, we consider the subset of points in R that are dominated by all points in ğ‘„ğ‘£, which can be comprised of ğ‘‚(logğ‘‘ğ‘›) canonical subsets of R, represented by nodes in ğ‘‡ğ‘…. We now link a node ğ‘¢âˆˆğ‘‡ğ‘… and a node ğ‘£âˆˆğ‘‡ğµ if and only if v represents such a canonical subset for u and vice versa. By repeatedly applying Lemma 4 for each dimension, it can easily be shown that these links represent all dominance relations between R and B.

As a d-dimensional range tree consists of ğ‘‚(ğ‘›logğ‘‘âˆ’1ğ‘›) nodes, a trivial bound on the number of links is ğ‘‚(ğ‘šlog2ğ‘‘âˆ’1ğ‘›) (assuming ğ‘›â‰¥ğ‘š). Below we show that the number of links can be bounded by ğ‘‚(ğ‘›(logğ‘›loglogğ‘›)ğ‘‘âˆ’1). We first consider the case for ğ‘‘=1.

Analyzing the Number of Links in 1D
Let R and B be point sets in â„ with |ğ‘…|=ğ‘›, |ğµ|=ğ‘š, and ğ‘›â‰¥ğ‘š. Now, every associated range of a node u in ğ‘‡ğ‘… or ğ‘‡ğµ is an interval ğ¼ğ‘¢. We can extend the interval to infinity in one direction; to the left for ğ‘¢âˆˆğ‘‡ğ‘…, and to the right for ğ‘¢âˆˆğ‘‡ğµ. For analysis purposes we construct another range tree T on ğ‘…âˆªğµ, where T is not a BB[ğ›¼]-tree, but instead a perfectly balanced tree with height âŒˆlog(ğ‘›+ğ‘š)âŒ‰. For convenience we assume that the associated intervals of T are slightly expanded so that all points in ğ‘…âˆªğµ are always interior to the associated intervals. We associate a node u in ğ‘‡ğ‘… or ğ‘‡ğµ with a node v in T if the endpoint of ğ¼ğ‘¢ is contained in the associated interval ğ¼ğ‘£ of v.

Observation 12
Every node of ğ‘‡ğ‘… or ğ‘‡ğµ is associated with at most one node per level of T.

For two intervals ğ¼ğ‘¢=(âˆ’âˆ,ğ‘] and ğ¼ğ‘£=[ğ‘,âˆ), corresponding to a node ğ‘¢âˆˆğ‘‡ğ‘… and a node ğ‘£âˆˆğ‘‡ğµ, let [a, b] be the spanning interval of u and v. We now want to charge spanning intervals of links to nodes of T. We charge a spanning interval ğ¼ğ‘¢ğ‘£=[ğ‘,ğ‘] to a node w of T if and only if [a, b] is a subset of ğ¼ğ‘¤, and [a, b] is cut by the splitting coordinate of w. Clearly, every spanning interval can be charged to exactly one node of T.

Now, for a node u of T, let â„ğ‘…(ğ‘¢) be the height of the highest node of ğ‘‡ğ‘… associated with u, and let â„ğµ(ğ‘¢) be the height of the highest node of ğ‘‡ğµ associated with u.

Lemma 13
The number of spanning intervals charged to a node u of T is ğ‘‚(â„ğ‘…(ğ‘¢)â‹…â„ğµ(ğ‘¢)).

Proof
Let x be the splitting coordinate of u and let ğ‘Ÿâˆˆğ‘‡ğ‘… and ğ‘âˆˆğ‘‡ğµ form a spanning interval that is charged to u. We claim that, using the notation introduced in Lemma 4, ğ‘Ÿâˆˆğ¶(ğ‘‡ğ‘…,(âˆ’âˆ,ğ‘¥]) (and symmetrically, ğ‘âˆˆğ¶(ğ‘‡ğµ,[ğ‘¥,âˆ))). Let ğ¼ğ‘=[ğ‘¥â€²,âˆ) be the associated interval of b, where ğ‘¥â€²>ğ‘¥. By definition, ğ‘Ÿâˆˆğ¶(ğ‘‡ğ‘…,(âˆ’âˆ,ğ‘¥â€²]). If ğ‘Ÿâˆ‰ğ¶(ğ‘‡ğ‘…,(âˆ’âˆ,ğ‘¥]), then the right endpoint of ğ¼ğ‘Ÿ must lie between x and ğ‘¥â€². But then the spanning interval of r and b would not be charged to u. As a result, we can only charge spanning intervals between â„ğ‘…(ğ‘¢) nodes of ğ‘‡ğ‘… and â„ğµ(ğ‘¢) nodes of ğ‘‡ğµ, of which there are at most ğ‘‚(â„ğ‘…(ğ‘¢)â‹…â„ğµ(ğ‘¢)). â—»

Using Lemma 13, we count the total number of charged spanning intervals and hence, links between ğ‘‡ğ‘… and ğ‘‡ğµ. We refer to this number as numLinks(ğ‘‡ğ‘…,ğ‘‡ğµ). This is simply âˆ‘ğ‘¢âˆˆğ‘‡ğ‘‚(â„ğ‘…(ğ‘¢)â‹…â„ğµ(ğ‘¢))â‰¤âˆ‘ğ‘¢âˆˆğ‘‡ğ‘‚(â„ğ‘…(ğ‘¢)2+â„ğµ(ğ‘¢)2). We can split the sum and assume w.l.o.g. that numLinks(ğ‘‡ğ‘…,ğ‘‡ğµ)â‰¤2âˆ‘ğ‘¢âˆˆğ‘‡ğ‘‚(â„ğ‘…(ğ‘¢)2). Rewriting the sum based on heights in ğ‘‡ğ‘… gives

numLinks(ğ‘‡ğ‘…,ğ‘‡ğµ)â‰¤âˆ‘â„ğ‘…=0height(ğ‘‡ğ‘…)ğ‘›ğ‘‡(â„ğ‘…)â‹…ğ‘‚(â„2ğ‘…),
where ğ‘›ğ‘‡(â„ğ‘…) is the number of nodes of T that have a node of height â„ğ‘… associated with it.

To bound ğ‘›ğ‘‡(â„) we use Observation 12 and the fact that ğ‘‡ğ‘… is a BB[ğ›¼] tree. Let ğ‘=11âˆ’ğ›¼, then we get that height(ğ‘‡ğ‘…)â‰¤logğ‘(ğ‘›) from properties of BB[ğ›¼] trees. Therefore, the number of nodes in ğ‘‡ğ‘… that have height h is at most ğ‘‚(ğ‘›ğ‘â„).

Lemma 14
ğ‘›ğ‘‡(â„)=ğ‘‚((ğ‘›+ğ‘š)â„ğ‘â„).

Proof
As argued, there are at most ğ‘‚(ğ‘›/ğ‘â„) nodes in ğ‘‡ğ‘… of height h. Consider cutting the tree T at level log(ğ‘›/ğ‘â„). This results in a top tree of size ğ‘‚(ğ‘›/ğ‘â„), and ğ‘‚(ğ‘›/ğ‘â„) bottom trees. Clearly, the top tree contributes at most its size to ğ‘›ğ‘‡(â„). All bottom trees have height at most âŒˆlog(ğ‘›+ğ‘š)âŒ‰âˆ’log(ğ‘›/ğ‘â„)=ğ‘‚(log(ğ‘â„)+log(1+ğ‘š/ğ‘›))=ğ‘‚(â„+ğ‘š/ğ‘›). Every node in ğ‘‡ğ‘… of height h can, in the worst case, be associated with one distinct node per level in the bottom trees by Observation 12. Hence, the bottom trees contribute at most ğ‘‚(ğ‘›(â„+ğ‘š/ğ‘›)/ğ‘â„)=ğ‘‚((ğ‘›â„+ğ‘š)/ğ‘â„)=ğ‘‚((ğ‘›+ğ‘š)â„/ğ‘â„) to ğ‘›ğ‘‡(â„). â—»

Using this bound on ğ‘›ğ‘‡(â„) in the sum we previously obtained gives:

numLinks(ğ‘‡ğ‘…,ğ‘‡ğµ)â‰¤âˆ‘â„ğ‘…=0â„ğ‘’ğ‘–ğ‘”â„ğ‘¡(ğ‘‡ğ‘…)ğ‘‚((ğ‘›+ğ‘š)â„3ğ‘…ğ‘â„ğ‘…)â‰¤ğ‘‚(ğ‘›+ğ‘š)âˆ‘â„=0âˆâ„3ğ‘â„=ğ‘‚(ğ‘›+ğ‘š).
Where indeed, âˆ‘âˆâ„=0â„3ğ‘â„=ğ‘‚(1) because ğ‘>1. Thus, we conclude:

Theorem 15
The number of links between two 1-dimensional range trees ğ‘‡ğ‘… and ğ‘‡ğµ containing n and m points, respectively, is bounded by ğ‘‚(ğ‘›+ğ‘š).

Extending to Higher Dimensions
We now extend the bound to d dimensions. The idea is very simple. We first determine the links for the top-layer of the range trees. This results in links between associated range trees of ğ‘‘âˆ’1 dimensions (see Fig. 8). We then determine the links within the linked associated trees, which number can be bounded by induction on d.

Fig. 8
figure 8
Two layered trees with two layers, and the links between them (sketched in black). We are interested in bounding the number of such links

Full size image
Theorem 16
The number of links between two d-dimensional range trees ğ‘‡ğ‘… and ğ‘‡ğµ containing respectively n and m (ğ‘›â‰¥ğ‘š) points is bounded by ğ‘‚(ğ‘›(logğ‘›loglogğ‘›)ğ‘‘âˆ’1).

Proof
We show by induction on d that the number of links is bounded by the minimum of ğ‘‚(ğ‘›(logğ‘›loglogğ‘›)ğ‘‘âˆ’1) and ğ‘‚(ğ‘šlog2ğ‘‘âˆ’1ğ‘›). The second bound is simply the trivial bound given at the start of Sect. 4. The base case for ğ‘‘=1 is provided by Theorem 15. Now consider the case for ğ‘‘>1. We first determine the links for the top-layer of ğ‘‡ğ‘… and ğ‘‡ğµ. Now consider the links between an associated tree ğ‘‡ğ‘¢ in ğ‘‡ğ‘… containing k points and other associated trees ğ‘‡0,â€¦,ğ‘‡ğ‘Ÿ that contain at most k points. Since ğ‘‡ğ‘¢ can be linked with only one associated tree per level, and because both range trees use BB[ğ›¼] trees, the number of points ğ‘š0,â€¦,ğ‘šğ‘Ÿ in ğ‘‡0,â€¦,ğ‘‡ğ‘Ÿ satisfy ğ‘šğ‘–â‰¤ğ‘˜/ğ‘ğ‘– (0â‰¤ğ‘–â‰¤ğ‘Ÿ) where ğ‘=11âˆ’ğ›¼. By induction, the number of links between ğ‘‡ğ‘¢ and ğ‘‡ğ‘– is bounded by the minimum of ğ‘‚(ğ‘˜(logğ‘›loglogğ‘›)ğ‘‘âˆ’2) and ğ‘‚(ğ‘šğ‘–log2ğ‘‘âˆ’3ğ‘›). Now let ğ‘–âˆ—=logğ‘(logğ‘‘âˆ’1ğ‘›)=ğ‘‚(loglogğ‘›). Then, for ğ‘–â‰¥ğ‘–âˆ—, we get that ğ‘‚(ğ‘šğ‘–log2ğ‘‘âˆ’3ğ‘›)=ğ‘‚(ğ‘˜logğ‘‘âˆ’2ğ‘›). Since the sizes of the associated trees decrease geometrically, the total number of links between ğ‘‡ğ‘¢ and ğ‘‡ğ‘– for ğ‘–â‰¥ğ‘–âˆ— is bounded by ğ‘‚(ğ‘˜logğ‘‘âˆ’2ğ‘›). The links with the remaining trees can be bounded by ğ‘‚(ğ‘˜logğ‘‘âˆ’2ğ‘›(loglogğ‘›)ğ‘‘âˆ’1). Finally note that the top-layer of each range tree has ğ‘‚(logğ‘›) levels, and that each level contains n points in total. Thus, we obtain ğ‘‚(ğ‘›logğ‘‘âˆ’1ğ‘›(loglogğ‘›)ğ‘‘âˆ’1) links in total. The remaining links for which the associated tree in ğ‘‡ğµ is larger than in ğ‘‡ğ‘… can be bounded in the same way. â—»

It follows from Theorem 16 that our data structure from Sect. 3 actually maintains only ğ‘‚(ğ‘›logğ‘›loglogğ‘›) certificates. That number is significantly lower than our initial analysis showed: at the end of Sect. 3.1 we analyzed the space usage to be ğ‘‚(ğ‘›log3ğ‘›). The number of certicates, even under the tighter analysis, however still slightly dominates the space usage of the 2D range trees and kinetic tournaments, which is ğ‘‚(ğ‘›logğ‘›). Our data structure thus uses only ğ‘‚(ğ‘›logğ‘›loglogğ‘›) space.

Conclusion and Future Work
We presented an efficient fully dynamic data structure for maintaining a set of disjoint growing squares. This leads to an efficient algorithm for agglomerative glyph clustering. The main future challenge is to improve the analysis of the running time. Our analysis from Sect. 4 shows that at any time, we need only few linking certificates. However, we would like to bound the total number of linking certificates used throughout the entire sequence of operations. An interesting question is if we can extend our argument to this case. This may also lead to a more efficient algorithm for maintaining the linking certificates during updates.