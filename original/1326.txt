Abstract
Given a finite set of weighted points in â„ğ‘‘ (where there can be negative weights), the maximum box problem asks for an axis-aligned rectangle (i.e., box) such that the sum of the weights of the points that it contains is maximized. We consider that each point of the input has a probability of being present in the final random point set, and these events are mutually independent; then, the total weight of a maximum box is a random variable. We aim to compute both the probability that this variable is at least a given parameter, and its expectation. We show that even in ğ‘‘=1 these computations are #P-hard, and give pseudo-polynomial time algorithms in the case where the weights are integers in a bounded interval. For ğ‘‘=2, we consider that each point is colored red or blue, where red points have weight +1 and blue points weight âˆ’âˆ. The random variable is the maximum number of red points that can be covered with a box not containing any blue point. We prove that the above two computations are also #P-hard, and give a polynomial-time algorithm for computing the probability that there is a box containing exactly two red points, no blue point, and a given point of the plane.

Introduction
The maximum box problem receives as input a finite point set in â„ğ‘‘, where each point is associated with a positive or negative weight, and outputs an axis-aligned rectangle (i.e., box) such that the sum of the weights of the points that it contains is maximized [3]. We consider this problem on a recent uncertainty model in which each element of the input has assigned a probability. Particularly, each point has assigned its own and independent probability of being present in the final (hence random) point set. Then, one can ask the following questions: What is the probability that for the final point set there exists a box that covers a weight sum greater than or equal to a given parameter? What is the expectation of the maximum weight sum that can be covered with a box? Uncertainty models come from real scenarios in which large amounts of data, arriving from many sources, have inherent uncertainty. In computational geometry, we can find several recent works on uncertain point sets such as: the expected total length of the minimum Euclidean spanning tree [5]; the probability that the distance between the closest pair of points is at least a given parameter [11]; the computation of the most-likely convex hull [16]; the probability that the area or perimeter of the convex hull is at least a given parameter [15]; the smallest enclosing ball [9]; the probability that a 2-colored point set is linearly separable [10]; the area of the minimum enclosing rectangle [17]; and Kleeâ€™s measure of random rectangles [20]. We deal with the maximum box problem in the above mentioned random model. The maximum box problem is a geometric combinatorial optimization problem, different from most of the problems considered in this random setting that are computations of some measure or structure of the extent of the geometric objects.

For ğ‘‘=1, the maximum box problem asks for an interval of the line. If the points are uncertain as described above, then it is equivalent to consider as input a sequence of random numbers, where each number has two possible outcomes: zero if the number is not present and the actual value of the number otherwise. The output is the subsequence of consecutive numbers with maximum sum. We consider the simpler case when the subsequence is a partial sum, that is, it contains the first (or leftmost) number of the sequence. More formally: We say that a random variable X is zero-value if ğ‘‹=ğ‘£ with probability ğœŒ, and ğ‘‹=0 with probability 1âˆ’ğœŒ, for an integer number ğ‘£=ğ‘£(ğ‘‹)â‰ 0 and a probability ğœŒ. We refer to v as the value of X and to ğœŒ as the probability of X. In any sequence of zero-value variables, all variables are assumed to be mutually independent. Let î‰„=ğ‘‹1,ğ‘‹2,â€¦,ğ‘‹ğ‘› be a sequence of n mutually independent zero-value variables, whose values are ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›, respectively. We study the random variable


ğ–²(î‰„) = max{0,ğ‘‹1,ğ‘‹1+ğ‘‹2,â€¦,ğ‘‹1+â‹¯+ğ‘‹ğ‘›},

which is the maximum partial sum of the random sequence î‰„. The fact that ğ”¼[max{ğ‘‹,ğ‘Œ}] is not necessarily max{ğ”¼[ğ‘‹],ğ”¼[ğ‘Œ]}, even if X and Y are independent random variables, makes hard the computation of the expectation ğ”¼[ğ–²(î‰„)].

Kleinberg et al. [13] proved that the problem of computing Pr[ğ‘‹1+â‹¯+ğ‘‹ğ‘›>1] is #P-complete, in the case where the values of the variables ğ‘‹1,ğ‘‹2,â€¦,ğ‘‹ğ‘› are all positive. The proof can be straightforwardly adapted to also show that computing Pr[ğ‘‹1+â‹¯+ğ‘‹ğ‘›>ğ‘§] is #P-complete, where the values of ğ‘‹1,ğ‘‹2,â€¦,ğ‘‹ğ‘› are all positive, for any fixed ğ‘§>0. This last fact implies that computing Pr[ğ–²(î‰„)â‰¥ğ‘§] for any fixed ğ‘§â‰¥1 is #P-hard. We show hardness results when the probabilities of ğ‘‹1,ğ‘‹2,â€¦,ğ‘‹ğ‘› are the same, and their values are not necessarily positive. Namely, we prove (Sect. 2.1) that computing Pr[ğ–²(î‰„)â‰¥ğ‘§] for any fixed ğ‘§â‰¥1, and computing the expectation ğ”¼[ğ–²(î‰„)] are both #P-hard problems, even if all variables of î‰„ have the same less-than-one probability. When ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›âˆˆ[âˆ’ğ‘..ğ‘] for bounded ğ‘,ğ‘âˆˆâ„•, we show (Sect. 2.2) that both Pr[ğ–²(î‰„)â‰¥ğ‘§] and ğ”¼[ğ–²(î‰„)] can be computed in time polynomial in n, a, and b. For two integers ğ‘¢<ğ‘£, we use [u..v] to denote the set {ğ‘¢,ğ‘¢+1,â€¦,ğ‘£}.

For ğ‘‘=2, we consider the maximum box problem in the context of red and blue points, where red points have weight +1 and blue points weight âˆ’âˆ. Let R and B be disjoint finite point sets in the plane with a total of n points, where the elements of R are colored red and the elements of B are colored blue. The maximum box problem asks for a box H such that |ğ»âˆ©ğ‘…| is maximized subject to |ğ»âˆ©ğµ|=âˆ…. This problem has been well studied, with algorithms whose running times go from ğ‘‚(ğ‘›2logğ‘›) [6], ğ‘‚(ğ‘›2) [3], to ğ‘‚(ğ‘›log3ğ‘›) [2]. Let ğ‘†âŠ†ğ‘…âˆªğµ be the random point set where every point ğ‘âˆˆğ‘…âˆªğµ is included in S independently and uniformly at random with probability ğœ‹(ğ‘)âˆˆ[0,1]. Let ğ–»ğ—ˆğ—‘(ğ‘†) denote the random variable equal to the maximum number of red points in S that can be covered with a box not covering any blue point of S.

We prove (Sect. 3.1) that computing the probability Pr[ğ–»ğ—ˆğ—‘(ğ‘†)â‰¥ğ‘˜] for any given ğ‘˜â‰¥2, and computing the expectation ğ”¼[ğ–»ğ—ˆğ—‘(ğ‘†)], are both #P-hard problems. We further show (Sect. 3.2) that given a point o of the plane, computing the probability that there exists a box containing exactly two red points of S, no blue point of S, and the point o can be solved in polynomial time. If we remove the restriction of containing o, this problem is also #P-hard. This fact is a direct consequence of the previous #P-hardness proofs.

In all running time upper bounds in this paper, in both algorithms and reductions, we assume a real RAM model of computation where each arithmetic operation on large-precision numbers takes constant time. Otherwise, the running times should be multiplied by a factor proportional to the bit complexity of the numbers, which is polynomial in n and the bit complexity of the input probability values [5, 11].

Weighted Points
Hardness
Theorem 1
For any integer ğ‘§â‰¥1 and any ğœŒâˆˆ(0,1), the following problem is #P-hard: Given a sequence î‰„=ğ‘‹1,ğ‘‹2,â€¦,ğ‘‹ğ‘› of n zero-value random variables, each with probability ğœŒ, compute Pr[ğ–²(î‰„)â‰¥ğ‘§].

Proof
Let ğ‘§â‰¥1 be an integer, and ğœŒâˆˆ(0,1) be a probability. We show a Turing reduction from the #SubsetSum problem, which is known to be #P-complete [8]. Our reduction assumes an unknown algorithm (i.e., oracle) îˆ­(î‰„) computing Pr[ğ–²(î‰„)â‰¥ğ‘§] for any finite sequence î‰„ of zero-value random variables, that will be called twice. #SubsetSum receives as input a set {ğ‘1,â€¦,ğ‘ğ‘›}âŠ‚â„• of n numbers and a target ğ‘¡âˆˆâ„•, and counts the number of subsets ğ½âŠ†[1..ğ‘›] such that âˆ‘ğ‘—âˆˆğ½ğ‘ğ‘—=ğ‘¡. It remains #P-hard if the subsets J must also satisfy |ğ½|=ğ‘˜, for given ğ‘˜âˆˆ[1..ğ‘›]. Let ({ğ‘1,â€¦,ğ‘ğ‘›},ğ‘¡,ğ‘˜) be an instance of this #SubsetSum, in which we assume ğ‘¡â‰¤ğ‘1+â‹¯+ğ‘ğ‘›.

Let ğ‘š=max{ğ‘§,1+ğ‘1+â‹¯+ğ‘ğ‘›}>ğ‘¡, and î‰„=ğ‘‹0,ğ‘‹1,ğ‘‹2,â€¦,ğ‘‹ğ‘› be a sequence of ğ‘›+1 zero-value random variables, each with probability ğœŒ, where the value of ğ‘‹0 is âˆ’ğ‘˜ğ‘šâˆ’ğ‘¡+ğ‘§, and the value of ğ‘‹ğ‘– is ğ‘š+ğ‘ğ‘– for every ğ‘–âˆˆ[1..ğ‘›]. Observe that for ğ½âŠ†[1..ğ‘›] we have


âˆ‘ğ‘—âˆˆğ½(ğ‘š+ğ‘ğ‘—)=ğ‘˜ğ‘š+ğ‘¡ â‡” (âˆ‘ğ‘—âˆˆğ½ğ‘ğ‘—=ğ‘¡ and |ğ½|=ğ‘˜).

Furthermore, |ğ½|>ğ‘˜ implies âˆ‘ğ‘—âˆˆğ½(ğ‘š+ğ‘ğ‘—)>ğ‘˜ğ‘š+ğ‘¡.

Let ğ½î‰„={ğ‘—âˆˆ[1..ğ‘›]:ğ‘‹ğ‘—â‰ 0}, and for any s, let


ğ‘ğ‘  = âˆ£âˆ£âˆ£ğ½âŠ†[1..ğ‘›]:|ğ½|=ğ‘˜,âˆ‘ğ‘—âˆˆğ½ğ‘ğ‘—â‰¥ğ‘ âˆ£âˆ£âˆ£.

Then, #SubsetSum asks for ğ‘ğ‘¡âˆ’ğ‘ğ‘¡+1. Call îˆ­(î‰„) to compute Pr[ğ–²(î‰„)â‰¥ğ‘§]. Then:


Pr[ğ–²(î‰„)â‰¥ğ‘§] = Pr[ğ–²(î‰„)â‰¥ğ‘§,ğ‘‹0=0]+Pr[ğ–²(î‰„)â‰¥ğ‘§,ğ‘‹0=âˆ’ğ‘˜ğ‘šâˆ’ğ‘¡+ğ‘§]

where,


Pr[ğ–²(î‰„)â‰¥ğ‘§,ğ‘‹0=0] = Pr[ğ‘‹0=0]â‹…Pr[ğ–²(î‰„)â‰¥ğ‘§âˆ£ğ‘‹0=0] = (1âˆ’ğœŒ)â‹…Pr[|ğ½î‰„|â‰¥1] = (1âˆ’ğœŒ)â‹…(1âˆ’Pr[|ğ½î‰„|=0]) = (1âˆ’ğœŒ)â‹…(1âˆ’(1âˆ’ğœŒ)ğ‘›),

and


Pr[ğ–²(î‰„)â‰¥ğ‘§,ğ‘‹0=âˆ’ğ‘˜ğ‘šâˆ’ğ‘¡+ğ‘§]= Pr[ğ‘‹0=âˆ’ğ‘˜ğ‘šâˆ’ğ‘¡+ğ‘§]â‹…Pr[ğ–²(î‰„)â‰¥ğ‘§âˆ£ğ‘‹0=âˆ’ğ‘˜ğ‘šâˆ’ğ‘¡+ğ‘§]= ğœŒâ‹…Pr[âˆ’ğ‘˜ğ‘šâˆ’ğ‘¡+ğ‘§+âˆ‘ğ‘—âˆˆğ½î‰„(ğ‘š+ğ‘ğ‘—)â‰¥ğ‘§]=ğœŒâ‹…Pr[âˆ‘ğ‘—âˆˆğ½î‰„(ğ‘š+ğ‘ğ‘—)â‰¥ğ‘˜ğ‘š+ğ‘¡]= ğœŒâ‹…(Pr[|ğ½î‰„|=ğ‘˜,âˆ‘ğ‘—âˆˆğ½î‰„(ğ‘š+ğ‘ğ‘—)â‰¥ğ‘˜ğ‘š+ğ‘¡]+âˆ‘ğ‘–=ğ‘˜+1ğ‘›Pr[|ğ½î‰„|=ğ‘–,âˆ‘ğ‘—âˆˆğ½î‰„(ğ‘š+ğ‘ğ‘—)â‰¥ğ‘˜ğ‘š+ğ‘¡])= ğœŒâ‹…Pr[|ğ½î‰„|=ğ‘˜,âˆ‘ğ‘—âˆˆğ½î‰„ğ‘ğ‘—â‰¥ğ‘¡]+ğœŒâ‹…âˆ‘ğ‘–=ğ‘˜+1ğ‘›Pr[|ğ½î‰„|=ğ‘–]= ğœŒâ‹…ğ‘ğ‘¡â‹…ğœŒğ‘˜â‹…(1âˆ’ğœŒ)ğ‘›âˆ’ğ‘˜+ğœŒâ‹…âˆ‘ğ‘–=ğ‘˜+1ğ‘›(ğ‘›ğ‘–)â‹…ğœŒğ‘–â‹…(1âˆ’ğœŒ)ğ‘›âˆ’ğ‘–.

Hence, we can compute ğ‘ğ‘¡ in polynomial time from the value of Pr[ğ–²(î‰„)â‰¥ğ‘§]. Consider now the random sequence î‰„â€²=ğ‘‹â€²0,ğ‘‹1,ğ‘‹2,â€¦,ğ‘‹ğ‘›, where ğ‘‹â€²0 has value âˆ’ğ‘˜ğ‘šâˆ’(ğ‘¡+1)+ğ‘§. Using arguments similar to those above, by calling îˆ­(î‰„â€²) to compute Pr[ğ–²(î‰„â€²)â‰¥ğ‘§], we can compute ğ‘ğ‘¡+1 in polynomial time from this probability. Then, ğ‘ğ‘¡âˆ’ğ‘ğ‘¡+1 can be computed in polynomial time, plus the time of calling twice the oracle îˆ­. This implies the theorem. â—»

Theorem 2
For any ğœŒâˆˆ(0,1), the following problem is #P-hard: Given a sequence î‰„=ğ‘‹1,â€¦,ğ‘‹ğ‘› of n zero-value random variables, each with probability ğœŒ, compute ğ”¼[ğ–²(î‰„)].

Proof
Let î‰„=ğ‘‹1,ğ‘‹2,â€¦,ğ‘‹ğ‘› be a sequence of zero-value random variables, each with probability ğœŒ, and consider the sequence î‰„â€²=ğ‘‹0,ğ‘‹1,â€¦,ğ‘‹ğ‘›, where ğ‘‹0 is a zero-value random variable with value âˆ’1 and probability ğœŒ. Let w be the sum of the positive values among the values of ğ‘‹1,â€¦,ğ‘‹ğ‘›. Then:


ğ”¼[ğ–²(î‰„)] = âˆ‘ğ‘–=1ğ‘¤ğ‘–â‹…Pr[ğ–²(î‰„)=ğ‘–] = âˆ‘ğ‘–=1ğ‘¤Pr[ğ–²(î‰„)â‰¥ğ‘–],

and


ğ”¼[ğ–²(î‰„â€²)] = âˆ‘ğ‘–=1ğ‘¤Pr[ğ–²(î‰„â€²)â‰¥ğ‘–] = âˆ‘ğ‘–=1ğ‘¤(Pr[ğ–²(î‰„â€²)â‰¥ğ‘–,ğ‘‹0=0]+Pr[ğ–²(î‰„â€²)â‰¥ğ‘–,ğ‘‹0=âˆ’1]) = âˆ‘ğ‘–=1ğ‘¤(Pr[ğ‘‹0=0]â‹…Pr[ğ–²(î‰„â€²)â‰¥ğ‘–âˆ£ğ‘‹0=0] +Pr[ğ‘‹0=âˆ’1]â‹…Pr[ğ–²(î‰„â€²)â‰¥ğ‘–âˆ£ğ‘‹0=âˆ’1]) = âˆ‘ğ‘–=1ğ‘¤((1âˆ’ğœŒ)â‹…Pr[ğ–²(î‰„)â‰¥ğ‘–]+ğœŒâ‹…Pr[ğ–²(î‰„)â‰¥ğ‘–+1]) = âˆ‘ğ‘–=1ğ‘¤(1âˆ’ğœŒ)â‹…Pr[ğ–²(î‰„)â‰¥ğ‘–]+âˆ‘ğ‘–=2ğ‘¤+1ğœŒâ‹…Pr[ğ–²(î‰„)â‰¥ğ‘–] = (1âˆ’ğœŒ)â‹…Pr[ğ–²(î‰„)â‰¥1]+âˆ‘ğ‘–=2ğ‘¤Pr[ğ–²(î‰„)â‰¥ğ‘–].

Then, we have that


ğ”¼[ğ–²(î‰„)]âˆ’ğ”¼[ğ–²(î‰„â€²)] = ğœŒâ‹…Pr[ğ–²(î‰„)â‰¥1].

Since computing Pr[ğ–²(î‰„)â‰¥1] is #P-hard (Theorem 1), then computing ğ”¼[ğ–²(î‰„)] is also #P-hard via a Turing reduction. â—»

Pseudo-Polynomial Time Algorithms
Let î‰„=ğ‘‹1,ğ‘‹2,â€¦,ğ‘‹ğ‘› be a sequence of n zero-value random variables, with values ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›âˆˆ[âˆ’ğ‘..ğ‘]âŠ‚â„¤ and probabilities ğœŒ1,ğœŒ2,â€¦,ğœŒğ‘›, respectively, for some ğ‘,ğ‘âˆˆâ„•. We show that both Pr[ğ–²(î‰„)â‰¥ğ‘§] and ğ”¼[ğ–²(î‰„)] can be computed in time polynomial in n, a, and b. Let ğ½={ğ‘—âˆˆ[1..ğ‘›]:ğ‘ğ‘—<0} and


ğ‘¤0 = âˆ‘ğ‘—âˆˆğ½|ğ‘ğ‘—| = ğ‘‚(ğ‘›ğ‘)  and  ğ‘¤1 =âˆ‘ğ‘—âˆˆ[1..ğ‘›]âˆ–ğ½ğ‘ğ‘— = ğ‘‚(ğ‘›ğ‘).

For every ğ‘¡âˆˆ[1..ğ‘›], let


ğ‘†ğ‘¡ğ¿ğ‘¡ = ğ‘‹1+â‹¯+ğ‘‹ğ‘¡,  ğ‘€ğ‘¡ = max{0,ğ‘†1,ğ‘†2,â€¦,ğ‘†ğ‘¡},  and = {Pr[ğ‘€ğ‘¡=ğ‘˜,ğ‘†ğ‘¡=ğ‘ ]:ğ‘˜âˆˆ[0..ğ‘¤1],ğ‘ âˆˆ[âˆ’ğ‘¤0..ğ‘¤1],ğ‘˜â‰¥ğ‘ }.

Observe that ğ¿ğ‘¡ has size ğ‘‚(ğ‘¤1(ğ‘¤0+ğ‘¤1))=ğ‘‚(ğ‘›ğ‘(ğ‘›ğ‘+ğ‘›ğ‘))=ğ‘‚(ğ‘›2ğ‘(ğ‘+ğ‘)) for every t, and that ğ¿1 can be trivially computed. Using the dynamic programming algorithm design paradigm, we next show how to compute the values of ğ¿ğ‘¡, ğ‘¡â‰¥2, assuming that all values of ğ¿ğ‘¡âˆ’1 have been computed. Note that:


Pr[ğ‘€ğ‘¡=ğ‘˜,ğ‘†ğ‘¡=ğ‘ ]=Pr[ğ‘€ğ‘¡=ğ‘˜,ğ‘†ğ‘¡=ğ‘ ,ğ‘‹ğ‘¡=0]+Pr[ğ‘€ğ‘¡=ğ‘˜,ğ‘†ğ‘¡=ğ‘ ,ğ‘‹ğ‘¡=ğ‘ğ‘¡],

where


Pr[ğ‘€ğ‘¡=ğ‘˜,ğ‘†ğ‘¡=ğ‘ ,ğ‘‹ğ‘¡=0] = Pr[ğ‘‹ğ‘¡=0]â‹…Pr[ğ‘€ğ‘¡=ğ‘˜,ğ‘†ğ‘¡=ğ‘ âˆ£ğ‘‹ğ‘¡=0] = (1âˆ’ğœŒğ‘¡)â‹…Pr[ğ‘€ğ‘¡âˆ’1=ğ‘˜,ğ‘†ğ‘¡âˆ’1=ğ‘ ]

and


Pr[ğ‘€ğ‘¡=ğ‘˜,ğ‘†ğ‘¡=ğ‘ ,ğ‘‹ğ‘¡=ğ‘ğ‘¡] = Pr[ğ‘‹ğ‘¡=ğ‘ğ‘¡]â‹…Pr[ğ‘€ğ‘¡=ğ‘˜,ğ‘†ğ‘¡=ğ‘ âˆ£ğ‘‹ğ‘¡=ğ‘ğ‘¡] = ğœŒğ‘¡â‹…Pr[ğ‘€ğ‘¡=ğ‘˜,ğ‘†ğ‘¡=ğ‘ âˆ£ğ‘‹ğ‘¡=ğ‘ğ‘¡].

When ğ‘˜=ğ‘ , we have for ğ‘ğ‘¡<0 that Pr[ğ‘€ğ‘¡=ğ‘˜,ğ‘†ğ‘¡=ğ‘ âˆ£ğ‘‹ğ‘¡=ğ‘ğ‘¡]=0, since this event indicates that ğ‘†ğ‘¡=ğ‘‹1+â‹¯+ğ‘‹ğ‘¡ is a maximum partial sum of ğ‘‹1,â€¦,ğ‘‹ğ‘¡, but this cannot happen because any maximum partial sum ends in a positive element. For ğ‘ğ‘¡>0 we have


Pr[ğ‘€ğ‘¡=ğ‘˜,ğ‘†ğ‘¡=ğ‘ âˆ£ğ‘‹ğ‘¡=ğ‘ğ‘¡] = Pr[ğ‘€ğ‘¡âˆ’1â‰¤ğ‘˜,ğ‘†ğ‘¡âˆ’1=ğ‘ âˆ’ğ‘ğ‘¡] = âˆ‘ğ‘–=ğ‘ âˆ’ğ‘ğ‘¡ğ‘˜Pr[ğ‘€ğ‘¡âˆ’1=ğ‘–,ğ‘†ğ‘¡âˆ’1=ğ‘ âˆ’ğ‘ğ‘¡].

When ğ‘˜>ğ‘ , ğ‘€ğ‘¡ does not count the element ğ‘ğ‘¡, hence ğ‘€ğ‘¡âˆ’1=ğ‘€ğ‘¡. Then


Pr[ğ‘€ğ‘¡=ğ‘˜,ğ‘†ğ‘¡=ğ‘ âˆ£ğ‘‹ğ‘¡=ğ‘ğ‘¡] = Pr[ğ‘€ğ‘¡âˆ’1=ğ‘˜,ğ‘†ğ‘¡âˆ’1=ğ‘ âˆ’ğ‘ğ‘¡].

Modeling each set ğ¿ğ‘¡ as a 2-dimensional table (or array), note that each value of ğ¿ğ‘¡ can be computed in ğ‘‚(ğ‘˜âˆ’(ğ‘ âˆ’ğ‘ğ‘¡))=ğ‘‚(ğ‘¤1) time, and hence all values of ğ¿ğ‘¡ can be computed in ğ‘‚(ğ‘¤1)â‹…ğ‘‚(ğ‘›2ğ‘(ğ‘+ğ‘))=ğ‘‚(ğ‘›3ğ‘2(ğ‘+ğ‘)) time. Finally, once all the values of ğ¿ğ‘› have been computed in ğ‘‚(ğ‘›)â‹…ğ‘‚(ğ‘›3ğ‘2(ğ‘+ğ‘))=ğ‘‚(ğ‘›4ğ‘2(ğ‘+ğ‘)) time, we can compute Pr[ğ–²(î‰„)â‰¥ğ‘§] as


Pr[ğ–²(î‰„)â‰¥ğ‘§] = âˆ‘ğ‘˜=ğ‘§ğ‘¤1Pr[ğ–²(î‰„)=ğ‘˜] = âˆ‘ğ‘˜=ğ‘§ğ‘¤1âˆ‘ğ‘ =âˆ’ğ‘¤0ğ‘˜Pr[ğ‘€ğ‘›=ğ‘˜,ğ‘†ğ‘›=ğ‘ ]

in ğ‘‚(ğ‘¤1(ğ‘¤0+ğ‘¤1))=ğ‘‚(ğ‘›2ğ‘(ğ‘+ğ‘)) time, and ğ”¼[ğ–²(î‰„)] as


ğ”¼[ğ–²(î‰„)] = âˆ‘ğ‘§=1ğ‘¤1Pr[ğ–²(î‰„)â‰¥ğ‘§]

in ğ‘‚(ğ‘¤1)=ğ‘‚(ğ‘›ğ‘) time. As a consequence, we get the following result.

Theorem 3
Let î‰„=ğ‘‹1,ğ‘‹2,â€¦,ğ‘‹ğ‘› be a sequence of n zero-value random variables, with values ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›âˆˆ[âˆ’ğ‘..ğ‘]âŠ‚â„¤ and probabilities ğœŒ1,ğœŒ2,â€¦,ğœŒğ‘›, respectively, for some ğ‘,ğ‘âˆˆâ„•. Then, both Pr[ğ–²(î‰„)â‰¥ğ‘§] and ğ”¼[ğ–²(î‰„)] can be computed in time polynomial in n, a, and b.

Red and Blue Points
Hardness
Given a graph ğº=(ğ‘‰,ğ¸), a subset ğ‘‰â€²âŠ†ğ‘‰ is an independent set of G if no pair of vertices of ğ‘‰â€² define an edge in E. Let N(G) denote the number of independent sets of G. The problem #IndSet of counting the number of independent sets in a graph is #P-complete, even if the graph is planar, bipartite, and with maximum degree 4 [18]. We show in what follows a one-to-many Turing reduction from #IndSet to the problem of computing Pr[ğ–»ğ—ˆğ—‘(ğ‘†)â‰¥ğ‘˜], for any given ğ‘˜â‰¥2. The proof uses techniques similar to that of Kamousi et al. [11] to prove that counting vertex covers in weighted unit-disk graphs is #P-hard, and that of Vadhan [18] to prove that counting weighted matchings in planar bipartite graphs is #P-hard.

Let ğº=(ğ‘‰,ğ¸) be the input of #IndSet, where G is a planar, bipartite graph with maximum degree 4. Let ğ‘›=|ğ‘‰| and ğ‘š=|ğ¸|=ğ‘‚(ğ‘›). For an overview of the whole proof, refer to Fig. 1.

Fig. 1
figure 1
Given an instance ğº=(ğ‘‰,ğ¸) of #IndSet, for every s in the set {â„,â„+1,â€¦,â„+ğ‘š} of ğ‘š+1 integers polynomially bounded in n, we construct the random colored point set ğ‘…ğ‘ âˆªğµğ‘ . Let ğºğ‘  be the graph obtained from G by subdividing each edge with exactly s new vertices. Assuming that an oracle computes Pr[ğ–»ğ—ˆğ—‘(ğ‘†)â‰¥2], where ğ‘†âŠ†ğ‘…ğ‘ âˆªğµğ‘  is the random sample, we show that ğ‘(ğºğ‘ ) can be computed in constant time from this probability. From all of the values ğ‘(ğºâ„),ğ‘(ğºâ„+1),â€¦,ğ‘(ğºâ„+ğ‘š) already computed, we show that N(G) can be computed in polynomial time

Full size image

For any subset ğ‘‰â€²âŠ†ğ‘‰ and any edge ğ‘’={ğ‘¢,ğ‘£}âˆˆğ¸, we say that ğ‘‰â€² 1-covers edge e if exactly one of u and v belongs to ğ‘‰â€². We also say that ğ‘‰â€² 2-covers e if both u and v belong to ğ‘‰â€². Let ğ¶ğ‘–,ğ‘— denote the number of subsets of V that 1-cover exactly i edges and 2-cover exactly j edges. Then,

For ğ‘ â‰¥1, let ğºğ‘ =(ğ‘‰ğ‘ ,ğ¸ğ‘ ) be the graph obtained from G by adding exactly s intermediate vertices on each edge of E. Let {ğ‘“ğ‘–}âˆğ‘–=1 be the Fibonacci sequence, with ğ‘“1=ğ‘“2=1 and ğ‘“ğ‘–=ğ‘“ğ‘–âˆ’1+ğ‘“ğ‘–âˆ’2 for ğ‘–â‰¥3. Let ğ›¼ğ‘–=ğ‘“ğ‘–+1/ğ‘“ğ‘–+2 for ğ‘–â‰¥0. The next lemma relates the number ğ‘(ğºğ‘ ) of independent sets of ğºğ‘  to the values ğ¶ğ‘–,ğ‘— in G.

Lemma 4
We have


ğ‘(ğºğ‘ ) = (ğ‘“ğ‘ +2)ğ‘šâ‹…âˆ‘0â‰¤ğ‘–+ğ‘—â‰¤ğ‘šğ¶ğ‘–,ğ‘—â‹…(ğ›¼ğ‘ )ğ‘–â‹…(1âˆ’ğ›¼ğ‘ )ğ‘—.

Proof
Any independent set ğ‘‰â€²ğ‘ âŠ†ğ‘‰ğ‘  of ğºğ‘  induces the subset ğ‘‰â€²ğ‘ âˆ©ğ‘‰ of V, which is not necessarily an independent set of G because it may 2-cover some edges. Let ğ‘‰â€²âŠ†ğ‘‰ be any subset of V that 1-covers i edges and 2-covers j edges. For any edge ğ‘’âˆˆğ¸, let ğ‘ğ‘’ denote the path induced by the s vertices added to e when constructing ğºğ‘  from G. An independent set of ğºğ‘  inducing ğ‘‰â€² can be obtained by starting with ğ‘‰â€² and adding vertices in the following way. For every edge ğ‘’={ğ‘¢,ğ‘£}âˆˆğ¸:

(1)
if ğ‘‰â€² neither 1-covers nor 2-covers e, then add any independent set of ğ‘ğ‘’.

(2)
if ğ‘‰â€² 1-covers e, say ğ‘¢âˆˆğ‘‰â€², then add any independent set of ğ‘ğ‘’ not containing the extreme vertex of ğ‘ğ‘’ adjacent to u in ğºğ‘ .

(3)
if ğ‘‰â€² 2-covers e, then add any independent set of ğ‘ğ‘’ with no extreme vertex.

It is well known that the number of independent sets of a path of length â„“ is exactly ğ‘“â„“+3 [18]. Since ğ‘ğ‘’ has length ğ‘ âˆ’1 for every e, the number of choices for cases (1), (2), and (3) are ğ‘“ğ‘ +2, ğ‘“ğ‘ +1, and ğ‘“ğ‘ , respectively. Therefore, the number of independent sets of ğºğ‘  inducing a subset of V that 1-covers i edges and 2-covers j edges is precisely ğ¶ğ‘–,ğ‘—â‹…(ğ‘“ğ‘ +1)ğ‘–â‹…(ğ‘“ğ‘ )ğ‘—â‹…(ğ‘“ğ‘ +2)ğ‘šâˆ’ğ‘–âˆ’ğ‘—. Hence, the number ğ‘(ğºğ‘ ) of independent sets of ğºğ‘  satisfies


ğ‘(ğºğ‘ ) = âˆ‘0â‰¤ğ‘–+ğ‘—â‰¤ğ‘šğ¶ğ‘–,ğ‘—â‹…(ğ‘“ğ‘ +1)ğ‘–â‹…(ğ‘“ğ‘ )ğ‘—â‹…(ğ‘“ğ‘ +2)ğ‘šâˆ’ğ‘–âˆ’ğ‘— = (ğ‘“ğ‘ +2)ğ‘šâ‹…âˆ‘0â‰¤ğ‘–+ğ‘—â‰¤ğ‘šğ¶ğ‘–,ğ‘—â‹…(ğ‘“ğ‘ +1ğ‘“ğ‘ +2)ğ‘–â‹…(ğ‘“ğ‘ ğ‘“ğ‘ +2)ğ‘— = (ğ‘“ğ‘ +2)ğ‘šâ‹…âˆ‘0â‰¤ğ‘–+ğ‘—â‰¤ğ‘šğ¶ğ‘–,ğ‘—â‹…(ğ‘“ğ‘ +1ğ‘“ğ‘ +2)ğ‘–â‹…(1âˆ’ğ‘“ğ‘ +1ğ‘“ğ‘ +2)ğ‘— = (ğ‘“ğ‘ +2)ğ‘šâ‹…âˆ‘0â‰¤ğ‘–+ğ‘—â‰¤ğ‘šğ¶ğ‘–,ğ‘—â‹…(ğ›¼ğ‘ )ğ‘–â‹…(1âˆ’ğ›¼ğ‘ )ğ‘—,

which completes the proof. â—»

Lemma 5
Let T be a set of ğ‘š+1 integers, each bounded by a polynomial in n. If we know the value of ğ‘(ğºğ‘ ) for every ğ‘ âˆˆğ‘‡, then the number N(G) can be computed in time polynomial in n.

Proof
For every ğ‘ âˆˆğ‘‡, the value of (ğ‘“ğ‘ +2)ğ‘š can be computed in ğ‘‚(logğ‘ +logğ‘š)=ğ‘‚(logğ‘›) time, and the value of ğ›¼ğ‘  also in ğ‘‚(logğ‘ )=ğ‘‚(logğ‘›) time. Let ğ‘ğ‘ =ğ‘(ğºğ‘ )/(ğ‘“ğ‘ +2)ğ‘š for every ğ‘ âˆˆğ‘‡. Consider the polynomial


ğ‘ƒ(ğ‘¥) = âˆ‘0â‰¤ğ‘–+ğ‘—â‰¤ğ‘šğ¶ğ‘–,ğ‘—â‹…ğ‘¥ğ‘–â‹…(1âˆ’ğ‘¥)ğ‘— = ğ‘0+ğ‘1ğ‘¥+ğ‘2ğ‘¥2+â‹¯+ğ‘ğ‘šğ‘¥ğ‘š,

of degree m, whose coefficients ğ‘0,ğ‘1,â€¦,ğ‘ğ‘š are linear combinations of the terms ğ¶ğ‘–,ğ‘—. By Lemma 4, and using the known values of ğ‘ğ‘  and ğ›¼ğ‘  for every ğ‘ âˆˆğ‘‡, we have ğ‘š+1 evaluations of P(x) of the form ğ‘ğ‘ =ğ‘ƒ(ğ›¼ğ‘ ), each corresponding to the linear equation ğ‘ğ‘ =ğ‘0+ğ‘1â‹…ğ›¼ğ‘ +ğ‘2â‹…ğ›¼2ğ‘ +â‹¯+ğ‘ğ‘šâ‹…ğ›¼ğ‘šğ‘  with variables the coefficients ğ‘0,ğ‘1,â€¦,ğ‘ğ‘š. The main matrix of this system of ğ‘š+1 linear equations is Vandermonde, with parameters ğ›¼ğ‘  for every ğ‘ âˆˆğ‘‡. All ğ›¼ğ‘  are distinct (refer to [18] or Appendix A for completeness), so the determinant of the main matrix is non-zero, and the system has a unique solution ğ‘0,ğ‘1,â€¦,ğ‘ğ‘š, which can be computed in time polynomial in n. Finally, observe that for ğ‘—=0, the coefficient of the polynomial ğ‘ƒ(ğ‘¥)=ğ¶ğ‘–,ğ‘—â‹…ğ‘¥ğ‘–â‹…(1âˆ’ğ‘¥)ğ‘—=ğ¶ğ‘–,0â‹…ğ‘¥ğ‘– is ğ¶ğ‘–,0. Furthermore, for ğ‘—>0, all the coefficients of the polynomial


ğ‘ƒ(ğ‘¥) == ğ¶ğ‘–,ğ‘—â‹…ğ‘¥ğ‘–â‹…(1âˆ’ğ‘¥)ğ‘—  ğ¶ğ‘–,ğ‘—â‹…ğ‘¥ğ‘–â‹…((ğ‘—0)âˆ’(ğ‘—1)ğ‘¥1+(ğ‘—2)ğ‘¥2âˆ’â‹¯+(âˆ’1)ğ‘—(ğ‘—ğ‘—)ğ‘¥ğ‘—)

sum up to zero. Indeed, it suffices to note that ğ‘ƒ(1)=0. Hence, we obtain


ğ‘0+ğ‘1+ğ‘2+â‹¯+ğ‘ğ‘š = âˆ‘ğ‘–=0ğ‘šğ¶ğ‘–,0 = ğ‘(ğº).

which shows that N(G) can be computed in time polynomial in n. â—»

In polynomial time, the graph ğº=(ğ‘‰,ğ¸) can be embedded in the plane using ğ‘‚(ğ‘›2) area in such a way that its vertices are at integer coordinates, and its edges are drawn so that they are polylines made up of line segments of the form ğ‘¥=ğ‘– or ğ‘¦=ğ‘—, for integers i and j [19] (see Fig. 2a). Let â„=ğ‘‚(ğ‘›) be the maximum number of bends of the polylines corresponding to the edges.

Fig. 2
figure 2
a An embedding of G. b The embedding of ğºğ‘  for ğ‘ =2: two intermediate vertices are added to each edge of G so that all polyline bends are covered

Full size image

For ğ‘ =â„,â„+1,â€¦,â„+ğ‘š, we embed the graph ğºğ‘  in the following way. We embed the graph G as above; scale the embedding by factor 2(ğ‘ +1); and for each edge of G, add s intermediate vertices to the polyline of the edge so that they have even integer coordinates and cover all bends of the polyline (see Fig. 2b). Then, each edge of ğºğ‘  is represented in the embedding by a vertical or horizontal segment. Let the point set ğ‘…0=ğ‘…0(ğ‘ )âŠ‚â„¤2 denote the vertex set of the embedding, and color these points in red. By translation if necessary, we can assume ğ‘…0âŠ‚[0..ğ‘]2 for some ğ‘=ğ‘‚(ğ‘›2). Let ğµ0=ğµ0(ğ‘ ) be the following set of blue points: For each horizontal or vertical line â„“ through a point of ğ‘…0, and each two consecutive points ğ‘,ğ‘âˆˆğ‘…0 in â„“ such that the vertices p and q are not adjacent in ğºğ‘ , we add a blue point in the segment pq connecting p and q, in order to â€œblockâ€ this segment, so that the blue point has one odd coordinate. In this way, blue points blocking horizontal segments have odd x-coordinates and even y-coordinates; and blue points blocking vertical segments have even x-coordinates and odd y-coordinates. Hence, a blue point cannot block at the same time a horizontal and a vertical segment defined by two red points. Note that |ğµ0|=ğ‘‚(|ğ‘…0|)=ğ‘‚(ğ‘›+ğ‘šâ‹…ğ‘ )=ğ‘‚(ğ‘›2). Now, a horizontal or vertical segment connecting two points p and q of ğ‘…0âˆªğµ0 represents an edge of ğºğ‘  if and only if ğ‘,ğ‘âˆˆğ‘…0 and the segment does not contain any other point of ğ‘…0âˆªğµ0 in its interior (see Fig. 4).

We perturb ğ‘…0âˆªğµ0âŠ‚[0..ğ‘]2 to obtain a point set with rational coordinates by applying the function ğœ†:[0..ğ‘]2â†’â„š2, where


ğœ†(ğ‘)=(ğ‘¥(ğ‘)+ğ‘¥(ğ‘)+ğ‘¦(ğ‘)4ğ‘+1,ğ‘¦(ğ‘)+ğ‘¥(ğ‘)+ğ‘¦(ğ‘)4ğ‘+1),

to every ğ‘âˆˆğ‘…0âˆªğµ0, where x(p) and y(p) denote the x- and y-coordinates of p, respectively. Similar perturbations can be found in [1, 4], and refer to Fig. 3. Since ğœ† is injective [4], let ğœ†âˆ’1 denote the inverse of ğœ†. For ğ´âŠ‚[0..ğ‘]2, let ğœ†(ğ´)={ğœ†(ğ‘)âˆ£ğ‘âˆˆğ´}, and for ğ´â€²âŠ‚ğœ†([0..ğ‘]2) let ğœ†âˆ’1(ğ´â€²)={ğœ†âˆ’1(ğ‘)âˆ£ğ‘âˆˆğ´â€²}. Let ğ›¿=1/(4ğ‘+2), and define the sets


ğ‘…ğ‘  = ğœ†(ğ‘…0)  and  ğµğ‘  = ğœ†(ğµ0)âˆª{ğ‘+(1/2,1/2),ğ‘+(ğ›¿,âˆ’ğ›¿)âˆ£ğ‘âˆˆğ‘…ğ‘ }.

To simplify the notation, let ğ‘…=ğ‘…ğ‘  and ğµ=ğµğ‘ . Note that |ğ‘…|=ğ‘‚(ğ‘›2) and |ğµ|=ğ‘‚(ğ‘›2). For two points a and b, let D(a, b) be the box with the segment ab as a diagonal. The proof of the next technical lemma is deferred to Appendix B.

Fig. 3
figure 3
The way in which points are perturbed using function ğœ†

Full size image

Fig. 4
figure 4
The point set ğ‘…0âˆªğµ0 for the embedding ğºğ‘ , ğ‘ =2, depicted in Fig. 2b. The grid lines are equally spaced in two units, then their intersection points have even coordinates. After the perturbation with the function ğœ† (see Fig. 3), the extra blue points {ğ‘+(1/2,1/2),ğ‘+(ğ›¿,âˆ’ğ›¿)âˆ£ğ‘âˆˆğ‘…ğ‘ } are included in ğµğ‘  to avoid that the box ğ·(ğœ†(ğ‘),ğœ†(ğ‘)) contains no blue point, for any two points ğ‘,ğ‘âˆˆğ‘…0 which do not belong to the same edge of the embedding. See for example the points p and q, denoted in the figure (Color figure online)

Full size image

Lemma 6
For any different ğ‘,ğ‘âˆˆğ‘…, the vertices ğœ†âˆ’1(ğ‘) and ğœ†âˆ’1(ğ‘) are adjacent in ğºğ‘  if and only if the box D(p, q) contains no point of B.

Theorem 7
Given ğ‘…âˆªğµ, it is #P-hard to compute Pr[ğ–»ğ—ˆğ—‘(ğ‘†)â‰¥ğ‘˜] for every integer ğ‘˜â‰¥2, and it is also #P-hard to compute ğ”¼[ğ–»ğ—ˆğ—‘(ğ‘†)].

Proof
Let ğ‘˜=2. Assume that there exists an algorithm (i.e., oracle) îˆ­ that computes Pr[ğ–»ğ—ˆğ—‘(ğ‘†)â‰¥2]. Consider the planar bipartite graph ğº=(ğ‘‰,ğ¸), with maximum degree 4, the input of #IndSet. Let ğ‘‡={â„,â„+1,â€¦,â„+ğ‘š}. For each ğ‘ âˆˆğ‘‡ we create the graph ğºğ‘ , embed ğºğ‘  in the plane, and build the colored point set ğ‘…âˆªğµ=ğ‘…ğ‘ âˆªğµğ‘  from this embedding. For each red point ğ‘âˆˆğ‘… we set its probability ğœ‹(ğ‘) to 1/2, and for each blue point ğ‘âˆˆğµ we set ğœ‹(ğ‘)=1. Note from Lemma 6 that there does not exist any box containing more than two red points of R and no blue point from B. Then, we have Pr[ğ–»ğ—ˆğ—‘(ğ‘†)â‰¥2]=Pr[ğ–»ğ—ˆğ—‘(ğ‘†)=2], where ğ‘†âŠ†ğ‘…âˆªğµ is the random subset of ğ‘…âˆªğµ. Furthermore,


Pr[ğ–»ğ—ˆğ—‘(ğ‘†)=2]===ğ‘(ğºğ‘ )=Pr[ğœ†âˆ’1(ğ‘†âˆ©ğ‘…) is not an independent set in ğºğ‘ ]1âˆ’Pr[ğœ†âˆ’1(ğ‘†âˆ©ğ‘…) is an independent set in ğºğ‘ ]1âˆ’ğ‘(ğºğ‘ )2|ğ‘…|2|ğ‘…|â‹…(1âˆ’Pr[ğ–»ğ—ˆğ—‘(ğ‘†)â‰¥2]).

Then, for each ğ‘ âˆˆğ‘‡ we can compute ğ‘(ğºğ‘ ) by calling îˆ­ once. By Lemma 5, we can compute N(G) from the ğ‘š+1 computed values of ğ‘(ğºğ‘ ) for each ğ‘ âˆˆğ‘‡. Hence, it is #P-hard to compute Pr[ğ–»ğ—ˆğ—‘(ğ‘†)â‰¥2] via a Turing reduction from #IndSet. To show that computing ğ”¼[ğ–»ğ—ˆğ—‘(ğ‘†)] is also #P-hard, for each ğ‘ âˆˆğ‘‡ consider the above point set ğ‘…âˆªğµ and note that


ğ”¼[ğ–»ğ—ˆğ—‘(ğ‘†)]==ğ‘(ğºğ‘ )=1â‹…Pr[ğœ†âˆ’1(ğ‘†âˆ©ğ‘…) is an independent set in ğºğ‘ ,ğ‘†âˆ©ğ‘…â‰ âˆ…]+2â‹…Pr[ğœ†âˆ’1(ğ‘†âˆ©ğ‘…) is not an independent set in ğºğ‘ ]ğ‘(ğºğ‘ )âˆ’12|ğ‘…|+2â‹…(1âˆ’ğ‘(ğºğ‘ )2|ğ‘…|) = 2âˆ’ğ‘(ğºğ‘ )+12|ğ‘…|2|ğ‘…|â‹…(2âˆ’ğ”¼[ğ–»ğ—ˆğ—‘(ğ‘†)])âˆ’1.

Let now ğ‘˜â‰¥3. For each ğ‘ âˆˆğ‘‡, the graph ğºğ‘  can be colored with two colors, 0 and 1, because it is also a bipartite graph. Each red point in R corresponds to a vertex in ğºğ‘ . Then, for each red point ğ‘âˆˆğ‘… with color 0 we add new âŒŠğ‘˜2âŒ‹âˆ’1 red points close enough to p (say, at distance much smaller than ğ›¿), and for each red point ğ‘âˆˆğ‘… with color 1 we add new âŒˆğ‘˜2âŒ‰âˆ’1 red points close enough to q. Let ğ‘…â€²=ğ‘…â€²(ğ‘ ) be the set of all new red points, and assign ğœ‹(ğ‘¢)=1 for every ğ‘¢âˆˆğ‘…â€². In this new colored point set ğ‘…âˆªğ‘…â€²âˆªğµ, there is no box containing more than k red points and no blue point. Furthermore, every box containing exactly k red points and no blue point contains two points ğ‘,ğ‘âˆˆğ‘… such that ğœ†âˆ’1(ğ‘) and ğœ†âˆ’1(ğ‘) are adjacent in ğºğ‘ ; and for every ğ‘,ğ‘âˆˆğ‘… such that ğœ†âˆ’1(ğ‘) and ğœ†âˆ’1(ğ‘) are adjacent in ğºğ‘  such a box containing p and q exists. Then, when taking ğ‘†âŠ†ğ‘…âˆªğ‘…â€²âˆªğµ at random, we also have


Pr[ğ–»ğ—ˆğ—‘(ğ‘†)â‰¥ğ‘˜]===Pr[ğ–»ğ—ˆğ—‘(ğ‘†)=ğ‘˜]Pr[ğœ†âˆ’1(ğ‘†âˆ©ğ‘…) is not an independent set in ğºğ‘ ]1âˆ’ğ‘(ğºğ‘ )2|ğ‘…|.

Hence, computing Pr[ğ–»ğ—ˆğ—‘(ğ‘†)â‰¥ğ‘˜] is also #P-hard for any ğ‘˜â‰¥3. â—»

Two-Point Boxes
From the proof of Theorem 7, note that it is also #P-hard to compute the probability that in ğ‘†âŠ†ğ‘…âˆªğµ there exists a box that contains exactly two red points p, q and no blue point; and that this box can be restricted to be the minimum box D(p, q) having p and q as opposed vertices. In this section, we present a polynomial-time algorithm to compute such a probability when the box is further restricted to contain a given point ğ‘œâˆ‰ğ‘…âˆªğµ of the plane in the interior. We assume general position, that is, there are no two points of ğ‘…âˆªğµâˆª{ğ‘œ} with the same x- or y-coordinate. We further assume w.l.o.g. that o is the origin of coordinates.

Given a fixed ğ‘‹âŠ†ğ‘…âˆªğµ, and ğ‘†âŠ†ğ‘…âˆªğµ chosen at random, let ğ¸(ğ‘‹)=ğ¸(ğ‘‹,ğ‘†) be the event that there exist two red points ğ‘,ğ‘âˆˆğ‘†âˆ©ğ‘‹ such that the box D(p, q) contains the origin o, no other red point in ğ‘†âˆ©ğ‘‹, and no blue in ğ‘†âˆ©ğ‘‹. Then, our goal is Pr[ğ¸(ğ‘…âˆªğµ)].

Theorem 8
Given ğ‘…âˆªğµ, Pr[ğ¸(ğ‘…âˆªğµ)] can be computed in polynomial time.

Proof
Let ğ‘‹âŠ†ğ‘…âˆªğµ, and define ğ‘‹+={ğ‘âˆˆğ‘‹âˆ£ğ‘¦(ğ‘)>0} and ğ‘‹âˆ’={ğ‘âˆˆğ‘‹âˆ£ğ‘¦(ğ‘)<0}. Given points ğ‘âˆˆğ‘‹+ and ğ‘Ÿâˆˆğ‘‹âˆ’, define the events


ğ‘ˆğ‘(ğ‘‹,ğ‘†)=[ğ‘=argminğ‘âˆˆğ‘‹+âˆ©ğ‘†{ğ‘¦(ğ‘)}]  and  ğ‘Šğ‘Ÿ(ğ‘‹,ğ‘†)=[ğ‘Ÿ=argmaxğ‘âˆˆğ‘‹âˆ’âˆ©ğ‘†{ğ‘¦(ğ‘)}].

Let ğ‘ˆğ‘(ğ‘‹)=ğ‘ˆğ‘(ğ‘‹,ğ‘†) and ğ‘Šğ‘Ÿ(ğ‘‹)=ğ‘Šğ‘Ÿ(ğ‘‹,ğ‘†). Using the formula of the total probability, we have:


Pr[ğ¸(ğ‘‹)]==âˆ‘ğ‘âˆˆğ‘‹+Pr[ğ¸(ğ‘‹)âˆ£ğ‘ˆğ‘(ğ‘‹)]â‹…Pr[ğ‘ˆğ‘(ğ‘‹)]âˆ‘ğ‘âˆˆğ‘‹+Pr[ğ¸(ğ‘‹)âˆ£ğ‘ˆğ‘(ğ‘‹)]â‹…(ğœ‹(ğ‘)â‹…âˆğ‘âˆˆğ‘‹+:ğ‘¦(ğ‘)<ğ‘¦(ğ‘)(1âˆ’ğœ‹(ğ‘))).

To compute Pr[ğ¸(ğ‘‹)âˆ£ğ‘ˆğ‘(ğ‘‹)], we assume ğ‘¥(ğ‘)>0. The case where ğ‘¥(ğ‘)<0 is symmetric. If ğ‘âˆˆğµ, then observe that when restricted to the event ğ‘ˆğ‘(ğ‘‹) any box ğ·(ğ‘â€²,ğ‘â€²) defined by two red points ğ‘â€²,ğ‘â€²âˆˆğ‘†âˆ©ğ‘‹, containing the origin o and no other red point in ğ‘†âˆ©ğ‘‹, where one between ğ‘â€² and ğ‘â€² is to the right of q, will contain q. Hence, we must â€œdiscardâ€ all points to the right of q, all points between the horizontal lines through q and o because they are not present, and q itself. Then, we have that:


Pr[ğ¸(ğ‘‹)âˆ£ğ‘ˆğ‘(ğ‘‹)] = Pr[ğ¸(ğ‘‹ğ‘)],

where ğ‘‹ğ‘âŠ‚ğ‘‹ contains the points ğ‘âˆˆğ‘‹ such that ğ‘¥(ğ‘)<ğ‘¥(ğ‘) and either ğ‘¦(ğ‘)>ğ‘¦(ğ‘) or ğ‘¦(ğ‘)<0. If ğ‘âˆˆğ‘…, we expand Pr[ğ¸(ğ‘‹)âˆ£ğ‘ˆğ‘(ğ‘‹)] as follows:


Pr[ğ¸(ğ‘‹)âˆ£ğ‘ˆğ‘(ğ‘‹)] = âˆ‘ğ‘Ÿâˆˆğ‘‹âˆ’Pr[ğ¸(ğ‘‹)âˆ£ğ‘ˆğ‘(ğ‘‹),ğ‘Šğ‘Ÿ(ğ‘‹)]â‹…Pr[ğ‘Šğ‘Ÿ(ğ‘‹)]= âˆ‘ğ‘Ÿâˆˆğ‘‹âˆ’Pr[ğ¸(ğ‘‹)âˆ£ğ‘ˆğ‘(ğ‘‹),ğ‘Šğ‘Ÿ(ğ‘‹)]â‹…(ğœ‹(ğ‘Ÿ)â‹…âˆğ‘âˆˆğ‘‹âˆ’:ğ‘¦(ğ‘)>ğ‘¦(ğ‘Ÿ)(1âˆ’ğœ‹(ğ‘))).

There are now three cases according to the relative positions of q and r.

Case 1: ğ‘¥(ğ‘Ÿ)<0<ğ‘¥(ğ‘). Let ğ‘Œğ‘,ğ‘ŸâŠ‚ğ‘‹ contain the points ğ‘âˆˆğ‘‹ (including q) such that ğ‘¥(ğ‘Ÿ)<ğ‘¥(ğ‘)â‰¤ğ‘¥(ğ‘) and either ğ‘¦(ğ‘)<ğ‘¦(ğ‘Ÿ) or ğ‘¦(ğ‘)â‰¥ğ‘¦(ğ‘). If ğ‘Ÿâˆˆğ‘…, then Pr[ğ¸(ğ‘‹)âˆ£ğ‘ˆğ‘(ğ‘‹),ğ‘Šğ‘Ÿ(ğ‘‹)]=1. Otherwise, if ğ‘Ÿâˆˆğµ, given that ğ‘ˆğ‘(ğ‘‹) and ğ‘Šğ‘Ÿ(ğ‘‹) hold, any box ğ·(ğ‘â€²,ğ‘â€²) defined by two red points ğ‘â€²,ğ‘â€² of ğ‘†âˆ©ğ‘‹, containing the origin o and no other red point in ğ‘†âˆ©ğ‘‹, where one between ğ‘â€² and ğ‘â€² is not in ğ‘Œğ‘,ğ‘Ÿ, will contain q or r in the interior. Then


Pr[ğ¸(ğ‘‹)âˆ£ğ‘ˆğ‘(ğ‘‹),ğ‘Šğ‘Ÿ(ğ‘‹)] = Pr[ğ¸(ğ‘Œğ‘,ğ‘Ÿ)âˆ£ğ‘ˆğ‘(ğ‘Œğ‘,ğ‘Ÿ)].

Similar arguments are given in the next two cases.

Case 2: 0<ğ‘¥(ğ‘)<ğ‘¥(ğ‘Ÿ). We have


Pr[ğ¸(ğ‘‹)âˆ£ğ‘ˆğ‘(ğ‘‹),ğ‘Šğ‘Ÿ(ğ‘‹)] = Pr[ğ¸(ğ‘‹ğ‘âˆª{ğ‘})âˆ£ğ‘ˆğ‘(ğ‘‹ğ‘âˆª{ğ‘})].

Case 3: 0<ğ‘¥(ğ‘Ÿ)<ğ‘¥(ğ‘). If ğ‘Ÿâˆˆğ‘…, then


Pr[ğ¸(ğ‘‹)âˆ£ğ‘ˆğ‘(ğ‘‹),ğ‘Šğ‘Ÿ(ğ‘‹)] = Pr[ğ¸(ğ‘ğ‘,ğ‘Ÿâˆª{ğ‘Ÿ})âˆ£ğ‘Šğ‘Ÿ(ğ‘ğ‘,ğ‘Ÿâˆª{ğ‘Ÿ})],

where ğ‘ğ‘,ğ‘ŸâŠ‚ğ‘‹ contains the points ğ‘âˆˆğ‘‹ such that ğ‘¥(ğ‘)<ğ‘¥(ğ‘Ÿ) and either ğ‘¦(ğ‘)<ğ‘¦(ğ‘Ÿ) or ğ‘¦(ğ‘)>ğ‘¦(ğ‘). Note that the event [ğ¸(ğ‘ğ‘,ğ‘Ÿâˆª{ğ‘Ÿ})âˆ£ğ‘Šğ‘Ÿ(ğ‘ğ‘,ğ‘Ÿâˆª{ğ‘Ÿ})] is symmetric to the event [ğ¸(ğ‘‹)âˆ£ğ‘ˆğ‘(ğ‘‹)], thus its probability can be computed similarly. Otherwise, if ğ‘Ÿâˆˆğµ, we have


Pr[ğ¸(ğ‘‹)âˆ£ğ‘ˆğ‘(ğ‘‹),ğ‘Šğ‘Ÿ(ğ‘‹)] = Pr[ğ¸(ğ‘ğ‘,ğ‘Ÿ)].

Note that in the above recursive computation of Pr[ğ¸(ğ‘‹)], for ğ‘‹=ğ‘…âˆªğµ, there is a polynomial number of subsets ğ‘‹ğ‘, ğ‘Œğ‘,ğ‘Ÿ, and ğ‘ğ‘,ğ‘Ÿ; each of such subsets can be encoded in constant space (i.e., by using a constant number of coordinates). Then, we can use dynamic programming, with a polynomial-size table, to compute Pr[ğ¸(ğ‘…âˆ©ğµ)] in time polynomial in n. â—»

Discussion and Open Problems
For fixed ğ‘‘â‰¥1, the maximum box problem for non-probabilistic points can be solved in ğ‘‚(ğ‘›ğ‘‘) time [3]. This fact, combined with the Monte Carlo method and known techniques, can be used to approximate the expectation of the total weight of the maximum box on probabilistic points, in polynomial time and with high probability of success. That is, we provide a FPRAS, which is explained in Appendix C. Approximating the probability that the total weight of a maximum box is at least a given parameter is an open question of this paper. To this end, we give in Appendix D a FPRAS for approximating this probability, but only in the case where the points are colored red or blue, each with probability 1/2, and we look for the box covering the maximum number of red points and no blue point (i.e. red points have weight +1 and blue points weight âˆ’âˆ).

For ğ‘‘=2 and red and blue points, there are several open problems: For example, to compute Pr[ğ–»ğ—ˆğ—‘(ğ‘†)â‰¥ğ‘˜] (even for ğ‘˜=3) in ğ‘‘=2 when the box is restricted to contain a fixed point. Other open questions are the cases in which the box is restricted to contain a given point as vertex, or has some side contained in a given axis-parallel line. This two latter variants can be solved in ğ‘›ğ‘‚(ğ‘˜) time (see Appendix E), which means that they are polynomial-time solvable for fixed k. This contrasts with the original question that is #P-hard for every ğ‘˜â‰¥2.

For red and blue points in ğ‘‘=1, both Pr[ğ–»ğ—ˆğ—‘(ğ‘†)â‰¥ğ‘˜] and ğ”¼[ğ–»ğ—ˆğ—‘(ğ‘†)] can be computed in polynomial time by using standard dynamic programming techniques. This implies that for ğ‘‘=2 and a fixed direction, computing the probability that there exists a strip (i.e., the space between two parallel lines) perpendicular to that direction and covering at least k red points and no blue point can be done in polynomial time. If the orientation of the strip is not restricted, then such a computation is #P-hard for every ğ‘˜â‰¥3 (see Appendix F).