Abstract
We study the generalized minimum Manhattan network (GMMN) problem: given a set Pğ‘ƒ of pairs of points in the Euclidean plane {\mathbb{R}}^2â„2, we are required to find a minimum-length geometric network which consists of axis-aligned segments and contains a shortest path in the L_1ğ¿1 metric (a so-called Manhattan path) for each pair in Pğ‘ƒ. This problem commonly generalizes several NP-hard network design problems that admit constant-factor approximation algorithms, such as the rectilinear Steiner arborescence (RSA) problem, and it is open whether so does the GMMN problem. As a bottom-up exploration, Schnizler (2015) focused on the intersection graphs of the rectangles defined by the pairs in Pğ‘ƒ, and gave a polynomial-time dynamic programming algorithm for the GMMN problem whose input is restricted so that both the treewidth and the maximum degree of its intersection graph are bounded by constants. In this paper, as the first attempt to remove the degree bound, we provide a polynomial-time algorithm for the star case, and extend it to the general tree case based on an improved dynamic programming approach.

Introduction
In this paper, we study a geometric network design problem in the Euclidean plane {\mathbb{R}}^2â„2. For a pair of points s and t in the plane, a path between s and t is called a Manhattan path (or an M-path for short) if it consists of axis-aligned segments whose total length is equal to the Manhattan distance of s and t (in other words, it is a shortest sâ€“t path in the L_1ğ¿1 metric). The minimum Manhattan network (MMN) problem is to find a minimum-length geometric network that contains an M-path for every pair of points in a given terminal set. In the generalized minimum Manhattan network (GMMN) problem, given a set Pğ‘ƒ of pairs of terminals, we are required to find a minimum-length network that contains an M-path for every pair in Pğ‘ƒ. Throughout this paper, let n = |P|ğ‘›=|ğ‘ƒ| denote the number of terminal pairs.

The GMMN problem was introduced by Chepoi, Nouioua, and VaxÃ¨s [5], and is known to be NP-hard as so is the MMN problem [6]. The MMN problem and another NP-hard special case named the rectilinear Steiner arborescence (RSA) problem admit polynomial-time constant-factor approximation algorithms, and in [5] they posed a question whether so does the GMMN problem or not, which is still open.

Das, Fleszar, Kobourov, Spoerhase, Veeramoni, and Wolff [8] gave an O(\log ^{d+1} n)ğ‘‚(logğ‘‘+1ğ‘›)-approximation algorithm for the d-dimensional GMMN problem based on a divide-and-conquer approach. They also improved the approximation ratio for d = 2ğ‘‘=2 to O(\log n)ğ‘‚(logğ‘›). Funke and Seybold [9] (see also[19]) introduced the scale-diversity measure {\mathcal{D}}îˆ° for (2-dimensional) GMMN instances, and gave an O({\mathcal{D}})ğ‘‚(îˆ°)-approximation algorithm. Because {\mathcal{D}} = O(\log n)îˆ°=ğ‘‚(logğ‘›) is guaranteed, this also implies O(\log n)ğ‘‚(logğ‘›)-approximation as with Das et al. [8], which is the current best approximation ratio for the GMMN problem in general.

As another approach to the GMMN problem, Schnizler [18] explored tractable cases by focusing on the intersection graphs of GMMN instances. The intersection graph represents for which terminal pairs M-paths can intersect. He showed that, when both the treewidth and the maximum degree of intersection graphs are bounded by constants, the GMMN problem can be solved in polynomial time by dynamic programming (see Table 1). His algorithm heavily depends on the degree bound, and it is natural to ask whether we can remove it, e.g., whether the GMMN problem is difficult even if the intersection graph is restricted to a tree without any degree bound.

In this paper, we give an answer to this question. Specifically, as the first tractable case without any degree bound in the intersection graphs, we provide a polynomial-time algorithm for the star case by reducing it to the longest path problem in directed acyclic graphs.

Theorem 1.1
There exists an O(n^2)ğ‘‚(ğ‘›2)-time algorithm for the GMMN problem when the intersection graph is restricted to a star.

Then, we extend it to the general tree case based on a dynamic programming (DP) approach inspired by and improving Schnizlerâ€™s algorithm [18].

Theorem 1.2
There exists an O(n^5)ğ‘‚(ğ‘›5)-time algorithm for the GMMN problem when the intersection graph is restricted to a tree.

The above algorithm involves two types of DPs, which are nested. We furthermore improve its running time by reducing the computational cost of inner DPs, and obtain the following result.

Theorem 1.3
There exists an O(n^3)ğ‘‚(ğ‘›3)-time algorithm for the GMMN problem when the intersection graph is restricted to a tree.

Furthermore, we show that the cycle case can be solved by solving the tree case O(n) times. This fact is shown as Proposition 6.1 in a generalized form from cycles to triangle-free pseudotrees, where a triangle is a cycle consisting of three vertices and a pseudotree is a connected graph that contains at most one cycle.Footnote 1 Combining this with Theorem 1.3, we obtain the following result.

Corollary 1.1
There exists an O(n^4)ğ‘‚(ğ‘›4)-time algorithm for the GMMN problem when the intersection graph is restricted to a cycle (or a triangle-free pseudotree).

We also improve the time complexity for the general case as in Table 1. The dependency on the maximum degree is substantially improved, but it is still exponential. In addition, the approach is apart from the above main results and is also a straightforward improvement from Schnizlerâ€™s result for the tree case. For these reasons, we just sketch this result in the appendix.

Table 1 Exactly solvable cases classified by the class of intersection graphs, whose treewidth and maximum degree are denoted by {\rm{tw}}tw and \varDeltağ›¥, respectively
Full size table

Related Work
The MMN problem was first introduced by Gudmundsson, Levcopoulos, and Narashimhan [10]. They gave 4- and 8-approximation algorithms running in O(n^3)ğ‘‚(ğ‘›3) and O(n \log n)ğ‘‚(ğ‘›logğ‘›) time, respectively. The current best approximation ratio is 2, which was obtained independently by Chepoi et al. [5] using an LP-ronding technique, by Nouioua [15] using a primal-dual scheme, and by Guo, Sun, and Zhu [11] using a greedy method.

The RSA problem is another important special case of the GMMN problem. In this problem, given a set of terminals in {\mathbb{R}}^2â„2, we are required to find a minimum-length network that contains an M-path between the origin and every terminal. The RSA problem was first studied by Nastansky, Selkow, and Stewart [14] in 1974. The complexity of the RSA problem had been open for a long time, and Shi and Su [20] showed that the decision version is strongly NP-complete after three decades. Rao, Sadayappan, Hwang, and Shor [16] proposed a 2-approximation algorithm that runs in O(n \log n)ğ‘‚(ğ‘›logğ‘›) time. Lu and Ruan [12] and Zachariasen [21] independently obtained PTASes, which are both based on Aroraâ€™s technique [3] of building a PTAS for the metric Steiner tree problem.

Organization
The rest of this paper is organized as follows. In Sect. 2, we describe necessary definitions and notations. In Sect. 3, we present an algorithm for the star case and prove Theorem 1.1. In Sect. 4, based on a DP approach, we extend our algorithm to the tree case and prove Theorem 1.2. Then, in Sect. 5, we improve the algorithm shown in Sect. 4 by reducing the computational cost of solving subproblems in our DP and prove Theorem 1.3. Finally, in Sect. 6, we show that any cycle (or triangle-free pseudotree) instance can be reduced to O(n) tree instances, which implies Corollary 1.1. We also discuss an improvement on the general case and another observation in the appendix.

Preliminaries
Problem Formulation
For a point p \in {\mathbb{R}}^2ğ‘âˆˆâ„2, we denote by p_xğ‘ğ‘¥ and p_yğ‘ğ‘¦ its x- and y-coordinates, respectively, i.e., p = (p_x, p_y)ğ‘=(ğ‘ğ‘¥,ğ‘ğ‘¦). Let p, q \in {\mathbb{R}}^2ğ‘,ğ‘âˆˆâ„2 be two points. We write p \le qğ‘â‰¤ğ‘ if both p_x \le q_xğ‘ğ‘¥â‰¤ğ‘ğ‘¥ and p_y \le q_yğ‘ğ‘¦â‰¤ğ‘ğ‘¦ hold. We define two points

\begin{aligned} p \wedge q&= \left( \min \left\{ p_x, q_x\right\} ,\, \min \left\{ p_y, q_y\right\} \right) , \\ p \vee q&= \left( \max \left\{ p_x, q_x\right\} ,\, \max \left\{ p_y, q_y\right\} \right) . \end{aligned}

ğ‘âˆ§ğ‘ğ‘âˆ¨ğ‘=(min{ğ‘ğ‘¥,ğ‘ğ‘¥},min{ğ‘ğ‘¦,ğ‘ğ‘¦}),=(max{ğ‘ğ‘¥,ğ‘ğ‘¥},max{ğ‘ğ‘¦,ğ‘ğ‘¦}).

We denote by pq the segment whose endpoints are p and q, and by \Vert pq\Vertâ€–ğ‘ğ‘â€– its length, i.e., pq = \{ \alpha p + (1 - \alpha ) q \mid \alpha \in [0, 1] \}ğ‘ğ‘={ğ›¼ğ‘+(1âˆ’ğ›¼)ğ‘âˆ£ğ›¼âˆˆ[0,1]} and \Vert pq\Vert = \sqrt{(p_x - q_x)^2 + (p_y - q_y)^2}â€–ğ‘ğ‘â€–=(ğ‘ğ‘¥âˆ’ğ‘ğ‘¥)2+(ğ‘ğ‘¦âˆ’ğ‘ğ‘¦)2â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾â€¾âˆš. We also define d_x(p, q) = |p_x - q_x|ğ‘‘ğ‘¥(ğ‘,ğ‘)=|ğ‘ğ‘¥âˆ’ğ‘ğ‘¥| and d_y(p, q) = |p_y - q_y|ğ‘‘ğ‘¦(ğ‘,ğ‘)=|ğ‘ğ‘¦âˆ’ğ‘ğ‘¦|, and denote by d(p, q) the Manhattan distance between p and q, i.e., d(p, q) = d_x(p, q) + d_y(p, q)ğ‘‘(ğ‘,ğ‘)=ğ‘‘ğ‘¥(ğ‘,ğ‘)+ğ‘‘ğ‘¦(ğ‘,ğ‘). Note that \Vert pq\Vert = d(p, q)â€–ğ‘ğ‘â€–=ğ‘‘(ğ‘,ğ‘) if and only if p_x = q_xğ‘ğ‘¥=ğ‘ğ‘¥ or p_y = q_yğ‘ğ‘¦=ğ‘ğ‘¦, and then the segment pq is said to be vertical or horizontal, respectively, and axis-aligned in either case.

A (geometric) network N in {\mathbb{R}}^2â„2 is a finite simple graph with a vertex set V(N) \subseteq {\mathbb{R}}^2ğ‘‰(ğ‘)âŠ†â„2 and an edge set E(N) \subseteq \left( {\begin{array}{c}V(N)\\ 2\end{array}}\right) = \{ \{p, q\} \mid p, q \in V(N),~p \ne q \}ğ¸(ğ‘)âŠ†(ğ‘‰(ğ‘)2)={{ğ‘,ğ‘}âˆ£ğ‘,ğ‘âˆˆğ‘‰(ğ‘), ğ‘â‰ ğ‘}, where we often identify each edge \{p, q\}{ğ‘,ğ‘} with the corresponding segment pq. The length of N is defined as \Vert N\Vert = \sum _{\{p, q\} \in E(N)} \Vert pq\Vertâ€–ğ‘â€–=âˆ‘{ğ‘,ğ‘}âˆˆğ¸(ğ‘)â€–ğ‘ğ‘â€–. For two points s, t \in {\mathbb{R}}^2ğ‘ ,ğ‘¡âˆˆâ„2, a path \piğœ‹ between s and t (or an sâ€“t path) is a network of the following form:

\begin{aligned} V(\pi )&= \{s = p_0, p_1, p_2, \dots , p_k = t\}, \\ E(\pi )&= \bigl \{\{p_{i-1}, p_i\} \mid i \in [k] \bigr \}, \end{aligned}

ğ‘‰(ğœ‹)ğ¸(ğœ‹)={ğ‘ =ğ‘0,ğ‘1,ğ‘2,â€¦,ğ‘ğ‘˜=ğ‘¡},={{ğ‘ğ‘–âˆ’1,ğ‘ğ‘–}âˆ£ğ‘–âˆˆ[ğ‘˜]},

where [k] = \{1, 2, \dots , k\}[ğ‘˜]={1,2,â€¦,ğ‘˜} for a nonnegative integer k. An sâ€“t path \piğœ‹ is called a Manhattan path (or an M-path) for a pair (s, t) if every edge \{p_{i-1}, p_i\} \in E(\pi ){ğ‘ğ‘–âˆ’1,ğ‘ğ‘–}âˆˆğ¸(ğœ‹) is axis-aligned and \Vert \pi \Vert = d(s, t)â€–ğœ‹â€–=ğ‘‘(ğ‘ ,ğ‘¡) holds.

We are now ready to state our problem formally.

Problem
(Generalized Minimum Manhattan Network (GMMN))

Input:
A set Pğ‘ƒ of n pairs of points in {\mathbb{R}}^2â„2.

Goal:
Find a minimum-length network N in {\mathbb{R}}^2â„2 that consists of axis-aligned edges and contains a Manhattan path for every pair (s, t) \in P(ğ‘ ,ğ‘¡)âˆˆğ‘ƒ.

Throughout this paper, when we write a pair (p, q) \in {\mathbb{R}}^2 \times {\mathbb{R}}^2(ğ‘,ğ‘)âˆˆâ„2Ã—â„2, we assume p_x \le q_xğ‘ğ‘¥â‰¤ğ‘ğ‘¥ (by swapping if necessary). A pair (p, q) is said to be regular if p_y \le q_yğ‘ğ‘¦â‰¤ğ‘ğ‘¦, and flipped if p_y \ge q_yğ‘ğ‘¦â‰¥ğ‘ğ‘¦. In addition, if p_x = q_xğ‘ğ‘¥=ğ‘ğ‘¥ or p_y = q_yğ‘ğ‘¦=ğ‘ğ‘¦, then there exists a unique M-path for (p, q) and we call such a pair degenerate.

Restricting a Feasible Region to the Hanan Grid
For a GMMN instance Pğ‘ƒ, we denote by {\mathcal{H}}(P)îˆ´(ğ‘ƒ) the Hanan grid, which is a grid network in {\mathbb{R}}^2â„2 consisting of vertical and horizontal lines through each point appearing in Pğ‘ƒ. More formally, it is defined as follows (see Fig. 1):

\begin{aligned} V({\mathcal{H}}(P))&= \left( \bigcup _{(s, t) \in P}\{ s_x, t_x \}\right) \times \left( \bigcup _{(s, t) \in P}\{ s_y, t_y \}\right) \subseteq {\mathbb{R}}^2, \\ E({\mathcal{H}}(P))&= \left \{\{p, q\} \in \textstyle \left( {\begin{array}{c}V({\mathcal{H}}(P))\\ 2\end{array}}\right) \Biggm| \Vert pq\Vert = d(p,q),~pq \cap V({\mathcal{H}}(P)) = \{p, q\} \right \}. \end{aligned}

ğ‘‰(îˆ´(ğ‘ƒ))ğ¸(îˆ´(ğ‘ƒ))=(â‹ƒ(ğ‘ ,ğ‘¡)âˆˆğ‘ƒ{ğ‘ ğ‘¥,ğ‘¡ğ‘¥})Ã—(â‹ƒ(ğ‘ ,ğ‘¡)âˆˆğ‘ƒ{ğ‘ ğ‘¦,ğ‘¡ğ‘¦})âŠ†â„2,={{ğ‘,ğ‘}âˆˆ(ğ‘‰(îˆ´(ğ‘ƒ))2)âˆ£âˆ£âˆ£âˆ£â€–ğ‘ğ‘â€–=ğ‘‘(ğ‘,ğ‘), ğ‘ğ‘âˆ©ğ‘‰(îˆ´(ğ‘ƒ))={ğ‘,ğ‘}}.

Note that {\mathcal{H}}(P)îˆ´(ğ‘ƒ) is an at most 2n \times 2n2ğ‘›Ã—2ğ‘› grid network. It is not difficult to see that, for any GMMN instance Pğ‘ƒ, at least one optimal solution is contained in the Hanan grid {\mathcal{H}}(P)îˆ´(ğ‘ƒ) as its subgraph (cf. [9]).

Fig. 1
figure 1
An optimal solution (solid) to a GMMN instance \{(s_1, t_1),(s_2, t_2),(s_3, t_3)\}{(ğ‘ 1,ğ‘¡1),(ğ‘ 2,ğ‘¡2),(ğ‘ 3,ğ‘¡3)} lies on the Hanan grid (dashed), where (s_1, t_1)(ğ‘ 1,ğ‘¡1) and (s_2, t_2)(ğ‘ 2,ğ‘¡2) are regular pairs and (s_3, t_3)(ğ‘ 3,ğ‘¡3) is a flipped pair

Full size image

For each pair v = (p, q) \in V({\mathcal{H}}(P)) \times V({\mathcal{H}}(P))ğ‘£=(ğ‘,ğ‘)âˆˆğ‘‰(îˆ´(ğ‘ƒ))Ã—ğ‘‰(îˆ´(ğ‘ƒ)), we denote by \varPi _P(v)ğ›±ğ‘ƒ(ğ‘£) or \varPi _P(p, q)ğ›±ğ‘ƒ(ğ‘,ğ‘) the set of all M-paths for v that are subgraphs of the Hanan grid {{\mathcal{H}}}(P)îˆ´(ğ‘ƒ). By the problem definition, we associate each n-tuple of M-paths, consisting of an M-path \pi _v \in \varPi _P(v)ğœ‹ğ‘£âˆˆğ›±ğ‘ƒ(ğ‘£) for each v \in Pğ‘£âˆˆğ‘ƒ, with a feasible solution N = \bigcup _{v \in P} \pi _vğ‘=â‹ƒğ‘£âˆˆğ‘ƒğœ‹ğ‘£ on {{\mathcal{H}}}(P)îˆ´(ğ‘ƒ), where the union of networks is defined by the set unions of the vertex sets and of the edge sets. Moreover, each minimal feasible (as well as optimal) solution on {{\mathcal{H}}}(P)îˆ´(ğ‘ƒ) must be represented in this way. Based on this correspondence, we abuse the notation as N = (\pi _v)_{v \in P} \in \prod _{v \in P}\varPi _P(v)ğ‘=(ğœ‹ğ‘£)ğ‘£âˆˆğ‘ƒâˆˆâˆğ‘£âˆˆğ‘ƒğ›±ğ‘ƒ(ğ‘£), and define \rm{Feas}(P)Feas(P) and \rm{Opt}(P)Opt(P) as the sets of feasible solutions covering all minimal ones and of all optimal solutions, respectively, on {{\mathcal{H}}}(P)îˆ´(ğ‘ƒ), i.e.,

\begin{aligned} {\rm{Feas}}(P)&= \prod _{v \in P}\varPi _P(v), \\ {\rm{Opt}}(P)&= \mathop {\mathrm{arg\,min}}\limits \{ \Vert N\Vert \mid N \in {\rm{Feas}}(P) \}. \end{aligned}

Feas(ğ‘ƒ)Opt(ğ‘ƒ)=âˆğ‘£âˆˆğ‘ƒğ›±ğ‘ƒ(ğ‘£),=argmin{â€–ğ‘â€–âˆ£ğ‘âˆˆFeas(ğ‘ƒ)}.

Thus, we have restricted a feasible region of a GMMN instance Pğ‘ƒ to the Hanan grid {{\mathcal{H}}}(P)îˆ´(ğ‘ƒ). In other words, the GMMN problem reduces to finding a network N = (\pi _v)_{v \in P} \in {\rm{Opt}}(P)ğ‘=(ğœ‹ğ‘£)ğ‘£âˆˆğ‘ƒâˆˆOpt(ğ‘ƒ) as an n-tuple of M-paths in {\rm{Feas}}(P)Feas(ğ‘ƒ).

Specialization Based on Intersection Graphs
The bounding box of a pair v = (p, q) \in {\mathbb{R}}^2 \times {\mathbb{R}}^2ğ‘£=(ğ‘,ğ‘)âˆˆâ„2Ã—â„2 indicates the rectangle region

\begin{aligned} \{z \in {\mathbb{R}}^2 \mid p \wedge q \le z \le p \vee q \}, \end{aligned}

{ğ‘§âˆˆâ„2âˆ£ğ‘âˆ§ğ‘â‰¤ğ‘§â‰¤ğ‘âˆ¨ğ‘},

and we denote it by B(v) or B(p, q). Note that B(p, q) is the region where an M-path for (p, q) can exist. For a GMMN instance Pğ‘ƒ and a pair v \in Pğ‘£âˆˆğ‘ƒ, we denote by {\mathcal{H}}(P, v)îˆ´(ğ‘ƒ,ğ‘£) the subgraph of the Hanan grid {\mathcal{H}}(P)îˆ´(ğ‘ƒ) induced by V({\mathcal{H}}(P)) \cap B(v)ğ‘‰(îˆ´(ğ‘ƒ))âˆ©ğµ(ğ‘£). We define the intersection graph \rm{IG}[P]IG[P] of Pğ‘ƒ by

\begin{aligned} V(\rm{IG}[P])&= P, \\ E(\rm{IG}[P])&= \left \{\{u, v\}\in \textstyle \left( {\begin{array}{c}P\\ 2\end{array}}\right) \Biggm| E({\mathcal{H}}(P, u)) \cap E({\mathcal{H}}(P, v)) \ne \emptyset \right \}. \end{aligned}

ğ‘‰(IG[P])ğ¸(IG[P])=ğ‘ƒ,={{ğ‘¢,ğ‘£}âˆˆ(ğ‘ƒ2)âˆ£âˆ£âˆ£âˆ£ğ¸(îˆ´(ğ‘ƒ,ğ‘¢))âˆ©ğ¸(îˆ´(ğ‘ƒ,ğ‘£))â‰ âˆ…}.

The intersection graph {\rm{IG}}[P]IG[ğ‘ƒ] intuitively represents how a GMMN instance Pğ‘ƒ is complicated in the sense that, for each u, v \in Pğ‘¢,ğ‘£âˆˆğ‘ƒ, an edge \{u, v\} \in E(\rm{IG}[P]){ğ‘¢,ğ‘£}âˆˆğ¸(IG[P]) exists if and only if two M-paths \pi _u \in \varPi _P(u)ğœ‹ğ‘¢âˆˆğ›±ğ‘ƒ(ğ‘¢) and \pi _v \in \varPi _P(v)ğœ‹ğ‘£âˆˆğ›±ğ‘ƒ(ğ‘£) can share some segments, which saves the total length of a network in {\rm{Feas}}(P)Feas(ğ‘ƒ).Footnote 2 In particular, if {\rm{IG}}[P]IG[ğ‘ƒ] contains no triangle, then no segment can be shared by M-paths for three different pairs in Pğ‘ƒ, and hence N \in {\rm{Feas}}(P)ğ‘âˆˆFeas(ğ‘ƒ) is optimal (i.e., \Vert N\Vertâ€–ğ‘â€– is minimized) if and only if the total length of segments shared by two M-paths in N is maximized.

We denote by GMMN[\cdotsâ‹¯] the GMMN problem with restriction on the intersection graph of the input; e.g., {\rm{IG}}[P]IG[ğ‘ƒ] is restricted to a tree in GMMN[Tree]. Each restricted problem is formally stated in the relevant section.

An O(n^2)ğ‘‚(ğ‘›2)-Time Algorithm for GMMN[Star]
In this section, as a step to GMMN[Tree], we present an O(n^2)ğ‘‚(ğ‘›2)-time algorithm for GMMN[Star], which is formally stated as follows.

Problem
(GMMN[Star])

Input:
A set P\subseteq {\mathbb{R}}^2 \times {\mathbb{R}}^2ğ‘ƒâŠ†â„2Ã—â„2 of n pairs whose intersection graph {\rm{IG}}[P]IG[ğ‘ƒ] is a star, whose center is denoted by r = (s, t) \in Pğ‘Ÿ=(ğ‘ ,ğ‘¡)âˆˆğ‘ƒ.

Goal:
Find an optimal network N = (\pi _v)_{v \in P} \in {\rm{Opt}}(P)ğ‘=(ğœ‹ğ‘£)ğ‘£âˆˆğ‘ƒâˆˆOpt(ğ‘ƒ).

A crucial observation for GMMN[Star] is that an M-path \pi _l \in \varPi _P(l)ğœ‹ğ‘™âˆˆğ›±ğ‘ƒ(ğ‘™) for each leaf pair l \in P- rğ‘™âˆˆğ‘ƒâˆ’ğ‘Ÿ can share some segments only with an M-path \pi _r \in \varPi _P(r)ğœ‹ğ‘Ÿâˆˆğ›±ğ‘ƒ(ğ‘Ÿ) for the center pair r. Hence, minimizing the length of N = (\pi _v)_{v \in P}\in {\rm{Feas}}(P)ğ‘=(ğœ‹ğ‘£)ğ‘£âˆˆğ‘ƒâˆˆFeas(ğ‘ƒ) is equivalent to maximizing the total length of segments shared by two M-paths \pi _rğœ‹ğ‘Ÿ and \pi _lğœ‹ğ‘™ for l \in P- rğ‘™âˆˆğ‘ƒâˆ’ğ‘Ÿ.

In Sect. 3.1, we observe that, for each leaf pair l \in P- rğ‘™âˆˆğ‘ƒâˆ’ğ‘Ÿ, once we fix where an M-path \pi _r \in \varPi _P(r)ğœ‹ğ‘Ÿâˆˆğ›±ğ‘ƒ(ğ‘Ÿ) for r enters and leaves the bounding box B(l), the maximum length of segments that can be shared by \pi _rğœ‹ğ‘Ÿ and \pi _l \in \varPi _P(l)ğœ‹ğ‘™âˆˆğ›±ğ‘ƒ(ğ‘™) is easily determined. Thus, GMMN[Star] reduces to finding an optimal M-path \pi _r \in \varPi _P(r)ğœ‹ğ‘Ÿâˆˆğ›±ğ‘ƒ(ğ‘Ÿ) for the center pair r = (s, t)ğ‘Ÿ=(ğ‘ ,ğ‘¡), and in Sect. 3.2, we formulate this task as the computation of a longest sâ€“t path in an auxiliary directed acyclic graph (DAG), which is constructed from the subgrid {{\mathcal{H}}}(P, r)îˆ´(ğ‘ƒ,ğ‘Ÿ). As a result, we obtain an exact algorithm that runs in linear time in the size of auxiliary graphs, which are simplified so that it is always O(n^2)ğ‘‚(ğ‘›2) in Sect. 3.3.

Observation on Sharable Segments
Without loss of generality, we assume that the center pair r = (s, t)ğ‘Ÿ=(ğ‘ ,ğ‘¡) is regular, i.e., s \le tğ‘ â‰¤ğ‘¡. Fix an M-path \pi _r \in \varPi _P(r)ğœ‹ğ‘Ÿâˆˆğ›±ğ‘ƒ(ğ‘Ÿ) and a leaf pair l = (s_l, t_l) \in P- rğ‘™=(ğ‘ ğ‘™,ğ‘¡ğ‘™)âˆˆğ‘ƒâˆ’ğ‘Ÿ. Obviously, if \pi _rğœ‹ğ‘Ÿ is disjoint from the bounding box B(l), then any M-path \pi _l \in \varPi _P(l)ğœ‹ğ‘™âˆˆğ›±ğ‘ƒ(ğ‘™) cannot share any segment with \pi _rğœ‹ğ‘Ÿ. Suppose that \pi _rğœ‹ğ‘Ÿ intersects B(l), and let \pi _r[l]ğœ‹ğ‘Ÿ[ğ‘™] denote the intersection \pi _r \cap {{\mathcal{H}}}(P, l)ğœ‹ğ‘Ÿâˆ©îˆ´(ğ‘ƒ,ğ‘™). Let v = (p, q)ğ‘£=(ğ‘,ğ‘) be the pair of two vertices on \pi _rğœ‹ğ‘Ÿ such that \pi _r[l]ğœ‹ğ‘Ÿ[ğ‘™] is a pâ€“q path, and we call v the in-out pair of \pi _rğœ‹ğ‘Ÿ for l. As \pi _r \in \varPi _P(r)ğœ‹ğ‘Ÿâˆˆğ›±ğ‘ƒ(ğ‘Ÿ), we have \pi _r[l] \in \varPi _P(v)ğœ‹ğ‘Ÿ[ğ‘™]âˆˆğ›±ğ‘ƒ(ğ‘£), and v is also regular (recall the assumption p_x \le q_xğ‘ğ‘¥â‰¤ğ‘ğ‘¥). Moreover, for any M-path \pi _v \in \varPi _P(v)ğœ‹ğ‘£âˆˆğ›±ğ‘ƒ(ğ‘£), the network \pi '_rğœ‹â€²ğ‘Ÿ obtained from \pi _rğœ‹ğ‘Ÿ by replacing its subpath \pi _r[l]ğœ‹ğ‘Ÿ[ğ‘™] with \pi _vğœ‹ğ‘£ is also an M-path for r in \varPi _P(r)ğ›±ğ‘ƒ(ğ‘Ÿ). Since B(v) \subseteq B(l)ğµ(ğ‘£)âŠ†ğµ(ğ‘™) does not intersect B(l')ğµ(ğ‘™â€²) for any other leaf pair l' \in P\setminus \{r, l\}ğ‘™â€²âˆˆğ‘ƒâˆ–{ğ‘Ÿ,ğ‘™}, once v = (p, q)ğ‘£=(ğ‘,ğ‘) is fixed, we can freely choose an M-path \pi _v \in \varPi _P(v)ğœ‹ğ‘£âˆˆğ›±ğ‘ƒ(ğ‘£) instead of \pi _r[l]ğœ‹ğ‘Ÿ[ğ‘™] for maximizing the length of segments shared with some \pi _l \in \varPi _P(l)ğœ‹ğ‘™âˆˆğ›±ğ‘ƒ(ğ‘™). For each possible in-out pair v = (p, q)ğ‘£=(ğ‘,ğ‘) of M-paths in \varPi _P(r)ğ›±ğ‘ƒ(ğ‘Ÿ) (the sets of those vertices p and q are formally defined in Sect. 3.2 as V_{\llcorner }(r, l)ğ‘‰âŒ(ğ‘Ÿ,ğ‘™) and V_{\urcorner }(r, l)ğ‘‰âŒ(ğ‘Ÿ,ğ‘™), respectively), we denote by \gamma (l, p, q)ğ›¾(ğ‘™,ğ‘,ğ‘) the maximum length of segments shared by two M-paths for l and v = (p, q)ğ‘£=(ğ‘,ğ‘), i.e.,

\begin{aligned} \gamma (l, p, q) = \max \left\{ \Vert \pi _l \cap \pi _v\Vert \mid \pi _l \in \varPi _P(l),~\pi _v \in \varPi _P(p, q)\right\} . \end{aligned}

ğ›¾(ğ‘™,ğ‘,ğ‘)=max{â€–ğœ‹ğ‘™âˆ©ğœ‹ğ‘£â€–âˆ£ğœ‹ğ‘™âˆˆğ›±ğ‘ƒ(ğ‘™), ğœ‹ğ‘£âˆˆğ›±ğ‘ƒ(ğ‘,ğ‘)}.

(3.1)

Then, the following lemma is easily observed (see Fig. 2).

Lemma 3.1
For every leaf pair l \in P- rğ‘™âˆˆğ‘ƒâˆ’ğ‘Ÿ, the following properties hold.

(1)
If l is a regular pair, \gamma (l, p, q) = d(p, q)\ \bigl (= d_x(p, q) + d_y(p, q)\bigr )ğ›¾(ğ‘™,ğ‘,ğ‘)=ğ‘‘(ğ‘,ğ‘) (=ğ‘‘ğ‘¥(ğ‘,ğ‘)+ğ‘‘ğ‘¦(ğ‘,ğ‘)).

(2)
If l is a flipped pair, \gamma (l, p, q) = \max \left\{ d_x(p, q),\, d_y(p, q)\right\}ğ›¾(ğ‘™,ğ‘,ğ‘)=max{ğ‘‘ğ‘¥(ğ‘,ğ‘),ğ‘‘ğ‘¦(ğ‘,ğ‘)}.

Fig. 2
figure 2
a If l = (s_l, t_l)ğ‘™=(ğ‘ ğ‘™,ğ‘¡ğ‘™) is a regular pair, for any \pi _v \in \varPi _P(p, q)ğœ‹ğ‘£âˆˆğ›±ğ‘ƒ(ğ‘,ğ‘), some \pi _l \in \varPi _P(l)ğœ‹ğ‘™âˆˆğ›±ğ‘ƒ(ğ‘™) completely includes \pi _vğœ‹ğ‘£. b If l= (s_l, t_l)ğ‘™=(ğ‘ ğ‘™,ğ‘¡ğ‘™) is a flipped pair, while any \pi _l \in \varPi _P(l)ğœ‹ğ‘™âˆˆğ›±ğ‘ƒ(ğ‘™) cannot contain both horizontal and vertical segments of any \pi _v \in \varPi _P(p, q)ğœ‹ğ‘£âˆˆğ›±ğ‘ƒ(ğ‘,ğ‘), one can choose \pi _v \in \varPi _P(p, q)ğœ‹ğ‘£âˆˆğ›±ğ‘ƒ(ğ‘,ğ‘) so that the whole of either horizontal or vertical segments of \pi _vğœ‹ğ‘£ can be included in some \pi _l \in \varPi _P(l)ğœ‹ğ‘™âˆˆğ›±ğ‘ƒ(ğ‘™)

Full size image

Reduction to the Longest Path Problem in DAGs
In this section, we reduce GMMN[Star] to the longest path problem in DAGs. Let Pğ‘ƒ be a GMMN[Star] instance and r = (s, t) \in Pğ‘Ÿ=(ğ‘ ,ğ‘¡)âˆˆğ‘ƒ (s \le tğ‘ â‰¤ğ‘¡) be the center of {\rm{IG}}[P]IG[ğ‘ƒ], and we construct an auxiliary DAG G from the subgrid {\mathcal{H}}(P, r)îˆ´(ğ‘ƒ,ğ‘Ÿ) as follows (see Fig. 3).

Fig. 3
figure 3
a An M-path for r in the subgrid {{\mathcal{H}}}(P, r)îˆ´(ğ‘ƒ,ğ‘Ÿ). b The corresponding directed sâ€“t path in the auxiliary DAG G, where the dashed arcs are of length 0. c The boundary vertex sets for leaf pairs. d The corresponding parts in G, where the length of each interior arc (p, q) is \gamma (l, p, q)ğ›¾(ğ‘™,ğ‘,ğ‘) for p \in V_\llcorner (r, l)ğ‘âˆˆğ‘‰âŒ(ğ‘Ÿ,ğ‘™) and q \in V_\urcorner (r, l)ğ‘âˆˆğ‘‰âŒ(ğ‘Ÿ,ğ‘™)

Full size image

First, for each edge e = \{p, q\} \in E({\mathcal{H}}(P, r))ğ‘’={ğ‘,ğ‘}âˆˆğ¸(îˆ´(ğ‘ƒ,ğ‘Ÿ)) with p \le qğ‘â‰¤ğ‘ (and p \ne qğ‘â‰ ğ‘), we replace e with an arc (p, q) of length 0. For each leaf pair l \in P- rğ‘™âˆˆğ‘ƒâˆ’ğ‘Ÿ, let s'_lğ‘ â€²ğ‘™ and t'_lğ‘¡â€²ğ‘™ denote the lower-left and upper-right corners of B(r) \cap B(l)ğµ(ğ‘Ÿ)âˆ©ğµ(ğ‘™), respectively, so that (s'_l, t'_l)(ğ‘ â€²ğ‘™,ğ‘¡â€²ğ‘™) is a regular pair with B(s'_l, t'_l) = B(r) \cap B(l)ğµ(ğ‘ â€²ğ‘™,ğ‘¡â€²ğ‘™)=ğµ(ğ‘Ÿ)âˆ©ğµ(ğ‘™). If (s'_l, t'_l)(ğ‘ â€²ğ‘™,ğ‘¡â€²ğ‘™) is degenerate, then we change the length of each arc (p, q) with p, q \in V({\mathcal{H}}(P, r) \cap B(l))ğ‘,ğ‘âˆˆğ‘‰(îˆ´(ğ‘ƒ,ğ‘Ÿ)âˆ©ğµ(ğ‘™)) from 0 to \Vert pq\Vertâ€–ğ‘ğ‘â€–, which clearly reflects the (maximum) sharable length in B(l). Otherwise, the bounding box B(s'_l, t'_l) \subseteq B(l)ğµ(ğ‘ â€²ğ‘™,ğ‘¡â€²ğ‘™)âŠ†ğµ(ğ‘™) has a nonempty interior, and we define four subsets of V({\mathcal{H}}(P, r) \cap B(l))ğ‘‰(îˆ´(ğ‘ƒ,ğ‘Ÿ)âˆ©ğµ(ğ‘™)) as follows:

\begin{aligned} V_{\llcorner }(r, l)&= \{p \in V({\mathcal{H}}(P, r) \cap B(l)) \mid p_x = (s'_l)_x~\text {or}~p_y = (s'_l)_y\}, \\ V_{\urcorner }(r, l)&= \{q \in V({\mathcal{H}}(P, r) \cap B(l)) \mid q_x = (t'_l)_x~\text {or}~q_y = (t'_l)_y\}, \\ {V_{{}^\bullet {}_\bullet }}(r, l)&= V_{\llcorner }(r, l) \cap V_{\urcorner }(r, l), \\ V_{\blacksquare }(r, l)&= V({\mathcal{H}}(P, r) \cap B(l)) \setminus (V_{\llcorner }(r, l) \cup V_{\urcorner }(r, l)) \\&= \{z \in V({\mathcal{H}}(P, r) \cap B(l)) \mid (s'_l)_x< z_x< (t'_l)_x~\text {and}~(s'_l)_y< z_y < (t'_l)_y\}. \end{aligned}

ğ‘‰âŒ(ğ‘Ÿ,ğ‘™)ğ‘‰âŒ(ğ‘Ÿ,ğ‘™)ğ‘‰âˆ™âˆ™(ğ‘Ÿ,ğ‘™)ğ‘‰â—¼(ğ‘Ÿ,ğ‘™)={ğ‘âˆˆğ‘‰(îˆ´(ğ‘ƒ,ğ‘Ÿ)âˆ©ğµ(ğ‘™))âˆ£ğ‘ğ‘¥=(ğ‘ â€²ğ‘™)ğ‘¥ or ğ‘ğ‘¦=(ğ‘ â€²ğ‘™)ğ‘¦},={ğ‘âˆˆğ‘‰(îˆ´(ğ‘ƒ,ğ‘Ÿ)âˆ©ğµ(ğ‘™))âˆ£ğ‘ğ‘¥=(ğ‘¡â€²ğ‘™)ğ‘¥ or ğ‘ğ‘¦=(ğ‘¡â€²ğ‘™)ğ‘¦},=ğ‘‰âŒ(ğ‘Ÿ,ğ‘™)âˆ©ğ‘‰âŒ(ğ‘Ÿ,ğ‘™),=ğ‘‰(îˆ´(ğ‘ƒ,ğ‘Ÿ)âˆ©ğµ(ğ‘™))âˆ–(ğ‘‰âŒ(ğ‘Ÿ,ğ‘™)âˆªğ‘‰âŒ(ğ‘Ÿ,ğ‘™))={ğ‘§âˆˆğ‘‰(îˆ´(ğ‘ƒ,ğ‘Ÿ)âˆ©ğµ(ğ‘™))âˆ£(ğ‘ â€²ğ‘™)ğ‘¥<ğ‘§ğ‘¥<(ğ‘¡â€²ğ‘™)ğ‘¥ and (ğ‘ â€²ğ‘™)ğ‘¦<ğ‘§ğ‘¦<(ğ‘¡â€²ğ‘™)ğ‘¦}.

As r is regular, any M-path \pi _r \in \varPi _P(r)ğœ‹ğ‘Ÿâˆˆğ›±ğ‘ƒ(ğ‘Ÿ) intersecting B(l) enters it at some p \in V_{\llcorner }(r, l)ğ‘âˆˆğ‘‰âŒ(ğ‘Ÿ,ğ‘™) and leaves it at some q \in V_{\urcorner }(r, l)ğ‘âˆˆğ‘‰âŒ(ğ‘Ÿ,ğ‘™), and the maximum sharable length \gamma (l, p, q)ğ›¾(ğ‘™,ğ‘,ğ‘) in B(l) is determined by Lemma 3.1. We remove all the interior vertices in V_{\blacksquare }(r, l)ğ‘‰â—¼(ğ‘Ÿ,ğ‘™) (with all the incident arcs) and all the boundary arcs (p, q) with p, q \in V_{\llcorner }(r, l) \cup V_{\urcorner }(r, l)ğ‘,ğ‘âˆˆğ‘‰âŒ(ğ‘Ÿ,ğ‘™)âˆªğ‘‰âŒ(ğ‘Ÿ,ğ‘™). Instead, for each pair (p, q) of p \in V_{\llcorner }(r, l)ğ‘âˆˆğ‘‰âŒ(ğ‘Ÿ,ğ‘™) and q \in V_{\urcorner }(r, l)ğ‘âˆˆğ‘‰âŒ(ğ‘Ÿ,ğ‘™) with p \le qğ‘â‰¤ğ‘ and p \ne qğ‘â‰ ğ‘, we add an interior arc (p, q) of length \gamma (l, p, q)ğ›¾(ğ‘™,ğ‘,ğ‘). Let E_{\rm{int}}(l)ğ¸int(ğ‘™) denote the set of such interior arcs for each nondegenerate pair l \in P- rğ‘™âˆˆğ‘ƒâˆ’ğ‘Ÿ.

Finally, we care about the corner vertices in {V_{{}^\bullet {}_\bullet }}(r, l)ğ‘‰âˆ™âˆ™(ğ‘Ÿ,ğ‘™), which can be used for cheating if l is flipped as follows. Suppose that p \in {V_{{}^\bullet {}_\bullet }}(r, l)ğ‘âˆˆğ‘‰âˆ™âˆ™(ğ‘Ÿ,ğ‘™) is the upper-left corner of B(l), and consider the situation when the in-out pair (p', q')(ğ‘â€²,ğ‘â€²) of \pi _r \in \varPi _P(r)ğœ‹ğ‘Ÿâˆˆğ›±ğ‘ƒ(ğ‘Ÿ) for l satisfies p'_x = p_x < q'_xğ‘â€²ğ‘¥=ğ‘ğ‘¥<ğ‘â€²ğ‘¥ and p'_y < p_y = q'_yğ‘â€²ğ‘¦<ğ‘ğ‘¦=ğ‘â€²ğ‘¦. Then, (p', q')(ğ‘â€²,ğ‘â€²) is not degenerate, and by Lemma 3.1, the maximum sharable length in B(l) is \gamma (l, p', q') = \max \left\{ d_x(p', q'),\, d_y(p', q')\right\}ğ›¾(ğ‘™,ğ‘â€²,ğ‘â€²)=max{ğ‘‘ğ‘¥(ğ‘â€²,ğ‘â€²),ğ‘‘ğ‘¦(ğ‘â€²,ğ‘â€²)} as it is represented by an interior arc (p', q')(ğ‘â€²,ğ‘â€²), but one can take another directed p'ğ‘â€²â€“q'ğ‘â€² path that consists of two arcs (p', p)(ğ‘â€²,ğ‘) and (p, q')(ğ‘,ğ‘â€²) in the current graph, whose length is d_y(p', p) + d_x(p, q') = d_y(p', q') + d_x(p', q') >\gamma (l, p', q')ğ‘‘ğ‘¦(ğ‘â€²,ğ‘)+ğ‘‘ğ‘¥(ğ‘,ğ‘â€²)=ğ‘‘ğ‘¦(ğ‘â€²,ğ‘â€²)+ğ‘‘ğ‘¥(ğ‘â€²,ğ‘â€²)>ğ›¾(ğ‘™,ğ‘â€²,ğ‘â€²). To avoid such cheating, for each p \in {V_{{}^\bullet {}_\bullet }}(r, l)ğ‘âˆˆğ‘‰âˆ™âˆ™(ğ‘Ÿ,ğ‘™), we divide it into two distinct copies p^{\rm{hor}}ğ‘hor and p^{\rm{vert}}ğ‘vert (which are often identified with its original p unless we need to distinguish them), and replace the endpoint p of each incident arc e with p^{\rm{hor}}ğ‘hor if e is horizontal and with p^{\rm{vert}}ğ‘vert if vertical (see Fig. 3d). In addition, when p is not shared by any other leaf pair,Footnote 3 we add an arc (p^{\rm{hor}}, p^{\rm{vert}})(ğ‘hor,ğ‘vert) of length 0 if p is the upper-left corner of B(s'_l, t'_l)ğµ(ğ‘ â€²ğ‘™,ğ‘¡â€²ğ‘™) and an arc (p^{\rm{vert}}, p^{\rm{hor}})(ğ‘vert,ğ‘hor) of length 0 if the lower-right, which represents the situation when \pi _r \in \varPi _P(r)ğœ‹ğ‘Ÿâˆˆğ›±ğ‘ƒ(ğ‘Ÿ) intersects B(l) only at p.

Let G be the constructed directed graph, and denote by \ell (e)â„“(ğ‘’) the length of each arc e \in E(G)ğ‘’âˆˆğ¸(ğº). The following two lemmas complete our reduction (see Fig. 3 again).

Lemma 3.2
The directed graph G is acyclic.

Proof
Almost all arcs are of form (p, q) with p \le qğ‘â‰¤ğ‘ and p \ne qğ‘â‰ ğ‘. The only exception is of form (p^{\rm{vert}}, p^{\rm{hor}})(ğ‘vert,ğ‘hor) or (p^{\rm{hor}}, p^{\rm{vert}})(ğ‘hor,ğ‘vert) for some p \in {V_{{}^\bullet {}_\bullet }}(r, l)ğ‘âˆˆğ‘‰âˆ™âˆ™(ğ‘Ÿ,ğ‘™) with some l \in P- rğ‘™âˆˆğ‘ƒâˆ’ğ‘Ÿ, and at most one direction exists for each p by definition. Thus, G contains no directed cycle. \squareâ—»

Lemma 3.3
Any longest sâ€“t path \pi ^*_Gğœ‹âˆ—ğº in G with respect to \ellâ„“ satisfies

\begin{aligned} \sum _{e \in E(\pi ^*_G)} \ell (e) = \max _{\pi _r \in \varPi _P(r)}\left( \sum _{l \in P-r} \max _{\pi _l \in \varPi _P(l)}\Vert \pi _l \cap \pi _r\Vert \right) . \end{aligned}

âˆ‘ğ‘’âˆˆğ¸(ğœ‹âˆ—ğº)â„“(ğ‘’)=maxğœ‹ğ‘Ÿâˆˆğ›±ğ‘ƒ(ğ‘Ÿ)(âˆ‘ğ‘™âˆˆğ‘ƒâˆ’ğ‘Ÿmaxğœ‹ğ‘™âˆˆğ›±ğ‘ƒ(ğ‘™)â€–ğœ‹ğ‘™âˆ©ğœ‹ğ‘Ÿâ€–).

Proof
Fix a directed sâ€“t path \pi _Gğœ‹ğº in G. By the definition of G and Lemma 3.2, for each nondegenerate pair l \in P-rğ‘™âˆˆğ‘ƒâˆ’ğ‘Ÿ, the path \pi _Gğœ‹ğº uses at most one interior arc in E_{\rm{int}}(l)ğ¸int(ğ‘™), and any other arc has a trivially corresponding edge in {\mathcal{H}}(P, r)îˆ´(ğ‘ƒ,ğ‘Ÿ) (including edges in a degenerate pair). For each l with E(\pi _G) \cap E_{\rm{int}}(l) \ne \emptysetğ¸(ğœ‹ğº)âˆ©ğ¸int(ğ‘™)â‰ âˆ…, let e_l = (p, q)ğ‘’ğ‘™=(ğ‘,ğ‘) be the unique arc in E(\pi _G) \cap E_{\rm{int}}(l)ğ¸(ğœ‹ğº)âˆ©ğ¸int(ğ‘™). By the definitions of \ellâ„“ and \gammağ›¾, we have

\begin{aligned} \ell (e_l) = \gamma (l, p, q) = \max \left\{ \Vert \pi _l \cap \pi _{e_l}\Vert \mid \pi _l \in \varPi _P(l),~\pi _{e_l} \in \varPi _P(p, q)\right\} , \end{aligned}

â„“(ğ‘’ğ‘™)=ğ›¾(ğ‘™,ğ‘,ğ‘)=max{â€–ğœ‹ğ‘™âˆ©ğœ‹ğ‘’ğ‘™â€–âˆ£ğœ‹ğ‘™âˆˆğ›±ğ‘ƒ(ğ‘™), ğœ‹ğ‘’ğ‘™âˆˆğ›±ğ‘ƒ(ğ‘,ğ‘)},

(3.2)

and hence one can construct an M-path \pi _r \in \varPi _P(r)ğœ‹ğ‘Ÿâˆˆğ›±ğ‘ƒ(ğ‘Ÿ) by replacing each e_lğ‘’ğ‘™ with some M-path \pi _{e_l} \in \varPi _P(p, q) attaining (3.2) such that

\begin{aligned} \sum _{e \in E(\pi _G)} \ell (e) = \sum _{l \in P-r} \max _{\pi _l \in \varPi _P(l)}\Vert \pi _l \cap \pi _r\Vert . \end{aligned}

(3.3)

To the contrary, for any M-path \pi _r \in \varPi _P(r), by the definitions of \gamma and \ell, one can construct a directed sâ€“t path \pi _G in G of length at least the right-hand side of (3.3), and we are done. \square

Computational Time Analysis with Simplified DAGs
A longest path in a DAG G is computed in O(|V(G)| + |E(G)|) time by dynamic programming. Although the subgrid {{\mathcal{H}}}(P, r) has O(n^2) vertices and edges, the auxiliary DAG G constructed in Sect. 3.2 may have much more arcs due to E_{\rm{int}}(l), whose size is \varTheta (|V_{\llcorner }(r, l)| \cdot |V_{\urcorner }(r, l)|) and can be \varOmega (n^2). This, however, can be always reduced to linear by modifying the boundary vertices and the incident arcs appropriately in order to avoid creating diagonal arcs in B(l). In this section, we simplify G to G' with O(n^2) vertices and edges, which completes the proof of Theorem 1.1.

Fig. 4
figure 4
a Simplification for a regular pair. b Simplification for a flipped pair, where the gray and white vertices distinguish sharing horizontal and vertical segments in {{\mathcal{H}}}(P, r) \cap B(l), respectively, and the dashed arcs are of length 0

Full size image

Fix a nondegenerate leaf pair l \in P- r, and we modify the relevant part in G as follows (see Fig. 4). We first remove (precisely, avoid creating) the arcs (p, q) \in E_{\rm{int}}(l) for p \in V_{\llcorner }(r, l) and q \in V_{\urcorner }(r, l) with either p_x < q_x and p_y < q_y (diagonal) or p \in {V_{{}^\bullet {}_\bullet }}(r, l).

If l is a regular pair, then we keep the boundary vertices as they are. Instead of the removed arcs, we add an boundary arc (q_1, q_2) of length \Vert q_1q_2\Vert for each q_1, q_2 \in V_{\urcorner }(r, l) with \{q_1, q_2\} \in E({\mathcal{H}}(P, r)) and q_1 \le q_2. Then, for any removed arc e = (p, q) \in E_{\rm{int}}(l), there exists a pâ€“q path in G', whose length is always equal to \ell (e) = \gamma (l, p, q) = d(p, q) (cf. Lemma 3.1).

If l is a flipped pair, then we need to care which directional (horizontal or vertical) segments are shared in B(l). For this purpose, we add two distinct copies q^{\rm{hor}} and q^{\rm{vert}} of each boundary vertex q \in V_{\urcorner }(r, l) \setminus {V_{{}^\bullet {}_\bullet }}(r, l) with two arcs (q^{\rm{hor}}, q) and (q^{\rm{vert}}, q) of length 0 (recall that, for each p \in {V_{{}^\bullet {}_\bullet }}(r, l), we have already added p^{\rm{hor}} and p^{\rm{vert}}, and removed p itself in G). We also replace each remaining axis-aligned arc (p, q) \in E_{\rm{int}}(l) with two arcs (p, q^{\rm{hor}}) of length d_x(p, q) and (p, q^{\rm{vert}}) of length d_y(p, q).Footnote 4 Instead of the removed diagonal arcs, we add two boundary arcs (q_1^{\rm{hor}}, q_2^{\rm{hor}}) of length d_x(q_1, q_2) and (q_1^{\rm{vert}}, q_2^{\rm{vert}}) of length d_y(q_1, q_2) for each q_1, q_2 \in V_{\urcorner }(r, l) with \{q_1, q_2\} \in E({\mathcal{H}}(P, r)) and q_1 \le q_2. Then, for any removed arc e = (p, q) \in E_{\rm{int}}(l), there exist two pâ€“q path in G', whose lengths are equal to d_x(p, q) and d_y(p, q). As \ell (e) = \gamma (l, p, q) = \max \left\{ d_x(p, q),\, d_y(p, q)\right\} (cf. Lemma 3.1), the longest paths are preserved by this simplification.

As with Lemma 3.2, we can easily confirm that G' is acyclic. Thus, we have obtained a simplified auxiliary DAG G', and the following lemma completes the proof of Theorem 1.1.

Lemma 3.4
|V(G')| = O(n^2) and |E(G')| = O(n^2).

Proof
For the vertex set, by definition, we see

\begin{aligned} |V(G')| \le 3|V(G)| \le 6|V({{\mathcal{H}}}(P, r))| = O(n^2). \end{aligned}

For the arc set, since all the arcs outside of \bigcup _{l \in P- r} B(l) directly come from the subgrid {{\mathcal{H}}}(P, r), it suffices to show that the number of axis-aligned interior arcs and additional boundary arcs is O(n^2) in total. By definition, if {\mathcal{H}}(P, r) \cap {\mathcal{H}}(P, l) is an a \times b grid, then the number of such arcs is at most 3(a + b) in the regular case and at most 6(a + b) in the flipped case. Thus, the total number is at most

\begin{aligned} \sum _{l \in P-r} 6|V_{\urcorner }(l)| \le 6|V({{\mathcal{H}}}(P, r))| = O(n^2), \end{aligned}

and we are done. \square

An O(n^5)-Time Algorithm for GMMN[Tree]
In this section, we present an O(n^5)-time algorithm for GMMN[Tree], which is the main target in this paper and stated as follows.

Problem
(GMMN[Tree])

Input:
A set P\subseteq {\mathbb{R}}^2 \times {\mathbb{R}}^2 of n pairs whose intersection graph {\rm{IG}}[P] is a tree.

Goal:
Find an optimal network N = (\pi _v)_{v \in P} \in {\rm{Opt}}(P).

For a GMMN[Tree] instance P, we choose an arbitrary pair r \in P as the root of the tree {\rm{IG}}[P]; in particular, when {\rm{IG}}[P] is a star, we regard the center as the root. The basic idea of our algorithm is dynamic programming on the tree {\rm{IG}}[P] from the leaves toward r. Each subproblem reduces to the longest path problem in DAGs like the star case, which is summarized as follows.

Fix a pair v = (s_v, t_v) \in P. If v \ne r, then there exists a unique parent u = \rm{Par}(v) in the tree {\rm{IG}}[P] rooted at r, and there are O(n^2) possible in-out pairs (p_v, q_v) of \pi _u \in \varPi _P(u) for v. We virtually define p_v = q_v = \epsilon for the case when we do not care the shared length in B(u), e.g., v = r or \pi _u is disjoint from B(v). Let P_v denote the vertex set of the subtree of {\rm{IG}}[P] rooted at v (including v itself). For every possible in-out pair (p_v, q_v), as a subproblem, we compute the maximum total length \rm{dp}(v, p_v, q_v) of sharable segments in B(P_v) = \bigcup _{w \in P_v}B(w), i.e.,

\begin{aligned} {\rm{dp}}(v, \epsilon , \epsilon )&= \max \left\{ \sum _{w \in P_v - v} \Vert \pi _w \cap \pi _{\rm{Par}(w)} \Vert \Biggm | (\pi _{w})_{w \in P} \in {\rm{Feas}}(P) \right\} ,\\ \rm{dp}(v, p_v, q_v)&= \max \left\{ \sum _{w \in P_v} \Vert \pi _w \cap \pi _{\rm{Par}(w)} \Vert \Biggm | \begin{array}{ll} &{}(\pi _{w})_{w \in P} \in {\rm{Feas}}(P),\\ &{}\pi _u[v] \in \varPi _P(p_v, q_v)\end{array} \right\} . \end{aligned}

By definition, the goal is to compute \rm{dp}(r, \epsilon , \epsilon ). If v is a leaf in {\rm{IG}}[P], then P_v = \{v\}. In this case, \rm{dp}(v, p_v, q_v) is the maximum length of segments shared by two M-paths \pi _v \in \varPi _P(v) and \pi _u \in \varPi _P(u) with \pi _u[v] \in \varPi _P(p_v, q_v), which is easily determined (cf. Lemma 3.1). Otherwise, using the computed values \rm{dp}(w, p_w, q_w) for all children w of v and all possible in-out pairs (p_w, q_w), we reduce the task to the computation of a longest s_vâ€“t_v path in an auxiliary DAG, as with finding an optimal M-path for the center pair in the star case.

Constructing Auxiliary DAGs for Subproblems
Let v = (s_v, t_v) \in P, which is assumed to be regular without loss of generality. If v = r, then let p_v = q_v = \epsilon; otherwise, let u = \rm{Par}(v) be its parent, and fix a possible in-out pair u' = (p_v, q_v) of \pi _u \in \varPi _P(u) for v (including the case p_v = q_v = \epsilon). Let C_v \subseteq P_v be the set of all children of v. By replacing r and P- r in Sect. 3.2 with v and C_v + u' (or C_v if p_v = q_v = \epsilon), respectively, we construct the same auxiliary directed graph, denoted by G[v, p_v, q_v]. We then change the length of each interior arc (p_w, q_w) \in E_{\rm{int}}(w) for each child w \in C_v from \gamma (w, p_w, q_w) to {\rm{dp}}(w, p_w, q_w) - {\rm{dp}}(w, \epsilon , \epsilon ), so that it represents the difference of the total sharable length in B(P_w) = \bigcup _{w' \in P_w}B(w') between the cases when an M-path for v intersects B(w) (enters at p_w and leaves at q_w) and when an M-path for v is ignored. As with Lemma 3.2, the graph G[v, p_v, q_v] is acyclic. The following lemma completes the reduction of computing \rm{dp}(v, p_v, q_v) to finding a longest s_vâ€“t_v path in G[v, p_v, q_v].

Lemma 4.1
Let \pi _G^* be a longest s_vâ€“t_v path in G[v, p_v, q_v] with respect to \ell. We then have

\begin{aligned} \rm{dp}(v, p_v, q_v) = \sum _{e \in E(\pi _G^*)} \ell (e) + \sum _{w \in C_v} \rm{dp}(w, \epsilon , \epsilon ). \end{aligned}

Proof
If v is a leaf in {\rm{IG}}[P], then C_v = \emptyset, and hence it immediately follows from Lemma 3.3.

Suppose that v is not a leaf in {\rm{IG}}[P], and let \pi _G be a directed s_vâ€“t_v path in G[v, p_v, q_v]. We show that there exists a feasible solution (\pi _w)_{w \in P} \in {\rm{Feas}}(P) with \pi _u[v] \in \varPi _P(p_v, q_v) and

\begin{aligned} \sum _{w \in P_v} \Vert \pi _{w} \cap \pi _{\rm{Par}(w)} \Vert = \sum _{e \in E(\pi _G)} \ell (e) + \sum _{w \in C_v} \rm{dp}(w, \epsilon , \epsilon ). \end{aligned}

(4.1)

By definition, for each w \in C_v + u', the path \pi _G uses at most one arc in E_{\rm{int}}(w). For each w \in C_v with E(\pi _G) \cap E_{\rm{int}}(w) \ne \emptyset, let e_w = (p_w, q_w) be the unique arc in E(\pi _G) \cap E_{\rm{int}}(w), and then \ell (e_w) = \rm{dp}(w, p_w, q_w) - \rm{dp}(w, \epsilon , \epsilon ). Hence, by defining p_w = q_w = \epsilon for each w \in C_v with E(\pi _G) \cap E_{\rm{int}}(w) = \emptyset, the right-hand side of (4.1) is rewritten as

\begin{aligned} \sum _{w \in C_v} \rm{dp}(w, p_w, q_w) + \gamma (u'), \end{aligned}

where \gamma (u') = \gamma (u', p_{u'}, q_{u'}) if there exists (p_{u'}, q_{u'}) \in E(\pi _G) \cap E_{\rm{int}}(u') and \gamma (u') = 0 otherwise.

By the definition of \rm{dp}, for each w \in C_v, there exists an M-path {\tilde{\pi }}_{v, w} \in \varPi _P(p_w, q_w) appearing as \pi _v[w] = \pi _v \cap {{\mathcal{H}}}(P, w) in some feasible solution N = (\pi _w)_{w \in P} \in {\rm{Feas}}(P) such that

\begin{aligned} \sum _{w' \in P_w} \Vert \pi _{w'} \cap \pi _{\rm{Par}(w')} \Vert = \rm{dp}(w, p_w, q_w). \end{aligned}

If \gamma (u') = 0, then N (with replacing \pi _u so that \Vert \pi _v \cap \pi _u\Vert = 0 if necessary) is a desired network. Otherwise, there exists a unique arc (p_{u'}, q_{u'}) \in E(\pi _G) \cap E_{\rm{int}}(u'). By choosing {\tilde{\pi }}_{v, u'} \in \varPi _P(p_{u'}, q_{u'}) appropriately (cf. Lemma 3.1), one can replace \pi _v as well as \pi _u so that \Vert \pi _v \cap \pi _u\Vert = \gamma (u', p_{u'}, q_{u'}) and \pi _u[v] \in \varPi _P(p_v, q_v), and we are done.

To the contrary, we show that, for any feasible solution N = (\pi _w)_{w \in P} \in {\rm{Feas}}(P) with \pi _u[v] \in \varPi _P(p_v, q_v), there exists a directed s_vâ€“t_v path \pi _G in G[v, p_v, q_v] of length at least

\begin{aligned}&\sum _{w \in P_v} \Vert \pi _w \cap \pi _{\rm{Par}(w)} \Vert - \sum _{w \in C_v} \rm{dp}(w, \epsilon , \epsilon )\nonumber \\&\quad = \sum _{w \in C_v} \left( \sum _{w' \in P_w} \Vert \pi _{w'} \cap \pi _{\rm{Par}(w')} \Vert - \rm{dp}(w, \epsilon , \epsilon )\right) + \Vert \pi _v \cap \pi _u\Vert . \end{aligned}

(4.2)

The proof is done by induction from the leaves to the root in {\rm{IG}}[P]. For each w \in C_v + u', suppose that \pi _v[w] \in \varPi _P(p_w, q_w), where we virtually define p_w = q_w = \epsilon if \pi _v is disjoint from B(w). Then, by taking \pi _G so that (p_w, q_w) \in E(\pi _G) for each w \in C_v + u' unless p_w = q_w = \epsilon, we obtain the following relation from the induction hypothesis (when v is not a leaf) and the definitions of \ell and \rm{dp}:

\begin{aligned} \sum _{e \in E(\pi _G)} \ell (e) = \sum _{w \in C_v} \left( \rm{dp}(w, p_w, q_w) - \rm{dp}(w, \epsilon , \epsilon )\right) + \gamma (u') \ge \rm{(R.H.S.~of~(4.2))}, \end{aligned}

where \gamma (u') = 0 if p_{u'} = q_{u'} = \epsilon and \gamma (u') = \gamma (u', p_{u'}, q_{u'}) otherwise. Thus we are done. \square

Computational Time Analysis
This section completes the proof of Theorem 1.2. For a pair v \in P, suppose that {{\mathcal{H}}}(P, v) is an a_v \times b_v grid graph. For each possible in-out pair (p_v, q_v), to compute \rm{dp}(v, p_v, q_v), we find a longest path in the DAG G[v, p_v, q_v] constructed in Sect. 4.1, which has O(a_v b_v) = O(n^2) vertices and O(\delta _v (a_v + b_v)^2) = O(\delta _v n^2) edges, where \delta _v is the degree of v in {\rm{IG}}[P]. Hence, for solving the longest path problem once for each v \in P, it takes \sum _{v \in P} O(\delta _v n^2) = O(n^3) time in total (recall that {\rm{IG}}[P] is a tree). For each v \in P- r, there are respectively at most a_v + b_v = O(n) candidates for p_v and for q_v, and hence O(n^2) possible in-out pairs. Thus, the total computational time is bounded by O(n^5), and we are done.

An O(n^3)-Time Algorithm for GMMN[Tree]
In this section, we improve the DP algorithm for GMMN[Tree] given in Sect. 4 so that it can be implemented in O(n^3) time.

Overview
Let P be a GMMN[Tree] instance with |P| \ge 3, and we choose a root r \in P of the tree {\rm{IG}}[P] such that r is not a leaf (i.e., r has at least two neighbors). In Sect. 4, for each v \in P- r and each possible in-out pair (p_v, q_v) of \pi _u\in \varPi _P(u) for v, we compute {\rm{dp}}(v, p_v, q_v) one-by-one by finding a longest s_vâ€“t_v path in the auxiliary DAG G[v, p_v, q_v]. In this section, using an extra DP, we improve this part so that we compute {\rm{dp}}(v, p_v, q_v) for many possible in-out pairs (p_v, q_v) at once.

As with Sect. 4, we assume that v is regular, and let u=(s_u, t_u) be the parent of v. We also assume that neither u nor v is degenerate (otherwise, we can easily fill up the table {\rm{dp}}(v, \cdot , \cdot ) in O(n^2) time by definition). Since u must have a neighbor other than v by the choice of the root r, we have B(u) \not \subseteq B(v). Hence, for any M-path \pi _u \in \varPi _P(u), its in-out pair (p_v, q_v) satisfies one of the following conditions:

(a)
either p_v = s_u \in B(v) or q_v = t_u \in B(v), and then one endpoint p_v or q_v is completely fixed;

(b)
p_v \ne s_u, q_v \ne t_u, and they are on two adjacent boundaries of B(v);

(c)
p_v \ne s_u, q_v \ne t_u, and they are on two opposite boundaries of B(v).

For each case among (a)â€“(c), we design an extra DP to compute {\rm{dp}}(v, p_v, q_v) for all such in-out pairs (p_v, q_v) in O(n^2) time. Then, no matter how B(u) intersects B(v), one can classify all the possible in-out pairs into a constant number of such cases, and fill up the table {\rm{dp}}(v, \cdot , \cdot ) in O(n^2) time in total by applying the designed DPs separately.Footnote 5 This implies that the overall computational time is bounded by O(n^3).

No matter which of the three cases (a)â€“(c) we consider, we first compute the value {\rm{dp}}(v, \epsilon , \epsilon ) by computing a longest s_vâ€“t_v path in the auxiliary DAG G[v, \epsilon , \epsilon ]. In addition, by doing it in two ways from s_v and from t_v, we obtain a longest s_vâ€“z path and a longest zâ€“t_v path for every (reachable) z \in V(G[v, \epsilon , \epsilon ]) as byproducts. We denote the lengths of the s_vâ€“z path and the zâ€“t_v path by \lambda (s_v, z) and \lambda (z, t_v), respectively. Note that this computation for all v \in P requires O(n^3) time in total (cf. Sect. 4.2). We also compute the value \kappa _v = \sum _{w \in C_v} {\rm{dp}}(w, \epsilon , \epsilon ), which is the baseline of the total sharable length in the subtree rooted at v (cf. Lemma 4.1), where recall that C_v denotes the set of all children of v.

We then show that computing the values {\rm{dp}}(v, p_v, q_v) for all possible in-out pairs (p_v, q_v) in each case takes O(n^2) time in total. Suppose that {{\mathcal{H}}}(P, v) \cap {{\mathcal{H}}}(P, u) is an a \times b grid graph, where a and b are associated with the y- and x-coordinates, respectively. Depending on the cases (a)â€“(c) and whether the parent u is regular or flipped (hence, we consider six cases), we define auxiliary DP values (e.g., denoted by \omega (v, i, j) for i \in [a] and j \in [b]), and demonstrate how to compute and use them.

When the Parent is Regular
In this section, we consider the case that the parent u is a regular pair.

Case (a): One Endpoint is Fixed in the Subgrid
By symmetry, we consider the situation when p_v = s_u \in B(v) and (q_v)_x = (t_v)_x for all possible in-out pairs (p_v, q_v) of \pi _u \in \varPi _P(u) for v. We then have (t_v)_x < (t_u)_x and (t_u)_y \le (t_v)_y, and let p_{i,j} be the (i, j) vertex on the a \times b grid {\mathcal{H}}(P, v) \cap {\mathcal{H}}(P, u) for each i \in [a] and j \in [b], where we define p_{1,1} = s_u (see Fig. 5). In this case, we need to compute {\rm{dp}}(v, p_{1,1}, p_{i,b}) for each i \in [a].

Fig. 5
figure 5
The case (a) when the parent u is regular

Full size image

For each i \in [a] and j \in [b], we define \omega (v, i, j) as the length of a longest s_vâ€“p_{i,j} path in G[v, p_{1,1}, p_{i,j}], where we slightly extend the definition of the auxiliary DAG G[v, p_v, q_v] in Sect. 4.1 so that (p_v, q_v) is not necessarily an in-out pair of \pi _u \in \varPi _P(u) for v but that of its subpath. Then, by Lemma 4.1, we have

\begin{aligned} {\rm{dp}}(v, p_{1,1}, p_{i, b}) = \max \left\{ \max _{j \in [b]} \left( \omega (v, i, j) + \lambda (p_{i,j}, t_v)\right) + \kappa _v,\, {\rm{dp}}(v, \epsilon , \epsilon )\right\} \end{aligned}

for each i \in [a], because any s_vâ€“t_v path in G[v, p_{1,1}, p_{i,b}] either leaves B(p_{1,1}, p_{i,b}) at some p_{i,j} (j \in [b]) or is disjoint from B(p_{1,1}, p_{i,b}). Thus, after filling up the table \omega (v, \cdot , \cdot ), we can compute the values {\rm{dp}}(v, p_{1,1}, p_{i,b}) for all i \in [a] in O(a \times b) = O(n^2) time in total. In what follows, we see how to compute \omega (v, i, j).

For the base case when i = j = 1, from the definitions of G[v, \cdot , \cdot ] and \lambda (s_v, \cdot ), we see

\begin{aligned} \omega (v, 1, 1)&= \lambda (s_v, p_{1,1}). \end{aligned}

(5.1)

Next, when i > 1 and j = 1, we can compute it by a recursive formula

\begin{aligned} \omega (v, i, 1)&= \max \left\{ \omega (v, i-1, 1) + \Vert p_{i-1, 1}p_{i, 1}\Vert ,\, \lambda (s_v, p_{i,1})\right\} , \end{aligned}

(5.2)

which is confirmed as follows. Fix a longest s_vâ€“p_{i,j} path in G[v, p_{1,1}, p_{i,1}] attaining \omega (v, i, 1), and let \pi \in \varPi _P(s_v, p_{i,j}) be a corresponding M-path. If \pi intersects p_{i-1,1}, then the s_vâ€“p_{i-1,1} prefix corresponds to a longest s_vâ€“p_{i-1,1} path in G[v, p_{1,1}, p_{i-1,1}] of length \omega (v, i-1, 1) and the last segment p_{i-1,1}p_{i,1} contributes to the length in G[v, p_{1,1}, p_{i,1}] in addition. Otherwise, \pi is disjoint from p_{i-1,1}, and it then corresponds to a longest s_vâ€“p_{i,1} path in G[v, \epsilon , \epsilon ] of length \lambda (s_v, p_{i,1}). The case when i = 1 and j > 1 is similarly computed by

\begin{aligned} \omega (v, 1, j)&= \max \left\{ \omega (v, 1, j-1) + \Vert p_{1, j-1}p_{1, j}\Vert ,\, \lambda (s_v, p_{1,j})\right\} . \end{aligned}

(5.3)

Finally, when i > 1 and j > 1, we can compute it by a recursive formula

\begin{aligned} \omega (v, i, j)&= \max \left\{ \omega (v, i-1, j) + \Vert p_{i-1, j}p_{i, j}\Vert ,\, \omega (v, i, j-1) + \Vert p_{i,j-1}p_{i,j}\Vert \right\} , \end{aligned}

(5.4)

because for any s_vâ€“p_{i,j} path in G[v, p_{1,1}, p_{i,j}], a corresponding M-path in \varPi _P(s_v, p_{i,j}) intersects either p_{i-1,j} or p_{i,j-1}, and the last segment p_{i-1,j}p_{i, j} or p_{i,j-1}p_{i, j}, respectively, contributes to the length in G[v, p_{1,1}, p_{i,j}].

Since we only look up a constant number of values in (5.1)â€“(5.4), each value \omega (v, i, j) can be computed in constant time. As the table \omega (v, \cdot , \cdot ) is of size a\times b = O(n^2), the total computational time is O(n^2). Thus we are done.

Case (b): In-Out Pairs Move on Adjacent Boundaries
By symmetry, we consider the situation when (p_v)_y = (s_v)_y and (q_v)_x = (t_v)_x for all possible in-out pairs (p_v, q_v) of \pi _u \in \varPi _P(u) for v. We then have (s_v)_x \le (s_u)_x \le (t_v)_x < (t_u)_x and (s_u)_y < (s_v)_y \le (t_u)_y \le (t_v)_y, and let p_{i,j} be the (i, j) vertex on the a \times b grid {\mathcal{H}}(P, v) \cap {\mathcal{H}}(P, u) for each i \in [a] and j \in [b], where we define p_{1,1} as the lower-right corner (see Fig. 6). In this case, we need to compute {\rm{dp}}(v, p_{1,j}, p_{i,1}) for each pair of i \in [a] and j \in [b].

Fig. 6
figure 6
The case (b) when the parent u is regular

Full size image

For each i \in [a] and j \in [b], we define \omega (v, i, j) as the maximum length of an s_vâ€“t_v path in G[v, p_{1,j}, p_{i,1}] that intersects B(p_{1,j}, p_{i,1}). Then, by Lemma 4.1, we have

\begin{aligned} {\rm{dp}}(v, p_{1,j}, p_{i,1})&= \max \left\{ \omega (v, i, j) + \kappa _v,\, {\rm{dp}}(v, \epsilon , \epsilon )\right\} . \end{aligned}

Thus, after filling up the table \omega (v, \cdot , \cdot ), we can compute the values {\rm{dp}}(v, p_{1,j}, p_{i,1}) for all i \in [a] and j \in [b] in O(a \times b) = O(n^2) time in total.

In what follows, we see how to compute \omega (v, i, j). We first observe that, for any s_vâ€“t_v path in G[v, p_{1,j}, p_{i,1}] attaining \omega (v, i, j), a corresponding M-path \pi _v \in \varPi _P(v) can be taken so that it intersects p_{i,j} by choosing an M-path \pi _u \in \varPi _P(u) appropriately (cf. Lemma 3.1).

For the base case when i = j = 1, from the definitions of G[v, \cdot , \cdot ], \lambda (s_v, \cdot ), and \lambda (\cdot , t_v), we see

\begin{aligned} \omega (v, 1, 1)&= \lambda (s_v, p_{1,1}) + \lambda (p_{1,1}, t_v). \end{aligned}

(5.5)

Next, when i > 1 and j = 1, we can compute it by a recursive formula

\begin{aligned} \omega (v, i, 1)&= \max \left\{ \omega (v, i-1, 1) + \Vert p_{i-1,1}p_{i,1}\Vert ,\, \lambda (s_v, p_{i,1}) + \lambda (p_{i,1}, t_v)\right\} , \end{aligned}

(5.6)

which is confirmed as follows. Fix an s_vâ€“t_v path in G[v, p_{1,1}, p_{i,1}] attaining \omega (v, i, 1), and let \pi _v \in \varPi _P(v) be a corresponding M-path. If \pi _v intersects p_{i-1,1}, then it corresponds to an s_vâ€“t_v path in G[v, p_{1,1}, p_{i-1,1}] attaining \omega (v, i-1, 1) and the segment p_{i-1,1}p_{i,1} contributes to the length in G[v, p_{1,1}, p_{i,1}] in addition. Otherwise, \pi _v is disjoint from p_{i-1,1}, and hence \pi _v intersects B(p_{1,1}, p_{i,1}) only at p_{i,1}. Then, the s_vâ€“p_{i,1} prefix of \pi _v corresponds to a longest s_vâ€“p_{i,1} path in G[v, \epsilon , \epsilon ] of length \lambda (s_v, p_{i,1}), and the p_{i,1}â€“t_v suffix a longest p_{i,1}â€“t_v path in G[v, \epsilon , \epsilon ] of length \lambda (p_{i,1}, t_v). The case when i = 1 and j > 1 is similarly computed by

\begin{aligned} \omega (v, 1, j)&= \max \left\{ \omega (v, 1, j-1) + \Vert p_{1,j}p_{1,j-1}\Vert ,\, \lambda (s_v, p_{1,j}) + \lambda (p_{1,j}, t_v)\right\} . \end{aligned}

(5.7)

Finally, when i > 1 and j > 1, we can compute it by a recursive formula

\begin{aligned} \omega(v, i, j) = \max\,\{&\omega(v, i-1, j) + \|p_{i-1,j}p_{i,j}\|,\\ &\omega(v, i, j-1) + \|p_{i,j}p_{i,j-1}\|,\\ &\lambda(s_v, p_{i,j}) + \lambda(p_{i,j}, t_v)\}, \end{aligned}

(5.8)

because, for any M-path \pi _v \in \varPi _P(v) intersecting p_{i,j}, it either intersects at least one of p_{i-1,j} and p_{i,j-1} or intersects B(p_{1,j}, p_{i,1}) only at p_{i,j}, and each case can be analyzed as with the previous paragraph.

Since we only look up a constant number of values in (5.5)â€“(5.8), each value \omega (v, i, j) can be computed in constant time. As the table \omega (v, \cdot , \cdot ) is of size a\times b = O(n^2), the total computational time is O(n^2). Thus we are done.

Case (c): In-Out Pairs Move on Opposite Boundaries
By symmetry, we consider the situation when (p_v)_y = (s_v)_y and (q_v)_y = (t_v)_y for all possible in-out pairs (p_v, q_v) of \pi _u \in \varPi _P(u) for v. We then have (s_v)_x \le (s_u)_x < (t_u)_x \le (t_v)_x and (s_u)_y< (s_v)_y< (t_v)_y < (t_u)_y, and let p_{i,j} be the (i, j) vertex on the a \times b grid {\mathcal{H}}(P, v) \cap {\mathcal{H}}(P, u) for each i \in [a] and j \in [b], where we define p_{1,1} as the lower-right corner (see Fig. 7). In this case, we need to compute {\rm{dp}}(v, p_{1,j}, p_{a,k}) for each j, k \in [b] with j \ge k, which we directly compute as follows.

Fig. 7
figure 7
The case (c) when the parent u is regular

Full size image

First, when j = k = 1, we have

\begin{aligned} {\rm{dp}}(v, p_{1,1}, p_{a,1})&= \max _{1 \le h \le i \le a} \left( \lambda (s_v, p_{h,1}) + \lambda (p_{i,1}, t_v) + \Vert p_{h,1}p_{i,1}\Vert \right) , \end{aligned}

(5.9)

because any M-path \pi _v \in \varPi _P(v) intersects the segment p_{1,1}p_{a,1} at some point, and it is partitioned into three parts: the s_vâ€“p_{h,1} prefix, the segment p_{h,1}p_{i,1}, and the p_{i,1}â€“t_v suffix for some h, i \in [a] with h \le i. The computation of {\rm{dp}}(v, p_{1,1}, p_{a,1}) requires O(a^2) = O(n^2) time.

Next, for any 1 \le k \le j \le b, we have

\begin{aligned} {\rm{dp}}(v, p_{1,j}, p_{a,k})&= {\rm{dp}}(v, p_{1,1}, p_{a,1}) + \Vert p_{1,j} p_{1,k}\Vert , \end{aligned}

(5.10)

which is confirmed as follows. Fix a network (\pi _w)_{w \in P} \in {\rm{Feas}}(P) attaining {\rm{dp}}(v, p_{1,j}, p_{a,k}). Then, without changing the total shared length, we can modify the M-paths \pi _v \in \varPi _P(v) and \pi _u \in \varPi _P(u) with \pi _u[v] \in \varPi _P(p_{1,j}, p_{a,k}) so that it also attains {\rm{dp}}(v, p_{1,j}, p_{a,j}) = {\rm{dp}}(v, p_{1,1}, p_{a,1}) and \pi _v shares all of its horizontal segments in B(p_{1,j}, p_{a,k}) with \pi _u in addition, whose total length is d_x(p_{1,j}, p_{1,k}) = \Vert p_{1,j} p_{1,k}\Vert (cf. Lemma 3.1 and Fig. 2).

We can compute {\rm{dp}}(v, p_{1,j}, p_{a,k}) in constant time by (5.10) for each j, k \in [b] with j \ge k. As the table {\rm{dp}}(v, \cdot , \cdot ) is of size O(b^2) = O(n^2), the total computational time is O(n^2). Thus we are done.

When the Parent is Flipped
In this section, we consider the case that the parent u is a flipped pair.

Case (a): One Endpoint is Fixed in the Subgrid
By symmetry, we consider the situation when p_v = s_u \in B(v) and (q_v)_x = (t_v)_x for all possible in-out pairs (p_v, q_v) of \pi _u \in \varPi _P(u) for v. We then have (t_v)_x < (t_u)_x and (s_v)_y \le (t_u)_y, and let p_{i,j} be the (i, j) vertex on the a \times b grid {\mathcal{H}}(P, v) \cap {\mathcal{H}}(P, u) for each i \in [a] and j \in [b], where we define p_{1,1} as the upper-right corner so that p_{1,b} = s_u (see Fig. 8). In this case, we need to compute {\rm{dp}}(v, p_{1,b}, p_{i,1}) for each i \in [a].

Fig. 8
figure 8
The case (a) when the parent u is flipped

Full size image

For each i \in [a] and j \in [b], we define \omega (v, i, j) as the length of a longest p_{i,j}â€“t_v path in G[v, p_{i,j}, p_{1,1}]. Then, as with the regular case, by Lemma 4.1, we have

\begin{aligned} {\rm{dp}}(v, p_{1,b}, p_{i,1}) = \max\,\Bigl\{&\max_{j \in [b]} \left(\lambda(s_v, p_{i,j}) + \omega(v, i, j)\right) + \kappa_v,\\ &\max_{h \in [i]} \left(\lambda(s_v, p_{h,b}) + \omega(v, h, b)\right) + \kappa_v,\\ &{\rm{dp}}(v, \epsilon, \epsilon)\Bigr\} \end{aligned}

for each i \in [a], because any s_vâ€“t_v path in G[v, p_{i,j}, p_{1,1}] either enters B(p_{1,b}, p_{i,1}) at some p_{i,j} (j \in [b]), enters B(p_{1,b}, p_{i,1}) at some p_{h,b} (h \in [i]), or is disjoint from B(p_{1,b}, p_{i,1}). Thus, after filling up the table \omega (v, \cdot , \cdot ), we can compute the values {\rm{dp}}(v, p_{1,b}, p_{i,1}) for all i \in [a] in O(a \times (a + b)) = O(n^2) time in total. In what follows, we see how to compute \omega (v, i, j).

First, when j = 1, from the definitions of G[v, \cdot , \cdot ] and \lambda (\cdot , t_v), we see

\begin{aligned} \omega (v, i, 1)&= \lambda (p_{1,1}, t_v) + \Vert p_{i,1}p_{1,1}\Vert . \end{aligned}

(5.11)

Similarly, when i = 1 and j > 1, we have

\begin{aligned} \omega (v, 1, j)&= \max _{k \in [j]} \left( \lambda (p_{1,k}, t_v) + \Vert p_{1,j}p_{1,k}\Vert \right) , \end{aligned}

(5.12)

because any M-path in \varPi _P(p_{1,j}, t_v) leaves B(p_{1,j}, p_{1,1}) at some point p_{1,k} (k \in [j]) and then it shares the first segment p_{1,j}p_{1,k} with p_u \in \varPi _P(u) (with p_u[v] \in \varPi _P(s_u, p_{1,1})). Computing \omega (v, 1, j) requires O(j) time by (5.12), and hence it takes O(b^2) = O(n^2) time in total for all j \in [b].

Finally, when i > 1 and j > 1, we can compute it by a recursive formula

\begin{aligned} \omega (v, i, j)&= \max \left\{ \lambda (p_{1,j}, t_v) + \Vert p_{i,j}p_{1,j}\Vert ,\, \omega (v, i-1, j), \, \omega (v, i, j-1)\right\} , \end{aligned}

(5.13)

which is confirmed as follows. Fix a longest p_{i,j}â€“t_v path in G[v, p_{i,j}, p_{1,1}] attaining \omega (v, i, j), and let \pi \in \varPi _P(p_{i,j}, t_v) be a corresponding M-path. If \pi leaves B(p_{i,j}, p_{1,1}) at p_{1,j}, then the p_{1,j}â€“t_v suffix corresponds to a longest p_{1,j}â€“t_v path in G[v, \epsilon , \epsilon ] of length \lambda (p_{1,j}, t_v) and the first segment p_{i,j}p_{1,j} contributes to the length in G[v, p_{i,j}, p_{1,1}] in addition. Otherwise, \pi leaves B(p_{i,j}, p_{1,1}) at some p_{1,k} (k \in [j-1]). Recall that, since u is flipped, \pi can share either horizontal or vertical segments with \pi _u \in \varPi _P(u) (cf. Lemma 3.1). If \pi shares horizontal segments with \pi _u, then we can assume that the p_{i,j}â€“p_{1,k} prefix of \pi consists of two segments p_{i,j}p_{1,j} and p_{1,j}p_{1,k} by modifying \pi _u (with \pi _u[v] \in \varPi _P(p_{1,b}, p_{i,1})) so that it traverses p_{1,j}p_{1,k}; we then have \omega (v, i, j) = \omega (v, 1, j) = \omega (v, i-1, j). Otherwise, \pi shares vertical segments with \pi _u, and we can assume that the p_{i,j}â€“p_{1,k} prefix of \pi consists of two segments p_{i,j}p_{i,k} and p_{i,k}p_{1,k} by modifying \pi _u so that it traverses p_{i,k}p_{1,k}; we then have \omega (v, i, j) = \omega (v, i, k) = \omega (v, i, j-1).

Since we only look up a constant number of values in (5.13) as well as (5.11), each value \omega (v, i, j) for i > 1 can be computed in constant time. As the table \omega (v, \cdot , \cdot ) is of size a\times b = O(n^2), the total computational time is bounded by O(n^2). Thus we are done.

Case (b): In-Out Pairs Move on Adjacent Boundaries
By symmetry, we consider the situation when (p_v)_y = (t_v)_y and (q_v)_x = (t_v)_x for all possible in-out pairs (p_v, q_v) of \pi _u \in \varPi _P(u) for v. We then have (s_v)_x \le (s_u)_x \le (t_v)_x < (t_u)_x and (s_v)_y \le (t_u)_y \le (t_v)_y < (s_u)_y, and let p_{i,j} be the (i, j) vertex on the a \times b grid {\mathcal{H}}(P, v) \cap {\mathcal{H}}(P, u) for each i \in [a] and j \in [b], where we define p_{1,1}=t_v (see Fig. 9). In this case, we need to compute {\rm{dp}}(v, p_{1,j}, p_{i,1}) for each pair of i \in [a] and j \in [b].

Fig. 9
figure 9
The case (b) when the parent u is flipped

Full size image

For each i \in [a] and j \in [b], we define \omega (v, i, j) as the length of a longest s_vâ€“t_v path in G[v, p_{1,j}, p_{i,1}]. Then, by Lemma 4.1, we have

\begin{aligned} {\rm{dp}}(v, p_{1,j}, p_{i,1})&= \omega (v, i, j) + \kappa _v. \end{aligned}

Thus, after filling up the table \omega (v, \cdot , \cdot ), we can compute the values {\rm{dp}}(v, p_{1,j}, p_{i,1}) for all i \in [a] and j \in [b] in O(a \times b) = O(n^2) time in total. In what follows, we see how to compute \omega (v, i, j).

For the base case when i = j = 1, from the definitions of G[v, \cdot , \cdot ] and \lambda (s_v, \cdot ), we see

\begin{aligned} \omega (v, 1, 1)&= \lambda (s_v, p_{1,1}). \end{aligned}

(5.14)

Next, when i > 1 and j = 1, we can compute it by a recursive formula

\begin{aligned} \omega (v, i, 1)&= \max \left\{ \lambda (s_v, p_{i,1}) + \Vert p_{i,1}p_{1,1}\Vert ,\, \omega (v, i-1, 1)\right\} , \end{aligned}

(5.15)

which is confirmed as follows. Fix a longest s_vâ€“t_v path in G[v, p_{i,1}, p_{1,1}] attaining \omega (v, i, 1), and let \pi _v \in \varPi _P(v) be a corresponding M-path. If \pi _v intersects p_{i,1}, then it corresponds to a longest s_vâ€“p_{i,1} path in G[v, \epsilon , \epsilon ] of length \lambda (s_v, p_{i,1}) and the last segment p_{i,1}p_{1,1} contributes to the length in G[v, p_{1,1}, p_{i,1}] in addition. Otherwise, \pi _v is disjoint from p_{i,1}, and then it corresponds to a longest s_vâ€“t_v path in G[v, p_{i-1,1}, p_{1,1}] of length \omega (v, i-1, 1). The case when i = 1 and j > 1 is similarly computed by

\begin{aligned} \omega (v, 1, j)&= \max \left\{ \lambda (s_v, p_{1,j}) + \Vert p_{1,j}p_{1,1}\Vert ,\, \omega (v, 1, j-1)\right\} . \end{aligned}

(5.16)

Finally, when i > 1 and j > 1, we can compute it by a recursive formula

\begin{aligned} \omega (v, i, j)&= \max \left\{ \lambda (s_v, p_{i,j}) + \gamma (v, p_{i,j}, p_{1,1}),\, \omega (v, i-1, j), \, \omega (v, i, j-1)\right\} , \end{aligned}

(5.17)

where \gamma (v, p_{i,j}, p_{1,1}) = \max \left\{ d_x(p_{i,j}, p_{1,1}),\, d_y(p_{i,j}, p_{1,1})\right\} is similarly defined (cf. (3.1) and Lemma 3.1). This is because, for any M-path \pi _v \in \varPi _P(v), it intersects p_{i,j}, enters B(p_{i-1,j}, p_{1,1}) at some p_{h,j} (h \in [i-1]), or enters B(p_{i,j-1}, p_{1,1}) at some p_{i,k} (k \in [j-1]), and each case is analyzed as with the previous paragraph.

Since we only look up a constant number of values in (5.14)â€“(5.17), each value \omega (v, i, j) can be computed in constant time. As the table \omega (v, \cdot , \cdot ) is of size a\times b = O(n^2), the total computational time is O(n^2). Thus we are done.

Case (c): In-Out Pairs Move on Opposite Boundaries
By symmetry, we consider the situation when (p_v)_y = (t_v)_y and (q_v)_y = (s_v)_y for all possible in-out pairs (p_v, q_v) of \pi _u \in \varPi _P(u) for v. We then have (s_v)_x \le (s_u)_x < (t_u)_x \le (t_v)_x and (t_u)_y< (s_v)_y< (t_v)_y < (s_u)_y, and let p_{i,j} be the (i, j) vertex on the a \times b grid {\mathcal{H}}(P, v) \cap {\mathcal{H}}(P, u) for each i \in [a] and j \in [b], where we define p_{1,1} as the upper-right corner (see Fig. 10). In this case, we need to compute {\rm{dp}}(v, p_{1,j}, p_{a,k}) for each j, k \in [b] with j \ge k. Recall that, since u is flipped, any M-paths \pi _v \in \varPi _{P}(v) and \pi _u \in \varPi _{P}(u) can share either horizontal or vertical segments.

Fig. 10
figure 10
The case (c) when the parent u is flipped

Full size image

First, when j = k, as with the regular case (cf. (5.9)), we have

\begin{aligned} {\rm{dp}}(v, p_{1,j}, p_{a,j})&= {\rm{dp}}(v, p_{1,1}, p_{a,1})\nonumber \\&= \max _{1 \le h \le i \le a} \left( \lambda (s_v, p_{h,1}) + \lambda (p_{i,1}, t_v) + \Vert p_{h,1}p_{i,1}\Vert \right) \end{aligned}

(5.18)

because in this case \pi _u[v] consists of a single vertical segment p_{1,j}p_{a,j}.

When j > k, we consider two cases of sharing horizontal and vertical segments separately, and then take the maximum. In the vertical sharing case, the desired value is exactly {\rm{dp}}(v, p_{1,1}, p_{a,1}), because any horizontal segment in B(p_{1,j}, p_{a,k}) has no meaning. In the horizontal sharing case, the desired value is {\rm{dp}}(v, \epsilon , \epsilon ) + \Vert p_{1,k}p_{1,j}\Vert, because for any longest s_vâ€“t_v path in G[v, \epsilon , \epsilon ], we can take a corresponding M-path \pi _v \in \varPi _P(v) so that it goes through B(p_{1,j}, p_{a,k}) horizontally and then it can share the horizontal segment in addition with \pi _u \in \varPi _P(u) (with \pi _u[v] \in \varPi _P(p_{1,j}, p_{a,k})). Thus, we have

\begin{aligned} {\rm{dp}}(v, p_{1,j}, p_{a,k})&= \max \left\{ {\rm{dp}}(v, p_{1,1}, p_{a,1}),\, {\rm{dp}}(v, \epsilon , \epsilon ) + \Vert p_{1,k}p_{1,j}\Vert \right\} . \end{aligned}

(5.19)

The computation of {\rm{dp}}(v, p_{1,1}, p_{a,1}) requires O(a^2) = O(n^2) time by (5.18). After computing it, by (5.18) and (5.19), we can compute {\rm{dp}}(v, p_{1,j}, p_{a,k}) in constant time for each j, k \in [b] with j \ge k. As the table {\rm{dp}}(v, \cdot , \cdot ) is of size O(b^2) = O(n^2), the total computational time is O(n^2). Thus we are done.

Reduction of GMMN[Cycle] to GMMN[Tree]
In this section, we show that GMMN[Cycle] can be reduced to O(n) GMMN[Tree] instances. More generally, we describe a reduction for triangle-free pseudotree instances. The target problem is formally stated as follows, where we emphasize again that the triangle-freeness is crucial in our approach (cf. Sect. 2.3).

Problem
(GMMN[Pseudotree])

Input:
A set P\subseteq {\mathbb{R}}^2 \times {\mathbb{R}}^2 of n pairs whose intersection graph {\rm{IG}}[P] is a triangle-free pseudotree.

Goal:
Find an optimal network N = (\pi _v)_{v \in P} \in {\rm{Opt}}(P).

Let P be a GMMN[Pseudotree] instance. If {\rm{IG}}[P] is a tree, we do nothing for reduction. Suppose that {\rm{IG}}[P] has a (unique) cycle of length at least four. Let C \subseteq P be the subset of pairs consisting of the cycle. If C has a degenerate pair, we can cut the cycle by appropriately splitting the degenerate pair into two degenerate pairs which are not adjacent in the intersection graph. Therefore, we can assume that any pair in C is not degenerate.

We choose an arbitrary pair v = (s_v, t_v) \in C. Without loss of generality, we assume that v is regular and s_v is the lower-left corner of B(v). Suppose that {{\mathcal{H}}}(P, v) is an a \times b grid graph, where a and b are associated with the y- and x-coordinates, respectively. Note that a, b \ge 2 since v is nondegenerate. Let p_{i,j} denote the (i, j) vertex for i \in [a] and j \in [b], where p_{1,1} = s_v. For each i \in [a] and j \in [b], we define

\begin{aligned} {\mathcal{E}}^{\rm{hor}}(p_{i,j})&= {\left\{ \begin{array}{ll} \{(p_{i,j-1}, p_{i,j}, p_{i,j+1}), (p_{i-1,j}, p_{i,j}, p_{i,j+1})\} &{} (1< i,\ 1< j< b), \\ \{(p_{i,j-1}, p_{i,j}, p_{i,j+1})\} &{} (i = 1,\ 1< j< b), \\ \{(p_{i-1,j}, p_{i,j}, p_{i,j+1})\} &{} (1< i,\ j = 1), \\ \{(p_{i,j}, p_{i,j}, p_{i,j+1})\} &{} (i = j = 1), \\ \emptyset &{} (\text {otherwise, i.e., } j = b), \end{array}\right. } \\ {\mathcal{E}}^{\rm{vert}}(p_{i,j})&= {\left\{ \begin{array}{ll} \{(p_{i-1,j}, p_{i,j}, p_{i+1,j}), (p_{i,j-1}, p_{i,j}, p_{i+1,j})\} &{} (1< i< a,\ 1< j), \\ \{(p_{i-1,j}, p_{i,j}, p_{i+1,j})\} &{} (1< i< a,\ j = 1), \\ \{(p_{i,j-1}, p_{i,j}, p_{i+1,j})\} &{} (i = 1,\ 1 < j), \\ \{(p_{i,j}, p_{i,j}, p_{i+1,j})\} &{} (i = j = 1), \\ \emptyset &{} (\text {otherwise, i.e., } i = a). \end{array}\right. } \end{aligned}

Namely, each element of {\mathcal{E}}^{\rm{hor}}(p_{i,j}) is a triple representing a way for an M-path \pi _v \in \varPi _P(v) to go through an edge \{p_{i,j}, p_{i, j+1}\} of {{\mathcal{H}}}(P, v). Similarly, each element of {\mathcal{E}}^{\rm{vert}}(p_{i,j}) indicates a manner for \pi _v to go through \{p_{i,j}, p_{i+1,j}\}.

Let u_1 and u_2 be the neighbors of v in C. Then B(u_1) and B(u_2) can be separated by an axis-aligned line, without their boundaries (recall that they can share corner vertices). By symmetry, we assume that the line is vertical and B(u_1) is the left side. Take \alpha \in [a] and \beta \in [b] such that (p_{\alpha , \beta })_x is the x-coordinate of the right boundary of B(u_1) \cap B(v) and (p_{\alpha , \beta })_y is the minimum of the y-coordinates of the upper boundaries of B(u_1) \cap B(v) and B(u_2) \cap B(v) (see Fig. 11). If \alpha = a and \beta = b, i.e., p_{\alpha ,\beta } = t_v, the lower-right corner of B(u_1) and the upper-left corner of B(u_2) are t_v. In this case, we flip both the x- and y-axes so that p_{\alpha ,\beta } = s_v. Hence, we can assume that p_{\alpha ,\beta } \ne t_v.

Define

\begin{aligned} X^{\rm{hor}}&= \{p_{i, \beta } \mid i \in [\alpha ]\},\\ X^{\rm{vert}}&= \{p_{\alpha , j} \mid j \in [\beta ]\}. \end{aligned}

Then any M-path \pi _v is consistent with exactly one way in {\mathcal{E}}^{\rm{hor}}(q) for some q \in X^{\rm{hor}} or in {\mathcal{E}}^{\rm{vert}}(q) for some q \in X^{\rm{vert}}. We try every possibility and then adopt an optimal one.

Assume that \pi _v is consistent with (q^-, q, q^+) \in {\mathcal{E}}^{\rm{hor}}(q) for some q \in X^{\rm{hor}} or with (q^-, q, q^+) \in {\mathcal{E}}^{\rm{vert}}(q) for some q \in X^{\rm{vert}}, i.e., \pi _v goes through \{q^-, q\} and \{q, q^+\}. Then the minimum length of a network under this assumption is the same as {\tilde{N}} \in {\rm{Opt}}(\tilde{P}), where \tilde{P} = (P- v) \cup \{v_1, v_2, v_3, v_4\} with v_1 = (s_v, q^-), v_2 = (q^-, q), v_3 = (q, q^+), and v_4 = (q^+, t_v) (see Fig. 11 again). It is shown that {\rm{IG}}[\tilde{P}] has no cycles as follows.

Fig. 11
figure 11
Construction of \tilde{P} = (P- v) \cup \{v_1, v_2, v_3, v_4\}, where q \in X^{\rm{hor}} \cup X^{\rm{vert}} is on dotted lines

Full size image

Claim 6.1
{\rm{IG}}[\tilde{P}] is a forest.

Proof
Let \varGamma _v be the set of neighbors of v in {\rm{IG}}[P], excluding v itself. Then {\rm{IG}}[\varGamma _v] is edgeless as P is triangle-free. Put \tilde{\varGamma } = \varGamma _v \cup {\tilde{V}} with {\tilde{V}} = \{v_1, v_2, v_3, v_4\}. Then, for every v_k \in {\tilde{V}}, neighbors of v_k in {\rm{IG}}[\tilde{P}] are included in \varGamma _v by B(v_k) \subseteq B(v). In addition, for k \in \{2, 3\}, the graph {{\mathcal{H}}}(\tilde{P}, v_k) consists of a single edge in E({{\mathcal{H}}}(P, v)) or is a single vertex in V({{\mathcal{H}}}(P, v)). Therefore, there exists at most one pair w \in \varGamma _v such that B(w) intersects B(v_k). This means that the degree of v_2 and v_3 in {\rm{IG}}[\tilde{\varGamma }] is at most one, and hence they are not in any cycle in {\rm{IG}}[\tilde{P}].

Since the pairs in \varGamma _v are not adjacent to each other in {\rm{IG}}[P] and we have q^- \le q^+ and q^- \ne q^+ by definition, at most one pair in \varGamma _v can be adjacent to both v_1 and v_4 in {\rm{IG}}[{\tilde{\varGamma }}]. Thus {\rm{IG}}[{\tilde{\varGamma }}] is a forest. Then, if {\rm{IG}}[{\tilde{P}}] has a cycle, at least one of the following holds:

(C1)
\{u_1, v_1\}, \{v_1, u_2\} \in E({\rm{IG}}[\tilde{\varGamma }]),

(C2)
\{u_1, v_4\}, \{v_4, u_2\} \in E({\rm{IG}}[\tilde{\varGamma }]), or

(C3)
\{u_1, v_1\}, \{v_1, w\}, \{w, v_4\}, \{v_4, u_2\} \in E({\rm{IG}}[\tilde{\varGamma }]) for some w \in \varGamma _v \setminus \{u_1, u_2\}.

In what follows, we see that none of these is the case.

Let i, h_1, h_2, g_1, g_2 \in [a] and j, \gamma \in [b] such that q = p_{i,j}, the upper- and a lower-right corners of B(u_1) \cap B(v) are p_{h_1,\beta } and p_{g_1,\beta }, respectively, and the upper- and lower-left corners of B(u_2) \cap B(v) are p_{h_2,\gamma } and p_{g_2,\gamma }, respectively. Note that \alpha = \min \left\{ h_1, h_2\right\} and \beta \le \gamma.

We first consider the exceptional case when q = s_v \ (= p_{1,1}). Since {{\mathcal{H}}}(P, v_1) consists of the single vertex s_v, neither (C1) nor (C3) holds. If q^+ = p_{1,2}, then p_{1,1}\in X^{\rm{hor}} and \beta = 1, which implies B(u_1) \cap B(v_4) = \emptyset. Otherwise (i.e., q^+ = p_{2,1}), we have p_{1,1}\in X^{\rm{vert}}. This implies \min \left\{ h_1, h_2\right\} = \alpha = 1, and hence B(u_1) \cap B(v_4) = \emptyset or B(u_2) \cap B(v_4) = \emptyset. Thus (C2) does not hold, and we are done.

We next deal with the case when q \in X^{\rm{hor}} - s_v and (q^-, q, q^+) \in {\mathcal{E}}^{\rm{hor}}. By the definition of X^{\rm{hor}}, it holds j = \beta. Consider (C1). If \beta < \gamma, we have B(u_2) \cap B(v_1) = \emptyset, which negates (C1). Suppose that \beta = \gamma. Then it must holds h_1 \le g_2 or h_2 \le g_1 since otherwise B(u_1) intersect B(u_2). In the former case, we have \alpha = h_1 \le g_2 and thus B(v_1) does not intersect B(u_2). In the latter case, say \alpha = h_2 \le g_1 (see Fig. 12), it holds B(v_1) \cap B(u_2) = \emptyset if q^- = p_{i, \beta -1} and B(v_1) \cap B(u_1) = \emptyset if q^- = p_{i-1, \beta }. Therefore, (C1) does not hold for any case. We also have B(u_1) \cap B(v_4) = \emptyset by q_x \le q^+_x and q_x \ne q^+_x, which means that (C2) does not hold either.

Fig. 12
figure 12
An uneasy situation when B(u_1) and B(u_2) share their corners at q (i.e., \beta = \gamma = i and g_1 = h_2). a \pi _v \in \varPi _P(v) goes through q. b \pi _v \in \varPi _P(v) turns at q

Full size image

Suppose that there exists w \in \varGamma _v \setminus \{u_1, u_2\} satisfying the condition in (C3). If i < g_1, then B(v_1) does not intersect B(u_1), which contradicts \{u_1, v_1\} \in E({\rm{IG}}[\tilde{\varGamma }]). If i > g_1, then B(w) must intersect B(u_1), which also contradicts the assumption that P is triangle-free. Otherwise, i = g_1 (see Fig. 13). If q^- = p_{i, \beta -1}, then B(w) intersects B(u_1), a contradiction again. If q^- = p_{i-1, \beta }, the bounding box B(v_1) does not intersect B(u_1). Hence (C3) is not true for any case.

Fig. 13
figure 13
An uneasy situation when B(u_1) and B(w) for some w \in \varGamma _v \setminus \{u_1, u_2\} share their corners at q. a \pi _v \in \varPi _P(v) goes through q. b \pi _v \in \varPi _P(v) turns at q

Full size image

Finally, we consider the situation when q \in X^{\rm{vert}} - s_v and (q^-, q, q^+) \in {\mathcal{E}}^{\rm{vert}}. We have i = \alpha by the definition of X^{\rm{vert}}. If j < \beta, then (C1) does not hold because B(v_1) does not intersect B(u_2). Suppose that j = \beta, which means that q = p_{\alpha , \beta } \in X^{\rm{hor}} \cap X^{\rm{vert}}. Since the present v_1 is the same as that in the case of (q^-, q, p_{\alpha ,\beta +1}) \in {\mathcal{E}}^{\rm{hor}} if \beta < b, we have already proved that (C1) does not hold in the above horizontal case (cf. Fig. 12). It can be checked that the same proof is valid even if \beta = b. Thus (C1) does not hold in any case. In addition, since q_y \le q^+_y and q_y \ne q^+_y, we also have B(v_4) \cap B(u_k) = \emptyset if \alpha = h_k for k = 1, 2. Hence (C2) is not the case either.

Suppose that there exists w \in \varGamma _v \setminus \{u_1, u_2\} that satisfies (C3). As we have mentioned above, B(v_4) does not intersect B(u_2) if \alpha = h_2, which contradicts \{v_4, u_2\} \in E({\rm{IG}}[\tilde{\varGamma }]). Suppose that \alpha = h_1. Let \delta \in [b] such that p_{\alpha , \delta } is the upper-left corner of B(u_1) \cap B(v). If j < \delta, then B(v_1) does not intersect B(u_1), which contradicts \{u_1, v_1\} \in E({\rm{IG}}[\tilde{\varGamma }]). If j > \delta, then B(w) intersects B(u_1); this contradicts the assumption that P is triangle-free. Consider the remaining situation when j = \delta. If q^- = p_{\alpha -1, j}, then B(w) intersects B(u_1), a contradiction again. If q^- = p_{\alpha , j-1}, then B(v_1) does not intersect B(u_1). Therefore, (C3) does not hold in any case, and we are done. \square

From Claim 6.1, we have successfully reduced the GMMN[Pseudotree] instance P to O(n) instances of GMMN[Tree] each of which has n + 2 pairs.

Proposition 6.1
If GMMN[Tree] can be solved in T(n) time, then GMMN[Pseudotree] can be solved in O(n\cdot T(n+2)) time.

By combining Proposition 6.1 with Theorem 1.3, we obtain Corollary 1.1.

Notes
Precisely, a triangle itself is not a triangle-free pseudotree, but its size is trivially bounded by a constant. In contrast, the size of a pseudotree containing a triangle is unbounded, and it remains open whether such a case is tractable or not. See Sect. 2.3 for why the triangle-freeness is crucial in our approach.

We remark that our definition of the intersection graph is slightly different from Schnizlerâ€™s one [18], which regards two pairs as adjacent even when their bounding boxes share exactly one point. We employ our definition because M-paths for such pairs cannot share any nontrivial segment. This difference itself expands tractable situations, and sometimes requires more careful arguments due to shared points of nonadjacent pairs (in particular, the corners of their bounding boxes).

Note that p can be shared as corners of two different leaf pairs due to our definition of the intersection graph, and then leaving one bounding box means entering the other straightforwardly.

We may have p \in V_\llcorner \setminus {V_{{}^\bullet {}_\bullet }} and q \in {V_{{}^\bullet {}_\bullet }}, and then the original arc in G is already (p, q^{\rm{hor}}) or (p, q^{\rm{vert}}) of length d(p, q) = \Vert pq\Vert. Such an arc is replaced with two arcs (p, q^{\rm{hor}}) of length d_x(p, q) and (p, q^{\rm{vert}}) of length d_y(p, q).

If p_v or q_v (or both) can move on two boundaries of B(v), then we separately handle all possible cases, e.g., when (q_v)_x = (t_v)_x (i.e., q_v moves on the right boundary of B(v)) and when (q_v)_y = (t_v)_y (i.e., q_v moves on the upper boundary of B(v)).