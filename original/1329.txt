The Weighted Tree Augmentation problem (WTAP) is a fundamental problem in network design. In this paper, we consider this problem in the online setting. We are given an n-vertex tree 𝑇=(𝑉,𝐸) and an additional set 𝐿⊆(𝑉2) of edges (called links) with costs. Then, terminal pairs arrive one-by-one and our task is to maintain a low-cost subset of links F such that every terminal pair that has arrived so far is 2-edge-connected in 𝑇∪𝐹. This online problem was first studied by Gupta, Krishnaswamy and Ravi (SICOMP 2012) who used it as a subroutine for the online survivable network design problem. They gave a deterministic 𝑂(log2𝑛)-competitive algorithm and showed an 𝛺(log𝑛) lower bound on the competitive ratio of randomized algorithms. The case when T is a path is also interesting: it is exactly the online interval set cover problem, which also captures as a special case the parking permit problem studied by Meyerson (FOCS 2005). The contribution of this paper is to give tight results for online weighted tree and path augmentation problems. The main result of this work is a deterministic 𝑂(log𝑛)-competitive algorithm for online WTAP, which is tight up to constant factors.

Access provided by University of Auckland Library

Introduction
In the weighted tree augmentation problem (WTAP), we are given an n-vertex tree 𝑇=(𝑉,𝐸) together with an additional set of edges L called links, where 𝐿⊆(𝑉2). Each link ℓ∈𝐿 has a cost 𝑐(ℓ)≥0. Terminal pairs (𝑠𝑖,𝑡𝑖), 𝑖={1,…,𝑘}, are given and the goal is to compute a minimum cost subset of links 𝐹⊆𝐿 such that each terminal pair is (edge) 2-connected in 𝑇∪𝐹. In the unweighted version, the links have unit costs and the problem is known as the tree augmentation problem (TAP). If the tree T is a path, then the unweighted problem is called the path augmentation problem (PAP), while the weighted version is called weighted path augmentation (WPAP).

TAP and WTAP are considered to be fundamental connectivity augmentation problems, and have been studied extensively. TAP is already known to be APX-hard and the best approximation algorithms for WTAP and TAP achieve approximation ratios of 2 and 1.458 respectively [7, 9]. Improving these bounds is an important open problem.

We consider these problems in the online setting. In online WTAP, we are initially given a tree 𝑇=(𝑉,𝐸), and the set of links L together with their costs. The terminal pairs (𝑠𝑖,𝑡𝑖) arrive online one by one. Our goal is to maintain a low-cost subset of links 𝐹⊆𝐿 such that each terminal pair seen so far is (edge) 2-connected in 𝑇∪𝐹.

Online WTAP occurs as a subproblem in the online survivable network design algorithm of Gupta, Krishnaswamy and Ravi [10]. They observed that the online tree augmentation problem can be cast as an instance of the online set cover problemFootnote1 in which the elements are the fundamental cuts defined by the terminal pairs and the sets are the links. Since there are only n elements and 𝑂(𝑛2) sets, applying the results of Alon et al. [1] yields a fractional 𝑂(log𝑛)-competitive algorithm. But then, how does one round the fractional solution online? Randomized rounding seems to be the only rounding technique we have for this problem, and it yields a randomized 𝑂(log2𝑛)-competitive algorithm, as observed by [1]. This competitive factor can even be achieved deterministically at no further cost [1]. We note that the loss of a logarithmic factor in the rounding step seems inherent to the randomized rounding. Interestingly, Gupta, Krishnaswamy and Ravi [10] also showed for the rooted setting (𝑠𝑖=𝑟 for some root r) a lower bound of 𝛺(log𝑛) against randomized algorithms. It is easy to observe that this lower bound also holds against fractional online algorithms.

There has been a long line of work on maintaining connectivity online, starting with the seminal paper of Imase and Waxman [13]. A Θ(log𝑛)-competitive algorithm is given there for the online Steiner tree problem in undirected graphs. In this problem, the graph with a fixed root vertex is known in advance and the terminals are given one by one, and one must ensure that all terminals that have arrived so far are connected to the root. Other polylogarithmic (in n) competitive algorithms have been given for more complex models of connectivity, including those with node costs rather than edge costs and penalties for violating connectivity constraints; see [2,3,4, 11, 12, 17, 19, 21]. Gupta, Krishnaswamy, and Ravi [10] consider the online survivable network design problem, which generalizes WTAP. In this problem, a graph is fixed in advance and terminal pairs (𝑠𝑖,𝑡𝑖) arrive with connectivity requirements 𝑟𝑖; one must ensure that there are at least 𝑟𝑖 edge-disjoint paths between 𝑠𝑖 and 𝑡𝑖 for all pairs that have arrived thus far. They give a randomized 𝑂̃ (𝑟maxlog3𝑛)-competitive algorithm for the problem, where 𝑟max=max𝑖𝑟𝑖. (The 𝑂̃  notation hides loglog𝑛 factors.) Note that this problem with uniform requirements 𝑟𝑖=2 already generalizes WTAP.

The online WPAP, when T is a path, is an interesting problem in its own right. This problem is equivalent to online interval set coverFootnote2. It captures as a special case the parking permit problem introduced by Meyerson [16]. In this problem, there is a sequence of days; each day it is either sunny or it rains, and if it rains we must purchase a parking permit. Permits have various durations and costs. We can model the parking permit problem by online path augmentation by letting the edges of the path correspond to the sequence of days, the links to the permits, and the rainy days to a terminal pair request for the corresponding day. Meyerson [16] gives a deterministic 𝑂(log𝑛)-competitive algorithm for the problem and a randomized 𝑂(loglog𝑛)-competitive algorithm, and shows lower bounds on the competitive ratio of 𝛺(log𝑛/loglog𝑛) for deterministic algorithms and 𝛺(loglog𝑛) for randomized algorithms. Note that online WPAP is a strict generalization of the parking permit problem because the parking permit problem assumes that permits of the same duration have the same cost, whereas no such assumption is made of the links in WPAP.

Our Results
The contribution of this paper is to give tight results (within constant factors) for online tree and path augmentation problems. Our main result is that weighted online tree augmentation has a competitive ratio of Θ(log𝑛).

Theorem 1
There is a deterministic algorithm for online WTAP with competitive ratio 𝑂(log𝑛).

This result is tight up to constant factors because of the 𝛺(log𝑛) lower bound on randomized algorithms for WTAP given by [10]. As we mention above, [10] gives a randomized 𝑂̃ (𝑟maxlog3𝑛)-competitive algorithm for the online survivable network design problem. An intriguing open question is whether this competitive ratio can be improved, say to 𝑂(𝑟maxlog𝑛) or even 𝑂(log𝑛). In fact, we are unaware of lower bounds that rule out the latter bound. We view our main result as a necessary stepping stone towards obtaining an 𝑂(𝑟maxlog𝑛) or 𝑂(log𝑛) bound. Indeed, for 𝑟max=2, plugging in our algorithm for online WTAP into the algorithm of [10] improves their competitive ratio from 𝑂̃ (log3𝑛) to 𝑂̃ (log2𝑛).

Corollary 1
For online survivable network design with 𝑟max=2, there is a randomized algorithm with competitive ratio 𝑂̃ (log2𝑛).

Our second result shows that the competitive ratio for deterministic algorithms for online path augmentation is also Θ(log𝑛). Meyerson [16] gives a lower bound of 𝛺(log𝑛/loglog𝑛) for deterministic algorithms for the parking permit problem, and hence for online path augmentation. We improve the analysis of his lower bound instance to show the following.

Theorem 2
Every deterministic algorithm for online WPAP has competitive ratio 𝛺(log𝑛).

Since we use a parking permit instance to show the lower bound, we have the same lower bound for the parking permit problem.

Finally, we show that the fractional version of online path augmentation has competitive ratio Θ(loglog𝑛) for deterministic algorithms. In the fractional version of the problem, the algorithm is allowed to buy each edge to a fractional extent; see Sect. 6 for a formal definition. Fractional algorithms are interesting as they are related to randomized algorithms. On the one hand, a randomized algorithm can be converted into a deterministic fractional algorithm of the same cost: the fractional algorithm buys each edge e to an extent equal to the probability that the randomized algorithm buys it. On the other hand, a fractional algorithm can sometimes be converted into a randomized algorithm by applying randomized rounding on the fractional solution. We show the following.

Theorem 3
There is a deterministic algorithm for online fractional WPAP with competitive ratio 𝑂(loglog𝑛).

This is asymptotically tight as Meyerson [16] gives a lower bound of 𝛺(loglog𝑛) for randomized algorithms for the parking permit problem, and hence for online fractional path augmentation. Theorem 3 also implies an exponential gap between the competitive ratios of fractional path augmentation and fractional tree augmentation.

Recall that online WPAP is equivalent to online interval set cover. Thus, Theorems 1 and 3 imply that restricting online set cover to interval sets allows for improved competitive ratios. Also, even though interval set cover and interval hitting set are equivalent in the offline case, it turns out that there is an exponential gap between the competitive ratios of the two problems in the online case; in contrast to Theorem 3, Even and Smorodinsky [6] gave a lower bound of 𝛺(log𝑛) for online fractional hitting set.

Our Techniques
We now outline some of the ideas behind our algorithms.

Online WTAP As mentioned before, there is an online fractional 𝑂(log𝑛)-competitive algorithm for WTAP that follows from the work of [1] on the online set cover problem. However, it is unclear how to exploit the special structure of the set system in hand in WTAP (as defined by the links) to avoid the loss of another factor of 𝑂(log𝑛) when rounding the fractional solution into an integral one (either randomized or deterministic). Thus, our approach to proving Theorem 1 takes a completely different route. There are two key ingredients in our proof:

1.
Low-width path decomposition. The first ingredient is a path decomposition of low “width”: in particular, there is a decomposition of the tree into edge-disjoint paths such that any path in the tree intersects at most 𝑂(log𝑛) paths of the decomposition. Such a decomposition can be obtained using the heavy-path decomposition of Sleator and Tarjan [20]. This immediately implies an 𝑂(log𝑛)-approximate black-box reduction from online tree augmentation to online path augmentation. Unfortunately, Theorem 2 gives a lower bound of 𝛺(log𝑛) for the latter problem. Since a tree may have width 𝛺(log𝑛) in the worst case (e.g., a binary tree), the best we can achieve for WTAP using a black-box reduction is a competitive ratio of 𝑂(log2𝑛).

2.
Refined guarantee for path augmentation. The second ingredient is our main technical contribution. We define a notion of projection for links onto paths in the path decomposition, and call the projected link rooted if it has the node of the path closest to the root of the tree as an endpoint. The key insight is that the path decomposition has a special structure: for each link, its projection is rooted for all but at most one of the paths in the decomposition. We then use linear programming to give a version of the path algorithm that treats rooted links differently from non-rooted links; in particular, an online path augmentation algorithm that finds a solution whose cost is within a constant factor of the rooted links of the optimal solution plus an 𝑂(log𝑛) factor of the cost of the non-rooted links. Intuitively, then, summing the cost over all the paths in the decomposition, each link appears as a rooted link in at most 𝑂(log𝑛) paths in the decomposition and as a non-rooted link in at most one path in the decomposition, yielding the 𝑂(log𝑛) factor overall.

Online Fractional WPAP Directly applying the online fractional set cover algorithm of [1] to online fractional WPAP only yields a competitive ratio of 𝑂(log𝑛). However, for online set cover instances in which each element is covered by at most d sets, the algorithm of [1] is 𝑂(log𝑑)-competitive. Thus, to get a competitive ratio of 𝑂(loglog𝑛), the basic idea is to reduce to a restricted instance in which each request can only be covered by 𝑂(log𝑛) links. For such restricted instances, applying the algorithm of [1] gives a competitive ratio of 𝑂(loglog𝑛).

Other Related Work
Dehghani et al. [5] studied online survivable network design, giving a bicriteria approximation algorithm, and considered several stochastic settings.

Organization of the Paper
We start with the preliminaries and describe the low-width path decomposition in Sect. 2. In Sect. 3, we present the refined guarantee needed for online path augmentation. Then, we show how to achieve the required refined guarantee in Sect. 4. Next, we turn to the WPAP. In Sect. 5, we give a lower bound for WPAP against deterministic algorithms. In Sect. 6, we give a fractional algorithm for WPAP. We conclude the paper with open problems in Sect. 7.

Preliminaries
We restate the formal definition of the problem. In the online weighted tree augmentation problem, we are initially given a tree 𝑇=(𝑉,𝐸), and an additional set of edges called links 𝐿⊆(𝑉2) with costs 𝑐(ℓ)≥0. Then, terminal pairs (𝑠𝑖,𝑡𝑖) arrive one by one. Our goal is to maintain a low-cost subset of links 𝐹⊆𝐿 such that each terminal pair seen so far is 2-connected in 𝑇∪𝐹.

Notation Denote by P(u, v) the path between u and v in T. For a link ℓ=(𝑢,𝑣), we write 𝑃(ℓ)=𝑃(𝑢,𝑣) and for a set S of links, we write 𝑃(𝑆)=⋃ℓ∈𝑆𝑃(ℓ). We say that a link ℓ∈𝐿 covers an edge 𝑒∈𝐸 if 𝑒∈𝑃(ℓ). Define cov(𝑒)={ℓ∈𝐿:𝑒∈𝑃(ℓ)} to be the set of links covering e. Note that cov(𝑒) is exactly the set of links crossing the cut induced by the tree edge e. See Fig. 1 for an illustration.

Fig. 1
figure 1
This figure illustrates the definitions in the Notation paragraph of Sect. 2. In this example, the tree consist of the solid edges. The link (u, v) is represented by a dashed edge and its path P(u, v) consist of the solid blue edges. The link (u, v) covers the tree edge e and thus belongs to cov(𝑒)

Full size image
Simplifying assumptions In the rest of this paper, we assume that link costs are powers of 2; this assumption is without loss of generality since we can round up all link costs and lose only a factor of 2 in the competitive ratio. Given that link costs are powers of 2, we say that the class of a link ℓ is j if 𝑐(ℓ)=2𝑗 and we write class(ℓ)=𝑗.

Given an instance in which link costs are powers of 2, we also assume that requests are elementary: each request (𝑠𝑖,𝑡𝑖) is a tree edge 𝑒∈𝐸. This is without loss of generality because an adversary can simulate a non-elementary request (𝑠𝑖,𝑡𝑖) by a sequence of requests, one per edge along the path between 𝑠𝑖 and 𝑡𝑖; this only makes the problem harder as the algorithm has to cover part of the path before seeing the full set of requests on the path. The benefit of an instance consisting only of elementary requests is that it admits the following characterization of feasible solutions. Let 𝑅⊆𝐸 be a set of elementary requests. Then, a solution F is feasible if and only if for every edge 𝑒∈𝑅, we have |𝐹∩cov(𝑒)|≥1; or equivalently, if 𝑃(𝐹)⊇𝑅.

Path decomposition We next define a rooted path decomposition.

Definition 1
(Rooted Path Decomposition) Let T be a tree. A path decomposition of T is a partition  of its edge set into edge-disjoint paths. We say  is rooted if there is a vertex 𝑟∈𝑇 such that if we root T at r, then for each path 𝑝∈, the least common ancestor of the vertices on p is an endpoint of the path (we call this endpoint the root of p). The width of  is width()=max𝑢,𝑣∈𝑉(𝑇)|{𝑝∈:𝑃(𝑢,𝑣)∩𝑝≠∅}|, the maximum number of paths 𝑝∈ that any path in T intersects. See Fig. 2 for an illustration.

Lemma 1
(Low Width Rooted Path Decompositions [20]) Every tree on n vertices admits a rooted path decomposition of width 𝑂(log𝑛).

An 𝑂(log𝑛)-width rooted path decomposition can be obtained using the so-called heavy path decomposition of Sleator and Tarjan [20]. For the sake of completeness, we give a proof here. The following notion of a caterpillar decomposition will be convenient.

Definition 2
(Caterpillar Decomposition) Let T be a rooted tree on n vertices. A caterpillar decomposition of T is a vertex-disjoint decomposition of T into a root-to-leaf path B (called the backbone) and subtrees 𝑇𝑖 that are connected to B. The decomposition is balanced if for each subtree 𝑇𝑖, we have |𝑉(𝑇𝑖)|≤𝑛/2.

Lemma 2
Every tree admits a balanced caterpillar decomposition.

Proof
The existence of a balanced caterpillar decomposition is an easy consequence of the well-known fact [14] that every tree T has a balanced vertex separator v, i.e. after removing v from T, each of the remaining connected components has at most n/2 vertices. The following is a balanced caterpillar decomposition of T: pick an arbitrary root-to-leaf path containing v to be the backbone B, and the subtrees 𝑇𝑖 to be the connected components of T after removing B. ◻

Fig. 2
figure 2
Example of a tree and a rooted path decomposition consisting of four paths: 𝑃1,𝑃2,𝑃3,𝑃4. The edge colors reflect the partition of the edges. The root of each path is the highest vertex of the path. The width of the decomposition is 4 as the path between u and v intersects all four paths of the decomposition

Full size image
Lemma 1 now easily follows by choosing an arbitrary root vertex of T and recursively applying Lemma 2.

Refined Guarantee for Online Path Augmentation
As already mentioned, Lemma 1 implies an 𝑂(log𝑛)-approximate black-box reduction to online path augmentation: given an 𝛼-competitive algorithm for online path augmentation, we have an 𝑂(𝛼log𝑛)-competitive algorithm for online tree augmentation. However, Theorem 2 says that 𝛼=𝛺(log𝑛) for deterministic algorithms. To get around this lower bound, instead of using a black box reduction, we will use Lemma 1 in conjunction with a more refined guarantee for online path augmentation.

We need some notation to describe this refined guarantee. Suppose  is a rooted path decomposition of T and 𝑄∈ be a path in the decomposition. For a link ℓ that shares at least one edge with Q, define 𝜋𝑄(ℓ) to be the link whose endpoints are endpoints of the path 𝑃(ℓ)∩𝑄; we call 𝜋𝑄(ℓ) the projection of ℓ onto Q. We say that ℓ is Q-rooted if one of the endpoints of 𝜋𝑄(ℓ) is the root of Q, and Q-non-rooted otherwise. (See Fig. 3 for an illustration.) For brevity, we simply say that a link is rooted or non-rooted when Q is implied by the context. The main ingredient for the refined guarantee is the next lemma.

Fig. 3
figure 3
Illustration of the projections of the link (u, v) (represented as a dashed line in the figure on the right) onto the paths of the decomposition. Only the projection onto 𝑃3 (consisting of the path between x and y) is non-rooted

Full size image
Lemma 3
Consider a tree T and link ℓ=(𝑢,𝑣). Suppose  is a rooted path decomposition of T. Then, there is at most one path 𝑄∈ for which ℓ is Q-non-rooted.

Proof
Let w be the least common ancestor of u and v. If ℓ is Q-non-rooted, then w lies in Q but is not the root of Q. Since a vertex only appears in multiple paths in  if it is the root of all but at most one of them, there is at most one 𝑄∈ containing w as a non-root vertex, giving the lemma. ◻

Motivated by Lemma 3, we define the online rooted path augmentation problem. An instance of online rooted path augmentation consists of a rooted path Q where the root r is an endpoint of Q. For such an instance, we say that a link is rooted if one of its endpoints is r. Lemma 3 suggests that we should devise an algorithm for online rooted path augmentation with the following refined guarantee.

Definition 3
(Nice Solution) A solution F for an instance of online rooted path augmentation is nice if for any feasible solution 𝐹∗, we have 𝑐(𝐹)≤𝑂(1)𝑐(𝑅∗)+𝑂(log𝑛)𝑐(𝑆∗) where 𝑅∗ is the set of rooted links and 𝑆∗ is the set of non-rooted links of 𝐹∗, respectively. An algorithm is nice if it always produces a nice solution.

Lemma 4
Suppose that there exists a deterministic nice algorithm 𝖯𝖺𝗍𝗁-𝖠𝖫𝖦 for online rooted path augmentation. Then, there exists an 𝑂(log𝑛)-competitive deterministic algorithm for online tree augmentation.

Proof
Here is our algorithm for general instances. Consider a general instance of online weighted tree augmentation with tree 𝑇=(𝑉,𝐸), requests 𝑒1,…,𝑒𝑘⊆𝐸 and links 𝐿=(𝑉2) with costs 𝑐(ℓ). Our algorithm works as follows. By Lemma 1, there exists a rooted path decomposition  of T with width 𝑤=𝑂(log𝑛). Now, each rooted path 𝑄∈ defines an instance of online rooted path augmentation: the links are 𝐿𝑄={𝜋𝑄(ℓ):ℓ∈𝐿} where 𝜋𝑄(ℓ) has cost 𝑐(ℓ), and the sequence of requests is exactly the subsequence of requests that lie on Q. So, our algorithm runs in parallel || instantiations of 𝖯𝖺𝗍𝗁-𝖠𝖫𝖦, one per rooted path 𝑄∈. When request 𝑒𝑖 arrives, if 𝑒𝑖∈𝑄 (since 𝑒𝑖 is an elementary request, it must lie on some path of ), then our algorithm uses the instantiation of 𝖯𝖺𝗍𝗁-𝖠𝖫𝖦 on Q to handle that request; in particular, if 𝖯𝖺𝗍𝗁-𝖠𝖫𝖦 buys the projected link 𝜋𝑄(ℓ), then our algorithm buys the link ℓ.

Let us now analyze the competitive ratio of this algorithm. Let 𝐹∗ be a feasible solution. For 𝑄∈, we denote by 𝑅∗𝑄, and 𝑆∗𝑄 the subset of 𝐹∗ which is Q-rooted, and Q-non-rooted, respectively. Since 𝖯𝖺𝗍𝗁-𝖠𝖫𝖦 is nice, we have that our algorithm’s solution F has cost

𝑐(𝐹)≤∑𝑄∈[𝑂(1)𝑐(𝑅∗𝑄)+𝑂(log𝑛)𝑐(𝑆∗𝑄)]≤𝑂(log𝑛)𝑐(𝐹∗),
where the last inequality is because Lemma 3 implies that each link of 𝐹∗ is in 𝑆∗𝑄 for at most one 𝑄∈ and is in 𝑅∗𝑄 for at most 𝑤=𝑂(log𝑛) paths 𝑄∈. ◻

In the next section, we construct a nice deterministic algorithm. Together with Lemma 4 this gives a deterministic 𝑂(log𝑛)-competitive algorithm for online tree augmentation, thus proving Theorem 1.

A Nice Algorithm for Online Path Augmentation
In this section, we devise a nice algorithm for online rooted path augmentation. In the following, we use the convention that the root of the path is the left endpoint of the path.

We begin by showing in Sect. 4.1 that it suffices to consider simpler instances that we call minimal instances. Then, we describe in Sect. 4.2 how to prove niceness using an LP for the problem. Finally, we describe and analyze the algorithm in Sects. 4.3 and 4.4.

Minimal Instances
The first step is a preprocessing step that simplifies the structure of the link set. In particular, before any requests arrive, we prune the set of links so that it is of the following type.

Definition 4
(Minimal Instances) A set of links L and its costs c are minimal if they satisfy the following properties:

1. for each class j,

there is at most one rooted link of cost within class j and

for every edge e, there are at most two links ℓ of class j with 𝑒∈𝑃(ℓ);

2. for any two rooted links ℓ and ℓ′, if class(ℓ)>class(ℓ′), then 𝑃(ℓ)⊋𝑃(ℓ′).

An instance is minimal if its links and costs are minimal.

For a subset of links 𝐿′⊆𝐿, we say that a solution 𝐹⊆𝐿′ is nice for 𝐿′ if for any feasible solution 𝐹′⊆𝐿′, we have 𝑐(𝐹)≤𝑂(1)𝑐(𝑅′)+𝑂(log𝑛)𝑐(𝑆′) where 𝑅′ is the set of rooted links and 𝑆′ is the set of non-rooted links of 𝐹′, respectively. The following lemma says that if suffices to design a nice algorithm for a subset 𝐿′ that is minimal.

Lemma 5
For any set of links L and its costs c, there is an efficiently computable subset 𝐿′⊆𝐿 that is:

1.
Minimal;

2.
For any set of requests, the optimal solution restricted to 𝐿′ costs at most 3 times the optimal solution using L; and

3.
Any solution that is nice for 𝐿′ is also nice for L.

We now describe a pruning algorithm to compute 𝐿′. Given a set of links L and its costs c, we prune L to get a minimal subset of links 𝐿′⊆𝐿 as follows. We begin by pruning the rooted links: while there exists a rooted link ℓ and a rooted link ℓ′ of the same or lower class such that 𝑃(ℓ′)⊇𝑃(ℓ), remove ℓ. Then we prune the non-rooted links for each class j: let 𝐿𝑗 be the set of class j links and 𝐿′𝑗 be a minimum-cardinality subset of 𝐿𝑗 that covers 𝐿𝑗, i.e. 𝑃(𝐿′𝑗)⊇𝑃(𝐿𝑗); then, remove the links 𝐿𝑗∖𝐿′𝑗. Such a minimum cover may be computed efficiently using an algorithm for minimum cardinality interval cover [8]. The subset 𝐿′ are the links that are not pruned away by the algorithm.

By construction, 𝐿′ is minimal. We now turn to proving that it satisfies the other two properties claimed in Lemma 5. By minimality, we have that for any edge e, there are at most two links ℓ,ℓ′∈𝐿′𝑗 such that 𝑒∈𝑃(ℓ)∩𝑃(ℓ′). The following claim shows that any link ℓ∈𝐿𝑗 that was pruned away can be replaced by at most three links of 𝐿′𝑗 and so restricting to 𝐿′ only causes the value of the optimal solution to increase by at most a factor of 3.

Claim 1
For every j and link ℓ∈𝐿𝑗∖𝐿′𝑗, there exists (at most) three links ℓ1,ℓ2,ℓ3∈𝐿′𝑗 with 𝑃(ℓ)⊆𝑃(ℓ1)∪𝑃(ℓ2)∪𝑃(ℓ3).

Proof
Suppose, towards a contradiction, that there exists a link ℓ∈𝐿𝑗∖𝐿′𝑗 whose path 𝑃(ℓ) can only be covered by at least four links of 𝐿′𝑗. Let 𝑆⊆𝐿′𝑗 be a minimum-size cover of 𝑃(ℓ) and let ℓ1 be the link of S whose left endpoint is leftmost and ℓ2 be the link of S whose right endpoint is rightmost. Consider a link ℓ′∈𝑆∖{ℓ1,ℓ2}⊆𝐿′𝑗. By minimality of 𝐿′𝑗, we get that 𝑃(ℓ′) is neither a subset of 𝑃(ℓ1) nor 𝑃(ℓ2). Thus, if 𝑃(ℓ′) is not a subset of 𝑃(ℓ), then we can discard either ℓ1 or ℓ2 from S to get a smaller cover of 𝑃(ℓ). However, since S is a minimum-size cover of 𝑃(ℓ), we get that 𝑃(ℓ′) is a subset of 𝑃(ℓ). So we have that the path of every link ℓ′∈𝑆∖{ℓ1,ℓ2} is contained in 𝑃(ℓ).

Combining the above observation with the assumption that |𝑆|≥4, this implies that swapping out 𝑆∖{ℓ1,ℓ2} from 𝐿′𝑗 and replacing it with ℓ gives a smaller cover of 𝑃(𝐿𝑗). However, this contradicts the fact that 𝐿′𝑗 is a minimum cover of 𝑃(𝐿𝑗). ◻

Claim 2
Any solution that is nice for 𝐿′ is also nice for L.

Proof
Suppose 𝐹∗⊆𝐿 is a feasible solution. Let 𝑅∗⊆𝐹∗ be its set of rooted links and 𝑆∗⊆𝐹∗ be its set of non-rooted links. We now find a rooted link ℓ𝑟∈𝐿′ and a set of non-rooted links 𝑆′⊆𝐿′ such that 𝐹′=𝑆′∪{ℓ𝑟} is feasible and moreover, 𝑐(ℓ𝑟)≤𝑂(1)𝑐(𝑅∗) and 𝑐(𝑆′)≤𝑂(1)𝑐(𝑆∗). Let ℓ∈𝑅∗ be the link in 𝑅∗ whose right endpoint is furthest from the root r. If ℓ∈𝐿′, then we set ℓ𝑟=ℓ. Otherwise, by construction, there exists a rooted link ℓ′∈𝐿′ of no higher class than ℓ and 𝑃(ℓ′)⊇𝑃(ℓ); then we set ℓ𝑟=ℓ′. Observe that in both cases, 𝑃(ℓ𝑟)⊇𝑃(𝑅∗) and that 𝑐(ℓ𝑟)≤𝑐(𝑅∗). We now proceed with the construction of 𝑆′. We construct 𝑆′ iteratively, starting with 𝑆′=∅. Then, for each class j, we iterate over each class-j link ℓ∈𝑆∗: if ℓ∈𝐿′𝑗, then we add ℓ to 𝑆′ as well; otherwise, we add to 𝑆′ the (at most) three links guaranteed by Claim 1ℓ1,ℓ2,ℓ3∈𝐿′𝑗 with 𝑃(ℓ)⊆𝑃(ℓ1)∪𝑃(ℓ2)∪𝑃(ℓ3). Observe that 𝑃(𝑆′)⊇𝑃(𝑆∗) and 𝑐(𝑆′)≤3𝑐(𝑆∗). Since 𝑃(𝑆′∪{ℓ𝑟})⊇𝑃(𝐹∗), we get that 𝐹′ is feasible.

Finally, a solution F that is nice for 𝐿′ satisfies

𝑐(𝐹)≤𝑂(1)𝑐({ℓ𝑟})+𝑂(log𝑛)𝑐(𝑆′)≤𝑂(1)𝑐(𝑅∗)+𝑂(log𝑛)𝑐(𝑆∗),
and so it is also nice for L. ◻

This completes the proof of Lemma 5. Henceforth, we focus on devising a nice algorithm for minimal instances.

Proving Niceness via the Dual LP
Our algorithm uses the natural LP formulation of the problem. Let  be the set of requests. The following are the primal and dual LPs, respectively.

 minimize  subject  to ∑ℓ∈𝐿𝑥(ℓ)𝑐(ℓ)∑ℓ∈cov(𝑒)𝑥(ℓ)≥1𝑥(ℓ)≥0∀𝑒∈∀ℓ∈𝐿
(1)
 maximize  subject  to ∑𝑒∈𝑦(𝑒)∑𝑒∈𝑃(ℓ)𝑦(𝑒)≤𝑐(ℓ)𝑦(𝑒)≥0∀ℓ∈𝐿∀𝑒∈
(2)
We say that a link ℓ is tight with respect to a dual solution y if ∑𝑒∈𝑃(ℓ)𝑦(𝑒)=𝑐(ℓ).

The following lemma tells us how to use a dual solution y to prove that a primal solution F is nice. It says that F is nice if there is a dual solution y such that the cost of F is at most O(1) times the value of y, and if y violates the dual constraint for each non-rooted link by at most a factor of 𝑂(log𝑛) and the dual constraint for each rooted link by at most a factor of O(1). Intuitively, for any feasible solution 𝐹∗, the dual violation conditions lets us charge the value of the dual to 𝑂(log𝑛) times the cost of the non-rooted links in 𝐹∗ and O(1) times the cost of the rooted links in 𝐹∗.

Lemma 6
Let F be an integral solution to the primal LP and y be a solution to the dual LP such that

1.
𝑐(𝐹)≤𝑂(1)∑𝑒𝑦(𝑒),

2.
∑𝑒∈𝑃(ℓ)𝑦(𝑒)≤𝑂(log𝑛)𝑐(ℓ) for every non-rooted link ℓ, and

3.
∑𝑒∈𝑃(ℓ)𝑦(𝑒)≤𝑂(1)𝑐(ℓ) for every rooted link ℓ.

Then, F is a nice solution.

Proof
Let 𝐹∗ be a feasible solution, 𝑅∗ be the subset of 𝐹∗ that is rooted and 𝑆∗ the subset that is non-rooted. We now show that ∑𝑒𝑦(𝑒)≤𝑂(1)𝑐(𝑅∗)+𝑂(log𝑛)𝑐(𝑆∗), which then implies that 𝑐(𝐹)≤𝑂(1)𝑐(𝑅∗)+𝑂(log𝑛)𝑐(𝑆∗). Since we have a dual variable y(e) for each request e and 𝐹∗ is feasible, we have that

∑𝑒𝑦(𝑒)≤∑𝑒∈𝑃(𝑅∗)𝑦(𝑒)+∑𝑒∈𝑃(𝑆∗)𝑦(𝑒).
Using the fact that ∑𝑒∈𝑃(ℓ)𝑦(𝑒)≤𝑂(1)𝑐(ℓ) for every rooted link ℓ, we also have

∑𝑒∈𝑃(𝑅∗)𝑦(𝑒)≤∑ℓ∈𝑅∗∑𝑒∈𝑃(ℓ)𝑦(𝑒)≤𝑂(1)𝑐(𝑅∗).
Similarly, we get that ∑𝑒∈𝑃(𝑆∗)𝑦(𝑒)≤𝑂(log𝑛)𝑐(𝑆∗). Putting all of these together, we conclude that ∑𝑒𝑦(𝑒)≤𝑂(1)𝑐(𝑅∗)+𝑂(log𝑛)𝑐(𝑆∗), as desired. ◻

Algorithm
We now give some of the ideas behind our algorithm.

An 𝑂(log𝑛)-competitive algorithm First, we describe a simple algorithm that constructs a solution F and a dual solution y that satisfies 𝑐(𝐹)≤𝑂(1)∑𝑒𝑦(𝑒) and ∑𝑒∈𝑃(ℓ)𝑦(𝑒)≤𝑂(log𝑛)𝑐(ℓ) for every link ℓ. The algorithm maintains a maximal feasible dual solution y and is as follows: when a request 𝑒𝑖 arrives, raise its dual variable 𝑦(𝑒𝑖) until some link ℓ with 𝑒𝑖∈𝑃(ℓ) goes tight; add this link to F. There are two parts to the analysis. First, let 𝐹ˆ be the set of links in F that cost at least maxℓ∈𝐹𝑐(ℓ)/𝑛2. Since |𝐹|≤𝑛2, we get that 𝑐(𝐹)≤2𝑐(𝐹ˆ) so it suffices to bound 𝑐(𝐹ˆ). The second part of the analysis uses the following charging argument to bound 𝑐(𝐹ˆ): whenever we add a tight link ℓ to 𝐹ˆ, we charge its cost to the dual variables y(e) for 𝑒∈𝑃(ℓ). Let 𝜆(𝑒) be the total number of links charged to y(e) and 𝑦ˆ be the dual solution where 𝑦ˆ(𝑒)=𝜆(𝑒)𝑦(𝑒). We have 𝑐(𝐹ˆ)≤𝑂(1)∑𝑒𝜆(𝑒)𝑦(𝑒). Now observe that 𝜆(𝑒)≤𝑂(log𝑛) because Property 1 of minimal instances implies that there can be at most 2 links ℓ∈𝐹ˆ with 𝑒∈𝑃(ℓ) for a single cost class, and, by definition, 𝐹ˆ can have at most 𝑂(log𝑛) cost classes. So, for each link ℓ, we have

∑𝑒∈𝑃(ℓ)𝜆(𝑒)𝑦(𝑒)≤𝑂(log𝑛)∑𝑒∈𝑃(ℓ)𝑦(𝑒)≤𝑂(log𝑛)𝑐(ℓ)
where the last inequality follows from the fact that y is feasible.

Saving the rooted links A natural idea to ensure that ∑𝑒∈𝑃(ℓ)𝜆(𝑒)𝑦(𝑒)≤𝑂(1)𝑐(ℓ) for each rooted link ℓ is to modify the above algorithm to explicitly take into account the charging method as follows: after buying a tight link (we call this a type-1 link), if there is a rooted link ℓ′ such that ∑𝑒∈𝑃(ℓ′)𝜆(𝑒)𝑦(𝑒)>𝑐(ℓ′), buy the one of highest class among such links (we call this a type-2 link). Moreover, we also modify the charging method to only charge each type-1 link ℓ to the dual variables y(e) for 𝑒∉𝑃(ℓ′) where ℓ′ is the last type-2 link bought.

As we will see, these modifications let us to argue that ∑𝑒∈𝑃(ℓ)𝜆(𝑒)𝑦(𝑒)≤𝑂(1)𝑐(ℓ) for each rooted link ℓ. However, it also introduces a complication: it might be possible that for some type-1 link ℓ, most of the dual variables y(e) paying towards its cost have 𝑒∈𝑃(ℓ′) where ℓ′ is the last type-2 link bought. Since the charging method only charges to dual variables y(e) for 𝑒∉𝑃(ℓ′), this would mean that it might charge an amount that is much less than the cost of ℓ′.

Fixing the complication To fix the above issue, whenever we buy a type-2 link ℓ′, we also buy all links ℓ″ of class at most class(ℓ′) that crosses ℓ′, i.e. ∅⊊𝑃(ℓ″)∩𝑃(ℓ′)⊊𝑃(ℓ′). Property 1 implies that the total cost of these links is at most 𝑂(1)𝑐(ℓ′). We call these links type-3 links. This ensures that later on, when we buy a type-1 link ℓ, if 𝑃(ℓ)∩𝑃(ℓ′)≠∅, then ℓ must be of higher class than ℓ′ and thus most of its cost is paid for by dual variables y(e) for 𝑒∉𝑃(ℓ′).

We describe the complete algorithm formally in Algorithm 1. In Algorithm 1, we use Z to keep track of 𝑃(ℓ) where ℓ is the last type-2 link bought so far (𝑍=∅ if no type-2 link is bought yet). The links bought in Step 4, 9, 11, are type-1, type-2, and type-3 links, respectively.

Analysis of Algorithm
We now prove that Algorithm 1 is nice. Let 𝐹1,𝐹2,𝐹3⊆𝐹 be the sets of type-1, type-2 and type-3 links, respectively. The proof consists of three steps. First, we show that 𝑐(𝐹)≤𝑂(1)𝑐(𝐹1) (Lemma 7) and thus it suffices to bound the cost of type-1 links. Then, we construct a dual solution 𝑦ˆ that accounts for the cost of type-1 links (Lemma 8). This shows that 𝑦ˆ satisfies the first condition of Lemma 6. Finally, Lemmas 10 and 9 show that 𝑦ˆ satisfies the remaining conditions of Lemma 6.

figure a
For each type-1 link ℓ∈𝐹1, define 𝐶(ℓ) to be the set of edges e such that 𝜆(𝑒) was incremented during the iteration that ℓ was assigned to 𝐹1, i.e. each dual variable y(e) for 𝑒∈𝐶(ℓ) contributes towards paying 𝑐(ℓ). Observe that 𝜆(𝑒)=|{ℓ:𝑒∈𝐶(ℓ)}| and 𝐶(ℓ)⊆𝑃(ℓ).

Proposition 1
Algorithm 1 satisfies the following properties. Let 𝑍𝑖 and 𝜆𝑖 denote Z and 𝜆 at the end of the i-th iteration. Then, for every iteration i, we have

1.
𝑍𝑖⊇𝑍𝑖−1;

2.
If 𝑦(𝑒𝑖)>0, then 𝜆𝑖(𝑒𝑖)>0.

Proof
The first follows from Property 2 of minimal instances. The second follows from the fact that in the iteration that 𝑒𝑖 arrives, since it is unsatisfied, it must not be contained in Z. Let ℓ be the link added to F in that iteration. Since 𝑒𝑖∈𝑃(ℓ)∖𝑍 and 𝑦(𝑒𝑖)>0, we have that 𝜆(𝑒𝑖) is increased by 1 during the iteration and thus 𝜆𝑖(𝑒𝑖)>0. ◻

Lemma 7
𝑐(𝐹)≤𝑂(𝑐(𝐹1)).

Proof
We will show that 𝑐(𝐹3)≤𝑂(1)𝑐(𝐹2), that 𝑐(𝐹2)≤𝑂(1)∑𝑒𝜆(𝑒)𝑦(𝑒) and that ∑𝑒𝜆(𝑒)𝑦(𝑒)≤𝑐(𝐹1). Let ℓ𝑟 be the last type-2 link bought. We have that 𝑐(ℓ𝑟)≤∑𝑒∈𝑃(ℓ𝑟)𝜆(𝑒)𝑦(𝑒) by construction. Moreover, since 𝑐(ℓ𝑟)≥𝑐(ℓ) for every ℓ∈𝐹2 and there is at most one rooted link of each class, we get that 𝑐(𝐹2)≤2𝑐(ℓ𝑟). Thus, we get that 𝑐(𝐹2)≤2∑𝑒∈𝑃(ℓ𝑟)𝜆(𝑒)𝑦(𝑒). For each type-2 link ℓ bought, we buy at most two type-3 links per class 𝑗≤class(ℓ) because of Property 1 of minimal instances. Therefore, we have 𝑐(𝐹3)≤2𝑐(𝐹2)≤4∑𝑒∈𝑃(ℓ𝑟)𝜆(𝑒)𝑦(𝑒).

Finally, we show that ∑𝑒𝜆(𝑒)𝑦(𝑒)≤𝑐(𝐹1). Since 𝜆(𝑒)=|{ℓ:𝑒∈𝐶(ℓ)}|, we have

∑𝑒𝜆(𝑒)𝑦(𝑒)=∑ℓ∈𝐹1(∑𝑒∈𝐶(ℓ)𝑦(𝑒)).
Now, since 𝐶(ℓ)⊆𝑃(ℓ) and y is feasible, we get

∑𝑒∈𝐶(ℓ)𝑦(𝑒)≤∑𝑒∈𝑃(ℓ)𝑦(𝑒)≤𝑐(ℓ).
Combining the previous two inequalities gives us that ∑𝑒𝜆(𝑒)𝑦(𝑒)≤𝑐(𝐹1). ◻

Let 𝑐max=maxℓ∈𝐹1𝑐(ℓ). Define 𝐹ˆ1={ℓ∈𝐹1:𝑐(ℓ)≥𝑐max/𝑛2} and 𝜆ˆ(𝑒)=|{ℓ∈𝐹ˆ1:𝑒∈𝐶(ℓ)}|. We now show that F and the dual solution 𝑦ˆ where 𝑦ˆ(𝑒)=𝜆ˆ(𝑒)𝑦(𝑒) satisfies the conditions of Lemma 6.

Lemma 8
𝑐(𝐹1)≤𝑂(1)∑𝑒𝜆ˆ(𝑒)𝑦(𝑒).

Proof
Observe that 𝑐(𝐹1)≤2𝑐(𝐹ˆ1) so it suffices to prove that

𝑐(𝐹ˆ1)≤𝑂(1)∑𝑒𝜆ˆ(𝑒)𝑦(𝑒).
(3)
We now show that this inequality holds at the end of each iteration of the algorithm. Consider an iteration in which the current request 𝑒𝑖 is not already covered and suppose ℓ∈𝐹ˆ1 is the type-1 link bought in this iteration. The LHS of Inequality (3) increases by 𝑐(ℓ) in this iteration. We now show that ∑𝑒𝜆ˆ(𝑒)𝑦(𝑒) increases by at least 𝑐(ℓ)/2. In this iteration, 𝜆ˆ(𝑒) increases by 1 for every 𝑒∈𝑃(ℓ)∖𝑍 and 𝑦(𝑒)>0, and so ∑𝑒𝜆ˆ(𝑒)𝑦(𝑒) increases by exactly ∑𝑒∈𝑃(ℓ)∖𝑍𝑦(𝑒).

In the remainder of the proof, we show that ∑𝑒∈𝑃(ℓ)∖𝑍𝑦(𝑒)≥𝑐(ℓ)/2. If 𝑃(ℓ)∩𝑍=∅, then ∑𝑒∈𝑃(ℓ)∖𝑍𝑦(𝑒)=∑𝑒∈𝑃(ℓ)𝑦(𝑒)=𝑐(ℓ) since ℓ is tight. Now suppose 𝑃(ℓ)∩𝑍≠∅. Let ℓ′ be the type-2 link such that 𝑍=𝑃(ℓ′). Since 𝑃(ℓ)∩𝑃(ℓ′)≠∅, it must be the case that ℓ is of type higher than class(ℓ′). This is because otherwise, ℓ would have been bought earlier as a type-3 link in the same iteration as ℓ′. But then since 𝑒𝑖∈𝑃(ℓ), it would contradict the assumption that 𝑒𝑖 is not already covered at the start of the current iteration. Thus, class(ℓ)>class(ℓ′) and so 𝑐(ℓ)≥2𝑐(ℓ′). So, we now have

∑𝑒∈𝑃(ℓ)∖𝑍𝑦(𝑒)≥∑𝑒∈𝑃(ℓ)𝑦(𝑒)−∑𝑒∈𝑃(ℓ′)𝑦(𝑒)≥𝑐(ℓ)−𝑐(ℓ′)≥𝑐(ℓ)/2,
where the second last inequality follows from the fact that y is a feasible dual and ℓ is tight. Therefore, Inequality (3) holds at the end of each iteration, as desired. ◻

Lemmas 7 and 8 imply that 𝑐(𝐹)≤𝑂(1)∑𝑒𝑦ˆ(𝑒).

Lemma 9
For each non-rooted link ℓ, we have ∑𝑒∈𝑃(ℓ)𝜆ˆ(𝑒)𝑦(𝑒)≤𝑂(log𝑛)𝑐(ℓ).

Proof
Property 1 of minimal instances implies that for each j, there are at most two links ℓ′∈𝐹ˆ1 of class j with 𝑒∈𝐶(ℓ′). Since each link in 𝐹ˆ1 has cost between 𝑐max/𝑛2 and 𝑐max and link costs are powers of 2, we have that 𝜆ˆ(𝑒)≤𝑂(log𝑛). Thus we get that ∑𝑒∈𝑃(ℓ)𝜆ˆ(𝑒)𝑦(𝑒)≤𝑂(log𝑛)∑𝑒∈𝑃(ℓ)𝑦(𝑒)≤𝑂(log𝑛)𝑐(ℓ), where the last inequality follows from the fact that y is a feasible dual. ◻

Lemma 10
For each rooted link ℓ, we have ∑𝑒∈𝑃(ℓ)𝜆ˆ(𝑒)𝑦(𝑒)≤𝑂(1)𝑐(ℓ).

Proof
We will in fact show that ∑𝑒∈𝑃(ℓ)𝜆(𝑒)𝑦(𝑒)≤𝑂(1)𝑐(ℓ). Suppose, at the end of some iteration, that we have ∑𝑒∈𝑃(ℓ)𝜆(𝑒)𝑦(𝑒)>𝑐(ℓ). Consider the earliest iteration that this happens. We now show that ∑𝑒∈𝑃(ℓ)𝜆(𝑒)𝑦(𝑒)≤𝑂(1)𝑐(ℓ) at the end of the iteration and later show that the LHS cannot increase in future iterations.

Let 𝜆old(𝑒) and 𝑦old(𝑒) denote the values of 𝜆(𝑒) and y(e) at the start of the iteration and 𝜆new(𝑒) and 𝑦new(𝑒) denote their values at the end. We have that

∑𝑒∈𝑃(ℓ)𝜆old(𝑒)𝑦old(𝑒)<𝑐(ℓ).
We now show that

∑𝑒∈𝑃(ℓ)𝜆new(𝑒)𝑦new(𝑒)≤3𝑐(ℓ).
Let 𝑒𝑖 be the request of the current iteration. During this iteration, we only increase y(e) for 𝑒=𝑒𝑖 and we set 𝜆(𝑒𝑖)=1 so 𝜆new(𝑒𝑖)𝑦new(𝑒𝑖)=𝑦(𝑒𝑖). So, we have

∑𝑒∈𝑃(ℓ)𝜆new(𝑒)𝑦new(𝑒)=∑𝑒∈𝑃(ℓ)∖{𝑒𝑖}𝜆new(𝑒)𝑦old(𝑒)+𝑦(𝑒𝑖).
Since y is a feasible dual, we have that 𝑦(𝑒𝑖)≤𝑐(ℓ). Now, Proposition 1 implies that 𝜆old(𝑒)≥1 if 𝑦old(𝑒)>0. Together with the fact that 𝜆new(𝑒)≤𝜆old(𝑒)+1, we get that 𝜆new(𝑒)𝑦old(𝑒)≤2𝜆old(𝑒)𝑦old(𝑒) and so

∑𝑒∈𝑃(ℓ)∖{𝑒𝑖}𝜆new(𝑒)𝑦new(𝑒)≤2∑𝑒∈𝑃(ℓ)∖{𝑒𝑖}𝜆old(𝑒)𝑦old(𝑒)<2𝑐(ℓ).
Thus, ∑𝑒∈𝑃(ℓ)𝜆new(𝑒)𝑦new(𝑒)≤3𝑐(ℓ) at the end of the current iteration.

Finally, we show that ∑𝑒∈𝑃(ℓ)𝜆(𝑒)𝑦(𝑒) does not increase in future iterations. At the end of the current iteration, ℓ is a candidate to be added to F. Among all candidates, the one with highest class is added, so either ℓ is added to F or a rooted link ℓ′ of higher class is added to F. In the second case, by Proposition 1, we have 𝑃(ℓ′)⊇𝑃(ℓ). Thus, in either case, we have that 𝑍⊇𝑃(ℓ) at the end of the current iteration. Moreover, in future iterations, we still have 𝑍⊇𝑃(ℓ) by Proposition 1. Therefore, ∑𝑒∈𝑃(ℓ)𝜆(𝑒)𝑦(𝑒) does not increase in future iterations. Thus, we conclude that ∑𝑒∈𝑃(ℓ)𝜆(𝑒)𝑦(𝑒)≤3𝑐(ℓ) at the end of the algorithm. ◻

Therefore, we conclude that Algorithm 1 is nice. Together with Lemma 4, we get Theorem 1.

Lower Bound for Online Path Augmentation
In this section, we prove Theorem 2.

Let B be a constant to be fixed later. Consider the path with n edges and 𝑛+1 vertices where n is a power of 2B. In the following, for 𝑖∈{0,…,𝑛}, we write 𝑣𝑖 as the i-th vertex of the path with 𝑣0 being the leftmost vertex. We have log2𝐵𝑛 classes of links. Each link ℓ of class j has cost 𝐵𝑗 and path length |𝑃(ℓ)|=(2𝐵)𝑗; moreover, the class j links are disjoint, i.e. for any ℓ,ℓ′ of class j, we have 𝑃(ℓ)∩𝑃(ℓ′)=∅, and they cover the entire path. In particular, each link ℓ of class j is of the form ℓ=(𝑖⋅(2𝐵)𝑗,(𝑖+1)⋅(2𝐵)𝑗) for some 𝑖∈{0,…,𝑛(2𝐵)𝑗−1}. We say that a link ℓ contains another link ℓ′ if 𝑃(ℓ)⊇𝑃(ℓ′). Note that the links form a hierarchical structure: a link ℓ of class j contains 2B links of class 𝑗−1; we call the latter child links of ℓ, and ℓ their parent link. We also say that the set of minimal links (i.e. those at the bottom of the hierarchical structure) are leaf links. Note that these correspond exactly to the edges of the path.

We say that an algorithm is canonical if for each request e, if it buys a class j link ℓ, then for each class 𝑗′<𝑗, it also buys the unique link ℓ′ which has 𝑒∈𝑃(ℓ′)⊆𝑃(ℓ). Since the costs are geometric, it is easy to see that we can make any algorithm canonical and lose only a constant factor in the competitive ratio. Thus, it suffices to prove a lower bound against canonical algorithms.

Lemma 11
For every 𝐵≥2, every canonical algorithm 𝖠𝖫𝖦 has competitive ratio at least 𝛺(log𝐵𝑛).

Proof
Consider the following sequence of requests: while there exists an edge that is not yet covered by 𝖠𝖫𝖦, the adversary gives as the next request the leftmost edge that is not yet covered. Let R be the sequence of requests in this instance and F be the set of links bought by 𝖠𝖫𝖦. The plan is to show that for each class j, there exists a feasible solution 𝐹′𝑗 consisting only of class j links and that ∑𝑗𝑐(𝐹′𝑗)≤2𝑐(𝐹). This would imply that OPT≤2𝑐(𝐹)/log2𝐵𝑛 and thus imply the lemma.

For each class j, define the set 𝐹′𝑗 to be the links ℓ of class j such that there exists a request that is contained in 𝑃(ℓ). Let 𝐹′=⋃𝑗𝐹′𝑗. Clearly, each 𝐹′𝑗 is a feasible solution. It remains to show that 𝑐(𝐹′)≤2𝑐(𝐹). To do this, we now prove that 𝑐(𝐹′∖𝐹)≤𝑐(𝐹). The following claim will be useful. It says that if a link ℓ has 𝑃(ℓ) containing some request e and ℓ was not chosen by the algorithm, then it must be the case that each child link ℓ′ of ℓ has 𝑃(ℓ′) containing some request 𝑒′. ◻

Claim 3
For each non-leaf link ℓ∈𝐹′∖𝐹, every child link ℓ′ of ℓ is in 𝐹′ as well.

Proof
We need to show that for each child link ℓ′ of ℓ, there exists a request 𝑒∈𝑃(ℓ′). Since ℓ∉𝐹 and the algorithm is canonical, it must be the case that for each request 𝑒∈𝑅∩𝑃(ℓ), when the request e arrived, the algorithm covered it using a link that is strictly contained in ℓ. Thus, by construction of the request sequence, we have that for each child link ℓ′ of ℓ, there exists a request contained in 𝑃(ℓ′) and so by definition of 𝐹′, we have that ℓ′∈𝐹′. ◻

We use a token-based argument to prove that 𝑐(𝐹′∖𝐹)≤𝑐(𝐹). There will be two types of tokens: original tokens and virtual tokens. Each token a has a value v(a); moreover, if a is virtual, then it is also associated with a parent token p(a) (which may be either an original or virtual token) and we say that a is a child token of p(a). Initially, there are no tokens. For each link ℓ∈𝐹, we give it an original token of value 𝑐(ℓ). We will now create virtual tokens to pay for links in 𝐹′∖𝐹. We say that a link ℓ∈𝐹′∖𝐹 is paid for if it has tokens of value at least 𝑐(ℓ). We create virtual tokens iteratively in a bottom-up manner: While there exists a link in 𝐹′∖𝐹 that is not paid for, let ℓ be the link of smallest class in 𝐹′∖𝐹 that is not paid for; then, for each token a associated with a child link of ℓ, we create and give to ℓ a virtual token 𝑎′ with 𝑣(𝑎′)=𝑣(𝑎)/2 and 𝑝(𝑎′)=𝑎. We now argue that in each iteration of this procedure, ℓ is paid for. First, observe that ℓ cannot be a leaf link (and thus the above procedure is actually valid). By definition of 𝐹′, the links in 𝐹′ that are leaf links correspond exactly to the set of requested edges. Since the algorithm is canonical, these links are also in F and are thus paid for. Therefore, ℓ is not a leaf link; moreover, the above claim implies that each of its 2B child links are in 𝐹′. Since ℓ is the link of smallest class that is not paid for, its child links are already paid for so they have tokens of total value at least 2𝐵⋅𝐵𝑗−1=2𝐵𝑗. Therefore, we get that the tokens given to ℓ have value at least 𝐵𝑗 and so ℓ is now paid for.

Since each link of 𝐹′∖𝐹 is paid for by virtual tokens, we get that 𝑐(𝐹′∖𝐹) is at most the value of virtual tokens. We now argue that the total value of the virtual tokens is at most the value of the original tokens. Note that each token, virtual or original, can have at most one child token. Moreover, every virtual token is a descendant of an original token. Finally, the value of a virtual token is half its parent token’s value. Putting the above together, we get that for each original token of value 𝐵𝑗, the total value of its descendant virtual tokens is at most ∑𝑖≥1𝐵𝑗/2𝑖≤𝐵𝑗. Therefore, the total value of virtual tokens is at most the total value of original tokens. Since the value of the original tokens is exactly c(F), we get that 𝑐(𝐹′∖𝐹)≤𝑐(𝐹), as desired. This completes the proof of the lemma. ◻

Using 𝐵=2 in the above lemma gives us Theorem 2.

A Fractional Algorithm for Online Path Augmentation
In this section, we prove Theorem 3. We begin by defining the online fractional path augmentation problem formally. We have variables 𝑥(ℓ) for each link ℓ which represent the fraction of ℓ that we have bought so far. Initially, 𝑥(ℓ)=0 for every ℓ. Then, when a request 𝑒𝑖 arrives, we need to increase variables so that ∑ℓ:𝑒𝑖∈𝑃(ℓ)𝑥(ℓ)≥1. Moreover, variables cannot be decreased. The cost of a fractional solution x is ∑ℓ𝑥(ℓ)𝑐(ℓ). The goal is to maintain a feasible fractional solution with low cost. Equivalently, we can think of the online fractional problem in terms of solving LP (1) online: the constraints of the LP arrive one by one, and we need to maintain a feasible fractional solution.

Throughout this section, we assume that we are working with minimal instances as defined in Sect. 4. In general, the fractional version of an optimization problem can admit a much better solution than the integral version. It turns out that for the path augmentation problem, to be competitive against any fractional solution, it suffices to be competitive against any integral solution.

Lemma 12
(Integrality of LP (1)) For any instance of path augmentation, there is an optimal solution to LP (1) that is integral.

Proof
The rows of the constraint matrix of LP (1) satisfy the consecutive-ones property. Thus the constraint matrix is totally unimodular and the LP (1) is integral (see Lee [15, Chapter 0.8]). ◻

Henceforth, we will use OPT to denote the value of an optimal integral solution and our goal is to be competitive against OPT.

Let us first sketch a simple algorithm assuming that we are given the value of OPT at the beginning. Since OPT is the value of an optimal integral solution, we first remove all links of cost more than OPT without loss of generality. We say that a request 𝑒𝑖 is small if it can be covered by a link of cost at most OPT/𝑛, and large otherwise. We handle small and large requests differently. For each small request 𝑒𝑖, we set 𝑥(ℓ)=1 where ℓ is the link of cost at most OPT/𝑛 covering 𝑒𝑖. We use the online fractional set cover algorithm of [1] to deal with large requests.

Let us now analyze this algorithm. The incremental cost incurred in serving a request is the increase in the algorithm’s cost when it serves the request. The total incremental cost incurred in serving small requests is at most OPT since the incremental cost for each small request is at most OPT/𝑛 and there can be at most n requests total (one request per edge of the path). What about the total incremental cost for large requests? The online fractional set cover algorithm of [1] has a competitive ratio of 𝑂(log𝑑) if each element is contained in at most d sets. Thus, to show that the total incremental cost for large requests is at most 𝑂(loglog𝑛)OPT, it suffices to prove that each large request is covered by at most 2log𝑛 links. Consider a large request 𝑒𝑖. Since we had removed links of cost more than OPT and 𝑒𝑖 is large, it is covered only by links of cost between OPT/𝑛 and OPT. Moreover, since costs are powers of 2, by Property 1 of minimal instances, 𝑒𝑖 is covered by at most log𝑛 links.

We now describe our online fractional path augmentation algorithm that does not need to know the value of OPT upfront. Let OPT𝑖 denote the cost of the optimal integral solution for the first i requests 𝑒1,…,𝑒𝑖; Lemma 12 implies that OPT𝑖 can be found by computing a basic feasible solution of LP (1). For each request 𝑒𝑖, if 𝑒𝑖 can be covered by a link ℓ of cost at most OPT𝑖/𝑛, then we set the variable 𝑥(ℓ)=1; otherwise, we perform multiplicative update as follows. Let 𝐿𝑖={ℓ:𝑒𝑖∈𝑃(ℓ)∧𝑐(ℓ)∈[OPT𝑖/𝑛,2OPT𝑖]}. The multiplicative update step does the following: while ∑ℓ∈𝐿𝑖𝑥ℓ<1, for each ℓ∈𝐿𝑖, increase 𝑥(ℓ) continuously at the rate

𝑑𝑥(ℓ)𝑑𝑡=𝑥(ℓ)+1/log𝑛𝑐(ℓ).
As before, we say that request 𝑒𝑖 is small if there exists a link of cost at most OPT𝑖/𝑛 covering it, and large otherwise.

Lemma 13
The solution x computed by the online fractional path augmentation algorithm above has cost 𝑂(loglog𝑛)OPT.

Proof
It is easy to see that again, the total incremental cost incurred in serving small requests is at most OPT. However, bounding the total incremental cost incurred in serving large requests requires more work. Say that an integral solution F is restricted if for every large request 𝑒𝑖, there is a link in F covering 𝑒𝑖 that is also in 𝐿𝑖, i.e. F is feasible even if 𝑒𝑖 is restricted to be covered only by links in 𝐿𝑖. Since costs are powers of 2, Property 1 of minimal instances implies that |𝐿𝑖|≤𝑂(log𝑛) and so, as before, the analysis in [1] implies that the total incremental cost incurred in serving large requests is at most 𝑂(loglog𝑛)𝑐(𝐹) for every restricted solution F. It remains to show that there exists a restricted solution F with cost at most 𝑂(OPT).

Define phase j of the algorithm to consist of the time steps i for which OPT𝑖∈[2𝑗,2𝑗+1) and i(j) to be the last time step of phase j. Let OPT𝑗=OPT𝑖(𝑗), the value of an optimal integral solution 𝐹∗𝑗 for the requests seen by the end of phase j. For each large request 𝑒𝑖 in phase j, since OPT𝑗<2OPT𝑖 and 𝐹∗𝑗 is integral, it must be the case that 𝑒𝑖 is covered by 𝐹∗𝑗 using a link in 𝐿𝑖. Let 𝐹̂ 𝑗 be the subset of 𝐹∗𝑗 that covers the large requests of phase j. Therefore, we get that 𝐹=⋃𝑗𝐹̂ 𝑗 is a restricted solution. The cost of F is 𝑐(𝐹)≤∑𝑗≤𝑚2𝑗+1≤2𝑚+2, where m is the final phase. Since OPT=OPT𝑚≥2𝑚, we have that 𝑐(𝐹)≤4OPT. This proves that there exists a restricted solution F with cost at most 𝑂(OPT). Therefore, we conclude that x has cost at most 𝑂(loglog𝑛)OPT. ◻

This proves Theorem 3.

Conclusion and Open Problems
We gave a deterministic algorithm for online WTAP with competitive ratio 𝑂(log𝑛). Plugging this algorithm into the algorithm of [10] gives a randomized 𝑂̃ (log2𝑛)-competitive algorithm for online survivable network design for the setting where 𝑟max=2. The main open problem is whether the competitive ratio for the online survivable network design problem can be improved. For general 𝑟max, the current best upper bound is randomized 𝑂̃ (𝑟maxlog3𝑛) and the current best lower bound is 𝛺(log𝑛) against randomized algorithms [10]. The lower bound also holds when 𝑟max=2.

For WPAP, we showed that the deterministic competitive ratio is Θ(log𝑛). It remains open whether it is possible to achieve a randomized competitive ratio of 𝑂(loglog𝑛). For the special case of the online parking permit problem, [16] gave a randomized 𝑂(loglog𝑛)-competitive algorithm and a lower bound of 𝛺(loglog𝑛) against randomized algorithms. We gave a fractional 𝑂(loglog𝑛)-competitive algorithm for WPAP and conjecture that it is possible to obtain a randomized rounding algorithm for our fractional algorithm that only loses a constant factor in the rounding.