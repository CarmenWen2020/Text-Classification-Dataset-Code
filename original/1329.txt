The Weighted Tree Augmentation problem (WTAP) is a fundamental problem in network design. In this paper, we consider this problem in the online setting. We are given an n-vertex tree ğ‘‡=(ğ‘‰,ğ¸) and an additional set ğ¿âŠ†(ğ‘‰2) of edges (called links) with costs. Then, terminal pairs arrive one-by-one and our task is to maintain a low-cost subset of links F such that every terminal pair that has arrived so far is 2-edge-connected in ğ‘‡âˆªğ¹. This online problem was first studied by Gupta, Krishnaswamy and Ravi (SICOMP 2012) who used it as a subroutine for the online survivable network design problem. They gave a deterministic ğ‘‚(log2ğ‘›)-competitive algorithm and showed an ğ›º(logğ‘›) lower bound on the competitive ratio of randomized algorithms. The case when T is a path is also interesting: it is exactly the online interval set cover problem, which also captures as a special case the parking permit problem studied by Meyerson (FOCS 2005). The contribution of this paper is to give tight results for online weighted tree and path augmentation problems. The main result of this work is a deterministic ğ‘‚(logğ‘›)-competitive algorithm for online WTAP, which is tight up to constant factors.

Access provided by University of Auckland Library

Introduction
In the weighted tree augmentation problem (WTAP), we are given an n-vertex tree ğ‘‡=(ğ‘‰,ğ¸) together with an additional set of edges L called links, where ğ¿âŠ†(ğ‘‰2). Each link â„“âˆˆğ¿ has a cost ğ‘(â„“)â‰¥0. Terminal pairs (ğ‘ ğ‘–,ğ‘¡ğ‘–), ğ‘–={1,â€¦,ğ‘˜}, are given and the goal is to compute a minimum cost subset of links ğ¹âŠ†ğ¿ such that each terminal pair is (edge) 2-connected in ğ‘‡âˆªğ¹. In the unweighted version, the links have unit costs and the problem is known as the tree augmentation problem (TAP). If the tree T is a path, then the unweighted problem is called the path augmentation problem (PAP), while the weighted version is called weighted path augmentation (WPAP).

TAP and WTAP are considered to be fundamental connectivity augmentation problems, and have been studied extensively. TAP is already known to be APX-hard and the best approximation algorithms for WTAP and TAP achieve approximation ratios of 2 and 1.458 respectively [7, 9]. Improving these bounds is an important open problem.

We consider these problems in the online setting. In online WTAP, we are initially given a tree ğ‘‡=(ğ‘‰,ğ¸), and the set of links L together with their costs. The terminal pairs (ğ‘ ğ‘–,ğ‘¡ğ‘–) arrive online one by one. Our goal is to maintain a low-cost subset of links ğ¹âŠ†ğ¿ such that each terminal pair seen so far is (edge) 2-connected in ğ‘‡âˆªğ¹.

Online WTAP occurs as a subproblem in the online survivable network design algorithm of Gupta, Krishnaswamy and Ravi [10]. They observed that the online tree augmentation problem can be cast as an instance of the online set cover problemFootnote1 in which the elements are the fundamental cuts defined by the terminal pairs and the sets are the links. Since there are only n elements and ğ‘‚(ğ‘›2) sets, applying the results of Alon et al. [1] yields a fractional ğ‘‚(logğ‘›)-competitive algorithm. But then, how does one round the fractional solution online? Randomized rounding seems to be the only rounding technique we have for this problem, and it yields a randomized ğ‘‚(log2ğ‘›)-competitive algorithm, as observed by [1]. This competitive factor can even be achieved deterministically at no further cost [1]. We note that the loss of a logarithmic factor in the rounding step seems inherent to the randomized rounding. Interestingly, Gupta, Krishnaswamy and Ravi [10] also showed for the rooted setting (ğ‘ ğ‘–=ğ‘Ÿ for some root r) a lower bound of ğ›º(logğ‘›) against randomized algorithms. It is easy to observe that this lower bound also holds against fractional online algorithms.

There has been a long line of work on maintaining connectivity online, starting with the seminal paper of Imase and Waxman [13]. A Î˜(logğ‘›)-competitive algorithm is given there for the online Steiner tree problem in undirected graphs. In this problem, the graph with a fixed root vertex is known in advance and the terminals are given one by one, and one must ensure that all terminals that have arrived so far are connected to the root. Other polylogarithmic (in n) competitive algorithms have been given for more complex models of connectivity, including those with node costs rather than edge costs and penalties for violating connectivity constraints; see [2,3,4, 11, 12, 17, 19, 21]. Gupta, Krishnaswamy, and Ravi [10] consider the online survivable network design problem, which generalizes WTAP. In this problem, a graph is fixed in advance and terminal pairs (ğ‘ ğ‘–,ğ‘¡ğ‘–) arrive with connectivity requirements ğ‘Ÿğ‘–; one must ensure that there are at least ğ‘Ÿğ‘– edge-disjoint paths between ğ‘ ğ‘– and ğ‘¡ğ‘– for all pairs that have arrived thus far. They give a randomized ğ‘‚Ìƒ (ğ‘Ÿmaxlog3ğ‘›)-competitive algorithm for the problem, where ğ‘Ÿmax=maxğ‘–ğ‘Ÿğ‘–. (The ğ‘‚Ìƒ  notation hides loglogğ‘› factors.) Note that this problem with uniform requirements ğ‘Ÿğ‘–=2 already generalizes WTAP.

The online WPAP, when T is a path, is an interesting problem in its own right. This problem is equivalent to online interval set coverFootnote2. It captures as a special case the parking permit problem introduced by Meyerson [16]. In this problem, there is a sequence of days; each day it is either sunny or it rains, and if it rains we must purchase a parking permit. Permits have various durations and costs. We can model the parking permit problem by online path augmentation by letting the edges of the path correspond to the sequence of days, the links to the permits, and the rainy days to a terminal pair request for the corresponding day. Meyerson [16] gives a deterministic ğ‘‚(logğ‘›)-competitive algorithm for the problem and a randomized ğ‘‚(loglogğ‘›)-competitive algorithm, and shows lower bounds on the competitive ratio of ğ›º(logğ‘›/loglogğ‘›) for deterministic algorithms and ğ›º(loglogğ‘›) for randomized algorithms. Note that online WPAP is a strict generalization of the parking permit problem because the parking permit problem assumes that permits of the same duration have the same cost, whereas no such assumption is made of the links in WPAP.

Our Results
The contribution of this paper is to give tight results (within constant factors) for online tree and path augmentation problems. Our main result is that weighted online tree augmentation has a competitive ratio of Î˜(logğ‘›).

Theorem 1
There is a deterministic algorithm for online WTAP with competitive ratio ğ‘‚(logğ‘›).

This result is tight up to constant factors because of the ğ›º(logğ‘›) lower bound on randomized algorithms for WTAP given by [10]. As we mention above, [10] gives a randomized ğ‘‚Ìƒ (ğ‘Ÿmaxlog3ğ‘›)-competitive algorithm for the online survivable network design problem. An intriguing open question is whether this competitive ratio can be improved, say to ğ‘‚(ğ‘Ÿmaxlogğ‘›) or even ğ‘‚(logğ‘›). In fact, we are unaware of lower bounds that rule out the latter bound. We view our main result as a necessary stepping stone towards obtaining an ğ‘‚(ğ‘Ÿmaxlogğ‘›) or ğ‘‚(logğ‘›) bound. Indeed, for ğ‘Ÿmax=2, plugging in our algorithm for online WTAP into the algorithm of [10] improves their competitive ratio from ğ‘‚Ìƒ (log3ğ‘›) to ğ‘‚Ìƒ (log2ğ‘›).

Corollary 1
For online survivable network design with ğ‘Ÿmax=2, there is a randomized algorithm with competitive ratio ğ‘‚Ìƒ (log2ğ‘›).

Our second result shows that the competitive ratio for deterministic algorithms for online path augmentation is also Î˜(logğ‘›). Meyerson [16] gives a lower bound of ğ›º(logğ‘›/loglogğ‘›) for deterministic algorithms for the parking permit problem, and hence for online path augmentation. We improve the analysis of his lower bound instance to show the following.

Theorem 2
Every deterministic algorithm for online WPAP has competitive ratio ğ›º(logğ‘›).

Since we use a parking permit instance to show the lower bound, we have the same lower bound for the parking permit problem.

Finally, we show that the fractional version of online path augmentation has competitive ratio Î˜(loglogğ‘›) for deterministic algorithms. In the fractional version of the problem, the algorithm is allowed to buy each edge to a fractional extent; see Sect. 6 for a formal definition. Fractional algorithms are interesting as they are related to randomized algorithms. On the one hand, a randomized algorithm can be converted into a deterministic fractional algorithm of the same cost: the fractional algorithm buys each edge e to an extent equal to the probability that the randomized algorithm buys it. On the other hand, a fractional algorithm can sometimes be converted into a randomized algorithm by applying randomized rounding on the fractional solution. We show the following.

Theorem 3
There is a deterministic algorithm for online fractional WPAP with competitive ratio ğ‘‚(loglogğ‘›).

This is asymptotically tight as Meyerson [16] gives a lower bound of ğ›º(loglogğ‘›) for randomized algorithms for the parking permit problem, and hence for online fractional path augmentation. Theorem 3 also implies an exponential gap between the competitive ratios of fractional path augmentation and fractional tree augmentation.

Recall that online WPAP is equivalent to online interval set cover. Thus, Theorems 1 and 3 imply that restricting online set cover to interval sets allows for improved competitive ratios. Also, even though interval set cover and interval hitting set are equivalent in the offline case, it turns out that there is an exponential gap between the competitive ratios of the two problems in the online case; in contrast to Theorem 3, Even and Smorodinsky [6] gave a lower bound of ğ›º(logğ‘›) for online fractional hitting set.

Our Techniques
We now outline some of the ideas behind our algorithms.

Online WTAP As mentioned before, there is an online fractional ğ‘‚(logğ‘›)-competitive algorithm for WTAP that follows from the work of [1] on the online set cover problem. However, it is unclear how to exploit the special structure of the set system in hand in WTAP (as defined by the links) to avoid the loss of another factor of ğ‘‚(logğ‘›) when rounding the fractional solution into an integral one (either randomized or deterministic). Thus, our approach to proving Theorem 1 takes a completely different route. There are two key ingredients in our proof:

1.
Low-width path decomposition. The first ingredient is a path decomposition of low â€œwidthâ€: in particular, there is a decomposition of the tree into edge-disjoint paths such that any path in the tree intersects at most ğ‘‚(logğ‘›) paths of the decomposition. Such a decomposition can be obtained using the heavy-path decomposition of Sleator and Tarjan [20]. This immediately implies an ğ‘‚(logğ‘›)-approximate black-box reduction from online tree augmentation to online path augmentation. Unfortunately, Theorem 2 gives a lower bound of ğ›º(logğ‘›) for the latter problem. Since a tree may have width ğ›º(logğ‘›) in the worst case (e.g., a binary tree), the best we can achieve for WTAP using a black-box reduction is a competitive ratio of ğ‘‚(log2ğ‘›).

2.
Refined guarantee for path augmentation. The second ingredient is our main technical contribution. We define a notion of projection for links onto paths in the path decomposition, and call the projected link rooted if it has the node of the path closest to the root of the tree as an endpoint. The key insight is that the path decomposition has a special structure: for each link, its projection is rooted for all but at most one of the paths in the decomposition. We then use linear programming to give a version of the path algorithm that treats rooted links differently from non-rooted links; in particular, an online path augmentation algorithm that finds a solution whose cost is within a constant factor of the rooted links of the optimal solution plus an ğ‘‚(logğ‘›) factor of the cost of the non-rooted links. Intuitively, then, summing the cost over all the paths in the decomposition, each link appears as a rooted link in at most ğ‘‚(logğ‘›) paths in the decomposition and as a non-rooted link in at most one path in the decomposition, yielding the ğ‘‚(logğ‘›) factor overall.

Online Fractional WPAP Directly applying the online fractional set cover algorithm of [1] to online fractional WPAP only yields a competitive ratio of ğ‘‚(logğ‘›). However, for online set cover instances in which each element is covered by at most d sets, the algorithm of [1] is ğ‘‚(logğ‘‘)-competitive. Thus, to get a competitive ratio of ğ‘‚(loglogğ‘›), the basic idea is to reduce to a restricted instance in which each request can only be covered by ğ‘‚(logğ‘›) links. For such restricted instances, applying the algorithm of [1] gives a competitive ratio of ğ‘‚(loglogğ‘›).

Other Related Work
Dehghani et al. [5] studied online survivable network design, giving a bicriteria approximation algorithm, and considered several stochastic settings.

Organization of the Paper
We start with the preliminaries and describe the low-width path decomposition in Sect. 2. In Sect. 3, we present the refined guarantee needed for online path augmentation. Then, we show how to achieve the required refined guarantee in Sect. 4. Next, we turn to the WPAP. In Sect. 5, we give a lower bound for WPAP against deterministic algorithms. In Sect. 6, we give a fractional algorithm for WPAP. We conclude the paper with open problems in Sect. 7.

Preliminaries
We restate the formal definition of the problem. In the online weighted tree augmentation problem, we are initially given a tree ğ‘‡=(ğ‘‰,ğ¸), and an additional set of edges called links ğ¿âŠ†(ğ‘‰2) with costs ğ‘(â„“)â‰¥0. Then, terminal pairs (ğ‘ ğ‘–,ğ‘¡ğ‘–) arrive one by one. Our goal is to maintain a low-cost subset of links ğ¹âŠ†ğ¿ such that each terminal pair seen so far is 2-connected in ğ‘‡âˆªğ¹.

Notation Denote by P(u, v) the path between u and v in T. For a link â„“=(ğ‘¢,ğ‘£), we write ğ‘ƒ(â„“)=ğ‘ƒ(ğ‘¢,ğ‘£) and for a set S of links, we write ğ‘ƒ(ğ‘†)=â‹ƒâ„“âˆˆğ‘†ğ‘ƒ(â„“). We say that a link â„“âˆˆğ¿ covers an edge ğ‘’âˆˆğ¸ if ğ‘’âˆˆğ‘ƒ(â„“). Define cov(ğ‘’)={â„“âˆˆğ¿:ğ‘’âˆˆğ‘ƒ(â„“)} to be the set of links covering e. Note that cov(ğ‘’) is exactly the set of links crossing the cut induced by the tree edge e. See Fig. 1 for an illustration.

Fig. 1
figure 1
This figure illustrates the definitions in the Notation paragraph of Sect. 2. In this example, the tree consist of the solid edges. The link (u, v) is represented by a dashed edge and its path P(u, v) consist of the solid blue edges. The link (u, v) covers the tree edge e and thus belongs to cov(ğ‘’)

Full size image
Simplifying assumptions In the rest of this paper, we assume that link costs are powers of 2; this assumption is without loss of generality since we can round up all link costs and lose only a factor of 2 in the competitive ratio. Given that link costs are powers of 2, we say that the class of a link â„“ is j if ğ‘(â„“)=2ğ‘— and we write class(â„“)=ğ‘—.

Given an instance in which link costs are powers of 2, we also assume that requests are elementary: each request (ğ‘ ğ‘–,ğ‘¡ğ‘–) is a tree edge ğ‘’âˆˆğ¸. This is without loss of generality because an adversary can simulate a non-elementary request (ğ‘ ğ‘–,ğ‘¡ğ‘–) by a sequence of requests, one per edge along the path between ğ‘ ğ‘– and ğ‘¡ğ‘–; this only makes the problem harder as the algorithm has to cover part of the path before seeing the full set of requests on the path. The benefit of an instance consisting only of elementary requests is that it admits the following characterization of feasible solutions. Let ğ‘…âŠ†ğ¸ be a set of elementary requests. Then, a solution F is feasible if and only if for every edge ğ‘’âˆˆğ‘…, we have |ğ¹âˆ©cov(ğ‘’)|â‰¥1; or equivalently, if ğ‘ƒ(ğ¹)âŠ‡ğ‘….

Path decomposition We next define a rooted path decomposition.

Definition 1
(Rooted Path Decomposition) Let T be a tree. A path decomposition of T is a partition îˆ¼ of its edge set into edge-disjoint paths. We say îˆ¼ is rooted if there is a vertex ğ‘Ÿâˆˆğ‘‡ such that if we root T at r, then for each path ğ‘âˆˆîˆ¼, the least common ancestor of the vertices on p is an endpoint of the path (we call this endpoint the root of p). The width of îˆ¼ is width(îˆ¼)=maxğ‘¢,ğ‘£âˆˆğ‘‰(ğ‘‡)|{ğ‘âˆˆîˆ¼:ğ‘ƒ(ğ‘¢,ğ‘£)âˆ©ğ‘â‰ âˆ…}|, the maximum number of paths ğ‘âˆˆîˆ¼ that any path in T intersects. See Fig. 2 for an illustration.

Lemma 1
(Low Width Rooted Path Decompositions [20]) Every tree on n vertices admits a rooted path decomposition of width ğ‘‚(logğ‘›).

An ğ‘‚(logğ‘›)-width rooted path decomposition can be obtained using the so-called heavy path decomposition of Sleator and Tarjan [20]. For the sake of completeness, we give a proof here. The following notion of a caterpillar decomposition will be convenient.

Definition 2
(Caterpillar Decomposition) Let T be a rooted tree on n vertices. A caterpillar decomposition of T is a vertex-disjoint decomposition of T into a root-to-leaf path B (called the backbone) and subtrees ğ‘‡ğ‘– that are connected to B. The decomposition is balanced if for each subtree ğ‘‡ğ‘–, we have |ğ‘‰(ğ‘‡ğ‘–)|â‰¤ğ‘›/2.

Lemma 2
Every tree admits a balanced caterpillar decomposition.

Proof
The existence of a balanced caterpillar decomposition is an easy consequence of the well-known fact [14] that every tree T has a balanced vertex separator v, i.e. after removing v from T, each of the remaining connected components has at most n/2 vertices. The following is a balanced caterpillar decomposition of T: pick an arbitrary root-to-leaf path containing v to be the backbone B, and the subtrees ğ‘‡ğ‘– to be the connected components of T after removing B. â—»

Fig. 2
figure 2
Example of a tree and a rooted path decomposition consisting of four paths: ğ‘ƒ1,ğ‘ƒ2,ğ‘ƒ3,ğ‘ƒ4. The edge colors reflect the partition of the edges. The root of each path is the highest vertex of the path. The width of the decomposition is 4 as the path between u and v intersects all four paths of the decomposition

Full size image
Lemma 1 now easily follows by choosing an arbitrary root vertex of T and recursively applying Lemma 2.

Refined Guarantee for Online Path Augmentation
As already mentioned, Lemma 1 implies an ğ‘‚(logğ‘›)-approximate black-box reduction to online path augmentation: given an ğ›¼-competitive algorithm for online path augmentation, we have an ğ‘‚(ğ›¼logğ‘›)-competitive algorithm for online tree augmentation. However, Theorem 2 says that ğ›¼=ğ›º(logğ‘›) for deterministic algorithms. To get around this lower bound, instead of using a black box reduction, we will use Lemma 1 in conjunction with a more refined guarantee for online path augmentation.

We need some notation to describe this refined guarantee. Suppose îˆ¼ is a rooted path decomposition of T and ğ‘„âˆˆîˆ¼ be a path in the decomposition. For a link â„“ that shares at least one edge with Q, define ğœ‹ğ‘„(â„“) to be the link whose endpoints are endpoints of the path ğ‘ƒ(â„“)âˆ©ğ‘„; we call ğœ‹ğ‘„(â„“) the projection of â„“ onto Q. We say that â„“ is Q-rooted if one of the endpoints of ğœ‹ğ‘„(â„“) is the root of Q, and Q-non-rooted otherwise. (See Fig. 3 for an illustration.) For brevity, we simply say that a link is rooted or non-rooted when Q is implied by the context. The main ingredient for the refined guarantee is the next lemma.

Fig. 3
figure 3
Illustration of the projections of the link (u, v) (represented as a dashed line in the figure on the right) onto the paths of the decomposition. Only the projection onto ğ‘ƒ3 (consisting of the path between x and y) is non-rooted

Full size image
Lemma 3
Consider a tree T and link â„“=(ğ‘¢,ğ‘£). Suppose îˆ¼ is a rooted path decomposition of T. Then, there is at most one path ğ‘„âˆˆîˆ¼ for which â„“ is Q-non-rooted.

Proof
Let w be the least common ancestor of u and v. If â„“ is Q-non-rooted, then w lies in Q but is not the root of Q. Since a vertex only appears in multiple paths in îˆ¼ if it is the root of all but at most one of them, there is at most one ğ‘„âˆˆîˆ¼ containing w as a non-root vertex, giving the lemma. â—»

Motivated by Lemma 3, we define the online rooted path augmentation problem. An instance of online rooted path augmentation consists of a rooted path Q where the root r is an endpoint of Q. For such an instance, we say that a link is rooted if one of its endpoints is r. Lemma 3 suggests that we should devise an algorithm for online rooted path augmentation with the following refined guarantee.

Definition 3
(Nice Solution) A solution F for an instance of online rooted path augmentation is nice if for any feasible solution ğ¹âˆ—, we have ğ‘(ğ¹)â‰¤ğ‘‚(1)ğ‘(ğ‘…âˆ—)+ğ‘‚(logğ‘›)ğ‘(ğ‘†âˆ—) where ğ‘…âˆ— is the set of rooted links and ğ‘†âˆ— is the set of non-rooted links of ğ¹âˆ—, respectively. An algorithm is nice if it always produces a nice solution.

Lemma 4
Suppose that there exists a deterministic nice algorithm ğ–¯ğ–ºğ—ğ—-ğ– ğ–«ğ–¦ for online rooted path augmentation. Then, there exists an ğ‘‚(logğ‘›)-competitive deterministic algorithm for online tree augmentation.

Proof
Here is our algorithm for general instances. Consider a general instance of online weighted tree augmentation with tree ğ‘‡=(ğ‘‰,ğ¸), requests ğ‘’1,â€¦,ğ‘’ğ‘˜âŠ†ğ¸ and links ğ¿=(ğ‘‰2) with costs ğ‘(â„“). Our algorithm works as follows. By Lemma 1, there exists a rooted path decomposition îˆ¼ of T with width ğ‘¤=ğ‘‚(logğ‘›). Now, each rooted path ğ‘„âˆˆîˆ¼ defines an instance of online rooted path augmentation: the links are ğ¿ğ‘„={ğœ‹ğ‘„(â„“):â„“âˆˆğ¿} where ğœ‹ğ‘„(â„“) has cost ğ‘(â„“), and the sequence of requests is exactly the subsequence of requests that lie on Q. So, our algorithm runs in parallel |îˆ¼| instantiations of ğ–¯ğ–ºğ—ğ—-ğ– ğ–«ğ–¦, one per rooted path ğ‘„âˆˆîˆ¼. When request ğ‘’ğ‘– arrives, if ğ‘’ğ‘–âˆˆğ‘„ (since ğ‘’ğ‘– is an elementary request, it must lie on some path of îˆ¼), then our algorithm uses the instantiation of ğ–¯ğ–ºğ—ğ—-ğ– ğ–«ğ–¦ on Q to handle that request; in particular, if ğ–¯ğ–ºğ—ğ—-ğ– ğ–«ğ–¦ buys the projected link ğœ‹ğ‘„(â„“), then our algorithm buys the link â„“.

Let us now analyze the competitive ratio of this algorithm. Let ğ¹âˆ— be a feasible solution. For ğ‘„âˆˆîˆ¼, we denote by ğ‘…âˆ—ğ‘„, and ğ‘†âˆ—ğ‘„ the subset of ğ¹âˆ— which is Q-rooted, and Q-non-rooted, respectively. Since ğ–¯ğ–ºğ—ğ—-ğ– ğ–«ğ–¦ is nice, we have that our algorithmâ€™s solution F has cost

ğ‘(ğ¹)â‰¤âˆ‘ğ‘„âˆˆîˆ¼[ğ‘‚(1)ğ‘(ğ‘…âˆ—ğ‘„)+ğ‘‚(logğ‘›)ğ‘(ğ‘†âˆ—ğ‘„)]â‰¤ğ‘‚(logğ‘›)ğ‘(ğ¹âˆ—),
where the last inequality is because Lemma 3 implies that each link of ğ¹âˆ— is in ğ‘†âˆ—ğ‘„ for at most one ğ‘„âˆˆîˆ¼ and is in ğ‘…âˆ—ğ‘„ for at most ğ‘¤=ğ‘‚(logğ‘›) paths ğ‘„âˆˆîˆ¼. â—»

In the next section, we construct a nice deterministic algorithm. Together with Lemma 4 this gives a deterministic ğ‘‚(logğ‘›)-competitive algorithm for online tree augmentation, thus proving Theorem 1.

A Nice Algorithm for Online Path Augmentation
In this section, we devise a nice algorithm for online rooted path augmentation. In the following, we use the convention that the root of the path is the left endpoint of the path.

We begin by showing in Sect. 4.1 that it suffices to consider simpler instances that we call minimal instances. Then, we describe in Sect. 4.2 how to prove niceness using an LP for the problem. Finally, we describe and analyze the algorithm in Sects. 4.3 and 4.4.

Minimal Instances
The first step is a preprocessing step that simplifies the structure of the link set. In particular, before any requests arrive, we prune the set of links so that it is of the following type.

Definition 4
(Minimal Instances) A set of links L and its costs c are minimal if they satisfy the following properties:

1. for each class j,

there is at most one rooted link of cost within class j and

for every edge e, there are at most two links â„“ of class j with ğ‘’âˆˆğ‘ƒ(â„“);

2. for any two rooted links â„“ and â„“â€², if class(â„“)>class(â„“â€²), then ğ‘ƒ(â„“)âŠ‹ğ‘ƒ(â„“â€²).

An instance is minimal if its links and costs are minimal.

For a subset of links ğ¿â€²âŠ†ğ¿, we say that a solution ğ¹âŠ†ğ¿â€² is nice for ğ¿â€² if for any feasible solution ğ¹â€²âŠ†ğ¿â€², we have ğ‘(ğ¹)â‰¤ğ‘‚(1)ğ‘(ğ‘…â€²)+ğ‘‚(logğ‘›)ğ‘(ğ‘†â€²) where ğ‘…â€² is the set of rooted links and ğ‘†â€² is the set of non-rooted links of ğ¹â€², respectively. The following lemma says that if suffices to design a nice algorithm for a subset ğ¿â€² that is minimal.

Lemma 5
For any set of links L and its costs c, there is an efficiently computable subset ğ¿â€²âŠ†ğ¿ that is:

1.
Minimal;

2.
For any set of requests, the optimal solution restricted to ğ¿â€² costs at most 3 times the optimal solution using L; and

3.
Any solution that is nice for ğ¿â€² is also nice for L.

We now describe a pruning algorithm to compute ğ¿â€². Given a set of links L and its costs c, we prune L to get a minimal subset of links ğ¿â€²âŠ†ğ¿ as follows. We begin by pruning the rooted links: while there exists a rooted link â„“ and a rooted link â„“â€² of the same or lower class such that ğ‘ƒ(â„“â€²)âŠ‡ğ‘ƒ(â„“), remove â„“. Then we prune the non-rooted links for each class j: let ğ¿ğ‘— be the set of class j links and ğ¿â€²ğ‘— be a minimum-cardinality subset of ğ¿ğ‘— that covers ğ¿ğ‘—, i.e. ğ‘ƒ(ğ¿â€²ğ‘—)âŠ‡ğ‘ƒ(ğ¿ğ‘—); then, remove the links ğ¿ğ‘—âˆ–ğ¿â€²ğ‘—. Such a minimum cover may be computed efficiently using an algorithm for minimum cardinality interval cover [8]. The subset ğ¿â€² are the links that are not pruned away by the algorithm.

By construction, ğ¿â€² is minimal. We now turn to proving that it satisfies the other two properties claimed in Lemma 5. By minimality, we have that for any edge e, there are at most two links â„“,â„“â€²âˆˆğ¿â€²ğ‘— such that ğ‘’âˆˆğ‘ƒ(â„“)âˆ©ğ‘ƒ(â„“â€²). The following claim shows that any link â„“âˆˆğ¿ğ‘— that was pruned away can be replaced by at most three links of ğ¿â€²ğ‘— and so restricting to ğ¿â€² only causes the value of the optimal solution to increase by at most a factor of 3.

Claim 1
For every j and link â„“âˆˆğ¿ğ‘—âˆ–ğ¿â€²ğ‘—, there exists (at most) three links â„“1,â„“2,â„“3âˆˆğ¿â€²ğ‘— with ğ‘ƒ(â„“)âŠ†ğ‘ƒ(â„“1)âˆªğ‘ƒ(â„“2)âˆªğ‘ƒ(â„“3).

Proof
Suppose, towards a contradiction, that there exists a link â„“âˆˆğ¿ğ‘—âˆ–ğ¿â€²ğ‘— whose path ğ‘ƒ(â„“) can only be covered by at least four links of ğ¿â€²ğ‘—. Let ğ‘†âŠ†ğ¿â€²ğ‘— be a minimum-size cover of ğ‘ƒ(â„“) and let â„“1 be the link of S whose left endpoint is leftmost and â„“2 be the link of S whose right endpoint is rightmost. Consider a link â„“â€²âˆˆğ‘†âˆ–{â„“1,â„“2}âŠ†ğ¿â€²ğ‘—. By minimality of ğ¿â€²ğ‘—, we get that ğ‘ƒ(â„“â€²) is neither a subset of ğ‘ƒ(â„“1) nor ğ‘ƒ(â„“2). Thus, if ğ‘ƒ(â„“â€²) is not a subset of ğ‘ƒ(â„“), then we can discard either â„“1 or â„“2 from S to get a smaller cover of ğ‘ƒ(â„“). However, since S is a minimum-size cover of ğ‘ƒ(â„“), we get that ğ‘ƒ(â„“â€²) is a subset of ğ‘ƒ(â„“). So we have that the path of every link â„“â€²âˆˆğ‘†âˆ–{â„“1,â„“2} is contained in ğ‘ƒ(â„“).

Combining the above observation with the assumption that |ğ‘†|â‰¥4, this implies that swapping out ğ‘†âˆ–{â„“1,â„“2} from ğ¿â€²ğ‘— and replacing it with â„“ gives a smaller cover of ğ‘ƒ(ğ¿ğ‘—). However, this contradicts the fact that ğ¿â€²ğ‘— is a minimum cover of ğ‘ƒ(ğ¿ğ‘—). â—»

Claim 2
Any solution that is nice for ğ¿â€² is also nice for L.

Proof
Suppose ğ¹âˆ—âŠ†ğ¿ is a feasible solution. Let ğ‘…âˆ—âŠ†ğ¹âˆ— be its set of rooted links and ğ‘†âˆ—âŠ†ğ¹âˆ— be its set of non-rooted links. We now find a rooted link â„“ğ‘Ÿâˆˆğ¿â€² and a set of non-rooted links ğ‘†â€²âŠ†ğ¿â€² such that ğ¹â€²=ğ‘†â€²âˆª{â„“ğ‘Ÿ} is feasible and moreover, ğ‘(â„“ğ‘Ÿ)â‰¤ğ‘‚(1)ğ‘(ğ‘…âˆ—) and ğ‘(ğ‘†â€²)â‰¤ğ‘‚(1)ğ‘(ğ‘†âˆ—). Let â„“âˆˆğ‘…âˆ— be the link in ğ‘…âˆ— whose right endpoint is furthest from the root r. If â„“âˆˆğ¿â€², then we set â„“ğ‘Ÿ=â„“. Otherwise, by construction, there exists a rooted link â„“â€²âˆˆğ¿â€² of no higher class than â„“ and ğ‘ƒ(â„“â€²)âŠ‡ğ‘ƒ(â„“); then we set â„“ğ‘Ÿ=â„“â€². Observe that in both cases, ğ‘ƒ(â„“ğ‘Ÿ)âŠ‡ğ‘ƒ(ğ‘…âˆ—) and that ğ‘(â„“ğ‘Ÿ)â‰¤ğ‘(ğ‘…âˆ—). We now proceed with the construction of ğ‘†â€². We construct ğ‘†â€² iteratively, starting with ğ‘†â€²=âˆ…. Then, for each class j, we iterate over each class-j link â„“âˆˆğ‘†âˆ—: if â„“âˆˆğ¿â€²ğ‘—, then we add â„“ to ğ‘†â€² as well; otherwise, we add to ğ‘†â€² the (at most) three links guaranteed by Claim 1â„“1,â„“2,â„“3âˆˆğ¿â€²ğ‘— with ğ‘ƒ(â„“)âŠ†ğ‘ƒ(â„“1)âˆªğ‘ƒ(â„“2)âˆªğ‘ƒ(â„“3). Observe that ğ‘ƒ(ğ‘†â€²)âŠ‡ğ‘ƒ(ğ‘†âˆ—) and ğ‘(ğ‘†â€²)â‰¤3ğ‘(ğ‘†âˆ—). Since ğ‘ƒ(ğ‘†â€²âˆª{â„“ğ‘Ÿ})âŠ‡ğ‘ƒ(ğ¹âˆ—), we get that ğ¹â€² is feasible.

Finally, a solution F that is nice for ğ¿â€² satisfies

ğ‘(ğ¹)â‰¤ğ‘‚(1)ğ‘({â„“ğ‘Ÿ})+ğ‘‚(logğ‘›)ğ‘(ğ‘†â€²)â‰¤ğ‘‚(1)ğ‘(ğ‘…âˆ—)+ğ‘‚(logğ‘›)ğ‘(ğ‘†âˆ—),
and so it is also nice for L. â—»

This completes the proof of Lemma 5. Henceforth, we focus on devising a nice algorithm for minimal instances.

Proving Niceness via the Dual LP
Our algorithm uses the natural LP formulation of the problem. Let îˆ¾ be the set of requests. The following are the primal and dual LPs, respectively.

 minimize  subject  to âˆ‘â„“âˆˆğ¿ğ‘¥(â„“)ğ‘(â„“)âˆ‘â„“âˆˆcov(ğ‘’)ğ‘¥(â„“)â‰¥1ğ‘¥(â„“)â‰¥0âˆ€ğ‘’âˆˆîˆ¾âˆ€â„“âˆˆğ¿
(1)
 maximize  subject  to âˆ‘ğ‘’âˆˆîˆ¾ğ‘¦(ğ‘’)âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğ‘¦(ğ‘’)â‰¤ğ‘(â„“)ğ‘¦(ğ‘’)â‰¥0âˆ€â„“âˆˆğ¿âˆ€ğ‘’âˆˆîˆ¾
(2)
We say that a link â„“ is tight with respect to a dual solution y if âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğ‘¦(ğ‘’)=ğ‘(â„“).

The following lemma tells us how to use a dual solution y to prove that a primal solution F is nice. It says that F is nice if there is a dual solution y such that the cost of F is at most O(1) times the value of y, and if y violates the dual constraint for each non-rooted link by at most a factor of ğ‘‚(logğ‘›) and the dual constraint for each rooted link by at most a factor of O(1). Intuitively, for any feasible solution ğ¹âˆ—, the dual violation conditions lets us charge the value of the dual to ğ‘‚(logğ‘›) times the cost of the non-rooted links in ğ¹âˆ— and O(1) times the cost of the rooted links in ğ¹âˆ—.

Lemma 6
Let F be an integral solution to the primal LP and y be a solution to the dual LP such that

1.
ğ‘(ğ¹)â‰¤ğ‘‚(1)âˆ‘ğ‘’ğ‘¦(ğ‘’),

2.
âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğ‘¦(ğ‘’)â‰¤ğ‘‚(logğ‘›)ğ‘(â„“) for every non-rooted link â„“, and

3.
âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğ‘¦(ğ‘’)â‰¤ğ‘‚(1)ğ‘(â„“) for every rooted link â„“.

Then, F is a nice solution.

Proof
Let ğ¹âˆ— be a feasible solution, ğ‘…âˆ— be the subset of ğ¹âˆ— that is rooted and ğ‘†âˆ— the subset that is non-rooted. We now show that âˆ‘ğ‘’ğ‘¦(ğ‘’)â‰¤ğ‘‚(1)ğ‘(ğ‘…âˆ—)+ğ‘‚(logğ‘›)ğ‘(ğ‘†âˆ—), which then implies that ğ‘(ğ¹)â‰¤ğ‘‚(1)ğ‘(ğ‘…âˆ—)+ğ‘‚(logğ‘›)ğ‘(ğ‘†âˆ—). Since we have a dual variable y(e) for each request e and ğ¹âˆ— is feasible, we have that

âˆ‘ğ‘’ğ‘¦(ğ‘’)â‰¤âˆ‘ğ‘’âˆˆğ‘ƒ(ğ‘…âˆ—)ğ‘¦(ğ‘’)+âˆ‘ğ‘’âˆˆğ‘ƒ(ğ‘†âˆ—)ğ‘¦(ğ‘’).
Using the fact that âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğ‘¦(ğ‘’)â‰¤ğ‘‚(1)ğ‘(â„“) for every rooted link â„“, we also have

âˆ‘ğ‘’âˆˆğ‘ƒ(ğ‘…âˆ—)ğ‘¦(ğ‘’)â‰¤âˆ‘â„“âˆˆğ‘…âˆ—âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğ‘¦(ğ‘’)â‰¤ğ‘‚(1)ğ‘(ğ‘…âˆ—).
Similarly, we get that âˆ‘ğ‘’âˆˆğ‘ƒ(ğ‘†âˆ—)ğ‘¦(ğ‘’)â‰¤ğ‘‚(logğ‘›)ğ‘(ğ‘†âˆ—). Putting all of these together, we conclude that âˆ‘ğ‘’ğ‘¦(ğ‘’)â‰¤ğ‘‚(1)ğ‘(ğ‘…âˆ—)+ğ‘‚(logğ‘›)ğ‘(ğ‘†âˆ—), as desired. â—»

Algorithm
We now give some of the ideas behind our algorithm.

An ğ‘‚(logğ‘›)-competitive algorithm First, we describe a simple algorithm that constructs a solution F and a dual solution y that satisfies ğ‘(ğ¹)â‰¤ğ‘‚(1)âˆ‘ğ‘’ğ‘¦(ğ‘’) and âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğ‘¦(ğ‘’)â‰¤ğ‘‚(logğ‘›)ğ‘(â„“) for every link â„“. The algorithm maintains a maximal feasible dual solution y and is as follows: when a request ğ‘’ğ‘– arrives, raise its dual variable ğ‘¦(ğ‘’ğ‘–) until some link â„“ with ğ‘’ğ‘–âˆˆğ‘ƒ(â„“) goes tight; add this link to F. There are two parts to the analysis. First, let ğ¹Ë† be the set of links in F that cost at least maxâ„“âˆˆğ¹ğ‘(â„“)/ğ‘›2. Since |ğ¹|â‰¤ğ‘›2, we get that ğ‘(ğ¹)â‰¤2ğ‘(ğ¹Ë†) so it suffices to bound ğ‘(ğ¹Ë†). The second part of the analysis uses the following charging argument to bound ğ‘(ğ¹Ë†): whenever we add a tight link â„“ to ğ¹Ë†, we charge its cost to the dual variables y(e) for ğ‘’âˆˆğ‘ƒ(â„“). Let ğœ†(ğ‘’) be the total number of links charged to y(e) and ğ‘¦Ë† be the dual solution where ğ‘¦Ë†(ğ‘’)=ğœ†(ğ‘’)ğ‘¦(ğ‘’). We have ğ‘(ğ¹Ë†)â‰¤ğ‘‚(1)âˆ‘ğ‘’ğœ†(ğ‘’)ğ‘¦(ğ‘’). Now observe that ğœ†(ğ‘’)â‰¤ğ‘‚(logğ‘›) because Property 1 of minimal instances implies that there can be at most 2 links â„“âˆˆğ¹Ë† with ğ‘’âˆˆğ‘ƒ(â„“) for a single cost class, and, by definition, ğ¹Ë† can have at most ğ‘‚(logğ‘›) cost classes. So, for each link â„“, we have

âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†(ğ‘’)ğ‘¦(ğ‘’)â‰¤ğ‘‚(logğ‘›)âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğ‘¦(ğ‘’)â‰¤ğ‘‚(logğ‘›)ğ‘(â„“)
where the last inequality follows from the fact that y is feasible.

Saving the rooted links A natural idea to ensure that âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†(ğ‘’)ğ‘¦(ğ‘’)â‰¤ğ‘‚(1)ğ‘(â„“) for each rooted link â„“ is to modify the above algorithm to explicitly take into account the charging method as follows: after buying a tight link (we call this a type-1 link), if there is a rooted link â„“â€² such that âˆ‘ğ‘’âˆˆğ‘ƒ(â„“â€²)ğœ†(ğ‘’)ğ‘¦(ğ‘’)>ğ‘(â„“â€²), buy the one of highest class among such links (we call this a type-2 link). Moreover, we also modify the charging method to only charge each type-1 link â„“ to the dual variables y(e) for ğ‘’âˆ‰ğ‘ƒ(â„“â€²) where â„“â€² is the last type-2 link bought.

As we will see, these modifications let us to argue that âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†(ğ‘’)ğ‘¦(ğ‘’)â‰¤ğ‘‚(1)ğ‘(â„“) for each rooted link â„“. However, it also introduces a complication: it might be possible that for some type-1 link â„“, most of the dual variables y(e) paying towards its cost have ğ‘’âˆˆğ‘ƒ(â„“â€²) where â„“â€² is the last type-2 link bought. Since the charging method only charges to dual variables y(e) for ğ‘’âˆ‰ğ‘ƒ(â„“â€²), this would mean that it might charge an amount that is much less than the cost of â„“â€².

Fixing the complication To fix the above issue, whenever we buy a type-2 link â„“â€², we also buy all links â„“â€³ of class at most class(â„“â€²) that crosses â„“â€², i.e. âˆ…âŠŠğ‘ƒ(â„“â€³)âˆ©ğ‘ƒ(â„“â€²)âŠŠğ‘ƒ(â„“â€²). Property 1 implies that the total cost of these links is at most ğ‘‚(1)ğ‘(â„“â€²). We call these links type-3 links. This ensures that later on, when we buy a type-1 link â„“, if ğ‘ƒ(â„“)âˆ©ğ‘ƒ(â„“â€²)â‰ âˆ…, then â„“ must be of higher class than â„“â€² and thus most of its cost is paid for by dual variables y(e) for ğ‘’âˆ‰ğ‘ƒ(â„“â€²).

We describe the complete algorithm formally in Algorithm 1. In Algorithm 1, we use Z to keep track of ğ‘ƒ(â„“) where â„“ is the last type-2 link bought so far (ğ‘=âˆ… if no type-2 link is bought yet). The links bought in Step 4, 9, 11, are type-1, type-2, and type-3 links, respectively.

Analysis of Algorithm
We now prove that Algorithm 1 is nice. Let ğ¹1,ğ¹2,ğ¹3âŠ†ğ¹ be the sets of type-1, type-2 and type-3 links, respectively. The proof consists of three steps. First, we show that ğ‘(ğ¹)â‰¤ğ‘‚(1)ğ‘(ğ¹1) (Lemma 7) and thus it suffices to bound the cost of type-1 links. Then, we construct a dual solution ğ‘¦Ë† that accounts for the cost of type-1 links (Lemma 8). This shows that ğ‘¦Ë† satisfies the first condition of Lemma 6. Finally, Lemmas 10 and 9 show that ğ‘¦Ë† satisfies the remaining conditions of Lemma 6.

figure a
For each type-1 link â„“âˆˆğ¹1, define ğ¶(â„“) to be the set of edges e such that ğœ†(ğ‘’) was incremented during the iteration that â„“ was assigned to ğ¹1, i.e. each dual variable y(e) for ğ‘’âˆˆğ¶(â„“) contributes towards paying ğ‘(â„“). Observe that ğœ†(ğ‘’)=|{â„“:ğ‘’âˆˆğ¶(â„“)}| and ğ¶(â„“)âŠ†ğ‘ƒ(â„“).

Proposition 1
Algorithm 1 satisfies the following properties. Let ğ‘ğ‘– and ğœ†ğ‘– denote Z and ğœ† at the end of the i-th iteration. Then, for every iteration i, we have

1.
ğ‘ğ‘–âŠ‡ğ‘ğ‘–âˆ’1;

2.
If ğ‘¦(ğ‘’ğ‘–)>0, then ğœ†ğ‘–(ğ‘’ğ‘–)>0.

Proof
The first follows from Property 2 of minimal instances. The second follows from the fact that in the iteration that ğ‘’ğ‘– arrives, since it is unsatisfied, it must not be contained in Z. Let â„“ be the link added to F in that iteration. Since ğ‘’ğ‘–âˆˆğ‘ƒ(â„“)âˆ–ğ‘ and ğ‘¦(ğ‘’ğ‘–)>0, we have that ğœ†(ğ‘’ğ‘–) is increased by 1 during the iteration and thus ğœ†ğ‘–(ğ‘’ğ‘–)>0. â—»

Lemma 7
ğ‘(ğ¹)â‰¤ğ‘‚(ğ‘(ğ¹1)).

Proof
We will show that ğ‘(ğ¹3)â‰¤ğ‘‚(1)ğ‘(ğ¹2), that ğ‘(ğ¹2)â‰¤ğ‘‚(1)âˆ‘ğ‘’ğœ†(ğ‘’)ğ‘¦(ğ‘’) and that âˆ‘ğ‘’ğœ†(ğ‘’)ğ‘¦(ğ‘’)â‰¤ğ‘(ğ¹1). Let â„“ğ‘Ÿ be the last type-2 link bought. We have that ğ‘(â„“ğ‘Ÿ)â‰¤âˆ‘ğ‘’âˆˆğ‘ƒ(â„“ğ‘Ÿ)ğœ†(ğ‘’)ğ‘¦(ğ‘’) by construction. Moreover, since ğ‘(â„“ğ‘Ÿ)â‰¥ğ‘(â„“) for every â„“âˆˆğ¹2 and there is at most one rooted link of each class, we get that ğ‘(ğ¹2)â‰¤2ğ‘(â„“ğ‘Ÿ). Thus, we get that ğ‘(ğ¹2)â‰¤2âˆ‘ğ‘’âˆˆğ‘ƒ(â„“ğ‘Ÿ)ğœ†(ğ‘’)ğ‘¦(ğ‘’). For each type-2 link â„“ bought, we buy at most two type-3 links per class ğ‘—â‰¤class(â„“) because of Property 1 of minimal instances. Therefore, we have ğ‘(ğ¹3)â‰¤2ğ‘(ğ¹2)â‰¤4âˆ‘ğ‘’âˆˆğ‘ƒ(â„“ğ‘Ÿ)ğœ†(ğ‘’)ğ‘¦(ğ‘’).

Finally, we show that âˆ‘ğ‘’ğœ†(ğ‘’)ğ‘¦(ğ‘’)â‰¤ğ‘(ğ¹1). Since ğœ†(ğ‘’)=|{â„“:ğ‘’âˆˆğ¶(â„“)}|, we have

âˆ‘ğ‘’ğœ†(ğ‘’)ğ‘¦(ğ‘’)=âˆ‘â„“âˆˆğ¹1(âˆ‘ğ‘’âˆˆğ¶(â„“)ğ‘¦(ğ‘’)).
Now, since ğ¶(â„“)âŠ†ğ‘ƒ(â„“) and y is feasible, we get

âˆ‘ğ‘’âˆˆğ¶(â„“)ğ‘¦(ğ‘’)â‰¤âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğ‘¦(ğ‘’)â‰¤ğ‘(â„“).
Combining the previous two inequalities gives us that âˆ‘ğ‘’ğœ†(ğ‘’)ğ‘¦(ğ‘’)â‰¤ğ‘(ğ¹1). â—»

Let ğ‘max=maxâ„“âˆˆğ¹1ğ‘(â„“). Define ğ¹Ë†1={â„“âˆˆğ¹1:ğ‘(â„“)â‰¥ğ‘max/ğ‘›2} and ğœ†Ë†(ğ‘’)=|{â„“âˆˆğ¹Ë†1:ğ‘’âˆˆğ¶(â„“)}|. We now show that F and the dual solution ğ‘¦Ë† where ğ‘¦Ë†(ğ‘’)=ğœ†Ë†(ğ‘’)ğ‘¦(ğ‘’) satisfies the conditions of Lemma 6.

Lemma 8
ğ‘(ğ¹1)â‰¤ğ‘‚(1)âˆ‘ğ‘’ğœ†Ë†(ğ‘’)ğ‘¦(ğ‘’).

Proof
Observe that ğ‘(ğ¹1)â‰¤2ğ‘(ğ¹Ë†1) so it suffices to prove that

ğ‘(ğ¹Ë†1)â‰¤ğ‘‚(1)âˆ‘ğ‘’ğœ†Ë†(ğ‘’)ğ‘¦(ğ‘’).
(3)
We now show that this inequality holds at the end of each iteration of the algorithm. Consider an iteration in which the current request ğ‘’ğ‘– is not already covered and suppose â„“âˆˆğ¹Ë†1 is the type-1 link bought in this iteration. The LHS of Inequality (3) increases by ğ‘(â„“) in this iteration. We now show that âˆ‘ğ‘’ğœ†Ë†(ğ‘’)ğ‘¦(ğ‘’) increases by at least ğ‘(â„“)/2. In this iteration, ğœ†Ë†(ğ‘’) increases by 1 for every ğ‘’âˆˆğ‘ƒ(â„“)âˆ–ğ‘ and ğ‘¦(ğ‘’)>0, and so âˆ‘ğ‘’ğœ†Ë†(ğ‘’)ğ‘¦(ğ‘’) increases by exactly âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)âˆ–ğ‘ğ‘¦(ğ‘’).

In the remainder of the proof, we show that âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)âˆ–ğ‘ğ‘¦(ğ‘’)â‰¥ğ‘(â„“)/2. If ğ‘ƒ(â„“)âˆ©ğ‘=âˆ…, then âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)âˆ–ğ‘ğ‘¦(ğ‘’)=âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğ‘¦(ğ‘’)=ğ‘(â„“) since â„“ is tight. Now suppose ğ‘ƒ(â„“)âˆ©ğ‘â‰ âˆ…. Let â„“â€² be the type-2 link such that ğ‘=ğ‘ƒ(â„“â€²). Since ğ‘ƒ(â„“)âˆ©ğ‘ƒ(â„“â€²)â‰ âˆ…, it must be the case that â„“ is of type higher than class(â„“â€²). This is because otherwise, â„“ would have been bought earlier as a type-3 link in the same iteration as â„“â€². But then since ğ‘’ğ‘–âˆˆğ‘ƒ(â„“), it would contradict the assumption that ğ‘’ğ‘– is not already covered at the start of the current iteration. Thus, class(â„“)>class(â„“â€²) and so ğ‘(â„“)â‰¥2ğ‘(â„“â€²). So, we now have

âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)âˆ–ğ‘ğ‘¦(ğ‘’)â‰¥âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğ‘¦(ğ‘’)âˆ’âˆ‘ğ‘’âˆˆğ‘ƒ(â„“â€²)ğ‘¦(ğ‘’)â‰¥ğ‘(â„“)âˆ’ğ‘(â„“â€²)â‰¥ğ‘(â„“)/2,
where the second last inequality follows from the fact that y is a feasible dual and â„“ is tight. Therefore, Inequality (3) holds at the end of each iteration, as desired. â—»

Lemmas 7 and 8 imply that ğ‘(ğ¹)â‰¤ğ‘‚(1)âˆ‘ğ‘’ğ‘¦Ë†(ğ‘’).

Lemma 9
For each non-rooted link â„“, we have âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†Ë†(ğ‘’)ğ‘¦(ğ‘’)â‰¤ğ‘‚(logğ‘›)ğ‘(â„“).

Proof
Property 1 of minimal instances implies that for each j, there are at most two links â„“â€²âˆˆğ¹Ë†1 of class j with ğ‘’âˆˆğ¶(â„“â€²). Since each link in ğ¹Ë†1 has cost between ğ‘max/ğ‘›2 and ğ‘max and link costs are powers of 2, we have that ğœ†Ë†(ğ‘’)â‰¤ğ‘‚(logğ‘›). Thus we get that âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†Ë†(ğ‘’)ğ‘¦(ğ‘’)â‰¤ğ‘‚(logğ‘›)âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğ‘¦(ğ‘’)â‰¤ğ‘‚(logğ‘›)ğ‘(â„“), where the last inequality follows from the fact that y is a feasible dual. â—»

Lemma 10
For each rooted link â„“, we have âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†Ë†(ğ‘’)ğ‘¦(ğ‘’)â‰¤ğ‘‚(1)ğ‘(â„“).

Proof
We will in fact show that âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†(ğ‘’)ğ‘¦(ğ‘’)â‰¤ğ‘‚(1)ğ‘(â„“). Suppose, at the end of some iteration, that we have âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†(ğ‘’)ğ‘¦(ğ‘’)>ğ‘(â„“). Consider the earliest iteration that this happens. We now show that âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†(ğ‘’)ğ‘¦(ğ‘’)â‰¤ğ‘‚(1)ğ‘(â„“) at the end of the iteration and later show that the LHS cannot increase in future iterations.

Let ğœ†old(ğ‘’) and ğ‘¦old(ğ‘’) denote the values of ğœ†(ğ‘’) and y(e) at the start of the iteration and ğœ†new(ğ‘’) and ğ‘¦new(ğ‘’) denote their values at the end. We have that

âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†old(ğ‘’)ğ‘¦old(ğ‘’)<ğ‘(â„“).
We now show that

âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†new(ğ‘’)ğ‘¦new(ğ‘’)â‰¤3ğ‘(â„“).
Let ğ‘’ğ‘– be the request of the current iteration. During this iteration, we only increase y(e) for ğ‘’=ğ‘’ğ‘– and we set ğœ†(ğ‘’ğ‘–)=1 so ğœ†new(ğ‘’ğ‘–)ğ‘¦new(ğ‘’ğ‘–)=ğ‘¦(ğ‘’ğ‘–). So, we have

âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†new(ğ‘’)ğ‘¦new(ğ‘’)=âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)âˆ–{ğ‘’ğ‘–}ğœ†new(ğ‘’)ğ‘¦old(ğ‘’)+ğ‘¦(ğ‘’ğ‘–).
Since y is a feasible dual, we have that ğ‘¦(ğ‘’ğ‘–)â‰¤ğ‘(â„“). Now, Proposition 1 implies that ğœ†old(ğ‘’)â‰¥1 if ğ‘¦old(ğ‘’)>0. Together with the fact that ğœ†new(ğ‘’)â‰¤ğœ†old(ğ‘’)+1, we get that ğœ†new(ğ‘’)ğ‘¦old(ğ‘’)â‰¤2ğœ†old(ğ‘’)ğ‘¦old(ğ‘’) and so

âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)âˆ–{ğ‘’ğ‘–}ğœ†new(ğ‘’)ğ‘¦new(ğ‘’)â‰¤2âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)âˆ–{ğ‘’ğ‘–}ğœ†old(ğ‘’)ğ‘¦old(ğ‘’)<2ğ‘(â„“).
Thus, âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†new(ğ‘’)ğ‘¦new(ğ‘’)â‰¤3ğ‘(â„“) at the end of the current iteration.

Finally, we show that âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†(ğ‘’)ğ‘¦(ğ‘’) does not increase in future iterations. At the end of the current iteration, â„“ is a candidate to be added to F. Among all candidates, the one with highest class is added, so either â„“ is added to F or a rooted link â„“â€² of higher class is added to F. In the second case, by Proposition 1, we have ğ‘ƒ(â„“â€²)âŠ‡ğ‘ƒ(â„“). Thus, in either case, we have that ğ‘âŠ‡ğ‘ƒ(â„“) at the end of the current iteration. Moreover, in future iterations, we still have ğ‘âŠ‡ğ‘ƒ(â„“) by Proposition 1. Therefore, âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†(ğ‘’)ğ‘¦(ğ‘’) does not increase in future iterations. Thus, we conclude that âˆ‘ğ‘’âˆˆğ‘ƒ(â„“)ğœ†(ğ‘’)ğ‘¦(ğ‘’)â‰¤3ğ‘(â„“) at the end of the algorithm. â—»

Therefore, we conclude that Algorithm 1 is nice. Together with Lemma 4, we get Theorem 1.

Lower Bound for Online Path Augmentation
In this section, we prove Theorem 2.

Let B be a constant to be fixed later. Consider the path with n edges and ğ‘›+1 vertices where n is a power of 2B. In the following, for ğ‘–âˆˆ{0,â€¦,ğ‘›}, we write ğ‘£ğ‘– as the i-th vertex of the path with ğ‘£0 being the leftmost vertex. We have log2ğµğ‘› classes of links. Each link â„“ of class j has cost ğµğ‘— and path length |ğ‘ƒ(â„“)|=(2ğµ)ğ‘—; moreover, the class j links are disjoint, i.e. for any â„“,â„“â€² of class j, we have ğ‘ƒ(â„“)âˆ©ğ‘ƒ(â„“â€²)=âˆ…, and they cover the entire path. In particular, each link â„“ of class j is of the form â„“=(ğ‘–â‹…(2ğµ)ğ‘—,(ğ‘–+1)â‹…(2ğµ)ğ‘—) for some ğ‘–âˆˆ{0,â€¦,ğ‘›(2ğµ)ğ‘—âˆ’1}. We say that a link â„“ contains another link â„“â€² if ğ‘ƒ(â„“)âŠ‡ğ‘ƒ(â„“â€²). Note that the links form a hierarchical structure: a link â„“ of class j contains 2B links of class ğ‘—âˆ’1; we call the latter child links of â„“, and â„“ their parent link. We also say that the set of minimal links (i.e. those at the bottom of the hierarchical structure) are leaf links. Note that these correspond exactly to the edges of the path.

We say that an algorithm is canonical if for each request e, if it buys a class j link â„“, then for each class ğ‘—â€²<ğ‘—, it also buys the unique link â„“â€² which has ğ‘’âˆˆğ‘ƒ(â„“â€²)âŠ†ğ‘ƒ(â„“). Since the costs are geometric, it is easy to see that we can make any algorithm canonical and lose only a constant factor in the competitive ratio. Thus, it suffices to prove a lower bound against canonical algorithms.

Lemma 11
For every ğµâ‰¥2, every canonical algorithm ğ– ğ–«ğ–¦ has competitive ratio at least ğ›º(logğµğ‘›).

Proof
Consider the following sequence of requests: while there exists an edge that is not yet covered by ğ– ğ–«ğ–¦, the adversary gives as the next request the leftmost edge that is not yet covered. Let R be the sequence of requests in this instance and F be the set of links bought by ğ– ğ–«ğ–¦. The plan is to show that for each class j, there exists a feasible solution ğ¹â€²ğ‘— consisting only of class j links and that âˆ‘ğ‘—ğ‘(ğ¹â€²ğ‘—)â‰¤2ğ‘(ğ¹). This would imply that OPTâ‰¤2ğ‘(ğ¹)/log2ğµğ‘› and thus imply the lemma.

For each class j, define the set ğ¹â€²ğ‘— to be the links â„“ of class j such that there exists a request that is contained in ğ‘ƒ(â„“). Let ğ¹â€²=â‹ƒğ‘—ğ¹â€²ğ‘—. Clearly, each ğ¹â€²ğ‘— is a feasible solution. It remains to show that ğ‘(ğ¹â€²)â‰¤2ğ‘(ğ¹). To do this, we now prove that ğ‘(ğ¹â€²âˆ–ğ¹)â‰¤ğ‘(ğ¹). The following claim will be useful. It says that if a link â„“ has ğ‘ƒ(â„“) containing some request e and â„“ was not chosen by the algorithm, then it must be the case that each child link â„“â€² of â„“ has ğ‘ƒ(â„“â€²) containing some request ğ‘’â€². â—»

Claim 3
For each non-leaf link â„“âˆˆğ¹â€²âˆ–ğ¹, every child link â„“â€² of â„“ is in ğ¹â€² as well.

Proof
We need to show that for each child link â„“â€² of â„“, there exists a request ğ‘’âˆˆğ‘ƒ(â„“â€²). Since â„“âˆ‰ğ¹ and the algorithm is canonical, it must be the case that for each request ğ‘’âˆˆğ‘…âˆ©ğ‘ƒ(â„“), when the request e arrived, the algorithm covered it using a link that is strictly contained in â„“. Thus, by construction of the request sequence, we have that for each child link â„“â€² of â„“, there exists a request contained in ğ‘ƒ(â„“â€²) and so by definition of ğ¹â€², we have that â„“â€²âˆˆğ¹â€². â—»

We use a token-based argument to prove that ğ‘(ğ¹â€²âˆ–ğ¹)â‰¤ğ‘(ğ¹). There will be two types of tokens: original tokens and virtual tokens. Each token a has a value v(a); moreover, if a is virtual, then it is also associated with a parent token p(a) (which may be either an original or virtual token) and we say that a is a child token of p(a). Initially, there are no tokens. For each link â„“âˆˆğ¹, we give it an original token of value ğ‘(â„“). We will now create virtual tokens to pay for links in ğ¹â€²âˆ–ğ¹. We say that a link â„“âˆˆğ¹â€²âˆ–ğ¹ is paid for if it has tokens of value at least ğ‘(â„“). We create virtual tokens iteratively in a bottom-up manner: While there exists a link in ğ¹â€²âˆ–ğ¹ that is not paid for, let â„“ be the link of smallest class in ğ¹â€²âˆ–ğ¹ that is not paid for; then, for each token a associated with a child link of â„“, we create and give to â„“ a virtual token ğ‘â€² with ğ‘£(ğ‘â€²)=ğ‘£(ğ‘)/2 and ğ‘(ğ‘â€²)=ğ‘. We now argue that in each iteration of this procedure, â„“ is paid for. First, observe that â„“ cannot be a leaf link (and thus the above procedure is actually valid). By definition of ğ¹â€², the links in ğ¹â€² that are leaf links correspond exactly to the set of requested edges. Since the algorithm is canonical, these links are also in F and are thus paid for. Therefore, â„“ is not a leaf link; moreover, the above claim implies that each of its 2B child links are in ğ¹â€². Since â„“ is the link of smallest class that is not paid for, its child links are already paid for so they have tokens of total value at least 2ğµâ‹…ğµğ‘—âˆ’1=2ğµğ‘—. Therefore, we get that the tokens given to â„“ have value at least ğµğ‘— and so â„“ is now paid for.

Since each link of ğ¹â€²âˆ–ğ¹ is paid for by virtual tokens, we get that ğ‘(ğ¹â€²âˆ–ğ¹) is at most the value of virtual tokens. We now argue that the total value of the virtual tokens is at most the value of the original tokens. Note that each token, virtual or original, can have at most one child token. Moreover, every virtual token is a descendant of an original token. Finally, the value of a virtual token is half its parent tokenâ€™s value. Putting the above together, we get that for each original token of value ğµğ‘—, the total value of its descendant virtual tokens is at most âˆ‘ğ‘–â‰¥1ğµğ‘—/2ğ‘–â‰¤ğµğ‘—. Therefore, the total value of virtual tokens is at most the total value of original tokens. Since the value of the original tokens is exactly c(F), we get that ğ‘(ğ¹â€²âˆ–ğ¹)â‰¤ğ‘(ğ¹), as desired. This completes the proof of the lemma. â—»

Using ğµ=2 in the above lemma gives us Theorem 2.

A Fractional Algorithm for Online Path Augmentation
In this section, we prove Theorem 3. We begin by defining the online fractional path augmentation problem formally. We have variables ğ‘¥(â„“) for each link â„“ which represent the fraction of â„“ that we have bought so far. Initially, ğ‘¥(â„“)=0 for every â„“. Then, when a request ğ‘’ğ‘– arrives, we need to increase variables so that âˆ‘â„“:ğ‘’ğ‘–âˆˆğ‘ƒ(â„“)ğ‘¥(â„“)â‰¥1. Moreover, variables cannot be decreased. The cost of a fractional solution x is âˆ‘â„“ğ‘¥(â„“)ğ‘(â„“). The goal is to maintain a feasible fractional solution with low cost. Equivalently, we can think of the online fractional problem in terms of solving LP (1) online: the constraints of the LP arrive one by one, and we need to maintain a feasible fractional solution.

Throughout this section, we assume that we are working with minimal instances as defined in Sect. 4. In general, the fractional version of an optimization problem can admit a much better solution than the integral version. It turns out that for the path augmentation problem, to be competitive against any fractional solution, it suffices to be competitive against any integral solution.

Lemma 12
(Integrality of LP (1)) For any instance of path augmentation, there is an optimal solution to LP (1) that is integral.

Proof
The rows of the constraint matrix of LP (1) satisfy the consecutive-ones property. Thus the constraint matrix is totally unimodular and the LP (1) is integral (see Lee [15, Chapter 0.8]). â—»

Henceforth, we will use OPT to denote the value of an optimal integral solution and our goal is to be competitive against OPT.

Let us first sketch a simple algorithm assuming that we are given the value of OPT at the beginning. Since OPT is the value of an optimal integral solution, we first remove all links of cost more than OPT without loss of generality. We say that a request ğ‘’ğ‘– is small if it can be covered by a link of cost at most OPT/ğ‘›, and large otherwise. We handle small and large requests differently. For each small request ğ‘’ğ‘–, we set ğ‘¥(â„“)=1 where â„“ is the link of cost at most OPT/ğ‘› covering ğ‘’ğ‘–. We use the online fractional set cover algorithm of [1] to deal with large requests.

Let us now analyze this algorithm. The incremental cost incurred in serving a request is the increase in the algorithmâ€™s cost when it serves the request. The total incremental cost incurred in serving small requests is at most OPT since the incremental cost for each small request is at most OPT/ğ‘› and there can be at most n requests total (one request per edge of the path). What about the total incremental cost for large requests? The online fractional set cover algorithm of [1] has a competitive ratio of ğ‘‚(logğ‘‘) if each element is contained in at most d sets. Thus, to show that the total incremental cost for large requests is at most ğ‘‚(loglogğ‘›)OPT, it suffices to prove that each large request is covered by at most 2logğ‘› links. Consider a large request ğ‘’ğ‘–. Since we had removed links of cost more than OPT and ğ‘’ğ‘– is large, it is covered only by links of cost between OPT/ğ‘› and OPT. Moreover, since costs are powers of 2, by Property 1 of minimal instances, ğ‘’ğ‘– is covered by at most logğ‘› links.

We now describe our online fractional path augmentation algorithm that does not need to know the value of OPT upfront. Let OPTğ‘– denote the cost of the optimal integral solution for the first i requests ğ‘’1,â€¦,ğ‘’ğ‘–; Lemma 12 implies that OPTğ‘– can be found by computing a basic feasible solution of LP (1). For each request ğ‘’ğ‘–, if ğ‘’ğ‘– can be covered by a link â„“ of cost at most OPTğ‘–/ğ‘›, then we set the variable ğ‘¥(â„“)=1; otherwise, we perform multiplicative update as follows. Let ğ¿ğ‘–={â„“:ğ‘’ğ‘–âˆˆğ‘ƒ(â„“)âˆ§ğ‘(â„“)âˆˆ[OPTğ‘–/ğ‘›,2OPTğ‘–]}. The multiplicative update step does the following: while âˆ‘â„“âˆˆğ¿ğ‘–ğ‘¥â„“<1, for each â„“âˆˆğ¿ğ‘–, increase ğ‘¥(â„“) continuously at the rate

ğ‘‘ğ‘¥(â„“)ğ‘‘ğ‘¡=ğ‘¥(â„“)+1/logğ‘›ğ‘(â„“).
As before, we say that request ğ‘’ğ‘– is small if there exists a link of cost at most OPTğ‘–/ğ‘› covering it, and large otherwise.

Lemma 13
The solution x computed by the online fractional path augmentation algorithm above has cost ğ‘‚(loglogğ‘›)OPT.

Proof
It is easy to see that again, the total incremental cost incurred in serving small requests is at most OPT. However, bounding the total incremental cost incurred in serving large requests requires more work. Say that an integral solution F is restricted if for every large request ğ‘’ğ‘–, there is a link in F covering ğ‘’ğ‘– that is also in ğ¿ğ‘–, i.e. F is feasible even if ğ‘’ğ‘– is restricted to be covered only by links in ğ¿ğ‘–. Since costs are powers of 2, Property 1 of minimal instances implies that |ğ¿ğ‘–|â‰¤ğ‘‚(logğ‘›) and so, as before, the analysis in [1] implies that the total incremental cost incurred in serving large requests is at most ğ‘‚(loglogğ‘›)ğ‘(ğ¹) for every restricted solution F. It remains to show that there exists a restricted solution F with cost at most ğ‘‚(OPT).

Define phase j of the algorithm to consist of the time steps i for which OPTğ‘–âˆˆ[2ğ‘—,2ğ‘—+1) and i(j) to be the last time step of phase j. Let OPTğ‘—=OPTğ‘–(ğ‘—), the value of an optimal integral solution ğ¹âˆ—ğ‘— for the requests seen by the end of phase j. For each large request ğ‘’ğ‘– in phase j, since OPTğ‘—<2OPTğ‘– and ğ¹âˆ—ğ‘— is integral, it must be the case that ğ‘’ğ‘– is covered by ğ¹âˆ—ğ‘— using a link in ğ¿ğ‘–. Let ğ¹Ì‚ ğ‘— be the subset of ğ¹âˆ—ğ‘— that covers the large requests of phase j. Therefore, we get that ğ¹=â‹ƒğ‘—ğ¹Ì‚ ğ‘— is a restricted solution. The cost of F is ğ‘(ğ¹)â‰¤âˆ‘ğ‘—â‰¤ğ‘š2ğ‘—+1â‰¤2ğ‘š+2, where m is the final phase. Since OPT=OPTğ‘šâ‰¥2ğ‘š, we have that ğ‘(ğ¹)â‰¤4OPT. This proves that there exists a restricted solution F with cost at most ğ‘‚(OPT). Therefore, we conclude that x has cost at most ğ‘‚(loglogğ‘›)OPT. â—»

This proves Theorem 3.

Conclusion and Open Problems
We gave a deterministic algorithm for online WTAP with competitive ratio ğ‘‚(logğ‘›). Plugging this algorithm into the algorithm of [10] gives a randomized ğ‘‚Ìƒ (log2ğ‘›)-competitive algorithm for online survivable network design for the setting where ğ‘Ÿmax=2. The main open problem is whether the competitive ratio for the online survivable network design problem can be improved. For general ğ‘Ÿmax, the current best upper bound is randomized ğ‘‚Ìƒ (ğ‘Ÿmaxlog3ğ‘›) and the current best lower bound is ğ›º(logğ‘›) against randomized algorithms [10]. The lower bound also holds when ğ‘Ÿmax=2.

For WPAP, we showed that the deterministic competitive ratio is Î˜(logğ‘›). It remains open whether it is possible to achieve a randomized competitive ratio of ğ‘‚(loglogğ‘›). For the special case of the online parking permit problem, [16] gave a randomized ğ‘‚(loglogğ‘›)-competitive algorithm and a lower bound of ğ›º(loglogğ‘›) against randomized algorithms. We gave a fractional ğ‘‚(loglogğ‘›)-competitive algorithm for WPAP and conjecture that it is possible to obtain a randomized rounding algorithm for our fractional algorithm that only loses a constant factor in the rounding.