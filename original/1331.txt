A bipartite graph ğº=(ğ‘ˆ,ğ‘‰,ğ¸) is convex if the vertices in V can be linearly ordered such that for each vertex ğ‘¢âˆˆğ‘ˆ, the neighbors of u are consecutive in the ordering of V. An induced matching H of G is a matching for which no edge of E connects endpoints of two different edges of H. We show that in a convex bipartite graph with n vertices and m weighted edges, an induced matching of maximum total weight can be computed in ğ‘‚(ğ‘›+ğ‘š) time. An unweighted convex bipartite graph has a representation of size O(n) that records for each vertex ğ‘¢âˆˆğ‘ˆ the first and last neighbor in the ordering of V. Given such a compact representation, we compute an induced matching of maximum cardinality in O(n) time. In convex bipartite graphs, maximum-cardinality induced matchings are dual to minimum chain covers. A chain cover is a covering of the edge set by chain subgraphs, that is, subgraphs that do not contain induced matchings of more than one edge. Given a compact representation, we compute a representation of a minimum chain cover in O(n) time. If no compact representation is given, the cover can be computed in ğ‘‚(ğ‘›+ğ‘š) time. All of our algorithms achieve optimal linear running time for the respective problem and model, and they improve and generalize the previous results in several ways: The best algorithms for the unweighted problem versions had a running time of ğ‘‚(ğ‘›2) (BrandstÃ¤dt et al. in Theor. Comput. Sci. 381(1â€“3):260â€“265, 2007. https://doi-org.ezproxy.auckland.ac.nz/10.1016/j.tcs.2007.04.006). The weighted case has not been considered before.

Introduction
A bipartite graph ğº=(ğ‘ˆ,ğ‘‰,ğ¸) is convex if the vertices in V can be numbered as 1,2,â€¦,ğ‘›ğ‘‰ so that the neighbors of every vertex ğ‘–âˆˆğ‘ˆ form an interval {ğ¿ğ‘–,ğ¿ğ‘–+1,ğ¿ğ‘–+2,â€¦,ğ‘…ğ‘–}âŠ†{1,2,â€¦,ğ‘›ğ‘‰}, which we denote by [ğ¿ğ‘–,ğ‘…ğ‘–], see Fig. 1a. For such graphs, we consider the problem of computing an induced matching (a) of maximum cardinality or (b) of maximum total weight, for graphs with edge weights.

Fig. 1
figure 1
a A convex bipartite graph ğº=(ğ‘ˆ,ğ‘‰,ğ¸) containing an induced matching H of size 3, highlighted in red. Since we use natural numbers as elements of U and V, we will explicitly indicate whether we regard a number x as a vertex of U or of V. There is no induced matching with more than 3 edges: vertex 3âˆˆğ‘ˆ is adjacent to all vertices of V except 1âˆˆğ‘‰. Thus, if we match 3âˆˆğ‘ˆ, this can only lead to induced matchings of size at most 2. Furthermore, we cannot simultaneously match 1âˆˆğ‘ˆ and 2âˆˆğ‘ˆ since every neighbor of 2âˆˆğ‘ˆ is also adjacent to 1âˆˆğ‘ˆ. b A minimum chain cover of G with 3 chain subgraphs ğ‘1,ğ‘2,ğ‘3 (in different colors and dash styles), providing an independent proof that H is optimal. Here, ğ‘1,ğ‘2,ğ‘3 have disjoint edge sets, which is not necessarily the case in general. c The compact representation of G

Full size image
An induced matching ğ»âŠ†ğ¸ is a matching such that the subgraph of G induced by the matched vertices has H as its edge set. This amounts to requiring that no edge of E connects endpoints of two different edges of H, see Fig. 1a. More formally, a set ğ»âŠ†ğ¸ is an induced matching in G if for any two distinct edges (ğ‘,ğ‘),(ğ‘â€²,ğ‘â€²)âˆˆğ», the four vertices ğ‘,ğ‘,ğ‘â€²,ğ‘â€² are pairwise distinct, and none of the edges ğ‘ğ‘â€²,ğ‘ğ‘â€²,ğ‘ğ‘â€²,ğ‘ğ‘â€² is present in E.

In terms of the line graph, an induced matching is an independent set in the square of the line graph. The square of a graph connects every pair of nodes whose distance is one or two. Accordingly, we call two edges of E independent if they can appear together in an induced matching, or in other words, if their endpoints induce a 2ğ¾2 (a disjoint union of two edges) in G. Otherwise, they are called dependent.

In convex bipartite graphs, maximum-cardinality induced matchings are dual to minimum chain covers. A chain graph Z is a bipartite graph that contains no induced matching of more than one edge, i. e., it contains no pair of independent edges. (Chain graphs are also called difference graphs [13] or non-separable bipartite graphs [8].) A chain cover of a graph G with edge set E is a set of (not necessarily induced) chain subgraphs ğ‘1,ğ‘2,â€¦,ğ‘ğ‘˜ of G such that the union of the edge sets of ğ‘1,ğ‘2,â€¦,ğ‘ğ‘˜ is E, see Fig. 1b. A chain cover with k chain subgraphs provides an obvious certificate that the graph cannot contain an induced matching with more than k edges. We will elaborate on this aspect of a chain cover as a certificate of optimality in Sect. 5. A minimum chain cover of G is a chain cover with the smallest possible number k of chain subgraphs. In a convex bipartite graph, we have the following strong duality statement, which is due to Yu et al. [27]: the maximum size of an induced matching is equal to the minimum number of chain subgraphs of a chain cover, see Theorem 3.

We denote the number of vertices by ğ‘›ğ‘ˆ=|ğ‘ˆ|, ğ‘›ğ‘‰=|ğ‘‰|, ğ‘›=ğ‘›ğ‘ˆ+ğ‘›ğ‘‰, and the number of edges by ğ‘š=|ğ¸|. If a convex graph is given as an ordinary bipartite graph without the proper numbering of V, it can be transformed into this form in linear time ğ‘‚(ğ‘›+ğ‘š) [2]. (In terms of the bipartite adjacency matrix, convexity is the well-known consecutive-ones property.) Unweighted convex bipartite graphs have a natural implicit representation [24] of size O(n), which is often called a compact representation [14, 23]: every interval {ğ¿ğ‘–,ğ¿ğ‘–+1,â€¦,ğ‘…ğ‘–} is specified by its endpoints ğ¿ğ‘– and ğ‘…ğ‘–, see Fig. 1c. Since the numbering of V can be computed in ğ‘‚(ğ‘›+ğ‘š) time, it is easy to obtain a compact representation in total time ğ‘‚(ğ‘›+ğ‘š) [23, 25]. The chain covers that we construct will consist of convex bipartite subgraphs with the same ordering of V as the original graph. Thus, we will be able to use the same representation for the chain graphs of a chain cover.

Related Work and Motivation The problem of finding an induced matching of maximum size was first considered by Stockmeyer and Vazirani [26] as the â€œrisk-free marriage problemâ€ with applications in interference-free network communication. The decision version of the problem is known to be NP-complete in many restricted graph classes [5, 16, 17], in particular bipartite graphs [5, 17] that are ğ¶4-free [17] or have maximum degree 3 [17]. On the other hand, it can be solved in linear time in chordal graphs [4], and in polynomial time in weakly chordal graphs [6], trapezoid graphs, k-interval-dimension graphs and co-comparability graphs [12], amongst others. For a more exhaustive survey we refer to [9].

The class of convex bipartite graphs was introduced by Fred Glover [11], who motivates the computation of matchings in these graphs with industrial manufacturing applications. Items that can be matched when some quantity fits up to a certain tolerance naturally lead to convex bipartite graphs. The computation of matchings in convex bipartite graphs also corresponds to a scheduling problem of tasks of discrete length on a single disjunctive resource [15]. The problem of finding a (classic, not induced) matching of maximum cardinality in convex bipartite graphs has been studied extensively [10, 11, 25] culminating in an O(n) algorithm when a compact representation of the graph is given [25]. Several other combinatorial problems have been studied in convex bipartite graphs. While some problems have been shown to be NP-complete even if restricted to this graph class [1], many problems that are NP-hard in general can be solved efficiently in convex bipartite graphs. For example, a maximum independent set can be found in O(n) time (assuming a compact representation) [23] and the existence of Hamiltonian cycles can be decided in ğ‘‚(ğ‘›2) time [19]. For a comprehensive summary we refer to [14].

One of the applications given by Stockmeyer and Vazirani [26] for the induced matching problem can be stated as follows. We want to test (or use) a maximum number of connections between receiver-sender pairs in a network. However, testing a particular connection produces noise so that no other node in reach may be tested simultaneously. We remark that this type of motivation extends very naturally to convex bipartite graphs when we consider wireless networks in which nodes broadcast or receive messages in specific frequency ranges. Further, weighted edges can model the importance of connections.

Recently, Panda et al. [20] have built on our results to obtain polynomial algorithms for finding maximum-weight induced matchings in circular-convex and triad-convex bipartite graphs. These graph classes generalize convex bipartite graphs. Their algorithms use Theorem 1 of our paper as a subroutine.

Previous Work Yu et al. [27] describe an algorithm that finds both a maximum-cardinality induced matching and a minimum chain cover in a convex bipartite graph in runtime ğ‘‚(ğ‘š2). Their procedure is improved by BrandstÃ¤dt et al. [3], resulting in a runtime of ğ‘‚(ğ‘›2). Chang [7] computes maximum-cardinality induced matchings and minimum chain covers in ğ‘‚(ğ‘›+ğ‘š) time in bipartite permutation graphs, which form a proper subclass of convex bipartite graphs.

Our Contribution We improve and generalize the previous results in several ways.

In Sect. 2 we give an algorithm for finding a maximum-weight induced matching in a convex bipartite graph in ğ‘‚(ğ‘›+ğ‘š) time. The previous best algorithm [3] had a runtime of ğ‘‚(ğ‘›2) and was restricted to the unweighted case.

In Sect. 3 we show that for the unweighted case, a further speed-up is possible if a compact representation of the graph is given: we specialize our algorithm from Sect. 2 to find induced matchings of maximum cardinality in O(n) runtime.

In Sect. 4 we extend the approach from Sect. 3 to obtain in O(n) time a compact representation of a minimum chain cover. If the input graph is not given in compact form, our algorithm can be adapted to produce a minimum chain cover (in standard representation) in ğ‘‚(ğ‘›+ğ‘š) time. This improves the previous best algorithm [3], which had a runtime of ğ‘‚(ğ‘›2).

All of our algorithms achieve optimal running time for the respective problem and model. Our results for finding a maximum-cardinality induced matching also improve the running times of the algorithms of Pandey et al. [21] for the circular-convex and triad-convex case, as they use the convex case as a building block.

An induced matching together with a chain cover of the same cardinality constitute a certificate of optimality, of linear size. In Sect. 5, we show how to check this certificate for validity with very simple linear time algorithms. Thus, our algorithms for the unweighted case are certifying algorithms, see [18] for a survey about this concept.

Strong duality suggests that there should be a weighted chain cover with the same weight as the maximum weight of an induced matching in a convex bipartite graph. We discuss this aspect in Sect. 6 and leave it as an open problem to extend our maximum-weight matching algorithm to an efficient algorithm that also finds a minimum-weight chain cover.

Maximum-Weight Induced Matchings
In this section, we compute a maximum-weight induced matching of a given edge-weighted convex bipartite graph ğº=(ğ‘ˆ,ğ‘‰,ğ¸) in time ğ‘‚(ğ‘›+ğ‘š). We generally write indices ğ‘–âˆˆğ‘ˆ as superscripts and indices ğ‘—âˆˆğ‘‰ as subscripts. We consider E as a subset of ğ‘ˆÃ—ğ‘‰. We assume that ğ‘‰={1,â€¦,ğ‘›ğ‘‰} is numbered as described in Sect. 1 and the interval {ğ¿ğ‘–,ğ¿ğ‘–+1,â€¦,ğ‘…ğ‘–}âŠ†ğ‘‰ of each vertex ğ‘–âˆˆğ‘ˆ is given by the left endpoint ğ¿ğ‘– and right endpoint ğ‘…ğ‘–. Each edge (ğ‘–,ğ‘—)âˆˆğ¸ has a weight ğ¶ğ‘–ğ‘—.

Our dynamic-programming approach considers the following subproblems: For an edge (ğ‘–,ğ‘—)âˆˆğ¸, we define ğ‘Šğ‘–ğ‘— as the cost of the maximum-weight induced matching that uses the edge (i, j) and contains only edges in ğ‘ˆÃ—{1,â€¦,ğ‘—}. As we will see, the following dynamic-programming recursion computes ğ‘Šğ‘–ğ‘—:

ğ‘Šğ‘–ğ‘—=ğ¶ğ‘–ğ‘—+max({ğ‘Šğ‘–â€²ğ‘—â€²âˆ£ğ‘…ğ‘–â€²<ğ‘—, ğ‘—â€²<ğ¿ğ‘–}âˆª{0})
(1)
The range over which the maximum is taken is illustrated in Fig. 2. In this recursion, we build the induced matching H of weight ğ‘Šğ‘–ğ‘— by adding the edge (i, j) to some induced matching ğ»â€² of weight ğ‘Šğ‘–â€²ğ‘—â€². We want H to be an induced matching: By construction, the edge (ğ‘–â€²,ğ‘—â€²) is independent of (i, j), but it remains to show that the other edges of ğ»â€² are also independent of (i, j). In order to prove this (Lemma 2), we use some sort of transitivity of the independence relation for edge pairs (Lemma 1). First we state an observation:

Fig. 2
figure 2
The table entries that enter in the computation of ğ‘Šğ‘–ğ‘— are shaded: They lie in rows that end to the left of ğ‘Šğ‘–ğ‘— (marked by arrows), and only the entries to the left of ğ¿ğ‘– are considered

Full size image
Proposition 1
Two edges (i, j) and (ğ‘–â€²,ğ‘—â€²) are independent if and only if ğ‘—â€²âˆ‰[ğ¿ğ‘–,ğ‘…ğ‘–] and ğ‘—âˆ‰[ğ¿ğ‘–â€²,ğ‘…ğ‘–â€²]. â—»

We emphasize that the independence of (i, j) and (ğ‘–â€²,ğ‘—â€²) does not require that the intervals [ğ¿ğ‘–,ğ‘…ğ‘–] and [ğ¿ğ‘–â€²,ğ‘…ğ‘–â€²] are disjoint, see, e.g., edges (4,6) and (5,9) in Fig. 1a.

Lemma 1
Let (ğ‘–â€³,ğ‘—â€³),(ğ‘–â€²,ğ‘—â€²),(ğ‘–,ğ‘—)âˆˆğ¸ with ğ‘—â€³<ğ‘—â€²<ğ‘—. Assume that (ğ‘–â€³,ğ‘—â€³) and (ğ‘–â€²,ğ‘—â€²) are independent, and (ğ‘–â€²,ğ‘—â€²) and (i, j) are independent. Then (ğ‘–â€³,ğ‘—â€³) and (i, j) are independent.

Proof
By Proposition 1, we have ğ‘—â€³â‰¤ğ‘…ğ‘–â€³<ğ‘—â€²â‰¤ğ‘…ğ‘–â€²<ğ‘— and ğ‘—â€³<ğ¿ğ‘–â€²â‰¤ğ‘—â€²<ğ¿ğ‘–â‰¤ğ‘—. Thus, ğ‘—âˆ‰[ğ¿ğ‘–â€³,ğ‘…ğ‘–â€³] and ğ‘—â€³âˆ‰[ğ¿ğ‘–,ğ‘…ğ‘–]. â—»

Lemma 2
The recursion (1) is correct.

Proof
By Proposition 1, any edge (ğ‘–â€²,ğ‘—â€²) with ğ‘—â€²<ğ‘— that is independent of (i, j) satisfies ğ‘…ğ‘–â€²<ğ‘— and ğ‘—â€²<ğ¿ğ‘–. By Lemma 1, all other edges (ğ‘–â€³,ğ‘—â€³) used to obtain the matching value ğ‘Šğ‘–â€²ğ‘—â€² are also independent of (i, j). â—»

We create a table in which we record the entries ğ‘Šğ‘–ğ‘—. We assume that the intervals are sorted in nondecreasing order by ğ¿ğ‘–, that is, ğ¿ğ‘–â‰¤ğ¿â„ for ğ‘–<â„. The values ğ‘Šğ‘–ğ¿ğ‘–,â€¦,ğ‘Šğ‘–ğ‘…ğ‘– form the ith row of the table. We fill the table row by row proceeding from ğ‘–=1 to ğ‘–=ğ‘›ğ‘ˆ. Each row i is processed from left to right. This ensures that the values on the right side of the recursion (1) have already been computed when they are needed, see Fig. 2. The only challenge in evaluating (1) is the maximum-expression, for which we introduce the following notation.

ğ‘€ğ‘–ğ‘—=max({ğ‘Šğ‘–â€²ğ‘—â€²âˆ£ğ‘…ğ‘–â€²<ğ‘—, ğ‘—â€²<ğ¿ğ‘–}âˆª{0})
(2)
Each row starts with the computation of the leftmost entry ğ‘Šğ‘–ğ¿ğ‘–, which we discuss later. When we proceed from ğ‘Šğ‘–ğ‘— to ğ‘Šğ‘–ğ‘—+1 we want to go incrementally from ğ‘€ğ‘–ğ‘— to ğ‘€ğ‘–ğ‘—+1. Direct comparison of the respective defining sets leads to

ğ‘€ğ‘–ğ‘—+1=max({ğ‘€ğ‘–ğ‘—}âˆª{ğ‘Šğ‘–â€²ğ‘—â€²âˆ£ğ‘…ğ‘–â€²=ğ‘—, ğ‘—â€²<ğ¿ğ‘–})
(3)
In order to evaluate the maximum of the second set in (3) efficiently, we group intervals ğ‘–â€² with a common right endpoint ğ‘…ğ‘–â€²=ğ‘— together. Let ğ‘†ğ‘— be the earliest startpoint of an interval with endpoint j. If there are no intervals with endpoint j, we set ğ‘†ğ‘—:=ğ‘—. (It would be more logical to set ğ‘†ğ‘—:=ğ‘—+1 in this case, but this choice makes the algorithm simpler.) We maintain an array ğ‘ƒğ‘—[â„“] for ğ‘†ğ‘—â‰¤â„“â‰¤ğ‘— that is defined as follows:

ğ‘ƒğ‘—[â„“]:=max({ğ‘Šğ‘–â€²ğ‘—â€²âˆ£âˆ£ğ‘…ğ‘–â€²=ğ‘—; row ğ‘–â€² has already been processed; ğ‘—â€²â‰¤â„“}âˆª{0})
(4)
In a sense, ğ‘ƒğ‘—[â„“] is a provisional version of the expression max{ğ‘Šğ‘–â€²ğ‘—â€²âˆ£ğ‘…ğ‘–â€²=ğ‘—, ğ‘—â€²â‰¤â„“}, which takes into account only the already processed rows. For (3), we need the entry ğ‘ƒğ‘—[ğ¿ğ‘–âˆ’1], and we will show that all relevant entries have already been computed whenever we access this entry:

Lemma 3
When entry ğ‘Šğ‘–ğ‘—+1 is processed, ğ‘€ğ‘–ğ‘—+1 can be computed by the formula

ğ‘€ğ‘–ğ‘—+1={max{ğ‘€ğ‘–ğ‘—,ğ‘ƒğ‘—[ğ¿ğ‘–âˆ’1]},ğ‘€ğ‘–ğ‘—,if ğ¿ğ‘–âˆ’1â‰¥ğ‘†ğ‘—otherwise
(5)
Figure 3 illustrates the role of the arrays ğ‘ƒğ‘— when processing a row.

Fig. 3
figure 3
Example. We are in the process of filling row 30 from left to right. All rows with smaller index i have been processed and are filled with the entries ğ‘Šğ‘–ğ‘—. Unprocessed entries are marked as â€œâ€“â€. The figure does not show the rows in the order in which they are processed, but intervals with the same right endpoint ğ‘…ğ‘–=ğ‘Ÿ are grouped together. The bold entries collect the provisional maxima ğ‘ƒğ‘Ÿ in each group. By way of example, the encircled entry ğ‘ƒ27[20]=54 is the maximum among the shaded entries of the intervals that end at ğ‘…ğ‘–=27, ignoring the yet unprocessed entries. As we proceed from ğ‘—=27 to ğ‘—=28 in row 30, the intervals with ğ‘…ğ‘–=27 become relevant. The maximum usable entry from these intervals is found in position 17 of this array, because 17=ğ¿30âˆ’1. The entry ğ‘ƒ27[17]=44 is marked by an arrow. The next entry ğ‘Š3028 is equal to ğ¶3028+max{ğ‘ƒ27[17],ğ‘ƒ26[17],â€¦,ğ‘ƒ17[17]} according to (2), by the interpretation of the entries ğ‘ƒğ‘—[â„“]. (Some of these entries might not exist.) The maximum in this expression is ğ‘€3028, and in the algorithm it is computed incrementally by formula (5) from ğ‘ƒ27[17] and the term ğ‘€3027=max{ğ‘ƒ26[17],â€¦,ğ‘ƒ17[17]}, which has been used for calculating ğ‘Š3027. We can confirm that the minimum over which ğ‘ƒ27[17] is defined involves no unprocessed entries at this time (Lemma 3). Later, when the next row ğ‘–=34 in the group with ğ‘…ğ‘–=27 is filled, the array ğ‘ƒ27 will updated

Full size image
Before proving that (5) defines indeed the same quantity as (3), we first discuss that the expression (5) does not access the array ğ‘ƒğ‘— beyond its boundaries: The condition ğ¿ğ‘–âˆ’1â‰¥ğ‘†ğ‘— ensures that the array index ğ¿ğ‘–âˆ’1 does not exceed the left boundary of the array ğ‘ƒğ‘—. Also, the index ğ¿ğ‘–âˆ’1 never exceeds the right boundary j of the array ğ‘ƒğ‘—, since ğ¿ğ‘–<ğ‘—+1â‰¤ğ‘…ğ‘–, and therefore ğ¿ğ‘–âˆ’1â‰¤ğ‘—. Thus, ğ‘ƒğ‘—[ğ¿ğ‘–âˆ’1] is always defined when it is accessed.

Proof
(of Lemma 3) We distinguish three cases.

Case 1 No interval ends at j, and accordingly, ğ‘†ğ‘—=ğ‘—.

In this case ğ‘€ğ‘–ğ‘—+1=ğ‘€ğ‘–ğ‘— in (3) since its rightmost set is empty. Since ğ¿ğ‘–<ğ‘—+1â‰¤ğ‘…ğ‘–, we have ğ¿ğ‘–âˆ’1<ğ‘†ğ‘—=ğ‘— and, thus, the right side of (5) evaluates also to ğ‘€ğ‘–ğ‘—.

Case 2 There exists an interval ending at j, and ğ¿ğ‘–âˆ’1<ğ‘†ğ‘—. The right side of (5) evaluates to ğ‘€ğ‘–ğ‘—. In (3), intervals ğ‘–â€² that end at ğ‘…ğ‘–â€²=ğ‘— have ğ¿ğ‘–â€²â‰¥ğ‘†ğ‘—>ğ¿ğ‘–âˆ’1. Thus, an edge (ğ‘–â€²,ğ‘—â€²) with ğ‘—â€²<ğ¿ğ‘– and ğ‘…ğ‘–â€²=ğ‘— does not exist, and the second set in (3) is empty. Therefore, (3) evaluates to ğ‘€ğ‘–ğ‘—+1=ğ‘€ğ‘–ğ‘—.

Case 3 There exists an interval ending at j, and ğ¿ğ‘–âˆ’1â‰¥ğ‘†ğ‘—. In this case, ğ‘ƒğ‘—[ğ¿ğ‘–âˆ’1] is defined:

ğ‘ƒğ‘—[ğ¿ğ‘–âˆ’1]=max{ğ‘Šğ‘–â€²ğ‘—â€²âˆ£ğ‘…ğ‘–â€²=ğ‘—, ğ‘—â€²â‰¤ğ¿ğ‘–âˆ’1, row i' already processed}
(6)
For each entry ğ‘Šğ‘–â€²ğ‘—â€² with ğ‘—â€²<ğ¿ğ‘–, we conclude that ğ¿ğ‘–â€²â‰¤ğ‘—â€²<ğ¿ğ‘– and, thus, row ğ‘–â€² has already been processed. This means that the condition that row ğ‘–â€² has been processed is redundant, and (6) coincides with maximum of the right set in (3). â—»

figure a
After processing row i with startpoint â„“=ğ¿ğ‘– and endpoint ğ‘Ÿ=ğ‘…ğ‘–, we have to update the values in ğ‘ƒğ‘Ÿ[ğ‘—]. This is straightforward.

It remains to discuss the computation of the first value ğ‘Šğ‘–â„“ of the row. An edge (ğ‘–â€²,ğ‘—â€²),ğ‘—â€²<â„“ and edge (ğ‘–,â„“) are independent if and only if the interval ğ‘–â€² ends before â„“, that is ğ‘…ğ‘–â€²<â„“. Since we process the intervals in nondecreasing order by their startpoints, it suffices to maintain a value F with the maximum ğ‘Šğ‘–â€²ğ‘—â€² in all finished intervals: those intervals ğ‘–â€² that end before â„“. In other words ğ¹=max{ğ‘ƒ1[1],ğ‘ƒ2[2],â€¦,ğ‘ƒâ„“âˆ’1[â„“âˆ’1]}. This value is easily maintained by updating F as â„“ increases. The full details are stated as Algorithm 1.

The update of the array ğ‘ƒğ‘Ÿ[ğ‘—] in the second loop can be integrated with the computation of ğ‘Šğ‘–ğ‘— in the first loop. When this is done, the values ğ‘Šğ‘–ğ‘— need not be stored at all because they are not used.

As stated earlier, when no interval ends at a point ğ‘Ÿâˆˆğ‘‰, we set ğ‘†ğ‘Ÿ=ğ‘Ÿ. The array ğ‘ƒğ‘Ÿ consists of a single dummy entry ğ‘ƒğ‘Ÿ[ğ‘Ÿ]=0. In this way, this case needs no special treatment in the algorithm.

We have described the computation of the value of the optimal matching. It is straightforward to augment the program so that the optimal matching itself can be recovered by backtracking how the optimal value was obtained, but this would clutter the program.

Theorem 1
A maximum-weight induced matching of an edge-weighted convex bipartite graph can be computed in ğ‘‚(ğ‘›+ğ‘š) time. â—»

Maximum-Cardinality Induced Matchings
For the unweighted version of the problem, we assume a compact representation of a convex bipartite graph ğº=(ğ‘ˆ,ğ‘‰,ğ¸), that is, for each ğ‘–âˆˆğ‘ˆ we are given the startpoint ğ¿ğ‘– and endpoint ğ‘…ğ‘– of its interval {ğ¿ğ‘–,ğ¿ğ‘–+1,â€¦,ğ‘…ğ‘–}. This makes it possible to obtain a linear runtime of O(n).

The recursion (1) can be specialized to the unweighted case by setting ğ¶ğ‘–ğ‘—â‰¡1.

ğ‘Šğ‘–ğ‘—=1+max({ğ‘Šğ‘–â€²ğ‘—â€²âˆ£ğ‘…ğ‘–â€²<ğ‘—, ğ‘—â€²<ğ¿ğ‘–}âˆª{0})
(7)
This recursion is related to the previous algorithms [3, 27] for computing maximum-cardinality induced matchings (and minimum chain covers) in convex bipartite graphs: Yu et al. describe a greedy procedure that colors the edges of the bipartite adjacency matrix with integer values ğ‘ŠÌ‚ ğ‘–ğ‘—  [27, Greedy Decomposition Algorithm]. This procedure is later also used by BrandstÃ¤dt et al. [3, Procedure: Greedy Coloring]. It assigns to each edge (i, j) the smallest possible color ğ‘ŠÌ‚ ğ‘–ğ‘— such that independent edges receive different colors. Figure 4 below shows an example of such a coloring. Formally, we can express this approach as a recursion:

ğ‘ŠÌ‚ ğ‘–ğ‘—=min({1,2,â€¦,ğ‘š}âˆ–{ğ‘ŠÌ‚ ğ‘–â€²ğ‘—â€²âˆ£ğ‘…ğ‘–â€²<ğ‘—, ğ‘—â€²<ğ¿ğ‘–})
(8)
Our assignment (7), by contrast, picks the next color after the largest color of an independent edge. By Lemma 1 it can be derived that the choices (7) and (8) agree, i.e. ğ‘Šğ‘–ğ‘—=ğ‘ŠÌ‚ ğ‘–ğ‘— for every edge (i, j). Thus, our explicit dynamic programming approach produces the same coloring as the algorithm of Yu et al. and it gives a new interpretation and a different explanation of the assigned colors.

Fig. 4
figure 4
An example showing a section of the computation of ğ‘Šğ‘–ğ‘— by Algorithm 4. The threshold values ğ‘¡6 and ğ‘¡7 are shown as they change with the rows that are successively considered. The shaded entries form the chain subgraph ğ‘7 that is used for the chain cover

Full size image
The original implementation given in [27] runs in time ğ‘‚(ğ‘š2). BrandstÃ¤dt et al. [3] give an improved implementation which obtains the colors ğ‘ŠÌ‚ ğ‘–ğ‘— in ğ‘‚(ğ‘›2) time. Our Algorithm 1 from Sect. 2 improves on these results as it obtains the values ğ‘Šğ‘–ğ‘—=ğ‘ŠÌ‚ ğ‘–ğ‘— in total time ğ‘‚(ğ‘›+ğ‘š).

Given a compact representation, a further speed-up to O(n) time is possible: we exploit some straightforward structural properties of the filled dynamic-programming table:

Lemma 4
[27, Lemma 5] The values ğ‘Šğ‘–ğ‘— are nondecreasing in each row.

Proof
In (7), the maximum is taken over a set which is increasing with j. â—»

Lemma 5
[3, Lemma 3.3, Lemma 3.4] Each row contains at most two consecutive values.

Proof
Let ğ‘Šğ‘–ğ‘— be the largest value in some row i. Then, if we take a corresponding matching of size ğ‘Šğ‘–ğ‘—, it is easy to see that we can remove the last two edges and replace them by an arbitrary edge (i, k). This proves that ğ‘Šğ‘–ğ‘˜â‰¥ğ‘Šğ‘–ğ‘—âˆ’1.

More formally, we can argue by the recursion (7): Assume there are values ğ‘Šğ‘–ğ‘˜â‰¤ğ‘Šğ‘–ğ‘—âˆ’2 in row i. By Lemma 4 we can assume ğ‘˜<ğ‘—. By (7), ğ‘Šğ‘–ğ‘—=1+ğ‘Šğ‘–â€²ğ‘—â€²=2+ğ‘Šğ‘–â€³ğ‘—â€³ with ğ‘…ğ‘–â€³<ğ‘—â€²<ğ¿ğ‘– for some ğ‘–â€³<ğ‘–â€²<ğ‘–. Thus, ğ‘—â€³â‰¤ğ‘…ğ‘–â€³<ğ‘—â€²<ğ¿ğ‘–â‰¤ğ‘˜ and by definition of ğ‘Šğ‘–ğ‘˜ according to (7) we have ğ‘Šğ‘–ğ‘—âˆ’2=ğ‘Šğ‘–â€³ğ‘—â€³<ğ‘Šğ‘–ğ‘˜â‰¤ğ‘Šğ‘–ğ‘—âˆ’2, which is a contradiction. â—»

figure b
figure c
Specializing Algorithm 1 to the unweighted case leads to a solution with ğ‘‚(ğ‘›+ğ‘š) running time. Our O(n)-time algorithm will follow the general scheme of Algorithm 1, with the following modifications.

(I) In view of Lemmas 4 and 5, we will not fill each row individually, but we will just determine the leftmost value w and the position where the entries switch from w to ğ‘¤+1 (if any).

(II) The computation of the leftmost entry is exactly as in Algorithm 1.

(III) The position where the entries of row i switch from w to ğ‘¤+1 can be determined from (7): If there is a row ğ‘–â€² containing an entry w left of ğ¿ğ‘–, then ğ‘Šğ‘–ğ‘— must be ğ‘¤+1 as soon as ğ‘—>ğ‘…ğ‘–â€². The algorithm determines the threshold position ğ‘¡ğ‘¤ as the smallest right endpoint ğ‘…ğ‘–â€² under these constraints. Then the entries ğ‘¤+1 in row i start at ğ‘—=ğ‘¡ğ‘¤+1 if these entries are still part of the row.

(IV) We do not maintain the whole array ğ‘ƒğ‘Ÿ for each r, but only its last entry ğ‘ƒğ‘Ÿ[ğ‘Ÿ]; this is sufficient for updating F and thus for computing the leftmost entries in the rows. We call this value ğ‘„ğ‘Ÿ.

This leads to Algorithm 2.

We will improve Algorithm 2 by maintaining the values ğ‘¡ğ‘¤ instead of computing them from scratch. We use the fact that the smallest value w in the row is known, and hence we can associate ğ‘¡ğ‘¤ with the value w instead of the row index i, as is already apparent from our chosen notation. We update ğ‘¡ğ‘¤ whenever â„“ increases. The details are shown in Algorithm 3. The differences to Algorithm 2 are marked by â–³.

This still does not achieve O(n) running time. The final improvement comes from realizing that it is sufficient to update ğ‘¡ğ‘¤ when ğ‘Šğ‘–â€²ğ‘™ is the leftmost entry w in row ğ‘–â€². The time when such an update occurs can be predicted when a row is generated. To this end, we maintain a list î‰€ğ‘— for ğ‘—=1,â€¦,ğ‘›ğ‘‰ that records the updates that are due when â„“ becomes j. This final version is Algorithm 4.

figure d
The runtime of Algorithm 4 is ğ‘‚(ğ‘›ğ‘ˆ+ğ‘›ğ‘‰): Processing each interval i takes constant time and adds at most two pairs to the lists î‰€. Thus, processing the lists î‰€ for updating the ğ‘¡ğ‘¤ array takes also only ğ‘‚(ğ‘›ğ‘ˆ) time.

Some simplifications are possible: The addition of (ğ‘¤,ğ‘…ğ‘–) to the list î‰€â„“ in the case of two values can actually be omitted, as it leads to no decrease in ğ‘¡ğ‘¤: ğ‘¡ğ‘¤ is already <ğ‘…ğ‘–. The algorithm could be further streamlined by observing that at most two consecutive values of ğ‘¡ğ‘¤ need to be remembered at any time. Again, it is easy to modify the algorithm to return a maximum induced matching in addition to its size.

Theorem 2
Given a compact representation, a maximum-cardinality induced matching of a convex bipartite graph can be computed in O(n) time. â—»

Minimum Chain Covers
For convex bipartite graphs, we have the following important duality result of Yu et al. [27], see also [3]:

Theorem 3
In a convex bipartite graph, the size of a maximum-cardinality induced matching equals the number of chain subgraphs of a minimum chain cover.

Along the lines of this duality relation, we are going to extend Algorithm 4 to obtain a minimum chain cover of a convex bipartite graph ğº=(ğ‘ˆ,ğ‘‰,ğ¸).

Let ğ‘Šâˆ— be the cardinality of a maximum induced matching of G. Accordingly, the values ğ‘Šğ‘–ğ‘— cover the range {1,â€¦,ğ‘Šâˆ—}. We create ğ‘Šâˆ— chain subgraphs ğ‘1,â€¦,ğ‘ğ‘Šâˆ— of G. The edges (i, j) with ğ‘Šğ‘–ğ‘—=ğ‘¤ will be part of the chain subgraph ğ‘ğ‘¤. As already observed in [27], the edges with a fixed value of ğ‘Šğ‘–ğ‘— may contain independent edges and, thus, do not necessarily constitute a chain graph. Yu et al. [27] describe a strategy to extend the edge set for each value of ğ‘Šğ‘–ğ‘—=ğ‘¤ to a chain graph ğ‘ğ‘¤. Their original implementation runs in time ğ‘‚(ğ‘š2). BrandstÃ¤dt et al. [3] give an improved implementation with runtime ğ‘‚(ğ‘›2). We improve on these previous results, by implementing the extension strategy in ğ‘‚(ğ‘›+ğ‘š) time; and even in O(n) time if a compact representation of the input graph is given.

The correctness of this approach was already shown in [27], thus establishing Theorem 3. We give a new independent proof.

The following characterization is often used as an alternative definition of chain graphs:

Lemma 6
A bipartite graph (ğ‘ˆÂ¯,ğ‘‰Â¯,ğ¸Â¯) is a chain graph if and only if the sets of neighbors ğ‘‰Â¯(ğ‘–):={ğ‘—âˆˆğ‘‰Â¯âˆ£(ğ‘–,ğ‘—)âˆˆğ¸Â¯} of the vertices ğ‘–âˆˆğ‘ˆÂ¯ form a chain in the inclusion order. (Equal sets are allowed.) In other words, among any two sets ğ‘‰Â¯(ğ‘–) and ğ‘‰Â¯(ğ‘–â€²), one must be contained in the other.

Proof
This is a direct consequence of the fact that edges (i, j) and (ğ‘–â€²,ğ‘—â€²) are independent if and only if ğ‘—â€²âˆ‰ğ‘‰Â¯(ğ‘–) and ğ‘—âˆ‰ğ‘‰Â¯(ğ‘–â€²). â—»

The condition that the neighborhoods must form a chain is apparently the reason for calling these graphs chain graphs, however, we did not find a reference for this.

We use ğ‘ˆğ‘¤ to denote the set of rows that contain entries ğ‘Šğ‘–ğ‘—=ğ‘¤. For every row ğ‘–âˆˆğ‘ˆğ‘¤, we determine the beginning and ending points ğµğ‘–ğ‘¤,ğ¸ğ‘–ğ‘¤ with this color, that is, ğ‘Šğ‘–ğ‘—=ğ‘¤âŸºğµğ‘–ğ‘¤â‰¤ğ‘—â‰¤ğ¸ğ‘–ğ‘¤. We extend every such interval [ğµğ‘–ğ‘¤,ğ¸ğ‘–ğ‘¤] to the left by choosing a new starting point ğµÌ‚ ğ‘–ğ‘¤ according to the formula

ğµÌ‚ ğ‘–ğ‘¤:=min({ğµğ‘–ğ‘¤}âˆª{ğµğ‘–â€²ğ‘¤âˆ£ğ‘–â€²âˆˆğ‘ˆğ‘¤, ğ¸ğ‘–â€²ğ‘¤<ğ¸ğ‘–ğ‘¤})
(9)
=min({ğµğ‘–ğ‘¤}âˆª{ğµÌ‚ ğ‘–â€²ğ‘¤âˆ£ğ‘–â€²âˆˆğ‘ˆğ‘¤, ğ¸ğ‘–â€²ğ‘¤<ğ¸ğ‘–ğ‘¤})
(10)
The second expression uses the new values ğµÌ‚  on the right-hand side. It is easy to see that the two expressions are equivalent: Using (9) for the definition of ğµÌ‚ ğ‘–â€²ğ‘¤, the expression (10) becomes

min ({ğµğ‘–ğ‘¤}âˆª{ğµğ‘–â€²ğ‘¤âˆ£ğ‘–â€²âˆˆğ‘ˆğ‘¤, ğ¸ğ‘–â€²ğ‘¤<ğ¸ğ‘–ğ‘¤}âˆª{ğµğ‘–â€³ğ‘¤âˆ£ğ‘–â€³âˆˆğ‘ˆğ‘¤,ğ¸ğ‘–â€³ğ‘¤<ğ¸ğ‘–â€²ğ‘¤<ğ¸ğ‘–ğ‘¤,ğ‘–â€²âˆˆğ‘ˆğ‘¤}).
(11)
The third set is contained in the second set, and thus, (11) is equal to ğµÌ‚ ğ‘–ğ‘¤ according to (9).

We construct the chain graph ğ‘ğ‘¤ as the graph with the extended intervals [ğµÌ‚ ğ‘–ğ‘¤,ğ¸ğ‘–ğ‘¤]. Figure 4 shows an example. It is obvious by construction that these intervals satisfy the conditions of a chain graph: By Lemma 6, we have to show that there are no two intervals [ğµÌ‚ ğ‘–ğ‘¤,ğ¸ğ‘–ğ‘¤], [ğµÌ‚ ğ‘–â€²ğ‘¤,ğ¸ğ‘–â€²ğ‘¤] with ğµÌ‚ ğ‘–â€²ğ‘¤<ğµÌ‚ ğ‘–ğ‘¤ and ğ¸ğ‘–â€²ğ‘¤<ğ¸ğ‘–ğ‘¤. But if the last condition holds, (10) ensures that ğµÌ‚ ğ‘–ğ‘¤â‰¤ğµÌ‚ ğ‘–â€²ğ‘¤. The only thing that could go wrong is that ğµÌ‚ ğ‘–ğ‘¤ becomes too small so that the chain graph is not a subgraph of G. The following lemma shows that this is not the case.

Lemma 7
ğµÌ‚ ğ‘–ğ‘¤â‰¥ğ¿ğ‘– for every ğ‘–âˆˆğ‘ˆğ‘¤.

Proof
For the sake of contradiction, assume ğµÌ‚ ğ‘–ğ‘¤<ğ¿ğ‘–. By (9), there is a row ğ‘–â€²âˆˆğ‘ˆğ‘¤ such that ğµğ‘–â€²ğ‘¤<ğ¿ğ‘– and ğ¸ğ‘–â€²ğ‘¤<ğ¸ğ‘–ğ‘¤. Setting ğ‘—=ğ¸ğ‘–ğ‘¤ and ğ‘—â€²=ğµğ‘–â€²ğ‘¤ in the recursion (7), we conclude that ğ¸ğ‘–ğ‘¤â‰¤ğ‘…ğ‘–â€², because otherwise, (7) would imply ğ‘¤=ğ‘Šğ‘–ğ¸ğ‘–ğ‘¤â‰¥1+ğ‘Šğ‘–â€²ğµğ‘–â€²ğ‘¤=1+ğ‘¤. Thus, (ğ‘–â€²,ğ¸ğ‘–ğ‘¤) is an edge of G. By Lemma 5, ğ‘Šğ‘–â€²ğ¸ğ‘–ğ‘¤=ğ‘¤+1. By (7), there is an edge (ğ‘–â€³,ğ‘—â€³) with ğ‘Šğ‘–â€³ğ‘—â€³=ğ‘¤, ğ‘…ğ‘–â€³<ğ¸ğ‘–ğ‘¤ and ğ‘—â€³<ğ¿ğ‘–â€²<ğ¿ğ‘–. Again by (7), such an edge (ğ‘–â€³,ğ‘—â€³) would imply that ğ‘Šğ‘–ğ¸ğ‘–ğ‘¤â‰¥ğ‘¤+1, a contradiction. â—»

figure e
Algorithm 5 carries out the computation of (9). It processes the triplets (ğµğ‘–ğ‘¤,ğ¸ğ‘–ğ‘¤,ğ‘¤) in increasing order of the endpoints ğ¸ğ‘–ğ‘¤=ğ‘Ÿ. This can be done in linear time, by first sorting the ğ‘‚(ğ‘›ğ‘ˆ) triples (ğµğ‘–ğ‘¤,ğ¸ğ‘–ğ‘¤,ğ‘¤) into ğ‘›ğ‘‰ buckets according to the value of ğ¸ğ‘–ğ‘¤. Thus, Algorithm 5 takes linear time O(n). By Lemma 6, the result is a chain cover, which by duality is minimum. Each row belongs to at most two chain subgraphs, and thus the chain cover consists of at most 2ğ‘›ğ‘ˆ such row intervals in total. It is straightforward to extend Algorithm 4 to compute the sets ğ‘ˆğ‘¤ and the quantities ğµğ‘–ğ‘¤,ğ¸ğ‘–ğ‘¤, and thus the cover can be constructed in O(n) time in compressed form.

Theorem 4
Given a compact representation of a convex bipartite graph, a compact representation of a minimum chain cover can be computed in O(n) time. â—»

Given a compact representation of a minimum chain cover, we can list all the edges of its chain subgraphs in ğ‘‚(ğ‘›+ğ‘š) time since every edge is contained in at most two chain subgraphs. A compact representation of a convex bipartite graph can be computed in ğ‘‚(ğ‘›+ğ‘š) time [2, 23, 25]. Thus, Algorithm 4 and Algorithm 5 can also be used to obtain:

Theorem 5
A minimum chain cover of a convex bipartite graph can be computed in ğ‘‚(ğ‘›+ğ‘š) time. â—»

Certification of Optimality
An induced matching H together with a chain cover of the same cardinality provides a certificate of optimality, of size O(n). As we will establish in the following discussion, it is easy to check this certificate for validity in linear time. This is easier than constructing the largest induced matching with our algorithm. Thus, it is possible to establish correctness of the result beyond doubt, for each particular instance of the problem, without having to trust the correctness of our algorithms and their implementations, see [18] for a survey about this concept.

It is trivial to check whether the matching H is contained in the graph. To test whether it forms an induced matching, we sort the edges (i, j) by j. This takes O(n) time with bucket-sort. Then, by Lemma 1, it is sufficient to test consecutive edges for independence, and each such test takes only constant time according to Proposition 1.

To establish the validity of a chain cover {ğ‘1,â€¦,ğ‘ğ‘Šâˆ—}, we need to check that the edges of G are covered and each ğ‘ğ‘¤ is a chain subgraph. The chain subgraphs ğ‘ğ‘¤={(ğ‘–,ğ‘—)âˆ£ğ‘–âˆˆğ‘ˆğ‘¤,ğµÌ‚ ğ‘–ğ‘¤â‰¤ğ‘—â‰¤ğ¸ğ‘–ğ‘¤}, for 1â‰¤ğ‘¤â‰¤ğ‘Šâˆ— are compactly represented by a set of at most 2ğ‘›ğ‘ˆ quadruples (ğ‘¤,ğ‘–,ğµÌ‚ ğ‘–ğ‘¤,ğ¸ğ‘–ğ‘¤). The following checking procedure works in linear time for any chain cover as long as it consists of convex bipartite subgraphs. It does not use any special properties of the cover produced by our algorithm.

We sort the quadruples (ğ‘¤,ğµÌ‚ ğ‘–ğ‘¤,âˆ’ğ¸ğ‘–ğ‘¤,ğ‘–) lexicographically. Then it is easy to check the chain graph property using the characterization of Lemma 6: The intervals [ğµÌ‚ ğ‘–ğ‘¤,ğ¸ğ‘–ğ‘¤] that belong to a fixed chain graph ğ‘ğ‘¤ (these are consecutive in the list) ought to be nested. Since the starting points ğµÌ‚ ğ‘–ğ‘¤ are weakly increasing, this amounts to checking that the endpoints ğ¸ğ‘–ğ‘¤ decrease weakly.

To check that the chain graphs are contained in G and they collectively cover G, we sort the quadruples (ğ‘–,ğµÌ‚ ğ‘–ğ‘¤,ğ¸ğ‘–ğ‘¤,ğ‘¤). The union of the intervals [ğµÌ‚ ğ‘–ğ‘¤,ğ¸ğ‘–ğ‘¤] that are the neighbors of a fixed vertex ğ‘–âˆˆğ‘ˆ (these are consecutive in the list) can be incrementally formed, and the resulting interval is compared against [ğ¿ğ‘–,ğ‘…ğ‘–]. As soon as a gap would form in this union, we can abort the test, since the intervals are sorted by left endpoint and it is then impossible to form a connected interval [ğ¿ğ‘–,ğ‘…ğ‘–].

The required lexicographic sorting operations can be carried out in O(n) time by repeated bucket-sort (radix-sort).

Outlook: Duality
The existence of a maximum induced matching and a smallest chain cover with the same size is a manifestation of strong duality between independent sets and clique covers in perfect graphs. We mentioned in the introduction that our maximum induced matching problem is an instance of a maximum independent set problem in the square of a line graph, and the chain cover is a covering by cliques. Yu et al. [27] established that the square of the line graph of a convex bipartite graph is a co-comparability graph. Therefore, it is also a perfect graph. It follows that the linear program for maximizing the size of an induced matching in a convex bipartite graph is totally dual integral, see [22, Corollary 65.2f]. As a corollary of this fact, we recover our strong duality result: the existence of a primal optimal solution (maximum induced matching) and a dual optimal solution (smallest chain cover) with matching objective function values, see [22, Corollary 65.2d].

This duality relation for perfect graphs extends to the weighted version. Thus, there should also be a weighted chain cover with the same weight as the maximum weight of an induced matching. A weighted chain cover of a weighted graph consists of chain subgraphs together with a positive real weight for each chain subgraph, such that for every edge (i, j), the total weight of all chain subgraphs covering the edge (i, j) is at least the weight ğ¶ğ‘–ğ‘— of this edge. The weight of a weighted chain cover is the sum of all weights. It is an open problem to extend our primal Algorithm 1 in weighted graphs to a fast combinatorial algorithm for finding minimum-weight chain covers, as Algorithm 5 does for the unweighted version.