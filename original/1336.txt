We introduce a new type of adversary for online graph problems thus allowing parametrized analysis of online algorithms with respect to a natural parameter. The new adversary is parameterized by a single integer 𝜅, which upper bounds the number of connected components that the adversary can use at any time during the presentation of the online graph G. We call this adversary “𝜅-components-bounded”, or 𝜅-CB for short. On one hand, this adversary is restricted compared to the classical adversary because of the 𝜅-CB constraint. On the other hand, we seek competitive ratios parameterized only by 𝜅 with no dependence on the input length n, thereby giving the new adversary power to use arbitrarily large inputs. We study online coloring under the 𝜅-CB adversary. We obtain a finer analysis of the existing algorithms FirstFit and CBIP by computing their competitive ratios on trees and bipartite graphs under the new adversary: (1) Perhaps surprisingly, FirstFit outperforms CBIP on trees; (2) The competitive ratio of CBIP on bipartite graphs is simply 𝜅. We also study several well known classes of graphs, such as 3-colorable, 𝐶𝑘-free, d-inductive, planar, and bounded treewidth, with respect to online coloring under the 𝜅-CB adversary. We demonstrate that the extra adversarial power of unbounded input length outweighs the restriction on the number of connected components leading to non-existence of competitive algorithms for these classes.

Access provided by University of Auckland Library

Introduction
In online graph problems the input graph is not known in advance, but is rather revealed one item at a time. In this paper we are concerned with the so-called vertex-arrival model, where the graph is revealed one vertex at a time. When a new vertex is revealed, an online algorithm learns the identity of the vertex as well as its neighborhood restricted to the already revealed vertices. Note that the algorithm gets no information about future vertices. Many graph problems do not admit any non-trivial online algorithms in the adversarial vertex-arrival model. Be that as it may, online graph problems often arise in real life applications in computer networks, public transit networks, electrical grids, and so on. Recently, the interest in online and “online-like”Footnote1 graph models and algorithms has been increasing since it is being sparked by the proliferation of online social networks. Thus, it is necessary to introduce various restrictions of the basic adversarial model that allow nontrivial algorithms while capturing interesting real-life scenarios.

One obtains a plethora of restricted adversaries simply by insisting that the adversary generates a graph belonging to a particular family of graphs, such as 𝜒-colorable, planar, d-inductive, etc. Another way to relax the classical adversarial model is to consider distributions on graphs and perform average-case analysis. One of the most studied distributions is, of course, the Erdös-Rényi random graph. While it is mathematically appealing, real life graphs rarely follow this distribution. For example, one of the early empirical observations was that distributions on degrees of vertices in real social networks are most accurately modeled by power-law distributions [12], whereas the Erdös-Rényi model induces a binomial distribution on degrees of vertices. Thus, new models of random graphs have been introduced in an attempt to approximate power-law distributions on degrees. Many of these new generative models are inherently offline. A notable exception is the preferential attachment model [2], which perfectly fits within the vertex-arrival model. The formal definition is technical, but at a high level this model works as follows. When a new vertex v arrives its neighborhood is generated by connecting v to an already existing vertex u with probability proportional to the current degree of u. This model has a natural motivation: consider a person signing up for some social network, where people can “follow” each other. This person is signing up not because they want to be left alone (i.e. form a new connected component), but because they already have a list of people in mind who they will follow (i.e., join existing connected component(s), potentially merging some components together). It is more likely that the person is going to follow well known people, e.g. celebrities, who in turn have some of the highest numbers of followers in the network. This is akin to a new vertex in vertex-arrival model likely being connected to existing vertices of high degree.

The first starting point of our work is the observation that when a social network graph is generated via the preferential attachment process, there are very few connected components in the online graph at any point in time. Formalizing this observation in the adversarial setting, we investigate a new type of adversary that is restricted to using at most 𝜅 connected components at any point in time during the generation of the online input graph. We call such adversary 𝜅-components-bounded, or 𝜅-CB for short.

In this paper we focus on the online coloring problem under the 𝜅-CB adversary. Indeed, another motivation for considering the 𝜅-CB adversary is to extend our understanding of lower-bound techniques for online coloring. Most of the past research uses the following methodology: the adversary creates a collection of disjoint components with some properties, then the adversary merges these components by creating a vertex appropriately connected to the components. The aim of this technique is to allow the adversary to observe the coloring of each component chosen by the algorithm, and then choose a “correct” coloring of the components that differs from the one chosen by the algorithm. The adversary then connects the components together, forcing the algorithm to use extra colors (since the algorithm’s coloring is incorrect inside at least one component). By iterating this process, the adversary tries to force the online algorithm to perform badly. Some variants of this technique have been used, for example, in [1, 4, 6, 7, 14]. A notable exception is [8], where this create-and-merge components technique is not directly involved. Usually, this type of construction involves a large number of disjoint components, typically logarithmic in the number of vertices—see, for example, [6, 7]. Our goal is to formally analyze the power of this technique, and the extent of dependence of existing lower bounds on this technique. Specifically, we ask, what happens if the adversary in the online coloring problem is 𝜅-CB? In this work we investigate this question, while allowing the adversary to use an unlimited number of vertices to compensate for a limited number of components.

Our first set of results gives a finer understanding of the FirstFit and CBIP algorithms (for formal definitions see Sect. 2), which are well known in the online graph coloring community. We show that, perhaps surprisingly, FirstFit outperforms CBIP on trees with respect to the 𝜅-CB adversary. The optimality of FirstFit, up to a constant factor, has been shown for several classes of graphs including trees in [1]. Our results can be viewed as a strengthening of [1]: FirstFit can perform strictly better than CBIP on trees. For general bipartite graphs, we show that CBIP uses at most 2𝜅 colors against the 𝜅-CB adversary. This result is particularly interesting in the context of existing lower bounds on the performance of CBIP on bipartite graphs. In a series of works [4, 6, 7] it is shown that any online algorithm must use at least roughly 2log𝑛 colors where n is the number of vertices. The construction for this lower bound uses log𝑛 disjoint components. Our result shows that this is necessary. One often measures the performance of an online algorithm by its competitive ratio—the worst-case ratio between the objective value achieved by an algorithm and the offline optimum. In the case of nontrivial bipartite graphs the offline optimum is 2, thus the difference between the absolute number of colors used by CBIP and its competitive ratio is just a factor of 2. But this difference has a philosophical significance: our result shows that the competitive ratio of CBIP on bipartite graphs is simply 𝜅: the number of components that the adversary is allowed to use.

Our second set of results shows that for several classes of graphs, including 𝜒-colorable graphs, the 𝜅-CB adversary equipped with unlimited number of vertices is powerful enough to rule out competitive algorithms even when 𝜅=1. These two sets of results provide another contrast between bipartite graphs and other classes of graphs.

Besides the technical results, we view the 𝜅-CB adversary as a conceptual contribution: it allows parametrized analysis of online algorithms for online graph problems with respect to a natural parameter.

The rest of the paper is organized as follows. In Sect. 2 we go over some preliminaries. The new adversarial model is introduced in Sect. 3. The FirstFit algorithm is analyzed in Sect. 4, while CBIP is analyzed in Sect. 5. The analysis of various classes of graphs is in Sect. 6. We finish with some discussion and open problems in Sect. 7.

Preliminaries
In online coloring, an adversary creates a simple undirected graphFootnote2𝐺=(𝑉,𝐸) and a presentation order of verticesFootnote3𝜎:[𝑛]→𝑉. The graph is then presented online in the vertex-arrival model: at time i vertex 𝑣=𝜎(𝑖) arrives, and we learn all its neighbors among already appeared vertices. An online algorithm must declare how to color the new vertex c(v) prior to the arrival of the next vertex 𝜎(𝑖+1). A priori, an online algorithm does not know V or even n. Alternatively, we can view the online input as a sequence of induced subgraphs:

𝐺∩𝜎([1]),𝐺∩𝜎([2]),…,𝐺∩𝜎([𝑛]).
We call the set of neighbors of v that an online algorithm learns about at the time of arrival of v the pre-neighborhood of v, denoted by 𝑁−(𝑣).

A natural greedy algorithm is called FirstFit (see, for example, [7, 9, 13]): when a vertex v arrives, FirstFit colors it with the first color that does not appear in the pre-neighborhood of v. The pseudocode is shown in Algorithm 1.

figure a
Another famous algorithm due to [11] for online coloring of bipartite graphs is called CBIP: when a vertex 𝑣=𝜎(𝑖) arrives, CBIP computes an entire connected component CC to which v belongs in the partial graph known so far. Since we assume that the input graph is bipartite, the connected component CC can be partitioned into two sets of vertices A and B such that all edges go between A and B only. Suppose that 𝑣∈𝐴, then v is colored with the first color that is not present among vertices in B. The pseudocode is shown in Algorithm 2.

figure b
In the adversarial arguments presented in this work we often need to control the chromatic number of constructed instances. These instances can get quite complicated and computing their chromatic number exactly might be rather difficult. The following technique is widely used in the online coloring community, see e.g., [8]. The adversary is not only going to construct an online instance, but it will also maintain a valid coloring of that instance. Thus, when specifying the adversary we need to define not only how the next input item is generated, but also how it is colored. The key idea is that since the adversary knows and controls how future input items will be generated, it can anticipate its own moves and create a much better coloring than what an online algorithm can achieve without this knowledge. Unless explicitly stated otherwise, by an “algorithm” we always mean a deterministic algorithm.

Bins vs. Colors
We adopt the terminology introduced in [8]: when there is a possibility of ambiguity we say that an online algorithm colors with bins and the adversary with colors in order to distinguish the two. Let v be a vertex. We use the notation b(v) to denote the bin that is assigned to v by an online algorithm, and c(v) to denote the color that is assigned to v by the adversary. Let A be a set of vertices. Define 𝑏(𝐴)={𝑏(𝑣):𝑣∈𝐴} and 𝑐(𝐴)={𝑐(𝑣):𝑣∈𝐴}. Sometimes, we say that bin b contains v to mean that 𝑏(𝑣)=𝑏.

Saturated Bins
We define a notion that is inspired by several previous works [6, 8, 14].

Definition 1
Suppose that the adversary is constructing a 𝜒-colorable graph. A bin b is said to be p-saturated if there are p vertices 𝑣1,…,𝑣𝑝 such that

𝑏(𝑣1)=⋯=𝑏(𝑣𝑝)=𝑏,|{𝑐(𝑣1),𝑐(𝑣2),…,𝑐(𝑣𝑝)}|=𝑝.
(1)
A bin b is said to be perfectly p-saturated if bin b is p-saturated and it contains exactly p vertices. When a bin b is 𝜒-saturated, we simply say bin b is saturated.

The following simple fact shows why this notion might be interesting.

Fact. If t bins are all saturated, then every color class contains t vertices in distinct bins. By connecting a new vertex to these t vertices, the algorithm is forced to use a new bin.

The notion of saturated bins is already implicit in some previous works. For example, the so-called “two-sided colors”Footnote4 in [6] are saturated bins when 𝜒=2. The construction in [6] forces many two-sided colors, i.e., many saturated bins. The proof of a lower bound in [8], which we mentioned earlier as an example that does not use the common create-and-merge-components strategy directly, could be summarized as follows: the adversary has a strategy to force any algorithm to use perfectly p-saturated bins for 1≤𝑝≤𝜒/2. In [14], the lower bound construction does not necessarily force p-saturated bins, but seeks to create a situation where a weaker form of the above Fact is bound to appear.

In Sect. 4, we show that a 𝜅-CB adversary can successively force saturated bins on FirstFit for 𝜒-colorable graphs. This leads to the algorithm being noncompetitive. Explicit examples of saturated bins can be seen in Fig. 1 in Sect. 4. The construction of forcing saturated bins on FirstFit is generalized in Sect. 6 to work for all algorithms.

A New Type of Adversary
Let cc(G) denote the number of connected components of graph G.

Definition 2
An adversary is said to be 𝜅-components-bounded, or 𝜅-CB, if the input graph G and the presentation order 𝜎 satisfy

∀ 𝑖∈[𝑛]𝑐𝑐(𝐺∩𝜎([𝑖]))≤𝜅.
(2)
Let  denote a deterministic online coloring algorithm. Define 𝛽(,𝜅,𝐺) to be the maximal number of bins  has to use when a 𝜅-CB adversary constructs the graph G. Let  denote a class of graphs. Define

𝛽(,𝜅,)=sup𝐺∈𝛽(,𝜅,𝐺),
(3)
and

𝛽(𝜅,)=inf𝛽(,𝜅,).
(4)
Let 𝜒∈ℕ. By identifying 𝜒 with the class of graphs that are 𝜒-colorable, the notation 𝛽(,𝜅,𝜒) and 𝛽(𝜅,𝜒) are defined via (3) and (4), respectively. Let TREE denote the class of graphs that are trees.

Different from traditional online coloring models, a feature of the 𝜅-CB adversary model is that the number of vertices of a graph is not necessarily a parameter in the model. In this work, the 𝜅-CB adversary is allowed to construct graphs with arbitrarily many vertices. We will be interested in understanding what the power and limitations are for an adversary who can use an unlimited number of vertices but is 𝜅-CB.

Proposition 1
Let 𝛺 denote the set of all possible graphs and let  be an arbitrary algorithm. Then,

𝛽(,1,𝛺)=∞.
Proof
For every 𝑛∈ℕ, let 𝐾𝑛 denote the complete graph on n vertices. Obviously, an adversary can present 𝐾𝑛 in any presentation order while maintaining a single connected component. Thus, 𝛽(,1,𝐾𝑛)≥𝑛. As n is arbitrary, the result follows. ◻

Hence, the 𝜅-CB adversary model becomes interesting when we consider special classes of graphs. For example, 𝛽(𝐹𝑖𝑟𝑠𝑡𝐹𝑖𝑡,𝜅,2) denotes the maximal number of bins the 𝜅-CB adversary can force FirstFit (see Algorithm 1) to use by constructing a bipartite graph.

FirstFit on 𝜒-Colorable Graphs, Triangle-Free Graphs, and Trees
In this section, we completely characterize the performance of FirstFit on 𝜒-colorable graphs, triangle-free graphs, and trees for 𝜅-CB adversaries. We begin with the following theorem, which completely determines 𝛽(𝐹𝑖𝑟𝑠𝑡𝐹𝑖𝑡,𝜅,𝜒) for all 𝜅,𝜒∈ℕ.

Theorem 1
Let 𝜅∈ℕ,𝜒∈ℕ.

(1)
𝛽(𝐹𝑖𝑟𝑠𝑡𝐹𝑖𝑡,𝜅,1)=1 for every 𝜅≥1;

(2)
𝛽(𝐹𝑖𝑟𝑠𝑡𝐹𝑖𝑡,1,2)=2;

(3)
𝛽(𝐹𝑖𝑟𝑠𝑡𝐹𝑖𝑡,2,2)=∞

(4)
𝛽(𝐹𝑖𝑟𝑠𝑡𝐹𝑖𝑡,𝜅,𝜒)=∞ for every 𝜅≥1 and 𝜒≥3.

Proof
(1)
The graphs that are 1-colorable and can be presented by a 𝜅-CB adversary consist of up to 𝜅 isolated vertices. Clearly, FirstFit uses a single bin on such graphs.

(2)
A simple induction shows that FirstFit maintains a valid 2-coloring when a bipartite graph is revealed by a 1-CB adversary. The base case of a single vertex is trivial. In the inductive step, the newly arriving vertex has edges going to the “opposite” side of the bipartition (due to the 1-CB restriction). By the inductive assumption, those neighbors have been assigned to a single bin consistent with a valid 2-coloring, FirstFit correctly identifies the other bin for the new vertex.

(3)
Let n be even and consider the graph 𝐺=(𝑉,𝐸) with the vertex set 𝑉={𝑣𝑖∣𝑖∈[𝑛]} and the edge set defined by connecting each vertex 𝑣2𝑘−1 with 𝑣2𝑘′ for 𝑘,𝑘′∈[𝑛/2] and 𝑘≠𝑘′. Since all edges go in between odd-indexed and even-indexed vertices, the graph is clearly bipartite. The adversary presents vertices in order 𝑣1,𝑣2,𝑣3,…,𝑣𝑛. This presentation order satisfies the 2-CB constraint: 𝑣1 is initially in one connected component, when 𝑣2 arrives it is isolated and forms the second component, and every future vertex has an edge either to 𝑣1 or 𝑣2. An example of this graph for 𝑛=8 is shown in Fig. 1a.

Let b(v) denote the bin that FirstFit assigns v to. We show by induction on 𝑘∈[𝑛/2] that 𝑏(𝑣2𝑘−1)=𝑏(𝑣2𝑘)=𝑘. The base case of 𝑘=1 is trivial since when 𝑣1 and 𝑣2 arrive they are isolated vertices, so they are placed in bin 1 by FirstFit. In the inductive step, 𝑣2𝑘−1 is connected to 𝑣2𝑘′ for 𝑘′∈[𝑘−1]. By induction, 𝑏(𝑣2𝑘′)=𝑘′, therefore FirstFit assigns 𝑣2𝑘−1 to a new bin k. A similar argument holds for the next arriving vertex 𝑣2𝑘.

As n can be arbitrary large, the result follows.

(4)
Since 𝛽(𝐹𝑖𝑟𝑠𝑡𝐹𝑖𝑡,𝜅,𝜒) is non-decreasing with respect to both 𝜅 and 𝜒, it suffices to show that 𝛽(𝐹𝑖𝑟𝑠𝑡𝐹𝑖𝑡,1,3)=∞. Let n be a multiple of 3 and consider the graph 𝐺=(𝑉,𝐸) with the vertex set 𝑉={𝑣𝑖∣𝑖∈[𝑛]}. The adversary presents vertices in order 𝑣1,…,𝑣𝑛. The edge set is defined by the following construction. As usual, we let c(v) denote the color that the adversary maintains for vertex v, while b(v) denotes the bin used by FirstFit.

The construction consists of two phases: the initial phase and the inductive phase. During the initial phase, the adversary presents a path of 6 vertices: 𝑣1,𝑣2,𝑣3,𝑣4,𝑣5,𝑣6. Clearly, when 𝑣1 arrives it is an isolated vertex, but each subsequent vertex 𝑣𝑖 is revealed with a single edge to 𝑣𝑖−1. This clearly satisfies the 1-CB constraint. The adversary assigns colors 𝑐(𝑣1)=𝑐(𝑣4)=red, 𝑐(𝑣2)=𝑐(𝑣5)=green, and 𝑐(𝑣3)=𝑐(𝑣6)=blue. This is a valid 3-coloring (although 2 colors are sufficient, the adversary uses more colors in anticipation of the inductive phase). FirstFit assigns bins 𝑏(𝑣1)=𝑏(𝑣3)=𝑏(𝑣5)=1 and 𝑏(𝑣2)=𝑏(𝑣4)=𝑏(𝑣6)=2. The result of the initial phase is that FirstFit ends up with 2 bins that are 3-saturated.

The inductive phase proceeds in rounds. In round 𝑘∈[3,𝑛/3], the vertex 𝑣3𝑘−2 is revealed and its pre-neighborhood consists of vertices 𝑣3𝑘′−1 for 𝑘′∈[𝑘−1]. Then the vertex 𝑣3𝑘−1 is revealed and its pre-neighborhood consists of vertices 𝑣3𝑘′ for 𝑘′∈[𝑘−1]. Lastly, the vertex 𝑣3𝑘 is revealed and its pre-neighborhood consists of vertices 𝑣3𝑘′−2 for 𝑘′∈[𝑘−1]. The adversary assigns 𝑐(𝑣3𝑘−2)=red,𝑐(𝑣3𝑘−1)=green, and 𝑐(𝑣3𝑘)=blue. By a straightforward induction, FirstFit assigns 𝑏(𝑣3𝑘−2)=𝑏(𝑣3𝑘−1)=𝑏(𝑣3𝑘)=𝑘: prior to round k, FirstFit has 𝑘−1 bins that are 3-saturated; during round k, FirstFit creates a new bin and places all three new vertices into that bin making it 3-saturated. The initial phase described in the previous paragraph establishes The base case of the induction.

The coloring maintained by the adversary is easily seen to be valid, since the color classes consist of vertices whose indices have the same remainder mod3, while the edges are present only between two vertices whose indices have different remainders mod3. The 1-CB constraint is clearly maintained during the inductive phase.

An example of this construction for 𝑛=12 is shown in Fig. 1b. ◻

Fig. 1
figure 1
Examples of adversarial inputs used in the proof of Theorem 1. Columns indicate the coloring maintained by the adversary, while rows indicate the bins used by FirstFit

Full size image
Observe that the construction in part (4) of Theorem 1 results in a triangle-free graph. Let 𝚃𝚁𝙸𝙰𝙽𝙶𝙻𝙴-𝙵𝚁𝙴𝙴 denote the class of triangle-free graphs.

Corollary 1
𝛽(𝐹𝑖𝑟𝑠𝑡𝐹𝑖𝑡,1,𝚃𝚁𝙸𝙰𝙽𝙶𝙻𝙴-𝙵𝚁𝙴𝙴)=∞.

Part (4) of Theorem 1 and Corollary 1 will be generalized in Sect. 6.

We conclude this section by giving a complete analysis of FirstFit on trees with respect to the 𝜅-CB adversary.

Theorem 2
𝛽(𝐹𝑖𝑟𝑠𝑡𝐹𝑖𝑡,𝜅,𝚃𝚁𝙴𝙴)=𝜅+1.

Proof
The lower bound 𝛽(𝐹𝑖𝑟𝑠𝑡𝐹𝑖𝑡,𝜅,𝚃𝚁𝙴𝙴)≥𝜅+1 is witnessed by the so-called forest construction due to Bean [3] (also independently discovered in [7]). We claim that a 𝜅-CB adversary can construct a forest consisting of 𝜅 trees 𝑇1,𝑇2,…,𝑇𝜅 with the property that for each i the FirstFit algorithm uses color i on some vertex 𝑣𝑖 belonging to the tree 𝑇𝑖. We first prove this claim and later see how it implies the lower bound.

The construction is recursive and so we prove the above statement by induction on 𝜅. The base case is trivial: when 𝜅=1 the adversary can give a single isolated vertex. Assume that the statement is true for 𝜅 and we wish to establish it for 𝜅+1. The adversary begins by invoking induction and creating 𝑇1,𝑇2,…,𝑇𝜅 such that for 𝑖∈[𝜅] there is 𝑣𝑖∈𝑇𝑖 such that 𝑏(𝑣𝑖)=𝑖 is assigned by FirstFit. Then, the adversary creates a new vertex u connected to all the 𝑣𝑖. This process merges all existing trees into a single tree, which we call 𝑇′𝜅+1. Moreover, this forces FirstFit to assign 𝑏(𝑢)=𝜅+1. This tree is set aside, and to satisfy the claim for 𝜅+1, the adversary invokes the induction again to create another set of trees 𝑇′1,…,𝑇′𝜅 with 𝑣′𝑖∈𝑇′𝑖 such that 𝑏(𝑣′𝑖)=𝑖. Note that creating 𝑇′𝑖 requires at most 𝜅 components, so the adversary is (𝜅+1)-CB (remember that we have an additional component 𝑇′𝜅+1 set aside during the second invocation of induction). Moreover, note that 𝑏(𝑢)=𝜅+1, so the trees 𝑇′1,…,𝑇′𝜅+1 satisfy the claim.

This claim implies the lower bound since the 𝜅-CB adversary can present 𝑇1,…,𝑇𝜅 with 𝑏(𝑣𝑖)=𝑖 for some 𝑣𝑖∈𝑇𝑖. In the last step, the adversary presents u connected to each 𝑣𝑖. This process does not increase the number of components and forces 𝑏(𝑢)=𝜅+1. An example of this construction is shown in Fig. 2.

Next, we show the upper bound 𝛽(𝐹𝑖𝑟𝑠𝑡𝐹𝑖𝑡,𝜅,𝚃𝚁𝙴𝙴)≤𝜅+1. Suppose that FirstFit uses 𝑚+1 bins for some m. Let v be the first vertex which is placed into bin 𝑚+1 by FirstFit. By the definition of FirstFit, there are m vertices in the pre-neighborhood 𝑁−(𝑣) that have been previously assigned to bins 1,2,…,𝑚. Since the adversary is constructing a tree, there can be no cycle. Hence, these m vertices must be in distinct components, i.e., there are at least m distinct components. ◻

Fig. 2
figure 2
An example of the forest construction used in the proof of Theorem 2. The adversary presents the vertices in order: 𝑣1,𝑣2,𝑣3,…,𝑣8. The FirstFit uses 4 bins while the adversary uses 3 connected components during this construction

Full size image
CBIP on Bipartite Graphs
We will establish the tight bound of 2𝜅 on the number of bins used by CBIP with respect to a 𝜅-CB adversary on bipartite graphs and trees. This provides a finer understanding of the performance of CBIP and is particularly interesting in light of previous lower bounds. Gutowski et al. [6] proved that any online algorithm has to use at least 2log𝑛−10 bins for coloring bipartite graphs with n vertices, which matches the upper bound on CBIP from [11] up to the additive constant −10. The construction in [6] applied to CBIP (or even FirstFit) uses log𝑛 disjoint connected components to force 2log𝑛 bins. The main result of this section which we state next, in particular demonstrates that this is a necessary feature of their construction.

Theorem 3
𝛽(𝐶𝐵𝐼𝑃,𝜅,𝚃𝚁𝙴𝙴)=𝛽(𝐶𝐵𝐼𝑃,𝜅,2)=2𝜅.

Proof
Since 𝛽(𝐶𝐵𝐼𝑃,𝜅,2)≥𝛽(𝐶𝐵𝐼𝑃,𝜅,𝚃𝚁𝙴𝙴), the lower bound follows from Lemma 1 and the upper bound follows from Lemma 2. ◻

Observe that Theorem 3 implies that, in the class of bipartite graphs, worst-case input already appears in TREE for CBIP.

We begin by establishing the lower bound used in the above theorem.

Lemma 1
𝛽(𝐶𝐵𝐼𝑃,𝜅,𝚃𝚁𝙴𝙴)≥2𝜅.

Proof
In this proof, the notation r(T) is used to denote the root of a rooted tree T. The statement of the theorem is witnessed by the following recursive adversarial construction:

The base cases: 𝑇1 is a rooted tree consisting of a single vertex. 𝑇2 is a rooted tree consisting of one edge, where 𝑟(𝑇2) is defined as the vertex that is assigned to bin 2 by CBIP.

Recursive step: let 𝑖≥3. To construct 𝑇𝑖 the adversary does the following:

(1)
it constructs 𝑇𝑖−1;

(2)
it constructs 𝑇𝑖−2;

(3)
it presents a new vertex v connected via an edge to 𝑟(𝑇𝑖−1) and via another edge to 𝑟(𝑇𝑖−2).

The vertex from step (3) becomes the root 𝑟(𝑇𝑖) of the newly formed tree 𝑇𝑖.

As usual, let b(v) denote the bin to which v is assigned by CBIP. For each i, let 𝐸𝑖 denote the set of vertices that are at even distance from 𝑟(𝑇𝑖) in 𝑇𝑖. Similarly, let 𝑂𝑖 denote the set of vertices at odd distance from 𝑟(𝑇𝑖) in 𝑇𝑖. We claim that for the above construction it holds that

(i)
𝑏(𝐸𝑖)=[𝑖]∖{𝑖−1};

(ii)
𝑏(𝑂𝑖)=[𝑖−1];

(iii)
the construction of 𝑇𝑖 satisfies the ⌊𝑖/2⌋-CB constraint.

We prove the above claim by strong induction on i. The statements are immediate for The base cases of 𝑇1 and 𝑇2. Assume that the statement holds for all 𝑗≤𝑖−1 for some 𝑖≥3. Next, consider 𝑇𝑖. Examining the construction we obtain:

𝐸𝑖=𝑂𝑖−2∪𝑂𝑖−1∪{𝑣},

𝑂𝑖=𝐸𝑖−2∪𝐸𝑖−1.

Using the inductive assumption, we have 𝑏(𝐸𝑖−2)=[𝑖−2]∖{𝑖−3} and 𝑏(𝐸𝑖−1)=[𝑖−1]∖{𝑖−2}. Therefore, we have 𝑏(𝑂𝑖)=𝑏(𝐸𝑖−2∪𝐸𝑖−1)=[𝑖−1] establishing part (ii) of the claim.

Using the inductive assumption again, we have 𝑏(𝑂𝑖−2)=[𝑖−3] and 𝑏(𝑂𝑖−1)=[𝑖−2]. Therefore, 𝑏(𝐸𝑖∖{𝑣})=𝑏(𝑂𝑖−2∪𝑂𝑖−1)=[𝑖−2].

CBIP uses the bipartition induced by 𝐸𝑖 and 𝑂𝑖 to decide how to color v. Specifically, CBIP uses the first available bin other than those in 𝑂𝑖. Therefore, since 𝑏(𝑂𝑖)=[𝑖−1] we have 𝑏(𝑣)=𝑖. Combining it with the result from the previous paragraph, we get 𝐵(𝐸𝑖)=[𝑖]∖{𝑖−1} establishing part (i) of the claim.

As for the number of connected components used in the presentation of 𝑇𝑖, observe that step (1) uses ⌊(𝑖−1)/2⌋ components by induction. After step (1), 𝑇𝑖−1 is put aside as a separate component. Therefore, step (2) uses 1+⌊(𝑖−2)/2⌋ connected components (we invoked the inductive assumption one more time here). Step (3) of the construction does not require any additional components. Therefore, the total number of components is bounded by max(⌊(𝑖−1)/2⌋,1+⌊(𝑖−2)/2⌋). It is easy to see that this expression is exactly ⌊𝑖/2⌋ by considering the cases of odd and even i separately. This establishes part (iii) of the claim.

Lastly, note that the claim implies that CBIP uses 2𝜅 bins on 𝑇2𝜅 and that the presentation of 𝑇2𝜅 satisfies the 𝜅-CB constraint. ◻

We finish this section with a matching upper bound for the class of bipartite graphs.

Lemma 2
𝛽(𝐶𝐵𝐼𝑃,𝜅,2)≤2𝜅.

Proof
Consider a certain point in execution of CBIP on the input graph. As usual, let b(v) denote the bin to which v is assigned by CBIP. We say that a connected component CC is of Type 1[ℓ] if CC can be partitioned into two subsets of vertices A and B (the subsets A and B will also be called blocks) such that

all edges go between A and B

𝑏(𝐴)=[ℓ−2]

𝑏(𝐵)=[ℓ−1]

Similarly, we say that a connected component CC is of Type 2[ℓ] if CC can be partitioned into two subsets of vertices A and B such that

all edges go between A and B

𝑏(𝐴)=[ℓ−2]∪{ℓ}

𝑏(𝐵)=[ℓ−1]

Figure 3 shows an example construction with two connected components of Type 2[4] and Type 1[5].

Fig. 3
figure 3
A snapshot of an execution of CBIP on an input instance, with vertices presented in left-to-right order. At this step in the presentation, the graph contains two connected components 𝐶𝐶1 and 𝐶𝐶2 of Type 2[4] and Type 1[5] respectively. Labels indicate bins used by CBIP

Full size image
The high-level idea is that the 𝜅-CB adversary can only force components that are either of Type 1[ℓ] or of Type 2[ℓ] for some ℓ≤2𝜅. Before we prove it formally, we observe that when a new vertex v arrives, it can either (1) be an isolated vertex (taken to be of Type 1[2]), (2) be added to an existing component, or (3) be used to merge two or more existing components. Formally, we say that components 𝐶𝐶1,𝐶𝐶2,…,𝐶𝐶𝑗 get merged at time t if vertex 𝑣=𝜎(𝑡) satisfies 𝑁−(𝑣)∩𝐶𝐶𝑖≠∅ for 𝑖∈[𝑗], and 𝐶𝐶𝑖 were distinct connected components at time 𝑡−1.

We record what happens to types of components after each of the above operations (1), (2) and (3). During operation (1), a new vertex of Type 1[ℓ] for ℓ=2 is added. Clearly, ℓ≤2𝜅 for any 𝜅≥1. Next, we consider operation (2), i.e., when a new vertex v gets added to a component CC. We assume that the two blocks of CC are A and B and that they satisfy the conditions of Type 1 or 2. The resulting component is called 𝐶𝐶′. The changes to types after vertex v is presented are recorded in Table 1.

Table 1 Type changes for case (1), i.e., when v is added to an existing component
Full size table
Finally, we consider what happens when a vertex v is used to merge two or more components. We distinguish four types of components, the numbers of which are denoted by 𝑘1,𝑘2,𝑘3, and 𝑘4, respectively:

1.
𝐶𝐶𝐴𝑖 of Type 1[ℓ𝐴𝑖] for 𝑖∈[𝑘1]. Vertex v has a neighbor on the A-side of such components.

2.
𝐶𝐶𝐵𝑖 of Type 1[ℓ𝐵𝑖] for 𝑖∈[𝑘2]. Vertex v has a neighbor on the B-side of such components.

3.
𝐶𝐶′𝐴𝑖 of Type 2[ℓ′𝐴𝑖] for 𝑖∈[𝑘3]. Vertex v has a neighbor on the A-side of such components.

4.
𝐶𝐶′𝐵𝑖 of Type 2[ℓ′𝐵𝑖] for 𝑖∈[𝑘4]. Vertex v has a neighbor on the B-side of such components.

Let 𝑚=max{ℓ𝐴𝑖1,ℓ𝐵𝑖2,ℓ′𝐴𝑖3,ℓ′𝐵𝑖4:𝑖1∈[𝑘1],𝑖2∈[𝑘2],𝑖3∈[𝑘3],𝑖4∈[𝑘4]}. We call m the type parameter of the partially constructed input graph.

We say that a block A or B of a particular component being merged is on the opposite side of v if v has a neighbor among the vertices of the block. Otherwise, we say that the block is on the same side as v. For example, block A of 𝐶𝐶𝐴𝑖 component is on the opposite side of v, whereas block B of the same component is on the same side as v. Let 𝑆−𝑣 denote the set of bins already used for the vertices of blocks on the opposite side of v, and let 𝑆𝑣 denote the set of bins already used for the vertices of blocks on the same side as v. By the definitions of Type 1 and 2 components as well as m, it is easy to see that each of 𝑆𝑣,𝑆−𝑣 can be only one of the following four options: [𝑚−2],[𝑚−1],[𝑚−2]∪{𝑚},[𝑚]. This reduces the problem of computing the type of the merged component to analyzing 16 cases. For example, if 𝑆−𝑣=[𝑚−2] and 𝑆𝑣=[𝑚−2] then vertex v will be assigned bin 𝑚−1 and the merged component will be of Type 1[m] since it will have one side with bins [𝑚−2] and the opposite side with bins [𝑚−1]. We denote the merged component by 𝐶𝐶′ and Table 2 summarizes all of the 16 cases.

Table 2 Type changes for case (2), i.e., when v is used to merge some existing components
Full size table
The reason that certain combinations in Table 2 are impossible is that if one side is colored with bins [m] then the opposite side must use bin 𝑚−1 (because of how CBIP works).

Observe that from Table 2, the type parameter of 𝐶𝐶′ can either stay the same, increase by additive 1, or increase by additive 2. Furthermore, it can be directly verified from the table that an increase is possible only if there are at least two components having type parameters not less than 𝑚−1. We refer to this property as the continuity of the type parameter.

Assume that the input graph G and the presentation order 𝜎 satisfy the 𝜅-CB condition, then the above observations imply the following statements:

(i)
∀ 𝑖 we have 𝐺∩𝜎([𝑖]) consists of Type 1/2[ℓ] components for ℓ≤2𝜅;

(ii)
∀ 𝑖 there can be at most one component that is of one of the following four types: Type 1[2𝜅−1], Type 1[2𝜅], Type 2[2𝜅−1], Type 2[2𝜅].

Note that (i) immediately implies the statement of this lemma.

These statements can be proved by induction on 𝜅. The base case 𝜅=1 is easy to verify. Indeed, if 𝑖=1, i.e., there is just a single vertex, then it is of Type 1[2]. Consider 𝑖≥2. Observe that for 𝜅=1 the algorithms CBIP and FirstFit have identical behavior. Therefore, (2) in Theorem 1 shows (i) is true, and the single component is of Type 2[2]. Hence, (ii) is true.

We proceed to the induction step. Assume (i) and (ii) are true for 𝜅, we consider the case 𝜅+1. First, we show (ii). Let 𝐶𝐶1 be the first component that is of one of the following types: Type 1[2𝜅+1], Type 1[2𝜅+2], Type 2[2𝜅+1], Type 2[2𝜅+2]. Since the adversary is (𝜅+1)-CB, the existence of 𝐶𝐶1 implies that the adversary becomes 𝜅-CB when creating any new component that is disjoint from 𝐶𝐶1. By the induction assumption, the adversary can only create components that are of Type 1/2[ℓ] for ℓ≤2𝜅. This proves (ii). Next we show (i). By the continuity of the type parameter, in order for the type parameter to go beyond 2𝜅+2 there need to be at least two components both having type parameters not less than 2𝜅+1. By (ii), this is impossible, so (i) is true. ◻

Lower Bounds for Several Graph Classes
In this section we establish non-existence of competitive algorithms against 𝜅-CB adversaries for various classes of graphs. We begin by establishing a strong non-competitiveness result for 𝜒-colorable graphs for 𝜒≥3. This generalizes part (4) of Theorem 1 to arbitrary algorithms.

Theorem 4
𝛽(1,𝜒)=∞ for every 𝜒≥3.

Proof
Since 𝛽(1,𝜒) is non-decreasing in 𝜒, it suffices to prove that 𝛽(1,3)=∞. Fix an arbitrary coloring algorithm . We show that for every 𝑡∈ℕ, a 1-CB adversary can construct a 3-colorable graph G so that  uses at least t different bins to color vertices in G. It may be helpful to consult Fig. 4 while reading this proof.

The construction of G proceeds in layers, which we denote by 𝐿1,𝐿2,…,𝐿𝑡−1. Vertices (and their pre-neighborhoods) in 𝐿1 are presented first, followed by 𝐿2, and so on. The construction stops as soon as  uses t distinct bins, which may happen before 𝐿𝑡−1 and will be guaranteed to happen in 𝐿𝑡−1.

Each layer consists of “sufficiently many” vertices, meaning that there should be enough vertices in lower layers to guarantee that the construction of higher layers goes through. Initially, we don’t quantify “sufficiently many,” although we shall give some estimates on sizes of layers at the end of this proof.

Layer 𝐿1 is simply a path P of sufficiently large length ℓ1. The adversary presents the vertices in P in the order in which they appear on the path. There are two possibilities: (i)  already uses at least t bins to color P; (ii)  uses fewer than t bins to color P. In case (i) the construction is over and the adversary has achieved its goal.

Next, we handle case (ii). Observe that  has to use at least two different bins to color P correctly. Consider two bins 𝑏1 and 𝑏2 with the most number of vertices assigned to them by . Let the sets of vertices assigned to those bins be 𝐵1 and 𝐵2, respectively, with |𝐵1|≥|𝐵2|. The definition of case (ii) implies that |𝐵1|≥ℓ1/𝑡. Since P is a path, no bin can contain more than ℓ1/2+1 vertices. Thus, the number of vertices not in 𝐵1 is at least ℓ1/2−1. Since they are partitioned among at most 𝑡−1 bins, including 𝐵2, and 𝐵2 is most populous then |𝐵2|≥(ℓ1/2−1)/(𝑡−1)=(ℓ1−2)/(2𝑡−2). Next, we select subsets 𝐵′1⊆𝐵1 and 𝐵′2⊆𝐵2 so that all the vertices in 𝐵′1∪𝐵′2 are non-adjacent in P and |𝐵′1|=|𝐵′2|=ℓ1/(10𝑡). This can be done as follows: alternatively pick a vertex from 𝐵1 or 𝐵2 to include in 𝐵′1 or 𝐵′2, respectively, and remove its neighbors from 𝐵2 or 𝐵1, respectively. Each pair of such steps includes one vertex into 𝐵′1 and one vertex into 𝐵′2 removing at most 3 vertices from each 𝐵1 and 𝐵2 from future considerations. Thus, this can go on for at least |𝐵2|/3≥ℓ1/(10𝑡) rounds. In conclusion, we end up with sets of vertices 𝐵′1 and 𝐵′2 such that

all vertices in 𝐵′𝑖 are placed in bin 𝑏𝑖 by , where 𝑖∈{1,2};

|𝐵′1|=|𝐵′2|=ℓ1/(10𝑡).

In particular, the second item implies that |𝐵′1| and |𝐵′2| can be assumed to be sufficiently large.

Construction of each following layer 𝐿𝑖 for 𝑖≥2 either terminates early because  used at least t different bins or forces  to assign sufficiently many vertices to bin 𝑏𝑖+1. We shall denote the set of such verticesFootnote5𝐵′𝑖+1 for layer 𝐿𝑖. Assuming that the construction hasn’t terminated in layer 𝐿𝑖−1, the next layer 𝐿𝑖 is constructed by the adversary by repeating the following steps sufficiently many times:

(1)
the adversary chooses vertices 𝑢𝑗∈𝐵′𝑗 for all 𝑗≤𝑖 arbitrarily;

(2)
the adversary presents a new vertex v with pre-neighborhood {𝑢1,…,𝑢𝑖};

(3)
the adversary updates 𝐵′𝑗←𝐵′𝑗∖{𝑢𝑗} for all 𝑗≤𝑖.

Due to step (3) we say that v consumes vertices 𝑢𝑗 from 𝐵′𝑗 for 𝑗∈[𝑖]. Observe that step (2) guarantees that  has to assign v to a bin other than 𝑏1,…,𝑏𝑖. Just as for layer 𝐿1, if  uses t different bins in this layer then we are done. Otherwise, let 𝑏𝑖+1 be the bin that has the most number of vertices assigned to it in layer 𝐿𝑖. If the adversary presents ℓ𝑖 vertices in layer 𝐿𝑖 then the number of vertices assigned to 𝑏𝑖+1 is at least ℓ𝑖/𝑡. We let 𝐵′𝑖+1 be an arbitrary subset of such vertices of size exactly ℓ𝑖/𝑡.

This construction continues until layer 𝐿𝑡−1 where the adversary can present a single vertex according to the above scheme forcing  to assign it to a new bin 𝑏𝑡. Overall,  then uses t different bins, namely, 𝑏1,…,𝑏𝑡.

To guarantee that step (1) in the above construction always works, we need to make sure that all sets 𝐵′𝑗 are sufficiently large for this construction to reach layer 𝐿𝑡−1. This is possible provided that for 𝑖≥2 we have |𝐵′𝑖+1|≥∑𝑡−1𝑗=𝑖+1ℓ𝑗 since each vertex in a layer above i consumes one vertex from 𝐵′𝑖 (step (3) of the above construction). We also need a similar condition for layer 1, namely, that |𝐵′2|=|𝐵′1|≥∑𝑡−1𝑗=2ℓ𝑗. Thus, we end up with the following system of inequalities:

ℓ𝑡−1=1;

ℓ𝑖/𝑡≥∑𝑡−1𝑗=𝑖+1ℓ𝑗 for 𝑖∈{2,3,…,𝑡−2};

ℓ1/(10𝑡)≥∑𝑡−1𝑗=2ℓ𝑗.

It is straightforward to check that ℓ𝑡−1=1, ℓ𝑖=𝑡(𝑡+1)𝑡−𝑖−2 for 𝑖∈[2,𝑡−2] and ℓ1=10𝑡(𝑡+1)𝑡−3 is a valid solution to the above system. Thus, a feasible construction can be carried out by the adversary. The total number of vertices in this construction is at most 20𝑡(𝑡+1)𝑡−3.

Observe that the construction clearly satisfies the 1-CB constraint, since layer 𝐿1 is presented as a single connected component and every vertex in a higher layer is adjacent to a vertex in layer 𝐿1.

We also note that the construction creates an almost-forest. More specifically, call the vertex v in step (2) of the above construction the parent of the corresponding 𝑢𝑗 for 𝑗∈[𝑖] chosen in step (1). Observe that due to step (3), each vertex has at most one parent. Therefore, the only thing preventing this construction from being a forest is layer 𝐿1, which can be thought of as a path going through all the leaves of the forest. This implies that the constructed graph is 3-colorable. Consider the subgraph obtained by removing all edges in layer 𝐿1 along with all vertices that do not have parents. Since it is a forest, it is 2-colorable. Moreover, any valid 2-coloring of this subgraph is also a partial valid 2-coloring of the entire graph since we chose 𝐵′1 and 𝐵′2 to be non-adjacent. We can then extend this partial coloring to a complete 3-coloring of the entire graph by using a greedy strategy. Note that uncolored vertices in 𝐿1 have degree at most 2, so a greedy coloring would use at most 3 colors. ◻

Fig. 4
figure 4
Example of the construction used in Theorem 4. This is a hypothetical example for some  that assigns bins to vertices according to the figure

Full size image
The above construction can be modified so that either  uses t bins or the adversary can successively force saturated bins. For example, the adversary can extend the level 𝐿1 and repeat the construction on the extended part. The adversary can do this sufficiently many times and recolor each copy so that saturated bins are forced.

The rough estimates on sufficient lengths of layers presented in the above proof immediately lead to the following quantitative version of the result.

Corollary 2
The 1-CB adversary can construct a 3-colorable graph on n vertices so that any online coloring algorithm uses at least 𝛺(log𝑛/loglog𝑛) bins.

Next, we note that the construction from Theorem 4 is quite robust. It can be modified in various ways to obtain similar non-competitiveness results for other classes of graphs. We first define the relevant classes.

𝐶𝑘-𝙵𝚁𝙴𝙴::
the class of graphs that do not contain a cycle of length k as a (not necessarily induced) subgraph.

𝑑-𝙸𝙽𝙳𝚄𝙲𝚃𝙸𝚅𝙴::
the class of d-inductive graphs, i.e., those graphs whose vertices can be numbered so that each vertex has at most d adjacent vertices among higher numbered vertices.

𝙿𝙻𝙰𝙽𝙰𝚁::
the class of planar graphs.

𝚃𝚁𝙴𝙴𝚆𝙸𝙳𝚃𝙷-𝑘::
the class of graphs of treewidth at most k.

We are now ready to state and prove the following corollary of the construction from Theorem 4.

Corollary 3
(1)
𝛽(1,𝐶𝑘-𝙵𝚁𝙴𝙴)=∞ for every 𝑘≥3.

(2)
𝛽(1,𝑑-𝙸𝙽𝙳𝚄𝙲𝚃𝙸𝚅𝙴)=∞ for every 𝑑≥2.

(3)
𝛽(1,𝙿𝙻𝙰𝙽𝙰𝚁)=∞.

(4)
𝛽(1,𝚃𝚁𝙴𝙴𝚆𝙸𝙳𝚃𝙷-𝑘)=∞ for every 𝑘≥5.

Proof
(1)
Since the construction in Theorem 4 is an almost-forest, the only cycles present are those using edges in layer 𝐿1. By making 𝐿1 longer we could insist that vertices in 𝐵′1 and 𝐵′2 are at least distance k apart: modify the procedure for selecting vertices into 𝐵′1 or 𝐵′2 by picking a vertex from 𝐵1 or 𝐵2 respectively and removing all vertices at distance k from it from 𝐵1 and 𝐵2. This modification insures that all cycles are of length greater than k.

(2)
Observe that the construction is 2-inductive: number vertices in the order in which they appear. Each vertex in layer 𝐿𝑖 for 𝑖≥2 has at most one neighbor among higher numbered vertices, namely, the vertex which we called the parent. A vertex in 𝐿1 potentially has 2 adjacent higher numbered vertices: at most one parent in layer 𝐿𝑖 for 𝑖≥2 and at most one neighbor in layer 𝐿1 which follows it in the path.

(3)
Since the construction in Theorem 4 is an almost-forest and the forest part is planar, we just need to make sure that the path in 𝐿1 does not break planarity. We could draw a plane embedding of the forest part and order leaves clockwise. If the vertices in 𝐿1 appear in the order consistent with this clockwise ordering of leaves then planarity can be maintained while adding vertices and edges from 𝐿1 back into the picture. Unfortunately, the clockwise ordering of leaves in plane embedding might be inconsistent with the ordering of these leaves along the path in 𝐿1. Fortunately, it is possible to adjust the construction to guarantee that the two orders are consistent. A completely formal proof of this is rather tedious, so we give a high-level description instead.

First, note that there is a single tree T such that for every algorithm  the forest-part of the construction produced for  is a subgraph of T, where the leaves are labelled as either 𝐵′1 or 𝐵′2 vertices. Second, we could consider the plane embedding of T and the clockwise ordering of leaves induces a sequential pattern of inter-mixed labels 𝐵′1 and 𝐵′2. Third, observe that by letting the path P in 𝐿1 be sufficiently long and taking a subset of 𝐵1 and 𝐵2 appropriately, any sequential pattern of inter-mixed labels 𝐵′1 and 𝐵′2 can be generated along the path P in 𝐿1. Therefore, the adversary can always generate 𝐵′1 and 𝐵′2 respecting the same sequential pattern as induced by the clockwise ordering of leaves in the plane embedding of T. This is how the adversary generates 𝐿1 in the modified construction. The adversary proceeds generating the subgraph of T as before, but it uses T as a guide: vertex v from step (2) of the construction can be mapped to a vertex in T and the children of v in T dictate which vertices {𝑢𝑗} are chosen in step (1) of the construction. An illustration is given in Fig. 5. This completes the argument.

(4)
Observe that the modified construction from the previous item is 2-outerplanar since after removing the vertices in 𝐿1 we are left with a graph where every vertex is adjacent to the unbounded face. Therefore by the result of Bodlaender [5] the construction has treewidth at most 5.

◻

Fig. 5
figure 5
Example of the construction used in parts 3 and 4 of Corollary 3. The vertices appearing on the circle are precisely the 𝐵′1 and 𝐵′2 subsets of 𝐿1 vertices. Other 𝐿1 vertices are not shown, but they can be visualized as being interspersed between them. Observe that the graph is planar and 2-outerplanar

Full size image
Conclusion and Open Problems
We have introduced a new type of adversary for online graph problems and studied online coloring with respect to this adversary. This led to an improved understanding of the properties of the two widely studied online coloring algorithms FirstFit and CBIP. Furthermore, when the adversary is 𝜅-CB for 𝜅=𝑂(1), Theorems 3 and 4 show a sharp contrast between bipartite graphs, for which the CBIP uses only O(1) bins, and 3-colorable graphs for which any algorithm has to use infinitely many bins. While our work suggests many directions for future research, we find the following questions particularly intriguing:

1.
What is 𝛽(1,𝚃𝚁𝙴𝙴𝚆𝙸𝙳𝚃𝙷-𝑘) for 𝑘∈{2,3,4}?

2.
We allow the adversary to use an unlimited number of vertices. A natural extension of our work is to study the dependency on n while the adversary is 𝜅-CB. Corollary 2 is a step in that direction. Can the lower bound in Corollary 2 be improved to 𝛺(log2𝑛), matching the best known lower bound in [14] for 3-colorable graphs when the adversary is unconstrained? On the other hand, we discusssed in the introduction that in practice it seems the case that 𝜅 is often O(1), hence it would be very interesting to see whether it is possible to improve the existing upper bounds (such as those in [14] and [10]) under the O(1)-CB adversary assumption.

3.
For a graph G and presentation order 𝜎 define 𝜅(𝐺,𝜎)=max𝑖𝑐𝑐(𝐺∩𝜎([𝑖])). What is the behaviour of 𝜅(𝐺,𝜎) in real-world instances? As we mention in the introduction, it is expected that 𝜅(𝐺,𝜎) is “small” for social networks. How “small” is it actually? What are typical values of 𝜅(𝐺,𝜎)? For a class of real-world instances for a particular application (such as transportation networks, social networks, or electrical networks), do 𝜅(𝐺,𝜎) values follow some well-defined distribution?

4.
One can study the power and limitations of the 𝜅-CB adversary in other related models, e.g., online algorithms with advice, streaming algorithms, temporal or dynamic graphs algorithms. Interactions between various features of those models and the 𝜅-CB constraint might lead to new algorithms or finer understanding of existing algorithms.

5.
Last but definitely not least, it would be rather interesting to study other online graph problems under the 𝜅-CB adversary.