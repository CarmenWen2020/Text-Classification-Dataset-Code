We introduce a new type of adversary for online graph problems thus allowing parametrized analysis of online algorithms with respect to a natural parameter. The new adversary is parameterized by a single integer ğœ…, which upper bounds the number of connected components that the adversary can use at any time during the presentation of the online graph G. We call this adversary â€œğœ…-components-boundedâ€, or ğœ…-CB for short. On one hand, this adversary is restricted compared to the classical adversary because of the ğœ…-CB constraint. On the other hand, we seek competitive ratios parameterized only by ğœ… with no dependence on the input length n, thereby giving the new adversary power to use arbitrarily large inputs. We study online coloring under the ğœ…-CB adversary. We obtain a finer analysis of the existing algorithms FirstFit and CBIP by computing their competitive ratios on trees and bipartite graphs under the new adversary: (1) Perhaps surprisingly, FirstFit outperforms CBIP on trees; (2) The competitive ratio of CBIP on bipartite graphs is simply ğœ…. We also study several well known classes of graphs, such as 3-colorable, ğ¶ğ‘˜-free, d-inductive, planar, and bounded treewidth, with respect to online coloring under the ğœ…-CB adversary. We demonstrate that the extra adversarial power of unbounded input length outweighs the restriction on the number of connected components leading to non-existence of competitive algorithms for these classes.

Access provided by University of Auckland Library

Introduction
In online graph problems the input graph is not known in advance, but is rather revealed one item at a time. In this paper we are concerned with the so-called vertex-arrival model, where the graph is revealed one vertex at a time. When a new vertex is revealed, an online algorithm learns the identity of the vertex as well as its neighborhood restricted to the already revealed vertices. Note that the algorithm gets no information about future vertices. Many graph problems do not admit any non-trivial online algorithms in the adversarial vertex-arrival model. Be that as it may, online graph problems often arise in real life applications in computer networks, public transit networks, electrical grids, and so on. Recently, the interest in online and â€œonline-likeâ€Footnote1 graph models and algorithms has been increasing since it is being sparked by the proliferation of online social networks. Thus, it is necessary to introduce various restrictions of the basic adversarial model that allow nontrivial algorithms while capturing interesting real-life scenarios.

One obtains a plethora of restricted adversaries simply by insisting that the adversary generates a graph belonging to a particular family of graphs, such as ğœ’-colorable, planar, d-inductive, etc. Another way to relax the classical adversarial model is to consider distributions on graphs and perform average-case analysis. One of the most studied distributions is, of course, the ErdÃ¶s-RÃ©nyi random graph. While it is mathematically appealing, real life graphs rarely follow this distribution. For example, one of the early empirical observations was that distributions on degrees of vertices in real social networks are most accurately modeled by power-law distributions [12], whereas the ErdÃ¶s-RÃ©nyi model induces a binomial distribution on degrees of vertices. Thus, new models of random graphs have been introduced in an attempt to approximate power-law distributions on degrees. Many of these new generative models are inherently offline. A notable exception is the preferential attachment model [2], which perfectly fits within the vertex-arrival model. The formal definition is technical, but at a high level this model works as follows. When a new vertex v arrives its neighborhood is generated by connecting v to an already existing vertex u with probability proportional to the current degree of u. This model has a natural motivation: consider a person signing up for some social network, where people can â€œfollowâ€ each other. This person is signing up not because they want to be left alone (i.e. form a new connected component), but because they already have a list of people in mind who they will follow (i.e., join existing connected component(s), potentially merging some components together). It is more likely that the person is going to follow well known people, e.g. celebrities, who in turn have some of the highest numbers of followers in the network. This is akin to a new vertex in vertex-arrival model likely being connected to existing vertices of high degree.

The first starting point of our work is the observation that when a social network graph is generated via the preferential attachment process, there are very few connected components in the online graph at any point in time. Formalizing this observation in the adversarial setting, we investigate a new type of adversary that is restricted to using at most ğœ… connected components at any point in time during the generation of the online input graph. We call such adversary ğœ…-components-bounded, or ğœ…-CB for short.

In this paper we focus on the online coloring problem under the ğœ…-CB adversary. Indeed, another motivation for considering the ğœ…-CB adversary is to extend our understanding of lower-bound techniques for online coloring. Most of the past research uses the following methodology: the adversary creates a collection of disjoint components with some properties, then the adversary merges these components by creating a vertex appropriately connected to the components. The aim of this technique is to allow the adversary to observe the coloring of each component chosen by the algorithm, and then choose a â€œcorrectâ€ coloring of the components that differs from the one chosen by the algorithm. The adversary then connects the components together, forcing the algorithm to use extra colors (since the algorithmâ€™s coloring is incorrect inside at least one component). By iterating this process, the adversary tries to force the online algorithm to perform badly. Some variants of this technique have been used, for example, in [1, 4, 6, 7, 14]. A notable exception is [8], where this create-and-merge components technique is not directly involved. Usually, this type of construction involves a large number of disjoint components, typically logarithmic in the number of verticesâ€”see, for example, [6, 7]. Our goal is to formally analyze the power of this technique, and the extent of dependence of existing lower bounds on this technique. Specifically, we ask, what happens if the adversary in the online coloring problem is ğœ…-CB? In this work we investigate this question, while allowing the adversary to use an unlimited number of vertices to compensate for a limited number of components.

Our first set of results gives a finer understanding of the FirstFit and CBIP algorithms (for formal definitions see Sect. 2), which are well known in the online graph coloring community. We show that, perhaps surprisingly, FirstFit outperforms CBIP on trees with respect to the ğœ…-CB adversary. The optimality of FirstFit, up to a constant factor, has been shown for several classes of graphs including trees in [1]. Our results can be viewed as a strengthening of [1]: FirstFit can perform strictly better than CBIP on trees. For general bipartite graphs, we show that CBIP uses at most 2ğœ… colors against the ğœ…-CB adversary. This result is particularly interesting in the context of existing lower bounds on the performance of CBIP on bipartite graphs. In a series of works [4, 6, 7] it is shown that any online algorithm must use at least roughly 2logğ‘› colors where n is the number of vertices. The construction for this lower bound uses logğ‘› disjoint components. Our result shows that this is necessary. One often measures the performance of an online algorithm by its competitive ratioâ€”the worst-case ratio between the objective value achieved by an algorithm and the offline optimum. In the case of nontrivial bipartite graphs the offline optimum is 2, thus the difference between the absolute number of colors used by CBIP and its competitive ratio is just a factor of 2. But this difference has a philosophical significance: our result shows that the competitive ratio of CBIP on bipartite graphs is simply ğœ…: the number of components that the adversary is allowed to use.

Our second set of results shows that for several classes of graphs, including ğœ’-colorable graphs, the ğœ…-CB adversary equipped with unlimited number of vertices is powerful enough to rule out competitive algorithms even when ğœ…=1. These two sets of results provide another contrast between bipartite graphs and other classes of graphs.

Besides the technical results, we view the ğœ…-CB adversary as a conceptual contribution: it allows parametrized analysis of online algorithms for online graph problems with respect to a natural parameter.

The rest of the paper is organized as follows. In Sect. 2 we go over some preliminaries. The new adversarial model is introduced in Sect. 3. The FirstFit algorithm is analyzed in Sect. 4, while CBIP is analyzed in Sect. 5. The analysis of various classes of graphs is in Sect. 6. We finish with some discussion and open problems in Sect. 7.

Preliminaries
In online coloring, an adversary creates a simple undirected graphFootnote2ğº=(ğ‘‰,ğ¸) and a presentation order of verticesFootnote3ğœ:[ğ‘›]â†’ğ‘‰. The graph is then presented online in the vertex-arrival model: at time i vertex ğ‘£=ğœ(ğ‘–) arrives, and we learn all its neighbors among already appeared vertices. An online algorithm must declare how to color the new vertex c(v) prior to the arrival of the next vertex ğœ(ğ‘–+1). A priori, an online algorithm does not know V or even n. Alternatively, we can view the online input as a sequence of induced subgraphs:

ğºâˆ©ğœ([1]),ğºâˆ©ğœ([2]),â€¦,ğºâˆ©ğœ([ğ‘›]).
We call the set of neighbors of v that an online algorithm learns about at the time of arrival of v the pre-neighborhood of v, denoted by ğ‘âˆ’(ğ‘£).

A natural greedy algorithm is called FirstFit (see, for example, [7, 9, 13]): when a vertex v arrives, FirstFit colors it with the first color that does not appear in the pre-neighborhood of v. The pseudocode is shown in Algorithm 1.

figure a
Another famous algorithm due to [11] for online coloring of bipartite graphs is called CBIP: when a vertex ğ‘£=ğœ(ğ‘–) arrives, CBIP computes an entire connected component CC to which v belongs in the partial graph known so far. Since we assume that the input graph is bipartite, the connected component CC can be partitioned into two sets of vertices A and B such that all edges go between A and B only. Suppose that ğ‘£âˆˆğ´, then v is colored with the first color that is not present among vertices in B. The pseudocode is shown in Algorithm 2.

figure b
In the adversarial arguments presented in this work we often need to control the chromatic number of constructed instances. These instances can get quite complicated and computing their chromatic number exactly might be rather difficult. The following technique is widely used in the online coloring community, see e.g., [8]. The adversary is not only going to construct an online instance, but it will also maintain a valid coloring of that instance. Thus, when specifying the adversary we need to define not only how the next input item is generated, but also how it is colored. The key idea is that since the adversary knows and controls how future input items will be generated, it can anticipate its own moves and create a much better coloring than what an online algorithm can achieve without this knowledge. Unless explicitly stated otherwise, by an â€œalgorithmâ€ we always mean a deterministic algorithm.

Bins vs. Colors
We adopt the terminology introduced in [8]: when there is a possibility of ambiguity we say that an online algorithm colors with bins and the adversary with colors in order to distinguish the two. Let v be a vertex. We use the notation b(v) to denote the bin that is assigned to v by an online algorithm, and c(v) to denote the color that is assigned to v by the adversary. Let A be a set of vertices. Define ğ‘(ğ´)={ğ‘(ğ‘£):ğ‘£âˆˆğ´} and ğ‘(ğ´)={ğ‘(ğ‘£):ğ‘£âˆˆğ´}. Sometimes, we say that bin b contains v to mean that ğ‘(ğ‘£)=ğ‘.

Saturated Bins
We define a notion that is inspired by several previous works [6, 8, 14].

Definition 1
Suppose that the adversary is constructing a ğœ’-colorable graph. A bin b is said to be p-saturated if there are p vertices ğ‘£1,â€¦,ğ‘£ğ‘ such that

ğ‘(ğ‘£1)=â‹¯=ğ‘(ğ‘£ğ‘)=ğ‘,|{ğ‘(ğ‘£1),ğ‘(ğ‘£2),â€¦,ğ‘(ğ‘£ğ‘)}|=ğ‘.
(1)
A bin b is said to be perfectly p-saturated if bin b is p-saturated and it contains exactly p vertices. When a bin b is ğœ’-saturated, we simply say bin b is saturated.

The following simple fact shows why this notion might be interesting.

Fact. If t bins are all saturated, then every color class contains t vertices in distinct bins. By connecting a new vertex to these t vertices, the algorithm is forced to use a new bin.

The notion of saturated bins is already implicit in some previous works. For example, the so-called â€œtwo-sided colorsâ€Footnote4 in [6] are saturated bins when ğœ’=2. The construction in [6] forces many two-sided colors, i.e., many saturated bins. The proof of a lower bound in [8], which we mentioned earlier as an example that does not use the common create-and-merge-components strategy directly, could be summarized as follows: the adversary has a strategy to force any algorithm to use perfectly p-saturated bins for 1â‰¤ğ‘â‰¤ğœ’/2. In [14], the lower bound construction does not necessarily force p-saturated bins, but seeks to create a situation where a weaker form of the above Fact is bound to appear.

In Sect. 4, we show that a ğœ…-CB adversary can successively force saturated bins on FirstFit for ğœ’-colorable graphs. This leads to the algorithm being noncompetitive. Explicit examples of saturated bins can be seen in Fig. 1 in Sect. 4. The construction of forcing saturated bins on FirstFit is generalized in Sect. 6 to work for all algorithms.

A New Type of Adversary
Let cc(G) denote the number of connected components of graph G.

Definition 2
An adversary is said to be ğœ…-components-bounded, or ğœ…-CB, if the input graph G and the presentation order ğœ satisfy

âˆ€ ğ‘–âˆˆ[ğ‘›]ğ‘ğ‘(ğºâˆ©ğœ([ğ‘–]))â‰¤ğœ….
(2)
Let îˆ­ denote a deterministic online coloring algorithm. Define ğ›½(îˆ­,ğœ…,ğº) to be the maximal number of bins îˆ­ has to use when a ğœ…-CB adversary constructs the graph G. Let îˆ³ denote a class of graphs. Define

ğ›½(îˆ­,ğœ…,îˆ³)=supğºâˆˆîˆ³ğ›½(îˆ­,ğœ…,ğº),
(3)
and

ğ›½(ğœ…,îˆ³)=infîˆ­ğ›½(îˆ­,ğœ…,îˆ³).
(4)
Let ğœ’âˆˆâ„•. By identifying ğœ’ with the class of graphs that are ğœ’-colorable, the notation ğ›½(îˆ­,ğœ…,ğœ’) and ğ›½(ğœ…,ğœ’) are defined via (3) and (4), respectively. Let TREE denote the class of graphs that are trees.

Different from traditional online coloring models, a feature of the ğœ…-CB adversary model is that the number of vertices of a graph is not necessarily a parameter in the model. In this work, the ğœ…-CB adversary is allowed to construct graphs with arbitrarily many vertices. We will be interested in understanding what the power and limitations are for an adversary who can use an unlimited number of vertices but is ğœ…-CB.

Proposition 1
Let ğ›º denote the set of all possible graphs and let îˆ­ be an arbitrary algorithm. Then,

ğ›½(îˆ­,1,ğ›º)=âˆ.
Proof
For every ğ‘›âˆˆâ„•, let ğ¾ğ‘› denote the complete graph on n vertices. Obviously, an adversary can present ğ¾ğ‘› in any presentation order while maintaining a single connected component. Thus, ğ›½(îˆ­,1,ğ¾ğ‘›)â‰¥ğ‘›. As n is arbitrary, the result follows. â—»

Hence, the ğœ…-CB adversary model becomes interesting when we consider special classes of graphs. For example, ğ›½(ğ¹ğ‘–ğ‘Ÿğ‘ ğ‘¡ğ¹ğ‘–ğ‘¡,ğœ…,2) denotes the maximal number of bins the ğœ…-CB adversary can force FirstFit (see Algorithm 1) to use by constructing a bipartite graph.

FirstFit on ğœ’-Colorable Graphs, Triangle-Free Graphs, and Trees
In this section, we completely characterize the performance of FirstFit on ğœ’-colorable graphs, triangle-free graphs, and trees for ğœ…-CB adversaries. We begin with the following theorem, which completely determines ğ›½(ğ¹ğ‘–ğ‘Ÿğ‘ ğ‘¡ğ¹ğ‘–ğ‘¡,ğœ…,ğœ’) for all ğœ…,ğœ’âˆˆâ„•.

Theorem 1
Let ğœ…âˆˆâ„•,ğœ’âˆˆâ„•.

(1)
ğ›½(ğ¹ğ‘–ğ‘Ÿğ‘ ğ‘¡ğ¹ğ‘–ğ‘¡,ğœ…,1)=1 for every ğœ…â‰¥1;

(2)
ğ›½(ğ¹ğ‘–ğ‘Ÿğ‘ ğ‘¡ğ¹ğ‘–ğ‘¡,1,2)=2;

(3)
ğ›½(ğ¹ğ‘–ğ‘Ÿğ‘ ğ‘¡ğ¹ğ‘–ğ‘¡,2,2)=âˆ

(4)
ğ›½(ğ¹ğ‘–ğ‘Ÿğ‘ ğ‘¡ğ¹ğ‘–ğ‘¡,ğœ…,ğœ’)=âˆ for every ğœ…â‰¥1 and ğœ’â‰¥3.

Proof
(1)
The graphs that are 1-colorable and can be presented by a ğœ…-CB adversary consist of up to ğœ… isolated vertices. Clearly, FirstFit uses a single bin on such graphs.

(2)
A simple induction shows that FirstFit maintains a valid 2-coloring when a bipartite graph is revealed by a 1-CB adversary. The base case of a single vertex is trivial. In the inductive step, the newly arriving vertex has edges going to the â€œoppositeâ€ side of the bipartition (due to the 1-CB restriction). By the inductive assumption, those neighbors have been assigned to a single bin consistent with a valid 2-coloring, FirstFit correctly identifies the other bin for the new vertex.

(3)
Let n be even and consider the graph ğº=(ğ‘‰,ğ¸) with the vertex set ğ‘‰={ğ‘£ğ‘–âˆ£ğ‘–âˆˆ[ğ‘›]} and the edge set defined by connecting each vertex ğ‘£2ğ‘˜âˆ’1 with ğ‘£2ğ‘˜â€² for ğ‘˜,ğ‘˜â€²âˆˆ[ğ‘›/2] and ğ‘˜â‰ ğ‘˜â€². Since all edges go in between odd-indexed and even-indexed vertices, the graph is clearly bipartite. The adversary presents vertices in order ğ‘£1,ğ‘£2,ğ‘£3,â€¦,ğ‘£ğ‘›. This presentation order satisfies the 2-CB constraint: ğ‘£1 is initially in one connected component, when ğ‘£2 arrives it is isolated and forms the second component, and every future vertex has an edge either to ğ‘£1 or ğ‘£2. An example of this graph for ğ‘›=8 is shown in Fig. 1a.

Let b(v) denote the bin that FirstFit assigns v to. We show by induction on ğ‘˜âˆˆ[ğ‘›/2] that ğ‘(ğ‘£2ğ‘˜âˆ’1)=ğ‘(ğ‘£2ğ‘˜)=ğ‘˜. The base case of ğ‘˜=1 is trivial since when ğ‘£1 and ğ‘£2 arrive they are isolated vertices, so they are placed in bin 1 by FirstFit. In the inductive step, ğ‘£2ğ‘˜âˆ’1 is connected to ğ‘£2ğ‘˜â€² for ğ‘˜â€²âˆˆ[ğ‘˜âˆ’1]. By induction, ğ‘(ğ‘£2ğ‘˜â€²)=ğ‘˜â€², therefore FirstFit assigns ğ‘£2ğ‘˜âˆ’1 to a new bin k. A similar argument holds for the next arriving vertex ğ‘£2ğ‘˜.

As n can be arbitrary large, the result follows.

(4)
Since ğ›½(ğ¹ğ‘–ğ‘Ÿğ‘ ğ‘¡ğ¹ğ‘–ğ‘¡,ğœ…,ğœ’) is non-decreasing with respect to both ğœ… and ğœ’, it suffices to show that ğ›½(ğ¹ğ‘–ğ‘Ÿğ‘ ğ‘¡ğ¹ğ‘–ğ‘¡,1,3)=âˆ. Let n be a multiple of 3 and consider the graph ğº=(ğ‘‰,ğ¸) with the vertex set ğ‘‰={ğ‘£ğ‘–âˆ£ğ‘–âˆˆ[ğ‘›]}. The adversary presents vertices in order ğ‘£1,â€¦,ğ‘£ğ‘›. The edge set is defined by the following construction. As usual, we let c(v) denote the color that the adversary maintains for vertex v, while b(v) denotes the bin used by FirstFit.

The construction consists of two phases: the initial phase and the inductive phase. During the initial phase, the adversary presents a path of 6 vertices: ğ‘£1,ğ‘£2,ğ‘£3,ğ‘£4,ğ‘£5,ğ‘£6. Clearly, when ğ‘£1 arrives it is an isolated vertex, but each subsequent vertex ğ‘£ğ‘– is revealed with a single edge to ğ‘£ğ‘–âˆ’1. This clearly satisfies the 1-CB constraint. The adversary assigns colors ğ‘(ğ‘£1)=ğ‘(ğ‘£4)=red, ğ‘(ğ‘£2)=ğ‘(ğ‘£5)=green, and ğ‘(ğ‘£3)=ğ‘(ğ‘£6)=blue. This is a valid 3-coloring (although 2 colors are sufficient, the adversary uses more colors in anticipation of the inductive phase). FirstFit assigns bins ğ‘(ğ‘£1)=ğ‘(ğ‘£3)=ğ‘(ğ‘£5)=1 and ğ‘(ğ‘£2)=ğ‘(ğ‘£4)=ğ‘(ğ‘£6)=2. The result of the initial phase is that FirstFit ends up with 2 bins that are 3-saturated.

The inductive phase proceeds in rounds. In round ğ‘˜âˆˆ[3,ğ‘›/3], the vertex ğ‘£3ğ‘˜âˆ’2 is revealed and its pre-neighborhood consists of vertices ğ‘£3ğ‘˜â€²âˆ’1 for ğ‘˜â€²âˆˆ[ğ‘˜âˆ’1]. Then the vertex ğ‘£3ğ‘˜âˆ’1 is revealed and its pre-neighborhood consists of vertices ğ‘£3ğ‘˜â€² for ğ‘˜â€²âˆˆ[ğ‘˜âˆ’1]. Lastly, the vertex ğ‘£3ğ‘˜ is revealed and its pre-neighborhood consists of vertices ğ‘£3ğ‘˜â€²âˆ’2 for ğ‘˜â€²âˆˆ[ğ‘˜âˆ’1]. The adversary assigns ğ‘(ğ‘£3ğ‘˜âˆ’2)=red,ğ‘(ğ‘£3ğ‘˜âˆ’1)=green, and ğ‘(ğ‘£3ğ‘˜)=blue. By a straightforward induction, FirstFit assigns ğ‘(ğ‘£3ğ‘˜âˆ’2)=ğ‘(ğ‘£3ğ‘˜âˆ’1)=ğ‘(ğ‘£3ğ‘˜)=ğ‘˜: prior to round k, FirstFit has ğ‘˜âˆ’1 bins that are 3-saturated; during round k, FirstFit creates a new bin and places all three new vertices into that bin making it 3-saturated. The initial phase described in the previous paragraph establishes The base case of the induction.

The coloring maintained by the adversary is easily seen to be valid, since the color classes consist of vertices whose indices have the same remainder mod3, while the edges are present only between two vertices whose indices have different remainders mod3. The 1-CB constraint is clearly maintained during the inductive phase.

An example of this construction for ğ‘›=12 is shown in Fig. 1b. â—»

Fig. 1
figure 1
Examples of adversarial inputs used in the proof of Theorem 1. Columns indicate the coloring maintained by the adversary, while rows indicate the bins used by FirstFit

Full size image
Observe that the construction in part (4) of Theorem 1 results in a triangle-free graph. Let ğšƒğšğ™¸ğ™°ğ™½ğ™¶ğ™»ğ™´-ğ™µğšğ™´ğ™´ denote the class of triangle-free graphs.

Corollary 1
ğ›½(ğ¹ğ‘–ğ‘Ÿğ‘ ğ‘¡ğ¹ğ‘–ğ‘¡,1,ğšƒğšğ™¸ğ™°ğ™½ğ™¶ğ™»ğ™´-ğ™µğšğ™´ğ™´)=âˆ.

Part (4) of Theorem 1 and Corollary 1 will be generalized in Sect. 6.

We conclude this section by giving a complete analysis of FirstFit on trees with respect to the ğœ…-CB adversary.

Theorem 2
ğ›½(ğ¹ğ‘–ğ‘Ÿğ‘ ğ‘¡ğ¹ğ‘–ğ‘¡,ğœ…,ğšƒğšğ™´ğ™´)=ğœ…+1.

Proof
The lower bound ğ›½(ğ¹ğ‘–ğ‘Ÿğ‘ ğ‘¡ğ¹ğ‘–ğ‘¡,ğœ…,ğšƒğšğ™´ğ™´)â‰¥ğœ…+1 is witnessed by the so-called forest construction due to Bean [3] (also independently discovered in [7]). We claim that a ğœ…-CB adversary can construct a forest consisting of ğœ… trees ğ‘‡1,ğ‘‡2,â€¦,ğ‘‡ğœ… with the property that for each i the FirstFit algorithm uses color i on some vertex ğ‘£ğ‘– belonging to the tree ğ‘‡ğ‘–. We first prove this claim and later see how it implies the lower bound.

The construction is recursive and so we prove the above statement by induction on ğœ…. The base case is trivial: when ğœ…=1 the adversary can give a single isolated vertex. Assume that the statement is true for ğœ… and we wish to establish it for ğœ…+1. The adversary begins by invoking induction and creating ğ‘‡1,ğ‘‡2,â€¦,ğ‘‡ğœ… such that for ğ‘–âˆˆ[ğœ…] there is ğ‘£ğ‘–âˆˆğ‘‡ğ‘– such that ğ‘(ğ‘£ğ‘–)=ğ‘– is assigned by FirstFit. Then, the adversary creates a new vertex u connected to all the ğ‘£ğ‘–. This process merges all existing trees into a single tree, which we call ğ‘‡â€²ğœ…+1. Moreover, this forces FirstFit to assign ğ‘(ğ‘¢)=ğœ…+1. This tree is set aside, and to satisfy the claim for ğœ…+1, the adversary invokes the induction again to create another set of trees ğ‘‡â€²1,â€¦,ğ‘‡â€²ğœ… with ğ‘£â€²ğ‘–âˆˆğ‘‡â€²ğ‘– such that ğ‘(ğ‘£â€²ğ‘–)=ğ‘–. Note that creating ğ‘‡â€²ğ‘– requires at most ğœ… components, so the adversary is (ğœ…+1)-CB (remember that we have an additional component ğ‘‡â€²ğœ…+1 set aside during the second invocation of induction). Moreover, note that ğ‘(ğ‘¢)=ğœ…+1, so the trees ğ‘‡â€²1,â€¦,ğ‘‡â€²ğœ…+1 satisfy the claim.

This claim implies the lower bound since the ğœ…-CB adversary can present ğ‘‡1,â€¦,ğ‘‡ğœ… with ğ‘(ğ‘£ğ‘–)=ğ‘– for some ğ‘£ğ‘–âˆˆğ‘‡ğ‘–. In the last step, the adversary presents u connected to each ğ‘£ğ‘–. This process does not increase the number of components and forces ğ‘(ğ‘¢)=ğœ…+1. An example of this construction is shown in Fig. 2.

Next, we show the upper bound ğ›½(ğ¹ğ‘–ğ‘Ÿğ‘ ğ‘¡ğ¹ğ‘–ğ‘¡,ğœ…,ğšƒğšğ™´ğ™´)â‰¤ğœ…+1. Suppose that FirstFit uses ğ‘š+1 bins for some m. Let v be the first vertex which is placed into bin ğ‘š+1 by FirstFit. By the definition of FirstFit, there are m vertices in the pre-neighborhood ğ‘âˆ’(ğ‘£) that have been previously assigned to bins 1,2,â€¦,ğ‘š. Since the adversary is constructing a tree, there can be no cycle. Hence, these m vertices must be in distinct components, i.e., there are at least m distinct components. â—»

Fig. 2
figure 2
An example of the forest construction used in the proof of Theorem 2. The adversary presents the vertices in order: ğ‘£1,ğ‘£2,ğ‘£3,â€¦,ğ‘£8. The FirstFit uses 4 bins while the adversary uses 3 connected components during this construction

Full size image
CBIP on Bipartite Graphs
We will establish the tight bound of 2ğœ… on the number of bins used by CBIP with respect to a ğœ…-CB adversary on bipartite graphs and trees. This provides a finer understanding of the performance of CBIP and is particularly interesting in light of previous lower bounds. Gutowski et al. [6] proved that any online algorithm has to use at least 2logğ‘›âˆ’10 bins for coloring bipartite graphs with n vertices, which matches the upper bound on CBIP from [11] up to the additive constant âˆ’10. The construction in [6] applied to CBIP (or even FirstFit) uses logğ‘› disjoint connected components to force 2logğ‘› bins. The main result of this section which we state next, in particular demonstrates that this is a necessary feature of their construction.

Theorem 3
ğ›½(ğ¶ğµğ¼ğ‘ƒ,ğœ…,ğšƒğšğ™´ğ™´)=ğ›½(ğ¶ğµğ¼ğ‘ƒ,ğœ…,2)=2ğœ….

Proof
Since ğ›½(ğ¶ğµğ¼ğ‘ƒ,ğœ…,2)â‰¥ğ›½(ğ¶ğµğ¼ğ‘ƒ,ğœ…,ğšƒğšğ™´ğ™´), the lower bound follows from Lemma 1 and the upper bound follows from Lemma 2. â—»

Observe that Theorem 3 implies that, in the class of bipartite graphs, worst-case input already appears in TREE for CBIP.

We begin by establishing the lower bound used in the above theorem.

Lemma 1
ğ›½(ğ¶ğµğ¼ğ‘ƒ,ğœ…,ğšƒğšğ™´ğ™´)â‰¥2ğœ….

Proof
In this proof, the notation r(T) is used to denote the root of a rooted tree T. The statement of the theorem is witnessed by the following recursive adversarial construction:

The base cases: ğ‘‡1 is a rooted tree consisting of a single vertex. ğ‘‡2 is a rooted tree consisting of one edge, where ğ‘Ÿ(ğ‘‡2) is defined as the vertex that is assigned to bin 2 by CBIP.

Recursive step: let ğ‘–â‰¥3. To construct ğ‘‡ğ‘– the adversary does the following:

(1)
it constructs ğ‘‡ğ‘–âˆ’1;

(2)
it constructs ğ‘‡ğ‘–âˆ’2;

(3)
it presents a new vertex v connected via an edge to ğ‘Ÿ(ğ‘‡ğ‘–âˆ’1) and via another edge to ğ‘Ÿ(ğ‘‡ğ‘–âˆ’2).

The vertex from step (3) becomes the root ğ‘Ÿ(ğ‘‡ğ‘–) of the newly formed tree ğ‘‡ğ‘–.

As usual, let b(v) denote the bin to which v is assigned by CBIP. For each i, let ğ¸ğ‘– denote the set of vertices that are at even distance from ğ‘Ÿ(ğ‘‡ğ‘–) in ğ‘‡ğ‘–. Similarly, let ğ‘‚ğ‘– denote the set of vertices at odd distance from ğ‘Ÿ(ğ‘‡ğ‘–) in ğ‘‡ğ‘–. We claim that for the above construction it holds that

(i)
ğ‘(ğ¸ğ‘–)=[ğ‘–]âˆ–{ğ‘–âˆ’1};

(ii)
ğ‘(ğ‘‚ğ‘–)=[ğ‘–âˆ’1];

(iii)
the construction of ğ‘‡ğ‘– satisfies the âŒŠğ‘–/2âŒ‹-CB constraint.

We prove the above claim by strong induction on i. The statements are immediate for The base cases of ğ‘‡1 and ğ‘‡2. Assume that the statement holds for all ğ‘—â‰¤ğ‘–âˆ’1 for some ğ‘–â‰¥3. Next, consider ğ‘‡ğ‘–. Examining the construction we obtain:

ğ¸ğ‘–=ğ‘‚ğ‘–âˆ’2âˆªğ‘‚ğ‘–âˆ’1âˆª{ğ‘£},

ğ‘‚ğ‘–=ğ¸ğ‘–âˆ’2âˆªğ¸ğ‘–âˆ’1.

Using the inductive assumption, we have ğ‘(ğ¸ğ‘–âˆ’2)=[ğ‘–âˆ’2]âˆ–{ğ‘–âˆ’3} and ğ‘(ğ¸ğ‘–âˆ’1)=[ğ‘–âˆ’1]âˆ–{ğ‘–âˆ’2}. Therefore, we have ğ‘(ğ‘‚ğ‘–)=ğ‘(ğ¸ğ‘–âˆ’2âˆªğ¸ğ‘–âˆ’1)=[ğ‘–âˆ’1] establishing part (ii) of the claim.

Using the inductive assumption again, we have ğ‘(ğ‘‚ğ‘–âˆ’2)=[ğ‘–âˆ’3] and ğ‘(ğ‘‚ğ‘–âˆ’1)=[ğ‘–âˆ’2]. Therefore, ğ‘(ğ¸ğ‘–âˆ–{ğ‘£})=ğ‘(ğ‘‚ğ‘–âˆ’2âˆªğ‘‚ğ‘–âˆ’1)=[ğ‘–âˆ’2].

CBIP uses the bipartition induced by ğ¸ğ‘– and ğ‘‚ğ‘– to decide how to color v. Specifically, CBIP uses the first available bin other than those in ğ‘‚ğ‘–. Therefore, since ğ‘(ğ‘‚ğ‘–)=[ğ‘–âˆ’1] we have ğ‘(ğ‘£)=ğ‘–. Combining it with the result from the previous paragraph, we get ğµ(ğ¸ğ‘–)=[ğ‘–]âˆ–{ğ‘–âˆ’1} establishing part (i) of the claim.

As for the number of connected components used in the presentation of ğ‘‡ğ‘–, observe that step (1) uses âŒŠ(ğ‘–âˆ’1)/2âŒ‹ components by induction. After step (1), ğ‘‡ğ‘–âˆ’1 is put aside as a separate component. Therefore, step (2) uses 1+âŒŠ(ğ‘–âˆ’2)/2âŒ‹ connected components (we invoked the inductive assumption one more time here). Step (3) of the construction does not require any additional components. Therefore, the total number of components is bounded by max(âŒŠ(ğ‘–âˆ’1)/2âŒ‹,1+âŒŠ(ğ‘–âˆ’2)/2âŒ‹). It is easy to see that this expression is exactly âŒŠğ‘–/2âŒ‹ by considering the cases of odd and even i separately. This establishes part (iii) of the claim.

Lastly, note that the claim implies that CBIP uses 2ğœ… bins on ğ‘‡2ğœ… and that the presentation of ğ‘‡2ğœ… satisfies the ğœ…-CB constraint. â—»

We finish this section with a matching upper bound for the class of bipartite graphs.

Lemma 2
ğ›½(ğ¶ğµğ¼ğ‘ƒ,ğœ…,2)â‰¤2ğœ….

Proof
Consider a certain point in execution of CBIP on the input graph. As usual, let b(v) denote the bin to which v is assigned by CBIP. We say that a connected component CC is of Type 1[â„“] if CC can be partitioned into two subsets of vertices A and B (the subsets A and B will also be called blocks) such that

all edges go between A and B

ğ‘(ğ´)=[â„“âˆ’2]

ğ‘(ğµ)=[â„“âˆ’1]

Similarly, we say that a connected component CC is of Type 2[â„“] if CC can be partitioned into two subsets of vertices A and B such that

all edges go between A and B

ğ‘(ğ´)=[â„“âˆ’2]âˆª{â„“}

ğ‘(ğµ)=[â„“âˆ’1]

Figure 3 shows an example construction with two connected components of Type 2[4] and Type 1[5].

Fig. 3
figure 3
A snapshot of an execution of CBIP on an input instance, with vertices presented in left-to-right order. At this step in the presentation, the graph contains two connected components ğ¶ğ¶1 and ğ¶ğ¶2 of Type 2[4] and Type 1[5] respectively. Labels indicate bins used by CBIP

Full size image
The high-level idea is that the ğœ…-CB adversary can only force components that are either of Type 1[â„“] or of Type 2[â„“] for some â„“â‰¤2ğœ…. Before we prove it formally, we observe that when a new vertex v arrives, it can either (1) be an isolated vertex (taken to be of Type 1[2]), (2) be added to an existing component, or (3) be used to merge two or more existing components. Formally, we say that components ğ¶ğ¶1,ğ¶ğ¶2,â€¦,ğ¶ğ¶ğ‘— get merged at time t if vertex ğ‘£=ğœ(ğ‘¡) satisfies ğ‘âˆ’(ğ‘£)âˆ©ğ¶ğ¶ğ‘–â‰ âˆ… for ğ‘–âˆˆ[ğ‘—], and ğ¶ğ¶ğ‘– were distinct connected components at time ğ‘¡âˆ’1.

We record what happens to types of components after each of the above operations (1), (2) and (3). During operation (1), a new vertex of Type 1[â„“] for â„“=2 is added. Clearly, â„“â‰¤2ğœ… for any ğœ…â‰¥1. Next, we consider operation (2), i.e., when a new vertex v gets added to a component CC. We assume that the two blocks of CC are A and B and that they satisfy the conditions of Type 1 or 2. The resulting component is called ğ¶ğ¶â€². The changes to types after vertex v is presented are recorded in Table 1.

Table 1 Type changes for case (1), i.e., when v is added to an existing component
Full size table
Finally, we consider what happens when a vertex v is used to merge two or more components. We distinguish four types of components, the numbers of which are denoted by ğ‘˜1,ğ‘˜2,ğ‘˜3, and ğ‘˜4, respectively:

1.
ğ¶ğ¶ğ´ğ‘– of Type 1[â„“ğ´ğ‘–] for ğ‘–âˆˆ[ğ‘˜1]. Vertex v has a neighbor on the A-side of such components.

2.
ğ¶ğ¶ğµğ‘– of Type 1[â„“ğµğ‘–] for ğ‘–âˆˆ[ğ‘˜2]. Vertex v has a neighbor on the B-side of such components.

3.
ğ¶ğ¶â€²ğ´ğ‘– of Type 2[â„“â€²ğ´ğ‘–] for ğ‘–âˆˆ[ğ‘˜3]. Vertex v has a neighbor on the A-side of such components.

4.
ğ¶ğ¶â€²ğµğ‘– of Type 2[â„“â€²ğµğ‘–] for ğ‘–âˆˆ[ğ‘˜4]. Vertex v has a neighbor on the B-side of such components.

Let ğ‘š=max{â„“ğ´ğ‘–1,â„“ğµğ‘–2,â„“â€²ğ´ğ‘–3,â„“â€²ğµğ‘–4:ğ‘–1âˆˆ[ğ‘˜1],ğ‘–2âˆˆ[ğ‘˜2],ğ‘–3âˆˆ[ğ‘˜3],ğ‘–4âˆˆ[ğ‘˜4]}. We call m the type parameter of the partially constructed input graph.

We say that a block A or B of a particular component being merged is on the opposite side of v if v has a neighbor among the vertices of the block. Otherwise, we say that the block is on the same side as v. For example, block A of ğ¶ğ¶ğ´ğ‘– component is on the opposite side of v, whereas block B of the same component is on the same side as v. Let ğ‘†âˆ’ğ‘£ denote the set of bins already used for the vertices of blocks on the opposite side of v, and let ğ‘†ğ‘£ denote the set of bins already used for the vertices of blocks on the same side as v. By the definitions of Type 1 and 2 components as well as m, it is easy to see that each of ğ‘†ğ‘£,ğ‘†âˆ’ğ‘£ can be only one of the following four options: [ğ‘šâˆ’2],[ğ‘šâˆ’1],[ğ‘šâˆ’2]âˆª{ğ‘š},[ğ‘š]. This reduces the problem of computing the type of the merged component to analyzing 16 cases. For example, if ğ‘†âˆ’ğ‘£=[ğ‘šâˆ’2] and ğ‘†ğ‘£=[ğ‘šâˆ’2] then vertex v will be assigned bin ğ‘šâˆ’1 and the merged component will be of Type 1[m] since it will have one side with bins [ğ‘šâˆ’2] and the opposite side with bins [ğ‘šâˆ’1]. We denote the merged component by ğ¶ğ¶â€² and Table 2 summarizes all of the 16 cases.

Table 2 Type changes for case (2), i.e., when v is used to merge some existing components
Full size table
The reason that certain combinations in Table 2 are impossible is that if one side is colored with bins [m] then the opposite side must use bin ğ‘šâˆ’1 (because of how CBIP works).

Observe that from Table 2, the type parameter of ğ¶ğ¶â€² can either stay the same, increase by additive 1, or increase by additive 2. Furthermore, it can be directly verified from the table that an increase is possible only if there are at least two components having type parameters not less than ğ‘šâˆ’1. We refer to this property as the continuity of the type parameter.

Assume that the input graph G and the presentation order ğœ satisfy the ğœ…-CB condition, then the above observations imply the following statements:

(i)
âˆ€ ğ‘– we have ğºâˆ©ğœ([ğ‘–]) consists of Type 1/2[â„“] components for â„“â‰¤2ğœ…;

(ii)
âˆ€ ğ‘– there can be at most one component that is of one of the following four types: Type 1[2ğœ…âˆ’1], Type 1[2ğœ…], Type 2[2ğœ…âˆ’1], Type 2[2ğœ…].

Note that (i) immediately implies the statement of this lemma.

These statements can be proved by induction on ğœ…. The base case ğœ…=1 is easy to verify. Indeed, if ğ‘–=1, i.e., there is just a single vertex, then it is of Type 1[2]. Consider ğ‘–â‰¥2. Observe that for ğœ…=1 the algorithms CBIP and FirstFit have identical behavior. Therefore, (2) in Theorem 1 shows (i) is true, and the single component is of Type 2[2]. Hence, (ii) is true.

We proceed to the induction step. Assume (i) and (ii) are true for ğœ…, we consider the case ğœ…+1. First, we show (ii). Let ğ¶ğ¶1 be the first component that is of one of the following types: Type 1[2ğœ…+1], Type 1[2ğœ…+2], Type 2[2ğœ…+1], Type 2[2ğœ…+2]. Since the adversary is (ğœ…+1)-CB, the existence of ğ¶ğ¶1 implies that the adversary becomes ğœ…-CB when creating any new component that is disjoint from ğ¶ğ¶1. By the induction assumption, the adversary can only create components that are of Type 1/2[â„“] for â„“â‰¤2ğœ…. This proves (ii). Next we show (i). By the continuity of the type parameter, in order for the type parameter to go beyond 2ğœ…+2 there need to be at least two components both having type parameters not less than 2ğœ…+1. By (ii), this is impossible, so (i) is true. â—»

Lower Bounds for Several Graph Classes
In this section we establish non-existence of competitive algorithms against ğœ…-CB adversaries for various classes of graphs. We begin by establishing a strong non-competitiveness result for ğœ’-colorable graphs for ğœ’â‰¥3. This generalizes part (4) of Theorem 1 to arbitrary algorithms.

Theorem 4
ğ›½(1,ğœ’)=âˆ for every ğœ’â‰¥3.

Proof
Since ğ›½(1,ğœ’) is non-decreasing in ğœ’, it suffices to prove that ğ›½(1,3)=âˆ. Fix an arbitrary coloring algorithm îˆ­. We show that for every ğ‘¡âˆˆâ„•, a 1-CB adversary can construct a 3-colorable graph G so that îˆ­ uses at least t different bins to color vertices in G. It may be helpful to consult Fig. 4 while reading this proof.

The construction of G proceeds in layers, which we denote by ğ¿1,ğ¿2,â€¦,ğ¿ğ‘¡âˆ’1. Vertices (and their pre-neighborhoods) in ğ¿1 are presented first, followed by ğ¿2, and so on. The construction stops as soon as îˆ­ uses t distinct bins, which may happen before ğ¿ğ‘¡âˆ’1 and will be guaranteed to happen in ğ¿ğ‘¡âˆ’1.

Each layer consists of â€œsufficiently manyâ€ vertices, meaning that there should be enough vertices in lower layers to guarantee that the construction of higher layers goes through. Initially, we donâ€™t quantify â€œsufficiently many,â€ although we shall give some estimates on sizes of layers at the end of this proof.

Layer ğ¿1 is simply a path P of sufficiently large length â„“1. The adversary presents the vertices in P in the order in which they appear on the path. There are two possibilities: (i) îˆ­ already uses at least t bins to color P; (ii) îˆ­ uses fewer than t bins to color P. In case (i) the construction is over and the adversary has achieved its goal.

Next, we handle case (ii). Observe that îˆ­ has to use at least two different bins to color P correctly. Consider two bins ğ‘1 and ğ‘2 with the most number of vertices assigned to them by îˆ­. Let the sets of vertices assigned to those bins be ğµ1 and ğµ2, respectively, with |ğµ1|â‰¥|ğµ2|. The definition of case (ii) implies that |ğµ1|â‰¥â„“1/ğ‘¡. Since P is a path, no bin can contain more than â„“1/2+1 vertices. Thus, the number of vertices not in ğµ1 is at least â„“1/2âˆ’1. Since they are partitioned among at most ğ‘¡âˆ’1 bins, including ğµ2, and ğµ2 is most populous then |ğµ2|â‰¥(â„“1/2âˆ’1)/(ğ‘¡âˆ’1)=(â„“1âˆ’2)/(2ğ‘¡âˆ’2). Next, we select subsets ğµâ€²1âŠ†ğµ1 and ğµâ€²2âŠ†ğµ2 so that all the vertices in ğµâ€²1âˆªğµâ€²2 are non-adjacent in P and |ğµâ€²1|=|ğµâ€²2|=â„“1/(10ğ‘¡). This can be done as follows: alternatively pick a vertex from ğµ1 or ğµ2 to include in ğµâ€²1 or ğµâ€²2, respectively, and remove its neighbors from ğµ2 or ğµ1, respectively. Each pair of such steps includes one vertex into ğµâ€²1 and one vertex into ğµâ€²2 removing at most 3 vertices from each ğµ1 and ğµ2 from future considerations. Thus, this can go on for at least |ğµ2|/3â‰¥â„“1/(10ğ‘¡) rounds. In conclusion, we end up with sets of vertices ğµâ€²1 and ğµâ€²2 such that

all vertices in ğµâ€²ğ‘– are placed in bin ğ‘ğ‘– by îˆ­, where ğ‘–âˆˆ{1,2};

|ğµâ€²1|=|ğµâ€²2|=â„“1/(10ğ‘¡).

In particular, the second item implies that |ğµâ€²1| and |ğµâ€²2| can be assumed to be sufficiently large.

Construction of each following layer ğ¿ğ‘– for ğ‘–â‰¥2 either terminates early because îˆ­ used at least t different bins or forces îˆ­ to assign sufficiently many vertices to bin ğ‘ğ‘–+1. We shall denote the set of such verticesFootnote5ğµâ€²ğ‘–+1 for layer ğ¿ğ‘–. Assuming that the construction hasnâ€™t terminated in layer ğ¿ğ‘–âˆ’1, the next layer ğ¿ğ‘– is constructed by the adversary by repeating the following steps sufficiently many times:

(1)
the adversary chooses vertices ğ‘¢ğ‘—âˆˆğµâ€²ğ‘— for all ğ‘—â‰¤ğ‘– arbitrarily;

(2)
the adversary presents a new vertex v with pre-neighborhood {ğ‘¢1,â€¦,ğ‘¢ğ‘–};

(3)
the adversary updates ğµâ€²ğ‘—â†ğµâ€²ğ‘—âˆ–{ğ‘¢ğ‘—} for all ğ‘—â‰¤ğ‘–.

Due to step (3) we say that v consumes vertices ğ‘¢ğ‘— from ğµâ€²ğ‘— for ğ‘—âˆˆ[ğ‘–]. Observe that step (2) guarantees that îˆ­ has to assign v to a bin other than ğ‘1,â€¦,ğ‘ğ‘–. Just as for layer ğ¿1, if îˆ­ uses t different bins in this layer then we are done. Otherwise, let ğ‘ğ‘–+1 be the bin that has the most number of vertices assigned to it in layer ğ¿ğ‘–. If the adversary presents â„“ğ‘– vertices in layer ğ¿ğ‘– then the number of vertices assigned to ğ‘ğ‘–+1 is at least â„“ğ‘–/ğ‘¡. We let ğµâ€²ğ‘–+1 be an arbitrary subset of such vertices of size exactly â„“ğ‘–/ğ‘¡.

This construction continues until layer ğ¿ğ‘¡âˆ’1 where the adversary can present a single vertex according to the above scheme forcing îˆ­ to assign it to a new bin ğ‘ğ‘¡. Overall, îˆ­ then uses t different bins, namely, ğ‘1,â€¦,ğ‘ğ‘¡.

To guarantee that step (1) in the above construction always works, we need to make sure that all sets ğµâ€²ğ‘— are sufficiently large for this construction to reach layer ğ¿ğ‘¡âˆ’1. This is possible provided that for ğ‘–â‰¥2 we have |ğµâ€²ğ‘–+1|â‰¥âˆ‘ğ‘¡âˆ’1ğ‘—=ğ‘–+1â„“ğ‘— since each vertex in a layer above i consumes one vertex from ğµâ€²ğ‘– (step (3) of the above construction). We also need a similar condition for layer 1, namely, that |ğµâ€²2|=|ğµâ€²1|â‰¥âˆ‘ğ‘¡âˆ’1ğ‘—=2â„“ğ‘—. Thus, we end up with the following system of inequalities:

â„“ğ‘¡âˆ’1=1;

â„“ğ‘–/ğ‘¡â‰¥âˆ‘ğ‘¡âˆ’1ğ‘—=ğ‘–+1â„“ğ‘— for ğ‘–âˆˆ{2,3,â€¦,ğ‘¡âˆ’2};

â„“1/(10ğ‘¡)â‰¥âˆ‘ğ‘¡âˆ’1ğ‘—=2â„“ğ‘—.

It is straightforward to check that â„“ğ‘¡âˆ’1=1, â„“ğ‘–=ğ‘¡(ğ‘¡+1)ğ‘¡âˆ’ğ‘–âˆ’2 for ğ‘–âˆˆ[2,ğ‘¡âˆ’2] and â„“1=10ğ‘¡(ğ‘¡+1)ğ‘¡âˆ’3 is a valid solution to the above system. Thus, a feasible construction can be carried out by the adversary. The total number of vertices in this construction is at most 20ğ‘¡(ğ‘¡+1)ğ‘¡âˆ’3.

Observe that the construction clearly satisfies the 1-CB constraint, since layer ğ¿1 is presented as a single connected component and every vertex in a higher layer is adjacent to a vertex in layer ğ¿1.

We also note that the construction creates an almost-forest. More specifically, call the vertex v in step (2) of the above construction the parent of the corresponding ğ‘¢ğ‘— for ğ‘—âˆˆ[ğ‘–] chosen in step (1). Observe that due to step (3), each vertex has at most one parent. Therefore, the only thing preventing this construction from being a forest is layer ğ¿1, which can be thought of as a path going through all the leaves of the forest. This implies that the constructed graph is 3-colorable. Consider the subgraph obtained by removing all edges in layer ğ¿1 along with all vertices that do not have parents. Since it is a forest, it is 2-colorable. Moreover, any valid 2-coloring of this subgraph is also a partial valid 2-coloring of the entire graph since we chose ğµâ€²1 and ğµâ€²2 to be non-adjacent. We can then extend this partial coloring to a complete 3-coloring of the entire graph by using a greedy strategy. Note that uncolored vertices in ğ¿1 have degree at most 2, so a greedy coloring would use at most 3 colors. â—»

Fig. 4
figure 4
Example of the construction used in Theorem 4. This is a hypothetical example for some îˆ­ that assigns bins to vertices according to the figure

Full size image
The above construction can be modified so that either îˆ­ uses t bins or the adversary can successively force saturated bins. For example, the adversary can extend the level ğ¿1 and repeat the construction on the extended part. The adversary can do this sufficiently many times and recolor each copy so that saturated bins are forced.

The rough estimates on sufficient lengths of layers presented in the above proof immediately lead to the following quantitative version of the result.

Corollary 2
The 1-CB adversary can construct a 3-colorable graph on n vertices so that any online coloring algorithm uses at least ğ›º(logğ‘›/loglogğ‘›) bins.

Next, we note that the construction from Theorem 4 is quite robust. It can be modified in various ways to obtain similar non-competitiveness results for other classes of graphs. We first define the relevant classes.

ğ¶ğ‘˜-ğ™µğšğ™´ğ™´::
the class of graphs that do not contain a cycle of length k as a (not necessarily induced) subgraph.

ğ‘‘-ğ™¸ğ™½ğ™³ğš„ğ™²ğšƒğ™¸ğš…ğ™´::
the class of d-inductive graphs, i.e., those graphs whose vertices can be numbered so that each vertex has at most d adjacent vertices among higher numbered vertices.

ğ™¿ğ™»ğ™°ğ™½ğ™°ğš::
the class of planar graphs.

ğšƒğšğ™´ğ™´ğš†ğ™¸ğ™³ğšƒğ™·-ğ‘˜::
the class of graphs of treewidth at most k.

We are now ready to state and prove the following corollary of the construction from Theorem 4.

Corollary 3
(1)
ğ›½(1,ğ¶ğ‘˜-ğ™µğšğ™´ğ™´)=âˆ for every ğ‘˜â‰¥3.

(2)
ğ›½(1,ğ‘‘-ğ™¸ğ™½ğ™³ğš„ğ™²ğšƒğ™¸ğš…ğ™´)=âˆ for every ğ‘‘â‰¥2.

(3)
ğ›½(1,ğ™¿ğ™»ğ™°ğ™½ğ™°ğš)=âˆ.

(4)
ğ›½(1,ğšƒğšğ™´ğ™´ğš†ğ™¸ğ™³ğšƒğ™·-ğ‘˜)=âˆ for every ğ‘˜â‰¥5.

Proof
(1)
Since the construction in Theorem 4 is an almost-forest, the only cycles present are those using edges in layer ğ¿1. By making ğ¿1 longer we could insist that vertices in ğµâ€²1 and ğµâ€²2 are at least distance k apart: modify the procedure for selecting vertices into ğµâ€²1 or ğµâ€²2 by picking a vertex from ğµ1 or ğµ2 respectively and removing all vertices at distance k from it from ğµ1 and ğµ2. This modification insures that all cycles are of length greater than k.

(2)
Observe that the construction is 2-inductive: number vertices in the order in which they appear. Each vertex in layer ğ¿ğ‘– for ğ‘–â‰¥2 has at most one neighbor among higher numbered vertices, namely, the vertex which we called the parent. A vertex in ğ¿1 potentially has 2 adjacent higher numbered vertices: at most one parent in layer ğ¿ğ‘– for ğ‘–â‰¥2 and at most one neighbor in layer ğ¿1 which follows it in the path.

(3)
Since the construction in Theorem 4 is an almost-forest and the forest part is planar, we just need to make sure that the path in ğ¿1 does not break planarity. We could draw a plane embedding of the forest part and order leaves clockwise. If the vertices in ğ¿1 appear in the order consistent with this clockwise ordering of leaves then planarity can be maintained while adding vertices and edges from ğ¿1 back into the picture. Unfortunately, the clockwise ordering of leaves in plane embedding might be inconsistent with the ordering of these leaves along the path in ğ¿1. Fortunately, it is possible to adjust the construction to guarantee that the two orders are consistent. A completely formal proof of this is rather tedious, so we give a high-level description instead.

First, note that there is a single tree T such that for every algorithm îˆ­ the forest-part of the construction produced for îˆ­ is a subgraph of T, where the leaves are labelled as either ğµâ€²1 or ğµâ€²2 vertices. Second, we could consider the plane embedding of T and the clockwise ordering of leaves induces a sequential pattern of inter-mixed labels ğµâ€²1 and ğµâ€²2. Third, observe that by letting the path P in ğ¿1 be sufficiently long and taking a subset of ğµ1 and ğµ2 appropriately, any sequential pattern of inter-mixed labels ğµâ€²1 and ğµâ€²2 can be generated along the path P in ğ¿1. Therefore, the adversary can always generate ğµâ€²1 and ğµâ€²2 respecting the same sequential pattern as induced by the clockwise ordering of leaves in the plane embedding of T. This is how the adversary generates ğ¿1 in the modified construction. The adversary proceeds generating the subgraph of T as before, but it uses T as a guide: vertex v from step (2) of the construction can be mapped to a vertex in T and the children of v in T dictate which vertices {ğ‘¢ğ‘—} are chosen in step (1) of the construction. An illustration is given in Fig. 5. This completes the argument.

(4)
Observe that the modified construction from the previous item is 2-outerplanar since after removing the vertices in ğ¿1 we are left with a graph where every vertex is adjacent to the unbounded face. Therefore by the result of Bodlaender [5] the construction has treewidth at most 5.

â—»

Fig. 5
figure 5
Example of the construction used in parts 3 and 4 of Corollary 3. The vertices appearing on the circle are precisely the ğµâ€²1 and ğµâ€²2 subsets of ğ¿1 vertices. Other ğ¿1 vertices are not shown, but they can be visualized as being interspersed between them. Observe that the graph is planar and 2-outerplanar

Full size image
Conclusion and Open Problems
We have introduced a new type of adversary for online graph problems and studied online coloring with respect to this adversary. This led to an improved understanding of the properties of the two widely studied online coloring algorithms FirstFit and CBIP. Furthermore, when the adversary is ğœ…-CB for ğœ…=ğ‘‚(1), Theorems 3 and 4 show a sharp contrast between bipartite graphs, for which the CBIP uses only O(1) bins, and 3-colorable graphs for which any algorithm has to use infinitely many bins. While our work suggests many directions for future research, we find the following questions particularly intriguing:

1.
What is ğ›½(1,ğšƒğšğ™´ğ™´ğš†ğ™¸ğ™³ğšƒğ™·-ğ‘˜) for ğ‘˜âˆˆ{2,3,4}?

2.
We allow the adversary to use an unlimited number of vertices. A natural extension of our work is to study the dependency on n while the adversary is ğœ…-CB. Corollary 2 is a step in that direction. Can the lower bound in Corollary 2 be improved to ğ›º(log2ğ‘›), matching the best known lower bound in [14] for 3-colorable graphs when the adversary is unconstrained? On the other hand, we discusssed in the introduction that in practice it seems the case that ğœ… is often O(1), hence it would be very interesting to see whether it is possible to improve the existing upper bounds (such as those in [14] and [10]) under the O(1)-CB adversary assumption.

3.
For a graph G and presentation order ğœ define ğœ…(ğº,ğœ)=maxğ‘–ğ‘ğ‘(ğºâˆ©ğœ([ğ‘–])). What is the behaviour of ğœ…(ğº,ğœ) in real-world instances? As we mention in the introduction, it is expected that ğœ…(ğº,ğœ) is â€œsmallâ€ for social networks. How â€œsmallâ€ is it actually? What are typical values of ğœ…(ğº,ğœ)? For a class of real-world instances for a particular application (such as transportation networks, social networks, or electrical networks), do ğœ…(ğº,ğœ) values follow some well-defined distribution?

4.
One can study the power and limitations of the ğœ…-CB adversary in other related models, e.g., online algorithms with advice, streaming algorithms, temporal or dynamic graphs algorithms. Interactions between various features of those models and the ğœ…-CB constraint might lead to new algorithms or finer understanding of existing algorithms.

5.
Last but definitely not least, it would be rather interesting to study other online graph problems under the ğœ…-CB adversary.