Interval graphs, intersection graphs of segments on a real line (intervals), play a key role in the study of algorithms and special structural properties. Unit interval graphs, their proper subclass, where each interval has a unit length, has also been extensively studied. We study mixed unit interval graphsâ€”a generalization of unit interval graphs where each interval has still a unit length, but intervals of more than one type (open, closed, semi-closed) are allowed. This small modification captures a richer class of graphs. In particular, mixed unit interval graphs may contain a claw as an induced subgraph, as opposed to unit interval graphs. Heggernes, Meister, and Papadopoulos defined a representation of unit interval graphs called the bubble model which turned out to be useful in algorithm design. We extend this model to the class of mixed unit interval graphs and demonstrate the advantages of this generalized model by providing a subexponential-time algorithm for solving the MaxCut problem on mixed unit interval graphs. In addition, we derive a polynomial-time algorithm for certain subclasses of mixed unit interval graphs. We point out a substantial mistake in the proof of the polynomiality of the MaxCut problem on unit interval graphs by BoyacÄ± et al. (Inf Process Lett 121:29â€“33, 2017. https://doi-org.ezproxy.auckland.ac.nz/10.1016/j.ipl.2017.01.007). Hence, the time complexity of this problem on unit interval graphs remains open. We further provide a better algorithmic upper-bound on the clique-width of mixed unit interval graphs.

Introduction
A graph G is an intersection graph if there exists a family of non-empty sets îˆ²={ğ‘†1,â€¦,ğ‘†ğ‘›} such that for each vertex ğ‘£ğ‘– of G, a set ğ‘†ğ‘–âˆˆîˆ² is assigned in a way that there is the edge ğ‘£ğ‘–ğ‘£ğ‘— in G if and only if ğ‘†ğ‘–âˆ©ğ‘†ğ‘—â‰ âˆ…. We say that G has an îˆ²-intersection representation. Every graph can be represented as an intersection graph since per each vertex, we can use the set of its incident edges. However, many important graph classes can be described as intersection graphs of a restricted family of sets. Depending on the geometrical representation, different types of intersection graphs are defined, for instance, interval, circular-arc, disk graphs, etc. Interval graphs are intersection graphs of segments of the real line, called intervals. Such a representation is being referred to as interval representation. They have been a well known and widely studied class of graphs from both the theoretical and the algorithmic points of view since 1957. They were first mentioned independently in combinatorics (Hajos [10, 22]) and genetics (Benzer [3]).

Interval graphs have a nice structure, they are chordal and, therefore, also perfect which provides a variety of graph decompositions and models. Such properties are often useful tools for the algorithm designâ€”the most common algorithms on them are based on dynamic programming. Therefore, many classical ğ–­ğ–¯-hard problems are polynomial-time solvable on interval graphs, for instance Hamiltonian cycle (Keil [31]), Graph isomorphism (Booth [6]) or Colorability (Golumbic [19]) are solvable even in linear time. Surprisingly, the complexity of some well-studied problems is still unknown despite extensive research, e.g. the ğ¿2,1-labeling problem, or the packing coloring problem.

Interval graphs have many real applications in diverse areas including genetics [3], economics, and archaeology [37, 38]. According to Golumbic [19], many real-world applications involve solving problems on graphs which are either interval graphs themselves or are related to interval graphs in a natural way. An important subclass of interval graphs is the class of proper interval graphs, graphs which can be represented by such an interval representation that no interval properly contains another one. Another interval representation is a representation with intervals of only unit lengths, graphs which have such a representation are called unit interval graphs. Roberts proved in 1969 [36] that a graph is a proper interval graph if and only if it is a unit interval graph. Later, Gardi came up with a constructive combinatorial proof [17].

The mentioned results do not specifically care about what types of intervals (open, closed, semi-closed) are used in the interval representation. However, as far as there are no restrictions on lengths of intervals, it does not matter which types of intervals are used [40]. The same applies if there is only one type of interval in the interval representation. However, this is not true when all intervals in the interval representation have unit length and at least two types of intervals are used. In particular, the claw ğ¾1,3 can be represented using one open interval and three closed unit intervals whereas it cannot be represented with unit intervals of the same type.

Recently, it has been observed that a restriction on different types of intervals in the unit interval representation leads to several new subclasses of interval graphs. We denote the set of all open, closed, open-closed, and closed-open intervals of unit length by î‰âˆ’âˆ’, î‰++, î‰âˆ’+, and î‰+âˆ’, respectively. Let î‰ be the set of all types of unit intervals. Although there are 16 different combinations of types of unit intervals, it was shown in [13, 25, 35, 40, 41] in the years 2012â€“2018 that they form only four different classes of mixed unit interval graphs. In particular, the following holds:

âˆ…âŠŠunit intervalâŠŠunit open and closed intervalâŠŠsemi-mixed unit intervalâŠŠmixed unit intervalâŠŠinterval graphs,
where unit open and closed interval graphs have (î‰++âˆªî‰âˆ’âˆ’)-intersection representation, semi-mixed unit interval graphs have (î‰++âˆªî‰âˆ’âˆ’âˆªî‰âˆ’+)-intersection representation, and mixed unit interval graphs have î‰-intersection representation. Hence, mixed unit interval graphs allow all types of intervals of unit length.

Definition 1
A graph G is a mixed unit interval graph if it has a î‰-intersection representation. We call such representation a mixed unit interval representation.

There are lots of characterizations of interval and unit interval graphs. Among many of the characterizations, we single out a matrix-like representation called bubble model [23]. A similar notion was independently discovered by Lozin [30] under the name canonical partition. In the bubble model, vertices of a unit interval graph G are placed into a â€œmatrixâ€ where each matrix entry may contain any number (possibly zero) of vertices. Edges of G are represented implicitly with the following conditions: each column forms a clique; and in addition, edges are only between consecutive columns where they form nested neighborhood (two vertices u and v from consecutive columns are adjacent if and only if v occurs in a higher row than u). In particular, there are no edges between non-consecutive columns. This representation can be computed in linear time given a proper interval ordering representation.

We introduce a similar representation of mixed unit interval graphs, called î‰-bubble model, and we extend some results from unit interval graphs to mixed unit interval graphs using this representation. The representation has almost the same structure as the original bubble model, except that edges are allowed in the same row under specific conditions. We show that a graph is mixed unit interval graph if and only if it can be represented by a î‰-bubble model.

Theorem 1
A graph is a mixed unit interval graph if and only if it has a î‰-bubble model. Moreover, given a mixed unit interval representation of graph G on n vertices, a î‰-bubble model can be constructed in îˆ»(ğ‘›) time.

In addition, we show properties of our model, such as the relation of the size of a maximum independent set or maximum clique, and the size of the model, see Sect. 2.6.

Given a graph G, the MaxCut problem is the problem of finding a partition of the vertices of G into two sets S and ğ‘†â¯â¯â¯â¯ such that the number of edges with one endpoint in S and the other one in ğ‘†â¯â¯â¯â¯ is maximum among all partitions. There were two results about polynomiality of the MaxCut problem in unit interval graphs in the past years; the first one by Bodlaender et al. in 1999 [5], the second one by BoyacÄ± et al. which has been published in 2017  [7]. The result of the first paper was disproved by authors themselves a few years later [4]. In the second paper, the authors used a bubble model for proving the polynomiality. However, we realized that this algorithm is also incorrect. Moreover, it seems to us to be hardly repairable. We provide further discussion and also a concrete example, in Sect. 3.2. The complexity of the MaxCut problem in interval graphs was surprisingly unknown for a long time. Interestingly, a result about ğ–­ğ–¯-completeness by Adhikary et al. has appeared on arXiv [1] very recentlyFootnote1.

Using the î‰-bubble model, we obtain at least a subexponential-time algorithm for MaxCut in mixed unit interval graphs. We are not aware of any subexponential algorithms on interval graphs. In general graphs, there has been extensive research dedicated to approximation of MaxCut in subexponential time, see e.g. [2] or [24]. Furthermore, we obtain a polynomial-time algorithm if the given graph has a î‰-bubble model with a constant number of columns. This extends a result by BoyacÄ± et al. [8] who showed a polynomial-time algorithm for MaxCut on unit interval graphs which have a bubble model with two columns (also called co-bipartite chain graphs). The question of whether the MaxCut problem is polynomial-time solvable or ğ–­ğ–¯-hard in unit interval graphs still remains open.

Theorem 2
Let G be a mixed unit interval graph. A maximum cardinality cut can be found in time ğ‘›îˆ»(1)2ğ‘›âˆš(logğ‘›+2).

From the proof of Theorem 2, we derive the following corollary.

Corollary 3
The size of a maximum cut in the graph class defined by î‰-bubble models with k columns can be determined in time îˆ»(ğ‘›ğ‘˜+5). Moreover, for ğ‘˜=2 in time îˆ»(ğ‘›5).

The third part of the paper is devoted to clique-width, one of the graph parameters that is used to measure the complexity of a graph. Many ğ–­ğ–¯-hard problems can be solved efficiently on graphs with bounded clique-width [11]. In general, it is ğ–­ğ–¯-complete to decide if the graph has clique-width at most k for a given number k, see [15].

Unit interval graphs are known to have unbounded clique-width [20]. It follows from results by Fellows et al. [14], and Kaplan and Shamir [26] that the clique-width of (mixed) unit interval graphs is upper-bounded by ğœ” (the maximum size of their clique) + 1. Heggernes et al.  [23] improved this result for unit interval graphs using the bubble model. There, the clique-width is upper-bounded by a minimum of ğ›¼ (the maximum size of an independent set) + 1, and a parameter related to the bubble model representation which is in the worst case ğœ”+1. We use similar ideas to extend these bounds to mixed unit interval graphs using the î‰-bubble model. In particular, we obtain that the upper-bound on clique-width is the minimum of the analogously defined parameter for a î‰-bubble model and 2ğ›¼+3. The upper-bound is still in the worst case ğœ”+1. The upper-bound can be also expressed in the number of rows or columns of î‰-bubble model. Refer to Theorem 21 and Corollary 22 in Sect. 4 for further details. As a consequence, we obtain an analogous result to Corollary 3 for rows using the following result. Fomin et al. [16] showed that the MaxCut problem can be solved in time îˆ»(ğ‘›2ğ‘¡+îˆ»(1)) where t is clique-width of the input graph. By the combination of their result and our upper-bounds on clique-width (Theorem 21 in Sect. 4) we derive not only polynomial-time algorithm when the number of columns is bounded (with worse running time than Corollary 3) but also a polynomial-time algorithm when the number of rows is bounded, formulated as Corollary 4Footnote2. Moreover, the above combination provides an alternative proof of Theorem 2 with slightly worse running-time; see Remark 1 in Sect. 3.3 for more details.

Corollary 4
The size of a maximum cut in the graph class defined by î‰-bubble models with k rows can be determined in time îˆ»(ğ‘›4ğ‘˜+îˆ»(1)).

Preliminaries and Notation
By a graph we mean a finite, undirected graph without loops and multiedges. Let G be a graph. We denote by V(G) and E(G) the vertex and edge set of G, respectively; with ğ‘›=|ğ‘‰(ğº)| and ğ‘š=|ğ¸(ğº)|. Let ğ›¼(ğº) and ğœ”(ğº) denote the maximum size of an independent set of G and the maximum size of a clique in G, respectively. Let ğ‘¢,ğ‘£âˆˆğ‘‰(ğº) be two adjacent vertices, we say that u, v are twins if they have the same neighborhood in G. By a family we mean a multiset {ğ‘†1,â€¦,ğ‘†ğ‘›}, i.e., it allows the possibility that ğ‘†ğ‘–=ğ‘†ğ‘— even though ğ‘–â‰ ğ‘—.

Let ğ‘¥,ğ‘¦âˆˆâ„ be real numbers. We call the set {ğ‘§âˆˆâ„:ğ‘¥â‰¤ğ‘§â‰¤ğ‘¦} closed interval [x, y], the set {ğ‘§âˆˆâ„:ğ‘¥<ğ‘§<ğ‘¦} open interval (x, y), the set {ğ‘§âˆˆâ„:ğ‘¥<ğ‘§â‰¤ğ‘¦} open-closed interval (x, y], and the set {ğ‘§âˆˆâ„:ğ‘¥â‰¤ğ‘§<ğ‘¦} closed-open interval [x, y). By semi-closed interval we mean interval which is open-closed or closed-open. We denote the set of all open, closed, open-closed, and closed-open intervals of unit length by î‰âˆ’âˆ’, î‰++, î‰âˆ’+, and î‰+âˆ’, respectively. Formally, î‰++:={[ğ‘¥,ğ‘¥+1]:ğ‘¥âˆˆâ„}, î‰âˆ’âˆ’:={(ğ‘¥,ğ‘¥+1):ğ‘¥âˆˆâ„}, î‰+âˆ’:={[ğ‘¥,ğ‘¥+1):ğ‘¥âˆˆâ„}, and î‰âˆ’+:={(ğ‘¥,ğ‘¥+1]:ğ‘¥âˆˆâ„}. We further denote the set of all unit intervals by

î‰:=î‰++âˆªî‰âˆ’âˆ’âˆªî‰+âˆ’âˆªî‰âˆ’+.
From now on, we will be speaking only about unit intervals.

Let I be an interval, we define the left and right end of I as â„“(ğ¼):=inf(ğ¼) and ğ‘Ÿ(ğ¼):=sup(ğ¼), respectively. Let ğ¼,ğ½âˆˆî‰ be unit intervals, I, J are almost-twins if â„“(ğ¼)=â„“(ğ½). The type of an interval I is a pair (r, s) where ğ¼âˆˆî‰ğ‘Ÿ,ğ‘ ,ğ‘Ÿ,ğ‘ âˆˆ{+,âˆ’}.

Let ğº=(ğ‘‰,ğ¸) be a graph and îˆµ an interval representation of G. Let ğ‘£âˆˆğ‘‰ be represented by an interval ğ¼ğ‘£âˆˆî‰ğ‘Ÿ,ğ‘ , where ğ‘Ÿ,ğ‘ âˆˆ{+,âˆ’}, in îˆµ. The type of a vertex ğ‘£âˆˆğ‘‰ in îˆµ, denoted by typeîˆµ(ğ‘£), is the pair (r, s). We use type(ğ‘£) if it is clear which interval representation we have in mind. We follow the standard approach where the maximum over the empty set is âˆ’âˆ. The notion of îˆ»Ìƒ  denotes the standard îˆ» which ignores polylogarithmic factors, i.e, îˆ»(ğ‘“(ğ‘›)logğ‘˜ğ‘›)=îˆ»Ìƒ (ğ‘“(ğ‘›)), where k is a constant.

Recognition and î‰-Intersection Representation of Mixed Unit Interval Graphs
All the classes of mixed unit interval graphs can be characterized using forbidden induced subgraphs, sometimes by infinitely many. Rautenbach and Szwarcfiter [35] gave a characterization of unit open and closed interval graphs using five forbidden induced subgraphs. Joos [25] gave a characterization of mixed unit interval graphs without twins by an infinite class of forbidden induced subgraphs. Shuchat et al. [40] proved independently also this characterization, moreover, they complemented it by a quadratic-time algorithm that produces a mixed proper interval representation. Finally, KratochvÃ­l and Talon [41] characterized the remaining classes.

Le and Rautenbach [29] characterized graphs that have a mixed unit interval representations in which all intervals have integer endpoints, and provided a quadratic-time algorithm that decides whether a given interval graph admits such a representation. We refer the reader to the original papers for more details and concrete forbidden subgraphs. More structural results can be found in [41].

Theorem 5
([41]) The classes of semi-mixed and mixed unit interval graphs can be recognized in time îˆ»(ğ‘›2). Moreover, there exists an algorithm which takes a semi-mixed interval graph G on input, and outputs a corresponding (î‰++âˆªî‰âˆ’âˆ’)-intersection representation of G in time îˆ»(ğ‘›2).

Corollary 6
([41]). It is possible to modify the algorithm for semi-mixed unit interval graphs such that given a mixed unit interval graph G, it outputs a mixed unit interval representation of G in time îˆ»(ğ‘›2).

Bubble Model for Mixed Unit Interval Graphs
In this section, we present a î‰-bubble model, a new representation of mixed unit interval graphs which is inspired by the notion of bubble model for proper interval graphs created by Heggernes et al. [23] in 2009.

Definition of Bubble Model
First, we present the bubble model for proper interval graphs as it was introduced by Heggernes et al.

Definition 2
(Heggernes et al. [23], reformulated). If A is a finite non-empty set, then a 2-dimensional bubble structure for A is a partition îˆ®=âŸ¨ğµğ‘–,ğ‘—âŸ©1â‰¤ğ‘—â‰¤ğ‘˜,1â‰¤ğ‘–â‰¤ğ‘Ÿğ‘—, where ğ´=â‹ƒğ‘–,ğ‘—ğµğ‘–,ğ‘—, âˆ…âŠ†ğµğ‘–,ğ‘—âŠ†ğ´ for every i, j with 1â‰¤ğ‘—â‰¤ğ‘˜ and 1â‰¤ğ‘–â‰¤ğ‘Ÿğ‘—, and ğµ1,1â€¦ğµğ‘Ÿğ‘˜,ğ‘˜ are pairwise disjoint. The graph given by îˆ®, denoted as ğº(îˆ®), is defined as follows:

1.
the vertex set of ğº(îˆ®) is A, and

2.
uv is an edge of ğº(îˆ®) if and only if there are indices ğ‘–,ğ‘–â€²,ğ‘—,ğ‘—â€² such that ğ‘¢âˆˆğµğ‘–,ğ‘—, ğ‘£âˆˆğµğ‘–â€²,ğ‘—â€², |ğ‘—âˆ’ğ‘—â€²|â‰¤1, and one of the two conditions holds: either ğ‘—=ğ‘—â€² or (ğ‘–âˆ’ğ‘–â€²)(ğ‘—âˆ’ğ‘—â€²)<0.

A bubble model for a graph ğº=(ğ‘‰,ğ¸) is a 2-dimensional bubble structure îˆ® for V such that ğº=ğº(îˆ®).

Theorem 7
(Heggernes et al. [23]). A graph is proper interval if and only if it has a bubble model.

We define a similar matrix-type structure for mixed unit interval graphs where each set ğµğ‘–,ğ‘— is split into four parts and edges are allowed also in the same row under specific conditions.

Definition 3
Let A be a finite non-empty set and îˆ®=âŸ¨ğµğ‘–,ğ‘—âŸ©1â‰¤ğ‘—â‰¤ğ‘˜,1â‰¤ğ‘–â‰¤ğ‘Ÿğ‘— be a 2-dimensional bubble structure for A such that ğµğ‘–,ğ‘—=ğµ++ğ‘–,ğ‘—âˆªğµ+âˆ’ğ‘–,ğ‘—âˆªğµâˆ’+ğ‘–,ğ‘—âˆªğµâˆ’âˆ’ğ‘–,ğ‘—, ğµğ‘Ÿ,ğ‘ ğ‘–,ğ‘— are pairwise disjoint, and âˆ…âŠ†ğµğ‘Ÿ,ğ‘ ğ‘–,ğ‘—âŠ†ğµğ‘–,ğ‘— for every ğ‘Ÿ,ğ‘ âˆˆ{+,âˆ’} and i, j with 1â‰¤ğ‘—â‰¤ğ‘˜ and 1â‰¤ğ‘–â‰¤ğ‘Ÿğ‘—. We call the partition îˆ® a 2-dimensional î‰-bubble structure for A.

We call each set ğµğ‘–,ğ‘— a bubble, and each set ğµğ‘Ÿ,ğ‘ ğ‘–,ğ‘—,ğ‘Ÿ,ğ‘ âˆˆ{+,âˆ’}, a quadrant of the bubble ğµğ‘–,ğ‘—. The type of a quadrant ğµğ‘Ÿ,ğ‘ ğ‘–,ğ‘—, ğ‘Ÿ,ğ‘ âˆˆ{+,âˆ’}, is the pair (r, s). We denote by âˆ— both + and âˆ’, for example ğµâˆ—+ğ‘–,ğ‘—=ğµâˆ’+ğ‘–,ğ‘—âˆªğµ++ğ‘–,ğ‘—. Bubbles with the same i-index form a row of îˆ®, and with the same j-index a column of îˆ®, we say vertices from bubbles ğµğ‘–,1âˆªâ‹¯âˆªğµğ‘–,ğ‘˜ appear in row i, and we denote i as their row-index. We define an analogous notion for columns. We denote the index of the first row with a non-empty bubble as top(ğ‘—):=min{ğ‘–âˆ£ğµğ‘–,ğ‘—âˆˆîˆ® and ğµğ‘–ğ‘—â‰ âˆ…}. Thus, ğµtop(ğ‘—),ğ‘— is the first non-empty bubble in the column j. Let B be a bubble, then row(ğµ) and col(ğµ) is the row-index and column-index of B, respectively. Let ğ‘¢âˆˆğµğ‘–,ğ‘—, ğ‘£âˆˆğµğ‘–â€²,ğ‘—â€²; we say that u is under v and v is above u if ğ‘–>ğ‘–â€².

Fig. 1
figure 1
Different representations of a mixed unit interval graph G

Full size image
Definition 4
Let îˆ®=âŸ¨ğµğ‘–,ğ‘—âŸ©1â‰¤ğ‘—â‰¤ğ‘˜,1â‰¤ğ‘–â‰¤ğ‘Ÿğ‘— be a 2-dimensional î‰-bubble structure for A. The graph given by îˆ®, denoted as ğº(îˆ®), is defined as follows:

1.
ğ‘‰(ğº(îˆ®))=ğ´,

2.
uv is an edge of ğº(îˆ®) if and only if there are indices ğ‘–,ğ‘–â€²,ğ‘—,ğ‘—â€² such that ğ‘¢âˆˆğµğ‘–,ğ‘—, ğ‘£âˆˆğµğ‘–â€²,ğ‘—â€², or ğ‘£âˆˆğµğ‘–,ğ‘—, ğ‘¢âˆˆğµğ‘–â€²,ğ‘—â€², and one of the three conditions holds:

(a)
ğ‘—=ğ‘—â€², or

(b)
ğ‘—=ğ‘—â€²âˆ’1 and ğ‘–>ğ‘–â€², or

(c)
ğ‘—=ğ‘—â€²âˆ’1 and ğ‘–=ğ‘–â€² and ğ‘¢âˆˆğµâˆ—+ğ‘–,ğ‘—,ğ‘£âˆˆğµ+âˆ—ğ‘–â€²,ğ‘—â€².

The definition says that the edges are only between vertices from the same or consecutive columns and if ğ‘¢âˆˆğµğ‘–,ğ‘— and ğ‘£âˆˆğµğ‘–â€²,ğ‘—+1, there is an edge between u and v if and only if u is under v (ğ‘–>ğ‘–â€²), or they are in the same row and ğ‘¢âˆˆğµâˆ—+ğ‘–,ğ‘—,ğ‘£âˆˆğµ+âˆ—ğ‘–â€²,ğ‘—+1.

Observation 8
Vertices from the same column in ğº(îˆ®) form a clique. Moreover, the neighborhoods of vertices from the same bubble can differ only in the same row, and vertices from the same bubble quadrant are twins.

Definition 5
Let ğº=(ğ‘‰,ğ¸) be a graph. A î‰-bubble model for a graph G is a 2-dimensional î‰-bubble structure îˆ®=âŸ¨ğµğ‘–,ğ‘—âŸ©1â‰¤ğ‘—â‰¤ğ‘˜,1â‰¤ğ‘–â‰¤ğ‘Ÿğ‘— for V such that

(i)
G is isomorphic to ğº(îˆ®), and

(ii)
each column and each row contains a non-empty bubble, and

(iii)
no column ends with an empty bubble, and

(iv)
top(1)=1, and for every ğ‘—âˆˆ{1,â€¦,ğ‘˜âˆ’1}:top(ğ‘—)â‰¤top(ğ‘—+1).

For a î‰-bubble model îˆ®=âŸ¨ğµğ‘–,ğ‘—âŸ©1â‰¤ğ‘—â‰¤ğ‘˜,1â‰¤ğ‘–â‰¤ğ‘Ÿğ‘—, by the number of rows of îˆ® we mean max{ğ‘Ÿğ‘—âˆ£1â‰¤ğ‘—â‰¤ğ‘˜}. We define the size of the î‰-bubble model îˆ® as the number of columns multiplied by the number of rows, i.e., ğ‘˜â‹…max{ğ‘Ÿğ‘—âˆ£1â‰¤ğ‘—â‰¤ğ‘˜}.

See Fig. 1 with an example of a mixed unit interval graph, given by a mixed unit interval representation, and by a î‰-bubble model.

Construction of î‰-Bubble Model
First, we construct a mixed unit interval representation îˆµ of a mixed unit interval graph G using the quadratic-time algorithm, see Corollary 6; then each vertex of G is represented by a corresponding interval in îˆµ. Having a mixed unit interval representation of the graph, our algorithm outputs a î‰-bubble model for the graph in îˆ»(ğ‘›) time.

We now describe the creation of bubbles. Given a mixed unit interval representation îˆµ, all the vertices that are represented by almost-twins in îˆµ form a single bubble where they belong to the particular quadrants according to the type of their corresponding intervals in îˆµ. We denote the set of all bubbles by â„¬. From now on, we speak about bubbles only. We are going to determine their place (row and column) to create a 2-dimensional î‰-bubble structure for â„¬. We show that the î‰-bubble structure is a î‰-bubble model for our graph. Based on the order ğœ by endpoints of intervals in the representation îˆµ from left to right, we obtain the same order on bubbles in â„¬. In line with that, we denote â„“(ğµ):=â„“(ğ¼ğ‘£) and ğ‘Ÿ(ğµ):=ğ‘Ÿ(ğ¼ğ‘£) for a bubble ğµâˆˆâ„¬ and an interval ğ¼ğ‘£âˆˆîˆµ corresponding to ğ‘£âˆˆğµ (note that it is well-defined as every bubble contains only vertices which are represented by almost-twins in îˆµ). The idea of the algorithm is to process the bubbles in the order ğœ, and assign to each bubble its column immediately after processing it. During the processing, the algorithm maintains an auxiliary path in order to assign rows at the end. Thus, rows are assigned to each bubble after all bubbles are processed.

For bubbles ğ´,ğµâˆˆâ„¬, ğ´<ğœğµ denotes that A is smaller than B in order ğœ. For technical reasons, we create two new bubbles: ğµğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡, ğµğ‘’ğ‘›ğ‘‘ such that â„“(ğµğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡)=ğ‘Ÿ(ğµğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡)=âˆ’âˆ and â„“(ğµğ‘’ğ‘›ğ‘‘)=ğ‘Ÿ(ğµğ‘’ğ‘›ğ‘‘)=âˆ. We refer to them as auxiliary bubbles, in particular, if we speak about bubbles, we exclude auxiliary bubbles (also ğµğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡, ğµğ‘’ğ‘›ğ‘‘âˆ‰â„¬). We enhance the representation in a way that each bubble ğµâˆˆâ„¬ has a pointer ğ‘ğ‘Ÿğ‘’ğ‘£:â„¬â†’â„¬âˆª{ğµğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡} defined as follows.

ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ)={ğµğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡maxğœ{ğ´âˆˆâ„¬âˆ£â„“(ğµ)â‰¥ğ‘Ÿ(ğ´)}if â„“(ğµ)<ğ‘Ÿ(minğœâ„¬),otherwise.
In order to set rows at the end, the algorithm is creating a single oriented path P that has the information about the height of elements in the î‰-bubble structure being constructed. Some of the arcs of the path can be marked with level indicator (ğ–«). Intuitively, a consecutive level indicators create a row. For ease of notation, we use ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘ƒ(ğµğ‘–)=ğµğ‘— to say that ğµğ‘— is the next element on path P after ğµğ‘–. We note that we can view P as an order of bubbles; we denote by ğ´<ğ‘ƒğµ, ğ´,ğµâˆˆâ„¬, the information that A occurs earlier than B on P. Also from technical reasons, P starts and ends with ğµğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ and ğµğ‘’ğ‘›ğ‘‘, respectively. Except P and pointers ğ‘ğ‘Ÿğ‘’ğ‘£ and ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘ƒ, the algorithm remembers the highest bubble of column i, denoted by ğ¶ğ—ğ—ˆğ—‰ğ‘–. Also, denote by ğ–¼ğ—ğ—‹ğ—‹, the index of the currently processed column.

Now, we are able to state the algorithm for assigning columns and rows to bubbles in â„¬ and its properties (which are discussed in the Correctness section but are also straightforward to verify while reading the algorithm).

Property 1::
Bubbles are processed (and therefore added somewhere to P) one by one respecting the order ğœ.

Property 2::
The order induced by P of already processed vertices never changes, i.e., once ğ´â‰¤ğ‘ƒğµ then ğ´â‰¤ğ‘ƒğµ for the rest of the algorithm.

Property 3::
The arc of P between bubbles A and B has the level indicator (ğ–«) if and only if ğ‘Ÿ(ğ´)=â„“(ğµ). Moreover, if the arc from A to B has level indicator, then col(ğ´)<col(ğµ).

Property 4::
col(ğ´)â‰¤col(ğµ) whenever ğ´â‰¤ğœğµ.

Property 5::
ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ) is the closest ancestor of B on P in the previous column, i.e., ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ)=max{ğ´âˆ£ğ´â‰¤ğ‘ƒğµ,col(ğ´)=col(ğµ)âˆ’1}.

Property 6::
The order induced by P of vertices in the same column is exactly the order of those vertices induced by ğœ.

Algorithm
Given bubbles in â„¬ ordered by ğœ, the algorithm creates P by processing bubbles one by one in order ğœ. For the purpose of the algorithm description, we denote the order ğœ of bubbles in â„¬ by subscripts, i.e., ğµ1<ğœğµ2<ğœâ€¦ are all bubbles in â„¬ in the described order ğœ (do not confuse with the notation ğµğ‘–,ğ‘— where subscripts denote the row and column). See Fig. 2 for an example of a step of the algorithm. The algorithm outputs a row and a column to each bubble. Initially, set col(ğµ1)=1, ğ‘ƒ=(ğµğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡,ğµ1,ğµğ‘’ğ‘›ğ‘‘), ğ–¼ğ—ğ—‹ğ—‹ =1 and ğ¶ğ—ğ—ˆğ—‰1=ğµ1.

Suppose that ğ‘–âˆ’1 bubbles have been already processed, for ğ‘–â‰¥2. Split the cases of processing bubble ğµğ‘– based on the following possibilities:

i.
â„“(ğµğ‘–)>ğ‘Ÿ(ğ¶ğ—ğ—ˆğ—‰ğ–¼ğ—ğ—‹ğ—‹): First increase ğ–¼ğ—ğ—‹ğ—‹ by one, then set col(ğµğ‘–)=ğ–¼ğ—ğ—‹ğ—‹ and ğ¶ğ—ğ—ˆğ—‰ğ–¼ğ—ğ—‹ğ—‹=ğµğ‘–.

ii.
â„“(ğµğ‘–)=ğ‘Ÿ(ğ¶ğ—ğ—ˆğ—‰ğ–¼ğ—ğ—‹ğ—‹): First increase ğ–¼ğ—ğ—‹ğ—‹ by one, then set col(ğµğ‘–)=ğ–¼ğ—ğ—‹ğ—‹ and ğ¶ğ—ğ—ˆğ—‰ğ–¼ğ—ğ—‹ğ—‹=ğµğ‘–. Let Q be ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘ƒ(ğ¶ğ—ğ—ˆğ—‰ğ–¼ğ—ğ—‹ğ—‹âˆ’1). Substitute arc in P from ğ¶ğ—ğ—ˆğ—‰ğ–¼ğ—ğ—‹ğ—‹âˆ’1 to Q with two new arcs ğ¶ğ—ğ—ˆğ—‰ğ–¼ğ—ğ—‹ğ—‹âˆ’1 to ğµğ‘– that has ğ–« indicator set and from ğµğ‘– to Q.

iii.
â„“(ğµğ‘–)<ğ‘Ÿ(ğ¶ğ—ğ—ˆğ—‰ğ–¼ğ—ğ—‹ğ—‹): Set col(ğµğ‘–)=ğ–¼ğ—ğ—‹ğ—‹.

We continue only with cases i. and iii. and distinguish multiple possibilities:

1.
ğ‘Ÿ(ğ‘ğ‘Ÿğ‘’ğ‘£(ğµğ‘–))=â„“(ğµğ‘–): Let Q be ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘ƒ(ğ‘ğ‘Ÿğ‘’ğ‘£(ğµğ‘–)). Then substitute arc in P from ğ‘ğ‘Ÿğ‘’ğ‘£(ğµğ‘–) to Q with two new arcs ğ‘ğ‘Ÿğ‘’ğ‘£(ğµğ‘–) to ğµğ‘– that has ğ–« indicator set and from ğµğ‘– to Q.

2.
ğ‘Ÿ(ğ‘ğ‘Ÿğ‘’ğ‘£(ğµğ‘–))<â„“(ğµğ‘–): Split this case further based on the properties of ğµğ‘–âˆ’1.

2a.
ğ‘ğ‘Ÿğ‘’ğ‘£(ğµğ‘–âˆ’1)=ğ‘ğ‘Ÿğ‘’ğ‘£(ğµğ‘–): Let Q be ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘ƒ(ğµğ‘–âˆ’1). Substitute arc in P from ğµğ‘–âˆ’1 to Q with two new arcs ğµğ‘–âˆ’1 to ğµğ‘– and from ğµğ‘– to Q.

2b.
ğ‘ğ‘Ÿğ‘’ğ‘£(ğµğ‘–âˆ’1)â‰ ğ‘ğ‘Ÿğ‘’ğ‘£(ğµğ‘–): Let Q be ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘ƒ(ğ‘ğ‘Ÿğ‘’ğ‘£(ğµğ‘–)). Then substitute arc in P from ğ‘ğ‘Ÿğ‘’ğ‘£(ğµğ‘–) to Q with two new arcs ğ‘ğ‘Ÿğ‘’ğ‘£(ğµğ‘–) to ğµğ‘– and from ğµğ‘– to Q.

After processing all the bubbles in â„¬, assign rows to bubbles by a single run over P, inductively: Take the first bubble B of P and assign row(ğµ):=1. Let B be the last bubble on P with already set row index. We are about to determine row(ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘ƒ(ğµ)). If arc in P from B to ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘ƒ(ğµ) has ğ–« indicator, set row(ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘ƒ(ğµ)):=row(ğµ), otherwise row(ğ‘›ğ‘’ğ‘¥ğ‘¡ğ‘ƒ(ğµ)):=row(ğµ)+1.

Fig. 2
figure 2
An example of an input and one step of the construction algorithm

Full size image
Fig. 3
figure 3
A maximum clique of G in a î‰-bubble model. Dark gray color represents the bubbles that are fully contained in the clique. Light gray color highlights two bubbles where only parts of them are contained in the clique, concretely the one of the sets ğµğ‘–,ğ‘—,ğµğ‘–,ğ‘—+1, and ğµâˆ—+ğ‘–,ğ‘—âˆªğµ+âˆ—ğ‘–,ğ‘—+1 with the maximum size

Full size image
Correctness
Here, we show that the algorithm above gives us a î‰-bubble model for a graph given by mixed unit interval representation. It gives us the forward implication of Theorem 1.

Lemma 9
Given a mixed unit interval representation îˆµ of a connected graph G on n vertices, a î‰-bubble model for G can be constructed in îˆ»(ğ‘›) time.

Proof of Lemma 9
We show the correctness of the construction, i.e., that the constructed object satisfies Definition 5 and that declared Properties 1â€“6 are satisfied during the whole algorithm. Let â„¬ be the set of bubbles created from îˆµ as in Sect. 2.2. It follows immediately from the construction that Properties 1â€“4 are satisfied. Observe that ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ) is always in the previous column than B, for ğµâˆˆâ„¬. Moreover, observe that in step ii. of the algorithm, ğ¶ğ—ğ—ˆğ—‰col(ğµ)âˆ’1=ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ),ğµâˆˆâ„¬. Then, Property 5 follows from the construction. Property 6 can be seen by examining the construction. Let ğ´,ğµâˆˆâ„¬ be two bubbles in the same column such that ğ´<ğœğµ. Either ğ‘ğ‘Ÿğ‘’ğ‘£(ğ´)=ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ), then B is put later than A on P. Or ğ‘ğ‘Ÿğ‘’ğ‘£(ğ´)<ğœğ‘ğ‘Ÿğ‘’ğ‘£(ğµ), then, by the construction, ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ) is put after A and B is put after ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ). In both cases, ğ´<ğ‘ƒğµ. Using Property 2, the Property 6 holds.

It is readily seen that the algorithm outputs a 2-dimensional î‰-bubble structure for the vertex set of G. Let îˆ® denote the î‰-bubble structure and ğº(îˆ®) denote the graph given by îˆ®. We want to show that îˆ® is a î‰-bubble model for G. Parts (ii), (iii) from Definition 5 are clearly satisfied. It remains to show (i) and (iv).

Let us start with (i), that is, ğº(îˆ®) is isomorphic to G. Let ğ‘¢âˆˆğ´, ğ‘£âˆˆğµ, where A, B are bubbles in ğº(îˆ®). Recall from the construction of â„¬ that u and v are represented by almost-twins in îˆµ if and only if ğ´=ğµ. The former implies that u and v are adjacent in G, the latter implies that u and v are adjacent in ğº(îˆ®). Since the case of ğ´=ğµ is trivially satisfied, without loss of generality, we assume ğ´<ğœğµ. We distinguish a few cases based on the position of A and B in îˆ®.

First, let A and B be in non-consecutive columns in îˆ®. Denote by ğ‘=col(ğ´). By Definition 4, u and v are non-adjacent in ğº(îˆ®). By the construction, there exists a non-empty bubble ğ¶ğ—ğ—ˆğ—‰ğ‘+1 in îˆ® such that it is the top bubble of column ğ‘+1. It follows that ğ¶ğ—ğ—ˆğ—‰ğ‘+1>ğœğ´, by Property 4, and also ğ¶ğ—ğ—ˆğ—‰ğ‘+1â‰ ğ´. Since the construction assigns B to a different column than ğ¶ğ—ğ—ˆğ—‰ğ‘+1, we know that ğ‘Ÿ(ğ¶ğ—ğ—ˆğ—‰ğ‘+1)â‰¤â„“(ğµ). It gives immediate conclusion that u, v are not adjacent in G.

Second, let A and B be in the same column c in îˆ®. Vertices u, v are adjacent in ğº(îˆ®) by Definition 4. By the construction, there exists a non-empty bubble ğ¶ğ—ğ—ˆğ—‰ğ‘ in îˆ® such that it is the top bubble in column c and â„“(ğ¶ğ—ğ—ˆğ—‰ğ‘)â‰¤â„“(ğ´)<â„“(ğµ)<ğ‘Ÿ(ğ¶ğ—ğ—ˆğ—‰ğ‘)=1+â„“(ğ¶ğ—ğ—ˆğ—‰ğ‘). Therefore, u, v are adjacent in G.

Third, let A and B appear in consecutive columns in îˆ®. We denote ğ‘=col(ğ´)=col(ğµ)âˆ’1. By Definition 4, vertices u, v are adjacent in ğº(îˆ®) if and only if either row(ğ´)>row(ğµ), or row(ğ´)=row(ğµ) and ğ‘¢âˆˆğ´âˆ—+,ğ‘£âˆˆğµ+âˆ—. By Properties 1 and 2 of P, it is sufficient to verify only the situation when bubble B was added. Observe that if ğµâ€²<ğ‘ƒğµâ€³ then row(ğµâ€²)â‰¤row(ğµâ€³). We split the case into the following all possibilities:

ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ)>ğœğ´: By the definition of ğ‘ğ‘Ÿğ‘’ğ‘£ and the interval property, u is non-adjacent to v in G and ğ‘Ÿ(ğ´)â‰ â„“(ğµ). By Property 6, ğ´<ğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘£(ğµ). By Property 5, ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ)<ğ‘ƒğµ. As ğ´<ğ‘ƒğµ, row(ğ´)â‰¤row(ğµ). By Property 3, row(ğ´)<row(ğµ). Therefore, u, v are non-adjacent in ğº(îˆ®).

ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ)=ğ´: By Properties 3, 5 and the rows assignment, row(ğµ)=row(ğ´) if and only if â„“(ğµ)=ğ‘Ÿ(ğ´). Therefore, there is an edge in both models if and only if u and v are of correct types; that is, u has a type (âˆ—,+) and v has a type (+,âˆ—).

ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ)<ğœğ´: By the definition of ğ‘ğ‘Ÿğ‘’ğ‘£ and the interval property, u is adjacent to v in G and ğ‘Ÿ(ğ´)>â„“(ğµ). By Property 6, ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ)<ğ‘ƒğ´, therefore, row(ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ)â‰¤row(ğ´)). By Property 5, row(ğ´)â‰¥row(ğµ). By Property 3, the equality cannot occur. Therefore, row(ğ´)>row(ğµ).

Indeed, ğº(îˆ®) is isomorphic to G.

Part (iv) follows by the construction of P. When ğµ=ğ¶ğ—ğ—ˆğ—‰ğ‘—,ğ‘—â‰¥2 is added on P, by Property 5, ğ‘ğ‘Ÿğ‘’ğ‘£(ğµ)<ğ‘ƒğµ. We note that ğ¶ğ—ğ—ˆğ—‰ğ‘—âˆ’1â‰¤ğ‘ƒğ‘ğ‘Ÿğ‘’ğ‘£(ğµ). We obtain row(ğ¶ğ—ğ—ˆğ—‰ğ‘—âˆ’1)â‰¤row(ğ¶ğ—ğ—ˆğ—‰ğ‘—) for every possible j. Also note that row(minğœâ„¬)=row(ğ¶ğ—ğ—ˆğ—‰1)=1.

It remains to show the running-time of the algorithm. We note that ğ‘ğ‘Ÿğ‘’ğ‘£ can be easily computed by a single run over the representation, as well as the assigning columns can be done simultaneously by a single run over the representation (having ğ‘ğ‘Ÿğ‘’ğ‘£ and remembering top bubbles of columns). Moreover, rows are assigned by a single run over path P which leads to overall running time îˆ»(ğ‘›) where n is the number of intervals of the given mixed unit interval representation. â—»

Proof of Theorem 1
Proof of Theorem 1
First, we prove the reverse implication: given a î‰-bubble model for a graph G, we construct a mixed unit interval representation of G. Let îˆ®=âŸ¨ğµğ‘–,ğ‘—âŸ©1â‰¤ğ‘—â‰¤ğ‘˜,1â‰¤ğ‘–â‰¤ğ‘Ÿğ‘— be a î‰-bubble model of G. Let

ğœ€:=1max{ğ‘Ÿğ‘—âˆ£1â‰¤ğ‘—â‰¤ğ‘˜}.
We create a mixed unit interval representation îˆµ of G as follows. Let ğ‘£âˆˆğµğ‘Ÿ,ğ‘ ğ‘–,ğ‘—, where ğ‘Ÿ,ğ‘ âˆˆ{+,âˆ’}. The corresponding interval ğ¼ğ‘£ of v has the properties:

ğ¼ğ‘£âˆˆî‰ğ‘Ÿ,ğ‘  and â„“(ğ¼ğ‘£):=ğ‘—+(ğ‘–âˆ’1)ğœ€.
We note that all vertices from the same bubble are represented by intervals that are almost-twins and the type of an interval corresponds with the type of the bubble quadrant. Since ğœ€ was chosen such that ğœ€(ğ‘–âˆ’1)<1 for any row i in îˆ®, the graph given by the constructed mixed unit interval representation is isomorphic to the graph given by îˆ®. The forward implication follows from Lemma 9. â—»

Properties of î‰-Bubble Model
In this section, we give basic properties of a î‰-bubble model which are used later in the text. It is readily seen that a î‰-bubble model of graph ğº=(ğ‘‰,ğ¸) has at most n rows and n columns where n is the number of vertices of G since each column and each row contains at least one vertex. Consequently, the size of a î‰-bubble model is at most ğ‘›2.

Two basic characteristics of a graph are the size of a maximum clique and the size of a maximum independent set in the graph. The problem of finding those numbers is ğ–­ğ–¯-complete in general but it is polynomial-time solvable in interval graphs. We show a relation between those two numbers and the size of a î‰-bubble model for the graph. We start with the size of a maximum independent set.

Lemma 10
Let G be a mixed unit interval graph, and let îˆ® be a î‰-bubble model for G. The number of columns of îˆ® is at least ğ›¼(ğº) and at most 2ğ›¼(ğº).

Proof
Let I be a maximum independent set of G, and let k be the number of columns of îˆ®. We have that ğ›¼(ğº)â‰¥âŒˆğ‘˜/2âŒ‰ from the property that two non-consecutive columns from îˆ® are not adjacent in ğº(îˆ®). Since each column forms a clique, only one vertex from each column can be in I. Therefore, ğ›¼(ğº)â‰¤ğ‘˜. â—»

In the bubble model for unit interval graphs, ğ›¼(ğº) is equal to the number of columns [23]. However, the gap in Lemma 10 cannot be narrowed in generalâ€”consider an even number k and the following unit interval graphs: path on k-vertices (ğ‘ƒğ‘˜) and a clique on k vertices (ğ¾ğ‘˜). There exists a unit interval representation of ğ‘ƒğ‘˜ using only closed intervals which leads to a î‰-bubble model of ğ‘ƒğ‘˜ containing one row and k columns, where ğ›¼(ğ‘ƒğ‘˜)=âŒˆğ‘˜/2âŒ‰. A î‰-bubble model of ğ¾ğ‘˜ contains k rows and one column, where ğ›¼(ğ¾ğ‘˜)=1=number of columns.

Another important and useful property of graphs is the size of a maximum clique. We show that a maximum clique of a mixed unit interval graph can be found in two consecutive columns of a î‰-bubble model of the graph, see Fig. 3.

Fig. 4
figure 4
A counterexample to the original algorithm, a bubble model îˆ® where the numbers denote the number of vertices in each bubble, and dashed lines indicate the edges between bubbles

Full size image
Lemma 11
Let G be a mixed unit interval graph, and let îˆ® be a î‰-bubble model for G. Then the size of a maximum clique is

ğœ”(ğº)ğ‘ğ‘–=maxğ‘—âˆˆ{1,â€¦,ğ‘˜âˆ’1}ğ‘–âˆˆ{1,â€¦,ğ‘Ÿğ‘—+1}(âˆ‘ğ‘–â€²=ğ‘–+1ğ‘Ÿğ‘—|ğµğ‘–â€²,ğ‘—|+âˆ‘ğ‘–â€²=1ğ‘–âˆ’1|ğµğ‘–â€²,ğ‘—+1|+ğ‘ğ‘–),={max{|ğµğ‘–,ğ‘—|,|ğµğ‘–,ğ‘—+1|,|ğµâˆ—+ğ‘–,ğ‘—|+|ğµ+âˆ—ğ‘–,ğ‘—+1|}|ğµğ‘–,ğ‘—+1|ğ‘–â‰¤ğ‘Ÿğ‘—,otherwise.
Proof
Let K be a maximum clique of G. Notice, K does not contain two vertices from non-consecutive columns, as there are no edges between non-consecutive columns. Furthermore, vertices u and v from two consecutive columns ğ¶ğ‘— and ğ¶ğ‘—+1, respectively, can be in K only if u is under v or they are in the same row in quadrants of types {âˆ—+} and {+âˆ—}, respectively.

On the other hand, vertices from one column of îˆ® create a clique in ğº(îˆ®). Moreover, if we split any two consecutive columns ğ¶ğ‘— and ğ¶ğ‘—+1 in row i (for any index ğ‘–âˆˆ{1,â€¦,min{ğ‘Ÿğ‘—,ğ‘Ÿğ‘—+1}}), the second part of ğ¶ğ‘— with the first part of ğ¶ğ‘—+1 form a clique. This is true even together with bubble quadrants ğµâˆ—+ğ‘–,ğ‘—âˆªğµ+âˆ—ğ‘–,ğ‘—+1. â—»

Maximum Cardinality Cut
This section is devoted to the time complexity of the MaxCut problem on (mixed) unit interval graphs.

Notation
A cut of a graph G(V, E) is a partition of V(G) into two subsets ğ‘†,ğ‘†Â¯, where ğ‘†Â¯=ğ‘‰(ğº)âˆ–ğ‘†. Since ğ‘†Â¯ is the complement of S, we say for the brevity that a set S is a cut and similarly we use terms cut vertexFootnote3 and non-cut vertex for a vertex ğ‘£âˆˆğ‘† and ğ‘£âˆˆğ‘†Â¯, respectively. The cut-set of cut S is the set of edges of G with exactly one endpoint in S, we denote it ğ¸(ğ‘†,ğ‘†Â¯). Then, the value |ğ¸(ğ‘†,ğ‘†Â¯)| is the cut size of S. A maximum (cardinality) cut on G is a cut with the maximum size among all cuts on G. Finally, the MaxCut problem is the problem of determining the size of the maximum cut.

Time Complexity is Still Unknown on Unit Interval Graphs
As it was mentioned in the introduction, there is a paper A polynomial-time algorithm for the maximum cardinality cut problem in proper interval graphs by BoyacÄ± et al. from 2017 [7], claiming that the MaxCut problem is polynomial-time solvable in unit interval graphs and giving a dynamic programming algorithm based on the bubble model representation. We realized that the algorithm is incorrect; this section is devoted to it.

We start with a counterexample to the original algorithm.

Example
Let îˆ®=âŸ¨ğµğ‘–,ğ‘—âŸ©1â‰¤ğ‘—â‰¤2,1â‰¤ğ‘–â‰¤2, where ğµ1,1={ğ‘£1}, ğµ2,1={ğ‘£2}, ğµ1,2={ğ‘£3,ğ‘£4,ğ‘£5}, ğµ2,2={ğ‘£6}, be a bubble model for a graph G, see also Fig. 4. In other words, this bubble model corresponds to a unit interval graph on vertices ğ‘£1,ğ‘£2,ğ‘£3,ğ‘£4,ğ‘£5,ğ‘£6 where there is the edge ğ‘£1ğ‘£2, and vertices ğ‘£2,ğ‘£3,ğ‘£4,ğ‘£5,ğ‘£6 create a complete graph without the edge ğ‘£2ğ‘£6.

Fig. 5
figure 5
A heavy part with light columns L and R and the highlighted subgraph ğºğ‘–

Full size image
Then, according to the paper [7], the size of a maximum cut in G is eight. To be more concrete, the algorithm from [7] fills the following values of dynamic table: ğ¹0,1(0,0)=4, ğ¹2,1(1,1)=8 for ğ‘ 2,1=1,ğ‘ 2,2=1, and finally, ğ¹0,0(0,0)=8 which is the output of the algorithm. However, the size of a maximum cut in G is only seven. Suppose, for contradiction, that the size of a maximum cut is eight. As there are ten edges in total in G, at least one vertex of the triangle ğ‘£3,ğ‘£4,ğ‘£5 must be a cut-vertex and one not. Then, those two vertices have three common neighbors. Therefore, the size of a maximum cut is at most seven which is possible; for example, ğ‘£1,ğ‘£4,ğ‘£5 are cut-vertices.

The brief idea of the algorithm in [7] is to process the columns from the biggest to the lowest column from the top bubble to the bottom one. Once we know the number of cut-vertices in the actual processed bubble B (in the column j) and the number of cut-vertices which are above B in the columns j and ğ‘—+1, we can count the exact number of edges. For each bubble and each such number of cut-vertices in the columns j and ğ‘—+1 (above the bubble), we remember only the best values of MaxCutFootnote4.

We claim that the algorithm and its full idea from [7] are incorrect since we lose the consistency thereâ€”to obtain a maximum cut, we do not remember anything about the distribution of cut vertices within bubbles, that was used in the previously processed column. Therefore, there is no guarantee that the final outputted cut of the computed size exists. To be more specific, one of two problems is in the moving from the column j to the column ğ‘—âˆ’1 since we forget there too much. The second problem is that for each bubble ğµğ‘–,ğ‘— and for each possible numbers ğ‘¥,ğ‘¥â€² we count the size ğ¹ğ‘–,ğ‘—(ğ‘¥,ğ‘¥â€²) of a specific cut and we choose some values ğ‘ ğ‘–,ğ‘—, ğ‘ ğ‘–,ğ‘—+1 (possibly different; they represents the number of cut-vertices in the bubbles ğµğ‘–,ğ‘—,ğµğ‘–,ğ‘—+1) which maximize the values of ğ¹ğ‘–,ğ‘—(ğ‘¥,ğ‘¥â€²). In few steps later, when we are processing the bubble ğµğ‘–,ğ‘—âˆ’1, again, for each possible values y and ğ‘¦â€² we choose some values ğ‘ â€²ğ‘–,ğ‘—âˆ’1 and ğ‘ â€²ğ‘–,ğ‘— such that they maximize the size of ğ¹ğ‘–,ğ‘—âˆ’1(ğ‘¦,ğ‘¦â€²). However, we need to be consistent with the selection in the previous column, i.e., to guarantee that ğ‘ ğ‘–â€²,ğ‘—=ğ‘ ğ‘–,ğ‘— for any particular values y, ğ‘¦â€²=ğ‘¥, and ğ‘¥â€².

A straightforward correction of the algorithm would lead to remembering too much for a polynomial-time algorithm. However, we can be inspired by it to obtain a subexponential-time algorithm. We attempted to correct the algorithm or extend the idea leading to the polynomiality. However, despite lots of effort, we were not successful and it seemed to us that the presented algorithm is hardly repairable. We note here, that there is another paper by the same authors [8] where a very similar polynomial algorithm is used for MaxCut of co-bipartite chain graphs with twins. Those graphs can be viewed as graphs given by bubble models with two columns; but having two columns is a crucial property for the algorithm.

To conclude, the time complexity of the MaxCut problem on unit interval graphs is still not resolved and it seems to be a challenging open question.

Subexponential Algorithm in Mixed Unit Interval Graphs
Here, we present a subexponential-time algorithm for the MaxCut problem in mixed unit interval graphs. Our aim is to have an algorithm running in 2îˆ»Ìƒ (ğ‘›âˆš) time. Some of the ideas, for unit interval graphs, originated in discussion with Karczmarz, Nadara, RzÄ…Å¼ewski, and Zych-Pawlewicz at Parameterized Algorithms Retreat of University of Warsaw 2019 [34].

Let us start with a notation. Let H be a graph, ğ‘ŠâŠ†ğ‘‰(ğ»), and ğ‘†âŠ†ğ‘Š, we say that a cut X of H agrees with S in W if ğ‘‹âˆ©ğ‘Š=ğ‘†. We denote the size of a maximum cut of H that agrees with S in W as ğ‘šğ‘ğ‘ (ğ»,ğ‘†,ğ‘Š). Let G be a mixed unit interval graph. We take a î‰-bubble model îˆ®=âŸ¨ğµğ‘–,ğ‘—âŸ©1â‰¤ğ‘—â‰¤ğ‘˜,1â‰¤ğ‘–â‰¤ğ‘Ÿğ‘— for G and we distinguish columns of îˆ® according to their number of vertices. We denote by ğ‘ğ‘–ğ‘— the number of vertices in bubble ğµğ‘–,ğ‘— and by ğ‘ğ‘— the number of vertices in column j, i.e., ğ‘ğ‘–ğ‘—=|ğµğ‘–,ğ‘—| and ğ‘ğ‘—=âˆ‘ğ‘Ÿğ‘—ğ‘–=1ğ‘ğ‘–,ğ‘—. We call a column j with ğ‘ğ‘—>ğ‘›âˆš a heavy column, otherwise a light column. We call consecutive heavy columns and their two bordering light columns a heavy part of îˆ® (if îˆ® starts or ends with a heavy column, for brevity, we add an empty column at the beginning or the end of îˆ®, respectively), and we call their light columns borders. A heavy part might contain no heavy columns in the case that two light columns are consecutive.

We note that we can guess all possible cuts in one light column without exceeding the aimed time and that most of those light column guesses are independent of each otherâ€”once we know the cut in the previous column, it does not matter what the cut is in columns before. Furthermore, there are at most ğ‘›âˆš consecutive heavy columns which allow us to process them together in subexponential time. More formally, we show that we can determine a maximum cut independently for each heavy part, given a fixed cut on its borders, as stated in the following lemma.

Lemma 12
Let G be a mixed unit interval graph and îˆ®=âŸ¨ğµğ‘¥,ğ‘¦âŸ©1â‰¤ğ‘¦â‰¤ğ‘˜,1â‰¤ğ‘¥â‰¤ğ‘Ÿğ‘¦ be a î‰-bubble model for G where îˆ®Ì‚ 1,â€¦,îˆ®Ì‚ ğ‘ are heavy parts of îˆ® in this order. If ğ‘†=ğ‘†0âˆªâ‹¯âˆªğ‘†ğ‘ is a (fixed) cut of light columns îˆ¸=ğ¶ğ‘–0âˆªğ¶ğ‘–1âˆªâ‹¯âˆªğ¶ğ‘–ğ‘ in ğº(îˆ®), where 1â‰¤ğ‘–0<â€¦<ğ‘–ğ‘â‰¤ğ‘˜, such that ğ‘†ğ‘— is a cut of ğ¶ğ‘–ğ‘—, ğ‘—âˆˆ{0,â€¦,ğ‘}, then

ğ‘šğ‘ğ‘ (ğº,ğ‘†,îˆ¸)=âˆ‘ğ‘—=1ğ‘ğ‘šğ‘ğ‘ (ğº(îˆ®Ì‚ ğ‘—),ğ‘†ğ‘—âˆ’1âˆªğ‘†ğ‘—,ğ¶ğ‘–ğ‘—âˆ’1âˆªğ¶ğ‘–ğ‘—)âˆ’(âˆ‘ğ‘—=1ğ‘âˆ’1|ğ‘†ğ‘—|â‹…|ğ¶ğ‘–ğ‘—âˆ–ğ‘†ğ‘—|).
Proof
It is readily seen that once we have a fixed cut in an entire column C of a bubble model, a maximum cut of columns which are to the left of C (including C) is independent on a maximum cut of those which are to the right of C (including C). Therefore, we can sum the sizes of maximum cuts in heavy parts which are separated by fixed cuts. However, the cut size of middle light columns is counted twice since they are contained in two heavy parts. Therefore, we subtract them. â—»

Now, our aim is to determine the size of a maximum cut for a heavy part îˆ®Ì‚  given a fixed cut on its borders. This can be also achived by clique-width approach using results in [16] with a slightly worse running time; see Remark 1 for details. We note that if îˆ®Ì‚  is a heavy part with no heavy columns, we can straightforwardly count the number of cut-edges of ğº(îˆ®Ì‚ ) assuming a fixed cut on borders is given. Therefore, we are focusing on a situation where at least one heavy column is present in a heavy part. We use dynamic programming to determine the size of a maximum cut on each such heavy part.

Let îˆ®Ì‚  be a heavy part with â„â‰¥1 heavy columns (for simplicity numbered by 1,â€¦,â„) and borders L and R (we also refer to L and R as columns 0 and â„+1, respectively). First, we present a brief idea of the dynamic programming approach, followed by technical definitions and proofs later. We take bubbles in îˆ®Ì‚  which are not in borders and process them one-by-one in top-bottom, left-right order. When processing a bubble, we consider all the possibilities of numbers of cut-vertices in each its quadrant. We refer to the already processed part after i-th step as ğºğ‘–, that is, ğºğ‘– is the induced subgraph of ğº(îˆ®Ì‚ ) with ğ‘‰(ğºğ‘–)=ğµ1âˆªâ‹¯âˆªğµğ‘–âˆªğ¿âˆªğ‘… where ğµğ‘—, ğ‘—âˆˆ{1,â€¦,ğ‘–} are first i bubbles in top-bottom, left-right order in îˆ®Ì‚  (as it is shown in Fig. 5).

We store all possible (â„+1)-tuples (ğ‘ 1,ğ‘ 2,â€¦,ğ‘ â„,ğ‘), where ğ‘ ğ‘— characterizes the number of all cut vertices in (heavy) column j, and number a characterizes the number of cut vertices of types (âˆ—,+) in the last processed bubble. Then, we define recursive function f where ğ‘“ğ‘– will be related to the maximum size of a cut that has exactly ğ‘ ğ‘— cut vertices in column j (for all j) in the already processed part ğºğ‘–. More precisely, we want the recursive function f to satisfy the properties later covered by Lemma 13. Once, f satisfies the desired properties, we easily obtain the size of a maximum cut in the heavy part (Theorem 14, below).

Now, we present a key observation for the construction of f. Observe, by the properties of î‰-bubble model, that the edges of ğºğ‘– can be partitioned into following disjoint sets:

ğ¸1={edges of the graph ğºğ‘–âˆ’1},

ğ¸2={edges inside ğµğ‘–},

ğ¸3={edges between ğµğ‘– and the same column above ğµğ‘–},

ğ¸4={edges between ğµğ‘– and the next column above ğµğ‘–},

ğ¸5={edges between ğµğ‘– and the bubble in the previous column and the same row as ğµğ‘–},

ğ¸6={edges between ğµğ‘– and column L below ğµğ‘–},

ğ¸7={edges between ğµğ‘– and the bubble in column R in the same row as ğµğ‘–}.

Therefore, the idea there is to count the size of a desired cut of ğºğ‘– using the sizes of possible cuts in ğºğ‘–âˆ’1 and add the size of a cut using edges ğ¸2âˆ’ğ¸7. The former is stored in ğ‘“ğ‘–âˆ’1 and the later can be counted from the number of cut vertices in currently processed bubble ğµğ‘– and numbers in the (â„+1)-tuple we are processing.

Now, let us properly define the function f and prove Theorem 2 formally. We develop more notation. Let ğµ1,...,ğµğ‘š be bubbles in îˆ®Ì‚ âˆ–(ğ¿âˆªğ‘…) numbered in the top-bottom, left-right order. Let ğ‘†ğ¿ and ğ‘†ğ‘… be (fixed) cuts in L and R. To handle borders, we define auxiliary functions ğ‘›â†“,ğ‘›â†,ğ‘›â†‘, ğ‘›â†’ which output the number of cut vertices in borders in a specific position depending on the given row and column; they output 0 if the given column is not next to the borders. We define:

the number of (fixed) cut vertices in L under row r (or 0 if the previous column is not L):

ğ‘›â†“(ğ‘Ÿ,ğ‘):={|ğ‘†ğ¿âˆ©â‹ƒğ‘Ÿ0ğ‘˜=ğ‘Ÿ+1ğµğ‘˜,0|0ğ‘=1ğ‘â‰ 1,
the number of (fixed) cut vertices of type (âˆ—,+) in the left border L in row r:

ğ‘›â†(ğ‘Ÿ,ğ‘):={|ğ‘†ğ¿âˆ©ğµâˆ—,+ğ‘Ÿ,0|0ğ‘=1ğ‘â‰ 1,
the number of (fixed) cut vertices in the right border R above row r:

ğ‘›â†‘(ğ‘Ÿ,ğ‘):={|ğ‘†ğ‘…âˆ©â‹ƒğ‘Ÿâˆ’1ğ‘˜=1ğµğ‘˜,â„+1|0ğ‘=â„ğ‘â‰ â„,
the number of (fixed) cut vertices of type (+,âˆ—) in the right border R in row r:

ğ‘›â†’(ğ‘Ÿ,ğ‘):={|ğ‘†ğ‘…âˆ©ğµ+,âˆ—ğ‘Ÿ,â„+1|0ğ‘=â„ğ‘â‰ â„.
We denote the number of vertices in ğµğ‘– by ğ‘ğ‘–:=|ğµğ‘–|, analogously ğ‘ğ‘¥ğ‘¦ğ‘–:=|ğµğ‘¥ğ‘¦ğ‘–|, ğ‘¥,ğ‘¦âˆˆ{+,âˆ’}. We further denote

ğ›½ğ‘–:={(ğ‘›1,ğ‘›2,ğ‘›3,ğ‘›4)âˆ£ğ‘›1âˆˆ{0,â€¦,ğ‘++ğ‘–},ğ‘›2âˆˆ{0,â€¦,ğ‘+âˆ’ğ‘–},ğ‘›3âˆˆ{0,â€¦,ğ‘âˆ’+ğ‘–},ğ‘›4âˆˆ{0,â€¦,ğ‘âˆ’âˆ’ğ‘–}}.
In addition, we denote the set of (â„+1)-tuples characterizing all possible counts of cut-vertices in the h heavy columns and an auxiliary number characterizing the count of possible edges from the last processed bubble, by

ğ‘‡={(ğ‘ 1,â€¦,ğ‘ â„,ğ‘)âˆ£ğ‘âˆˆâ„•,0â‰¤ğ‘â‰¤maxğ‘–âˆˆ{1,â€¦,ğ‘š}(ğ‘âˆ’+ğ‘–+ğ‘++ğ‘–),âˆ€ğ‘—âˆˆ{1,â€¦,â„}:ğ‘ ğ‘—âˆˆâ„•,0â‰¤ğ‘ ğ‘—â‰¤ğ‘ğ‘—}.
Let ğ‘’(ğ‘ 1,ğ‘ 2) denote the number of cut-edges between two sets ğ‘†1, ğ‘†2 which are complete to each other and ğ‘†ğ‘˜, ğ‘˜âˆˆ{1,2}, contains ğ‘ ğ‘˜ cut vertices and ğ‘ ğ‘˜â¯â¯â¯â¯â¯ non-cut vertices, i.e., ğ‘’(ğ‘ 1,ğ‘ 2)=ğ‘ 1â‹…ğ‘ 2â¯â¯â¯â¯â¯+ğ‘ 1â¯â¯â¯â¯â¯â‹…ğ‘ 2. We remark that it is important to know the numbers of non-cut vertices (ğ‘ 1â¯â¯â¯â¯â¯ and ğ‘ 2â¯â¯â¯â¯â¯), however, we will not write them explicitly for the easier formulas. It will be seen that they can be, for instance, stored in parallel with the numbers of cut vertices (or counted in each step again).

Finally, we define a recursive function f by the following recurrence relation:

âˆ€(ğ‘ 1,â€¦,ğ‘ â„,ğ‘)âˆˆğ‘‡:if ğ‘ 1â‰¤ğ‘1,ğ‘ 2=â‹¯=ğ‘ â„=0:ğ‘“1((ğ‘ 1,â€¦,ğ‘ â„,ğ‘))=max(ğ‘++,ğ‘âˆ’+,ğ‘+âˆ’,ğ‘âˆ’âˆ’)âˆˆğ›½1:ğ‘+++ğ‘âˆ’++ğ‘+âˆ’+ğ‘âˆ’âˆ’=ğ‘ 1,ğ‘+++ğ‘âˆ’+=ğ‘(ğ‘’(ğ‘ 1,ğ‘›â†“(1,1))+ğ‘ 1â‹…(ğ‘1âˆ’ğ‘ 1)+ğ‘’(ğ‘›â†(1,1),(ğ‘+++ğ‘+âˆ’))+ğ‘’(ğ‘›â†’(1,1),ğ‘+++ğ‘âˆ’+)),otherwise:ğ‘“1((ğ‘ 1,â€¦,ğ‘ â„,ğ‘))=âˆ’âˆ.âˆ€ğ‘–âˆˆ{2,â€¦,ğ‘š},âˆ€(ğ‘ 1,â€¦,ğ‘ â„,ğ‘)âˆˆğ‘‡:ğ‘“ğ‘–((ğ‘ 1,â€¦,ğ‘ â„,ğ‘))=max(ğ‘++,ğ‘+âˆ’,ğ‘âˆ’+,ğ‘âˆ’âˆ’)âˆˆğ›½ğ‘–,ğ‘§âˆˆâ„•:ğ‘+++ğ‘âˆ’+=ğ‘,(ğ‘ 1,â€¦,ğ‘ ğ‘âˆ’ğ‘,â€¦,ğ‘ â„,ğ‘§)âˆˆğ‘‡,ğ‘§â‰¤|ğµâˆ—+ğ‘–âˆ’1|(ğ‘“ğ‘–âˆ’1((ğ‘ 1,â€¦,ğ‘ ğ‘âˆ’ğ‘,â€¦,ğ‘ â„,ğ‘§))+ğ‘â‹…(ğ‘ğ‘–âˆ’ğ‘)+ğ‘’(ğ‘,ğ‘ ğ‘+1)+ğ‘’(ğ‘,ğ‘ ğ‘âˆ’ğ‘)+ğ‘’(ğ‘›â†“(ğ‘Ÿ,ğ‘),ğ‘)+ğ‘’(ğ‘›â†(ğ‘Ÿ,ğ‘),(ğ‘+++ğ‘+âˆ’))+ğ‘’((ğ‘+++ğ‘âˆ’+),ğ‘›â†’(ğ‘Ÿ,ğ‘))+ğ´)where ğ´={ğ‘’(ğ‘§,ğ‘+++ğ‘+âˆ’)0ğ‘–>1,ğ‘=col(ğµğ‘–âˆ’1)+1,otherwise,and ğ‘=ğ‘+++ğ‘+âˆ’+ğ‘âˆ’++ğ‘âˆ’âˆ’,ğ‘=col(ğµğ‘–),ğ‘Ÿ=row(ğµğ‘–), and ğ‘ â„+1=ğ‘›â†‘(ğ‘Ÿ,ğ‘).
Recall that ğºğ‘– denotes the induced subgraph of ğº(îˆ®Ì‚ ) with ğ‘‰(ğºğ‘–)=ğµ1âˆªâ‹¯âˆªğµğ‘–âˆªğ¿âˆªğ‘….

Lemma 13
For each ğ‘ =(ğ‘ 1,â€¦,ğ‘ â„,ğ‘)âˆˆğ‘‡ and for every ğ‘–âˆˆ{1,â€¦,ğ‘š}, the value ğ‘“ğ‘–(ğ‘ ) is equal to the maximum size of a cut S in ğºğ‘– that satisfies the following

for every ğ‘—âˆˆ{1,â€¦,â„}, the number of cut vertices in the column j in ğºğ‘– is equal to ğ‘ ğ‘—, and S agrees with ğ‘†ğ¿âˆªğ‘†ğ‘… in ğ¿âˆªğ‘…, and

a is equal to the number of cut vertices from ğµ++ğ‘–âˆªğµâˆ’+ğ‘–,

or ğ‘“ğ‘– is equal to âˆ’âˆ if there is no such cut.

Proof
We prove Lemma 13 by induction on the number of steps (bubbles). Since ğµ1 is in the first heavy column, Lemma 13 is true for ğ‘–=1 by Definition 5 (iv).

In the inductive step, suppose that for every ğ‘ =(ğ‘£1,ğ‘£2,â€¦,ğ‘£â„,ğ‘§)âˆˆğ‘‡, ğ‘“ğ‘–âˆ’1(ğ‘ ) is equal to the size of a maximum cut ğ‘†ğ‘–âˆ’1 in ğºğ‘–âˆ’1 such that the number of cut vertices in each column j, for every ğ‘—âˆˆ{1,2,â€¦,â„}, in ğºğ‘–âˆ’1 is equal to ğ‘£ğ‘—, and the number of cut vertices from ğµâˆ—+ğ‘–âˆ’1 is equal to z. Or ğ‘“ğ‘–âˆ’1(ğ‘ ) is equal to âˆ’âˆ if such a cut does not exist.

As it was mentioned, the edges of ğºğ‘– can be partitioned into disjoint sets ğ¸1â€”ğ¸7. Recall:

ğ¸1={edges of the graph ğºğ‘–âˆ’1},

ğ¸2={edges inside ğµğ‘–},

ğ¸3={edges between ğµğ‘– and the same column above ğµğ‘–},

ğ¸4={edges between ğµğ‘– and the next column above ğµğ‘–},

ğ¸5={edges between ğµğ‘– and the bubble in the previous column and the same row as ğµğ‘–},

ğ¸6={edges between ğµğ‘– and column L below ğµğ‘–},

ğ¸7={edges between ğµğ‘– and the bubble in column R in the same row as ğµğ‘–}.

We note that ğ¸6 is non-empty only if ğµğ‘– is in the column 1, similarly ğ¸7 is non-empty only if ğµğ‘– is in the column h. Let ğ‘ =(ğ‘ 1,â€¦,ğ‘ â„,ğ‘)âˆˆğ‘‡ be fixed. At first assume, S is a maximum cut in ğºğ‘– (that agrees with ğ‘†ğ¿âˆªğ‘†ğ‘… in ğ¿âˆªğ‘…) such that it contains ğ‘ ğ‘— vertices from the column j for each ğ‘—âˆˆ{1,2,â€¦,â„} and a vertices from ğµâˆ—+ğ‘–; we say S satisfies the conditions s. We discuss the case where no such cut exists, later. We denote by ğ‘ ğ‘¥ğ‘¦ the number of vertices in ğµğ‘¥ğ‘¦ğ‘–âˆ©ğ‘†, ğ‘¥,ğ‘¦âˆˆ{+,âˆ’}, and by ğ‘ â€² the sum of these values, i.e., ğ‘ â€²=ğ‘ +++ğ‘ +âˆ’+ğ‘ âˆ’++ğ‘ âˆ’âˆ’. We denote col(ğµğ‘–) by j, and row(ğµğ‘–) by r. Then,

ğ¸(ğ‘†,ğ‘†â¯â¯â¯â¯)=(ğ¸(ğ‘†,ğ‘†â¯â¯â¯â¯)âˆ©ğ¸(ğºğ‘–âˆ’1))âˆª{ğ‘¢ğ‘£âˆˆğ¸ğ‘˜âˆ£ğ‘¢âˆˆğ‘†,ğ‘£âˆ‰ğ‘†,ğ‘˜âˆˆ{2,â€¦,6}}.
Which leads to the expression:

|ğ¸(ğ‘†,ğ‘†â¯â¯â¯â¯)| where ğ´=|ğ¸(ğ‘†,ğ‘†â¯â¯â¯â¯)âˆ©ğ¸(ğºğ‘–âˆ’1)|+ğ‘ â€²â‹…(ğ‘ğ‘–âˆ’ğ‘ â€²)+ğ‘’(ğ‘ â€²,(ğ‘ ğ‘—âˆ’ğ‘ â€²))+ğ‘’(ğ‘ â€²,ğ‘ ğ‘—+1)+ğ´+ğ‘’(ğ‘ â€²,ğ‘›â†“(ğ‘Ÿ,ğ‘—))+ğ‘’(ğ‘ +++ğ‘ +âˆ’,ğ‘›â†(ğ‘Ÿ,ğ‘—))+ğ‘’(ğ‘ +++ğ‘ âˆ’+,ğ‘›â†’(ğ‘Ÿ,ğ‘—)),={ğ‘’(|ğ‘†âˆ©ğµâˆ—+ğ‘–âˆ’1|,ğ‘ +++ğ‘ +âˆ’)0ğ‘—=col(ğµğ‘–âˆ’1)+1,ğ‘œğ‘¡â„ğ‘’ğ‘Ÿğ‘¤ğ‘–ğ‘ ğ‘’.
By the induction hypothesis,

|ğ¸(ğ‘†,ğ‘†â¯â¯â¯â¯)âˆ©ğ¸(ğºğ‘–âˆ’1)|â‰¤ğ‘“ğ‘–âˆ’1(ğ‘ 1,â€¦,ğ‘ ğ‘—âˆ’ğ‘ â€²,â€¦,ğ‘ â„,|ğ‘†âˆ©ğµâˆ—+ğ‘–âˆ’1|).
(1)
It gives us together with the right part of the equation, the definition of ğ‘“ğ‘– for ğ‘ğ‘¥ğ‘¦=ğ‘ ğ‘¥ğ‘¦, ğ‘=ğ‘ â€² and ğ‘§=|ğ‘†âˆ©ğµâˆ—+ğ‘–âˆ’1|. Therefore,

|ğ¸(ğ‘†,ğ‘†â¯â¯â¯â¯)|â‰¤ğ‘“ğ‘–(ğ‘ ).
Furthermore, we show that ğ‘“ğ‘–(ğ‘ ) is the size of a cut satisfying the conditions s. Since the value of the function ğ‘“ğ‘–âˆ’1((ğ‘ 1,â€¦,ğ‘ ğ‘—âˆ’ğ‘,â€¦,ğ‘ â„,ğ‘§)) is for any number ğ‘âˆˆ{0,â€¦,min(ğ‘ ğ‘—,ğ‘ğ‘–)} a size of a cut in ğºğ‘–âˆ’1 which satisfies the conditions (ğ‘ 1,â€¦,ğ‘ ğ‘—âˆ’ğ‘,â€¦,ğ‘ â„,ğ‘§), or âˆ’âˆ (if no such cut exists), we can extend that cut into ğºğ‘– by adding ğ‘ğ‘¥ğ‘¦ vertices from ğµğ‘¥ğ‘¦ğ‘– where ğ‘+++ğ‘âˆ’+=ğ‘ and ğ‘+++ğ‘+âˆ’+ğ‘âˆ’++ğ‘âˆ’âˆ’=ğ‘. Consequently, ğ‘“ğ‘–(ğ‘ ) is a size of a cut on ğºğ‘– satisfying that it contains ğ‘ ğ‘– vertices from the column i and a vertices from |ğµâˆ—+ğ‘–|. At least one such cut exists, by (1). Therefore, |ğ¸(ğ‘†,ğ‘†â¯â¯â¯â¯)|â‰¥ğ‘“ğ‘–(ğ‘ ). It leads to the equation |ğ¸(ğ‘†,ğ‘†â¯â¯â¯â¯)|=ğ‘“ğ‘–(ğ‘ ), otherwise, S is not a maximum cut.

In a similar way, we can extend every cut on ğºğ‘–âˆ’1 to ğºğ‘–. Therefore, if there exist no cut on ğºğ‘– which satisfies the conditions s, there exists no cut in ğºğ‘–âˆ’1 which can be extended to the cut on ğºğ‘– satisfying the conditions s. Consequently, ğ‘“ğ‘–(ğ‘ )=âˆ’âˆ by the definition of f since ğ‘“ğ‘–âˆ’1(ğ‘£)=âˆ’âˆ for all (â„+1)-tuples v which appear in the definition. â—»

Finally, we obtain the next theorem about a maximum cut of a heavy part as a corollary of Lemma 13.

Theorem 14
Let îˆ®Ì‚  be a heavy part with â„â‰¥1 heavy columns (numbered by 1,â€¦,â„) and borders L and R. Let ğµ1,...,ğµğ‘š be bubbles in îˆ®Ì‚ âˆ–(ğ¿âˆªğ‘…) numbered in the top-bottom, left-right order. Let ğ‘†ğ¿ and ğ‘†ğ‘… be (fixed) cuts in L and R. Then,

ğ‘šğ‘ğ‘ (ğº(îˆ®Ì‚ ),ğ‘†ğ¿âˆªğ‘†ğ‘…,ğ¿âˆªğ‘…)=maxğ‘ âˆˆğ‘‡ğ‘“ğ‘š(ğ‘ ).
Towards proving Theorem 2 and Corollary 3, it remains to prove the time complexity of processing a heavy part.

Lemma 15
Let îˆ®Ì‚  be a heavy part with â„â‰¥1 columns, m bubbles, and a fixed cut in the borders. The size of a maximum cut of îˆ®Ì‚  that agrees with the fixed cut in the borders can be determined in time:

(ğ‘1+1)â€¦(ğ‘â„+1)â‹…(ğ‘+1)â‹…âˆ‘ğ‘–=1ğ‘š(ğ‘++ğ‘–â‹…ğ‘+âˆ’ğ‘–â‹…ğ‘âˆ’+ğ‘–â‹…ğ‘âˆ’âˆ’ğ‘–)
where ğ‘ğ‘— is the number of vertices in the column j, i.e., ğ‘ğ‘—=âˆ‘ğ‘Ÿğ‘—ğ‘–â€²=1ğµğ‘–â€²,ğ‘—, and ğ‘=maxğ‘–|ğµâˆ—+ğ‘–|.

Proof
We analyze the time complexity of the algorithm from Lemma 15. Let T denote all the possible (â„+1)-tuples. Then |ğ‘‡|=(ğ‘1+1)â€¦(ğ‘â„+1)â‹…(ğ‘+1). The time for processing a bubble ğµğ‘– is |ğ‘‡|â‹…ğ‘++ğ‘–â‹…ğ‘+âˆ’ğ‘–â‹…ğ‘âˆ’+ğ‘–â‹…ğ‘âˆ’âˆ’ğ‘–. The time complexity of processing îˆ®Ì‚  is then

|ğ‘‡|â‹…âˆ‘ğ‘–=1ğ‘šğ‘++ğ‘–â‹…ğ‘+âˆ’ğ‘–â‹…ğ‘âˆ’+ğ‘–â‹…ğ‘âˆ’âˆ’ğ‘–.
â—»

Now, we are ready to prove Theorem 2.

Proof of Theorem 2
By Lemma 12, heavy parts can be processed independently on each other, given a cut on their borders. Moreover, it is sufficient for a light column C to remember only the biggest cuts on the left of C (containing C) for each possible cut in C. Therefore, there is no need to guess cuts in all light columns at once. It is sufficient to guess a cut only in two consecutive light columns at once.

Observe that there are at most 2ğ‘›âˆš guesses of cut vertices for a light column and there are at most n light columns. Therefore, the time complexity of determining the size of a maximum cut in G is at most ğ‘›â‹…(2ğ‘›âˆš)2â‹…ğ‘ƒ, where P is the maximum time for processing a heavy part. Now, we want to prove a time complexity of processing a heavy part îˆ®Ì‚ =âŸ¨ğµğ‘–,ğ‘—âŸ©1â‰¤ğ‘—â‰¤ğ‘™,1â‰¤ğ‘–â‰¤ğ‘Ÿğ‘— with a given guess of light columns.

By Lemma 15, the time complexity of processing a heavy part with a given guess of light columns is

ğ‘ƒ=(ğ‘1+1)â€¦(ğ‘â„+1)â‹…(ğ‘+1)â‹…âˆ‘ğ‘–=1ğ‘š(ğ‘++ğ‘–â‹…ğ‘+âˆ’ğ‘–â‹…ğ‘âˆ’+ğ‘–â‹…ğ‘âˆ’âˆ’ğ‘–)â‰¤(ğ‘›+1)1+ğ‘›âˆšâ‹…âˆ‘ğ‘–=1ğ‘šğ‘4ğ‘–â‰¤(ğ‘›+1)1+ğ‘›âˆšâ‹…ğ‘›4âˆˆîˆ»(ğ‘›52ğ‘›âˆšlog(ğ‘›)).
To sum up, we can determine the size of a maximum cut in time:

ğ‘›â‹…(2ğ‘›âˆš)2â‹…ğ‘ƒâˆˆîˆ»(ğ‘›62ğ‘›âˆš(log(ğ‘›)+2)).
(2)
For brevity, we analyzed only the size of a maximum cut. However, the maximum cut itself can be determined retroactively in the same running time. â—»

Remark 1
We wish to point out that Theorem 2 with slightly worse bound of ğ‘›îˆ»(1)22ğ‘›âˆš(log(ğ‘›)+1) can be derived by combination of the maxcut algorithm parameterized by the clique-width as presented in [16] together with our bounds on the clique-width expressed by the number of columns of the model (Corollary 22), and Lemma 12.

More precisely, the heavy part is composed of at most ğ‘›âˆš columns plus two additional light columns. Therefore, by Corollary 22 the clique-width of the heavy part is bounded by ğ‘›âˆš+5. As the algorithm in [16] can be easily modified to determine the maximum cut size even when the cut on the light columns is given, we conclude by Lemma 12 and the expression in (2) where ğ‘ƒ=ğ‘›îˆ»(1)ğ‘›2(ğ‘›âˆš+5).

Lemma 15 has a nice corollary for graphs with a î‰-bubble model with a constant number of columns. According to Lemma 15, we are able to solve the MaxCut problem in those graphs in polynomial time which is formulated as Corollary 3 in the introduction. Therefore, we improved another polynomial-time algorithm by BoyacÄ± et al. [8] solving the MaxCut problem in co-bipartite chain graphs with possible twins (which is exactly the class of graphs defined by a classic bubble model with only two columns).

Proof of Corollary 3
Let G be a graph on n vertices which is defined by a î‰-bubble model îˆ® with k columns and m bubbles. The bubble model îˆ® can be seen as a heavy part with no cut-vertices in its borders. By Lemma 15, the size of a maximum cut in îˆ® can be determined in time ğ‘‡=(ğ‘1+1)â€¦(ğ‘ğ‘˜+1)â‹…(ğ‘+1)â‹…âˆ‘ğ‘šğ‘–=1(ğ‘++ğ‘–â‹…ğ‘+âˆ’ğ‘–â‹…ğ‘âˆ’+ğ‘–â‹…ğ‘âˆ’âˆ’ğ‘–) where ğ‘ğ‘¥ğ‘¦ğ‘–,ğ‘¥ğ‘¦âˆˆ{+,âˆ’} is the number of vertices in the bubble quadrant ğµğ‘¥ğ‘¦ğ‘–, and ğ‘ğ‘— is the number of vertices in the column j, i.e., ğ‘ğ‘—=âˆ‘ğ‘Ÿğ‘—ğ‘–â€²=1ğµğ‘–â€²,ğ‘—, and ğ‘=maxğ‘–|ğµâˆ—+ğ‘–|.

By Arithmetic Mean-Geometric Mean Inequality (AM-GM) we obtain

ğ‘‡â‰¤(ğ‘+1)â‹…(1ğ‘˜â‹…âˆ‘ğ‘—=1ğ‘˜(ğ‘ğ‘—+1))ğ‘˜â‹…âˆ‘ğ‘–=1ğ‘š(ğ‘++ğ‘–+ğ‘+âˆ’ğ‘–+ğ‘âˆ’+ğ‘–+ğ‘âˆ’âˆ’ğ‘–4)4=(ğ‘+1)â‹…(ğ‘›+ğ‘˜ğ‘˜)ğ‘˜â‹…âˆ‘ğ‘–=1ğ‘š(ğ‘ğ‘–4)4â‰¤(ğ‘+1)â‹…(ğ‘›+ğ‘˜ğ‘˜)ğ‘˜â‹…(ğ‘›4)4âˆˆîˆ»(ğ‘›ğ‘˜+5).
It remains to prove the special case where ğ‘˜=2. Notice, it is sufficient to distinguish only between vertices in quadrants of types (âˆ—,+) and (âˆ—,âˆ’) in the first column, and similarly (+,âˆ—) and (âˆ’,âˆ—) in the second column. Therefore, we obtain (ğ‘ğ‘–2)2 instead of (ğ‘ğ‘–4)4 which leads to the time complexity îˆ»(ğ‘›ğ‘˜+1+2)=îˆ»(ğ‘›5). â—»

We note that Theorem 14 states the explicit size of a maximum cut.

Clique-Width Of Mixed Unit Interval Graphs
The clique-width is one of the parameters which are used to measure the complexity of a graph. Many ğ–­ğ–¯-hard problems, those which are expressible in Monadic Second-Order Logic using second-order quantifiers on vertices (ğ‘€ğ‘†ğ‘‚1), can be solved efficiently in graphs of bounded clique-with [11]. For instance, 3-coloring. Definition of the clique-width is quite technical but it follows the idea that a graph of the clique-width at most k can be iteratively constructed such that in any time, there are at most k types of vertices, and vertices of the same type behave indistinguishably from the perspective of the newly added vertices.

Definition 6
(Courcelle 2000). The clique-width of a graph G, denoted by ğ‘ğ‘¤ğ‘‘(ğº), is the smallest integer number of different labels that is needed to construct the graph G using the following operations:

0.
creation of a vertex with label i,

1.
disjoint union (denoted by âŠ•),

2.
relabeling: renaming all labels i to j (denoted by ğœŒğ‘–â†’ğ‘—),

3.
edge insertion: connecting all vertices with label i to all vertices with label j, ğ‘—âˆˆ{1,â€¦,ğ‘˜}, ğ‘–â‰ ğ‘—; already existing edges are not doubled (denoted by ğœ‚ğ‘–,ğ‘—).

Such a construction of a graph can be represented by an algebraic term composed of the operations âŠ•, ğœŒğ‘–â†’ğ‘—, and ğœ‚ğ‘–,ğ‘—, called cwd-expression. We call k-expression a cwd-expression in which at most k different labels occur. Using this, we can say that the clique-width of a graph G is the smallest integer k such that the graph G can be defined by a k-expression.

Example
The diamond graph G on the four vertices u, v, w, x (the complete graph ğ¾4 without the edge vw) is defined by the following cwd-expression:

ğœ‚1,2(ğœŒ2â†’1(ğœ‚1,2(1(ğ‘¢)âŠ•2(ğ‘£)âŠ•2(ğ‘¤)))âŠ•2(ğ‘¥)).
Therefore, ğ‘ğ‘¤ğ‘‘(ğº)â‰¤2.

Fellows et al. [15] proved in 2009 that the deciding whether the clique-width of a graph G is at most k is ğ–­ğ–¯-complete. Therefore, researchers put effort into computing an upper-bound of the clique-width.

Courcelle and Olariu [12] showed in 2000 that bounded treewidth implies bounded clique-width (but not vice versa). They showed that for any graph G with the treewidth k, the clique-width of G is at most 4â‹…2ğ‘˜âˆ’1+1.

Golumbic and Rotics [20] proved that unit interval graphs have unbounded clique-width via a construction that can be described as a bubble model where all bubbles contains exactly one vertex. Consequently, (mixed unit) interval graphs have unbounded clique-width as well. Therefore, computing upper-bounds are of particular interest. Fellows et al. [14] showed that the clique-width of a graph is bounded by its pathwidth + 2, therefore, the clique-width of interval graphs as well as of unit interval graphs is upper-bounded by the size of their maximum clique + 1 [14, 26]. Using a bubble model structure, subclasses of unit interval graphs were characterized in terms of (linear) clique-width [30, 32]. Courcelle [12] observed that clique-width can be computed componentwise.

Lemma 16
(Courcelle [12]). Any graph G satisfies that

ğ‘ğ‘¤ğ‘‘(ğº)=ğ‘šğ‘ğ‘¥{ğ‘ğ‘¤ğ‘‘(ğºâ€²)âˆ£ğºâ€² is a connected component of ğº}.
We provide an upper-bound of the clique-width of a graph G depending on the number of columns in a î‰-bubble model of G. We express it also in the size of a maximum independent set.

Lemma 17
Let G be a mixed unit interval graph and îˆ® be a î‰-bubble model of G. Then ğ‘ğ‘¤ğ‘‘(ğº)â‰¤ğ‘˜+3, where k is the number of columns of îˆ®. Moreover, a (ğ‘˜+3)-expression defining the graph G can be constructed in îˆ»(ğ‘›) time from îˆ®.

Proof
The proof is inspired by the proof for unit interval graphs [23].

We find a (ğ‘˜+3)-expression defining G and, therefore, prove that ğ‘ğ‘¤ğ‘‘(ğº)â‰¤ğ‘˜+3. We use ğ‘˜+3 labels where label i will be assigned to i-th column of îˆ® and the remaining three labels, denoted by ğ‘™1,ğ‘™2,ğ‘™3, are used for maintaining the last two added vertices.

We define a linear order on vertices of G according to îˆ® as follows:

(i)
We take the vertices from top to bottom, left to right. Formally, let ğ‘¥âˆˆğµğ‘–,ğ‘—, ğ‘¦âˆˆğµğ‘™,ğ‘š, we define ğ‘¥â‰ºğ‘¦ if ğ‘–<ğ‘™ or (ğ‘–=ğ‘™ and ğ‘—<ğ‘š);

(ii)
we define the following order on bubble quadrants:

ğ‘¥â‰ºğ‘¦â‰ºğ‘§â‰ºğ‘¤ for ğ‘¥âˆˆğµâˆ’âˆ’ğ‘–,ğ‘—,ğ‘¦âˆˆğµ+âˆ’ğ‘–,ğ‘—,ğ‘§âˆˆğµâˆ’+ğ‘–,ğ‘—,ğ‘¤âˆˆğµ++ğ‘–,ğ‘—;
(iii)
we define an arbitrary linear order on vertices in the same quadrant of the same bubble.

The idea of the proof is that every column has its own label and we need three more labels for maintaining the last added vertices. We will add vertices to G in the described order which ensures that a new vertex is complete to all vertices from the following column and anti-complete to all vertices from the previous column except those from the same row. Recall that according to the definition of î‰-bubble model, there is an edge between vertices ğ‘¥âˆˆğµğ‘–,ğ‘— and ğ‘¦âˆˆğµğ‘–,ğ‘—+1 if and only if ğ‘¥âˆˆğµâˆ—,+ğ‘–,ğ‘— and ğ‘¦âˆˆğµ+âˆ—ğ‘–,ğ‘—+1. Therefore, vertices from the last constructed bubble in the previous column must have two distinct labels according to the types of the vertices. However, once we add all vertices from the actual bubble, we do not need to distinguish between vertices from the previous column, anymore. Therefore, we rename their labels to the label of their column.

Formally. Let x be the first (smallest) vertex of G according to the defined linear order. We know that x is from the first column by Definition 5 (iv). If x is of type (âˆ’,+) or (+,+), we label it by ğ‘™1, otherwise by 1, so the expression for ğº[{ğ‘¥}] is 1(x) if x is of type (+,âˆ’) or (âˆ’,âˆ’), and ğ‘™1(ğ‘¥) otherwise.

Let y be the first non-processed vertex from G, i.e., a label is assigned to all preceding vertices. Let ğ‘™2,ğ‘™3âˆˆ{ğ‘˜+1,ğ‘˜+2,ğ‘˜+3} are currently unused labels or ğ‘™2 is used in the actual bubble ğµğ‘–,ğ‘— and ğ‘™3 is unused, and ğ‘™1 may be used (in the previous column). We note that at most one label from {ğ‘˜+1,ğ‘˜+2,ğ‘˜+3} is used in the previous column any time. We split the proof according to the type of y, the bubble quadrant where y belongs.

(a)
ğ‘¦âˆˆğµâˆ’âˆ’ğ‘–,ğ‘—. We use label ğ‘™2 for y. Then, we make y (the only one vertex with label ğ‘™2) complete to vertices with labels ğ‘—+1 (if ğ‘—<ğ‘˜) and j. Relabel ğ‘™2 to j.

(b)
ğ‘¦âˆˆğµ+âˆ’ğ‘–,ğ‘—. We use label ğ‘™2 for y. Then, we make y (the only one vertex with label ğ‘™2) complete to vertices with labels ğ‘—+1 (if ğ‘—<ğ‘˜), j, ğ‘™1. Relabel ğ‘™2 to j.

(c)
ğ‘¦âˆˆğµâˆ’+ğ‘–,ğ‘—. We use label ğ‘™2 for y. Then, we make all vertices with label ğ‘™2 complete to vertices with labels ğ‘—+1 (if ğ‘—<ğ‘˜), j, ğ‘™2. (Do not relabel vertices with label ğ‘™2).

(d)
ğ‘¦âˆˆğµ++ğ‘–,ğ‘—. We use label ğ‘™3 for y. Then, we make y (the only one vertex with label ğ‘™3) complete to vertices with labels ğ‘—+1 (if ğ‘—<ğ‘˜), j, ğ‘™1, ğ‘™2. Relabel ğ‘™3 to ğ‘™2.

If all vertices from ğµğ‘–,ğ‘— were used, we rename all vertices with the label ğ‘™1 to ğ‘—âˆ’1 if ğ‘—>1. If ğ‘—=ğ‘˜, we relabel ğ‘™2 to k.

For the correctness, observe that the previous column has always at most two labels and in a), b), and d) the temporary label for y is unique (no other vertices are labeled by it at that time). The rest follows from the definition of adjacency in the î‰-bubble model. Since we constructed G using at most ğ‘˜+3 labels, ğ‘ğ‘¤ğ‘‘(ğº)â‰¤ğ‘˜+3.

The described algorithm processes each vertex once and each vertex has at most three labels in total. Moreover, the algorithm needs a constant work for each vertexâ€”for instance, a cwd-expression for the option a) is:

ğœŒğ‘™2â†’ğ‘—(ğœ‚ğ‘—,ğ‘™2(ğœ‚ğ‘—+1,ğ‘™2(ğ‘™2(ğ‘¦)âŠ•ğºâ€²))),
where ğºâ€² is the already constructed graph before adding the vertex y. Therefore, the (ğ‘˜+3)-expression defining G is constructed in linear time given a î‰-bubble model in an appropriate structure. â—»

Theorem 18
Let G be a mixed unit interval graph. Then ğ‘ğ‘¤ğ‘‘(ğº)â‰¤2ğ›¼(ğº)+3. Moreover, a (2ğ›¼(ğº)+3)-expression defining the graph G can be constructed in îˆ»(ğ‘›) time provided a î‰-bubble model of G is given.

Proof
We apply Lemma 17 and Lemma 10 together to obtain the statements. â—»

Next, we provide a different bound for clique-width which is obtained by a small extension of the proof for unit interval graphs using the bubble model by Heggernes et al. [23]. We include the full proof for completeness.

We need more notation. Let G be a mixed unit interval graph and let îˆ®=âŸ¨ğµğ‘–,ğ‘—âŸ©1â‰¤ğ‘—â‰¤ğ‘˜,1â‰¤ğ‘–â‰¤ğ‘Ÿğ‘— be a î‰-bubble model for G. We say that vertices from the same column j of îˆ® create a group if they have the same neighbours in the following column ğ‘—+1 of îˆ®. Let ğ‘£âˆˆğµğ‘–,ğ‘—, the group number of vertex v in îˆ®, denoted by ğ‘”îˆ®(ğ‘£), is defined as the maximum number of groups in ğ‘(ğ‘£)âˆ©(â‹ƒğ‘Ÿğ‘—âˆ’1ğ‘–â€²=ğ‘–+1ğµğ‘–â€²,ğ‘—âˆ’1âˆªâ‹ƒğ‘–âˆ’1ğ‘–â€²=1ğµğ‘–â€²,ğ‘—âˆªğ´) over the sets ğ´=ğµâˆ—+ğ‘–,ğ‘—âˆ’1âˆªğµ+âˆ—ğ‘–,ğ‘— and ğ´=ğµğ‘–,ğ‘—. Then the group number of G in îˆ® is defined as

ğœ‘îˆ®(ğº):=maxğ‘£âˆˆğ‘‰(ğº)ğ‘”îˆ®(ğ‘£).
Lemma 19
Let G is a mixed unit interval graph and îˆ® a î‰-bubble model for G. The following inequality holds

ğœ‘îˆ®(ğº)â‰¤ğœ”(ğº)âˆ’1.
Proof
Let ğ‘£âˆˆğµğ‘–,ğ‘—. Observe that â‹ƒğ‘Ÿğ‘—âˆ’1ğ‘–â€²=ğ‘–+1ğµğ‘–â€²,ğ‘—âˆ’1âˆªâ‹ƒğ‘–âˆ’1ğ‘–â€²=1ğµğ‘–â€²,ğ‘—âˆªğ´âˆª{ğ‘£} is a clique (for both the possibilities of A), see Lemma 11. Moreover, v is not included in the counting the group number of v, and no vertex can be in more than one group. Therefore, ğ‘”îˆ®(ğ‘£)â‰¤ğœ”(ğº)âˆ’1 for any vertex v which leads to the desired inequality. â—»

Theorem 20
Let G be a mixed unit interval graph and îˆ® a î‰-bubble model for G. Then ğ‘ğ‘¤ğ‘‘(ğº)â‰¤ğœ‘îˆ®(ğº)+2. Moreover, a (ğœ‘îˆ®(ğº)+2)-expression defining the graph G can be constructed in îˆ»(ğ‘›+ğ‘š) time provided a î‰ -bubble model of G is given.

Proof
Our aim is to find a (ğœ‘îˆ®(ğº)+2)-expression defining G. We add vertices in the order from left to right, top to bottom of îˆ® processing vertices of type (+,âˆ—) at first, i. e., in the following linear order:

(i)
ğ‘¥â‰ºğ‘¦ for ğ‘¥âˆˆğµğ‘–,ğ‘—, ğ‘¦âˆˆğµğ‘™,ğ‘š, where ğ‘—<ğ‘š or (ğ‘—=ğ‘š and ğ‘–<ğ‘™);

(ii)
ğ‘¥â‰ºğ‘¦â‰ºğ‘§â‰ºğ‘¤ for ğ‘¥âˆˆğµ++ğ‘–,ğ‘—,ğ‘¦âˆˆğµ+âˆ’ğ‘–,ğ‘—,ğ‘§âˆˆğµâˆ’+ğ‘–,ğ‘—,ğ‘¤âˆˆğµâˆ’âˆ’ğ‘–,ğ‘—;

(iii)
an arbitrary linear order on the vertices in the same quadrant of the same bubble.

Now, we follow the original proof. Shortly, we add each vertex v in a proper way. We assume that a label is assigned for each previous vertex and all the vertices which belong to the same group have the same label. At first, we change to 1 the label of all the previous vertices which are non-adjacent to v. We know that at most ğ‘”îˆ®(ğ‘£) distinct labels are used in the remaining groups, say labels {2,â€¦,ğ‘”îˆ®(ğ‘£)+1}. This is true since all the groups are adjacent to v and because of the linear order.

We note that it is important to add first all the vertices of type (+,âˆ—) from a bubble. Otherwise, ğ‘”îˆ®(ğ‘£)+1 remaining groups could be there; in the situation that v is of type (+,âˆ—), a potentially one distinct label is needed for ğµâˆ—+ğ‘–,ğ‘—âˆ’1, and another for ğµâˆ—âˆ’ğ‘–,ğ‘—. One the other hand, if all the vertices of type (+,âˆ—) precede vertices of type (âˆ’,âˆ—) in one bubble, this situation does not happenâ€”a potential label of ğµâˆ—+ğ‘–,ğ‘—âˆ’1 would be released. Therefore, it is enough to take into account only the parts ğ´=ğµâˆ—+ğ‘–,ğ‘—âˆ’1âˆªğµ+âˆ—ğ‘–,ğ‘—, and ğ´=ğµğ‘–,ğ‘—, and not the bigger one ğ´=ğµâˆ—+ğ‘–,ğ‘—âˆ’1âˆªğµğ‘–,ğ‘—, in the definition of ğ‘”îˆ®(ğ‘£).

We use a free label, say ğ‘”îˆ®(ğ‘£)+2, for v and join all the vertices with this label with vertices with labels 2,â€¦,ğ‘”îˆ®(ğ‘£)+1. Next, change the label of v to a label of its group if v belongs to an already existing group. We continue with the next vertex. During the processing of each vertex, we need no more than its group number + 2 distinct labels. Therefore, ğ‘ğ‘¤ğ‘‘(ğº)â‰¤ğœ‘îˆ®(ğº)+2.

It remains to determine the running time for the construction of the expression defining G. Assume a î‰-bubble model is given in a way that going over all vertices takes linear time in the number of vertices. First, we count the time for the creation of groups. For each vertex v we compare its neighbors from the next column with the neighbors of the previous vertex in this column. Therefore, the splitting vertices into groups and determining the group number of G take îˆ»(ğ‘š+ğ‘›) time. In a constant time, we determine a free label for each vertex. Then, we need to check the labels of groups in the neighborhood of each vertex v and create a îˆ»(ğ‘”îˆ®(ğ‘£)) long cwd-expression, yielding îˆ»(ğ‘š+ğ‘›) time in total. Furthermore, each vertex is at most once relabeled to 1 since once it is relabeled to 1, its label remains 1 for the rest of the algorithm. Therefore, the relabeling of vertices that are non-adjacent to a newly added vertex takes îˆ»(ğ‘›) time in total. To sum up, the algorithm outputs the construction in îˆ»(ğ‘›+ğ‘š) time. â—»

The combination of Theorems 18 and 20 gives us the following upper-bound that can be compared with the known upper-bound ğœ”(ğº)+1 [14, 26].

Theorem 21
Let G be a mixed unit interval graph. Then

ğ‘ğ‘¤ğ‘‘(ğº)â‰¤min{2ğ›¼(ğº)+3,ğœ‘îˆ®(ğº)+2}â‰¤ğœ”(ğº)+1,
where îˆ® is a î‰-bubble model for G. Moreover, the corresponding expression can be constructed in îˆ»(ğ‘›+ğ‘š) time provided îˆ® is given, otherwise in îˆ»(ğ‘›2) time.

Observe that ğœ‘îˆ®(ğº)â‰¤2max{ğ‘Ÿğ‘—âˆ£1â‰¤ğ‘—â‰¤ğ‘˜}. A combination of Theorem 21 and Lemma 17 gives a useful Corollary 22. In particular, if the number of rows or number of columns is bounded, than clique-width is bounded.

Corollary 22
Let G be a mixed unit interval graph. Then ğ‘ğ‘¤ğ‘‘(ğº)â‰¤min{ğ‘˜+3,2ğ‘Ÿ+2}, where k is the number of columns and r is the length of a longest column in a î‰-bubble model for G.

We note that by an application of Lemma 4.1 in [30], slightly worse bounds on clique-width in terms of rows and columns can also be derived. In particular, if we take two natural orderings of the bubbles in the î‰-bubble model, one taking rows first and the other taking columns first, we obtain two times larger multiplicative factor than in Corollary 22.

Conclusion
The main contribution of this work is a new representation of mixed unit interval graphsâ€”the î‰-bubble model. This structure is particularly useful in the design of algorithms and their analysis. Using the î‰-bubble model, we presented new upper-bounds for the clique-width of mixed unit interval graphs and designed a subexponential-time algorithm for the MaxCut problem on mixed unit interval graphs. We further realized that the state-of-the-art polynomial-time algorithm for the MaxCut problem on unit interval graphs is incorrect. A long-term task is to determine the difference between the time complexity of basic problems on unit interval graphs compared to interval graphs. In particular, on a more precise scale of mixed unit interval graphs, determine what is a key property for the change of the complexity. Independently, a long-standing open problem is the time complexity of the MaxCut problem on unit interval graphs, in particular, decide if it is NP-hard or polynomial-time solvable.

An interesting direction to pursue the first task could be the study of labeling problems; either ğ¿2,1-labeling or Packing Coloring. Both problems were motivated by assigning frequencies to transmitters. The ğ¿2,1-labeling problem was first introduced by Griggs and Yeh in 1992 [21]. The packing coloring problem is newer, it was introduced by Goddard et al. in 2008 [18]. Although, these are well-known problems, quite surprisingly, their time complexity is open for interval graphs.

The ğ¿2,1-labeling problem assigns labels {0,â€¦,ğ‘˜} to vertices such that the labels of neighboring vertices differ by at least two and the labels of vertices in distance two are different. The time complexity of this problem is still wide open even for unit interval graphs, despite partial progress on specific values for the largest used label. Sakai proved that the value of the largest label lies between 2ğœ’âˆ’2 and 2ğœ’ where ğœ’ is the chromatic number [39].

The packing coloring problem asks for an existence of such a mapping ğ‘:ğ‘‰â†’{1,â€¦,ğ‘š} that for all ğ‘¢â‰ ğ‘£ with ğ‘(ğ‘¢)=ğ‘(ğ‘£)=ğ‘– the distance between u and v is at least i. This problem is wide open on interval graphs. Recently, there was a small progress on unit interval graphs leading to an FPT algorithm (time ğ‘“(ğ‘˜)â‹…ğ‘›îˆ»(1) for some computable function f and parameter k). It is shown in [27] that the packing coloring problem is in FPT parameterized by the size of a maximum clique. We note that the algorithm can be straightforwardly extended to mixed unit interval graphs. However, a polynomial-time algorithm or alternatively NP-hardness for (unit) interval graphs is of a much bigger interest.