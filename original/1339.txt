Interval graphs, intersection graphs of segments on a real line (intervals), play a key role in the study of algorithms and special structural properties. Unit interval graphs, their proper subclass, where each interval has a unit length, has also been extensively studied. We study mixed unit interval graphs—a generalization of unit interval graphs where each interval has still a unit length, but intervals of more than one type (open, closed, semi-closed) are allowed. This small modification captures a richer class of graphs. In particular, mixed unit interval graphs may contain a claw as an induced subgraph, as opposed to unit interval graphs. Heggernes, Meister, and Papadopoulos defined a representation of unit interval graphs called the bubble model which turned out to be useful in algorithm design. We extend this model to the class of mixed unit interval graphs and demonstrate the advantages of this generalized model by providing a subexponential-time algorithm for solving the MaxCut problem on mixed unit interval graphs. In addition, we derive a polynomial-time algorithm for certain subclasses of mixed unit interval graphs. We point out a substantial mistake in the proof of the polynomiality of the MaxCut problem on unit interval graphs by Boyacı et al. (Inf Process Lett 121:29–33, 2017. https://doi-org.ezproxy.auckland.ac.nz/10.1016/j.ipl.2017.01.007). Hence, the time complexity of this problem on unit interval graphs remains open. We further provide a better algorithmic upper-bound on the clique-width of mixed unit interval graphs.

Introduction
A graph G is an intersection graph if there exists a family of non-empty sets ={𝑆1,…,𝑆𝑛} such that for each vertex 𝑣𝑖 of G, a set 𝑆𝑖∈ is assigned in a way that there is the edge 𝑣𝑖𝑣𝑗 in G if and only if 𝑆𝑖∩𝑆𝑗≠∅. We say that G has an -intersection representation. Every graph can be represented as an intersection graph since per each vertex, we can use the set of its incident edges. However, many important graph classes can be described as intersection graphs of a restricted family of sets. Depending on the geometrical representation, different types of intersection graphs are defined, for instance, interval, circular-arc, disk graphs, etc. Interval graphs are intersection graphs of segments of the real line, called intervals. Such a representation is being referred to as interval representation. They have been a well known and widely studied class of graphs from both the theoretical and the algorithmic points of view since 1957. They were first mentioned independently in combinatorics (Hajos [10, 22]) and genetics (Benzer [3]).

Interval graphs have a nice structure, they are chordal and, therefore, also perfect which provides a variety of graph decompositions and models. Such properties are often useful tools for the algorithm design—the most common algorithms on them are based on dynamic programming. Therefore, many classical 𝖭𝖯-hard problems are polynomial-time solvable on interval graphs, for instance Hamiltonian cycle (Keil [31]), Graph isomorphism (Booth [6]) or Colorability (Golumbic [19]) are solvable even in linear time. Surprisingly, the complexity of some well-studied problems is still unknown despite extensive research, e.g. the 𝐿2,1-labeling problem, or the packing coloring problem.

Interval graphs have many real applications in diverse areas including genetics [3], economics, and archaeology [37, 38]. According to Golumbic [19], many real-world applications involve solving problems on graphs which are either interval graphs themselves or are related to interval graphs in a natural way. An important subclass of interval graphs is the class of proper interval graphs, graphs which can be represented by such an interval representation that no interval properly contains another one. Another interval representation is a representation with intervals of only unit lengths, graphs which have such a representation are called unit interval graphs. Roberts proved in 1969 [36] that a graph is a proper interval graph if and only if it is a unit interval graph. Later, Gardi came up with a constructive combinatorial proof [17].

The mentioned results do not specifically care about what types of intervals (open, closed, semi-closed) are used in the interval representation. However, as far as there are no restrictions on lengths of intervals, it does not matter which types of intervals are used [40]. The same applies if there is only one type of interval in the interval representation. However, this is not true when all intervals in the interval representation have unit length and at least two types of intervals are used. In particular, the claw 𝐾1,3 can be represented using one open interval and three closed unit intervals whereas it cannot be represented with unit intervals of the same type.

Recently, it has been observed that a restriction on different types of intervals in the unit interval representation leads to several new subclasses of interval graphs. We denote the set of all open, closed, open-closed, and closed-open intervals of unit length by −−, ++, −+, and +−, respectively. Let  be the set of all types of unit intervals. Although there are 16 different combinations of types of unit intervals, it was shown in [13, 25, 35, 40, 41] in the years 2012–2018 that they form only four different classes of mixed unit interval graphs. In particular, the following holds:

∅⊊unit interval⊊unit open and closed interval⊊semi-mixed unit interval⊊mixed unit interval⊊interval graphs,
where unit open and closed interval graphs have (++∪−−)-intersection representation, semi-mixed unit interval graphs have (++∪−−∪−+)-intersection representation, and mixed unit interval graphs have -intersection representation. Hence, mixed unit interval graphs allow all types of intervals of unit length.

Definition 1
A graph G is a mixed unit interval graph if it has a -intersection representation. We call such representation a mixed unit interval representation.

There are lots of characterizations of interval and unit interval graphs. Among many of the characterizations, we single out a matrix-like representation called bubble model [23]. A similar notion was independently discovered by Lozin [30] under the name canonical partition. In the bubble model, vertices of a unit interval graph G are placed into a “matrix” where each matrix entry may contain any number (possibly zero) of vertices. Edges of G are represented implicitly with the following conditions: each column forms a clique; and in addition, edges are only between consecutive columns where they form nested neighborhood (two vertices u and v from consecutive columns are adjacent if and only if v occurs in a higher row than u). In particular, there are no edges between non-consecutive columns. This representation can be computed in linear time given a proper interval ordering representation.

We introduce a similar representation of mixed unit interval graphs, called -bubble model, and we extend some results from unit interval graphs to mixed unit interval graphs using this representation. The representation has almost the same structure as the original bubble model, except that edges are allowed in the same row under specific conditions. We show that a graph is mixed unit interval graph if and only if it can be represented by a -bubble model.

Theorem 1
A graph is a mixed unit interval graph if and only if it has a -bubble model. Moreover, given a mixed unit interval representation of graph G on n vertices, a -bubble model can be constructed in (𝑛) time.

In addition, we show properties of our model, such as the relation of the size of a maximum independent set or maximum clique, and the size of the model, see Sect. 2.6.

Given a graph G, the MaxCut problem is the problem of finding a partition of the vertices of G into two sets S and 𝑆⎯⎯⎯⎯ such that the number of edges with one endpoint in S and the other one in 𝑆⎯⎯⎯⎯ is maximum among all partitions. There were two results about polynomiality of the MaxCut problem in unit interval graphs in the past years; the first one by Bodlaender et al. in 1999 [5], the second one by Boyacı et al. which has been published in 2017  [7]. The result of the first paper was disproved by authors themselves a few years later [4]. In the second paper, the authors used a bubble model for proving the polynomiality. However, we realized that this algorithm is also incorrect. Moreover, it seems to us to be hardly repairable. We provide further discussion and also a concrete example, in Sect. 3.2. The complexity of the MaxCut problem in interval graphs was surprisingly unknown for a long time. Interestingly, a result about 𝖭𝖯-completeness by Adhikary et al. has appeared on arXiv [1] very recentlyFootnote1.

Using the -bubble model, we obtain at least a subexponential-time algorithm for MaxCut in mixed unit interval graphs. We are not aware of any subexponential algorithms on interval graphs. In general graphs, there has been extensive research dedicated to approximation of MaxCut in subexponential time, see e.g. [2] or [24]. Furthermore, we obtain a polynomial-time algorithm if the given graph has a -bubble model with a constant number of columns. This extends a result by Boyacı et al. [8] who showed a polynomial-time algorithm for MaxCut on unit interval graphs which have a bubble model with two columns (also called co-bipartite chain graphs). The question of whether the MaxCut problem is polynomial-time solvable or 𝖭𝖯-hard in unit interval graphs still remains open.

Theorem 2
Let G be a mixed unit interval graph. A maximum cardinality cut can be found in time 𝑛(1)2𝑛√(log𝑛+2).

From the proof of Theorem 2, we derive the following corollary.

Corollary 3
The size of a maximum cut in the graph class defined by -bubble models with k columns can be determined in time (𝑛𝑘+5). Moreover, for 𝑘=2 in time (𝑛5).

The third part of the paper is devoted to clique-width, one of the graph parameters that is used to measure the complexity of a graph. Many 𝖭𝖯-hard problems can be solved efficiently on graphs with bounded clique-width [11]. In general, it is 𝖭𝖯-complete to decide if the graph has clique-width at most k for a given number k, see [15].

Unit interval graphs are known to have unbounded clique-width [20]. It follows from results by Fellows et al. [14], and Kaplan and Shamir [26] that the clique-width of (mixed) unit interval graphs is upper-bounded by 𝜔 (the maximum size of their clique) + 1. Heggernes et al.  [23] improved this result for unit interval graphs using the bubble model. There, the clique-width is upper-bounded by a minimum of 𝛼 (the maximum size of an independent set) + 1, and a parameter related to the bubble model representation which is in the worst case 𝜔+1. We use similar ideas to extend these bounds to mixed unit interval graphs using the -bubble model. In particular, we obtain that the upper-bound on clique-width is the minimum of the analogously defined parameter for a -bubble model and 2𝛼+3. The upper-bound is still in the worst case 𝜔+1. The upper-bound can be also expressed in the number of rows or columns of -bubble model. Refer to Theorem 21 and Corollary 22 in Sect. 4 for further details. As a consequence, we obtain an analogous result to Corollary 3 for rows using the following result. Fomin et al. [16] showed that the MaxCut problem can be solved in time (𝑛2𝑡+(1)) where t is clique-width of the input graph. By the combination of their result and our upper-bounds on clique-width (Theorem 21 in Sect. 4) we derive not only polynomial-time algorithm when the number of columns is bounded (with worse running time than Corollary 3) but also a polynomial-time algorithm when the number of rows is bounded, formulated as Corollary 4Footnote2. Moreover, the above combination provides an alternative proof of Theorem 2 with slightly worse running-time; see Remark 1 in Sect. 3.3 for more details.

Corollary 4
The size of a maximum cut in the graph class defined by -bubble models with k rows can be determined in time (𝑛4𝑘+(1)).

Preliminaries and Notation
By a graph we mean a finite, undirected graph without loops and multiedges. Let G be a graph. We denote by V(G) and E(G) the vertex and edge set of G, respectively; with 𝑛=|𝑉(𝐺)| and 𝑚=|𝐸(𝐺)|. Let 𝛼(𝐺) and 𝜔(𝐺) denote the maximum size of an independent set of G and the maximum size of a clique in G, respectively. Let 𝑢,𝑣∈𝑉(𝐺) be two adjacent vertices, we say that u, v are twins if they have the same neighborhood in G. By a family we mean a multiset {𝑆1,…,𝑆𝑛}, i.e., it allows the possibility that 𝑆𝑖=𝑆𝑗 even though 𝑖≠𝑗.

Let 𝑥,𝑦∈ℝ be real numbers. We call the set {𝑧∈ℝ:𝑥≤𝑧≤𝑦} closed interval [x, y], the set {𝑧∈ℝ:𝑥<𝑧<𝑦} open interval (x, y), the set {𝑧∈ℝ:𝑥<𝑧≤𝑦} open-closed interval (x, y], and the set {𝑧∈ℝ:𝑥≤𝑧<𝑦} closed-open interval [x, y). By semi-closed interval we mean interval which is open-closed or closed-open. We denote the set of all open, closed, open-closed, and closed-open intervals of unit length by −−, ++, −+, and +−, respectively. Formally, ++:={[𝑥,𝑥+1]:𝑥∈ℝ}, −−:={(𝑥,𝑥+1):𝑥∈ℝ}, +−:={[𝑥,𝑥+1):𝑥∈ℝ}, and −+:={(𝑥,𝑥+1]:𝑥∈ℝ}. We further denote the set of all unit intervals by

:=++∪−−∪+−∪−+.
From now on, we will be speaking only about unit intervals.

Let I be an interval, we define the left and right end of I as ℓ(𝐼):=inf(𝐼) and 𝑟(𝐼):=sup(𝐼), respectively. Let 𝐼,𝐽∈ be unit intervals, I, J are almost-twins if ℓ(𝐼)=ℓ(𝐽). The type of an interval I is a pair (r, s) where 𝐼∈𝑟,𝑠,𝑟,𝑠∈{+,−}.

Let 𝐺=(𝑉,𝐸) be a graph and  an interval representation of G. Let 𝑣∈𝑉 be represented by an interval 𝐼𝑣∈𝑟,𝑠, where 𝑟,𝑠∈{+,−}, in . The type of a vertex 𝑣∈𝑉 in , denoted by type(𝑣), is the pair (r, s). We use type(𝑣) if it is clear which interval representation we have in mind. We follow the standard approach where the maximum over the empty set is −∞. The notion of ̃  denotes the standard  which ignores polylogarithmic factors, i.e, (𝑓(𝑛)log𝑘𝑛)=̃ (𝑓(𝑛)), where k is a constant.

Recognition and -Intersection Representation of Mixed Unit Interval Graphs
All the classes of mixed unit interval graphs can be characterized using forbidden induced subgraphs, sometimes by infinitely many. Rautenbach and Szwarcfiter [35] gave a characterization of unit open and closed interval graphs using five forbidden induced subgraphs. Joos [25] gave a characterization of mixed unit interval graphs without twins by an infinite class of forbidden induced subgraphs. Shuchat et al. [40] proved independently also this characterization, moreover, they complemented it by a quadratic-time algorithm that produces a mixed proper interval representation. Finally, Kratochvíl and Talon [41] characterized the remaining classes.

Le and Rautenbach [29] characterized graphs that have a mixed unit interval representations in which all intervals have integer endpoints, and provided a quadratic-time algorithm that decides whether a given interval graph admits such a representation. We refer the reader to the original papers for more details and concrete forbidden subgraphs. More structural results can be found in [41].

Theorem 5
([41]) The classes of semi-mixed and mixed unit interval graphs can be recognized in time (𝑛2). Moreover, there exists an algorithm which takes a semi-mixed interval graph G on input, and outputs a corresponding (++∪−−)-intersection representation of G in time (𝑛2).

Corollary 6
([41]). It is possible to modify the algorithm for semi-mixed unit interval graphs such that given a mixed unit interval graph G, it outputs a mixed unit interval representation of G in time (𝑛2).

Bubble Model for Mixed Unit Interval Graphs
In this section, we present a -bubble model, a new representation of mixed unit interval graphs which is inspired by the notion of bubble model for proper interval graphs created by Heggernes et al. [23] in 2009.

Definition of Bubble Model
First, we present the bubble model for proper interval graphs as it was introduced by Heggernes et al.

Definition 2
(Heggernes et al. [23], reformulated). If A is a finite non-empty set, then a 2-dimensional bubble structure for A is a partition =⟨𝐵𝑖,𝑗⟩1≤𝑗≤𝑘,1≤𝑖≤𝑟𝑗, where 𝐴=⋃𝑖,𝑗𝐵𝑖,𝑗, ∅⊆𝐵𝑖,𝑗⊆𝐴 for every i, j with 1≤𝑗≤𝑘 and 1≤𝑖≤𝑟𝑗, and 𝐵1,1…𝐵𝑟𝑘,𝑘 are pairwise disjoint. The graph given by , denoted as 𝐺(), is defined as follows:

1.
the vertex set of 𝐺() is A, and

2.
uv is an edge of 𝐺() if and only if there are indices 𝑖,𝑖′,𝑗,𝑗′ such that 𝑢∈𝐵𝑖,𝑗, 𝑣∈𝐵𝑖′,𝑗′, |𝑗−𝑗′|≤1, and one of the two conditions holds: either 𝑗=𝑗′ or (𝑖−𝑖′)(𝑗−𝑗′)<0.

A bubble model for a graph 𝐺=(𝑉,𝐸) is a 2-dimensional bubble structure  for V such that 𝐺=𝐺().

Theorem 7
(Heggernes et al. [23]). A graph is proper interval if and only if it has a bubble model.

We define a similar matrix-type structure for mixed unit interval graphs where each set 𝐵𝑖,𝑗 is split into four parts and edges are allowed also in the same row under specific conditions.

Definition 3
Let A be a finite non-empty set and =⟨𝐵𝑖,𝑗⟩1≤𝑗≤𝑘,1≤𝑖≤𝑟𝑗 be a 2-dimensional bubble structure for A such that 𝐵𝑖,𝑗=𝐵++𝑖,𝑗∪𝐵+−𝑖,𝑗∪𝐵−+𝑖,𝑗∪𝐵−−𝑖,𝑗, 𝐵𝑟,𝑠𝑖,𝑗 are pairwise disjoint, and ∅⊆𝐵𝑟,𝑠𝑖,𝑗⊆𝐵𝑖,𝑗 for every 𝑟,𝑠∈{+,−} and i, j with 1≤𝑗≤𝑘 and 1≤𝑖≤𝑟𝑗. We call the partition  a 2-dimensional -bubble structure for A.

We call each set 𝐵𝑖,𝑗 a bubble, and each set 𝐵𝑟,𝑠𝑖,𝑗,𝑟,𝑠∈{+,−}, a quadrant of the bubble 𝐵𝑖,𝑗. The type of a quadrant 𝐵𝑟,𝑠𝑖,𝑗, 𝑟,𝑠∈{+,−}, is the pair (r, s). We denote by ∗ both + and −, for example 𝐵∗+𝑖,𝑗=𝐵−+𝑖,𝑗∪𝐵++𝑖,𝑗. Bubbles with the same i-index form a row of , and with the same j-index a column of , we say vertices from bubbles 𝐵𝑖,1∪⋯∪𝐵𝑖,𝑘 appear in row i, and we denote i as their row-index. We define an analogous notion for columns. We denote the index of the first row with a non-empty bubble as top(𝑗):=min{𝑖∣𝐵𝑖,𝑗∈ and 𝐵𝑖𝑗≠∅}. Thus, 𝐵top(𝑗),𝑗 is the first non-empty bubble in the column j. Let B be a bubble, then row(𝐵) and col(𝐵) is the row-index and column-index of B, respectively. Let 𝑢∈𝐵𝑖,𝑗, 𝑣∈𝐵𝑖′,𝑗′; we say that u is under v and v is above u if 𝑖>𝑖′.

Fig. 1
figure 1
Different representations of a mixed unit interval graph G

Full size image
Definition 4
Let =⟨𝐵𝑖,𝑗⟩1≤𝑗≤𝑘,1≤𝑖≤𝑟𝑗 be a 2-dimensional -bubble structure for A. The graph given by , denoted as 𝐺(), is defined as follows:

1.
𝑉(𝐺())=𝐴,

2.
uv is an edge of 𝐺() if and only if there are indices 𝑖,𝑖′,𝑗,𝑗′ such that 𝑢∈𝐵𝑖,𝑗, 𝑣∈𝐵𝑖′,𝑗′, or 𝑣∈𝐵𝑖,𝑗, 𝑢∈𝐵𝑖′,𝑗′, and one of the three conditions holds:

(a)
𝑗=𝑗′, or

(b)
𝑗=𝑗′−1 and 𝑖>𝑖′, or

(c)
𝑗=𝑗′−1 and 𝑖=𝑖′ and 𝑢∈𝐵∗+𝑖,𝑗,𝑣∈𝐵+∗𝑖′,𝑗′.

The definition says that the edges are only between vertices from the same or consecutive columns and if 𝑢∈𝐵𝑖,𝑗 and 𝑣∈𝐵𝑖′,𝑗+1, there is an edge between u and v if and only if u is under v (𝑖>𝑖′), or they are in the same row and 𝑢∈𝐵∗+𝑖,𝑗,𝑣∈𝐵+∗𝑖′,𝑗+1.

Observation 8
Vertices from the same column in 𝐺() form a clique. Moreover, the neighborhoods of vertices from the same bubble can differ only in the same row, and vertices from the same bubble quadrant are twins.

Definition 5
Let 𝐺=(𝑉,𝐸) be a graph. A -bubble model for a graph G is a 2-dimensional -bubble structure =⟨𝐵𝑖,𝑗⟩1≤𝑗≤𝑘,1≤𝑖≤𝑟𝑗 for V such that

(i)
G is isomorphic to 𝐺(), and

(ii)
each column and each row contains a non-empty bubble, and

(iii)
no column ends with an empty bubble, and

(iv)
top(1)=1, and for every 𝑗∈{1,…,𝑘−1}:top(𝑗)≤top(𝑗+1).

For a -bubble model =⟨𝐵𝑖,𝑗⟩1≤𝑗≤𝑘,1≤𝑖≤𝑟𝑗, by the number of rows of  we mean max{𝑟𝑗∣1≤𝑗≤𝑘}. We define the size of the -bubble model  as the number of columns multiplied by the number of rows, i.e., 𝑘⋅max{𝑟𝑗∣1≤𝑗≤𝑘}.

See Fig. 1 with an example of a mixed unit interval graph, given by a mixed unit interval representation, and by a -bubble model.

Construction of -Bubble Model
First, we construct a mixed unit interval representation  of a mixed unit interval graph G using the quadratic-time algorithm, see Corollary 6; then each vertex of G is represented by a corresponding interval in . Having a mixed unit interval representation of the graph, our algorithm outputs a -bubble model for the graph in (𝑛) time.

We now describe the creation of bubbles. Given a mixed unit interval representation , all the vertices that are represented by almost-twins in  form a single bubble where they belong to the particular quadrants according to the type of their corresponding intervals in . We denote the set of all bubbles by ℬ. From now on, we speak about bubbles only. We are going to determine their place (row and column) to create a 2-dimensional -bubble structure for ℬ. We show that the -bubble structure is a -bubble model for our graph. Based on the order 𝜎 by endpoints of intervals in the representation  from left to right, we obtain the same order on bubbles in ℬ. In line with that, we denote ℓ(𝐵):=ℓ(𝐼𝑣) and 𝑟(𝐵):=𝑟(𝐼𝑣) for a bubble 𝐵∈ℬ and an interval 𝐼𝑣∈ corresponding to 𝑣∈𝐵 (note that it is well-defined as every bubble contains only vertices which are represented by almost-twins in ). The idea of the algorithm is to process the bubbles in the order 𝜎, and assign to each bubble its column immediately after processing it. During the processing, the algorithm maintains an auxiliary path in order to assign rows at the end. Thus, rows are assigned to each bubble after all bubbles are processed.

For bubbles 𝐴,𝐵∈ℬ, 𝐴<𝜎𝐵 denotes that A is smaller than B in order 𝜎. For technical reasons, we create two new bubbles: 𝐵𝑠𝑡𝑎𝑟𝑡, 𝐵𝑒𝑛𝑑 such that ℓ(𝐵𝑠𝑡𝑎𝑟𝑡)=𝑟(𝐵𝑠𝑡𝑎𝑟𝑡)=−∞ and ℓ(𝐵𝑒𝑛𝑑)=𝑟(𝐵𝑒𝑛𝑑)=∞. We refer to them as auxiliary bubbles, in particular, if we speak about bubbles, we exclude auxiliary bubbles (also 𝐵𝑠𝑡𝑎𝑟𝑡, 𝐵𝑒𝑛𝑑∉ℬ). We enhance the representation in a way that each bubble 𝐵∈ℬ has a pointer 𝑝𝑟𝑒𝑣:ℬ→ℬ∪{𝐵𝑠𝑡𝑎𝑟𝑡} defined as follows.

𝑝𝑟𝑒𝑣(𝐵)={𝐵𝑠𝑡𝑎𝑟𝑡max𝜎{𝐴∈ℬ∣ℓ(𝐵)≥𝑟(𝐴)}if ℓ(𝐵)<𝑟(min𝜎ℬ),otherwise.
In order to set rows at the end, the algorithm is creating a single oriented path P that has the information about the height of elements in the -bubble structure being constructed. Some of the arcs of the path can be marked with level indicator (𝖫). Intuitively, a consecutive level indicators create a row. For ease of notation, we use 𝑛𝑒𝑥𝑡𝑃(𝐵𝑖)=𝐵𝑗 to say that 𝐵𝑗 is the next element on path P after 𝐵𝑖. We note that we can view P as an order of bubbles; we denote by 𝐴<𝑃𝐵, 𝐴,𝐵∈ℬ, the information that A occurs earlier than B on P. Also from technical reasons, P starts and ends with 𝐵𝑠𝑡𝑎𝑟𝑡 and 𝐵𝑒𝑛𝑑, respectively. Except P and pointers 𝑝𝑟𝑒𝑣 and 𝑛𝑒𝑥𝑡𝑃, the algorithm remembers the highest bubble of column i, denoted by 𝐶𝗍𝗈𝗉𝑖. Also, denote by 𝖼𝗎𝗋𝗋, the index of the currently processed column.

Now, we are able to state the algorithm for assigning columns and rows to bubbles in ℬ and its properties (which are discussed in the Correctness section but are also straightforward to verify while reading the algorithm).

Property 1::
Bubbles are processed (and therefore added somewhere to P) one by one respecting the order 𝜎.

Property 2::
The order induced by P of already processed vertices never changes, i.e., once 𝐴≤𝑃𝐵 then 𝐴≤𝑃𝐵 for the rest of the algorithm.

Property 3::
The arc of P between bubbles A and B has the level indicator (𝖫) if and only if 𝑟(𝐴)=ℓ(𝐵). Moreover, if the arc from A to B has level indicator, then col(𝐴)<col(𝐵).

Property 4::
col(𝐴)≤col(𝐵) whenever 𝐴≤𝜎𝐵.

Property 5::
𝑝𝑟𝑒𝑣(𝐵) is the closest ancestor of B on P in the previous column, i.e., 𝑝𝑟𝑒𝑣(𝐵)=max{𝐴∣𝐴≤𝑃𝐵,col(𝐴)=col(𝐵)−1}.

Property 6::
The order induced by P of vertices in the same column is exactly the order of those vertices induced by 𝜎.

Algorithm
Given bubbles in ℬ ordered by 𝜎, the algorithm creates P by processing bubbles one by one in order 𝜎. For the purpose of the algorithm description, we denote the order 𝜎 of bubbles in ℬ by subscripts, i.e., 𝐵1<𝜎𝐵2<𝜎… are all bubbles in ℬ in the described order 𝜎 (do not confuse with the notation 𝐵𝑖,𝑗 where subscripts denote the row and column). See Fig. 2 for an example of a step of the algorithm. The algorithm outputs a row and a column to each bubble. Initially, set col(𝐵1)=1, 𝑃=(𝐵𝑠𝑡𝑎𝑟𝑡,𝐵1,𝐵𝑒𝑛𝑑), 𝖼𝗎𝗋𝗋 =1 and 𝐶𝗍𝗈𝗉1=𝐵1.

Suppose that 𝑖−1 bubbles have been already processed, for 𝑖≥2. Split the cases of processing bubble 𝐵𝑖 based on the following possibilities:

i.
ℓ(𝐵𝑖)>𝑟(𝐶𝗍𝗈𝗉𝖼𝗎𝗋𝗋): First increase 𝖼𝗎𝗋𝗋 by one, then set col(𝐵𝑖)=𝖼𝗎𝗋𝗋 and 𝐶𝗍𝗈𝗉𝖼𝗎𝗋𝗋=𝐵𝑖.

ii.
ℓ(𝐵𝑖)=𝑟(𝐶𝗍𝗈𝗉𝖼𝗎𝗋𝗋): First increase 𝖼𝗎𝗋𝗋 by one, then set col(𝐵𝑖)=𝖼𝗎𝗋𝗋 and 𝐶𝗍𝗈𝗉𝖼𝗎𝗋𝗋=𝐵𝑖. Let Q be 𝑛𝑒𝑥𝑡𝑃(𝐶𝗍𝗈𝗉𝖼𝗎𝗋𝗋−1). Substitute arc in P from 𝐶𝗍𝗈𝗉𝖼𝗎𝗋𝗋−1 to Q with two new arcs 𝐶𝗍𝗈𝗉𝖼𝗎𝗋𝗋−1 to 𝐵𝑖 that has 𝖫 indicator set and from 𝐵𝑖 to Q.

iii.
ℓ(𝐵𝑖)<𝑟(𝐶𝗍𝗈𝗉𝖼𝗎𝗋𝗋): Set col(𝐵𝑖)=𝖼𝗎𝗋𝗋.

We continue only with cases i. and iii. and distinguish multiple possibilities:

1.
𝑟(𝑝𝑟𝑒𝑣(𝐵𝑖))=ℓ(𝐵𝑖): Let Q be 𝑛𝑒𝑥𝑡𝑃(𝑝𝑟𝑒𝑣(𝐵𝑖)). Then substitute arc in P from 𝑝𝑟𝑒𝑣(𝐵𝑖) to Q with two new arcs 𝑝𝑟𝑒𝑣(𝐵𝑖) to 𝐵𝑖 that has 𝖫 indicator set and from 𝐵𝑖 to Q.

2.
𝑟(𝑝𝑟𝑒𝑣(𝐵𝑖))<ℓ(𝐵𝑖): Split this case further based on the properties of 𝐵𝑖−1.

2a.
𝑝𝑟𝑒𝑣(𝐵𝑖−1)=𝑝𝑟𝑒𝑣(𝐵𝑖): Let Q be 𝑛𝑒𝑥𝑡𝑃(𝐵𝑖−1). Substitute arc in P from 𝐵𝑖−1 to Q with two new arcs 𝐵𝑖−1 to 𝐵𝑖 and from 𝐵𝑖 to Q.

2b.
𝑝𝑟𝑒𝑣(𝐵𝑖−1)≠𝑝𝑟𝑒𝑣(𝐵𝑖): Let Q be 𝑛𝑒𝑥𝑡𝑃(𝑝𝑟𝑒𝑣(𝐵𝑖)). Then substitute arc in P from 𝑝𝑟𝑒𝑣(𝐵𝑖) to Q with two new arcs 𝑝𝑟𝑒𝑣(𝐵𝑖) to 𝐵𝑖 and from 𝐵𝑖 to Q.

After processing all the bubbles in ℬ, assign rows to bubbles by a single run over P, inductively: Take the first bubble B of P and assign row(𝐵):=1. Let B be the last bubble on P with already set row index. We are about to determine row(𝑛𝑒𝑥𝑡𝑃(𝐵)). If arc in P from B to 𝑛𝑒𝑥𝑡𝑃(𝐵) has 𝖫 indicator, set row(𝑛𝑒𝑥𝑡𝑃(𝐵)):=row(𝐵), otherwise row(𝑛𝑒𝑥𝑡𝑃(𝐵)):=row(𝐵)+1.

Fig. 2
figure 2
An example of an input and one step of the construction algorithm

Full size image
Fig. 3
figure 3
A maximum clique of G in a -bubble model. Dark gray color represents the bubbles that are fully contained in the clique. Light gray color highlights two bubbles where only parts of them are contained in the clique, concretely the one of the sets 𝐵𝑖,𝑗,𝐵𝑖,𝑗+1, and 𝐵∗+𝑖,𝑗∪𝐵+∗𝑖,𝑗+1 with the maximum size

Full size image
Correctness
Here, we show that the algorithm above gives us a -bubble model for a graph given by mixed unit interval representation. It gives us the forward implication of Theorem 1.

Lemma 9
Given a mixed unit interval representation  of a connected graph G on n vertices, a -bubble model for G can be constructed in (𝑛) time.

Proof of Lemma 9
We show the correctness of the construction, i.e., that the constructed object satisfies Definition 5 and that declared Properties 1–6 are satisfied during the whole algorithm. Let ℬ be the set of bubbles created from  as in Sect. 2.2. It follows immediately from the construction that Properties 1–4 are satisfied. Observe that 𝑝𝑟𝑒𝑣(𝐵) is always in the previous column than B, for 𝐵∈ℬ. Moreover, observe that in step ii. of the algorithm, 𝐶𝗍𝗈𝗉col(𝐵)−1=𝑝𝑟𝑒𝑣(𝐵),𝐵∈ℬ. Then, Property 5 follows from the construction. Property 6 can be seen by examining the construction. Let 𝐴,𝐵∈ℬ be two bubbles in the same column such that 𝐴<𝜎𝐵. Either 𝑝𝑟𝑒𝑣(𝐴)=𝑝𝑟𝑒𝑣(𝐵), then B is put later than A on P. Or 𝑝𝑟𝑒𝑣(𝐴)<𝜎𝑝𝑟𝑒𝑣(𝐵), then, by the construction, 𝑝𝑟𝑒𝑣(𝐵) is put after A and B is put after 𝑝𝑟𝑒𝑣(𝐵). In both cases, 𝐴<𝑃𝐵. Using Property 2, the Property 6 holds.

It is readily seen that the algorithm outputs a 2-dimensional -bubble structure for the vertex set of G. Let  denote the -bubble structure and 𝐺() denote the graph given by . We want to show that  is a -bubble model for G. Parts (ii), (iii) from Definition 5 are clearly satisfied. It remains to show (i) and (iv).

Let us start with (i), that is, 𝐺() is isomorphic to G. Let 𝑢∈𝐴, 𝑣∈𝐵, where A, B are bubbles in 𝐺(). Recall from the construction of ℬ that u and v are represented by almost-twins in  if and only if 𝐴=𝐵. The former implies that u and v are adjacent in G, the latter implies that u and v are adjacent in 𝐺(). Since the case of 𝐴=𝐵 is trivially satisfied, without loss of generality, we assume 𝐴<𝜎𝐵. We distinguish a few cases based on the position of A and B in .

First, let A and B be in non-consecutive columns in . Denote by 𝑐=col(𝐴). By Definition 4, u and v are non-adjacent in 𝐺(). By the construction, there exists a non-empty bubble 𝐶𝗍𝗈𝗉𝑐+1 in  such that it is the top bubble of column 𝑐+1. It follows that 𝐶𝗍𝗈𝗉𝑐+1>𝜎𝐴, by Property 4, and also 𝐶𝗍𝗈𝗉𝑐+1≠𝐴. Since the construction assigns B to a different column than 𝐶𝗍𝗈𝗉𝑐+1, we know that 𝑟(𝐶𝗍𝗈𝗉𝑐+1)≤ℓ(𝐵). It gives immediate conclusion that u, v are not adjacent in G.

Second, let A and B be in the same column c in . Vertices u, v are adjacent in 𝐺() by Definition 4. By the construction, there exists a non-empty bubble 𝐶𝗍𝗈𝗉𝑐 in  such that it is the top bubble in column c and ℓ(𝐶𝗍𝗈𝗉𝑐)≤ℓ(𝐴)<ℓ(𝐵)<𝑟(𝐶𝗍𝗈𝗉𝑐)=1+ℓ(𝐶𝗍𝗈𝗉𝑐). Therefore, u, v are adjacent in G.

Third, let A and B appear in consecutive columns in . We denote 𝑐=col(𝐴)=col(𝐵)−1. By Definition 4, vertices u, v are adjacent in 𝐺() if and only if either row(𝐴)>row(𝐵), or row(𝐴)=row(𝐵) and 𝑢∈𝐴∗+,𝑣∈𝐵+∗. By Properties 1 and 2 of P, it is sufficient to verify only the situation when bubble B was added. Observe that if 𝐵′<𝑃𝐵″ then row(𝐵′)≤row(𝐵″). We split the case into the following all possibilities:

𝑝𝑟𝑒𝑣(𝐵)>𝜎𝐴: By the definition of 𝑝𝑟𝑒𝑣 and the interval property, u is non-adjacent to v in G and 𝑟(𝐴)≠ℓ(𝐵). By Property 6, 𝐴<𝑃𝑝𝑟𝑒𝑣(𝐵). By Property 5, 𝑝𝑟𝑒𝑣(𝐵)<𝑃𝐵. As 𝐴<𝑃𝐵, row(𝐴)≤row(𝐵). By Property 3, row(𝐴)<row(𝐵). Therefore, u, v are non-adjacent in 𝐺().

𝑝𝑟𝑒𝑣(𝐵)=𝐴: By Properties 3, 5 and the rows assignment, row(𝐵)=row(𝐴) if and only if ℓ(𝐵)=𝑟(𝐴). Therefore, there is an edge in both models if and only if u and v are of correct types; that is, u has a type (∗,+) and v has a type (+,∗).

𝑝𝑟𝑒𝑣(𝐵)<𝜎𝐴: By the definition of 𝑝𝑟𝑒𝑣 and the interval property, u is adjacent to v in G and 𝑟(𝐴)>ℓ(𝐵). By Property 6, 𝑝𝑟𝑒𝑣(𝐵)<𝑃𝐴, therefore, row(𝑝𝑟𝑒𝑣(𝐵)≤row(𝐴)). By Property 5, row(𝐴)≥row(𝐵). By Property 3, the equality cannot occur. Therefore, row(𝐴)>row(𝐵).

Indeed, 𝐺() is isomorphic to G.

Part (iv) follows by the construction of P. When 𝐵=𝐶𝗍𝗈𝗉𝑗,𝑗≥2 is added on P, by Property 5, 𝑝𝑟𝑒𝑣(𝐵)<𝑃𝐵. We note that 𝐶𝗍𝗈𝗉𝑗−1≤𝑃𝑝𝑟𝑒𝑣(𝐵). We obtain row(𝐶𝗍𝗈𝗉𝑗−1)≤row(𝐶𝗍𝗈𝗉𝑗) for every possible j. Also note that row(min𝜎ℬ)=row(𝐶𝗍𝗈𝗉1)=1.

It remains to show the running-time of the algorithm. We note that 𝑝𝑟𝑒𝑣 can be easily computed by a single run over the representation, as well as the assigning columns can be done simultaneously by a single run over the representation (having 𝑝𝑟𝑒𝑣 and remembering top bubbles of columns). Moreover, rows are assigned by a single run over path P which leads to overall running time (𝑛) where n is the number of intervals of the given mixed unit interval representation. ◻

Proof of Theorem 1
Proof of Theorem 1
First, we prove the reverse implication: given a -bubble model for a graph G, we construct a mixed unit interval representation of G. Let =⟨𝐵𝑖,𝑗⟩1≤𝑗≤𝑘,1≤𝑖≤𝑟𝑗 be a -bubble model of G. Let

𝜀:=1max{𝑟𝑗∣1≤𝑗≤𝑘}.
We create a mixed unit interval representation  of G as follows. Let 𝑣∈𝐵𝑟,𝑠𝑖,𝑗, where 𝑟,𝑠∈{+,−}. The corresponding interval 𝐼𝑣 of v has the properties:

𝐼𝑣∈𝑟,𝑠 and ℓ(𝐼𝑣):=𝑗+(𝑖−1)𝜀.
We note that all vertices from the same bubble are represented by intervals that are almost-twins and the type of an interval corresponds with the type of the bubble quadrant. Since 𝜀 was chosen such that 𝜀(𝑖−1)<1 for any row i in , the graph given by the constructed mixed unit interval representation is isomorphic to the graph given by . The forward implication follows from Lemma 9. ◻

Properties of -Bubble Model
In this section, we give basic properties of a -bubble model which are used later in the text. It is readily seen that a -bubble model of graph 𝐺=(𝑉,𝐸) has at most n rows and n columns where n is the number of vertices of G since each column and each row contains at least one vertex. Consequently, the size of a -bubble model is at most 𝑛2.

Two basic characteristics of a graph are the size of a maximum clique and the size of a maximum independent set in the graph. The problem of finding those numbers is 𝖭𝖯-complete in general but it is polynomial-time solvable in interval graphs. We show a relation between those two numbers and the size of a -bubble model for the graph. We start with the size of a maximum independent set.

Lemma 10
Let G be a mixed unit interval graph, and let  be a -bubble model for G. The number of columns of  is at least 𝛼(𝐺) and at most 2𝛼(𝐺).

Proof
Let I be a maximum independent set of G, and let k be the number of columns of . We have that 𝛼(𝐺)≥⌈𝑘/2⌉ from the property that two non-consecutive columns from  are not adjacent in 𝐺(). Since each column forms a clique, only one vertex from each column can be in I. Therefore, 𝛼(𝐺)≤𝑘. ◻

In the bubble model for unit interval graphs, 𝛼(𝐺) is equal to the number of columns [23]. However, the gap in Lemma 10 cannot be narrowed in general—consider an even number k and the following unit interval graphs: path on k-vertices (𝑃𝑘) and a clique on k vertices (𝐾𝑘). There exists a unit interval representation of 𝑃𝑘 using only closed intervals which leads to a -bubble model of 𝑃𝑘 containing one row and k columns, where 𝛼(𝑃𝑘)=⌈𝑘/2⌉. A -bubble model of 𝐾𝑘 contains k rows and one column, where 𝛼(𝐾𝑘)=1=number of columns.

Another important and useful property of graphs is the size of a maximum clique. We show that a maximum clique of a mixed unit interval graph can be found in two consecutive columns of a -bubble model of the graph, see Fig. 3.

Fig. 4
figure 4
A counterexample to the original algorithm, a bubble model  where the numbers denote the number of vertices in each bubble, and dashed lines indicate the edges between bubbles

Full size image
Lemma 11
Let G be a mixed unit interval graph, and let  be a -bubble model for G. Then the size of a maximum clique is

𝜔(𝐺)𝑎𝑖=max𝑗∈{1,…,𝑘−1}𝑖∈{1,…,𝑟𝑗+1}(∑𝑖′=𝑖+1𝑟𝑗|𝐵𝑖′,𝑗|+∑𝑖′=1𝑖−1|𝐵𝑖′,𝑗+1|+𝑎𝑖),={max{|𝐵𝑖,𝑗|,|𝐵𝑖,𝑗+1|,|𝐵∗+𝑖,𝑗|+|𝐵+∗𝑖,𝑗+1|}|𝐵𝑖,𝑗+1|𝑖≤𝑟𝑗,otherwise.
Proof
Let K be a maximum clique of G. Notice, K does not contain two vertices from non-consecutive columns, as there are no edges between non-consecutive columns. Furthermore, vertices u and v from two consecutive columns 𝐶𝑗 and 𝐶𝑗+1, respectively, can be in K only if u is under v or they are in the same row in quadrants of types {∗+} and {+∗}, respectively.

On the other hand, vertices from one column of  create a clique in 𝐺(). Moreover, if we split any two consecutive columns 𝐶𝑗 and 𝐶𝑗+1 in row i (for any index 𝑖∈{1,…,min{𝑟𝑗,𝑟𝑗+1}}), the second part of 𝐶𝑗 with the first part of 𝐶𝑗+1 form a clique. This is true even together with bubble quadrants 𝐵∗+𝑖,𝑗∪𝐵+∗𝑖,𝑗+1. ◻

Maximum Cardinality Cut
This section is devoted to the time complexity of the MaxCut problem on (mixed) unit interval graphs.

Notation
A cut of a graph G(V, E) is a partition of V(G) into two subsets 𝑆,𝑆¯, where 𝑆¯=𝑉(𝐺)∖𝑆. Since 𝑆¯ is the complement of S, we say for the brevity that a set S is a cut and similarly we use terms cut vertexFootnote3 and non-cut vertex for a vertex 𝑣∈𝑆 and 𝑣∈𝑆¯, respectively. The cut-set of cut S is the set of edges of G with exactly one endpoint in S, we denote it 𝐸(𝑆,𝑆¯). Then, the value |𝐸(𝑆,𝑆¯)| is the cut size of S. A maximum (cardinality) cut on G is a cut with the maximum size among all cuts on G. Finally, the MaxCut problem is the problem of determining the size of the maximum cut.

Time Complexity is Still Unknown on Unit Interval Graphs
As it was mentioned in the introduction, there is a paper A polynomial-time algorithm for the maximum cardinality cut problem in proper interval graphs by Boyacı et al. from 2017 [7], claiming that the MaxCut problem is polynomial-time solvable in unit interval graphs and giving a dynamic programming algorithm based on the bubble model representation. We realized that the algorithm is incorrect; this section is devoted to it.

We start with a counterexample to the original algorithm.

Example
Let =⟨𝐵𝑖,𝑗⟩1≤𝑗≤2,1≤𝑖≤2, where 𝐵1,1={𝑣1}, 𝐵2,1={𝑣2}, 𝐵1,2={𝑣3,𝑣4,𝑣5}, 𝐵2,2={𝑣6}, be a bubble model for a graph G, see also Fig. 4. In other words, this bubble model corresponds to a unit interval graph on vertices 𝑣1,𝑣2,𝑣3,𝑣4,𝑣5,𝑣6 where there is the edge 𝑣1𝑣2, and vertices 𝑣2,𝑣3,𝑣4,𝑣5,𝑣6 create a complete graph without the edge 𝑣2𝑣6.

Fig. 5
figure 5
A heavy part with light columns L and R and the highlighted subgraph 𝐺𝑖

Full size image
Then, according to the paper [7], the size of a maximum cut in G is eight. To be more concrete, the algorithm from [7] fills the following values of dynamic table: 𝐹0,1(0,0)=4, 𝐹2,1(1,1)=8 for 𝑠2,1=1,𝑠2,2=1, and finally, 𝐹0,0(0,0)=8 which is the output of the algorithm. However, the size of a maximum cut in G is only seven. Suppose, for contradiction, that the size of a maximum cut is eight. As there are ten edges in total in G, at least one vertex of the triangle 𝑣3,𝑣4,𝑣5 must be a cut-vertex and one not. Then, those two vertices have three common neighbors. Therefore, the size of a maximum cut is at most seven which is possible; for example, 𝑣1,𝑣4,𝑣5 are cut-vertices.

The brief idea of the algorithm in [7] is to process the columns from the biggest to the lowest column from the top bubble to the bottom one. Once we know the number of cut-vertices in the actual processed bubble B (in the column j) and the number of cut-vertices which are above B in the columns j and 𝑗+1, we can count the exact number of edges. For each bubble and each such number of cut-vertices in the columns j and 𝑗+1 (above the bubble), we remember only the best values of MaxCutFootnote4.

We claim that the algorithm and its full idea from [7] are incorrect since we lose the consistency there—to obtain a maximum cut, we do not remember anything about the distribution of cut vertices within bubbles, that was used in the previously processed column. Therefore, there is no guarantee that the final outputted cut of the computed size exists. To be more specific, one of two problems is in the moving from the column j to the column 𝑗−1 since we forget there too much. The second problem is that for each bubble 𝐵𝑖,𝑗 and for each possible numbers 𝑥,𝑥′ we count the size 𝐹𝑖,𝑗(𝑥,𝑥′) of a specific cut and we choose some values 𝑠𝑖,𝑗, 𝑠𝑖,𝑗+1 (possibly different; they represents the number of cut-vertices in the bubbles 𝐵𝑖,𝑗,𝐵𝑖,𝑗+1) which maximize the values of 𝐹𝑖,𝑗(𝑥,𝑥′). In few steps later, when we are processing the bubble 𝐵𝑖,𝑗−1, again, for each possible values y and 𝑦′ we choose some values 𝑠′𝑖,𝑗−1 and 𝑠′𝑖,𝑗 such that they maximize the size of 𝐹𝑖,𝑗−1(𝑦,𝑦′). However, we need to be consistent with the selection in the previous column, i.e., to guarantee that 𝑠𝑖′,𝑗=𝑠𝑖,𝑗 for any particular values y, 𝑦′=𝑥, and 𝑥′.

A straightforward correction of the algorithm would lead to remembering too much for a polynomial-time algorithm. However, we can be inspired by it to obtain a subexponential-time algorithm. We attempted to correct the algorithm or extend the idea leading to the polynomiality. However, despite lots of effort, we were not successful and it seemed to us that the presented algorithm is hardly repairable. We note here, that there is another paper by the same authors [8] where a very similar polynomial algorithm is used for MaxCut of co-bipartite chain graphs with twins. Those graphs can be viewed as graphs given by bubble models with two columns; but having two columns is a crucial property for the algorithm.

To conclude, the time complexity of the MaxCut problem on unit interval graphs is still not resolved and it seems to be a challenging open question.

Subexponential Algorithm in Mixed Unit Interval Graphs
Here, we present a subexponential-time algorithm for the MaxCut problem in mixed unit interval graphs. Our aim is to have an algorithm running in 2̃ (𝑛√) time. Some of the ideas, for unit interval graphs, originated in discussion with Karczmarz, Nadara, Rzążewski, and Zych-Pawlewicz at Parameterized Algorithms Retreat of University of Warsaw 2019 [34].

Let us start with a notation. Let H be a graph, 𝑊⊆𝑉(𝐻), and 𝑆⊆𝑊, we say that a cut X of H agrees with S in W if 𝑋∩𝑊=𝑆. We denote the size of a maximum cut of H that agrees with S in W as 𝑚𝑐𝑠(𝐻,𝑆,𝑊). Let G be a mixed unit interval graph. We take a -bubble model =⟨𝐵𝑖,𝑗⟩1≤𝑗≤𝑘,1≤𝑖≤𝑟𝑗 for G and we distinguish columns of  according to their number of vertices. We denote by 𝑏𝑖𝑗 the number of vertices in bubble 𝐵𝑖,𝑗 and by 𝑐𝑗 the number of vertices in column j, i.e., 𝑏𝑖𝑗=|𝐵𝑖,𝑗| and 𝑐𝑗=∑𝑟𝑗𝑖=1𝑏𝑖,𝑗. We call a column j with 𝑐𝑗>𝑛√ a heavy column, otherwise a light column. We call consecutive heavy columns and their two bordering light columns a heavy part of  (if  starts or ends with a heavy column, for brevity, we add an empty column at the beginning or the end of , respectively), and we call their light columns borders. A heavy part might contain no heavy columns in the case that two light columns are consecutive.

We note that we can guess all possible cuts in one light column without exceeding the aimed time and that most of those light column guesses are independent of each other—once we know the cut in the previous column, it does not matter what the cut is in columns before. Furthermore, there are at most 𝑛√ consecutive heavy columns which allow us to process them together in subexponential time. More formally, we show that we can determine a maximum cut independently for each heavy part, given a fixed cut on its borders, as stated in the following lemma.

Lemma 12
Let G be a mixed unit interval graph and =⟨𝐵𝑥,𝑦⟩1≤𝑦≤𝑘,1≤𝑥≤𝑟𝑦 be a -bubble model for G where ̂ 1,…,̂ 𝑝 are heavy parts of  in this order. If 𝑆=𝑆0∪⋯∪𝑆𝑝 is a (fixed) cut of light columns =𝐶𝑖0∪𝐶𝑖1∪⋯∪𝐶𝑖𝑝 in 𝐺(), where 1≤𝑖0<…<𝑖𝑝≤𝑘, such that 𝑆𝑗 is a cut of 𝐶𝑖𝑗, 𝑗∈{0,…,𝑝}, then

𝑚𝑐𝑠(𝐺,𝑆,)=∑𝑗=1𝑝𝑚𝑐𝑠(𝐺(̂ 𝑗),𝑆𝑗−1∪𝑆𝑗,𝐶𝑖𝑗−1∪𝐶𝑖𝑗)−(∑𝑗=1𝑝−1|𝑆𝑗|⋅|𝐶𝑖𝑗∖𝑆𝑗|).
Proof
It is readily seen that once we have a fixed cut in an entire column C of a bubble model, a maximum cut of columns which are to the left of C (including C) is independent on a maximum cut of those which are to the right of C (including C). Therefore, we can sum the sizes of maximum cuts in heavy parts which are separated by fixed cuts. However, the cut size of middle light columns is counted twice since they are contained in two heavy parts. Therefore, we subtract them. ◻

Now, our aim is to determine the size of a maximum cut for a heavy part ̂  given a fixed cut on its borders. This can be also achived by clique-width approach using results in [16] with a slightly worse running time; see Remark 1 for details. We note that if ̂  is a heavy part with no heavy columns, we can straightforwardly count the number of cut-edges of 𝐺(̂ ) assuming a fixed cut on borders is given. Therefore, we are focusing on a situation where at least one heavy column is present in a heavy part. We use dynamic programming to determine the size of a maximum cut on each such heavy part.

Let ̂  be a heavy part with ℎ≥1 heavy columns (for simplicity numbered by 1,…,ℎ) and borders L and R (we also refer to L and R as columns 0 and ℎ+1, respectively). First, we present a brief idea of the dynamic programming approach, followed by technical definitions and proofs later. We take bubbles in ̂  which are not in borders and process them one-by-one in top-bottom, left-right order. When processing a bubble, we consider all the possibilities of numbers of cut-vertices in each its quadrant. We refer to the already processed part after i-th step as 𝐺𝑖, that is, 𝐺𝑖 is the induced subgraph of 𝐺(̂ ) with 𝑉(𝐺𝑖)=𝐵1∪⋯∪𝐵𝑖∪𝐿∪𝑅 where 𝐵𝑗, 𝑗∈{1,…,𝑖} are first i bubbles in top-bottom, left-right order in ̂  (as it is shown in Fig. 5).

We store all possible (ℎ+1)-tuples (𝑠1,𝑠2,…,𝑠ℎ,𝑎), where 𝑠𝑗 characterizes the number of all cut vertices in (heavy) column j, and number a characterizes the number of cut vertices of types (∗,+) in the last processed bubble. Then, we define recursive function f where 𝑓𝑖 will be related to the maximum size of a cut that has exactly 𝑠𝑗 cut vertices in column j (for all j) in the already processed part 𝐺𝑖. More precisely, we want the recursive function f to satisfy the properties later covered by Lemma 13. Once, f satisfies the desired properties, we easily obtain the size of a maximum cut in the heavy part (Theorem 14, below).

Now, we present a key observation for the construction of f. Observe, by the properties of -bubble model, that the edges of 𝐺𝑖 can be partitioned into following disjoint sets:

𝐸1={edges of the graph 𝐺𝑖−1},

𝐸2={edges inside 𝐵𝑖},

𝐸3={edges between 𝐵𝑖 and the same column above 𝐵𝑖},

𝐸4={edges between 𝐵𝑖 and the next column above 𝐵𝑖},

𝐸5={edges between 𝐵𝑖 and the bubble in the previous column and the same row as 𝐵𝑖},

𝐸6={edges between 𝐵𝑖 and column L below 𝐵𝑖},

𝐸7={edges between 𝐵𝑖 and the bubble in column R in the same row as 𝐵𝑖}.

Therefore, the idea there is to count the size of a desired cut of 𝐺𝑖 using the sizes of possible cuts in 𝐺𝑖−1 and add the size of a cut using edges 𝐸2−𝐸7. The former is stored in 𝑓𝑖−1 and the later can be counted from the number of cut vertices in currently processed bubble 𝐵𝑖 and numbers in the (ℎ+1)-tuple we are processing.

Now, let us properly define the function f and prove Theorem 2 formally. We develop more notation. Let 𝐵1,...,𝐵𝑚 be bubbles in ̂ ∖(𝐿∪𝑅) numbered in the top-bottom, left-right order. Let 𝑆𝐿 and 𝑆𝑅 be (fixed) cuts in L and R. To handle borders, we define auxiliary functions 𝑛↓,𝑛←,𝑛↑, 𝑛→ which output the number of cut vertices in borders in a specific position depending on the given row and column; they output 0 if the given column is not next to the borders. We define:

the number of (fixed) cut vertices in L under row r (or 0 if the previous column is not L):

𝑛↓(𝑟,𝑐):={|𝑆𝐿∩⋃𝑟0𝑘=𝑟+1𝐵𝑘,0|0𝑐=1𝑐≠1,
the number of (fixed) cut vertices of type (∗,+) in the left border L in row r:

𝑛←(𝑟,𝑐):={|𝑆𝐿∩𝐵∗,+𝑟,0|0𝑐=1𝑐≠1,
the number of (fixed) cut vertices in the right border R above row r:

𝑛↑(𝑟,𝑐):={|𝑆𝑅∩⋃𝑟−1𝑘=1𝐵𝑘,ℎ+1|0𝑐=ℎ𝑐≠ℎ,
the number of (fixed) cut vertices of type (+,∗) in the right border R in row r:

𝑛→(𝑟,𝑐):={|𝑆𝑅∩𝐵+,∗𝑟,ℎ+1|0𝑐=ℎ𝑐≠ℎ.
We denote the number of vertices in 𝐵𝑖 by 𝑏𝑖:=|𝐵𝑖|, analogously 𝑏𝑥𝑦𝑖:=|𝐵𝑥𝑦𝑖|, 𝑥,𝑦∈{+,−}. We further denote

𝛽𝑖:={(𝑛1,𝑛2,𝑛3,𝑛4)∣𝑛1∈{0,…,𝑏++𝑖},𝑛2∈{0,…,𝑏+−𝑖},𝑛3∈{0,…,𝑏−+𝑖},𝑛4∈{0,…,𝑏−−𝑖}}.
In addition, we denote the set of (ℎ+1)-tuples characterizing all possible counts of cut-vertices in the h heavy columns and an auxiliary number characterizing the count of possible edges from the last processed bubble, by

𝑇={(𝑠1,…,𝑠ℎ,𝑎)∣𝑎∈ℕ,0≤𝑎≤max𝑖∈{1,…,𝑚}(𝑏−+𝑖+𝑏++𝑖),∀𝑗∈{1,…,ℎ}:𝑠𝑗∈ℕ,0≤𝑠𝑗≤𝑐𝑗}.
Let 𝑒(𝑠1,𝑠2) denote the number of cut-edges between two sets 𝑆1, 𝑆2 which are complete to each other and 𝑆𝑘, 𝑘∈{1,2}, contains 𝑠𝑘 cut vertices and 𝑠𝑘⎯⎯⎯⎯⎯ non-cut vertices, i.e., 𝑒(𝑠1,𝑠2)=𝑠1⋅𝑠2⎯⎯⎯⎯⎯+𝑠1⎯⎯⎯⎯⎯⋅𝑠2. We remark that it is important to know the numbers of non-cut vertices (𝑠1⎯⎯⎯⎯⎯ and 𝑠2⎯⎯⎯⎯⎯), however, we will not write them explicitly for the easier formulas. It will be seen that they can be, for instance, stored in parallel with the numbers of cut vertices (or counted in each step again).

Finally, we define a recursive function f by the following recurrence relation:

∀(𝑠1,…,𝑠ℎ,𝑎)∈𝑇:if 𝑠1≤𝑏1,𝑠2=⋯=𝑠ℎ=0:𝑓1((𝑠1,…,𝑠ℎ,𝑎))=max(𝑏++,𝑏−+,𝑏+−,𝑏−−)∈𝛽1:𝑏+++𝑏−++𝑏+−+𝑏−−=𝑠1,𝑏+++𝑏−+=𝑎(𝑒(𝑠1,𝑛↓(1,1))+𝑠1⋅(𝑏1−𝑠1)+𝑒(𝑛←(1,1),(𝑏+++𝑏+−))+𝑒(𝑛→(1,1),𝑏+++𝑏−+)),otherwise:𝑓1((𝑠1,…,𝑠ℎ,𝑎))=−∞.∀𝑖∈{2,…,𝑚},∀(𝑠1,…,𝑠ℎ,𝑎)∈𝑇:𝑓𝑖((𝑠1,…,𝑠ℎ,𝑎))=max(𝑏++,𝑏+−,𝑏−+,𝑏−−)∈𝛽𝑖,𝑧∈ℕ:𝑏+++𝑏−+=𝑎,(𝑠1,…,𝑠𝑐−𝑏,…,𝑠ℎ,𝑧)∈𝑇,𝑧≤|𝐵∗+𝑖−1|(𝑓𝑖−1((𝑠1,…,𝑠𝑐−𝑏,…,𝑠ℎ,𝑧))+𝑏⋅(𝑏𝑖−𝑏)+𝑒(𝑏,𝑠𝑐+1)+𝑒(𝑏,𝑠𝑐−𝑏)+𝑒(𝑛↓(𝑟,𝑐),𝑏)+𝑒(𝑛←(𝑟,𝑐),(𝑏+++𝑏+−))+𝑒((𝑏+++𝑏−+),𝑛→(𝑟,𝑐))+𝐴)where 𝐴={𝑒(𝑧,𝑏+++𝑏+−)0𝑖>1,𝑐=col(𝐵𝑖−1)+1,otherwise,and 𝑏=𝑏+++𝑏+−+𝑏−++𝑏−−,𝑐=col(𝐵𝑖),𝑟=row(𝐵𝑖), and 𝑠ℎ+1=𝑛↑(𝑟,𝑐).
Recall that 𝐺𝑖 denotes the induced subgraph of 𝐺(̂ ) with 𝑉(𝐺𝑖)=𝐵1∪⋯∪𝐵𝑖∪𝐿∪𝑅.

Lemma 13
For each 𝑠=(𝑠1,…,𝑠ℎ,𝑎)∈𝑇 and for every 𝑖∈{1,…,𝑚}, the value 𝑓𝑖(𝑠) is equal to the maximum size of a cut S in 𝐺𝑖 that satisfies the following

for every 𝑗∈{1,…,ℎ}, the number of cut vertices in the column j in 𝐺𝑖 is equal to 𝑠𝑗, and S agrees with 𝑆𝐿∪𝑆𝑅 in 𝐿∪𝑅, and

a is equal to the number of cut vertices from 𝐵++𝑖∪𝐵−+𝑖,

or 𝑓𝑖 is equal to −∞ if there is no such cut.

Proof
We prove Lemma 13 by induction on the number of steps (bubbles). Since 𝐵1 is in the first heavy column, Lemma 13 is true for 𝑖=1 by Definition 5 (iv).

In the inductive step, suppose that for every 𝑠=(𝑣1,𝑣2,…,𝑣ℎ,𝑧)∈𝑇, 𝑓𝑖−1(𝑠) is equal to the size of a maximum cut 𝑆𝑖−1 in 𝐺𝑖−1 such that the number of cut vertices in each column j, for every 𝑗∈{1,2,…,ℎ}, in 𝐺𝑖−1 is equal to 𝑣𝑗, and the number of cut vertices from 𝐵∗+𝑖−1 is equal to z. Or 𝑓𝑖−1(𝑠) is equal to −∞ if such a cut does not exist.

As it was mentioned, the edges of 𝐺𝑖 can be partitioned into disjoint sets 𝐸1—𝐸7. Recall:

𝐸1={edges of the graph 𝐺𝑖−1},

𝐸2={edges inside 𝐵𝑖},

𝐸3={edges between 𝐵𝑖 and the same column above 𝐵𝑖},

𝐸4={edges between 𝐵𝑖 and the next column above 𝐵𝑖},

𝐸5={edges between 𝐵𝑖 and the bubble in the previous column and the same row as 𝐵𝑖},

𝐸6={edges between 𝐵𝑖 and column L below 𝐵𝑖},

𝐸7={edges between 𝐵𝑖 and the bubble in column R in the same row as 𝐵𝑖}.

We note that 𝐸6 is non-empty only if 𝐵𝑖 is in the column 1, similarly 𝐸7 is non-empty only if 𝐵𝑖 is in the column h. Let 𝑠=(𝑠1,…,𝑠ℎ,𝑎)∈𝑇 be fixed. At first assume, S is a maximum cut in 𝐺𝑖 (that agrees with 𝑆𝐿∪𝑆𝑅 in 𝐿∪𝑅) such that it contains 𝑠𝑗 vertices from the column j for each 𝑗∈{1,2,…,ℎ} and a vertices from 𝐵∗+𝑖; we say S satisfies the conditions s. We discuss the case where no such cut exists, later. We denote by 𝑠𝑥𝑦 the number of vertices in 𝐵𝑥𝑦𝑖∩𝑆, 𝑥,𝑦∈{+,−}, and by 𝑠′ the sum of these values, i.e., 𝑠′=𝑠+++𝑠+−+𝑠−++𝑠−−. We denote col(𝐵𝑖) by j, and row(𝐵𝑖) by r. Then,

𝐸(𝑆,𝑆⎯⎯⎯⎯)=(𝐸(𝑆,𝑆⎯⎯⎯⎯)∩𝐸(𝐺𝑖−1))∪{𝑢𝑣∈𝐸𝑘∣𝑢∈𝑆,𝑣∉𝑆,𝑘∈{2,…,6}}.
Which leads to the expression:

|𝐸(𝑆,𝑆⎯⎯⎯⎯)| where 𝐴=|𝐸(𝑆,𝑆⎯⎯⎯⎯)∩𝐸(𝐺𝑖−1)|+𝑠′⋅(𝑏𝑖−𝑠′)+𝑒(𝑠′,(𝑠𝑗−𝑠′))+𝑒(𝑠′,𝑠𝑗+1)+𝐴+𝑒(𝑠′,𝑛↓(𝑟,𝑗))+𝑒(𝑠+++𝑠+−,𝑛←(𝑟,𝑗))+𝑒(𝑠+++𝑠−+,𝑛→(𝑟,𝑗)),={𝑒(|𝑆∩𝐵∗+𝑖−1|,𝑠+++𝑠+−)0𝑗=col(𝐵𝑖−1)+1,𝑜𝑡ℎ𝑒𝑟𝑤𝑖𝑠𝑒.
By the induction hypothesis,

|𝐸(𝑆,𝑆⎯⎯⎯⎯)∩𝐸(𝐺𝑖−1)|≤𝑓𝑖−1(𝑠1,…,𝑠𝑗−𝑠′,…,𝑠ℎ,|𝑆∩𝐵∗+𝑖−1|).
(1)
It gives us together with the right part of the equation, the definition of 𝑓𝑖 for 𝑏𝑥𝑦=𝑠𝑥𝑦, 𝑏=𝑠′ and 𝑧=|𝑆∩𝐵∗+𝑖−1|. Therefore,

|𝐸(𝑆,𝑆⎯⎯⎯⎯)|≤𝑓𝑖(𝑠).
Furthermore, we show that 𝑓𝑖(𝑠) is the size of a cut satisfying the conditions s. Since the value of the function 𝑓𝑖−1((𝑠1,…,𝑠𝑗−𝑏,…,𝑠ℎ,𝑧)) is for any number 𝑏∈{0,…,min(𝑠𝑗,𝑏𝑖)} a size of a cut in 𝐺𝑖−1 which satisfies the conditions (𝑠1,…,𝑠𝑗−𝑏,…,𝑠ℎ,𝑧), or −∞ (if no such cut exists), we can extend that cut into 𝐺𝑖 by adding 𝑏𝑥𝑦 vertices from 𝐵𝑥𝑦𝑖 where 𝑏+++𝑏−+=𝑎 and 𝑏+++𝑏+−+𝑏−++𝑏−−=𝑏. Consequently, 𝑓𝑖(𝑠) is a size of a cut on 𝐺𝑖 satisfying that it contains 𝑠𝑖 vertices from the column i and a vertices from |𝐵∗+𝑖|. At least one such cut exists, by (1). Therefore, |𝐸(𝑆,𝑆⎯⎯⎯⎯)|≥𝑓𝑖(𝑠). It leads to the equation |𝐸(𝑆,𝑆⎯⎯⎯⎯)|=𝑓𝑖(𝑠), otherwise, S is not a maximum cut.

In a similar way, we can extend every cut on 𝐺𝑖−1 to 𝐺𝑖. Therefore, if there exist no cut on 𝐺𝑖 which satisfies the conditions s, there exists no cut in 𝐺𝑖−1 which can be extended to the cut on 𝐺𝑖 satisfying the conditions s. Consequently, 𝑓𝑖(𝑠)=−∞ by the definition of f since 𝑓𝑖−1(𝑣)=−∞ for all (ℎ+1)-tuples v which appear in the definition. ◻

Finally, we obtain the next theorem about a maximum cut of a heavy part as a corollary of Lemma 13.

Theorem 14
Let ̂  be a heavy part with ℎ≥1 heavy columns (numbered by 1,…,ℎ) and borders L and R. Let 𝐵1,...,𝐵𝑚 be bubbles in ̂ ∖(𝐿∪𝑅) numbered in the top-bottom, left-right order. Let 𝑆𝐿 and 𝑆𝑅 be (fixed) cuts in L and R. Then,

𝑚𝑐𝑠(𝐺(̂ ),𝑆𝐿∪𝑆𝑅,𝐿∪𝑅)=max𝑠∈𝑇𝑓𝑚(𝑠).
Towards proving Theorem 2 and Corollary 3, it remains to prove the time complexity of processing a heavy part.

Lemma 15
Let ̂  be a heavy part with ℎ≥1 columns, m bubbles, and a fixed cut in the borders. The size of a maximum cut of ̂  that agrees with the fixed cut in the borders can be determined in time:

(𝑐1+1)…(𝑐ℎ+1)⋅(𝑎+1)⋅∑𝑖=1𝑚(𝑏++𝑖⋅𝑏+−𝑖⋅𝑏−+𝑖⋅𝑏−−𝑖)
where 𝑐𝑗 is the number of vertices in the column j, i.e., 𝑐𝑗=∑𝑟𝑗𝑖′=1𝐵𝑖′,𝑗, and 𝑎=max𝑖|𝐵∗+𝑖|.

Proof
We analyze the time complexity of the algorithm from Lemma 15. Let T denote all the possible (ℎ+1)-tuples. Then |𝑇|=(𝑐1+1)…(𝑐ℎ+1)⋅(𝑎+1). The time for processing a bubble 𝐵𝑖 is |𝑇|⋅𝑏++𝑖⋅𝑏+−𝑖⋅𝑏−+𝑖⋅𝑏−−𝑖. The time complexity of processing ̂  is then

|𝑇|⋅∑𝑖=1𝑚𝑏++𝑖⋅𝑏+−𝑖⋅𝑏−+𝑖⋅𝑏−−𝑖.
◻

Now, we are ready to prove Theorem 2.

Proof of Theorem 2
By Lemma 12, heavy parts can be processed independently on each other, given a cut on their borders. Moreover, it is sufficient for a light column C to remember only the biggest cuts on the left of C (containing C) for each possible cut in C. Therefore, there is no need to guess cuts in all light columns at once. It is sufficient to guess a cut only in two consecutive light columns at once.

Observe that there are at most 2𝑛√ guesses of cut vertices for a light column and there are at most n light columns. Therefore, the time complexity of determining the size of a maximum cut in G is at most 𝑛⋅(2𝑛√)2⋅𝑃, where P is the maximum time for processing a heavy part. Now, we want to prove a time complexity of processing a heavy part ̂ =⟨𝐵𝑖,𝑗⟩1≤𝑗≤𝑙,1≤𝑖≤𝑟𝑗 with a given guess of light columns.

By Lemma 15, the time complexity of processing a heavy part with a given guess of light columns is

𝑃=(𝑐1+1)…(𝑐ℎ+1)⋅(𝑎+1)⋅∑𝑖=1𝑚(𝑏++𝑖⋅𝑏+−𝑖⋅𝑏−+𝑖⋅𝑏−−𝑖)≤(𝑛+1)1+𝑛√⋅∑𝑖=1𝑚𝑏4𝑖≤(𝑛+1)1+𝑛√⋅𝑛4∈(𝑛52𝑛√log(𝑛)).
To sum up, we can determine the size of a maximum cut in time:

𝑛⋅(2𝑛√)2⋅𝑃∈(𝑛62𝑛√(log(𝑛)+2)).
(2)
For brevity, we analyzed only the size of a maximum cut. However, the maximum cut itself can be determined retroactively in the same running time. ◻

Remark 1
We wish to point out that Theorem 2 with slightly worse bound of 𝑛(1)22𝑛√(log(𝑛)+1) can be derived by combination of the maxcut algorithm parameterized by the clique-width as presented in [16] together with our bounds on the clique-width expressed by the number of columns of the model (Corollary 22), and Lemma 12.

More precisely, the heavy part is composed of at most 𝑛√ columns plus two additional light columns. Therefore, by Corollary 22 the clique-width of the heavy part is bounded by 𝑛√+5. As the algorithm in [16] can be easily modified to determine the maximum cut size even when the cut on the light columns is given, we conclude by Lemma 12 and the expression in (2) where 𝑃=𝑛(1)𝑛2(𝑛√+5).

Lemma 15 has a nice corollary for graphs with a -bubble model with a constant number of columns. According to Lemma 15, we are able to solve the MaxCut problem in those graphs in polynomial time which is formulated as Corollary 3 in the introduction. Therefore, we improved another polynomial-time algorithm by Boyacı et al. [8] solving the MaxCut problem in co-bipartite chain graphs with possible twins (which is exactly the class of graphs defined by a classic bubble model with only two columns).

Proof of Corollary 3
Let G be a graph on n vertices which is defined by a -bubble model  with k columns and m bubbles. The bubble model  can be seen as a heavy part with no cut-vertices in its borders. By Lemma 15, the size of a maximum cut in  can be determined in time 𝑇=(𝑐1+1)…(𝑐𝑘+1)⋅(𝑎+1)⋅∑𝑚𝑖=1(𝑏++𝑖⋅𝑏+−𝑖⋅𝑏−+𝑖⋅𝑏−−𝑖) where 𝑏𝑥𝑦𝑖,𝑥𝑦∈{+,−} is the number of vertices in the bubble quadrant 𝐵𝑥𝑦𝑖, and 𝑐𝑗 is the number of vertices in the column j, i.e., 𝑐𝑗=∑𝑟𝑗𝑖′=1𝐵𝑖′,𝑗, and 𝑎=max𝑖|𝐵∗+𝑖|.

By Arithmetic Mean-Geometric Mean Inequality (AM-GM) we obtain

𝑇≤(𝑎+1)⋅(1𝑘⋅∑𝑗=1𝑘(𝑐𝑗+1))𝑘⋅∑𝑖=1𝑚(𝑏++𝑖+𝑏+−𝑖+𝑏−+𝑖+𝑏−−𝑖4)4=(𝑎+1)⋅(𝑛+𝑘𝑘)𝑘⋅∑𝑖=1𝑚(𝑏𝑖4)4≤(𝑎+1)⋅(𝑛+𝑘𝑘)𝑘⋅(𝑛4)4∈(𝑛𝑘+5).
It remains to prove the special case where 𝑘=2. Notice, it is sufficient to distinguish only between vertices in quadrants of types (∗,+) and (∗,−) in the first column, and similarly (+,∗) and (−,∗) in the second column. Therefore, we obtain (𝑏𝑖2)2 instead of (𝑏𝑖4)4 which leads to the time complexity (𝑛𝑘+1+2)=(𝑛5). ◻

We note that Theorem 14 states the explicit size of a maximum cut.

Clique-Width Of Mixed Unit Interval Graphs
The clique-width is one of the parameters which are used to measure the complexity of a graph. Many 𝖭𝖯-hard problems, those which are expressible in Monadic Second-Order Logic using second-order quantifiers on vertices (𝑀𝑆𝑂1), can be solved efficiently in graphs of bounded clique-with [11]. For instance, 3-coloring. Definition of the clique-width is quite technical but it follows the idea that a graph of the clique-width at most k can be iteratively constructed such that in any time, there are at most k types of vertices, and vertices of the same type behave indistinguishably from the perspective of the newly added vertices.

Definition 6
(Courcelle 2000). The clique-width of a graph G, denoted by 𝑐𝑤𝑑(𝐺), is the smallest integer number of different labels that is needed to construct the graph G using the following operations:

0.
creation of a vertex with label i,

1.
disjoint union (denoted by ⊕),

2.
relabeling: renaming all labels i to j (denoted by 𝜌𝑖→𝑗),

3.
edge insertion: connecting all vertices with label i to all vertices with label j, 𝑗∈{1,…,𝑘}, 𝑖≠𝑗; already existing edges are not doubled (denoted by 𝜂𝑖,𝑗).

Such a construction of a graph can be represented by an algebraic term composed of the operations ⊕, 𝜌𝑖→𝑗, and 𝜂𝑖,𝑗, called cwd-expression. We call k-expression a cwd-expression in which at most k different labels occur. Using this, we can say that the clique-width of a graph G is the smallest integer k such that the graph G can be defined by a k-expression.

Example
The diamond graph G on the four vertices u, v, w, x (the complete graph 𝐾4 without the edge vw) is defined by the following cwd-expression:

𝜂1,2(𝜌2→1(𝜂1,2(1(𝑢)⊕2(𝑣)⊕2(𝑤)))⊕2(𝑥)).
Therefore, 𝑐𝑤𝑑(𝐺)≤2.

Fellows et al. [15] proved in 2009 that the deciding whether the clique-width of a graph G is at most k is 𝖭𝖯-complete. Therefore, researchers put effort into computing an upper-bound of the clique-width.

Courcelle and Olariu [12] showed in 2000 that bounded treewidth implies bounded clique-width (but not vice versa). They showed that for any graph G with the treewidth k, the clique-width of G is at most 4⋅2𝑘−1+1.

Golumbic and Rotics [20] proved that unit interval graphs have unbounded clique-width via a construction that can be described as a bubble model where all bubbles contains exactly one vertex. Consequently, (mixed unit) interval graphs have unbounded clique-width as well. Therefore, computing upper-bounds are of particular interest. Fellows et al. [14] showed that the clique-width of a graph is bounded by its pathwidth + 2, therefore, the clique-width of interval graphs as well as of unit interval graphs is upper-bounded by the size of their maximum clique + 1 [14, 26]. Using a bubble model structure, subclasses of unit interval graphs were characterized in terms of (linear) clique-width [30, 32]. Courcelle [12] observed that clique-width can be computed componentwise.

Lemma 16
(Courcelle [12]). Any graph G satisfies that

𝑐𝑤𝑑(𝐺)=𝑚𝑎𝑥{𝑐𝑤𝑑(𝐺′)∣𝐺′ is a connected component of 𝐺}.
We provide an upper-bound of the clique-width of a graph G depending on the number of columns in a -bubble model of G. We express it also in the size of a maximum independent set.

Lemma 17
Let G be a mixed unit interval graph and  be a -bubble model of G. Then 𝑐𝑤𝑑(𝐺)≤𝑘+3, where k is the number of columns of . Moreover, a (𝑘+3)-expression defining the graph G can be constructed in (𝑛) time from .

Proof
The proof is inspired by the proof for unit interval graphs [23].

We find a (𝑘+3)-expression defining G and, therefore, prove that 𝑐𝑤𝑑(𝐺)≤𝑘+3. We use 𝑘+3 labels where label i will be assigned to i-th column of  and the remaining three labels, denoted by 𝑙1,𝑙2,𝑙3, are used for maintaining the last two added vertices.

We define a linear order on vertices of G according to  as follows:

(i)
We take the vertices from top to bottom, left to right. Formally, let 𝑥∈𝐵𝑖,𝑗, 𝑦∈𝐵𝑙,𝑚, we define 𝑥≺𝑦 if 𝑖<𝑙 or (𝑖=𝑙 and 𝑗<𝑚);

(ii)
we define the following order on bubble quadrants:

𝑥≺𝑦≺𝑧≺𝑤 for 𝑥∈𝐵−−𝑖,𝑗,𝑦∈𝐵+−𝑖,𝑗,𝑧∈𝐵−+𝑖,𝑗,𝑤∈𝐵++𝑖,𝑗;
(iii)
we define an arbitrary linear order on vertices in the same quadrant of the same bubble.

The idea of the proof is that every column has its own label and we need three more labels for maintaining the last added vertices. We will add vertices to G in the described order which ensures that a new vertex is complete to all vertices from the following column and anti-complete to all vertices from the previous column except those from the same row. Recall that according to the definition of -bubble model, there is an edge between vertices 𝑥∈𝐵𝑖,𝑗 and 𝑦∈𝐵𝑖,𝑗+1 if and only if 𝑥∈𝐵∗,+𝑖,𝑗 and 𝑦∈𝐵+∗𝑖,𝑗+1. Therefore, vertices from the last constructed bubble in the previous column must have two distinct labels according to the types of the vertices. However, once we add all vertices from the actual bubble, we do not need to distinguish between vertices from the previous column, anymore. Therefore, we rename their labels to the label of their column.

Formally. Let x be the first (smallest) vertex of G according to the defined linear order. We know that x is from the first column by Definition 5 (iv). If x is of type (−,+) or (+,+), we label it by 𝑙1, otherwise by 1, so the expression for 𝐺[{𝑥}] is 1(x) if x is of type (+,−) or (−,−), and 𝑙1(𝑥) otherwise.

Let y be the first non-processed vertex from G, i.e., a label is assigned to all preceding vertices. Let 𝑙2,𝑙3∈{𝑘+1,𝑘+2,𝑘+3} are currently unused labels or 𝑙2 is used in the actual bubble 𝐵𝑖,𝑗 and 𝑙3 is unused, and 𝑙1 may be used (in the previous column). We note that at most one label from {𝑘+1,𝑘+2,𝑘+3} is used in the previous column any time. We split the proof according to the type of y, the bubble quadrant where y belongs.

(a)
𝑦∈𝐵−−𝑖,𝑗. We use label 𝑙2 for y. Then, we make y (the only one vertex with label 𝑙2) complete to vertices with labels 𝑗+1 (if 𝑗<𝑘) and j. Relabel 𝑙2 to j.

(b)
𝑦∈𝐵+−𝑖,𝑗. We use label 𝑙2 for y. Then, we make y (the only one vertex with label 𝑙2) complete to vertices with labels 𝑗+1 (if 𝑗<𝑘), j, 𝑙1. Relabel 𝑙2 to j.

(c)
𝑦∈𝐵−+𝑖,𝑗. We use label 𝑙2 for y. Then, we make all vertices with label 𝑙2 complete to vertices with labels 𝑗+1 (if 𝑗<𝑘), j, 𝑙2. (Do not relabel vertices with label 𝑙2).

(d)
𝑦∈𝐵++𝑖,𝑗. We use label 𝑙3 for y. Then, we make y (the only one vertex with label 𝑙3) complete to vertices with labels 𝑗+1 (if 𝑗<𝑘), j, 𝑙1, 𝑙2. Relabel 𝑙3 to 𝑙2.

If all vertices from 𝐵𝑖,𝑗 were used, we rename all vertices with the label 𝑙1 to 𝑗−1 if 𝑗>1. If 𝑗=𝑘, we relabel 𝑙2 to k.

For the correctness, observe that the previous column has always at most two labels and in a), b), and d) the temporary label for y is unique (no other vertices are labeled by it at that time). The rest follows from the definition of adjacency in the -bubble model. Since we constructed G using at most 𝑘+3 labels, 𝑐𝑤𝑑(𝐺)≤𝑘+3.

The described algorithm processes each vertex once and each vertex has at most three labels in total. Moreover, the algorithm needs a constant work for each vertex—for instance, a cwd-expression for the option a) is:

𝜌𝑙2→𝑗(𝜂𝑗,𝑙2(𝜂𝑗+1,𝑙2(𝑙2(𝑦)⊕𝐺′))),
where 𝐺′ is the already constructed graph before adding the vertex y. Therefore, the (𝑘+3)-expression defining G is constructed in linear time given a -bubble model in an appropriate structure. ◻

Theorem 18
Let G be a mixed unit interval graph. Then 𝑐𝑤𝑑(𝐺)≤2𝛼(𝐺)+3. Moreover, a (2𝛼(𝐺)+3)-expression defining the graph G can be constructed in (𝑛) time provided a -bubble model of G is given.

Proof
We apply Lemma 17 and Lemma 10 together to obtain the statements. ◻

Next, we provide a different bound for clique-width which is obtained by a small extension of the proof for unit interval graphs using the bubble model by Heggernes et al. [23]. We include the full proof for completeness.

We need more notation. Let G be a mixed unit interval graph and let =⟨𝐵𝑖,𝑗⟩1≤𝑗≤𝑘,1≤𝑖≤𝑟𝑗 be a -bubble model for G. We say that vertices from the same column j of  create a group if they have the same neighbours in the following column 𝑗+1 of . Let 𝑣∈𝐵𝑖,𝑗, the group number of vertex v in , denoted by 𝑔(𝑣), is defined as the maximum number of groups in 𝑁(𝑣)∩(⋃𝑟𝑗−1𝑖′=𝑖+1𝐵𝑖′,𝑗−1∪⋃𝑖−1𝑖′=1𝐵𝑖′,𝑗∪𝐴) over the sets 𝐴=𝐵∗+𝑖,𝑗−1∪𝐵+∗𝑖,𝑗 and 𝐴=𝐵𝑖,𝑗. Then the group number of G in  is defined as

𝜑(𝐺):=max𝑣∈𝑉(𝐺)𝑔(𝑣).
Lemma 19
Let G is a mixed unit interval graph and  a -bubble model for G. The following inequality holds

𝜑(𝐺)≤𝜔(𝐺)−1.
Proof
Let 𝑣∈𝐵𝑖,𝑗. Observe that ⋃𝑟𝑗−1𝑖′=𝑖+1𝐵𝑖′,𝑗−1∪⋃𝑖−1𝑖′=1𝐵𝑖′,𝑗∪𝐴∪{𝑣} is a clique (for both the possibilities of A), see Lemma 11. Moreover, v is not included in the counting the group number of v, and no vertex can be in more than one group. Therefore, 𝑔(𝑣)≤𝜔(𝐺)−1 for any vertex v which leads to the desired inequality. ◻

Theorem 20
Let G be a mixed unit interval graph and  a -bubble model for G. Then 𝑐𝑤𝑑(𝐺)≤𝜑(𝐺)+2. Moreover, a (𝜑(𝐺)+2)-expression defining the graph G can be constructed in (𝑛+𝑚) time provided a  -bubble model of G is given.

Proof
Our aim is to find a (𝜑(𝐺)+2)-expression defining G. We add vertices in the order from left to right, top to bottom of  processing vertices of type (+,∗) at first, i. e., in the following linear order:

(i)
𝑥≺𝑦 for 𝑥∈𝐵𝑖,𝑗, 𝑦∈𝐵𝑙,𝑚, where 𝑗<𝑚 or (𝑗=𝑚 and 𝑖<𝑙);

(ii)
𝑥≺𝑦≺𝑧≺𝑤 for 𝑥∈𝐵++𝑖,𝑗,𝑦∈𝐵+−𝑖,𝑗,𝑧∈𝐵−+𝑖,𝑗,𝑤∈𝐵−−𝑖,𝑗;

(iii)
an arbitrary linear order on the vertices in the same quadrant of the same bubble.

Now, we follow the original proof. Shortly, we add each vertex v in a proper way. We assume that a label is assigned for each previous vertex and all the vertices which belong to the same group have the same label. At first, we change to 1 the label of all the previous vertices which are non-adjacent to v. We know that at most 𝑔(𝑣) distinct labels are used in the remaining groups, say labels {2,…,𝑔(𝑣)+1}. This is true since all the groups are adjacent to v and because of the linear order.

We note that it is important to add first all the vertices of type (+,∗) from a bubble. Otherwise, 𝑔(𝑣)+1 remaining groups could be there; in the situation that v is of type (+,∗), a potentially one distinct label is needed for 𝐵∗+𝑖,𝑗−1, and another for 𝐵∗−𝑖,𝑗. One the other hand, if all the vertices of type (+,∗) precede vertices of type (−,∗) in one bubble, this situation does not happen—a potential label of 𝐵∗+𝑖,𝑗−1 would be released. Therefore, it is enough to take into account only the parts 𝐴=𝐵∗+𝑖,𝑗−1∪𝐵+∗𝑖,𝑗, and 𝐴=𝐵𝑖,𝑗, and not the bigger one 𝐴=𝐵∗+𝑖,𝑗−1∪𝐵𝑖,𝑗, in the definition of 𝑔(𝑣).

We use a free label, say 𝑔(𝑣)+2, for v and join all the vertices with this label with vertices with labels 2,…,𝑔(𝑣)+1. Next, change the label of v to a label of its group if v belongs to an already existing group. We continue with the next vertex. During the processing of each vertex, we need no more than its group number + 2 distinct labels. Therefore, 𝑐𝑤𝑑(𝐺)≤𝜑(𝐺)+2.

It remains to determine the running time for the construction of the expression defining G. Assume a -bubble model is given in a way that going over all vertices takes linear time in the number of vertices. First, we count the time for the creation of groups. For each vertex v we compare its neighbors from the next column with the neighbors of the previous vertex in this column. Therefore, the splitting vertices into groups and determining the group number of G take (𝑚+𝑛) time. In a constant time, we determine a free label for each vertex. Then, we need to check the labels of groups in the neighborhood of each vertex v and create a (𝑔(𝑣)) long cwd-expression, yielding (𝑚+𝑛) time in total. Furthermore, each vertex is at most once relabeled to 1 since once it is relabeled to 1, its label remains 1 for the rest of the algorithm. Therefore, the relabeling of vertices that are non-adjacent to a newly added vertex takes (𝑛) time in total. To sum up, the algorithm outputs the construction in (𝑛+𝑚) time. ◻

The combination of Theorems 18 and 20 gives us the following upper-bound that can be compared with the known upper-bound 𝜔(𝐺)+1 [14, 26].

Theorem 21
Let G be a mixed unit interval graph. Then

𝑐𝑤𝑑(𝐺)≤min{2𝛼(𝐺)+3,𝜑(𝐺)+2}≤𝜔(𝐺)+1,
where  is a -bubble model for G. Moreover, the corresponding expression can be constructed in (𝑛+𝑚) time provided  is given, otherwise in (𝑛2) time.

Observe that 𝜑(𝐺)≤2max{𝑟𝑗∣1≤𝑗≤𝑘}. A combination of Theorem 21 and Lemma 17 gives a useful Corollary 22. In particular, if the number of rows or number of columns is bounded, than clique-width is bounded.

Corollary 22
Let G be a mixed unit interval graph. Then 𝑐𝑤𝑑(𝐺)≤min{𝑘+3,2𝑟+2}, where k is the number of columns and r is the length of a longest column in a -bubble model for G.

We note that by an application of Lemma 4.1 in [30], slightly worse bounds on clique-width in terms of rows and columns can also be derived. In particular, if we take two natural orderings of the bubbles in the -bubble model, one taking rows first and the other taking columns first, we obtain two times larger multiplicative factor than in Corollary 22.

Conclusion
The main contribution of this work is a new representation of mixed unit interval graphs—the -bubble model. This structure is particularly useful in the design of algorithms and their analysis. Using the -bubble model, we presented new upper-bounds for the clique-width of mixed unit interval graphs and designed a subexponential-time algorithm for the MaxCut problem on mixed unit interval graphs. We further realized that the state-of-the-art polynomial-time algorithm for the MaxCut problem on unit interval graphs is incorrect. A long-term task is to determine the difference between the time complexity of basic problems on unit interval graphs compared to interval graphs. In particular, on a more precise scale of mixed unit interval graphs, determine what is a key property for the change of the complexity. Independently, a long-standing open problem is the time complexity of the MaxCut problem on unit interval graphs, in particular, decide if it is NP-hard or polynomial-time solvable.

An interesting direction to pursue the first task could be the study of labeling problems; either 𝐿2,1-labeling or Packing Coloring. Both problems were motivated by assigning frequencies to transmitters. The 𝐿2,1-labeling problem was first introduced by Griggs and Yeh in 1992 [21]. The packing coloring problem is newer, it was introduced by Goddard et al. in 2008 [18]. Although, these are well-known problems, quite surprisingly, their time complexity is open for interval graphs.

The 𝐿2,1-labeling problem assigns labels {0,…,𝑘} to vertices such that the labels of neighboring vertices differ by at least two and the labels of vertices in distance two are different. The time complexity of this problem is still wide open even for unit interval graphs, despite partial progress on specific values for the largest used label. Sakai proved that the value of the largest label lies between 2𝜒−2 and 2𝜒 where 𝜒 is the chromatic number [39].

The packing coloring problem asks for an existence of such a mapping 𝑐:𝑉→{1,…,𝑚} that for all 𝑢≠𝑣 with 𝑐(𝑢)=𝑐(𝑣)=𝑖 the distance between u and v is at least i. This problem is wide open on interval graphs. Recently, there was a small progress on unit interval graphs leading to an FPT algorithm (time 𝑓(𝑘)⋅𝑛(1) for some computable function f and parameter k). It is shown in [27] that the packing coloring problem is in FPT parameterized by the size of a maximum clique. We note that the algorithm can be straightforwardly extended to mixed unit interval graphs. However, a polynomial-time algorithm or alternatively NP-hardness for (unit) interval graphs is of a much bigger interest.