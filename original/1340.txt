We show that there is a better-than-brute-force algorithm that, when given a small constant-depth Boolean circuit C made up of gates that compute constant-degree Polynomial Threshold functions or PTFs (i.e., Boolean functions that compute signs of constant-degree polynomials), counts the number of satisfying assignments to C in significantly better than brute-force time. Formally, for any constants d, k, there is an ğœ€>0 such that the zero-error randomized algorithm counts the number of satisfying assignments to a given depth-d circuit C made up of k-PTF gates such that C has at most ğ‘›1+ğœ€ many wires. The algorithm runs in time 2ğ‘›âˆ’ğ‘›Î©(ğœ€). Before our result, no algorithm for beating brute-force search was known for counting the number of satisfying assignments even for a single degree-k PTF (which is a depth-1 circuit with linearly many wires).We give two different algorithms for the case of a single PTF. The first uses a learning algorithm for learning degree-1 PTFs (or Linear Threshold Functions) using comparison queries due to Kane, Lovett and Moran (STOC 2018), and the second uses a proof of Hofmeister (COCOON 1996) for converting a degree-1 PTF to a depth-two threshold circuit with small weights. We show that both these ideas fit nicely into a memoization approach that yields the #SAT algorithms.

Access provided by University of Auckland Library

Introduction
This paper adds to the growing line of work on circuit-analysis algorithms, where we are given as input a Boolean circuit C from a fixed class îˆ¯ computing a function ğ‘“:{âˆ’1,1}ğ‘›â†’{âˆ’1,1},Footnote1 and we are required to compute some parameter of the function f. A typical example of this is the question of satisfiability, i.e. whether f is the constant function 1 or not. In this paper, we are interested in computing #SAT(f), which is the number of satisfying assignments of f (i.e. |{ğ‘âˆˆ{âˆ’1,1}ğ‘›âˆ£ğ‘“(ğ‘)=âˆ’1}|).

Problems of this form can always be solved by â€œbrute-forceâ€ in time poly(|ğ¶|)â‹…2ğ‘› by trying all assignments to C. The question is can this brute-force algorithm be significantly improved, say to time 2ğ‘›/ğ‘›ğœ”(1) when C is small, say |ğ¶|â‰¤ğ‘›ğ‘‚(1).

Such algorithms, intuitively are able to distinguish a small circuit ğ¶âˆˆîˆ¯ from a â€œblack-boxâ€ and hence find some structure in C. This structure, in turn, is useful in answering other questions about îˆ¯, such as proving lower bounds against the class îˆ¯.Footnote2 There has been a large body of work in this area, a small sample of which can be found in [26, 27, 33, 37]. A striking result of this type was proved by Williams [33] who showed that for many circuit classes îˆ¯, even co-non-deterministic satisfiability algorithms running in better than brute-force time yield lower bounds against îˆ¯.

Recently, researchers have also uncovered tight connections between many combinatorial problems and circuit-analysis algorithms, showing that even modest improvements over brute-force search can be used to improve long-standing bounds for these combinatorial problems (see, e.g., [1,2,3, 38]). This yields further impetus in improving known circuit-analysis algorithms.

This paper is concerned with #SAT algorithms for constant depth threshold circuits, denoted as TC0, which are Boolean circuits where each gate computes a linear threshold function (LTF); an LTF computes a Boolean function which accepts or rejects based on the sign of a (real-valued) linear polynomial evaluated on its input. Such circuits are surprisingly powerful: for example, they can perform all integer arithmetic efficiently [4, 10], compute conjectured families of pseudorandom functions [23] (and hence are not amenable to Natural lower bound proof techniques in the sense defined by Razborov and Rudich [28]) and are at the frontier of our current lower bound techniques [8, 21].

It is natural, therefore, to try to come up with circuit-analysis algorithms for threshold circuits. Indeed, there has been a large body of work in the area (reviewed in the Previous Work paragraph later in the Introduction), but some extremely simple questions remain open.

An example of such a question is the existence of a better-than-brute-force algorithm for satisfiability of degree-k PTFs where k is a constant greater than 2. Informally, the question is the following: we are given a degree-k polynomial ğ‘„(ğ‘¥1,â€¦,ğ‘¥ğ‘›) in n Boolean variables and we ask if there is any Boolean assignment ğ‘âˆˆ{âˆ’1,1}ğ‘› to ğ‘¥1,â€¦,ğ‘¥ğ‘› such that ğ‘„(ğ‘)<0. Surprisingly, no algorithm is known for this problem that is significantly better than 2ğ‘› time.Footnote3

Note that for a linear polynomial (i.e. ğ‘˜=1), this problem is trivial. For ğ‘˜=2 the problem is already non-trivial. While not noted explicitly in the literature, a better-than-brute-force algorithm for satisfiability of 2-PTFs is implied by the results from [32, 35]. However, the stronger counting variant of this problem for 2-PTFs is open as far as we know.

In this paper, we solve the counting variant of this problem for any constant-degree PTFs. We start with some definitions and then describe this result.

Definition 1
(Polynomial Threshold Functions) A Polynomial Threshold Function (PTF) on n variables of degree-k is a Boolean function ğ‘“:{âˆ’1,1}ğ‘›â†’{âˆ’1,1} such that there is a degree-k multilinear polynomial ğ‘ƒ(ğ‘¥1,â€¦,ğ‘¥ğ‘›)âˆˆâ„[ğ‘¥1,â€¦,ğ‘¥ğ‘›] that, for all ğ‘âˆˆ{âˆ’1,1}ğ‘›, satisfies ğ‘“(ğ‘)=sgn(ğ‘ƒ(ğ‘)). (We assume that ğ‘ƒ(ğ‘)â‰ 0 for any ğ‘âˆˆ{âˆ’1,1}ğ‘›.)

In such a scenario, we call f a k-PTF. In the special case that ğ‘˜=1, we call f a Linear Threshold function (LTF). We also say that the polynomial P sign-represents f.

When ğ‘ƒâˆˆâ„¤[ğ‘¥1,â€¦,ğ‘¥ğ‘›], we define the weight of P, denoted w(P), to be the bit-complexity of the sum of the absolute values of all the coefficients of P. In particular, the coefficients of P are integers in the range [âˆ’2ğ‘¤(ğ‘ƒ),2ğ‘¤(ğ‘ƒ)].

We now formally define the #SAT problem for k-PTFs. Throughout, we assume that k is a constant and not a part of the input.

Definition 2
(#SAT problem for k-PTFs) The problem is defined as follows.

Input: A k-PTF f, specified by a degree-k polynomial ğ‘ƒ(ğ‘¥1,â€¦,ğ‘¥ğ‘›) with integer coefficients.Footnote4

Output: The number of satisfying assignments to f. That is, the number of ğ‘âˆˆ{âˆ’1,1}ğ‘› such that ğ‘ƒ(ğ‘)<0.

We use #SAT(f) to denote this output. We say that the input instance has parameters (n, M) if n is the number of input variables and ğ‘¤(ğ‘ƒ)â‰¤ğ‘€.

Remark 3
An interesting setting of M is poly(ğ‘›) since any k-PTF can be represented by an integer polynomial with coefficients of bit-complexity at most ğ‘‚Ìƒ (ğ‘›ğ‘˜) [22]. However, note that our algorithms work even when M is exp(ğ‘›ğ‘œ(1)), i.e. when the weights are slightly short of doubly exponential in n.

We give a better-than-brute-force algorithm for #SAT(ğ‘˜-PTF). Formally we prove the following theorem.

Theorem 4
Fix any constant k. There is a deterministic algorithm that solves the #SAT problem for k-PTFs in time poly(ğ‘›,ğ‘€)â‹…2ğ‘›âˆ’ğ‘† where ğ‘†=Î©Ìƒ (ğ‘›1/(ğ‘˜+1)) and (n, M) are the parameters of the input k-PTF f. (The Î©Ìƒ (â‹…) hides factors that are inverse polylogarithmic in n.)

Remark 5
An anonymous ITCS 2019 referee pointed out to us that from two results of Williams [32, 35], it follows that satisfiability for 2-PTFs can be solved in 2ğ‘›âˆ’Î©(ğ‘›âˆš) time. Note that this is better than the runtime of our algorithm. However, the method does not seem to extend to ğ‘˜â‰¥3.

Using a different approach, we give another algorithm for the same problem. This result is incomparable to Theorem 4. While the running time is better (and comparable to Williamsâ€™ algorithm mentioned above when ğ‘˜=2) as long as M is subexponential in n, the algorithm is zero-error randomized.Footnote5

Theorem 6
Fix any constant k. There is a zero-error randomized algorithm that solves the #SAT problem for k-PTFs in time poly(ğ‘›,ğ‘€)â‹…2ğ‘›âˆ’ğ‘† where ğ‘†=Î©(ğ‘›1/ğ‘˜) and (n, M) are the parameters of the input k-PTF f.

We then extend this result to a powerful model of circuits called k-PTF circuits, where each gate computes a k-PTF. This model was first studied by Kane, Kabanets and Lu [17] who proved strong average case lower bounds for slightly superlinear-size constant-depth k-PTF circuits. Using these ideas, Kabanets and Lu [18] were able to give a #SAT algorithm for a restricted class of k-PTF circuits, where each gate computes a PTF with a subquadratically many, say ğ‘›1.99, monomials (while the size remains the same, i.e. slightly superlinear).Footnote6 A reason for this restriction on the PTFs was that they did not have an algorithm to handle even a single degree-2 PTF (which can have Î©(ğ‘›2) many monomials).

Building on our #SAT algorithm for k-PTFs and the ideas of [18], we are able to handle general k-PTF circuits of slightly superlinear size. We state these results formally below.

We first define k-PTF circuits formally.

Definition 7
(k-PTF circuits) A k-PTF circuit on n variables is a Boolean circuit on n variables where each gate g of fan-in m computes a fixed k-PTF of its m inputs. The size of the circuit is the number of wires in the circuit, and the depth of the circuit is the longest path from an input to the output gate.Footnote7

The problems we consider is the #SAT problem for k-PTF circuits, defined as follows.

Definition 8
(#SAT problem for k-PTF circuits) The problem is defined as follows.

Input: A k-PTF circuit C, where each gate g is labelled by an integer polynomial that sign-represents the function that is computed by g.

Output: The number of satisfying assignments to C.

We use #SAT(C) to denote this output. We say that the input instance has parameters (n, s, d, M) where n is the number of input variables, s is the size of C, d is the depth of C and M is the maximum over the weights of the degree-k polynomials specifying the k-PTFs in C. We will say that M is the weight of C, denoted by w(C).

We now state our result on #SAT for k-PTF circuits. The following result also implies a zero-error randomized version of Theorem 4.

Theorem 9
Fix any constants k, d. Then the following holds for some constant ğœ€ğ‘˜,ğ‘‘>0 depending on k, d. There is a zero-error randomized algorithm that solves the #SAT problem for k-PTF circuits of size at most ğ‘ =ğ‘›1+ğœ€ğ‘˜,ğ‘‘ with probability at least 1/4 and outputs ? otherwise. The algorithm runs in time poly(ğ‘›,ğ‘€)â‹…2ğ‘›âˆ’ğ‘†, where ğ‘†=ğ‘›ğœ€ğ‘˜,ğ‘‘ and (n, s, d, M) are the parameters of the input k-PTF circuit.

We note that in the Williams [33] framework of proving lower bounds via satisfiability algorithms, zero-error randomized algorithms are as good as deterministic algorithms (as noted already above, even co-non-deterministic algorithms are good enough). However, the above theorem does not imply any new lower bounds, as slightly superlinear-size k-PTF circuits already follows from the work of Kane, Kabanets and Lu [17].

Previous work Satisfiability algorithms for TC0 have been widely investigated. Impagliazzo, Lovett, Paturi and Schneider [14, 16] give algorithms for checking satisfiability of depth-2 threshold circuits with O(n) gates. The former result was improved by Chen and Santhanam [6]. An incomparable result was proved by Williams [36] who obtained algorithms for subexponential-sized circuits from the class ACC0âˆ˜LTF, which is a subclass of subexponential TC0.Footnote8 For the special case of k-PTFs (and generalizations to sparse PTFs over the {0,1} basis) with small weights, a #SAT algorithm was devised by Sakai et al. [31].Footnote9 The high-level idea of our algorithm is the same as theirs.

For general constant-depth threshold circuits, the first satisfiability algorithm was given by Chen, Santhanam and Srinivasan [7]. In their paper, Chen et al. gave the first average case lower bound for TC0 circuits of slightly super linear size ğ‘›1+ğœ€ğ‘‘, where ğœ€ğ‘‘ depends on the depth of the circuit. (These are roughly the strongest size lower bounds we know for general TC0 circuits even in the worst case [15].) Using their ideas, they gave the first (zero-error randomized) improvement to brute-force-search for satisfiability algorithms (and indeed even #SAT algorithms) for constant depth TC0 circuits of size at most ğ‘›1+ğœ€ğ‘‘.

The lower bound results of [7] were extended to the much more powerful class of k-PTF circuits (of roughly the same size as [7]) by Kane, Kabanets and Lu [17]. In a follow-up paper, Kabanets and Lu [18] considered the satisfiability question for k-PTF circuits, and could resolve this question in the special case that each PTF is subquadratically sparse, i.e. has ğ‘›2âˆ’Î©(1) monomials. One of the reasons for this sparsity restriction is that their strategy does not seem to yield a SAT algorithm for a single degree-2 PTF (which is a depth-1 2-PTF circuit of linear size).

Proof outline
For simplicity we discuss SAT algorithms instead of #SAT algorithms.

Satisfiability algorithm for k-PTFs
At a high level, we follow the same strategy as Sakai et al. [31]. Their algorithm uses memoization, which is a standard and very useful strategy for satisfiability algorithms (see, e.g. [29]). Let îˆ¯ be a circuit class and îˆ¯ğ‘› be the subclass of circuits from îˆ¯ that have n variables. Memoization algorithms for îˆ¯-SAT fit into the following two-step template.

Step 1 Solve by brute-force all instances of îˆ¯-SAT where the input circuit ğ¶â€²âˆˆîˆ¯ğ‘š for some suitable ğ‘šâ‰ªğ‘›. (Typically, ğ‘š=ğ‘›ğœ€ for some constant ğœ€.) Usually this takes exp(ğ‘šğ‘‚(1))â‰ª2ğ‘› time.

Step 2 On the input ğ¶âˆˆîˆ¯ğ‘›, set all input variables ğ‘¥ğ‘š+1,â€¦,ğ‘¥ğ‘› to Boolean values and for each such setting, obtain ğ¶â€³âˆˆîˆ¯ğ‘š on m variables. Typically ğ¶â€³ is a circuit for which we have solved satisfiability in Step 1 and hence by a simple table lookup, we should be able to check if ğ¶â€³ is satisfiable in poly(|ğ¶|) time. Overall, this takes time ğ‘‚âˆ—(2ğ‘›âˆ’ğ‘š)â‰ª2ğ‘›.

At first sight, this seems perfect for k-PTFs, since it is a standard result that the number of k-PTFs on m variables is at most 2ğ‘‚(ğ‘šğ‘˜+1) [5]. Thus, Step 1 can be done in 2ğ‘‚(ğ‘šğ‘˜+1)â‰ª2ğ‘› time.

For implementing Step 2, we need to ensure that the lookup (for satisfiability for k-PTFs on m variables) can be done quickly. Unfortunately how to do this is unclear. The following two ways suggest themselves.

Store all polynomials ğ‘ƒâ€²âˆˆâ„¤[ğ‘¥1,â€¦,ğ‘¥ğ‘š] with small coefficients. Since every k-PTF f can be sign-represented by an integer polynomial with coefficients of size 2poly(ğ‘š) [22], this can be done with a table of size 2poly(ğ‘š) and in time 2poly(ğ‘š). When the coefficients are small (say of bit-complexity â‰¤ğ‘›ğ‘œ(1)), then this strategy already yields a #SAT algorithm, as observed by Sakai et al. [31]. Unfortunately, in general, given a restriction ğ‘ƒâ€³âˆˆâ„¤[ğ‘¥1,â€¦,ğ‘¥ğ‘š] of a polynomial ğ‘ƒâˆˆâ„¤[ğ‘¥1,â€¦,ğ‘¥ğ‘›], its coefficients can be much larger (say 2poly(ğ‘›)) and it is not clear how to efficiently find a polynomial with small coefficients that sign-represents the same function.

It is also known that every k-PTF on m variables can be uniquely identified by poly(ğ‘š) numbers of bit-complexity O(m) each [5]: these are called the â€œChow parametersâ€ of f. Again for this representation, it is unclear how to compute efficiently the Chow parameters of the function represented by the restricted polynomial ğ‘ƒâ€³. (Even for an LTF, computing the Chow parameters is as hard as Subset-sum [25].)

We show two different ways of circumventing these problems, using two different ideas from the literature.

Using learning theory We use a beautiful recent result of Kane, Lovett and Moran [19], who show that there is a simple decision tree that, when given as input the coefficients of any degree-k polynomial ğ‘ƒâ€²âˆˆâ„¤[ğ‘¥1,â€¦,ğ‘¥ğ‘š], can determine the sign of the polynomial ğ‘ƒâ€² at all points in {âˆ’1,1}ğ‘š using only poly(ğ‘š) queries to the coefficients of P. Here, each query is a linear inequality on the coefficients of P; such a decision tree is called a linear decision tree.Footnote10

Our strategy is to replace Step 1 with the construction of this linear decision tree (which can be done in exp(ğ‘šğ‘‚(1)) time). At each leaf of the linear decision tree, we replace the truth table of the input polynomial ğ‘ƒâ€² by a single bit that indicates whether ğ‘“â€²=sgn(ğ‘ƒâ€²) is satisfiable or not.

In Step 2, we simply run this decision tree on our restricted polynomial ğ‘ƒâ€³ and obtain the answer to the corresponding satisfiability query in poly(ğ‘š,ğ‘¤(ğ‘ƒâ€³)) time. Note, crucially, that the height of the linear decision tree implied by [19] construction is poly(ğ‘š) and independent of the bit-complexity of the coefficients of the polynomial ğ‘ƒâ€³ (which may be as big as poly(ğ‘›) in our algorithm). This concludes the description of the algorithm for k-PTF.

Using circuit complexity A famous result of Goldmann, HÃ¥stad and Razborov [9] shows that any linear threshold function (with possibly very large weights) can be simulated by a depth-2 threshold circuit with small weights. A simple proof of this was provided by Hofmeister [11]. The basic idea is to use the Chinese Remainder Theorem to reduce checking integer equalities involving very large integers to checking integer equalities with much smaller numbers (by going modulo small primes).

In our setting, this idea allows us to reduce (via a randomized procedure) the problem to be solved in Step 2 to solving satisfiability for k-PTFsFootnote11 on m variables with small coefficients, as long as M is not too large. Since there are not many such PTFs, we can compute and store the answers to all such queries beforehand. This yields the algorithm.

Satisfiability algorithm for k-PTF circuits
For k-PTF circuits, we follow a template set up by the result of Kabanets and Lu [18] on sparse-PTF circuits. We start by describing this template and then describe what is new in our algorithm.

The Kabanetsâ€“Lu algorithm is an induction on the depth d of the circuit (which is a fixed constant). Given as input a depth d k-PTF circuit C on n variables, Kabanets and Lu do the following:

Depth-reduction: In [18], it is shown that on a random restriction that sets all but ğ‘›1âˆ’2ğ›½ variables (here, think of ğ›½ as a small constant, say 0.01) to random Boolean values, the bottom layer of C simplifies in the following sense.

All but ğ‘¡â‰¤ğ‘›ğ›½ gates at the bottom layer become exponentially biased, i.e. on all but ğ›¿=exp(âˆ’ğ‘›Î©(1)) fraction of inputs they are equal to a fixed ğ‘âˆˆ{âˆ’1,1}. Now, for each such biased gate g,  there is a minority value ğ‘ğ‘”âˆˆ{âˆ’1,1} that it takes on very few inputs. [18] show how to enumerate this small number of inputs in ğ›¿â‹…2ğ‘› time and check if there is a satisfying assignment among these inputs. Having ascertained that there is no such assignment, we replace these gates by their majority value and there are only t gates at the bottom layer. At this point, we â€œguessâ€ the output of these t â€œunbiasedâ€ gates and for each such guess ğœâˆˆ{âˆ’1,1}ğ‘¡, we check if there is an assignment that simultaneously satisfies:

(a)
The depth ğ‘‘âˆ’1 circuit ğ¶â€², obtained by setting the unbiased gates to the guess ğœ, is satisfied.

(b)
Each unbiased gate ğ‘”ğ‘– evaluates to the corresponding value ğœğ‘–.

Base case: Continuing this way, we eventually get to a base case which is an AND of sparse PTFs for which there is a satisfiability algorithm using the polynomial method.

In the above algorithm, there are two steps where subquadratic sparsity is crucially used. The first is the minority assignment enumeration algorithm for PTFs, which uses ideas of Chen and Santhanam [6] to reduce the problem to enumerating biased LTFs, which is easy [7]. The second is the base case, which uses a non-trivial polynomial approximation for LTFs [30]. Neither of these results hold for even degree-2 PTFs in general. To overcome this, we do the following.

Enumerating minority assignments Given a k-PTF on m variables that is ğ›¿=exp(âˆ’ğ‘›Î©(1))-close to ğ‘âˆˆ{âˆ’1,1}, we enumerate its minority assignments as follows. First, we set up a linear decision tree as in the k-PTF satisfiability algorithm. Then we set all but ğ‘â‰ˆlog1ğ›¿ variables of the PTF. On most such settings, the resulting PTF becomes the constant function and we can check this using the linear decision tree we created earlier. In this setting, there is nothing to do. Otherwise, we brute-force over the remaining variables to find the minority assignments. Setting parameters suitably, this yields an ğ‘‚(ğ›¿âˆšâ‹…2ğ‘š) time algorithm to find the minority assignments of a k-PTF on m variables which is ğ›¿-close to an explicit constant.

Base case Here, we make the additional observation (which [18] do not need) that the AND of PTFs that is obtained further is small in that it only has slightly superlinear size. Hence, we can apply another random restriction in the style of [18] and using the minority assignment enumeration ideas, reduce it to an AND of a small (say ğ‘›0.1) number of PTFs on ğ‘›0.01 (say) variables. At this point, we can again run the linear decision tree (in a slightly more generalized form) to check satisfiability.

#SAT for k-PTFs: the first algorithm
A result of Kane, Lovett, and Moran [19]
In this subsection, we formally present the result from [19] which we use in the memoization step of our #SAT algorithm in the following subsection. We begin with the following couple of definitions.

Definition 10
(Coefficient vectors) Fix any ğ‘˜,ğ‘šâ‰¥1. There are exactly ğ‘Ÿ=âˆ‘ğ‘˜ğ‘–=0(ğ‘šğ‘–) many multilinear monomials of degree at most k. Any multilinear polynomial ğ‘ƒ(ğ‘¥1,â€¦,ğ‘¥ğ‘š) of degree k can be identified with a list of the coefficients of its monomials in lexicographic order (say) and hence with some vector ğ‘¤âˆˆâ„ğ‘Ÿ. We call w the coefficient vector of P and use coeffğ‘š,ğ‘˜(ğ‘ƒ) to denote this vector. When m, k are clear from context, we will simply use coeff(ğ‘ƒ) instead of coeffğ‘š,ğ‘˜(ğ‘ƒ).

Definition 11
(Linear Decision Trees) A Linear Decision Tree for a function ğ‘“:â„ğ‘Ÿâ†’ğ‘† (for some set S) is a decision tree where each internal node is labelled by a linear inequality, or query, of the form âˆ‘ğ‘Ÿğ‘–=1ğ‘¤ğ‘–ğ‘§ğ‘–â‰¥ğœƒ (here ğ‘§1,â€¦,ğ‘§ğ‘› denote the input variables). Depending on the answer to this linear query, computation proceeds to the left or right child of this node, and this process continues until a leaf is reached, which is labelled with an element of S that is the output of f on the given input.

The following construction of linear decision trees from [19] will be crucial for us.

Theorem 12
There is a deterministic algorithm, which on input a positive integer r and a subset ğ»âŠ†{âˆ’1,1}ğ‘Ÿ, produces a linear decision tree of depth Î”=ğ‘‚(ğ‘Ÿlog2ğ‘Ÿâ‹…log|ğ»|) that computes a function ğ¹:â„ğ‘Ÿâ†’{âˆ’1,1}|ğ»| and has the following properties.

1.
Each linear query has coefficients in {âˆ’2,âˆ’1,0,1,2}.

2.
Given as input any ğ‘¤âˆˆâ„ğ‘Ÿ such that âŸ¨ğ‘¤,ğ‘âŸ©â‰ 0 for all ğ‘âˆˆ{âˆ’1,1}ğ‘Ÿ, F(w) is the truth table of the LTF defined by w (with constant term 0) on inputs from ğ»âŠ†{âˆ’1,1}ğ‘Ÿ.

Moreover, the algorithm runs in time 2ğ‘‚(Î”).

Theorem 1.8 from [19] shows the existence of such a deterministic linear decision tree. However, as noted by an anonymous ITCS 2019 reviewer,Footnote12 their proof can in fact be slightly modified to yield an algorithm to construct it in the claimed running time. For completeness, we give a proof in â€œAppendix Aâ€.

We will need a version of Theorem 12 for evaluating (tuples of) k-PTFs. It follows easily from Theorem 12.

Corollary 13
Fix positive constants k and c. Let ğ‘Ÿ=âˆ‘ğ‘˜ğ‘–=0(ğ‘šğ‘–)=Î˜(ğ‘šğ‘˜) denote the number of coefficients in a degree-k multilinear polynomial in m variables. There is a deterministic algorithm which on input positive integers m and â„“â‰¤ğ‘šğ‘ computes a function ğ¹:â„ğ‘Ÿâ‹…â„“â†’â„• as follows: given as input any â„“-tuple of coefficient vectors ğ‘¤â¯â¯â¯â¯â¯=(coeffğ‘š,ğ‘˜(ğ‘ƒ1),â€¦,coeffğ‘š,ğ‘˜(ğ‘ƒâ„“))âˆˆâ„ğ‘Ÿâ‹…â„“ such that ğ‘ƒğ‘–(ğ‘)â‰ 0 for all ğ‘âˆˆ{âˆ’1,1}ğ‘š, ğ¹(ğ‘¤â¯â¯â¯â¯â¯) is the number of common satisfying assignments to all the k-PTFs on {âˆ’1,1}ğ‘š sign-represented by ğ‘ƒ1,â€¦,ğ‘ƒâ„“. Further, the algorithm runs in time 2ğ‘‚(Î”), where Î”=ğ‘‚(â„“â‹…ğ‘šğ‘˜+1log2ğ‘š).

Proof
For each ğ‘âˆˆ{âˆ’1,1}ğ‘š, define evalğ‘âˆˆ{âˆ’1,1}ğ‘Ÿ to be the vector of all evaluations of multilinear monomials of degree at most k, taken in lexicographic order, on the input b. Define ğ»âŠ†{âˆ’1,1}ğ‘Ÿ to be the set {evalğ‘ | ğ‘âˆˆ{âˆ’1,1}ğ‘š}. Clearly, |ğ»|â‰¤2ğ‘š. Further, note that given any polynomial ğ‘ƒ(ğ‘¥1,â€¦,ğ‘¥ğ‘š) of degree at most k, the truth table of the k-PTF sign-represented by P is given by the evaluation of the LTF represented by coeff(ğ‘ƒ) at the points in H. Our aim, therefore, is to evaluate the LTFs corresponding to coeff(ğ‘ƒ1),â€¦,coeff(ğ‘ƒâ„“) at all the points in H.

For each i, we use the deterministic algorithm from Theorem 12 to produce a decision tree î‰€ğ‘– that evaluates the Boolean function ğ‘“ğ‘–:{âˆ’1,1}ğ‘šâ†’{âˆ’1,1} sign-represented by ğ‘ƒğ‘– (or equivalently, evaluating the LTF corresponding to coeff(ğ‘ƒğ‘–) at all points in H). Note that î‰€ğ‘– has depth ğ‘‚(ğ‘šğ‘˜log2ğ‘šâ‹…log(2ğ‘š))=ğ‘‚(ğ‘šğ‘˜+1log2ğ‘š). The final tree î‰€ is obtained by simply running î‰€1,â€¦,î‰€â„“ in order, which is of depth ğ‘‚(â„“â‹…ğ‘šğ‘˜+1log2ğ‘š). Observe that the tree î‰€ outputs the number of common satisfying assignments to all the ğ‘“ğ‘–.

The claim about the running time follows from the analogous claim in Theorem 12 and the fact that the number of common satisfying assignments to all the ğ‘“ğ‘– can be computed from the truth tables in 2ğ‘‚(ğ‘š) time. This completes the proof. â—»

The #SAT algorithm
We are now ready to prove Theorem 4. We first state the algorithm, which follows a standard memoization idea (see, e.g. [29]). We assume that the input is a polynomial ğ‘ƒâˆˆâ„¤[ğ‘¥1,â€¦,ğ‘¥ğ‘›] of degree at most k that sign-represents a Boolean function f on n variables. The parameters of the instance are assumed to be (n, M) (recall from Definition 2 that ğ‘€=ğ‘¤(ğ‘ƒ) is the bit-complexity of the sum of the absolute values of all the coefficients of P). Set ğ‘š=ğ‘›1/(ğ‘˜+1)/logğ‘›.

Algorithm îˆ­

1.
Use the algorithm from Corollary 13 with â„“=1 to construct a deterministic linear decision tree T such that on any input polynomial ğ‘„(ğ‘¥1,â€¦,ğ‘¥ğ‘š) (or more precisely coeffğ‘š,ğ‘˜(ğ‘„)) of degree at most k that sign-represents a k-PTF g on m variables, T computes the number of satisfying assignments to g.

2.
Set ğ‘=0 (N will ultimately be the number of satisfying assignments to f).

3.
For each setting ğœâˆˆ{âˆ’1,1}ğ‘›âˆ’ğ‘š to the variables ğ‘¥ğ‘š+1,â€¦,ğ‘¥ğ‘›, do the following:

(a)
Compute the polynomial ğ‘ƒğœ obtained by substituting the variables ğ‘¥ğ‘š+1,â€¦,ğ‘¥ğ‘› accordingly in P.

(b)
Run T on coeff(ğ‘ƒğœ) and compute its output ğ‘ğœ, the number of satisfying assignments to ğ‘ƒğœ. Add this to the current value of N.

4.
Output N.

Correctness It is clear from Corollary 13 (invoked for â„“=1) and step 3b that algorithm îˆ­ outputs the correct number of satisfying assignments to f.

Running time We show that the running time of algorithm îˆ­ is poly(ğ‘›,ğ‘€)â‹…2ğ‘›âˆ’ğ‘š. First note that by Corollary 13, the construction of a linear decision tree T takes 2ğ‘‚(Î“) time, where Î“=ğ‘šğ‘˜+1log2ğ‘š, and hence, step 1 takes 2ğ‘‚(Î“) time. Next, for a setting ğœâˆˆ{âˆ’1,1}ğ‘›âˆ’ğ‘š to the variables ğ‘¥ğ‘š+1,â€¦,ğ‘¥ğ‘›, computing ğ‘ƒğœ and constructing the vector coeff(ğ‘ƒğœ) takes only poly(ğ‘›,ğ‘€) time. Recall that the depth of T is ğ‘‚(Î“) and thus, on input vector coeff(ğ‘ƒğœ), each of whose entries has bit complexity at most M, it takes time ğ‘‚(Î“)â‹…poly(ğ‘€,ğ‘›) to run T and obtain the output ğ‘ğœ. Therefore, step 3 takes poly(ğ‘›,ğ‘€)â‹…2ğ‘›âˆ’ğ‘š time. Finally, the claim about the total running time of algorithm îˆ­ follows at once when we observe that for the setting ğ‘š=(ğ‘›/log3ğ‘›)1/ğ‘˜+1, Î“=ğ‘‚(ğ‘›/logğ‘›)=ğ‘œ(ğ‘›).

#SAT for k-PTFs: the second algorithm
Here, we present an alternate approach to #SAT for k-PTFs. This approach uses memoization as before, but the idea now will be to first reduce the size of the coefficients, by going modulo small primes. A major hurdle with this is that PTFs use inequalities, which do not gel well with this operation. Hence, we will first transform our PTFs into a similar model which uses equalities, namely Exact Polynomial Threshold Functions.

Definition 14
(Exact Polynomial Threshold Functions [12, 13]) A Boolean function ğ¸:{âˆ’1,1}ğ‘›â†’{âˆ’1,1} is called an Exact Polynomial Threshold Function of degree ğ‘˜, or a ğ‘˜-EPTF, if there exists a multilinear polynomial ğ‘ƒâˆˆâ„[ğ‘¥1,â€¦,ğ‘¥ğ‘›] of degree ğ‘˜ such that for all ğ‘âˆˆ{âˆ’1,1}ğ‘›, ğ¸(ğ‘)=âˆ’1 if and only if ğ‘ƒ(ğ‘)=0. We refer to such a ğ‘ƒ as a representation of ğ¸. When ğ‘˜=1, we call ğ¸ an Exact Threshold Function, or ETF for short.

The main idea in this algorithm is to first convert the given PTF to a disjoint OR of EPTFs. To do this, we follow Hofmeister [11], who showed how to do this for degree one. His proof is constructive and can easily be adapted to higher degrees.

Lemma 15
(Implicit in [11]) Let ğ‘“:{âˆ’1,1}ğ‘›â†’{âˆ’1,1} be a ğ‘˜-PTF sign-represented by a polynomial ğ‘ƒâˆˆâ„¤[ğ‘¥1,â€¦,ğ‘¥ğ‘›] with parameters (ğ‘›,ğ‘€). Then it can be written as,

ğ‘“=â‹ğ‘–=1â„ğ¸ğ‘–
where â„=ğ‘‚(ğ‘€ğ‘›2ğ‘˜) and each ğ¸ğ‘– is a ğ‘˜-EPTF that can be represented by a degree k polynomial with weight ğ‘‚(ğ‘€+ğ‘˜logğ‘›).

Moreover, the OR is a disjoint OR i.e. at most one of the ğ¸ğ‘–s can evaluate to TRUE for a given input.

Finally, this transformation is constructive in the following sense. There is a deterministic algorithm running in poly(ğ‘›,ğ‘€) time that, on input an integer polynomial ğ‘ƒâˆˆâ„¤[ğ‘¥1,â€¦,ğ‘¥ğ‘›] with parameters (n, M) representing f, produces polynomials ğ‘ƒ1,â€¦,ğ‘ƒâ„ of weight ğ‘‚(ğ‘€+ğ‘˜logğ‘›) where ğ‘ƒğ‘– represents ğ¸ğ‘– for each ğ‘–âˆˆ[â„].

We include a proof of this lemma in â€œAppendix Bâ€ for completeness.

One of the bottlenecks to a brute force approach to satisfiability directly using this lemma is the size of the coefficients. For this reason, instead of evaluating an EPTF as is, we evaluate it modulo many small primes. We first define this modular version of EPTFs.

Definition 16
(modular EPTFs) Let ğ‘ƒâˆˆâ„¤[ğ‘¥1,â€¦,ğ‘¥ğ‘›] be any integer polynomial of degree at most k. For a prime p, we define the Boolean function ğ¸ğ‘ğ‘ƒ:{âˆ’1,1}ğ‘›â†’{âˆ’1,1} such that for all a, ğ¸ğ‘ğ‘ƒ(ğ‘)=âˆ’1 if and only if ğ‘ƒ(ğ‘)â‰¡0modğ‘.

We call such a Boolean function ğ¸ğ‘ğ‘ƒ a p-modular k-EPTF.

Evaluating a polynomial modulo small enough primes will reduce the size of the coefficients but it will also introduce errors. However, if we evaluate modulo a random prime among sufficiently many primes, the error probability can be shown to be small. The underlying principle is the well-known Chinese Remainder Theorem, which we state below.

Theorem 17
(Chinese Remainder Theorem) Let {ğ‘1,â€¦,ğ‘â„“} be a set of distinct primes, and ğ‘âˆˆâ„¤. Then the following are equivalent:

for all 1â‰¤ğ‘–â‰¤â„“, ğ‘â‰¡0modğ‘ğ‘–.

ğ‘â‰¡0modâˆâ„“ğ‘–=1ğ‘ğ‘–.

In particular if ğ‘â‰ 0 and ğ‘â‰¡0(modğ‘ğ‘–) for each ğ‘–âˆˆ[â„“], then â„“â‰¤log2|ğ‘|.

Now we are ready to describe the algorithm in detail. The input, as earlier, will be a polynomial ğ‘ƒâˆˆâ„¤[ğ‘¥1,â€¦,ğ‘¥ğ‘›] of degree at most ğ‘˜ that sign-represents a Boolean function ğ‘“ on ğ‘› variables. The parameters of the instance are taken to be (ğ‘›,ğ‘€). We assume that all monomials of the same degree are ordered among themselves using a predetermined ordering. One such ordering is the lexicographic ordering.

Algorithm îˆ¹îˆ»îˆ°ğ‘:

Set ğ‘š=ğ›¿ğ‘›1/ğ‘˜ and ğ´=ğ›½2ğ‘š for a small enough constant ğ›¿ and a large enough constant ğ›½.

1.
Using Lemma 15, decompose f as a disjoint OR of k-EPTFs

ğ‘“(ğ‘‹)=â‹ğ‘–=1â„ğ¸ğ‘–(ğ‘‹).
Here â„=ğ‘‚(ğ‘€ğ‘›2ğ‘˜)=poly(ğ‘›,ğ‘€) and each ğ¸ğ‘– is a ğ‘˜-EPTF represented by a degree-k polynomial ğ‘ƒğ‘– with weight at most ğ‘€â€²=ğ‘‚(ğ‘€+logğ‘›).

2.
We now describe the memoization step. For each prime ğ‘âˆˆ[1,ğ‘€â€²ğ´log(ğ‘€â€²ğ´)], we do the following. For each ğ‘–âˆˆ[â„], consider all degree-k integer polynomials in ğ‘¥1,â€¦,ğ‘¥ğ‘š such that the following holds.

The coefficients of the monomials with degree exactly ğ‘˜ are chosen by reducing the corresponding coefficients of the polynomial ğ‘ƒğ‘– modulo p (to obtain a non-negative integer less than p).

The coefficients of the monomials of degree less than k are allowed to be any non-negative integers less than p. Let îˆ¼ğ‘–,ğ‘ be the set of all such polynomials.

Each polynomial ğ‘„âˆˆîˆ¼ğ‘–,ğ‘ defines a p-modular k-EPTF ğ¸ğ‘ğ‘„ of m variables. For each such Q, use brute force over all m input variables and count the number of satisfying assignments of ğ¸ğ‘ğ‘„. Store the results in a table.

3.
Set ğ‘=0. (ğ‘ will ultimately be the number of satisfying assignments to ğ‘“).

4.
For each ğœ:{ğ‘¥ğ‘š+1,â€¦,ğ‘¥ğ‘›}â†’{âˆ’1,1}, for each ğ‘–âˆˆ[â„], do the following. For each ğ‘—âˆˆ[2ğ‘›], do the following.

(a)
Choose a uniformly random prime ğ‘ğ‘—âˆˆ[1,ğ‘€â€²ğ´log(ğ‘€â€²ğ´)].

(b)
Compute ğ‘ƒğ‘–,ğœ, the restriction of ğ‘ƒğ‘– given by the partial assignment ğœ. (Note that ğ‘ƒğ‘–,ğœ is a polynomial in ğ‘¥1,â€¦,ğ‘¥ğ‘š. Further, since ğ‘ƒğ‘– has degree at most k, the coefficient of any monomial of degree exactly k in ğ‘ƒğ‘–,ğœ is the same as it is in ğ‘ƒğ‘–.)

(C)
Let Q be the polynomial in îˆ¼ğ‘–,ğ‘ obtained by reducing the coefficients of ğ‘ƒğ‘– modulo ğ‘ğ‘—. Look up the number of satisfying assignments of ğ¸ğ‘ğ‘—ğ‘„ in the table constructed in Step 2. Let this be ğ‘ğ‘–,ğœ,ğ‘—.

Arrange ğ‘ğ‘–,ğœ,1,â€¦,ğ‘ğ‘–,ğœ,2ğ‘› in increasing order and let ğ‘ğ‘–,ğœ be the smallest value. Add ğ‘ğ‘–,ğœ to N.

5.
Output ğ‘.

We now prove Theorem 6 from the introduction. Note that Theorem 6 is trivial when ğ‘€=2Î©(ğ‘›1/ğ‘˜) since #SAT for k-PTFs can be solved in time poly(ğ‘›,ğ‘€)2ğ‘› by a trivial brute-force algorithm. Hence, from now on, we assume that ğ‘€â‰¤2ğœ€ğ‘›1/ğ‘˜ for a suitably small constant ğœ€. The following statement now almost implies Theorem 6, except for the zero-error criterion.

Theorem 18
The following holds for large enough constant ğ›½ and small enough constants ğœ€,ğ›¿. îˆ¹îˆ»îˆ°ğ‘ is a randomized algorithm, which on input a polynomial ğ‘ƒ of degree ğ‘˜ with parameters (ğ‘›,ğ‘€) with ğ‘€â‰¤2ğœ€ğ‘›1/ğ‘˜, outputs the number of satisfying assignments for ğ‘“=sgn(ğ‘ƒ) with probability 1âˆ’ğ‘œ(1). The algorithm runs in time at most 2ğ‘›âˆ’Î©(ğ‘›1/ğ‘˜).

Proof
Correctness Recall that f is decomposed as a disjoint OR of k-EPTFs ğ¸1,â€¦,ğ¸â„ represented by polynomials ğ‘ƒ1,â€¦,ğ‘ƒâ„ in Step 1. For any assignment ğœ considered in Step 4, we still have that the corresponding relation between the restrictions ğ‘“ğœ and ğ¸1,ğœ,â€¦,ğ¸â„,ğœ. It suffices to show that in Step 4, for each i and ğœ, ğ‘ğ‘–,ğœ equals the number of satisfying assignments of ğ¸ğ‘–,ğœ with high probability.

To this end, we claim that for any restriction ğœ on the last ğ‘›âˆ’ğ‘š variables and any ğ‘–âˆˆ[â„] the following holds.

Pr[ğ‘ğ‘–,ğœ= number of satisfying assignments of ğ¸ğ‘–,ğœ]â‰¥1âˆ’14ğ‘›
(1)
To show this we proceed as follows. Note that for each ğ‘—âˆˆ[2ğ‘›], ğ‘ğ‘–,ğœ,ğ‘— is equal to the number of ğ‘âˆˆ{âˆ’1,1}ğ‘š such that ğ‘ƒğ‘–,ğœ(ğ‘)â‰¡0(modğ‘ğ‘—). We call ğ‘ğ‘— a bad prime for a if ğ‘ƒğ‘–,ğœ(ğ‘) is non-zero but ğ‘ƒğ‘–,ğœ(ğ‘)â‰¡0(modğ‘ğ‘—), i.e a is not a satisfying assignment of ğ¸ğ‘–,ğœ, but under the modulo operation, it gets counted as a satisfying assignment. Further, we say that ğ‘ğ‘— is a bad prime if it is bad for some ğ‘âˆˆ{âˆ’1,1}ğ‘š, i.e. modulo ğ‘ğ‘— some non-satisfying assignment gets counted as a satisfying assignment. Note that ğ‘ğ‘–,ğœ,ğ‘— is always at least the number of satisfying assignments of ğ¸ğ‘–,ğœ, with equality occurring if ğ‘ğ‘— is not a bad prime.

We now bound the probability that ğ‘ğ‘— is a bad prime. Fix any ğ‘âˆˆ{âˆ’1,1}ğ‘š. As ğ‘ƒğ‘– has weight at most ğ‘€â€², we have |ğ‘ƒğ‘–,ğœ(ğ‘)|â‰¤2ğ‘€â€². Using Theorem 17, the number of primes that are bad for a is bounded by ğ‘€â€². Hence the total number of bad primes is at most ğ‘€â€²2ğ‘š. On the other hand, the total number of primes in the range [1,ğ‘€â€²ğ´log(ğ‘€â€²ğ´)] is at least Î©(ğ‘€â€²ğ´) by the Prime Number theorem. For a large enough constant ğ›½, this is at least 4ğ‘€â€²2ğ‘š. Thus, the probability that ğ‘ğ‘— is a bad prime is at most 1/4.

Since ğ‘ğ‘–,ğœ is the smallest of all the ğ‘ğ‘–,ğœ,ğ‘— for ğ‘—âˆˆ[2ğ‘›], we see that ğ‘ğ‘–,ğœ is equal to the number of satisfying assignments of ğ¸ğ‘–,ğœ unless every ğ‘ğ‘— (ğ‘—âˆˆ[2ğ‘›]) is a bad prime. The probability of this is at most (1/4)ğ‘›. This proves (1).

By a union bound, the probability that there exist ğœ and i such that ğ‘ğ‘–,ğœ is not equal to the number of satisfying assignments of ğ¸ğ‘–,ğœ is at most â„2ğ‘›âˆ’ğ‘š/4ğ‘›=ğ‘‚(ğ‘€ğ‘›2ğ‘˜2ğ‘›âˆ’ğ‘š/4ğ‘›)=ğ‘œ(1), where we have used the upper bound on M from the statement of the theorem. Hence with probability 1âˆ’ğ‘œ(1), the algorithm correctly computes the number of satisfying assignments of ğ¸ğ‘–,ğœ for each ğœ,ğ‘–. In this case the algorithm correctly returns the number of satisfying assignments of f.

Running time The running time of the algorithm is dominated by the running times of Step 2 and Step 4.

In Step 2, the number of primes in the specified range is ğ‘‚(ğ‘€â€²2ğ‘š). For a given prime p and ğ‘–âˆˆ[â„], the set îˆ¼ğ‘–,ğ‘ has size at most (ğ‘1ğ‘€â€²2ğ‘š)ğ‘šğ‘˜âˆ’1 for some positive constant ğ‘1. Hence the number of modular ğ‘˜-EPTFs that are considered is at most ğ‘‚(â„ğ‘€â€²2ğ‘š)â‹…(ğ‘1ğ‘€â€²2ğ‘š)ğ‘šğ‘˜âˆ’1=2ğ‘‚(ğ‘šğ‘˜+ğ‘šğ‘˜âˆ’1logğ‘€â€²). For each such EPTF, it takes time 2ğ‘šâ‹…poly(ğ‘›,ğ‘€â€²)=2ğ‘šâ‹…poly(ğ‘›,ğ‘€) to brute force over all possible assignments. Hence the total time needed to execute this step is 2ğ‘‚(ğ‘šğ‘˜+ğ‘šğ‘˜âˆ’1logğ‘€â€²)â‹…poly(ğ‘›,ğ‘€)â‰¤2ğ‘›/2 for our choice of parameters and suitably small ğœ€,ğ›¿.

For Step 4, the total running time is 2ğ‘›âˆ’ğ‘špoly(ğ‘›,ğ‘€). Hence, for the given choice of parameters, and using ğ‘€â‰¤2ğœ€ğ‘›1/ğ‘˜ for suitably small ğœ€, the final running time is 2ğ‘›âˆ’Î©(ğ‘›1/ğ‘˜). â—»

Making the algorithm zero-error The above almost implies Theorem 6 with the only exception being that the algorithm is not zero-error. However, there is a simple and elegant fix for this, as was pointed out to us by a anonymous reviewer.

Note that the above algorithm always returns an estimate that is at least the number of satisfying assignments of f, as the only source of error is when an non-satisfying assignment is incorrectly counted as a satisfying assignment at the time of computing ğ‘ğ‘–,ğœ for some ğ‘–âˆˆ[â„],ğœâˆˆ{âˆ’1,1}ğ‘›âˆ’ğ‘š.

So, to get the zero-error algorithm, we proceed as follows. We run the above algorithm on polynomials P and âˆ’ğ‘ƒ, which represent Boolean functions f and the negation of f respectively. The algorithm returns estimates ğ‘1 and ğ‘2, where ğ‘1â‰¥ğ‘ğ‘“ and ğ‘2â‰¥ğ‘Â¬ğ‘“ and ğ‘ğ‘” denotes the number of satisfying assignments of g. Note that both inequalities are equalities precisely when ğ‘1+ğ‘2=2ğ‘›, and this happens with probability 1âˆ’ğ‘œ(1). Hence, the algorithm simply checks that ğ‘1+ğ‘2=2ğ‘› and returns ğ‘1 in this case. Otherwise, the algorithm returns ?.

Constant-depth circuits with PTF gates
In this section we give an algorithm for counting the number of satisfying assignments for a k-PTF circuit of constant depth and slightly superlinear size. We begin with some definitions.

Definition 19
Let ğ›¿â‰¤1 be any parameter. Two Boolean functions f, g are said to be ğ›¿-close if Prğ‘¥[ğ‘“(ğ‘¥)â‰ ğ‘”(ğ‘¥)]â‰¤ğ›¿.

A k-PTF f specified by a polynomial P is said to be ğ›¿-close to an explicit constant if it is ğ›¿-close to a constant and such a constant can be computed efficiently, i.e. poly(ğ‘›,ğ‘€), where n is the number of variables in P and w(P) is at most M.

Definition 20
For a Boolean function ğ‘“:{âˆ’1,1}ğ‘›â†’{âˆ’1,1}, the majority value of f is the bit value ğ‘âˆˆ{âˆ’1,1} which maximizes Prğ‘¥[ğ‘“(ğ‘¥)=ğ‘] and the bit value âˆ’ğ‘ is said to be its minority value.

For a Boolean function f with majority value b, an assignment ğ‘¥âˆˆ{âˆ’1,1}ğ‘› is said to be a majority assignment if ğ‘“(ğ‘¥)=ğ‘ and a minority assignment otherwise.

Definition 21
Given a k-PTF f on n variables specified by a polynomial P, a parameter ğ‘šâ‰¤ğ‘› and a partial assignment ğœâˆˆ{âˆ’1,1}ğ‘›âˆ’ğ‘š on ğ‘›âˆ’ğ‘š variables, let ğ‘ƒğœ be the polynomial obtained by substituting the variables in P according to ğœ. If P has parameters (n, M) then ğ‘ƒğœ has parameters (m, M). For a k-PTF circuit C, ğ¶ğœ is defined similarly. If C has parameters (n, s, d, M) then ğ¶ğœ has parameters (m, s, d, M).

Outline of the #SAT procedure For designing a #SAT algorithm for k-PTF circuits, we use the generic framework developed by Kabanets and Lu [18] with some crucial modifications.

Given a k-PTF circuit C on n variables of depth d we want to count the number of satisfying assignments ğ‘âˆˆ{âˆ’1,1}ğ‘› such that ğ¶(ğ‘)=âˆ’1. We in fact solve a slightly more general problem. Given (ğ¶,îˆ¼), where C is a small k-PTF circuit of depth d and îˆ¼ is a set of k-PTF functions, such that âˆ‘ğ‘“âˆˆîˆ¼fan-in(ğ‘“) is small, we count the number of assignments that simultaneously satisfy C and all the function in îˆ¼.

At the core of the algorithm that solves this problem, Algorithm îˆ®, is a recursive procedure îˆ­5, which works as follows: on inputs (ğ¶,îˆ¼) it first applies a simplification step that outputs â‰ª2ğ‘› instances of the form (ğ¶â€²,îˆ¼â€²) such that

Both ğ¶â€² and functions in îˆ¼â€² are on ğ‘šâ‰ªğ‘› variables.

The sets of satisfying assignments of these instances â€œalmostâ€ partition the set of satisfying assignments of (ğ¶,îˆ¼).

With all but very small probability the bottom layer of ğ¶â€² has the following nice structure.

At most n gates are ğ›¿-close to an explicit constant. We denote this set of gates by B (as we will simplify them by setting them to the constant they are close to).

At most ğ‘›ğ›½ğ‘‘ gates are not ğ›¿-close to an explicit constant. We denote these gates by G (as we will simplify them by â€œguessingâ€ their values).

There is a small set of satisfying assignments that are not covered by the satisfying assignments of (ğ¶â€²,îˆ¼â€²) but we can count these assignments with a brute-force algorithm that does not take too much time.

For each ğ¶â€² with this nice structure, then we try to use this structure to create ğ¶â€³ which has depth ğ‘‘âˆ’1. Suppose we reduce the depth as follows:

Set all the gates in B to the values that they are biased towards.

Try all the settings of the values that the gates in G can take, thereby from ğ¶â€² creating possibly 2ğ‘›ğ›½ğ‘‘ instances (ğ¶â€³,îˆ¼â€²).

(ğ¶â€³,îˆ¼â€²) now is an instance where ğ¶â€³ has depth ğ‘‘âˆ’1. Unfortunately, by simply setting biased gates to the values they are biased towards, we may miss out on the minority assignments to these gates which could eventually satisfy ğ¶â€². We design a subroutine îˆ­3 to precisely handle this issue, i.e. to keep track of the number of minority assignments, say ğ‘ğ¶â€². This part of our algorithm is completely different from that of [18], which only works for subquadratically sparse PTFs.

Once îˆ­3 has computed ğ‘ğ¶â€², i.e. the number of satisfying assignments among the minority assignments, we now need to only count the number of satisfying assignments among the rest of the assignments.

To achieve this we use an idea similar to that in [7, 18], which involves appending îˆ¼â€² with a few more k-PTFs (this forces the biased gates to their majority values). This gives say a set îˆ¼Ìƒ â€². Similarly, while setting gates in G to their guessed values, we again use the same idea to ensure that we are counting satisfying assignments consistent with the guessed values, once again updating îˆ¼Ìƒ â€² to a new set îˆ¼â€³. This creates instances of the form (ğ¶â€³,îˆ¼â€³), where the depth of ğ¶â€³ is ğ‘‘âˆ’1.

This way, we iteratively decrease the depth of the circuit by 1. Finally, we have instances (ğ¶â€³,îˆ¼â€³) such that the depth of ğ¶â€³ is 1, i.e. it is a single k-PTF, say h. At this stage we solve #SAT(ğ¶Ìƒ ), where ğ¶Ìƒ =â„âˆ§â‹€ğ‘“âˆˆîˆ¼â€³ğ‘“. This is handled in a subroutine îˆ­4. Here too our algorithm differs significantly from [18].

In what follows we will prove Theorem 9. In order to do so, we will set up various subroutines îˆ­1,îˆ­2,îˆ­3,îˆ­4,îˆ­5 designed to accomplish certain tasks and combine them together at the end to finally design algorithm îˆ® for the #SAT problem for k-PTF circuits.

îˆ­1 will be an oracle, used in other routines, which will compute the number of common satisfying assignments for small AND of PTFs on few variables (using the same idea as in the algorithm for #SAT for k-PTFs). îˆ­2 will be a simplification step, which will allow us to argue about some structure in the circuit (this algorithm is from [18]). It will make many gates at the bottom of the circuit ğ›¿-close to a constant, thus simplifying it. îˆ­3 will be used to count minority satisfying assignments for a bunch of PTFs that are ğ›¿-close to an explicit constant, i.e. assignments which cause at least one of the PTFs to evaluate to its minority value. îˆ­4 will be a general base case of our algorithm, which will count satisfying assignments for AND of superlinearly many PTFs, by first using îˆ­2 to simplify the circuit, then reducing it to the case of small AND of PTFs and then using îˆ­1. îˆ­5 will be a recursive procedure, which will use îˆ­2 to first simplify the circuit, and then convert it into a circuit of lower depth, finally making a recursive call on the simplified circuit.

Parameter setting Let d be a constant. Let A, B be two fixed absolute large constants. Let ğœ=min(1,ğ´/2ğµğ‘˜2). For each 2â‰¤ğ‘–â‰¤ğ‘‘, let ğ›½ğ‘–=ğ´â‹…ğœ€ğ‘– and ğœ€ğ‘–=(ğœ10ğ´(ğ‘˜+1))ğ‘–. Choose ğ›½1=1/10 and ğœ€1=1/10ğ´.

Oracle access to a subroutine Let îˆ­1(ğ‘›â€²,ğ‘ ,ğ‘“1,â€¦,ğ‘“ğ‘ ) denote a subroutine with the following specification. Here, n is the number of variables in the original input circuit.

Input: AND of k-PTFs, say ğ‘“1,â€¦,ğ‘“ğ‘  specified by polynomials ğ‘ƒ1,â€¦,ğ‘ƒğ‘  respectively, such that ğ‘ â‰¤ğ‘›0.1 and for each ğ‘–âˆˆ[ğ‘ ], ğ‘“ğ‘– is defined over ğ‘›â€²â‰¤ğ‘›1/(2(ğ‘˜+1)) variables and ğ‘¤(ğ‘ƒğ‘–)â‰¤ğ‘€.

Output: #{ğ‘âˆˆ{âˆ’1,1}ğ‘›â€²âˆ£âˆ€ğ‘–âˆˆ[ğ‘ ],ğ‘ƒğ‘–(ğ‘)=âˆ’1}.

In what follows, we will assume that we have access to the above subroutine îˆ­1. We will set up such an oracle and show that it answers any call to it in time poly(ğ‘›,ğ‘€) in Sect. 4.5.

Simplification of a k-PTF circuit
For any 1>ğœ€â‰«(logğ‘›)âˆ’1, let ğ›½=ğ´ğœ€ and ğ›¿=exp(âˆ’ğ‘›ğ›½/ğµâ‹…ğ‘˜2), where A and B are constants. Note that it is these constants A, B we use in the parameter settings paragraph above. Let îˆ­2(ğ¶,ğ‘‘,ğ‘›,ğ‘€) be the following subroutine.

Input: k-PTF circuit C of depth d on n variables with size ğ‘›1+ğœ€ and weight M.

Output: A decision tree TDT which is a complete binary tree of depth ğ‘›âˆ’ğ‘›1âˆ’2ğ›½ such that for a uniformly random leaf ğœâˆˆ{âˆ’1,1}ğ‘›âˆ’ğ‘›1âˆ’2ğ›½, the corresponding circuit ğ¶ğœ is a good circuit with probability 1âˆ’exp(âˆ’ğ‘›ğœ€), where ğ¶ğœ is called good if its bottom layer has the following structure:

there are at most n gates which are ğ›¿-close to an explicit constant. Let ğµğœ denote this set of gates.

there are at most ğ‘›ğ›½ gates that are not ğ›¿-close to an explicit constant. Let us denote this set of gates by ğºğœ.

In [18], such a subroutine îˆ­2(ğ¶,ğ‘‘,ğ‘›,ğ‘€) was designed. Specifically, they proved the following theorem.

Theorem 22
(Kabanets and Lu [18]) There is a zero-error randomized algorithm îˆ­2(ğ¶,ğ‘‘,ğ‘›,ğ‘€) that runs in time poly(ğ‘›,ğ‘€)â‹…ğ‘‚(2ğ‘›âˆ’ğ‘›1âˆ’2ğ›½) and outputs a decision tree as described above with probability at least 1âˆ’1/210ğ‘› (and outputs ? otherwise). Moreover, given a good ğ¶ğœ, there is a deterministic algorithm that runs in time poly(ğ‘›,ğ‘€) which computes ğµğœ and ğºğœ.

Remark 23
In [18], it is easy to see that the probability of outputting ? is at most 1/2. To bring down this probability to 1/210ğ‘›, we run their procedure in parallel 10n times, and output the first tree that is output by the algorithm. The probability that no such tree is output is 1/210ğ‘›.

Remark 24
In designing the above subroutine in [18], they consider a more general class of polynomially sparse-PTF circuits (i.e. each gate computes a PTF with polynomially many monomials) as opposed to the k-PTF circuits we consider here. Under this weaker assumption, they get that ğ›¿=exp(âˆ’ğ‘›Î©(ğ›½3)). However, by redoing their analysis for degree k-PTFs, it is easy to see that ğ›¿ could be set to exp(âˆ’ğ‘›ğ›½/ğµâ‹…ğ‘˜2) for some constant B. Under this setting of ğ›¿, we get exactly the same guarantees.

Further, while the statement of the result in [18] does not guarantee that the decision tree TDT obtained is a complete binary tree, it is easy to see that this follows from their analysis (and the analysis from [7] that is used as a black box).

In this sense, the above theorem statement is a slight restatement of [18, Lemma 11].

Enumerating the minority assignments
We now design an algorithm îˆ­3(ğ‘š,â„“,ğ›¿,ğ‘”1,â€¦,ğ‘”â„“), which has the following behaviour.

Input: parameters ğ‘šâ‰¤ğ‘›,â„“,ğ›¿ such that ğ›¿âˆˆ[exp(âˆ’ğ‘š1/10(ğ‘˜+1)),1], â„“â‰¤ğ‘š2, k-PTFs ğ‘”1,ğ‘”2,â€¦,ğ‘”â„“ specified by polynomials ğ‘ƒ1,â€¦,ğ‘ƒâ„“ on m variables (ğ‘¥1,â€¦,ğ‘¥ğ‘š) each of weight at most M and which are ğ›¿-close to âˆ’1.

Oracle access to: îˆ­1.

Output: The set of all ğ‘âˆˆ{âˆ’1,1}ğ‘š such that âˆƒğ‘–âˆˆ[â„“] for which ğ‘ƒğ‘–(ğ‘)>0.

Lemma 25
There is a deterministic algorithm îˆ­3(ğ‘š,â„“,ğ›¿,ğ‘”1,â€¦,ğ‘”â„“) as specified above that runs in time poly(ğ‘š,ğ‘€)â‹…ğ›¿âˆšâ‹…2ğ‘š.

Proof
We start with the description of the algorithm.

îˆ­3(ğ¦,â„“,ğ›¿,ğ 1,â€¦,ğ â„“)

1.
Set ğ‘=12log1ğ›¿â‰¤ğ‘š2 and let îˆº=âˆ…. (îˆº will eventually be the collection of minority assignments i.e. all ğ‘âˆˆ{âˆ’1,1}ğ‘š such that âˆƒğ‘–âˆˆ[â„“] for which ğ‘ƒğ‘–(ğ‘)>0.)

2.
For each setting ğœŒâˆˆ{âˆ’1,1}ğ‘šâˆ’ğ‘ to the variables ğ‘¥ğ‘+1,â€¦,ğ‘¥ğ‘š, do the following:

(a)
Construct the restricted polynomials ğ‘ƒ1,ğœŒ,â€¦,ğ‘ƒâ„“,ğœŒ. Let ğ‘”ğ‘–,ğœŒ=sgn(ğ‘ƒğ‘–,ğœŒ) for ğ‘–âˆˆ[â„“].

(b)
Using oracle îˆ­1(ğ‘,1,âˆ’ğ‘”ğ‘–,ğœŒ), check for each ğ‘–âˆˆ[â„“] if ğ‘”ğ‘–,ğœŒ is the constant function âˆ’1 by checking if the output of the oracle on the input âˆ’ğ‘”ğ‘–,ğœŒ is zero.

(c)
If there is an ğ‘–âˆˆ[â„“] such that ğ‘”ğ‘–,ğœŒ is not the constant function âˆ’1, try all possible assignments ğœ’ to the remaining q variables ğ‘¥1,â€¦,ğ‘¥ğ‘. This way, enumerate all assignments ğ‘=(ğœ’,ğœŒ) to ğ‘¥1,â€¦,ğ‘¥ğ‘š for which there is an ğ‘–âˆˆ[â„“] such that ğ‘ƒğ‘–(ğ‘)>0. Add such an assignment to the collection îˆº.

3.
Output îˆº.

Correctness Ifğ‘âˆˆ{âˆ’1,1}ğ‘š is a minority assignment (i.e. âˆƒğ‘–0âˆˆ[â„“] so that ğ‘ƒğ‘–0(ğ‘)>0) and if ğ‘=(ğœ’,ğœŒ) where ğœŒ is an assignment to the last ğ‘šâˆ’ğ‘ variables, and ğœ’ to the first q, a will get added to îˆº in the loop of step 2 corresponding to ğœŒ and that of ğœ’ in step 2c, because of ğ‘–0 being a witness. Conversely, observe that we only add to the collection îˆº when we encounter a minority assignment.

Running time For each setting ğœŒâˆˆ{âˆ’1,1}ğ‘šâˆ’ğ‘ to the variables ğ‘¥ğ‘+1,â€¦,ğ‘¥ğ‘š, step 2a takes poly(ğ‘š,ğ‘€) time and step 2b takes ğ‘‚(â„“).poly(ğ‘š,ğ‘€)=poly(ğ‘š,ğ‘€) time and so combined, they take only poly(ğ‘š,ğ‘€) time. Let î‰€ be the set consisting of all assignments ğœŒ to the last ğ‘šâˆ’ğ‘ variables such that the algorithm enters the loop described in step 2c i.e.

î‰€={ğœŒâˆˆ{âˆ’1,1}ğ‘šâˆ’ğ‘|âˆƒğ‘–âˆˆ[â„“]:ğ‘”ğ‘–,ğœŒ is not the constant functionâˆ’1}
and let î‰€ğ‘ denote its complement. Also note that for a ğœŒâˆˆî‰€, enumeration of minority assignments in step 2c takes 2ğ‘â‹…â„“â‹…poly(ğ‘š,ğ‘€) time. Therefore, we can bound the total running time by

poly(ğ‘š,ğ‘€)(2ğ‘â‹…|î‰€|+|î‰€ğ‘|).
Next, we claim that the size of î‰€ is small:

Lemma 26
|î‰€|â‰¤â„“â‹…ğ›¿âˆšâ‹…2ğ‘šâˆ’ğ‘.

Proof
We define for ğ‘–âˆˆ[â„“], î‰€ğ‘–={ğœŒâˆˆ{âˆ’1,1}ğ‘šâˆ’ğ‘|ğ‘”ğ‘–,ğœŒ is not the constant functionâˆ’1}. By the union bound, it is sufficient to show that |î‰€ğ‘–|â‰¤ğ›¿âˆšâ‹…2ğ‘šâˆ’ğ‘ for a fixed ğ‘–âˆˆ[â„“]. Let ğ·ğ‘š denote the uniform distribution on {âˆ’1,1}ğ‘š i.e. on all possible assignments to the variables ğ‘¥1,â€¦,ğ‘¥ğ‘š. Then from the definition of ğ›¿-closeness, we know

Prğ‘âˆ¼ğ·ğ‘š[ğ‘”ğ‘–(ğ‘)=1]â‰¤ğ›¿.
Writing LHS in the following way, we have


where ğ·ğ‘šâˆ’ğ‘ and ğ·ğ‘ denote uniform distributions on assignments to the last ğ‘šâˆ’ğ‘ variables and the first q variables respectively. By Markovâ€™s inequality,

PrğœŒâˆ¼ğ·ğ‘šâˆ’ğ‘[Prğœ’âˆ¼ğ·ğ‘[ğ‘”ğ‘–,ğœŒ(ğœ’)=1]â‰¥ğ›¿âˆš]â‰¤ğ›¿âˆš.
Consider a ğœŒ for which this event does not occur i.e. for which Prğœ’âˆ¼ğ·ğ‘[ğ‘”ğ‘–,ğœŒ(ğœ’)=1]<ğ›¿âˆš. For such a ğœŒ, ğ‘”ğ‘–,ğœŒ has only 2ğ‘=1/ğ›¿âˆš many inputs and therefore, ğ‘”ğ‘–,ğœŒ must be the constant function âˆ’1. Thus, we conclude that

PrğœŒâˆ¼ğ·ğ‘šâˆ’ğ‘[ğ‘”ğ‘–,ğœŒ is not the constant functionâˆ’1]â‰¤ğ›¿âˆš
or in other words, |î‰€ğ‘–|â‰¤ğ›¿âˆšâ‹…2ğ‘šâˆ’ğ‘. â—»

Finally, by using the trivial bound |î‰€ğ‘|â‰¤2ğ‘šâˆ’ğ‘ and the above claim, we obtain a total running time of poly(ğ‘š,ğ‘€)â‹…ğ›¿âˆšâ‹…2ğ‘š and this concludes the proof of the lemma. â—»

#SAT for AND of k-PTFs
We design an algorithm îˆ­4(ğ‘›,ğ‘€,ğ‘”1,â€¦,ğ‘”ğœ) with the following functionality.

Input: A set of k-PTFs ğ‘”1,â€¦,ğ‘”ğœ specified by polynomials ğ‘ƒ1,â€¦,ğ‘ƒğœ on n variables such that ğ‘¤(ğ‘ğ‘–)â‰¤ğ‘€ for each ğ‘–âˆˆ[ğœ] and âˆ‘ğ‘–âˆˆ[ğœ]fan-in(ğ‘”ğ‘–)â‰¤ğ‘›1+ğœ€1.

Oracle access to: îˆ­1,îˆ­2.

Output: #{ğ‘âˆˆ{âˆ’1,1}ğ‘›âˆ£âˆ€ğ‘–âˆˆ[ğœ],ğ‘ƒğ‘–(ğ‘)<0}.

The details of the algorithm
îˆ­4(ğ§,ğŒ,ğ 1,â€¦,ğ ğœ)

1.
Let ğ‘š=ğ‘›ğ›¼ for ğ›¼=ğœğœ€12(ğ‘˜+1). Let C denote the AND of ğ‘”1,â€¦,ğ‘”ğœ.

2.
Run îˆ­2(ğ¶,2,ğ‘›,ğ‘€) to obtain the decision tree TDT. Initialize N to 0.

3.
For each leaf ğœ of TDT, do the following:

(A)
If ğ¶ğœ is not good, count the number of satisfying assignments for ğ¶ğœ by brute-force and add to ğ‘.

(B)
If ğ¶ğœ is good, do the following:

(i)
ğ¶ğœ is now an AND of PTFs in ğµğœ and ğºğœ, over ğ‘›â€²=ğ‘›1âˆ’2ğ›½1 variables, where all PTFs in ğµğœ are ğ›¿-close to an explicit constant, where ğ›¿=exp(âˆ’ğ‘›ğ›½1/ğµâ‹…ğ‘˜2). Moreover, |ğµğœ|â‰¤ğ‘›,|ğºğœ|â‰¤ğ‘›ğ›½1. Let ğµğœ={â„1,â€¦,â„â„“} be specified by ğ‘„1,â€¦,ğ‘„â„“. Suppose for ğ‘–âˆˆ[â„“], â„ğ‘– is close to ğ‘ğ‘–âˆˆ{âˆ’1,1}. Then let ğ‘„â€²ğ‘–=âˆ’ğ‘ğ‘–â‹…ğ‘„ğ‘– and â„â€²ğ‘–=sgn(ğ‘„â€²ğ‘–). Let ğµâ€²ğœ={ğ‘„â€²1,â€¦,ğ‘„â€²â„“}.

(ii)
For each restriction ğœŒ:{ğ‘¥ğ‘š+1,â€¦,ğ‘¥ğ‘›â€²}â†’{âˆ’1,1}, do the following:

(a)
Check if there exists â„â€²âˆˆğµâ€²ğœ such that â„â€²ğœŒ is not the constant function âˆ’1 using îˆ­1(ğ‘š,1,â„â€²ğœŒ).

(b)
If such an â„â€²âˆˆğµâ€²ğœ exists, then count the number of satisfying assignments for ğ¶ğœğœŒ by brute-force and add to ğ‘.

(c)
If the above does not hold, we have established that for each â„ğ‘–âˆˆğµğœ, â„ğ‘–,ğœŒ is the constant function ğ‘ğ‘–. If âˆƒğ‘–âˆˆ[â„“] such that ğ‘ğ‘–=1, it means ğ¶ğœğœŒ is also a constant 1 . Then simply halt. Else set each â„ğ‘– to ğ‘ğ‘–. Thus, ğ¶ğœğœŒ has been reduced to an AND of ğ‘›ğ›½1 many PTFs over ğ‘š variables. Call this set ğºâ€²ğœğœŒ, use îˆ­1(ğ‘š,ğ‘›ğ›½1,ğºâ€²ğœğœŒ) to calculate the number of satisfying assignments and add the output to ğ‘.

4.
Finally, output N.

The correctness argument and running time analysis
Lemma 27
îˆ­4 is a zero-error randomized algorithm that counts the number of satisfying assignments correctly. Further, îˆ­4 runs in time poly(ğ‘›,ğ‘€)â‹…ğ‘‚(2ğ‘›âˆ’ğ‘›ğ›¼) and outputs the right answer with probability at least 1/2 (and outputs ? otherwise).

Proof
Correctness For a leaf ğœ of TDT, when ğ¶ğœ is not good, we simply use brute-force, which is guaranteed to be correct. Otherwise,

If â„â€²ğœŒ not the constant function âˆ’1 for some â„â€²âˆˆğµâ€²ğœ, then we again use brute-force, which is guaranteed to work correctly.

Otherwise, for each â„â€²âˆˆğµâ€²ğœ, â„â€²ğœŒ is the constant function âˆ’1. Here we only need to consider the satisfying assignments for the gates in ğºğœğœŒ. For this we use îˆ­1, that works correctly by assumption.

Further, we need to ensure that the parameters that we call îˆ­1 on, are valid. To see this, observe that ğ‘š=ğ‘›ğ›¼â‰¤ğ‘›1/(2(ğ‘˜+1)) because of the setting of ğ›¼ and further, we have ğ‘›ğ›½1â‰¤ğ‘›0.1.

Finally, the claim about the error probability follows from the error probability of îˆ­2 (Theorem 22).

Running Time The time taken for constructing TDT is poly(ğ‘›,ğ‘€)â‹…ğ‘‚(2ğ‘›âˆ’ğ‘›1âˆ’2ğ›½1), by Theorem 22. For a leaf ğœ of TDT, we know that step (A) is executed with probability at most 2âˆ’ğ‘›ğœ€1. The total time for running step (A) is thus poly(ğ‘›,ğ‘€)â‹…ğ‘‚(2ğ‘›âˆ’ğ‘›ğœ€1). We know that the oracle îˆ­1 answers calls in poly(ğ‘›,ğ‘€) time. Hence, the total time for running step (a) is poly(ğ‘›,ğ‘€)â‹…ğ‘‚(2ğ‘›âˆ’ğ‘›ğ›¼). Next, note that if step (b) is executed, then all PTFs in ğµğœ are ğ›¿-close to âˆ’1. So, the number of times it runs is at most ğ›¿â‹…2ğ‘›â€². Therefore, the total time for running step (b) is poly(ğ‘›,ğ‘€)â‹…ğ‘‚(2ğ‘›+ğ‘›ğ›¼âˆ’ğ‘›ğ›½1/ğµğ‘˜2). Recall that ğœ=min(1,ğ´/2ğµğ‘˜2), implying ğ›¼=ğœğœ€12(ğ‘˜+1)=ğœğ›½12ğ´(ğ‘˜+1)â‰¤ğ›½14ğµğ‘˜2(ğ‘˜+1)<ğ›½1ğµğ‘˜2. Similar to the analysis of step (a), the total time for running step (c) is also poly(ğ‘›,ğ‘€)â‹…ğ‘‚(2ğ‘›âˆ’ğ‘›ğ›¼). We conclude that the total running time is poly(ğ‘›,ğ‘€)â‹…ğ‘‚(2ğ‘›âˆ’ğ‘›ğ›¼). This completes the proof.

#SAT for larger depth k-PTF circuits
Let C be a k-PTF circuit of depth ğ‘‘â‰¥1 on n variables and let îˆ¼ be a set of k-PTFs ğ‘”1,â€¦,ğ‘”ğœ, which are specified by n-variate polynomials ğ‘ƒ1,â€¦,ğ‘ƒğœ. Let #SAT(ğ¶,îˆ¼) denote #{ğ‘âˆˆ{âˆ’1,1}ğ‘›âˆ£ğ¶(ğ‘)<0 and âˆ€ğ‘–âˆˆ[ğœ],ğ‘ƒğ‘–(ğ‘)<0}. We now specify our depth-reduction algorithm îˆ­5(ğ‘›,ğ‘‘,ğ‘€,ğ‘›1+ğœ€ğ‘‘,ğ¶,îˆ¼).

Input: (ğ¶,îˆ¼) as follows:

k-PTF circuit C with parameters (ğ‘›,ğ‘›1+ğœ€ğ‘‘,ğ‘‘,ğ‘€).

a set îˆ¼ of k-PTFs ğ‘”1,â€¦,ğ‘”ğœ on n variables, which are specified by polynomials ğ‘ƒ1,â€¦,ğ‘ƒğœ such that âˆ‘ğœğ‘–=1fan-in(ğ‘”ğ‘–)â‰¤ğ‘›1+ğœ€ğ‘‘ and for each ğ‘–âˆˆ[ğœ], ğ‘¤(ğ‘ƒğ‘–)â‰¤ğ‘€.

Oracle access to: îˆ­1,îˆ­4.

Output: #SAT(ğ¶,îˆ¼).

We start by describing the algorithm.

The details of the algorithm
Let count be a global counter initialized to 0 before the execution of the algorithm.

îˆ­5(ğ§,ğ,ğŒ,ğ§1+ğœ€ğ,ğ‚,îˆ¼)

1.
If ğ‘‘=1, output îˆ­4(ğ‘›,ğ‘€,{ğ¶}âˆªîˆ¼) and halt.

2.
Run îˆ­2(ğ¶,ğ‘‘,ğ‘›,ğ‘€), which gives us a TDT. (If not, output ?.)

3.
For each leaf ğœâˆˆ{âˆ’1,1}ğ‘›âˆ’ğ‘›1âˆ’2ğ›½ğ‘‘ of TDT.

(a)
For each ğ‘–âˆˆ[ğœ] compute ğ‘ƒğ‘–,ğœ, the polynomial obtained by substituting ğœ in its variables. Let îˆ¼ğœ={ğ‘ƒ1,ğœ,â€¦,ğ‘ƒğœ,ğœ}.

(b)
Obtain ğ¶ğœ. If ğ¶ğœ is not a good circuit, then brute-force to find the number of satisfying assignments of (ğ¶ğœ,îˆ¼ğœ), say ğ‘ğœ, and set ğšŒğš˜ğšğš—ğš=ğšŒğš˜ğšğš—ğš+ğ‘ğœ.

(c)
If ğ¶ğœ is good then obtain ğµğœ and ğºğœ.

(d)
Let ğµğœ={â„1,â€¦,â„â„“} be specified by ğ‘„1,â€¦,ğ‘„â„“. We know that each â„âˆˆğµğœ is ğ›¿-close to an explicit constant, for ğ›¿=2âˆ’ğ‘›ğ›½ğ‘‘/ğµğ‘˜2. Suppose for ğ‘–âˆˆ[â„“], â„ğ‘– is close to ğ‘ğ‘–âˆˆ{âˆ’1,1}. Then let ğ‘„â€²ğ‘–=âˆ’ğ‘ğ‘–â‹…ğ‘„ğ‘– and â„â€²ğ‘–=sgn(ğ‘„â€²ğ‘–). Let ğµâ€²ğœ={ğ‘„â€²1,â€¦,ğ‘„â€²â„“}.

(e)
Run îˆ­3(ğ‘›1âˆ’2ğ›½ğ‘‘,â„“,ğ›¿,â„â€²1,â€¦,â„â€²â„“) to obtain the set îˆºğœ of all the minority assignments of ğµğœ. (Note that this uses oracle access to îˆ­1.) for each ğ‘âˆˆîˆºğœ, if ((ğ¶(ğ‘)<0) AND (âˆ€ğ‘–âˆˆ[ğœ], ğ‘ƒğ‘–,ğœ(ğ‘)<0)), then ğšŒğš˜ğšğš—ğš=ğšŒğš˜ğšğš—ğš+1.

(f)
Let ğºğœ={ğ‘“1,â€¦,ğ‘“ğ‘¡} be specified by polynomials ğ‘…1,â€¦,ğ‘…ğ‘¡. We know that ğ‘¡â‰¤ğ‘›ğ›½ğ‘‘. For each ğ‘âˆˆ{âˆ’1,1}ğ‘¡,

i
Let ğ‘…â€²ğ‘–=âˆ’ğ‘ğ‘–â‹…ğ‘…ğ‘– for ğ‘–âˆˆ[ğ‘¡]. Let ğºâ€²ğœ,ğ‘={ğ‘…â€²1,â€¦,ğ‘…â€²ğ‘¡}.

ii
Let ğ¶ğœ,ğ‘ be the circuit obtained from ğ¶ğœ by replacing each â„ğ‘– by ğ‘ğ‘– 1â‰¤ğ‘–â‰¤â„“ and each ğ‘“ğ‘— by ğ‘ğ‘— for 1â‰¤ğ‘—â‰¤ğ‘¡.

iii
îˆ¼ğœ,ğ‘=îˆ¼ğœâˆªğµâ€²ğœâˆªğºâ€²ğœ,ğ‘.

iv
If ğ‘‘>2 then run îˆ­5(ğ‘›1âˆ’2ğ›½ğ‘‘,ğ‘‘âˆ’1,ğ‘€,ğ‘›1+ğœ€ğ‘‘,ğ¶ğœ,ğ‘,îˆ¼ğœ,ğ‘) ğ‘›1=10ğ‘› times and let ğ‘ğœ be the output of the first run that does not output ?. Set ğšŒğš˜ğšğš—ğš=ğšŒğš˜ğšğš—ğš+ğ‘ğœ. (If all runs of îˆ­5 output ?, then output ?.)

v
If ğ‘‘=2 then run îˆ­4(ğ‘›1âˆ’2ğ›½ğ‘‘,ğ‘€,ğ¶ğœ,ğ‘âˆªîˆ¼ğœ,ğ‘) ğ‘›1=10ğ‘› times and let ğ‘ğœ be the output of the first run that does not output ?. Set ğšŒğš˜ğšğš—ğš=ğšŒğš˜ğšğš—ğš+ğ‘ğœ. (If all runs of îˆ­5 output ?, then output ?.)

4.
Output count.

The correctness argument and running time analysis
Lemma 28
The algorithm îˆ­5 described above is a zero-error randomized algorithm which on input (ğ¶,îˆ¼) as described above, correctly solves #SAT(ğ¶,îˆ¼). Moreover, the algorithm outputs the correct answer (and not ?) with probability at least 1/2. Finally, îˆ­5(ğ‘›,ğ‘‘,ğ‘€,ğ‘›1+ğœ€ğ‘‘,ğ¶,âˆ…) runs in time poly(ğ‘›,ğ‘€)â‹…2ğ‘›âˆ’ğ‘›ğœğœ€ğ‘‘/2(ğ‘˜+1), where parameters ğœ€ğ‘‘,ğœ are as defined at the beginning of Sect. 4.

Proof
We argue correctness by induction on the depth d of the circuit C.

Clearly, if ğ‘‘=1, correctness follows from the correctness of algorithm îˆ­4. This takes care of the base case.

If ğ‘‘â‰¥2, we argue first that if the algorithm does not output ?, then it does output #SAT(ğ¶,îˆ¼) correctly. Assume that the algorithm îˆ­2 outputs a decision tree TDT as required (otherwise, the algorithm outputs ? and we are done). Now, it is sufficient to argue that for each ğœ, the number of satisfying assignments to (ğ¶ğœ,îˆ¼ğœ) is computed correctly (if the algorithm does not output ?).

Fix any ğœ. If ğ¶ğœ is not a good circuit, then the algorithm uses brute-force to compute #SAT(ğ¶ğœ,îˆ¼ğœ) which yields the right answer. So we may assume that ğ¶ğœ is indeed good.

Now, the satisfying assignments to (ğ¶ğœ,îˆ¼ğœ) break into two kinds: those that are minority assignments to the set ğµğœ and those that are majority assignments to ğµğœ. The former set is enumerated in Step 3e (correctly by our analysis of îˆ­3) and hence we count all these assignments in this step.

Finally, we claim that the satisfying assignments to (ğ¶ğœ,îˆ¼ğœ) that are majority assignments of all gates in ğµğœ are counted in Step 3f. To see this, note that each such assignment ğ‘âˆˆ{âˆ’1,1}ğ‘›1âˆ’2ğ›½ğ‘‘ forces the gates in ğºğœ to some values ğ‘1,â€¦,ğ‘ğ‘¡âˆˆ{âˆ’1,1}. Note that for each such ğ‘âˆˆ{âˆ’1,1}ğ‘¡, these assignments are exactly the satisfying assignments of the pair (ğ¶ğœ,ğ‘,îˆ¼ğœ,ğ‘) as defined in the algorithm. In particular, the number satisfying assignments to (ğ¶ğœ,îˆ¼ğœ) that are majority assignments of all gates in ğµğœ can be written as

âˆ‘ğ‘âˆˆ{âˆ’1,1}ğ‘¡# SAT(ğ¶ğœ,ğ‘,îˆ¼ğœ,ğ‘).
We now want to apply the induction hypothesis to argue that all the terms in the sum are computed correctly. To do this, we need to argue that the size of ğ¶ğœ,ğ‘ and the total fan-in of the gates in îˆ¼ğœ,ğ‘ are bounded as required (note that the total size of C remains the same, while the total fan-in of îˆ¼ increases by the total fan-in of the gates in ğµâ€²ğœâˆªğºâ€²ğœ,ğ‘ which is at most ğ‘›1+ğœ€ğ‘‘). It can be checked that this boils down to the following two inequalities

ğ‘›(1âˆ’2ğ›½ğ‘‘)(1+ğœ€ğ‘‘âˆ’1)â‰¥ğ‘›1+ğœ€ğ‘‘ and ğ‘›(1âˆ’2ğ›½ğ‘‘)(1+ğœ€ğ‘‘âˆ’1)â‰¤2ğ‘›1+ğœ€ğ‘‘
both of which are easily verified for our choice of parameters (for large enough n). Thus, by the induction hypothesis, all the terms in the sum are computed correctly (unless we get ?). Hence, the output of the algorithm is correct by induction.

Now, we analyze the probability of error. If ğ‘‘=1, the probability of error is at most 1/2 by the analysis of îˆ­4. If ğ‘‘>2, we get an error if either îˆ­2 outputs ? or there is some ğœ such that the corresponding runs of îˆ­5 or îˆ­4 output ?. The probability of each is at most 1/210ğ‘›. Taking a union bound over at most 2ğ‘› many ğœ, we see that the probability of error is at most 1/2Î©(ğ‘›)â‰¤1/2.

Finally, we analyze the running time. Define î‰€(ğ‘›,ğ‘‘,ğ‘€) to be the running time of the algorithm on a pair (ğ¶,îˆ¼) as specified in the input description above. We need the following claim.

Lemma 29
î‰€(ğ‘›,ğ‘‘,ğ‘€)â‰¤poly(ğ‘›,ğ‘€)â‹…2ğ‘›âˆ’ğ‘›ğœğœ€ğ‘‘/2(ğ‘˜+1).

To see the above, we argue by induction. The case ğ‘‘=1 follows from the running time of îˆ­4. Further from the description of the algorithm, we get the following inequality for ğ‘‘â‰¥2.

î‰€(ğ‘›,ğ‘‘,ğ‘€)â‰¤poly(ğ‘›,ğ‘€)â‹…(2ğ‘›âˆ’ğ‘›1âˆ’2ğ›½ğ‘‘+2ğ‘›âˆ’ğ‘›ğœ€ğ‘‘+2ğ‘›âˆ’12â‹…ğ‘›ğ›½ğ‘‘/(ğµğ‘˜2)+2ğ‘›âˆ’ğ‘›(1âˆ’2ğ›½ğ‘‘)ğœğœ€ğ‘‘âˆ’1/2(ğ‘˜+1))
(2)
The first term above accounts for the running time of îˆ­2 and all steps other than Steps 3b, 3e and 3f. The second term accounts for the brute force search in Step 3b since there are only a 2âˆ’ğ‘›ğœ€ğ‘‘ fraction of ğœ where it is performed. The third term accounts for the minority enumeration algorithm in Step 3e (running time follows from the running time of that algorithm). The last term is the running time of Step 3f and follows from the induction hypothesis.

It suffices to argue that each term in the RHS of (2) can be bounded by 2ğ‘›âˆ’ğ‘›ğœğœ€ğ‘‘/2(ğ‘˜+1). This is an easy verification from our choice of parameters and left to the reader. This concludes the proof. â—»

Putting it together
In this subsection, we complete the proof of Theorem 9 using the aforementioned subroutines. We also need to describe the subroutine îˆ­1, which is critical for all the other subroutines. We shall do so inside our final algorithm for the #SAT problem for k-PTF circuits, algorithm îˆ®. Recall that îˆ­1 has the following specifications:

Input: AND of k-PTFs, say ğ‘“1,â€¦,ğ‘“ğ‘  specified by polynomials ğ‘ƒ1,â€¦,ğ‘ƒğ‘  respectively, such that ğ‘ â‰¤ğ‘›0.1 and for each ğ‘–âˆˆ[ğ‘ ], ğ‘“ğ‘– is defined over ğ‘›â€²â‰¤ğ‘›1/(2(ğ‘˜+1)) variables and ğ‘¤(ğ‘ƒğ‘–)â‰¤ğ‘€.

Output: #{ğ‘âˆˆ{âˆ’1,1}ğ‘›â€²âˆ£âˆ€ğ‘–âˆˆ[ğ‘ ],ğ‘“ğ‘–(ğ‘)=âˆ’1}.

We are now ready to complete the proof of Theorem 9. Suppose C is the input k-PTF circuit with parameters (ğ‘›,ğ‘›1+ğœ€ğ‘‘,ğ‘‘,ğ‘€). On these input parameters (ğ¶,ğ‘›,ğ‘›1+ğœ€ğ‘‘,ğ‘‘,ğ‘˜,ğ‘€), we finally have the following algorithm for the #SAT problem for k-PTF circuits:

îˆ®(ğ‚,ğ§,ğ§1+ğœ€ğ,ğ,ğ¤,ğŒ)

1.
(Oracle Construction Step) Construct the oracle îˆ­1 as follows. Use the algorithm from Corollary 13, with â„“ chosen to be ğ‘›0.1 and m to be ğ‘›1/2(ğ‘˜+1), to construct a deterministic linear decision tree T such that on any input ğ‘¤â¯â¯â¯â¯â¯=(coeffğ‘š,ğ‘˜(ğ‘„1),â€¦,coeffğ‘š,ğ‘˜(ğ‘„â„“))âˆˆâ„ğ‘Ÿâ‹…â„“ (where ğ‘„ğ‘–s are polynomials of degree at most k that sign-represent k-PTFs ğ‘”ğ‘–, each on m variables), T computes the number of common satisfying assignments to ğ‘”1,â€¦,ğ‘”â„“.

2.
Run îˆ­5(ğ‘›,ğ‘‘,ğ‘€,ğ‘›1+ğœ€ğ‘‘,ğ¶,âˆ…). For an internal call to îˆ­1, say on parameters (ğ‘›â€²,ğ‘ ,ğ‘“1,â€¦,ğ‘“ğ‘ ) where ğ‘›â€²â‰¤ğ‘š and ğ‘ â‰¤â„“, run T on the input ğ‘¤â¯â¯â¯â¯â¯=(coeffğ‘›â€²,ğ‘˜(ğ‘ƒ1),â€¦,coeffğ‘›â€²,ğ‘˜(ğ‘ƒğ‘ ))âˆˆâ„ğ‘Ÿâ‹…ğ‘ . (We expand out the coefficient vectors with dummy variables so that they depend on exactly m variables. Similarly, using some dummy polynomials, we can assume that there are exactly â„“ polynomials.)

Lemma 30
The construction of the oracle îˆ­1 in the above algorithm takes 2ğ‘‚(ğ‘›0.6) time. Once constructed, the oracle îˆ­1 answers any call (with valid parameters) in poly(ğ‘›,ğ‘€) time.

Proof
Substituting the parameters â„“=ğ‘›0.1 and ğ‘š=ğ‘›1/(2(ğ‘˜+1)) in Corollary 13, we see that the construction of îˆ­1 (step 1) takes 2ğ‘‚(ğ‘›0.6log2ğ‘›) time. Also, the claimed running time of answering a call follows from the bound on the depth of T given by the proof of Corollary 13. â—»

With the correctness of îˆ­1 now firmly established, we finally argue the correctness and running time of algorithm îˆ®.

Correctness The correctness of îˆ® follows from that of îˆ­1,îˆ­2,îˆ­3,îˆ­4, and îˆ­5 (see Lemma 30, Theorem 22, Lemmas 25, 27, and 28 respectively). From the analysis of îˆ­5, we see th