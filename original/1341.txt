In the MAXIMUM DEGREE CONTRACTION problem, the input is a graph G on n vertices, and integers k, d, and the objective is to check whether G can be transformed into a graph of maximum degree at most d, using at most k edge contractions. A simple brute-force algorithm that checks all possible sets of edges for a solution runs in time 𝑛(𝑘). As our first result, we prove that this algorithm is asymptotically optimal, upto constants in the exponents, under Exponential Time Hypothesis (ETH). Belmonte, Golovach, van’t Hof, and Paulusma studied the problem in the realm of parameterized complexity and proved, among other things, that it admits an FPT algorithm running in time (𝑑+𝑘)2𝑘⋅𝑛(1)=2(𝑘log(𝑘+𝑑))⋅𝑛(1), and remains NP-hard for every constant 𝑑≥2 (Acta Informatica (2014)). We present a different FPT algorithm that runs in time 2(𝑑𝑘)⋅𝑛(1). In particular, our algorithm runs in time 2(𝑘)⋅𝑛(1), for every fixed d. In the same article, the authors asked whether the problem admits a polynomial kernel, when parameterized by 𝑘+𝑑. We answer this question in the negative and prove that it does not admit a polynomial compression unless 𝖭𝖯⊆𝖼𝗈𝖭𝖯/𝑝𝑜𝑙𝑦.

Access provided by University of Auckland Library

Introduction
For any graph class , the -MODIFICATION problem takes as input a graph G and an integer k, and asks whether one can make at most k modifications in G such that the resulting graph is in . These types of modification problems are among the most central in graph theory and have received a considerable attention in algorithm design. With appropriate choice of  and allowed modification operations, -MODIFICATION can encapsulate well-studied problems like VERTEX COVER, CHORDAL COMPLETION, CLUSTER EDITING, HADWINGER NUMBER, etc. Some natural and well-studied graph modification operations are vertex deletion, edge deletion, edge addition, and edge contraction. The focus of the vast majority of papers on graph modification problems has been to the first three operations. Consider as example the ≤𝑑-MODIFICATION problem where ≤𝑑 is the collection of all graphs that have maximum degree at most d. If the allowed modification operation is vertex deletion then we know the problem as BOUNDED DEGREE DELETION (BDD) and if it is edge contraction then as MAXIMUM DEGREE CONTRACTION (MDC). The complexity of BDD and several of its variants has been extensively studied [7, 9, 10, 13, 15, 18, 22, 30, 38] whereas, to the best of our knowledge, only [8] addressed MDC. In this article, we enhance our understanding of the second problem and answer an open question stated in [8].

The contraction of edge (u, v) in simple graph G deletes vertices u and v from G, and replaces them by a new vertex, which is made adjacent to the vertices that were adjacent to u or v. For a set of edges F in E(G), we denote the graph obtained from G by contracting all edges in F by G/F. In the -CONTRACTION problem, the input is a graph G and an integer k, and the aim is to decide whether there is a set F of at most k edges in G such that G/F is in . Early papers by Watanabe et al. [42, 43] and Asano and Hirata [6] showed that -CONTRACTION is NP-hard for simple graph classes like trees, paths, stars, etc. Brouwer proved that it is NP-hard even to decide whether a graph can be contracted to a path of length four [11]. Note that this problem admits a simple polynomial time algorithm if we consider any other modification operation. This has been a recurring theme in graph modification problems. For the same target graph class, the edge contraction problem tends to more difficult than their counterparts where the modification operation is vertex/edge addition/deletion. This difficulty is evident even in the realm of the parameterized complexity and exact exponential algorithms.

In parameterized complexity, -CONTRACTION problems are studied with the number of edges one is allowed to contract, k, as parameter. Heggernes et al. [29] proved that if  is the set of acyclic graphs then -CONTRACTION is FPT but does not admit a polynomial kernel unless 𝖭𝖯⊆𝖼𝗈𝖭𝖯/𝑝𝑜𝑙𝑦. Note that the vertex deletion version of the problem, known as FEEDBACK VERTEX SET, admits a polynomial kernel [41]. Series of papers studied the parameterized complexity for various graph class  like a generalization and restrictions of trees [1, 3], cactus graphs [32], bipartite graphs [25, 28], planar graphs [23], grids [39], cliques [12], split graphs [4], chordal graphs [34], bi-cliques [36], degree constrained graph classes [8, 24], etc. Krithika et al. [31] and Gunda et al. [27] studied -CONTRACTION problems from the lenses of FPT approximation and lossy kernelization. Agarwal et al. [2] broke the 2𝑛-barrier for PATH CONTRACTION whereas Fomin et al. [20] showed that the brute-force algorithms for HADWINGER NUMBER problem and various other -CONTRACTION problem are optimal under ETHFootnote1.

Belmonte et al. [8] studied the parameterized complexity of -CONTRACTION for three different classes : the class of graphs with maximum degree at most d, the class of d-regular graphs, and the class of d-degenerate graphs. They classified the parameterized complexity of all three problems with respect to the parameters k, d, and 𝑑+𝑘. The first problem, also known as MDC, is defined as follows.

figure a
The authors proved that MDC is FPT when parameterized by 𝑘+𝑑, 𝖶[2]-hard when parameterized by k (even when restricted to split graphs), and para-NP-hard when parameterized by d (Theorem 3 in [8]). Note that the problem is trivially solvable in polynomial time when 𝑑≤1 and NP-hard for every constant 𝑑≥2.

Consider brute-force algorithm for MDC that given an instance (G, k, d), where graph G has n vertices, enumerates all subsets of edges of size at most k in G and for each subset contracts all edges in it to check whether the resulting graph has degree at most d. This algorithm runs in time 𝑛(𝑘). Our first result states that this algorithm is optimal, up to constants in the exponents, under ETH.

Theorem 1
Unless ETH fails, there is no algorithm that given any instance (G, k, d) of MAXIMUM DEGREE CONTRACTION runs in time 𝑛𝑜(𝑘) and correctly determines whether it is a YES-instance.

Belmonte et al. [8] presented an FPT algorithm for MDC that runs in time (𝑑+𝑘)2𝑘⋅𝑛(1). As for any non-trivial instance 𝑑+𝑘 is smaller than n, we can conclude that there is no algorithm that given any instance (G, k, d) of MDC runs in time (𝑑+𝑘)𝑜(𝑘)⋅𝑛(1) and correctly determines whether it is a YES-instance, unless ETH fails.

We remark that that the lower bound in Theorem 1 does not hold when d is a fixed constant and not a part of input. Hence, it is possible that MDC admits an algorithm that runs in time 𝑘𝑜(𝑘)⋅𝑛(1) for a constant value of d. Belmonte et al. [8] proved that MDC problem admits linear vertex kernels on connected graphs when 𝑑=2. This linear kernel leads to an FPT algorithmFootnote2 running in time 2(𝑘)⋅𝑛(1) . This hints that it is possible to design a better FPT algorithm for small values of d. Our second result shows that this is indeed the case.

Theorem 2
There is an algorithm that given an instance (G, k, d) of MAXIMUM DEGREE CONTRACTION runs in time 2(𝑑𝑘)⋅𝑛(1) and correctly determines whether it is a YES-instance.

We argue that the existing results imply that MDC does not admit an algorithm running in time 2𝑜(𝑛𝑑), and hence in time 2𝑜(𝑘𝑑), unless ETH fails.

Next, we look at the kernelization of MDC. Belmonte et al. [8] left it as an open question to determine whether MDC admits a polynomial kernel when parameterized by 𝑘+𝑑. Our last result answers this question in the negative.

Theorem 3
Unless 𝖭𝖯⊆𝖼𝗈𝖭𝖯/𝑝𝑜𝑙𝑦, MAXIMUM DEGREE CONTRACTION, parameterized by 𝑘+𝑑, does not admit a polynomial compression.

It is known that the BOUNDED DEGREE DELETION problem admits a kernel with (𝑑3𝑘) vertices [18]. Hence, ≤𝑑-MODIFICATION is another example for which changing the modification operations from vertex deletion to edge contraction changes the compressibility drastically.

We organize the remaining paper as follows. In Sect. 2, we present some preliminaries and observations regarding MDC. In Sect. 3, we give a parameter preserving reduction from (𝑘×𝑘)-PERMUTATION INDEPENDENT SET to MDC to rule out 𝑛𝑜(𝑘) algorithm for the later problem under ETH. We present an FPT algorithm using universal sets and branching techniques in Sect. 4. In Sect. 5, we present a parameter preserving reduction from RED BLUE DOMINATING SET to rule out polynomial compression for the MDC problem. We conclude this article with an open question in Sect. 6.

Preliminaries
For a positive integer q, we denote set {1,2,…,𝑞} by [q].

Graph Theory
In this article, we consider simple graphs with a finite number of vertices. For an undirected graph G, sets V(G) and E(G) denote its set of vertices and edges, respectively. Unless otherwise specified, we use n to denote the number of vertices in the input graph G. We denote an edge with endpoints u, v as (u, v). Two vertices u, v in V(G) are adjacent to each other if there is edge (u, v) in E(G). The open neighborhood of a vertex v, denoted by 𝑁𝐺(𝑣), is the set of vertices adjacent to v and its degree deg𝐺(𝑣) is |𝑁𝐺(𝑣)|. The closed neighborhood of a vertex v, denoted by 𝑁𝐺[𝑣], is the set 𝑁(𝑣)∪{𝑣}. We omit the subscript in the notation for neighborhood and degree if the graph under consideration is clear. For a subset S of V(G), we define 𝑁[𝑆]=⋃𝑣∈𝑆𝑁[𝑣] and 𝑁(𝑆)=𝑁[𝑆]∖𝑆.

For a subset F of edges, the subset of vertices V(F) denotes the collection of endpoints of edges in F. We say a set of edges F spans a set of vertices S if 𝑆⊆𝑉(𝐹). For a subset S of V(G), we denote the graph obtained by deleting S from G by 𝐺−𝑆 and the subgraph of G induced on the set S by G[S]. For two subsets 𝑆1,𝑆2 of V(G), edge set 𝐸(𝑆1,𝑆2) denotes the edges with one endpoint in 𝑆1 and another one in 𝑆2. We say 𝑆1,𝑆2 are adjacent if 𝐸(𝑆1,𝑆2) is non empty.

For an integer q, a q-coloring of graph G is a function 𝜙:𝑉(𝐺)→[𝑞]. A proper coloring of G is a q-coloring 𝜙 of V(G) for some integer q such that for any edge (u, v), 𝜙(𝑢)≠𝜙(𝑣). There is a proper coloring of the graph with Δ(𝐺)+1 many colors which can found in polynomial time (See Chapter 5.2 in [16]). A set of vertices S is said to be an independent set if no two vertices in S are adjacent to each other. A set of edges F is called a matching if no two edges in F share an endpoint. A graph is called connected if there is a path between every pair of distinct vertices. A subset S of V(G) is said to be a connected set if G[S] is connected. A spanning tree of a connected graph is its connected acyclic subgraph, which includes all the vertices of the graph.

Graph Contraction
The contraction of an edge (u, v) in G deletes vertices u and v from G, and adds a new vertex which is adjacent to vertices that were adjacent to u or v. This process does not introduce self-loops or parallel edges. The resulting graph is denoted by G/e. For a graph G and edge 𝑒=(𝑢,𝑣), we formally define G/e in the following way: 𝑉(𝐺/𝑒)=(𝑉(𝐺)∪{𝑤})∖{𝑢,𝑣} and 𝐸(𝐺/𝑒)={(𝑥,𝑦)∣𝑥,𝑦∈𝑉(𝐺)∖{𝑢,𝑣},(𝑥,𝑦)∈𝐸(𝐺)}∪{(𝑤,𝑥)| 𝑥∈𝑁𝐺(𝑢)∪𝑁𝐺(𝑣)}. Here, w is a new vertex. An edge contraction reduces the number of vertices in a graph by exactly one. Several edges might disappear because of one edge contraction. For a subset of edges F in G, graph G/F denotes the graph obtained from G by contracting each connected component in the sub-graph 𝐺′=(𝑉(𝐹),𝐹) to a vertex.

We now formally define a contraction of graph G to another graph H.

Definition 1
(Graph Contraction) A graph G is said to be contractible to graph H if there is a function 𝜓:𝑉(𝐺)→𝑉(𝐻) such that following properties hold.

1.
For any vertex h in V(H), the set 𝑊(ℎ):={𝑣∈𝑉(𝐺)∣𝜓(𝑣)=ℎ} is not empty, and graph G[W(h)] is connected.

2.
For any two vertices ℎ,ℎ′ in V(H), edge ℎℎ′ is present in H if and only if 𝐸(𝑊(ℎ),𝑊(ℎ′)) is not empty.

We then say that G is contractible to H via mapping 𝜓. For a vertex h in H, the set W(h) is called a witness set associated with or corresponding to h. For a fixed 𝜓, we define the H-witness structure of G, denoted by , as the collection of all witness sets. Formally, ={𝑊(ℎ)∣ℎ∈𝑉(𝐻)}. A witness structure  is a partition of vertices in G. If a witness set contains more than one vertex, then we call it a big witness set, otherwise it is a small witness set.

If G has a H-witness structure, then H can be obtained from G by a series of edge contractions. For a fixed H-witness structure, let F be the union of spanning trees of all witness sets. By convention, the spanning tree of a singleton set does not contain any edge. To obtain H from G, it is sufficient to contract edges in F. Hence, 𝐻=𝐺/𝐹. For the (G/F)-witness structure  of G, there is a unique function 𝜓:𝑉(𝐺)→𝑉(𝐺/𝐹) corresponding to it. We say graph G is k-contractible to H if the cardinality of F is at most k. In other words, H can be obtained from G by at most k edge contractions. The following observations are immediate consequences of the above definitions.

Observation 1
If graph G is k-contractible to graph H via mapping 𝜓 then following statements are true.

1.
Any H-witness structure of G has at most k big witness sets.

2.
For a fixed H-witness structure, the number of vertices in G that are in some big witness set is at most 2k.

3.
For a vertex v in V(G), if |𝑊(𝜓(𝑣))|=1 then deg𝐻(𝜓(𝑣))≤deg𝐺(𝑣).

4.
For 𝑈⊆𝑉(𝐺), define 𝜓(𝑈):={𝜓(𝑢) | 𝑢∈𝑈}. Then, |𝑈|≤|𝜓(𝑈)|+𝑘.

Proof
Let  be a H-witness structure of G and F be the union of the spanning trees of all witness sets. As G is k-contractible to H, we have |𝐹|≤𝑘.

(1)
As any big witness set contains at least one edge in F, the number of big witness set is at most k.

(2)
As F spans all vertices in the big witness sets, the number of vertices in big witness set is at most 2k.

(3)
Let ℎ𝑖 be a vertex in 𝑁𝐻(𝜓(𝑣)). As (𝜓(𝑣),ℎ𝑖)∈𝐸(𝐻), set 𝐸(𝑊(𝜓(𝑣)),𝑊(ℎ𝑖)) is non-empty subset of E(G). As |𝑊(𝜓(𝑣))|=1, this implies 𝐸({𝑣},𝑊(ℎ𝑖)) is non empty. As ℎ𝑖 is an arbitrary neighbor of 𝜓(𝑣), we can conclude that in G, v is adjacent to at least as many vertices as deg𝐻(𝜓(𝑣)). Hence, deg𝐻(𝜓(𝑣))≤deg𝐺(𝑣).

(4)
Assume that |𝑈|>|𝜓(𝑈)|+𝑘. Fix an arbitrary order on the vertices in U. We define a function 𝜙:𝑈→𝜓(𝑈)∪{⊥} as follows: 𝜙(𝑢𝑖)=𝜓(𝑢𝑖) if 𝜓(𝑢𝑖)≠𝜓(𝑢𝑗) for any 𝑗<𝑖 otherwise 𝜙(𝑢𝑖)=⊥. For a vertex 𝜓(𝑢𝑖) in 𝜓(𝑈), the function 𝜙 selects one vertex amongst the set {𝑢∣𝜓(𝑢)=𝜓(𝑢𝑖)}. Define 𝑈0={𝑢∈𝑈| 𝜙(𝑢)=⊥}. By our assumption, |𝑈0|>𝑘.

Consider an arbitrary vertex 𝑢𝑖 in 𝑈0. By the construction, there is an index 𝑗∈[|𝑈|] such that 𝑢𝑗∈𝑈, 𝜓(𝑢𝑗)=𝜓(𝑢𝑖) and 𝑗<𝑖. As 𝜓(𝑢𝑖)=𝜓(𝑢𝑗), both 𝑢𝑖,𝑢𝑗 are in some big witness set in . As F is the union of edges in this spanning trees of witness sets in , there is a unique path from 𝑢𝑖 to 𝑢𝑗 that comprises only edges in F. Consider the edge in this path incident to 𝑢𝑖. We assign vertex 𝑢𝑖 to this edge in F. As 𝑢𝑖 is an arbitrary vertex in 𝑈0, we can assign an edge in F to every vertex in 𝑈0. Note that we are considering the first edge in the unique path from some vertex in 𝑈0 to some vertex outside 𝑈0. Hence, no two vertices in 𝑈0 can be assigned to same edge in F. This contradicts the fact that |𝐹|≤𝑘. Hence, our assumption is wrong and |𝑈|≤|𝜓(𝑈)|+𝑘. ◻

Maximum Degree Contraction
In this subsection, we prove some observations and a lemma related to MDC. We say a set of edges F is a solution to instance (G, k, d) if the number of edges in F is at most k and the maximum degree of the graph G/F is at most d. The number of edges that we are allowed to contract, k, is also called solution size. We start with the following simple observation that states that contracting an edge in a solution does not produce a NO-instance.

Observation 2
If (G, k, d) is a YES-instance of MDC and 𝐹⊆𝐸(𝐺) is a solution to (G, k, d), then for any edge (u, v) in F, instance (𝐺/{(𝑢,𝑣)},𝑘−1,𝑑) is a YES-instance of MDC.

Next, we bound the maximum degree of the graph by 𝑘+𝑑 in the non-trivial instances of the problem.

Observation 3
If there is a vertex of degree 𝑑+𝑘+1 or more in G then (G, k, d) is a NO-instance.

Proof
Suppose there is a vertex, say v, of degree greater than 𝑑+𝑘+1 in graph G. Assume, for the sake of a contradiction, that (G, k, d) is a YES-instance. Let (G, k, d) is k-contractible to a graph H, via mapping 𝜓, such that the maximum degree of vertices in H is at most d. By Observation 1 (1), |𝑁𝐺[𝑣]|≤|𝜓(𝑁𝐺[𝑣])|+𝑘 where 𝜓(𝑁𝐺[𝑣])=⋃𝑢∈𝑁𝐺[𝑣]𝜓(𝑢). As 𝑑+𝑘+1<|𝑁𝐺[𝑣]|, we have 𝑑+1<|𝜓(𝑁𝐺[𝑣])|. As 𝜓(𝑁𝐺[𝑣])⊆𝑁𝐻(𝜓(𝑣)), vertex 𝜓(𝑣) is adjacent with 𝑑+1 or more vertices in H. This contradicts the fact that the maximum degree of vertices in H is at most d. Hence, our assumption is wrong and (G, k, d) is a NO-instance. ◻

The following observation specifies how a solution behaves locally.

Observation 4
Consider a YES-instance (G, k, d) of MDC and let v be a vertex of degree at least 𝑑+1 in G. Then, for any solution F to (G, k, d), there are at least two vertices in N[v] that are in the same witness set in the G/F-witness structure of G.

Proof
Let G be contractible to a graph G/F, via mapping 𝜓. Assume, for the sake of contradiction, that no two vertices in N[v] are in the same witness set. This implies |𝑁[𝑣]|=|𝜓(𝑁[𝑣])|, where 𝜓(𝑁𝐺[𝑣])=⋃𝑢∈𝑁𝐺[𝑣]𝜓(𝑢). As 𝜓(𝑁𝐺[𝑣])⊆𝑁𝐺/𝐹(𝜓(𝑣)) and |𝑁[𝑣]|>𝑑+1, vertex 𝜓(𝑣) is adjacent with 𝑑+1 or more vertices in G/F. This contradicts the fact that the maximum degree of vertices in G/F is at most d. Hence, our assumption is wrong and there are at least two vertices in N[v] that are in some big-witness set in G/F-witness structure of G. ◻

If every vertex in G has degree at most d, then (G, k, d) is a trivial YES-instance. Hence, there is at least one vertex in G that has degree at least 𝑑+1. We prove that the number of such vertices is bounded.

Observation 5
Let (G, k, d) be a YES-instance of MDC. Then, G contains at most 𝑘(𝑑+2) vertices that has degree at least 𝑑+1.

Proof
Let L be the collection of vertices in G which has degree at least 𝑑+1. As (G, k, d) is a YES-instance, there is a solution, say F, to it. Let  be a (G/F)-witness structure of G. By Observation 4, every vertex in L is either contained in a big-witness set or at least two of its neighbors are in a big witness set. By Observation 1 (1), the number of vertices in big witness sets is at most 2k. As every vertex in G/F has degree at most d, there are at most dk vertices in G that are adjacent to some vertex in big witness sets. This implies that there are at most 𝑘(2+𝑑) vertices in L. ◻

We say that solution F merges at least two vertices in N[v]. Note that for an edge (u, v) in G, it is possible that (𝑢,𝑣)∉𝐹 but F merges u, v.

In the light of Observation 4, the following lemma allows us to conclude that an instance is a NO-instance if we find a sizeable collection of large stars that do not intersect with each other. We present it in the form suitable for the application in the later part of the article.

Lemma 1
For an instance (𝐺,𝑘−1,𝑑), suppose there is subset 𝐿∘ of V(G) that satisfies the following conditions: (i) For every vertex v in 𝐿∘, N(v) is an independent set of size at least 𝑑+1. (ii) For any two different vertices u, v in 𝐿∘, 𝑁(𝑣)∩𝑁(𝑢)=∅. (iii) |𝐿∘|≥𝑘. Then, (𝐺,𝑘−1,𝑑) is a NO-instance.

Proof
Assume, for the sake of contradiction, that (𝐺,𝑘−1,𝑑) is a YES-instance. Let F be a solution to (𝐺,𝑘−1,𝑑), and G is (𝑘−1)-contractible to be G/F via 𝜓. By Observation 4, for every vertex v in 𝐿∘, there are at least two vertices in N[v] which are in same witness set in the G/F-witness structure of G. As N(v) is an independent set, there is no edge both of whose endpoints are in N(v). Hence, for every vertex in 𝐿∘, one of the following two statements must be true: (a) F contains an edge incident to v. (b) F contains at least two edges incident to N(v) but not incident to {𝑣}.

Let 𝐿1 be the collection of vertices in 𝐿∘ for which the first statement is true. Let 𝐹1 be the subset of F that are incident to some vertex in 𝐿1. Recall that for any two vertices in 𝑢,𝑣∈𝐿1, as 𝑁[𝑣]∩𝑁[𝑢]=∅. Hence, no edge in 𝐹1 is incident to more than one vertex in 𝐿∘. Hence, |𝐹1|=|𝐿1|. For every v in 𝐿∘∖𝐿1, there are at least two edges incident to N(v). Note that these edges are in 𝐹∖𝐹1 as they are not incident to any vertex in 𝐿∘. As every edge in 𝐹∖𝐹1 can be incident to the open neighborhood of at most two vertices in 𝐿∘∖𝐿1, we can conclude that 2|𝐹∖𝐹1|≥2|𝐿∘∖𝐿1|. This implies that the number of edges in F is at least |𝐿1|+|𝐿∘∖𝐿1|=|𝐿|. This contradicts the fact that |𝐹|≤𝑘−1 and |𝐿∘|≥𝑘+1. Hence our assumption is wrong and (𝐺,𝑘−1,𝑑) is a NO-instance. ◻

Parameterized Complexity
An instance of a parameterized problem Π comprises of an input I, which is an input of the classical instance of the problem and an integer k, which is called as the parameter. A problem Π is said to be fixed-parameter tractable or in FPT if given an instance (I, k) of Π, we can decide whether or not (I, k) is a YES-instance of Π in time 𝑓(𝑘)⋅|𝐼|(1). Here, 𝑓(⋅) is some computable function whose value depends only on k.

A compression of a parameterized problem Π1 into a (non-parameterized) problem Π2 is a polynomial algorithm that maps each instance (𝐼1,𝑘1) of Π1 to an instance I of Π2 such that (1) (I, k) is a YES-instance of Π1 if and only if 𝐼2 is a YES-instance of Π2, and (2) the size of 𝐼2 is bounded by g(k) for a computable function 𝑔(⋅). The output 𝐼2 is also called a compression. The function g is said to be the size of the compression. A compression is polynomial if g is polynomial. A compression is said to be kernel if Π1=Π2.

A reduction rule is a polynomial time algorithm that takes as an input an instance of a problem and outputs another, usually reduced, instance. A reduction rule said to be applicable on an instance if the output instance is different from the input instance. A reduction rule is safe if the input instance is a YES-instance if and only if the output instance is a YES-instance.

For details on parameterized complexity and related terminologies, we refer the reader to the books of Downey and Fellows [17], Flum and Grohe [19], Niedermeier [37], and the more recent books by Cygan et al. [14] and Fomin et al. [21].

A Lower Bound for the Algorithm
In this section, we prove Theorem 1. We present a reduction from (𝑘×𝑘)-PERMUTATION INDEPENDENT SET (PIS) problem to MAXIMUM DEGREE CONTRACTION problem. In the (𝑘×𝑘)-PIS problem we are given a graph H on a vertex set [𝑘]×[𝑘]. In other words, the vertex set is formed by a 𝑘×𝑘 table. We denote vertices in the table by v[i, j] for 1≤𝑖,𝑗≤𝑘. The question is whether there exists an independent set X in H that contains exactly one vertex from each row and each column of the table. In other words, for every 𝑖,𝑗∈[𝑘] there is exactly one element of X that has i on the first coordinate and j on the second coordinate. Note that without loss of generality we may assume that each row and each column of the table forms an independent set.Footnote3 The following result is known for this problem.

Proposition 1
( [33]) Unless ETH fails, (𝑘×𝑘)-PERMUTATION INDEPENDENT SET can not be solved in time 𝑘𝑜(𝑘).

Reduction The reduction accepts an instance, say (H, k), of (𝑘×𝑘)-PERMUTATION INDEPENDENT SET as input. Here, H is a graph with vertex set formed by a 𝑘×𝑘 table. The reduction modifies a copy of the graph H in the following way.

It adds a vertex corresponding to each row in the table and makes it adjacent with all vertices in that row. Let 𝑅={𝑟1,𝑟2,…,𝑟𝑘} be the set of vertices corresponding to rows.

It adds a vertex corresponding to each column in the table and makes it adjacent with all vertices in that column. Let 𝐶={𝑐1,𝑐2,…,𝑐𝑘} be the set of vertices corresponding to columns.

It adds set 𝑆={𝑠1,𝑠2,…,𝑠𝑘} of k vertices. For every i in [k], it makes 𝑠𝑖 adjacent with every vertex in 𝑅𝑖∪𝐶∪{𝑟𝑖}, where 𝑅𝑖 is the collection of all the vertices in the 𝑖𝑡ℎ row.

For every vertex 𝑟𝑖 in R, it adds 𝑘2 pendant vertices and makes them adjacent with 𝑟𝑖.

For every vertex 𝑐𝑗 in C, it adds (𝑘2−𝑘+1) pendant vertices and makes them adjacent with 𝑐𝑗.

For every vertex 𝑠𝑖 in S, it adds (𝑘2−𝑘+1) pendant vertices and makes them adjacent with 𝑠𝑖.

See Figure 1 for an illustration. Let G be the graph obtained from a copy of graph H with the above modifications. The algorithm returns (𝐺,𝑘,𝑘2+𝑘) as instance of MDC.

Fig. 1
figure 1
Dotted (blue) lines and thin (green) lines show the adjacency of vertices in R and C, respectively. Contracting the thick (red) edge (𝑣[2,3],𝑠2) represents selecting vertex v[2, 3] into the independent set. For the sake of clarity, we do not depict all edges and pendant vertices present in the graph

Full size image
We present an intuition of the proof of correctness. We describe how a solution, if exists, to (G, k, d) leads to a solution to (H, k). We hope that this will also provide some intuition as to how a solution to (H, k) leads to a solution to (G, k, d). Note that S, C, R are independent sets in G. Every vertex in 𝑅∪𝐶∪𝑆 has degree 𝑑+1 and every vertex in 𝑉(𝐺)∖(𝑅∪𝐶∪𝑆) has degree strictly less than d. We first argue that any solution for (G, k, d) can only contain edges in E(G) that have one endpoint in V(H) and another endpoint in S. Then, we prove that for every 𝑖∈[𝑘], any solution must pick an edge incident to some vertex in 𝑖𝑡ℎ row and on 𝑠𝑖 to reduce the degree of 𝑟𝑖. We prove a similar statement for every column. For example, in Fig. 1, to reduce the degree of 𝑟2, at least one edge in {(𝑣[2,1],𝑠2),(𝑣[2,2],𝑠2),(𝑣[2,3],𝑠2)} needs to be contracted. Similarly, to reduce the degree of 𝑐𝑠, at least one edge in {(𝑐[1,3],𝑠1),(𝑐[2,3],𝑠2),(𝑐[3,3],𝑠3)} needs to be contracted. Note that such a contraction reduces the degree of 𝑠𝑖 by one. Hence, for every 𝑖∈[𝑘], a solution contains an edge of the form (𝑣[𝑖,𝑗],𝑠𝑖) for some 𝑗∈[𝑘]. As there are at most k edges in a solution, every edge is of this form. For 𝑖1,𝑖2,𝑗1,𝑗2∈[𝑘], let (𝑣[𝑖1,𝑗1],𝑠𝑖1) and (𝑣[𝑖2,𝑗2],𝑠𝑖2) be two edges in a solution. We argue that if (𝑣[𝑖1,𝑗1],𝑣[𝑖2,𝑗2]) is an edge in G (and hence in H) then the degrees of vertices obtained by contracting (𝑣[𝑖1,𝑗1],𝑠𝑖1) and (𝑣[𝑖2,𝑗2],𝑠𝑖2) are more than d. For example, if a solution contains (𝑣[2,3],𝑠2), then it can not contain (𝑣[3,2],𝑠3) as it will introduce edge between with endpoints 𝑠2,𝑠3, increasing the degree of both of these vertices to 𝑑+1. As this is true for any two arbitrary edges in solution, their endpoints in V(H) form an independent set in H. We formalize this intuition in the following two lemmas.

Lemma 2
Suppose the reduction returns (G, k, d) when the input is (H, k). If (H, k) is a YES-instance of (𝑘×𝑘)-PIS then (G, k, d) is a YES-instance of MDC.

Proof
Suppose (H, k) is a YES-instance, and let X be an independent set in H that contains exactly one vertex from each row and each column of the table. Define a function 𝜌:[𝑘]→[𝑘] such that 𝑗=𝜌(𝑖) if v[i, j] is a vertex in X. By the properties of X, 𝜌 is one-to-one and onto function. We construct solution F to (G, k, d) using independent set X. For every vertex 𝑣[𝑖,𝜌(𝑖)] in X, add edge (𝑠𝑖,𝑣[𝑖,𝜌(𝑖)]) in F. By the construction, the cardinality of F is k. We argue that the maximum degree of any vertex in G/F is d. As mentioned before, in G, 𝑅∪𝐶∪𝑆 is the collection of all vertices of degree strictly greater than d. More precisely, every vertex in 𝑅∪𝐶∪𝑆 has degree 𝑑+1. We prove that contracting edges in F reduces the degree of each vertex in 𝑅∪𝐶 ∪𝑆 by one.

Note that edges in F form a matching in G. For every i in [k], let 𝑠∘𝑖 be the new vertex added while contracting edge (𝑠𝑖,𝑣[𝑖,𝜌(𝑖)]). Let 𝐺′=𝐺/𝐹 and 𝑆∘={𝑠∘1,𝑠∘2,…,𝑠∘𝑘}. Set 𝑉(𝐺′) can be partitioned into 𝑅,𝐶,𝑆∘, 𝑉(𝐻)∖𝑋, and pendant vertices which are adjacent with 𝑅∪𝐶∪𝑆. Every vertex in 𝑉(𝐻)∖𝑋 is adjacent with at most 𝑘2−2𝑘 vertices in 𝑉(𝐻)∖𝑋 (as every row or column is an independent set) and 3 vertices in 𝑅∪𝐶∪𝑆. Hence, the degree of each vertex in 𝑉(𝐻)∖𝑋 is at most 𝑘2−2𝑘+3≤𝑑−3𝑘+3≤𝑑. Every vertex in R is adjacent with 𝑘−1 vertices in 𝑉(𝐻)∖𝑋, one vertex in 𝑆∘, and 𝑘2 pendant vertices in 𝐺′. Hence, the degree of every vertex in R in 𝐺′ is 𝑘−1+1+𝑘2=𝑑. For a vertex, say 𝑐𝑗, in C, there exists a vertex 𝑣[𝑖,𝜌(𝑖)] in X such that 𝑗=𝜌(𝑖). Hence, in graph 𝐺′, vertex 𝑐𝑗 is adjacent with 𝑘−1 vertices in V(H), k vertices in 𝑆∘, and 𝑘2−𝑘+1 pendant vertices. Hence, the degree of 𝑐𝑗 in 𝐺′ is 𝑘−1+𝑘+𝑘2−𝑘+1=𝑑. Since 𝑐𝑗 is an arbitrary vertex in C, this is true for every vertex in C.

We now argue that 𝑆∘ is an independent set in 𝐺′. Consider two different vertices, say 𝑠∘𝑖,𝑠∘𝑗 in 𝑆∘. By the construction, 𝑠𝑖 and 𝑠𝑗 are not adjacent with each other in G. As X is an independent set in G, vertices 𝑣[𝑖,𝜌(𝑖)],𝑣[𝑗,𝜌(𝑗)] in X are not adjacent with each other. Recall that, among the vertices in V(H), 𝑠𝑖 is adjacent with vertices that are in 𝑖𝑡ℎ row only. And the similar statement is true for 𝑠𝑗. This implies that there is no edge with one endpoint in set {𝑠𝑖,𝑣[𝑖,𝜌(𝑖)]} and another endpoint in {𝑠𝑗,𝑣[𝑗,𝜌(𝑗)]}. Hence, vertices 𝑠∘𝑖 and 𝑠∘𝑗 are not adjacent with each other in 𝐺′. Since this is true for any two vertices in 𝑆∘, it is an independent set in 𝐺′. By the construction, for any i in [k], vertex 𝑣[𝑖,𝜌(𝑖)] is adjacent with only one vertex, viz 𝑟𝑖, in R. Hence, any vertex 𝑠∘𝑖 in S is adjacent with one vertex vertex in R, 𝑘−1 vertices in 𝑉(𝐻)∖𝑋 that are in 𝑖𝑡ℎ row, k vertices in C, and 𝑘2−𝑘 many pendant vertices in graph 𝐺′. This implies that every vertex in 𝑆∘ has degree 1+𝑘−1+𝑘+𝑘2−𝑘=𝑑. Hence, the maximum degree of any vertex in 𝐺′ is at most d. This implies that (G, k, d) is a YES-instance which concludes the proof. ◻

In the remaining section, we prove the following lemma.

Lemma 3
Suppose the reduction returns (G, k, d) when the input is (H, k). If (G, k, d) is a YES-instance of MDC then (H, k) is a YES-instance of (𝑘×𝑘)-PIS.

To prove the lemma, we first investigate how a solution to (G, k, d) can intersect with edges in G. Recall that for vertex subsets X, Y, we denote the set of all edges with one endpoint in X and another endpoint in Y by E(X, Y). Let 𝑃𝐶, 𝑃𝑅, and 𝑃𝑆 be the collection of pendant vertices that are adjacent with C, R, and S, respectively. By the construction, the edges of G can be partitioned into following five sets: 𝐸(𝐶∪𝑅∪𝑆,𝑃𝐶∪𝑃𝑅∪𝑃𝑆), 𝐸(𝐶∪𝑅,𝑆), 𝐸(𝐶∪𝑅,𝑉(𝐻)), E(V(H), V(H)), and E(S, V(H)). We first prove that any solution to (G, k, d) does not intersect with the first four sets.

Suppose (G, k, d) is a YES-instance, and let 𝐹⊆𝐸(𝐺) be a solution to (G, k, d).

Claim 1
𝐹∩𝐸(𝐶∪𝑅∪𝑆,𝑃𝐶∪𝑃𝑅∪𝑃𝑆)=∅.

Proof
Assume that there exists an edge, say (𝑐𝑖,𝑣), in 𝐹∩𝐸(𝐶,𝑃𝐶) where vertices 𝑐𝑖,𝑣 are in C and 𝑃𝐶, respectively. Note that, instance (𝐺/{(𝑐𝑖,𝑣)},𝑘−1,𝑑) and set R satisfy the premise of Lemma 1. Hence, we can conclude that (𝐺/{(𝑐𝑖,𝑣)},𝑘−1,𝑑) is a NO-instance. This contradicts Observation 2. Hence our assumption is wrong and 𝐹∩𝐸(𝐶,𝑃𝐶) is an empty set.

Using the similar arguments, 𝐹∩𝐸(𝑆,𝑃𝑆) is an empty set.

Assume that there exists edge (𝑟𝑖,𝑣) in 𝐹∩𝐸(𝑅,𝑃𝑅) where vertices 𝑟𝑖,𝑣 are in R and 𝑃𝑅, respectively. Let 𝑅′ be the set obtained from R by removing 𝑟𝑖 and adding the vertex which is introduced while contracting edge (𝑟𝑖,𝑣). Note that, instance (𝐺/{(𝑟𝑖,𝑣)},𝑘−1,𝑑) and set 𝑅′ satisfy the premise of Lemma 1. Hence, we can conclude that (𝐺/{(𝑟𝑖,𝑣)},𝑘−1,𝑑) is a NO-instance. This contradicts Observation 2. Hence our assumption is wrong and 𝐹∩𝐸(𝑅,𝑃𝑅) is an empty set.

By the construction of G, sets 𝐸(𝐶,𝑃𝑅∪𝑃𝑆), 𝐸(𝑆,𝑃𝑅∪𝑃𝐶), and 𝐸(𝑅,𝑃𝐶∪𝑃𝑆) are empty. This implies that there is no edge in 𝐹∩𝐸(𝐶∪𝑅∪𝑆,𝑃𝐶∪𝑃𝑅∪𝑃𝑆). ◻

Claim 2
𝐹∩𝐸(𝐶∪𝑅,𝑆)=∅.

Proof
Assume that there exists an edge, say (𝑠𝑖,𝑐𝑗), in 𝐹∩𝐸(𝐶,𝑆) where vertices 𝑠𝑖,𝑐𝑗 are in S and C, respectively. Let w be the new vertex introduced while contracting edge (𝑠𝑖,𝑐𝑗). In graph (𝐺/{(𝑠𝑖,𝑐𝑗)}, vertex w is adjacent with all pendant vertices which were adjacent with 𝑠𝑖 or 𝑐𝑗 in G. Hence, the degree of w in (𝐺/{(𝑠𝑖,𝑐𝑗)}) is at least 2(𝑘2+𝑘−1)>𝑑+𝑘. By Observation 4, (𝐺/{(𝑐𝑖,𝑠𝑗)},𝑘−1,𝑑) is a NO-instance. This contradicts Observation 2. Hence our assumption is wrong and 𝐹∩𝐸(𝐶,𝑆) is an empty set. We can conclude that 𝐹∩𝐸(𝑅,𝑆) is an empty set by similar arguments. This concludes the proof of the claim. ◻

Claim 3
𝐹∩𝐸(𝐶,𝑉(𝐻))=∅.

Proof
Assume that there exists an edge, say (𝑐𝑗,𝑥[𝑖,𝑗]), in 𝐹∩𝐸(𝐶,𝑉(𝐻)) where vertices 𝑐𝑗,𝑥[𝑖,𝑗] are in C and V(H), respectively. Note that, instance (𝐺/{(𝑐𝑗,𝑥[𝑖,𝑗])},𝑘−1,𝑑) and set R satisfy the premise of Lemma 1. Hence, we can conclude that (𝐺/{(𝑐𝑗,𝑥[𝑖,𝑗])},𝑘−1,𝑑) is a NO-instance. This contradicts Observation 2. Hence our assumption is wrong and 𝐹∩𝐸(𝐶,𝑉(𝐻)) is an empty set. ◻

Claim 4
𝐹∩𝐸(𝑅,𝑉(𝐻))=∅.

Proof
Assume that 𝐹∩𝐸(𝑅,𝑉(𝐻)) is not empty. As any vertex 𝑐𝑗 in C has degree 𝑑+1, edges in F merge at least two vertices in 𝑁[𝑐𝑗] (Lemma 1). We argue that if our assumption is correct then there are not enough edges to merge two vertices in each 𝑁[𝑐𝑗].

Let 𝐽′ be the set of columns such that there is no edge of the form (𝑥[𝑖,𝑗′],𝑠) in F, where 𝑖,𝑗′∈[𝑘] and 𝑠∈𝑆. Note that set 𝐽′ is not empty as there are k columns and at most (𝑘−1) edges in 𝐹∩𝐸(𝑉(𝐻),𝑆). There are at most |𝐹|−(𝑘−|𝐽′|)=|𝐽′| many edges to merge two vertices in 𝑁[𝑐′𝑗] for each 𝑗′ in 𝐽′. For any two different vertices 𝑐𝑗,𝑐𝑗′ in C, their neighborhoods outside S do not intersect. Formally, (𝑁[𝑐𝑗]∖𝑆)∩(𝑁[𝑐𝑗′]∖𝑆)=∅. Hence, |𝐽′| many edges need to cover 2|𝐽′| vertices. This implies that edges in 𝐹∖𝐸(𝑉(𝐻),𝑆) form a matching in G. For any vertex 𝑐𝑗 in C, its neighborhood is an independent set. Hence, the only possible way to merge two vertices in each 𝑁[𝑐𝑗′] using edges in matching is to contract an edge incident to 𝑐𝑗′ and one of its neighbors in V(H). Hence, all the edges in 𝐹∖𝐸(𝑉(𝐻),𝑆) are in E(C, V(H)). This is a contradiction to Claim 2 which states that there is no solution edge in E(C, V(H)). Hence our assumption is wrong and 𝐹∩𝐸(𝑅,𝑉(𝐻))=∅. ◻

Claim 5
𝐹∩𝐸(𝑉(𝐻),𝑉(𝐻))=∅.

Proof
Assume that there exists an edge, say (𝑥[𝑖,𝑗],𝑥[𝑖′,𝑗′]), in 𝐹∩𝐸(𝑉(𝐻),𝑉(𝐻)) for some 𝑖,𝑗,𝑖′,𝑗′∈[𝑘]. Consider instance (𝐺/{(𝑥[𝑖,𝑗],𝑥[𝑖′,𝑗′])},𝑘−1,𝑑). As any vertex 𝑟𝑖 in R have degree 𝑑+1, edges in any solution for the instance merge at least two vertices in 𝑁[𝑟𝑖] (Lemma 1). Hence, 𝐹∖{(𝑥[𝑖,𝑗],𝑥[𝑖′,𝑗′])} merges at least two vertices in 𝑁[𝑟𝑖] for each 𝑟𝑖 in R. Let Y be the set of vertices in 𝐺/{(𝑥[𝑖,𝑗],𝑥[𝑖′,𝑗′])} such that Y contains at least two vertices in 𝑁[𝑟𝑖] for every 𝑟𝑖 in R. Note that the cardinality of Y is at least 2𝑘−1. By Claim 4, there is no edge in 𝐹∩𝐸(𝑅,𝑉(𝐻)). This implies that at most (𝑘−1) edges in 𝐹∖{(𝑥[𝑖,𝑗],𝑥[𝑖′,𝑗′])} covers at least 2𝑘−1 vertices. This is a contradiction as any edge can cover at most two vertices. Hence our assumption is wrong and 𝐹∩𝐸(𝑉(𝐻),𝑉(𝐻))=∅. ◻

Proof
(of Lemma 3) By Claims 1 to 5, every edge in F is of the form (𝑥[𝑖,𝑗],𝑠ℓ) for some 𝑖,𝑗,ℓ∈[𝑘] where 𝑥[𝑖,𝑗]∈𝑉(𝐻) and 𝑠ℓ∈𝑆. Let 𝑋′ be the collection of vertices in V(H) that are endpoints of some edges in F. The size of 𝑋′ is at most k. In the remaining part, we argue that 𝑋′ is an independent set in H and contains one vertex from each row and column.

We first argue that for every vertex in 𝑠ℓ in S, there is exactly one edge in F which is incident to 𝑠ℓ. Note that S is an independent set and every vertex in it has the degree 𝑑+1. By Lemma 1, edges in F merges at least two vertices in 𝑁[𝑠ℓ] for every 𝑠ℓ. As |𝐹|≤𝑘 and |𝑆|=𝑘, there is exactly one edge incident to 𝑠ℓ for every ℓ∈[𝑘].

We now prove that 𝑋′ contains one vertex from every row and column. Recall that for every 𝑖∈[𝑘], the degree of vertex 𝑟𝑖 is 𝑑+1 in G and 𝑁(𝑟𝑖) contains 𝑠𝑖 and all the vertices in 𝑖𝑡ℎ row. By Lemma 1, for every i, edges in F merge at least two vertices in 𝑁[𝑟𝑖]. Hence, the other endpoint of the edge incident 𝑠𝑖 is some vertex in 𝑖𝑡ℎ row. This implies there exists a vertex in 𝑋′ from each row. To prove a similar statement for column, recall that for every 𝑗∈[𝑘], the degree of 𝑐𝑗 is 𝑑+1 in G, and 𝑁(𝑐𝑗) contains {𝑣[𝑖,𝑗],𝑠𝑖} for every 𝑖∈[𝑘]. Once again, by Lemma 1, for every j, edges in F merge at least two vertices in 𝑁[𝑐𝑗]. Hence, the other endpoint of the edge incident on 𝑠𝑖 is some vertex in 𝑗𝑡ℎ column. This implies there exists a vertex in 𝑋′ from each column.

It remains to argue that 𝑋′ is an independent set in H. Define function 𝜙:𝑆→𝑉(𝐻) as follows: For every 𝑠ℓ∈𝑆, assign 𝜙(𝑠ℓ)=𝑥[𝑖,𝑗] if (𝑥[𝑖,𝑗],𝑠ℓ)∈𝐹 for some 𝑖,𝑗∈[𝑘]. As there is exactly one edge in F which is incident to 𝑠ℓ, function 𝜙 is well defined. Assume that there exists an edge (𝜙(𝑠ℓ),𝜙(𝑠ℓ′)) in H. Let 𝑠∘ℓ and s^{\circ }_{{\ell }'} be the two new vertices added while contracting edges (s_{\ell }, \phi (s_{\ell })) and (s_{{\ell }'}, \phi (s_{{\ell }'})). Note that s^{\circ }_{\ell } is adjacent with s^{\circ }_{{\ell }'}, one vertex in R, k - 1 vertices in V(H) that are in {\ell }^{th} row, k vertices in RC, and k^2 - k + 1 pendant vertices in V(H). Hence, the degree of s^{\circ }_l is 1 + 1 + k - 1 + k + k^2 - k + 1 = d + 1. This contradicts the fact that every vertex in G/F have degree at most d. Hence our assumption is wrong and there is no edge (\phi (s_{\ell }), \phi (s_{{\ell }'})) in H. Since, s_{\ell }, s_{{\ell }'} are any two arbitrary vertices in S, we can conclude that X' is an independent set in H.

Hence, if (G, k, d) is a YES-instance of MDC then (H, k) is a YES-instance of (k \times k)-PIS. \square

We now present a proof of Theorem 1 using Proposition 1, Lemmas 2, and 3.

Proof of Theorem 1
Assume, for the sake of contradiction, that there is an algorithm, say {\mathcal {A}}, that given any instance (G, k, d) of MDC runs in time n^{o(k)} and correctly determines whether it is a YES-instance. Consider the algorithm {\mathcal {B}} that given an instance (H, k) of (k \times k)-PIS constructs an instance (G, k, d) of MDC as described in the reduction. Then, it calls Algorithm {\mathcal {A}} as subroutine on instance (G, k, d). If Algorithm {\mathcal {A}} returns YES then Algorithm {\mathcal {B}} returns YES otherwise it returns NO. The correctness of Algorithm {\mathcal {B}} follows from the correctness of Algorithm {\mathcal {A}}, Lemmas 2, and 3. We now argue the running time of Algorithm {\mathcal {B}}. By the description of the reduction, it is easy to see that given instance (H, k), the algorithm computes instance (G, k, d) in time polynomial in |V(H)| \in {\mathcal {O}}(k^2) and |V(G)| = n \in {\mathcal {O}}(k^2). Hence, the total running time of the algorithm is n^{o(k)} = k^{o(k)}.

This implies that there is an algorithm to solve (k\times k)-PIS in time k^{o(k)} contradicting Proposition 1. Hence, our assumption is wrong which concludes the proof. \square

A Different FPT Algorithm
Recall that Belmonte et al. [8] presented an FPT algorithm for MDC that runs in time (d + k)^{2k} \cdot n^{{\mathcal {O}}(1)}. In this section, we present a different FPT algorithm for MAXIMUM DEGREE CONTRACTION that runs in time 2^{{\mathcal {O}}(dk)} \cdot n^{{\mathcal {O}}(1)}.

Consider a YES-instance (G, k, d) is of MDC. Suppose F is a solution to (G, k, d). Note that |V(F)| \le 2k. It is easy to verify that every vertex in G - V(F) has degree at most d. We argue that the number of vertices in N(V(F)) is at most kd. To identify this ‘interesting part’ of the graph, we label vertices in V(G) uniformly at random using red and blue labels. All the vertices in V(F) and N(V(F)) are labeled with red and blue, respectively, with high probability. Note that be some other vertices that got labeled red or blue but are not in V(F) and N(V(F)), respectively. Hence, we need to identify the red and blue vertices corresponding these two sets. After correctly identifying these, it is sufficient to contract a spanning tree of red-labeled connected components corresponding to V(F). To utilize these ideas, we introduce a variation of the problem called LABELED-MAXIMUM DEGREE CONTRACTION (LABELED-MDC). We present an FPT algorithm for LABELED-MDC and use it as a subroutine to present an FPT algorithm for MDC.

Informally, an instance of LABELED-MDC is an instance of MDC along with a labeling of vertices in the graph. Every vertex has a red or blue label. We are only interested in a solution that satisfies the following properties: (1) every edge has red labelled endpoints, and (2) for any red-labelled maximal connected component, a solution either spans none or all the vertices in that component. We remark that because of the second condition, this problem is not a restricted version of MDC. We formally define LABELED-MDC as follows.

figure b
We say a set of edges F is a solution to instance (G, (V_r, V_b), k, d) if the number of edges in F is at most k, the maximum degree of graph G/F is at most d, V(F) \subseteq V_r and for a connected component C of G[V_r], if C \cap V(F) \ne \emptyset then C \subseteq V(F).

It is easy to see that if (G, (V_r, V_b), k, d) is a YES-instance of LABELED-MDC then (G, k, d) is a YES-instance of MDC. Let {\mathcal {U}} be the family of all subsets of V(G). If (G, k, d) is a YES-instance of MDC then (G, (V_r, V(G) \setminus V_r), k, d) is a YES-instance of LABELED-MDC for some set V_r in {\mathcal {U}}. We use universal sets to construct a ‘small’ family of subsets of V(G) that suffices for our purpose. We assume that there is a unique integer in [n] for every vertex in V(G). We use a subset of [n] and a corresponding subset of V(G) interchangeably.

Definition 2
(Universal Sets) An (n, l)-universal set is a family {\mathcal {U}} of subsets of [n] such that for any S \subseteq [n] of size l, the family \{A \cap S\ |\ A \in {\mathcal {U}} \} contains all subsets of S.

Proposition 2
( [5]) For any n, l \ge 1 one can construct an (n, l)-universal set of size 2^{{\mathcal {O}}(l)} \cdot \log (n) in time 2^{{\mathcal {O}}(l)} \cdot n \log (n).

In the following lemma, we argue that an FPT algorithm for LABELED-MDC leads to an FPT algorithm for MDC.

Lemma 4
Suppose there is an algorithm that given an instance (G, (V_r, V_b), k, d) of LABELED-MDC runs in time f(k, d) \cdot n^{{\mathcal {O}}(1)} and correctly determines whether it is a YES-instance. Then, there is an algorithm that given an instance (G, k, d) of MDC runs in time 2^{{\mathcal {O}}(dk)} \cdot f(k, d) \cdot n^{{\mathcal {O}}(1)} and correctly determines whether it is a YES-instance.

Proof
Let {\mathcal {A}} be an algorithm that given an instance (G, (V_r, V_b), k, d) of LABELED-MDC runs in time f(k, d) \cdot n^{{\mathcal {O}}(1)} and correctly determines whether it is a YES-instance. We first describe an algorithm for MDC that uses {\mathcal {A}} as a subroutine. For the input (G, k, d), the algorithm constructs a (n, 2k + kd)-universal family {\mathcal {U}} using Proposition 2. For every set V_r in {\mathcal {U}}, the algorithm runs Algorithm {\mathcal {A}} with input (G, (V_r, V(G) \setminus V_r), k, d). The algorithm returns YES if Algorithm {\mathcal {A}} returns YES for one of these inputs otherwise it returns NO. This completes the description of the algorithm.

The running time of the algorithm follows from the description and Proposition 2. In the remaining proof, we argue the correctness of the algorithm. More precisely, we prove that (G, k, d) is a YES-instance of MDC if and only if there is a subset V_r in {\mathcal {U}} such that (G, (V_r, V(G) \setminus V_r), k, d) is a YES-instance of LABELED-MDC.

Suppose that (G, k, d) is a YES-instance of MDC and let F be a solution to it. Note that |V(F)| \le 2k. We first argue that the number of vertices in N(V(F)) is at most kd. Let {\mathcal {W}} be the G/F-witness structure of G and \psi : V(G) \rightarrow V(G/F) be the corresponding function. Consider an arbitrary vertex v in N(V(F)). As v is not in V(F), \psi (v) corresponds to a small witness set in {\mathcal {W}}. As v is in N(V(F)), \psi (v) is adjacent to a vertex in G/F that corresponds to a big witness set in {\mathcal {W}}. By Observation 1 (1), there are at most k big witness sets in {\mathcal {W}}. Since the maximum degree of G/F is at most d, there are at most kd small witness sets in {\mathcal {W}} that are adjacent with some big witness set. Hence, there are at most kd vertices in N(V(F)). As {\mathcal {U}} is a (n, 2k + dk)-universal set and |N[V(F)]| \le 2k + dk, the family \{A \cap N[V(F)]~|\ A \in {\mathcal {U}} \} contains all subsets of N[V(F)]. This implies, there exists a set, say V_r, such that V_r \cap N[V(F)] = V(F). We argue that (G, (V_r, V(G) \setminus V_r), k, d) is a YES-instance of LABELED-MDC.

Note that G/F has maximum degree at most d and V(F) \subseteq V_r. We need to prove that for a connected component C of G[V_r] if C \cap V(F) \ne \emptyset then C \subseteq V(F). Assume that there exits a connected component C of G[V_r] such that C \cap V(F) \ne \emptyset and C \setminus V(F) \ne \emptyset . As C is a connected component and C \cap V(F) \ne \emptyset , there exists a vertex v in C \setminus V(F) that is adjacent with some vertex in V(F). Hence, there is a vertex in N(V(F)) \cap V_r. This contradicts the fact that V_r \cap N[V(F)] = V(F). Hence, our assumption is wrong and C \setminus V(F) is an empty set. This implies (G, (V_r, V(G)\setminus V_r), k, d) is a YES-instance of LABELED-MDC. As mentioned before, it is easy to see that if (G, (V_r, V_b), k, d) is a YES-instance of LABELED-MDC then (G, k, d) is a YES-instance of MDC. This concludes the proof of the lemma. \square

In the remaining section, we present a recursive algorithm for LABELED-MDC. We start with some simple reduction rules.

Reduction Rule 1 If the reduced instance is a trivial YES-instance (resp. NO-instance) then the algorithm returns YES(resp. NO).

For example, for an instance (G, (V_r, V_b), k, d), if the maximum degree of vertices in G is at most d and k \ge 0 then return a YES-instance. Recall that a set of edges F is called solution to (G, (V_r, V_b), k, d) if the number of edges in F is at most k, the maximum degree of graph G/F is at most d, V(F) \subseteq V_r, and for a connected component C of G[V_r], if C \cap V(F) \ne \emptyset then C \subseteq V(F). Consider a connected component C of G[V_r]. If |C| = 1 then no solution edge can be incident to it. Also, if |C| \ge 2k + 1 then because of the last property and the fact that |V(F)| \le 2k, no solution edge can be incident to vertices in C. These simple observations prove that the following reduction rule is safe.

Reduction Rule 2 For an instance (G, (V_r, V_b), k, d), if there is a connected component, say C, of G[V_r] such that |C| = 1 or |C| \ge 2k + 1 then move C from V_r to V_b i.e. return instance (G, (V_r \setminus C, V_b \cup C), k, d).

By Observation 4, a vertex v in V_b can be adjacent to at most d + k vertices in V_r. The following reduction rule ensures that the neighbors of v in V_r are not spread across many connected components.

Reduction Rule 3 For an instance (G, (V_r, V_b), k, d), if there exists a vertex, say v, in V_b for which N_G(v) intersects with d + 1 different connected components of G[V_r] then return a NO-instance.

Lemma 5
Reduction Rule 4 is safe.

Proof
Assume that (G, (V_r, V_b), k, d) is a YES-instance. Let F be its solution and it contracts G to G/F via mapping \psi . Suppose C_1, C_2, \dots , C_{d+1} are connected components of G[V_r] such that C_i \cap N(v) \ne \emptyset for i \in [d + 1]. For every i, consider a vertex, say u_i, in C_i \cap N(v). Let U = \{u_1, u_2, \dots , u_{d + 1}\}. Define \psi (U) = \bigcup _{u \in U} \psi (u). For i, j \in [d + 1], i \ne j implies \psi (u_i) \ne \psi (u_j) as C_i and C_j are two different connected components of G[V_r] and V(F) \subseteq V_r. This implies |\psi (U)| = |U| = d + 1. As V(F) \subseteq V_r and v \in V_b, F does not contain an edge incident to v. Hence, \psi (v) \ne \psi (u_i) for any i \in [d + 1]. As \psi (U) \subseteq N_{G/F}(\psi (v)) and |\psi (U)| \ge d + 1, vertex \psi (v) is adjacent with d + 1 or more vertices in G/F. This contradicts the fact that the maximum degree of vertices in G/F is at most d. Hence, our assumption is wrong and (G, (V_r, V_b), k, d) is a NO-instance. \square

The algorithm exhaustively applies the reduction rules mentioned above. On the reduced instance, it creates multiple instances using the following subroutine. For an instance (G, (V_r, V_b), k, d), a subset R of V_r, and a (d + 1)-coloring of R, the subroutine creates the new instance by contracting each colored component of R into a single vertex, and (re-)labeling it blue. We need the notion of ‘valid coloring’ to filter out colorings that will not produce ‘smaller’ instances. For graph H, a vertex coloring \phi : V(H) \rightarrow [d + 1] is said to be a valid coloring if every monochromatic connected component is of size at least two. We now describe the subroutine.

Subroutine Colorwise-Contraction The subroutine takes as an input an instance (G, (V_r, V_b), k, d) of LABELED-MDC, a non-empty subset R of V_r, and a valid coloring \phi of G[R]. It returns another instance of LABELED-MDC. It initializes G' = G, V_r' = V_r, V_b' = V_b, and k' = k. For a monochromatic connected component C of G[R], the subroutine finds a spanning tree of G[C] and contracts all edges in it. Let v_C be the vertex obtained at the end of this series of edge contractions. It updates V'_r = V_r \setminus C, V'_b = V_b \cup \{v_C\} and reduces k by |C| - 1. The subroutine repeats this procedure for every monochromatic connected component of G[R]. It returns (G', (V'_r, V'_b), k', d) as instance of LABELED-MDC. This completes the description of the subroutine.

It is easy to verify that (V_r', V'_b) is a partition of V(G'). As \phi is a valid coloring of G[R], the union of spanning trees of all monochromatic connected components of G[R] contains at least |R|/2 edges. Hence, the subroutine contracts at least |R|/2 edges. This small observation is helpful to get the desired bound on the running time of the algorithm.

Remark 1
k' \le k - |R|/2.

Let \texttt {CC}[(G, (V_r, V_b), k, d); R; \phi ] denote the instance returned by the subroutine when the input is (G, (V_r, V_b), k, d), R, and \phi . In the following lemma, we prove that if the original instance is a YES-instance then at least one of the reduced instances is a YES-instance.

Lemma 6
Consider a YES-instance (G, (V_r, V_b), k, d) of LABELED-MDC. Let R be the union of some connected components of G[V_r]. Suppose there is solution F to (G, (V_r, V_b), k, d) such that R \subseteq V(F). Then, there is a valid coloring \phi : R \rightarrow [d + 1] of G[R] for which \texttt {CC} [(G, (V_r, V_b), k, d); R; \phi ] is a YES-instance.

Proof
Let H = G/F. Consider the H-witness structure {\mathcal {W}} of G and let G be contracted to H via \psi . Define a subset {\mathcal {W}}_R of {\mathcal {W}} as the collection of witness sets that intersects R. Formally, {\mathcal {W}}_R = \{W \in {\mathcal {W}}\ |\ W \cap R \ne \emptyset \}. Let {\mathcal {W}}_R = \{W_1, W_2, \dots , W_q\}. For every i \in [q], let h_i be the vertex corresponding to W_i. In other words, W_i = \{v \in V(G)\ |\ \psi (v) = h_i\}. Let R_H = \{h_1, h_2, \dots , h_q\}.

Let F_1 be the collection of edges in F that are incident to some vertex in R. Hence, R \subseteq V(F_1). As R is the union of connected components in G[V_r] and V(F_1) \subseteq V(F) \subseteq V_r, we can conclude that R = V(F_1) = \bigcup _{i \in [q]} W_i. Hence, \{W_1, W_2, \dots , W_q\} is a partition of R. As there is a solution edge incident to every vertex in R, every witness set in {\mathcal {W}}_R is a big witness set. This implies for every i \in [q], there is a subset F_i of F such that W_i = V(F_i). As the maximum degree of vertices in graph H is at most d, there is a proper (d+1)-coloring, say \gamma , of H. For i, j \in [q], if (h_i, h_j) is an edge in H then \gamma (h_i) \ne \gamma (h_j). Define a coloring \phi :R \rightarrow [d + 1] as follows. For v \in R, \phi (v) = \gamma (h_i) where v \in W_i. As \{W_1, W_2, \dots , W_q\} is a partition of R, function \phi is well defined. Since W_i is a big witness set, \phi is a valid coloring.

By the construction of \phi , any witness set in {\mathcal {W}} is monochromatic. Since \gamma is a proper coloring of H, any two witness sets adjacent to each other have distinct colors. Hence, every witness set in {\mathcal {W}}_R is a monochromatic connected component of coloring \phi . As the algorithm constructs every valid coloring of R, it also considers this coloring and creates instance (G', (V_r', V_b'), k', d) = \texttt {CC}[(G, (V_r, V_b), k, d), R; \phi ]. For every i \in [q], let F^{\circ }_i be edges in a spanning tree of G[W_i]. Define F^{\circ } = \bigcup _{i \in [q]} F^{\circ }_i. As W_i = V(F_i), graphs G/F_1 and G/F^{\circ } are identical. Also, |F^{\circ }_i| \le |F_i| which implies |F^{\circ }| \le |F_1|. Define F^{\star } = (F \setminus F_1) \cup F^{\circ }. It is easy to verify that F^{\star } is also a solution to (G, (V_r, V_b), k, d).

We now argue that F^{\star } \setminus F^{\circ } is a solution to (G', (V_r', V_b'), k', d). By the description of the algorithm, k' = k - |F^{\circ }|. As |F^{\star }| \le |F| \le k and F^{\circ } \subseteq F^{\star }, we have |F^{\star } \setminus F^{\circ }| \le |F^{\star }| - |F^{\circ }| \le k'. Note that G/F^{\star } = (G/F^{\circ })/(F^{\star }\setminus F^{\circ }) = G'/(F^{\star }\setminus F^{\circ }) as G' = G/F^{\circ }. This implies the maximum degree of G'/(F^{\star }\setminus F^{\circ }) is at most d. The only thing that remains to argue is that V(F^{\star }\setminus F^{\circ }) is contained in V_r'. By the construction, F \setminus F_1 = F^{\star } \setminus F^{\circ }. As F_1 is the set of edges in F that were incident to R, we can conclude that no edge in F^{\star } \setminus F^{\circ } is incident to R. Recall that V_r' = V_r \setminus R. Hence, V(F^{\star } \setminus F^{\circ }) \subseteq V_r'. This implies that F^{\star } \setminus F^{\circ } is a solution to (G', (V_r', V_b), k', d) and concludes the proof of the lemma. \square

In the above lemma, instead of considering an arbitrary subset of V_r, we only consider a subset that is union of one or more connected components of G[V_r]. This suffices for our purpose as the algorithm calls the subroutine only on such subsets of V_r. Also, note that we do not need to know the solution F explicitly to apply the above lemma. It suffices to know that such a solution exists. We now present the algorithm for LABELED-MDC.

Algorithm for LABELED-MDC The algorithm takes as input an instance (G, (V_r, V_b), k, d) of LABELED-MDC and returns YES or NO. If k < 0 then the algorithm returns NO. If k = 0 then it finds the maximum degree of G. If it is at most d then the algorithm returns YES otherwise it returns NO. The algorithm exhaustively applies Reduction Rules 4, 4, and 4. If the reduced instance is a trivial YES-instance (resp. NO-instance) then the algorithm returns YES (resp. NO). Otherwise, it creates multiple instances and makes recursive calls on these instances. The algorithm returns YES if one of the recursive calls returns YES, otherwise; it returns NO.

We now describe the procedure used by the algorithm to create new instances. Let (G, (V_r, V_b), k, d) be the instance on which the reduction rules are not applicable. The algorithm finds a vertex, say v, in G such that \deg _G(v) \ge d + 1. It considers the following two cases.

1.
(Vertex v is in V_r) Let R be the connected component of G[V_r] that contains v. The algorithm constructs all valid colorings \phi : R \rightarrow [d + 1] of G[R]. For each coloring, the algorithm calls subroutine Colorwise-Contraction with input (G, (V_r, V_b), k, d), R, and \phi . The algorithm calls itself with the instances returned by this subroutine as the input.

2.
(Vertex v is in V_b) Let C_1, C_2, \dots , C_q be the connected components of G[V_r] such that N(v) \cap C_i \ne \emptyset for every i \in [q]. For a non-empty subset I \subseteq [q], define R_I := \bigcup _{i \in I} C_i. For every non-empty subset I \subseteq [q], the algorithm proceeds as follows: If |R_I| \ge 2k + 1, the algorithm discards this choice of I and moves to the next one. Otherwise, it constructs all valid colorings \phi : R_I \rightarrow [d + 1] of G[R_I]. For each coloring, it calls subroutine Colorwise-Contraction with input (G, (V_r, V_b), k, d), R_I, and \phi . The algorithm calls itself with the instance returned by this subroutine as input.

This completes the description of the algorithm.

In the following lemma, we prove that the algorithm described above is correct and runs in the desired time.

Lemma 7
There is an algorithm that given an instance (G, (V_r, V_b), k, d) of LABELED-MDC runs in time 2^{(d + 2) k} \cdot (d + 1)^{2k} \cdot n^{{\mathcal {O}}(1)} and correctly determines whether it is a YES-instance.

Proof
We argue that the algorithm described above solves LABELED-MDC in the desired time. We prove this by the induction on the solution size k.

Consider the base case when the solution size is zero. Here, the algorithm finds the maximum degree of the graph and depending on its value returns YES or NO. Assume that the lemma is true when the solution size is at most k - 1.

We first prove that given a YES-instance the algorithm returns YES. Suppose (G, (V_r, V_b), k, d) is a YES-instance of LABELED-MDC and let F be its solution. Note that this implies F is a solution to (G, k, d). If the algorithm returns YES because Reduction Rule 1 returns a YES-instance then the lemma is vacuously true. By Lemma 5, Reduction Rule 3 is not applicable on the input. Consider the instance obtained by the exhaustive application Reduction Rules 1 and 2 on the input instance. For notational convenience, we denote this reduced instance by (G, (V_r, V_b), k, d). As Reduction Rule 4 is not applicable, there is a vertex in G that has degree at least d + 1. Let v be the vertex of degree at least d + 1 found by the algorithm. By Observation 4, V(F) intersects with N[v].

Consider the case when v is in V_r and let R be the connected component of G[V_r] that contains v. Since V(F) \subseteq V_r, we have R \cap V(F) \ne \emptyset . As F is a solution to (G, (V_r, V_b), k, d), R \cap V(F) \ne \emptyset implies R \subseteq V(F). Instance (G, (V_r, V_b), k, d), subset R of V_r, and solution F satisfies the premise of Lemma 6. Hence, there is a valid coloring \phi :R \rightarrow [d + 1] of G[R] such that \texttt {CC}[(G, (V_r, V_b), k, d), R; \phi ] is a YES-instance. As R \ne \emptyset , Remark 1 implies that k' < k. By the induction hypothesis, the algorithm correctly returns YES when the input is (G', (V'_r, V'_b), k', d). As one of the recursive calls returns YES, the algorithm returns YES when the input is (G, (V_r, V_b), k, d) and v is in V_r.

Consider the case when v is in V_b. Let C_1, C_2, \dots , C_q be the connected components of G[V_r] such that N(v) \cap C_i \ne \emptyset for every i \in [q]. Recall that for a non-empty subset I \subseteq [q], R_I = \bigcup _{i \in I} C_i. As V(F) intersects N[v] and V(F) \subseteq V_r, there exists a non-empty subset I' \subseteq [q] such that for i \in [q], C_i \cap N(v) \ne \emptyset if and only if i \in I'. As F is a solution to (G, (V_r, V_b), k, d), C_i \cap V(F) \ne \emptyset implies C_i \subseteq V(F). Hence, R_{I'} \subseteq V(F). As |V(F)| \le 2k, we have |R_{I'}| \le 2k. For every non-empty subset I \subseteq [q] for which |R_I| \le 2k, the algorithm constructs all valid coloring \phi : R_I \rightarrow [d + 1] of G[R_I] and calls Colorwise-Contraction. Instance (G, (V_r, V_b), k, d), subset R_{I'} of V_r, and solution F satisfies the premise of Lemma 6. Hence, there is a valid coloring \phi :R_{I'} \rightarrow [d + 1] of G[R_{I'}] such that (G', (V'_r, V'_b), k', d) = \texttt {CC}[(G, (V_r, V_b), k, d), R_{I'}, \phi ] is a YES-instance. As R \ne \emptyset , Remark 1 implies that k' < k. By the induction hypothesis, the algorithm correctly returns YES when the input is (G', (V'_r, V'_b), k', d). As one of the recursive calls returns YES, the algorithm returns YES when the input is (G, (V_r, V_b), k, d) and v is in V_b. This implies that if (G, (V_r, V_b), k, d) is a YES-instance then the algorithm returns YES.

We now prove that if the algorithm returns YES on instance (G, (V_r, V_b), k, d) then it is a YES-instance of LABELED-MDC. If the algorithm returns YES because Reduction Rule 4 returns a YES-instance then the lemma is vacuously true. Otherwise, there is a newly created instance, say (G', (V'_r, V'_b), k', d), on which the recursive call of the algorithm returns YES. Let R be the subset of V_r and \phi be its valid coloring such that Colorwise-Contraction returns this instance when input is (G, (V_r, V_b), k, d), R, and \phi . Let F^{\circ } be the edges in G contracted by the subroutine to contract G'. In other words, F^{\circ } is a collection of spanning trees of connected monochromatic components of G[R]. Note that |F^{\circ }| = k - k'. The algorithm calls Colorwise-Contraction only on non-empty subsets R. Hence, by Remark 1, k' < k. By the induction hypothesis, (G', (V'_r, V'_b), k', d) is a YES-instance of LABELED-MDC. It is easy to see that if F' is a solution to (G', (V'_r, V'_b), k', d) then F' \cup F^{\circ } is a solution to (G, (V_r, V_b), k, d). This concludes the proof of the correctness of the algorithm.

We now bound the running time of the algorithm. The algorithm can apply all the reduction rules in polynomial time. It creates new instances only when none of the reduction rules are applicable. As Reduction Rules 4 is not applicable, any connected component of G[V_r] has at least two and at most 2k vertices. In Case(1), the algorithm creates at most (d + 1)^{|R|} many instances. By Remark 1 and the induction hypothesis, the time taken by the algorithm in this case is

\begin{aligned}&(d + 1)^{|R|} \cdot 2^{(d + 2)(k - |R|/2)} \cdot (d + 1)^{2(k - |R|/2)} \cdot n^{{\mathcal {O}}(1)} \le \\&\quad (d + 1)^{|R| + 2k - |R|} \cdot 2^{kd + 2k - d |R| - |R|} \cdot n^{{\mathcal {O}}(1)} \le 2^{(d + 2) k} \cdot (d + 1)^{2k} \cdot n^{{\mathcal {O}}(1)}. \end{aligned}
As Reduction Rule 4 is not applicable, for any vertex v in V_b, there are at most d connected components of G[V_r] that intersect N(v). In Case(2), the algorithm constructs all valid partitions of R_I only when |R_I| \le 2k. Hence, in this case, the algorithm creates 2^d \cdot (d + 1)^{|R|} many instances. By Remark 1 and the induction hypothesis, the time taken by the algorithm in this case is

\begin{aligned}&2^d \cdot (d + 1)^{|R|} \cdot 2^{(d + 2)(k - |R|/2)} \cdot (d + 1)^{2(k - |R|/2)} \cdot n^{{\mathcal {O}}(1)} \le \\&\quad 2^d \cdot 2^{(d + 2)(- |R|/2)} \cdot 2^{(d + 2)k} \cdot (d + 1)^{|R| + 2k - |R|} \cdot n^{{\mathcal {O}}(1)} \\&\quad \le 2^{(d + 2) k} \cdot (d + 1)^{2k} \cdot n^{{\mathcal {O}}(1)}. \end{aligned}
As |R| \ge 2, we have 2^d \cdot 2^{(d + 2)(-|R|/2)} \le 1. This completes the proof of the lemma. \square

The correctness of Theorem 2 follows from Lemmas 4 and 7.

In [8], the authors presented a reduction that takes as input an instance {\mathcal {H}} of HYPERGRAPH 2-COLORING, and constructs an instance (G, k, d) of MDC for any fixed d \ge 2. If hypergraph {\mathcal {H}} has N vertices and M hyper-edges, then the reduction constructs graph G with N + M vertices. In [39], the authors presented a simple reduction to prove that unless ETH fails, HYPERGRAPH 2-COLORING does not admit an algorithm running in time 2^{o(N + M)}. See Reduction (2) in the full version of the article [40]. These two results imply that MDC does not admit an algorithm running in time 2^{o(nd)}, and hence in time 2^{o(kd)}, unless ETH fails.

No Polynomial Kernel
In this section, we prove that MAXIMUM DEGREE CONTRACTION does not admit a polynomial kernel when parameterized by k + d. To show that, we present a reduction from RED BLUE DOMINATING SET (RBDS). In this problem, an input is comprised of a bipartite graph H with a bipartition (R, B) of V(H), and a positive integer l. The question is, does there exist a subset R' of R of size at most l such that N(R') = B? Without loss of generality, we can assume that l + 3 < |B| and no vertex in R is adjacent to all but one vertices in B. We know the following result about the compression of the problem. See, for example, Theorem 15.18 in [14].

Proposition 3
Unless \textsf {NP}\subseteq \textsf {coNP}/poly, RBDS, parameterized by |B|, does not admit a polynomial compression.

If |R| > 2^{|B|} then there are at least two different vertices, say r_1, r_2 such that N(r_1) = N(r_2). It is easy to see that it is safe to delete one of these two vertices. In this case, we can ensure, in polynomial time, that |R| \le 2^{|B|} by repeating the above process. This implies \log _2 |R| \le |B|. Hence, we get the following corollary of Proposition 3.

Corollary 1
Unless \textsf {NP}\subseteq \textsf {coNP}/poly, RBDS, parameterized by |B| + \log _2|R|, does not admit a polynomial compression.

For the sake of clarity, we use both |B| and \log _2|R| as parameters instead of replacing \log _2|R| by the larger parameter |B|. For notational convenience, we assume that \log _2|R| is an integer. If this is not the case, one can add some isolated vertices in R to ensure that \log _2|R| is an integer. This results in at most doubling of the number of vertices in it.

Fig. 2
figure 2
(Left) Overview of the reduction. The doted lines indicate that there is a complete bipartite graph across two sets. (Right) The operation of replacing edges incident to vertex in B by a tree rooted at that vertex

Full size image
We first present an overview of the reduction. Consider an instance (H, R, B, l) of RBDS. See Fig. 2 for an illustration. The reduction makes a copy of R and two copies of B, say B^1, B^2. For every vertex b in B, we denote its two copies in B^1, B^2 by b^1, b^2, respectively. For every edge (r, b), the reduction adds edges (r, b^1) and (r, b^2). It adds two independent sets U^1, U^2. For every vertex u \in U^1 \cup U^2, it adds some pendant vertices adjacent to it. The reduction adds all edges to make a complete bipartite graph with (B^1, U^1) as its bipartition. Similarly, it adds all edges to make a complete bipartite graph with (B^2, U^2) as its bipartition. For every vertex b in B, it adds a set of independent vertices X_b. For every x in X_b, it adds some pendant vertices adjacent to it and adds edges (b^1, x), (b^2, x). We briefly present an intuition behind the construction before presenting the last step. Let G be the graph constructed so far and k, d be two integers whose values depend only on |B|, \log _2|R|. Suppose the reduction returns (G, k, d) as an instance of MDC.

We set the value of d and the number of pendant vertices to ensure that only vertices in U^1 \cup U^2 \cup X_b have degrees more than d in G. We fix k and the sizes of sets U^1, U^2, X_b such that any solution for the reduced instance of MDC satisfies the following properties.

1.
It does not include an edge with one of its endpoints in B^1 \cup B^2 and another in U^1 \cup U^2.

2.
For any b in B, it does not include an edge with one of its endpoints in \{b^1, b^2\} and another in X_b.

3.
It spans all vertices in B^1 \cup B^2. In other words, B^1 \cup B^2 \subseteq V(F).

4.
There are at most l witness sets in the G/F-witness structure of G that contain vertices in B^1 (similarly in B^2).

5.
For every b in B, vertices b^1, b^2 in same witness set in G/F-witness structure of G.

Property (5) ensures that the degree constraints for the vertices in U^1 (similarly in U^2) are satisfied. Property (5) ensures that for every b in B, the degree constraint for the vertices in X_b are satisfied. Because of Property (5) and (5), only the vertices in R can make a big witness set connected. Hence, each witness set should contain at least one vertex from R. We set the budget k such that each witness set contains exactly one vertex from R. To prove connectivity to the witness set, this vertex needs to be adjacent to all vertices in that witness set. Hence, the set of endpoints of edges in a solution to (G, k, d) contains at most l vertices in R that dominate B. This naturally leads to a solution to (H, R, B, l).

We now present the last step in the construction. The degree of the vertices formed by contracting a witness set can be larger than d. To avoid this, we replace edges across R, B that are incident to vertex b in B by a binary tree rooted at that vertex. We ensure that for every edge incident b, there is a unique root-to-leaf path in the binary tree rooted at b and vice versa.

Reduction Given an instance (H, R, B, l) of RBDS as an input, the reduction outputs an instance (G, k, d) of MDC. The reduction creates an intermediate instance (H^{\star }, R^{\star }, B^{\star }, l) of RBDS. It takes a copy of R and two copies of B, namely B^1, B^2, to create vertex set of graph H^{\star }. Formally, R^{\star } = R and B^{\star } = B^1 \cup B^2. For every edge (r, b) in H such that r \in R and b \in B, it adds edges (r, b^1), (r, b^2) to H^{\star }. Here, vertices b^1, b^2 are copies of b in B^1, B^2, respectively. It is easy to see that (H, R, B, l) is a YES-instance of RBDS if and only if (H^{\star }, R, B^1 \cup B^2, l) is a YES-instance.

The reduction sets k = 2|B| \cdot \log _2|R| and d = 2|B| \cdot (\log _2|R| + k + 2), and constructs graph G by modifying a copy of graph H^{\star } in the following way. It repeats the first three steps for i = 1 and i = 2.

For every vertex b^i in B^i, it deletes all the edges incident to b^i and constructs a binary tree that satisfies the following conditions: (i) the tree is rooted at b^i, (ii) the height of the binary tree is \log _2|R|, and (ii) its leaves are the vertices in N_{H^{\star }}(b^i). Note that every edge incident to b^{i} in H^{\star } corresponds to an unique root-to-leaf path in this binary tree and vice versa. Let I^{i} be the collection of all the new vertices added in this step. It is the collection of vertices in binary trees that are not roots or leaves.

It adds set U^i of k + 1 new vertices to V(G). For every vertex b^i in B^i and every vertex u in U^i, it adds edge (b^i, u). It adds all edges to make G[B^i \cup U^i] a complete bipartite graph with B^i, U^i as its bipartition.

For every vertex u in U^i, it adds d - l pendant vertices adjacent to u.

For every vertex b in B, it adds a set X_b of k + 1 new vertices. For every vertex x in X_b, it adds edges (b^1, x) and (b^2, x). It also adds d - 2 pendant vertices adjacent to x. Let P_X^b be the set of pendant vertices adjacent to some vertex in X_b.

This completes the construction of (G, k, d).

The following lemma identifies the set of vertices in G that have degree more than d.

Lemma 8
Suppose the reduction returns (G, k, d) when the input is (H, R, B, l). Then, U \cup X is the collection of all vertices in G that have degree strictly greater than d. Here, U = U^1 \cup U^2 and X = \bigcup _{b \in B} X_b.

Proof
Define I := I^1 \cup I^2 and P := P^1 \cup P^2 \cup \left( \bigcup _{b \in B} P^b_X \right) . Note that sets R, I, B^1, B^2, U, X, P form a partition of V(G). Consider vertex r in R. This vertex is a leaf in the binary trees rooted at every vertex in N_{H^{\star }}(r). Hence, in graph G, any vertex in R is adjacent to at most 2|B| = |B^1 \cup B^2| many vertices in I. Every vertex in I is an internal vertex in a binary tree and hence adjacent to at most three vertices. Every vertex in B^1 is adjacent to at most two vertices from set I, all the vertices in set U^1 and all the vertices in X_b. Hence, vertex in B^1 is adjacent with 2 + |U^1| + |X_b| many vertices. As |U^1| = |X_b| = k + 1, every vertex in B^1 is adjacent to at most 2k + 4 \le d vertices. By similar arguments, every vertex in B^2 is adjacent to at most d vertices. As P is a collection of pendant vertices, every vertex in it is adjacent with exactly one vertex.

We have proved that every vertex in V(G) \setminus (U \cup X) has degree at most d. It remains to prove that every vertex in U \cup X has degree at least d. Every vertex in U^1 is adjacent with d - l pendant vertices and every vertex in B^1. As |B| > l, every vertex in U^1 has degree strictly greater than d. By similar arguments, every vertex in U^2 has degree strictly greater than d. For every b in B, every vertex in X_b is adjacent with d - 1 pendant vertices and two vertices in B^1 \cup B^2. Hence, every vertex in X is adjacent with at least d + 1 vertices. This concludes the proof of the lemma. \square

In the remaining section, we argue that the reduction is correct. In Lemmas 9 and 10 we prove the forward and the backward directions, respectively.

Lemma 9
Suppose the reduction returns (G, k, d) when the input is (H, R, B, l). If (H, R, B, l) is a YES-instance of RBDS then (G, k, d) is a YES-instance of MDC.

Proof
As mentioned before, (H, R, B, l) is a YES-instance of RBDS if and only if (H^{\star }, R, B^1 \cup B^2, l) is a YES-instance of RBDS. Let R' = \{r_1, r_2, \dots , r_{|R'|}\} be a subset of R of size at most l such that B^1 \cup B^2 = N_{H^{\star }}(R). Without loss of generality, we assume that R' is a minimal dominating set. Partition B^1 \cup B^2 into B_1, B_2, \dots , B_{|R'|} such that for every j \in [|R'|], r_j dominates vertices in B_j and for every b in B, vertices b^1, b^2 are in same part. Since R' is a minimal dominating set, B_j is a non-empty. For every j \in [|R'|], define F_j as follows: Initialize F_j to an empty set. For every b in B_j, the consider binary tree rooted at b^1 (similarly at b^2). Add the root-to-leaf paths in the trees that correspond to edges (r_j, b^1) and (r_j, b^2) to F_j. Let F be the union of all F_js. Formally, F = \bigcup _{j \in [|R'|]} F_j. Since every path is of length \log _2|R| and any two paths in F are edge disjoints, |F| = 2|B| \cdot \log _2|R|. Consider the graph G/F and let G is contracted to G/F via function \psi . Define B^{\circ } = \{b^{\circ }_1, b^{\circ }_2, \dots , b^{\circ }_{|R'|}\}, where b^{\circ }_j is the vertex in G/F that is obtained by contracting all edges in F_j. We argue that the maximum degree of vertices in G/F is at most d.

Vertices in V(G/F) can be partitioned into R \setminus R' = R \setminus V(F), I \setminus V(F), B^{\circ }, U, X, and P. Here, I, U, X, P are the sets defined in Lemma 8. For every vertex in (R \cup I \cup P) \setminus V(F), we have |W(\psi (v))| = 1. By Observation 1 (1 ), \deg _{G/F}(\psi (v)) \le \deg _G(v). By Lemma 8, every vertex in R \cup I \cup P has degree at most d. Hence, we can conclude that \deg _{G/F}(\psi (v)) \le d. In graph G/F, every vertex v in U is adjacent to every vertex in B^{\circ } and d - l pendant vertices. As |B^{\circ }| = |R'| \le l, every vertex in U is adjacent to at most d vertices. As b^1,b^2 are in same witness set for every b in B, every vertex in X is adjacent to one vertex in B^{\circ } and d - 1 pendant vertices. Hence, every vertex in X has degree at most d in G/F.

It remains to argue that the degree of b^{\circ }_j is at most d in G/F. For every j in [|R'|], set V(F_j) can be partitioned into the following three parts: (i) V(F_j) \cap R, (ii) V(F_j) \cap I, and (iii) B_j = V(F_j) \cap (B^1 \cup B^2). Consider the first part. By the construction, V(F_j) \cap R = \{r_j\}. As mentioned in the proof of Lemma 8, in graph G, any vertex in R is adjacent to at most |B^1 \cup B^2| vertices in I. Hence, the vertex in V(F_j) \cap R is adjacent to at most |B^1 \cup B^2| - |B_j| vertices outside V(F_j). Now consider the second part. Every vertex in V(F_j) \cap I is adjacent to at most one vertex outside V(F_j). As every r_j to b^1 (similarly r_j to b^2) path is of length \log _2|R|, and any two paths in F_j are edge disjoint, |V(F_j) \cap I| = |B_j| \cdot \log _2|R|. Hence, vertices in V(F_j) \cap I are adjacent to at most |B_j| \cdot \log _2|R| vertices outside V(F_j). Now consider the third part. Every vertex in V(F_j) \cap (B^1 \cup B^2) is adjacent to at most one vertex in I \setminus V(F_j), every vertex in U and every vertex in X_{j}. Here, X_{j} = \bigcup _{b \in B_j} X_b. Hence, vertices in V(F_j) \cap (B^1 \cup B^2) are adjacent to at most |B_j| + (k + 1) + |B_j|(k + 1) vertices. This implies that the number of vertices adjacent to V(F_j) is at most |B^1 \cup B^2| - |B_j| + |B_j| \cdot \log _2|R| + |B_j| + (k + 1) + |B_j| \cdot (k + 1) \le 2 |B^1 \cup B^2| \cdot (\log _2|R| + k + 2) = d. Here, we use the fact that 1 + |B_j| \le |B^1 \cup B^2|. This follows from our assumption that in graph H, no vertex in R is adjacent to all but one vertex in B. Hence, the degree of any vertex in B^{\circ } is at most d in G/F.

This proves that the maximum degree of any vertex in G/F is at most d. Hence, if (H, R, B, l) is a YES-instance, then so is (G, k, d). \square

We now prove the backward direction. As in Section 3, we prove a series of claims about a solution to reduced instance. We prove the five properties mentioned at the start of this section to prove the following lemma.

Lemma 10
Suppose the reduction returns (G, k, d) when the input is (H, R, B, l). If (G, k, d) is a YES-instance of MDC then (H, R, B, l) is a YES-instance of RBDS.

We prove that if (G, k, d) is a YES-instance of MDC then (H^{\star }, R, B^1 \cup B^2, l) is a YES-instance of RBDS. Recall that for vertex subset X, Y, we denote the set of all edges with one endpoint in X and another endpoint in Y by E(X, Y). Let P^1_U, P^2_U and P_X be the collection of pendant vertices adjacent to vertices in U^1, U^2, and X, respectively. By the construction, we can partition edges of G into the following four sets: E(B^1 \cup B^2, U^1 \cup U^2), E(B^1 \cup B^2, X), E(U \cup X, P^1_U \cup P^2_U \cup P_X), and E'. Here, E' is the collection of edges that are not covered by the first three sets.

Suppose (G, k, d) is a YES-instance and F is a solution to (G, k, d).

Claim 6
F \cap E(B^1 \cup B^2, U^1 \cup U^2) = \emptyset .

Proof
Assume that there is an edge, say (b^1, u), in F \cap E(B^1, U^1) where vertices b^1, u are in B^1 and U^1, respectively. Let w be the new vertex introduced while contracting edge (b^1, u). In graph G/\{(b^1, u)\}, vertex w is adjacent to every vertex in (B^1 \setminus \{b^1\} )\cup X_b \cup (U^1 \setminus \{u\}) and with all pendant vertices that were adjacent with u in G. Hence, the degree of w in (G/\{(b^1, u)\}) is at least |B| - 1 + |X_b| + |U^1| + d - l > d + (k - 1) + 1. By Observation 4, (G/\{(b^1, u)\}, k - 1, d) is a NO-instance. This contradicts Observation 2. Hence our assumption is wrong and F \cap E(B^1, U^1) is an empty set. By similar arguments, F \cap E(B^2, U^2) is an empty set. By the construction, sets E(B^1, U^2) and E(B^2, U^1) are empty. This concludes the proof of the claim. \square

Claim 7
F \cap E(B^1 \cup B^2, X) = \emptyset .

Proof
To prove the claim, it suffices to prove that for any vertex b in B, F does not include edge (b^1, x) where b^1 is in B^1 and x is in X_b. For the sake of contradiction, assume such an edge exists. Let w be the new vertex introduced while contracting edge (b^1, x). In graph (G/\{(b^1, x)\}, vertex w is adjacent to every vertex in \{b^2\} \cup (X_b \setminus \{x\}) \cup U^1 and with all pendant vertices that were adjacent with x in G. Hence, the degree of w in (G/\{(b^1, u)\}) is at least 1 + |X_b| + |U^1| + d - 1 > d + (k - 1) + 1. By Observation 4, (G/\{(b^1, x)\}, k - 1, d) is a NO-instance. This contradicts Observation 2. Hence our assumption is wrong and there is no edge of the form (b^1, x). As every edge in E(B^1, X) is of the form (b^1, x) for some b^1 in B^1 and x in X_b, we can conclude that E(B^1, X) is an empty set. By similar arguments, E(B^2, X) is an empty set. This concludes the proof of the claim. \square

Claim 8
(B^1 \cup B^2) \subseteq V(F).

Proof
Assume, for the sake of contradiction, that there is b^1 in (B^1 \cup B^2) \setminus V(F). Recall that every vertex x in X_b, the degree of x is d + 1. By Observation 4, there are at least two vertex in N[x] which are in V(F). As b^1 is not incident to any solution edge, b^1 is not in N[x] \cap V(F). Vertex b^2 can be one of the vertices in N[x] \cap V(F). By Claim 7, edge (b^2, x) is not in any solution. Hence, there is at least one vertex N[x] \cap V(F) which is a pendant vertex adjacent to x or the vertex x itself. This implies for every x in X_b, there is a solution edge incident to pendant vertex adjacent to x. Hence, there are at least |X_b| = k + 1 edges in F. This contradicts the fact that |F| is at most k. Hence our assumption is wrong and B^1 \cup B^2 \subseteq V(F). \square

Claim 9
There are at most l witness sets in the G/F-witness structure of G that contain vertices in B^1 (similarly in B^2).

Proof
Recall that for a subset Z \subseteq V(G), we define \psi (Z) := \{\psi (z)\ |\ z \in X \}. To prove the claim, it suffices to prove that the size of \psi (B^1) is at most l. Assume that there is a positive integer l' such that |\psi (B^1)| = l + l'. For every vertex u \in U in graph G, vertex \psi (u) is adjacent to every vertex in \psi (B^1) in graph G'. The degree of \psi (u) in G/F is at most d. By Claim 6, F does not contain an edge in E(B^1, U^1). Hence, F must contain at least l' many edges incident to u and pendant vertices adjacent to it. As this is true for every vertex in U^1, there are |U^1| \cdot l' many edges in F that are incident to pendant vertices. As |U^1| = k + 1 and l' \ge 1, this contradicts the fact that |F| \le k. Hence, our assumption is wrong and |\psi (B^1)| \le l. This implies the G/F-witness structure of G partitions all vertices in B^1 into at most l witness sets. By similar arguments, we can prove that the G/F-witness structure of G partitions all vertices in B^2 into at most l witness sets. \square

Claim 10
For every b in B, \psi (b^1) = \psi (b^2).

Proof
Assume, for the sake of contradiction, that there is b in B, such that \psi (b^1) \ne \psi (b^2). In other words, b^1, b^2 are in two different witness sets in G/F-witness structure of G. Recall that every vertex x in X_b, the degree of x is d + 1. By Observation 4, there are at least two vertices in N[x] that are in a witness set. By Claim 7, no edge in E(B^1 \cup B^2, X) is a part of any solution. Hence, for every x in X_b, there is a solution edge incident to pendant vertex adjacent to x. As |X_b| = k + 1, this contradicts the fact that |F| is at most k. Hence our assumption is wrong and for every b in B, \psi (b^1) = \psi (b^2). \square

We now present a proof of Lemma 10. In the proof, we crucially use the fact that G[R \cup I \cup B^1 \cup B^2] is union of binary trees rooted at vertices in B^1 \cup B^2. Moreover, any two of these binary trees are edge disjoint.

Proof of Lemma 10
We prove that (H^{\star }, R, B^1 \cup B^2, l) is a YES-instance of RBDS. By Claims 8 and 9, there is l' (\le l) witness sets, say W_1, W_2, \dots , W_{l'}, in the G/F-witness structure of G such that their union contains B^1 \cup B^2. For j \in [l'], define B^{\circ }_j = (B^1 \cup B^2) \cap W_{j}. We divide this proof of the lemma in two parts. In the first part, we prove that for every b_{\alpha } in B^{\circ }_j, there is vertex r in W_j such that r is adjacent with b_{\alpha } in H^{\star }. This implies that in graph H^{\star }, set \bigcup _{j \in [l']}(R \cap W_j) dominates B^1 \cup B^2. In the second part, we prove that there is at most one vertex in R \cap W_j. This proves that the dominating set is of size l' \le l.

Define {\widetilde{E}} := E(B^1 \cup B^2, U^1 \cup U^2) \cup E(B^1 \cup B^2, X). By Claims 6 and 7, solution F does not contain any edge in {\widetilde{E}}. For any two vertices b_{\alpha }, b_{\beta } \in B^1 \cup B^2, any b_{\alpha } to b_{\beta } path in G - {\widetilde{E}} contains a vertex in N_{H^{\star }}(b_{\alpha }) and a vertex in N_{H^{\star }}(b_{\alpha }). Fix an arbitrary vertex b^1 in B^1. By Claim 10, if b^{1} is in W_j then b^{2} is also in W_j. Hence, there are at least two vertices in B^{\circ }_j which forms a subset of W_j. As W_j is connected set in G - {\widetilde{E}}, it contains at least one vertex each from N_{H^{\star }}(b_{\alpha }) and N_{H^{\star }}(b_{\beta }). Hence, for any b_{\alpha } in B^1 \cup B^2, if b_{\alpha } is in W_j then there exists at least one vertex in W_j which is adjacent to b_{\alpha } in H^{\star }. This implies that in graph H^{\star }, set \bigcup _{j \in [l']}(R \cap W_j) dominates B^1 \cup B^2.

To prove the second part, we need to argue that we can partition F into |B^1 \cup B^2| parts, each corresponding to a vertex in B^1 \cup B^2. For every vertex b_{\alpha } in B^1 \cup B^2, let \rho (b_{\alpha }) be the vertex in R such that (i) b_{\alpha } and \rho (b_{\alpha }) are in same witness set, and (ii) \rho (b_{\alpha }) is the nearest vertex in the witness set that satisfy the first property. The arguments in previous the paragraph ensure that such a vertex exits. Let P_{\alpha } be a path from b_{\alpha } to \rho (b_{\alpha }) such that edges in P_{\alpha } are in F. As b_{\alpha }, \rho (b_{\alpha }) are in W_j, which is a witness set, such a path exists. Because of the second property, P_{\alpha } is a root-to-leaf path in the binary tree rooted at b_{\alpha }. This implies that the length of P_{\alpha } is \log _2|R| and for two different vertices b_{\alpha }, b_{\beta } in B^1 \cup B^2, paths P_{\alpha } and P_{\beta } are edge disjoint. As |F| = |B^1 \cup B^2| \cdot \log _2|R|, we can conclude that \{E(P_{\alpha })\ |\ b_{\alpha } \in B_1 \cup B_2\} is a partition of F.

We now prove the second part. Assume that there is some j such that the set R \cap W_j contains two vertices, say r_1, r_2. As r_1, r_2 are in same witness sets, there is a r_1 to r_2 path whose edges are contained in F. By the construction of H^{\star } and the fact that F \cap {\widetilde{E}} = \emptyset , there is vertex b_{\alpha } in W_j such that r_1, r_2 are leaves in the binary tree rooted at b_{\alpha }. Without loss of generality, let r_1 = \rho (b_{\alpha }). As r_2 is a leaf, there is at least one edge in r_1 to r_2 path which is not contained in path P_{\alpha }. This edge is not a part of P_{\beta } for any b_{\beta } \ne b_{\alpha } \in B^{1} \cup B^2 as binary trees rooted at vertices in B^1 \cup B^2 are edge disjoints. This implies there is an edge in F which is not in path P_{\alpha } for any b_{\alpha } in B^1 \cup B^2. This contradictions the fact that \{E(P_{\alpha })\ |\ b_{\alpha } \in B_1 \cup B_2\} is a partition of F. Hence our assumption is wrong and for j \in [l'], set R \cap W_j contains at most one vertex.

This implies that in graph H^{\star }, set \bigcup _{j \in [l']}(R \cap W_j) is of size at most l and dominates B^1 \cup B^2. Hence (H^{\star }, R, B^1 \cup B^2, l) is a YES-instance. As mentioned before, it is easy to see that (H, R, B, l) is a YES-instance if and only if (H^{\star }, R, B^1 \cup B^2, l) is a YES-instance. This concludes the proof of the lemma. \square

We now present a proof of Theorem 3 using Corollary 1, Lemmas 9, and 10.

Proof of Theorem 3
Assume, for the sake of contradiction, MDC, parameterized by k + d admits a polynomial-sized compression. This implies there is an algorithm, say {\mathcal {A}}, that given any instance (G, k, d) of MDC runs in polynomial time and produces equivalent instance (I', k') of parameterized problem \Pi such that (i) (G, k, d) is a YES-instance of MDC if and only if (I', k') is a YES-instance of \Pi , and (ii) |I'| + k' \le (k + d)^c, where c is a fixed constant. We construct a compression algorithm for RBDS using Algorithm {\mathcal {A}} as a subroutine.

Consider algorithm {\mathcal {B}} that given an instance (H, R, B, l) of RBDS constructs an instance (G, k, d) of MDC as described in the reduction. Then, it calls Algorithm {\mathcal {A}}, as subroutine, on instance (G, k, d). Let (I', k') be the instance of \Pi returned by Algorithm {\mathcal {A}}. The algorithm returns (I', k') as a compressed instance.

For the correctness of the algorithm {\mathcal {A}}, Lemmas 9, and 10 implies that (H, R, B, l) is a YES-instance of RBDS if and only if (I', k') is a YES-instance of \Pi . Since (G, k, d) is the instance of MDC constructed by the reduction when input is (H, R, B, l), we have k = 2|B| \cdot \log _2|R| and d = 2 |B| \cdot (\log _2|R| + k + 2). As, |I'| + k' \le (k + d)^c, we have |I'| + k' \le (|B| + \log _2|R|)^{c_0}, where c_0 is a fixed constant. By the description of the reduction, given instance (H, R, B, l), Algorithm {\mathcal {B}} computes instance (G, k, d) in time polynomial in |V(H)|. Hence, the total running time of the algorithm is polynomial in the size of the input.

This implies RBDS, when parameterized by |B| + \log _2|R|, admits a polynomial compression. But this contradicts Corollary 1. Hence, our assumption is wrong which concludes the proof. \square

Conclusion
In this article, we studied the MAXIMUM DEGREE CONTRACTION problem. We proved that a simple brute force algorithm for this problem is optimal under ETH. This lower bound also implies that the known FPT algorithm with running time (d + k)^{k} \cdot n^{{\mathcal {O}}(1)} is also optimal under the same hypothesis. We compliment this result by presenting another FPT algorithm with running time 2^{{\mathcal {O}}(dk)} \cdot n^{{\mathcal {O}}(1)}. While these two FPT algorithms are incomparable, our algorithm runs faster for smaller values of d, for which the problem remains NP-hard. We also prove that unless \textsf {NP}\subseteq \textsf {coNP}/poly, the problem does not admit a polynomial compression when parameterized by k + d.

It will be interesting to investigate whether the techniques used in this article can be applied to MINIMUM DEGREE CONTRACTION [23] and REGULAR DEGREE CONTRACTION [8]. These problems are known to be FPT when parameterized by k + d.

Most of the {\mathcal {H}}-CONTRACTION problems do not admit a polynomial kernel under the same complexity conjecture. For some graph classes like trees [31], cactus graphs [31], cliques [26], and splits graphs [26] such negative results have been complimented by establishing a lossy kernel, which was introduced in [35], of polynomial size. There are also examples like CHORDAL CONTRACTION [26] and S-CLUB CONTRACTION (for s \ge 2) for which we know that lossy kernel of polynomial size do not exist. We conclude this article with following open question: Does MAXIMUM DEGREE CONTRACTION admit a lossy kernel of polynomial size?