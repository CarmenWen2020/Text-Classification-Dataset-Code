Online routing in a planar embedded graph is central to a number of fields and has been studied extensively in the literature. For most planar graphs no O(1)-competitive online routing algorithm exists. A notable exception is the Delaunay triangulation for which Bose and Morin (SIAM J Comput 33(4):937–951, 2004) showed that there exists an online routing algorithm that is O(1)-competitive. However, a Delaunay triangulation can have  vertex degree and a total weight that is a linear factor greater than the weight of a minimum spanning tree. We show a simple construction, given a set V of n points in the Euclidean plane, of a planar geometric graph on V that has small weight (within a constant factor of the weight of a minimum spanning tree on V), constant degree, and that admits a local routing strategy that is O(1)-competitive. Moreover, the technique used to bound the weight works generally for any planar geometric graph whilst preserving the admission of an O(1)-competitive routing strategy.

Introduction
The aim of this paper is to design a graph on V (a finite set of points in the Euclidean plane) that is cheap to build and easy to route on. Consider the problem of finding a route in a geometric graph from a given source vertex s to a given target vertex t. Routing in a geometric graph is a fundamental problem that has received considerable attention in the literature. In the offline setting, when we have full knowledge of the graph, the problem is well-studied and numerous algorithms exist for finding shortest paths (for example, the classic Dijkstra’s Algorithm [17]). In an online setting the problem becomes much more complex. The route is constructed incrementally and at each vertex a local decision has to be taken to decide which vertex to forward the message to. Without knowledge of the full graph, an online routing algorithm cannot identify a shortest path in general; the goal is to follow a path whose length approximates that of the shortest path.

Given a source vertex s, a target vertex t, and a message m, the aim is for an online routing algorithm to send m together with a header h from s to t in a graph G. Initially the algorithm only has knowledge of s, t and the neighbors of s, denoted . Note that it is commonly assumed that for a vertex v, the set  also includes information about the coordinates of the vertices in . Upon receiving a message m and its header h, a vertex v must select one of its neighbours to forward the message to as a function of h, , s, and t. This procedure is repeated until the message reaches the target vertex t. Different routing algorithms are possible depending on the size of h and the part of G that is known to each vertex. Usually, there is a trade-off between the amount of information that is stored in the header and the amount of information that is stored in the vertices.

Bose and Morin [12] showed that greedy routing always reaches the intended destination on Delaunay triangulations. Dhandapani [16] proved that every triangulation can be embedded in such a way that it allows greedy routing and Angelini et al. [2] provided a constructive proof.

However, the above papers only prove that a greedy routing algorithm will succeed on the specific graphs therein. No attention is paid to the quality or competitiveness of the resulting path relative to the shortest path. Bose and Morin [12] showed that many local routing strategies are not competitive but also show how to route competitively in a Delaunay triangulation. Bonichon et al. [7, 8] provided different local routing algorithms for the Delaunay triangulation, decreasing the competitive ratio, and Bonichon et al. [6] designed a competitive routing algorithm for Gabriel triangulations.

To the best of our knowledge most of the existing routing algorithms consider well-known graph classes such as triangulations and -graphs. However, these graphs are generally very expensive to build. Typically, they have high degree  and the total length of their edges can be as bad as  times that of the minimum spanning tree of V.

On the other hand, there is a large amount of research on constructing geometric planar graphs with ‘good’ properties. However, none of these have been shown to have all of bounded degree, weight, planarity, and the admission of competitive local routing. Bose et al. [11] come tantalisingly close by providing a local routing algorithm for a plane bounded-degree spanner.

In terms of bounded degree, the best bound for plane spanners is 4 by Bonichon et al. [9]. This spanner has a spanning ratio of 156.82. Another construction that also achieves a maximum degree of 4 was given by Kanj et al. [22], who reduced the spanning ratio to 20. In two special cases, Bose et al. [5] showed that reducing the degree to 3 is possible. In terms of lower bounds, Dumitrescu and Ghosh [19] showed that there exist point sets that require a spanning ratio of at least 1.4308. They also strengthened this bound to 2.1755 for spanners of degree 4 and 2.7321 for spanners of degree 3.

The search for low weight spanners started in 1993 when Althöfer et al. [1] presented the greedy spanner. Das et al. [14, 15] showed that the weight of a greedy spanner for a set V of points in 
 is within a constant factor times the weight of a minimum spanning tree, for any constant d. For a complete proof see the book by Narasimhan and Smid [25]. In more recent work these results have been generalised to a wider family of doubling metrics [10, 20, 21].

In this paper we consider the problem of constructing a geometric graph of small weight and small degree that guarantees a local routing strategy that is O(1)-competitive. More specifically we show:

Given a set V of n points in the plane, together with two parameters  and , we show how to construct in  time a planar -spanner with degree at most , and weight at most  times the weight of a minimum spanning tree of V, where . This construction admits an O(1)-memory deterministic 1-local routing algorithm with a routing ratio of no more than .

While we focus on our construction, we note that the techniques used to bound the weight of the graph apply generally to any planar geometric graph. In particular, using techniques similar to the ones we use, it may be possible to extend the results by Bose et al. [11] to obtain other routing algorithms for bounded-degree light spanners.

Building the Network
Given a Delaunay triangulation  of a point set V we will show that one can remove edges from  such that the resulting graph  has constant degree and constant stretch-factor. We will also show that the resulting graph has the useful property that for every Delaunay edge (u, v) in  there exists a spanning path along the boundary of the face in  containing u and v. This property will be critical to develop the routing algorithm in Sect. 3. In Sect. 4 we will show how to prune  further to guarantee the lightness property while still being able to route in it.

Building a Bounded Degree Spanner
The idea behind the construction is slightly reminiscent to that of the -graph: For a given parameter , let  and let 
 be a set of  disjoint cones partitioning the plane, with each cone having angle measure at most  at apex u. Let 
 be the clockwise-ordered Delaunay neighbours of u within some cone 
 (see Fig. 1a).

Fig. 1
figure 1
a An example of the vertices in some cone C with apex u. b Extreme, penultimate, and middle are mutually exclusive properties taking precedence in that order

Full size image

If there is at least one edge at u induced by C, call edges 
 and 
 extreme at u. Call edges 
 and 
 penultimate at u if there are two distinct extreme edges at u induced by C and at least one other edge at u induced by C. If there are two distinct edges that are extreme at u induced by C, and two distinct edges that are penultimate at u induced by C, and at least one other edge at u induced by C, then, of the remaining edges incident to u and contained in C, the shortest one is called a middle edge at u (see Fig. 1b).

The construction removes every edge except the extreme, penultimate, and middle ones in every 
, for every point u, in any order. The edges present in the final construction are thus the ones which are either extreme, penultimate, or middle at both of their endpoints (not necessarily the same at each endpoint).

The resulting graph is denoted by . The construction time of this graph is dominated by constructing the Delaunay triangulation, which requires  time. Given the Delaunay triangulation, determining which edges to remove takes linear time (see Sect. 2.3). The degree of  is bounded by , since each of the  cones 
 can induce at most five edges. It remains to bound the spanning ratio.

Spanning Ratio
Before proving that the network is a spanner (Corollary 1) we will need to prove some basic properties regarding the edges in . We start with a simple but crucial observation about consecutive Delaunay neighbours of a vertex u.

Lemma 1
Let C be a cone with apex u and angle measure . Let 
 be consecutive clockwise-ordered Delaunay neighbours of u contained in C. The interior angle 
 must be at least .

Proof
In the case when 
 is reflex in the quadrilateral 
 the lemma trivially holds. Let us thus examine the case when 
 is not, in which case the quadrilateral 
 is convex and, as 
 and 
 are Delaunay triangles, 
 must be at least  (see Fig. 2a). Since 
 and 
 lie in a cone with apex u of angle measure , 
 is at most . Hence, 
 is at least . 

Fig. 2
figure 2
a Example placement of 
 and v in the circle 
 b The path from 
 to 
 along the Delaunay neighbours of u must be in . Furthermore, 
 and 
 are extreme, 
 and 
 are penultimate, and 
 is a middle edge

Full size image

This essentially means that 
 is wide, and will help us to argue when 
 and 
 must be in  (Lemma 3). Next, we define protected, fully protected, and semi-protected edges.

Definition 1
An edge uv is protected at u (with respect to some fixed 
) if it is extreme, penultimate, or middle at u. An edge uv is fully protected if it is protected at both u and v. An edge uv is semi-protected at u if it is protected at u but not protected at v.

Hence, an edge is contained in  if and only if it is fully protected. We continue with an observation that allows us to argue which edges are fully protected.

Observation 1
If an edge 
 is not extreme at u, then u must have consecutive clockwise-ordered Delaunay neighbours 
, all in the same cone 
. Similarly, if 
 is neither extreme nor penultimate at u, then u must have consecutive clockwise-ordered Delaunay neighbours 
, all in the same cone 
.

Lemma 2
Every edge that is penultimate or middle at one of its endpoints is fully protected.

Proof
Consider an edge uv that is penultimate or middle at u. Since it is protected at u, we need to show that it is protected at v. Since uv is not extreme at u, u must have consecutive clockwise-ordered Delaunay neighbours 
 in the same cone by Observation 1.

We show that uv must be extreme at v. Suppose for a contradiction that uv is not extreme at v. Then, by Observation 1, 
 and 
 are contained in the same cone with apex v and angle at most . However, by Lemma 1, 
, which is impossible. Thus, uv is extreme at v and protected at v. Hence, the edge is fully protected. 

Now we can argue about the Delaunay neighbours of a vertex (see Fig. 2b for an illustration of the lemma).

Lemma 3
Let 
 be the clockwise-ordered Delaunay neighbours of u contained in some cone 
. The edges in the path 
 are all fully protected.

Proof
Let 
 be an edge along this path for some . Suppose for a contradiction that 
 is not protected at 
. It is thus, in particular, neither extreme nor penultimate at 
. Then, by Observation 1, 
 and 
 must be contained in the same cone with apex 
 as 
. By Lemma 1, 
, contradicting that 
 and 
 lie in the same cone with apex 
. The edge 
 must therefore be either extreme or penultimate, and thus protected, at 
 for . An analogous argument shows that 
 is either extreme or penultimate at 
 for . It is thus fully protected. 

Since these paths 
 are included in , we can modify the proof of Theorem 3 by Li and Wang [24] to suit our construction to prove that  is a spanner.

Theorem 2
 is a -spanner of the Delaunay triangulation  for an adjustable parameter .

Proof
The proof of this theorem is illustrated in Fig. 3. We show that for any edge uv in  that is not present in , there is a spanning path in  from u to v.

The edges in  are exactly the edges in  that are fully protected. Without loss of generality, let uv be an edge in  that is not protected at u. Then, uv is not extreme and must be a chord of the face 
 where 
 is a middle edge and 
 is a penultimate edge. According to Lemma 2
 and 
 are edges in , and according to Lemma 3 all the edges in the path 
 are included in . Moreover, 
. Consider 
, the shortest curve with endpoints 
 and 
 contained in the polygon 
. Label 
 with x, 
 with y, and let w be the point on the segment 
 with length x so that 
.

We will show that 
 is contained in the triangle 
. If none of 
 are contained in the triangle 
, the claim must hold since all such vertices must be additionally outside the circle with centre u and radius x (
 is the middle edge) and thus the line segment joining 
 and 
 is unobstructed. If any of 
 are in the triangle 
, then 
 must connect directly to one of them along 
, say p, and 
 must connect directly to one of them, say q possibly the same as p. Since 
 can be seen as the lower convex hull of 
, and since p and q are in the triangle 
, the subpath of 
 with endpoints p and q must be in the triangle 
 too.

Since 
 is convex with base 
 and contained in the triangle 
; it must thus have a length not more than 
 where  is the angle 
. Now consider an edge of 
, say 
. The edge 
 shortcuts the subpath 
 of 
 in .

Dobkin et al. [18] (see also Lemma 3.3 in [12]) showed that the length 
 is at most 
, provided that

1.
the straight-line segment between 
 and 
 lies outside the Voronoi region induced by u, and

2.
the path 
 lies on one side of the line through 
 and 
.

The first property follows from the fact that  and the second property follows from the construction. Since both conditions hold, 
. Putting everything together, we have that the path 
 has length at most


 

Since , the last inequality immediately follows.

The right-hand-most side of the inequality shows that for any edge uv in , there is a -spanning path in  between u and v.  is thus a -spanner of the Delaunay triangulation  for an adjustable parameter . 

Fig. 3
figure 3
Illustrating Theorem 2. The spanning path from u to v is 
. Note that the path 
 is indeed contained in triangle 

Full size image

Note that from the proof of Theorem 2 it follows that for every Delaunay edge uv that is not in , there is a path from u to v along the face of  containing uv realising a path of length at most . This is a key observation that will be used in Sect. 3.

Algorithmic Construction of 
For completeness we state the algorithm in Sect. 2 as pseudocode and analyse its time complexity.

figure a
Theorem 3
 takes  time to construct.  takes O(n) time to construct if the input is a Delaunay triangulation  on V.

Proof
The construction of the Delaunay triangulation  at line 2 takes  time.

The loops at lines 3,5,8,20 are independent of each other. The one starting at line 3 takes O(n) time and the one on line 5 takes O(n) time since there are a linear number of edges in , which we look at twice (once for each endpoint), and the bucketing of each edge takes  time at most. The loop starting at line 8 takes O(n) time since there are a linear number of edges in , which we look at six times at most (thrice for each endpoint). Finally, the loop at line 20 takes O(n) time since there are a linear number of edges in .

The result follows that  takes  time to construct and  takes O(n) time to construct if the input is a Delaunay triangulation  on V.


Putting the results from this section together, using that the Delaunay triangulation is a 1.998-spanner [26], and observing that  is trivially planar since it is a subgraph of the Delaunay triangulation, we obtain:

Corollary 1
Given a set V of n points in the plane and a parameter , one can in  time compute a graph  that is a planar -spanner having degree at most , where .

Routing
In order to route efficiently on , we modify Bonichon et al.’s routing algorithm [8] on the Delaunay Triangulation. Given a source s and a destination t on the Delaunay triangulation , we assume without loss of generality that the line segment [st] is horizontal with s to the left of t. Bonichon et al.’s routing algorithm [8] then works as follows: When we are at a vertex 
 (
), set 
 to t and terminate if 
 is an edge in . Otherwise, consider the rightmost Delaunay triangle 
 at 
 that has a non-empty intersection with [st]. Denote the circumcircle 
 with 
, denote the leftmost point of 
 with 
, and the rightmost intersection of 
 and [st] with 
.

If 
 is encountered in the clockwise walk along 
 from 
 to 
, set 
 to p, the first vertex among  encountered on this walk starting from 
 (see Fig. 4a).

Otherwise, set 
 to q, the first vertex among  to be encountered in the counterclockwise walk along 
 starting from 
 (see Fig. 4b).

Fig. 4
figure 4
The routing choice: a At 
 we follow the edge to p. b At 
 we follow the edge to q

Full size image

We relax Bonichon et al.’s routing algorithm [8] in such a way that it no longer necessarily uses the rightmost intersected triangle: At 
, we set 
; at 
 for , we will find a Delaunay triangle 
 based on the Delaunay triangle 
 used in the routing decision at 
, where one of x or y is 
.

Let 
 be any Delaunay triangle with a non-empty intersection with [st] to the right of the intersection of 
 with [st] and which, moreover, satisfies the condition that if 
 is above [st], then, when making a counterclockwise sweep centred at 
 starting from 
, we encounter 
 before 
, with 
 intersecting [st] and 
 not intersecting [st]. Figure 5 illustrates two concrete examples of 
 given 
. An analogous statement for choosing 
 holds when 
 lies below [st], sweeping in clockwise direction.

Fig. 5
figure 5
Candidate triangles 
 given 
: a when [st] is not crossed when moving from 
 to 
, b when [st] is crossed when moving from 
 to 

Full size image

We note that these triangles 
 always exist, since the rightmost Delaunay triangle intersecting [st] is a candidate. Furthermore, the triangles occur in order along [st] by definition. This implies that the relaxation of Bonichon et al.’s routing algorithm [8] terminates.

Theorem 4
The relaxation of Bonichon et al.’s routing algorithm [8] on the Delaunay triangulation is 1-local and has a routing ratio of at most .

Proof
The 1-locality follows by construction. The proof for the routing ratio of Bonichon et al.’s routing algorithm [8] holds for its relaxed version, since the only parts of their proof using the property that 
 is rightmost are:

1.
The termination of the algorithm (which we argued above).

2.
The categorisation of the Worst Case Circles of Delaunay triangles 
 into three mutually exclusive cases (which we discuss next).

Thus, the relaxation of Bonichon et al.’s routing algorithm [8] on the Delaunay triangulation has a routing ratio of at most . 

Worst Case Circles
In the analysis of the routing ratio of Bonichon et al.’s routing algorithm [8], the notion of Worst Case Circles is introduced whereby the length of the path yielded by the algorithm is bounded above by some path consisting of arcs along these Worst Case Circles; this arc-path is then shown to have a routing ratio of 5.90.

Suppose we have a candidate path, and are given a Delaunay triangle 
 intersecting [st]; we denote its circumcircle by 
 with centre 
. The Worst Case Circle 
 is a circle that goes through 
 and 
, whose centre 
 is obtained by starting at 
 and moving it along the perpendicular bisector of 
 until either st is tangent to 
 or 
 is the leftmost point of 
, whichever occurs first. The direction 
 is moved towards depends on the routing decision at 
: if 
 is encountered on the clockwise walk from 
 to 
, then 
 is moved towards this arc, and otherwise, 
 is moved towards the opposite direction. Letting 
 be the leftmost point of 
, we can categorise the Worst Case Circles into the following three mutually exclusive types (see Fig. 6):

1.
Type 
 : 
, and 
 does not cross [st], and st is tangent to 
.

2.
Type 
 : 
 and 
 does not cross [st].

3.
Type Y : 
 and 
 crosses [st].

Fig. 6
figure 6
The three types of Worst Case Circles

Full size image

Next, we show that the Worst Case Circles of Delaunay triangles 
 fall into the same categories. Let 
 be the circumcircle of 
 centred at 
, let 
 be the leftmost point of 
, and let 
 be the right intersection of 
 with [st]. We begin with the following observation which follows from how the criteria forces 
 to intersect [st]:

Observation 5
Let 
. Taking a clockwise walk along 
 from 
 to 
, exactly one of p or q is encountered. An analogous statement holds for the counterclockwise walk.

This observation captures the necessary property that allows the categorisation to go through. We denote the Worst Case Circle of 
 by 
 with centre 
, and leftmost point 
.

Lemma 4
 can be categorised into the following three mutually exclusive types:

1.
Type 
 : 
, and 
 does not cross [st], and st is tangent to 
.

2.
Type 
 : 
 and 
 does not cross [st].

3.
Type Y : 
 and 
 crosses [st].

Proof
If 
 does not cross [st], 
 is clearly of type 
 or 
.

Consider when 
 crosses [st]. Without loss of generality, let 
 be above [st] and 
 be below [st]. By Observation 5, 
 occurs on the counterclockwise walk around 
 from 
 to 
, for if not, neither vertex of 
 occurs on the clockwise walk around 
 from 
 to 
. Since 
 is above [st], it lies above the leftmost intersection of 
 with [st] and below 
.

Since 
 is moved along the perpendicular bisector of 
 towards the counterclockwise arc of 
 to 
, it must be that 
 (which starts at 
 when 
 starts at 
) moves onto 
 eventually. Thus, 
 is Type Y. 

Routing on 
In order to route on , we simulate the relaxation of Bonichon et al.’s routing algorithm [8] described in the previous section. We first prove a property that allows us to distribute information about edges over their endpoints.

Lemma 5
Every edge  is protected by at least one of its endpoints u or v.

Proof
Suppose that uv is not protected at u. Then uv is not extreme at u and thus by Observation 1, u must have consecutive clockwise-ordered Delaunay neighbours 
. By Lemma 1, 
 since , and thus 
 and 
 cannot both belong to the same cone with apex v and angle at most . Since 
 are consecutive clockwise-ordered Delaunay neighbours of v, and 
 and 
 cannot be in the same cone, it follows that vu is extreme at v. Hence, uv is protected at v when it is not protected at u. 

This lemma allows us to store all edges of the Delaunay triangulation by distributing them over their endpoints. At each vertex u, we store:

1.
Fully protected edges uv, with two additional bits to denote whether it is extreme, penultimate, or middle at u.

2.
Semi-protected edges uv (only protected at u), with one additional bit denoting whether the clockwise or counterclockwise face path is a spanning path to v.

We can label the vertices of  in this way, denoting this augmented graph as a Marked Bounded Degree Graph or  for short. Pseudocode and its running time analysis can be found in Appendix A.

Theorem 6
 stores O(1) words of information at each of its vertices.

Proof
According to Corollary 1, each vertex in  is incident to at most  (fully and semi) protected edges, where  is a fixed constant. From the above discussion a vertex may store 2 bits for each incident protected edge in , which immediately proves the theorem. 

In the remaining part of Sect. 3.2 we will focus our attention on routing in . When we write “an edge is followed" or “walking along a face" or any statement of that sort, this is always done in  using only the information stored in each vertex unless otherwise stated. At a high level, the routing algorithm on  works as follows: the simulation searches for a suitable candidate triangle 
 at 
, possibly taking a walk from 
 along a face to be defined later in order to do so. Once 
 has been found, we will know the locations of 
, where p and q are candidate vertices for 
, and we can thus use the routing criteria of Bonichon et al.’s routing algorithm [8] to determine whether to route to p or to route to q. Next, we describe how to route on the non-triangular faces of ; the vertices of any such face can always be labelled with 
 where 
 and 
 are a middle edge and a penultimate edge at v (see Fig. 7).

Fig. 7
figure 7
A non-triangular face of . Dotted edges here are unprotected at v

Full size image

There are two different situations wherein we must route on such faces. The first situation is when we want to move from v to any other vertex (the destination vertex along such a face is undetermined until it is reached); we shall use Unguided Face Walks to ensure a face-route with constant stretch in such a situation. The second situation is when we want to move from any other vertex on this face to v; we shall use Guided Face Walks to ensure a face-route with constant stretch in such a situation.

Unguided Face Walks
Suppose 
 and 
 are a middle edge and a penultimate edge and suppose that 
 is the shorter of the two. We want to route from v to any other vertex p on this face. For any such vertex p on this face, we refer to the spanning face path from v to p starting with 
 as an Unguided Face Walk from v to p.

Fig. 8
figure 8
An Unguided Face Walk from v to p. 
 and 
 are not labeled with “middle” or “penultimate” to emphasize that we can take the shorter of the two

Full size image

In the simulation, we use Unguided Face Walks in a way that p is undetermined until it is reached; we will take an Unguided Face Walk from v and test at each vertex along this walk if it satisfies some property, ending the walk if it does. Routing in this manner from v to p can easily be done locally: Suppose 
 was counterclockwise to 
 (see Fig. 8). Then, at any intermediate vertex 
, we take the edge immediately counterclockwise to 
 (
). The procedure when 
 is clockwise to 
 is analogous.

Observation 7
An Unguided Face Walk needs O(1) memory since at 
, the previous vertex along the walk 
 must be stored in order to determine 
.

Observation 8
An Unguided Face Walk from v to p has a stretch factor of at most  as shown in the proof of Theorem 2.

Guided Face Walks
Suppose we want to route from p to v where pv is extreme at p but not protected at v (i.e., it is a semi-protected edge stored at p). Then, pv is a chord of some face determined by 
 and 
 where the former is a middle edge and the latter a penultimate edge. Moreover, recall that we stored a bit with the semi-protected edge pv at p indicating whether to take the edge clockwise or counterclockwise to reach v. We refer to the face path from p to v following the direction pointed to by these bits as the Guided Face Walk from p to v (see Fig. 9). Routing from p to v can now be done as follows:

1.
At p, store v in memory.

2.
Until v is reached, if there is an edge to v, take it. Otherwise, take the edge pointed to by the bit of the semi-protected edge to v.

Fig. 9
figure 9
A guided face walk from p to v. Vertices at which an edge is semi-protected are labeled with the edge and a bit-direction

Full size image

Observation 9
A Guided Face Walk needs O(1) memory since v needs to be stored in memory for the duration of the walk.

Observation 10
A Guided Face Walk from p to v has a stretch factor of at most  as shown in the proof of Theorem 2.

Simulating the Relaxation of Bonichon et al.’s Routing Algorithm [8]
We are now ready to describe the routing algorithm on  in more detail. First, we consider finding the first vertex after s. If st is an edge, take it and terminate. Otherwise, at 
, we consider all edges protected at s, and let 
 and 
 be the first such edge encountered in a counterclockwise and clockwise sweep starting from [st] centred at s. There are two subcases.

(I)
If both 
 and 
 are not middle edges at s, then 
 is a Delaunay triangle 
. Determine whether to route to 
 or 
, using the same criteria used in Bonichon et al.’s routing algorithm [8] (see the beginning of Sect. 3). If the picked edge is fully protected, we follow it. Otherwise, we take the Guided Face Walk from s to this vertex.

(II)
If one of 
 and 
 is a middle edge at s, the other edge must then be a penultimate edge. Then, 
 must be contained in the cone with apex s sweeping clockwise from 
 to 
. We assume that 
 is shorter than 
. Take the Unguided Face Walk from s until some 
 such that 
 is above [st] and 
 is below [st]. We have now found 
 and we determine whether to route to p or q, using the same criteria used in Bonichon et al.’s routing algorithm [8] (see the beginning of Sect. 3).

In both cases, the memory used for the Face Walks is cleared and 
 or 
 is stored as the last triangle used.

Next, we focus on how to simulate a routing step from an arbitrary vertex 
. Suppose 
 is above [st], and that 
 is stored in memory. If 
 is an edge, take it and terminate. Otherwise, let 
 be the rightmost edge of 
 that intersects [st], and 
 
 be its extension to a line. Make a counterclockwise sweep, centred at 
 and starting at 
, through all edges that are protected at 
 that lie in the halfplane defined by 
 
 that contains t. Note that this region must have at least one such edge, since otherwise 
 is a convex hull edge, which cannot be the case since s and t are on opposite sides.

(I)
If there is some edge that does not intersect [st] in this sweep, let 
 be the first such edge encountered in the sweep and let 
 be the protected edge immediately clockwise to 
 at 
. There are two cases to consider.

(I.I)
If 
 is not contained in the cone with apex 
 sweeping clockwise from 
 to 
 (see Fig. 10a), simulating a step of the relaxation of Bonichon et al.’s Routing Algorithm [8] is analogous to the method used for the first step: determine if 
 or 
 is a middle edge and use a Guided or Unguided Face Walk to reach the proper vertex of 
.

Fig. 10
figure 10
Simulating a step of the relaxation of Bonichon et al.’s routing algorithm [8]: a Case I.I, b case I.II.

Full size image

(I.II)
If 
 is contained in the cone with apex 
 sweeping clockwise from 
 to 
 (see Fig. 10b), then one of 
 and 
 must be a middle edge and the other a penultimate edge. This must be the case since the edge 
 is contained in the interior of the cone with apex 
 sweeping clockwise from 
 to 
 and is thus not protected at 
; unprotected edges at 
 are always between a middle and a penultimate edge. Then, 
 must be contained in the cone with apex 
 sweeping clockwise from 
 to 
. We take the Unguided Face Walk, starting from the shorter of 
 and 
. If we start from 
, we stop when we have found some 
 such that 
 is above [st] and 
 is below [st], and make the decision to complete the Unguided Face Walk to q or not. If, on the other hand, we start from 
, we stop when we have both passed f in the Unguided Face Walk (to ensure that 
 lies to the right of 
) and found some 
 such that 
 is below [st] and 
 is above [st], and make the decision to complete the Unguided Face Walk to p or not.

(II)
If all of the edges in the sweep intersect [st] (see Fig. 11), let 
 be the last edge encountered in the sweep, and 
 be the protected edge immediately counterclockwise to it, which must be in the halfplane defined by 
 
 that does not contain t. Note that 
 cannot be contained in this cone, as that would imply that 
, making 
 a convex hull edge. Simulating the Delaunay routing algorithm is analogous to the method used for the first step: determine if 
 or 
 is a middle edge and use a Guided or Unguided Face Walk to reach the proper vertex of 
.

Fig. 11
figure 11
Simulating a step of the relaxation of Bonichon et al.’s routing algorithm [8] (case II).

Full size image

In all cases, we clear the memory and store 
 as the previous triangle. The case where 
 lies below [st] is analogous. We obtain the following theorem.

Theorem 11
The simulation of the relaxation of Bonichon et al.’s routing algorithm [8] on  is 1-local, has a routing ratio of at most  and uses O(1) memory.

Lightness
In the previous sections we have presented a bounded degree network  with small spanning ratio that allows for local routing. It remains to show how we can prune this graph even further to guarantee that the resulting network  also has low weight.

We will describe a pruning algorithm that takes  and returns a graph (Light Marked Bounded Degree Graph) , allowing a trade-off between the weight (within a constant times that of the minimum spanning tree of V) and the (still constant) stretch factor. Then, we show how to route on  with a constant routing ratio and constant memory.

The Levcopoulos and Lingas Protocol
To bound the weight of , we use the algorithm by Levcopoulos and Lingas [23] with two slight modifications: (1) allow any planar graph as input instead of only Delaunay triangulations, and (2) marking the endpoints of pruned edges to facilitate routing.

At a high level, the algorithm works as follows: Given , we compute its minimum spanning tree and add these edges to . We then take an Euler Tour around the minimum spanning tree, treating it as a degenerate polygon P enclosing V. Finally, we start expanding P towards the convex hull CH(V). As edges of  enter the interior of P, we determine whether to add them to . This decision depends on a given parameter . If an edge is excluded from , we augment its endpoints with information to facilitate routing should that edge be used in the path found on . Once P has expanded into CH(V), we return .

To explicate further upon this, let us first acknowledge and differentiate between a few kinds of edges which will play a part in the following discussion:

1.
Convex hull edges of CH(V).

2.
Boundary edges of the polygon P that encloses V.

3.
Included settled edges, which are edges of  in P and included in .

4.
Excluded settled edges, which are edges of  in P and excluded from .

5.
Unsettled edges, which are edges of  outside of P and whose inclusion in  have not yet been determined.

Note that while the last three kinds are mutually exclusive, there may be edges which are of more than one kind. For example, a boundary edge of P can coincide with a convex hull edge of CH(V).

How the Polygon Grows
For each iteration of the Levcopoulos and Lingas Protocol, P, a polygon without holes, grows, consuming more area and more edges of , until it coincides completely with the convex hull CH(V). Let us consider a single iteration of the algorithm.

Consider any edge uv on the convex hull CH(V). If part of the boundary of P coincides with uv, there is nothing to consider. However, if that is not the case, then, among the two paths from u to v along the boundary of P, consider the path  which has a part visible to uv (see Fig. 12a); that is, there exists a line segment connecting the interior of  to the interior of uv that does not intersect the interior of P.

 concatenated with uv then forms a closed curve C on the plane that does not intersect the interior of P. C is further subdivided by unsettled edges (non-crossing by planarity), with endpoints between vertices of , into cells 
 (see Fig. 12b).

Fig. 12
figure 12
a  has a part visible to uv. The dotted edge is a convex hull edge of V. b  is subdivided into k cells. Each gray edge is an edge in 

Full size image

If there are no unsettled edges, we expand  into uv by removing  from P and adding uv to P. If, on the other hand, there is at least one unsettled edge, there must be some cell 
 whose entire boundary, minus one unsettled edge pq, coincides with a part of  (see Fig. 13a).

Fig. 13
figure 13
a 
 coincides with part of  except its one unsettled edge. 
 and 
 are not candidates for expansion. b Expansion of P into 

Full size image

Then, we consider the addition of pq into , make it a settled edge, and expand P into 
 by removing the subpath from p to q along  from P, and adding the edge pq to P (see Fig. 13b). Since the area of P is increasing, this process must eventually terminate.

Condition for Including an Edge
The decision whether to include an edge in  depends on an adjustable parameter , which causes an increase in the stretch factor by a factor of at most  and ensures a weight of at most  times that of .

All settled edges are assigned a , which is the length of a short (but not necessarily shortest) path between their endpoints that uses only the currently included settled edges, which are by definition edges of . Initially,  for all edges pq in the minimum spanning tree of . Now, when considering whether to include the unsettled edge uv into , we take the sum S of the weight of edges in . These edges have been settled and thus have weight assigned. If S is greater than , add uv to  and assign it a weight of |uv| now that is has been settled. Otherwise, settle uv but exclude it, and assign it a weight of S. We can see that S is the length of the path from u to v; that is, the concatenation of paths between the endpoints of edges in .

Bounds on the Levcopoulos and Lingas Protocol
Given an unsettled edge uv, let  be the path along P from u to v such that  concatenated with uv forms a closed curve that does not intersect the interior of P. When processing an edge uv, it is added to  when the summed weight of the edges of  is greater than . This implies that  is a spanner.

Theorem 12
 is a -spanner of  for an adjustable parameter .

Theorem 13
 has weight at most  times the weight of the minimum spanning tree of  for an adjustable parameter .

Proof
Let P be the polygon that encloses V in the above algorithm. Initially P is the degenerate polygon described by the Euler tour of the minimum spanning tree of V in . Give each edge e of P, a starting credit of r|e|. Denote the sum of credits of edges in P with credit(P). The sum of credit(P) and the weight of the initially included settled edges is then  times the weight of the minimum spanning tree of .

As P is expanded and edges are settled, we adjust the credits in the following manner:

If an edge uv is added into  when settled, we set the credit of the newly added edge uv of P to , and the credit of the edges along  to 0.

If an edge is excluded from  when settled, we set the credit of the newly excluded edge uv of P to , and the credit of edges along  to 0.

We can see that the sum of credit(P) and the weights of included settled edges, at any time, is at most  times the weight of the minimum spanning tree of  since it strictly drops when adding an edge when it is settled and stays the same when excluding an edge when it is settled.

It now suffices to show that credit(P) is never negative, which we do by showing that for every edge uv of P, at any time, . We do this by induction over the edges in the order they are settled. For the base case, when P is the Euler Tour around the minimum spanning tree of , we have that . For the induction step, let uv be a settled edge. There are two cases:

(I)
If uv is added to , then credit(uv) equals


 

The first inequality holds from the induction hypothesis, and the second inequality and last equality hold since uv is added to .

(II)
If uv is not added to , then credit(uv) equals


 

The first inequality holds from the induction hypothesis, and the equality holds since uv was not added.

Since credit(P) is never negative, and the sum of credit(P) and the weights of included settled edges is at most  times the weight of the minimum spanning tree of , the theorem follows. 

Putting together all the results so far, we get:

Theorem 14
Given a set V of n points in the plane together with two parameters  and , one can compute in  time a planar graph  that has degree at most , weight of at most  times that of a minimum spanning tree of V, and is a -spanner of V, where .

Proof
Let us start with the running time. The algorithm by Levcopoulos and Lingas (Lemma 3.3 in [23]) can be implemented in linear time and, according to Corollary 1,  can be constructed in  time, hence,  in total.

The degree bound and planarity follow immediately from the fact that  is a subgraph of , and the bound on the stretch factor follows from Theorem 12 and Corollary 1.

It only remains to bound the weight. Callahan and Kosaraju [13] showed that the weight of a minimum spanning tree of a Euclidean graph G(V) is at most t times that of the weight of MST(V) whenever G is a t-spanner on V. Since  is a -spanner on V by Corollary 1,  has weight of at most  times that of the minimum spanning tree of V by Theorem 13. This concludes the proof of the theorem. 

Finally, we prove that  has short paths between the ends of pruned edges.

Theorem 15
Let uv be an excluded settled edge. There is a face path in  from u to v of length at most .

Proof
If uv is the first excluded settled edge processed by the Levcopoulos-Lingas algorithm, then all edges of  must be included in . By planarity, no edge will be added into the interior of the cycle consisting of uv and  once uv is settled, and thus uv will be a chord on the face in  that coincides with . Thus,  is a face path in  from u to v with a length of at most .

Otherwise, if uv is an arbitrary excluded edge, then some edges of  may be excluded settled edges. If none are excluded, then  is again a face path with length at most weight(uv). However, if some edges are excluded, then, by induction, for each excluded edge pq along , there is a face path in  from p to q with a length of . Replacing all such pq in  by their face paths, and since no edge will be added into the interior of the cycle consisting of uv and  once uv is settled,  with its excluded edges replaced by their face paths is a face path in  from u to v with a length of . 

Remark
The remainder of this section is not required to proceed, but it is worth mentioning this curious phenomenon. We can say something even stronger about the weight if  is small. When , the weight of  can be bounded to be no more than  times that of a minimum spanning tree on V.

Lemma 6
If 
 and 
 are edges in a minimum spanning tree of V then 
.

Proof
Refer to Fig. 14a. Let 
 and 
 be edges in a minimum spanning tree of V. Suppose for a contradiction that 
. Then, without loss of generality, we can say that 
. Since 
 and 
, we deduce that 
. We can therefore replace 
 with 
 to get a lighter spanning tree, contradicting the minimality of the tree. Therefore, it must be that 
. 

Lemma 7
Fix a minimum spanning tree on V. Let C be a cone with apex u and angle measure less than . If uv is a minimum spanning tree edge contained in C, and if there is a  such that , then we can replace uv with uw to get another minimum spanning tree.

Proof
Fix a minimum spanning tree on V. Let C be a cone with apex u and angle measure less than , and let uv be a minimum spanning tree edge contained in C. Suppose there is a  such that . We consider two cases separately. In the first case, when the path in the minimum spanning tree from v to w does not go through u (see Fig. 14b), we can replace uv with uw to get a spanning tree no heavier. In the second case, when the path in the minimum spanning tree from v to w goes through u (see Fig. 14c), we can replace uv with vw to get a lighter spanning tree. This is a contradiction to the minimality of the spanning tree and is thus an impossible case. Since we can fix up the first case, and the second is impossible, we have shown how that we can replace uv with uw to get another minimum spanning tree. 

Fig. 14
figure 14
a We can replace 
 with 
 to get a lighter tree. b We can replace uv with uw to get a tree no heavier. c We can replace uv with vw to get a lighter tree

Full size image

Theorem 16
If , a minimum spanning tree of V is contained in .

Proof
It is a known fact that the Delaunay triangulation  contains a minimum spanning tree of V (see [4]). Fix a minimum spanning tree of . Suppose uv is a minimum spanning tree edge that is not in . It is therefore not fully protected. Without loss of generality, say it is not protected at u. Look at the cone 
 that contains uv. Let um be the middle edge in C. Since the angle measure of C is less than , and by the definition of the middle edge which says , we can replace uv with um by Lemma 7 to get another minimum spanning tree. Since the angle measure of C is less than , there can only be one such edge uv in C that needs replacement, by Lemma 6. This says that we are replacing at most one minimum spanning tree edge with um, to get another minimum spanning tree. Repeating this process for all minimum spanning tree edges that are not fully protected, we will trade a set of  distinct minimum spanning tree edges that are not fully protected with k distinct middle edges to get another minimum spanning tree; one that is contained in . 

Corollary 2
If ,  has a weight no more than  times that of a minimum spanning tree of V.

Proof
This follows immediately from Theorem 16. 

Routing on the Light Graph
In order to route on , we store edge-data at each of its endpoints when it is excluded. Specifically, let uv be some excluded edge; at u (and v) we store uv, along with one bit to indicate whether the starting edge of the -path is the edge clockwise or counterclockwise to uv.

Observation 17
 stores O(1) words of information at each vertex.

To route on , we simulate the routing algorithm on . When this algorithm would follow an excluded edge uv at u, we store v and the orientation of the face path from uv at u in memory. Then, until v is reached, take the edge that is clockwise or counterclockwise to the edge arrived from, in accordance with the orientation stored. Once v is reached, we proceed with the next step of the routing algorithm on .

Note that bounding the weight in this manner only requires the input graph to be planar. It transforms the pruned edges into O(d) information at each vertex, where d is the degree of the input graph; in our case d is a constant. The scheme of simulating a particular routing algorithm and switching to a face routing mode when needed can then be applied to the resulting graph.

Theorem 18
The routing algorithm on  is 1-local, has a routing ratio of  and uses O(1) memory.

Proof
The 1-locality follows by construction. The routing ratio follows from Theorem 11. Finally, the memory bound follows from the fact that while routing along a face path to get across a pruned edge, no such subpaths can be encountered. Thus, the only additional memory needed at any point in time is a constant amount to navigate a single face path. 

Conclusion
We showed how to construct and route locally on a bounded-degree lightweight spanner. In order to do this, we simulate a relaxation of Bonichon et al.’s routing algorithm [8] on Delaunay triangulations. A natural question is whether our routing algorithm can be improved by using the improved Delaunay routing algorithm by Bonichon et al. [7]. Unfortunately, this is not obvious: when applying the improved algorithm on our graph, we noticed that the algorithm can revisit vertices. While this may not be a problem, it implies that the routing ratio proof from [7] needs to be modified in a non-trivial way and thus we leave this as future work.

References
Althöfer, I., Das, G., Dobkin, D.P., Joseph, D., Soares, J.: On sparse spanners of weighted graphs. Discrete Comput. Geom. 9, 81–100 (1993)

MathSciNet  Article  Google Scholar 

Angelini, P., Frati, F., Grilli, L.: An algorithm to construct greedy drawings of triangulations. J. Graph Algorithms Appl. 14(1), 19–51 (2010)

MathSciNet  Article  Google Scholar 

Ashvinkumar, V., Gudmundsson, J., Levcopoulos, C., Nilsson, B.J., van Renssen, A.: Local routing in sparse and lightweight geometric graphs. In: Proceedings of the 30th International Symposium on Algorithms and Computation (ISAAC 2019), Leibniz International Proceedings in Informatics (LIPIcs), vol. 149, pp. 33:1–33:13 (2019)

Berg, M.D., Cheong, O., Kreveld, M., Overmars, M.: Computational Geometry: Algorithms and Applications. Springer, Berlin (2008)

Book  Google Scholar 

Biniaz, A., Bose, P., Carufel, J.D., Gavoille, C., Maheshwari, A., Smid, M.H.M.: Towards plane spanners of degree 3. J. Comput. Geom. 8(1), 11–31 (2017)

MathSciNet  MATH  Google Scholar 

Bonichon, N., Bose, P., Carmi, P., Kostitsyna, I., Lubiw, A., Verdonschot, S.: Gabriel triangulations and angle-monotone graphs: local routing and recognition. In: International Symposium on Graph Drawing and Network Visualization (GD), Lecture Notes in Computer Science (LNCS), vol. 9801, pp. 519–531 (2016)

Bonichon, N., Bose, P., De Carufel, J., Despré, V., Hill, D., Smid, M.: Improved routing on the delaunay triangulation. In: Proceedings of the 26th Annual European Symposium on Algorithms (ESA), Leibniz International Proceedings in Informatics (LIPIcs), vol. 112, pp. 22:1–22:13 (2018)

Bonichon, N., Bose, P., De Carufel, J., Perković, L., Van Renssen, A.: Upper and lower bounds for online routing on Delaunay triangulations. Discrete Comput.l Geom. 58(2), 482–504 (2017)

MathSciNet  Article  Google Scholar 

Bonichon, N., Kanj, I., Perković, L., Xia, G.: There are plane spanners of degree 4 and moderate stretch factor. Discrete Comput. Geom. 53(3), 514–546 (2015)

MathSciNet  Article  Google Scholar 

Borradaile, G., Le, H., Wulff-Nilsen, C.: Greedy spanners are optimal in doubling metrics. In: Proceedings of the 30th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pp. 2371–2379. SIAM (2019)

Bose, P., Fagerberg, R., van Renssen, A., Verdonschot, S.: Optimal local routing on Delaunay triangulations defined by empty equilateral triangles. SIAM J. Comput. 44(6), 1626–1649 (2015)

MathSciNet  Article  Google Scholar 

Bose, P., Morin, P.: Online routing in triangulations. SIAM J. Comput. 33(4), 937–951 (2004)

MathSciNet  Article  Google Scholar 

Callahan, P.B., Kosaraju, S.R.: Faster algorithms for some geometric graph problems in higher dimensions. In: Proceedings of the 4th ACM-SIAM Symposium on Discrete Algorithms (SODA), pp. 291–300 (1993)

Das, G., Heffernan, P.J., Narasimhan, G.: Optimally sparse spanners in 3-dimensional Euclidean space. In: Proceedings of the 9th Symposium on Computational Geometry, pp. 53–62. ACM (1993)

Das, G., Narasimhan, G., Salowe, J.S.: A new way to weigh malnourished Euclidean graphs. In: Proceedings of the 6th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pp. 215–222. ACM-SIAM (1995)

Dhandapani, R.: Greedy drawings of triangulations. Discrete Comput. Geom. 43(2), 375–392 (2010)

MathSciNet  Article  Google Scholar 

Dijkstra, E.W.: A note on two problems in connexion with graphs. Numer. Math. 1, 269–271 (1959)

MathSciNet  Article  Google Scholar 

Dobkin, D.P., Friedman, S.J., Supowit, K.J.: Delaunay graphs are almost as good as complete graphs. Discrete Comput. Geom. 5, 399–407 (1990)

MathSciNet  Article  Google Scholar 

Dumitrescu, A., Ghosh, A.: Lower bounds on the dilation of plane spanners. Int. J. Comput. Geom. Appl. 26(02), 89–110 (2016)

MathSciNet  Article  Google Scholar 

Filtser, A., Solomon, S.: The greedy spanner is existentially optimal. SIAM J. Comput. 49(2), 429–447 (2020)

MathSciNet  Article  Google Scholar 

Gottlieb, L.: A light metric spanner. In: IEEE 56th Annual Symposium on Foundations of Computer Science (FOCS), pp. 759–772. IEEE (2015)

Kanj, I.A., Perkovic, L., Türkoglu, D.: Degree four plane spanners: simpler and better. J. Comput. Geom. 8(2), 3–31 (2017)

MathSciNet  MATH  Google Scholar 

Levcopoulos, C., Lingas, A.: There are planar graphs almost as good as the complete graphs and almost as cheap as minimum spanning trees. Algorithmica 8(1–6), 251–256 (1992)

MathSciNet  Article  Google Scholar 

Li, X.Y., Wang, Y.: Efficient construction of low weight bounded degree planar spanner. In: Proceedings of the 9th Annual International Computing and Combinatorics Conference (COCOON), Lecture Notes in Computer Science (LNCS), vol. 2697, pp. 374–384 (2003)

Narasimhan, G., Smid, M.: Geometric Spanner Networks. Cambridge University Press, Cambridge (2007)

Book  Google Scholar 

Xia, G.: The stretch factor of the Delaunay triangulation is less than 1.998. SIAM J. Comput. 42(4), 1620–1659 (2013)

MathSciNet  Article  Google Scholar 

Download references

Author information
Affiliations
University of Sydney, Sydney, Australia

Vikrant Ashvinkumar, Joachim Gudmundsson & André van Renssen

Lund University, Lund, Sweden

Christos Levcopoulos

Malmö University, Malmö, Sweden

Bengt J. Nilsson

Authors

Vikrant Ashvinkumar
You can also search for this author in PubMed Google Scholar

Joachim Gudmundsson
You can also search for this author in PubMed Google Scholar

Christos Levcopoulos
You can also search for this author in PubMed Google Scholar

Bengt J. Nilsson
You can also search for this author in PubMed Google Scholar

André van Renssen
You can also search for this author in PubMed Google Scholar

Corresponding author
Correspondence to André van Renssen.

Additional information
Publisher's Note
Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.

An extended abstract appeared at the 30th International Symposium on Algorithms and Computation (ISAAC 2019) [3]. J. Gudmundsson is funded by the Australian Government through the Australian Research Council DP150101134 and DP180102870. C. Levcopoulos is funded by Swedish Research Council Grants 2017-03750 and 2018-04001.

A Algorithmic Construction of 
A Algorithmic Construction of 
We state a modification to the construction of  to construction of . Added lines to the former construction have been inserted at lines 20,21,22 and coloured red.

figure b
Theorem 19
 takes  time to construct.  takes O(n) time to construct if the input is a Delaunay triangulation  on V.

Proof
The running time of the loop at line 8 remains unchanged; it is O(n) since there are a linear number of edges, each looked at at most eight times (four times per endpoint). For the same reasons that justify the construction time of , we can then conclude that  takes  time to construct and  takes O(n) time to construct if the input is a Delaunay triangulation  on V. 