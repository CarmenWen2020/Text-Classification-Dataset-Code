We consider the problem of encoding two-dimensional arrays, whose elements come from a total order, for answering  queries. The aim is to obtain encodings that use space close to the information-theoretic lower bound, which can be constructed efficiently. For an  array, with , we first propose an encoding for answering 1-sided  queries, whose query range is restricted to , for . Next, we propose an encoding for answering for the general (4-sided)  queries that takes 
 bits, which generalizes the joint Cartesian tree of Golin et al. [TCS 2016]. Compared with trivial -bit encoding, our encoding takes less space when . In addition to the upper bound results for the encodings, we also give lower bounds on encodings for answering 1 and 4-sided  queries, which show that our upper bound results are almost optimal.

Introduction
Given a one-dimensional (1D) array  of n elements from a total order, the range Top-k query on A () returns the positions of k largest values in . In this paper, we refer to these queries as 2-sided  queries; and the special case where the query range is , for , as the 1-sided  queries. We can extend the definition to the two-dimensional (2D) case—given an  2D array  of mn elements from a total order and a , the range Top-k query on A () returns the positions of k largest values in . Without loss of generality, we assume that all elements in A are distinct (by ordering equal elements based on the lexicographic order of their positions). Also, we assume that . In this paper, we consider the following types of  queries.

Based on the order in which the answers are reported

Sorted query: the k positions are reported in sorted order of their corresponding values.

Unsorted query: the k positions are reported in an arbitrary order.

Based on the query range

1-sided query: the query range is , for .

4-sided query: the query range is , for , and .

We consider how to support these range  queries on A in the encoding model. In this model, one needs to construct a data structure (an encoding) so that queries can be answered by only accessing the data structure, without accessing the original input array A. The minimum size of such an encoding is also referred to as the effective entropy of the input data [10]. Our aim is to obtain encodings that use space close to the effective entropy, which can be constructed efficiently. In the rest of the paper, we use  to denote  if A is clear from the context. Also, unless otherwise mentioned, we assume that all  queries are sorted, and 4-sided  queries. Finally, we assume the standard word-RAM model [17] with word size Footnote 1.

Previous work
The problem of encoding 1D arrays to support  queries has been widely studied in the recent years. Especially, the case when , which is commonly known as the Range maximum query (RMQ) problem, has been studied extensively, and has a wide range of applications [1]. Fischer and Heun [6] proposed an optimal -bit data structure which answers RMQ queries on 1D array of size n in constant time. For a 2D array A of size , a trivial way to encode A for answering RMQ queries is to store the rank of all elements in A, using  bits. Golin et al. [10] show that when  and  encodings on each row are given, one can support  queries on A using  extra bits by encoding a joint Cartesian tree of the two rows. By extending the above encoding, they obtained -bit encoding for answering  queries on A, which takes less space than the trivial -bit encoding when . Brodal et al. [3] proposed an 
-bit data structure which supports  queries on A in constant time. Finally, Brodal et al. [2] obtained an optimal -bit encoding for answering  queries on A (although the queries are not supported efficiently). For the case when , Davoodi et al. [5] proposed a -bit data structure to encode a 1D array of size n, which supports  queries in constant time. The space was later improved by Gawrychowski and Nicholson [9] to the optimal  bits, although it does not support queries efficiently.

For general k, on a 1D array of size n, Grossi et al. [11] proposed an -bit encoding which supports sorted  queries in O(k) time, and showed that at least  bits are necessary for answering 1-sided  queries; Gawrychowski and Nicholson [9] proposed a -bitFootnote 2 encoding for  queries (although the queries are not supported efficiently), and showed that at least  bits are required to encode  queries. They also proposed a -bit data structure for answering  queries in 
 time, for any strictly increasing function f. For a 2D array A of size , one can answer  queries using  bits, by storing the rank of all elements in A. To support the queries efficiently on this encoding, one can use some of the existing orthogonal range reporting data structures in 3D, in which the z-coordinate stores the rank of the elements in A (while x- and y-coordinates correspond to the positions of the elements in A), while reporting the points in sorted order of their ranks. However, all the known 3D orthogonal range reporting data structures use at least linear space (i.e.,  bits), and take at least  time to answer sorted  queries. See 7 [13] for details. Also Rahul and Tao considered the data structures for answering  queries in 
 [19, 20]; all their data structures use super-linear space (for 4-sided queries). To the best of our knowledge, there are no results on encodings for range  queries on 2D arrays for .

Table 1 Summary of the results of upper and lower bounds for  encodings on 2D arrays
Full size table

Our results
Given an  array A, we first show that  bits are necessary and sufficient for answering sorted 1-sided  queries. For unsorted 1-sided queries, we show that  bits are necessary and sufficient. This space bound is strictly less than the space used to encode sorted 1-sided  queries. Thus it is interesting to note that in 2D, there is a gap between the space needed to encode the 1-sided  queries for the sorted and unsorted cases. In contrast, in 1D, the space needed to encode the 1-sided  queries for both sorted and unsorted cases are asymptotically the same (for ). We show that such encodings can be simply constructed in  time by using a min-heap data structure.

Next, in Sect. 3, we consider encodings for 4-sided  queries on an  array A. We first observe that one can obtain an -bit data structure which answers 4-sided  queries on A in O(k) time, by combining the results of [3] and [4]. We then propose the alternative encoding which uses less space than the trivial -bit encoding (which stores all the positions of A in sorted order), for small m.

To be more precise, we first show that 4n bits are sufficient for answering sorted 4-sided  queries on  array, when encodings for answering sorted 2-sided  queries for each row are given. This encoding is obtained by a binary DAG for answering  queries on  array which generalizes the -bit encoding of  query on  array proposed by Golin et al. [10], to general k; and shows that we can encode a joint Cartesian tree for general k (which corresponds to the DAG in our paper) using 4n bits. Note that the additional space is independent of k. By extending the encoding on  array, we obtain 
-bit encoding for answering 4-sided  queries on  arrays. This improves upon the trivial -bit encoding when , and also generalizes the -bit encoding [10] for answering  queries. The trivial encoding of the input array takes  bits, whereas one can easily show a lower bound of  bits for any encoding of an  array that supports  queries since at least  bits are necessary for answering  queries [3], and at least  bits are necessary for answering  queries for each row [11]. Thus, there is only a small range of parameters where a strict improvement over the trivial encoding is possible. Our result closes this gap partially, achieving a strict improvement when .

In Sect. 4, we also obtain a data structure for answering  queries in 
 time using  bits, if there exists an S(n, k)-bit encoding to answer sorted 2-sided  queries on a 1D array of size n in T(n, k) time. Comparing to the -bit encoding, this data structure uses more space but supports  queries efficiently (the -bit encoding takes 
 time for answering  queries).

Finally, in Sect. 5, given a  array A, we consider the lower bound on additional space required to answer unsorted (or sorted)  on A when encodings of  query for each row are given. We show that at least  additional bits are necessary for answering unsorted 1-sided  queries on A, when encodings of unsorted 1 or 2-sided  query for each row are given. Note that this lower bound also gives the lower bound for answering unsorted 4-sided  queries on  array under the same condition. We also show that  additional bits are necessary for answering sorted 4-sided  queries on A, when encodings of unsorted (or sorted) 2-sided  query for each row are given. These lower bound results imply that our encodings in 3 are close to optimal (i.e., within O(n) bits of the lower bound), since any  encoding for the array A also needs to support the  queries on the individual rows. All these results are summarized in Table 1.

Encoding 1-Sided Range  Queries on Two Dimensional Array
In this section, we consider the encoding of sorted and unsorted 1-sided  queries on a 2D array . In the rest of the paper, we use (i, j) to denote the position in the i-th row and j-th column of a 2D array.

Sorted 1-sided queries
We first introduce an encoding by simply extending the encoding of sorted 1-sided  queries for 1D array proposed by Grossi et al. [12]. Next we propose an optimal encoding for sorted 1-sided  queries on A. For a 1D array 
, define another 1D array  as follows. For , define . For , 
 if there exists a position 
 which satisfies 
, and  otherwise.

Then one can answer the 
 by finding the rightmost occurrence of every element  in . By representing X (along with some additional auxiliary structures) using  bits, Grossi et al. [12] obtained an encoding which supports 1-sided  queries on 
 in O(k) time. For a 2D array A, one can encode A to support sorted 1-sided  queries by writing down the values of A in column-major order into a 1D array, and using the encoding described above – resulting in the following encoding.

Proposition 1
A 2D array  can be encoded using  bits to support sorted 1-sided  queries in O(k) time.

Now we describe an optimal encoding of A which supports sorted 1-sided  queries. For 1D array 
, we can define another 1D array 
 such that for , 
 if 
 is the l-th largest element in 
 with , and 
 otherwise. Then we answer the 
 query as follows. We first find the rightmost position 
 such that 
. Then we find the rest of  positions 
 such that for , 
 is the rightmost position in 
 with 
. Finally, we return the positions 
. Therefore by storing 
 using  bits, we can answer the sorted 1-sided  queries on 
. Also we can sort 
 using the property that for , 
 if and only if one of the following two conditions hold: (i) 
, or (ii) 
 and there exist at least 
 positions 
 between 
 and 
 where 
 for all .

We can extend this encoding for the sorted 1-sided  queries on a 2D array A, to obtain an optimal encoding as stated in the following theorem.

Theorem 1
Given a 2D array  there is an encoding of size  bits, which can answer sorted 1-sided  queries. Also, the space bound is asymptotically optimum.

Proof
For , we first define the elements of j-th column in A as 
. Then we define the sequence 
 such that for , 
 if 
 is the l-th largest element in  with , and 
 otherwise. Since there exist 
 possible 
 sequences (T is the total number of ways in which we can choose p out of the m rows for new entries into the  positions, summed over all possible values of p), we can store 
 using  bits and we can answer the sorted 1-sided  queries on A by the following procedure.

1.
Find the rightmost column q, for some , such that 
 has  elements 
 where 
. If , we return the positions of 
 as the answers of the query, and stop. Otherwise (if ), we return the positions of 
, and

2.
Repeat Step 1 by setting k to , and j to .

We can return the positions in the sorted order of their corresponding values by applying the procedure to sort the answers of 1-sided  queries on 
, described above. This shows the upper bound.

We now show that  bits are necessary to encode sorted 1-sided  queries on A. Suppose there are two distinct sequences 
 and 
 which give sorted 1-sided  encodings of 2D arrays A and 
, respectively. For , if 
 then   
 by the definition of 
 and 
. Since for an  array, there are 
 distinct sequences 
, We now prove for 
, each 
 has an array A such that 
, which completes the proof of the theorem.

Without loss of generality, suppose that all elements in A come from the set . Then we can reconstruct A from the rightmost column using 
 as follows. If 
, for , we assign the 
-th largest element in L to A[j][n]. After we assign all values in the rightmost column with 
, we discard all assigned values from L, move to -th column and repeat the procedure. After we assign all values in A whose corresponding values in 
 are smaller than , we assign the remaining values in L to remaining positions in 
 which are not assigned yet. Thus for any , if 
 has  elements 
 where 
, then the b-th column in A contains -largest elements in  by the above procedure. This shows that 
. 

Note that this encoding takes less space than the encoding in the Proposition 1.

Unsorted 1-sided queries
In this section, we consider the encoding of unsorted 1-sided  queries on a 2D array A. Let unsorted 
 be the k positions, ordered in their lexicographic order. Grossi et al [12] show that for any array  of size n, one can support unsorted  queries for  using  bits with O(k) query time. This implies that we can answer unsorted 1-sided  queries on A using  bits with O(k) query time, by converting the unsorted 1-sided  queries on A into the unsorted  queries on a 1D array of size mn which is obtained by the values of A in column-major order. Now we consider the another encoding which supports unsorted query using optimal space, if query time is not of concern, and show the following.

Theorem 2
Given a 2D array  there is a data structure of size  bits which supports unsorted 1-sided  queries. Moreover, the space bound is asymptotically optimal.

Proof
We first show the upper bound by considering the two cases, (i) , and (ii)  separately.

Case (i) . In this case, we first encode the answers of unsorted  query using 
 bits. For , the answers of  are the positions of k largest values in A out of  positions, corresponding to the positions in  along with the positions . Thus, for any , if we know the answers of unsorted , we can encode the answers of unsorted  using 
 bits. Hence, the total space for encoding the answers for all the n columns is 
 bits. We can find the answers of a 1-sided  query as follows. We first decode the answers of , and decode the answers of unsorted 1-sided query from left to right until we decode the answers of b-th unsorted 1-sided  query.

Case (ii) . When , it is obvious that , i.e., all the positions within the query range are part of the answer. Therefore no extra space is needed for storing the answers of unsorted  queries for . When , we can encode the answers of  queries using 
 bits by using the similar encoding as described above (using 
 bits for answering  query and 
 bits for answering  queries for any ). Also, we can find the answers of unsorted 1-sided  by a similar procedure as in Case (i). The only difference is when , we just report all positions in the sub-array .

From the above two cases, it follows that we can answer unosorted 1-sided  queries on A using at most 
 bits. If , then 
; and if , then 
. Thus the space bound can be written as  bits. This shows the upper bound stated in the theorem.

Now we show the lower bound. Without loss of generality, suppose that all elements in the array come from the set 
, and  (we can prove the case when  in a similar way). Then it is enough to show that there are 
 arrays 
 of size  such that for any , there exists  such that unsorted 
.

We prove the above statement by induction on n. When , we assign  to the answers of unsorted , and assign 
 to remaining positions arbitrary. Since any k positions in  can be the answer of  query, there are 
 arrays such that any two of them have different answers for the  query.

Now assume the inductive hypothesis that the above statement holds for some 
 where 
, and that there are 
 arrays 
, satisfying the above statement. Let a set 
 and 
.

To prove the inductive step for 
, we first pick an arbitrary 
, 
 from the set of arrays 
 and add the 
-th column to 
 (none of the positions in this column have an assigned value). Then for some integer  where , we pick the answers of unsorted 
 query by choosing  positions from the set 
 and choosing the remaining  positions from the 
-th column. We then choose  elements from M and add them to the  positions chosen from the set 
. When we assign a value  to 
, we delete x from M, set 
 and 
. Since 
 for all , it is easy to show that this does not change the answers of unsorted 
 for all 
. Next, we assign the remaining values in M to the  chosen positions in the 
-th column, and finally assign the values in 
 to the remaining positions in that column arbitrarily. Since there are 
 ways to select the answers of unsorted 
 query, and for each s, there are 
 arrays 
 such that for all  and 
, unsorted 
 but unsorted 
. Therefore the above statement holds for 
 whenever it holds for 
, which proves the theorem. 

Note that we can construct the encoding of Theorem 2 in  time by maintaining a min-heap of size at most k. More precisely, we insert the values of A in column-major order and delete the minimum value in the heap when the size of the heap is more than k. We can answer the position of the k largest values in A[1, m][1, i] for , by scanning the heap after every m-th insertion, in O(k) time.

Remark
Let 
 and 
 be the space needed to encode the sorted and unsorted 1-sided  queries respectively. For 1D array, Gawrychowski and Nicholson showed that 
 (thus, the space requirements are asymptotically same for both case) [8]. In contrast, in 2D array case when , 
 by Theorems 1 and 2, which implies the gap between the space needed to encode the 1-sided  queries for sorted and unsorted case for a 2D array is significantly more than the case for a 1D array.

Encoding 4-Sided  Queries on on  Array
In this section, we give an encoding which supports general  queries on  2D array A. Note that if query time is not of concern in the above data structure, one can simply consider the -bit trivial encoding for answering  queries on A, by storing the rank (i.e., the position in sorted order) of all the elements in A. We first introduce an -bit data structure which supports  query in O(k) time by using the RMQ encoding of Brodal et al. [2].

Proposition 2
Given a 2D array  there exists an -bit data structure to support unsorted  in O(k) time for  and .

Proof
We use a data structure similar to the one outlined in [4] (based on Frederikson’s heap selection algorithm [7]) for answering unsorted  queries in 1D arrayFootnote 3. First encode A using  bits to support RMQ (range maximum) queries in constant time for any rectangular range in A. This encoding also supports finding the rank of any element in A in O(1) time [3]. Next, let 
 be the maximum value in , which can be found using an RMQ query on A. Then consider the 4-ary heap obtained by the following procedure. The root of the heap is x, and its four subtrees are formed by recursively constructing the 4-ary heap on the sub-arrays 
, 
, 
 and 
, respectively. Now, we can find the k largest elements in the above 4-ary heap in O(k) time using the algorithm proposed by Frederickson [7] (note that this algorithm only builds a heap with O(k) nodes which is a connected subgraph of the above 4-ary heap). 

We now introduce alternative encoding to support  queries on an  2D array A, which take less space than the trivial encoding for small m. The overall idea is as follows. We first show that 4n bits are sufficient for answering sorted 4-sided  queries on A for  when encodings for answering sorted 2-sided  queries for each row are given. This encoding is obtained by encoding the binary DAG which is defined later. After that, we extend the encoding into  array and obtain 
-bit encoding for answering  queries on A. Note that this encoding takes less space than the trivial -bit encoding when .

Now we describe the encoding of sorted 4-sided  on A when . For , let 
 be the array of the i-th row in A, and assume that sorted 2-sided  encodings on 
 and 
 are already given. When , i.e., to answer  queries on A, one can use the joint Cartesian tree of Golin et al. [10]. The joint Cartesian tree of constructs a conceptual binary tree analogous to a Cartesian tree, storing a bit indicating which row the maximum element in the range comes from, splitting the range corresponding to the node at the position of the maximum element, and then recursing on each subrange. Thus by storing an extra n bits (one at each node of the conceptual binary tree), they showed that one can answer  queries for any , if the encodings for answering  on 
 and 
 are given. See [10] for details. To answer the sorted 4-sided  queries with , we extend the idea of a joint Cartesian tree into a DAG-based structure, denoted by 
, which is defined as follows.

Every node p in 
 is labeled with some closed interval 
, where . In this case, we use both  and 
 to refer to the sorted  query. For a node p with label 
 in 
 and , let 
 be the position of the i-th largest element in . Now we define 
 as follows (see Fig. 1 for an example.).

Fig. 1
figure 1
 array A and the DAG 

Full size image

1.
The root of 
 is labeled with the range [1, n].

2.
A node p with label 
 does not have any child node (i.e., leaf node) if .

3.
Suppose there exists a non-leaf node p with label 
 in 
, and let 
 and 
 (
) be the leftmost and rightmost column indices among the answers of , respectively. If 
, then the node p has a node with label 
 as a left child. Similarly, if 
, the node p has a node with label 
 as a right child.

The following lemma states some useful properties of 
.

Lemma 1
Let A be a  array. The following statements hold.

(i)
For any two distinct nodes p and q in 
  (i.e., any two distinct nodes have different  answers).

(ii)
 if and only if p is descendant of q in 
.

(iii)
For any interval [a, b] with , there exists a unique node p in 
 which satisfies (i) 
, and (ii) label of any descendant of p does not contain [a, b]. Furthermore, for such a node p,  .

Proof
(i)
From the construction of 
, one can observe that if there is a node with label [a, b] in 
, with , then both -th and -th column contain at least one element that is larger than the elements in , which implies  and . Now suppose that there are two distinct nodes with labels [a, b] and 
 with 
 such that 
, then 
, contradicting the fact that . The case when 
, 
 or 
 is analogous.

(ii)
Let 
 and 
. From the construction of 
, it is the case that if p is a descendant of q, then 
. Now, suppose that there are two nodes 
 such that 
 but p is not descendant of q. Then there exists a node 
 which satisfies (i) 
 is a descendant of q, (ii) 
, and (iii) no child of 
 whose label contains 
. Since neither of labels of the children of 
 contain 
, all the positions of 
 are between 
-th and 
-th column. (otherwise, there always exists a child 
 of 
 which satisfies 
). But this would imply that 
, which leads to a contradiction with Lemma 1(i).

(iii)
We first show that there exists a unique node p in 
 such that 
 contains the interval [a, b] and none of labels of the children of p contain [a, b]. We then show that the .

Since label of the root in 
 contains all column indices in A, it is easy to see that there exists at least one node p with label 
 in 
 such that 
 but no child of 
 contains [a, b]. Suppose that there exists another node 
 with label 
 in 
 such that 
 but there is no child of 
 whose label contains [a, b]. By Lemma 1(ii), it follows that 
 and 
 (otherwise, one of them would be a descendant of the other, contradicting the conditions on p and 
). Now, suppose that 
 (the case when 
 is analogous). Then there exists a column 
 such that p has a child node with label 
 where 
 by the property of 
 (note that 
), contradicting the fact that p does not have such a child. This shows that there is a unique such p in 
.

Now we claim that . Suppose that there exist a  in 
 such that column c contains at least one of the answers to . Also without loss of generality, we assume that  (the case when  can be handled in a similar way). Then by the property of 
, p has a child with label 
 which still contains [a, b], contradicting the fact that p does not have such a child. 

By Lemma 1(iii), if the DAG 
 and the answers for each sorted 2-sided  queries corresponding to all the nodes in 
 are given, then we can answer any sorted  query by finding the corresponding node in p in 
 which satisfies .

We now describe how to encode 
 using at most 4n bits. The main idea of our encoding is as follows. For each node in 
, we assign at most 2 bits (except the root node, which is assigned k bits) while traversing all the nodes in the level order. These bits enable us to answer  queries on the range corresponding to each node in 
, using the  answers of the nodes in the previous level (more specifically, one of the parent nodes), and the  encodings of the individual rows. By Lemma 1(iii), this encoding is enough to answer all possible  queries for any . However, since there exists at most O(kn) nodes in 
 (see Lemma 2), this encoding takes O(kn) bits. To make the space independent to k, we skip some redundant nodes in 
 (i.e., nodes for which the answers of  on that nodes can be answered using the information obtained by some of the already traversed nodes, without any extra information). We modify the original level order to modified level order, which will be describe later, and show that if we encode 
 according to the modified level order, we can encode 
 at most 4n bits, by skipping the redundant nodes during the traversal.

Modified level-order For two nodes 
 with label 
 and 
 with label 
 which satisfy 
 and 
, we say the node 
 precedes the node 
 if 
. Now, let q be one of the parents of the node p with label 
 (note that a node can have multiple parents in a DAG). Note that , since 
 contains all the answers of  except one or both positions from the column  or from the column . Also let 
 and 
 be the number of positions in  on the first and the second row respectively. Now we consider the following two cases:

Case 1 ( = 1): In this case, the positions of  are already contained in the answers of , and the k-th largest element in  is either the 
-th largest element in 
 or the 
-th largest element in 
 (we call them as first-candidates at node p).

Case 2 ( = 2): In this case, the positions of  are already contained in the answers of , and the -th largest element in  is the one of the the first-candidates at node p. Now suppose -th largest element in  is on the first row (the other case is analogous). Then again, the k-th largest element in  is on the one of the positions of 
-th largest element in 
 and 
-th largest element in 
 (we call them as second-candidates at node p).

Note that if 
 and 
 are given, the first and second-candidates at node p can be found using the  encodings of 
 and 
. Figure 2 shows the overall procedure of modified level-order. While traversing the nodes of 
 in the modified level order, we classify the nodes as visited, half-visited, or unvisited. All the nodes are initially unvisited, and the traversal continues until all the nodes in 
 are visited. For example, we traverse the nodes of 
 in Fig. 1 as:  (here each node is denoted as its label).

Fig. 2
figure 2
Modified level-order traversal of 

Full size image

Picking the positions For a node 
, p picks the position (x, y) if (i) (x, y) is among the  positions of p, and (ii) this information (that (x, y) is among the answers to  query) does not follow from the  positions of any of the visited or half-visited before p in the modified level-order. By storing the information of all picked positions at node p, we can answer  by combining the answers of  positions of some visited or half-visited nodes before p.

When the traversal starts at the root node of 
, the root node picks the positions of k-largest values among the answers of 
 and 
 queries, and theses positions can be indicated using k bits, since we assume that  encodings of 
 and 
 are given.

Next, suppose we visit an unvisited non-root node p where , where q is a parent of p (note that q is always visited before p in modified level order). In this case, since we can answer the positions of  largest elements in A using , p picks at most one position, which is among the first-candidates at p. Thus, we can store the picked position at node p using one extra bit. The case when  can be handled similarly, other than p picks at most two positions (one from the first-candidates and another from the second-candidates), and this information can be stored using at most two extra bits. The following lemma shows that the size of 
 is O(kn), which in turn gives a simple O(kn)-bit space bound by storing the information of all the picked positions at each node of 
.

Lemma 2
Given  array A and DAG 
, there are at most 6kn nodes in 
.

Proof
It is enough to show that there are at most 2kn non-leaf nodes in 
. Let 
 be a set of labels of t non-leaf nodes 
 in 
 where all the nodes 
 picks .

Now we claim that t is at most k. To prove a claim, suppose .

Then it is clear that for any 
, 
 and 
 by the modified level-order traversal of 
. Therefore without loss of generality, assume that 
. Also we can easily show that for , there is a position at 
-th column whose corresponding value is larger than 
 by the construction algorithm of 
. Therefore for , the node 
 has k positions at 
-th columns which have larger values than both , contradicts to the fact that 
. 

We now describe how to make the space usage of our encoding to be independent of k - from O(kn) to O(n). Suppose there exists two non-root nodes p and q in 
 where the first (or second) candidates of p are contained in q, and the candidates of p and q are not distinct. In this case, the modified level order always visits q prior to p, and gives a ‘chance’ not to pick any position at node p, although q is not an ancestor of p. Using this property, we now prove the following lemma, which bounds the size of our encoding by showing that if we store the all picked positions according to the modified level order, we can encode 
 in space independent to k.

Lemma 3
Given  array  and DAG 
 , any position in A is picked at most twice while we traverse all nodes in 
 in the modified level order.

Proof
Suppose that a position (i, j) is among the answers of  query on the t distinct nodes 
 where 
 for , but not among the answers of  query on their parent nodes. For  if 
 is an ancestor of 
, we don’t pick (i, j) at the node 
 by the modified level order traversal algorithm (Note that 
 is traversed before 
). Therefore without loss of generality, we assume that for all , 
 and 
. Now we claim that for every position (i, j) in A, at most two nodes from 
 pick (i, j).

To prove the claim, for , suppose there exists three nodes 
, 
, and 
 where all of these three nodes picks (i, j), and let 
 be the another (first or second)-candidate of 
. Then by the modified level-order traversal algorithm we do not pick (i, j) at 
 (note that 
 or 
), which contradicts the assumption. 

For example, during the traversal of 
 in Fig. 1 according to modified level order, the position(s) picked at each node are: , respectively ( indicates that no position is picked). Now we prove our main theorem.

Theorem 3
Given a  array A, if there exists an S(n, k)-bit encoding to answer sorted 2-sided  queries on a 1D array of size n in T(n, k) time and such encoding can be constructed in C(n, k) time, then we can construct an encoding of A that uses  bits which can be constructed in 
 time, for answering  queries on A.

Proof
For , we first use 2S(n, k) bits to support sorted 2-sided  and  queries. To answer  queries, from Lemma 1(iii), we note that it is enough to encode the answers to the sorted  queries corresponding to all the nodes in 
. We encode these answers into a bit string X while traversing the DAG 
 as follows. When the traversal begins at the root, X is initialized to a k-bit string, which stores information for answering  query (namely, the i-th bit stores 0 or 1 depending on whether the i-th largest element in the range comes from the top or bottom row, respectively). Now we traverse 
 in the modified level order from the root node. Whenever we find a node p in Step (2) of the traversal algorithm described above, and if we pick a position (x, y) at node p, we append a single bit to X to find the answer from p’s first (or second) candidate.

Note that we can find such p in O(kn) time by the Lemma 2 and find the first (or second) candidates of node p in  time using the encoding of  queries on individual rows and pre-visited nodes other than root node, which takes  time. Finally we can check whether one of the position in the first (or second candidates) of p is picked at node p or not in O(n) time. Therefore whenever we traverse node p,  time is sufficient for encoding a bit in X to find the answer of  query. Since we traverse any node at most twice in the modified level order, and since 
 has at most 6kn nodes by Lemma 2, we can construct the encoding in 
 time in total. Also by Lemma 3,  after we traverse all the nodes in 
.

To decode answers of  queries corresponding to the nodes in 
 from X, we first construct the root and its children from the first k bits, and whenever we find a node p with label 
 in Step (2) of the traversal algorithm described above, we decode 
 when p is unvisited and , or p is half-visited and . Also we decode 
 when p is unvisited and . The positions in  with larger positions can be easily answered by the answer of  on the former traversed nodes. Now let (1, x) and (2, y) be the first or second candidates in such unvisited or half-visited node p, which can be found by 
 and 
.

If one of the candidates is already picked before at some node 
 (without loss of generality, assume that (1, x) is picked by 
) and 
, we can know  with no extra information. If there is no such node we read next 1 bit to decode. Since X is encoded in the modified level order, one can easily show that such bit is encoded for pick (i, j) at p. Therefore, we can encode to answer  queries at most 4n extra bits, if we can answer sorted 2-sided  queries on 
 and 
. 

For the special case when , the following theorem shows that the space bound of the encoding of Theorem 3 can be improved.

Theorem 4
Given a  array A, if there exists an S(n)-bit encoding to answer sorted 2-sided  queries on a 1D array of size n in T(n) time and such encoding can be constructed in C(n) time, then we can encode A in  bits using 
 time, for answering  queries on A.

Proof
It is enough to show that the bit string X, defined in the proof of Theorem 3, has length at most 3n when it is constructed under 
. We claim that after all nodes in 
 are traversed in modified level-order, i-th column is picked (i.e., any position in the i-th column is picked) at most three times for all , which proves the theorem.

To prove the claim, let f(i) (respectively, s(i)) be the position of the larger (respectively, smaller) element between (1, i) and (2, i), and suppose p with label 
 be the first node in the modified level order at which the position s(i) is picked for the first time. Then by the traversing algorithm and definition of 
, f(i) is already picked before s(i) is picked. This implies that  and the i-th column is not contained in all descendants of p (note that the labels of p’s children are  and  by the definition of 
). Also, we claim that s(i) is not picked at any other node 
 with label 
 where 
 and 
. To prove this, suppose that s(i) is picked at the node 
, and without loss of generality, 
 precedes the node p. Then by the definition of 
, the element in  is larger than 
 (note that the ancestor of p picks , to have p as descendant). This implies 
 and hence s(i) cannot picked at the node 
. Thus, s(i) is only picked once at the node p, and f(i) can be picked at most twice by Lemma 3, which implies any column is picked at most three times. 

From the encoding of Theorem 3, the following theorem shows that we can obtain an encoding for answering sorted 4-sided  queries on an  array by extending the encoding of a  array.

Theorem 5
Given an  array A, if there exists an S(n, k)-bit encoding to answer sorted 2-sided  queries on a 1D array of size n, then we can encode A in  bits, to support sorted 4-sided  queries on A.

Proof
For  and , we first use mS(n, k) bits to support sorted 2-sided  queries. Also we encode the answer 
 queries on  array 
, whose first and second row are a-th and b-th row in A respectively. By Theorem 3, we can encode such queries on all possible 
 arrays using  extra bits. For  and , let 
 be the position of -th largest element in  Note that we can find such 
 using  query.

Now we describe how to answer  query. We first define  values 
 and set 
. After that, we find a position of largest value in  by comparing 
 and find a position with largest element among them. It is clear that for 
, we can compare values at the position 
 and 
 using 
 query since at least one of the their corresponding positions in 
 is an answer of 
 query. Suppose for 
, 
 a position with the largest value in . Then we increase 
 by 1, and compare 
 and 
 again to find a position of the second largest value in . We do this procedure iteratively until we find a position of k-th largest value in . 

Corollary 1
Given an  array A, if there exists an S(n)-bit encoding to answer sorted 2-sided  queries on a 1D array of size n, then we can encode A in  bits, to support sorted 4-sided  queries on A.

Finally, if we combine the encoding of Theorem 5 and Gawrychowski and Nicholson’s 
-bit optimal encoding for sorted 2-sided  queries on a 1D array [9], we obtain an encoding as follows.

Corollary 2
Given an  array A, there exists an 
-bit encoding, to support sorted 4-sided  queries on A. Also when , there exists an 
-bit encoding, to support sorted 4-sided  queries on A.

Data Structure for 4-Sided  Queries on  Array
The encoding of Theorem 3 shows that 4n bits are sufficient for answering  queries whose range spans both rows, when encodings for answering sorted 2-sided  queries for each row are given. However, this encoding does not support queries efficiently (takes 
 time) since we need to reconstruct all the nodes in 
 to answer a query (in the worst case). We now show that the query time can be improved to 
 time if we use  additional bits. Note that if we simply use the data structure of Grossi et al. [11] (which takes  bits to encode a 1D array of length n to support  queries in O(k) time) on the 1D array of size 2n obtained by writing the values of A in column-major order, we can answer  queries on A in O(k) time using  additional bits. Although our data structure takes more query time and takes asymptotically more space, it uses less space for small values of k (note that  for all integers ) when n is sufficiently large. We now describe our data structure.

Fig. 3
figure 3
, 
, 
, 
, and 
 to support  queries on  array A

Full size image

We first define a graph 
 on A as follows. The set of vertices 
, and there exists an edge 
 if and only if (i)  and , (ii) there are at most  positions in  whose corresponding values are larger than both A[1][i] and A[2][j], and (iii) there is no vertex 
 where 
 and satisfies the condition (ii). We also define a graph 
 on A which is analogous to 
, by replacing A[1][i], A[2][j] and 
 with A[2][i] A[1][j], and 
, respectively in all three conditions. Each of the graphs 
 and 
 have n vertices and at most n edges. Also for any vertex 
 (resp., 
), there exists at most one vertex 
 in 
 (resp., 
) such that v is incident to 
 and 
. See Fig. 3 for an example. We now show that 
 (thus, also 
) is a k-page graph, i.e. there exist no  edges 
 such that 
.

Lemma 4
Given  array A, a graph 
 on A is k-page graph.

Proof
Suppose that there are  edges 
 such that 
, and for , let 
 be a position of the minimum element in 
. Then by the definition fo 
, there are at least k positions 
 in 
 whose corresponding values in A are larger than both 
 and 
, which contradicts the definition of 
. 

From the above lemma and the succinct representation of k-page graphs of Munro and Raman [18] (with minor modification as described in [8]), we can encode 
 and 
 using  bits in total, and for any vertex v in 
, we can find a vertex with the largest index which incident to v in O(k) time. Also to compare the elements in the same column, we maintain a bit string 
 of size n such that for , 
 if and only if . Finally, for 
 (resp., 
), we maintain another bit string 
 (resp., 
) such that for , 
 (resp., 
) if and only if all elements in 
 (resp., 
) are smaller than A[1][i] (resp., A[2][i]) (see Fig. 3 for an example). We now show that if there is an encoding which can answer the sorted  queries on each row, then the encoding of 
, 
, and the additional arrays defined above are enough to answer 4-sided  queries on A.

Theorem 6
Given a  array A, if there exists an S(n, k)-bit encoding to answer sorted 2-sided  queries on a 1D array of size n in T(n, k) time, then there is a -bit data structure which can answer  queries on A in 
 time.

Proof
For , we first use 2S(n, k) bits to support sorted 2-sided  and  queries in T(n, k) time.

To answer  query, we maintain succinct representations of 
 and 
 [8, 18] using  bits, and 
, 
, and 
 using 3n bits. Now for , let 
 (resp., 
) be the position of the p-th largest value in 
 (resp., 
), which can be answered in O(T(n, k)) time using the encoding of  queries on each row.

We first find the position of the largest value in  by comparing 
 and 
. If 
(resp.,
), we compare 
 with 
 (resp., 
 with 
) to find the position of the second-largest value in . By repeating this procedure iteratively k times, we can answer the  query.

Now we describe how to compare 
 with 
, for all  (in the above procedure, we do not need to compare 
 with 
 if ). If 
, the result of the comparison is already stored in the bit 
. Now suppose that 
 (if 
, we use 
 and 
 instead of 
 and 
 respectively, in the following procedure), and let 
 be a vertex with the largest index in 
 which is incident to 
, if it exists. Note that we can find such 
 in O(k) time [8, 18]. If there is no vertex incident to 
 or 
, we show that 
 by considering the following two cases.

(i) 
: From the definition of 
, it follows that 
.

(ii) 
: In this case, (a) 
, but there are at least k positions in 
 whose corresponding values are larger than both 
 and 
 or (b) 
. However (a) cannot hold since there are at most  positions in 
 whose corresponding values are larger than both 
 and 
. Therefore 
.

Now consider the case 
. If 
, then 
 if and only if 
 by the definition of 
. If 
, we first compare 
 with 
. If 
, then 
 by the definition of 
. If not, (a) 
, but there are at least k positions in 
 whose corresponding value is larger than both 
 and 
, or (b) 
. However, (a) cannot hold by the same reason as the case when there is no vertex incident to 
 or 
, and 
. Therefore 
 if 
. Also since 
 is one of the answers of 
 query, we can compare 
 with 
 in T(n, k) time using the  encoding on the second row. By the procedure describe above, each iteration step takes at most  time, thus we can answer  query in 
 time. 

Lower Bounds for Encoding Range  Queries on  Array
In this section, we consider the lower bound on space for encoding a  array A to support unsorted 1-sided and sorted 4-sided  queries, when . Specifically for , we consider to lower bound on extra space for answering (i) unsorted  queries, assuming that we have access to the encodings of the individual rows of A that can answer unsorted 1-sided (or 2-sided)  queries, and (ii) sorted  queries, assuming that we have access to the encodings of the individual rows of A that can answer sorted 2-sided  queries. We show that for answering unsorted 1-sided queries on A, at least  (or ) extra bits are necessary, and for answering unsorted or sorted 4-sided queries on A, at least  extra bits are necessary.

For simplicity (to avoid writing floors and ceilings, and to avoid considering some boundary cases), we assume that k is even. (Also, if k is odd we can consider the lower bound on extra space for answering 4-sided  queries as the lower bound of extra space for answering 4-sided  queries—it is clear that former one requires more space.) For both unsorted and sorted query cases, we assume that all elements in A are distinct, and come from the set ; and also that each row in A is sorted in the ascending order. Finally, for , we define the mapping 
 if and only if .

Unsorted 1-sided Top-k query The following theorem gives the lower bound for answering unsorted 1-sided  queries on  array A, when the encodings for answering unsorted 1-sided (or 2-sided)  queries on both rows are already given. Note that this lower bound also gives the lower bound for answering unsorted 4-sided  queries on  array under the same condition.

Theorem 7
Given a  array A and encodings for answering unsorted 1-sided (or 2-sided)  queries on both rows in A, at least  additional bits are necessary for answering unsorted 1-sided  queries on A.

Proof
If  we do not need any extra space since all positions are answers of unsorted  queries for . Now suppose that . In this case, let 
 be a set of all possible arrays of size  which satisfies the following properties:

For any 
, all of  are in  and each row in B is sorted in the ascending order (thus, all the arrays in 
 have same encodings for answering unsorted 1 and 2-sided  queries on their individual rows), and

for any two distinct arrays 
, there exists  such that 
.

By the definition of 
, for any  and two distinct arrays 
, there exists a position  where B and C have distinct answers of unsorted  queries, which implies 
 gives the lower bound of additional space for answering the 1-sided  queries on  array. We compute the size of 
 as follows. 
 since there exists only one case as 
. For , we can consider three cases as (1, 2, 3, 4), (1, 3, 2, 4), or (1, 4, 2, 3) if we write a elements of B[1, 2][1, 2] for 
 in row-major order (note that each row is sorted in ascending order).

Next, consider the case when . In this case for any 
, 
. To construct arrays in 
, we construct a set 
 from the array in 
 such that for any 
 and , 
 and 
. It is clear that 
. Now we consider two cases as follows.

Case 1. 
 and 
 are in different rows: In this case, for any 
 the position of the first and the second largest value in  are  and  respectively and for any 
, 
 are distinct. In this case, 
 since only , , or  can be 
 for any array 
 respectively, which satisfy the above condition and maintaining both rows in C as sorted in ascending order. Furthermore, since both 
 and 
 are in -th column, the number of 
 in this case is 
.

Case 2. 
 and 
 are in the same row: Without loss of generality, assume that both 
 and 
 are in the first row. Then for any 
 the position of the first and the second largest value in  are  and  respectively, and for any 
, 
 are distinct. Therefore 
 in this case since only  or  can be  for any array 
 respectively which satisfy the above condition and maintaining both rows in C as sorted in ascending order. Also since all the B is in the Case 1 or 2, the number of 
 in this case is 
.

By the statement described above, we obtain a recursive relation 
. By solving the recursive relation using characteristic equation, we obtain 
, which proves the theorem. 

Sorted and 4-sided  query In this case we divide a  array A into 2n/k blocks 
 of size  as for , 
 and all values of 
 are in . Then for any  array A and 
, sorted 
, and 
, if there exists a position  where 
. Let 
 be the set of all possible arrays of size  such that for any 
, all values of B are in  and both rows of B are sorted in ascending order, which implies all the arrays in 
 have same encodings for answering unsorted and sorted 2-sided  queries on their individual rows. Since the size of 
 is same as central binomial number, 
, which is well-known as at least 
 [16]. Therefore, at least 
 additional bits are necessary for answering sorted  queries that span both the rows, when encodings for answering sorted (or unsorted) on both rows are given.

Theorem 8
Given a  array A , at least  additional bits are necessary for answering sorted 4-sided  queries on A if encodings for answering sorted (or unsorted) 2-sided  queries on both rows in A are given.

Conclusions and Open Problems
In this paper, we proposed encodings for answering  queries on 2D arrays. For  arrays, we proposed upper and lower bounds on space for answering sorted and unsorted 4-sided  queries. Finally, we obtained an 
-bit encoding for answering 4-sided sorted  queries on  arrays. We end with the following open problems:

Can we support 4-sided sorted  queries with efficient query time on  arrays using less than  bits when ?

Can we obtain an improved lower or upper bound for answering 4-sided sorted  queries on  arrays?

Notes
We use  to denote 
.

, i.e., an entropy of the binary string whose density of zero is x

Brodal et al. [4] also give another structure to answer sorted  queries, with the same time and space bounds.