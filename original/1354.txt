The Terrain Guarding problem is a well-known variant of the famous Art Gallery problem. Only second to Art Gallery, it is the most well-studied visibility problem in Discrete and Computational Geometry, which has also attracted attention from the viewpoint of Parameterized complexity. In this paper, we focus on the parameterized complexity of Terrain Guarding (both discrete and continuous) with respect to two natural parameters. First we show that, when parameterized by the number r of reflex vertices in the input terrain, the problem has a polynomial kernel. We also show that, when parameterized by the number c of minima in the terrain, Discrete Orthogonal Terrain Guarding has an XP algorithm.

Introduction
The (Continuous and Discrete) Terrain Guarding problem is a widely studied problem in Discrete and Computational Geometry. In particular, it is the most well-studied visibility problem except for the classic Art Gallery problem. Formally, a 1.5-dimensional terrain , or terrain for short, is a graph on vertex-set 
 where each vertex 
 is associated with a point 
 on the two-dimensional Euclidean plane such that 
, and for any , having 
 implies that either 
 or 
 (see Fig. 1); the edge-set of this graph is 
. In the two-dimensional Euclidean plane, let 
 be the horizontal ray starting from vertex 
 towards negative infinity, and 
 be the horizontal ray starting from 
 towards positive infinity. The region bounded by 
 and lying on and above T is called the region bounded by the terrain T. Note that the points lying on the terrain include the vertices 
, , as well as the points that lie on the edges in E. The Continuous Terrain Guarding problem takes as input a terrain and a positive integer k, and the objective is to decide whether one can place guards on at most k points on the terrain such that each point on the terrain is seen by at least one guard. When we say that a point p sees a point q, we mean that the line segment 
 
 lies in the region bounded by the terrain. Notice that the guards may be placed on points on the terrain that do not belong to V. The Discrete Terrain Guarding problem is defined similarly, with the requirement that the guards must be placed on vertices in V only, as well as that only each vertex in V must be guaranteed to be seen by at least one guard.

Fig. 1
figure 1
A terrain, where convex vertices are denoted by circles, reflex vertices are denoted by double circles, and edges are denoted by straight line segments. The set of reflex vertices sees all the vertices of the terrain

Full size image

One of the reasons why the Terrain Guarding problem and its numerous variants are important is because there is a wide variety of applications in the design of communication technologies such as cellular networks and line-of-sight transmission networks for radio broadcasting, as well as in coverage of highways, streets and walls with street lights as well as security cameras and natural terrain border security [3, 14]. In Discrete and Computational Geometry, the problem has its origin in 1995, when an NP-hardness proof was claimed by Chen et al. [7]. This proof was never completed and it took almost 15 years until King and Krohn [20] finally showed that this problem is indeed NP-hard. In between, the problem has received a lot of attention from the viewpoint of approximation algorithms. In 2005, Ben-Moshe et al. [3] obtained the first constant-factor approximation algorithm for Discrete Terrain Guarding. Subsequently, the approximation factor was gradually improved in [8, 13, 19], until a PTAS was proposed by Gibson et al. [16] for Discrete Terrain Guarding. Recently, Friedrichs et al. [14] showed that even the Continuous Terrain Guarding problem admits a PTAS.

A special case of Terrain Guarding that has received notable attention is Orthogonal Terrain Guarding, which was recently shown to be NP-hard [5]. Here, the terrain is orthogonal: for each vertex 
, , either both 
 and 
 or both 
 and 
. In other words, each edge is either a horizontal line segment or a vertical line segment, and each vertex is incident to at most one horizontal edge and at most one vertical edge (see Fig. 2 for two examples of orthogonal terrains). This problem is of particular interest to the algorithm design community as it provides more structure and therefore more positive results than Terrain Guarding [12, 17, 21, 22]. Although the PTASes designed in [14, 16] clearly work for the Orthogonal Terrain Guarding problem as well, studies on this particular variant of Terrain Guarding bring out interesting structural properties specific to this variant. For instance, in the work of Katz and Roisman [17] a relatively simple 2-approximation algorithm is described for Discrete Orthogonal Terrain Guarding. Recently, Lyu and Üngör [21] improved upon this result by developing a linear-time 2-approximation algorithm for Orthogonal Terrain Guarding. In [12, 22], restricted versions were studied under which Orthogonal Terrain Guarding can be solved in polynomial time.

With a satisfactory landscape of approximation results for Terrain Guarding, the focus shifted to parameterized variants of the problem. In fact, in their landmark paper [20] King and Krohn state that “the biggest remaining question regarding the complexity of Terrain Guarding is whether or not it is FPT”. Khodakarami et al. [18] introduced the parameter “the depth of the onion peeling of a terrain” and showed that Terrain Guarding is FPT with respect to this parameter. In [2], for the solution size k as parameter a subexponential-time algorithm for Terrain Guarding with running time 
 was given in both discrete and continuous domains. In the same paper, an FPT algorithm with running time 
 was presented for Discrete Orthogonal Terrain Guarding. We remark that a lower bound of 
 for the time complexity of any algorithm for Terrain Guarding under the Exponential Time Hypothesis (ETH) was claimed in the conference version [4] of [5], but the proof was said to be false and replaced by a lower bound of 
 under the ETH in [5].

The Parameters We consider two structural parameters. So far, the understanding of the parameterized complexity of Terrain Guarding has been very limited, and, more generally, exact (exponential-time) algorithms for any visibility problem are extremely scarce. All our results utilize new and known structural properties of terrains. The individual results make use of different methods in parameterized complexity, and thus show several ways of how the aforementioned structural properties can be exploited algorithmically. In particular, we show how the paradigm of parameterized complexity can successfully yield positive, non-trivial results in the context of visibility. We believe that our work will open the door for additional research of which structural properties of terrains, polygons and related input domains make them easy to solve, and which do not. For example, here we see that terrains somewhat close to being convex, or which has constantly many minima, can be efficiently guarded.

We first consider the number r of reflex vertices of the terrain as a parameter; reflex vertices are those whose incident edges create an angle strictly larger than 180 degree in the region bounded by the terrain (see Fig. 1);Footnote 1 all other vertices are convex vertices. It is known (and follows from, say, Theorem 1.5 of [23]) that if one places a guard on each of the reflex vertices of the terrain, then all points of the terrain are guarded. Hence, the parameterized instances of interest are those where , k being the intended solution size. Thus, r can be considered as a natural relaxation of parameterization by solution size (whose status is a longstanding open problem). Further, we believe that it is interesting in its own right, since having a small (but not necessarily a fixed constant) parameter r means that the terrain is close to being convex. For such terrains, our result (formally stated ahead) not only shows that the problem is solvable efficiently (by a parameterized algorithm) but also that, in fact, the entire terrain can be shrunk to be of small size (by a kernelization algorithm).

We would like to remark that for a closely related problem called Art Gallery, the problem has been studied with respect to the number of reflex vertices, inspired by the W[1]-hardness result of Bonnet and Miltzow [6] for the problem, when parameterized by the number of reflex vertices. In particular, Agrawal et al. [1] obtained that Art Gallery parameterized by the number of reflex vertices admits an FPT algorithm.

Fig. 2
figure 2
As illustration of c being arbitrary a larger or b smaller than k. In the terrains vertices are denoted by squares and edges by straight line segments. The red vertices are solution vertices, and the blue edges are the minima (Color figure online)

Full size image

The second structural parameter we consider is the number c of local minima (or minima for short) of the terrain, for orthogonal terrains. Recall that in the orthogonal terrains that we consider, every vertex is incident to at most one horizontal and at most one vertical edge. Then in an orthogonal terrain, a minimum is a horizontal edge whose y-coordinates are all the same as well as smaller than that of the (at most) two neighbours on either end (see the blue edges in Fig. 2). Notice that in an orthogonal terrain, except for possibly the first and the last vertices of the terrain, the minima occur in pairs of convex endpoints of horizontal edges (see Fig. 2).

It is to be noted that c, unlike r, cannot be related to k—it can be arbitrarily smaller or arbitrarily larger than k (as well as than r); see Fig. 2. We believe that in many naturally occurring terrains the number of minima is much smaller than the number of observable vertices (where the gradient of the terrain changes). Indeed, it is conceivable to have (e.g., on natural hills or artificial structures) a huge number of vertices with slight changes of slope, and only few that actually alter the current “trend” (of having increasing y-coordinates or decreasing y-coordinates) of the terrain, in which case c is small.

Our Contribution First, we consider the Discrete Terrain Guarding problem parameterized by the number r of reflex vertices. Then, an instance of the problem is denoted by (T, k, r), where the input terrain T has r reflex vertices, and the objective is to determine if there is a k-sized vertex guard set for guarding all vertices of the terrain. Parameterized by r, we obtain a polynomial kernel for Terrain Guarding:

Theorem 1
For an instance (T, k, r) of Discrete Terrain Guarding, in polynomial time we can find an equivalent instance 
 of the problem, where 
. Moreover, the problem admits a polynomial kernel, when parameterized by r.

Our algorithm exploits structural properties of consecutively appearing convex vertices to identify vertices sufficient to capture a solution. We also find vertices guarding which would imply that all vertices of the terrain are guarded. Then, roughly speaking, we remove useless vertices (and make their neighbors adjacent) to obtain an instance with 
 vertices. We remark that Theorem 1 also works for Continuous Terrain Guarding, by using an appropriate “discretization” as described in [14] (for details see Sect. 3).

We would like to note that the equivalent instance 
 with 
, obtained using the first statement in the above theorem does not directly imply a polynomial kernel for the problem, as the coordinates of the vertices of 
 may not be bounded by a (polynomial) function of r. Thus to obtain a polynomial kernel using the above instance, we will rely on the known (explicit) polynomial time reducibility among appropriate NP-complete problems.

Next, we consider Discrete Orthogonal Terrain Guarding parameterized by the number of minima, c, of the input orthogonal terrain. We design a somewhat tricky dynamic programming algorithm for it that belongs to XP. The membership in FPT remains open.

Theorem 2
Discrete Orthogonal Terrain Guarding parameterized by c can be solved in 
 time.

Preliminaries
For a positive integer k, we use [k] as a shorthand for . We use standard notation and terminology from the book of Diestel [10] for graph-related terms which are not explicitly defined here. We only consider simple undirected graphs. Given a graph H, V(H) and E(H) denote its vertex-set and edge-set, respectively.

Terrains Consider a terrain , where 
 and 
. We denote the ordering of vertices in T by 
. Moreover, for vertices 
, we write 
 if , and 
 if . We say that a subset of points P on the terrain sees a subset of points Q on the terrain if each point in Q is seen by at least one point in P. A subterrain of T is an induced subgraph of T over a set 
 of consecutive vertices in V with  (retaining the points associated with the vertices).

Proposition 1
(Order Claim [3]) For a terrain , consider four vertices 
, such that 
 sees 
, and 
 sees 
. Then, 
 sees 
.

Consider an orthogonal terrain . A minimum (resp. maximum) of T is a pair of consecutive vertices 
 of T, where , such that the following conditions are satisfied: i) 
, ii) if 
 exists, then 
 (resp. 
), and iii) if 
 exists, then 
 (resp. 
).Footnote 2 We denote the set of minima and maxima of T by  and , respectively.

Parameterized Complexity In Parameterized Complexity each problem instance is accompanied by a parameter k. A central notion in this field is fixed-parameter tractability (FPT). This means, for a given instance (I, k), solvability in time 
 where f is some computable function of k. A kernelization algorithm for a parameterized problem  is a polynomial time procedure which takes as input an instance (x, k), where k is the parameter, and returns an instance 
 such that  if and only if 
 and 
, where g is a computable function. In the above, we say that  admits a g(k)-kernel. If g(k) is a polynomial function, then the kernel is a polynomial kernel for . For more information on Parameterized Complexity we refer the reader to [9, 11].

Polynomial Kernel for Discrete Terrain Guarding
We design a polynomial kernel for Discrete Terrain Guarding when parameterized by the number of reflex vertices. The main goal will be to prove the next lemma, which is the first statement of Theorem 1.

Lemma 1
For an instance (T, k, r) of Discrete Terrain Guarding, in polynomial time we can compute an equivalent instance 
 of the problem, where 
.

We (again) remark that the above lemma does not direct imply a polynomial kernel for Discrete Terrain Guarding as it may not necessarily be possible to represent the coordinates of points in the resulting instance using bit-length proportional to a (polynomial) function of r. Thus to obtain a proof of Theorem 1, after proving Lemma 1, we will rely on (an explicit) two-step polynomial time reduction via the Dominating Set problem, exploiting the polynomial time reducibility among NP-complete problems, to obtain a proof of the theorem.

Now we focus on the proof of Lemma 1. Let  be an instance of Discrete Terrain Guarding. We will design three marking schemes that will mark at most 
 vertices. Roughly speaking, we will argue that there is a solution contained in the marked set of vertices, and guarding the marked vertices is enough to guard all the vertices. Our first marking scheme will be used to ensure that there is a solution that contains only marked vertices. Our second and third marking schemes will be used to ensure that it is enough to guard the marked vertices. Finally, to obtain the proof of Lemma 1, we construct a modified terrain by adding edges between “consecutive” marked vertices in the original terrain. We begin with some definitions and establish some useful properties regarding them, which will be helpful in proving the lemma.

Fig. 3
figure 3
An illustration of convex regions in a terrain and Marking Scheme II. The terrain has six convex regions 
, and the reflex vertices are double circled. The blue/red/green (dotted) lines/points/squares are the objects defined in Marking Scheme II. Also, the labelling of vertices and points are as defined in Marking Scheme II. We remark that for the pair of reflex vertices 
, the line segment 
 
 is blocked by the terrain (Color figure online)

Full size image

For a terrain 
, a convex region of 
 is a maximal subterrain of 
 where every vertex is a convex vertex (see Fig. 3). For a convex region C, the vertex set of C is denoted by V(C). A vertex in V(C) that is not one of the two (not necessarily distinct) endpoints is called an internal vertex of C. A partial convex region is a subterrain of a convex region C that contains at least one endpoint of C. We can also define internal vertices of partial convex regions as above. Notice that the ordering of vertices given by  (and ) naturally extends to an ordering of convex regions, as two convex regions do not have common vertices. Thus, hereafter we will use  (and ) to denote orderings among convex regions as well. In the following we state some useful observations regarding convex regions. The next observation follows from from the assumption that the end vertices of a terrain are reflex vertices.

Observation 3
The number of convex regions in T is at most .

Observation 4
Consider a convex region C in T with endpoints 
. For each 
,Footnote 3u sees 
.

Observation 5
Let C be a convex region in T with endpoints 
. Consider vertices  and , such that v sees u and 
 (resp. 
). Then v sees each vertex 
 such that 
 (resp. 
).

Proof
Consider the case when 
. (The other case can be proved by following similar arguments.) If 
, then the claim trivially follows. Thus we assume that 
. Consider 
, such that 
. If 
, then from Observation 4 it follows that v sees 
. Now we consider the case when 
. From Observation 4, 
 sees 
, by our assumption v sees u, and we have 
. Thus by the Order Claim (Proposition 1) we can conclude that v sees 
. 

We are now ready to state our first marking scheme. Intuitively speaking, this marking scheme is used to identify a set of vertices where we can always find a solution.

Definition 1
(Marking Scheme I) We create a subset 
 of vertices as follows.

1.
Add all the reflex vertices of T to 
.

2.
For each convex region C, add its two (not necessarily distinct) endpoints to 
.

3.
Consider an ordered pair of distinct convex regions 
 such that there is 
 that sees all vertices of 
. If 
 (resp. 
), let 
 be the largest (resp. smallest) vertex in 
 other than the endpoints of 
 that sees 
. Add 
 to 
.

4.
Consider a reflex vertex v and a convex region C with endpoints 
, such that 
 (resp. 
). Let f(C, v) be the largest (resp. smallest) vertex in C, other than the endpoints of C, that v sees. Add f(C, v) to 
.

The following observation easily follows from the above definition and Observation 3.

Observation 6
The number of vertices in 
 is bounded by 
.

In the next lemma we show existence of a solution (for a yes-instance) contained in 
.

Lemma 2
(T, k, r) is a yes-instance of Discrete Terrain Guarding if and only if there is a solution 
.

Proof
If some 
 is a solution for (T, k, r) then (T, k, r) is a yes-instance. Now suppose that (T, k, r) is a yes-instance. Consider a solution 
 for (T, k, r) that maximizes the number of vertices from 
 and is of minimum possible size. If 
, then we are done. Thus, we assume that there is 
. From Item 1 and 2 of Definition 1 we can obtain that v is neither a reflex vertex nor an endpoint of any convex region in T. Thus we assume that v belongs to a convex region, say C, with 
 as its endpoints.

We first consider the case when there is a convex region 
 such that: i) 
 contains a vertex that is seen by v and no vertex in 
, and ii) v does not see all vertices of 
. (Note that 
, from Observation 4.) Without loss of generality we assume that 
. (The other case can be argued symmetrically.) For the arguments that follow, please refer to Fig. 4a. Let 
 be the endpoints of 
. We will argue that 
 is a solution for (T, k, r). Clearly, 
. We will now argue that 
 sees each vertex in V. To prove the above, it is enough to show that for each , such that v is the only vertex in 
 that sees it, either 
 sees u, or we arrive at a contradiction to our assumption that v is the only vertex in 
 that sees u. Consider such a vertex u, and the following cases based on the position of u.

If , then from Observation 4, 
 sees u.

Now we consider the case when 
. We will show that 
 sees u, or arrive at a contradiction that u is seen only by v in 
. Recall that u sees v by our assumption and 
 sees 
 (Observation 4). Thus using the Order Claim (Proposition 1) on 
, we conclude that 
 sees u.

Finally, we consider the case when 
. As v does not see all vertices of 
 and 
, using Observation 5 we conclude that v does not see 
. As 
 is a solution, there is some 
 that sees 
. By Observations 4 and 5, respectively, if 
 or 
 then 
 sees all vertices in 
, which contradicts the choice of 
 to contain a vertex seen only by v and no other vertex in 
. Thus including the fact that 
, it must be the case that 
. From Observation 5 we obtain that v sees 
, and by assumption 
 sees 
. Thus, using the Order Claim for vertices 
, we obtain that 
 sees v. Next, as 
, 
 sees v, and 
 sees 
 (Observation 4 applied to C), using the Order Claim on 
 we obtain that 
 sees 
. Finally as 
, v sees u, and 
 sees 
, using the Order Claim on 
 we obtain that 
 sees u. The above contradicts that v is the only vertex in 
 that sees u. From the above discussion we can conclude that 
 is a solution for the instance (T, k, r), such that either 
, or 
 and 
. This contradicts the choice of 
.

Hereafter we assume that for any convex region 
, either v sees all the vertices in 
 or sees none of its vertices. Again our goal will be to find another solution 
 by modifying 
 so as to obtain a contradiction to the choice of 
. Towards the construction of 
, we start by constructing a set X as follows. For each reflex vertex  such that v is the only vertex in 
 that sees u, we add the vertex f(C, u) to X (see Definition 1). Similarly, for each convex region 
 such that v is the only vertex in 
 that sees all the vertices of it, add the vertex 
 to X. As 
 is a minimum sized solution, and hence a minimal solution, and 
, we obtain that . Let 
 be a vertex that is closest to v in (the path in) C. We assume that 
. (The case when 
 can be argued symmetrically.) For the arguments that follow, please refer to Fig. 4b. Let 
. Notice that either 
, or 
 and 
. Thus, like previously, if we argue that 
 is a solution to (T, k, r), then we will arrive at a contradiction to the choice of 
. Now we will show that 
 is a solution for (T, k, r). First, we show that for each reflex vertex that v sees, the vertex 
 sees it as well. Consider a reflex vertex u that is seen by v. If 
, then clearly, 
 sees u. Now we assume that 
. If 
, then by definition of f(C, u) and the fact that 
 we obtain that 
. As 
 sees 
 (Observation 4) and f(C, u) sees u, using the Order Claim on 
 we can obtain that 
 sees u. Next consider the case when 
 (also we have 
 and 
). In this case by definition of f(C, u) and the fact that 
, we obtain that 
. As v sees u and f(C, u) sees 
, we apply the Order Claim on 
 to obtain that 
 sees u.

Next, we show that for each convex region 
 that v sees (we are in the case when v sees all vertices of a convex region or none), the vertex 
 sees it as well. If 
, then clearly, 
 sees 
. Now we assume that 
. If 
 then 
 for each vertex 
. Then by definition of 
 and the fact that 
 we obtain that 
 for each vertex 
. As 
 sees 
 (Observation 4) and 
 sees 
, using the Order Claim on 
 for each vertex 
, we can obtain that 
 sees each 
. Next consider the case when 
. Then for each 
, 
 (also we have 
 and 
). In this case by definition of 
 and the fact that 
, we obtain that for each 
, 
. As v sees u and 
 sees 
, we apply the Order Claim on 
 to obtain that 
 sees u, for each 
. Thus, 
 sees 
. This concludes the proof. 

Fig. 4
figure 4
An illustrative example of the case study in Lemma 2. Here, v is an unmarked vertex in 
 that belongs to convex region C and 
, 
 are the endpoints of the convex region C. a 
 is a convex region with endpoints 
 and 
. A partial convex region 
 of 
 that includes 
 is seen by v. The other endpoint 
 is seen by a vertex 
. b Any convex region that has some vertex seen by v has all its vertices seen by v. The vertex 
 is as defined in Lemma 2. Given a reflex vertex u, the vertex f(C, u) is shown in the diagram

Full size image

Our next two marking schemes will help us identify vertices such that guarding them will be sufficient for any vertex subset to qualify as a solution. We remark that the ordering  (and ) of vertices of T naturally extends to the points that lie on the terrain. We will slightly abuse the notation and use  (and ) to also denote the ordering of points on T.

Definition 2
(Marking Scheme II) Consider an (unordered) pair of distinct reflex vertices 
 and let 
 be the line containing them (see Fig. 3). Let 
 
 (if it exists) be the maximal line segment with (possibly non-vertex) endpoints 
 and 
 that contains both u and 
, and is completely contained on or above T. Let 
 and 
 be the (not necessarily distinct from 
) vertices in V such that 
 (resp. 
) is the largest (resp. smallest) vertex in V, such that 
 (resp. 
). Add the vertices 
 and 
, and their (at most two) neighbors in T to 
. Similarly, let 
 (resp. 
) be the largest (resp. smallest) vertex in V, such that 
 (resp. 
). Add the vertices 
 and 
, and their neighbors in T to 
.

We design another simple marking scheme, which constructs a set of vertices 
 which marks the neighbors of the vertices in 
 (excluding vertices in 
).

Definition 3
(Marking Scheme III) For each 
 and 
, such that , add the vertex v to 
.

Observation 7
 is bounded by 
. Moreover, 
.

In the next lemma we show that guarding 
 is enough to guard T, and the guards can be selected from the set 
. (Although there is a solution contained in 
 from Lemma 2, we state the lemma a bit differently to simplify its usage later.)

Lemma 3
A set 
 of size at most k is a solution for the instance (T, k, r) of Discrete Terrain Guarding if and only if for each 
, there is some 
 that sees u.

Proof
In one direction, suppose there is 
 that is a solution for the instance (T, k, r). Then, clearly, for each 
, there is some 
 that sees u.

In the other direction, consider a set 
 of minimum size that sees each vertex in 
, and 
 maximizes the number of reflex vertices it contains. We will show that 
 is a solution for the instance (T, k, r). For the sake of contradiction, suppose that there is a vertex 
 that is seen by no vertex in 
. Since 
 contains all reflex vertices (see Definition 1) and 
 is guarded by 
, v must be a convex vertex. Let C be the convex region in T containing v. Let 
 be the largest vertex such that 
. Similarly, let 
 be the smallest vertex such that 
. From Item 2 of Definition 1, both 
 and 
 exist, and they must belong to the convex region C. Moreover, from Definition 3, we obtain that 
 (recall that 
, see Observation 7).

If there is a 
 such that 
 and 
 sees 
, then using Observations 4 and 5 we conclude that 
 sees v. Similarly, if there is 
, such that 
 and 
 sees 
, then we conclude that 
 sees v. From the above, we assume that there are vertices 
, such that 
, 
 sees 
, and 
 sees 
. We now consider the following cases based on whether or not 
 is a reflex vertex.

1.
Suppose 
 is a reflex vertex (see Fig. 5a). Since 
 sees 
 but not v, there must be a reflex vertex u, such that 
 and the line segment 
 intersects the subterrain 
 of C between 
 and v (containing these vertices). Hence 
 must contain a vertex from 
. As 
 is the largest vertex from 
 with 
, 
 has no vertex from 
 other than 
. But 
 and 
. This leads to a contradiction.

2.
Suppose 
 belongs to a convex region, say 
. By our assumption 
 does not see v, thus using Observation 4 we obtain that 
. Moreover, as 
, we have 
. Let 
 be the smallest reflex vertex such that 
, and 
 be the largest reflex vertex such that 
. Note that 
. We will show that 
 sees each vertex in 
. Moreover, either 
, or 
 and 
 contains strictly more reflex vertices that 
. The above would lead us to a contradiction to the choice of 
. Now we focus on showing that 
 sees each vertex in 
 (see Fig. 5b). Consider any 
. If 
 is seen by a vertex in 
, then clearly, 
 sees 
. If 
 or 
, then using Observation 4 we can obtain that 
 sees 
. Now we can assume that either 
 or 
. First consider the case when 
. As 
, 
 sees 
 (by assumption), and 
 sees 
 (Observation 4), using the Order Claim on 
 we obtain that 
 sees 
. Now we consider the other case, i.e., when 
. Recall that 
, and 
 sees 
 and 
 sees 
. Thus using the Order Claim on 
 we obtain that 
 sees 
. As 
, 
 sees 
, and 
 sees 
, using the Order Claim on 
 we obtain that 
 sees 
. Again, as 
, 
 sees 
, and 
 sees 
, using the Order Claim on 
 we obtain that 
 sees 
. This concludes the proof.


Fig. 5
figure 5
An illustrative example of the case study in Lemma 3. Here, 
 and 
 are the nearest marked vertices to v. The vertices 
 and 
 are seen by 
 and 
, respectively. a In Case 1, 
 is a reflex vertex that sees 
 but cannot see v because of a reflex vertex u. b In Case 2, 
 is a convex vertex and 
 is the smallest reflex vertex to the right of 
. Similarly, 
 is the largest reflex vertex to the left of 

Full size image

We define a new terrain 
 (see Fig. 6), where the coordinates of 
 remain the same as in T and the edge set 
 is defined as follows. Consider the restriction of the ordering, , of vertices in T to the vertices in 
. The set 
 contains an edge between every consecutive pair of vertices in 
, given by the above ordering. We have the following observations about the new terrain 
.

Fig. 6
figure 6
An illustrative example of deriving from terrain  shown in a the new terrain 
 shown in b. The vertices in 
 are denoted by boxes whereas unmarked vertices of V are denoted as circles

Full size image

Observation 8
A vertex is reflex in T if and only if it is a reflex vertex in 
.

Proof
Consider a reflex vertex v in T. By Definition 1, 
. We show that v is also a reflex vertex of 
. If v is the first or last vertex of T, then it is also the first or last vertex of 
 and therefore is a reflex vertex by definition. Otherwise, v has two neighbours, say 
 and 
. From Definition 1 we can obtain that 
. As the coordinates of 
 in T are the same as that in 
, we obtain that v is a reflex vertex of 
.

Now we show that a vertex 
 that is a convex vertex in T is also a convex vertex in 
. By definition, v cannot be the first or last vertex. Let 
 and 
 be the two neighbours of v such that 
. If 
, then as the coordinates of 
 in T are the same as that in 
, we obtain that v is also a convex vertex in 
. Otherwise, let 
 be the closest such vertex to v where 
. By definition of 
, such a vertex exists for all convex vertices v. Notice that it must hold that 
. Also by definition of 
, if 
 is a reflex vertex then 
 and 
. Similarly, let 
 be the closest such vertex to v where 
. By definition of 
, such a vertex exists for all convex vertices v. Notice that it must hold that 
. Again by definition of 
, if 
 is a reflex vertex then 
 and 
. Note that in 
, 
 and 
 are the neighbours of v such that 
. We are in the case that at least one of 
 and 
 holds. If 
 (
) is not a reflex vertex, by construction of 
 it must belong to the same convex region as 
 (
). By Observation 4, 
 sees v (
 sees v) and therefore 
 lies below or on the line 
 (
 lies below or on the line 
). Now consider 
 and 
 made inside the region bounded by T. It must be the case that 
. Thus, if v was a convex vertex in T then it means that in the region bounded by T 
. This implies that in the region bounded by 
 
, which means that v is a convex vertex of 
. 

Observation 9
Given two vertices 
, u sees v in T if and only if it sees v in 
.

Proof
For any 
 such the u sees v in T, each , such that  (or ) must lie below or on the line 
, containing u and v. In particular, each 
 such that  (or ) must lie below or on the line 
. Thus we can obtain that u sees v in 
.

Consider 
 such the u sees v in 
. Consider a  such that  (we can give a symmetric argument for ). If 
 then it must lie below or on the line 
. Otherwise, 
 and by construction of 
, w must be a convex vertex. Let 
 be the closest such vertex to w such that 
 in T. Similarly, let 
 be the closest such vertex to w such that 
 in T. Note that u, v are potential candidates for 
 and 
, respectively and that 
 in 
. By definition of 
, 
 all belong to a convex region C of T. By Observation 4, 
 sees 
 in T. Since 
, w lies below or on the line 
. Coming back to the fact that u sees v in 
 and 
, the line segment 
 must lie below or on the line segment 
. Putting everything together, we see that w lies below or on the line segment 
. Thus, u sees v in T. 

We are now ready to prove Lemma 1.

Proof of Lemma 1
We show that  is a yes-instance of Discrete Terrain Guarding if and only if 
 is a yes-instance of the problem. By Observation 8, the reflex vertices of T are reflex vertices of 
 and vice versa. Therefore, the number of reflex vertices in both T and 
 is r.

First, let (T, k, r) be a yes-instance of Discrete Terrain Guarding. Following from Lemma 2, there is a solution 
 of size at most k. In particular, 
 guards all vertices in 
. By Observation 9, 
 is a k-sized solution for 
 and therefore 
 is a yes-instance.

On the other hand, let 
 be a yes-instance of Discrete Terrain Guarding. Let 
 be a k-sized solution for 
. By Observation 9, 
 sees all vertices in 
 in the terrain T. Thus, by Lemma 3
 is a solution for (T, k, r) and therefore (T, k, r) is a yes-instance.

Moreover, we can construct 
 in polynomial time. Also from Observation 7 we have 
. This concludes the proof. 

We are now ready to prove Theorem 1.

Proof of Theorem 1
Let (T, k, r) be an instance of Discrete Terrain Guarding. Using Lemma 1, in polynomial time we compute an equivalent instance 
 of Discrete Terrain Guarding with 
.

We now construct an instance of Dominating Set (G, k) as follows. We let 
, and for ,  if and only if u and v see each other in 
. Clearly, (G, k) is a yes-instance of Dominating Set if and only if 
 is a yes-instance of Discrete Terrain Guarding. Moreover, (G, k) can be constructed in polynomial time. Now we can convert the instance (G, k) of Dominating Set in polynomial time to an equivalent instance of Discrete Terrain Guarding using the NP-hardness reduction from Dominating Set to Discrete Terrain Guarding. (This can be explicitly achieved for example, by a chain of polynomial time reductions Dominating Set 
 SAT 
 3-SAT 
 Planar 3-SAT 
 Discrete Terrain Guarding [5, 15, 20].) This concludes the proof. 

Remark Regarding Continuous Terrain Guarding We end this section with a note regarding extension of Theorem 1 for Continuous Terrain Guarding. Consider an instance 
 of Continuous Terrain Guarding, where r is the number of reflex vertices in T. Using the discretization result of Friedrichs et al. (Section 2, [14]), in polynomial time we can construct a terrain  by sub-dividing (possibly multiple times) edges of 
, and sets X, Y, where 
, such that the following condition is satisfied: (T, k, r) is a yes-instance of Continuous Terrain Guarding if and only if there is a set  of size at most k that sees each vertex in Y. Equipped with the above result, we can adapt our marking schemes to consider only vertices from Y while dealing with visibilities, and marking only vertices from X for potential guard set. Using this we can obtain an instance of a restricted (NP-complete) version of Discrete Terrain Guarding with 
 vertices in the terrain. Also by using NP-hardness of Continuous Terrain Guarding, we can obtain a polynomial kernel for the problem.

Algorithm for Discrete Orthogonal Terrain Guarding
We design a dynamic programming based algorithm for Discrete Orthogonal Terrain Guarding running in time 
, where n is the number of vertices in the input orthogonal terrain. Let (T, k) be an instance of Discrete Orthogonal Terrain Guarding. Intuitively speaking, in our algorithm the states for our dynamic programming table are chosen in relation to the minima of T as follows (see Fig. 8). We will maintain a height, on or above which we can place guards. With respect to our minima, we will define the notion of valleys. For each such “valley”, we will have a vertex on its “left slope” in our state of the table, and we would like to guard all the vertices of the valley that appear in the “left slope” and lie on or above this vertex. Similarly, we will have such vertices for the “right slopes”. Towards formalizing the above, we begin by introducing some notations and preliminary results that will be useful later.

Notations We let  and  denote the set of reflex and convex vertices of T, respectively. (For the sake of simplicity, we include the two endpoints of T in both  and ). In the following we state a well-known result from Claim 3.3 and 3.4 of [17], which states that guarding convex vertices of an orthogonal terrain using guards placed at reflex vertices is enough to guard the whole terrain. This property will be useful in our algorithm.

Proposition 2
[17] (T, k) is a yes-instance of Discrete Orthogonal Terrain Guarding if and only if there is  of size at most k such that S sees each vertex of .

Observation 10
For an orthogonal terrain T and vertices 
 and 
, if u sees v, then 
.

Next we will define the notion of valleys. Roughly speaking, a “valley” is a maximal region containing at most one minimum and at most two maxima. We will formally define the notion of valleys in an orthogonal terrain; our definitions will be formulated in a way to ensure uniqueness of the set of valleys in the given terrain (see Fig. 7).

Fig. 7
figure 7
An intuitive illustration of the set of valleys 
 and different vertices in an orthogonal terrain. (The sets are presented modulo the elements  and .)

Full size image

Definition 4
For an integer , the 
valley, denoted by 
 (with its vertex set denoted by 
), of the terrain T is an (ordered) set of consecutive vertices of T that contains the smallest vertex u that is not contained in any valley 
, where , and the following vertices.Footnote 4 Let  be the smallest integer (if it exists) such that 
 and 
. If a does not exist, then 
 contains all the vertices v where 
. Otherwise, 
 contains all the vertices v where 
.

We let 
 be the set of valleys in T. Notice that . For a valley 
 
, the vertices 
 and 
 denote the first and last vertices of 
, respectively. For the sake of notational convenience, we will now define left/right slope convex vertices. We say that 
 contains a minimum/maximum 
, if 
. Note that by definition, 
 can contain at most one minimum and at most two maxima. If 
 has one minimum, say 
, then the set of left slope vertices 
, is the set 
 and the set of right slope vertices 
, is the set 
. Otherwise, the vertices 
 have either non-increasing y-coordinates or non-decreasing y-coordinates. If 
 have non-increasing y-coordinates, then we have 
 and 
. Otherwise, 
 have non-decreasing y-coordinates, and we have 
 and 
. We let 
, 
, 
 (see Figs. 7, 8).Footnote 5 We let 
 be the largest vertex in 
. Similarly, we let 
 be the smallest vertex in 
. We will now define the set of heights H of guards in the terrain, which will be used in defining the states of our dynamic programming routine: . For , by  we denote the smallest element 
 such that 
. (For the largest element, say 
, we have 
.) Finally for , we let 
.

We state some useful observations that will be useful in our algorithm. We will move to the description of the states of our dynamic programming table after the stating few simple but useful observations below.

Observation 11
Consider . For a vertex 
, if 
 sees 
 and , then . Similarly, a vertex 
, if 
 sees 
 and , then .

Observation 12
Consider , and vertices 
, where 
. If 
 sees 
, where 
, and 
, then 
 sees 
.

We define the set of heights of guards in a valley, which will be useful in stating the states of our dynamic programming routine. For , we let 
. Moreover, for 
, by 
 we denote the smallest element 
 such that 
. (For the largest element, say 
, we have 
.) Finally for , we let 
.

We let 
, 
, 
 and 
. Furthermore, we let 
.

We are now ready to define the states of our dynamic programming algorithm. For each valley we will have the following in our dynamic programming states. Firstly, we have a pair of vertices from each valley, one from the left-side and other from the right-side of the valley. These two vertices tell us “what” vertices must be guarded (see Fig. 8 for an illustration). Intuitively speaking, we want to guard all the left (resp. right) convex vertices in the valley that are on or above the left-side (resp. right-side) vertex for this valley in the state of our dynamic programming table. Additionally, we have a number denoting the height, on or above which we are allowed to place the guards. Apart from these, we will have a number 
 denoting the number of guards that we are allowed to use in our “partial” solution.

Fig. 8
figure 8
An intuition of states of our dynamic programming algorithm

Full size image

States of the Dynamic Programming Table and Their Interpretation Consider 
 
, where for , 
, , and an integer 
. For each such triple we have an entry in our dynamic programming table denoted by 
. For interpreting 
, we will define 
; the goal of the algorithm will be to compute 
, so as to mimic 
, for every triple.

Definition 5
For 
 
, where for , 
, , and an integer 
, we have 
 if and only if there is a set  of size at most 
 such that the following conditions are satisfied (see Fig. 8):

1.
All the guards placed are at height at least h. That is, for each , we have .

2.
Each vertex in 
 that is 
 or above it, is seen by a guard in S. Similarly, each vertex in 
 that is 
 or above it, is seen by a guard in S. So, for each  and 
, such that either 
 or 
, there is  that sees u.

In the above, the set S is called a solution for 
.

Let 
, and 
, for each . (In the above, for , as 
 and 
, 
 and 
 can never be undefined.) From Proposition 2 we can obtain that (T, k) is a yes-instance of Discrete Orthogonal Terrain Guarding if and only if 
.

Order of Computation of Entries We describe the order in which we compute the entries of our dynamic programming table. We will use a modified form of “lexicographic” ordering for the table entries as follows. To this end we first describe how we order the vertices in the “left” and “right” sides of our valleys. For , the vertices in 
 are ordered as per the ordering given by T, whereas, the vertices in 
 are reverse ordered compared to the ordering given by T. (We need to do the above because when are going down the valley from right side, the vertices are decreasing.) We order the elements of H in decreasing order (with  being the first element in this ordering). Finally, the overall ordering is obtained by using (lexicographic) ordering of H, the ordering of vertices in 
, and the ordering of vertices in 
, with increasing values of i, and 
 (increasing).

Next we will describe how we (recursively) compute the entries of the table. Consider 
, where for , 
, , and an integer 
. We compute 
 as follows.

Base Cases The base cases occur in the following scenarios, applied in the given order.

1.
If for each , we have 
 and 
, then 
.

2.
If  and for some , 
 or 
, then 
.

3.
If  and for some , 
 or 
, then 
.

The correctness of the base cases directly follows from their description. Next we describe the recursive formula for computing the other entries of our dynamic programming table.

Recursive Formula Intuitively, we will compute an entry by taking “or” of the solutions for already computed entries, where the entries we query are based on where and at what vertices we place the lowest height guards in the partial solution.

Let 
. As Item 1 of Base Case is not applicable, we need to place at least one guard, thus we can obtain that . Notice that 
, as for each valley, we can have at most two vertices from  that are at height h. For every 
, we will compute 
, which (intuitively speaking) corresponds to the solution S for 
, where 
, i.e., A is the set of (vertex) guards at height h in the solution. (We will have 
 if and only if there is a solution S for 
 such that 
.)

We remark that , as the base cases are not applicable. Consider 
. If some  sees 
, then we let 
 be the largest vertex in 
 that is not seen by any vertex in A. (If 
 does not exists, it is set to .) Otherwise, no  sees 
, and we set 
. Similarly, if some  sees 
, we let 
 be the smallest vertex in 
 that is not seen by any . (If 
 does not exists, it is set to .) Otherwise, no  sees 
, and we set 
. Let 
. Finally, we let 
. Notice that 
 is smaller in order compared to , and thus the entry corresponding to it in our dynamic programming table is already computed. We let 
. Finally, we set 
.

Lemma 4
The recursive formula for computation of the entries is correct.

Proof
To establish the correctness it is enough to show that 
 if and only if there is 
, such that 
.

For the forward direction suppose that 
, and  be a solution for 
. We let 
 and 
. We will show that 
. We will show that 
, by proving that 
 is a solution for 
. As S is a solution for 
, for each , we have . The above together with the construction of 
 (and 
) implies that for each 
, we have , and 
. Now it remains to prove Item 2 of Definition 5, to show that 
 is a solution for 
. Consider . We will show that for each 
, such that either 
 or 
, there is some 
 that sees u. We will only prove the above statement for the case when 
. (We can obtain the proof for the case when 
, by following similar arguments.) Let 
 be the largest vertex such that 
 and u is not seen by any vertex in 
. (If such a vertex u does not exist, then the claim trivially follows.) Since S is a solution for 
 and (by construction) 
, there exists 
, such that s sees u. Furthermore, there is 
, where 
, such that 
 sees 
. From the above we can obtain that all of 
 are distinct and 
. From Observation 10 we have 
. This together with the fact that 
 implies that 
. If 
, then using Observation 12 we can conclude that 
 sees u. This contradicts the choice of u that no vertex in 
 sees it. Now consider the case when 
. In this case, using Observation 11 we can obtain that 
. Thus, we have 
. As 
, using Observation 10 we can obtain a contradiction to our assumption that  sees u. This concludes the proof of the forward direction.

Now we consider the reverse direction. Consider 
, such that 
 
, and let 
 be a solution for 
 
. Let 
. Clearly, 
, and for each , we have . Also, for , by the construction of 
 and 
, and the fact that 
 is a solution for 
, we can conclude that for each 
, such that either 
 or 
, there is  that sees u. From the above discussions we can obtain that S is a solution for 
, and thus we have 
. This concludes the proof. 

Note that t, the number of valleys, is bounded . The number of entries in our dynamic programming table is bounded by 
. The entries in our base cases can be computed in  time. The recursive formula per entry can be computed in time bounded by 
, as 
, for each . Thus we obtain the proof of Theorem 2.