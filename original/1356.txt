For a finite set V of elements, a confluent system is a set system (𝑉,⊆2𝑉) such that every three sets 𝑋,𝑌,𝑍∈ with 𝑍⊆𝑋∩𝑌 implies 𝑋∪𝑌∈, where we call a set 𝐶∈ a component. We assume that two oracles L1 and L2 are available, where given two subsets 𝑋,𝑌⊆𝑉, L1 returns a maximal component 𝐶∈ with 𝑋⊆𝐶⊆𝑌; and given a set 𝑌⊆𝑉, L2 returns all maximal components 𝐶∈ with 𝐶⊆𝑌. Given a set I of items and a function 𝜎:𝑉→2𝐼 in a confluent system, a component 𝐶∈ is called a solution (or support-closed) if the set of common items in C is inclusively maximal; i.e., ⋂𝑣∈𝐶𝜎(𝑣)⊋⋂𝑣∈𝑋𝜎(𝑣) for any component 𝑋∈ with 𝐶⊊𝑋. We prove that there exists an algorithm of enumerating all solutions in polynomial delay and in polynomial space. The proposed algorithm yields polynomial-delay and polynomial-space algorithms for enumerating connectors in an attributed graph (i.e., a graph such that each vertex is assigned items) and for enumerating all subgraphs with various types of connectivities such as all k-edge/vertex-connected induced subgraphs and all k-edge/vertex-connected spanning subgraphs in a given undirected/directed graph for a fixed k.

Introduction
In the present paper, we consider the enumeration problem in a set system called a confluent system [8, 19]. For a confluent system on a set of elements and a set of items (or attributes) given to each element, we design an algorithm that enumerates all subsets in the system that are inclusion-wise maximal with respect to the common items in a subset.

Let V be a finite set of elements. A system on a set V of elements is defined to be a pair (𝑉,) of V of elements and a family ⊆2𝑉, where a set in  is called a component. For a subset 𝑋⊆𝑉 in a system (𝑉,), a component 𝑍∈ with 𝑍⊆𝑋 is called X-maximal if no other component 𝑊∈ satisfies 𝑍⊊𝑊⊆𝑋, and let max(𝑋) denote the family of all X-maximal components. For two subsets 𝑋⊆𝑌⊆𝑉, let max(𝑋;𝑌) denote the family of components 𝐶∈max(𝑌) such that 𝑋⊆𝐶. We call a system (𝑉,) (or ) confluent if


 any  tuple  of  components 𝑋,𝑌,𝑍∈ with 𝑍⊆𝑋∩𝑌 implies 𝑋∪𝑌∈.

Examples of a confluent system include any Sperner family, a family of subsets every two of which intersect, and the family of ideals (i.e., downsets) in a partially ordered set. We will show that, given a graph and a positive integer k, the family of vertex subsets that induce k-edge/vertex-connected subgraphs is a confluent system; see Sect. 6.2 for the definition of k-edge/vertex-connectivity.

To discuss the computational complexities for solving a problem in a confluent system, we assume that a confluent system (𝑉,) is implicitly given as two oracles L1 and L2 such that

given non-empty subsets 𝑋⊆𝑌⊆𝑉, L1(𝑋,𝑌) returns a component 𝑍∈max(𝑋;𝑌) (or ∅ if no such Z exists) in 𝜃1,t time and 𝜃1,s space; and

given a non-empty subset 𝑌⊆𝑉, L2(𝑌) returns max(𝑌) in 𝜃2,t time and 𝜃2,s space.

We also denote by 𝛿(𝑋) an upper bound on |max(𝑋)|, where we assume that 𝛿 is a non-decreasing function in the sense that 𝛿(𝑌)≤𝛿(𝑋) holds for any subsets 𝑌⊆𝑋⊆𝑉.

We define an instance to be a tuple =(𝑉,,𝐼,𝜎) of a set V of 𝑛≥1 elements, a family ⊆2𝑉, a set I of 𝑞≥1 items and a function 𝜎:𝑉→2𝐼.   Let =(𝑉,,𝐼,𝜎) be an instance. The common item set 𝐼𝜎(𝑋) over a subset 𝑋⊆𝑉 is defined to be 𝐼𝜎(𝑋)=⋂𝑣∈𝑋𝜎(𝑣). A solution to instance  is defined to be a component 𝑋∈ such that


 every  component 𝑌∈ with 𝑌⊋𝑋 satisfies 𝐼𝜎(𝑌)⊊𝐼𝜎(𝑋). 

Let  denote the family of all solutions to instance .

Our aim is to design an efficient algorithm for enumerating all solutions in  when  is confluent in instance .

Following [18], we call an enumeration algorithm 

output-polynomial (or polynomial-total) if the overall computation time is polynomial with respect to the input and output size;

incremental-polynomial if the computation time between the ith output and the (𝑖−1)st output is bounded by a polynomial with respect to the input size and i; and

polynomial-delay if the delay (i.e., the time between any two consecutive outputs), preprocessing time and postprocessing time are all bounded by a polynomial with respect to the input size.

One sees that an incremental-polynomial algorithm is output-polynomial and that a polynomial-delay algorithm is incremental-polynomial (and thus output-polynomial).

To enumerate solutions for a given instance in a more flexible way, we introduce a new notion. We call a set function 𝜌 from 2𝑉 to the set ℝ of reals a volume function if 𝜌(𝑋)≤𝜌(𝑌) for any subsets 𝑋⊆𝑌⊆𝑉. A subset 𝑋⊆𝑉 is called 𝜌-positive if 𝜌(𝑋)>0. The proposed algorithm enumerates all 𝜌-positive solutions. We introduce the volume function to model numerical properties that are monotone with respect to set-inclusion. The examples of such properties include the set cardinality, a linear sum of profits/costs that are given to each vertex, and so on. The volume function enables us to enumerate solutions such that the property values are more than a given threshold, whereas we can enumerate all solutions by setting 𝜌(𝑆):=1>0 for all 𝑆⊆𝑉. Moreover, we will use the volume function as a tool to derive a theorem (Theorem 7). Given a volume function 𝜌, we assume that whether 𝜌(𝑋)>0 holds or not can be tested in 𝜃𝜌,t time and 𝜃𝜌,s space.

In this paper, we design an algorithm that enumerates all 𝜌-solutions in  by traversing a family tree over the solutions in . The family tree is one of the conventional techniques of enumeration (e.g., [5, 28]). It is a tree structure that represents a parent–child relationship among solutions and admits us to enumerate solutions by traversing the tree.

The following theorem summarizes our main result.

Theorem 1
Let =(𝑉,,𝐼,𝜎) be an instance on a confluent system (𝑉,), where 𝑛=|𝑉| and 𝑞=|𝐼|, and 𝜌:2𝑉→ℝ be a volume function. All 𝜌-positive solutions in  to the instance  can be enumerated in 𝑂(𝑞2𝛿(𝑉)𝜃1,t+𝑞𝜃2,t+𝑞𝛿(𝑉)𝜃𝜌,𝑡+𝑞2𝛿(𝑉)𝑛) delay and in 𝑂(𝑛𝜃1,s+𝑛𝜃2,s+𝑛𝜃𝜌,s+𝑛2+𝑞𝑛) space.

The theorem indicates that, when 𝜃1,t, 𝜃2,t, 𝜃𝜌,t and 𝛿(𝑉) are bounded by a polynomial of n and q, all solutions are enumerable in polynomial-delay. Similarly, when 𝜃1,s, 𝜃2,s and 𝜃𝜌,s are bounded by a polynomial of n and q, the enumeration can be done in polynomial space with respect to the input size. Our algorithm in Theorem 1 is a framework that can be applied to some enumeration problems over graphs, as will be discussed in Sects. 6 and 7.

The paper is organized as follows.

In Sect. 2, we describe the research background.

In Sect. 3, we prepare terminologies and notations.

In Sect. 4, we present a family-tree based algorithm that enumerates all solutions in a given instance, along with computational complexity analyses. We also show that the algorithm can be used to enumerate all components in the confluent system of the instance.

The proposed algorithm can be applied to several problems of enumerating subgraphs that satisfy certain connectivity conditions over a given graph. In Sect. 5, we show how to construct a confluent system from a given weighted/unweighted mixed graph so that each component in the resulting system corresponds to a required subgraph.

In Sect. 6, we mention a significant application of our algorithm to the connector enumeration problem. We show that our algorithm yields a polynomial-delay algorithm for the problem even when we require stronger connectivity conditions such as k-edge/vertex-connectivity.

In Sect. 7, we obtain polynomial-delay algorithms that enumerate all k-edge-connected (resp., k-vertex-connected) induced subgraphs and that enumerate all k-edge-connected (resp., k-vertex-connected) spanning subgraphs in a given undirected or directed graph for any k (resp., a fixed k), applying the component enumeration algorithm.

Finally Sect. 8 makes some concluding remarks.

Background
In this section, we first mention our motivation on this work (Sect. 2.1). We focus on a confluent system in this paper, while various set systems have been treated in the literature of the enumeration problem. We provide representative ones and their definitions (Sects. 2.2 and 2.3). We then explain related work, difference from ours (Sect. 2.4) and the difficulty in confluent systems (Sect. 2.5). Finally in Sect. 2.6, we describe some application examples of the proposed algorithm.

Motivation
Connector Enumeration Problem
Assume that we are given a tuple (𝐺,𝐼,𝜎) with an undirected graph G, a set I of items, and a function 𝜎:𝑉(𝐺)→2𝐼. For a subset 𝑋⊆𝑉(𝐺), let G[X] denote the subgraph induced from G by X, and 𝐼𝜎(𝑋) denote the common item set ⋂𝑢∈𝑋𝜎(𝑢). A subset 𝑋⊆𝑉(𝐺) such that G[X] is connected called a connector, if for any vertex 𝑣∈𝑉(𝐺)∖𝑋, 𝐺[𝑋∪{𝑣}] is not connected or 𝐼𝜎(𝑋∪{𝑣})⊊𝐼𝜎(𝑋); i.e., there is no proper superset Y of X such that G[Y] is connected and 𝐼𝜎(𝑌)=𝐼𝜎(𝑋).

The problem of enumerating all connectors is called the connector enumeration problem in the literature [13, 14, 25, 30]. Figure 1 illustrates a brief example of an instance of the connector enumeration problem.

Fig. 1
figure 1
An instance of the connector enumeration problem: it has connectors {𝑣1}, {𝑣4}, {𝑣1,𝑣2}, {𝑣1,𝑣3}, {𝑣1,𝑣2,𝑣3}, and {𝑣1,𝑣2,𝑣3,𝑣4}, where an item is represented by an integer

Full size image

A tuple (𝐺,𝐼,𝜎) is called a graph with an item set, or an attributed graph, and is useful to represent many existing networks such as social networks and biological networks [7]. Some papers in the literature have reported applications of the connector enumeration problem in biology. Seki and Sese [29] considered a biological network such that a vertex corresponds to a gene and an edge represents a protein–protein interaction between genes. A gene produces RNAs under a certain condition, and the phenomenon is called gene expression. A condition at which gene expression occurs is given to a vertex as an item. A biologist is particularly interested in a large-sized connector with a large common item set, that is, a large connected set of genes that make expressions simultaneously under common (possibly complex) conditions.

More recently, Alokshiya et al. [4] proposed a new algorithm for enumerating all connected induced subgraphs (CISs) of a given (non-attributed) graph. They applied the algorithm to find maximal cohesive patterns in BIOGRID protein-protein interaction network [10], where a maximal cohesive pattern is defined as a connector that is maximal among those X satisfying |𝐼𝜎(𝑋)|≥𝜃 for a threshold 𝜃.

Related Studies
The connector enumeration problem is a generalization of the frequent item set mining problem [1], a well-known problem in data mining, such that G is a clique and a vertex corresponds to a transaction.

For an attributed graph, community detection [22] and frequent subgraph mining [17] are among significant graph mining problems. The latter asks to enumerate all subgraphs that appear in a given set of attributed graphs “frequently,” where the graph isomorphism is defined by taking into account the items. For the problem, gSpan [34] should be one of the most successful algorithms. The algorithm enumerates all frequent subgraphs by growing up a search tree. In the search tree, a node in a depth d corresponds to a subgraph that consists of d vertices, and a node u is the parent of a node v if the subgraph for v is obtained by adding one vertex to the subgraph for u.

For the connector enumeration problem, Sese et al. [30] proposed a gSpan-based algorithm, named COPINE. Okuno et al. [26, 27] and Okuno [25] studied parallelization of COPINE. The first polynomial-delay algorithm was introduced in [8]. Haraguchi et al. [13, 14] proposed an alternative output-polynomial algorithm, named COOMA, based on a dynamic programming method.

In the present paper, we study a generalization of the connector enumeration problem on a set system. The proposed method is applicable not only to the original connector enumeration problem but also to the case where the graph is mixed and/or stronger connectivity conditions are imposed on connectors.

Hereditary Property in Subgraph Enumeration
In the context of subgraph enumeration, we are often asked to solve the problem as follows; given a graph 𝐺=(𝑉,𝐸) and a graph property 𝜋, enumerate all subsets of V that induce a subgraph that satisfies 𝜋. Let 𝜋 denote the set of all vertex subsets of V that induce a subgraph that satisfies 𝜋. We call the system (𝑉,𝜋) induced by G and 𝜋. We call a graph property 𝜋 hereditary if, for any 𝑋⊆𝑌⊆𝑉, 𝑌∈𝜋 implies 𝑋∈𝜋. We call a graph property 𝜋 connected-hereditary if, for any 𝑋⊆𝑌⊆𝑉, 𝑋∈𝜋 holds whenever 𝑌∈𝜋 and G[X] is connected.

Set Systems
We review the following classes of set systems. A system (𝑉,) is called

accessible if any non-empty component 𝑌∈ contains an element 𝑎∈𝑌 such that 𝑌∖{𝑎}∈;

strongly-accessible if ∅∈ and any pair of components 𝑋,𝑌∈ with 𝑋⊊𝑌 admits an element 𝑎∈𝑌∖𝑋 such that 𝑋∪{𝑎}∈;

independent if every subset X of a component 𝑌∈ is a component in ; and

weakly-confluent if, for every three components 𝑋,𝑌,𝑍∈, 𝑍⊆𝑋∩𝑌 and 𝑍≠∅ imply 𝑋∪𝑌∈.

One can readily see that the above mentioned systems have the following relationships;

an independent system is strongly-accessible and a strongly-accessible system is accessible;

a confluent system is weakly-confluent;

a system induced by a graph and a hereditary property is independent; and

a system induced by a graph and a connected-hereditary property is strongly-accessible (Lemma 19 in [12]).

Moreover, if a system is confluent and accessible, then it is also strongly-accessible by the following Lemma 2.

Lemma 1
Let (𝑉,) be a confluent system. If ∅∈, then  is closed under union, that is, 𝑋,𝑌∈ implies 𝑋∪𝑌∈.

Proof
For arbitrary components 𝑋,𝑌∈, there is 𝑍⊆𝑋∩𝑌 such that 𝑍∈ since ∅∈. Then 𝑋∪𝑌 is a component by confluency. ◻

Let (𝑉,) be a system. For 𝑋,𝑌∈ with 𝑋⊆𝑌, we say that Y is accessible from X (or equivalently, X is accessible from Y) if there is an ordering on elements in 𝑌∖𝑋={𝑒1,…,𝑒𝑘} such that all of 𝑋∪{𝑒1}, 𝑋∪{𝑒1,𝑒2}, …, 𝑋∪{𝑒1,𝑒2,…,𝑒𝑘−1} and 𝑋∪{𝑒1,𝑒2,…,𝑒𝑘}=𝑌 are components.

Lemma 2
Let (𝑉,) be a system. If (𝑉,) is confluent and accessible, then it is strongly-accessible.

Proof
It suffices to show that, for any 𝑋,𝑌∈ with 𝑋⊆𝑌, Y is accessible from X.

Let 𝑌={𝑒1,𝑒2,…,𝑒𝑚} such that all of 𝑌𝑚:=𝑌, 𝑌𝑚−1:=𝑌∖{𝑒𝑚}, 𝑌𝑚−2:=𝑌∖{𝑒𝑚−1,𝑒𝑚}, …, 𝑌1:=𝑌∖{𝑒2,…,𝑒𝑚}={𝑒1} are components, where such orderings on the elements in Y surely exist by accessibility.

Then 𝑋∪𝑌1, 𝑋∪𝑌2, …, 𝑋∪𝑌𝑚 belong to  by Lemma 1 since the system is confluent and ∅∈ holds by accessibility.

The sequence of distinct subsets in 𝑋∪𝑌1, 𝑋∪𝑌2, …, 𝑋∪𝑌𝑚 indicates that Y is accessible from X. ◻

Figure 2 illustrates these relationships by a Venn diagram along with their concrete examples.

Fig. 2
figure 2
Venn diagram representing the relationships among representative set systems in the literature and their concrete examples

Full size image

Enumeration of Solutions in Other Set Systems
This paper proposes the first polynomial-delay and polynomial-space algorithm for enumerating all solutions in an instance such that the set system is confluent. Let us review related work.

Given a system (𝑉,), a function 𝜙:→ is a closure operator if the following three conditions hold for any 𝑋,𝑌∈: (extensibility) 𝑋⊆𝜙(𝑋); (monotonicity) 𝑋⊆𝑌 implies 𝜙(𝑋)⊆𝜙(𝑌); and (idempotence) 𝜙(𝜙(𝑋))=𝜙(𝑋). A component 𝐶∈ is closed if 𝐶=𝜙(𝐶) holds (i.e., C is a fixed point with respect to 𝜙). For given strongly-accessible (resp., accessible) system and closure operator, Boley et al. [8] (resp., Arimura and Uno [5]) developed a polynomial-delay algorithm for enumerating closed components. The algorithms assume a membership oracle that identifies whether a subset 𝑆⊆𝑉 is a member of  or not.

Suppose that an instance (𝑉,,𝐼,𝜎) is given. The instance is non-redundant if every element 𝑣∈𝑉 satisfies 𝜎(𝑣)⊊𝐼. For a component 𝐶∈, let us write by Sol(𝐶) a minimal solution 𝑋∈ such that 𝑋⊇𝐶. By Lemma 6 in [8], if (𝑉,) is weakly-confluent, Sol(𝐶) is unique for every 𝐶∈. A function 𝜙:→ is called a support closure operator if 𝜙(𝐶)=Sol(𝐶) holds for every 𝐶∈, where the existence of such 𝜙 is not trivial.

Boley et al.’s algorithm for enumerating closed sets [8] can be applied to enumeration of solutions in a given non-redundant instance (𝑉,,𝐼,𝜎) such that (𝑉,) is weakly-confluent and strongly-accessible. The essence of the application is summarized as follows.

There exists a support closure operator 𝜙:→ for the instance since (𝑉,) is weakly-confluent (Theorem 7 in [8]).

We can compute 𝜙(𝐶)=Sol(𝐶) for any 𝐶∈ in the manner of Lemma 6 in [8] since (𝑉,) is strongly-accessible.

Similarly, Arimura and Uno’s algorithm for enumerating closed sets [5] can be applied to enumeration of solutions in (𝑉,,𝐼,𝜎) such that (𝑉,) is weakly-confluent and accessible since, by Lemma 2, (𝑉,) is strongly-accessible.

The complexity of enumerating solutions in weakly-confluent and strongly-accessible (resp., weakly-confluent and accessible) systems is summarized in (A) (resp., (B)) of Table 1, where 𝜃m,t and 𝜃m,s denote the time and space complexities of the membership oracle, respectively, and 𝑤=max𝐶∈|𝐶| denotes the largest size of a component. The complexity of the proposed algorithm is presented as (C) in the table.

Table 1 Complexity of enumerating solutions in (𝑉,,𝐼,𝜎) for various systems (𝑉,), where 𝑛=|𝑉|, 𝑞=|𝐼|, and 𝑤=max𝐶∈|𝐶|
Full size table

Difficulty in Confluent System
The above mentioned algorithms make use of accessibility in searching the family . In an accessible system (and thus also in a strongly-accessible system) (𝑉,), for every component 𝐶∈, there is 𝑣∈𝑉∖𝐶 such that 𝐶∪{𝑣} is a component or is 𝑣′∈𝐶 such that 𝐶∖{𝑣′} is a component. We can proceed the search by moving to one of such components, where we can identify whether a subset of V is a component or not by using the membership oracle.

A confluent system does not have such accessibility. For example, we consider a system (𝑉,𝜋) induced by the graph in Fig. 3 and the graph property 𝜋 “the induced subgraph is 2-edge-connected”. The 2-edge-connectivity is an elementary notion in graph theory. See Sect. 6.2 for the definition. We have 𝜋={{𝑣4,𝑣5,𝑣6,𝑣8},𝑉∖{𝑣5},𝑉∖{𝑣8},𝑉}. We see that the component {𝑣4,𝑣5,𝑣6,𝑣8} is not accessible from any other components.

Fig. 3
figure 3
A 2-edge-connected graph 𝐺=(𝑉,𝐸) such that vertex subsets {𝑣4,𝑣5,𝑣6,𝑣8}, 𝑉∖{𝑣5} and 𝑉∖{𝑣8} induce 2-edge-connected subgraphs

Full size image

Due to the lack of accessibility, we assume stronger oracles in this work, that is L1 and L2. By the term “strong”, we mean that the membership oracle can be realized by L2 since we can decide 𝑆∈ or not for 𝑆⊆𝑉 by whether L2(𝑆) returns {𝑆} or not although the proposed algorithm does not use L2 as the membership oracle explicitly. L1 appears to be redundant since L1 can be realized by using L2. Nevertheless we use the two oracles in order to make the analyses clearer.

Our assumption on oracles appears to be unrealistic since enumeration of maximal subsets with respect to a certain property is usually non-trivial and has been a significant research issue itself [11, 12, 21]. For some graph properties related to connectivity, however, it is possible to implement the oracles so that the time and space complexities are polynomially bounded. This will be discussed in Sects. 6 and 7.

As an extension of this work, Haraguchi and Nagamochi [16] recently provided an algorithm for enumerating solutions to a given instance (𝑉,,𝐼,𝜎) using L1 and L2 oracles, where (𝑉,) is an arbitrary system. The complexity of this algorithm is presented as (D) in Table 1.

Let us discuss the time complexities in Table 1. An algorithm that is applicable to some set system is comparable to another algorithm that is applicable to a larger set system (i.e., a superset in the Venn diagram). It is expected that the former should be faster than the latter since the former possibly makes use of stronger conditions peculiar to the smaller system. In fact, we see that (A) achieves a better bound than (B) and that (C) achieves a better bound than (D). It is not trivial to compare (A) and (B) with (C) and (D) since the used oracles are different. For example, under an assumption of 𝜃1,t=𝜃2,t=𝑂(𝑛𝜃m,t), 𝜃𝜌,t=𝑂(1), 𝑞=𝑂(𝑛), 𝛿(𝑉)=𝑂(𝑛) and 𝑤=𝑂(1), the time complexities of (A), (B), (C) and (D) are 𝑂(𝑛3𝜃m,t), 𝑂(𝑛3𝜃m,t), 𝑂(𝑛4𝜃m,t) and 𝑂(𝑛4𝜃m,t), respectively, where (A) and (B) achieve a better bound than (C) and (D).

We define a solution based not on a closure operator but on item sets. The proposed algorithm makes use of items explicitly, and it is hard to extend it to the case where a solution is defined on a closure operator. The problem of enumerating closed subsets in a confluent system is left for future work.

Application Examples
Connectors in Graphs
As we will observe in Sect. 6.1, our framework can be applied to the connector enumeration problem. We overview the scenario as follows. Let (𝐺,𝐼,𝜎) be an instance of the connector enumeration problem, where 𝐺=(𝑉,𝐸) is a graph, 𝐼={1,2,…,𝑞} is an item set, and 𝜎:𝑉→2𝐼 is a function that represents the items assigned to each vertex. Define a component to be a nonempty vertex subset of V that induces a connected subgraph, and denote by  to be the family of components in G. We can show that the system (𝑉,) is confluent and that a solution in the instance (𝑉,,𝐼,𝜎) is a connector.

Table 2 Complexity of enumerating connectors in (𝐺=(𝑉,𝐸),𝐼,𝜎), where 𝑛=|𝑉|, 𝑚=|𝐸|, 𝑞=|𝐼|, and 𝑤=max𝐶∈|𝐶|
Full size table

Let us denote 𝑛=|𝑉| and 𝑚=|𝐸|. Then L1 and L2 oracles can be realized by a conventional graph search algorithm (e.g., DFS, BFS), and thus it holds that 𝜃1,t=𝜃2,t=𝑂(𝑛+𝑚) and 𝜃1,s=𝜃2,s=𝑂(𝑛+𝑚). Also we can set 𝜃𝜌,𝑡=𝜃𝜌,𝑠=𝑂(1) and 𝛿(𝑉)=𝑛. Substituting them for (C) and (D) of Table 1, we obtain an algorithm for the connector enumeration problem such that the complexity is given in (C) and (D) of Table 2, respectively.

Alternatively, we may define a component to be a vertex subset of V that induces a connected subgraph, where this time we regard an empty subset as connected. The system (𝑉,) in this case is strongly-accessible and weakly-confluent, which is indicated with the point 5 in Fig. 2. Similarly to L1 and L2, the membership oracle can be implemented so that the time and space complexities are 𝑂(𝑛+𝑚). Then we have complexity bounds (A) and (B) of Table 2, substituting 𝜃m,t=𝜃m,s=𝑂(𝑛+𝑚) for (A) and (B) of Table 1, respectively. Note that, for (A), Corollary 13 in [8] claims better time and space bounds, 𝑂((𝑞+𝑚)𝑛2) and O(n), respectively. The complexity for (B) is obtained immediately from Theorem 4.2 in [5].

We see that the proposed algorithm (C) achieves a better time bound than others in some cases. For example, when 𝑞=𝑂(1) and 𝑚=𝑂(𝑛2), (C) achieves a time bound 𝑂(𝑛3) whereas the time bounds of (A), (B) and (D) are 𝑂(𝑛5), 𝑂(𝑤𝑛5) and 𝑂(𝑛4), respectively.

Components
Remember that a solution S in a given instance (𝑉,,𝐼,𝜎) is a component 𝑆∈ such that the set of common items in the set is maximal over all components that contain S. As will be proven in Sect. 4.6, any algorithm for enumerating all solutions in an instance (𝑉,,𝐼,𝜎) of a class of set systems can be conversely used to enumerate all components in the set system (𝑉,) of that class. We show the resulting complexity of such algorithms in Table 3. The complexity for the confluent system (C) and the general system (D) is obtained by substituting 𝑞=𝑂(𝑛) for the complexity (C) and (D) in Table 1, respectively, which results the same time and space bounds. The complexity for the strongly-accessible system (resp., the accessible system) is based on a corollary of Theorem 3 in [8] (resp., Theorem 4.2 in [5]).

Table 3 Complexity of enumerating all components for various set systems (𝑉,), where 𝑛=|𝑉| and 𝑤=max𝐶∈|𝐶|
Full size table

In Table 3, (A) achieves a better time bound than (B), as expected. Similarly to comparison in Sect. 2.5, under an assumption of 𝜃1,t=𝜃2,t=𝑂(𝑛𝜃m,t), 𝜃𝜌,𝑡=𝑂(1) and 𝛿(𝑉)=𝑂(𝑛), (A) and (B) achieve better time bounds than (D). We see that (C) and (D) have the same time bound. We consider that it is not because the complexity analysis is loose. Both algorithms are based on family tree and somewhat similar to each other. We may develop a better algorithm for (C), making use of confluency, to the extent of enumeration of components. This is left for future work.

Preliminaries
Let ℝ (resp., ℝ+) denote the set of reals (resp., non-negative reals). For a function 𝑓:𝐴→ℝ for a finite subset A and a subset 𝐵⊆𝐴, we let f(B) denote ∑𝑎∈𝐵𝑓(𝑎).

For two integers a and b, let [a, b] denote the set of integers i with 𝑎≤𝑖≤𝑏. For a set A with a total order < over the elements in A, we define a total order ≺ over the subsets of A as follows. For two subsets 𝐽,𝐾⊆𝐴, we denote by 𝐽≺𝐾 if the minimum element in (𝐽∖𝐾)∪(𝐾∖𝐽) belongs to J. We denote 𝐽⪯𝐾 if 𝐽≺𝐾 or 𝐽=𝐾. Note that 𝐽⪯𝐾 holds whenever 𝐽⊇𝐾. Let 𝑎max denote the maximum element in A. Then 𝐽≺𝐾 holds for 𝐽={𝑗1,𝑗2,…,𝑗|𝐽|}, 𝑗1<𝑗2<⋯<𝑗|𝐽| and 𝐾={𝑘1,𝑘2,…,𝑘|𝐾|}, 𝑘1<𝑘2<⋯<𝑘|𝐾|, if and only if the sequence


(𝑗1,𝑗2,…,𝑗|𝐽|,𝑗′|𝐽|+1,𝑗′|𝐽|+2,…,𝑗′|𝐴|)

of length |A| with 𝑗′|𝐽|+1=𝑗′|𝐽|+2=⋯=𝑗′|𝐴|=𝑎max is lexicographically smaller than the sequence


(𝑘1,𝑘2,…,𝑘|𝐾|,𝑘′|𝐾|+1,𝑘′|𝐾|+2,…,𝑘′|𝐴|)

of length |A| with 𝑘′|𝐾|+1=𝑘′|𝐾|+2=⋯=𝑘′|𝐴|=𝑎max. Hence we see that ⪯ is a total order on 2𝐴.

We start with an important property on components in a confluent system.

Lemma 3
Let (𝑉,) be a confluent system. For a component 𝑋∈ and a superset 𝑌⊇𝑋, there is exactly one component in max(𝑋;𝑌).

Proof
Since 𝑋⊆𝑌, max(𝑋;𝑌) contains a Y-maximal component C. For any component 𝑊∈ with 𝑋⊆𝑊⊆𝑌, the transitivity of  and 𝑋⊆𝐶∩𝑊 imply 𝐶∪𝑊∈, where 𝐶∪𝑊=𝐶 must hold by the Y-maximality of C. Hence a Y-maximal component in max(𝑋;𝑌) is unique. ◻

For a component 𝑋∈ and a superset 𝑌⊇𝑋, let C(X; Y) denote the unique component in max(𝑋;𝑌).

Suppose that an instance (𝑉,,𝐼,𝜎) is given. To facilitate our aim, we introduce a total order over the items in I by representing I as a set [1,𝑞]={1,2,…,𝑞} of integers. For each subset 𝑋⊆𝑉, let min𝐼𝜎(𝑋)∈[0,𝑞] denote the minimum item in 𝐼𝜎(𝑋), where min𝐼𝜎(𝑋)≜0 for 𝐼𝜎(𝑋)=∅. For each 𝑖∈[0,𝑞], define a family of solutions in ,


𝑖≜{𝑋∈∣min𝐼𝜎(𝑋)=𝑖}.

Note that  is a disjoint union of 𝑖, 𝑖∈[0,𝑞]. In Sect. 4.5, we will design an algorithm that enumerates all solutions in 𝑘 for any specified integer 𝑘∈[0,𝑞].

Enumerating Solutions in Confluent System
Defining Family Tree
To generate all solutions in  efficiently, we use the idea of family tree, where we first introduce a parent–child relationship among solutions, which defines a rooted tree (or a set of rooted trees), and we traverse each tree starting from the root and generating the children of a solution recursively. Our tasks to establish such an enumeration algorithm are as follows:

Select some solutions from the set  of solutions as the roots, called “bases;”

Define the “parent” 𝜋(𝑆)∈ of each non-base solution 𝑆∈, where the solution S is called a “child” of the solution 𝑇=𝜋(𝑆);

Design an algorithm A that, given a solution 𝑆∈, returns its parent 𝜋(𝑆); and

Design an algorithm B that, given a solution 𝑇∈, generates a set  of components 𝑋∈ such that  contains all children of T. We can test whether each component 𝑋∈ is a child of T by constructing 𝜋(𝑋) by algorithm A and checking if 𝜋(𝑋) is equal to T.

Starting from each base, we recursively generate the children of a solution. The complexity of delay-time of the entire algorithm depends on the time complexity of algorithms A and B, where || is bounded from above by the time complexity of algorithm B.

Defining Base
Let (𝑉,,𝐼=[1,𝑞],𝜎) be an instance on a confluent system. We define subsets 𝑉⟨0⟩≜𝑉 and 𝑉⟨𝑖⟩≜{𝑣∈𝑉∣𝑖∈𝜎(𝑣)} for each item 𝑖∈𝐼. For each non-empty subset 𝐽⊆𝐼, define subset 𝑉⟨𝐽⟩≜⋂𝑖∈𝐽𝑉⟨𝑖⟩={𝑣∈𝑉∣𝐽⊆𝜎(𝑣)}. For 𝐽=∅, define 𝑉⟨𝐽⟩≜𝑉. For each integer 𝑖∈[0,𝑞], define a set of components


𝑖≜{𝑋∈max(𝑉⟨𝑖⟩)∣min𝐼𝜎(𝑋)=𝑖}, 

and ≜⋃𝑖∈[0,𝑞]𝑖. We call each component in  a base.

Lemma 4
Let (𝑉,,𝐼=[1,𝑞],𝜎) be an instance on a confluent system.

(i)
For each non-empty set 𝐽⊆[1,𝑞] or 𝐽={0}, it holds that max(𝑉⟨𝐽⟩)⊆;

(ii)
For each 𝑖∈[0,𝑞], any solution 𝑆∈𝑖 is contained in some base in 𝑖; and

(iii)
0=0 and 𝑞=𝑞.

Proof
(i) Let X be a component in max(𝑉⟨𝐽⟩). Note that 𝐽⊆𝐼𝜎(𝑋) holds. When 𝐽={0} (i.e., 𝑉⟨𝐽⟩=𝑉), no proper superset of X is a component, and X is a solution. Consider the case of ∅≠𝐽⊆[1,𝑞]. To derive a contradiction, assume that X is not a solution; i.e., there is a proper superset Y of X such that 𝐼𝜎(𝑌)=𝐼𝜎(𝑋). Since ∅≠𝐽⊆𝐼𝜎(𝑋)=𝐼𝜎(𝑌), we see that 𝑉⟨𝐽⟩⊇𝑌. This, however, contradicts the 𝑉⟨𝐽⟩-maximality of X. This proves that X is a solution.

(ii) We prove that each solution 𝑆∈𝑖 is contained in a base in 𝑖. Note that 𝑖=min𝐼𝜎(𝑆) holds. By definition, it holds that 𝑆⊆𝑉⟨𝑖⟩. Let 𝐶∈max(𝑆;𝑉⟨𝑖⟩) be a solution. Note that 𝐼𝜎(𝑆)⊇𝐼𝜎(𝐶) holds. Since 𝑖∈𝐼𝜎(𝐶) for 𝑖≥1 (resp., 𝐼𝜎(𝐶)=∅ for 𝑖=0), we see that min𝐼𝜎(𝑆)=𝑖=min𝐼𝜎(𝐶). This proves that C is a base in 𝑖. Therefore S is contained in a base 𝐶∈𝑖.

(iii) Let 𝑘∈{0,𝑞}. We see from (i) that max(𝑉⟨𝑘⟩)⊆, which implies that 𝑘={𝑋∈max(𝑉⟨𝑘⟩)∣min𝐼𝜎(𝑋)=𝑘}⊆{𝑋∈∣min𝐼𝜎(𝑋)=𝑘}=𝑘. We prove that any solution 𝑆∈𝑘 is a base in 𝑘. By (ii), there is a base 𝑋∈𝑘 such that 𝑆⊆𝑋, which implies that 𝐼𝜎(𝑆)⊇𝐼𝜎(𝑋) and min𝐼𝜎(𝑆)≤min𝐼𝜎(𝑋). We see that 𝐼𝜎(𝑆)=𝐼𝜎(𝑋), since ∅=𝐼𝜎(𝑆)⊇𝐼𝜎(𝑋) for 𝑘=0, and 𝑞=min𝐼𝜎(𝑆)≤min𝐼𝜎(𝑋)≤𝑞 for 𝑘=𝑞. Hence 𝑆⊊𝑋 would contradict that S is a solution. Therefore 𝑆=𝑋∈𝑘, as required. ◻

Lemma 4(iii) tells that all solutions in 0∪𝑞 can be found by calling oracle L2(𝑌) for 𝑌=𝑉⟨0⟩=𝑉 and 𝑌=𝑉⟨𝑞⟩. In the following, we consider how to generate all solutions in 𝑘 for each item 𝑘∈[1,𝑞−1].

For a notational convenience, let C(X; i) for each item 𝑖∈𝐼𝜎(𝑋) denote the component 𝐶(𝑋;𝑉⟨𝑖⟩) and let C(X; J) for each subset 𝐽⊆𝐼𝜎(𝑋) denote the component 𝐶(𝑋;𝑉⟨𝐽⟩).

Lemma 5
Let (𝑉,,𝐼=[1,𝑞],𝜎) be an instance on a confluent system. Any two solutions 𝑆,𝑇∈ such that 𝑆⊆𝑇 satisfy 𝑇=𝐶(𝑆;𝐼𝜎(𝑇)).

Proof
Let 𝑇′=𝐶(𝑆;𝐼𝜎(𝑇))∈max(𝑉⟨𝐼𝜎(𝑇)⟩). Note that 𝑆⊆𝑇⊆𝑉⟨𝐼𝜎(𝑇)⟩ holds. The uniqueness of maximal component 𝑇′=𝐶(𝑆;𝐼𝜎(𝑇)) by Lemma 3 indicates 𝑇⊆𝑇′. To derive a contradiction, assume that 𝑇⊊𝑇′. By Lemma 4(i), 𝑇′∈max(𝑉⟨𝐼𝜎(𝑇)⟩) is a solution. Since T and 𝑇′ are solutions such that 𝑇⊊𝑇′, it must hold that 𝐼𝜎(𝑇)⊋𝐼𝜎(𝑇′), implying that 𝑉⟨𝐼𝜎(𝑇)⟩⊉𝑇′, a contradiction. Therefore we have 𝑇=𝑇′. ◻

Defining Parent
This subsection defines the “parent” of a non-base solution. For two solutions 𝑆,𝑇∈, we say that T is a superset solution of S if 𝑇⊋𝑆 and 𝑆,𝑇∈𝑖 for some item 𝑖∈[1,𝑞−1]. A superset solution T of a solution 𝑆∈ is called minimal if no proper subset 𝑍⊊𝑇 is a superset solution of S. Let S be a non-base solution in 𝑘∖𝑘 for some item 𝑘∈[1,𝑞−1]. We call a minimal superset solution T of S the lex-min solution of S if 𝐼𝜎(𝑇)⪯𝐼𝜎(𝑇′) holds for all minimal superset solutions 𝑇′ of S.

figure a
Lemma 6
Let (𝑉,,𝐼=[1,𝑞],𝜎) be an instance on a confluent system, 𝑆∈𝑘∖𝑘 be a non-base solution for some item 𝑘∈[1,𝑞−1], and T denote the lex-min solution of S. Denote 𝐼𝜎(𝑆) by \{k, i_1,i_2,\ldots ,i_p\}{𝑘,𝑖1,𝑖2,…,𝑖𝑝} so that k<i_1<i_2<\cdots <i_p𝑘<𝑖1<𝑖2<⋯<𝑖𝑝. Then:

(i)
For each integer j\in [1,p]𝑗∈[1,𝑝], i_j\in I_\sigma (T)𝑖𝑗∈𝐼𝜎(𝑇) holds if and only if C(S;J\cup \{i_j\})\supsetneq S𝐶(𝑆;𝐽∪{𝑖𝑗})⊋𝑆 holds for the item set J=I_\sigma (T)\cap \{k, i_1,i_2,\ldots ,i_{j-1}\}𝐽=𝐼𝜎(𝑇)∩{𝑘,𝑖1,𝑖2,…,𝑖𝑗−1}; and

(ii)
Parent(S) in Algorithm 1 correctly delivers the lex-min solution of S in O(q(n+\theta _{\mathrm {1,t}}))𝑂(𝑞(𝑛+𝜃1,t)) time and O(q+n+\theta _{\mathrm {1,s}})𝑂(𝑞+𝑛+𝜃1,s) space.

Proof
(i) By

Lemma 4(i) and \min I_\sigma (S)=kmin𝐼𝜎(𝑆)=𝑘, we see that C(S;J\cup \{i_j\}) \in {{\mathcal {S}}}_k𝐶(𝑆;𝐽∪{𝑖𝑗})∈𝑘 for any integer j\in [1,p]𝑗∈[1,𝑝].

Case 1. C(S;J\cup \{i_j\})=S𝐶(𝑆;𝐽∪{𝑖𝑗})=𝑆: For any set J'\subseteq \{i_{j+1},i_{j+2},\ldots ,i_p\}𝐽′⊆{𝑖𝑗+1,𝑖𝑗+2,…,𝑖𝑝}, the component C(S;J\cup \{i_j\}\cup J')𝐶(𝑆;𝐽∪{𝑖𝑗}∪𝐽′) is equal to S and cannot be a minimal superset solution of S. This implies that i_j\not \in I_\sigma (T)𝑖𝑗∉𝐼𝜎(𝑇).

Case 2. C(S;J\cup \{i_j\})\supsetneq S𝐶(𝑆;𝐽∪{𝑖𝑗})⊋𝑆: Then C=C(S;J\cup \{i_j\})𝐶=𝐶(𝑆;𝐽∪{𝑖𝑗}) is a solution by Lemma 4(i). Observe that k\in J\cup \{i_j\}\subseteq I_\sigma (C)\subseteq I_\sigma (S)𝑘∈𝐽∪{𝑖𝑗}⊆𝐼𝜎(𝐶)⊆𝐼𝜎(𝑆) and \min I_\sigma (C)=kmin𝐼𝜎(𝐶)=𝑘, implying that C\in {{\mathcal {S}}}_k𝐶∈𝑘 is a superset solution of S. Then C contains a minimal superset solution T^*\in {{\mathcal {S}}}_k𝑇∗∈𝑘 of S, where I_\sigma (T^*)\cap [1,i_{j-1}]=I_\sigma (T^*)\cap \{k,i_1,i_2,\ldots ,i_{j-1}\}\supseteq J= I_\sigma (T)\cap \{k,i_1,i_2,\ldots ,i_{j-1}\}=I_\sigma (T)\cap [1,i_{j-1}]𝐼𝜎(𝑇∗)∩[1,𝑖𝑗−1]=𝐼𝜎(𝑇∗)∩{𝑘,𝑖1,𝑖2,…,𝑖𝑗−1}⊇𝐽=𝐼𝜎(𝑇)∩{𝑘,𝑖1,𝑖2,…,𝑖𝑗−1}=𝐼𝜎(𝑇)∩[1,𝑖𝑗−1] and i_j \in I_\sigma (T^*)𝑖𝑗∈𝐼𝜎(𝑇∗). If I_\sigma (T^*)\cap [1,i_{j-1}]\supsetneq J𝐼𝜎(𝑇∗)∩[1,𝑖𝑗−1]⊋𝐽 or i_j\not \in I_\sigma (T)𝑖𝑗∉𝐼𝜎(𝑇), then I_\sigma (T^*)\prec I_\sigma (T)𝐼𝜎(𝑇∗)≺𝐼𝜎(𝑇) would hold, contradicting that T is the lex-min solution of S. Hence I_\sigma (T)\cap [1,i_{j-1}]=J=I_\sigma (T^*)\cap [1,i_{j-1}]𝐼𝜎(𝑇)∩[1,𝑖𝑗−1]=𝐽=𝐼𝜎(𝑇∗)∩[1,𝑖𝑗−1] and i_j\in I_\sigma (T)𝑖𝑗∈𝐼𝜎(𝑇).

(ii) Based on (i), we can obtain the solution T as follows. First we find the item set I_\sigma (T)𝐼𝜎(𝑇) by applying (i) to each integer j\in [1,p]𝑗∈[1,𝑝], where we construct subsets J_0\subseteq J_1\subseteq \cdots \subseteq J_p \subseteq I_\sigma (S)𝐽0⊆𝐽1⊆⋯⊆𝐽𝑝⊆𝐼𝜎(𝑆) such that J_0=\{k\}𝐽0={𝑘} and

\begin{aligned} J_j&=\left\{ \begin{array}{ll} J_{j-1}\cup \{i_j\} &{}\quad \text {if\ }C(S;J_{j-1}\cup \{i_j\})\supsetneq S,\\ J_{j-1} &{}\quad \text {otherwise}. \end{array} \right. \end{aligned}

𝐽𝑗={𝐽𝑗−1∪{𝑖𝑗}𝐽𝑗−1if\ 𝐶(𝑆;𝐽𝑗−1∪{𝑖𝑗})⊋𝑆,otherwise.

Each subset J_j𝐽𝑗 can be obtained from subset J_{j-1}𝐽𝑗−1 by testing whether C(S;J_{j-1}\cup \{i_j\})\supsetneq S𝐶(𝑆;𝐽𝑗−1∪{𝑖𝑗})⊋𝑆 holds or not, where C(S;J_{j-1}\cup \{i_j\})𝐶(𝑆;𝐽𝑗−1∪{𝑖𝑗}) is computable by calling the oracle \mathrm {L}_1L1. By (i), we have J_j=I_\sigma (T)\cap \{k,i_1,\dots ,i_j\}𝐽𝑗=𝐼𝜎(𝑇)∩{𝑘,𝑖1,…,𝑖𝑗}, and in particular, J_p=I_\sigma (T)𝐽𝑝=𝐼𝜎(𝑇) holds. Next we compute the component C(S;J_p)𝐶(𝑆;𝐽𝑝) by calling the oracle \mathrm {L}_1(S,V_{\langle J_p\rangle })L1(𝑆,𝑉⟨𝐽𝑝⟩), where C(S;J_p)𝐶(𝑆;𝐽𝑝) is equal to the solution T by Lemma 5. The above algorithm is described as algorithm Parent(S) in Algorithm 1.

Let us mention critical parts in terms of time complexity analysis. In line 1, it takes O(qn) time to compute I_\sigma (S)𝐼𝜎(𝑆). The for-loop from line 3 to 7 is repeated O(q) times. In line 4, the oracle \mathrm {L}_1(S,V_{\langle J\cup \{i_j\}\rangle })L1(𝑆,𝑉⟨𝐽∪{𝑖𝑗}⟩) is called to obtain a component Z=C(S;J\cup \{i_j\})𝑍=𝐶(𝑆;𝐽∪{𝑖𝑗}) and whether S=Z𝑆=𝑍 or not is tested. This takes O(\theta _{\mathrm {1,t}}+n)𝑂(𝜃1,t+𝑛) time. The overall running time is O(q(n+\theta _{\mathrm {1,t}}))𝑂(𝑞(𝑛+𝜃1,t)). It takes O(q) space to store I_\sigma (S)𝐼𝜎(𝑆) and J, and O(n) space to store S and Z. An additional O(\theta _{\mathrm {1,s}})𝑂(𝜃1,s) space is needed for the oracle \mathrm {L}_1L1. \square ◻

For each item k\in [1,q-1]𝑘∈[1,𝑞−1], we define the parent \pi (S)𝜋(𝑆) of a non-base solution S\in {{\mathcal {S}}}_k{\setminus } {{\mathcal {B}}}_k𝑆∈𝑘∖𝑘 to be the lex-min solution of S, and define a child of a solution T\in {{\mathcal {S}}}_k𝑇∈𝑘 to be a non-base solution S\in {{\mathcal {S}}}_k{\setminus } {{\mathcal {B}}}_k𝑆∈𝑘∖𝑘 such that \pi (S)=T𝜋(𝑆)=𝑇.

Generating Children
This subsection shows how to construct a family \mathcal {X} of components for a given solution T so that \mathcal {X} contains all children of T.

Lemma 7
Let (V,{{\mathcal {C}}},I=[1,q],\sigma )(𝑉,,𝐼=[1,𝑞],𝜎) be an instance on a confluent system and T\in {{\mathcal {S}}}_k𝑇∈𝑘 be a solution for some item k\in [1,q-1]𝑘∈[1,𝑞−1]. Then:

(i)
Every child S of T satisfies [k+1,q]\cap (I_\sigma (S){\setminus } I_\sigma (T)) \ne \emptyset [𝑘+1,𝑞]∩(𝐼𝜎(𝑆)∖𝐼𝜎(𝑇))≠∅ and is a component in {{\mathcal {C}}}_{\mathrm{max}}(T\cap V_{\langle j\rangle })max(𝑇∩𝑉⟨𝑗⟩) for any item j\in [k+1,q]\cap (I_\sigma (S){\setminus } I_\sigma (T))𝑗∈[𝑘+1,𝑞]∩(𝐼𝜎(𝑆)∖𝐼𝜎(𝑇));

(ii)
The family of children S of T is equal to the disjoint collection of families \mathcal {C}_j = \{ C\in {{\mathcal {C}}}_{\mathrm{max}}(T\cap V_{\langle j\rangle })\mid k= \min I_\sigma (C), j=\min \{i\mid i\in [k+1,q]\cap (I_\sigma (C){\setminus } I_\sigma (T))\}, T=𝑗={𝐶∈max(𝑇∩𝑉⟨𝑗⟩)∣𝑘=min𝐼𝜎(𝐶),𝑗=min{𝑖∣𝑖∈[𝑘+1,𝑞]∩(𝐼𝜎(𝐶)∖𝐼𝜎(𝑇))},𝑇= Parent(C)\}(𝐶)} over all items j\in [k+1, q]{\setminus } I_\sigma (T)𝑗∈[𝑘+1,𝑞]∖𝐼𝜎(𝑇); and

(iii)
The set of all children of T can be constructed in O\big (q \theta _{2,\mathrm {t}} + q^2(n+\theta _{1,\mathrm {t}})\delta (T) \big )𝑂(𝑞𝜃2,t+𝑞2(𝑛+𝜃1,t)𝛿(𝑇)) time and O(q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}})𝑂(𝑞+𝑛+𝜃1,s+𝜃2,s) space.

Proof
(i) Note that [0,k]\cap I_\sigma (S)=[0,k]\cap I_\sigma (T)=\{k\}[0,𝑘]∩𝐼𝜎(𝑆)=[0,𝑘]∩𝐼𝜎(𝑇)={𝑘} since S,T\in {{\mathcal {S}}}_k𝑆,𝑇∈𝑘. Since S\subseteq T𝑆⊆𝑇 are both solutions, I_\sigma (S)\supsetneq I_\sigma (T)𝐼𝜎(𝑆)⊋𝐼𝜎(𝑇). Hence [k+1,q]\cap (I_\sigma (S){\setminus } I_\sigma (T)) \ne \emptyset [𝑘+1,𝑞]∩(𝐼𝜎(𝑆)∖𝐼𝜎(𝑇))≠∅. Let j be an arbitrary item in [k+1,q]\cap (I_\sigma (S){\setminus } I_\sigma (T))[𝑘+1,𝑞]∩(𝐼𝜎(𝑆)∖𝐼𝜎(𝑇)). Since S\subseteq T\cap V_{\langle j\rangle }𝑆⊆𝑇∩𝑉⟨𝑗⟩, it holds that {{\mathcal {C}}}_{\mathrm{max}}(S;T\cap V_{\langle j\rangle })\ne \emptyset max(𝑆;𝑇∩𝑉⟨𝑗⟩)≠∅.

Let C be a (T\cap V_{\langle j\rangle })(𝑇∩𝑉⟨𝑗⟩)-maximal component in {{\mathcal {C}}}_{\mathrm{max}}(S;T\cap V_{\langle j\rangle })max(𝑆;𝑇∩𝑉⟨𝑗⟩). It suffices to show that C=S𝐶=𝑆. Note that S\subseteq C\subseteq T𝑆⊆𝐶⊆𝑇, I_\sigma (S)\supseteq I_\sigma (C)\supseteq I_\sigma (T)𝐼𝜎(𝑆)⊇𝐼𝜎(𝐶)⊇𝐼𝜎(𝑇) and k=\min I_\sigma (S)=\min I_\sigma (T)𝑘=min𝐼𝜎(𝑆)=min𝐼𝜎(𝑇) implies \min I_\sigma (C)= kmin𝐼𝜎(𝐶)=𝑘.

We show that C\in {{\mathcal {S}}}𝐶∈, which implies C\in {{\mathcal {S}}}_k𝐶∈𝑘. Note that j \in I_\sigma (C){\setminus } I_\sigma (T)𝑗∈𝐼𝜎(𝐶)∖𝐼𝜎(𝑇), and C\subsetneq T𝐶⊊𝑇.

Assume that C is not a solution; i.e., there is a solution C^*\in {{\mathcal {S}}}𝐶∗∈ such that C\subsetneq C^*𝐶⊊𝐶∗ and I_\sigma (C)=I_\sigma (C^*)𝐼𝜎(𝐶)=𝐼𝜎(𝐶∗), where j\in I_\sigma (C)=I_\sigma (C^*)𝑗∈𝐼𝜎(𝐶)=𝐼𝜎(𝐶∗) means that C^*\subseteq V_{\langle j\rangle }𝐶∗⊆𝑉⟨𝑗⟩. Hence C^*{\setminus } T\ne \emptyset 𝐶∗∖𝑇≠∅ by the (T\cap V_{\langle j\rangle })(𝑇∩𝑉⟨𝑗⟩)-maximality of C. Since C,C^*,T\in {{\mathcal {C}}}𝐶,𝐶∗,𝑇∈ and C\subseteq C^*\cap T𝐶⊆𝐶∗∩𝑇, we have C^*\cup T\in {{\mathcal {C}}}𝐶∗∪𝑇∈ by the transitivity. We also see that I_\sigma (C^*\cup T)=I_\sigma (C^*)\cap I_\sigma (T)=I_\sigma (C)\cap I_\sigma (T)=I_\sigma (T)𝐼𝜎(𝐶∗∪𝑇)=𝐼𝜎(𝐶∗)∩𝐼𝜎(𝑇)=𝐼𝜎(𝐶)∩𝐼𝜎(𝑇)=𝐼𝜎(𝑇). This, however, contradicts that T is a solution, proving that C\in {{\mathcal {S}}}_k𝐶∈𝑘. If S\subsetneq C𝑆⊊𝐶, then S\subsetneq C\subsetneq T𝑆⊊𝐶⊊𝑇 would hold for S,C,T\in {{\mathcal {S}}}_k𝑆,𝐶,𝑇∈𝑘, contradicting that T is a minimal superset solution of S. Therefore S=C𝑆=𝐶.

(ii) By (i), the family \mathcal {S}_T𝑇 of children of T is contained in the family of (T\cap V_{\langle j\rangle })(𝑇∩𝑉⟨𝑗⟩)-maximal components over all items j\in [k+1,q]\cap I_\sigma (T)𝑗∈[𝑘+1,𝑞]∩𝐼𝜎(𝑇). Hence

\begin{aligned} \mathcal {S}_T =\cup _{j\in [k+1,q]\cap I_\sigma (T)}\{C\in {{\mathcal {C}}}_{\mathrm{max}}(T\cap V_{\langle j\rangle }) \mid T=\textsc {Parent}(C)\}. \end{aligned}

𝑇=∪𝑗∈[𝑘+1,𝑞]∩𝐼𝜎(𝑇){𝐶∈max(𝑇∩𝑉⟨𝑗⟩)∣𝑇=PARENT(𝐶)}.

Note that if a subset S\subseteq V𝑆⊆𝑉 is a child of T, then k= \min I_\sigma (S)𝑘=min𝐼𝜎(𝑆) and S\in {{\mathcal {C}}}_{\mathrm{max}}(T\cap V_{\langle j\rangle })𝑆∈max(𝑇∩𝑉⟨𝑗⟩) for all items j\in [k+1,q]\cap (I_\sigma (S){\setminus } I_\sigma (T))𝑗∈[𝑘+1,𝑞]∩(𝐼𝜎(𝑆)∖𝐼𝜎(𝑇)). Hence we see that \mathcal {S}_T𝑇 is equal to the disjoint collection of families \mathcal {C}_j = \{ C\in {{\mathcal {C}}}_{\mathrm{max}}(T\cap V_{\langle j\rangle })\mid k= \min I_\sigma (C), j=\min \{i\mid i\in [k+1,q]\cap (I_\sigma (C){\setminus } I_\sigma (T))\}, T=𝑗={𝐶∈max(𝑇∩𝑉⟨𝑗⟩)∣𝑘=min𝐼𝜎(𝐶),𝑗=min{𝑖∣𝑖∈[𝑘+1,𝑞]∩(𝐼𝜎(𝐶)∖𝐼𝜎(𝑇))},𝑇= Parent(C)\}(𝐶)} over all items j\in [k+1, q]{\setminus } I_\sigma (T)𝑗∈[𝑘+1,𝑞]∖𝐼𝜎(𝑇).

figure b
(iii) Based on (ii), we obtain an algorithm described in Algorithm 2. We analyze the time and space complexities of the algorithm. Note that T may have no children. The outer for-loop from line 1 to 10 is repeated O(q) times. Computing {{\mathcal {C}}}(T\cap V_{\langle j\rangle })(𝑇∩𝑉⟨𝑗⟩) in line 2 takes \theta _{2,\mathrm {t}}𝜃2,t time by calling the oracle L_22. The inner for-loop from line 3 to 7 is repeated at most \delta (T\cap V_{\langle j\rangle })𝛿(𝑇∩𝑉⟨𝑗⟩) times for each j, and the most time-consuming part of the inner for-loop is algorithm Parent(S) in line 4, which takes O(q(n+\theta _{1,\mathrm {t}}))𝑂(𝑞(𝑛+𝜃1,t)) time by Lemma 6(ii). Recall that \delta 𝛿 is a non-decreasing function. Then the running time of algorithm Children(T, k) is evaluated by

\begin{aligned} O\Big (q\theta _{2,\mathrm {t}} + q(n+\theta _{1,\mathrm {t}})\sum _{j\in [k+1,q]{\setminus }I_\sigma (T)} \delta (T\cap V_{\langle j\rangle })\Big ) = O\big (q \theta _{2,\mathrm {t}} + q^2(n+\theta _{1,\mathrm {t}})\delta (T) \big ). \end{aligned}

𝑂(𝑞𝜃2,t+𝑞(𝑛+𝜃1,t)∑𝑗∈[𝑘+1,𝑞]∖𝐼𝜎(𝑇)𝛿(𝑇∩𝑉⟨𝑗⟩))=𝑂(𝑞𝜃2,t+𝑞2(𝑛+𝜃1,t)𝛿(𝑇)).

For the space complexity, we do not need to share the space between iterations of the outer for-loop from line 1 to 8. In each iteration, we use the oracle L_22 and algorithm Parent(S), whose space complexity is O(q+n+\theta _{1,\mathrm {s}})𝑂(𝑞+𝑛+𝜃1,s) by Lemma 6(ii). Then algorithm Children(T, k) uses O(q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}})𝑂(𝑞+𝑛+𝜃1,s+𝜃2,s) space. \square ◻

Traversing Family Tree
We are ready to describe an entire algorithm for enumerating solutions in {{\mathcal {S}}}_k𝑘 for a given integer k\in [0,q]𝑘∈[0,𝑞]. We first compute the component set {{\mathcal {C}}}_{\mathrm{max}}(V_{\langle k\rangle })max(𝑉⟨𝑘⟩). We next compute the family {{\mathcal {B}}}_k~(\subseteq {{\mathcal {C}}}_{\mathrm{max}}(V_{\langle k\rangle }))𝑘 (⊆max(𝑉⟨𝑘⟩)) of bases by testing whether k=\min I_\sigma (T)𝑘=min𝐼𝜎(𝑇) or not, where {{\mathcal {B}}}_k\subseteq {{\mathcal {S}}}_k𝑘⊆𝑘. When k=0𝑘=0 or q, we are done with {{\mathcal {B}}}_k={{\mathcal {S}}}_k𝑘=𝑘 by Lemma 4(iii). Let k\in [1,q-1]𝑘∈[1,𝑞−1]. Suppose that we are given a solution T\in {{\mathcal {S}}}_k𝑇∈𝑘. We find all the children of T by Children(T, k) in Algorithm 2. By applying Algorithm 2 to a newly found child recursively, we can find all solutions in {{\mathcal {S}}}_k𝑘.

When no child is found to a given solution T\in {{\mathcal {S}}}_k𝑇∈𝑘, we may need to go up to an ancestor by traversing recursive calls O(n) times before we generate the next solution. This would result in time delay of O(n\alpha )𝑂(𝑛𝛼), where \alpha 𝛼 denotes the time complexity required for a single run of Children(T, k). To improve the delay to O(\alpha )𝑂(𝛼), we employ the alternative output method [31], where we output the children of T after (resp., before) generating all descendants when the depth of the recursive call to T is an even (resp., odd) integer.

Assume that a volume function \rho : 2^V\rightarrow {\mathbb {R}}𝜌:2𝑉→ℝ is given. An algorithm that enumerates all \rho 𝜌-positive solutions in {{\mathcal {S}}}_k𝑘 is described in Algorithms 3 and 4.

figure c
figure d
Lemma 8
Let (V,{{\mathcal {C}}},I=[1,q],\sigma )(𝑉,,𝐼=[1,𝑞],𝜎) be an instance on a confluent system. For each k\in [0,q]𝑘∈[0,𝑞], all \rho 𝜌-positive solutions in {{\mathcal {S}}}_k𝑘 can be enumerated in O\big (q\theta _{2,\mathrm {t}} + (q(n+\theta _{1,\mathrm {t}}) +\theta _{\rho ,\mathrm {t}})q\delta (V_{\langle k\rangle })\big )𝑂(𝑞𝜃2,t+(𝑞(𝑛+𝜃1,t)+𝜃𝜌,t)𝑞𝛿(𝑉⟨𝑘⟩)) delay and O\big ((q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}} +\theta _{\rho ,\mathrm {s}}) n\big )𝑂((𝑞+𝑛+𝜃1,s+𝜃2,s+𝜃𝜌,s)𝑛) space.

Proof
Let T\in {{\mathcal {S}}}_k𝑇∈𝑘 be a solution such that \rho (T)\le 0𝜌(𝑇)≤0. In this case, \rho (S)\le \rho (T)\le 0𝜌(𝑆)≤𝜌(𝑇)≤0 holds for all descendants S of T since S\subseteq T𝑆⊆𝑇. Then we do not need to make recursive calls for such T.

We analyze the time delay. Let \alpha 𝛼 denote the time complexity required for a single run of Children(T, k). By Lemma 7(ii) and \delta (T)\le \delta (V_{\langle k\rangle })𝛿(𝑇)≤𝛿(𝑉⟨𝑘⟩), we have \alpha =O\big (q\theta _{2,\mathrm {t}} + q^2(n+\theta _{1,\mathrm {t}})\delta (V_{\langle k\rangle })\big )𝛼=𝑂(𝑞𝜃2,t+𝑞2(𝑛+𝜃1,t)𝛿(𝑉⟨𝑘⟩)). In Algorithm 3 and Descendants, we also need to compute \rho (S)𝜌(𝑆) for all child candidates S. The complexity is O(q\delta (V_{\langle k\rangle })\theta _{\rho ,\mathrm {t}})𝑂(𝑞𝛿(𝑉⟨𝑘⟩)𝜃𝜌,t) since \rho (S)𝜌(𝑆) is called at most q\delta (V_{\langle k\rangle })𝑞𝛿(𝑉⟨𝑘⟩) times. Hence we see that the time complexity of Algorithm 3 and Descendants without including recursive calls is O(\alpha +q\delta (V_{\langle k\rangle })\theta _{\rho ,\mathrm {t}})𝑂(𝛼+𝑞𝛿(𝑉⟨𝑘⟩)𝜃𝜌,t).

From Algorithm 3 and Descendants, we observe:

(i)
When d is odd, the solution S for any call Descendants(S,k,d+1)(𝑆,𝑘,𝑑+1) is output immediately before Descendants(S,k,d+1)(𝑆,𝑘,𝑑+1) is executed; and

(ii)
when d is even, the solution S for any call Descendants(S,k,d+1)(𝑆,𝑘,𝑑+1) is output immediately after Descendants(S,k,d+1)(𝑆,𝑘,𝑑+1) is executed.

Let m denote the number of all calls of Descendants during a whole execution of Algorithm 3. Let d_1=1,d_2,\ldots ,d_m𝑑1=1,𝑑2,…,𝑑𝑚 denote the sequence of depths d in each Descendants(S,k,d+1)(𝑆,𝑘,𝑑+1) of the m calls. Note that d=d_i𝑑=𝑑𝑖 satisfies (i) when d_{i+1}𝑑𝑖+1 is odd and d_{i+1}=d_i+1𝑑𝑖+1=𝑑𝑖+1, whereas d=d_i𝑑=𝑑𝑖 satisfies (ii) when d_{i+1}𝑑𝑖+1 is even and d_{i+1}=d_i-1𝑑𝑖+1=𝑑𝑖−1. Therefore we easily see that during three consecutive calls with depth d_i𝑑𝑖, d_{i+1}𝑑𝑖+1 and d_{i+2}𝑑𝑖+2, at least one solution will be output. This implies that the time delay for outputting a solution is O(\alpha +q\delta (V_{\langle k\rangle })\theta _{\rho ,\mathrm {t}})𝑂(𝛼+𝑞𝛿(𝑉⟨𝑘⟩)𝜃𝜌,t).

We analyze the space complexity. Observe that the number of calls Descendants whose executions are not finished during an execution of Algorithm 3 is the depth d of the current call Descendants(S,k,d+1)(𝑆,𝑘,𝑑+1). In Algorithm 4, |T|+d\le n+1|𝑇|+𝑑≤𝑛+1 holds initially, and Descendants(S,k,d+1)(𝑆,𝑘,𝑑+1) is called for a nonempty subset S\subsetneq T𝑆⊊𝑇, where |S|<|T||𝑆|<|𝑇|. Hence |S|+d\le n+1|𝑆|+𝑑≤𝑛+1 holds when Descendants(S,k,d+1)(𝑆,𝑘,𝑑+1) is called. Then Algorithm 3 can be implemented to run in O(n(\beta +\theta _{\rho ,\mathrm {s}}))𝑂(𝑛(𝛽+𝜃𝜌,s)) space, where \beta 𝛽 denotes the space required for a single run of Children(T, k). We have \beta =O(q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}})𝛽=𝑂(𝑞+𝑛+𝜃1,s+𝜃2,s) by Lemma 7(ii). Then the overall space complexity is O\big ((q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}}+\theta _{\rho ,\mathrm {s}}) n\big )𝑂((𝑞+𝑛+𝜃1,s+𝜃2,s+𝜃𝜌,s)𝑛). \square ◻

The volume function is introduced to impose a condition on the output solutions. For example, when \rho (X)=|X|-p𝜌(𝑋)=|𝑋|−𝑝 for a constant p, all solutions X\in {{\mathcal {S}}}_k𝑋∈𝑘 with |X|\ge p+1|𝑋|≥𝑝+1 will be output. In particular, all solutions in {{\mathcal {S}}}_k𝑘 will be output for p\le 0𝑝≤0. In this case, we have \theta _{\rho ,\mathrm {t}}=\theta _{\rho ,\mathrm {s}}=O(n)𝜃𝜌,t=𝜃𝜌,s=𝑂(𝑛), and thus the delay is O\big (q\theta _{2,\mathrm {t}} + q^2(n+\theta _{1,\mathrm {t}})\delta (V_{\langle k\rangle })\big )𝑂(𝑞𝜃2,t+𝑞2(𝑛+𝜃1,t)𝛿(𝑉⟨𝑘⟩)) and the space is O\big ((q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}}) n\big )𝑂((𝑞+𝑛+𝜃1,s+𝜃2,s)𝑛).

Theorem 1 is immediate from Lemma 8 since \delta (V_{\langle k\rangle })\le \delta (V)𝛿(𝑉⟨𝑘⟩)≤𝛿(𝑉) holds by our assumption that \delta (Y)\le \delta (X)𝛿(𝑌)≤𝛿(𝑋) for subsets Y\subseteq X\subseteq V𝑌⊆𝑋⊆𝑉.

Enumerating Components
This section shows that our algorithm in the previous section can enumerate all components in a given confluent system (V,{{\mathcal {C}}})(𝑉,) with n=|V|\ge 1𝑛=|𝑉|≥1. For this, we construct an instance \mathcal {I}=(V,{{\mathcal {C}}},I=[1,n],\varphi )=(𝑉,,𝐼=[1,𝑛],𝜑) as follows. Denote V by \{v_1,\dots ,v_n\}{𝑣1,…,𝑣𝑛}. We set I=[1,n]𝐼=[1,𝑛] and define a function \varphi :V\rightarrow 2^I𝜑:𝑉→2𝐼 to be \varphi (v_k)\triangleq I{\setminus }\{k\}𝜑(𝑣𝑘)≜𝐼∖{𝑘} for each element v_k\in V𝑣𝑘∈𝑉. For each subset X\subseteq V𝑋⊆𝑉, let \mathsf {Ind}(X)𝖨𝗇𝖽(𝑋) denote the set of indices i of elements v_i\in X𝑣𝑖∈𝑋; i.e., \mathsf {Ind}(X)=\{i\in [1,n]\mid v_i\in X\}𝖨𝗇𝖽(𝑋)={𝑖∈[1,𝑛]∣𝑣𝑖∈𝑋}, and I_\varphi (X)\subseteq [1,n]𝐼𝜑(𝑋)⊆[1,𝑛] denote the common item set over \varphi (v)𝜑(𝑣), v\in X𝑣∈𝑋; i.e., I_\varphi (X) = \bigcap _{v\in X}\varphi (v)𝐼𝜑(𝑋)=⋂𝑣∈𝑋𝜑(𝑣). Observe that I_\varphi (X)=I{\setminus }\mathsf {Ind}(X)𝐼𝜑(𝑋)=𝐼∖𝖨𝗇𝖽(𝑋).

Lemma 9
Let (V=\{v_1,\dots ,v_n\},{{\mathcal {C}}})(𝑉={𝑣1,…,𝑣𝑛},) be a confluent system with n\ge 1𝑛≥1. The family {{\mathcal {C}}} of all components is equal to the family {{\mathcal {S}}} of all solutions in the instance (V,{{\mathcal {C}}},I=[1,n],\varphi )(𝑉,,𝐼=[1,𝑛],𝜑).

Proof
Since any solution S\in {{\mathcal {S}}}𝑆∈ is a component, it holds that {{\mathcal {C}}}\supseteq {{\mathcal {S}}}⊇. We prove that {{\mathcal {C}}}\subseteq {{\mathcal {S}}}⊆. Let X\in {{\mathcal {C}}}𝑋∈. For any superset Y\supsetneq X𝑌⊋𝑋, it holds that I_{\varphi }(Y)=I{\setminus } \mathsf {Ind}(Y)\subsetneq I{\setminus } \mathsf {Ind}(X)=I_{\varphi }(X)𝐼𝜑(𝑌)=𝐼∖𝖨𝗇𝖽(𝑌)⊊𝐼∖𝖨𝗇𝖽(𝑋)=𝐼𝜑(𝑋). The component X is a solution in (V,{{\mathcal {C}}},I,\varphi )(𝑉,,𝐼,𝜑) since no superset of X has the same common item set as X. \square ◻

Since the family {{\mathcal {C}}} of components is equal to the family {{\mathcal {S}}} of solutions to the instance \mathcal {I}=(V,{{\mathcal {C}}},I,\varphi )=(𝑉,,𝐼,𝜑) by Lemma 9, we can enumerate all components in (V,{{\mathcal {C}}})(𝑉,) by running our algorithm on the instance \mathcal {I}. By |I|=n|𝐼|=𝑛, we have the following corollary to Theorem 1.

Corollary 1
Let (V,{{\mathcal {C}}})(𝑉,) be a confluent system with n=|V|\ge 1𝑛=|𝑉|≥1 and a volume function \rho 𝜌. All \rho 𝜌-positive components in {{\mathcal {C}}} can be enumerated in O\big ( n\theta _{2,\mathrm {t}} + (n^2+n\theta _{1,\mathrm {t}} +\theta _{\rho ,\mathrm {t}})n \delta (V)\big )𝑂(𝑛𝜃2,t+(𝑛2+𝑛𝜃1,t+𝜃𝜌,t)𝑛𝛿(𝑉)) delay and O\big ((n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}} +\theta _{\rho ,\mathrm {s}}) n\big )𝑂((𝑛+𝜃1,s+𝜃2,s+𝜃𝜌,s)𝑛) space.

Confluent System in Mixed Graph with Meta-Weight Function
Our enumeration algorithm in a confluent system can be applied to several problems of enumerating subgraphs that satisfy certain types of connectivity requirements over a given graph. To treat these applications universally, this subsection presents a general method of constructing a confluent system based on a mixed graph and a weight function on elements in the graph.

Meta-Weight Function in Mixed Graph
Let M be a mixed graph, which is defined to be a graph that may contain undirected edges and directed edges. In this paper, M may have multiple edges but no self-loops. Let V(M), \mathbf {E}(M)𝐄(𝑀) and {\overline{E}}(M)𝐸⎯⎯⎯⎯(𝑀) denote the sets of vertices, directed edges and undirected edges, respectively. Let E(M)\triangleq \mathbf {E}(M)\cup {\overline{E}}(M)𝐸(𝑀)≜𝐄(𝑀)∪𝐸⎯⎯⎯⎯(𝑀). Let n=|V(M)|𝑛=|𝑉(𝑀)| and m=|E(M)|𝑚=|𝐸(𝑀)|. For a vertex subset X\subseteq V𝑋⊆𝑉, let M[X] denote the subgraph induced from M by X. For a subset X\subseteq V(M)\cup E(M)𝑋⊆𝑉(𝑀)∪𝐸(𝑀), let V(X) denote the set of vertices in X\cap V(M)𝑋∩𝑉(𝑀) and the end-vertices of edges in X\cap E(M)𝑋∩𝐸(𝑀). For two vertices u,v\in V(M)𝑢,𝑣∈𝑉(𝑀), let

\mathbf {E}(u,v)𝐄(𝑢,𝑣) denote the set of directed edges from u to v,

{\overline{E}}(u,v)𝐸⎯⎯⎯⎯(𝑢,𝑣) denote the set of undirected edges between u and v in M, and

E(u,v)\triangleq \mathbf {E}(u,v)\cup {\overline{E}}(u,v)𝐸(𝑢,𝑣)≜𝐄(𝑢,𝑣)∪𝐸⎯⎯⎯⎯(𝑢,𝑣).

For two non-empty subsets X,Y\subseteq V(M)𝑋,𝑌⊆𝑉(𝑀), let

\mathbf {E}(X,Y)\triangleq \bigcup _{u\in X,v\in Y}\mathbf {E}(u,v)𝐄(𝑋,𝑌)≜⋃𝑢∈𝑋,𝑣∈𝑌𝐄(𝑢,𝑣),

{\overline{E}}(X,Y)\triangleq \bigcup _{u\in X,v\in Y}{\overline{E}}(u,v)𝐸⎯⎯⎯⎯(𝑋,𝑌)≜⋃𝑢∈𝑋,𝑣∈𝑌𝐸⎯⎯⎯⎯(𝑢,𝑣) and

E(X,Y)\triangleq \bigcup _{u\in X,v\in Y}E(u,v)𝐸(𝑋,𝑌)≜⋃𝑢∈𝑋,𝑣∈𝑌𝐸(𝑢,𝑣).

For two vertices s,t\in V(M)𝑠,𝑡∈𝑉(𝑀), an s, t-cut C is defined to be an ordered pair (S, T) of disjoint subsets S,T\subseteq V(M)𝑆,𝑇⊆𝑉(𝑀) such that s\in S𝑠∈𝑆 and t\in T𝑡∈𝑇, and the element set \varepsilon (C)𝜀(𝐶) of C (or \varepsilon (S,T)𝜀(𝑆,𝑇) of (S, T)) is defined to be a union F\cup R𝐹∪𝑅 of the edge subset F=E(S,T)𝐹=𝐸(𝑆,𝑇) and the vertex subset R=V(M){\setminus } (S\cup T)𝑅=𝑉(𝑀)∖(𝑆∪𝑇), where R=\emptyset 𝑅=∅ is allowed.

We define a meta-weight function on M to be \omega : 2^{V(M)\cup E(M)}\times (V(M)\cup E(M))\rightarrow {\mathbb {R}}_+𝜔:2𝑉(𝑀)∪𝐸(𝑀)×(𝑉(𝑀)∪𝐸(𝑀))→ℝ+. For each subset X\in 2^{V(M)\cup E(M)}𝑋∈2𝑉(𝑀)∪𝐸(𝑀), we define the function \omega _X: V(M)\cup E(M)\rightarrow {\mathbb {R}}_+𝜔𝑋:𝑉(𝑀)∪𝐸(𝑀)→ℝ+ induced from \omega 𝜔 by X so that \omega _X(a)=\omega (X,a)𝜔𝑋(𝑎)=𝜔(𝑋,𝑎) for each element a\in V(M)\cup E(M)𝑎∈𝑉(𝑀)∪𝐸(𝑀). We call \omega 𝜔 monotone if every two subsets X\subseteq Y\subseteq V(M)𝑋⊆𝑌⊆𝑉(𝑀) satisfy

\begin{aligned} \omega _{Y}(a)\ge \omega _X(a) \text{ for } \text{ each } \text{ element } a\in V(M)\cup E(M)\text{. } \end{aligned}

𝜔𝑌(𝑎)≥𝜔𝑋(𝑎) for  each  element 𝑎∈𝑉(𝑀)∪𝐸(𝑀). 

For two vertices s,t\in V(M)𝑠,𝑡∈𝑉(𝑀) and a subset X\subseteq V(M)\cup E(M)𝑋⊆𝑉(𝑀)∪𝐸(𝑀), define

\begin{aligned} \mu (s,t;X)\triangleq \min \{\omega _X(\varepsilon (C))\mid s,t \text{-cuts }\ C=(S,T)\ \text{ in }\ M\}. \end{aligned}

𝜇(𝑠,𝑡;𝑋)≜min{𝜔𝑋(𝜀(𝐶))∣𝑠,𝑡-cuts  𝐶=(𝑆,𝑇)  in  𝑀}.

We call a subset X\subseteq V(M)\cup E(M)𝑋⊆𝑉(𝑀)∪𝐸(𝑀) k-connected if |V(X)|=1|𝑉(𝑋)|=1 or \mu (u,v;X)\ge k𝜇(𝑢,𝑣;𝑋)≥𝑘 for each pair of vertices u,v\in V(X)𝑢,𝑣∈𝑉(𝑋). The notion of k-connectivity is a generalization of the standard k-edge/vertex-connectivity in graphs. The details will be explained in Sect. 6.2.

Lemma 10
Let (M,\omega )(𝑀,𝜔) be a mixed graph with a monotone meta-weight function, and k\ge 0𝑘≥0. For any two k-connected subsets X,Y\subseteq V(M)\cup E(M)𝑋,𝑌⊆𝑉(𝑀)∪𝐸(𝑀) such that \omega _{X\cap Y}(V(X\cap Y))\ge k𝜔𝑋∩𝑌(𝑉(𝑋∩𝑌))≥𝑘, the subset X\cup Y𝑋∪𝑌 is k-connected.

Proof
To derive a contradiction, assume that X\cup Y𝑋∪𝑌 is not k-connected; i.e., |V(X\cup Y)|\ge 2|𝑉(𝑋∪𝑌)|≥2 and some vertices s,t\in V(X\cup Y)𝑠,𝑡∈𝑉(𝑋∪𝑌) admit an s, t-cut C=(S,T)𝐶=(𝑆,𝑇) with \omega _{X\cup Y}(\varepsilon (C))<k𝜔𝑋∪𝑌(𝜀(𝐶))<𝑘. By the monotonicity of \omega 𝜔, it holds that \omega _{X\cup Y}(a)\ge \omega _X(a), \omega _Y(a)𝜔𝑋∪𝑌(𝑎)≥𝜔𝑋(𝑎),𝜔𝑌(𝑎) for any element a\in V(M)\cup E(M)𝑎∈𝑉(𝑀)∪𝐸(𝑀). Hence \omega _{X\cup Y}(\varepsilon (C))<k𝜔𝑋∪𝑌(𝜀(𝐶))<𝑘 implies \omega _{X}(\varepsilon (C))<k𝜔𝑋(𝜀(𝐶))<𝑘 and \omega _{Y}(\varepsilon (C))<k𝜔𝑌(𝜀(𝐶))<𝑘. Since each of X and Y is k-connected, we see that neither of s,t\in V(X)𝑠,𝑡∈𝑉(𝑋) and s,t\in V(Y)𝑠,𝑡∈𝑉(𝑌) occurs. Without loss of generality assume that s\in V(X{\setminus } Y)𝑠∈𝑉(𝑋∖𝑌) and t\in V(Y{\setminus } X)𝑡∈𝑉(𝑌∖𝑋). If some vertex v\in V(X\cap Y)𝑣∈𝑉(𝑋∩𝑌) belongs to T (resp., S), then C would be an s, v-cut with s,v\in V(X)𝑠,𝑣∈𝑉(𝑋) (resp., v, t-cut with v,t\in V(Y)𝑣,𝑡∈𝑉(𝑌)), contradicting the k-connectivity of X (resp., Y). Hence for the set R=V(M){\setminus } (S\cup T)𝑅=𝑉(𝑀)∖(𝑆∪𝑇), it holds V(X\cap Y)\subseteq R𝑉(𝑋∩𝑌)⊆𝑅. By the assumption of X\cap Y𝑋∩𝑌, the non-negativity and the monotonicity of \omega 𝜔, we have k\le \omega _{X\cap Y}(V(X\cap Y)) \le \omega _{X\cap Y}(R) \le \omega _{X\cup Y}(R)\le \omega _{X\cup Y}(\varepsilon (C))𝑘≤𝜔𝑋∩𝑌(𝑉(𝑋∩𝑌))≤𝜔𝑋∩𝑌(𝑅)≤𝜔𝑋∪𝑌(𝑅)≤𝜔𝑋∪𝑌(𝜀(𝐶)). This, however, contradicts \omega _{X\cup Y}(\varepsilon (C))<k𝜔𝑋∪𝑌(𝜀(𝐶))<𝑘. \square ◻

For a mixed graph (M,\omega )(𝑀,𝜔) with a meta-weight function and a real k\ge 0𝑘≥0, let {{\mathcal {C}}}(M,\omega ,k)\subseteq 2^{V(M)\cup E(M)}(𝑀,𝜔,𝑘)⊆2𝑉(𝑀)∪𝐸(𝑀) denote the family of k-connected subsets X\subseteq V(M)\cup E(M)𝑋⊆𝑉(𝑀)∪𝐸(𝑀) with \omega _X(V(X))\ge k𝜔𝑋(𝑉(𝑋))≥𝑘.

Lemma 11
For a mixed graph (M,\omega )(𝑀,𝜔) with a monotone meta-weight function and a real k\ge 0𝑘≥0, let {{\mathcal {C}}}={{\mathcal {C}}}(M,\omega ,k)=(𝑀,𝜔,𝑘). Then {{\mathcal {C}}} is confluent.

Proof
Let Z,X,Y\in {{\mathcal {C}}}𝑍,𝑋,𝑌∈ such that Z\subseteq X\cap Y𝑍⊆𝑋∩𝑌, where \omega _{X\cup Y}(V(X\cup Y))\ge \omega _{X\cup Y}(V(Z)) \ge \omega _{Z}(V(Z))\ge k𝜔𝑋∪𝑌(𝑉(𝑋∪𝑌))≥𝜔𝑋∪𝑌(𝑉(𝑍))≥𝜔𝑍(𝑉(𝑍))≥𝑘. By \omega _{Z}(V(Z))\ge k𝜔𝑍(𝑉(𝑍))≥𝑘 and

Lemma 10, X\cup Y𝑋∪𝑌 is k-connected. Since \omega _{X\cup Y}(V(X\cup Y))\ge k𝜔𝑋∪𝑌(𝑉(𝑋∪𝑌))≥𝑘, it holds that X\cup Y\in {{\mathcal {C}}}𝑋∪𝑌∈. Therefore {{\mathcal {C}}} is confluent. \square ◻

Construction of Monotone Meta-Weight Functions
This part shows a concrete method of constructing a monotone meta-weight function from a mixed graph with a standard weight function on the vertex and edge sets. We also present how to construct oracles L_11 and L_22 that are required when we apply the enumeration algorithm in Sect. 4.5 to the corresponding confluent system.

Let M be a mixed graph and w:V(M)\cup E(M)\rightarrow {\mathbb {R}}_+𝑤:𝑉(𝑀)∪𝐸(𝑀)→ℝ+ be a weight function. We define a coefficient function to be \gamma =(\alpha ,\overline{\alpha },\alpha ^+,\alpha ^-,\beta )𝛾=(𝛼,𝛼⎯⎯⎯,𝛼+,𝛼−,𝛽) that consists of functions

\alpha : E(M)\rightarrow {\mathbb {R}}_+𝛼:𝐸(𝑀)→ℝ+,

\overline{\alpha } : {\overline{E}}(M)\rightarrow {\mathbb {R}}_+𝛼⎯⎯⎯:𝐸⎯⎯⎯⎯(𝑀)→ℝ+,

\alpha ^+,\alpha ^- : \mathbf {E}(M)\rightarrow {\mathbb {R}}_+𝛼+,𝛼−:𝐄(𝑀)→ℝ+, and

\beta : V(M)\cup E(M) \rightarrow {\mathbb {R}}_+𝛽:𝑉(𝑀)∪𝐸(𝑀)→ℝ+.

We call \gamma 𝛾 monotone if

1\ge \alpha (e)\ge \overline{\alpha }(e)\ge \beta (e)1≥𝛼(𝑒)≥𝛼⎯⎯⎯(𝑒)≥𝛽(𝑒) for each undirected edge e\in {\overline{E}}(M)𝑒∈𝐸⎯⎯⎯⎯(𝑀),

1\ge \alpha (e)\ge \alpha ^+(e)\ge \beta (e)1≥𝛼(𝑒)≥𝛼+(𝑒)≥𝛽(𝑒) for each directed edge e\in \mathbf {E}(M)𝑒∈𝐄(𝑀);

1\ge \alpha (e)\ge \alpha ^-(e)\ge \beta (e)1≥𝛼(𝑒)≥𝛼−(𝑒)≥𝛽(𝑒) for each directed edge e\in \mathbf {E}(M)𝑒∈𝐄(𝑀); and

1\ge \beta (v)1≥𝛽(𝑣) for each vertex v\in V(M)𝑣∈𝑉(𝑀).

We call a tuple (M,w,\gamma )(𝑀,𝑤,𝛾) a system, and define a meta-weight function

\begin{aligned} \omega : 2^{V(M)\cup E(M)}\times (V(M)\cup E(M))\rightarrow {\mathbb {R}}_+ \end{aligned}

𝜔:2𝑉(𝑀)∪𝐸(𝑀)×(𝑉(𝑀)∪𝐸(𝑀))→ℝ+

to the system so that, for each subset X\subseteq V(M)\cup E(M)𝑋⊆𝑉(𝑀)∪𝐸(𝑀), \omega _X:V(M)\cup E(M) \rightarrow {\mathbb {R}}_+𝜔𝑋:𝑉(𝑀)∪𝐸(𝑀)→ℝ+ is given by

\begin{aligned} \omega _X(v)= \left\{ \begin{array}{ll} w(v) &{}{}\quad \text { if }\ v\in V(X), \\ \beta (v)w(v) &{}{}\quad \text { if }\ v\in V(M){\setminus } V(X), \end{array} \right. \\ \omega _X(e)= \left\{ \begin{array}{ll} w(e) &{}{}\quad \text { if }\ e \in E(M)\cap X, \\ \alpha (e)w(e) &{}{}\quad \text { if }\ e \in E(V(X),V(X)){\setminus } X, \\ \overline{\alpha }(e)w(e) &{}{}\quad \text { if }\ e\in {\overline{E}}(V(X),V(M){\setminus } V(X)), \\ \alpha ^+(e)w(e) &{}{}\quad \text { if }\ e\in \mathbf {E}(V(X),V(M){\setminus } V(X)),\\ \alpha ^-(e)w(e) &{}{}\quad \text { if }\ e\in \mathbf {E}(V(M){\setminus } V(X), V(X)), \\ \beta (e)w(e) &{}{}\quad \text { if }\ e \in E(V{\setminus } V(X),V{\setminus } V(X)). \end{array} \right. \end{aligned}

𝜔𝑋(𝑣)={𝑤(𝑣)𝛽(𝑣)𝑤(𝑣) if  𝑣∈𝑉(𝑋), if  𝑣∈𝑉(𝑀)∖𝑉(𝑋),𝜔𝑋(𝑒)=⎧⎩⎨⎪⎪⎪⎪⎪⎪𝑤(𝑒)𝛼(𝑒)𝑤(𝑒)𝛼⎯⎯⎯(𝑒)𝑤(𝑒)𝛼+(𝑒)𝑤(𝑒)𝛼−(𝑒)𝑤(𝑒)𝛽(𝑒)𝑤(𝑒) if  𝑒∈𝐸(𝑀)∩𝑋, if  𝑒∈𝐸(𝑉(𝑋),𝑉(𝑋))∖𝑋, if  𝑒∈𝐸⎯⎯⎯⎯(𝑉(𝑋),𝑉(𝑀)∖𝑉(𝑋)), if  𝑒∈𝐄(𝑉(𝑋),𝑉(𝑀)∖𝑉(𝑋)), if  𝑒∈𝐄(𝑉(𝑀)∖𝑉(𝑋),𝑉(𝑋)), if  𝑒∈𝐸(𝑉∖𝑉(𝑋),𝑉∖𝑉(𝑋)).

We call a system (M,w,\gamma )(𝑀,𝑤,𝛾) monotone if \gamma 𝛾 is monotone.

Lemma 12
For a monotone system (M,w,\gamma )(𝑀,𝑤,𝛾), the corresponding meta-weight function \omega : 2^{V(M)\cup E(M)}\times (V(M)\cup E(M))\rightarrow {\mathbb {R}}_+𝜔:2𝑉(𝑀)∪𝐸(𝑀)×(𝑉(𝑀)∪𝐸(𝑀))→ℝ+ is monotone.

Proof
Let X\subseteq Y\subseteq V(M)\cup E(M)𝑋⊆𝑌⊆𝑉(𝑀)∪𝐸(𝑀), where V(X)\subseteq V(Y)𝑉(𝑋)⊆𝑉(𝑌) holds. It suffices to show that \omega _Y(a)\ge \omega _X(a)𝜔𝑌(𝑎)≥𝜔𝑋(𝑎) for any element a\in V(M)\cup E(M)𝑎∈𝑉(𝑀)∪𝐸(𝑀). For each vertex v\in V(M)𝑣∈𝑉(𝑀), we see that \omega _Y(v) =\omega _X(v)+|\{v\}\cap (V(Y){\setminus } V(X))|(1-\beta (v))w(v) \ge \omega _X(v)𝜔𝑌(𝑣)=𝜔𝑋(𝑣)+|{𝑣}∩(𝑉(𝑌)∖𝑉(𝑋))|(1−𝛽(𝑣))𝑤(𝑣)≥𝜔𝑋(𝑣).

For each edge e\in E(M)𝑒∈𝐸(𝑀) with end-vertices u and v, we see that (i) \omega _Y(e)=\omega _X(e)+(1-\alpha )|\{e\}\cap (Y{\setminus } X)|w(e)\ge \omega _X(e)𝜔𝑌(𝑒)=𝜔𝑋(𝑒)+(1−𝛼)|{𝑒}∩(𝑌∖𝑋)|𝑤(𝑒)≥𝜔𝑋(𝑒) if u,v\in V(X)𝑢,𝑣∈𝑉(𝑋); and (ii) \omega _Y(e)=\omega _X(e)+\Delta |\{u,v\}\cap (V(Y){\setminus } V(X))| w(e)\ge \omega _X(e)𝜔𝑌(𝑒)=𝜔𝑋(𝑒)+Δ|{𝑢,𝑣}∩(𝑉(𝑌)∖𝑉(𝑋))|𝑤(𝑒)≥𝜔𝑋(𝑒) otherwise, where \Delta Δ is one of 1-\overline{\alpha }(e)1−𝛼⎯⎯⎯(𝑒), 1- \alpha ^+(e)1−𝛼+(𝑒), 1-\alpha ^-(e)1−𝛼−(𝑒), \alpha (e)-\overline{\alpha }(e)𝛼(𝑒)−𝛼⎯⎯⎯(𝑒), \alpha (e)- \alpha ^+(e)𝛼(𝑒)−𝛼+(𝑒), \alpha (e)-\alpha ^-(e)𝛼(𝑒)−𝛼−(𝑒), (\alpha (e)-\beta (e))/2(𝛼(𝑒)−𝛽(𝑒))/2, \overline{\alpha }(e)-\beta (e)𝛼⎯⎯⎯(𝑒)−𝛽(𝑒), \alpha ^+(e)-\beta (e)𝛼+(𝑒)−𝛽(𝑒), \alpha ^-(e)-\beta (e)𝛼−(𝑒)−𝛽(𝑒) and (1-\beta (e))/2(1−𝛽(𝑒))/2. \square ◻

For a system (M,w,\gamma )(𝑀,𝑤,𝛾) on a mixed graph M with n vertices and m edges and a real k\ge 0𝑘≥0, let \mathrm {tm}(n,m,k)tm(𝑛,𝑚,𝑘) and \mathrm {sp}(n,m,k)sp(𝑛,𝑚,𝑘) respectively denote the time and space complexities for testing if \mu (u,v;X)<k𝜇(𝑢,𝑣;𝑋)<𝑘 holds or not for two vertices u,v\in V(M)𝑢,𝑣∈𝑉(𝑀) and a subset X\subseteq V(M)\cup E(M)𝑋⊆𝑉(𝑀)∪𝐸(𝑀).

Lemma 13
For a monotone system (M,w,\gamma )(𝑀,𝑤,𝛾), let \omega 𝜔 be the corresponding monotone meta-weight function.

(i)
\mathrm {tm}(n,m,k)=O(mn\log n)tm(𝑛,𝑚,𝑘)=𝑂(𝑚𝑛log𝑛) and \mathrm {sp}(n,m,k)=O(n+m)sp(𝑛,𝑚,𝑘)=𝑂(𝑛+𝑚); and

(ii)
Let X\subseteq Y\subseteq V(M)\cup E(M)𝑋⊆𝑌⊆𝑉(𝑀)∪𝐸(𝑀) be non-empty subsets such that \omega _X(V(X))\ge k𝜔𝑋(𝑉(𝑋))≥𝑘 and \mu (u,u';Y)\ge k𝜇(𝑢,𝑢′;𝑌)≥𝑘 for all vertices u,u'\in V(X)𝑢,𝑢′∈𝑉(𝑋). Given a vertex t\in V(Y){\setminus } V(X)𝑡∈𝑉(𝑌)∖𝑉(𝑋), whether there is a vertex u\in V(X)𝑢∈𝑉(𝑋) such that \mu (u,t;Y)<k𝜇(𝑢,𝑡;𝑌)<𝑘 or not can be tested in \mathrm {tm}(n,m,k)tm(𝑛,𝑚,𝑘) time and \mathrm {sp}(n,m,k)sp(𝑛,𝑚,𝑘) space.

Proof
(i) The problem of computing \mu (s,t;X)𝜇(𝑠,𝑡;𝑋) can be formulated as a problem of finding a maximum flow in a weighted graph (M,\omega _X)(𝑀,𝜔𝑋) with an edge-capacity \omega _X(e)𝜔𝑋(𝑒), e\in E(M)𝑒∈𝐸(𝑀) and a vertex-capacity \omega _X(v)𝜔𝑋(𝑣), v\in V(M), and \mu (s,t;X) can be computed in O(mn\log n) time and O(n+m) space by using the maximum flow algorithm [2, 3]. Hence \mathrm {tm}(n,m,k)=O(mn\log n) and \mathrm {sp}(n,m,k)=O(n+m).

(ii) Let t\in V(Y){\setminus } V(X). To find a vertex u\in V(X) with \mu (u,t;Y)<k if any by using (i) only once, we augment the weighted graph (M,\omega _Y) into another weighted graph (M^*,\omega _Y) with a new vertex s^* and |V(X)| new directed edges e_u=(s^*,u), u\in V(X) such that \omega _Y(e_u):=k. We claim that \mu (u,t;Y)\ge k for all vertices u\in V(X) in (M,\omega _Y) if and only if \mu (s^*,t;Y)\ge k in (M^*,\omega _Y).

First consider the case of \mu (s^*,t;Y)< k in (M^*, \omega _Y); i.e., the graph (M^*,\omega _Y) has an s^*,t-cut C^*=(S,T) with \omega _Y(\varepsilon (C^*))<k, where s^*\in S and t\in T. Let R=V(M^*){\setminus } (S\cup T), where R=V(M){\setminus } (S\cup T). Note that X\subseteq S\cup R, since otherwise u\in T\cap V(X) would mean that e_u=(s^*,u)\in E(S,T) and \omega _Y(\varepsilon (C^*))\ge \omega _Y(e_u)= k, contradicting that \omega _Y(\varepsilon (C^*))<k. Also S\cap V(X)\ne \emptyset , since otherwise V(X)\subseteq R would mean that \omega _Y(\varepsilon (C^*))\ge \omega _Y(R) \ge \omega _X(V(X))\ge k, contradicting that \omega _Y(\varepsilon (C^*))<k. Let u\in S\cap V(X). Then C=(S{\setminus }\{s^*\},T) is a u, t-cut in (M,\omega _Y) with \omega _Y(\varepsilon (C))\le \omega _Y(\varepsilon (C^*))<k. This means that \mu (u,t;Y)<k.

Next consider the case of \mu (s^*,t;Y)\ge k in (M^*, \omega _Y). In this case, we show that \mu (u,t;Y)\ge k for all vertices u\in V(X). To derive a contradiction, assume that \mu (u,t;Y)<k for some vertex u\in V(X); i.e., the graph (M, \omega _Y) has a u, t-cut C=(S,T) with \omega _Y(\varepsilon (C))<k. Note that T\cap V(X)=\emptyset , since otherwise u'\in T\cap V(X) would contradict the assumption that \mu (u,u';Y)\ge k holds for all vertices u,u'\in V(X).

Then C'=(S'=S\cup \{s^*\},T) is an s^*,t-cut in (M^*, \omega _Y), and satisfies \omega _Y(\varepsilon (C'))=\omega _Y(\varepsilon (C))<k since T\cap V(X)=\emptyset . This, however, contradicts that \mu (s^*,t;Y)\ge k holds in (M^*, \omega _Y).

By the claim, it suffices to test if \mu (s^*,t;Y)\ge k or not in \mathrm {tm}(n,m,k) time and \mathrm {sp}(n,m,k) space. \square

Construction of Oracles
We denote by {{\mathcal {C}}}(M,w,\gamma ,k) the family of k-connected sets X with \omega _X(V(X))\ge k in a system (M,w,\gamma ). By Lemmas 11 and 12, {{\mathcal {C}}}(M,w,\gamma ,k) is confluent. Let \Lambda \subseteq V(M)\cup E(M) be a subset. Let {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ) denote the family of components X\in {{\mathcal {C}}}(M,w,\gamma ,k) such that X\subseteq \Lambda , where we see that {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ) is also confluent.

We consider how to construct oracles \mathrm {L}_1 and \mathrm {L}_2 to the confluent system. For two non-empty subsets X\subseteq Y\subseteq \Lambda , let {{\mathcal {C}}}_{\mathrm{max}}(Y) denote the family of maximal subsets Z\in {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ) such that Z\subseteq Y, and let C_k(X;Y) denote a maximal set X^*\in {{\mathcal {C}}}_{\mathrm{max}}(Y) such that X\subseteq X^*; and C_k(X;Y)\triangleq \emptyset if no such set X^* exists.

Lemma 14
For a monotone system (M,w,\gamma ,\Lambda ), let \omega denote the corresponding monotone meta-weight function. Let X\subseteq Y\subseteq \Lambda be non-empty subsets such that \omega _X(V(X))\ge k. Then

(i)
X^*=C_k(X;Y) is uniquely determined;

(ii)
If there are vertices u\in V(X) and v\in V(Y) such that \mu (u,v;Y)<k, then v\not \in V(X^*);

(iii)
Assume that \mu (u,v;Y)\ge k for all vertices u\in V(X) and v\in V(Y){\setminus } V(X). Then C_k(X;Y)=Y if \mu (u,u';Y)\ge k for all vertices u,u'\in V(X); and C_k(X;Y)=\emptyset otherwise; and

(iv)
C_k(X;Y) can be found in O(|Y|^2 \mathrm {tm}(n,m,k)) time and O(\mathrm {sp}(n,m,k) +|Y|) space.

Proof
(i) To derive a contradiction, assume that there are two maximal sets X_1,X_2\in {{\mathcal {C}}}_{\mathrm{max}}(Y) such that X\subseteq X_1\cap X_2. From this and the monotonicity of \omega , it holds that \omega _{X_1\cup X_2}(V(X_1\cup X_2))\ge \omega _{X_1\cap X_2}(V(X_1\cap X_2)) \ge \omega _X(V(X))\ge k. From this and Lemma 10, X_1\cup X_2 is also k-connected and X_1\cup X_2\in {{\mathcal {C}}}_{\mathrm{max}}(Y), contradicting the maximality of X_1 and X_2. Therefore C_k(X;Y) is unique.

(ii) When C_k(X;Y)=\emptyset , v\not \in C_k(X;Y) is trivial. Assume that C_k(X;Y)=X^*\in {{\mathcal {C}}}_{\mathrm{max}}(Y). By the monotonicity of \omega and X^*\subseteq Y, it holds that \mu (u,v;X^*)\le \mu (u,v;Y) <k. Hence u,v\in V(X^*) would contradict the k-connectivity of X^*. Since u\in V(X^*), we have v\not \in V(X^*).

(iii) Obviously if \mu (u,u';Y)< k for some vertices u,u'\in V(X), then no subset Y' of Y with X\subseteq Y' can be k-connected, and C_k(X;Y)=\emptyset . Assume that \mu (u,u';Y)\ge k for all vertices u,u'\in V(X). By the monotonicity of \omega and X\subseteq Y, it holds that \omega _{Y}(V(Y))\ge \omega _X(V(X))\ge k. To prove that C_k(X;Y)=Y, it suffices to show that \mu (u,v;Y)\ge k for all pairs of vertices u,v\in V(Y). By assumption, \mu (u,v;Y)\ge k for all vertices u\in V(X) and v\in V(Y). To derive a contradiction, assume that there is a pair of vertices s,t\in V(Y){\setminus } V(X) with \mu (s,t;Y)< k; i.e., there is an s, t-cut C=(S,T) with \omega _Y(\varepsilon (C))<k. Let R=V(M){\setminus } S\cup T.

We observe that V(X)\subseteq R, since u\in V(X)\cap S (resp., u\in V(X)\cap T) would imply that C is a u, t-cut (resp., s, u-cut), contradicting that \mu (u,v;Y)\ge k for all vertices v\in V(Y){\setminus } V(X). By the monotonicity of \omega and V(X)\subseteq R, it would hold that k\le \omega _X(V(X))\le \omega _Y(R)\le \omega _Y(\varepsilon (C))<k, a contradiction.

(iv) We can find C_k(X;Y) as follows. Based on (ii), we first remove the set Z_V of all vertices t\in V(M)\cap (Y{\setminus } X) such that \mu (u,t;Y)<k for some vertex u\in V(X) and the set Z_E of all edges e\in E(M)\cap (Y{\setminus } X) such that \mu (u,t;Y)<k for some vertices u\in V(X) and t\in V(\{e\}) so that C_k(X;Y)=C_k(X;Y') holds for Y'=Y{\setminus } (Z_V\cup Z_E). For a fixed vertex t\in V(M)\cap (Y{\setminus } X) or t\in V(\{e\}) with an edge e\in E(M)\cap (Y{\setminus } X), we can test if there is a vertex u\in X such that \mu (u,t;Y)<k or not in O(\mathrm {tm}(n,m,k)) time and O(\mathrm {sp}(n,m,k)) space by Lemma 13(ii). Hence finding such a set Z_V\cup Z_E takes O(|Y{\setminus } X|\mathrm {tm}(n,m,k)) time and O(\mathrm {sp}(n,m,k)+|Z_V\cup Z_E|) space. We repeat the above procedure until there is no pair of vertices u\in V(X) and v\in V(Y'){\setminus } V(X) after executing at most |Y{\setminus } X| repetitions taking O(|Y{\setminus } X|^2\mathrm {tm}(n,m,k)) time and O(\mathrm {sp}(n,m,k)+|Y{\setminus } X|) space.

figure e
Based on (iii), we finally conclude that C_k(X;Y)=Y' (C_k(X;Y)=\emptyset ) if there is not pair of vertices u,u'\in V(X) such that \mu (u,u';Y')<k (resp., otherwise), which takes O(|X|^2\mathrm {tm}(n,m,k)) time and O(\mathrm {sp}(n,m,k)) space by Lemma 13(i). An entire algorithm is described in Algorithm 5. The time and space complexities are then O(|Y|^2\mathrm {tm}(n,m,k)) time and O(\mathrm {sp}(n,m,k) +|Y|), respectively. \square

By the lemma, oracle \mathrm {L}_1(X;Y) to a monotone system (M,w,\gamma ) runs in \theta _{\mathrm {1,t}}=O(|Y|^2\mathrm {tm}(n,m,k)) time and \theta _{\mathrm {1,s}}=O(\mathrm {sp}(n,m,k) +|Y|) space.

For a system (M,w,\gamma ,\Lambda ), we define a k-core of a subset Y\subseteq \Lambda to be a subset Z of Y such that \omega _Z(V(Z))\ge k and any proper subset Z' of Z satisfies \omega _{Z'}(V(Z'))< k.

Lemma 15
Let (M,w,\gamma ,\Lambda ) be a monotone system, and Y be a subset of \Lambda . For the family \mathcal {K} of all k-cores of Y, it holds that {{\mathcal {C}}}_{\mathrm{max}}(Y)= \bigcup _{Z\in \mathcal {K}} \{C_k(Z;Y)\} and |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |\mathcal {K}|. Given \mathcal {K}, {{\mathcal {C}}}_{\mathrm{max}}(Y) can be obtained in O(|\mathcal {K}|( |Y|^2 \mathrm {tm}(n,m,k)+|Y|\log |\mathcal {K}|)) time and O(\mathrm {sp}(n,m,k)+|\mathcal {K}|\cdot |Y|) space.

Proof
Clearly each set X\in {{\mathcal {C}}}_{\mathrm{max}}(Y) satisfies \omega _X(V(X))\ge k and contains a k-core Z\in \mathcal {K}, where C_k(Z;Y)\ne \emptyset and C_k(Z;Y)=X holds by the uniqueness in Lemma 14(i). Therefore {{\mathcal {C}}}_{\mathrm{max}}(Y)=\bigcup _{Z\in \mathcal {K}} \{C_k(Z;Y)\}, from which |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |\mathcal {K}| follows. Given \mathcal {K}, we compute C_k(Z;Y) for each set Z\in \mathcal {K} taking O(|Y|^2 \mathrm {tm}(n,m,k)) time and O(\mathrm {sp}(n,m,k)+|Y|) space by Lemma 14(iv). We can test if the same set X\in {{\mathcal {C}}}_{\mathrm{max}}(Y) has been generated or not in O(|Y|\log |\mathcal {K}|) time and O(|\mathcal {K}|\cdot |Y|) space. Therefore \mathcal {X} can be constructed in O(|\mathcal {K}|( |Y|^2 \mathrm {tm}(n,m,k)+|Y|\log |\mathcal {K}|)) time and O(\mathrm {sp}(n,m,k)+|\mathcal {K}|\cdot |Y|) space. \square

By the lemma, oracle \mathrm {L}_2(Y) to a monotone system (M,w,\gamma ,\Lambda ) runs in \theta _{\mathrm {2,t}}=O(|\mathcal {K}|( |Y|^2 \mathrm {tm}(n,m,k) +|Y|\log |\mathcal {K}|)) time and \theta _{\mathrm {2,s}}=O(\mathrm {sp}(n,m,k)+|\mathcal {K}|\cdot |Y|) space, where we assume that the family \mathcal {K} of k-cores of Y is given as input.

Connector Enumeration Problem
Recall the connector enumeration problem that we introduced in Sect. 2.1. The problem can be treated as the case where G is an undirected graph and {{\mathcal {C}}} is the family of all vertex subsets that induce connected subgraphs.

Formulation by Confluent System
Let us consider formulating the connector enumeration problem by means of a confluent system. For a given instance (G,I,\sigma ) of the connector enumeration problem, let {{\mathcal {C}}}_G denote the family of all vertex subsets X such that the induced subgraph G[X] is connected, where we regard G[X] with |X|=1 (resp., X=\emptyset ) as connected (resp., disconnected). We see that (V(G),{{\mathcal {C}}}_G) is a confluent system since, for any X,Y\in {{\mathcal {C}}}_G, G[X\cup Y] is connected whenever there is a subset S\subseteq X\cap Y such that S\in {{\mathcal {C}}}_G.

Let n=|V(G)| and m=|E(G)|. We can implement the oracles L_1 and L_2 so that they run in O(n+m) time and space (i.e., \theta _{i,\mathrm {t}}=O(n+m), i=1,2, and \theta _{i,\mathrm {s}}=O(n+m), i=1,2) since they are realized by conventional graph search (e.g., DFS or BFS). We can take the upper bound \delta (Y)=|Y|, which exactly satisfies our assumption that \delta (X)\le \delta (Y) holds for subsets X\subseteq Y\subseteq V.

For any X\subseteq V, the followings are equivalent:

X is a connector for (G,I,\sigma ); and

X is a solution for the instance (V(G),{{\mathcal {C}}}_G,I,\sigma ).

In Fig. 4, we show the Hasse diagram of the confluent system (V(G),{{\mathcal {C}}}_G) for the instance (G,I,\sigma ) in Fig. 1, along with the solutions for (V(G),{{\mathcal {C}}}_G,I,\sigma ).

Fig. 4
figure 4
Hasse diagram of the confluent system (V,{{\mathcal {C}}}_G) of the instance (V(G),{{\mathcal {C}}}_G,I,\sigma ) from Fig. 1, where common item sets are indicated by integers and solutions are indicated by shade

Full size image

Theorem 2
Given an instance (G,I,\sigma ) of the connector enumeration problem in a graph G, all connectors can be enumerated in O(q^2(n+m)n) delay and O((q+n+m)n) space, where n=|V(G)|, m=|E(G)| and q=|I|.

Proof
The connector enumeration problem for (G,I,\sigma ) is solved by enumerating all solutions for the instance (V(G),{{\mathcal {C}}}_G,I,\sigma ). For the confluent system (V(G),{{\mathcal {C}}}_G), we see that \theta _{i,\mathrm {t}}=O(n+m), i=1,2, \theta _{i,\mathrm {s}}=O(n+m), i=1,2, and \delta (Y)=O(|Y|)=O(n). By Theorem 1, we can enumerate all solutions in {{\mathcal {S}}} in O(q^2(n+m)n) delay and in O((q+n+m)n) space. \square

Enumerating Connectors Under Various Connectivity Conditions
In addition to the system (V(G),{{\mathcal {C}}}_G), we may obtain an alternative confluent system by selecting a different notion of connectivity such as the edge- or vertex-connectivity on a digraph or an undirected graph. This section presents two examples of confluent systems based on high graph connectivity using the result in Sect. 5.

Edge- and Vertex-Connectivity in Mixed Graph
Let G be a mixed graph with n vertices and m edges. We define a path from a vertex u to a vertex v (or a u, v-path) in G to be a subgraph P of G such that V(P)=\{v_1~(=u),v_2,\ldots ,v_p~(=v)\}, E(P)=\{e_1,e_2,\ldots ,e_{p-1}\} and e_i=v_iv_{i+1}\in {\overline{E}}(P) or e_i=(v_i,v_{i+1})\in \mathbf {E}(P). Let s,t\in V(G) be two vertices in G. Let \lambda (s,t;G) denote the minimum size |F| of a subset F\subseteq E(G) so that the graph G-F obtained from G by removing edges in F has no s, t-path. Let \kappa (s,t;G) denote the minimum size |S| of a subset S\subseteq E(G)\cup (V(G){\setminus }\{s,t\}) to be removed from G so that the graph G-S obtained from G by removing vertices and edges in S has no s, t-path, where such a minimum subset S can be chosen so that S{\setminus } E(s,t)\subseteq V(G). By Menger’s theorem [23], \lambda (s,t;G) (resp., \kappa (s,t;G)) is equal to the maximum number of edge-disjoint (resp., internally disjoint) s, t-paths. We can test whether \lambda (s,t;G)\ge k (resp., \kappa (s,t;G)\ge k) or not in O(\min \{k,n\}m) (resp., O(\min \{k,n^{1/2}\}m)) time [2, 3]. A graph G is called k-edge-connected if |V(G)|\ge 1 and \lambda (u,v;G)\ge k for any two vertices u,v\in V(G). A graph G is called k-vertex-connected if |V(G)|\ge k+1 and \kappa (u,v;G)\ge k for any two vertices u,v\in V(G). In the following, we show two examples of confluent systems based on graph connectivity.

Vertex Subsets Highly-Connected Over the Entire Graph
Given a mixed graph G, we define “k-connected set” based on the connectivity of the entire graph G. Let us call a subset X\subseteq V(G) k-edge-connected if |X|=1 or for any two vertices u,v\in X, \lambda (u,v;G)\ge k. Let {{\mathcal {C}}}_{k,\mathrm {edge}} denote the family of k-edge-connected sets in G. Let us call a subset X\subseteq V(G) k-vertex-connected if |X|\ge k+1 and, for any two vertices u,v\in X, \kappa (u,v;G)\ge k. Let {{\mathcal {C}}}_{k,\mathrm {vertex}} denote the family of k-vertex-connected sets in G.

Lemma 16
Let G be a mixed graph and k\ge 0 be an integer, where n=|V(G)| and m=|E(G)|.

(i)
The family {{\mathcal {C}}}={{\mathcal {C}}}_{k,\mathrm {edge}} is confluent. For any non-empty subsets X\subseteq Y\subseteq V(G), it holds |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |Y|, and oracles \mathrm {L}_1(X;Y) and \mathrm {L}_2(Y) can be implemented so that they run in O(n^2) time and space after an O(n^2\min \{k,n\}m)-time and O(n^2)-space preprocessing; and

(ii)
The family {{\mathcal {C}}}={{\mathcal {C}}}_{k,\mathrm {vertex}} is confluent. For any non-empty subsets X\subseteq Y\subseteq V(G), it holds |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le {{|Y|}\atopwithdelims (){k}}, oracle \mathrm {L}_1(X;Y) can be implemented so that it runs in O(n^2) time and O(n^2) space, and oracle \mathrm {L}_2(Y) can be implemented so that it runs in O(|Y|^{k}n^2) time and O(|Y|^{k}n) space, after an O(n^2\min \{k,n^{1/2}\}m)-time and O(n^2)-space preprocessing.

Proof
Let (M,w,\gamma ,k,\Lambda ) be a system such that a mixed graph M:=G, \Lambda :=V(G), and a weight function w and a coefficient function \gamma =(\alpha ,\overline{\alpha },\alpha ^+,\alpha ^-,\beta ) such that \alpha (e):=\overline{\alpha }(e):=\alpha ^+(e):=\alpha ^-(e):=1 for each edge e\in E(G), and \beta (a):=1 for each element a\in V(G)\cup E(G), where we see that \gamma is monotone and the family {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ) is confluent by Sects. 11 and 12.

(i) We set weight w so that w(e):=1 for each edge e\in E(G) and w(v):=k for each vertex v\in V(G). We claim that {{\mathcal {C}}}_{k,\mathrm {edge}} is equal to {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), where the latter is the family of non-empty subsets X\subseteq \Lambda with \omega _X(V(X))\ge k such that |V(X)|=1 or \mu (u,v;X)\ge k for each pair of vertices u,v\in V(X). Note that \omega _X(V(X))\ge w(V(X))=k|X| for any non-empty set X\subseteq \Lambda . Then every set X\subseteq V(G) with |X|=1 belongs to both {{\mathcal {C}}}_{k,\mathrm {edge}} and {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ).

Let X be a subset of V(G) with |V(X)|=|X|\ge 2. By definition of coefficient function \gamma and weight w in G, we see that \mu (u,v;X)=\lambda (u,v;G) holds for any two vertices u,v\in V(X). This means that {{\mathcal {C}}}_{k,\mathrm {edge}}={{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), proving the claim.

We define the auxiliary graph G_{k,\mathrm {edge}}^* to be an undirected graph such that

V(G_{k,\mathrm {edge}}^*)=V(G), and

E(G_{k,\mathrm {edge}}^*) =\{uv\mid u,v\in V(G) \text{ with } \lambda (u,v;G)\ge k{ and}\lambda (v,u;G)\ge k \}.

We can construct G_{k,\mathrm {edge}}^* in O(n^2\min \{k,n\}m) time and O(n^2) space. Observe that a non-empty subset X\subseteq V(G) belongs to {{\mathcal {C}}}_{k,\mathrm {edge}} if and only if w(X)\ge k and X forms a clique in G_{k,\mathrm {edge}}^*. For edge-connectivity, we easily see that \lambda (x,y;G), \lambda (y,x;G), \lambda (y,z;G), \lambda (z,y;G)\ge k imply \lambda (x,z;G), \lambda (z,x;G)\ge k. Hence G_{k,\mathrm {edge}}^* is a disjoint union of cliques, and for {{\mathcal {C}}}={{\mathcal {C}}}_{k,\mathrm {edge}}, the family {{\mathcal {C}}}_{\mathrm{max}}(Y) is also a disjoint union of cliques in the induced subgraph G_{k,\mathrm {edge}}^*[Y]. This means that |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |Y| holds and {{\mathcal {C}}}_{\mathrm{max}}(Y) is found in O(n^2) time as the set of connected components in G_{k,\mathrm {edge}}^*.

For {{\mathcal {C}}}={{\mathcal {C}}}_{k,\mathrm {edge}}, \mathrm {L}_1(X;Y) and \mathrm {L}_2(Y) run in O(n^2) time and space after an O(n^2\min \{k,n\}m)-time and O(n^2)-space preprocessing.

(ii) We set weight w so that w(e):=1 for each edge e\in E(G) and w(v):=1 for each vertex v\in V(G). We claim that {{\mathcal {C}}}_{k,\mathrm {vertex}} is equal to {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ). Note that \omega _X(V(X))= w(V(X))=|X| for any non-empty set X\subseteq \Lambda . Let X be a subset of V(G) with |V(X)|=|X|<k. Then X is not k-vertex-connected in G and X is not k-connected in the system (M,w,\gamma ,k,\Lambda ).

Let X be a subset of V(G) with |V(X)|=|X|\ge k. By definition of coefficient function \gamma and weight w in G, we see that \mu (u,v;X)=\kappa (u,v;G) holds for any two vertices u,v\in V(X). This means that {{\mathcal {C}}}_{k,\mathrm {vertex}}={{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), proving the claim.

We define the auxiliary graph G_{k,\mathrm {vertex}}^* to be an undirected graph such that

V(G_{k,\mathrm {vertex}}^*)=V(G), and

E(G_{k,\mathrm {vertex}}^*) =\{uv\mid u,v\in V(G) \text{ with } \kappa (u,v;G)\ge k{ and}\kappa (v,u;G)\ge k \}.

We can construct G_{k,\mathrm {vertex}}^* in O(n^2\min \{k,n^{1/2}\}m) time and O(n^2) space. Observe that a non-empty subset X\subseteq V(G) belongs to {{\mathcal {C}}}_{k,\mathrm {vertex}} if and only if w(X)\ge k and X forms a clique in G_{k,\mathrm {vertex}}^*.

Let {{\mathcal {C}}}={{\mathcal {C}}}_{k,\mathrm {vertex}}. For subsets X\subseteq Y\subseteq V(G) such that |X|\ge k, a maximal set Z \in {{\mathcal {C}}}_{\mathrm{max}}(Y) with X\subseteq Z is the unique set C_k(X;Y) by Lemma 14. Hence C_k(X;Y) can be found in O(n^2) time and space by constructing the unique maximal clique containing X in the induced subgraph G_{k,\mathrm {vertex}}^*[Y]. Let \mathcal {K} be the family of k-cores; i.e., subsets of exactly k vertices in Y, which can be constructed in O(|Y|^k) time.

By Lemma 15, |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |\mathcal {K}|={{|Y|}\atopwithdelims (){k}} holds, and we can construct {{\mathcal {C}}}_{\mathrm{max}}(Y) by computing C_k(Z;Y) for all sets Z\in \mathcal {K}, taking O(|Y|^{k}n^2) time and O(|Y|^{k}n) space.

\square

Using Theorem 1 and Lemma 16, we have the following theorem on the time delay and the space complexity of enumeration of connectors that are k-edge-connected or k-vertex-connected.

Theorem 3
Let (G,I,\sigma ) be an instance on a mixed graph G and k\ge 0 be an integer, where n=|V(G)|, m=|E(G)|, and q=|I|.

(i)
All k-edge-connected connectors can be enumerated in O(q^2n^3) delay and O(qn+n^3) space, after an O(n^2\min \{k,n\}m)-time and O(n^2)-space preprocessing.

(ii)
All k-vertex-connected connectors can be enumerated in O(q^2n^{k+2}) delay and O(qn+n^{k+2}) space, after an O(n^2\min \{k,n^{1/2}\}m)-time and O(n^2)-space preprocessing.

Proof
Recall that, for Y\subseteq V, \delta (Y) denotes an upper bound on |{{\mathcal {C}}}_{\max }(Y)|. In both (i) and (ii), \theta _{\rho ,\mathrm {t}} and \theta _{\rho , \mathrm {s}} can be regarded as O(1) since the volume function is not used anywhere in this context.

(i) By Lemma 16(i), we have \theta _{1,\mathrm {t}}=\theta _{2,\mathrm {t}}=O(n^2) and \theta _{1,\mathrm {s}}=\theta _{2,\mathrm {s}}=O(n^2), and we can set \delta (Y)=n for any Y\subseteq V. By Theorem 1, we have the time delay O\big (q\theta _{2,\mathrm {t}} + (q(n+\theta _{1,\mathrm {t}})+\theta _{\rho ,\mathrm {t}})q \delta (V)\big ) =O(q^2n^3) and the space complexity O\big ((q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}} + \theta _{\rho ,\mathrm {s}}) n\big ) =O(qn+n^3).

(ii) By Lemma 16(ii), we have \theta _{1,\mathrm {t}}=O(n^2), \theta _{2,\mathrm {t}}=O(n^{k+2}), \theta _{1,\mathrm {s}}=O(n^2), and \theta _{2,\mathrm {s}}=O(n^{k+1}), and we can set \delta (Y)=n^k for any Y\subseteq V. By Theorem 1, we have the time delay O\big (q\theta _{2,\mathrm {t}} +(q(n+\theta _{1,\mathrm {t}})+\theta _{\rho ,\mathrm {t}})q \delta (V)\big ) =O(q^2n^{k+2}) and the space complexity O\big ((q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}} + \theta _{\rho ,\mathrm {s}}) n\big ) =O(qn+n^{k+2}).

For preprocessing, the time and space complexities are immediate from Lemma 16 both for (i) and (ii). \square

Highly-Connected Induced Subgraphs
Given a mixed graph G, we define a “k-connected set” X based on the connectivity of the induced graph G[X]. Define {{\mathcal {C}}}_{k,\mathrm {edge}}^{\mathrm {in}} to be the family (resp., {{\mathcal {C}}}_{k,\mathrm {vertex}}^{\mathrm {in}}) of subsets X\subseteq V(G) such that the induced graph G[X] is k-edge-connected (resp., k-vertex-connected).

Lemma 17
Let G be a mixed graph and k\ge 0 be an integer, where n=|V(G)| and m=|E(G)|.

(i)
The family {{\mathcal {C}}}={{\mathcal {C}}}_{k,\mathrm {edge}}^{\mathrm {in}} is confluent. For any non-empty subsets X\subseteq Y\subseteq V(G), it holds |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |Y|, oracle \mathrm {L}_1(X;Y) can be implemented so that it runs in O(|Y|^2\min \{k\!+\!1,n\}m) time and O(n^2) space, and \mathrm {L}_2(Y) can be implemented so that it runs in O(|Y|^3\min \{k\!+\!1,n\}m) time and O(n^2) space.

(ii)
The family {{\mathcal {C}}}={{\mathcal {C}}}_{k,\mathrm {vertex}}^{\mathrm {in}} is confluent. For any non-empty subsets X\subseteq Y\subseteq V(G), it holds |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le {{|Y|}\atopwithdelims (){k}}, oracle \mathrm {L}_1(X;Y) can be implemented so that it runs in O(|Y|^2\min \{k\!+\!1,n^{1/2}\}m) time and O(n^2) space, and oracle \mathrm {L}_2(Y) can be implemented so that it runs in O(|Y|^{k+2}\min \{k\!+\!1,n^{1/2}\}m) time and O(|Y|^{k}n) space.

Proof
Let (M,w,\gamma ,k,\Lambda ) be a system such that a mixed graph M:=G, \Lambda :=V(G), a weight function w and a coefficient function \gamma =(\alpha ,\overline{\alpha },\alpha ^+,\alpha ^-,\beta ) such that \alpha (e):=1 and \overline{\alpha }(e):=\alpha ^+(e):=\alpha ^-(e):=0 for each edge e\in E(G), and \beta (a):=0 for each element a\in V(G)\cup E(G), where we see that \gamma is monotone and the family {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ) is confluent by Lemmas 11 and 12.

(i) We set weight w so that w(e):=1 for each edge e\in E(G) and w(v):=k for each vertex v\in V(G). We claim that {{\mathcal {C}}}_{k,\mathrm {edge}}^{\mathrm {in}} is equal to {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), where the latter is the family of non-empty subsets X\subseteq \Lambda with \omega _X(V(X))\ge k such that |V(X)|=1 or \mu (u,v;X)\ge k for each pair of vertices u,v\in V(X). Note that \omega _X(V(X))\ge w(V(X))=k|X| for any non-empty set X\subseteq \Lambda . Then every set X\subseteq V(G) with |X|=1 belongs to both {{\mathcal {C}}}_{k,\mathrm {edge}}^{\mathrm {in}} and {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ).

Let X be a subset of V(G) with |V(X)|=|X|\ge 2. By definition of coefficient function \gamma and weight w in G, we see that \mu (u,v;X)=\lambda (u,v;G[X]) holds for any two vertices u,v\in V(X). Hence G[X] is a k-edge-connected graph if and only if \mu (u,v;X)=\lambda (u,v;G[X])\ge k for any two vertices u,v\in V(X). This means that {{\mathcal {C}}}_{k,\mathrm {edge}}^{\mathrm {in}}={{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), proving the claim.

Whether \mu (s,t;X)\ge k (i.e., \lambda (s,t;G[X]),\lambda (t,s;G[X])\ge k) or not for a subset X\subseteq V(G) can be tested in O(\min \{k,n\}m) time [2, 3]. By Lemma 14(iv), \mathrm {L}_1(X;Y) runs in O(|Y|^2\min \{k\!+\!1,n\}m) time and O(n^2) space. The family \mathcal {K} of k-cores Z\subseteq Y is \{\{v\}\mid v\in Y\}. By Lemma 15, |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |\mathcal {K}|\le |Y| and \mathrm {L}_2(Y) runs in O(|Y|^3\min \{k\!+\!1,n\}m) time and O(n^2) space.

(ii) We set weight w so that w(e):=1 for each edge e\in E(G) and w(v):=1 for each vertex v\in V(G). We claim that {{\mathcal {C}}}_{k,\mathrm {vertex}}^{\mathrm {in}} is equal to {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ). Note that \omega _X(V(X))= w(V(X))=|X| for any non-empty set X\subseteq \Lambda . By definition of coefficient function \gamma and weight w in G, we see that \mu (u,v;X)=\kappa (u,v;G[X]) holds for any two vertices u,v\in X. In particular, if |X|\le k then \mu (u,v;X)=\kappa (u,v;G[X])<k. Let X be a subset of V(G) with |V(X)|=|X|\le k. Then G[X] is not a k-vertex-connected graph and X is not k-connected in the system (M,w,\gamma ,k,\Lambda ).

Let X be a subset of V(G) with |V(X)|=|X|\ge k+1. Then G[X] is a k-vertex-connected graph if and only if \mu (u,v;X)=\kappa (u,v;G[X])\ge k for any two vertices u,v\in V(X). This means that {{\mathcal {C}}}_{k,\mathrm {vertex}}^{\mathrm {in}}={{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), proving the claim.

Whether \mu (s,t;X)\ge k (i.e., \kappa (s,t;G[X]),\kappa (t,s;G[X])\ge k) or not for a subset X\subseteq V(G) can be tested in O(\min \{k,n^{1/2}\}m) time and O(n+m) space [2, 3]. By Lemma 14(iv), \mathrm {L}_1(X;Y) runs in O(|Y|^2\min \{k\!+\!1,n^{1/2}\}m) time and O(n^2) space. The family \mathcal {K} of k-cores Z\subseteq Y is {{Y}\atopwithdelims (){k}}. By Lemma 15, |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |\mathcal {K}|\le {{|Y|}\atopwithdelims (){k}} and \mathrm {L}_2(Y) runs in O(|Y|^{k+2}\min \{k\!+\!1,n^{1/2}\}m) time and O(|Y|^{k}n) space. \square

Again, using Theorem 1 and Lemma 17, we have the following theorem on the time delay and the space complexity of enumeration of connectors such that the induced subgraphs are k-edge-connected or k-vertex-connected.

Theorem 4
Let (G,I,\sigma ) be an instance on a mixed graph G and k\ge 0 be an integer, where n=|V|, m=|E|, and q=|I|.

(i)
All connectors that induce k-edge-connected subgraphs can be enumerated in O(\min \{k\!+\!1,n\}q^2n^3m) delay and O(qn+n^3) space.

(ii)
All connectors that induce k-vertex-connected subgraphs can be enumerated in O(\min \{k\!+\!1,n^{1/2}\}q^2n^{k+2}m) delay and O(qn+n^{k+2}) space.

Proof
In both (i) and (ii), \theta _{\rho ,\mathrm {t}} and \theta _{\rho , \mathrm {s}} can be regarded as O(1) since the volume function is not used anywhere in this context.

(i) By Lemma 17(i), we have \theta _{1,\mathrm {t}}=O(\min \{k\!+\!1,n\}n^2m), \theta _{2,\mathrm {t}}=O(\min \{k\!+\!1,n\}n^3m), and \theta _{1,\mathrm {s}}=\theta _{2,\mathrm {s}}=O(n^2), and we can set \delta (Y)=n for any Y\subseteq V. By Theorem 1, we have the time delay O\big (q\theta _{2,\mathrm {t}} + (q(n+\theta _{1,\mathrm {t}})+\theta _{\rho ,\mathrm {t}})q \delta (V)\big ) =O(\min \{k\!+\!1,n\}q^2n^3m) and the space complexity O\big ((q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}} + \theta _{\rho ,\mathrm {s}}) n\big ) =O(qn+n^3).

(ii) By Lemma 17(ii), we have \theta _{1,\mathrm {t}}=O(\min \{k\!+\!1,n^{1/2}\}n^2m), \theta _{2,\mathrm {t}}=O(\min \{k\!+\!1,n^{1/2}\}n^{k+2}m), \theta _{1,\mathrm {s}}=O(n^2), and \theta _{2,\mathrm {s}}=O(n^{k+1}), and we can set \delta (Y)=n^k for any Y\subseteq V. By Theorem 1, we have the time delay O\big (q\theta _{2,\mathrm {t}} + (q(n+\theta _{1,\mathrm {t}})+\theta _{\rho ,\mathrm {t}})q \delta (V)\big ) =O(\min \{k\!+\!1,n^{1/2}\}q^2n^{k+2}m) and the space complexity O\big ((q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}} + \theta _{\rho ,\mathrm {s}}) n\big ) =O(qn+n^{k+2}). \square

Enumerating Connected Subgraphs
As we observed in Sect. 4.6, we can enumerate all components in a given confluent system (V,{{\mathcal {C}}}). This approach can be applied to enumeration of vertex subsets that induce subgraphs under various connectivity conditions.

Connected Induced Subgraphs (CISs)
For an undirected graph G, there are some studies on enumeration of CISs. In the seminal paper on reverse search [6], Avis and Fukuda showed that all CISs are enumerable in output-polynomial time and in polynomial space. It is immediate that their algorithm achieves O(n) delay, where n=|V(G)|. Uno [32] showed that all CISs are enumerable in O(1) time for each solution, using the analysis technique called Push Out Amortization. Alokshiya et al. [4] proposed a new linear delay algorithm and showed its empirical efficiency by experimental comparison with other algorithms.

The above mentioned previous algorithms are specialized to the task of enumerating all CISs. Our algorithm is so general that it is applicable to the task by taking the confluent system (V(G),{{\mathcal {C}}}_G). Recall that, for (V(G),{{\mathcal {C}}}_G), we can implement the oracles L_1 and L_2 so that \theta _{i,\mathrm {t}}=O(n+m), i=1,2, \theta _{i,\mathrm {s}}=O(n+m), i=1,2, and \theta _{\rho ,\mathrm {t}}=\theta _{\rho ,\mathrm {s}}=O(1). Corollary 1 implies that all components in (V(G),{{\mathcal {C}}}_G) can be enumerated in O(n^3(n+m)) delay and O(n(n+m)) space.

k-Edge- and k-Vertex-Connected Induced Subgraphs
For a mixed graph G, a subgraph G' with V(G')\subseteq V(G) and E(G')\subseteq E(G) is spanning if V(G')=V(G). There is some literature on enumeration of spanning subgraphs that are k-edge- or k-vertex-connected. Khachiyan et al. [20] showed that, when G is undirected, all minimal 2-vertex-connected spanning subgraphs are enumerable in incremental polynomial time. Boros et al. [9] extended the result so that all minimal k-vertex-connected spanning subgraphs can be enumerated in incremental polynomial time for a constant k.

Nutov [24] showed that, whether G is undirected or directed, minimal undirected Steiner networks, and minimal k-vertex-connected and k-outconnected spanning subgraphs are enumerable in incremental polynomial time. Recently, Yamanaka et al. [33] proposed a reverse search algorithm that enumerates all k-edge-connected spanning subgraphs of an undirected graph in polynomial delay for any k. Sano et al. [28] presented a polynomial-delay algorithm that enumerates all 2-edge-connected induced subgraphs of an undirected graph.

By Corollary 1 and Lemma 17, we can enumerate all vertex subsets that induce k-edge- and k-vertex-connected subgraphs in a given mixed graph G since they constitute components of the confluent systems (V(G),{{\mathcal {C}}}_{k,\mathrm {edge}}^{\mathrm {in}}) and (V(G),{{\mathcal {C}}}_{k,\mathrm {vertex}}^{\mathrm {in}}), respectively.

Theorem 5
Let G be a mixed graph and k\ge 0 be an integer, where n=|V(G)| and m=|E(G)|.

(i)
All vertex subsets that induce k-edge-connected subgraphs can be enumerated in O(\min \{k\!+\!1,n\}n^5m) delay and O(n^3) space.

(ii)
All vertex subsets that induce k-vertex-connected subgraphs can be enumerated in O(\min \{k\!+\!1,n^{1/2}\}n^{k+4}m) delay and O(n^{k+2}) space.

Subgraphs Induced by Edges
Let G be a mixed graph. For an edge subset F\subseteq E(G), let G[F] denote the subgraph H induced by F; i.e., V(H)=V(F) and E(H)=F. Define \mathcal {E}_{k,\mathrm {edge}}^{\mathrm {in}} to be the family (resp., \mathcal {E}_{k,\mathrm {vertex}}^{\mathrm {in}}) of subsets F\in E(G) such that the induced graph G[F] is k-edge-connected (resp., k-vertex-connected). Analogously with Lemma 17, we obtain the next result.

Lemma 18
Let G be a mixed graph with n vertices and m edges and k\ge 0 be an integer. Then:

(i)
The family {{\mathcal {C}}}=\mathcal {E}_{k,\mathrm {edge}}^{\mathrm {in}} is confluent. For any non-empty subsets X\subseteq Y\subseteq E(G), it holds |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |Y|, \mathrm {L}_1(X;Y) for a subset X\subseteq Y can be implemented so that it runs in O(|Y|^2\min \{k+1,n\}m) time and O(n^2) space, and \mathrm {L}_2(Y) can be implemented so that it runs in O(|Y|^3\min \{k+1,n\}m) time and O(n^2) space.

(ii)
The family {{\mathcal {C}}}=\mathcal {E}_{k,\mathrm {vertex}}^{\mathrm {in}} is confluent. For any non-empty subsets X\subseteq Y\subseteq E(G), it holds |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le {{|Y|}\atopwithdelims (){k}}, oracle \mathrm {L}_1(X;Y) can be implemented so that it runs in O(|Y|^2\min \{k+1,n^{1/2}\}m) time and O(n^2) space, and oracle \mathrm {L}_2(Y) can be implemented so that it runs in O(|Y|^{k+2}\min \{k+1,n^{1/2}\}m) time and O(|Y|^{k}n) space.

Proof
Let (M,w,\gamma ,k,\Lambda ) be a system such that a mixed graph M:=G, \Lambda :=E(G), a weight function w and a coefficient function \gamma =(\alpha ,\overline{\alpha },\alpha ^+,\alpha ^-,\beta ) such that \alpha (e):=\overline{\alpha }(e):=\alpha ^+(e):=\alpha ^-(e):=0 for each edge e\in E(G), and \beta (a):=0 for each element a\in V(G)\cup E(G), where we see that \gamma is monotone and the family {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ) is confluent by Lemmas 11 and 12.

(i) We set weight w so that w(e):=1 for each edge e\in E(G) and w(v):=k for each vertex v\in V(G). We claim that \mathcal {E}_{k,\mathrm {edge}}^{\mathrm {in}} is equal to {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), where the latter is the family of non-empty subsets X\subseteq \Lambda with \omega _X(V(X))\ge k such that |V(X)|=1 or \mu (u,v;X)\ge k for each pair of vertices u,v\in V(X). Note that |V(X)|\ge 2 and \omega _X(V(X))= w(V(X))=k|V(X)| for any non-empty set X\subseteq \Lambda =E(G).

Let X be a non-empty subset of E(G), where |V(X)|\ge 2 and \omega _X(V(X))\ge k. By definition of coefficient function \gamma and weight w in G, we see that \mu (u,v;X)=\lambda (u,v;G[X]) holds for any two vertices u,v\in V(X). Hence G[X] is a k-edge-connected graph if and only if \mu (u,v;X)=\lambda (u,v;G[X])\ge k for any two vertices u,v\in V(X). This means that \mathcal {E}_{k,\mathrm {edge}}^{\mathrm {in}} ={{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), proving the claim.

Whether \mu (s,t;X)\ge k (i.e., \lambda (s,t;G[X]),\lambda (t,s;G[X])\ge k) or not for a subset X\subseteq E(G) can be tested in O(\min \{k,n\}m) time [2, 3]. By Lemma 14(iv), \mathrm {L}_1(X;Y) runs in O(|Y|^2\min \{k+1,n\}m) time and O(n^2) space. The family \mathcal {K} of k-cores Z\subseteq Y is \{\{v\}\mid v\in Y\}. By Lemma 15, |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |\mathcal {K}|\le |Y| and \mathrm {L}_2(Y) runs in O(|Y|^3\min \{k+1,n\}m) time and O(n^2) space.

(ii) We set weight w so that w(e):=1 for each edge e\in E(G) and w(v):=1 for each vertex v\in V(G).

We claim that \mathcal {E}_{k,\mathrm {vertex}}^{\mathrm {in}} is equal to {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ). Note that |V(X)|\ge 2 and \omega _X(V(X))= w(V(X))=|X| for any non-empty set X\subseteq \Lambda . By definition of coefficient function \gamma and weight w in G, we see that \mu (u,v;X)=\kappa (u,v;G[X]) holds for any two vertices u,v\in V(X). In particular, if |V(X)|\le k then \mu (u,v;X)=\kappa (u,v;G[X])<k. Let X be a subset of E(G) with |V(X)| \le k. Then G[X] is not a k-vertex-connected graph and X is not k-connected in the system (M,w,\gamma ,k,\Lambda ).

Let X be a subset of E(G) with |V(X)|\ge k+1. Then G[X] is a k-vertex-connected graph if and only if \mu (u,v;X)=\kappa (u,v;G[X])\ge k for any two vertices u,v\in V(X). This means that \mathcal {E}_{k,\mathrm {vertex}}^{\mathrm {in}} ={{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), proving the claim.

Whether \mu (s,t;X)\ge k (i.e., \kappa (s,t;G[X]),\kappa (t,s;G[X])\ge k) or not for a subset X\subseteq E(G) can be tested in O(\min \{k,n^{1/2}\}m) time and O(n+m) space [2, 3]. By Lemma 14(iv), \mathrm {L}_1(X;Y) runs in O(|Y|^2\min \{k+1,n^{1/2}\}m) time and O(n^2) space. The family \mathcal {K} of k-cores Z\subseteq Y is {{Y}\atopwithdelims (){k}}. By Lemma 15, |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |\mathcal {K}|\le {{|Y|}\atopwithdelims (){k}} and \mathrm {L}_2(Y) runs in O(|Y|^{k+2}\min \{k+1,n^{1/2}\}m) time and O(|Y|^{k}n) space. \square

By Corollary 1 and Lemma 18, we can enumerate all edge subsets that induce k-edge- and k-vertex-connected subgraphs in a given mixed graph G since they constitute components of the confluent systems (E(G),\mathcal {E}_{k,\mathrm {edge}}^{\mathrm {in}}) and (E(G),\mathcal {E}_{k,\mathrm {vertex}}^{\mathrm {in}}), respectively.

Theorem 6
Let G be a mixed graph and k\ge 1 be an integer, where n=|V(G)| and m=|E(G)|.

(i)
All edge subsets that induce k-edge-connected subgraphs can be enumerated in O(\min \{k+1,n\}m^6) delay and O(mn^2) space.

(ii)
All edge subsets that induce k-vertex-connected subgraphs can be enumerated in O(\min \{k+1,n^{1/2}\}m^{k+5}) delay and O(m^{k+1}n) space.

Define a volume function \rho :V(G)\cup E(G)\rightarrow {\mathbb {R}} so that \rho (X):=|V(X)|- |V(G)|+1 for each subset X\subseteq V(G)\cup E(G). For a subset X\subseteq E(G), the graph G[X] is a spanning subgraph of G if and only if \rho (X)> 0. We see that \theta _{\rho ,\mathrm {t}}=\theta _{\rho ,\mathrm {s}}=O(n).

Similarly to Theorem 6, we can enumerate all edge subsets that induce k-edge- and k-vertex-connected spanning subgraphs in a given mixed graph G since they constitute \rho -positive components of the confluent systems (E(G),\mathcal {E}_{k,\mathrm {edge}}^{\mathrm {in}}) and (E(G),\mathcal {E}_{k,\mathrm {vertex}}^{\mathrm {in}}), respectively.

Theorem 7
Let G be a mixed graph and k\ge 1 be an integer, where n=|V(G)| and m=|E(G)|.

(i)
All edge subsets that induce k-edge-connected spanning subgraphs can be enumerated in O(\min \{k+1,n\}m^6) delay and O(mn^2) space.

(ii)
All edge subsets that induce k-vertex-connected spanning subgraphs can be enumerated in O(\min \{k+1,n^{1/2}\}m^{k+5}) delay and O(m^{k+1}n) space.

Concluding Remarks
The main contribution of the paper is Theorem 1. To prove the theorem, we have presented a family-tree based enumeration algorithm that achieves the required complexity in Sects. 4.1 and 4.5.

Once we define a confluent system (V,{{\mathcal {C}}}) such that \delta (X)\le \delta (Y) holds for any X\subseteq Y\subseteq V and design two oracles L_1 and L_2 for it, we can enumerate all solutions in an instance (V,{{\mathcal {C}}},I,\sigma ) for arbitrary I and \sigma in the stated computational complexity. In particular, if the time (resp., space) complexity of the two oracles is polynomially bounded, the algorithm achieves polynomial-delay (resp., polynomial space).

We presented some application results in Sects. 6 and 7. In Sect. 6, we obtained a polynomial-delay algorithm for the connector enumeration problem, even when a stronger connectivity condition is imposed on a connector (i.e., k-edge-connectivity for any k and k-vertex-connectivity for a fixed k). In Sect. 7, we showed that, for any k (resp., a fixed k), we can enumerate in polynomial delay all vertex/edge subsets that induce k-edge-connected (resp., k-vertex-connected) subgraphs and all edge subsets that induce k-edge-connected (resp., k-vertex-connected) spanning subgraphs. We summarize the computational complexity in Tables 4 and 5. We could improve complexity bounds for respective cases, which are left for future work.

Table 4 Complexity of enumerating connectors X that satisfy several connectivity requirements: conn. is an abbreviation of “connected”
Full size table

Table 5 Complexity of enumerating vertex subsets X or edge subsets F that satisfy several connectivity requirements: conn. is an abbreviation of “connected”
Full size table

Let us emphasize that, in Sects. 6 and 7, the input graph G can be undirected, directed or even mixed, and the vertex and/or edges can be weighted. We manipulate such G by means of a meta-weight function, and the details were discussed in Sect. 5.

Our next issue is to show the effectiveness of the family-tree based algorithm by solving real instances of enumeration problems concerning a confluent system. The connector enumeration problem has applications in biology, as mentioned in Sect. 6, and we are to pursuit further applications in such fields as chemistry. We have already developed an implementation of the algorithm for this problem. In [15], we observed its efficiency in comparison with previous algorithms, COOMA [13, 14] and COPINE [30].