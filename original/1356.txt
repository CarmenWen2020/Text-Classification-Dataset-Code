For a finite set V of elements, a confluent system is a set system (ğ‘‰,îˆ¯âŠ†2ğ‘‰) such that every three sets ğ‘‹,ğ‘Œ,ğ‘âˆˆîˆ¯ with ğ‘âŠ†ğ‘‹âˆ©ğ‘Œ implies ğ‘‹âˆªğ‘Œâˆˆîˆ¯, where we call a set ğ¶âˆˆîˆ¯ a component. We assume that two oracles L1 and L2 are available, where given two subsets ğ‘‹,ğ‘ŒâŠ†ğ‘‰, L1 returns a maximal component ğ¶âˆˆîˆ¯ with ğ‘‹âŠ†ğ¶âŠ†ğ‘Œ; and given a set ğ‘ŒâŠ†ğ‘‰, L2 returns all maximal components ğ¶âˆˆîˆ¯ with ğ¶âŠ†ğ‘Œ. Given a set I of items and a function ğœ:ğ‘‰â†’2ğ¼ in a confluent system, a component ğ¶âˆˆîˆ¯ is called a solution (or support-closed) if the set of common items in C is inclusively maximal; i.e., â‹‚ğ‘£âˆˆğ¶ğœ(ğ‘£)âŠ‹â‹‚ğ‘£âˆˆğ‘‹ğœ(ğ‘£) for any component ğ‘‹âˆˆîˆ¯ with ğ¶âŠŠğ‘‹. We prove that there exists an algorithm of enumerating all solutions in polynomial delay and in polynomial space. The proposed algorithm yields polynomial-delay and polynomial-space algorithms for enumerating connectors in an attributed graph (i.e., a graph such that each vertex is assigned items) and for enumerating all subgraphs with various types of connectivities such as all k-edge/vertex-connected induced subgraphs and all k-edge/vertex-connected spanning subgraphs in a given undirected/directed graph for a fixed k.

Introduction
In the present paper, we consider the enumeration problem in a set system called a confluent system [8, 19]. For a confluent system on a set of elements and a set of items (or attributes) given to each element, we design an algorithm that enumerates all subsets in the system that are inclusion-wise maximal with respect to the common items in a subset.

Let V be a finite set of elements. A system on a set V of elements is defined to be a pair (ğ‘‰,îˆ¯) of V of elements and a family îˆ¯âŠ†2ğ‘‰, where a set in îˆ¯ is called a component. For a subset ğ‘‹âŠ†ğ‘‰ in a system (ğ‘‰,îˆ¯), a component ğ‘âˆˆîˆ¯ with ğ‘âŠ†ğ‘‹ is called X-maximal if no other component ğ‘Šâˆˆîˆ¯ satisfies ğ‘âŠŠğ‘ŠâŠ†ğ‘‹, and let îˆ¯max(ğ‘‹) denote the family of all X-maximal components. For two subsets ğ‘‹âŠ†ğ‘ŒâŠ†ğ‘‰, let îˆ¯max(ğ‘‹;ğ‘Œ) denote the family of components ğ¶âˆˆîˆ¯max(ğ‘Œ) such that ğ‘‹âŠ†ğ¶. We call a system (ğ‘‰,îˆ¯) (or îˆ¯) confluent if


 any  tuple  of  components ğ‘‹,ğ‘Œ,ğ‘âˆˆîˆ¯ with ğ‘âŠ†ğ‘‹âˆ©ğ‘Œ implies ğ‘‹âˆªğ‘Œâˆˆîˆ¯.

Examples of a confluent system include any Sperner family, a family of subsets every two of which intersect, and the family of ideals (i.e., downsets) in a partially ordered set. We will show that, given a graph and a positive integer k, the family of vertex subsets that induce k-edge/vertex-connected subgraphs is a confluent system; see Sect. 6.2 for the definition of k-edge/vertex-connectivity.

To discuss the computational complexities for solving a problem in a confluent system, we assume that a confluent system (ğ‘‰,îˆ¯) is implicitly given as two oracles L1 and L2 such that

given non-empty subsets ğ‘‹âŠ†ğ‘ŒâŠ†ğ‘‰, L1(ğ‘‹,ğ‘Œ) returns a component ğ‘âˆˆîˆ¯max(ğ‘‹;ğ‘Œ) (or âˆ… if no such Z exists) in ğœƒ1,t time and ğœƒ1,s space; and

given a non-empty subset ğ‘ŒâŠ†ğ‘‰, L2(ğ‘Œ) returns îˆ¯max(ğ‘Œ) in ğœƒ2,t time and ğœƒ2,s space.

We also denote by ğ›¿(ğ‘‹) an upper bound on |îˆ¯max(ğ‘‹)|, where we assume that ğ›¿ is a non-decreasing function in the sense that ğ›¿(ğ‘Œ)â‰¤ğ›¿(ğ‘‹) holds for any subsets ğ‘ŒâŠ†ğ‘‹âŠ†ğ‘‰.

We define an instance to be a tuple îˆµ=(ğ‘‰,îˆ¯,ğ¼,ğœ) of a set V of ğ‘›â‰¥1 elements, a family îˆ¯âŠ†2ğ‘‰, a set I of ğ‘â‰¥1 items and a function ğœ:ğ‘‰â†’2ğ¼.   Let îˆµ=(ğ‘‰,îˆ¯,ğ¼,ğœ) be an instance. The common item set ğ¼ğœ(ğ‘‹) over a subset ğ‘‹âŠ†ğ‘‰ is defined to be ğ¼ğœ(ğ‘‹)=â‹‚ğ‘£âˆˆğ‘‹ğœ(ğ‘£). A solution to instance îˆµ is defined to be a component ğ‘‹âˆˆîˆ¯ such that


 every  component ğ‘Œâˆˆîˆ¯ with ğ‘ŒâŠ‹ğ‘‹ satisfies ğ¼ğœ(ğ‘Œ)âŠŠğ¼ğœ(ğ‘‹). 

Let îˆ¿ denote the family of all solutions to instance îˆµ.

Our aim is to design an efficient algorithm for enumerating all solutions in îˆ¿ when îˆ¯ is confluent in instance îˆµ.

Following [18], we call an enumeration algorithm îˆ­

output-polynomial (or polynomial-total) if the overall computation time is polynomial with respect to the input and output size;

incremental-polynomial if the computation time between the ith output and the (ğ‘–âˆ’1)st output is bounded by a polynomial with respect to the input size and i; and

polynomial-delay if the delay (i.e., the time between any two consecutive outputs), preprocessing time and postprocessing time are all bounded by a polynomial with respect to the input size.

One sees that an incremental-polynomial algorithm is output-polynomial and that a polynomial-delay algorithm is incremental-polynomial (and thus output-polynomial).

To enumerate solutions for a given instance in a more flexible way, we introduce a new notion. We call a set function ğœŒ from 2ğ‘‰ to the set â„ of reals a volume function if ğœŒ(ğ‘‹)â‰¤ğœŒ(ğ‘Œ) for any subsets ğ‘‹âŠ†ğ‘ŒâŠ†ğ‘‰. A subset ğ‘‹âŠ†ğ‘‰ is called ğœŒ-positive if ğœŒ(ğ‘‹)>0. The proposed algorithm enumerates all ğœŒ-positive solutions. We introduce the volume function to model numerical properties that are monotone with respect to set-inclusion. The examples of such properties include the set cardinality, a linear sum of profits/costs that are given to each vertex, and so on. The volume function enables us to enumerate solutions such that the property values are more than a given threshold, whereas we can enumerate all solutions by setting ğœŒ(ğ‘†):=1>0 for all ğ‘†âŠ†ğ‘‰. Moreover, we will use the volume function as a tool to derive a theorem (Theorem 7). Given a volume function ğœŒ, we assume that whether ğœŒ(ğ‘‹)>0 holds or not can be tested in ğœƒğœŒ,t time and ğœƒğœŒ,s space.

In this paper, we design an algorithm that enumerates all ğœŒ-solutions in îˆ¿ by traversing a family tree over the solutions in îˆ¿. The family tree is one of the conventional techniques of enumeration (e.g., [5, 28]). It is a tree structure that represents a parentâ€“child relationship among solutions and admits us to enumerate solutions by traversing the tree.

The following theorem summarizes our main result.

Theorem 1
Let îˆµ=(ğ‘‰,îˆ¯,ğ¼,ğœ) be an instance on a confluent system (ğ‘‰,îˆ¯), where ğ‘›=|ğ‘‰| and ğ‘=|ğ¼|, and ğœŒ:2ğ‘‰â†’â„ be a volume function. All ğœŒ-positive solutions in îˆ¿ to the instance îˆµ can be enumerated in ğ‘‚(ğ‘2ğ›¿(ğ‘‰)ğœƒ1,t+ğ‘ğœƒ2,t+ğ‘ğ›¿(ğ‘‰)ğœƒğœŒ,ğ‘¡+ğ‘2ğ›¿(ğ‘‰)ğ‘›) delay and in ğ‘‚(ğ‘›ğœƒ1,s+ğ‘›ğœƒ2,s+ğ‘›ğœƒğœŒ,s+ğ‘›2+ğ‘ğ‘›) space.

The theorem indicates that, when ğœƒ1,t, ğœƒ2,t, ğœƒğœŒ,t and ğ›¿(ğ‘‰) are bounded by a polynomial of n and q, all solutions are enumerable in polynomial-delay. Similarly, when ğœƒ1,s, ğœƒ2,s and ğœƒğœŒ,s are bounded by a polynomial of n and q, the enumeration can be done in polynomial space with respect to the input size. Our algorithm in Theorem 1 is a framework that can be applied to some enumeration problems over graphs, as will be discussed in Sects. 6 and 7.

The paper is organized as follows.

In Sect. 2, we describe the research background.

In Sect. 3, we prepare terminologies and notations.

In Sect. 4, we present a family-tree based algorithm that enumerates all solutions in a given instance, along with computational complexity analyses. We also show that the algorithm can be used to enumerate all components in the confluent system of the instance.

The proposed algorithm can be applied to several problems of enumerating subgraphs that satisfy certain connectivity conditions over a given graph. In Sect. 5, we show how to construct a confluent system from a given weighted/unweighted mixed graph so that each component in the resulting system corresponds to a required subgraph.

In Sect. 6, we mention a significant application of our algorithm to the connector enumeration problem. We show that our algorithm yields a polynomial-delay algorithm for the problem even when we require stronger connectivity conditions such as k-edge/vertex-connectivity.

In Sect. 7, we obtain polynomial-delay algorithms that enumerate all k-edge-connected (resp., k-vertex-connected) induced subgraphs and that enumerate all k-edge-connected (resp., k-vertex-connected) spanning subgraphs in a given undirected or directed graph for any k (resp., a fixed k), applying the component enumeration algorithm.

Finally Sect. 8 makes some concluding remarks.

Background
In this section, we first mention our motivation on this work (Sect. 2.1). We focus on a confluent system in this paper, while various set systems have been treated in the literature of the enumeration problem. We provide representative ones and their definitions (Sects. 2.2 and 2.3). We then explain related work, difference from ours (Sect. 2.4) and the difficulty in confluent systems (Sect. 2.5). Finally in Sect. 2.6, we describe some application examples of the proposed algorithm.

Motivation
Connector Enumeration Problem
Assume that we are given a tuple (ğº,ğ¼,ğœ) with an undirected graph G, a set I of items, and a function ğœ:ğ‘‰(ğº)â†’2ğ¼. For a subset ğ‘‹âŠ†ğ‘‰(ğº), let G[X] denote the subgraph induced from G by X, and ğ¼ğœ(ğ‘‹) denote the common item set â‹‚ğ‘¢âˆˆğ‘‹ğœ(ğ‘¢). A subset ğ‘‹âŠ†ğ‘‰(ğº) such that G[X] is connected called a connector, if for any vertex ğ‘£âˆˆğ‘‰(ğº)âˆ–ğ‘‹, ğº[ğ‘‹âˆª{ğ‘£}] is not connected or ğ¼ğœ(ğ‘‹âˆª{ğ‘£})âŠŠğ¼ğœ(ğ‘‹); i.e., there is no proper superset Y of X such that G[Y] is connected and ğ¼ğœ(ğ‘Œ)=ğ¼ğœ(ğ‘‹).

The problem of enumerating all connectors is called the connector enumeration problem in the literature [13, 14, 25, 30]. Figure 1 illustrates a brief example of an instance of the connector enumeration problem.

Fig. 1
figure 1
An instance of the connector enumeration problem: it has connectors {ğ‘£1}, {ğ‘£4}, {ğ‘£1,ğ‘£2}, {ğ‘£1,ğ‘£3}, {ğ‘£1,ğ‘£2,ğ‘£3}, and {ğ‘£1,ğ‘£2,ğ‘£3,ğ‘£4}, where an item is represented by an integer

Full size image

A tuple (ğº,ğ¼,ğœ) is called a graph with an item set, or an attributed graph, and is useful to represent many existing networks such as social networks and biological networks [7]. Some papers in the literature have reported applications of the connector enumeration problem in biology. Seki and Sese [29] considered a biological network such that a vertex corresponds to a gene and an edge represents a proteinâ€“protein interaction between genes. A gene produces RNAs under a certain condition, and the phenomenon is called gene expression. A condition at which gene expression occurs is given to a vertex as an item. A biologist is particularly interested in a large-sized connector with a large common item set, that is, a large connected set of genes that make expressions simultaneously under common (possibly complex) conditions.

More recently, Alokshiya et al. [4] proposed a new algorithm for enumerating all connected induced subgraphs (CISs) of a given (non-attributed) graph. They applied the algorithm to find maximal cohesive patterns in BIOGRID protein-protein interaction network [10], where a maximal cohesive pattern is defined as a connector that is maximal among those X satisfying |ğ¼ğœ(ğ‘‹)|â‰¥ğœƒ for a threshold ğœƒ.

Related Studies
The connector enumeration problem is a generalization of the frequent item set mining problem [1], a well-known problem in data mining, such that G is a clique and a vertex corresponds to a transaction.

For an attributed graph, community detection [22] and frequent subgraph mining [17] are among significant graph mining problems. The latter asks to enumerate all subgraphs that appear in a given set of attributed graphs â€œfrequently,â€ where the graph isomorphism is defined by taking into account the items. For the problem, gSpan [34] should be one of the most successful algorithms. The algorithm enumerates all frequent subgraphs by growing up a search tree. In the search tree, a node in a depth d corresponds to a subgraph that consists of d vertices, and a node u is the parent of a node v if the subgraph for v is obtained by adding one vertex to the subgraph for u.

For the connector enumeration problem, Sese et al. [30] proposed a gSpan-based algorithm, named COPINE. Okuno et al. [26, 27] and Okuno [25] studied parallelization of COPINE. The first polynomial-delay algorithm was introduced in [8]. Haraguchi et al. [13, 14] proposed an alternative output-polynomial algorithm, named COOMA, based on a dynamic programming method.

In the present paper, we study a generalization of the connector enumeration problem on a set system. The proposed method is applicable not only to the original connector enumeration problem but also to the case where the graph is mixed and/or stronger connectivity conditions are imposed on connectors.

Hereditary Property in Subgraph Enumeration
In the context of subgraph enumeration, we are often asked to solve the problem as follows; given a graph ğº=(ğ‘‰,ğ¸) and a graph property ğœ‹, enumerate all subsets of V that induce a subgraph that satisfies ğœ‹. Let îˆ¯ğœ‹ denote the set of all vertex subsets of V that induce a subgraph that satisfies ğœ‹. We call the system (ğ‘‰,îˆ¯ğœ‹) induced by G and ğœ‹. We call a graph property ğœ‹ hereditary if, for any ğ‘‹âŠ†ğ‘ŒâŠ†ğ‘‰, ğ‘Œâˆˆîˆ¯ğœ‹ implies ğ‘‹âˆˆîˆ¯ğœ‹. We call a graph property ğœ‹ connected-hereditary if, for any ğ‘‹âŠ†ğ‘ŒâŠ†ğ‘‰, ğ‘‹âˆˆîˆ¯ğœ‹ holds whenever ğ‘Œâˆˆîˆ¯ğœ‹ and G[X] is connected.

Set Systems
We review the following classes of set systems. A system (ğ‘‰,îˆ¯) is called

accessible if any non-empty component ğ‘Œâˆˆîˆ¯ contains an element ğ‘âˆˆğ‘Œ such that ğ‘Œâˆ–{ğ‘}âˆˆîˆ¯;

strongly-accessible if âˆ…âˆˆîˆ¯ and any pair of components ğ‘‹,ğ‘Œâˆˆîˆ¯ with ğ‘‹âŠŠğ‘Œ admits an element ğ‘âˆˆğ‘Œâˆ–ğ‘‹ such that ğ‘‹âˆª{ğ‘}âˆˆîˆ¯;

independent if every subset X of a component ğ‘Œâˆˆîˆ¯ is a component in îˆ¯; and

weakly-confluent if, for every three components ğ‘‹,ğ‘Œ,ğ‘âˆˆîˆ¯, ğ‘âŠ†ğ‘‹âˆ©ğ‘Œ and ğ‘â‰ âˆ… imply ğ‘‹âˆªğ‘Œâˆˆîˆ¯.

One can readily see that the above mentioned systems have the following relationships;

an independent system is strongly-accessible and a strongly-accessible system is accessible;

a confluent system is weakly-confluent;

a system induced by a graph and a hereditary property is independent; and

a system induced by a graph and a connected-hereditary property is strongly-accessible (Lemma 19 in [12]).

Moreover, if a system is confluent and accessible, then it is also strongly-accessible by the following Lemma 2.

Lemma 1
Let (ğ‘‰,îˆ¯) be a confluent system. If âˆ…âˆˆîˆ¯, then îˆ¯ is closed under union, that is, ğ‘‹,ğ‘Œâˆˆîˆ¯ implies ğ‘‹âˆªğ‘Œâˆˆîˆ¯.

Proof
For arbitrary components ğ‘‹,ğ‘Œâˆˆîˆ¯, there is ğ‘âŠ†ğ‘‹âˆ©ğ‘Œ such that ğ‘âˆˆîˆ¯ since âˆ…âˆˆîˆ¯. Then ğ‘‹âˆªğ‘Œ is a component by confluency. â—»

Let (ğ‘‰,îˆ¯) be a system. For ğ‘‹,ğ‘Œâˆˆîˆ¯ with ğ‘‹âŠ†ğ‘Œ, we say that Y is accessible from X (or equivalently, X is accessible from Y) if there is an ordering on elements in ğ‘Œâˆ–ğ‘‹={ğ‘’1,â€¦,ğ‘’ğ‘˜} such that all of ğ‘‹âˆª{ğ‘’1}, ğ‘‹âˆª{ğ‘’1,ğ‘’2}, â€¦, ğ‘‹âˆª{ğ‘’1,ğ‘’2,â€¦,ğ‘’ğ‘˜âˆ’1} and ğ‘‹âˆª{ğ‘’1,ğ‘’2,â€¦,ğ‘’ğ‘˜}=ğ‘Œ are components.

Lemma 2
Let (ğ‘‰,îˆ¯) be a system. If (ğ‘‰,îˆ¯) is confluent and accessible, then it is strongly-accessible.

Proof
It suffices to show that, for any ğ‘‹,ğ‘Œâˆˆîˆ¯ with ğ‘‹âŠ†ğ‘Œ, Y is accessible from X.

Let ğ‘Œ={ğ‘’1,ğ‘’2,â€¦,ğ‘’ğ‘š} such that all of ğ‘Œğ‘š:=ğ‘Œ, ğ‘Œğ‘šâˆ’1:=ğ‘Œâˆ–{ğ‘’ğ‘š}, ğ‘Œğ‘šâˆ’2:=ğ‘Œâˆ–{ğ‘’ğ‘šâˆ’1,ğ‘’ğ‘š}, â€¦, ğ‘Œ1:=ğ‘Œâˆ–{ğ‘’2,â€¦,ğ‘’ğ‘š}={ğ‘’1} are components, where such orderings on the elements in Y surely exist by accessibility.

Then ğ‘‹âˆªğ‘Œ1, ğ‘‹âˆªğ‘Œ2, â€¦, ğ‘‹âˆªğ‘Œğ‘š belong to îˆ¯ by Lemma 1 since the system is confluent and âˆ…âˆˆîˆ¯ holds by accessibility.

The sequence of distinct subsets in ğ‘‹âˆªğ‘Œ1, ğ‘‹âˆªğ‘Œ2, â€¦, ğ‘‹âˆªğ‘Œğ‘š indicates that Y is accessible from X. â—»

Figure 2 illustrates these relationships by a Venn diagram along with their concrete examples.

Fig. 2
figure 2
Venn diagram representing the relationships among representative set systems in the literature and their concrete examples

Full size image

Enumeration of Solutions in Other Set Systems
This paper proposes the first polynomial-delay and polynomial-space algorithm for enumerating all solutions in an instance such that the set system is confluent. Let us review related work.

Given a system (ğ‘‰,îˆ¯), a function ğœ™:îˆ¯â†’îˆ¯ is a closure operator if the following three conditions hold for any ğ‘‹,ğ‘Œâˆˆîˆ¯: (extensibility) ğ‘‹âŠ†ğœ™(ğ‘‹); (monotonicity) ğ‘‹âŠ†ğ‘Œ implies ğœ™(ğ‘‹)âŠ†ğœ™(ğ‘Œ); and (idempotence) ğœ™(ğœ™(ğ‘‹))=ğœ™(ğ‘‹). A component ğ¶âˆˆîˆ¯ is closed if ğ¶=ğœ™(ğ¶) holds (i.e., C is a fixed point with respect to ğœ™). For given strongly-accessible (resp., accessible) system and closure operator, Boley et al. [8] (resp., Arimura and Uno [5]) developed a polynomial-delay algorithm for enumerating closed components. The algorithms assume a membership oracle that identifies whether a subset ğ‘†âŠ†ğ‘‰ is a member of îˆ¯ or not.

Suppose that an instance (ğ‘‰,îˆ¯,ğ¼,ğœ) is given. The instance is non-redundant if every element ğ‘£âˆˆğ‘‰ satisfies ğœ(ğ‘£)âŠŠğ¼. For a component ğ¶âˆˆîˆ¯, let us write by Sol(ğ¶) a minimal solution ğ‘‹âˆˆîˆ¯ such that ğ‘‹âŠ‡ğ¶. By Lemma 6 in [8], if (ğ‘‰,îˆ¯) is weakly-confluent, Sol(ğ¶) is unique for every ğ¶âˆˆîˆ¯. A function ğœ™:îˆ¯â†’îˆ¯ is called a support closure operator if ğœ™(ğ¶)=Sol(ğ¶) holds for every ğ¶âˆˆîˆ¯, where the existence of such ğœ™ is not trivial.

Boley et al.â€™s algorithm for enumerating closed sets [8] can be applied to enumeration of solutions in a given non-redundant instance (ğ‘‰,îˆ¯,ğ¼,ğœ) such that (ğ‘‰,îˆ¯) is weakly-confluent and strongly-accessible. The essence of the application is summarized as follows.

There exists a support closure operator ğœ™:îˆ¯â†’îˆ¯ for the instance since (ğ‘‰,îˆ¯) is weakly-confluent (Theorem 7 in [8]).

We can compute ğœ™(ğ¶)=Sol(ğ¶) for any ğ¶âˆˆîˆ¯ in the manner of Lemma 6 in [8] since (ğ‘‰,îˆ¯) is strongly-accessible.

Similarly, Arimura and Unoâ€™s algorithm for enumerating closed sets [5] can be applied to enumeration of solutions in (ğ‘‰,îˆ¯,ğ¼,ğœ) such that (ğ‘‰,îˆ¯) is weakly-confluent and accessible since, by Lemma 2, (ğ‘‰,îˆ¯) is strongly-accessible.

The complexity of enumerating solutions in weakly-confluent and strongly-accessible (resp., weakly-confluent and accessible) systems is summarized in (A) (resp., (B)) of Table 1, where ğœƒm,t and ğœƒm,s denote the time and space complexities of the membership oracle, respectively, and ğ‘¤=maxğ¶âˆˆîˆ¯|ğ¶| denotes the largest size of a component. The complexity of the proposed algorithm is presented as (C) in the table.

Table 1 Complexity of enumerating solutions in (ğ‘‰,îˆ¯,ğ¼,ğœ) for various systems (ğ‘‰,îˆ¯), where ğ‘›=|ğ‘‰|, ğ‘=|ğ¼|, and ğ‘¤=maxğ¶âˆˆîˆ¯|ğ¶|
Full size table

Difficulty in Confluent System
The above mentioned algorithms make use of accessibility in searching the family îˆ¯. In an accessible system (and thus also in a strongly-accessible system) (ğ‘‰,îˆ¯), for every component ğ¶âˆˆîˆ¯, there is ğ‘£âˆˆğ‘‰âˆ–ğ¶ such that ğ¶âˆª{ğ‘£} is a component or is ğ‘£â€²âˆˆğ¶ such that ğ¶âˆ–{ğ‘£â€²} is a component. We can proceed the search by moving to one of such components, where we can identify whether a subset of V is a component or not by using the membership oracle.

A confluent system does not have such accessibility. For example, we consider a system (ğ‘‰,îˆ¯ğœ‹) induced by the graph in Fig. 3 and the graph property ğœ‹ â€œthe induced subgraph is 2-edge-connectedâ€. The 2-edge-connectivity is an elementary notion in graph theory. See Sect. 6.2 for the definition. We have îˆ¯ğœ‹={{ğ‘£4,ğ‘£5,ğ‘£6,ğ‘£8},ğ‘‰âˆ–{ğ‘£5},ğ‘‰âˆ–{ğ‘£8},ğ‘‰}. We see that the component {ğ‘£4,ğ‘£5,ğ‘£6,ğ‘£8} is not accessible from any other components.

Fig. 3
figure 3
A 2-edge-connected graph ğº=(ğ‘‰,ğ¸) such that vertex subsets {ğ‘£4,ğ‘£5,ğ‘£6,ğ‘£8}, ğ‘‰âˆ–{ğ‘£5} and ğ‘‰âˆ–{ğ‘£8} induce 2-edge-connected subgraphs

Full size image

Due to the lack of accessibility, we assume stronger oracles in this work, that is L1 and L2. By the term â€œstrongâ€, we mean that the membership oracle can be realized by L2 since we can decide ğ‘†âˆˆîˆ¯ or not for ğ‘†âŠ†ğ‘‰ by whether L2(ğ‘†) returns {ğ‘†} or not although the proposed algorithm does not use L2 as the membership oracle explicitly. L1 appears to be redundant since L1 can be realized by using L2. Nevertheless we use the two oracles in order to make the analyses clearer.

Our assumption on oracles appears to be unrealistic since enumeration of maximal subsets with respect to a certain property is usually non-trivial and has been a significant research issue itself [11, 12, 21]. For some graph properties related to connectivity, however, it is possible to implement the oracles so that the time and space complexities are polynomially bounded. This will be discussed in Sects. 6 and 7.

As an extension of this work, Haraguchi and Nagamochi [16] recently provided an algorithm for enumerating solutions to a given instance (ğ‘‰,îˆ¯,ğ¼,ğœ) using L1 and L2 oracles, where (ğ‘‰,îˆ¯) is an arbitrary system. The complexity of this algorithm is presented as (D) in Table 1.

Let us discuss the time complexities in Table 1. An algorithm that is applicable to some set system is comparable to another algorithm that is applicable to a larger set system (i.e., a superset in the Venn diagram). It is expected that the former should be faster than the latter since the former possibly makes use of stronger conditions peculiar to the smaller system. In fact, we see that (A) achieves a better bound than (B) and that (C) achieves a better bound than (D). It is not trivial to compare (A) and (B) with (C) and (D) since the used oracles are different. For example, under an assumption of ğœƒ1,t=ğœƒ2,t=ğ‘‚(ğ‘›ğœƒm,t), ğœƒğœŒ,t=ğ‘‚(1), ğ‘=ğ‘‚(ğ‘›), ğ›¿(ğ‘‰)=ğ‘‚(ğ‘›) and ğ‘¤=ğ‘‚(1), the time complexities of (A), (B), (C) and (D) are ğ‘‚(ğ‘›3ğœƒm,t), ğ‘‚(ğ‘›3ğœƒm,t), ğ‘‚(ğ‘›4ğœƒm,t) and ğ‘‚(ğ‘›4ğœƒm,t), respectively, where (A) and (B) achieve a better bound than (C) and (D).

We define a solution based not on a closure operator but on item sets. The proposed algorithm makes use of items explicitly, and it is hard to extend it to the case where a solution is defined on a closure operator. The problem of enumerating closed subsets in a confluent system is left for future work.

Application Examples
Connectors in Graphs
As we will observe in Sect. 6.1, our framework can be applied to the connector enumeration problem. We overview the scenario as follows. Let (ğº,ğ¼,ğœ) be an instance of the connector enumeration problem, where ğº=(ğ‘‰,ğ¸) is a graph, ğ¼={1,2,â€¦,ğ‘} is an item set, and ğœ:ğ‘‰â†’2ğ¼ is a function that represents the items assigned to each vertex. Define a component to be a nonempty vertex subset of V that induces a connected subgraph, and denote by îˆ¯ to be the family of components in G. We can show that the system (ğ‘‰,îˆ¯) is confluent and that a solution in the instance (ğ‘‰,îˆ¯,ğ¼,ğœ) is a connector.

Table 2 Complexity of enumerating connectors in (ğº=(ğ‘‰,ğ¸),ğ¼,ğœ), where ğ‘›=|ğ‘‰|, ğ‘š=|ğ¸|, ğ‘=|ğ¼|, and ğ‘¤=maxğ¶âˆˆîˆ¯|ğ¶|
Full size table

Let us denote ğ‘›=|ğ‘‰| and ğ‘š=|ğ¸|. Then L1 and L2 oracles can be realized by a conventional graph search algorithm (e.g., DFS, BFS), and thus it holds that ğœƒ1,t=ğœƒ2,t=ğ‘‚(ğ‘›+ğ‘š) and ğœƒ1,s=ğœƒ2,s=ğ‘‚(ğ‘›+ğ‘š). Also we can set ğœƒğœŒ,ğ‘¡=ğœƒğœŒ,ğ‘ =ğ‘‚(1) and ğ›¿(ğ‘‰)=ğ‘›. Substituting them for (C) and (D) of Table 1, we obtain an algorithm for the connector enumeration problem such that the complexity is given in (C) and (D) of Table 2, respectively.

Alternatively, we may define a component to be a vertex subset of V that induces a connected subgraph, where this time we regard an empty subset as connected. The system (ğ‘‰,îˆ¯) in this case is strongly-accessible and weakly-confluent, which is indicated with the point 5 in Fig. 2. Similarly to L1 and L2, the membership oracle can be implemented so that the time and space complexities are ğ‘‚(ğ‘›+ğ‘š). Then we have complexity bounds (A) and (B) of Table 2, substituting ğœƒm,t=ğœƒm,s=ğ‘‚(ğ‘›+ğ‘š) for (A) and (B) of Table 1, respectively. Note that, for (A), Corollary 13 in [8] claims better time and space bounds, ğ‘‚((ğ‘+ğ‘š)ğ‘›2) and O(n), respectively. The complexity for (B) is obtained immediately from Theorem 4.2 in [5].

We see that the proposed algorithm (C) achieves a better time bound than others in some cases. For example, when ğ‘=ğ‘‚(1) and ğ‘š=ğ‘‚(ğ‘›2), (C) achieves a time bound ğ‘‚(ğ‘›3) whereas the time bounds of (A), (B) and (D) are ğ‘‚(ğ‘›5), ğ‘‚(ğ‘¤ğ‘›5) and ğ‘‚(ğ‘›4), respectively.

Components
Remember that a solution S in a given instance (ğ‘‰,îˆ¯,ğ¼,ğœ) is a component ğ‘†âˆˆîˆ¯ such that the set of common items in the set is maximal over all components that contain S. As will be proven in Sect. 4.6, any algorithm for enumerating all solutions in an instance (ğ‘‰,îˆ¯,ğ¼,ğœ) of a class of set systems can be conversely used to enumerate all components in the set system (ğ‘‰,îˆ¯) of that class. We show the resulting complexity of such algorithms in Table 3. The complexity for the confluent system (C) and the general system (D) is obtained by substituting ğ‘=ğ‘‚(ğ‘›) for the complexity (C) and (D) in Table 1, respectively, which results the same time and space bounds. The complexity for the strongly-accessible system (resp., the accessible system) is based on a corollary of Theorem 3 in [8] (resp., Theorem 4.2 in [5]).

Table 3 Complexity of enumerating all components for various set systems (ğ‘‰,îˆ¯), where ğ‘›=|ğ‘‰| and ğ‘¤=maxğ¶âˆˆîˆ¯|ğ¶|
Full size table

In Table 3, (A) achieves a better time bound than (B), as expected. Similarly to comparison in Sect. 2.5, under an assumption of ğœƒ1,t=ğœƒ2,t=ğ‘‚(ğ‘›ğœƒm,t), ğœƒğœŒ,ğ‘¡=ğ‘‚(1) and ğ›¿(ğ‘‰)=ğ‘‚(ğ‘›), (A) and (B) achieve better time bounds than (D). We see that (C) and (D) have the same time bound. We consider that it is not because the complexity analysis is loose. Both algorithms are based on family tree and somewhat similar to each other. We may develop a better algorithm for (C), making use of confluency, to the extent of enumeration of components. This is left for future work.

Preliminaries
Let â„ (resp., â„+) denote the set of reals (resp., non-negative reals). For a function ğ‘“:ğ´â†’â„ for a finite subset A and a subset ğµâŠ†ğ´, we let f(B) denote âˆ‘ğ‘âˆˆğµğ‘“(ğ‘).

For two integers a and b, let [a, b] denote the set of integers i with ğ‘â‰¤ğ‘–â‰¤ğ‘. For a set A with a total order < over the elements in A, we define a total order â‰º over the subsets of A as follows. For two subsets ğ½,ğ¾âŠ†ğ´, we denote by ğ½â‰ºğ¾ if the minimum element in (ğ½âˆ–ğ¾)âˆª(ğ¾âˆ–ğ½) belongs to J. We denote ğ½âª¯ğ¾ if ğ½â‰ºğ¾ or ğ½=ğ¾. Note that ğ½âª¯ğ¾ holds whenever ğ½âŠ‡ğ¾. Let ğ‘max denote the maximum element in A. Then ğ½â‰ºğ¾ holds for ğ½={ğ‘—1,ğ‘—2,â€¦,ğ‘—|ğ½|}, ğ‘—1<ğ‘—2<â‹¯<ğ‘—|ğ½| and ğ¾={ğ‘˜1,ğ‘˜2,â€¦,ğ‘˜|ğ¾|}, ğ‘˜1<ğ‘˜2<â‹¯<ğ‘˜|ğ¾|, if and only if the sequence


(ğ‘—1,ğ‘—2,â€¦,ğ‘—|ğ½|,ğ‘—â€²|ğ½|+1,ğ‘—â€²|ğ½|+2,â€¦,ğ‘—â€²|ğ´|)

of length |A| with ğ‘—â€²|ğ½|+1=ğ‘—â€²|ğ½|+2=â‹¯=ğ‘—â€²|ğ´|=ğ‘max is lexicographically smaller than the sequence


(ğ‘˜1,ğ‘˜2,â€¦,ğ‘˜|ğ¾|,ğ‘˜â€²|ğ¾|+1,ğ‘˜â€²|ğ¾|+2,â€¦,ğ‘˜â€²|ğ´|)

of length |A| with ğ‘˜â€²|ğ¾|+1=ğ‘˜â€²|ğ¾|+2=â‹¯=ğ‘˜â€²|ğ´|=ğ‘max. Hence we see that âª¯ is a total order on 2ğ´.

We start with an important property on components in a confluent system.

Lemma 3
Let (ğ‘‰,îˆ¯) be a confluent system. For a component ğ‘‹âˆˆîˆ¯ and a superset ğ‘ŒâŠ‡ğ‘‹, there is exactly one component in îˆ¯max(ğ‘‹;ğ‘Œ).

Proof
Since ğ‘‹âŠ†ğ‘Œ, îˆ¯max(ğ‘‹;ğ‘Œ) contains a Y-maximal component C. For any component ğ‘Šâˆˆîˆ¯ with ğ‘‹âŠ†ğ‘ŠâŠ†ğ‘Œ, the transitivity of îˆ¯ and ğ‘‹âŠ†ğ¶âˆ©ğ‘Š imply ğ¶âˆªğ‘Šâˆˆîˆ¯, where ğ¶âˆªğ‘Š=ğ¶ must hold by the Y-maximality of C. Hence a Y-maximal component in îˆ¯max(ğ‘‹;ğ‘Œ) is unique. â—»

For a component ğ‘‹âˆˆîˆ¯ and a superset ğ‘ŒâŠ‡ğ‘‹, let C(X; Y) denote the unique component in îˆ¯max(ğ‘‹;ğ‘Œ).

Suppose that an instance (ğ‘‰,îˆ¯,ğ¼,ğœ) is given. To facilitate our aim, we introduce a total order over the items in I by representing I as a set [1,ğ‘]={1,2,â€¦,ğ‘} of integers. For each subset ğ‘‹âŠ†ğ‘‰, let minğ¼ğœ(ğ‘‹)âˆˆ[0,ğ‘] denote the minimum item in ğ¼ğœ(ğ‘‹), where minğ¼ğœ(ğ‘‹)â‰œ0 for ğ¼ğœ(ğ‘‹)=âˆ…. For each ğ‘–âˆˆ[0,ğ‘], define a family of solutions in îˆ¿,


îˆ¿ğ‘–â‰œ{ğ‘‹âˆˆîˆ¿âˆ£minğ¼ğœ(ğ‘‹)=ğ‘–}.

Note that îˆ¿ is a disjoint union of îˆ¿ğ‘–, ğ‘–âˆˆ[0,ğ‘]. In Sect. 4.5, we will design an algorithm that enumerates all solutions in îˆ¿ğ‘˜ for any specified integer ğ‘˜âˆˆ[0,ğ‘].

Enumerating Solutions in Confluent System
Defining Family Tree
To generate all solutions in îˆ¿ efficiently, we use the idea of family tree, where we first introduce a parentâ€“child relationship among solutions, which defines a rooted tree (or a set of rooted trees), and we traverse each tree starting from the root and generating the children of a solution recursively. Our tasks to establish such an enumeration algorithm are as follows:

Select some solutions from the set îˆ¿ of solutions as the roots, called â€œbases;â€

Define the â€œparentâ€ ğœ‹(ğ‘†)âˆˆîˆ¿ of each non-base solution ğ‘†âˆˆîˆ¿, where the solution S is called a â€œchildâ€ of the solution ğ‘‡=ğœ‹(ğ‘†);

Design an algorithm A that, given a solution ğ‘†âˆˆîˆ¿, returns its parent ğœ‹(ğ‘†); and

Design an algorithm B that, given a solution ğ‘‡âˆˆîˆ¿, generates a set î‰„ of components ğ‘‹âˆˆîˆ¯ such that î‰„ contains all children of T. We can test whether each component ğ‘‹âˆˆî‰„ is a child of T by constructing ğœ‹(ğ‘‹) by algorithm A and checking if ğœ‹(ğ‘‹) is equal to T.

Starting from each base, we recursively generate the children of a solution. The complexity of delay-time of the entire algorithm depends on the time complexity of algorithms A and B, where |î‰„| is bounded from above by the time complexity of algorithm B.

Defining Base
Let (ğ‘‰,îˆ¯,ğ¼=[1,ğ‘],ğœ) be an instance on a confluent system. We define subsets ğ‘‰âŸ¨0âŸ©â‰œğ‘‰ and ğ‘‰âŸ¨ğ‘–âŸ©â‰œ{ğ‘£âˆˆğ‘‰âˆ£ğ‘–âˆˆğœ(ğ‘£)} for each item ğ‘–âˆˆğ¼. For each non-empty subset ğ½âŠ†ğ¼, define subset ğ‘‰âŸ¨ğ½âŸ©â‰œâ‹‚ğ‘–âˆˆğ½ğ‘‰âŸ¨ğ‘–âŸ©={ğ‘£âˆˆğ‘‰âˆ£ğ½âŠ†ğœ(ğ‘£)}. For ğ½=âˆ…, define ğ‘‰âŸ¨ğ½âŸ©â‰œğ‘‰. For each integer ğ‘–âˆˆ[0,ğ‘], define a set of components


îˆ®ğ‘–â‰œ{ğ‘‹âˆˆîˆ¯max(ğ‘‰âŸ¨ğ‘–âŸ©)âˆ£minğ¼ğœ(ğ‘‹)=ğ‘–}, 

and îˆ®â‰œâ‹ƒğ‘–âˆˆ[0,ğ‘]îˆ®ğ‘–. We call each component in îˆ® a base.

Lemma 4
Let (ğ‘‰,îˆ¯,ğ¼=[1,ğ‘],ğœ) be an instance on a confluent system.

(i)
For each non-empty set ğ½âŠ†[1,ğ‘] or ğ½={0}, it holds that îˆ¯max(ğ‘‰âŸ¨ğ½âŸ©)âŠ†îˆ¿;

(ii)
For each ğ‘–âˆˆ[0,ğ‘], any solution ğ‘†âˆˆîˆ¿ğ‘– is contained in some base in îˆ®ğ‘–; and

(iii)
îˆ¿0=îˆ®0 and îˆ¿ğ‘=îˆ®ğ‘.

Proof
(i) Let X be a component in îˆ¯max(ğ‘‰âŸ¨ğ½âŸ©). Note that ğ½âŠ†ğ¼ğœ(ğ‘‹) holds. When ğ½={0} (i.e., ğ‘‰âŸ¨ğ½âŸ©=ğ‘‰), no proper superset of X is a component, and X is a solution. Consider the case of âˆ…â‰ ğ½âŠ†[1,ğ‘]. To derive a contradiction, assume that X is not a solution; i.e., there is a proper superset Y of X such that ğ¼ğœ(ğ‘Œ)=ğ¼ğœ(ğ‘‹). Since âˆ…â‰ ğ½âŠ†ğ¼ğœ(ğ‘‹)=ğ¼ğœ(ğ‘Œ), we see that ğ‘‰âŸ¨ğ½âŸ©âŠ‡ğ‘Œ. This, however, contradicts the ğ‘‰âŸ¨ğ½âŸ©-maximality of X. This proves that X is a solution.

(ii) We prove that each solution ğ‘†âˆˆîˆ¿ğ‘– is contained in a base in îˆ®ğ‘–. Note that ğ‘–=minğ¼ğœ(ğ‘†) holds. By definition, it holds that ğ‘†âŠ†ğ‘‰âŸ¨ğ‘–âŸ©. Let ğ¶âˆˆîˆ¯max(ğ‘†;ğ‘‰âŸ¨ğ‘–âŸ©) be a solution. Note that ğ¼ğœ(ğ‘†)âŠ‡ğ¼ğœ(ğ¶) holds. Since ğ‘–âˆˆğ¼ğœ(ğ¶) for ğ‘–â‰¥1 (resp., ğ¼ğœ(ğ¶)=âˆ… for ğ‘–=0), we see that minğ¼ğœ(ğ‘†)=ğ‘–=minğ¼ğœ(ğ¶). This proves that C is a base in îˆ®ğ‘–. Therefore S is contained in a base ğ¶âˆˆîˆ®ğ‘–.

(iii) Let ğ‘˜âˆˆ{0,ğ‘}. We see from (i) that îˆ¯max(ğ‘‰âŸ¨ğ‘˜âŸ©)âŠ†îˆ¿, which implies that îˆ®ğ‘˜={ğ‘‹âˆˆîˆ¯max(ğ‘‰âŸ¨ğ‘˜âŸ©)âˆ£minğ¼ğœ(ğ‘‹)=ğ‘˜}âŠ†{ğ‘‹âˆˆîˆ¿âˆ£minğ¼ğœ(ğ‘‹)=ğ‘˜}=îˆ¿ğ‘˜. We prove that any solution ğ‘†âˆˆîˆ¿ğ‘˜ is a base in îˆ®ğ‘˜. By (ii), there is a base ğ‘‹âˆˆîˆ®ğ‘˜ such that ğ‘†âŠ†ğ‘‹, which implies that ğ¼ğœ(ğ‘†)âŠ‡ğ¼ğœ(ğ‘‹) and minğ¼ğœ(ğ‘†)â‰¤minğ¼ğœ(ğ‘‹). We see that ğ¼ğœ(ğ‘†)=ğ¼ğœ(ğ‘‹), since âˆ…=ğ¼ğœ(ğ‘†)âŠ‡ğ¼ğœ(ğ‘‹) for ğ‘˜=0, and ğ‘=minğ¼ğœ(ğ‘†)â‰¤minğ¼ğœ(ğ‘‹)â‰¤ğ‘ for ğ‘˜=ğ‘. Hence ğ‘†âŠŠğ‘‹ would contradict that S is a solution. Therefore ğ‘†=ğ‘‹âˆˆîˆ®ğ‘˜, as required. â—»

Lemma 4(iii) tells that all solutions in îˆ¿0âˆªîˆ¿ğ‘ can be found by calling oracle L2(ğ‘Œ) for ğ‘Œ=ğ‘‰âŸ¨0âŸ©=ğ‘‰ and ğ‘Œ=ğ‘‰âŸ¨ğ‘âŸ©. In the following, we consider how to generate all solutions in îˆ¿ğ‘˜ for each item ğ‘˜âˆˆ[1,ğ‘âˆ’1].

For a notational convenience, let C(X; i) for each item ğ‘–âˆˆğ¼ğœ(ğ‘‹) denote the component ğ¶(ğ‘‹;ğ‘‰âŸ¨ğ‘–âŸ©) and let C(X; J) for each subset ğ½âŠ†ğ¼ğœ(ğ‘‹) denote the component ğ¶(ğ‘‹;ğ‘‰âŸ¨ğ½âŸ©).

Lemma 5
Let (ğ‘‰,îˆ¯,ğ¼=[1,ğ‘],ğœ) be an instance on a confluent system. Any two solutions ğ‘†,ğ‘‡âˆˆîˆ¿ such that ğ‘†âŠ†ğ‘‡ satisfy ğ‘‡=ğ¶(ğ‘†;ğ¼ğœ(ğ‘‡)).

Proof
Let ğ‘‡â€²=ğ¶(ğ‘†;ğ¼ğœ(ğ‘‡))âˆˆîˆ¯max(ğ‘‰âŸ¨ğ¼ğœ(ğ‘‡)âŸ©). Note that ğ‘†âŠ†ğ‘‡âŠ†ğ‘‰âŸ¨ğ¼ğœ(ğ‘‡)âŸ© holds. The uniqueness of maximal component ğ‘‡â€²=ğ¶(ğ‘†;ğ¼ğœ(ğ‘‡)) by Lemma 3 indicates ğ‘‡âŠ†ğ‘‡â€². To derive a contradiction, assume that ğ‘‡âŠŠğ‘‡â€². By Lemma 4(i), ğ‘‡â€²âˆˆîˆ¯max(ğ‘‰âŸ¨ğ¼ğœ(ğ‘‡)âŸ©) is a solution. Since T and ğ‘‡â€² are solutions such that ğ‘‡âŠŠğ‘‡â€², it must hold that ğ¼ğœ(ğ‘‡)âŠ‹ğ¼ğœ(ğ‘‡â€²), implying that ğ‘‰âŸ¨ğ¼ğœ(ğ‘‡)âŸ©âŠ‰ğ‘‡â€², a contradiction. Therefore we have ğ‘‡=ğ‘‡â€². â—»

Defining Parent
This subsection defines the â€œparentâ€ of a non-base solution. For two solutions ğ‘†,ğ‘‡âˆˆîˆ¿, we say that T is a superset solution of S if ğ‘‡âŠ‹ğ‘† and ğ‘†,ğ‘‡âˆˆîˆ¿ğ‘– for some item ğ‘–âˆˆ[1,ğ‘âˆ’1]. A superset solution T of a solution ğ‘†âˆˆîˆ¿ is called minimal if no proper subset ğ‘âŠŠğ‘‡ is a superset solution of S. Let S be a non-base solution in îˆ¿ğ‘˜âˆ–îˆ®ğ‘˜ for some item ğ‘˜âˆˆ[1,ğ‘âˆ’1]. We call a minimal superset solution T of S the lex-min solution of S if ğ¼ğœ(ğ‘‡)âª¯ğ¼ğœ(ğ‘‡â€²) holds for all minimal superset solutions ğ‘‡â€² of S.

figure a
Lemma 6
Let (ğ‘‰,îˆ¯,ğ¼=[1,ğ‘],ğœ) be an instance on a confluent system, ğ‘†âˆˆîˆ¿ğ‘˜âˆ–îˆ®ğ‘˜ be a non-base solution for some item ğ‘˜âˆˆ[1,ğ‘âˆ’1], and T denote the lex-min solution of S. Denote ğ¼ğœ(ğ‘†) by \{k, i_1,i_2,\ldots ,i_p\}{ğ‘˜,ğ‘–1,ğ‘–2,â€¦,ğ‘–ğ‘} so that k<i_1<i_2<\cdots <i_pğ‘˜<ğ‘–1<ğ‘–2<â‹¯<ğ‘–ğ‘. Then:

(i)
For each integer j\in [1,p]ğ‘—âˆˆ[1,ğ‘], i_j\in I_\sigma (T)ğ‘–ğ‘—âˆˆğ¼ğœ(ğ‘‡) holds if and only if C(S;J\cup \{i_j\})\supsetneq Sğ¶(ğ‘†;ğ½âˆª{ğ‘–ğ‘—})âŠ‹ğ‘† holds for the item set J=I_\sigma (T)\cap \{k, i_1,i_2,\ldots ,i_{j-1}\}ğ½=ğ¼ğœ(ğ‘‡)âˆ©{ğ‘˜,ğ‘–1,ğ‘–2,â€¦,ğ‘–ğ‘—âˆ’1}; and

(ii)
Parent(S) in Algorithm 1 correctly delivers the lex-min solution of S in O(q(n+\theta _{\mathrm {1,t}}))ğ‘‚(ğ‘(ğ‘›+ğœƒ1,t)) time and O(q+n+\theta _{\mathrm {1,s}})ğ‘‚(ğ‘+ğ‘›+ğœƒ1,s) space.

Proof
(i) By

Lemma 4(i) and \min I_\sigma (S)=kminğ¼ğœ(ğ‘†)=ğ‘˜, we see that C(S;J\cup \{i_j\}) \in {{\mathcal {S}}}_kğ¶(ğ‘†;ğ½âˆª{ğ‘–ğ‘—})âˆˆîˆ¿ğ‘˜ for any integer j\in [1,p]ğ‘—âˆˆ[1,ğ‘].

Case 1. C(S;J\cup \{i_j\})=Sğ¶(ğ‘†;ğ½âˆª{ğ‘–ğ‘—})=ğ‘†: For any set J'\subseteq \{i_{j+1},i_{j+2},\ldots ,i_p\}ğ½â€²âŠ†{ğ‘–ğ‘—+1,ğ‘–ğ‘—+2,â€¦,ğ‘–ğ‘}, the component C(S;J\cup \{i_j\}\cup J')ğ¶(ğ‘†;ğ½âˆª{ğ‘–ğ‘—}âˆªğ½â€²) is equal to S and cannot be a minimal superset solution of S. This implies that i_j\not \in I_\sigma (T)ğ‘–ğ‘—âˆ‰ğ¼ğœ(ğ‘‡).

Case 2. C(S;J\cup \{i_j\})\supsetneq Sğ¶(ğ‘†;ğ½âˆª{ğ‘–ğ‘—})âŠ‹ğ‘†: Then C=C(S;J\cup \{i_j\})ğ¶=ğ¶(ğ‘†;ğ½âˆª{ğ‘–ğ‘—}) is a solution by Lemma 4(i). Observe that k\in J\cup \{i_j\}\subseteq I_\sigma (C)\subseteq I_\sigma (S)ğ‘˜âˆˆğ½âˆª{ğ‘–ğ‘—}âŠ†ğ¼ğœ(ğ¶)âŠ†ğ¼ğœ(ğ‘†) and \min I_\sigma (C)=kminğ¼ğœ(ğ¶)=ğ‘˜, implying that C\in {{\mathcal {S}}}_kğ¶âˆˆîˆ¿ğ‘˜ is a superset solution of S. Then C contains a minimal superset solution T^*\in {{\mathcal {S}}}_kğ‘‡âˆ—âˆˆîˆ¿ğ‘˜ of S, where I_\sigma (T^*)\cap [1,i_{j-1}]=I_\sigma (T^*)\cap \{k,i_1,i_2,\ldots ,i_{j-1}\}\supseteq J= I_\sigma (T)\cap \{k,i_1,i_2,\ldots ,i_{j-1}\}=I_\sigma (T)\cap [1,i_{j-1}]ğ¼ğœ(ğ‘‡âˆ—)âˆ©[1,ğ‘–ğ‘—âˆ’1]=ğ¼ğœ(ğ‘‡âˆ—)âˆ©{ğ‘˜,ğ‘–1,ğ‘–2,â€¦,ğ‘–ğ‘—âˆ’1}âŠ‡ğ½=ğ¼ğœ(ğ‘‡)âˆ©{ğ‘˜,ğ‘–1,ğ‘–2,â€¦,ğ‘–ğ‘—âˆ’1}=ğ¼ğœ(ğ‘‡)âˆ©[1,ğ‘–ğ‘—âˆ’1] and i_j \in I_\sigma (T^*)ğ‘–ğ‘—âˆˆğ¼ğœ(ğ‘‡âˆ—). If I_\sigma (T^*)\cap [1,i_{j-1}]\supsetneq Jğ¼ğœ(ğ‘‡âˆ—)âˆ©[1,ğ‘–ğ‘—âˆ’1]âŠ‹ğ½ or i_j\not \in I_\sigma (T)ğ‘–ğ‘—âˆ‰ğ¼ğœ(ğ‘‡), then I_\sigma (T^*)\prec I_\sigma (T)ğ¼ğœ(ğ‘‡âˆ—)â‰ºğ¼ğœ(ğ‘‡) would hold, contradicting that T is the lex-min solution of S. Hence I_\sigma (T)\cap [1,i_{j-1}]=J=I_\sigma (T^*)\cap [1,i_{j-1}]ğ¼ğœ(ğ‘‡)âˆ©[1,ğ‘–ğ‘—âˆ’1]=ğ½=ğ¼ğœ(ğ‘‡âˆ—)âˆ©[1,ğ‘–ğ‘—âˆ’1] and i_j\in I_\sigma (T)ğ‘–ğ‘—âˆˆğ¼ğœ(ğ‘‡).

(ii) Based on (i), we can obtain the solution T as follows. First we find the item set I_\sigma (T)ğ¼ğœ(ğ‘‡) by applying (i) to each integer j\in [1,p]ğ‘—âˆˆ[1,ğ‘], where we construct subsets J_0\subseteq J_1\subseteq \cdots \subseteq J_p \subseteq I_\sigma (S)ğ½0âŠ†ğ½1âŠ†â‹¯âŠ†ğ½ğ‘âŠ†ğ¼ğœ(ğ‘†) such that J_0=\{k\}ğ½0={ğ‘˜} and

\begin{aligned} J_j&=\left\{ \begin{array}{ll} J_{j-1}\cup \{i_j\} &{}\quad \text {if\ }C(S;J_{j-1}\cup \{i_j\})\supsetneq S,\\ J_{j-1} &{}\quad \text {otherwise}. \end{array} \right. \end{aligned}

ğ½ğ‘—={ğ½ğ‘—âˆ’1âˆª{ğ‘–ğ‘—}ğ½ğ‘—âˆ’1if\ ğ¶(ğ‘†;ğ½ğ‘—âˆ’1âˆª{ğ‘–ğ‘—})âŠ‹ğ‘†,otherwise.

Each subset J_jğ½ğ‘— can be obtained from subset J_{j-1}ğ½ğ‘—âˆ’1 by testing whether C(S;J_{j-1}\cup \{i_j\})\supsetneq Sğ¶(ğ‘†;ğ½ğ‘—âˆ’1âˆª{ğ‘–ğ‘—})âŠ‹ğ‘† holds or not, where C(S;J_{j-1}\cup \{i_j\})ğ¶(ğ‘†;ğ½ğ‘—âˆ’1âˆª{ğ‘–ğ‘—}) is computable by calling the oracle \mathrm {L}_1L1. By (i), we have J_j=I_\sigma (T)\cap \{k,i_1,\dots ,i_j\}ğ½ğ‘—=ğ¼ğœ(ğ‘‡)âˆ©{ğ‘˜,ğ‘–1,â€¦,ğ‘–ğ‘—}, and in particular, J_p=I_\sigma (T)ğ½ğ‘=ğ¼ğœ(ğ‘‡) holds. Next we compute the component C(S;J_p)ğ¶(ğ‘†;ğ½ğ‘) by calling the oracle \mathrm {L}_1(S,V_{\langle J_p\rangle })L1(ğ‘†,ğ‘‰âŸ¨ğ½ğ‘âŸ©), where C(S;J_p)ğ¶(ğ‘†;ğ½ğ‘) is equal to the solution T by Lemma 5. The above algorithm is described as algorithm Parent(S) in Algorithm 1.

Let us mention critical parts in terms of time complexity analysis. In line 1, it takes O(qn) time to compute I_\sigma (S)ğ¼ğœ(ğ‘†). The for-loop from line 3 to 7 is repeated O(q) times. In line 4, the oracle \mathrm {L}_1(S,V_{\langle J\cup \{i_j\}\rangle })L1(ğ‘†,ğ‘‰âŸ¨ğ½âˆª{ğ‘–ğ‘—}âŸ©) is called to obtain a component Z=C(S;J\cup \{i_j\})ğ‘=ğ¶(ğ‘†;ğ½âˆª{ğ‘–ğ‘—}) and whether S=Zğ‘†=ğ‘ or not is tested. This takes O(\theta _{\mathrm {1,t}}+n)ğ‘‚(ğœƒ1,t+ğ‘›) time. The overall running time is O(q(n+\theta _{\mathrm {1,t}}))ğ‘‚(ğ‘(ğ‘›+ğœƒ1,t)). It takes O(q) space to store I_\sigma (S)ğ¼ğœ(ğ‘†) and J, and O(n) space to store S and Z. An additional O(\theta _{\mathrm {1,s}})ğ‘‚(ğœƒ1,s) space is needed for the oracle \mathrm {L}_1L1. \square â—»

For each item k\in [1,q-1]ğ‘˜âˆˆ[1,ğ‘âˆ’1], we define the parent \pi (S)ğœ‹(ğ‘†) of a non-base solution S\in {{\mathcal {S}}}_k{\setminus } {{\mathcal {B}}}_kğ‘†âˆˆîˆ¿ğ‘˜âˆ–îˆ®ğ‘˜ to be the lex-min solution of S, and define a child of a solution T\in {{\mathcal {S}}}_kğ‘‡âˆˆîˆ¿ğ‘˜ to be a non-base solution S\in {{\mathcal {S}}}_k{\setminus } {{\mathcal {B}}}_kğ‘†âˆˆîˆ¿ğ‘˜âˆ–îˆ®ğ‘˜ such that \pi (S)=Tğœ‹(ğ‘†)=ğ‘‡.

Generating Children
This subsection shows how to construct a family \mathcal {X}î‰„ of components for a given solution T so that \mathcal {X}î‰„ contains all children of T.

Lemma 7
Let (V,{{\mathcal {C}}},I=[1,q],\sigma )(ğ‘‰,îˆ¯,ğ¼=[1,ğ‘],ğœ) be an instance on a confluent system and T\in {{\mathcal {S}}}_kğ‘‡âˆˆîˆ¿ğ‘˜ be a solution for some item k\in [1,q-1]ğ‘˜âˆˆ[1,ğ‘âˆ’1]. Then:

(i)
Every child S of T satisfies [k+1,q]\cap (I_\sigma (S){\setminus } I_\sigma (T)) \ne \emptyset [ğ‘˜+1,ğ‘]âˆ©(ğ¼ğœ(ğ‘†)âˆ–ğ¼ğœ(ğ‘‡))â‰ âˆ… and is a component in {{\mathcal {C}}}_{\mathrm{max}}(T\cap V_{\langle j\rangle })îˆ¯max(ğ‘‡âˆ©ğ‘‰âŸ¨ğ‘—âŸ©) for any item j\in [k+1,q]\cap (I_\sigma (S){\setminus } I_\sigma (T))ğ‘—âˆˆ[ğ‘˜+1,ğ‘]âˆ©(ğ¼ğœ(ğ‘†)âˆ–ğ¼ğœ(ğ‘‡));

(ii)
The family of children S of T is equal to the disjoint collection of families \mathcal {C}_j = \{ C\in {{\mathcal {C}}}_{\mathrm{max}}(T\cap V_{\langle j\rangle })\mid k= \min I_\sigma (C), j=\min \{i\mid i\in [k+1,q]\cap (I_\sigma (C){\setminus } I_\sigma (T))\}, T=îˆ¯ğ‘—={ğ¶âˆˆîˆ¯max(ğ‘‡âˆ©ğ‘‰âŸ¨ğ‘—âŸ©)âˆ£ğ‘˜=minğ¼ğœ(ğ¶),ğ‘—=min{ğ‘–âˆ£ğ‘–âˆˆ[ğ‘˜+1,ğ‘]âˆ©(ğ¼ğœ(ğ¶)âˆ–ğ¼ğœ(ğ‘‡))},ğ‘‡= Parent(C)\}(ğ¶)} over all items j\in [k+1, q]{\setminus } I_\sigma (T)ğ‘—âˆˆ[ğ‘˜+1,ğ‘]âˆ–ğ¼ğœ(ğ‘‡); and

(iii)
The set of all children of T can be constructed in O\big (q \theta _{2,\mathrm {t}} + q^2(n+\theta _{1,\mathrm {t}})\delta (T) \big )ğ‘‚(ğ‘ğœƒ2,t+ğ‘2(ğ‘›+ğœƒ1,t)ğ›¿(ğ‘‡)) time and O(q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}})ğ‘‚(ğ‘+ğ‘›+ğœƒ1,s+ğœƒ2,s) space.

Proof
(i) Note that [0,k]\cap I_\sigma (S)=[0,k]\cap I_\sigma (T)=\{k\}[0,ğ‘˜]âˆ©ğ¼ğœ(ğ‘†)=[0,ğ‘˜]âˆ©ğ¼ğœ(ğ‘‡)={ğ‘˜} since S,T\in {{\mathcal {S}}}_kğ‘†,ğ‘‡âˆˆîˆ¿ğ‘˜. Since S\subseteq Tğ‘†âŠ†ğ‘‡ are both solutions, I_\sigma (S)\supsetneq I_\sigma (T)ğ¼ğœ(ğ‘†)âŠ‹ğ¼ğœ(ğ‘‡). Hence [k+1,q]\cap (I_\sigma (S){\setminus } I_\sigma (T)) \ne \emptyset [ğ‘˜+1,ğ‘]âˆ©(ğ¼ğœ(ğ‘†)âˆ–ğ¼ğœ(ğ‘‡))â‰ âˆ…. Let j be an arbitrary item in [k+1,q]\cap (I_\sigma (S){\setminus } I_\sigma (T))[ğ‘˜+1,ğ‘]âˆ©(ğ¼ğœ(ğ‘†)âˆ–ğ¼ğœ(ğ‘‡)). Since S\subseteq T\cap V_{\langle j\rangle }ğ‘†âŠ†ğ‘‡âˆ©ğ‘‰âŸ¨ğ‘—âŸ©, it holds that {{\mathcal {C}}}_{\mathrm{max}}(S;T\cap V_{\langle j\rangle })\ne \emptyset îˆ¯max(ğ‘†;ğ‘‡âˆ©ğ‘‰âŸ¨ğ‘—âŸ©)â‰ âˆ….

Let C be a (T\cap V_{\langle j\rangle })(ğ‘‡âˆ©ğ‘‰âŸ¨ğ‘—âŸ©)-maximal component in {{\mathcal {C}}}_{\mathrm{max}}(S;T\cap V_{\langle j\rangle })îˆ¯max(ğ‘†;ğ‘‡âˆ©ğ‘‰âŸ¨ğ‘—âŸ©). It suffices to show that C=Sğ¶=ğ‘†. Note that S\subseteq C\subseteq Tğ‘†âŠ†ğ¶âŠ†ğ‘‡, I_\sigma (S)\supseteq I_\sigma (C)\supseteq I_\sigma (T)ğ¼ğœ(ğ‘†)âŠ‡ğ¼ğœ(ğ¶)âŠ‡ğ¼ğœ(ğ‘‡) and k=\min I_\sigma (S)=\min I_\sigma (T)ğ‘˜=minğ¼ğœ(ğ‘†)=minğ¼ğœ(ğ‘‡) implies \min I_\sigma (C)= kminğ¼ğœ(ğ¶)=ğ‘˜.

We show that C\in {{\mathcal {S}}}ğ¶âˆˆîˆ¿, which implies C\in {{\mathcal {S}}}_kğ¶âˆˆîˆ¿ğ‘˜. Note that j \in I_\sigma (C){\setminus } I_\sigma (T)ğ‘—âˆˆğ¼ğœ(ğ¶)âˆ–ğ¼ğœ(ğ‘‡), and C\subsetneq Tğ¶âŠŠğ‘‡.

Assume that C is not a solution; i.e., there is a solution C^*\in {{\mathcal {S}}}ğ¶âˆ—âˆˆîˆ¿ such that C\subsetneq C^*ğ¶âŠŠğ¶âˆ— and I_\sigma (C)=I_\sigma (C^*)ğ¼ğœ(ğ¶)=ğ¼ğœ(ğ¶âˆ—), where j\in I_\sigma (C)=I_\sigma (C^*)ğ‘—âˆˆğ¼ğœ(ğ¶)=ğ¼ğœ(ğ¶âˆ—) means that C^*\subseteq V_{\langle j\rangle }ğ¶âˆ—âŠ†ğ‘‰âŸ¨ğ‘—âŸ©. Hence C^*{\setminus } T\ne \emptyset ğ¶âˆ—âˆ–ğ‘‡â‰ âˆ… by the (T\cap V_{\langle j\rangle })(ğ‘‡âˆ©ğ‘‰âŸ¨ğ‘—âŸ©)-maximality of C. Since C,C^*,T\in {{\mathcal {C}}}ğ¶,ğ¶âˆ—,ğ‘‡âˆˆîˆ¯ and C\subseteq C^*\cap Tğ¶âŠ†ğ¶âˆ—âˆ©ğ‘‡, we have C^*\cup T\in {{\mathcal {C}}}ğ¶âˆ—âˆªğ‘‡âˆˆîˆ¯ by the transitivity. We also see that I_\sigma (C^*\cup T)=I_\sigma (C^*)\cap I_\sigma (T)=I_\sigma (C)\cap I_\sigma (T)=I_\sigma (T)ğ¼ğœ(ğ¶âˆ—âˆªğ‘‡)=ğ¼ğœ(ğ¶âˆ—)âˆ©ğ¼ğœ(ğ‘‡)=ğ¼ğœ(ğ¶)âˆ©ğ¼ğœ(ğ‘‡)=ğ¼ğœ(ğ‘‡). This, however, contradicts that T is a solution, proving that C\in {{\mathcal {S}}}_kğ¶âˆˆîˆ¿ğ‘˜. If S\subsetneq Cğ‘†âŠŠğ¶, then S\subsetneq C\subsetneq Tğ‘†âŠŠğ¶âŠŠğ‘‡ would hold for S,C,T\in {{\mathcal {S}}}_kğ‘†,ğ¶,ğ‘‡âˆˆîˆ¿ğ‘˜, contradicting that T is a minimal superset solution of S. Therefore S=Cğ‘†=ğ¶.

(ii) By (i), the family \mathcal {S}_Tîˆ¿ğ‘‡ of children of T is contained in the family of (T\cap V_{\langle j\rangle })(ğ‘‡âˆ©ğ‘‰âŸ¨ğ‘—âŸ©)-maximal components over all items j\in [k+1,q]\cap I_\sigma (T)ğ‘—âˆˆ[ğ‘˜+1,ğ‘]âˆ©ğ¼ğœ(ğ‘‡). Hence

\begin{aligned} \mathcal {S}_T =\cup _{j\in [k+1,q]\cap I_\sigma (T)}\{C\in {{\mathcal {C}}}_{\mathrm{max}}(T\cap V_{\langle j\rangle }) \mid T=\textsc {Parent}(C)\}. \end{aligned}

îˆ¿ğ‘‡=âˆªğ‘—âˆˆ[ğ‘˜+1,ğ‘]âˆ©ğ¼ğœ(ğ‘‡){ğ¶âˆˆîˆ¯max(ğ‘‡âˆ©ğ‘‰âŸ¨ğ‘—âŸ©)âˆ£ğ‘‡=PARENT(ğ¶)}.

Note that if a subset S\subseteq Vğ‘†âŠ†ğ‘‰ is a child of T, then k= \min I_\sigma (S)ğ‘˜=minğ¼ğœ(ğ‘†) and S\in {{\mathcal {C}}}_{\mathrm{max}}(T\cap V_{\langle j\rangle })ğ‘†âˆˆîˆ¯max(ğ‘‡âˆ©ğ‘‰âŸ¨ğ‘—âŸ©) for all items j\in [k+1,q]\cap (I_\sigma (S){\setminus } I_\sigma (T))ğ‘—âˆˆ[ğ‘˜+1,ğ‘]âˆ©(ğ¼ğœ(ğ‘†)âˆ–ğ¼ğœ(ğ‘‡)). Hence we see that \mathcal {S}_Tîˆ¿ğ‘‡ is equal to the disjoint collection of families \mathcal {C}_j = \{ C\in {{\mathcal {C}}}_{\mathrm{max}}(T\cap V_{\langle j\rangle })\mid k= \min I_\sigma (C), j=\min \{i\mid i\in [k+1,q]\cap (I_\sigma (C){\setminus } I_\sigma (T))\}, T=îˆ¯ğ‘—={ğ¶âˆˆîˆ¯max(ğ‘‡âˆ©ğ‘‰âŸ¨ğ‘—âŸ©)âˆ£ğ‘˜=minğ¼ğœ(ğ¶),ğ‘—=min{ğ‘–âˆ£ğ‘–âˆˆ[ğ‘˜+1,ğ‘]âˆ©(ğ¼ğœ(ğ¶)âˆ–ğ¼ğœ(ğ‘‡))},ğ‘‡= Parent(C)\}(ğ¶)} over all items j\in [k+1, q]{\setminus } I_\sigma (T)ğ‘—âˆˆ[ğ‘˜+1,ğ‘]âˆ–ğ¼ğœ(ğ‘‡).

figure b
(iii) Based on (ii), we obtain an algorithm described in Algorithm 2. We analyze the time and space complexities of the algorithm. Note that T may have no children. The outer for-loop from line 1 to 10 is repeated O(q) times. Computing {{\mathcal {C}}}(T\cap V_{\langle j\rangle })îˆ¯(ğ‘‡âˆ©ğ‘‰âŸ¨ğ‘—âŸ©) in line 2 takes \theta _{2,\mathrm {t}}ğœƒ2,t time by calling the oracle L_22. The inner for-loop from line 3 to 7 is repeated at most \delta (T\cap V_{\langle j\rangle })ğ›¿(ğ‘‡âˆ©ğ‘‰âŸ¨ğ‘—âŸ©) times for each j, and the most time-consuming part of the inner for-loop is algorithm Parent(S) in line 4, which takes O(q(n+\theta _{1,\mathrm {t}}))ğ‘‚(ğ‘(ğ‘›+ğœƒ1,t)) time by Lemma 6(ii). Recall that \delta ğ›¿ is a non-decreasing function. Then the running time of algorithm Children(T, k) is evaluated by

\begin{aligned} O\Big (q\theta _{2,\mathrm {t}} + q(n+\theta _{1,\mathrm {t}})\sum _{j\in [k+1,q]{\setminus }I_\sigma (T)} \delta (T\cap V_{\langle j\rangle })\Big ) = O\big (q \theta _{2,\mathrm {t}} + q^2(n+\theta _{1,\mathrm {t}})\delta (T) \big ). \end{aligned}

ğ‘‚(ğ‘ğœƒ2,t+ğ‘(ğ‘›+ğœƒ1,t)âˆ‘ğ‘—âˆˆ[ğ‘˜+1,ğ‘]âˆ–ğ¼ğœ(ğ‘‡)ğ›¿(ğ‘‡âˆ©ğ‘‰âŸ¨ğ‘—âŸ©))=ğ‘‚(ğ‘ğœƒ2,t+ğ‘2(ğ‘›+ğœƒ1,t)ğ›¿(ğ‘‡)).

For the space complexity, we do not need to share the space between iterations of the outer for-loop from line 1 to 8. In each iteration, we use the oracle L_22 and algorithm Parent(S), whose space complexity is O(q+n+\theta _{1,\mathrm {s}})ğ‘‚(ğ‘+ğ‘›+ğœƒ1,s) by Lemma 6(ii). Then algorithm Children(T, k) uses O(q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}})ğ‘‚(ğ‘+ğ‘›+ğœƒ1,s+ğœƒ2,s) space. \square â—»

Traversing Family Tree
We are ready to describe an entire algorithm for enumerating solutions in {{\mathcal {S}}}_kîˆ¿ğ‘˜ for a given integer k\in [0,q]ğ‘˜âˆˆ[0,ğ‘]. We first compute the component set {{\mathcal {C}}}_{\mathrm{max}}(V_{\langle k\rangle })îˆ¯max(ğ‘‰âŸ¨ğ‘˜âŸ©). We next compute the family {{\mathcal {B}}}_k~(\subseteq {{\mathcal {C}}}_{\mathrm{max}}(V_{\langle k\rangle }))îˆ®ğ‘˜ (âŠ†îˆ¯max(ğ‘‰âŸ¨ğ‘˜âŸ©)) of bases by testing whether k=\min I_\sigma (T)ğ‘˜=minğ¼ğœ(ğ‘‡) or not, where {{\mathcal {B}}}_k\subseteq {{\mathcal {S}}}_kîˆ®ğ‘˜âŠ†îˆ¿ğ‘˜. When k=0ğ‘˜=0 or q, we are done with {{\mathcal {B}}}_k={{\mathcal {S}}}_kîˆ®ğ‘˜=îˆ¿ğ‘˜ by Lemma 4(iii). Let k\in [1,q-1]ğ‘˜âˆˆ[1,ğ‘âˆ’1]. Suppose that we are given a solution T\in {{\mathcal {S}}}_kğ‘‡âˆˆîˆ¿ğ‘˜. We find all the children of T by Children(T, k) in Algorithm 2. By applying Algorithm 2 to a newly found child recursively, we can find all solutions in {{\mathcal {S}}}_kîˆ¿ğ‘˜.

When no child is found to a given solution T\in {{\mathcal {S}}}_kğ‘‡âˆˆîˆ¿ğ‘˜, we may need to go up to an ancestor by traversing recursive calls O(n) times before we generate the next solution. This would result in time delay of O(n\alpha )ğ‘‚(ğ‘›ğ›¼), where \alpha ğ›¼ denotes the time complexity required for a single run of Children(T, k). To improve the delay to O(\alpha )ğ‘‚(ğ›¼), we employ the alternative output method [31], where we output the children of T after (resp., before) generating all descendants when the depth of the recursive call to T is an even (resp., odd) integer.

Assume that a volume function \rho : 2^V\rightarrow {\mathbb {R}}ğœŒ:2ğ‘‰â†’â„ is given. An algorithm that enumerates all \rho ğœŒ-positive solutions in {{\mathcal {S}}}_kîˆ¿ğ‘˜ is described in Algorithms 3 and 4.

figure c
figure d
Lemma 8
Let (V,{{\mathcal {C}}},I=[1,q],\sigma )(ğ‘‰,îˆ¯,ğ¼=[1,ğ‘],ğœ) be an instance on a confluent system. For each k\in [0,q]ğ‘˜âˆˆ[0,ğ‘], all \rho ğœŒ-positive solutions in {{\mathcal {S}}}_kîˆ¿ğ‘˜ can be enumerated in O\big (q\theta _{2,\mathrm {t}} + (q(n+\theta _{1,\mathrm {t}}) +\theta _{\rho ,\mathrm {t}})q\delta (V_{\langle k\rangle })\big )ğ‘‚(ğ‘ğœƒ2,t+(ğ‘(ğ‘›+ğœƒ1,t)+ğœƒğœŒ,t)ğ‘ğ›¿(ğ‘‰âŸ¨ğ‘˜âŸ©)) delay and O\big ((q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}} +\theta _{\rho ,\mathrm {s}}) n\big )ğ‘‚((ğ‘+ğ‘›+ğœƒ1,s+ğœƒ2,s+ğœƒğœŒ,s)ğ‘›) space.

Proof
Let T\in {{\mathcal {S}}}_kğ‘‡âˆˆîˆ¿ğ‘˜ be a solution such that \rho (T)\le 0ğœŒ(ğ‘‡)â‰¤0. In this case, \rho (S)\le \rho (T)\le 0ğœŒ(ğ‘†)â‰¤ğœŒ(ğ‘‡)â‰¤0 holds for all descendants S of T since S\subseteq Tğ‘†âŠ†ğ‘‡. Then we do not need to make recursive calls for such T.

We analyze the time delay. Let \alpha ğ›¼ denote the time complexity required for a single run of Children(T, k). By Lemma 7(ii) and \delta (T)\le \delta (V_{\langle k\rangle })ğ›¿(ğ‘‡)â‰¤ğ›¿(ğ‘‰âŸ¨ğ‘˜âŸ©), we have \alpha =O\big (q\theta _{2,\mathrm {t}} + q^2(n+\theta _{1,\mathrm {t}})\delta (V_{\langle k\rangle })\big )ğ›¼=ğ‘‚(ğ‘ğœƒ2,t+ğ‘2(ğ‘›+ğœƒ1,t)ğ›¿(ğ‘‰âŸ¨ğ‘˜âŸ©)). In Algorithm 3 and Descendants, we also need to compute \rho (S)ğœŒ(ğ‘†) for all child candidates S. The complexity is O(q\delta (V_{\langle k\rangle })\theta _{\rho ,\mathrm {t}})ğ‘‚(ğ‘ğ›¿(ğ‘‰âŸ¨ğ‘˜âŸ©)ğœƒğœŒ,t) since \rho (S)ğœŒ(ğ‘†) is called at most q\delta (V_{\langle k\rangle })ğ‘ğ›¿(ğ‘‰âŸ¨ğ‘˜âŸ©) times. Hence we see that the time complexity of Algorithm 3 and Descendants without including recursive calls is O(\alpha +q\delta (V_{\langle k\rangle })\theta _{\rho ,\mathrm {t}})ğ‘‚(ğ›¼+ğ‘ğ›¿(ğ‘‰âŸ¨ğ‘˜âŸ©)ğœƒğœŒ,t).

From Algorithm 3 and Descendants, we observe:

(i)
When d is odd, the solution S for any call Descendants(S,k,d+1)(ğ‘†,ğ‘˜,ğ‘‘+1) is output immediately before Descendants(S,k,d+1)(ğ‘†,ğ‘˜,ğ‘‘+1) is executed; and

(ii)
when d is even, the solution S for any call Descendants(S,k,d+1)(ğ‘†,ğ‘˜,ğ‘‘+1) is output immediately after Descendants(S,k,d+1)(ğ‘†,ğ‘˜,ğ‘‘+1) is executed.

Let m denote the number of all calls of Descendants during a whole execution of Algorithm 3. Let d_1=1,d_2,\ldots ,d_mğ‘‘1=1,ğ‘‘2,â€¦,ğ‘‘ğ‘š denote the sequence of depths d in each Descendants(S,k,d+1)(ğ‘†,ğ‘˜,ğ‘‘+1) of the m calls. Note that d=d_iğ‘‘=ğ‘‘ğ‘– satisfies (i) when d_{i+1}ğ‘‘ğ‘–+1 is odd and d_{i+1}=d_i+1ğ‘‘ğ‘–+1=ğ‘‘ğ‘–+1, whereas d=d_iğ‘‘=ğ‘‘ğ‘– satisfies (ii) when d_{i+1}ğ‘‘ğ‘–+1 is even and d_{i+1}=d_i-1ğ‘‘ğ‘–+1=ğ‘‘ğ‘–âˆ’1. Therefore we easily see that during three consecutive calls with depth d_iğ‘‘ğ‘–, d_{i+1}ğ‘‘ğ‘–+1 and d_{i+2}ğ‘‘ğ‘–+2, at least one solution will be output. This implies that the time delay for outputting a solution is O(\alpha +q\delta (V_{\langle k\rangle })\theta _{\rho ,\mathrm {t}})ğ‘‚(ğ›¼+ğ‘ğ›¿(ğ‘‰âŸ¨ğ‘˜âŸ©)ğœƒğœŒ,t).

We analyze the space complexity. Observe that the number of calls Descendants whose executions are not finished during an execution of Algorithm 3 is the depth d of the current call Descendants(S,k,d+1)(ğ‘†,ğ‘˜,ğ‘‘+1). In Algorithm 4, |T|+d\le n+1|ğ‘‡|+ğ‘‘â‰¤ğ‘›+1 holds initially, and Descendants(S,k,d+1)(ğ‘†,ğ‘˜,ğ‘‘+1) is called for a nonempty subset S\subsetneq Tğ‘†âŠŠğ‘‡, where |S|<|T||ğ‘†|<|ğ‘‡|. Hence |S|+d\le n+1|ğ‘†|+ğ‘‘â‰¤ğ‘›+1 holds when Descendants(S,k,d+1)(ğ‘†,ğ‘˜,ğ‘‘+1) is called. Then Algorithm 3 can be implemented to run in O(n(\beta +\theta _{\rho ,\mathrm {s}}))ğ‘‚(ğ‘›(ğ›½+ğœƒğœŒ,s)) space, where \beta ğ›½ denotes the space required for a single run of Children(T, k). We have \beta =O(q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}})ğ›½=ğ‘‚(ğ‘+ğ‘›+ğœƒ1,s+ğœƒ2,s) by Lemma 7(ii). Then the overall space complexity is O\big ((q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}}+\theta _{\rho ,\mathrm {s}}) n\big )ğ‘‚((ğ‘+ğ‘›+ğœƒ1,s+ğœƒ2,s+ğœƒğœŒ,s)ğ‘›). \square â—»

The volume function is introduced to impose a condition on the output solutions. For example, when \rho (X)=|X|-pğœŒ(ğ‘‹)=|ğ‘‹|âˆ’ğ‘ for a constant p, all solutions X\in {{\mathcal {S}}}_kğ‘‹âˆˆîˆ¿ğ‘˜ with |X|\ge p+1|ğ‘‹|â‰¥ğ‘+1 will be output. In particular, all solutions in {{\mathcal {S}}}_kîˆ¿ğ‘˜ will be output for p\le 0ğ‘â‰¤0. In this case, we have \theta _{\rho ,\mathrm {t}}=\theta _{\rho ,\mathrm {s}}=O(n)ğœƒğœŒ,t=ğœƒğœŒ,s=ğ‘‚(ğ‘›), and thus the delay is O\big (q\theta _{2,\mathrm {t}} + q^2(n+\theta _{1,\mathrm {t}})\delta (V_{\langle k\rangle })\big )ğ‘‚(ğ‘ğœƒ2,t+ğ‘2(ğ‘›+ğœƒ1,t)ğ›¿(ğ‘‰âŸ¨ğ‘˜âŸ©)) and the space is O\big ((q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}}) n\big )ğ‘‚((ğ‘+ğ‘›+ğœƒ1,s+ğœƒ2,s)ğ‘›).

Theorem 1 is immediate from Lemma 8 since \delta (V_{\langle k\rangle })\le \delta (V)ğ›¿(ğ‘‰âŸ¨ğ‘˜âŸ©)â‰¤ğ›¿(ğ‘‰) holds by our assumption that \delta (Y)\le \delta (X)ğ›¿(ğ‘Œ)â‰¤ğ›¿(ğ‘‹) for subsets Y\subseteq X\subseteq Vğ‘ŒâŠ†ğ‘‹âŠ†ğ‘‰.

Enumerating Components
This section shows that our algorithm in the previous section can enumerate all components in a given confluent system (V,{{\mathcal {C}}})(ğ‘‰,îˆ¯) with n=|V|\ge 1ğ‘›=|ğ‘‰|â‰¥1. For this, we construct an instance \mathcal {I}=(V,{{\mathcal {C}}},I=[1,n],\varphi )îˆµ=(ğ‘‰,îˆ¯,ğ¼=[1,ğ‘›],ğœ‘) as follows. Denote V by \{v_1,\dots ,v_n\}{ğ‘£1,â€¦,ğ‘£ğ‘›}. We set I=[1,n]ğ¼=[1,ğ‘›] and define a function \varphi :V\rightarrow 2^Iğœ‘:ğ‘‰â†’2ğ¼ to be \varphi (v_k)\triangleq I{\setminus }\{k\}ğœ‘(ğ‘£ğ‘˜)â‰œğ¼âˆ–{ğ‘˜} for each element v_k\in Vğ‘£ğ‘˜âˆˆğ‘‰. For each subset X\subseteq Vğ‘‹âŠ†ğ‘‰, let \mathsf {Ind}(X)ğ–¨ğ—‡ğ–½(ğ‘‹) denote the set of indices i of elements v_i\in Xğ‘£ğ‘–âˆˆğ‘‹; i.e., \mathsf {Ind}(X)=\{i\in [1,n]\mid v_i\in X\}ğ–¨ğ—‡ğ–½(ğ‘‹)={ğ‘–âˆˆ[1,ğ‘›]âˆ£ğ‘£ğ‘–âˆˆğ‘‹}, and I_\varphi (X)\subseteq [1,n]ğ¼ğœ‘(ğ‘‹)âŠ†[1,ğ‘›] denote the common item set over \varphi (v)ğœ‘(ğ‘£), v\in Xğ‘£âˆˆğ‘‹; i.e., I_\varphi (X) = \bigcap _{v\in X}\varphi (v)ğ¼ğœ‘(ğ‘‹)=â‹‚ğ‘£âˆˆğ‘‹ğœ‘(ğ‘£). Observe that I_\varphi (X)=I{\setminus }\mathsf {Ind}(X)ğ¼ğœ‘(ğ‘‹)=ğ¼âˆ–ğ–¨ğ—‡ğ–½(ğ‘‹).

Lemma 9
Let (V=\{v_1,\dots ,v_n\},{{\mathcal {C}}})(ğ‘‰={ğ‘£1,â€¦,ğ‘£ğ‘›},îˆ¯) be a confluent system with n\ge 1ğ‘›â‰¥1. The family {{\mathcal {C}}}îˆ¯ of all components is equal to the family {{\mathcal {S}}}îˆ¿ of all solutions in the instance (V,{{\mathcal {C}}},I=[1,n],\varphi )(ğ‘‰,îˆ¯,ğ¼=[1,ğ‘›],ğœ‘).

Proof
Since any solution S\in {{\mathcal {S}}}ğ‘†âˆˆîˆ¿ is a component, it holds that {{\mathcal {C}}}\supseteq {{\mathcal {S}}}îˆ¯âŠ‡îˆ¿. We prove that {{\mathcal {C}}}\subseteq {{\mathcal {S}}}îˆ¯âŠ†îˆ¿. Let X\in {{\mathcal {C}}}ğ‘‹âˆˆîˆ¯. For any superset Y\supsetneq Xğ‘ŒâŠ‹ğ‘‹, it holds that I_{\varphi }(Y)=I{\setminus } \mathsf {Ind}(Y)\subsetneq I{\setminus } \mathsf {Ind}(X)=I_{\varphi }(X)ğ¼ğœ‘(ğ‘Œ)=ğ¼âˆ–ğ–¨ğ—‡ğ–½(ğ‘Œ)âŠŠğ¼âˆ–ğ–¨ğ—‡ğ–½(ğ‘‹)=ğ¼ğœ‘(ğ‘‹). The component X is a solution in (V,{{\mathcal {C}}},I,\varphi )(ğ‘‰,îˆ¯,ğ¼,ğœ‘) since no superset of X has the same common item set as X. \square â—»

Since the family {{\mathcal {C}}}îˆ¯ of components is equal to the family {{\mathcal {S}}}îˆ¿ of solutions to the instance \mathcal {I}=(V,{{\mathcal {C}}},I,\varphi )îˆµ=(ğ‘‰,îˆ¯,ğ¼,ğœ‘) by Lemma 9, we can enumerate all components in (V,{{\mathcal {C}}})(ğ‘‰,îˆ¯) by running our algorithm on the instance \mathcal {I}îˆµ. By |I|=n|ğ¼|=ğ‘›, we have the following corollary to Theorem 1.

Corollary 1
Let (V,{{\mathcal {C}}})(ğ‘‰,îˆ¯) be a confluent system with n=|V|\ge 1ğ‘›=|ğ‘‰|â‰¥1 and a volume function \rho ğœŒ. All \rho ğœŒ-positive components in {{\mathcal {C}}}îˆ¯ can be enumerated in O\big ( n\theta _{2,\mathrm {t}} + (n^2+n\theta _{1,\mathrm {t}} +\theta _{\rho ,\mathrm {t}})n \delta (V)\big )ğ‘‚(ğ‘›ğœƒ2,t+(ğ‘›2+ğ‘›ğœƒ1,t+ğœƒğœŒ,t)ğ‘›ğ›¿(ğ‘‰)) delay and O\big ((n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}} +\theta _{\rho ,\mathrm {s}}) n\big )ğ‘‚((ğ‘›+ğœƒ1,s+ğœƒ2,s+ğœƒğœŒ,s)ğ‘›) space.

Confluent System in Mixed Graph with Meta-Weight Function
Our enumeration algorithm in a confluent system can be applied to several problems of enumerating subgraphs that satisfy certain types of connectivity requirements over a given graph. To treat these applications universally, this subsection presents a general method of constructing a confluent system based on a mixed graph and a weight function on elements in the graph.

Meta-Weight Function in Mixed Graph
Let M be a mixed graph, which is defined to be a graph that may contain undirected edges and directed edges. In this paper, M may have multiple edges but no self-loops. Let V(M), \mathbf {E}(M)ğ„(ğ‘€) and {\overline{E}}(M)ğ¸â¯â¯â¯â¯(ğ‘€) denote the sets of vertices, directed edges and undirected edges, respectively. Let E(M)\triangleq \mathbf {E}(M)\cup {\overline{E}}(M)ğ¸(ğ‘€)â‰œğ„(ğ‘€)âˆªğ¸â¯â¯â¯â¯(ğ‘€). Let n=|V(M)|ğ‘›=|ğ‘‰(ğ‘€)| and m=|E(M)|ğ‘š=|ğ¸(ğ‘€)|. For a vertex subset X\subseteq Vğ‘‹âŠ†ğ‘‰, let M[X] denote the subgraph induced from M by X. For a subset X\subseteq V(M)\cup E(M)ğ‘‹âŠ†ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€), let V(X) denote the set of vertices in X\cap V(M)ğ‘‹âˆ©ğ‘‰(ğ‘€) and the end-vertices of edges in X\cap E(M)ğ‘‹âˆ©ğ¸(ğ‘€). For two vertices u,v\in V(M)ğ‘¢,ğ‘£âˆˆğ‘‰(ğ‘€), let

\mathbf {E}(u,v)ğ„(ğ‘¢,ğ‘£) denote the set of directed edges from u to v,

{\overline{E}}(u,v)ğ¸â¯â¯â¯â¯(ğ‘¢,ğ‘£) denote the set of undirected edges between u and v in M, and

E(u,v)\triangleq \mathbf {E}(u,v)\cup {\overline{E}}(u,v)ğ¸(ğ‘¢,ğ‘£)â‰œğ„(ğ‘¢,ğ‘£)âˆªğ¸â¯â¯â¯â¯(ğ‘¢,ğ‘£).

For two non-empty subsets X,Y\subseteq V(M)ğ‘‹,ğ‘ŒâŠ†ğ‘‰(ğ‘€), let

\mathbf {E}(X,Y)\triangleq \bigcup _{u\in X,v\in Y}\mathbf {E}(u,v)ğ„(ğ‘‹,ğ‘Œ)â‰œâ‹ƒğ‘¢âˆˆğ‘‹,ğ‘£âˆˆğ‘Œğ„(ğ‘¢,ğ‘£),

{\overline{E}}(X,Y)\triangleq \bigcup _{u\in X,v\in Y}{\overline{E}}(u,v)ğ¸â¯â¯â¯â¯(ğ‘‹,ğ‘Œ)â‰œâ‹ƒğ‘¢âˆˆğ‘‹,ğ‘£âˆˆğ‘Œğ¸â¯â¯â¯â¯(ğ‘¢,ğ‘£) and

E(X,Y)\triangleq \bigcup _{u\in X,v\in Y}E(u,v)ğ¸(ğ‘‹,ğ‘Œ)â‰œâ‹ƒğ‘¢âˆˆğ‘‹,ğ‘£âˆˆğ‘Œğ¸(ğ‘¢,ğ‘£).

For two vertices s,t\in V(M)ğ‘ ,ğ‘¡âˆˆğ‘‰(ğ‘€), an s, t-cut C is defined to be an ordered pair (S, T) of disjoint subsets S,T\subseteq V(M)ğ‘†,ğ‘‡âŠ†ğ‘‰(ğ‘€) such that s\in Sğ‘ âˆˆğ‘† and t\in Tğ‘¡âˆˆğ‘‡, and the element set \varepsilon (C)ğœ€(ğ¶) of C (or \varepsilon (S,T)ğœ€(ğ‘†,ğ‘‡) of (S, T)) is defined to be a union F\cup Rğ¹âˆªğ‘… of the edge subset F=E(S,T)ğ¹=ğ¸(ğ‘†,ğ‘‡) and the vertex subset R=V(M){\setminus } (S\cup T)ğ‘…=ğ‘‰(ğ‘€)âˆ–(ğ‘†âˆªğ‘‡), where R=\emptyset ğ‘…=âˆ… is allowed.

We define a meta-weight function on M to be \omega : 2^{V(M)\cup E(M)}\times (V(M)\cup E(M))\rightarrow {\mathbb {R}}_+ğœ”:2ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€)Ã—(ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€))â†’â„+. For each subset X\in 2^{V(M)\cup E(M)}ğ‘‹âˆˆ2ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€), we define the function \omega _X: V(M)\cup E(M)\rightarrow {\mathbb {R}}_+ğœ”ğ‘‹:ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€)â†’â„+ induced from \omega ğœ” by X so that \omega _X(a)=\omega (X,a)ğœ”ğ‘‹(ğ‘)=ğœ”(ğ‘‹,ğ‘) for each element a\in V(M)\cup E(M)ğ‘âˆˆğ‘‰(ğ‘€)âˆªğ¸(ğ‘€). We call \omega ğœ” monotone if every two subsets X\subseteq Y\subseteq V(M)ğ‘‹âŠ†ğ‘ŒâŠ†ğ‘‰(ğ‘€) satisfy

\begin{aligned} \omega _{Y}(a)\ge \omega _X(a) \text{ for } \text{ each } \text{ element } a\in V(M)\cup E(M)\text{. } \end{aligned}

ğœ”ğ‘Œ(ğ‘)â‰¥ğœ”ğ‘‹(ğ‘) for  each  element ğ‘âˆˆğ‘‰(ğ‘€)âˆªğ¸(ğ‘€). 

For two vertices s,t\in V(M)ğ‘ ,ğ‘¡âˆˆğ‘‰(ğ‘€) and a subset X\subseteq V(M)\cup E(M)ğ‘‹âŠ†ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€), define

\begin{aligned} \mu (s,t;X)\triangleq \min \{\omega _X(\varepsilon (C))\mid s,t \text{-cuts }\ C=(S,T)\ \text{ in }\ M\}. \end{aligned}

ğœ‡(ğ‘ ,ğ‘¡;ğ‘‹)â‰œmin{ğœ”ğ‘‹(ğœ€(ğ¶))âˆ£ğ‘ ,ğ‘¡-cuts  ğ¶=(ğ‘†,ğ‘‡)  in  ğ‘€}.

We call a subset X\subseteq V(M)\cup E(M)ğ‘‹âŠ†ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€) k-connected if |V(X)|=1|ğ‘‰(ğ‘‹)|=1 or \mu (u,v;X)\ge kğœ‡(ğ‘¢,ğ‘£;ğ‘‹)â‰¥ğ‘˜ for each pair of vertices u,v\in V(X)ğ‘¢,ğ‘£âˆˆğ‘‰(ğ‘‹). The notion of k-connectivity is a generalization of the standard k-edge/vertex-connectivity in graphs. The details will be explained in Sect. 6.2.

Lemma 10
Let (M,\omega )(ğ‘€,ğœ”) be a mixed graph with a monotone meta-weight function, and k\ge 0ğ‘˜â‰¥0. For any two k-connected subsets X,Y\subseteq V(M)\cup E(M)ğ‘‹,ğ‘ŒâŠ†ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€) such that \omega _{X\cap Y}(V(X\cap Y))\ge kğœ”ğ‘‹âˆ©ğ‘Œ(ğ‘‰(ğ‘‹âˆ©ğ‘Œ))â‰¥ğ‘˜, the subset X\cup Yğ‘‹âˆªğ‘Œ is k-connected.

Proof
To derive a contradiction, assume that X\cup Yğ‘‹âˆªğ‘Œ is not k-connected; i.e., |V(X\cup Y)|\ge 2|ğ‘‰(ğ‘‹âˆªğ‘Œ)|â‰¥2 and some vertices s,t\in V(X\cup Y)ğ‘ ,ğ‘¡âˆˆğ‘‰(ğ‘‹âˆªğ‘Œ) admit an s, t-cut C=(S,T)ğ¶=(ğ‘†,ğ‘‡) with \omega _{X\cup Y}(\varepsilon (C))<kğœ”ğ‘‹âˆªğ‘Œ(ğœ€(ğ¶))<ğ‘˜. By the monotonicity of \omega ğœ”, it holds that \omega _{X\cup Y}(a)\ge \omega _X(a), \omega _Y(a)ğœ”ğ‘‹âˆªğ‘Œ(ğ‘)â‰¥ğœ”ğ‘‹(ğ‘),ğœ”ğ‘Œ(ğ‘) for any element a\in V(M)\cup E(M)ğ‘âˆˆğ‘‰(ğ‘€)âˆªğ¸(ğ‘€). Hence \omega _{X\cup Y}(\varepsilon (C))<kğœ”ğ‘‹âˆªğ‘Œ(ğœ€(ğ¶))<ğ‘˜ implies \omega _{X}(\varepsilon (C))<kğœ”ğ‘‹(ğœ€(ğ¶))<ğ‘˜ and \omega _{Y}(\varepsilon (C))<kğœ”ğ‘Œ(ğœ€(ğ¶))<ğ‘˜. Since each of X and Y is k-connected, we see that neither of s,t\in V(X)ğ‘ ,ğ‘¡âˆˆğ‘‰(ğ‘‹) and s,t\in V(Y)ğ‘ ,ğ‘¡âˆˆğ‘‰(ğ‘Œ) occurs. Without loss of generality assume that s\in V(X{\setminus } Y)ğ‘ âˆˆğ‘‰(ğ‘‹âˆ–ğ‘Œ) and t\in V(Y{\setminus } X)ğ‘¡âˆˆğ‘‰(ğ‘Œâˆ–ğ‘‹). If some vertex v\in V(X\cap Y)ğ‘£âˆˆğ‘‰(ğ‘‹âˆ©ğ‘Œ) belongs to T (resp., S), then C would be an s, v-cut with s,v\in V(X)ğ‘ ,ğ‘£âˆˆğ‘‰(ğ‘‹) (resp., v, t-cut with v,t\in V(Y)ğ‘£,ğ‘¡âˆˆğ‘‰(ğ‘Œ)), contradicting the k-connectivity of X (resp., Y). Hence for the set R=V(M){\setminus } (S\cup T)ğ‘…=ğ‘‰(ğ‘€)âˆ–(ğ‘†âˆªğ‘‡), it holds V(X\cap Y)\subseteq Rğ‘‰(ğ‘‹âˆ©ğ‘Œ)âŠ†ğ‘…. By the assumption of X\cap Yğ‘‹âˆ©ğ‘Œ, the non-negativity and the monotonicity of \omega ğœ”, we have k\le \omega _{X\cap Y}(V(X\cap Y)) \le \omega _{X\cap Y}(R) \le \omega _{X\cup Y}(R)\le \omega _{X\cup Y}(\varepsilon (C))ğ‘˜â‰¤ğœ”ğ‘‹âˆ©ğ‘Œ(ğ‘‰(ğ‘‹âˆ©ğ‘Œ))â‰¤ğœ”ğ‘‹âˆ©ğ‘Œ(ğ‘…)â‰¤ğœ”ğ‘‹âˆªğ‘Œ(ğ‘…)â‰¤ğœ”ğ‘‹âˆªğ‘Œ(ğœ€(ğ¶)). This, however, contradicts \omega _{X\cup Y}(\varepsilon (C))<kğœ”ğ‘‹âˆªğ‘Œ(ğœ€(ğ¶))<ğ‘˜. \square â—»

For a mixed graph (M,\omega )(ğ‘€,ğœ”) with a meta-weight function and a real k\ge 0ğ‘˜â‰¥0, let {{\mathcal {C}}}(M,\omega ,k)\subseteq 2^{V(M)\cup E(M)}îˆ¯(ğ‘€,ğœ”,ğ‘˜)âŠ†2ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€) denote the family of k-connected subsets X\subseteq V(M)\cup E(M)ğ‘‹âŠ†ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€) with \omega _X(V(X))\ge kğœ”ğ‘‹(ğ‘‰(ğ‘‹))â‰¥ğ‘˜.

Lemma 11
For a mixed graph (M,\omega )(ğ‘€,ğœ”) with a monotone meta-weight function and a real k\ge 0ğ‘˜â‰¥0, let {{\mathcal {C}}}={{\mathcal {C}}}(M,\omega ,k)îˆ¯=îˆ¯(ğ‘€,ğœ”,ğ‘˜). Then {{\mathcal {C}}}îˆ¯ is confluent.

Proof
Let Z,X,Y\in {{\mathcal {C}}}ğ‘,ğ‘‹,ğ‘Œâˆˆîˆ¯ such that Z\subseteq X\cap Yğ‘âŠ†ğ‘‹âˆ©ğ‘Œ, where \omega _{X\cup Y}(V(X\cup Y))\ge \omega _{X\cup Y}(V(Z)) \ge \omega _{Z}(V(Z))\ge kğœ”ğ‘‹âˆªğ‘Œ(ğ‘‰(ğ‘‹âˆªğ‘Œ))â‰¥ğœ”ğ‘‹âˆªğ‘Œ(ğ‘‰(ğ‘))â‰¥ğœ”ğ‘(ğ‘‰(ğ‘))â‰¥ğ‘˜. By \omega _{Z}(V(Z))\ge kğœ”ğ‘(ğ‘‰(ğ‘))â‰¥ğ‘˜ and

Lemma 10, X\cup Yğ‘‹âˆªğ‘Œ is k-connected. Since \omega _{X\cup Y}(V(X\cup Y))\ge kğœ”ğ‘‹âˆªğ‘Œ(ğ‘‰(ğ‘‹âˆªğ‘Œ))â‰¥ğ‘˜, it holds that X\cup Y\in {{\mathcal {C}}}ğ‘‹âˆªğ‘Œâˆˆîˆ¯. Therefore {{\mathcal {C}}}îˆ¯ is confluent. \square â—»

Construction of Monotone Meta-Weight Functions
This part shows a concrete method of constructing a monotone meta-weight function from a mixed graph with a standard weight function on the vertex and edge sets. We also present how to construct oracles L_11 and L_22 that are required when we apply the enumeration algorithm in Sect. 4.5 to the corresponding confluent system.

Let M be a mixed graph and w:V(M)\cup E(M)\rightarrow {\mathbb {R}}_+ğ‘¤:ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€)â†’â„+ be a weight function. We define a coefficient function to be \gamma =(\alpha ,\overline{\alpha },\alpha ^+,\alpha ^-,\beta )ğ›¾=(ğ›¼,ğ›¼â¯â¯â¯,ğ›¼+,ğ›¼âˆ’,ğ›½) that consists of functions

\alpha : E(M)\rightarrow {\mathbb {R}}_+ğ›¼:ğ¸(ğ‘€)â†’â„+,

\overline{\alpha } : {\overline{E}}(M)\rightarrow {\mathbb {R}}_+ğ›¼â¯â¯â¯:ğ¸â¯â¯â¯â¯(ğ‘€)â†’â„+,

\alpha ^+,\alpha ^- : \mathbf {E}(M)\rightarrow {\mathbb {R}}_+ğ›¼+,ğ›¼âˆ’:ğ„(ğ‘€)â†’â„+, and

\beta : V(M)\cup E(M) \rightarrow {\mathbb {R}}_+ğ›½:ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€)â†’â„+.

We call \gamma ğ›¾ monotone if

1\ge \alpha (e)\ge \overline{\alpha }(e)\ge \beta (e)1â‰¥ğ›¼(ğ‘’)â‰¥ğ›¼â¯â¯â¯(ğ‘’)â‰¥ğ›½(ğ‘’) for each undirected edge e\in {\overline{E}}(M)ğ‘’âˆˆğ¸â¯â¯â¯â¯(ğ‘€),

1\ge \alpha (e)\ge \alpha ^+(e)\ge \beta (e)1â‰¥ğ›¼(ğ‘’)â‰¥ğ›¼+(ğ‘’)â‰¥ğ›½(ğ‘’) for each directed edge e\in \mathbf {E}(M)ğ‘’âˆˆğ„(ğ‘€);

1\ge \alpha (e)\ge \alpha ^-(e)\ge \beta (e)1â‰¥ğ›¼(ğ‘’)â‰¥ğ›¼âˆ’(ğ‘’)â‰¥ğ›½(ğ‘’) for each directed edge e\in \mathbf {E}(M)ğ‘’âˆˆğ„(ğ‘€); and

1\ge \beta (v)1â‰¥ğ›½(ğ‘£) for each vertex v\in V(M)ğ‘£âˆˆğ‘‰(ğ‘€).

We call a tuple (M,w,\gamma )(ğ‘€,ğ‘¤,ğ›¾) a system, and define a meta-weight function

\begin{aligned} \omega : 2^{V(M)\cup E(M)}\times (V(M)\cup E(M))\rightarrow {\mathbb {R}}_+ \end{aligned}

ğœ”:2ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€)Ã—(ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€))â†’â„+

to the system so that, for each subset X\subseteq V(M)\cup E(M)ğ‘‹âŠ†ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€), \omega _X:V(M)\cup E(M) \rightarrow {\mathbb {R}}_+ğœ”ğ‘‹:ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€)â†’â„+ is given by

\begin{aligned} \omega _X(v)= \left\{ \begin{array}{ll} w(v) &{}{}\quad \text { if }\ v\in V(X), \\ \beta (v)w(v) &{}{}\quad \text { if }\ v\in V(M){\setminus } V(X), \end{array} \right. \\ \omega _X(e)= \left\{ \begin{array}{ll} w(e) &{}{}\quad \text { if }\ e \in E(M)\cap X, \\ \alpha (e)w(e) &{}{}\quad \text { if }\ e \in E(V(X),V(X)){\setminus } X, \\ \overline{\alpha }(e)w(e) &{}{}\quad \text { if }\ e\in {\overline{E}}(V(X),V(M){\setminus } V(X)), \\ \alpha ^+(e)w(e) &{}{}\quad \text { if }\ e\in \mathbf {E}(V(X),V(M){\setminus } V(X)),\\ \alpha ^-(e)w(e) &{}{}\quad \text { if }\ e\in \mathbf {E}(V(M){\setminus } V(X), V(X)), \\ \beta (e)w(e) &{}{}\quad \text { if }\ e \in E(V{\setminus } V(X),V{\setminus } V(X)). \end{array} \right. \end{aligned}

ğœ”ğ‘‹(ğ‘£)={ğ‘¤(ğ‘£)ğ›½(ğ‘£)ğ‘¤(ğ‘£) if  ğ‘£âˆˆğ‘‰(ğ‘‹), if  ğ‘£âˆˆğ‘‰(ğ‘€)âˆ–ğ‘‰(ğ‘‹),ğœ”ğ‘‹(ğ‘’)=â§â©â¨âªâªâªâªâªâªğ‘¤(ğ‘’)ğ›¼(ğ‘’)ğ‘¤(ğ‘’)ğ›¼â¯â¯â¯(ğ‘’)ğ‘¤(ğ‘’)ğ›¼+(ğ‘’)ğ‘¤(ğ‘’)ğ›¼âˆ’(ğ‘’)ğ‘¤(ğ‘’)ğ›½(ğ‘’)ğ‘¤(ğ‘’) if  ğ‘’âˆˆğ¸(ğ‘€)âˆ©ğ‘‹, if  ğ‘’âˆˆğ¸(ğ‘‰(ğ‘‹),ğ‘‰(ğ‘‹))âˆ–ğ‘‹, if  ğ‘’âˆˆğ¸â¯â¯â¯â¯(ğ‘‰(ğ‘‹),ğ‘‰(ğ‘€)âˆ–ğ‘‰(ğ‘‹)), if  ğ‘’âˆˆğ„(ğ‘‰(ğ‘‹),ğ‘‰(ğ‘€)âˆ–ğ‘‰(ğ‘‹)), if  ğ‘’âˆˆğ„(ğ‘‰(ğ‘€)âˆ–ğ‘‰(ğ‘‹),ğ‘‰(ğ‘‹)), if  ğ‘’âˆˆğ¸(ğ‘‰âˆ–ğ‘‰(ğ‘‹),ğ‘‰âˆ–ğ‘‰(ğ‘‹)).

We call a system (M,w,\gamma )(ğ‘€,ğ‘¤,ğ›¾) monotone if \gamma ğ›¾ is monotone.

Lemma 12
For a monotone system (M,w,\gamma )(ğ‘€,ğ‘¤,ğ›¾), the corresponding meta-weight function \omega : 2^{V(M)\cup E(M)}\times (V(M)\cup E(M))\rightarrow {\mathbb {R}}_+ğœ”:2ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€)Ã—(ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€))â†’â„+ is monotone.

Proof
Let X\subseteq Y\subseteq V(M)\cup E(M)ğ‘‹âŠ†ğ‘ŒâŠ†ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€), where V(X)\subseteq V(Y)ğ‘‰(ğ‘‹)âŠ†ğ‘‰(ğ‘Œ) holds. It suffices to show that \omega _Y(a)\ge \omega _X(a)ğœ”ğ‘Œ(ğ‘)â‰¥ğœ”ğ‘‹(ğ‘) for any element a\in V(M)\cup E(M)ğ‘âˆˆğ‘‰(ğ‘€)âˆªğ¸(ğ‘€). For each vertex v\in V(M)ğ‘£âˆˆğ‘‰(ğ‘€), we see that \omega _Y(v) =\omega _X(v)+|\{v\}\cap (V(Y){\setminus } V(X))|(1-\beta (v))w(v) \ge \omega _X(v)ğœ”ğ‘Œ(ğ‘£)=ğœ”ğ‘‹(ğ‘£)+|{ğ‘£}âˆ©(ğ‘‰(ğ‘Œ)âˆ–ğ‘‰(ğ‘‹))|(1âˆ’ğ›½(ğ‘£))ğ‘¤(ğ‘£)â‰¥ğœ”ğ‘‹(ğ‘£).

For each edge e\in E(M)ğ‘’âˆˆğ¸(ğ‘€) with end-vertices u and v, we see that (i) \omega _Y(e)=\omega _X(e)+(1-\alpha )|\{e\}\cap (Y{\setminus } X)|w(e)\ge \omega _X(e)ğœ”ğ‘Œ(ğ‘’)=ğœ”ğ‘‹(ğ‘’)+(1âˆ’ğ›¼)|{ğ‘’}âˆ©(ğ‘Œâˆ–ğ‘‹)|ğ‘¤(ğ‘’)â‰¥ğœ”ğ‘‹(ğ‘’) if u,v\in V(X)ğ‘¢,ğ‘£âˆˆğ‘‰(ğ‘‹); and (ii) \omega _Y(e)=\omega _X(e)+\Delta |\{u,v\}\cap (V(Y){\setminus } V(X))| w(e)\ge \omega _X(e)ğœ”ğ‘Œ(ğ‘’)=ğœ”ğ‘‹(ğ‘’)+Î”|{ğ‘¢,ğ‘£}âˆ©(ğ‘‰(ğ‘Œ)âˆ–ğ‘‰(ğ‘‹))|ğ‘¤(ğ‘’)â‰¥ğœ”ğ‘‹(ğ‘’) otherwise, where \Delta Î” is one of 1-\overline{\alpha }(e)1âˆ’ğ›¼â¯â¯â¯(ğ‘’), 1- \alpha ^+(e)1âˆ’ğ›¼+(ğ‘’), 1-\alpha ^-(e)1âˆ’ğ›¼âˆ’(ğ‘’), \alpha (e)-\overline{\alpha }(e)ğ›¼(ğ‘’)âˆ’ğ›¼â¯â¯â¯(ğ‘’), \alpha (e)- \alpha ^+(e)ğ›¼(ğ‘’)âˆ’ğ›¼+(ğ‘’), \alpha (e)-\alpha ^-(e)ğ›¼(ğ‘’)âˆ’ğ›¼âˆ’(ğ‘’), (\alpha (e)-\beta (e))/2(ğ›¼(ğ‘’)âˆ’ğ›½(ğ‘’))/2, \overline{\alpha }(e)-\beta (e)ğ›¼â¯â¯â¯(ğ‘’)âˆ’ğ›½(ğ‘’), \alpha ^+(e)-\beta (e)ğ›¼+(ğ‘’)âˆ’ğ›½(ğ‘’), \alpha ^-(e)-\beta (e)ğ›¼âˆ’(ğ‘’)âˆ’ğ›½(ğ‘’) and (1-\beta (e))/2(1âˆ’ğ›½(ğ‘’))/2. \square â—»

For a system (M,w,\gamma )(ğ‘€,ğ‘¤,ğ›¾) on a mixed graph M with n vertices and m edges and a real k\ge 0ğ‘˜â‰¥0, let \mathrm {tm}(n,m,k)tm(ğ‘›,ğ‘š,ğ‘˜) and \mathrm {sp}(n,m,k)sp(ğ‘›,ğ‘š,ğ‘˜) respectively denote the time and space complexities for testing if \mu (u,v;X)<kğœ‡(ğ‘¢,ğ‘£;ğ‘‹)<ğ‘˜ holds or not for two vertices u,v\in V(M)ğ‘¢,ğ‘£âˆˆğ‘‰(ğ‘€) and a subset X\subseteq V(M)\cup E(M)ğ‘‹âŠ†ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€).

Lemma 13
For a monotone system (M,w,\gamma )(ğ‘€,ğ‘¤,ğ›¾), let \omega ğœ” be the corresponding monotone meta-weight function.

(i)
\mathrm {tm}(n,m,k)=O(mn\log n)tm(ğ‘›,ğ‘š,ğ‘˜)=ğ‘‚(ğ‘šğ‘›logğ‘›) and \mathrm {sp}(n,m,k)=O(n+m)sp(ğ‘›,ğ‘š,ğ‘˜)=ğ‘‚(ğ‘›+ğ‘š); and

(ii)
Let X\subseteq Y\subseteq V(M)\cup E(M)ğ‘‹âŠ†ğ‘ŒâŠ†ğ‘‰(ğ‘€)âˆªğ¸(ğ‘€) be non-empty subsets such that \omega _X(V(X))\ge kğœ”ğ‘‹(ğ‘‰(ğ‘‹))â‰¥ğ‘˜ and \mu (u,u';Y)\ge kğœ‡(ğ‘¢,ğ‘¢â€²;ğ‘Œ)â‰¥ğ‘˜ for all vertices u,u'\in V(X)ğ‘¢,ğ‘¢â€²âˆˆğ‘‰(ğ‘‹). Given a vertex t\in V(Y){\setminus } V(X)ğ‘¡âˆˆğ‘‰(ğ‘Œ)âˆ–ğ‘‰(ğ‘‹), whether there is a vertex u\in V(X)ğ‘¢âˆˆğ‘‰(ğ‘‹) such that \mu (u,t;Y)<kğœ‡(ğ‘¢,ğ‘¡;ğ‘Œ)<ğ‘˜ or not can be tested in \mathrm {tm}(n,m,k)tm(ğ‘›,ğ‘š,ğ‘˜) time and \mathrm {sp}(n,m,k)sp(ğ‘›,ğ‘š,ğ‘˜) space.

Proof
(i) The problem of computing \mu (s,t;X)ğœ‡(ğ‘ ,ğ‘¡;ğ‘‹) can be formulated as a problem of finding a maximum flow in a weighted graph (M,\omega _X)(ğ‘€,ğœ”ğ‘‹) with an edge-capacity \omega _X(e)ğœ”ğ‘‹(ğ‘’), e\in E(M)ğ‘’âˆˆğ¸(ğ‘€) and a vertex-capacity \omega _X(v)ğœ”ğ‘‹(ğ‘£), v\in V(M), and \mu (s,t;X) can be computed in O(mn\log n) time and O(n+m) space by using the maximum flow algorithm [2, 3]. Hence \mathrm {tm}(n,m,k)=O(mn\log n) and \mathrm {sp}(n,m,k)=O(n+m).

(ii) Let t\in V(Y){\setminus } V(X). To find a vertex u\in V(X) with \mu (u,t;Y)<k if any by using (i) only once, we augment the weighted graph (M,\omega _Y) into another weighted graph (M^*,\omega _Y) with a new vertex s^* and |V(X)| new directed edges e_u=(s^*,u), u\in V(X) such that \omega _Y(e_u):=k. We claim that \mu (u,t;Y)\ge k for all vertices u\in V(X) in (M,\omega _Y) if and only if \mu (s^*,t;Y)\ge k in (M^*,\omega _Y).

First consider the case of \mu (s^*,t;Y)< k in (M^*, \omega _Y); i.e., the graph (M^*,\omega _Y) has an s^*,t-cut C^*=(S,T) with \omega _Y(\varepsilon (C^*))<k, where s^*\in S and t\in T. Let R=V(M^*){\setminus } (S\cup T), where R=V(M){\setminus } (S\cup T). Note that X\subseteq S\cup R, since otherwise u\in T\cap V(X) would mean that e_u=(s^*,u)\in E(S,T) and \omega _Y(\varepsilon (C^*))\ge \omega _Y(e_u)= k, contradicting that \omega _Y(\varepsilon (C^*))<k. Also S\cap V(X)\ne \emptyset , since otherwise V(X)\subseteq R would mean that \omega _Y(\varepsilon (C^*))\ge \omega _Y(R) \ge \omega _X(V(X))\ge k, contradicting that \omega _Y(\varepsilon (C^*))<k. Let u\in S\cap V(X). Then C=(S{\setminus }\{s^*\},T) is a u, t-cut in (M,\omega _Y) with \omega _Y(\varepsilon (C))\le \omega _Y(\varepsilon (C^*))<k. This means that \mu (u,t;Y)<k.

Next consider the case of \mu (s^*,t;Y)\ge k in (M^*, \omega _Y). In this case, we show that \mu (u,t;Y)\ge k for all vertices u\in V(X). To derive a contradiction, assume that \mu (u,t;Y)<k for some vertex u\in V(X); i.e., the graph (M, \omega _Y) has a u, t-cut C=(S,T) with \omega _Y(\varepsilon (C))<k. Note that T\cap V(X)=\emptyset , since otherwise u'\in T\cap V(X) would contradict the assumption that \mu (u,u';Y)\ge k holds for all vertices u,u'\in V(X).

Then C'=(S'=S\cup \{s^*\},T) is an s^*,t-cut in (M^*, \omega _Y), and satisfies \omega _Y(\varepsilon (C'))=\omega _Y(\varepsilon (C))<k since T\cap V(X)=\emptyset . This, however, contradicts that \mu (s^*,t;Y)\ge k holds in (M^*, \omega _Y).

By the claim, it suffices to test if \mu (s^*,t;Y)\ge k or not in \mathrm {tm}(n,m,k) time and \mathrm {sp}(n,m,k) space. \square

Construction of Oracles
We denote by {{\mathcal {C}}}(M,w,\gamma ,k) the family of k-connected sets X with \omega _X(V(X))\ge k in a system (M,w,\gamma ). By Lemmas 11 and 12, {{\mathcal {C}}}(M,w,\gamma ,k) is confluent. Let \Lambda \subseteq V(M)\cup E(M) be a subset. Let {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ) denote the family of components X\in {{\mathcal {C}}}(M,w,\gamma ,k) such that X\subseteq \Lambda , where we see that {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ) is also confluent.

We consider how to construct oracles \mathrm {L}_1 and \mathrm {L}_2 to the confluent system. For two non-empty subsets X\subseteq Y\subseteq \Lambda , let {{\mathcal {C}}}_{\mathrm{max}}(Y) denote the family of maximal subsets Z\in {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ) such that Z\subseteq Y, and let C_k(X;Y) denote a maximal set X^*\in {{\mathcal {C}}}_{\mathrm{max}}(Y) such that X\subseteq X^*; and C_k(X;Y)\triangleq \emptyset if no such set X^* exists.

Lemma 14
For a monotone system (M,w,\gamma ,\Lambda ), let \omega denote the corresponding monotone meta-weight function. Let X\subseteq Y\subseteq \Lambda be non-empty subsets such that \omega _X(V(X))\ge k. Then

(i)
X^*=C_k(X;Y) is uniquely determined;

(ii)
If there are vertices u\in V(X) and v\in V(Y) such that \mu (u,v;Y)<k, then v\not \in V(X^*);

(iii)
Assume that \mu (u,v;Y)\ge k for all vertices u\in V(X) and v\in V(Y){\setminus } V(X). Then C_k(X;Y)=Y if \mu (u,u';Y)\ge k for all vertices u,u'\in V(X); and C_k(X;Y)=\emptyset otherwise; and

(iv)
C_k(X;Y) can be found in O(|Y|^2 \mathrm {tm}(n,m,k)) time and O(\mathrm {sp}(n,m,k) +|Y|) space.

Proof
(i) To derive a contradiction, assume that there are two maximal sets X_1,X_2\in {{\mathcal {C}}}_{\mathrm{max}}(Y) such that X\subseteq X_1\cap X_2. From this and the monotonicity of \omega , it holds that \omega _{X_1\cup X_2}(V(X_1\cup X_2))\ge \omega _{X_1\cap X_2}(V(X_1\cap X_2)) \ge \omega _X(V(X))\ge k. From this and Lemma 10, X_1\cup X_2 is also k-connected and X_1\cup X_2\in {{\mathcal {C}}}_{\mathrm{max}}(Y), contradicting the maximality of X_1 and X_2. Therefore C_k(X;Y) is unique.

(ii) When C_k(X;Y)=\emptyset , v\not \in C_k(X;Y) is trivial. Assume that C_k(X;Y)=X^*\in {{\mathcal {C}}}_{\mathrm{max}}(Y). By the monotonicity of \omega and X^*\subseteq Y, it holds that \mu (u,v;X^*)\le \mu (u,v;Y) <k. Hence u,v\in V(X^*) would contradict the k-connectivity of X^*. Since u\in V(X^*), we have v\not \in V(X^*).

(iii) Obviously if \mu (u,u';Y)< k for some vertices u,u'\in V(X), then no subset Y' of Y with X\subseteq Y' can be k-connected, and C_k(X;Y)=\emptyset . Assume that \mu (u,u';Y)\ge k for all vertices u,u'\in V(X). By the monotonicity of \omega and X\subseteq Y, it holds that \omega _{Y}(V(Y))\ge \omega _X(V(X))\ge k. To prove that C_k(X;Y)=Y, it suffices to show that \mu (u,v;Y)\ge k for all pairs of vertices u,v\in V(Y). By assumption, \mu (u,v;Y)\ge k for all vertices u\in V(X) and v\in V(Y). To derive a contradiction, assume that there is a pair of vertices s,t\in V(Y){\setminus } V(X) with \mu (s,t;Y)< k; i.e., there is an s, t-cut C=(S,T) with \omega _Y(\varepsilon (C))<k. Let R=V(M){\setminus } S\cup T.

We observe that V(X)\subseteq R, since u\in V(X)\cap S (resp., u\in V(X)\cap T) would imply that C is a u, t-cut (resp., s, u-cut), contradicting that \mu (u,v;Y)\ge k for all vertices v\in V(Y){\setminus } V(X). By the monotonicity of \omega and V(X)\subseteq R, it would hold that k\le \omega _X(V(X))\le \omega _Y(R)\le \omega _Y(\varepsilon (C))<k, a contradiction.

(iv) We can find C_k(X;Y) as follows. Based on (ii), we first remove the set Z_V of all vertices t\in V(M)\cap (Y{\setminus } X) such that \mu (u,t;Y)<k for some vertex u\in V(X) and the set Z_E of all edges e\in E(M)\cap (Y{\setminus } X) such that \mu (u,t;Y)<k for some vertices u\in V(X) and t\in V(\{e\}) so that C_k(X;Y)=C_k(X;Y') holds for Y'=Y{\setminus } (Z_V\cup Z_E). For a fixed vertex t\in V(M)\cap (Y{\setminus } X) or t\in V(\{e\}) with an edge e\in E(M)\cap (Y{\setminus } X), we can test if there is a vertex u\in X such that \mu (u,t;Y)<k or not in O(\mathrm {tm}(n,m,k)) time and O(\mathrm {sp}(n,m,k)) space by Lemma 13(ii). Hence finding such a set Z_V\cup Z_E takes O(|Y{\setminus } X|\mathrm {tm}(n,m,k)) time and O(\mathrm {sp}(n,m,k)+|Z_V\cup Z_E|) space. We repeat the above procedure until there is no pair of vertices u\in V(X) and v\in V(Y'){\setminus } V(X) after executing at most |Y{\setminus } X| repetitions taking O(|Y{\setminus } X|^2\mathrm {tm}(n,m,k)) time and O(\mathrm {sp}(n,m,k)+|Y{\setminus } X|) space.

figure e
Based on (iii), we finally conclude that C_k(X;Y)=Y' (C_k(X;Y)=\emptyset ) if there is not pair of vertices u,u'\in V(X) such that \mu (u,u';Y')<k (resp., otherwise), which takes O(|X|^2\mathrm {tm}(n,m,k)) time and O(\mathrm {sp}(n,m,k)) space by Lemma 13(i). An entire algorithm is described in Algorithm 5. The time and space complexities are then O(|Y|^2\mathrm {tm}(n,m,k)) time and O(\mathrm {sp}(n,m,k) +|Y|), respectively. \square

By the lemma, oracle \mathrm {L}_1(X;Y) to a monotone system (M,w,\gamma ) runs in \theta _{\mathrm {1,t}}=O(|Y|^2\mathrm {tm}(n,m,k)) time and \theta _{\mathrm {1,s}}=O(\mathrm {sp}(n,m,k) +|Y|) space.

For a system (M,w,\gamma ,\Lambda ), we define a k-core of a subset Y\subseteq \Lambda to be a subset Z of Y such that \omega _Z(V(Z))\ge k and any proper subset Z' of Z satisfies \omega _{Z'}(V(Z'))< k.

Lemma 15
Let (M,w,\gamma ,\Lambda ) be a monotone system, and Y be a subset of \Lambda . For the family \mathcal {K} of all k-cores of Y, it holds that {{\mathcal {C}}}_{\mathrm{max}}(Y)= \bigcup _{Z\in \mathcal {K}} \{C_k(Z;Y)\} and |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |\mathcal {K}|. Given \mathcal {K}, {{\mathcal {C}}}_{\mathrm{max}}(Y) can be obtained in O(|\mathcal {K}|( |Y|^2 \mathrm {tm}(n,m,k)+|Y|\log |\mathcal {K}|)) time and O(\mathrm {sp}(n,m,k)+|\mathcal {K}|\cdot |Y|) space.

Proof
Clearly each set X\in {{\mathcal {C}}}_{\mathrm{max}}(Y) satisfies \omega _X(V(X))\ge k and contains a k-core Z\in \mathcal {K}, where C_k(Z;Y)\ne \emptyset and C_k(Z;Y)=X holds by the uniqueness in Lemma 14(i). Therefore {{\mathcal {C}}}_{\mathrm{max}}(Y)=\bigcup _{Z\in \mathcal {K}} \{C_k(Z;Y)\}, from which |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |\mathcal {K}| follows. Given \mathcal {K}, we compute C_k(Z;Y) for each set Z\in \mathcal {K} taking O(|Y|^2 \mathrm {tm}(n,m,k)) time and O(\mathrm {sp}(n,m,k)+|Y|) space by Lemma 14(iv). We can test if the same set X\in {{\mathcal {C}}}_{\mathrm{max}}(Y) has been generated or not in O(|Y|\log |\mathcal {K}|) time and O(|\mathcal {K}|\cdot |Y|) space. Therefore \mathcal {X} can be constructed in O(|\mathcal {K}|( |Y|^2 \mathrm {tm}(n,m,k)+|Y|\log |\mathcal {K}|)) time and O(\mathrm {sp}(n,m,k)+|\mathcal {K}|\cdot |Y|) space. \square

By the lemma, oracle \mathrm {L}_2(Y) to a monotone system (M,w,\gamma ,\Lambda ) runs in \theta _{\mathrm {2,t}}=O(|\mathcal {K}|( |Y|^2 \mathrm {tm}(n,m,k) +|Y|\log |\mathcal {K}|)) time and \theta _{\mathrm {2,s}}=O(\mathrm {sp}(n,m,k)+|\mathcal {K}|\cdot |Y|) space, where we assume that the family \mathcal {K} of k-cores of Y is given as input.

Connector Enumeration Problem
Recall the connector enumeration problem that we introduced in Sect. 2.1. The problem can be treated as the case where G is an undirected graph and {{\mathcal {C}}} is the family of all vertex subsets that induce connected subgraphs.

Formulation by Confluent System
Let us consider formulating the connector enumeration problem by means of a confluent system. For a given instance (G,I,\sigma ) of the connector enumeration problem, let {{\mathcal {C}}}_G denote the family of all vertex subsets X such that the induced subgraph G[X] is connected, where we regard G[X] with |X|=1 (resp., X=\emptyset ) as connected (resp., disconnected). We see that (V(G),{{\mathcal {C}}}_G) is a confluent system since, for any X,Y\in {{\mathcal {C}}}_G, G[X\cup Y] is connected whenever there is a subset S\subseteq X\cap Y such that S\in {{\mathcal {C}}}_G.

Let n=|V(G)| and m=|E(G)|. We can implement the oracles L_1 and L_2 so that they run in O(n+m) time and space (i.e., \theta _{i,\mathrm {t}}=O(n+m), i=1,2, and \theta _{i,\mathrm {s}}=O(n+m), i=1,2) since they are realized by conventional graph search (e.g., DFS or BFS). We can take the upper bound \delta (Y)=|Y|, which exactly satisfies our assumption that \delta (X)\le \delta (Y) holds for subsets X\subseteq Y\subseteq V.

For any X\subseteq V, the followings are equivalent:

X is a connector for (G,I,\sigma ); and

X is a solution for the instance (V(G),{{\mathcal {C}}}_G,I,\sigma ).

In Fig. 4, we show the Hasse diagram of the confluent system (V(G),{{\mathcal {C}}}_G) for the instance (G,I,\sigma ) in Fig. 1, along with the solutions for (V(G),{{\mathcal {C}}}_G,I,\sigma ).

Fig. 4
figure 4
Hasse diagram of the confluent system (V,{{\mathcal {C}}}_G) of the instance (V(G),{{\mathcal {C}}}_G,I,\sigma ) from Fig. 1, where common item sets are indicated by integers and solutions are indicated by shade

Full size image

Theorem 2
Given an instance (G,I,\sigma ) of the connector enumeration problem in a graph G, all connectors can be enumerated in O(q^2(n+m)n) delay and O((q+n+m)n) space, where n=|V(G)|, m=|E(G)| and q=|I|.

Proof
The connector enumeration problem for (G,I,\sigma ) is solved by enumerating all solutions for the instance (V(G),{{\mathcal {C}}}_G,I,\sigma ). For the confluent system (V(G),{{\mathcal {C}}}_G), we see that \theta _{i,\mathrm {t}}=O(n+m), i=1,2, \theta _{i,\mathrm {s}}=O(n+m), i=1,2, and \delta (Y)=O(|Y|)=O(n). By Theorem 1, we can enumerate all solutions in {{\mathcal {S}}} in O(q^2(n+m)n) delay and in O((q+n+m)n) space. \square

Enumerating Connectors Under Various Connectivity Conditions
In addition to the system (V(G),{{\mathcal {C}}}_G), we may obtain an alternative confluent system by selecting a different notion of connectivity such as the edge- or vertex-connectivity on a digraph or an undirected graph. This section presents two examples of confluent systems based on high graph connectivity using the result in Sect. 5.

Edge- and Vertex-Connectivity in Mixed Graph
Let G be a mixed graph with n vertices and m edges. We define a path from a vertex u to a vertex v (or a u, v-path) in G to be a subgraph P of G such that V(P)=\{v_1~(=u),v_2,\ldots ,v_p~(=v)\}, E(P)=\{e_1,e_2,\ldots ,e_{p-1}\} and e_i=v_iv_{i+1}\in {\overline{E}}(P) or e_i=(v_i,v_{i+1})\in \mathbf {E}(P). Let s,t\in V(G) be two vertices in G. Let \lambda (s,t;G) denote the minimum size |F| of a subset F\subseteq E(G) so that the graph G-F obtained from G by removing edges in F has no s, t-path. Let \kappa (s,t;G) denote the minimum size |S| of a subset S\subseteq E(G)\cup (V(G){\setminus }\{s,t\}) to be removed from G so that the graph G-S obtained from G by removing vertices and edges in S has no s, t-path, where such a minimum subset S can be chosen so that S{\setminus } E(s,t)\subseteq V(G). By Mengerâ€™s theorem [23], \lambda (s,t;G) (resp., \kappa (s,t;G)) is equal to the maximum number of edge-disjoint (resp., internally disjoint) s, t-paths. We can test whether \lambda (s,t;G)\ge k (resp., \kappa (s,t;G)\ge k) or not in O(\min \{k,n\}m) (resp., O(\min \{k,n^{1/2}\}m)) time [2, 3]. A graph G is called k-edge-connected if |V(G)|\ge 1 and \lambda (u,v;G)\ge k for any two vertices u,v\in V(G). A graph G is called k-vertex-connected if |V(G)|\ge k+1 and \kappa (u,v;G)\ge k for any two vertices u,v\in V(G). In the following, we show two examples of confluent systems based on graph connectivity.

Vertex Subsets Highly-Connected Over the Entire Graph
Given a mixed graph G, we define â€œk-connected setâ€ based on the connectivity of the entire graph G. Let us call a subset X\subseteq V(G) k-edge-connected if |X|=1 or for any two vertices u,v\in X, \lambda (u,v;G)\ge k. Let {{\mathcal {C}}}_{k,\mathrm {edge}} denote the family of k-edge-connected sets in G. Let us call a subset X\subseteq V(G) k-vertex-connected if |X|\ge k+1 and, for any two vertices u,v\in X, \kappa (u,v;G)\ge k. Let {{\mathcal {C}}}_{k,\mathrm {vertex}} denote the family of k-vertex-connected sets in G.

Lemma 16
Let G be a mixed graph and k\ge 0 be an integer, where n=|V(G)| and m=|E(G)|.

(i)
The family {{\mathcal {C}}}={{\mathcal {C}}}_{k,\mathrm {edge}} is confluent. For any non-empty subsets X\subseteq Y\subseteq V(G), it holds |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |Y|, and oracles \mathrm {L}_1(X;Y) and \mathrm {L}_2(Y) can be implemented so that they run in O(n^2) time and space after an O(n^2\min \{k,n\}m)-time and O(n^2)-space preprocessing; and

(ii)
The family {{\mathcal {C}}}={{\mathcal {C}}}_{k,\mathrm {vertex}} is confluent. For any non-empty subsets X\subseteq Y\subseteq V(G), it holds |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le {{|Y|}\atopwithdelims (){k}}, oracle \mathrm {L}_1(X;Y) can be implemented so that it runs in O(n^2) time and O(n^2) space, and oracle \mathrm {L}_2(Y) can be implemented so that it runs in O(|Y|^{k}n^2) time and O(|Y|^{k}n) space, after an O(n^2\min \{k,n^{1/2}\}m)-time and O(n^2)-space preprocessing.

Proof
Let (M,w,\gamma ,k,\Lambda ) be a system such that a mixed graph M:=G, \Lambda :=V(G), and a weight function w and a coefficient function \gamma =(\alpha ,\overline{\alpha },\alpha ^+,\alpha ^-,\beta ) such that \alpha (e):=\overline{\alpha }(e):=\alpha ^+(e):=\alpha ^-(e):=1 for each edge e\in E(G), and \beta (a):=1 for each element a\in V(G)\cup E(G), where we see that \gamma is monotone and the family {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ) is confluent by Sects. 11 and 12.

(i) We set weight w so that w(e):=1 for each edge e\in E(G) and w(v):=k for each vertex v\in V(G). We claim that {{\mathcal {C}}}_{k,\mathrm {edge}} is equal to {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), where the latter is the family of non-empty subsets X\subseteq \Lambda with \omega _X(V(X))\ge k such that |V(X)|=1 or \mu (u,v;X)\ge k for each pair of vertices u,v\in V(X). Note that \omega _X(V(X))\ge w(V(X))=k|X| for any non-empty set X\subseteq \Lambda . Then every set X\subseteq V(G) with |X|=1 belongs to both {{\mathcal {C}}}_{k,\mathrm {edge}} and {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ).

Let X be a subset of V(G) with |V(X)|=|X|\ge 2. By definition of coefficient function \gamma and weight w in G, we see that \mu (u,v;X)=\lambda (u,v;G) holds for any two vertices u,v\in V(X). This means that {{\mathcal {C}}}_{k,\mathrm {edge}}={{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), proving the claim.

We define the auxiliary graph G_{k,\mathrm {edge}}^* to be an undirected graph such that

V(G_{k,\mathrm {edge}}^*)=V(G), and

E(G_{k,\mathrm {edge}}^*) =\{uv\mid u,v\in V(G) \text{ with } \lambda (u,v;G)\ge k{ and}\lambda (v,u;G)\ge k \}.

We can construct G_{k,\mathrm {edge}}^* in O(n^2\min \{k,n\}m) time and O(n^2) space. Observe that a non-empty subset X\subseteq V(G) belongs to {{\mathcal {C}}}_{k,\mathrm {edge}} if and only if w(X)\ge k and X forms a clique in G_{k,\mathrm {edge}}^*. For edge-connectivity, we easily see that \lambda (x,y;G), \lambda (y,x;G), \lambda (y,z;G), \lambda (z,y;G)\ge k imply \lambda (x,z;G), \lambda (z,x;G)\ge k. Hence G_{k,\mathrm {edge}}^* is a disjoint union of cliques, and for {{\mathcal {C}}}={{\mathcal {C}}}_{k,\mathrm {edge}}, the family {{\mathcal {C}}}_{\mathrm{max}}(Y) is also a disjoint union of cliques in the induced subgraph G_{k,\mathrm {edge}}^*[Y]. This means that |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |Y| holds and {{\mathcal {C}}}_{\mathrm{max}}(Y) is found in O(n^2) time as the set of connected components in G_{k,\mathrm {edge}}^*.

For {{\mathcal {C}}}={{\mathcal {C}}}_{k,\mathrm {edge}}, \mathrm {L}_1(X;Y) and \mathrm {L}_2(Y) run in O(n^2) time and space after an O(n^2\min \{k,n\}m)-time and O(n^2)-space preprocessing.

(ii) We set weight w so that w(e):=1 for each edge e\in E(G) and w(v):=1 for each vertex v\in V(G). We claim that {{\mathcal {C}}}_{k,\mathrm {vertex}} is equal to {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ). Note that \omega _X(V(X))= w(V(X))=|X| for any non-empty set X\subseteq \Lambda . Let X be a subset of V(G) with |V(X)|=|X|<k. Then X is not k-vertex-connected in G and X is not k-connected in the system (M,w,\gamma ,k,\Lambda ).

Let X be a subset of V(G) with |V(X)|=|X|\ge k. By definition of coefficient function \gamma and weight w in G, we see that \mu (u,v;X)=\kappa (u,v;G) holds for any two vertices u,v\in V(X). This means that {{\mathcal {C}}}_{k,\mathrm {vertex}}={{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), proving the claim.

We define the auxiliary graph G_{k,\mathrm {vertex}}^* to be an undirected graph such that

V(G_{k,\mathrm {vertex}}^*)=V(G), and

E(G_{k,\mathrm {vertex}}^*) =\{uv\mid u,v\in V(G) \text{ with } \kappa (u,v;G)\ge k{ and}\kappa (v,u;G)\ge k \}.

We can construct G_{k,\mathrm {vertex}}^* in O(n^2\min \{k,n^{1/2}\}m) time and O(n^2) space. Observe that a non-empty subset X\subseteq V(G) belongs to {{\mathcal {C}}}_{k,\mathrm {vertex}} if and only if w(X)\ge k and X forms a clique in G_{k,\mathrm {vertex}}^*.

Let {{\mathcal {C}}}={{\mathcal {C}}}_{k,\mathrm {vertex}}. For subsets X\subseteq Y\subseteq V(G) such that |X|\ge k, a maximal set Z \in {{\mathcal {C}}}_{\mathrm{max}}(Y) with X\subseteq Z is the unique set C_k(X;Y) by Lemma 14. Hence C_k(X;Y) can be found in O(n^2) time and space by constructing the unique maximal clique containing X in the induced subgraph G_{k,\mathrm {vertex}}^*[Y]. Let \mathcal {K} be the family of k-cores; i.e., subsets of exactly k vertices in Y, which can be constructed in O(|Y|^k) time.

By Lemma 15, |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |\mathcal {K}|={{|Y|}\atopwithdelims (){k}} holds, and we can construct {{\mathcal {C}}}_{\mathrm{max}}(Y) by computing C_k(Z;Y) for all sets Z\in \mathcal {K}, taking O(|Y|^{k}n^2) time and O(|Y|^{k}n) space.

\square

Using Theorem 1 and Lemma 16, we have the following theorem on the time delay and the space complexity of enumeration of connectors that are k-edge-connected or k-vertex-connected.

Theorem 3
Let (G,I,\sigma ) be an instance on a mixed graph G and k\ge 0 be an integer, where n=|V(G)|, m=|E(G)|, and q=|I|.

(i)
All k-edge-connected connectors can be enumerated in O(q^2n^3) delay and O(qn+n^3) space, after an O(n^2\min \{k,n\}m)-time and O(n^2)-space preprocessing.

(ii)
All k-vertex-connected connectors can be enumerated in O(q^2n^{k+2}) delay and O(qn+n^{k+2}) space, after an O(n^2\min \{k,n^{1/2}\}m)-time and O(n^2)-space preprocessing.

Proof
Recall that, for Y\subseteq V, \delta (Y) denotes an upper bound on |{{\mathcal {C}}}_{\max }(Y)|. In both (i) and (ii), \theta _{\rho ,\mathrm {t}} and \theta _{\rho , \mathrm {s}} can be regarded as O(1) since the volume function is not used anywhere in this context.

(i) By Lemma 16(i), we have \theta _{1,\mathrm {t}}=\theta _{2,\mathrm {t}}=O(n^2) and \theta _{1,\mathrm {s}}=\theta _{2,\mathrm {s}}=O(n^2), and we can set \delta (Y)=n for any Y\subseteq V. By Theorem 1, we have the time delay O\big (q\theta _{2,\mathrm {t}} + (q(n+\theta _{1,\mathrm {t}})+\theta _{\rho ,\mathrm {t}})q \delta (V)\big ) =O(q^2n^3) and the space complexity O\big ((q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}} + \theta _{\rho ,\mathrm {s}}) n\big ) =O(qn+n^3).

(ii) By Lemma 16(ii), we have \theta _{1,\mathrm {t}}=O(n^2), \theta _{2,\mathrm {t}}=O(n^{k+2}), \theta _{1,\mathrm {s}}=O(n^2), and \theta _{2,\mathrm {s}}=O(n^{k+1}), and we can set \delta (Y)=n^k for any Y\subseteq V. By Theorem 1, we have the time delay O\big (q\theta _{2,\mathrm {t}} +(q(n+\theta _{1,\mathrm {t}})+\theta _{\rho ,\mathrm {t}})q \delta (V)\big ) =O(q^2n^{k+2}) and the space complexity O\big ((q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}} + \theta _{\rho ,\mathrm {s}}) n\big ) =O(qn+n^{k+2}).

For preprocessing, the time and space complexities are immediate from Lemma 16 both for (i) and (ii). \square

Highly-Connected Induced Subgraphs
Given a mixed graph G, we define a â€œk-connected setâ€ X based on the connectivity of the induced graph G[X]. Define {{\mathcal {C}}}_{k,\mathrm {edge}}^{\mathrm {in}} to be the family (resp., {{\mathcal {C}}}_{k,\mathrm {vertex}}^{\mathrm {in}}) of subsets X\subseteq V(G) such that the induced graph G[X] is k-edge-connected (resp., k-vertex-connected).

Lemma 17
Let G be a mixed graph and k\ge 0 be an integer, where n=|V(G)| and m=|E(G)|.

(i)
The family {{\mathcal {C}}}={{\mathcal {C}}}_{k,\mathrm {edge}}^{\mathrm {in}} is confluent. For any non-empty subsets X\subseteq Y\subseteq V(G), it holds |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |Y|, oracle \mathrm {L}_1(X;Y) can be implemented so that it runs in O(|Y|^2\min \{k\!+\!1,n\}m) time and O(n^2) space, and \mathrm {L}_2(Y) can be implemented so that it runs in O(|Y|^3\min \{k\!+\!1,n\}m) time and O(n^2) space.

(ii)
The family {{\mathcal {C}}}={{\mathcal {C}}}_{k,\mathrm {vertex}}^{\mathrm {in}} is confluent. For any non-empty subsets X\subseteq Y\subseteq V(G), it holds |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le {{|Y|}\atopwithdelims (){k}}, oracle \mathrm {L}_1(X;Y) can be implemented so that it runs in O(|Y|^2\min \{k\!+\!1,n^{1/2}\}m) time and O(n^2) space, and oracle \mathrm {L}_2(Y) can be implemented so that it runs in O(|Y|^{k+2}\min \{k\!+\!1,n^{1/2}\}m) time and O(|Y|^{k}n) space.

Proof
Let (M,w,\gamma ,k,\Lambda ) be a system such that a mixed graph M:=G, \Lambda :=V(G), a weight function w and a coefficient function \gamma =(\alpha ,\overline{\alpha },\alpha ^+,\alpha ^-,\beta ) such that \alpha (e):=1 and \overline{\alpha }(e):=\alpha ^+(e):=\alpha ^-(e):=0 for each edge e\in E(G), and \beta (a):=0 for each element a\in V(G)\cup E(G), where we see that \gamma is monotone and the family {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ) is confluent by Lemmas 11 and 12.

(i) We set weight w so that w(e):=1 for each edge e\in E(G) and w(v):=k for each vertex v\in V(G). We claim that {{\mathcal {C}}}_{k,\mathrm {edge}}^{\mathrm {in}} is equal to {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), where the latter is the family of non-empty subsets X\subseteq \Lambda with \omega _X(V(X))\ge k such that |V(X)|=1 or \mu (u,v;X)\ge k for each pair of vertices u,v\in V(X). Note that \omega _X(V(X))\ge w(V(X))=k|X| for any non-empty set X\subseteq \Lambda . Then every set X\subseteq V(G) with |X|=1 belongs to both {{\mathcal {C}}}_{k,\mathrm {edge}}^{\mathrm {in}} and {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ).

Let X be a subset of V(G) with |V(X)|=|X|\ge 2. By definition of coefficient function \gamma and weight w in G, we see that \mu (u,v;X)=\lambda (u,v;G[X]) holds for any two vertices u,v\in V(X). Hence G[X] is a k-edge-connected graph if and only if \mu (u,v;X)=\lambda (u,v;G[X])\ge k for any two vertices u,v\in V(X). This means that {{\mathcal {C}}}_{k,\mathrm {edge}}^{\mathrm {in}}={{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), proving the claim.

Whether \mu (s,t;X)\ge k (i.e., \lambda (s,t;G[X]),\lambda (t,s;G[X])\ge k) or not for a subset X\subseteq V(G) can be tested in O(\min \{k,n\}m) time [2, 3]. By Lemma 14(iv), \mathrm {L}_1(X;Y) runs in O(|Y|^2\min \{k\!+\!1,n\}m) time and O(n^2) space. The family \mathcal {K} of k-cores Z\subseteq Y is \{\{v\}\mid v\in Y\}. By Lemma 15, |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |\mathcal {K}|\le |Y| and \mathrm {L}_2(Y) runs in O(|Y|^3\min \{k\!+\!1,n\}m) time and O(n^2) space.

(ii) We set weight w so that w(e):=1 for each edge e\in E(G) and w(v):=1 for each vertex v\in V(G). We claim that {{\mathcal {C}}}_{k,\mathrm {vertex}}^{\mathrm {in}} is equal to {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ). Note that \omega _X(V(X))= w(V(X))=|X| for any non-empty set X\subseteq \Lambda . By definition of coefficient function \gamma and weight w in G, we see that \mu (u,v;X)=\kappa (u,v;G[X]) holds for any two vertices u,v\in X. In particular, if |X|\le k then \mu (u,v;X)=\kappa (u,v;G[X])<k. Let X be a subset of V(G) with |V(X)|=|X|\le k. Then G[X] is not a k-vertex-connected graph and X is not k-connected in the system (M,w,\gamma ,k,\Lambda ).

Let X be a subset of V(G) with |V(X)|=|X|\ge k+1. Then G[X] is a k-vertex-connected graph if and only if \mu (u,v;X)=\kappa (u,v;G[X])\ge k for any two vertices u,v\in V(X). This means that {{\mathcal {C}}}_{k,\mathrm {vertex}}^{\mathrm {in}}={{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), proving the claim.

Whether \mu (s,t;X)\ge k (i.e., \kappa (s,t;G[X]),\kappa (t,s;G[X])\ge k) or not for a subset X\subseteq V(G) can be tested in O(\min \{k,n^{1/2}\}m) time and O(n+m) space [2, 3]. By Lemma 14(iv), \mathrm {L}_1(X;Y) runs in O(|Y|^2\min \{k\!+\!1,n^{1/2}\}m) time and O(n^2) space. The family \mathcal {K} of k-cores Z\subseteq Y is {{Y}\atopwithdelims (){k}}. By Lemma 15, |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |\mathcal {K}|\le {{|Y|}\atopwithdelims (){k}} and \mathrm {L}_2(Y) runs in O(|Y|^{k+2}\min \{k\!+\!1,n^{1/2}\}m) time and O(|Y|^{k}n) space. \square

Again, using Theorem 1 and Lemma 17, we have the following theorem on the time delay and the space complexity of enumeration of connectors such that the induced subgraphs are k-edge-connected or k-vertex-connected.

Theorem 4
Let (G,I,\sigma ) be an instance on a mixed graph G and k\ge 0 be an integer, where n=|V|, m=|E|, and q=|I|.

(i)
All connectors that induce k-edge-connected subgraphs can be enumerated in O(\min \{k\!+\!1,n\}q^2n^3m) delay and O(qn+n^3) space.

(ii)
All connectors that induce k-vertex-connected subgraphs can be enumerated in O(\min \{k\!+\!1,n^{1/2}\}q^2n^{k+2}m) delay and O(qn+n^{k+2}) space.

Proof
In both (i) and (ii), \theta _{\rho ,\mathrm {t}} and \theta _{\rho , \mathrm {s}} can be regarded as O(1) since the volume function is not used anywhere in this context.

(i) By Lemma 17(i), we have \theta _{1,\mathrm {t}}=O(\min \{k\!+\!1,n\}n^2m), \theta _{2,\mathrm {t}}=O(\min \{k\!+\!1,n\}n^3m), and \theta _{1,\mathrm {s}}=\theta _{2,\mathrm {s}}=O(n^2), and we can set \delta (Y)=n for any Y\subseteq V. By Theorem 1, we have the time delay O\big (q\theta _{2,\mathrm {t}} + (q(n+\theta _{1,\mathrm {t}})+\theta _{\rho ,\mathrm {t}})q \delta (V)\big ) =O(\min \{k\!+\!1,n\}q^2n^3m) and the space complexity O\big ((q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}} + \theta _{\rho ,\mathrm {s}}) n\big ) =O(qn+n^3).

(ii) By Lemma 17(ii), we have \theta _{1,\mathrm {t}}=O(\min \{k\!+\!1,n^{1/2}\}n^2m), \theta _{2,\mathrm {t}}=O(\min \{k\!+\!1,n^{1/2}\}n^{k+2}m), \theta _{1,\mathrm {s}}=O(n^2), and \theta _{2,\mathrm {s}}=O(n^{k+1}), and we can set \delta (Y)=n^k for any Y\subseteq V. By Theorem 1, we have the time delay O\big (q\theta _{2,\mathrm {t}} + (q(n+\theta _{1,\mathrm {t}})+\theta _{\rho ,\mathrm {t}})q \delta (V)\big ) =O(\min \{k\!+\!1,n^{1/2}\}q^2n^{k+2}m) and the space complexity O\big ((q+n+\theta _{1,\mathrm {s}}+\theta _{2,\mathrm {s}} + \theta _{\rho ,\mathrm {s}}) n\big ) =O(qn+n^{k+2}). \square

Enumerating Connected Subgraphs
As we observed in Sect. 4.6, we can enumerate all components in a given confluent system (V,{{\mathcal {C}}}). This approach can be applied to enumeration of vertex subsets that induce subgraphs under various connectivity conditions.

Connected Induced Subgraphs (CISs)
For an undirected graph G, there are some studies on enumeration of CISs. In the seminal paper on reverse search [6], Avis and Fukuda showed that all CISs are enumerable in output-polynomial time and in polynomial space. It is immediate that their algorithm achieves O(n) delay, where n=|V(G)|. Uno [32] showed that all CISs are enumerable in O(1) time for each solution, using the analysis technique called Push Out Amortization. Alokshiya et al. [4] proposed a new linear delay algorithm and showed its empirical efficiency by experimental comparison with other algorithms.

The above mentioned previous algorithms are specialized to the task of enumerating all CISs. Our algorithm is so general that it is applicable to the task by taking the confluent system (V(G),{{\mathcal {C}}}_G). Recall that, for (V(G),{{\mathcal {C}}}_G), we can implement the oracles L_1 and L_2 so that \theta _{i,\mathrm {t}}=O(n+m), i=1,2, \theta _{i,\mathrm {s}}=O(n+m), i=1,2, and \theta _{\rho ,\mathrm {t}}=\theta _{\rho ,\mathrm {s}}=O(1). Corollary 1 implies that all components in (V(G),{{\mathcal {C}}}_G) can be enumerated in O(n^3(n+m)) delay and O(n(n+m)) space.

k-Edge- and k-Vertex-Connected Induced Subgraphs
For a mixed graph G, a subgraph G' with V(G')\subseteq V(G) and E(G')\subseteq E(G) is spanning if V(G')=V(G). There is some literature on enumeration of spanning subgraphs that are k-edge- or k-vertex-connected. Khachiyan et al. [20] showed that, when G is undirected, all minimal 2-vertex-connected spanning subgraphs are enumerable in incremental polynomial time. Boros et al. [9] extended the result so that all minimal k-vertex-connected spanning subgraphs can be enumerated in incremental polynomial time for a constant k.

Nutov [24] showed that, whether G is undirected or directed, minimal undirected Steiner networks, and minimal k-vertex-connected and k-outconnected spanning subgraphs are enumerable in incremental polynomial time. Recently, Yamanaka et al. [33] proposed a reverse search algorithm that enumerates all k-edge-connected spanning subgraphs of an undirected graph in polynomial delay for any k. Sano et al. [28] presented a polynomial-delay algorithm that enumerates all 2-edge-connected induced subgraphs of an undirected graph.

By Corollary 1 and Lemma 17, we can enumerate all vertex subsets that induce k-edge- and k-vertex-connected subgraphs in a given mixed graph G since they constitute components of the confluent systems (V(G),{{\mathcal {C}}}_{k,\mathrm {edge}}^{\mathrm {in}}) and (V(G),{{\mathcal {C}}}_{k,\mathrm {vertex}}^{\mathrm {in}}), respectively.

Theorem 5
Let G be a mixed graph and k\ge 0 be an integer, where n=|V(G)| and m=|E(G)|.

(i)
All vertex subsets that induce k-edge-connected subgraphs can be enumerated in O(\min \{k\!+\!1,n\}n^5m) delay and O(n^3) space.

(ii)
All vertex subsets that induce k-vertex-connected subgraphs can be enumerated in O(\min \{k\!+\!1,n^{1/2}\}n^{k+4}m) delay and O(n^{k+2}) space.

Subgraphs Induced by Edges
Let G be a mixed graph. For an edge subset F\subseteq E(G), let G[F] denote the subgraph H induced by F; i.e., V(H)=V(F) and E(H)=F. Define \mathcal {E}_{k,\mathrm {edge}}^{\mathrm {in}} to be the family (resp., \mathcal {E}_{k,\mathrm {vertex}}^{\mathrm {in}}) of subsets F\in E(G) such that the induced graph G[F] is k-edge-connected (resp., k-vertex-connected). Analogously with Lemma 17, we obtain the next result.

Lemma 18
Let G be a mixed graph with n vertices and m edges and k\ge 0 be an integer. Then:

(i)
The family {{\mathcal {C}}}=\mathcal {E}_{k,\mathrm {edge}}^{\mathrm {in}} is confluent. For any non-empty subsets X\subseteq Y\subseteq E(G), it holds |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |Y|, \mathrm {L}_1(X;Y) for a subset X\subseteq Y can be implemented so that it runs in O(|Y|^2\min \{k+1,n\}m) time and O(n^2) space, and \mathrm {L}_2(Y) can be implemented so that it runs in O(|Y|^3\min \{k+1,n\}m) time and O(n^2) space.

(ii)
The family {{\mathcal {C}}}=\mathcal {E}_{k,\mathrm {vertex}}^{\mathrm {in}} is confluent. For any non-empty subsets X\subseteq Y\subseteq E(G), it holds |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le {{|Y|}\atopwithdelims (){k}}, oracle \mathrm {L}_1(X;Y) can be implemented so that it runs in O(|Y|^2\min \{k+1,n^{1/2}\}m) time and O(n^2) space, and oracle \mathrm {L}_2(Y) can be implemented so that it runs in O(|Y|^{k+2}\min \{k+1,n^{1/2}\}m) time and O(|Y|^{k}n) space.

Proof
Let (M,w,\gamma ,k,\Lambda ) be a system such that a mixed graph M:=G, \Lambda :=E(G), a weight function w and a coefficient function \gamma =(\alpha ,\overline{\alpha },\alpha ^+,\alpha ^-,\beta ) such that \alpha (e):=\overline{\alpha }(e):=\alpha ^+(e):=\alpha ^-(e):=0 for each edge e\in E(G), and \beta (a):=0 for each element a\in V(G)\cup E(G), where we see that \gamma is monotone and the family {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ) is confluent by Lemmas 11 and 12.

(i) We set weight w so that w(e):=1 for each edge e\in E(G) and w(v):=k for each vertex v\in V(G). We claim that \mathcal {E}_{k,\mathrm {edge}}^{\mathrm {in}} is equal to {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), where the latter is the family of non-empty subsets X\subseteq \Lambda with \omega _X(V(X))\ge k such that |V(X)|=1 or \mu (u,v;X)\ge k for each pair of vertices u,v\in V(X). Note that |V(X)|\ge 2 and \omega _X(V(X))= w(V(X))=k|V(X)| for any non-empty set X\subseteq \Lambda =E(G).

Let X be a non-empty subset of E(G), where |V(X)|\ge 2 and \omega _X(V(X))\ge k. By definition of coefficient function \gamma and weight w in G, we see that \mu (u,v;X)=\lambda (u,v;G[X]) holds for any two vertices u,v\in V(X). Hence G[X] is a k-edge-connected graph if and only if \mu (u,v;X)=\lambda (u,v;G[X])\ge k for any two vertices u,v\in V(X). This means that \mathcal {E}_{k,\mathrm {edge}}^{\mathrm {in}} ={{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), proving the claim.

Whether \mu (s,t;X)\ge k (i.e., \lambda (s,t;G[X]),\lambda (t,s;G[X])\ge k) or not for a subset X\subseteq E(G) can be tested in O(\min \{k,n\}m) time [2, 3]. By Lemma 14(iv), \mathrm {L}_1(X;Y) runs in O(|Y|^2\min \{k+1,n\}m) time and O(n^2) space. The family \mathcal {K} of k-cores Z\subseteq Y is \{\{v\}\mid v\in Y\}. By Lemma 15, |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |\mathcal {K}|\le |Y| and \mathrm {L}_2(Y) runs in O(|Y|^3\min \{k+1,n\}m) time and O(n^2) space.

(ii) We set weight w so that w(e):=1 for each edge e\in E(G) and w(v):=1 for each vertex v\in V(G).

We claim that \mathcal {E}_{k,\mathrm {vertex}}^{\mathrm {in}} is equal to {{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ). Note that |V(X)|\ge 2 and \omega _X(V(X))= w(V(X))=|X| for any non-empty set X\subseteq \Lambda . By definition of coefficient function \gamma and weight w in G, we see that \mu (u,v;X)=\kappa (u,v;G[X]) holds for any two vertices u,v\in V(X). In particular, if |V(X)|\le k then \mu (u,v;X)=\kappa (u,v;G[X])<k. Let X be a subset of E(G) with |V(X)| \le k. Then G[X] is not a k-vertex-connected graph and X is not k-connected in the system (M,w,\gamma ,k,\Lambda ).

Let X be a subset of E(G) with |V(X)|\ge k+1. Then G[X] is a k-vertex-connected graph if and only if \mu (u,v;X)=\kappa (u,v;G[X])\ge k for any two vertices u,v\in V(X). This means that \mathcal {E}_{k,\mathrm {vertex}}^{\mathrm {in}} ={{\mathcal {C}}}(M,w,\gamma ,k,\Lambda ), proving the claim.

Whether \mu (s,t;X)\ge k (i.e., \kappa (s,t;G[X]),\kappa (t,s;G[X])\ge k) or not for a subset X\subseteq E(G) can be tested in O(\min \{k,n^{1/2}\}m) time and O(n+m) space [2, 3]. By Lemma 14(iv), \mathrm {L}_1(X;Y) runs in O(|Y|^2\min \{k+1,n^{1/2}\}m) time and O(n^2) space. The family \mathcal {K} of k-cores Z\subseteq Y is {{Y}\atopwithdelims (){k}}. By Lemma 15, |{{\mathcal {C}}}_{\mathrm{max}}(Y)|\le |\mathcal {K}|\le {{|Y|}\atopwithdelims (){k}} and \mathrm {L}_2(Y) runs in O(|Y|^{k+2}\min \{k+1,n^{1/2}\}m) time and O(|Y|^{k}n) space. \square

By Corollary 1 and Lemma 18, we can enumerate all edge subsets that induce k-edge- and k-vertex-connected subgraphs in a given mixed graph G since they constitute components of the confluent systems (E(G),\mathcal {E}_{k,\mathrm {edge}}^{\mathrm {in}}) and (E(G),\mathcal {E}_{k,\mathrm {vertex}}^{\mathrm {in}}), respectively.

Theorem 6
Let G be a mixed graph and k\ge 1 be an integer, where n=|V(G)| and m=|E(G)|.

(i)
All edge subsets that induce k-edge-connected subgraphs can be enumerated in O(\min \{k+1,n\}m^6) delay and O(mn^2) space.

(ii)
All edge subsets that induce k-vertex-connected subgraphs can be enumerated in O(\min \{k+1,n^{1/2}\}m^{k+5}) delay and O(m^{k+1}n) space.

Define a volume function \rho :V(G)\cup E(G)\rightarrow {\mathbb {R}} so that \rho (X):=|V(X)|- |V(G)|+1 for each subset X\subseteq V(G)\cup E(G). For a subset X\subseteq E(G), the graph G[X] is a spanning subgraph of G if and only if \rho (X)> 0. We see that \theta _{\rho ,\mathrm {t}}=\theta _{\rho ,\mathrm {s}}=O(n).

Similarly to Theorem 6, we can enumerate all edge subsets that induce k-edge- and k-vertex-connected spanning subgraphs in a given mixed graph G since they constitute \rho -positive components of the confluent systems (E(G),\mathcal {E}_{k,\mathrm {edge}}^{\mathrm {in}}) and (E(G),\mathcal {E}_{k,\mathrm {vertex}}^{\mathrm {in}}), respectively.

Theorem 7
Let G be a mixed graph and k\ge 1 be an integer, where n=|V(G)| and m=|E(G)|.

(i)
All edge subsets that induce k-edge-connected spanning subgraphs can be enumerated in O(\min \{k+1,n\}m^6) delay and O(mn^2) space.

(ii)
All edge subsets that induce k-vertex-connected spanning subgraphs can be enumerated in O(\min \{k+1,n^{1/2}\}m^{k+5}) delay and O(m^{k+1}n) space.

Concluding Remarks
The main contribution of the paper is Theorem 1. To prove the theorem, we have presented a family-tree based enumeration algorithm that achieves the required complexity in Sects. 4.1 and 4.5.

Once we define a confluent system (V,{{\mathcal {C}}}) such that \delta (X)\le \delta (Y) holds for any X\subseteq Y\subseteq V and design two oracles L_1 and L_2 for it, we can enumerate all solutions in an instance (V,{{\mathcal {C}}},I,\sigma ) for arbitrary I and \sigma in the stated computational complexity. In particular, if the time (resp., space) complexity of the two oracles is polynomially bounded, the algorithm achieves polynomial-delay (resp., polynomial space).

We presented some application results in Sects. 6 and 7. In Sect. 6, we obtained a polynomial-delay algorithm for the connector enumeration problem, even when a stronger connectivity condition is imposed on a connector (i.e., k-edge-connectivity for any k and k-vertex-connectivity for a fixed k). In Sect. 7, we showed that, for any k (resp., a fixed k), we can enumerate in polynomial delay all vertex/edge subsets that induce k-edge-connected (resp., k-vertex-connected) subgraphs and all edge subsets that induce k-edge-connected (resp., k-vertex-connected) spanning subgraphs. We summarize the computational complexity in Tables 4 and 5. We could improve complexity bounds for respective cases, which are left for future work.

Table 4 Complexity of enumerating connectors X that satisfy several connectivity requirements: conn. is an abbreviation of â€œconnectedâ€
Full size table

Table 5 Complexity of enumerating vertex subsets X or edge subsets F that satisfy several connectivity requirements: conn. is an abbreviation of â€œconnectedâ€
Full size table

Let us emphasize that, in Sects. 6 and 7, the input graph G can be undirected, directed or even mixed, and the vertex and/or edges can be weighted. We manipulate such G by means of a meta-weight function, and the details were discussed in Sect. 5.

Our next issue is to show the effectiveness of the family-tree based algorithm by solving real instances of enumeration problems concerning a confluent system. The connector enumeration problem has applications in biology, as mentioned in Sect. 6, and we are to pursuit further applications in such fields as chemistry. We have already developed an implementation of the algorithm for this problem. In [15], we observed its efficiency in comparison with previous algorithms, COOMA [13, 14] and COPINE [30].