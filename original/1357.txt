In the classic minimum makespan scheduling problem, we are given an input sequence of n jobs with sizes. A scheduling algorithm has to assign the jobs to m parallel machines. The objective is to minimize the makespan, which is the time it takes until all jobs are processed. In this paper, we consider online scheduling algorithms without preemption. However, we allow the online algorithm to change the assignment of up to k jobs at the end for some limited number k. For m identical machines, Albers and Hellwig (Algorithmica 79(2):598–623, 2017) give tight bounds on the competitive ratio in this model. The precise ratio depends on, and increases with, m. It lies between 4/3 and . They show that  is sufficient to achieve this bound and no  can result in a better bound. We study m uniform machines, i.e., machines with different speeds, and show that this setting is strictly harder. For sufficiently large m, there is a  such that, for m machines with only two different machine speeds, no online algorithm can achieve a competitive ratio of less than  with . We present a new algorithm for the uniform machine setting. Depending on the speeds of the machines, our scheduling algorithm achieves a competitive ratio that lies between 4/3 and  with . We also show that  is necessary to achieve a competitive ratio below 2. Our algorithm is based on maintaining a specific imbalance with respect to the completion times of the machines, complemented by a bicriteria approximation algorithm that minimizes the makespan and maximizes the average completion time for certain sets of machines.

Introduction
In the classic minimum makespan scheduling problem, we are given an input sequence of n jobs with sizes. A scheduling algorithm has to assign the jobs to m parallel machines. The objective is to minimize the makespan, which is the time it takes until all jobs are processed. This problem is NP-hard in the strong sense [20]. In this paper, we consider online scheduling without preemption.

An online algorithm does not have knowledge about the input sequence in advance. Instead, it gets to know the input sequence job by job without knowledge about the future. An online algorithm is called c-competitive if the makespan of the algorithm is at most c times the makespan of an optimal offline solution.

Extensive work has been done to narrow the gap between lower and upper bounds on the competitive ratio for online minimum makespan scheduling. Increasingly sophisticated algorithms and complex analyses were developed. Nevertheless, even for the most basic case of identical machines, in which each job has the same processing time, i.e., its size, on every machine, there is still a gap between the best known lower and upper bounds on the competitive ratio of 1.880 [30] and 1.9201 [18], respectively. In the setting with uniform machines, in which different machines may run at different speeds, the best known lower and upper bounds on the competitive ratio are 2.564 [13] and 5.828 [6], respectively.

In this work, we study to what extent the ability to migrate a limited number of jobs can help an online algorithm in terms of the competitive ratio in the uniform machine setting. In this model, the online algorithm has to assign jobs to machines as they arrive. However, after all jobs have arrived, the algorithm may remove up to k jobs from the machines and reassign them to different machines.

Job migration is a useful tool to balance loads and it is natural to study how many jobs need to be migrated to achieve certain load guarantees. Indeed, job migration in scheduling has been studied previously, see for example [8, 12, 27, 32,33,34], but in particular, Albers and Hellwig [2] studied this problem for m identical machinesFootnote 1 and gave tight bounds on the competitive ratio for this case. Roughly speaking,  job migrations are sufficient and necessary to achieve this tight bound. Allowing more job migrations does not result in further improvements as long as , where n denotes the total number of arriving jobs.

We provide related results for the more general setting of uniform machines, which introduces new technical challenges. Our contribution also implies new results on a different but related problem: online reordering for scheduling. In this model, a so-called reordering buffer can be used to reorder the input sequence of jobs in a restricted fashion. Arriving jobs are first stored in the reordering buffer which has capacity to store up to k jobs. When the buffer is full, the online scheduling algorithm has to decide which of the jobs to remove from the buffer and to assign (irrevocably) to a machine. When no more jobs arrive, all jobs remaining in the buffer have to be assigned to machines as well.

This model was introduced by Englert et al. [14] and the work by Albers and Hellwig [2] generalizes their results for identical machines to the setting were no buffer is used, but a limited number of job migrations are permitted. It is not known what the relationship between the two models is in general. However, Albers and Hellwig note that any online algorithm for the job migration model that satisfies a certain monotonicity property can be transformed into an online algorithm for the corresponding reordering buffer problem which has the same competitive ratio. If the algorithm migrates k jobs, the transformed algorithm requires a buffer of size k. The aforementioned monotonicity property is as follows: if the algorithm would not migrate a job at time t if we pretend that the input sequence ends at that time, then the algorithm does not migrate the job at any later time either.

Both the algorithm by Albers and Hellwig and the algorithm we present in this work satisfy the monotonicity property. Therefore, our results also directly imply an improved upper bound for the online minimum makespan scheduling problem with a reordering buffer on uniform machines.

The Model and Our Contribution
We present a lower bound on the competitive ratio showing that the problem is strictly harder for uniform machines than for identical machines. We give the first online algorithm for uniform machines with job migration. Depending on the speeds of the m machines, our scheduling algorithm achieves a competitive ratio that lies between 4/3 and  and performs O(m) job migrations. In addition, we show that  job migrations are necessary to achieve a competitive ratio of less than 2.

For the corresponding problem of online minimum makespan scheduling with a reordering buffer, Englert et al. [14] present a greedy algorithm that achieves a competitive ratio of 2 (or  if the algorithm is supposed to be efficient) with a reordering buffer of size m. Subsequently, Ding et al. [9] improved the competitive ratio to  with a buffer of size .Footnote 2 Therefore, we also obtain a significant improvement over these previously known results for the reordering buffer version of the problem, since our upper bound translates to this model as well.

Before we explain our contribution in more detail, we define the model more formally and introduce some useful notation and definitions. The  machines are denoted by 
. For each , the speed of machine 
 is denoted by 
, with 
. Later, for our upper bounds, we will assume that the machines are sorted in ascending order of their speeds, i.e., 
, but in our lower bound construction this is not necessarily the case. The sum of speeds is denoted by 
. The size of a job J is denoted by p(J). The load 
 of a machine 
 is defined as the sum of the sizes of the jobs assigned to machine 
. The completion time of a machine 
 is defined as the load 
 of machine 
 divided by the speed 
 of machine 
. The objective is to minimize the makespan, i.e., the maximum completion time.

As in previous works of Englert et al. [14] and Albers and Hellwig [2], our algorithm attempts to maintain a specific (and not balanced) load distribution on the machines. The desired load on a machine 
 is defined by the so-called  
 of the machine. The weight is defined as


 
 
 
 
 
 
 
 

Now, r is the smallest positive solution to 
, i.e., we ensure that the weights of all machines sum up to 1. Due to Corollary 16 in the “Appendix”, such a solution always exists. It is important to note that r depends on the number of machines m as well as the machine speeds 
. If 
, the weights match those in [2, 14] and 
 is equal to the competitive ratio achieved in [2, 14] for m identical machines.

Unfortunately, we do not know a closed-form formula for r, but the value can be calculated for any given m and speeds 
. Due to Corollary 16 in the “Appendix”,


 

where 
 is the lower branch of the Lambert W function, i.e., 
 is the smallest real solution to 
. Note that, for the optimal competitive ratio 
 for m identical machines,


 

Depending on the speeds of the machines, r can be significantly smaller than 
.

Our results are as follows.

We prove that a  exists such that, for m uniform machines with only two different machine speeds, m sufficiently large, no online algorithm can achieve a competitive ratio less than 
 while migrating o(n) jobs. Recall that, for the optimal competitive ratio 
 for m identical machines, 
. Hence, the more general problem of uniform machines is strictly harder than the special case of identical machines. The lower bound construction differs from the previous ones for identical machines in [2, 14]. The previous constructions used a very large number ( many) of very small jobs (of size ), which the online algorithm has to schedule on the machines. The adversary then identifies a machine with load of at least 
, i.e., a machine with a load that is not below the “target load” and, roughly speaking, produces just enough large jobs so that one of them has to be assigned to a machine with load 
. Migrating small jobs is ineffective and the large jobs cannot all avoid a machine with load 
. This technique alone however is no longer sufficient to obtain a lower bound that is strictly larger than the known one. Using a larger number of possible continuations of the initial input, we can show that to handle these additional continuations, the online algorithm would have to have a significant number of machines with completion time strictly less than, and bounded away from, 
. But then another machine must have completion time strictly above 
 (rather than just equal to 
). We remark that the same lower bound can be constructed for the reordering buffer model with uniform machines.

We show that, for m uniform machines,  migrations are necessary to achieve a competitive ratio of less than 2. Specifically, for , no online algorithm can achieve a competitive ratio less than  while migrating at most 
 jobs. For example, 
 if at most  job migrations are allowed. Again, we remark that the same lower bound can be constructed for the reordering buffer model with uniform machines.

For m uniform machines with speeds 
, our online algorithm achieves a competitive ratio of  with O(m) job migrations. If an efficient algorithm is desired, there is an additional additive loss of  in the competitive ratio due to the use of a PTAS by Hochbaum and Shmoys [24] in a subroutine. Note that 
, i.e., the competitive ratio is at most an additive 1/3 larger than in the identical machines case. However, depending on the speeds of the machines, r can also be significantly smaller than 
 in which case the difference between the competitive ratios can also be smaller than 1/3. The basic structure of our algorithm is similar to the algorithm for the special case of identical machines [2]: Jobs are classified into small and large jobs according to their relative size compared to the total load on all machines. Ignoring the contribution of large jobs, the small jobs are scheduled in such a way that an imbalance with respect to the completion times of the machines is maintained. Roughly speaking, faster machines are kept at lower completion times than slower ones. After all jobs have arrived, some jobs are migrated. The rough intuition is that the largest jobs should be reassigned to improve the solution. For this, we first remove some jobs from machines. Then, we schedule the largest ones optimally on m empty virtual machines 
 with 
. For m identical machines, this means that, for each , the completion time of machine 
 is less than or equal to the average completion time of the machines 
, and this is a crucial property for achieving the optimal competitive ratio for the identical machine case. In the more general case of uniform machines, this property does not always hold. For example, if 
 has speed 1 and 
 have speed 3/2, then m jobs of size 1 are optimally scheduled with makespan 1, but the completion time of 
 is 1, which is strictly greater than the average completion time of the machines 
. To address this new complication, our algorithm contains a crucial additional balancing step in which the average completion time for certain sets of virtual machines is increased at the cost of a small increase in the maximum completion time (which is responsible for the additive loss of 1/3). Finally, the smaller jobs that were removed from their machines are reassigned greedily one by one. The analysis of this step is also more involved than the corresponding one for identical machines because a more straightforward naive argument would introduce a factor of 
 into the number of job migrations. Obviously, once we determine which jobs to migrate, we could just assign those jobs optimally to the existing machines. However, it is not clear how to analyze such a procedure directly. We state a specific algorithm for the reassignment step because it provides us with important properties that enable us to analyze the competitive ratio.

Related Work
Minimum makespan scheduling has been extensively studied. See the survey by Pruhs, Sgall, and Torng [29] for an overview. For m identical machines, the currently best upper and lower bounds are 1.9201 [18] and 1.880 [30], respectively. These bounds were the last ones in a long series of successive improvements for general or specific values of m [1, 4, 5, 7, 17, 21, 22, 25, 31].

For uniform machines, Aspnes et al. [3] present the first algorithm that achieves a constant competitive ratio. Due to Berman, Charikar and Karpinski [6], the best known upper bound on the competitive ratio is 5.828, and, due to Ebenlendr and Sgall [13], the best known lower bound on the competitive ratio is 2.564.

In a semi-online variant of the problem the jobs arrive in decreasing order of their size. The greedy LPT algorithm, which assigns each job to a machine on which it will be completely processed as early as possible, was considered in this setting. For m identical machines, Graham [23] shows that the LPT algorithm achieves a competitive ratio of . For uniform machines, the LPT algorithm achieves a competitive ratio of 1.66 and a lower bound of 1.52 on its competitive ratio is known [19]. A detailed and tight analysis for two uniform machines is given by Mireault, Orlin, and Vohra [28] and Epstein and Favrholdt [15].

For m identical machines, Albers and Hellwig [2] present an algorithm that is 
-competitive, which is optimal as long as at most o(n) jobs can be migrated. For , the algorithm migrates at most 7m jobs. For smaller m, 8m to 10m jobs may be migrated. They further give some results on the trade-off between the number of job migrations and the competitive ratio. For example, 2.5m job migrations are sufficient to achieve a competitive ratio of 1.75.

Tan and Yu [33] study two identical machines. They give a tight bound of 4/3 on the competitive ratio and this bound is achievable by migrating a single job. They also explore two other models. One in which, at the end, for each machine, the last job that was assigned to the machine may be migrated. And another in which, at the end, the k jobs that arrived last in the input may be migrated.

Chen et al. [8] give an optimal algorithm for two uniform machines. Using independent techniques and algorithms, Wang et al. [34] show bounds which are similar, but not quite optimal for all machine speeds. Both improve upon work by Liu et al. [27].

Dósa et al. [12] consider a variant in which up to k jobs can be migrated after every job arrival, which is a relaxation of online scheduling with a reordering buffer of size k. Sanders, Sivadasan, and Skutella [32] introduce another model in which, after every job arrival, a number of jobs can be reassigned as long as the total size of the reassigned jobs is bounded by some linear function of the size of the arriving job.

Numerous variants related to online minimum makespan scheduling with reordering buffers have been studied. Kellerer et al. [26] present, for two identical machines, an algorithm that achieves an optimal competitive ratio of 4/3 with a reordering buffer of size 2, i.e., the smallest buffer size allowing reordering.

For m identical machines, Englert et al. [14] present a tight and, in comparison to the problem without reordering, improved bound on the competitive ratio for minimum makespan scheduling with reordering buffers. Depending on m, their scheduling algorithm achieves the optimal competitive ratio 
 with a buffer of size . Further, they show that larger buffer sizes do not result in an additional advantage and that a buffer of size  is necessary to achieve this competitive ratio.

Ding et al. [9] give, for m identical machines, a 1.5-competitive algorithm with a buffer of size  and, for three identical machines, a (15/11)-competitive algorithm with a buffer of size 7.

Dósa and Epstein [10] study minimum makespan scheduling on two uniform machines with speed ratio . They show that, for any , a buffer of size 3 is sufficient to achieve an optimal competitive ratio (i.e. even a larger buffer cannot result in a smaller competitive ratio) and, in the case , a buffer of size 2 already allows to achieve an optimal ratio.

Dósa and Epstein [11] further study preemptive scheduling, as opposed to non-preemptive scheduling, on m identical machines with a reordering buffer. They present a tight bound on the competitive ratio for any m. This bound is 4/3 for even values of m and slightly lower for odd values of m. They show that a buffer of size  is sufficient to achieve this bound, but a buffer of size o(m) does not reduce the best overall competitive ratio of  that is known for the case without reordering.

Epstein, Levin, and van Stee [16] study the objective to maximize the minimum completion time. For m identical machines, they present an upper bound on the competitive ratio of 
 for a buffer of size m and a lower bound of 
 for any fixed buffer size. For m uniform machines, they show that a buffer of size  is sufficient to achieve the optimal competitive ratio m.

Lower Bounds
Theorem 1
A  exists such that, for m uniform machines with only two machine speeds, m sufficiently large, no online algorithm can achieve a competitive ratio of less than 
 while migrating o(n) jobs, where n denotes the total number of arriving jobs.

Proof
Only two machine speeds 1 and 3/2 are used. Let 
 denote the number of slow machines with speed 1 and 
 denote the number of fast machines with speed 3/2. Note that the sum of speeds 
. Define 
 in such a way that 
, with 
.

Consider an online algorithm A that uses at most  job migrations. We start with the following initial input sequence:  small jobs of size  arrive. Depending on the actions of the online algorithm up to at most m additional larger jobs arrive later on. Therefore, in total our input sequence will contain no more than  jobs (i.e. ). In the remainder of the proof, we will frequently use that 
 which is a simple consequence of this. Let 
 denote the m uniform machines on which A has scheduled these jobs. Let 
 denote the respective speeds of these machines, with 
. According to this order of the machine speeds, define the weight 
 of a machine 
.

In the following, we show that the competitive ratio of A is at least 
. Due to Observation 17 in the “Appendix”, 
, as long as all machine speeds are upper bounded by some constant which is independent of m. Hence, for m sufficiently large, 
. As a consequence, for m sufficiently large, there exists a  such that no online algorithm can achieve a competitive ratio of less than 
.

Due to Corollary 16 in the “Appendix”, 
. This gives the following observation.

Observation 2

 
 
 
 
 
 
 
 

Assume for contradiction that A achieves a competitive ratio of 
.

The lower bound construction for the identical machines case, is based on the following idea: there must exist a machine 
 with load of at least 
 after the initial sequence, since otherwise, the total scheduled load would be strictly less than 
. Since at most k(n) of these jobs can be migrated at the end, at least 
 of them are guaranteed to stay on 
 which is still almost all the load for sufficiently small  since 
. The high load on 
 can now be exploited by continuing the input sequence in the right way.

However, for uniform machines we now want to get a larger lower bound than for the identical machine case. Hence, a significant contribution is the following lemma that gives an improved lower bound on the completion time. Specifically, it shows a lower bound on the completion time that is larger than the original 
 by an additive 
, resulting in an improved lower bound on the competitive ratio of A.

Lemma 3
After the initial input sequence, a machine 
 with completion time of at least 
 exists.

Proof
We show that the lemma holds as otherwise a continuation of the input sequence that leads to a contradiction to A being 
-competitive exists. We distinguish two cases.

The number of fast machines with weight 
 is at least : In addition, 
 large jobs of size 
 arrive, with


 
 
 
 
 
 
 
 
 
 
 
 
 
 

An optimal offline algorithm can schedule each large job on a separate fast machine and evenly distribute the small jobs among the remaining machines. These remaining machines, among which the small jobs are distributed, consist of all 
 slow machines and the  fast machines that do not get assigned any of the large jobs. Therefore, the sum of their speeds is exactly 
. Hence, the optimal makespan is at most 
. If, in the final schedule after migrations, A schedules one large job on a slow machine or two large jobs on the same fast machine, the completion time of such a machine is at least 
 and, therefore, the competitive ratio of A is at least

which is strictly larger than 
 if  is sufficiently small. As a consequence, A schedules each of the large jobs on a separate fast machine. Let  be the set of such machines which have weight 
. Then for any machine 
, for the load 
 on 
 caused by small jobs,


 
 
 

since otherwise the completion time of 
 is at least


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

which is a contradiction to A being 
-competitive. For the fourth step, recall that

and for steps seven and nine, note that Observation 2 gives . The number of large jobs that are scheduled on a machine with weight  is


 
 
 
 
 
 
 
 
 
 

for 
 sufficiently large. We conclude that there must be a machine 
 such that


 
 
 
 
 

as otherwise


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

which is a contradiction to the fact that the total size of all small jobs combined is S.

The number of fast machines with weight 
 is at most : In addition, 
 large jobs of size 
 arrive, with


 
 
 
 
 
 
 
 
 
 
 
 

An optimal offline algorithm can schedule each large job on a separate machine of the set of all fast and 
 slow machines. Now, the fast machines can process additional jobs while the slow machines are working on large jobs. Therefore, the small jobs can be distributed among the remaining slow machines and the fast machines, which give a weighted sum of speeds of 
. Hence, the optimal makespan is at most 
. If A schedules two large jobs on the same slow machine or three large jobs on the same fast machine, the competitive ratio of A is at least

which is strictly larger than 
 if  is sufficiently small. As a consequence, A schedules at most one large job on each slow machine and at most two large jobs on each fast machine. Let  be the set of all slow machines that have weight 
 and receive one large job and all fast machines that receive two large jobs. Then for any slow machine 
, for the load 
 on 
 caused by small jobs,

since otherwise the completion time of 
 is at least


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

which is a contradiction to A being 
-competitive. For the second step, recall that

and note that the last step follows form Observation 2. In addition, for any fast machine 
, for the load 
 on 
 caused by small jobs,

since otherwise the completion time of 
 is at least


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

which is a contradiction to A being 
-competitive. For the second step, note that by the definition of the weights, 
 for all i. If the number of fast machines with weight 
 is at most  (as is the case here), then their combined speed is at most  − 3/2. The sum of the speeds of all machines with weight 
 is at least  by the definition of the weights. Then the number of slow machines with weight  is at least .

We conclude that the number of slow machines with a weight different from  is at most 
. Thus, for the 
 large jobs, the number of large jobs that are scheduled on a slow machine with weight  or together with another large job on a fast machine is


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

The second step holds for 
 sufficiently large. For the fourth step, note that, for m sufficiently large, 
, since 
 and 
. We conclude that there must be a machine 
 such that


 
 
 
 
 

as otherwise


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

which is a contradiction to the fact that the total size of all small jobs combined is S.

Let 
 denote a machine which, after the initial input sequence of jobs of size , has a completion time of at least 
. We distinguish two cases.

:

No more jobs arrive. An optimal offline algorithm can evenly distribute all jobs among the machines. Hence, the optimal makespan is at most . Finally, the competitive ratio of A is at least


 
 
 
 

which is strictly larger than 
 if  is sufficiently small.

:

In addition, 
 large 3/2-jobs of size 
 and 
 large 1-jobs of size 
 arrive. An optimal offline algorithm can schedule each large x-job, with , on a separate machine with speed x and evenly distribute the small jobs among the remaining machines. Hence, the optimal makespan is at most 
.

If A schedules one large 3/2-job on a slow machine or two large jobs on the same machine, the competitive ratio of A is at least


 
 

which is strictly larger than 
 if  is sufficiently small.

If 
, the number of 3/2-jobs that arrive is greater than the number of fast machines 
 which have an index of 
. Since these jobs can only be scheduled on fast machines, at least one of them has to be scheduled on a machine with index 
. If 
 the number of 3/2-jobs that arrive is equal to the total number of fast machines 
. If there exists a fast machine which has an index 
, at least one of these jobs has to be scheduled on such a machine. On the other hand, if all fast machines have an index of 
, then we observe that the total number of 1-jobs and 3/2-jobs is 
. Hence, at least one of the jobs has to be scheduled on a machine with index 
 (and this machine is slow). We conclude that A schedules at least one large x-job, with , on a machine with speed x that, after the initial assignment of the jobs of size , that, after the initial assignment of the jobs of size , already has a completion time of at least 
.

By definition of 
, 
. Finally, the competitive ratio of A is at least


 
 
 
 

which is strictly larger than 
 if  is sufficiently small.

Theorem 4
For , no online algorithm can achieve a competitive ratio of less than  while migrating at most 
 jobs.

Proof
Let  and . For each , there are  machines with speed 
. Add machines of speed 1 such that there are m machines in total. Consider an online algorithm A that migrates at most 
 jobs.

The input sequence consists of at most c consecutive phases. In phase ,  jobs of size 
 arrive. Let 
 denote the number of jobs of size 
 that are assigned by A to machines with speed strictly less than 
 or to machines where at least one job of size 
 is already scheduled. If 
, stop at the end of this phase. Otherwise, if , continue with phase .

If the input sequence stops at the end of phase  due to the fact that 
, the competitive ratio of A is at least


 
 

Otherwise, we focus on the  machines with speed 
. In each phase i, at least  of these machines are assigned a job of size 
. This means that after the last phase, there must be  such machines which each were assigned one job from each phase. We can remove jobs from at most k such machines in the migration phase. Therefore, after the migration phase, at least


 
 
 
 
 
 

machines with speed 
 exist, to which, for each , A has assigned at least one job of size 
. Hence, the competitive ratio of A is at least


 
 
 

since . 

Scheduling Algorithm
For m uniform machines with speeds 
, our algorithm consists of two phases: In the scheduling phase, arriving jobs are assigned to (or scheduled on) machines online. In the migration phase, which starts after all jobs have arrived, some jobs are removed from their machines and reassigned to other machines.

More specifically, the scheduling phase consists of steps , where n denotes the total number of arriving jobs. In step t, the t-th job arrives and is assigned to a machine. For , let 
 denote the total size of the  jobs that have arrived up to and including step . In addition, define 
. A job J is called small in step t, if 
, where b is a constant that will be defined later. Otherwise, J is called large in step t. Note that during the scheduling phase, a job that is large in step t can become small in step .

Further, let 
 denote the total size of the jobs that have arrived up to and including step  and that are small in step t. Finally, let 
 denote the total size of the jobs that are scheduled on machine 
 at the end of step , i.e., after the -th job is assigned to a machine, and let 
 denote the total size of the jobs that are scheduled on machine 
 at the end of step  and that are small in step t.

We use two different algorithms. The first algorithm, which is used when 
, schedules every job on machine 
 and does not migrate any jobs. The second algorithm, which is used when 
, is more interesting and works as follows.

Scheduling phase: The t-th arriving job J is scheduled in step t as follows.

If J is small in step t, J is assigned to a machine 
 with 
. (Since 
 and 
, such a machine always exists.)

If J is large in step t, J is assigned to a machine 
 that has minimum completion time 
 among all machines.

Migration phase: Throughout the migration phase, we remove jobs from machines and reassign them. At any point during this process, let 
 denote the load of machine 
 at that point, i.e., the 
 values are changing throughout the migration phase.

At the start of the migration phase, after all n jobs have arrived, we have, for each , 
. Then do the following. For each machine 
, as long as 
 and 
, remove the job of largest size from 
.

The removed jobs can now be reassigned optimally to the machines, i.e., in such a way that the resulting makespan is minimized. However, as stated before, it is difficult to analyze the resulting makespan directly. In the following, we therefore present a more specific procedure for this reassignment step which provides us with certain properties that enable us to analyze the competitive ratio. The resulting bound is of course also an upper bound on the competitive ratio achieved through an optimal reassignment.

(1)
Those removed jobs that are large at time  are scheduled on m empty virtual machines 
 with speeds 
:

(1a)
The jobs are scheduled on the virtual machines optimally, i.e., to minimize the makespan of the virtual machines.Footnote 3 Call the resulting makespan on the virtual machines 
. We assume that the resulting loads of the virtual machines are sorted, i.e., 
, and that, for each , 
 if 
. (See the following Observation 5 items (1) and (2).)

(1b)
Each machine 
, with  where


 
 
 
 
 

is called critical. If , all jobs from the machines 
, with , are reassigned to 
.

For  do the following:

Find the largest  such that 
. (Due to the following Observation 5 item (3), such a machine always exists.)

Reassign all jobs from 
 to 
, i.e., 
 is increased by 
 and 
 is set to 0.

Re-sort the loads of the machines such that 
 again. (See the following Observation 5 item (1).)

Finally, for each , assign the jobs from 
 to the real machine 
.

(2)
Those removed jobs that are small at time  are scheduled according to the greedy algorithm that assigns a job to a machine finishing it first.

Observation 5
For the migration phase, the following observations can be made.

(1)
Sorting according to the load does not increase the makespan.

(2)
We can assume that, for each , 
 if 

(3)
If , then for each , 
.

(4)
For each , 
.

Proof
(1)
Assume that 
, with . Since 
, swapping the loads of 
 and 
 does not increase the makespan.

(2)
While a  exists with 
 and 
, reassign the jobs from 
 to 
, i.e., 
 is increased by 
 and 
 is set to 0, and sort according to the load. This does not increase the makespan, since 
 and due to item (1). Further, this process terminates, since after each iteration there is one more machine with no load.

(3)
Assume for contradiction that, for each , 
. This yields the following contradiction to the fact that 
 is critical:


 
 
 
 
 
 
 
 
 

since 
. Then, there exists a , with 
. Since 
, 

(4)
Clearly, at the beginning of step (1b), for each , 
. Then, after each reassignment in step (1b), for each , 
 due to items (3) and (1). 

Analysis of the Algorithm
The analysis of the algorithm consists of two parts. The first part provides a bound on the number of migrated jobs. The second part provides a bound on the competitive ratio of the algorithm. These two parts together give the following theorem.

Theorem 6
For m uniform machines with speeds 
, our online algorithm achieves a competitive ratio of  with O(m) job migrations.

Bounding the Number of Migrated Jobs
The following lemma gives an upper bound on the number of jobs removed from a single machine.

Lemma 7
For each , in the migration phase, at most 
 jobs are removed from machine 
.

Proof
If the final load of 
 at the end of the scheduling phase satisfies 
 or 
, no job is removed from 
. Otherwise, let t be the last time at which 
 or 
. Such a time t exists because the condition is met for . Note that the condition is slightly different than the negation of the condition for job removals in the migration phase because we are using 
 rather than 
 in the first part. We do this so that the first part of the condition aligns with the condition for the placement of small jobs in the scheduling phase.

It is sufficient to remove the following jobs from 
 to guarantee 
 or 
.

(a)
All jobs that are large at time t and are scheduled on 
 before the arrival of the t-th job and

(b)
all jobs assigned to 
 in step t or after.

At any time 
 (before the arrival of the 
-th job), there are at most 
 jobs that are large at time 
 scheduled on 
. Suppose this is not true and let 
 be the first time at which this is not true. Then there were 
 jobs of size greater than 
 scheduled on 
 at time 
 and in step 
 one more such job J is assigned to 
. However, before the assignment of J, the load of 
 is 
. Then 
 cannot be a machine with minimum completion time among all machines in step 
 and therefore a large job J would not be assigned to it. We conclude that at most 
 jobs are removed in (a).

To bound the number of jobs removed in (b), we observe that in steps  our algorithm only allocates jobs to 
 that are large at the time of allocation. This is due to the fact that by definition of t, for each 
, 
. Therefore, whenever a job J is assigned to 
 in a step 
, it is a large job, which is assigned to a machine of minimum completion time. But then, for each , 
, because we also have 
. Hence 
. Since job J is large at the time of assignment, its size has to be greater than 
. After assigning 
 such jobs to 
 in steps after t, the load of 
 exceeds 
. After that, no further such jobs are assigned to 
, because a machine with load greater than 
 can never be a machine that has the smallest completion time among all machines. We conclude that, at most 
 jobs are removed in (b), where the additive 1 is due to the job that is assigned to machine 
 in step t.

In total, it is sufficient to remove these 
 many jobs, and, because the algorithm removes jobs from 
 in decreasing order of size, the number of jobs removed is bounded by the same number. 

Due to Lemma 7, the total number of jobs migrated is bounded by


 
 
 
 
 

Recall, that we only migrate jobs when 
, as otherwise, we simply schedule all jobs on machine 
. If 
, according to Corollary 16 and Observation 18 in the “Appendix”, 
. Hence, we number of migrated jobs is at most

Bounding the Competitive Ratio
If 
, we assign all jobs to machine 
. The resulting makespan is 
, where  denotes the optimal makespan. Hence the competitive ratio is bounded by .

For the remainder of the paper, we consider the case 
. The following lemma shows that, at the end of step (1b), there are no critical machines. In fact, it gives a lower bound on 
.

Lemma 8
At the end of step (1b), for each ,


 
 
 
 
 

Proof
Clearly we have


 
 
 
 
 
 
 

because 
 (optimally scheduling a subset of all jobs can only result in a smaller makespan than optimally scheduling all jobs). Therefore, it only remains to show


 
 
 
 
 

If , the lemma is true by definition of C. In the following, we consider the case . At the end of step (1b), for each , 
 and, as a consequence, the lemma is true for these machines. In the following, we show that the lemma is true for 
 after each reassignment in step (1b), if it is true for these machines before this reassignment.

Initially, at the beginning of step (1b), for each , 
 is not critical by definition of c, i.e., the lemma is true for 
.

Now, consider a reassignment in step (1b). For each , let 
 and 
 denote the load of machine 
 before and after this reassignment, respectively. Assume that the lemma is true for 
 before this reassignment.

In this reassignment, all jobs from 
, with , are reassigned to 
, with


 
 
 

Then, re-sort the loads of the machines again. Specifically,


 

i.e., after re-sorting, 
, and, for each , 
. In addition, for each , 
. Note that, for each , 
 and, if , 
.

It remains to show that the lemma is true for 
. Consider machine 
 with . If 
, then


 
 
 
 
 
 
 
 
 

since, by definition of , for each , 
.

In the following, we consider the case 
.

Observation 9
For each , 
.

Proof
Assume for contradiction that there exists a  with 
. Then,


 
 
 
 
 
 

i.e., 
. This yields the following contradiction to the fact that all jobs from 
 are reassigned to 
:  and


 
 
 
 
 
 
 

since, by definition of , 
. 

Due to the fact that 
 is critical,


 
 
 
 
 
 

As a consequence, by subtracting 
,


 
 
 
 
 
 
 

where the second step follows from 
.

Due to Observation 5 item (2),


 
 
 
 

and, due to Observation 9,


 
 
 
 
∑𝑗=𝑥+1𝑚−1𝐿(𝑀′𝑗)≥45⋅OPT′⋅∑𝑗=𝑥+1𝑚−1𝑠𝑗.

Hence,


 
 
 
 
 
 
 
 

As a consequence,


 
 
 
 
 
 
 
 
 

i.e.,


 
 
 
 

Altogether,


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

where the second Step uses Observation 5 item (2) and Observation 9, the fourth step uses 
, and the fifth step uses 
 which holds due to Observation 5 item (4). 

Next, we give a bound on the makespan at the end of step (1) of the migration phase. We distinguish two cases.

 after the removal of jobs:

Then, 
. The completion time of machine 
 at the end of step (1) of the migration phase is 
, since 
 due to Observation 5 item (4).

 after the removal of jobs:

Then, 
 after the removal of jobs.  is an upper bound on the total size of all jobs in the input and the virtual machines only contain jobs which are large at time . Therefore 
. We distinguish two sub-cases.

:

By definition of 
, 
 and, as a consequence,


 
 
 
 
 

Then we can bound the completion time of machine 
 at the end of step (1) of the migration phase as follows:


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

where the second step uses Lemma 8.

:

By definition of 
,

Then we can bound the completion time of machine 
 at the end of step (1) of the migration phase as follows:


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

where the second step uses Lemma 8, the third step uses 
 and 
 which holds due to Observation 5 item (4), and the fourth step uses 
.

In all cases, the makespan is at most  at the end of step (1) of the migration phase.

Finally, we analyze the makespan at the end of step (2) of the migration phase. We start with the following observation.

Observation 10
There exists a machine 
 with 
 and completion time of at most , where


 
 
 

Proof
Assume for contradiction that, for each 
, 
. This yields the following contradiction:


 
 
 
 
 
 
 
 

since 
 by the definition of 
. 

Consider a removed job J that is scheduled in step (2) of the migration phase. Since J is small at time , 
. According to Observation 10, there exists a machine 
 with 
 and completion time of at most . Since 
, 
. In step (2) of the migration phase, J is assigned to a machine finishing it first. Then, we can bound the completion time of this machine after J is assigned to it as follows:


 
 
 
 
 
 
 

At the end of the migration phase, the makespan is at most 
. Recall that 
. For example, for , 
, and, for , 
.