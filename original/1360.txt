We study the parameterized complexity of computing nontrivial automorphisms of weight k for a given hypergraph , with k as fixed parameter, where the weight of a permutation 
 is the number of points moved by . Building on the earlier work of Schweitzer (in: Proceedings of 19th ESA, Springer, Berlin, 2011. https://doi-org.ezproxy.auckland.ac.nz/10.1007/978-3-642-23719-5_32), we show the following results: (1) Computing nontrivial automorphisms of weight at most k for d-hypergraphs (that is, with edge-size bounded by d) remains fixed parameter tractable, with d treated as a second fixed parameter. Likewise, finding isomorphisms of weight k between d-hypergraphs X and Y (both defined on vertex set [n]) remains fixed parameter tractable. (2) For dealing with the exact weight k version of the problem, we introduce a more general algorithmic problem PermCode: given a permutation group G by a generating set and a fixed parameter k, is there is a nontrivial element of G with support at most (or exactly) k? We give a method for shrinking large orbits of the given group G to obtain subgroups while maintaining existence of weight at most k elements in it. An application of this yields an FPT algorithm for finding exact weight k nontrivial automorphisms in d-hypergraphs, d as second fixed parameter. (3) For hypergraphs with edges of unbounded size, we show that the problem is in 
. (4) Computing d-hypergraph isomorphisms of weight exactly k is fixed parameter tractable. This requires a more complicated orbit shrinking technique.

Introduction
Given linear equations  over 
, determining a minimum weight nonzero solution is the minimum weight codeword problem, which is a fundamental and well studied algorithmic problem. Even finding constant factor approximations to it is NP-hard [3, 4]. The parameterized complexity of the decision version of this problem (called Even) is also well studied [5, 6]. Formally:

: Given linear equations  defining a linear code over 
 and a parameter k, is there is a nonzero codeword of weight at most k?

It was only recently shown [7, 8] that  is -hard under randomized reductions. For the exact weight-k codeword problem  (determining if there is a codeword with weight exactly k) -hardness was shown years ago [5].

These problems have a natural generalization in the setting of permutation groups. Let  be a permutation (on n elements). We define the support of , denoted  as

The generalization of  we consider is the following:

PermCode: Given  and parameter k, is there a permutation  such that ?

It is readily seen that Even is a special case of PermCode. We can encode the two elements of 
 by the two permutations on : The bit 1 is encoded as the transposition (1 2) and the bit 0 as the identity (1)(2). In general, let 
 be a vector. We can encode it as a product of transpositions as follows: The domain is the set . If 
 then we encode it as the transposition  and if 
 we encode it as the identity permutation . Thus, if 
 then the vector x is encoded as the permutation 
 defined as a product of disjoint transpositions 
.

Now, let  be an instance of Even. Let 
 be the solution space for the system of linear equations , which can be computed in polynomial time given A. Then  is a yes instance of Even if and only if there is a nonzero vector of weight at most k in the subspace spanned by 
 in 
 which holds if and only if the permutation subgroup G of 
 generated by 
 contains a permutation of weight at most 2k.

We now explain what these problems have to do with Graph Isomorphism and Graph Automorphism, which are the main topic of this paper. Suppose X is an n-vertex graph or hypergraph, and the permutation group  is the automorphism group  of X. An analogue of Even is the following problem:

: Given an undirected simple graph  and parameter k, does  contain a nontrivial automorphism moving at most k vertices?

Likewise, we also consider the following problems (for graphs and hypergraphs):

: Given an undirected simple graph  and parameter k, does  contain a nontrivial automorphism moving exactly k vertices? This is the problem analogous to the exact weight-k version of Even.

: Given a hypergraph  and parameter k, does  contain a nontrivial automorphism moving at most k vertices?

: Given a hypergraph  and parameter k, does  contain a nontrivial automorphism moving exactly k vertices?

Are these problems also -hard or are they fixed parameter tractable?

In [9], Schweitzer showed that 
 is in FPT by giving a 
 time algorithm for it for n-vertex graphs. The problem 
 is defined as follows: given input graphs X and Y on vertex set [n] and a fixed parameter k, is there an isomorphism between X and Y moving at most k vertices? Schweitzer’s algorithm can easily be adapted to also solve the problem 
.

Our Results
Extending Schweitzer’s result [9], in this paper we show the following:

For hypergraphs with edge-size bounded by d (treated as a second fixed parameter), we show that 
 is fixed parameter tractable. This requires a generalization of the technique used in [9]. It is well-known that Hypergraph Isomorphism is polynomial-time reducible to Graph Isomorphism. However, to the best of our knowledge, no parameterized reduction achieving this is known, when the support size of the isomorphism is treated as parameter. This is presented in Sect. 3.

The exact weight-k automorphism problem poses a different difficulty which requires significantly different ideas than used by Schweitzer [9]. We give an orbit shrinking method showing that PermCode for an arbitrary permutation group G can be reduced in polynomial time to PermCode for a subgroup 
 of G, where the orbits of 
 are of size bounded by the parameter k. We use this tool to reduce 
 to the same problem for vertex-colored hypergraphs with color classes of size k. It turns out that for such graphs we can find color-preserving automorphisms of weight exactly k in FPT. These results are described in Sects. 4 and 5.

The orbit shrinking technique has another application: For general hypergraphs of unbounded edge-size, we show that 
 and 
 are in 
. The  oracle is first used to compute the automorphism group of X. Then the orbit shrinking technique is applied to  to obtain orbits of size at most k. Interpreting orbits as vertex color classes, we can apply algorithms of Sect. 4 to solve the problem in FPT.

Computing d-hypergraph isomorphisms of weight exactly k is also fixed parameter tractable. It turns out that the previous orbit shrinking technique does not work for this problem. The problem requires additional permutation group theory which yields an FPT algorithm. This result is described in Sect. 6.

Preliminaries
We use the 
 notation for upper bounding the running time of our algorithms. This notation suppresses factors that are polynomial in the input size. In this paper the factor is at most quadratic in |V| and |E| for an input hypergraph .

We recall some permutation group theory basics. Details can be found in Dixon and Mortimer’s comprehensive text [10].

A permutation group G is a subgroup of , where  is the group of all permutations on a finite domain V of n elements. The subgroup all even permutation on V is denoted . When the n-element domain V is implicit or nonspecific we denote these groups by  and , respectively. We write  when H is a subgroup of G. Thus, .

Let 
 denote the image of  under permutation , and we denote the identity permutation by . We apply permutations from left to right so that 
. For a subset , 
. If  is an element of G then  denotes the coset . For , the group  generated by S is the smallest subgroup of  containing S. The G-orbit of an element  is the set

If  we also refer to the set 
 as the -orbit of v.

Let  be a permutation group. For , the point stabilizer subgroup is

The set stabilizer subgroup is

For a singleton subset , we write 
 for the point stabilizer.

For 
, by abuse of notation, we denote by 
 the intersection 
 of all set stabilizers 
.

Properties of the Cayley and Hamming Permutation Metrics
We now derive some useful properties about the Hamming and Cayley metric for permutations.

The support of a permutation  is defined as the subset of points in V not fixed by :

Definition 2.1
(Hamming metric) The Hamming distance between two permutations  is defined as

This is a generalization of the standard Hamming metric on binary vectors (by encoding each bit as an element of the symmetric group ). It is easy to see that 
 is a metric space [11].

The Hamming weight of a permutation  is defined as 
.

Every permutation can be written as a product of transpositions.

Definition 2.2
The complexity of a permutation , denoted , is the minimum number of transpositions whose product is . More precisely, let r be the least positive integer such that

where 
 are transpositions. Then .

Every nontrivial permutation  can be expressed as a product of disjoint nontrivial cycles. For any cycle 
 of length  its minimal expression as a product of transpositions is


 

Hence, .

Proposition 2.3
For  let 
, for nontrivial disjoint cycles 
. Then


 
 

(2)

Definition 2.4
(Cayley metric) The Cayley distance between two permutations  is defined as

Definition 2.5
Let  be a permutation group and .

1.
A permutation  has minimal support in the coset  if there is no 
 with 
.

2.
A permutation  has minimal complexity in the coset  if  cannot be decomposed as 
 for 
 and 
 such that 
.

In particular, these notions apply to elements of the automorphism group  of a graph X and to elements of the coset  of isomorphisms between two graphs X and Y.

Proposition 2.6
Let  be a coset of a permutation group  for some . Suppose  is not of minimal complexity, and for 
 and 
 we have

 and

.

Then 
 and 
.

Proof
We can write both 
 and 
 as a product of disjoint cycles. I.e. 
 and 
 for all indices .

Assume to the contrary that for some point  we have 
. Clearly, we must have 
. Without loss of generality, suppose 
. There is a  such that 
 and 
. Reordering the cycles we can write

Notice that 
 has size at most 
, because i is not in the support and j, which is in both 
 and 
, has to be counted only once. Therefore, 
, which implies


 
 
 

This contradicts the proposition’s hypothesis that


 
 
 


Remark 2.7
The minimality notions in Definition 2.5 are incomparable. Consider the automorphism groups of the graphs in Fig. 1. Taking 
 as G and  in Definition 2.5, we note that the automorphism (1 2)(3 6)(4 5) has minimal complexity but (2 6)(3 5) has smaller support.

Let  and . Then . The element  has minimal support size in  but not minimal complexity, witnessed by the decomposition

for 
 and 
.

On the other hand, for a subgroup G of  we can show that minimal support implies minimal complexity.

Corollary 2.8
For any permutation group , if  is of minimal support then  is a minimal complexity element of G.

Proof
Suppose not. Then 
 such that both 
 and 
 are in  and


 

(3)

By Proposition 2.6, both 
 and 
 are contained in . Since  is of minimal support it follows that 
. Let . Now, the maximum value of  is  (when  has a single cycle) and the minimum value of 
 that is possible is s/2. Thus, the equality in Eq. 3 is impossible, completing the proof. 

Fig. 1
figure 1
The automorphism groups of these graphs show that the three minimality notions of Definition 2.5 are incomparable; see the text for details

Full size image

In the following proposition we show that every element of  can be decomposed into a product of permutations of minimal complexity.

Proposition 2.9
Let  be a coset of a permutation group  for some . Let . Then  can be decomposed as a product

for some , such that 
, where 
 are of minimal complexity, and 
 is of minimal complexity such that 
 for each . Moreover, all these inclusions become equalities if  and  is of minimal support in G.

Proof
The proof is by induction on  and repeated application of Proposition 2.6. In the base case, where  has minimal complexity in , we have  and 
. Otherwise, there are  and  such that  and . By Proposition 2.6, this implies  and . To see that these inclusions become equalities if  and  has minimal support in G, note that 
 for all  as  and 
 a proper subset of  would contradict the assumption that  has minimal support in G. As both  and  have lower complexity than , we can apply the induction hypothesis to them. This yields the decompositions 
 and 
 such that: 
 are of minimal complexity and  for each i, and 
 are of minimal complexity such that 
 for each j. Combining these we obtain 
. This completes the induction and the proof. 

Hypergraphs with Bounded Hyperedge Size
A hypergraph  consists of a vertex set V and a hyperedge set 
. Call X a d-hypergraph if the maximum edge size 
 is d. Usual graphs are 2-hypergraphs as  for all edges e. The degree of a vertex  is . An isomorphism from hypergraph  to hypergraph 
 is a bijection 
 such that 
.

A (vertex) coloring of X is a partition 
 of V into color classes 
, . A colored hypergraph 
 is called b-bounded if 
 for all . An isomorphism  from a colored hypergraph 
 to a colored hypergraph 
 is a color-preserving isomorphism from X to 
, i.e. 
 for all . The automorphisms of X are the isomorphisms from X to itself; they form a subgroup of  denoted . Suppose X and 
 are isomorphic and  is an isomorphism from X to 
. The set of isomorphisms from X to 
 form a right coset 
.

In this section we consider the problems 
 and 
 for d-hypergraphs, with d as additional fixed parameter, and give FPT algorithms for them. More precisely, let  and 
 be d-hypergraphs. We show that a nontrivial element  of weight at most k, if it exists, can be found in 
 time. Notice that even for 
 this running time is 
.

This generalizes Schweitzer’s 
 algorithm for 
 [9], for usual graphs, to d-hypergraphs. For usual graphs, Schweitzer’s algorithm searches for an isomorphism in  of support size at most k, by iteratively applying transpositions that bring the two graphs closer to each other. Thus, if  is a candidate partial isomorphism, the algorithm continues the search by branching on a choice of transposition applied to 
, from among 
 transpositions. Thus, to find the suitable sequence of transpositions, the algorithm explores a search tree of depth k and degree  
 . In each step, it computes a candidate set  of at most 2k vertices and tries all transpositions among them. The candidate set has the crucial property that for each isomorphism  between 
 and Y that has support size at most k, C contains two vertices i, j that are in the same orbit of .

Vertex covers play an important role in computing the candidate set in Schweitzer’s algorithm. To extend this algorithm to hypergraphs we need a generalization of vertex covers.

Definition 3.1
Let  be a hypergraph and . A hyperedge  is q-covered by C if . The set C is a q-cover of X if it q-covers every hyperedge of X.

Clearly, 1-covers are the usual vertex covers.

Definition 3.2
Let X and Y be two hypergraphs with vertex set .  is the hypergraph with edge set  and having as vertex set the union of all edges in .

For the sequel, let X and Y be non-identical hypergraphs on vertex set V. Let  be an isomorphism from X to Y with .

Lemma 3.3
Suppose C is a q-cover of  such that no two distinct points in C are in the same -orbit. Then for all hyperedges e of :


 

Proof
Suppose 
 such that 
 and 
 for some . Further, suppose . That is, 
 for . W.l.o.g. let . Let  be the smallest positive integer such that 
. We claim that 
 implies 
, for .

Since 
 for , for some 
 we have 
. As 
 and no two distinct elements of C is in the same -orbit, it follows that 
. Hence, 
 is not q-covered by C which implies 
 is not in the symmetric difference . On the other hand, since  is an isomorphism, 
 implies that 
. Hence, 
.

As 
, repeated application of this implication yields 
 which implies 
 as  is an isomorphism. This contradicts the assumption that . 

Lemma 3.4
If  is a q-cover of  such that no two distinct points in  belong to the same -orbit, then  is a -cover of .

Proof
By Lemma 3.3, for all hyperedges e of  with  we have . Hence,  covers at least one additional vertex in each such hyperedge. 

Lemma 3.5
If C is a q-cover for  and some hyperedge e of  has size at most q, then C contains two distinct points from some -orbit.

Proof
As C is a q-cover and  it follows that C contains e. If no two distinct points in C are in the same -orbit, then Lemma 3.3 implies that C does not contain , which contradicts the fact that . 

Lemmas 3.4 and 3.5 suggest the following algorithm to compute a candidate set; it can be plugged into Schweitzer’s isomorphism test [9, Algorithm 1], cf. Algorithm 2 below.

figure a
Observe that, by construction, Algorithm 1 returns a candidate set 
 of size at most dk. The following lemma shows that 
 also has the other desired property, stated in the lemma, and gives an FPT bound on the running time of the procedure.

Lemma 3.6
Let  be hypergraphs on vertex set V with hyperedge size bounded by d, and  be an isomorphism from X to Y with . Then the set 
 returned by 
 contains two vertices in the same -orbit. Moreover, the running time of the procedure is 
.

Proof
By definition, 
 is a 0-cover. Lemma 3.4 guarantees that for , the while-loop condition fails only if 
 contains two vertices in the same -orbit. By Lemma 3.5, if the while loop terminates with  then also 
 contains two vertices in the same -orbit.

It remains to bound the running time. The only step to discuss is extending a q-cover 
 of  to a -cover 
 in Line 5. This amounts to finding a hitting set S of size at most k for the hypergraph


 

and taking 
. The latter problem is fixed parameter tractable by the classical bounded search tree technique in time 
 (see, e.g., [12, Theorem 1.14]). 

The following is a search version of Schweitzer’s algorithm adapted to hypergraphs.

figure b
Finding all isomorphisms of support size at most k is not possible in FPT time; e.g. between two complete graphs there are 
 of them. However, the following lemma shows that Algorithm 2 finds a meaningful subset of them. More precisely, if X and Y are isomorphic d-hypergraphs on the same vertex set V we know that  is the right coset  where  is some isomorphism. We will show that the output of Algorithm 2 includes all complexity-minimal isomorphisms  such that .

Lemma 3.7
Let  be d-hypergraphs on the vertex set V, and let . Then 
 returns a subset of  containing each complexity-minimal isomorphism  such that  and . Further, 
 runs in time 
.

Proof
It is clear from the algorithm description that the set returned by 
 only contains isomorphisms from X to Y.

It remains to show that every complexity-minimal isomorphism  from X to Y with and  is in this set. By Lemma 3.6, the candidate set C contains two vertices u and v in the same orbit of . Thus, we can write 
 for some 
 such that 
. If 
 then we claim it has minimal complexity in 
. Indeed, 
 with 
, 
 and 
 would imply 
 with 
, 
 and 
, contradicting that  has minimal complexity in .

Now it suffices to show that when u and v are considered in the loop starting in Line 8, the permutation 
 is in the set returned by 
. This follows by induction on the complexity of , with the base case  taken care of by Line 4.

To show the bound on the running time it suffices to observe that the depth of the recursion tree is c and, as , there are 
 recursive calls in total. In each call, it takes 
 time to compute C (Lemma 3.6), and the rest of the computation is linear in the size of the recursion tree. 

Remark 3.8
1.
By Lemma 3.7, the number of minimal complexity isomorphisms of weight at most k between two d-hypergraphs is bounded by 
.

2.
An isomorphism  in the set P returned by 
 has minimal complexity if and only if there is no  with  and 
. This property can be checked in polynomial time. Hence, we can efficiently compute from P the set of all minimal complexity isomorphisms of weight at most k.

Theorem 3.9
Given as input d-hypergraphs  there is an 
 algorithm for deciding if there is an isomorphism from X to Y of weight at most k.

Proof
The algorithm runs 
 and accepts if the returned set is not empty. Every isomorphism  from X to Y with  trivially satisfies  and can be decomposed by Proposition 2.9, obtaining a minimal-complexity isomorphism 
 from X to Y with 
. By Lemma 3.7, 
 is in the set returned by 
. 

We conclude this section by describing an algorithm for the problem 
 for d-hypergraphs in time 
.

figure c
Theorem 3.10
Given as input a d-hypergraph X on n vertices, the algorithm 
 enumerates all complexity-minimal automorphisms of X of weight at most k (plus possibly some more that do not have minimal complexity) in 
 time.

Proof
Clearly, the returned set contains only automorphisms of X of weight at most k. The fact that every complexity-minimal automorphism  of weight at most k is included follows from Lemma 3.7, by the same decomposition argument. The time bound also follows from Lemma 3.7. 

Remark 3.11
There is no FPT algorithm enumerating all graph automorphisms of weight at most k. For example, the complete graph 
 has 
  many such automorphisms.

However, by Proposition 2.9 each  with support size at most k can be written as a product of minimal-complexity automorphisms of X of weight at most k. Let S be the set of automorphisms returned by 
. Then every automorphism of X of weight at most k is in the subgroup  of automorphisms of X generated by S.

Hypergraphs with Bounded Color Class Size
In this section we consider b-bounded hypergraphs. That is, vertex colored hypergraphs (with hyperedges of unbounded size) and of maximum color class size b (considered as additional fixed parameter). We give an FPT algorithm for 
 for b-bounded hypergraphs. Here the problem is to find a weight at most k color-preserving isomorphism. Isomorphisms and automorphisms are required to be color-preserving in this section. But we will refer to them as simply isomorphisms and automorphisms, unless we need to make it explicit.

Given hypergraphs  and 
 and a partition 
 of V into color classes 
 with 
, our algorithm will compute in time 
 a color-preserving isomorphism from X to Y of weight at most k (if it exists). For a permutation  let

be the subset of color classes that intersect . Suppose the target of our search is an isomorphism  of weight at most k. Notice that each color class in  has at least two points in . Hence,  has at most k/2 color classes. Let . We will search for the color classes in  using the color-coding technique of Alon-Yuster-Zwick [13]. Consider the FKS family  of perfect hash functions . Each  defines a partition of the color classes 
 into  bags 
, where

Since  is a perfect hash family, there is some  that is good for  in the sense that the color classes 
 all hash under h to distinct labels in . That is, 
.

Let  be a hash function. Corresponding to h, for each  we define hypergraphs 
 and 
 as follows:


 

If the hash function h is good for the target isomorphism , then observe that the restriction of  to 
 is an isomorphism from 
 to 
 that moves only vertices of exactly one color class in 
 (the unique color class in 
).

We say that a color class 
 moves for a hyperedge  if there is some isomorphism 
 that moves only vertices of color class 
 and 
. We denote the set of all color classes 
 that move for e by .


 

The next claim shows that the size of  is bounded by 
.

Claim
For any hyperedge , at most 
 many color classes 
 move for e.

Proof of the claim
We will show that if more than 
 color classes move for e, then we can produce more than 
 many edges in 
, which is a contradiction.

Let  and suppose that 
 many color classes 
 move for e. Let 
, for , be corresponding isomorphisms such that 
 fixes all color classes in 
 except 
 and 
.

Let 
. Notice that 
 is a set of  distinct automorphisms of 
. For any subset  let 
 denote the product

in, say, increasing order of . Finally, we note that 
 are 
 distinct isomorphisms in 
. Furthermore, the images 
 of the hyperedge 
 under 
 are distinct for distinct choices of T because the subset  determines precisely which color classes among 
 move for e. Hence the total number of distinct edges in 
, generated as images 
 of 
 under the different 
 will be 
 which is impossible. 

Before proceeding to the FPT algorithm for 
 for the case of b-bounded hypergraphs, we introduce a definition that is important for the rest of the paper.

Definition 4.1
Let  and 
 be b-bounded hypergraphs with color class set 
 and let . For a subset 
 define the permutation 
 as


 
 

An isomorphism  from X to Y is said to be color-class-minimal, if for any set 
 with 
, the permutation 
 is not in . Color-class-minimal automorphisms are analogously defined.

We notice that all isomorphisms having minimal support are also color-class-minimal. An immediate consequence of Definition 4.1 is the following.

Proposition 4.2
Let  be a hypergraph with color classes 
. Each nontrivial automorphism  of X can be written as a product of nontrivial color-class-minimal automorphisms 
 of X, where the support color class sets 
, , are pairwise disjoint and form a partition of the support color class set .

We will use the following subroutine to compute isomorphisms between hypergraphs by building them color class by color class. Let 
 be a partition of the color class set 
 and let 
. Then we call a permutation  
-good for 
, if each bag 
 contains exactly one of the color classes in  (say 
) and 
 for .

figure d
In the following lemma we show how to use the above subroutine (Algorithm 4) to compute color-class-minimal isomorphisms that are 
-good.

Lemma 4.3
Let  be two b-bounded hypergraphs. Then the set returned by the algorithm 
 contains all color-class-minimal isomorphisms  from  to  that are 
-good for 
. Furthermore, Algorithm 4 runs in time 
.

Proof
First we note that Algorithm 4 is a recursive subroutine. If  is an isomorphism then in Line 5 the subroutine returns  and exits. Otherwise, it searches for all extensions  of  that are candidates for being a color-class minimal isomorphism.

Let  be such an isomorphism, and let 
 for some subset 
 of the color classes that intersect . We show by induction on the number of color classes in 
 touched by  but not by  that 
 finds . If this number is 0, we have , and Line 5 ensures that  is found. Otherwise, the color-class-minimality of  implies that . Thus, Line 8 will find a hyperedge  with 
. Since  is 
-good for 
, for any hyperedge  with 
, there is a bag 
 with 
 and a color class 
 such that 
. By the inductive hypothesis,  is found in the iteration of the inner loop where 
.

To show the bound on the running time, we first observe that the recursion tree has degree bounded by


 

and its depth is bounded by k/2. As 
, the overall running time is 
, as all steps in each recursive call can be implemented in O(N) time. 

In order to compute all color-class-minimal isomorphisms between two b-bounded hypergraphs  of support size exactly k, we augment Algorithm 4 by adding an initial branching over all , and going over all FKS hash functions , where each h defines a partition 
 of , and trying all -partitions 
. As the FKS family  is of size 
, and there are 
 -partitions of k, the run time incurs an extra 
 factor. This yields the algorithm 
 for computing all color-class-minimal isomorphisms from X to Y of support size exactly k.

Next, consider computing all nontrivial color-class-minimal automorphisms of a graph X of support size exactly k. Lemma 4.3 and Algorithm 4 are not directly applicable, because  is already an automorphism and a call to 
 will return only . However, the following minor modification suffices to find all nontrivial color-class-minimal automorphisms  of  that are 
-good for 
. Branch over all 
 and color classes 
, and over all permutations  with  such that 
, with a call to 
. The union of the automorphisms returned by these calls will be all color-class-minimal automorphisms of  that are 
-good for 
. This incurs an extra factor of 
 to the running time. In order to find all color-class-minimal automorphisms, as done for 
, we can add an initial branching over all , and all FKS hash functions , where each h defines a partition 
 of , and all -partitions 
. This yields the algorithm 
 for computing all nontrivial color-class-minimal automorphisms of X with support size exactly k.

Theorem 4.4
Given as input b-bounded hypergraphs X and Y on vertex set  and parameter , the set of all color-class-minimal isomorphisms from X to Y with support size exactly k can be computed in 
 time.

As each isomorphism having minimum support size k is also color-class-minimal, we obtain the following corollary as the main result in this section.

Corollary 4.5
Given as input b-bounded hypergraphs X and Y on vertex set  and parameter , there is an algorithm for 
 that checks if there is an isomorphism of weight at most k in  in time 
, and computes such an isomorphism if it exists.

Finding Automorphisms of Exact Weight k
In this section we show that the problem 
 of computing automorphisms of weight exactly k is solvable in  for hypergraphs having hyperedges or color classes of bounded size. We will first focus on hypergraphs having hyperedges of size bounded by d and show that the 
 problem for such graphs is FPT reducible to the 
 problem for k-bounded hypergraphs.

We stress that Schweitzer’s algorithm [9], for ordinary graphs, cannot guarantee finding isomorphisms of weight exactly k. This is because exact weight k isomorphisms (and automorphisms), unless of minimal complexity, may not get enumerated in either Schweitzer’s algorithm [9] or our generalization in Sect. 4 to bounded hyperedge size hypergraphs.

However, each weight k automorphism is expressible as a product of automorphisms enumerated by the search. We state this as a simple corollary of Proposition 2.9 and Theorem 3.10.

Corollary 5.1
Let X be a d-hypergraph and let S be the set returned by the algorithm 
. Then the subgroup  of  contains all automorphisms of X of weight at most k. In particular, G includes all automorphisms of weight exactly k.

Given the subgroup  of automorphisms of X, as stated in Corollary 5.1, our goal is to search for an element in G of weight exactly k. We now explain a simple group-theoretic procedure that will allow us to shrink G into a subgroup H that has orbits of size at most k. Moreover, if G has a weight k element then H too will have a weight k element in it. Treating the orbits of H as color classes of the hypergraph X, we obtain a k-bounded hypergraph in which we can search for an exact weight k automorphism by building on the algorithms (for b-bounded hypergraphs) in Sect. 4. With this overview in mind, we proceed to the details.

Shrinking Orbits While Preserving Small Weight Permutations
Let  be a subset of permutations and  be a parameter. Recall that  is to search for an exact weight k permutation in the group  generated by A. Our aim is to reduce the instance (A, k) of the  problem to an instance (B, k), where B is a set of permutations such that  is a subgroup of , the orbits of  are of size at most k and  contains an exact weight-k element if and only if  does.

Lemma 5.2
There is a polynomial-time algorithm that given as input an instance (A, k) of , with  and , outputs an instance (B, k) with 
 such that every orbit of 
 has size bounded k and


 

Moreover, for every  with  there is a 
 with 
.

Proof
The reduction is an application of the following simple group-theoretic observation.

Claim
Let  be a G-orbit of size more than k and let u be any point in . Then, for any element  of support size , there is an element 
 with 
.

To prove the claim, we only have to consider the case that , since otherwise 
. Note that  is nonempty since  and . Let v be a point in  and let  such that 
. Then it follows immediately that the permutation 
 belongs to 
 and has the same support size as .

The claimed reduction is given by the following simple algorithm that stabilizes points in orbits of size larger than k until no such orbits exist any more.

figure e
The correctness of the reduction is a direct consequence of the claim above. Further, the reduction is polynomial-time as the Schreier-Sims algorithm has polynomial running time and the while loop runs for at most n iterations. 

The Algorithm for Exact Weight-k Automorphisms
Lemma 5.3
Let  be a hypergraph with hyperedges of size bounded by d. In FPT time we can reduce the search for an exact weight k automorphism of X to finding an exact weight k automorphism of X that is vertex colored with k-bounded color classes.

Proof
Let  be a hypergraph with hyperedges of size bounded by d. Applying Theorem 3.10, we can enumerate the set B of all complexity-minimal automorphisms of X that are of weight at most k. Clearly, any weight at most k automorphism (including the exact weight k ones) of X is in the subgroup  of . Next, we can apply Lemma 5.2 to the permutation group G and replace it by the subgroup 
 whose orbits are of size at most k such that if G has an exact weight k automorphism then 
 also has an exact weight k automorphism.

We can designate the orbits of 
 (which are all of size at most k) as color classes of X to obtain a k-bounded hypergraph. I.e. we assign different colors to vertices that are in different orbits of 
 and consider only color-preserving automorphisms. Clearly, the exact weight k automorphisms of X that survive in 
 are also color-preserving automorphisms of this k-bounded colored version of hypergraph X. 

We now turn to the problem of checking if a b-bounded hypergraphs  has an exact weight k automorphism. The algorithm of Theorem 4.4 does not directly solve this because exact weight k automorphisms of X need not be color-class-minimal. However, in the following theorem we show how to adapt the algorithm.

Theorem 5.4
There is an algorithm for 
 for b-bounded hypergraphs  that decides in time 
 if there is an exact weight k automorphism of X and computes such an automorphism if it exists.

Proof
We apply the algorithm of Theorem 4.4 to enumerate the set A of all color-class-minimal automorphisms of X of weight at most k in time 
. By Proposition 4.2, we know that for any exact weight k color-preserving automorphism  of X there is an  such that  is expressible as

where each 
 is a color-class-minimal automorphism of X of weight at most k and 
, for , forms a partition of . I.e. each candidate 
 is in the enumerated set A. Let 
, where  (because in all only k vertices are in ).

We will again use color coding [13] to search for the 
. Let  be the FKS family [14] of perfect hash functions , where m is the total number of color classes in X, and , as above, is the number of color classes in . For each  define the bags 
. By the property of the FKS family, there is some h such that for , each bag 
 contains exactly one color class from  (namely 
). We require the following combinatorial fact.

Fact 5.5
The total number of partitions of the set 
 into  sets is bounded by 
 and we can cycle through all such partitions in time 
.

One of the 
 many partitions, say 
 of 
 will be the partition such that 
. Assume we are considering this partition 
. Now, let A denote the set of all color-class-minimal automorphisms of X that can be enumerated applying the algorithm in Theorem 4.4.

In  time we partition A into subsets 
, with , defined by

We can try all partitions 
 (there are at most 
 many of them) and for each partition we look for an element of weight exactly 
 in 
 in time 
.

Clearly, by Theorem 4.4, if there exists a color-preserving exact weight k automorphism of X, then for some  and some partition the search will succeed. For the running time, the extra factor is 
. This completes the proof. 

Corollary 5.6
There is an algorithm for 
 for d-hypergraphs X that decides in time 
 if X has an exact weight k automorphism, and computes such an automorphism if it exists.

Proof
By Lemma 5.3 we can transform  into a hypergraph with k-bounded color classes in time 
 such that X has an exact weight k automorphism if and only if there is an exact weight k color-preserving automorphism of X. Hence, we can apply the algorithm of Theorem 5.4 to solve the problem. The running time bound is obtained by putting  in Theorem 5.4 and bounding k! by 
. 

Finally, for the general case of hypergraphs of unbounded edge size it is interesting to note that we have an 
 algorithm for the problems 
 and 
. This can be understood as partial evidence that neither is -hard, and we leave the problem of finding FPT algorithms for them open.

Corollary 5.7
There are 
 algorithms for 
 and 
 in the case of general hypergraphs.

Proof
Given a hypergraph X as input, we can first compute a generating set for  in polynomial time with polynomially many calls to the GI oracle [15, 16]. Then using Lemma 5.2 we can reduce the instance to a k-bounded hypergraph to which the algorithms of Corollary 4.5 or of Theorem 5.4, can be applied to solve 
 and 
, respectively. 

Isomorphisms of Exact Weight k
In this section, we show that 
 for d-bounded hypergraphs is fixed parameter tractable.

In Sect. 5 we showed that 
 is in , using an “orbit shrinking” technique which reduced the problem to finding exact weight k color-preserving automorphisms in hypergraphs of k-bounded color class size. For 
 we will need a more sophisticated “orbit shrinking” technique.

We first give a brief overview of the algorithm and explain why the orbit shrinking required is more involved. Let (X, Y) be a pair of d-hypergraphs and suppose  is an isomorphism of weight at most k returned by the algorithm of Theorem 3.9. If  has weight exactly k we are already done. Otherwise, as , any isomorphism of weight exactly k is of the form , where  is of weight at most 2k. Note that  and  can intersect. The points in the intersection are of two types: points where  agrees with 
 (which will be fixed by ) and points where  disagrees with 
 (which will be in ). The remaining points in  will be fixed by . If there are r points of the first type and s points of the second type, then the  that we seek with the above properties is of exact weight .

Based on the above overview, we formulate a constrained automorphism problem that we wish to solve in .

: Let  be a d-hypergraph, k be a parameter, and a list constraint 
 (where d and r are treated as additional fixed parameter). The problem is to decide if there is a weight exactly k automorphism  that satisfies the equality and inequality constraints: namely, 
 for 
 , and 
 for 
. And if so, to compute such an automorphism .

Thus, in order to find  such that , in 
 time we can cycle through all choices of subsets of the first and second types described above. Each pair of subsets gives us an instance of 
 which we will show is in . Broadly, the algorithm for 
 has two steps:

1.
A polynomial-time reduction that transforms, by an orbit shrinking method, the given d-hypergraph X into a bounded color class instance , where the color classes in  are of size at most f(k), for some function f of the parameter k. The orbit shrinking will ensure that X has a weight-k automorphism satisfying the constraints iff  has a color-preserving weight-k automorphism satisfying the constraints.

2.
An  algorithm for 
 for the bounded color class instance .

 for Bounded Color Class Hypergraphs
Input instances of 
 are vertex-colored hypergraphs  with vertex set partitioned into color classes 
 of size at most b along with constraints  (the equality and inequality constraints). The problem is to find an exact weight k color-preserving automorphism satisfying the constraints.

We will adapt our algorithm for exact weight k automorphisms of bounded color class hypergraphs of Sect. 4.

Definition 6.1
Let  be a vertex-colored hypergraph with color classes 
 and L be the constraint set, defining an instance of 
.

For a subset 
, we say that a color-preserving automorphism  
-satisfies the constraints L if for every constraint  
.

For the sequel, we recall the notation and definition from Definition 4.1. The next lemma is analogous to Proposition 4.2, allowing the decomposition of a color-preserving automorphism into color-class-minimal automorphisms with a corresponding partition of the constraint set L.

Lemma 6.2
Let  be a hypergraph with color classes  with L as constraints set for the 
 instance. Let 
. Then there is a non-trivial color-preserving automorphism  of X with 
 satisfying L if and only if 
 can be partitioned into  subsets 
 and the constraints can be partitioned into  subsets 
 such that for each  there is a color-class-minimal automorphism 
 of X with 
 such that 
-satisfies 
. The constraints in 
 are 
-satisfied by . Moreover, 
 can be chosen such that 
 for .

Proof
To show the forward direction, let  with 
 satisfying L. Include all constraints into 
 that are 
-satisfied by . For every constraint 
 we have 
. Hence, 
 is 
-satisfied by .

We show by induction on  that for  which -satisfies 
, we can partition  into 
 and the constraints 
 into 
 such that 
 is a color-class-minimal automorphism of X that 
-satisfies 
, for . If  itself is color-class-minimal, which always happens if , we are done: We can set , 
, and 
. Otherwise there is a non-empty  such that 
. This implies 
. Note that 
 and thus 
. Next, we partition the constraints of 
 into two subsets 
 and 
: If a constraint of 
 is -satisfied by , we include it in 
; otherwise we include it in 
. In the former case, this constraint is also -satisfied by , as 
 for all . In the latter case, the clause must be -satisfied by , and consequently also by 
, as 
 for all . Thus 
 is -satisfied by , and 
 is 
-satisfied by 
; hence, we can apply the induction hypothesis to both  and 
. This yields partitions of  and 
 as well as  and 
, which we can combine to obtain the desired partitions of  and 
.

To show the other direction, let 
 be a partition of 
, let 
 be a partition of L, and let 
 be color-preserving automorphisms of X with 
 such that 
 is 
-satisfied by 
 for , and 
 is 
-satisfied by . Consider the automorphism 
. As 
 for , the following definition of  is equivalent and well-defined:


 
 

Thus, 
 and 
. Moreover, any constraint in L is in a unique 
. If , this constraint is 
-satisfied by 
 and thus also by , as 
 for all 
. It remains to consider the case . Then the constraint is 
-satisfied by  and thus also by , as 
 for all 
. 

By Theorem 4.4, for b-bounded hypergraphs we can compute all color-class-minimal automorphisms of X of weight exactly k in 
 time. We use the algorithm of Theorem 4.4 as a building block for the following algorithm which searches for an exact weight k automorphism of X, where the search is essentially brute-force facilitated by color coding [13] (as already explained and used in Sect. 4).

figure f
Theorem 6.3
Given a vertex-colored b-bounded hypergraph  as input with constraint set L and , the algorithm 
 computes an exact weight k color-preserving automorphism of X that satisfies L in 
 time, if it exists.

Proof
If the algorithm returns 
, we know 
 and 
. As these sets are disjoint, we have 
, and Lemma 6.2 implies that  satisfies L.

We next show that the algorithm does not return  if there is an exact weight k automorphism  that satisfies L. By Lemma 6.2, we can partition  into 
 and L into 
 such that, for , the permutation 
 is a color-class-minimal automorphism of X that 
-satisfies 
. Now consider the iteration of the loop where the hash function h is injective on  (which must exist in the FKS hash family). Now let 
 be a function with 
 if 
; such an 
 exists because h is injective on . In the loop iterations where 
 and the partition of L into 
 is considered, the condition on line 10 is true (at least) with 
, so the algorithm does not return .

Line 5 can be implemented by using the algorithm of Theorem 4.4 which runs in 
 time which also bounds 
. The FKS hash family 
 has size 
. The inner loops take at most 
, 
 and 
 iterations, respectively. Together, this yields a runtime of 
. 

Orbit Shrinking for 
 Instances
Our  algorithm for 
 requires some additional permutation group theory. We recall some definitions from Dixon and Mortimer’s text [9].

Let  be a permutation group. The group G partitions V into orbits: 
. On each orbit 
, the group G acts transitively.

A subset 
 is a block of the group G if for all  either 
 or 
. Clearly, 
 is itself a block, and so are all singleton sets. These are trivial blocks. Other blocks are nontrivial. If G has no nontrivial blocks it is primitive. If G is not primitive, we can partition 
 into blocks 
, where each 
 is a maximal nontrivial block. Then the group G acts primitively on the block system 
. Such a block system for G is called a maximal G-block system. In the action of G on a block system, a permutation  maps 
 to 
. If  is given by a generating set A then orbits of G and a maximal block system for each orbit of G can be computed in  time [10].

The following two theorems give us useful information about the structure of a primitive permutation group  when G has elements of small support. Recall that the alternating group  is the subgroup of all even permutations:


 

As  is an index-2 subgroup of , if , for a permutation group G, then either  or .

Theorem 6.4
[10, Theorem 3.3A] Suppose  is a primitive subgroup of . If G contains an element  such that  then G contains . If G contains an element  such that  then .

Theorem 6.5
[10, Theorem 3.3D] If  is primitive with  and contains an element  such that  (for some ) then 
.

The following lemma implies that the alternating group in a large orbit survives fixing vertices in a smaller orbit.

Lemma 6.6
Let 
 be a permutation group such that 
 is an orbit of G, and 
. Let 
 denote G restricted to 
. Suppose 
 and 
. Then for some subgroup H of 
, the group G contains the product group 
. In particular, the pointwise stabilizer 
 contains the subgroup 
.

Proof
Every element  of G can be expressed as 
, where 
. Let 
 denote the surjective projection homomorphism. Then


 

Let 
. Since 
 is a normal subgroup of G, K is a normal subgroup of 
. As 
, 
 is simple, and the only nontrivial normal subgroup of 
 is 
, it follows that either  or 
.

Case 1:
Suppose . In this case 
 is trivial. Thus, 
 is an isomorphism from G to 
 implying that 
. As 
, this contradicts the assumption that 
.

Case 2:
Suppose 
. Consider the other surjective projection homomorphism 
. Then 
, and 
 is a normal subgroup of 
. We show that G contains the product group 
 as claimed by the lemma.

Consider any pair 
. We can write it as  and note that by definition 
 and 
. As both 
 and 
 are subgroups of G, it follows that .


Remark 6.7
In a special case of Lemma 6.6, suppose 
 such that 
 is an orbit of G, 
 }, and 
. As 
 is implied by this assumption, the consequence of the lemma follows.

The effect of fixing vertices of some orbit on other orbits of the same size depends on how the group relates these orbits to each other.

Definition 6.8
Two orbits 
 and 
 of a permutation group  are linked if there is a group isomorphism 
 with 
. (This happens if and only if both 
 and 
 are isomorphic to 
.)

Proposition 6.9
Two orbits 
 and 
 of a permutation group  are linked if and only if both 
 and 
 are isomorphic to 
.

Proof
Suppose 
 and 
 are linked orbits of G. By definition, there a group isomorphism 
 with 
. The mapping  is a group isomorphism 
 to 
. Conversely, suppose 
 is isomorphic to 
 for . Then 
. Let

be an isomorphism and write 
. Since  is onto, its two restrictions 
 such that 
, for , are both onto homomorphisms and hence isomorphisms (since the two groups 
 have the same cardinality). Putting it together, the mapping 
 (applied right to left) is an isomorphism from 
 such that

Hence, the orbits 
 and 
 are linked. 

We next show that two large orbits where the group action includes the alternating group are (nearly) independent unless they are linked.

Lemma 6.10
Suppose , and 
 and 
 are two orbits of G such that 
. Further, suppose 
 for . Then either 
 and 
 are linked in G, or 
 contains the product group 
.

Proof
Without loss of generality, we assume that 
. Thus, we can represent any element of G as a pair (x, y) where 
 and 
.

Let 
 denote the surjective projection homomorphisms, for . Further, let 
 and 
. It is easily checked that H is a normal subgroup of 
. If 
 then 
, because the only nontrivial normal subgroup of 
 is 
 for 
. If 
 then 
 as 
 is simple for 
. Similarly, K is a normal subgroup of 
 and hence 
.

Case 1  (the case  is similar).:
Then 
 is trivial, and 
 is an isomorphism from G to 
, implying that 
. By the basic isomorphism theorem, we have 
 
, and hence 
. But G is isomorphic to 
 which, by assumption, is either 
 or 
. Hence G has only three possible normal subgroups: isomorphic to 
, isomorphic to 
, or isomorphic to . Since 
 is a normal subgroup of G, it follows that 
 is one of these three. In the first two cases, 
. That implies 
, which is a contradiction. Thus, 
, which implies that 
 and 
 are linked in G.

Case 2 
 (the case 
 is similar).:
Consider any pair 
. Since 
 there is a 
 such that . Now, we can write 
, and note that  and 
 by assumption on H. Therefore,  implying that 
, and thus 
.

Case 3:
Finally, we are left with the possibility that 
, 
, 
 and 
. In this case G contains 
.


The next ingredient for our algorithm is the observation that when there are two linked orbits where the group action includes the alternating group, fixing a vertex in one orbit is equivalent to fixing some vertex of the other orbit.

Lemma 6.11
[10, Theorem 8.2A] Let  and suppose . If  is a group automorphism then there is a permutation  such that

Corollary 6.12
Let 
 and 
 be two linked orbits of a permutation group  with 
 and 
. Then for each 
 there is a 
 such that 
.

Proof
Let 
 be the group isomorphism witnessing that 
 and 
 are linked. Thus, every element of 
 is of the form , and every element  of G is of the form , where  is essentially  restricted to the remaining points 
.

Let 
. Both 
 and 
 are either  or .

Fix a bijection 
. This yields a group isomorphism from 
 to 
 defined through conjugation by :


 

Hence, 
, for all 
 is an automorphism of 
. Now, by Lemma 6.11 there is a permutation 
 such that 
. Let 
. Notice that 
 is a bijection and we have

It follows that for any element , if 
 for 
 then 
 is also fixed by . This proves the lemma. 

The next two lemmas are tailored for proving correctness of the algorithm. Let  be a permutation group and  be the set of all orbits of G. For , let  be a maximal G-block system in .

Lemma 6.13
Let  be a permutation group and  be the set of all orbits of G with the following properties:

1.
For every orbit 
, suppose either 
 contains 
 or 
. Furthermore, for every orbit 
 and every block 
 suppose .

2.
Let  be an orbit of G such that  is of maximum cardinality. Suppose 
.

3.
Suppose .

Let 
 and let


 

Then the point stabilizer subgroup 
 of G is such that 
 still contains .

Proof
Let 
 and let 
 be any nontrivial orbit. Then 
. Let  and 
. As a first step, we show the following claim.

Claim
There is some nonempty subset 
 such that the point stabilizer subgroup 
 still contains .

Proof of the Claim
We consider two cases:

Case 1: 
::
Then by the given condition we have 
 which means 
. Since 
 we have


 
 

Therefore, by Lemma 6.6 applied to 
 the point stabilizer 
 still contains . We can take 
 in this case.

Case 2: 
::
Then, as 
 contains 
, we can apply Lemma 6.10 as follows: Since 
, the orbits  and 
 are not linked. Therefore, it follows from the lemma that 
 contains 
 which, in turn, contains . Hence, the point stabilizer of 
, 
 contains . Now  is transitive on  since . Therefore, 
 has  as an orbit. On the other hand, each orbit 
 of 
 that is contained in 
 is contained in some block 
. Therefore, 
. Hence,


 
 

(4)

If there are no nontrivial orbits in 
 of the group 
 then 
 and we can take 
. Otherwise, let 
 be a nontrivial orbit of 
. and consider the action of 
 on the union 
. Since 
 (by the above equation), applying Lemma 6.6 to the group 
 and the union of orbits 
 it follows that the point stabilizer subgroup 
 contains .

Thus, 
 contains .

Now, we note that  is still an orbit of 
 (as it contains ). Since all orbits in 
 are linked to , each orbit 
 remains an orbit of 
 that is linked to . Thus, we can see that the group 
 satisfies all the conditions of the lemma statement. Hence, if 
 has any nontrivial orbits O not in 
 then by applying the above claim to 
 we obtain a nonempty subset 
 such that 
 contains . Applying this argument repeatedly it follows that 
 contains . 

Lemma 6.14
Let 
 be a permutation group such that  is an orbit of G. Let 
 be a maximal block system of  with 
. Suppose K is a subgroup of G such that . Let  and suppose 
 
. Consider any subcollection I of s blocks 
 and let 
. Then the point stabilizer subgroup 
 has the remaining blocks 
 as an orbit on which it acts as the alternating group .

Proof
Since  and , K is transitive on  and 
 is a maximal block system for K as well since  is primitive for .

Let 
. Consider the set stabilizer of : 
. Since 
 setwise stabilizes , 
 also setwise stabilizes both 
 and 
. Now, let 
 denote the subgroup of K that pointwise stabilizes 
. Notice that 
 is also the subgroup of 
 that pointwise stabilizes 
. We have the following subgroup chain:

Since , 
 contains the subgroup of  that pointwise stabilizes 
. For , the point stabilizer subgroup of  that fixes any s points is . Thus, 
 and hence 
 has 
 as an orbit and 
 contains 
. We now apply Lemma 6.6 to the group 
. By assumption 
 
. Therefore, we have


 
 

where the first inequality holds as  and the last inequality holds as 
 contains 
. Now, as 
, by Lemma 6.6 the point stabilizer 
 contains 
 as orbit and, moreover, 
. 

We are now ready to present the parameterized algorithm for 
. Consider an input instance d-hypergraph X with a list L of constraints. The algorithm first computes the permutation group G generated by all complexity-minimal automorphisms of weight at most k invoking 
. If X has an exact weight k automorphism satisfying the constraints L then it is in G. As mentioned at the beginning of Sect. 6.2, the algorithm works by shrinking the orbits of G (which makes the group itself shrink) until all orbits are of size at most 
 
. Treating the orbits as color classes, we have an instance of 
 for bounded color classes which can be solved using 
, where 
 
. The group-theoretic machinery, specifically Theorems 6.4 and 6.5, and Lemma 6.14, ensures that the algorithm can carry out the orbit shrinking so that a color-preserving automorphism satisfying the constraints survives.

figure g
Theorem 6.15
Algorithm 7 correctly solves 
 in time 
, where 
 
.

Proof
Suppose there is some  of exact weight k that satisfies L.

By Theorem 3.10, the algorithm 
 (line 4) returns a set of 
 many automorphisms of X that includes all minimal-complexity automorphisms of weight at most k. By Proposition 2.9, the automorphism  can be decomposed as a product of minimal-complexity automorphisms of weight at most k, which implies .

We will show that whenever the algorithm shrinks G (by shrinking an orbit of G), some exact weight k automorphism of X that satisfies L survives. For the shrinking in line 12 we need to consider two cases. If  is an orbit with block-size  for some (and thus each) , then none of the blocks in  is moved by . Indeed, if  moves one block, it would have to move at least one more block, which implies that , contradicting the assumption. On the other hand, if 
 and  does not contain the alternating group, then Theorems 6.4 and 6.5 imply that the primitive group  has no non-trivial element that moves at most k elements of . In particular, it means that  setwise stabilizes every  and thus survives the shrinking of G in this step.

We now consider the other shrinking step for G, which occurs in line 23. Note that this can only happen if 
 because of the if-condition in line 16. As the algorithm has exited the repeat-until loop, it implies that 
.

Claim
The point stabilizer 
 still has 
 as orbit and 
 contains 
.

The above claim is an immediate consequence of Lemma 6.13.

Claim
The point stabilizer group 
 has a single nontrivial orbit 
 of size 
.

For a proof of the above claim, consider

which is the set of all blocks in 
 that intersect T. In all there are at most |T| many such blocks. I.e. . Let 
. Then . We now apply Lemma 6.14 to the group 
, where 
 is the union of the remaining orbits in 
. The subset  to be pointwise stabilized, as in the lemma, is the points of the blocks in . Here , , and 
. Hence,

clearly holds. Therefore, by Lemma 6.14 the point stabilizer 
 contains the alternating group acting on the remaining 
 
 blocks . That forms the single orbit 
 of size  as claimed.

Claim
If G has an exact weight k automorphism satisfying the constraint set L then for any block 
 the set stabilizer 
 also has an exact weight k automorphism satisfying the constraint set.

Let  be an exact weight-k automorphism satisfying L. Since 
 has 
 
 blocks, there is a block 
 such that 
 for all 
. Since 
 is an H-orbit, there is an automorphism  such that 
. Now, consider the automorphism 
. We observe as claimed that:

 is of exact weight k as it is a conjugate of  and conjugation preserves the support size of the permutation.

Since  it pointwise stabilizes all elements of T. Therefore, 
 for all . In particular, for constraints  we have 
 and for constraints  we have 
. Thus, each constraint in L is satisfied by .

Therefore, we have shown that as long as there is an orbit of G of size more than 
 
, the while-loop of the algorithm will be executed, which will result in the shrinking of at least one orbit while preserving the existence of an element of weight exactly k satisfying the constraints in L. Therefore, the while-loop will be exited within at most |V| steps with a group G of orbit size bounded by 
 
. As before, we interpret the orbits as vertex color classes and we can invoke ColorConsGA (Theorem 6.3) to solve the exact weight k problem in time 
 time, where 
 
 

The group-theoretic computation in Lines 19, 20 and 23 involve computing the point stabilizer subgroup of a permutation group which is polynomial-time bounded using the Schreier-Sims algorithm [10, 17].

To complete the running time analysis, we note that 
 on line 4 takes 
 time. As all operations in the loops can be implemented in  time the claimed time bound follows. 

Putting it together, we obtain the FPT algorithm for the 
 problem for d-hypergraphs in the following corollary.

Corollary 6.16
For d-hypergraphs 
 can be solved in 
 time.

Proof
As explained in the beginning of this section, 
 can be solved with 
 subroutine calls to an FPT algorithm for 
 where the constraints L have at most k pairs. Now, applying 
 of Theorem 6.15 to each of these instances, we obtain an algorithm of run time 
, where 
 
 
 for . Since 
, we have


 

Hence, the run time of the algorithm is 
. This completes the proof. 

Concluding Remarks
We have studied the complexity of several parameterized instances of PermCode related to the Graph Automorphism and Isomorphism problems. In particular we have shown that for hypergraphs, when either the edge size or or the color class size is taken as an additional parameter, 
 and 
 are in FPT, thus extending Schweitzer’s result to d-hypergraphs and to the exact case. It would be interesting to obtain faster algorithms for these problems.

For hypergraphs (of unbounded edge size) are the problems 
 and 
 fixed parameter tractable? We could only show these problems are in the class FPT
.