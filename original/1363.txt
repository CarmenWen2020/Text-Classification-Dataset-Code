Let G be an n-node and m-edge positively real-weighted undirected graph. For any given integer , we study the problem of designing a sparse f-edge-fault-tolerant (f-EFT) -approximate single-source shortest-path tree (-ASPT), namely a subgraph of G having as few edges as possible and which, following the failure of a set F of at most f edges in G, contains paths from a fixed source that are stretched by a factor of at most . To this respect, we provide an algorithm that efficiently computes an f-EFT -ASPT of size O(fn). Our structure improves on a previous related construction designed for unweighted graphs, having the same size but guaranteeing a larger stretch factor of , plus an additive term of . Then, we show how to convert our structure into an efficient f-EFT single-source distance oracle, that can be built in 
 time, has size 
, and in 
 time is able to report a -approximate distance from the source to any node in . Moreover, our oracle can return a corresponding approximate path in the same amount of time plus the path’s size. The oracle is obtained by tackling another fundamental problem, namely that of updating a minimum spanning forest (MSF) of G following a batch of k simultaneous modification (i.e., edge insertions, deletions and weight changes). For this problem, we build in 
 time an oracle of size 
, that reports in 
 time the (at most 2k) edges either exiting from or entering into the MSF. Finally, for any integer , we complement all our results with a lower bound of 
 
 to the size of any f-EFT -ASPT with  and 
 
, that holds if the Erdős’ girth conjecture is true.

Introduction
Let  be a positively real-weighted undirected graph of n nodes and m edges. A shortest-path tree (SPT) of G rooted at a distinguished source vertex, say s, is one of the most popular structures in communication networks. For example, it can be used for implementing the fundamental broadcasting operation. However, the SPT, as any tree-based topology, is highly sensitive to edge/vertex failures, which cause the undesired effect of disconnecting sets of vertices from the source.

Therefore, a general approach to cope with this scenario is to make the SPT resistant against a given number of component failures, by adding to it a set of suitably selected edges from the underlying graph, so that the resulting subgraph (also referred as structure in the following) will still contain a SPT of the surviving network. If we prepare ourselves to resist against a set of at most f failing edges in G, then the corresponding structure will be named an f-edge-fault-tolerant (f-EFT) SPT. Unfortunately, even if ,  additional edges may be needed, also in the case in which 
 [12]. Thus, to sparsify such a structure, it makes sense to resort to -approximate shortest paths from the source, i.e., paths that are stretched at most by a factor , for any possible set of failures that has to be handled (see Fig. 1 for an example).

In this paper, we show how to buildFootnote 1 an efficient structure of this sort. Moreover, we show that it is possible to transform such a structure into an efficient oracle that will allow to quickly switch to the corresponding approximate replacement paths (or just to report their length).

Fig. 1
figure 1
a A graph G on n vertices and 
 edges. The edges between vertices in X weight 0, while those incident to the vertices in Y have weight 
 
. Each of the sets Y and Z contains  vertices and  induces a complete bipartite subgraph. The edges of an SPT of G from s are shown in bold. The only 1-EFT SPT H of G is G itself since, for , an SPT of 
 contains the unique edge 
 of weight i together with all other edges incident to z. b A 1-EFT 
 
-approximate SPT. The bipartite subgraph can be sparsified by only selecting the edges incident to the two white vertices (one from Y and one from Z). In general, if we want a f-EFT 
 
-approximate SPT, we can still sparsify the bipartite subgraph by selecting all the edges incident to f vertices from Z and f vertices from Y

Full size image

Related Work
In the recent past, several single and multiple edge/vertex-fault-tolerant approximate SPT (ASPT) structures that offer different trade-offs between the guaranteed stretch and the overall size of the structure have been devised (see [39] for a survey). More formally, we say that a spanning subgraph H of G is an f-EFT -ASPT if it satisfies the following condition: For each set of edges  of size at most f, all the distances from the source s in the subgraph  are at most  times longer than the corresponding distances in . If a further additive distortion  is also allowed to the distances, then the structure will be named f-EFT -ASPT. Similar definitions can be given for the vertex-fault-tolerant (VFT) case and for unweighted graphs (in this case we use the acronym ABFS instead of ASPT to stress the fact that we are dealing with unweighted graphs in which SPTs coincide with breadth-first search trees).

A natural counterpart of fault-tolerant SPT structures are fault-tolerant -stretched single-source distance oracles (-SSDO in the following), i.e., compact data structures that can be built with a low preprocessing time, and that are able to quickly return -approximate distances/paths from the source following a set of failures. Converting a fault-tolerant SPT into a corresponding SSDO with the very same stretch, and additionally having a small size and a fast query time, is a quite natural process, because of its practical usage: computing the alternative post-failure distances/paths on the structure may indeed be very time consuming. However, such a conversion process is not straightforward, in general, since it requires to exploit distance-related information that are instead implicit in the underlying structure, and this has to be done by optimizing the trade-off between the size and the query time of the oracle.

Turning back our attention to fault-tolerant SPT structures, their study originated in [6], where the authors showed the existence of a 1-VFT -ABFS with size 
 
, for any , and of a 1-VFT 3-ASPT having size . These results were obtained as byproducts of a 1-VFT 3-SSDO and a 1-VFT -SSDO of the same size, both having a distance (resp., path) query time of O(1) (resp., proportional to the path’s size). Later, in [12], the authors showed the existence of a 1-E/VFT -ASPT of size 
 
, for any  (without providing a corresponding oracle). In [11], the authors designed a -SSDO of size 
 and query time , for any . For the special case , they also provided a simpler construction improving the query time to O(1).

Concerning unweighted graphs, Parter and Peleg [41] presented a 1-E/VFT Breadth-First Search tree (BFS) of size , where  denotes the eccentricity of the source vertex s in G, namely a structure containing exact shortest paths from the source after a single edge/vertex failure. In the same paper, the authors also exhibit a corresponding lower bound of 
 for the size of a 1-E/VFT BFS. Then, in [42], the same authors presented a set of lower and upper bounds to the size of -ABFS. More precisely, they showed that for every , there exists a graph G and a source vertex  such that a corresponding 1-EFT -ABFS requires 
 edges, for some function . Moreover, they also constructed a 1-EFT (1, 4)-ABFS of size 
. Finally, assuming at most  edge failures can take place, they showed the existence of (i) an f-EFT -ABFS of size O(fn), and (ii) an f-EFT -ABFS of size 
. These structures will be exactly our touchstone in this paper, since they are the only ones concerned with multiple-edge-failure single-source shortest paths.

Our Results
In this paper, we present the following main results:

An f-EFT -ASPT of size O(fn) that is able to handle the failure of any set  of at most f edges. This considerably improves w.r.t. to its direct competitors, namely the structures presented in [42]: our structure has a size that is never worse, a lower stretch, works on weighted graphs, and handles an arbitrary (i.e., even non-constant) number of failures. Moreover, our construction is simpler and can be computed quickly in  time, where  is the inverse of the Ackermann’s function.

A corresponding f-EFT -SSDO of size 
, that can be built in 
 time, has a distance query time of 
, and is also able to report the corresponding path in the same time plus the path’s size. Moreover, if one is willing to use 
 space, then our oracle can handle any number of edge failures (i.e., up to m).

Interestingly enough, the former result is obtained by posing a simple yet surprising relationship between the structure of the replacement paths and the minimum spanning forest (MSF) of an ad-hoc auxiliary graph. This approach is also useful to develop the latter result, that is indeed obtained through an efficient updating of an MSF after that a batch of any number k of edge modifications (i.e., edge insertions, deletions and weight changes) are simultaneously performed. For this problem indeed we provide the following result:

a (multiple-update) MSF sensitivity oracleFootnote 2 of size 
, that can be built in 
 time, and is able to report in 
 time the (at most 2k) edges either exiting from or entering into the MSF. As a result of independent interest, it is worth noticing that our oracle can be used to efficiently maintain a MSF under relatively short sequences of non-simultaneous updates. Indeed, observe that a sequence 
 of updates can be managed through h sequential queries to the oracle, where the i-th query will involve the modifications to the starting MSF induced by the batch of the first i updates. This way, we spend 
 time to handle each single update. Hence, as the fastest long-standing algorithm for the classic (and clearly more general) fully-dynamic MSF problem has a worst-case cost of  per update [25], it follows that for , our oracle should be preferred, since it will manage each update in  time. Notice also that a comparison with other known online/offline algorithms for maintaining an MSF that are more efficient in an amortized sense, like for instance those given in [24, 33, 34], is unfeasible. Indeed these algorithms need to start from an empty graph to guarantee their bounds or they need long sequences of updates to become efficient. Thus, when starting from an arbitrary graph, as it happens in our setting, a single update operation could even cost them  time!

Finally, for any integer , we prove a lower bound of 
 
 on the size of any f-EFT -ASPT with  and 
 
, that holds if the Erdős’ girth conjecture is true. Our lower bound shows that, in contrast to the single-edge failure case, it is not possible to obtain a stretch arbitrary close to 1 with size 
Footnote 3 when the number of faults is more than . We look at the problem of understanding whether this can be done for constant  as an interesting open problem.

Other Related Work on Fault-Tolerant Sourced Structures/Oracles
A vast body of literature deals with structures and oracles that tolerate single/multiple failures in single-source shortest paths. An early work on the topic is [37], where the authors were concerned with the computation of best swap edges (w.r.t. several swap functions) for the failure of each and every edge in a SPT. As a by-product of their results, it can be easily seen that by adding to a SPT the (at most)  best swap edges w.r.t. to the new distance from s to the root of the subtree disconnected from s after an edge failure, then a 1-EFT 3-ASPT is obtained. Interestingly, such a structure can be easily converted into a 1-EFT 3-SSDO of size O(n) and query time O(1). In [21], the authors faced the special case of shortest-path failures, in which the failure of a set F of at most f adjacent edges along any source-leaf path has to be tolerated. They proposed an f-EFT -ASPT of size 
, where |F| denotes the size of the actual failing path, and  is a parameter of choice. Notice that this result is subsumed by ours. Moreover, they also provided a conversion to a corresponding oracle, and for the special case of , they gave an ad-hoc solution of size  and with stretch 3. For directed graphs with integer positive edge weights bounded by M, in [28] the authors showed how to build efficiently in 
 time a randomized 1-EFT 1-SSDO of size 
 and with O(1) query time, where returned distances are exact w.h.p., and  denotes the matrix multiplication exponent.

Concerning unweighted graphs, in [12] the authors showed that an ordinary (i.e., non fault-tolerant) -spanner (i.e., where distances/paths between arbitrary pairs of nodes are at most -stretched) of size O(g(n)) can be used to build a 1-EFT (resp., VFT) -ABFS of the same size (resp., of size ). This result is useful for building sparse 1-VFT -ABFS structures by making use of the vast literature on additive -spanners (e.g., [7, 18]). In [38], Parter presented a 2-EFT BFS having 
 edges, which is tight.

Another research stream related to our work is that on multi-source fault-tolerant structures,Footnote 4 for which we look at distances/paths from a set  of sources. Here, results are known only for unweighted graphs. For , [41] shows how to compute a 1-EFT MSBFS of size 
, which is tight and has been converted, among other results, to an oracle having size 
 that is able to report post-failure shortest-paths in O(1) time per edge [9]. In [30], Gupta and Singh showed that post-failure distance queries can be answered in time  without increasing the oracle’s size. For  the construction of [38] can be generalized to yield a 2-E/VFT MSBFS of size 
 
 
, also for the case of directed graphs [29]. For large values of f, [13] shows how to build a f-E/VFT MSBFS of size 
, which quickly approaches 
 even in the single-source case. As the authors show, this is unavoidable: for any fixed , there is a large enough value f (depending on ) for which all f-E/VFT BFS constructions must use 
 edges in the worst case, and this is true even if a constant additive error is allowed. In [12], it was shown that an ordinary -spanner of size O(g(n)) can be used to build a 1-EFT -AMSBFS of size , and similarly for the vertex case of size .

More Related Work on (Fault-Tolerant) Spanners/Oracles
For the sake of completeness, we also give some hints on the large body of literature on the related topic of (fault-tolerant) spanners and distance oracles.

As far as spanners are concerned, on weighted graphs the current best known construction is, for any  and any integer parameter , the f-E/VFT -spanner of size 
 
 
 given in [14]. For a comparison, the sparsest known -multiplicative ordinary spanner has size 
 [3], and this is believed to be asymptotically tight due to the girth conjecture of Erdős [26]. In [4] the authors introduced the related concept of 1-EFT resilient spanners, i.e., spanners that approximately preserve the multiplicative increment in distances following an edge failure. In unweighted graphs, fault-tolerant additive spanners were also considered. In particular, Braunshvig et al. [15] proposed the following general approach to build an f-EFT additive spanner: Let A be an f-EFT -spanner, and let B be an ordinary -spanner. Then  is an f-EFT -spanner. The corresponding analysis has been refined in [10] yielding a better additive bound of .

As far as distance oracles are concerned, ordinary (i.e., fault-free) all-pairs distance oracles (APDO) on weigthed graphs were introduced in a seminal work by Thorup and Zwick [44] (who also coined the term oracle), followed by a sequel of papers (among the others, we mention [19, 23] for the currently best bounds). In a fault-tolerant setting, in [8] the authors built (on directed graphs) a 1-E/VFT 1-APDO of size 
 and with query time O(1). For two failures, in [22] the authors built, still on directed graphs, a 2-E/VFT 1-APDO of size 
 and with query time . Concerning multiple-edge failures, in [20] the authors built, for any integer , an f-EFT -APDO of size 
, where W is the ratio of the maximum to the minimum edge weight in G. The query time of the oracle is 
, where F is the actual set of failing edges, and d is the distance between the queried pair of nodes in .

Finally, for other results on single edge/vertex failures spanners/oracles, we refer the reader to [6, 9, 10, 16, 40] and to [1] for a survey.

Structure of the Paper
The paper is organized as follows. First of all, in Sect. 2 we present the MSF sensitivity oracle, that will be instrumental to obtain our efficient oracle. Then, in Sect. 3, we introduce the algorithm for building our structure, and the associated oracle, while in Sect. 4 we present the claimed lower bound. Finally, in Sect. 5 we provide some concluding remarks and hints for possible future works.

A Minimum Spanning Tree k-Sensitivity Oracle
In this section we present an oracle that, given a real-weighted graph G, along with any minimum spanning tree (MST) T of G,Footnote 5 is able to answer queries of the form:

Given a set F of k edge updates on G (i.e., edge insertions, deletions and weight modifications), let 
 be a new MST of G. What are the edges in the symmetric difference of E(T) and 
?

In other words, the oracle can report all the edges of T that leave the MST as a consequence of the updates, along with all the new edges in 
 that enter the MST in their place. The oracle has a size of 
 and can be built in 
 space and 
 time, while a query involving k updates can be answered in 
 time and space.

Our oracle exploits the fact that, when few updates are to be handled, the changes in the resulting MST will be small. This implies that large portions of T and 
 will coincide, hence finding and reusing these portions allows us to save a considerable amount of work compared to the time needed to recompute 
 from scratch. To this aim, we build a structure that maintains a set of connected subtrees of T at different levels of granularity.

A high-level description of our approach is the following. First of all, notice that since a weight modification can be simulated by a deletion followed by an insertion, and since insertions can be managed in  time using known data structures (details can be found in 2.3), it turns out that the difficulty of the problem lies in handling deletions. For them, we perform the following two preprocessing steps:

(i)
We compute a hierarchical clustering of the vertices of T;

(ii)
We associate with each pair of clusters, say 
, a set of crossing edges, namely edges of G having one endvertex in C and the other in 
.

Then, whenever a query involving a set F of edge updates is carried out on the oracle, we build an auxiliary graph 
 whose vertices correspond to the preprocessed clusters, and whose edges are suitably selected from the set of crossing edges – depending on which edges were removed in F. Finally, we compute a MST of 
, from which the query associated with F will be answered.

In the following section, we present the building blocks of our approach step by step.

Building the Clustering
Let  be the maximum degree of a vertex in the given MST T of G.Footnote 6 Our clustering  is a laminar family over V(T), i.e., a collection of clusters (i.e., subsets of V(T)) such that any two clusters from  are either disjoint or one is contained in the other. Moreover,  will guarantee the following properties:

P
.:
,  and, for each , .

P
.:
Each cluster  with  can be partitioned into at least 2 and at most  other clusters from .

P
.:
If 
 and 
 then 
.

P
.:
The vertices in each cluster induce a connected component of T;

From P
 and the fact that  is a laminar family it follows that the number of clusters  containing any single vertex v are at most . Figure 2a shows an example of such a clustering . We can represent  with a tree  in which each vertex is a cluster. The tree  is rooted in the cluster V(T), its leaves are the singleton clusters in , and the children of each internal node C are the maximal clusters 
 such that 
 (see Fig. 2b).Footnote 7 Notice that, since each internal vertex has at least two children (by P
) and the number of leaves is n, we immediately have .

We now show describe a recursive algorithm that computes a clustering of T satisfying properties P
–P
. A generic invocation of our algorithm receives a subtree 
 of T as its input and adds a clustering of 
 to a global clustering  of T, which is initially empty. The algorithm begins by adding 
 to  and then checks whether 
 consists of a single vertex. If this is the case we are done, otherwise we compute a centroidFootnote 8v of 
 and we invoke the algorithm recursively on each of the trees 
 of the forest obtained by deleting v from T. Our clustering  is the result of the execution of the above algorithm with input T. Observe that the tree  associated with  is closely related to a centroid decomposition of T.

The following lemma bounds the time complexity of our recursive algorithm.

Lemma 1
The above algorithm for computing  requires time .

Proof
We start by noticing that the centroid of a tree can be found in linear time in the number of the tree’s vertices. We let  be a large enough constant such that (i) the non-recursive part of the algorithm can be executed in time at most cn when the input tree has n vertices (the non-recursive part includes the computation of the centroid), and (ii) the overall time required by the algorithm when the input tree has at most 3 vertices is at most c.

We now prove by induction on  that the worst-case time S(n) required by the algorithm when the input tree T has n vertices is at most . Let v be the centroid of T, let  be the degree of v in T, let 
 be the trees of the forest , and denote by 
 the number of vertices in 
. By the properties of the centroid, we know that each 
 is at most 
 
. If 
 then 
 by our choice of c, otherwise we can invoke the induction hypothesis to write 
. Since the time spent by the algorithm is at most 
, we have: 
. 

Fig. 2
figure 2
a The MST T, along with the set of edges of T (dashed) which are deleted in F (for the sake of readability, the remaining edges of G are not depicted); the picture shows all the sets of , which are numbered. b the tree  associated with the hierarchical clustering . c the set of vertices of 
 computed by Algorithm 1. The dashed edges in c correspond to the deletions in F, so they do not belong to 
; solid lines represent edges of T that will appear in 
. The remaining edges of 
 are selected from the set of crossing edges and are not shown

Full size image

Computing the Crossing Edges
In order to build the auxiliary graph that will be incorporated in our oracle, we need to map the edges of G onto the clustering described above, as explained in the following.

More in detail, we associate with each pair of clusters 
 with 
 a list 
 containing all the edges of E(G) with one endpoint in C and the other in 
. This list is ordered according to edge weights in a non-decreasing fashion. Let  be the set of clusters that contain vertex u. As we already observed, we must have , therefore each edge  appears in at most 
 clusters showing that the overall number of elements in the lists is at most 
. We now show that these lists can be built in time 
 and stored in a way that allows the list associated with a given pair of clusters to be accessed in O(1) time (which will guarantee the promised query time of our oracle).

Our construction maintains a dictionary D, whose keys will be unordered pair of clusters and whose values will be pointers to the corresponding lists of edges. Initially D is empty. We first sort all the edges of G in non-decreasing order of weight, prioritizing the edges in T whenever ties arise, and we examine one edge at a time. When  is considered, we use the tree  to find all the clusters 
 (resp. 
) that contain u but not v (resp. v but not u). In order to do so, we compute the lowest common ancestor (LCA) x of the clusters  and  in . Then, 
 (resp. 
) are exactly the vertices in the unique path from  (resp. ) to x (excluded) in . For each pair 
, with  and , we query D: if the key 
 exists, then we add e to the corresponding list, otherwise we create a new list 
 containing e and we add to D a new element with 
 as its key, and a pointer to 
 as its value.

The above procedure requires 
 time, as each edge belongs to 
 pairs of clusters, as observed before, and a query on D requires  time. However, for efficiency reasons, we will need for our oracle to have a constant access time to the list associated with a given pair of clusters. This can be obtained by building a static version of the dictionary D. This can be done in  time by using the approach given in [31], where  is the number of elements in the original dictionary. In our case 
, hence the overall time needed to handle the crossing edges remains 
, using 
 space.

Answering a Query
We are now ready to describe how a query can be answered. In order to do so, it is useful to split each weight update operation involving an edge e into two separate operations, namely the deletion of e followed by its reinsertion with the new (updated) weight. By doing so, all the operations in F are now either insertions or deletions. For the sake of clarity, we first consider the case in which all the updates F are edge deletions, and we will show later how this can be extended to deal also with edge insertions. Moreover, we initially provide a solution whose size and query time depend on the degree of T, and then we show how this dependence can be avoided, yielding the claimed result.

Handling Edge Deletions In order to handle deletions, we use Algorithm 1 to construct an auxiliary graph 
 whose vertices are clusters. The algorithm computes a set R of clusters of  that coincides with 
. Initially R contains the unique cluster in  that is the root of  and represents the whole tree T. At each time, the set of clusters in R will always form a partition of the vertices in V. The algorithm proceeds iteratively, by considering one after the other the edges of 
. When an edge 
 is considered, if 
 and u and v belong to the same cluster C of R, we split C, i.e., we remove C from  and R, and we add to R all the maximal clusters of  that are strictly contained in C, i.e, the former children of C in . In this way  is always a forest and R contains the roots of the trees in . In the pseudocode of Algorithm 1 we use 
 to denote the root of the tree in  that contains cluster 
, and 
 to denote the set of children of 
 in .

figure a
In the end, 
 is such that all the edges in F have their endvertices into different clusters of 
. Moreover, by 
, the clusters in 
 are associated with connected fragments of T. Since each edge in F can cause at most  splits (as this is also an upper bound on the height of ), and each split operation can increase the number of vertices by at most  (by 
 and the definition of ), we have that 
 contains at most  vertices (see Fig. 2c). Notice that, given a failing edge , the clusters of  that need to be split are those in the unique path from the root of  to the lowest common ancestor of (the singleton clusters containing) u and v. Therefore such clusters can be found in  time and an efficient implementation of Algorithm 2 requires  time.

To construct the set 
 we consider all the pairs 
 of vertices in 
. For each of these 
 pairs, we examine the edges in 
, in order, and we select the first edge e so that , if any. Then, if e exists, we add the edge 
 to 
 with weight w(e). Notice that e is an edge of minimum weight among those in  that have one endvertex in C and the other in 
. Moreover, thanks to the static dictionary, all the above edges can be found in 
 time (the additional additive term k accounts for the edges in the lists that belong to F).

We can now compute a MST 
 of 
 in time 
 by using any standard MST algorithm. We claim that once that the vertices (i.e., clusters) of 
 are expanded to their MST fragments, the resulting structure is exactly a MST of . Indeed, by the cut property of MSTs, we know that all the edges of  (which are a superset of the intra-cluster edges) also belong to an MST of . It is well-known that contracting edges from an MST and computing an MST of the resulting graph yields an MST of the original graph [43, Ch. 11.5.2]. In our case we are contracting all intra-cluster edges and the resulting graph is exactly 
. Then, we look at the edges of 
 and we answer the query by returning the edges of G corresponding to those in 
 that are not in E(T).

Notice that once the MST 
 of the auxiliary graph 
 has been computed, it can be used to answer the following additional query q(u, v) in 
 time. These queries will be needed by our oracle of Sect. 3.1.

Given a set F of at most f edge failures in G, and given a pair of nodes , report all the new edges (and their weights) w.r.t. T on the unique path from u to v in a new MST of G, in order.

Indeed, these new edges can be detected by simply checking the path in 
 between the corresponding clusters containing u and v.

Handling General Edge Updates It turns out that the difficulty of the problem lies in handling the edge-deletion operations. Indeed, once this has been done, the remaining edge-insertion operations can be easily performed. To this aim, we reorganize the batch F (of size k) by first performing all the deletion operations, and we make use of a top-tree [2], i.e., a data structure that dynamically maintains a (weighted) forest under edge-insertion (link) and edge-deletion (cut) operations. Moreover, given two vertices u and v, top-trees are able to report the heaviest edge that lies on the path between u and v in the current forest. Each of these operations can be performed in  time where  is the number of vertices of the forest.

The idea is to maintain the current MST 
 by using a top-tree that is initialized when the oracle is built to represent the tree T. This takes  time. Then, we perform all the edge-deletion operations (as already described), while updating the top-tree accordingly (this requires only  additional time since the number of needed link and cut operations is O(k)).

Now we handle the insertions one by one. In order to insert a new edge , we search for the heaviest edge 
 of the path connecting u and v in 
. If 
 is heavier than e, we cut 
 from 
 and we link the two resulting components by adding the edge e. It is easy to see that this procedure requires an overall time of .

By keeping track of all the O(k) updates in the MST 
, we can easily answer a query consisting of both edge-insertion and edge-deletion operations in 
 time, by reporting all the edges in the symmetric difference of T and 
.

Reducing the Degree of T So far, the complexity of our MST oracle depends on the maximum degree  of the vertices in T. However, using standard techniques (see, e.g., [27]), we now show that the updates on the original graph G and its MST T can be mapped onto an auxiliary graph 
 with weight function 
 and a corresponding MST 
, such that 
 has asymptotically the same size of G, and each vertex of 
 has a degree at most 3 in 
.

Initially 
, 
, and 
 coincide with G, w, and T, respectively. We root 
 in an arbitrary vertex, we iteratively search for a vertex u in 
 that has more than 2 children, and we lower its degree. We let 
 be the children of u in 
, and we proceed as follows: we remove all the edges in 
 from both 
 and 
, then we add to both 
 and 
 a binary tree whose root coincides with u, and that has exactly h leaves 
. We assign weight 
 to all the edges e of this tree.Footnote 9 Finally, we add to 
 and 
 an edge 
 for each , we set 
, and we label 
 with 
. For all the edges e of 
 not affected by this transformation (i.e., the ones that also belong to G) we set . An example of such a transformation is shown in Fig. 3. Let Z be the set of all the edges of weight  added to 
 by this procedure.

Fig. 3
figure 3
Reducing the degree of vertices in T: on the left side, the tree T (solid edges) embedded in G, on the right side the superimposition of the binary tree to T in order to get a maximum degree of 3. Thin solid edges have weight 0, while the weight of 
 is 

Full size image

Each time we have to perform a weight update or delete operation on an edge 
 of G, we instead perform it on the corresponding edge 
. Insertions and operations involving edges in  do not require any special care. In a similar way, whenever the answer of a query contains an edge 
, we replace it with the corresponding edge 
. Clearly, O(n) vertices and edges are added by this process, and hence 
 and 
.

For the sake of completeness we now formally prove that a MST of 
 induces a MST of G even after performing a (possibly empty) set of update operations on both G and 
. To this aim it will be helpful to think of both G and 
 as complete graphs where the functions w and 
 assigning weight  to all the edges that are not in the original graphs. By doing so, applying a set of updates to G and 
 can be seen as a replacing the old weight functions with new ones, say 
 and 
, respectively. Notice also that, by doing so, for each edge  we have 
 while both 
 and 
 if .

Fact 1
Let 
 be a MST of 
 w.r.t. 
. The edges in 
 induce a MST of G w.r.t. 
.

Proof
In the rest of the proof, we assume that whenever ties arise they will be broken in a consistent way. Notice that the edges in Z form a forest in 
 containing n trees, moreover as they are the only edges of weight  w.r.t. 
 we must have  and 
. Let M be a MST of G w.r.t. 
 and  be an edge in 
, we now show that  must belong to M. Let 
 be the cut-set containing the edges of 
 whose endpoints lie in two different components of . Clearly e is the lightest among the edges in 
, and since 
 we have that 
. Let 
 and notice that C is a cut-set for G. Since 
, it follows that  is also the lightest edge in C and hence it belongs to M. The claim follows from the fact that, by construction, the function  is injective. 

Once the maximum degree of the tree has been reduced to a constant, the query time of our oracle becomes 
. Thus, we have finally proven the following result:

Theorem 1
Given a MST T of a real-weighted n-vertex and m-edge graph G, there exists a sensitivity oracle for T of size 
. The oracle can be built in 
 time and, for any batch consisting of an arbitrary number k of modifications to the edges of G, it is able to report in 
 time the (at most 2k) edges either exiting from or entering into the MST.

An immediate consequence of this result is that the additional query q(u, v) can then be answered in 
 time.

An f-EFT -ASPT and a Corresponding Oracle
In this section we show how to compute an f-EFT -ASPT H of G, i.e., a subgraph H of G which contains an SPT of G, and such that 
 for every  and for every subset  of at most f failed edges.

Since up to f edges can fail, we can observe that whenever G is -edge-connected, H must contain  edges even if we are only interested in preserving the connectivity of G. Indeed, the degree of each vertex v in H must be at least  since otherwise v could become disconnected in . Here we show that  edges also suffice if we aim to preserve distances that are at most -stretched w.r.t. the surviving part of G.

Let 
 and 
 denote the distance and the shortest path between nodes u and 
 in any subgraph X of G, respectively. When , we will simply write 
 and 
. If  is a path, 
 will denote the subpath of  between 
.

For any given integer f, Algorithm 2 returns an f-EFT -ASPT of G. First, it computes a SPT T of G that is used to assign a weight to the edges of an auxiliary graph 
. More precisely, the weight of an edge e of 
 is 0 if e is also in T, otherwise it is equal to the sum of the corresponding edge weight in G and the distances in T between s and the endpoints of e. Then,  MSFs 
 of 
 are iteratively computed: when we compute the i-th forest, we remove its edges 
 from 
 before computing the -th forest, so that the sets 
 are pairwise disjoint. The sought subgraph H contains all the edges of the sets 
, and has therefore size O(fn). Notice that 
 coincides with E(T).

figure b
We now argue that H is indeed an f-EFT -ASPT of G. Our proof strategy is as follows: we first show that, when the weight function 
 is considered, any MSF of  is also an MFS of  (Lemma 2). This allows us to upper bound the length of a shortest-path 
 from s to t in  as a function of 
 and the weights 
 of the edges 
 in 
 (Lemma 3). Next, Lemma 4 bounds each of these weights 
 by the largest edge weight 
 of some edge e in 
. Finally, our definition of 
 provides the desired bound on the length of 
 (see Lemma 5).

Fix a vertex t and let 
 be the shortest path from s to t in the surviving graph .Footnote 10 The path  contains (a subset of) the vertices from several trees in the forest . We say that an edge is new if its endpoints belong to two different trees in . Let N be the set of new edges in .

Now consider a MSF M of the graph  (w.r.t. 
). This is also a MSF of the graph 
 (w.r.t. 
) as shown by the following lemma.

Lemma 2
For every  with , any MSF M of  (w.r.t. 
) is also a MSF of 
 (w.r.t. 
).

Proof
In what follows, whenever ties arise we break them by prioritizing the edges in H. First we show that, given any cut-setFootnote 11C of 
, H contains the  lightest edges of C. Indeed, for any set 
, consider the set 
. Either 
 is non empty, and therefore 
 contains the lightest edge in 
, or 
 which means that each edge in C belongs to some set 
 and hence to H.

Let 
 be a MSF of 
. We prove the claim by showing that each edge 
 must also belong to M. Let 
 be the cut-set of 
 that contains e and every edge 
 that forms a cycle with e in 
. Since e is the lightest edge of 
, it is within the  lightest edges of 
. As a consequence , and it also belongs to M as it is the lightest edge in 
. 

Let 
 and notice that 
 traverses each tree of the forest  at most once since the edges in E(T) have weight 0 in H. Once again, let 
 be the set of new edges of 
. By using the path 
, we now provide an upper bound to the distance 
:

Lemma 3
.

Proof
Let M be a MSF of the graph  (w.r.t. 
). The first inequality is trivial as 
 is a path (not necessarily shortest) between s and t in (a subgraph of) , hence we focus on proving the second inequality.

Let 
 be the trees of  traversed by 
, in order, and let 
 be the new edge in 
 connecting a vertex 
 of 
 to a vertex 
 of 
. Thus, we have 
. We call 
 the vertex in 
 that has the lowest depth in 
.Footnote 12

According to this definition, 
 coincides with s, 
 is the LCA in 
 between 
 and t, and 
 is the LCA in 
 between 
 and 
, for every .

We prove by induction on i that 
. The base case  is trivially true. Now suppose that the inductive hypothesis holds for i, we prove it also for :


 
 
 
 

We now use the fact that 
 to prove the claim:


 
 
 


Next lemma shows that the weights of the new edges of 
 are, in turn, upper bounded by the weight of some new edge of the path .

Lemma 4
For each 
, we have 
.

Proof
Let 
 be an arbitrary edge in 
. W.l.o.g., we assume that the path 
 traverses the vertices s, x, y, t in this order. We recall that the path 
 traverses each tree in  at most once, i.e., all the vertices of 
 that belong to the same tree in  must be contiguous in 
. Moreover, as 
 is new, x and y belong to two different trees in .

Let Z be the set of trees of the forest  that are traversed by the path . Let 
 be the last vertex of 
 that belongs to a tree, say 
, in Z (see Fig. 4). Observe that 
 is always defined since s belongs to some tree of Z. In a similar way, let 
 be the first vertex of 
 that belongs to a tree, say 
, in Z. Again, observe that 
 is always defined as t belongs to some tree of Z other than that containing s, hence 
, and finally notice that 
. By our choice of 
 and 
, we know that  encounters both a vertex of 
 and a vertex of 
 (in some order), so we let 
 be the minimal (w.r.t. inclusion) subpath of  with one endpoint, say u, in 
, and the other endpoint, say v, in 
.

Let 
 be the set of new edges in 
. Notice that 
 as 
, and that adding the edges in 
 (weighted according to 
) to M forms (at least) one cycle C containing both 
 and an edge in 
, say 
. Since M is a MSF of 
, as shown by Lemma 2, we have that 
. 

Fig. 4
figure 4
The forest  obtained by deleting the failed edges in F from T. The path  is the shortest path between s and t in , while 
 (in bold) is the unique path in M between the same vertices. Gray trees contain a vertex of  and are therefore in Z. Edges having endpoints in different trees are new

Full size image

Finally, next lemma relates the weights 
 of the new edges of  to distances in the surviving graph .

Lemma 5
For , 
.

Proof
Let  with 
. Since e lies on the shortest path 
, we can write:


 


We are now ready to prove the main result of this section:

Theorem 2
The graph H returned by Algorithm 2 is an f-EFT -ASPT of G of size O(fn). Moreover, Algorithm 2 requires  time and O(m) space.

Proof
First, observe that 
 contains at most |F| new edges. Indeed all the edges in  have weight 0, while the remaining edges have a positive weight. This means that . As  has no more than  connected components, we have that at most |F| other edges—in addition to the ones in —can belong to M.

By using the above fact in conjunction with Lemmas 3–5, we can write:


 
 
 
 
 

(1)

We recall that this holds for every vertex . Concerning the computational complexity of Algorithm 2, we make use of Chazelle’s algorithm [17]—that computes a MSF in  time and linear space—to compute the  MSFs 
. 

A Corresponding Path/Distance Reporting Oracle
In this section we show how to build an oracle that, given a positively real-weighted graph G and a distinguished source vertex s, is able to answer queries of the form:

“Given a set F of at most f edge failures in G, and a destination node t in G, report a -approximate path/distance from s to t in .”

We first compute a SPT T of G and an f-EFT -ASPT H of G, as shown in the previous section. Then, the oracle is composed of three ingredients:

The tree T and all the distances 
 from s to any vertex ;

A MSF sensitivity oracle Q for T w.r.t. H with weights 
, built as shown in Sect. 2. According to Theorem 1, this oracle has size 
 and can be built in 
 time;

An oracle to answer LCA queries between two vertices in T. Such an oracle can be built in linear time and has a constant query time, as shown in [32].

The resulting size is therefore 
, and the time required to build our oracle is 
. Interestingly, if we do not fix in advance the value of f, we can build in 
 time an oracle of size 
 that is able to report  approximate paths/distances, for any number |F| of faults. Indeed, the number of edges in H is upper bounded by m, i.e., the number of edges of G.

In the following, we analyze the query time of the oracle, by first facing a path-reporting query, and then a simpler distance query.

Answering a Path-Reporting Query

To return a -approximate path between s and t, it suffices to report the path 
, as shown by Eq. (1).

To this aim, we first query the MSF oracle Q through the additional query q(s, t), which will return all the new edges on the unique path from s to t in the updated MSF. Let 
 be these new edges, in order, with 
. For , let 
 be the LCA in 
 between 
 and 
, and let 
 be the LCA in 
 between 
 and t. We now have all the pieces needed to reconstruct and return the path 
. Indeed, if we let 
, the following holds:


 

(2)

where each subpath is entirely in T and all the endpoints are known. The whole procedure requires 
 time to perform the query q(s, t) on Q (as observed at the end of Sect. 2), O(|F|) time for the LCA queries, and 
 time to reconstruct the path. The overall query time is therefore 
.

Answering a Distance Query To report the length of a -approximate path from s to t, we can replace each subpath in Eq. (2) with the corresponding distance, in order to obtain:


 
 

The above quantity can be computed in  time, once we know the edges 
 and we notice that 
, and moreover that if x is a descendant of 
 in T, then 
. The overall query time is thus 
.

Summarizing, we can give the following:

Theorem 3
Given a positively real-weighted n-vertex and m-edge graph G, and given a distinguished source vertex s of G, there exists an f-EFT SSDO of G that can be built in 
 time. The oracle has size 
 and, for any set F of failures, it is able to report -approximate distances (resp., approximate shortest paths) from s in  in 
 time (resp., 
 time plus the size of the reported path).

A Lower Bound to the Size of a -EFT -ASPT
In this section we show that, if the long-standing girth conjecture of Erdős [26] is true, then, for any integer , any f-EFT -ASPT with  and 
 
 requires 
 
 edges. In particular, this implies that if we want to build a structure which is resistant to at least  edge failures and has stretch less than 2, then it must contain 
 edges. Very recently, in [5], Baswana et al. showed that a similar construction implies a lower bound of 
 edges for any structure preserving connectivity on directed graphs when up to f edges can fail.

Theorem 4
There are graphs G for which any f-EFT -ASPT with  and 
 
 contains 
 
 edges.

Proof
Let G be a graph on  vertices with girth  and 
 
 edges (according to the girth conjecture, such a graph always exists). We construct a weighted graph 
 in the following way (see Fig. 5): we add to G a binary tree T rooted in s with  leaves and height , and we further add an edge from each leaf of T to a distinct vertex of V(G), in an arbitrary way. The weights of E(G) and E(T) will be set to 1 and 0, respectively, while the remaining additional edges will have weight 
 
. Observe that the total number of vertices of 
 is , hence 
 
.

Fig. 5
figure 5
Graph 
 used in the lower bound construction. The dashed edge e does not belong to H while the dotted edges belong to F. Bold edges have weight 1, tree edges have weight 0, and the remaining edges—connecting the leaves of T to the vertices in G—have weight x

Full size image

Let H be any f-EFT -ASPT of 
 rooted in s, with  and 
 
. We will show that H must contain all the edges of E(G). Indeed, suppose that an edge  is missing from H, and let 
 be the unique leaf of the T such that 
. We let 
 be the sequence of internal vertices of T traversed by 
, and let 
 be the edge incident to 
 other than that in 
. We choose 
 as shown in Fig. 5. It is easy to see that , and that each path from s to any vertex of V(G) in 
 has the path 
 as a prefix, hence the same must hold in . Therefore, we know that 
. Observe that either 
 passes through a vertex in V(T) or not. In the former case, it must contain at least an edge of weight 1 and two edges of weight x, hence 
. Otherwise, since the girth of G is g, 
. In both cases we have that 
 
 
. At the same time, it holds 
 
. This implies that the stretch factor of H would be at least 
 
 
, a contradiction. 

Conclusions and Open Problems
In this paper we have shown how to build an f-EFT -ASPT of size O(fn), thus providing a substantial improvement over the previously known structure of [42]. Such a structure has an (asymptotically) optimal size, as  edges are needed even to preserve connectivity between the source vertex and the other vertices of the graph when f edge failures can happen. It is not clear, however, whether the stretch can be improved without increasing the size of the structure. The lower bound of 
 
 edges to the size of any f-EFT ASPT shown in Sect. 4 only works for more than  failures, and for a fixed size of  edges only implies a lower bound to the stretch of at most 3, hence we look at the problem of closing this gap as an interesting challenge. Nonetheless, we point out that this already shows that it is not possible to obtain a stretch arbitrarily close to 1 with a quasi-linear number edges, as it happens for the single-failure case. To this respect, it would be worthy to understand if the lower bound can be extended to work—even if in some weaker form—for a constant number of edge failures.

Furthermore, we have also shown how to convert our f-EFT -ASPT into an f-EFT -SSDO of size 
 than can answer distance queries in time 
. This oracle is also able to report the path corresponding to a query by using an additional time proportional to the number of edges of the path itself (i.e., constant time per edge). To obtain this latter result we developed a sensitivity oracle of size 
 that is able to report in 
 time the changing edges of a MSF of a graph following the insertion/deletion/weight-update of k edges of the graph. This provides the current best worst-case solution to the fully-dynamic MSF problem for relatively short sequences of updates when the starting graph is arbitrary. Notice that a lower-bound of  edges to the size of any MSF sensitivity oracle trivially holds when , since storing the whole graph G is required. It would therefore be interesting to understand whether it is possible to shave off the polylogarithmic factors from the size of our constructions and from the query time. The latter improvement would also result in a query time that is a function of only the number of changing edges, i.e., it is constant as soon as .

