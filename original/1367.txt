We consider the ğ‘˜-PRIZE-COLLECTING STEINER TREE PROBLEM. An instance is composed of an integer k and a graph G with costs on edges and penalties on vertices. The objective is to find a tree spanning at least k vertices which minimizes the cost of the edges in the tree plus the penalties of vertices not in the tree. This is one of the most fundamental network design problems and is a common generalization of the PRIZE-COLLECTING STEINER TREE PROBLEM and the ğ‘˜-MINIMUM SPANNING TREE PROBLEM. Our main result is a 2-approximation algorithm, which improves on the currently best known approximation factor of 3.96 and has a faster running time. The algorithm builds on a modification of the primal-dual framework of Goemans and Williamson, and reveals interesting properties that can be applied to other similar problems.

Access provided by University of Auckland Library

Introduction
In many network design problems, the input consists of an edge-weighted graph, and the output is a minimum-cost tree connecting a certain subset of vertices. Two of the most fundamental NP -hard variants are the PRIZE-COLLECTING STEINER TREE PROBLEM (PCST) and the ğ‘˜-MINIMUM SPANNING TREE PROBLEM (ğ‘˜-MST). For PCST, a solution may contain any subset of vertices, but any not spanned vertex incurs a penalty which is added to the objective-function. For ğ‘˜-MST, the output tree is required to contain at least k vertices.

In this paper we consider the ğ‘˜-PRIZE-COLLECTING STEINER TREE PROBLEM (ğ‘˜-PCST), which is a common generalization of PCST and ğ‘˜-MST. An instance consists of a connected undirected graph ğº=(ğ‘‰,ğ¸), a special vertex r, called the root, and a non-negative integer ğ‘˜â‰¤|ğ‘‰|. Each edge ğ‘’âˆˆğ¸ has a non-negative cost ğ‘ğ‘’, and each vertex ğ‘£âˆˆğ‘‰ has a non-negative penalty ğœ‹ğ‘£. A solution is a tree T spanning at least k vertices, including the root r, minimizing the cost of edges of the tree plus the penalties of vertices not spanned by the tree, i.e., minimizing âˆ‘ğ‘’âˆˆğ¸(ğ‘‡)ğ‘ğ‘’+âˆ‘ğ‘£âˆˆğ‘‰âˆ–ğ‘‰(ğ‘‡)ğœ‹ğ‘£. Without loss generality, we assume that ğœ‹ğ‘Ÿ=âˆ.

Related Works
PCST is the special case of ğ‘˜-PCST for which ğ‘˜=0. For this problem, Bienstock et al. presented a 3-approximation based on an LP rounding algorithm [5], and Goemans showed that this factor could be improved to 2.54, by randomizing the rounding algorithm [18]. Goemans and Williamson presented a 2-approximation [12] based on a new general primal-dual scheme for PCST as well as many other constrained forest problems. To bound the value of an optimal solution, they used weak duality, and, as a consequence, their analysis implies that the integrality gap of the usual LP formulation is asymptotically tight. Currently, the best approximation for PCST is due to Archer et al. [1] and it has factor 2âˆ’(2âˆ’ğœŒ2+ğœŒ)2, where ğœŒ is an approximation factor for the STEINER TREE PROBLEM. Using the best-known value for ğœŒ, which is ln(4)+ğœ– [7], this yields a factor of 1.9672+ğœ– for PCST.

ğ‘˜-MST is the special case of ğ‘˜-PCST for which ğœ‹ğ‘£=0 for each vertex v. One may assume that a solution spans exactly k vertices, since a tree with more than k vertices can be pruned without increasing its cost. Several approximation algorithms were devised for ğ‘˜-MST [4, 8, 17], and Blum et al. [6] gave the first constant-factor approximation, with factor 17, by using the primal-dual scheme. Garg improved this factor to 5 and 3, subsequently [10], and Arya and Ramesh showed how Gargâ€™s algorithm could be used to obtain a factor of 2.5 [3]. Later, Arora and Karakostas gave a (2+ğœ–)-approximation by modifying Gargâ€™s algorithm [2]. Currently, the best approximation for ğ‘˜-MST is a 2-approximation due to Garg [11, 16] and is based on a sophisticated use of the primal-dual scheme.

To our knowledge, the first constant-factor approximation for ğ‘˜-PCST was given by Han et al. [13] and has factor 5. They presented a primal-dual scheme based on the Lagrangian relaxation of a linear program. Later, Matsuda and Takahashi [15] derived a 4-approximation by combining the solutions for the underlying instances of PCST and ğ‘˜-MST. The algorithmâ€™s running time is îˆ»(|ğ‘‰|4|ğ¸|log|ğ‘‰|) and is bottlenecked by Gargâ€™s 2-approximation, which is used to solve ğ‘˜-MST. By using the (1.9672+ğœ–)-approximation for PCST, the approximation factor for ğ‘˜-PCST can be improved to 3.9672+ğœ–, with a significant increase in the running time.

Our Results
Our main contribution is a 2-approximation for ğ‘˜-PCST. More precisely, we present an algorithm with running time îˆ»(|ğ‘‰|2|ğ¸|2+|ğ‘‰|4log2|ğ‘‰|) that finds a tree T such that âˆ‘ğ‘’âˆˆğ¸(ğ‘‡)ğ‘ğ‘’+2â‹…âˆ‘ğ‘£âˆˆğ‘‰âˆ–ğ‘‰(ğ‘‡)ğœ‹ğ‘£â‰¤2â‹…opt, where opt is the optimal value. This improves on both the approximation factor and the time complexity of the previously best-known algorithms. Our 2-approximation is based on a modified version of the Goemans and Williamsonâ€™s algorithm, and our analysis reveals many interesting properties of the primal-dual scheme, which might give insights to other problems with similar constraints. We note that the inequalities considered by our algorithm do not correspond to a dual LP formulation for ğ‘˜-PCST, and our analysis does not rely on weak duality. Moreover, a small modification of the algorithm results in a 2-approximation for the quota variant [14] of ğ‘˜-PCST, for which an instance includes vertex weights, and a solution is any tree whose weight is at least the given quota.

Algorithmâ€™s Overview
Our algorithm successively executes a modified version of the 2-approximation primal-dual scheme for PCST due to Goemans and Williamson [12]. Their algorithm is divided into a growth-phase and a pruning-phase. In the growth-phase, it computes a feasible dual solution y such that for each subset of vertices S, ğ‘¦ğ‘† is a non-negative value. It also outputs a tree T and a collection îˆ® of subsets of V, whose edges and subsets correspond to tight dual inequalities of an LP formulation. In the pruning-phase, the algorithm deletes from T the subsets in îˆ® which do not disconnect the graph, resulting in a pruned tree . To derive a 2-approximation, they bound the value of  by a factor of the dual objective-function; in our algorithm, we compare the output with an optimal solution directly.

In our modification, the growth-phase receives two new arguments, a potential ğœ† and a tie-breaking list ğœ. The potential is a uniform increase on the penalties of each vertex, such that for larger values of ğœ†, the output tree  spans more vertices. During the growth-phase, there might be concurrent events, thus there are multiple choices for the execution path. Usually, these choices are determined by some fixed lexicographic order. Our algorithm, on the contrary, relies on a tie-breaking list ğœ to control the priority among concurrent events. The i-th element in this list dictates which event gets the highest priority in the i-th iteration of the algorithm. This allows us to control the execution path of the algorithm.

The use of potential ğœ† is built on Gargâ€™s arguments for the 2-approximation for ğ‘˜-MST [11], which can be described as follows. If, for some ğœ†, the pruned tree  spans exactly k vertices, this leads to a 2-approximation by using the Lagrangian relaxation strategy (see, e.g., [8]). However, it might be the case that no such ğœ† exists; thus, the idea is to find a particular value of ğœ† such that, for sufficiently small ğœ–, using potential ğœ†âˆ’ğœ– leads to a pruned tree  spanning less than k vertices, and using potential ğœ†+ğœ– leads to a pruned tree  spanning at least than k vertices. The tree  is constructed by pruning a tree  using a collection . Similarly,  is constructed by pruning a tree  using a collection . On the one hand,  is a feasible solution, but its cost cannot be bounded in terms of vector y. On the other hand, the value of  can be bounded, but it is not a feasible solution.

In Gargâ€™s algorithm, the trees  and  and the collections  and  might be very different. Thus, to obtain a tree with k vertices and whose cost can be bounded, his algorithm iteratively transforms  into  and  into  by replacing one edge of  or one subset in  at a time. At some iteration, pruning the current tree using the current collection must result in a tree spanning at least k vertices. And, before this step, instead of performing the operation, one augments the current pruned tree by adding a sequence of edges whose corresponding dual restrictions are tight, picking up to k vertices.

Our algorithm also considers similar trees  and  and corresponding collections  and . However, both trees are constructed by executing the growth-phase using a single potential ğœ†. To differentiate between the cases, we take into account a tie-braking list ğœ and its maximal proper prefix ğœËœ. We show how to compute a special tuple (ğœ†,ğœ), called the threshold-tuple, such that executing the growth-phase using ğœ results in a pruned tree with less than k vertices, while using ğœËœ results in a pruned tree with at least k vertices (or vice-versa).

The trees and collections output by the two executions of the growth-phase are only slightly different. Indeed, a key ingredient of our analysis (presented in Lemma 10) shows that one of the two following scenarios hold:

(i)
 and  are equal, and trees  and  differ in one edge; or

(ii)
 and  are equal, and collections  and  differ in one subset.

Moreover, we show that the vector y output in both executions of the growth-phase are the same. This leads to a straightforward way of augmenting the pruned tree , by picking a sequence of edges of  or  whose corresponding inequalities are tight, without the need for a step-by-step transformation.

Although the computed vector y satisfies a set of inequalities, these inequalities do not correspond to an LP dual formulation for ğ‘˜-PCST, hence we cannot use weak duality to bound the value of an optimal solution. Instead, we show (in Lemma 23) that either our algorithm returns a 2-approximate solution, or it identifies a non-empty subset of the vertices which are not spanned by any optimal solution. Thus, we either find the desired solution, or can safely reduce the size of the instance. Therefore, by running the algorithm at most |ğ‘‰|âˆ’ğ‘˜ times, we find a 2-approximate solution.

Text Organization
The remaining sections are organized as follows. In Sect. 2, we give a series of definitions and introduce the terminology used in the text. In Sect. 3, we describe our modification of the primal-dual scheme, which accounts for the potential ğœ† and the tie-breaking list ğœ. In Sect. 4, we formally define the threshold-tuple, and show how it can be computed. In Sect. 5, we show that, given a threshold-tuple, one can construct a tree spanning exactly k vertices. In Sect. 6, we bound the cost of the computed tree and give a 2-approximation for ğ‘˜-PCST. In Sect. 7, we give some concluding remarks.

Definitions and Preliminaries
We say that a nonempty collection îˆ¸âŠ†2ğ‘‰ is laminar if, for any two subsets ğ¿1,ğ¿2âˆˆîˆ¸, either ğ¿1âˆ©ğ¿2=âˆ…, or ğ¿1âŠ†ğ¿2, or ğ¿2âŠ†ğ¿1. A laminar collection îˆ¸ is binary if for every ğ¿âˆˆîˆ¸ with |ğ¿|â‰¥2, there are distinct non-empty subsets ğ¿1,ğ¿2âˆˆîˆ¸ such that ğ¿=ğ¿1âˆªğ¿2. We denote the collection of inclusion-wise maximal subsets of a collection îˆ¸ by îˆ¸âˆ—. Observe that, if îˆ¸ is laminar, then the subsets in îˆ¸âˆ— are disjoint.

Let îˆ¼ be a partition of V, and consider an edge e with extremes on V. If a set in îˆ¼ contains an extreme of e, then we call this set an endpart of e. We say that an edge e is internal in îˆ¼ if e has only one endpart, and we say that e is external in îˆ¼ if e has two distinct endparts. Also, two external edges are said to be parallel in îˆ¼ if they have the same pair of endparts.

Given a graph H and a subset ğ¿âŠ†ğ‘‰, we say that H is L-connected if ğ‘‰(ğ»)âˆ©ğ¿=âˆ… or if the induced subgraph ğ»[ğ‘‰(ğ»)âˆ©ğ¿] is connected. For a collection îˆ¸ of subsets of vertices, we say that H is îˆ¸-connected if H is L-connected for every ğ¿âˆˆîˆ¸.

Let ğ¿âŠ†ğ‘‰ and ğ»âŠ†ğº. Then ğ›¿ğ»(ğ¿) denotes the set of edges of H with exactly one extreme in L. We say that L has degree |ğ›¿ğ»(ğ¿)| on H. In the case where ğ»=ğº, we drop the subscript and write just ğ›¿(ğ¿).

For a subset ğ¿âŠ†ğ‘‰, we define its new penalty as ğœ‹ğœ†ğ¿=âˆ‘ğ‘£âˆˆğ¿ğœ‹ğ‘£+ğœ†|ğ¿|, where ğœ† is a non-negative value which we call potential. Note that, for any subset L containing the root r, we have ğœ‹ğœ†ğ¿=âˆ.

Consider a vector y such that, for each ğ¿âŠ†ğ‘‰, the entry ğ‘¦ğ¿ is a non-negative variable. We say that y respects edge cost ğ‘ if

âˆ‘ğ¿:ğ‘’âˆˆğ›¿(ğ¿)ğ‘¦ğ¿â‰¤ğ‘ğ‘’for every edge ğ‘’âˆˆğ¸,
(1)
and we say that y respects vertex penalty ğœ‹ğœ† if

âˆ‘ğ‘†:ğ‘†âŠ†ğ¿ğ‘¦ğ‘†â‰¤ğœ‹ğœ†ğ¿for every subset ğ¿âŠ†ğ‘‰.
(2)
We say that an edge e is tight for (ğ‘¦,ğœ†) if the inequality corresponding to e in (1) holds with equality. Analogously, a subset ğ¿âŠ†ğ‘‰ is tight for (ğ‘¦,ğœ†) if the inequality corresponding to L in (2) is satisfied with equality. If the pair (ğ‘¦,ğœ†) is clear from the context, we simply say that e and L are tight.

Inequalities (1) and (2) are similar to the inequalities in the dual formulation for PCST [12], with the difference that we include inequalities for subsets containing r. However, these inequalities do not correspond to the dual of an LP formulation for ğ‘˜-PCST.

For a collection of subsets îˆ¸, denote by îˆ¸[ğ‘†] the collection of subsets in îˆ¸ which are subsets of S. Also, denote by îˆ¸(ğ‘†) the collection of subsets in îˆ¸ which contain some, but not all, vertices of S. Moreover, let ğ‘ğ¸â€²=âˆ‘ğ‘’âˆˆğ¸â€²ğ‘ğ‘’ for ğ¸â€²âŠ†ğ¸, and ğœ‹ğ¿=âˆ‘ğ‘£âˆˆğ¿ğœ‹ğ‘£ for ğ¿âŠ†ğ‘‰. To bound the value of an optimal solution, we use the following lemma.

Lemma 1
Let ğ‘‡âˆ— be an optimal solution. Suppose that îˆ¸ is a laminar collection and that ğ¿âˆ— is the minimal subset in îˆ¸ containing ğ‘‰(ğ‘‡âˆ—). If y respects ğ‘ and ğœ‹ğœ†, then

âˆ‘ğ¿âˆˆîˆ¸(ğ¿âˆ—)ğ‘¦ğ¿âˆ’ğœ†|ğ¿âˆ—âˆ–ğ‘‰(ğ‘‡âˆ—)|â‰¤ğ‘ğ¸(ğ‘‡âˆ—)+ğœ‹ğ¿âˆ—âˆ–ğ‘‰(ğ‘‡âˆ—).
Proof
Since îˆ¸ is laminar, each subset in îˆ¸(ğ¿âˆ—) contains some, but not all, vertices of ğ‘‰(ğ‘‡âˆ—), or it is a subset of ğ¿âˆ—âˆ–ğ‘‰(ğ‘‡âˆ—). Also, one subset in îˆ¸(ğ¿âˆ—) cannot be ğ‘‰(ğ‘‡âˆ—), because otherwise ğ¿âˆ— would not be minimal. Thus,

âˆ‘ğ¿âˆˆîˆ¸(ğ¿âˆ—)ğ‘¦ğ¿=âˆ‘ğ¿âˆˆîˆ¸(ğ‘‰(ğ‘‡âˆ—))ğ‘¦ğ¿+âˆ‘ğ¿âˆˆîˆ¸[ğ¿âˆ—âˆ–ğ‘‰(ğ‘‡âˆ—)]ğ‘¦ğ¿â‰¤âˆ‘ğ‘’âˆˆğ¸(ğ‘‡âˆ—)âˆ‘ğ¿:ğ‘’âˆˆğ›¿(ğ¿)ğ‘¦ğ¿+âˆ‘ğ¿âˆˆîˆ¸[ğ¿âˆ—âˆ–ğ‘‰(ğ‘‡âˆ—)]ğ‘¦ğ¿â‰¤âˆ‘ğ‘’âˆˆğ¸(ğ‘‡âˆ—)ğ‘ğ‘’+ğœ‹ğœ†ğ¿âˆ—âˆ–ğ‘‰(ğ‘‡âˆ—)=ğ‘ğ¸(ğ‘‡âˆ—)+ğœ‹ğ¿âˆ—âˆ–ğ‘‰(ğ‘‡âˆ—)+ğœ†|ğ¿âˆ—âˆ–ğ‘‰(ğ‘‡âˆ—)|.
The first inequality holds as each subset in îˆ¸(ğ‘‰(ğ‘‡âˆ—)) is crossed by at least one edge of ğ‘‡âˆ—, and the second inequality holds because y respects ğ‘ and ğœ‹ğœ†. â—»

Modified Growth and Pruning Phases
In the following, we detail our modification of the primal-dual scheme due to Goemans and Williamson for PCST [12]. The algorithm is composed of two main routines: a clustering algorithm, also known as the growth-phase, and a cleanup algorithm, known as the pruning-phase.

Modified Clustering Algorithm
The modified growth-phase is described in the following and is denoted by ğ™¶ğ™¿(ğœ†,ğœ). A listing of all steps is given afterwards, in Algorithm 1. The algorithm maintains a binary laminar collection îˆ¸âŠ†2ğ‘‰, such that îˆ¸âˆ— partitions the set V of vertices, and a vector y which respects ğ‘ and ğœ‹ğœ†. It iteratively constructs a forest ğ¹âŠ†ğº and a subcollection of processed subsets îˆ®âŠ†îˆ¸, such that the edges of F and the subsets of îˆ® are tight for (ğ‘¦,ğœ†). In each iteration, either a new edge is added to F, or a new subset is included in îˆ®.

The algorithm begins by defining îˆ¸={{ğ‘£}:ğ‘£âˆˆğ‘‰} and ğ‘¦ğ‘†=0, for each ğ‘†âŠ†ğ‘‰ (implicitly), and by letting ğ¹=(ğ‘‰,âˆ…), and îˆ®=âˆ…. Once initialized, it starts the iteration process. At a given moment, a maximal subset ğ¿âˆˆîˆ¸âˆ— is said to be active if it has not been processed yet, i.e., if ğ¿âˆˆîˆ¸âˆ—âˆ–îˆ®. In each iteration, we increase the value ğ‘¦ğ¿ of every active subset L uniformly until one of the following events occurs:

â–¹:
an external edge e with endparts ğ¿1,ğ¿2âˆˆîˆ¸âˆ— becomes tight, in which case e is added to F, and the union ğ¿1âˆªğ¿2 is included in îˆ¸; or

â–¹:
an active subset L becomes tight, in which case L is included in îˆ®.

We note that multiple edges and subsets might become tight simultaneously. In our modified algorithm, we use the tie-breaking list ğœ to decide the order in which the events are processed. A tie-breaking list ğœ with size |ğœ| is a (possibly empty) sequence of edges and subsets. For each ğ‘–=1,2,â€¦,|ğœ|, the i-th element of the list is denoted by ğœğ‘–. In iteration i, the event to be processed is determined according to the following order:

(i)
if ğ‘–â‰¤|ğœ|, then the event corresponding to ğœğ‘– has the highest priority;

(ii)
followed by events corresponding to edges;

(iii)
and finally by events corresponding to subsets.

The priority order between events of the same type is determined by a fixed lexicographic order.

The algorithm stops when V is the only active subset in îˆ¸âˆ—, at which point F is a tree. The algorithm defines ğ‘‡=ğ¹, and outputs the pair (ğ‘‡,îˆ®).

figure a
Next lemma collects basic invariants of the growth-phase.

Lemma 2
At the beginning of any iteration of ğ™¶ğ™¿(ğœ†,ğœ), the following holds:

(gp1)
îˆ¸ is a binary laminar collection, â‹ƒğ¿âˆˆîˆ¸âˆ—ğ¿=ğ‘‰, and âˆ…âˆ‰îˆ¸;

(gp2)
y respects ğ‘ and ğœ‹ğœ†;

(gp3)
F is an îˆ¸-connected forest and every edge ğ‘’âˆˆğ¸(ğ¹) is tight for (ğ‘¦,ğœ†);

(gp4)
îˆ®âŠ†îˆ¸ is laminar and every subset in îˆ® is tight for (ğ‘¦,ğœ†);

(gp5)
no subset in îˆ® contains the root r.

Proof
Before the first iteration, îˆ¸={{ğ‘£}:ğ‘£âˆˆğ‘‰}, hence (gp1) is valid. Assume that the invariant is valid at the beginning of an iteration and notice that a new subset L is included into îˆ¸ only if ğ¿=ğ¿1âˆªğ¿2, where ğ¿1,ğ¿2âˆˆîˆ¸âˆ—. Therefore, (gp1) is also valid at the end of the iteration.

Before the first iteration, we have ğ‘¦=0, thus (gp2) is valid since ğ‘ğ‘’ and ğœ‹ğœ†ğ‘£ are non-negative for every edge e and vertex v. Assume that the invariant is valid at the beginning of an iteration. In this iteration, each variable ğ‘¦ğ¿ corresponding to an active subset L is increased by the minimum value of ğ›¥ such that an edge external in îˆ¸âˆ— or an active subset becomes tight. Observe that the only edges that can become tight must be external. Moreover, if a subset ğ¿âŠ†ğ‘‰ becomes tight, so does some subset ğ¿âˆˆîˆ¸âˆ—, because îˆ¸ is laminar. Therefore, after modifying y, no inequality is violated, and the invariant remains valid.

Before the first iteration, (gp3) is valid because îˆ¸ is composed of singletons, and F contains no edges. Assume that the invariant is valid at the beginning of an iteration, and notice that an edge e is included into F only if it is tight and the union ğ¿1âˆªğ¿2 of its endparts ğ¿1,ğ¿2âˆˆîˆ¸âˆ— is included into îˆ¸. Since F is ğ¿1-connected and ğ¿2-connected, it follows that F is also (ğ¿1âˆªğ¿2)-connected because e was added to F. Therefore, (gp3) remains valid at the end of the iteration.

Invariant (gp3) holds because îˆ¸ is laminar, and only tight active subsets are included in îˆ®. For invariant (gp5), observe that in any iteration, if ğ¿âˆˆîˆ¸ is the active component containing the root r, then ğœ‹ğœ†ğ¿=âˆ. It follows that L is not processed, and thus it is not included in îˆ®. â—»

Observe that, since G is connected and the algorithm only ends when V is the only active component, by invariant (gp3) T spans V.

Corollary 1
Let (ğ‘‡,îˆ®) be the pair output by ğ™¶ğ™¿(ğœ†,ğœ). Then ğ‘‰(ğ‘‡)=ğ‘‰.

Lemma 3
The number of iterations executed by ğ™¶ğ™¿(ğœ†,ğœ) is at most 3|ğ‘‰|âˆ’3.

Proof
Since F is a forest (invariant (gp3)), the number of processed edges is at most |ğ‘‰|âˆ’1. Observe that the size of îˆ¸ is initially |V| and increases by 1 for each processed edge. Thus, the final size of îˆ¸ is at most 2|ğ‘‰|âˆ’1. Each subset of îˆ¸ which does not contain the root r can be processed. Therefore, the total number of processed events is at most 3|ğ‘‰|âˆ’3. â—»

A consequence is that the growth-phase executes in polynomial time. Also, this implies that the size of a tie-breaking list need not exceed 3|ğ‘‰|âˆ’3.

Modified Pruning Algorithm
The modified pruning-phase is denoted by ğ™¿ğ™¿(ğ»,îˆ®). A listing is given in Algorithm 2. The algorithm receives a graph H and iteratively deletes from it any processed subset ğµâˆˆîˆ® such that the degree of B in H is one. We assume that the input H is a connected subgraph of G containing r, and that îˆ® is a laminar collection of subsets of V which do not contain r.

figure b
In the following, we might say that we prune H using îˆ® to mean that we execute algorithm ğ™¿ğ™¿(ğ»,îˆ®), and say that a graph H is pruned with îˆ® if |ğ›¿ğ»(ğµ)|â‰ 1 for every ğµâˆˆîˆ®.

Note that we allow input graphs H with cycles, whereas the standard pruning-phase only considers trees. This will be useful in Sect. 5.1, when, to find a tree with k vertices from distinct trees  and , we will first prune , which might contain a cycle.

Next lemma collects invariants of the pruning-phase.

Lemma 4
At the beginning of any iteration of ğ™¿ğ™¿(ğ»,îˆ®), the following holds:

(pp1)
H is connected and ğ‘Ÿâˆˆğ‘‰(ğ»);

(pp2)
ğ»[ğ‘‰(ğ»)âˆ©ğµ] is connected.

Proof
Observe that H is connected and ğ‘Ÿâˆˆğ‘‰(ğ») when the algorithm starts. Consider the subset B chosen at the beginning of an iteration, and assume that (pp1) is valid. Since |ğ›¿ğ»(ğµ)|=1 and ğ‘Ÿâˆ‰ğµ, deleting B does not disconnect H nor removes the root r from H. Thus, (pp1) holds at the end of the iteration. For (pp2), observe that, since H is connected and |ğ›¿ğ»(ğµ)|=1, ğ‘‰(ğ»)âˆ©ğµ must induce a connected subgraph. â—»

Corollary 2
Let ğ»â€² be the graph output by ğ™¿ğ™¿(ğ»,îˆ®). Then, ğ»â€²âŠ†ğ», ğ»â€² is pruned with îˆ®, and ğ‘Ÿâˆˆğ‘‰(ğ»).

Proof
By construction, ğ»â€²âŠ†ğ» and ğ»â€² is pruned with îˆ®. Invariant (pp1) implies ğ‘Ÿâˆˆğ»â€². â—»

Next, we give a structural result about the pruning-phase. It is an auxiliary lemma which implies a series of monotonic properties of the pruning algorithm.

Lemma 5
Consider connected graphs D and H both containing r. Assume that D is pruned with îˆ® and let ğ»â€² be the graph output by ğ™¿ğ™¿(ğ»,îˆ®). If ğ·âŠ†ğ», then ğ·âŠ†ğ»â€².

Proof
Assume that in the execution that output ğ»â€², the algorithm executed â„“ iterations, and let ğµğ‘– and ğ»ğ‘– be the values assigned to variables B and H at the beginning of iteration i. Also, let ğ»â„“+1=ğ»â€².

We show that ğ·âŠ†ğ»ğ‘– by induction on i. Clearly ğ·âŠ†ğ»=ğ»1. Then, assume that ğ·âŠ†ğ»ğ‘– for some ğ‘–â‰¥1. It follows that |ğ›¿ğ·(ğµğ‘–)|â‰¤|ğ›¿ğ»ğ‘–(ğµğ‘–)|. But |ğ›¿ğ»ğ‘–(ğµğ‘–)|=1 by the choice of ğµğ‘–, and so |ğ›¿ğ·(ğµğ‘–)|â‰¤1. Since D is pruned with îˆ®, we know that |ğ›¿ğ·(ğµğ‘–)|â‰ 1, and thus |ğ›¿ğ·(ğµğ‘–)|=0. This implies that ğµğ‘–âˆ©ğ‘‰(ğ·)=âˆ…, because D is connected containing r and ğ‘Ÿâˆ‰ğµğ‘– (invariant (gp5). To complete the induction, observe that ğ·=ğ·âˆ’ğµğ‘–âŠ†ğ»ğ‘–âˆ’ğµğ‘–=ğ»ğ‘–+1. â—»

An implication of this lemma is that the output of ğ™¿ğ™¿(ğ»,îˆ®) is invariant to the order in which subsets of îˆ® are considered.

Corollary 3
Let ğ»1 and ğ»2 be the graphs output by two executions of ğ™¿ğ™¿(ğ»,îˆ®). Then ğ»1=ğ»2.

Proof
Observe that ğ»1 is connected and pruned with îˆ®, and that ğ»2 is the output of ğ™¿ğ™¿(ğ»,îˆ®). Since ğ»1âŠ†ğ», by Lemma 5, ğ»1âŠ†ğ»2. Symmetrically, we have ğ»2âŠ†ğ»1, and thus ğ»1=ğ»2. â—»

Next corollary states that pruning a fixed graph H using a subcollection îˆ® produces a supergraph of the graph obtained from pruning H with îˆ®.

Corollary 4
Let ğ»1 and ğ»2 be the graphs output by ğ™¿ğ™¿(ğ»,îˆ®1) and ğ™¿ğ™¿(ğ»,îˆ®2), respectively. If îˆ®1âŠ†îˆ®2, then ğ»2âŠ†ğ»1.

Proof
Observe that ğ»2 is connected and pruned with îˆ®2, and thus it is pruned with îˆ®1 as well. Since ğ»2âŠ†ğ», by Lemma 5, ğ»2âŠ†ğ»1. â—»

The last corollary considers graphs D which are â€œsandwichedâ€ between a graph H and the pruned subgraph ğ»â€². Intuitively, one may interpret this corollary as stating that pruning a partially pruned graph D leads to the fully pruned graph ğ»â€².

Corollary 5
Consider connected graphs D and H. Let ğ·â€² and ğ»â€² be the graphs output by ğ™¿ğ™¿(ğ·,îˆ®) and ğ™¿ğ™¿(ğ»,îˆ®), respectively. If ğ»â€²âŠ†ğ·âŠ†ğ», then ğ»â€²=ğ·â€².

Proof
Observe that ğ»â€² is connected and pruned with îˆ®. Since ğ»â€²âŠ†ğ·, by Lemma 5, ğ»â€²âŠ†ğ·â€². Analogously, observe that ğ·â€² is connected and pruned with îˆ®. Since ğ·â€²âŠ†ğ·âŠ†ğ», by Lemma 5, ğ·â€²âŠ†ğ»â€². Therefore, ğ»â€²=ğ·â€². â—»

Modified Goemansâ€“Williamson Algorithm
The modified Goemans-Williamson algorithm wraps up the growth and the pruning-phases and is denoted by ğ™¶ğš†(ğœ†,ğœ). A listing is given in Algorithm 3. First, the algorithm executes ğ™¶ğ™¿(ğœ†,ğœ) to obtain a pair (ğ‘‡,îˆ®). Then, it executes ğ™¿ğ™¿(ğ‘‡,îˆ®) and returns the pruned tree .

figure c
One interesting property of ğ™¶ğš†(ğœ†,ğœ) is that if ğœ† is too large, then no subset is ever processed, and the returned tree spans the whole set of vertices. Recall that ğ‘ğ¸=âˆ‘ğ‘’âˆˆğ¸ğ‘ğ‘’. Next lemma states that ğ‘ğ¸ is sufficiently large.

Lemma 6
Let  be the output of ğ™¶ğš†(ğœ†,ğœ). If ğœ†>ğ‘ğ¸, then .

Proof
We claim that îˆ®=âˆ…. If this is the case, by Corollary 1, we have that ğ™¶ğ™¿(ğœ†,ğœ) returns the tuple (ğ‘‡,âˆ…), thus no subset is deleted in the pruning-phase, and we get  and .

Now, we show that îˆ®=âˆ…. Suppose, for a contradiction, that the first processed subset is L and it is processed in iteration â„“. For a vertex v, denote by ğ›¤ğ‘£ the value of âˆ‘ğ‘†:ğ‘£âˆˆğ‘†ğ‘¦ğ‘† at the end of iteration â„“. Since no subset was processed before iteration â„“, each vertex is contained in exactly one active subset in each iteration ğ‘–â‰¤â„“. It follows that, for any two vertices u and v, we have ğ›¤ğ‘¢=ğ›¤ğ‘£.

Since no subset containing the root r is ever processed (invariant (gp5)), ğ‘Ÿâˆ‰ğ¿, and since G is connected, there must exist an external edge e with extremes ğ‘¢âˆˆğ¿ and ğ‘¤âˆ‰ğ¿. Since y respects ğ‘ (invariant (gp2)), and no ğ‘†âˆˆîˆ¸ contains both u and w at the end of iteration â„“, we have

ğ›¤ğ‘¢+ğ›¤ğ‘¤=âˆ‘ğ‘†:ğ‘’âˆˆğ›¿(ğ‘†)ğ‘¦ğ‘†â‰¤ğ‘ğ‘’.
Then, since L becomes tight at iteration â„“,

ğœ‹ğœ†ğ¿=âˆ‘ğ‘†:ğ‘†âŠ†ğ¿ğ‘¦ğ‘†â‰¤âˆ‘ğ‘£âˆˆğ¿ğ›¤ğ‘£=|ğ¿|ğ›¤ğ‘¢â‰¤|ğ¿|ğ‘ğ‘’â‰¤ğ‘ğ¸,
which is a contradiction because ğœ‹ğœ†ğ¿â‰¥ğœ†>ğ‘ğ¸. â—»

The Threshold-Tuple
We execute the modified Goemans-Williamson algorithm using potential zero and passing an empty tie-breaking list, i.e., we execute ğ™¶ğš†(0,âˆ…). If the returned tree spans at least k vertices, then this tree is a 2-approximate solution, as stated in Lemma 7. The proof is adapted from Feofiloff et al. [9] and is given in Appendix A.

Lemma 7
Let  be the tree returned by ğ™¶ğš†(0,âˆ…), and ğ‘‡âˆ— be an optimal solution. Then,


In the remainder of this section, we assume that executing ğ™¶ğš†(0,âˆ…) returns a tree spanning less than k vertices. Observe that Lemma 6 implies that using potential greater than ğ‘ğ¸ leads to a tree with at least k vertices for any tie-breaking list ğœ. We would like to find ğœ† and associated ğœ such that the returned tree spans exactly k vertices, but it might be the case that no such pair exists. Instead, our goal will be finding a special tuple (ğœ†,ğœ), called the threshold-tuple, which will be defined below.

First, we need to introduce some notation. Note that, in the i-th iteration of ğ™¶ğ™¿(ğœ†,ğœ), the edge or subset corresponding to ğœğ‘– is not necessarily tight. We say that a tie-breaking list ğœ is respected by potential ğœ† if the sequence of edges and subsets of V processed in the first |ğœ| iterations of ğ™¶ğ™¿(ğœ†,ğœ) corresponds to ğœ. Also, we denote by ğœËœ the prefix of ğœ with size |ğœ|âˆ’1.

Definition 1
Let  be the tree returned by ğ™¶ğš†(ğœ†,ğœ), and  be the tree returned by ğ™¶ğš†(ğœ†,ğœËœ). We say that (ğœ†,ğœ) is a threshold-tuple if

(i)
ğœ is respected by ğœ†; and

(ii)
 or .

Given a threshold-tuple, one may obtain a pair of trees, one with less than k vertices, and the other with at least k vertices. These trees share many of their structures, and this will be used in Sect. 5 to construct a tree which spans exactly k vertices and is a 2-approximation. In Sect. 4.1, we study the properties of a threshold-tuple and, in Sect. 4.2, we show how it can be computed in polynomial time.

Properties of a Threshold-Tuple
We start by noticing that the executions of ğ™¶ğ™¿(ğœ†,ğœ) and ğ™¶ğ™¿(ğœ†,ğœËœ) are identical up to the beginning of iteration |ğœ|.

Lemma 8
If ğœ is respected by ğœ†, then ğœËœ is respected by ğœ†. Also, at the beginning of the iteration |ğœ| of ğ™¶ğ™¿(ğœ†,ğœ) and ğ™¶ğ™¿(ğœ†,ğœËœ), the variables F, îˆ¸, îˆ® and y are identical.

Proof
The first statement is clear by definition. For the second statement, observe that up to the beginning of the iteration |ğœ|, the execution depends only on the |ğœ|âˆ’1 items of the tie-breaking list. â—»

The event processed in the iteration |ğœ| of the growth-phase plays an important role in distinguishing the outputs returned by executing ğ™¶ğš†(ğœ†,ğœ) and ğ™¶ğš†(ğœ†,ğœËœ). Each such an event corresponds to an edge or a subset. The next auxiliary result lists the possibilities when (ğœ†,ğœ) is a threshold-tuple.

Lemma 9
Assume that (ğœ†,ğœ) is a threshold-tuple. Let ğœ be the edge or subset processed in the |ğœ|-th iteration of ğ™¶ğ™¿(ğœ†,ğœ), and ğœâ€² be the edge or subset processed in |ğœ|-th iteration of ğ™¶ğ™¿(ğœ†,ğœËœ). Then ğœâ‰ ğœâ€², and ğœâ€² is an edge.

Proof
If we had ğœ=ğœâ€², then the output of ğ™¶ğ™¿(ğœ†,ğœËœ) would be identical to the output of ğ™¶ğ™¿(ğœ†,ğœ), and ğ™¶ğš†(ğœ†,ğœËœ) and ğ™¶ğš†(ğœ†,ğœ) would return identical trees. This is not possible, as (ğœ†,ğœ) is a threshold-tuple, thus indeed ğœâ‰ ğœâ€².

First, assume that ğœ is an edge. Since ğœ is respected by ğœ†, ğœ=ğœ|ğœ|. Thus, at the beginning of the |ğœ|-th iteration of ğ™¶ğ™¿(ğœ†,ğœ), ğœ is a tight edge external in îˆ¸âˆ—. By Lemma 8, at the beginning of the |ğœ|-th iteration of ğ™¶ğ™¿(ğœ†,ğœËœ), ğœ is also a tight edge external in îˆ¸âˆ—. Observe that in this iteration of ğ™¶ğ™¿(ğœ†,ğœËœ), edges have the highest priorities, since the size of the considered tie-breaking list is |ğœËœ|<|ğœ|. Because there is at least one tight edge to be processed, this iteration processes an edge, thus ğœâ€² is an edge.

Now, assume that ğœ is a subset. Suppose, for a contradiction, that ğœâ€² is a subset. Since a subset is processed in the |ğœ|-iteration of ğ™¶ğ™¿(ğœ†,ğœËœ), there are no tight edges external in îˆ¸âˆ— in the beginning of this iteration. Let ğ¿0,â€¦,ğ¿ğ‘š be the collection of tight active subsets in the beginning of the |ğœ|-th iteration of ğ™¶ğ™¿(ğœ†,ğœËœ), which is the same for ğ™¶ğ™¿(ğœ†,ğœ) by Lemma 8. Notice that processing a subset does not modify variables F, îˆ¸ and y, thus each subset ğ¿ğ‘– must be processed in both executions (although in different order) before any other edge or subset becomes tight. It follows that, in the beginning of the (|ğœ|+ğ‘š)-th iteration of both ğ™¶ğ™¿(ğœ†,ğœ) and ğ™¶ğ™¿(ğœ†,ğœËœ), variables F, îˆ¸, îˆ® and y are identical. This implies that both executions have the same output. But, again, this is a contradiction because (ğœ†,ğœ) is a threshold-tuple. â—»

In the following, we use the notion of rounds of iterations. Recall that during the execution of ğ™¶ğ™¿(ğœ†,ğœ), there might be iterations for which the increment ğ›¥ to variables of y is set to zero, and thus vector y remains unaltered. We say that iterations i and j are in the same round if the value of vector y at the end of iteration i equals the value of vector y at the end of iteration j.

The output of the growth-phase corresponds to a tree and a collection of processed subsets. Suppose that executing ğ™¶ğ™¿(ğœ†,ğœ) returns pair (ğ‘‡,îˆ®), and executing ğ™¶ğ™¿(ğœ†,ğœËœ) returns pair (ğ‘‡â€²,îˆ®â€²). While, for a threshold-tuple, these pairs must be different, we show that the difference is restricted to adding and removing an edge, or adding a subset. The proofâ€™s arguments rely on the fact that both executions of the growth-phase are almost identical, and differ only in the round of iteration |ğœ|.

Whether the trees or the collections will be different depends on the event processed at iteration |ğœ|. If ğ™¶ğ™¿(ğœ†,ğœ) processes an edge ğœ, then ğ™¶ğ™¿(ğœ†,ğœËœ) processes an edge ğœâ€², and ğ‘‡=ğ‘‡â€²+ğœâˆ’ğœâ€². We give an illustration in Fig. 1. The state at the beginning of iteration |ğœ| is depicted in Fig. 1a, which is the same for both executions. Each maximal subset is represented by a circle, and processed subsets correspond to filled circles. Only edges which are tight and external are drawn, and only maximal subsets which are tight are labelled. The priority order of each edge and subset is given by the corresponding label index. Figure 1b represents the end of the round for ğ™¶ğ™¿(ğœ†,ğœËœ), where the contours surrounding circles are the subsets added to îˆ¸. In this execution, ğœâ€²=ğ‘’1 is the first edge, and the processing order is ğ‘’1,ğ‘’2,ğ‘’3,ğ‘’4,ğ‘’5. Figure 1c represents the end of the round for ğ™¶ğ™¿(ğœ†,ğœ), for which ğœ=ğ‘’6 is the last item of ğœ, and the processing order is ğ‘’6,ğ‘’1,ğ‘’2,ğ‘’3,ğ‘’4.

Fig. 1
figure 1
Executions of ğ™¶ğ™¿(ğœ†,ğœËœ) and ğ™¶ğ™¿(ğœ†,ğœ) in the edge case

Full size image
Fig. 2
figure 2
Executions of ğ™¶ğ™¿(ğœ†,ğœËœ) and ğ™¶ğ™¿(ğœ†,ğœ) in the subset case

Full size image
When ğ™¶ğ™¿(ğœ†,ğœ) processes a subset ğœ at iteration |ğœ|, we have îˆ®=îˆ®â€²âˆª{ğœ}. We give an illustration in Fig. 2, where we use the same convention as before. Figure 2a depicts the state at the beginning of iteration |ğœ|. Figure 2b represents the end of the round for ğ™¶ğ™¿(ğœ†,ğœËœ), for which ğœâ€²=ğ‘’1 is the first edge, and the processing order is ğ‘’1,ğ‘’2,ğ‘’3,ğ‘’4,ğ¿2. Figure 2c represents the end of the round for ğ™¶ğ™¿(ğœ†,ğœ), for which ğœ=ğ¿3 is the last item of ğœ, and the processing order is ğ¿3,ğ‘’1,ğ‘’2,ğ‘’3,ğ‘’4,ğ¿2. Notice that ğ¿1 was not processed in either execution because, after ğ‘’2 had been processed, ğ¿1 stopped being maximal. The subset ğ¿3 was processed by ğ™¶ğ™¿(ğœ†,ğœ), but not by ğ™¶ğ™¿(ğœ†,ğœËœ), because ğ¿3 is processed first in the execution of ğ™¶ğ™¿(ğœ†,ğœ), whereas it stopped being maximal in the execution of ğ™¶ğ™¿(ğœ†,ğœËœ) after ğ‘’4 had been processed.

The following lemma summarizes the main properties of threshold-tuples.

Lemma 10
Assume that (ğœ†,ğœ) is a threshold-tuple, and let ğœ=ğœ|ğœ|. Also, let T, îˆ® and y be the output computed by ğ™¶ğ™¿(ğœ†,ğœ), and let ğ‘‡â€², îˆ®â€² and ğ‘¦â€² be the output computed by ğ™¶ğ™¿(ğœ†,ğœËœ). Then, ğ‘¦=ğ‘¦â€² and

(i)
if ğœ is an edge, then îˆ®=îˆ®â€², ğœâˆ‰ğ¸(ğ‘‡â€²), and ğ‘‡âŠ†ğ‘‡â€²+ğœ;

(ii)
if ğœ is a subset, then ğ‘‡=ğ‘‡â€², ğœâˆ‰îˆ®â€², and îˆ®=îˆ®â€²âˆª{ğœ}.

Proof
Note that ğœ is the edge or subset processed in the |ğœ|-th iteration of ğ™¶ğ™¿(ğœ†,ğœ), because ğœ is respected by ğœ†. Let ğœâ€² be the edge or subset processed in the |ğœ|-th iteration of ğ™¶ğ™¿(ğœ†,ğœËœ). By Lemma 9, ğœâ‰ ğœâ€², and ğœâ€² is an edge. We consider two cases, depending on the type of ğœ.

Case 1: Both ğœ and ğœâ€² are edges.

Let î‰… be the set of tight external edges considered to be processed in the |ğœ|-th iteration of ğ™¶ğ™¿(ğœ†,ğœ). Similarly, define î‰…â€² as the analogous set corresponding to ğ™¶ğ™¿(ğœ†,ğœËœ). Since ğœ and ğœâ€² are processed edges, ğœâˆˆî‰…, and ğœâ€²âˆˆî‰…â€². By Lemma 8, we have î‰…=î‰…â€², and thus ğœ,ğœâ€²âˆˆî‰…. Because edges are processed with priority higher than subsets, each edge of î‰… is processed or becomes internal in the same round of iteration |ğœ|, and before any active tight subset is processed.

Since ğœâˆˆî‰…, at some iteration |ğœ|+â„“, for some â„“â‰¥0, the execution ğ™¶ğ™¿(ğœ†,ğœËœ) must process edge ğœ or some other edge of î‰… which is parallel to ğœ. For some ğ‘–â‰¥0, let ğ‘’â€²ğ‘– be the edge of î‰… processed by ğ™¶ğ™¿(ğœ†,ğœËœ) at iteration |ğœ|+ğ‘–. Therefore, ğ‘’â€²0=ğœâ€², and ğ‘’â€²â„“ is parallel to ğœ at iteration |ğœ|+â„“. Similarly, let ğ‘’ğ‘– be the edge of î‰… processed by ğ™¶ğ™¿(ğœ†,ğœ) at iteration |ğœ|+ğ‘–, and observe that ğ‘’0=ğœ.

We claim that for each 1â‰¤ğ‘–â‰¤â„“, ğ‘’ğ‘–=ğ‘’â€²ğ‘–âˆ’1. To see this, note that at the beginning of iteration |ğœ|+ğ‘– of ğ™¶ğ™¿(ğœ†,ğœ), edge ğ‘’â€²ğ‘–âˆ’1 is tight and external. Since ğ‘’â€²ğ‘–âˆ’1 was processed in iteration |ğœ|+ğ‘–âˆ’1 of ğ™¶ğ™¿(ğœ†,ğœËœ), it has priority higher than any other tight edge of î‰… which is still external. Thus, ğ‘’â€²ğ‘–âˆ’1 is selected to be processed, and indeed ğ‘’ğ‘–=ğ‘’â€²ğ‘–âˆ’1.

At the end of iteration |ğœ|+â„“, the forest F computed by ğ™¶ğ™¿(ğœ†,ğœ) and the forest ğ¹â€² computed by ğ™¶ğ™¿(ğœ†,ğœËœ) are such that ğ¹âˆ’ğœâ€²=ğ¹â€²âˆ’ğœ. Moreover, ğœ and ğœâ€² are in the same connected components of both F and ğ¹â€². Thus, the value of y, the set of external edges, and the collection of active subsets at the end of this iteration are the same in both executions. This implies that the sequence of processed edges and subsets in succeeding iterations are the same. Therefore, the output of ğ™¶ğ™¿(ğœ†,ğœ) and ğ™¶ğ™¿(ğœ†,ğœËœ) are such that ğ‘¦=ğ‘¦â€², îˆ®=îˆ®â€², and ğ‘‡=ğ‘‡â€²+ğœâˆ’ğœâ€². This shows the lemma when ğœ is an edge.

Case 2: ğœ is a subset and ğœâ€² is an edge.

Let î‰„ be the collection of active tight subsets considered to be processed in the |ğœ|-th iteration of ğ™¶ğ™¿(ğœ†,ğœ). Similarly, define î‰„â€² as the analogous collection corresponding to ğ™¶ğ™¿(ğœ†,ğœËœ). Since ğœ is a processed subset, ğœâˆˆî‰„. By Lemma 8, we have î‰„=î‰„â€².

Suppose that, after processing edge ğœâ€², ğ™¶ğ™¿(ğœ†,ğœËœ) processes other â„“ edges in the same round of iterations. Since edges have higher priority, no subset is processed before every tight external edge is processed or becomes internal. Let ğ‘’â€²0,ğ‘’â€²1,â€¦,ğ‘’â€²â„“ be the edges processed in iteration |ğœ|,|ğœ|+1,â€¦,|ğœ|+â„“ of ğ™¶ğ™¿(ğœ†,ğœËœ), respectively. Note that ğ‘’â€²0=ğœâ€².

By Lemma 8, each ğ‘’â€²ğ‘– is also a tight external edge in iteration |ğœ| of ğ™¶ğ™¿(ğœ†,ğœ). Processing a subset does not change the set of tight external edges, thus, after processing subset ğœ, ğ™¶ğ™¿(ğœ†,ğœ) must process the sequence of edges ğ‘’â€²0,ğ‘’â€²1,â€¦,ğ‘’â€²â„“, such that ğ‘’â€²ğ‘– is processed at iteration |ğœ|+ğ‘–+1 of ğ™¶ğ™¿(ğœ†,ğœ). This implies that the set of edges processed by ğ™¶ğ™¿(ğœ†,ğœËœ) up to iteration |ğœ|+â„“ equals the set of edges processed by ğ™¶ğ™¿(ğœ†,ğœ) at up to iteration |ğœ|+â„“+1.

As a consequence, any tight subset of î‰„ that remains maximal at the end of iteration |ğœ|+â„“ of ğ™¶ğ™¿(ğœ†,ğœËœ) is also tight and maximal at the end of iteration |ğœ|+â„“+1 of ğ™¶ğ™¿(ğœ†,ğœ), and vice-versa. After processing edges, any such subset which is still unprocessed is processed. Therefore, at the end of the rounds corresponding to ğ™¶ğ™¿(ğœ†,ğœËœ) and ğ™¶ğ™¿(ğœ†,ğœ), the value of y, the set of external edges, and the collection of active subsets are the same in both executions. As in the previous case, this implies that the sequence of processed edges and subsets in succeeding iterations are the same.

Now observe that both executions process the same set of edges, thus ğ‘‡=ğ‘‡â€². Also, any subset processed by ğ™¶ğ™¿(ğœ†,ğœËœ) is processed by ğ™¶ğ™¿(ğœ†,ğœ). Conversely, if a subset processed by ğ™¶ğ™¿(ğœ†,ğœ) is not processed by ğ™¶ğ™¿(ğœ†,ğœËœ), then this subset must be ğœ. Thus, îˆ®=îˆ®â€²âˆª{ğœ}. To show that ğœâˆ‰îˆ®â€², note that if îˆ®=îˆ®â€², then ğ™¶ğš†(ğœ†,ğœ) and ğ™¶ğš†(ğœ†,ğœËœ) would return identical trees, which is not possible since (ğœ†,ğœ) is a threshold-tuple. This completes the lemma. â—»

Computing a Threshold-Tuple
Before describing the algorithm to compute a threshold-tuple (ğœ†,ğœ), we need some definitions and corresponding auxiliary lemmas.

The Increase-Function
In the following, suppose that we are given a fixed tie-breaking list ğœ and a real interval [a, b] such that, for every ğœ†âˆˆ[ğ‘,ğ‘], ğœ is respected by ğœ†. Then, there is a fixed pair (îˆ¸,îˆ®) such that, for every ğœ†âˆˆ[ğ‘,ğ‘], the laminar collection and the collection of processed subsets computed by ğ™¶ğ™¿(ğœ†,ğœ) at the end of iteration |ğœ| correspond to îˆ¸ and îˆ®, respectively. Let îˆ­=îˆ¸âˆ—âˆ–îˆ®, and note that îˆ­ is the collection of active subsets at the beginning of iteration |ğœ|+1. Define the object-collection îˆ½ corresponding to ğœ and [a, b] as the collection that contains the active subsets, the external edges with at least one active endpart, and the tight external edges with no active endparts at the beginning of iteration |ğœ|+1. Observe that, for ğœ†âˆˆ[ğ‘,ğ‘], if ğ™¶ğ™¿(ğœ†,ğœ) processes an edge or a subset ğœ at iteration |ğœ|+1, then ğœâˆˆîˆ½. Thus, îˆ½ contains all subsets and edges that might be processed at iteration |ğœ|+1 for some ğœ†âˆˆ[ğ‘,ğ‘].

At the beginning of iteration |ğœ|+1 of ğ™¶ğ™¿(ğœ†,ğœ), the variable ğ‘¦ğ‘† of every active subset ğ‘†âˆˆîˆ­ is increased by the largest value ğ›¥â‰¥0, for which no inequality corresponding to an edge or a subset is violated. To compute ğ›¥, one first finds, for each edge or subset ğœâˆˆîˆ½, the value ğ›¥ğœ to increase each variable ğ‘¦ğ‘† such that ğœ becomes tight. Since the considered tie-breaking list ğœ and interval [a, b] are fixed, the value ğ›¥ğœ depends only on ğœ†. The increase-function of ğœ corresponding to ğœ and [a, b] is the function ğœ–ğœ:[ğ‘,ğ‘]â†’â„šâ‰¥0 such that ğœ–ğœ(ğœ†)=ğ›¥ğœ.

Lemma 11
For every ğœâˆˆîˆ½, the increase-function of ğœ is linear in ğœ†.

Proof
For some integer â„“, with 0â‰¤â„“â‰¤|ğœ|, let ğ‘‡â„“ be the sublist of ğœ defined as ğ‘‡â„“=(ğœ1,ğœ2,â€¦,ğœâ„“). Observe that the tie-breaking list ğ‘‡â„“ is respected by ğœ† for every ğœ†âˆˆ[ğ‘,ğ‘], then there is an object-collection îˆ½â„“ corresponding to ğ‘‡â„“ and [a, b]. Also, for each index 1â‰¤â„“â‰¤|ğœ|, the entry ğœâ„“ of the tie-breaking list is processed at iteration â„“ of ğ™¶ğ™¿(ğœ†,ğœ), and thus ğœâ„“âˆˆîˆ½â„“âˆ’1. Note that îˆ½|ğœ|=îˆ½, thus, by defining ğœ|ğœ|+1=ğœ, we have ğœâ„“âˆˆîˆ½â„“âˆ’1 for index â„“=|ğœ|+1 as well.

Let ğœ–â„“(ğœ†) be the increase-function of ğœâ„“ corresponding to ğ‘‡â„“âˆ’1 and [a, b]. We will show by induction that, for each 1â‰¤â„“â‰¤|ğœ|+1, function ğœ–â„“(ğœ†) is linear in ğœ†. The lemma will follow by taking â„“=|ğœ|+1.

First, consider the case â„“=1. If ğœ1 is a subset, then it must be a singleton {ğ‘£} for some vertex v, because each maximal subset in îˆ¸ is a singleton in the first iteration of the growth-phase. Since at this moment, ğ‘¦=0, the increase to turn ğœ1 tight is ğœ–1(ğœ†)=ğœ‹ğœ†ğ‘£=ğœ‹ğ‘£+ğœ†. Similarly, if ğœ1 is an edge e, it must have two active endparts at the first iteration, and thus ğœ–1(ğœ†)=ğ‘ğ‘’/2.

Now, assume that ğœ–ğ‘–(ğœ†) is linear in ğœ† for each ğ‘–<â„“. Consider some subset S, and let ğ›¬ğ‘† denote the set of indices i such that ğ‘–<â„“ and S was an active subset at the beginning of iteration i. It follows that, at the beginning of iteration â„“, ğ‘¦ğ‘†=âˆ‘ğ‘–âˆˆğ›¬ğ‘†ğœ–ğ‘–(ğœ†), which is linear in ğœ†, since each ğœ–ğ‘– is linear in ğœ†, and ğ›¬ğ‘† does not depend on ğœ†.

Let îˆ­ be the collection of active subsets at the beginning of iteration â„“. If ğœâ„“ is an external edge e with no active endparts, then it is tight, thus ğœ–â„“(ğœ†)=0. In the case that ğœâ„“ is an edge e with at least one active endpart, the left-hand side of inequality (2) corresponding to e is âˆ‘ğ‘†:ğ‘’âˆˆğ›¿(ğ‘†)ğ‘¦ğ‘†, that is a linear function, say ğ‘“(ğœ†). It follows that the increase of ğ‘¦ğ‘† for active subsets S which is necessary to turn e tight is

ğœ–â„“(ğœ†)=ğ‘ğ‘’âˆ’ğ‘“(ğœ†)|{ğ‘†âˆˆîˆ­:ğ‘’âˆˆğ›¿(ğ‘†)|.
In both cases, ğœ–â„“(ğœ†) is linear in ğœ†.

Similarly, if ğœâ„“ is a subset L, then the left-hand side of inequality (1) corresponding to L is âˆ‘ğ‘†:ğ‘†âŠ†ğ¿ğ‘¦ğ‘†, that is a function which is linear in ğœ†. Let this function be ğ‘“(ğœ†), then,

ğœ–â„“(ğœ†)=ğœ‹ğœ†ğ¿âˆ’ğ‘“(ğœ†)=ğœ‹ğ¿+ğœ†|ğ¿|âˆ’ğ‘“(ğœ†),
which is linear in ğœ†. â—»

The Diverging Potential
For each potential ğœ†âˆˆ[ğ‘,ğ‘], the element of the object-collection îˆ½ corresponding to ğœ and [a, b] that is processed at iteration |ğœ|+1 of the growth-phase is determined by the increase-function which evaluates to the smallest value. Suppose that executing ğ™¶ğ™¿(ğ‘,ğœ) processes some edge or subset ğœ1 at iteration |ğœ|+1, while executing ğ™¶ğ™¿(ğ‘,ğœ) processes a distinct edge or subset ğœ2 at iteration |ğœ|+1. In this situation, ğœ1 is selected in the former execution because ğœ–ğœ1(ğ‘)â‰¤ğœ–ğœâ€²(ğ‘) for any ğœâ€²âˆˆîˆ½, while ğœ2 is selected in the latter because ğœ–ğœ2(ğ‘)â‰¤ğœ–ğœâ€²(ğ‘) for any ğœâ€²âˆˆîˆ½. Since increase-functions are linear, this implies that there must be some potential ğ‘âˆˆ(ğ‘,ğ‘) such that, at iteration |ğœ|+1, ğ™¶ğ™¿(ğœ†,ğœ) processes ğœ1 for ğœ†<ğ‘, and processes a distinct element in îˆ½ for ğœ†>ğ‘.

Formally, we say that a value ğ‘âˆˆ(ğ‘,ğ‘) is a diverging potential if there are edges or subsets ğœ,ğœâ€²âˆˆîˆ½ with distinct increase-functions ğœ–ğœ,ğœ–ğœâ€² such that: (i) ğœ–ğœ(ğ‘)=ğœ–ğœâ€²(ğ‘); and (ii) execution ğ™¶ğ™¿(ğ‘,ğœ) processes ğœ at iteration |ğœ|+1. Observe that, since increase-functions are linear, the number of diverging potentials is finite and they can be computed in polynomial time using standard line-intersection algorithms.

The definition implies that, for each pair of consecutive diverging potentials, there is an edge or a subset which is tight at iteration |ğœ|+1 when the growth-phase is executed with either diverging potential. This is formalized next.

Lemma 12
Let ğ‘1<ğ‘2<â‹¯<ğ‘ğ‘š be the sequence of diverging potentials in (a, b), and let ğ‘0=ğ‘ and ğ‘ğ‘š+1=ğ‘. Also, let ğœ†0âˆˆ(ğ‘ğ‘—,ğ‘ğ‘—+1) for some 0â‰¤ğ‘—â‰¤ğ‘š. If ğœâˆˆîˆ½ is processed at iteration |ğœ|+1 of ğ™¶ğ™¿(ğœ†0,ğœ), then ğœ is tight at the end of iteration |ğœ|+1 of ğ™¶ğ™¿(ğœ†,ğœ) for every ğœ†âˆˆ[ğ‘ğ‘—,ğ‘ğ‘—+1].

Proof
Because ğœ has been processed, ğœ–ğœ(ğœ†0)â‰¤ğœ–ğœâ€²(ğœ†0) for any ğœâ€²âˆˆîˆ½ with distinct increase-function. Since ğ‘ğ‘— and ğ‘ğ‘—+1 are consecutive potentials, functions ğœ–ğœ and ğœ–ğœâ€² do not intersect for any ğœ†âˆˆ(ğ‘ğ‘—,ğ‘ğ‘—+1). Thus, by the continuity of the increase-functions, ğœ–ğœ(ğœ†)â‰¤ğœ–ğœâ€²(ğœ†) for each ğœ†âˆˆ[ğ‘ğ‘—,ğ‘ğ‘—+1]. It follows that, at iteration |ğœ|+1 of ğ™¶ğ™¿(ğœ†,ğœ), the increase of the variables is ğœ–ğœ(ğœ†), and ğœ is tight at the end of the iteration. â—»

The Threshold-Tuple Search Algorithm
We describe the threshold-tuple search algorithm, denoted by ğšƒğš‚. A listing is given in Algorithm 4. To find a threshold-tuple, the algorithm constructs a tie-breaking list ğœ iteratively. It maintains the following invariants: (i) ğœ is respected by ğœ† for any ğœ†âˆˆ[ğ‘,ğ‘]; (ii) ğ™¶ğš†(ğ‘,ğœ) returns a tree spanning less than k vertices, and ğ™¶ğš†(ğ‘,ğœ) returns a tree spanning at least k vertices.

Initialize the variables by making ğœ=âˆ…, ğ‘=0 and ğ‘=ğ‘ğ¸+1, and start the iteration process. At each iteration i, compute the sequence of diverging potentials ğ‘1<â‹¯<ğ‘ğ‘š in the range (a, b), and let ğ‘0=ğ‘ and ğ‘ğ‘š+1=ğ‘. Since ğ™¶ğš†(ğ‘,ğœ) returns less than k vertices and ğ™¶ğš†(ğ‘,ğœ) returns at least k vertices, there must be some index j for which ğ™¶ğš†(ğ‘ğ‘—,ğœ) returns less than k vertices, and ğ™¶ğš†(ğ‘ğ‘—+1,ğœ) returns at least k vertices.

Discover the edge or subset ğœ which is processed at iteration i of ğ™¶ğ™¿(ğœ†0,ğœ) for some arbitrary ğœ†0âˆˆ(ğ‘ğ‘—,ğ‘ğ‘—+1). Then, extend the tie-breaking list by appending ğœ at the end of ğœ. Note that, by Lemma 12, the extended tie-breaking list ğœ is respected by ğœ† for every ğœ†âˆˆ[ğ‘ğ‘—,ğ‘ğ‘—+1], then the first invariant is maintained by making ğ‘=ğ‘ğ‘— and ğ‘=ğ‘ğ‘—+1.

Next, check if executing ğ™¶ğš†(ğ‘ğ‘—,ğœ) using the updated tie-breaking list returns at least k vertices. If this is so, since ğ™¶ğš†(ğ‘ğ‘—,ğœËœ) returns less than k vertices, (ğ‘ğ‘—,ğœ) is a threshold-tuple, and the algorithm stops. Analogously, if ğ™¶ğš†(ğ‘ğ‘—+1,ğœ) returns less than k vertices, (ğ‘ğ‘—+1,ğœ) is a threshold-tuple. If neither is the case, then the second invariant is maintained, and the process is repeated.

Next, we show that ğšƒğš‚ indeed finds a threshold-tuple.

figure d
Lemma 13
If executing ğ™¶ğš†(0,âˆ…) returns a tree spanning less than k vertices, then ğšƒğš‚ returns a threshold-tuple in polynomial time.

Proof
We argue that the algorithm indeed maintains the invariants: (i) ğœ is respected by ğœ† for any ğœ†âˆˆ[ğ‘,ğ‘]; (ii) ğ™¶ğš†(ğ‘,ğœ) returns a tree spanning less than k vertices, and ğ™¶ğš†(ğ‘,ğœ) returns a tree spanning at least k vertices. Observe that an empty tie-breaking list is respected by ğœ† for every potential ğœ†. Also, ğ™¶ğš†(0,âˆ…) returns a tree spanning less than k vertices by assumption, and ğ™¶ğš†(ğ‘ğ¸+1,âˆ…) returns a tree spanning at least k vertices by Lemma 6. Thus, at the beginning of the iteration process, both invariants hold. By the description of the algorithm, if the invariants hold at the beginning of an iteration, then they hold at the end of the iteration as well.

Observe that, if the algorithm stops, then it returns a threshold-tuple. We will show that ğšƒğš‚ stops after at most 3|ğ‘‰|âˆ’3 iterations. Suppose it does not. Then, at the beginning of iteration 3|ğ‘‰|âˆ’2, the tie-breaking list has size |ğœ|=3|ğ‘‰|âˆ’3. By Lemma 3, the growth-phase executes at most 3|ğ‘‰|âˆ’3 iterations. It follows that the sequence of edges and subsets processed by ğ™¶ğ™¿(ğ‘,ğœ) and ğ™¶ğ™¿(ğ‘,ğœ) are the same, because we know that ğœ is respected by ğœ†âˆˆ[ğ‘,ğ‘] from invariant (i). This implies that ğ™¶ğ™¿(ğ‘,ğœ) and ğ™¶ğ™¿(ğ‘,ğœ) have the same output, and thus ğ™¶ğš†(ğ‘,ğœ) and ğ™¶ğš†(ğ‘,ğœ) return identical trees, which contradicts invariant (ii). â—»

Finding a Solution with a Threshold-Tuple
Assume that we are given a threshold-tuple (ğœ†,ğœ). Then, by executing ğ™¶ğš†(ğœ†,ğœ) and ğ™¶ğš†(ğœ†,ğœËœ), we obtain two trees, one which spans less than k vertices, and the other, at least k vertices. Let  and  be the trees with less than k vertices, and at least k vertices, respectively, and let  and  denote the corresponding pairs computed in the growth-phase.

Denote by  and  the laminar collections computed in the growth-phase. While these laminar collections might be (slightly) different, Lemma 10 states that ğ™¶ğ™¿(ğœ†,ğœ) and ğ™¶ğ™¿(ğœ†,ğœËœ) compute identical vectors y. Moreover each edge of  and each subset of  is tight. The objective of this section is to find a tree T from  spanning at least k vertices.

Recall that that  is the collection of subsets which contain some but not all vertices of S, and let ğ‘‡âˆ— be an optimal solution. Also, assume that V is the minimal subset in  containing ğ‘‰(ğ‘‡âˆ—); we will relax this assumption later. To bound the cost of this optimal solution, one can use Lemma 1, which gives the lower bound


To bound the cost of T, we need to prove an inequality analogous to the one given by Goemans and Williamsonâ€™s analysis [12], i.e., we want that


Therefore, to obtain a 2-approximation, it is sufficient to find a tree such that |ğ‘‰(ğ‘‡)|â‰¤|ğ‘‰(ğ‘‡âˆ—)|. But, since any feasible solution must span at least k vertices, this means that our goal is to compute a tree T that spans exactly k vertices. Such a tree is constructed by the picking-vertices algorithm. This algorithm follows some of the ideas due to Garg [11].

We now explain our assumption that V is the minimal subset containing ğ‘‰(ğ‘‡âˆ—). Recall that , thus there are two subsets  such that ğ‘‰=ğ¿1âˆªğ¿2, because  is binary laminar. Without loss of generality, let ğ¿1 be the one containing r. If V is not the minimal subset in  containing ğ‘‰(ğ‘‡âˆ—), then either ğ¿1 or ğ¿2 contains ğ‘‰(ğ‘‡âˆ—). But, because ğ‘‡âˆ— contains the root r, ğ¿1 must be the subset containing ğ‘‰(ğ‘‡âˆ—), as it also contains r. Therefore, either our assumption holds, or we can safely reduce the instanceâ€™s size by discarding the vertices in ğ¿2.

Picking k Vertices
Let ğœ be the edge or subset processed at iteration |ğœ| of ğ™¶ğ™¿(ğœ†,ğœ). Assume for the moment that ğœ is a subset. Then, Lemma 10 implies that  and collections  and  differ in exactly one subset. Since  spans fewer vertices than , collection  contains more subsets than collection , by the monotonicity of the pruning operation. Therefore, in this case, .

We would like to obtain a tree from  spanning exactly k vertices. To use Goemans and Williamsonâ€™s analysis, this tree needs to be pruned with a collection of tight subsets. If we prune  using , the resulting tree  would have too many vertices, but if we add subset ğœ to the pruning collection, then the pruning algorithm would delete a sequence of tight subsets, until finding the tree , as illustrated in Fig. 3. We will soon show that these subsets form a path in .

Fig. 3
figure 3
Sequence of deleted subsets when ğœ is a subset

Full size image
Definition 2
Consider a laminar collection of subsets îˆ®, and let H be a connected graph. A sequence of subsets ğ·1,ğ·2,â€¦,ğ·â„“+1 which partition V(H) is called a subset path of H processed with îˆ® if ğ»[ğ·â„“+1] is pruned with îˆ®, and, for each 1â‰¤ğ‘–â‰¤â„“,

(i)
H has an edge connecting a vertex ğ‘£ğ‘–âˆˆğ·ğ‘– to ğ·ğ‘–+1;

(ii)
there is ğµğ‘–âˆˆîˆ® such that ğ·ğ‘–âŠ†ğµğ‘– and ğµğ‘–âˆ©ğ·ğ‘—=âˆ…, for every ğ‘—>ğ‘–;

(iii)
ğ»[ğ·ğ‘–âˆªâ‹¯âˆªğ·â„“+1] is connected and pruned with {ğµâˆˆîˆ®:ğ‘£ğ‘–âˆ‰ğµ}.

Figure 4 repeats Figure 3, but representing the corresponding processed subsets and vertices from the definition of a subset path.

Fig. 4
figure 4
A subset path ğ·1,â€¦,ğ·ğ‘™+1 when ğœ is a subset

Full size image
Next lemma states that, under certain conditions, there exists a subset path, which can be computed in polynomial time.

Lemma 14
If H is îˆ®-connected and pruned with {ğµâˆˆîˆ®:ğ‘£âˆ‰ğµ} for some ğ‘£âˆˆğ‘‰(ğ»), then a subset path of H processed with îˆ® can be computed in polynomial time.

Proof
If H is already pruned with îˆ®, then V(H) is a subset path of H processed with îˆ®. Thus, we can assume that executing ğ™¿ğ™¿(ğ»,îˆ®) processes â„“â‰¥1 iterations. Let ğ»ğ‘– be the graph being pruned at the beginning of the i-th iteration, such that ğ»1=ğ» and ğ»â„“+1 is the graph returned by the algorithm. Also, let ğµğ‘–âˆˆîˆ® be the subset chosen to be deleted at this iteration. In each iteration of this execution, we choose some subset ğµğ‘–âˆˆîˆ® with |ğ›¿ğ»ğ‘–(ğµğ‘–)|=1 which is inclusion-wise minimal. Let ğ·â„“+1=ğ‘‰(ğ»â„“+1) and ğ·ğ‘–=ğ‘‰(ğ»ğ‘–)âˆ©ğµğ‘– for each 1â‰¤ğ‘–â‰¤â„“. Note that each ğ·ğ‘– is connected by invariant (pp2). We will show that the sequence ğ·1,ğ·2,â€¦,ğ·â„“+1 is a subset path of H processed with îˆ®.

For each 1â‰¤ğ‘–â‰¤â„“, by the choice of ğµğ‘–, there is an edge connecting a vertex ğ‘£ğ‘–âˆˆğ·ğ‘– to some vertex in ğ‘‰(ğ»ğ‘–+1). We claim that, if |ğ›¿ğ»ğ‘–(ğµ)|=1 for some ğµâˆˆîˆ®, then ğ‘£ğ‘–âˆˆğµ. For ğ‘–=1, since ğ»1 is pruned with {ğµâ€²âˆˆîˆ®:ğ‘£âˆ‰ğµâ€²}, any subset ğµâ€²âˆˆîˆ® with |ğ›¿ğ»1(ğµâ€²)|=1 contains v. Then ğµ1âŠ†ğµ, because ğµ1 is an inclusion-wise minimal subset with |ğ›¿ğ»1(ğµ1)|=1. Thus, indeed, ğ‘£1âˆˆğµ.

Now suppose that the claim is false, and let ğ‘–â‰¥2 be minimum such that |ğ›¿ğ»ğ‘–(ğµ)|=1 for some ğµâˆˆîˆ® with ğ‘£ğ‘–âˆ‰ğµ. If ğµâˆ©ğµğ‘–â‰ âˆ…, then either ğµâŠ†ğµğ‘– or ğµğ‘–âŠ†ğµ. But ğµğ‘– is an inclusion-wise minimal subset with degree one in ğ»ğ‘–, thus ğµğ‘–âŠ†ğµ, which contradicts ğ‘£ğ‘–âˆ‰ğµ. Thus, we may restrict our attention to the case where B and ğµğ‘– are disjoint.

Let ğ·=ğµâˆ©ğ‘‰(ğ»ğ‘–) and ğ‘…=ğ‘‰(ğ»ğ‘–)âˆ–(ğµâˆªğµğ‘–), and observe that the three sets ğ·ğ‘–,ğ·,ğ‘… partition the vertices of ğ»ğ‘– and ğ‘…â‰ âˆ…. Because both ğ·ğ‘– and D have degree one in ğ»ğ‘–, there is no edge between them, as otherwise ğ»ğ‘– would be disconnected because ğ‘…â‰ âˆ…. Thus, there is one edge from ğ·ğ‘– to R, and one edge from D to R.

If the unique edge leaving ğ·ğ‘–âˆ’1 in ğ»ğ‘–âˆ’1 connects ğ·ğ‘–âˆ’1 to R, then ğ·ğ‘– and D would have degree one in ğ»ğ‘–âˆ’1. Because ğµğ‘– and B are disjoint, and îˆ® is laminar, ğ‘£ğ‘–âˆ’1 can be in only one of them. This implies that the other subset does not have ğ‘£ğ‘–âˆ’1 and has degree one in ğ»ğ‘–âˆ’1. This is a contradiction, since the claim holds for ğ‘–âˆ’1. Thus, we may restrict our attention to the case where there is no edge between ğ·ğ‘–âˆ’1 and R.

Then, the unique edge leaving ğ·ğ‘–âˆ’1 in ğ»ğ‘–âˆ’1 has an extreme in either ğ·ğ‘– or D. Assume that this edge connects ğ·ğ‘–âˆ’1 to ğ·ğ‘–, as the other case is symmetrical. In this case, there is no edge between D and ğ·ğ‘–âˆ’1, and thus the degree of B on ğ»ğ‘–âˆ’1 is one. This implies that ğ‘£ğ‘–âˆ’1âˆˆğµ, and it follows that ğµğ‘–âˆ’1âˆ©ğµâ‰ âˆ…. Therefore, ğµğ‘–âˆ’1âŠ†ğµ.

Notice that H is B-connected. Thus, we have two distinct edges between two connected graphs, H[B] and ğ»[ğ·ğ‘–âˆªğ‘…], forming a cycle in H, say C. Since C has vertices in both ğ·ğ‘–âˆ’1 and ğ»ğ‘–, at some iteration ğ‘—<ğ‘–, some, but not all vertices of C were removed for the first time. But this implies that |ğ›¿ğ»ğ‘—(ğµğ‘—)|â‰¥2, which is a contradiction to the choice of ğµğ‘—. Hence, the claim holds.

We conclude that, for each {1\le i \le \ell }, H_i is pruned with {\{B \in {\mathcal {B}}: v_i \notin B\}}, and there is an edge from v_i \in D_i to D_{i+1}. Then, D_1, D_2, \dots , D_{\ell +1} is indeed a subset path of H processed with {\mathcal {B}}. This completes the proof. \square

Finding a Subset Path
In the remaining of this section, we consider , i.e., we let H be the graph with vertex set  and edge set , and let  be the graph output by . By the monotonicity of the pruning operation,  contains , then  spans at least k vertices. The goal is to find a subset path of  leading to .

Observe that, when \sigma is a subset, , then  is pruned with . If v is a vertex in \sigma , then  is pruned with . Therefore, Lemma 14 directly implies the following.

Lemma 15
If \sigma is a subset, then a subset path of  processed with  can be computed in polynomial time.

Now, assume that \sigma is an edge. For this case, Lemma 10 implies that . Moreover,  and  span the same set of vertices, and the difference between them is exactly one edge, thus there exists a unique edge  such that .

Unlike before, we cannot obtain a subset path from  that leads to , because removing  from  disconnects the graph. Instead, we use the fact that H has exactly one cycle, because . Let C be this cycle, and notice that C contains . We begin by showing that  also contains cycle C.

Lemma 16
If \sigma is an edge, then  contains cycle C.

Proof
First observe that  contains . If not, then we would have  and, since  is pruned with , this would imply  by Lemma 5. This is not possible because . Thus, indeed  contains .

Because , we have  by Lemma 5. It follows that  contains , and thus  contains at least some vertices of C. Suppose that  contains some, but not all vertices of C. Then, the pruning algorithm removed some vertices of C, and in the first time that this happened, the selected subset would have degree at least 2, because the corresponding cut-set would have at least two edges from C. This is not possible, because only subsets with degree one are selected. Then, no vertex of C was removed, and indeed  contains C. \square

To construct a subset path of  when \sigma is an edge, we show that there is an edge e of the cycle, such that pruning  leads to  by a sequence of deleted subsets that form a path.

Lemma 17
If \sigma is an edge, then there is an edge e \in E(C) such that a subset path D_1, D_2, \dots , D_{\ell +1} of  processed with  can be computed in polynomial time. Moreover,  connects subsets D_i and D_{i+1} for some i\ge 1, and e connects D_1 and D_j for some j \ge i+1.

Proof
Define , which is connected because  contains C, and  is in C. Since  is pruned with , the first processed subset must contain exactly one extreme of . Let v be such an extreme, and v' be the other extreme of .

Now, define , and obtain a graph  by executing \mathtt {PP}(H_1, {\mathcal {B}}_1). In Fig. 5, the grey circles denote the sets deleted when pruning H_1. Because no subset in {\mathcal {B}}_1 contains v', and  is connected,  contains a path K_{v'} starting at the root r and ending at v'. Consider the unique path K_v in H_1 starting at the root r and ending and v, and let u be the last vertex in this path which is in , i.e., u is the last vertex of K_v which was not deleted by the pruning algorithm. Note that u must be a vertex of the cycle, since K_v contains at least one vertex of K_{v'} which is also in C.

Fig. 5
figure 5
Pruning H_1 using {\mathcal {B}}_1

Full size image
Let u' be the vertex that follows u in K_{v}, and observe that C has an edge e connecting u to u'. Define , and . We claim that H_2 is pruned with {\mathcal {B}}_2. Suppose not, and let B be a subset in {\mathcal {B}}_2 with {|\delta _{H_2}(B)| = 1}. Since  is pruned with {\mathcal {B}}, we know that B contains exactly one extreme of e, thus u \in B, and . Since  does not contain u', it does not contain e either, thus . This implies , and thus . Because  is pruned with {\mathcal {B}}_1, this implies that B \notin {\mathcal {B}}_1, then v' \in B. Since H_2 has two edge-disjoint paths, one from v' to the root r, and other from v' to u', it follows that |\delta _{H_2}(B)|\ge 2, which is a contradiction. Therefore, H_2 is pruned with {\mathcal {B}}_2.

We will obtain a subset path of H_2 processed with  in two steps.  First, since H_2 is pruned with , we can use Lemma 14, and obtain a subset path D_1, D_2, \dots , D_{i+1} of H_2 such that u' \in D_1, and H_2[D_{i+1}] is pruned with .  Second, using Lemma 14 again, we obtain a subset path D'_1, D'_2, \dots , D'_{m+1} of H_2[D_{i+1}] such that v' \in D'_1, and H_2[D'_{m+1}] is pruned with . Then D_1, \dots , D_{i}, D'_1, \dots ,D'_m, D'_{m+1} is a subset path of  processed with .

Note that H_2 has exactly one edge between D_i and D_{i+1}, thus this edge must be , and since v' \in D'_1,  must connect D_i to D'_1. Also, observe that e connects D_1 to some D'_j for j \ge 1, forming a cycle with vertices in D_1, \dots , D_i, D'_1, \dots , D'_j. See Fig. 6.

\square

Fig. 6
figure 6
A subset path D_1, \dots , D_{i}, D'_1, \dots ,D'_m, D'_{m+1}

Full size image
Augmenting the Path
Assume that we already computed a subset path D_1, D_2, \dots , D_{\ell +1} of  processed with . Recall that  contains  as a subgraph, and thus spans at least k vertices. Also, observe that D_{\ell +1} corresponds to the vertices of , and thus spans less than k vertices. Then, there exists an index t such that the subsets in D_t, D_{t+1}, \dots , D_{\ell +1} cover at least k vertices, but D_{t+1}, \dots , D_{\ell +1} cover less than k vertices.

If D_{t+1}, \dots , D_{\ell +1} cover exactly {k - m} vertices, then we would like to augment this sequence by iteratively picking subsets from D_t which add up to m vertices. The goal is to find a sequence of subsets P_1, P_2, \dots , P_s such that: each subset P_i induces a connected subgraph in ; P_1 is connected to D_{t+1}; adjacent subsets are connected by an edge of ; and |P_s| = 1.

This can be done as follows. Suppose that we already have computed a sequence P_0, P_1, \dots , P_{i-1} for some i \ge 1, and want to pick m vertices in S \cap D_t for some subset  containing at least m vertices. Also, suppose there is an edge connecting P_{i-1} to some vertex {v \in S \cap D_t}. To initialize the process, let P_0 = D_{t+1} and S = B_t, where B_t is the subset in  corresponding to D_t in the subset path. Note that there is an edge connecting D_{t+1} to some v \in D_t.

If m = 1, then define P_i = \{v\}, and we are done. Otherwise, we have m \ge 2, thus S contains at least two vertices. Since  is binary laminar, this implies that there are disjoint subsets S_1 and S_2 with S = S_1 \cup S_2, and such that v \in S_1.

If |S_1 \cap D_t| \ge m, then just make S = S_1, and repeat the process. This does not change the assumptions, except that it makes S smaller. Otherwise, {|S_1 \cap D_t| < m}, but this implies {|S_2 \cap D_t| \ge 1} because we have {|S \cap D_t| \ge m}. It follows that  spans vertices in both S_1 and S_2, and, since  is S-connected, there must be an edge connecting a vertex v_1 \in S_1 to a vertex v_2 \in S_2. In this case, we define P_i = S_1 \cap D_t, update the variables by making m = m - |P_i|, S = S_2 and v = v_2, and repeat the process for i + 1. Note that P_i induces a connected subgraph in  because  is S_1-connected.

Figure 7 exemplifies this process. In this figure, solid contours denote the subsets  considered in the process.

Fig. 7
figure 7
A sequence \dots , D_{t+1}, P_1, P_2, P_3, P_4

Full size image
The whole process is summarized as the picking-vertices algorithm, denoted by \mathtt {PV}({\lambda },{\tau }). A listing is given in Algorithm 5. First, obtain a subset path D_1, D_2, \dots , D_{\ell +1} using Lemmas 15 or 17, depending on whether \sigma is a subset, or an edge. Then, find the largest t such that D_t, D_{t+1}, \dots , D_{\ell +1} cover at least k vertices, and find a sequence P_1, P_2, \dots , P_s from D_t using the picking process.

Now, the sequence P_s, \dots , P_1, D_{t+1}, \dots , D_{\ell +1} covers exactly k vertices, and is such that each subset induces a connected subgraph in , and adjacent subsets are connected by an edge. Thus, it induces a tree T spanning exactly k vertices and containing the root r, which is the output of the algorithm.

figure e
In what follows, denote by W the subset  corresponding to D_t in the subset path such that D_t \subseteq W and W \cap D_j = \emptyset for every j > t. Recall that {\mathcal {L}}[W] is the collection of subsets in {\mathcal {L}} which are subsets of W. Also, let w be the last vertex selected by the picking process, i.e., P_s = \{w\}. Next lemmas present some properties of vertex w and laminar collections {\mathcal {L}} and {\mathcal {B}}.

Lemma 18
Let  and suppose L contains a vertex in V(T) and a vertex v \in W \setminus V(T). If no subset in  contains v, then {w \in L}.

Proof
Let D_1, \dots , D_{\ell +1} be the computed subset path and recall that T is a subgraph of . Since no subset in  contains v, the pruning algorithm has not deleted v, and thus v \in V(H_t). Because L\subseteq W, we have v \in D_t. This implies that L was considered by the picking process, playing the role of S in some iteration, and because not all vertices in L \cap D_t were selected, all the remaining vertices of T were picked from L. Therefore, w \in L. \square

Next lemma shows that the only processed subsets in  with degree one in T which are not pruned from T are those containing w.

Lemma 19
Let . If |\delta _T(B)| = 1, then w \in B.

Proof
Remember that the algorithm computes a subset path D_1, \dots , D_{\ell +1} of a tree  processed with , where  if \sigma is a subset, and  for some edge e if \sigma is an edge. Define . Let K be the path in T starting at the root r and ending at w, and observe that there is a vertex v_t \in V(K) such that H_t is pruned with .

Let  with |\delta _T(B)| = 1, and suppose for a contradiction that w \notin B. If |\delta _T(B)| = |\delta _{H_t}(B)|, then v_t \in B, and there are two edge-disjoint paths crossing B, one from w to v_t and other from v_t to the root r. This is not possible because |\delta _T(B)| = 1. Therefore, |\delta _T(B)| \ne |\delta _{H_t}(B)|, and thus |\delta _{H_t}(B)|\ge 2.

Observe that K contains all edges connecting adjacent subsets D_i and D_{i+1}, for i \ge 1. It follows that B \subseteq D_j for some j \ge t, because B does not contain a vertex of K. If j \ge t + 1, then we would have {|\delta _{H_t}(B)| = |\delta _T(B)|}, a contradiction. Thus, assume that j = t and B \subseteq D_t.

Because T spans vertices in B and B \subseteq D_t, these vertices were selected by the picking process. Let m be the number of vertices still needed at the iteration which considered subset B. If m \le |B\cap D_{t}|, then all the m remaining vertices of T were picked from B\cap D_{t}, and thus w \in B. Otherwise, all the vertices of B \cap D_{t} were picked, and T has two edges leaving B, which is a contradiction since |\delta _T(B)| = 1.

\square

Next lemma extracts the critical property of the tree output by the algorithm, which is used to bound the solution cost. For some collection of subsets {\mathcal {L}}, denote by {\mathcal {L}}_w the collection of subsets in {\mathcal {L}} which contain vertex w. Thus, {\mathcal {L}}_w[W] contains all subsets in {\mathcal {L}} which are subsets of W and contain w.

Lemma 20
Consider the execution of \mathtt {GP} which returned , and let {\mathcal {A}} be the collection of active subsets that contain some vertex of T at the beginning of an iteration. Then,

\begin{aligned} \sum _{A \in {\mathcal {A}}}|\delta _T(A)| \le 2 (|{\mathcal {A}}| - |{\mathcal {A}}_w[W]|). \end{aligned}
Proof
Let D_1, D_2, \dots , D_{\ell +1} be the subset path computed by the algorithm, and define  for each 1 \le i \le \ell . Observe that T is a subgraph of H_t, and remember that W is the subset in  associated with D_t, such that H_{t+1} = H_t - W and |\delta _{H_t}(W)| = 1. Also, let P_1, P_2, \dots , P_s be the sequence of subsets picked from , such that P_s = \{w\}. By Lemma 19, any subset in  with degree one in T contains w.

Consider the laminar collection  at the beginning of an iteration of \mathtt {GP}, and let {\mathcal {A}} be the collection of maximal subsets in  which are active and contain some vertex of T, and {\mathcal {I}} be the collection of maximal subsets in  which are not active and contain some vertex of T. Note that {\mathcal {A}}\cup {\mathcal {I}} partitions V(T). If we contract on T each subset in {\mathcal {A}}\cup {\mathcal {I}}, obtaining a graph T', then each vertex of T' corresponding to a subset S will have degree |\delta _T(S)|.

Observe that an active subset is a maximal subset of the laminar collection at the beginning of the iteration, thus the subsets in {\mathcal {A}} are disjoint, and then {|{\mathcal {A}}_w[W]| \le 1}. We are also interested in counting the vertices of T' with degree one which correspond to non-active subsets, thus let {\mathcal {I}}_1 be the collection of subsets {S\in {\mathcal {I}}} with {|\delta _T(S)| = 1}. Because each subset in {\mathcal {I}}_1 is in  and has degree one in T, we know that w \in S for every S \in {\mathcal {I}}_1, by Lemma 19.

We break the proof into two cases, depending on whether T' is a tree.

Case 1: The contracted graph T' is a tree.

We claim that |{\mathcal {I}}_1| + |{\mathcal {A}}_w[W]| \le 1. This means that there is at most one non-active subset with degree one, and, if there is one, then there are no active subsets of W containing w. Indeed, if {\mathcal {I}}_1 contains some subset S, then w \in S, and thus no active subset contains w. Otherwise, |{\mathcal {I}}_1|=0, and the claim holds because |{\mathcal {A}}_w[W]| \le 1.

Since T' is a tree, it follows that

\begin{aligned} \sum _{A \in {\mathcal {A}}}|\delta _T(A)| + 2|{\mathcal {I}}| - |{\mathcal {I}}_1|&\le \sum _{A \in {\mathcal {A}}}|\delta _T(A)| + \sum _{I \in {\mathcal {I}}}|\delta _T(I)| = 2(|{\mathcal {A}}| + |{\mathcal {I}}| - 1) \\&\le 2(|{\mathcal {A}}| + |{\mathcal {I}}| - |{\mathcal {I}}_1| -|{\mathcal {A}}_w[W]|), \end{aligned}
which implies \sum _{A \in {\mathcal {A}}}|\delta _T(A)| \le 2(|{\mathcal {A}}| -|{\mathcal {A}}_w[W]|), thus the lemma holds in this case.

Case 2: The contracted graph T' has a cycle.

Because T' has a cycle, there exists some maximal subset L in {\mathcal {A}}\cup {\mathcal {I}} which induces a disconnected subgraph T[L]. Since  is L-connected by invariant (gp3), we know that  is connected, thus H[V(T)\cup L] has a cycle C whose vertices intersect L, and then  contains C as well. Observe that this case can occur only when \sigma is an edge, and  is in C. Because T contains at most one edge that is not in , the contracted tree T' contains at most one cycle. Also, note that T[L] has only two components, since otherwise H would have two cycles.

Recall that C has the edge . Suppose, for a contradiction, that both extremes of  are contained in the same maximal subset S \in {\mathcal {A}}\cup {\mathcal {I}}. Then, because  is S-connected, H[S] would contain a cycle which is not C. Since there is only one cycle, this is not possible, and we conclude that  connects consecutive maximal subsets in the cycle. Therefore,  is an edge of T', and at least one extreme of  is not in L.

We claim that W contains some but not all vertices of C. Observe that D_t spans vertices of C, since otherwise C would be contained in D_1, D_2, \dots , D_{t-1}, by Lemma 17, and thus T would not span vertices of C. Since D_t is a subset of W, it follows that W spans vertices of C. Now, also by Lemma 17,  connects consecutive subsets D_i to D_{i+1} for some i \ge 1. Then T contains vertices of both D_i and D_{i+1}, and it follows that t \le i, since D_t is the first subset of the subset path containing vertices of T. Therefore, W cannot contain all vertices of C, because D_{i+1} \subseteq V(H_{i+1}) and H_{i+1} does not contain vertices of W.

It follows that the cut \delta _{C}(W) contains two edges of C. Since {|\delta _T(W)| = 1}, both edges cannot be edges of T, thus W contains some vertex v_1 in L. Let L_1 and L_2 be the two connected components of T[L]. Suppose without loss of generality that v_1 \in L_1 and let v_2 \in L_2. Because there is no path from v_1 to v_2 in , it follows that v_2 \in D_j for some j > t. Thus, v_2 \notin B_t = W. Now v_1 \in L \cap W, and v_2 \in L \setminus W. Since  is laminar, W \subseteq L.

Figure 8 illustrates T with maximal subsets in dashed lines whose contraction resulted in a graph T' with a cycle.

Fig. 8
figure 8
A graph T' with a cycle

Full size image
This implies |{\mathcal {A}}_w[W]| = 0, since {\mathcal {A}}_w[W] contains only subsets of W. Also, |{\mathcal {I}}_1| = 0, because the maximal subset containing w is L, which has degree at least 2. Using the fact that in this case T' has exactly one cycle, we get

\begin{aligned} \sum _{A \in {\mathcal {A}}}|\delta _T(A)| + 2|{\mathcal {I}}|&\le \sum _{A \in {\mathcal {A}}}|\delta _T(A)| + \sum _{I \in {\mathcal {I}}}|\delta _T(I)| = 2(|{\mathcal {A}}| + |{\mathcal {I}}|) \\&= 2(|{\mathcal {A}}| + |{\mathcal {I}}| -|{\mathcal {A}}_w[W]|), \end{aligned}
which implies \sum _{A \in {\mathcal {A}}}|\delta _T(A)| \le 2(|{\mathcal {A}}| -|{\mathcal {A}}_w[W]|), completing the lemma. \square

The 2-Approximation
This section wraps up the whole algorithm. First, we bound the cost of the tree output by \mathtt {PV}. Then, we show how to use this bound to find a tree whose cost is within factor 2 of an optimal solution for k-PCST.

Bounding the Cost of the Tree
We adopt the same definitions introduced in Sect. 5, except that, to simplify the notation, for the remainder of this section, we let . Recall that {\mathcal {L}}(S) denotes the collection of subsets in {\mathcal {L}} that contains some, but not all vertices of S, that {\mathcal {L}}[S] denotes the collection of subsets in {\mathcal {L}} which are subsets of S, and that {\mathcal {L}}_w is the collection of subsets in {\mathcal {L}} that contain w. Next two lemmas bound the cost of edges and vertex penalties of the tree output by \mathtt {PV}.

Lemma 21
Let T be the tree returned by \mathtt {PV}({\lambda },{\tau }), then


Proof
By Lemma 10, we have that the vectors y computed in the growth-phases \mathtt {GP}({\lambda },{\tau }) and \mathtt {GP}({\lambda },{\widetilde{\tau }}) are the same. Since , each edge of T is tight, thus


We prove by induction that, at the beginning of each iteration of \mathtt {GP}({\lambda },{\tau }),


At the beginning of the growth-phase, y = 0, then the inequality holds. Thus, assume that the inequality holds at the beginning of an iteration, and let {\mathcal {A}} be the collection of active subsets that contain some vertex of T.

Notice that, if some maximal subset S contains V(T), then S \notin {\mathcal {L}}(V(T)). Also, any such subset contains both r and w, thus S \notin {\mathcal {L}}_w[W], because {\mathcal {L}} is laminar. Therefore, if V(T) is contained in some maximal subset, then neither the left nor the right side of the inequality changes. Hence, we can assume that no active subset contains V(T). It follows that {{\mathcal {A}}\subseteq {\mathcal {L}}(V(T))} and that {{\mathcal {A}}_w[W] \subseteq {\mathcal {L}}_w[W]}. Suppose that, in this iteration, the variable y_L of each active subset L is increased by \varDelta . Then, the left side of the inequality is increased by {\sum _{A \in {\mathcal {A}}}|\delta _T(A)|\varDelta }, while the right side is increased by {2 (|{\mathcal {A}}| - |{\mathcal {A}}_w[W]|) \varDelta }. By Lemma 20, the increase on the left side is smaller, thus the inequality is maintained at the end of the iteration. \square

Lemma 22
Let T be the tree returned by \mathtt {PV}({\lambda },{\tau }), then


Proof
We partition W into three parts, P, I, and Q, corresponding to the set of vertices whose penalties can be paid by some processed component which is a proper subset of W \setminus V(T), the intersection with T, and the vertices which are not paid. More precisely, define


First, we consider the vertices of W which are not paid. Since W is tight for (y,{\lambda }) and y respects \pi ^{\lambda }, it follows that

\begin{aligned} \pi ^{\lambda }_{Q} = \pi ^{\lambda }_W - \pi ^{\lambda }_{P \cup I}&\le \sum _{L \in {\mathcal {L}}[W]} y_L - \sum _{L \in {\mathcal {L}}[P\cup I]} y_L. \end{aligned}
(3)
Denote by {\mathcal {P}} the collection of subsets in {\mathcal {L}}[P\cup I] that contain a vertex in P and a vertex in I. Then {\{{\mathcal {L}}[P], {\mathcal {L}}[I], {\mathcal {P}}\}} partitions the collection {{\mathcal {L}}[P\cup I]}. Similarly, denote by {\mathcal {W}} the collection of subsets in {\mathcal {L}}[W] that contain a vertex in {P \cup Q} and a vertex in I. Then {\{{\mathcal {L}}[P \cup Q], {\mathcal {L}}[I],{\mathcal {W}}\}} partitions the collection {\mathcal {L}}[W].

We claim that {\mathcal {W}}\setminus {\mathcal {P}}\subseteq {\mathcal {L}}_w[W]. To see this, consider a subset {L \in {\mathcal {W}}\setminus {\mathcal {P}}}. Since L contains a vertex in I, but is not in {\mathcal {P}}, it does not contain a vertex in P. It follows that L contains a vertex of v \in Q. Because v \in W \setminus V(T) and no subset in  contains v, Lemma 18 implies that {w \in L}. Therefore, L \in {\mathcal {L}}_w[W], and then {{\mathcal {W}}\setminus {\mathcal {P}}\subseteq {\mathcal {L}}_w[W]}.

We can simplify the indices in the summation (3) as

\begin{aligned} {\mathcal {L}}[W] \setminus {\mathcal {L}}[P \cup I]&= ({\mathcal {L}}[P \cup Q] \cup {\mathcal {L}}[I] \cup {\mathcal {W}}) \setminus ({\mathcal {L}}[P] \cup {\mathcal {L}}[I] \cup {\mathcal {P}})\\&\subseteq ({\mathcal {L}}[P \cup Q] \cup {\mathcal {L}}_w[W]) \setminus {\mathcal {L}}[P]. \end{aligned}
Now, we consider the vertices which are paid, i.e., vertices not spanned by T which are contained in some subset . In addition to vertices P, the vertices in {R = V \setminus (V(T) \cup W)} are also paid. Note that any vertex in R was deleted by the pruning algorithm, thus every vertex in R is indeed contained in some subset in  which contains no vertex in V(T) \cup W. Hence, there is a collection \{B_1,B_2,\dots ,B_m\} of processed subsets in  that partitions the vertices in R. By similar arguments, there is also a collection \{B_{m+1},B_{m+2},\dots ,B_\ell \} of subsets in  that partitions the vertices in P. Thus, since each such subset is tight for (y,{\lambda }),

\begin{aligned} \pi ^{\lambda }_{R \cup P}&= \sum _{i=1}^\ell \pi ^{\lambda }_{B_i} = \sum _{i=1}^\ell \sum _{L \in {\mathcal {L}}[B_i]} y_L =\sum _{L \in {\mathcal {L}}[R]\cup {\mathcal {L}}[P]} y_L. \end{aligned}
(4)
Since the collections of summations (3) and (4) are disjoint,

\begin{aligned} ({\mathcal {L}}[W] \setminus {\mathcal {L}}[P \cup I]) \cup ({\mathcal {L}}[R]\cup {\mathcal {L}}[P])&\subseteq {\mathcal {L}}[P \cup Q] \cup {\mathcal {L}}_w[W] \cup {\mathcal {L}}[R]\\&\subseteq {\mathcal {L}}[V \setminus V(T)] \cup {\mathcal {L}}_w[W]. \end{aligned}
By combining (3) and (4), we conclude

\begin{aligned} \pi ^{\lambda }_{V \setminus V(T)}&=\pi ^{\lambda }_{Q} + \pi ^{\lambda }_{R \cup P} \le \sum _{L \in {\mathcal {L}}[V \setminus V(T)]} y_L + \sum _{L \in {\mathcal {L}}_w[W]} y_L. \end{aligned}
\square

Combining the bounds from the previous two lemmas, one obtains the following corollary.

Corollary 6
Let T be the tree returned by \mathtt {PV}({\lambda },{\tau }), then


The Approximation Algorithm
Next lemma is the final ingredient of our 2-approximation.

Lemma 23
Let T be the tree returned by \mathtt {PV}({\lambda },{\tau }), and T^* be an optimal solution. Also, suppose that L^* is the minimal subset in {\mathcal {L}} containing V(T^*). If L^* = V, then

\begin{aligned} c_{E(T)} + 2 \pi _{V \setminus V(T)} \le 2 \left( c_{E(T^*)} + \pi _{V \setminus V(T^*)} \right) . \end{aligned}
Proof
Assume V = L^*. Since T spans exactly k vertices and T^* spans at least k vertices, we have {|V \setminus V(T)| \ge |V \setminus V(T^*)|}. Therefore,

\begin{aligned} c_{E(T)} + 2 \pi _{V \setminus V(T)}&= c_{E(T)} + 2 \pi ^{\lambda }_{V \setminus V(T)} - 2 {\lambda }|V \setminus V(T)|\\&\le c_{E(T)} + 2 \pi ^{\lambda }_{V \setminus V(T)} - 2 {\lambda }|V \setminus V(T^*)|\\&\le \textstyle 2 \sum _{L \in {\mathcal {L}}(V)} y_L - 2 {\lambda }|V \setminus V(T^*)|\\&\le 2 \left( c_{E(T^*)} + \pi _{V \setminus V(T^*)} \right) , \end{aligned}
where the penultimate inequality follows from Corollary 6, and the last inequality follows from Lemma 1, because y respects c and \pi ^{\lambda }. \square

We finally present our 2-approximation, which is denoted by \mathtt {2\text{- }APPROX}. A listing is given in Algorithm 6.

The algorithm will compute a series of trees, the best of which will be the output. In each iteration, start by computing a tree executing \mathtt {GW}(0,\emptyset ), and, if it already spans at least k vertices, then store this tree and stop the iteration process. Otherwise, there is a threshold-tuple ({\lambda },{\tau }), by Lemma 13, which can be computed by \mathtt {TS}. Now, store the tree returned by \mathtt {PV}({\lambda },{\tau }) and let {\mathcal {L}} be the laminar collection used by \mathtt {PV}({\lambda },{\tau }) when computing this tree. Find the subset L_r \in {\mathcal {L}} which is the inclusion-wise maximal proper subset of V containing the root r. If |L_r| < k, then stop; otherwise, remove from G any vertex not in L_r, i.e., repeat the iteration process with G[L_r].

Observe that at least one vertex is deleted in each iteration, and the reduced graph is connected because it is {\mathcal {L}}-connected. Thus, the algorithm stops, and the output is the computed tree T which minimizes the cost with respect to the original graph G. We argue why T is a 2-approximation. Let T^* be an optimal solution with respect to G and consider the last iteration which processed some subgraph G' containing T^*. If the algorithm stopped in this iteration after computing a tree using \mathtt {GW}(0,\emptyset ), then Lemma 7 implies that this tree is a 2-approximation with respect to G'. Otherwise, the inclusion-wise minimal subset containing T^* is V(G'), and Lemma 23 implies that the tree computed by \mathtt {PV}({\lambda },{\tau }) is a 2-approximation with respect to G'. Now, note that a 2-approximation with respect to G' is also a 2-approximation with respect to G.

Theorem 1
If T is the tree returned by \mathtt {2\text{- }APPROX}, and T^* is an optimal solution, then

\begin{aligned} c_{E(T)} + 2 \pi _{V \setminus V(T)} \le 2 \left( c_{E({T^*})} + \pi _{V \setminus V(T^*)} \right) . \end{aligned}
figure f
Final Remarks
In this paper, we presented a 2-approximation for the k-PRIZE-COLLECTING STEINER TREE PROBLEM. This improves over the previous best known approximation factor [15], and has a smaller running time. Observe that \mathtt {2\text{- }APPROX} iterates for {\mathcal {O}}(|V|) times, and the time complexity of each iteration is dominated by the subroutine \mathtt {TS}, whose running time is {\mathcal {O}}(|V||E|^2 + |V|^3 \log ^2|V|). Thus, our algorithm runs in time {{\mathcal {O}}(|V|^2|E|^2 + |V|^4 \log ^2|V|)}.

Variants of the PRIZE-COLLECTING STEINER TREE PROBLEM are among the most classical network design problems, and have long been studied from both practical and theoretical perspectives. In this paper we considered only the version of PCST with a cardinality constraint, but similar techniques can be applied to other connectivity problems, particularly those for which the primal-dual framework has been used [12]. Although the algorithm is based on the primal-dual framework, it does not use an \mathrm {LP} formulation. We note that the standard integer linear program for k-PCST [13] has integrality gap of at least 4.

Johnson et al. [14] also considered the quota version of k-MST, in which each vertex v has an associated non-negative integer weight w_v and a solution is a minimum-cost tree with any number of vertices, such that the total weight of the vertices in the tree is at least some given quota. Note that k-MST is the special case in which the quota is k and every vertex has weight one. A small modification of our algorithm also leads to a 2-approximation for the quota variant of k-PCST. To do this, build an equivalent instance of k-PCST by replacing each vertex v with w_v copies at the same location, and observe that, although the size of this instance is not necessarily polynomial, the growth-phase and picking-vertices can be simulated in polynomial time.

References
Archer, A., Bateni, M., Hajiaghayi, M., Karloff, H.: Improved approximation algorithms for prize-collecting steiner tree and tsp. SIAM J. Comput. 40(2), 309â€“332 (2011). https://doi-org.ezproxy.auckland.ac.nz/10.1137/090771429

MathSciNet
 
Article
 
MATH
 
Google Scholar
 

Arora, S., Karakostas, G.: A 2 + \varepsilon approximation algorithm for the k-mst problem. Math. Program. 107(3), 491â€“504 (2006). https://doi-org.ezproxy.auckland.ac.nz/10.1007/s10107-005-0693-1

MathSciNet
 
Article
 
MATH
 
Google Scholar
 

Arya, S., Ramesh, H.: A 2.5-factor approximation algorithm for the k-mst problem. Inf. Process. Lett. 65(3), 117â€“118 (1998). https://doi-org.ezproxy.auckland.ac.nz/10.1016/S0020-0190(98)00010-6

Awerbuch, B., Azar, Y., Blum, A., Vempala, S.: New approximation guarantees for minimum-weight k-trees and prize-collecting salesmen. SIAM J. Comput. 28(1), 254â€“262 (1998)

MathSciNet
 
Article
 
Google Scholar
 

Bienstock, D., Goemans, M.X., Simchi-Levi, D., Williamson, D.: A note on the prize collecting traveling salesman problem. Math. Program. 59(1), 413â€“420 (1993). https://doi-org.ezproxy.auckland.ac.nz/10.1007/BF01581256

MathSciNet
 
Article
 
MATH
 
Google Scholar
 

Blum, A., Ravi, R., Vempala, S.: A constant-factor approximation algorithm for the k-mst problem. J. Comput. Syst. Sci. 58(1), 101â€“108 (1999). https://doi-org.ezproxy.auckland.ac.nz/10.1006/jcss.1997.1542

MathSciNet
 
Article
 
MATH
 
Google Scholar
 

Byrka, J., Grandoni, F., Rothvoss, T., SanitÃ , L.: Steiner tree approximation via iterative randomized rounding. J. ACM 60(1), 6:1â€“6:33 (2013). https://doi-org.ezproxy.auckland.ac.nz/10.1145/2432622.2432628.

Chudak, F.A., Roughgarden, T., Williamson, D.P.: Approximate k-msts and k-Steiner trees via the primal-dual method and Lagrangean relaxation. Math. Program. 100(2), 411â€“421 (2004). https://doi-org.ezproxy.auckland.ac.nz/10.1007/s10107-003-0479-2

MathSciNet
 
Article
 
MATH
 
Google Scholar
 

Feofiloff, P., Fernandes, C.G., Ferreira, C.E., de Pina, J.C.: A note on Johnson, Minkoff and Phillipsâ€™ algorithm for the prize-collecting steiner tree problem. CoRR abs/1004.1437 (2010). arXiv:1004.1437

Garg, N.: A 3-approximation for the minimum tree spanning k vertices. In: Proceedings of the 37th Annual Symposium on Foundations of Computer Science, FOCS â€™96, p. 302. IEEE Computer Society, Washington, DC, USA (1996). http://dl.acm.org.ezproxy.auckland.ac.nz/citation.cfm?id=874062.875522

Garg, N.: Saving an epsilon: A 2-approximation for the k-mst problem in graphs. In: Proceedings of the Thirty-seventh Annual ACM Symposium on Theory of Computing, STOC â€™05, pp. 396â€“402. ACM, New York, NY, USA (2005). https://doi-org.ezproxy.auckland.ac.nz/10.1145/1060590.1060650. http://doi.acm.org/10.1145/1060590.1060650

Goemans, M., Williamson, D.: A general approximation technique for constrained forest problems. SIAM J. Comput. 24(2), 296â€“317 (1995). https://doi-org.ezproxy.auckland.ac.nz/10.1137/S0097539793242618

MathSciNet
 
Article
 
MATH
 
Google Scholar
 

Han, L., Xu, D., Du, D., Wu, C.: A 5-approximation algorithm for the k-prize-collecting Steiner tree problem. Optim. Lett. (2017). https://doi-org.ezproxy.auckland.ac.nz/10.1007/s11590-017-1135-8

Johnson, D.S., Minkoff, M., Phillips, S.: The prize collecting Steiner tree problem: theory and practice. In: Proceedings of the Eleventh Annual ACM-SIAM Symposium on Discrete Algorithms, SODA â€™00, pp. 760â€“769. Society for Industrial and Applied Mathematics, Philadelphia, PA, USA (2000). http://dl.acm.org.ezproxy.auckland.ac.nz/citation.cfm?id=338219.338637

Matsuda, Y., Takahashi, S.: A 4-approximation algorithm for k-prize collecting Steiner tree problems. Optim. Lett. 13(2), 341â€“348 (2019). https://doi-org.ezproxy.auckland.ac.nz/10.1007/s11590-018-1367-2

MathSciNet
 
Article
 
MATH
 
Google Scholar
 

Oshiro, M.T.I.: k-Ãrvores de custo mÃ­nimo. Masterâ€™s thesis, Universidade de SÃ£o Paulo, Instituto de MatemÃ¡tica e EstatÃ­stica (2010)

Ravi, R., Sundaram, R., Marathe, M.V., Rosenkrantz, D.J., Ravi, S.S.: Spanning treesâ€“short or small. SIAM J. Discret. Math. 9(2), 178â€“200 (1996)

MathSciNet
 
Article
 
Google Scholar
 

Williamson, D.P., Shmoys, D.B.: The Design of Approximation Algorithms, 1st edn. Cambridge University Press, New York (2011)

Book
 
Google Scholar
 

Download references

Author information
Affiliations
Institute of Computing, University of Campinas, Campinas, Brazil

Lehilton Lelis Chaves Pedrosa & Hugo Kooki Kasuya Rosado

Corresponding author
Correspondence to Hugo Kooki Kasuya Rosado.

Additional information
Publisher's Note
Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.

Supported by SÃ£o Paulo Research Foundation (FAPESP) grant #2015/11937-9 and National Council for Scientific and Technological Development (CNPq) grants #425340/2016-3, #422829/2018-8, #140552/2019-7, and #312186/2020-7.

Proof of Lemma 7
Proof of Lemma 7
In this appendix, we prove Lemma 7. We show that, if \mathtt {GW}(0,\emptyset ) returns a tree T with at least k vertices, then T is a 2-approximation. The proof is adapted from [9].

Let (T,{\mathcal {B}}) be the tuple returned by \mathtt {GP}(0,\emptyset ), and remember that the growth-phase computes a corresponding laminar collection {\mathcal {L}} associated with vector y. Also, let  be the output of \mathtt {GW}(0,\emptyset ), and observe that  is the tree returned by \mathtt {PP}(T,{\mathcal {B}}).

Recall that {\mathcal {L}}(S) denotes the collection of subsets in {\mathcal {L}} which contain some but not all vertices of a subset S, and that {{\mathcal {L}}_v} denote the collection of subsets in {\mathcal {L}} which contain a vertex v. Thus, {\mathcal {L}}_r(S) is the collection of subsets in {\mathcal {L}}(S) which contain the root r.

We bound the cost of  into two steps. Lemma 1 bounds the cost of edges of , and Lemma 2 bounds the penalty of vertices not in .

Lemma 1
Let  be the tree returned by \mathtt {GW}(0,\emptyset ), then


Proof
Since every edge in  is tight for (y, 0), we have


We prove by induction that, at the beginning of each iteration of \mathtt {GP}(0,\emptyset ),


At the beginning of the growth-phase, y = 0, then the inequality holds. Thus, assume that the inequality holds at the beginning of an iteration. Consider the laminar collection {\mathcal {L}} at the beginning of this iteration, let {\mathcal {A}} be the collection of active maximal subsets in {\mathcal {L}}^* which contain some vertex of , and let {\mathcal {I}} be the collection of non-active maximal subsets in {\mathcal {L}}^* which contain some vertex of .

If some maximal subset in {\mathcal {L}}^* contains , then neither side of the inequality changes, thus assume that no maximal subset contains . Suppose that the variable y_L of each active subset L is increased by \varDelta in this iteration. Hence, the left side of the inequality increases by , and the right side increases by 2 |{\mathcal {A}}\setminus {\mathcal {A}}_r|\varDelta . We claim that


and thus the inequality is maintained at the end of the iteration.

Note that {\mathcal {A}}\cup {\mathcal {I}} partition . Thus, we can create a graph T' from  by contracting each subset in {\mathcal {A}}\cup {\mathcal {I}}. As  is a tree and a subgraph of T, it follows that the graph T' is a tree because T is {\mathcal {L}}-connected by invariant (gp3). Let S be a non-active subset in {\mathcal {I}}, and observe that S is in {\mathcal {B}}. Since  is pruned with {\mathcal {B}}, Corollary 2 implies that the degree of S on  is not one. Therefore, the degree of each vertex of T' corresponding a subset in {\mathcal {I}} is at least 2. It follows that


Since the subset containing the root r is always active, exactly one subset in {\mathcal {A}} contains r, hence {|{\mathcal {A}}\setminus {\mathcal {A}}_r| = |{\mathcal {A}}|-1}, and thus , which shows the claim. \square

Lemma 2
Let  be the tree returned by \mathtt {GW}(0,\emptyset ), then


Proof
By Corollary 1, every vertex not spanned by T is contained in a subset in {\mathcal {B}}, and since \mathtt {PP}(T,{\mathcal {B}}) only deletes from T subsets in {\mathcal {B}}, we have that every vertex not spanned by  is contained in a subset in {\mathcal {B}}. Since {\mathcal {B}} is laminar, there is a collection \{B_1,\cdots ,B_m\} of subsets in {\mathcal {B}} which partitions the vertices in . Because every subset in {\mathcal {B}} is tight for (y, 0),


\square

Now, we can prove Lemma 7.

Lemma 7 Let  be the tree returned by \mathtt {GW}(0,\emptyset ), and T^* be an optimal solution. Then,


Proof
Let L^* be the minimal subset in {\mathcal {L}} containing all the vertices of T^*. Also, let {\mathcal {P}} be the collection of subsets in {\mathcal {L}} which contain all the vertices of L^*. Observe that \{{\mathcal {L}}(L^*),{\mathcal {L}}[V \setminus L^*],{\mathcal {P}}\} partitions {\mathcal {L}}. Also, since L^* contains r, it follows that {{\mathcal {P}}\subseteq {\mathcal {L}}_r}.

Combining Lemmas 1 and 2 we have


Observe that the subsets considered in the terms are disjoint. Thus, we can simplify the indices of the summation as


Now, since y respects c and \pi ^0, using Lemma 1 for {\lambda }= 0,


\square

