
Abstract
We present a formalism to represent cyclic models and study different semantic frameworks that support testing. These models combine sequences of observable actions and the passing of (discrete) time and can be used to specify a number of classes of reactive systems, an example being robotic systems. We use implementation relations in order to formally define a notion of correctness of a system under test (SUT) with respect to a specification. As usual, the aim is to devise an extension of the classical ioco implementation relation but available timed variants of ioco are not suitable for cyclic models. This paper thus defines new implementation relations that encapsulate the discrete nature of time and take into account not only the actions that models can perform but also the ones that they can refuse. In addition to defining these relations, we study a number of their properties and provide alternative characterisations, showing that the relations are appropriate conservative extensions of trace containment. Finally, we give test derivation algorithms and prove that they are sound and also are complete in the limit.

Keywords
Model-based testing
Implementation relations
Cyclic systems

1. Introduction
Cyclic systems (Bożejko and Bocewicz, 2019) operate in cycles of the following form: read values from sensors (inputs), perform calculations, then write values to actuators (outputs). The corresponding models typically combine actions into a single step and a behaviour is then a sequence of steps, with time passing between steps. The importance of these models lies in their relevance to a range of systems (e.g. embedded control systems) including those used in robotics. This form of models is found with languages, such as Statecharts (Harel, 1987), that have a step semantics.

The aim of the work, we are going to discuss, is to define formal, automated, approaches to testing that fit into the standard robotics development process. Typically, a robotic system will be modelled as a state machine. Afterwards, a simulation model is produced, which is used to validate the original model. The simulation model can also be used to drive the testing of the developed system; a point of particular relevance to this paper. In contrast to the analysis of many systems where time can be (at least partially) abstracted, time plays a fundamental role in cyclic systems and must be treated as a first-class citizen. In the simulations, time is discrete and each time slot contains a sequence of actions. The use of robotic systems is expanding in areas such as manufacturing, healthcare, transport and home assistance. For example, the sales of these systems increased by 30% in 2017 and this represented a new record for the fifth year in a row (World Robotics, 2018). This trend is steady and, according to a UK government report,1 the value of the global market for robotics and autonomous systems is expected to reach £13 billion by 2025.

The work described in this paper came out of the early stages of a project in the area of testing robotic systems. The motivation was to provide a foundational testing theory on which to base sound automated testing. The formalism used is the syntactically simplest one that captures the features required; syntactic simplicity is beneficial since it facilitates formal reasoning. The formalism also has the advantage that it corresponds to the form of operational semantics given to the models from which we wish to test.2

The overall line of work was motivated by several factors. First, robotic systems are ubiquitous in safety-critical areas and it is of the utmost importance to increase the confidence in the correctness of these systems. It is becoming widely recognised, not only in academia but also in industry, that the use of formal methods increases the reliability of the developed systems (Bonfanti et al., 2018, Fitzgerald et al., 2013, Newcombe et al., 2015). As a result, since software testing (Ammann and Offutt, 2017, Myers et al., 2011) is the main software validation technique, the combination of formal methods and testing is a promising approach to analyse the behaviour of systems; this is the second factor that motivated the work. Note that although testing was initially considered to be a mainly manual and informal activity, many formal approaches to testing have been defined and applied (Binder et al., 2015, Cavalli et al., 2015, Hierons et al., 2009, Hierons et al., 2008).

Formal approaches to testing usually rely on state-based models, that is, models that are in the form of labelled transition systems (LTSs); these models have states and labelled transitions between the states and there are many tools to support testing (Marinescu et al., 2015, Shafique and Labiche, 2015). In testing from an LTS, it is normal to assume that the system under test (SUT) behaves like an unknown LTS (this is called the minimal test hypothesis ISO/IEC JTCI/SC21/WG7, ITU-T SG 10/Q.8, 1996). So, testing involves comparing two LTSs to decide whether the first (unknown) one is correct with respect to the second one. The relation between LTSs, that describes what we mean by correctness, is usually formalised as an implementation relation. The literature provides a myriad of implementation relations for LTSs (Glabbeek, 1993, Glabbeek, 2001), where the difference between them strongly depends on the observational power of the observer.

In this paper we introduce a framework to specify and validate robotic systems described as cyclic models. The ultimate goal is to provide techniques and tools that can be used to make the development of robotic systems more efficient and effective, through removing the need for several manual, error prone activities. Next we enumerate the main contributions. First, we introduce a state-based formalism, tockLTS, to specify cyclic models. The tockLTS formalism corresponds to the one underlying the operational semantics of tock-CSP (Roscoe, 2010 Chapter 14), a timed variant of CSP. This process algebra is used to give semantics to RoboSim (Cavalcanti et al., 2019b), a language used to define simulation models in robotics. Note that we consider tockLTS, instead of RoboSim, because it has a simpler syntax but also is more general. In fact, we expect that it will be relatively easy to adapt our framework to other simulation languages and to languages having a cyclic nature and a step semantics (e.g. Statecharts Harel, 1987). Second, we define several implementation relations (notions of correctness). Having different notions of correctness is useful because the users of our framework can decide which one better suites their needs. There are several types of observations that can be made in the framework. As usual, we assume that it is possible to observe the actions that a system performs and also the passing of time. In addition, we also consider a notion of refusal; the observation that the system cannot perform certain actions. Our previous work shows that the use of refusals makes it possible to distinguish between distinct behaviours that otherwise would be identical. We study properties of these implementation relations, in particular, we show how they are related via containment and present alternative characterisations. Having defined implementation relations, the final contribution consists of a testing framework for each implementation relation. We provide such a framework and corresponding test derivation algorithms. These algorithms are sound: if the SUT does not pass one of the test cases produced by the algorithm then we know that the SUT is faulty. These algorithms are also exhaustive in the limit; if the SUT is faulty then it fails at least one test case that can be returned by the test generation algorithm. Observe that this means that finite test suites do not provide guaranteed fault detection effectiveness. However, this limitation is inevitable unless one introduces, for example, a finite fault model that restricts the class of faults that might occur. The approach is also common practice in ioco-based implementation relations (Tretmans, 2008), like the ones that we introduce in this paper; we discuss this further in Section 8 of the paper.

The choice of formalism was motivated by several factors. First, as previously noted, the work was developed within a robotics project and the aim was to use a formalism that would be familiar to roboticists but that could also be provided with a formal semantics (to support sound test generation and also formal verification). This led to the development of the RoboChart language, which is based on UML Statecharts; the view of colleagues working in robotics was that roboticists would not use languages, such as timed automata (Alur and Dill, 1994), that are less familiar. RoboChart models are mapped to RoboSim, in order to run simulations. Since we were initially interested in testing within a simulation, testing should be from RoboSim. However, it makes little sense to have a testing theory based on a language such as RoboSim, which has a rich syntax (so the theory would be complex and difficult to reason about). As a result, we based the testing theory on the syntactically simplest formalism that could capture the semantics of a RoboSim model. Note that, in addition, RoboSim models can be mapped to CSP specifications and the formalism used in this paper is inspired by CSP with discrete time (tock-CSP Roscoe, 2010, Chapter 14). The formalism essentially mirrors the operational semantics of tock-CSP but with one crucial difference: since we are interested in testing, it is necessary to have a semantics that reflects the different roles of inputs and outputs. As a result of the above, the testing theory developed can be used to reason about testing from RoboSim models and also as the basis for deriving suitable test cases from such models.3 The formalism used in this paper is also quite general, the hope being that it will be possible to use the proposed formalism to express the semantics of other models in languages similar to RoboChart and RoboSim and that the testing theory developed can then be applied.

Interestingly, the cyclic nature of the models makes them a little like Finite State Machines (FSMs), also called Mealy Machines (Mealy, 1955), in which there is a finite set of states, transitions between the states, and each transition has an input/output pair. There is a rich theory, and set of test generation techniques, associated with FSMs (see, for example, Hierons, 2019, Lee and Yannakakis, 1996, Petrenko and Yevtushenko, 2005). As a result, an alternative might have been to use FSMs. Unfortunately, FSMs do not provide a general solution. The first point is that a transition would not necessarily involve an input/output pair; it could have an arbitrarily long sequence of inputs and outputs. The first value in a sequence would be an input but after that the sequence could have outputs before inputs; the controllability of such sequences would be very different to that of transitions in Mealy Machines. In addition, the ‘transition structure’ taking one from state  to state 
 could contain cycles and so there may be infinitely many transitions between two states (as well as there potentially being infinitely many states). However, there may well be situations in which FSMs can be used and the corresponding theory and test generation algorithms would then have a number of benefits, such as there being algorithms that generate tests that are guaranteed to find all faults in a given fault model.

This paper represents a revised, extended and enhanced version of our recent work (Lefticaru et al., 2019). Next we briefly describe the main contributions with respect to the conference paper. First, we provide a more detailed and rigorous development of the two implementation relations previously given; one based on traces, the second with refusals included. In addition, for each implementation relation we consider the situation in which an input is not defined in a given state of the specification and alternatives that capture different context (ways in which incompleteness is handled). This leads to an additional two variants of each implementation relation previously given (Lefticaru et al., 2019) and we prove how these relate. We also define two testing frameworks, one for each implementation relation. We give associated automated test generation algorithms, proving that these are sound and also complete in the limit.

The rest of the paper is organised as follows. In Section 2 we briefly discuss the context in which our framework fits and the most relevant related work. In Section 3 we introduce the main definitions and concepts used. Based on these, in Section 4 we provide three implementation relations based around trace inclusion. Section 5 defines the most general type of observation (the notion of timed refusal traces). In Section 6 we introduce implementation relations based on timed refusal traces and show that they are strictly stronger than the corresponding relations from Section 4. In Section 7 we present alternative characterisations of the implementation relations from Section 6. Section 8 then explores test generation and finally, Section 9 provides conclusions and describe some lines for future work.

2. Technical context and related work
In order to develop robotic systems, it is usual to start with a state-based model. The work described in this paper was developed in the context of the state-based RoboChart language (Miyazawa et al., 2019), which allows models to be described in a way that is familiar to roboticists. A RoboChart model can be automatically mapped to a simulation model, in a language called RoboSim (Cavalcanti et al., 2019b), that is consistent with the original model. Simulation models are also given a formal semantics, making it possible to automatically analyse or reason about them. A formal semantics for RoboSim (Cavalcanti et al., 2019c) is given by mapping a RoboSim model to a variant of CSP, called tock-CSP (Roscoe, 2010 Chapter 14). The operational semantics of this language is, as usual, given in terms of an LTS. One of the benefits of this approach is that we can analyse the semantics of a RoboSim model using formal tools and methodologies available for CSP. As previously explained, in this paper we work with a formalism that is similar to these LTSs (it is actually a slight generalisation). Therefore, our framework can be directly applied to the development of robotic systems.

In testing we distinguish between inputs and outputs since these play different roles and this has led to implementation relations that were not classically considered (Glabbeek, 1993, Glabbeek, 2001). The best known implementation relation is ioco (Tretmans, 2008). There are three main differences between the classical definition of ioco and the implementation relations given in this paper. We present relations for timed systems where time is discrete, we are interested in using refusals while testing, and we do not assume that SUTs are input-enabled.

Concerning the last property, we do not assume that the SUT is input-enabled, that is, we do not impose the restriction that the SUT should be able to react to any input provided by the tester. This assumption (the SUT being input-enabled) makes sense for a range of systems and is based on the observation that the SUT will not block input. However, there are also systems that are not input-enabled and where this is deliberate. For example, certain options/fields might be greyed-out on a webpage or simply not available; consider, for instance, the options available to an editor and to an author in a journal’s manuscript system. In the context of autonomous systems, a system might switch off sensors and, in addition, sensors might fail. It is well-known that one can convert a model that is not input-enabled into one that is. However, in the type of systems that we consider in this paper, such a completed model would less appropriately model an SUT in which certain inputs are disabled and could lead to the generation of test cases that either do not make sense from a testing perspective or introduces redundancy. We consider an approach in which the absence of an input denotes that input is not allowed/possible but we also define more relaxed implementation relations that adapt the ioco approach to undefined inputs.

There are a number of options regarding the observational power of a user interacting with a system. An observer might only be allowed to observe the actions in which the system participates. However, we can increase the capabilities of observers. For example, we might consider situations in which it is possible to also observe the refusal of a set of actions, that is, those actions in which the system cannot participate at a certain point. In the scope of testing and process algebras, this is a well-known approach (Phillips, 1987), with some subtle differences with respect to the notion of must testing (de Nicola and Hennessy, 1984). In classical ioco, there is only one type of refusal, called quiescence, and this can be observed if the system is in a state where it cannot evolve via an internal action and, in addition, the system cannot produce an output without first receiving an input. The observation of the refusal of a set  is typically represented by the situation in which the environment chooses to only engage in the actions in  and the composition of the environment and the SUT deadlocks. A deadlock is usually observed through a timeout, similar to the process of observing quiescence in classical ioco, and this takes time. As a result, the observation of a deadlock (and so also a refusal) should precede a duration (an action representing a unit of time passing).

We are not aware of alternative approaches that consider models with the required features. Of particular interest is the combination of urgent outputs, refusals and discrete time. It is exactly this combination that we have to reason about for the models in which we are interested. There is a need for a formal testing theory for such models, in order to support the development of sound test generation algorithms and, ultimately, test generation and execution tools.

It is important to note that there is a variant of ioco including refusals and where systems need not be input-enabled (Heerink and Tretmans, 1997). We depart from this work in several lines (in addition to including time). First, our refusals are observed only in stable states4 and this has some implications. Specifically, an internal choice between outputs is equivalent to the same external choice while if we consider inputs then we obtain semantically different processes. Using a process algebraic notation, we have 
 while 
, where actions preceded by ? and ! denote, respectively, an input and an output, and  denotes an internal action. Second, their notion of a process being input-enabled is more restrictive than ours: at a certain port, either all the inputs are enabled or none of them is. In their notation, we have only one port and we allow several inputs to be enabled and several to not be.

Finally, ioco does not take into account time. Note that time cannot be taken as an ordinary action because it is neither an input, since the tester does not control it, nor an output, since the SUT does not control it (the SUT cannot, for example, stop time). There are several timed variants of ioco (all are typically called tioco) (Brandán Briones and Brinksma, 2004, Krichen and Tripakis, 2009, Schmaltz and Tretmans, 2008). The versions of tioco differ in a number of ways, including whether quiescence is a possible observation. It might be possible to use a version of tioco with discrete time, and in some situations this will be sufficient, but we prefer a native discrete time tioco (in addition, previous work does not consider a general notion of refusal).

From the above, one can see that a number of formalisms have been developed within the context of formal testing and these have corresponding implementation relations. However, it appears that they do not provide the combination of features required for the models in which we are interested. As a result, this paper develops a novel testing theory, with associated implementation relations, that builds on previous work on ioco and tioco.

3. Background and models
In this section we define the models and notation used in this paper along with some properties that we expect our systems to fulfil.

3.1. Cyclic models
As previously explained, the work in this paper is motivated by the nature of the types of models used with embedded control systems in areas such as robotics and the automotive industry. Such control systems operate in cycles of the following form.

1.
Read values from sensors (inputs).

2.
Perform calculations.

3.
Write values to actuators (outputs).

The corresponding models typically combine actions into a single step and a behaviour is then a sequence of steps, with time passing between steps. Such models can be found in robotics, with RoboCalc, RoboSim and models used in simulation packages (Rohmer et al., 2013) but also in a number of variations of Statecharts (Harel, 1987).

Example 1

This example is inspired from previous work (Cavalcanti et al., 2019a), which presented a simple rescue application that uses a drone to deliver some relief to a given target location. The complete model, described using the RoboChart language (Miyazawa et al., 2019), is more complex, comprising other elements like modules, robotic platforms or controllers. In Fig. 1 we present only an excerpt: the state machine model. It has four self-explanatory states: Off, Looking, Delivering, Returning. The RoboChart notation allows us to specify entry and during states, exit actions, transition actions, using events and operations. For example, the transitions in our model can be triggered by different events (e.g. switchOn or found when the target is found) and operations such as wait(TOP) (an action that pauses the system during TOP time units) or .

In the rest of this section we explain the formalisation we used. This is consistent with the above type of model but is rather more general than, for example, only considering models used within a particular domain. The aim is to develop formalisations and corresponding techniques that are relatively general and that can be used in the testing of embedded systems. Interestingly, it will transpire that a number of the classical testing assumptions do not hold and so implementation relations such as the different available versions of tioco are not suitable.


Download : Download high-res image (126KB)
Download : Download full-size image
Fig. 1. State machine model of a rescue drone (Cavalcanti et al., 2019a).

3.2. Traces and automata
Observations made in testing will be in the form of sequences and we use  for the empty sequence. Given set , 
 denotes the set of finite sequences of elements from  and 
 denotes the set of infinite sequences of elements from .

A system will interact with its environment through inputs and outputs. Throughout the paper,  and  will represent the (disjoint) input and output alphabets and we let  denote the set of actions.

The basic, untimed, type of model we consider is an automaton in which, as usual in Automata Theory and in contrast to the standard notion of LTS, we have the concept of a final state.

Definition 1 Automaton

An automaton is a tuple 
 where

•
 is a countable, non-empty set of states;

•
 is the initial state;

•
 is a countable set of visible actions;

•
 is the transition relation, where  represents an internal action;

•
 is the set of final states.

At any time, an automaton  is in a particular state . If 
 for action  then  can move to state 
 through . We will sometimes use an alternative notation: a transition 
 can be expressed as


. We will also write

if there does not exist 
 such that 
. The transition relation can be extended as follows.
Definition 2

Let 
 be an automaton with states 
,  be a set of states, visible actions 
, with , and sequence of visible actions 
.


Download : Download high-res image (74KB)
Download : Download full-size image
As usual, we will not always distinguish between a model and its initial state. If 
, then we will identify  with its initial state 
, and, for example, we will usually write


instead of

. The automaton 
 defines the language  of finite sequences that take  to a final state.
Definition 3

Given automaton 
, the language 
 is defined as


Download : Download high-res image (9KB)
Download : Download full-size image
3.3. Timed models
We now describe our timed model, which is an LTS in which there is a special action, , that denotes the passing of a unit of time. We call this action ‘tock’ in order to be consistent with tock-CSP (Roscoe, 2010 Chapter 14).

Definition 4 TockLTS, Timed Traces

A labelled transition system with tock (or tockLTS) is a tuple 
 where

•
 is a countable, non-empty set of states;

•
 is the initial state;

•
 and  are countable disjoint sets of inputs and outputs respectively, with  being the set of visible actions;

•
 is the transition relation, where  represents the internal action, and  represents a tock action denoting the passage of a unit of time.

We use  to denote the set of tockLTS with input set  and output set .

The definition of the


relation is similar to the one given in Definition 2, with the only difference that 
 and, therefore, we omit it. The set of timed traces of  is defined as

Download : Download high-res image (10KB)
Download : Download full-size image
We will require some additional notation. Specifically, we will compute the states that can be reached from a given state after performing a sequence of actions and define a predicate to decide whether a system can refuse a set of actions at a certain state.

Definition 5

Let 
 be a tockLTS,  be a state,  be a set of states,  be a set of labels, and 
. We define the following notions:

1.

2.
.

3.

.
As usual, we expect processes to have certain properties. First, we require that time can progress: there cannot be a state from which it is impossible for time to advance. Second, we should have the urgency of internal actions and outputs (to be consistent with how our cyclic models operate). Third, processes should not show Zeno behaviour, that is, a process should not be able to follow an infinite sequence of actions in finite time. Finally, processes should have time determinism: processes do not branch as a result of time passing (performing a ), though a process can branch through internal actions that occur after a .

Definition 6 Urgency, Zeno Behaviour, Time Determinism

Let 
 be a tockLTS. Then

•
 is time progressing if for all  there exists 
 such that


.
•
 has urgent internal actions and output if for all  and , if


then

.
•
 has Zeno behaviour if there exists a state  and an infinite path from  with finitely many tock actions.

•
 has time determinism if for all states 
 we have that


implies 
.
Note that previously (Lefticaru et al., 2019) we required that processes do not have forced inputs, that is, for each state of a process there exists at least one outgoing transition that is not an input. Conceptually, this requirement makes sense — it essentially says that processes cannot stop time. We weakened this assumption, to requiring that time progresses, because some cyclic models can have forced inputs; in development, there is then the obligation to demonstrate that the context in which the SUT is used ensures that the composition of the specification and its environment cannot stop time.

Example 2

In Fig. 2 we give a formal representation, using a tockLTS, of the RoboChart state machine presented in Example 1. Let 
 denote this tockLTS, with this having state set 
, initial state 
 and action sets  and .

Essentially, the events that trigger transitions in RoboChart are transformed into input symbols ( stands for switchOn,  stands for found and  stands for origin) while actions or sequences of action calls are transformed into output symbols ( stands for takeoff,  stands for land,  stands for turnBack and  stands for move). We have transformed the actions involving time, such as wait(TOP) and wait(DELIVERY), where TOP and DELIVERY are greater than , into sequences of actions 
 that simulate the passing of an arbitrary number of time units followed by an output action . We have included additional states in order to capture the more complex transition behaviours. Specifically, we have split the RoboChart transition


into the sequence of tockLTS transitions

. Similarly, other transitions were added to simulate entry actions associated with states. The state Off is transformed into the states 
 and 
, the state Looking is transformed into the states 
 and 
, and the states Delivering and Returning are transformed, respectively, into the states 
 and 
 and 
 and 
.
We now illustrate some of the concepts from Definition 5 on 
. For example, considering  the following sets can be computed: 
, 
 and, consequently, 
. Concerning refusals, for example, we have that 
.

Regarding the (timed) traces of a model, it is worth mentioning that they can be regarded as the visible (and tock) actions of a path. For example, 
 has a path determined by the execution of the action sequence . However, the corresponding timed trace will consist only of visible and tock actions: 
.

It is easy to check that 
 satisfies the properties from Definition 6: the model has time determinism and it has urgent internal and output actions. If we were to add, for example, a  transition departing from 
 then the urgency property would no longer be true. Similarly, an additional  transition in 
 would violate time determinism. Note that time is always progressing in 
 as from any state it is possible to reach a state from which there is a  transition. It is easy to check that 
 does not have Zeno behaviour. However, if the transition


was replaced by the transition

, with , then the new tockLTS would have an infinite path described by 
 with no  actions. It would therefore exhibit Zeno behaviour.
The tockLTS we consider have the following property; the proof easily follows from the absence of Zeno behaviour and the time progressing assumption.

Proposition 1

Let 
 be a tockLTS. We have that for all  there exists an infinite path 
 such that


and 
.
4. Implementation relations based on traces
If the environment can only observe traces of visible actions and time (i.e. it cannot observe refusals) then we have a number of associated implementation relations. We start with the simplest of these, which simply requires every behaviour (trace) of the SUT to also be a trace of the specification.

Definition 7

Let  and  be two tockLTSs. We say that  conforms to  under timed trace inclusion if and only if . We denote this 
.

The following property is immediate from the definition.

Proposition 2

The timed trace inclusion relation is reflexive and transitive but need not be symmetric or antisymmetric.

Consider now the situation in which  is a trace of the specification and there is an input  such that  is not a trace of the specification. If  is also a trace of the SUT then trace inclusion requires that the SUT cannot receive input  after ;  is not defined after . This makes sense in contexts in which an input being undefined in the specification corresponds to that input not being allowed. For example, an input being undefined might correspond to the requirement that the corresponding field or option either does not appear in an interface or is greyed-out or that a system does not have access to a particular sensor (it is turned off). However, there are also cases where an input not being specified denotes the situation in which any behaviour is allowed (‘do not care’) and for such situations it is clear that timed trace inclusion is not the right implementation relation. We now define two additional implementation relations that interpret an input being undefined in slightly different ways but in ways that are consistent with the (untimed) implementation relations  and  (Tretmans, 2008).

One approach is to say that if a trace 
 can take the specification to a state  in which  is not defined then any behaviour is allowed if the SUT receives  after 
. The idea here is simply that the specification might have been in a state  in which  is not defined and so we should allow any behaviour after this.

Definition 8

Let  and  be two tockLTSs. We say that 
 if and only if for all  either  or there exists a prefix 
 of , with , such that 
 and there is a state 
 such that


and

.
The following property is immediate from the definition.

Proposition 3

The relation 
 is reflexive but need not be symmetric or antisymmetric.

Example 3

Consider the tockLTSs  (left),  (centre) and  (right) depicted in Fig. 3. We have that 
 since the specification (that is, ) does not say anything about what the SUT (that is, ) should do concerning  and the subsequent evolutions. It is trivial that 
 because, in particular, we have 
. However, it is obvious that 
 does not hold.

The 
 implementation relation can be seen as allowing any response to an input  in a state of the specification in which  is not defined. As a result, we can see this in terms of completing the specification in the following way.

Definition 9

Let 
 be a tockLTS. The completion of , denoted , is the tockLTS 
 in which 
 is a fresh state and 
 in which:

1.

2.
.

Note that  presents a Zeno behaviour: once we reach the fresh state 
, we cannot perform any . This is not a problem because we only use this process as a theoretical tool to provide an alternative characterisation of the 
 relation.

Example 4

Consider the tockLTS drone model given in Fig. 2 and described in Example 2. We build its completion 
 by adding a fresh state 
 and the transition sets 
 as explained in Definition 9. Because 
 has many states that do not accept any input, 
 will include transitions from each of these states, 
, to the new state, 
, labelled with all the input actions. For the remaining states, 
, the transition set 
 will include only transitions with inputs which are not already accepted by each of these states. For example, for 
 it includes only


. 
 consists of self-loops labelled with all the visible actions.
Then we have the following result. The proof follows easily from the fact that 
 extends 
 by accepting undefined behaviours. This is exactly the role of  with respect to : extend the latter with all potential behaviours after unspecified inputs.

Theorem 1

Given tockLTS  and  with the same alphabets, 
 if and only if 
.

The above deals with undefined inputs in a manner similar to the (untimed) implementation relation  for (untimed) input–output transition systems and this is also similar to how undefined inputs are considered in the literature on testing from finite state machines (see, for example, Hierons, 2017, Hierons, 2019, Petrenko and Yevtushenko, 2005, Petrenko et al., 1996). However, the implementation relation  takes a different perspective, which in effect says that the response to input  after trace 
 is defined in a specification  if there is some state 
 such that 
 can be reached from the initial state of  by 
 (


) and  is defined in 
 (

). The following adapts timed trace inclusion by taking the  approach to inputs not being specified.
Definition 10

Let  and  be two tockLTSs. We say that 
 if and only if for all  either  or there exists a prefix 
 of , with , such that 
 and for all 
 such that


we have that

.
Naturally, we cannot use the completion  above to reason about testing from a specification  under implementation relation 
;  might have behaviours (timed traces) not allowed. However, this is not the case if we first convert  into an equivalent deterministic tockLTS, using a simple adaption of the classical transformation from non-deterministic to deterministic finite automata (Hopcroft et al., 2006). Given tockLTS  we will let  denote the determinised version; states of  will be sets of states of  reached by a common trace.

Definition 11

Let 
 be a tockLTS. We write  to denote the automaton 
 in which 
 for 
 and  if and only if 
.

Observe that we say that  is an automaton, rather than a tockLTS (and so include a set of final states), because  need not satisfy some of the requirements that we place on tockLTS. For example,  need not have urgent output; this might be the case if


,

,

and there is an output  such that

.
Example 5

Considering the tockLTS 
 from Example 2 we will provide a few states and transitions for its determinised automaton. Here, the only sources of non-determinism in this model are due to  transitions. Thus, it is relatively straightforward to construct 
. For example, from 
 the action  moves 
 to 
. Further,  takes 
 from 
 to 
.

We obtain the following result. This follows by simply observing that in , an input  is specified after a trace  if and only if we have that


for some state such that

.
Theorem 2

Given tockLTS  and  with the same alphabets, 
 if and only if .

Note that in the above we did not use 
 to compare  and  since  is an automaton and not necessarily a tockLTS.

Observe that the process of constructing  could, in principle, lead to states of  corresponding to infinite sets of states of , which means that even bounded approaches to (partial) construction might not work. However, it is relatively common to assume that processes have the following property.

Definition 12

A tockLTS 
 is finitely-branching if for every 
 and  we have that 
 is finite.

Under this condition, the states of  that are reached by finite traces correspond to finite sets of states of . The proof of the result easily follows by induction on the length of .

Proposition 4

Given tockLTS , if  is finitely-branching then for all  we have that 
 is finite.

Theorem 3

Let  and  be tockLTS with the same alphabets. We have the following results:

1.
If 
 then 
 and 
.

2.
It is possible that one or more of 
 and 
 holds but not 
.

3.
If 
 then 
.

4.
It is possible that 
 but not 
.

Proof

The first result is immediate from the definitions of 
, 
, and 
.

For the second result, consider the specification tockLTS  given in Fig. 3 (centre) and  be the tockLTS given in Fig. 3 (left). It is clear that 
 and 
 since under these relations, an implementation of  can do anything after receiving 
. However, we do not have that 
 since, for example, 
 is a timed trace of  but not .

Now consider how 
 and 
 relate. First if 
 then, by definition, for all  either  or there exists a prefix 
 of , with , such that 
 and for all 
 such that


we have that

. If we consider the second part of this condition, this implies that there exists a prefix 
 of , with , such that 
 and there is a state 
 such that

and

. But this means that  is allowed under both 
 and 
.
For the last part, we require  and  such that 
 but not 
. Consider the tockLTSs  and  depicted in Fig. 4. Essentially, they differ through it being possible for  to produce 
 after 
 while  cannot. We have that 
 since 
 can take  to a state (
) in which 
 is not specified and so (under 
) all behaviours are allowed after 
. In contrast, we do not have that 
 since 
 can take  to a state (
) in which 
 is specified and so (under 
) the only behaviours allowed after 
 are those that are traces of . The result therefore follows.

The previous result shows that the three implementation relations differ in terms of how they deal with unspecified inputs. As a result, we have the following.

Theorem 4

Let  and  be countable disjoint sets of inputs and outputs, respectively. Let  and  be two elements of . If  is input-enabled then the following three statements are equivalent: 
; 
; and 

The trace based implementation relations have some benefits. For example, they have a number of nice properties and are relatively simple to define. In addition, they correspond to inclusion between two formal languages and so we can use concepts and results from formal language theory in order to reason about them. However, there is potential to strengthen them by allowing refusals to be observed. As a result, there are some systems that are related under these implementation relations but that, intuitively, should not be. The following discusses timed trace inclusion but similar arguments can be applied to the other two implementation relations defined in this section.

Example 6

Let us consider the fragments of models given in Fig. 5 (top and bottom). These two pairs of models conform to each other under timed trace inclusion because we have  and ,  and . However, often we will want to be able to distinguish between such processes. On the one hand, we expect both conformances between  and  because outputs cannot be controlled by the environment. In other words, a choice between outputs should work exactly as the corresponding internal choice. For example, even though 
 and 
 are available at 
, a user/tester cannot choose which of them will be performed. On the other hand,  and  should not be equivalent. The issue is that the tester or user can choose between two inputs in the same way that one can choose among the available options in a vending machine. If we have the corresponding internal choice and we reach, for example, state 
 then input 
 is not available. The implementation relation that we present in the next section satisfies all of these properties.

5. Timed refusal traces
In this section we extend the notion of a timed trace to allow refusals to be observed, leading to timed refusal traces. We then define the timed refusal traces of a tockLTS. Finally, we develop an approach in which a tockLTS  is transformed into an automaton  whose language describes the set of timed refusal traces of . In the next section we define implementation relations based on timed refusal traces and prove that we can express these in terms of language inclusion based on .

Recall that we are interested in models that are cyclic/have a step semantics: a sequence of actions occurs without time (in the model) passing and then there is a tock action. A refusal of a set  is typically observed through the tester only being willing to engage in the actions in  and the composition of the tester and the SUT deadlocking. Since deadlocks are observed (in testing) through timeouts, the observation of a refusal takes time and so we only allow a refusal to be observed immediately before a tock action. Since outputs and internal actions are urgent, this means that a refusal can only be observed in a stable state.

Definition 13 Stable State

Let 
 be a tockLTS, with . We say that the state  is stable if for all  we have that


.
Given a set  of actions, we use  to denote the refusal of set . Further, we let  denote the set of all possible refusals.

We can extend the transition relation of a tockLTS with refusals as follows.

Definition 14 Refusal

Let 
 be a tockLTS and . For all  we write


if the following hold:
1.

and
2.
for all  we have that


.
This constitutes the observation of the refusal , that is, at a given stable state the model cannot perform the actions belonging to .

Note that, as previously indicated, due to the urgency of outputs and  we have that if a  can occur in a state  then  must be stable. As a result of this definition, the observation of a refusal  implies that no element  can occur in state : for all  we have that


. We therefore obtain the following result.
Proposition 5

Given tockLTS 
,  and , we have that


if and only if

.
Example 7

In order to illustrate refusals, we consider the two models from Fig. 5 (top). It can be easily checked that states 
 are not stable. In addition, refusals could be observed in any stable state of the two tockLTS models, 
. We denote this by


, where .
For our running example 
, refusals can be observed only in the stable states in which  is possible. This is exactly the set 
 of states. The transition relation can be extended with self-loops for refusals in each state 
. For example, we will have the transition


.
Note also that the second condition of Definition 14 implies that we include  as a refusal if all the actions in  can be refused, even if there are other actions from  that can be refused. Therefore, we do not only include maximal refusals. In fact, doing this would lead to some undesirable effects (this will be clearer after we give our implementation relations using refusals).

We can then give the set of refusal traces of a tockLTS in which, as we already said,


is defined in terms of

and

, in the usual way. Recall, however, that a refusal can only be observed immediately before a tock action. We therefore obtain a set of potential refusal traces (those that satisfy this condition) and we call these timed refusal traces. Also note that a timed refusal trace cannot end in a refusal since the observation of a refusal takes time (and so must be followed by a ). As a result, this set is not prefix closed.
Definition 15 Timed Refusal Traces

Let  be a set of actions. We define the set of timed refusal traces over  as 
.

Let 
 be a tockLTS, with . The set of timed refusal traces of  is defined as


Download : Download high-res image (15KB)
Download : Download full-size image
Example 8

Considering again 
 from Fig. 2 with refusals added in the stable states 
, as explained in the previous example, some timed refusal traces are:



Trace inclusion corresponds to a relation between the languages defined by the automata corresponding to two LTS. The benefit is that it is possible to use standard results and algorithms from formal language theory. This is particularly useful if the processes are deterministic finite state automata since there are efficient algorithms for many standard problems, including deciding language inclusion (that is, trace inclusion in our setting). We now show how we can generate an automaton whose traces are exactly the timed refusal traces of a tockLTS .

In order to explore one approach that might be used to achieve this, consider the fragment of a model in Fig. 6 (a). This can refuse all actions other than 
 when in state 
. It might seem that we can simply add a self-loop transition, with such a refusal, in state 
. However, we would then have the problem that such a self-loop need not be followed by a  action. For example, the inclusion of such a self-loop in state 
 would allow refusal traces such as 
. Such a refusal trace should not be allowed since it has a refusal followed by an action other than .


Download : Download high-res image (128KB)
Download : Download full-size image
Fig. 6. A refusal can only happen immediately before a duration or tock  .

One possible solution is outlined in Fig. 6(b). Rather than adding a self-loop, we include a transition, to a new state 
, that is labelled with the refusal. From 
 there is only one possible action, which is . We also require that 
 is not a final state of the automaton. As a result, any path that reaches a final state and includes the transition from 
 to 
 must follow this transition by a transition with label . Note that we require the notion of a final state and so the model is an automaton and not a tockLTS.

We now formally define the automaton  that includes these refusals.

Definition 16

Let 
 be a tockLTS, with . Let us consider the subset of states that can evolve by performing , that is, the set


. We define a set of fresh states 
 (i.e. 
). The new set of states 
 has a state for each state of 
.
We let  denote the automaton 
 where

•

.
•
.

The following result shows that the previous construction is correct.

Theorem 5

Let 
 be a tockLTS. We have that .

Proof

First, observe that both sets are subsets of , where . We will prove a slightly stronger result than the one stated before. Specifically, we will prove that for all , we have that  takes  to state  if and only if  is a final state of  and  takes  to state .

We use proof by induction on the length of . The base case, with  being the empty sequence, is immediate.

Inductive hypothesis: the result holds if the sequence has length less than  (). Let us suppose that  has length  and  takes one of  and  to state . By the definition of , 
 for some  (i.e. sequences in  cannot end in refusals). There are two cases to consider. First, if 
 does not end with a refusal then, by the inductive hypothesis, we have that 
 reaches the same states in  and . In addition, by construction we have that  takes  and  to the same state and so the result follows. The second case is where 
 ends in a refusal and so 
 for some  and 
. By the inductive hypothesis, 
 takes  and  to the same state 
. By construction,  takes  and  to the same state  and so the result follows.

6. Implementation relations with refusals
In the previous section we defined the notion of a timed refusal trace. In this section we extend the previous implementation relations in the natural way: we base implementation relations on the timed refusal traces of a process and not just its timed traces.

Definition 17

Let  and  be countable disjoint sets of inputs and outputs, respectively. Let  and  be two elements of . We say that  conforms to  under timed refusal trace inclusion if and only if . We denote this 
.

We now examine this implementation relation before considering alternatives that treat unspecified inputs in different ways. First, we present an example showing some relations between models and why maximal refusals do not provide the expected implementation relation.

Example 9

Consider again the fragments of models  and  given in Fig. 5 (top). We cannot add refusals to traces in states 
, 
, 
 and 
 because they are not stable. Therefore, we have  and .

Consider now  and  given in Fig. 5 (bottom). Assuming that 
 and , we have the following sets5 of timed refusal traces:  
 
 

We have , so that  conforms to  under timed refusal trace inclusion, but the converse is not the case. This shows that an external choice between inputs is a good implementation of the internal choice between the same inputs.

These last two fragments help show why we cannot restrict ourselves to only computing the maximal refusal sets. If we were to do this, the timed refusal traces of  would be the same but the ones corresponding to  would be 
 and we would no longer have timed trace inclusion.

The following is immediate from Theorem 5.

Theorem 6

Let  and  be countable disjoint sets of inputs and outputs, respectively. Let  and  be two elements of . Then 
 if and only if .

We now define two alternative implementation relations. The first approach corresponds to that used with 
. Similar to before, the idea is that any behaviour is allowed if an unspecified input is received. However, since behaviours are now timed refusal traces, rather than timed traces, the definitions are written in terms of the states reached by a prefix of a timed refusal trace.

Definition 18

Let  and  be countable disjoint sets of inputs and outputs, respectively. Let  and  be two elements of . We say that 
 if and only if for all  either  or there exists a prefix 
 of , with , such that 
 and there exists 
 such that


and

.
The second approach corresponds to that used with the implementation relation 
.

Definition 19

Let  and  be countable disjoint sets of inputs and outputs, respectively. Let  and  be two elements of . We say that 
 if for all  either  or there exists a prefix 
 of , with , such that 
 and for all 
 such that


we have that

.
We can compare the three implementation relations that are based on timed refusal traces, with the proof of the following being equivalent to that of the corresponding result for traces (Theorem 3).

Theorem 7

Let  and  be countable disjoint sets of inputs and outputs, respectively. Let  and  be two elements of . Then the following hold.

1.
If 
 then 
 and 
.

2.
It is possible that one or both of 
 and 
 hold but not 
.

3.
If 
 then 
.

4.
It is possible that 
 but not 
.

Similar to before, the implementation relations coincide if the specification is input-enabled.

Theorem 8

Let  and  be countable disjoint sets of inputs and outputs, respectively. Let  and  be two elements of . If  is input-enabled then the following three statements are equivalent: 
; 
; and 
.

We can now compare the implementation relation defined in this section with those based on trace inclusion introduced in Section 4. The proof of the following result follows from the fact that, for a process , we have 
.

Proposition 6

Let  and  be countable disjoint sets of inputs and outputs, respectively. Let  and  be two elements of . Then the following hold.

1.
If 
 then 
.

2.
If 
 then 
.

3.
If 
 then 
.

However, the converse is not the case as the following result shows.

Proposition 7

Let  and  be countable disjoint sets of inputs and outputs, respectively. There exist  and  in  such that 
 but 
 does not hold.

Proof

In order to prove this it is sufficient to give an example of such tockLTSs. Consider  and  depicted in Fig. 5 (bottom). In Example 6 we showed that . Therefore,  conforms to  under timed trace inclusion. On the contrary, in Example 9 we showed that . Therefore,  does not conform to  under timed refusal trace inclusion.

To summarise, 
 but 
 does not hold. The result therefore holds.

Note that the above proof considered parts of tockLTS models in which all inputs are specified and thus is not affected by whether we compare 
 with 
, 
 with 
, or 
 with 
. We therefore have the following.

Proposition 8

Let  and  be countable disjoint sets of inputs and outputs, respectively. There exist  and  in  such that the following hold.

1.
 but not 

2.
 but not 

We therefore obtain the following result, that says that the implementation relations that use timed refusal traces are strictly stronger than the corresponding implementation relations that only look at traces.

Theorem 9

Let  and  be countable disjoint sets of inputs and outputs, respectively. Let  and  be two elements of . Then the following hold.

1.
If 
 then 
 but the converse does not hold.

2.
If 
 then 
 but the converse does not hold.

3.
If 
 then 
 but the converse does not hold.

The previous result tells us that if we can observe timed refusal traces in testing then we have more powerful implementation relations than the ones we obtain when we only consider timed traces. It is also the case that if the environment (e.g. the user) can observe timed refusal traces (through, for example, the refusal of actions being observed as a result of options not being available on a screen) then it is insufficient to test for trace inclusion and its variants: the user might consider an SUT  to be faulty with respect to a specification  even though, for example, they have the same sets of timed traces.

Finally, we show how timed refusal trace inclusion can be expressed in terms of language containment between automata. The following is an immediate consequence of Theorem 5 and tells us that  captures the behaviours we require when reasoning about timed refusal trace inclusion.

Theorem 10

Let  and  be countable disjoint sets of inputs and outputs, respectively. Let  and  be two elements of . We have that 
 if and only if .

7. Alternative characterisation based on observers
In this section we provide an alternative characterisation of the implementation relations that are based around timed refusal trace inclusion.

Implementation relations should correspond to the ability of the environment, or a tester, to distinguish between processes; typically we require that all observations that can be made of the SUT are also observations that can be made when interacting with the specification (see, for example, Tretmans, 2008). In this section we define the notion of an observer, in our context, and how such an observer interacts with a tockLTS. This will provide an alternative, but equivalent, characterisation of timed refusal trace inclusion.

We follow the classical approach of ioco (Tretmans, 2008), in which a special action  is included in an observer to denote the observation of a refusal. In the case of ioco, as previously explained, the only refusal is associated with the inability of a model to perform output at a certain state (this is denoted by  in the models and by  in the observer/tester).

Next we define the notion of observer. An observer is an automaton in which all states are final. We also require that certain additional constraints are satisfied.

Definition 20 Observer

Let  and  be countable disjoint sets of inputs and outputs, respectively. An observer 
 is an automaton that satisfies the following properties for each state :

1.
If


then for all  we have that

.
2.
There exists at most one 
 such that


. If there is such a 
 then for all  we have that

.
3.
If 
 is a transition of  then  is the only action available in state 
.

We let  denote the set of observers with input set  and output set .

Note that observers cannot perform internal transitions (the rationale is that they essentially record what they can observe from a process). The last rule ensures that a refusal must be followed by a . The first rule is the standard condition that a tester is able to observe outputs while the second rule indicates that time can pass only if no output is available. Finally, the observation of a refusal takes time and so a  must be followed by a .

Example 10

In Fig. 7 we provide an observer for the tockLTS drone model given in Fig. 2. Note that there are many possible observers and, in addition, the graphical representation captures only part of an observer. It, does, however, illustrate the observation of a refusal (the -labelled transition), time passing (-transition) and acceptance of all outputs.

Definition 21 Synchronised Parallel Communication

Let  and  be countable disjoint sets of inputs and outputs, respectively. Let 
 and 
. The composition of the observer  and the model , denoted by , is an automaton 
 in which 
 is defined as follows:

•
If 
 then for all 
 we have 
.

•
If 
 and 
, with , then we have 
.

•
Let . If 
 and 
 then 
 
 if and only if the following conditions hold:

–
for all  we have that either there does not exist 
 such that 
 or there does not exist 
 such that 
.

–
for all  we have that there exists 
 such that 
.

The set of observations that the observer  can make of , denoted by 
, is given by the following:


Download : Download high-res image (13KB)
Download : Download full-size image
Note that in the last rule of the composition, since 
 may evolve via  then we have that it must be a stable state (for all  we have that


); this follows from the fact that  is a tockLTS and tockLTSs have urgent outputs and internal actions (Definition 6). In this rule, also note that we discard the state reached after the performance of  from 
: the composition makes  remain in the same state. Naturally, the second rule then ensures that this can be followed by a .
Example 11

Fig. 8 shows part of the composition of the observer given in the previous example (Fig. 7) with the tockLTS model from Fig. 2.

Proposition 9

Let  and  be countable disjoint sets of inputs and outputs, respectively. Given 
 and  in , there is an observer  such that 
 if and only if  is a prefix of a timed refusal trace of .

Note that in the above result  need not be a timed refusal trace of  since  could end in a refusal; to make this a timed refusal trace it would be necessary to add the  that follows this refusal. The following result is immediate from Proposition 9.

Theorem 11

Let  and  be countable disjoint sets of inputs and outputs, respectively. Let  and  be two elements of . We have that 
 if and only if for all  we have that 
.

Since observers capture the observations that can be made, this tells us that timed refusal trace inclusion is a suitable implementation relation for our scenario.

8. Test generation
In this section we present a testing framework for cyclic systems specified by using a tockLTS. The goal is to use the specification of the SUT to derive sound and exhaustive test suites with respect to an implementation relation. These test suites are said to be complete. The soundness of the process ensures that if an SUT fails one of the derived tests then the SUT is faulty (in other words, it does not conform to the specification with respect to the chosen implementation relation). In addition, exhaustiveness ensures that if an SUT is faulty then there exists a derived test case that is failed by the SUT. While soundness is relatively easy to achieve (in particular, the empty set of tests is sound), exhaustiveness is usually not reached if the SUT is a black-box. The problem is that we do not have a bound on the number of tests that we have to apply. We will provide an algorithm that achieves exhaustiveness in the limit (Merayo et al., 2008). The idea is that given a natural number , we can construct test suites that find all faults that can be observed in observations of length up to . If  tends to infinity then we achieve exhaustiveness in the limit. A recent approach (Bos et al., 2019) shows how one can derive test suites that are exhaustive as long as the number of states of the SUT does not exceed a given bound. Both approaches have a similar underlying idea: if the length of the tested sequences or the number of states tends to infinity then the derived test suites are complete in the limit.


Download : Download high-res image (589KB)
Download : Download full-size image
Fig. 9. -tests.

First, we define a testing framework where testers do not have the capabilities to detect refusals. As a result, we will be able to characterise our implementation relation based on the timed traces of a process, that is, the 
 relation. Next, we will extend the tests with refusals and will be able to provide a characterisation of the implementation relation based on timed refusal traces, that is, the 
 relation.

8.1. Complete test suites with respect to 
Our first task is to define the notion of test. Usually, a test case can either provide an input to the SUT or observe output. In our framework, a test case can also observe the passing of time. A difference with respect to the usual notion of test case is that we will also test for the (in)ability of the SUT to perform an input at a certain point of time. In this case, if testing detects that the SUT is able to perform an input that is not allowed by the specification then we will stop the testing process and indicate that a faulty behaviour was detected. Similarly, in the next section we will test for the capabilities of the SUT to perform refusals (and test that they are followed by a tock action indicating the passing of time). There are two main differences with respect to usual automata: tests do not have internal actions (actually, they are deterministic) and they must represent a finite process, that is, the induced graph cannot have cycles. Finally, note that the notions of test case and observer, introduced in the previous section, are related but tests are more restrictive: they are deterministic, have finite behaviour and at most one input can be used to continue the testing process from each state of the test.

Definition 22 Test

Let  and  be countable disjoint sets of inputs and outputs respectively. An -test (or simply test when  and  can be inferred from the context) is an acyclic and deterministic automaton 
 such that  is finite and for all  we have that either there are no outgoing transitions from  or the following two restrictions hold:

•
Observe any possible output or passing of time. For each  there exists 
 such that 
.

•
Continue with at most one input. There exists at most one input  such that


.
In addition, we require that non-final states, denoting that the testing process has failed, are deadlocked, that is, if  then there does not exist  and 
 such that 
.

We use  to denote the set of -tests.

In a test case, we distinguish three types of states. Two of them are states in which an input is not applied. This can mean either that the test case has been successfully passed or failed (graphically represented by ✓and , respectively). In the first case (✓), there are two cases: the test case has terminated or the test case is in a state where it can observe further output, or the passing of time, and then continue. Failing states () always lead to the test case terminating and the set of failing states is given by . The third type of state of a test case represents the potential application of an input to the SUT, paired with the potential to observe any output or the passing of time. This third type encompasses two different situations. If the state reached after the input belongs to , then we have an expected input; otherwise it is an input that was not allowed and indicates that a fault has been detected. Note that we require tests to have a finite number of states, capturing the idea that the application of a test case should produce a verdict in finite time. In practice, if the set of outputs is infinite then we might compress transitions so that we retain finiteness. Given a state  we could, for example, partition the set of transitions from  to deadlocked states into two groups: the ones reaching pass and fail states, respectively. For example, if we consider the test case given in Fig. 9 (left), then we would obtain the test case given in Fig. 10. For the sake of simplicity, we will assume that the tests are in an uncompressed form but will rely to its equivalent representation if we are working with an infinite set of outputs.


Download : Download high-res image (177KB)
Download : Download full-size image
Fig. 10. -test in compressed form. .


Download : Download high-res image (178KB)
Download : Download full-size image
Fig. 11. Faulty implementation of the TockLTS drone model.

Next, we define the application of a test to an SUT. Essentially, we will compose in parallel the test case and the SUT and we will say that the application of the test case has failed if a non-final state of the test case can be reached.

Definition 23 Test Application

Let  and  be countable disjoint sets of inputs and outputs respectively. Let 
 be a tockLTS and 
 be an -test. We define the application of the test case  to the system , denoted by


, as the automaton 
 where 
 is the smallest set of transitions fulfilling the following rules
•
If 
 then for all 
 we have 
.

•
For each , if 
 and 
 then 
.

We say that the application of  to  has failed if there is a sequence of transitions belonging to 
 departing from 
 and reaching a state belonging to 
; otherwise, we say that the application was successful.

Example 12

Consider the -tests 
 (Fig. 9 (left)) and 
 (Fig. 9 (right)), where  and  are the sets of inputs and outputs, respectively, corresponding to our running example. Consider the (faulty) implementation of our running example 
 given in Fig. 11. We have that the application of 
 to 
 fails because the sequence , which can be performed by


, reaches a fail state of the test. On the contrary, the application of 
 to 
 is successful.
The following result is immediate from the definition of


.
Lemma 1

Let  and  be countable disjoint sets of inputs and outputs respectively. Let ,  be an -test and 
. We have that


if and only if  and

.
Next we present an algorithm to derive tests from a specification such that an SUT conforms to the specification with respect to 
 if and only if the SUT successfully passes all the tests of the suite. The algorithm is given in Fig. 12. The application of the algorithm to a specification produces a single test. If we consider all the non-deterministic choices in the algorithm (the choice in Step 2 between stop and continue testing and the choice of the input in Step 2(b)i) then we obtain a test suite. Note that in Steps 2(b)i and ii we continue testing (third clause) only if we have chosen an expected input or we are dealing with an output or tock that the specification can perform from the reached state after partially traversing it.


Download : Download high-res image (347KB)
Download : Download full-size image
Fig. 12. Test derivation I: the 
 relation .

Definition 24

Let  be a tockLTS. We denote by 
 the smallest set including all the tests that can be derived by applying the algorithm given in Fig. 12 to .

Example 13

Let  be our running example (see Example 2) and consider the tests 
 and 
 depicted, respectively, in Fig. 9 (left) and (right). We have that 
 while 
. In the latter case, note that state  should be a fail state. Note that the transition departing from state  and labelled by  could be produced by our derivation algorithm because it reaches a fail state (this transition is not available in  after performing ).

Next we study the computational complexity of our algorithm. Therefore, we will restrict to finite tockLTSs, that is, we will assume that we have finite sets of inputs, outputs, states and transitions. Note that, as previously discussed, the derivation algorithm returns a test case but if the algorithm is repeated then there is no bound on the number of test cases that can be produced. Therefore, we consider the computational complexity of producing a single test case. In addition, observe that the time taken to produce a test case will inevitably depend on the size of the test case and, in particular, it is only possible to place an upper bound on the time taken if we either fix or bound the size of the test case. As a result, we explore the complexity of producing a test case that has  inputs. Note that this is equivalent to applying Step 2(b) of the test case derivation algorithm a total of  times.

Theorem 12

Let 
 be a tockLTS. The space needed to store a test case with  inputs and generated by the algorithm given in Fig. 12 applied to  is in .

Proof

Each application of Step 2(b) generates  new states in the test case and as many transitions. In addition, the auxiliary storage space (that is, the set 
) increases by at most  pairs. Note that each pair added to 
 has a single state of the test case and also a subset of . As a result, the auxiliary space added in each iteration is in . Therefore, we have that, the space needed to compute a test case with  inputs, including both the space needed for the test case (states and transitions) and auxiliary space needed to construct it, is in , that is, in .

Theorem 13

Let 
 be a tockLTS. The time needed to produce a test case with  inputs and generated by the algorithm given in Fig. 12 applied to  is in .

Proof

Each application of Step 1 can be done in constant time: we simply need to choose any element of a set. The first item of Step 2(b)i also takes constant time. Concerning the second item of this step, in order to decide whether


, it is enough to traverse the multi-graph induced by  from each element of . Since traversing a graph, either using a depth-first or a breadth-first strategy, can be done in , where  is the set of edges and  is the set of vertex, and , then this operation is in . Note that this operation also computes the states belonging to  that are needed in the second part of the item. Using a similar reasoning, we have that Step 2(b)ii can be done in time  because we have to repeat the previous process, in the worst case, for all the elements in . Therefore, we have that, in the worst case, the time needed to compute a test case with  inputs is in , that is, in .
The final part of this section consists of proving that the derived test suites are indeed complete with respect to the 
 implementation relation. First, we provide two auxiliary results.

Proposition 10

Let 
 be a tockLTS and 
 be a test. Let 
 such that


and let 
 be the unique state such that

. We have that 
 if and only if .
Proof

We will prove the result by induction on the length of . The base case, with  being the empty sequence, is immediate because  can only reach the initial state (by construction, it belongs to ) and the empty sequence is always a trace of .

Inductive hypothesis: the result holds if the sequence has length less than  (). Let us suppose that  has length . Therefore, 
 and the result holds for 
. First, note that 
 must reach a state belonging to  because there are no outgoing transitions departing from states in 
. Therefore, by induction, 
. Depending on whether  is an allowed/unexpected input, an output or a tock, the transition of the test case labelled by  can be produced, respectively, by Step 2(b)i (if ) and Step 2(b)ii (otherwise). In all cases it is straightforward to check that the reached state after  belongs to  if and only if  can be performed from the states belonging to 
. In other words, this holds if and only if 
.

Proposition 11

Let  and  be countable disjoint sets of inputs and outputs respectively. Let  and . There exists a test case 
 such that


and 
.
Proof

We will prove the result by induction on the length of . The base case, with  being the empty sequence, is immediate because it is enough to consider the test case built after applying the initialisation of the algorithm given in Fig. 12, entering the loop, choosing the only existing pair of 
, and choosing the option (a) in Step 2. This process produces an empty test, with one final state, and we have


Inductive hypothesis: the result holds if the sequence has length less than  (). Let us suppose that  has length . Therefore, 
 and the result holds for 
. Again, we have that the state of the test reached after performing 
 belongs to . Let 
 be this state. Note that at this stage we will have that 
. In addition, since  is a trace of , we have


. If  is an input then we will apply Step 2(b)i; if  is an output or a tock, then we will apply Step 2(b)ii. In both cases, the reached state belongs to . Independently of the way we complete this test, we have that the requested property holds.
Theorem 14

Soundness of 
Let  and  be countable disjoint sets of inputs and outputs respectively. Let  and 
. If


fails then 
 does not hold.
Proof

If


fails then there exists a sequence 
 reaching a non-final state of the automaton

from its initial state. First, by Lemma 1 we have that . Second, since we reach a non-final state of the test case and by Proposition 10, we have that . Therefore,  and we conclude that 
 does not hold.
Example 14

Consider again our running example , the test case 
 given in Fig. 9 (left) and the system 
 given in Fig. 11 (top). In Example 13 we saw that 
 and in Example 12 we obtained that


fails. The soundness of our framework allows us to state that 
 does not hold even without computing the traces of both processes.
Theorem 15

Exhaustiveness of 
Let  and  be countable disjoint sets of inputs and outputs respectively. Let . If 
 does not hold then there exists 
 such that


fails.
Proof

If 
 does not hold then there exists 
 such that  but . Let 
 be the longest sequence such that there exists 
 such that 
. Note that 
 might be empty but 
 cannot be empty. So, 
 and 
. By Proposition 11 we can build a test case whose set of traces includes 
. If we extend this test case to consider , we will have that  reaches a non-final state of the test, denoting the fail of the application of the test case if this state is reached. Obviously, this state is reached because 
 is a trace of  and a trace of  and applying Lemma 1, it is also a trace of


. Therefore,  fails , as requested.
Corollary 1

Completeness of 
Let  and  be countable disjoint sets of inputs and outputs respectively. Let . We have that 
 if and only if for all 
 we have that


does not fail.
8.2. Complete test suites with respect to 
In order to capture refusals, we have to increase the testing power of tests. We slightly modify the notion of test case given in Definition 22 by including two new types of action. First, we will add the capability to test the existence of a refusal. Second, we will be able to test refusals such that its performance, followed by a tock action, will detect a faulty behaviour.

Definition 25 Test

Let  and  be countable disjoint sets of inputs and outputs respectively. An -test case with refusals (or simply test case when  and  can be inferred from the context and it is clear that we are taking into account refusals) is an acyclic and deterministic automaton 
 such that for all  we have that either there are no outgoing transitions from  or the following three restrictions hold:

•
Observe any possible output and passing of time. For each  there exists 
 such that 
.

•
Continue with at most one input or refusal. There exists at most one  such that there exists 
 such that one of the following hold.

–
 and 
, or

–
, 
, 
 and there exists 
 such that 
. This is the only transition departing from 
.

•
Check unexpected refusals. There exist , 
 and 
 such that 
. The last one is the only transition departing from 
.

In addition, we require that non-final states, denoting that the testing process has failed, are deadlocked, that is, if  then there does not exist  and 
 such that 
.

We use 
 to denote the set of -tests with refusals.

Similarly to our previous notion of test, tests with refusals will have ✓and  states and states representing the potential application of an input  to the SUT. In this case, this application will be again paired with the potential to observe any output and the passing of time. In addition, tests will be able to observe that the SUT cannot perform a certain set of actions. We will use this option with two goals: check that the SUT does not have unexpected refusals and continue testing after observing an allowed refusal. In the former case, we use a unique transition, labelled by a set belonging to , to include all the refusals that the SUT should not observe. In both cases, in order to observe a refusal in testing, we have to make sure that it is followed by the performance of a tock action. An obvious corollary of the previous definition is that any sequence of transitions performed by a test case can have, at most, one transition labelled by a set in . This fact will be explicitly used in the proof of some of the results in this section.

Next, we define the application of a test case with refusals to an SUT. Again, we will say that the application of the test case has failed if a non-final state of the test case can be reached.

Definition 26 Test Application

Let  and  be countable disjoint sets of inputs and outputs respectively. Let 
 be a tockLTS and 
 be an -test with refusals. We define the application of the test case  to the system , denoted by


, as the automaton 
 where 
 is the smallest set of transitions fulfilling the following rules
•
If 
 then for all 
 we have 
.

•
For each , if 
 and 
 then 
.

•
If


, with 
, and 
 then 
.
•
If


, with 
,  and 
, then 
.
We say that the application of  to  has failed if there is a sequence of transitions belonging to 
 departing from 
 and reaching a state belonging to 
; otherwise, we say that the application was successful.

The differences with respect to Definition 23 appear in the new third and fourth clauses. If the test case offers a refusal and the process is able to refuse that set, then they will synchronise. Taking into account the structure of tests, where the offering of a refusal is always followed by a tock, the next performed action will be . If the test case offers a set of refusals such that the process is able to refuse at least one of these refusals, then the process and the test case simultaneously evolve.

Lemma 2

Let  and  be countable disjoint sets of inputs and outputs respectively. Let ,  be an -test with refusals and 
. We have that


if and only if

and there exists 
, that can be formed from  by replacing each occurrence of each set of refusals  by one of its elements , such that

.
Moreover, we have the following results concerning the membership of  to .

1.
If either the last or the penultimate action of  belongs to , that is, 
 or 
 then 
. In the latter case, there exists  such that 
.

2.
If the last action of  belongs to , that is, 
 then 
.

3.
Otherwise, 
 and .

Next we present an algorithm to derive tests from a specification such that an SUT conforms to the specification with respect to 
 if and only if the SUT successfully passes all the tests of the suite. The algorithm is a variation of the one given in Fig. 12 to take into account refusals. Again, the application of the algorithm to a specification produces a single test. If we consider all the non-deterministic choices in the algorithm (the choice in Step 2 between the options (a) and (b) and the choice of the input or refusal in Step 2(b)i) then we obtain a test suite. The new algorithm is given in Fig. 14.


Download : Download high-res image (623KB)
Download : Download full-size image
Fig. 14. Test derivation II: the 
 relation .

Definition 27

Let  be a tockLTS. We denote by 
 the smallest set including all the tests that can be derived by applying the algorithm given in Fig. 14 to .

Example 15

Let  be our running example (see Example 2) and  be the test case given in Fig. 13. We have that 
.

Next we study the computational complexity of the new algorithm. Again, we will assume that we have finite sets of inputs, outputs, states and transitions. This time, we will use as unit of measure the number of inputs and expected refusals appearing in the test case (this number is equal to the number of non-trivial iterations of the main loop).

Theorem 16

Let 
 be a tockLTS. The space needed to store a test case with a total of  inputs and expected refusals and generated by the algorithm given in Fig. 14 applied to  is in 
.

Proof

Each application of Step 2(b) generates at most,  new states in the test case and as many transitions. The difference with respect to the proof of Theorem 12 is that we now have two additional states and transitions for the set of unexpected refusals and if we apply a refusal instead of an input then we produce two states and transitions instead of just one. Similarly, the set 
 increases by at most  pairs, storing again each pair belonging to 
 a single state and a subset of .

However, we have to take into account that a transition of the test case does not have a small amount of information. In the previous case, the information stored in a transition was an action. However, in the new framework each iteration adds a transition labelled by a set of unexpected refusals. Therefore, in the worst case, we need space in 
 to store these transitions. Note that although refusals are subsets of , we can omit outputs because they can be always added to any refusal (see Proposition 5). Therefore, we have that the space needed to compute a test case with a total of  inputs and/or expected refusals, including both the space needed for the test case and auxiliary space needed to construct it, is in 
, that is, in 
.

Theorem 17

Let 
 be a tockLTS. The time needed to produce a test case with  inputs and expected refusals and generated by the algorithm given in Fig. 14 applied to  is in 
.

Proof

The main difference with respect to the proof of Theorem 13 is that each iteration of the main loop needs to compute whether each refusal set is expected or not for the set of states that we are processing: unexpected refusals are always used (Step 2(b)iii) while expected refusals can be used in Step 2(b)i.B. Since we can omit outputs, as explained in the proof of Theorem 16, each iteration needs additional processing in 
 with respect to an iteration of the previous algorithm. Therefore, we have that, in the worst case, the time needed to compute a test case with  inputs and/or expected refusals is in 
.

The final part of this section involves proving that the derived test suites are indeed complete with respect to the 
 implementation relation. We will follow a similar methodology to the one previously used for 
 and start with some auxiliary results.

Proposition 12

Let 
 be a tockLTS and 
 be a test. Let 
 be such that


and let 
 be the unique state such that

. We have that 
 if and only if one of the following hold
•
, or

•
there exists  such that 
 and 
, or

•
there exists  such that 
 and 
. In this case, for all  we have that 
.

Proof

First, note that the last two actions of  cannot be  because we would reach a non-final state of the test. We will prove the result by induction on the length of . The base case, with  being the empty sequence, is immediate because  can only reach the initial state (by construction, it belongs to ) and the empty sequence is always a trace of .

Inductive hypothesis: the result holds if the sequence has length less than  (). Let us suppose that  has length . Therefore, 
 and the result holds for 
. First, note that 
 must reach a state belonging to  because there are no outgoing transitions departing from states in 
. We consider three cases.

If , taking into account the observation that we made in the beginning of the proof, then we reason as in the proof of Proposition 10. Depending on whether  is an allowed/unexpected input, an output or a tock, the transition of the test labelled by  can be produced, respectively, by Step 2(b)iA (if ) and Step 2(b)ii (otherwise). In all cases it is straightforward to check that the reached state after  belongs to  if and only if  can be performed from the states belonging to 
. In other words, this holds if and only if 
.

If  then 
 must finish with an action belonging to  because there cannot be two consecutive occurrences of single refusals (because each single refusal must be followed by a tock). Therefore, 
.

If , again, we must have that the last action of 
 belongs to  (it cannot be a single refusal because they are always followed by tock and there can be at most one occurrence of an action belonging to  in a sequence performed by a test). Again, we conclude 
. Moreover, by construction we trivially have the second part of the result, that is, for all  we have that 
.

The proof of the next result is an obvious adaption of the proof of Proposition 11 and, therefore, we omit it. In particular, note that the sequences considered in the result do not contain elements of  because they are (timed refusal) traces of a process.

Proposition 13

Let  and  be countable disjoint sets of inputs and outputs respectively. Let  and . There exists a test case 
 such that


and 
.
Theorem 18

Soundness of 
Let  and  be countable disjoint sets of inputs and outputs respectively. Let  and 
. If


fails then 
 does not hold.
Proof

If


fails then there exists a sequence 
 reaching a non-final state of the automaton

from its initial state. We have two possibilities: 
 or 
, with 
 and . Note that  cannot end with an action belonging to  because transitions labelled by these actions reach final states.
Consider the first case, 
. By Lemma 2 we have that


and since  does not end either with a refusal or a set of refusals we obtain . Second, since we reach a non-final state, we apply Proposition 12 and given the fact that only one of the three possibilities is viable (again,  does not end with either an element belonging to ) we have that . Therefore,  and we conclude that 
 does not hold.
In the second case we have 
, with 
 and . Applying Lemma 2 we have that there exists  such that 
. Applying Proposition 12 we have that 
 (note that 
 reaches a final state because this sequence can be extended). Taking into account the definition of  in Step 2(b)iii of the derivation algorithm, this set contains the refusals  such that  cannot perform  after performing 
. In particular, it cannot perform the sequence  and, therefore, 
. Thus,  and we conclude that 
 does not hold.

Theorem 19

Exhaustiveness of 
Let  and  be countable disjoint sets of inputs and outputs respectively. Let . If 
 does not hold then there exists 
 such that


fails.
Proof

If 
 does not hold then there exists 
 such that  but . Let 
 be the longest sequence such that there exists 
 such that 
. Note that 
 might be empty but 
 cannot be empty. So, 
 and 
. Now, we distinguish two cases.

If  then we proceed as in the proof of Theorem 15. By Proposition 13 we can build a test case with trace 
. If we extend this test case to consider , then we will have that  reaches a non-final state of the test, denoting the fail of the application of the test case if this state is reached. Obviously, this state is reached in


because 
 is a trace of  and a trace of  and applying Lemma 2, it is also a trace of

. Therefore,  fails , as requested.
If , that is,  for a certain , then we know that  is followed by a tock action. Therefore, we have 
, with 
, 
 and 
. In other words, we have


but

. Again, by Proposition 13 we can build a test case with trace 
. We will have that  will be a member of the set of refusals  built after applying step 2(b)iii to the state that we reach in the test case  after performing 
. If we apply this test case to , taking into account that

, we have that  fails , as requested.
Corollary 2

Completeness of 
Let  and  be countable disjoint sets of inputs and outputs respectively. Let . We have that 
 if and only if for all 
 we have that


does not fail.
9. Conclusions and future work
There has been significant interest in testing from formal models since this brings the potential for automated systematic testing. In order to test from a formal model one requires an implementation relation that says what it means for the system under test (SUT) to be a correct implementation of the specification. This paper considered cyclic models, in which behaviours are of the form of sequences of observable actions separated by discrete time intervals. The work was motivated by the use of cyclic simulators in a number of areas, including robotic systems.

Although many implementation relations are variants of the well known ioco implementation relation, ioco and its timed versions were not suitable for cyclic models. As a result, there was a need to define novel implementation relations that take into account the discrete nature of time in cyclic models. We defined two types of implementation relation that differ in whether or not it is possible to observe the situation in which a model can refuse a set of actions. There were three variants of each type of implementation relation, with these varying in how unspecified inputs are treated.

We introduced two alternative characterisations of timed refusal trace inclusion. First, we showed how one can define an automaton whose language is exactly the set of timed refusal traces of a model; this allows one to express correctness in terms of formal language containment for automata. We also showed how one can define timed refusal trace inclusion in terms of the observations that can be made by an observer interacting with processes (the specification and SUT); this demonstrates that timed refusal trace inclusion corresponds to the notion of observation for our models.

Finally, we introduced two testing frameworks that appropriately capture our main implementation relations. Specifically, we gave test derivation algorithms such that a process conforms to a specification if and only if the process successfully passes all the tests that can be derived from the specification.

There are several possible lines of future work. Regarding the testing of deployed robots, as opposed to testing in a simulation, we would like to further explore the role of the environment in our framework. Although one can test within a simulation (using a model of the environment), in practice the real environment will not behave like the model. As a result, it is necessary to address this ‘reality gap’ when testing the actual deployed robot. We believe that it will be possible to map the tests produced using the proposed algorithms to tests that can be used in testing a deployed robot. However, it is likely that there will also be a need to have additional tests that explore the reality gap, possibly based on a search-based approach that aims to maximise observed differences between the simulation of the environment and the actual environment.

There are also several possible lines of future work associated with the formalism used, test theory, and test generation algorithms. It would be interesting to explore conditions under which models can be expressed as Finite State Machines, allowing the use of the associated test generation algorithms. More generally, there should also be scope to introduce additional test generation algorithms, possibly including algorithms that take into account fault models that describe the faults that might occur. Sometimes it is difficult to interact with the systems in which we are interested. In such situations, it is necessary to use a more passive testing approach. An approach might build on our previous work that considers the role of asynchronous communications (Hierons et al., 2017, Merayo et al., 2018a, Merayo et al., 2018b). There is the potential to enrich models to include, for example, probabilities or continuous variables (i.e. hybrid systems) and, again, our previous work (Hierons and Núñez, 2017) will be a starting point. Finally, we plan to carry out case studies with robotic systems.

CRediT authorship contribution statement
Raluca Lefticaru: Methodology, Investigation, Software, Writing - original draft, Writing - review & editing, Visualization. Robert M. Hierons: Conceptualization, Methodology, Writing - original draft, Writing - review & editing, Supervision, Funding acquisition. Manuel Núñez: Methodology, Writing - original draft, Writing - review & editing, Visualization, Supervision, Funding acquisition.