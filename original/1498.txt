Cyber–physical systems increasingly feature highly-distributed and mobile deployments of devices spread over large physical environments: in these contexts, it is generally very difficult to engineer trustworthy critical services, mostly because formal methods generally hardly scale with the number of involved devices, especially when faults, continuous changes, and dynamic topologies are the norm. To start addressing this problem, in this paper we devise a formally correct and self-adaptive implementation of distributed monitors for spatial properties. We start from the Spatial Logic of Closure Spaces, and provide a compositional translation that takes a formula and yields a distributed program that provides runtime verification of its validity. Such programs are expressed in terms of the field calculus, a recently emerged computational model that focusses on global-level outcomes instead of single-device behaviour, and expresses distributed computations by pure functions and the functional composition mechanism. By reusing previous results and tools of the field calculus, we prove correctness of the translation, self-stabilisation of the derived monitors, and empirically evaluate adaptivity of such monitors in a realistic smart city scenario of safe crowd monitoring and control.

Previous
Keywords
Spatial logics

Runtime verification

Self-adaptive systems

Field calculus

1. Introduction
Cyber–physical systems (CPSs) are typically constructed by deploying a variety of computational devices of various sorts (sensors, actuators, computers) into the physical environment, e.g., in scenarios like smart cities, intelligent buildings and factories, transportation, and wide-area monitoring and control. Such systems increasingly feature large-scale, intrinsic distribution of computation, dynamism, mobility, and unpredictability due to faults, adversarial behaviour, and unknown patterns of human behaviour and data production. As such, engineering trustworthy computational services over CPSs is particularly challenging, especially when there is need of facing critical functional and non-functional requirements. In principle, one would seek for formal methods and tools by which a system design can be verified against the validity of certain properties, such that these properties can be transferred to system execution: unfortunately, the complexity of CPSs deployment scenarios typically makes the problem intractable (Bennaceur et al., 2019).

As a contribution towards facing this issue in a significant class of cases, in this paper we focus on the problem of decentralised distributed runtime verification of spatial properties. Runtime verification is a computing analysis paradigm based on observing a system at runtime (to check its expected behaviour) by means of monitors generated from formal specifications, so as to precisely state the properties to check as well as providing formal guarantees about the results of monitoring (Bauer et al., 2011, Leucker and Schallhart, 2009): distributed runtime verification is runtime verification in connection with distributed systems, hence it comprises both monitoring of distributed systems and using distributed systems for monitoring in an asynchronous setting. Approaches to distributed runtime verification typically rely on simplifying assumptions such as absence of failures and mobility (Francalanza et al., 2018). Here, we specifically aim at open systems of agents, where the number of participants, their communication topology, and the performance of (broadcast) messages is unreliable. According to the above survey, there is no comparative work in this regard.

In a further departure from other approaches to runtime verification, we are specifically not interested in a global verdict (and hence a global monitor), but rather in each agent’s view, which in a slight departure from the terminology we call the decentralised setting. In our application area we specifically want to avoid a centralised monitor (observer), as nodes e.g. in a wireless sensor network can only communicate with neighbours, and we see distribution also as a way to tolerate failures such as network partitioning, in addition to a pragmatic motivation.

We address this problem of an open system by careful selection of a computational model for distributed systems that provides inherent support to large-scale and open scenarios, scalability with the complexity of the distributed algorithms to implement, and compositionality with respect to spatial logical connectives. Namely, we adopt the aggregate computing paradigm (Beal et al., 2015, Viroli et al., 2019), and especially its incarnation into the field calculus language (Audrito et al., 2019), where agents are programmed in an abstract computational environment and make use also of spatial and temporal data constructs in their region through proximity-based interactions. Programs expressed in field calculus focus on global-level outcomes of a computation instead of single-device behaviour, they express highly-distributed computations by pure functions, and finally rely on functional composition as key mechanism to combine libraries of reusable and correct building blocks into higher-level applications services (Viroli et al., 2018). At the modelling level, the field calculus expresses computations as transformation of computational fields (or fields for short), namely, space–time distributed data structures mapping computational events (occurring at a given position of space and time) to computational values. As an example, a set of temperature sensors spread over a building forms a field of temperature values (a field of reals), and a monitor alerting areas where the temperature was above a threshold for the last 10 min is a function from the temperature field to a field of Booleans.

We take as reference the Spatial Logic of Closure Spaces (SLCS) (Ciancia et al., 2014), a modal logic proposed to describe and verify topological properties over spatially-situated systems, and formally grounding the concepts of proximity, propagation and surroundedness. By the field calculus, we are able to define a translation of formulas of the Spatial Logic of Closure Spaces (SLCS) into distributed systems that act as monitors for such formulas, namely, making all nodes of the system collaborate by local interaction to establish the validity of the formula at each point of space. By reusing previous results and tools of the field calculus, then, we prove correctness of the translation, and self-stabilisation of the derived monitors, hence their robustness to transient changes. Finally, we empirically evaluate self-adaptivity of the generated monitors in a realistic smart city scenario of safe crowd monitoring. In such a case study, we consider a target SLCS property and compare a corresponding decentralised field calculus monitor (straightforwardly obtained by applying the formula mappings) with an ideal, oracle monitor having direct complete knowledge of the entire distributed system. We show that the former monitor, despite the adversarial conditions of nearly-continuous topology change, is able to approximate the ideal monitor with reasonable precision. This demonstrates the practical viability of the approach (though, of course, its suitability ultimately depends on the relative reactivity and precision requirements of the application at hand) as well as its significance especially in scenarios where centralised services are not practicable (e.g., because of missing infrastructure) or temporarily unavailable (c.f. graceful degradation).

The remainder of this paper is organised as follows: Section 2 provides the necessary background; Section 3 illustrates how the field calculus can be used to implement distributed monitors of spatial logic properties; Section 4 presents the case study; Section 5 discusses some related work; and Section 6 concludes.

2. Background
In this section we provide the necessary background to introduce the key contribution of the paper in next section. In particular, Section 2.1 describes distributed runtime verification and how our approach relates to it, Section 2.2 introduces aggregate computing and the field calculus, and finally Section 2.3 discusses spatial logics and introduces the SLCS logics.

2.1. Distributed runtime verification
Runtime verification is a lightweight verification technique concerned with observing the execution of a system with respect to a specification (Leucker and Schallhart, 2009). Specifications are generally trace- or stream-based, with events that are mapped to atomic propositions in the underlying logic of the specification language. Popular specification languages include variations on the Linear Time Logic LTL, and regular expressions. Events may be generated through state changes or execution flow, such as method calls.

Most specifically, this paper focusses on the sub-case of so-called distributed runtime verification (Francalanza et al., 2018), aiming at defining logics to express properties of space and time, and corresponding monitors for such properties—which may or may not be distributed. In distributed runtime verification, agents (representing the system to verify at each device) are generally considered remote to each other: as constituents of the whole system, they are assumed to execute independently and occasionally synchronise or communicate with each other via the underlying communication platform. A local trace of events corresponds to a sequence of sets of values for observables, as defined through the sensors of an agent, or derived values from those. Since agents may appear or disappear over time from the overall system, traces from different processes are not aligned in time in the sense that for a particular index/position in each trace, these events did not necessarily happen at the same time. Accordingly, logic formulas cannot state properties over single traces, but one should naturally adopt an “event structure” viewpoint (Winskel, 1982), where a partial order relation between events is introduced to model causality (communication across agents, or agent internal computation steps) (Audrito et al., 2019).

Monitoring is performed by computation entities that check properties of the system under analysis by analysing traces representing partial system evolutions. Similar to the agents carrying on system execution, each monitor is hosted at a given location and may communicate with other monitors, though in general there is no strict correspondence between locations of agents and monitors. Additionally, failures, such as lost or corrupt messages, are typically ignored, for they would make the overall distributed monitor unable to carry on the verification process in a meaningful way.

The distributed monitoring approach we shall introduce in this paper is in a sense a more natural transition from traditional runtime verification. It is based on the idea of locating monitors on each device and make them execute the same local program, which amounts to evaluate single traces that include all local events as well as events from neighbouring nodes (perceived by communication). Given that the formula of a spatial logic may have a validity result that varies at each point of space, the local monitor at a device will naturally give the validity result of its location: each local result, however, has been derived through the collaboration of all local monitors through broadcast communication, hence, in a distributed way. Accordingly, unexpected changes in the system configuration (node/device faults, changes in topology, permanent loss of communications), affect the executing system in the same way they affect the distributed monitor, which will then behave accordingly and coherently. Namely, any change will be considered as a new network configuration, in which the distributed monitor will continue its verification process, taking into account the changed set of neighbours in subsequent communication rounds.

2.2. Aggregate computing
Aggregate computing (Beal et al., 2015, Viroli et al., 2019) aims at supporting reusability and composability of collective adaptive behaviour. Following the inspiration of “fields” of physics (e.g., gravitational fields), this is achieved by the notion of computational field (simply called field) (Mamei and Zambonelli, 2009), defined as a global data structure mapping devices of the distributed system to computational values. Computing with fields means deriving in a computable way an output field from a set of input fields. Field computations can be understood both locally, in terms of interactions with neighbours, or globally in terms of composition of functions on fields.

2.2.1. Computational model
In aggregate computing, the global evolution of a computing network is carried out by periodically and asynchronously executing on every device a same program  according to a cyclic schedule. Thus, every device  in the network independently performs a sequence 
 of firings, each of them consisting of the following actions:

1.
the device perceives contextual information formed by data provided by sensors, local information stored in the previous firing, and messages recently collected from neighbours1 (discarding older messages after a certain timeout), the latter in the form of a so-called neighbouring value —essentially a map 
  from neighbour devices’ identifiers 
 to corresponding values 
.

2.
then, the device evaluates the program , considering as input the contextual information gathered as described above;

3.
the result of the local computation is a data structure that is stored locally, broadcast to neighbours, and possibly fed to actuators producing output values;

4.
finally, the device goes to sleep waiting for its next firing, while gathering messages from neighbours.

Firings and their mutual relationships are modelled formally through the established notion of event structures (Lamport, 1978) and its augmented variant with device identifiers (Audrito et al., 2018a, Audrito et al., 2019). This representation focuses on the communication between devices, which is the main aspect distinguishing a distributed system from a sequential one: the relation of this representation with the physical neighbour-relationship of devices at each point in time will be discussed later (c.f. Section 2.2.2).

Definition 1 Event Structure

An event structure  is a finite or countably infinite2 set of events  together with a neighbouring relation  and a causality relation , such that the transitive closure of  forms the irreflexive partial order , and the set 
3 is finite for all  (i.e.,  and  are locally finite).

Thus, we say that 
 is a neighbour of  iff 
, and that 
 is the set of neighbours of .

Fig. 1 depicts a sample event structure, showing how the -relation partitions events into “causal past” (red), “causal future” (cyan), and non-ordered “concurrent” subspaces (black) with respect to any given event (in Fig. 1, colours reflect causality with respect to the doubly-circled event in magenta). In principle, an execution at  can depend on information from any event in its past and its results can influence any event in its future. Causality is uniquely induced by neighbouring (the  relation), dictating when an event can directly influence (by message-passing) another. Intuitively, every  relation correspond to the send and receive of a message: in order for 
 to hold, event 
 on a device 
 must result in a message which reaches a device 
 before its execution of 
. The name neighbouring reflects that message exchanges happen on devices that are close to each other (in some physical or logical sense).


Download : Download high-res image (290KB)
Download : Download full-size image
Fig. 1. Example of an event structure (which is also a LUIC augmented event structure, c.f.  Definition 2), comprising events (circles), neighbour relations (arrows), devices (ordinate axis). Colours indicate causal structure with respect to the doubly-circled event (magenta), splitting events into causal past (red), causal future (cyan) and concurrent (non-ordered, in black). The numbers written within events represent a sample space–time value (c.f.  Definition 3) associated with that event structure. Note that the doubly-circled event has three neighbouring events: event  at the same device (its previous firing), event  at device 4, and event  at device . (For interpretation of the references to colour in this figure legend, the reader is referred to the web version of this article.)

Figure taken from Audrito et al. (2018a).
Any sequence of computation events and message exchanges between them can be represented as an event structure, however, not all event structures are physically realisable by a distributed system following the firing model described at the beginning of this section. The subset of realisable event structures is characterised by the following definition.

Definition 2 LUIC Augmented Event Structure

An augmented event structure is a tuple  such that  is an event structure and  is a mapping from events to the devices where they happened. We define:

•

as the partial function4 mapping an event  to the unique event  such that  and , if such an event exists and is unique (i.e.,  is the computation performed immediately after  on the same device ); and
•
 as the relation such that 
 ( implicitly precedes 
) if and only if 
 and not 
.

We say that  is a LUIC augmented event structure if the following coherence constraints are satisfied:

•
Linearity: if 
 for  and 
, then 
 (i.e., every event  is a neighbour of at most another one on the same device);

•
Uniqueness: if 
 for  and 
, then 
 (i.e., neighbours of an event all happened on different devices);

•
Impersistence: if 
 for  and 
, then either 
 and 
 for all , or the same happens swapping 
 with 
 (i.e., an event reaches a contiguous set of events on a same device);

•
Computation immediacy: the relation  is acyclic on  (i.e., explicit causal dependencies  are consistent with implicit time dependencies ).

The first two constraints are necessary for defining the semantics of an aggregate program (denotational semantics in Audrito et al., 2019, Viroli et al., 2019). The third reflects that messages are not retrieved after they are first dropped (and in particular, they are all dropped on device reboots). The last constraint reflects the assumption that computation and communication are modelled as happening instantaneously. In this scenario, the explicit causal dependencies imply additional time dependencies 
: if 
 was able to reach  but not , the firing of 
 must have happened after  (additional details on this point may be found in the proof of Theorem 1 in Appendix B.1).

Remark 1 On Augmented Event Structures

Augmented event structures were first implicitly used in Audrito et al. (2019) for defining the denotational semantics (with the linearity and uniqueness constraints only), then formalised in Audrito et al. (2018a) (without any explicit constraint embedded in the definition). In this paper, we gathered all necessary constraints to capture exactly which augmented event structures correspond to physically plausible executions of an aggregate system (see Theorem 1): this includes both the linearity and uniqueness from Audrito et al. (2019), together with the new impersistence and computation immediacy constraints.

Notice that the event structure in Fig. 1 satisfies the LUIC constraints with the represented device assignment. Interpreting this structure in terms of physical devices and message passing, a physical device is instantiated as a chain of events connected by  relations (representing evolution of state over time with the device carrying state from one event to the next), and any  relation between devices represents information exchange from the tail neighbour to the head neighbour. Notice that this is a very flexible and permissive model: there are no assumptions about synchronisation, shared identifiers or clocks, or even regularity of events (though of course these things are not prohibited either).

Through the repetitive execution of firings (modelled by events), across space (where devices are located) and time (when devices fire), a global behaviour emerges. This global behaviour is defined in terms of global data structures called space–time values (also depicted in Fig. 1) mapping events to values for each event in an event structure.

Definition 3 Space-Time Value

Let  be any domain of computational values and  be an augmented event structure. A space–time value  is a pair comprising the event structure and a function  that maps the events  to values .

With abuse of notation, in the remainder of this paper we use  to denote  where .

A space–time value  represents a quantity that is distributed across space end evolving through time, so that its value  may be different on different events . For example,  may associate events to the corresponding measurements of a sensor  available in them, or to the current local result  of a distributed computation. These quantities can be manipulated by distributed computations (i.e., consumed as inputs) and can also be created by them (i.e., produced as outputs). Thus, an aggregate computer is a “collective” device manipulating such space–time values, modelled as a space–time function.

Definition 4 Space-Time Function

Let  be the set of all possible space–time values in a augmented event structure . Then, an -ary space–time function in  is a partial map


.
Notice that the definition of a space–time function  requires every input and output space–time value to exist in the same augmented event structure . However, it does not specify how the output space–time values are obtained from the inputs, and in fact not all space–time functions  are physically realisable by a program, as  may violate either causality or Turing-computability (see Audrito et al., 2018a for further details).

The specification of a space–time function can be either done at a low-level (i.e. through local interactions), in order to define programming language constructs and general-purpose building blocks of reusable behaviour (c.f. Section 2.2.3 for such a programming language), or at a high-level (i.e. by composition of other space–time functions with a global interpretation) in order to design collective adaptive services and whole distributed applications—which ultimately work by getting input fields from sensors and process them to produce output fields to actuators. However, in aggregate computing a distributed program  always has both the local and global interpretations, dually linked: the global interpretation as a space–time function (obtained through a denotational semantics Audrito et al., 2019, Viroli et al., 2019), and the local interpretation as a procedure performed in a firing (defined by an operational semantics, see Appendix A).

2.2.2. Stabilisation and spatial model
Even though the global interpretation of a program has to be given in spatio-temporal terms in general, for a relevant class of programs a space-only representation is also possible. In this representation, event structures, space–time values and space–time functions are replaced by network graphs, computational fields and field functions.

Definition 5 Network Graph

A network graph  is a finite set  of devices  together with a reflexive neighbouring relation , i.e., such that  for each . Thus, we say that 
 is a neighbour of  iff 
, and that 
 is the set of neighbours of .

Intuitively, an instance element 
 that belongs to the neighbouring relation  on devices (in a certain specific instant of time) represents the possibility for a device 
 to successfully send a message to another device 
, thus creating corresponding instance elements 
 of the neighbouring relation  on events for events 
 on devices 
. Notice that  does not necessarily have to be symmetric, since e.g. an high-power device may be able to send messages to a distant device with not enough power to reply. The formal relationship between relations  and  will be captured by Definition 8 below.

Definition 6 Computational Field

Let  be any domain of computational values and  be a network graph. A computational field  is a pair comprising the network graph and a function  mapping devices  to values .

Definition 7 Field Function

Let  be the set of all possible computational fields in a network graph . Then, an -ary field function in  is a partial map


.
These space-only, time-independent representations are to be interpreted as “limits for time going to infinity” of their traditional time-dependent counterparts, where the limit is defined as in the following.

Definition 8 Stabilising Augmented Event Structure and Limit

Let  be a countably infinite augmented event structure. We say that  is stabilising to its limit  iff  is the set of devices appearing infinitely often in , and for all except finitely many , the devices of neighbours are the neighbours of the device of : 

Although the notion of limit of an event structure provided by Definition 8, it is not identical to the notion of limit in analysis; they are intimately connected, justifying the usage of the same name. In concrete deployments, the augmented event structure representing a distributed computation performed over time and across space arises from a network graph (evolving over time) which represents the possible connections across devices in every instant of time. Then, the limit of the event structure is (intuitively) the network graph that is obtained for the time that goes to infinity. A similar notion of limit (and stabilisation) can also be applied to space–time values as shown in the following.

Definition 9 Stabilising Space-Time Value and Limit

Let  be a space–time value on a stabilising augmented event structure  with limit . We say that  is stabilising to its limit  iff for all except finitely many , .

Notice that  is not a parameter of the definition above, by being uniquely determined by .

Definition 10 Self-Stabilising Space-Time Function and Limit

Let


be an -ary space–time function in a stabilising  with limit . We say that  is self-stabilising with limit

iff for any 
 with limit 
, 
 with limit 
.
Many of the most commonly used routines in aggregate computing are indeed self-stabilising, and in fact belong to a class of self-stabilising functions identified in Viroli et al. (2018). In the remainder of this paper, we shall relate aggregate functions with spatial logical formulas, expressing their relationship in terms of their self-stabilising limit (see Theorem 3).

2.2.3. The field calculus
The field calculus (Audrito et al., 2019) is a minimal functional language that identifies basic constructs to manipulate aggregate fields, and whose operational semantics can act as blueprint for developing toolchains to design and deploy systems of possibly myriad devices interacting via local (e.g., proximity-based) broadcasts. The field calculus provides the necessary mechanisms to express and compose such distributed computations, by a level of abstraction that intentionally neglects explicit management of synchronisation, message exchanges between devices, position and quantity of devices, and so on. Each field calculus function comes with both a global interpretation (through a denotational semantics in terms of space–time functions and/or field functions Audrito et al., 2019, Viroli et al., 2019), and a local interpretation (through an operational semantics defining the operations performed in a firing, see Appendix A) which provides a practical and correct implementation of the global interpretation. These interpretations are so that compositionality holds, that is, function composition in the language translate to space–time function composition.

The syntax of field calculus is presented in Fig. 2, following the presentation by Audrito et al. (2020), simplified to fit the needs of this paper. The overbar notation 
 
 is a shorthand for sequences of elements, and multiple overbars are intended to be expanded together, e.g., 
 
 stands for 
 and 
 for 
. Operator  and  are the main peculiar constructs of the field calculus, the former responsible for both interaction and field dynamics, the latter for observing neighbouring values; while  and  correspond to the standard function definition and the branching expression constructs, properly adapted to fit computational fields. We remark that the field calculus comes with a type system, which performs standard checks on function calls, ensures that the arguments of  and  have the proper type, and guards of branches have Boolean type—a detailed presentation of the field calculus type system can be found in Audrito et al. (2019). In this paper, we use  (Boolean values) and  (numbers with infinity) as primitive types , together with types  for neighbouring fields built from values of type , and types 
 
 for functions.

A program  consists of a list of function definitions 
 
, each written as “
”, followed by a main expression  that is the one executed at each firing (as well as the one representing the overall field computation, in the global viewpoint). An expression  can be:


Download : Download high-res image (121KB)
Download : Download full-size image
Fig. 2. Syntax of the field calculus language.

•
A variable , used e.g. as formal parameter of functions.

•
A value , which can be of the following two kinds:

–
A local value , with structure 
 or simply  when 
 is empty (defined via data constructor  and arguments 
), can be, e.g., a Boolean ( or ), a number, a string, or a structured value (e.g., a pair or a list).

–
A neighbouring value  that associates neighbour devices  to local values , e.g., it could be the neighbouring value of distances of neighbours—note that neighbouring values are not part of the surface syntax, they are produced at runtime by evaluating expressions, as described below.

•
A function call 
 
, where  can be of two kinds: a user-declared function  (declared by the keyword , as illustrated above) or a built-in function , such as a mathematical or logical operator, a data structure operation, or a function returning the value of a sensor. The built-in functions and data constructors used in this paper are listed in Fig. 3 together with their types and formal interpretations—all of these operators are natively available in existing implementations of the field calculus, including Protelis (used in the case study presented in Section 4).

•
A branching expression 
, used to split field computation in two isolated sub-networks, where/when 
 evaluates to  or : the result is computation of 
 in the former area, and 
 in the latter.

•
A neighbouring expression , where  evaluates to a local value. It evaluates to a neighbouring value mapping neighbours to their latest available result of evaluating . Each device :

1.
shares its value of  with its neighbours, and

2.
evaluates the expression into a neighbouring value  mapping each neighbour 
 of  to the latest value that 
 has shared for .

Note that within an  branch,  is restricted to work on device events within the subspace of the branch. I.e., the evaluation by a device  of an -expression within a branch of some 
 expression, is affected only by the neighbours of  that, during their last computation cycle, evaluated the same value for the guard 
 (domain restriction, Audrito et al., 2016).
•
A share expression 
, where 
 and 
 evaluate to a local values. It incorporates message passing and local state evolution. The result of such expression is obtained by:

–
Gathering the results obtained by neighbours for the whole expression  in their last firings into a neighbouring field value .

–
Such  may also contain a value for the current device (if it is not the first firing it executes ). If not, the result of evaluating 
 is used as value for the current device and incorporated into .

–
Expression 
 is evaluated by substituting  to , obtaining the overall value  for .

–
Value  is broadcast to neighbours, allowing them to use it in constructing their following neighbours’ observation .

Note that within an  branch,  (like  as described above) is restricted to work on device events within the subspace of the branch. This construct can be used both for structuring device interaction and for evolving a local state, by using the built-in operator  which extracts the value  relative to the current device from a neighbouring field value .
Example 1

As an example illustrating the constructs of field calculus, consider the problem – typical in sensor networks – of locally detecting dangerous situations in a working area and propagating alarms to all the devices in the same area. Assume


is a Boolean built-in sensor identifying an area to be monitored (i.e., which is

in the devices within that very working area, and

elsewhere) and

is a Boolean built-in sensor which holds

if some threat is detected. The goal is to build a Boolean field of alarms such that it becomes

in the

whenever any device located there perceives some

. The main expression uses construct

to limit the computation to the space–time region where

gives

(simply returning

elsewhere):

Download : Download high-res image (16KB)
Download : Download full-size image
We have made use of abstraction and specified the logic of alarm propagation through a function

, defined as follows:

Download : Download high-res image (32KB)
Download : Download full-size image
This function takes a Boolean field

and, whenever it holds a

value in a device, this gets propagated throughout the network by gossipping. This is achieved by using

to handle state and communication: a device is alarmed if it is currently perceiving some danger (

is true) or any of its neighbours, including itself, have perceived danger in their previous round (

). Notice that when a device is alarmed, it continues to be so indefinitely (unless changes in the working area cause the computation to be skipped, hence refreshing the corresponding state).
A formal account of the field calculus operational semantics, formalising the behaviour of a firing, is given in Appendix A. Essentially, each expression evaluation creates a tree of “values” (corresponding to the unfolding of expression evaluation), containing values to be exported to neighbours (due to operators  and ): at the end of a firing, the resulting tree is packed and sent to neighbours, which will use it locally to support the semantics of  and .

The computation within a single device is modelled by judgement “
”, to be read “expression 
 evaluates to  on device  with respect to the value-tree environment  and sensor state ”, where  is the evaluation result of 
 as a value-tree,  is a map from each neighbour device 
 (including  itself) to the value-tree 
 produced in its last firing, and  is a data structure containing sensor information required to compute built-ins (like


and

of Example 1) related to sensors.
The overall evolution of the network is then modelled by a transition system 
 on network configurations .  models the environmental conditions, where the device neighbouring relation  (c.f.  Definition 5) models network connection topology and the computational field  (c.f. Definition 6) models sensor values on each device (see Appendix A.2 for further details).  models the overall status of the devices in the network at a given time (as a map from device identifiers to value-tree environments ), and actions  can either be firings of a device () or network configuration changes ().

The system evolution formalised as a sequence of transition 
 
 
 can then be modelled through the more abstract notion of augmented event structure and space–time value (c.f. Section 2.2.1). In fact, every system evolution  induces a unique LUIC augmented event structure  (i.e.,  is completely determined by ), whereas every LUIC augmented event structure is induced by multiple system evolutions, as shown in the following theorem.

Theorem 1 Semantic Completeness

Let  be a LUIC augmented event structure. Then there exist (infinitely many) system evolutions  that induce .

Proof

See Appendix B.1.  □

This result ensures that the linearity, uniqueness, impersistence, and computation immediacy constraints characterise exactly the set of event structures that can arise from the execution of such a system.

2.3. Spatial logics and SLCS
In traditional model checking and runtime verification of distributed and concurrent systems, properties expressed as a temporal logic formula (see for instance Ben-Ari et al., 1983, Emerson, 1990) are either statically or dynamically checked for satisfaction. Thus, properties of the temporal evolution of a system are considered, but properties of (physical) space typically are not. Spatial logics (van Benthem and Bezhanishvili, 2007) are topological interpretations of modal logics, whose purpose is to enable reasoning about the spatial dimension. These logics are based on two main modalities:  (holds in the interior of points where  holds) and  (holds in the closure of points where  holds). Other modalities have been considered during the years: of particular interest to us is a spatial surrounded operator—inspired by the temporal weak until operator—that first appeared for topological spaces in Aiello (2002).


Download : Download high-res image (226KB)
Download : Download full-size image
Fig. 4. Pictorial representation of a closure space  induced by a graph.

In Ciancia et al. (2014), a Spatial Logic of Closure Spaces (SLCS in short) based on the above mentioned operators has been formalised for the more general setting of closure spaces, which can be formalised as a set  together with a closure operator 
 mapping set of points to their closure.5 These spaces include the category of quasi-discrete closure spaces, which are conveniently characterised as the topologies arising from discrete directed graphs  with 
,  for all  (c.f. network graphs as in Definition 5): in this case, the set of points is  and closure is interpreted as “proximity”: .6

A logic on quasi-discrete closure spaces is thus able to express properties of discrete networks of devices: a pictorial representation of this concept is given in Fig. 4. In Ciancia et al. (2014), an efficient proof-of-concept model checker for SLCS on quasi-discrete closure spaces has been implemented.7 In Section 3 we shall investigate how to perform distributed runtime verification on SLCS properties through aggregate computing techniques (in particular, devising a translation of properties into field calculus programs computing their truth in every node of the network of computing devices). In Ciancia et al. (2014), the presentation of the SLCS logic was first given in terms of the closure operator; then, for the special case of quasi-discrete closure spaces, formulations of SLCS operators in terms of paths in a graph were devised and proven equivalent. In the remainder of this paper, we shall only consider quasi-discrete closure spaces, modelled through network graphs, using the equivalent formulations of SLCS operators in terms of paths in a graph as their primitive definition.

•
 (interior) which is true at points with all neighbours satisfying 8;

•
 (closure) which is true at points with some neighbour satisfying ;

•
 (boundary) which is true at points with some (but not all) neighbours satisfying ;

•
 (interior boundary) which is true at points satisfying  with some neighbour not satisfying it;

•
 (closure boundary) which is true at points not satisfying  with some neighbour satisfying it.

The global modalities are:

•
 (reaches) which is true at the ending points of paths (i.e., sequences 
 in the directed graph  inducing the quasi-discrete closure space) whose starting point satisfy  and where  holds;

•
 (touches) which is true at the ending points of paths whose starting point satisfy  and where  holds in the rest of the path;

•
 (surrounded by) which is true at points in an area  satisfying , whose neighbours satisfy ;

•
 (everywhere) which is true at points where  holds in every incoming path;

•
 (somewhere) which is true at points where  holds in a point of an incoming path.

The whole list of modalities is redundant, meaning that they can all be expressed through  and  only, by means of the equivalences expressed in Fig. 5 (bottom). Fig. 5 (centre) presents a semantics for a minimal set of logical connectives and local modalities, and for every global modality. Semantics models are of the form , where  is a network graph and 
 maps every propositional variable  to the subset of devices where  holds. Semantics for global modalities is defined through properties of paths in graph  towards , defined as sequences 
 such that 
. We use 
 to denote the set of such paths.

SLCS being a spatial logics, it is worth noticing that its formulas generally have different values in different points of space. A notable exception is the case of formulas that are a logical combination (i.e., via non-modal operators) of formulas that have  or  as top connective, in a strongly connected9 graph: in these cases they are either true or false in all points of space—so, the specified monitors emit a global verdict.

Remark 2

On the Relation with Ciancia et al., 2014
The presentation of SLCS in Ciancia et al. (2014) differs in many relevant though not fundamental ways.

Firstly, semantics was primitively given for closure spaces, substituting  with pairs  where 
, and only afterwards a semantic interpretation on graphs through paths was derived (Ciancia et al., 2014 Theorem 3 and Remark 3). Even though the semantics on closure spaces is more general, it is not exploited by the model checker in Ciancia et al. (2014), which only applies to quasi-discrete closure spaces defined in terms of graphs. Since the generality of closure spaces does not seem to translate into additional applicability, we opted for a presentation natively rooted on graphs.

Secondly, the primitive global modality in Ciancia et al. (2014) is  instead of , since  has a cleaner definition in terms of closure spaces:  holds in  iff  such that ,  holds in  and  holds in 
. Conversely, in our presentation rooted on graphs  has a simpler definition than  (and is more easily computable), and thus was chosen as a primitive modality.

Thirdly, and most importantly, the operator 
 called reach in Ciancia et al. (2014) is similar but not identical to ours. There, ⊧
 if and only if: 
⊧
⊧In particular, the difference is in that  is not required to hold in . Although this choice being counter-intuitive (and inconvenient in practice), this version of the reachability operator was preferred since it is the dual of the  operator: 
. We opted for a presentation tailored for formulas on graphs, for which operator  is more relevant (and easily computable) than 
. Notice also that the two operators are interchangeable through the equivalences 
 and 
.

Finally, the touch operator is not present in Ciancia et al. (2014). However, it is defined in Ciancia et al. (2018) as 
, which can be proven equivalent to our definition.

Remark 3 On Modality Equivalences

Since we both gave a direct semantic interpretation of , , ,  and a definition of them in terms of , the two must be proven equivalent. For , it boils down to an easy substitution exercise. For , substitution gives 
⊧; and if a path satisfies the direct interpretation of , the restricted path 
 satisfies the interpretation through . For , substitution gives the following: 
⊧
⊧which is satisfied whenever the direct interpretation of  is satisfied with the extended path 
.

For , we use the result from Ciancia et al. (2014) that 
 (with the semantic interpretation of  in Fig. 5 (centre) and the semantic interpretation of 
 in Remark 2). We can then use the equivalence 
 in order to obtain that: 

Example 2 Smart Home

As sample application of SLCS in a smart home scenario, consider the following property to monitor: air conditioning and lights are on whenever the room is not empty, off otherwise. Consider the atomic propositions:

•
 is true on points that are sensing the presence of people;

•
 is true on points that are the monitored electrical devices (air conditioning, lights);

•
 is true on electrical devices that are on.

If we only want to consider the presence of people in the immediate vicinity, the considered property can be written as . When also considering people farther away, the property can be written as . In the sample closure space of Fig. 4, a possible evaluation of these properties could be the following, where different colours are used for points where  is false (grey),  is true and  is false (black),  and  are true (yellow):



Download : Download high-res image (154KB)
Download : Download full-size image
The green area denotes the nodes for which  is true, i.e., the nodes that do perceive at least a person in the room. The cyan area () is given by the nodes that have at least a neighbour within the green area. The blue area () is given by the nodes for which there exists a path to a node in  (“somewhere”); this includes all the nodes of the example.

Example 3 Sensor Network

As sample application of SLCS in a sensor network scenario, consider the following property to monitor: internet is reachable through non-busy devices. Consider the atomic propositions:

•
 is true on busy devices;

•
 is true on devices that have an internet connection.

The considered property can then be written as . An evaluation of this formula is represented in the following picture, where the purple area marks points where the formula is false and different colours are used for points where  is true (red),  is true (blue), or none are true (grey).



Download : Download high-res image (101KB)
Download : Download full-size image
In the central part of the network, the property is false because there is no path from the grey nodes inside it to a blue (Internet) node which does not pass through a red (busy) node; i.e., the red nodes make up a perimeter which does not contain any blue node.

Example 4 Emergency

As sample application of SLCS in an emergency scenario, consider the following property to monitor: dangerous areas are surrounded by non-dangerous areas from which it is possible to reach a recovery point without crossing any other dangerous area. Consider the atomic propositions:

•
 is true on devices in dangerous areas;

•
 is true on devices in recovery points.

The considered property can then be written as . An evaluation of this formula is represented in the following picture, where the purple area marks points where the formula is false and different colours are used for points where  is true (red),  is true (blue), or none are true (grey).



Download : Download high-res image (88KB)
Download : Download full-size image
The property is false for the two red (dangerous area) nodes at the top left of the network because the grey node above them is unable to reach a blue (recovery point) node without passing through a red (dangerous) node.

3. Automatic generation of distributed monitors in field calculus
In this section, we provide a translation of SLCS formulas into field calculus. Namely, thanks to the functional nature of field calculus, the resulting distributed monitor will provide efficient computation of the truth value of a formula at each device by recursion over its syntactic structure, and this will be achieved assuming that each participant is evaluating the same property from its perspective with regard to any quantifiers. In particular, we translate atomic propositions  into built-in function calls getting their value from some external environment (which we do not detail here, since typically involving external sensors), logical connectives into corresponding Boolean built-ins, and modal spatial operators into field calculus library functions that perform spatial operations (such as propagating values through spanning trees to compute distances). The functional composition character of field calculus, which works at the global level, is the distinctive feature by which this model allows to easily express the translation, as well as to formally prove self-stabilisation of the resulting monitors. Section 3.1 introduces a translation of SLCS into field calculus, coherently with the formal interpretation (c.f. Section 2.3). Section 3.2 discusses the correctness and efficiency properties of this translation.

3.1. Automatic translation in field calculus
Fig. 6, Fig. 7 show the translation  of an SLCS formula  into field calculus, which essentially derives a space–time function that turns Boolean space–time values for the atomic propositions () into a Boolean space–time value representing the validity of the monitored formula over space and time—validity depends on time in the transient phase, when the validity of atomic propositions symbols change, or if network topology changes. The correspondence of the translation with the SLCS semantics (c.f. Fig. 5) is formally given by Theorem 3, which shows that the limit of the translated space–time value always match the computational field defined by the SLCS formula (c.f. Definition 8). This translation uses the data constructors and built-in functions described in Fig. 3, and assumes that:


Download : Download high-res image (182KB)
Download : Download full-size image
Fig. 6. Translation  of an SLCS formula  into field calculus. Only the logical operators and the spatial operators , ,  and  are considered—the other spatial operators (, 
, 
,  and ) can be translated by rewriting them through the considered ones according to Fig. 5 (bottom).


Download : Download high-res image (173KB)
Download : Download full-size image
Fig. 7. Functions


and

used in the translation of Fig. 6, in turn using the auxiliary function

.
•

, as in common programming languages such as Python;
•

is a commonly used algorithm (based on Bellman–Ford algorithm, available in the standard libraries of field calculus implementations) determining the shortest distance (in network hops) to a destination point (Viroli et al., 2018);
•

is a field calculus function which is true whenever the shortest distance to a point where the argument holds is plausible (smaller than the network diameter

in hops). In many cases, the parameter  can be determined at network design time, allowing to run the translation in Fig. 6 as is. When this is not possible, the translation can still be applied by incorporating strategies for dynamically estimating the diameter: e.g., computing the maximum distance from an elected leader (Mo et al., 2020);
•

is a field calculus function which is true only in connected areas where

is true and somewhere in that area

is also true (since in that case there must be a path staying within the area where

is true which reaches a point where

is true).
Remark 4 Translation of Derived Modalities

The translation in Fig. 6 is defined also for the derived modalities ,  and all derived logical operators. The translation given is coherent with the definition of those derived operators in terms of the primitive ones. For logical operators, this equivalence is standard. For the interior modality, notice that its definition  in terms of primitives is translated into the (valid) equivalence:


Download : Download high-res image (16KB)
Download : Download full-size image
Similarly, the definition  of  in terms of primitives translates to the valid equivalence:
In the next section, the coherence between translation and operator definitions explained in Remark 4 will be extended by (and be a consequence of) Theorem 3, which proves that the translation is coherent with the semantics of all primitive and derived operators (c.f.  Fig. 5 centre).

It may be tempting to implement


with function

in Example 1, instead of the implementation proposed in Fig. 7. However, this function is not able to adjust its value from

to

in case all the points satisfying the argument disappear from the network (namely, it is not self-stabilising c.f.  Definition 10): thus, this approach would only work in a fully static situation and could not be used in a dynamic environment for tracking the truth value of the spatial formula over time. Several approaches could be used for implementing a self-adjusting

routine in field calculus: e.g. with replicated gossip (Pianini et al., 2016) or by combining several commonly used building blocks (Beal and Viroli, 2014) (S for leader election, G for distance estimation and broadcasting, C for data summarisation). The proposed one, however, excels by its simplicity and efficiency (see Theorem 2) while providing optimal reactiveness to input changes (see Theorem 3).
The reader may appreciate the simplicity of the proposed translation, which is compositional (i.e. defining the translation of an expression by composing translations of sub-expressions) thanks to the functional paradigm of field computations, and which hints at the power of field calculus as an implementation technique for higher-level languages and logic frameworks. Indeed, complex behaviours can arise at the level of device interactions, but they are hidden under the hood of the computational model and the lower-level functions used in the translation.

Example 5 Formula Translation

The translation of the surrounded by operator 
 is


, where

Download : Download high-res image (25KB)
Download : Download full-size image
Then, the translation of the formulas in Examples 2, 3, 4 are the following.
3.2. Properties of the translation
Firstly, we show that the monitors obtained from the translation of SLCS formulas are efficient and lightweight, being able to scale to arbitrary network sizes and easily runnable on low-end devices.

Theorem 2 Lightweightness

The translation  of a formula  according to Fig. 6 computes in each node using message size  and computation time/space , where  is neighbourhood size and  are the numbers of logical and spatial operators in .

Proof

See Appendix B.2.  □

Notice that the bounds on message size, computation time and space provided above are asymptotically optimal, and thus the translated program can be deemed efficient and lightweight. Furthermore, these bounds do not depend on the network size, implying that the computation can scale up to arbitrarily large networks, as long as the individual degree of nodes stays bounded. In practice, we can expect a firing to be executed within few microseconds of CPU time in any realistic scenario.

We are now able to prove that the given translation is correct and optimal. Correctness will be shown in terms of stabilisation to the correct limit, as formalised in Definition 8 for space–time functions. In fact, this definition can be translated to field calculus functions and expressions by means of the following definition:

Definition 11 Stabilising Expression

A field calculus expression  is stabilising with limit  on  iff for any system evolution 
 
 of program  such that for some 
 and each 
, the environment 
 in 
 is the same10 and has topology given by , and there are infinitely many  transitions for each  in , then for some 
 and each 
 the value produced in each firing  is exactly .

Optimality will then be measured as having the lowest bound on the number of full rounds of execution required for stabilisation.

Definition 12 Full round of execution

Let 
 be a (possibly infinite) network evolution consisting only of device fires. We say that one full rounds of execution has passed at step  if  is minimal such that for each device  in the network, there exists an  such that 
. Similarly, we say that  full rounds of execution has passed at step  if  full rounds of execution has passed at step 
, and one full round of execution has passed at step 
 in the reduced network evolution 
 
.

Self-stabilisation of the monitor comes as a direct consequence of the results in Viroli et al. (2018), since all expressions in Fig. 6 belong to the self-stabilising fragment of the field calculus thereby identified. In the following theorem, however, we shall also prove that its limit is the value of the SLCS formula (c.f.  Fig. 5 centre), and that it is obtained with the lowest possible number of full rounds of execution.

Theorem 3 Self-Stabilisation, Correctness, Optimality

Let  be the translation of  according to Fig. 6. If the network configuration and atomic propositions stabilise, the result of  also stabilises to the interpretation of  in that final configuration (regardless of the evolution history of the network). Furthermore, the time required for stabilisation is as small as possible, meaning that no correct inductive translation can stabilise with a smaller worst case of full rounds of execution.

Proof

See Appendix B.3.  □

According to the above theorem, and assuming the network is connected, then:

•
When the network configuration and atomic propositions become stable, the field calculus monitor  stabilises (as fast as possible), and compute in each device the correct value of the SLCS formula .

•
When the network configuration and atomic propositions keep evolving, the field calculus monitor  keeps bringing about the correct validity of the formula  at each device: due to intrinsic delays in communication, then, the snapshot of a result at a device may not be correct. However, given the simple and natural structure of the


algorithm used in the translation, one still expects fast reactiveness to changes in a regime of persistent perturbation without stable points—even though it is harder to characterise reactiveness formally. This claim will be validated through simulation in Section 4.
Note that, if the network is divided in two or more disconnect sub-network, then the above bullets apply to each sub-network.

4. Case study: crowd safety
The previous section proved the correctness and self-stabilising nature of field calculus translations of SLCS properties. Though field calculus monitors are guaranteed to eventually converge to the correct value, it is still open the question of whether they are reasonably reactive, i.e., whether the approach can be useful in application settings characterised by frequent or continuous change. Accordingly, in this section, we demonstrate the proposed approach in a large-scale computing scenario related to crowd safety (described in Section 4.1), by means of simulation (as described in Section 4.2). That is, we show a concrete example of translation from SLCS to field calculus, leading to a distributed monitor whose reactive behaviour is verified by means of repeated experiments. Most specifically, we focus on the ability of such a monitor to produce an output that eventually converges to that of an ideal monitor, implemented as an oracle that checks the SLCS property exhaustively in every state of the simulated system and accordingly provides, at each simulation step, the correct value that should be computed by every device participating in the system. Especially, we will show the ability of the monitor to keep up with continuous change (change in connection topology) in the environment. Indeed, while the oracle has instantaneous access to the global state of the distributed system under simulation, the field calculus monitor runs in a decentralised fashion, where each device can only directly observe (by exchanging messages with neighbours) a local portion of the overall system, and therefore it takes some time to converge to the correct value. Notice that a single local change in the system – e.g., a single connectivity link that changes – may potentially cause a SLCS property to globally flip (as exemplified in Fig. 10). In other words, given an execution round of some device, the oracle provides the correct value that such a device could compute if it had access to the global state of the evolving distributed system (which is clearly an unrealistic assumption). Moreover, though convergence is eventually guaranteed for constant input (as covered in Section 3), the monitor should also be “enough reactive” to bring the error (measured by the difference between the SLCS property field and the field provided by the oracle) at acceptable levels (which are, still, generally application-specific). Experimental results are presented in Section 4.3, whereas further discussion about this latter aspect is available in Section 4.4.

The source code, build infrastructure, and instructions for running and reproducing the experiments are publicly available online.11

4.1. Simulation scenario
The scenario leverages real-world data of a recent mass event (Anzengruber et al., 2013), consisting of anonymised GPS traces recorded from a subset of the visitors. This is an example where very large numbers of people move around the city, possibly leading to bloats or situations of danger. In this setting, scalable crowd analysis and management algorithms can help to provide safety and services for a better experience, e.g., by estimating the density of the crowd, propagating information about the crowd to the surroundings, and supporting crowd-aware dispersal and navigation.

Aggregate programming techniques have proven to be effective in expressing such crowd management algorithms by a global perspective, and to make them execute in an adaptive, resilient and decentralised fashion (Beal et al., 2015, Casadei et al., 2019a). With this approach, each participant has a smartphone or another wearable device that provides sensor data (e.g., presence of people nearby) and outputs local information (e.g., the suggested direction of movement to avoid overcrowded areas) for the person as computed by the collectively executed aggregate program. In practice, multiple concrete deployments are possible, ranging from fully peer-to-peer to cloud-based architectural styles (Viroli et al., 2016). Given the costs of testing new services for the proposed real-world scenario, we proceed empirically by simulation, considering a reasonable aggregate system deployment where nodes perform their firing in a non-synchronous fashion and interact with all the devices closer to them with respect to a certain, configurable threshold. More details are provided in the next section and are available at the attached repository. Finally, it is key to consider that this approach does not require either global knowledge (e.g., the GPS positions of devices and locations) or global connectivity to the Internet (which may be limited in mass events), therefore providing a viable solution for guaranteeing (continuity of) services in situations where only minimal assumptions hold, through graceful degradation (if any).

For the purpose of this paper, we focus on monitoring the safety property represented by the SLCS formula in Example 4: where  denotes a “dangerous area” (i.e., an area which is overcrowded or in the very proximity of one) and  denotes a “base” or “safe area” (e.g., an exit for dispersal or an area with medical facilities). The above property can be read as “dangerous areas are surrounded by devices which can safely reach a base”; in other words, this is to guarantee that large groups of people do not hinder the way to exit or other important locations to other people. A visual representation of the scenario is provided in Fig. 8 (full-size, colour pictures are included in the provided repository).

Note that the reachability of safe points is based on connectivity paths across the system of devices; in other words, each neighbouring link between two nodes should represent a valid hint for an accessible, walkable path. Therefore, in this simulated scenario it is assumed that links can actually be followed on foot, and that there is a sufficiently dense (but still quite sparse) network in place—otherwise, the system would consist of multiple isolated sub-networks with trivial results. To improve realism, for the simulations, the GPS traces are interpolated to place nodes on actual streets. Moreover, the system neglects other potential paths passing through streets which are not “sampled” by any device; nevertheless, the presented solution also shall work when devices do not have maps (which, anyway, should be augmented with crowding data), since a “map” is implicitly constructed (though, of course, actual accessibility should be fostered with proper design decisions).


Download : Download high-res image (2MB)
Download : Download full-size image
Fig. 8. Representation of a snapshot of the simulated scenario, as a network of devices in the city: black dots denote (the smartphones of) people corresponding to the GPS traces of the reference mass event; grey links represent connectivity (i.e., the neighbouring relationships); yellow, orange, and red overlays represent increasing levels of crowding; blue squares denote safe places (these are real locations of hospital facilities); small, light blue squares represent access points.


Download : Download high-res image (1MB)
Download : Download full-size image
Fig. 9. Protelis implementation of the aggregate specification executed for the case study. Bold red symbols denote language keywords; bold blue symbols denote standard library functions; bold purple symbols denote application-related functions; bold black symbols denote SLCS functions; and bold orange symbols denote parameters, constants, or built-ins whose declaration is not reported. (For interpretation of the references to colour in this figure legend, the reader is referred to the web version of this article.)


Download : Download high-res image (1MB)
Download : Download full-size image
Fig. 10. These zoomed snapshots of the scenario are meant to illustrate the property checking. We assume safe areas are only south of the river, and there are no paths that circumvent the Reichsbrücke bridge shown in the picture.

4.2. Simulation framework and setup
For these experiments, we leverage the meta-simulator Alchemist (Pianini et al., 2013) which provides an event-driven simulation engine for scheduling events and actions upon modelled entities as well as features for configuration of scenarios, visualisation and data extraction. The translated monitors are written in Protelis (Pianini et al., 2015), an implementation of the field calculus as a standalone domain-specific language that also provides a library of reusable aggregate building blocks and interoperability with the Java ecosystem.

The scenario is configured as follows: a total of 1497 nodes are loaded at the starting positions of the corresponding available GPS traces and configured to move according to their traces as well as to execute the aggregate program and broadcast data to neighbours once about every 
 second(s). Since the network inferred by the data traces is quite sparse relatively to the physical region of the city, a mesh of access points is put in place to provide a reasonable level of connectivity for the system. While normal devices are assumed to have a connectivity range of  (i.e., around the maximum Wi-Fi range), access points connect to each other within a  range; these choices have been made as a compromise between simplicity and realism—more deployment-related considerations will follow.

An excerpt of the aggregate program implementation is provided in Fig. 9. Dangerous areas (i.e., nodes where field


is true) are those which are either

or

(i.e., nearby overcrowded areas by a certain threshold), as computed by aggregate function

, whereas safe areas are given by predefined nodes having a corresponding property as true. The crowd detection functionality and its parameterisation are taken from Beal et al. (2015). The last expression of the listing is the property to be monitored, expressed straightforwardly through the SLCS functions: it yields a Boolean field that is true in the nodes in which the property is satisfied, and false where this is not the case.
The code of Fig. 9 is then extended with simulation-specific code for the parameterised configuration of the scenario, for the oracle, and for data extraction. The oracle, whose goal is to objectively check the property by inspecting the state of the system, is executed by-need when a device in  fires; its implementation leverages JGraphT (Michail et al., 2020) for representing the partitioned network of non/dangerous devices and calculating connected sets in order to check graph reachability of safe nodes. Moreover, in order to stress the monitor, there is additional aggregate code to activate, from  to , a simple crowd dispersal algorithm that changes network topology: nodes close to risk are suggested to move in the direction opposite to the nearest dangerous node (which performs a spatial broadcast of its GPS position). Nodes are configured with a certain, individual probability to follow the dispersal advice; so, when the advice is given, and they “choose” to follow it, they move in the suggested dispersal direction, hence departing from the recorded GPS trace.

4.3. Simulation results
The scenario described above is run 100 times, each with a different random seed, yielding 100 different simulation instances. The random seed is given as input to the pseudo-random generator of the Alchemist simulator, which affects (i) the displacement of access points into random mesh-like arrangements (i.e., whereas the smartphones are positioned according to the GPS traces, which are always the same, and hospitals have precise fixed locations, the access points are positioned along a grid with random shifts along the ideal latitude and longitude positions in each different instance), (ii) the tendency of people to follow the dispersal advice, and (iii) the relative ordering of the computation rounds scheduled at the devices. These aspects may affect the dynamics of the system as well as the trajectory of the SLCS property in non-trivial ways, since the appearance or the vanishing of few connectivity links could make a huge difference. Each simulation instance is executed for  seconds of simulated time. For each run, on every second of simulated time, the following data is exported: the number of devices which are overcrowded, at risk, and monitored (the monitor needs to run on all the devices, but the property is relevant only on devices in , so, as an optimisation, only for these the oracle is executed); the number of devices for which the monitor and the oracle yield a positive response, as well as the number of devices for which the monitor and the oracle provide a different response (i.e., this is a measure of the error), detailed with the count of false positives (i.e., erroneous monitor evaluations suggesting the property is satisfied when it is not the case) and false negatives (i.e., erroneous unsatisfiability claims).

The results are shown in Fig. 11. In particular, Fig. 11(a) shows how the level of crowding varies over time, also by the effect of the crowd dispersal process, which makes nodes in danger and those close to risky areas disperse. It is possible to appreciate a reduction of the dangerous areas, as well as a reduction of devices at risk (after an initial increase due to the dispersal dynamics).

In Fig. 11(b), we have a view of how the property evolves in the system and, more interestingly, we can observe how the response of the distributed, field calculus monitor “follows” the response of the oracle, with a certain delay and with a varying error that can be more precisely observed in Fig. 11(c) (by counting the number of different individual responses) and in Fig. 11(d) (by counting the number of false positives and false negatives). Moreover, after the crowd dispersal, the number of devices for which the property is true is larger relative to the number of monitored devices. The error for this scenario is, on average, around 10%–20%; though not bad, this figure could easily improve by increasing system stability (the sparseness of the used dataset produces high variability due to network fragmentation). Also, interestingly, note that the monitor tends to provide more false negatives than false positives (i.e., it finds harder to claim the property is satisfied when it is actually not the case), which may be important for safety properties.

So, in summary, the field calculus monitor provides a reasonable approximation of an ideal monitor, but works in a decentralised, self-healing fashion, with devices providing an evaluation of the property by their local perspective, but still achieving (eventual) collective coherence through the continuous coordination with neighbours as regulated by the aggregate specification.

4.4. Discussion
The experiments demonstrate the technical validity of the field calculus solution for the monitoring of SLCS properties. While “eventual” stabilisation of the monitor outcome to the expected correct values is guaranteed by the theorems in previous section, this empirical evaluation actually shows that even in systems with quite dynamic topology, the inherent error in prediction remains to an acceptable bound. Indeed, Theorem 3 shows that a field calculus monitor obtained by translation of a SLCS formula stabilises to the truth value of that logical formula, after a sufficient number of rounds with no changes. However, in many practical application scenarios, small changes may happen almost continuously; in such circumstances, Theorem 3 does not help, since its premises may get invalidated very soon. The experimental evaluation shows that also in a scenario characterised by mobility and therefore continuous perturbations (as induced by changes in topology), the truth values computed by the monitor are sufficiently close to the ideal truth values at each instant (where the level of “sufficiency” depends on the particular application). In other words, the experimental results outlined in Section 4.3 show that the approach can cover practical cases that go beyond the hypothesis of formal theorems.

We stress that the monitor exercised in this section is distributed (actually, decentralised) and self-adaptive. Notice that distribution is simulated: we did not perform an actual large-scale deployment but rather simulated a network of smartphones and access points communicating based on spatial proximity (according to a typical Wi-Fi range). The logical computational model of the field calculus is intrinsically decentralised in control: it assumes each node repeatedly runs the program and shares coordination messages with neighbours—there is no centralised entity orchestrating the system. Adaptiveness is driven by the field calculus program and stems from the specifics of the execution model (as it may affect the relative order of operations), the environmental dynamics, and the evolution of the state of the system. In a computational round, a device executes the field calculus program against an up-to-date context that considers sensor data and recent messages received from neighbours. A change in the context will probably cause the device to also change its state, its outputs, and the messages it will send to neighbours—which in turn will adapt to their new context. In this way, local changes propagate through neighbourhoods to affect increasingly non-local portions of the network, ultimately affecting other localities. Essentially, the field calculus program is responsible for organising local adaptations such that they bring to the desired globally distributed state. In the case study, a portion of the program is responsible for computing and evaluating the level of density; as the people with the smartphones move in the city, the system topology changes, and such a density level (a distributed field, which has potentially different values for different nodes of the network) changes as well. The SLCS property under evaluation also adapts as the estimated density level and the topology of the system changes.

Concerning performance, most specifically, the field calculus monitor necessarily “follows” the oracle with some delay. The reactivity of the system can be regulated through proper parameterisation and algorithmic optimisations. For instance, components affecting how fast the system can respond to perturbations include, e.g., the frequency of firings and communications, the time for which neighbour data is considered valid, the estimation of the network diameter, and the particular gradient algorithm (Audrito et al., 2018b) adopted (which is used to set up the distributed structure for information propagation and collection). Of course, any application scenario is potentially different, and the above parameters should be tuned accordingly to the expected levels of variability. Additionally, there is a sort of algorithmic inertia that should be taken into account: for instance, non-reachability takes a number of  rounds to be proved; so, countermeasures could be taken to “delay” invalidation of results. Also, network partitioning may be particularly problematic: consider an unsafe partition whose connected set does not include a safe node. A node moving from such an unsafe partition to a safe partition while touching, at the same time, a non-dangerous, safe cluster and a dangerous cluster, can compromise the latter if stale data is not removed and is immediately used to contribute to a property evaluation decision (c.f. 


). In this case, delaying contributions and short retention windows for neighbour data could help to mitigate disruptions.
Regarding the deployment and operational execution of aggregate systems, various options are available (Viroli et al., 2016). Devices may locally run the field calculus program and directly communicate with neighbours or delegate these tasks to other (e.g., more powerful) devices—in that case, however, they must, at a minimum, provide sensor data and receive output/actuation data. So, in this latter view, access points may be useful to provide neighbourhood connectivity extending normal Wi-Fi range of smartphones as well as fog-level computing support.

4.5. Further considerations on applicability
In light of the above considerations, we can finally discuss the suitability of the approach for various systems and scenarios. First of all, due to the delays involved, the approach may not be adequate for applications where real-time exact responses are expected (although preliminary results on the applicability of aggregate computing techniques to real-time scenarios have already been investigated in Audrito et al., 2018c). However, this limitation holds in general for decentralised solutions where global knowledge has to incrementally build up from local knowledge. Instead, the approach can be particularly useful when some delay or error can be tolerated. Typically, such a tolerance depends on application requirements and is related to constraints and situations to withstand. For instance, scenarios characterised by adversarial conditions such as frequent changes able to potentially affect global properties (i.e., like the one considered in this section) require certain levels of reactivity for the monitoring system to be useable and useful at all. In these kinds of systems, decentralised monitoring approaches should be evaluated on a case-by-case basis.

On the other hand, the proposed approach nicely fits scenarios characterised by moderate change and where approximated responses are acceptable during transient phases. Decentralised approaches are also favourable in very large-scale settings, to avoid single-points-of-failures, when there is no infrastructure in place, and as fallback solutions where centralised servers become unavailable (c.f. graceful degradation).

Additionally, recall that reactivity and precision of field calculus SLCS monitors are related to a few network characteristics. For instance, the larger the network diameter (i.e., number of hops of the longest shortest path), the longer it takes for information to reach the whole network, hence directly affecting the timing of


and

. This problem could be mitigated, e.g., by applying the divide-et-impera principle and organising the system into bounded working areas (Casadei et al., 2019b), possibly overlapping as per Casadei et al. (2021), to enable multiple monitoring slices, and constructed by leveraging gradients originating from a selection of the safe places. The hop-by-hop propagation time is also affected by the frequency with which computational rounds are executed by the devices—which, in general, may depend on device energy levels, technical requirements and limitations (c.f. LoRaWAN systems Adelantado et al., 2017), or design choices. The relative frequency of round executions and environment dynamics also determines the reactivity with which inputs are considered. Last but not least, higher density (i.e., average number of neighbours) levels can provide higher stability, as changes are less likely to be disruptive.
5. Related work
As discussed in  Section 2, our idea of specifying a property in a modal logic and then evaluating it step-wise is most closely related with the field of runtime verification (Leucker and Schallhart, 2009): while in runtime verification properties are usually specified in a temporal logic with operators such as always and eventually, here the modalities are spatial like or everywhere and somewhere. Nonetheless, the core aspect of runtime verification, the evaluation of properties as the system runs, is preserved in our setting: from the perspective of each device, the property is evaluated to a truth value every step, where a step here corresponds to a firing on each device.

While traditionally runtime verification considers evaluating a property on a single trace, the extension to distributed runtime verification makes the participation of multiple entities explicit. We discuss this sub-field in the following.

5.1. Distributed runtime verification and spatial logics
Distributed runtime verification lifts the concept of runtime verification to distributed systems (see Francalanza et al., 2018 for a survey), finding applications in the following areas: (i) observing distributed computations & expressiveness (specifications over the distributed systems), (ii) analysis decomposition (coupled composition of system- and monitoring components), (iii) exploiting parallellism (in the evaluation of monitors), (iv) fault tolerance and (v) efficiency gains (by optimising communication). In the following, we discuss some works in this area are related to our aim, though none of them address the dynamisms at the same level; most assume a fixed number of participants and fixed communication topology.

Bauer and Falcone (2016) show a decentralised monitoring approach where disjoint atomic propositions in a global LTL property are monitored without a central observer in their respective components: communication overhead is shown to be lower than the number of messages that would need to be sent to a central observer. Sen et al. (2004) introduce PT-DTL to specify distributed properties in a past time temporal logic, where subformulas in a specification are explicitly annotated with the node (or process) where the subformula should be evaluated: communication of results of subcomputation is handled by message passing. Both approaches assume a total communication topology, i.e., each node can send messages to everyone in the system, although causally unrelated messages may arrive in arbitrary order.

Our work is more closely related to those that have grown out of the spatial logics community, and moved into the area of runtime verification. In Nenzi et al. (2018), Signal Temporal Logic (STL) for real-valued signals takes inspiration from SLCS and is extended with the spatial modalities somewhere and bounded surround into Spatio-STL (SSTL). A monitoring algorithm is presented and its implementation evaluated, though, in contrast to our work, the topology of the system is considered fixed. This is addressed by Bartocci et al. (2017) with the Spatio-Temporal Reach and Escape Logic (STREL), which in turn extends the above SSTL logic with two further modalities, reach and escape, which are designed as local properties, only taking into account neighbours. A monitoring algorithm is presented. To the best of our knowledge, no distributed algorithm has been presented yet to monitor distributed properties in large-scale dynamic networks.

5.2. Runtime verification of self-adaptive systems
Techniques for runtime verification have also been investigated in the context of self-adaptive systems, where the related problem of monitoring is particularly crucial to drive proper adaptation. In Borda et al. (2018), specifications expressed in a higher-order process language for adaptive CPSs are translated to FDR (Failures-Divergences Refinement) to refinement-check requirement satisfaction. Another approach, Lotus@Runtime (Barbosa et al., 2017) addresses verification of self-adaptive systems, modelled as (probabilistic) labelled transition systems, by checking reachability properties on execution traces—which must be generated, e.g., through instrumentation or aspect-oriented techniques. In Tahara et al. (2017), CAMPer is proposed, a property verifier for Component Aspect Models (CAM) UML profile that uses Maude for expressing behaviours and verifying dynamic evolution processes; however, unlike our approach, this is not applied to large-scale scenarios, and does not deal with decentralised control. Calinescu et al. (2017) provide a survey of quantitative model checking approaches for the (re-)verification of QoS properties after system, environment, or requirements change. Our field-based approach to coordination, in particular, naturally addresses the challenges of “continual re-assessment” which are stressed in the above work. Moreover, our approach captures properties to be verified as executable specifications, and the decentralised, self-healing monitor is directly “implied” from these, since their continuous, distributed interpretation yields the needed computation and communication activities for their local evaluation.

5.3. Ensembles of devices and aggregate computing
Several foundational calculi for describing interaction of devices in distributed systems have been proposed, mostly rooted on the archetype process algebra for mobility, the -calculus (Milner et al., 1992a, Milner et al., 1992b). Approaches like ambient calculus (Cardelli and Gordon, 2000), Bigraphs (Milner, 2006),  (Cardelli and Gardner, 2010), SCEL (De Nicola et al., 2013), and many others, provide mathematically concise foundations for capturing the interaction of groups in complex environments, featuring a shared-space abstraction by which multiple processes can interact in a decoupled way. However, they do not feature mechanisms for capturing the overall behaviour of an ensemble by abstracting over the single devices as with the field calculus, and for making such a behaviour compositional as required by the formulation of spatial properties. This makes them quite low level for the purpose of expressing distribute monitors automatically generated from SLCS specifications.

The problem of finding suitable programming models for ensemble of devices has been the subject of intensive research—see e.g. the surveys (Beal et al., 2013, Viroli et al., 2019): works as TOTA (Mamei and Zambonelli, 2009) and Hood (Whitehouse et al., 2004) provide abstractions over the single device to facilitate construction of macro-level systems; GPL (Coore, 1999) and others are used to express spatial and geometric patterns; Regiment (Newton and Welsh, 2004) and TinyLime (Curino et al., 2005) are information systems used to stream and summarise information over space–time regions; while MGS (Giavitto et al., 2004) and the fixpoint approach in Lluch-Lafuente et al. (2017) provide general purpose space–time computing models.

Aggregate computing and the field calculus have then be developed as a generalisation of the above approaches, with the goal of defining a programming model with sufficient expressiveness to describe complex distributed processes by a functional-oriented compositional model, whose semantics is defined in terms of gossip-like computational processes. Recent works have also adopted this field calculus as a lingua franca to investigate formal properties of resiliency to environment changes (Audrito et al., 2018c, Nishiwaki, 2016, Viroli et al., 2018), and to device distribution (Beal et al., 2017).

6. Conclusion and future work
In this paper we provided a natural translation of properties expressed in SLCS logic, a spatial logics with topological modal operators, into distributed programs for monitoring such properties. Such programs define a repetitive task to be executed by local monitors hosted in each device of the network, resulting in a coordinated behaviour that altogether computes local validity of the SLCS formula, and self-adapt optimally after changes in network topology or of truth values of the atomic propositions in the formula. This adaptation process is modelled through self-stabilisation and proved correct in Theorem 3. Additionally, local monitors run using local memory, message size and computation time that are all linear in the size of the formula (c.f.  Theorem 2). Critical to achieve these results is the usage of aggregate computing (Beal et al., 2015) and the field calculus model (Audrito et al., 2019), which provided: (i) a functional programming model easily expressing the translation in a syntax-directed way, (ii) operators and libraries to easily capture the ability to monitor SLCS spatial operators, (iii) a programming language (Protelis, Pianini et al., 2015) and simulator (Alchemist, Pianini et al., 2013) to perform empirical evaluation in realistic scenarios, and finally (iv) a characterisation of self-stabilising field calculus programs as of Viroli et al. (2018), by which we could state resiliency of the runtime verification process. In particular, we also evaluated the approach in a large-scale crowd safety scenario, and showed that, even in environments characterised by nearly continuous and possibly disruptive change, essentially undermining the self-stabilisation requirements, the decentralised monitor still nicely approximates an oracle monitor.

Future works will be mainly devoted to capture more powerful monitoring processes, by considering more expressive spatial logics, as well as logics addressing spatio-temporal aspects. Additionally, we will seek for platform support for field calculus programs, encompassing the opportunistic usage of cloud as well as edge resources, along the line of Viroli et al. (2016).