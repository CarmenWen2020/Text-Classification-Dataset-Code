Abstract
Test suite minimization problem has been mainly addressed by employing heuristic techniques or integer linear programming focusing on a specific criterion or bi-criteria. These approaches fall short to compute optimal solutions especially when there exists overlap among test cases in terms of various criteria such as code coverage and the set of detected faults. Nonlinear formulations have also been proposed recently to address such cases. However, these formulations require significantly more computational resources compared to linear ones. Moreover, they are also subject to shortcomings that might still lead to sub-optimal solutions. In this paper, we identify such shortcomings and we propose an alternative formulation of the problem. We have empirically evaluated the effectiveness of our approach based on a publicly available dataset and compared it with respect to the state-of-the-art based on the same objective function and the same set of criteria including statement coverage, fault-revealing capability, and test execution time. Results show that our formulation leads to either better results or the same results, when the previously obtained results were already the optimal ones. In addition, our formulation is a linear formulation, which can be solved much more efficiently compared to non-linear formulations.

Previous
Next 
Keywords
Software testing

Regression testing

Test suite minimization

Integer programming

Multi-objective optimization

1. Introduction
Software systems evolve. They have to be maintained over time and usually extended with new features. Regression testing is performed to ensure that maintenance activities and extensions do not introduce bugs or side effects (Yoo and Harman, 2012).

The size of test suites used for regression testing tends to increase over time. It becomes too costly, if not infeasible, to execute the whole test suite for large-scale systems. The testing process might involve millions of test executions (Herzig et al., 2015) and take multiple weeks to complete. For example, it was previously reported (Rothermel et al., 2001) that the entire test suite of an actual product requires 7 weeks to run, although the product comprises around 20,000 lines of code. Test case selection, test case prioritization and test suite minimization approaches have been proposed to address this problem (Yoo and Harman, 2012).

In this paper, we target at test suite minimization, which strives for finding and eliminating redundant test cases to reduce the total number of tests (Yoo and Harman, 2012). Hereby, the problem is to find the minimal subset of the test suite, which satisfies some criteria. Optimization with respect to a single criterion can lead to a test suite that severely compromises its effectiveness in terms of other criteria (Rothermel et al., 1998). Therefore, we focus on, namely, the multi-criteria test suite minimization (MCTSM) problem (Lin et al., 2018) that requires the consideration of multiple criteria such as code coverage, fault detection capability and cost.

The MCTSM problem has been mainly addressed by employing heuristic techniques (Jeffrey and Gupta, 2007, Lin and Huang, 2009) or integer linear programming (Hsu and Orso, 2009, Black et al., 2004, Hao et al., 2012, Li et al., 2014, Jabbarvand et al., 2016, Nardo et al., 2015, Miranda and Bertolino, 2017). These approaches fall short to compute optimal solutions especially when there are dependencies among test cases in terms of various criteria. For instance, simply maximizing the number of detected faults would not necessarily lead to an efficient test suite if the same fault could be detected by multiple test cases. It must be ensured that test cases cover a diverse set of faults. A nonlinear formulation was recently proposed (Lin et al., 2018) based on this observation. Although this formulation significantly improves the results with respect to prior work, we argue that it is still subject to shortcomings. We demonstrate both analytically on small instances and empirically on large test instances that it may fail to identify the optimal solution. We propose an alternative formulation of the problem that addresses the identified shortcomings. Besides, our formulation is a linear formulation, which does not require a linear transformation and it can be solved much more efficiently compared to non-linear formulations.

We empirically evaluated the effectiveness of our approach based on a publicly available dataset (Lin et al., 2018). This dataset was previously created based on 5 open-source projects (Henard et al., 2016) and it was used for evaluating solution approaches for the MCTSM problem. We used the same dataset and the same experimental setup to compare our approach with respect to previous studies. That is, we used the same objective function and the same set of criteria including statement coverage, fault-revealing capability, and test execution time. Results show that our formulation leads to either better results or the same results, when the previously obtained results were already the optimal ones. In addition, it leverages better time efficiency as expected.

The contributions of this paper are threefold: (i) we identify deficiencies in state-of-the-art MCTSM problem formulations, (ii) we propose a novel formulation for optimally solving this problem, and (iii) we present an empirical study in which the proposed approach is compared with previous studies based on a publicly available dataset obtained from a set of open-source projects.

The remainder of this paper is organized as follows. In the next section, we briefly explain the MCTSM problem, previously proposed formulations for the problem and their deficiencies. We introduce our formulation for the problem in Section 3. We present an empirical evaluation of our approach and a comparison with other approaches in Section 4. We summarize related studies in Section 5. Finally, we provide our concluding remarks and future research directions in Section 6.

2. Multi-criteria test-suite minimization
There exist 3 basic approaches for increasing the effectiveness of the regression testing process (Yoo and Harman, 2012): (i) test suite minimization, (ii) test case selection, and (iii) test case prioritization. Test case prioritization aims at finding an optimal execution order of the test cases in a test suite according to an objective such as detecting faults as early as possible. Test case selection is performed to select a subset of test cases within a test suite that are associated with the changed parts of the software. The goal of test suite minimization is to identify and then eliminate obsolete or redundant test cases from the test suite. Hence, a subset of the test cases are (de)selected as well. However, test suite minimization can be considered as a more general approach in the sense that the selection criterion is not fixed such as focusing on changed parts of the system only. It is also sometimes called as “test suite reduction” (Rothermel et al., 2002, Zhang et al., 2011, Shi et al., 2014, Shi et al., 2018) to essentially refer to the same type of approach (Yoo and Harman, 2012).

MCTSM is a variant of the test suite minimization problem, where multiple criteria can be considered for selecting and eliminating test cases. It is a multi-objective optimization problem, which can be formalized as follows by adopting the weighted-sums approach (Steuer, 1986).

Given:

•
A test suite 

•
A set of constraint criteria 

•
A set of optimization criteria 

•
A set of weights of importance associated with the optimization criteria 

Problem: Find a test suite  such that

•
 satisfies C

•
 that satisfies C, 

Hereby, each function  provides an evaluation of a given test suite with respect to the optimization criteria . One obvious criterion, by definition, would be to minimize the test suite size. However, there can be others considering, for instance, code coverage and cost. Various combinations of such criteria and constraints lead to an open-ended number of instances of MCTSM. In this paper, we propose a generic approach to formulate this problem. Then, we adapt our formulation and evaluate our approach based on 3 instances (Section 4), which were previously used for evaluating MCTSM approaches (Lin et al., 2018). They are described in the following.

Classic bi-criteria (CB).
This problem has two objectives with equal weights: (i) minimize the number of test cases, and (ii) maximize the fault-detection ability. As a constraint, the statement coverage of the reduced test suite must be equal to the statement coverage of the original test suite.

Variant bi-criteria (VB).
This problem employs the same set of objectives and the same constraint as CB. In addition, it incorporates an additional constraint based on the observation that some segments of code are more important than others, and as such, they need to be covered multiple times (Jin and Orso, 2012, Jabbarvand et al., 2016). Hereby, importance of a statement is assumed to be proportional to the number of times it is executed by the original test suite. For instance, an additional constraint is specified for each of the top 10% mostly executed statements, where the statement must be executed at least 10% of the number of times it is executed by the original test suite.

Tri-criteria (TC).
This problem has two objectives with equal weights: (i) maximize statement coverage, and (ii) maximize the fault-detection ability. As a constraint, the total test cost must be less than a given budget. The amount of cost for each test case is provided as input, which might be specified in terms of execution time (Walcott et al., 2006, Zhang et al., 2009). The budget limit is specified as a percentage of the total cost for the original test suite.

In general, MCTSM problem is NP-complete, as it can be reduced from the minimum set-covering problem in polynomial time (Garey and Johnson, 1979). In the following subsections, we introduce previously proposed integer programming formulations of the MCTSM problem. We also introduce adversary examples to demonstrate how these formulations can lead to sub-optimal results. Then, we explain our formulation in the next section.

2.1. Linear formulation
State-of-the-art linear modeling of MCTSM (Black et al., 2004, Hsu and Orso, 2009) adopt a binary integer linear programming formulation of the problem. Hereby, a binary decision variable,  is associated with each test case,  within the test suite, .  takes the value 1 if  is selected as part of the reduced test suite, , and 0 otherwise. In the following, we present a motivating example adopted from Lin et al. (2018) to illustrate this approach and its shortcomings.

Table 1 lists the statement and fault coverage regarding 3 test cases, . There are 3 statements () and 4 faults (). In the first part of the table, we see that the first statement,  is executed by  and . The second statement,  is executed only by , while  is executed by both  and . In the second part of the table, we see that the first 3 faults are detected by  and , whereas the last fault,  can be detected only by . In this example, there exist only one constraint criterion, , to maintain the same statement coverage as the original test suite. There is also a single optimization criterion, , to maximize the fault detection effectiveness.


Table 1. First adversary example (adopted from Lin et al. (2018)).

Coverage	Test cases
1	0	1
0	1	0
0	1	1
0	1	1
0	1	1
0	1	1
1	0	0
The constraint criterion  is formulated as follows: (1)

Hereby,  represents the number of statements and  is a binary variable that takes the value 1 if the statement  is executed by the test case , and 0 otherwise. Each decision variable,  is associated with the (de)selection of the corresponding test case . The interpretation of Eq. (1) for the example case listed in Table 1 leads to the following concrete constraints: 

The optimization criterion  is formulated as follows: (2)

This linear objective function tries to minimize the size of the reduced test suite. The function  evaluates the fault detection incapability of a given test case. The more faults detected by a test case , the smaller the value gets returned by . Hence, this function is formulated as follows: (3)

Hereby,  represents the number of faults and  is a binary variable that takes the value 1 if the fault  is detected by the test case , and 0 otherwise. The objective function for the example given in Table 1 turns out to be the following: 

The optimal solution for this formulation turns out to be  with  as the value of the objective function. However, this is actually not the optimal solution for the problem. We can see in Table 1 that test cases  and  both detect ,  and , while they miss . The optimal solution for this example case is . These two test cases cover all the statements and detect all the faults although the objective function evaluates to . This linear formulation tends to select test cases that detect more number of faults in total; however, it does not maximize the number of distinct faults detected. Although  detects  only, it should have been selected together with  since  can only be detected with  and all the other faults can be detected by  anyhow.

The linear formulation discussed in this subsection can be provided to a linear solver. We refer to this solution approach (Hsu and Orso, 2009) as  (Linear Formulation–Linear Solver) in the rest of this paper. In the following, we explain the state-of-the-art nonlinear formulation approach.

2.2. Nonlinear formulation
The recently proposed nonlinear formulation (Lin et al., 2018) takes test case dependencies into account. That is, faults detected by multiple test cases are also considered to maximize the number of distinct faults detected. In the following, we illustrate an instance of this formulation for the example case provided in the previous subsection, where there is a single constraint criterion () to maintain the same statement coverage as the original test suite, and there is a single objective () to maximize the fault detection effectiveness. As a result, the overall objective function turns out to be the same as Eq. (2), except the evaluation function (), which makes the formulation nonlinear. The refined function is defined as follows. (4)

The evaluation function for the linear formulation was defined in Eq. (3). The only difference between Eq. (3) and Eq. (4) is the multiplying factor, , which is defined as follows. (5)

Eq. (5) iterates over all the test cases () that detects  (i.e., ), except . If at least one of these test cases is selected,  becomes , which makes the whole equation evaluate to . Hence, it becomes not favorable to select  since it detects a fault that is already detected by some other selected test case.

The objective function for the example given in Table 1 turns out to be the following: (6)

The first test case detects only one fault,  that is not detected by any other test case. On the other hand, the second and third test cases both detect ,  and . Hence, Eq. (6) can be expanded as follows. 

The set of constraints remains the same as defined in Eq. (1). The optimal solution for this formulation turns out to be  with  as the value of the objective function. This is indeed the optimal solution for the example case. The solution selected by the linear formulation () leads to value  for the revised objective function.

Two alternatives were proposed for solving this nonlinear formulation (Lin et al., 2018). The first alternative is to use a nonlinear solver. This approach is referred as  (Nonlinear Formulation–Nonlinear Solver). The second alternative is to transform this formulation to linear programming and then use a linear solver. We do not explain the employed transformation process and refer the reader to the corresponding publication (Lin et al., 2018) for details. This second approach is referred as  (Nonlinear Formulation–Linear Solver).

Although the proposed nonlinear formulation takes test case dependencies into account, it can still lead to sub-optimal solutions as illustrated in the following.

We introduce a second adversary example, where the set of criteria and constraints are the same as those used in the first example. That is, there exist only one constraint criterion, , to maintain the same statement coverage as the original test suite. There is also a single optimization criterion, , to maximize the fault detection effectiveness. Table 2 lists the statement and fault coverage regarding 3 test cases, . There are 3 statements and 4 faults. In the first part of the table, we see that the first statement,  is executed only by . The second statement,  is executed only by , while  is executed by all. In the second part of the table, we see that the first fault is detected by  and , second only by , third only by , and finally fourth only by .

Hence, Eq. (6) for this example can be expanded as follows. 


Table 2. Second adversary example.

Coverage	Test cases
1	0	0
0	1	0
1	1	1
1	1	0
0	0	1
0	1	0
0	0	1
The statement coverage constraint requires the selection of  and  as  is covered only by  and  is covered only by . On the other hand,  may not be selected at all as it only covers  which is already covered by the first and second test already. The optimal solution for this formulation turns out to be , where the above equation yields to  as the minimum value. However, with the single optimization criterion of maximizing the fault detection effectiveness, the optimal solution to this example should have been selecting all the tests as the last test detects two faults,  and  namely, which cannot be detected by the other tests.

We would stuck at a sub-optimal solution in this example even if we adopted CB, where the goal is to minimize the number of test cases as well as maximize the fault-detection ability. Hereby, the last test should still be selected as it covers two faults while increasing the number of test cases selected by one. Hence, we prove that nonlinear formulation may not yield the optimal solution for certain instances of the problem.

Note that the existing linear formulation,  would also select  and  in this example case, for which the objective function can be expanded as follows. 
 
 
 

Hereby,  and  must be equal to 1 since the first two test cases must be selected to be able to cover all the statements. The last decision variable,  will be set to 0 to be able to minimize the objective function value.

Next, we present a third adversary example (Table 3), where the nonlinear formulation fails to identify the optimal solution. In this example, there exists a test,  that covers all the statements but does not detect any fault at all. The other three tests cover one statement and detect two distinct faults each.

Hence, Eq. (6) for this example can be expanded as follows.  
 


Table 3. Third adversary example.

Coverage	Test cases
1	1	0	0
1	0	1	0
1	0	0	1
0	1	0	0
0	1	0	0
0	0	1	0
0	0	1	0
0	0	0	1
0	0	0	1
The statement coverage constraint requires either  or  as feasible solutions. The objective function value for these solutions are  and 
 
, respectively. Thus, the optimal solution turns out to be  since we are trying to minimize the objective function value. However, with the single optimization criterion of maximizing the fault detection effectiveness, the optimal solution to this example should have been selecting all the tests but the first one as the last three tests detect two faults each whereas the first test detects none. Even for the CB problem variant, the last three tests should still be selected as each test covers two faults while increasing the number of test cases selected by one. Hence, we prove that nonlinear formulation does not yield the optimal solution for such instances as well.

Note that the existing linear formulation,  would also select only  in this example case, for which the objective function can be expanded as follows. 
 
 
 

The values of this function becomes equal to 1 when  is set to 1 and all the other decision variables are set to 0. The value becomes equal to 2 when  is set to 0 and all the other decision variables are set to 1. Hence, the resulting test suite would be  as the solution with the minimum value.

In the following, we introduce our approach and then later compare it with respect to all the previously proposed alternatives, namely , , and .

3. A novel formulation of the problem
We propose a novel formulation for the MCTSM problem. First of all, our formulation is a linear formulation. Hence, it does not require a linear transformation and it can be solved much more efficiently compared to nonlinear formulations. Second, our formulation can easily handle the adversary cases discussed above for nonlinear formulation and identify the best solution in those cases. In fact, provided that we can find a solution using our formulation,1 we obtain “the optimal” solution for the problem in consideration. Thus, any other algorithm cannot find a better solution. The same statement does not hold for the nonlinear formulation discussed in the previous section. We demonstrated both analytically on small instances and empirically on large test instances (See Section 4) that it may fail to identify the optimal solution. Finally, our model determines the optimal solution in the order of seconds for even larger problems with 58,344 lines of code and 746 tests, while running on a laptop computer (Section 4). Even though the problem itself is NP-Hard, our solution method is computationally efficient, beating the state-of-the-art (Lin et al., 2018) in terms of time efficiency as well.

In our mathematical formulation, instead of devising a “good” objective function that handles all the criteria imposed to the problem, we use a “penalty-based approach” and account for certain issues such as not detecting a fault or not covering a statement in specialized constraints with certain binary indicator variables and penalize those cases in the objective function accordingly by using the corresponding indicator variables. Once again, the resulting model is a binary linear model as opposed to a nonlinear model, which is easier to handle by definition.

We present 3 variants of our formulation, ,  and  for MCTSM problem variants CB, VB and TC, respectively. In the following, we introduce the notation used in these formulations, followed by the definition of .  
 
 
 

(7)(8)(9)(10)(11)

The objective is to minimize the sum of the number of test cases performed and the number of faults that cannot be detected by the selected tests. Note that minimizing the number of faults that cannot be detected by the reduced test suite is equivalent to maximizing the number of faults detected by the test suite as the total number of faults is constant. Constraints (8) ensure that the reduced test suite covers all the statements covered by the original test suite. Constraints (9) guarantee that a fault is either detected by the tests in the reduced test suite determined by the model or an indicator binary variable is equal to 1 showing that fault is not detected by the reduced test suite. If the latter is the case, it is accordingly penalized in the objective function. Finally, constraints (10) and constraints (11) are the binary restrictions for the decision variables. The optimal solution to  yields the best solution for CB.

The proposed model is also quite versatile in the sense that (i) it can handle different objective functions (i.e., unequal weights of the two criteria corresponds to merely multiplying each summation statement in the objective function value with the desired weights), (ii) it can easily incorporate additional constraints imposed to the problem (i.e., limiting the number of faults undetected, limiting the number of tests selected, etc.). These additional limitations does not complicate the solution process. In fact, they might even improve the solution time of our proposed method.

Next, we would like demonstrate how our model handles the last two adversary examples discussed before. For the second adversary example (Table 2), we have the following formulation (excluding the binary restrictions). (12)(13)(14)(15)(16)(17)(18)(19)

Due to first two constraints, the first two tests should be selected, , and after eliminating the redundant constraints the formulation reduces to: (20)(21)(22)

Hence, in order to satisfy the remaining two constraints either  or , while the former increases the objective function value by one whereas the latter increases by two. As the problem is a minimization problem, the model selects , finding the optimal solution for the CB problem.

For the last adversary example (Table 3), we have the following formulation (excluding the binary restrictions). (23)(24)(25)(26)(27)(28)(29)(30)(31)(32)

Hence, due to the last six constraints, we should have either  or , either  or , and either  or . As the objective function value coefficients are the same, we would have  and  rather than the other way around. As the problem is a minimization problem, the model selects  as the first three constraints are already satisfied with , finding the optimal solution for the CB problem.

For the second MCTSM variant, VB, we propose another mathematical model, . Before presenting the formulation of , we introduce additional notation used in this formulation.  
  (33)(34)(35)(36)(37)(38)

The additional constraints, constraints (36), ensure that each of the top 10% mostly executed statements is executed by the reduced test suite at least 10% of the number of times it is executed by the original test suite. The optimal solution to  yields the best solution for the VB problem. As in ,  can also be easily modified to handle additional criteria and restrictions.

Finally, we propose, , for the last MCTSM variant, TC. Before presenting the formulation of , we again introduce additional notation used in this formulation.  
 
 

(39)(40)(41)(42)(43)(44)(45)

The objective is now to minimize the sum of the number of statements that cannot be covered and the number of faults that cannot be detected by the selected tests. Constraints (40) ensure that either a statement is covered by the reduced test suite or an indicator binary variable,  is equal to 1 showing that that particular statement is not covered by the reduced test suite. If the latter is the case, it is accordingly penalized in the objective function. Constraints (41) guarantee that a fault is either detected by the tests in the reduced test suite determined by the model or an indicator binary variable is equal to 1 showing that that fault is not detected by the reduced test suite. Again, if the latter is the case, it is accordingly penalized in the objective function. Constraints (42) ensure that the available budget is not exceeded. Finally, constraints (43), (44), and (45) are the binary restrictions for the decision variables. The optimal solution to  yields the best solution for the TC problem.

In the previous section, we introduced adversary cases to prove that existing approaches do not always lead to optimal solutions. In this section, we showed that our approach can find the optimal solution for these cases. However, one might question how prevalent these artificial cases are in reality. In the following section, we perform an empirical evaluation with a benchmark dataset collected from real systems. We show that our approach is able to find better (indeed optimal) solutions with respect to the ones obtained with existing approaches. Therefore, such cases should have been taking place in the dataset as well.

4. Empirical evaluation
In this section, we provide an empirical evaluation of our approach. In particular, we compare the effectiveness and time efficiency of our formulation (,  and ) with respect to previously proposed formulations of the MCTSM problem, namely  (Section 2.1),  and  (Section 2.2). Hence, we investigate the following research questions:

RQ1: How do ,  and  compare against ,  and  with respect to effectiveness of the test suite?

RQ2: How do ,  and  compare against ,  and  with respect to time efficiency?

The metric we used for answering RQ2 is basically the execution time. We measured the time it takes for each approach to find a solution. The smaller the metric value, the better.

We used two metrics for answering RQ1. The first metric is for evaluating the solutions for  and  problems. Hereby, the goal is to minimize both the number of tests and the number of missed faults. These goals have equal priorities. Therefore, the metric is the sum of the number of tests and the number of missed faults. The objective function is to minimize this metric value.  adopts the same objective function as  and introduces a new constraint: each of the top 10% mostly executed statements must be executed at least 10% of the times it is executed by the original test suite. However, the overall goal is still to minimize the sum of the number of tests and the number of missed faults.

The second metric used for answering RQ1 is regarding the evaluation of solutions for the  problem. The  problem aims at maximizing the coverage of statements and the number of detected faults. These goals have equal priorities as well. Therefore, the metric is the sum of the number of executed statements and the number of detected faults. The objective function is to maximize this metric value. Variants of this problem adopt various budget constraints (i.e., the number of test cases that can be selected); however, they all keep the same objective function.

In the following we give details of our experimental setup towards answering our research questions.


Table 4. Subject programs used for evaluation (Lin et al., 2018).

Program	Version	LOC	# of tests	# of faults
Grep	2.7	58,344	746	54
Flex	2.5.4	12,366	605	37
Sed	4.2	26,466	324	25
Make	3.80	23,400	158	15
Gzip	1.3	5,682	397	56
4.1. Experimental setup
We have used an existing, publicly available dataset2 that was previously created based on 5 open-source projects (Henard et al., 2016). These projects constitute our subject programs as listed in Table 4.

The dataset includes test suites as well as the cost, covered statements and the detected faults for each test within these test suites. These were used for evaluating and comparing solution approaches for the MCTSM problem (Lin et al., 2018). We have used the same dataset for a fair comparison with respect to the previously proposed approaches.

A sample faulty code snippet in one of the subject systems, Sed, can be seen in Listing 1. Sed stands for stream editor and it can perform many operations on a text file such as searching, replacing, insertion and deletion. Listing 1 shows parts of the function that matches a given address to line(s). This address can be specified simply as the number of the line or a regular expression. One can also specify a range of lines, possibly including only some of the lines within this range based on a step pattern. So, test inputs for this function include numbers, regular expressions (e.g., “[ t]*$” matches all the lines ending with whitespace) and combinations of number ranges with optional step sizes (e.g., “1  3” matches lines 1, 4, 7, etc.). The faulty line in this code snippet is Line 12 and the correct version is commented above it.


Download : Download high-res image (185KB)
Download : Download full-size image
We used CPLEX (Anon, 2019) as the solver. We used this solver on NEOS (Czyzyk et al., 1998), which is a free Web service for solving numerical optimization problems. We used the NEOS server to perform a fair performance comparison among the alternative formulations. The same server was utilized by the previous evaluations (Lin et al., 2018) as well.

We used the same set of MCTSM problem variants that was used for previous evaluations. These are CB, VC and TC as described in Section 2. The additional constraint for the VC problem is specified for the top 10% mostly executed statements, where each of them must be executed at least 10% of the number of times it is executed by the original test suite. The budget limit for the TC problem is specified as a percentage of the total cost for the original test suite. The problem is instantiated with values , , , and  used as the budget limit.

4.2. Results and discussion
In the following, we present and discuss results regarding the effectiveness and time efficiency of MCTSM formulations to provide answers for RQ1 and RQ2, respectively.

4.2.1. Effectiveness
Results regarding the CB problem are listed in Table 5. Hereby, the alternative formulations are listed in the first column, where the last one is our formulation. The first row lists the 5 subject systems. The second and the third rows list the total number of test cases and the total number of faults for the corresponding system. These are followed by the number of test cases selected by each of the alternative formulations and the number of faults detected by these test cases.

In Table 5, we see that  could not find the optimal solution for any of the subject programs.  and  could find the optimal set of test cases for Sed and Make. However, this is not the case for the other programs, where only  reached to the optimal solution. The corresponding cells are highlighted in light gray color on the table. Hereby, please recall that the metric we used for quantifying the quality of a solution for the CB problem is the sum of the number of tests and the number of faults missed. This sum should be minimized altogether. For instance,  detects 53 faults in Grep out of 54. So, it misses 1 fault only. The number of test cases is 71. Their sum turns out to be 72. On the other hand,  detects 36 faults out of 54. So, it misses 18 faults. The number of test cases is 59. Their sum turns out to be 77, which is 6.49% worse than the one obtained with .

We can see that  coud not obtain any solution for Grep since the solver (Czyzyk et al., 1998) timed out after 8 hours (Lin et al., 2018). This turns out to be the case for almost all the subject systems except Make for the VB problem. Table 6 lists the results regarding this problem. The organization of this table is the same as Table 5. We observe that  could not find the optimal solution for any of the subject programs for this problem as well.  seems to be successful in finding the optimal solution for Grep, Flex Sed and Make. However, this is not the case for Gzip, where only  reached to the optimal solution.


Table 5. Effectiveness of alternative formulations of the CB problem (# T: number of test cases, # F: number of faults, N/A: the solver timed out).


 and  adopt the same objective function. They both aim at minimizing the number of tests as well as the number of missed faults. However,  finds a solution under an additional constraint: each of the top 10% mostly executed statements must be executed at least 10% of the times it is executed by the original test suite. On the other hand,  is not subject to any constraint regarding the selection of test cases. Therefore, it can achieve the same fault detection effectiveness with less number of test cases.


Table 6. Effectiveness of alternative formulations of the VB problem (# T: number of test cases, # F: number of faults, N/A: the solver timed out).


Results regarding the instances of the TC problem are listed in Table 7. The table is divided into 5 sections. The top section lists the 5 subject systems together the total number of test cases, the total number of statements, and the total number of faults for each. Each of the remaining sections is dedicated to an instance of the problem with a different budget limit, i.e., , , , . The second column lists the alternative formulations for each budget limit.  is not listed here, since it was not possible to obtain a solution due to the size of the model for this problem (Lin et al., 2018). We can see that only  could find the optimal solution for Grep, Flex, Make and Gzip, when the budget limit is .  is again unable to find the optimal solution for any of the subject programs for this instance. The obtained solutions by all the approaches get better as the budget constraint gets relaxed and as such, the number of selected test cases can be increased. Hereby, the quality of solutions is not measured based on solely the number of detected faults but the overall objective function, which is to maximize the number of statements covered as well as the number of faults detected. For instance, tests selected by  with  budget detect 51 faults in Gzip and covers 1356 of its statements. Those tests that are selected by  for the same budget is 56. So, all the faults could be detected even when the budget is . However, the number of covered statements is 1343. So, the detection of 5 more faults is compromised by covering 23 less number of statements. This is not considered as a better solution overall since the fault detection effectiveness and statement coverage have equal weights in the specified objective function.


Table 7. Effectiveness of alternative formulations of the TC problem for various budget limits (# T: number of test cases, # S: number of statements, # F: number of faults, N/A: the solver timed out).


Table 8 lists the amount of improvement achieved by  over the other approaches regarding the solutions found for the TC problem when the budget is . Recall that the metric used for evaluating the objective function is the sum of the number of covered statements and the number of detected faults. Since the number of statements in subject programs are in the order of several thousands, even the detection/coverage of more than a dozen faults/statements is associated with an overall improvement that is less than . Hence, these values do not really reflect the significance of the improvement achieved.

Table 9 lists the objective function values for all the subject systems, all problem instances and all the alternative formulations. The optimum value that is obtained with our formulation is highlighted with light gray color for cases, in which it could not be obtained with any of ,  and . Hence, we empirically show that previous formulations, even nonlinear ones, cannot always find the optimal solution, whereas our formulation can.


Table 8. Amount of improvement achieved by  over the other approaches regarding the solutions found for the TC problem when the budget is  (# S: number of statements, # F: number of faults, N/A: the solver timed out).


Note that the goal of TC is to maximize both the number of statements exercised and the number of faults detected. Minimizing the number of test cases is not a concern in the problem definition. Therefore, we can see in Table 7 that the number of test cases tends to increase as the amount of budget increases. This is the case for all the formulations including ours and this is expected due to the definition of TC. One might find this to be in conflict with the goal of the MCTSM problems in general, i.e., to minimize the test suite. However, we can easily address this concern by extending our approach with an additional optimization step. In this second step, the object function is to minimize the number of test cases. The constraint is to achieve the same number of covered statements and the same number of detected faults as those obtained in the first step via the original  formulation. We also tried this two-step approach. Table 10 lists the results for the TC instance, where the budget limit is . Hereby, the subject programs are listed in the first column. The following four columns list the number of test cases, the number of statements covered, the number of faults detected and the value of the objective function. Hereby, the number of statements, the number of faults and the objective function value are all the same with those obtained by the original  formulation (See Table 7, Table 9). However, the number of test cases are reduced significantly. The sixth column lists the number of test cases obtained with the original formulation (See Table 7). The last column lists the amount of reduction in the number of test cases obtained with the extended approach. Our approach can be extended in similar ways to handle additional criteria.


Table 9. Objective function values obtained with state-of-the-art formalisms and the optimum value obtained with our model (CB and VB problems aim at minimization, whereas instances of the TC problem aim at maximization of the objective function value).


In the following, we share and discuss results regarding the runtime performance of our approach.

4.2.2. Performance
Since our formulation is a linear formulation, it would be expected that its runtime performance is comparable to that of , better than  and significantly better than . We collected execution times from the results reported by NEOS (Czyzyk et al., 1998), when our approach is used for solving the CB, VB and TC problem instances to confirm this expectation. We compared these with respect to those reported for ,  and  (Lin et al., 2018). The measurements of execution time (in seconds) are depicted with a box plot in Fig. 1. Hereby, note that the -axis that represents the execution time is in logarithmic scale. We can see that the execution time for solving the variants of our formulation never exceeded a second. The runtime performance of  is comparable to our formulation as expected. It takes 1 s to find solutions for given problems. However, results discussed in the previous subsection showed that these solutions were sub-optimal for many of the subject programs. On the other hand, the runtime performance is very divergent for  and . For instance,  can find a solution within a few seconds for CB, VB. However, it takes up to several hours for the TC problem.  is the worst among all in terms of time performance. In fact, it fails to find any solution at all (before solver times out) for many of the subject programs. Hence, we conclude that the time efficiency of our approach is better than the state-of-the-art nonlinear formulations and comparable to that of previous linear formulations.

4.3. Threats to validity
Our evaluation is subject to external validity threats (Wohlin et al., 2012) since it is based on a benchmark dataset that comprises similar types of programs. All of these programs are Unix utilities provided by GNU. This dataset was adopted from a prior study, where the state-of-the-art approach was proposed and evaluated. We used this dataset without any changes. As such, we mitigate internal and construct validity threats while comparing our approach with respect to the state-of-the-art in terms of the effectiveness of the resulting test suite. Finally, conclusion validity is mitigated by adopting the same set of constraints, criteria and weights for test suite minimization. First, we showed flaws in existing formulations with small contradictory examples. Then, we showed in our empirical evaluation that our formulation can reach to optimal results for all the subject programs, whereas previous formulations can stuck at sub-optimal results for some of these. We shared both our formulations and the obtained results online3 for reproducibility of our experimental results. We also shared the source code (in C++) of the program that we developed for automatically generating formulations.


Table 10. Results obtained after minimizing the test suite for the instance of the TC problem, where the budget is set as  (# T: number of test cases, # S: number of statements, # F: number of faults).

Programs	# T	# S	# F	Obj. function
value	# T in FTC
solution	Reduction
in # T
grep	72	1695	54	1749	107	33%
flex	48	3143	54	3180	74	35%
sed	12	945	25	970	42	71%
make	16	3803	15	3818	27	41%
gzip	49	1409	56	1465	72	32%
5. Related work
Test suite minimization problem has been known to be an NP-complete problem (Yoo and Harman, 2012). Therefore, there have been many solution proposals in the literature that employ heuristics. Some of these approaches (Harrold et al., 1993, Chen and Lau, 1996, Tallam and Gupta, 2005) focus on single-criterion test suite minimization, where greedy heuristics are adopted to find a minimal subset of a test suite that covers all the requirements. It was shown that optimization with respect to such a single criterion can significantly reduce the fault detection effectiveness of the resulting test suite (Rothermel et al., 1998). Consequently, heuristics-based approaches for addressing the MCTSM problem (Jeffrey and Gupta, 2007, Lin and Huang, 2009) were also proposed, where fault detection effectiveness is incorporated as an additional criterion. There exist many other approaches (Sampath et al., 2013) that employ heuristics, machine learning algorithms and greedy algorithms to address the MCTSM problem with hybrid combinations of various criteria such as statement coverage, branch coverage and execution time. These approaches generate approximate solutions and do not guarantee an optimal solution.

We employ integer programming as the solution approach. A majority of related studies in this area (Yoo and Harman, 2012, Lin et al., 2018) focus on bi-criteria problems. For instance, Black et al. (2004) considers fault detection ability and the coverage of all uses in data flow as the two criteria for constructing an integer linear programming model. Likewise, another model (Hao et al., 2012) focuses on statement coverage and fault detection ability. There are other approaches (Li et al., 2014, Jabbarvand et al., 2016), which consider statement coverage and energy consumption as the optimization criteria. Similarly, many other types of criteria (Sampath et al., 2013) can be considered for the construction of the integer linear programming model. However, these approaches have two drawbacks. First, they do not guarantee an optimal solution for the MCTSM problem as explained in Section 2. Second, they mainly focus on specific bi-criteria and ignore other types of criteria. MINTS (Hsu and Orso, 2009) was proposed as a generic framework, where an arbitrary number of criteria can be accommodated. However, MINTS does not always provide an optimal solution to the MCTSM problem as well. In fact, the LF_LS approach that is compared with respect to ours in Section 4 corresponds to the implementation of MINTS.

Even if the problem is defined based on the same set of concerns, it might be formulated in an open-ended number of ways depending on the definition of constraints, criteria and weights assigned for these criteria. For instance, one can simply aim at minimizing the number of selected tests while covering all the originally covered statements as well as not missing any fault that could be detected by the original test suite (Shi et al., 2014). In this case, there would be only one objective, to minimize the number of tests and two constraints: (i) to keep the same statement coverage and (ii) to keep the same fault detection capability. One can argue that the solution obtained from the solver is optimal for the given problem definition although it might not be optimal for another definition. However, we argue that existing formulations are subject to flaws that prevent them always reaching optimal solutions even for the intended problem definition. We adapt our formulation for 3 previously defined instances of the problem to prove our argument and to make a fair comparison with the state-of-the-art approaches (Lin et al., 2018). We showed that our formulation can reach to better (indeed optimal) results for the same set of constraints, criteria and weights.

To the best of our knowledge, the most recent, state-of-the-art approach for addressing the MCTSM problem is NEMO (Lin et al., 2018). We facilitate automation for generating linear programming formulations like NEMO does. Our program uses the same set of inputs (fault coverage, line coverage and cost information regarding tests) with the same file format. However, formulations generated by NEMO are different from ours. NEMO formulates MCTSM in the form of an integer nonlinear programming problem. Then, it proposes two alternatives to solve this problem. First, the nonlinear formulation can be supplied directly to a nonlinear solver. The NF_NS approach that is compared with respect to ours in Section 4 corresponds to this alternative. Second, the nonlinear formulation can be transformed into a linear one through the use of auxiliary variables. Then, this can be solved using a linear solver. The NF_LS approach that is compared with respect to ours in Section 4 corresponds to this second alternative. However, the nonlinear formulation itself is subject to flaws that might lead to sub-optimal solutions. We showed this with adversary examples (Section 2). The linear formulation that is transformed from the nonlinear formulation embodies the same flaws. This becomes apparent in empirical results (Section 4), where the obtained formulation fails to find optimal solutions for some of the subject systems. Our formulation can find the optimal solutions for these as well as all the others. Furthermore, our formulation is a linear one, which makes it unnecessary to adopt an additional transformation process and auxiliary variables.

In real life, one can obtain information regarding only those faults that were detected in previous versions of the system. There have been studies (Zhang et al., 2011, Shi et al., 2014, Shi et al., 2018) to evaluate the effectiveness of MCTSM approaches based on this fact. Hereby, test cases are selected based on faults that have been detected in the past. Then, the selected test cases are executed on the next version of the system to evaluate their capability in detecting new faults. We used an existing dataset to unequivocally show the superiority of our formulation with respect to existing formulations. In our evaluation, we obtain an optimal solution for a given input regarding the test cost, coverage of statements and detection of faults by the test cases. The actual effectiveness of the solution would depend on how much this input reflects the state of the next version of the system. However, evaluation of this correlation is out-of-scope of this paper.

Code coverage has been the mostly adopted criterion for measuring test effectiveness (Zhang et al., 2019) and therefore commonly used for minimizing test suites. However, there exist other coverage metrics as well. One of these is the recently introduced assertion coverage (Zhang and Mesbah, 2015), which is also known as checked coverage (Schuler and Zeller, 2011). There has been empirical evidence suggesting that assertion coverage has a stronger correlation with mutation score (Zhang and Mesbah, 2015) although it was shown to be the opposite in some other studies (Zhang et al., 2019). A recent test minimization approach (Vahabzadeh et al., 2018) used assertion coverage as the main criterion though it minimizes test suites at the statement level, rather than at the test case level. Our approach is agnostic to the coverage criteria adopted for test suite minimization. It takes as input the list of test cases together with an enumerated list of items covered by each test case. These enumerated items can in principle represent anything including source code statements, faults or assertions.

6. Conclusion and future work
We proposed a novel formulation of the multi-criteria test suite minimization problem based on integer linear programming. We identified shortcomings of the state-of-the-art formulations that might lead to sub-optimal solutions. We demonstrated this with adversary examples and show that our formulation can address the identified shortcomings. We also empirically evaluated the effectiveness of our approach based on a publicly available dataset derived from a set of open-source projects. Results show that our linear formulation leads to better results with respect to the state-of-the-art in terms of the same objective function and the same set of criteria including statement coverage, fault-revealing capability, and test execution time. In addition, it leverages better time performance compared to non-linear formulations, making it more scalable for larger problems.

Formulating the multi-criteria test suite minimization problem as an integer programming problem is effective for reaching the optimal solution. However, this problem is known to be NP-complete and such formulations (even the linear one) do not guarantee to find a solution quickly. This approach might fall short as the problem size grows further. Therefore, a possible future direction would be to extend the evaluation with larger datasets, compare the results with those obtained with heuristics or greedy algorithms, and assess the trade-off between the effectiveness and efficiency of alternative approaches.