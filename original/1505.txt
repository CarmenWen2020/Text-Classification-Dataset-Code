Abstract
Game engines help developers create video games and avoid duplication of code and effort, like frameworks for traditional software systems. In this paper, we explore open-source game engines along three perspectives: literature, code, and human. First, we explore and summarize the academic literature on game engines. Second, we compare the characteristics of the 282 most popular engines and the 282 most popular frameworks in GitHub. Finally, we survey 124 engine developers about their experience with the development of their engines. We report that: (1) Game engines are not well-studied in software-engineering research with few studies having engines as object of research. (2) Open-source game engines are slightly larger in terms of size and complexity and less popular and engaging than traditional frameworks. Their programming languages differ greatly from frameworks. Engine projects have shorter histories with less releases. (3) Developers perceive game engines as different from traditional frameworks. Generally, they build game engines to (a) better control the environment and source code, (b) learn about game engines, and (c) develop specific games. We conclude that open-source game engines have differences compared to traditional open-source frameworks although this differences do not demand special treatments.

Previous
Next 
Keywords
Game-engine

Framework

Video-game

Mining

Open-source

1. Introduction
“It’s hard enough to make a game (...). It’s really hard to make a game where you have to fight your own tool set all the time.”

— Schreier (2019) quoting a game developer on the difficulties faced using their game engine.

For decades, video games have been a joyful hobby for many people around the world (Entertainment Software Association - ESA, 2019), making the game industry multi-billionaire, surpassing the movie and music industries combined (Newzoo, 2019). However, realistic graphics and smooth gameplays hide constant and non-ending problems with game development, mostly related to poor software-development practices and inadequate management (Petrillo et al., 2009). Problems like these result in a scenario where 80% of the top 50 games on Steam1 need critical updates (Lin et al., 2017), also leaving a trail of burnout developers after long periods of “crunchs”2  Edholm et al. (2017).

During game development, developers use specialized software infrastructures to develop their games; chief among which are game engines. Game engines encompass a myriad of resources and tools (Gregory, 2014, Thorn, 2011, Hughes, 2010, Sherrod, 2007). They can be built from scratch during game development, reused from previous games, extended from open-source ones, or bought off the shelves. They are essential to game development but misunderstood and misrepresented by the media (Schreier, 2018) and developers due to lacks of clear definitions, architectural Refs. Messaoudi et al. (2016), and academic studies. They are also the source of problems, especially between design and technical teams (Schreier, 2017, Kushner, 2003).

To address these problems, some researchers suggest the use of software-engineering techniques (Petrillo et al., 2009, Petrillo and Pimenta, 2010, Kasurinen et al., 2017) while others consider game development as a special kind of software and propose new engineering practices or extensions to classical ones (Hyrynsalmi et al., 2018, Murphy-Hill et al., 2014, Lewis and Whitehead, 2011, Kanode and Haddad, 2009, Callele et al., 2015, Ramadan and Hendradjaya, 2014, Mozgovoy and Pyshkin, 2018). However, they did not study a large number of game engines, either proprietary, because only 13% of all the games on Steam describe their engines (Toftedahl and Engström, 2019), or open source. They also did not survey game engine developers.

Therefore, we set to comparing open-source video-game engines with traditional open-source software frameworks can help researchers and developers to understand them better. With this article, we want to answer whether game engines share similar characteristics with software frameworks. By comparing the tools (engines and frameworks) rather than their instances (video games, traditional software systems), we provide a distinct view on game development: rather than studying how developers use games engines, we focus on how the foundations of their games are built.

We study open-source game engines from three perspectives: literature, code, and human to provide an global view on the states of the art and practice on game engines. We explore academic and gray literature on game engines; compare the characteristics of the 282 most popular engines and the 282 most popular frameworks in GitHub; and, survey 124 engine developers about their experience with the development of their engines. Thus, we provide four contributions: (1) a corpus of open-source engines for this and future research work; (2) an analysis and discussion of the characteristics of engines; (3) a comparison of these characteristics with those of traditional frameworks; and, (4) a survey of engine developers about their experience with engine development.

We show that, different from what researchers and engine developers think, there are qualitative but no quantitative differences between engines and frameworks. Game engines are slightly larger in terms of size and complexity and less popular and engaging than traditional frameworks. The programming languages of game engines differ greatly from that of traditional frameworks. game engine projects have shorter histories with less releases. Developers perceive game engines as different from traditional frameworks and claim that engines need special treatments. Developers build game engines to better control the environment and source code, to learn about game engines, and to develop specific games. We conclude that open-source game engines have differences compared to traditional open-source frameworks although this differences, related to community, do not demand special treatments.

The paper is structured as follows: Section 2 lists the research questions for all the three perspectives: literature, code, human. Section 3 shows the results of the literature perspective. Section 4 described the study design for the code perspective: metrics, data collection, and analysis. Section 6 discusses our results and threats to their validity. Section 7 concludes.

In addition, the detailed results are in the Appendix Sections. Appendix A shows results related to static analysis of the projects. Appendix B shows the historic analysis of the projects. Appendix C shows the community analysis of the projects. Section 5 describes our survey of engine developers for the human perspective.

2. Research questions
This Section shows the list of research questions and the metrics used to answer them. An overview of the Perspectives, RQs, and Metrics, is in the Appendix Fig. 6. More details about the metrics are into Table 1.

2.1. RQ1: Literature Perspective
Although software frameworks are part of the toolset of most developers nowadays, its concept is often misunderstood, specially with libraries.3 To better understand the differences between frameworks and game engines we explore the literature perspective using Scopus,4 for academic books and the search engines on internet, for articles, technical blogs, and discussion forums. In Section 3 we aim to answer the following research questions.

•
RQ1.1: What is the definition for software framework?

•
RQ1.2: What is the definition for game engine?

•
RQ1.3: What are the works related to game engines?

2.2. RQ2: Code Perspective
With respect to the design and implementation of game engines and traditional frameworks, we study their static, historical, and community characteristics.

RQ2.1: Static Characteristics
To understand the differences of the frameworks and game engines projects from a code perspective, we investigate the static attributes of the projects, like their size, complexity of the functions, programming languages and licenses used. In Section 4.4 (and Appendix A) we aim to answer the following research questions.

•
RQ2.1.1: What is the popularity of the languages in the projects?

–
Metrics: main_language

•
RQ2.1.2: What is the popularity of the licenses in theprojects?

–
Metrics: license

•
RQ2.1.3: What are the project sizes of engines and frameworks?

–
Metrics: main_language_size, total_size,func_per_file_mean

•
RQ2.1.4: What are the function sizes of engines and frameworks?

–
Metrics: n_funcs, nloc_mean, func_per_file_mean

•
RQ2.1.5: What are the function complexities of engines and frameworks?

–
 Metrics: cc_mean

RQ2.2: Historical Characteristics
To explore the historical characteristics of the projects, we compare the life-cycles of game engines and traditional frameworks. We analyze the tags released (versions), projects’ lifespan and commits. In Section 4.5 (and Appendix B) we aim to answer the following research questions.

•
RQ2.2.1: How many versions were released for each project?

–
Metrics: tags_releases_count

•
RQ2.2.2: What is the lifetime of the projects?

–
Metrics: lifespan

•
RQ2.2.3: How frequently do projects receive new contributions?

–
Metrics: commits_count , commits_per_time

•
RQ2.2.4: Are commits made on game engines more effort-prone?

–
Metrics: lines_added , lines_removed , code_churn

RQ2.3: Community Characteristics
To investigate the interactions of the OSS community on the projects, we analyze the popularity of the projects, the number of issues reported in these projects, and the truck-factor measure (Avelino et al., 2016). In Section 4.6 (and Appendix C) we aim to answer the following research questions.

•
RQ2.3.1: How many developers contribute in the project?

–
Metrics: truck_factor

•
RQ2.3.2: How popular are the projects considering their main languages?

–
Metrics: stargazers_count,contributors_count

•
RQ2.3.3: How many issues are reported in each project?

–
Metrics: issues_count, closed_issues_count,closed_issues_rate

2.3. RQ3: Human Perspective
The human perspective pertains to the developers’ perception of game engines and of their differences with traditional frameworks. We conducted an online survey with developers of the game engines to understand why they built such engines and their opinions about the differences (if any) between engines and frameworks.

Question 1 contains a predefined set of answers that we compiled from the literature and from the documentation and “readme” files studied during the manual filtering of the datasets. The respondent could choose one or more answers. We also provided a free-form text area for developers to provide a different answer and–or explain their answers. With Question 2, we want to understand whether game engine developers are also traditional software developers. Finally, Question 3 collected the developers’ point of views regarding the differences (or lack thereof) between the development of engines and frameworks.

•
RQ3.1: What are the reasons developers create open-source game engines?

–
Survey question 1: Why did you create or collaborated with a video-game engine project?

∗
To help me to create a game

∗
To learn how to build an engine

∗
To have the full control of the environment

∗
Because the existent engines do not provide the features I need

∗
Because I wanted to work with this specific programming language

∗
Because the licenses of the existent engines are too expensive

∗
Other [please specify]

•
RQ3.2: Do game engine developers also have expertise with traditional software?

–
Survey question 2: Have you ever written code for a software unrelated to games, like a Web, phone, or desktop app?[Yes or No]

•
RQ3.3: For game engine developers, is it similar to developing a traditional framework?

–
Survey question 3: How similar do you think writing a video-game engine is compared to writing a framework for traditional apps? (Like Django, Rails, or Vue)– [1 (very different) to 5 (very similar)]

3. Results from RQ1: Literature Perspective
We study game engines along the literature perspective by querying both Scopus and the Internet. We report that only few works on game engines exist: mostly books, few academic papers. We did not perform a systematic literature review (SLR) (Kitchenham, 2012) because of the small size of the current academic literature on the topic, as shown in the following.

RQ1.1: What is the definition for software framework?
GitHub uses a set of “topics”5 to classify projects. It defines the topic “framework” as “a reusable set of libraries or classes in software. In an effort to help developers focus their work on higher level tasks, a framework provides a functional solution for lower level elements of coding. While a framework might add more code than is necessary, they also provide a reusable pattern to speed up development.”

Pree (1994) defined frameworks as having frozen and hot spots: code blocks that remain unchanged and others that receive user code to build the product. Larman (2012) observed that frameworks use the Hollywood Principle, “Don’t call us, we’ll call you.”: user code is called by the framework. Taylor (2018) sees a framework as a programmatic bridge between concepts (such as “window” or “image”) and lower-level implementations. Frameworks can map architectural styles into implementation and–or provide a foundation for an architecture.

RQ1.2: What is the definition for game engine?
ID Software6 introduced the concept of video-game engine in 1993 to refer to the technology “behind the game” when they announced the game DOOM (Gregory, 2014, Lowood and Guins, 2016). In fact, they invented the game engine around 1991 and revealed the concept around the DOOM press release early 1993 (Lowood, 2014).

The invention of this game technology was a discrete historical event in the early 1990s but it established MS-DOS 3.3 as a relevant gaming platform, mostly because of the NES-like horizontal scrolling emulation, allowing developers to create games similar to the ones on Nintendo console. It also introduced the separation of game engine from “assets” accessible to players and thereby revealed a new paradigm for game design on the PC platform (Lowood, 2014), allowing players to modify their games and create new experiences. This concept has since evolved into the “fundamental software components of a computer game”, comprising its core functions, e.g., graphics rendering, audio, physics, AI (Lowood and Guins, 2016).

John Carmack,7 and to a less degree John Romero,8 are credited for the creation and adoption of the term game engine. In the early 90 s, they created the first game engine to separate the concerns between the game code and its assets and to work collaboratively on the game as a team (Lowood and Guins, 2016, Kushner, 2003). Also, they “lent” their engines to other game companies to allow other developers to focus only on game design.

In 2002, Lewis and Jacobson (2002) defined game engines as “collection[s] of modules of simulation code that do not directly specify the game’s behavior (game logic) or game’s environment (level data)”. In 2007, Sherrod (2007) defined engines as frameworks comprised of different tools, utilities, and interfaces that hide the low-level details of the implementations of games. Engines are extensible software that can be used as the foundations for many different games without major changes (Gregory, 2014) and are “software frameworks for game development”. They relieve developers so that they can focus on other aspects of game development”.9 In 2019, Toftedahl and Engström (2019) analyzed and divided engines in four complementary types: (a) Core Game Engine, (b) Game Engine, (c) General Purpose Game Engine, and (d) Special Purpose Game Engine.

RQ1.3: What are the works related to game engines?
There are few academic papers on game engines. Most recently and most complete, Toftedahl and Engström (2019) analyzed the engines of games on the Steam and Itch.io platforms to create a taxonomy of game engines. They highlighted the lack of information regarding the engines used in mainstream games with only 13% of all games reporting information about their engines. On Steam, they reported Unreal (25.6%), Unity (13.2%), and Source (4%) as the main engines. On Itch.io, they observed that Unity alone has 47.3% of adoption among independent developers.

Messaoudi et al. (2016) investigated the performance of the Unity engine in depth and reported issues with CPU and GPU consumption and modules related to rendering.

Cowan and Kapralos (2014) in 2014 and 2016 (Cowan and Kapralos, 2017) analyzed the game engines used for the development of serious games. They identified few academic sources about tools used to develop serious games. They showed that “Second Life”10 is the most mentioned game engine for serious games, followed by Unity and Unreal. They considered game engines as parts of larger infrastructures, which they call frameworks and which contain scripting modules, assets, level editors as well as the engines responsible for sound, graphics, physics, and networking. They ranked Unity, Flash, Second Life, Unreal, and XNA as the most used engines.

Neto and Brega (2015) conducted a systematic literature review of game engines in the context of immersive applications for multi-projection systems, aiming at proposing a generic game engine for this purpose.

Wang and Nordmark (2015) assumed that game development is different from traditional software development and investigated how architecture influences the creative process. They reported that the game genre significantly influences the choice of an engine. They also showed that game-engine development is driven by the creative team, which request features to the development team until the game is completed. They observed that adding scripting capability ease game-engine development through testing and prototyping.

Anderson et al. (2008) raised issues and questions regarding game engines, among which the need for a unified language of game development, the identification of software components within games, the definition of clear boundaries between game engines and games, the links between game genres and game engines, the creation of best practices for the development of game engines.


Download : Download high-res image (82KB)
Download : Download full-size image
4. Results from RQ2: Code Perspective
This section details the method for gathering the data and the metrics used to answer the set of RQs 2.1, 2.2, and 2.3. It also introduced the applied statistical techniques. For the sake of clarity, this section does not provide all the details but summarizes the answers to each set of RQs. The Appendices, B, and C present the detailed results of each set of RQs.

4.1. Method
Fig. 1 shows the steps that we followed to mine the data to answer our questions. In Step 1, on August 8, 2019, we gathered the top 1000 projects in GitHub related to the game-engine and framework topics, separately, storing each one in a specific dataset.

In Step 2, we filtered these projects using the following criteria to remove “noise” and improve the quality of our dataset, which is a common approach when dealing with Github repositories (Lima et al., 2014, Avelino et al., 2016) to obtain 458 engines and 743 frameworks:

•
The project must have more than one contributor;

•
The project must have been starred at least twice;

•
The last commit must be at least from 2017;

•
The project cannot be archived.

In Step 3, we manually analyzed the remaining  projects to remove those that are neither game engines nor frameworks according to the definitions in Section 3. We kept 358 game engines and 358 frameworks.

In Step 4, we kept only projects with programming language supported by Lizard: C/C++, C#, GDScript, Golang, Java, JavaScript, Lua, Objective-C, PHP, Python, Ruby, Scala, Swift, TTCN-3. We had now 282 engines and 282 frameworks.

In Step 5, we computed the metrics and stored their values in the datasets, which we describe in details in the following Section 4.2.

In Step 6, we computed the truck-factor of each project, which is the number of contributors that must quit before a project is in serious trouble (Williams and Kessler, 2002, Avelino et al., 2016).

In Step 7, we used Lizard to gather the average value of the metrics related to functions. Lastly, we ordered the projects by popularity: how many “stars” they have.

Fig. 2 shows an example containing the Github page of the engine Godot.11 We only consider the main language of the projects but most projects are composed of multiple languages. Almost all the code of Godot is written in C++ (93%). Godot is tagged with the “game-engine” topic and, therefore, was found through our search. Godot is the most popular engine containing more than 26k votes.

The dataset, scripts and all the material from this study are in its replication package.12


Download : Download high-res image (353KB)
Download : Download full-size image
Fig. 2. Godot engine Github page example. In this case we considered C++ as main language (A) and filtered the projects with least one commit from 2017 or newer (B) and with more than two contributors (D). Tags, provided by the developers, were used to search for the engines (C). Finally, we ordered the projects by the stars (E).

4.2. Metrics
Defining metrics is challenging. Some authors warn about problems with simplistic measurements (Kaner et al., 2004) and lack of precision of tools that make the measurements (Lincke et al., 2008). However, imperfect quantification is better than none (DeMarco, 1986).

Kaner et al. (2004) recommends the use of direct metrics13 but also defines a framework to described and justify the metrics. We used a simplified version of this framework with six questions: Purpose (What is the purpose of this metric?), Scope (What is the scope of this metric?), Scale (What is the natural scale of the attribute we are trying to metric?), Domain (What is the domain this metric belongs to?), and Instrument (How the metric will be measured?).

Therefore, to answer the questions RQ2.1: Static Characteristics, RQ2.2: Historical Characteristics, and RQ2.3: Community Characteristics, we use the set of metrics described in Table 1. Also, the following list some details about some of the metrics.


Table 1. Description of the Metrics for the Code Perspective (Rqs 2, 3, and 4). We adapted the framework defined by Kaner et al. (2004).

RQs	Purpose	Scope	Metric	Scale	Domain	Instrument
RQ2.1.1	Verify what is the most common main languages by the projects	Project	main_language	Nominal	Programming languages	API GraphQL (V4)
RQ2.1.2	Verify what is the most common licenses used by the projects	Project	license	Nominal	Source code licenses	API GraphQL (V4)
RQ2.1.3	Verify the project size	Project	main_language_size	Ratio	Positive rational numbers (Q)	API GraphQL (V4)
total_size	Ratio	Positive rational numbers (Q)
n_file	Ratio	Natural numbers (N)
RQ2.1.4	Verify the function size	Function	n_func	Ratio	Natural numbers (N)	Lizard
nloc_mean	Ratio	Positive rational numbers (Q)
func_per_file_mean	Ratio	Positive rational numbers (Q)
RQ2.1.5	Verify the complexity of the function	Function	cc_mean	Ratio	Natural numbers (N)	Lizard
RQ2.2.1	Verify the release strategy of the project	Project	tags_releases_count	Ratio	Natural numbers (N)	API GraphQL (V4)
RQ2.2.2	Verify the lifetime of the project	Project	lifespan	Ratio	Natural numbers (N)	API GraphQL (V4)
RQ2.2.3	Verify the contributions
to the project	Commits	commits_count	Ratio	Natural numbers (N)	Pydriller
commits_per_time	Ratio	Positive rational numbers (Q)
RQ2.2.4	Very the effort made
in the projects	Commits	lines_added	Ratio	Natural numbers (N)	Pydriller
lines_removed	Ratio	Natural numbers (N)
code_churn	Ratio	Natural numbers (N)
RQ2.3.1	Verify the contribution of the project	Contributors	truck_factor	Ratio	Natural numbers (N)	Library Avelino et. al.
RQ2.3.2	Verify the popularity
of the project	Project	stargazers_count	Ratio	Natural numbers (N)	API GraphQL (V4)
contributors_count	Ratio	Natural numbers (N)
RQ2.3.3	Verify the how developers
deal with issues in the project	Issues	issues_count	Ratio	Natural numbers (N)	API GraphQL (V4)
closed_issues_count	Ratio	Natural numbers (N)
closed_issues_rate	Ratio	Positive rational numbers (Q)
RQ2.1.1. Metric: main_language –
According to Tiobe index, currently, the most common languages are C, Java, Python.14 Also, GitHub uses Linguistic to determine the most common language in the project.15

RQ2.1.2. Metric: license –
MIT, Apache-2.0, and GPL-V3 were the most common open source licenses in 2019.16 GitHub has a “license picker” allowing the user to choose from different open-source licenses.17

RQ2.1.3. Metrics: main_language_size, total_size, n_file –
GitHub recommends repositories with less than 1 GB, and less than 5 GB is strongly recommended. Also with 100MB maximum file size limit.18

RQ2.1.4. Metrics: n_func, nloc_mean, func_per_file_mean –
Lizard19 gives a list of all functions in the project with NLOC (lines of code without comments) and CCN (cyclomatic complexity number). It also gives the list of files and the functions’ name (signatures).

RQ2.1.5. Metrics: cc_mean –
McCabe’s (McCabe, 1976) recommends keeping the complexity of modules below 10.

RQ2.2.1. Metric tags_releases_count :
Within the context of GitHub, a tag is a release of the product.

RQ2.2.2. Metrics commits_count, commits_per_time –
PyDriller is a Python framework to analyze Git repositories.20

RQ2.2.4. Metrics: lines_added, lines_removed, code_churn –
Code churn measures the number the amount of code changes occurred during development of code (Shin et al., 2011). We use the sum of deleted and removed lines.

RQ2.3.1. Metric: truck_factor –
According to Avelino et al. (2016), truck-factor is the number of people on the team that have to be hit by a truck before the project becomes problematic. Therefore, systems with low truck-factor have problems with strong dependency of certain developers. Linux has truck-factor of 57 and Git 12. We used a library defined by Avelino et al. (2016) as instrument.

RQ2.3.2. Metrics: stargazers_count –
“vuejs” is the moststared github opensource software project with more than 169k.21 In 2019, “microsoft/vscode” had the highest number of contributors with 19.1k.22

4.3. Analysis
We used the statistical-analysis workflow-model for empirical software-engineering research (de Oliveira Neto et al., 2019) to test statistically the differences between engines and frameworks. For each continuous variable, we used descriptive statistics in the form of tables with mean, median, min, and max values, together with boxplots. For the boxplots, to better show the distributions, we removed outliers using the standard coefficient of 1.5 (). We observed outliers for all the measures, with medians skewed towards the upper quartile (Q3). To check for normality, we applied the Shapiro test (Wohlin et al., 2012) and checked visually using Q–Q plots. Normality  0.05 means the data is not normally distributed. Finally, given the data distribution, we applied the appropriate statistical tests and computed their effect sizes.

4.4. Results for RQ2.1: Static Characteristics
Table 2 shows the results of Wilcoxon tests. The p-values  indicate that the distributions are not equal and there is a significant difference between engines and frameworks, although this difference is small. The biggest effects are related to source code metrics, i.e., nloc_mean and cc_mean.


Table 2. Statistical tests, RQ2.1: Static Characteristics.

Variable	-value	Estimate	Effect
main_language_size	0.01	0.28	0.189 (small)
total_size	0.01	0.34	0.188 (small)
n_file	0.01	45.00	0.155 (small)
n_func	0.01	769.00	0.211 (small)
nloc_mean	0.01	2.12	0.297 (small)
func_per_file_mean	0.01	3.13	0.208 (small)
cc_mean	0.01	0.53	0.356 (small)
The implementation of game engines and traditional frameworks are different but without statistical significance. Engines are bigger and more complex than frameworks. They use mostly compiled programming languages vs. interpreted ones for frameworks. They both often use the MIT license.

4.5. Results for RQ2.2: Historical Characteristics
Overall, all metrics have similar median values when comparing both groups, except for tags_releases_count. In fact, engines releases way less versions (median is one) than frameworks (median is 32).

Table 3 shows the results of Wilcoxon tests, showing large differences for all historical measures except lines_added, lines_removed, and code_churn. Versioning does not look like a well-followed practice in engine development, with few versions compared to frameworks. Commits are less frequent and less numerous in engines, which are younger and have shorter lifetimes when compared to frameworks.


Table 3. Statistical tests, RQ2.2: Historical Characteristics.

Variable	-value	Estimate	Effect
tags_releases_count	0.01	−24.00	−0.613 (large)
lifespan	0.01	−56.29	−0.32 (large)
commits_count	0.01	−175.00	−0.198 (large)
commits_per_time	0.01	−0.30	−0.198 (large)
lines_added	0.01	134.47	0.219 (small)
lines_removed	0.01	48.83	0.168 (small)
cchurn_delta	0.01	153.88	0.224 (small)
cchurn_sum	0.01	222.48	0.212 (small)
4.6. Results for RQ2.3: Community Characteristics
Table 4 shows the results of Wilcoxon tests, indicating a large difference in all measures related to community. The truck-factor shows that the majority of the projects have few contributors. Some uncommon languages, like Go and C#, are popular compared to others in more prevalent projects, e.g., C++ and JavaScript.


Download : Download high-res image (104KB)
Download : Download full-size image

Table 4. Statistical tests, RQ2.3: Community Characteristics.

Variable	-value	Estimate	Effect
stargazers_count	0.01	−358.00	−0.511 (large)
contributors_count	0.01	−9.00	−0.459 (large)
truck_factor	0.01	0.01	−0.138 (large)
issues_count	−139.00	0.01	−0.451 (large)
closed_issues_count	−122.00	0.01	−0.459 (large)
closed_issues_rate	−0.05	0.01	−0.27 (large)
5. Results from RQ3: Human Perspective
We now discuss developers’ own perception of game engines and of their differences with traditional frameworks. We used an online form to contact developers over a period of three days. We sent e-mails to 400 developers of the game engines in our dataset, using the truck-factor of each project: developers who collaborate(d) most to the projects. We received 124 responses, i.e., 31% of the developers. The survey, answers, and scripts for their analyses are in the replication package.12

Question 1: Why did you create or collaborated with a video-game engine project?
Fig. 3 shows the breakdown of the developers’ answers. Having access to the source code, freedom to develop, etc., i.e., control of the environment, is the developers’ major reason for working on a game engine while learning to build an engine is the second reason; explaining why many engines have few developers and commits.

The third reason is to build a game, confirming the lack of clear separation between developers and game designers. It is indeed common for game developers to act also as game designers, specially in independent games, e.g., the single developer of Stardew Valley.23


Download : Download high-res image (166KB)
Download : Download full-size image
Fig. 3. Answers to Question 1: Why did you create or collaborated with a video-game engine project?.

The next answer is about working with a specific language, also related with learning: when learning a new language, developers want to apply or test their knowledge on some projects, and game engines are interesting candidates.

Also related to the environment, the next answer concerns the features offered by existing engines: reusing or creating a new engine may be necessary for certain, particular games with specific requirements. Developers think as game designers: the game concept(s) may require a new engine.

The engine licenses are the least concern: fees and taxes from vendors, e.g., Unreal and Unity, are not important to developers because some licenses are “indie” friendly and offer low rates for indie games (Toftedahl and Engström, 2019).

Finally, 19 developers provided “Other” answers: they work on game engines because “it is fun” and–or they have access to some source code, e.g., one developer who reverse-engineered a proprietary engine wrote:

“The source for the original engine was proprietary and so we opened the platform by reverse-engineering it then re-implementing under GPL3.”

Other answers include performance, platform compatibility, new experimental features, and creating a portfolio.

Question 2: Have you ever written code for a software unrelated to games, like a Web, phone, or desktop app?
The great majority of developers, 119 of the 124 respondents (96%), have experience with traditional software. The respondents can be considered general software developers with expertise in engine development.

Question 3: How similar do you think writing a video-game engine is compared to writing a framework for traditional apps? (Like Django, Rails, or Vue)
Fig. 4 shows that engine developers consider engines different from frameworks: 59% of the respondents believe that engines follows a different process from frameworks. Only 20% believe this process is similar. This is a surprising result as they also have experience in developing traditional software.


Download : Download high-res image (117KB)
Download : Download full-size image
6. Discussions
We now discuss the results of our study of engines along the three perspectives.

6.1. Perils for engines and frameworks
Kalliamvakou et al. (2014) analyzed developers’ usages of GitHub and reported a set of perils and promises related to GitHub projects. Table 5 shows the perils applying to the objects of our study: engines and frameworks. The perils 7, 8 (about pull-requests), and 9 (activity outside GitHub) are out of scope of our dataset.

In Peril 1, the authors distinguished forks and base repositories. In our search, we observed that most repositories are base ones. We found few forks that we removed during the manual filtering. Therefore, this peril is false for both engines and frameworks.


Table 5. Perils of Github repositories adapted from Kalliamvakou et al. (2014). Perils 7, 8, and 9 do not pertain to this work.

#	Perils	Eng.	Fram.
1	A repository is not necessarily a project.	False	False
2	Most projects have very few commits.	False	False
3	Most projects are inactive.	False	False
4	A large portion of repositories are not for software development.	True	False
5	Two thirds of projects (71.6% of repositories) are personal.	True	False
6	Only a fraction of projects use pull requests. And of those that use them, their use is very skewed.	True	True
In Peril 2, the authors reported that the median of commits were 6, with 90% of the projects having less than 50 commits. We observed that the engines and frameworks in our dataset have medians of 616 and 833 commits, respectively, as shown in Table 9.

Peril 3 does not apply to our dataset as the projects have a median of one commit per week and because we removed projects with more than two years without commits.

For Peril 4, the authors found that about 10% of the developers used GitHub for storage. This is partially true for our dataset: we found engine repositories that were used mostly to store assets, documentation, and other files.

Peril 5 is present in this study, specifically in game engine projects: although we removed engines with less than 2 contributors, we found many warnings in read-me files stating that an engine was only for “personal use”, an “unfinished project”, or for “educational purposes” only.

Peril 6 is true for all projects. The number of pull requests for engines is lower than that for frameworks: at least 50% of the engine projects have at least 10 closed pull requests, while frameworks have 100 s.

In general, the perils found in any repositories in GitHub do not apply to our dataset. Engines and frameworks seem different to the projects studied by Kalliamvakou et al. (2014).

6.2. Discussion of RQ1: Literature Perspective
In theory, game engines and frameworks have similar objectives: they are modular platforms for reuse that provide a standard way to develop a product, lowering the barrier of entry for developers by abstracting implementation details.

We could classify frameworks in different categories, according to their domains, e.g., Web apps, mobile apps, AI, etc. In a same category and across categories, two frameworks are not the same. They provide their functionalities in different ways. Similarly, game engines also belong to different categories and are different from one another. For example, 3D or 2D and specific for game genres, like platformer, shooter, racing, etc.

Traditional frameworks provide business services while game engines support entertaining games (Kasurinen et al., 2017). The process of finding the “fun factor” is exclusive to game development (Lewis and Whitehead, 2011, Callele et al., 2015) but do not exempt developers from using traditional software-engineering practices (Petrillo et al., 2009, Kasurinen, 2016). Game engines are tools that help game developers to build games and, therefore, are not directly concerned with non-functional requirements of games, such as “being fun”.

Fig. 5 shows the relationship between game engines, games, frameworks, and traditional software: a video game is a product built on top of a engine, like a Web app is built on top of a Web framework. Engines are a specific kind of framework used to build games. Everything described is a software: Scrumpy24 is a Web app written with Vue while Dota 225 is a game made with Source.

6.3. Discussion of RQ2: Code Perspective
6.3.1. RQ2.1: Static Characteristics
Differences in programming languages
There is a discrepancy between the languages used in game engines, which belong mostly to the C family, and frameworks, developed mostly with interpreted languages. We explain this difference as follows: engines must work close to the hardware and manage memory for performance. Low-level, compiled languages allow developers to control fully the hardware and memory. Frameworks use languages providing higher-level abstractions, allowing developers to focus on features. Frameworks and engines are tools on which developers build their products, who choose the most effective language for their needs.

This observation highlights the needs for performance in engines, through low-level communication with hardware and memory. With the rise of WebAssembly26 and the possibility of running compiled code in Web browsers, this observation could change in the near future.

We explain the predominance of C++ for engines by a set of features of this language: abstraction, performance, memory management, platforms support, existing libraries, and community. These features together make C++ a good choice for game developers.

Engines are usually written (or extended) via their main programming language. However, to ease the design, implement, test workflow during production, game developers often add scripting capabilities to their engines. Therefore, when writing a game, game developers may not code directly with low-level languages but use scripts; sometimes with in a specific domain-specific language. For example, Unity, although written in C++, offers scripting capabilities in C#27 for game developers to build their games. Furthermore, the developer can, possible, finish its game just using this high level language. For any further extension in the game engine they will need to deal with the low level language. On the other hand, frameworks rarely offer scripting capabilities: their products are often written in the same programming languages.

Similarities in licenses
The MIT License is the most used license by both open-source frameworks and open-source engines because it allows reusing and distributing source and–or compiled code in open or proprietary products, with or without changes. Developers can use such these frameworks and engines to create and distribute their software and games without restriction. Also, they can extend or change the code without having to share their intellectual property.

Similarities in sizes and complexities
Our results show small differences in sizes and complexities between engines and frameworks, yet not enough to consider engines different from frameworks.

The size of a piece of code is a simplistic proxy to its quality. Also, regarding the languages and numbers of files, we expected that larger values for frameworks, given the numbers of configuration files and testing functions. However, we reported that engines are larger in all cases, although by a small margin.

The complexities of the functions was another surprise given the large number of small engines: engines are more complex, although by a small difference.

6.3.2. RQ2.2: Historical Characteristics
Our results showed that 40% of the engines do not have tags, which could mean that they are still under development and no build is available.

However, our dataset contains the most important game engines on GitHub, thus there should be other reasons for the lack of engine releases. During our manual analysis, we found engines with warning messages alerting that they were incomplete, lacking some essential features. Also, we observed that about one third of the engines have only two collaborators. This fact combined with the complexity of engines could explain the difficulty to release a first feature-complete version.

Frameworks are released more often than engines with more commits performed more regularly. There are thus meaningful differences between engines and frameworks, which could be explained by the higher popularity of the frameworks (see next section).

6.3.3. RQ2.3: Community Characteristics
Differences in truck factor
The truck-factor is 1 for most of the engines (83%). Lavallée and Robillard (2015) considered that, in addition to being a threat to a project survival, a low truck-factor causes also delays, as the knowledge is concentrated in one developer only. This concentration further limits adoption by new developers. We believe that low truck-factor values are due to the nature of the engines, i.e., side/hobby projects. In contrast, popular frameworks do not have such a dependency on single developers.

Differences in community engagement
We assumed that the numbers of stars for projects in GitHub are a good proxy for their popularity (Borges and Valente, 2018). Surprisingly, engines written in Go and frameworks written in C# are most popular, even though their total numbers are low. JavaScript and C are second and third, respectively. Java is barely present despite its age and general popularity.

6.4. Closed-source vs. open-source game engines
The great majority of commercial games are written with proprietary, closed-source game engines. Recently, an effort for building a robust and powerful open-source game engine became popular with the Godot project. The Godot game engine was thus used by many indie games,28 some of them of high quality.29

Open-source tools for game development had a promising start with Doom and its engine. However, the game industry took another route and closed-source engines are commonplace nowadays. Despite the difference in popularity between open-source game engines and traditional, open-source frameworks, we believe that open-source is the right path to follow. It democratizes and allow a soft learning curve for beginners. Also, it will allow the creation of more diverse games.

6.5. Threats to validity
Our results are subject to threat to their internal, construct, and external validity.

Internal validity
We related engines and frameworks with static and historical measures. As previous works, we assumed that these measures represent the characteristics that they measure as perceived by developers. It is possible that other measures would be more relevant and representative for developers’ choices and perceptions. We mitigated this threat by exploring different perspectives: literature, code, and human. Also, we divided measures along different aspects (static, historical, and community).

Construct validity
We assumed that we could compare fairly projects in different programming languages, for different domains, and with different purposes, as in various previous studies. We claim that different projects can be compared by considering these projects from three different perspectives: literature, code, and human.

External validity
We studied only open-source projects accessible to other researchers and to provide uniquely identifying information. We also shared on-line12 all the collected data to mitigate this threat by allowing others to study, reproduce, and complement our results.

Conclusion validity
We did not perform a systematic literature review integrating gray literature available on the Internet. We accept this threat and plan a multivocal literature review in future work. Our study of the literature confirmed that game engines are little studied in academia.

The higher popularity of the frameworks is a concern: the numbers of contributors are larger and could lead to unfair comparisons. We ordered the dataset by the most popular frameworks and engines, so we expected such effect. In the future, we will improve the categorization of our dataset by separating frameworks and engines based on their domains (Web, security, etc., and 2D and 3D games, etc.).

We mined the dataset using the tags of GitHub with which developers classify their projects. For game engines, we used some variations like game engine, game-engine, or gameengine. We may have missed some projects if developers did not use relevant, recognizable tags. For example, the game engine Piston,30 written in Rust by 67 contributors, is not part of our dataset because it was tagged as “piston, rust, modular-game-engine”. However, we claim that such engines are rare and their absence does not affect our results based on 282 engines and 282 frameworks.

Regarding our survey, Question 3 is broad and could have mislead developers. Although the requirements are different, developers are still creating the building blocks that will serve to build a product. We mitigated this threat through Questions 1 and 2 and the other two perspectives.

Even after filtering out projects with at less than two contributors, most of the open-source engines are, in fact, personal projects. A few, popular, open-source game engines are used by the majority of the released games. In general, commercial games are built using proprietary/closed-source engines (Unity and Unreal). In future work, we could use other metrics to filter the projects than their numbers of contributors and stars; for example, the numbers and stars of the games released using these engines.

Our conclusions, in particular those stemming from RQ2 and RQ3, depend on the users of the analyzed projects: a project with a larger user base would certainly receive more bug reports, see more commits and more contributions, etc. Therefore, comparing the top frameworks, which are certainly used in dozens of others projects, and the top game engines, which are mostly “personal” projects, could be unfair to game engines. We must accept this threat in the absence of means to obtain statistics on the user base of GitHub projects. Future work includes possibly using GitHub Insights on a selected set of projects in collaboration with their developers’ teams.

Finally, we acknowledge that a great part of game-engine development is closed-source. Therefore, these results might not generalize to game engines overall but should hold true to open-source game engines.

7. Conclusion
This paper is a step towards confirming that software-engineering practices apply to game development given their commonalities. It investigated open-source game engines, which form the foundation of video games, and compared them with traditional open-source frameworks. Frameworks are used by developers to ease software development and to focus on their products rather than on implementation details. Similarly, game engines help developers create video games and avoid duplication of code and effort.

We studied open-source game engines along three perspectives: literature, code, and human. Our literature review showed a lack of academic studies about engines, especially their characteristics and architectures. Yet, we showed that, different from what researchers and engine developers think, there are qualitative but no quantitative differences between open-source engines and open-source frameworks. Hence, game engines must be an object of study in software-engineering research in their own right.

We divided the code perspective into three points of view: static code (RQ2.1), history of the projects (RQ2.2), and of their community characteristics (RQ2.3). We studied 282 engines and 282 frameworks from GitHub and contributed with the first corpus of curated open-source engines.12 We reported no significant difference between engines and frameworks for size and complexity but major differences in terms of popularity and community engagement. The programming languages adoption differed greatly also with engines mostly written in C, C++, and C# and frameworks mostly in JavaScript, PHP, and Python. We observed that engines have shorter histories and fewer releases than frameworks.

Finally, our survey results showed that engine developers have also experience in developing traditional software and that they believe that game engines are different from frameworks. The developers’ objectives for developing engines are (a) better control the environment and source code, (b) learn, and (c) develop specific games.


Download : Download high-res image (170KB)
Download : Download full-size image
We will also consider contacting a subset of the top projects and work with their developers’ teams so that they install GitHub Insights, which would provide further information on theprojects, unavailable at the moment when analyzing GitHub data as “outsiders” to the projects.


Download : Download high-res image (633KB)
Download : Download full-size image
Fig. 6. The three perspectives of the study, the research questions and metrics.

Some engines appears suitable for a deeper investigation of their core architectures. The outliers are good candidates to find anti-patterns related to engines and frameworks. While Gregory (2014) presented a complex description of the architecture of an engine, it would be interesting to see how a real, successful engine architecture is similar to the one proposed by the author. Also, we did not discuss in details the most popular, closed-source engines: Unity and Unreal. We could also study the differences between engines and frameworks regarding their workflow to reveal new differences between both types of software. Finally, further investigate engines and frameworks communities (developers’ turnover and how teams are geo-dispersed) as well as why and how these projects choose their languages.