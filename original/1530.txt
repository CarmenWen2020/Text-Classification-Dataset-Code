Abstract
Nowadays, Android apps have penetrated all aspects of our lives. Despite their popularity, understanding their behaviors is still a challenging task. Considering that many Android apps are in the same category and share similar workflows, in this paper, we propose a user behavior pattern mining and reuse approach across similar Android apps, thereby reducing the cost of understanding new apps. Particularly, for a specific new app, to figure out its typical behaviors, the behavior patterns that refer to the frequently-occurring workflows can be obtained from another similar app and transferred to this app. Moreover, to reuse the behavior patterns on this app, a semantic-based event fuzzy matching strategy and continuous workflow generation strategy are raised to generate workflows for this app. To evaluate our approach’s effectiveness and rationality, we conduct a series of experiments on 25 Android apps in five categories. Furthermore, the experimental results show that 88.3% of behavior patterns can be completely reused on similar apps, and the generated workflows cover 89.1% of the top 20% of important states.


Keywords
Android apps
Behavior pattern reuse
Semantic-based event fuzzy matching
GUI model

1. Introduction
In recent years, we have witnessed the rapid development of the mobile Internet and reached a consensus that mobile platforms have dominated the future trend of personal computing and internet working. As Android is the most used mobile platform, a large number of Android apps are developed and launched. Despite their popularity, comprehending the dynamic behavior of an Android app is still challenging in practice. Currently, the most direct way to have insight into a new app’s behaviors is to interact with it according to authentic human experience, but it is tedious and costly.

Intuitively, similar apps in the same domain share similar behaviors, as reported by Kudo et al. (2019) and Mao et al. (2017b). Rather than depending on manual labor, the known behaviors from other similar apps also make it possible to get started with new apps quickly. More specifically, migrating or reusing the existing apps’ behaviors to new apps can help quickly figure out new apps’ behaviors. However, there has been a lack of effort exploiting the benefits of behavior reuse across similar Android apps.

At present, a software system’s behavior is usually captured through dynamic exploration and expressed by traces (Lorenzoli et al., 2008, Brooks and Memon, 2007, Wang et al., 2018). The traces record the system’s workflows, consisting of concrete events sequences triggered by users or crawling. To further analyze and understand the typical behavior of a system, mining generic behavior patterns from the traces, which denote the frequently-occurring workflows of the system, is put forward. In contrast with traces, patterns involved in a system stand for behaviors that are more likely to be triggered. Since similar apps share similar behaviors, the behavior patterns can also be transferred from one app to similar apps. More importantly, behavior patterns reuse can support the automatic creation of tutorials or usage guides, or automatic assistance to the user.

Therefore, this paper proposes a behavior pattern mining and reuse approach across similar Android apps, which mines behavior patterns from existing traces of similar apps and reproduces the patterns to new apps, thereby helping users understand unfamiliar apps promptly. Although this approach is theoretically feasible, we still face several technical challenges both in behavior pattern mining and reusing. Concretely, in pattern mining, the complexity of traces brings difficulties to sequential pattern mining. In pattern reusing, transferring the event sequences in behavior patterns to the new apps presents two challenges. One is that different apps usually vary in GUI, affecting the event mapping across Android apps. The other is that subtle difference still exists in the workflow of similar Android apps, leading to the discontinuity of the mapped events.

To address these issues, the semantic of events and the GUI model of apps are taken into account in this paper in order to achieve behavior pattern reuse across apps. More specifically, since GUI widgets that bind similar events may be syntactically different but semantically similar, the semantics of GUI widgets are considered in the paper in order to realize accurate event mapping across apps. Besides, the attributes of two matched events may not correspond one to one. Thus, a fuzzy matching strategy for GUI events is necessary. Moreover, the GUI model of an application provides a way to link the discontinuous events. So, it is used to guide the generation of feasible and successive workflows for new apps during pattern reuse.

To the best of our knowledge, it is the first to provide an automated behavior pattern reuse approach across Android apps. The primary contributions of this paper are as follows:

1.
A user behavior pattern mining and reuse approach across similar Android apps is proposed, which can reproduce the typical workflows (patterns) from known apps for other unfamiliar apps, reducing the cost of apps comprehension.

2.
A semantic-based event fuzzy mapping strategy and a continuous workflow generation strategy are raised to generate workflows for the new apps during behavior pattern reuse.

3.
An empirical evaluation of 25 open-source Android apps demonstrates that our behavior pattern mining and reuse approach is feasible and effective. Moreover, the generated workflows cover most of the important behaviors in the new apps.

The remainder of this paper is organized as follows. Section 2 introduces a case study to illustrate the behavior pattern reuse process as well as the challenges. Section 3 describes the details of our proposed approach. Section 4 analyzes the empirical evaluation results and threats to validity. Section 5 depicts the related work. Finally, Section 6 concludes our work in this paper.

2. Case study
In this section, we conduct a case study on two similar Android apps to illustrate the process of behavior pattern reuse. Meanwhile, the problems encountered in the process are also pointed out in this part.

Suppose the shopping list app  is a new app that users want to know, which can be regarded as the target app. To quickly figure out the commonly used functionalities of this app, users can take advantage of another similar app (e.g., ) analyzed before.  can be taken as the source app. Assume that behavior patterns of  are mined from traces in advance. Take one behavior pattern indicating sorting shopping items as shown in Fig. 1 as an example. Our goal is to reuse this pattern to the target app , thereby knowing the similar functionality on .

The behavior pattern of the source app in Fig. 1 describes that a user wants to sort the shopping items he/she added before. In more detail, firstly, he/she has to enter the main activity, e.g. activity , and click on the shopping list “Fruit” (
) to reach the  activity . Then, click on “Sort” element (
), arriving at activity . At last, check the “ascending” event (
) in activity  and click on the “OKAY” button (
) to sort shopping items in ascending alphabetical order, leading the sorting result in activity . The behavior pattern is represented as 
.

In order to facilitate the understanding of the reuse process of behavior patterns, we give the final generated workflow for the target app  in advance. The event sequence involved in the target workflow is shown in Fig. 2. Concretely, to sort shopping items, the user should start at the main activity, e.g. activity 
, and click on the shopping list “Fruit” (
) to enter the  activity 
. Then, click on “More options” (
) arriving at activity 
. Then, the “Sort...” event in the activity 
 is triggered (
), and the application transfers to the activity 
. Finally, click on “A-Z” (
) in activity 
, receiving the sort result in the activity 
. The generated workflow is represented as 
.

Even though the workflows for item sorting on the source app and the target app are similar, a direct copy of the behavior pattern from the source app to the target app is not feasible due to two reasons: (1) The appearance of GUI widgets of different apps is different, leading the difficulty of creating event mapping relations between apps. For instance, the widget’s text of 
 in the source app is “ascending”, while that of 
 in the target app is “A-Z”. (2) There are still subtle differences between the workflows of different apps, causing the matched event sequence on the target app not continuous and executable. Take the two workflows in Fig. 1, Fig. 2 as example, for 
, 
 and 
 of the source app in Fig. 1, 
, 
 and 
 of the target app in Fig. 2 are supposed to match them, respectively. Because both event 
 and 
 are to enter the  activity, 
 and 
 aim to provide the sorting menu selection, while 
 and 
 are to sort the shopping items in ascending alphabetical order. And no event is found to match 
 of the source app on the target app. Thus, event sequence 
 on the target app is obtained after creating event mapping relations. However, it is not an executable event sequence since 
 is missing between 
 and 
.

As the example shows, to transfer the behavior pattern 
 of the source app to the target workflow 
, the above two challenges must be solved. For the first challenge in event mapping, from 
 and 
, we can see that although the widgets’ texts are syntactically different, they are similar in semantics. In other words, events achieving similar functionality are alike in the semantics of the widgets they bind. So the semantic of events should be considered when matching events across apps. Besides, the semantic of two similar events may come from different attributes of widgets. For example, the widget of 
 has the content description “sort” while that of 
 has the text “sort”. Intuitively, all attributes of a widget can represent its semantics, and they are consistent in semantics. Thus, the attributes of widgets from one application can cross-compare with those of widgets from a similar application. For the second challenge in pattern reuse, the GUI model of an application is widely used to supplement events when migrating event sequences across different platforms (Qin et al., 2019) and applications (Behrang and Orso, 2019) . Inspired by them, in this paper, the GUI model of the target app is taken into account to support feasible workflow generation.

3. Behavior pattern mining and reuse approach
It can be observed that behavior patterns reuse across Android apps can facilitate automatic apps comprehension to users or automatic creation of tutorials or usage guides. Nevertheless, how to automatically create an event mapping relation between similar apps and link all the mapped events together to form a continuous workflow for the target app is still a complex problem.

As mentioned above, events achieving similar functions are alike in their semantics, and the GUI model can chain events when migrating event sequences across apps. For this reason, this paper proposes a semantic-based event fuzzy matching strategy and pattern-oriented continuous workflow generation strategy to support behavior patterns reuse across Android apps.

Fig. 3 shows the overview of our approach, which consists of three modules: User Behavior Pattern Miner, GUI Model Builder and User Behavior Pattern Reuser. User Behavior Pattern Miner aims to mine user behavior patterns from traces obtained during users’ interaction with the source app. Moreover, a sequential pattern mining algorithm is utilized to deal with traces and draw out behavior patterns. To assist in reusing user behavior patterns, GUI Model Builder dynamically builds a GUI model for the target app by depth-first exploration. User Behavior Pattern Reuser takes advantage of the source app’s behavior patterns and the GUI model of the target app to generate continuous and executable workflows for the target app. In the rest of this section, we will describe each module in more detail.

3.1. User behavior pattern miner
Before mining behavior patterns from traces, we first give the formal representation of traces and behavior patterns of Android apps reported in this paper. On this foundation, the traces collection and pattern mining methods are introduced.

3.1.1. Definitions of traces and behavior patterns
In this paper, Android apps’ behaviors are captured as traces when users interact with the apps. The trace involves events and states that a user-triggered. Concretely, a user trace represents an access process performed by one user on a certain app, which can be defined as follows:

Definition 1 Trace

A user trace is composed of states and associated events triggered by users. That is, trace 
, and a trace element 
 maps to a triple 
, where 
 is the 
 event recorded, and 
 and 
 are the app states before and after 
 triggered, respectively. In more detail, event  is a triplet , where  is the event type (In this work, we classify events into three types, namely , - and ),  is the GUI widget on which  triggered and  is the text value enters by users. State  consists of the activity name and the UI hierarchy of the activity page.

User behavior patterns represent the frequent workflows mined from the concrete traces. To quantify the frequency of workflows, we first introduce a concept of support commonly used in patterns mining.

Definition 2 Support

A sequence 
 is supposed to be a sub-sequence of trace  only if  and , denoted as . Given a trace set 
, the absolute support of the sequence  in  is the number of traces in  which contains . And the relative support of  is the absolute support divided by TS, where TS refers to the total number of traces in .

Based on the definition of support, behavior patterns of Android apps can be defined as below:

Definition 3 Behavior Pattern

Given a minimum support , the behavior pattern is a frequent sequence  in trace set  satisfying .

3.1.2. Behavior patterns mining
Based on the definition of behavior patterns, this part discusses the behavior patterns mining approach. There are three steps for mining patterns, including traces collection, traces preprocessing, and patterns mining. The details are as below.

Traces collection is the foundation of behavior pattern mining in Android apps. Appium (Singh et al., 2014) is widely used to record and replay complex user actions. In this work, it is utilized to record users’ interactions with the source app. Nevertheless, only the events can be captured, while the state information (i.e., activity) cannot be gotten by Appium. To record the states that users trigger, we record the test scripts of Appium and insert probes into test scripts before and after the triggering event. After that, the instrumented test scripts are replayed to obtain the triggered states and events of the source app, forming a trace set.

In order to facilitate the sequential pattern mining, trace elements in the trace set are preprocessed in advance. The trace preprocessing is to recognize similar trace elements and give them the same representation. In more detail, given two trace elements 
 and 
, whether they are similar is determined by gradually comparing the event type, widget attributes, activity name and UI hierarchy of state. If 
 and 
 are recognized as similar trace elements, they will be assigned a same label. After all trace elements in the trace set are preprocessed, the trace set is transferred to a labeled trace set.

The user trace is essentially an event sequence. Thus, sequential pattern mining can be applied to identify the frequent workflow based on the labeled trace set. CloFAST (Fumarola et al., 2016) is a novel closed sequential pattern mining algorithm, which combines a new data representation of the sequence dataset with an one-step technique to fast count the support of sequences and efficiently mine closed sequential patterns. A closed sequential pattern refers to a sub-sequence with support greater than , and it is not a sub-sequence of any other sequential patterns with the same support. Thus, this paper chooses CloFAST to mine user behavior patterns from the labeled trace set. Besides, there may be an inclusion relation between two event sequences mined from traces. That is, one event sequence is a sub-sequence of another one when they are with different support. In this situation, it is unnecessary to keep both of them. Since the longest sequences represents a more complete user behavior pattern, this paper filters out the event sequences contained by other sequences and reserves the longest sequences as the behavior patterns for subsequent pattern reuse.

3.2. GUI model builder
As mentioned above, when reusing behavior patterns from the source app to the target app, the slight difference between applications may cause event sequences of behavior patterns to break in the target app. To alleviate this issue, this paper employs the target app’s GUI model to make discrete mapped events linked together.

Since behavior patterns reuse across apps concern the reproduction of events and states, the GUI model of target apps only needs to focus on events and states. Hence, the GUI model of an Android app can be defined as follows:

Definition 4 GUI Model

Essentially, the GUI model is a Finite State Machine (FSM) which can be represented by a tuple 
. S is the set of states which refers to activity pages of the app, 
 is the initial state and  is the set of final states.  is the set of events.  is the set of transitions, and each transition  takes the form of 
, where 
 are the source and target state and  is the event.

According to this definition, the GUI model of target apps is constructed through dynamic exploration automatically. In more detail, the target app starts with the initial state 
. In the current state, all available events are extracted and stored in a stack. Then, the event at the top of the stack is popped and triggered. If a new state is reached, a new state 
 and a new transition 
 associated with the event and the states are created and added to the GUI model. Meanwhile, the acquirable events on the state 
 are identified and pushed into the stack. Otherwise, only a new transition 
 associated with the event and the existing states is created and added to the model. Repeat the process above until all events in the stack are triggered.

Notably, by observing Android apps’ behavior, it can be found that all input widgets on a GUI are logically associated. Moreover, most editable events binding the input widgets need to be followed by a clickable event to jump to another state. In this situation, the editable events should be combined with the clickable event so as to explore more states and reduce self-loops states as well as the unnecessary transitions. Thus, in this paper, composite events are raised to organize such events above, thereby compressing the state space of the GUI model. In contrast with composite events, atomic events refer to single clickable events and long-clickable events.

The discrimination strategy for composite events and atomic events is as below. At first, all input widgets are distinguished and extracted from the state. Then, the context information related to the input widgets is obtained. That is, the data type and semantic information, such as “username,” “password”, “mobile phone number”, and other text information, are identified for the input widgets. Then, according to the keywords associated with clickable events, such as “submit”, “confirm”, and “register”, search the relevant click widget related to these input widgets. Finally, the corresponding composite events are distinguished according to the input widgets and click the widget. Moreover, all events except composite events are recognized as atomic events.

3.3. User behavior pattern reuser
Based on the behavior patterns mined from the source app and GUI model of the target app, the User Behavior Pattern Reuser module aims to reproduce the patterns for the target app through generating executable and continuous target workflows. It consists of two phases, the first one is to create a mapping relation between the events of the source app and target app based on the semantic-based event fuzzy matching method (SEFM). And the second one is to generate a continuous workflow chaining the mapped events for the target app with the help of its GUI model. The details of this module will be explained in the rest of this section.

3.3.1. Semantic-based event fuzzy matching
To reuse user behavior patterns from the source app to the target app, we need to find events in the target app corresponding to the source app’s behavior patterns. As mentioned above, the subtle disparity of the GUI between similar applications affects event mapping. Nevertheless, in general, events achieving the same functionality are semantically similar. Thus, this paper proposes a semantic-based event fuzzy matching (SEFM) strategy to map events across Android apps.

Next, we first analyze the constituents of events and then, based on them, give a semantic-based event similarity measurement and a fuzzy matching strategy to estimate the similarity between events, thereby achieving events mapping.

Event analysis.
To match the event 
 of the source app to the event 
 of the target app, the semantic information of events is considered. In more detail, an event of Android apps can be represented as a triplet , where  represents the event type,  represents the activity on which the event triggered, and  represents attributes of the widget binding the event.

In terms of the semantic of events, they may come from attributes , such as id, text, content description, etc. For the id attribute, developers usually prefer assigning a specific meaning to the id of a widget, reflecting its functionality. Thus, it can signify the semantics of events. For the text and content description, the former is to show on the widget, and the latter aims to help users understand the functionality of the widget. And if a widget has neither text nor content description, the description information may be retrieved from its surrounding widgets within a certain kinship. In addition, the hint is always assigned to editable widgets for displaying the prompt message about input. For widgets with images, the image content is generally reflected in the filename of the image, which should also be considered.

Overall, the id, text, content description, description from the surrounding widgets, hint and the filename of images of the widget binding the event can imply the semantics of the event.

Semantic similarity of events’ attributes.
As mentioned above, one event may correspond to multiple attributes representing its semantics. Based on them, the semantic similarity between events is measured.

Concretely, for a pair of events (e.g. the source event 
 and target event 
) to be matched, their attributes relevant to semantics can be expressed as 
 and 
, respectively, where both 
 and 
 consist of the attribute and its value, expressed by . To measure the semantic similarity between 
 and 
, the similarity between attributes (e.g. 
 and 
) from 
 and 
 should be measured at first.

Given two attributes 
 of source event 
 and 
 of target event 
, their semantic similarity can be computed by text comparability. That is, 
 and 
 are regarded as natural language and preprocessed, including tokenization, lemmatization, and stopword removal. After that, two token lists for 
 and 
 are obtained, expressed by 
 and 
, where 
, 
, and 
 and 
 represent tokens involved in 
 and 
. To measure the semantic similarity between 
 and 
, the Word2Vec model that is specific to the word vector representation for the Android domain trained by Behrang and Orso (2019), is utilized to translate tokens to word vectors and compute the cosine similarity between word vectors as the semantic similarity of tokens. In particular, the cosine similarity of all token pairs from 
 and 
 are computed. Then, the highest value is taken, and the pair of tokens for this highest value is “linked”. Meanwhile, these tokens are removed from their token lists, and the next highest value is taken. Repeat the process until either 
 or 
 is empty. After all the best matched token pairs are distinguished, the average of their cosine similarity is taken as the semantic similarity of 
 and 
. Namely, the semantic similarity of the attribute 
 and 
.

Event fuzzy matching strategy.
Based on the semantic similarity between the attributes, the semantic similarity between the source event 
 and target event 
 can be calculated. As mentioned above, widgets corresponding to similar events are similar in the semantic of attributes. But attributes representing the same semantics may come from different sources. For example, a widget TextView leverages the  to indicate its function while the matched widget ImageView uses the  to implies its function. To identify such similar events, in this paper, we propose an event fuzzy matching strategy, which considers cross-pairing between different attributes instead of the one-to-one pairing of the same attribute.

In more detail, to compute the semantic similarity between events 
 and 
, each attribute 
 in 
 are compared with all attributes of 
 (i.e. 
), and the highest similarity between attributes (e.g. 
 and 
) is regarded as the similarity between the attribute 
 and attributes of 
. And the average of all the highest similarity between the attributes of 
 and that of 
 is taken as the semantic similarity from 
 to 
, expressed by 
. Likewise, each attribute 
 from the 
 is compared with all attributes of 
 (i.e. 
), and the highest similarity between attributes (e.g. 
 and 
) is regarded as the similarity between the attribute 
 and attributes of 
. And the average of all the highest similarity between the attributes of 
 and that of 
 is taken as the semantic similarity from 
 to 
, expressed by 
. After that, the semantic similarity between 
 and 
 (i.e. 
) is the average of 
 and 
.

To better understand the SEFM strategy, take the click events on two ImageButtons at the bottom of activity  in Fig. 1 and activity 
 in Fig. 2, namely 
 and 
, as an example. The  of the widget binding 
 is “fab_new_list”, the image  is “ic_input_add”, and the description from a surrounding widget is “CREATE A LIST”. For the widget binding 
, its  is “fab” and the image  is “ic_note_add_white_24dp”.

Assume that 
 is the source event and 
 is the target event. Firstly, the attributes of these two events are extracted and preprocessed. The attributes set of 
 (i.e. 
) is {
, 
CREATE A LIST)}, that of 
 (i.e. 
) is 
. After tokenization, lemmatization and stopword removal, the token lists of each attribute in 
 are 
  [“floating”, “action”, “button”, “new”, “list”], 
  [“add”, “input”] and 
  [“create”, “list”], while the token lists of each attribute in 
 are 
  [“floating”, “action”, “button”] and 
  [“add”, “note”], respectively.

Then, the semantic similarity between any two attributes of 
 and 
 is computed by the cosine similarity of tokens extracted from attributes. Take attribute  of 
 and 
 as an example, whose token lists are 
 and 
, respectively. The semantic similarity between token pairs is shown in matrix 
. It can be seen from this matrix, the best matched token pairs in 
 and 
 are  and  with cosine similarity of 1.0 and 0.1107. Thereby, the semantic similarity between  of 
 and  of 
 is (1.0  0.1107)/2  0.5554.

Considering the fuzzy matching strategy, the  of 
 should be also compared with the  of 
, whose token lists are 
 and 
. The semantic similarity between token pairs is shown in matrix 
. The best matched token pairs are  and  with cosine similarity of 0.3899 and 0.0304. So, the semantic similarity between  of 
 and  of 
 is (0.3899  −0.0304)/2  0.1798.


Download : Download high-res image (22KB)
Download : Download full-size image

Download : Download high-res image (32KB)
Download : Download full-size image
Based on the semantic similarity between any two attributes from 
 and 
, the similarity matrices between events 
 and 
 are as follows, where matrix 
 is the similarity matrix from 
 to 
 and matrix 
 is the similarity matrix from 
 to 
.


Download : Download high-res image (26KB)
Download : Download full-size image

Download : Download high-res image (26KB)
Download : Download full-size image
From these matrices, we can see that the similarity from 
 to 
 (i.e. 
) is calculated as (1.0  0.5554  0.8403)/3  0.7986, while that from 
 to 
 (i.e. 
) is calculated as (1.0  0.5554)/2  0.7777. Thus, the semantic similarity between 
 and 
 (i.e. 
) is (0.7986  0.7777)/2  0.7882.

Besides the semantic similarity of events, we also take (1) the event  and (2) the name of  on which the event triggered, into consideration to measure the similarity between events. This is because the event type could distinguish similar events in coarse granularity; in other words, events of a different type are intuitively not similar, which is especially reflected between  events and other events. Moreover, the activity name generally reflects certain functionality of the application, and events on totally different activities are not similar to a great extent.

Thus, the similarity between two events can be computed as below. Given an event pair 
, the similarity between them is defined as shown in Eq. (1): (1)
  where 
 and 
 are the event type of 
 and 
, respectively. 
 is the attributes’ semantic similarity between 
 and 
. And 
 is the activity name’s semantic similarity between 
 and 
.  and  are the weights of 
 and 
, and the sum of  and  is equal to 1.

For each source event in the user behavior pattern, SEFM computes the event similarity between it and all available events in the target app, and then takes such events whose similarity exceeds the preset threshold as the candidates. Based on the candidate events, a pattern-oriented continuous workflow generation approach is raised to link them for the target app.

3.3.2. Pattern-oriented continuous workflow generation
According to the candidate events matched with source events in behavior patterns, the  module tries to generate an executable workflow for the target app by chaining the discontinuous candidates with the GUI model. More specially, based on the behavior patterns, the candidate events in the GUI model are extended to the target workflow one by one by using the backward search. Moreover, since candidate events in the GUI model are discrete, there may be multiple candidate paths concatenating two ordered events together. To further improve the efficiency of target workflow generation, a candidate path selection strategy is raised to guide the search process.

In what follows, we will detail the candidate path selection strategy, and based on it, introduce the target workflow generation method.

Candidate path selection strategy.
Based on the SEFM strategy, for a source event in behavior patterns, events in the target app whose similarity exceeds the preset threshold are taken as its candidate events. As mentioned above, candidate events corresponding to two ordered source events may be incontinuous in the target app, such as 
 and 
 of  shown in Fig. 2. In order to generate the executable workflow for the target app, it is necessary to find a partial path between the two ordered candidate events to chain them in series. Particularly, there may be several partial paths, named candidate paths, between ordered candidate events. This can boil down to two reasons. One is that a source event in the behavior pattern may correspond to multiple candidate events. The other is that there may be several paths reaching a specific candidate event from the current state of the target workflow. Thus, how to select the best candidate path closest to the behavior pattern to expand the target workflow is a critical problem.

For example, Fig. 4 is a partial GUI model of a certain target app. Assume that the target workflow  is in a state at some point, e.g.,  in the GUI model. And there are two candidate events matching the next source event, e.g. 
 and 
, which will be used to extend the . Obviously, 
 and 
 cannot be added to the  directly, since their source states are not state . So there is a need to generate partial paths linking the  to candidate events 
 and 
. These kinds of partial paths are candidate paths. More specially, for 
, there are two candidate paths in the GUI model of target application, which are 
 and 
. For 
, its corresponding candidate path 
 is 
. But which candidate path should be chosen to extend the ?

As mentioned in 3.3.1, the candidate event, whose semantic is closer to the source event’s semantic, should be selected preferentially as the target event. On the other hand, since workflows achieving the same functionality are proximal in the number of steps (events) involved, the candidate path from the current state to the candidate event should be as short as possible. So, when expanding the target workflow, the candidate path selection depends on not only the semantic similarity of events but also the length of candidate paths.

Therefore, this paper proposes a candidate path priority rule considering the semantic similarity of events and the length of candidate paths. The priority score of a candidate path is defined as Eq. (2): (2) 
 
 where  is a candidate event matching the source event  in the behavior pattern,  is a candidate path reaching  from the current state of the target workflow, and  is the length of .  refers to logarithm. 
 is the similarity between  and .

From this formula, we can see that if  is within a certain length, the event similarity 
 directly determines the priority score. Otherwise, the event similarity is penalized by the length of the candidate path, forming the priority score. This is because that for the shorter , the similarity between  and  is critical, while for the longer , the path length has an adverse influence on the priority of candidate paths.

After computing the priority score for all candidate paths, we sort them from highest to lowest based on their priority and then execute them in turn to verify their feasibility. The first executable path is selected to be a segment of the target workflow.

Continue the above example in Fig. 4, assume that 
 has higher similarity than 
. The priority score of 
, 
 and 
 is computed and compared as below. For 
 and 
, both of them aim to link the same event 
, while the length of 
 exceeds 2 and that of 
 is within 2. The priority score of 
 is penalized by its length. Thus, the priority score of 
 is higher than that of 
. For 
 and 
, the length of them is within 2. So, the event similarity decides the priority score of 
 and 
. As 
 is more similar with the source event than 
, the priority score of 
 linking 
 is higher than that of 
 linking 
. Thus, 
 has the highest priority. If 
 is executable, it will be added to the target workflow. Otherwise, we further compare the priority score of 
 and 
, and the one with higher priority will be selected to extend the workflow.

Target workflow generation by backward search.
Based on behavior patterns, the target workflow is generated from the GUI model by the backward search for the target app, guided by the candidate path selection strategy.

In more detail, for an event sequence in behavior patterns from the source app, firstly, one source event is mapped to some candidate events of the target app by the SEFM strategy. Then, the candidate paths reaching candidate events from the current state of the target app are identified and evaluated by the priority rule. And the candidate path with the highest priority score is chosen to extend the target workflow. Next, this candidate path is executed. If it is executable, the next candidate event corresponding to the next source event will be handled. Otherwise, it will be abandoned, and another candidate path is selected. In extreme cases, if all the candidate paths are infeasible, the current candidate events go back to the last set of candidate events, and another candidate path reaching the last candidate event set is selected. Repeat this process until all events in the behavior pattern are traversed.

3.3.3. The algorithm of user behavior pattern reuse
The core idea of our behavior pattern reuse approach is to create an event mapping from the source app to the target app by the SEFM strategy and generate a continuous workflow for the target app based on the candidate path selection strategy. The pseudo-code is summarized in Algorithm 1.

Given (1) a user behavior pattern () of source app and (2) a GUI model () of target app as input, the algorithm first matches events in  with that of the target app and then generates the target workflow  chaining the mapped events for the target app with the GUI model.

To be more specific, in  phase, firstly, all available events () are extracted from the GUI model of the target app (Line 3). For each source event  in , the similarity between  and all events in  is calculated based on the formula (1). And if the similarity between  and event  in  exceeds the threshold value, then  is added to the candidate event set . After all events in  are compared with , a candidate event set  is obtained which stores the candidate events similar to  (lines 7–13). After all source events in  are traversed, all candidate event sets are identified and stored in a list  (Lines 4–15).

Based on the , the target workflow is generated through linking candidate events in  sequentially. In the  phase, firstly, the state of  is initialized as 
 of the GUI model (Line 17), and the target workflow  is set to an empty list (Line 18). Then, a recursive algorithm of generating target workflow (i.e., ) is designed to generate  for the target app, as detailed in Algorithm 2.

Concretely, the GTWF function has five parameters, which are , , ,  and . Among them,  is the target workflow to be generated,  is the index of the current candidate event set in ,  is the index of the candidate event set where backtracking occurs,  is a set of invalid paths, and  is the original target workflow before backtracking occurs. The termination condition of the GTWF function is that  equals the size of , which means that all mapped events have been connected. At this time, the finally generated target workflow  is returned (Lines 2–3).

The detailed generation process is as follows. Firstly, for the current candidate event set  in , all candidate paths from the  to the source state of every event in  are collected (Lines 5–15). That is, for each candidate event  in , its source state is identified and regarded as the destination state  of the current state  (Lines 7–8). If  and  are the same state, the candidate path is a path directly linking the  from the  (Lines 9–10). Otherwise, the GUI model  is used to generate paths linking the  and  by depth-first search (Line 12). And the candidate paths  are added to the set  (Line 14). After that, all candidate paths except paths in  are evaluated by the priority rule and sorted from highest to lowest based on the priority score (Lines 14–17). Then paths in  are executed in turn, and the first executable path is obtained (Line 18). If such executable path  exists, it is used to extend the target workflow , and meanwhile, the  increases by 1 (Lines 19–21). Otherwise, namely, when all alternative paths cannot expand the current , the backtrack occurs (Lines 23–35). The termination condition of the backtrack is that  rolls back to 1, meaning that no feasible paths can reach the candidate event set where the backtrack starts. At this time, this candidate event set is skipped, and the  is restored to its original state  (Lines 23–25). When  is greater than 1, we backtrack to the last candidate event set by reviving the  to the previous state and invalidating the last path . If  is greater than , meaning that a new backtrack point has been encountered, then the current  is recorded to , and the new  is modified to  (Lines 27–33). Subsequently, the  decreases by 1 (Line 34). At last, the new values of parameters are passed to the next recursive call of .


Download : Download high-res image (205KB)
Download : Download full-size image

Download : Download high-res image (379KB)
Download : Download full-size image
4. Empirical evaluation
In order to verify the validity of our user behavior pattern mining and reuse approach, we conduct experiments on five categories of similar Android apps. Moreover, four research questions are raised below.

RQ1.
Do behavior patterns mined from traces by our method represent the typical functionality of similar apps?

RQ2.
How effective is our SEFM strategy in event matching across similar apps? And how much influence does the fuzzy strategy have on event matching?

RQ3.
Can the continuous workflow generation method create effective workflows for the target apps?

RQ4.
Is our pattern reuse approach correctly transferring behavior patterns of source apps to target apps?

4.1. Evaluation metrics
To evaluate the effectiveness of our behavior pattern reuse method, we propose a series of metrics. In more detail, to measure our SEFM strategy, the matching accuracy of events is measured from different aspects as below. The straightforward metric is the correctly matched events  (i.e., true positives, ), which refers to the ratio of the correct counterparts in matched candidate event sets of the target app to source events in the behavior patterns. On the other side, those events that are not successfully matched can be classified into three categories. The first one is the incorrectly matched events  (i.e., false positives, ), which indicates the percentage of source events in the behavior pattern that are matched to the wrong events in the target app. In fact, the source events may not have a counterpart in the target app. The second one is the incorrectly unmatched events  (i.e., false negatives, ), which means the percentage of source events in the behavior pattern that have a counterpart in the target app but are not matched to any event. And the third one is the correctly unmatched events  (i.e., true negatives, ), representing the percentage of source events in the behavior pattern that are not matched to any event, and this is largely because that they have no counterpart in the target app.

Moreover, whether our continuous workflow generation method creates effective workflows can be analyzed from the reuse of behavior patterns and the coverage of target workflows. For the reuse of patterns, it reflects in the percentage of completely reused behavior patterns  and the percentage of partially reused ones . Particularly,  means the target workflows reproducing all events in behavior patterns, while  indicates the target workflows failing to reproduce some events in behavior patterns that have a counterpart in the target app. In terms of the generated target workflows, whether they can cover staple states of the target app reflects our behavior pattern reuse method’s effectiveness. Betweenness centrality  is one of the most commonly used centrality measures, which is formally defined for the first time in Freeman (1977). In a general network consisting of vertices and edges, a vertex holding a high  value has the potential to control the communication taking place between vertices. Correspondingly, in the Android app’s GUI model, we think that a state  having higher  is more likely to be triggered. In other words, state  is more important. Thus, this paper adopts the  of a state  to express its centrality (importance), which is defined as the total fraction of the shortest paths between arbitrary state pairs that use or pass through . To evaluate the target workflows, the  of all states on the GUI model are calculated, and states are sorted by  from highest to lowest. Furthermore, these states are divided into three levels according to their importance. The range of 
 is the top 20% of states, the range of 
 is the top 20% to 50%, and the remaining states are divided into 
. If the generated target workflows cover more important states belonging to the preceding levels, then it demonstrates that our behavior pattern reuse method is effective in figuring out typical behaviors of new apps.

Besides, to verify whether our behavior pattern reuse approach can correctly transform behavior patterns of the source app into event sequences of the target app, the human experience is used to measure its effectiveness. In particular, we surveyed three postgraduates and asked them to mark each reused event sequence. Their feedback may be ✓,  and , where ✓means that the pattern is correctly translated,  is that the pattern is incorrectly translated, and  represents they are not sure.


Table 1. Android apps used in the study.

Category	App name	Version	LOC	Source
Shopping list	S1 - Shopping list	v1.0.1	7.1K	Google Play
S2 - Shopping list	v1.2.3	5.2K	Google Play
S3 - Shopping list	v1.0.8	18.9K	Google Play
S4 - OI shopping list	v1.7.0.5	32.3K	Google Play
S5 - Fast shopping	v1.3.50	11.5K	F-Droid
Note taking	N1 - Swiftnotes	v3.1.4	4.8K	Google Play
N2 - Note now	v2.8	6.1K	Google Play
N3 - Notepad	v1.12	2.7K	F-Droid
N4 - Notepad	v1.06	2.3K	F-Droid
N5 - uNote	v1.5.1	4.3K	F-Droid
Expense tracker	E1 - Easy budget	v1.5.2	14.1K	Google Play
E2 - Money tracker	v2.1.3	12.6K	Google Play
E3 - Budget watch	v0.21.5	12.9K	F-Droid
E4 - Pro expense	v1.0.0	16.8K	F-Droid
E5 - DailyBudget	v2.0	5.8K	F-Droid
Weather	W1 - Geometric weather	v2.608	77.6K	Google Play
W2 - Forecastie	v1.5	8.5K	Google Play
W3 - Good weather	v4.4	9.7K	Google Play
W4 - World weather	v1.2.5	19.7K	Google Play
W5 - Weather	v2.4.2	25.6K	F-Droid
Todos management	T1 - Clear list	v1.5.6	15.7K	F-Droid
T2 - Minimal	v1.2	3.4K	F-Droid
T3 - Minitask	v1.0	38.0K	F-Droid
T4 - Simple Todo	v1.1	3.5K	F-Droid
T5 - Fire Todo	v1.5	3.3K	Google Play
4.2. Experimental subjects and design
Our behavior pattern reuse approach is implemented with Python, and it is precisely for Android apps. According to the suggestion of Behrang and Orso (2019), we select five categories of Android apps from Google Play or F-Droid to evaluate the effectiveness of our approach. In addition, whether the apps are commonly used and open source is still considered when selecting experimental subjects. These categories are , , , , and , respectively. And each category provides a standard set of features. For each category, we select five open source applications. One of them is chosen randomly to be the source app, and the others are the target apps.

Table 1 shows the details of Android apps, including the category, app name with ID, version, size (LOC) and the source of each app. In our experiment, we choose  and  as the source apps of each category. Furthermore, to gather user traces for the source apps, we ask five masters to interact with the apps using Appium. These five masters are not participants in this study, and their interactions with apps are based entirely on their daily habits of using apps in the same category. In addition, the minimum relative support is set to 0.1 since the size of our trace set is relatively small, and the event similarity threshold in our experiments is set to 0.5. The parameter  and  in the event similarity formula are set to 2/3 and 1/3, respectively. In order to look for these appropriate parameter values, we conducted experiments on different parameter values. Take the minimum relative support as an example. We first set it to 0.3 and then gradually set it to 0.2 and 0.1. It is found that the user behavior patterns mined with the minimum relative support of 0.1 are better in terms of number, length, and functional representation. Then we increase and decrease the minimum relative support in the step of 0.01 around 0.1 and conduct experiments. Finally, the conclusion is that 0.1 is the most appropriate minimum relative support.

4.3. Experimental results and analysis
4.3.1. Results for RQ1
To evaluate the effectiveness of our behavior patterns mining method, we further analyze the functionality involved in the patterns and verify whether they can represent the typical workflows of Android apps. Table 2 shows the results of behavior patterns mined from user traces for the five source apps. This table reports the number of user traces of each app (#traces), the number of events in user traces (#evtsTraces), the number of user behavior patterns mined from user traces (#patns), the number of events in these patterns(#evtsPatns), and the typical functionality (Typical functionality) we summarized from these patterns.

As can be seen from Table 2, for five source apps , , ,  and , there are 13, 5, 8, 14, and 8 behavior patterns mined from the recorded traces, respectively. Taking the source app  as an example, through analyzing 13 patterns involved in this app, we can summarize 7 typical functionalities they represent. They are adding, deleting, and editing operations to a specific list or item, respectively, as well as sorting items of a list. Obviously, these functionalities are ubiquitous in shopping list apps, thus representing the typical functionality of such a category of apps to a certain extent. The other three categories of apps’ experimental results are the same, confirming that the behavior patterns do represent the typical functionality of the same category of apps.

Notably, the number of typical functionalities does not equal the number of patterns because there is a common situation that multiple patterns achieve the same functionality, even if the event sequences contained in patterns have a subtle difference. For example, there are two ways to delete an item in . One is to long-click the item and click the delete operation, while the other is that check the item, open the options menu, and delete the checked item. Both of them are common behavior patterns to achieve the functionality of deleting an item.


Download : Download high-res image (78KB)
Download : Download full-size image
Fig. 4. Example of candidate events and corresponding candidate paths.


Table 2. Results of behavior patterns mined from traces.

App	#traces	#evtsTraces	#patns	#evtsPatns	Typical functionality
S1	35	274	13	65	1. add list
2. delete list
3. add item
4. delete item
5. edit the list information
6. edit the item information
7. sort items
N1	41	278	5	26	1. add note
2. delete note
3. search note and view it
4. edit and favorite note
E1	40	278	8	46	1. tutorial page
2. add expense
3. add income
4. edit expense
5. delete expense
6. delete income
7. set low balance warning threshold
W1	35	293	14	84	1. search for a new location
2. set the data refresh interval
3. set the temperature unit
4. set the distance unit
5. set the pressure unit
6. set the wind speed unit
7. view the about information
8. set the theme of the app
T1	35	259	8	36	1. choose list category
2. view task
3. add task
4. mark a task as completed and delete it
5. add list category
4.3.2. Results for RQ2
To evaluate the effectiveness of our SEFM strategy in the event mapping phase, we analyzed the event matching results with and without the fuzzy strategy, respectively. The results are listed in Table 3. Note that the benchmark of event mapping across apps is obtained through manual analysis. That is, we manually find the correct counterparts on the target app for each source event in patterns or determine that the source event has no counterpart on the target app. In Table 3, the first and second columns show the ID of the source and target apps, respectively. Column 3 and column 4 show the percentage of correctly matched events () and incorrectly matched events (), while column 5 and column 6 shows the percentage of unmatched events with a counterpart () and with no counterpart () in the target app.

As Table 3 shows, for the , , ,  and  categories, our method correctly matches () 72.7%, 55.8%, 51.1%, 54.8% and 43.8% of source events in patterns with the fuzzy strategy, and 56.5%, 45.2%, 56.5%, 25.0% and 36.8% of that without the fuzzy strategy, respectively. As for the unmatched events , our method fails to match 2.7%, 6.7%, 7.1%, 0.3% and 2.8% of source events in patterns that have counterparts in the target app with the fuzzy strategy, while 22.7%, 10.6%, 0.6%, 8.6% and 4.9% without the fuzzy strategy. These results show that among 20 target apps, for 16 apps that belong to the , ,  and  categories, the fuzzy strategy can increase the proportion of correctly matched events and reduce the proportion of unmatched events that have counterparts. For apps in the  category,  shows that the fuzzy strategy has no effect on event matching, and the other three apps even show better results without fuzzy matching.

Besides, we further combine these metrics above into the precision and recall, where the precision is equal to , and the recall is equal to . As Table 4 shows, with the fuzzy strategy, the average precision of the , , ,  and  categories are 77.2%, 75.4%, 58.7%, 60.7% and 67.6%, and the recall are 96.7%, 89.0%, 88.9%, 99.5% and 94.5%, respectively. While without the fuzzy strategy, the precision are 77.2%, 69.1%, 64.2%, 29.9% and 57.2%, and the recall are 69.4%, 81.1%, 99.0%, 73.7% and 84.4%, respectively. For , ,  and  categories, the precision and recall with the fuzzy strategy exceed those without the fuzzy strategy. For the  category, the results are the opposite.

Overall, the fuzzy strategy increases  by 11.6% and reduces  by 5.6%. And the precision and recall are increased by 8.4% and 12.2%, respectively. Thus, the effectiveness of the SEFM strategy is demonstrated.


Table 3. Results of event matching with and without the fuzzy strategy.

Src	Tgt	CM	ICM	UM	UM!
Fuzzy	Without fuzzy	Fuzzy	Without fuzzy	Fuzzy	Without fuzzy	Fuzzy	Without fuzzy
S1	S2	83.1%	80.0%	10.7%	10.7%	3.1%	6.2%	3.1%	3.1%
S3	86.2%	78.5%	4.6%	7.7%	4.6%	9.2%	4.6%	4.6%
S4	64.6%	50.7%	32.3%	27.7%	3.1%	20.0%	0%	1.5%
S5	56.9%	16.9%	40.0%	9.2%	0%	55.4%	3.1%	18.5%
Avg.	72.7%	56.5%	21.9%	13.9%	2.7%	22.7%	2.7%	6.9%
N1	N2	61.5%	42.4%	7.7%	19.2%	3.9%	11.5%	26.9%	26.9%
N3	42.3%	38.5%	26.9%	19.2%	7.7%	7.7%	23.1%	34.6%
N4	61.5%	46.2%	15.4%	26.9%	7.7%	11.5%	15.4%	15.4%
N5	57.7%	53.9%	23.1%	15.4%	7.7%	11.5%	11.5%	19.2%
Avg.	55.8%	45.2%	18.3%	20.2%	6.7%	10.6%	19.2%	24.0%
E1	E2	58.7%	58.7%	37.0%	26.1%	0%	0%	4.3%	15.2%
E3	43.5%	56.5%	32.6%	34.8%	19.6%	0%	4.3%	8.7%
E4	56.5%	60.9%	26.1%	32.6%	8.7%	0%	8.7%	6.5%
E5	45.7%	50.0%	50.0%	32.6%	0%	2.2%	4.3%	15.2%
Avg.	51.1%	56.5%	36.4%	31.5%	7.1%	0.6%	5.4%	11.4%
W1	W2	53.6%	19.1%	33.3%	58.3%	0%	9.5%	13.1%	13.1%
W3	57.1%	25.0%	42.9%	75.0%	0%	0%	0%	0%
W4	60.7%	11.9%	26.2%	54.9%	1.2%	21.3%	11.9%	11.9%
W5	47.6%	44.0%	40.5%	40.5%	0%	3.6%	11.9%	11.9%
Avg.	54.8%	25.0%	35.7%	57.1%	0.3%	8.6%	9.2%	9.2%
T1	T2	36.1%	36.1%	30.6%	41.7%	0%	0%	33.3%	22.2%
T3	41.7%	38.9%	25.0%	27.8%	8.3%	8.3%	25.0%	25.0%
T4	47.2%	36.1%	22.2%	33.3%	0%	0%	30.6%	30.6%
T5	50.0%	36.1%	8.3%	13.9%	2.8%	11.1%	38.9%	38.9%
Avg.	43.8%	36.8%	21.5%	29.2%	2.8%	4.9%	31.9%	29.2%

Table 4. Precision and recall of event matching results with and without the fuzzy strategy.

Src	Tgt	Precision	Recall
Fuzzy	Without fuzzy	Fuzzy	Without fuzzy
S1	S2	88.5%	88.1%	96.4%	92.9%
S3	94.9%	91.1%	94.9%	89.5%
S4	66.7%	64.7%	95.5%	71.7%
S5	58.7%	64.8%	100.0%	23.4%
Avg.	77.2%	77.2%	96.7%	69.4%
N1	N2	88.9%	68.8%	94.1%	78.6%
N3	61.1%	66.7%	84.6%	83.3%
N4	80.0%	63.2%	88.9%	80.0%
N5	71.4%	77.8%	88.2%	82.4%
Avg.	75.4%	69.1%	89.0%	81.1%
E1	E2	61.3%	69.2%	100.0%	100.0%
E3	57.1%	61.9%	69.0%	100.0%
E4	68.4%	65.1%	86.7%	100.0%
E5	47.8%	60.5%	100.0%	95.8%
Avg.	58.7%	64.2%	88.9%	99.0%
W1	W2	61.6%	24.7%	100%	66.8%
W3	57.1%	25.0%	100.0%	100.0%
W4	69.9%	17.9%	98.1%	35.7%
W5	54.2%	52.1%	100.0%	92.4%
Avg.	60.7%	29.9%	99.5%	73.7%
T1	T2	54.1%	46.4%	100.0%	100.0%
T3	62.5%	58.3%	83.4%	61.2%
T4	68.0%	52.0%	100.0%	100.0%
T5	85.8%	72.2%	94.7%	76.5%
Avg.	67.6%	57.2%	94.5%	84.4%
4.3.3. Results for RQ3
To evaluate the effectiveness of our pattern-oriented continuous workflow generation method, we assess the completeness of reused patterns and the importance of generated target workflows. Fig. 5 shows the results of behavior patterns reuse. The  and  are 88.3% and 9.2% on average, confirming that our pattern reuse method can effectively reuse behavior patterns of source apps. Besides, compared with the event matching results in Table 3, results in Fig. 5 show that the target workflow generation can supplement some unmatched events that have a counterpart to the target workflow, improving the effectiveness of behavior pattern reuse. Taking  as an example, 8.7% of source events in  do not find counterparts on  in event matching, but the proportion of completely reused patterns is 100%. This means that the unmatched source events discover their counterparts in the target app while generating target workflows. What is more, the sum of  and  of target apps belonging to the  category is 87.5%, while the sum of other categories is 100%. This is because, in the  category, there is a function represented by a user behavior pattern that does not exist in the target apps; that is, the events in the user behavior pattern have no counterparts on the target apps.

Table 5 shows the results of the state coverage on three levels of GUI model states. The average state coverage of 
, 
 and 
 are 89.1%, 71.2% and 53.0%, respectively. The decreasing relationship of the state coverage of 
, 
 and 
 indicates that the generated target workflows tend to cover states that are more likely to be accessed.


Download : Download high-res image (205KB)
Download : Download full-size image
Fig. 5. The percentage of completely reused patterns and partially reused patterns.

Overall, on average, our continuous workflow generation method completely reuses 88.3% of behavior patterns, and the generated target workflows cover 89.1% of the most important app states. Thus, according to the results, our continuous workflow generation method is effective.


Table 5. The state coverage of target workflows on three levels.

Source app	Target app	level
level
level
S1	S2	75.0%	33.3%	44.4%
S3	57.1%	45.5%	17.6%
S4	100.0%	60.0%	42.9%
S5	71.4%	66.7%	52.9%
N1	N2	100.0%	75.0%	100.0%
N3	100.0%	100.0%	100.0%
N4	100.0%	100.0%	71.4%
N5	100.0%	100.0%	42.9%
E1	E2	80.0%	42.9%	30.8%
E3	83.3%	75.0%	42.9%
E4	80.0%	42.9%	45.5%
E5	100.0%	100.0%	40.0%
W1	W2	100.0%	100.0%	85.7%
W3	80.0%	42.9%	69.2%
W4	100%	100%	60%
W5	100.0%	100.0%	45.5%
T1	T2	100.0%	50.0%	50.0%
T3	100.0%	75.0%	60.0%
T4	33.3%	75.0%	28.6%
T5	66.7%	40.0%	28.6%
Avg.	89.1%	71.2%	53.0%
4.3.4. Results for RQ4
To verify whether our approach can correctly translate the sequences of events, the human experience evaluates the behavior pattern reuse results. The feedback of the postgraduates is shown in Table 6. The results show that 61.2% of user behavior patterns are correctly transferred.

In addition, we interviewed these three postgraduates about why they think that a user behavior pattern has not been correctly reused. They consider two aspects in their judgment of incorrect reuse. On one hand, the function represented by the user behavior pattern does not exist on the target app, and on the other hand, the generated target workflow in the target app is not equivalent to the user behavior pattern in the source app. For uncertain reuse results, a part of events in the user behavior patterns are accurately reused, but the remaining events may not exist on the target apps, or they may not affect the overall behavior logics.


Table 6. The human feedback results of the correctness of user behavior patterns reuse.

Source app	User	✓	×	–
S1	User1	65.4%	25.0%	9.6%
User2	69.2%	25.0%	5.8%
User3	69.2%	25.0%	5.8%
N1	User1	70.0%	20.0%	10.0%
User2	80.0%	20.0%	0%
User3	75.0%	20.0%	5.0%
E1	User1	53.1%	46.9%	0%
User2	52.1%	40.6%	6.3%
User3	50.0%	40.6%	9.4%
W1	User1	57.1%	37.5%	5.4%
User2	57.1%	28.6%	14.3%
User3	55.4%	32.1%	12.5%
T1	User1	43.8%	53.1%	3.1%
User2	56.3%	40.6%	3.1%
User3	46.9%	50.0%	3.1%
Avg.	61.2%	33.6%	6.2%
4.4. Threats to validity
The primary external threat to the validity of our results is the generalization to other apps and categories. To mitigate this threat, we randomly select real-world apps from five different categories. The first internal threat is that our approach currently only supports three-screen events, namely clickable, long-clickable and editable events, and does not support user gestures, which feature may be considered in future work. Moreover, the second internal threat is that there may be mistakes when manually inspecting the pattern reuse results. In order to reduce the error caused by this threat, we repeatedly check the matching relation between the source event and the expected target event to improve the credibility of the results.

5. Related work
5.1. Test case reuse
Test case reuse is an important means to reduce test costs in the testing field. In general, test case reuse can be divided into two types, one is test case migration, and the other is generic test case reuse.

In test case migration, there are some studies in the Web and Android field aiming to migrate test cases between applications with similar functionality (Rau et al., 2018a, Rau et al., 2018b, Behrang and Orso, 2018b, Behrang and Orso, 2018a, Behrang and Orso, 2019, Lin et al., 2019). For example, Rau et al. (2018b) first raise a test transferring method across Web applications, which creates and leverages event mappings across different applications, and thus to transfer tests from one to another. Lin et al. (2019) propose a framework called CRAFTDROID that leverages information retrieval, along with static and dynamic analysis techniques, to extract the human knowledge from an existing test suite for one app and transfer the test cases and oracles to be used for testing other apps with the similar functionality. Moreover, Qin et al. (2019) proposes a tool called TestMig to migrate test cases from the iOS version to the Android version. TestMig executes the GUI tests of the iOS version and records their GUI event sequences. Guided by the iOS GUI events, TestMig explores the Android version of the application to generate the corresponding Android event sequences. All of these work share a common intuition that applications in the same category are implement similar functionality and user flows.

Unlike the existing research, our approach focuses on the user behavior patterns mined from real-world user traces, representing the typical functionality of similar apps, that is, the workflows that users are most likely to execute on such apps. But the migrated test cases are manually written by researchers according to specific usage scenarios. On the other hand, events involved in user behavior patterns are not necessarily continuous since the pattern only means the sequence of triggering events, while the test case must be a continuous event sequence.

In generic test case reuse, some researchers are dedicated to the reuse of generic test cases applicable to certain types of activities or functions. Moreira et al. (2013) defines several base UI test patterns and proposes a domain-specific language PARADIGM for combining test patterns with building newer ones and promoting reuse. The above works are to reuse pre-defined generic test cases, while our work is to reuse the behavior patterns of a specific app to similar apps. Rosenfeld et al. (2018) aims at relieving some of the manual functional testing burdens by automatically classifying each of the application’s screens to a set of common screen behaviors for which generic test scripts can be instantiated and reused. Hu et al. (2018) presents a system for synthesizing highly robust, highly reusable UI tests, called AppFlow. AppFlow utilizes machine learning to classify each of the app’s activities to a certain type and summarizes a set of common behaviors that can be instantiated and reused for each type of apps. It enables developers to write a library of modular tests for the main functionality of an app category, thereby tests a new app in the same category by synthesizing full tests from the modular ones in the library. Mariani et al. (2018) proposes Augusto, a test case generation technique that encodes the commonly expected semantics of application-independent functionalities (AIF) into models using Alloy (Jackson, 2002). Moreover, with the semantic models, Augusto can precisely identify AIFs and then generate complex test cases for applications under test.

5.2. Usage of user trace
In recent years, user trace is used in many test-related studies in the web field. For example, Ernst et al. (2002) focuses on data values and implements a technique named Daikon to extract models from execution traces in the form of Boolean expressions. Based on the work of Ernst et al. (2002) and Lorenzoli et al. (2008) generates an EFSM model considering both data values and component interactions which are two different aspects of application execution. Brooks and Memon (2007) leverage event sequences that users execute on the application to develop a probabilistic usage model of the application. Wang et al., 2018, Wang et al., 2019 propose a trace-based model construction approach for web applications, which represents dynamic behaviors of web applications as traces and optimize minimal traces set by the greedy algorithm. Milani Fard et al. (2014) implements a tool named 
, which mines the human knowledge present in the form of input values, event sequences, and assertions existing in manually-written test cases. Moreover, 
 leverages the human knowledge to infer a model and expand the model by exploring uncovered paths and states, finally generating new test cases. Ermuth and Pradel (2016) adopts data mining techniques, in particular frequent subsequence mining and inference of finite state machines, to infer macro events from user traces, that is, logical steps that users commonly perform. Furthermore, this work combines random test generation and macro events to generate test cases from the tested web application model.

There have been many studies on Android automated testing (Choi et al., 2013, Azim and Neamtiu, 2013, Amalfitano et al., 2014, Choudhary et al., 2015, Mahmood et al., 2014, Linares-Vásquez et al., 2017, Su et al., 2017, Yang et al., 2018, Salihu et al., 2019). But these studies do not consider the context between events, thereby are not possible to generate test case with user logic. Thus, in the Android field, research has gradually begun to introduce user trace. For example, Linares-Vásquez et al. (2015) proposes a novel approach 
 that automatically generates test cases by mining user traces and deriving language models. Inspired by crowdsourcing’s popular use in software engineering research (Ponzanelli et al., 2013, Chen and Kim, 2015, Mao et al., 2015, Wang et al., 2016, Mao et al., 2017a), Mao et al. (2017b) introduces a tool 
 which generates replicable test scripts from crowd-based testing by extracting cross-app motif events from traces that are recorded by Android  command and replayed by RERAN (Gomez et al., 2013).

Like the above work, our approach also leverages user traces of existing apps and mines frequent and reusable user behavior patterns from them to help understand other similar new apps.

6. Conclusion
To help understand a new app’s behavior quickly, in this paper, we propose a user behavior pattern mining and reuse approach across similar Android apps. In the pattern mining phase, we adopt the sequential pattern mining technique  to mine frequent patterns from real-world user traces. In the pattern reuse phase, we leverage the semantic-based event fuzzy matching strategy to match candidate events on the target app for each source event in patterns. Moreover, we further use the GUI model of the target app to supplement new events among the discontinuous ordered candidate events, thereby chaining them in series to generate the target workflow. We implement the approach and evaluate its effectiveness on 25 open source apps from five categories. The results show that the behavior patterns of source apps are correctly transferred to the target apps. And 88.3% of patterns are completely reused, and the coverage rate of the generated target workflow to the states of 
 reaches 89.1%.

In future work, we plan to introduce user gestures into our research to expand more user interactions. And our existing research results can be combined with existing Android automated testing methods to generate test cases that are more likely to be executed by users.