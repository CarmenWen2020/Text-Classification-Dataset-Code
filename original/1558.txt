Abstract
This paper introduces the notion of Constrained Locating Arrays (CLAs), mathematical objects which can be used for fault localization in software testing. CLAs extend ordinary locating arrays to make them applicable to testing of systems that have constraints on test parameters. Such constraints are common in real-world systems; thus CLA enhances the applicability of locating arrays to practical testing problems. The paper also proposes an algorithm for constructing CLAs. Experimental results show that the proposed algorithm scales to problems of practical sizes.

Previous
Next 
Keywords
Combinatorial interaction testing

Locating arrays

Covering arrays

Software testing

1. Introduction
Combinatorial interaction testing is a well-known strategy for software testing. In the strategy, a System Under Test (SUT) is modeled as a finite set of test parameters or factors and every interaction of interest is exercised by at least one test. Empirical results suggest that testing interactions involving a fairly small number of factors, typically two or three, suffices to reveal most of latent faults. Many studies have been developed to construct small test sets for combinatorial interaction testing. Such test sets are often called Covering Arrays (CAs). Surveys on these studies can be found in, for example, Colbourn, 2004, Grindal et al., 2005 and Nie and Leung (2011).

An important direction of extending the capability of combinatorial interaction testing is to add fault localization capability to it. Locating Arrays (LAs) can be used as test suites that provide this capability (Colbourn and McClary, 2008). In Colbourn and McClary (2008) LAs of a few different types are defined. For example, a -LA enables us to locate a set of  failure-triggering -way interactions using the test outcome.

The purpose of this paper is to extend the notion of LAs to expand the applicability to practical testing problems. Specifically, we propose Constrained Locating Arrays (CLAs) which can be used to detect and locate failure-triggering interactions in the presence of constraints. Constraints, which prohibit some particular tests, are common in real-world systems. Constraint handling has been well studied in the field of combinatorial interaction testing (Wu et al., 2019a). The main focus of the previous studies is on constructing test sets, often called a Constrained Covering Array (CCA), that consist only of constraint-satisfying tests and cover all interactions that can occur in constraint-satisfying tests. CLAs add the ability of fault localization to CCAs.

However, CLAs require additional considerations about constraints. Specifically, constraints may make it impossible to distinguish a failure-triggering interaction or set of such interactions from another; hence a special treatment must be needed to deal with such an inherently indistinguishable pair. By extending LAs with the concept of distinguishability, we provide the formal definition of CLAs. We also propose a generation method for CLAs and demonstrate that the generation method can scale to problems of practical sizes.

The rest of the paper is organized as follows. Section 2 describes the SUT model and the definition of locating arrays, as well as some related notions. Section 3 presents the definition of CLAs and some basic theorems about them. Section 4 presents a computational method for generating CLAs. Section 5 shows experimental results obtained by applying the method to a number of problem instances. Section 6 summarizes related work. Section 7 concludes the paper with possible future directions of work.

2. Preliminaries
2.1. SUT models, tests, and interactions
An SUT is modeled as  where 
 is a set of factors, 
 is a set of domains for the factors, and 
 is a mapping that represents constraints. Each domain 
 consists of two or more consecutive integers ranging from 0; i.e., 
 (
). A test is an element of 
. A test  is valid if and only if (iff) it satisfies the constraints , i.e.., . Given an SUT, we denote the set of all valid tests as . For a set of  factors, 
, the set 
 such that 
 for all   is a -way interaction or an interaction of strength . Hence a test contains or covers 
 -way interactions. Note that a -way interaction 
 and a test 
 can be treated interchangeably. Thus we write  iff a test  covers an interaction . It should be noted that the only 0-way is the empty set. We use , instead of , to denote the 0-way interaction.


Download : Download high-res image (408KB)
Download : Download full-size image
Fig. 1. Example of an SUT Cohen et al. (2008).

Constraints may make it impossible to test some interactions. These interactions cannot be covered by any valid tests. We call such an interaction invalid. Formally, an interaction  is valid if  for some valid test ; it is invalid, otherwise.

As a running example, consider a classic cell-phone example taken from Cohen et al. (2008) (Fig. 1). This SUT model has five factors which have three or two values in their domains. The constraints consist of seven parts. Test , for example, is valid, whereas test  is not valid (invalid) because it violates the third and fourth constraints. Similarly, two-way interaction  is valid, since it occurs in valid test . On the other hand,  is invalid, since it violates constraint 
 and thus never occurs in any valid tests.

A test suite is defined as a (possibly empty) collection of tests and thus can be represented as an  array  when the number of tests is . For such an array  and interaction , we let 
 denote the set of tests (rows) of  in which the interaction is covered. For a set of interactions , we define 
. We use  to denote an empty set of interactions. Clearly 
. (By comparison, 
 is the set of all rows of .)

An interaction is either faulty or not. A fault is an interaction that is faulty. A failure is caused by a fault: the result of executing a test  is fail iff  covers at least one faulty interaction; otherwise the result is pass. Hence the result of executing a test suite  is a vector of size , each element being either pass or fail.

2.2. Covering arrays and locating arrays
When there are no constraints, i.e.,  for any test 
, a Covering Array (CA) can be used to detect the existence of fault-triggering interactions of a given strength  or less. Let 
 be the set of all -way interactions. Formally, a -CA is defined by the following condition:

 

On the other hand, a Locating Array (LA) can be used to locate the set of faulty interactions. Colbourn and McClary introduced a total of six types of LAs in Colbourn and McClary (2008). The definitions of the two most basic types of LAs are shown below.  
 
 

The definition of other two types of LAs, namely 
-LAs and 
 
-LAs, requires the notion of independence (Colbourn and McClary, 2008). Let 
 
 be the set of all interactions of strength at most , i.e., 
 
. A set of interactions (interaction set) 
 
 is independent iff there do not exist two interactions 
 with 
. For example, consider a set of two interactions 
 
 for the running example. This interaction set is not independent because . Note that if two interactions 
 are both faulty and 
, then the failure caused by  always masks the failure caused by 
. Because of this, it is natural to limit the scope of fault localization to independent interaction sets. Based on 
 
 and the notion of independent interaction sets, the two types of LAs are defined as follows.  
 
 
 
 We do not consider the remaining two types of locating arrays, namely 
-LAs and 
 
-LAs, because they either exist in trivial cases or otherwise are equivalent to 
- and 
 
-LAs.

Fig. 2 shows a -LA for the running example shown in Fig. 1. Let  be the LA and 
 be the th row. If the pass/fail result were obtained for all these tests, any faulty single two-way interaction could be identified. For example, if only the first test 
 failed, then the faulty interaction would be determined to be , because 
 holds only for , provided that  and  for . However, this array cannot be used for testing the system because of the constraints. For example, 
 is not valid and thus cannot be executed in reality.

3. Constrained locating arrays
3.1. Definitions of CLAs
In the presence of constraints, a test suite must consist of only valid tests. From now on, we assume that an array  representing a test suite consists of a (possibly empty) set of valid tests. In practice, this problem has been circumvented by, instead of CAs, using Constrained Covering Arrays (CCAs). Let 
 be the set of all valid -way interactions. Then a CCA of strength , denoted as -CCA, is defined as follows.  
 In words, a -CCA is an array that covers all valid interactions of strength . It is easy to see that a -CCA,  is a -CCA. Therefore, the above definition is equivalent to:  
 
  Fig. 3 shows a 2-CCA for the running example.

When incorporating constraints into LA, it is crucial to take into consideration, in addition to the presence of invalid interactions, the fact that constraints may make it impossible to identify some set of faulty interactions, which could be identified if no constraints existed. This requires us the notion of distinguishability to formally define CLAs.

Definition 1

A pair of sets of valid interactions, 
 and 
, are distinguishable iff 
 for some array  consisting of valid tests.

For the running example, 
 are not distinguishable (indistinguishable), since any valid test contains either both of the two-way interactions or none of them. That is, tests that cover exactly one of the two interaction sets (e.g., (0 1 0 0 0) or (1 2 0 0 0)) are all invalid. Hence no array  exists such that 
.

It should be noted that even if there are no constraints, there can be some indistinguishable pairs of interaction sets. In the running example, two interaction sets ,  are indistinguishable even if the constraints were removed, because any test has 0 or 1 on factors 
 and 
. Another extreme case is when 
 and 
 are identical. Clearly, identical interactions are always indistinguishable.

Definition 2

Let  and . Let 
 be the set of all valid -way interactions and 
 
 be the set of all valid interactions of strength at most . An array  that consists of valid tests or no rows is a -, 
 
-, 
- or 
 
-CLA iff the corresponding condition shown below holds.  
 
 
 
 
 (In extreme cases where no two such interaction sets 
 exist, any  is a CLA.)

The intuition of the definition is that if the SUT has a set of  (or ) faulty interactions, then the test outcome obtained by executing all tests in  will be different from the one that would be obtained when the SUT had a different set of  (or ) faulty interactions, unless the two interaction sets are not distinguishable.

The algorithm to identify faulty interactions is directly obtained from the definition. Given a (
 
, 
)-CLA , for example, the algorithm amounts to checking, for each independent 
 
 such that , if 
 is equal to the set of failed tests. When the assumptions about the number () and strength () of faulty interactions hold,  that satisfies the condition is either (1) the set of faulty interactions or (2) a set of interactions that is indistinguishable from the former.

3.2. Examples of CLAs
Here we show (1, 1)-, 
 
-, 
 
- and 
 
 
-CLAs for the running SUT example. Figs. 4, 5, Fig. 6, Fig. 7 respectively show these CLAs. The sizes (i.e., the number of rows) of these arrays are 5, 12, 15 and 28. The number of valid tests for the running example is 31; thus these CLAs, except the 
 
 
-CLA, are considerably smaller than the array that consists of all valid tests. On the other hand, the 
 
 
-CLA is almost as large as the exhaustive one. The three missing valid tests are (0, 2, 1, 0, 1), (0, 2, 1, 1, 1) and (1, 1, 1, 1, 1).

One can verify that these are indeed CLAs by checking the necessary and sufficient conditions using the facts shown below. For the running example, all interactions of strength  are valid, except ten two-way interactions listed below.  
 For the example, all pairs 
 such that 
 and 
 are distinguishable. That is, any pair of distinct one-way interactions are distinguishable. Fig. 8 shows pairs of interaction sets that are not distinguishable for the other parameters 
 
.

First let us assume that the faulty interaction is 
. When the 2-CCA is used as a test suite, 
 is the only test that fails. This test outcome is identical to when another interaction 
, instead of 
, is faulty. As a result, it is impossible to determine which one of the two interactions is faulty from the test outcome. In contrast, when the 
 
-CLA is used, failing tests are different between 
 and any other two-way interaction. For example, only 
 fails when 
 is faulty, whereas 
 fails when 
 is faulty. Hence, it can be safely concluded that the faulty interaction is 
. By definition, 
 
-CLAs ensure accurate fault detection unless there is an interaction that is different but indistinguishable from the faulty one.

Now consider 
 and 
 which are indistinguishable from each other. When the 
 
-CLA is used as a test suite, the failing tests will be 
, 
, and 
 whenever either one of the two interactions is faulty. However, this test outcome never occurs if another interaction that is distinguishable from 
 is faulty. In general, CLAs guarantee that the test outcome is always different between a pair of interaction sets that are distinguishable. On the other hand, CCAs provide no such guarantee. For example, when the 2-CCA is used, 
 and 
 fail if 
 or 
 is faulty. This test outcome also arises when  is faulty; thus it is not possible to narrow down the candidates for the fault to 
 and 
.

3.3. Properties of CLAs
The following observation follows from the definition.

Observation 1

A 
 
-CLA is a 
 
- and 
-CLA. A 
 
-CLA and a 
-CLA are both a -CLA. A 
 
-CLA and a 
 
-CLA are a 
 
-CLA and a 
 
-CLA, respectively. A 
 
-CLA and a 
-CLA are a 
 
 
-CLA and a 
 
-CLA, respectively.

Observation 2 states that when there are no constraints, an LA, if existing, and a CLA are equivalent.

Observation 2

Suppose that the SUT has no constraints, i.e.,  for all 
, and that an LA  exists (with any parameters of 
). Then (1)  is a CLA with the same parameters, and (2) any CLA with the same parameters as  is an LA (which is possibly different from ) with the same parameters.

Proof

Suppose that  is a -LA. Let 
 be any two interaction sets such that 
. (1) If 
, then 
. If 
, then they are not distinguishable. Hence  is a -CLA. (2) Suppose that an array 
 is a -CLA. If 
, then 
 and thus they are distinguishable, which in turn implies 
. If 
, then they are not distinguishable and trivially 
. Hence 
 is a -LA. The same argument applies to the other three types of LAs.  □

It should be noted that LAs do not always exist and that the above observation claims the equivalence of an LA and a CLA only if the LA actually exists. On the other hand, CLAs always exist whether there are constraints or not, as will be shown in Theorem 1. For example, no -LAs exist for the running example: Consider 
 and 
. Then 
 and 
 both include all rows; thus 
 for any . The guarantee of the existence of CLAs comes from the definition which exempts indistinguishable pairs of interaction sets from fault localization. The example above illustrates that when 
. The definition of -LAs does not hold for any  array for the SUT. Because 
 and 
 are always indistinguishable and the existence of indistinguishable interaction set pairs violates the definition of -LAs. In contrast, CLAs permit the existence of indistinguishable interaction set pairs, and only distinguish interaction pairs that are distinguishable. Hence, -CLAs exist for the SUT while -LAs do not exist. In that sense, CLAs can be viewed as a “best effort” variant of LAs.

Lemma 1

A pair of sets of valid interactions, 
 and 
, are distinguishable iff there is a valid test that covers some interaction in 
 or 
 but no interactions in 
 or 
, respectively, i.e., for some valid test , 
 or 
.

Proof

(If part) Suppose that there is such a valid test . Consider an array  that contains . Then, either 
 or 
; thus 
. (Only if part) Suppose that there is no such valid test, i.e., for every valid test , 
 and 
. This means that for every valid test , 
 or 
. Hence for any test  in , 
 or 
. As a result, for any , 
.  □

Theorem 1

If  is an array consisting of all valid tests, then  is a -, 
-, 
 
- and 
 
-CLA for any  and .

Proof

Let 
 and 
 be any interaction sets that are distinguishable. By Lemma 1, a valid test  exists such that 
 or 
. Since  contains this test and by the same argument of the proof of the if-part of Lemma 1, 
.  □

Although Theorem 1 guarantees that a test suite consisting of all valid tests is a CLA, it is desirable to use a smaller test suite in practice. In Section 4, we present a computational method for generating small CLAs.

4. Computational generation of 
 
-CLAs
In this and next sections, we focus our attention on generation of 
 
-CLAs for practical reasons as follows. As demonstrated in the previous section, when the value of  (or 
 
) exceeds one, the size of CLAs may become substantially larger than -CCAs, offsetting the very benefit of combinatorial interaction testing. Also, practical test suites must distinguish the situation where no fault exists from that where some hypothesized fault occurs; thus we consider 
 
-CLAs, instead of 
-CLAs.

In this section, we propose an algorithm for generating 
 
-CLAs. Although not much research exists on generation of LAs, there has already been a large body of research on CCA generation in the combinatorial interaction testing field. The idea of the proposed algorithm is to make use of an existing CCA generation algorithm to generate 
 
-CLAs. This becomes possible by the theorem shown in Section 4.1, which proves that any -CCA is a 
 
-CLA. This result allows us to use a two-step approach as follows:

Step 1.
A -CCA is generated using an off-the-shelf algorithm.

Step 2.
A 
 
-CLA is obtained by removing redundant tests from the -CCA.

4.1. Theoretical results
Theorem 2

Let  be an integer such that . If an  array  is a -CCA, then  is also a 
 
-CLA.

Proof

By Definition 2, an array  is a 
 
-CLA iff 
 for all 
 
 such that 
, 
, and 
 and 
 are distinguishable. Now suppose that an  array  is a -CCA such that . If 
, then 
 and thus they are not distinguishable. If 
 and 
, then 
 because  is a -CCA and thus any 
 
 is covered by some row in . Since 
, 
 holds for any 
, 
 
 if 
 and 
. The same argument clearly holds if 
 and 
.

In the rest of the proof, we consider the case in which 
 and 
. We will show that 
 (i.e.
) always holds for any 
 
 if 
 and 
 are distinguishable. Let 
 and 
 (). Also let 
; i.e.,  is the set of factors that are involved in both interactions. There are two cases to consider.

(1)
For some 
. That is, the two interactions have different values on some factor 
. In this case, 
 and 
 never occur in the same test. Since  is a -CCA, 
 and 
. Hence, 
.

(2)
 or for all 
. That is, the two interactions have no common factors or have the same value for every factor in common. Since 
 and 
 are distinguishable, there must be at least one valid test  in  that covers either 
 or 
 but not both. Suppose that  covers 
 but does not cover 
. In this case, there is a factor 
 such that the value on 
 of , denoted 
, is different from 
, because otherwise 
 were covered by . Now consider a -way interaction 
. Since the valid test  covers 
, 
 is a -way valid interaction. Since  is a -CCA and ,  contains at least one row that covers 
. This row covers 
 but does not cover 
 because the value on 
 is 
 and 
. Hence, 
. The same argument applies to the case in which  covers 
 but not 

As a result, 
 holds for any 
, 
 
 if 
 and they are distinguishable.  □

This theorem, namely, Theorem 2 can be viewed as a variant of Theorem 8.5 of Colbourn and McClary (2008), where it is proved, among other things, that a -CA is a 
 
-LA. Theorem 2 shows that a -CCA is already a 
 
-CLA. However, -CCAs usually contain tests that are not needed to form 
 
-CLAs; thus such redundant tests should be removed to obtain small 
 
-CLAs.

Theorem 3 below proves that a 
 
-CLA and a 
 
-CLA are equivalent. This property is useful for checking whether the test is redundant or not. With this property, a test can be determined to be redundant if its removal does not invalidate the condition required for the array to be a 
 
-CLA, instead of a 
 
-CLA. This simplifies the check because we can restrict the interactions to be considered to those in 
, instead of 
 
.

Lemma 2

Suppose that an  array  is a 
 
-CLA such that . Then  is a -CCA.

Proof

Since  is a 
 
-CLA, 
 for any 
 such that 
. Hence, if 
 and 
 for any 
, then 
.  □

Theorem 3

If an  array  is a 
 
-CLA such that , then  is a 
 
-CLA.

Proof

Suppose that  is a 
 
-CLA such that . By Lemma 2,  is a -CCA; thus, by Theorem 2, it is a 
 
 
-CLA. Recall that  is a 
 
-CLA iff 
 for all 
 
 such that 
 and 
 are distinguishable and 
. (Note that 
 and 
 are trivially independent.) If 
, then 
 and 
 are both  and thus indistinguishable. If 
 and 
, then 
 for some 
 
. Since  is a -CCA, 
 for any 
 
. Therefore 
. Clearly this argument holds when 
 and 
.

In the following part of the proof, we assume that 
. Let 
, 
 where 
 
. Without losing generality, we assume that the strength of 
 is at most equal to that of 
, i.e., 
. If 
 and 
 and 
 are distinguishable, then 
 since  is a 
 
 
-CLA. If 
 and 
 and 
 are distinguishable, then 
 since  is a 
 
-CLA.

Now consider the remaining case where 
. Assume that 
 and 
 are distinguishable. Below we show that 
 under this assumption. Because of the assumption, at least either one of the following two cases holds: Case 1: for some , 
 and 
, or Case 2: for some , 
 and 
.

Let 
 and 
 (). Also let 
; i.e.,  is the set of factors that are involved in both interactions.

Case 1: Let 
 be any test in  such that 
 and 
. Choose a factor 
,  such that the value on 
 in 
 is different from 
. Such a factor must always exist, because otherwise 
. Let 
 denote the value on 
 in 
. Then interaction 
 is covered by 
 (
) and thus is valid. The strength of 
 is  (if 
, in which case 
) or  (if 
). For any test , 
 holds because 
. Since  is a -CCA and the strength of 
 is at most ,  has a row that covers 
. This row covers 
 but not 
; thus 
.

Case 2: Let 
 be any test in  such that 
 and 
. Also let 
 be any -way interaction such that 
, , 
 for some 
. In other words, 
 is a -way interaction that is obtained by extending 
 with some  factor-value pairs in 
.

If 
 is valid, then 
 and 
 are distinguishable, because 
 and 
 (since 
 and 
).  is a 
 
-CLA; thus  must have a row  that covers either 
 or 
; i.e., 
 or 
. 
 directly implies 
, while 
 implies 
, which means 
. Hence 
.

If 
 is not valid, then we can show that 
 and 
 never appear simultaneously in any test  as follows. If there is some test  in  in which 
 and 
 are both covered, then 
 is also covered by some tests (including ) in ; i.e., 
 is valid. The contraposition of this argument is that if 
 is invalid, then there is no test in  that covers 
 and 
. Since  is a -CCA and 
 
, 
 and 
. Hence 
.  □

4.2. Algorithm


Download : Download high-res image (240KB)
Download : Download full-size image
Algorithm 1 is the proposed algorithm for generating 
 
-CLAs. The algorithm takes an SUT model  and strength  as input and finally returns a 
 
-CLA . This algorithm is a heuristic algorithm because it does not guarantee that the output CLA is optimal in size. Indeed, the resulting CLAs can vary for different runs.

In the first line of the algorithm, the function generateCCA() uses an existing algorithm to generate a -CCA. Then the function getAllInteractions() is called to enumerate all -way interactions the -CCA contains. The interactions obtained are the set of all valid -way interactions (i.e., 
), because all interactions occurring in a CCA are valid and any -CCA contains all -way valid interactions. Once all the valid -way interactions have been collected, we compute a mapping  that maps each of them to the set of rows of  that cover it; that is, 
 where 
.

In each iteration of the for loop, a row  is randomly chosen from . Then we compute 
 which is a mapping such that 
. In other words, 
 is 
 where 
 is the array obtained from  by removing  from it. The function updateMap() is used to obtain 
. Also we enumerate all -way interactions that are covered by . The set of these interactions is represented by .

In each iteration of the loop, we check whether  can be removed or not. The row can be removed if  remains to be a 
 
-CLA (equivalently, 
 
-CLA) after the removal. This check is performed by checking two conditions.

One condition is that every valid -way interaction  still has some row that covers it; i.e., 
. The condition holds if and only if 
 holds when 
 and 
, since 
 implies 
 which in turn implies 
.

The other condition corresponds to the case 
: The condition is that for every pair of valid, mutually distinguishable -way interactions, they still have different sets of rows in which they are covered. In other words, for 
, if 
 and 
 are distinguishable, then 
 (i.e., 
). Note that 
 and 
 are distinguishable iff 
 (i.e., 
), since  is a 
 
-CLA.

Clearly, if an interaction  is not covered by , the deletion of  does not alter the set of rows that cover . Hence checking of the first condition can be performed by examining only the interactions covered by , i.e., those in , instead of all interactions in 
. The same is true for checking of the second condition: it can be performed by checking each pair of an interaction 
 in  and another interaction 
.

The loop is iterated until all rows in the initial  have been examined. Finally, the resulting  becomes a 
 
-CLA of reduced size.

As stated above, output 
 
-CLAs vary for different runs of the algorithm, even if the initial  (i.e., the -CCA generated in line 1) is identical for all runs. This is because the 
 
-CLAs finally obtained depends also on the order of deleting rows.

For example, suppose that there are only three valid -way interactions 
 and 
 and that 
, 
, 
 are distinguishable with each other. Also suppose that after mapping each interaction to rows, we have 
 and 
. If the order of deleting rows is , rows 1 and 2 are deleted but rows 3, 4 and 5 are not. This is because after deleting rows 1 and 2, the mapping becomes: 
 and 
; thus any further deletion of rows would make some interaction lose all its covering rows or make identical the sets of covering rows for some pair of interactions. However, if the deleting order is , rows 5, 3 and 2 are deleted. The deleting order of rows thus influences the sizes of resulting CLAs.

Fig. 9 shows concrete examples of different CLAs obtained from the same CCA. Specifically, the two 
 
 
-CLAs in this figure were generated from the 2-CCA shown in Fig. 3. For the CLA on the left, the deleting order was  
 
   
   
 
   
   
 
   
  
   
 
   
   
 
   
, whereas the order was  
 
    
 
    
 
   
   
 
   
   
 
    
 
   
  
  
 for the CLA on the right. (The rows deleted are underlined.)

5. Evaluation
5.1. Experiment 1: Generation of CLAs with strength 
In this section, the proposed generation algorithm is evaluated. Here, we focus on the case , i.e., the generation of 
 
 
-CLAs. The evaluation is performed with respect to two criteria: generation time and sizes (the number of rows) of CLAs. For comparison, we choose a generation algorithm based on an SMT (Satisfiability Modulo Theories) solver which we have proposed in Jin et al. (2018), because, to our knowledge, there does not exist another method that generates CLAs.

5.1.1. SMT-based generation algorithm
The SMT-based generation algorithm can be regarded as an adaptation of constraint solving-based methods for generating CCAs (Nanba et al., 2012, Banbara et al., 2010) or LAs (Konishi et al., 2017, Konishi et al., 2020a). In this algorithm, the necessary and sufficient conditions for the existence of a 
 
-CLA (which is equivalent to a 
 
-CLA) of a given size  are encoded into a conjunction of logic expressions. Then, the algorithm uses an SMT solver to find a satisfiable valuation of variables of the logic expressions. If a satisfiable valuation is found, then it can be interpreted as a CLA. On the other hand, if there is no satisfiable valuation, then the non-existence of a CLA of size  can be concluded.

In the encoding of the conditions of a CLA, each cell of the array is represented as a variable; thus the array is encoded as a set of  variables. According to the definition of 
 
-CLAs (see Definition 2), three sets of logic expressions are needed. One of the three sets enforces that all rows of the array satisfy all of the SUT constraints. Another one is used to guarantee that each valid -way interaction is covered by at least one row. This ensures that for every 
, 
. The last one enforces that for every pair of valid -way interactions, 
, if 
 and 
 are mutually distinguishable, there is at least one row covering only one interaction of the pair, i.e., 
.

In our experiments, if a 
 
 
-CLA is successfully generated within a timeout period, we will decrease  by 1 and repeats runs of the algorithm until the SMT solver proves the non-existence of CLAs of size . If a run of the algorithm fails to terminate within the timeout period, the repetition is stopped.

5.1.2. Research questions and experiment settings
We pose several research questions as follows for better understanding of experimental results.

RQ 1

How does the proposed algorithm perform with respect to generation time and sizes for generated CLAs?

RQ 2

How different is the performance between the proposed algorithm and the SMT-based algorithm?

RQ 3

Does the proposed algorithm scale to real-world problems?

We performed experiments where we applied both algorithms to a total of 30 problem instances, numbered from 1 to 30. Benchmarks No.1–5 are provided as part of the CitLab tool (Gargantini and Vavassori, 2012). Benchmarks No.6–25 can be found in Segall et al. (2011). Large benchmarks, namely, benchmarks No.26–30 are taken from Cohen et al. (2008). For each problem instance the proposed algorithm was executed 10 times, as it is a nondeterministic algorithm. On the other hand, the SMT-based algorithm was run only once, since it is deterministic. The initial value of  for the SMT-based algorithm was set to the size of the smallest CLAs among those obtained by the 10 runs of the proposed algorithm. This favors the SMT-based algorithm, since it ensures that the output CLA of the SMT-based algorithm is never greater in size than those obtained by the proposed heuristic algorithm.

All the experiments were conducted on a machine with 3.2 GHz 8-Core Intel Xeon W CPU and 128 GB memory, running MacOS Mojave. We wrote a C++ program that implements the proposed algorithm. The CIT-BACH tool 1 was used as a 3-way CCA generator. The implementation of the SMT-based algorithm was done using C. The Yices SMT solver (Dutertre, 2014) was used in this implementation. The timeout period was set to 1 h for every run of both algorithms.

The results of the experiments are shown in Table 1. The two leftmost columns of the table show the benchmark IDs and names. The third and fourth columns show the number of factors and the number of valid two-way interactions for each benchmark. The fifth column, marked with an asterisk (*), shows the number of unordered pairs 
 such that 
 and 
 are indistinguishable.

The remaining part of the table is divided into two parts: one for the proposed algorithm and the other for the SMT-based generation algorithm. In the proposed algorithm part, the left three columns show the maximum, minimum, and average sizes of the generated 
 
 
-CLAs. In the column labeled “Average (3-CCA)”, the figures in parentheses indicate the sizes of the 3-way CCAs generated by generateCCA() on Line 1 in Algorithm 1. The next three columns indicate the maximum, minimum, and average running times. The running time is the sum of the time used for generating 3-way CCAs and the time used for deleting redundant rows from those 3-way CCAs. The unit is seconds.

The two rightmost columns show the results of the SMT-based algorithm. They show, for each problem instance, the size of the smallest CLA obtained and the running time taken by the algorithm to produce that CLA. (Thus, the running time does not include the running time of runs with 
 and 
, where  is the given size of an array and 
 denotes the size of the smallest CLA.) As stated above, the algorithm was iterated with decreasing  until it failed to solve the problem within the timeout period or proves the nonexistence of a CLA of size . In the latter case, the CLA obtained in the immediately previous iteration is guaranteed to be optimal in size. The figures in bold font show the sizes of these optimal 
 
 
-CLAs. The “T.O.” marks indicate that even the first iteration with the initial  was not completed because of timeout.

The experimental results of the comparison on generation time and CLA sizes between different strength  is shown in Table 2. The first column in the table shows the benchmark IDs. The detailed system structure can be found in Table 1. In addition to the generation experiments for 
 
 
-CLAs, we applied our proposed method for the generation of 
 
 
-CLAs. The columns labeled “” indicate the strength  of the generated CLA. As same as Table 1, the columns labeled “
” show the numbers of valid -way interactions that benchmarks have. The column labeled “*” show the number of unordered pairs of interactions which are mutually indistinguishable. The generation for both 
 
 
-CLAs and 
 
 
-CLAs are repeated 10 times. The average generation time and the average sizes of the generated CLAs are shown in columns “average – time” and “average – size”, respectively. Note that all experiments are set a timeout period as 1 h. The experiment data with “T.O.” indicates that the corresponding execution did not finish within 1 h. The experiment data with “–” indicates that the ()-CCAs for the systems cannot be constructed because  exceeds the number of parameters in the system.

5.1.3. Experimental results
Answer to RQ 1.
The proposed heuristic algorithm was able to find CLAs for all the benchmarks. The running time was even less than one second for many of these. Except for the two largest problem instances, it was at most 90 s. The two exceptional instances are Apache and GCC, both having nearly 200 factors. Even for these large benchmarks, the algorithm terminated, successfully producing CLAs within the one hour time limit. The proposed algorithm was able to generate CLAs that are considerably smaller than the initial CCAs. The reduction rate varies for different problem instances; but it was greater than 50% for many of the problems. Even a more than five-fold reduction was observed for some benchmarks, namely, Insurance (No. 14), NetworkMgmt (No. 15), Services (No. 18), Storage4 (No. 22), and Storage5 (No. 23). In summary, the proposed heuristic algorithm is able to generate CLAs within a reasonable time unless the problem is not very large. The sizes of CLAs produced by the algorithm are substantially smaller than the initial 3-CCAs.


Table 1. Experimental results that compare CLA sizes and running times between the proposed heuristic algorithm and the SMT-based algorithm.

No.	SUT		
*	Proposed method	SMT based method
 
 
-CLA sizes	Time (s)	
 
 
-CLA	Time (s)
Max	Min	Average(3-CCA)	Max	Min	Average
1	Aircraft	11	180	54	17	15	16.3 (23.6)	0.28	0.13	0.15	13	25.60
2	Car	9	102	161	10	10	10.0 (12.2)	0.13	0.12	0.12	10	0.07
3	Movie	13	178	567	9	8	8.4 (11.2)	0.14	0.14	0.14	8	0.07
4	Medicitries	3	41	0	25	23	24.3 (41.0)	0.11	0.10	0.10	23	0.98
5	Medicitries_small	3	58	1	35	32	33.4 (70.0)	0.12	0.10	0.11	30	47.70
6	Banking1	5	102	0	28	25	26.7 (61.3)	0.14	0.13	0.14	23	913.41
7	Banking2	15	473	0	30	27	27.5 (41.2)	0.17	0.17	0.17	T.O.	T.O.
8	Concurrency	5	36	16	7	7	7.0 (8.0)	0.11	0.10	0.10	7	0.01
9	CommProtocol	11	285	69	35	33	34.0 (54.6)	0.19	0.18	0.18	T.O.	T.O.
10	Healthcare1	10	361	5	50	45	48.2 (125.1)	0.21	0.19	0.20	42	3438.74
11	Healthcare2	12	466	0	36	33	34.9 (76.8)	0.21	0.20	0.20	T.O.	T.O.
12	Healthcare3	29	3092	477	101	77	91.9 (251.4)	4.59	4.03	4.38	T.O.	T.O.
13	Healthcare4	35	5707	288	105	98	101.7 (379.3)	21.59	20.34	20.85	T.O.	T.O.
14	Insurance	14	4573	0	805	789	794.2 (7325.3)	84.94	83.63	84.34	T.O.	T.O.
15	NetworkMgmt	9	1228	0	210	202	207.2 (1199.8)	1.89	1.84	1.86	T.O.	T.O.
16	ProcessorComm1	15	1058	6	63	58	59.9 (164.6)	0.62	0.56	0.59	T.O.	T.O.
17	ProcessorComm2	25	2525	1562	68	65	66.8 (200.3)	2.14	1.99	2.04	T.O.	T.O.
18	Services	13	1819	93	200	194	197.0 (1258.6)	4.70	4.52	4.62	T.O.	T.O.
19	Storage1	4	53	11	22	22	22.0 (25.0)	0.12	0.11	0.11	22	70.63
20	Storage2	5	126	0	37	34	35.9 (78.2)	0.12	0.11	0.12	30	564.92
21	Storage3	15	1020	57	89	87	87.5 (269.4)	0.81	0.75	0.77	T.O.	T.O.
22	Storage4	20	3491	0	222	215	218.6 (1183.1)	15.57	14.92	15.30	T.O.	T.O.
23	Storage5	23	5342	20	361	344	355.7 (2137.5)	56.71	55.82	56.18	T.O.	T.O.
24	SystemMgmt	10	310	130	31	27	29.0 (66.8)	0.17	0.15	0.16	T.O.	T.O.
25	Telecom	10	440	23	54	49	51.5 (144.5)	0.24	0.22	0.22	T.O.	T.O.
26	Apache	172	66,927	0	89	85	86.6 (232.4)	3350.32	3138.48	3263.15	T.O.	T.O.
27	Bugzilla	52	5818	0	48	41	45.3 (80.8)	9.80	7.98	9.02	T.O.	T.O.
28	GCC	199	82,770	46	68	61	64.4 (128.8)	2618.84	2286.57	2494.59	T.O.	T.O.
29	Spins	18	979	9	53	49	50.7 (136.3)	0.64	0.61	0.63	T.O.	T.O.
30	Spinv	55	8741	599	97	91	93.2 (321.4)	59.99	56.37	58.21	T.O.	T.O.
Answer to RQ 2.
When comparing the running times between both algorithms, the proposed algorithm shows distinguishing results. For all benchmarks except Car, Movie, Concurrency, the proposed algorithm achieved orders of magnitude reduction. The SMT-based algorithm often timed out even for the benchmarks that the proposed algorithm solved in less than one second. The difference can be explained as follows. To generate a CLA, the SMT-based algorithm needs to solve a constraint satisfaction problem represented by logic expressions. This problem can be very difficult to solve, especially when the given number of rows, , approaches to the lower limit of the size of CLAs. On the other hand, the proposed heuristic simply repeats the check-and-delete process until all rows are examined. In the experiments, as stated above, we set the initial  of the SMT-based algorithm to the size of the smallest CLA obtained by 10 runs of the proposed heuristic algorithm. Hence the sizes of the CLAs generated by the SMT-based algorithm were guaranteed not to exceed those generated by the proposed heuristic algorithm. The experimental results show that the SMT-based algorithm was often successful in further decreasing the sizes of CLAs by, typically, a few rows. This also suggests that the proposed algorithm rarely produces the minimum (optimal) CLAs. One possible reason for this is that 3-way CCAs generated by generateCCA() may not be a superset of any of the optimal CLAs. Another reason is that resulting CLAs depends on the order of deleting rows. As there are a number of deleting orders, it can be unlikely that the one that leads to the optimal CLA, if any, is selected. In summary, the proposed heuristic algorithm runs much faster than does the SMT-based algorithm. If the problem is small enough for the SMT-based algorithm to handle, the algorithm is superior in yielding small CLAs to the proposed heuristic algorithm.

Answer to RQ 3.
As stated, the proposed algorithm was able to produce CLAs in very short time for many problem instances. Even for very large benchmarks, namely, Apache and GCC, it completed generation of CLAs within one hour. These benchmarks are model taken from the real-world applications. Hence we conclude that, although further improvement is still desirable, the proposed algorithm can scale to real-world problems.

5.2. Experiment 2: Generation of CLAs of strength 
The results of Experiment 1 showed that the proposed CLA generation algorithm can scale to large problems when thestrength  of CLAs is two. Now we examine its scalability with respect to strength by posing the following research question.


Table 2. Experimental results that compare average (
 
)-CLA sizes and running times of the proposed algorithm with different strength .

No.		
*	Average	No.		
*	Average
Time	Size	Time	Size
1	2	180	54	0.15	16.3	16	2	1058	6	0.59	59.9
3	961	438	0.29	39.3	3	14,229	231	81.57	279.1
4	3376	2109	1.25	85.1	4	130,725	4023	T.O.	T.O.
2	2	102	161	0.12	10.0	17	2	2525	1562	2.04	66.8
3	346	1590	0.16	13.0	3	53,228	67,926	738.57	332.0
4	701	6373	0.23	13.0	4	T.O.	T.O.	T.O.	T.O.
3	2	178	567	0.14	8.4	18	2	1819	93	4.62	197.0
3	934	7489	0.28	13.0	3	30,031	4313	1278.08	1626.2
4	3228	56,638	1.35	20.8	4	T.O.	T.O.	T.O.	T.O.
4	2	41	0	0.10	24.3	19	2	53	11	0.11	22.0
3	–	–	–	–	3	71	43	0.14	23.0
4	–	–	–	–	4	–	–	–	–
5	2	58	1	0.11	33.4	20	2	126	0	0.12	35.9
3	–	–	–	–	3	432	0	0.22	116.3
4	–	–	–	–	4	729	0	0.31	304.5
6	2	102	0	0.14	36.7	21	2	1020	57	0.77	87.5
3	324	0	0.18	81.2	3	11,840	1212	61.72	396.5
4	513	104	0.21	176.4	4	89,623	13,982	3145.79	1417.4
7	2	473	0	0.17	27.5	22	2	3491	0	15.30	218.6
3	4290	0	2.84	81.2	3	86,153	0	T.O.	T.O.
4	26,728	0	109.00	199.3	4	T.O.	T.O.	T.O.	T.O.
8	2	38	16	0.10	7.0	23	2	5342	20	56.18	355.7
3	55	90	0.10	8.0	3	157,950	1908	T.O.	T.O.
4	35	46	0.10	8.0	4	T.O.	T.O.	T.O.	T.O.
9	2	285	69	0.18	34.0	24	2	310	130	0.16	29.0
3	1650	1221	0.68	79.9	3	1982	1591	0.73	88.6
4	5978	9338	3.90	147.0	4	7770	10,227	5.12	216.8
10	2	361	5	0.20	48.2	25	2	440	23	0.22	51.5
3	2535	118	2.25	190.5	3	3431	225	3.76	208.7
4	11,102	1151	27.32	567.6	4	16,841	1246	66.62	688.5
11	2	466	0	0.20	34.9	26	2	66,927	0	3263.15	86.6
3	4076	6	4.78	127.4	3	T.O.	T.O.	T.O.	T.O.
4	23,792	183	166.26	416.7	4	T.O.	T.O.	T.O.	T.O.
12	2	3092	477	4.38	91.9	27	2	5818	0	9.02	45.3
3	74,274	18,460	3051.87	484.6	3	202,683	24	T.O.	T.O.
4	T.O.	T.O.	T.O.	T.O.	4	T.O.	T.O.	T.O.	T.O.
13	2	5707	288	20.85	101.7	28	2	82,770	46	2494.59	64.4
3	191,398	13,378	T.O.	T.O.	3	T.O.	T.O.	T.O.	T.O.
4	T.O.	T.O.	T.O.	T.O.	4	T.O.	T.O.	T.O.	T.O.
14	2	4573	0	84.34	794.2	29	2	979	9	0.63	50.7
3	T.O.	T.O.	T.O.	T.O.	3	12,835	355	86.76	220.0
4	T.O.	T.O.	T.O.	T.O.	4	116,332	6436	T.O.	T.O.
15	2	1228	0	1.86	207.2	30	2	8741	599	58.21	93.2
3	15,370	1	203.995	1664.6	3	T.O.	T.O.	T.O.	T.O.
4	116,350	40	T.O.	T.O.	4	T.O.	T.O.	T.O.	T.O.
RQ 4

How does the proposed algorithm perform when the strength  of CLAs is relatively large ()?

We applied the proposed algorithm to 28 and 27 of the 30 benchmark problems to create (
 
)-CLAs with strength  and , respectively. The three problems, namely No. 4, No. 5, and No. 19, are excluded because they consist only of three or four factors.

As in Experiment 1, we ran the proposed algorithm 10 times for each problem. Table 2 summarizes the results of this experiment, including those obtained for  in Experiment 1. As in Table 1, the columns marked with “
” and “*” show respectively the number of valid interactions of strength  and the number of pairs of indistinguishable valid interactions of strength . The columns labeled with “average” show the running time of the proposed algorithm and the size of obtained CLAs averaged over 10 runs.

From Table 2, it is seen that the size of generated CLAs and the generation time increased exponentially when the strength increased. For all benchmarks, the speed of growth in size was much slower than the speed of growth in generation time. With the one hour timeout, there were eight benchmark problems for which our algorithm ran out of time while generating (
 
 
)-CLAs. Our proposed algorithm also failed to generate (
 
 
)-CLAs for 14 benchmarks.

For large problems, the algorithm already failed to enumerate valid interactions. For example, for No 26, No 28, and No. 30, enumeration was not completed when . Even when valid interactions have been enumerated, if the number of these interactions was large, CDA generation was not completed within the timeout period.

Answer to RQ 4.
The proposed algorithm is able to handle high strength  when the problem is not large. To handle large problems, further improvement in algorithm performance is needed.

Finally we note an interesting finding about the number of valid interactions. For benchmark No. 8, the number of valid -way interactions is smaller than the number of valid -way interactions. This would never happen when there were no constraints. In such an exceptional case, higher strength does not necessarily mean larger computation time. In fact, for this problem, the computation time did not vary much for differentstrengths.

5.3. Experiment 3: Applying CLA-based test cases to actual programs
In the third experiment, we examine CLAs with respect to the capability of identifying faulty interactions induced by real software bugs. By definition, CLAs ensure that faulty interactions can be located if underlying assumptions hold. Specifically, (
 
)-CLAs allow any faulty interaction to be located if the strength of the interaction is at most  and there is no other faulty interaction. However, these assumptions may not necessarily hold in reality. The aim of this experiment is to answer the following research question.

RQ 5

Can CLAs be used to detect faulty interactions caused by actual bugs, especially when the assumptions about the number and strength of faulty interactions do not hold?

The procedure of the experiment is as follows:

Step 1
Construct SUT models for applications under test.

Step 2
Seed bugs to the source code of the application programs to create a collection of faulty versions of the programs.

Step 3
Use exhaustive testing to identify faulty interactions that are caused by the seeded bugs. The identified faulty interactions are used as correct answers.

Step 4
Use CLAs to select test cases and locate (or estimate) faulty interactions using these test cases.

Step 5
Compare the results obtained from CLAs with the correct answers.

In the experiments, we set the parameters of CLAs, i.e.,  and , as  and .

5.3.1. Experimental setting
We chose Flex 2 and Gzip 3 as applications under test and obtained their source code from Software-artifact Infrastructure Repository (SIR) (Do et al., 2005) at the University of Nebraska–Lincoln. At SIR each of the programs is associated with a test specification file written in the Extended Test Specification Language (Ostrand and Balcer, 1988). Test specification files describe all of the options and patterns of the inputs to be tested, together with the requirements and specifications among the options. SIR also provides the whole testing environment for these programs, which encompasses a bug seeding facility, verified input–output sets, and a tool chain including an automatic test script generation tool.

Petke et al. analyzed the test specification files of the two applications and provided the SUT models with constraints (Petke et al., 2015). We used their SUT models in this experiment.

We used the bug seeding facility provided by SIR to seed bugs into Flex and Gzip. Exactly one bug was seeded in a single version of the programs.

Exhaustive testing was conducted for each application as follows. First, we constructed a CCA whose strength is equal to the total number of factors for the SUT model of the application. This CCA represents the exhaustive test suite, because it consists of all valid tests. Then, we created test scripts from the CCA and applied them to faulty versions of the application.

From the test outcome, faulty interactions were identified as follows. We computed a minimal set of interactions such that (1) every interaction in the set occurs in some of the failed tests but not in any of the passed tests and (2) every failed test contains at least one interaction in the set. Here we say that the set is minimal if no smaller set satisfies these conditions. In general, there can be more than one such minimal sets; but a unique set of interactions was identified for every faulty version in our case.

As the SUT model does not completely cover the possible test space of the application, no test case failed for some of the faulty versions. The bugs that manifested themselves are summarized in Table 3. The names of the bugs are designated by SIR.

Then, we ran our proposed algorithm to generate a (
 
, 
 
)-CLA for the SUT model. We derived test scripts from the CLA and applied them to the set of faulty programs. The located faulty interactions using the CLA-based test cases are compared with the results of the exhaustive testing.


Table 3. Seeded bugs.

SUT	Name	Description
Flex	F_AA_2	array: “array[index]” to “array[index - 1]”
F_AA_3	if condition: “var1  var2” to “var1  var2”
F_AA_6	if condition: “(var1  var2) && var3” to “var1  (var2 && var3)”
Gzip	FAULTY_F_KL_6	value assignment: “var1  var2” to “var1  var2”
FAULTY_F_KP_11	loop condition: “var” to “var ”
5.3.2. Experimental results
The results of the experiments are summarized in Table 4. The two leftmost columns show the applications and names of bugs. The rest of the table is divided into two parts, i.e., the exhaustive testing part and the CLA part. Each part consists of three columns. The “Tests” column shows the total number of test cases. The “Failed” column shows the number of test cases that failed. The “Located” column shows located faulty interactions. Note that the faulty interactions located by exhaustive testing are correct answers.


Table 4. Experimental results for locating faulty interactions.

SUT	Name	Exhaustive testing	CLA
#Tests	#Failed	Located	#Tests	#Failed	Located
Flex	F_AA_2	500	90	1-way: {(FastSwithT, FST)}	32	11	–
1-way: {(FastSwithT, AlterFast)}
F_AA_3	500	468	1-way: {(Compability, off)}	32	26	1-way: {(Compability, off)}
F_AA_6	500	20	4-way: {(Bp, Off), (FastS, FS), (Align, Off), (EqClass, Off)}	32	5	1-way: {(FastS, FullS)}
1-way: {(FastS, FullS)}
Gzip	FAULTY_F_KL_6	159	4	3-way: {(SetV, On), (Set4, On), (FileType, ASCII)}	36	2	2-way: {(Set4, On), (FileType, ASCII)}
FAULTY_F_KP_11	159	79	1-way: {(FileType, ASCII)}	36	20	1-way: {(FileType, ASCII)}
Note:

FastSwithT  Fast Scanner with Table, FST  Fast Scanner Table, AlterFast  Alternate Fast;

Compability  Compability with AT&T Lex; Bp  Bypass use; EqClass  Equivalence Classes;

FastS  Fast Scanner, FS  Fast Scan, FullS  Full Scan;

Set_V  Set V Option; Set_4  Set 4 Option.

For two faulty versions denoted F_AA_3 and FAULTY_F_KP_11, there was exactly one faulty interaction and its strength was one. The test cases derived from the 
 
 
-CLAs successfully identified the faulty interaction, as proved by the theory.

For F_AA_2, there were two faulty interactions which both were of strength one, namely, {(FastSwithT, FST)} and {(FastSwithT, AlterFast)}. The CLA-based test cases failed to locate either of these faulty interactions. In this case, there was no single interaction that appeared in the 11 failed test cases but not in the remaining 21 passed test cases. However, if we assumed the existence of two faulty interactions of strength , the faulty interactions could be identified because no other interaction pairs coincide the test outcome. This suggests that even if faulty interactions cannot be exactly located, the test outcome obtained from CLAs may provide informative clues about them.

Similarly to F_AA_2, the case F_AA_6 also contained two faulty interactions; but in this case, one of the faulty interactions was of strength four. In this case, the CLA-based test cases correctly located one faulty interaction that is of strength one. The other faulty interaction, namely, {(Bp, Off), (FastS, FS), (Align, On), (EqClass, Off)} did not occur in any of the test cases because of its high strength. As a result, the four-way faulty interaction did not affect the identification of the other faulty interaction.

The case FAULTY_F_KL_6 contained one faulty interactionwhose strength is three. This means that by definition, the 
 
 
-CLA-based test cases were not able to locate this interaction. In fact, based on the test outcome, two-way interaction {(Set4, On), (FileType, ASCII)} was identified as a faulty interaction. This result was not exactly correct; but this is useful for fault localization as it is a subset of the correct faulty interaction {(SetV, On), (Set4, On), (FileType, ASCII)}.

Although this experiment is limited in scale, we answer RQ 5 based on the results obtained so far as follows.

Answer to RQ 5.
The test cases derived from 
 
-CLAs may fail to locate faulty interactions if there are more than one faulty interaction or faulty interactions have strength greater than ; but even in such cases, they still can provide information useful for localization of faulty interactions.

6. Related work
Constraint handling has been an important issue in combinatorial interaction testing, even before the name of this testing approach was coined. Early work includes, for example, Tatsumi (1987) and Cohen et al. (1997). Recent surveys of constraint handling in combinatorial interaction testing include (Wu et al., 2019a, Wu et al., 2019b, Ahmed et al., 2017). These surveys mention more than 100 research papers addressing this particular problem.

In contrast, research on LAs is still in an early stage (Colbourn and Syrotiuk, 2016). The notion of LAs was originally proposed by Colbourn and McClary (2008). Since then, some studies have been published that discuss mathematical properties of LAs or propose mathematical constructions of LAs. These studies include (Shi et al., 2012b, Tang et al., 2012, Colbourn et al., 2016, Colbourn and Fan, 2016, Shi et al., 2020). Some other studies proposed computational generation methods of LAs (Konishi et al., 2017, Konishi et al., 2020a, Nagamoto et al., 2014, Konishi et al., 2020b, Seidel et al., 2018, Lanus et al., 2019). None of these previous studies consider constraints. Recent surveys on the state of locating array research and its applications can be found in Colbourn and Syrotiuk, 2016, Colbourn and Syrotiuk, 2018.

Mathematical objects similar to LAs include Detecting Arrays (Colbourn and McClary, 2008, Shi et al., 2012a, Colbourn and Syrotiuk, 2019) and Error Locating Arrays (Martínez et al., 2010). To our knowledge, no attempts have been reported to incorporate constraints into these arrays, either.

We for the first time introduced the concept of CLA in Jin and Tsuchiya (2018a), which is a preprint of an early version of this paper. This paper extends the early version by incorporating our subsequent work (Jin and Tsuchiya, 2018b), where we showed the heuristic algorithm for obtaining CLAs for the first time. Originally we presented it as a method of generating 
 
-CLAs, instead of 
 
-CLAs. This paper extends (Jin and Tsuchiya, 2018b) by providing new theorems (namely, Theorems 2 and 3) to show that the algorithm can yield 
 
-CLAs and by providing more comprehensive experimental results using a new, faster implementation of the algorithm. The SMT-based algorithm, which was compared with the proposed algorithm in Section 5, was presented in Jin et al. (2018).

There are many studies that address finding faulty interactions without using the mathematical objects mentioned above. Many of these studies proposed adaptive testing strategies (Wang et al., 2010, Zhang and Zhang, 2011, Li et al., 2012, Arcaini et al., 2019, Bonn et al., 2019, Niu et al., 2020b). In an adaptive strategy, new test cases are interactively created and executed to gradually narrow down the candidates for faulty interactions. On the other hand, the CLA-based approach is non-adaptive. A main benefit of using non-adaptive approaches is that testing, which is often very time-consuming, can be performed in parallel. Identifying multiple faulty interactions with an adaptive approach is discussed in Niu et al. (2020a).

In Yilmaz et al., 2006, Shakya et al., 2012 and Nishiura et al. (2017), machine learning techniques are applied to the test outcome to identify suspicious faulty interactions. Practical issues with fault localization raising in industrial software development cycles are discussed in Fouché et al. (2009) and Blue et al. (2019).

In this paper, we did not discuss how to spot faulty program statements from identified faulty interactions. This important problem is addressed in, for example, Ghandehari et al., 2013, Ghandehari et al., 2020.

7. Conclusions
In this paper, we introduced the notion of Constrained Locating Arrays (CLA), which generalize locating arrays by incorporating constraints on test parameters into them. The extension allows locating arrays to be applied to testing of real-world systems which usually have such constraints. We proved some basic properties of CLAs and then presented a heuristic algorithm to generate 
 
-CLAs which can locate at most one faulty interaction. Experimental results using a number of practical problem instances showed that the proposed algorithm is able to construct CLAs with reasonable time.

Even when multiple faults exist, the test outcome of 
 
-CLAs provides useful clues for identifying faulty interactions, because candidates for faulty interactions can be narrowed down to the interactions occurring only in the failing tests. However, a care must be taken if the test outcome matches a single fault and a set of multiple faults simultaneously. For example, consider the 
 
 
-CLA on the left in Fig. 9. If a one-way interaction  is the only faulty interaction, then the failing tests are 
, 
, 
, and 
. This test outcome is the same when two interactions  and  are faulty. If the possibility of multiple faults is taken into account, it is not possible to conclude that  is the faulty interaction in this case. Detecting arrays address this problem in the absence of constraints. One possible direction of future research is to adapt detecting arrays to the SUTs that have constraints. Our early attempt in this direction can be found in Jin et al. (2020).

Other future research directions include, for example, developing other algorithms for CLA generation and extending CLAs to handle invalid inputs for testing negative scenarios (Fögen and Lichter, 2019a, Fögen and Lichter, 2019b).