Abstract
Function-as-a-Service (FaaS) is a cloud service model enabling developers to offload event-driven executable snippets of code. The execution and management of such functions becomes a FaaS provider’s responsibility, therein included their on-demand provisioning and automatic scaling. Key enablers for this cloud service model are FaaS platforms, e.g., AWS Lambda, Microsoft Azure Functions, or OpenFaaS. At the same time, the choice of the most appropriate FaaS platform for deploying and running a serverless application is not trivial, as various organizational and technical aspects have to be taken into account. In this work, we present (i) a FaaS platform classification framework derived using a multivocal review and (ii) a technology review of the ten most prominent FaaS platforms, based on the proposed classification framework. We also present a FaaS platform selection support system, called FaaStener, which can help researchers and practitioners to choose the FaaS platform most suited for their requirements.

Keywords
Serverless
Function-as-a-Service
FaaS
Platform
Classification framework
Technology review

1. Introduction
In the context of cloud computing, the term serverless is typically used to describe a paradigm focusing on cloud architectures that comprise provider-managed components (Baldini et al., 2017). From the developer’s perspective, the decreased control over the infrastructure gives the impression that servers are no longer needed, whereas in fact servers become a provider’s burden. One exemplary serverless use case is when different non-managed component types, e.g., Database-as-a-Service and Software-as-a-Service, are combined to implement a Backend-as-a-Service (Cloud Native Computing Foundation (CNCF), 2018).

Function-as-a-Service (FaaS) is a cloud service model enabling the hosting of business logic in a serverless fashion, which makes this model an essential instrument for developing serverless applications. By deploying event-driven, stateless, and often short-lived functions to FaaS platforms, developers outsource the maintenance efforts to the corresponding platform provider. As a consequence, functions are automatically scaled without any imposed limits on the amount of new instances. Moreover, in case functions are no longer needed, they are scaled to zero instances, hence eliminating the need to pay for idle application components unlike in other service models that continuously run components, e.g., Platform-as-a-Service (Yussupov et al., 2019b).

The FaaS service model started gaining a lot of attention after the release of AWS Lambda (Amazon Web Services, Inc., 2021) in 2015, which started the overall serverless trend. Afterwards, all major cloud providers introduced their FaaS offerings including notable examples such as Microsoft Azure Functions (Microsoft, 2021a), Google Cloud Functions (Google, 2021a), and IBM Cloud Functions (IBM, 2021a), with the latter based on the open source FaaS platform Apache OpenWhisk (The Apache Software Foundation, 2021). The landscape of open source FaaS platforms is also blooming. Various alternatives such as OpenFaaS (OpenFaaS Project, 2021), Apache OpenWhisk (The Apache Software Foundation, 2021), Kubeless (Bitnami, 2021), or Knative (The Knative Authors, 2021) are being actively developed and maintained by the community.

However, in most cases, the FaaS programming model is the only common denominator for all available offerings since the underlying technical platform characteristics and supported feature sets vary significantly. For example, one of the main strengths of proprietary FaaS platforms lies in the out-of-the-box integration with provider-specific services, which is typically not the case for open source platform offerings. For instance, AWS Lambda can natively be combined with Amazon SQS to use message queues as sources triggering function execution. In contrast, open source platforms such as Kubeless or OpenFaaS provide a more portable way to develop serverless applications. They indeed reduce platform lock-in, favoring more portable serverless applications that are not locked into specific cloud offerings, e.g., by relying on Kubernetes (The Kubernetes Authors, 2021), a portable application orchestrator, rather than on Amazon’s or Microsoft’s clouds.

As a result, choosing the most suitable platform becomes a decision problem involving multiple different dimensions, which affect both the high-level business perspective of project managers and the low-level technical perspective of application developers and operators. For instance, high-level requirements include the license used by a FaaS platform, which heavily influences the choice of the platform when the latter is intended to be incorporated as an internal task-scheduling component for a company’s product. Various low-level technical details have to be analyzed too, which might become a serious obstacle for deciding which platform to choose. Examples of such technicalities include available event source integrations, platform-supported tooling, deployment automation support, or supported language runtimes.

Our objective here is precisely to provide a way to uniformly classify FaaS platforms with the goal of simplifying the decision-making process for specialists with different levels of responsibilities, i.e., managers and technical specialists. To come up with an efficient classification mechanism, we conducted a multivocal review that combines the results from a systematic literature review and the documentation analysis of existing platforms to derive a FaaS Platforms Classification Framework, which we present as the first contribution of this paper.

Our classification framework clearly distinguishes between two views: (i) the business view of project managers and (ii) the technical view of developers and operators. These two different views can help organizations in choosing a FaaS platform best suited for their requirements, with the business view helping project managers to first select the subset of FaaS platforms complying with the project and business requirements with a high-level analysis, and without delving into all technicalities of the platforms themselves. The technical view can then be exploited by the technical specialists working on the development and operation of a FaaS-based project to analyze the technical features of FaaS platforms, while at the same time focusing only on the platforms that already comply with the project and business requirements.

Based on our classification framework, we conducted a FaaS Platforms Technology Review, which constitutes the second contribution of this paper. The technology review classifies and compares the ten most popular FaaS Platforms, i.e., the three most used proprietary platforms and the seven highest-ranked open source platforms. Notably, our review provides a first systematic knowledge base that managers and DevOps can exploit to choose the platform best suited for their requirements.

The main contribution of this work is hence twofold:

(i)
We introduce a FaaS Platforms Classification Framework derived using a multivocal literature review that analyzed (a) the official documentation of commercial and open source platforms and (b) FaaS platforms classification approaches used in academic literature. Our classification framework combines this knowledge in the form of a comprehensive set of dimensions and criteria for comparing FaaS platforms from two different perspectives: the higher-level business view of project managers and the lower-level technical view of application developers and operators.

(ii)
We conducted a FaaS Platforms Technology Review of the ten most popular FaaS platforms, including the three most used commercial platforms and the seven highest-ranked open source platforms. The collected data are publicly available on Zenodo (Yussupov et al., 2020) and provide a characterization of the investigated platforms under both the business and the technical views of our classification framework.

To further support researchers and practitioners in the selection process, we also present a FaaS Platforms Selection Support System, called FaaStener. FaaStener is a web-based open source application exploiting the results of our technology review and enabling to search for FaaS platforms through multi-attribute queries, e.g., to look for platforms with a certain license and supporting given monitoring and logging solutions. FaaStener allows researchers and practitioners to look for FaaS platforms which satisfy the requirements of their serverless projects and to browse through the knowledge base built by our technology review.

The rest of the paper is organized as follows. Sections 2 Background, 3 Related work discuss background and related work, respectively. Section 4 illustrates the research approach for conducting our study. Section 5 introduces the FaaS Platforms Classification Framework. Section 6 presents the FaaS Platforms Technology Review, while Section 7 illustrates the FaaS Platforms Selection Support System materializing the results of the review. Sections 8 Discussion, 9 Threats to validity discussion the results and potential threats to the validity of our study, respectively. Section 10 finally draws concluding remarks.

2. Background
The popularity of serverless computing started to rise after Amazon introduced its FaaS platform offering called AWS Lambda (Amazon Web Services, Inc., 2021). While the term serverless was also used previously in other contexts, it gained most popularity in the context of cloud-native application development (Fox et al., 2017). Essentially, serverless applications are composed of components that are managed by third-parties, which significantly reduces control over the infrastructure by minimizing management efforts (Cloud Native Computing Foundation (CNCF), 2018).

Function-as-a-Service is an integral part of the serverless world as it enables hosting business logic in the form of functions that are typically stateless and driven by events. This means that the deployed function code can be triggered by events originating from multiple heterogeneous event sources such as databases, message queues, or streaming platforms. Moreover, functions can be exposed as HTTP endpoints via API Gateways, or invoked on a scheduled basis, e.g., using cron jobs. The actual list of supported event sources and possible ways to integrate events from third party services depends on the employed FaaS platform. Since the provider is responsible for managing functions, autoscaling comes out-of-the-box, also including scaling to zero instances when functions are not needed. This introduces a new, more flexible cost model, where users do not need to pay for idle components as for Platform-as-a-Service deployments. However, in some cases the costs might become less appealing than with classic cloud service models (Eivy, 2017). Moreover, aside from its benefits, FaaS also has some well-known limitations (Hellerstein et al., 2018) such as the cold start issue, limited execution time which might also vary on different FaaS platforms, or tighter-coupling with provider’s specifics due to outsourced management efforts (Yussupov et al., 2019a). However, the combination of the above mentioned properties and limitations is what essentially affects the ways how FaaS platforms need to be chosen.

The FaaS technology landscape comprises a variety of heterogeneous platforms, which are offered as-a-service, or can be installed on-premises. For example, Microsoft introduced Azure Functions (Microsoft, 2021a) while IBM started offering its Cloud Functions (IBM, 2021a) based on the open source FaaS platform Apache Openwhisk (The Apache Software Foundation, 2021). The landscape of open source FaaS platforms started to evolve rapidly too, also due to the popularity of container orchestration brought by Kubernetes (The Kubernetes Authors, 2021). Multiple open source products such as OpenFaaS (OpenFaaS Project, 2021), Kubeless (Bitnami, 2021), or Fission (The Fission Authors, 2021) that provide serverless, FaaS-based application development experience on top of Kubernetes. Typically, since functions are event-driven, FaaS platforms can be integrated with multiple possible event sources such as databases, messaging and streaming platforms, or provider-specific services such as AWS Alexa (Amazon, 2021). As a result of this heterogeneity, there is an ongoing work on maintaining the list of available technologies with high-level details such as web-site and documentation pointers curated by the Cloud Native Computing Foundation (CNCF) (Cloud Native Computing Foundation (CNCF), 2021a). Moreover, CNCF is also curating the work on standardization of event specification format called CloudEvents (Cloud Native Computing Foundation (CNCF), 2021b).

3. Related work
There already exist some research efforts qualitatively classifying and reviewing FaaS platforms. All such efforts were considered in our study to derive the initial version of our classification framework (cf. Section 4), which was then extended based on FaaS platforms’ documentation to derive the classification framework presented in this article.

We hereafter position our study with respect to existing efforts, starting from the review by Kritikos and Skrzypek (2018), who conducted an assessment of serverless frameworks using a set of criteria corresponding to different phases of a serverless application’s lifecycle, e.g., design, development, deployment, or execution. Kritikos and Skrzypek distinguish between provisioning and abstraction frameworks. Provisioning frameworks are responsible for provisioning serverless applications by enabling a “mini-serverless platform”, whereas abstraction frameworks abstract from the technical details of two or more serverless platforms. As a result, Kubernetes-based FaaS platforms, like Fission and Kubeless, are classified as provisioning frameworks, whereas the Serverless framework is described as an abstraction framework. The Authors then evaluate and compare both provisioning and abstraction frameworks by considering qualitative criteria. Our effort goes a step further by (i) considering a wider set of criteria to analyze and classify FaaS platforms, and by (ii) considering a wider set of FaaS platforms.

Similar considerations apply to other examples of criteria-based reviews of FaaS platforms, e.g., Lee et al. (2018), Lynn et al. (2017), and Mohanty et al. (2018), and to those focussing on evaluating FaaS-based function orchestrators and serverless application repositories, e.g., García López et al. (2018) and Spillner (2019). Lee et al. (2018) evaluate the performance characteristics of production FaaS platforms, and include a feature-wise comparison of the chosen products, i.e., FaaS platforms from Amazon, Microsoft, Google, and IBM. Lynn et al. (2017) evaluate seven enterprise serverless platforms with the term serverless being used interchangeably with FaaS. The chosen products are reviewed based on the set of defined criteria and include, e.g., AWS Lambda, Microsoft Azure Functions, and Google Cloud Functions. Mohanty et al. (2018) conduct a feature-wise comparison and performance evaluation of four open source FaaS platforms, namely Kubeless, OpenWhisk, Fission, and OpenFaaS. In their work, Mohanty et al. however put more focus on comparing the performances experienced by the considered open source platforms. García López et al. (2018) evaluate and compare three commercial FaaS orchestrations systems, namely AWS Step Functions, IBM Composer, and Azure Durable Functions. The chosen function orchestrators are reviewed based on the set of defined criteria, and their runtime overhead is evaluated experimentally. Spillner (2019) investigates how FaaS-based applications are specified, stored, and offered using the AWS Serverless Applications Repository. Various statistics are presented related to different aspects of functions’ lifecycle.

All the aforementioned works (Kritikos and Skrzypek, 2018, Lee et al., 2018, Lynn et al., 2017, Mohanty et al., 2018, García López et al., 2018, Spillner, 2019) together with other existing criteria-based reviews of FaaS platforms (Rajan, 2018, Palade et al., 2019, Kumar, 2019, Kalnauz and Speranskiy, 2019, Gand et al., 2020, Bortolini and Obelheiro, 2019), provide valuable contributions by taking various angles for reviewing FaaS platforms and related concepts. At the same time, the features considered in all such efforts for classifying FaaS platforms, as well as the classified platforms, do not overlap, hence scattering knowledge across different pieces of literature. We instead aim to provide a more comprehensive classification framework and technical review, by (i) extending the set of features already considered in literature for classifying FaaS platforms, (ii) enabling to classify FaaS platforms at two different levels of detail, based on the involved stakeholders, and (iii) providing a more comprehensive technical review for the most popular FaaS platforms using our classification framework. In addition, we provide a selection support system enabling researchers and practitioners to look for FaaS platforms most suited to their needs.

Other research efforts worth mentioning are those tackling the problem of FaaS platforms benchmarking. For instance, Wang et al. (2018) analyze the performance, resource management, and architectures of the FaaS platforms from Amazon, Microsoft, and Google. Wang et al. implement measurement functions to discover hidden architecture details of these platforms and collect performance-related data. Our work differs from that by Wang et al. (2018) since we focus on feature-wise classification and reviewing of FaaS platforms, rather than on their benchmarking. Similar considerations apply to other research efforts benchmarking FaaS platforms (Back and Andrikopoulos, 2018, Figiela et al., 2018, Malawski et al., 2018, Kuhlenkamp et al., 2019).


Table 1. Classification of related work based on main focus and research method of each study, and on its coverage of the classification dimensions and FaaS platforms presented in this article.

Study	Research method	Covered dimensions	Covered platforms	Support tooling
Business View	Technical View	Proprietary	Open source	
Kritikos and Skrzypek (2018)	Technology review	2/18	17/36	0/3	3/7	
Lee et al. (2018)	Performance comparison	0/18	9/36	3/3	0/7	
Lynn et al. (2017)	Gray literature review	2/18	14/36	3/3	1/7	
Mohanty et al. (2018)	Performance comparison	6/18	7/36	0/3	4/7	
García López et al. (2018)	Performance comparison	0/18	3/36	2/3	0/7	
Spillner (2019)	Technology review	0/18	3/36	1/3	0/7	a
Rajan (2018)	Gray literature review	1/18	4/36	3/3	0/7	
Palade et al. (2019)	Performance comparison	4/18	5/36	0/3	4/7	
Kumar (2019)	Technology review	0/18	11/36	3/3	0/7	
Kalnauz and Speranskiy (2019)	Performance comparison	0/18	4/36	3/3	0/7	
Gand et al. (2020)	Solution proposal	1/18	2/36	0/3	3/7	
Bortolini and Obelheiro (2019)	Performance comparison	0/18	3/36	2/3	0/7	
Wang et al. (2018)	Performance comparison	0/18	2/36	3/3	0/7	
Back and Andrikopoulos (2018)	performance comparison	0/18	5/36	3/3	1/7	
Jonas et al. (2019)	Position paper	0/18	4/36	1/3	0/7	
Our study	Multivocal review	18/18	36/36	3/3	7/7	✓
a
Review results publicly available online and continuously updated.

Jonas et al. (2019) instead provides a different view on serverless computing. Similarly to their Berkeley view of cloud computing (Armbrust et al., 2010, Jonas et al., 2019) explain motivations and applications for serverless computing, and they list issues and research directions for allowing serverless computing to fulfill its potential. Jonas et al. (2019) also provide a high-level review of AWS Lambda, which covers some of the classification dimensions that we also cover in our study. Our study however goes a step further in analyzing and comparing FaaS platforms, as we consider a much bigger set of classification dimensions and review both proprietary commercial platforms and open source platforms.

Table 1 summarizes the above discussion by reporting on the research method adopted in the above mentioned related research efforts, and by showing how many of the classification dimensions and FaaS platforms analyzed in this article are covered also in such research efforts, i.e., (i) how many of the 18 different classification dimensions pertaining to the business view of project managers (Section 5.1) are covered in related work, (ii) how many of 36 different classification dimensions pertaining to the technical view of developers and operators (Section 5.2) are covered in related work, and (iii) how many of three proprietary and seven open source platforms covered in our review (Section 6) are also covered in related work. From the table, one can directly observe how each related publication covers a different set of classification dimensions and reviews a different set of FaaS platforms, with a preponderance towards proprietary platforms, whilst open source platforms being much less covered. The data in the table hence show that our work is the first multivocal review in the field, and how it more comprehensively covers classification dimensions for FaaS platforms. We indeed cover a much higher number of classification dimensions, and ours is the first study reviewing ten FaaS platforms, by both considering proprietary and open source platforms. In addition, ours is the first research work accompanied by some concrete tooling to support application developers in selecting the FaaS platform most suited to their needs.

Finally, it is worth positioning our study with respect to other studies of similar nature applied to other cloud service delivery models. Kolb (2019) inspired our work by proposing a classification framework and review of PaaS platforms, which he made available online in a PaaS platform selection support system, i.e., PaaSfinder. Cloud4SOA (DAndria et al., 2012), PaaSport (Bassiliades et al., 2017), SeaClouds (Brogi et al., 2014), and DrACO (Brogi et al., 2017) are other examples of solutions classifying cloud service offerings and offerings selection support systems, with Cloud4SOA and PaaSport focussing on PaaS platforms, while SeaClouds and DrACO covering both IaaS and PaaS cloud offerings. Notably, various of the dimensions pertaining to the business view in our classification framework are covered also in all such efforts, while the same does not hold for those in the technical view. Similar considerations apply to other studies targeting decision support for cloud-based deployment (Menzel and Ranjan, 2012, Peng et al., 2009, Sundareswaran et al., 2012, Di Martino et al., 2010, Jung et al., 2013). This highlights how our business view can be reused to classify and review other cloud-based deployment solutions, whereas the technical view we propose hereafter is specific to FaaS platforms.

4. Research method
In this section, we first recap terminology for core concepts related to the world of serverless and FaaS, which we use throughout this paper. We then proceed by describing the research method’s steps.

4.1. Terminology
In this section, we define the serverless- and FaaS-related terminology used in the subsequent sections.

Function-as-a-Service Platform/FaaS Platform. We use the term FaaS platform to describe an environment that enables deploying, managing, and observing function instances, similar to the notion of a FaaS platform used in the CNCF Serverless Landscape (Cloud Native Computing Foundation (CNCF), 2021a). This definition also covers FaaS platforms that require a specific underlying platform, e.g., when a platform must run on top of a container orchestration platform such as Kubernetes, since these kinds of restrictions do not influence the overall purpose of the given product, i.e., to enable the usage of user-provided functions in a serverless fashion.

Event. We base our definition of an event on the CloudEvents specification by CNCF. More precisely, by using the term event, we mean a data record capturing an occurrence of a particular fact in a software system during its operating time (Cloud Native Computing Foundation (CNCF), 2021b).

Event Source. As for events, we rely on the definition from CloudEvents specification (Cloud Native Computing Foundation (CNCF), 2021b), i.e., an event source is the context where events happen, e.g., a remote database.

Function. We base our definition of a function on the definition from the serverless whitepaper by CNCF (Cloud Native Computing Foundation (CNCF), 2018). We use the term function to describe an executable snippet of code that can be hosted on the FaaS platform and triggered by events originating from supported event sources, or invoked directly, e.g., via programmatic access provided by available client libraries.

Serverless Application. The term serverless application is used to describe a combination of one or more functions that interact with a set of resources managed by third-parties such as cloud providers or other external as-a-service offerings. Essentially, a serverless application represents a logical grouping of resources and functions in particular, which facilitates, e.g., versioning for development and deployment of applications.

Function Orchestrator. To describe a specialized software that enables composing multiple functions by means of workflows, we use the term function orchestrator. This definition is related only to specialized products explicitly tailored for FaaS, e.g., AWS Step Functions (Amazon Web Services, 2021a) or Azure Durable Functions (Microsoft, 2021b), while it does not include general-purpose workflow engines such as Apache ODE.

Function Marketplace. We use the term function marketplace to denote dedicated marketplace platforms for offering functions and FaaS-based applications that are distributed by third-parties under proprietary or open source licenses for commercial and non-commercial use, e.g., applications that represent a common serverless use case and can be purchased for educational or development purposes. A function marketplace is managed by a marketplace provider, who also defines packaging and description formats of marketplace’s products, for instance. A notable example of function marketplace is the AWS Serverless Application Repository (AWS SAR) (Amazon Web Services, 2021b).

Code Samples Repository. A code samples repository is a publicly-available and officially-maintained collection of function and application examples developed for a given FaaS platform, which can be used as a training material or reused for application development. Unlike function marketplaces, code samples are always distributed under open source licenses and typically provided as-is. Technically, it might be a standalone repository or a part of the main platform’s repository maintained by the community or the platform producer, e.g., function examples stored in the examples folder with the platform repository.

4.2. Research method’s steps
Fig. 1 shows the multi-step process of our multivocal review, based on a combination of academic literature review and documentation analysis. As an initial step, we analyzed existing academic reviews of FaaS platforms and we derived an initial FaaS platforms classification framework. Afterwards, we selected ten existing FaaS platforms, we analyzed them, we refined the initial classification framework based on the newly-discovered data, and we used it for the review of these platforms. In the following, we elaborate on the research method’s design.

4.2.1. Step 1: Academic literature review
To derive a classification framework that covers both academic and industrial views on FaaS platforms, as a first step, we analyzed the existing literature that focuses on reviewing Function-as-a-Service platforms by searching the initial set of publications using well-known electronic research databases, namely ACM Digital Library, arXiv.org, Google Scholar, IEEE Xplore, Springer Link, Science Direct and Wiley Online Library.

Selection criteria. To identify publications relevant to FaaS platforms analysis and comparison, we defined a set of selection criteria. The initial dataset was screened by the authors using adaptive reading depth (Petersen et al., 2015) to identify publications’ relevance. We defined the inclusion (✓) and exclusion () criteria as follows:

✓
Publications that evaluate and compare existing FaaS platforms and function orchestration technologies.

✓
Publications that are written in English.

Publications not accessible as full-text or not in the form of a full research paper, e.g. extended abstract, presentation, tutorial, PhD research proposal, demo paper, as they do not provide enough details.

As a result, we identified five (Kritikos and Skrzypek, 2018, García López et al., 2018, Mohanty et al., 2018, Lee et al., 2018, Lynn et al., 2017) relevant publications after applying the selection criteria to the identified initial set of publications.

Snowballing and Combination. As additional means to identify relevant literature, we applied the snowballing technique (Wohlin, 2014). More specifically, we used Google Scholar for forward snowballing, i.e., analyzed all research papers that cite each of the selected publications, and applied closed recursive backward snowballing, i.e., analyzed all research papers cited by each of the selected publications. Afterwards, we applied the selection criteria defined previously in Section 4.2.1, which lead to the identification of six additional publications (Rajan, 2018, Palade et al., 2019, Kumar, 2019, Kalnauz and Speranskiy, 2019, Gand et al., 2020, Bortolini and Obelheiro, 2019). Due to the relatively small amount of relevant publications (11 in total), the combination step was not necessary.

4.2.2. Step 2: Derive initial classification framework
To derive an initial classification framework, we used the keywording technique (Petersen et al., 2008). The overall process is as follows: (1) the first two authors of this work separately analyzed each publication from the selected set to identify common concepts and define keywords for them; (2) the resulting keywords were discussed among all authors and clustered to form the initial classification framework. At this stage, we had a set of generic, high-level keywords representing categories, e.g., Licensing, Installation, Documentation, Development, Interfaces, and Observability, each coming with a set of low-level keywords representing concrete criteria. For example, Observability included Logging and Monitoring categories, which listed supported tooling and available integration mechanisms for adding new tools. As an outcome of this step we obtained a set of mappings between higher- and lower-level keywords, e.g., Development: {Function Runtimes, Client Libraries}, where Development is a high-level keyword representing a category and the low-level keywords are in braces. Due to the discrepancies in classification criteria names used in reviewed publications, the combination of lower-level keywords also involved de-duplication and decision on final keyword choices. We explain the decision on keyword choices by an example: we have chosen the term Function Runtimes over Programming Language, which is used in multiple reviewed publications, e.g., “Language” (Kritikos and Skrzypek, 2018), “Programming Language Supported” (Mohanty et al., 2018), “Programming Language Support” (Palade et al., 2019). While both Function Runtime and Programming Language are self-explanatory, there is a subtle difference between them. Supporting a function runtime means that a platform provides necessary means to run a function code developed in a specific programming language out-of-the-box, e.g., Python3 or Java8 runtimes. On the other hand, if a platform supports Docker images as function runtimes, virtually any programming language can be supported with additional effort, i.e., Docker image has to conform with the interfaces required by the platform to invoke the container instances. After this step, the collected set of keywords lacked technical depth compared to the refined framework, e.g., Event Sources category had no dimensions yet. Additionally, the keywords were not yet organized in a concrete classification framework, but rather grouped as a set of mappings between higher- and lower-level keywords.1

4.2.3. Step 3: Search and select relevant faas platforms
As a next step, we selected ten relevant general-purpose FaaS platforms for subsequent refinement of our initial classification framework. We defined the following requirements that had to be fulfilled by a FaaS platform to be included for the documentation analysis:

✓
A platform must be general-purpose, meaning that it should not tailored for a specific use case (e.g., training AI models).

✓
A platform has to be actively-maintained, i.e., there exist one or more parties consistently contributing towards new platform releases and the code repository is not stale or archived.

We structured the overall process of searching and selecting relevant FaaS platforms using approaches from existing work, e.g., search engine hits analysis (Wurster et al., 2019).

Phase 1: Platforms Search. To select relevant FaaS platforms, we used white and gray literature sources, namely the list of platforms reviewed in the publications chosen during the literature review step described in Section 4.2.1, and the serverless landscape (Cloud Native Computing Foundation (CNCF), 2021a) maintained by CNCF that describes the platforms and tooling related to serverless computing. We aggregated the lists of platforms obtained from both sources while checking if the aforementioned inclusion criteria are fulfilled to ensure that we do not miss relevant platforms. For example, we excluded Snafu (Spillner, 2017), a research prototype evaluated in one of the publications as it is not a general-purpose and actively-maintained FaaS platform (no commits in the last 2 years). Afterwards, we sorted the remaining platforms by popularity (using separate criteria for hosted and installable platforms) and we applied the effort bounded stopping criteria (Garousi et al., 2019) by selecting ten platforms in total.

Phase 2: Platforms Selection. A first crucial selection aspect is how to decide on proper ratio between commercial and open source platforms. It is important to mention that at the moment of writing CNCF serverless landscape lists 33 FaaS platforms, 19 of which are hosted (mostly closed-source) and 14 are installable and open source. With the aim of putting more emphasis on open source installable FaaS platforms, whose source code is publicly available and which can be installed on premises, we decided to cover 50% of them, i.e., seven open source installable FaaS platforms. Taking into account our bounded effort stopping criteria (Garousi et al., 2019), according to which we limited our analysis to ten FaaS platforms, we hence chose to analyze three commercial platforms and seven open source platforms.


Table 2. List of selected FaaS platforms (sorted alphabetically).

To pick the most representative commercial and open source FaaS platforms, we then decided to select the most popular of them. We used different popularity quantifiers for commercial and open source platforms since (i) commercial platforms typically have popularity quantifiers, like quantity of search engine hits or Stackoverflow questions, which are higher with respect to those of open source platforms by orders of magnitude, (ii) such popularity quantifiers can also be misleading for open source platforms, as their name may not be branded and correspond to other projects, and (iii) the developers’ interest in open source platforms can be estimated by analyzing publicly available source code-related metrics, while commercial platforms are typically proprietary closed-source products maintained by one party, e.g., AWS Lambda.

We searched for the three most popular commercial FaaS platforms by sorting commercial platforms by Google Search hits, and by using the full platform name as a search query (e.g., “aws lambda”, “azure functions”, “google cloud functions”, and “ibm cloud functions”). As a result, we selected AWS Lambda, Microsoft Azure Functions, and Google Cloud Functions. It is worth mentioning that for all three selected platforms the amount of Google Search hits was above 500.000 hits, whereas there is a significant drop in number of hits for the remaining commercial platforms, all of which had less than 150.000 hits.

In contrast, we approximated the overall interest in open source platforms by measuring the amount of GitHub stars given by GitHub users since all open source FaaS platforms are hosted on GitHub (Cloud Native Computing Foundation (CNCF), 2021a). The amount of stars associated with the GitHub repositories of FaaS platforms were extracted using GitHub’s API, which resulted in the following list: OpenFaaS, Apache Openwhisk, Nuclio, Fission, Fn, Kubeless, and Knative. This decision was driven by two main factors, namely (i) to highlight the trends in open source FaaS platform development community and (ii) to provide more data for identifying the gaps between open source and commercial platforms, since the latter generally focus less on supporting integration with third-parties. Table 2 shows the final list of FaaS platforms selected for the documentation analysis together with their corresponding documentation sources.

4.2.4. Step 4: Analyse platforms’ documentation
We analyzed only the documentation provided by official sources such as a dedicated website maintained by the official producer of the platform and its GitHub repository, in case the platform is open source (Table 2). The documentation was analyzed separately by the first two authors of this work using the initial classification framework as a baseline. After the analysis, the results were discussed among all authors to identify potential refinements for the classification framework. As starting points for reviewing the documentation we used the initial set of keyword mappings obtained after the analysis of relevant research publications as discussed in Section 4.2.2. The mappings between higher- and lower-level keywords such as Development: {Function Runtimes, …} were further refined based on the technical information obtained from the documentation of platforms. For example, the criterion Runtime Customization was added to the mapping Development: {Function Runtimes, Runtime Customization, …} as multiple platforms documented ways of extending supported function runtimes with the goal to enable implementing functions using programming languages not officially listed in the documentation. As an outcome of this step, we updated existing mappings with additional technical criteria. The updated mappings at this stage required a categorization and decisions on which collected criteria to keep.

4.2.5. Step 5: Finalise classification framework
After the initial set of mappings was refined using the analysis in Section 4.2.3, the obtained set of mappings had to be categorized to derive the final version of the classification framework. Firstly, the relations between higher-level keywords representing categories and low-level keywords was discussed among all authors to finalize our classification framework explained in detail in Section 5. For example, it was decided to combine Testing and Debugging into one parent category as multiple platforms document corresponding features “in vicinity of each other”. Similarly with the Observability category, which focuses on logging and monitoring aspects. The resulting set of categories and child elements was further analyzed and cross-checked among authors to reduce potential bias (Section 9). As a result, our framework comprised a set of categories grouping multiple related dimensions that represent classification criteria, each with a set of allowed values.

At this stage, we decided not to include some of the initially defined keywords. For example, it was decided not to include security-related concepts such as function’s code isolation mechanisms, as all authors agreed that such aspects require more specialized analysis and are not in the scope of this work. During this process we observed that the derived categories and dimensions differ in the amount of technical details, which inspired the idea of having two separate views on platforms: (i) higher-level, more general, and (ii) lower-level, more technical views. The resulting set of categorized dimensions was used to derive our FaaS Platforms Classification Framework, which we discuss in-detail in Section 5.

4.2.6. Step 6: Conduct faas platforms review
We exploited our classification framework derived in  Section 4.2.5 to conduct a technology review of the ten FaaS platforms listed in Table 2. As a first step, each platform was reviewed separately by two authors. Afterwards, the results were cross-checked by the other authors and merged. The conflicting results were discussed and resolved until the unanimous consensus was reached. To facilitate the reproducibility of our technology review, all collected data with corresponding documentation links are published as a Zenodo dataset (Yussupov et al., 2020). The results of the review are presented in Section 6.

5. Faas platforms classification framework
When choosing a FaaS platform best suited for a software project, various different aspects have to be taken into account and two different views can be identified. On the one hand, project managers focus on project- and business-oriented aspects when choosing the possible FaaS platforms for shipping the projects they manage, e.g., whether to select a proprietary or open source platform, and its actual licensing. On the other hand, aspects like whether a FaaS platform natively supports certain function triggers or deployment automation, or whether it can be integrated with given monitoring and logging solutions are typically not analyzed by project managers. Such aspects are rather considered by the technical experts actually developing and operating the project itself. Following this idea, we now present our framework for classifying FaaS platforms by distinguishing the business view of project managers from the technical view of developers and operators.2

5.1. A business view for classifying faas platforms
The business view of our FaaS Platforms Classification Framework comprises categories and dimensions of interest for project managers aiming to identify the FaaS platforms complying with the high-level project requirements. These include, for instance, the license under which a FaaS platform is released and whether the platform can be installed on-premise or not, as both dimensions can impact on the integration of the platform with the rest of the software developed in a project (Laurent, 2004). All dimensions pertaining to the business view of our classification framework are organized in Fig. 2 and explained hereafter.

Licensing . Each FaaS platform is released under some existing licensing, whether open or proprietary. The category Licensing enables classifying platforms under such dimension by allowing to indicate the actual License and the corresponding license Type. Fig. 2 reports some possible values for classifying the name and type of the license under which a platform is released, which can anyhow be any existing open source license name and type (such as those recapped by Laurent in his book (Laurent, 2004), for instance) or any proprietary licensing option under which vendors release their software.

Installation . FaaS platforms currently come in two different forms, as they can be hosted by vendors, installed on-premise, or both. The purpose of the Installation category is precisely to enable classifying FaaS platforms under this dimension by allowing to distinguish their installation Type (i.e., as-a-service, installable). The Installation category also enables to indicate the set of Target Hosts where a FaaS platform can be installed, which is given by a subset of the set formed by existing OSs and cluster orchestrators (some examples of which are in Fig. 2). Of course, if a platform only comes as-a-service, then the set of Target Hosts will be empty.

Source Code . The Source Code category enables classifying the Availability of the sources of a FaaS platform, whether it is open source or closed source. In the former case, the FaaS Platform Classification Framework also enables classifying the Open Source Repository and main Programming Language used for the Source Code. Fig. 2 lists possible values for classifying the Open Source Repository and main Programming Language, which can be any existing open source repository and programming language.

Interface . Existing FaaS platforms offer different ways for interacting with them, and the purpose of the Interface category is precisely to enable classifying platform under this dimension. The Interface category allows to list the supported interface Types, i.e., whether they offer a command line interface (CLI), an application programming interface (API), and/or a graphical user interface (GUI). It also enables to classify whether a FaaS platform supports Application Management, i.e., which subset of CRUD operations it offers to manage applications. Finally, the Interface category includes the Platform Administration dimension, which enables indicating whether a FaaS platform provides means for its own deployment, configuration, enactment, termination and undeployment.

Community . The Community category enables to classify FaaS platforms based on the size, activity, and popularity of their development community. Given that the seven most popular open source FaaS platforms (which drove the development of our classification framework) are all hosted on GitHub, the obtained Community category explicitly enables to classify platforms based on quantitative information taken from their GitHub repository, i.e., the amount of Stars, Forks, Issues, Commits and Contributors. All such numeric information gives an indication of the size, activity, and popularity of the corresponding repository (Guidotti et al., 2019). Another dimension explicitly included in the Community category is the amount of platform-related Questions on Stackoverflow, which also provide an indication of the usage and popularity of a platform.

Documentation . The available official documentation for currently existing FaaS platforms is heterogeneous in comprehensibility and nature. This is the main reason why the business view of our classification framework includes the Documentation category. The latter enables to indicate whether a FaaS platform comes with an official documentation for function development and deployment (with the Functions dimension), i.e., whether it documents how to develop functions that can be executed by the platform and the actual processes for suitably deploying them on the platform. The Documentation category also enables to indicate whether a FaaS platform officially documents its usage, development, deployment and architecture (with the Platform dimension), i.e., whether it documents the processes to use the platform for running function-based applications, to develop extension to the platform, to deploy the platform, and whether it provides information on the platform’s architecture.

5.2. A technical view for classifying FaaS platforms
The technical view in our classification framework comprises a set of categories and dimensions that have to be considered by software development and operations specialists willing to identify if a given FaaS platform suffices low level, technical requirements. For example, a runtime for the programming language used in the company or project might not be supported by the platform which would complicate the development. Fig. 3 presents a set of categories helping to classify a given FaaS platform from the technical perspective. In the following, we discuss all categories and their respective dimensions in-detail.

Development . Essentially, a FaaS platform might provide various mechanisms that facilitate the overall function and application development experience. Firstly, to start developing functions in a specific programming language, e.g., Python or Java, the platform must support the required Function Runtimes. Note that even in cases when the platform does not support a particular language, it still might be possible to develop function in such language if the platform supports Runtime Customization, e.g., by supplying custom container images as a function runtime. However, since a custom container image has to be created first following the specific set of requirements (e.g., implementing a required interface), instead of simply providing the source code, this option also introduces additional management efforts. As FaaS platforms typically impose varying requirements on, for example, the way functions have to be implemented (Yussupov et al., 2019a), the source code development can also be simplified via plugins for popular IDEs and Text Editors such as IntelliJ IDEA (JetBrains, 2021) or Visual Studio Code (Microsoft, 2021c) that provide support, e.g., for platform-specific syntax highlighting or automated code packaging. Moreover, a platform can provide Client Libraries for a set of programming languages that wrap the platform’s APIs as a part of platform’s Software Development Kit (SDK) to facilitate the development process, e.g., usage of platform-specific libraries for working with typed events’ data.


Download : Download high-res image (953KB)
Download : Download full-size image
Fig. 3. The technical view of our classification framework. White cells contain categories, lighter gray cells contain classification dimensions, while dark gray cells contain values that can possibly be associated with classification dimensions.

Finally, some FaaS platforms restrict the size of functions that can be deployed, as well as the execution time that functions can get at runtime. The purpose of the Quotas category is precisely to qualitatively indicate whether any upper bounds apply to a given FaaS platform. Presence of such quotas might influence the design decisions made when implementing functions for a given platform, e.g., a decision on usage of convenient but heavyweight libraries. The Quotas category indicates whether a platform imposes any restrictions on the Deployment Package Size and Execution Time.

Version Management . An important aspect in FaaS platforms that can simplify several distinct phases of the application lifecycle is Version Management of serverless applications and functions. Apart from facilitating the development process, versioning is also helpful for application deployment, e.g., to support canary releases (Danilo Sato, 2014) or blue–green deployments (Martin Fowler, 2010). It is hence advantageous if a FaaS platform provides mechanisms for managing versions on the level of single Function versions, or entire Application versions, i.e., a combination of functions and resources tracked together. It is worth mentioning that while it is always possible, for instance, to encode version identifiers as part of function or application names or namespaces, however such implicit versioning is less advantageous than the presence of dedicated mechanisms for version management. Additionally, a platform might not support version management on the serverless application level in case no notion of an application is present.

Event Sources . Due to the event-driven nature of FaaS, the event sources support plays an important role in deciding whether the platform is suitable for given development requirements. For instance, one of the common FaaS use cases is when a function needs to be exposed as an Endpoint via an API Gateway (Yussupov et al., 2019a). Subsequently, several endpoint-related aspects can be considered here, e.g., whether a Synchronous Call or an Asynchronous Call is supported and which protocols can be used for performing such calls, e.g., HTTP or gRPC. Moreover, it might be needed to use a custom endpoint’s name instead of the default resource name assigned when exposing the function as an endpoint, i.e., Endpoint Customization must be supported. In addition, in case a secure communication via HTTPS is required, a platform must provide TLS Support.

The next dimension of event sources encapsulates different Data Store types. Since serverless applications comprise non-managed components, we consider only the higher-level storage types (Mansouri et al., 2018) such as File Level which includes object stores like AWS S3, and Database Mode that covers SQL and NoSQL databases like Azure CosmosDB.

Another relevant event source is the Scheduler, which allows invoking functions on a scheduled basis. Typically, internally these sources are implemented using cron jobs, hence developers might need to understand the subtle differences in the required format of cron expressions.

Such event source dimensions as Message Queue and Stream Processing Platform are the next important parts for FaaS platforms. Being one of the main integration mechanisms, messaging plays a crucial role in serverless components integration. Examples of messaging and streaming solutions include AWS SQS (Amazon Web Services, 2021c), Apache Kafka (Apache Software Foundation, 2021), and RabbitMQ (Pivotal, 2021).

Generally, multiple event sources such as AWS Alexa (Amazon, 2021), IBM Watson (IBM, 2021b), or GitHub (GitHub, 2021) are not related to particularly-large dimensions and instead represent particular use cases, which are covered by the Special-purpose Service dimension. The list of supported specialized service offerings varies drastically from platform to platform and might be a major factor influencing the choice of a suitable platform (Yussupov et al., 2019a).

Finally, a platform might provide Event Source Integration options, which makes it possible to trigger functions using custom event sources. Examples of integration options might include plugin development or webhook-based integration. Essentially, the integration using proxy components such as event gateways or message queues is possible in the majority of the cases due to the loosely coupled nature of serverless applications. However, the crucial point here is that the platform’s documentation describes official ways to integrate custom event sources, for example, company’s proprietary applications emitting custom events, which hastens the overall development process.

Function Orchestration . The next significant aspect characterizing FaaS platforms is related to possible ways of orchestrating multiple functions. Apart from connecting functions by means of events and message queues, the specification of workflows (Leymann and Roller, 1999) incorporating multiple functions is another way to orchestrate complex function interactions. Therefore, support for Function Orchestration brings additional benefits to platform users. In this category, we consider only FaaS-oriented orchestrators such as AWS Step Functions or Azure Durable Functions following the definition of a function orchestrator provided in Section 4.1. Essentially, the majority of function orchestrators are separate offerings that are tailored to work with FaaS platforms and require a separate classification framework. For instance, multiple criteria from the business view can also be used to classify function orchestrators, e.g., installation, licensing, or quotas. Moreover, other orchestration aspects, e.g., expressiveness and extensibility of the underlying workflow language, require a more detailed analysis.

For the sake of brevity, we present the baseline information relevant for developers willing to start defining function orchestrations. Firstly, the Workflow Definition process might vary significantly (García López et al., 2018), e.g., a custom Domain-Specific-Language (DSL) can be used to define a function workflow, or even a standard language such as BPEL (OASIS, 2007). Another option is to implement an orchestrating function in a general-purpose programming language such as Java, which will be responsible for calling other involved functions and aggregating the results. Here, the execution of orchestrating functions is controlled by the function orchestrator that handles stateful operations or error handling, for instance, making this option not valid for programming languages that are not explicitly supported by the orchestrator. Another dimension to consider is the presence of documentation for Control Flow Constructs, e.g., to understand how parallel or sequential task execution can be modeled or whether it is possible to handle errors during the workflow execution. Additionally, function orchestrators can impose Quotas on certain aspects of function workflows execution. For example, the overall Execution Time might be restricted or the Task Input and Output Size can be limited to a particular value (Yussupov et al., 2019a).

Testing and Debugging . Another crucial set of mechanisms is related to testing and debugging of standalone functions and entire serverless applications. While FaaS platforms are typically not responsible for the code development, additional ways to test Functional and Non-functional aspects of deployed functions can be provided, e.g., unit and integration testing, or load testing. For example, a platform might offer mechanisms for facilitating unit testing with platform-specific libraries, or verifying function invocation using dedicated CLI commands. Moreover, a combination of Local and Remote debugging mechanisms might be provided by the platform. In all these cases, both platform-native and third-party tooling may provide the possible set of solutions.

Observability . The presence of mechanisms for observing serverless applications is a crucial factor for deciding on the FaaS platform. For instance, platforms might provide various Logging and Monitoring options including both platform-native tooling and third-party tooling. Additionally, platforms can provide documented ways to integrate existing tools, e.g., using a push-based or pull-based integration approaches.

Application Delivery . The next category groups together dimensions related to facilitating the delivery of developed applications. To hasten application deployment, various Deployment Automation tools can be supported by the platform. For example, a platform-native deployment automation tool such as AWS Cloud Formation (Amazon Web Services, 2021d), or a third-party tool such as the Serverless Framework (Serverless, Inc., 2021) can be present. Moreover, presence of documented CI/CD Pipelining ways can facilitate the DevOps processes.

Code Reuse . The ability to use existing applications as a basis for implementation as well as having access to exemplary code and configuration snippets can facilitate reducing the time to market. Essentially, we distinguish two separate dimensions of Code Reuse, namely the availability of supported Function Marketplaces and Code Sample Repositories, which are actively-maintained by the platform’s provider or by its open source community.

Access Management . Finally, FaaS platforms might provide various Access Management options related to using the platform from both, developer’s and user’s perspectives. For example, a platform can provide native or support external Authentication mechanisms. Additionally, there might be supported Access Control mechanisms for defining the access rules for functions and related resources that interact with them, e.g., forbidding a function to access a particular data store resources.

6. FaaS platform technology review
In this section, we present the second contribution of this article, which is given by the results of the FaaS platforms review using the classification framework introduced in Section 5. As for the presentation of our classification framework, we first discuss the review results relevant for the business view, followed by the technical view. The dataset containing the review results with references to data sources is also publicly available on Zenodo (Yussupov et al., 2020).

6.1. A business view on FaaS platforms
The business view of our classification framework (Section 5.1) provides various categories for classifying and comparing existing FaaS platforms at a high-level. These high-level categories can be of help for researchers and practitioners willing to identify FaaS platforms suitable for hosting existing or new FaaS-based applications by focusing only on those platforms that adhere to high-level projects’ requirements. Such top-down classification approach helps eliminating the need to delve into technical details of platforms that could be ignored beforehand.

In the following, we present and discuss the classification of the ten FaaS platforms selected in Section 4, based on the categories in the business view of our classification framework presented in Section 5.1.

License.
The different licensing options used by the considered FaaS platforms are listed in Table 3. As expected, all commercial solutions are licensed under provider’s own proprietary license. Non-commercial solutions instead mainly use the permissive Apache 2.0 License, except for OpenFaaS, which uses the permissive MIT License.


Download : Download high-res image (90KB)
Download : Download full-size image
Installation.
Table 4 classifies the considered FaaS platforms by indicating whether they are available as-a-service or whether they can be installed on-premises. Not surprisingly, commercial FaaS platforms are all offered as-a-service. MS Azure Functions also supports installing the Azure Functions Host, which enables running serverless applications on Linux, Kubernetes, MacOS and Windows.


Table 3. Classification of FaaS platforms, based on the Licensing category in the business view of our classification framework.

License	Type
Apache Openwhisk	Apache 2.0	Permissive
AWS Lambda	AWS service terms	Proprietary
Fission	Apache 2.0	Permissive
Fn	Apache 2.0	Permissive
Google Cloud Functions	Google Cloud platform terms	Proprietary
Knative	Apache 2.0	Permissive
Kubeless	Apache 2.0	Permissive
MS Azure Functions	SLA for Azure
Functions	Proprietary
Nuclio	Apache 2.0	Permissive
OpenFaaS	MIT	Permissive
All open source solutions are installable on different hosts, with Nuclio also coming as-a-service, i.e., allowing to run FaaS application on hosted instances of Nuclio and providing additional features, e.g., advanced monitoring and logging solutions, and a 24/7 support (Iguazio, 2021). The target hosts actually supported by each installable platform are listed in Table 4. Kubernetes turns out to be the most supported target host, as all platforms (but Fn) can be installed on Kubernetes hosts. A reason for this is that installable platforms are either developed by extending Kubernetes itself or to be natively integrated with it.


Download : Download high-res image (75KB)
Download : Download full-size image

Table 4. Classification of FaaS platforms, based on the Installation category in the business view of our classification framework. The abbreviation “n/a” stays for “not applicable”.

Type	Target hosts
Apache
Openwhisk	Installable	Docker, Kubernetes, Linux,
MacOS, Mesos, Windows
AWS Lambda	as-a-service	n/a
Fission	Installable	Kubernetes
Fn	Installable	Docker, Linux, MacOS, Unix, Windows
Google Cloud Functions	as-a-service	n/a
Knative	Installable	Kubernetes
Kubeless	Installable	Kubernetes, Linux, MacOS,
Windows
MS Azure
Functions	as-a-service,
installable	Linux, Kubernetes, MacOS,
Windows
Nuclio	as-a-service,
installable	Kubernetes
OpenFaaS	Installable	Dockera, faasd, Kubernetes, OpenShift
a
In swarm mode (Docker, Inc., 2021).

Source code.
The availability of the source code of the considered FaaS platforms (i.e., whether they are open or closed sourced) is classified in Table 5, which also lists the open source repository and main programming language in which an open source platform is implemented. AWS Lambda and Google Cloud Functions are closed source, while MS Azure Function is partly released open source. Microsoft is indeed maintaining a GitHub repository (Microsoft, 2021d) where part of the C# sources of MS Azure Functions are publicly available. The GitHub repository provides sources of a simplified version MS Azure Functions runtime (i.e., Azure Functions Host), which can be installed and customized to run functions on-premises. The repository also provides open source tools for developing, debugging, and testing functions running on MS Azure Functions. All other platforms in Table 5 are instead fully open source and their source code can be found in corresponding GitHub repositories.

Notably, Go turns out to be the most employed programming language for developing FaaS platforms whose code is publicly available on GitHub (including MS Azure Functions). All reviewed open source platforms (but Apache Openwhisk) are developed in Go, which emphasizes the relevance of Go for cloud-native development. Additionally, this language choice could indicate that platforms are developed by extending Kubernetes, which is also developed in Go, or with the installation and integration with Kubernetes in mind.


Download : Download high-res image (70KB)
Download : Download full-size image

Table 5. Classification of FaaS platforms, based on the Source Code category in the business view of our classification framework. The abbreviation “n/a” stays for “not applicable”.

Availability	Open source repository	Programming language
Apache Openwhisk	Open source	GitHub	Scala
AWS Lambda	Closed source	n/a	n/a
Fission	Open source	GitHub	Go
Fn	Open source	GitHub	Go
Google Cloud Functions	Closed source	n/a	n/a
Knative	Open source	GitHub	Go
Kubeless	Open source	GitHub	Go
MS Azure Functions	Open sourcea	GitHub	C#
Nuclio	Open source	GitHub	Go
OpenFaaS	Open source	GitHub	Go
a
Partially open sourced.

Interface.
Table 6 classifies considered FaaS platforms under the Interface category of our classification framework, i.e., by showing whether they offer a CLI, API, or GUI, and which capabilities are featured through such interfaces. While we can observe that all platforms support all CRUD operations for serverless applications, they considerably vary in terms of interface type and of operations offered to manage the platform. A first distinction occurs between commercial platforms and open source platforms, with the former being the only providing all types of interfaces. In contrast, all open source solutions provide a command-line interface (CLI) to access and administer the platform, with only 5/7 also providing an HTTP-based API and only 3/7 featuring a GUI. It clearly emerges that CLI and API are the most important interface types, emphasizing the need for programmatic access. GUI is also supported by more than a half of reviewed platforms (6/10), as it eases manual interaction with the platform.

Finally, it is worth noting that a neat distinction between commercial platforms and open source platforms occurs as per what regards the administration of the platform itself. Commercial platforms do not provide any operation to administer the platform itself, which is a logical result of being offered as-a-service (Table 4). Conversely, given that all open source platforms come as installable solutions (Table 4), they also provide operations for deploying and enacting the platform, with some also providing operations to configure the platform. Finally, most of them do not provide means for terminating nor undeploying the platform (e.g., in the form of runnable scripts or binaries). Installable FaaS platforms indeed rely on what available on the target host for being terminated or undeployed, e.g., if deployed with Docker or Kubernetes, they rely on the latters’ functionalities to stop and delete the running Docker containers or Kubernetes deployments.


Download : Download high-res image (64KB)
Download : Download full-size image
Community.
Table 7 provides details on the community involved in the development of considered FaaS platforms.3 Notably, the amount of questions on StackOverflow demonstrates that commercial FaaS platforms are considerably more popular and used in comparison with the reviewed open source platforms. This is influenced by the difference in the maturity of the platforms themselves, by the underlying infrastructure, and by natively supported services.


Table 6. Classification of FaaS platforms, based on the Interface category in the business view of our classification framework.

Apache Openwhisk	AWS Lambda	Fission	Fn	Google Cloud Functions	Knative	Kubeless	MS Azure Functions	Nuclio	OpenFaaS
Type	cli	✓	✓	✓	✓	✓	✓	✓	✓	✓	✓
api	✓	✓	✓	✓	✓	✓		✓		✓
gui		✓		✓	✓			✓	✓	✓
App. Man.	create	✓	✓	✓	✓	✓	✓	✓	✓	✓	✓
retrieve	✓	✓	✓	✓	✓	✓	✓	✓	✓	✓
update	✓	✓	✓	✓	✓	✓	✓	✓	✓	✓
delete	✓	✓	✓	✓	✓	✓	✓	✓	✓	✓
Plat. Adm.	deployment	✓		✓	✓		✓	✓		✓	✓
configuration	✓		✓	✓		✓	✓		✓	
enactment	✓		✓	✓		✓	✓		✓	✓
termination	a		a	✓		a	a		a	a
undeployment	a		a	a		a	a		a	a
a
Termination/undeployment can be achieved by stopping/uninstalling the platform instance with host commands.


Table 7. Classification of FaaS platforms, based on the Community category in the business view of our classification framework. “n/a” stays for “not applicable”. The numbers displayed in the table were collected on July 1st, 2020.

Apache Openwhisk	AWS Lambda	Fission	Fn	Google Cloud Functions	Knative	Kubeless	MS Azure Functions	Nuclio	OpenFaaS
GitHub	Stars	4.8K	n/a	5.2K	4.6K	n/a	3Ka	5.8K	n/a	3.3K	17.9K
Forks	932	n/a	487	349	n/a	637a	591	n/a	332	1.5K
Issues	274	n/a	215	125	n/a	223a	164	n/a	51	62
Commits	2.8K	n/a	1.2K	3.4K	n/a	4.7Ka	1K	n/a	1.4K	1.9K
Contributors	180	n/a	104	86	n/a	185a	89	n/a	55	147
SO	Questions	198	16.8K	7	25	10.1K	71	8	7.2K	3	29
a
Values for the function hosting component of Knative, i.e., Knative Serving.

Among open source FaaS platforms, OpenFaaS is by far the most popular in terms of stars and it shows also a quite active community (in terms of forks, commits, and contributors). Kubeless, Fission, Apache OpenWhisk, and Fn respectively follow in term of popularity, if measured in amount of stars. The Knative platform is instead that with the most active community of contributors, with its Serving component showing a total of 4.7 K commits, by far higher if compared with all other open source platforms. Finally, Knative and Apache Openwhisk are maintained by 185 and 180 contributors, respectively, hence owning the biggest communities of contributors among investigated open source platforms. Despite all such information just provides an indicator of popularity, it can still be important while choosing a platform for prioritizing those with higher popularity or bigger community of contributors, as both indicate an active maintenance of the platform itself.


Download : Download high-res image (91KB)
Download : Download full-size image
Documentation.
Table 8 illustrates the classification of considered FaaS platforms based on the documentation they provide on development and deployment of supported applications, and on the platform itself. All considered platforms widely document how to use the platform itself and how to deploy serverless applications. Most of considered platforms (except for Knative, Nuclio and OpenFaaS) also concretely document how to develop serverless applications that can run on the platform, therein included the available runtime environments and how to exploit the support provided by the platform (see Section 5.2 for further details). In addition, each installable platform documents its deployment by providing installation guidelines.

Differences can instead be observed when looking at how considered FaaS platforms document their development and architecture. Apart from the three commercial solutions, which obviously do not publicly document their development or architecture, one would expect all open source solutions to document the architecture of the platform and its development. However, the classification of open source FaaS platforms in Table 8 shows that this is not the case. Only Apache OpenWhisk, Fission, Kubeless, and OpenFaaS fully document both their architecture and development. Fn and Nuclio document their architecture, but they only provide guidelines to contribute to its development. Conversely, Knative documents its development, without giving information on its architecture.


Download : Download high-res image (74KB)
Download : Download full-size image

Table 8. Classification of FaaS platforms, based on the Documentation category in the business view of our classification framework.

Apache Openwhisk	AWS Lambda	Fission	Fn	Google Cloud Functions	Knative	Kubeless	MS Azure Functions	Nuclio	OpenFaaS
App.	Development	✓	✓	✓	✓	✓		✓	✓		
Deployment	✓	✓	✓	✓	✓	✓	✓	✓	✓	✓
Platform	Usage	✓	✓	✓	✓	✓	✓	✓	✓	✓	✓
Development	✓		✓	a		✓	✓		a	✓
Deployment	✓		✓	✓		✓	✓	✓	✓	✓
Architecture	✓		✓	✓			✓		✓	✓
a
Only providing guidelines/code of conduct for contributing to the project.

6.2. A technical view on FaaS platforms
As shown in Section 5, FaaS platforms can be classified using numerous categories that comprise heterogeneous sets of criteria related to their technicalities. In the following, we elaborate on the results of reviewing the ten selected FaaS platforms (Table 2) using the technical view in our classification framework.

Development.
One of the main technical aspects related to development is whether a platform supports a required function runtime, which allows developing functions in a chosen programming language such as Node.js or Java. Table 9 shows the details of function runtime support for the list of reviewed platforms sorted alphabetically.


Table 9. Classification of considered FaaS platforms, based on the Function Runtimes and Runtime Customization dimensions of the Development category in the technical view of our classification framework.

Apache Openwhisk	AWS Lambda	Fission	Fn	Google Cloud Functions	Knative	Kubeless	MS Azure Functions	Nuclio	OpenFaaS
Function runtimes	Ballerina	✓						✓			
Custom Binary	✓		✓						✓	
Docker Image	✓			✓		✓	✓	✓	✓	✓
Go	✓	✓	✓	✓	✓		✓		✓	✓
Java	✓	✓	✓	✓	✓		✓	✓	✓	✓
MS .NET	✓	✓	✓	✓			✓	✓	✓	✓
Node.js	✓	✓	✓	✓	✓		✓	✓	✓	✓
Perl			✓							
PHP	✓		✓				✓	✓		✓
Python	✓	✓	✓	✓	✓		✓	✓	✓	✓
Ruby	✓	✓	✓	✓			✓			✓
Rust	✓									
Shell	✓	✓	✓					✓	✓	
Swift	✓									
Runtime customization	✓	✓	✓	✓		✓	✓	✓	✓	✓
The most popular languages are Java, Node.js, and Python, which are supported by 9/10 platforms. Java, Node.js, and Python are languages with a huge community and ecosystem of libraries, making these languages a perfect choice for fast-paced FaaS-based development. The next place is shared by Go and .NET, whose support is stated by 8/10 reviewed platforms. As shown previously, Go has become an inherent part of the cloud-native development world. Go is a compiled and fast language, which is also used to implement multiple FaaS platforms, which is an additional reason why Go is supported by most of them. Moreover, .NET is mature and well-established, with a large ecosystem of general-purpose libraries making it a good addition to the main list of supported languages. The third and fourth place among supported function runtimes are then occupied by Docker Images and Ruby, respectively. While Ruby is another good example of a popular programming language for web development, a large support for Docker Images worth a special highlight.


Table 10. Classification of considered FaaS platforms, based on the Development category in the technical view of our classification framework. D and E are used to denote that quotas are set for deployment package size and execution time, respectively. The abbreviation “n/s” stays for “not specified”, meaning that no related information is in the documentation.

IDEs and Text Editors	Client Libraries	Quotas
Apache Openwhisk	Visual Studio Codea, Xcodea	Go, Node.js	Eb
AWS Lambda	AWS Cloud9, Eclipse, Toolkit for JetBrains, Visual Studio, Visual Studio Code	Go, Java, MS .NET, Node.js, Python, Ruby, C++	D, E
Fission	n/s	n/s	n/s
Fn	n/s	Go	n/s
Google Cloud Functions	n/s	Dart, Go, Java, MS .NET, Node.js, Python, Ruby	D, E
Knative	n/s	n/s	n/s
Kubeless	Visual Studio Code	n/s	n/s
MS Azure Functions	Visual Studio, Visual Studio Code	Java, MS .NET, Python	D, Eb
Nuclio	Jupyter Notebooks	Go, Java, MS .NET, Python	n/s
OpenFaaS	n/s	n/s	n/s
a
Deprecated/No longer maintained.

b
Bounded by default, but can be configured to unset quota.

Essentially, supporting Docker Images as a function runtime allows developing and running functions in any programming language assuming that all required dependencies can be included together with the function’s logic and the resulting container is compatible with the FaaS platform, i.e., a platform is able to invoke the function and pass the event data. However, implementing function as container images requires more effort, since the underlying container has typically to implement a specific interface allowing the platform to interact with the function within the container. Docker image can also encapsulate custom binaries, support for which is stated separately by several reviewed platforms, e.g., Nuclio and Kubeless. The main difference is in which kind of artifacts are used as an input for deploying the function, i.e., a Dockerfile or the binary with a specification of its invocation details.

Additionally, supporting Docker images is one of the possible ways to enable the Runtime Customization since a function implemented in a non-supported programming language can be invoked by the platform. However, there are other ways to customize function runtimes. For example, in some platforms the runtime support is implemented via dedicated container images, e.g., for running Java8 applications. In such cases, extending the runtime might also mean building a modified runtime container image on top of an existing image, e.g., to add a particular library dependency. Most of the reviewed platforms provide a description of runtime customization options.

The classification of considered FaaS platforms based on the Development category is completed by checking whether each FaaS platform provides plugins for IDEs and rich text editors, as well as language-specific client libraries for programmatic access to the API of the platform. Table 10 shows the details about supported IDEs and Text Editors (e.g., in the form of plugins) and Client Libraries. One can readily observe that the presence of platform-specific IDEs or of plugins for existing IDEs is rarely the case, especially for open source FaaS platforms.

In addition, most of the considered platforms (6/10) shown in Table 10 provide client libraries for existing programming languages, which wrap the platforms’ APIs to facilitate the development of serverless applications (e.g., by easing the use of platform-specific libraries to work with typed data or events).

Finally, the quotas on package size and function execution time are mainly imposed by commercial platforms. On the other hand, while in most cases open source platforms do not impose any quotas, it is typically possible to configure limits, e.g., to impose restrictions on specific resource types consumption. The review results in Table 10 show the platforms that impose quotas by default, as this information might influence the way platform-specific applications need to be developed. For example, if the function’s execution time is restricted, developers might need to optimize the code execution time. Often, commercial platforms offer plans with different quotas, and in some cases quotas can be reconfigured or unset, e.g., execution time in Azure Functions.


Download : Download high-res image (85KB)
Download : Download full-size image
Version management.
The results for versioning support with respect to single functions and application that represent a combination of multiple functions and resources are shown in Table 11. One interesting fact is that some reviewed platforms tend to omit the notion of a serverless application and rather focus on deploying single functions. For example, Knative does not differentiate between functions and serverless applications, since a Service in Knative represents a container. While in theory a service could also contain multiple functions, the documentation does not provide any details on such deployment strategy and how internal functions can be distinguished. As a result, application versioning in such platforms is not really

possible even implicitly, e.g., by establishing certain naming conventions for applications. Secondly, most platforms do not offer dedicated versioning mechanisms, which makes only implicit versioning possible. In some cases, there are rudimentary versioning capabilities, which however cannot be considered dedicated versioning mechanisms. For example, in Apache Openwhisk there is an internal version property in metadata, which is assigned automatically after the deployment but cannot be managed. The only documentation describing both function- and application-level versioning is AWS Lambda, where applications can be defined and managed using AWS SAM templates.


Download : Download high-res image (61KB)
Download : Download full-size image

Table 11. Classification of considered FaaS platforms, based on the Version Management category in the technical view of our classification framework. D and I are used to denote the possible values dedicated mechanisms and implicit versioning, respectively. The abbreviation “n/s” stays for “not specified”, meaning that a platform does not explicitly mention the versioning of serverless applications.

Application versions	Function versions
Apache Openwhisk	I	I
AWS Lambda	D	D
Fission	I	I
Fn	I	D
Google Cloud Functions	I	I
Knative	n/s	D
Kubeless	n/s	I
MS Azure Functions	I	I
Nuclio	n/s	D
OpenFaaS	n/s	I
Event sources.
The detailed results of the review for this category are shown in Table 12. There are several observations related to the Endpoint event sources category that can be highlighted. Firstly, all platforms provide capabilities to synchronously invoke functions exposed as endpoints using HTTP protocol, whereas the majority (7/10) of reviewed platforms do not document support for asynchronous invocation of endpoints. In addition, almost all platforms (9/10) provide mechanisms to customize endpoint names and the majority of platforms allow securing the endpoint communication using HTTPS.

Scheduled function invocation is also supported by the majority of platforms (9/10), as described by the Scheduler category. The scheduling is typically time-based, and it is implemented by exploiting cron jobs. The definition of time-based scheduling slightly varies among considered platforms, mainly in terms of the required formatting.

Different considerations instead apply to triggers related to Data Stores and Message Queues. Most open source FaaS platforms (4/7) indeed do not document any support for event sources in the Data Store category, neither for file level data stores nor for relational and NoSQL databases. There are some exceptions: Knative’s documentation lists commercial and open source data stores as supported, Apache Openwhisk states support for IBM’s NoSQL database called Cloudant, and OpenFaaS describes how Min.io and Redis can be integrated. The main reason for this is that open source FaaS platforms come as distinct and standalone products, which typically do not come with a rich set of natively integrated services at a first place, unlike commercial FaaS platforms. Not surprisingly, all commercial FaaS platforms provide built-in support for multiple data stores originating from the same provider, e.g., AWS Lambda can be seamlessly integrated with the object storage service offering called AWS S3, and Amazon’s NoSQL database called DynamoDB.

In the Message Queue category, similar as with data stores support, commercial FaaS platforms focus on provider-specific message queues such as AWS SQS and AWS SNS for AWS Lambda or Azure Queue Storage for Azure Functions. As can be seen in Table 12, the support for message queues is stated by the larger part (4/7) of the reviewed FaaS platforms. This list includes both open source messaging solutions such as RabbitMQ, and commercial solutions such as Google Cloud Pub/Sub (Google, 2021b). Likewise, for the Stream Processing Platform category, commercial

FaaS platforms provide support for provider-specific services such as Google Cloud Pub/Sub for Google Cloud Functions or Azure Event Hubs for Azure Functions. In case of open source platforms, Apache Kafka is the most supported (6/7) stream processing platform, whereas in some cases support for commercial stream processing offerings is provided as well.


Table 12. Classification of considered FaaS platforms, based on the Event Sources category in the technical view of our classification framework. n/s stays for “not specified”, meaning that no related information is provided in the documentation.

Apache Openwhisk	AWS Lambda	Fission	Fn	Google Cloud Functions	Knative	Kubeless	MS Azure Functions	Nuclio	OpenFaaS
Endpoint	Synchronous call	HTTP	HTTP	HTTP	HTTP	HTTP, RPCb	HTTP	HTTP	HTTP	HTTP	HTTP
Asynchronous call	HTTP	HTTP	n/s	n/s	n/s	n/s	n/s	n/s	n/s	HTTP
Endpoint customization	✓	✓	✓	✓	✓	✓	✓	✓	✓	n/s
TLS support	✓	✓	✓	n/s	✓	✓	✓	✓	n/s	✓
Data Store	File Level	n/s	AWS S3	n/s	n/s	Google Cloud Storage	Google Cloud Storage	n/s	Azure Blob Storage	n/s	Min.io
Database Mode	IBM Cloudant	Amazon DynamoDB	n/s	n/s	Cloud Firestorec, Firebase Realtime Databasec	Apache CouchDB, AWS DynamoDB	n/s	Azure Cosmos DB	n/s	Redis
Scheduler	✓	✓	✓	n/s	✓	✓	✓	✓	✓	✓
Message Queue	n/s	AWS SQS, AWS SNS	Azure Storage Queue	n/s	Google Cloud Pub/Sub	AWS SQS, AWS SNS, Google Cloud PubSub	n/s	Azure Queue Storage, Azure Service Bus	RabbitMQ, MQTT	AWS SQS, AWS SNS, MQTT
Stream Processing Platform	Apache Kafka, IBM Message Hub	Amazon Kinesis	Apache Kafka, NATS	n/s	Google Cloud Pub/Sub	Apache Kafka, AWS Kinesis, Google Cloud Pub/Sub	AWS Kinesis, NATS, Apache Kafka	Azure Event Hubs	Apache Kafka, AWS Kinesis, Iguazio Data Science Platform, Azure Event Hubs, NATS	Apache Kafka, NATS
Special-purpose Service	GitHub, Slacka, Weather Company Dataa, IBM Push Notificationsa, Websocket APIa	AWS* service offerings	KubeWatcher	n/s	Google* service offerings	Apache Camel, Kubernetes event, GitHub, BitBucket, GitLab, Google Cloud Scheduler, AWS CodeCommit, AWS Cognito, FTP/SFTP, Heartbeat events, Websocket	n/s	MS Azure* service offerings	n/s	Azure EventGrid, IFTTT, VMware vCenter
Event Source Integration	Hooks, polling, connection patterns	Event source mappings	Plugins	n/s	Webhooks	Plugins	Plugins	Custom I/O bindings	n/s	Connector Plugins
a
Only one-directional integration.

b
To be used for testing purposes.

c
Feature is in a pre-release state.

For the Special-purpose Service category, there is no clear pattern on the choice of supported services. On the one hand, commercial providers focus on integrating their FaaS offerings with the ecosystem of provider-specific services they offer (e.g., AWS Lambda integrates with the ecosystem given by AWS* service offerings). On the other hand, open source platforms support a variety of external services, e.g., GitHub (2021), Slack (2021), or IFTTT (2021). To a large extent, the availability of certain services is driven by the needs of open source contributors, making platforms very heterogeneous under this dimension.

Finally, as shown in the Event Source Integration category, the reviewed platforms mention multiple possible ways to integrate custom event sources, e.g., plugin development, webhooks, or polling. Essentially, one of the most common ways to integrate custom event sources that is not always listed explicitly is by means of messaging. However, since out-of-the-box integration typically requires less effort, it is more beneficial to have an explicitly-supported integration for a desired event source.


Download : Download high-res image (137KB)
Download : Download full-size image
Function orchestration.
Table 13 presents the results of the platforms review with respect to the Function Orchestration category. Orchestrating multiple functions is an important task, with the majority of reviewed FaaS platforms (6/10) providing a dedicated function orchestrator aimed to facilitate this task. Furthermore, in most cases orchestrators are provided as standalone components or service offerings, e.g., Openwhisk Composer or Azure Durable Functions. In this review, we do not consider function orchestration using general-purpose workflow engines, e.g., Google Composer is based on Apache Airflow.


Table 13. Classification of considered FaaS platforms, based on the Function Orchestration category in the technical view of our classification framework. C denotes custom DSL, and O denotes orchestrating function, with the list of supported programming languages for developing orchestrating functions given in square braces. The abbreviations “n/s” and “n/a” stay for “not specified” and “not applicable”, respectively.

Orchestrator	Workflow definition	Control flow described	Quotas
Apache Openwhisk	Openwhisk composer	O [JavaScript, Python]	✓	Execution time
AWS Lambda	AWS step functions	C	✓	Execution time, I/O size
Fission	Fission workflows	C	✓	n/s
Fn	Fn Flow	O [Java]	✓	n/s
Google Cloud Functions	n/s	n/a	n/a	n/a
Knative	Knative eventing	C	✓a	n/s
Kubeless	n/s	n/a	n/a	n/a
MS Azure Functions	Azure durable functions	O [C#, JavaScript]	✓	n/s
Nuclio	n/s	n/a	n/a	n/a
OpenFaaS	n/s	n/a	n/a	n/a
a
Only sequence and parallel execution are supported.

Half of the reviewed orchestrators allows defining workflows using so-called orchestrating functions, which define the required control flow involving multiple functions. Here, orchestrators typically support less programming languages for defining workflows, in comparison with supported function runtimes. Moreover, a set of supported control flow constructs such as sequences, exclusive and parallel gateways, is not always defined by the language itself. For example, Azure Durable Functions relies entirely on the constructs of the underlying language, i.e., JavaScript or C#. Openwhisk Composer also allows defining orchestrations using JavaScript or Python functions, and it also introduces a set of so-called combinators, i.e., module-specific commands representing workflow constructs. For instance, a loop in Openwhisk Composer-based workflow is defined via a module-specific command composer.repeat instead of the regular for loop.

AWS Lambda, Fission and Knative instead allow orchestrating functions by relying on DSL-based workflow definitions, e.g., AWS Step Functions provides a custom DSL for composing functions on AWS Lambda. The list of supported control flow constructs is defined by the DSL itself, and it can vary significantly. For example, the Eventing component of Knative allows defining sequences and parallel executions, while the orchestrators provided by AWS Lambda and Fission feature more expressive power enabling the description of more complex workflows.

Finally, most platforms do not specify any quotas for limiting the execution of the workflows orchestrating functions. The only exceptions are Apache Openwhisk and AWS Step Functions, which allow to set timeouts for establishing maximum task execution time, with AWS Step Functions also allowing to limit I/O size.


Download : Download high-res image (65KB)
Download : Download full-size image
Testing and debugging.
Table 14 illustrates the review results regarding platform-specific testing mechanisms. The majority of reviewed FaaS platforms (6/10) documents some features related to functional testing. As testing of the function code is not a direct responsibility of a FaaS platform, most platforms just provide mechanisms for invoking deployed functions for testing purposes, e.g., using a dedicated CLI command or GUI.

In particular, Apache Openwhisk provides a tool for testing the invocation of NodeJS functions, AWS Lambda provides a GUI to invoke deployed functions for testing purposes, and Fn offers a function development kit (FDK) for Java, which facilitates implementing unit tests. AWS Lambda, Google Cloud Functions and MS Azure also provide guidelines on how to exploit external tooling for functional testing of serverless applications, typically referring to the platform-specific IDE plugins they provide (formerly reported in Table 10). AWS Lambda also illustrate some aspects of non-functional testing, and in particular related to load testing of serverless applications.

The review results related to provided debugging mechanisms are shown in Table 15. One observation is that all reviewed FaaS platforms document mechanisms mainly related to local debugging. Not surprisingly, the commercial platforms offer advanced debugging solutions, as all of them provide dedicated tooling for step-through debugging of functions. Open source platforms instead mainly document log-based debugging, which can be done using either platform-specific tooling or tools supported by the underlying hosting platform, e.g., the kubctl tooling from Kubernetes. Only in few cases (2/10), platforms do not explicitly provide any information related to debugging, even if they may still support log-based debugging or debugging through available external tools. Overall, both testing and debugging mechanisms provided by open source FaaS platforms are rather rudimentary, whereas commercial platforms often offer more features.


Download : Download high-res image (91KB)
Download : Download full-size image
Observability.
This category covers logging and monitoring dimensions of FaaS platforms, and the respective classification of platforms is shown in Table 16. As with other tooling-related categories, commercial platforms provide standalone logging and monitoring solutions.


Table 14. Classification of testing mechanisms for considered FaaS platforms. F and N denote functional and non-functional testing mechanisms, respectively. The abbreviation “n/s” stays for “not specified”, meaning that no related information is documented.

Testing mechanisms	Documented features
Apache Openwhisk	F	Function invocation testing
AWS Lambda	F, Na	Function invocation testing, testing using external tools
Fission	F	Function invocation testing
Fn	F	Unit testing of Java functions
Google Cloud Functions	Fa	Testing using external tools
Knative	n/s	n/s
Kubeless	n/s	n/s
MS Azure Functions	Fa	Testing using external tools
Nuclio	n/s	n/s
OpenFaaS	n/s	n/s
a
Only guidelines provided.


Table 15. Classification of debugging mechanisms for considered FaaS platforms. L and R denote local and remote debugging, respectively. The abbreviation “n/s” stays for “not specified”, meaning that no related information is documented.

Debugging mechanisms	Documented features
Apache Openwhisk	n/s a	n/s
AWS Lambda	L	Step-through debugging using IDE plugins and AWS SAM CLI
Fission	L	Log-based debugging using platform’s CLI tool
Fn	L	Log-based debugging using platform’s CLI tool
Google Cloud Functions	L	Step-through debugging using dedicated functions development framework
Knative	Lb	Log-based debugging using Kubernetes
Kubeless	Lb	Log-based debugging using Kubernetes
MS Azure Functions	L	Step-through debugging using dedicated functions development framework
Nuclio	n/s	n/s
OpenFaaS	L	Log-based debugging using platform’s CLI tool
a
A debugging tool for NodeJS applications is available, but deprecated.

b
Only through features of the underlying hosting environment.

For example, Amazon offers AWS CloudWatch (Amazon Web Services, 2021e) and AWS CloudTrail (Amazon Web Services, 2021f) for monitoring and logging of functions hosted on AWS Lambda. Likewise, Microsoft provides Azure Application Insights (Microsoft, 2021e) and Google offers its Operations suite (formerly Stackdriver) (Google, 2021c). In contrast, open source platforms rely on external tooling, e.g., using a combination of Prometheus (Prometheus Authors, 2021) and Grafana (Grafana Labs, 2021) for monitoring, or combining ElasticSearch (Elasticsearch B.V., 2021a) and Kibana (Elasticsearch B.V., 2021b) for logging. Nuclio and Knative support integration with commercial monitoring and logging services, i.e., Azure Application Insights and Google Cloud Operations, respectively. Most reviewed open source platforms (5/7) document integration with external logging and monitoring tools. The integration is achieved by configuring the platform to send events and logs to an external endpoint (push-based) or vice versa, i.e., when an external component pulls events and logs from the platform (pull-based). Additionally, Fission allows using the Istio service mesh and installing add-ons, e.g., for monitoring and distributed tracing.


Download : Download high-res image (70KB)
Download : Download full-size image
Application delivery.
The results of the review related to the aspects of application delivery are shown in Table 17, with several interesting observations. Most platforms rely on some form of declarative deployment modeling (Endres et al., 2017), either by using proprietary tools and formats


Table 16. Classification of considered FaaS platforms, based on the Observability category in the technical view.

Monitoring	Logging	Tooling Integr.
Apache Openwhisk	Kamon, Prometheus, Datadog	Logback (slf4j)	n/s
AWS Lambda	AWS CloudWatch	AWS CloudTrail, CloudWatch	n/s
Fission	Istio  Prometheus	Fission Logger  InfluxDB,
Istio  Jaeger	Using a service mesh
Fn	Prometheus, Zipkin, Jaeger	Docker container logs	Push-based
Google Cloud Functions	Google Cloud Operations	Google Cloud Operations	n/s
Knative	Prometheus  Grafana, Zipkin, Jaeger	ElasticSearch  Kibana, Google Cloud Operations	Push-based
Kubeless	Prometheus  Grafana	n/s	n/s
MS Azure Functions	Azure Application Insights	Azure Application Insights	n/s
Nuclio	Prometheus, Azure Application Insights	stdout, Azure Application Insights	Push-based, pull-based
OpenFaaS	OpenFaaS Gateway  Prometheus	Kubernetes cluster API, Swarm cluster API, Loki	Pull-based
(e.g., Azure Resource Manager or AWS SAM) or by relying on the deployment automation featured by their underlying hosting environments (e.g., declarative deployments using custom resource definitions for Kubernetes-based platforms). In open source platforms, the deployment is often automated by using platform-native CLI tools that consume declarative application specification as an input. Another thing worth mentioning is that the Serverless Framework, a popular solution for automating the deployment of FaaS-based applications, is explicitly mentioned only by Kubeless.


Table 17. Classification of considered FaaS platforms, based on the Application Delivery category in the technical view of our classification framework. P and T denote Platform-native tooling and third party tooling, respectively. The abbreviation “n/s” stays for “not specified”, meaning that no related information is documented.

Deployment automation	CI/CD
Apache Openwhisk	wskdeploy (P)	n/s
AWS Lambda	AWS Cloud Formation (P), AWS SAM (P)	AWS CodePipeline(P)
Fission	Fission CLI (P)	n/s
Fn	Fn CLI (P)	n/s
Google Cloud Functions	Google Cloud Deployment Manager	Cloud Build (P)
Knative	Kubernetes (P)a	n/s
Kubeless	Kubernetes (P)a,
Serverless Framework (T)	n/s
MS Azure Functions	Azure Resource Manager (P)	Azure Pipelines (P), Azure App Service (P), Jenkins (T)
Nuclio	nuctl (P)a	n/s
OpenFaaS	faas-cli (P)	OpenFaaS Cloud (P), faas-cli  (P), Circle CI (T), CodeFresh (T), Drone CI (T), GitLab CI/CD (T), Jenkins (T), Travis (T)
a
Using Kubernetes specification with Custom Resource Definitions.

Most platforms (6/10) do not document CI/CD pipelines integration. Only OpenFaaS documents integration with various third-party tools by also providing a CI/CD-optimized version of the platform that already comes with out-of-the-box integration, i.e., OpenFaaS Cloud. Commercial platforms instead typically have a dedicated CI/CD service, i.e., AWS CodePipeline, Cloud Build, or Azure Pipelines.


Download : Download high-res image (106KB)
Download : Download full-size image
Code reuse.
The classification of considered FaaS platforms related to code reuse aspects are shown in Table 17.

Notably, only AWS Lambda, MS Azure Functions, and OpenFaaS are equipped with a function marketplace where to pick already existing, runnable functions. Amazon and OpenFaaS indeed provide marketplaces including various serverless use case applications, whereas Microsoft provides a more general-purpose marketplace called Azure Marketplace, which also offers applications based on Azure Functions. At the time of writing, Google’s marketplace instead does not offer applications based on Google Cloud Functions. Going beyond marketplaces, all platforms instead provide one or more code sample repositories, which typically reside in the same or in a separate project under the same GitHub organization (see Table 18).


Download : Download high-res image (46KB)
Download : Download full-size image

Table 18. Classification of considered FaaS platforms, based on the Code Reuse category in the technical view of our classification framework. The abbreviation “n/s” stays for “not specified”, meaning that no related information is documented.

Function Marketplaces	Official code sample repositories
Apache Openwhisk	n/s	✓
AWS Lambda	AWS Serverless Application Repository	✓
Fission	n/s	✓
Fn	n/s	✓
Google Cloud Functions	n/s	✓
Knative	n/s	✓
Kubeless	n/s	✓
MS Azure Functions	Azure Marketplace	✓
Nuclio	n/s	✓
OpenFaaS	OpenFaaS function store	✓
Access management.
Finally, the results of the review related to the aspects of access management covering support for authentication mechanisms and access control are shown in Table 19. With respect to available authentication mechanisms, commercial platforms offer dedicated services such AWS IAM or Google Cloud IAM that provide a powerful and highly-flexible way to control authentication. Azure Functions instead supports usage of a Microsoft account, or authentication via a trusted third-party credentials such as Facebook, Google, or Twitter. On the contrary, most open source platforms do not cover such aspects, either by outsourcing this task to the underlying hosting environment (e.g., Kubernetes) or implementing basic authentication using shared secrets.

In terms of access control capabilities, all commercial providers support defining access rules for who can invoke functions and how functions can access specific resources. The documentation of most open source platforms does not provide details on such advanced topics. The only exception is OpenFaaS and Kubeless. OpenFaas allows configuring functions as read-only, hence preventing them to modify the underlying file system. Kubeless instead describes how to control accesses based on Kubernetes-native mechanisms. Notably, even if some Kubernetes-based platforms do not explicitly mention the support for access control mechanisms, it is still possible to reuse Kubernetes-native mechanisms to control the access to functions and/or resources.


Download : Download high-res image (91KB)
Download : Download full-size image

Table 19. Classification of considered FaaS platforms, based on the Access Management category in the technical view of our classification framework. The abbreviation “n/s” stays for “not specified”, meaning that no related information is documented.

Authentication mechanisms	Access control
Apache Openwhisk	Function invocation using shared secrets	n/s
AWS Lambda	AWS IAM	Resources, functions
Fission	✓b	n/s
Fn	n/s	n/s
Google Cloud Functions	Cloud IAM	Resources, functions
Knative	n/s	n/s
Kubeless	✓b	✓b
MS Azure Functions	Azure active directory, Facebook, Google, Microsoft account, Twitter	Resources, functions
Nuclio	n/s	n/s
OpenFaaS	Function invocation using shared secrets, built-in basic authentication or proprietary OAuth2 API access plugins	Resourcesa
a
Functions can be made read-only to forbid modifying the file system.

b
Kubernetes-based mechanisms are described in the documentation.

7. FaaStener: Platform selection support system
To facilitate the storage and usage of collected data for the FaaS selection process, we implemented an open source FaaS Platforms Selection Support System, called FaaStener.4 FaaStener is a web-based application developed in Angular5 and Angular Material6 components library providing a graphical user interface for interacting with the platform’s data (Fig. 4).

FaaStener enables users to browse the information for a chosen reviewed platform, to perform a multi-attribute search for suitable FaaS platform based on the specified requirements (e.g., taken from the business view, from the technical view, or from a combination of the two) and to visualize the corresponding results, which significantly improves the usability of our classification framework and technology review. Another advantage is the possibility to perform feature-wise comparison of multiple platforms by simultaneously looking at their classification in separate tabs of the browser.


Download : Download high-res image (690KB)
Download : Download full-size image
Fig. 4. FaaStener: A FaaS platforms selection support system.

FaaStener has been intentionally designed to ease the maintenance and extension of the systematic knowledge base it enables browsing, which is currently constituted by the results of our technology review. The technology review results are indeed encoded as JSON files, whose structure represents the overall structure of our classification framework. Since FaaStener is open sourced, updating information on an already reviewed FaaS platform or adding a new platform just requires to update or upload the corresponding JSON files by exploiting the mechanism of pull requests in GitHub, which allows to accept contributions from all interested parties. To facilitate the contribution process, FaaStener provides the relevant documentation and resource links in a dedicated site section.

8. Discussion
In this section, we discuss the key observations made when conducting this study related to the FaaS platforms review results and specific to the platform selection process.

As it can be seen from the results presented in Section 6, reviewed FaaS platforms feature multiple similarities in various dimensions. All open source platforms use permissive licenses, and in certain cases they are related to commercial products too. For example, Apache Openwhisk is used as a basis for IBM’s Cloud Functions7 and Fn is a basis for Oracle’s Functions.8 In addition, Azure Functions runtime’s source code is also publicly-available under a permissive license. The overall trend to make platform’s source code publicly-available simplifies the development and testing process and it facilitates using FaaS platforms (and reusing existing functions) outside purely-serverless contexts, e.g., as task-scheduling middlewares in loosely-couple component architectures.

While most open source platforms are tailored towards installation in container orchestration platforms such as Kubernetes or Docker Swarm, it is also possible to install them in smaller scale environments, e.g., local machines for development purposes. Moreover, such ease of installation allows mixing multiple platforms, e.g., within one Kubernetes cluster, to benefit from stronger sides of several platforms simultaneously. Due to the openness of the source code and active communities built around the reviewed platforms, the task of introducing new features becomes straightforward. Yet still additional efforts are needed as opposed to commercial platforms offering a significantly-larger number of out-of-the-box features. Moreover, the platform extensibility task in most cases requires the knowledge of Go, as most reviewed platforms are implemented in this programming language.

Interaction using dedicated CLI tools is another common characteristic for reviewed platforms. In most cases platforms also provide a documented API to enable interaction with the API using calls over HTTP. Less frequent is the usage of GUIs, which, in case of open source platforms, typically offer less features in comparison with capabilities of corresponding CLIs and APIs. The way interfaces are documented varies from platform to platform in open source segment of our review, whereas all commercial solutions provide comprehensive descriptions of platform interfaces. Obviously, GUIs in commercial platforms offer more features than GUIs of open source platforms, also due to the fact that in open source platforms GUIs may be maintained as separate projects of smaller priority and with less active contributors.

The discrepancy between commercial and open source platforms in terms of the level of details the documentation provides is related not only to interfaces. While all reviewed platforms provide pointers on how to start working with the platform, in open source solutions it is more likely to encounter undocumented functionalities as well as outdated parts of the documentation. For example, at the time of writing this article the CLI features provided by Apache Openwhisk were not clearly described in the documentation. In addition, the reviewed platforms have active and relatively large communities built around them, making the contribution process simpler to any willing party.

It is also worth noting that data gathered using the classification framework described in Section 5 provides flexible means to compare existing platforms by mixing the higher-level requirements with precise technical needs. For instance, multiple classification dimensions can be combined to answer specific questions, e.g., whether a platform can be extended to support a new event source using a specific programming language. To answer this question, at least the data about (i) licensing, (ii) platform’s programming language, and (iii) support for event sources extensibility is needed.

At the same time, selecting a FaaS platform using the provided data is still not straightforward as it requires identifying the relevant data dimensions and designing a proper search query. Moreover, in many cases multiple platforms may be selected, hence requiring to look for a most suitable trade-off, e.g., favoring ease of extensibility over the higher degree of coupling with provider’s infrastructure. One aspect that makes the platform selection process more precise is when a concrete application data is included as a part of the search query. Adding a set of requirements targeting a concrete application instead of focusing solely on the platform might require additional information, not present in the current review. For example, more detailed information such as specific event types that have to trigger a function, support for particular software libraries or platform’s concurrency configuration specifics might be needed. Such finer-grained requirements, however, do not introduce conflicts and fit well into the overall classification framework and identified dimensions, e.g., adding event types to the event sources dimension.

Another interesting aspect influencing the selection process is the desired balance between the ease of implementation and degree of coupling for the given component architecture. Here, apart from the desired platform’s properties, a given application’s component architecture has to be analyzed with respect to desired amount of integration efforts. For instance, if a given application’s architecture also comprises “serverful” components, Kubernetes-native FaaS platforms might look more beneficial if Kubernetes is planned to be used for hosting these traditional components. On the other hand, using provider-specific services involves less integration efforts and simplifies the development. Hence, deciding on where to host particular components of the given architecture might become crucial for choosing the right platform, possibly leading to decisions to combine several FaaS platforms for different component types in the same architecture, e.g., a Kubernetes-native platform in the cluster and a commercial platform for interacting with provider-specific services.

As shown by the major discrepancies among commercial and open source platforms, the platform data are not homogeneous, e.g., supported feature sets are not always fair to compare. While still sharing some similarities, these two major platform clusters have absolutely different views on out-of-the-box integration. Open source, installable platforms do not cope with what happens outside of the platform’s boundaries as they are independent pieces of software that typically rely on external complementary solutions, e.g., event emitting components, monitoring and logging solutions. On the other hand, commercial cloud providers have the platform’s boundaries somewhat blurred. For example, major types of event sources are transparently integrated with commercial FaaS platforms, e.g., AWS Lambda is aware what kind of infrastructure services can trigger a deployed function reducing the problem to specification of proper AWS policies. As a result, to start using open source FaaS platforms, one needs to have the required infrastructure prepared, e.g., message-oriented middleware must be available and supported by the chosen FaaS platfom to enable message-based function invocation. Moreover, since installable platforms have to be deployed and managed manually together with the required infrastructure, the decision on maintaining the right degree of “serverlessness” might be needed.

Essentially, such advanced decisions require deriving composite selection metrics that can benefit significantly from the introduced classification framework and the data collected over the course of this work. However, to have a comprehensive baseline for decision-making, the selection support system needs to additionally support queries related to applications and other relevant dimensions, which are not in the scope of this work.


Table 20. Coverage of the dimensions in the (a) business and (b) technical views of our FaaS Platform Classification Framework in related work. For each classification dimension, the table indicates which related research work used it to classify at least one FaaS platform.

(a) Business view
Classification dimensions	Coverage
Licensing	License	Mohanty et al. (2018), Palade et al. (2019) and Gand et al. (2020)
Type	
Installation	Type	Lynn et al. (2017)
Target hosts	Kritikos and Skrzypek (2018)
Source code	Availability	Lynn et al. (2017) and Rajan (2018)
Open source repository	
Programming language	Mohanty et al. (2018)
Interface	Type	Kritikos and Skrzypek (2018), Mohanty et al. (2018) and Palade et al. (2019)
Application management	
Platform administration	
Community	GitHub	Stars	Mohanty et al. (2018) and Palade et al. (2019)
Forks	Mohanty et al. (2018)
Issues	
Commits	
Contributors	Mohanty et al. (2018) and Palade et al. (2019)
Stackoverflow	Questions	
Documentation	Functions	
Platform	
(b) Technical view
Classification dimensions	Coverage
Development	Function runtimes	Kritikos and Skrzypek (2018), Lee et al. (2018), Lynn et al. (2017), Mohanty et al. (2018), Spillner (2019), Rajan (2018), Palade et al. (2019), Kalnauz and Speranskiy (2019), Gand et al. (2020), Bortolini and Obelheiro (2019), Wang et al. (2018), Back and Andrikopoulos (2018) and Jonas et al. (2019)
Runtime customization	
IDEs and Text editors	
Client libraries	Kritikos and Skrzypek (2018)
Quotas	Deployment package size	Lee et al. (2018), Lynn et al. (2017), Kalnauz and Speranskiy (2019) and Bortolini and Obelheiro (2019)
Function execution time	Lee et al. (2018), Lynn et al. (2017), Bortolini and Obelheiro (2019), Wang et al. (2018), Back and Andrikopoulos (2018) and Jonas et al. (2019)
Version management	Application versions	Kritikos and Skrzypek (2018) and Lynn et al. (2017)
Function versions	Spillner (2019)
Event sources	Endpoint	Synchronous call	Kritikos and Skrzypek (2018), Lee et al. (2018), Lynn et al. (2017), Mohanty et al. (2018), Palade et al. (2019) and Back and Andrikopoulos (2018),
Asynchronous call	Kritikos and Skrzypek (2018), Lee et al. (2018), Lynn et al. (2017), Mohanty et al. (2018), Palade et al. (2019) and Back and Andrikopoulos (2018),
Endpoint customization	
TLS support	
Data store	File level	Kritikos and Skrzypek (2018), Lee et al. (2018), Lynn et al. (2017), Rajan (2018), Kumar (2019), Kalnauz and Speranskiy (2019) and Jonas et al. (2019)
Database mode	Kritikos and Skrzypek (2018), Lee et al. (2018), Lynn et al. (2017), Rajan (2018), Kumar (2019), Kalnauz and Speranskiy (2019) and Jonas et al. (2019)
Scheduler	Kritikos and Skrzypek (2018), Lynn et al. (2017) and Mohanty et al. (2018)
Message queue	Kritikos and Skrzypek (2018), Lee et al. (2018), Lynn et al. (2017), Mohanty et al. (2018), Rajan (2018), Palade et al. (2019) and Kumar (2019)
Stream processing platform	Kritikos and Skrzypek (2018), Mohanty et al. (2018), Rajan (2018) and Kumar (2019)
Special-purpose service	Lynn et al. (2017) and Kumar (2019)
Event source integration	
Function orchestration	Workflow definition	Kritikos and Skrzypek (2018), Lynn et al. (2017), García López et al. (2018) and Kumar (2019)
Control flow constructs	
Quotas	Execution Time	García López et al. (2018)
Task input and output size	García López et al. (2018)
Testing and debugging	Testing	Functional	Kritikos and Skrzypek (2018)
Non-functional	
Debugging	Local	
Remote	
Observability	Logging	Kritikos and Skrzypek (2018), Lynn et al. (2017) and Kumar (2019)
Monitoring	Kritikos and Skrzypek (2018), Mohanty et al. (2018), Palade et al. (2019), Kumar (2019) and Gand et al. (2020)
Tooling integration	
Application delivery	Deployment automation	
CI/CD pipelining	Kritikos and Skrzypek (2018), Lee et al. (2018) and Kumar (2019)
Code reuse	Function marketplace	Spillner (2019)
Code sample repository	
Access management	Authentication	Kritikos and Skrzypek (2018), Lynn et al. (2017), Kumar (2019) and Back and Andrikopoulos (2018)
Access control	Kritikos and Skrzypek (2018) and Kumar (2019)
9. Threats to validity
Wohlin et al. (2012) provide a standardized classification of threats of validity potentially affecting secondary studies. Four of such potential threats may apply to our study, namely threats to external validity, to construct and internal validities, and to conclusions validity. We hereafter discuss them and illustrate the countermeasures we adopted to mitigate them.

External validity concerns the applicability of a set of results in a more general context (Wohlin et al., 2012). Since we focused on self-declared information available on the official websites and GitHub repositories of FaaS platforms, our results and observations may only be partly applicable to the broader practices and information available on FaaS platforms, hence threatening external validity. To reinforce the validity of our findings, we organized 3 feedback sessions during our analysis of the documentation available on the websites and GitHub repositories of considered FaaS platforms. We analyzed the discussion following-up from each feedback session, and we exploited this qualitative data to fine-tune our classification framework, the actual classification of considered platforms, and the applicability of our findings. We also made our data easily accessible on Zenodo (Yussupov et al., 2020) and throughout FaaStener. The latter is open source, and its GitHub repository includes all artifacts produced during our analysis. We believe that this can help in making our classification framework, technology review, and observations more explicit and ease their applicability in practice.

Construct and internal validity instead concern the generalizability of the constructs under studies and the validity of the methods actually exploited to study and analyze data, respectively (Wohlin et al., 2012). These inherently includes the possible biases affecting our study. To mitigate both above threats, we adopted various inter-rater reliability assessment rounds, aimed at avoiding biases by triangulation (Section 4). We indeed performed various iterations among the authors both for (i) refining the initially obtained classification framework and obtaining that show in Section 5, and for (ii) cross-checking the actual classification of considered FaaS platforms until a full agreement among all authors was achieved.

Finally, threats to conclusions validity may apply depending on the degree to which the conclusions of a study are reasonably based on the available data (Wohlin et al., 2012). To mitigate this threat, we exploited theme coding and inter-rater reliability assessment to limit observer and interpretation biases, both while developing the classification framework and while actually classifying the considered FaaS platforms. The ultimate goal in both cases was indeed to perform a sound analysis of the data we retrieved from official websites and GitHub repositories of considered FaaS platforms. In addition, the conclusions drawn in this paper were independently drawn by each of the authors, and they were then double-checked against the available information in joint discussion sessions.

10. Conclusions & future work
With the ultimate goal of supporting researchers and practitioners in classifying existing FaaS platforms and choosing those most suited to their needs, we presented a classification framework and a technology review of existing FaaS platforms. Our FaaS Platforms Classification Framework enables the characterization of FaaS platforms under two different perspectives. Such perspectives are clearly shown in the FaaS Platforms Technology Review, which provides both a business and a technical view on ten existing FaaS platforms, and which was conducted using the aforementioned framework.

Our classification framework and technology review provide a more extensive classification of currently existing FaaS platforms, if compared with those already available in related work. Even if some of the classification dimensions we consider are also covered in related work, our classification is the first to cover other dimensions (Table 20). In addition, ours is the first technology review covering seven open source and three proprietary FaaS platforms, while related research efforts typically cover a smaller set of platforms, with a preponderance towards proprietary platforms (Section 3).

Apart from enabling a thorough comparison of existing FaaS platforms, our contributions result in the stemming out of various novel research and innovation directions. For instance, we observed a lack of solutions for testing, debugging and versioning FaaS-based project, especially for separately testing, debugging and versioning of FaaS-based applications from the functions used to implement them. Portability is another example of research direction stemming out from our study, as FaaS platforms resulted to be quite heterogeneous in featured triggers, in supported orchestration, monitoring, and logging solutions, and in deployment automation technologies. This obviously hampers the migration of a FaaS-based application from a FaaS platform to another, hence requiring solutions for enhancing their portability.

In addition of the above listed directions for future work, we actually plan to extend the results and support provided by the proposed classification framework, technology review, and selection support system. We intend to extend the classification framework defined in this work with other dimensions (e.g., security- or performance-related aspects), and to extend the technology review both by reviewing already considered platforms with the novel introduced dimensions and by considering other existing FaaS platforms and/or related tooling (e.g., function orchestrators). In addition, we plan to combine the categories and dimensions forming our classification framework into advanced metrics for evaluating and comparing FaaS platforms, and to exploit such advanced metrics to extend our selection support system into a full-fledged decision support system, which will be capable of providing smart informed recommendations to researchers and practitioners looking for a FaaS platform to run their applications.

CRediT authorship contribution statement
Vladimir Yussupov: Conceptualization, Methodology, Investigation, Data curation, Software, Writing - original draft, Writing - review & editing. Jacopo Soldani: Conceptualization, Methodology, Investigation, Data curation, Writing - original draft, Writing - review & editing. Uwe Breitenbücher: Conceptualization, Methodology, Investigation, Writing - review & editing. Antonio Brogi: Conceptualization, Methodology, Investigation, Writing - review & editing, Funding acquisition. Frank Leymann: Conceptualization, Methodology, Investigation, Writing - review & editing, Funding acquisition.