Abstract
Dynamic fault trees (DFTs) with spare gates have been used extensively in reliability analysis. The traditional approach to DFTs is Markov-based that may suffer from problems like state–space explosion. Algebraic-structure-based methods consume long computation time caused by the inclusive/exclusive formula. Recently, some combinatorial solutions have been applied to DFTs such as sequential binary decision diagrams (SBDD) and algebraic binary decision diagrams (ABDD). They analyze systems by the minimal cut sequence (MCQ) based on sequence-dependence. We propose an analytical method based on conditional binary decision diagrams (CBDD) for combinatorial reliability analysis of non-repairable DFTs with spare gates. A detectable component state is mined to describe the sequence-dependent failure behaviors between components in the spare gate. Minimal cut set (MCS) instead of MCQ is used for qualitative analysis to locate faults via the component state. Compared to Markov-based methods, our method can generate system reliability result with any arbitrary time-to-failure distribution for system components. Different from SBDD and ABDD, specific operation rules are proposed to eliminate inconsistencies and reduce redundancies when building a CBDD. For quantitative analysis, the CBDD simplifies computation via using the sum of disjoint products. Case studies are presented to show the advantage of using our method.

Keywords
Conditional binary decision diagram (CBDD)
System reliability
Dynamic fault tree
Conditional state transformation
Dependable computing

1. Introduction
System reliability is one of the measures of dependability in systems engineering (Commission et al., 2016). Fault Tree Analysis (FTA) is a traditional reliability analysis method that is suitable for system dependable computing. In fault trees, the dynamic fault tree (DFT) (Dugan et al., 1992, Ruijters and Stoelinga, 2015) is an extension of the static fault tree (SFT) (Vesely et al., 2002). The DTF considers functional-dependent failure and sequence-dependent failure. Compared to the static fault tree, the dynamic fault tree includes several dynamic gates such as functional-dependency (FDEP) gate, spare gate, priority-and (PAND) gate, and sequence-enforcing (SEQ) gate. As a result of dynamic behaviors like function-dependency and sequence-dependency, the reliability analysis of high-reliability systems in the critical field becomes complicated. To maintain the desired high-reliability for the system, a high degree of redundancy, dynamic redundancy management, and spares are usually required. Compared to redundancy, spares can flexibly adjust its working state by adopting three kinds of spare gates to balance its required performance and energy consumption. The spare gate (Fig. 1) is widely known as a common design technique for achieving the fault-tolerant system, which can keep the system working despite hardware failures or software errors that may cause the entire system to fail. The spare gate consists of primary components and spare components. According to the state of spare components, the spare gate has three different types: hot spare (HSP [Fig. 1(a)]) gate, warm spare (WSP [Fig. 1(b)]) gate, and cold spare (CSP [Fig. 1(c)]) gate (Dugan et al., 1992, Dugan and Doyle, 1996, Misra, 2008). For considering energy consumption, the HSP gate is the most expensive of the three types of spare gates since the primary component and spare components are both in a working state. The hot spare component can be placed into service immediately when the current primary component (an initial primary component or an activated spare component) fails. It is usually used in applications whose failure resume time is minimal such as A/V switches, computers, network printers, and hard drive data backup systems. In contrast, the CSP gate is the most economical of the three types of spare gates since its spare component is always in an unpowered state before the current primary component failure activates the cold spare component. The cold spare component requires a long time to replace the faulty component in the CSP gate. Hence, the CSP gate is typically applied in places where power is limited such as satellites and conventional submarines. The WSP gate is a compromise solution between the HSP gate and the CSP gate since the warm spare component is in a dormant (standby) state that is power-on but not actively operating. Compared to the HSP gate, the WSP gate consumes much less power before the warm spare component is activated. Compared to the CSP gate, the WSP gate has a shorter response time to let the spare component replace the faulty component and restore the system. The WSP gate is commonly used in sensor networks, disk management systems, and vehicle management systems.

In the DFT reliability analysis, the spare gate is one of the most complicated cases. It includes sequence-dependent failure behaviors and different failure probabilities in the same spare component in different states. Spare gate fires when all components including the primary component and the spare components fail (shared spare component may be occupied rather than fail). In the CSP gate, all the spare components may fail only after the current primary component fails. Note that cold spare component is not considered to have failed before it is activated (Dugan et al., 1992). In this case, the cold spare component has two failure probabilities: one is 0 before it is activated and the other is 
 after it is activated. Unlike the cold spare component, however, the warm spare component has no sequential fault restriction if specific failure states are not concerned; it also has two failure probabilities: one is 
 in the dormant state and the other is 
 in the working state. In the HSP gate, the hot spare component failure is neither sequence-dependent nor has different probabilities. Hence, if we only consider failure behaviors, an HSP gate with non-shared spares is equivalent to a logic AND gate, which has no sequence-dependent failure behaviors. As a result, the spare gate in this paper mainly involves CSP and WSP gates except for Fig. 2 (hot spare mode). Current approaches to reliability analysis of dynamic fault trees (DFTs) with spare gates are Markov-based methods (Misra, 2008), simulation-based methods (Long, 2002, Merle et al., 2016), Bayesian-network-based methods (Boudali and Dugan, 2005, Kabir et al., 2014) and algebraic-structure-based methods (Merle et al., 2011a, Merle et al., 2011b). Markov-based methods may suffer from the state–space explosion problem when the scale of DFTs is large (Ruijters and Stoelinga, 2015). However, it can achieve the reliability analysis of large DFT via reducing state–space for cases mentioned in Volk et al., 2016, Volk et al., 2018. Also, it is only suitable for the exponential time-to-failure probability distribution of basic events. Simulation-based methods eliminate the exponential time-to-failure distribution restriction, but they cannot offer accurate results. Bayesian-network-based methods have similar computation complexity troubles as the Markov-based methods. With the help of temporal logic, algebraic-structure-based methods (Merle et al., 2011a) use a symbol  to denote a sequential relationship “before”. Algebraic-structure-based methods can handle any arbitrary time-to-failure probability distribution but they may require using the I/E (Inclusive/Exclusive) formula for reliability computation. However, they will relate to a huge amount of computation when minimal cut sequences (MCQs) are too numerous. In recent years, BDD-based methods are used for DFTs analysis. Converting the fault tree to binary decision diagram (BDD) is an efficient method to find MCS (Akers and B, 1978). After converting, the BDD has exponential complexity in the worst case, but it also has linear complexity in the best case (Ruijters and Stoelinga, 2015).


Download : Download high-res image (85KB)
Download : Download full-size image
Fig. 1. Three types of the spare gate. (a) HSP, (b) WSP and (c) CSP.

We mine a detectable component state in spare gates. According to this specific state, we create a certain conditioning event that implies sequence-dependent behaviors in spare gates. Thus, the DFT described in our paper is a fault tree that consists of spare gates and static logic gates (logic AND gate and/or logic OR gates). Our proposed method also is a combinatorial solution involving an extended BDD.

Firstly, we convert the DFT to the conditional fault tree (CFT) by using some conditioning events that relate to the status of the component. Secondly, according to the proposed rules, a system CBDD model corresponding to the CFT is built. At last, a system CBDD model can be evaluated by translating paths from the top to terminal “1” to algebraic expressions of sequence-dependent.

Note that, the DFT described in our paper is a fault tree that consists of spare gates and static logic gates (logic AND gate and/or logic OR gates). We do not consider voting gates separately since it can be replaced by the combination of logic OR and AND gates (Ruijters and Stoelinga, 2015).

The remainder of this paper is organized as follows. Section 2 presents recent related work regarding reliability analysis using BDDs and multiple-valued decision diagrams (MDDs). Section 3 introduces some concepts of static transform and basics of BDD. Section 4 presents the conditional state transformation. Section 5 shows the construction of the CBDD. How to use a CBDD for reliability analysis based on DFTs with spare gates is presented in Section 6. In Section 7, three practical DFT case studies are illustrated for the reliability analysis using CBDD in detail. Section 8 concludes the paper.

2. BDD Related work
Recently, many BDD-based methods were used in reliability analysis or related field. A new and efficient BDD-based method was utilized for performability analysis of -to--out-of- computing systems (Mo et al., 2018), An improved BDD can reduce memory consumption and computation time by combining truncation with modularization, which quickly obtains an accuracy probability in the fault tree analysis if a proper truncation probability is found (Deng et al., 2015). A BDD assisted with a dynamic labeling method is proposed for non-coherent fault tree analysis. The dynamic labeling can be used to reduce the number of intersections to be calculated for the determination of prime implicants (Matuzas and Contini, 2015). A BDD combined with an incremental method is used for the quantification of sequences of linked fault trees, adopting a reduction procedure that can be used individually to each fault tree defined in the sequence (Ibáñez-Llano et al., 2010). However, sequence-dependent behaviors are not considered. An analytical and combinatorial method based on sequential BDD (SBDD) was proposed for the analysis of non-repairable standby systems (Xing et al., 2012, Tannous et al., 2011) and it was improved by creating a heuristic variable index to keep the scale of resultant cut sequences as small as possible (Ge et al., 2015). However, the SBDD cannot eliminate sequence-dependent at prime events level, and it removes invalid nodes after the final SBDD has been built. The SBDD (Rauzy, 2011) that was inspired by Minato’s Zero-Suppressed BDD (Minato, 1993) used a new data structure to encode sets of sequences of basic events. All rules related to sequence algebras can be operated based on the proposed data structure. Nevertheless, it is similar to algebraic-structure-based methods and allows complex sequence-operation rules in the SBDD. Also, the SBDD is not developed based on a well-defined temporal or sequential algebra. Hence, the SBDD is complicated when conducting both qualitative and quantitative analysis of a large-scale DFT. An algebraic BDD (ABDD) on algebraic-structure-based methods was applied for the analysis of DFTs (Jiang et al., 2018), but it eliminates the invalid path after the final ABDD has been completed and relates to complex operations with temporal logical failure behaviors as well. MDD, which is an extended version of BDD, has mainly been used for multiple-state system reliability analysis. The MDD inherits all the advantages of BDD, such as no restriction on the time-to-failure distribution for the basic event in the DFT and reliability computed by the sum of disjoint product (SDP). A generalized MDD was proposed for the reliability analysis of fault-tolerant systems (Xiang et al., 2016). A multi-state MDD was presented for the analysis of multi-state systems with multi-state components (Xing and Dai, 2009). A new MDD-based analysis technique was proposed for the reliability analysis of network systems with dependent propagation effects (Mo et al., 2016). An MDD is proposed to evaluate cold standby systems via supplementing a mark to the activated event (Zeng, 2019). Some MDDs were used for the analysis of warm standby systems and cold standby systems (Zhai et al., 2013, Zhai et al., 2015a, Zhai et al., 2015b) based on fault coverage models. An efficient MDD-based method was proposed for the reliability analysis of binary-state phased-mission systems by using independent multi-valued variables to encode component failure behavior across phases (Peng et al., 2014). However, they conduct reliability analysis based on coverage models or multi-state systems rather than the DFT model. An efficient MDD-based DFT analysis approach for computing the reliability measures of large dynamic subtrees was proposed (Mo, 2014). This method can relieve the state–space explosion problem by identifying whether subtree components relate dynamic failure behaviors, but it still has the exponential limitation on basic events in dynamic gates. The above methods either cannot be directly available to DFTs or involve state–space explosions or complex sequence-dependent failure behaviors. Unfortunately, sequence-dependent failure behaviors may cause a permutation problem due to cut sequence searching in DFTs, and a permutation problem usually involves a factorial complexity problem (Dixon and Mortimer, 1996). In this paper, an analytical and combinatorial method is proposed for reliability analysis of non-repairable DFTs with spare gates while addressing problems of the existing approaches. The proposed method is based on conditional binary decision diagram (CBDD), an extended version of BDD (Bryant, 1986, Rauzy, 1993).

It is easy to understand that searching cut sets in SFTs is a mathematical combinatorial problem. The complexity of combinatorial problems is much less than that of permutation problems (Biggs and White, 1979). To reduce the complexity, a static conditional transformation of spare gates is proposed. A new conditional fault tree (CFT) is built with the static conditional transform, and the minimal cut set (MCS) replaces the MCQ. In the CFT, permutation problems are changed into combinatorial problems, since sequence-dependent failure behaviors are converted into conditional states in DFTs with spare gates. In this paper, a novel BDD (CBDD) based on the CFT is propounded for reliability analysis of DFTs with spare gates.

Note that, in this paper, different from the state based on state–space methods, the conditional state is located in the component (basic event) level rather than the gate (or system) level. We only focus on the entire system reliability evaluation and assume that the time to failure of the system components satisfies the continuous probability distribution function (PDF). The PDF of the system components can be estimated by methods of statistical inference (ALLEN AO, 1990) if it is unknown or partially unknown.

3. Static transform & binary decision diagram
A transformation from dynamic PAND gates to static AND gates with some dependent conditioning events has been presented in Xiang et al. (2013). The fault tree conditioning event relates to some specific conditions or restrictions that are used to any logic gate. With the help of the transformation, the MCQ of a DFT with PAND gates is converted into the MCS of a conditional SFT. After the transformation, the conditional AND gate is called the CAND gate. It can represent the priority relations that cannot be modeled by the PAND gate. A simple example of the transformation is shown in Fig. 2. In the CAND gate, the conditioning event “Switch Connects to Principal Supply” indicates the switch fails before the principal supply fails. In other words, it implies the sequence-dependent failure behaviors between components. The specific conditioning event can be used to achieve static transformation for PAND gates (Xiang et al., 2013). If we only consider failure behaviors, in most cases, the SEQ gate is likely to be replaced by a special case of CSP gates with non-shared spare components (Ruijters and Stoelinga, 2015, Manian et al., 1999) and the FDEP gate can be translated into a logic OR gate (Merle et al., 2011b). In some special scenarios (Boudali et al., 2010, Junges et al., 2016), it cannot achieve translation rules regarded as SEQ gates and FDEP gates. For example, an SEQ gate with a logical AND gate as the second child or an FDEP gate whose two dependent events are the inputs in a PAND gate. However, the static transformation-related complete solution of spare gates is not proposed.

BDD was first used as a new algorithm for fault tree analysis in Rauzy (1993). Unlike other methods of fault tree reliability analysis, BDD requires less memory and computation time. It is a rooted acyclic graph based on the Shannon decomposition as follows: (1)
In Eq. (1),  denotes a Boolean expression and  denotes a Boolean variable in . 
 and 
 equal 
 and 
, respectively. 
 and 
 represent  evaluated as  being one and zero, respectively.  represents the concise  format. The BDD has two branches, labeled by 0-edge and 1-edge, representing the operable state and failed state, respectively. The two BDD terminal nodes are logic value 0 and value 1. The general BDD node and prime BDD node are shown in Fig. 3.

An SFT can be converted to the BDD by recursively using the following operation rules set out in Bryant (1986). Let  represent any logic operation (AND/OR).  and  represent two Boolean expressions corresponding to the traversed sub STFs, and then we have 
  
 
 where  represents the Boolean variable order based on the heuristic method.


Download : Download high-res image (68KB)
Download : Download full-size image
Fig. 3. Two BDD nodes: (a) the general BDD node (b) the prime BDD node.

If BDDs are suitable for static fault trees, the DFT also could be converted to a certain BDD after static transformation. Thus, our combinatorial solution addressing this is presented in the following sections.

4. Conditional state transformation
A component in dynamic gates has some detectable static states when it is in different conditions such as operable, failure, and other states. In spare gates, a spare component has two states: working state and standby state. Precisely, the standby state can be divided into two states, un-power state and dormant state, which are respectively located in the CSP gate and the WSP gate. The spare component in WSP gates can fail in the dormant state. When a primary component fails, a spare component is activated and replaces the failed primary component. At this point, the spare component is working before it fails. The spare component in the working state plays a role of the primary component. It can be replaced by the other spare component as well. Generally speaking, the spare component can replace a replaceable component. The replaceable component refers to a primary component or a working spare component in the spare gate. Also, we consider that if there is an available spare component, a replaceable component will be replaced when it fails, and a spare component is operational when it replaces a component.

4.1. Conditioning event
A particular event may occur in the spare gate, which can determine the replacement behaviors between components. Here we introduce a “replacement” symbol  to represent this conditioning event, which exists only in spare gates. 
 denotes the conditioning event that a component 
 replaces a component 
, where 
 can only be a spare component while 
 is a replaceable component (either a primary component 
 or a working spare component 
). Accordingly, 
 denotes that the replacement between 
 and 
 has never happened. It is easy to understand that 
 represents the conditioning event that 
 never replaces any other component, as it is in the dormant state at all time. In this case, 
 denotes the warm spare component 
 fails in the dormant state. 
 denotes 
 replaces a certain component. It implies 
 is activated by a replaceable component. In the algebraic-structure-based method (Merle et al., 2011a), 
 denotes a spare component 
 fails after it replaces a component, and 
 denotes a spare component 
 fails while no replacing any other components. As opposed to 
 and 
, the  (conditioning event) does not imply the spare component 
 failure.

4.2. Conditional fault tree
Thanks to , the combination of component states can be considered to supersede the sequence-dependent behaviors between components in the spare gate. Based on the specific , if we only consider the non-shared spare, the WSP gate or the CSP gate can be converted into a kind of conditional SFT called CFT, as shown in Fig. 4. For the shared spare WSP gate and shared spare CSP gate, primary components could be affected by each other due to the occupation of the shared spare component. The conversion of shared spare gates (WSP gate and CSP gate) is shown in Fig. 5. For Fig. 5, it is easy to observe that the occupation of a shared spare is symmetrical for TE1 and TE2. Hence, if TE1 and TE2 are combined with a logic OR gate, we only consider the failure of P1 and P2 for the logic OR gate, but not which one will be replaced first. For  primary components and  shared spare components, each primary component corresponds to a spare gate, and we can deduce that one of the shared spare SP gates is bound to happen if  components fail. Furthermore, it can be obtained that one of the shared SP gates will happen if  primary components fail and .

Compared with the sequence-dependent failure behavior, the static transformation expression of spare gates can describe both the location and failure state of basic events. Thus, it can more accurately describe the failure process of the spare gate. Furthermore, a combination of primary events (Vesely et al., 2002) and conditioning events, instead of primary event permutation, describes the dynamic failure behavior of DFTs with spare gates.


Download : Download high-res image (389KB)
Download : Download full-size image
Fig. 5. Converting the shared spare SP gates into the CFT.

4.3. Minimal cut set vs minimal cut sequence
As a result of conditional states replacing the sequence-dependent failure behaviors, MCQ is no longer suitable for qualitative analysis of a CFT. Hence, MCS is considered to be used in qualitative analysis. However, basic events in the MCS are typically primary events (Vesely et al., 2002) which are assumed to be independent. Obviously, the conditioning events in the CFT are dependent events. According to the definition of basic events, the conditioning event is a type of basic events (Vesely et al., 2002). The MCS is the smallest combination of basic events that result in the top event. Thus, MCS can also be applied to CFTs, but the inconsistency and redundancy caused by conditioning events need to be eliminated. The replacement can only happen when the replaceable component fails. The following rules can be introduced to solve the redundancy problem: (2)
(3)
 Eqs. (2), (3) indicate if a replacement happens and if the corresponding replaceable component was bound to fail.

If a replaceable component is operational, then it is impossible to be replaced (it refers to Eqs. (4), (5)). For a spare component, “never replace” and “replace” cannot happen at the same time, which refers to Eq. (6). It is also impossible for a spare component to “never replace” and “be replaced” simultaneously, which refers to Eqs. (7), (8). A spare cannot replace more than one replaceable component at the same time as well, which refers to Eqs. (9), (11). For the same reason, a replaceable component cannot be replaced twice or more simultaneously, which refers to Eqs. (10), (12). Based on the above analysis, the following rules can be introduced to solve the inconsistency problem: (4)
(5)
(6)
(7)
(8)
(9)
(10)
(11)
(12)
 where 
 and 
 are distinct primary components in the shared spare gate. 
 and 
 are distinct working spare components in the same spare gate. 
 and 
 are distinct spare components in the same spare gate. In this paper, the conditioning event only refers to the relationship between replaceable components and spare components in spare gates. However, the conditioning event is not a primary event (the primary component failure), though it can imply the replaceable component failure. The spare gate only fires when all components fail. Hence, the conditioning event cannot appear in the MCS singly. It combines with at least one primary event. For the spare gates shown in Fig. 4, the MCS is presented as follows: 
 As we know, the CSP gate can be regarded as a special case of the WSP gate if the failure of the spare component in the dormant is not considered. Thus, the following part of this paper focuses on WSP gates. For a WSP gate, the MCS is the product of all primary events in the WSP gate if the specific failure status of the spare component is not distinguished. However, the failure probability of a spare component is different before or after the replacement. In quantitative analysis, it will be divided into two sub-events. For the convenience of engineering applications, these differences will be reflected in the MCS. For example, a WSP gate with two spare components has a primary components 
 and two spare components 
 and 
. It can be converted into a CFT, as shown in Fig. 6. Four MCSs of the CFT are as follows: 
 If MCQs are used for the above example, the six MCQs are as below: 

The symbol  denotes a sequential relationship “before”. For example, if  and  are two basic events in a DFT, then  denotes that only when the event  occurs before event , the event  will occur.

For the WSP gate with two spare components, it is evident that the quantity of MCSs is less than that of MCQs. This is because some MCSs can imply two MCQs. 
 implies 
 and 
, and 
 implies 
 and 
.


Download : Download high-res image (233KB)
Download : Download full-size image
Fig. 6. CFT of the WSP gate with two spare components.

The general non-shared spare case is the WSP gate with  spare components. In this case, the WSP gate firing will be satisfied if:

(i) All the components fail.

(ii) Each spare component can only fail in one of the two different states simultaneously. One is the failure without replacement, and the other is the failure after replacement.

According to the inconsistency rules (9) and Eq. (11), it is impossible for a spare component to replace two different replaceable components at the same time. Hence, a spare component has a unique replacement failure (failing after replacement) in one MCS. The MCS that leads to the WSP gate firing is related to a simple combination of the primary component failure state and the spare component failure state. A primary component has only one failure state, and each spare component has two possible failure states. In total,  spare components have 
 possible failure states. Therefore, the quantity of combinations of possible failure states in the non-shared general case is 
. Correspondingly, the quantity of MCSs is also 
. Compared to the MCS, MCQ is a sequence permutation with all primary events (one primary component failure and  spare components failure) in the WSP gate. In the general non-shared spare case, the quantity of MCQs is 
: 
In the qualitative analysis, the quantity of MCSs is less than that of MCQs if the WSP gate has two or more spare components. Also, as the quantity of spare components increases, the difference is more significant.

The general shared spare case is  WSP gates with  shared spare components. In this case, a single WSP gate firing will be satisfied if:

(i) Its primary component fails.

(ii) All the spare components are exhausted. Each shared spare component can only be consumed in one of three different states at the same time. One is the failure without replacement, one is the failure after replacement, and the third is the replacement in the not-self WSP gate.

Each shared spare component has two failed states that are the same as those in the non-shared WSP gate. However, it is different from the case of non-shared WSP gates. The shared spare component has one more state (occupied state) that replaces the replaceable component in the not-self WSP gate. The possible quantity of occupied states is related to the number of primary components in the shared WSP gate. In the general shared case, the quantity of primary components is , and then the shared spare component has  possible occupation states. Therefore, the shared spare component has  () possible consumed states. In total,  spare components have 
 possible consumed states. Similarly, combined with the primary component failure state, the quantity of MCSs of a single WSP gate in general shared case is 
. If , it is converted into 
, which is a general case of non-shared spare. In other words, 
 can also solve the general non-shared spare case. Thus, it is considered a general formula for a WSP gate failure. For the general shared spare case, if  components fail, one of the WSP gates is bound to fire. Additionally, the probability of occurrence of each WSP gate, in this case, is the same. Hence, the quantity of MCQs of a single WSP gate in a general shared case is 
. 
 For example, two WSP gates (with two primary components 
, 
) share two spare components (
, 
). Nine MCSs can cause one of the WSP gates to fail (the WSP gate with 
), as follows: 
 In the same condition, the quantity of MCQs is twelve. 

Typically, in mathematical theory, the complexity of the combination problem is smaller than that of the permutation problem (Lucey and Lucey, 2002). Generally speaking, the quantity of MCSs of a single WSP gate is less than that of MCQs whether it is a WSP gate that has shared or non-shared spare components if the spare components are more than one. The more spare components and the more shared WSP gates, the higher the difference. Furthermore, when the WSP gate is combined with the static gate, the difference will become more significant as well. Additionally, our MCS is more intuitive and straightforward than the MCQ for describing dynamic behaviors in spare gates since  can directly denote replacement between components.

5. Conditional binary decision diagram
Our BDD is an extension of the traditional BDD, as it involves -dependent nodes that are converted by conditioning events . Thus, to distinguish other BDDs, our BDD is called Conditional BDD (CBDD). The node in traditional BDD is considered to be -independent, but the node in CBDD may not be since the conditioning node is converted from the conditioning event. In CBDD, conditioning nodes are not the same as sequential nodes in SBDD (Ge et al., 2015) and ABDD (Jiang et al., 2018), since they cannot be represented alone and have different dependent relation. Hence, it is assumed that all of the nodes in CBDD are -independent. However, the dependent relation between CBDD nodes will be considered in the quantitative analysis. Similar to the traditional BDD, an ordering strategy of nodes is always needed since the order of input variables is also heavily relevant to the size of the CBDD. However, the solution in Rauzy (1993) cannot be directly used to the CBDD due to conditioning nodes. Also, more operational rules will be introduced to eliminate some redundancy and inconsistency.

A few solutions were proposed for an ordering strategy of BDD nodes such as depth-first-based methods (Bouissou, 1996), heuristics-based methods (Mo et al., 2013), neural network-based methods (Bartlett and Andrews, 2002), and neighbor-first-based methods (Sun and Du, 2008). However, there is no generic solution for the ordering strategy of BDD nodes. In this paper, we choose a neighbor-first-based method called progressive neighbor first ordering (PNFO) since it can reduce the number of BDD nodes as much as possible. PNFO evaluates logical relationships among the basic events in the CFT and is not influenced by the way the CFT has been constructed. Also, it focuses on repeated events and gives the ordering priority to their neighbor events (Sun and Du, 2008).

To eliminate the inconsistency problem caused by conditioning nodes during the logical operation between CBDDs, several rules are introduced based on Eq. (4) to Eq. (12), as shown in Fig. 7.

•
Simplification Rule. Replace the redundant node S’ to its 1-edge sub_node , if the node S’ and the conditioning node 
 are on the same path, as shown in Fig. 8.

We illustrate how to construct the CBDD using a WSP gate. The CFT shown in Fig. 6 consists of four logic AND gates with conditioning events. Based on the PNFO mentioned above, the index order of nodes is set to 
. The CBDD of the CFT is generated as follows:

The CBDD of No. 1 gate in Fig. 6 is built as shown in Fig. 9. Similarly, CBDDs of No. 2 to No. 4 gates are constructed. These are basic logical operations without inconsistency. Fig. 10 shows the sub_CBDD generated by logical operation between CBDDs of No. 1 gate and No. 2 gate.

The CBDD of the CFT is generated by a logic OR operation between two sub_CBDDs shown in Fig. 10, Fig. 11. However, when the structure of the CBDD is complicated, the inconsistencies problem will emerge. For example, there is an inconsistency elimination operation (Fig. 7(b)) during logical operation between two sub_CBDDs, as shown in Fig. 12. The red dotted circle indicates the removed inconsistent node by replacing it to terminal node ‘0’.

Finally, the CBDD of the CFT after inconsistency elimination operations (Fig. 7(b)) is shown in Fig. 13.

Typically, inputs of spare gates are basic events (Dugan et al., 1992). However, if a basic event is both a primary event and a spare event, for example, a spare gate, the replacement becomes unclear (Boudali et al., 2010). Our proposed solution also can analyze this case if the definition of  makes a corresponding extension. An example of DFT with specific spare gates is shown in Fig. 14 (Volk et al., 2018). To handle this DFT, the 
 and 
 in 
 are allowed to denote a subtree, respectively.


Download : Download high-res image (167KB)
Download : Download full-size image
Fig. 12. CBDD of the CFT before elimination inconsistency and simplification.


Download : Download high-res image (165KB)
Download : Download full-size image
Fig. 13. Final CBDD of the CFT.


Download : Download high-res image (67KB)
Download : Download full-size image
Fig. 14. WSP gate with subtrees inputs (Volk et al., 2018).

WSP gates in Fig. 14 are converted to logic AND gates with the specific conditioning event. Once either 
 or 
 fails, the logic OR gate connected as the primary component will happen. Hence, we consider 
 or 
 as a primary component respectively during the conversion of CFT. The CFT of Fig. 14 is shown in Fig. A.1 (in the Appendix A Analysis of WSP gate with subtrees inputs based on the CBDD, Appendix B Figures and equations relating to case study II). We can build the CBDD based on the CFT shown in Fig. A.1. The steps are similar to the CBDD construction of Fig. 6. The final CBDD of the WSP gate with subtrees inputs is shown as Fig. 15 based on the index order selected by PNFO. The index order is set to 
. The evaluation based on the CBDD is presented in Appendix A.

Note that our extension cannot be used for SP gates with arbitrary subtrees. For example, if both primary components and spare components are dependent events in an FDEP gate, then once the trigger is activated, spare races (more than two primary components simultaneously compete for the same spare component) may cause the non-deterministic behavior (Junges et al., 2016). Moreover, some complex nested SP gates in (Junges et al., 2016) also need carefully identifying replacement behaviors regarded to activation.

6. Reliability analysis using conditional binary decision diagram
A general three-step process can design the CBDD based on dynamic fault trees with spare gates: CFT conversion, system CBDD model generation, and system CBDD model evaluation, which are described in the following:

Step 1 — CFT Conversion

The replacement behavior of the spare gate in the DFT is extracted, and the replacement behavior is transformed into the conditioning event after analysis. Then, the spare gate is converted into one or more logic AND gates with conditional events. Also, the occupation of shared spare components is considered (mentioned in Section 4.2). If some condition is satisfied, it may simplify conditioning AND gates to a logic AND gate. According to the description in Section 4.2, we assume that  SP gates (each SP gate only has one primary component) share  spare components, and  SP gates are connected by a logical OR gate where , then any combination of  primary components failure (in total 
) will cause the logical OR gate to occur. Consequently, we can use logical AND gates instead of partial conditioning AND gates in this scenario. For example, three SP gates (
, 
, and 
) connected by a logical OR gate share one spare component (
), as shown in Fig. 16. A logical AND gates with two primary components (any combination of two primary components among three) can replace two conditioning AND gates, as shown in Fig. 16. Similarly, there two other logical AND gates (
 and 
) that can be obtained, in total there are three (
). After that, the DFT can be converted into the CFT.

Construct the CBDD based on the CFT using the process mentioned in Section 5. First, build sub-CBDDs related to separate logic gates. Then, new sub-CBDDs are generated by combining two sub-CBDDs via logical operations that correspond to the static logical gate in the CFT. Loop this process until the final CBDD is presented. In these operations, pay attention to avoiding contradiction and redundancy by using elimination redundancy and inconsistency rules mentioned in Fig. 7, Fig. 8.

Step 3 — System CBDD Model Evaluation

Collect all paths from the top node to terminal node 1 in the CBDD. After eliminating negation events, inconsistency, and redundancy, all the paths are converted to corresponding algebraic-structure-based expressions (Merle, 2010). Finally, the results are obtained by using an integral-based method.

7. Case studies
In this section, three systems are illustrated to use and verify the proposed solution in detail.

7.1. Case study I
A hard disk system (Tannous et al., 2011) is shown in Fig. 17. The 
 and 
 are primary hard disks (primary components) sharing the same warm spare disk (spare component) 
 in the hard disk system.

Step 1 — CFT Conversion

In this system, any WSP gate failure can lead to an entire system failure. The shared spare component failure and occupation (replaces the other primary component) are able to cause WSP gate failure when the primary component fails. There are three conditioning events: 
, 
, and 
. The DFT of the hard disk system needs to be converted into the CFT, as shown in Fig. 18. As mentioned in Section 4.2, two primary components share one spare components (), and one of two WSP gates will occur if both of the two primary components fail. Because 
 can only replace one primary component, when 
 and 
 both fail, one of two WSP gates is bound to fire, and the WSP gate firing will cause the entire system to fail as well. Hence, the No. 1 gate in Fig. 18 is constructed as a logic AND gate. Due to the logic OR gate in the top, when any one of the WSP gates fires individually, the entire system will also fail. Each WSP gate can fire in two conditions. One condition is when the primary component fails and then the spare component replaces the primary component and finally fails, which corresponds to No. 2 gate and No. 4 gate. The other condition is when the spare component fails first and then the primary component fails, which corresponds to No. 3 gate and No. 5 gate. No. 2 gate and No. 4 gate include conditioning events related to replacement. No. 3 gate and No. 5 gate include conditioning events related to non-replacement. Any gate firing can result in an entire system failure.

According to PNFO, the index order of variables corresponding to nodes of CBDD is 
, and all components start to work (or are in the dormant state) simultaneously. The CFT for the hard disk system includes one logic AND gate and four conditional AND gates. In the system CFT model, the occurrence of any one of the conditional AND gates or the logic AND gate can result in the top event happening.

Firstly, construct CBDDs of five gates numbered 1 to 5 as shown in Fig. 18. The No. 1 gate is a logic AND gate. The No. 2 gate and No. 3 CBDD model generation are shown as Fig. 19. Similarly, No. 4 gate and No. 5 gate are built as well.

Secondly, merge the CBDDs of five gates.

(i) Perform a logic OR operation between two CBDDs related to No. 2 gate and No. 3 gate as a sub-CBDD of the hard disk system, as shown in Fig. 20.

(ii) The same operation is used for CBDDS of No. 4 gate and No. 5 gate, and the result is the other sub-CBDD of the hard disk system.

(iii) The sub-CBDD generated in (i) does a logic OR operation with the CBDD of No. 1 gate, and it can generate the third sub-CBDD of the system.

(iv) The final CBDD can be obtained by a logic OR operation between the sub-CBDD generated in (ii) and the sub-CBDD generated in (iii), as shown in Fig. 21.

Five MCSs can be found by the system CBDD as well as from the CFT directly:

 (absorbs  )





However, they need to be converted to the sequence-dependent model of the algebraic structure to compute failure probability via the I/E-based method. Obviously, it is more complicated than the SDP-based method.

Step 3 — System CBDD Model Evaluation

The CBDD can implicitly represent the SDP. Each disjoint product (DP) corresponds to a path from the root node to terminal node ‘1’ like that in the BDD. As a result of all the paths being disjointed, we can compute the entire system probability via the sum of probabilities of all the paths from the root to the terminal node ‘1’. To evaluate the system CBDD model, probabilities of all the paths from the root node to the terminal node ‘1’ must be calculated. There are six paths shown as the logic operation result in Fig. 21, which can lead to an entire system failure. The symbol  denotes a path between two CBDD nodes. 
 Two paths (1), (6) in Eq. (13) can be considered as a path . The system failure probability can be expressed as: (13)
 From Eq. (13), all the disjunctive terms are mutually exclusive. Actually, they are DPs. According to the inclusion–exclusion principle, Eq. (13) can be deduced as follows: (14)
 In this case, some negation conditioning events can be replaced as follows: (15)
(16)
(17)
 According to Eq. (15) to Eq. (17) and the elimination redundancy and inconsistency rules (in Section 4.3), Eq. (14) can be reduced as follows: (18)
  can be easily deduced.

. 
 is the failure probability of the WSP gate consisting of the primary component 
 and the spare component 
 in the condition of non-replacement. Non-replacement implies 
 failed in the dormant state. 
 represents 
 fails and 
 does not fail in the case that 
 fails in a dormant state. It implies the spare component 
 fails first (
 fails before 
 and 
), 
 fails after 
, and 
 does not fail. Thus, 
 can be converted into a sequence-dependent model of algebraic structure function as 
. Then, 
 can be converted into 
. According to the sequence-dependent model of algebraic determination of the structure-function deduction rules (Merle, 2010), it can be deduced as follows: (19)


Download : Download high-res image (63KB)
Download : Download full-size image
Fig. 22. Time relationship for 
, 
, and 
.

Here, 
 is set as a random variable  that represents the time-to-failure of the primary component 
. Similarly, 
 refers to the primary component 
. 
 and 
 are set as the time to failure  of warm spare component 
 before and after it is activated, respectively. The relationship between 
, 
, and 
 is shown in Fig. 22. For ease of computation, it is assumed that all components start to work at . Let 
, 
, 
, and 
 denote the probability density function of 
, 
, 
, and 
 respectively. The calculation similar to 
 has been discussed many times (Merle et al., 2011a, Merle, 2010). Assuming that 
 fails at 
, then the probability that 
 fails after 
 (
 fails after 
) is: (20)
Hence, the probability that 
 fails before 
 and 
 fails is given as follows: (21)
Consequently, the probability of 
 is: (22)

. 
 is the failure probability of the WSP gate consisting of the primary component 
 and the spare component 
 in the condition that replacement occurs. Replacement indicates 
 fails in the activated state. It implies that 
 fails first (before 
 and 
 fail), and 
 fails after the failure of component 
. Thus, 
 can be converted into a sequence-dependent model of algebraic structure function as 
. It can also be deduced as follows: (23)

First, the probability that the primary component 
 fails at 
 and the spare component 
 fails after 
, meaning that 
 survives 
 (the probability of 
 non-occurrence in a dormant state from time 0 to time 
): (24)
(25)
 Secondly, the probability that 
 fails at 
 and then 
 fails after 
 equals the probability that 
 fails, 
 survives 
 and 
 fails after 
: (26)
 Finally, the 
 is: 
(27)

The structure of 
 and 
 are symmetrical to 
 and 
, respectively. A system failure can be caused by the failure of the WSP gate, which consists of the primary component 
 and the spare component 
. Hence, they can be analyzed in a similar way with the following results: (28)
(29)
 According to Eq. (18), Eq. (22), Eq. (27), Eqs. (28), (29), the unreliability of the system is: 
(30)

To verify the results, the Markov-based method, SBDD, and ABDD are used to analyze the same system. Assume that 
, 
, and 
 fail exponentially with constant rates. Let 
, 
, 
 and 
. Use the parameter values of 
, 
, 
 (replacement), and 
 (non-replacement). The Markov model generated in the Markov solution is shown in Fig. 23. As a result, there are five different differential equations, as shown in Eq. 7.1. According to the assumption mentioned above, the initial state (at time 0) is state 1. 
 
 
 
 
(31)
 

The converted trees are shown as Fig. 24, Fig. 25 and they correspond to SBDD and ABDD, which are shown as Fig. 26 and Fig. 27, respectively. In Fig. 24, Fig. 26, the symbol “” denotes the precedence order of component failures, for example, “” means that a basic event  fails before a basic event  fails (Tannous et al., 2011). The SBDD and ABDD (only compute 7 valid paths ) use the SDPs-based method to calculate the system unreliability (Tannous et al., 2011, Jiang et al., 2018).

We compute the system unreliability results by using the proposed solution, the Markov solution, the SBDD solution, and the ABDD solution for three different mission times (t=300, 500, and 900 days, respectively). All equations (integrals and differentials) are programmed via Matlab 2016 and get an exact match, as shown in Table 1.


Download : Download high-res image (78KB)
Download : Download full-size image
Fig. 23. Markov model of the hard disk system.


Download : Download high-res image (62KB)
Download : Download full-size image
Fig. 24. Fault tree after conversion by SBDD (Tannous et al., 2011).


Download : Download high-res image (86KB)
Download : Download full-size image
Fig. 25. Fault tree after conversion by ABDD (Jiang et al., 2018).


Download : Download high-res image (72KB)
Download : Download full-size image
Fig. 26. Final SBDD of the hard disk system (Tannous et al., 2011).

The time-to-failure distributions of Weibull also can be applied to the system components. The following parameter values are used for computation: Weibull (shape: , scale: 
, 
, 
, and 
, 
). Results of the Weibull distribution used in CBDD with different mission times are shown in Table 1. It is obvious that our proposed method is not limited to exponential distribution. We can calculate the disk system unreliability when the system components follow other time-to-failure distributions, such as Weibull. Compared to SBDD and ABDD, CBDD avoids sequence-dependent (or temporal logic) nodes in the formal and eliminates inconsistencies in the process of building the CBDD. As opposed to SBDD and ABDD, all nodes of CBDD can be located in the basic event level. Moreover, our approach is more efficient than using the I/E-based method (Dugan and Doyle, 1996, Liu et al., 2007) on MCSs/MCQs directly since it only computes an expression of 5 integrals rather than an expression of 31 (
, 5 MCSs) terms (each term is also an integral) including our 5 integrals.


Table 1. Results for the hard disk system analysis.

Method	t (days)
300	500	900
Markov	0.365588	0.627432	0.894022
SBDD (Exponential)	0.365588	0.627432	0.894022
ABDD (Exponential)	0.365588	0.627432	0.894022
CBDD (Exponential)	0.365588	0.627432	0.894022
CBDD (Weibull)	0.137563	0.479438	0.942553
7.2. Case study II
The DFT with spare gates example that we are going to use is the DFT of a Vehicle Management System (VMS) (Vesely et al., 2002) in the application, as shown in Fig. 28. The system consists of three WSP gates, a logic AND gate, and a logic OR gate. Three WSP gates share the same spare component 
 in the VMS. In the system, a vehicle management subsystem is a logic AND gate that is composed of two WSP gates (vehicle management A and vehicle management B). Finally, the system consists of the vehicle management subsystem and the WSP gate (vehicle management C) via logic OR gate.

When WSP gates are used, the assignment of the spare component as well as the determination of the failure rate for each spare component is included. The failure of vehicle management C can directly lead to an entire system failure, which can be caused by two cases. One case is both 
 and 
 (before or after replacement) fail, and the other case is when 
 replaces either 
 or 
, then 
 fails. The subsystem failure caused by the failure of two WSP gates can also result in the entire system failure. The combination between , , , 
, 
, and 
 can deduce three cut sets to lead to a subsystem failure. Another set that causes subsystem failure is the combination of , , , and 
. In the VMS, three WSP gates share a spare 
. According to the analysis of converting from shared spare SP gates to CFTs in Section 4.2, one of three WSP gates will fail after two primary components fail. However, two of three primary components failing may not cause a system failure because two WSP gates are combined with a logic AND gate. For example,  failed before  fails,  failed before  fails, and both  and  fail. If all three primary components fail, two of three WSP gates will fail since only one spare component is available. Any two WSP gates fail will cause the top event to happen. Thus, the combination of , , and  can directly lead to entire system failure. Hence, the combination of , , and  is chosen. According to the analysis above, the DFT can be converted into the CFT, as shown in Fig. 29. The CFT is made up of seven conditional AND gates and one logic AND gate. In this case study, it is not easy to directly obtain a logical AND gate with three primary components (
, 
, and 
) by the rule mentioned in Section 4.2. It is required to separately analyze the two WSP gates connected by a logical AND gate then consider the replacement between the spare component and three primary components to translate the logical AND gate.

Step 2 — System CBDD Model Generation

Set the index order of nodes as 
 based on the PNFO when two CBDDs are merged by logical operations. According to the VMS CFT, the system failure is caused by any one of the eight gates (seven conditional AND gates and one logic AND gate) that are numbered from 1 to 8 from left to right. All gates from 1 to 8 can be easily constructed as shown in Fig. 19. The primary events , , conditioning event 
, and conditioning event 
 can cause the No. 1 gate and No. 2 gate to fire (Vehicle Mgmt C), which will lead to VMS system failure. The related CBDD is built as shown in Fig. 30. The subsystem failure is caused by three primary events (, , and ) and three conditioning events (
, 
 and 
), and the subsystem CBDD is built as shown in Fig. 31. Merge No. 7 gate CBDD with No. 8 gate CBDD by logic OR operation, as shown in Fig. 32. Similarly, do logic OR operation between these CBDDs including the CBDD of Vehicle Mgmt C, subsystem CBDD, No. 6 gate CBDD, and the CBDD in Fig. 32 via logic OR operation. During the operation, some inconsistencies can be solved by inconsistency elimination rules shown in Fig. 7. The Final CBDD of VMS is shown in Fig. 33.

Assume that all components start to work (or are in the dormant state) at the same time in the beginning. The fourteen paths that can lead to the VMS failure are from the root node to a terminal node ‘1’ in the VMS CBDD, as shown in Fig. 33. 
 Based on the binary logic of VMS CBDD, the mutually exclusive relation can be easily found in these paths. Hence, the probability of the VMS failure is shown as follows: 
(32)
 Consider the entire logical relation in the VMS. Negation conditioning events are converted into the following basic events: (33)
(34)
(35)
(36)
 According to Eq. (33) to Eq. (36), replace negation conditioning events and remove inconsistencies. Furthermore, to reduce calculations, 
 and 
 are merged into 
. The same operate from 
 and 
 to 
. Similarly, 
 and 
 can also be obtained. Finally, fourteen products are reduced to ten products, as shown in the following: 
(37)
 Similarly, for the purpose of verification, Markov, SBDD and ABDD analysis are performed on the same VMS case study. Assume that all the component failures in the VMS follow an exponential distribution with parameter . The warm spare component can fail either before or after the primary component with failure rate 
 and 
, respectively. Similar to the assumption in Section 5, the failure PDF are 
 (
 before replacement), 
 (
 after replacement), 
 (
), 
 (
), and 
 (
), respectively. The unreliability of the VMS is calculated by an expression with ten integral terms shown in Eq. (B.1) (in Appendix B).

The Markov model of the VMS example is shown in Fig. B.1. According to Fig. B.1, we have to solve the Markov chain with 11 states and 21 transitions. As a result, 11 different differential equations are shown in the Eq. (B.2).

The converted fault tree of VMS prepares to generate the SBDD is shown in Fig. B.2. The SBDD (Tannous et al., 2011) of VMS is shown in Fig. B.3 under the index order . Different from Fig. 33, the path from top to terminal node 1 in Fig. B.3 is not necessarily able to be used for qualitative analysis since some of them may be invalid (for example, ). Each path needs to be analyzed to identify its correctness.

The converted fault tree of VMS for building the ABDD is shown in Fig. B.4. However, the ABDD does not eliminate inconsistencies during generation (It handles invalid paths after ABDD generation). As a result, the ABDD of VMS seems to be more complex than both the CBDD and the SBDD, as shown in Fig. B.5. Its index order is . Remove inconsistencies or reduce some paths when calculating paths from the top to terminal node 1 after the final ABDD is constructed.

Setting parameter values of 
, 
, 
, 
, and 
, we use Matlab 2016 to compute the system unreliability results from the proposed method, the Markov approach (the initial state (at time 0) is state 1), the SBDD method, and the ABDD method, which match for three different mission times accurately, as shown in Table 2. The VMS unreliability time distribution under the condition of components exponential failure distribution is shown in Fig. 34.

However, the I/E based method can also be used to compute the VMS unreliability via evaluating an expression of 
 terms (Dugan and Doyle, 1996) based on  MCQs in general. For our example, the I/E-based method involves at least 8 MCSs deduced from Fig. 29. According to the I/E-based formula, an expression of 
 terms (each term involves integrals) is required to evaluate the VMS unreliability if internal mutually exclusive is not considered. Compared to 255 terms, our proposed method, which only computes an expression of 10 integrals (they are included in 255 terms), is more efficient than the I/E-based method in the VMS example.


Table 2. Analysis results for the VMS.

Method	t (days)
300	500	900
CBDD	0.466659	0.747732	0.956783
Markov	0.466659	0.747732	0.956783
SBDD	0.466659	0.747732	0.956783
ABDD	0.466659	0.747732	0.956783
7.3. Case study III
We will illustrate a more complex example than the previous two case studies. A multiprocessor computing system (Montani et al., 2006) is shown in Fig. 35. The DFT of the multiprocessor computing system involves a logic AND gate, three logic OR gates, four WSP gates including two shared spare component WSP gates, and a (one-short) PDEP gate (Portinale et al., 2010). The function of the system consists of two computing modules ( and ).  includes two disks (a primary disk 
 and a spare disk 
), processor 
, and memory 
. Similarly, the structure of  is the same as . 
 in  shares a spare memory 
 with 
 in . Moreover, a power supply 
 supports both 
 and 
, and all data from both two computing modules transit through the Bus 
.

Step 1 — CFT Conversion

To WSP gates, we can directly convert them to logic AND gates with specific conditioning events. For a one-short PDEP gate that is a special case of FDEP, the trigger event leads the dependency events to fail with a probability . Here, we set  as the same as Montani et al. (2006). Hence, we can treat this PDEP gate as a FDEP gate. In this condition, once the failure of 
 cases both 
 and 
 fail, which leads the system to fail. The CFT of the multiprocessor computing system is shown in Fig. 36.

Step 2 — System CBDD Model Generation

A similar operation with the previous two case studies is used to build the sub_CBDD of each gate. Then, merge sub_CBDDs by using Boolean operation rules. During the operation, eliminate potential inconsistencies and simplify. The index of variables is  
 
 
 
. The final CBDD under the index determined by PNFO is shown in Fig. 37.

Step 3 — System CBDD Model Evaluation

There are fifty-nine paths from the top node N to terminal nodes ‘1’, which corresponds to fifty-nine computing items for the system failure. The negation conditioning events are converted into the following basic events: (38)
(39)
(40)
(41)
(42)
(43)
 (44)
For fifty-nine calculation items, according to Eq. (38) to Eq. (44), replace negation conditioning events and remove inconsistencies. Obviously, there are six products that can be reduced as three products. 
 and 
 can be merged into 
. Similarly, we can obtain 
 from 
 and 
. 
 is from 
 and 
. All assumptions are the same as the previous two case studies. We also assume each component in the multiprocessor computing system failure follows an exponential distribution with parameter . Setting parameter values of 
, 
, 
, 
, 
 (
 or 
 after replacement), 
 (
 or 
 before replacement), 
, 
 (
 after replacement), and 
 (
 before replacement). Finally, we also are using Markov (212 states), SBDD, and ABDD to verify the result of our CBDD relating to the multiprocessor computing system. The system unreliability results computed by Matlab from different methods match for three different mission times accurately, as shown in Table 3.

35 MCQs/MCSs (32 MCQs, 3 MCSs) can be deduced from Fig. 36. If we use the I/E-based method to compute the unreliability, we have to evaluate an expression of 
 terms (including integrals terms) if internal mutually exclusive is not considered. Compared to 
 terms, our proposed method, which only computes an expression including 33 integrals terms and 3 non-integrals terms. However, even if we consider mutually exclusive between 32 MCQs, the number of terms based on the I/E-based method is much more than ours. Hence, the proposed method is more efficient than the I/E-based method in the multiprocessor computing system example.


Table 3. Analysis results for the multiprocessor computing system.

Method	t (days)
500	1000	1500
CBDD	0.002998	0.006009	0.009072
Markov	0.002998	0.006009	0.009072
SBDD	0.002998	0.006009	0.009072
ABDD	0.002998	0.006009	0.009072
8. Conclusion
In this paper, we have presented an efficient reliability analysis method of DFTs with spare gates based on CBDD via conditional transformation. CBDD can be applicable to both spare systems (DFTs model with spare gates) and static systems (SFT models) with any arbitrary component time-to-failure distributions and different component failure parameter values. We proved that our MCS (with conditioning events) is more intuitive and efficient than MCQ in reliability analysis of spare gates. Additionally, our MCS can help engineers locate component faulty by conditional events needless to search current or historical records associated with fault components. We demonstrated that the MCS could be explained by sequence-dependent failure behaviors used in algebraic-structure-based methods (Merle et al., 2011a, Merle et al., 2011b). Compared to SBDD (Xing et al., 2012, Tannous et al., 2011) and ABDD (Jiang et al., 2018), our proposed solution avoids sequence-dependent (or temporal logical) nodes and uses MCSs instead of MCQs to analyze system reliability. Although they are converted to temporal logic to compute failure probability via integrals, CBDD replaces MCQs with MCSs by transferring sequence-dependent behaviors to static conditional status. Based on the data collected in our case studies, our proposed method is more efficient than the MCQ combining I/E-based method. At last, the quantitative analysis based on the CBDD has been presented by means of a hard disk system, VMS examples, and multiprocessor computing system example.

In future work, our proposed method will be expanded to DFTs including other dynamic gates (PAND gates and SEQ gates) reliability analysis. Also,we will focus on some scenarios (including the complex shared spare SP gate and other cases in Junges et al. (2016)) which we have not implemented the automation yet. Finally, we will develop an integrated solution based on CBDDs for reliability analysis of dynamic fault trees including monotonic or non-monotonic and repairable or non-repairable.