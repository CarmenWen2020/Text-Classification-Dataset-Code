Abstract
The evolution to next generation embedded systems is shortening the obsolescence period of the underlying hardware. As this happens, software designed for those platforms (a.k.a., legacy code), that might be functionally correct and validated code, may be lost in the architecture and peripheral change unless a retargeting approach is applied. Embedded systems often have real-time computing constraints, therefore, the legacy code retargeting issue directly affects real-time systems. When dealing with real-time legacy code migration, the timing as well as the functional behaviour must be preserved. This article sets the focus on the timing issue, providing a migration path to real-time legacy embedded control applications by integrating a portable timing enforcement mechanism into a machine-adaptable binary translation tool. The proposed timing enforcement solution provides at the same time means for validating the legacy timing behaviour on the new hardware platform using formal timing specifications in the form of contracts.

Keywords
Legacy software
Retargeting
Real-time systems
Time contract

1. Introduction
Companies within the embedded systems industry are facing a relentless demand for increasingly stringent requirements such as better performance, increased dependability, and energy efficiency, while offering a cost-effective product within a reduced time-to-market. This transition to next generation embedded systems is being encouraged by the rapid development of computing architectures. As a consequence, the obsolescence period of embedded systems is being shortened and there is a need to deal with legacy systems and their integration.

Legacy systems are characterized by some particular properties:

•
Usually runs on obsolete hardware which is slow and expensive to maintain (Wu et al., 1997).

•
Use customized and deprecated toolchain(s) (Wagner, 2014).

•
Have no or outdated documentation and original developers or users are no longer available (Wagner, 2014).

•
Are essential for the company (Bennett, 1995) since they comprise business knowledge (Wahler et al., 2015).

Due to their nature and particular properties, legacy systems present a complex scenario in software maintenance and evolution. Hence, the process of updating legacy systems is usually complex, error-prone, time-consuming and requires high cost investment.

Binary translation appears to be a standard approach when it comes to legacy software migration, since the binary that runs on the legacy hardware can be ported to a new hardware platform without a considerable expense of time, effort and money. Software recompilation is also a well known approach to port platform-independent legacy source code.

However, when dealing with Real-Time (RT) legacy code migration, not just the functional behaviour, but also the timing behaviour must be preserved. To the authors knowledge, limited solutions exist to port real-time legacy software, while existing solutions have limitations regarding their portability. Therefore, industry still needs a low-overhead embedded RT legacy software retargeting solution that can be easily ported to different source and target architectures.

In the direction to solve this problem, this work sets the focus on the timing issue, therefore, the overall goal of this research is to provide a migration path to real-time legacy embedded control applications by integrating a portable timing enforcement mechanism into a machine-adaptable binary translation tool. The proposed solution should also provide means to validate the legacy timing behaviour on the new hardware platform.

As a first step on this research, Yarza et al. (2020) studies the feasibility of two machine-adaptable binary translators, one dynamic and the other one static, for their use in a RT property conserving legacy software migration process. Based on these translation tools, two (dynamic and static) RT legacy source code migration solutions are proposed. The feasibility study compares the measured execution time of a set of Worst Case Execution Time (WCET) representative benchmarks running on the legacy and new hardware platforms using both migration approaches. From this feasibility study, the static approach is selected to implement a timing contract aware real-time legacy software migration solution, since it provides a more deterministic timing behaviour and less translation overhead. The main contribution of this article are:

•
The systematic annotation of legacy timing properties into the behavioural legacy source code using a set of portable temporal construct that provide means to enforce a specific timing behaviour within the legacy software.

•
The systematic transformation of legacy timing properties into formal timing specifications for their latter use within the timing validation phase.

•
The integration of the temporal constructs within the binary translation process to achieve a timing-aware legacy software migration.

The remainder of this paper is organized as follows. An overview of related work in the area of timing-aware recompilation and machine-adaptable binary translation techniques is provided in Section 2. Then, in Section 3 the proposed migration path is constraint to a specific class of application. Then, based on these constraints, Section 6 presents the RT legacy software migration path. The proposed solution is then assessed in Section 7 and obtained results are analysed. Finally, Section 8 gives a conclusion and outlook on future work.

2. Related work
Given that legacy software migration is a common issue in industry, it has been widely studied during the last decades. However, when porting RT legacy software, not just the functional behaviour, but also the timing behaviour must be preserved. This section provides an overview of existing solutions for a timing-aware recompilation of legacy C source code, as well as binary translation tools targeting either a machine-adaptable or a RT legacy code migration solution. The related work identifies six timing-aware recompilation solutions (from R1 to R6) and three binary translation tools (from B1 to B3) for a latter analysis.

2.1. Timing-aware recompilation
Software recompilation is a well known solution when it comes to port legacy software to a new Instruction Set Architecture (ISA). However, recompilation to be applicable on the legacy migration process, the legacy source code must be available and it must be at sufficient high level that it is independent (or almost independent) from the legacy hardware platform (e.g., dedicated instructions, specific hardware resources). In the following, timing-aware recompilation solutions are covered:

Resmerita et al. (2015) proposed a systematic approach to apply real-time programming to legacy embedded control systems composed of time- as well as event-triggered tasks with different priority levels. Using Timing Definition Language (TDL) the code is transformed and then compiled into E-code and interpreted at runtime by an Embedded Machine (E-machine) (Henzinger and Kirsch, 2007), which provides a real-time interaction among software and physical processes.

Le Nabec et al. (2016) describe the process of modelling RT legacy software using the Real-Time BIP (RT-BIP) (Abdellatif et al., 2013) framework, an extension to the Behaviour Interaction Priority (BIP) language for modelling real-time systems together with a real-time engine used for execution. To this end, they define a configurable component pattern, called the Real-Time BIP Agent (RT-BIPAgent), that follows a classical template for a real-time task, composed of a start time, a period, a set of input and output data, and a computational function. Then, based on the FreeRTOS platform, executable code is generated from the BIP model.

Natarajan and Broman (2018) proposed an extension of the C programming language, called Timed C, consisting of a set of primitives for defining soft and firm RT constants that ease RT systems’ implementation. A Timed C file is then compiled into a target specific C file using their source-to-source compiler, KTC. The resulting file is linked against Portable Operating System Interface (POSIX) or FreeRTOS to implement the user defined timing and scheduling behaviour.

Real-Time Concurrent C (Gehani and Ramamritham, 1991) incorporates a set of temporal constructs into Concurrent C, a parallel superset of C. It provides means to specify strict timing constraints through the temporal constructs, which allow delaying program’s execution, defining periodicity or specifying deadlines. Real-Time Concurrent C was designed for a UNIX-based implementation of Concurrent C and its compiler is no longer available (Natarajan and Broman, 2018).

The time measurement and control blocks (Bruns et al., 2019) are a C++ extension, implemented as a C++ library, that enable block-level timing annotations into embedded C++ software. These block annotations can be implemented to measure and profile the execution time of a given software block as well as to control and enforce a specific timing behaviour (time-budget or specific duration) at run-time. Time measurement and control blocks have been implemented for bare-metal C++ applications running on an Zynq-7000, using the Global Timer Counter and a Central Processing Unit (CPU) Watchdog.

The WCET-aware C Compiler (WCC) (Falk and Lokuciejewski, 2010) was the first compiler to provide means to reduce the WCET at both, source code and assembly code level. The WCC has a clear notion of the program’s worst-case behaviour (combining measurement-based WCET analysis and static program analyses) and applies specialized compiler optimization to reduce the program’s WCET. The WCC’s target architecture is the Infineon TriCore processor heavily used in the automotive industry.

2.2. Binary Translation
Binary translation techniques have been widely studied and developed in the last decades. So, given the great amount of binary translation systems and the focus of this paper on embedded RT legacy software migration, just cross-platform translators heeding portability and/or RT applications will be considered in this section.

The TIBBIT project (Cogswell and Segall, 1995), developed the first binary translation approach for embedded RT applications (which are not assumed to be user-level processes) that needed to be migrated to a different processor but still maintaining the externally observable timing behaviour. To this end, both, the legacy application and the operating system code, are packed in a black box, converted into an equivalent C program, and then translated into the target binary format using the GNU Compiler Collection (GCC) retargetable compiler. During the translation process, timing code is inserted into each translation block, to maintain the same timing behaviour as in the original processor. If the execution is running faster than it did in the old processor, extra time is used to run other tasks until the execution is back on schedule.

Then, in 2008, Heinz (2008) proposed a system-level Static Binary Translation (SBT) approach to port RT legacy software. However, instead of dynamically computing a delay, as Cowsgell and Zary did on the TIBBIT project, the delay computation is shifted from run-time to compile-time. The translator selects from a set of precomputed delays the appropriate value according to the context of a program point, so there is no need to keep track of the execution time on the source machine.

UQBT (Cifuentes and Emmerik, 2000) was the first SBT tool designed with portability in mind. UQBT translates the user-level target binary into a machine-independent Intermediate Representation (IR), Higher-Level Register Transfer Language (HRTL), and then the intermediate code is translated into host machine binary code. This two phase translation, eases the portability to new source and target architectures. To handle indirect calls that could not be discovered at static time, the UQBT uses an interpreter.

Based on the UQBT, Ung and Cifuentes (2000) presented the first retargetable Dynamic Binary Translation (DBT) approach, UQDBT. Just like its predecessor, UQDBT does not support system-level emulation and provides a machine-adaptable solution by separating the system into machine-dependent and machine-independent parts through a machine independent intermediate representation (I-RTL). However, the machine adaptability of the translator comes at the cost of performance. To improve generated code, UQDBT performs generic hot path optimizations that are applicable on different machines.

Since UQBT and UQDBT, there have been a wide variety of machine-adaptable dynamic as well as static Binary Translation (BT) tools. In 2005, Bellard (2005) developed Quick EMUlator (QEMU), a well known machine emulator build upon a fast and portable DBT system. QEMU uses Tiny Code Generator (TCG) to translate target source code into a machine independent IR and then translates IRs into host machine code. In order to reduce system overhead, QEMU applies Translation Block (TB) (unit of a basic block in QEMU) chaining, which directly jumps to the next TB without returning control to the execution engine.

DisIRer (Hwang et al., 2011), is a multi-target SBT tool that leverages the GCC infrastructure. DisIRer translates x86 user-mode instructions into GCC’s Register-Transfer Level (RTL) and then translates RTL into GCC’s Abstract Syntax Tree (AST). The fact that it is build upon the GCC optimizer and back-end makes the tool cost effective and easily adaptable to multiple targets (those supported by GCC).

Another machine-adaptable BT tool is CrossBit (Yang et al., 2010), which can dynamically translate user-level binaries from different source ISAs into binaries hosted by the same Operating System (OS) for different target architectures. This tool applies profiling information to determine the hot code where host-independent optimizations are applied. Moreover, just as QEMU does, CrossBit applies Basic Block chaining.

LLBT (Shen et al., 2012) is a multi-target SBT tool for embedded systems based on the Low Level Virtual Machine (LLVM) (Lattner and Adve, 2004) compilation framework that provides a source and target independent optimizer, as well as code generation support for multiple ISAs. Therefore, the LLVM compiler infrastructure provides LLBT with means for optimization and retargetability. Moreover, in order to make the system suitable for embedded systems, the size of the address mapping table was reduced.

Based on BT techniques, Rev.ng (Federico et al., 2017) is a machine-adaptable binary analysis framework that relies on QEMU (Bellard, 2005) and LLVM (Lattner and Adve, 2004) to perform the binary translation. Rev.ng takes advantage of the core element of QEMU, TCG, to translate user-level instructions of a supported ISA into a machine independent IR. Then, instead of generating machine code for the host architecture in emulation mode, QEMU IR is further translated into a higher level IR, LLVM IR. By employing LLVM as a back-end, the generated LLVM IR is translated into host machine code.

2.3. Analysis
Based on the literature review, existing solutions in the area of timing-aware recompilation and binary translation are mapped to the scope of this work. The related work identifies six timing-aware recompilation solutions (from R1 to R6) and three binary translation tools (from B1 to B3). Then, this identifiers are placed in the scope map according to the research area they cover. The following list shows the related work that has been mapped to the scope:

R1
Logical Execution Time (LET) & E-machine (Resmerita et al., 2015)

R2
BIP & FreeRTOS (Le Nabec et al., 2016)

R3
Timed C (Natarajan and Broman, 2018)

R4
Real-Time Concurrent C (Gehani and Ramamritham, 1991)

R5
Time Measurement and Control Blocks (Bruns et al., 2019)

R6
WCC (Falk and Lokuciejewski, 2010)

B1
TIBBIT (Cogswell and Segall, 1995)

B2
Heinz (Heinz, 2008)

B3
UQBT (Cifuentes and Emmerik, 2000) & UQDBT (Ung and Cifuentes, 2000)

QEMU (Bellard, 2005)

DisIRer (Hwang et al., 2011)

CrossBit (Yang et al., 2010)

Rev.ng (Federico et al., 2017)

LLBT (Shen et al., 2012)

Fig. 1 shows the diagram resulting from mapping related work to the scope, which is composed of four research areas: binary translation, where machine-adaptable solutions form a sub-area of research in binary translation; RT software, where RT legacy software is a sub-area in this group; timing enforcement that forms another research area with retargetable timing enforcement solutions as a subgroup of it; and timing validation which is the fourth research area covered on this research work.

On the one hand, among the timing-aware recompilation solutions, R1 and R2 provide means to enforce a specific timing behaviour within RT software. Both of these solutions describe how they can be implemented on RT legacy software. R3, R4, and R5 are also solution to enforce a specific timing behaviour. However, none of them describe how they can be integrated on RT legacy software. Nevertheless, none of the timing enforcement solutions presents a retargetable solution.


Download : Download high-res image (203KB)
Download : Download full-size image
Fig. 1. Related work analysis. Mapping related work to the scope..

On the other hand, regarding BT tools, B1 and B2 are the only solutions that provide a migration path to RT legacy software. However, none of these translators is machine-adaptable. In contrast, many machine-adaptable BT tools exist (see  B3), but none of them supports a timing-aware binary translation, where not just the functional behaviour, but also the timing behaviour needs to be preserved during the translation process.

In order to, at some point, fill the existing gap, the overall contribution of this research work (marked with a C in Fig. 1) is: a RT legacy software migration solution based on an existing machine adaptable BT framework, which is enhanced with a portable timing enforcement mechanism that at the same time provides means for validating the enforced timing behaviour.

3. Real-time legacy system model definition
The RT legacy control system is a computer system that executes a set of periodic tasks according to a predefined static scheduling policy. The following subsections describe through formal notation the main modelling elements in the considered RT legacy system.

3.1. Application model
Table 1 shows an example set of tasks with the corresponding timing properties. Such a task set is described through the application model.

Definition 1 Application Model

The legacy application  is composed of a set of periodic tasks , where a task  can be represented by a tuple (, , , , ), where  is the period of the task,  specifies an offset relative to the start of the period,  is an upper bound of the execution time of the task (the WCET of the task can be used as this upper bound),  determines the preceding task and  is an identifier of the existence of a section of critical code within the task. A critical code section is set to be a section that generates an exchange of information among state machines (either hardware or software). Every element in the tuple, except for , is composed of the value  and the corresponding time unit , except for which contains the preceding task or task set.

3.2. Execution model
The set of periodic tasks  is executed according to a predefined static schedule. Fig. 2 depicts the execution trace of an example set of tasks.

Definition 2 Execution Model

The execution  consists of a hyper-period , which determines the time after which the task execution pattern repeats itself, that is in turn composed of a set of frames . The size of the hyper-period  is determined through the Least Common Multiple (LCM) among all tasks’ period,  and the frame size  is determined through the Greatest Common Divisor (GCD) among all tasks’ period, . Both, and are composed of the value  and the corresponding time unit . According to the hyper-period and frame size, the number of frames within a hyper-period is limited to: .

Each frame  is characterized with a set of time slots {}, describing each time slot  as a tuple (, , ), where  is the task mapped to the slot,  is the start instant of , and  the end instant of . Time slots are consecutively ordered so that .

The function  maps tasks to slot sets. A task can only be mapped to one slot  within a frame . However, a task can be mapped to the same slots within different frames. For example, task  can be mapped to ,  and , but never to  and , since a task can only run once in each frame.

When mapping tasks to slots, it is assumed that if a precedence relation exists among two tasks , such that  shares the results produced by , then  will never start before  has finished execution: 

3.3. Example application
For a better understanding of the presented model, consider an illustrative example that resembles the typical pattern of reactive control systems. The legacy system consists of seven tasks , where a task is a sequential code block that starts reading input data and its internal state and terminates when it provides the computed results and updates its internal state. Tasks are ordered considering precedence relation and data sharing among them. Through the use of timers and internal counters, these tasks run periodically following a static scheduling policy. Tasks  and  have a period of , whereas tasks  and  have a period of . Moreover, tasks  and  are critical sections. Therefore, in order to preserve correctness of the entire system’s behaviour, the time interval at which these critical sections run must be kept equivalent on the migration process (same offset with respect to the start of the period as in the legacy system and minimum jitter among subsequent task instances). The offset of tasks  and  are  and  respectively. On the contrary, for tasks  and , a variation in their offset and jitter among subsequent task instances does not hinder a correct behaviour of the overall system. However, precedence relation and data sharing among tasks must still be considered. Table 1 summarizes this information and completes it with the WCET of each task. Whereas, Fig. 2 depicts the execution of the example task set.

The functional behaviour of the example application consists on a bit toggling sequence, where each of the sequential tasks toggles a specific bit in an output variable (the bit in the position corresponding to the task number, the bit in position zero never toggles).


Table 1. RT legacy application example. Tasks with their corresponding timing information, such as period, offset (if relevant, otherwise Not Relevant (N/R) is shown), an upper bound for the execution time, as well as identification of critical sections are shown.

Tasks	Period	Offset	WCET	Critical
[ms]	[ms]	[ms]	section
20	0	5	✓
20	Not Relevant (N/R )	5	–
40	10	3	✓
40	30	3	✓
20	N/R	2	–
20	15	2	✓
20	N/R	3	–

Download : Download high-res image (65KB)
Download : Download full-size image
Fig. 2. Example execution trace of the RT legacy application example. Execution is composed of two frames that compose the hyper-period.

4. Time measurement & control blocks
A timing-aware migration requires means to first extract and then enforce the legacy timing properties. Time measurement and control blocks aid this process, the time measurement block is used to extract the legacy timing behaviour and the time control blocks are used to enforce this timing behaviour on the new platform. The proposed time measurement and control solution is based on a block-level source code (systematic) annotation approach.

4.1. Time measurement block
To measure the end-to-end duration of a code section a time measurement block has been defined, referred as Estimated Execution Time (EET).

4.1.1. Estimated Execution Time
The EET Block provides means to measure the execution time of the wrapped code block and perform a measurement based WCET analysis. For each wrapped code block the execution time duration is computed and stored under a block ID. After several runs, the average, standard deviation, 99%-quantile and maximum observed duration are computed, which are also represented in a histogram.

4.2. Time control blocks
According to typical patterns on RT control systems, four different time control blocks have been defined: Periodic Execution Time (PET), Forced Execution Time (FET), Budgeted Execution Time (BET), and Period N Execution Time (PNET). As a safety mechanism at run-time, time control blocks trigger a user-defined error handler whenever a time budget violation is detected in one of the blocks. Concerning the amount of blocks, there should only exist one PET block in the whole legacy control application, whereas the use of FET, BET and PNET blocks is unlimited; nevertheless, the temporal overhead the block management structure entails should be taken into consideration. The PET block will always be the root node, while FET, BET and PNET blocks are always defined within an FET or PET block.

4.2.1. Periodic Execution Time
The PET Block enforces a periodic execution of the wrapped code block. The only argument passed to this block specifies the execution period of the wrapped code block through the frame size (). As shown in Fig. 10, the PET block inserts a delay at the end of its execution in order to consume the remaining time (if any) and maintain the block’s periodicity. On the contrary, if the block takes longer than expected, leading to a period violation, a user defined error handling routine takes place.

4.2.2. Forced Execution Time
The FET Block enforces a concrete duration (specified in its only input argument) for the wrapped code block. Taking a look into Fig. 10 it can be seen that, as it is done in the PET block, extra duration at the end of the block will be consumed (delay insertion).

4.2.3. Budgeted Execution Time
The BET Block defines an upper bound duration for the wrapped code block. As shown in Fig. 10, the time remaining at the end of BET block’s execution is passed to the next sibling BET or PNET block (described latter). The parent FET or PET block is in charge of managing the execution time budget. However, as FET and PET blocks have a fixed duration, BET blocks can only use the remaining time budget of earlier finished same level BET or PNET blocks.

4.2.4. Period N Execution Time
The PNET Block accepts three input arguments. The first one determines an upper bound duration for the wrapped code block, the second one determines the th period at which the blocks is active, whereas the third one determines the offset of the wrapped code block in periods with respect to the start of the execution. Combining the period and offset arguments, tasks can be mapped to different frames (i.e. th period 3 and offset 1 means that the block will run every three frames starting with the first run at the second frame due to 1 period offset). The remaining time at the end of a PNET block is passed through sibling BET blocks (see Fig. 10). The parent FET or PET block manages the execution time budget among sibling BET blocks. PNET blocks within the same parent FET or PET block should be defined combining the second and third parameters in such a way that they will never run at the same time.

5. Formal timing specification
Within this research work, formal timing specifications are based on MULTIC Time Specification Language (MTSL) (Böde et al., 2017), a timing specification language defined within the MULTIC project.1

5.1. Components & contracts
The MULTIC project assumes systems to be built from components (see Fig. 3), which interact with the environment (including other components) through a set of ports linked with connectors. Within this context, timing specifications are defined over the ports of components, where any behaviour in the component model is observable.


Port	::	PortName —  ComponentName ‘.’ PortName
Timing specifications about components are expressed in terms of contracts by instances of MTSL. A contract states assumption(s) (denoted with an A) about the components environment and the behaviour that the component’s implementation must guarantee (denoted with a G), considering the component is used in a context where the assumption about the environment is accomplished. Therefore, the example contract in Fig. 4 states that assuming that an event occurs on Entry port every 20 ms, whenever an event is observed on Entry port, an event will be observed on Exit port within 0 to 20 ms.


Download : Download high-res image (39KB)
Download : Download full-size image
Fig. 3. General component model.

5.2. MULTIC Time Specification Language
MTSL is based on specification patterns, natural language like statements defined in terms of time traces that satisfy a pattern. Time traces are based on the notion of sampled signals (MTSL focuses on discrete-event signals) to determine the value of variables in the time domain.

Definition 3 Timed Trace

A timed trace observed at port , is defined as a tuple , where  is an infinite sequence of monotonic time instant and, for each time instant,  denotes the corresponding element from the value domain of port . Timed traces are required to be non-zeno, therefore, for each  exists a timed trace  such that . A set of timed traces observed at port  is denoted by .

The same way, a set of timed traces observed at a port set  is denoted by , where .

Projection  of traces over a port set  to port , where  if and only if .

Timing specifications describe relations among events, which are only observable at ports and fixed to a value domain. A timing specification refers to one or multiple events, where the event value may or may not be of importance:


EventSpec	::	Port  Port ‘.’ EventValue
The EventValue could consist of labels as well as (complex) values and if it is not specified in the EventSpec, any event observed at the Port is considered.

So, given a timed trace , an event , it is said to satisfy the event specification, denoted as 
⊧
 EventSpec, if either EventSpec specifies a port and  corresponds to its value domain or EventSpec specifies an event value and  equals to it.

Timing specifications can either refer to an only event, an event sequence or a set of events:


EventExpr	::	EventSpec  ‘(’ EventList ‘)’ 
‘{’ EventList ‘}’
EventList	::	EventSpec [‘,’ EventSpec]*
Extending the notion of satisfaction to event expressions, a timed trace , , , ,  is said to satisfy an event sequence , ,  if every event , , , satisfies the event specification . We say , , , ,  satisfies an event set , ,  if there is a sequence , ,  such that , , , ,  which is satisfied.

Timing specifications may refer to a time point or interval:


TimeExpr	::	Value Unit
Boundary	::	‘[’  ‘]’
Interval	::	TimeExpr  Boundary Value ‘,’
Value Boundary Unit
Time units and values in time expressions are restricted to usual time units and simple numbers:


Unit	::	s  ms  us  ns
Number	::	0 .. 9[ 0 .. 9 ]*
Value	::	Number  Number ‘.’ Number
In the following some of the patterns defined within the MULTIC time specification language (those relevant for this work) are presented.2

5.2.1. Event occurrence
To describe a repetitive event occurrence in a particular port, such as periodic events or events with minimum and maximum inter-arrival times, the Repetition pattern is introduced:


Repetition	::	EventList occurs every Interval
[ with RepetitionOptions ]?.
RepetitionOptions	::	Jitter [ and Offset ]?  Offset
[ and Jitter ]?
Jitter	::	jitter TimeExpr
Offset	::	offset Interval
The parameter Interval in the Repetition pattern determines the minimum and maximum time interval between subsequent occurrences of the EventList. The Jitter defines an additional delay between subsequent occurrences of the EventList, whereas the Offset defines a delay interval for the first occurrence of the EventList.

Definition 4 Repetition Pattern Semantics

Semantics of the repetition pattern “EL occurs every I with jitter J and offset O”. is defined as the set of timed traces 
 such that 
 corresponds to the event list EL, and , where the term  is an interval of the minimum period  and maximum period , denoted as ,  is the offset interval, and  is the jitter.  is required.

Fig. 5 shows multiple pattern instances with different parameters. The first one, shows a minimal instance of the pattern, with no jitter and no offset. In the second instance of the pattern a jitter up to 5 ms is added. The light blue bars in the time-line mark the period intervals as for the first pattern instance, showing that the jitter is “added” to the “baseline” periodic behaviour. The third instance defines a period interval (between 20 and 25 ms). As no offset nor jitter is defined in the third pattern, the first event occurs at 0 ms. The fourth pattern shows the application of the offset parameter, which is between [0, 10] ms. Therefore, the first event occurs somewhere in the interval (for example at 5 ms), whereas the time interval between two successive event occurrences is within an interval [20, 25] ms.

5.2.2. Reaction constraints
The Reaction pattern, which describes a forward delay over events, event sets and event sequences is defined as follows:


Reaction	::	whenever EventExpr occurs then
EventExpr occurs within Interval [once]?.
Definition 5 Reaction Pattern Semantics

Semantics of the reaction pattern “whenever  occurs then  occurs within I”., where  and  are either a set or a sequence of events that contain  and  events, respectively, is defined as a set of timed traces  such that ⊧⊧
⊧
⊧
.

The optional keyword once states that the pattern fails if more than one reaction occurs within the determined time window, therefore only one  exists such that the corresponding sequence satisfies .

Fig. 6 depicts multiple instances of the reaction pattern. The first time-line shows a fragment of a pattern instance where event f occurs within [15, 25] ms since event e occurs. In contrast to the first instance, the second one forbids multiple occurrences of event f within the specified time-window using the keyword once. The third pattern instance defines an event sequence (f, g) instead of a single event as the reaction to event e.

5.2.3. Causal event relations
To be able to reason, beyond the timely behaviour of events, about relation of events the order of occurrence of different events shall be captured. MTSL allows defining basic functional relations3 by assigning event values. The formal definition of causal event relations is as follows:

Definition 6 Causal Event Relation

Consider ports  and , and let  be the semantics of the ports. A causal event relation between  and  is a function where for all  and for all event occurrences  exist , ,  such that it holds , ,  and , , .

Causal event relations are transitive, meaning that given three ports  and causal event relations  and , the causal event relation  is given by: 

Based on the defined causal event relation, the causal version of the Repetition pattern is introduced:


CausalReaction	::	Reaction(EventSpec ‘,’ EventSpec
within Interval.
Definition 7 Causal Reaction Pattern Semantics

Semantics of the causal reaction pattern “Reaction() within I”., where  and  refer to  and , respectively, is defined as the set of timed traces  where for all 
, 
, and for all event occurrences  such that ⊧
⊧
, holds  and ⊧
⊧
.

An example of the causal reaction pattern is shown in Fig. 7. The dashed light blue line states that those events are related by the definition of causal reaction event relation. In contrast to the first instance in the non-causal reaction pattern (see first pattern instance in 6), in the causal reaction pattern instance (see Fig. 7) the reaction to the second occurrence of event e violates the pattern due to the causal relation.

6. RT legacy software migration
Fig. 8 depicts (from left to right) the real-time legacy software migration process (described in the following subsections) that ports the RT legacy control software (that complies with the legacy system model defined in Section 3) running on top of the legacy hardware platform to a new (different) hardware architecture.

The migration process consists of four main steps. The first step corresponds to the process of lifting the legacy timing properties (extract legacy timing properties, make them implicit in the legacy application and transform them into formal timing specification), which is presented in Section 6.1. To this end, time measurement and control blocks are annotated within the legacy application. These blocks, which are based on the time measurement and control blocks presented by Bruns et al. (2019), provide means to extract the legacy timing properties and enforce them during execution. The annotated code is then tested to check whether it meets the legacy system’s timing and functional properties. To do so, timing properties are transformed into formal timing specifications and compared against time traces, whereas a set of reference values for input state variables and the corresponding reference values for output control variables are extracted from the legacy system to check whether the functional behaviour is preserved. According to the results obtained, if any of the requirements (temporal and/or functional) are not met, time control blocks might have to be reallocated and the time budget as well as the timing specifications adjusted. The timing and functional test procedure as well as the block and budget reallocation process is described within Section 6.2. The next step, consists of porting the timing annotated binary code to a new ISA, which could either be implemented using dynamic BT, static BT or cross-compilation. From the feasibility study presented in Yarza et al. (2020), we concluded that the static approach ensures a lower translation overhead and more deterministic timing behaviour than the dynamic approach, so the migration flow has been implemented using Rev.ng static BT tool suit. If the legacy source code is platform and toolchain independent, a migration flow based on cross compilation could also be applied, but this will not be covered in this article. Therefore, with a focus on how the static binary translation tool handles the timing annotations, the timing aware translation process is described in Section 6.3. Finally, after the annotated legacy source code has been translated, temporal and functional requirements are tested once again and if needed time control blocks reallocated and time budget as well as timing specifications re-adjusted. It is worth to mention that the block reallocation as well as the time budget and contract adjustment step might have to be accomplished several times during the migration process.


Download : Download high-res image (229KB)
Download : Download full-size image
Fig. 10. Time control blocks’ structure and functionality. Description of execution time control blocks’ structure and functionality through the RT legacy application example (see Section 3.3). Time control blocks annotated in the legacy source code describe the assumed timing behaviour. PET block enforces a periodic execution. FET enforces a concrete duration. BET defines an upper bound duration and passes remaining time to next sibling BET or PNET blocks. PNET defines an upper bound duration for a code block that runs every th period starting at an specific period (according to its offset).

6.1. Lifting of timing properties
The timing property lifting process presented in Fig. 9 consists of three main stages: profiling, annotation, and time specification.


Download : Download high-res image (202KB)
Download : Download full-size image
Fig. 11. Time control blocks’ behaviour and nesting. Description of execution time control blocks’ behaviour and nesting through the RT legacy example application (see Section 3.3). PET1 is the root node. It has four child nodes: FET2, FET3, BET4 and BET5. PET1 manages the timing budget passed across BET4 and BET5 siblings. FET2 has two child nodes (BET6 and BET7) and manages the time budget passed across them. FET3 has three child nodes, two PNET blocks (PNET8 and PNET9) and a BET block (BET10). The timing budget passes across the sibling PNET and BET blocks is managed by their parent node, FET3.

6.1.1. Profiling legacy system
Profiling constitutes the first stage, where legacy source code, legacy system’s specifications and timing measurements are evaluated by an expert to extract the necessary timing information from the legacy system. Information regarding the period of each task, precedence relation and data sharing among tasks, as well as identification of critical sections is obtained through the analysis of the legacy source code, legacy system’s specifications and expert knowledge (hand-made). Whereas time measurement blocks (the EET described in Section 4.1.1), which are systematically annotated into the legacy source code (automatized), provide means to measure the end-to-end duration of a specific code section and save the result in memory (under block’s ID). The obtained timing data is then analysed to extract information regarding the WCET and offset of tasks. As a result of the profiling phase, legacy timing properties and the behavioural legacy source code (legacy sources code without any time control statement) are obtained.

6.1.2. Legacy timing enforcement
To enforce an appropriate temporal behaviour after the migration process, implicit legacy timing properties are made explicit in the behavioural legacy source code (automatized). The proposed time control solution is based on a block-level source code (systematic) annotation approach.

Based on the described time control blocks (see Section 4.2), the example legacy application presented in Section 3.3 is annotated as follows. The root node is a PET block with period set to , which is the GCD of all tasks’ period. Then, each task is wrapped into a BET or PNET block according to its period. Tasks with a period equal to that defined through the PET block are wrapped into BET blocks, whereas tasks with a greater period are mapped into PNET blocks. The budget for either block (BET or PNET) is determined by the WCET of the task it contains. Whereas the period and offset parameters of PNET blocks are determined according to the period of the task they wrap. For the example application, tasks  and  have a period two times greater than that defined on the PET block, therefore, the period argument is set to , whereas the offset parameter is set to  in the PNET block that wraps  and to  in the block containing . This way  and  will run every two periods starting at period  and period  respectively. Finally, in order to preserve a specific offset and minimum jitter among subsequent task instances for critical tasks, every BET or PNET block preceding a block wrapping a task marked as critical section must be wrapped into a FET block. Therefore, BET blocks corresponding to  and  are wrapped into a FET block. The duration of this FET block is set to  so that the next tasks marked as critical preserve their offset. The PNET blocks and the BET block corresponding to  are wrapped into another FET block. The upper limit of PNET blocks that can be wrapped in a FET block is determined by the period argument of the PNET blocks, which has to be equal for every PNET block within a FET, while the offset has to be different for each PNET block within a FET. To preserve the offset of the following critical task (), the duration of the FET block is set to . The resulting annotated code is shown in Fig. 10, and the corresponding tree diagram in Fig. 11.

6.1.3. Extract timing specifications
Finally, the annotated legacy application is systematically transformed into formal time specifications (automatized) that provide means for the latter validation of legacy timing properties (see Section 5).

Based on MULTIC approach, the RT legacy software migration solution describes each time control block as a component. Within each component, virtual ports are defined, at which events are observable, as well as the corresponding contract, which is based on MTSL repetition and causal reaction patterns. Moreover, component-to-component connections are done according to a causality order. Therefore, the annotated legacy example application presented in Fig. 10, which follows a tree diagram as depicted in Fig. 11, is transformed into a set of component nodes with their corresponding contract. The resulting component-contract structure is shown in Fig. 12.

This component-contract structure will later be used to validate the timing behaviour of the annotated legacy application. However, before applying the time specification, a consistency check must be performed. To this end, the concept of Virtual Integration Testing (VIT) is being used, which checks compatibility and refinement conditions. The former verifies whether two (or more) components can be put together without violating any of the contracts. That means that two components are compatible if the assumption about the environment of a component are not violated by another component connected to this component. The latter verifies whether the composition of a set of sub-components satisfies the contract(s) of the parent component. This means that the guaranteed behaviour of a set of sub-components must refine the behaviour guaranteed by the parent contract, within an environment that complies with the parent contract assumption. The details about VIT are out of the scope of this paper and can be found in Böde et al. (2017)


Download : Download high-res image (646KB)
Download : Download full-size image
Fig. 12. Ideal component-contract structure for the annotated example application. Description of component-contract structure through the RT legacy example application (see Section 3.3). Each component has its corresponding contract, composed of assumption(s) and guarantee(s), which are based on MTSL repetition and causal reaction patterns. Port names are shown in blue colour. Contracts describe an ideal behaviour and therefore do not describe possible time variations (jitter) present in real a scenario. In the timing validation phase (see Section 7) contracts are adjusted to handle such timing deviations.

6.2. Testing, reallocation & adjustment
To check that timing and functional requirements are still met after the lifting process, the control block annotated legacy application is executed on the legacy hardware platform and collected functional and timing traces are compared against their reference values (automated).

On the one hand, the timing test compares time traces that time control blocks generate at runtime against systematically obtained formal timing specifications using the MULTIC tooling (Böde et al., 2019), which allows expressing timing requirements in terms of contracts and provides means for their validation through a simulation based method based on the SystemC (Accellera, 2019) simulation framework. Fig. 13 depicts the process of testing the timing properties.

On the other hand, the functional test feeds the annotated legacy application running on the legacy hardware platform with a set of reference input data for state variables (usually provided by an expert group) and compares the output values obtained for control variables against a set of reference output data, which is obtained running the (original) legacy application on the legacy hardware platform. Fig. 14 depicts the process of testing the functional properties.


Download : Download high-res image (209KB)
Download : Download full-size image
Fig. 13. Description of the process for testing timing properties.

According to the timing and functionality test result, a time control block reallocation and budget adjustment process might be necessary (hand-made). During the lifting process, source code is extracted, modified and rearranged. In this reverse engineering process, the functional and timing behaviour of the legacy application might have been changed. Therefore, if the timing and/or functional test results is not successful (i.e., the allocated budget is not enough, the offset before critical section tasks is not appropriate, the task precedence relation has been corrupted), time control blocks need to be reallocated and budgets adjusted accordingly, while still ensuring an appropriate timing behaviour.


Download : Download high-res image (157KB)
Download : Download full-size image
Fig. 14. Description of the process for testing functional properties.


Download : Download high-res image (130KB)
Download : Download full-size image
Fig. 15. Description of the static binary translator based block handling.

Systematically generated timing specifications (see Fig. 12) describe an ideal timing behaviour. However, in a real scenario the timing behaviour is not ideal and timing deviations exist due to the overhead of time control block management or binary translation, as well as deviations caused by the underlying OS or hardware platform itself. As a consequence, formal timing specifications might need to be adjusted accordingly, while still ensuring an appropriate timing behaviour.


Download : Download high-res image (208KB)
Download : Download full-size image
Fig. 16. Overview of the flight controller (SAFEPOWER, 2017).

During the lifting process it might be necessary to repeat the temporal a functional property test, the control block reallocation and the budget and contract adjustment process several times, until all legacy system’s requirements are met, temporal as well as functional requirements.

6.3. Timing block support within static BT
The RT legacy software migration approach relies on a static binary analysis framework, Rev.ng (Federico et al., 2017). The core element in Rev.ng is its SBT tool, that combines the benefits of QEMU (Bellard, 2005) with those of LLVM (Lattner and Adve, 2004). Revamb parses the statically linked Linux binary and uses QEMU’s TCG as a front-end to generate tiny code instructions from any of the input architectures it supports. Then code in QEMU IR form is further translated into LLVM IR instructions. However, in QEMU, certain features such as syscalls and complex instructions (e.g. floating point division) are handled through a set of external functions (written in C) known as helper functions. Therefore, using Clang, QEMU helper functions are obtained in the form of LLVM IR and statically linked before generating the LLVM module. Besides the helper functions, additional support is needed mainly for initialization purposes. To this end, Revamb provides a set of support functions which are linked to the LLVM module. Then, the linked LLVM IR module is translated into machine code using LLVM compiler infrastructure.

For the static translation, the time control block annotated legacy application, obtained as a result of the lifting process, is statically linked to the Timing Measurement and Control Block (TMCB) library and compiled for the legacy hardware platform using a legacy Linux toolchain. The technical implementation of TMCBs as a library enables its use across multiple platforms. Then, the annotated binary is statically translated from legacy to the new ISA using Rev.ng tool-suite (automated). Fig. 15 depicts the described static binary translator based timing control block handling.

As it is done after the lifting process, after translating the annotated code temporal and functional properties need to be tested on the new hardware platform. If the test results are unsuccessful, time control blocks might have to be reallocated and/or the assigned time budget and/or timing specifications adjusted (see Section 6.2 for more information).

7. Timing-aware migration assessment
As a proof of concept, the RT legacy software migration approach described in the previous chapter (see Section 6) is used to port ARM Cortex-A9 legacy software to an Intel Atom processor. Therefore, the Xilinx Zynq-7000 System on a Chip (SoC) ZC702 evaluation kit and the MinnowBoard Turbot Dual-Core board have been selected as source and target platforms, respectively. The timing-aware migration assessment describes the evaluation of the implemented block level timing enforcement mechanism as well as the evaluation of the timing-aware static translation process. For each of the evaluation scenarios, the functional as well as the timing behaviour have been assessed. The migration assessment is accomplished through the example application (described in Section 3.3) and a flight control application. The example application provides a complete analysis in the sense that it contains tasks with different periods and some of the tasks are considered a critical code section, therefore, through the example every time control block can be evaluated. However, this is an example application that we implemented and therefore the great effort of porting third party code is excluded. On the contrary, the flight control application is a legacy application that was implemented by a third party and therefore, it is a suitable application to evaluate the effort of porting third party legacy source code.

The example application, first introduced in Section 3.3, resembles the typical pattern of a reactive control system. This bare-metal application includes seven periodic tasks (with different periods) executed following a static scheduling policy. The functional behaviour of the example application consists on a bit toggling sequence. Running the legacy example application on the ARM Cortex-A9 processor for 50 000 time steps (statistically representative enough), the output variable bit toggling sequence is observed and reference output data collected.

The flight control application that will be used in the evaluation process is the OFFIS multirotor (OFFIS, 2019), which supports a mixed-critical architecture and enables high-performance processing while still supporting a safe flight control. The flight control algorithm is responsible for computing the motor values (control variables) based on the control orders from the user (set-point) and the sensor data (process variables). Fig. 16 depicts the main components of the flight controller, which are Read Sensors, Sensor Processing, Read Remote, Remote Processing, Flight Controller, and Send Motor Values. To guarantee a stable flight behaviour, an update rate of 500 Hz must be ensured in the motor drivers, therefore the control cycle cannot exceed 2.1 ms. The multirotor application running on top of the ARM Cortex-A9 processor is fed with the reference input data, generated through a flight simulation program (the multirotor takes off, hoovers for a while and then lands), the execution lasts for 3000 time steps (statistically representative enough) and control variables are observed to collect the reference output data.


Download : Download high-res image (45KB)
Download : Download full-size image
Fig. 17. Ideal component-contract structure for the annotated multirotor application. The only component (PET36) has its corresponding contract. The contract describes the assumption and guarantee observable at Entry/Exit ports (named in blue colour). The contract describes an ideal behaviour and therefore does not describe possible time variations (jitter) present in real a scenario.

7.1. Block-level timing enforcement assessment
The timing enforcement solution presented in Section 6.1, which consist of a block-level source code annotation mechanism is being assessed in this section. To this end, each application is systematically annotated with timing control blocks.4 The annotated application is linked against the TMCB library and compiled for the ARMv7-A ISA. Then, the time control block annotated application runs on top of the ARM Cortex-A9 processor (running Preempt-RT Linux at a 666 MHz operation frequency) and the corresponding functional and timing data is collected.

7.1.1. Timing test
As described in Section 6.2, to test the timing behaviour, the annotated code (example — see Listing 1, and multirotor — see Listing 2) is systematically transformed into formal timing specifications (example — see Fig. 12, and multirotor — see Fig. 17). These timing specifications, together with the time traces that the annotated binary generates when running on top of the ARM Cortex-A9 processor are fed to the MULTIC tool and thus the timing behaviour is validated.


Download : Download high-res image (174KB)
Download : Download full-size image

Download : Download high-res image (54KB)
Download : Download full-size image
Ideal contracts.
Table 2a and b, respectively, show the time traces generated by the annotated example and flight control applications running on the ARM Cortex-A9 processor validated against the ideal component-contract structure (example — see Fig. 12, and multirotor — see Fig. 17).

Given that the contracts presented in Fig. 12, Fig. 17 are ideal and therefore do not consider any timing variation cause by the overhead of time control block management or by the underlying OS and hardware platform itself, a great percentage of the traces did not pass the corresponding contract (about 45% of the time traces for the example application, and about 99% for the multirotor application). In order to cover the timing deviations present in a real scenario, contracts are adjusted as follows:


Table 2. Time traces generated by the annotated (a) example and (b) flight control applications running on the ARM Cortex-A9 processor validated against the ideal and annotation adjusted component-contract structure (example — see Figs. 12 and 18a respectively, and multirotor — see Figs. 17 and 18b respectively). The first column shows the time trace. For the ideal contracts, the second column shows the valid time interval according to time trace(s) and the corresponding contract and the third column shows contract pass/fail information. For the annotation adjusted contracts, the fourth column shows the valid time interval and the fifth column shows contract pass/fail information..

(a) Annotated example application
Time trace	Ideal contract	Annotation adjusted contract
Valid interval	Pass/Fail	Valid interval	Pass/Fail
PET20.Entry 0 ns	[0,0] ns	✓	[0,0] ns	✓
FET21.Entry 486665 ns	[0,0] ns	✗	[0,500000] ns	✓
BET22.Entry 563782 ns	[0,0] ns	✗	[0,600000] ns	✓
BET22.Exit 690209 ns	[563782,5563782] ns	✓	[563782,5563782] ns	✓
BET26.Entry 747273 ns	[0,5000000] ns	✓	[0,5000000] ns	✓
BET26.PEntry 486665 ns	[0,0] ns	✗	[0,500000] ns	✓
BET26.Exit 864886 ns	[747273,10747273] ns	✓	[747273,10747273] ns	✓
FET21.Exit 10575312 ns	[10486665,10486665] ns	✗	[10486665,10586665] ns	✓
FET31.Entry 10663988 ns	[10000000,10000000] ns	✗	[10000000,10700000] ns	✓
PNET32.Entry 10730281 ns	[10000000,10000000] ns	✗	[10000000,10800000] ns	✓
PNET32.Exit 10849301 ns	[10730281,11030281] ns	✓	[10730281,11030281] ns	✓
BET40.Entry 10908774 ns	[10000000,13000000] ns	✓	[10000000,13000000] ns	✓
BET40.PEntry 10663988 ns	[10000000,10000000] ns	✗	[10000000,10700000] ns	✓
BET40.Exit 11026414 ns	[10908774,11163988] ns	✓	[10908774,11163988] ns	✓
FET31.Exit 15748180 ns	[11163988,11163988] ns	✗	[15663988,15763988] ns	✓
BET45.Entry 15812727 ns	[15000000,15000000] ns	✗	[15000000,15900000] ns	✓
BET45.Exit 15927360 ns	[15812727,16012727] ns	✓	[15812727,16012727] ns	✓
BET49.Entry 16072984 ns	[15000000,17000000] ns	✓	[15000000,17000000] ns	✓
BET49.PEntry 0 ns	[0,0] ns	✓	[0,0] ns	✓
BET49.Exit 16191203 ns	[16072984,20000000] ns	✓	[16072984,20000000] ns	✓
PET20.Exit 20079694 ns	[20000000,20000000] ns	✗	[19800000,20400000] ns	✓
(b) Annotated flight control application
Time trace	Ideal contract	Annotation adjusted contract
Valid interval	Pass/Fail	Valid interval	Pass/Fail
PET36.Entry 0 ns	[0,0] ns	✓	[0,0] ns	✓
PET36.Exit 2041568 ns	[2000000,2000000] ns	✗	[1910000,2150000] ns	✓
PET36.Entry 2115352 ns	[2000000,2000000] ns	✗	[1940000,2210000] ns	✓
PET36.Exit 4123452 ns	[4115352,4115352] ns	✗	[4025352,4265352] ns	✓
PET36.Entry 4185823 ns	[4115352,4115352] ns	✗	[4055352,4325352] ns	✓
PET36.Exit 6123593 ns	[6185823,6185823] ns	✗	[6095823,6335823] ns	✓
PET36.Entry 6215352 ns	[6185823,6185823] ns	✗	[6125823,6395823] ns	✓
PET36.Exit 8256823 ns	[8215352,8215352] ns	✗	[8125352,8365352] ns	✓
PET36.Entry 8352682 ns	[8215352,8215352] ns	✗	[8155352,8425352] ns	✓
PET36.Exit 10360680 ns	[10352682,10352682] ns	✗	[10262682,10502682] ns	✓
•
Adjust the offset in some of the assumptions (following a repetition pattern) to cover little variations on the time distance from the start of execution to the first occurrence of an event on a particular port.

•
Adjust the interval in some of the assumptions (following a repetition pattern) to cover little variations on the time distance between repetitive event occurrences on a particular port.

•
Adjust the interval in some of the guarantees (following a causal reaction pattern) to cover little variations on the time distance between causally related events on input/output ports.

Annotation adjusted contracts.
Figs. 18a and 18b show the adjusted component-contract structure for the annotated example and flight control applications. Changes in the contracts with respect to the ideal component-contract structure (example — see Fig. 12, and multirotor — see Fig. 17) are shown in bold. Table 2a and b show the time traces generated by the annotated example and flight control applications running on the ARM Cortex-A9 processor validated against the annotation adjusted component-contract structure (example — see Fig. 18a, and multirotor — see Fig. 18b). Changes in the time interval with respect to the ideal component-contract structure are shown in bold.

Result analysis.
Result show that systematically generated formal timing specifications needed to be adjusted to cover the timing deviations caused by time control block management overhead or the underlying OS and hardware platform itself. After the adjustment of formal timing specifications, time traces generated at runtime by the annotate example and multirotor applications fit into the defined timing contracts.


Download : Download high-res image (690KB)
Download : Download full-size image
Fig. 18. Adjusted component-contract structure for the annotated (a) example and (b) flight control applications. Each component has its corresponding contract. Contracts describe the assumptions and guarantees observable at input/output ports (named in blue colour). Contracts have been adjusted to cover possible jitter present on a real scenario, in this case adjustments are applied for the application running on the ARM Cortex-A9 processor. Changes in the contracts with respect to the ideal component-contract structure (example — see Fig. 12, and multirotor — see Fig. 17) are shown in bold.


Download : Download high-res image (176KB)
Download : Download full-size image
Fig. 19. Functional test results for the annotated and translated example applications running on the ARM Cortex-A9 and Intel Atom E3866 processors respectively. For each time step (X-axis) the corresponding output variable value (Y-axis) is shown, for the legacy (without annotations), annotated and translated example application. On every test scenario (legacy, annotated and translated), the bit toggling sequence is equivalent..


Download : Download high-res image (471KB)
Download : Download full-size image
Fig. 20. Functional test results for the annotated and translated multirotor applications running on the ARM Cortex-A9 and Intel Atom E3866 processors respectively. (a) shows for each time step (in the X-axis) the corresponding value of motor front point variable (in the Y-axis), (b) shows for each time step (in the X-axis) the corresponding value of motor rear point variable (in the Y-axis), (c) shows for each time step (in the X-axis) the corresponding value of motor right point variable (in the Y-axis), and (d) shows for each time step (in the X-axis) the corresponding value of motor left point variable (in the Y-axis). Every graph, (a), (b), (c), and (d), shows the results obtained for the legacy (without annotations), annotated and translated multirotor application. On every test scenario (legacy, annotated and translated), the output value of control variables is equivalent.

7.1.2. Functional test
The functional test compares the reference output value for control variables with the output value, for those control variables, when running the annotated applications (example — see Listing 1, and multirotor — see Listing 2) on the ARM Cortex-A9 processor, using reference input data for state variables.5

Fig. 19, Fig. 20 show the functional behaviour of the example and flight control applications respectively. The former, shows the bit toggling sequence of the example application output variable on both test scenarios (legacy and new hardware platform). However, due to scaling problems, the figure depicts just the output variable value for the first 100 time steps. The latter, shows the output values for each of the multirotor control variables on both test scenarios. Control variables are observed for 3000 time steps (about 6 seconds simulation).

Result analysis.
Results show that the signal observed on every control variable is equivalent before and after the lifting of timing properties.


Table 3. Time traces generated by the translated (a) example and (b) flight control applications running on the Intel Atom E3866 processor validated against before and after translation adjusted component-contract structure (example — see Figs. 18a and 21a respectively, and multirotor – see Figs. 18b and 21b respectively). The first column shows the time trace. For the annotation adjusted contracts, the second column shows the valid time interval according to time trace(s) and the corresponding contract and the third column shows contract pass/fail information. For the translation adjusted contracts, the fourth column shows the valid time interval and the fifth column shows contract pass/fail information..

(a) Translated example application
Time trace	Annotation adjusted contracts	Translation adjusted contracts
Valid interval	Pass/Fail	Valid interval	Pass/Fail
PET20.Entry 0 ns	[0,0] ns	✓	[0,0] ns	✓
FET21.Entry 717363 ns	[0,500000] ns	✗	[0,800000] ns	✓
BET22.Entry 742831 ns	[0,600000] ns	✗	[0,800000] ns	✓
BET22.Exit 794687 ns	[742831,5742831] ns	✓	[742831,5742831] ns	✓
BET26.Entry 814523 ns	[0,5000000] ns	✓	[0,5000000] ns	✓
BET26.PEntry 717363 ns	[0,500000] ns	✗	[0,800000] ns	✓
BET26.Exit 852282 ns	[814523,10717363] ns	✓	[814523,10717363] ns	✓
FET21.Exit 10786757 ns	[10717363,10817363] ns	✓	[10717363,10817363] ns	✓
FET31.Entry 10817126 ns	[10000000,10700000] ns	✗	[10000000,10900000] ns	✓
PNET32.Entry 10838593 ns	[10000000,10800000] ns	✗	[10000000,10900000] ns	✓
PNET32.Exit 10888800 ns	[10838593,13838593] ns	✓	[10838593,13838593] ns	✓
BET40.Entry 10909998 ns	[10000000,13000000] ns	✓	[10000000,13000000] ns	✓
BET40.PEntry 10817126 ns	[10000000,10700000] ns	✗	[10000000,10900000] ns	✓
BET40.Exit 10949420 ns	[10909998,15817126] ns	✓	[10909998,15817126] ns	✓
FET31.Exit 15884580 ns	[15817126,15917126] ns	✓	[15817126,15917126] ns	✓
BET45.Entry 15942260 ns	[15000000,15900000] ns	✗	[15000000,16000000] ns	✓
BET45.Exit 16050311 ns	[15942260,17942260] ns	✓	[15942260,17942260] ns	✓
BET49.Entry 16104890 ns	[15000000,17000000] ns	✓	[15000000,17000000] ns	✓
BET49.PEntry 0 ns	[0,0] ns	✓	[0,0] ns	✓
BET49.Exit 16201764 ns	[16104890,20000000] ns	✓	[16104890,20000000] ns	✓
PET20.Exit 20088814 ns	[19800000,20400000] ns	✓	[19800000,20700000] ns	✓
(b) Translated flight control application
Time trace	Annotation adjusted contracts	Translation adjusted contracts
Valid interval	Pass/Fail	Valid interval	Pass/Fail
PET36.Entry 0 ns	[0,0] ns	✓	[0,0] ns	✓
PET36.Exit 2124215 ns	[1910000,2150000] ns	✓	[1890000,2240000] ns	✓
PET36.Entry 2341230 ns	[1940000,2210000] ns	✗	[1920000,2380000] ns	✓
PET36.Exit 4568417 ns	[4251230,4491230] ns	✗	[4231230,4581230] ns	✓
PET36.Entry 4646059 ns	[4281230,4551230] ns	✗	[4261230,4721230] ns	✓
PET36.Exit 6843136 ns	[6556059,6796059] ns	✗	[6536059,6886059] ns	✓
PET36.Entry 6935216 ns	[6586059,6856059] ns	✗	[6566059,7026059] ns	✓
PET36.Exit 9150728 ns	[8845216,9085216] ns	✗	[8825216,9175216] ns	✓
PET36.Entry 9243715 ns	[8875216,9145216] ns	✗	[8855216,9315216] ns	✓
PET36.Exit 11303320 ns	[11153715,11393715] ns	✓	[11133715,11483715] ns	✓
7.2. Timing-aware static translation assessment
This section evaluates the timing equivalent static BT approach described in Section 6.3. As the timing enforcement assessment, the assessment of the timing-aware static legacy software translation is accomplished through the example and multirotor applications. To this end, each of the time control block annotated applications that was statically linked and compiled for the ARMv7-A ISA is statically translated, using Rev.ng, into an equivalent binary for x86 ISA. The translated binary is then executed on top of the Intel Atom E3866 processor (running Preempt-RT Linux at a 1463 MHz operation frequency) and the corresponding functional and timing data is collected.

7.2.1. Timing test
The timing test validates the timing behaviour of translated applications (example — see Listing 1, and multirotor — see Listing 2) running on the Intel Atom E3866 processor. Using MULTIC tool, the time traces that each of the translated applications generates at run-time are validated against the corresponding component-contract structure.

Annotation adjusted contracts.
Table 2a and b show the time traces generated by the translated example and flight control applications running on the Intel Atom E3866 processor validated against the component-contract structure adjusted as part of the timing enforcement assessment (example — see Fig. 18a, and multirotor — see Fig. 18b).

The contracts presented in Figs. 18a and 18b had already been adjusted, however, they do not consider any timing variation cause by the overhead of the static translation process. Moreover, the code is now running on a new hardware platform, so time variations caused by the underlying OS and hardware platform itself, might vary. This caused many of the traces to fail the corresponding contract (about 30% of the traces for the example application and about 60% of the traces for the multirotor application). In order to cover the timing deviations caused by the static translation and the new hardware platform, contracts are adjusted as it was done before translation.

Translation adjusted contracts.
Figs. 21a and 21b show the adjusted component-contract structure for the translated example and flight control applications. Changes in the contracts with respect to (before translation) adjusted component-contract structure (example — see Fig. 18a, and multirotor — see Fig. 18b) are shown in bold. Table 3a and b show the time traces generated by the annotated example and flight control applications running on the Intel Atom E3866 processor validated against the translation adjusted component-contract structure (example — see Fig. 21a, and multirotor — see Fig. 21b). Changes in the time interval with respect to the validation against (before translation) adjusted component-contract structure are shown in bold.


Download : Download high-res image (689KB)
Download : Download full-size image
Fig. 21. Adjusted component-contract structure for the translated (a) example and (b) flight control applications. Each component has its corresponding contract. Contracts describe the assumptions and guarantees observable at input/output ports (named in blue colour). Contracts have been adjusted to cover possible jitter present on a real scenario, in this case adjustments are applied for the applications running on the Intel Atom E3866 processor. Changes in the contracts with respect to (before translation) adjusted component-contract structure (example — see Fig. 18a, and multirotor — see Fig. 18b) are shown in bold.

Result analysis.
Result show that formal timing specifications adjusted as part of the timing enforcement assessment needed to be re-adjusted to cover the timing deviations cause by the new hardware platform and translation overhead. After re-adjusting the formal timing specifications, time traces generated at runtime by the translated example and multirotor applications fit into the defined timing contracts.

7.2.2. Functional test
The functional test compares the reference output value for control variables with the output value (for those control variables) when running the systematically annotated and then translated applications on the Intel Atom E3866 processor, using reference input data for state variables 5 (example — see Fig. 19, and multirotor — see Fig. 20).

Result analysis.
Results show that the signal observed on every control variable is equivalent before and after the timing-aware migration process.

8. Conclusion
This research work, first, reasons about the need for a portable legacy software migration solution that preserves the timing as well as the functional behaviour of the retargeted application. In the direction to cover this gap, a RT legacy software migration solution is proposed, which is based on existing static binary translation solution enhanced with a timing enforcement mechanism that at the same time provides means for validating the enforced timing behaviour. The proposed solution is then evaluated, through multiple legacy applications (example and multirotor). Legacy source code is ported from the ARM Cortex-A9 processor to the Intel Atom E3866.

The timing-aware migration assessment concludes that the defined temporal constructs provide means to enforce a specific timing behaviour. The enforces timing behaviour can then be validated on the new hardware platform combining the use of the time traces that temporal constructs generate at runtime, systematically generated formal timing specifications, and MULTIC tool. Results show that although timing specifications needed to be relaxed such that they reflect time uncertainties generated by time control block management, the static translation process as well as the new hardware platform itself, it is possible to achieve a timing behaviour equivalent to that in the legacy system.

Future work considers lifting Input/Output (I/O) dependent code and implementing an I/O virtualization mechanism to provide the ported legacy application means to interact with the external environment when running on the new platform.

CRediT authorship contribution statement
Irune Yarza: Conceptualization, Software, Investigation, Writing - original draft, Writing - review & editing. Mikel Azkarate-askatsua: Conceptualization, Validation, Supervision. Peio Onaindia: Validation. Kim Grüttner: Conceptualization, Validation, Supervision. Philipp Ittershagen: Conceptualization, Software. Wolfgang Nebel: Supervision.