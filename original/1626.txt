Abstract
With the growing complexity of railway control systems, it is required to preform runtime safety checks of system executions that go beyond conventional runtime monitoring of pre-programmed safety conditions. Runtime verification is a lightweight and rigorous formal method that dynamically analyses execution traces against some formal specifications. A challenge in applying this method in railway systems is defining a suitable monitoring specification language, i.e., a language that is expressive, of reasonable complexity, and easy to understand. In this paper, we propose parameterized modal live sequence charts (PMLSCs) by introducing the alphabet of the specification into charts to distinguish between silent events and unexpected events. We further investigate the expressiveness and complexity theories of the language. In particular, we prove that PMLSCs are closed under negation and the complexity of a subclass of PMLSCs is linear, which allows the language to be used to monitor a system online. Finally, we use PMLSCs to monitor an RBC system in the Chinese high-speed railway and evaluate the performance. The experimental results show that the PMLSC has high monitoring efficiency, and can reduce false alarm rate by introducing alphabets of charts.

Previous
Next 
Keywords
Runtime verification

Live sequence chart

Train control system

1. Introduction
Chinese train control system (CTCS) is a Chinese railway signalling system that ensures the safety of train operations. The CTCS Level 3 is closely related to the European Train Control System ETCS level 2 and 3, and is designed for high-speed passenger transportation. The CTCS is a typical safety critical system, whose failures may result in serious consequences of death to people and loss to property. Fail-safety is a key design feature of railway signalling systems. It means that whenever a failure occurs in a railway system, the system should transit into some safe-side states that lead the train to stop quickly. To achieve the fail-safety, runtime monitoring techniques are applied for detecting system failures by checking, e.g., memory integrity and pre-programmed safety conditions. However, with the growing complexity of CTCS software, it is required to monitor more complicated logical safety properties beyond conventional runtime monitors.

Runtime verification is a lightweight formal method that checks the execution of a system against some specifications. Runtime verification is performed by using a monitor, which is a device or piece of software that observes the system and generates a verdict (true or false) as a result. With scalable monitoring specifications, runtime verification has a potential to monitor desired safety properties of modern complex railway software. The quality of a runtime verification system depends on the quality of its monitoring specification. To make a monitor easier to understand and build, its specification is often formalized with some sort of temporal logic, such as linear temporal logic (LTL) and its extensions. Although these formalisms are expressive and technically sound for monitoring, they are inefficient for specifying the interleaving of subsystems. Moreover, railway engineers are not familiar with these textual formalisms and need extensive training to understand and use them efficiently.

We aim to address the above mentioned problems by writing monitoring specifications with a graphic formalism. In railways, a well adopted means to understand the control system of a train is via the specifications of its operational scenarios. Such typical scenarios include the start of mission, override, level transition, change of train orientation, RBC/RBC handover, etc. The formalism of sequence charts are attractive to specify interactive behaviours between subsystems. The UML sequence diagram is widely used in railway industries for representing system specifications. However, being a semi-formal language, the semantics of the UML sequence diagram suffers from lack of expressiveness. One of the main drawbacks is that the UML sequence diagram cannot differentiate between the required and allowed behaviours of a system. Damm and Harel overcome this drawback by defining the language of live sequence charts (LSCs), which introduces the notations of the universal and existential charts.

When used for monitoring specifications, the language of LSCs suffers from an inherent shortcoming of expressing properties with necessary conditions. Additionally, the language of standard LSCs is not closed under complement, and it suffers from semantic confusions due to the introduction of negation operators (Harel and Maoz, 2008). In our previous work (Chai and Schlingloff, 2017), we defined the language of the parameterized extended LSC (PeLSC), which introduces the notations of the necessary and sufficient precharts, and a special symbol  for executing any one out of all possible events of charts. These extensions make PeLSCs capable for the expressiveness of regular languages under certain conditions. However, when the language of PeLSC is applied to construct monitoring specifications for real-world railway applications, sometime the symbol  is not used intuitively, resulting to highly incorrect monitoring rates in some cases. For example, consider the following property of the RBC/RBC handover procedure in CTCS level 3: if and only if a train sends an “approaching” message to the handover RBC, then the RBC returns an “RBC/RBC handover command” message to the train. After that, if the train sends a “request movement authority (MA)” message to the handover RBC, it must return an “MA” message to the train. This procedure is specified in two charts of PeLSCs. These two charts have different irrelevant messages, i.e., silent events. Since a silent event in PeLSC is defined based on a unique alphabet, the language of PeLSCs cannot express this property in an intuitive manner.

Contribution
In this paper, we first propose the language of the parameterized modal live sequence chart (PMLSC) by introducing the alphabet of charts into PeLSCs. With this extension, the language can accurately formulate silent events, which improves the safety protection ability of monitors. Second, we investigate the expressiveness and complexity theories of the novel language. In particular, we prove that PMLSC is closed under negation, which solves a long-standing problem in this area. The complexity of a subclass of PMLSC is linear with respect to the lengths of words, which enables a system to be monitored online. By contrast, full PMLSC is NP-complete or undecidable, depending on the feature of domains of variables. Third, we develop a PMLSC monitoring algorithm based on language translation and trace slicing. This algorithm substantially improves the monitoring efficiency of large-scale system executions. Finally, we apply our PMLSC to monitor a concrete example of Radio Block Center (RBC) executions of the CTCS level 3. The experimental results are promising: PMLSC monitors with the developed algorithm achieve high performance and are able to prevent known errors, as well as many other unknown possible defects, hidden in an RBC system from evolving into accidents.

The rest of this paper is organized as follows. Section 2 provides a brief survey of related work. Section 3 presents the framework and features of CTCS level 3. Section 4 defines the novel language of PMLSCs. Section 5 proves some theoretical results of the expressiveness and complexity of PMLSCs. Section 6 develops algorithms for monitoring large-scale system executions. Section 7 provides a concrete example of monitoring an RBC system of CTCS level 3. Section 8 contains conclusions and directions for future work.

2. Related work
Monitoring runtime status of railway control systems has a long tradition. For example, every Chinese high-speed railway system is equipped with a dynamic monitoring system (DMS) that checks memory integrity, communication between on-board and wayside subsystem and other preprogrammed safety conditions. Unfortunately, the growing complexity of railway systems requires runtime monitoring that go beyond conventional monitors. Runtime verification is a lightweight formal method that verifies runs of a software system in detecting faults (Delgado et al., 2004, Havelund and Goldberg, 2008, Sokolsky et al., 2012, Falcone et al., 2013, Bartocci et al., 2018). Linear temporal logic (LTL) is a widely adopted formalism in runtime verification. In order to allow the runtime verification to perform better over a finite length of executions, Bauer et al. propose a three valued LTL (LTL
) (Bauer et al., 2011) and a four valued LTL (RV-LTL) (Bauer et al., 2010) for expressing uncertainties likely to be caused by unknown future executions. Runtime verification has been applied to monitor the interactions of agents in multi-agent systems. Ancona et al. propose a formalism for tracing expressions of specifications in such systems (Ancona et al., 2012). They further prove that the formalism is more expressive than LTL (Ancona et al., 2016). Aceto et al. prove the runtime monitorability of the properties specified by the Hennessy–Milner logic with recursion (Aceto et al., 2019a).

Boer et al. propose a textual formalism based approach for monitoring the protocol- and data-oriented properties of a communication process (de Boer and de Gouw, 2014). The language of live sequence charts, proposed as an extension of message sequence charts (Damm and Harel, 2001), can be used to verify event traces of systems at runtime (Maoz and Harel, 2011). Harel et al. propose a play-in/play-out approach for modelling with LSCs (Harel et al., 2002). Bontemps et al. prove that any LSC specification can be translated into LTL formulae (Bontemps and Schobbens, 2007). Kugler et al. develop an efficient algorithm for translating LSCs into LTL formulae (Kugler et al., 2005). The expressive power and complexity of LSCs are discussed in a previous survey (Harel et al., 2008). Sun et al. show that LSCs can be translated into CSP (Sun and Dong, 2005). Kumar et al. extend the LSC language with Kleene star, subcharts, and hierarchical charts (Kumar and Mercer, 2009). They further translate their LSCs into automata for verification. Taking silent actions into account, Aceto et al. study the issues related to the monitorability of properties (Aceto et al., 2017). Harel et al. propose modal sequence diagrams with “consider” and “ignore” operators to define relevant and irrelevant messages. However, those operations introduce confusions in negation of charts (Harel and Maoz, 2008). Translations from timed sequence diagrams into time Petri nets are then proposed (Andrade et al., 2009, Yang et al., 2012). Our parameterized extensions of LSCs are inspired by the treatment of time in LSCs proposed by Harel and Marelly (2002), in which a time constraint is defined by a combination of assignment and condition structures. By contrast, we provide general notation for arbitrary data parameters.

Diekert et al. prove that the complexity of deciding the liveness and monitorability for Büchi automata are both PSPACE-complete; and that of deciding the liveness of the LTL formulae is EXPSPACE-complete (Diekert et al., 2015). Bonakdarpour et al. study the complexity of the problem of model checking for HyperLTL (Bonakdarpour and Finkbeiner, 2018). Aceto et al. analyse the complexity bounds of various formalisms, which provides an excellent guide in choosing specification languages for monitoring overhead aspects (Aceto et al., 2020). As shown in Harel et al. (2008), the complexities of model checking reachability and centralized synthesis of LSCs are PSPACE-complete and EXPTIME-complete, respectively. Since the language of PMLSCs has more expressiveness, solving the above problems of the formalism in general has no lower complexity. However, as shown in the present work, the word problem of a subclass of PMLSC is linear. Therefore, the language is feasible for specifying some kinds of monitoring properties.

Monitoring events that carry data are an important research area of runtime verification [45]. Ahrendt et al. propose a runtime verification approach for monitoring those properties which combine features of both data and control (Ahrendt et al., 2017). Colombo et al. propose a well scaled tool, Larva, for monitoring real-time properties of Java programmes (Colombo et al., 2009, Colombo et al., 2009). RuleR (Barringer et al., 2010) and LogicFire (Havelund, 2014b) are developed for monitoring data-relevant properties. Although these rule-based runtime verification systems have high performance, they are not attractive for practical applications. TraceMatches (Allan et al., 2005) is essentially a language of regular expressions that extends the language of AspectJ (Kiczales et al., 2001) by introducing free variables in the matching patterns. JavaMOP addresses parametric specification and monitoring using TraceMatches (Meredith et al., 2012). TraceMatches and JavaMOP are defined on the basis of trace slicing, which translates parameterized events into propositional events. However, these trace slicing algorithms can handle only traces where all events with the same name carry the same parameters.

Another important direction of monitoring parameterized properties is based on automata theory. Quantified event automata (Barringer et al., 2012) are an extension of the trace slicing methods mentioned above. Data automata have been proposed as a down-scaled version of Rete to an automaton-based formalism (Havelund, 2014a). Furthermore, various extensions of temporal logic have been proposed for monitoring parameterized/timed event traces, such as TLTL (Bauer et al., 2011), MTL (Basin et al., 2012), TPTL (Chai and Schlingloff, 2013), MDL (Basin et al., 2017), MFOTL (Basin and Klaedtke, 2015) and LTL
 (Bauer et al., 2015). Basin et al. report the development and correctness proofs in Isabelle/HOL of monitoring for the metric first-order dynamic logic (Basin et al., 2020). These formalisms are expressive and technically sounds to perform runtime verification. However, the scenarios of railway systems specified with these textual-based languages are complicated and difficult to be understood by railway engineers.

3. CTCS level 3
CTCS level 3 is characterized by bi-directional communication and wayside subsystems via a radio block centre (RBC). It adopts features from the European train control system (ETCS) level 2. In CTCS level 3, continuous radio communication is used to exchange train control information between the train and the wayside equipment. Instead of using Global System for Mobile Communication (GSM), in the CTCS level 2 train operation related information are transmitted via track circuits. This information includes the speed, direction and location of the train, and the maximum speed and distance for the train.

3.1. Typical architecture of CTCS level 3
The typical architecture of CTCS level 3 is shown in Fig. 1.

The centralized traffic control (CTC) is responsible for directing train operations. Depending on the train schedule, the CTC generates route request commands and sends them to the interlocking. In CTCS level 3, a route is a path of railway (typically) between two signals in a railway station on which a train can move. The CTC also provides an interface for dispatchers to set up temporary speed restrictions and emergency brake commands and send them to the train via the RBC.


Download : Download high-res image (203KB)
Download : Download full-size image
Fig. 1. Typical architecture of CTCS level 3.

The interlocking is responsible for setting and granting requested routes. When a route command is received from the CTC, the interlocking guarantees that the route is safe to use by controlling the wayside infrastructure. The control is proceeded with respect to the status of the wayside infrastructure stipulated by the interlocking table. After the route is locked, the interlocking sends the route information to the RBC.

In an interlocking table, relevant wayside infrastructures include tracks, points and signals. When all tracks on the route are free and all points are locked in the required positions, the interlocking clears the signal and informs the RBC that the route is available. By contrast, if (some part of) the route is occupied by another train, the interlocking informs the RBC that the route is used.

The RBC is responsible for computing movement authorities (MAs) for a train. An MA is a succession of geographic railway areas that a train can safely operate in. The furthest point of an MA is indicated by the end of authority (EoA), which is given to a train by the RBC. When a train approaches its EoA, the train applies for a new MA by sending an “MA request” to the RBC. After receiving this request, the RBC generates an extension of the MA for the train according to the physical location and operation plan of the train. If the train is running through a railway station, the MA application procedure is performed based on the available routes supplied by the interlocking. After a route is locked, the RBC sends the train an updated MA to the end of the route.

The automatic train protection (ATP) is responsible for guaranteeing safe movement of a train. According to the EoA and railway line engineering data, the ATP computes a speed-distance curve of the MA area that consists of the maximum safe speed at each location between the train and the EoA. If the running speed of a train exceeds its speed-distance curve, the ATP initiates a service/emergency brake.

3.2. Monitoring specifications of CTCS level 3
In the context of CTCS level 3, the high-level safety requirements are collision and derailment free. Since these conditions are abstract, they cannot be used directly as monitoring specifications directly. To solve this problem, we formulate safety-critical scenarios of CTCS level 3 as monitoring specifications of the system. With such properties, a monitor can detect execution errors in the system before the errors evolve into failures. The safety guarantee ability of the monitor is therefore increased. In this paper, we show how to specify procedures of MA extensions and RBC/RBC handover as properties to be monitored.

CTCS level 3 behaviour includes interactions between on-board and wayside subsystems with complicated logical relations. In addition, executions of CTCS level 3 system carry various data, including time, train position, train speed and other engineering data. Thus, the language should be able to formulate parameterized properties to specify the constraints of the data. Therefore, we choose to use LSCs and their extensions as the monitoring specification languages. The language of LSCs is defined by extending message sequence charts (MSCs), which can graphically specify the interleaving behaviour among the components of a system in an intuitive manner. Because the language of LSCs is proposed as a system modelling language, some shortcomings arise in expressiveness when specifying system properties. Consequently, the language should be extended to meet the expressiveness requirements of CTCS monitoring.

4. Parameterized modal live sequence charts
The language of LSC is defined by introducing universal and existential charts into MSCs. With this extension, the language can distinguish between necessary and possible behaviour of a system. We define parameterized extended live sequence charts (PMLSCs) by introducing the alphabet of charts to make the language more practical for expressing monitoring properties.

4.1. Basic charts
The language of PMLSCs is defined on the basis of basic charts, which are visually similar to MSCs. A basic chart specifies communication (i.e., the exchange of messages) among a set of lifelines. Intuitively, a lifeline is composed of a sequence of communication actions, i.e., sending and receiving of a message. A communication is made between two lifelines. It associates two events (i.e. actions) representing the sending and receiving actions of the message, respectively. A basic chart describes the following partial orders between two events.

R1:
An event at a lower position of a lifeline follows an event at a higher position of the same lifeline; and

R2:
an event of sending a message precedes the event of receiving the same message.

Formal definitions of basic charts are given as follows. Let  be a set of messages and  be an alphabet of events; that is, an event is either  or , indicating that the message  is sent or received, respectively. A lifeline 
 is a finite (possible empty) sequence of events. Given an -tuple of lifelines 
 with 
, we say that an event 
 occurs at the th position of the th lifeline in . An event occurrence  is defined as a tuple consisting of an event  and the occurrence location  of  in . Given a message , a communication 
 is a pair of two event occurrences that represent sending and receiving .

Definition 1 Basic Chart

A basic chart  is a three-tuple  of lifeline , a set  of communications and the alphabet  of the chart, where each event occurrence in  is contained in at most one communication.

Let  and  be all events and event occurrences appearing in , respectively. It holds that 
. A basic chart is allowed to specify only the sending or the receiving of a message. In addition, an event is allowed to occur multiple times in a basic chart, e.g., a basic chart can express that a message is repeatedly sent or received; however, each event occurrence in a basic chart is unique. The semantics of basic charts are given as follows. Let  be the smallest partial order relation between event occurrences induced by a basic chart . According to the above stated informal descriptions, the partial order of the occurrence of events satisfies the following two points.

1.
 with 
: 
 (R1), and

2.
: 
 (R2).

For any event occurrence , let  be the event of . Let  be a (bijection) permutation. Let  be a basic chart with 
. A sequence 
 of event occurrences is called consistent with , if 
 implies  for any .

The events in the alphabet of  but not appearing in the chart of silent events of  are denoted by 
. We define silent events of  as 
. Intuitively, the alphabet of  defines all relevant events of the property, whereas a silent event in the alphabet is not used in the chart. By  we denote  being consistent with C. The occurrence of silent events in an event occurrence does not impact its consistency of a basic chart.

Definition 2 Semantics of Basic Charts

Let 
 be a (possible empty) sequence of silent events of a basic chart ; the language  defined by the chart is given as follows. 

For example, Fig. 2 shows a basic chart  and the words  defined by the chart, with the alphabet 
 of  placed at the upper-left corner of the chart, where 
.

Definition 3 Empty Basic Chart

An empty basic chart 
 is a basic chart with , where the language 
 of 
 is the set of empty words 
.

4.2. Parameterized modal LSCs
A PMLSC consists of two basic charts: a prechart (Pch, drawn within a hexagon) and a main chart (Mch, drawn within a solid rectangle). The language of a PMLSC  is defined over an alphabet 
 of events, where 
.

PMLSCs have modal precharts: sufficient precharts (drawn within a dashed hexagon) and necessary precharts (drawn within a solid hexagon). Intuitively, a PMLSC with a sufficient prechart specifies all the traces composed of two segments in a way that, if the first segment meets the prechart, then the second segment must meet the main chart. A necessary prechart is interpreted as a necessary condition. A PMLSC with a necessary prechart specifies all the traces composed of two segments in a way that, the second segment cannot meet the main chart unless the first segment meets the prechart. The parameters of a property are specified by the assignment and condition structures in PMLSCs, which evaluate variables to parameter values and specify parameter constraints, respectively. In a PMLSC, the value of a parameter is first stored in an assignment structure and later on it is checked by a condition structure.

Formally, the syntax of PMLSCs is defined as follows. Let 
 be a finite set of nominals and 
 be a domain (e.g., integers or reals). A parameter is a pair  from , where  and  are the name and value of , respectively. Let 
 be a finite set of variables, assignment structures and condition structures are defined as follows.

Definition 4

An assignment structure is defined as a tuple , where ,  and .

Definition 5

A condition structure is defined as a pair , where  is a proposition with respect to  and .

Definition 6 Syntax of PMLSCs

A PMLSC  is a six-tuple 
, where 
 is the alphabet of the chart,  and  are basic charts,  is the modal (sufficient or necessary) of the prechart, and ASSI and COND are sets of assignment structures and condition structures, respectively.

Given sets 
 of words, we denote 
 to be the concatenation of  and 
, and 
 
 to be the complement of . The set  of words defined by a PMLSC  is given as follows. (1)
 
 
 
 
 

Intuitively, modals  and  indicate that the execution of the prechart is, respectively, the sufficient and necessary conditions for the execution of the main chart. For example, if a PMLSC is with a sufficient prechart (Mod ), then the chart specifies all the traces in a way that, if a trace contains a segment accepted by the prechart, then it must also contain a continuation segment (directly following the first segment) accepted by the main chart. On the other hand, if a PMLSC is with a necessary prechart (Mod ), then the chart specifies all the traces in a way that, if a trace contains a segment accepted by the main chart, then it must also contain a prefix segment (directly preceding the second segment) accepted by the prechart.

For runtime verification, we formalize an action of an SuM (System under Monitoring) by a parameterized event (i.e., an event carrying data). A parameterized event is a pair , where 
 is an event and 
 is a set of parameters. We require parameterized events to follow a non-ambiguity assumption: a parameterized event cannot carry two parameters with the same name but different values. Let  be the name of a parameter . A parameterized event is non-ambiguous if and only if for any 
 it holds that 
. With the non-ambiguity assumption, a monitor can generate a true or false result from system executions. Otherwise, since a parameter carries uncertain values, the monitoring results may contain uncertainties.

An execution of a system (i.e., a sequence of actions) is formalized by a finite parameterized word 
, which is a finite sequence of parameterized events. We denote with  the 
 parameterized event 
 of , whereas with 
, the suffix 
. Finite parameterized words over the alphabet 
 are defined as elements of 
.

A PMLSC is well-formed if and only if for any  and 
, it holds that 
. From a well-formed PMLSC, all free variables in a proposition of a condition structure is evaluated with an assignment structure. The value is obtained from the parameterized event associated with the assignment structure. To simplify the notation, we denote 
 as a sequence 
 of s, where  is an event, a nominal or a value of a parameter. Let  be boolean values and  be propositions in condition structures. The function 
 is defined as follows. 
 

A parameterized word 
 is consistent with a PMLSC  if and only if

•
, and

•
for any 
, it holds that .

By , we denote the set of all parameterized words consistent with .

The alphabet 
 of PMLSC  represents all relevant events of the property specified by . The language of  is thus defined on 
. Given parameters , the set 
 of silent parameterized events (SPEs) of basic chart  is 
. That is, an SPE is a silent event carrying an arbitrary set of parameters. The semantics of PMLSCs is given as follows.

Definition 7 Semantics of PMLSCs

Given a PMLSC , the language  is defined as follows. 

In our previous work (Chai and Schlingloff, 2017), we introduced the language of the parameterized extended LSC (PeLSC), which is defined in a similar manner as PMLSCs. In contrast, the syntax of PeLSC does not contain the alphabet of the chart, and any event not appearing in the chart is defined to be a silent event. Additionally, in order to enhance the expressiveness of PeLSCs, we introduced a special symbol  for specifying events in . Let  be the set of events appearing in , the semantics of  is 
. From the symbol , we define 
 and 
 as the sequence of any events and the non-empty sequence of events in , respectively.

However, when the language of PeLSC is applied to construct monitoring specifications for real-world applications, the symbol  is sometimes not used intuitively and monitors have high incorrect report rates for some cases. For example, consider the following property of a communication process: for given messages , if message ‘a’ is transmitted, then message ‘b’ must be transmitted immediately afterwards. After that, message ‘d’ cannot be transmitted unless message ‘c’ is sent. The language  of this property is as follows. 
 
 
 
 
The concatenating PeLSC charts, as shown in the left part of Fig. 3, is not equal to . Messages  and  are non-silent events of the former chart as they have already appeared in the latter chart. Consequently, a monitor built from this specification reports ‘false’ against some correct executions, while ‘true’ against some incorrect executions. For the PMLSCs as shown in the right part of Fig. 3, this property can be specified in an intuitive manner with alphabets: The alphabets of the two chart are defined to be 
 and 
, respectively. This makes  and  to be silent events in the former chart, and  and  in the latter chart.

Definition 8 PMLSC Specification

A PMLSC specification 
 is a finite set of PMLSCs.

A PMLSC specification is a set of PMLSCs, each of which is expected to be satisfied by an execution of an SuM. The language  defined by a PMLSC specification is 
With a PMLSC specification, a monitor can be generated to check whether an execution of an SuM (formalized by a parameterized word) satisfies or violates the properties of the specification.

Definition 9 PMLSC Monitoring

PMLSC monitoring is defined with the validation relation ⊧ between a parameterized word 
 and a monitor  generated from , which is deductively given as follows. ⊧ 
 

A system  with an alphabet of  satisfies a PMLSC specification Spec if and only if 
⊧
where 
 and 
.

As proposed in Aceto et al. (2019b) and Francalanza et al. (2017), the monitorability of the PMLSC properties is defined as follows. PMLSC property  is -monitorable (here 
), if there exists some 
 such that whether  is satisfied or violated is determined by . Additionally, a property is  pz-monitorable if it is -monitorable for all finite words , whereas a  pz-monitorable if it is -monitorable for some finite words . According to the definitions, PMLSCs are defined over finite parameterized words. Therefore, every PMLSC property is  pz-monitorable. Let 
 be the language of infinite parameterized words. We define an iteration operator 
 to specify the execution of chart  with infinite number of iterations. In the iteration operation, the language of PMLSC
 is capable to specify properties over infinite words.

Proposition 1

There exists some PMLSC
 properties which are pz-monitorable.

Proof

Consider the property “sequence 
 must occur first, and  occurs infinitely often”, which defines the language 
, where . It is a  pz-monitorable property. This is because of the fact that for a word 
, there exists  such that  violates the property. The property is not  pz-monitorable as for a word , there is no word 
 such that  satisfies or violates the property. This property can be specified by the PMLSC
 specification 
 as shown in Fig. 4. The alphabets in the chart are as follows. 
, 
, 
 The language of chart 
 is 
 
 
, which equals 
. The language of chart 
 is 
 
 
, which equals 
. Consequently, the specification 
 defines the language .

4.3. PMLSC properties
In this subsection, we illustrate features of PMLSCs by expressing some properties of a railroad crossing warning system. When a train approaches the railroad cross, the system closes a gate to prevent collisions between the train and road vehicles. In this subsection, we present patterns of interested monitoring properties of the system expressed by PMLSC specifications.

4.3.1. Reaction to trigger, absence of unsolicited reaction and strict trigger and reaction
Consider two behaviours:

•
B1: Radar detects a train coming;

•
B2: Radar alerts Controller about the coming train, and Controller closes the gate.

PMLSCs  and  in Fig. 5 specify B1 to be a sufficient and necessary condition, respectively.

In particular, PMLSC specification 
 formulates B1 to be a necessary and sufficient condition of B2. By  and  we denote the languages of the prechart and the main chart of these two PMLSCs, respectively. The language defined by 
 is (2)
 
 
 
 


Download : Download high-res image (198KB)
Download : Download full-size image
Fig. 5. PMLSCs for sufficient and necessary conditions.

Eq. (2) is equal to 
 
 
 
 
 
This language accepts all event words  such that  if and only if . More generally, let  and 
 be two PMLSCs with 
, 
, 
, 
, 
,  and 
. The PMLSC specification 
 expresses the property “the prechart is executed if and only if the main chart is executed afterwards”. We use a double-lined notation for the abbreviation of this specification to express an iff prechart. For instance, the PMLSC 
 in Fig. 5 expresses the specification 
, as given above.

4.3.2. Forbidden behaviour
Consider the property of forbidden behaviour FB “The system cannot exhibit the behaviour of detect approach () first and then execute the command to raise () the gate afterwards”. The language defined by FB is 
 
.

The property FB of forbidden  is specified by PMLSC 
 as shown on the left side of Fig. 6. This chart has an empty necessary prechart, whose alphabet is a singleton 
 of a silent event. The intuitive interpretation of the chart is as follows: Chart 
 accepts all event words  such that unless  is admitted by the prechart of 
, sub-trace  cannot be admitted by the main chart of 
. The reason is that any non-empty trace cannot be admitted by an empty chart, trace , possibly interleaved with silent event sequence, is rejected by 
. A strict proof of the property is given as follows.

Given 
 with 
 and 
, we denote by 
 the language of the main chart. The language defined by 
 is 
 
 
, which is equal to 
 
 
. Because 
 is a silent event of the main chart, the above language is equal to 
 
, which is the language of property FB.

4.3.3. Parametric property
PMLSC  in Fig. 6 expresses the parametric property “If a message  is received, then a message  must be sent within , and show that the train speed is under ”. By means of the assignment structure, the value of  carried by  is stored in variable . This value is used later by a condition structure to express that the time of receiving  must be less than  (i.e., within  after the time of receiving ). The constraint of the “speed” feature is specified by the condition  combined with the sending of .

5. Expressiveness and complexity of PMLSCs
5.1. Expressiveness
In previous work (Chai and Schlingloff, 2017), we proposed an extension of LSCs (named PeLSCs) by introducing necessary precharts into standard LSCs. However, without explicating the alphabets of basic charts, the language of PeLSCs has some limitations in specifying monitoring properties in practice. One of the main shortcomings is that the language of PeLSCs cannot distinguish between silent events and unexpected events. Given a PeLSC specification, any event not appearing in any of the charts is directly interpreted to be a silent event. Consequently, by means of the intersection of charts, silent events of one chart can become non-silent events. This result is not expected in many cases and leads to false alarms in monitoring.

Theorem 1

PMLSC is strictly more expressive than PeLSC.

Proof

For any PeLSC 
, there is a PMLSC  with 
 such that 
. Therefore, PeLSCs do not have more expressiveness than PMLSCs.

We now show that the language 
 
 over  is not definable by any PeLSC. According to the definitions, PeLSCs define languages of the form 
 
 
. To define language , the prechart and the main chart of a PeLSC 
 must define  and , respectively. Event  is a silent event of 
 because the event does not appear in the chart. That is, a word  is in the language 
. However, because  is in 
 and  is in 
, this word is not in . Since  is defined by PMLSC  with 
, the language of PMLSCs is strictly more expressive than the language of PeLSCs. □

As shown in Aceto et al. (2018), a language has more expressiveness for monitoring when it is closed under negation. The language of PeLSCs is closed under negation due to the introduction of the additional symbol . However, the symbol  is not used intuitively: if a language is not composed of 
, a single PeLSC chart cannot contain the symbol . We now show that by introducing alphabets, without the symbol , the language of PMLSCs is still negation closure.

Theorem 2

PMLSC is closed under negation.

Proof

For a PMLSC  with a sufficient prechart, the language of  is 
 
. The complement of  is 
 
 
. Let the prechart of 
 be an empty sufficient prechart, and let the main chart be the sequencing of message transmissions of  and  of . The language of 
 is 
 
 
, which is equal to . Let the prechart of  be a necessary prechart  and an empty main chart, and let the alphabet of the main chart be the same  as that of the prechart. The language of 
 is 
 
 
. Because all events in  are silent events, the sequence 
 is actually 
. The language of 
 is thus 
. Consequently, the PMLSC specification 
 defines the complementation of . □

5.2. Complexity
In this part, we investigate the efficiency of monitoring a system with PMLSC specifications, that is, the complexity of the parameterized word problem of PMLSCs with respect to the lengths of the parameterized event traces. We introduce simple numerical comparisons (SNCs) that express only the comparisons of numerical values. For example, a simple numerical proposition can be ,  and . By PMLSC-SNCs we denote a subclass of PMLSCs in which all propositions are SNC. We first prove the complexity of PMLSC-SNC.

The hybrid logic (Franceschet et al., 2003) () is a well defined formal language that extends LTL. Let  be a subclass of hybrid logic with “down arrow” (excluding the “at” operator). The down arrow operation  is combined with a temporal formula. At the time of the local temporal context, it stores the value of parameter  in variable . The formula of  asserts about the parameterized word 
 that  satisfies 
. The formula of 
 is obtained by replacing all the free occurrences of variable  in  with constant 
, where 
. For example, the formula 
asserts that whenever event ‘’ occurs in a parameterized word, then event ‘’ must eventually occur within 30 s, and the speed value carried by  must be smaller than 40. As the logic of  captures the features of temporal logic properties and parameter constrains, we use it to analyse the expressiveness of PMLSCs. The language of  is formally defined as follows.

Definition 10

Syntax of HL[
] Let  be a finite set of events,  be a finite set of nominals and  be a finite set of variables. The simple numerical terms  and the formulae  of  is inductively formed according to the following grammar, where , , ,  and : ≔≔

The following shorthands are used in  as in :  stands for ,  stands for  and  stands for .

Given a set of variables  and their domains , an assignment  for  is a mapping  such that  and . Given an assignment  and a parameter , we define 
 by 
 and 
 for . We define semantics of  over finite linear models as follows.

Definition 11

HL[
Finite Linear Semantics] Let  be a finite parameterized word with 
 being a position,  be an event,  be a parameter, and 
 and 
 are any  formulae. Let  and  being the event and the parameter of the th position of , respectively. The satisfaction relation ⊧ of  over a linear model is defined inductively as follows:

⊧;

⊧ iff ;

⊧
 iff ⊧
 and ⊧
;

⊧
 iff there exists  with ⊧
 and for all 
 it holds that 
⊧
;

⊧
 iff 
;

⊧ iff there exists a parameter  such that 
⊧.

Theorem 3

The language of PMLSC-SNC is at most as expressive as .

Proof

We have to show that a PMLSC-SNC chart  can be translated into an equivalent  formula. The resulting formula  is the conjunction of two subformulae  and , where  specifies the temporal relations between events and  expresses the constraints of parameters carried by events.

For given alphabet 
 of events and 
, Kugler et al. (2005) proposed the following LTL fragment for defining a finite sequence of events 
 
It indicates that nothing can occur before event 
, after that nothing cannot occur before event 
, and so on. Inspired by this LTL fragment, we develop the following HL[] formulae for specifying features of the languages defined by PMLSCs. The following formula  specifies a finite sequence of events 
 over 
: 
Different from the Kugler’s paradigm, we put the subformula of 
 at the end of the last event 
 of the sequence. This formula is used to specify that no event is allowed to occur after 
. If events 
 appearing in  is a subset of , any sequence interleaved with the events in 
 is rejected by the formula of . Given a superset 
 of  (i.e., 
), the formula specifies the word  interleaving with any finite (possible empty) sequence of silent events, i.e., the language of 

According to the definitions of PMLSCs, a basic chart  specifies a finite set of finite sequences of words . Give the “exclusive or” operation , the language  can be specifies by a formula  as follows 
This formula expresses that exactly one trace of  is executed.

The formula 
 for concatenation of charts can be defined in a similar manner.

Given a PMLSC-SNC , the formula  defines the temporal relations of  as follows  
 

Let 
 be an event and the occurrence time of events in a chart. Let 
 be the set of events appearing in PMLSC , where 
 are the occurrence times of the respective events. The formula  
 
 
 expresses that event  has been executed  times. A sequence of events is accepted by the formulae if and only if an event  occurs at some position  and the suffix starting from position  satisfies the formula of  
 
 
 . The formula 
 specifies that an event  cannot be executed unless all events in  have been executed. With the additional formula , the concatenation of PMLSC-SNCs can be defined by formulae according to the definitions. Furthermore, a PMLSC-SNC specification 
 can be translated into the conjunction of 
.

A simple numerical comparison  of a condition structure  in  can be either with or without variables.

For the case of  (i.e.,  involves no variables) with , we define the following HL formula. This formula specifies that if  occurs in a parameterized word, then it must carry a parameter  such that  is true.

For the case of  (i.e.,  involves a variable ), there must be an assignment structure 
 with 
. Let  and 
, we define the following formula. 
This formula specifies that if both  and 
 occur in a parameterized word with 
, then the simple numerical proposition  must hold with the parameters carried by . According to the assignment, the value of  in  is given by the parameter named 
 carried by 
. The value of  is given by the parameter named  carried by  itself. If  contains more than one variable, the formula  can be built in the same manner. The formula  then specifies the constraints of the parameters in .

According to these definitions, any parameterized word  is admitted by a PMLSC-SNC  iff ⊧, where . Therefore, any PMLSC can be translated into an equivalent  formula. □

With the above theorem, the complexity of PMLSC-SNC for monitoring is equal to the complexity of the parameterized word problem of : Given a parameterized word  and an  formula , decide whether or not ⊧ holds. Given 
, the satisfaction ⊧ can be translated into 
⊧, where 
. Since  is an SNC, whether  is true or false can be decided directly; therefore, the parameterized word problem of  is translated into the word problem of . Since the complexity of the latter problem is linear with respect to lengths of the words (Roşu and Havelund, 2005), the following theorem holds.

Theorem 4

The complexity of monitoring PMLSC-SNC properties is linear with respect to the lengths of the parameterized words.

By introducing quantifiers into propositions of condition structures, another subclass of PMLSCs can be obtained, that has more expressive power than PMLSC-SNCs. For example, a property can be specified to state that the data carried by a message has some features of the first order logic. However, the complexity of the language increases with increasing expressiveness. By investigating the complexities of the language, we show below whether this subclass of PMLSCs is applicable for monitoring. Monitoring a system is essentially a problem of checking whether a linear model satisfies some properties. Although the scale of this problem is smaller than that of general model checking problems, the monitoring properties specified by this language have unacceptable efficiency.

Let  and  be first-order propositions with quantifiers over infinite and finite domains, respectively. By PMLSC-FOL and PMLSC-FOL
, we denote the languages of super classes of PMLSC-SNCs involving  and , respectively. Intuitively, the complexity of checking PMLSC-FOL is related to the complexity of solving the conditions in the charts. Therefore, the hypothesis is that the complexities of PMLSC-FOL
 and PMLSC-FOL are at least undecidable and NP-complete, respectively. In the following, we provide strict proof of the complexities of these languages through the tiling problem (Kari, 2007).

Theorem 5

The complexity of monitoring PMLSC-FOL properties is NP-complete.

Proof

We first prove that the complexity of the parameterized word problem of PMLSC-FOL is in NP. Given a PMLSC-FOL  with a proposition , where  contains a variable  and a domain  with . Whether a parameterized word  is in the language  of  can be determined through the following two steps:

1.
Translate the PMLSC-FOL  into a PMLSC-SNC 
 by guessing an assignment of  from the domain , and

2.
Translate the chart 
 into an equivalent  formula 
.

According to Theorem 4, the complexity of PMLSC-SNC is linear. Therefore, the problem of monitoring PMLSC-FOL is in NP.

We then prove that the problem is NP-complete. A tile is defined as a pair , where  and  represent the name and the four colours of the tile, respectively. We define  as a tuple 
 representing the colours of the top, bottom, left and right edge of the tile. Given a finite set of tiles , a finite  plane and a sequence 
. For any 
 and 
 in 
, it holds that the right colour of 
 is equal to the left colour of 
. Let  be a set of tiles, a tiling can be formalized with a function 
. For 
, the function  indicates that the tile  is placed at position  on the plane. By 
, 
, 
, 
, we denote the colours of the tile  on the top, bottom, left and right edges, respectively. The bounded tiling problem requires to determine whether a tiling of the  plane exists in the given set  of tiles, where the first row is the given sequence 
. This problem can be formulated by using the proposition 
 as follows. (3)
 The bounded tiling problem can be translated into 
 as shown in Fig. 7. The prechart stores the tiles in the first row of the plane. After that, the main chart describes a tiling of the plane with the given tiles. Let  be a word formed with the set of tiles representing the parameters carried by the events. Checking whether the word is admitted by 
 is equivalent to the problem of deciding whether there exists a tiling for the plane. Since the above bounded tiling problem has been proved to be NP-complete, the complexity of solving the parameterized word problem of PMLSC-FOL also becomes NP-complete. □

Theorem 6

The problem of monitoring PMLSC-FOL
 properties is undecidable.

Proof

By allowing infinite domains, the language of PMLSC-FOL
 can be used to specify tiling of an infinite plane. This property can be specified with the chart 
 as shown in Fig. 7 by replacing 
 with the following proposition. (4)
 Since unbounded tiling problem is undecidable, the word problem of PMLSC-FOL
 is undecidable. □

Since the complexities of PMLSC-FOL and PMLSC-FO
 are too high, these sub-classes of PMLSC are not suitable for performing online monitoring. Therefore, we focus on PMLSC-SNC in the following part of the paper.

6. Monitoring algorithms of PMLSC-SNCs
The translation of the standard LSCs into LTL was been introduced in Kugler et al. (2005). By assigning to variables parameters carried by events, a  formula can be translated into an LTL formula, which has online verification algorithms. As shown in Section 5.3, PMLSC-SNC is not more expressive than . Therefore, a naive PMLSC-SNC monitoring algorithm can directly translate charts into  formulae. The correctness of an SuM is then decided by checking whether the executions satisfy the resulting formulae. Unfortunately, this algorithm is not efficient enough for large-size (offline) monitoring system executions. Since the formulae have to specify all partial orders of events induced by charts, the sizes of the resulting formulae are very large. For example, the formula from the simple property 
 in Fig. 5 has over  operations/propositions. The result cannot be obtained efficiently when checking the correctness of a large log file (i.e., a long parameterized event trace) directly with such a large formula. Furthermore, PMLSCs with iterations essentially introduce (infinite) Kleene star into the expressions: such a chart thus cannot be translated into an  formula.

We develop an explicit algorithm to check PMLSC properties efficiently to solve these problems. For a given PMLSC , a monitor  can be synthesized via the following steps.

1.
Translating all basic charts (i.e., precharts and main charts) and parameter constraints of PMLSCs into ;

2.
Filtering the word by projecting away all silent events (according to the alphabet of the PMLSC specification);

3.
Splitting the word into a set of slices with respect to the precharts and main charts;

4.
Checking the satisfaction relations between slices and basic charts to decide whether a PMLSC is “triggered” independently (according to the modality of its prechart); and

5.
Checking whether the word satisfies all triggered PMLSCs in the specification.

The correctness of the monitors synthesis (Bonakdarpour and Finkbeiner, 2020, Basin et al., 2020) can be shown as follows.

Lemma 1

For any PMLSC ,  is a correct monitor for .

As defined in Francalanza and Seychell (2015), the correctness of a monitor  is defined as follows: For any parameterized word , if  cannot be admitted by  then the monitor should detect it, and vice versa. Assume that the  formula  is a correct translation of the basic chart . The formula is capable to decide whether a parameterized word is admitted by a basic chart. According to the definitions, the execution of the prechart precedes the execution of the main chart. With respect to a PMLSC, a word can be split into two slices 
 in sequence. The former slice exhibits the execution of the prechart, whereas the latter slice exhibits that of the main chart. Whether the original word can be admitted by  with different modals (i.e., sufficient prechart and necessary prechart) of PMLSCs is decided by checking the satisfaction of 
 and 
, respectively.

6.1. Translation of PMLSC-SNCs into 
By means of event occurrences, we can distinguish every event appearing in a chart. Inspired by the translation of LSC to LTL proposed by Kugler et al. (2005), we develop an efficient translation algorithm from PMLSC to . Let  and  be sets of partial orders 
 induced by a basic chart  and all events appearing in , respectively. From , an alphabet 
 of  and a set  of events, a formula 
 can be defined, where (5)
 (6)
 (7)

The correctness of the translations can be represented by the following lemma.

Lemma 2

Given a PMLSC , any word  is admitted by the prechart  (resp. the main chart ) if and only if

⊧
 (resp. ⊧
).

The formula 
 specifies that if 
, then 
 cannot appear in a word before ; the formula 
 specifies that each  can appear in a word at most one time; and the formula 
 specifies that all the events in the alphabet occur eventually and any event not in the alphabet cannot occur in a word. According to the definitions, these formulae together represent the temporal requirements of event occurrences in a basic chart.

The simple numerical proposition  of a condition structure  in  can be either with or without variables. For the case of  (i.e.,  involves no variables) with , we define the following  formula. This formula specifies that if  occurs in a parameterized word, then it must carry a parameter  such that  is true.

For the case of  (i.e.,  involves a variable ), there must be an assignment structure 
 with 
. Let  and 
: we define the following formula. 
This formula specifies that if both  and 
 occur in a parameterized word with 
, then the simple numerical proposition  must hold with the parameters carried by . According to the assignment, the value of  in  is given by the parameter named 
 carried by 
. The value of  is given by the parameter named  carried by  itself. The formula 
 specifies the parameter constraints of .

6.2. Rewriting algorithms for 


Download : Download high-res image (176KB)
Download : Download full-size image
By means of formula rewriting, we develop algorithms for checking  over parameterized words. Given a finite parameterized word 
 and an  formula 
, the algorithm for checking whether  satisfies  is as shown in Algorithm 1. In this algorithm, the formula is rewritten by resuming the first parameterized event in . No down arrow binder exists at the first depth for some intermediate formulae. We use the LTL rewriting algorithm proposed in Chen and Roşu (2005) to verify the resulting intermediate LTL formulae. This process is performed iteratively until all the parameterized events are consumed. Since the length of  is finite, the algorithm is terminated.

Example. The  formula  represents the property “ cannot happen until  occurs within 5 sec”. For the given parameterized word , we denote 
 as the suffix of  starting from the th position. Let ⊧ be the satisfaction between a parameterized word and an  formula, the formula rewriting process can be expressed as follows. ⊧
⊧
⊧
⊧⊧⊧

6.3. Slicing algorithm for PMLSC-SNC monitoring
Before checking the correctness of a parameterized word , the word is preprocessed with Algorithm 2. The word is first filtered according to the alphabet of a given PMLSC-SNC specification. Then, the word is divided into a set of sub-traces, each of which represents an execution of a prechart or a main chart in the underlying PMLSC-SNC specification. The positions of all parameterized events in  are recorded to restore the sub-traces into a word with the original execution order.


Download : Download high-res image (199KB)
Download : Download full-size image
6.4. Monitoring algorithm for PMLSC-SNCs
Whether a parameterized word  satisfies a PMLSC-SNC specification can be determined by checking the sliced sub-traces  (as shown in Algorithm 3). The algorithm first decides which PMLSC-SNCs in the specification are “triggered” according to the modalities (necessary or sufficient) of precharts. For a PMLSC-SNC with a sufficient prechart, the PMLSC-SNC is triggered when the prechart is satisfied; For a PMLSC-SNC with a necessary prechart, the PMLSC-SNC is triggered when the prechart is not satisfied. If a PMLSC-SNC is triggered, the parameter constraints should also be satisfied. A word satisfies a PMLSC specification iff the word satisfies all triggered charts with the correct execution orders. In addition, the word satisfies concatenations (as well as iterations) of triggered charts iff the execution orders are correct. Since each sub-trace can be checked by an independent Check procedure, this algorithm can verify large executions in parallel. As there is no backtracking, this algorithm is also suitable for online monitoring.

Example. Consider the parameterized word  and the PMLSC specification 
, where the alphabets of 
 and 
 are 
 and 
, respectively. As shown in algorithm 2, the silent events  are first filtered and then the trace is split into four slices according to the occurrences of events 
, 
, 
 and 
. The slices and the executions of the basic charts are stored in  and , respectively. The correctness of the execution, the partial order of executions, and the parameter constraints are then checked by algorithm 3.


Download : Download high-res image (173KB)
Download : Download full-size image
7. A case study: monitoring RBCs of CTCS
In this section, we present an example of monitoring RBCs deployed on a main high-speed railway line of China. We choose this example because a concrete accident occurred in this system, see Fig. 8. Due to a sequence of internal errors, the CTCS level 3 system of train A fails to prevent the train from a collision accident with train B. By analysing the accident, the errors are found to arise from incorrect interactions between the RBC and interlocking as follows. According to the schedule, train A did not plan to stop at the station, and the interlocking locked a main line route X-IG-121 for the train. With respect to this route, the RBC provided an MA to train A with the EoA at distance kilometre 121 (dk121). Then, the CTC decided that train A was still far away from the station and train B should leave the station first. Therefore, it temporarily cancelled, via the interlocking, the route XI-121 and setted up a route X3-121 for train B. However, since train A did not stop, the RBC decided that the route X-IG-121 could not be cancelled. It still provides an MA with EoA at position dk121 to train A. Consequently, with the incorrect MA, the CTCS level 3 controlled train A would roll over at Point #10. In this accident, train B was controlled by the CTCS level 2, in which MAs are generated by track circuits. Since the RBC was not aware of the MA information provided by the track circuits, train A would have collided with train B.

This defect was corrected through a software update. Although a high price has been paid, it is difficult to guarantee that a similar accident will not occur again because such accidents are caused by multiple mistakes of different subsystem executions, and are hard to predict and eliminate during the development phases. To solve this problem, we propose to use runtime verification to protect RBC executions. By means of monitors, RBC software is allowed to carry defects, which are impossible to be fully eliminated, and the executions are checked at runtime. When a dangerous execution is exhibited, the monitor sets alarms and prevent the execution from evolving into an accident.

We obtain several properties of RBCs to monitor by translating the Chinese Train Control System Requirement Specifications. The abbreviations of messages, actions and parameters are shown in Table 1.


Table 1. Messages in the RBC/RBC Handover Process.

Abbreviation	Description
SA	Signal authorization
CEM	conditional emergency braking message
R_S (R_E)	start position (end position) of a route
RN	The RBC border
Hov_C	The RBC/RBC handover command
T_ID	Train ID
PA	Pre-announcement: information of an approaching train to the RBC-RBC border
MA	Movement authority
(R)RI	Related Route information
RRI_R	Related Route information request
7.1. The MA extension process
To extend MAs in train stations, the interlocking first locks the route for the train and sends the route information (called signal authorization, SA) to the RBC. With the SA messages, the RBC computes the MA with respect to the engineering data and sends the MA to the train. The end of MA is at the end of the locked route. When the train enters the locked route, the interlocking sends an SA message indicating that the route is used, and the RBC sends a conditional emergency braking message (CEM) to the train. The braking target position of the CEM is at the starting position of the used route. If the front of the train has already passed the braking target position, the train ignores the CEM and keeps operating with its original speed-distance curve. If the route is cancelled, the interlocking will send an SA of route-cancellation and the RBC updates the MA with respect to the locked routes. This process is formulated with PMLSCs 
, 
 and 
 as shown in Fig. 9, where

•

•

•

7.2. The RBC/RBC handover process
In general, a long railway line is divided into several RBC supervision areas, each of which contains one or more interlocking train stations. When a train approaches the border of an RBC supervision area, the so-called “RBC/RBC handover process” occurs to ensure that the train can pass the RBC border without losing speed. The high-level RBC/RBC handover principles are described as follows. When a train approaches the border of two RBC areas, the current RBC (referred to as the handing over RBC, HOVRBC) sends a pre-announcement message to the adjacent RBC (referred to as the accepting RBC, ACCRBC). After receiving this message, the ACCRBC prepares to allow the train to enter its supervision area. At this time, the HOVRBC can only provide an MA with the EoA at the border of the two RBCs. To allow the train to pass the RBC border, the HOVRBC sends an HOV_C message to the train, and sends an RRI message to the accepting RBC. Upon receiving an RR, the ACCRBC sends route-related information message that includes the available route information in its supervision area. With the RI, the HOVRBC can extend its EoA to the ACCRBC area. PMLSC specifications 
 and 
 shown in Fig. 10 specify this process, where

•

•

7.3. Experimental results and discussion
Monitors were generated with the above algorithms, where the  function is implemented as in Clavel et al. (2011). Maude provides a rewriting environment for various logics, including HL. We applied our monitors into a CTCS simulation platform with the structure described in Section 2, where the RBC software and engineering data are the same as of the above Chinese main railway line.

To analyse the protection abilities of PMLSC monitors, we do not simply inject the above errors that occurred but also apply a mutation technique to generate various incorrect executions. We apply four mutation operations for system executions: Change Event Orders (CEO), Delete Events (DEV), Insert Events (IEV) and Change Parameter Values (CPV).

Let  and  be the numbers of correct and incorrect words being monitored, respectively. Let  and  be a true alarm and false alarm reported by a monitor, respectively. A monitor is evaluated with respect to the false alarm rate (FAR) and bug found rate (BFR), where  and . We constructed 338 parameterized words from a CTCS-3 simulation system, where 67 are correct executions and 271 are incorrect executions, by applying the above four mutation operators. For comparison, we constructed monitoring specifications with PeLSCs, where the alphabets are not separately defined in charts.1 Unfortunately, if one directly copy the charts of PMLSCs, the FAR of monitoring with the resulting PeLSC specification becomes to 100%. This is because by means of the intersection of charts, some silent events are automatically transformed into unexpected non-silent events. This changes the meaning of the specifications. For solving this problem, we put a 
 at the end of each chart to define its alphabet. This modelling strategy reduces the FAR of the PeLSC specifications. The experimental results are shown in Table 2. The rows 
 to 
 indicate monitoring with only PMLSCs/PeLSCs 
 to 
, respectively. The row “All” shows the monitoring results obtained by defining all the charts to be the monitoring specification.

The experimental results show that monitoring a system with PMLSC specifications can eliminate all false alarms of the PeLSC specifications. These false alarms are caused by the strict definition of silent events. For example,  (appearing in 
) is supposed to be a silent event when monitoring property 
; however, this event cannot be defined as a silent event with PeLSCs. For example, consider the following execution trace  It shows that when a train attempts to enter a route, the route is cancelled and the RBC sends a CEM to the train. This is a correct execution. Due to the incorrect definition of the non-silent event Cancel Route, PeLSC monitors generates false alarm. By contrast, by introducing alphabets, the above event is allowed to be both a non-silent event of 
 and a silent event of 
. False alarms caused by this problem are therefore eliminated with PMLSCs. In addition, PMLSCs have greater capability to catch bugs than PeLSCs. For example, consider the following illegal execution of 
: The trace indicates that with an RRI requirement, the HOVRBC sends an old RRI (receive before send) information to the train. The PMLSC monitor can catch this fault and report it as false. However, as the prechart of 
 does not accept any prefix of the execution, the whole chart 
 accepts the entire execution. Therefore, the monitors of PeLSCs will report it as true. For a single specification such that the alphabet is equal to the events appearing in the charts, PMLSCs and PeLSCs have the same bug finding capability. However, when the alphabet has more events (e.g., 
 to 
), PMLSCs have a lower FAR and a higher BFR. A single PMLSC specification has a very low BFR because some features of (incorrect) executions are not described by the specification. Since the above five specifications do not formulate all the properties of RBC, some injected errors are not found in our experiments. This problem can be solved by introducing more charts of properties into the specifications.

We further investigate the monitoring efficiency of PMLSCs. We analyse approximately 200GB of log data generated from running the CTCS simulation platform for 30 days. Table 3 presents the numbers of the events with respect to the chart alphabets (after mutation). We use rewriting steps to measure the monitor performance, which is shown in Table 4. The log file is divided into approximately 20,580 sub-files. For each property, we use 10 computers for slicing and monitoring. Maude is expected to perform 
 rewrites per second. However, in practice, additional time for compiling traces grows exponentially with respect to the sizes of traces. Consequently, if the size of the trace under verifying is too large, then Maude will not be able to provide the verification results. For the property 
, the log file containing the relevant events has a considerably large size (approximate 
 events). In our experiments, affected by the time required to compile such a long trace, Maude failed to give results within a reasonable computational time. For the properties  and , the log files contain relatively smaller numbers of relevant events, and the monitor can give results within a few minutes. Since the size of  formula 
 is bigger than that of 
, the monitor of property 
 spends more time to give results in comparison to those required by the monitor of the properties 
. The experimental results show that the algorithms with trace slicing reduce the computational overhead significantly.


Table 3. Log of RBC executions.

Event	Count
SA	11,812,579
MA	151,517,320
CancelRoute	125,574
RouteLocked	7,471,581
enterRoute	111,800
LTA	742,281
Hov_C	790,588
PA	775,149
RRI_R	92,628,696
RRI	157,513,118

Table 4. PMLSC monitor performance.

Property	Rewriting Steps
(per slice, median)	Runtime
(overall, min)	Rewriting Steps
(cumulative)
U1	2.39*10^9	–	4.92*10^14
U2	6.41*10^5	2.68	1.32*10^11
U3	8.53*10^5	3.98	1.75*10^10
U4	5.12*10^6	21.95	1.05*10^11
U5	1.92*10^6	4.32	3.95*10^11
8. Conclusion
In this paper, we have proposed PMLSC for monitoring the parameterized properties of CTCS level 3. The language of PMLSC is defined by introducing alphabets of charts. We proved that PMLSC is closed under negation and that the complexity of a subclass of the language is linear with respect to the lengths of words. Moreover, the complexity increases significantly if the condition structures involve quantifiers. For generating monitors, we showed how to translate PMLSC-SNCs into  and developed an efficient monitoring algorithm based on trace slicing. Finally, we presented a concrete example of monitoring RBCs of CTCS level 3. The results showed that by defining alphabets of charts, the properties to be monitored can be specified accurately; therefore, monitors achieve better BFR and FAR.

The quality of a monitor depends on the quality of the monitoring specification (Legunsen et al., 2016). We have developed an expressive graphic language for describing the (parameterized) properties of CTCS that is similar to the train control system requirement specifications. However, how to write a complete and accurate specification to monitor railway systems remains an open question. We plan to investigate the methods for (automatically) generating PMLSC properties via specification mining techniques.