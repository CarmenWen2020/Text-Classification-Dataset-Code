Abstract
The modelling and verification of systems security is an open research topic whose complexity and importance needs, in our view, the use of formal and non-formal methods. This paper addresses the modelling of security using misuse cases and the automatic verification of survivability properties using model checking. The survivability of a system characterises its capacity to fulfil its mission (promptly) in the presence of attacks, failures, or accidents, as defined by Ellison. The original contributions of this paper are a methodology and its tool support, through a framework called surreal. The methodology starts from a misuse case specification enriched with UML profile annotations and obtains, as a by-product, a survivability assessment model (SAM). Using predefined queries the survivability properties are proved in the SAM. A total of fourteen properties have been formulated and also implemented in surreal, which encompasses tools to model the security specification, to create the SAM and to prove the properties. Finally, the paper validates the methodology and the framework using a cyber–physical system (CPS) case study, in the automotive field.

Previous
Next 
Keywords
Security specification

Formal verification

Survivability properties

UML

cyber–physical systems (CPS)

1. Introduction
Some years ago, Cheng and Atlee (2007) identified that becoming computing systems ever more pervasive, mobile and targets of security attacks, new challenges to security requirements engineering would be posed. Therefore, they advised that works on notations and methodologies for modelling and verifying high-level security policies would become strategic. More recently, Bures et al. (2017) also identified as open yet the research topic on the need for verifying requirement specifications of cyber–physical systems (CPS) and declared its inherent complexity.

CPS are networked embedded systems used to monitor and control the physical world (Zacchia Lun et al., 2018), for example, electrical power grids, oil and natural gas distribution, transportation systems or health-care devices. Undoubtedly, CPS security is of primary importance in the current networked world and understanding their vulnerabilities, attacks and protection mechanisms is a must for developing the underlying control software (Humayed et al., 2017).

Among the list of challenges, identified by Cheng and Atlee (2007) and Bures et al. (2017), on requirements engineering for securing CPS, this work helps in the modelling of security requirements, early in the software life-cycle, and in the formal and automatic verification of system properties. Regarding the kind of properties, we mostly focus on system survivability ones. The survivability of a system can be defined as its capacity “to fulfil its mission on time, in the presence of attacks, failures, or accidents” (Ellison et al., 1999), then preventing perpetual service degradations, outages or integrity leaks, for example.

Survivability, as defined in the original papers by Ellison et al. (1999) and Knight and Strunk (2004) embraces security and safety requirements, since it encompasses under the term threats, both attacks (usually named threats, in the security community) and accidental faults (often named hazards, in the safety community), and corresponding protection mechanisms (i.e., survivability strategies). This work considers misuse cases, introduced by Alexander (2003) as follows: “Misuse cases – a form of use cases – help document negatives scenarios. Use and misuse cases, employed together, are valuable in threat and hazard analysis, system design, eliciting requirements, and generating test cases.” Consequently, misuse cases are used for eliciting and specifying both security and safety requirements. In the context of CPS, we consider critical both types of requirements, and survivability (also referred to as resilience, as stated more recently in Goertzel and Feldman, 2009) provides a framework for their modelling and analysis. For example, consider in the critical infrastructure domain, the well-known Stuxnet attack (Kushnet, 2013) – the first advanced persistent (APT) threat – to a CPS, that is the SCADA and PLC system of the nuclear plants of Iran in 2010, that provoked substantial damage to nuclear plants. The consequences of such damage could have been even more severe, also affecting people and the environment. This paper considers a smart car case study, that is a safety-critical CPS (a system failure may have catastrophic consequences on the user(s) and the environment), where safety requirements (expressed by ASIL — safety-integrity levels) can be affected by attacks.

The original contributions of this paper are a methodology and its tool support, through a framework called surreal. The methodology comprises different phases, significantly modelling and verification, and artefacts. For modelling, misuse cases are enriched with a UML1 profile, then defining a security specification, where sequences of attacks and protections are inferred. By protections, we mean countermeasures, introduced to allow the system to recover from an attack. The UML profile (UML2, 2017) extension mechanism enables to tailor the language to different domains, in our case, the survivability domain, by introducing concepts such as survivability strategies or service modes. For verification, state-of-the-art model-checking techniques are used to prove predefined survivability properties on the security specification. The surreal framework offers support for all the methodology phases proposed in this paper.

The methodology and the framework, described in this work, contribute to the requirements engineering process by supporting the analysts in better eliciting and assessing security requirements, especially those related to system survivability. Concretely, the work contributes to:

•
model threats to essential services, and the countermeasures needed to recover the system from degraded states;

•
and to verify survivability properties by checking the modelled specification.

More specifically, this paper extends our previous work(Bernardi et al., 2016, Gentile et al., 2017) in many different aspects. First, it introduces model-checking for producing an assessment model automatically. Second, it proposes fourteen predetermined queries, ready to be used by the analyst, for verifying system survivability properties. Third, model checking is also used for carrying out such verification automatically. Fourth, we extend the UML profiles presented in Bernardi et al. (2016) and Gentile et al. (2017) to accommodate these new features, then improving the profiles modelling capabilities. Fifth, the current work provides tools that automate, for the analyst, the steps of the methodology. Last, this paper validates the approach with a case study in the CPS domain.

The structure of the paper is as follows. Section 2 recalls the background supporting this paper as well as some related works. Section 3 presents, at a glance, the methodology and tools that are part of the surreal framework, for the reader to catch the overall picture. Sections 4 Modelling and generation phases, 5 Verification phase describe the internals of each phase of the methodology. Section 6 elaborates a case study in the automotive field, which demonstrates the applicability of the methodology in the CPS context and the usefulness of the tool framework. Finally, Section 7 summarises the assumptions and conducts a threat to validity analysis, and Section 8 concludes the paper.

2. Background and related works
This section is devoted to review the background on survivability modelling and model-checking techniques (Section 2.1) and the related works (Section 2.2).

2.1. Background on survivability modelling and model-checkingtechniques
On survivability modelling.
In previous works (Bernardi et al., 2016, Gentile et al., 2017), we proposed and implemented a UML profile2 for specifying system survivability requirements. In particular, four main concepts are captured by our survivability profile (Ellison et al., 1999, Knight and Strunk, 2004):

•
Essential services — representing system services that must survive despite threats materialisation. They are characterised by non-functional metrics (e.g., performance, integrity or availability) that define their health.

•
Service modes — defining different Quality of Service (QoS) levels of the system according to combinations of essential services measured by their health, i.e., by a QoS index. For example, the system is in “fully operational” service mode when the availability of all of its essential services is greater than 90%.

•
Threats — representing either activity carried out by attackers or materialisations of natural causes (e.g., blackouts) resulting in system failures. They may compromise essential services by degrading the system quality.

•
Survivability strategies — resistance, recognition and recovery actions aimed to prevent/react against consequences of threats. They are countermeasures to threats that try to maintain or restore the health of essential services.

Considering a military command and control system, used as a running example in this paper,3 an essential service is, for instance, the provision – via GPS trackers – of up-to-date position awareness of military forces on a digital map. On the one hand, threats affecting this service can be either attacks or accidental faults: for example, respectively, a man-in-the-middle attack – that counterfeits the position of the enemy forces in the digital map – or unintentional destruction of the deployment platform where the essential service is running on. On the other hand, for each threat, different survivability strategies can be applied to mitigate it. In particular, the man-in-the-middle attack could be reduced by combining different types of strategies, such as implementing cryptographic protocols in GPS communication (resistance), anomaly detection techniques (recognition) and restoration of original geodata (recovery) after the attack has been detected. The accidental destruction of the deployment platform could be mitigated by the implementation of fault-tolerance mechanisms such as hardware and software redundancy and reconfiguration (recovery).

As shown in Fig. 1, the survivability profile has two main packages, Misuse case and SAM (Survivability assessment model) extensions, and a package for types definitions. The Misuse case package extends UML use cases, and it is used to enrich misuse case specifications.

In particular, the Misuse case package extends existing concepts proposed in the original misuse case notation (Alexander, 2003) by including the survivability concepts from Ellison et al. (1999) and Knight and Strunk (2004), previously mentioned – i.e., essential services, service mode definition and survivability strategies – and by enabling the specification of QoS indices – e.g., availability metric. The SAM package is applied to UML state machines to specify system service modes, sequences of threats and survivability strategies.


Download : Download high-res image (82KB)
Download : Download full-size image
Fig. 1. Survivability profile overview.


Table 1. UML profile extensions used in the approach.

Misuse case extensions package
Stereotype	Description	Tags (type)	Extended UML metaclass	Changes w.r.t. (Bernardi et al., 2016, Gentile et al., 2017)
service	An essential service	indices (index)	Use case	tag refinement
misuse	A threat scenario	affects (affectConsequence)	Use case	tag type
threatens	A threat to a service		Dependency	
mitigates	A threat mitigation		Dependency	
service mode definition	Definition of the service modes	formula (String)	Constraint	new
recovery	A recovery strategy	affects (affectConsequence)	Use case	tag type
SAM extensions package
Stereotype	Description	Tags (type)	Extended UML metaclass	Changes w.r.t. (Bernardi et al., 2016, Gentile et al., 2017)
mode	A service mode	severity	State	
scenario	A sequence of misuses and survivability strategies	path (MSactivation)	Transition	tag type
Table 1 summarises the stereotypes of the profile used in this paper, where the last column highlights changes concerning the previous proposals (Bernardi et al., 2016, Gentile et al., 2017). In particular, tag type means that the tag has a different meaning: in Gentile et al. (2017) misuse and recovery stereotypes have a targetServiceMode tag to specify the system service mode reached as a consequence of the stereotyped (misuse or recovery) use case, whereas here the affects tag is used to determine the QoS indices of the essential services affected by the stereotyped (misuse or recovery) use case. Similarly, in Bernardi et al. (2016), state machine transitions can be annotated with a tag to specify the event that triggers the change of service mode (a misuse or a survivability strategy), whereas here the path tag of a scenario stereotyped transition is used to specify a sequence of misuse cases and survivability strategies that causes the change of a service mode. Tag refinement means that the indices tag has the same meaning as in our previous proposal (Gentile et al., 2017), i.e., it is used to specify the QoS indices associated to an essential service, but it enables a finer-grained specification (i.e., the type of value domain, the value domain and the initial value). Appendix A presents the complete profile. The profile is now a component of the surreal framework that supports this paper.

It is worth noticing that the Survivability profile provides general concepts that can be applied to different domains, including cyber–physical systems (CPS). The application of such concepts to CPS will be illustrated, in this paper, with a running example of military command and control system and a case study of a smart car, in the automation domain.

On model-checking techniques.
Model-checking is a formalmethod that, given a finite-state model of a system and a formal property, systematically checks if the property is verified for each possible sequence of states in that model. If a violation of a property is detected, the model checker produces a counterexample that is a sequence of analysed states whose crossing lead to the violation. Model-checking can be automated and can be, in general, applied to both software and hardware systems for the verification of properties related to communication protocols, concurrent systems or even for safety-critical systems. In Alrajeh et al. (2013), model checking is used to analyse the completeness of requirement specification, the work in Ghallab et al. (2004) proposes automated planning to compute sequences of actions able to reach a specified goal, while the work in Sheyner et al. (2002) deals with the automatic generation of attack graphs in network security. Model-checking is suggested by the international standards (e.g., ISO 61508, ISO 26262) for the verification of safety-critical system specifications. In the safety-critical domains, Wang et al. (2019) use a model checker to verify safety properties of the integrated modular avionics (IMA) – a computing network involved in aircrafts software development – and Benerecetti et al. (2017) proposes a framework based on model checking for the automatic system-level test case generation.

Model-checking can be even combined with learning-based techniques to obtain and verify properties from a black-box view of a system. In Fiterău-Broştean et al. (2016) model-learning combined with model checking, has been used to detect some flaws within the TCP protocols, by verifying properties on learned models of different clients and servers. Despite all the benefits introduced, the use of model checking comes with some drawbacks. First, the formal languages used to feed model checkers are mathematics-based and are often very complicated to fully master. Second, there is no guarantee that the counterexamples generated by a model checker are of a minimal length. To this aim, extra and more computation demanding techniques can be adopted, e.g., Bounded Model Checking (Biere et al., 2003).

2.2. Related works
In the following, we review the related works on the modelling of security and safety requirements and their verification with model checking techniques.

Security and safety requirements modelling.
Hundreds of works can be found in the literature regarding the elicitation and modelling of security and safety requirements. The surveys (Vilela et al., 2017, Raja Ramesh and Satyananda Reddy, 2016, Ullah et al., 2011) offer a good insight in this field. However, unlike our work, the greatest part of these works deal with safety-related approaches oriented to hazard identification. Among them, the following ones are of interest, although they do not use UML nor apply model checking techniques. In Troubitsyna (2008), the author proposes a method based on fault tree analysis (FTA) to derive requirements with the support of a state-based model. The Event-B formalism for control-systems is used in Lopatkin et al. (2011) and Méry and Singh (2015); interestingly the former uses it to automate Failure Modes and Effects Analysis (FMEA) partially. In the area of safety management and safety-driven design, Leveson presents the STAMP/SPTA approach (Leveson and Dulac, 2005) to meet assurance goals in software projects among other fields. This approach is followed and applied in other papers (Song et al., 2019, Friedberg et al., 2017). In the field of cyber–physical applications, the work in Masrur et al. (2016) presents a technique, to model interactions between components, that allows reasoning about timing behaviour.

The works in Dörr et al., 2003, Koh and Seong, 2009 and Yoo et al. (2005) are also in the field of safety-related approaches but closer to ours. In particular, Dörr et al. (2003) propose a requirement elicitation process based on use case modelling. Koh and Seong (2009) use model checking, as our work, and FTA and combine such techniques to verify security requirements automatically. Yoo et al. (2005) introduce a new formal method – NuSCR – to elicit safety-critical requirements and apply it to nuclear plants.

Security and safety requirements modelling using UML.
The literature on modelling security and safety requirements, using UML is also large. In the following we only recall: (a) some works highly cited in the literature, some of them have inspired our approach, and (b) some UML profiles that have been the baseline for the profile presented in this paper. SecureUML (Lodderstedt et al., 2002) is a seminal work in modelling security based on UML and the model-driven paradigm. The approach presents a methodology for modelling access control that also offers support for specifying complex authorisation constraints. Then, SecureUML focusses on specifying role-based access control policies and requirements, while our approach is for the modelling of attacks and protections. The final goal of SecureUML is to automatically generate security infrastructures for access control while our approach aims to assess survivability properties of systems. The CORAS method4 is oriented to model-driven risk analysis of changing systems (Lund et al., 2011), the CORAS language is used to support the analysis of security threats and risk scenarios in security risk analyses. UMLsec (Jürjens, 2002) allows to specify security information during the development of security-critical systems and provides tool-support for formal security verification according to the SVDT approach (Houmb et al., 2007). SVDT and its successor (Georg et al., 2010) allow for evaluating (already) verified alternatives against different requirements, including time-to-market and budget constraints. All these approaches are applied to software system design and IT security.

Regarding UML profiles, MARTE (OMG-MARTE, 2011) (Modelling and Analysis of Real-Time and Embedded Systems) is an OMG standard mostly focussed on schedulability and performance. DAM (Bernardi et al., 2013) is a MARTE extension for the modelling and analysis of dependable systems, while SecAM (Rodríguez et al., 2014) extends DAM for security modelling of critical infrastructures, early in the system development life-cycle. CIP_VAM (Vittorini et al., 2015, Drago et al., 2019) is a UML profile for vulnerability analysis and modelling in the field of critical infrastructure protection.5 It is used in model-driven chains involving Bayesian networks and quantitative modelling, and it focuses on physical aspects modelling, integration with SecAM was proposed in Marrone et al. (2015). Other approaches use SysML (Friedenthal et al., 2008) instead of ad-hoc UML profiles, as in Scholz and Thramboulidis (2013) and Roudier et al. (2013), and others create specific profiles for SysML (Biggs et al., 2016). An application of the SysML language to a critical system for assessing repair/survivability strategies can be found in Biagi et al. (2018). Finally, in Gharib et al. (2019) a UML profile for modelling functional safety requirements is proposed, the requirements are expressed in OCL and verified directly on the UML model.

Security and safety requirements verification using model checking.
As stated at the beginning of the sub-section, different works exist having similar premises: the work (Alrajeh et al., 2013) presents a tool, based on model checking, to complete the operational requirement specification according to the stakeholders’ goals. However, this approach strongly relies on the state-based specification and forces the requirement engineer to define positive and negative scenarios each time the model checker verifies a property violation. Thus, at each iteration, there is the need to define such scenarios against the properties, using the considered temporal logic language.

In this work, we propose a framework that allows the engineer to model safety and security requirements in the same model, using an extended version of the use case diagram. The rationale behind our proposal is to relieve the engineer from the modelling of a precise state-based specification and the definition of the properties to be checked in the temporal logic language. Then, the framework leverages model transformations for the state-based representation of the specification to verify the properties, which are selected by the engineer from a list of properties expressed as English sentences. The results of the verification allow the engineer to make informed decisions about the completeness of the requirement specification.

Based on the STPA methodology, previously commented, the work (Howard et al., 2017) identifies and formally analyses safety and security requirements, but different from our work, it is not focussed on verifying survivability properties. Verification of safety requirements in large software systems using probabilistic model-checking is proposed in Calinescu et al. (2012). Unlike our work, the approach in Calinescu et al. (2012) assumes the system already operational, and it is aimed at verifying, at runtime, the compliance with safety requirements. Another work, with some common points with our approach, is the seminal work in Gargantini and Heitmeyer (1999) that uses model-checking to test software implementations from requirements specifications. The main difference with this approach is that the methodology here proposed aims at verifying the specification instead of the resulting software artefact. Finally, the Formal Tropos (Fuxman et al., 2001) and Secure Tropos (Mouratidis, 2011) approaches deserve to be mentioned. Formal Tropos is a language that enables the automatic verification of requirements using model-checking, although it is not explicitly devoted to security requirements. Secure Tropos is for the analysis of security requirements alongside functional ones. It drives system designers from the acquisition of requirements up to their verification. There exist two versions of Secure Tropos, one extends the i*-language and the other extending Tropos. Secure Tropos also offers a CASE tool (Pavlidis et al., 2012).

In the light of the works above reviewed and considering the improvements, summarised in Section 1, that this paper offers concerning our previous works (Bernardi et al., 2016, Gentile et al., 2017), we can stress some conceptual differences with related works in the literature, as follows. First difference, we overcome the single-stepped attack and single-stepped recovery hypotheses assumed in Gentile et al. (2017), see Section 4.2. Second, the proposed fourteen queries define a starting rich-full framework for guiding the analyst to select the requirements of interest to be verified in the system. Third, the use of model checking, for the automatic verification of the selected requirements, produces counterexamples that significantly helps the analyst, for example: (1) to find sequences of attacks and repairs, or (2) to find degradation paths, as well as recovery paths and strategies. All these improvements conform to a framework that empowers the analyst to automatically obtain an assessment model, that helps in many tasks concerning the automatic verification of system security properties.

3. Methodology overview
Fig. 2 presents the big picture of our methodology and related framework. The methodology is composed of three phases: modelling, generation and verification. Regarding tools, those depicted as black gears are used by the CPS analyst, while the grey ones are invoked transparently by the other tools.


Download : Download high-res image (260KB)
Download : Download full-size image
Fig. 2. Methodology and tool framework overview.

During the modelling phase, the CPS analyst defines (functional and non-functional) system requirements building a UML misuse case diagram (MUCD) (Alexander, 2003). This specification is enriched by identifying essential services, threats, survivability strategies, and system service modes, which are annotated using the survivability profile recalled in the previous section.

During the generation phase, the aim is to create a survivability assessment model (SAM). The SAM is a UML state machine that represents the system service modes and the change of service modes caused by the occurrence of threats and the application of survivability strategies. The SAM generation tool accomplishes the task automatically, through several steps. In the first step, starting from the MUCD, the states of the SAM are created, they represent system service modes. Next, the tool transforms the MUCD into a Kripke model (MUCD formal model), that can be analysed by a model checker, e.g., NuSMV (Cimatti et al., 2002). The results of the analysis, in particular the counterexamples provided by the model-checker, are then post-processed to add the transitions of the SAM and label them with sequences of events (threats and survivability strategies). Consequently, the SAM represents the system evolution throughout the different service modes using the possible sequences of threats occurrences and survivability strategies execution.

In our methodology, the verification phase deals with the verification of system survivability properties. The properties are specified as abstract queries and stored in a query template repository (QTR). The CPS analyst, using the query instantiation GUI, selects queries and instantiates them with actual elements of the MUCD (e.g., misuse cases) or of the SAM (i.e., service modes). Then, an engine is called, which downloads, for each instantiated query, a solver capable of executing it. Finally, the query is proved against the SAM by the solver and results are presented to the analyst in the form of an assessment report. Currently, the surreal framework allows assessing fourteen different survivability properties, that is the properties listed in Table 3. The rationale behind the choice of these properties is to provide a general support for the assessment of systems survivability, and this paper applies them in the CPS context. The support encompasses the analysis of the recoverability of service modes (Security level properties), and the analysis of the effect of threat occurrences and survivability strategies on the service modes (Threat and Mitigation properties). Moreover, the framework has been designed for being easily extensible regarding new survivability properties.

The assessment report allows the analyst to make informed decisions about the completeness of the requirement specification. For example, one property of interest to verify is the strong reversibility, that is the possibility to recover the system to a given service mode (property P1 in Table 3). This property does not hold when the specification omits possible survivability strategies mitigating one or more threats represented as misuse cases; in such a case, the analyst can decide to refine the MUCD by adding such strategies and repeat the generation and verification phases with the refined specification. Therefore, the modelling and verification activities, supported by the interactive methodology, are carried out by the CPS analyst in a cyclic manner, until a requirement specification that satisfies the properties of interest is found.

Motivation.
In requirement engineering it is impossible to find a “silver bullet” and, in the case of cyber–physical systems, this task is worsened by the confluence of software, hardware, mutable operating environments and the human factor, since emerging behaviours are not rare but hard to predict. Hence, formal methods are just one of the techniques that can be used in such systems. They proved their effectiveness with many success stories, from Paris metro systems (Behm et al., 1999) to the Intel’s practices for the design of CPU architectures using model checking (Kaivola et al., 2009). Notwithstanding such techniques, new vulnerabilities are found even in those processors (e.g., the Spectre and Meltdown vulnerabilities). We strongly believe that the approach proposed in this paper, like other similar techniques, cannot be as a one-size-fits-all tool for system hardening.

First, the proposed methodology is for eliciting security requirements, hence, it should be first used in the early stages of the system development to discover failure scenarios. The fulfilment of such requirements should be then assessed later in the lifecycle.

Second, the proposed approach does not exclude but creates synergy with other techniques as testing. As it has been demonstrated in Benerecetti et al. (2017) model checking combined with functional testing may be successful in industrial settings.

Finally, the proposed methodology must be embedded in the development process. As it is impossible to have detailed knowledge in the early stages of development, we think that it should be applied more than once during the system lifecycle.

The choice of focusing on a functional level description is because the most widespread methodologies dealing with safety, security and in-the-large, dependability assessment of a product/system during the whole duration of its lifecycle, start with some kind of Functional Hazard Assessment (FHA). This family of methodologies is in charge of eliciting, determining the proper level of safety (or other dependability attributes) for each component with the consequent definition of the appropriate design and validation processes. Since such processes start in the very early phases of the system lifecycle, when the architecture is not often defined yet, then functions that the system has to provide are the only known system assets. Since our approach supports such phases, a functional view of the system is a right starting point. To help this point of view, the most adopted international standards recommend FHA in the early phases across different domains (e.g., IEC 61508 International Electrotechnical Commission, 1998, ISO 26262 ISO 26262, 2011, EN 50128 CENELEC, 2011).

Running example.
Modern military command and control systems are actually systems of systems that incorporate fully-integrated modular cyber–physical systems such as personal combat displays, unmanned aerial systems and tactical mobility night vision devices to enhance the situational awareness and improve decision-making (Eisenberg et al., 2018). To support the methodology description a military command and control system (Bernardi et al., 2016) is used as a running example.. The system provides two basic essential services: messaging and map positioning. These services must survive despite the presence of faults or attacks, thus allowing the officers in charge to send timely their orders to subordinates and to achieve the situational awareness in the battlefield. In particular, we will address the following questions that indeed represent system survivability requirements:

•
Is it always possible to recover to the service mode that provides the highest quality (the best service mode)?

•
Let us suppose the system is offering the highest quality service and man-in-the-middle attacks occur that manipulate the information about the operations plan exchanged between the officers, what is the service quality provided by the system after the attacks?

•
Let us consider a set of possible survivability strategies that can be used to improve the service quality in a degraded service mode. Which is the smallest subset that allows reaching the best service mode?

4. Modelling and generation phases
4.1. Modelling phase
In the modelling phase, the CPS analyst creates a MUCD enriched with a survivability specification. A MUCD is the result of a requirements elicitation process where four tasks can be emphasised: (a) the elicitation of the essential services, which should survive despite the presence of threats; (b) the vulnerability analysis (or threat modelling), where threats affecting essential services are identified; (c) the definition of survivability strategies, that aim at eliminating or mitigating threats; and (d) the definition of system service modes, which guarantee different levels of QoS, from the best one offered by the system, for all essential services, to the most degraded, but still acceptable. Specifically, system service modes are ranked according to the relevance of the QoS indices and their threshold values (i.e., QoS levels) associated to essential services: all system service modes but the one with the best QoS level are considered degraded service modes (or degraded states).

The specific methodology used to carry out the elicitation process has been already presented in Bernardi et al. (2016) and it is here omitted. the emphasis is, indeed, on the artefacts produced by the process. The vulnerability analysis takes into account two hypotheses: (i) the threats (or misuses) are independent, they may occur concurrently, and (ii) they are carried out in a single step. The same holds for the recovery strategies which are considered as single-step actions to recover from a degraded state.


Table 2. Tagged-values specification of the running example.

Stereotype: service	Tagged-values: indices (name,kind,values,initial)
ExchangeInformation	(avail, integerInterval, 0..100, 100)
(integLevel, integerInterval, 0..100, 100)
UpdateMap	(avail, integerInterval, 0..100, 100)
(integLevel, integerInterval, 0..100, 100)
Stereotype: misuse	Tagged-values: affects (index,set,inc,dec)
Jamming	(avail, –, –, 10)
ManipulateInformation	(integLevel, 50, –, –)
DestroyNode	(avail, 0, –, –)
(integLevel, 10, –, –)
Stereotype: recovery	Tagged-values: affects (index,set,inc,dec)
RestoreOriginalCommunication	(avail, 100, –, –)
ChooseAlternativeCommunication	(avail, –, 10, –)
RestoreOriginalData	(integLevel, 100, –, –)
Reconfigure	(avail, 100, –, –)
(integLevel, 90, –, –)
Stereotype: serviceModeDefinition, tagged-values: formula
(GS0,0, (ExchangeInformation.avail  90) & (ExchangeInformation.integLevel  60) &
 (UpdateMap.avail  90) & (UpdateMap.integLevel  60))
(GS1,1, (ExchangeInformation.avail  80) & (ExchangeInformation.integLevel  60) &
 (UpdateMap.avail  80) & (Update map.integLevel  60))
(GS2,2, (ExchangeInformation.avail  50) & (ExchangeInformation.integLevel  30) &
 (UpdateMap.avail  50) & (UpdateMap.integLevel  30))
(GS3,3,)
Fig. 3 shows an excerpt of the MUCD of the running example, where just two essential services are considered: i.e., ExchangeInformation – that is initiated by the military staff and includes different scenarios, such as the sending of reports, the request of supplies and the transmission of orders – and UpdateMap – that is triggered by a sensor, like a GPS tracker, and it provides up to date position awareness of military forces on a digital map. A more comprehensive model can be found in Bernardi et al. (2016), herein we refine the misuse case diagram applying the survivability profile, where for the sake of clarity, the tagged values associated to the stereotyped model elements are summarised in Table 2. In particular, essential services are characterised by two QoS indices, i.e., the availability and the integrity level, both express a percentage, thus they are defined over the interval 0..100, and their initial values are set to the highest value. The initial values represent the optimistic situation where the system is not affected by threats.


Download : Download high-res image (405KB)
Download : Download full-size image
Fig. 3. MUCD of the running example annotated with the survivability profile.

There are three misuse cases in the diagram: Jamming represents an attack aimed at interrupting (or slowing down) the communication, it is usually carried out by sending interference signals; ManipulateInformation represents an attack that is aimed at manipulating the geodata used to update the digital map or the information exchanged by the military staff; and DestroyNode that models the destruction of a node, which can be either accidental or intentional. The misuse cases compromise the QoS of the essential services, in particular, each misuse case may affect one or more QoS indices and the degradation of a QoS index value is specified using the affects tagged-value (see in Table 2). For example, the Jamming misuse case affects the availability of the ExchangeInformation service, it may occur multiple times, and its occurrence decreases the initial availability value of , whereas the ManipulateInformation misuse case affects the integrity level of the two essential services by halving its value. The DestroyNode misuse case affects both the availability and the integrity level of the UpdateMap essential service by setting their value to zero and , respectively.

For each misuse case, survivability strategies need to be specified to mitigate the effect of the misuse case on the QoS of the essential services. In the running example, only recovery strategies are modelled. In particular, two different strategies are included to mitigate a jamming attack, i.e., setting an alternative communication with lower bandwidth (ChooseAlternativeCommunication) and the restoration of the original communication (RestoreOriginalCommunication). The ManipulateInformation misuse case is mitigated by restoring the original geodata before the attack, and the destruction of a node (DestroyNode) is overcome through hardware redundancy and software reconfiguration. Similar to misuse cases, recovery strategies are annotated with affects tagged-values to specify how they affect the QoS indices of the essential services. For example, a reconfiguration, after node destruction, improves both the availability and the integrity level by setting them to the initial value and , respectively; whereas the two alternative recovery strategies from a jamming attack increase the availability differently: a  availability is guaranteed with the restoration of the original communication and an increase of  (concerning the initial value) is obtained in case of choosing the alternative communication mean.


Download : Download high-res image (71KB)
Download : Download full-size image
Fig. 4. Venn’s diagram representing system service modes.

Finally, the last annotation included in the MUCD specifies the system service modes (see serviceModeDefinition in Table 2). We use an ad-hoc syntax that enables to define each service mode as a triplet: (name, severity, QoSlevel), where name is the name of the service mode, severity is the severity level (the higher is the level more degraded the service mode is) and QoSlevel is a boolean expression that specifies the QoS level of the system in terms of the thresholds for the QoS indices associated to the essential services. In the running example, the thresholds for both the QoS indices are minimum values, and there are four service modes: GS0 is the best service mode that guarantees at least a  availability and at least a  integrity level of the two essential services. The other service modes provide degraded services: in particular, GS1 guarantees a lower threshold for the availability (i.e., ) concerning GS0, whereas in GS2 both the availability and integrity thresholds are lower than GS1. Finally, GS3 is the worst service mode, and it does not guarantee a QoS minimum threshold. Thus, the specification of the system service mode enables to divide the value domain space of the QoS indices into different regions, where each region is defined by the QoSlevel of a service mode:  Fig. 4 shows a Venn’s diagram representation of such regions.

4.2. Generation phase
The work in Gentile et al. (2017) already dealt with the automatic generation of the SAM. In that paper, starting from a misuse cases diagram – that specifies the system essential services, the attacks and countermeasures – a SAM is produced by a model-to-model transformation. However, the approach has a limitation, it only considers single-stepped attacks/recoveries, i.e., the direct transition from a service mode to another is due to either a single attack occurrence or a single recovery execution. Although reasonable in some industrial contexts, this paper wants to overcome such hypothesis, then allowing to elicit complex attack-recovery sequences – that is sequences of multiple attack occurrences and multiple recovery executions that cause the direct transition from a service mode to another – which postulates the main motivation of this phase of the methodology.

In the generation phase, we use NuSMV (Cimatti et al., 2002) to produce the SAM. NuSMV is a powerful model-checking tool characterised by its simplicity in specifying both models and properties. To generate the SAM, the MUCD is first transformed into a Kripke model – MUCD formal model, in Fig. 2 – and a first version of the SAM, which includes just the states representing the service modes. Next, the Kripke model is analysed by NuSMV and the counterexamples produced by the model checker are used to enrich the SAM with the state transitions.

MUCD-to-KRipke.
The generation process from the MUCD to the Kripke model is depicted, at a high level of abstraction, in Fig. 5 where a sample MUCD model is represented on the left and a scheme of the Kripke model is on the right. In the Figure, the directed arrows show the mapping between the model elements of the MUCD and the three main sections of the Kripke model, that is: Module Section, Define Section and Properties.

The Module Section contains the description of the behaviour of the processes determining the evolution of the system: this description is apportioned among as many modules as the number of the  use cases, in the MUCD, and one main module. The Define Section contains the definition of symbols. In particular, there are two sets of symbols: the Inhibit Symbols – used in the main module – to permit the activation of one or more attacks, and the SM Symbols – used in the Properties section – that capture into boolean variables the system service modes. In the end, the Properties section reports a list of CTL formulas expressing the possibility to pass from a service mode to another.

In the following, we describe the generation process in details with the help of the running example of Fig. 3 and the Listing 1, that reports an excerpt of the Kripke model automatically generated from Fig. 3. The complete Kripke model can be found in the Appendix C.


Download : Download high-res image (719KB)
Download : Download full-size image
First, there are as many modules as use cases stereotyped ¡¡service¿¿ in the MUCD. The parameters of a module are the names of the attacks and recovery actions related to the use case, i.e., the misuses that threat the use case and the recoveries that mitigate the misuses. Each module is then responsible for determining the evolution of the QoS indices specified in the ¡¡service¿¿ as a response to the values specified for the attacks and recoveries.


Table 3. Survivability properties supported by the surreal framework.




Download : Download high-res image (268KB)
Download : Download full-size image
Fig. 5. MUCD-to-Kripke: overview.

The second part is the main module that instantiates all the attacks and recoveries in the MUCD model with the following behaviour: attacks are represented by boolean variables (i.e., TRUE if the attack is launched, otherwise FALSE); recoveries are represented by three-valued variables (i.e., KO if the recovery is not active, ENABLED if a triggering attack has been launched, but the recovery is not executed, yet, and OK if the recovery is executed). The body of the main module correlates the evolution of the attacks (KO  OK) and of the recoveries (KO  ENABLED  OK). Furthermore, the main module instantiates the attack-related Kripke modules passing the attack/recovery variables to the corresponding use case modules as actual parameters. The usage of NuSMV’s modules for the modelling of the behaviour of the ¡¡service¿¿ use cases is not motivated by the need of instantiating these modules more than once in the main module; but rather by choice of respecting a modular approach and easing the generation process. Moreover, the main module instantiates the process modules by passing as actual parameters the misuse and recovery variables since misuse and recoveries have global scope (i.e., they must be seen from all the service processes).

The third part of the NuSMV model is made of two DEFINE sections that are related to the definition of: (1) attack inhibitor variables, used to inhibit one or more attack occurrences in fine-grained analyses (see Section 5); (2) service mode variables used to understand if the system is in one service mode or another.

Concerning the latter, there are as many boolean variables as service modes, which are defined according to the QoSlevel boolean expressions in the tagged values of the ¡¡serviceModeDefinition¿¿ stereotype. The severity values of the service modes define a total ordering relation of the service modes that is translated into an expression by taking into account the precedence between the variables themselves. As an example, if there are two service modes, Gx and Gy with severity of Gy greater than the severity of Gx, such service modes are translated into two variables as in Listing 2:


Download : Download high-res image (774KB)
Download : Download full-size image
where expr_x and expr_y are, respectively, the QoSlevel boolean expressions associated to the service modes Gx and Gy.
Both these groups of symbols are introduced for technical reasons. They simplify, respectively: (1) the switching between the MUCD formal model used in the generation and the verification phases (see Section 5 for further details); (2) the generation of the properties to check since, without defining such symbols, the properties should report the whole expressions with QoS indices.

The last part defines the properties to check. There is one property per transition in the SAM, hence, if we have  service modes, there will be  transitions and properties to check. Each property computes the sequence of events that brings from a service mode Gx to a service mode Gy. In order to compute such sequence, we need to negate it in the form of a CTL expression — i.e., it is always true that starting from Gx, all the next steps present !Gy, where the conditions Gx and Gy are the truth of the variables as defined above. The CTL formula for checking the “Gx-to-Gy” property is then expressed as in the Listing 3:



Download : Download high-res image (27KB)
Download : Download full-size image
Counterexamples-to-SAM.
The SAM is a UML state machine,where the states represent the system service modes, and the transitions allow the system to evolve through service modes. The statuses of the SAM are directly generated from the MUCD, considering the serviceModeDefinition, whereas the transitions between states are added from the results provided by NuSMV from the checking of the Kripke model.

In particular, for each service mode in the serviceModeDefinition, a state is generated and stereotyped as ¡¡mode¿¿; each state is annotated with the severity tagged value, representing the severity of the service mode. The transitions between states are generated by considering the list of counterexamples that are produced by NuSMV with the checking of the CTL formulas, for the Gx-to-Gy properties, defined in the Kripke model. In the case that the Gx-to-Gy property is considered true by the model-checker, no counterexample is found and thus there is no feasible sequence of attacks and/or repairs between the two service modes Gx and Gy. Otherwise, the model checker produces a detailed description of the steps from Gx to Gy.

Such a description is parsed according to an EBNF grammar. By constructing a proper parser and semantic analyser, the attacks/recoveries contained in the counterexample are filtered and then used to annotate the transition in the SAM, with the path tagged value of the ¡¡scenario¿¿ stereotype.6 A path is a sequence of misuse cases/recovery strategies states that cause the change of service mode, where each path item is specified by a triplet (service,value,step): service is the name of the misuse case/recovery strategy, value is its state and step is the global system state (see Table A.7, Table A.8 of the Appendix A).

The Listing 4 reports an excerpt of the NuSMV output related to our running example, whereas Fig. 6 shows the generated SAM in its graphical form.



Download : Download high-res image (30KB)
Download : Download full-size image
The screenshot, in Fig. 6 on the right, shows the property panel of the Eclipse-Papyrus tool, with the path value (not complete) associated to the transition T_GS3_GS2 – from the service mode GS3 to the service mode GS2, with lower severity. The complete path has been manually added in the note symbol attached to the transition. In particular, the path discovered by the model-checker represents the situation where both a Jamming and a DestroyNode has occurred and the corresponding recovery actions become enabled (step 0); in the next step (step 1), a ManipulateInformation attack is launched and, in the meanwhile, the recovery actions for the attacks previously occurred are executed; finally, recovery actions are deactivated (step 2). The effect of the recovery actions is to re-establish the  availability of the two essential services and increase the integrity level of updateMap; however, the attack in step 1 affects the integrity level of the ExchangeInformation which remains equal to . Thus, the reached service mode GS2 is better than GS3, but it is still degraded.


Download : Download high-res image (609KB)
Download : Download full-size image
Fig. 6. SAM of the running example.

Observe that, the paths found by the model-checker maybe not realistic in the context of the system under analysis. For instance, according to the approach discussed above both the recovery strategies RestoreOriginalCommunication and ChooseAlternativeCommunication are executed, whereas it seems straightforward that the execution of just the former is sufficient to improve the availability of the essential services. In the verification phase, the CPS analyst can perform a fine-grained analysis to check whether both are necessary, or just one of them is sufficient to improve the QoS indices. The framework is also open for fine-grained automatic analysis that are future works for this paper.

5. Verification phase
5.1. Properties and the query template repository
Once the system services, threats, strategies and service modes have been specified, and the survivability assessment model (SAM) automatically generated, then the system is ready for verification purposes. To this end, we have collected a set of survivability properties. Although large, the set is not exclusive but expandable. Most of these requirements belong to the survivability analysis field since they test properties related to system recovery. Table 3 presents the properties that are expressed as queries that can be proved against the SAM by a solver. Each property has a unique identifier (first column), a name (third column) and specifies a query template (fourth column) that will be eventually instantiated to the SAM. The query is expressed in natural language (English), and it is characterised by input parameters (fifth column) that may represent either service modes, misuse cases or recovery strategies. Depending on the property to be assessed, a different type of result will be returned by the solver (sixth column) that is a boolean value (i.e., true/false), a service mode or a scenario (i.e., a sequence of misuse cases or recovery strategies). The complete set of properties conforms what we call the query template repository (QTR) in the surreal framework.

Table 3 shows the properties arranged according to their kind (second column), which guides the interests of the analyst in the verification phase. In particular, the Security level properties focus the analysis on the recoverability of service modes, the Threat properties allow analysing the effect of threat occurrences on the service modes and the Mitigation properties help the analyst in deciding on the survivability strategies to be developed in the system. Appendix B formalises all the properties implemented by the surreal framework and listed in Table 3.

The properties in the running example.
Let us recall and interpret the three questions initially posed in Section 3:

1.
Is it always possible to recover to the service mode that provides the highest quality (the best service mode)?

2.
Let us suppose the system is offering the highest quality service and attacks that manipulate information occur, what is the service quality provided by the system after the attacks?

3.
Let us consider a set of possible survivability strategies that can be used to improve the service quality in a degraded service mode. Which is the smallest subset that allows reaching the best service mode?

The first question can be pinpointed to P1 and can be answered by instantiating the service mode GS0 (see Fig. 6) to the  input parameter of the query template. The second question can be addressed by instantiating P8, i.e., considering the ManipulateInformation misuse case (see Fig. 3). Finally, the last question can be answered by instantiating three times P14, one for each degraded service mode, i.e., GS1, GS2 and GS3.

5.2. The surreal framework
As shown in Fig. 2, for the verification phase the surreal framework encompasses several tools and documents, as follows.

Repository.
The QTR is currently implemented as a JSON file deployed on a web server. The file completely describes each property and includes an extra line to indicate the URL of the solver for the query: the Listing 5 reports an excerpt of it, where only the template of property P8 is shown.



Download : Download high-res image (397KB)
Download : Download full-size image
Query instantiation GUI.
The CPS analyst is now in charge of choosing the queries of interest and of specifying the parameters for binding — i.e., selecting the actual model elements according to the parameter type list. The query instantiation GUI guides the analyst in accomplishing this task for producing the query instantiation document (QID). Fig. 7 depicts a snapshot of the GUI when executed for our running example analysis.

Engine and solvers.
The engine is the core of the query analysis process. It is in charge to read the proper solvers in the QTR and call them based on the instantiated queries in the QID. More in details, the engine asks the QTR for the solver, retrieves the URL and dynamically loads it in the JVM7 to enable the solution of the instantiated query according to the binding specified in the QID. As inputs, the solver receives the SAM and an instantiated query (i.e., a single element of the QID). The solution algorithms of each solver are different one from another, but three categories have been identified:


Download : Download high-res image (384KB)
Download : Download full-size image
Fig. 7. Query instantiation GUI executed on the running example.


Download : Download high-res image (342KB)
Download : Download full-size image
Fig. 8. The running example — assessment report.

•
Type A: some solvers simply explore the SAM (e.g., in understanding which are the essential services potentially recovered by a recovery action);

•
Type B: others rely on the exhaustive state space exploration capability of the SAM by the model checker;

•
Type C: others can combine the two approaches above in effective and efficient solution algorithms. As an example of this class, Algorithm 1 sketches a pseudo-java solution for the solve method of the “Best set of strategies in a service mode (P14)” solver. This solution method uses the first approach (Type A) to analyse the SAM model by searching for a sequence of transitions from the queried service mode to the best one (lines 2–5). In the case of negative response, there is no recovery strategy, and hence the function ends returning an empty scenario. Otherwise, a recovery strategy is generated by considering as actions the paths associated with the transitions of the sequence. However, this set may be not minimal.8 Therefore, the second approach is applied (Type B) and the algorithm (lines 7–12) computes the smallest set of recovery actions by re-analysing the model with Bounded Model Checking (BMC) technique. More in detail:

–
@line 7: the MUCD formal model is generated using a new transformation component which is built based on the one developed in the Generation phase. These components differ in the number of properties to check (i.e., in P14 query template the model checker is asked to compute the path from degradedModeName to bestModeName);

–
@line 8: the MUCD formal model is analysed. In this case, the difference is just in the command line for launching NuSMV. The -bmc flag is just added (inside the called method);

–
@lines 9–10: they create and invoke the proper method of the specific query template post-processor to separate the requested answer among the other counterexamples;

–
@lines 11–12: at these lines, the transition from degradedModeName to bestModeName is extracted,parsed, cleaned and added to the returning Scenario.

It is worth noticing that the Query Template solvers of Type B and Type C require to analyse the MUCD formal model again; the MUCD-to-Kripke transformation, described in Section 4.2, is engineered to reuse most of the Kripke model automatically obtained in the generation phase. However, in the verification phase, the model checker is not used to generate the labelled transitions of the SAM, but to verify a property on the SAM. Hence, the Properties section of the Kripke model is different from the one generated before. Furthermore, while the Process Section is the same, few differences are present in the Define Section in case the property deals with one single attack (e.g., P8). In this case, the evolution of the original MUCD formal model is different because all the attacks cannot fire, but the one that is the subject of the analysis. To this aim, the Inhibit Symbols of the Define Section are changed setting to TRUE all of them but the one related to the attack that is free to fire.

Finally, and according to Fig. 2, the called solver returns the results for the engine to generate a textual report. All the reports related to all the queries in the QID are collected by the engine that returns them to the user in terms of an assessment report (AR). Fig. 8 depicts a snapshot of such a GUI for our running example analysis. Thus, the feedback provided to the analysis are the following answers:

•
P1(SM=GS0):true. It is always possible to recover to the best service mode.

•
P8(M=ManipulateInformation):[GS2]. When manipulation information attacks occur in the best service mode, then the system degrades to service mode GS2.

•
P14(S=GS1):@0:(P)RestoreOriginal Communication->OK. The best service mode can be restored from the degraded service GS1 by carrying out the only RestoreOriginalCommunication strategy.



Download : Download high-res image (117KB)
Download : Download full-size image
On the extensibility of the solvers.
The solution already presented for the solvers enables easy extensibility of the tool by allowing developers to define their query templates and related solvers. As supported by the UML class diagram in Fig. 9, the implementation of a solver is limited to the classes in the solver.specific package. More in detail, a solver should use and/or extend only some classes in the surreal.engine and surreal.samgen packages of the surreal framework, as depicted by the class hierarchy.

The main classes that a solver developer must implement are mainly related to: (1) the core of its solving algorithm — SpecificSolvers’s solve method —, (2) the usage of the SAMHandler containing the services able to query the SAM enhanced model (Type A and Type C solvers), (3) the implementation of both SpecificTransformation and SpecificPostProcessor in Type B and Type C. Solvers which respectively extend the classes of the surreal framework — Transformation is in charge of generating the SAM while PostProcessor parses the results of the model checker execution. Finally, as explained previously, each solver returns the results, concretely an object of the class Result, for the engine to generate a textual report as in Fig. 8.


Download : Download high-res image (260KB)
Download : Download full-size image
Fig. 9. Class diagram for extending solvers in the surreal framework.

6. The case study
This section describes the application of the approach to a more complex case study in order to exhibit its potentialities in real contexts. The considered system is a smart car in the domain of intelligent transportation systems. The case study has been extensively described in Stellios et al. (2018), where readers can find the complete description of the system and a survey of known attacks against it.

Modern smart cars are equipped with many sensors, actuators and a set of control units (Electronic Control Units — ECUs) that are able to manage both mechanical and electrical components, such as braking, transmission, airbags, infotainment, emergency call and adaptive cruise control. These components allow the introduction of innovative smart control and assisting subsystems, such as Autonomous Driving Systems (ADS), Adaptive Cruise Control (ACC), collision avoidance and emergency vehicle notification systems. All these systems rely on data collected by on-board sensors that automatically generate novel control actions to maintain speed and safety distance, to immediately brake the car, to alert the driver with messages transmitted by emergency vehicles and so on. Smart cars also integrate an Internet connection (mainly through a data SIM card) for infotainment services to enable an in-car WiFi connection.

A single bus (Controlled Area Network — CAN) – introduced in the ’80s to reduce the car wiring costs and to share information among the different subsystems – connects all the devices with the ECU. Furthermore, wireless technologies enable communication with other vehicles (known as Vehicle-to-Vehicle communications) and with the traffic infrastructures (Vehicle-to-Infrastructure communications). A physical connection (On-Board Diagnostics Socket — ODB) is also present to provide physical access to the whole system. Typically, all these subsystems and components do not include any security mechanism making the smart car vulnerable to various types of attacks.

Misuse case diagram.
The misuse case diagram, shown in Fig. 10, represents a set of subsystems of the smart car at a high level of abstraction. As said previously, the depicted diagram is a UML use case diagram where mainly the use cases are annotated as service, misuse or recovery to identify respectively essential services, threat scenarios and recovery strategies. The ADS consists of two subsystems: the ACC and the collision avoidance subsystems. The former is in charge of providing two essential services MaintainSpeed and MaintainDistance, whereas the latter provides the EmergencyBraking. The first two services are needed by the ACC to regulate the speed of the car to automatically keep a minimum distance from the preceding vehicles. Both these services rely on the information provided by the on-board sensors, and specifically either on a radar, or on a laser detector, or on a camera, and are able to brake the car when it is approaching a slower vehicle, and then accelerates when the traffic condition permits it. These services have been modelled as UML use cases annotated with the stereotype service. The third service is needed to activate the emergency braking of the car (with the maximum breaking strength) when an obstacle is detected in the proximity of the car to avoid collisions. The other two sub-systems i.e., Internet connectivity services and Emergency vehicle notification, provide respectively the OnLineInfotainment and the AlertDriver essential services. The former is initiated by the driver and it allows him/her to easily control all those systems such as GPS navigation system, radio, music playing and smartphone integration using simple and intuitive commands. The latter is waked up by road sensors and it shows alerts about the presence of emergency vehicles with the rights of way in the proximity of the car. Also these two services are use cases of the misuse case diagram, annotated as service. Furthermore, the diagram in Fig. 10 contains six misuse cases (use cases annotated with the stereotype misuse) which can threaten the essential services, and six recovery strategies which can be applied to recover the system (use cases annotated with the stereotype recovery). Each misuse case and recovery will be described in the following of this paragraph. The dependencies among use cases are also annotated with the stereotype threatens to model the relationships between misuse cases and services, and with the stereotype mitigates to model the relationships between recoveries and misuses.


Download : Download high-res image (731KB)
Download : Download full-size image
Fig. 10. Misuse case of the case study.

According to the ISO 26262 – Functional Safety for Road Vehicles (ISO 26262, 2011) – the essential services have to be classified considering the Automotive Safety Integrity Levels (ASILs). There are four levels in the ASIL classification: from ASIL A to ASIL D, where ASIL A represents the lowest requirement on the service whereas ASIL D is the highest. In addition, ASIL QM means that there are not safety requirements associated to the service. As reported in Table 4, the services considered in this case study have all an impact on safety. In particular, the indices tagged-values associated to the essential services correspond to the highest value of ASIL (i.e., ), indicating the highest safety requirement, where the ASIL enumeration domain  has been mapped to an integer interval 0..100 as follows: . Moreover, the availability of the On-LineInfotainment and AlertDriver essential services is also considered. This index, in fact, is expressed as an integer interval 0..6, which specifies the number of “nines” after the comma, i.e., . Just to interpret the availability values, considering a mission time of 1 year, the corresponding downtimes are about  (avail4),  (avail5) and  (avail6). Thus, the availability initial values assigned to the essential services are the highest ones.

There are six misuse cases in the diagram in Fig. 10 (represented by the use cases annotated with the stereotype misuse). SensorsJamming represents an attack aimed at slowing down (or interrupting) the distance measurement by means of interference signals, thus it threatens the maintenance of the distance from the preceding vehicle and the capability of activating the emergency braking. BlindRadar also threatens the MaintainDistance service as the previous attack, but it is aimed to prevent the correct measurement of the distance from the preceding vehicle. Each time one of these two attacks are launched, they decrease the initial ASIL level of the affected services by . TakeControl represents an attack aiming at taking the control of the ADS system, e.g., managing speed and distance from the outside. A successful attack of this type completely reduces the ASIL of the affected services to . InjectCommandsViaWifi and SendCraftedDABdata are special cases of TakeControl, in the sense that they also aim to take control of the ADS of the car but they act, indirectly, by exploiting vulnerabilities of the OnLineInfotainment service. The former represents an attack conducted by a nearby adversary who wants to take control of the ADS of the car by injecting malicious commands through the in-car WiFi; the latter models an attack conducted by an adversary who creates a fake radio station and sends crafted Digital Audio Broadcasting (DAB) signals to compromise the on-line infotainment of the smart cars in the range. Both these attacks reduce the ASIL of the affected services to  and decrease the availability of the OnLineInfotainment service of  nine. Finally, InjectMessages represents an attack to the emergency vehicle notification system, where an adversary injects messages in the traffic control system of high-traffic roads. This attack reduces the ASIL of the AlertDrive service to  and decreases its availability of  nine.


Table 4. Tagged-values specification of the case study.

Stereotype: service	Tagged-values: indices (name,kind,values,initial)
MaintainSpeed	(ASIL,integerInterval, 0..100,100)
MaintainDistance	(ASIL,integerInterval, 0..100,100)
EmergencyBraking	(ASIL,integerInterval, 0..100,100)
On-LineInfotainment	(ASIL,integerInterval, 0..100,100)
(avail, integerInterval, 0..6, 6)
AlertDriver	(ASIL,integerInterval, 0..100,100)
(avail, integerInterval, 0..6, 6)
Stereotype: misuse	Tagged-values: affects (index,set,inc,dec)
SensorsJamming	(ASIL, –, –, 20)
BlindRadar	(ASIL, –, –, 20)
TakeControl	(ASIL, 0, –, –)
InjectCommandsViaWiFi	(ASIL, 50, –, –)
(avail, –, –, 1)
SendCraftedDABData	(ASIL, 50, –, –)
(avail, –, –, 1)
InjectMessages	(ASIL, 50, –, –)
(avail, –, –, 1)
Stereotype: recovery	Tagged-values: affects (index,set,inc,dec)
DiscardSensor	(ASIL, –,20,–)
ManualControl	(avail, 0, –, –)
ReconfigureFirmware	(ASIL, 100, –,–)
(avail, –, 1, –)
DisableWiFi	(ASIL, 100, –, –)
DisableDABReceiver	(ASIL, 100, –, –)
HideAlerts	(avail, 0, –, –)
Stereotype: serviceModeDefinition, tagged-values: formula
(Optimal,0,(MaintainSpeed.ASIL  75) & (MaintainDistance.ASIL  75) &
(EmergencyBraking.ASIL  75) & (AlertDriver.ASIL  75) & (AlertDriver.avail  5) &
(On-LineInfotaintment.ASIL  75) & (On-LineInfotaintment.avail ¿5))
(DegradedICandEN,1,(MaintainSpeed.ASIL  75) & (MaintainDistance.ASIL  75) &
(EmergencyBraking.ASIL  75) & (AlertDriver.ASIL  50) & (AlertDriver.avail  4) &
(On-LineInfotaintment.ASIL  50) & (On-LineInfotaintment.avail ¿4))
(DegradedASDSafety,2,(MaintainSpeed.ASIL  50) & (MaintainDistance.ASIL  50) &
(EmergencyBraking.ASIL  50) & (AlertDriver.ASIL  75) & (AlertDriver.avail  5) &
(On-LineInfotaintment.ASIL  75) & (On-LineInfotaintment.avail ¿5))
(Degraded,3,(MaintainSpeed.ASIL  50) & (MaintainDistance.ASIL  50) &
(EmergencyBraking.ASIL  50) & (AlertDriver.ASIL  50) & (AlertDriver.avail  4) &
(On-LineInfotaintment.ASIL  50) & (On-LineInfotaintment.avail ¿4))
(VeryDegraded,4,(MaintainSpeed.ASIL  25) & (MaintainDistance.ASIL  25) &
(EmergencyBraking.ASIL  25) & (AlertDriver.ASIL  25) & (AlertDriver.avail  4) &
(On-LineInfotaintment.ASIL  25) & (On-LineInfotaintment.avail ¿4))
(WorstDegradation, 5)
In the diagram depicted in Fig. 10, six survivability strategies – modelled as use cases annotated with the stereotype recovery – are defined to mitigate the effects of the misuse cases and recover the system. DiscardSensor is introduced to mitigate the sensor jamming attack, and its effect on the QoS indices of the services affected by the misuse case is to increase their ASIL of . An extreme recovery strategy consists in giving the manual control to the driver (ManualControl), which can help in case of adversaries who take the control of the ADS of the car or blind radar, but with a negative impact on the availability of the OnLineInfotainment service, reducing it to . To contrast the injection of commands via Wi-Fi, applicable strategies are to reconfigure the firmware (ReconfigureFirmware) or to disable the in-car WiFi (DisableWiFi). In both these cases, the strategies improve the ASIL of the services that is reset to , while the availability of the OnLineInfotainment service increases by  nine only in case of firmware reconfiguration. Instead, if the adversary tries to crack the DAB signal, it is possible to disable the DAB receiver (DisableDABReceiver), which increases the ASIL to . At last, to recovery the system from fake messages injected against the emergency vehicle notification system, it is possible to hide the alerts (HideAlerts) but, as for the manual control, the availability of the alert service goes to .

At the bottom of Table 4, we reported the definition of the six system service modes which vary from the Optimal to the WorstDegradation. In particular, the Optimal service mode guarantees ASIL D (i.e., greater than ) for all the essential services and an availability of at least  nines for the OnLineInfotainment and AlertDriver services. Starting from the best service mode, two distinct degradations are possible: degradation of Internet Connectivity and/or of the emergency vehicle notification services (DegradedICandEN), and degradation of ADS services (DegradedASDSafety). The intersection of both these degradations is a different service mode, named Degraded. A last acceptable degraded service mode is VeryDegraded, where essential services guarantee a minimum ASIL B, and the OnLineInfotainment and AlertDriver services guarantee an availability of at least  nines. The last service mode, WorstDegradation, does not guarantee minimum thresholds of the QoS indices. The inclusion relationship between the six services modes is represented by the Venn’s diagram shown in Fig. 11.

The SAM model.
Fig. 12 depicts the SAM model that has been automatically generated from the misuse case diagram of Fig. 10 by the SAM generation tool. The generated state machine has  states, corresponding to the service modes previously described, and  transitions, corresponding to the possibilities of the system to pass through the different service modes.


Download : Download high-res image (203KB)
Download : Download full-size image
Fig. 11. Venn’s diagram representing smart car service modes.

For sake of space, we do not report the NuSMV model of the case study; in the following paragraph, we describe the counterexamples to SAM, which are automatically generated to verify some properties of interest.

System verification.
The model previously described has been verified against the three properties P1 (Reversibility), P8 (Security level threat impact) and P14 (Best set of strategies in a service mode). Excluding the trivial case of the service mode WorstDegradation, we obtained that the reversibility is guaranteed for all the service modes but VeryDegraded. In fact, the reader can verify that all the corresponding states except VeryDegraded in the SAM model (depicted in Fig. 12) have incoming transitions from all the states with higher severity.


Download : Download high-res image (648KB)
Download : Download full-size image
Fig. 12. SAM of smart car (automatically generated).

More complex results have been found for the remaining two properties. In fact, the analysis of the security level threat impact (P8) highlights that multiple occurrences of TakeControl lead the system in the state WorstDegradation. Instead, each of the remaining misuse cases sets ASIL of services to  and decreases their availability one at a time up to unacceptable levels.

At last, the analysis of the best set of strategies in a service mode (P14) highlights that the recovery ReconfigureFirmware is the shortest way – alone or in combination to other countermeasures – to recover the system from the states DegradedICandEN, Degraded, VeryDegraded and WorstDegradation. In fact, this recovery rises up the ASIL to , which is the level required by the best service mode.

In the last part of this paragraph, we report the execution times of the conducted analysis. All the results have been obtained working on a laptop equipped with Intel(R) Core(TM) i7-2677M CPU @ 1.80 GHz and 4 GB of RAM. The SAM generation has been performed in 25.32 s. The analysis of P1 was almost instantaneous (since it is of Type A). Concerning P8 and P14 properties, Table 5 reports the minimum, maximum and average time. The difference between the execution times of these two analysis is due to the need in P14 query to find the shortest counterexample, that we implement with the BMC analysis — generally more complex and time-consuming than other kinds of analysis.

These values demonstrate the applicability of the proposed approach also on complex real-world case studies, as the smart car could be. Up to now, the tool analyses each query separately: future tool optimisation actions would explore batch executions of properties on the same formal model (to exploit single generation of the state space) and/or parallel executions.


Table 5. Execution times.

Property	Execution time [s]	
min	avg	max
P8	0.01	0.05	0.07
P14	26.89	36.21	51.04
7. Assumptions and threats to validity
The presented methodology relies, in our view, on realistic assumptions discussed throughout the paper and here summarised. Mainly, the application of the surreal framework is enabled by the usage of profiled UML models representing both, use cases and misuse cases, but also service modes of the overall system need to be known and well-defined. These assumptions can be easily satisfied in realistic applications when domain experts analyse the survivability from such an elicitation of possible misuse cases. Starting from this model, the framework is able to conduct automatic verification, so giving answers to common and important properties in the survivability field. Summarising, the main hypothesis supporting the methodology are the following:

HP1:
misuses may occur concurrently and are independent;

HP2:
misuses are considered as carried out in a single step;

HP3:
recovery strategies are independent;

HP4:
recovery strategies are considered as single-step actions and are able to recover from a degraded state;

HP5:
the QoS levels of each system status, as well as the impact of the attacks and the improvement due to the mitigation strategies, are based on the requirement engineer domain knowledge.

When using surreal, we have observed that the framework is able to cope with the increasing size of the models in realistic scenarios. In fact, the tree-like structure offered by the Eclipse plugin helped to the scalability of the approach. Moreover, when the number of misuses increases, the model can be organised in packages for a better visualisation and management. In any case, surreal leverages, for modelling, state of the art Eclipse tools and scales according to them. If some threat exists for these tools it will apply to surreal as well. The application of the methodology and framework to the proposed case study has shown us the effective management of a complex real-world application and its validation. In fact, the manual modelling of the case study has not been a hard task and the framework well supported this activity. So, we are also confident that more complex case studies can also be managed. Even if we have investigated fourteen properties, the surreal framework can be extended with additional ones and corresponding solvers. The latter can be carried out by downloading the source code of the framework, freely available on the GitHub repository of the project, and developing a custom package, following the instructions given in Section 5. According to our opinion, such development of a new solver is not a challenging task for a medium experienced Java developer. At last, it is important to remark that the real impact of attacks and recovery strategies during system service may not correspond, one by one, to those estimated by the approach. In fact, estimated values can be affected by contextual factors that may not be completely captured by the model initially. This threat is common to all modelling approaches, especially in the initial stages of the life-cycle. Hence, there is research on modelling under uncertainties (Ayyub and Klir, 2006). However, as the development process progresses, the engineer is equipped with better knowledge and tools, such as system prototypes, that help to gain insights for calibrating the model, then obtaining more accurate estimations. In particular, for threat elicitation, discrepancies can derive from many sources, even from a wrong threat analysis conducted by experts. Fortunately, in our proposal, the automation capabilities provided by surreal, both at the modelling and solution levels, make feasible to re-apply the approach several times in short time-span. This is useful for updating the UML models, as well as the estimations, as such knowledge is acquired.

8. Discussion and conclusion
The relevant contribution of this work, in our view, is the capability of verifying survivability properties. Moreover, the verification is automatic, as well as the generation of the model where they are proved, i.e., the SAM. The SAM is a by-product of the security specification developed by the analyst, mostly in terms of misuse cases.

Currently, we have conceptually investigated fourteen properties, all of them implemented in the framework. As explained in Section 5.2, the set of properties is extensible, also in terms of tool implementation - Fig. 9 - which confers great potential to the approach. The properties are expressed abstractly, in terms of security concepts, e.g., threats, which means that they need to be interpreted in the problem domain by an expert, e.g., the CPS analyst in the case study. Such abstraction level makes more robust the proposal since it is not bounded to a particular problem domain or application, but can address CPS at large. However, it posed the challenge of formalising each property, as explained in Appendix B.

The methodological and theoretical contexts proposed by the work have indeed been made practicable. The surreal framework has been developed for the Eclipse platform (The Eclipse Foundation, 2019) and applying the model-driven (The Object Management Group (OMG), 2018, Selic, 2003) paradigm for the SAM generation tool. The rest of the tools, query instantiation GUI, engine and solvers have been developed in Java (Oracle, 2019) language and they are also integrated in the framework, which can be freely downloaded from https://github.com/stefanomarrone/surreal.

Concerning the surreal architecture, the design choice to implement a lightweight analysis framework with just the Solver interface has the following advantages: (a) it gives the freedom to the user to implement his/her specific solvers with the preferred technology; (b) an open architecture supports extensibility of the framework with third-party contributions, of new solvers; (c) ad-hoc solvers, focussing on a single Query Template, are more manageable to design, test and load at run-time in the engine during the verification phase.

The surreal framework and the overall approach have been validated through a CPS case study in the automotive domain. The system is exposed to attacks that threaten the safety of the passengers. The case study makes it clear at least: (a) the complexity of survivability specifications in CPS, as manifested in the specifications in Table 4 and in the complex definition of the transitions in Fig. 12, (b) the important role of the CPS analyst for understanding the problem domain, for example, when s/he needs to classify essential services considering the ASILs, and (c) the need for verifying security properties. Although we decided not to present all the details of the system verification, we assess three interesting properties, and among others, we conclude that for different service modes the system could not reach an optimal mode, i.e., the safety is not guaranteed.

As future work, we want to test the tool framework in various case studies and with new properties at hand. Other research efforts will be put on upgrading the methodology and tools by considering quantitative aspects. Services, misuses and recovery actions can also be annotated with quantitative information capturing the probability of their occurrence and/or success. Furthermore, we plan to integrate this quantitative information into the MUCD formal model, and use quantitative model checking frameworks (e.g., PRISM Kwiatkowska et al., 2011). The final aim is to provide to the CPS analyst not only information about the possible sequence of events but also to estimate the probability of their occurrence, to boost his/her decisional power.

CRediT authorship contribution statement
S. Bernardi: Conceptualization, Methodology, Formalization, Definition and Implementation of the UML Profile, Writing. U. Gentile: Conceptualization, Definition and Implementation of SAM generation process, Writing. S. Marrone: Conceptualization, Methodology, Framework design and implementation, Writing. J. Merseguer: Supervision, Methodology, Definition and Implementation of the UML Profile, Writing. R. Nardone: Software, Validation, Case study, Writing.

Declaration of Competing Interest
The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.


Table A.6. Misuse case extensions.

Stereotype/Tag	Extension	Description
misuse	–	(Generalisation: serviceMS) A misuse case represents an use case from the point of view of an hostile actor.
Tag		
affects		It is a set of consequences on the services threatened by the misuse case. Each consequence is expressed in terms of the (negative) impact on the value of a QoS index.
successProb		It is the probability of succeeding.
attackDelay		It is the mean time between the attack launching and the intrusion occurrence.
misuser	Actor	A misuser is an hostile actor: it can be an attacker, an unaware user who uses the system in the wrong way or the environment that hinders the system being in operation.
mitigates	Dependency	It is a direct relationship between a strategy that aim at mitigating a misuse case and the misuse case.
resistance	–	(Generalisation: strategy) It is a strategy aimed at repealing an attack or masking an accidental fault (Ellison et al., 1999).
recovery	–	(Generalisation: strategy) It is a strategy aimed at restoring the service after an intrusion or failure (Ellison et al., 1999).
Tag		
affects		It is a set of consequence on the services that were threatened by the misuse cases mitigated by the strategy. Each consequence is expressed in terms of (positive) impact on the value of a QoS index.
MTTR		(Mean Time To Recover) It is the time to undergo recovery.
recognition	–	(Generalisation: strategy) It is a strategy aimed at detecting an attack/fault and evaluating the damage (Ellison et al., 1999).
service	Use case	It is an essential service provided by the system that must survive even when it is infiltrated, compromised or crashed (Ellison et al., 1999).
Tag		
indices		It is a set of Quality of Service (QoS) requirements associated to the service. Each QoS requirement is expressed in terms of a performance, dependability or security index.
serviceModeDefinition	Constraint	It is a specification of the global service modes of the system.
Tag		
formula		It is a set of global service modes. Each service mode is a logical expression that defines the QoS requirements of the system in terms of minimum/maximum acceptable values for the QoS indexes associated to the essential services.
serviceSM	Use case	It is an abstract stereotype that may represent either a misuse case or a survivability strategy.
strategy	Use case	(Generalisation: serviceSM) It is an abstract stereotype that represents a survivability strategy.
Tag		
successsProb		Probability of succeeding.
threatens	Dependency	It is a direct relationship between a misuse case that threatens an essential service and the service.


Appendix A. Survivability profile
The survivability profile, see Fig. 1, is structured in three separate packages:

•
Misuse case extensions: it includes stereotypes to specify threats/attacks and protections in UML use case diagrams, as a result of threats modelling and survivability analysis of the system. Table A.6 lists all the stereotypes of this package.

•
Survivability Assessment Model (SAM) extensions: it includes stereotypes to specify service modes and changes of service modes in UML state machine diagrams. This package depends on the previous one. Table A.7 lists all the stereotypes of this package.

•
Survivability types: it includes a set of datatypes/enumeration used to define the previous stereotypes. Table A.8 lists all types in detail.


Table A.7. Survivability assessment model extensions.

Stereotype/Tag	Extension	Description
mode	State	A global service mode.
Tag		
severity		The severity level of the service mode: the higher is the level the more degraded mode is.
scenario	Transition	The system changes from a global service mode to another global service mode.
Tag		
path		It is a sequence of misuse cases/recovery strategies that causes the change of a service mode.

Table A.8. Survivability types.

Datatype/Attribute	Description
MSActivation	It is a misuse/strategy activation.
Attribute	
service	The misuse case or the survivability strategy.
value	The state value associated to the service.
step	The step number, representing a state of the global system, that includes this service value.
affectConsequence	It is the consequence on a QoS index.
Attribute	
index	The name of the QoS index.
set	The value set to the QoS index.
inc	The increment to the current value of the QoS index (positive consequence due to a recovery strategy).
dec	The decrement to the current value of the QoS index (negative consequence due to a misuse case).
duration	Mean duration.
Attribute	
value	Time value.
unit	Time unit.
index	QoS index.
Attribute	
name	The name of the QoS index.
kind	The type of value domain.
values	The value domain.
initial	The initial value.
indexKind	Index value domain
integerInterval	An integer interval.
enum	Enumeration.
Appendix B. Formalisation of the properties
This appendix provides a formalisation of the survivability properties that the surreal framework offers currently. We realised the need for formalising the properties early while studying their application even to simple examples, and definitively while implementing them. In fact, some properties where being interpreted by each researcher slightly different. However, it took discussions to find a better way of carrying out the formalisation. Finally, we based the formalisation on two definitions: (a) the SAM (survivability assessment model), i.e., a state machine, given in Definition 1; and (b) the service mode reachability, given in Definition 2.

Definition 1

A state machine is a tuple , where:

•
 is the set of service modes.

•
 is the set of transitions representing the changes of service mode.

•
 is the set of (mis)use cases, which is partitioned into the set of threats  (misuse cases), and the set of recovery strategies  (strategy use cases).

•
The service mode change function  associates to each transition  a pair of service modes 
, where  is the leaving service mode and 
 is the entering service mode. The change from service mode  to service mode 
 is denoted by: 
.

•
The priority function  assigns a natural number to each service mode: the lower is the priority, the more degraded is the service mode. The priority function  defines a total ordering of the service modes and 
 such that 
 is the best service mode.

•
Let  be the set of the possible threat/recovery strategy states, the function 
 assigns to each transition , where 
, a sequence of threat/recovery strategy occurrences 
, where 
, that causes the change of service mode from  to 
. We denote by , the number of occurrences of  in the sequence occurrence  of transition .

Definition 2

Let  be a state machine, a service mode 
 is reachable from a service mode  if there exists a sequence of transitions 
, where 
, that leads from  to 
, i.e.: 

In the following, each query template or property, listed in Table 3, is formally defined using the notation just introduced.

Property 1 (Reversibility).
Let  be a state machine and  a service mode. Then, it is always possible to recover to  iff  such that 
.

Property 2 (Strong reversibility).
Let  be a state machine and  a service mode. Then, it is always possible to recover to  without further degradation iff  such that 
 and 
.

Property 3 (Recoverability).
Let  be a state machine, 
 two service modes, where 
. Then, it is always possible to recover to  from 
 iff 
.

Property 4 (Strong recoverability).
Let  be a state machine and 
 two service modes, where 
. Then, it is always possible to recover to  from 
 without further degradation iff 
 and 
.

Property 5 (Threat consequence — single occurrence).
Let  be a state machine and  a threat. Then, a single occurrence of  provokes a system degradation iff 
 such that:

1.
,

2.
, and

3.
.

Property 6 (Threat consequence — multiple occurrence).
Let  be a state machine and  a threat. Then, a multiple occurrence of  provokes a system degradation iff 
 such that:

1.
,

2.
, and

3.
.

Property 7 (Security level threat impact — single occurrence).
Let  be a state machine, 
 the best service mode and  a threat. Let us denote by 
, the set of service modes that can be reached directly from 
. Then, the set 
:  
 is the set of service modes reached by a single occurrence of the threat  from the best service mode 
.

Property 8 (Security level threat impact — multiple occurrence).
Let  be a state machine, 
 the best service mode and  a threat. Let us denote by 
, the set of service modes that can be reached directly from 
. Then, the set 
:  
 is the set of service modes reached by multiple occurrences of the threat  from the best service mode 
.

Property 9 (Threat scenario).
Let  be a state machine, 
 the best service mode and 
 a service mode. Given a sequence of transitions 
 that leads from 
 to , i.e., 
, the set 
 contains the threats that cause the service degradation to  from the best service 
. Then, the smallest set of threats 
 that leads to  from 
 satisfies the equality: 
 

Property 10 (Recovery feasibility).
Let  be a state machine and  a recovery strategy. Then,  is feasible iff 
 where 
 such that .

Property 11 (Multiple recovery).
Let  be a state machine and 
,  recovery strategies. Then, the  survivability strategies are always needed together iff 
 where 
 such that 
.

Property 12 (Recovery mutual exclusion).
Let  be a state machine and 
, a subset of recovery strategies. Given a transition 
, let us denote by , the set of recovery strategies that causes the change of service mode from  to 
. Then, the subset of recovery strategies are never carried out together iff: 

Property 13 (Threat/recovery effectiveness).
Let  be a state machine,  a threat and  a recovery strategy. Then, the strategy  is effective to mitigate the threat  iff  
  
where 
.

Property 14 (Best set of strategies in a service mode).
Let  be a state machine, 
 the best service mode and 
 a service mode. Given a sequence of transitions 
 (
) that leads 
 to 
, i.e., 
, where 
, let 
 be the set of recovery strategies that occurred in . Then, the smallest set of strategies 
 that leads to the best service mode satisfies the equality: 
 where  is the cardinality of the set .

Appendix C. Kripke model of the running example
This appendix includes the complete Kripke model of the running example.



Download : Download high-res image (218KB)
Download : Download full-size image
