Abstract
Formal specification can benefit software quality by precisely defining the behaviors of operations to prevent primary mistakes in the early phase of software projects, but a remaining challenge is how such a specification can be checked comprehensibly to show whether it satisfies the user’s perception of requirements. In this paper, we describe a new technique for animating operation specifications as a means to address this problem. The technique offers new ways to do (1) automatic animation data generation for both input and output of an operation based on pre- and post-conditions, (2) visualized demonstration of the relationships between input and the corresponding output, (3) comprehensible animation of data items, and (4) illustrative animation of logical expressions and the operators used in them. We discuss these issues and present a prototype tool that supports the automation of the proposed technique. We also report an industrial application as a trial experiment to validate the technique. Finally, we conclude the paper and point out future research directions.

Previous
Next 
Keywords
Formal specification

Specification animation

Verification and validation

1. Introduction
Formal specification is a technique for defining what to be done by a potential software system using a mathematically-based language or notation. If used properly to appropriate application domains, formal specification can produce benefits in terms of improving software reliability and reducing the cost of its development (Kurita et al., 2008a, Woodcock et al., 2009). However, formal specification also faces challenges that keep many practitioners away from utilizing its advantages (Knight et al., 1997, Parnas, 2010). Our experience in applying formal specification in industry (Liu et al., 1998a, Luo et al., 2016) has made us realize that formal operation specifications are the places where mistakes often occur.

In realistic software projects, formal specifications are mainly written and read by the developers who are well trained in formal methods, but they may occasionally be used as a vehicle for communication between the developer and some users who have a good background of mathematics or formal methods. However, as far as our experience in Japan and China can tell, most users of software systems developed in industry would not be expected to understand formal specifications (Liu et al., 2008). Therefore, the formal specification written by the developer will need to be validated against the user’s requirements in a comprehensible manner.

Specification animation was proposed as a means for formal specification validation in 1990’s (Hazel et al., 1997, Miller and Strooper, 2003b). The essential idea is trying to make formal specifications in pre- and post-conditions executable so that sample input data, which is called animation data, can be properly selected to demonstrate the behavior dynamically. But since the proposed approach requires automatic translation from formal specifications in a formal notation (e.g., Z) to code, it can only deal with a subset of the formal notation because not all of the specifications in pre- and post-conditions can be automatically refined into code for execution (Hayes and Jones, 1989). Almost in the same period, Chen and Liu proposed an alternative technique called specification testing that does not require translation of formal specifications to code but can automatically generate test data for input variables and expected output data from pre- and post-conditions (Chen and Liu, 1996, Liu, 1999a). Although this work has set up an important foundation for building a more useful technique for specification animation, no much progress in technical details was made until we undertake the study presented in this paper. The main difference between the specification testing proposed previously and the specification animation proposed in this work is that the latter supports visualized demonstration of both operation behaviors and data characteristics for validation while the former only focuses on the generation of input and output values for an operation to check the consistency of its specification.

As is well known, the animation of software specifications for validation is notoriously difficult, primarily because it requires that humans understand what the animation is demonstrating. Furthermore, animation also faces another technical difficulty due to the fact that logical formulas and expressions often contain nonconstructive and abstract elements. To deal with these challenges, the strategy in our proposed animation technique is to generate comprehensible and representative animation data based on the pre- and post-conditions of an operation to visually demonstrate the relationships between input and output values and the characteristics of the values for the user who is usually interested in the behavior of the system under construction. For the analyst who writes the specification, we choose to animate the process of evaluating designated logical expressions to help him or her confirm whether the expressions are specified as desired.

This paper discusses the specification animation technique in four aspects: (1) how animation data for both input and output of an operation can be automatically generated based on its pre- and post-conditions, (2) how a visualized demonstration of the operation behaviors in terms of the input–output relation can be conducted, (3) how input and output variables of the operation can be confirmed to be properly declared with appropriate types, and (4) how the logical expressions involved in the pre- and post-conditions of the operation can be ensured to be valid.

We have made the following three contributions in this paper:

•
A novel automatic animation data generation technique is proposed.

•
A tool-supported approach to animating operations, data items, and logical expressions is established.

•
An industrial application is conducted to evaluate the proposed animation technique in terms of detecting faults in specifications.

In general, a software system is composed of more than one operation, therefore mistakes may occur in the integration of operations. For this reason, both the integration of operations and each individual operation in formal specifications need to be validated. We have put forward an approach to handling the animation of operation integrations in formal specifications in a previous work (Li and Liu, 2015). On the other hand, in many cases of realistic software engineering projects, a specification is often written as a set of rather independent operations and each operation is specified separately. Integrating the operations into an architecture is often regarded as part of software design rather than specification. This style becomes more and more adopted in the Agile development paradigm where comprehensive documentation is not emphasized. Of course, different schools may have different opinions on this since the Agile paradigm has both advantages and disadvantages. Our position is on the side of the combination of formal specification with the Agile principles under necessary compromises from both sides because our work on the Agile formal engineering methods (Liu, 2018) has shown that such a combination helps enhance both software productivity and quality. In this paper, we only focus on the discussion of the animation of individual operations specified in pre- and post-conditions. As mentioned above, our experience suggests that faults should often be introduced into individual operation specifications due to the difficulty in achieving abstract but precise mathematical expressions with high complexity.

The remainder of the paper is organized as follows. Section 2 briefly describes the goal of specification animation. Section 3 discusses the issues in relation to animation data generation. Section 4 presents a series of algorithms for generating animation data from various logical expressions in formal specifications. Section 5 focuses on a supporting tool we have built for our animation approach. Section 6 presents an industrial application of our technique to confirm its feasibility and effectiveness. Section 7 reviews related work and compare our work with existing work. Finally, in Section 8, we conclude the paper and discuss the future research topics.

2. Goal of specification animation
Given an operation specification in pre- and post-conditions, the goal of the specification animation is to analyze and confirm the functionality of the operation defined in the specification, the characteristics of the related data items, and the meaning of the formal expressions involved in the formal specification through visualized demonstrations.

2.1. Key issues
Since the determination of whether a specification meets the user’s requirements usually needs human judgment, one of the key issues to be addressed is what aspects of the specification needs to be visually demonstrated so that the user would feel easy to make correct judgments. On the basis of our long-term experience in collaborating with industry, we have realized that visualized demonstration of the input–output relation, the characteristics of the data items involved, and the meaning of the formal expressions in the specification can significantly help the user comprehend what the operation is intended to do and understand whether they are desirable.

Another key issue is what animation data need to be used and how they can be generated. Our essential idea is that the animation data must allow the user to check all of the important functional scenarios (similar to the concept of use cases in UML but with more precise and detailed contents) and must be generated based on the formal specification of the operation. The technical details of generating animation data will be discussed in Section 3.

The final key issue is how to comprehensibly represent the three aspects of the operation as mentioned above. Since this issue is also related to human judgment, it seems to be extremely difficult to come up with a “magic” solution. Taking the well-known view of graphical representations being more comprehensible than texts (“A picture is worth a thousand words”), we believe that visualized demonstration based on graphical representations can be helpful. The details of this point will be discussed in Section 5.

2.2. Specification language
Although the technical contributions of this paper are generally independent of specification languages in which the operation specification is written, we still need a specific language as the vehicle to represent our discussions. In this work, we choose SOFL (Structured Object-Oriented Formal Language) (Liu et al., 1998c, Liu, 2004) partly because of our expertise in SOFL and partly because a process specification in SOFL shares the same concept and style as an operation specification in the well-known formal notations (e.g., VDM, B-Method). Therefore, our discussions in this paper can also be applicable to existing similar formal notations.

A process in SOFL models a transformation from input to output (Liu, 2004). It is similar to an operation in VDM but has a more general structure to allow multiple input and output ports. This structure enables a process to be used flexibly for abstraction in modeling systems. This point will become clearer as the discussion on the structure of a process and its specification progresses.

A process is represented in both graphical and textual formats that are complementary for understanding. For instance, Fig. 1 shows a graphical representation of a process named  in a railway card system we have specified in our previous project (Liu, 1999b). For the purpose of explaining the basic concepts involved in our discussions, we have simplified the original version of the process specification to the extent that we believe ensures a good understandability.

The process has two input ports represented by the two small narrow rectangles on the left side of the graphical representation, and two output ports represented by the two small narrow rectangles on the right side. The upper input port receives one input data flow , representing the amount of input cash, while the lower input port receives three input data flows  (the amount to be charged to the  from the customer’s bank account),  (the password supplied by the customer for accessing to his or her bank account), and  (the account number provided by the customer).

One important feature of the process is that all of the input ports (or all of the output ports) are  in terms of using their input data flows (or producing their output data flows). There are some rules defined in the SOFL language for writing pre- and post-conditions of a process with multiple input/output ports. These rules disallow the data flow variables of different ports to join the same conjunction. Such a rule is enforced through a consistency checking supported by a tool developed in our another project before (Liu et al., 2010). For example, the process  is intended to charge the railway card either by cash or through the customer’s bank account, but not both. The railway card is denoted by the data store named  and the customer’s bank account is represented by another data store named . Each store is assigned a number such as 1 or 2 for reference purpose in communication between the developers. The process is connected to the two stores in a way that they can be updated by the process. If the  becomes available (i.e., is supplied), the process takes it as input and adds it to the balance of the . If the  is not available but the , , and  are all available, the process accepts them as input and properly updates the  and the , according to different conditions these three arguments satisfy. The details of the conditions and the corresponding updating of the two data stores are given in the formal specification of the process as shown below.

,

,

ext wr   

/*a sequence of 9 digits chosen from 0 to 9*/

/*a sequence of 6 digits chosen from 0 to 9 */

pre   

post 

, ) 

, ) 

, ) 

  ”

) 

     ”

end_process;

In the signature of the process, the declarations of data flows of different input (or output) ports are separated using the vertical bar . For instance, the declaration of the input data flow  is separated from that of the input data flows , , and . The data store variables  and  are declared as writable external variables (similar to global variables), which is indicated by the keyword wr (write) after ext (external). Each of the two stores is defined as an object of the corresponding composite type with several fields as shown in the specification. The pre-condition of the process requires that the related input be greater than or equal to 0 when they are ready for use by the process. The post-condition defines how the  and  are updated by charging the card with cash and through transfer from the bank account, respectively. In the latter case, the situation where the customer’s input data are acceptable and the situation where the input data are unacceptable are specified separately. Note that a decorated store variable in the post-condition, such as , is used to represent the initial value of the variable before the process while the undecorated store variable,  for example, is used to denote the updated value of the variable after the process.

On the basis of this example, we give a general definition of a process next.

Definition 1

A process is a six-tuple (, , , , , ), where  is the process name,  a collection of the input variable sets,  a collection of the output variable sets,  a set of the external variables including both decorated and undecorated external variables (if any),  the pre-condition, and  the post-condition of the process.

For instance, all of the elements of the process  are as follows:


{,
{,
}}
{,
}
{, ,
, }
the same as given above
the same as given above
It is worth mentioning that a process in SOFL specifications can be decomposed into a formalized data flow diagram known as Condition Data Flow Diagram (CDFD) together with its associated module, in order to deal with the specification of complex and/or large scale systems (Liu, 2004). The process and its decomposition are required to be kept consistent to ensure that the behaviors defined by the decomposed CDFD and its module must satisfy the specification of the process. Such a consistency is well defined and can be verified through rigorous inspection as discussed in our previous work (Liu et al., 2010). Since our work presented in this paper focuses on the validation of a single process, we do not extend our discussion to the issue concerned with process decomposition.

2.3. Process specification animation
As mentioned previously, a process specification animation aims to check and confirm whether the specification is desirable with respect to the user’s requirements and the analyst’s understanding through visualized demonstrations of the input–output relation of the process, the characteristics of the related input/output data items, and the meaning of formal expressions written in the specification, using selected sample data. The procedure of carrying out an animation in our method usually takes two steps, as illustrated in Fig. 2. The first step is animation data generation and the second is visualized demonstration.

Animation data generation is aimed at selecting representative values for all of the variables involved in the specification, including input variables, output variables, and external variables (like state variables used in other formal notation). This point is similar to test data generation in program testing where both the input values and expected output values are usually prepared in advance, but the difference is that in program testing, the expected output values are not used for executing the program (although they are used for test result analysis) while the output values generated for specification animation must be used during the animation process, see more detailed discussions in Section 3.


Download : Download high-res image (102KB)
Download : Download full-size image
Fig. 2. Process specification animation procedure.

Animation data must be generated based on the formal specification of the process. The generation from the formal specification is similar to white-box testing for programs; it must take the structure of the specification into account in order to achieve desirable functional coverage for validation. A process in the SOFL language may have multiple input ports that accept input data non-deterministically. Precisely speaking, only one input port can accept the input data for one execution of the process, but which one of the input ports will be used to execute the process is non-deterministic. This special structure may affect the evaluation of the precondition of the process and will have to be taken into account when animation data are generated, which is discussed in detail in Section 3. The activity of animation data generation may lead to the identification of faults because the process of generating animation data inevitably “force” the generator (either human or machine) to scrutinize the formal specification. That is, animation data generation can play the role of inspecting the specification in addition to preparing data for visualized demonstration.

Visualized demonstration for specification animation aims to demonstrate the three aspects of a process in a visualized fashion in order to facilitate both the analyst (who wrote the specification) and the user to check whether the potential behaviors of the process are desirable.

It is worth mentioning that our animation approach is intended to offer a facility for the analyst and the user to work together to identify faults and confirm the validity of the specification. Since the technique is a testing-based approach with visualized demonstration and its effect is dependent on human judgment, its application would be difficult to guarantee the correctness of the specification or any desirable efficiency in finding faults. As indicated by the three criteria for animation data generation given in the next section, our approach suggests a minimum level of animation with the selected animation data, which is to ensure at least one animation for every desired functional scenario defined in the specification. Even if this validation does not help find all of the potential faults in the specification, it can strengthen the communication between the analyst and the user. It can also enhance the confidence of the user in the validity of the specification.

3. Animation data generation from specifications
We first discuss the structure of a process specification and then proceed to describe the criteria for animation data generation based on the structure.

3.1. Functional scenarios
We assume that the pre- and post-conditions of any given process specification is in a disjunctive normal form.

Definition 2

Let  and  be both a disjunctive normal form. Then, we call a conjunction  ( ) a functional scenario.

We treat the conjunction  as a functional scenario because it defines an independent function: when  is satisfied by the input variables and the initial external variables, the output variables and the final external variables will be defined by . As highlighted in previous section, since process  may have multiple input and output ports, such a functional scenario may not define an acceptable functional scenario in the sense that the selected input data will lead to the corresponding output result. For this reason, we need to define the notion of acceptable functional scenario next.

Definition 3

Let  be a functional scenario of process . Then,  is said acceptable if and only if the following condition holds:  where  denotes the set of free variables occurring in predicate . An acceptable functional scenario  is expected to ensure that the input satisfying  can be used in  to define the output of the process, and therefore requires that  and  do not contain input variables of different input ports due to the exclusiveness of input variables of the different input ports in executing process .

Let us take the process  as an example to illustrate the notions defined above. The relevant parts of the process are given as follows:


Functional scenarios	:	(1)	
(2)	
(3)	
(4)	
(5)	
(6)	
(7)	
(8)	
(9)	
(10)	
Acceptable functional			
scenarios	:	(1)	
(2)	
(3)	
(4)	
(5)	
Definition 4

We use 
 to denote the set of all possible functional scenarios of process  and 
 the set of all possible acceptable functional scenarios of process .

3.2. Animation data generation criteria
Before discussing the criteria for animation data generation, we first need to clarify the basic concepts animation data and animation set because they are easy to be confused with the notions of test data and test set used in the literature on software testing.

Definition 5

Let  be a process. Let 
, 
, 
. Then, an animation data for , denoted by , is a mapping from 
 to the set : 
 where 
and 
where  denotes the type of variable  and 
 the union of all of the input variables, the output variables, and the external variables, and  represents the union of all the types of these variables. Note that this definition only explains what an animation data means; it is not used as an animation data generation criterion for our purpose. Animation criteria will be discussed later in this section.

Abstractly speaking, an animation data for an operation is one pair of input and output values. Since an operation usually has more than one input (and output) variable, the input value actually means a set of values for all the input variables, and likewise for the output value. An animation data is usually expressed as a set of pairs of variable with its value, for example, 
 is a possible animation data for process , where 
 denotes an input variable, 
 the initial external variable of a wr (writable) external variable , and 
 an output variable.

To facilitate our discussions in the rest of this paper, we divide an animation data  into two parts: (1) input animation data 
, which contains values only for the input variables and the initial external variables (e.g., 
), and (2) output animation data 
, which contains values only for the output variables and the final external variables (e.g., 
). Such a distinction between input and output animation data will allow us to easily describe the input–output relation for a process in a visualized demonstration as detailed in Section 5.

Definition 6

An animation set for process  is a set of animation data for process .

We can now define criteria for generating an animation set from a process specification. Each criterion provides a guideline for generating adequate animation set. These criteria are intended to be checked by the tool described in Section 5 when the animation set is produced.

Criterion 1

Let  be an animation set generated from the specification of process . Then,  must satisfy the following conditions:

(1) 

(2) 

(3) 


where  denotes the value bound for variable  in animation data  and  means that  satisfies the functional scenario .

Condition  states that for every input variable set  there exists an animation data  in the generated animation set  such that if  contains a value for every input variable in ,  must satisfy an acceptable functional scenario . Condition  states that for every output variable set  there exists an animation data  in  such that if  contains a value for every output variable in ,  must satisfy an acceptable functional scenario . Condition  describes that for every initial external variable 
 and final external variable  there exists an animation data in  such that if  contains a value for 
 and ,  must satisfy an acceptable functional scenario .

This criterion is the least but essential requirement for generating adequate animation set . Intuitively, it requires that for all of the variables of every input port and output port, an animation data that satisfies some acceptable functional scenario must be generated for animation. It also requires that for all initial and final external variables an animation data satisfying some acceptable functional scenario must be generated. Thus, the criterion ensures that all of the variable groups involved in the process specification are animated at least once, respectively.

Note that if no input could be produced to satisfy the pre-condition of process , then animation of process  will not be conducted. This, however, does not necessarily mean that the process specification is semantically wrong, but indicates that the process cannot be properly used in the system. Another possibility is that when an input is successfully generated to satisfy the pre-condition, no corresponding output can be produced to satisfy the post-condition of the process. In this case, no successful animation data is generated, which might indicate a potential fault in the post-condition. Humans involved must check the specification to decide the root of the problem and what to do with it.

For instance, an animation set containing the following two animation data for process  satisfies this criterion:


{,
(  ”),
,
,
(
,
),
(,
)}
{,
,
(
{(  ”),
(,
)}

{,
,
,
(, “   ”),
,
(
,
),
,
(,
)}
{,
,
},
,
(
{(   ”),
,
(
Using these two animation data, we can perform two animations of the process . One is a visualized demonstration of the action of inputting  and producing the output   ” and updating the balance of the store  but keeping the  unchanged. Fig. 3 shows the resultant state of the animation.

Another is a visualized demonstration of providing the inputs , , and , and producing the output    ” without updating any of the stores  and . The resultant state of this animation is illustrated in Fig. 4.


Download : Download high-res image (170KB)
Download : Download full-size image
Fig. 3. Animation of Charge_Card with animation data.

Due to the fact that the input ports or output ports do not have a one-to-one relation with the acceptable functional scenarios derived from the pre- and post-conditions, this criterion apparently does not ensure that every acceptable functional scenario is animated. For this reason, we form another criterion.


Download : Download high-res image (175KB)
Download : Download full-size image
Fig. 4. Animation of Charge Card with data 
.

Criterion 2

Let  be an animation set generated from the specification of process  that satisfies Criterion 1. Then,  must satisfy the following condition: 

Intuitively, this criterion requires that every acceptable functional scenario be animated with at least one animation data in animation set  to check its validity. This is reasonable because every acceptable functional scenario is expected to define a desirable behavior of the process with respect to the user’s requirements.

However, due to the possibility of human mistakes, some of the unacceptable functional scenarios of the process might be improperly defined (e.g., using wrong terms or operators defined on types). For this reason, we define another criterion to allow every possible functional scenario to be animated at least once.

Criterion 3

Let  be an animation set generated from the specification of process  that satisfies Criterion 2. Then,  must satisfy the following condition: 

This criterion allows to cover all of the functional scenarios in animation for different purposes. For the acceptable functional scenarios, animation is intended to check its validity, but for the unacceptable functional scenarios, animation is usually intended to confirm that they are indeed undesirable behaviors. This is similar to program testing where normal inputs are used to confirm whether the expected behavior of the program is provided correctly but some exceptional inputs may also be used to check whether the program properly deals with the situation, for example, by issuing an error message. The difference is that in the case of program testing, the program needs to give an appropriate response but in the case of specification animation, the humans (e.g., the developer or the user or both) need to interpret and determine the nature of the situation. Note that it is possible to generate an animation data involving input variables of different input ports that satisfies an unacceptable functional scenario because all of the input variables involved can be assigned a specific value from its type that satisfies the conditions of the functional scenario. However, in this case, since the exclusiveness of different input ports, as part of the actual pre-condition of the process, is violated, even if the functional scenario is satisfied, it has nothing to do with the correctness of the specification, but may provide a chance to let the analyst think about this exceptional case. Perhaps he or she may realize that putting some of the involved input variables into different input ports is a mistake through this animation, and therefore correct the mistake by changing the structure of the process and its specification.

4. Animation data generation algorithms
To validate a process using animation, we must carry out an animation for every acceptable functional scenario of the process in order to ensure that each potentially valid functional behavior is demonstrated at least once. To this end, animation data generation must focus on each individual functional scenario 
 where 
 only contains input variables whilst 
 contains output variables (possibly input variables as well). Apparently, as long as we generate an animation data satisfying this functional scenario, we can use the animation data to demonstrate the input–output relation of the process for validation. The demonstration of the input–output relation can be visualized with a tool support, as discussed later in Section 5.

Since each functional scenario 
 is a conjunction of atomic predicates where each atomic predicate is a relation or its negation, generation of animation data to satisfy the scenario must involve the animation data generation for atomic predicates and their conjunction, respectively. For this reason, we first discuss animation data generation from atomic predicates and then extend it to generation from conjunctions.

4.1. Animation data generation from atomic predicates
For the sake of simplicity in the discussions below, we represent the scenario 
 as the conjunction: 
, where each 
, 
, , 
)  denotes an atomic predicate. The variables 
, 
, , 
 are free variables, which can be either input variables or output variables of the related process, but may be part of all the free variables 
, 
, , 
 used in the whole conjunction, where . A variable can denote either a numeric value or a value of compound type (e.g., set, sequence, map, or composite type) that is available in many of the model-based formal notations, such as VDM-SL, Z, and SOFL (Liu, 2004), although their syntax may differ slightly. We start discussing the case of atomic predicates with only numeric variables, and then extend the discussion to predicates with variables of compound types.

4.1.1. Numeric type variables
An atomic predicate usually takes the format 
 where 
 and 
 are both algebraic expressions possibly involving all the free variables 
, 
, , 
, and , , , , , } is a relational operator. An algorithm to generate an animation data satisfying the predicate takes the following steps:

Step 1:
Randomly generate a value 
 for each variable 
  within its type and substitute the value for the variable in 
;

Step 2:
Convert 
 into an equivalent predicate 
 according to algebraic laws, where  is an constant;

Step 3:
Generate a value 
 for 
 such that 
 holds;

Step 4:
Treat 
 as an animation data.

Although this algorithm is rather straightforward, an example will help the reader comprehend its essential idea even better. Consider the atomic predicate . The steps taken to generate an animation data to satisfy the predicate are as follows:

Step 1:
Randomly generate values for  and , such as  and . Thus, we obtain .

Step 2:
Convert  into the equivalent predicate .

Step 3:
Generate a value  for .

Step 4:
Treat , , and  for , , and , respectively, as an animation data that satisfies .

4.1.2. Compound type variables
The above algorithms cannot directly handle variables of compound data types due to the possible use of the operators defined on those types. Since the essential idea for handling operations for all kinds of compound types is similar, we only choose the map type in SOFL as an example to discuss the algorithms for animation data generation. The algorithms for dealing with the other compound types in the SOFL language, such as set types, sequence types, and composite types, have been discussed in our previous publication (Liu and Nakajima, 2010).

A map is a mathematical function, describing a finite association between the domain and the range of the map. It is usually represented by a set of pairs, such as 
, 
, …, 
}. In each pair 
 , 
 and 
 are called domain element and range element of the pair, respectively. There are several operators defined on map types, such as  (domain),  (range),  ,  (domain restriction to),  (range restriction to),  (domain restriction by),  (range restriction by),  (map override),  (map inverse),  (map composition),  (equality) and  (inequality). Let , 
 and 
 be a map, respectively, from  to , then, all of the operators are interpreted as follows:

•
: the domain of map .

•
: the range of map .

•
: the range element associated with domain element  in .

•
: the sub-map of  that contains all of the pairs whose domain element falls into set .

•
: the sub-map of  that contains all of the pairs whose range element falls into set .

•
: the sub-map of  that contains all of the pairs whose domain element does not fall into set .

•
: the sub-map of  that contains all of the pairs whose range element does not fall into set .

•
: the map obtained by taking all of the pairs in 
 and all of the pairs in 
 whose domain element is not the same as that of any pairs in 
.

•
: the map obtained by exchanging the domain element with the range element of all the pairs in . This can be applied only when  defines a one-to-one association from the domain to the range.

•
: the map obtained by composing map 
 and 
.

•
: evaluates to true if 
 is the same as 
; otherwise, evaluates to false.

•
: evaluates to true if 
 is different from 
; otherwise, evaluates to false.

Table 1, Table 2 describe our proposed algorithms to generate animation data for maps , 
, and 
 from the relevant expressions involving the operators just mentioned above. In the tables, we use ≔ to mean that  is generated as , where  can be any appropriate expression.

It is worth mentioning that the algorithms in Table 1, Table 2 only show one possibility in animation data generation. There are many other possibilities for the generation algorithms. It is important for the developer in charge of the specification animation to take a flexible approach in adopting data generation algorithms based on our proposals.


Table 1. Algorithms for animation data generation from map type expressions.

No.	Expressions	Algorithms for animation data generation
(1)		≔
assuming 
and 
 
(2)		≔
assuming 
and 
 
(3)	
≔
(4)	
≔
assuming 
and 
(5)	
≔
assuming 
and 
(6)	
≔
assuming 
and 

Table 2. Table caption.

No.	Expressions	Algorithms for animation data generation
(7)	
≔
assuming 
and 
(8)	
≔
assuming 
(9)	
≔
≔
assuming 
  and
(10)	
≔
≔
(11)	
≔
≔
where 
4.2. Generation from conjunctions
We can now focus on animation data generation from the conjunction 
.

4.2.1. Simple algorithm
A simple algorithm for the purpose is first to generate an animation data satisfying one of the atomic predicates, say 
 , and then use the same animation data to evaluate the rest predicates in the conjunction. If it also satisfies all of the rest predicates, a qualified animation data for the conjunction is found; otherwise, another attempt to generate a new animation data must be made to repeat the same process. However, our experience suggests that this algorithm may not be efficient in many situations.

Existing SAT solvers, such as RISS (Manthey, 2012), may be used for animation data generation for a conjunction, but since the SAT solver only deals with propositional logic, its capability is limited for our formal notation that adopts first-order predicate logic with rich data types. Existing SMT solvers, such as Yices (Dutertre, 2014) and Z3 (Moura and Bjorner, 2008), can be a better possibility for the solution due to their capability of dealing with predicate logic. However, in the SOFL language, an expression may involve operators defined on some types (e.g., set, sequence, map types), and those operators (e.g., ) are not directly dealt with by the SAT or SMT solver. We have tried hard to adopt Z3 for the generation of animation data in our work, but could not succeed because of its limitation in dealing with many operators defined on compound data types in the SOFL language. To overcome this difficulty, we propose a more efficient algorithm than the simple one described above for animation data generation from a logical conjunction.

4.2.2. More efficient algorithm
In this section, we describe an algorithm for generating animation data from a conjunction that is more efficient than the simple algorithm mentioned above. The essential idea of the algorithm is first to form an ordered partition of the atomic predicate set {
, 
, , 
} according to variable dependency, and then properly apply the simple algorithm mentioned above to generate a qualified animation set for the conjunction if it is satisfiable. Before introducing the details of the algorithm, we first need to introduce the notions to be used in the algorithm below.

Definition 7

If predicate 
 contains more free variables than predicate 
, denoted by 
 where 
 denotes the set of all free variables occurring in expression 
, then we say that 
 is dependent on 
, represented by 
.

For example, predicate  is dependent on ; that is, , because the former contains three variables , , and  whilst the latter contains two variables  and .

Definition 8

The set of predicate sets {
, 
, , 
} is an ordered set of predicate sets on  if it satisfies the following two conditions:

(1) 
 where ,

(2) No predicate in any of the predicate sets is dependent on another predicate in the same predicate set.

In this definition, 
 means that any predicate in 
 is dependent on every predicate in 
.

Definition 9

An animation data  is said to satisfy a predicate set  if it satisfies every predicate in .

Algorithm 4.2.1

/*Java-based pseudocode*/

No. 1
Construct a partition {
, 
, , 
} for the conjunction 
  such that {
, 
, , 
} forms an ordered set of predicate sets on ;

No. 2
≔; ≔; ≔; /*initializing variable 
 representing the initial animation data*/

No. 3
 (     ) {

≔ 
;

 is an array of predicates*/

≔ ;

 is a new animation data generated based on the predicates in */

 

≔≔

 ≔


No.4
 (  ) {Display an animation data generation failure message}

 {Display an animation data generation success message and 

}

No. 5
End.

This algorithm aims to produce an animation data that satisfies all of the predicates in 
  and then utilize the values in the animation data to generate a more complete animation data for 
. Repeat this process until 
 is reached and a qualified animation data is generated. However, if the generation fails for 
, it will go one step back to retry generating an animation data for 
 and then repeat the same process until reaching the level that causes the problem. But if the number of failures to generate the qualified animation data satisfying all 
, 
, , 
 reaches the pre-defined number denoted by , or no animation data can be generated for 
, a failure message will be issued as the result of the algorithm.

In the algorithm, the function 
, 
) obtains an array  whose elements are the atomic predicates resulting from substituting the value of every variable in animation data 
 for the same variable in the atomic predicates in 
. For instance, suppose

, , containing two predicates and

, and the animation data for 
 is

. Then, we get  from 
 as follows:

, }.

To generate an animation data for 
 based on , we need to apply the function . The animation data generated from this function is actually a more complete one than 
 that satisfies all of the atomic predicates in . Assume that array  has  atomic predicates as its elements, we give an algorithm used to implement the function  below.

Algorithm 4.2.2

/* Java-based pseudocode*/

satisfyingConjunction≔

 ( ≔){

≔ 

≔

 (  Satisfy
){

≔


 

≔

 {satisfyingConjunction ≔

}


 ( ) {



 

This algorithm first tries to generate an animation data satisfying the last atomic predicate of  and then to test whether it satisfies all of the other atomic predicates in . If yes, a successful animation data is generated; otherwise, repeat the same process for the other atomic predicates in  until all of the atomic predicates of  is exhausted. In this algorithm, the function  produces an animation data as the result that satisfies the ith atomic predicate in . Satisfy
 yields true if animation data 
 satisfies ; otherwise it yields false.  yields a permutation of  by moving the last element of  to the first position and all of the other elements are shifted one position to the right in .


Download : Download high-res image (271KB)
Download : Download full-size image
Fig. 5. Snapshot of the animation of process .

Note that the algorithms for generating animation data above work well generally, but no guarantee can be given to ensure that an animation data satisfying the conjunction will always be found or will always be efficiently found. If the generation of an animation data is unsuccessful, human must check and determine whether there exists any data satisfying the conjunction.

5. Animation tool
We have developed a prototype tool to support the animation of a process specification. In addition to supporting animation data generation based on the criteria and algorithms discussed above, the tool mainly offers three animation functions: (1) input–output relation animation, (2) data animation, and (3) logical expression animation. The tool is developed using C# in the Visual Studio 2012 environment.

5.1. Input–output relation animation
An important step in process specification animation is visualized demonstration of the input–output relation defined in the process specification. To enable the demonstration to effectively help humans (analyst or user or both) make judgments on the validity of the specification, our tool supports the input–output relation demonstration.

Before demonstrating the input–output relation of the process, the tool facilitates the user to choose a functional scenario and allows animation data to be generated both automatically and manually. Once an animation data is made available, by clicking on the right button, the tool will start to show how the selected input data flows are used to produce the expected output data flows. If data stores are connected to the process under animation, the access or updating of the stores is also properly demonstrated. To attract the user’s attention, the tool may choose different colors to represent the input and output data flows, respectively.

Fig. 5 shows a snapshot of visualized demonstration of the process . The process is represented graphically in the middle pane of the GUI and its formal specification is given in the right pane. When the input data flow  is selected, its animation data can be automatically generated and presented in the area below the pane. The animation data can also be provided by the user if such an option is chosen. When the arrow button at the left-bottom of the middle pane is clicked, a visualized demonstration of the behavior of updating the store  and producing the value of the output data flow variable  (i.e., “Charge is successful!”) from the value of the input data flow variable  will be performed comprehensibly. The visualized demonstration can be done either completely automatically or step by step with the user’s operation.

5.2. Data animation
When performing animations for a process, the user (or client) might not understand the characteristics of the input or output data, especially when the data structure is complex, such as a set, sequence, composite object, or map. To help the user learn about the data, data animation is provided by a sub-system of the tool with the aim of explaining the characteristics of the data in a comprehensible manner.

For example, when the selected data is a set of natural numbers, the data animation will display a moving pictures of showing the following three things: (1) each element of the set is represented by a “ball” and all of the elements are being put into a “container” (representing the set), as illustrated by the snapshot of the tool in Fig. 6, (2) the order of the elements occurring in the set is not important, and (3) no element duplication is allowed in the set. For item (2), the tool shows dynamic changes of the position of some elements in the container, and for item (3), the tool automatically generates a small set of elements of the same type and shows that the elements, one by one, can be put into the container if it is not a member of the selected set, or cannot be put into the container if it is already a member of the set. The snapshot of the tool in Fig. 7 shows one scene of the animation process.

Moreover, to help the user more efficiently understand the nature of the set, the tool also offers voice explanation (i.e., speak loudly) of the above three things as the animation is performing. This function is implemented by utilizing the Microsoft SpeechLib package that provides sufficient classes and methods to transform texts into voice reading the text out loud. The voice description together with the moving animation produces the similar effect to that of reading with listening in English study as a non-native speaker or that of listening to the voice instruction from a car navigation system in driving. Unfortunately, despite the fact that the voice feature is consistent with the general principle of enhancing human understanding in software engineering, its effect is extremely difficult, if not impossible, to measure due to the uncertain character of human judgment.

The animation actions are implemented using the System.Drawing and System.Threading packages available in the Visual Studio 2012 environment. The voice description is automatically generated for the selected data type.


Table 3. The summary of data animation.

Type	Characteristics
Set types	(1) The order of element occurrence is not important.
(2) No element duplication is allowed.
Sequence types	(1) The position of element occurrence is significant.
(2) Element duplication is possible.
Composite types	(1) An object can have multiple fields possibly with different types.
Map types	(1) For any one element in the domain, there is at most one associated element in the range.
(2) Both the domain and the range are finite.
5.3. Logical expression animation
Our experience with industrial collaboration suggests that the analyst and/or the user sometimes may be interested in some predicate expressions or individual operators defined on some data types (e.g., set types, map types) during a process specification animation. To help them check the appropriateness of the predicate expressions or individual operators, the tool also supports animations of predicate expressions and the most frequently used but perhaps complicated operators defined on all of the four compound types mentioned in Table 3. The question is how to perform the animation of a predicate expression to allow the user to easily comprehend its meaning.

The animation of logical expressions can be done at two levels. One is for a functional scenario form (FSF), which is a disjunction of functional scenarios, of the process under consideration and the other is for a single atomic predicate or even a single operator defined in the SOFL language.

The animation of an FSF is carried out in two steps. The first step is to convert the FSF into a finite state machine, and the second step is to evaluate the states along the transitions between the states using animation data. In the finite state machine, each state represents an atomic predicate involved in some functional scenario and the transition from one state to another denotes the logical operator “and”. Therefore, each functional scenario is represented by a sequence of state transitions from the start state to an end state. This sequence actually represents graphically the sequential steps of evaluating the atomic predicates involved in the corresponding functional scenario. For this reason, by demonstrating the sequential steps, we will be able to see how each functional scenario is actually evaluated to true or false with a successful animation data and a failed animation data, respectively. Thus, the contents of each functional scenario can be analyzed by the developer in a relatively comprehensible manner. The whole state machine is described as a set of sequences of state transitions from the start state to the end states. For example, suppose a functional scenario form (FSF) is  and each atomic predicate (e.g., , , ) involves three free integer variables , , and . Then, a finite state machine for this FSF is constructed as shown in Fig. 8, where  denotes the start state and  denotes the end state. An animation of a functional scenario in this FSF starts from the start state  and go through one of the transition sequence of the three transition sequences shown in the figure to reach the end state . Each transition from state  to state , for example, means that the atomic predicate  evaluates to true and the next evaluation will be the atomic predicate .

As far as the animation of an atomic predicate is concerned, our focus is on the explanation of its meaning in a comprehensible manner. Let us use the atomic predicate    as an example to explain how the animation is performed, where  denotes a value in the natural number type  (including zero) and  is a subset of . This predicate evaluates to true if  is a member of set ; otherwise, it evaluates to false. To perform the animation, the tool first requests the user of the tool to select the type of  and to supply specific values for  and , respectively. Then, the tool will automatically display three things in turn: (1) the process of all of the set elements being put into a container, (2) the atomic predicate with specific values for  and , and (3) the confirmation whether the value for  is a member of the set and the evaluation result of the predicate is consistent with the confirmation result. Fig. 9 shows the snapshot of a scene in the predicate animation.


Download : Download high-res image (122KB)
Download : Download full-size image
Fig. 8. An illustration of animation for an FSF.

As far as animation for individual operators is concerned, we have also provided comprehensible animation for other operators adopted in SOFL. Table 4 gives a summary of animation of all of the individual operators defined on various compound data types in SOFL. The important thing of our work here is to show the essential idea of whether and how animation can be conducted, which can be applied or extended to deal with animation of similar formal notations.


Download : Download high-res image (117KB)
Download : Download full-size image
Fig. 9. Snapshot of logical expression animation.

In fact, our experience suggests that doing animation for validation of a formal model be actually a process of “educating” the humans (e.g., the end user or the analyst) what the model does and what kind of data are used. Only after the humans get a precise understanding of the features of the data and the logical expressions involved, they can make a fair judgment on what is correctly built and what is not with respect to their desires. Apparently, if the humans are well trained in the formal notation, they may benefit less from the tool than those who are unfamiliar with the formal notation.


Table 4. Operators defined on data types in SOFL.

Type	Atomic predicate	Meaning
or Operator	
Set	  	membership
type	  	non-membership
cardinality
union
intersection
diff	difference
subset
proper subset
power set
Sequence		head
type		tail
length
element set
index set
sequence
application
concatenation
Composite		selecting field
type		field modification
Map		map application
type		domain of 
rang of 
domain
restriction to
rang
restriction to
composition
override
6. Application in practice
As is well-known, conducting a credible experiment for evaluation of software engineering techniques is notoriously difficult due to the fact that many uncertain factors may prevent us from setting up a context in which our method is comparable with any other method. For this reason, we do not believe that using controlled experiments is definitely a credible way to evaluate software engineering techniques within a limited resources (e.g., time, budget, subjects), especially when human operations and judgments are involved. Instead, we believe that as long as a technique like ours is confirmed to be effective in practice by some practitioners, even in a single company, the result will be valuable in the sense that it indicates a high possibility that the technique may also be applicable to other software systems by other practitioners in the future. This idea seems to be consistent with that of trial experiment and comparison experiment described in Tedre and Moisseinen (2014). To this end, we have applied our animation technique to an Automated Train Protection (ATP) software development project for a railway signal company in China. ATP software is one of the kernel components of railway transportation system, which performs speed control functionality of a train. As a typical safety-critical system, the ATP software requirements must be carefully validated to let ATP users confirm whether their perceptions are completely and correctly defined in the formal specification.

6.1. Application procedure
We applied our method to animate the formal specification of the ATP software system for validation. The formal specification was composed of 417 processes and constructed by the requirements analysts of the company using the SOFL language. We generate animation data using our method and then carry out the animation for all the processes in the specification.

Before applying our method, two experienced requirements engineers in the company were asked to manually review the specification. These two engineers joined our study by serving as the end-user of the system to help judge whether each animation finds defects in the specification. Thus, the two engineers can tell us the difference between the defects found by the animation and those found by the previous review.

We took three steps to complete our animation. Firstly, we performed the animation of the functionality of the processes involved. During this animation, the focus is put on the analysis of the input–output relationships. Secondly, we carry out data animation for variables of compound types (e.g., set types, sequence types, map types) identified in the specifications of the processes. Since variables of basic types (e.g., numeric types) are easy to comprehend, we did not carry out the animation for them. Finally, we performed the animation of the complex logical expressions extracted from the specifications of the processes. The simple logical expressions are not chosen for animation since they can be easily checked by a simple review.

6.2. Results of application
Table 5 shows the result of applying our animation method to check the functionality of all 417 processes and the 252 data items of compound types and the 33 complex logical expressions extracted from the process specifications. In comparison, the table also shows the result of reviewing all the process specifications and the corresponding data items and logical expressions.

The result of the study shows a considerable effectiveness of our animation approach in comparison with the specification review in terms of fault detection. Supported by the animation tool, the requirements analysts found 122 faults (29 function-related faults, 26 data-related faults, and 67 logic-related faults) in the formal specification within 80 h in 10 working days. In comparison with the effect of the specification review conducted before the animation, our animation approach finds 24 more function-related faults, 19 more data-related faults, and 52 more logic-related faults than the review approach, and saves approximately 120 h time. It is confirmed that all of the faults found by the review are identified by the animation, but it is not necessarily true the other way round. Moreover, since the animation was done with the tool support and the review was done manually without a specialized tool support, the animation took much less time than the review.


Table 5. The results of animation and review.

Methods	Objects of	Detected	Time
validation	faults	consumed
Animation	Functionality	29	80 h
Data items	26	
Logical expressions	67	
Review	Functionality	5	200 h
Data items	7	
Logical expressions	15	
We could also get more reliable feedback from the engineers about the effect of the visualization and voice explanation of our animation technique if more engineers could be used. But unfortunately, this could not be done due to the constraints on the resources. We will try to conduct more mature empirical studies in the future when necessary resources become available.

6.3. Limitations
Through the application of the tool-supported approach in practice, we have also found some limitations. The first one lies in the subjective evaluation of the validity of the specification. Although the animation can intuitively show the system functionality, determining whether the specification conforms to the user’s intention, to some extent, still depends on human’s experience and understanding of the requirements and domain knowledge. Therefore, some faults that are related to domain knowledge may not be effectively detected by the tool. The second major limitation lies in the construction of formal specification. The animation requires precise definition of data types and functions. That is, to use the tool-supported animation approach, formal specifications need to be constructed. However, in most industrial enterprises, requirements are not fully formalized, rather, they are described in certain informal or semi-formal manner (i.e., the UML). Currently, only in some safety-critical domains, such as the railway control, the aviation and the spacecraft domains, formal specifications are likely to be written. For this reason, the proposed animation technique is currently limited to the applications in these critical domains.

In spite of these limitations, the application of the animation technique in the real industrial project has given us the confidence that it can help engineers improve requirements specifications in practice.

7. Related work
Existing work on specification animation either supports the process of model checking or executing formal specifications by means of translating them into executable code. To the best of our knowledge, no related work supports the same technique proposed in this paper.

One of the early studies on requirements specification animation was done by Kramer and Ng in Kramer and Ng (1988). They built an animator to provide facilities for selecting and executing transactions in order to show the behavior of a particular scenario specified in the requirements specification. Specification animation actions include graphically depicting input–output mappings, controlling the triggering of actions, replaying and interacting with transactions. Oliver and Kent explored the technique for animating formal specifications written in Object Constraint Language (OCL) for UML (Oliver and Kent, 1999). The essential idea is to first generate execution paths from the post-condition of an operation, and then evaluate each term on the path, and finally apply invariants to the after-states to produce a set of “solutions”. Gogolla et al. developed an approach for the validation of UML models and OCL constraints based on animation and certification and a software tool, known as USE tool (UML-based Specification Environment), to support the execution of UML models and the checking of OCL constraints (Gogolla et al., 2007). Boanti et al. construct a graphical animator known as AsmetaA to support animation of Abstract State Machines (Bonfanti et al., 2018). The animator can demonstrate the execution of state-based specifications by means of showing a sequence of states using graphical elements, such as tables and colors. The common characteristic of these studies is that the animation of specifications are based on some kind of “action sequence” derived from the specification.

B-Toolkit is an early tool to support both construction and analysis of specifications in B-Method through animation, testing and proof (Bicarregui et al., 1997). ProB for B-Method is another toolset that checks the consistency of B specifications via model checking and also graphically displays the path of state transitions in a counter-example when a violation of the invariant concerned is discovered (Leuschel and Butler, 2003, Leuschel and Butler, 2008). ProB also supports step-by-step animation of B-machines that may involve non-deterministic operations (Leuschel et al., 2014). Specifically, it provides the user with a description of the current state of the machine, the history of the state changes up to the current state, and a list of all the enabled operations along with proper argument instantiations. There are also other tools offering the facilities that can be used for animation of specifications in the B-Method, such as CLPS-B (Bouquet et al., 2002) and the BZ-Testing-Tools (Ambert et al.). ProB is also extended to support refinement animation for Event-B (Hallerstede et al., 2010) to detect a variety of errors that occur frequently during refinement. Mashkoor describes a software tool called Brama to support the animation of Event-B specifications for their validation (Mashkoor, 2011). The animation aims to demonstrate the selected behavioral scenarios each of which represents a sequence of events. The animation of a model can be seen through the variable-view, machine-view, and event-view. The most interesting is the machine graph-view, which shows the animation of all the refinements of the model in one glance. All the refinement levels are animated concurrently. During the animation, Brama finds out whether the related invariant clause has been violated and indicates the violated part of the invariant if the violation occurs. Further development along this line has been made by the Mashkoor and his colleagues to provide a behavior-preserving transformation approach to dealing with the animation of non-animatable formal specifications in Event-B (Mashkoor and Jacquot, 2017, Mashkoor et al., 2017). Non-animatable specifications are heuristically transformed into equivalent animatable specifications for an appropriate animation. Specification animation is used as an auxiliary means to support valid refinement steps as well. Jacquot and Mashkoor discuss the issue of the validation of formal specifications and the related techniques including specification animation (Jacquot and Mashkoor, 2018). Alloy is a formal language for describing structural properties and its tool supports two kinds of analysis: simulation and checking (Jackson, 2002). The simulation is designed to verify the consistency of an invariant or to demonstrate an operation by generating a state or transition. The checking is aimed at testing the consequence of the specification by attempting to generate a counterexample. Another tool that adopts model checking for presenting the dynamic behavior of systems is UPPAAL (Behrmann et al., 2004, Vaandrager, 2011). In this system, the user can model the system behavior in terms of states and transitions between states. The simulator of UPPAAL can explore the state space of the model in a step-by-step fashion. Riccobene reported an approach to animating formal specifications in Parnas’ SCR tabular notation (Gargantini and Riccobene, 2003). One important feature of this work is the adoption of a model checker to help find counter-examples that contain a state not satisfying the property to be established by animation. VDMTools is an industry-strength toolset supporting the analysis of system models expressed in VDM (Fitzgerald et al., 2008), and has been used in some industrial projects (Larsen and Fitzgerald, 2007, Kurita et al., 2008b). A large executable subset of VDM can be executed in VDMTools; and the user can test the VDM specification by providing test cases, and observe the system behavior by setting breakpoints or stepping. Moreover, the interpreter in VDMTools can create an external log file recording all the events that happened in an execution. The time tag of each event is used to graphically display all the events on a time-axis. Overture (Larsen et al., 2010a) provides functions similar to VDMTools, and is built on an open, extensible platform based on the Eclipse framework. Using the combinatorial testing technique (Larsen et al., 2010), a set of test cases can be generated and used to detect errors such as missing pre-condition, violation of invariant or violation of post-condition. Prototype Verification System (PVS) (Owre et al., 1992) is a specification and verification system including an expressive specification language and interactive theorem prover. It offers a ground evaluator that can translate an executable subset of PVS to Lisp (Shankar, 1999). And PVS specifications can be animated by displaying the results of the ground evaluator in the Graphical User Interfaces (GUIs) created by Tcl/Tk (Crow et al., 2001). These animation techniques can be characterized by using formal proof or model checking to verify relevant invariants or properties during the animation process.

There are also studies on specification animation based on Z notation or other specification languages. PiZA (Hewitt et al., 1997) is an animator for Z formal specification. It translates Z specifications into Prolog to generate outputs. Morrey et al. developed a tool called wiZe to support the construction of model-based specifications in Z, and the animation of an executable subset of Z notation (Morrey et al., 1998). The subtool for specification animation is called ZAL. The wiZe is responsible for making a syntactically correct specification and transforming it into an executable representation in an extended Lisp, and then passes the executable representation to ZAL. ZAL animates the specification by executing the specification with test cases. An animation approach for Object-Z Specification is described in Najafi and Haghighi (2011), which simply translates the specification to C++ code for execution. Time Miller and Paul Strooper introduced a framework for animating model-based specifications by using testgraphs (Miller and Strooper, 2003a). The framework provides a testgraph editor for the user to edit testgraphs, and then derive sequences for animation by traversing the testgraph. Stepien and Logrippo built a toolset to translate LOTOS traces to MSC, and provide a graphic animator (Stepien and Logrippo, 2002). The translation is based on the mappings between the elements of LOTOS and MSC. Combes and his colleagues described an open animation tool for telecommunication systems in Combes et al. (2002). The tool is named ANGOR, and it offers an environment based on a flexible architecture. It allows animating different animation sources, such as formal and executable languages like SDL, and scenario languages like MSC. Moreover, our work is also related to studies on formal specification-based testing by sharing some fundamental ideas on test case generation from specifications or models. For example, Mandrioli et al. describe a method and tool for generating test cases from formal specifications written in the extended temporal-logic-based language known as TRIO that is suitable for writing time-related specifications (or properties) for real-time reactive systems (Mandrioli et al., 1995). This work shares the similar idea with our method for generating test cases in the sense that a test case, including both input value and output value, can be generated from a given formal specification, but since TRIO uses temporal logical formulas with simple data types in specifications, the specific algorithms for generating test cases from various logical formulas and their complexity differ considerably from those in our work. Gery et al. also present a UML model-based testing approach in their work on a UML-based software development tool, known as Rhapsody, to support complete model-based iterative life-cycle (Gery et al., 2002). The testing approach features the following steps: (1) specifying tests using scenarios represented by extended sequence diagrams in the model, (2) Rhapsody driving and monitoring the model execution for running tests, (3) reviewing results and pinpoint failures to indicate where the scenario is violated, and (4) fixing the defect and verify by rerunning the test. This approach shares the essential idea of generating tests from specifications in the model with our work, but seems to differ from ours in terms of the way to generate test cases, represent test cases, and run test cases.

Some of the existing studies, such as PVS ground evaluator, wiZe, and SOFL Animator, require an automatic translation from the formal notation into an executable programming language. This approach will inevitably limit the capability of animation because as Hayes and Jones’ study in their publication Hayes and Jones (1989) shows that specifications using pre- and post-conditions are not (necessarily) executable. By contrast, our animation approach described in this paper does not require any translation of the specification into code; it can directly perform animation by evaluating the pre- and post-conditions of the processes involved in the target system scenarios for the selected animation cases and expected results. This approach is much easier to implement technically, and is capable of dealing with all pre-post style specifications. The ProB animator seems to have the similar capability for operation animation as our approach, but does not offer facilities for data animation in the same style as ours. To the best of our knowledge, no existing work offers support for data animation with voice explanation and animation of logical expressions or operators used in them, while our work presented in this paper covers these two functions in a comprehensible fashion. OVADO is a tool to support the validation of critical data through the formal verification of the required properties on data to ensure that the data comply with their requirements (Fredj et al., 2017). The suggested approach in this tool seems to share the same principle of modeling first and validation second, but it differs from our work in the sense that formal properties on data need to be formed and formal verification of them are required while no formal properties need to be formed and animation data are required in our work.

Our work presented in this paper has also made some contributions different from our own previous publications related to specification animation. In the publication (Liu and Wang, 2007), we describe a technique for animation of a system functional scenario in which all of the operations are defined using an explicit, executable specification. The animation is implemented by first automatically translating it into a Message Sequence Chart (MSC) and then executing the MSC. Different from this work, we deal with the animation of individual operations that are defined using an implicit specification (i.e., pre- and post-conditions) in this paper. The techniques proposed in the two studies are considerably different, although they share the same purpose to validate specifications. The article in Liu and Nakajima (2010) presents a decompositional way to generate test cases from SOFL formal specifications for testing programs, but this paper focuses on how to validate the specification itself. Although the principle of generating animation data may share with that of generating test cases for program testing, the whole contributions are different. The paper (Li and Liu, 2012) first presents our initial idea of how to carry out an animation for a system functional scenario in which all of the operations are specified using pre- and post-conditions. The focus of this work is on the visualized demonstration of the operation “execution” along the system functional scenario based on data flows. Unlike the work, this paper focuses on the animation of each individual operation involved in some system functional scenario. Although showing the transformation from the input of an operation into its output is reflected in both studies, the work introduced in Li and Liu (2012) is much simpler than the one presented in this paper in terms of the techniques used for animation and the animation contents. In Li and Liu (2015), we describe a study to use animation of system functional scenarios as a reading technique for inspection of functional scenarios derived from a CDFD (Condition Data Flow Diagram, part of a SOFL specification), but the work on animation in this paper focuses on animation of individual operations and their related data, not the interactions between operations on the system functional scenarios. The work in Li and Liu (2017) focuses on the introduction of a tool to support the animation of SOFL formal specifications for internal consistency and the translation from the textual expression of the formal specification into a tabular form. Different from the contribution, this paper focuses on the animation of each individual operation, involved data items and logical expressions for validation.

Despite the strengths of our approach mentioned above, some challenges remain and may need to be tackled properly when the approach is actually applied in practice. One is that our approach requires that both pre- and post-conditions of the specification be in a disjunctive normal form (DNF). This restriction may be inconvenient for those who wish to write specifications in a more free style. Although any non-quantified pre- and post-conditions can be automatically transformed into a DNF using a well established algorithm (Rusnak, 2017), such a transformation in some cases (e.g., 
) can lead to an exponential explosion of the formula (e.g., having 
 terms). Our experience so far suggests that such extreme cases do not happen in SOFL specifications for practical systems, but the resultant specification of the transformation may appear quite differently from the original one in structure and therefore might add some difficulty to the user in understanding the animated behaviors. A way to deal with this problem is that the specification is written directly in DNF from the beginning. Our experience with industry shows that practitioners can easily accept this way of writing formal specifications (Liu et al., 1998b, Luo et al., 2016), since each functional scenario formed from such a specification describes a specific “use case” simple enough for the user to understand easily and the specification writer can easily verify whether all of the possible behaviors of the corresponding operation have been covered in definition. Another challenge is that the operation animation can only demonstrate the relationships between input and output values (of various types) and the data animation can only show the characteristics of the input and output values, but they may not explain comprehensibly what the input–output relationships and the data characteristics actually mean in the real world, which may limit the effect of validation.

8. Conclusion and future work
We have presented a tool-supported specification animation technique that can be used to validate formal specifications by comprehensibly demonstrating three aspects for an operation specified using pre- and post-conditions: (1) the input–output relation of the operation, (2) the characteristics of the relevant data items of the operation with voice explanations, and (3) logical expressions and operators used in the formal specification of the operation. We have discussed how adequate animation data can be generated for performing the animation and described a prototype tool supporting the animation technique. We have also applied the animation technique to an industrial system and compare its effect with the practically well-used specification review technique. Our observation and experience in the application study indicates that the animation technique can bring us four major benefits in validating formal specifications: (1) the user (and the analyst) can easily comprehend the potential behavior of the animated operations, (2) the communication between the user and the analyst can be improved in the early phase of software development before coding, (3) the animation data can be reused as test data for the program to be implemented later, and (4) the validity of the specification can be checked during the animation process.

In the future, we will continue to extend our prototype tool with more features and capabilities for formal specification animation at both operation level and system level. We will also study how animation can be facilitated by appropriate graphical user interface (GUI) and how such a GUI can be automatically produced based on the nature of the related data items of operations. We will also be interested in applying the animation technique with the extended tool to industrial software development projects to find out whether and how the technique can be utilized to support Agile development paradigms in industrial setting.

