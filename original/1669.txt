Abstract
Deductive verification has gained paramount attention from both academia and industry. Although intensive research in this direction covers almost all mainstream languages, the research community has paid little attention to the verification of database applications. This paper proposes a comprehensive set of Verification Conditions (VCs) generation techniques from database programs, adapting Symbolic Execution, Conditional Normal Form, and Weakest Precondition. The validity checking of the generated VCs for a database program determines its correctness w.r.t. the annotated database properties. The developed prototype DBverify based on our theoretical foundation allows us to instantiate VC generation from PL/SQL codes, yielding to detailed performance analysis of the three approaches under different circumstances. With respect to the literature, the proposed approach shows its competence to support crucial SQL features (aggregate functions, nested queries, NULL values, and set operations) and the embedding of SQL codes within a host imperative language. For the chosen set of benchmark PL/SQL codes annotated with relevant properties of interest, our experiment shows that only 38% of procedures are correct, while 62% violate either all or part of the annotated properties. The primary cause for the latter case is mostly due to the acceptance of runtime inputs in SQL statements without proper checking.


Keywords
Database languages
Formal verification
Deductive reasoning
Verification conditions

1. Introduction
Static program verification is an integral part of the software engineering process to formally prove or disprove the correctness of programs without executing them. Acknowledging its immense importance in critical systems, intensive research in this direction has been taking place since its inception 45 years ago (Bjørner and Havelund, 2014) and a rich class of verification methods, such as Theorem Proving (Ahrendt et al., 2016, Filliâtre, 2011, Hähnle and Huisman, 2019), Model Checking (Clarke et al., 1994, Clarke Jr et al., 2018, Jhala and Majumdar, 2009), Process Algebra (Fokkink, 2013), have been successfully introduced to formally verify the correctness of both finite-state (e.g., hardware designs) and infinite-state (e.g., software programs) systems, guaranteeing that an implementation or design satisfies its specification.

Deductive reasoning, based on general-purpose theorem proving, has emerged as a promising technique for software verification. Intensive research in this direction has been taking place with a coverage of almost all mainstream languages (Ahrendt et al., 2016, Hähnle and Huisman, 2019, Chalin et al., 2005, Cuoq et al., 2012, Weiß, 2011). Presently, the field of deductive verification has reached a stage of maturity for its use in an industrial setting (Hähnle and Huisman, 2017). In general, the deductive approach internally employs a Verification Condition Generator (VCG) which takes, as input, a program with specification and returns as output a number of proof obligations, called Verification Conditions (VCs). The VCs are then sent to a backend proof tool for validity checking (da Cruz et al., 2012). The use of VCs provides a relatively complete proof system with the use of a richer first-order specification language.

Database applications play a pivotal role in every aspect of our daily lives. Their existence is realized everywhere, ranging from simple web applications to even critical systems like banking, e-commerce, e-government, health-care, etc. In many situations, organizations prefer to adopt third party software modules and integrate them into their existing database-driven systems, keeping the underlying databases intact. Therefore, verification of such untrusted modules is essential, as erroneous codes may lead to inconsistency in the existing database data by violating their properties of interest. Fig. 1 exemplifies such a scenario considering a budget allocation system: The attributes TA of the database table BudgetTab stores the total proposed budget for each department, whereas other attributes MP, EQ, CT, and CS maintain its distribution under four heads Manpower, Equipment, Contingency, and Consumable respectively. The procedure DBprog extracts TA into the application variable  for a given department  (at program point 6) and compares it with the department’s available budget  (at program point 7). The statement at 10 adjusts the budget by subtracting an equal fraction of the deficit amount ( - ) among four heads. The specification containing the number of constraints or properties in the form of CHECK constraints is specified as part of the BudgetTab table definition, which must be respected by the procedure DBprog on all executions. However, observe that as DBprog accepts run time inputs, the update operation may lead to a violation of the specification by reducing budget amount under some heads below their minimum threshold specified in the CHECK constraints.

1.1. Motivation and contributions
The presence of external database states, along with programs internal states, makes the verification task of database applications more challenging and painstaking. We observed that, although the database is an integral and indispensable part of most computing environments today, the research community has paid little attention in this direction.

On searching exhaustively in the literature, we find relatively few numbers of attempts to verify database applications (Baltopoulos et al., 2011, Benzaken and Schaefer, 1998, Christiansen and Martinenghi, 2003, Itzhaky et al., 2017, Malecha et al., 2010). Let us briefly present them. The proposed work in Itzhaky et al. (2017) manually translates the embedded SQL code into SmpSL script language and then computes verification conditions using the weakest precondition. Unfortunately, the approach suffers from a severe limitation in terms of scalability to adopt it for real-world programs. Precisely, the verification process takes care of only the decidable fragment of the problem within the scope of the two-variable first-order logic formula. As a result, the approach fails to accept SQL codes in the presence of arithmetic operations, aggregate functions, JOIN operations, etc. Predicate abstraction-based integrity constraints verification of extended version of O
 object-oriented database language is proposed in Benzaken and Schaefer (1998). In order to cope with the verification complexity due to object referencing, the source code is translated into an intermediate form on which the predicate abstraction is applied. We observed that the intermediate language is not expressive enough to accommodate important database language features, such as nested query, arithmetic expressions, aggregate functions, etc. Authors in Christiansen and Martinenghi (2003) propose integrity constraints verification for database applications using transformation operators. The proposed approach expressed every update operation as a predicate U  
 and integrity constraints defined in a constraint theory . The function after
 translates the constraint theory to the weakest precondition of  with respect to the update U, and a simplified formula is obtained by applying function Simp
. Verification of RDBMS specification and implementation is proposed in Malecha et al. (2010) using the Coq proof assistant, which has expressive-power limited to relational algebra only. The proposal in Baltopoulos et al. (2011) allows transactions to write in a functional language F# with database table-definitions as refinement types, and verify them using the refinement-type checker Stateful F7. In contrast to Malecha et al. (2010), where the main concern is to address database implementation issues, the approach in Baltopoulos et al. (2011) mainly concerns bugs in the user-defined transactions.

A comparative summary w.r.t. the literature is depicted in Table 1, where the existing proposals are compared w.r.t. ours based on their potential to deal with the type of properties, NULL values, aggregate functions, arithmetic expressions, and language paradigms. The notations T1–T5 represent the type of properties (Ullman, 2020) as follows: T1: Attribute-based (properties involving single attribute), T2: Tuple-based (properties involving multiple attributes), T3: Properties involving NULL values, T4: Properties involving aggregate values, and T5: General Assertions (properties involving both attributes and application variables).

It should be noticed that the applicability of the existing solutions in the literature is relatively poor due to their inability to embrace most crucial SQL features such as aggregate functions, nested queries, NULL values, arithmetic expressions. Moreover, most of them focus only on the verification of SQL statements without the support of the imperative language paradigm. In order to compensate the extra complexity, the approaches follow a common step of translating SQL into an intermediate form, and therefore the expressive power of the intermediate language often imposes a limitation on the verification of SQL features. Usually, database applications are written in popular host programming languages such as C, C++, Java, etc., with embedded data access logic expressed declaratively in Structured Query Language (SQL) or SQL-derived programming languages such as PL/SQL and T/SQL (Elmasri and Navathe, 2011). Therefore, verification of such applications, in contrast to the programs in mainstream languages, demands a different treatment due to the presence of database attributes along with program variables.


Table 1. Comparative summary w.r.t. the literature.

Proposals	Properties	NULL	Aggregate functions	Arithmetic expressions	Language
Itzhaky et al. (2017)	T1, T2	No	No	No	 
 
Baltopoulos et al. (2011)	T1-T3	Yes	No	Yes	SQL
Malecha et al. (2010)	T2	No	Yes	No	SQL
Benzaken and Schaefer (1998)	T2	No	No	No	O
Christiansen and Martinenghi (2003)	T2	No	No	No	SQL
Our proposal	T1–T5	Yes	Yes	Yes	 
 
In order to facilitate the correctness proof of database applications addressing the above-mentioned challenges, in this paper, we propose a comprehensive set of techniques for the generation of Verification Conditions (VCs) from database programs, adapting Symbolic Execution (SE), Conditional Normal Form (CNF) and Weakest Precondition (WPC). If the generated VCs for a given database program can be discharged (i.e., proved valid by an automated theorem prover), then the program is guaranteed to be correct w.r.t. the specified database properties. The developed prototype DBverify based on our theoretical foundation allows us to instantiate VC generation from a set of PL/SQL benchmark codes (PL/SQL Project, 2020a, PL/SQL Project, 2020b, PL/SQL Project, 2020c, PL/SQL Project, 2020d, PL/SQL Project, 2020e, PL/SQL Project, 2020f, PL/SQL Project, 2020g, PL/SQL Project, 2020h), yielding to detailed performance analysis of these three approaches under different circumstances. As reported in Table 1, with respect to the literature, our approach is powerful enough to verify SQL codes embedded within a host imperative language, with a coverage of the above-mentioned crucial SQL features and common database properties (Ullman, 2020). It is worth mentioning that our work is primarily motivated by da Cruz et al., 2012, Frade and Pinto, 2011 and Lourenço et al. (2015).

To summarize, the main contributions in this paper are:

•
We propose a comprehensive set of techniques to generate Verification Conditions (VCs) from database applications where database statements are embedded into a host imperative language. The generated VCs are then processed by an automated theorem prover for their validity checking in order to prove the program’s correctness. To this aim, we adapt Symbolic Execution (SE), Conditional Normal Form (CNF), and Weakest Precondition (WPC). The proposed techniques allow to support important SQL features, including aggregate functions, nested queries, NULL values, and various operations (JOIN, UNION, INTERSECT, and MINUS).

•
We formalize the conversion of database programs into a single assignment form, which facilitates the verification process, especially in the case of Symbolic Execution and Conditional Normal Form.

•
We develop DBverify a verification tool implemented in Python based on our theoretical foundation, which enables users to verify PL/SQL procedures under three different approaches. DBverify makes use of ANTLR parser [52] to generate VCs and Microsoft’s Z3 theorem prover [27] to check the validity.

•
Finally, we perform an experimental evaluation on a set of benchmark PL/SQL codes (PL/SQL Project, 2020a, PL/SQL Project, 2020b, PL/SQL Project, 2020c, PL/SQL Project, 2020d, PL/SQL Project, 2020e, PL/SQL Project, 2020f, PL/SQL Project, 2020g, PL/SQL Project, 2020h) under all three different approaches. We present a detailed performance analysis based on the experimental results and establish the effectiveness of the approaches under various circumstances.

The rest of the paper is organized as follows: Section 2 recalls the abstract syntax of the languages under consideration and introduces the conversion of database programs into single assignment form. Section 3 presents in detail all the proposed verification condition generation techniques for database programs. The complexity analysis of the proposed approaches and their correctness proofs are detailed in Section 4. Section 5 presents DBverify, a prototype implementation for the verification of PL/SQL codes. The experimental result on a set of PL/SQL benchmark codes with detailed performance analysis is described in Section 6. Section 7 presents threats to validity. Finally, Section 8 covers the current state-of-the-art in this research line, and Section 9 concludes our work.

2. Database language and single assignment form
In this section, we first recall from Halder and Cortesi (2012) and Jana et al. (2018b) the abstract syntax of the database language under consideration. Then we introduce its single assignment form, an intermediate language representation, which serves as a backbone of some approaches proposed in Section 3.

2.1. Abstract syntax of database language
We consider a generic scenario of database applications where SQL codes are embedded into another high-level host language. To this aim, let us recall from Halder and Cortesi (2012) and Jana et al. (2018b) the abstract syntax of the language, which, for the sake of simplicity in the theoretical formalism, supports SQL data manipulation languages hosted by imperative statements. This is depicted in Table 2. The variables are categorized into two: database attributes set 
 and application variables set 
. The arithmetic expressions  and boolean expressions  are defined accordingly, considering the presence of either 
 or 
 or both along with possible arithmetic and/or relational operators. Observe that , , , and  represent group-by, distinct/all, order-by, and aggregate functions respectively, where  is the identity function.

The SQL statements 
, 
, 
, and 
 consist of an action-part and a condition-part. For example, in the update statement 
≔
, the first component 
≔
 represents an action-part and the second component  represents a condition-part which follows well-formed formulas in the first order logic. To exemplify this, let us consider the statement “UPDATE emp SET sal ≔ sal   WHERE age  60”, where “age  60” corresponds to the condition part and ≔ UPDATE () corresponds to the action part. Therefore, its abstract syntax is defined as ≔. Informally, the semantics of the update statement can be described as follows: For the database tuples which satisfy the condition-part , the values of the attributes 
 are updated (in sequence) by 
. Similarly, given a query “SELECT DISTINCT Dno, Pno, MAX(Sal) INTO  FROM Tab WHERE Sal  1000 GROUP BY Dno, Pno HAVING MAX(Sal)  4000 ORDER BY Dno”. Its abstract syntax, according to Table 2, is 
, where  Sal  1000, 
 GROUP BY (), 
  DISTINCT ( DISTINCT(Dno), DISTINCT(Pno), MAX  ALL(Sal)),  MAX(Sal)  4000, and 
 ORDER BY ASC (). In general,  filters a set of tuples from the target table based on the satisfaction of  and the result obtained after processing these tuples using , , , ,  (if present) is stored in the resultset application variable . The syntax of  in the form of 
 supports nested queries as well. Observe that, since insertion of a new tuple does not require any condition to satisfy, the  in 
 is by default .


Table 2. Abstract syntax of database language Halder and Cortesi, 2012, Jana et al., 2018b.



2.2. Assertion language and database properties
As deductive verification is not fully automatic, this requires annotating the source code with assume and assert statements according to the specifications. The informal semantics of assume and assert are as follows: the assume  command excludes all computations which do not satisfy logical expression , whereas assert  commands at different program points specify the properties to be proven. A program is correct if, for every execution, whenever assert  is reached, the assertion  is satisfied by the current state. Since our verification starts with the assumption that the initial database is in consistent states w.r.t database properties, in order to reflect this, we annotate our program by placing assume command at the beginning of the code. As the database commands are responsible for changing database states, to detect any property violation at a higher granularity level, we allow the annotation by placing assert commands anywhere within the program, especially after database commands.

We adopt the assertion language from Winskel (1993), defined in Eq. (1), in order to support the following types of database properties (Ullman, 2020): Attribute-based, Tuple-based, Properties involving NULL and aggregate values, and General Assertions. (1)⩴
where  ranges over integer variables and  is the arithmetic expression defined below: ⩴
where . Readers may refer to Winskel (1993) for the semantics of the assertion language.

To exemplify various property types, let us consider a database schema: Employee(ID, Name, DOJ, Experience, Salary), Department (DID, Dname, MgrID, MgrStartDate). The following assertions ‘Salary  100  Salary  4000’ and ‘Experience  5  Salary  2000’ represent attribute-based and tuple-based properties respectively depending upon the presence of one or more attributes in the assertions, whereas the assertion ‘MgrStartDate  DOJ  Experience  y’ represents a general assertion due to the involvement of both database attributes and application variables. The examples of assertions involving NULL and aggregate values are ‘DID NUMBER NOT NULL’, ‘Avg(Salary)  2500’ respectively.

2.3. Single assignment form of database language
Single Assignment (Aycock and Horspool, 2000) is a semantically equivalent representation of a program in which every new assignment to a variable results in a new version and each version denotes a different logical variable. This ensures that, in single assignment, each variable is defined only once before being used. A versioned variable is defined by the original name of the variable associated with an integer subscript representing its current version.

Obtaining a logical encoding of a program is an essential task in any deduction-based verification framework, allowing for the generation of appropriate verification conditions. Let us demonstrate on a simple code snippet how a single assignment form of program code leads to the generation of the correct form of VCs capturing the actual program semantics. Given the code fragment P
 and the specification 
 depicted in Figs. 2(a) and 2(b). The logical expression  represents a VC of the annotated code in Fig. 2(c).

However, observe that, although P
 is correct w.r.t. 
, this can never be captured due to the unsatisfiability of  because   15 is always unsatisfiable. To make  satisfiable, one has to differentiate between the variable  appearing at the left and right sides of the assignment operator (≔). The best way to do this is to convert program codes into a single assignment form da Cruz et al. (2012).

Single Assignment Form of Imperative Statements (Aycock and Horspool, 2000, Briggs et al., 1998). As the prime objective in single assignment form is to ensure single definitions for all variables, in the case of an assignment statement, a new version for the defined variable appeared on the left side of the assignment operator is introduced. For example, consider the code: {read ;  ≔   1;}, its equivalent single assignment form is {read 
; 
 ≔ 
  1;}, where 
 and 
 denote the initial version and the current version of  respectively. In case of conditional statements where two or more control flow paths merge at a point, the single assignment property may get violated since multiple definitions of a variable may reach that merging point. To solve this problem, imaginary assignments are introduced at the merging points by using -functions and the resultant representation is called Static Single Assignment (SSA) form Briggs et al. (1998). In general, a -function has arguments corresponding to each incoming control flow path: the th argument of a -function is the incoming value along the th path. For example, the SSA form of the code fragment P
 in Fig. 3(a) is depicted in Fig. 3(b). Note that, in order to make such SSA form executable, the -function can equivalently be defined in terms of the ternary conditional operator. For example, the statement 
 ≔  (
, 
); in Fig. 3(b) can be defined as 
 ≔ 
 ? 
 : 
;.

Dynamic Single Assignment (DSA) form is an alternative representation where variables are defined along all control paths to ensure that a single definition reaches towards the merging points. Since the meaning of a -function is a mapping of all incoming values to a single name (say 
), it is equivalent to place a copy of 
 at the end of each predecessor-block. The copy moves the values corresponding to the appropriate -function argument into 
. This can be seen as a destruction of a -function into its direct predecessor-blocks in SSA form Briggs et al. (1998). For example, the code snippet in Fig. 3(c) depicts the equivalent DSA form of P
. Similarly, Fig. 4 highlights the SSA and DSA treatments of if-statement.


Download : Download high-res image (141KB)
Download : Download full-size image
Fig. 3. If-else statement and its single assignment form.

Single assignment form of SQL statements.
Let us now extend the notions of SSA and DSA to the case of database applications. To exemplify this, consider the UPDATE statement  in Fig. 5(a). Treating  in a similar way as in the case of imperative statements, we get its single assignment form depicted in Fig. 5(b). Note that, in the conversion process, we assume the existence of a ghost database (denoted by cap(
) on table names), which contains all versions of the attributes of the original database. This allows us to observe that the resultant single assignment form would be wrong because it reflects only a part of the database state for which 
 holds. In order to capture the complete database state, we add an auxiliary UPDATE statement by considering the negation of cond which covers the other part of the database state. The correct single assignment form of  is depicted in Fig. 5(c). We show this fact pictorially in Fig. 6.


Download : Download high-res image (114KB)
Download : Download full-size image
Fig. 4. if-statement and its single assignment form.

 Similarly, we can define the single assignment form of INSERT and DELETE by adding auxiliary UPDATE statements before them in order to reflect other parts of the database state also. In these two cases, we have to consider the versioning of all attributes in the table which are referred by the statements. Observe that, the SELECT statement changes the version of the application result-set variables only.

Treating SQL statements under if- and if-else statements .
Similarly to statements of an imperative language, the presence of UPDATE or DELETE or INSERT statement in if- and if-else requires special treatment to convert them into SSA or DSA form. The code snippets given in Fig. 7 illustrate this.

Observe that the -function 
 in the case of multi-definitions of database attributes under SSA form can be defined in terms of UPDATE controlled by if or if-else. For example, 
 ≔ 
 (
, 
); at program point 3 in Fig. 7(b) can be defined as:


Download : Download high-res image (16KB)
Download : Download full-size image
On the other hand, in the case of DSA of database code, the else-part is introduced whenever necessary (for example, statement 4 in Fig. 7(c)) and -functions are destructed into their predecessor-blocks (for instance, by introducing statements 3, 4, 21, and 23 in Fig. 7(c)), which ensures the single definition of attributes to flow towards the merging points.

Download : Download high-res image (897KB)
Download : Download full-size image
Fig. 7. SQL statements and their single assignment form under if- and if- else.

Since our proposed verification approaches make use of only DSA form whenever applicable, we restrict our discussions to DSA translation only in the subsequent sections. Let us now formalize DSA translation of the database language. Let  be a function which maps program variables to their corresponding versions, defined as: :  where  is the set of natural numbers. The initial version is defined by 
: {0}. We define the function TranDSA : 
 for our language which maps a given command   w.r.t. current variables-version  into its equivalent DSA form 
 resulting into a new variables-version 
. Fig. 8 depicts the detailed definition of TranDSA for various components of our language under consideration. Observe that TranDSA renames variable  or attribute  into their corresponding versioned form 
 or 
 w.r.t. current version  where  ()   or  ()  . In the case of assignment statements, the current versions of defined variables are incremented by 1 resulting in an updated version 
.

Let us now introduce a new syntactic form: 
≔
which indicates that the action-part 
 on 
 for the tuples satisfying 
 will be followed by another action 
 on the same 
 for the tuples satisfying 
. For example, UPDATE, INSERT and DELETE statements under this syntactic form are represented as:


Download : Download high-res image (930KB)
Download : Download full-size image
Fig. 8. DSA translation function TranDSA.

≔
≔
≔
 Since the DSA forms of UPDATE, DELETE, and INSERT add an auxiliary UPDATE statement before them in order to capture the definition of attributes for all tuples, we use this syntactic form in the definition of TranDSA. Observe that, like assignment statements, in these cases also  is modified to 
 by increasing the versions of defined attributes by 1. In the case of conditional statements if- and if-else, we use two functions Destruct and Sync, defined below: ≔≔
≔
≔
≔
≔
≔
≔
 where (stmt
 - stmt
) represents only those defining statements in stmt
 which are not common to both stmt
 and stmt
. Note that the task of the Sync function is to make variable definitions in both if- and else-blocks consistent by adding a new part (stmt
 - stmt
) only after applying Destruct on it ensuring that no change in the values of the variables takes place before and after their inclusion. For example, given the following if-else code snippet


. According to the definition of TranDSA in the case of if-else, the use of Sync and Destruct functions yields the following DSA form:            Observe that

introduces statement

under the if-block of the resultant DSA form, followed by statement

which is obtained by Destruct(

). Similarly, statements

and

are introduced under the else-block.
We are now in a position to propose Verification Condition Generation techniques, namely symbolic execution, conditional normal form, and weakest precondition, in the subsequent section.

3. Verification condition generation techniques
As we mentioned earlier that the fundamental step involved in the deductive-based approach is to generate VCs from program codes annotated with specifications. Once VCs are generated, they are fed to the theorem provers to check their validity which proves the correctness of the programs w.r.t. given specifications. Although VCs have been widely used in some well-known verification tools (Barnett et al., 2005, Clarke et al., 2004, Filliâtre and Paskevich, 2013), they have not been systematically analyzed by the research community. Authors in da Cruz et al., 2012, Frade and Pinto, 2011 and Lourenço et al. (2015) first revisited various VC generation techniques for iteration free imperative programs and performed a detailed comparison in term of efficiency. To the best of our knowledge, this has never been explored in the realm of database applications where database statements are embedded within a general purpose host imperative language. Our main objective in this section is to extend these VC generation techniques, namely symbolic execution, conditional normal form and weakest precondition, to the case of database applications, enabling to formally verify underlying database properties and to perform a detailed comparative analysis with respect to performance.

3.1. Symbolic execution
The very first and simplest method to verify the correctness of a program is to generate logical formulas along all execution paths of a program using symbolic execution, taking the given specification into account. Symbolic execution considers symbolic input values (rather than concrete values) and therefore execution proceeds along all control paths covering the entire execution space of the programs. Notice that the method produces one VC for each assert command in a path and each VC encodes only the part of the program that is relevant for that assert command. Therefore, there exists a one-to-one relation between the execution path and the VC. The validity of each logical formula certifies that execution going through the corresponding path meets the assertions, and consequently, successful validation of all formulas ensures the program’s correctness w.r.t. the given specification. This technique has an advantage from the point of view of traceability: an invalid VC allows one to immediately identify the executions that may violate a property.

Let us now formalize below two functions Path and 
. Note that, in order to indicate a statement in DSA form, we use either the superscript  or the subscripts  and  as the current version and the updated version respectively. We denote by 
 ≔ 
  
  
 the DSA form of either UPDATE or DELETE or INSERT as follows:

≔
≔
≔
 The functions Path and VC 
 are defined below:

(1)
Let  be a logical encoding of an execution path  up to program point . On encountering 
 at program point   1 along the path, the function Path (, 
) returns a logical formula that encodes  up to the program point   1. Fig. 9 defines the function Path for all statements in our language. Observe that the helper function F(.) represents the composition of functions , , , ,  (if present) in SELECT.

(2)
Given a program in the form of a sequence of statements, the function VC 
 recursively collects the logical encoding of all program paths by invoking the auxiliary function Path defined above. Finally, on encountering an  statement, the function VC 
 returns a VC corresponding to an implication to the assert constraints. This is defined in Fig. 10.

The overall algorithm of symbolic execution-based VC generation is depicted as Algorithm 1. CFG(
) denotes the control-flow graph of 
.


Download : Download high-res image (101KB)
Download : Download full-size image
Example 1

Given the code snippet DBprog in Fig. 1, its DSA form annotated with assume and assert statements is shown in Fig. 11. Initially  is the empty set . Consider the sequence of statements  in DBprog 
. According to the definition of VC
, applying Algorithm 1 on the sequence of statements, VC
 (, ) results in VC
 (, )  VC
(Path (,  6 ),  7; 8;  ) which initiates recursive calls on the subproblems. The auxiliary function Path accumulates logical formulas along the program paths, and finally the function VC
, on encountering the assert statement at program point 19, generates the following set of VCs.

 The fact that VC
 is not satisfied in some cases (for example, 
  20, 
  12, MP
  79999, EQ
  59 999, CT
  9999, CS
  4999) indicates that DBprog does not respect the given specification all the time. In particular, the violation happens due to statement 10 in DBprog where attribute values are subtracted by some amount which is influenced by a runtime input.

Limitation.
3.2. Conditional normal form
We have seen in the previous section that VCG using symbolic execution leads to an exponential number of VCs in the worst case scenario. To overcome this problem, we now describe the second method of VCG which was first used in Bounded Model Checking of software (BMC) (Clarke et al., 2004) as a way to unroll loops avoiding path enumerations. In the BMC technique, the transformation of iteration free DSA programs form is basically guided by the following three rules (Clarke et al., 2004):

 The first rule 
 states that branches of conditional statements can be sequentialized. The second rule 
 states that conditions can be distributed through the sequence of statements present in the body of conditional statements. The third rule 
 states that nested conditions can be combined together. Observe that the above rules rewrite a given DSA program into another semantically equivalent form where every statement 
 is guarded by a condition 
. If a 
 is not in the body of any conditional statement then it will be guarded by . This representation of the DSA programs is known as Conditional Normal Form (CNF).

(1)
Transformation of database program 
 in DSA form into its equivalent CNF form 
. This is defined by function toCNF(.): 
 ϒ 
, which transforms a given statement 
 into its equivalent CNF form 
 under the path condition ϒ upon which the execution of 
 depends. 
≔
≔

(2)
Extraction of two sets of formulas 
 and 
 from each statement in 
. To this purpose, we define the function (.): 
 , where  is the set of well-formed first order logic formulas and 
. This is depicted in Fig. 12. Finally, a single verification condition is constructed in the form of  
   
, where 
 contains the encoding of program statements and 
 contains the encoding of all assert commands in the program. Note that, unlike symbolic execution, in this technique only one verification condition is generated.

Fig. 13 depicts the function VC
 which combines these two steps and generates a VC from a given program in DSA form. Algorithm 2 is the overall algorithm to generate the CNF-based VC. Example 2 illustrates the CNF-based VCG technique.


Download : Download high-res image (86KB)
Download : Download full-size image
Example 2

Given the DSA form of DBprog in Fig. 11, its CNF form applying ToCNF(.) as depicted in Fig. 14. Fig. 15(a) shows the output formula set 
 and 
 obtained by applying (.). Therefore, the  is constructed by combining 
 and 
 in the form  
   
 is depicted in Fig. 15(b).

Observe that, similarly to when the symbolic execution technique was used, the validity checking of VC
 fails in some cases, which indicate a violation of the property .

3.3. Weakest precondition
Hoare logic is a widely-used deductive verification formalism for computer programs (Hoare, 1969). The axioms and inference rules of this proof system are based on Hoare triples of the form {Pre}stmt{Post}. This means any terminating execution of the statement stmt on a state satisfying the precondition Pre results in a new state satisfying the postcondition Post.

Dijkstra et al. (1976) introduced predicate transformers, a set of rules for transforming predicates on states, as a way to specify program semantics. In particular, he defined “Weakest Precondition (wp)” and “Strongest Postcondition (sp)”, treating assertions like preconditions and postconditions as predicates on program states. The predicate transformers technique generates VCs by propagating predicates either backward (weakest preconditions) or forward (strongest postconditions) along the program. As VCG based on the strongest postcondition is costly due to the presence of existential quantifiers in the formula, in this section, we extend VCG based on the weakest precondition to the case of database language. Given a program statement stmt and a postcondition , the weakest precondition of an iteration free imperative program is computed as follows:


Download : Download high-res image (209KB)
Download : Download full-size image
Fig. 14. DBprog 
: CNF form of DBprog 
.


Download : Download high-res image (530KB)
Download : Download full-size image
Fig. 15. Verification Condition of DBprog
 based on CNF.

≔
 In order to adopt VCG of database programs, we define wp on database statements in Fig. 16. Observe that, this process does not require to convert input programs into DSA form.

Example 3

Consider the motivating program DBprog depicted in Fig. 1. The annotated form of DBprog is depicted in Fig. 17.

The verification condition using weakest precondition wp of the above annotated program is computed as follows:


Download : Download high-res image (108KB)
Download : Download full-size image
Finally, VC is generated as follows: 
 Note that, similarly to the SE and CNF methods, in this case validity checking of VC also fails in some cases, indicating property violation.

Limitations.
Although this approach generates a single verification condition, the length of the VC may be exponential w.r.t. program size. For instance, in the case of if-else statement, the weakest precondition computation considers both branches into a single formula, increasing its length by duplicating the propagated condition. Therefore, a program with  conditional statements generates a single VC of length O(2
).

Efficient weakest precondition
We observed that for non-DSA programs, the weakest precondition technique produces VCs whose size is, in the worse case, exponential with respect to the size of the program. Flanagan and Saxe showed that when the technique was applied to programs in DSA form, the size of the generated VCs was, in the worst case, quadratic (Flanagan and Saxe, 2001). The main point to understanding the simplified definition of predicate transformers for DSA programs is to observe that the set of execution paths of such a program can be encoded logically in a compact way that does not require duplicating assert formula. We call this encoding the program formula. The program formula of an assignment statement is simply the corresponding equality, and the formula of a sequence of statements is the conjunction of formulas of the sub-statements. For conditional, the formula is (
)  (
), where 
 and 
 are the formulas of the branch statements. The program formula of various statements of the language under consideration are depicted in Fig. 18, where the function 
 denotes the encoding of 
.

Authors in Leino and Rustan (2005) later proposed a simplified solution emphasizing that the technique could be seen as a special case of weakest precondition computation by introducing the following “dream property”. 
where 
 is the weakest formula (known as weakest liberal precondition of 
 w.r.t ) that characterizes the pre-states from which every non-blocking execution of 
 either goes wrong or terminates in a state satisfying .


Download : Download high-res image (206KB)
Download : Download full-size image
Fig. 18. Definition of function (.) for language statements.

WPC is conservative in the sense that wp (
 is a predicate over pre-states of 
 such that all possible executions of 
 terminate in a state satisfying  and in all executions the assertion  is satisfied. However, in 
, the execution may go wrong or terminate in a state satisfying . Therefore, the author in Leino and Rustan (2005) derived a notable relation between wp and wlp as follows : 

In case of no assert statements in 
, we have 
, since 
. Therefore, by following the dream property, the wlp of a program 
 w.r.t.  can be computed as follows: 
The wlp of programs is defined in the same way as of wp (as shown in Fig. 16) except for assume and assert statements: 
 Therefore, for a given database program 
; assert , where 
 does not contain other assert statements, the following function computes a single VC. 

Since 
 generates a linear size program formula, unlike the WPC-based VC, the size of the efficient weakest precondition-based VC is linear in the size of the program. The following example illustrates this.

Example 4

Consider annotated 
 shown in Fig. 11.

≔
≔
≔

Observe that the above VC is linear in size and does not have duplicate assert expressions.

3.4. Addressing aggregate functions, NULL values, sub-query, JOIN, UNION, INTERSECT, and MINUS operations
This section provides guidance to deal with crucial database-specific features and operations.

Aggregate functions.
The aggregate functions only appear in SELECT statements which usually return a single value as the answer to a posed query. This means that violation is only possible if the values obtained through aggregate functions are stored in a result-set variable which in turn may affect, directly or indirectly, the specification representing a database property.

Given a database program containing aggregate function  on attribute , our VC-based approaches ensure the presence of  in the resultant VCs. If we treat  in the VCs as a new variable and if the VC violates the specification, let  be the value of  for which a violation is observed. Since our goal is to identify one instance which leads to some properties violation, we adopt the following approach to deal with various aggregate functions:

(a)
  min (). There exists a minimum value  of attribute  in a database instance which leads to this violation. However, this may be a false positive because of the treatment of  and min () as different variables. As a solution, we propose to adopt all the constraints over  as the constraints over min () in the VCs.

(b)
  max (). Same as min ().

(c)
  sum (). In this case, we can adopt only the constraints which define the lowest bound of -values as the constraints over the variable sum (). Observe that this over-approximation may lead to false positives.

(d)
  avg (). In this case, we can adopt only the constraints which define both the lower- and upper-bound of -values as the constraints over the variable avg ().

(e)
  count (). This is applicable only when we consider table-level properties as a part of the specification. An example of a table-level property is “each department must have at least two employees”. As we consider only tuple-level properties, this case is out of the scope of this work, and we consider it as our future plan.

Treating NULL values.
In order to address NULL values, we provide a separate treatment for the properties which specify whether attribute values may accept NULL or must be NOT NULL. To be specific, NULL property-violation may take place in the following situations:

(a)
The value of an expression  is set to an attribute “a” in INSERT or UPDATE, where “a” is NOT NULL and the value of  may be NULL.

(b)
The presence of a condition of the form “ is NULL/ is NOT NULL” in conditional statement.

In case (a), special care should be taken by checking the possibility of NULL values occurring in  against the NULL/NOT NULL property of the attribute “a”. In such a case, a warning report is generated. In case (b), the presence of a condition of the form of “ IS NULL” or “ IS NOT NULL” always leads to “always false” or “always true” respectively w.r.t the given NULL constraints “ IS NOT NULL”. Therefore, the VC generation can decide statically whether to ignore or to include the logical encoding of the other part of the database statement.

Sub-query.
A sub-query can be nested inside the WHERE or HAVING clause of an outer SELECT, INSERT, UPDATE, or DELETE statement, or inside another sub-query. A sub-query can appear anywhere an expression can be used, if it returns a single value. SQL statements that include a sub-query take one of the following format:  In the case of a sub-query of the format “ WHERE   ”, we first convert the inner query into a logical sub-formula which becomes a part of the final VC involving attributes, operators and co-relations present in the outer query. Example 5 illustrates this scenario.

Example 5

Consider the UPDATE statement Q


. The logical sub-formula generated from the sub-query using symbolic execution is R_ID
  L_ID
  CID
. Therefore, the resultant VC would be: 
In the case of a nested query of the format “ WHERE   ”, we replace the IN operator by the assignment operator (≔) during VC generation. Since our main aim is to determine property violations by the database code, any instance invalidating the resultant VC fulfills our objective.

JOIN.
Without loss of generality, let us assume that all attribute names in the database are unique. The presence of a query containing -JOIN is addressed easily by incorporating the condition  in the VC, in addition. Observe that equi-JOIN and natural-JOIN are special cases of -JOIN.

UNION, INTERSECT and MINUS operations.
Two or more queries can be combined using set operators UNION, INTERSECT and MINUS. The logical encoding of UNION (or INTERSECT) is achieved by using logical OR  (or logical AND ) operator. That is, logical formulas obtained from operands of UNION (or INTERSECT) are composed using  (or ). Since MINUS operation can be replaced by UNION and INTERSECT operations, VC generation in the presence of MINUS can be achieved by using  and .

3.5. Treating loops
As mentioned earlier, deductive verification approaches require user’s guidance and expertise for program annotation. Naturally, the presence of loops in a program makes this process more challenging. The fundamental step in such a case is to infer a loop invariant which remains true throughout the loop iterations.

The following are examples of situations where iteration is required for effective coding for database programs:

•
If the action over the tuples of a table is parameterized with changeable parameters for different tuples. In this case, rather than writing separate database statements in the code for different tuples of the table, the parameterized action can collectively be expressed in terms of a loop.

•
To iterate over the result-set values using a cursor.

•
Recursive Queries.

Hoare logic was proposed to deal with iterating While-programs, based on the loop invariants. Formally, the following classic inference rule (Winskel, 1993) uses the invariant  to express the partial correctness of a loop: 
 
 Fig. 19 defines the Hoare logic 
 for database programs by extending the same for imperative programs.

The relation between Hoare triples and weakest precondition is that {}{} iff   wp (, ) or sp (, ) . Observe that, since wp generates quantifier free formulas, it is often used in Hoare logic-based verifiers, instead of sp.

The computation of loop invariants in host imperative languages relies on existing approaches (Winskel, 1993), that can be adopted for database programs as well. In particular, the computation of inductive invariants in these cases, by following the approaches in Furia et al. (2014) and Kroening and Weissenbacher (2010), can be used with our proposed verification approaches. On the other hand, as an alternative solution, we can also extend the existing works on abstract interpretation of database programs (Jana et al., 2018b). The definition of widening operation, in addition, covers recursive queries as well (Cortesi and Halder, 2013).


Download : Download high-res image (279KB)
Download : Download full-size image
Fig. 19. 
: Hoare rules for database programs.

4. Complexity analysis and correctness proofs
We are now in a position to perform a complexity analysis of the proposed VC generation algorithms and to prove their correctness.

4.1. Complexity analysis
Let us describe the asymptotic characteristics of VCs generation by various approaches. VC generation based on symbolic execution generates VCs along all execution paths of a program. For a given program with  conditional statements, there exist 
 execution paths, and therefore this results in a number of VCs in 
 . In contrary, the CNF-based approach sequentializes branches of conditional statements which increases the program’s length to some extent. Assuming that the program contains a chain of nested conditions up to depth , the approach generates a single VC of size 
. The weakest precondition-based approach considers both branches into a single formula. Therefore, a program with  conditional statements generates a single VC of size 
.

4.2. Correctness proofs
We have defined a number of functions, namely Path, VC
, VC
 and wp, which act as the core of different VC generation techniques in Section 3. Therefore, the correctness of the proposed verification techniques can be guaranteed by proving the correctness of these functions. We achieve this by considering the validity of input and output logical formulas in terms of their semantics w.r.t. states and transition semantics of database applications.

To this aim, let us first recall from Jana et al. (2018b) the notions of states and state transition semantics of database programs.

State Transition Semantics of Database Language. Since our database language involves both host imperative variables and database attributes, the state is defined by considering the semantics domains for both of them.

Definition 1 Application Environment

Given the set of application variables 
 and the domain of values , let 
 be the set of all functions with domain 
 and range included in . An application environment 
 maps application variables to the domain of values Val.

Definition 2 Database Environment

A database  is a set of tables 
 for a given set of indexes 
. A database environment is defined as a function 
 whose domain is 
, such that for 
, 
.

Definition 3 Table Environment

Consider a database table  with attribute attr ()  
, 
, , 
. So, 
 where 
 is the attribute corresponding to the typed domain 
. A table environment 
 for  is defined as a function such that for any attribute 
 attr (), 
 where  is the projection operator and 
 represents the th element of the 
th row. In other words, 
 maps 
 to the ordered set of values over the rows of the table .

Definition 4 States and Concrete Semantics

Let 
 be the set of states for the database language under consideration, defined by 
 where 
 and 
 denote the set of all database environments and the set of all application environments respectively. Therefore, a state 
 is denoted by a tuple 
 where 
 and 
. The transition relation (2)
specifies which successor states 
 can follow when a statement  executes on state 
. Therefore, the transitional semantics 
〚〛
 〚〛
〚〛 of a program  restricts the transition relation to program instructions only, i.e.  
〚〛
〚〛
〚〛

Example 6 illustrates the concrete semantics of an update statement.


Table 3. Database before and after the update operation.



Example 6

Consider the database table  in Table 3(a) and the following update statement: 
≔The abstract syntax is denoted by 
, where  and 
 and 
.

The table targeted by 
 is  (
)  {}. The semantics of 
 is:

〚
〛
〚〛
〚〛
〚〛
〚〛
 The notation  denotes the set of tuples in  for which  is true (denoted by the red part in  of Table 3(a)). 〚〛 is a semantic function for arithmetic expressions which maps “” to a list of values  on the table environment 
. The notation  denotes a substitution by new values. Observe that the substitution of ’’ by the list of values in 
 results in a new table environment 
 (denoted by the red part in Table 3(b)). Finally, the least upper bound (denoted ) of the two states results in a new state (
) where 
 is depicted in Table 3(b).

Lemmas and Theorems. Let us now state a number of lemmas and theorems aiming to guarantee the correctness of various VC generation functions in our verification approaches. As mentioned earlier, we make use of state and transition semantics defined above to prove these lemmas and theorems.

Extending the semantics of the assertion language defined inWinskel (1993) to the case of database applications, let the relation 
, 
⊧
 mean that the state 
, 
 satisfies the assertion  under the interpretation I.

Lemma 1

Let  be the logical encoding of an execution path  up to program point . Let 
 be a DSA form of program statement at program point . Let  be the logical encoding computed using the function Path, 
. The function Path is correct if 
, 
, 
⊧
 under interpretation  and 
〚
〛
, 
, 
, implies 
, 
⊧
.

Proof

The proof is established based on structural induction. Assume that 
, 
 satisfies  under the interpretation , i.e. 
, 
⊧
.

Assignment statement 
≔
. Let 
〚
≔
〛
, where 
 is obtained by substituting all occurrences of 
 in 
 by 
 〚
〛
. Since 
 does not involve 
, its semantics are the same w.r.t. both the states 
 and 
. Therefore, (3)
⊧
On the other hand, since 
 is not present in  due to the DSA property and only 
 is affected in 
, we have (4)
⊧
Combining Eqs. (3), (4), we get 
, 
⊧
.

Database statements Q. Since a database statement Q involves action ‘A’ and condition ‘cond’, this can be treated as a guarded command equivalent to “if  then A”. Consider the DSA form 
≔
, 
 of different database statements. By the definition of the function Path, we have: 
≔
≔
≔
 Let us now prove the lemma for each database action:

•
≔
 
. Given a state 
, 
, assume that 
〚
〛 
. By the definition of the function Path, we have 
 Since 
⊧
 and  does not involve 
 due to the DSA property, the following holds. (5)
⊧
 Now we have two possibilities: either 
⊧
 or 
⊧
. In the former case, the action 
≔
 results in the same semantics for 
 and 
 w.r.t. 
, i.e. 
〚
〛 
〚
〛
. Therefore, (6)
⊧
 In the latter case, the attributes 
 in 
, where 
, are substituted by 
〚
〛 
 respectively. Since only the value of 
 is affected in 
, we have 
〚
〛
〚
〛
, and therefore, (7)
⊧
 Hence, combining Eqs. (5), (6), (7), 
 ⊧
 is proved.

Proofs for other statements follow a similar direction. The reader is directed to Appendix A.1 for details.  □

Theorem 1

Given a database program  and its annotated DSA form 
 
, let  be the set of verification conditions derived by the function VC
 which includes initial condition 
. If for all 
, 
 is valid (denoted by 
), then  satisfies the property 
 and vice versa.

Proof

On applying 
 
 , according to the definition in Fig. 10, we get a set of VCs  along all execution paths, each of the form 
. For all initial states 
 satisfying 
, i.e. 
⊧
, if 
〚
〛
, 
, then according to Lemma 1 we have (8)
⊧
If the program satisfies the assert 
, this means 
, 
 ⊧
. Therefore, all 
 are valid. This proves the theorem.  □

Theorem 2

Let  be a verification condition generated from an annotated database program 
; 
;  
 in its CNF form, by applying the function VC
 which includes initial condition 
. If  is valid (denoted as ), then  satisfies the property 
 and vice versa.

Proof

Since 
 is semantically equivalent to 
, the proof is similar to Theorem 1.  □

Theorem 3

Given an annotated program 
; ;
. If the verification condition 
  wp(, 
) is valid, then  satisfies the property 
 and vice versa.

Proof

The proof is based on structural induction on . Recall the definition of wp in Fig. 16 and let  
. We have to prove that, if 
, 
⊧
 and 
 and 
 and 
〚〛
, then 
⊧
. Let us now consider the different cases:

Case   ≔. Let 
, 
⊧
. According to the definition, wp ≔
. Assume that 
. Therefore, (9)
⊧

According to the transition semantics, assume 
 〚≔〛
 such that 
 where 
〚〛
. Since, in 
 all occurrences of x are replaced by , according to Eq. (9), we have 
⊧
. Assuming 
, this case is proved.

Case  
≔
. Let 
⊧
. According to the definition, 
≔
, 
. Assume that 
. Therefore, (10)
⊧

According to the semantics function, let us assume 
 〚
〛
, where

(i)
Values of 
 will be updated by 
〚
〛
 for the tuples satisfying ‘’. That is, similarly to the assignment statement, we have (11)
⊧
⊧

(ii)
Values of 
 will remain unchanged for those tuples which do not satisfy ‘’. That is, (12)
⊧
⊧

Combining Eqs. (10), (11), (12), the lemma is proved for Q
 assuming 
.

Proofs for other statements are similar. The reader is referred to Appendix A.1 for details.  □

Recall the Hoare triple in Section 3.3 and the Hoare logic system 
 for the database language defined in Fig. 19. The semantics of Hoare triples is given below:

Definition 5

The Hoare triple  is said to be valid, denoted as ⊧ , whenever for all ((
, 
), (
, 
)) , if (
, 
) ⊧
 and 
〚〛
  (
, 
), then (
, 
) ⊧
.

Let us now prove the soundness of 
. We denote by 
 {}{} the fact that the Hoare triple {}{} is derivable in the Hoare logic system 
.

Theorem 4 Soundness of Hoare Logic System

Let stmt  and let ,  be the pre-condition and post-condition respectively. If  
stmt, then ⊧stmt.

Proof

The proofs for database statements follow the proof of Theorem 3. For assignment, sequence, conditional, and iteration statements, the reader is referred to Winskel (1993).  □

5. DBverify: A database code verifier
In this section, we present DBverify, a prototype implementation of our proposed verification approaches for PL/SQL language, which is developed in Python with roughly 6500 lines of codes. The workflow of DBverify is shown in Fig. 20. DBverify consists of four modules: (1) DSA-translator, (2) SE-verify, (3) CNF-verify, and (4) WP-verify. The overall schematic diagram of DBverify is depicted in Fig. 21. Observe that the first module converts a given PL/SQL code into its equivalent DSA form. The modules SE-verify, CNF-verify, and WP-verify implement verification condition generation under three deductive-based approaches. Let us now describe each of the modules in detail.


Download : Download high-res image (286KB)
Download : Download full-size image
Fig. 20. DBverify workflow.


Download : Download high-res image (791KB)
Download : Download full-size image
Fig. 21. Schematic diagram of DBverify.


Table 4. Description of benchmark database applications.

DB applications	Description	LOC	#Procedures	#Attributes	#Application variables
Courier_Company (CC) (PL/SQL Project, 2020a)	 
 	935	16	40	122
Inventory_Management (IM) (PL/SQL Project, 2020b)	 
 	550	05	37	73
CableCity(CB) (PL/SQL Project, 2020c)	 
 	890	09	25	54
Hotel_Reservation (HR) (PL/SQL Project, 2020d)	 
 	504	05	19	24
Retail_Business Management (RM) (PL/SQL Project, 2020e)	 
 	552	04	35	24
Computer Store Management (CS) (PL/SQL Project, 2020f)	 
 	738	05	38	34
Banking Management (BS) (PL/SQL Project, 2020g)	 
 	511	04	23	34
Course Registration (CR) (PL/SQL Project, 2020h)	 
 	268	01	31	15
(1)
Module DSA-translator: This module converts a given PL/SQL code into its equivalent DSA form. The initial tasks of the module are to annotate PL/SQL code by assume and assert statements taking the given specification into consideration, and then to construct the Control Flow Graph (CFG) of the annotated code using parsing techniques. We have used the ANTLR4 parser (Parr, 2013) for this purpose. Finally, taking CFG information as input, the module performs variable versioning and destruction of -nodes into its immediate predecessor-blocks to generate DSA form by following the standard algorithm (Briggs et al., 1998) with an extension to cover the PL/SQL language. The schematic diagram of this module is depicted in Fig. 21(a).

(2)
Module SE-verify: Given an annotated PL/SQL program in its DSA form, this module generates a set of VCs according to Algorithm 1 depicted in Section 3.1. The resultant VCs are further passed to the SMT Solver for validity checking. We have used Z3 for this purpose. The schematic diagram is depicted in Fig. 21(b).

(3)
Module CNF-verify: Unlike SE-verifier, this module first converts the annotated input program (in DSA form) into its equivalent CNF representation and then generates a single VC according to Algorithm 2 given in Section 3.2. Finally, this VC is fed to the Z3 SMT Solver for validity checking. The schematic diagram of this module is depicted in Fig. 21(c).

(4)
Module WP-verify: For a given database program and its specification, this module computes a single VC according to Algorithm 3 in Section 3.3. The schematic diagram of this module is depicted in Fig. 21(d).

As suggested in Section 3.4, DBverify considers the presence of aggregate operations as new variables. To deal with NULL, we maintain a dictionary of the form {tableName : [(attr-1, nullity), (attr-2, nullity), , (attr-n, nullity)]}, where nullity represents attribute constraints such as NULL or NOT NULL. On assigning an expression containing NULL to any of these attributes, we check and report (if any) constraint violations. When a NULLvalue appears in the guard of any conditional statements (e.g. if ... IS NULL {...}), we replace it by  representing non-determinism. Therefore, the VC generation can decide statically whether to ignore or to include the logical encoding of the other part of the database statement. In the case of nested queries, DBverify proceeds from the inner-most sub-query to the outer-most sub-query based on the generated Abstract Syntax Trees (AST) of sub-queries to generate logical formulas, according to the formalism described in Section 3.4. In the case of -JOIN operation, DBverify first extracts the logical formula from the AST of the condition , and then adds it with the logical formula of the other part of the query. In the case of outer-JOIN, UNION, INTERSECT, and MINUS operations, we follow the formalism described in Section 3.4.

6. Experimental evaluation
This section presents experimental results on a set of PL/SQL benchmark codes (PL/SQL Project, 2020a, PL/SQL Project, 2020b, PL/SQL Project, 2020c, PL/SQL Project, 2020d, PL/SQL Project, 2020e, PL/SQL Project, 2020f, PL/SQL Project, 2020g, PL/SQL Project, 2020h) using our prototype tool DBverify. A summary of the benchmark codes is depicted in Table 4.

We organize our experimental reports in two subsections. In the first of these, we assess the performance of deductive-based verification (symbolic execution, conditional normal form, and weakest precondition) techniques, and in the second we discuss about electing the most efficient algorithm. All experiments are conducted using a computer system equipped with core i7, 3.60 GHz CPU, 4GB memory, and Ubuntu 14.04 operating system.


Table 5. Verification results under deductive-based approaches.

DB App	Procedures	# Assertion	Assertion type	# VCs(SE)	Verification time (in millisec)	Verification results
SE	CNF	WP	#Valid	#Invalid
CC	update_client.sql (P1)	3	T1,T3	7	1132.382	429.915	605.012	2	1
add_dimension_class.sql (P2)	1	T1,T3	3	489.062	141.523	223.742	1	0
add_car.sql (P3)	2	T1-T4	36	5715.589	571.418	729.936	1	1
add_courier.sql (P4)	7	T1-T4	726	158 809.247	1610.636	2652.89	6	1
add_status.sql (P5)	4	T1,T3	24	3623.771	317.157	397.077	4	0
add_parcel_type.sql (P6)	1	T1,T3,T4	3	456.85	170.738	193.391	1	0
add_client.sql (P7)	2	T1,T3,T4	18	3681.689	305.573	323.188	0	2
add_delivery_attempt.sql (P8)	4	T1,T3	27	3967.09	296.309	379.003	3	1
add_parcel.sql (P9)	3	T1,T3,T4	40	7840.22	776.464	972.306	3	0
add_warehouse.sql (P10)	2	T1,T3	24	6005.307	473.43	576.8599	2	0
update_warehouse.sql (P11)	3	T1,T3	3	553.536	213.336	270.883	2	1
driving_license_category (P12)	1	T1,T3	3	450.966	134.064	152.183	1	0
get_contract_type_id.sql (P13)	1	T1,T3	3	469.39	170.085	253.615	1	0
get_delivery_status.sql (P14)	1	T1,T3	3	444.132	163.679	197.397	1	0
get_country_id.sql (P15)	1	T1,T3	3	450.762	171.882	256.791	1	0
delete_client.sql (P16)	1	T1	7	141.092	107.117	119	1	0
IM	add-to-inventory.sql (P1)	1	T1	1	150.933	148.536	150.597	1	0
assemble-module.sql (P2)	4	T1,T2	30	5822.301	195.399	437.9089	0	4
assemble-component.sql (P3)	10	T1–T5	78	11 235.171	397.668	22 882.824	8	2
procinventory.sql (P4)	7	T1,T3,T5	15	2577.703	730.68	854.946	6	1
deliver.sql (P5)	3	T1,T3	3	405.958	205.872	345.739	2	1
RM	add_cust.sql (P1)	2	T1,T3,T5	9	3740.924	620.314	2561.225	0	2
qoh_update.sql (P2)	4	T1,T3	7	1115.73	458.236	989.809	1	3
retail-business-logic.sql (P3)	3	T1,T2,T5	72	13 464.077	153.664	45 707.734	2	1
budget.sql (P4)	1	T1,T2,T5	2	510.087	231.96	393.028	0	1
HR	bill.sql (P1)	1	T1,T5	2	332.12	278.318	303.683	0	1
award-bonus.sql (P2)	1	T2	2	347.44	148.783	291.376	0	1
discount.sql (P3)	1	T1,T5	4	897.481	217.413	369.509	0	1
resrvation-proc.sql (P4)	5	T1,T3	30	6427.385	348.296	488.749	4	1
CS	cust-emp-proc.sql (P1)	2	T1,T2	6	850.02	141.256	189.866	2	0
cartsell.sql (P2)	5	T1-T3	30	4944.753	454.442	567.582	5	0
loginproc.sql (P3)	2	T1-T3	9	1951.349	188.744	206.902	0	2
product.sql (P4)	4	T1,T3	79	17 081.274	770.027	3453.8509	3	1
transfer.sql (P5)	4	T1,T3	4	686.796	314.784	416.193	4	0
BS	credit-account.sql (P1)	1	T1	1	305.4	129.629	121.744	1	0
debit-account.sql (P2)	1	T1,T5	2	302.246	127.123	134.39	0	1
Procedure_transactions.sql (P3)	7	T1,T3,T4	64	19 009.815	749.565	3019.334	6	1
check.sql (P4)	1	T1	2	294.594	118.144	123.658	0	1
CaC	AddCustomerPoints.sql (P1)	1	T1	4	952.831	222.605	232.99	0	1
CheckPassword.sql (P2)	1	T1,T2	3	469.283	132.547	154.568	1	0
UpdateQuantity.sql (P3)	1	T1,T2	6	902.813	150.781	233.769	1	0
RecordNewSale.sql (P4)	1	T1	16	2544.719	307.056	911.324	0	1
PopulateProducts.sql (P5)	1	T1,T3	4	974.6	264.795	135.582	0	1
PopulateCustomers.sql (6P)	1	T1,T3	4	678.47	377.758	162.135	0	1
PopulateSales.sql (P7)	4	T1–T5	1024	169 602.727	662.117	80 132.817	3	1
DecreaseDispStock.sql (P8)	1	T1	5	765.373	190.366	313.94	0	1
IncreaseDispStock.sql (P9)	1	T1	5	782.142	197.925	312.692	0	1
CR	isEnrollable.sql (P1)	1	T1,T3	14	4164.848	434.723	634.9329	1	0
6.1. Assessing the deductive-based verification techniques
DBverify accepts PL/SQL code annotated with assertions (representing properties of interest) as input, and it generates a set of VCs expressed in Z3 Language. The validity of VCs is then checked by providing their negation to Z3. The result Unsat indicates that the program satisfies its properties, whereas the result Sat for at least one case indicates a counter-example. For example, Z3 reports Sat for the VC (in negation form) generated from the procedure “budget” using weakest precondition and exhibits a model “[X  1/2, CS  5001, MP  160001/2, DID  0, EQ  60001, CT  10001, Z  0, TA  5/2, Y  0]”. This model serves as a counter-example for the correctness of the “budget” procedure.

Table 5 depicts detailed verification results of the benchmark applications under three deductive approaches. The procedures defined under each benchmark provide various services and they are verified at the individual level as they are independent w.r.t. each other.

Since our special focus in this experiment is to verify database properties, the third and fourth columns of the table denote the number and type of assertions each procedure is instrumented with. The assertions with which we have annotated the PL/SQL procedures are either defined as part of the table definitions or chosen based on their practical relevance w.r.t. the procedures’ behaviors. The assertion types are indicated by numbers, as follows: T1: Attribute-based, T2: Tuple-based, T3: Null Value, T4: Aggregate Functions, T5: General Assertions. The fifth column indicates the number of verification conditions (VCs) generated from the procedures under Symbolic Execution-based (SE) verification. Observe that Conditional Normal Form (CNF) and Weakest Precondition (WPC) always generate a single VC. We have recorded the total verification time (in millisec) for all procedures under the three approaches in columns 6–8, and their comparison is depicted in Fig. 22. It is worthwhile to observe that verification under CNF always takes less time as compared to SE and WPC. Interestingly, in the case of our benchmark codes, we also experience that SE requires longer verification time as compared to WPC in most of the cases. Arguably, the reason behind this is the generation of multiple VCs (which may contain multiple copies of the same logical encoding) in SE and their validity checking by Z3 individually (depicted in Fig. 27). However, an exception is observed in two procedures, namely P3 in the IM and RM applications, where longer VC generation time is experienced (depicted in Fig. 24) due to the presence of a high number of attributes in the postconditions as well as a higher number of SQL statements which define these attributes. Precisely, this affects the computation time from postcondition to weakest preconditions in the backward direction significantly. The verification outcomes indicating the number of assertions proved as valid and invalid are reported in columns 9 and 10 respectively. The results clearly show that only 38% of the benchmark procedures satisfy the annotated database properties, while 62% procedures violate either all or part of the annotated properties. The primary cause behind this is that most of the SQL statements in the procedures accept runtime inputs without any proper checking. On other hand, only 68% assertions are satisfied by benchmark procedures.

(I)
DSA Generation (DSAgen) Time: Conversion of PL/SQL codes into their equivalent DSA form is a key step in SE- and CNF-based verification. Intuitively, various factors such as the number and types of statements in the code, number of variables and attributes defined or used by the statements, number of conditions and nesting depth, etc., contribute differently to DSAgen time. To extract insightful observations on the variation of DSAgen time w.r.t. the PL/SQL codes, we have classified statements into three different categories low, medium and high effectiveness (denoted ,  and  respectively) depending upon their contributions in DSA-gen time and computed the overall weights of PL/SQL codes according to the following equation: (13)
where  is the number of statements and 
 denotes th statement in the category {l, m, h}. 
 returns the weight of 
 under its category . 
 is an additional weight factor whose value reflects the complexity level of 
, i.e. the number of attributes and variables used and defined in 
. Notice that this factor is implementation-dependent. We have classified the statements as follows: Low effectiveness category includes variables declaration, assume, assert, cursor operations and exception handling statements. Medium effectiveness category includes assignment statements. Most effectiveness category include conditional and SQL statements. Fig. 23 depicts the variation of DSAgen time w.r.t. the weights of the codes, considering Weight (
)  1, Weight (
)  2, and Weight (
)  4.

(II)
VC Generation (VCgen) Time: VCgen time for all procedures under SE, CNF and WPC are depicted in Fig. 24. As expected, VCgen in CNF always takes less time as compared to the others. However, if we compare VCgen in SE and WPC, we observe that for some procedures SE performs better than WPC, while for the rest WPC performs better than SE. Although VC generation in both approaches gets highly affected by the presence of conditional statements, the primary reason behind this difference in VCgen time is as follows: In SE, the logical encoding of all statements along each path appears in its corresponding VC. This creates multiple copies of the logical encoding of the same statement in multiple VCs, if the statement appears in all those paths. Therefore, procedures having a large number of execution paths which comprise multiple copies of the same statements’ logical encoding experience higher VCgen time (for example, procedures P4, P9 and P10 in CC, P2 in IM, P4 in RH, and P3 in BS). In contrast, in WPC, VC generation deals with the computation of the weakest precondition from the postcondition in a backward direction and this primarily gets affected by only those statements which define the attributes or variables that appeared in the postcondition. In particular, SQL statements as defining statements are more influential in this case, as they involve WHERE clause. Therefore, procedures having more such defining statements experience higher VCgen in WPC (for example, P3 in IM and RM, P4 in CS, etc.).

Let us now observe the variation of VCgen w.r.t. PL/SQL codes, identifying the influence of different types of statements and their operational complexity to the VCgen. The computation of weights of PL/SQL codes in case of SE, CNF and WPC follows similar approach as in the case of DSAgen time, with minor changes either in equation or in statements’ classification. In SE and CNF, conditional statements are considered as medium category, whereas WPC considers the assert and conditional statements as high category. Although the weight computation in CNF and WPC follows Eq. (13), it differs in case of SE by taking into account various paths in the code as defined in Eq. (14). (14)
Following Eqs. (13) and (14), the variation of VCgen time w.r.t. weights of different procedures in the case of SE, CNF, and WPC are depicted in Figs. 25(a), 25(b), and 25(c) respectively.

(III)
Number of VCs: The number of VCs in the SE-based technique is same as the number of execution paths that exist in the code, and it depends on the number of conditions and their nesting structure. The presence of conditional statements without any nesting in the code yields a maximum number of paths, whereas a balanced form of nesting in both if-block and else-block yields a minimum number of paths in the code. Therefore, given  number of conditional statements in the code, the number of paths (hence VCs) lie within the interval [, 
]. We observe that our results on the number of generated VCs lie between this allowable range depicted in Fig. 26.

(IV)
Z3 Execution time (Z3exe): Since we have built our tool on the top of SMT solver Z3, the time taken by Z3 to validate the generated formula for all procedures under three deductive approaches is depicted in Fig. 27. It is observed that Z3 execution time for the VCs generated in CNF always takes less time compared to others. However, in the case of SE and WPC, it depends on the number of VCs generated in SE versus the size of VC generated in WPC.

6.2. Electing most efficient verification algorithm
While evaluating different deductive verification algorithms with a common goal, the first question that comes to mind is “which one is the most efficient or suitable algorithm?”. Let us address this question by analyzing the results from the both theoretical and the practical perspectives.

As already discussed in Section 4, for a given program with  conditional statements, there exist 
 execution paths and therefore the SE-based algorithm results in 
 number of VCs. In contrast, the CNF algorithm avoids path enumeration by transforming the procedure into CNF-form. Assuming that the program contains  conditional statements with nesting depth up to , the CNF algorithm generates a single VC of size 
. The WPC algorithm, on the other hand, generates a single VC by OR-ing the weakest preconditions generated from the postcondition along all branches of the code. This exhibits exponential 
 size of VC for programs with  conditional statements.

Let us now do an analysis based on our empirical study. As is clear in Fig. 24, CNF always takes less VC generation time, thus supporting the theoretical analysis results. However, in the case of SE and WPC, although both are influenced by conditional statements, the VCgen time varies due to the presence of other statements. In particular, as already mentioned before, SE performs path enumeration and takes into account the same statements multiple times during the VC generation, if the statements appear over multiple paths. This consumes a significant amount of time which varies depending upon the number of paths and their length. On the other hand, VC generation in WPC effectively depends on the computation of weakest precondition from postconditions. This consumes a considerable amount of time which increases if the postcondition involves a higher number of attributes and variables and there exist more statements which define those attributes or variables. Although, our empirical study does not allow us to quantify these factors exactly, one can conclude that programs having a lower number of defining statements and a higher number of execution paths experience higher VCgen time in SE than that in case of WPC.

A similar observation can also be drawn from the Z3 execution time, depicted in Fig. 27, where VCs generated in CNF always takes less time as compared to the execution of VCs generated in SE and WPC. However, we observe in most of the cases that Z3 execution time in SE is higher than in WPC, due to the presence of multiple VCs (with repetition of logical encoding) whose validity is checked individually. An exception is observed in two cases, namely P3 in IM and RM, where the size of the VC generated in WPC is much higher than the total size of all VCs generated in SE. This happens due to the presence of a higher number of attributes in postcondition and also a higher number of SQL statements which define those attributes. As WPC does not require DSA conversion, this becomes a key factor on the overall verification time depicted in Fig. 22. Based on this analysis, one can now easily judge that CNF is the most efficient verification algorithm among these three. However, the decision to choose one between SE and WPC depends on the program’s structure, size of the postcondition and the types of statements involved in the program.

7. Threats to validity
We first discuss the threats to external validity, which are about the generalization of our findings. Three proposed VC generation techniques in this paper are, in general, applicable to the case of database applications dealing with relational databases. In particular, our focus is to verify their correctness w.r.t. database properties. In terms of expressive power of the assertion language, although we are able to express most common database properties (Ullman, 2020), a failure is observed in the case of property involving referential integrity or a count of database records. Notably, our theoretical formalism is based on the abstract syntax of a database language embedded within an imperative host language. Although this paper considers a simple form of host imperative language, the support of dynamic memory data structures, floating points, pointers, etc., can be provided with more engineering without affecting the general idea of the proposed techniques. Besides, the abstract syntax of database extension captures crucial features of the languages used in popular structured database systems, such as MySQL, Oracle, DB2, Microsoft SQL Server, PostgreSQL, etc., with a complete support for data manipulation operations. It should be mentioned that the proposed approach does not support verification of dynamically generated database statements in the applications. The developed tool DBverify currently supports loop-free PL/SQL only. We are in the process of extending it to support loops (as highlighted in Section Section 3.5) and to the languages of other database management systems with their embedding within popular host languages (such as C, Python, Java, etc.) in the next release of the tool. For the latter case, we require little effort to modify the parser-based language processing module in DBverify according to the language’s concrete syntax. Observe that, in the case of concurrent database transactions, as two or more transactions can interleave in a concrete program run, this threat can be mitigated by our current proposal through a static identification of all possible permutations of database statements present in the transactions (Beckert and Klebanov, 2007, Chrysanthis and Ramamritham, 1998), incurring an exponential computation cost (Ábrahám et al., 2005, Bruns, 2015).

Let us now discuss the threats to internal validity, which refer to experimental bias and errors. In our experiment, we have annotated benchmark PL/SQL procedures with the assertions that are already part of the underlying database table definitions or chosen based on their practical relevance w.r.t. the procedures’ behavior. To this aim, we have considered the most common relational database properties, as reported in Ullman (2020). Even though our proposal covers crucial SQL features, the aggregate functions (except COUNT) are treated by means of an abstraction, which may result in false positives. The experimental results, as expected, reveal that CNF is the most efficient verification algorithm among these three. However, the decision to choose one between SE and WPC depends on the program’s structure, size of the postcondition and the types of statements involved in the program.

8. Related work
Theorem proving (Deductive reasoning) (Ahrendt et al., 2016, Filliâtre, 2011, Hähnle and Huisman, 2019), model checking (algorithmic verification) (Clarke et al., 1994, Clarke Jr et al., 2018, Jhala and Majumdar, 2009) and process algebra (Fokkink, 2013) are the main categories of techniques for formally verifying properties of both hardware and software systems. The theorem proving and model checking approaches have complementary strengths and weaknesses, and their combination promises to enhance the capabilities of each (Reed et al., 1999, Uribe, 2000). Process algebra, on the other hand, constitutes a framework for formal verification of processes and data, with the emphasis on processes that are executed concurrently.

Over the decades, numerous proposals based on the above-mentioned methods have been proposed in the literature for the verification of general purpose programming languages, addressing various language features such as variables, control structures, pointers, objects, etc. (Ahrendt et al., 2016, Filliâtre, 2011, Hähnle and Huisman, 2019, Cuoq et al., 2012, Hoare, 1969). In addition, database researchers have also shown significant interest in verifying database applications using theorem proving (Baltopoulos et al., 2011, Benzaken and Schaefer, 1998, Christiansen and Martinenghi, 2003, Itzhaky et al., 2017, Malecha et al., 2010) and model checking (Abdulla et al., 2016, Calvanese et al., 2018, Deutsch et al., 2014, Gligoric and Majumdar, 2013, Vianu, 2009, Wang et al., 2017, Jana et al., 2018a). Apart from this, there have also been some proposals based on testing (Artzi et al., 2010, Chays et al., 2000, Emmi et al., 2007, Wassermann et al., 2008), equivalence checking (Chu et al., 2018, Chu et al., 2017), schema refactoring (Caruccio et al., 2016, Visser, 2008) as well as synthesis (Feng et al., 2017, Wang et al., 2019).

The authors in Itzhaky et al. (2017) propose an approach for verification of web applications embedded with SQL. This requires the translation of embedded SQL scripts into SmpSL functions followed by the computation of verification conditions of SmpSL functions using weakest precondition. The purpose is to verify integrity constraints defined on the underlying database. The limited expressibility of SmpSL does not cover aggregate functions or arithmetic operations. Integrity constraints verification in the object-oriented database programming language O
 is proposed in Benzaken and Schaefer (1998). For a given method m and constraint C, m cannot violate C if 
 or 
⃖
, where 
 is a postcondition for a given precondition  and 
⃖
 is a precondition for a given postcondition . The proposed approach computes verification conditions using either weakest precondition or strongest postcondition computations. Authors in Christiansen and Martinenghi (2003) propose integrity constraints verification for database applications using transformation operators. The proposed approach expresses every update operation as a predicate U  
, where 
 denotes a sequence of constants. Integrity constraints are defined in a constraint theory . The function after
 translates the constraint theory to the weakest precondition of  with respect to the update U and a simplified formula is obtained by applying function Simp
. The resultant formula is executed as a query and if it returns empty then the database is consistent, otherwise the returned tuple provides hints for extending the update in order to restore the consistency. Verification of database integrity constraints using refinement types is proposed in Baltopoulos et al. (2011). The proposed tool maps an SQL schema S to a Stateful F7 module 〚〛 by using a sequence of type definitions, predicate definitions, and function signatures. User transactions are written using the functional language F#. Verification of integrity constraints starts by generating a set of verification conditions from F# and SQL codes, which are then passed to an automatic theorem prover. Unfortunately, the syntax of SQL considered in the proposed work does not include nested queries or aggregate functions. An in-memory relational database management system (RDBMS) fully verified using Coq has been proposed in Malecha et al. (2010). The authors mainly verify whether or not the RDBMS correctly executes queries w.r.t. the denotational semantics of SQL and relations.

Verification of the functional correctness of database-driven applications using model checking is proposed in Vianu (2009). The author introduces the WAVE tool, which allows the users to specify functional correctness properties using LTL formulas and verify a given database-driven application against these functional properties. The authors in Abdulla et al. (2016) consider the verification of monadic second-order properties of runs in a model where the underlying database can be updated by insertion or deletion. Decidability is obtained for recency bounded artifacts, in which only recently introduced values are retained in the current data. A theoretical approach for the verification of database-driven systems is proposed in Calvanese et al. (2018), where the authors use symbolic model-checking via model completions (equivalently, via covers). Interesting works on real-time and distributed systems using temporal logic to obtain verification models are proposed in Souri and Norouzi (2015) and Souri et al. (2019b). The correctness verification of service composition methods in a multi-cloud computing environment based on event-based QoS factors is presented in Souri et al. (2019a).

Our work draws motivation from da Cruz et al., 2012, Frade and Pinto, 2011 and Lourenço et al. (2015). In da Cruz et al., 2012, Frade and Pinto, 2011 and Lourenço et al. (2015), the authors describe in detail all three approaches, namely symbolic execution, conditional normal form, and weakest precondition, to generate VCs for imperative languages. Our work can be seen as an extension of the latter approach to the case of database applications.

9. Conclusions
This work contributes towards the verification of database applications by proposing a set of comprehensive techniques to generate Verification Conditions from database programs. With respect to the literature, the proposed approach shows its ability to support crucial SQL features along with its embedding into other host imperative languages and allow for the verification of common database properties. We also introduce DBverify, a verification tool implemented in Python based on our theoretical foundation, which enables users to verify PL/SQL procedures under three different approaches. The detailed performance analysis based on the experimental results on a set of benchmark PL/SQL codes demonstrates the effectiveness of the approaches under various circumstances. Notably, the performance of the CNF algorithm is observed better than the other two approaches in all the cases. For the given set of PL/SQL codes with chosen properties, the experimental results show that only 38% of the benchmark procedures satisfy the annotated database properties, while 62% of procedures violate either all or part of the annotated properties. The primary cause for the latter case is acceptance of runtime inputs in SQL statements without any proper checking.

CRediT authorship contribution statement
Md. Imran Alam: Conceptualization, Methodology, Prototype tool development, Benchmark codes preparation, Writing - Original and revised draft preparation, Validation. Raju Halder: Conceptualization, Supervision, Writing - review & editing, Validation. Jorge Sousa Pinto: Supervision, Writing - reviewing, Validation.

Appendix.
A.1. Proofs
Lemma 2

Let  be the logical encoding of an execution path  up to program point . Let 
 be a DSA form of program statement at program point . Let  be the logical encoding computed using the function Path, 
. The function Path is correct if 
, 
, 
⊧
 under interpretation  and 
〚
〛
, 
, 
, implies 
, 
⊧
.

Proof

The proof is established based on structural induction. Assume that 
, 
 satisfies  under the interpretation , i.e. 
, 
⊧
.

•
Assignment Statement 
≔
. Let 
〚
≔
〛
, where 
 is obtained by substituting all occurrences of 
 in 
 by 
 〚
〛
. Since 
 does not involve 
, its semantics are same w.r.t. both the states 
 and 
. Therefore, (15)
⊧
On the other hand, since 
 is not present in  due to DSA property and only 
 is affected in 
, we have (16)
⊧
Combining Eqs. (15), (16), we get 
, 
⊧
.

•
Database Statements Q. Since a database statement Q involves action ‘A’ and condition ‘cond’, this can be treated as a guarded command equivalent to “if  then A”. Consider the DSA form 
≔
, 
 of different database statements. By the definition of the function Path, we have: 
≔
≔
≔
 Let us now prove the lemma for each database action:

–
≔
, 
 
. Given a state 
, 
, assume that 
〚
〛
. By the definition of the function Path, we have 
 Since 
⊧
 and  does not involve 
 due to DSA property, the following holds (17)
⊧
Now we have two possibilities: either 
 ⊧
 or 
⊧
. In the former case, the action 
≔
 results into the same semantics for 
 and 
 w.r.t. 
, i.e. 
〚
〛
〚
〛
. Therefore, (18)
⊧
 In the latter case, the attributes 
 in 
, where 
, are substituted by 
〚
〛
 respectively. Since only the value of 
 is affected in 
, we have 
〚
〛
〚
〛
, and therefore (19)
⊧
Hence, combining Eqs. (17), (18), (19), 
, 
 ⊧
 is proved.

–
≔
 . Given a state 
, 
, assume that 
〚
〛
. By the definition of the function Path, we have 
 Since 
⊧
 and  does not involve 
 due to DSA property, we have (20)
⊧
According to the action 
≔
 in 
, the semantics of 
 and 
 
 w.r.t. 
 are same, i.e., 
〚
〛
〚
〛 
. Therefore, (21)
⊧
However, according to the second action 
≔
, a single tuple containing values 
 〚
〛
 corresponding to attributes   
 where 
 is inserted into the database. Since only the value of 
 is affected in 
, we have 
〚
〛
〚
〛
, 
, and therefore (22)
⊧
 Hence, combining Eqs. (20), (21), (22), 
, 
 ⊧
 is proved.

–
≔
 
. Given a state 
, 
, assume that 
〚
〛
. By the definition of the function Path, we have 
 Since 
⊧
 and  does not involve 
 due to DSA property, the following holds (23)
⊧
Like previous cases, we have two possibilities: either 
⊧
 or 
⊧
. In the former case, similar to Eq. (6), we have (24)
⊧
While in the latter case, tuples satisfying 
 are removed from the database table. Therefore, 
⊧
 is proved.

–
≔
, 
. Let 
〚
〛
, 
. According to the Path function, we have 
. Following the similar direction as above, we can easily prove 
 ⊧
 by taking the following facts into the consideration:

(a)
The affected application variable 
 is not involved in , so 
⊧
.

(b)
When 
⊧
 then 
⊧

(c)
When 
⊧
 then 
⊧
. □

Theorem 5

Given an annotated program 
; ; assert 
. If the verification condition 
  wp(, 
) is valid, then  satisfies the property 
 and vice versa.

Proof

The proof is based on structural induction on . Recall the definition of wp in Fig. 16 and let  
. We have to prove that, if 
, 
⊧
 and 
 and 
 and 
〚〛
, then 
⊧
. Let us now consider the different cases:

•
Assignment  ≔. Let 
, 
⊧
. According to the definition, wp ≔
. Assume that 
. Therefore, (25)
⊧
 According to the transition semantics, assume 
 〚≔〛
 such that 
 where 
〚〛
. Since, in 
 all occurrences of x are replaced by , according to Eq. (25), we have 
⊧
. Assuming 
, this case is proved.

•
Q
≔
. Let 
⊧
. According to the definition, 
≔
, 
. Assume that 
. Therefore, (26)
⊧
 According to the semantics function, let us assume 
〚
〛
, where

(i)
Values of 
 will be updated by 
〚
〛
 for the tuples satisfying ‘’. That is, like assignment statement, we have (27)
⊧
⊧

(ii)
Values of 
 will remain unchanged for those tuples which do not satisfy ‘’. That is, (28)
⊧
⊧

Combining Eqs. (26), (27), (28), the lemma is proved for Q
 assuming 
.
•
Q
≔
. According to definition of wp, wp 
≔
, 
. Let 
, 
⊧
 and 
. Then, (29)
⊧
Now given 
〚
〛
, we have two cases:

(i)
Values of existing tuples will remain unchanged.Therefore, (30)
⊧
⊧

(ii)
For the newly inserted tuple, we have (31)
⊧
⊧

Assuming 
, and combining Eqs. (29), (30), and (31), the lemma is proved for Q
.
•
Q
≔. Let 
, 
⊧
. According to the definition of wp, wp 
≔, 
. Assume 
⊧
 and 
⊧
. Therefore, (32)
⊧
Let 
〚
〛
. Since the tuples which remain intact in the database after the DELETE action, do not satisfy ‘’, therefore, 
⊧
 when 
⊧
. Assuming 
, the lemma is proved for Q
.

•
Q
≔
. Since the SELECT statement does not affect any database attributes, this case can be proved easily as 
 and 
 only involve database attributes. □