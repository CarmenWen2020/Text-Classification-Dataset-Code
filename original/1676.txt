Abstract
Gas is a measurement unit of the computational effort that it will take to execute every single replicated operation that takes part in the Ethereum blockchain platform. If a transaction exceeds the amount of gas allotted by the user (known as gas limit), an out-of-gas exception is raised and its execution is interrupted. One of the main open problems in the analysis of Ethereum smart contracts is the inference of sound bounds on their gas consumption.

We present, to the best of our knowledge, the first static analysis that is able to infer sound parametric (i.e., non-constant) gas bounds for smart contracts. The inferred bounds can be parametric on the sizes of the input parameters for the functions, but also they can be parametric on the contract state, or blockchain data. Our gas analysis is developed at EVM bytecode level, in which Ethereum gas model is defined.

Our analysis is implemented in a tool named Gastap, Gas-Aware Smart contracT Analysis Platform, which takes as input a smart contract and automatically infers sound gas upper-bounds for its public functions. Gastap has been applied over 318,093 functions fetched from the Ethereum blockchain, and succeeded to obtain gas bounds for 90.24% of them.

Previous
Next 
Keywords
Smart contracts

Resource analysis

Static analysis

Decompilation

1. Introduction
In the Ethereum consensus protocol, every operation on a replicated blockchain state, which can be performed in a transactional manner by executing a smart contract code, costs a certain amount of gas (Wood, 2014). Gas has a monetary value in Ether, Ethereum’s currency, and it is paid by a transaction-proposing party. Computations (initiated by a protocol client invoking a smart contract) that require more computational or storage resources, cost more gas than those that require fewer resources. As regards storage, the Ethereum Virtual Machine (EVM) has three areas where it can store items: (a) the storage is where all contract state variables reside, every contract has its own storage and it is persistent between external function calls (transactions) and quite expensive to use; (b) the memory is used to hold temporary values, and it is erased between transactions and thus is cheaper to use; (c) the stack is used to carry out operations and it is free to use, but can only hold a limited amount of values.

The rationale behind the resource-aware smart contract semantics, instrumented with gas consumption, is three-fold. First, paying for gas at the moment of proposing the transaction does not allow the emitter to waste other parties’ (aka miners) computational power by requiring them to perform a lot of worthless intensive work. Second, gas fees disincentivize users to consume too much of replicated storage, which is a valuable resource in a blockchain-based consensus system. Finally, such a semantics puts a cap on the number of computations that a transaction can execute, hence prevents attacks based on non-terminating executions (which could otherwise, , make all miners loop forever).

The gas-instrumented operational semantics of EVM has introduced novel challenges  sound static reasoning about resource consumption, correctness, and security of replicated computations: (i) While the EVM specification (Wood, 2014) provides the precise gas consumption of the low-level operations, most of the smart contracts are written in high-level languages, such as Solidity (Ethereum, 2018b) or Vyper (Ethereum, 2018c).

The translation of the high-level language constructs to the low-level ones makes static estimation of runtime gas bounds challenging (as we will see throughout this paper), and is implemented in an ad-hoc way by state-of-the art compilers, which are only able to give constant gas bounds, or return  otherwise. (ii) As noted in the recent study by Grech et al. (2018) and Foundation (2018), in general it is dangerous for a smart contract to make its gas consumption dependent on the size of the data it stores (, the contract state), as well as on the size of its functions inputs, or of the current state of the blockchain. However, according to our experiments, almost 10% of the contract functions we have analyzed feature such dependencies. Note that there are a number of situations that, without having iterative code in the Solidity code, the Solidity compiler produces a loop at EVM bytecode level. These “hidden” loops might come from functions that receive as parameters arrays or strings, the size of the message data, or the length of data structures in storage. Let us show an example:


Download : Download high-res image (51KB)
Download : Download full-size image
The gas consumed by function f does not only depend on the length of values as it can be expected by looking at the source code. The EVM program obtained from this Solidity program includes two hidden loops: one that copies the contents of values in memory (loop 
); and another one that traverses all elements stored in data for setting them to 0 (loop 
). The use of resource analysis techniques at the level of the EVM allows us to infer the following accurate and sound upper-bound expression that accumulates the costs of these two hidden loops:  
 
 
  
 
 
  
 
 
 . The inability to soundly estimate the cost, and the lack of analysis tools, might lead to design mistakes, which make a contract unsafe to run or prone to exploits. For instance, a contract whose state size exceeds a certain limit, can be made forever stuck, not being able to progress. Those vulnerabilities have been recognized before, but only discovered by means of unsound, pattern-based analysis of control-flow graphs (Grech et al., 2018).

In this article, we address these challenges in a principled way by developing a new static analysis that is able to infer parametric gas bounds for smart contracts. The upper-bounds we infer are given in terms of the sizes of the input parameters of the functions, the contract state, and/or on the blockchain data that the gas consumption depends upon (, on the Ether value effective at the moment when the corresponding transaction takes place). The inference of gas requires complex transformation and analysis processes on the code that include: (1) the construction of the EVM control-flow graphs and the decompilation of low-level EVM bytecode to a higher-level rule-based representation of the program; (2) the special treatment of EVM data types (e.g., strings and bytes are challenging to deal with) and its storage and memory model; (3) the definition of a static cost-model that captures the gas consumed by the program and that can be plugged within state-of-the-art cost analysis tools; (4) the implementation effort to take advantage of off-the-shelf analysis tools that are able to compute parametric bounds for the input program.

A challenging aspect in the definition of the gas bounds analysis has been the approximation of the EVM gas model (which is formally specified in Wood (2014)). This is because the EVM gas model is highly complex and unconventional. The gas consumption of each instruction has two parts: (i) the memory gas cost, if the instruction accesses a location in memory which is beyond the previously accessed locations (known as active memory (Wood, 2014)), it pays a gas proportional to the distance of the accessed location. (ii) The second part, the opcode gas cost, is related to the bytecode instruction itself. This is quite challenging to infer as, somewhat counter-intuitively, it is not always a constant, but might depend in some cases on the current state of a contract and the blockchain. Our analysis is able to soundly approximate both components: the former is estimated by means of an instance of a peak resource analysis (Albert et al., 2015b, Hoffmann et al., 2011) and the latter using a parametric cost model within standard resource analysis (Wegbreit, 1975).

The analysis is implemented in a tool named Gastap, a Gas-Aware Smart contracT Analysis Platform, which is, to the best of our knowledge, the first automatic and sound gas analyzer for smart contracts. Gastap takes as input a smart contract provided in Solidity source code (Ethereum, 2018b), or in low-level (possibly decompiled (Suiche, 2017)) EVM code, and automatically infers upper-bounds on the gas consumption for each of its public functions. Fig. 1 provides an overview of the architecture of our analyzer and its different components will be introduced throughout the paper. Gastap has a wide range of applications for contract developers, attackers and owners, including the detection of vulnerabilities, debugging and verification/certification of gas usage. For contract developers and owners, a precise resource analyzer makes it possible to answer the following query about a specific smart contract: “what is the amount of gas necessary to safely (, without an out-of-gas exception) reach a certain execution point in the contract code, or to execute a function?” This can be used for debugging, verifying/certifying a safe amount of gas for running, as well as ensuring progress conditions. Besides, Gastap allows calculating the safe amount of gas that one must provide to an external data source (, contracts using the popular Oraclize service (Bernani, 2016)) in order to enable a successful asynchronous callback in a forthcoming separate response transaction. On the other hand, a rational attacker, can use a resource analysis in order to estimate how much Ether (in gas), they have to pour into a contract in order to execute the Denial-of-Service attack. We note that such an attack may, however, be economically impractical (Grech et al., 2018).

1.1. Summary of contributions
1.
Rule-based representation of EVM code. The starting point for our analysis is EVM bytecode from which a control flow graph (CFG) is obtained by our tool. This has required the implementation of an address analysis that figures out all possible jumping addresses. From the CFG, the box RBR generation of Fig. 1 provides the decompilation from EVM bytecode to a high-level Rule-Based Representation (RBR) that enables subsequent static analysis on the EVM code. Our decompiled programs represent explicitly the local and state variables, the operand stack, and blockchain data, by means of rule parameters.

2.
Handling EVM data and storage/memory model. In Section 4, we will describe the box GAS RBR refinement of Fig. 1 that by means of a number of program transformations in the RBR allows us to handle the specific features of EVM programs. In particular, we are able to handle strings and bytes — what is fundamental to achieve a precise gas analysis of EVM programs. The transformation in this case consists in retrieving the sizes of these data types and making them visible within the variables of the RBR. Another transformation is performed in order to represent the storage and memory accesses within the RBR program so that we can infer information on them in the subsequent analysis.

3.
Opcode gas bounds. In order to be able to apply a cost analysis framework to infer gas upper-bounds, we need to provide the definition of the gas operations cost model which (over-)approximates the gas usage of every EVM bytecode instruction. Over-approximation is needed because the gas model of EVM (Wood, 2014) is declared for concrete executions in which the state is fully instantiated (e.g., the gas cost of EXP varies logarithmically depending on the value of operand on which it is applied, the gas cost of SSTORE varies depending on whether the value to be stored is equals to zero or not). However, in order to statically infer gas bounds, we need to provide a static, parametric, gas model that soundly defines the gas cost for any concrete state that might arise during the execution.

4.
Memory gas bounds. The memory gas costs are computed separately in our framework by using a non-standard cost analysis. As we will explain, the inference of memory gas bounds boils down to inferring the address of the highest slot of memory accessed and, then, instantiating this value within the formula for the memory gas cost. We propose to infer this highest slot by means of a peak resource analysis (Albert et al., 2015b). As we will describe in Section 5.2, this can be done by means of a transformation within the RBR which annotates – using acquire declarations – the memory address accessed. The peak analysis then infers the peak value of all the acquire annotations, hence obtaining the highest slot accessed that we need.

5.
Implementation and experimental evaluation. Finally, Section 6 describes our experimental evaluation: we have analyzed more than 34,000 real smart contracts, and have succeeded to analyze 318,093 public functions and inferred gas bounds for 90.24% of them in 407.5 h. Gastap can be used from a web interface at https://costa.fdi.ucm.es/gastap.

Basically, the first contribution (item 1 above) enables using a standard resource analyzer but it requires solving the unique problems presented by smart contracts that are the contributions listed in item 2 (i.e., handling its storage/memory model and data), item 3 (providing a static definition of the gas operations cost model), and item 4 (developing new techniques to infer the memory gas costs).

A preliminary version of the decompilation phase in Section 3 appeared as a tool demonstration paper in the proceedings of ATVA’18  (Albert et al., 2018) and a first description of the basic components of the gas analyzer appeared in the proceedings of VECoS’19 (Albert et al., 2019). This article provides the formal basis for these tools and formally describes all the steps carried out in the analysis: namely we formalize a rule-based representation and a new gas-aware semantics that can be used for multiple purposes beyond gas analysis; as another novelty w.r.t. the previous publications, we present the extensions in item 2 above to handle the particularities of EVM code within static analysis; and we give a formal definition of the gas cost model (item 3) and the computation of the memory gas bounds by relying on existing cost analysis techniques. Beyond the formal contributions, we have also improved the experimental evaluation of Albert et al. (2018) and  Albert et al. (2019) significantly, since the former versions of our tool were relying on (Luu et al., 2018) to build the CFGs (that could be incomplete and was failing in many examples) and we have now fully implemented the CFG generation. Besides, we have applied our tool to more contracts (namely to the top-valued 300 contracts whose Solidity code was available) and assessed the accuracy of the upper bounds obtained for the analyzed functions by comparing them with the actual gas cost of real transactions.

2. Preliminaries: Stack-sensitive control flow graphs
The EVM language is a simple stack-based language with words of 256 bits with a local volatile memory that behaves as a simple word-addressed array of bytes, and a persistent storage that is part of the blockchain state. A more detailed description of the language and the complete set of operation codes can be found in Wood (2014). In this section, we only describe the (Stack-Sensitive) CFGs from which our contribution starts. As usual, the computation of the CFG is based on the notion of block. In general Aho et al. (2006), given a program , a block is a maximal sequence of straight-line consecutive code in the program with the properties that the flow of control can only enter the block through the first instruction in the block, and can only leave the block at the last instruction. In the case of EVM programs, blocks are split by using jumping instructions, jump destinations and ending instructions like RETURN, INVALID or REVERT. One significant difference between the EVM and other virtual machine languages (like Java Bytecode or CLI for .Net programs) is the use of the stack for saving the jump addresses instead of having them explicit in the code of the jumping instructions. In EVM, instructions JUMP and JUMPI will jump, unconditionally and conditionally respectively, to the program counter stored in the top of the execution stack. The difficulty is that the address might have been stored in a different block, as we will show in the example below. This happens for instance when a public function is invoked privately from other methods of the same contract, the returning program counter is introduced by the invokers at different program points and it will be used in a unique JUMP instruction when the invoked method finishes in order to return to the particular caller that invoked that function. This feature of the EVM requires, in order to obtain the control flow graph of the program, to keep track of the information stored in the stack and compute the different stack sizes with which the blocks can be reached.

Following Brent et al., 2018, Grech et al., 2018, Grech et al., 2019, in order to precisely infer the possible addresses at jumping program points, we need a context-sensitive static analysis that analyzes separately all blocks for each possible stack that can reach them (only considering the addresses stored in the stack). This context-sensitive analysis information is used to compute a stack-sensitive control flow graph () of the form  in that, for producing the set of vertices , we replicate each block for each different stack state that could be used for invoking it (e.g. gray nodes in Fig. 2 are cloned in the ) and the corresponding edges  are replicated according to the replicated blocks. Each block in  has the form 
, where  is the program counter of the first instruction of the block and  is a numeric identifier for the clone. For those blocks which are not cloned, we use 0 as identifier and omit it when it is clear from the context. We also use function , which returns the size of the stack at program point  for the clone identified with . A precise definition of this phase and the assumed function  is available in an online technical report (Albert et al., 2020a). There are some cases in which this analysis is not able to generate an , mostly due to the use of recursion and higher-order programming in Solidity. Importantly, the analysis is incomplete but sound: if an  is generated for a given EVM program , then for each execution trace of  there exists a corresponding path in the  that correctly represents it (proofs of soundness the -generation can be found at the above cited technical report (Albert et al., 2020a)).


Download : Download high-res image (538KB)
Download : Download full-size image
Fig. 2. Excerpt of Solidity code for EthereumPot contract and its .

Example 1

In order to describe our techniques, we use as running example method findWinner extracted from the EthereumPot contract (EthereumPot, 2017) that implements a lottery system. Fig. 2 shows the blocks (nodes) obtained for findWinner and their corresponding jump invocations. Solid and dashed edges represent the two possible execution paths depending on the entry block: solid edges represent the path that starts from block  and dashed edges the path that starts from . Interestingly, these two paths end in block , where we have a JUMP (marked with ✩) that takes the return address from function findWinner. If findWinner is publicly invoked, it jumps to address  (pushed at block  at ) and if it is invoked from function __callback it jumps to  (pushed at block  at ). The  includes non-replicated nodes for those blocks that only receive one possible stack state (white nodes in Fig. 2). However, the nodes that could be reached by two different stack states (gray nodes in Fig. 2) are cloned in our . For example, the  includes 
, 
, 
 and 
. The edges also consider the different replicas of the nodes and we have 
 and 
.  ■

3. From the S-CFG to a high-level rule-based representation
This section presents the process of obtaining a high-level rule-based representation (RBR) from the  described inSection 2. This part of the analysis, has been implemented as a standalone tool, EthIR (Albert et al., 2018), to facilitate its integration into other tools and corresponds to the RBR generation box in Fig. 1. Given a , it provides a set of rules that contain a high-level representation of all bytecode instructions in the block (, a PUSH operation is represented as an assignment to a stack variable). The rules have as parameters an explicit representation of the stack as well as of the memory, storage and blockchain data. Conditional branching in the CFG is represented by means of guarded rules that contain mutually exclusive boolean guards. The grammar of the RBR language into which the EVM is translated is as follows:


Download : Download high-res image (117KB)
Download : Download full-size image
We assume that all instructions  in the RBR rules are of the form  where  is a unique program point identifier in the RBR program and  is either an assignment or a  instruction. In what follows, we will ignore the program point unless it is required. Note that, the program point of the RBR does not correspond to the program counter of the original EVM program because some blocks have been replicated. The left hand side of RBR rules has the form 
 
, where 
 
 are parameters that can be of the following types:
1.
Stack variables (
 
): A relevant ingredient of the transformation is that the stack is flattened into explicit variables, , the different stack elements used by the instructions are modeled by using different variables 
, where 
 represents the top of the stack. The stack is explicitly received by the rules as parameters 
 and denoted as 
 and its size for any block 
 is obtained from function . We use  to refer to the set of all stack variables used in the program.

2.
Memory variables (): We use the array  (that has a size of 
 elements, like the maximum memory size) to model the content of the local memory of the transaction. The memory position to be accessed is pushed in the stack, hence accesses to the array will use as index a stack variable 
, i.e., 
 accesses the memory location stored in 
.

3.
State variables (): We also model the contract state variables by means of an array  (again with 
 elements, as the maximum storage size). As for memory, it is indexed using the stack variables as follows 
, where stack variable 
 contains the address involved in the operation.

4.
Blockchain data (): We model blockchain data using a mapping , where  is the name of a blockchain variable that represents the environmental or blockchain data, as   or . All these data are accessed through dedicated opcodes, which may consume some offsets of the stack and normally place the result on top of the stack (some of them, like CALLDATACOPY, can besides store information in the local memory). We will extend the notation to refer to additional parameters for some environmental information, as  
 to refer to the access to the word of the message call input data pointed by 
. We use  to refer to the set of names of blockchain variables.

3.1. RBR generation
The starting point of the RBR generation is the CFG for the bytecode as described in Section 2. Intuitively, for each block in the CFG, we produce an RBR rule and the edges in the CFG induce the invocations between the different rules. Besides, each bytecode is transformed into a corresponding high-level instruction and an associated  storing the original EVM operation. EVM instructions are kept in the RBR so as to precisely compute the gas cost of executing the original EVM instructions. The following definition formalizes the transformation of each EVM bytecode instruction into RBR instructions:

Definition 1 RBR Instructions

Given an EVM instruction of the form 
 where  is the EVM bytecode and  is the program counter in the EVM program, we define function 
 as follows: 
where  and 
 is defined for some representative EVM instructions as follows:


Download : Download high-res image (121KB)
Download : Download full-size image
 ■
It can be seen that function  translates each bytecode into two different components: (1) it applies function 
 to produce the corresponding high-level assignments between the RBR variables; and (2) it adds to the RBR the original bytecode instruction by simply wrapping it within a  functor. Observe that function 
 transforms EVM instructions into assignments between explicit stack variables (see PUSH, DUP or SWAP), converts arithmetic operations into the same operations between elements in the stack, boolean operations are transformed into functions, or accesses to ,  arrays or to map . We now formalize the generation of the RBR rules using :

Definition 2 RBR Rules

Given the stack-sensitive control flow graph  of an EVM program , and a block 
 with instructions 
 in , the generated rulesare:


Download : Download high-res image (179KB)
Download : Download full-size image
where , 
.  ■
In the RBR generation we distinguish three cases: (1) if the last bytecode in the block is a conditional jump (JUMPI) we produce two additional guarded rules (with a guard different from ) which represent the continuation when the condition holds, and when it does not; (2) if it is not a conditional jump and the  includes an outgoing edge from the corresponding block, we generate a single rule with a call to the continuation block; and (3) if the block ends in an instruction which terminates the execution, e.g. REVERT or INVALID, we just produce the rule without any call. Note that the number of stack variables  ( for the calls) is determined by the size of the stack at the first instruction of the rule by means of the function  of Section 2.

Example 2

Using Definition 2 to translate blocks  and  in the CFG of Fig. 2 we obtain the following rules:  
 

We can see that some operations produce assignments between the explicit stack variables (e.g. PUSH1, DUP1, …), and that bytecode instructions that operate on storage or memory are transformed into assignments on the involved variables, e.g., SLOAD in block_653_1 is translated into 
. For arithmetic operations, boolean operations, bit-wise operations, etc., the variables they operate on are also made explicit, e.g., LT operates on 
 and 
 and it is transformed into 
. The guards of the rules also make explicit the corresponding condition and the stack variable involved on it (e.g. 
). In this example we have included  guards, however, in the rest of the paper for brevity we will omit them. Observe that conditional jumps are implemented by means of two rules (e.g. ) with the same name and mutually exclusive guards. As explained in Section 2, conditional jumps (JUMPI opcodes) take the two top-most elements from the stack, the jump address and a value (that comes from checking some boolean condition). If the value is 1, then the execution jumps to the opcode located in the address read from the stack and if it is 0 it continues with the next opcode. ■

3.2. A gas-aware semantics
Rules in Fig. 3 define a gas-aware operational semantics for the (EVM) RBR. We use  to denote a non-empty sequence of elements, where  can be the empty sequence, denoted as . An activation record has the form , where  is a rule name,  is a sequence of instructions in , if it is not empty is denoted as  where  is the next instruction to be executed, and  is a mapping of stack variables to their values , where  is the set of all possible values that can be stored in an EVM word, i.e., 
.


Download : Download high-res image (580KB)
Download : Download full-size image
Fig. 3. RBR semantics.

A program state  has the form  where  is a sequence of activation records,  is a mapping of local memory addresses to their values1 ,  is a mapping of storage addresses to their values ,  is a mapping of blockchain variables , and  correspond to the gas consumption accumulated up to the current state of the execution for instructions execution and memory allocation, respectively. Rule (1) handles the assignment of an expression to a stack variable 
. According to the grammar seen before, this expression can be a constant, the contents of a memory or storage address, the contents of a blockchain variable, an arithmetic operation between stack variables, or some other operations represented by a functor as for example 
. Function  evaluates the expression using 256-bit arithmetics with respect to the mappings of stack, memory and storage variables. Rule (2) models the assignment of a blockchain data to a stack variable. Rules (3) and (4) correspond to assignments of stack variables to memory or storage elements. Rule (5) corresponds to the evaluation of a  annotation of any EVM instruction except external calls,  the ones in the set . At this point, the gas consumption  in the program state must be updated with the cost of the corresponding EVM instruction. For this purpose, functions  and  provide the gas consumed by , as defined in Appendix H of Wood (2014), and will be defined on the RBR in Sections 3.3.1 Opcode gas model, 3.3.2 Memory gas model for some representative cases. GAS is the blockchain variable that contains the amount of available gas for the current transaction. If the execution exceeds the gas limit there is no matching rule in the semantics and hence the execution does not progress further (in the blockchain execution it throws an out-of-gas exception). The instructions that correspond to external calls, i.e., those in set , are handled separately by Rule (6). In this case, besides the gas consumed by the instruction itself, the gas limit must also consider the gas consumed by the external contract execution. In addition, according to Wood (2014), an external call might change the data stored in memory and storage (for instance, external contracts might perform callback calls to the current contract, possibly modifying storage variables). This is expressed in the semantics by a call to the function , that returns a tuple 
 that contains the state of the local memory and the storage after executing the external call, as well as the gas consumed by the executed contract, respectively. Rule (7) evaluates a call to a rule in the RBR. A fresh activation record is created containing the code of the called rule, and the argument values are passed to it. Finally, Rule (8) corresponds to the termination of an activation record.

Program execution.
The execution of a function  of a smart contract starts from an initial state 
 of the form 
, where   is the RBR rule for the first block,  is the block code, 
 and 
 represent the empty mappings for stack variables and local variables, respectively, and 
 contains the current mapping of state variables to their values in the blockchain. Additionally,  contains the current state of blockchain variables as well as message data such as the hash code bound to . A trace is of the form 
↝↝
↝
. As we have already mentioned, there are no infinite traces: Rules (5) and (6) guarantee that any execution of a smart contract terminates, as the gas consumed is limited to the amount of gas set in the blockchain variable GAS at the beginning of the execution. Therefore, an execution trace terminates either because it runs out of gas, or the last state of the trace is of the form , where  is the empty sequence of activation records.


Table 1. Definition of Opcode Cost Function.

Fixed		
Cond. Constant	SSTORE	 
 
CALL	
DELEGATECALL	
 
CALLCODE	
 
STATICCALL	
SELFDESTRUCT	 
 
Parametric	EXP	
 
CALLDATACOPY	
CODECOPY	
RETURNDATACOPY	
EXTCODECOPY	
LOGX	
 where X 
SHA3	
Definition 3 RBR Gas Cost

Given a function  of a smart contract with initial storage state 
 and blockchain information , the execution trace of  on  is of the form 
↝↝
↝
 where 
 and its gas consumption is defined as 
.  ■

3.3. The gas cost model
The EVM gas cost model is complex and unconventional. Its computation can be separated into two different components: (1) one part depends on the EVM instruction executed, represented by the function  (described in Section 3.3.1); and (2) another part of the gas consumed is related to the memory consumption represented by function  (described in Section 3.3.2).

3.3.1. Opcode gas model
In this section we focus on the computation of the gas attributed to the EVM instructions. In order to compute the gas fee bound to each opcode, we define the function  that is used in the RBR semantics.

Definition 4 Opcode Cost Function

Given an EVM opcode b, a stack mapping , and a storage mapping ,  is a function defined for the different EVM opcodes in the Table 1.  ■

Observe that  takes three elements, an EVM opcode, the state of the stack and the mapping of state variables when reaching the opcode, and returns the gas consumed by the corresponding instruction. It can be seen that Table 1 in Definition 4 distinguishes between three types of instructions:

1.
Most bytecode instructions have a fixed constant gas consumption. We define the set  
 using the sets defined in Wood (2014) for all these instructions. For example, the gas consumption of  is 1, and the gas consumption of  is 200. We use a generic  in Table 1 to refer to these fixed costs.

2.
Bytecode instructions that have different constant gas consumption 
 or 
 depending on some given condition. This is the case of SSTORE that costs 
20,000 if the storage value is set from zero to non-zero (first assignment), and 
 otherwise. It is also the case for CALL and SELFDESTRUCT. To refer to all these instructions, we define the set  
 

The gas consumption for these EVM opcodes, except SSTORE, in Table 1 (Definition 4) varies with the actual value of blockchain variables such as , , and  (the latter checks if an account is non-existent or it has no code, no activity and zero balance). Observe that the execution cost of the external code invoked by call instructions is not included in this gas model, as it is already captured by means of the function  in Rule (6) in the semantics.

3.
Bytecode instructions with a non-constant (parametric) gas consumption that depends on the value of some stack location. We define the set  
 to include them. A complex case is EXP, whose gas consumption is defined as 
 if 
 (and 10 otherwise), i.e, the gas consumption depends on the value of the exponent, that is stored in 
, accounting for the larger computational effort.


Table 2. Definition of function highest used by memory cost function for EVM bytecodes that operates on memory.

b	
MLOAD	
MSTORE	
MSTORE8	
CALLDATACOPY		
CODECOPY	
RETURNDATACOPY		
EXTCODECOPY	
LOGX	
CALL	
CALLCODE	
DELEGATECALL	
STATICCALL	
RETURN	
REVERT	
SHA3	
CREATE	
3.3.2. Memory gas model
The second component that adds gas to a transaction is the amount of memory accessed. The memory gas of an EVM instruction  is defined in Wood (2014) as the difference 
, where  and 
 denote the highest memory slot accessed in the local memory before and after the execution of , respectively, and 
 is a function that, for a given memory slot , is defined as 
 
The cost computed for all the EVM instructions is accumulated to obtain the final memory cost. Column 
 in Table 2 shows how 
 is computed in Wood (2014), given an EVM instruction , the local state of the stack , and the actual highest memory slot accessed . It uses an auxiliary function , defined as follows:  
 

It can be seen that, besides MLOAD or MSTORE, instructions like SHA3 or CALL, among others, use the local memory, and hence can increase the memory gas cost.

In our semantics, the maximum cost is computed by Rules (5) and (6) of Fig. 3. Hence, the function  has to infer only the memory gas of the slot being accessed by each operation executed in the program.

Definition 5 Memory Cost Function

Given an EVM opcode b, and a stack mapping ,  is defined as 
where  is defined in Table 2, and function 
 is defined as 
 

The last column of Table 2, , shows the computation of the highest memory slot accessed by the EVM instruction  in the RBR semantics. Note that 
 is replacing the original  above with the only difference that the computation of the maximum is extracted from it and computed by Rules (5) and (6). Hence, 
 returns 0 if  instead of the highest slot of memory accessed up to this point as  does, and the maximum cost is kept thanks to the  function in Rules (5) and (6).

4. GAS-RBR : RBR transformations for gas analysis
An RBR program, together with its instrumented semantics, allows dynamically computing the gas consumption of concrete EVM transactions. However, in order to enable the use of existing analyzers for statically inferring gas bounds that are sound for any transaction, we need to make some transformations into the RBR. Section 4.1 details the adaptations in the RBR to model the local memory and the storage accesses by means of local variables. This allows that a resource analysis that only handles local variables can be used to infer gas on EVM programs, without requiring specific extensions for the EVM memory and storage models. Besides, as the contents in the storage and in the memory can be modified when a call to another contract is executed, in Section 4.2 we describe some additional transformations. Finally, in Section 4.3 we will see how RBR programs are transformed to abstract strings and byte arrays into their sizes, enabling a resource gas analyzer to deal with them.

4.1. Flattening the storage and memory locations
It is well known that shared mutable data structures, such as those stored in the heap, are the bane of formal reasoning and static analysis and most tools are not able to keep track of object fields nor of array contents. As we have seen in Section 3.2, the RBR semantics models the local memory and storage with arrays, imitating their treatment in EVM programs. Inspired by the ideas of Albert et al. (2014), we aim at flattening memory/storage allocated data by means of variables that contain the contents of particular addresses of the memory/storage. This avoids the need of extending resource analyzers with a complex treatment for reasoning on array contents. Our proposal consists in analyzing the addresses used in the load and store instructions, , MLOAD, MSTORE, SLOAD and SSTORE, to identify those addresses accessed that are trackable. Basically, if the load/store instruction always accesses the same address, we use a explicit variable for modeling this location and otherwise we do not track it. Existing heap and pointer (Andersen, 1994, Steensgaard, 1996, Yong and Horwitz, 2004) analyses could be applied to gain accuracy in modeling these accesses. As this is not the goal of our analysis, we just assume the following: (1) 
 (
) is a set of the form {
} ({
}, respectively) containing all memory (storage) variables identified by the analysis; (2) given a program point  with instruction MLOAD or MSTORE, function  returns a variable of the form 
 when the address accessed at  can be uniquely identified by the analysis or  when it cannot be identified; and, (3)  returns 
 or  analogously.

By means of these functions, the GAS-RBR program can be refined to, instead on including ,  accesses as we have in the RBR, include the concrete variables identified by the analysis, modifying the corresponding RBR instructions to use them. The following definition illustrates the refinement of the RBR to deal with flattened memory and storage accesses. Besides, we use 
 to represent all blockchain variables that can be extracted.

Definition 6 GAS-RBR Rule Refinement #1

Given an RBR rule of the form 
 
 
 the refined GAS-RBR rule is computed as follows: 
 
 
 where function 
 is defined in Box I .  

Observe that MLOAD and SLOAD RBR instructions are replaced by an assignment of the concrete memory/storage variable to its destination stack variable when the concrete variable can be tracked. However, when the address is not known, we assign function fresh to model the lack of information about its content. We use fresh() to denote a generator of fresh variables to safely represent the unknown value of the corresponding addresses. Analogously, MSTORE and SSTORE are replaced by assignments to the particular memory or storage variable. The treatment when the address accessed by an MSTORE or SSTORE is unknown extends to all memory/storage variables, respectively. As the destination of the assignment is not known, we have to “forget” all memory contents (or storage, respectively) from that point on, since the writing may affect any memory location (or storage location, respectively) and it is not sound any more to rely on the previously collected information. Our implementation though is able to detect the positions in which the length of the arrays is stored and it does not forget it (this is safe as this length cannot be modified when the bytecode has been obtained by compilation from a Solidity code). Keeping this length is crucial for the accuracy of the gas analysis.

Example 3

Function  applied to program points  and  in block  in Fig. 2 returns 
 as the EVM instructions SSTORE and SLOAD located in these program points always operate over the same state variable. In these cases, the storage address 10 (0x0a in hexadecimal) is located in the stack with the EVM instructions PUSH1 0x0a. After that, it is used by SSTORE and SLOAD to access to the 11th slot of storage (represented by 
). Something similar happens when function  is applied to program point  in block , that returns 
. However if we apply  to the SLOAD located at program point , we obtain  as it is loading a different storage location at each iteration of the loop (it accesses the storage address generated by the previous SHA3 instruction as it is traversing the array slots of Fig. 2).

If we consider only the blocks in Fig. 2, function 
 and 
. These variables are added to the head of the rules. For instance, the rule for block 653 in Example 2 now is:  
 hence a resource analyzer that works on integer variables can reason on the contents of memory/storage/blockchain data without requiring specific extensions.  ■

4.2. External calls
External contracts are invoked by the EVM instructions CALL, CALLCODE, DELEGATECALL, STATICCALL and handled by Rule (6) in the semantics. In these cases, the address of the invoked contract is passed as an element on the stack, and the actual code might only be known at run-time. There are three aspects to be taken into account when analyzing a contract with external calls: the gas consumed by the invoked contract, the existence of callbacks, and the return value. We focus on the gas consumption of the execution of a single contract and thus we do not add the gas consumed by external contracts which, on the other hand, might only be known at run-time. Regarding the second aspect, since an external call might make in turn a call to the invoking contract to execute some of its functions (this is known as a callback), we do have to consider that the external code, whose code is unknown at analysis time, might modify the storage of the invoking contract. In order to be sound, the GAS-RBR program must therefore “forget” any previous value of the storage, as we have done when a SSTORE accesses an unknown storage address. Finally, the results returned by external calls are stored in a sequence of positions of the local memory of variable length known at run-time. Therefore, we also have to assign to fresh any previous value of the local memory. The following refinement on the RBR is done to soundly approximate possible modifications performed in the memory and the storage due to an external call. Note that we apply this refinement on an RBR already refined.

Definition 7 GAS-RBR Rule Refinement #2

Given an RBR rule of the form 
 
 
 the refined GAS-RBR rule is computed as follows: 
 
 
 where function 
 is defined as follows


Download : Download high-res image (45KB)
Download : Download full-size image
 ■
In this case, the refinement described in Definition 7 has to maintain the original nop functors represented by the instructions 
 and 
 as they are needed to compute the gas consumed.

4.3. String and byte arrays
Solidity storage variables of types string and bytes are particular cases of Solidity dynamic arrays that are challenging for resource analysis because the way they are stored by the EVM depends on their actual sizes. In particular, if they are shorter than  bytes, their data is stored packed in the word of the storage slot corresponding to that variable together with its length. Otherwise, the slot word just contains the length and the data contents are stored at the address obtained like for standard arrays.

Typically loops that traverse data structures have a cost that is proportional to the size of the data structure being traversed. Hence, resource analyzers use a size analysis to (over-)approximate the size of the data structures of the program and then bound the number of iterations of loops and infer upper-bounds for them. In our language, inferring the size of the arrays and strings is crucial for obtaining precise results in the gas analysis. Unfortunately, the instructions used to access the length of these packed arrays include bit-wise operations, among others, that state-of-the-art size analysis cannot handle. Standard size analysis works for the case of unpacked string and bytes. Developing a specific size analysis for this purpose would be challenging and, besides, it is unnecessary as the issue can be solved by means of a simple transformation as follows. We match in the rules of the RBR the particular sequence of instructions generated by the compiler (which are always the same) that start by pushing the contents of the string or bytes variable at the top of the stack, and then obtaining its length, leaving it stored at the top of the stack (at the same position). Every time we find this pattern of instructions applied to a variable of type string or bytes, we remove them from the RBR as we are only interested in their size (keeping their nops to account for their gas). Leaving them would make a size analyzer that is unable to deal with bit-wise operations assume an unknown value and therefore also lose the information that is stored at the top of the stack. Importantly, since the top of the stack indeed contains the size, by removing the remaining instructions, the analyzer is able to handle that stack variable and reason on the size of the string and bytes. In particular, assuming that we have placed the contents of the string or bytes variable at the top of the stack, which is 
, the transformation applied is the following:


Download : Download high-res image (154KB)
Download : Download full-size image
This transformation is applied whenever possible and, , it is needed to infer bounds for the functions getPlayers and getSlots, studied in the experiments reported in Fig. 4. Without this transformation, the tool fails to find gas bounds.
5. Gas analysis of EVM transactions
As we have seen in Section 3.3, the computation of the gas fee can be split into two different parts, one part related to the EVM opcodes executed, and another part that depends on the memory addresses accessed. Likewise, our analysis splits the computation of the gas upper bound 
 of a transaction in two different upper bounds: 
where 
 corresponds to the opcode gas upper-bound that can be computed using a standard resource analyzer (Albert et al., 2015a); and 
 which is the memory gas upper-bound whose computation is performed by means of a peak resource analyzer (Albert et al., 2015b).

5.1. Opcode gas upper-bound
Resource analysis, a.k.a. cost analysis, is a rather complex type of analysis that we handle in this article as a black-box since existing techniques can be used. Resource analyzers, in order to quantify the cost associated to an instruction, use the generic notion of cost model. A cost model is a function  that assigns a measure of the cost of executing to each instruction in the program. We represent the resource analysis as a function  that receives an RBR program  and a cost model  and returns an upper-bound 
 on the resource modeled by  for each function  in . In order to use this function  for our purpose, we need to provide now the definition of a static opcode gas model 
. Note that the gas model in Section 3.3.1 is dynamic, i.e., it describes the gas usage for concrete executions, while in order to define 
 we need a static gas model that provides a gas cost that is sound for any concrete execution. As explained in Section 3.3.1, we can distinguish three kinds of instructions depending on their gas consumption (see Definition 4 and Table 1 for details):

1.
instructions that have a fixed gas consumption whose cost can be directly applied in the cost model,

2.
instructions that could have different constant gas consumption depending on a concrete value stored in the stack,

3.
instructions with a non-constant (parametric) gas cost whose concrete consumption depends on a value stored in the stack.

We can see that the gas cost of instructions included in points (2) and (3) is dynamic as it depends on concrete values stored in the stack, which in general are unknown at static analysis time. One possible but imprecise solution for defining the cost in the static cost model is to take always the worst case cost, e.g. always consider cost 20,000 for instruction SSTORE. We can improve the precision of the static cost model by using a value analysis which finds out whether a stack variable contains a constant value to be stored on storage and hence we can determine the concrete cost.

Given an  instruction  located at program point , we assume that we have a function 
 that returns the inferred value stored in 
, if it is constant at program point  or  if the value is not known or not constant at . We do not detail the implementation of this function, as it can be done with a simple syntactic analysis or a more precise semantic constancy or value analysis. Additionally, we use function  (see Section 2) to get the size of the stack at RBR program point .

Definition 8

Given an EVM instruction  at program point  and , we define the static EVM op cost model, 
 where  is defined in Table 3.  ■

Note that in the definition of 
 we only consider the cost associated to the nop instructions, that is, instructions that directly correspond to EVM instructions, the remaining RBR instructions do not add any cost. In the cost model definition, we can see the following considerations: (1) the cost produced by fixed cost instructions is like in the dynamic gas model; (2) instructions whose cost is constant but it depends on a concrete value stored in the stack rely on  to retrieve the value stored in the corresponding stack element or, if it is unknown, we consider the worst case cost; (3) as we do not have information about the state of the blockchain, for those expressions that depend on the results returned by  we directly consider the worst case cost, e.g. in SELFDESTRUCT; (4) as we analyze single contracts, the execution cost of external calls is added as a symbolic value represented by C(CALL); and (5) instructions with parametric cost directly include the stack variables in the cost expression.


Table 3. Static EVM opcode cost model.

Fixed		
Constant	SSTORE	 
 
CALL	
DELEGATECALL	
 
CALLCODE	
STATICCALL	
SELFDESTRUCT	
Parametric	EXP	
 
CALLDATACOPY	
CODECOPY	
RETURNDATACOPY	
EXTCODECOPY	
LOGX	
 where X 
SHA3	
The GAS-RBR we are producing adheres to the rule based representations of Albert et al., 2015a, Albert et al., 2012, hence we can directly feed the resource analyzers with our GAS-RBR. We have needed only to implement the cost model 
, and the analyzer returns closed-form gas upper-bounds, i.e., a cost expression that is parametric on the input arguments of the function. Note that the input arguments of the function are, not only the function parameters, but also the list of storage variables inferred and other blockchain values associated to the transaction, e.g. CALLDATASIZE (see Section 4.1 for details). The resource analyzer is able, without requiring any modification and in a fully automated way, to find a cost expression, which over-approximates the amount of gas related to the operations executed in EVM.

Example 4

The gas bound computed by Gastap for function findWinner (see Fig. 2) is , which is parametric on the state variable 
 that corresponds to the size of the array . Function  is defined as  if  and  otherwise. Other gas upper-bounds can be found in Fig. 4 in Section 6. Note that these upper-bounds are parametric on different state variables, input and blockchain data.  ■

5.2. Memory gas upper-bound
As we have already mentioned, the problem of inferring the memory gas bound boils down to (over)-approximating the highest memory address accessed by the transaction. Our approach to solve this problem is to view it as an instance of the peak resource analysis problem (Albert et al., 2015b, Hoffmann et al., 2011). This analysis, rather than accumulating all costs as in standard resource analysis, computes the peak (, the supremum) of the resource consumption of the whole execution. The cost model in this case is atypical as the resource we need to measure is the value of the memory location. Thus, for each instruction that accesses a memory location  we count as it allocates  resources. The work at Albert et al. (2015b) uses the notation acquire(e) to allocate e amount of resources, where e is a cost expression (that can include variables). The peak analysis allows inferring the maximal value of all acquire(e) annotations. Analogously to the case of standard cost analysis, we represent the peak analysis as a function  that returns the peak (, the supremum) of the resource consumption of the acquire(e) annotations within the RBR program . Thus, we just need to perform a transformation into the GAS-RBR program (see Section 4) that converts the memory accesses like MLOAD addr into allocations of addr resources. The slots of memory used by each EVM instruction according to Wood (2014) is given in Definition 5. Note that in some cases, it depends on a given condition that checks, by comparing the corresponding stack variable with 0, if the memory address is accessed. We include this information within acquire statements before the nop functors that contain EVM instructions that access to memory as shown in the following table, where  stands for  and 
 for the top-most stack variable. Then, the peak resource analysis computes the maximum of all the expressions within acquire, what corresponds to the highest memory slot addressed in the whole execution (see Table 4).

An alternative way to infer this information is by means of a size analysis (Brockschmidt et al., 2016) that computes upper-bounds on sizes of all expressions used to access the memory. After this, in a second step, a maximization of all these obtained upper-bound sizes would be required. In contrast to this approach, we directly obtain the maximum of all memory accesses. Finally, we apply the function 
 defined in Section 3.3.2 on the result of the analysis to obtain the memory gas upper-bound 
 for each public function  in the contract. Let us give an example that illustrates the analysis:


Table 4. Transformation for applying the peak analysis [9].

b	Transformed code	Condition
MLOAD
MSTORE	acquire ( 
)	
MSTORE8	acquire ( 
)	
CALLDATACOPY
CODECOPY
RETURNDATACOPY	acquire ( 
)	
EXTCODECOPY	acquire ( 
)	
LOGX	acquire ( 
)	
CALL
CALLCODE	acquire ( 
)
acquire ( 
)	
 
DELEGATECALL
STATICCALL	acquire ( 
)
acquire ( 
)	
 
RETURN
REVERT
SHA3	acquire ( 
)	
CREATE	acquire ( 
)	
Example 5

The function findWinner (see Fig. 2) executes  EVM instructions that access to memory: two MLOAD, MSTORE and RETURN in the rule block_142; and MSTORE and SHA3 in rules block_66F and block_691. If we analyze the EVM instructions of block_142, we infer that MLOAD instructions load the value stored in the memory address  (contained in top-most stack variable 
), MSTORE stores a value in the memory address  (in the top-most stack variable 
) and RETURN operates on the values  (stored in 
) and  (stored in the top-most stack variable 
). Similarly, the MSTORE instructions of rules block_66F and block_691, stored a value in the memory address  (stored in the top-most stack variable 
) and the SHA3 instructions operates on the values  and  (stored in the top-most stack variables 
, and 
 respectively). If we compute the expressions that appear in the table above, we obtain that , , , , and  resources are acquired respectively. Hence the analysis returns  as the highest slot of memory accessed during the execution of the function findWinner. Finally, if we apply the function 
 we obtain , the memory gas upper-bound for this function. More examples can be found in Fig. 4 of Section 6. Finally, as the gas upper-bound for the function findWinner (Fig. 2) is  and the memory gas upper-bound is , we can conclude that its gas upper-bound is .  ■

Theorem 1

Given a public function  of a GAS-RBR program  with blockchain information , the following holds: 
where 
.

Sketch of proof

Soundness follows from the following facts: Program transformations of GAS-RBR programs in Sections 4 GAS-RBR : RBR transformations for gas analysis, 5 Gas analysis of preserve the  instructions of the original program. Regarding the opcode cost, it is straightforward to check that 
 is an over-approximation of  for every EVM instruction , and soundness of the resource analysis 
 (Albert et al., 2015a) ensures that we infer an upper bound of the opcode cost. Finally, the soundness of the peak analysis   (Albert et al., 2015b) guarantees as well that the memory gas cost component is a sound upper bound of the memory cost. □

6. Implementation and evaluation
The analysis presented in this article has been implemented in a tool named Gastap, Gas-Aware Smart contracT Analysis Platform, that takes as input a smart contract and automatically infers sound gas upper-bounds for its public functions. This section provides implementation details and the results of our evaluation of Gastap. In Section 6.1, we provide some implementation details of Gastap. In Section 6.2, we evaluate the accuracy of the gas bounds inferred by Gastap on the EthereumPot by comparing them with the bounds computed by the Solidity compiler. In Section 6.3, we evaluate the efficiency and effectiveness of our tool by analyzing more than 34,000 Ethereum smart contracts obtained from the Ethereum blockchain using the popular Etherscan service (Ethereum, 2018a). The whole dataset used in Section 6.3 can be found at https://github.com/costa-group/EthIR/tree/master/examples/gastap. Note that the results presented in this section do not add the so called intrinsic gas cost of the execution as Solidity compiler does. However, Gastap has a flag to incorporate the transaction fee of 2300 gas. Finally, in Section 6.4, we assess the accuracy of the upper-bounds inferred by Gastap. To do so, we compare the upper-bounds obtained on the 300 top-valued accounts by Ether (the most valuable ones) obtained using Etherscan service with the gas cost of more than 4000 real transactions.

Gastap tool can be used from an online web interface at https://costa.fdi.ucm.es/gastap where we have also made available a subset of the smart contracts used for our experimental evaluation. To run the tool, the user has to either write her Solidity contract in the text area or to select an available one in the file manager area on the left side. In both cases, then the Refresh Outline allows selecting by means of a check button the function(s) whose gas cost is going to be inferred. Finally, by clicking on Apply the analysis starts and the gas bound is obtained. In the Settings menu it can be specified if the input is a Solidity program or an EVM code.

6.1. Implementation
Fig. 1 shows in white boxes the components developed by us – that are all open-source – and in gray those that we use out-of-the-box. The Saco analyzer we are using is not open-source but it is available through an executable. We classify the components implemented by us in two groups:

•
Python implementation. The components related to the generation of the stack sensitive control flow graph introduced in Section 2, the generation of the rule-based representation presented in Section 3 and the abstractions described in Section 4 have been implemented in Python. These components have been implemented in more than 18,000 lines of code ().

•
Prolog implementation. As the SACO analyzer is implemented in Prolog, we have implemented the components that are directly integrated in it in Prolog as well. In particular, the “Value Analysis” and “Gas Cost Model” components in Fig. 1 are implemented in 613  in Prolog. The first component implements a classical data-flow analysis and corresponds to the function  used in Section 5.1 to retrieve the value stored in a given stack element. This analysis is used in the second component that contains the models described in Section 5.1. The fixed cost instructions are modeled with facts in Prolog specifying its concrete cost. The instructions whose cost is constant but it depends on a concrete value or those instructions with parametric cost are modeled with rules in Prolog that use the result of the value analysis to compute the cost.

The output of the different components is stored in text files, e.g., the  and the RBR are written in separated files that are read by the next components.

6.2. Gas bounds for EthereumPot case study
Fig. 4 shows in column solc the gas bound provided by the Solidity compiler solc (Ethereum, 2018b), and in the next two columns the bounds produced by Gastap for opcode gas and memory gas, respectively, for all public functions in the contract. If we add the gas and memory bounds, it can be observed that, for those functions with constant gas consumption, we are as accurate as solc. Hence, we do not lose precision due to the use of static analysis.

For those 6 functions that solc fails to infer constant gas consumption, it returns . For opcode gas, we are able to infer precise parametric bounds for five of them, rewardWinner is linear on the size of the first and third state variables ( and  represent resp. the sizes of the arrays addresses and slots in Fig. 2), getSlots and findWinner on the third, getPlayers on the first, and __callback besides depends on the value of result (second function parameter) and proof (last parameter). It is important to note that, although the Solidity source code of some functions (, of getSlots and getPlayers) does not contain loops, they are generated by the compiler and are only visible at the EVM level. This also happens, for example, when a function takes a string or bytes variable as argument. This shows another reason for the need of developing the gas analyzer at the EVM level.

For joinPot we cannot ensure that the gas consumption is finite without embedding information about the blockchain in the analyzer. This is because joinPot has a loop:


Download : Download high-res image (16KB)
Download : Download full-size image
where minBetSize is a state variable that is initialized in the definition line as uint minBetSize = 0.01ether, and ether is the value of the Ether at the time of executing the instruction. This code has indeed several problems. The first one is that the initialization of the state variable minBetSize to the value 0.01ether does not appear in the EVM code available in the blockchain. This is because this instruction is executed only once when the contract is created. So our analyzer cannot find this instruction and the value of minBetSize is unknown (and hence no bound can be found). Besides, the analyzer cannot infer that the loop terminates if minBetSize is not guaranteed to be strictly greater than zero. If we add the initialization instruction, then we are able to infer a bound for joinPot.

For __callback we guarantee that the memory gas is finite but we cannot obtain an upper-bound for it, Gastap yields a maximization error. Maximization errors may occur when the analyzer needs to compose the cost of the different fragments of the code because it needs to find the maximal value of the cost of inner components in their calling contexts (see Albert et al. (2008) for details). If the maximization process involves memory locations that are “unknown”, i.e., those translated into a fresh variable in Definition 2 from Section 3, the upper-bound cannot be inferred. Still, if there is no ranking function error, we know that all loops terminate, thus the memory gas consumption is finite.

Finally, this transaction is called always with a constant gas limit of 400,000. This contrasts with the non-constant gas bound obtained using Gastap. Note that if the gas spent (without including the refunds) goes beyond the gas limit the transaction ends with an out-of-gas exception. Since the size of  and  is the same as the number of players, from our bound, we can conclude that from 16 players on the contract is in risk of running out-of-gas and get stuck as the 400,000 gas limit cannot be changed. So using Gastap we can prevent an out-of-gas vulnerability: the contract should not allow more than 15 players, or the gas limit must be increased from that number on.

6.3. Statistics for analyzed contracts
Our experimental setup consists on 34,460 contracts taken from the blockchain as follows. We pulled all Ethereum contracts from the blockchain of January 2018 whose Solidity source code was available. This fact reduces the number of smart contracts to be analyzed significantly as it is estimated that less than 1% of the smart contracts deployed on Ethereum blockchain have the source code available. Then, we removed duplicates instances of the same contracts, and after that, we removed those smart contracts that led to a compiler error due to a lower version of the compiler (it introduces changes in the syntax of Solidity that are not supported by the newer versions of the compiler). This ended up in 9760 files. Each Solidity file often contains several contracts. When the Solidity compiler generates the EVM bytecode of one of these files, it produces one different EVM bytecode file for each contract defined in the Solidity taken as input and Gastap analyzes each of these EVM bytecode files separately. However, we have excluded the files where the decompilation phase fails in any of the contracts it includes, since in that case we do not get any information on the whole file. This failure happens in 83 files, which represents a 0.85% of the total. The failures of EthIR are mainly due to recursive and high-order functions, which are not handled by the tool. This number is smaller than the failure rate of other tools like Vandal (Brent et al., 2018) (5% of failure rate), Oyente (Luu et al., 2018) (10% of failure rate) and Rattle (Rattle, 2018d) (30% of failure rate) or the previous prototype of Gastap (Albert et al., 2019) (7% of failure rate). Finally, EthIR has a timeout set to 60 s that is reached by 33 files.

After removing these files, our experimental evaluation has been carried out on the remaining 9644 files, containing the mentioned 34,460 contracts. In total we have analyzed 318,093 public functions (and all auxiliary functions that are used from them). The Solidity compiler can generate two different EVM bytecode versions: (i) the binary version used when the contract is deployed on the blockchain that includes the code of the constructor of the contracts, and (ii) the runtime version used when the contract has already been deployed, i.e., the code that is actually placed on the blockchain that only includes the bytecode of the functions of the contract excluding the constructor. Gastap analyzes the runtime version by default so it does not include the code related to the constructors of the contracts.

Experiments have been performed on an Intel Core i7-7700T at 2.9 GHz x 8 and 7.7 GB of Memory, running Ubuntu 16.04. Gastap accepts smart contracts written in versions of Solidity up to 0.7.1 or bytecode for the Ethereum Virtual Machine v1.9.202. The statistics that we have obtained in number of functions, and the time taken by the analyzer are summarized in Fig. 5. The results for the opcode and memory gas consumption are presented separately.

Let us first discuss the results in Fig. 5 which aim at showing the effectiveness of Gastap. Columns #opc and #mem contain the number of analyzed functions for opcode and memory gas, resp., and columns preceded by % the percentage they represent. For the analyzed contracts, we can see that a large number of functions, 83.75% (resp. 86.44%), have a constant opcode (resp. memory) gas consumption. This is as expected because of the nature of smart contracts, as well as because of the Ethereum safety recommendations mentioned in Section 1. Still, there is a relevant number of functions 6.49% (resp. 5.51%) for which we obtain an opcode (resp. memory) gas bound that is not constant (and hence are potentially vulnerable). Additionally, 6.27% of the analyzed functions for opcodes and 5.69% for memory reach the timeout (set to 30 s) due to the further complexity of solving the equations. Thanks to the information provided by the Saco analyzer used by Gastap, we are able to classify the types of errors that have led to a “don’t-know” answer and which in turn explain the sources of incompleteness by our analysis:


Download : Download high-res image (255KB)
Download : Download full-size image
Fig. 6. Statistics of gas usage on the analyzed 300 most valuable smart contracts whose source code is available from Ethereum blockchain.

•
Maximization error: In many cases, a maximization error is a consequence of loss of information by the size analysis or by the decompilation when the values of memory locations are lost. As mentioned, even if we do not produce the gas formula, we know that the gas consumption is finite (otherwise the system flags a ranking function error described below).

•
Ranking function error: The solver needs to find ranking functions to bound the maximum number of iterations of all loops the analyzed code might perform. If Gastap fails at this step, it outputs a ranking function error. Section 6 has described a scenario where we have stumbled across this kind of error. We note that number of these failures for mem is lower than for opcode because when the cost accumulated in a loop is 0, Saco does not look for a ranking function.

•
Cover point error: The equations are transformed into direct recursive form to be solved (Albert et al., 2008). If the transformation is not feasible, a cover point error is thrown. This might happen when we have mutually recursive functions, but it also happens for nested loops as in non-structured languages. This is because they contain jump instructions from the inner loop to the outer, and vice versa, and become mutually recursive. A loop extraction transformation would solve this problem, and we leave its implementation for the future work.

Let us discuss in further detail the type of parametric bounds we have obtained. 99% of the parametric opcode gas bounds shown in Fig. 5 are linear bounds. In case of the memory gas bounds, the linear bounds are the 97%. Importantly, a state-of-the-art cost solver is needed to automatically infer such linear costs, as this is a very complex problem to automate that, among other things, requires the inference of linear ranking functions (Albert et al., 2011) that bound the number of loop iterations. In general, such linear ranking functions may involve multiple program variables and some of them can increase through the loop execution, others decrease, or both, etc. Finding out automatically the loop bounds requires the use of static analysis techniques.

Note that Gastap considers all EVM bytecode instructions within the public function being analyzed when computing the upper bounds, there might be bytecode instructions related to failures (e.g., REVERT or INVALID) but they are not the reason for having parametricity, since we just accumulate their gas consumption. There are cases in which the EVM bytecode of a contract has a loop, though it is not visible in its Solidity source code. For instance, these “hidden” loops might come from functions that return arrays or strings, receive them as parameters, the size of the message data, or the length of data structures in storage. As Gastap analyzes EVM bytecode, it is able to detect these loops and it infers a parametric upper-bound for these functions.

As regards the sources of the parametric bounds, a good percentage correspond to getters of public state variables which are strings (such as symbol, name or version). Their getters are almost the 17% of the parametric functions and the 232% of the 318,093 public functions analyzed. The getter functions are introduced automatically by the Solidity compiler when the state variables are public. They are standard functions that can be called by any user and their content may be changed by any transaction. In the case of constant variables in Solidity (state variables with modifier constant), the value has to be a constant at compile time and it has to be assigned when the variable is declared. Then, the value is translated directly when the EVM bytecode is generated, and the upper-bounds inferred are constant. However, Gastap is not able to detect the cases in which the results inferred rely on state variables that are immutable (those that are not modified by any method of the contract). This kind of constancy is not detected by our analysis, as it would require another (orthogonal) analysis that detects that the state variable is set to a constant in the constructor and ensures that it is never changed again by any other function. This requires an inter-procedural constancy analysis that is complementary to our work. If such constant value is found out, its value can be replaced within the formulas inferred by our tool.

As regards the efficiency of Gastap, the total analysis time for all functions is 1,467,027.17 s (407.5 h). Columns T and % show, resp., the time in seconds for each phase and the percentage of the total for each type of gas bound. The first three rows are common for the inference of the opcode and memory bounds, while equation generation and solving is separated for opcode and memory. Most of the time is spent in solving the GE (68.43%), which includes some timeouts. The time taken by EthIR is negligible, as it is a syntactic transformation process, while all other parts require semantic reasoning. All in all, we argue that the statistics from our experimental evaluation show the accuracy, effectiveness and efficiency of our tool. Also, the sources of incompleteness point out directions for further improvements of the tool.

Finally, note that Gastap works at EVM bytecode level. Thus, the analysis is independent of the version of the compiler used. The same Solidity code compiled with different versions of the compiler might produce different upper-bounds and the optimizations performed by the compiler are orthogonal to our analyzer. In the case of the contracts published in the Ethereum platform, this point is specially interesting because the contracts are published with a particular version of the compiler and cannot be changed.

6.4. Accuracy of Gastap when compared to real transactions
In this section, we assess the accuracy of our tool by comparing the upper-bounds inferred by Gastap with the gas that real transactions consume on a smaller, but more prominent, set of benchmarks. To do so, we have downloaded the 300 top-valued accounts (those that are most valuable in Ether) whose source code was available using the Etherscan service (Ethereum, 2018a) by 21 September of 2020. This has resulted in 16 Solidity files that contain 24 smart contracts. We have analyzed the 348 public functions contained in these contracts and obtained the results in Fig. 6 (the rows have the same meaning explained in Section 6.3). Note that the number of parametric gas upper-bounds obtained for this subset is even higher (17.53%) than for the benchmarks in Section 6.3. For the 125 called, 76 correspond to constant bounds, 27 to parametric bounds, 11 of the functions called return a maximization error, the termination of 1 function could not be proved as the analyzer did not find a ranking function, 3 functions raise a cover point error and 7 functions reach the time out (set to 60s). The number of cover point errors is also higher as one of the contracts analyzed has various public functions that have three nested loops with a conditional statement inside that requires the loop extraction transformation mentioned in Section 6.3 that is not yet implemented in the Saco analyzer.


Download : Download high-res image (161KB)
Download : Download full-size image
Fig. 7. Accuracy of upper bounds inferred by Gastap compared to real transactions.

Now, in order to assess the accuracy, we have to restrict ourselves to those functions that have been invoked by existing transactions. This information can be retrieved using the Etherscan service (Ethereum, 2018a) and Bloxy service (Bloxy, 2018a). From the 348 public functions analyzed, 125 (almost a 37%) were called in 4054 real executions. In order to compare the bounds inferred by Gastap and the gas consumed by real executions, we have to add the transaction fee (21,000) to the Gastap bounds as it is not added by default. We compute the average of the gas consumed by each transaction to each function and compare our upper bound to such average. Fig. 7 summarizes our results. We have grouped the analyzed functions in five groups: those whose upper bound has an overhead 10% (leftmost group), those whose upper bound has an overhead between 10%–20%,.., until the rightmost group with an overhead between 200%–600%. Within each group, we separate the results of those functions that have a constant upper bounds from those that have a parametric one. We use also two cost models: the cost model described in the paper that is sound in all possible scenarios, and one (denoted as “improved cost model” in the figure) that captures better the state of the blockchain when these transactions were executed by accounting a less pessimistic gas consumption for certain bytecodes, namely these ones:


SSTORE	
CALL	
DELEGATECALL	
CALLCODE	
 
STATICCALL	
SELFDESTRUCT	
In this improved cost model, instead of assuming that the account involved in SELFDESTRUCT operation does not exist or is “dead” (worst case, see Wood (2014)), considers that it is active. Thus, it would only consume 5000 units of gas instead of 30,000. In the case of SSTORE bytecode, we assume that the storage location involved in the operation has been previously used and it does not contain a 0. Thus, it would consume 5000 units of gas instead of 20,000. Finally, for the opcodes related to external calls (CALL, DELEGATECALL, CALLCODE and STATICCALL), we assume that the contract called has been previously created. Thus, it saves 25,000 units of gas compared with the sound model.

As an example, the leftmost orange bar in Fig. 7 is displaying the number of functions (namely 19) that have a constant cost using the improved cost model above such that the overhead of the upper bound obtained for them is less than 10% w.r.t. the average of the gas consumed by the actual transactions invoking this functions.

We can observe in Fig. 7 that using the sound cost model, the upper-bounds inferred for more than half of the functions is are at least 50% higher than the real amount of gas consumed by the transactions. However, the results are improved notably when we assume the improved cost model, indeed, all constant gas bounds disappear from the last two groups in which the overhead is larger. We have still 16 functions in the rightmost group, that have a parametric bound, for which the overhead of the upper bound is large. This is not surprising as the actual transactions run on concrete data while our upper bounds are covering all possible input data values. An important result of these experiments is that 132 out of the 4054 analyzed (3.64%) raise an out-of-gas exception. In these cases, Gastap infers upper-bounds that are higher than the gas limit specified in the corresponding transactions. Thus, our bounds would have helped to prevent such exceptions. In addition, there are 7 functions that raise an out-of-gas exception in the transactions in which they are involved.

Finally, we have made a manual inspection of the functions in order to explain the sources of the parametricity of the functions shown in Fig. 6. We can classify them as follows:

•
11.48% of the parametric bounds depend on input data, i.e., on a value that is passed to the function as a parameter.

•
16.39% of the parametric bounds depend on the length of the message data. In this case, the bound is expressed in terms of CALLDATASIZE.

•
67.21% come from traversing state variables that are arrays. In this case, the loop is explicit in the code in a 79% of the times. However, for the rest 21% it appears when the source code is translated into EVM code (e.g. when using the primitive delete).

•
4.91% correspond to getters of public state variables that are strings. The bounds are expressed in terms of the length of the string returned.

7. Related work
Analysis of Ethereum smart contracts for possible safety and security violations and vulnerabilities is a popular topic that has received a lot of attention recently, with numerous tools developed, leveraging techniques based on symbolic execution (Luu et al., 2016, Grossman et al., 2018, Nikolic et al., 2018, Krupp and Rossow, 2018, Kalra et al., 2018, Tsankov et al., 2018), SMT solving (Marescotti et al., 2018, Kolluri et al., 2018, Hajdu and Jovanovic, 2020), and certified programming (Bhargavan et al., 2016, Grishchenko et al., 2018, Amani et al., 2018). Those approaches target vulnerabilities induced by contract-specific phenomena such as reentrancy (Grossman et al., 2018), mishandled control flow (Tsankov et al., 2018), as well as trace-based properties (Nikolic et al., 2018, Kolluri et al., 2018). However, most of the state-of-the art contract analysis tools ignore resource usage, focusing on non-gas-related safety, security, and temporal properties. As Gastap is not meant to be an all-in-one smart contract analyzer and focuses exclusively on gas consumption, in this survey we only relate to the tools and approaches that are concerned with gas usage and the corresponding out-of-gas vulnerabilities.

The GASPER tool identifies gas-costly programming patterns (Chen et al., 2017), which can be optimized to consume less. For doing so, it relies on matching specific control-flow patterns, SMT solvers and symbolic computation, which makes their analysis neither sound, nor complete for determining gas usage bounds. They classify the patterns in two groups: useless-code related patterns and loop-related patterns. These techniques focus on detecting code patterns to improve the development of the contract rather than inferring gas consumption bounds.

The previous work is extended in Chen et al. (2018) and Chen et al. (2020). In Chen et al. (2018) they present GasReducer, a tool that also works at EVM bytecode level. GasReducer takes the bytecode of a smart contract and outputs an optimized version of the original one that consumes less gas. In this case the patterns are defined as a sequence of EVM instructions that can be replaced by another one that consumes less gas but has the same semantics as the original sequence rather than using high-level structures such as dead code or opaque code. To identify the patterns, they inspect several instances from the execution traces of deployed smart contracts. In Chen et al. (2020) the tool GasChecker is presented. It follows a new approach to identify gas-inefficient code based on symbolic execution parallelized using a MapReduce model and cloud computing. They increase the patterns described in Chen et al. (2017). They also improve the performance of the tool making it fully scalable as it is shown in the experiments.

In a similar vein, the work by Grech et al. (2018) identifies a number of classes of gas-focused vulnerabilities, and provides MadMax, a static analysis, also working on a decompiled EVM bytecode, by combining techniques from flow analysis together with control-flow analysis (CFA), context-sensitive analysis and modeling of memory layout. In a first step, MadMax infers loop and data-flow information. From loops, it infers information related to the exit condition of the loop or induction variables, i.e., those that are incremented by a concrete value inside the loop. The data-flow analysis provides information such as aliasing or dependencies between variables. Using the basic loop and data-flow analysis, MadMax is able to infer high-level concepts such as array iterators or if the storage is increased on public functions. In its techniques, MadMax differs from Gastap, as it focuses on identifying control- and data-flow patterns inherent for the gas-related vulnerabilities, thus, working as a bug-finder, rather than complexity analyzer.

Since deriving accurate worst-case complexity boundaries is not a goal of any of GASPER, GasReducer, GasChecker and MadMax, they are unsuitable for tackling Challenge 1 posed in the introduction. Other tools based on proof assistants (Hirai, 2017, Mavridou and Laszka, 2017, Hildenbrandt et al., 2018, Grishchenko et al., 2018) may be used to detect out-of-gas exceptions. They can model how gas is updated along the execution of the trace and encode it as constraint formulas. However these tools are not able to infer loop invariants. They have to be specified manually. Thus, they are not able no automatically infer gas bounds for programs that involve loops as we do.

A preliminary prototype of Gastap has been used in Albert et al. (2020b) to develop Gasol, a gas optimizer of smart contracts. Gasol uses the gas analysis Gastap to detect under-optimized storage patterns and generate an automatic optimization that avoids storage accesses if they can be replaced by memory accesses. For this purpose, it includes a simplified version of our gas cost model that only accounts for the gas cost of storage operations.

Marescotti et al. (2018) propose a methodology, based on the notion of the so-called gas consumption paths (GCPs) to estimate the worst-case gas consumption using techniques from symbolic bounded model checking (Biere et al., 1999). Their approach is based on symbolically enumerating all execution paths and unwinding loops to a limit. In contrast, Gastap infers the maximal number of iterations for loops and generates accurate gas bounds which are sound for any possible execution of the function and not only for the unwound paths. While their approach unwinds loops to a given limit, using a resource analysis approach, we are able to infer the maximal number of iterations that loops may execute. As we have seen, using a resource analysis approach, in addition to inferring precise cost expressions for constant gas consumption as in Marescotti et al. (2018), we can go beyond that, and generate parametric gas bounds. Besides, to the best of our knowledge, the approach by Marescotti et al. has not been implemented in the context of EVM and has not been evaluated on real-world smart contracts as ours. Therefore, we have not been able to compare the results generated by our tool with the approach proposed in Marescotti et al. (2018).

In Signer (2018), Visualgas is presented, a tool to visualize gas costs. Visualgas records the deployment and initialization transactions of a given contract and uses them to generate transactions to run all its public functions applying the techniques described in Ambroladze, 2018, He et al., 2019. This approach differs from our analysis in that it is dynamic and hence it is focused on computing the gas cost of concrete transactions that have been generated previously. On the other hand, our technique is static and infers the gas cost consumed in the worst case for any arbitrary input of the public function under analysis.

8. Conclusions and future work
Automated sound static reasoning about resource consumption is critical for developing safe and secure blockchain-based replicated computations, managing billions of dollars worth of virtual currency. In this work, we have adapted and extended state-of-the art techniques in resource analysis, showing that such reasoning is feasible for Ethereum, where it can be used at scale not only for preventing vulnerabilities, but also for verification/certification of existing smart contracts. Note that improvements in all the auxiliary analyses used in Gastap will have an impact in the precision and the performance of the tool. As future work, we want to improve the accuracy of the tool in several directions. First, we are studying a more precise abstraction for the memory-allocated data (, for the abstraction explained in Section 3). Also, we aim at handling bit-wise operations by including in our tool an abstraction for them.