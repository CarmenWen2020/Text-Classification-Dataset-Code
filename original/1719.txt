Continually disclosed vulnerabilities reveal that traditional computer architecture lacks the consideration of security. This article proposes a security-first architecture, with an Active Security Processor (ASP) integrated to conventional computer architectures. To reduce the attack surface of ASP and improve the security of the whole system, the ASP is physically isolated from Computation Processor Units (CPU) with an asymmetric address space, which enables both ASP and CPU to run their operating system and applications independently in their own memory space. Furthermore, the ASP, which has the highest privilege (Super Root) of the whole system, possesses two advantageous features. First, the ASP can efficiently access all CPU resources and collect multi-dimensional information to monitor malicious behaviors, meanwhile, the CPU cannot access the ASP's private resources in any way. Second, instead of being scheduled by CPUs, the ASP can actively manage the security mechanisms employed in either CPUs or the ASP. Based on the security-first architecture, we introduce several typical security tasks running on ASP. With different considerations in terms of system overhead, complexity and performance, we also explore four typical system-level implementations for integrating the ASP to the security-first architecture. The first-generation ASP was designed and implemented based on the 40nm technology, and a security computer system was implemented based on it. Evaluations on this real hardware platform demonstrate that the security-first architecture can protect the system effectively with minor performance impacts on computing workloads.
SECTION 1Introduction
Today, continually discovered software and hardware vulnerabilities illustrate the significant challenges of building secure computing systems. The increasing complexity of modern operating systems and applications leads to larger attack surfaces. At the same time, since the design and production of processors usually involve multiple vendors, it is difficult to figure out all possible security risks. Meanwhile, rapidly upgraded and diversified attack methods pose challenges to the security of computer as well. More seriously, the critical techniques in the classically designed computer architecture and microarchitecture, such as speculative execution and shared on-chip cache hierarchy, bring not only performance improvement, but also new security vulnerabilities and side channel information leakage.

Recently, several architecture-level security mechanisms have been integrated in commercial processors, such as Intel SGX and ARM TrustZone. They are designed to provide a trusted execution environment (TEE) to protect secure tasks and data through logical isolation. For example, Intel designed SGX to protect applications and code even when the operating system, hypervisor, or BIOS firmware is compromised. However, these mechanisms have been confirmed with exposed attack surfaces and vulnerabilities. In the case of logical isolation, security and computing tasks run in the same computing environment, sharing resources including processor cores, on-chip caches, bus, and memory, etc. The secure and non-secure world are isolated via the switch of architectural states and necessary hardware supports. On the one hand, the execution of the security tasks might affect the performance of the computing tasks due to resource contention. On the other hand, logic sharing might cause security problems. Specifically, conventional microarchitecture vulnerabilities, such as cache side channel [1], [2], branch predictor side channel [3] and cache-DRAM attacks [4], still exist in SGX. Besides, recent studies disclosed that OS-level adversaries can exploit page-fault channels, page-access channels to deduce secrets inside SGX enclaves [4], [5], [6], [7]. And Intel has admitted that SGX cannot defend against information leakage through four attack vectors, including: power statistics, cache miss statistics, branch timing and page accesses via page tables [8]. Similarly, both cache side channel [9], [10] and branch predictor side channel [3], [11] are exploited in TrustZone as well.

One of the major reasons for using logical isolation instead of physical isolation is the consideration of implementation cost. Actually, during the last two decades, the primary goal of computing system design has always been optimizing the performance and saving the cost, placing security as a secondary priority. Such performance- and cost-first design philosophy causes a series of hardware security problems like Spectre variants which can only be migrated case by case so far, as well as the vulnerabilities of SGX and trustzone due to resource sharing.

In this paper, we first propose a security-first architecture to overturn the traditional performance- and cost-first design principle. Within this new architecture, we fully consider security during the architecture design stage, and comprehensively balance security, performance and cost, providing a secure and high-performance execution environment for security tasks. Specifically, the main contributions of this paper are as follows:

We proposed a security-first architecture, which considers security as a first-citizen requirement during the design stage. In addition to traditional computing CPUs, the security-first architecture introduces a new processor unit dedicated to running security tasks, called Active Security Processor (ASP). Thats to say, traditional CPU is responsible for running computing tasks, and the security mechanisms run independently on the ASP. The CPU and ASP have their private resources, including memory, disk, network and I/O devices, to run separate operating systems and applications. This new architecture adopts asymmetric address space to realize the unidirectional isolation between CPU and ASP. In particular, the super root permissions possessed by ASP enables it to efficiently access all CPU resources and cannot be disabled by the computing CPU, meanwhile, the CPU has no access to any ASP resources.

Typical security mechanisms running on ASP are discussed in details, including on-line detection of malicious behavior, active trusted computing and active noise interference for security consideration. These security mechanisms elaborate how ASP protects CPU from malicious attacks.

The design space of ASP implementation has been explored. The first-generation implementation adopts a separate chip designed and implemented based on the 40 nm technology, and a security computer system was implemented based on it. Evaluations on this real hardware platform demonstrate that security mechanisms running on the ASP effectively protect the security of the computing environment, and the performance impacts on computing-task are negligible.

The next Section presents the threat model and security challenges to be addressed. The concept of security-first architecture is introduced in Section 3. Section 4 introduces the possible implementations of ASP. Section 5 is the evaluation and analysis. And Section 6 includes related works. Section 7 concludes this paper.

SECTION 2Threat Model and Security Design Challenges
2.1 Threat Model
We assume computing CPU and its software stack are totally insecure, in which many components including applications, operating systems, firmware and the CPU hardware may be exploited. No user is trusted, including the privileged root on CPU based computing subsystem. It is noted that the ASP based security subsystem is free from the control of the privileged root of CPU based subsystem. Besides, adversaries can mount attacks by replacing hardware, such as the CPU, and hard disks.

2.2 Security Challenges to be Addressed
Since hardware and software vulnerabilities are inevitable, it is challenging to design a secure computer system. The top priority issue is how to ensure the security, efficiency and flexibility of the security mechanism in the attack and defense game. The major challenges of building a secure system are analyzed as below:

First, a secure execution environment should be provided for security mechanisms. On the one hand, it is necessary to avoid the security risks caused by large attack surfaces due to logical isolation. On the other hand, it should also be solved that the security mechanism may be bypassed due to the lack of initiative. When designing a secure computer system, the execution environment of the security mechanism should have the highest access and control rights.

Second, accurate and efficient security mechanisms should be designed at a low cost. The design of secure computer systems should balance accuracy, efficiency and cost to minimize the impacts of security mechanisms on original computing environments. Furthermore, the deployment of security mechanisms should reduce or avoid the possible modifications to current computing processors as much as possible.

Finally, the security subsystem should be flexible and programmable. The game of attack and defense continues to iterate, there is no once and for all security mechanism. The independent security subsystem should guarantee the efficient execution of diverse security tasks, and also needs to consider scalability and programmability. In addition, the security subsystem should support efficient and secure upgrade.

SECTION 3Security-First Architecture
3.1 Overview
Our major philosophy of designing a built-in security computer is listed as follows:

Security needs to be jointly considered at both the system and chip level during the architectural design phase. And we need comprehensively balance performance, security and cost.

Physical isolation is much more secure than logical isolation. We believe secure world should be physically isolated from insecure world, which avails the minimal attack surfaces.

Security mechanisms should have the highest access privilege, be proactive, and have minimum performance impacts on computing tasks.

Fig. 1 illustrates the proposed security-first architecture and its major features.


Fig. 1.
Overview of the security-first architecture.

Show All

Security and computation are decoupled. Besides traditional CPUs, the security-first architecture introduces Active Security Processor (ASPs) in the same computer. In other words, each computer consists of a CPU-based computing subsystem and a ASP-based security subsystem within the security-first architecture. And each subsystem has its own hardware and software stack (including OS and applications). A typical implementation is that the CPU runs normal computing tasks, and the ASP system runs audited security mechanisms such as secure boot, dynamic integrity measurement, and malicious behavior analysis. It is worth noting that the ASP can provide a mechanism similar to SGX enclave, sensitive code and data of computing tasks can be placed on the ASP. However, ASP does not allow such kind of usage. Since we cannot guarantee the security of the code in arbitrary computing task, co-existence of these code/data and above specific security mechanisms on ASP will bring greater security challenges.

Adopt asymmetric address space to realize the unidirectional physical isolation. Just as analyzed above, logical isolation between computing subsystem and security subsystem causes a large attack surface due to resource sharing. Therefore, the proposed security-first architecture adopts unidirectional physical isolation and places security as the first-citizen requirement. The computer built with security-first architecture has asymmetric address space. It indicates that each of the two subsystems has private hardware resource like memory, disk and other IO devices, and runs individual OS and applications with different memory space. While the ASP is designed to efficiently access the specified microarchitecture events, memory and I/O devices of the CPU, the CPU cannot access any private resources of the ASP. Such unidirectional isolation, implemented by the asymmetric address space, effectively reduces the attack surface and improves the security of the system.

The ASP has the highest privilege, named as Super Root. This highest privilege level of the whole system has two features: ① After powering on the system, the ASP runs first to measure the integrity of the firmware, operating system and user-level critical applications to be executed on CPU. ② The ASP is allowed to collect the full-stack information of the computing subsystem, and is able to control important architectural or microarchitectural modules (like inject noise or dynamically configure hardware modules) as the responses once security risks are detected. It is noted that such capability can not be disabled by any software running on the CPU. And the realization of this feature requires necessary support from the CPU. Specifically, the internal bus should support event collection operation issued by ASP, and corresponding hardware modules in CPU need to expose ports to ASP for dynamic configuration. For instance, several agents are embedded into major modules of the CPU to collect microarchitectural events, and the information will be sent to the on-chip preprocessing engine, which compresses valuable information after necessary filtering and sends them to the ASP for further analysis. Actually, existing commercial processor chips with similar on-chip fabric (e.g., ARM provides on-chip debug and trace collection bus) can be leveraged by our design. Furthermore, the interconnection should allow the ASP to access the main memory and I/O devices of computing subsystem.

3.2 Active Security Processor (ASP)
ASP is the critical component of the security-first architecture. It offers secure environment for trusted security tasks. These tasks are highly diversified and usually have performance requirements on processor core. Thus ASP is designed based on a general-purpose processor core with heterogeneous architecture to meet these requirements. General-purpose processor core provides good flexibility, while domain-specific accelerators, such as cryptography and AI accelerators, can significantly improve the efficiency.

The security subsystem of built-in security computer has its independent processor (ASP), memory, and I/O devices separated from the original CPU environment supported by asymmetric memory space. Since all security tasks are trusted via auditing before they are loaded into ASP subsystem by out-of-band approach, the OS does not need to be complex like standard Linux. Therefore, the OS running on ASP is a simplified version Linux, which only possesses necessary features required by security mechanisms. Furthermore, the formal verification can be used to improve the security.

Another functionality of ASP is to analyze and control I/O traffics of computing subsystem. In essence, the ASP serves as the bridge between I/O devices and the CPU of computing subsystem, thus it can observe the I/O requests and related data. If one I/O access violates the specified rule, ASP can discard this I/O transaction or even block this I/O path.

It should be noticed that the introduction of ASP in this section is at the concept level. Actually it can be put into several practical implementations. For example, it can be a separate chip, or it can also be integrated into the CPU chip as one IP attached to the on-chip fabric. Section 4 explores the design space of ASP implementations.

3.3 Typical Security Mechanisms on the ASP
This section introduces three typical scenarios of deploying security tasks on the ASP.

Scenario 1: Active online detection of malicious behaviors.

Malicious behaviors usually follow special patterns, which can be captured by active online detection. Next, memory-based rootkit detection and GPRs-based malware detection are used as examples to elaborate the mechanism of active online malicious behavior detection.

1) Many rootkit attacks usually tamper with critical kernel structures (e.g., task_struct list, system call table) of the operating system, through which they hide themselves from the system or hijack the execution flow of the kernel functions (e.g., system call functions). For example, they maliciously change the process list (e.g., task_struct list of Linux kernel) to hide themselves. Besides, tampering with the system call table to replace the original system call functions with malicious functions elaborated by the attackers is a typical attack approach of most rootkits.

As shown in Fig. 2, the active detection module running on ASP captures possible rootkit attacks in computing subsystem. The key idea is to measure the memory contents (especially for the critical kernel data structures) of computing subsystem periodically to detect activities of rootkit attacks. The active detection scheme mainly contains four modules listed as below.


Fig. 2.
Overview of active detection on Rootkit attack.

Show All

Semantics Reconstruction. The data extracted directly from the memory is of binary format without any semantic information. Following method is proposed to reconstruct semantic information from the pure binary bytes. First, base address where the normal computation kernel is loaded has been located (i.e., kernel_base). Second, the offset between kernel functions and the kernel_base can also be known. Then the two kinds of data mentioned above can be used by the semantics reconstruction module to locate kernel functions, because the address of these functions is the sum of the kernel base and the associated offset.

Active Detection Module. After reconstructing these kernel structures’ semantics information, the active detection module begins to measure these structures actively to detect potential threats. For example, an adversary might initiate a system call hooking attack which loads a malicious kernel module (i.e., rootkit) to tamper the system call table, which can be quickly detected by the active detection model by checking the integrity of these static kernel structures. Detection interval is an important factor as well, as it might degrade the performance if it is set too high, and some attacks will be missed if set too low. Therefore, the impacts of detection frequency are investigated in the evaluation section. The results show that, as the detection task runs on an independent ASP subsystem, minimum performance impacts have been found in existing detection.

Measurement Module. The active detection module periodically monitors some critical structures of the normal computation subsystem and extracts their binary data. And then it submits the binary data and the original measurement of these structures to the measurement module, which compares the re-calculated measurement with its original value to verify the integrity of these kernel structures.

Attack Response Module. The integrity-check result will be submitted to the attack response module. When the measurement module verifies that some kernel structures are tampered with, the attack response module will conduct associated defense strategies to protect the computing subsystem.

2) Another example is an online detection mechanism running on the ASP to identify malware on CPU-based subsystem by analyzing the spatial and temporal properties of general purpose registers (GPRs) of CPU chip [12]. It includes three majors components as follows.

In-depth data collection is used for automatically collecting multiple architectural and microarchitectural features, such as opcode features, branch features and GPRs features. These data are used to train the detection model (FusionST). Traditional mechanisms of information collection have some restrictions. For example, the techniques in [13] and [14] need manual operations. Besides, most of them specialize in extracting opcode information. We designed an automatic data collection system that can automatically and effectively extract the GPRs’ content and other microarchitectural events.

Sub-sample mechanism pre-processes the GPRs features collected by the In-depth data collection module. Prior works illustrates the opcode features (existence of opcodes and frequency of opcodes with largest difference) are effective for malicious behaviour detection, but only temporal statistics are considered as input features [15]. While in this study, spatial and temporal proprieties of GPRs have both been applied to malware detection. Eight GPRs are utilized as input features to train our malware detection model. And these GPRs are translated into numeric samples which can be directly used as the input of the classification model (Fig. 3a).

Fig. 3. - 
Active malware detection model exploiting the spatial and temporal properties of GPRs.
Fig. 3.
Active malware detection model exploiting the spatial and temporal properties of GPRs.

Show All

Malware detection adopts a combined model by jointly using convolution neural networks (CNNs) and Long Short-Term Memorys (LSTMs), to spot illegal behaviours with a short sample length. The architecture of the proposed FusionST model is shown in Fig. 3b. Its input is a series of sub-samples with a particular length. The first four CNNs abstract the spatial correlations among GPRs by fusing information from different layers, and then the following LSTM blocks encode the sequential information (temporal correlations) for final detection. Similar to the rootkit detection, the final result is submitted to attack response module and associated defense actions are triggered.

Scenario 2: Active trusted computing. Traditional trusted computing has two limitations. First, as the root of trust, Trusted Platform Module (TPM) chip needs to be invoked by the CPU. Therefore, once a computer is compromised, the trusted measurement process will be bypassed. Second, the measurement fails to detect dynamic changes, therefore, some researchers propose an active integrity measurement that can measure the integrity both statically and dynamically. On the one hand, static trusted measurements are performed when the computer is powered on or before a software application is executed. To maintain the integrity of the static chain of trust, the operating system kernel, libraries, and all applications must be measured before execution. Computers, on the other hand, perform dynamic trusted measurements when it is running, with such measurement task running on the ASP. This model can initiate integrity measurement to establish a trust chain composed of multiple trust dependencies.

Scenario 3: Active noise interference. When running applications, certain patterns can be found in microarchitecture behaviors as the hardware usually work with a certain set of policies or rules. Such observable patterns bring opportunities for attackers. For example, by observing the relevant microarchitecture behaviors, such as cache hit ratio, the attackers can infer the victim's secrets via side channel information leakages. In addition, these deterministic behaviors of micro-architecture components, such as branch predictors, allow attackers to train them maliciously and induce victims to transmit secrets through various covert channels. Within the security-first architecture, ASP can actively add noises to make the CPU “non-deterministic executing”, which brings more difficult for the attackers to sneak in. Taking the cache as an example, an adversary can evict a target cache line with a group of conflict lines, named as eviction set, and then monitor the cache to observe subsequent cache accesses issued by victim. Recent researches [16], [17], [18] confirm it is effective to defend against the attacks by randomizing the address-to-set mapping in hardware. Leveraging cryptography hash functions, the randomized index mechanism dynamically remaps the layout inside caches to prevent attackers from exploiting cache evictions as one viable side-channel. As the root of trust of the computer, the ASP is in charge of randomizing the CPU cache layout by dynamically configuring the random table and related flush logic inside the CPU cache. The ASP determines: ① whether to enable/disable the cache layout randomization; ② when to re-random the current cache layout; and ③ how to update the hash keys of the random table by adjusting the table indexes of keys. These actions are taken by the ASP according to specified security policies. As shown in Fig. 4, the CPU randomizes the hash keys used to remap cache index by the ASP-managed random table. The set index of a cache line is computed by XORing the randomized hash key with the original deterministic index, thus generating a cache layout that is completely unknown for adversaries. Such randomized layout makes it difficult to construct a definitive eviction set to complete a side-channel attack. Moreover, only ASP can manage the random table, there is no path for any software running on CPU to access this random table. It protects this mechanism from being comprised.


Fig. 4.
Random cache mapping controlled by the ASP.

Show All

SECTION 4Design Exploration of Built-in Security Computer Based on ASP
ASP can be implemented as an additional IP module on a chipset, an extra core on a processor chip, a separate processor chip, as well as the combination of on-chip agents and off-chip separate chip. They all follow the design philosophy of the security-first architecture, and reflect different design considerations in terms of system overhead, complexity and performance. In this section, different candidates mentioned above will be compared. In general, the on-chip implementation has the advantages of high-density integration, and efficient data collection, but its cost is expensive since it needs to modify the CPU or chiplet chip. Meanwhile, the off-chip scheme has better applicability and independence.

Integrate the ASP with the chipset. As shown in Fig. 5, the ASP is located at the entry point of the chipset as an integrated IP and is attached to the existing on-chip fabric of the chipset. This implementation makes it convenient for the ASP to analyze I/O traffic and effectively shutdown/re-open the I/O channel when requested. Following the principles of asymmetric memory space, the ASP has its own memory, disk, and I/O devices. An embedded DMA engine is used to scan the memory of the computing subsystem. However, the original chipset already has an complex internal architecture, which contains an on-chip routing fabric and several controllers for various I/O devices. It is difficult to increase the number of I/O pins in such an I/O bounded chip. The memory bandwidth for ASP is thus possibly limited. For this reason, Intel ME borrows memory from the CPU but introduces security risk as well.


Fig. 5.
Implement the ASP with the chipset.

Show All

Integrate the ASP inside the CPU chip. Shown in Fig. 6, the ASP is integrated into the CPU chip as an extra core. This is the most efficient way for ASP to monitor and analyze the on-chip micro-architecture behaviors on the CPU side. On-chip monitoring enables timely identification and response to elusive attacks and malicious behaviors. It also avoids transferring a large amount of behavior data outside the chip. Since the ASP is also utilized as an extra IP, it has similar performance and memory bandwidth limitations as the chipset implementation.


Fig. 6.
Implement the ASP inside the CPU.

Show All

Implement the ASP in a separate chip. As depicted in Fig. 7, the ASP is deployed as a separate chip. The ASP controls all system resources, monitors all CPU off-chip requests in fine granularity and collects all the CPU micro-architectural events. Compared with other design options, this implementation enables the largest asymmetric memory bandwidth for ASP. It is even possible to use additional hardware accelerators for improving efficiency of the security tasks. For example, online realtime deep neural network learning tasks can be boosted by using additional AI accelerators, which could greatly enhance the ability of monitoring and recognizing elusive attacks.


Fig. 7.
Implement ASP as a separate chip.

Show All

On-chip and off-chip combined implementation. In order to improve the efficiency, CPU and ASP need to collaborate in event collection and analysis (shown in Fig. 8). On the one hand, some scenarios make analysis based on a large amount of runtime information of CPU, such as collecting instruction trace, scanning memory region, and so on. A reasonable approach is to embed the corresponding proxy module into CPU, process the information quickly and then send it to the Off-chip ASP. This approach avoids CPU modifications as much as possible, while also facilitating the deep collection of various runtime information. On the other hand, the ASP needs to issue control or configuration commands (e.g., injecting noise) to some modules of the CPU. This also requires support from CPU hardware. In addition, in order to support the one-way physical isolation between the CPU and ASP, these modules embedded in the CPU chip cannot be controlled and modified by any CPU software.

SECTION 5Evaluation and Analysis
5.1 Methodology
5.1.1 Platform 1: Built-in Security Computer Based on CPU and ASP
We designed our first-generation ASP in the form of a separate chip. As shown in Fig. 9a, it consists of a processor core, Active PCIe Interface, memory controller, electrical fuse (eFUSE), as well as necessary I/O interfaces like SPI, UART, etc. The ASP chip is implemented with a 40 nm low leakage process. The chip layout is shown in Fig. 9b, and the major parameters are listed in Table 1. And then, the built-in security computer is built based on the ASP chip and a Intel core i9-7920X general-purpose processor. We connect the ASP to the commercial Intel processor via the PCIe bus, as illustrated in Fig. 10. The detailed configurations are summarized in Table 2.

TABLE 1 Major Parameters of ASP Chip
Table 1- 
Major Parameters of ASP Chip
TABLE 2 Built-in Security Computer Based on Intel Core i9-7920X and Separate ASP Chip (Platform 1)
Table 2- 
Built-in Security Computer Based on Intel Core i9-7920X and Separate ASP Chip (Platform 1)
Fig. 8. - 
Combined implementation of the ASP.
Fig. 8.
Combined implementation of the ASP.

Show All

Fig. 9. - 
ASP chip.
Fig. 9.
ASP chip.

Show All

Fig. 10. - 
The built-in security computer based on ASP and Intel core i9-7920X Processors (Platform 1).
Fig. 10.
The built-in security computer based on ASP and Intel core i9-7920X Processors (Platform 1).

Show All

One of the key functionalities of ASP chip is the unidirectional isolation, which is enabled by its internal Active PCIe Interface module. It bridges the CPU and ASP, and is responsible for data exchange and filtering. Its major components include the generic PCIe interface, address translation module, and hard isolation logic. Specifically, the generic PCIe interface handles the PCIe inbound and outbound traffics between CPU and ASP. The address translation module consists of inbound address filtering (INAF) and outbound address transformation (OUTAT). The requests initiated by CPU (red dot line in Fig. 9a) are considered as untrusted and will be filtered by INAF. The filtered raw data are passed to hardware isolation logic. By contrast, the requests initiated by ASP are considered as trusted (dark dot line in Fig. 9a) and will be transformed by OUTAT according to the specific address mapping between the PCIe space and the CPU memory space. The hardware isolation logic is composed of Shared Memory and Equivalent Interval Time Division Multiplexing (EITDM). The Shared Memory exchanges the filtered un-trusted messages from CPU and security functional messages initiated by ASP. By using equivalent access time technology, the EITDM guarantees the access time of each memory request from either side is nearly constant, which thus mitigates the timing side-channel between CPU and ASP.

With the cooperation of generic PCIe interface, address translation module and hardware isolation logic, two major security enhancements can be achieved. First, the ASP chip can actively initiate the access requests to CPU memory space without the participation of CPU (such as CPU read/write and DMA). Second, the asymmetric address space is enabled between ASP and CPU. It means that ASP can access all CPU resources, e.g., memory, I/O traffic, but the CPU can only access the limited shared memory exposed by the hardware isolation logic, and cannot access the ASP's private resources, e.g., local I/O and memory. Therefore, the physical separation between the ASP chip and the Active PCIe Interface provides a more secure execution environment for the system security tasks, where the secure strength is much better than the traditional software isolation.

5.1.2 Platform 2: Gem5 Based Simulator
Current commercial processors do not yet support the active noise interference discussed in Section 3.3. To evaluate its performance, we choose the cycle-accurate full-system simulator, Gem5 [19], as the evaluation platform. The specific configuration is shown in Table 4. The Gem5 simulator has been modified to support the cache layout randomization mechanism. Recent works [16], [17], [20] reveal that the key of this security mechanism is to decide when and how frequent to update the map table and thus evict corresponding dirty cache lines. The ASP collects the accessing behavior from caches at different levels, and starts resetting and flushing within a specific timing threshold, which is set to half an hour by default in our case.

TABLE 3 Experimental Scenarios on Platform 1

TABLE 4 Gem5 Simulator Configurations of Platform 2

5.1.3 Benchmarks
Performance Evaluation. Based on the real hardware system of Platform 1, we first evaluated the performance impacts with three classic computing benchmarks: SPEC CPU 2000 with reference input, UnixBench and Stream. SPEC CPU 2000 is an industry-standardized benchmark suite for performance evaluation. UnixBench is used to evaluate the performance of the system while running single-thread and multi-thread tasks. Stream measures sustainable memory bandwidth and the corresponding computation rate for simple vector kernels. We construct three scenarios listed in Table 3, which imitate different deployments of security and computing tasks. Scenario-A simulates the on-chip ASP implementation which shares the LLC and on-chip fabric with CPU cores. In Scenario-A, the security tasks are allocated on the core #0 of CPU, the computing benchmarks run on the other cores (core #1∼#11). Both Scenario-B and Scenario-C target at the proposed off-chip ASP implementation. In these two scenarios, computing benchmarks run on the core#1∼#11. Differently, the security tasks run on the separate ASP chip in Scenario-B, but there is no security task running in Scenario-C.

On the Platform 2 (Gem5 simulator), we ran the SPEC CPU 2006 benchmark with train input size to evaluate the performance cost of cache randomization managed by on-chip ASP.

Security Evaluation. Based on Platform 1, four typical attack scenarios are constructed to evaluate the mechanism of rootkit detection, including injecting the BIOS Trojan to control system startup, maliciously modifying system files, running rootkits on the kernel, and running malware without obvious characteristics. Then, to test how the deep malware detection model performs when confronted with completely new malware, we collected two non-signature test sets that involve multiple malware makers, such as DarkHorse, Posion, and Necro (see Table 5). The non-signature malwares (positive samples) were released in 2018 by VirusShare. Additionally, 150 malware using Virus Maker Pack Ultimate Collection 2017 are generated as another non-signature positive test set. Furthermore, another 150 benign samples from the SourceForge malware [21] are used as the negative test set. And with the two new test sets, we compare the FusionST model with other three popular antivirus software (AVware, ESET-NOD32, and Kaspersky) [22].

TABLE 5 Non-Signature Test Sets

5.2 Performance Evaluation
5.2.1 Performance Impact of Active Trusted Computing
Taking active memory monitoring as an example security task, we investigate the performance impacts of different ASP implementations on the computing workloads and further analyze the reasons. Specifically, we compared the performance of the scenarios described in Table 3 on Platform 1. As can be seen from Table 6, the performance of the off-chip ASP (Scenario-B) and baseline (Scenario-C) is similar, which indicates that the off-chip ASP does not interfere with the computing workloads. However, on-chip ASP (Scenario-A) has observable performance interference with the computing workloads. For example, in case of UnixBench, the average performance impact of off-chip ASP on the computing workloads is 0.04 percent, while the performance impact of the on-chip ASP is 6.87 percent.

TABLE 6 Performance Impact of Active Trusted Computing on Platform 1
Table 6- 
Performance Impact of Active Trusted Computing on Platform 1
To understand this performance difference, we used Intel VTune profiler to observe the microarchitecture behaviors for different implementations and found that on-chip LLC cache competition was one of the most important reasons. In our experiment, the simulated on-chip ASP needs to share last-level cache (LLC) with the CPU core. Dynamic memory monitoring generates frequent off-chip memory requests, causing high LLC miss rate. Such frequent access traffics interfere with the computing workloads due to LLC contention. Table 7 describes the observed LLC bound, which indicates how often CPU is stalled on LLC cache, or contended with a sibling Core. As can be seen, current implementation of on-chip ASP causes performance degradation due to LLC resource contention. It is noted that one better on-chip ASP implementation does not need to share LLCs with the CPU, but might still compete with on-chip fabric and memory controllers. Thus frequent access still might interfere with the computation intensive workloads.

TABLE 7 Last Level Cache Contention
Table 7- 
Last Level Cache Contention
5.2.2 Performance Evaluation of Active Noise Interference
Fig. 11a demonstrates that minimum impact has been made by the active noise interference during the cache address randomization. The performance loss is less than 5 percent for most cases. Noted that some cases even have performance speedup, for example, the performance of mcf and lbm are improved by 1.5 percent. The major reason is that there are fewer cache line conflicts after cache layout randomization.

Fig. 11. - 
Performance evaluation of ASP-controlled cache randomization on Platform 2.
Fig. 11.
Performance evaluation of ASP-controlled cache randomization on Platform 2.

Show All

To have a better understanding of its performance impacts, Fig. 11b shows MPKI changes. Since the MPKI of L1 ICache is much smaller than other caches, it is not listed. In case of L1 DCache, its MPKI loss is less than 10.5 percent on average. The exceptional cases include astar, sjeng, and gamess, their MPKI of L1 DCache decreases significantly. In case of L2 and L3 cache, the MPKI overhead for memory-bound benchmarks, such as libquantum, mcf, lbm and soplex, is less than 5 percent. For the cases presenting abnormal overhead, such as astar, hmmer, gamess, gromacs or sphinx3, a small MPKI (less than 10) has been found at these cache levels. Such abnormal overhead is caused by a small variation on a very small MPKI.

5.3 Evaluation of Security Tasks Running on ASP
5.3.1 Rootkits Detection Based on Active Memory Monitoring
Compared with well-known open source antivirus software and rootkit detection software, the detection capability of the ASP-based active memory monitoring mechanism is verified. Among them, the open source antivirus software include clamav, Comodo Antivirus, Sophos Antivirus for Linux; the open source Rootkit detection software include unhide, RKHunter, and chkrootkit; and the typical rootkits as detection targets include amark, Diamorphine, Wukong, lkm-rootkit, givemeroot, Suterusu, modhider, and adore-ng. The detailed comparison are summarized in Table 8.

TABLE 8 Rootkits Detection on Platform 1

Conventional rootkits detection software is usually based on the signatures of existing rootkits. Generally, it can only detect specific behavior of the attacks, but fails to cover different variants of rootkits. As a contrast, our proposed active memory monitoring can effectively detect various rootkits. In particular, it can accurately locate the program of rootkits and thus infer the potential attacks, which has significantly enhanced security.

In order to evaluate the detection interval, we used Lmbench [23], a popular performance evaluation tool, to investigate from the following aspects: 1) process operations; 2) context switching; 3) communication; 4) basic computing; 5) file operations. The evaluation results are shown in Table 9. The baseline is the case of disabling active memory monitoring, the ‘600s’ indicates that the dynamical measurement is triggered every 600 seconds. It can be observed that the detection interval has almost negligible impacts on the performance of normal computing tasks running on CPU. Since the measurement module runs on a physically separate ASP subsystem, it will only cause high overhead of ASP system even if the measurement frequency is high (e.g., the detection interval is 1 second).

TABLE 9 Evaluation on Detection Interval

5.3.2 Malware Detection Based on Contents of GPRs
We utilize the microarchitecture features of the processors to detect malicious behaviors. It is mainly divided into two steps. First, the GPRs of the malicious program are obtained. Second, the malicious program is identified by analyzing the GPRs via classification algorithm.

As shown in Table 10, we can find that three anti-virus software have good malware detection performance since the downloaded test set has been signed for these anti-virus software specifically. However, it is hard for those three anti-virus software to identify the generated test samples, since the generated samples are Zero-day (or unknown) malware for them. We also test these generated executable files on the VirusTotal website using 65 latest anti-virus engines. The report shows that none of anti-virus engines consider these newly generated files as malicious ones. The FusionST model can accurately identify non-signature malware. For instance, the accuracy of FusionST is 0.940 when the FPr is 0.087 on the generated test set. It indicates that malicious program recognition technology based on GPRs micro-architecture features can effectively detect malicious programs.

TABLE 10 Evaluation of Detecting Non-Signature Malware on Platform 1

5.4 Security Analysis
Our threat model assumes that adversaries could get root privilege to control the CPUs, then the security of the computer system depends on two key factors: the ability of ASPs to detect potential malware in time, and the ability to prevent ASPs themselves from being compromised. For the first factor, the ASP performs the static trusted measurements during the phase of secure boot, and dynamically measures the memory, especially the key data structures of kernel while the computer is running. For the second factor, we have adopted the following security enhancements. At the architecture level, the asymmetric address space is used to realize the unidirectional isolation, so that the compromised CPUs can't access the ASP's resource anyway. Furthermore, the interference circuits have been added in ASP chip to resist power leakage. For software running on ASPs, the techniques of encryption and signature verification have been used to guarantee the integrity of the software and security mechanisms. Additionally, the OS running on ASP is customized, and the security verification based on formal methodology is considered as one of future work.

SECTION 6Related Work
Hardware TEE (trusted execution environments) is one of promising approach to provide secure execution. For example, TrustZone [24] is deployed in ARM processors to separate a secure world and a non-secure world on the same physical core, dealing with sensitive and non-sensitive processes respectively. The switch between the two worlds are managed by a security monitor. By increasing the identity at the page table level, the data in a secure world and a non-secure world can be distinguished and the data in secure world is inaccessible to the non-secure world. Software Guard Extensions (SGX), proposed by Intel, isolates a secure enclave for sensitive processing from a normal untrusted execution environment with the support of hardware, software, and operating system. Programs outside the enclave do not have the rights to access data directly within enclaves. However, for SGX and Trustzone, both secure world/enclaves and non-secure world share the same microarchitecture, which gives attackers the opportunity to steal sensitive information through side-channel attacks [25], [26], [27]. For example, SgxPectre [25] attacks exploit the shared branch predictor and cache hierarchy. Based on the concept of enclave, some enhanced mechanisms were proposed provide private environment for security codes or data in computing programs. Sanctum [28] protects secrets in enclaves from cache timing attacks through software isolation with a minimal hardware changes. On every enclave entry and exit, MI6 [29] provides stronger isolation than Sanctum through statically distributing memory resources and flushing the state of temporally shared per-core private resources . IRONHIDE [30] further deduces the performance overhead caused by flushing mechanism through dynamic hardware re-allocation with inter-process communication (IPC) on multicore processors. Compared to these mechanisms, our work focuses on providing a secure computing environment using a separate security subsystem based on ASP for security tasks, rather than the code and data in computing tasks. Furthermore, it adopts asymmetric address space to realize the unidirectional isolation between CPU and ASP.

Trusted Platform Module [31], proposed by the Trusted Computing Group(TCG), employs a dedicated processor as the root of trust and is responsible for some of the secrets-related functions. Nevertheless, the security capabilities of this mechanism are limited. Management Engine(ME) in Intel processors and Platform Security Processor in AMD processors employ dedicated weak processor to run security tasks, including secure boot, recording key, remote reboot, etc. However, these mechanisms share some resources with the computing unit. For instance, the ME shares a reserved memory space with the computing unit in Intel processors [32]. Furthermore, there are several vulnerabilities for Intel ME and AMD PSP [33], [34]. For example, the secure boot can be bypassed in ME and PSP because they do not provide secure version control of firmware and the attacker can roll it back to non-secure status [33].

Meng et al. proposed the concept of the security-first architecture [35]. And this paper made the following extension. First, the security tasks running on ASP are refined, including active trusted computing, an AI-based malware detection based on GPRs, active noise interference, etc. Second, the microarchitecture of the ASP chip, especially Active PCIe Interface which provides unidirectional isolation, is introduced in detail. Third, a realistic built-in security computer integrating a separate ASP chip is introduced, and the performance evaluation is investigated on this platform. Finally, the security of ASP is analyzed, especially the detection accuracy against rootkit attack.

In addition, many existing hardware-assisted security mechanisms are proposed to defend against specific attacks. For example, control flow integrity can be protected by hardware-assisted mechanisms [36], [37] to prevent Return Oriented Programming (ROP) and Jump Oriented Programming (JOP) attacks [38], [39]. By changing the mapping relationship [16], [17], [18] or employing partitioned architecture [40], [41], cache side-channel attacks can be prevented. Speculative execution side-channel attacks can be defended by identifying suspicious instruction in speculative execution window and preventing them to leave secrets-dependent traces in microarchitecture [42], [43], [44], [45]. These security mechanisms can be effectively combined with our proposed security-first architecture. Specifically, these mechanisms are deployed in the CPU core or on-chip cache hierarchy, while the management module can be deployed on the ASP.

SECTION 7Conclusion
Continually disclosed vulnerabilities reveal that traditional computer architecture lacks the consideration of security. This paper proposed a security-first architecture, which considers security as a first-citizen requirement during the design stage. In addition to traditional computing CPUs, the security-first architecture introduces a new processor unit dedicated to running security tasks, called Active Security Processor. Thats to say, traditional CPU is responsible for running computing tasks, and the security mechanisms run independently on the ASP. The CPU and ASP have their private resources, including memory, disk, network and I/O devices, to run separate operating systems and applications. This new architecture adopts asymmetric address space to realize the unidirectional isolation between CPU and ASP. In particular, the super root permissions possessed by ASP enables it to efficiently access all CPU resources and cannot be disabled by the computing CPU, meanwhile, the CPU has no access to any ASP resources. The first-generation ASP was designed and implemented based on the 40 nm technology, and a secure computer system was implemented based on it. Evaluations on this real hardware platform demonstrate that security mechanisms running on the ASP effectively protects the security of the computing environment, and the performance impacts on computing tasks are minimal.

