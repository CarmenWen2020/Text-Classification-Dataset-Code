The promises of advanced quantum computing technology have driven research in the simulation of quantum computers on classical hardware, where the feasibility of quantum algorithms for real-world problems can be investigated. In domains such as High Energy Physics (HEP) and Remote Sensing Hyperspectral Imagery, classical computing systems are held back by enormous readouts of high-resolution data. Due to the multi-dimensionality of the readout data, processing and performing pattern recognition operations for this enormous data are both computationally intensive and time-consuming. In this article, we propose a methodology that utilizes Quantum Haar Transform (QHT) and a modified Grover's search algorithm for time-efficient dimension reduction and dynamic pattern recognition in data sets that are characterized by high spatial resolution and high dimensionality. QHT is performed on the data to reduce its dimensionality at preserved spatial locality, while the modified Grover's search algorithm is used to search for dynamically changing multiple patterns in the reduced data set. By performing search operations on the reduced data set, processing overheads are minimized. Moreover, quantum techniques produce results in less time than classical dimension reduction and search methods. The feasibility of the proposed methodology is verified by emulating the quantum algorithms on classical hardware based on field programmable gate arrays (FPGAs). We present designs of the quantum circuits for multi-dimensional QHT and multi-pattern Grover's search. We also present two emulation techniques and the corresponding hardware architectures for this methodology. A high performance reconfigurable computer (HPRC) was used for the experimental evaluation, and high-resolution images were used as the input data set. Analysis of the methods and implications of the experimental results are discussed.
SECTION 1Introduction
Quantum computing is a promising new paradigm in the computer science domain. Quantum computers could demonstrate significant speedup versus classical computers by solving classical NP-hard problems [1], [2], [3] in polynomial time. Different quantum algorithms provide different kinds of speedup, compared to their classical counterparts e.g., using Shor's algorithm [1] for factoring will provide superpolynomial speedup [4], while quantum search using Grover's algorithm [2] provides polynomial speedup [4]. The ongoing development of noisy intermediate-scale quantum (NISQ) devices by companies such as D-Wave [5], IBM [6], Google [7], Intel [8], Rigetti [8], and IonQ [9] marks a significant step towards quantum supremacy [10]. NISQ devices, which are capable of processing hundreds of quantum bits, will play a crucial role in the real-world use of quantum computing technology and the speedups provided by quantum algorithms. As quantum computing technology continues to develop, it is necessary to analyze the behavior and feasibility of quantum algorithms, and to investigate their potential applications. In addition, the full breadth of classical problems that quantum computers will be able to solve efficiently has not yet been realized, which is one of the major motivations of our work.

In domains which have high-dimensional readout data [11], not all the measured data components are relevant in detecting the underlying regions of interest (RoI). Generally, statistical predictive models [12] are applied to high spatial resolution multi-dimensional data sets for detecting and matching certain patterns. However, this process is computationally intensive. Alternatively, an effective pre-processing method is used to reduce the dimensionality [13] of the data in such high-dimensional spatial sets, for faster post-processing and pattern matching. Wavelet-based dimension reduction techniques [14], [15] have been proposed for this purpose and have been shown to be effective in data pre-processing, reducing computation overhead, and improving classification accuracy. However, the enormity of high resolution readout data in domains such as High Energy Physics (HEP) [11] and remote sensing hyperspectral imagery [14] would still pose a challenge for conventional/ classical wavelet-based dimension reduction techniques. On the other hand, quantum information processing (QIP) techniques [16], [17] such as quantum wavelet transform have been shown to be effective in processing large data volumes in applications such as quantum image processing and quantum data compression [18], [19], [20].

In this work, we propose employing quantum Haar transform (QHT) and quantum Grover's search (QGS) for time-efficient pattern recognition in data sets that are characterized by high-spatial resolution and high dimensionality. The QHT algorithm is used as a pre-processing step for reducing the dimensionality of the data at preserved spacial locality, while QGS algorithm is used to perform pattern matching on the reduced data. We present simplified and efficient quantum circuits that perform multi-level decompositions of multi-dimensional QHT including two-dimensional and three dimensional QHT (2D-QHT and 3D-QHT). In addition, a generalized Grover's search algorithm and circuits for dynamic multi-pattern searching [21] is proposed for this methodology. For evaluating our proposed methodology, we develop the equivalent hardware architectures for emulating the proposed quantum circuits, and implement them on a high performance reconfigurable computing (HPRC) testbed. The developed architectures are pipelined for high throughput, and support single-precision floating-point arithmetic for high accuracy. We provide extensive experimental results using both high resolution single-band and high-resolution multi-spectral data sets.

The contributions of this manuscript are summarized as follows. We propose the application of quantum algorithms for dimension reduction of high-resolution, hyperspectral data and also for performing pattern recognition on the reduced data. We present a methodology that combines the quantum Haar Transform (QHT) algorithm with quantum Grover's search (QGS) algorithm for the pattern recognition application based on dimension reduction. We present generalized QHT circuits that can perform multi-dimensional (1D, 2D, 3D, etc.) and multi-level decompositions of QHT operations depending on the dimensionality of the data. We also generalize the conventional Grover's search circuits and propose modifications that extend the search to dynamically changing multiple patterns. To evaluate the quantum circuits, we present emulation models and propose newer emulation techniques that are more time and space efficient. We design the equivalent hardware architectures for emulation and implement the proposed methodology on a high-performance reconfigurable computer.

We present improved and extensive experimental results that use real multi-spectral data and show that the proposed methods are feasible for future quantum applications. We chose to experimentally evaluate the proposed circuits on a classical platform due to the high costs and the primitive state of existing NISQ quantum systems. Quantum circuits and algorithms are being simulated classically on a variety of platforms such as CPUs, GPUs, and FPGAs [22], [23], [24], [25], [26]. Our preference was an FPGA-based platform because they can take advantage of the inherent parallelism in quantum algorithms. FPGAs are more cost-effective and power-efficient than other accelerator architectures such as GPUs, and the reconfigurability of FPGAs also gives them a unique advantage over other parallel accelerator architectures.

The rest of the paper is organized as follows. Section 2 contains background information related to general quantum computing concepts, quantum gates, quantum Haar Transform, and Grover's search algorithms as well as review of related work. The quantum circuits for multi-dimensional (2D and 3D) QHT and single-pattern/multi-pattern QGS are presented in Section 3. In Section 4, we discuss two types of emulation models and the corresponding hardware architectures for quantum circuit emulation. Section 5 contains our experimental results. Lastly, Section 6 ends with our conclusion and a discussion of future work.

SECTION 2Background and Related Work
In circuit-based modeling of quantum computing [16], computation begins with the system set in a specific unentangled quantum state |ψ⟩, usually the ground or |0⟩ state. This quantum state can be expressed as a superposition of 2n=N basis states as shown in (1), where ⊗ represents the Kronecker product and n is the number of qubits. The magnitude of the complex-valued state coefficients (γ0,γ1,…,γN−1) represent the probability of finding the quantum state in the corresponding basis state when measured. It naturally follows that the sum of the magnitude of the state coefficients is equal to 1. Depending on the quantum algorithm, different unitary transformations, i.e., U1, U2, ..., Um, or gates can be applied to the quantum state to reach a final quantum state, see (2). These operations involve transformations on the complex coefficients of the basis states. When a final measurement is carried out, the quantum state collapses into a readable classical state, and the superposition that existed prior to the measurement is lost [27].
|ψ⟩=|qn−1⟩⊗|qn−2⟩⊗…|q1⟩⊗|q0⟩=|qn−1qn−2…q1q0⟩=∑i=0N−1γi|i⟩(1)
View Source
|ψout⟩=Um⋅Um−1⋅ …⋅U2⋅U1⋅|ψin⟩.(2)
View Source

2.1 Qubits, Superposition, and Entanglement
The quantum bit or qubit is the smallest unit of quantum information [27]. A single qubit can exist in superposition of two basis state, |0⟩ and |1⟩, which can be represented by the Bloch sphere as shown in Fig. 1 (in the appendix, which can be found on the Computer Society Digital Library at http://doi.ieeecomputersociety.org.ezproxy.auckland.ac.nz/10.1109/TC.2020.3034883). The north pole of the Bloch sphere represents the basis state |0⟩ while the south pole represents the basis state |1⟩. Any other point on the surface of the sphere is a valid mixed state of the two basis states. The overall state of the qubit is satisfied by the linear superposition equation, see (3), where α and β are complex numbers whose values depend on φ and θ as shown in Fig. 1 (in the appendix available in the online supplemental material). When a qubit is measured it will collapse to a basis state where |α|2 is the probability of finding the qubit in the basis state |0⟩ and |β|2 is the probability of of finding the qubit in the basis state |1⟩.
|ψ⟩=α|0⟩+β|1⟩≡(αβ)(3)
View Source

Entanglement is another distinguishing property of qubits [16]. Two or more qubits may become entangled meaning that each entangled qubit becomes strongly correlated to the other and the quantum state cannot be factored into a Kronecker product of the individual qubits, i.e., |ψ⟩=|qn−1qn−2…q1q0⟩≠|qn−1⟩⊗|qn−2⟩⊗…|q1⟩⊗|q0⟩. The benefit of quantum entanglement is that operations on one entangled qubit can affect other entangled qubits. Likewise, measuring an entangled qubit can give information about the state of other entangled qubits [27].

2.2 Quantum Gates
In quantum computing, quantum gates are thes and are analogous to classical logic gates [27]. Quantum gates are used to manipulate the states of qubits and are represented by N×N unitary matrices where N=2n and n is the number of qubits. In other words, a one-qubit gate is represented by a 2×2 unitary matrix, a two-qubit gate is represented by a unitary 4×4 matrix and so forth. A general representation of a 1-qubit gate, U, is shown in (4). Commonly used quantum gates such as the Hadamard, X, cX, Z, and cZ are discussed in the next sections.
U=[acbd],wherea,b,c,d∈Cand,UU†=U(U∗)T=I.(4)
View Source

2.2.1 Hadamard Gate
The Hadamard, or H gate, is an important single-qubit gate because it creates an equal superposition of the basis states [27]. When an H gate is applied to the ground or |0⟩ state, the resulting state will be an equal probability superposition between the |0⟩ and |1⟩ states, i.e., 12√(|0⟩+|1⟩). The matrix representation of an H gate is given in (5).
H=12–√[111−1].(5)
View Source

2.2.2 X and cX Gate
The X gate is a single-qubit gate that is analogous to the NOT gate in classical computing and swaps the α and β coefficients of a qubit [27]. A control qubit can be added to an X gate creating a two-qubit gate called the cX or Controlled NOT gate. When the control qubit is equal to |1⟩ then the target qubit will be inverted, i.e, an X gate will be applied, otherwise, it will remain unchanged [27]. Additional control qubits can be added as needed resulting in the generic ckX gate, where k is the number of control qubits. The matrix representation of X and cX gates are given in (6).
X=[0110],cX=⎡⎣⎢⎢⎢1000010000010010⎤⎦⎥⎥⎥.(6)
View Source

2.2.3 Z and cZ Gate
The Z gate, or Phase Inversion gate, is a single-qubit gate that inverts the phase of the input qubit, i.e., inverts the phase of the |1⟩ basis state while leaving the |0⟩ basis state unchanged [27]. Like the ckX gate multiple control qubits can be added to create a ckZ gate such that when the control qubits are all equal to |1⟩ a Z gate is applied to target qubit which is otherwise unchanged. The matrix representation of a Z and cZ gate is given in (7).
Z=[100−1],cZ=⎡⎣⎢⎢⎢100001000010000−1⎤⎦⎥⎥⎥.(7)
View Source

2.3 Quantum Wavelet Transform
The quantum wavelet transform (QWT) [18], [19], [20] is the quantum equivalence of the classical discrete wavelet transform (DWT). The simplest DWT is the Haar wavelet transform [15]. It can be constructed using a unit step function, u(t), as shown in (8), where a and b are the time dilation and displacement factors respectively. The discretized version of the Haar wavelet function is defined as (9), where t=q.Δt, b=j.Δt, a=K.Δt, Δt is the sampling period, and K is the Haar window size in samples. The expression for discrete Haar wavelet transform can be derived [15] as (10), where N is the number of data samples.
Ψ(t−ba)=u(t−ba)−2u(t−ba−12)+u(t−ba−1)(8)
View Source
ΨD(q−jK)=⎧⎩⎨⎪⎪⎪⎪+1,−1,0,0≤(q−j)<K2K2≤(q−j)<Kotherwise(9)
View Source
FD(j,K)=∑q=0N−1fD(q.Δt)ΨD(q−jK).(10)
View SourceIn the quantum domain, the signal samples are encoded as the coefficients of a quantum state, which is in superposition of its constituent basis states. This is expressed as a normalized sequence of amplitudes as shown in (11), where n is the number of qubits, N=2n is the number of basis states of the quantum system, and |ψ⟩ is the input quantum state. By applying the wavelet function on the coefficients of the quantum state, the equivalent expression for quantum Haar wavelet transform (QHT) is given by (12), where |ψ⟩QHT is the output quantum state.
|ψ⟩=∑q=0N−1f(q.Δt)|q⟩,where∑q=0N−1|f(q.Δt)|2=1(11)
View Source
|ψ⟩QHT=1N−−√∑j=0N−1∑q=0N−1f(q.Δt)ΨD(q−jK)|j⟩.(12)
View Source

2.4 Quantum Grover's Search
Grover's search [2] is a quantum algorithm for searching an unstructured data arrays of N elements [27]. The objective of Grover's search algorithm is to find the element s∗ such that f(s∗)=1 and holds (13) true, where s∗ belongs to the set S={s1,s2,s3,…,sN} where N is the cardinality of S, and f is a boolean function such that f(x)→{0,1} [27].
f(x)={1,ifx=s∗0,ifx≠s∗.(13)
View Source

For a set of cardinality N, a classical computer will take on average N2 queries [27] as the classic machine iterates trough each element individually. However, on a quantum machine using Grover's algorithm only N−−√ queries are needed resulting in a quadratic speedup over classical computers [27]. Grover's algorithm can also be used to find multiple items in the same set [21]. The algorithm finds each of the target patterns with equal probability. The input quantum state is formed from entangled, superimposed qubits with equal coefficients [27]. The input quantum state undergoes two operations: phase inversion, and inversion about the mean [27].

The phase inversion operation is usually assumed as a black box called the oracle [27], which will take the input state, |x⟩, and invert the select coefficient of the target basis state. The Oracle unitary operation is denoted as Uf, as shown in (14). Where, if x≠s∗, then f(x)=0 and no change will be made to |x⟩. Otherwise, if f(x)=1 then |x⟩ will be multiplied by −1 resulting in a phase inversion for |x⟩. This has the effect of singling out the desired values of x to be amplified in the next step.
Uf|x⟩=(−1)f(x)|x⟩(14)
View SourceRight-click on figure for MathML and additional features.

In the inversion about the mean operation, the inverted coefficient amplitudes will be amplified while the other coefficient amplitudes will be attenuated [27]. This is done by rotating each values about the mean value of all the amplitudes. This results in the unselected amplitudes, which are close to the mean and positive, to be attenuated while the selected amplitudes, which are far from the mean and negative, to be amplified. The inversion about the mean operation is denoted by unitary operator Us as shown in (15). where |s⟩ is the output of the phase inversion stage, i.e., Uf|x⟩.
Us=2|s⟩ ⟨s|−1.(15)
View Source

The overall unitary operation for Grover's search can be denoted as Ug=UsUf |x⟩. This operation is iterated over several times to achieve the optimal amount of amplitude amplification [21] so that the coefficients of the sought patterns/basis states are maximized, thus making the success probability of finding the entangled qubits in the target states close to 1. The optimal number of iterations m is shown in (16)[21], where Np equals the number of solutions/patterns being searched for.
m=⎢⎣⎢⎢⎢π4sin−1(NpN−−−√)⎥⎦⎥⎥⎥.(16)
View Source

2.5 Related Work
We reviewed several notable related works on quantum wavelet transform (QWT) [18], [19], [20]. Fijany and Williams [18] present gate-level circuits for quantum Haar wavelet and Daubechies D(4) wavelet. They propose techniques for efficient quantum implementation of permutation matrices, which are required for factorization of the unitary operations of the wavelet transforms. Heidari et al. [19] investigate applications of QWT in image watermarking. They demonstrate improvement in invisibility and robustness of the watermarked image. The most recent work on QWT presented in Hai-Shen et al. [20] provide quantum circuit derivations for Haar and Daubechies wavelet transforms. The authors propose QHT circuits which contain k levels of permutations, where k is the kernel size.

The previous work on QWT presented circuits and software simulations. Comparatively, we present efficient hardware implementations of QHT. Our proposed circuits for multi-level, multi-dimensional QHT are simpler, more space-efficient, and generalizable. We propose application of these circuits in dimensionality reduction and detection of high spatial resolution data. Our approach is simpler and optimized for emulation because it uses a Haar kernel model and a pair of permutation models, where the permutation models are performed classically and are not part of the quantum computation. We propose classical circuits for permutation because (1) quantum permutation circuits implemented using multiple levels of swap operations have large quantum cost [19], [20], and (2) classical permutation techniques such as index scheduling are more space and time efficient for hardware implementation.

We also reviewed notable work on implementations of Grover's search algorithm. In the very first demonstration [29], Chuang et al., implemented Grover's search for a system of four states, using Nuclear Magnetic Resonance (NMR) techniques with chloroform molecules. The NMR system they used, however, lacked scalability and optimization at the time of their experimental demonstration. Mandviwalla et al. [30] contains experimental demonstration of Grover's on IBM's quantum computer. The authors implemented up to 4-qubit single-pattern Grover's search, presenting accuracy and execution time metrics of their implementations. Brickman et al. [31] present an implementation of single-pattern Grover's search on a 2-qubit, 4-state trapped ion quantum computer, and their results showed improvement over the equivalent classical search method. Researchers from IBM, Coles et al. [32], implemented 5-qubit Grover's search on the ibmqx4 quantum machine. However, in their experiments, they obtained less success rate in the implementations compared to their simulations. Figgatt et al. [33] demonstrated a programmable 3-qubit Grover's search on a trapped ion quantum computer. Lee et al. [26] presented an FPGA-based emulation of a 7-qubit Grover's circuit, but their proposed hardware architecture was limited in scalability.

Most of the related work presented single-pattern Grover's search implementations using a small number of qubits, which is not useful in practical applications. Moreover, they did not investigate or propose any actual applications of the algorithm. In our work, we present a Grover's search circuit which is modified from the conventional circuit, and generalized to enable dynamic single-pattern as well as multi-pattern searches. Our experimental results also show a higher number of entangled qubits emulated, compared to previous work. In addition, we propose a methodology that combines Grover's search with QHT algorithm for a useful and practical application such as pattern matching in high spatial resolution hyperspectral data. To the best of our knowledge, our work is the first to investigate these quantum algorithms for this particular application.

SECTION 3Proposed Methodology and Quantum Circuits
3.1 Overview of Methodology
In this paper, we present a methodology based on quantum algorithms for dimension reduction and pattern matching in high-resolution hyperspectral data. The methodology has two main operations, (1) performing dimension reduction on the input data set while preserving its spatial locality as a pre-processing technique, and (2) searching for the dynamically-changing target patterns in the data with reduced dimensionality. The first stage of operations, dimension reduction, is achieved by applying multi-dimensional QHT (1D-, 2D-, and/or 3D-QHT) in multiple decomposition levels, to convert the high spatial resolution of the input data to a desired, low spatial resolution. The multi-level QHT is implemented as cascaded packet wavelet decomposition [20]. A set of input patterns are also provided to the system and a pattern matching search is then performed on the low spatial resolution data set using multi-pattern Grover's search algorithm. In Grover's algorithm, a pattern generally means any binary string representing an integer.

Input classical data is encoded on n qubits |q0⟩, |q1⟩, ..., |qn−1⟩, see Fig. 2 (in the appendix available in the online supplemental material), representing the N basis states of a superimposed quantum state, where n=⌈log2N⌉. This can be achieved using classical-to-quantum encoding methods as described in [27]. For example, one of the methods described in [27] is pure state synthesis, i.e., the problem of encoding data in a quantum state reduces to the problem of synthesizing the state. The SynthesizePureState algorithm described in [27] and [28] has a complexity of O(N2), which is similar to the cost of processing an N×N im. Therefore, the classical-to-quantum encoding is a cost worth paying especially if the subsequent quantum algorithms provide substantial speedup compared to the classical equivalents.

The input qubits, assuming the data has been encoded, undergo L decomposition levels, where L=⌊1dlog2NNr⌋, where d=2 for 2D-QHT, d=3 for 3D-QHT, and Nr is a fixed and pre-determined number of states less than N that represents the size of the reduced data. The number of qubits needed to represent the reduced data decreases to nr=⌈log2Nr⌉. It is desired to perform multi-pattern quantum Grover's search (QGS) for a given Np number of patterns/basis states using the nr qubits |q0⟩, |q1⟩, ..., |qnr−1⟩, see Fig. 2 (in the appendix available in the online supplemental material). For the pattern search, m iterations [21] of multi-pattern quantum Grover's search (QGS) is applied. In the next sections, the QHT and QGS circuits that will be used for this methodology are discussed.

3.2 Quantum Circuits for Haar Wavelet Transform
The Haar transformation operation can be decomposed into a core Haar wavelet function, preceded and followed by perfect shuffle permutation operations [18], [20]. We generalize and simplify the main Haar function as quantum operations using n qubits, and a d-dimensional kernel, as shown in (17), where H is the Walsh-Hadamard matrix [16] represented by (5), and I is a 2×2 identity matrix. The corresponding quantum circuit for the function in (17) can be implemented using d H-gates and (n−d) I-gates. For example, the unitary quantum operation for 2D-QHT is given by (18). The corresponding quantum circuit for 2D-QHT is shown in Fig. 3 (in the appendix available in the online supplemental material). Similarly, the unitary operation for three dimensional QHT (3D-QHT) can be derived as (19) and the corresponding quantum circuit is shown in Fig. 4 (in the appendix available in the online supplemental material).
UQHT=I⊗(n−d)⊗H⊗d(17)
View SourceRight-click on figure for MathML and additional features.

where for any matrix A, and integer k,

A⊗k=A⊗A⊗…⊗Ak,

U2DQHT=I⊗(n−2)⊗H⊗2(18)
View SourceRight-click on figure for MathML and additional features.
U3DQHT=I⊗(n−3)⊗H⊗3.(19)
View Source

In Fig. 3 (in the appendix available in the online supplemental material), P2Din and P2Dout are the perfect shuffle permutation unitary operations before and after the 2D Haar operation. Similarly, in Fig. 4 (in the appendix available in the online supplemental material), P3Din and P3Dout are the perfect shuffle permutation unitary operations before and after the 3D Haar operation. These permutations are implemented conventionally in quantum circuits by applying quantum swap in multiple steps [20]. After analysis of the circuit operations, we generalized the number of steps of swap gates required for the permutations as a function of the number of qubits, n, the number of dimensions of the kernel, d, and the number of qubits representing the dth dimension, nd. For input and output permutations, the number of steps, or circuit depth is given by (20) and (21) respectively. The circuit depth for d-dimension Haar operation is always 1 since the circuit is one level of Hadamard gate(s). Therefore, total circuit depth for multi-level, multi-dimensional QHT, taking into account the number of levels of decomposition, L, is given by (22).
nPindepth(1−step)=(n−nd)−(d−1)(20)
View Source
nPoutdepth(1−step)=n−d(21)
View Source
nQHTdepth(1−step)=L(nPindepth(1−step)+1+nPoutdepth(1−step))=L(2(n−d+1)−nd).(22)
View Source

A multi-dimensional QHT can also be implemented in multiple steps. For example, 3D-QHT can be implemented in 2 steps, first applying 2D-QHT and then 1D-QHT. For the 2-step 3D-QHT we express the circuit depths in terms of the number of qubits representing each dimension, n1, n2, and n3 in equations (23), (24), and (25).
nPindepth(2−step)=2n1+n2−3(23)
View Source
nPoutdepth(2−step)=2n1+2n2+n3−5(24)
View Source
n3D−QHTdepth(2−step)=L(nPindepth(2−step)+2+nPoutdepth(2−step))=L(4n1+3n2+n3−6)(25)
View Source

3.3 Quantum Circuits for Grover's Search
3.3.1 Overview
In the unmodified single-pattern and multi-pattern Grover's search the phase inversion circuit is set statically before computations for every search. This is inconvenient for fast and dynamic search. Therefore, we use a modified Grover's algorithm capable of fast and dynamic searches with multiple patterns. Fig. 5 (in the appendix available in the online supplemental material) shows the overview for this process where |ψin⟩ is the output from 2D-QHT or 3D-QHT, P is the list of patterns to be searched for, and S is a series of indexes ranging from |0⟩ to |Np−1⟩.

The process to find the gate depth for Grover's algorithm can be separated into four separate stages as shown in Fig. 5 (in the appendix available in the online supplemental material) and is described in (26) where nQGSdepth is the number of time steps or circuit depth of Grover's algorithm and m is the amount of times Uf and Us are repeated as described in (16).
nQGSdepth=nHdepth+m(nfdepth+nsdepth)+npermutedepth.(26)
View SourceIn the H⊗n stage, the depth is simply 1, given by (27), as one H gate is applied to each qubit. This can be done in one time step as each H operation is independent from each other.
nHdepth=1.(27)
View Source

3.3.2 Circuit For Phase Inversion
The first modification adds a dynamic phase inversion circuit Uf that locates items at the first NP indices of the search list. This is followed by a unmodified inversion about the mean circuit Us that increases the probabilities of locating the pattern(s). The phase inversion and inversion about the mean quantum circuits are repeated for a certain number of iterations m given by (16) to produce an output quantum state. The second modification adds a permutation Upermute of the basis of the quantum state, which is critical for successfully locating the target pattern(s). The permutation circuit uses ancilla bits/qubits, in which the target pattern(s) are encoded, to assign the probability coefficients to the correct basis states.

In the phase inversion stage of Grover's algorithm, oracle circuits [33] are generally implemented using a cZ gate, and multiple X gates. To make the pattern search dynamic, we propose using cX or controlled X-gates, with the index at S acting as the controlling qubits. This modified Uf circuit for single-pattern Grover's search is shown in Fig. 6a (in the appendix available in the online supplemental material), where the input quantum state, formed by qubits q0,q1,…,qn−1, is in equal superposition of its basis states after applying applying an H gate to each qubit as shown by the H⊗n block in Fig. 5 (in the appendix available in the online supplemental material). The X-gates controlled by the search pattern dynamically changes the basis state that the oracle is searching for. The use of cX-gates also allows us to generalize the algorithm for multi-pattern search. Fig. 6b (in the appendix available in the online supplemental material) shows the proposed oracle for dynamic multi-pattern, dynamic Grover's search. To search for Np patterns, Np single-pattern oracle circuits must be cascaded, with each oracle circuit controlled by the corresponding index qubits as described by (28).
Uf=UfNp−1⋅…⋅Ufi⋅…⋅Uf0.(28)
View Source

In the single pattern oracle circuit, Fig. 6a (in the appendix available in the online supplemental material), the cX gates operate independently from each other as each cX gate operates on a qubit pair with no overlap. From this, the depth of the single pattern oracle circuit is 3 with a cX step followed by a cn−1Z step and lastly an additional cX step. The depth for the multi-pattern circuit is simply 3Np as each pattern has its own single pattern circuit as shown in Fig. 6b (in the appendix available in the online supplemental material). The total depth of the Uf is given in (29).
nfdepth=3Np.(29)
View Source

For the next stage, i.e., inversion about mean, the circuit we are using is identical to the traditional Grover's algorithm inversion about mean circuit [33]. Additionally, just like in traditional Grover's algorithm, the phase inversion and inversion about mean circuits are iterated over m times as described in (16). The depth of the inversion about mean is 5 as given in (30). The circuit first applies an H gate to each qubit followed by an X gate again to each qubit, then there is a single cn−1Z gate which is followed again by an X and an H gate applied to each qubit resulting in a total of 5 time steps. This method will amplify the first Np states, so a permutation stage dependent on the pattern being searched for is needed.
nsdepth=5.(30)
View Source

3.3.3 Circuits for Permutation
As the modified design of Grover's algorithm only amplifies the first Np states, a permutation step is added to assign the amplified amplitudes to the target basis states in the output state |ψout⟩. Similar to the oracle implementation, the permutation step consists of cascaded mutually-exclusive single permutation operations as seen in Fig. 7 (in the appendix available in the online supplemental material). The individual permutation step swaps two selected states based on a static index i and a dynamic input pattern Pi, where Pi ∈ P={P0,P1,…,PNp−1}. The quantum circuit for this operation is shown in Fig. 8 (in the appendix available in the online supplemental material). As each individual permutation step only swaps a single state with another state, a total of Np permutation steps are needed to permute each high state with one target basis state as described in (31). It should be noted that the permutation operations for QGS different to those discussed previously for the QHT circuits. Once all Npatterns permutations are performed, the output state |ψout⟩ will have high amplitudes in the desired states while leaving the other states with low amplitudes.
Upermute=UpermuteNp−1⋅…⋅Upermutei⋅…⋅Upermute0.(31)
View Source

The permutation circuit has five sub circuits, see Fig. 8 (in the appendix available in the online supplemental material), in which the detect and toggle circuits have the same depth. The detect and toggle circuits each has a depth of 3 similar to the single pattern oracle circuit as the cX gates operate independently from each other on qubit pairs with no overlap. In the case of the swap circuits, each qubit has a cc′cX and ccc′X gate. These gates are mutually exclusive because if one gate is applied the other gate is guaranteed to not be applied due to the control qubits. However, the cX gates between each qubit are not mutually exclusive as they all depend on using the ancillary qubit. This results in a circuit depth of n. For multi-pattern cases the circuit depth is again multiplied by Np similar to the oracle circuit, see Fig. 7 (in the appendix available in the online supplemental material). Combining everything together gives the following circuit depth for the Upermute stage,
npermutedepth=(9+2n)Np.(32)
View SourceSubstituting in all four of the depth equations into (26) results in the final QGS circuit depth given in (33).
nQGSdepth=1+m(3Np+5)+(9+2n)Np.(33)
View Source

Using the proposed methodology and quantum circuits of QHT and QGS, it is possible to achieve polynomial speedup over classical methods and techniques. The best known classical search algorithm has complexity of O(N) [2], [21], while QGS provides quadratic speedup with complexity of O(N−−√) [2], [21]. Applying dimension reduction using QHT reduces the state space for Grover's search from N to Nr, thereby improving the complexity to O(Nr−−−√), where Nr=N2dL, where d=2 for 2D-QHT, and d=3 for 3D-QHT. Moreover, the use of QHT compared to a classical method such as DWT also improves the complexity from O(N) to O(log2N) because of the data encoding scheme [27].

3.4 Considerations for Practical Quantum Operations
In practical implementation of quantum circuits, decoherence [16] plays an important part and is a critical consideration in the design of quantum computers. Decoherence is the noise in quantum circuits that disrupts the desired evolution of the quantum state. For any quantum circuit, the duration of the longest possible quantum computation is the ratio of the system decoherence time, i.e., the total time the system remains quantum-mechanically coherent, to the time taken for basic two-qubit unitary transformations [16]. Estimates of the total number of operations possible on different technologies of quantum computers such as nuclear spin, ion trap, quantum dot, etc., are given in [16]. For example, an ion trap quantum computer has a decoherence time of around 10−1 seconds and a gate operation time of 10−14 seconds, and can therefore perform up to 1013 operations [16]. From our circuit analysis in previous sections, nQHTdepth and nQGSdepth can be used along with the technology gate operation time to determine the practical implementation of the proposed circuits.

Fidelity of quantum gates is another important practical consideration. In quantum information theory, fidelity is used to measure how close two quantum states are. It is the probability that one state will pass a test and identify as the other [16]. Fidelity threshold of quantum gates is dependent on the underlying quantum technology. For example, superconducting quantum gates have a per-step fidelity threshold of 99% [34]. On the other hand, silicon-based qubit technology have achieved gate fidelities exceeding 99.9% [35]. Quantum gate fidelity is improved using additional error-correcting qubits. For our proposed quantum circuits, a detailed analysis of the gate fidelity is deferred for future investigations.

SECTION 4Hardware Emulation
There are various approaches and techniques [23], [25], [36], [37], [38], [39] investigated for simulating quantum circuits on classical machines. The general methods are the Schrodinger algorithm, Feynman paths algorithm, and Tensor networks [37]. In the Schrodinger algorithm [38], the simulator maintains the full quantum state vector in memory and updates it in every time step as the quantum circuit depth is traversed. In the Feynman paths algorithm [23], a simulator determines an output amplitude of the quantum state by traversing the paths leading from the final state back to the initial state. Tensor networks have also been utilized to simulate quantum circuits [39] by deriving the corresponding tree graph from a quantum circuit. There is also some work on emulation of quantum circuits using hardware [22], [26], [40], [41], [42]. Our approach for hardware emulation is based on the Schrodinger algorithm, and we present two emulation models and the corresponding hardware architectures.

4.1 Kernel-Based Emulation
For emulating quantum algorithms with sparse matrices such as the QHT, we present a kernel-based emulation model. The kernel is extracted from the given algorithm as a repeated set of core operations. The core operations are modeled using classical logic/arithmetic. The input states stored in buffers, are put into groups and the kernel operation is applied iteratively across all groups, one group every cycle, and controlled by input and output schedulers, see Fig. 9 (in the appendix available in the online supplemental material). We propose a simplified algorithm for implementing emulation architectures for multi-level decompositions of 2D-QHT and 3D-QHT, as described in Algorithm 1 and Algorithm 2 respectively. Algorithms 1 and 2 are presented in the appendix available in the online supplemental material.

Algorithm 1 (in the appendix available in the online supplemental material) performs multi-level decompositions of 2D-QHT operations based on a multi-dimensional Haar wavelet kernel. The kernel functionality is described by a set of operations applied to input states/pixels, and is preceded and followed by perfect shuffle permutation operations [18] on the input and output states/pixels. The permutation operations are performed by means of index calculations and scheduling. Algorithm 1 (in the appendix available in the online supplemental material) performs 2D-QHT on a set of input pixels X and produces an output pixel set Y. The first stage in the algorithm is to perform input permutations on the input pixels, followed by 2D Haar kernel operations on 4 neighboring pixels every cycle, and then finally output permutations are performed producing the output set of pixels. The 3D-QHT operation in Algorithm 2 (in the appendix available in the online supplemental material) is very similar, performing a 3D Haar kernel on 8 neighboring pixels every cycle, preceded and followed by input and output permutations on the pixels. We next provide elaborate explanations of the algorithm using the 2D-QHT as an example.
P2Din:⎡⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢x0x1x2x3⋮x(nrows)x(nrows+1)x(nrows+2)x(nrows+3)⋮x(N−1)⎤⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⟼⎡⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢x0x1x(nrows)x(nrows+1)x2x3x(nrows+2)x(nrows+3)⋮⋮x(N−1)⎤⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥.(34)
View Source

The first stage in Algorithm 1 (in the appendix available in the online supplemental material) is the input permutation P2Din, which is described by (34). The permutations can be emulated by gate models of swap gates but that incurs high resource utilization in the corresponding hardware architecture. For this reason, classical models are used that involve simple index scheduling and the corresponding emulation architecture is shown in Fig. 10a (in the appendix available in the online supplemental material). The input is a vector of quantum state coefficients which are written to a memory array in the index order 0 to N−1. Four coefficient values are then read out each clock cycle, with the scheduler generating the read indices iX00,iX01,iX10,andiX11 according to the input permutation, see Algorithm 1 (in the appendix available in the online supplemental material) and (34). The scheduler calculates a row index irow and a column index icol, to determine the output indices. These are used to write the output state into an output buffer. Optimizations such as replacing multiplications and divisions by powers of two with logical shifts are done for more time and resource efficient hardware emulation. A floor operation module is also implemented for the scheduler.

As shown in Fig. 3 (in the appendix available in the online supplemental material) and (18) the 2D Haar transformation, U2DQHT, is modeled using a pair of Hadamard gates. The Hadamard pair operation reduces to kernel operations on a set of four coefficients as described in Algorithm 1 (in the appendix available in the online supplemental material). The emulation architecture for the 2D Haar kernel is shown in Fig. 10b (in the appendix available in the online supplemental material). The design takes in four input coefficients, applies the kernel operations which involve addition and division, and outputs four coefficients per clock cycle. Conventional operator sharing techniques and logical shifts are applied to optimize for speed and area.

The final stage in Algorithm 1 (in the appendix available in the online supplemental material) is the output permutation, P2Dout, described by (35). The corresponding emulation architecture is shown in Fig. 10c (in the appendix available in the online supplemental material) and works similarly to the input permutation scheduler. The input vector of coefficients are written to a memory array, four values per clock cycle, with the scheduler generating the write indices iY00,iY01,iY10,andiY11 according to the output permutation described in Algorithm 1 (in the appendix available in the online supplemental material). The permuted coefficients are then read out from memory 4 values per clock cycle.
P2Dout:⎡⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢y0y(nrows/2)y(N/2)y((nrows/2)+(N/2))⋮y(N−1)⎤⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⟼⎡⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢y0y1y2y3⋮y(N−1)⎤⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥.(35)
View SourceRight-click on figure for MathML and additional features.

In quantum computing, one method of interpreting the quantum circuit output is to employ quantum-to-classical readout techniques [27] such as Quantum Fourier Transform (QFT). However, in this work this was not required to be implemented as only emulation of the quantum computation was performed on classical hardware and the output of the emulator can be extracted classically.

4.2 CMAC-Based Emulation
A quantum algorithm can be described as a series of unitary, reversible transformations on qubits, specifically a quantum state. The series of transformations can be reduced to a single unitary complex-valued matrix, UALG. An input quantum state, |ψin⟩, is represented by a vector comprising of the complex coefficients of the basis states of the quantum state. Applying the transformation matrix UALG to the input vector, we subsequently obtain an output quantum state vector, |ψout⟩, of coefficients which represent the basis states of the output quantum state in superposition. The circuit function of a given quantum algorithm is therefore reduced to a singular vector-matrix multiplication operation with a complexity of O(N2). We use this approach, illustrated in Fig. 11 (in the appendix available in the online supplemental material), as the emulation model for hardware implementation of multi-pattern QGS. In this emulation model, complex-valued vector-matrix multiplications are performed on complex multiply-and-accumulate (CMAC) units.

For emulation of dense quantum circuits such as Grover's on FPGAs, our objectives were to derive space-efficient hardware architectures. To ensure high emulation accuracy, single-precision floating-point arithmetic was used to model the quantum circuit operations. The complex coefficients describing qubits and unitary circuit operations are represented using 64 bits, with 32 bits for each of the real and imaginary components. For achieving high throughput, the design architecture is fully pipelined. The architecture of the emulator is shown in Fig. 11 (in the appendix available in the online supplemental material). The emulator determines the output quantum state |ψout⟩ given an input quantum state, |ψin⟩ and the unitary operation of the quantum algorithm, UALG. The emulation methodology leverages multiply-and-accumulate techniques to perform complex vector-matrix multiplications efficiently on hardware. This design methodology makes the emulator generic so that it can emulate any quantum algorithm, given its unitary transformation matrix, UALG. The number of CMAC instances that the emulator architecture uses can be varied from 1 to N, as a trade-off between circuit area and speed. The advantage of using CMAC units is that, a single CMAC will always have the same number of arithmetic units, irrespective of the number of operations in the gate/algorithm being modeled. Using a single CMAC architecture ensures a space-efficient design at a space complexity of O(1) irrespective of the circuit size. This architecture is also highly scalable as it stores only the quantum state vectors in memory and dynamically streams the algorithm matrix, UALG during computation. This technique allows a significantly higher number of qubits to be emulated.

We design a simple CMAC unit for the quantum algorithm emulator, shown in Fig. 12 (in the appendix available in the online supplemental material). The inputs of the unit are complex values, i.e., elements of the input state vector, |ψin(j)⟩, and of the algorithm matrix, U(i,j). To operate on complex values, the internal components of the CMAC, such as the multiplier and adder, have been designed for complex operations. The CMAC operations are shown in Fig. 12 (in the appendix available in the online supplemental material) and summarized in (36). One CMAC unit performs in total, four multiplications and four additions. CMAC-based architectures can be optimized by exploring different configurations. The CMAC unit operation can be optimized for speed, by using a lookup array to pre-store values of the algorithm matrix and thus reduce any computation overheads [22]. Another method is to optimize for area by dynamically generating the algorithm matrix values at runtime [22].
ψrealout(i)ψimagout(i)=∑j=0N−1Rreal(i,j)=∑j=0N−1Rimag(i,j)(36)
View Source

SECTION 5Experimental Results and Analysis
The proposed emulator architectures were implemented on DirectStream (DS8) [43], a state-of-the-art high performance reconfigurable computing (HPRC) system. The hardware designs were developed in a high-level synthesis flow using C++ on DS8. For functional verification of the design, reference models were developed in MATLAB. Simulations and hardware implementations were performed using Quartus Prime version 17.0.2 on an Arria 10 10AX115N4F45E3SG FPGA. The FPGA has a maximum operating frequency of 233 MHz. The on-chip resources on the FPGA consist of 427,200 Adaptive Logic Modules (ALMs), 2,713 Block RAMs (BRAMs), and 1,518 Digital Signal Processing (DSP) blocks, while the on-board memory (OBM) consists of 4×8 MB SRAM modules and 2×32 GB SDRAM modules. We implemented the emulation architectures for the proposed system, see Fig. 2 (in the appendix available in the online supplemental material), using the kernel-based emulator for multi-dimensional QHT emulation and the CMAC-based emulator for performing multi-pattern QGS. 32-bit floating-point precision was used to represent the real and imaginary components of the complex state coefficients for both emulators, and the architectures were fully pipelined for highest throughput. High resolution single-band and multi-spectral images were used as test data sets for the experiments. We have obtained implementation results emulating up to 32 qubits on a single FPGA node, with an operating frequency of 233 MHz.

The experimental results for the single-band images are presented in Table 1. In this experiment, multi-level 2D-QHT dimension reduction and pattern search using QGS was performed on single-band grayscale images of up to 64K×64K pixel size and using up to 32 emulated qubits, see Table 1. Fig. 13a (in the appendix available in the online supplemental material) shows an example single-band grayscale image, Fig. 13b (in the appendix available in the online supplemental material) shows the reduced image after 1 level of 2D-QHT decomposition, Fig. 13c (in the appendix available in the online supplemental material) shows the reduced image after 2 levels of 2D-QHT decomposition, and Fig. 13d (in the appendix available in the online supplemental material) shows the reduced image with pattern indices identifying a person in it with the help of QGS. A 10-qubit QGS circuit was emulated to perform pattern search on the reduced image data and output the pattern indices.

TABLE 1 2D-QHT and QGS Implementation Results Using Single-Spectral Images on Arria 10AX115N4F45E3SG FPGA

The FPGA resource utilization data shown in Table 1 refers to both the QHT and QGS circuit utilizations. The number of decomposition levels for 2D-QHT is increased as the input image size increases. This is done to keep the size of the reduced image to a fixed resolution, and therefore the QGS circuit can perform pattern search using a fixed number of qubits. The on-chip resources (ALMs, BRAMs, DSPs) are used for implementing the static components of the design such as counters, adders, shift operators, etc. and hence are constant as the emulated circuit size (number of qubits) increases. The low on-chip resource utilizations indicate that our proposed emulation architecture designs are highly space-efficient and highly scalable. The on-board memory is used to store the coefficients of the input and output quantum states and therefore the memory utilization increases exponentially with the number of qubits, making the emulation highly memory bound. The highest resolution image of size 64K×64K occupies a full 32 GB SDRAM bank. The image pixels are encoded as the quantum state coefficients which have 32-bit real and imaginary components and occupy 8 bytes each. A 64K×64K image contains 232 pixels and so the total memory required to encode it is 232×8 bytes, or 32 GB. The two 32 GB SDRAM banks on the FPGA node are utilized to store the input and output images respectively.

The system emulation time obtained in Table 1 is a function of the emulation times for QHT and QGS. In our previous investigation of QHT and kernel-based emulation [22], our findings show that execution time of the kernel-based emulator increases linearly with the data size, i.e., number of states. As emulation times for QGS is the same due to a fixed circuit size, the overall system emulation time increases linearly with the number of states, N, as illustrated in Fig. 14 (in the appendix available in the online supplemental material). Compared to our preliminary investigation [44] where the CMAC-based emulation model was employed for dimension reduction, this work improves results in terms of system emulation time as a result of integrating the kernel-based emulator for dimension reduction. The system emulation time complexity is improved to O(N), where N is the data size in number of pixels, compared to O(N2) in [44].

We carried out more experiments to test the proposed methodology using multi-spectral radiance images, collected in a previous study [45]. These images were obtained in summer of 2003 from rural and urban scenes in Minho, Portugal using embedded neutral probe spheres. On each sphere, the spectra of the local illumination at 17 sample points were extracted in each scene and a total of 1904 chromaticity coordinates and correlated color temperatures (CCTs) derived [45]. During acquisition of these images, a wavelength range of 400-720 nm was sampled at 10 nm intervals. Each image cube has an effective resolution of 1344×1024×33 (1344×1024 pixels of spatial resolution ×33 bands of spectral resolution). An example image sampled at three different frequency bands is shown in Figs. 15a to 15c (in the appendix available in the online supplemental material), and an RGB color representation generated from the multi-spectral image data is shown in Fig. 15d (in the appendix available in the online supplemental material).

The experiments for computing the 3D-QHT was carried out in two steps, i.e., 2D-QHT for each spectral band and 1D-QHT across bands. The multi-spectral images were sampled at each frequency band and 2D-QHT was performed on the grayscale image at each band to reduce spatial dimensions. 1D-QHT was performed across the bands to reduce the spectral dimension. The resulting reduced image cube contains the spatially located low frequency components within each band, as well as the lower frequency bands grouped together. Image slices at different bands from the reduced image cube are shown in Figs. 16a-16d (in the appendix available in the online supplemental material). QGS was performed on the reduced images slices, to locate randomly chosen target patterns. The data obtained for the multi-spectral image experiments is shown in Table 2. A maximum of 27 qubits was required for dimension reduction of the multi-spectral image data set by applying 2D-QHT across the 2D grayscale image, and 1D-QHT across the bands. After dimension reduction, a multi-pattern search was performed using QGS. The number of decomposition levels was varied from 2 to 9 for the different images in the set. This helped decrease the size of the reduced image cube, and the number of qubits required for QGS also decreased. For example, as seen in Table 2, for 2 levels of 3D-QHT decomposition, the corresponding QGS operation required 16 qubits, while for 9 levels of decomposition, the size of the corresponding QGS circuit decreased to 2. Table 2 also shows the variation in total circuit depth, i.e., the number of gate levels to be performed, as calculated from equations (22), (25), and (33). The circuit depth reflects the total number of execution time steps for the combination of the 2D-QHT, 1D-QHT, and QGS circuits. Finally, the resource utilizations are given in Table 2 for the emulator architectures of 2D-QHT, 1D-QHT and QGS.

TABLE 2 3D-QHT (2-Step) and QGS Implementation Results Using Multi-Spectral Images on Arria 10AX115N4F45E3SG FPGA
Table 2- 
3D-QHT (2-Step) and QGS Implementation Results Using Multi-Spectral Images on Arria 10AX115N4F45E3SG FPGA
In another experiment, 3D-QHT was performed on the multi-spectral data set in one step, using a 2×2×2 Haar kernel, see Algorithm 2 (in the appendix available in the online supplemental material), and followed by QGS for pattern searching. The corresponding experimental data is presented in Table 3. A 27-qubit 3D-QHT circuit was required for dimension reduction of the 3D images. The number of decomposition levels was varied from 2 to 9, similar to the previous experiment, and thus the number of qubits required for QGS varied in the same range as before. The variation of total circuit depth for the 3D-QHT and QGS circuits is also shown in Table 3. The resource utilization refers to the kernel-based emulator performing 3D-QHT and the CMAC-based emulator performing QGS on the same multi-spectral data set. The system emulation times for the 3D-QHT (2-step and 1-step) and QGS implementations are similar, with only difference being a negligible initial latency. The emulation times as a function of the number of decomposition levels is shown in Fig. 17 (in the appendix available in the online supplemental material).

TABLE 3 3D-QHT (1-step) and QGS implementation Results Using Multi-Spectral Images on Arria 10AX115N4F45E3SG FPGA
Table 3- 
3D-QHT (1-step) and QGS implementation Results Using Multi-Spectral Images on Arria 10AX115N4F45E3SG FPGA
SECTION 6Conclusion and Future Work
In this work, we have presented a novel methodology for time-efficient pattern recognition in high resolution data, employing quantum algorithms such as quantum wavelet transform for reducing data dimensionality while preserving its spatial locality, and quantum Grover's algorithm for efficient and dynamic multi-pattern search. For experimental evaluation, we developed FPGA-based emulation architectures on a high-performance reconfigurable computer, to emulate the quantum circuits of the proposed system. The experimental results show that the proposed methodology and system is feasible for use in future quantum systems. Future extensions of this work will involve experimental evaluations of the system using test data from domains such as High Energy Physics and remote sensing hyperspectral imagery with thousands of spectral bands.