Abstract‚ÄîNear-term quantum computing (QC) systems have
limited qubit counts, high gate (instruction) error rates, and
typically support a minimal instruction set having one type
of two-qubit gate (2Q). To reduce program instruction counts
and improve application expressivity, vendors have proposed,
and shown proof-of-concept demonstrations of richer instruction
sets such as XY gates (Rigetti) and fSim gates (Google). These
instruction sets comprise of families of 2Q gate types parameterized by continuous qubit rotation angles. That is, it allows
a large set of different physical operations to be realized on
the qubits, based on the input angles. However, having such a
large number of gate types is problematic because each gate
type has to be calibrated periodically, across the full system, to
obtain high fidelity implementations. This results in substantial
recurring calibration overheads even on current systems which
use only a few gate types. Our work aims to navigate this tradeoff
between application expressivity and calibration overhead, and
identify what instructions vendors should implement to get the
best expressivity with acceptable calibration time.
Studying this tradeoff is challenging because of the diversity in
QC application requirements, the need to optimize applications
for widely different hardware gate types and noise variations
across gate types. Therefore, our work develops NuOp, a flexible
compilation pass based on numerical optimization, to efficiently
decompose application operations into arbitrary hardware gate
types. Using NuOp and four important quantum applications,
we study the instruction set proposals of Rigetti and Google,
with realistic noise simulations and a calibration model. Our
experiments show that implementing 4-8 types of 2Q gates
is sufficient to attain nearly the same expressivity as a full
continuous gate family, while reducing the calibration overhead
by two orders of magnitude. With several vendors proposing rich
gate families as means to higher fidelity, our work has potential
to provide valuable instruction set design guidance for near-term
QC systems.
Index Terms‚Äîinstruction set architecture, compilation, quantum computing
I. INTRODUCTION
Quantum computing (QC) is an emerging paradigm that
uses quantum mechanical principles to manipulate information. QC systems store information using qubits (quantum bits)
and manipulate information using gates (operations). These
operations allow the system to exploit quantum effects such as
superposition, entanglement and interference to explore large
state spaces efficiently, sometimes faster than classical (nonquantum) systems. In the near-future, QC is poised to drive
research in domains such as machine learning [5], quantum
*Lingling Lao and Prakash Murali are joint first authors. Corresponding
author: pmurali@cs.princeton.edu
chemistry [6] and material science [7]. Several prototype QC
systems have been built using hardware technologies such
as superconducting and trapped-ion qubits. These systems
are referred to as Noisy Intermediate-Scale Quantum (NISQ)
systems [8] and have small qubit counts, restricted connectivity and high gate error rates. Although resource-constrained,
NISQ systems are useful for demonstrating near-term applications [9] and milestones such as quantum supremacy [2].
Typically, NISQ systems support a universal gate set composed of continuous single-qubit (1Q) rotations and a few
two-qubit (2Q) gate types that can express any application
operation. Among them, 2Q gates generate entanglement between pairs of qubits and constitute a key building block for
quantum algorithms. However, 2Q gates are more challenging
to implement than 1Q gates and have higher error rates. For
example, on IBM systems, 2Q gate error rates are 1-5%
and 1Q gate error rates are less than 0.1%. Since a single
entangling 2Q gate is sufficient for universality, most vendors
use instruction sets having only one 2Q gate type. For example,
in Rigetti‚Äôs and Google‚Äôs early QC systems, Controlled Z (CZ)
gate was the only supported 2Q gate type [10]‚Äì[12].
The type and error rate of the hardware 2Q gate determines
application expressivity, that is, the number of instructions
required to implement an application and the overall execution
fidelity. When a system has a single 2Q gate type, the
compiler is forced to express all application operations using
it, worsening executable instruction counts and duration. Importantly, the error rate of the available 2Q gate constrains the
number of program instructions that can be reliably executed.
Although vendors have been improving gate implementations,
progress has been slow because of challenges in accurate qubit
control, qubit defects from lithographic manufacturing and
emergent sources of noise. Therefore, if an application cannot
be expressed concisely, it is unlikely to execute successfully
on near-term hardware.
To improve expressivity, and thereby improve execution
success rate, industry and academic vendors [3], [4], [13]
have proposed instruction sets which have continuous 2Q gate
families. Table I shows the proposed XY gate family from
Rigetti and the fSim gate family from Google. Each gate
family is parameterized by rotation angles (e.g., Œ∏ and œÜ for
Google‚Äôs fSim gates) and forms a continuous set of two-qubit
gate types (different unitaries). This means, in theory, there
are an infinite number of hardware 2Q gate types that can be
used to express applications succinctly. In practice, however,

"$.*&&&UI"OOVBM*OUFSOBUJPOBM4ZNQPTJVNPO$PNQVUFS"SDIJUFDUVSF	*4$"

¬•*&&&
%0**4$"
2021 ACM/IEEE 48th Annual International Symposium on Computer Architecture (ISCA) | 978-1-6654-3333-4/21/$31.00 ¬©2021 IEEE | DOI: 10.1109/ISCA52012.2021.00071
Rigetti Google
Current Anticipated Current Anticipated
CZ =
‚éõ
‚éú‚éú‚éú‚éù
100 0
010 0
001 0
000 ‚àí1
‚éû
‚éü‚éü‚éü‚é†
XY(œÄ)
XY(Œ∏) =
‚éõ
‚éú‚éú‚éú‚éù
10 00
0 cos(Œ∏/2) isin(Œ∏/2) 0
0 isin(Œ∏/2) cos(Œ∏/2) 0
00 01
‚éû
‚éü‚éü‚éü‚é†
CZ
SYC = fSim(œÄ/2, œÄ/6)
‚àöiSWAP = fSim(œÄ/4, 0) fSim(Œ∏, œÜ) =
‚éõ
‚éú‚éú‚éú‚éù
10 0 0
0 cos(Œ∏) ‚àíisin(Œ∏) 0
0 ‚àíisin(Œ∏) cos(Œ∏) 0
00 0 e‚àíiœÜ
‚éû
‚éü‚éü‚éü‚é†.
Fidelity ‚àº95% 95-99% ‚àº99.6% ‚àº99.6%
TABLE I: Current and anticipated two-qubit gate types in Rigetti and Google systems. Each two-qubit gate type corresponds
to a 4x4 unitary matrix. Current gate sets are based on Rigetti‚Äôs Aspen-8 [1] and Google‚Äôs Sycamore [2] devices. Anticipated
gate sets are based on [3] and [4]. Controlled Z (CZ) is an example of a fixed gate type. In contrast, fSim(Œ∏, œÜ) is parameterized
by Œ∏, œÜ. Varying these parameters allows a broad range of gate types to be realized in hardware. XY(Œ∏) is a subset of fSim
gate family up to single-qubit rotations. (The actual instruction sets also include single-qubit operations for universality, they
are not shown here.)
quantum gates are implemented using analog pulse sequences
which must be calibrated to obtain high fidelity. Calibration
routines require a large number of test executions to tune
control parameters and characterize the hardware operations.
Worse, calibration is not a one-time step (parameters drift over
time) and must be performed periodically to maintain high
fidelity. Even with a single type of 2Q gate, Google‚Äôs 54-
qubit device requires up to four hours of calibration per day
[2]. Therefore, across the full parameter space of a continuous
gate set, calibration overheads are likely enormous, especially
as devices scale up.
Our work studies the tradeoff between application expressivity and calibration overhead to determine what gate sets
and gate parameter combinations vendors should implement to
offer high-fidelity executions without tremendous calibration
time. To accurately compare instruction set options, we require
a toolflow to automatically decompose and optimize applications for different candidate gate sets. This is challenging
because of the variety of gate options, variations in fidelity
across gate parameter values, and the need to use different
optimization strategies based on the hardware characteristics.
Figure 1 shows our simulation framework. Our work addresses the toolflow challenge by building NuOp, a flexible
compilation pass based on numerical optimization techniques.
NuOp accepts as input a set of target hardware gate types and
uses noise-adaptive compilation across gate parameter values
and approximate gate decomposition to heavily optimize applications, enabling accurate comparisons across gate choices.
Using NuOp, we perform a simulation-driven study to identify
the best instruction design choices across two vendor gate
families and several NISQ applications.
Our contributions include:
‚Ä¢ Current QC instruction sets belong to one of two camps:
minimal sets having a single two-qubit gate type [14]
(poor expressivity, easy to calibrate) or families of continuous gate sets [3], [4], [13] (rich expressivity, hard
to calibrate). These two choices and their calibration
tradeoffs are reminiscent of the tradeoffs in classical
RISC vs. CISC ISA choices. Our work is the first to
study the expressivity vs. calibration tradeoff in QC, and

$
$
	 

#



"

%








 
!






	


	
 



Fig. 1: Simulation framework. To study different instruction set
choices, our work performs an application-driven simulation
study with realistic device and calibration models.
design an instruction set that has rich expressivity and is
easy to calibrate.
‚Ä¢ To design this instruction set, we use NuOp to characterize instruction counts for four representative QC applications across the continuous parameter space for XY
and fSim gate families. Across the parameter space, one
to six hardware 2Q gates are required to implement an
application 2Q operation. Based on this characterization,
we identify a small subset (4-8 discrete combinations) of
these gate families that offers near-optimal expressivity
i.e., instruction counts and fidelity that are better than
instruction sets with a single gate type and close to
the optimal values that can be obtained using the entire
continuous parameter space of XY and fSim families.
‚Ä¢ Using a realistic calibration model for fSim gates, we
show that the proposed gate sets having 4-8 gate types,
save two orders of magnitude calibration overhead, compared to using the entire parameter space. Since calibration is not a one-time overhead, this large reduction
makes our instruction set practically viable for realsystem implementations.
‚Ä¢ Finally, QC systems are known to have highly variable error rates across qubits and time [15]‚Äì[18]. We
demonstrate that exposing multiple 2Q gate types is a
viable method to mitigate such noise variations. When
        
a noise-adaptive compiler pass such as NuOp is used in
conjunction with multiple gate types, the compiler can
choose different gate types on different qubits to obtain
significant improvements in fidelity.
Our work makes the case for an instruction set having a
small number of expressive two-qubit gate types. With major
QC vendors aiming to offer more instruction types in the nearterm [4], [13], we expect our work to significantly impact
industry and academic instruction sets and provide useful
guidance to hardware designers.
II. BACKGROUND ON QUANTUM GATES
Gate family vs. type: Quantum algorithms encode information using a set of qubits and manipulate information by
applying different quantum gates (instructions). Each n-qubit
quantum gate can be uniquely defined by a unitary matrix
U2n√ó2n . The unitary matrix of a gate may be a fixed unitary
or a parameterized unitary. An example of a fixed unitary
gate is the CZ gate shown in Table I. In contrast, fSim(Œ∏, œÜ)
is parameterized by Œ∏ and œÜ. For such gates, we use the term
gate family since it allows an infinite number of unitaries to
be realized based on the parameter values. We use the term
gate type to refer to fixed parameter values in this family e.g.,
fSim(œÄ, œÄ/2) and fSim(œÄ/6, œÄ/8) and CZ = fSim(0, œÄ) are
three distinct gate types.
Gate Implementation in NISQ systems: Gate implementation depends on the qubit hardware technology and gate
type. For example, in Google‚Äôs Sycamore system (transmon
qubits), single-qubit gates are implemented using microwave
pulses that are resonant with the qubit frequency; two-qubit
gates (SYC and ‚àö
iSWAP) are implemented by bringing
neighboring qubits in resonance through a tunable coupler that
mediates the interaction [2]. Gate implementations in all NISQ
systems are error-prone. The quality of a gate implementation
is characterized by its fidelity (1‚àíerror rate). Table I shows
average gate fidelities for Rigetti and Google systems.
III. RELATED WORK
Most prior works [19]‚Äì[24] consider instruction set design
issues assuming that systems have only one two-qubit gate
type. For example, Rigetti Quil [19] and IBM OpenQASM
[20] target only the CZ and CNOT gates, respectively. Murali
et al. [16] compare native and software-visible instruction
sets and recommend exposing all available gate types to the
compiler to improve application fidelity. In contrast to these
minimal instruction sets, we focus on instruction sets with
multiple gate types to improve application expressivity.
Google‚Äôs Sycamore device has preliminary support for a
continuous fSim gate [4]. Rigetti‚Äôs XY gates were demonstrated in [3]. Lacroix et al. [13] experimentally demonstrated
that using continuous Controlled-Phase gates (CZ(Œ∏)) is beneficial for quantum optimization (QAOA). I These works represent one extreme of the design space, i.e., the full parameter
space is available to programs, which optimizes for application
expressivity but requires demanding calibration schemes. Our
work uses realistic gate errors and calibration models from
Google and Rigetti devices to study what subset of the gate
parameter space should be exposed to obtain high application
reliability with low calibration overhead.
Our work requires an automated method to decompose and
optimize applications for arbitrary vendor gate sets. Several
works have investigated compilation and program optimization
techniques for QC devices. Early works focused on minimizing metrics such as gate count and circuit depth [25]‚Äì[29].
Recently noise-adaptive compilation passes [15], [17], [18],
[30] have been developed to adapt program executions to
spatio-temporal fidelity variations in real systems. However,
these works and compilers such as IBM Qiskit [31] and TriQ
[16] assume that the hardware instruction set has a single type
of two-qubit gate. Hence, they are not directly applicable for
studying instruction set design issues for multiple two-qubit
gate types.
IV. INSTRUCTION SET DESIGN CHOICES AND TRADEOFFS
A. Background on ISAs with Continuous Two-Qubit Gates
Rigetti has proposed using XY(Œ∏) gates along with the
Controlled-Z gate (CZ) as the instruction set in their future
systems. An early demonstration of this gate set on a two-qubit
system in [3] shows executions of broad range of gate types
with fidelities ranging from 95% to 99%. Rigetti‚Äôs current
system (Aspen-8), a 30-qubit device, includes one gate type
from this family, the XY(œÄ) gate, in addition to the CZ gate.
Similarly, Google has proposed a continuous fSim(Œ∏, œÜ)
gate family for their devices. This gate family can be viewed as
a composite of two families i.e., the CPHASE family, CZ(œÜ),
obtained by varying œÜ, fixing Œ∏ = 0, and the iSWAP-like
family, iSWAP(Œ∏), obtained by varying Œ∏, fixing œÜ = 0. In [4],
Google demonstrated 525 instances of the fSim family with
different Œ∏ and œÜ, on two qubits. Recent experiments from
their 54-qubit Sycamore processor use two gate types from
this family: SYC gate = fSim(œÄ/2, œÄ/6) [2] and ‚àö
iSWAP
gate = fSim(œÄ/4, 0) [34], with fidelities as high as 99.4%
In both Rigetti and Google instruction sets, multiple types of
single-qubit gates (qubit rotations) are included for obtaining
a universal gate set. However, these gates typically have one
order of magnitude higher fidelity than two-qubit gates and
have been optimized heavily using both hardware [35] and
software techniques [31]. Hence, our focus is on designing
efficient two-qubit instruction sets.
B. Application-level Benefits of Multiple Gate Types
Different gate types are advantageous to different QC applications. For example, the CZ gates are useful in quantum error
correction. Excitation-preserving operations like the ones in
XY and fSim families allow natural representations for quantum chemistry [6], [36] and combinatorial optimization [37].
Therefore, by offering more than one gate type, vendors aim to
cater to the different application operation needs, and reduce
the number of instructions required to express them.
Figure 2 shows decompositions of two application unitaries
using two types of hardware gates. When only one of these
gate types is available, the compiler has to decompose all

q0
q1
SU(4) =
‚éõ
‚éú‚éú‚éù
0.319 + 0.395i ‚àí0.379 + 0.039i ‚àí0.098 + 0.241i ‚àí0.058 ‚àí 0.724i
‚àí0.357 + 0.610i 0.350 + 0.177i 0.332 + 0.437i ‚àí0.172 + 0.116i
‚àí0.469 + 0.026i ‚àí0.474 ‚àí 0.205i 0.483 ‚àí 0.408i ‚àí0.305 ‚àí 0.132i
‚àí0.131 ‚àí 0.058i 0.617 + 0.228i 0.022 ‚àí 0.477i 0.004 ‚àí 0.563i
‚éû
‚éü‚éü‚é†
(a) Two-qubit QV unitary
q0
q1 e‚àí0.0303iZZ =
‚éõ
‚éú‚éú‚éù
10 00
0 0.995 + 0.095i 0 0
000.995 + 0.095i 0
00 01
‚éû
‚éü‚éü‚é†
(b) Two-qubit QAOA unitary
q0
q1
U3(3.89, 1.83, 4.12)
U3(3.73, 2.65, 5.57) CZ U3(1.35, 5.19, 2.46)
U3(1.25, 4.33, 3.93) CZ U3(2.26, 4.58, 0.93)
U3(4.98, 1.99, 0.75) CZ U3(1.22, 4.94, 2.74)
U3(3.26, 7.08, 2.37)
(c) Decomposition: QV unitary with CZ
q0
q1
U3(4.71, ‚àí0.11, 5.76)
U3(6.28, 5.09, 0.48) CZ U3(6.37, 1.78, 4.83)
U3(0, 5.39, 5.95) CZ U3(7.85, 0.51, 6.07)
U3(6.28, 4.09, 4.09)
(d) Decomposition: QAOA unitary with CZ
q0
q1
U3(6.79, 5.82, 3.79)
U3(4.44, 5.02, 2.86)
‚àö
iSWAP U3(1.97, 3.77, 5.26)
U3(1.45, 4.94, 6.05)
‚àö
iSWAP U3(2.91, 6.93, 7.24)
U3(2.76, 5.87, 1.54)
(e) Decomposition: QV unitary with ‚àöiSWAP
q0
q1
U3(2.83, 4.22, 4.16)
U3(4.98, 1.59, ‚àí0.05)
‚àö
iSWAP U3(2.10, 5.74, 0.51)
U3(8.31, 6.24, 3.24)
‚àö
iSWAP U3(2.04, 1.08, 4.75)
U3(2.03, 0.58, 1.97)
‚àö
iSWAP U3(1.79, 4.92, 1.09)
U3(0.58, 1.27, 2.22)
(f) Decomposition: QAOA unitary with ‚àöiSWAP
Fig. 2: Decomposition examples using NuOp. (a) shows a two-qubit gate with unitary from the SU(4) group (Quantum volume
circuits randomly sample gates from this group [32]). (b) shows a two-qubit Pauli interaction (e‚àíiŒ≤(Z‚äóZ)
), which is used in
QAOA circuits. (c-f) show exact implementation (decomposition error ‚âà 10‚àí8) of these unitaries using different two-qubit
hardware gates from Rigetti (CZ) and Google (‚àö
‚àö
iSWAP). The CZ gate is more expressive for QAOA unitaries and the
iSWAP gate is more expressive for QV unitaries. In (c-f), U3 gates are arbitrary single-qubit rotation operations1.



 


	 	



 


	


  	
Fig. 3: Layout of first 8 qubits in Rigetti Aspen-8 system.
Nodes are qubits and edges are two-qubit gates labeled by the
measured fidelity for XY(œÄ) and CZ gates [33]. The best gate
varies across qubit-pairs.
application unitaries using it, potentially increasing the number
of instructions. Since NISQ systems have high two-qubit
gate error rates, an increase in instruction count translates
to a significant reduction in fidelity. Continuous gate families
proposed by Rigetti and Google leverage this concept to an
extreme. That is, they aim to offer a very large number
of two-qubit gate types to applications using one or more
controllable gate parameters. For Rigetti‚Äôs XY family, Peterson
et al. [38] theoretically proves that offering applications access
to the full continuous parameter space, can give ‚àº 30% twoqubit instruction count reduction for generic quantum circuits.
Similarly, Foxen et al. [4] demonstrates that a continuous set
of fSim gates can provide a 3X gate reduction compared to
decomposition with one gate type. .
C. Experimental Difficulties of Multiple Gate Types
Calibration overhead: Implementing multiple two-qubit basis
gates in the same device with high fidelity is experimentally
1An arbitrary single-qubit gate can be described by a unitary matrix with
three parameters
U3(Œ±, Œ≤, Œª) = 
cos	 Œ±
2

 ‚àíeiŒª sin	 Œ±
2


eiŒ≤ sin	 Œ±
2

 ei(Œ≤+Œª) cos	 Œ±
2



.
difficult and requires demanding calibration strategies. First,
each two-qubit gate on each qubit pair needs to be calibrated independently to find its optimal control parameters,
and electronics need to be carefully calibrated to avoid any
bleeding between control pulses of different gates. These are
known challenges for continuous gate sets [4]. Second, on realsystems, calibration of different combinations of single-qubit
and multi-qubit gates, and parallel operations are also required
to obtain high fidelity [39]. Calibration complexity increases
at least linearly with the number of two-qubit basis gates and
becomes enormous for a continuous gate set. Since calibration
parameters drift over time (causing gate error rate fluctuations
of up to 10X [4]), frequent re-calibration is also required in
practice. In Section IX, we model fSim gate calibration.
Fidelity variations across gate types: Continuous gate families also have variable fidelities across the parameter space,
qubits in the system and time (similar to variability seen in
systems with one type of two-qubit gate [16], [17]). Figure 3
shows that the best gate type varies across qubits in Rigetti‚Äôs
Aspen-8 system. For XY gates, gate error rates vary up to 4X
depending on the angle Œ∏ (see Figure 6 in [3]). For fSim gates,
the error rates vary up to 5X based on Œ∏ and œÜ (see Figure
4 in [4]). If applications use a single gate type across the
system, it may result in severe fidelity losses. Instead, by using
multiple gate types with noise-aware compilation, applications
can benefit from the best gates on each part of the device.
D. Our Work
Our work studies key instruction design questions considering application-level benefits, calibration overheads and
noise variability. Is it possible to design an instruction set
having a small set of discrete gate types, but achieving the
expressivity and fidelity of a continuous gate family? What are
the calibration overheads of such an instruction set compared
to a continuous gate family? Is it beneficial to expose multiple
gate types and use noise adaptivity across gate types to
mitigate noise variations?
                       
Table II shows the gate set options considered: instruction
sets with a single type of two-qubit gate (S1-S7), our proposed
instruction sets for Rigetti (R1-R5) and Google (G1-G7) and
fully continuous FullXY and FullfSim gate families. To study
these options, we use the framework shown in Figure 1.
V. TOOLFLOW FOR ARCHITECTURAL EXPLORATION
QC applications are typically written in terms of high-level
device and gate set-independent operations. During compilation, program qubits are mapped onto the target device,
communication operations such as SWAPs are inserted to
comply with limited connectivity, and operations are translated
or decomposed into the target instruction set. Figure 2 shows
gate decomposition examples. Gate decomposition methods
aim to represent the unitary of a desired application operation
within a tolerable inaccuracy, using a circuit with short depth
(to minimize decoherence), and small number of two-qubit
gates (to minimize gate errors).
To probe instruction set design issues across different gate
types and their combinations we require a flexible decomposition method that can support any application operation
and hardware gate type. Current industry compilers focus on
gate decomposition routines for specific gate types of interest
to a particular hardware platform. These compilers typically
use linear algebra-based methods such as KAK decomposition [40]‚Äì[45] or hard coded gate identities [46]. These
methods are difficult to extend to continuous gate sets and
arbitrary parameter combinations within these gate families.
For example, IBM‚Äôs Qiskit compiler includes routines for
decomposing arbitrary two-qubit unitaries to CNOT gates.
Rigetti‚Äôs Quilc [47] includes support for CZ and XY(œÄ) gates,
but does not target arbitrary gate types and hence, was not
suitable for our study. Google‚Äôs Cirq can support a variety of
application unitaries and hardware gate types. However, Cirq
only provides optimized decompositions for limited gate types
such as SYC and CZ gates.
A. Numerical Optimization for Gate Decomposition
Our work develops NuOp, a numerical optimization technique to efficiently decompose any application unitary into any
hardware gate. NuOp is based on recent prior work [48]‚Äì[50].
We describe the method for a two-qubit application unitary and
then discuss how to apply it for a program circuit. NuOp takes
an application unitary and a target hardware gate type as
input and produces an optimized decomposition as output.
At a high-level, NuOp constructs a series of parameterized
template circuits and optimizes each template to achieve the
desired unitary. Among the optimized templates, it selects
the one which satisfies an input error threshold as the final
decomposition.
Figure 4 shows an example template with i layers. Each
template circuit has alternating layers of arbitrary single qubit
gates and the target hardware two-qubit gate type (similar
templates are used in the ADAPT-VQE algorithm [51]).
For example, to decompose an application operation into a
fSim(œÄ/6, œÄ/2) hardware gate, the template has layers of
fSim(œÄ/6, œÄ/2) gates sandwiched between arbitary singlequbit operations. For a given template, the optimization variables are the rotation angles for the single qubit operations. By
optimizing these angles and computing the accuracy w.r.t the
desired unitary, NuOp obtains a highly accurate representation
of the application operation. To compute accuracy, NuOp uses
decomposition fidelity Fd, i.e., the accuracy of the unitary decomposition (without device/hardware noise), measured using
the Hilbert-Schmidt inner product,
Fd = Ud, UtHS
dim(Ut) = Tr(U‚Ä†
dUt)
dim(Ut) . (1)
Here, Ut is the matrix of the application unitary and Ud is
the matrix represented by the template. Each choice of singlequbit angles in the template gives rise to a different Ud. When
Ud is far away from the desired unitary, Fd is close to 0 and
when it matches Ut, Fd is close to 1, so NuOp maximizes
Fd. To perform the optimization, NuOp uses a BFGS [52], a
well-known numerical optimization method.
NuOp starts with template circuits having one layer and
grows the number of layers one at a time. For each template
size i, it uses the optimization to obtain the best Fd possible
with i layers. Then NuOp takes a fidelity threshold as input
(e.g., a decomposition fidelity of 99.999%) and selects the
smallest number of layers that meets the threshold.
NuOp can be flexibly used for any input gate type, as well
as any application unitary by changing the input template.
To evaluate FullXY and FullfSim cases, i.e., the entire gate
family is available, we allow NuOp to use templates where
the two-qubit gate angles are also optimization variables. Our
experiments in Section VII confirm that the decompositions
produced by NuOp are comparable or better than optimized
KAK-based decompositions in Google Cirq.
B. Approximation and Noise-Awareness Optimizations
Current NISQ systems have significantly higher hardware
error rates (0.5-10%) than the decomposition error thresholds
commonly used for gate decomposition (e.g., 10‚àí8 for KAKbased approaches). Therefore, recent works have observed that
a less accurate decomposition that requires fewer operations
can be more beneficial than an exact decomposition [32]. We
incorporate this optimization into NuOp by considering two
kinds of errors: decomposition errors and hardware errors.
Decomposition error is a result of inexact representation of
the target unitary. Hardware error is a result of imperfect gate
implementation on a real device. For a target gate type gj and
number of layers i, the decomposition errors are quantified
using the decomposition fidelity, F(gj ,i)
d and hardware errors
using hardware fidelity, F(gj ,i)
h . Overall, the quality of a decomposition is the product of these two terms. By maximizing
the product across gate types and the number of layers we can
obtain a decomposition that has higher reliability overall, than
maximizing Fd alone:
F APD
u = max gj ,i
F(gj ,i)
d F(gj ,i)
h . (2)

Type Instruction Sets (Up to single-qubit rotations, XY(Œ∏) = iSWAP(Œ∏/2) = fSim(Œ∏/2, 0), CZ(œÜ) = fSim(0, œÜ).)
Single two-qubit gate type S1 = SYC = fSim(œÄ/2, œÄ/6), S2 = ‚àöiSWAP = fSim(œÄ/4, 0), S3 = CZ = fSim(0, œÄ),
S4 = iSWAP = fSim(œÄ/2, 0), S5 = fSim(œÄ/3, 0), S6 = fSim(3œÄ/8, 0), S7 = fSim(œÄ/6, œÄ)
Multiple gate types (Google) G1 = {S1,S2} , G2 = {S1,S2,S3}, G3 = {S1,S2,S3,S4}, G4 = {S1,S2,S3,S4,S5}, G5 = {S1,S2,S3,S4,S5,S6},
G6 = {S1,S2,S3,S4,S5,S6,S7}, G7 = {S1,S2,S3,S4,S5,S6,S7,SWAP},
Multiple gate types (Rigetti) R1 = {S3,S4}, R2 = {S2,S3,S4}, R3 = {S2,S3,S4,S5}, R4 = {S2,S3,S4,S5,S6}, R5 = {S2,S3,S4,S5,S6,SWAP}
Full continuous gate set FullXY = {XY(Œ∏): Œ∏ ‚àà [0, œÄ]}, FullfSim = {fSim(Œ∏, œÜ): Œ∏, œÜ ‚àà [0, œÄ]}
TABLE II: Instruction sets studied in this work. Each set also includes arbitrary single qubit operations (not shown) to make
it universal. S1-S7 were selected based on our application characterization experiments in Section VIII. See Figure 8 for a
graphical view of S1-S7 on the fSim parameter space. For Google, G1-G7 are combinations of S1-S7, e.g., G2 has three
two-qubit gate types. For Rigetti, R1-R5 are selected based on subsets which can be supported using the XY gate family. (For
ease of presentation, the table expresses Rigetti gates with fSim notation; they can be translated to XY(Œ∏) notation using the
identities on the top of the table.)
q0
q1
U3(Œ±0, Œ≤0, Œ≥0)
U3(Œ±1, Œ≤1, Œ≥1) fSim(Œ∏1, œÜ1) U3(Œ±2, Œ≤2, Œ≥2)
U3(Œ±3, Œ≤3, Œ≥3)
¬∑¬∑¬∑
¬∑¬∑¬∑ fSim(Œ∏i, œÜi) U3(Œ±2i, Œ≤2i, Œ≥2i)
U3(Œ±2i+1, Œ≤2i+1, Œ≥2i+1)
Layer 1 Layer i
Fig. 4: The template circuit used in the NuOp decomposition. It consists of i layers, alternating parameterized single-qubit
gates (three parameters Œ±, Œ≤, Œª for each) and fSim gates. To compile for a fixed fSim gate, Œ∏ and œÜ are set to the desired values
in the template. To compile for FullfSim, Œ∏ and œÜ are also considered as optimization variables.
q2
q3
q4
SU(4)
SU(4)
(a) 3-qubit circuit
q2
q3
q4
U3(0.65, 5.75, 1.82)
U3(5.11, 3.25, 0.50)
U3(1.00, 5.19, 0.90)
CZ U3(4.05, 5.83, 3.38)
U3(4.93, 2.25, 0.93) CZ U3(4.99, 6.38, 5.97)
U3(1.87, 2.00, 2.04) ‚àö
iSWAP U3(2.40, 1.04, 6.56)
U3(4.48, 3.16, 3.37)
‚àö
iSWAP U3(1.27, 4.90, 5.11)
U3(2.18, 3.10, 0.25)
Fd = 98.63%, Fh = 88.36%, Fu = 87.15% Fd = 100%, Fh = 92.16%, Fu = 92.16%
(b) Noise-aware approximate decomposition
Fig. 5: Illustration of noise-adaptive approximate decomposition. (a) 3-qubit circuit with two gates, both having the matrix in
Figure 2a. (b) decomposition circuit targeting qubits [2,3,4] on Rigetti Aspen-8 in Figure 3 (We assume the ‚àö
iSWAP=XY(œÄ/2)
gate has the same fidelity as the XY(œÄ) gate). The noise-aware gate compilation pass chooses the decomposition with CZ
gates for qubit pair (2,3) because its high hardware fidelity leads to higher overall fidelity Fu = 88.36% (which is much higher
than Fh = 0.7 of ‚àö
iSWAP). Similarly, the decomposition with ‚àö
iSWAP is selected for qubit pair (3,4). Furthermore, the
approximate decomposition maximizes the overall implementation fidelity by decomposing the unitary into only two CZ gates,
compared to 3 CZ gates in the exact decomposition in Figure 2c.
F(gj ,i)
h is estimated by the product of the hardware fidelity
(1-error rate) of every gate in the decomposition (this model
has been shown to work well in real systems [2], [53]‚Äì[55]).
Figure 5 shows an example decomposition with a CZ gate
that has hardware fidelity 94%. When the above approximate
optimization is used, only 2 applications of CZ are required to
obtain a decomposition with overall fidelity of 88.36% (Fd =
98.63%). If NuOp had used one more CZ gate to achieves
an exact decomposition (decomposition infidelity 10‚àí7), the
overall fidelity will be reduced to 83.06% because of its high
hardware error rate from three CZ applications (0.943).
We can further improve decompositions by exploiting fidelity variations across gate types. In Figure 3, on qubit pair
(2,3), the CZ gate has the highest fidelity, while on qubits (3,4),
the XY(œÄ) gate has the highest fidelity. When multiple gates
types (gj ) are available in a given device, we can choose the
best gate type for each application operation, depending on the
decomposition fidelity using that gate type and it‚Äôs hardware
fidelity. Figure 5 shows a noise-adaptive decomposition of
an application circuit using two gate types. We can easily
implement this idea within NuOp by computing F(gj ,i)
h using
the hardware fidelity of each gate type, obtained from device
calibration data. To our knowledge, our work is the first to
adapt executables to noise variations across gate types.
To decompose a full application for a given instruction set
having multiple two-qubit gate types, NuOp finds the best
decomposition for each application unitary and each hardware
gate type, using approximation if necessary. Then, for each
unitary, NuOp selects the gate type which offers the highest
overall fidelity Fu. NuOp creates an output circuit where
application unitaries are replaced by their best decompositions.
VI. EXPERIMENTAL SETUP
Benchmarks: We use four applications for evaluation: Quantum Volume (QV) [32], Quantum Approximate Optimization
Algorithm (QAOA) [37], Fermi-Hubbard model (FH), and
Quantum Fourier Transform (QFT). They cover the main types

of circuits studied for QC systems i.e, random circuits (QV),
quantum optimization circuits (QAOA), quantum simulation
circuits (FH), and classic QC or longer-term circuits (QFT).
QV is a full-stack benchmark proposed by IBM to compare
different QC devices and compiler stacks. Each random QV
circuit with n qubits has n parallel layers of random two-qubit
gates acting on a random pair of qubits.
QAOA is a promising NISQ application for solving combinatorial optimization problems. QAOA circuits have also been
used to study real-system performance [34]. Our experiments
use QAOA circuits with one layer of the MaxCut ansatz [56].
Each n-qubit QAOA circuit has ‚àº n3/4 random two-qubit ZZ
interactions, interleaved with single-qubit X rotations.
FH is a model of simulating interacting particles in a lattice,
which becomes difficult to solve on classical computers for
large problems. Our evaluation uses the 1D FH model circuits
with one Trotter step [57]. Each n-qubit FH circuit consists
of 2n ZZ interactions and ‚àº 4n 1
2 (XX+YY) interactions.
QFT is a key subroutine in conventional quantum algorithms
such as quantum phase estimation and Shor‚Äôs factoring [58].
An n-qubit QFT circuit consists of n Hadamard gates and
n(n ‚àí 1)/2 CZ(œÄ/2t
) gates (t ‚àà [1, ¬∑¬∑¬∑ , n ‚àí 1]) [59].
QV and QAOA circuits are generated from Qiskit [31]
and ReCirq [60], respectively. Our toolflow is scalable for
large circuit sizes, but current highly noisy systems can
only achieve high-fidelity computation for small-scale circuits.
Therefore, our evaluation experiments uses QV, QAOA, and
QFT benchmarks with 3-6 qubits and FH circuits with 10
and 20 qubits. For each n-qubit QV benchmark, we use 100
random circuits with different circuit structures and unitaries
to test instructions sets against a wide range of application
requirements. Similarly, for each n-qubit QAOA benchmark
we use 100 random circuits with different unitaries.
Decomposition Algorithms: We implemented NuOp as a
IBM Qiskit compiler pass using version 0.20. Numerical
optimization was performed using the BFGS implementation
[52] in scipy version 1.4.1. In NuOp we used templates with
a maximum of ten two-qubit gate layers, but for most cases
less than four layers were sufficient for obtaining high quality
decompositions. To validate NuOp we compare it to the
decomposition passes in Google Cirq v0.8.2.
QC Systems and Simulations: We use realistic noise simulations of two systems: Rigetti Aspen-8 and Google Sycamore.
Aspen-8 has 30 qubits and has 4 connected rings with 8
qubits each (two qubits are not functional). Figure 3 shows
the first ring of qubits. Sycamore is a 54-qubit device having
grid connectivity. For Aspen-8 we obtain real calibration data
from [33], including error rates for each gate type (XY(œÄ),
CZ, single-qubit), coherence times and readout errors. For
experiments with arbitrary XY(Œ∏) gates, we model the gate
errors rates as a uniform distribution in the range 95-99%
(based on experiments in [3]). For Sycamore we obtain qubit
coherence times and readout errors from [2] and acquire error
rates of simultaneous SYC gates and single-qubit gates via
Google‚Äôs quantum computing service. We model the error rates
of other types of two-qubit gates as a normal distribution with
Œº = 0.62%, œÉ = 0.24% (based on the error rate distribution of
SYC gates). For both systems, we use the Qiskit Aer simulator
[31] to perform a noise simulation using the calibration data.
Specifically, it applies single-qubit and two-qubit depolarizing
noises based on single-qubit and two-qubit gate error rates. It
implements amplitude damping and dephasing noise based on
T1 and T2 times as well as gate duration.
Metrics: For QV, the standard metric is the average probability of heavy output generation (HOP) obtained using
100 random circuits [32], [61]. With n qubits, HOP greater
than 2/3 denotes that the set of qubits has quantum volume
2n. For QAOA benchmarks, we measure the average crossentropy difference (XED) [12] metric which tests the quality
of the generated output with respect to the ideal distribution
(noiseless simulation) and the uniform distribution. For FH
benchmarks, we use the linear cross-entropy benchmarking
fidelity [62] metric to compare the measured probabilities
with the ideal probabilities. For QFT benchmarks, we measure the success rate, i.e., the probability of an execution
getting correct quantum states. Higher values are better for
all three metrics. For all circuits, we perform simulations for
10000 shots. We also report the two-qubit instruction counts
required to express an application using a particular gate set.
Compilation setup and performance: Our experiments were
performed on two systems: Intel Xeon Gold 6230 CPU
2.10GHz (using up to 32 threads, 128GB RAM) and Intel
Xeon Gold 6140 CPU 2.30GHz (using up to 36 threads,
192GB RAM). NuOp‚Äôs compilation time scales as O(GH)
where G is the number of 2-qubit gates in the application
and H is the number of available hardware 2-qubit gates.
The compile time is independent of the number of qubits.
Since decomposing an application gate to a hardware gate is
independent of other gates, we use a parallel implementation
of NuOp. With 32 threads, decomposing a circuit with 1000
2-qubit gates to one hardware gate type requires around 220
seconds.
VII. TOOLFLOW VALIDATION AND TUNING
A. Comparison of Cirq and exact decomposition with NuOp
Figure 6 compares the average hardware gate counts and
decomposition error rates for 100 random QV, QAOA, and
QFT unitaries using the gate types from Table I. Compared to
the KAK-based decomposition in Cirq, exact decomposition
with NuOp i.e., NuOp-100% finds decompositions with similar
or less amount of applications of two-qubit hardware gates.
For example, NuOp uses 3 CZ, 3 SYC, or 3 iSWAP gates
for one QV unitary while Cirq requires 3 CZ, 6 SYC, or 4
iSWAP gates. Across applications, NuOp-100% reduces gate
counts by 1.26X on average, compared to Cirq. Furthermore,
NuOp can decompose any target unitary with any native
gate while KAK-based decomposition like Cirq is typically
implemented for decomposing unitaries into specific native
gates. For example, Cirq does not support decompositions of
QV unitaries with ‚àö
iSWAP. Due to NuOp‚Äôs flexibility in
hardware gate sets and gate reductions over Cirq, we use it
for all other experiments in this work.

Fig. 6: Comparison with Cirq. Hardware gate counts (lower is
better) averaged across applications. Legend shows the target
two-qubit gate types. Cirq does not support decompositions
for QV with ‚àö
iSWAP. NuOp-99.9% denotes that 99.9% is
the target hardware fidelity for the decomposition. On average,
NuOp uses 1.3X-2.3X less gates than Cirq, depending on the
hardware gate fidelity and gate type. For NuOp, the average
decomposition errors are within a specified and tunable threshold based on the device requirements, e.g., for NuOp-99%, the
average decomposition error is 0.12%.
Fig. 7: Comparison of exact and approximate decomposition
on application performance with different average error rates
of the SYC gate. The left and right y axis denote the average
HOP of 100 5-qubit QV benchmarks and the average XED of
100 4-qubit QAOA benchmarks respectively (higher values
are better). In the low noise regime, applications that are
decomposed by the approximate approach have similar performance as the ones using exact decomposition. Approximate
decomposition starts outperforming the exact approach when
the device has average error rate around Sycamore‚Äôs (dashed
vertical line).
B. Comparison of exact and approximate decomposition
From Figure 6, across gate sets, NuOp offers 1.33-1.68X
average reduction in gate counts compared to Cirq when
approximation is applied. Compared to NuOp-100%, the reductions with approximation versions of NuOp are average
1.05-1.33X. For example, NuOp-95% obtains QV decompositions that have an average of 1.8 CZ gates per unitary
(40% lower than NuOp-100%) with decomposition infidelity
around 3% (not shown). Figure 7 shows that for both QV
and QAOA benchmarks, decomposition with the approximate
approach achieves similar application performance as exact
decomposition in less noisy systems and outperforms exact
decomposition for systems with higher error rates (around
0.62%). Given that the average two-qubit gate error rates in
the Sycamore processor and the Aspen-8 processor are 0.62%
and 95%, we use the approximate decomposition approach for
evaluating different instruction sets on these two devices.
VIII. BENEFITS OF MULTIPLE GATE TYPES
A. Optimizing Instruction Count
Figure 8 shows the expressivity for application unitaries
across the parameter space of XY and fSim gates. We uniformly discretized the continuous space into a 19 √ó 19 grid
of Œ∏ and œÜ values for this experiment. The value range of
Œ∏ and œÜ are set to be [0, œÄ/2] and [0, œÄ] (instead of [0, 2œÄ])
because of the unitary symmetries under single-qubit phase
rotations. For each parameter combination, we calculated the
average two-qubit instruction counts for 1000 random QV
unitaries, 1000 random QAOA unitaries, 10 QFT unitaries, 60
FH unitaries, and the SWAP unitary. The heatmap shows these
instruction counts normalized by the number of instructions in
the application i.e., the number of two-qubit instructions per
application operation. Overall, the average instruction counts
are strongly influenced by the application and gate parameter
choices. For each application, instruction counts vary between
1 to 6 depending on the gate parameters. Across gate types
and applications, these large differences in instruction counts
imply that choosing the right hardware gate types, based on
the application requirement is important for NISQ systems.
For QV unitaries, gates that are close to fSim(5œÄ/12, 0)
and fSim(œÄ/6, œÄ) are most expressive and near to the optimal
value with a continuous set, i.e., only around 2 instructions
are required per unitary (compared to 3 applications of CZ,
SYC, or iSWAP). In contrast, the most expressive gates for
QAOA unitaries are around iSWAP and CZ (2 applications
per unitary). For QFT unitaries, most fSim(Œ∏, œÄ(0)) and
fSim(œÄ/2(0), œÜ) gates are expressivity-efficient (2 applications
per unitary). For FH unitaries, gates close to ‚àö
iSWAP are
more expressive (2 applications per unitary). We also studied
the instruction counts required for the SWAP unitary, since
SWAPs are the fundamental means of qubit movement in
superconducting systems. For a large fraction of fSim gates, 3
gate applications are required to construct one SWAP unitary.
With fsim(œÄ/4, œÄ/2), we require 2 gate applications and with
fSim(œÄ/2, œÄ), we require only 1 gate application since this gate
is equivalent to the SWAP gate up to single-qubit rotations.
From these heatmaps, certain gate types perform well for
multiple applications. For example, fSim(œÄ/6, œÄ) gives low
instruction counts for all cases. Selecting gates in this manner,
we arrived at a set of seven two-qubit gate types that offer low
instruction counts. These types are shown in Table II. This list
also includes CZ, XY(œÄ), SYC, and ‚àö
iSWAP gates which are
used in current Rigetti and Google systems. We use these gate
types and their combinations for the subsequent experiments.
B. Optimizing Application Reliability
Figures 9 and 10 show the application reliability comparison among instruction sets with a single gate type (S1-
S7), instruction sets having multiple gate types (R1-R5 for
Rigetti and G1-G7 for Google), and instruction sets which

(a) QV unitaries (b) QAOA unitaries (c) QFT unitaries (d) FH unitaries
(e) SWAP unitary
Fig. 8: Average two-qubit hardware gate counts (lower is better) when decomposing (a)
1000 random QV unitaries, (b) 1000 random QAOA unitaries, (c) 10 QFT unitaries, (d) 60
FH unitaries, and (e) the SWAP unitary into different gates in the fSim(Œ∏, œÜ) family using
NuOp‚Äôs exact decomposition (Fd ‚â§ 10‚àí6). The XY gate set is a subset of the fSim gate
set and is highlighted by the blue box. We select the types S1-S7 and the hardware SWAP
gate, highlighted by green boxes. These types are used as baseline instruction types in
Table II, and their combinations are used to study instruction sets with mutiple gate types.
If all gates in the fSim set are available (i.e. a continuous set), then the average gate counts
for QV, QAOA, QFT, FH and SWAP unitaries are 2, 1, 1, 1 and 1, respectively.
(a) 100 3-qubit QV circuits (higher is better) (b) 100 4-qubit QAOA circuits (higher is better)(c) The 3-qubit QFT circuit (higher is better)
Fig. 9: Simulation results on Rigetti Aspen-8 with noise variations across gate types. The QV threshold is marked with a
horizontal line at 2/3. Instruction sets with multiple gate types (R1-R5) improve application performance compared to singlegate instruction sets (S2-S6). R5 that includes hardware SWAP gate, nearly achieves the same maximum reliability as FullXY.
use the full continuous parameter space (FullXY for Rigetti
and FullfSim for Google). In Figure 9a and 10a, instruction
sets with multiple types increase the heavy output probability
(HOP) by up to 6.6% (on average 2.3%), compared to the
best instructions sets with one type. HOP is averaged across a
large number of circuits and even small improvements are very
significant for applications [32]. In particular, for Rigetti, none
of the single gate type instruction sets reach the HOP threshold
of 2/3, while R3, R4 and R5 cross the threshold. That is,
having access to these 4-6 types of two-qubit gates can double
the quantum volume of the system. When the instruction
set has multiple gate types, the cross-entropy differences of
QAOA benchmarks improve by up to 12.9% (5.9% on average)
in Google and 143.7% (43.1% on average) in Rigetti. Similarly
for QFT, the success rates increase by up to 26% (11.6% on
average) in Google and 56.5% (15.2% on average) in Rigetti.
Finally, the fidelity of the FH circuit increases by up to 56.8%
(29.8% on average) in Google (The fidelity for Rigetti is very
low owing to high gate error rates, and is not reported in this
paper).
We further compare the application reliability using
multiple-gate sets with the values achieved by using full
continuous sets. In Figure 9 and 10, across benchmarks and
quantum systems, the applications decomposed with FullXY
and FullfSim have much higher reliability than the decomposition with R1-R4 and G1-G6 instruction sets. This is because
many routing operations (i.e., application SWAP gates in
Qiskit compiler) are inserted to comply with the connectivity
limitation in Sycamore and Aspen-8. This leads to a significant
increase in the total instruction counts. These SWAP operations are difficult to express succintly using the gates in R1-R4
and G1-G6. When the SWAP gate is added as a native type,
i.e., in R5 and G7, the instruction set offers reliability close to
the optimal values achieved by FullfSim. Therefore, our work
shows that implementing multiple types of two-qubit gates
is beneficial and only a few application-expressive types are
required to obtain reliability comparable to using the entire
continuous set.
Figure 10f compares the fidelity for FH circuits with 10
and 20 qubits. At high noise levels, having multiple gate types

(a) 100 6-qubit QV circuits (higher is better) (b) 100 6-qubit QAOA circuits (higher is better)
(c) The 6-qubit QFT circuit (higher is better) (d) The 10-qubit FH circuit (higher is better)
(e) 100 6-qubit QAOA, no noise variations across gate types (f) 10- and 20-qubit FH with different noise levels
Fig. 10: Simulation results on Google Sycamore (a-d) with and (e) without noise variation across gate types. The QV threshold
is marked with a horizontal line at 2/3. Multi-gate instruction sets (G1-G7) improve application performance compared to singlegate instruction sets (S1-S7). Compared to (b), the improvements of G1-G7 in (e) are less if no noise variation across gate
types. The instruction set with SWAP gate (G7) achieves comparable reliability as FullfSim. The advantages of the continuous
set reduces or even disappear when the average gate error rates in continuous set increase to 2X (the lightest blue bars). (f)
Fidelity for Fermi-Hubbard model circuits with 10 and 20 qubits. Average two-qubit hardware error rates are varied from
0.02% (low noise) to 0.36% (high noise, current error rate). Across circuit sizes and noise ranges, multiple gate types (G7)
outperforms the single gate type.
offers significantly better executions, with average 1.45X, up
to 1.7X improvement in fidelity compared to a single gate type,
for the 20-qubit case. Across circuit sizes, the instruction set
with multiple gate types (G7) outperforms the set with only
single gate type (S2) consistently, but the benefits reduce as
the hardware error rate improves. Multiple instruction types
are most beneficial at hardware noise levels that are expected
in the next 5-10 years.
To understand why reliability improves using multiple gate
types, we studied two sources of improvements: 1) reduction
in instruction counts and 2) noise adaptivity across instruction
types. In Figures 9 and 10, the bars are annotated on top with
the respective two-qubit instruction counts. Compared to S1-
S7, the number of instructions required to implement applications reduces when multiple instruction types are available
in R1-R5 and G1-G7.2 For Rigetti, multiple-gate sets R1-R4
2Note that these reductions are less prominent than the heatmaps in Figure
8 because the most expressive gate types were selected as the S1-S7 baselines.
reduce the instruction count by up to 14% compared to the
single-instruction sets. When the SWAP gate is also added in
R5, the reduction is on average 1.5X for QV, 2X for QAOA
and 1.5X for QFT. Similarly, for Google, sets with multiple
instruction types reduce the instruction count and G7 obtains
average 1.9X reduction for QV, 1.6X for QAOA, 1.8X for
QFT, and 1.3X for FH. In particular, the instruction counts of
R5 match FullXY for all the three applications and the counts
of G7 are very close to FullfSim. Hence, having a small number
of instruction types is sufficient to obtain the same expressive
power of a full continuous gate set for most applications.
To isolate the reliability benefits from gate count reductions
from reductions obtained through noise adaptivity, in Figure
10e, we repeated the experiment in Figure 10b but with the
assumption that there is no noise variation across gate types.
Compared to Figure 10b, G7 in Figure 10e still reduces
instruction counts and obtains higher cross entropy difference
than the other discrete instruction sets. Importantly, it almost

(a)
(b)
Fig. 11: Tradeoffs between calibration overhead and application performance. (a) The number of calibration and benchmarking circuits grows with the number of hardware gate types
and the device size (# qubits). (b) The calibration time cost
(left y axis) and application performance improvement (right
y axis) increase with the number of hardware gate types.
matches the performance of FullfSim. In contrast, even though
the gate count reductions of G1-G6 remain similar (‚àº 10%),
the application reliability improvements are lesser than the
improvements in Figure 10b. Similar observations can be
found for other benchmarks in Sycamore. This indicates that
small improvements in gate counts are likely to have a low
impact on application reliability in future systems where better
gates and lower noise variability. However, in current and nearterm systems, different gate types have significantly different
error rates. NuOp exploits these noise differences to choose
the best gate types across qubits and therefore achieves more
improvements with G1-G6 in Figure 10b.
To study the importance of noise adaptivity, we compare
the single-instruction sets S1-S4 with their combination G3
in Figure 10c. The two-qubit gates in S1-S4 have the same
expressivity and same average gate error rates. However, S1-
S4 have different performance because of fluctuations in error
rates across the operating qubits. In comparison, G3 achieves
much higher success rate than S1-S4 because exposing multiple instruction types allows noise-adaptivity across gate types
and helps in mitigating the noise variations that arise when
only type of gate is used. Therefore, the fidelity improvements
with multiple instruction types arise because of both improved
expressivity and noise-adaptivity across gate types.
IX. CALIBRATION OVERHEAD OF MULTIPLE GATE TYPES
In this section, we estimate the calibration overhead with
multiple gate types by adopting the calibration model of the
continuous fSim set in [4], where 525 gate types are calibrated
on real hardware. As mentioned previously, a fSim gate can
be seen as the composite of a CPHASE gate and an iSWAPlike gate. Therefore, the calibration of one single fSim gate
type (fSim(Œ∏, œÜ)) on one qubit pair can be divided into several
steps. The first step is to calibrate the CPHASE gates with rotation angle œÜ and angle œÄ. The second step calibrates iSWAPlike gates with angle 0 and angle œÄ/2 while the CPHASE angle
is tuned to œÜ. Then one tunes up the iSWAP-like gate angle
Œ∏ with CPHASE angle œÄ. Afterwards, the calibration data of
these CPHASE and iSWAP-like gates are used to construct a
pulse for the target fSim(Œ∏, œÜ) gate and unitary tomography is
performed to further adjust its pulse parameters. Finally, the
fidelity of this fSim gate is characterized by running a large
number of cross entropy benchmarking circuits (1000 rounds).
This is a conservative calibration model in which each gate
type is calibrated individually on isolated qubits. In practice,
more calibrations are required for minimizing errors due to
pulse overlaps [4] and crosstalk.
Figure 11a shows the number of calibration circuits for
different number of gate types and system sizes. The number
of circuits increases linearly with system size and the number
of gate types. For a 54-qubit device, we require ‚àº 107 circuits
to calibrate 10 gate types. For a 1000-qubit system, nearly
a billion circuits are required even for a small number of
gate types. Comparing with current systems, calibrating two
qubits in [63] takes up to four hours, including the calibration
of electronics, qubit frequencies, single-qubit rotations, and a
single two-qubit gate type. Even if we conservatively assume
that a single two-qubit gate type takes ‚àº2 hours, the linear
scaling of calibration time with gate types and system sizes
makes it practically intractable to calibrate a full gate family.
Figure 11b shows the tradeoffs between calibration time
and application reliability (data from Figures 9 and 10).
When more gates are available in the hardware, the average
application reliability improves, but with diminishing returns
after five gate types. Interestingly, the gate sets that have
SWAP gates (R5 and G7) offer reliability comparable to the
continuous sets. In practice, the continuous instruction set will
likely have lower average gate fidelity than the discrete sets
due to calibration difficulties and pulse overlaps [13]. The
reliability improvements resulting from gate reduction may
be compromised by the increased average gate error rates.
To study this, we performed simulations using FullfSim with
different increasing factors in the average error rates as shown
in Figure 10a-10c. Compared to discrete multi-gate sets G1-
G7 with average error rates 0.62%, the advantages of FullfSim
disappear when its average error rates increases to 1.5X, 2X,
2.5X for QV, QAOA, and QFT benchmarks respectively.
Since calibration and benchmarking overheads increase with
the number of gate types, having a small number of expressive
two-qubit gates is beneficial and sufficient to obtain high

reliability. To summarize, we recommend that QC systems
implement 4-8 different two-qubit hardware gates that are
expressive for most applications to obtain a sweet spot of
high-fidelity application executions and low device calibration
overheads. In addition, having hardware SWAP gates for
connectivity-constrained devices or other application-specific
gates can greatly improve reliability.
X. CONCLUSIONS
Most QC instruction sets have a single type of two-qubit
gate. This design choice sacrifices application expressivity,
but simplifies calibration. On the other hand, vendors have
proposed continuous gate families which maximize application
expressivity, but are very difficult to calibrate especially as
systems scale up. These tradeoffs are reminiscent of the
instruction count vs. hardware complexity tradeoffs of RISC
and CISC designs in classical computer architecture. Our work
used an application-based simulation analysis of instruction
sets, with realistic device and calibration models, to identify
a small instruction set that is both efficient for application
decompositions and easy to calibrate. Our proposed instruction sets R5 for Rigetti and G7 for Google have only 4-
8 two-qubit gate types, but offer near-optimal applicationexpressivity and fidelity compared to a continuous instruction
set, while reducing calibration overhead by two orders of
magnitude. NuOp is available open-source at https://github.
com/prakashmurali/NuOp.
With several vendors aiming to improve QC reliability
by offering better gate types, our work is poised to guide
instruction set design choices through the NISQ-regime.