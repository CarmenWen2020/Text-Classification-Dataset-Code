—Transient execution vulnerabilities originate in the extensive speculation implemented in modern high performance microprocessors. Identifying all possible vulnerabilities in complex designs is very challenging. One of the challenges stems from the lack of visibility into the transient micro architectural state of the processor. Prior work has used covert channels to identify data leakage from transient state which limits the systematic discovery of all potential leakage sources. This paper presents INTROSPECTRE a pre silicon framework for early discovery of transient execution vulnerabilities. INTROSPECTRE addresses the lack of visibility into the microarchitectural processor state by integrating into the register transfer level RTL design flow gaining full access to the internal state of the processor. Full visibility into the processor state enables INTROSPECTRE to perform a systematic leakage analysis that includes all micro architectural structures allowing it to identify potential leakage that may not be reachable with known side channels. We implement INTROSPECTRE on an RTL simulator and use it to perform transient leakage analysis on the RISC V BOOM processor. We identify multiple transient leakage scenarios most of which had not been highlighted on this processor design before. I. INTRODUCTION Transient execution vulnerabilities originally uncovered by the Meltdown and Spectre attacks have exposed fundamental security weaknesses in modern processor designs. The discovery of these vulnerabilities has lead to an explosion of transient execution attack variants — over the last few years. In response a robust body of defenses has been proposed . While prior work has made significant advances in addressing many of the attack variants new transient execution vulnerabilities continue to be discovered . A major challenge in discovering all the circumstances in which transient execution can lead to secret data leakage is posed by the nature of transient execution itself. By definition transient microarchitectural state is rolled back when illegal data accesses or mispeculated/invalid instructions are executed. This creates a major roadblock to fully understanding This work was funded in part by Intel Corp. under the Side Channel Academic Program and by the Air Force Research Laboratory under the Assured and Trusted Microelectronics Solutions award FA C . // . © I DOI ./ISCA.. and searches for leakage of secret data deliberately inserted in each fuzzing round. A detailed execution model constructed by the gadget fuzzer is used throughout the framework to assist with the code generation and leakage analysis. We implement INTROSPECTRE on top of Verilator an open source RTL simulator and use it to analyze the RISC V BOOM processor . We discover potential leakage arising from incorrect handling of permissions checks in several cross boundary accesses or aggressive line fill buffer LFB fill policies. We also find that the hardware prefetcher may exacerbate some forms of leakage. INTROSPECTRE identifies potential leakage in the physical register file line fill buffer and write back buffer of the tested processor. Overall we discover distinct not previously documented Meltdowntype transient leakage vulnerabilities in the target processor. This paper makes the following contributions • • • • b Spectre type leverage misprediction in the processor such as the pattern history table branch target buffer return stack buffer or store to load forwarding to trigger the transient execution of instructions of interest to the attacker. Shared prediction mechanisms allow attackers to manipulate prediction outcomes across security boundaries enabling the coercion of victim processes into executing down a selected transient path ultimately leaking their own secrets through pre determined disclosure gadgets. c Microarchitectural Data Sampling MDS type leverage in flight data that is stored in fill and other buffers and which is forwarded without adequate permission checks. Examples include RIDL which found that if load and store instructions are ambiguous some processors may speculatively forward data from the store buffer to the load buffer ZombieLoad that demonstrated line fill buffers are accessible by all logical CPUs and make no distinction between processes or privilege levels when forwarding data CrossTalk which revealed the ability to leak data from staging buffers shared across CPU cores and CacheOut that showed it is possible to select which data is leaked. There are several cross cutting factors across these axes which play a role in determining the success of attacks such as the ability to affect speculation primitives speculative window size achievable latency of the chosen disclosure gadget timing reference resolution and retention time of the covert channel. Defenses attempt to reduce or eliminate the feasibility of these factors in order to minimize the likelihood of attack success. Presents INTROSPECTRE the first RTL level framework for detection of transient execution vulnerabilities. Presents a methodology for feedback driven fuzzing of test gadgets that increases the effectiveness of the generated test code. Implements INTROSPECTRE on top of Verilator an opensource RTL simulator. Demonstrates the effectiveness of INTROSPECTRE by detecting multiple Meltdown type vulnerabilities and potential leakage scenarios in the RISC V BOOM processor. The rest of this paper is organized as follows Section II provides background on transient execution attacks and related work on exploit detection and synthesis. Section outlines the threat model. Sections IV VI present the In t r o Spe c t r e framework design. Section VII details the implementation and experimental methodology. Section V presents a number of use case scenarios for transient leakage detection and Section IX concludes. B. Attack Mitigations Several approaches to defending against information leakage through transiently executed instructions have been proposed both by industry and academia. Industry responded to the initial disclosure of these exploits in with guidelines for application developers which were essentially to insert serializing instructions directly after any vulnerable code sections to constrain speculation. Additionally micro code updates continue to be released by processor vendors as new vulnerabilities are disclosed seeking to remedy sources of leakage in processor functionality where possible. For example Intel provided a patch along with system software support to flush and disable shared branch predictor structures at runtime . A comprehensive list of micro code updates and security guidance can be found in Intel s Security Advisory portal . Google engineers developed the retpoline compiler level steering scheme to isolate indirect branches. Kernel page table isolation KPTI was integrated into the Linux kernel which removed kernel page mappings from user space and eliminated the ability to conduct Meltdown attacks. Academia the computer architecture community has advocated for modifications in processor design to enhance the security of transient execution. Solutions proposed have mostly followed two general protection schemes invisible II. BACKGROUND AND RELATED WORK A. Transient Execution Attacks Transient execution attacks can be categorized along two primary axes how transient effects are co opted and the channel used to covertly communicate information. The second axis has mostly explored use of the cache hierarchy occupancy replacement metadata coherence state but others have shown it practical to utilize port contention and AVX instruction latency as well . Attacks can then be further placed into three classes based on the first axis a Metldown type leverage transiently executed instructions in the shadow of a fault. The canonical example and namesake for this category transiently executed instructions past a pending exception on on an illegal memory load. This type of permission bypassing manifests when protection checks are performed in parallel to actual data accesses. Other examples include attacks abusing transient execution past an illegal register read or past lazily cleaned register state upon a context switch . which satisfy given constraints and represent the behavior of a specific exploit from which actual exploit programs can be synthesized. UPEC constructs safety hardware properties by shaping formal definitions of security in the domain of transient execution attacks. The hardware properties are then checked to verify if the program is executed uniquely with respect to the secret. Limitations of Existing Frameworks Frameworks like SpeechMiner Transynther SpecFuzz or DifFuzz face the twin challenges of very limited microarchitectural implementation information and the lack of visibility into microarchitectural state. SpeechMiner for instance uses abstract implementation models that may be incomplete and could miss subtle behaviors. SpeechMiner also has to rely on covert channels to identify leakage. This means the source of the leakage has to be known or suspected in order to be leaked by the covert channel. This significantly limits the possibility of discovering new leakage sources. speculation mechanisms such as Invisispec SafeSpec Delay on Miss and MuonTrap where microarchitectural state is hidden in dedicated shadow buffers while computing in a speculative shadow or undone following a misprediction in the case of CleanupSpec mechanisms constraining the use of speculative data from within the pipeline such as SpecShield STT NDA SDO and DOLMA until data is no longer speculative. Other defenses require system software support such as setting up cache partitions to isolate memory accesses across processes with DAWG or the annotation of secret data in ConTExT and Context Sensitive Fencing which use taint tracking to detect malicious gadgets and/or subvert the leaking of sensitive data. C. Exploit Detection and Synthesis Prior work has explored methods by which to synthesize unique transient execution exploits as well as techniques to automatically detect vulnerabilities which allow for covert channel formation and transmission. Approaches taken so far include utilizing forms of fuzzing formal analysis and information flow tracking. Fuzzing based Approaches Transynther is aimed at discovering Meltdown type attack variants by fuzzing seeds of known exploits applying random mutations to various attributes associated with the faulty load and utilizing the cache as a covert channel in proving the existence of a leak. SpecFuzz uses a dynamic testing methodology for discovering Spectre type transient execution vulnerabilities. The tool simulates speculative execution in software by forcing the direct execution of all reachable code paths. Memory accesses that would otherwise be hidden are made visible to integrity checkers which can then identify potential disclosure gadgets. DifFuzz fuzzes program inputs with the goal to discover side channels. DifFuzz analyzes two copies of the same program with different secret values but the same inputs. A cost metric is then computed based on the difference in side channel measurements resource usage specifically the number of instructions executed and memory footprint between the two applications. SpeechMiner leverages a fuzzing framework to identify Meltdown type vulnerabilities in existing processors. Sequences of x instructions are constructed using templates and executed in a controlled environment. A cache based covert channel is used to determine if vulnerabilities exist. ABsynthe introduces a framework for finding contention based side channels by measuring the relative effects on timing between different instructions in real hardware and formulating an optimization problem based on the maximization of said effects. Formal Specifications Spectector uses symbolic execution to automatically detect leaks from transient execution by verifying if speculatively executed instructions leak more than committed instructions. Checkmate is a tool for exploit synthesis based on happens before graphs which encode microarchitectural events and event orderings. Relational model finding is applied to determine sets of edges D. Hardware Verification Information flow Tracking Information flow tracking mechanisms for hardware designs seek to capture the routes of sensitive data through architectural or gate level structures in order to verify the absence of exposure to an attack surface. SecVerilog introduces a type system extension to the Verilog HDL where information flow policies for a design can be specified and checked statically at compiletime. GLIFT proposes an architecture able to track these flows at run time. These approaches are effective at identifying a broad range of information leakage scenarios. However they generally require the redesign of the target processors with increased complexity which may not be practical for all applications. Side Channel Analysis SVF proposes a quantitative method to evaluate side channel information leakage of a design by measuring the correlation of side channel information patterns to the actual execution patterns. CSV builds on top of SVF by limiting the scope of side channels to only cache side channel attacks and improves the accuracy of the resulting metric. These approaches are targeted to side channel characterization and do not directly address the sources of transient execution leakage. Constrained Random Verification Constrained Random Verification CRV is a design verification method used widely in industry primarily to verify functional correctness. CRV uses automatic generation of random input vectors that follow a set of pre defined constraints. As the stimuli generation is done automatically CRV can be especially useful in uncovering corner cases in large and complex designs. CRV can be incorporated in hardware description languages such as SystemC providing faster verification for designs modeled in higher levels of abstraction. In general CRV methods do not rely on feedback driven input generation. INTROSPECTRE uses approaches similar to CRV to randomize test gadget parameters. However CRV does not generally include a sufficiently expressive feedback mechanism to guide Gadget Fuzzer RTL Simulation Leakage Analyzer Instruction Type PC Fetched Cycle Decoded Cycle Renamed Cycle Issued Cycle Filtered Exe Log Cycle N LFB WB RF Val Val Val ST/LD Queue Mode U Secret Timeline Secret Secret Investigator Secret Secret Secret ........ O...... Secret Fig. High level illustration of the INTROSPECTRE workflow. Framework includes two main components a Gadget Fuzzer and a Leakage Analyzer. INTROSPECTRE is designed to run in conjunction with an RTL simulator. input selection. INTROSPECTRE relies on a detailed execution model to generate highly relevant test sequences rather than rely on random selection. Also unlike CRV INTROSPECTRE relies on more abstract building blocks instructions and gadgets for test generation rather than unit level/ensemble of units level testing. This level of abstraction allows INTROSPECTRE to expose leakage that requires complex softwareinitialized states such as OS isolation boundaries secret value prefetching in various microarchitectural structures etc. Other recent work has also similarly observed the benefits of fuzzing like approaches to hardware verification. state of the processor and are therefore extensively used for functional debugging and testing in industry. The INTROSPECTRE framework consists of two main components The Gadget Fuzzer and The Leakage Analyzer Figure . The gadget fuzzer Section V is responsible for generating stress test code sequences that use speculation primitives to attempt to access and leak privileged data. The test sequences are run through the RTL simulator which generates a detailed execution log. The leakage analyzer Section VI is used to parse the RTL log to determine if secret leakage is possible. A detailed execution model Section V C constructed by the gadget fuzzer is used throughout the framework to assist with the code generation and leakage analysis. . THREAT MODEL INTROSPECTRE targets transient execution vulnerabilities that can potentially leak data across isolation boundaries. We target Meltdown type vulnerabilities in which permission checks are lazily enforced relative to the data access. INTROSPECTRE is designed for pre silicon verification and we assume access to the RTL implementation of the processor under test. We consider cases of potential leakage in which secret data that crosses isolation boundaries is found in microarchitectural structures while user level code is executing. V. THE GADGET FUZZER The primary role of the gadget fuzzer is to generate relevant test sequences that exercise a wide range of possible transient execution leakage scenarios. The gadget fuzzer borrows some of the principles of fuzzing based test case generation including feedback based selection. In order to keep the test cases focused on transient execution vulnerabilities we use a set of predefined code gadgets designed to cover the space of possible speculation primitives isolation boundaries and memory access instructions. The gadget fuzzer consists of three main components that work jointly to generate targeted test sequences Stress Test Gadgets Execution Model Generator and Secret Value Generator Figure . The gadgets are short code snippets that are combined by the fuzzer to generate leakage test sequences. An execution model is constructed in parallel with the test sequences and provides feedback to the fuzzer to ensure that the resulting test meets certain functionality requirements. This helps prune the very large space of possible test sequences by selecting the ones most likely to lead to useful outcomes. Table I lists the gadgets we use in our INTROSPECTRE implementation on the RISC V BOOM processor. IV. INTROSPECTRE FRAMEWORK DESIGN Register transfer level RTL representation is a low level detailed implementation of a hardware design. An RTL design is sufficiently detailed to be synthesized and deployed into hardware. An RTL simulation uses the RTL representation of a design to produce a true and detailed simulation of the final hardware product. These simulations capture the precise timing and state of every single logic and memory element. They can therefore provide an accurate and very detailed representation of the runtime behavior of the hardware product. Unlike architectural simulations which are approximations of a design s behavior RTL simulations rely on the actual hardware implementation and are therefore very accurate and detailed. RTL simulations can provide full visibility into the M M M M M M M M M M M M M M M H H H H H H H H H H H S S S S Main Gadgets Description Meltdown US Meltdown SU Meltdown JP PrimeLFB STtoLD Forwarding FuzzPermissionBits ContExeWritePort ContExeUnit RandomException TorturousLdSt AMO Insts Load WB LFB Meltdown UM ExecuteSupervisor ExecuteUser Retrieve a value from supervisor memory while executing in user mode. Retrieve a value from a user page while executing in supervisor mode when SUM bit of sstatus CSR is clear. Jump to a user address and execute the stale value. Prime line fill buffer LFB entries with known values from Secret Value Generator. Generate store and load instructions with overlapping addresses. Test different combinations of permission bits for a user page. Each page table entry PTE has permission bits. Create contention on execution units with the same write port. Create contention on unpipelined execution units. Randomly choose an excepting instruction and execute it with a bound to flush method. Randomly generate loads and stores back to back from/to addresses that the processor has already interacted with. Randomly execute one atomic memory operation AMO instruction. Generates loads from values currently in write back buffer or line fill buffer. Retrieve a value from machine mode protected memory PMP while executing in supervisor/user mode. Jump to a supervisor memory location and start executing instructions. Jump to an inaccessible user memory location and start executing instructions. Helper Gadgets Description LoadImmUser LoadImmSupervisor LoadImmMachine BringToMapping BringToDCache BringToInstCache Start/FinishDummyBranch SpecWindow DummyException Long/ShortDelay FillUserPage Use Secret Value Generator to generate a user memory address. Use Secret Value Generator to generate a supervisor memory address. Use Secret Value Generator to generate a machine memory address. Create a mapping for a user page with full permissions. Load a memory location to the data cache through bound to flush load. Load a memory location to the instruction cache through bound to flush jump. Create dummy branches where all instructions in between are going to be squashed. Open speculative windows of different sizes. Raise an exception to change the execution privilege in order to execute a setup gadget. Insert variable delays in before execution of main gadgets. Fill a user page with data values that correlate with the page s address. Permutations Permutations Setup Gadgets Description ChangePagePermissions CSRModifications Fill/FlushSupervisorMem Fill/FlushMachineMem Modify user pages permissions bits as needed for the main gadgets. Modify supervisor/machine CSRs for the main gadgets. Fill/Flush supervisor memory pages KB with values generated by Secret Value Generator. Fill/Flush machine only memory pages KB with values generated by Secret Value Generator. Permutations TABLE I INTROSPECTRE gadget types with a brief description of their intended functionality. Permutations indicates the number of distinct variants available for each gadget. A. Stress Test Gadgets execution vulnerabilities by exercising uncommon accesses and isolation primitives. INTROSPECTRE can identify potential leakage of secret data in microarchitectural structures without having to include a leakage channel in the test sequence. This allows the framework to highlight potential leakage that may not yet have a known leakage channel. Gadgets are designed to be composable and allow for data communication where the output of one gadget becomes the input of another. In addition multiple gadgets can be composed to execute together within the same speculation window. The execution model is used to ensure gadgets communicate through memory or registers and to estimate the effect of the gadgets execution on the architectural and microarchitectural state of the system. The main gadgets represent the core of the speculation primitive and access instructions. In order to create a variety of conditions under which secret leakage can be observed additional helper gadgets are needed. For example for a simple Meltdown US gadget M in Table I the intended behavior is to load a secret value from supervisor memory while the code is running in user mode. The main gadget itself consists of a single load instruction. However certain microarchitectural conditions are required for each main gadget to execute as intended. For the Meltdown US gadget a known secret value stored in a known supervisor memory location is needed. Helper Gadgets are used to establish the predefined conditions needed by the main gadgets to work as intended. For We use simple gadgets as the building blocks for the stress test code sequences. We use gadgets as an input to the Fuzzer rather than individual instructions in order to keep the space of possible test outputs focused. However to increase test entropy these gadgets are randomly selected and assembled in random order by a Fuzzer module. In addition each gadget has multiple parameters that are randomly set by the Fuzzer. INTROSPECTRE uses three types of gadgets to construct test sequences Main Gadgets Helper Gadgets and Setup Gadgets. Main Gadgets represent the core of the leakage test sequences. They include speculation primitives and data access instructions. Many gadgets are based on known attacks while others are added to ensure all documented speculation primitives are covered. In the current implementation of INTROSPECTRE we focus on Meltdown type vulnerabilities in which secrets are leaked across various isolation boundaries. The speculation primitives we target are primarily exceptioncausing instructions. While several of the main gadgets are generated based on known transient execution attacks others are intended to exercise different speculation primitives and isolation boundaries even if no clear leakage channel can be defined a priori. This is achieved by gadgets such as FuzzPermissionBits M in Table I in which the fuzzer randomly changes the permission bits of target pages while performing different loads and stores to these pages. This approach can help reveal novel transient example for Meltdown US another requirement is that the target supervisor address should be present in L data cache. A helper gadget BringToDCache H is constructed to prefetch the required memory location in the cache. However the required memory address will not be available in L data cache immediately after executing this helper gadget. The fuzzer uses the Long/Short Delay H helper gadget to make sure the data is cached in the L data cache before the Meltdown US M gadget is executed. Setup Gadgets are responsible for setting up the needed architectural/microarchitectural state for the main gadgets in supervisor/machine mode. Unlike helper gadgets which run in user mode setup gadgets are intended to prime the system with state that can only be changed in supervisor/machine mode. For example we implement a simple ChangePagePermissions S in Table I gadget that assigns permissions to a target page. This gadget is preceded by a gadget that deliberately raises an exception in order to elevate the execution privilege to supervisor mode. The fuzzer inserts setup gadgets like ChangePagePermissions in the exception handler code where they will be executed with supervisor privileges. After the exception is handled and the setup code executes control is returned to the main gadget in the test sequence. In Listing we show an example fuzzing round that includes all three types of gadgets combined to replicate the Meltdown US behavior. First a supervisor page is populated with secrets corresponding to its address by executing S setup gadget in supervisor mode. Next a random address is chosen from this page using H helper gadget and then H gadget is executed to bring the supervisor secret into the L data cache and also update the TLB with the new mapping. H helper gadget utilizes a long latency chain of dependent divide instructions to delay branch resolution providing enough time for the subsequent load to perform address translation and secret prefetching before being flushed from the pipeline. Now we have the supervisor secret in the LFB and the next step is to use H to wait for the secret to propagate into the L data cache. Finally the M main gadget retrieves the data from the cache. In order to suppress the page fault exception raised by this illegal access the load instruction M can be placed behind a mispredicted branch H helper gadget . The decision to include setup gadgets and helper gadgets is based on the state of the execution model. For instance after the main gadget M is selected the fuzzer checks M s list of requirements against the current state of the execution model. If kernel addr is not present in the L Data Cache model the fuzzer selects one of the prefetching gadgets in this example H to execute before M. // Setup Gadget //S Populate kernel page with secrets memset KernelPage X Secret X // Helper Gadget //H Choose a random address kernel addr random KernelPage X Kernel Page X //H Prefetch secret data into LD /TLB x y / z // dependent divide insts to delay branch resolution z y / x y y / z if y N // mispredicted branch on y value load kernel addr //H Wait for the data to arrive in LD NOP //H Mispredicted branch to hide exception. x x / z if x N //Main Gadget M load kernel addr // load supervisor secret Listing Meltdown US gadgets. secret values are generated as a function of the address where they will be stored. If the leakage analyzer finds one of the secret values in the execution log it can identify the memory location where the leaked data originated. Using the execution model the analyzer can then identify which instruction was the potential source of the leakage and flag it for further analysis. C. Execution Model The INTROSPECTRE fuzzer includes an execution model designed to assist gadget selection instruction generation and leakage analysis. One of the key design challenges for our framework was how to prune the very large space of possible test code that the fuzzer can generate. To this end we designed a novel approach to guide the fuzzing code generation that relies on an execution model to predict the behavior of the fuzzed code. The execution model guides the intelligent selection of gadgets and gadget parameters to make the code generated for each fuzzing round more likely to exercise useful paths. The execution model provides an estimate of the microarchitectural state of the processor gradually constructed by the fuzzer as new gadgets are selected for a given fuzzing round. For each instruction or group of instructions that the fuzzer adds to a fuzzing round the execution model records the expected effects on the microarchitectural states of the processor. The execution model works similarly to a simple microarchitectural simulator. As Figure shows the model keeps track of the state of multiple architectural and microarchitectural elements including mapped pages register allocation cache and TLB contents etc. For each instruction added to the test code the execution model is updated by estimating the effects of that instruction. For example if the fuzzer adds a B. Secret Value Generator The INTROSPECTRE fuzzer uses a secret value generator to produce memory addresses and populate them with secret data values that can be later observed in the execution log. Having memory pages with different privileges populated with known secret data helps the leakage analyzer identify potential leakage by searching the log for those values. These Fuzzer Output . RVGC Inst . RVGC Inst ° . RVGC Inst . RVGC Inst N. RVGC Inst EM PermissionChange Snapshots EM Snapshots EM • • EM EM • • Main Gadgets Helper/Setup Gadgets Instruction Sequence EM « ° P I I EM P EM P P EM N I EM P ■■■ EM P M Fig. Execution model snapshots record expected microarchitectural state after each instruction. Load instruction its address is also added to a list of cached addresses along with all other addresses residing in the same cache line. The contents of the TLB and Line Fill Buffer are also updated. This information is used by the fuzzer to determine if certain requirements for the main gadgets are met. Based on this analysis the fuzzer may choose to add setup or helper gadgets to the code. Let s consider a scenario in which a main gadget M relies on certain values to be in the cache in order to perform as designed. After adding M to the test code the fuzzer checks the execution model to determine whether the targeted address is on the list of cached addresses. If it is not the fuzzer chooses a helper gadget that will attempt to prefetch the needed data into the cache. This feedback helps the fuzzer generate test code that is more likely to reveal interesting leakage cases with fewer fuzzing rounds. Interface with the Leakage Analyzer The Execution Model is used by the Leakage Analyzer to assist with identifying secret leakage. For example the execution model captures the secret values that need to be looked up in the RTL execution log. If a secret value is found the model assists with tracing that value back to the source instruction. The execution model state for a fuzzing round is stored as a series of snapshots of the microarchitectural state of the system after each instruction EM EM N in Figure . The more relevant snapshots are tagged with special labels for easier identification. For instance the execution model uses permission change labels P to tag instructions that follow permission changes to user pages. The Leakage Analyzer generates permission change snapshots EM P EM P M to determine the sections of the RTL execution log during which illegal accesses may cross isolation boundaries and the log should be monitored for secret leakage. Fig. Generating a fuzzing round from multiple gadgets. requirements of the gadget are checked against it. Note that the gadget s requirements could be satisfied by the execution of other earlier gadgets in the test code. If the check fails the fuzzer chooses helper/setup gadgets designed to satisfy the missing requirements H and H . The execution model is augmented to include the new gadgets. The process is repeated N times and a new randomly chosen main gadget is added to the code sequence in each iteration. The idea behind including multiple main gadgets in the same code sequence in random order is to increase the entropy of the fuzzing code by creating complex interactions between gadgets. The value of N controls the number main gadgets and therefore the complexity of each fuzzing round. VI. THE LEAKAGE ANALYZER Each fuzzing round is executed on an RTL simulator augmented to generate a detailed cycle level execution log that includes the state of all architectural and microarchitectural storage structures. A Leakage Analyzer module is used to parse the RTL log to identify potential leakage. In addition to the RTL log the Leakage Analyzer also uses the execution model corresponding to the same fuzzing round. The analysis process consists of three main steps. The first step is to analyze the list of EM snapshots to establish timelines during which values can be considered secrets. This helps exclude legal accesses as well as priming code in which secret values are being set up. The second step is to parse the RTL simulation log to extract all the cycles in which the processor ran in user mode. Finally the relevant sections of the execution log are searched for all secret values specified in the execution model. An Investigator module parses the execution model to identify secret values that were generated by the fuzzer as well as establish liveness timelines during which the presence of these values in the RTL log can be considered potential D. Test Code Generation The INTROSPECTRE fuzzer generates randomized test code sequences that can be executed on an RTL representation of a processor. The code generation process is illustrated in Figure . In the first step the fuzzer randomly chooses one of the main gadgets M . The main gadgets include a specification of the microarchitectural state expected by the gadget if any. An execution model is generated for gadget M and the PagePermission Pair EM PermissionChange Snapshots Label Secret Pair PC Secret Pair EM P x “daguxwrv Label Secret { } PC Secret { } EM P x “dagux v x “daguxwrv Label Secret {xaa} PC Secret {xaa} EM P x “da uxwrv x “ a uxwr Label Secret {xaa xaa} PC Secret {xaa xaa} EM P x “dagux v x “ a uxwr Label Secret {xaa} PC Secret {xaa} Secrets xaa xaa xaa Instruction Log RTL Sim Log Cycle ROB InstrX InstY InstZ Issue Unit RF Val Val Val TLB Mode U S M xaa —► Parser \ Inst Type PC Fetched Cycle Decoded Cycle Issued Cycle Exe Started Cycle Mem Access Cycle Committed Cycle ... Inst Type PC Fetched Cycle Decoded Cycle Issued Cycle Exe Started Cycle Mem Access Cycle Committed Cycle ... Filtered Execution Log Cycle Cycle Cycle ROB InstrX InstY InstZ LFB WB RF Val Val Val ST/LD Queue TLB Mode U LFB RF Val Val Val TLB Mode U S M WB RF Val Val Val ST/LD Queue TLB Mode U Instruction Sequence Fig. The Parser module processes the main RTL log in preparation Fig. The Investigator module identifies secrets and their liveness for the leakage analysis. in each fuzzing round. leakage. The Investigator examines the mapped pages dictionary in each permission change snapshot. This dictionary records the addresses of mapped user pages along with their permission bits. The investigator extracts these mappings from each EM snapshot as shown in Figure and creates a keyvalue pair for each EM permission change snapshot. The key is the permission change label used by the fuzzer to track a permission change event in the log. The value is the list of secrets that will be live in the next section of the log. The list of secrets associated with each permission change label is inferred from the permission bits of mapped user pages and the secret values stored in those pages. For example in Figure we show that after Label the user permissions of page x changes from xwrv to x v which means the user loses read/write permissions. The Investigator adds all secret data values xaa stored in page x to the secret list for the section of the log spanning from Label to Label . A permissions change to page x similarly adds a secret from that page xaa after Label . Finally the Investigator maps the labels to program counter PC values in the test sequence binary to generate PC Secret pairs. Note that the secret timeline is only needed for values residing in user pages. Supervisor/machine memory values are considered secrets throughout the entire fuzzing round execution while in user mode. A Parser module processes the raw RTL simulation log which includes the content of all the microarchitectural structures at cycle granularity. The Parser generates two separate files as shown in Figure The Filtered Execution Log is simply a pruned version of the main RTL log which excludes the machine/supervisor mode execution. The Instruction Log is a timing record for each dynamic instruction executed in the fuzzing round. It includes the cycle number in which each instruction is fetched decoded issued etc. This information helps the Leakage Analyzer track instructions responsible for potential leakage. A Scanner module uses the annotated execution model to search the Filtered Execution Log for leakage as illustrated I User Secrets Instruction Log PC Secret Pair Inst P PC Secret { } PC Secret {xaa} PC Secret {xaa xaa} Ip C Secret {xaa}l S/M Secrets x Type PC Fetched Cycle x Decoded Cycle Renamed Cycle Issued Cycle Exe Started Cycle Mem Access Cycle Committed Cycle x x x Scanner Filtered Exe Log User Secret Found Cycle N ■ LFB WB RF Val Val Val ST/LD Queue TLB Mode U Cycle M LFB WB RF Val Val Val ST/LD Queue TLB Mode U • S/M Secret Found S Supervisor M Machine Fig. The Scanner module searches the RTL log for secrets identified and tagged by the Investigator. in Figure . The list of PC Secret pairs is used to identify the sections of the execution log to scan for each secret value. For each user space secret value only the sections of the log executed while the value was secret are scanned. For supervisor/machine values the entire log is searched since those values should always be inaccessible from user space. If a secret value is found in a microarchitectural structure the Leakage Analyzer traces that value back to the producing instruction and flags it as potential leakage. The list of potential leakage sources and the microarchitectural units where leakage was observed are included in the INTROSPECTRE report. VII. IMPLEMENTATION AND EVALUATION METHODOLOGY We evaluate INTROSPECTRE on a system on chip design generated through the Chipyard framework . Chipyard includes Chisel a high level hardware generation language as well as a compiler and toolchain to translate Chisel designs into the FIRRTL intermediate representation which is then elaborated into Verilog. Particularly of interest to INTROSPECTRE is the printf synthesis feature in Chisel. Components defined at higher levels of abstraction can have their state logged where these statements are automatically carried along through elaboration. This allows for microarchitectural state tracing at cycle granularity. We implement INTROSPECTRE on top of Verilator an opensource RTL simulator which converts Verilog code to a cycleaccurate behavioral model in C or SystemC. We use the RISC V BOOM Berkeley Out of Order Machine v.. as a target for transient leakage analysis. Detailed configuration parameters for the BOOM SoC are included in Table II. Core Configuration Parameter Value Core Fetch/Decode Width ROB Entries Int Physical Regs FP Physical Regs LDq/STq Entries Max Branch Count Fetch Buffer Entries Branch Predictor L Data Cache L Inst. Cache Prefetching / Gshare HisLen numSets nSets nWays nMHSR nTLBEntries nSets nWays nMHSR fetchBytes Enabled Next Line Prefetcher tential information disclosure. We categorize results according to the nature of the potential leakage source or leakage scenario and present various case studies which surface these leakage scenarios. We describe each case study in terms of the isolation boundary bypassed conditions required to trigger the targeted speculation primitive and helper gadgets incorporated to satisfy said requirements. Table IV lists all the transient leakage cases and other isolation boundary violations identified by INTROSPECTRE. We categorize our findings across three classes R Type secret values in both physical register file PRF and line fill buffer LFB L Type secret values in LFB only and X Type miscellaneous control flow oriented. A. R Type Leakage Case Studies R type leakage scenarios include fuzzing rounds where sensitive data values can be found in both the physical register file and line fill buffer entries. We detail test cases assembled with INTROSPECTRE exhibiting these characteristics. R Supervisor only Bypass The R case study triggers lazy handling of a faulty load to bring supervisor data into the register file and/or LFB allowing user mode instructions to access supervisor owned data. R was found with INTROSPECTRE by combining the M main gadget and fulfilling its requirements with the assistance of the S setup gadget and the H helper gadget which fill supervisor pages with secrets and prefetch the secret data into the L data cache respectively. The behavior of R is reminiscent of the original Meltdown exploit. R User only Bypass The R case study is similar to R but the isolation boundary crossed is instead supervisorto user. Normally accessing a memory location mapped to a lower privilege while running in a higher privilege mode is not strictly illegal. However by clearing the access bits in the sstatus CSR RISC V configuration register with the S setup gadget the supervisor s access to user pages is no longer permitted. Here again similar to R despite raising a page fault exception the memory access is performed and data is brought into the RF or LFB. H and H helper gadgets are used to fill user pages with secrets and bring the user data into the cache. The M main gadget then accesses user mapped memory while in supervisor mode. R Machine only Bypass Describing the R case study necessitates an explanation of the physical memory protection mechanisms in RISC V and the Keystone trusted execution environment. Keystone is an open source framework for designing trusted execution environments TEE with secure hardware enclaves on RISC V systems. A Keystone system has a security monitor SM at its core which is trusted software that runs in the highest execution privilege in RISCV M and forms the trusted computing base TCB in a Keystone system. The security monitor is implemented on top of Berkeley Bootloader BBL and is responsible for isolating memory regions using RISC V physical memory protection. The security monitor is also in charge of managing secure hardware enclaves and remote attestation. TABLE II BOOM core configuration parameters. Test cases generated by INTROSPECTRE build on existing infrastructure in Chipyard for unit test creation used in verifying functional correctness of individual assembly instructions. This infrastructure riscv tests provides a testing environment enabling system support through a minimalist operating system kernel tasked with bootstrapping the processor setting up virtual memory and exception handlers. This efficient testing environment makes running many test rounds practical with execution times on the order of minutes. All tests are run on a machine equipped with an Intel Xeon E .GHz CPU GB of RAM running RHEL .. As shown in Figure INTROSPECTRE consists of three phases Gadget Fuzzer Instruction sequence generation EM snapshots binary compilation RTL Simulation Verilator simulator and Analyzer Investigator Parser and Scanner . Table shows the average wall clock time for each phase as well as total time for an average fuzzing round. In t r o Spe c t r e Module Execution Time Gadget Fuzzer RTL Simulation Analyzer Total .s .s .s .s TABLE Average wall clock execution time for one fuzzing round. The majority of test cases consider a threat model with user/supervisor privilege escalation/de escalation with respect to data accesses. However we also consider cases of machine privilege escalation specifically violating the security guarantees of the Keystone trusted execution environment. V . LEAKAGE CASE STUDIES In this section we discuss empirical findings of INTROSPECTRE which demonstrate its efficacy in discovering po Secret Leakage Instances in the BOOM processor Gadget Combination Guided Fuzzing R R R Supervisor only bypass User only bypass Machine only bypass R Reading from invalid user pages regardless of permission bits R Reading from user pages without read permission R Reading from user pages with access and dirty bits off R Reading from user pages with access bit off R Reading from user pages with dirty bit off S H H H H H MI H Hs HII S H H H H H M S H Hv H H H M H H H H S Mo MIO H H MS^m H H MIO M HO M H M H H H H S Mi H H M H M M H Mw H H H S MO M M H M H H H H H M H S M H MIO Mo W H H H S M M M H H M H S M H Mi M H H H S MM H H M M L Leaking page table entries through LFB L L X X Rnd Rnd Rnd Leaking secrets of a page without proper permissions in LFB by using prefetcher Leaking supervisor secrets after handling an exception through LFB H H H M H S M Hy H M H H M H S M H M H H H M H H H My M H S Mm H Mi H H H M H M H H M H M S H M H H M H S S M H H M M i H HH Mo Jump to an address and execute the stale value Speculatively execute supervisor code/inaccessible user code while in user mode H H H H Mv H H H H HO Mi Secret Leakage Instances in the BOOM processor Supervisor only bypass Secret only in LFB Supervisor only bypass Secret only in LFB Supervisor only bypass Secret only in LFB Gadget Combination Unguided Fuzzing H H M S M MO H MI M S H M H S H M H M H H MH H M M M S M M H S H H H H M H H Hy H H HO M M Mi TABLE IV Secret leakage scenarios and the gadget combinations that triggered them. The main gadget responsible for the leakage is highlighted in bold. The subscript number for each gadget represents the permutation ID. Memory only memory where the entire security monitor address range already meets this requirement. INTROSPECTRE primes the machine only memory by storing different secret values throughout the security monitor address range using the S setup gadget. According to Keystone security assumptions this region should not be accessible by processes in user or supervisor mode. However INTROSPECTRE was able to produce test cases showing machine mode secrets in the LFB PRF and write back buffer. Analyzing the test sequence we determined this was accomplished by the M main gadget executing in supervisor mode. M accessed security monitor memory protected by RISC V PMP which raised a Load Access Fault exception. However the memory request was not squashed and the secret value was eventually accessed finding its way through to the LFB if not cached or PRF if cached by the H helper gadget . Post simulation Analysis Fig. a Memory layout of security monitor enabled bootloader. b SM secrets show up in PRF and LFB in post simulation analysis. According to the RISC V Privileged ISA the RISC V physical memory protection PMP unit provides a set of CSRs to specify physical memory access privileges read write execute for each physical memory region. Using PMP control and status registers the security monitor divides the memory into two parts at boot time as illustrated in Figure . The first PMP entry CSR configured by the security monitor sets its own address range with all permissions turned off all bits set to . The last PMP entry CSR is configured to grant full permissions for the remainder of the memory space bits set to . This setup allows the OS access to all of memory with the exception of memory belonging to the security monitor. The test sequence responsible for leakage scenario R passes fuzzer selected instructions as the payload to the bootloader which is enhanced with a security monitor to be executed in supervisor mode. Enclave creation is not part of the test sequence because the goal is to bypass machine R R Leaking Inaccessible Data Case studies RR include scenarios where user pages are accessed by usermode processes but without proper access permissions. INTROSPECTRE first fills user pages with secret values using the H helper gadget and then changes the permission bits of those pages with the M main gadget. The permissions change requires higher privilege execution and the S setup gadget is used to accomplish this. Finally main gadgets such as M M and M are used to perform various loads to different pages with different permission bits in an effort to increase the odds of discovering potential leakage. The cause of leakage in this scenario is similar to R where the memory request is not canceled despite raising an exception. As a concrete example in the R case study secrets reside in an invalid user page and can be leaked through the LFB and PRF. Normally when the valid bit of a page is clear the page should not be accessible to any privilege level regardless of other permission bits in the PTE. However we have observed that contents of an invalid user page is leaked to the LFB and register file even though the access instruction raises a page fault exception. The same behavior can be found in case studies R R R and R where user pages have dirty bits cleared access bits cleared both access and dirty bits cleared or lack read permissions respectively. Accessing pages with the criteria outlined for case studies R R raises a page fault exception but the data is retrieved before the offending instructions are squashed. We have used the FuzzPermissionBits M main gadget to cover all possible combinations of user page permission bits. x xFF x x Accessible Page Inaccessible Page Virtual Address Fig. Illustration of accesses straddling two memory pages with different permissions. Supervisor Mode User Mode z Inst X Exception B. L Type Leakage Case Studies REGBYTES L type leakage scenarios include fuzzing rounds where secret values can be observed in line fill buffer entries but did not make their way through the register file. Note that the line fill buffer interfaces between caches and while not directly accessible by the user it has been shown to be vulnerable to side channel leakage . L Leaking PTE through LFB In the L case study INTROSPECTRE captured page table entries in the LFB while running in user mode. Page table entries are part of supervisor memory which should be protected from user mode instructions. On every TLB miss which may be added to the test sequence with the H helper gadget an internal cache request to the address of the root page table is performed to retrieve the correct mapping if available . If this cache request misses in the LD the LFB gets filled with the entire line of PTEs in the next few cycles. The prefetcher can also exacerbate this situation by prefetching the next line and bringing it to the LFB exposing additional PTEs. L Leaking from Prefetcher to LFB The L case study reveals that hardware prefetchers can introduce potential sources of leakage. Normally accessing page boundarystraddling addresses of a user page with proper permissions is legal. However if inaccessible user pages created by fuzzing page permission bits with main gadget M are located right after an accessible user page we may have secrets of the inaccessible page leaked into the LFB. This can be triggered by accessing the boundary straddling addresses of the accessible pages via torturous loads from the M main gadget. As a simple example shown in Figure if an access to address xFF misses in the LD the prefetcher will request the next address which falls within the boundary of the next inaccessible page. As a result secret values from page x will be brought into the LFB. L Exception Handler Leakage Case study L demonstrates possible leakage on exception handler exit. When an exception is raised while executing in user mode e.g executing H H helper gadgets execution privilege is changed to supervisor mode to handle this exception. Before executing the exception handler code the processor stores the values of general purpose registers in supervisor memory Trap Entry in Figure . After the handler has finished execution and Handler User Mode Frame Inst X Inst X Load GPRs STORE x REGBYTES sp LOAD STORE x REGBYTES sp LOAD x REGBYTES a STORE x REGBYTES sp LOAD x REGBYTES a STORE x REGBYTES sp LOAD x REGBYTES a STORE x REGBYTES sp LOAD x REGBYTES a x REGBYTES a Fig. Instructions executed to handle an exception. before changing the execution privilege back to user mode the processor reloads the previously stored register values from supervisor memory back to the registers Pop Trap Frame in Figure . INTROSPECTRE produced test cases in which some of these loads from supervisor memory miss in the cache. As a result the LFB gets filled with supervisor data residing in memory locations that fall in the same cache line as the stored register values. Figure illustrates such a scenario. While entries LFB contain the saved registers LFB and LFB contain supervisor data. In other words this secret data is brought into the LFB and remains there even after the execution privilege is reverted back to user mode. This effect is again amplified by the prefetcher which fetches the next line into the LFB bringing supervisor data to LFB . C. X Type Leakage Case Studies X type leakage scenarios exhibit speculative control flow hijacking and the influence of indirect branch targets. X Execute Stale PC In this case study INTROSPECTRE demonstrates that control logic can proceed with a stale PC value if there is an outstanding store request to the same address as the PC. This behavior was revealed by the M Parsed Log LCFyBcle M K WB ST/LD Queue LineBufferEntry LineBufferEntry LineBufferEntry LineBu fferEntry LineBu fferEntry LineBu fferEntry LineBu fferEntry LineBu fferEntry LineBu fferEntry LineBu fferEntry LineBufferEntry LineBufferEntry LineBufferEntry LineBufferEntry LineBufferEntry LineBufferEntry x x x x x x x x x x x x x x x x GP Registers J \ \ \ \ Supervisor Secrets LineBufferEntry LineBufferEntry LineBu fferEntry LineBu fferEntry LineBu fferEntry LineBu fferEntry LineBu fferEntry LineBu fferEntry LineBu fferEntry LineBu fferEntry LineBufferEntry LineBufferEntry LineBufferEntry LineBufferEntry LineBufferEntry LineBufferEntry x x x x x x x x x x x x x x x x Fig. In the L Exception Handler Leakage supervisor secrets end up in the LFB in cycle M. In cycle M K the prefetcher brings an entire cache line of supervisor data into the LFB. Main Gadgets Isolation Boundaries U S S U U U U/S M M M M M M / / / / / M / / / M M M / / / / / / / / M M M / / / / / / / / M M M / / / / / / Leakage Type Identified R L L R R R L R TABLE V Coverage of leakage across multiple isolation boundaries U ser S uperviser M achine types of leakage found and main gadgets used in the fuzzing rounds that revealed the leakage. Arrows represent the execution privilege of main gadget left and privilege level of accessed memory right . Time Fetched Fetched STORE Value Z jump User Addr X Resolved jump Fetched Value leakage scenarios for roughly the same number of fuzzing rounds with the INTROSPECTRE guided process. User Addr X E. Coverage Analysis and Discussion User Addr X y Resolved store Fetched Value Resolved Value y PC User Addr X Value Z « We examine the coverage of INTROSPECTRE along four dimensions Coverage of Microarchitectural Structures INTROSPECTRE can track all microarchitecturally accessible storage elements. In our implementation we record all structures that could possibly be a leakage source. From this perspective INTROSPECTRE can guarantee full coverage of all microarchitectural storage elements. Coverage of Isolation Boundaries We enumerate all possible combinations of isolation boundaries that could be vulnerable to Meltdown type attacks. Table V shows all possible accesses across isolation boundaries. We show the main gadgets that exercise those accesses and the instances in which possible leakage was identified. We can see that the INTROSPECTRE gadgets cover accesses across all possible isolation boundaries. Gadgets Coverage Gadgets implement kernels from known attacks speculation primitives memory access across isolation boundaries etc. As a proof of concept we implement a subset of the known Meltdown like attacks that are relevant to the BOOM architecture. This set can be expanded to more attacks other speculation primitives etc. The set of gadgets cannot be guaranteed to be complete as there are simply too many degrees of freedom. To increase the probability of discovering new attacks or new variants most gadgets are parametrized adding another dimension to the fuzzing space. In most cases these parameters can be enumerated to ensure complete coverage of each parameter value. The permutation metric in Table I shows the number of variants for each gadget class. Examples of gadget parameters include speculation primitives access instructions secret layouts access permissions etc. For example the STtoLD Forwarding M in Table I main gadget has variants permutations as illustrated in Figure . For M we choose between four types of Load instructions four types of Store instructions four memory access granularities and residency state in the LD and line fill buffer LFB . In summary INTROSPECTRE looks for leakage in all relevant storage elements supports accesses across all isolation boundaries and utilizes gadgets targeting all known Meltdownlike attacks enhanced with hyperparameters to increase coverage to new variants. User Addr X PC User Addr X PC User Addr X b Fig. a Required setup for Meltdown JP. b Timeline of instruction execution. main gadget. Figure shows a User Address X located in a user page with full permissions. This address is primed with the assistance of the H helper gadget but it is not present in the cache. Also the virtual to physical mapping for this user page is available in the ITLB but not in the DTLB. With this setup a jump instruction to User Address X that immediately follows a store to the same address would resolve faster than the store. As a result the PC is loaded with the stale Value Y and the control flow of the program is changed. Importantly the addresses of the jump and store are not disambiguated so no conflict is detected and no exception will be raised. X Illegal Speculative Control Flow The X case study executes supervisor code speculatively from user mode. The requirement for this test is to have the supervisor address in the instruction cache. By performing a jump to this S mode address the processor assigns an ROB entry for the instruction and raises an instruction page fault exception as soon as the instruction is added to the ROB. Although the instruction never executes and subsequent instructions are also not assigned resources it may still leak information about the instruction type in supervisor code. D. Guided and Unguided Fuzzing In order to demonstrate the importance of guided fuzzing we also examined INTROSPECTRE with the Execution Model removed. In this experiment we generate fuzzing rounds in which gadgets are randomly chosen from our pool of gadgets with randomly assigned configuration parameters. Each fuzzing round includes gadgets. We find that out the rounds rounds reveal the Supervisor only bypass leakage instance Rnd Rnd in Table IV however the leakage is only observed in the line fill buffer with the secret value not reaching the register file. Overall the random pick of gadgets is much less effective at identifying new leakage with leakage type out of runs compared to the distinct Different Load Instructions Different Store Instructions Degree of Overlap A. C. Aldaya B. B. Brumley S. ul Hassan C. Pereida García and N. Tuveri “Port contention for fun and profit ” in I Symposium on Security and Privacy SP pp. . A. Amid D. Biancolin A. Gonzalez D. Grubb S. Karandikar H. Liew A. Magyar H. Mao A. Ou N. Pemberton P. Rigge C. Schmidt J. Wright J. Zhao Y. S. Shao K. Asanovic and B. Nikolic “Chipyard Integrated design simulation and implementation framework for custom socs ” I Micro vol. no. pp. . ARM “Vulnerability of speculative processors to cache timing sidechannel mechanism ” https //developer.arm.com/support/securityupdate Online accessed May . K. Barber A. Bacha L. Zhou Y. Zhang and R. Teodorescu “SpecShield Shielding speculative data from microarchitectural covert channels ” in th International Conference on Parallel Architectures and Compilation Techniques PACT pp. . A. Bhattacharyya A. Sandulescu M. Neugschwandtner A. Sorniotti B. Falsafi M. Payer and A. Kurmus “SMoTherSpectre Exploiting speculative execution through port contention ” arXiv preprint arXiv . . J. V. Bulck M. Minkin O. Weisse D. Genkin B. Kasikci F. Piessens M. Silberstein T. F. Wenisch Y. Yarom and R. Strackx “Foreshadow Extracting the keys to the Intel SGX kingdom with transient out of order execution ” in th USENIX Security Symposium USENIX Security pp. . C. Canella D. Genkin L. Giner D. Gruss M. Lipp M. Minkin D. Moghimi F. Piessens M. Schwarz B. Sunar J. Van Bulck and Y. Yarom “Fallout Leaking data on Meltdown resistant CPUs ” in Proceedings of the ACM SIGSAC Conference on Computer and Communications Security CCS . ACM . C. Celio P. F. Chiu B. Nikolic D. A. Patterson and K. Asanovic “BOOM v An open source out of order RISC V core ” EECS Department University of California Berkeley Tech. Rep. UCB/EECS Sep . J. Demme R. Martin A. Waksman and S. Sethumadhavan “Sidechannel vulnerability factor a metric for measuring information leakage ” in Proceedings of the th Annual International Symposium on Computer Architecture ISCA vol. no. pp. . M. R. Fadiheh J. Muller R. Brinkmann S. Mitra D. Stoffel and W. Kunz “A formal approach for detecting vulnerabilities to transient execution attacks in out of order processors ” in th ACM/I Design Automation Conference DAC pp. . B. Gras C. Giuffrida M. Kurth H. Bos and K. Razavi “Absynthe Automatic blackbox side channel synthesis on commodity microarchitectures ” in Proceedings Network and Distributed System Security Symposium . D. Gruss M. Lipp M. Schwarz R. Fellner C. Maurice and S. Mangard “KASLR is dead long live KASLR ” in International Symposium on Engineering Secure Software and Systems. Springer pp. . M. Guarnieri B. Köpf J. F. Morales J. Reineke and A. Sánchez “Spectector Principled detection of speculative information flows ” in I Symposium on Security and Privacy pp. . F. Haedicke H. M. Le D. Grosse and R. Drechsler “Crave An advanced constrained random verification environment for SystemC ” in International Symposium on System on Chip SoC pp. . J. Horn “Speculative execution variant Speculative store bypass ” https //bugs.chromium.org/p/project zero/issues/detail id Online accessed May . Intel “Intel analysis of speculative execution side channels ” Intel https //newsroom.intel.com/wp content/uploads/sites////IntelAnalysis of Speculative Execution Side Channels.pdf Online accessed May . Intel “Speculative execution side channel mitigations ” Intel https //software.intel.com/security software guidance/apiapp/sites/default/files/ Speculative Execution Side ChannelMitigations.pdf Online accessed May . K. N. Khasawneh E. M. Koruyeh C. Song D. Evtyushkin D. Ponomarev and N. B. Abu Ghazaleh “SafeSpec Banishing the spectre of a meltdown with leakage free speculation ” in Proceedings of the th Annual Design Automation Conference . V. Kiriansky I. Lebedev S. Amarasinghe S. Devadas and J. Emer “DAWG a defense against cache timing attacks in speculative execution LFB LD LD SD Byte X LD X LFB LW SW Bytes X LD ^LFB LH SH Bytes ^LD XLFB LB SB Bytes ^LD yLFB Fig. Possible permutations for the M STtoLD Forwarding gadget. F. False Positives and False Negatives False negatives can be examined along two dimensions Will INTROSPECTRE always flag secret leakage revealed by the fuzzer The answer is yes. There are no false negatives if a secret leakage is triggered by the fuzzer and will INTROSPECTRE discover all known and unknown Meltdownlike attacks In terms of known Meltdown like attacks all relevant and applicable known attacks are covered. Also hyperparameters increase INTROSPECTRE coverage of potential new variants. However INTROSPECTRE cannot guarantee all Meltdown attacks will be discovered. False positives can similarly be examined along the following dimensions If INTROSPECTRE flags leakage in a structure is it guaranteed to be a violation of an isolation boundary The answer is yes. There are no false positives for isolation boundary violations. Are all INTROSPECTREidentified leakage cases exploitable The answer is no because this depends on whether a covert channel can be open to leak that secret. Additional expert analysis will be required to ascertain if the leakage is exploitable. INTROSPECTRE will therefore have false positives for exploitable attacks. IX. CONCLUSION This paper presented INTROSPECTRE a design verification framework for identifying transient execution leakage. We show that integrating INTROSPECTRE into the RTL design flow enables a systematic analysis of the entire microarchitectural state of complex processor designs. We integrated INTROSPECTRE with an RTL simulator and used it to perform transient leakage analysis on the open source RISC V BOOM processor. We identified potential transient leakage scenarios most of which had not been highlighted on this processor design before. 