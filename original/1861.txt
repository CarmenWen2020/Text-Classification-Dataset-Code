Abstract‚ÄîCompiling high-level quantum programs to machines that are size constrained (i.e. limited number of quantum
bits) and time constrained (i.e. limited number of quantum
operations) is challenging. In this paper, we present SQUARE
(Strategic QUantum Ancilla REuse), a compilation infrastructure
that tackles allocation and reclamation of scratch qubits (called
ancilla) in modular quantum programs. At its core, SQUARE
strategically performs uncomputation to create opportunities for
qubit reuse.
Current Noisy Intermediate-Scale Quantum (NISQ) computers
and forward-looking Fault-Tolerant (FT) quantum computers
have fundamentally different constraints such as data locality, instruction parallelism, and communication overhead. Our
heuristic-based ancilla-reuse algorithm balances these considerations and fits computations into resource-constrained NISQ or
FT quantum machines, throttling parallelism when necessary.
To precisely capture the workload of a program, we propose
an improved metric, the ‚Äúactive quantum volume,‚Äù and use this
metric to evaluate the effectiveness of our algorithm. Our results
show that SQUARE improves the average success rate of NISQ
applications
by 1.47X. Surprisingly, the additional gates for uncomputation
create ancilla with better locality, and result in substantially fewer
swap gates and less gate noise overall. SQUARE also achieves an
average reduction of 1.5X (and up to 9.6X) in active quantum
volume for FT machines.
Index Terms‚Äîquantum computing, compiler optimization, reversible logic synthesis
I. INTRODUCTION
Thanks to recent rapid advances in physical implementation
technologies, quantum computing (QC) is seeing an exciting
surge of hardware prototypes from both academia and industry [1]‚Äì[4]. This phase of QC development is commonly
referred as the Noisy Intermediate-Scale Quantum (NISQ)
era [5]. Current quantum computers are able to perform on
the order of hundreds of quantum operations (gates) using
tens to hundreds of quantum bits (qubits). While modest in
scale, these NISQ machines are large and reliable enough to
perform some computational tasks. Looking beyond the NISQ
era, quantum computers will ultimately arrive at the FaultTolerant (FT) era [6], [7], where quantum error correction is
Corresponding author: yongshan@uchicago.edu
implemented to ensure operation fidelity is met for arbitrarily
large computations.
One major challenge, however, facing the QC community, is
the substantial resource gap between what quantum computer
hardware can offer and what quantum algorithms (for classically intractable problems) typically require. Space and time
resources in a quantum computer are extremely constrained.
Space is constrained in the sense that there will be a limited
number of qubits available, often further complicated by poor
connectivity between qubits. Time is also constrained because
qubits suffer from decoherence noise and gate noise. Too
many successive operations on qubits results in lower program
success rates.
Due to space and time constraints, it is critical to find efficient ways to compile large programs into programs (circuits)
that minimize the number of qubits and sequential operations
(circuit depth). Several options have been proposed [8]‚Äì[14].
Among the options, one approach not yet well studied is to
coordinate allocation and reclamation of qubits for optimal
reuse and load balancing [15]. Reclaiming qubits, however,
comes with a substantial operational cost. In particular, to
obey the rules of quantum computation, before recycling a
used qubit, additional gate operations need to be applied to
‚Äúundo‚Äù part of its computation.
In this paper, we propose the first automated compilation framework for such strategic quantum ancilla reuse
(SQUARE) in modular quantum programs that could be readily applied to both NISQ and FT machines. SQUARE is a
compiler that automatically determines places in a program to
perform such uncomputation in order to manage the trade-offs
in qubit savings and gate costs and to optimize for the overall
resource consumption.
Optimally choosing reclamation points in a program is
crucial in minimizing resource consumption. This is because
reclaiming too often can result in significant time cost (due to
more gates dedicated to uncomputation). Likewise, reclaiming
too seldom may require too many qubits (e.g. fail to fit the
program in the machine). For example, Figure 1 shows how
qubit usage changes over time for the modular exponentia570
2020 ACM/IEEE 47th Annual International Symposium on Computer Architecture (ISCA)
978-1-7281-4661-4/20/$31.00 ¬©2020 IEEE
DOI 10.1109/ISCA45697.2020.00054
tion step in Shor‚Äôs algorithm [16]. Unfortunately, finding the
optimal points in a program for reclaiming qubit could get
extremely complex [17], [18]. An efficient qubit reuse strategy
will play a pivotal role in enabling the execution of programs
on resource-constrained machines.
To precisely estimate the workload of a computational
task, we propose a resource metric called ‚Äúactive quantum
volume‚Äù (AQV) that evaluates the ‚Äúliveness‚Äù of qubit during
the lifetime of the program, which we will formally introduce
in Section III-B. This is inspired by the concept of ‚Äúquantum
volume‚Äù introduced by IBM [19], a common measure for
the computational capability of a quantum hardware device,
based on parameters such as number of qubits, number of
gates, and error probability. AQV is a metric that measures the
volume of resource required by a program when executing on a
target hardware, which can therefore serve as an minimization
objective for the allocation and reclamation strategies.
The contributions of our work are:
‚Ä¢ We present a heuristic-based compilation framework,
called SQUARE, for optimizing qubit allocation and
reclamation in modular reversible programs. It leverages
the knowledge of qubit locality as well as program
modularity and parallelism.
‚Ä¢ We introduce a resource metric, active quantum volume
(AQV), that calculates the ‚Äúliveness‚Äù of qubits over the
lifetime of a program. This new metric allows us to quantify the effectiveness of various optimization strategies, as
well as to characterize the volume of resources consumed
by different computational tasks.
‚Ä¢ Our approach fits computations into resource-constrained
NISQ machines by strategically reusing qubits. Surprisingly, adding gates for uncomputation can improve the
fidelity of a program rather than impair it, as it creates
ancilla with better locality, leading to substantially fewer
swap gates and thus less gate noise. SQUARE improves
the success rate of NISQ applications by 1.47X on
average.
‚Ä¢ Our approach has broad applicability from NISQ to FT
machines. SQUARE achieves an average reduction of
1.5X (and up to 9.6X) in active quantum volume for FT
systems.
The rest of the paper is organized as follows: Section II
briefly discusses the basics of quantum computation and compilation of reversible arithmetic to quantum circuits, as well
as related work in both classical and quantum compilation.
Section III illustrate the central problem of allocation and
reclamation of ancilla tackled in this paper and the general idea
of our solution. Section IV describes in detail the techniques
that make up our proposed algorithm. Section V evaluates
the performance of the algorithm on an array of benchmarks
under the NISQ and FT architectures. Finally, Section VI summarizes and then highlights challenges awaiting satisfactory
solutions.
 	
 

  
 
 
            





	


Max qubits of machine
Coherence time of qubits
Too many gates
Too many qubits

Fig. 1: Qubit usage over time for Modular Exponentiation. The
shaded area under the curve corresponds to the active quantum
volume of this application. The blue curve, representing a
balance between qubit reclamation and uncomputation, has the
lowest area and is the best option.
II. BACKGROUND AND RELATED WORK
A. Basics of Quantum Computing
Quantum computers are devices that harness quantum mechanics to store and process information. For this paper, we
highlight three of the basic rules derived from the principles
of quantum mechanics:
‚Ä¢ Superposition rule: A quantum bit (qubit) can be in a
quantum state of a linear combination of 0 and 1: |œà =
Œ± |0 + Œ≤ |1, where Œ± and Œ≤ are complex amplitudes
satisfying |Œ±|
2 + |Œ≤|
2 = 1.
‚Ä¢ Transformation rule: Computation on qubits is accomplished by applying a unitary quantum logic gate that
maps from one quantum state to another. This process is
reversible and deterministic.
‚Ä¢ Measurement rule: Measurement or readout of a qubit
|œà = Œ± |0 + Œ≤ |1 collapses the quantum state to
classical outcomes: |œà
 = |0 with probability |Œ±|
2 and
|œà
 = |1 with probability |Œ≤|
2. This is irreversible and
probabilistic.
1) Reversibility constraints.: The above three rules give
rise to the potential computing power that quantum computers
possess, but at the same time, they impose strict constraints
on what we can do in quantum computation. For example,
the transformation rule implies that any quantum logic gate
we apply to a qubit has to be reversible. The classical AND
gate in Figure 2 is not reversible because we cannot recover
the two input bits based solely on one output bit. To make it
reversible, we could introduce a scratch bit, called ancilla, to
store the result out-of-place, as in controlled-controlled-NOT
gate (or Toffoli gate) in Figure 2. Note that we use the
terminology ‚Äúancilla‚Äù in its most general sense‚Äìit is not limited
to error correction ancilla, but rather, any (physical or logical)
qubits used as scratch space for computation. As the arithmetic
complexity scales up when tackling difficult computational
problems, we quickly see extensive usage of ancilla bits in
our circuits due to this reversibility constraint.
571                           









AND gate Toffoli gate
Fig. 2: Circuit diagram for the irreversible AND gate and the
reversible Toffoli gate.
B. Synthesizing Reversible Arithmetic
For small arithmetic logic, algorithms exist to directly
synthesize reversible circuits from the truth-table of the desired
function [20]‚Äì[22] and with templates [23]. This typically
works well for small low-level combinational functions, but
not for functions with internal states [24]. As the complexity
of the arithmetic in an algorithm scales up, modularity quickly
becomes convenient, and in many cases necessary. That is, to
construct high-level arithmetic, we need to build up from small
modular subroutines.
In reversible logic synthesis and optimization, besides making our circuit for the reversible function contain as few gates
as possible, we would also like to minimize the amount of
scratch memory (i.e. number of ancilla bits) used in the circuit.
Fortunately, there is a way to recycle ancilla bits for later reuse.
For a circuit that makes extensive use of scratch memory,
managing the allocation and reclamation of the ancilla bits
becomes critical to producing an efficient implementation of
the function.
1) Role of reversible arithmetic in quantum algorithms.:
Reversible arithmetic plays a pivotal role in many known
quantum algorithms. The advantage of quantum algorithms
is thought to stem from their ability to pass a superposition of inputs into a classical function at once, whereas a
classical algorithm can only evaluate the function on single
input at a time. Many quantum algorithms involve computing
classical functions, which must be embedded in the form of
reversible arithmetic subroutines in quantum circuits. For example, Shor‚Äôs factoring algorithm [16] uses classical modularexponentiation arithmetic, Grover‚Äôs searching algorithm [25]
also implements its underlying search problem as an oracle
subroutine, and the HHL algorithm for solving linear system of equations contains an expensive reciprocal step [26].
These reversible arithmetic subroutines are typically the most
resource-demanding computational components of the entire
quantum circuit.
C. Compiling Quantum Circuits to Target Architecture
As discussed above, there are several options for obtaining
a synthesized classical reversible circuit. The next step is
to compile it down to a sequence of instructions that a
quantum machine recognizes and natively supports, that is to
resolve architectural constraints. This means considering the
following two aspects:
1) Instruction set. There are certain quantum logic gates that
are supported in a given device architecture. In most cases,
this gate set is ‚ÄúClifford+T‚Äù gates, comprised of the CNOT
gate, NOT gate (or X gate), Hadamard gate (or H gate) and
T gate. This is a common set for most of today‚Äôs gate-based
quantum hardware prototypes, as well as for large-scale faulttolerant machines (e.g. with surface code error correction).
Given a classical reversible circuit, we can replace each gate
with its quantum counter-part. In particular, NOT gates and
CNOT gates can be directly implemented as quantum gates.
For Toffoli gates, algorithms exist that decompose them
into a sequence of Clifford+T gates [27]‚Äì[31]. At lower level,
some instruction sets are proposed to offer direct control over
the target hardware [32].
2) Qubit communication. Multi-qubit quantum gates are implemented by interacting the operand qubits with one another.
At the physical level, building large-scale quantum machines
with all-to-all qubit connectivity is shown to be extremely
challenging. The latest effort from IonQ [33] offers a machine
with 11 fully-connected qubits using trapped-ion technology.
Superconducting machines, for instance those by IBM [3]
and Rigetti [34], typically have much lower connectivity. Any
scalable proposal would involve an architecture of limited
qubit connectivity and a model for resolving long-distance
interactions. As a consequence, interacting qubits that are not
directly connected would induce communication costs.
1) Difference between NISQ and FT machines.: Depending
on the topology of the architecture and the model for resolving
two-qubit interactions, communication costs will differ. In the
context of a NISQ machine, the most frequently used approach
to resolve a long-distance two-qubit gate is through swaps,
where two (physical) qubits are moved closer by performing
a chain of swap gates that connects them. Each SWAP gate
consists of three CNOT gates. The time to complete a swap
chain is proportional to the length of the chain. In a FT
machine, a logical qubit is encoded by a number of physical
qubits. A logical operation is specified by a sequence of
physical operations on its physical qubits. For instance, for
surface code implementation, physical qubits form a 2D grid
with every data qubit connected to its four nearest neighbors
through stabilizer ancillas. In essence, a logical operation is
defined by specifying how the stabilizer ancillas interact with
the data qubits. In particular, a logical two-qubit gate can be
defined by braiding1 which creates a path between logical
qubits, where the stabilzer ancillas along the path do not
interact with their neighbors [37], [38]. Although it can extend
to arbitrary length and shape in constant time, two braids are
not allowed to cross. We refer interested readers to [7], [39]
for excellent tutorial.
Although our proposed SQUARE approach is designed
to optimize for compiling large quantum algorithms onto
medium- to large-scale systems with hundreds or thousands
of qubits, we demonstrate that NISQ machines can benefit
1The focus of this study is on braiding, but other schemes such as lattice
surgery [35], [36] exists for resolving two-qubit interactions on surface code,
which may expose different communication tradeoffs.
572       
from SQUARE optimizations significantly as well. As such,
Section V will include experiments that sweep a large range
of system sizes (from tens to thousands of qubits), assuming
architectures with their appropriate communication models
(e.g. swaps and braiding). The one key difference between
swaps and braids is that the time to complete a swap chain
is proportional to the length of swap, whereas the time to
complete a braid is proportional to the number of crossings
with other braids.
D. Reclaiming Ancilla Qubits via Uncomputation
Reclaiming qubits is the process of returning them to their
original |0 state for future reuse. Due to entanglement, this
process could be costly; ancilla qubits that are entangled with
data qubits will alter the data qubits‚Äô state if they are reset or
measured. Fortunately, uncomputation, introduced by Bennett
[40], is the process for undoing a computation in order to
remove the entanglement relationship between ancilla qubits
and data qubits from previous computations. Figure 3 (left
pane) illustrates this process. In that circuit diagram, the Uf
box denotes the circuit that computes a classical function f.
The garbage produced at the end of Uf is cleaned up by storing
the output elsewhere and then undoing the computation.
This uncomputation approach has two potential limitations:
firstly, if uncomputation is not done appropriately, we need to
pay for the additional gate cost, and secondly, it only works
if the circuit Uf implements classical reversible logic - i.e.
can be implemented with Toffoli gate alone, optionally
with NOT gate and CNOT gate. Quantum algorithms contain
non-classical gates such as Hadamard gate, phase gate and T
gate; this work focuses on the part in quantum algorithms that
computes classical functions (usually arithmetics) which can
be implemented without those gates. As discussed in Section
II-B1, classical reversible logic plays a large part of most
quantum algorithms.
Related work on optimization of qubit allocation and reclamation in reversible programs dates back to as early as [17],
[41], where they propose to reduce qubit cost via fine-grained
uncomputation at the expense of increasing time. Since then,
more [18], [42]‚Äì[44] have followed in characterizing the
complexity of reclamation for programs with complex modular
structures. Recent work in [24], [45] show that knowing
the structure of the operations in Uf can also help identify
bits that may be eligible for cleanup early. A more recent
example [46] improves the reclamation strategy for straightline programs using a SAT-based algorithm. Some of the above
work emphasizes on identifying reclamation opportunities in
a flat program, whereas our focus is on coordinating multiple
reclamation points in a larger modular program.
E. Reclaiming Qubits via Measurement and Reset
If ancilla qubits have already been disentangled from the
data qubits, we can directly reclaim them by performing a
measurement and reset. We can save the number of qubits, by
moving measurements to as early as possible in the program,
so early that we can reuse the same qubits after measurement
for other computation. Prior art [47], [48] has extensively
studied this problem and proposed algorithms for discovering
such opportunities.
This measurement-and-reset (M&R) approach also has limitations: firstly, a near-term challenge for NISQ hardware is
to support fast qubit reset. Without it, reusing qubits after
measurement could be costly or, in many cases, unfeasible.
The state-of-the-art technique for resetting a qubit on a NISQ
architecture is by waiting long enough for qubit decoherence
to happen naturally, typically on the order of milliseconds for
superconducting machines [3], significantly longer than the
average gate time around several nanoseconds. FT architectures have much lower (logical) measurement overhead (that
is roughly the same as that of a single gate operation), and
thus are more amenable to the M&R approach. Secondly, qubit
rewiring as introduced in [48] works only if measurements can
be done early in a program, which may be rare in quantum
algorithms ‚Äì measurements are absent in many program (such
as arithmetic subroutines) or only present somewhere deep in
the circuit. M&R of a qubit is allowed only after all entangled
results are no longer needed, whereas uncomputation can
be done partially for any subcircuit. As such, unlike the
uncomputation approach, M&R does not actively create qubit
reuse opportunities.
F. Related Work in Classical Compilation
Some similarities can be seen in register allocation in classical computing. In that setting, we assign program variables
to a limited number of registers in the CPU for fast access.
Variables that are not stored in register may be moved to and
from RAM, as a process called ‚Äúregister spilling‚Äù. The analysis
of live variable and register reuse can be very similar to
that of qubits. For instance, our heuristic-based methodology
is inspired by register allocation in GPU/distributed systems
where communication cost needs to be minimized, and by the
technique ‚Äúrematerialization‚Äù that reduces the register pressure
(i.e. number of registers in use at any point in time) by
recomputing some variables instead of storing them to memory. But the trade-offs in qubit allocation and reclamation are
unique, which we will introduce as ‚Äúrecursive recomputation‚Äù
and ‚Äúqubit reservation‚Äù in Section III-C. Finding the optimal
strategy for register allocation, and similarly for qubit reuse,
is known to be a hard problem [42], [49]. Luckily, we are
able to transfer some general insights from the rich history of
classical register allocation optimization to solve the problems
in qubit allocation and reclamation.
The connection made between qubit reuse and classical
register allocation [50]‚Äì[52] allows us to inherit some of the
intuitions from a wealth of classical literature. Nonetheless,
the uncomputation/reuse/locality trade-offs we face are fairly
unique. Indeed, rematerialization [53] is very much like qubit
reclamation, in that they both aim to lower active registers/qubits at the expense of computation, yet it does not exhibit
the same exponential recomputation cost, nor is the increase
in the live-range of variables from the recomputing step the
same as qubit reservation caused by not uncomputing. We
573 




 

  




 



 
 	

 
 

 
 	


!" !"
 
 

 












&!$" #(&
'!$" $(%
Fig. 3: (a) Ancilla qubit reclamation via uncomputation. Each horizontal line is a qubit. Each solid box contains reversible
gates. Qubits are highlighted red for the duration of being garbage. (b) Illustration for Eager and Lazy strategies with their
respective issues ‚Äì recursive recomputation and qubit reservation. Each dashed box denotes a function call containing the
enclosed gates. The allocation and reclamation points have been marked as blue circles in the circuit.
also gained general insights from numerous techniques in code
scheduling [54], [55], and thread-level parallelism [56].
III. KEY IDEA AND MOTIVATION
This paper focuses primarily on reusing qubits via uncomputation, and discusses the significance of our proposed
strategy in current noisy intermediate-scale quantum (NISQ)
and future fault-tolerant (FT) architectures. Prior work such as
[24] follows two basic strategies: ‚ÄúEager‚Äù cleanup and ‚ÄúLazy‚Äù
cleanup, as illustrated in Figure 3.
Baseline 1 ‚ÄúEager‚Äù: Recursive Recomputation. Eager reclaims qubits at the end of every function. In the example of
Figure 3, Eager performs uncomputation at the end of both Uf
and Ug. When reclaiming ancilla qubits in such programs with
nested functions, the uncompute step of the caller would have
to repeat everything inside of its callee, including the callee‚Äôs
uncompute step. This hierarchical structure will consequently
lead to re-computation of the callees, as marked in Figure 3.
More formally, for a hierarchical program with  levels, in
the worst case, recomputation causes the number of steps to
increase by a factor of 2. We call this exponential blowup
phenomenon ‚Äúrecursive recomputation‚Äù. That is why the 2-
level program in Figure 3 has roughly 4 times more steps as
the original circuit. This factor will play a crucial role in our
heuristic design.
Baseline 2 ‚ÄúLazy‚Äù: Qubit Reservation. Lazy reclaims qubits
only at the top-level function. In Figure 3, this means only Ug
is uncomputed, but not Uf . Lazy can sometimes be a preferred
strategy because it avoids the wasted recomputation2. In other
words, it is sometimes beneficial to temporarily leave the
garbage of callees, and uncompute the garbage by their callers.
This is equivalent to inlining the callee into the caller, and
letting the caller handle the reclamation of all ancilla qubits.
However, with the benefit of the avoided recomputation comes
2There are exceptions, such as recursive Fourier sampling, where recomputation cannot be avoided and is required for correctness [57].
the cost of ‚Äúqubit reservation‚Äù. The ancilla qubits from callee
are reserved or blocked out from any reuse until the end of
the caller. This can be seen at the bottom right of the example
in Figure 3. The garbage qubit from Uf stays as garbage until
almost the end of U ‚àí1 g , whereas in the Eager case, it is cleaned
up right away.
A. Overview of SQUARE Algorithm
Most existing qubit reuse algorithms [17], [24], [41] emphasize on the asymptotic qubit savings, and commonly
make an ideal assumption that machines have all-to-all qubit
connectivity (i.e. no locality constraint). Since all qubits are
considered identical, a straightforward way to keep track of
qubits is to maintain a global pool, sometimes referred to as
the ancilla heap. Ancilla qubits are pushed to the heap when
they are reclaimed, and popped off when they are allocated,
for instance in a last-in-first-out (LIFO) manner. In this ideal
model, we can simply track qubit usage by counting the
total number of fresh qubits ever allocated during the lifetime
of a program. However, leading proposals of NISQ and FT
quantum architectures have far stricter locality constraints.
Our Strategic QUantum Ancilla REuse (SQUARE) algorithm is highly motivated by the lesson that communication
can be a determinant factor for qubit allocation and reclamation. Take the NISQ architecture as an example. We make
the following two novel observations. Firstly, same algorithm
needs different strategies for different machine connectivity.
In Figure 5, a benchmark named Belle (whose details can
be found in Section V-A) prefers Eager strategy on a 2-
D lattice topology (with swaps), but Lazy strategy on a
fully-connected topology (without swaps). Secondly, and most
counter-intuitively, adding uncomputation gates can improve
overall circuit fidelity, if done properly. With careful allocation
and reclamation, the expense of additional uncomputation
gates is compensated by the reduction of communication cost.
This is because uncomputation allows us to create ancilla with
574                    
"
%"%
" #%
)%&',
"!&'%!'&
%''(%
"!&'%!'&
1	"%2
!#
! - 

"',0*%
"'"!
(%&'
"&'0')
% '"!
(%&'
'(%
&")"!!')',
&")'#!!,
	!'" #'"!
'" #"&'"!

""#(!%"!
(!'"!"!!


	
+('
	!&'%( !''"!
/
'"!
%"&&!
&")&,!'+
'%# !'
	
6.$6
6.$7
6.$8
7.$6$7
8.$7$8
/
'.$9$:
1			0072 1			0082
1			03	02
1			02
1	02
Fig. 4: Our Strategic Quantum Ancilla Reuse (SQUARE) compilation flow. SQUARE takes as input a Scaffold [58] program
(see sample code in Figure 6) and produces an executable that simulates the dynamics of qubit allocation/reclamation and gate
scheduling, which can then prints out an optimized schedule of quantum gate instructions.
Fig. 5: Locality constraint changes the desired reclamation
strategy. Results are based on a synthetic benchmark ‚ÄúBelle‚Äù.
Lower active quantum volume (defined in Section III-B) is
better. Belle performs better on a lattice machine with Eager
strategy, while preferring Lazy when operating on a fullyconnected machine.
better locality, resulting in fewer swap gates and less overall
gate noise.
Now we discuss how SQUARE finds the strategies for
allocation and reclamation.
1) Locality-Aware Allocation (LAA).: We present the
Locality-Aware Allocation (LAA) heuristic in the SQUARE
algorithm that prioritizes qubits according to their locations
in the machine. At a high level, LAA chooses qubits from
the ancilla heap by balancing three main considerations ‚Äì
communication, serialization, and area expansion.
When deciding which qubits to allocate and reuse, our
heuristic-based algorithm assigns priorities to all qubits. The
priorities are weighted not only by the communication overhead of two-qubit interactions but also by their potential
impact to the parallelism of the program. Reusing qubits adds
data dependencies to a program and thus serializes computation (which is similar to how reusing register names could lead
to false data dependencies and serialization), but not reusing
qubits expands the area of active qubits and thus increases the
communication overhead between them. Recall from Section
II-C1, communication have different tradeoffs under NISQ and
FT architectures. We will make this distinction in terms of our
heuristics clearer in Section IV-C.
2) Cost-Effective Reclamation (CER).: The Cost-Effective
Reclamation (CER) heuristic makes uncomputation decisions
with a simple cost-benefit analysis: at each potential reclamation point, we estimate and compare two quantities:
‚Ä¢ C1: cost of uncomputation and reclaiming ancilla qubits;
‚Ä¢ C0: cost of no uncomputation and leaving garbage qubits.
CER balances the cost of recursive recomputation and qubit
reservation as discussed in Section II-D. To do so, we need an
efficient way to accurately estimate the C1 and C0 quantities.
In particular, the decision of child function affects not only
the cost of itself, but also the cost of parent function. If a child
function decides to uncompute, the additional gate costs need
to be duplicated should its parent decide to uncompute as well.
This was illustrated in Section III-C as the phenomenon we
called ‚Äúrecomputation‚Äù. Thus, we should take the level of the
function into account when we make the decision. The total
cost of a uncomputation, C1, can be expressed as:
C1 = Nactive √ó Guncomp √ó S √ó 2 (1)
where Nactive is the number of active qubits, Guncomp is
the number of gates for uncomputation (including those in
all children functions),  is the level of the child function in
the program call graph, and S is the communication factor.
Details can be found in Section IV-D.
Now, suppose a function does not uncomputing/reclaiming
ancilla, the next chance to reclaim them is when its parent
function uncomputes. Thus, we want to estimate the cost of
holding the ancilla live until the parent‚Äôs uncompute block is
executed. The cost, C0, can be approximated as:
C0 = Nanc √ó Gp √ó S √ó (Nactive + Nanc)/Nactive (2)
where Nanc is the number of ancillae held by the function,
Gp is the number of gates from the current function to the
parent‚Äôs uncompute function. The term under the square root
sign captures the effect of ‚Äòarea expansion‚Äù, which we will
discuss in greater detail in Section IV-D.
575              
B. Active Quantum Volume
To accurately estimate the workload of a program, we define
the active quantum volume (AQV) of a program as:
VA =
q‚ààQ

(ti,tf )‚ààTq
(tf ‚àí ti)
where Q is the set of all qubits in the system, and Tq is
a sequence of pairs {(t
0
i , t0
f ),(t
1
i , t1
f ),...,(t
|Tq|‚àí1
i , t|Tq|‚àí1
f )}.
Each pair corresponds to a qubit usage segment, that is we
denote t
k
i and t
k
f as the allocation time and reclamation time
of the kth time that qubit q is being used, respectively. AQV is
high when a large number of qubits stay ‚Äúlive‚Äù (in-use) during
the execution; thus, the higher the AQV, the more costly it is
to execute on that target machine.
The key to this metric is in the term ‚Äúactive‚Äù. In particular,
we exclude the time that a reclaimed qubit spends in the
heap from volume calculation, because it has been restored
to the |0 state (ground state), which does not suffer from
the decoherence noise as an excited state does. Hence, AQV
serves as a minimization objective in SQUARE. There are a
few practical advantages for using AQV over other resource
metrics:
1) AQV is a better measure of the exposure to errors
than the space√ótime metric (i.e. number of qubits times
circuit depth) [39], [59]. The more time a qubit stays
live, the more susceptible it is to noise from its surroundings. We show lower AQV yields higher success
rate in Section V-C.
2) Unlike qubit count, gate count, or circuit depth, AQV
allows us to more accurately model ‚Äúliveness‚Äù of qubits
on a machine (i.e. which qubits are actively carrying
information and performing computation as opposed to
staying in ground state unused). [60] and [61] shows
that keeping a preferred subset of qubits live can boost
program success rate.
3) IBM‚Äôs quantum volume (QV) [19] characterizes the
amount of computational resource a quantum device
offers, AQV measures the portion of resource being
actively utilized by a program on the device.
C. Compilation Tool Flow of SQUARE
In a nutshell, our SQUARE compilation algorithm takes
as input a Scaffold program [58] and produces an optimized
schedule of all of its quantum instructions. This is accomplished through what is known as the ‚Äúinstrumentation-driven‚Äù
approach, also used in [62], which allows us to pre-simulate
the control flow in a quantum program. This works because all
inputs are known at compile time for most quantum programs,
so we can use their known control flow to simulate resource
usage.
Figure 4 illustrates in detail the compilation flow for
SQUARE. It consists of three main components: 1) an easyto-use syntactical construct compatible within the Scaffold
language, 2) a qubit allocation heuristic, and 3) a qubit
reclamation heuristic.
Under the hood, an input program first goes through
an initial compilation step, where each Allocate() and
Free() instruction is replaced by a classical function call
(such as in C/C++) that implements the heuristic algorithm.
Each quantum gate is replaced by a classical function that
resolves the connectivity constraints of its operand qubits and
then schedules the gate to the earliest time step possible. As
a result, we have obtained an executable for the classical
control flow of the quantum program. The compiler maintains
an ancilla heap (i.e. pool of reclaimed qubits) that stores all
the reclaimed ancilla qubits. Future allocations can therefore
choose to pop from the ancilla heap or initialize brand new
qubits. One of the key contributions of our work is a heuristic
that makes such decisions.
D. Complexity of SQUARE
SQUARE is a heuristic-based greedy algorithm. It makes
allocation and reclamation decisions as they appear in program order. As a result, it takes time that scales linearly to
the number of reclamation points in a program. Consider a
program with nested functions ‚Äì all decisions in the callees
are made prior to that of the caller, so when deciding for the
caller function, the cost of uncomputation is deterministic and
easy to estimate. On the flip side, we could end up in a suboptimal situation where callee‚Äôs decisions are made neglecting
the potential burden for uncomputing its caller.
The computational complexity of qubit reclamation via
uncomputation has been studied. It has been shown that, for
programs with linear sequential dependency graph, we can
use the reversible pebbling game to approach this problem
[46]. However, finding the optimal points in a program with
hierarchical structure is PSPACE complete [42]. For a program
with  levels and d callees per function, there can be as many
as d possible reclamation points in the worst case. We could
be dealing with 2d
different combinations of reclamation
decisions. So clearly, the na¬®ƒ±ve way for finding the optimal
strategy by exhaustively enumerating all possible decisions is
far from efficient.
IV. IMPLEMENTATION DETAILS OF SQUARE
In this section, we describe the implementation details
of the components of SQUARE algorithm, including the
expressive syntactical construct in the Scaffold programming
language [58] that exposes the optimization opportunities, the
instrumentation-driven LLVM [62] that translates the quantum
program into a classical executable, and details of the localityaware allocation heuristics and the cost-effective reclamation
heuristics that we left out from Section III-A.
A. Syntactical Construct
In order to express the opportunities for qubit allocation and
reclamation optimizations, we augment the high-level Scaffold
[58] programming language with an additional syntactical
construct: Compute-Store-Uncompute Code Blocks. As shown
in Figure 6, the keywords ‚ÄúAllocate‚Äù and ‚ÄúFree‚Äù are used
to express the locations of qubit allocation and reclamation
576     
1 #include "qalloc.h"
2
3 void fun1(qbit* in, qbit* out) {
4 qbit anc[1];
5 Allocate(anc, 1);
6 Compute {
7 Toffoli(in[0], in[1], in[2]);
8 CNOT(in[2], anc[0]);
9 Toffoli(in[1], in[0], anc[0]);
10 }
11 Store {
12 CNOT(anc[0], out[0]);
13 }
14 Uncompute{
15 // Invoke Inverse() to populate
16 // Or write out explicitly:
17 Toffoli(in[1], in[0], anc[0]);
18 CNOT(in[2], anc[0]);
19 Toffoli(in[0], in[1], in[2]);
20 }
21 Free(anc, 1);
22 }
23
24 int main () {
25 qbit new[4]; // declare name
26 Allocate(new, 4); // allocate qubits
27 fun1(new, &new[3]);
28 return 0;
29 }
Fig. 6: Format of compute-store-uncompute construct for qubit
allocation and reclamation. Shown here an example function
(fun1) that allocates and reclaims an ancilla qubit.
respectively. To enable automation in the optimizations, the
compiler needs additional information about the code structure. By writing a Compute code block, the program now
has explicitly specified the set of instructions that belong to
forward computation. Optionally, programmer can choose to
automatically generate the content of the Uncompute block
by invoking Inverse().
Under the hood, the compiler will replace each Allocate
and Free instruction with an invocation to our heuristic
algorithms. Depending on the reclamation decision, it will
either execute or skip the uncomputation step accordingly.
B. Instrumentation-Driven Compilation
In this section, we illustrate a number of advantages of
the instrumentation-drive approach over the conventional passdrive approach used in most quantum compilers.
The traditional pass-driven approach for compiling and
optimizing quantum programs is done by sending a high-level
quantum program through multiple layers of transformations,
each of which completes a different task. For instance, we
have transformations to resolve classical control structures
(e.g. loop unrolling and module inlining), explore circuit
optimizations (e.g. commutativity and parallelism), satisfy
architectural constraints (e.g. qubit connectivity), assign qubit
mappings, and perform gate scheduling, etc. One of the potential limitations in this approach is that each transformation
performs independently, and in some cases even conflicts with
each other [54]. So it is very hard to jointly optimize for
some correlated problems such as mapping and scheduling.
Algorithm Description
Eager Reclaim qubits whenever possible, as shown in Section III.
Lazy Only reclaim qubits from the top level in the program
call graph, as shown in Section III.
SQUARE Combines Locality-aware allocation (LAA) and
Cost-effective reclamation (CER). See Section III-A.
TABLE I: List of compiler configurations.
Techniques such as feedback loops could in some cases work
well in practice.
Two main reasons that the instrumentation-driven approach
may be a more natural fit for our purpose are: the dynamic
nature of our optimization and compilation time scalability.
Recall from Section III-C, our compilation tool flow produces
an executable that allows us to dynamically optimize for the
allocation and reclamation of qubits in reversible programs
with parallel and modular structures. In the next section, we
illustrate the details of our heuristic algorithms and how they
are integrated in the compilation tool flow.
C. Allocation Policy Details
The allocation policy is most concerned about the communication overhead of two-qubit operations in a program.
‚Ä¢ Under NISQ architecture, communication between two
qubits is accomplished by move one qubit to another via
a series of swaps. So swap distance is a direct measure of
the locality. The higher the distance, the longer it takes
for a chain of swaps to complete.
‚Ä¢ The concept of locality can be trickier in a FT architecture. Communication is accomplished via braiding.
Braids can have arbitrary length or shape, but they are
not allowed to cross. As [37] shows, average braid length
and average braid spacing are both strongly correlated
with the number of braid crossings. So we can reduce
communication overhead by moving interacting qubits
closer and moving non-interacting qubits far apart.
When there are fewer qubits available than requested (due
to either the maximum qubit constraint or a shortage in
the ancilla heap), we mark the allocation as pending, and
proceed to schedule all non-dependent, parallel computation
and reclamation. Allocation requests are not fulfilled until
sufficient ancilla qubits have been reclaimed.
D. Reclamation Policy Details
The reclamation policy dictates what and when ancilla
qubits get recycled. The decisions rely heavily on three main
considerations: qubit savings, uncomputation gate count, and
communication overhead. In Section III-A2, we have discussed how SQUARE balances between qubit savings and gate
count. Now we present further details on how to estimate the
communication factor in Equation 1 and 2.
‚Ä¢ NISQ architecture: We use the average swap-chain length
per gate as the estimate for S. This is obtained from the
history of swap chains during the compile time simulation
‚Äì we keep a running average of the number of swaps for
577
the gates we scheduled, and use it as an estimate for the
subsequent gates in the same module.
‚Ä¢ Fault-tolerant (FT) architecture: We use average braiding
conflicts per gate as the estimate for S. The communication latency due to braid routing is estimated (similarly
as [37]) by factoring in the average braid length, average
braid spacing, and number of crossings.
Since ‚Äúqubit reservation‚Äù causes the active qubit area to be
expanded, leading to higher communication overhead, the multiplicative factor (Nactive + Nanc)/Nactive aims to estimate
the swap or braid length increase due to the expansion.
Algorithm 1 and 2 are pseudo-code of SQUARE, implementing LAA and CER respectively. Procedures under
namespace LLVM are functions that operate on the LLVM
IR. In particular, get interact qubits() obtains the set of
qubits with which the allocated qubits interact by looking ahead in the code block. gen uncompute block() and
rm uncompute block() conditionally expands or deletes the
code block under Uncompute{} (as shown in Figure 6). closest qubit in heap() and closest qubit new() look for available qubits to reuse from the heap and from new qubits,
respectively. Both functions return the candidate qubits and
scores. The scores are calculated based on the communication,
serialization, and area expansion, as described in Sec IV-C. We
select the qubits with minimum scores until the requested n
qubits are allocated.
Algorithm 1 Allocate: Locality-Aware Allocation
Input: Number of qubits n
Output: Set of qubits S
1: I ‚Üê LLVM::get interact qubits()
2: S‚Üê‚àÖ;
3: for i ‚Üê 1 to n do
4: q1, score1 ‚Üê closest qubit in heap(I)
5: q2, score2 ‚Üê closest qubit new(I)
6: if score1 ‚â§ score2 then
7: S‚ÜêS‚à™{q1}
8: else
9: S‚ÜêS‚à™{q2}
10: end if
11: end for
Algorithm 2 Free: Cost-Effective Reclamation
Input: Number of qubits n, Set of qubits S
1: C1 ‚Üê cost of uncomputation
2: C0 ‚Üê cost of no uncomputation
3: if C1 ‚â§ C0 then
4: LLVM::gen uncompute block()
5: heap push(n, S)
6: else
7: LLVM::rm uncompute block()
8: LLVM::transfer to parent(n, S)
9: end if
V. EVALUATION
A. Benchmarks
Table II lists the QC benchmarks and brief description in our
study. These benchmarks are reversible arithmetic functions
Name Description
RD53 Input weight function with 5 inputs and 3 outputs.
6SYM Function with 6 inputs and 1 output.
2OF5 Output is 1 if number of 1s in its input equals two.
ADDER4 4-bit in-place controlled-addition3.
Jasmine-s Small and shallow instance of synthetic benchmark Jasmine.
Elsa-s Small and shallow instance of synthetic benchmark Elsa.
Belle-s Small and shallow instance of synthetic benchmark Belle.
ADDER32 32-bit in-place controlled-addition.
ADDER64 64-bit in-place controlled-addition.
MUL32 32-bit out-of-place controlled-multiplier.
MUL64 64-bit out-of-place controlled-multiplier.
MODEXP Modular exponentiation function4.
SHA2 Cryptographic hash function5.
SALSA20 Stream cipher core function6.
Jasmine Shallowly nested synthetic function7.
Elsa Heavy workload and shallowly nested synthetic function.
Belle Light workload and deeply nested synthetic function.
TABLE II: Characteristics of benchmark programs.
or applications that use ancilla qubits. Since ancilla qubits are
expensive in both NISQ and FT architectures, it is crucial
to reuse ancilla qubits and improve the success rate of a
program. The first 4 benchmarks (RD53, 6SYM, 2OF5, and
ADDER4) are small arithmetic functions suitable for executing
on NISQ systems (10 - 100 qubits). The rest of the benchmarks
are medium to large functions that are more demanding in
computational resources than current NISQ systems can offer.
The number of qubits they use, for instance, is on the order
of hundreds or thousands. For the last three benchmarks, we
construct random synthetic circuits (Jasmine, Elsa, and Belle)
with different characteristics in their program structures. In
particular, a benchmark is parameterized by the size and shape
of its program call graph using 5 variables: number of nested
levels, max number of callees per function, max number of
input qubits per function, max number of ancilla qubits per
function, maximum number of gates per function.
B. Experimental Setup
All compilation experiments are carried out on Intel Core
i7-3960X (3.3GHz, 64GB RAM), implemented in the quantum
compiler framework ScaffCC [58] version 4.0. Noise simulations use Intel E5-2680v4 (28-core, 2.4GHz, 64GB RAM),
performed using the IBM Qiskit software [66]. Table I lists
the ancilla reuse algorithms in our study. Eager and Lazy are
two baselines that appear commonly in prior work. SQUARE
is our Strategic QUantum Ancilla REuse algorithm.
3The adders are based on the Cucarro adder [63], [64].
4Modular exponentiation is an important subroutine used in Shor‚Äôs factoring
algorithm [16]. 5SHA2 contains multiple rounds of in-place modular additions and bit
rotations, based on the implementation from [24]. When used as an oracle
in Grover‚Äôs algorithm [25], we can find hash collisions more efficiently, and
thereby reduce the security of the hash function. 6Salsa20 involves 20 rounds of 4 parallel modules. Each module modifies 4
words with modular additions, XOR operations, and bit rotations. The Salsa20
stream cipher uses the Salsa20 core function to encrypt data. [65] Salsa family
functions have been popularly adopted for TLS in places like the Chrome
browser and OpenSSH. 7Qubits and gates are randomly assigned.
578 
	




	 	 	
Fig. 7: QC architecture boundary.
The rest of the section are divided up into three main
parts (Figure 7) ‚Äì experimental results on NISQ architecture
(Section V-C) with 2D lattice of physical qubits and nearestneighbor connectivity as commonly used in [3], [67], [68],
on NISQ-FT boundary architecture (Section V-D) with same
architecture model but on larger benchmarks, and on FT
architecture (Section V-E) with surface code error corrected
logical qubits [37], [69].
C. NISQ Experiments
Although SQUARE was initially designed to improve the
performance of large-scale applications, we find that reclaiming ancilla reduces program footprint and thus swap count due
to communication on NISQ machines. In this section, we give
analytic and noise simulation results that quantify the fidelity
gains from this reduced swap count. To make noise simulation
tractable, we focus on small benchmarks and introduce small
versions of our 3 synthetic benchmarks as in Table II.
1) AQV Analysis: For our NISQ benchmarks, Figure 8a
and Table III show the characteristics of the compiled QC
programs with different compiling policy. With the Eager
compiling policy, the programs use the fewest qubits, but it
may cost too many gates to reuse the ancilla qubits. SQUARE
finds the balance between qubit uses and gate costs. We show
the AQV comparison in Figure 8a. The AQV is reduced when
we apply LAA that allocates the closest qubits, reducing the
number swaps. When full SQUARE is applied, AQV is further
reduced because of reduction in uncompute cost.
2) Program Success Rate by Analytical Model: Program
success rates in our evaluation are estimated by a worst-case
analysis using qubit decoherences and gate errors. Multiplying
the single-qubit/two-qubit gate success rates and the probability of qubit coherence from Table IV, we observe an average
improvement by 1.47X w.r.t Eager and 1.07X w.r.t. Lazy. With
strategic uncompuptation by SQUARE, programs use fewer
qubits and improve overall chance of success. In reality, this
worst case analysis may neglect program structures and noise
cancellation. Results are even more positive in the next section
where we perform noise simulation.
3) Noise Simulations: All simulations in our evaluation
use IBM Qiskit Aer simulator [66] with noise models from the qiskit.providers.aer.noise library ‚Äì
depolarize_noise for single-qubit and two-qubit gate
Benchmarks Policy # Gatesa # Qubits Circuit Depth # Swaps
Lazy 536 19 395 462
RD53 Eager 1064 10 878 633
SQUARE 932 11 635 370
Lazy 648 19 456 654
6SYM Eager 1293 11 1279 1247
SQUARE 1078 12 731 520
Lazy 708 18 723 759
2OF5 Eager 1410 8 2374 1728
SQUARE 1176 10 952 385
Lazy 656 18 787 725
ADDER4 Eager 1184 12 1139 748
SQUARE 920 14 715 421
Lazy 275 16 232 73
Jasmine-s Eager 1226 5 1055 327
SQUARE 510 8 427 128
Lazy 163 15 787 725
Elsa-s Eager 501 8 438 163
SQUARE 254 13 223 85
Lazy 220 14 202 69
Belle-s Eager 712 6 574 113
SQUARE 294 9 266 89
a Here # Gates does not include swap gates (listed in a separate column).
TABLE III: NISQ benchmarks compilation results.
# Qubits single two T1 (Œºs) T2 (Œºs)
IBM-Sup [3], [70] 20 < 1% < 2% 55 60
IonQ-Trap [33] 79 < 1% < 2% > 106 > 106
Our Simulation < 20 0.1% 1% 50 70
TABLE IV: Error rates on real devices and noise models on
our simulation.
noises, and thermal_relaxation for T1/T2 relaxations
to account for qubit decoherence. Table IV shows the parameters in our simulation, compared against those in real
devices. Figure 8c shows the results from simulation; each data
point is obtained from 8192 shots of noisy circuit simulation.
We use total variation distance dT V , to compare measurement
outcomes of noisy circuits with those of ideal ones; it‚Äôs a common measure for QC experiments [71]‚Äì[73]. We observe that
SQUARE achieves lowest distance for almost all benchmarks
compared to Eager or Lazy.
4) Applicability of SQUARE to NISQ Machines: Table III
and Figure 8b together show the impact of uncomputation
on circuit fidelity. SQUARE finds a balanced middle-ground
between qubit savings and gate costs by strategically uncomputing its functions. Surprisingly, when comparing Lazy with
SQUARE, the additional gates for uncomputation reduces the
total number of operations, thanks to a substantial reduction in
swap gates, as ancilla qubits with better locality are actively reclaimed and reused. Uncomputation also dis-entangles garbage
qubits from output qubits, preventing noise from propagating.
Furthermore, SQUARE retains most of the qubit savings as
Eager does. Overall, SQUARE achieves high success rate
using fewer qubits than Lazy.
D. NISQ-FT Boundary Experiments
The boundary between NISQ and fault-tolerant architectures are far from clear. For completeness, we analyzed the
performance of the SQUARE algorithm assuming mediumscale machines (with 100-10000 qubits) is built without error
579    





'%
(
$	'
&
 
 
 


  
!" 

(a) Active quantum volume. (Lower AQV is better.)






	


!
"
	!





  

(b) Worst-case analytical model. (Higher success
rate is better.)
	

	


	












&$
'
#	&
%
 
 
 

!
  

(c) Realistic noise simulation using IBM Qiskit
Aer simulator. (Lower total variation distance is
better.)
Fig. 8: Impact of SQUARE optimizations on NISQ applications. All benchmarks use fewer than 20 qubits; SQUARE stands
out as a strategy that uses substantially fewer qubits while maintaining high application success rate. *&-0 *&+- *&*. *&*, *&*- *&*, *&*0 *&*, *&*, *&*,
*
*&/
+
+&/
,
,&/
-
-&/
-, 0. 
	-, 
	0. 
 , 	     
!#"!"" '%(
	  '	$( 
Fig. 9: AQV results on medium-scale non-error-corrected quantum systems. Numbers on the chart correspond to the normalized
AQV values of the SQUARE algorithm. ,&++
,&++
+&.2
+&-+
+&,+
+&,3
+&,,
+&41
+&.-
+&,2
+
+&0
,
,&0
-
-&0
.
.- 1/ 
	.- 
	1/ 
 - 	     
!#"!"" '%(
	  '	$( 
Fig. 10: AQV results on fault-tolerant quantum systems.
correction. Figure 9 shows the AQV results with different
compiling policies, and the normalized AQVs of SQUARE are
labeled. We observe significant AQV savings by SQUARE,
reducing the AQV by a factor of 6.9X on average when
compared to the Lazy policy.
E. Fault-Tolerant (FT) Experiments
The FT experiments share the set of benchmarks used in the
NISQ-FT experiments, but use braiding for communication. To
do so, we build and integrate a braid simulator in SQUARE to
precisely calculate the communication overhead for executing
a program on a surface-code error-corrected architecture.
Following prior work [37]‚Äì[39], we assume logical qubits
on the surface are laid out in a 2-D array, with sufficient
distance between qubits. The separation between qubits serves
as channels, allowing other qubits to braid through. So in
our simulator, we associate one site per qubit and channels
wide enough for a single qubit to braid through. Furthermore,
different single-qubit gates have different time cost.
We substitute the swap-chain generation procedure in the
SQUARE‚Äôs gate scheduler with a braid generation procedure.
In particular, when a CNOT gate is scheduled, we first find a
route between the operand qubits, and then check if it crosses
with other ongoing braids. It is queued until its route has been
cleared.
As shown in Figure 10, SQUARE significantly reduces
AQV in all applications under the FT system environment.
Comparing to Lazy policy, SQUARE achieve 44.08% AQV
reduction on average, and up to 89.66% reduction.
580                                                                                                       
VI. CONCLUSION
We have presented an automated compilation tool flow
that manages the allocation and reclamation of qubits in
reversible program with modular structures. We choose a
dynamic heuristic-based approach to tackle the challenges,
proving how we can use the knowledge of qubit locality and
program structure to our advantage to efficiently compile highlevel arithmetic for a resource-constrained machine. That is
accomplished by SQUARE via cost-effective uncomputation.
In this process, we introduce a resource metric, AQV, that
quantifies the amount of resource utilized by a given computational task. It allows us to measure and compare the
effectiveness of various compiler optimization designs.
The core of our optimization tool flow is the allocation
and reclamation heuristics, which predict the cost of uncomputation based on information such as qubit savings, gate
overheads, potential reuse, and decisions in children modules
in the program call graph. Our methodology is shown to
be effective on a suite of benchmarks, including common
arithmetic functions and synthetic programs with arbitrary
structures. We evaluate SQUARE on NISQ systems and FT
systems. The results show that our study has practical value
for not only current NISQ devices but also future FT systems.
Our work bridges qubit reclamation and classical register
allocation, which allows us to adapt ideas in the heuristic
design from classical literature. Much remains to be explored
‚Äì what other intuitions from classical compilation can be used
to optimize qubit allocation and reclamation.
This work relies on heuristics to seek a balance between
minimal ancilla usage and minimal gate complexity. It remains
an interesting open problem on whether the strategy can
achieve information-theoretical lower bound asymptotically.
Such asymptotic analysis has been explored at gate level (such
as for multi-control not gate) or for some small arithmetic
functions (such as adders); it would be a natural extension
to study the asymptotic behavior of various uncomputation
strategies at systems level (e.g. with communication costs).