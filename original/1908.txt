Abstract—Deep neural network (DNN) has emerged as the
most important and popular artificial intelligent (AI) technique.
The growth of model size poses a key energy efficiency challenge
for the underlying computing platform. Thus, model compression
becomes a crucial problem. However, the current approaches are
limited by various drawbacks. Specifically, network sparsification
approach suffers from irregularity, heuristic nature and large
indexing overhead. On the other hand, the recent structured
matrix-based approach (i.e., CIRCNN) is limited by the relatively complex arithmetic computation (i.e., FFT), less flexible
compression ratio, and its inability to fully utilize input sparsity.
To address these drawbacks, this paper proposes PERMDNN,
a novel approach to generate and execute hardware-friendly
structured sparse DNN models using permuted diagonal matrices. Compared with unstructured sparsification approach,
PERMDNN eliminates the drawbacks of indexing overhead, nonheuristic compression effects and time-consuming retraining.
Compared with circulant structure-imposing approach, PERMDNN enjoys the benefits of higher reduction in computational complexity, flexible compression ratio, simple arithmetic
computation and full utilization of input sparsity. We propose
PERMDNN architecture, a multi-processing element (PE) fullyconnected (FC) layer-targeted computing engine. The entire
architecture is highly scalable and flexible, and hence it can
support the needs of different applications with different model
configurations. We implement a 32-PE design using CMOS 28nm
technology. Compared with EIE, PERMDNN achieves 3.3× ∼
4.8× higher throughout, 5.9× ∼ 8.5× better area efficiency and
2.8× ∼ 4.0× better energy efficiency on different workloads.
Compared with CIRCNN, PERMDNN achieves 11.51× higher
throughput and 3.89× better energy efficiency.
Index Terms—Deep Learning, Model Compression, VLSI
I. INTRODUCTION
Starting their resurgence from Hinton’s seminal paper [1],
neural networks [2] have emerged as today’s most important
and powerful artificial intelligence (AI) technique. Thanks to
the availability of unprecedentedly abundant training/test data
and the significant advances in computers’ processing speed,
large-scale deep neural networks (DNNs) have been able to
deliver record-breaking accuracy results in many tasks that
*Chunhua Deng and Siyu Liao contribute equally to the paper.
+Chunhua Deng, Siyu Liao, Yi Xie and Bo Yuan are now with Rutgers
University.
demand intelligence, such as speech recognition [3], object
recognition [4], natural language processing [5] etc.
The extraordinary performance of DNNs with respect to
high accuracy is mainly attributed to their very large model
sizes [6]–[8]. As indicated in a number of theoretical analysis [9] [10] and empirical simulations [11]–[13], scaling
up the model sizes can improve the overall learning and
representation capability of the DNN models, leading to higher
classification/predication accuracy than the smaller models.
Motivated by these encouraging findings, the state-of-the-art
DNNs continue to scale up with the purpose of tackling more
complicated tasks with higher accuracy.
On the other hand, from the perspective of hardware design,
the continuous growth of DNN model size poses a key energy
efficiency challenge for the underlying computing platforms.
As pointed out in [14], since the size of on-chip SRAM is
usually very limited, placing the large-scale DNN models on
the off-chip DRAM, which has more than 100 times higher
energy cost than SRAM, is a bitter but inevitable choice.
Consequently, high energy cost incurred by the frequent access
to DRAM makes the energy-efficient deployment of DNN
systems very challenging.
To improve energy efficiency, efficient model compression
has emerged as a very active topic in AI research community.
Among different types of DNN compression techniques [15]–
[18], two approaches show promising results. First, network
sparsification is believed to be the most popular and state-ofthe-art strategy because of its good balance between compression ratio and test accuracy. To date, many methods [15] [16]
[18] have been proposed to perform efficient sparsification on
different DNN models. Echoing the importance and popularity of this approach, several sparse model-oriented hardware
architectures [19]–[22] have been proposed .
However, the current network sparsification methods suffer
from the inherent drawbacks of irregularity, heuristic nature
and indexing overhead. Consequently, despite the encouraging compression ratio, the unstructured sparse DNN models
cannot achieve optimal performance on the current computing
platforms, especially DNN hardware accelerators. Essentially,
the inefficient execution and hardware implementation are
189
2018 51st Annual IEEE/ACM International Symposium on Microarchitecture
978-1-5386-6240-3/18/$31.00 ©2018 IEEE
DOI 10.1109/MICRO.2018.00024
(a) Unstructured sparse weight matrix.
(b) Block-permuted diagonal weight matrix.
Fig. 1: Weight representation by using (a) conventional unstructured sparse matrix. (b) block-permuted diagonal matrix.
caused by the non-hardware-friendly sparse models.
To overcome the drawbacks of the irregularity, an alternative approach is to directly represent the network with
structured matrices [23]. A notable recent work is CIRCNN
[24], which represents weights using block-circulant matrices
and partitions the weight matrix W ∈ Rm×n into blocks
of square circulant sub-matrices (e.g., Wij of size k × k).
Due to circulant structure, only k (instead of k2) weights
need to be stored for each sub-matrix. The calculation of
Wijxj can be performed as IFFT
FFT(wij ) ◦ FFT(xj )

,
where ◦ denotes element-wise multiplications and wij is the
first row of Wij . Utilizing FFT-based fast multiplication, it
simultaneously reduces computational cost and storage cost
with small accuracy loss.
Due to the hardware-friendly model representation, CIRCNN demonstrated the efficient hardware implementation
and better performance. However, it is still limited by the
relatively complex arithmetic computation (i.e., FFT), less
flexible compression ratio, and inability to fully utilize input
sparsity.
In this paper, we propose PERMDNN, a novel approach that
generates and executes hardware-friendly structured sparse
DNN models using permuted diagonal matrices. As illustrated
in Fig. 1(b), permuted diagonal matrix is a type of structured
sparse matrix that places all the non-zero entries in the
diagonal or permuted diagonal. When the weight matrices of
DNNs can be represented in the format of multiple permuted
diagonal matrices (so-called block-permuted diagonal matrices), their inherent strong structured sparsity leads to great
benefits for practical deployment. Specifically, it eliminates
indexing overhead, brings non-heuristic compression effects,
and enables re-training-free model generation.
While both methods impose the structure on the construction of weight matrices, PERMDNN offers three advantages
over CIRCNN: 1) Simpler arithmetic computation. Unlike
CIRCNN, which inherently requires complex number operation (complex multiplication and addition) because of the use
of FFT, PERMDNN is purely based on real number arithmetic,
thereby leading to low hardware cost with the same compression ratio; 2) Significantly better flexibility. PERMDNN
hardware can freely support different sizes of permuted diagonal matrices, while CIRCNN hardware is limited to only
support 2t
-size circulant matrix because most of FFT hardware
is 2t
-point-based. This means that PERMDNN is much more
flexible for the choice of compression ratio; 3) Full utilization
of input sparsity. PERMDNN can fully utilize the dynamic
sparsity in the input vectors but CIRCNN cannot. The reason
is that CIRCNN can only process frequency-domain input
vectors that lose important time-domain sparsity. It allows
PERMDNN to achieve additional improvements in throughput
and energy efficiency over CIRCNN.
Based on PERMDNN, we develop an end-to-end training
scheme that can generate a high-accuracy permuted diagonal
matrix-based DNN models from scratch. We also develop the
corresponding low-complexity inference scheme that executes
efficiently on the trained structured sparse DNN models.
Experimental results on different datasets for different application tasks show that, enforced with the strong structure, the
permuted diagonal matrix-based DNNs achieve high sparsity
ratios with no or negligible accuracy loss.
To accelerate inference, we propose PERMDNN architecture, a high-performance permuted diagonal matrix-based
inference engine that targets the fully-connected (FC) layers of
DNN models. The PERMDNN architecture is designed to fully
reap the benefits of permuted diagonal matrix-based structure.
Unlike EIE [14], the state-of-the-art DNN architecture targeting FC layer, PERMDNN architecture does not incur index
overhead and load imbalance due to the irregularity of conventional unstructured sparse DNN models, thereby leading
to significant improvement in hardware performance. With an
array of processing elements (PEs), PERMDNN architecture is
an elastic and scalable architecture that can adapt to different
sizes of DNN models, size of component permuted diagonal
matrices, and number of PEs. This allows the architecture to
be deployed in various application scenarios that have different
requirements on power, area and throughput.
To demonstrate the advantages of PERMDNN architecture,
we implement a 32-PE design using CMOS 28nm technology.
Operating on 1.2GHz clock frequency, the PERMDNN implementation consumes 703.4mW and 8.85mm2. Meanwhile,
equipped with 8 multipliers in each PE, the processing power
of 32-PE PERMDNN achieves 614.4GOPS for a compressed
DNN model, which approximately corresponds to 14.74TOPS
on an uncompressed network. Compared to EIE, PERMDNN
achieves 3.3× ∼ 4.8× higher throughout, 5.9× ∼ 8.5× better
area efficiency and 2.8× ∼ 4.0× better energy efficiency
on different workloads. Compared to CIRCNN, PERMDNN
achieves 11.51× higher throughput and 3.89× better energy
efficiency.
II. MOTIVATION
A. Importance of FC Layer-targeted Architecture
Similar to EIE, PERMDNN is a customized DNN architecture that targets for FC layers. Specifically, PERMDNN
accelerates the sparse matrix-vector multiplication (M × V ),
190
which is the kernel computation of any FC layers. We justify
the importance of FC layer with the following three arguments.
First, FC layer has a wide spectrum of application scenarios.
As summarized in Table I, besides being used in convolutional
neural network (CNN) for computer vision tasks, FC layer is
also the dominant layer in many other types of DNNs (e.g.,
recurrent neural network (RNN1) and multi-layer perceptrons
(MLP) for speech recognition and natural language processing
tasks. Therefore, optimizing FC layer can universally benefit
a full spectrum of AI tasks.
Second, real-world industrial needs call for efficient FC
layer-targeted DNN architecture. As revealed in Googles seminal TPU paper [25], more than 95% workload in Google’s
datacenters are processed by those FC layer-centered DNNs,
such as RNNs and MLPs. Therefore, [25] called for more
research efforts on FC layers, which is currently far less active
than the effort for convolutional (CONV) layers.
Finally, optimized FC layer-targeted architecture can improve the overall performance of CONV layer-centered models
(e.g., CNNs). As analyzed in [20], forcing a CONV layertargeted architecture to execute FC layers will cause noticeable
performance degradation. We believe that, to realize an efficient architecture for CNNs with both CONV and FC layers,
a specialized design that optimizes for FC layer is a preferable
strategy to maximize hardware performance.
TABLE I: Types of DNN models used in practical AI fields.
Applications DNN Models Component Layer
Computer Vision CNN CONV layer (Main)
FC layer
Speech Recognition RNN, MLP FC layer
Natural Language Processing RNN, MLP FC layer
B. Drawbacks of Unstructured DNN Sparsification
Due to the large memory requirement and the inherent
redundancy, FC layers are usually compressed with network
sparsification, such as heuristic pruning [15] and conducting
certain regularization [18]. The downside of the approach is
that the unstructured sparse models are not friendly to be
implemented in DNN hardware accelerators.
First, the structure of their generated sparse DNNs is usually
highly irregular [15] or only exhibits weak regularity [18]. It
incurs significant space/computation overhead due to indexing
the irregular sparse weight matrices. For instance, in EIE, each
weight requires 4-bit virtual weight tag to represent its actual
value and additional 4 bits to record its relative position in
the entire weight matrix. Therefore, the overall storage cost
for one weight is actually 8 bits instead of 4 bits, significantly
limiting the achievable performance.
Second, the compression ratio of DNN sparsification is
typically heuristic. This is because the inherent process of
weight/neuron pruning or regularization-caused sparsification
is usually uncontrollable and unpredictable. Consequently, in
1In this paper the FC in RNN specifically means the component weight
matrices in RNN.
the scenario of compression effect is pre-defined, precisely
controlling the compression ratio to satisfy the design specification becomes challenging.
Moreover, the existing DNN sparsification approaches introduce large training overhead. Operating on the pre-trained
dense model, weight/neuron pruning and retraining are performed iteratively to ensure the original accuracy of the dense
model can also be achieved by the sparse model. Clearly,
the process is time-consuming, — sometimes it may even
take longer time to re-train sparse models than the dense
models. For instance, as reported in [26], in order to get a
fair compression rate on a pre-trained AlexNet model, it takes
4800K and 700K iterations by using the pruning methods
in [15] and [26], respectively, while training this pre-trained
model only takes 450K iterations.
C. Drawbacks of Circulant Matrix-based Compression
An alternative approach to achieve network compression is
to directly represent the network with structured matrices. As
an example, CIRCNN utilizes the mathematical property of
circulant matrix to compress DNN models that can be efficiently implemented in hardware. While avoiding the irregularity, CIRCNN suffers from a different set of drawbacks. First,
it requires high-cost arithmetic operation. The training and
inference algorithms of CIRCNN are based on FFT computation, which is inherently involved with complex multiplication
and addition. Unfortunately, arithmetic operations on complex
numbers incur much higher cost than their counterparts on real
numbers. For instance, one complex multiplication requires
four real multiplications and two real additions.
Moreover, it lacks flexibility on compression ratio. The
compression ratio of CIRCNN is determined by the size of
component circulant matrix. However, since this size also determines the length of FFT, in order to facilitate FFT hardware
design that mostly uses 2t
-point FFT2, the compression ratio
of each layer of CIRCNN has to be selected among the values
of 2t
. Obviously, such restriction severely limits the potential
applications of CIRCNN.
Finally, it loses the opportunity of utilizing input sparsity.
As discussed in [14] [21], utilizing the dynamic input sparsity
is an important technique to reduce the power consumption
and computational time of DNN hardware. However, since
CIRCNN processes the input vector in the frequency domain,
its original abundant sparsity in time domain is completely
lost. It prevents CIRCNN from utilizing the important input
sparsity for performance improvement.
III. PERMDNN: ALGORITHMS & BENEFITS
A. PERMDNN Representation
To address the drawbacks of the current sparsification-based
and structured matrix-based methods, we propose PERMDNN,
a new structured sparse DNN representation, shown in Fig.
1(b). Specifically, we enforce that the weight matrices of
2non-2t-point FFT has much more complex hardware than 2t-point FFT.
191
the DNN models consist of multiple permuted diagonal submatrices, where all the non-zero entries of the permuted diagonal matrices locate in the diagonals or permuted diagonals. In
general, the m-by-n weight matrix of one layer of PERMDNN
contains mn/p2 p-by-p permuted diagonal sub-matrices3. As
it will be shown later, this type of block-permuted diagonal
weight matrix exhibits strong spatial structure that brings
significant reduction in space cost and computational cost.
B. Inference and Training Schemes of PERMDNN
Based on the representation of PERMDNN, we develop the
computation procedures of forward and backward propagation
that are the key parts for inference and training process.
In general, we assume that the weight matrix of a fullyconnected layer of PERMDNN is an m-by-n block-permuted
diagonal matrix W ∈ Rm×n. Here W consists of multiple
p-by-p permuted diagonal sub-matrices. Considering there are
(m/p) × (n/p) sub-matrices in total and each has its own
permutation parameter, we index all the sub-matrices from 0
to (m/p)×(n/p)−1 and denote kl as the value of permutation
parameter for the l-th permuted diagonal sub-matrix. Then, for
arbitrary entry wij of W, its value can be represented as:
wij =

qkl×p+c if (c + kl) mod p ≡ d
0 otherwise , (1)
where c ≡ i mod p, d ≡ j mod p and l = (i/p) × (n/p) +
(j/p). Here q = (q0, q1,...,qmn/p−1) is the vector that
contains all the non-zero entries of W.
Forward Propagation for Inference. Recall that the forward propagation during inference phase for FC layer is
performed as y = ψ(a) = ψ(Wx)4, where ψ(·) is the
activation function and a = Wx = (a1, a2,...,am)T . In
addition, x = (x1, x2,...,xn)T and y = (y1, y2,...,ym)T
are the input and output vectors of FC layer, respectively.
Accordingly, when W is the trained block-permuted diagonal
weight matrix with entries that are represented by Eqn. (1),
the calculation of ai, as the key computation in the forward
propagation, can now be simplified as ai = n/p−1
g=0 wijxj ,
where j ≡ (i + kl) mod p + gp and l = g + (i/p) × (n/p).
Notice that here for weight storage, only the mn/p -length
vector q that contains all the non-zero entries of W needs
to be stored in the inference phase. Also, the calculation of
ai is significantly simplified from the original computation as
ai = n−1
g=0 wijxj .
Backward Propagation for Training. When the FC layer
is imposed with permuted diagonal structure, we need to
ensure the FC layer of PERMDNN always exhibits permuted
diagonal structure in each iteration of training phase. Recall
that the forward propagation for FC layer is performed as
y = ψ(a) where a = (a1, a2,...,am)T . Then, the gradient
calculation, which is the key step of the backward propagation,
is performed as ∂J
∂wij = xj
∂J
∂ai
, where J is the loss function
[27] of the neural network. Notice that according to the
3When m or n is not divided by p, zeroes are padded. It will not cause
extra overhead since padded zeroes are not involved in computation/storage. 4Bias is combined with W for simplicity.
principle of backpropagation [27], xi in the current layer will
be backward propagated to the previous layer as ai. Therefore,
together with the above equation, the weight updating rule for
the FC layer of PERMDNN can be derived as:
wij ← wij − xj
∂J
∂ai
, for any wij  = 0, (2)
∂J
∂xj
=
m/p
−1
g=0
wij
∂J
∂ai
, (3)
where i ≡ (j+p−kl) mod p+gp, l = gn/p+j/p and  is the
learning rate. Here in Eqn. (2) the calculation of ∂J
∂ai is aided
with the computation in Eqn. (3) since each xi in the current
layer will be backward propagated to the previous layer as ai.
Notice that here the weight update scheme described in Eqns.
(2) (3) theoretically guarantees the trained sparse network
always exhibits block-permuted diagonal structure and hence
provides attractive end-to-end training solution.
C. Extension to Convolutional Layer
Forward Propagation for Inference on CONV Layer. The
idea of imposing permuted diagonal structure on the weight
matrix of FC layer can be further generalized and applied
to the weight tensor of CONV layer. Recall that the weight
tensor of a CONV layer is a 4D tensor that can be viewed as a
”macro” matrix with each entry being a filter kernel; therefore,
as illustrated in Fig. 2, the permuted diagonal structure can be
imposed on the input channel and output channel dimensions
of the weight tensor. Then, similar to the case for FC layer,
the forward propagation for inference on CONV layer using
permuted diagonal matrix can be described as follows:
Y(i, x, y) =
c2

/p−1
g=0
w
1−1
w=0
h
1−1
h=0
F(i, j, w, h)X (j, x − w, y − h),
(4)
where X ∈ Rc0×w0×h0 , Y ∈ Rc2×w2×h2 , F ∈ Rc0×c2×w1×h1
represent the input, output and weight tensors of convolutional layer, respectively. Here wi and hi for i=0,1,2 are
the width and height of the input, kernel and output tensor,
respectively. c0 and c2 are the numbers of input channels and
output channels. In addition, j ≡ (i + kl) mod p + gp and
l = g + (i/p) × (n/p).
Fig. 2: Block-permuted diagonal weight tensor of CONV layer.
Backward Propagation for Training on CONV Layer.
Similar to the FC layer, in order to ensure the convolutional
layer of PERMDNN always exhibits the permuted diagonal
structure during the training phase, the corresponding weight
192
updating procedure needs to be re-designed. Following the
similar steps of deriving training procedure for FC layer, the
weight update rule in the back propagation on CONV layer
can be described as follows:
F(i, j, w, h) ←F(i, j, w, h) − 
w2
x=0

h2
y=0
X (i, x − w, y − h)
×
∂J
∂Y(i, x, y)
, for any F(i, j, w, h)  = 0,
(5) ∂J
∂X (i, j, x)
=
c0

/p−1
g=0
w
1−1
w=0
h
1−1
h=0
F(i, j, w, h) ∂J
∂Y(i, x+w, y+h)
,
(6)
where i = (j + p − kl) mod p + gp and l = gn/p + j/p.
Notice that here in Eqn. 5 the calculation of ∂J
∂Y(i,x,y) is aided
with the computation in Eqn. 6 since each X (j, x, y) in the
current layer will be backward propagated to the previous
layer as Y(j, x, y). Again, the weight update scheme described
in Eqns. (5) (6) theoretically guarantees the trained sparse
network always exhibits block-permuted diagonal structure.
D. Test Accuracy and Compression Ratio
By leveraging the forward and backward propagation
schemes in Eqns. (2)-(6), the PERMDNN models can be
trained from scratch and tested. Table II - Table V show
the task performance and compression ratio of different PERMDNN models on different types of datasets. Notice that
for one FC/CONV layer with block size p for its permuted
diagonal (PD) weight matrix/tensor, the compression ratio for
that layer is p. The details of the experimental setting are
described as follows:
• AlexNet [28]: The block sizes (p) for the permuted
diagonal weight matrices of three FC layers (FC6, FC7
and FC8) are set as different values (10, 10 and 4) for
different FC layers.
• Stanford Neural Machine Translation (NMT) [29]:
This is a stacked LSTM model containing 4 LSTMs with
8 FC weight matrices for each LSTM. In the experiment
the value of p for all the FC layers is set as 8.
• ResNet-20 [11]: In this experiment for the group of
CONV layers without 1x1 filter kernel, the value of p
is set as 2. For the group of CONV layers with 1x1 filter
kernel, p is set as 1.
• Wide ResNet-48 [12]: The widening parameter of this
model is 8. For the group of CONV layers without 1x1
filter kernel, the value of p is set as 4. For the group of
CONV layers with 1x1 filter kernel, p is set as 1.
• Selection of Permutation value (kl): kl can be selected via either natural indexing or random indexing.
Our simulation results show no difference between task
performance for these two setting methods. Table II -
Table V are based on natural indexing. For instance, for
a 4-by-16 block-permuted diagonal weight matrix with
p = 4, k0 ∼ k3 is set as 0 ∼ 3.
Table II - Table V show that imposing permuted diagonal
structure to DNN models enables significant reduction in
the weight storage requirement for FC or CONV layers.
Meanwhile, the corresponding task performance, in terms of
test accuracy (for computer vision) or BLEU scores [30] (for
language translation), are still retained as the same or only
exhibits negligible degradation. In short, PERMDNN models
can achieve high compression ratios in network size and
strong spatial network structure, and simultaneously, preserve
high task performance. It makes the corresponding hardwarefriendly architecture (Section IV) very attractive.
TABLE II: AlexNet on ImageNet [4]. PD: Permuted Diagonal.
AlexNet
Block size (p) for
PD weight matrix
of FC6-FC7-FC8
Top-5
Acc.
Compression
for overall
FC layers
Original 32-bit float 1-1-1 80.20% 234.5MB(1×)
32-bit float with PD 10-10-4 80.00% 25.9MB(9.0×)
16-bit fixed with PD 10-10-4 79.90% 12.9MB(18.1×)
TABLE III: Stanford NMT (32-FC layer LSTMs) on IWSLT15
for English-Vietnamese Translation.
Stanford NMT
(32-FC layer LSTMs)5
Block size (p) for
PD weight matrix
of ALL FC Layers
BLEU
Points
Compression
for overall
FC layers
Original 32-bit float 1 23.3 419.4MB(1×)
32-bit float with PD 8 23.3 52.4MB(8×)
16-bit fixed with PD 8 23.2 26.2MB(16×)
TABLE IV: ResNet-20 on CIFAR-10 [31].
ResNet-20
Block size (p) for
PD weight tensor
of CONV layers
Acc.
Compression
for overall
CONV Layers
Original 32-bit float 1 91.25% 1.09MB(1×)
32-bit float with PD 2 for most layers 90.85% 0.70MB(1.55×)
16-bit fixed with PD 2 for most layers 90.6% 0.35MB(3.10×)
TABLE V: Wide ResNet-48 on CIFAR-10.
Wide ResNet-48
Block size (p) for
PD weight tensor
of CONV layers
Acc.
Compression
for overall
CONV layers
Original 32-bit float 1 95.14% 190.2MB(1×)
32-bit float with PD 4 for most layers 94.92% 61.9MB(3.07×)
16-bit fixed with PD 4 for most layers 94.76% 30.9MB(6.14×)
E. Outline of Theoretical Proof on Universal Approximation
In CIRCNN the universal approximation property of blockcirculant matrix-based neural network was given to theoretically prove the effectiveness of using circulant matrices. In
this work we discover that the PERMDNN also exhibits the
universal approximation property, thereby making the rigorous
foundation for our proposed permuted diagonal structureimposing method. The details of the proof will be provided
in an individual technical report and this subsection gives
a brief outline of the proof as follows. First, we prove that
the ”connectedness” of PERMDNN, – that means, thanks to
the unique permuted diagonal structure of each block, when
kl is not identical for all permuted diagonal matrices, the
sparse connections between adjacent block-permuted diagonal
layers do not block away information from any neuron in the
previous layer. Based on this interesting property, we further
prove that the function space achieved by the block-permuted
5Here one FC in LSTM means one component weight matrix.
193
diagonal networks is dense. Finally, with the Hahn-Banach
Theorem we prove that there always exists a block-permuted
diagonal neural network that can closely approximate any
target continuous function defined on a compact region with
any small approximation error, thereby showing the universal
approximation property of block-permuted diagonal networks.
Besides, we also derive that the error bound of this approximation error is in the order of O(1/n), where n is the number
of model parameters. Consequently, the existence of universal
approximation property of PERMDNN theoretically guarantees its effectiveness on different DNN types and applications.
F. Applicability on the Pre-trained Model
Besides training from scratch, the permuted diagonal
matrix-based network model can also be obtained from a
pre-trained dense model. Fig. 3 illustrates the corresponding
procedure, which consists of two steps: permuted diagonal
approximation and re-training/fine-tuning. First, the original
dense weight matrices/tensors need to be converted to permuted diagonal matrices/tensors via permuted diagonal approximation. The mechanism of permuted diagonal approximation is to convert a non-permuted diagonal matrix/tensor to
a permuted diagonal format by only keeping the entries in the
desired permuted diagonal positions. Mathematically, such
approximation is the optimal approximation in term of
l2 norm measurement on the approximation error. After
that, the converted model already exhibits permuted diagonal
structure and then can be further re-trained/fine-tuned by
using Eqns. (2)-(6) to finally obtain a high-accuracy permuted
diagonal network model. Such two-step generating approach
is applied to all types of pre-trained models and can lead
to high accuracy. For instance, for pre-trained dense LeNet-5
model on MNIST dataset, with p = 4 for CONV layer and
p = 100 for FC layer, the finally converted permuted-diagonal
network after re-training achieves 99.06% test accuracy and
overall 40× compression ratio without using quantization.
Fig. 3: Train a PERMDNN from a pre-trained dense model.
G. PERMDNN vs Unstructured Sparse DNN
Compared to the existing network sparsification approaches,
the proposed PERMDNN enjoys several attractive advantages:
First, PERMDNN is a hardware-friendly model. As illustrated in Fig. 4, due to the inherent regular structure of
permuted diagonal matrix, the position of each non-zero entry
can now be calculated using very simple modulo operation6,
6As shown in Fig. 9, modulo circuit is simple by using LSB bits.
thereby completely eliminating the needs of storing the indices
of entries. From the perspective of hardware design, this elimination means that the permuted diagonal matrix-based PERMDNN completely avoids the huge space/computation overhead incurred by the complicated weight indexing/addressing
in the state-of-the-art sparse DNN accelerator (e.g. EIE), and
hence achieves significant reduction in the space requirement
and computational cost for DNN implementations.
Second, PERMDNN provides controllable and adjustable
compression and acceleration schemes. The reductions in
the model sizes and number of arithmetic operations are no
longer heuristic based and unpredictable. Instead it can now
be precisely and deterministically controlled by adjusting the
value of p. This further provides great benefits to explore
the design space exploring the tradeoff between hardware
performance and test accuracy.
Finally, PERMDNN enables direct end-to-end training
while preserving high accuracy. Since the structure of sparse
weight matrices of PERMDNN can now be pre-determined by
the model designers at the initialization stage of training, with
our training algorithm that preserves this fixed structure, the
entire structured sparse network can be trained from scratch,
completely avoiding the increasing complexity incurred by
the extra iterative pruning and/or re-training process in the
conventional unstructured sparse DNN training schemes.
Fig. 4: Storage requirement comparison.
H. PERMDNN vs CIRDNN
While PERMDNN and CIRDNN are both based on the
structured matrices, PERMDNN does not suffer from the
drawbacks of CIRDNN. Table VI compares the two methods.
Most importantly, PERMDNN uses simpler arithmetic computation. Different from complex number computation-based
CIRDNN, the computation of PERMDNN is purely based on
real numbers, thereby requiring significantly lower arithmetic
cost than CIRDNN with the same workload and same compression ratio.
Second, PERMDNN allows compression ratio to be flexibly adjusted. Different from CIRDNN, the computation in
PERMDNN does not have any restrictions on the size of
component permuted diagonal matrix. Therefore, the hardware
architecture of PERMDNN can support different compression
ratios based on the needs. This makes PERMDNN more
attractive for a wide range of applications.
Finally, the fundamental distinction is that PERMDNN can
fully utilize input sparsity. Since the computation of PERMDNN is in the time domain, the important input sparsity can
194
still be leveraged by PERMDNN to further reduce computational cost and power consumption. Because sparsity of input
vectors widely exists in numerous applications, this benefit
greatly expands the advantage of PERMDNN over CIRDNN.
TABLE VI: Advantages of PERMDNN over CIRCNN.
CIRCNN PERMDNN
Arithmetic Operation Complex number-based Real number-based
Flexible Compression No Yes
Utilize Input Sparsity No Yes
IV. PERMDNN: ARCHITECTURE
In this section, we develop the PERMDNN architecture
based on the proposed structure and algorithms. Similar to
most existing DNN accelerators [19] [20] [14], the PERMDNN
architecture is designed for inference tasks.
A. Data Mapping and Processing Scheme
In general, the proposed computing engine is a scalable
array of processing elements (PEs). Each PE performs the
forward propagation on part of the weight matrix. Different
PEs perform independent and parallel computations to maximize the processing throughput. Fig. 5 illustrates this partition
scheme on an 8-by-8 block-permuted diagonal weight matrix
with p = 4. We can see that the 4-by-4 permuted diagonal subweight matrices belonging to the same block row are processed
by the same PE7. To support such arrangement, the non-zero
entries of these sub-matrices are stored in each PE’s associated
SRAM. Therefore, the entire weight matrix of the FC layer is
stored in a distributed manner across multiple SRAM banks
to enable parallel processing of multiple PEs.
Besides, in order to fully utilize the potential dynamic
sparsity in the input vector x (also the activation vector output
y from previous layer), the entire PERMDNN adopts columnwise processing style. Specifically, as illustrated in Fig. 5, in
each clock cycle all PEs perform the multiplications between
xi, the non-zero entry of x, and wi, the corresponding column
vector of weight matrix W. The products are then accumulated
for updating the intermediate values of the corresponding
entries in the output vector a. After all the non-zero entries
of current wi have been multiplied with xi, the PEs will then
move on to perform the multiplications between xj and wj,
where xj is the next non-zero entry that follows xi in the
x. After all the xj and wj have been processed, the final
calculated values of all the entries of output vector a are
available simultaneously. Obviously, by adopting this columnwise processing scheme, the computations that are involved
with zero entries of x can be completely skipped, thereby
leading to significant saving in energy consumption when there
exists non-negligible sparsity in x.
7In general, each PE can be in charge of multiple permuted diagonal
matrices along column direction.
B. Overall Architecture
Based on the data mapping and processing scheme, the
overall architecture of PERMDNN computing engine is shown
in Fig. 6. The entire design consists of an array of NP E
PEs that perform the kernel M × V operations and the nonlinear activation operations. After all the yi’s, the entries of
output activation vector y for the current FC layer, have been
calculated and stored in the PEs, they are then written to
the activation SRAM. The writing operation is performed
in a group-writing manner: the entire activation SRAM is
partitioned into NACTMB banks, where each SRAM bank is
in charge of the yi’s from NACC /NP E PEs. In each clock
cycle, among all the PEs that belong to the same SRAM
bank, one of them outputs WACTM/q activation values yi’s to
its corresponding SRAM bank, where WACTM and q are the
width of activation SRAM and the bit-width of yi, respectively.
Consider there are in total NACTMBWACTM/q yi’s that are
simultaneously written to the activation SRAM in one cycle.
An activation routing network is designed to ensure each yi is
correctly written to the target position in the activation SRAM.
In the reading phase of activation SRAM, as described in
Section IV-A, each time only one non-zero activation value xi
is fetched and broadcasted to all the PEs. To achieve that, with
the help of control signals from main controller, an activation
selector is designed to select the correct xi from multiple
activation SRAM banks. After the examination from a zerodetector, the non-zero xi is then sent to an activation FIFO for
its broadcast to PE arrays. The purpose of using this activation
FIFO is to build up a backlog for the non-zero xi’s, thereby
ensuring that the PEs can always receive their required xi for
the current computation in time.
C. Processing Element
Fig. 7 shows the inner architecture of the PE. Here, each
PE is equipped with its own SRAM that stores the non-zero
entries of part of block-permuted diagonal weight matrices.
Similar to EIE, a weight lookup table (LUT) is located in the
PE to support weight sharing strategy [15] if needed. In that
case, the weight SRAM of the PE stores the virtual weight tag
(or so-called clustered class) that each actual weight has. After
being decoded by the weight LUT, NMUL actual weights are
multiplied with the input xi and the products are sent to a
group of accumulators in each clock cycle. Because each PE
is equipped with NACC accumulators, which corresponds to
NACC rows of weight matrix that one PE is in charge of,
NMUL accumulation selectors are designed to ensure those
products are routed to the target accumulators. Specifically, as
it will be elaborated in detail later, the permutation parameters
of the corresponding permuted diagonal weight sub-matrices
are used to enable very low-cost selection. For each selector,
it is associated with its own accumulator bank, and each
accumulator bank contains g = NACC /NMUL accumulators
that always contain a target accumulator for the input product.
After all PEs finish their processing for the current column
of weight matrix, the calculated ai’s in the accumulators are
sent to the activation units (ActU) to produce yi’s. Here, each
195
Fig. 5: Example column-wise processing procedure with input zero-skipping scheme.
Fig. 6: Overall architecture of PERMDNN hardware.
activation unit can be reconfigured to act as either Rectified
Linear Unit (ReLU) or hypertangent function (tanh(·)) unit
to support the needs of different applications.
Fig. 7: Inner architecture of PE.
Weight SRAM. To reduce the read/write energy consumption for the weight SRAM, we further break the weight SRAM
bank of each PE into multiple weight SRAM sub-banks. By
adopting this strategy, in each cycle only one weight SRAM
sub-bank is selected while the others are disabled to save
energy. Accordingly, in order to achieve the full utilization of
all the multipliers in most cases, the width of all the weight
SRAM sub-banks is selected to ensure that each row of every
SRAM sub-bank at least contains NMUL weight entries.
Besides, to accommodate the column-wise processing
scheme and the block-permuted diagonal structure of weight
matrix, the non-zero weight is specially arranged in the weight
SRAM of each PE. Fig. 8 illustrates the data allocation in
one weight SRAM sub-bank for one block-permuted diagonal
weight matrix. Here, each row of the weight SRAM sub-bank
stores the non-zero entries of the same column of the weight
matrix. By adopting this transpose-like data layout, each row
access to the weight SRAM sub-bank can fetch the required
data for column-wise data processing. Because each column
of one permuted diagonal sub-matrix only has one non-zero
entry, each PE always receives and processes the same number
of non-zero weights, thereby completely eliminating the risk
of load imbalance that prior work [14] may suffer from.
Fig. 8: Data allocation in weight SRAM
Accumulation Selector & Bank. Since the number of
accumulators (NACC ) is typically much larger than that of
multipliers (NMUL) in each PE, accumulation selectors are
required to route the outputs of multipliers to the target
accumulators. As shown in Fig. 9, an accumulation selector
consists of two parts, an index calculator and an array of reconfigurable comparators and multiplexers. The index calculator
is used to calculate the correct row index of the non-zero entry
in the permuted diagonal sub-matrix that the current PE is in
charge of. Specifically, due to the unique structure of permuted
diagonal matrix, such calculation is essentially the modulo
operation between the sum of permutation value and column
index and the size of permuted diagonal matrix p; and hence it
can be easily implemented using a circuit consisting of b-width
196
adder, subtractor and comparator, where b = ceil(log2 p) and
ceil(·) is the ceiling function. After the row index is calculated,
among the bank of accumulators, the target accumulator is first
identified by the array of comparators and multiplexers, and
then it is updated using the output of the multiplier.
Fig. 9: Inner architecture of accumulation selector and bank.
Permutation SRAM. The permutation values (PermVs)
sent to accumulation selectors are provided by permutation
SRAM. Different from weight SRAM and activation SRAM,
in each PE the permutation SRAM consists of a single
bank instead of multiple partitions. In addition, each row of
permutation SRAM contains multiple permutation values to
support the computation in different accumulation selectors.
Given that the bit-width of permutation value is typically small
(as log2 p), the width of permutation SRAM is not very large.
D. Design for Flexibility
Because the value of p and network size vary with models,
the PE of PERMDNN is designed to provide flexibility for
different needs. In general, designing a flexible PE involves
the considerations of several factors: NACC , the number of
accumulators in each PE; NMUL, the number of multipliers
in each PE; NROW P E = m/NP E, the number of rows that
each PE is in charge of; and p. In the following, we describe
the computation scheme of PE in three cases.
Case 1. NROW P E ≥ pNMUL and NACC ≥ NROW P E. In
this case, since NACC ≥ NROW P E, each PE has sufficient
registers to store all the calculated yi’s which it is in charge
of. Meanwhile, consider in each cycle one PE processes
NMUL size-p permuted diagonal sub-matrices and identifies
NMUL non-zero entries among pNMUL rows. Therefore, only
pNMUL comparators of one PE are activated to identify the required row indices of non-zero entries. This means that in each
accumulation selector of Fig. 9 only p out of NACC /NMUL
comparators and the corresponding multiplexers are used in
each cycle. Therefore, if we denote NROW P E = k(pNMUL)+
d, where d ≡ NROW P E mod k(pNMUL), then at the i-th
cycle of every k cycles, only (p(i − 1) + 1)-th to (pi)-th
comparators and multiplexers in Fig. 9 are activated to identify
the target register that should be updated. In other words,
different p copies of comparators, selectors and accumulators
of Fig. 9 are activated sequentially. Notice that because
NROW P E = k(pNMUL) + d and NACC ≥ NROW P E,
PEs always have enough hardware resource to continuously
process the current column of weight matrix, and it takes k
(for d = 0) or (k + 1) (for d > 0) cycles to fully process one
column. For instance, assume we have 2 PEs with NMUL = 1
and NACC = 4 to process an 8-by-8 weight matrix with p = 2.
Then as shown in Fig. 10(a), it takes two cycles to process
one column and such column-wise processing is continuous.
Case 2. NROW P E ≥ pNMUL and NACC < NROW P E.
In this case, since NROW P E = k(pNMUL) + d, there must
exist an integer f ≤ k that satisfies f(pNMUL) ≤ NACC <
(f + 1)(pNMUL). Therefore, after f cycles of sequential
activation described in Case 1, at the (f + 1)-th cycle the
inactivated accumulation selectors and accumulators in Fig.
9 are not sufficient for future processing. Accordingly, as
illustrated in Fig. 10(b) with p = 3, the overall computation
scheme needs to be changed for this case: all the other
columns need to be first partially processed to calculate part
of yi’s. Then the accumulators that were once allocated for the
previously calculated yi’s are released and used to perform the
rest unfinished computation. Such procedure may need to be
repeated for many times if f is much smaller than k.
Case 3. NROW P E < pNMUL. This is a very rare case since
the number of PEs should be properly determined to ensure
each multiplier is in charge of at least one permuted diagonal
sub-matrix. When such case occurs, it means that p is very
large (a very sparse model) and some of the PEs become
redundant. To solve this problem, we need to change the
original single column-processing scheme: different PEs can
now process multiple columns simultaneously. Consequently,
this strategy leads to two benefits: 1) increase the overall
throughput; and 2) equivalently improve NROW P E for each
column processing, and thereby transforming this case to the
aforementioned Case 1 or 2.
V. EVALUATION
A. Experimental Methodology
Simulation and CAD Tools. We developed a cycle-accurate
bit-accurate simulator to model the functional behavior of
PERMDNN architecture. This simulator also serves as the
golden reference for the correctness of Verilog implementation. After verifying the RTL model via validating its outputs
against the outputs of the simulator, we synthesized our design
using Synopsis Design Compiler with CMOS 28nm library.
Here the switching activity was extracted from simulation and
we annotated the toggle rate to the gate-level netlist. For place
and route, we used Synopsis IC compiler to generate layout
(see Fig. 11). The power consumption was estimated using
Prime-Time PX. Notice that the area and power consumption
of SRAM part, including weight SRAM, activation SRAM and
permutation SRAM, were estimated and reported by Cacti.
Benchmarks. Our evaluation uses a set of PERMDNN
models with the FC layer described in Section III-D. Specifically, similar to EIE, we evaluate the FC layers of these
compressed sparse models individually, and the layers with
197
(a) Computation scheme with p = 2.
(b) Computation scheme with p = 3.
Fig. 10: Example computation schemes for a 2-PE PERMDNN with NMUL = 1 and NACC = 4 for an 8-by-8 weight matrix.
Fig. 11: Layout of one PE using CMOS 28nm technology.
different sizes are viewed as different workloads. Accordingly,
the information of six benchmark layers, including the sizes,
constant weight sparsity ratio and statistically calculated activation sparsity ratio8, are listed in Table VII.
B. Design Configuration & Hardware Performance
Design Configuration. Table VIII lists the design configuration parameters for PE and the overall PERMDNN
8Lower sparsity ratio means more sparsity.
9The weight matrices of NMT model have three types of shapes.
TABLE VII: Information of evaluated FC layers.
Layer Size Weight Activation Description
Alex-FC6 4096, 9216 10% (p=10) 35.8% CNN model
for image
classification
Alex-FC7 4096, 4096 10% (p=10) 20.6%
Alex-FC8 1000, 4096 25% (p=4) 44.4%
NMT-1 2048,1024 12.5% (p=8) 100% RNN model
for language
translation
NMT-2 2048, 1536 12.5% (p=8) 100%
NMT-39 2048, 2048 12.5% (p=8) 100%
computing engine. Here one PE is equipped with eight 16-
bit multipliers and 128 24-bit accumulators. In addition, each
PE is also designed to contain 16 × 32 bit×2048 = 128KB
weight SRAM and 48bit×2048 = 12KB permutation SRAM.
It should be noted that the sizes of SRAM are selected by
using the over-design strategy to ensure the architecture can
support a wide range of applications. For instance, by using
4-bit weight sharing strategy a 32-PE PERMDNN computing
engine can store a compressed layer with 8M parameters,
which has the double size of the famous large-size compressed
VGG FC6 layer [32]. Similarly, the activation SRAM is also
designed with large capacity to facilitate the execution on
very large models. As illustrated in Table VIII, the activation
SRAM in this design has 8 × 64bit×2048 = 128KB, which
corresponds to a 16-bit 64K-length vector. Such large size is
usually sufficient for the FC layers in most practical models.
Hardware Performance. Table IX shows the power and
area breakdowns for one PE and overall PERMDNN computing engine. It is seen that each PE occupies 0.271mm2
and consumes 21.874mW. For the overall 32-PE computing
engine, it occupies 8.85mm2 and consumes 703.4mW, where
the PE array is the most resource-consuming part (99.5%
power and 97.9% area).
Regarding the throughput, being equipped with 32 PEs
198
TABLE VIII: Design configuration parameters.
PE Parameter Value
Multiplier Amount (NMUL) 8
Width 16 bits
Accumulator Amount (NACC ) 128
Width 24 bits
Weigth SRAM
sub-Banks
Amount 16
Width 32 bits
Depth 2048
Permutation SRAM Width 48 bits
Depth 2048
PERMDNN Computing Engine Parameter Value
Amount of PEs (NP E) 32
Quantization scheme 16 bits
Weight sharing strategy 4 bits
Number of pipeline stages 5
Activation
SRAM Bank
Amount (NACTMB) 8
Width (WACTM) 64 bits
Depth 2048
Activation FIFO Width 32 bits
Depth 32
running at 1.2GHz, the PERMDNN computing engine can
achieve 614.4GOPS for a compressed DNN model. For the
equivalent processing power on dense model, since it varies
with different compression ratios, we adopt a pessimistic
conversion scheme of assuming 8× weight sparsity and 3×
activation sparsity. Consequently, the equivalent application
throughput of PERMDNN achieves 14.74TOPS. Notice that
our selected conversion scheme is quite conservative. For
instance, EIE adopts conversion scheme of assuming 10×
weight sparsity and 3× input sparsity, which is more optimistic
than ours.
TABLE IX: Power and area breakdowns.
Component Power (mW) Area (mm2)
PE Breakdown
Memory 3.575 (16.35%) 0.178 (65.68%)
Register 4.755 (21.74%) 0.01 (3.69%)
Combinational 10.48 (47.91%) 0.015 (5.53%)
Clock Network 3.064 (14.00%) 0.0005 (0.18%)
Filler Cell 0.0678 (25.02%)
Total 21.874 0.271
Power (mW) Area (mm2)
PERMDNN Computing Engine Breakdown
32 PEs 700 8.67
Others 3.4 0.18
Total 703.4 8.85
C. Comparison with EIE and CIRCNN
In this subsection we compare PERMDNN with two most
relevant compressed DNN-oriented architectures: EIE and
CIRCNN. The reasons for selecting these two works as
reference are: 1) similar to PERMDNN, EIE is a type of FC
layer-targeted DNN architecture and it is the state-of-the-art
design in this category; 2) similar to PERMDNN, CIRCNN
also imposes structure to the weight matrix of DNN to gain
improved hardware performance.
Comparison with EIE. Table X summarizes the hardware
parameters and performance of EIE and PERMDNN. For fair
comparison, our design adopts the weight sharing strategy and
quantization scheme that are the same to EIE’s configuration.
Also, because EIE uses a different technology node from ours
(45nm vs 28nm), we adopt the scaling strategy used in EIE
to project EIE to the same 28nm technology.
TABLE X: Comparison of EIE and PERMDNN.
Design EIE PERMDNN
Number of PEs 64 32
CMOS Tech. 45nm
(reported)
28nm
(projected)10 28 nm
Clk. Freq. (MHZ) 800 1285 1200
Memory SRAM SRAM
Weight Sharing 4 bits 4 bits11
Quantization 16 bits 16 bits
Area (mm2) 40.8 15.7 8.85
Power (W) 0.59 0.59 0.70
Fig. 12 compares the hardware performance of EIE and
PERMDNN on executing three FC layers of AlexNet12 in
terms of speedup, area efficiency and energy efficiency. It
can be seen that compared with the projected EIE using
28nm, PERMDNN achieves 3.3× ∼ 4.8× higher throughout,
5.9× ∼ 8.5× better area efficiency and 2.8× ∼ 4.0×
better energy efficiency on different benchmark layers. As
analyzed in Section III-G, such improvement is mainly due
to the elimination of unnecessary storage for weight index,
inconvenient address calculation and load imbalance.
Comparison with CIRCNN. Table XI summarizes the
hardware performance of CIRCNN and PERMDNN. Again,
for fair comparison we project CIRCNN to the same 28nm
technology. Notice that because CIRCNN reported synthesis
results, here in Table XI the listed performance characteristics
of PERMDNN are also from synthesis reports. Meanwhile,
because CIRCNN only provides power and throughput information, we compare our PERMDNN and CIRCNN on overall
throughput (TOPS) and energy efficiency (TOPS/W). Table
XI shows that PERMDNN achieves 11.51× higher throughput
and 3.89× better energy efficiency.
As discussed in Section III-H, compared with CIRCNN the
PERMDNN enjoys the benefits of utilizing input sparsity and
real-number arithmetic computation. Because the architecture
of PERMDNN and CIRCNN are quite different, and the two
implementations have their individual design configurations
(e.g., compression ratios, size of SRAM, number of multipliers
etc.), the contributions of these two advantages to the overall
performance improvement are analyzed roughly as follows:
1) Because the utilization of dynamic input sparsity can
bring linear reduction in computational cost, if all the other
factors that affect throughput and energy efficiency, including
compression ratio, clock frequency, number of multipliers
and power, were the same for PERMDNN and CIRCNN
designs, 3× input sparsity of PERMDNN would enable about
3× increase of throughput and energy efficiency; 2) For the
simplicity of real number arithmetic computation, recall that a
10The projection follows rule in [14]: linear scaling for frequency, quadratic
scaling for area and constant power scaling. 11Our experiments show 4-bit weight sharing does not cause accuracy drop.
12They are the benchmark layers that both EIE and PERMDNN evaluate.
199
complex multiplication consists of 4 real multiplications and
2 real additions. Also, notice that performing inference on
the same-size compressed weight matrix (e.g., p-by-p), the
permuted diagonal matrix-based approach needs p real multiplications, while circulant matrix-based method requires p
complex multiplications in element-wise multiplication phase
plus plogp constant complex multiplications in FFT/IFFT
phases, Therefore, when the compression ratio is the same, the
use of real-number arithmetic computation can roughly bring
about 4× reduction in computational cost, which can translate
to a significant improvement in hardware performance.
D. Scalability
As the size of weight matrix of FC layer grows, it is easy to
scale up PERMDNN by adding more PEs. In general, thanks
to block-permuted diagonal matrix’s unique characteristic of
even distribution of non-zero entries along row and column
directions, PERMDNN enjoys strong scalability since the load
imbalance problem [14] that challenges other sparse DNN
accelerators does not exist for PERMDNN at all. Fig. 13
shows the speedup of PERMDNN architecture using different
numbers of PEs. We see that our design achieves very good
scalability on all benchmarks.
TABLE XI: Comparison of CIRCNN and PERMDNN. Both
results are from synthesis reports.
Design CIRCNN PERMDNN
Number of PEs N/A 32
CMOS Tech. 45 nm
(reported)
28 nm
(projected) 28 nm
Clk. Freq. (MHZ) 200 320 1200
Quantization 16 bits 16 bits
Area (mm2) N/A N/A 6.64
Power (W) 0.08 0.08 0.236
Throughput
(Equivalent TOPS) 0.8 1.28 14.74
(11.51×)
Energy Efficiency
(Equivalent TOPS/W) 10.0 16.0 62.28
(3.89×)
VI. RELATED WORK
Besides EIE and CIRCNN, various works have been reported for exploring high-performance DNN design. Diannao
family [33]–[38] and Google’s TPU [25] propose a series
of DNN processors and the corresponding instruction sets.
In [19]–[22], [39]–[41], several sparse DNN accelerators are
investigated. Considering the importance of meomory in highperformance DNN hardware, [42]–[46] extensively study better utilization of memory in DNN.
Among the research effort on data flow in DNN, [47]–
[49] propose optimized data flow to provide high flexibility
or reduce memory access. Also, [50]–[52] investigate highperformance DNN hardware using bit-serial inputs. Besides,
various FPGA-based DNN designs have been implemented
and reported, including [53]–[59].
Beyond the research works on digital accelerators for inference tasks, DNN hardware using analog or mixed-signal circuits [60]–[65] are also the potential high-efficiency solutions
for deploying deep learning. Considering training is a very
time-consuming process, several architecture-level approaches
are proposed in [66]–[71] to improve the efficiency of training.
DNN model compression is also an active research topic in
machine learning community. Various approaches, including
pruning [15], low rank decomposition [17], quantization [72]
[73], structured matrix [74] and clustering [75], have been
proposed in prior works. [76] presents a survey of different
compression techniques.
VII. CONCLUSION
This paper proposes PERMDNN, a novel approach to generate and execute hardware-friendly structured sparse DNN
models using permuted diagonal matrices. Compared with
prior model compression approaches, PERMDNN enjoys the
benefits of regularity, flexibility and simple arithmetic computation. We then propose PERMDNN architecture, a scalable
FC layer-targeted computing engine. Implementation results
show PERMDNN achieves 3.3× ∼ 4.8× higher throughout,
5.9× ∼ 8.5× better area efficiency and 2.8× ∼ 4.0× better
energy efficiency than EIE. It also achieves 11.51× higher
throughput and 3.89× better energy efficiency than CIRCNN.