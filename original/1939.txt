Abstract‚ÄîAs a powerful unsupervised learning method, Generative Adversarial Network (GAN) plays an important role in
many domains such as video prediction and autonomous driving.
It is one of the ten breakthrough technologies in 2018 reported in
MIT Technology Review. However, training a GAN imposes three
more challenges: (1) intensive communication caused by complex
train phases of GAN, (2) much more ineffectual computations
caused by special convolutions, and (3) more frequent off-chip
memory accesses for exchanging inter-mediate data between the
generator and the discriminator.
In this paper, we propose LerGAN1
, a PIM-based GAN
accelerator to address the challenges of training GAN. We first
propose a zero-free data reshaping scheme for ReRAM-based
PIM, which removes the zero-related computations. We then
propose a 3D-connected PIM, which can reconfigure connections
inside PIM dynamically according to dataflows of propagation
and updating. Our proposed techniques reduce data movement
to a great extent, avoiding I/O to become a bottleneck of
training GANs. Finally, we propose LerGAN based on these two
techniques, providing different levels of accelerating GAN for
programmers. Experiments shows that LerGAN achieves 47.2√ó,
21.42√ó and 7.46√ó speedup over FPGA-based GAN accelerator,
GPU platform, and ReRAM-based neural network accelerator
respectively. Moreover, LerGAN achieves 9.75√ó, 7.68√ó energy
saving on average over GPU platform, ReRAM-based neural network accelerator respectively, and has 1.04√ó energy consuming
over FPGA-based GAN accelerator.
I. INTRODUCTION
Tremendous success has been fueled by supervised deep
learning in image classification, speech recognition, and so
on [31] [58] [33] [60] [50] [22] [25]. However, non-trivial
amount of training datasets with millions of lables prevents
high-accuracy supervised deep learning from being employed
in many domains where massive labels are either unavailable
or costly to collect through human effort.
*This work is supported by the National Major Project of Scientific
Instrument of National Natural Science Foundation of China (Grant
No.61327902), National Key Research & Development Projects of China
(Grant No.2018YFB1003301), and in part by NSF grants 1822989, 1822459,
1527535, 1423090, and 1320100.
‚àó‚àóJiwu Shu is the corresponding author of this paper. 1 ‚ÄùLer‚Äù comes from removing ‚Äùo‚Äù from ‚Äùzero‚Äù which represents removing 0,
and changing ‚Äùz‚Äù to ‚Äùl‚Äù to represent shortening wire connection.
By automatically generating richer synthetic datasets without labeling data sets, semi-supervised learning [9] [27] and
unsupervised learning [24] [20] [17] are promising to extend
the intelligence of deep learning. On the frontier, GAN is
the most popular unsupervised learning method, effectively
working in many domains, such as video prediction [20],
autonomous driving [21] and photo resolution upgrading [34].
Though GAN is powerful to generate items without labeling
training sets by human, its network structure is more complex
than traditional NN‚Äôs to efficiently execute on hardware. The
generator model and discriminator model of GAN collaboratively work in a minimax manner, to achieve stronger GAN
with higher accuracy. To uphold the interaction between the
two models, massive amount of intermediate data is required
to be communicated between the two models frequently. Since
there are quite limited on-chip memory space to store intermediate data, GAN training will introduce additional pressure on
off-chip memory accesses, which consume nearly two orders
of magnitude more energy than a floating point operation [19].
Thus, these huge data movements become a bottleneck of the
system design for GAN.
To solve the memory wall problem in GAN training,
researchers proposed ReRAM-based Processing In Memory (PIM) [39] [15] [56] [7] [59], which exhibits energy
efficiency in reducing memory access cost compared with
CPUs and GPUs. Besides, it can complete a Matrix-MultiplyVector (MMV) operation in almost only one read cycle with
low energy consumption. Since MMV operations dominate the
computation patterns in GAN training, ReRAM-based PIM
technologies have the potential to reduce memory access cost
and accelerate GAN training efficiently.
However, GAN has two main features which are different
from traditional neural networks: (1) zero-insertion during
training phase; (2) complex dataflow patterns between the
two models. These two features degrade the efficiency of
PIM-based accelerator for GAN. First, zero-insertion adds a
heavy burden on storage. Also, I/O traffic becomes the system
bottleneck because, (1) the interaction between generator and
discriminator requires more communication via I/Os in PIM.
669
2018 51st Annual IEEE/ACM International Symposium on Microarchitecture
978-1-5386-6240-3/18/$31.00 ¬©2018 IEEE
DOI 10.1109/MICRO.2018.00060
(2) complex dataflow of GAN exists irregular data dependencies. Therefore, limited I/O bandwidth stalls GAN training.
To address these challenges in PIM-based GAN architecture, we first propose a novel, software-managed Zero Free
Data Reshaping (ZFDR) scheme to remove all the zero-related
operations produced by GAN. Then, a reconfigurable 3D
connection architecture is proposed, which not only efficiently
fits complex dataflows of GAN, but also supports efficient
ReRAM reads and writes and hides the I/O overhead to a great
extent. Putting ZFDR and reconfigurable 3D interconnection
architecture together, we propose LerGAN, a ReRAM-based
3D connection GAN accelerator, which carefully maps the
data processed by ZFDR to the 3D-connected PIM. By doing
so, it not only achieves higher I/O performance, but also
enables flexibly I/O connection configuration for the complex
dataflows in GAN training. Experiments shows that LerGAN
achieves 47.2√ó, 21.42√ó and 7.46√ó speedup over FPGA-based
GAN accelerator, GPU platform and ReRAM-based neural
network accelerator respectively. Moreover, LerGAN achieves
9.75√ó, 7.68√ó energy saving on average over GPU platform,
ReRAM-based NN accelerator respectively, and has 1.04√ó
energy overhead over FPGA-based GAN accelerator.
The main contributions of this paper are as follows:
(1) We elaborate three steps of zero-inserting that enable
transposed convolution operations in GAN and further analyze
the amount of zeros in GAN training. To address problems
caused by massive zeros in ReRAM-based PIM, we propose
Zero-Free Data Reshaping (ZFDR) to remove zero-related
operations. ZFDR is flexible to support different paddings,
strides and kernel sizes, capable of handling both existing
GANs and future GANs with larger stride (e.g. stride of 3).
(2) We present the dataflows of training GAN in detail and
propose a novel reconfigurable 3D-connected PIM to handle
the complicated dataflows. Our 3D connection supports efficient data transferring of both propagation and updating. It is
worth mentioning that, to the best of our knowledge, we are
the first to study efficient connections in ReRAM-based PIM.
(3) We propose LerGAN based on ZFDR and 3D-connected
PIM. We make slight modifications on the software (via
providing interfaces for ZFDR) and memory controller (via
creating a finite-state machine for data mapping and configuration of switches) to enable LerGAN to combine ZFDR and
3D-connected PIM well. Also, we enable programmers to use
heterogeneous levels of acceleration according to demands.
The rest of this paper is organized as follows. We first introduce ReRAM-based PIM and GAN in Section II. Then we analyze the challenges of using PIM to accelerate GAN training
in Section III. We present our ZFDR and 3D-connected PIM
in Section IV. The design of LerGAN which employs ZFDR
and 3D-connected PIM is in Section V. Section VI evaluates
the proposed algorithms, 3D-connected PIM and LerGAN
system. Finally, we present related works and conclusions in
Section VII and Section VIII respectively.
(b) Data mapped in Crossbar
i1
i2
i3
i4
w11 w12 w13 w14
w24
w34
w44
w23
w33
w43
w22
w32
w42
w21
w31
w41
o1 o2 o3 o4
ReRAM cell
i1 i2 i3 i4 o1o2 o3 o4
w11 w12 w13 w14
w24
w34
w44
w23
w33
w43
w22
w32
w42
w21
w31
w41
( ) () =
(a) MMV
DAC
S&H ADC
Fig. 1. Mapping MMV to ReRAM Crossbar.
 

 




"
"
 

 
 
 


"

 



 
 
 


 

 




"

 



 

 


"
"   






















 

 



 
 

!





# 

"






     !  "
"  



 
 


 
 
"
"












 

	




Fig. 2. DCGAN Outline
II. BACKGROUND
This section first introduces ReRAM-based PIM and how
it can be utilized to implement NNs efficiently, then presents
GAN and its features.
A. ReRAM-based PIM
ReRAM stands out from other non-volatile memories
(NVMs) since it has high density, low write latency (less
than 10% performance degradation, compared to an ideal
DRAM) [65], and low write energy (up to 72% lower than
DRAM) [46]. Moreover, it has high endurance (> 1010 [35]
[36], up to 1012 [36] [26], much higher than that of PCM ,
which is 107 ‚àº 108 [53]). If a network needs to be trained for
105 times [42], ReRAM-based PIM can train 105 ‚àº 107 such
networks. Due to these benefits of ReRAM, recent studies [15]
[56] [59] [14] modify it as the hardware of PIM to accelerate
the inference and training of NNs.
ReRAM-based PIM consists of ReRAM arrays and peripheral circuits. Note that, ReRAM arrays can be configured to
either support MMVs (called CArrays in this paper), or be
used as traditional storage (called SArrays in this paper). When
ReRAM arrays are configured as CArrays, they store weights
of NNs and conduct MMVs by feeding corresponding inputs
(briefly shown in Fig.1). ReRAM-based PIM also has buffer
which is composed of ReRAM cells and connected to CArrays
directly. Such buffer is called BArray and enables CArray to
access it randomly, hiding the memory access time when performing computation [15]. Equipped with CArrays, BArrays
and peripheral circuits to support various basic computations,
ReRAM-based PIM can be used to accelerate NNs efficiently.
B. Generative Adversarial Network
The Generative Adversarial Network (GAN) consists of two
components: a discriminator and a generator. The discriminator learns to decide whether a sample is from the real
data set or the generator. The generator aims to generate a
sample close to the real data to confuse the discriminator.
Therefore, in GAN, the two components play a minimax game
670
G D G D
Errors
Gw Dw Gw Dw
G D G D
Forward
Backward
Error 
transferring
 Weight
calculation
Train Discriminator Train Generator
m Noises m Fakes
m Reals m Noises m Fakes
Fig. 3. Dataflows of Training Discriminator and Generator of DCGAN
to compete with each other iteratively. A minibatch stochastic
gradient descent method can be used to train this model, where
in each training iteration, a minibatch of m noise samples
{n1, n2, ..., nm} and m true examples {x1, x2, ..., xm} are
sampled from a prior noise distribution pe(n) and real data
distribution pd(x), respectively. We use G(n; Œ∏g) to denote
the generative model that generates samples from noises with
parameters Œ∏g and D(x) to denote the discriminative model
that represents the probability that x comes from the real
data distribution pd(x). In order to optimize the discriminator,
it needs to be updated by ascending its stochastic gradient
using Equation 1, which means that the discriminator can
assign correct labels to both training examples from D and
samples from G. In order to maximize the generator, GAN
uses Equation 2 to update it by descending its gradient, which
tries to confuse the discriminator to predict the samples as
data from the real data distribution. In conclusion, GAN will
converge eventually so that the generator can generate an
example which is similar to a real one.
‚àáŒ∏d
1
m
m
i=1
[log D(xi) + log(1 ‚àí D(G(ni)))] (1)
‚àáŒ∏g
1
m
m
i=1
log(1 ‚àí D(G(ni))) (2)
We take the most popular Deep Convolutional Generative
Adversarial Network (DCGAN) [54] as an example to further
introduce GAN. The framework of DCGAN is shown in Fig.2.
There are some differences between traditional Convolutional
Neural Network (CNN) and DCGAN in training phase. In
forward propagation phase of discriminator, DCGAN employs
strided convolution (S-CONV) instead of pooling. As shown in
Fig.2, the generator has an inverse structure of discriminator,
and it employs transposed convolution (T-CONV) in forward
propagation phase.
Symbol Description
Wl Kernel weights for l-th layer
‚àáWl Derivative of kernel weights for l-th layer
zl Value of (Wl)T x + b
‚àázl Derivative of z for l-th layer
g Active function
al Value of g(zl)
TABLE I
NOTATIONS USED FOR EXPLANATION OF TRAINING DCGAN.
Fig.3 shows dataflows of training DCGAN and Table I
shows notations for explanation of training DCGAN. Overall,
training DCGAN involves two major parts: one is forward
propagation and the other is backward propagation. The backward propagation has two main sub-tasks: error transferring
and ‚àáweight calculation. When training the discriminator, the
(c) Pad zeros
(a) Insert zeros 
between each input (b) Add zeros outside
Original input
Input Zero
1024
‚Ä¶
1024
‚Ä¶
1024
‚Ä¶
1024
‚Ä¶
Fig. 4. Steps of Adding Zeros in Inputs of CONV1.
generator produces m fake samples using m noises (m is the
batch size and a noise (input) is denoted as a vector with
100 elements shown in Layer1 of Fig.2). This step is denoted
by ‚àí‚ÜíG, where DCGAN conducts T-CONV. Then, one batch
of real samples and one batch of fake samples are fed into
the discriminator. This step is denoted by ‚àí‚ÜíD, where DCGAN
conducts S-CONV. Next, DCGAN computes the error of
output layer ‚àázL using the loss function Equation 1, where
L is the last layer of the discriminator. After that, DCGAN
feeds ‚àázL back to the network and begins the backward
propagation, which consists of two stages ‚Üê‚àí
D and ‚Üê‚àí
Dw. Firstly,
‚àázL is fed back layer by layer in ‚Üê‚àíD using Equation 3 (‚àó
denotes an element-wise multiplication). Therefore, in ‚Üê‚àí
D, the
T-CONV takes ‚àázl+1 and zl cached by ‚àí‚ÜíD as inputs then
outputs ‚àázl
.
‚àázl = (Wl+1)
T ‚àázl+1 ‚àó g

(zl
) (3)
Conducting ‚Üê‚àíDw needs ‚àázl transfered by ‚Üê‚àíD and the intermediate al‚àí1 cached by ‚àí‚ÜíD. Equation 4 shows the computation in ‚Üê‚àí
Dw, denoted as W-CONV of discriminator since it is different
from both S-CONV and T-CONV.
‚àáWl = al‚àí1‚àázl (4)
After ‚Üê‚àí
Dw, the discriminator is updated with ‚àáWl
. When
training the generator, the generator generates m samples
and feeds them into the discriminator. After conducting ‚àí‚ÜíD,
according to the Equation 2, the error of the output layer in
discriminator is sent to ‚Üê‚àíD. With the intermediate zl cached by ‚àí‚ÜíD,
‚Üê‚àíD can calculate errors and send them to error propagation
of generator (denoted as ‚Üê‚àíG). With ‚àázl sent by ‚Üê‚àíG and the
intermediate al‚àí1 cached by ‚àí‚ÜíG,
‚Üê‚àíGw can calculate ‚àáWl of
generator. After that, the generator is updated with ‚àáWl
.
III. CHALLENGES OF PIM-BASED GAN ACCELERATOR
Although GAN has two networks, each of which resembles
CNN, it manifests some differences from traditional CNN.
In this section, we discuss challenges for PIM-based NN
accelerator to execute GAN.
A. Redundant Zero-Related Operations
Since DCGAN employs S-CONV, its training introduces
considerable zero-insertion, increasing burden on both storage
and bandwidth. In order to explain how redundant zeros are
introduced and restrain the efficiency, we first introduce some
notations used in this paper in Table II and take CONV1
of the generator in Fig. 2 as an example of T-CONV. As
671
1024
‚Ä¶
1024
‚Ä¶
‚Ä¶
1024
‚Ä¶
512
‚Ä¶
512
Inputs after adding zeros Weights
Corresponding outputs
Fig. 5. Convolution on Inserted Zeros Inputs with Stride of 1.
shown in Fig. 2, Iw = Il = 4 and Ow = Ol = 8. The
converse convolution of CONV1 is the same as CONV8 in
Discriminator, so S
= 2, S = 1, P
w = P
l = 2, Pw = Pl = 2.
Also, CONV1 and CONV8 have the same size of kernel
weight. To conduct CONV1, we first insert one zero between
every two adjacent input numbers horizontally and vertically
(Fig.4(a)), then add one zero at the end of input (Fig.4(b))
and finally use zero padding of 2 (Fig. 4(c)). After that, we
convolute it with 512 kernels, whose Ww = Wl = 5 and
Wh is 1024. Eventually, we obtain an output whose size is
8 √ó 8 √ó 512. In this example, we store and transfer 147456
input values while only 16384 of them are useful. Moreover,
we conduct 1638400 multiplications while 295936 of them are
useful, whose efficiency is only 18.06%.
Symbol Description
Iw, Il, Ih Width, length, height of input
Ow, Ol, Oh Width, length, height of output
Ww, Wl, Wh Width, length, height of kernel weight
Nw Number of kernel weights
S Stride size of convolution
S
Stride size of converse convolution
Pw, Pl Padding on width, length
P
w, P
l Padding on width, length of converse convolution
Niz w Number of insert zeros on width
Niz l Number of insert zeros on length
Nzero Number of zeros
TABLE II
NOTATIONS USED FOR EXPLANATION OF CONVOLUTION OPERATIONS.
In general, Iw = Il, Ow = Ol, Pw = Pl and P
w = P
l .
So we denote them as I, O, P and P
, respectively, and their
relationship is described in Equation 5.
O + 2P
‚àí W
S = (I ‚àí 1)¬∑¬∑¬∑ R (R is the remainder) (5)
Generally, to conduct a convolution in the generator, we first
insert S
‚àí1 zeros between every two input numbers, then we
add R zeros at the end and finally we use zero padding of P
(where P = W ‚àí P
‚àí 1). Based on the operations above, we
can calculate Niz w and Nzero.
Niz w = Niz l = (S

‚àí 1) √ó (I ‚àí 1) + R (6)
Nzero = (Niz w +Iw +Pw)√ó(Niz l +Il +Pl)‚àíIw √óIl (7)
From Equation 6 and Equation 7 we can observe that with the
increase of S
and P, the issue of redundant zeros in T-CONV
becomes more severe.
Similar to T-CONV, W-CONV of a generator needs to insert
zeros into inputs. However, W-CONV of a discriminator needs
Input
Weight Output
S = 2
Add Zero
S =1
Weight
Output
Fig. 6. An Example of W-CONV of Discriminator.
to insert zeros to both inputs and kernels. We take a W-CONV
connecting Layer11 and Layer10 in Fig.2 as an example. For
simplicity, we take one input feature map to illustrate the
difference of zero-insertion between W-CONV and T-CONV
in the example.
As shown in Fig.6, in the forward propagation, given a 8√ó8
input, we first pad it with 2, then convolve it with a 5√ó5 kernel,
and finally obtain a 4√ó4 output. In the backward propagation,
we denote ‚àáOutput as dz in Equation 3, whose shape is the
same as the output. We first insert zeros to ‚àáOutput and regard
‚àáOutput as a kernel weight. Then, we convolute the given 8√ó8
input with the kernel weight to obtain ‚àáWeight.
For W-CONV of the discriminator, the relationship between
input and output can be described as Equation 8.
I + 2P ‚àí W
S = (O ‚àí 1)¬∑¬∑¬∑ R (R is remainder) (8)
Furthermore, the relationship between Niz w and Niz l of the
kernel weight can be described as Equation 9.
Niz w = Niz l = (S ‚àí 1) √ó (O ‚àí 1) + R (9)
According to Fig.6, Nzero in W-CONV of the discriminator
equals to the sum of the number of zeros used for input
padding and the number of zeros used for ‚àá insertion. It can
be described using Equation 10.
Nzero =[(Niz w + Ow) √ó (Niz l + Ol) ‚àí Ow √ó Ol]+
[(Iw + Pw) √ó (Il + Pl) ‚àí Iw √ó Il] (10)
For W-CONV of the discriminator, Nzero also increases either
S or P increases according to Equations 9 and 10.
B. Inefficient I/O Connection
For training where massive memory reads/writes are required to update kernel weights, PipeLayer [59] employs
efficient H-tree wire routing. However, the dataflows of GAN
training are more complicated than that of traditional NNs.
We take a simple GAN (3-layer generator and 3-layer discriminator) as an example to show details of dataflows (training
discriminator in Fig.7 and training generator in Fig.8). Thus,
if we train a GAN by mapping phases to H-tree connection
architecture, it will experience a large number of long routings.
Fig.9 shows two GAN examples N1, N2 training on the
H-tree routing banks. Each bank has 16 tiles and each tile is
composed of several CArrays, BArrays and SArrays. There are
two kinds of routing nodes: (1) multiplexing node, connecting
data wires of the same width; (2) merging node, through
which the width of data wire is divided into two halves. In
672
G
Layer 1 Layer 2 Layer 3
D
D
Dw
Layer 1 Layer 2 Layer 3
Generator Discrinimator
z2
a2
z3
z2
a2
z3 input input
W2 W3
z
2
z
3
Fig. 7. Dataflow of Training Discriminator.
Layer 1 Layer 2 Layer 3 Layer 1 Layer 2 Layer 3
Generator Discrinimator
error
input input z2
a2
z3
z2
a2
z3
W2 W3
z
2 z3 z2 z
3
G
Gw
G D
D
Fig. 8. Dataflow of Training Generator.
G D D Dw
G G Gw D D Dw
G G Gw D D
Bus
Bank
N1
N2
Mat
Multiplexing Node
Merging Node
Train D G Train G
Fig. 9. Networks Mapped to H-tree Connected Tiles.
the examples shown in Fig.9, N1 is a relatively small GAN,
while N2 may be a bigger GAN or a small GAN with high
parallelism (i.e. duplicating kernel weights for several times).
In other words, the space utilized by training a GAN is decided
by the size of GAN itself and the number of kernel weight
duplications. When we map a GAN, we can separately training
discriminator and generator as N1 shows. This introduces
more space while reduces total data movements compared
with the map without duplication like the mapping pattern
of N2. However, all of these mapping patterns suffer from
long routings, as examples marked in green and red arrows
shown in Fig.9. With network size and number of duplications
increasing, this problem becomes more severe. We can relieve
this problem by adding some connections between the routing
nodes whose parent nodes are different, as the connection
pattern used in by MAERI [32]. Since the dataflow of GAN
training is much more complicated, simply doing so will not
achieve desirable performance of speedup.
IV. OUR PROPOSED SOLUTIONS
In this section, we propose our solutions to address the two
challenges analyzed in Section III.
A. PIM-Based Zero-Free Scheme
In order to address the problem mentioned in Section III-A,
we propose a novel software managed, memory controller
supported scheme called ZFDR (Zero-Free Data Reshaping)
to remove zero operations. This scheme consists of two
components: (1) T-CONV ZFDR for T-CONVs; (2) WCONV -S ZFDR for W-CONV of stride convolution.
We first take CONV1 (Fig.5) as an example to explain
our T-CONV ZFDR scheme. We usually convert convolutions
into MMVs in PIM-based computation, so we first reshape
kernel weights into vectors. The reshape operation is different
from the general one since we only extract kernel weights
1024
‚Ä¶
‚Ä¶
512
‚Ä¶
4 x 1024 = 4096
input
‚Ä¶
512
‚Ä¶
W1 W2
W3 W4
W1
W2
W3
W4
‚Ä¶
W1 W2
W3 W4
Fig. 10. Example of Zero Free Data Reshaping.
(a) Useful: No.12, 14, 22, 24
20
123 4 5
6 7 8 9 10
11 12 13 14 15
16 17 18 19
21 22 23 24 25
20
123 4 5
6 7 8 9 10
11 12 13 14 15
16 17 18 19
21 22 23 24 25
20
123 4 5
6 7 8 9 10
11 12 13 14 15
16 17 18 19
21 22 23 24 25
(b) Useful: No.11, 13, 15, 21, 23, 25 (c) Useful: No.12, 14, 22, 24
Fig. 11. Example of How Useful Weights Change When Sliding.
that multiply non-zero inputs, as shown in Fig.10. After
reshaping all the 512 weight kernels into a 512√ó4096 matrix,
we map this weight matrix into the Carray and feed the
corresponding 4096 inputs, then we obtain 512 results. All
of above operations correspond to one convolution operation
with 512 kernel weights. After the first convolution operation
shown in Fig.10, we slide kernel weights with stride of 1.
When sliding, the useful kernel weights change. Fig.11 gives
an example of how useful kernel weights change when sliding.
Thus, in step (c), the weight matrix can be reused since it is
the same with that in step (a). We find that some reshaped
weight matrices are reused when kernels slide on the edge
of input map and more reshaped weight matrices are reused
when kernels slide inside the input map.
In summary, we store 25 kinds of reshaped weight matrix
in this case (also the same in CONV2, CONV3 and CONV4).
Notwithstanding this ZFDR scheme introduces more space to
store weights, it improves parallelism greatly. For example, it
only needs 9 cycles (one MMV uses one cycle) to complete
CONV1. While without ZFDR, it will take 64 cycles. Moreover, if we duplicate kernel weights directly (without ZFDR),
and we want to conduct CONV1 in 9 cycles, we need to store
at least 179200 weights. It means that in order to achieve the
same performance as ZFDR, duplicating weights directly not
only consumes 75% more storage, but also transfers 9√ó inputs.
In order to extend our ZFDR scheme to a general case,
we first define the Loop Length (LL) using the following
equation.
LL =
‚éß
‚é®
‚é©
I √ó S
+ (S
‚àí 1) P ‚â• S
‚àí 1
I √ó S
P <S
‚àí 1, P + R ‚â• S
‚àí 1
I √ó S
‚àí (S
‚àí 1) P <S
‚àí 1, P + R<S
‚àí 1
(11)
Then we divide the T-CONV ZFDR scheme into three cases
as follows. Case 1: Reshape kernel weights that conduct
convolution on the corner of input map. This case has ((I ‚àí
1) √ó S
+1+ R + 2P ‚àí LL)2 sets of reshaped weights, and
each kind of weights is non-reusable. Case 2: Reshape kernel
weights that conduct convolution on the edge of input map.
We define R1, R2 using Equations 12 and 13:
673
R1 =
 P P <S
‚àí 1
P ‚àí (S
‚àí 1) else (12)
R2 =
 (P + R) ‚àí (S
‚àí 1) P + R ‚â• S
‚àí 1
P + R else (13)
Then number of reshaped kernel weights in this case is
R1 √ó S
√ó 2 + R1 √ó S
√ó 2, and each reshaped kernel weight can be reused by t times (t ‚àà {  
LL‚àíW+1
S

,
(
 
LL‚àíW+1
S

+ 1) }). Case 3: Reshape kernel weights that
conduct convolution inside the input map. This case has
S
√ó S
reshaped weights, and each reshaped weight can be
reused by t times (t ‚àà {  
LL‚àíW+1
S
2
, (
 
LL‚àíW+1
S

+ 1)2,  
LL‚àíW+1
S

√ó (
 
LL‚àíW+1
S

+ 1) }).
The pattern of W-CONV-S ZFDR is similar to that of
T-CONV ZFDR. The difference is, for W-CONV of stride
convolution, we remove zeros from ‚àáoutput, reshape it as
weight, then conduct convolution on input map to receive
‚àáweight. W-CONV-S ZFDR has three cases as follows.
Case 1: Reshape zero-insertion ‚àáoutput that conducts
convolution at the corner of input map. This case has
	 P
S

2
+
	 P ‚àíR
S

2
+2 	 P
S

 	 P ‚àíR
S


number of reshaped ‚àáoutputs
and each of them is non-reusable. Case 2: Reshape zeroinsertion ‚àáoutput that conducts convolution on the edge
of input map. This case has 2
	 P
S

 + 2 	 P ‚àíR
S

 number
of reshaped ‚àáoutputs, and each of them can be reused by
I‚àí(O‚àí1)S times. Case 3: Reshape zero-insertion ‚àáoutput
that conduct convolution inside the input map. This case
has only one zero-insertion ‚àáoutput whose size is equal to
‚àáoutput, and it can be reused by [I ‚àí (O ‚àí 1)S]
2 times.
Since both T-CONV ZFDR and W-CONV-S ZFDR have
three similar types, we name them as CornerReshape,
EdgeReshape and InsideReshape respectively. Note
that CornerReshape has no reuse of reshaped weights
while InsideReshape tends to have more reuses than
EdgeReshape does. This involves an unbalance in runtime
because InsideReshape takes a long time to execute while
CornerReshape is idle in most of the time. Such unbalance
not only exists in the executing stage, but also in the I/O
transmission, because I/O connected to InsideReshape is
busy while that connected to CornerReshape is slack. In
order to address this problem, we duplicate EdgeReshape
and InsideReshape for Re times and Ri times respectively.
B. 3D-Connected PIM for GAN Training
In order to solve the problem elaborated in SubSection III-B, we propose a 3D-connected PIM, aiming to
efficiently fit dataflows of GAN training.
Fig.12 (a) shows the original H-tree data wire connection
in a bank with 16 tiles (light grey squares). Green and blue
squares are multiplexing nodes, while red and yellow squares
are merging nodes. To better illustrate our 3D connection
architecture, we draw the connections as a binary tree and
mark different connection layers with different colors. First,
we add wires between two nodes whose parent nodes are
different in one layer, such as the wire between the middle two
(a) H-tree Connection (b) 3D Data Wire Connection Unit 
'&8
I
K
G
F F
I X
G
Bank 1
2
3
Tile
Router
Fig. 12. 3D Connection Based on Original H-tree Connection.
blue nodes shown in Fig.12 (b). Then we pile up three banks
and add vertical wires between two corresponding nodes.
For each two vertical connected nodes, the width of wire
between them is the same as the width of wire connected
to their parent nodes. Due to the pin bandwidth limitation, we
modify the routers by adding switches. We take two nodes
as examples shown in Fig.12 (b) (original wires are colored
grey and added wires are in yellow). For the node circled in
blue, it has one switch, which can connect wire h, wire d
or wire f, and two wires connected to child nodes are fixed
as original. For the light gray node circled in green, it has
two switches, which can connect wire u, wire d or wire f.
Note that, only nodes in Bank 2 have two switches, which
enable the nodes to connect both upper/down nodes at the
same time. We create a state set s set for each switch, and we
have s set ‚äÜ {parent, horizontal, upper, down}. Moreover,
we add an adder into the each node, which can be also
bypassed. Thus, we build a 3D data wire connection unit
(3DCU), which can be configured into two modes: Smode
for normal memory read/write and Cmode for computing. In
Smode, the connections are static and configured as H-tree
pattern. While in Cmode, the connections are dynamically
reconfigured according to dataflows.
With 3DCU, we can build our 3D-connected PIM for
training GANs. Fig.13 ellaborates how to use 3DCUs to
train a GAN. First, we connect two 3DCUs ({B1, B2, B3},
{B4, B5, B6}) together. Banks in these two 3DCUs are all
connected to the bus in traditional way. Moreover, B1 and B4,
B3 and B6 can be connected to each other directly, bypassing
the bus and CPU.
After connecting two 3DCUs, we first present the way
of training discriminator in Fig.13 (a). Note that we only
present the critical concept paths, omitting other paths like
data transferring of ‚àáweight calculation inside the bank. When
training discriminator, B2 and B3 are not used and stay in
Smode, working as traditional memory. We first map ‚àí‚ÜíG to
B1 and ‚àí‚ÜíD to B4. After that, we configure {B1, B4, B5, B6}
into Cmode. We show the dataflows of training discriminator
with Px (P reperesents the point marked on dataflows in
Fig.13, x is the number of the point). P1 ‚Üí P2 is the
dataflow of ‚àí‚ÜíG, and the zigzag line represents that during ‚àí‚ÜíG,
we may transfer data from one tile to another tile through
horizontal connections. P2 ‚Üí P3 transfers outputs of generator
to discriminator through the bypass bus connection. P3 ‚Üí P4
shows the dataflow of ‚àí‚ÜíD. During P3 ‚Üí P4, when we complete
674
8



12
10 

5
 


Bus Bus
1
2 3
4
6
7
8
9
10
11
12
13
1
2 3
4
5
6
7
9
11
1
13
14
15
16
B1
B2
B3
B4
B5
B6
(a) Training Discriminator (b) Training Generator
Tiles
Intra-3DCU 
Connections 
B1
B2
B3
B4
B5
B6
Inter-3DCU 
Connections 
Fig. 13. Dataflows of GAN Training Using 3DCUs.
A
B
C
D
Forward propagation Weight calculation Error transferring
(b) Duplicate weights
Tile
(a) Split weights
Fig. 14. Data mappings on 3D-connected PIM.
the computation of one layer, we map the corresponding part
of ‚Üê‚àí
Dw and ‚Üê‚àíD to B5 and B6 respectively. Note that we
continue forward propagation of the discriminator when we
map
‚Üê‚àí
Dw and ‚Üê‚àíD. For example, we conduct P11 ‚Üí P12 and
P9 ‚Üí P8 simultaneously. We start the backward propagation
by transferring error from P4 to P5. During the backward
propagation, we need the results from both ‚àí‚ÜíD (P8 ‚Üí P7,
P11 ‚Üí P12) and ‚Üê‚àíD (P6 ‚Üí P7, P13 ‚Üí P12) to conduct ‚Üê‚àíDw.
Also, we need the result from ‚àí‚ÜíD (P9 ‚Üí P10) to conduct ‚Üê‚àíD.
After backward propagation, we configure {B4, B5, B6} into
Smode. Through reading B5 and some calculations in CPU,
we update discriminator by writing new kernel weights to B4.
Fig.13 (b) illustrates the dataflows of training generator.
Note that, after training discriminator, B1 is in Cmode,
while others are in Smode. Thus, we first switch others to
Cmode. At the same time, we can conduct ‚àí‚ÜíG shown as
P1 ‚Üí P2, and map ‚Üê‚àíGw,
‚Üê‚àíG to B2, B3 simultaneously. Then
we output results of ‚àí‚ÜíG to
‚àí‚ÜíD marked as P2 ‚Üí P3 and start
‚àí‚ÜíD through P3 ‚Üí P4. Simultaneously, we map ‚Üê‚àíD to B6.
After that, we start backward propagation by transferring error
from P4 to P5. The error is transferred to generator through
P5 ‚Üí P8 ‚Üí P9, and during this period, the result in ‚àí‚ÜíD is
used for ‚Üê‚àíD, such as P6 ‚Üí P7. After transferring error to ‚Üê‚àíG, we start
‚Üê‚àíG and ‚Üê‚àíGw in an interleaving way. Similar as
dataflows in backward propagation of discriminator, we need
P11 ‚Üí P12 and P10 ‚Üí P12 to conduct ‚Üê‚àíGw first and then
we need P13 ‚Üí P14 for ‚Üê‚àíG. Afterwards, we use P1 ‚Üí P16
and P15 ‚Üí P16 to complete ‚Üê‚àíGw. Finally, in the same way
of updating discriminator, we switch {B1, B2, B3} to Smode
and update generator.
In general, we map generator to one or several 3DCUs
and map discriminator to corresponding 3DCUs connected to
generator. The top layer is usually for forward propagation and
the second, third layers are usually for ‚àáweight calculation,
error transfer respectively. We locate ‚àáweight calculation in
the second layer since it needs data transferred from either
phases, while error transfer only needs data from forward
propagation. What‚Äôs more, in order to reduce data movement,
we should make sure each part of phase is vertical alignment.
Take computation between Layer1 and Layer2 in Fig.8 as an
example. The left figure shown in Fig.14 is an original way of
data mapping. The green and red parts are bigger than the blue
one, because we apply ZFDR scheme on them, duplicating
kernel weights for several times. For the blue one, it applies
the normal kernel weight mapping pattern. This naive data
mapping introduces non-negligible data movements, like blue
lines marked in the left figure. We can solve this problem by
splitting kernel weights and enable each part to handle corresponding vertical partial results (shown in the middle figure
of Fig.14). Thus, we only need small-step data movements
like C ‚Üí D. It‚Äôs worth mentioning that green parts, red parts
and blue parts are not vertical alignment perfectly. They may
have small-step data movements horizontally, but it‚Äôs much
better than original data mapping shown in the left figure.
The method in (a) is space-saving but less parallelism. Also,
we can duplicate weights after splitting, like (b) shows. This
improves the parallelism but turns out to be space consuming.
The detailed design will be introduced in Section V.
V. LERGAN DESIGN
In this section, we present how Zero-Free Scheme in
Section IV-A and 3D Connected PIM in Section IV-B work
together in LerGAN.
Fig.15 elaborates the outline of LerGAN design in five parts.
Program In the program stage, we program a network,
describing it layer by layer. For example, in the lth layer,
we use the size of input (input size l), size of kernel
weight (weight size l) and size of output (output size l) to
describe it. Moreover, stride includes the stride of generator
and stride of discriminator and so does padding. Structure
replica degree describes the degree of duplication in each
phase of training GAN. It has three degrees, low, middle
and high. Programmers can easily use these three parameters
which represent low to high parallelisms, without knowing
how to duplicate kernel weights to increase parallelism, which
will be performed by the compiler.
Interface We realize ZFDR by providing two interfaces.
One is ZFDR T for T-CONV ZFDR and the other is
ZFDR W S for W-CONV-S ZFDR. These two functions do
not reshape data directly but create place holders and dataflows
675
ReRAM-based PIM
BArray
SArray
CArray
Tile
≈è
Bus ≈è
3DCU
Circuits for NN
Switch control
Program
Interface
Compiler
Network( ‚Ä¶, input_size_l, weight_size_l, output_size_l ‚Ä¶, stride, padding, replica_degree) { }
Network structure
G Gw D Dw
Data flow 
control
Replica
Generator
Memory Controller
Discriminator
ZFDR_T(≈è, i_gb_t, w_gb_t, o_gb_t ‚Ä¶){} G
ZFDR_T(≈èi_gf_s, w_gf_s, o_gf_s‚Ä¶
 i_gf_t, w_gf_t, o_gf_t, ‚Ä¶){} ZFDR_WS(≈è, i_dw_l, w_dw_l, o_dw_l, ‚Ä¶){}
ZFDR_T(≈è, i_db_l, w_db_l, o_db_l ‚Ä¶){}
ZFDR_T(≈è, i_gw_j, w_gw_j, o_gw_j ‚Ä¶){}
ZFDR_WS(≈è, i_gw_t, w_gw_t, o_gw_t, ‚Ä¶){}
DataMapping(df_reshaped, replica_df)
ZFDM(dw_reshaped, replica_dw)
ZFDM(db_reshaped, replica_db)
D
Dw
D
ZFDM(gf_reshaped, replica_gf)
ZFDM(gw_reshaped, replica_gw)
ZFDM(gb_reshaped, replica_gb)
G
Gw
G Data Map
Switch State
XB
DAC
XB
DAC
XB
DAC
XB
DAC
4 ADCs
Shift & Add
Fig. 15. Outline of LerGAN (an architecture combined techniques of ZFDR and 3DCUs).
for further removing zeros, just like the way of traditional NN
frameworks. Their parameters are passed from programming
a network. These two functions also process the network
layer by layer. The interface component in Fig.15 shows the
most complex situation: the generator of this GAN has both
T-CONV and S-CONV, and the discriminator has T-CONV.
The generator needs ZFDR T for ‚àí‚ÜíG (marked in blue), both
ZFDR T and ZFDR W S for ‚Üê‚àíGw (marked in orange), and
ZFDR T for ‚Üê‚àíG (marked in purple). The discriminator needs
ZFDR T for ‚Üê‚àíD and ‚Üê‚àíDw (marked in yellow and green).
Under normal situation where the generator has T-CONV and
the discriminator has S-CONV, ZFDR T is needed for ‚àí‚ÜíG, ‚Üê‚àíGw and ‚Üê‚àíD, and ZFDR W S is for ‚Üê‚àíDw.
Compiler After reshaping data, we start to map them
through a compiler. Mapping data has two parts. One is
mapping generator and the other is mapping discriminator. In
the case of the generator with both T-CONV and S-CONV,
we map
‚àí‚ÜíG, ‚Üê‚àíGw, ‚Üê‚àíG, ‚Üê‚àíDw and ‚Üê‚àíD by using Zero Free Data
Mapping scheme (ZFDM), while we use normal data mapping
scheme (DataMapping) to map ‚àí‚ÜíD (shown in the compiler
component of Fig.15). In the case of the generator with only
T-CONV, we use DataM apping for ‚Üê‚àíG and ‚àí‚ÜíD, and ZFDM
for the remaining phases. ZFDM has two main parameters:
data reshaped by ZFDR and the number of replicas transferred
from programming.
We take ‚àí‚ÜíG to further elaborate ZFDM scheme.
gf reshaped is data reshaped by ZFDR during generator
forward propagation. replica gf is a vector which records the
number of replicas in CornerReshape, EdgeReshape and
InsideReshape. We name items in replica gf as replica c,
replica e and replica i. Also, we calculate the average reuse
time of each case and name them as reuse c, reuse e and
reuse i. We do this because the reusing time of weights inside
each case shows little difference. Assume that the time MMV
consumed in CArray is tm, then the total time of computation
tc total in a layer is tm √ó reuse i
replica i (the execution time of
parallel tasks is decided by the longest task). We assume the
time of transferring data from one tile to its neighbor is tt,
then transferring results of a layer to its next layer consumes
at least (

 layer size
CArray size 
‚àí 1) √ó tt, named tt total (layer size
is decided by replica c, replica e and replica i). We fix
replica c as 1 since reuse c is 1, and define the maximum
value replica emax, replica imax = LL √ó replica emax
to let tt total ‚â§ tc total (LL is the loop length defined in
Section IV-A). Based on parameters defined above, we can
define replica gf as Table III shows.
Level
Value Part
replica c replica e replica i
low 1 1 replica emax
middle 1 replica emax replica emax
high 1 replica emax replica imax
TABLE III
VALUE OF replica gf .
To summarize, we duplicate kernel weights considering
three factors: (1) Programmers‚Äô demand (space demands).
When the free space is small or programmers would like
to use small memory space to train a GAN, they can
set replica degree as low, and vise versa. (2) Improving
the performance. More replicas indicate higher parallelism,
which means higher performance. (3) Avoiding I/O to become
a bottleneck. More replicas may incur more communications
among tiles, so we must avoid heavy communications from
hindering performance. For other phases in ZFDM, parameters
can be obtained in the same way of ‚àí‚ÜíG does.
Then we take ‚àí‚ÜíD to further introduce DataM apping
scheme. df reshaped is data reshaped by normal reshaping
scheme during forward propagation phase of discriminator. For
replica df, we define it as Equation 14 shows, where szf is
size of kernel weights after duplication in ‚àí‚ÜíD and sn is size
of kernel weights before duplication in ‚àí‚ÜíD.
replica df =
‚éß
‚é™‚é™‚é®
‚é™‚é™‚é©
1 replica degree = low
  szf
2√ósn

replica degree = middle
  szf
sn

replica degree = high
(14)
676
Memory controller Memory controller records the information transferred from the compiler, such as number of
replicas and data mappings. What‚Äôs more, it records states of
switches, which are deduced by data mappings. These records
come into a finite state machine, marked in blue rectangle
in Memory Controller (Fig.15). The finite state machine offers states for dataflow controller and switch controller to
control 3DCUs. Also, these two controllers receive signals
from 3DCUs and update the finite state machine. Thus, the
memory controller can manage the data mapping and configure
switches according to the dataflows dynamically.
ReRAM-based PIM The part communicating with memory controller is ReRAM-based PIM. It is also the main hardware that supports our LerGAN. It is configured with several
3DCU pairs introduced in Fig.13 in Section IV-B. Each tile
in 3DCU contains SArray, CArray and BArray, using the
design in PRIME [15], which has been already introduced in
Section II-A. The ReRAM crossbars in a CArray (marked in
light pink in Fig.15) employ the design of that in ISAAC [56],
since they can support 16-bit precision data while PRIME can
not. Based on the tile equipped with basic NN computation
and storage ability, our proposed 3DCU pairs can work well.
VI. EVALUATION
In this section, we first introduce our experimental setup
and benchmarks used to evaluate the proposed designs. We
then present our evaluation results in terms of performance,
energy, and overhead.
A. Experimental Setup
We compare LerGAN with (1) GANs running on GPU
platform; (2) FPGA-based GAN accelerator [47]; and (3)
GANs running on modified ReRAM-based NN accelerator:
PRIME [15]. We use the NVIDIA Titan X as our GPU platform and choose the Xilinx VCU118 board for implementing
FPGA-based GAN accelerator. The hardware configurations
we used for PRIME and LerGAN are listed in Table IV. The
configurations of ReRAM are from [48].
Host Processor Intel Xeon CPU E5520,
2.27GHz, 4 cores
L1 I/D cache 32KB/32KB; 4-way; 2 cycles access
L2 cache 256KB; 8-way; 10 cycles access
ReRAM-based
Main Memory
Overview T aOx/T iO2-based ReRAM
16GB; 2GB per bank, 128MB per tile;
Bank 32.8ns/41.4ns read/write latency;
413pJ/665pJ read/write energy
H-Tree 29.9ns latency, 386pJ energy
Tile 2.9ns/11.5ns read/write latency;
3.3pJ/34.8pJ read/write energy
I/O Frequency 1.6GHz
TABLE IV
HARDWARE CONFIGURATIONS.
For LerGAN configuration, we use 4-bit for each ReRAM
cell, and 16-bit for input, weight and output (i.e. same as [59]).
The size of ReRAM array is 128 √ó 128 cells. We configure
half of a tile for CArray (64MB), 1/64 of the tile for BArray
(2MB) and the remaining 62MB for SArray. We use CACTI6.5 [49], CACTO-IO [28] to model our interconnects and offchip connects respectively.
0
1
2
3
4
5
GF
GW
DB
DW
GB
Normalized Speedup
PRIME ZFDR ZFDR-NS
DiscoGAN5 pairs
DiscoGAN4 pairs
MAGANMNIST GPGAN ArtGANCIFAR10 DCGAN cGAN 3D-GAN GF GWDB DWGF GWDB DWGF GWDB DWGF GWDB DWGF GWDB DW
GF
GW
DB
DW
GF
GW
GB
DB
DW
G: Generator D: Discrimanator F: Forward B: Backward W: Weight Calculation
Fig. 16. Performance Comparison on Phases used ZFDR with PRIME
0
1
2
3
4
5
6
7
8
Average
ZFDR-NS-3D
Low-3D NS-Low-2D
Low-2D
NS-Low-3D
Normalized Speedup
PRIME ZFDR-2D ZFDR-3D ZFDR-NS-2D
DiscoGAN-5 pairs
DiscoGAN-4 pairs
MAGAN-MNIST
GPGAN
ArtGAN-CIFAR10
cG
3D-GAN
AN
DCGAN
Fig. 17. Performance Comparison between 3D-Connection and H-tree Connection with ZFDR
0
1
2
3
4
5
6
7
3D-ZFDR-NS 3D-Low-NS
Average
Normalized Speedup
PRIME 3D-NR 3D-ZFDR 3D-Low 3D-NR-NS
DiscoGAN-5 pairs
DiscoGAN-4 pairs
MAGAN-MNIST
GPGAN
ArtGAN-CIFAR10
3D-GAN
cGAN
DCGAN
Fig. 18. Performance Comparison between ZFDR and Normal Reshape with
3D-Connection
B. Benchmarks
We employ 8 state-of-the-art GAN networks as our benchmarks, shown in Table V. To describe the topologies of GANs,
we use f, c and t to denote fully-connected, convolution and
transposed convolution layers respectively. For example, the
512c5k2s denotes a convolution layer with 512 input feature
maps, using 5 √ó 5 √ó 512 kernels with a stride of 2, while
2s in 512t5k2s denotes a transposed convolution layer with
a stride of 1/2. The 100f denotes a fully-connected layer
with 100-unit input and f1 denotes a fully-connected layer
with 1-unit output. The t3 represents that after T-CONV, there
are 3 output feature maps. For simplicity, if several layers
share the same size of kernel or stride, we consolidate those
common factors at the end, for example 100f-(1024t-512t256t-128t)(5k2s)-t3, where layers 1024t, 512t, 256t, and 128t
share the common kernel size of 5 and stride size of 2.
C. Results
We fully train the networks in Table V with the batch size
of 64, and the results are shown as follows.
We first examine the effectiveness of our proposed ZFDR
and 3D connection mechanisms. We then compare the performance and energy between LerGAN and alternative PIM
design such as PRIME. Moreover, we compare LerGAN with
FPGA-based GAN accelerator and GAN running on GPU
platform. Note that we use 2D and 3D to represent Htree and 3D connection design, respectively, and investigate
configurations with different degrees of duplication (i.e. low,
middle and high).
Fig.16 shows the performance of ZFDR in different GAN
phases. We use NS to represent normalized space, which
677
Name Generator Item Size Discriminator
DCGAN [54] 100f-(1024t-512t-256t-128t)(5k2s)-t3 64 √ó 64 (3c-128c-256c-512c-1024c)(5k2s)-f1
cGAN [52] 100f-(256t-128t-64t)(4k2s)-t3 64 √ó 64 (3c-64c-128c-256c)(4k2s)-f1
3D-GAN [64] 100f-(512t-256t-128t)(4k2s)-t3 64 √ó 64 √ó 64 (1c-64c-128c-256c-512c)(4k2s)-f1
ArtGAN-CIFAR-10 [61] 100f-1024t4k1s-512t4k2s-256t4k2s-128t4k2s128t3k1s-t3 32 √ó 32 3c4k2s-128c3k1s-(128c-256c-512c1024c)(4k2s)-f11
GPGAN [63] 100f-(512t-256t-128t-64t)(4k2s)-t3 64 √ó 64 (3c-64c-128c-256c-512c)(4k2s)-f1
MAGAN-MNIST [62] 50f-128t7k1s-64t4k2s-t1 28 √ó 28 784f-256f-256f-784f-f11
DiscoGAN-4pairs [30] (3c-64c-128c-256c-512t-256t-128t-64t)(4k2s)-t3 64 √ó 64 (3c-64c-128c-256c-512c)(4k2s)-f1
DiscoGAN-5pairs [30] (3c-64c-128c-256c-512c)(4k2s)-100f-(512t-256t128t-64t)(4k2s)-t3 64 √ó 64 (3c-64c-128c-256c-512c)(4k2s)-f1
TABLE V
TOPOLOGIES OF GAN BENCHMARKS. (f :fully-connected c: convolution t:transposed convolution k:kernel s:stride)
0
2
4
6
8
10
12
14
16 PRIME Low Middle High NS-Low NS-Middle NS-High
Average
Normalized Speedup
DiscoGAN-5 pairs
DiscoGAN-4 pairs
MAGAN-MNIST
GPGAN
ArtGAN-CIFAR10
3D-GAN
cGAN
DCGAN
Fig. 19. Performance Comparison between LerGAN and PRIME
0
10
20
30
40
NS-Low NS-Middle NS-High
PRIME Low Middle High
Average
Normalized Energy Saving
DiscoGAN-5 pairs
DiscoGAN-4 pairs
MAGAN-MNIST
GPGAN
ArtGAN-CIFAR10
3D-GAN
cGAN
DCGAN
Fig. 20. Energy Saving Comparison between LerGAN and PRIME
means that PRIME uses the same CArray space as our design.
ZFDR achieves distinct speedup on DCGAN, cGAN, 3DGAN, GPGAN and DiscoGAN, which reflects that there are
large portions of zeros in these GANs. What‚Äôs more, ZFDR
saves up to 5.2√ó SArray space for storing inputs (in the case
of DCGAN), and saves 3.86√ó SArray space on average. Note
that DiscoGAN-4pairs has 5 phases using ZFDR because its
generator has both S-CONV and T-CONV. Moreover, there is
no speedup on discriminator of MAGAN-MNIST, because its
layers are fully-connected.
When we evaluate the entire process of training GANs with
H-tree connection, the speedup of ZFDR almost disappears.
This is resulted from the overhead of data transfers. Fig.17
shows the performance of our 3D connection design compared with H-tree connection. We observe that with our 3D
connection design, the speedup of ZFDR is much more visible. Moreover, with 3D connection, duplication (low degree)
achieves much higher performance speedup than ZFDR with
no duplication, while duplication achieves little speedup with
H-tree connection.
Fig.18 compares the performance between ZFDR and
normal reshaping (marked as NR) with 3D connection. The
results show that with 3D connection, ZFDR with (without)
duplication achieves 5.11√ó (2.77√ó) speedup on average, while
normal reshaping only yields 1.31√ó speedup, indicating that
both our 3D connection design and ZFDR are critical to
accelerate GAN execution.
Experiments above show that ZFDR and 3D connection
0
30
60
90
120
150
Average
DiscoGAN-5 pairs
DiscoGAN-4 pairs
MAGAN-MNIST
GPGAN
ArtGAN-CIFAR10
3D-GAN
cGAN
Normalized Speedup
FPGA-GAN GPU LerGAN-Low LerGAN-Middle LerGAN-High
DCGAN
Fig. 21. Performance Comparison among FPGA-based GAN accelerator,
GPU platform and LerGAN
0
5
10
15
20
Average
Normalized energy saving
FPGA-GAN GPU LerGAN-Low LerGAN-Middle LerGAN-High
DCGAN
cGAN
3D-GAN
ArtGAN-CIFAR10
GPGAN
MAGAN-MNIST
DiscoGAN-4 pairs
DiscoGAN-5 pairs
Fig. 22. Energy Saving Comparison among FPGA-based GAN accelerator,
GPU platform and LerGAN
can achieve high speedup when they work together. We further
show performance of LerGAN which combines these two
techniques. We train the discriminator and generator of each
GAN for ten iterations and calculate the average time of
each iteration. We compare different duplication degrees of
LerGAN with PRIME, shown in Fig.19. First of all, with our
design applied, DCGAN has more speedup than 3D-GAN and
GPGAN because it has a larger kernel size than others, which
leads to a larger proportion of multiplications with zeros.
Besides, MAGAN-MNIST shows nearly no speedup since its
discriminator is fully-connected and its generator is small with
only one T-CONV.
Fig.20 shows the results of energy saving. Note that
LerGAN-low-NS achieves 28.47√ó energy saving on average.
This high energy saving owes much to our zero-free and 3D
connection design, since they reduce the amount of data as
well as the data movements requiring long wires. Besides,
with the increase of duplications, LerGAN exhibits less energy
saving, since more duplications leads to (1) more memory
reads/writes when updating GANs; and (2) more complex and
energy-consuming switch configurations.
We also compare LerGAN with FPGA-based GAN accelerator and GPU platform. Fig.21 and 22 show the performance
and energy consumption of aforementioned architectures, respectively. In terms of the performance, LerGAN achieves
47.2√ó and 21.42√ó speedup on average over FPGA-GAN and
678
16%
13.6%
Updating 70.4%
Communication
Computing
Fig. 23. The Breakdown of Energy
Consumption in LerGAN (Overall)
ADC
DAC
Other 4.2%
10.5%
45.14%
40.16%
Cell Switching
Fig. 24. The Breakdown of Energy
Consumption of a ReRAM Tile
GPU, respectively. What‚Äôs more, DiscoGAN manifests more
speedup over others because (1) it has more T-CONVs, which
means more zeros. Our LerGAN with ZFDR design shows
higher performance; (2) the size of DiscoGAN is bigger,
leading to more off-chip memory accesses for FPGA and
GPU, which causes PIM-based LerGAN to perform better.
Moreover, GANs with small sizes, such as MAGAN-MNIST,
and lacking of T-CONVs, cause less speedup. For the energy
saving, LerGAN-low saves more energy than FPGA-based
GAN accelerator for GANs with small size but with more
frequent T-CONVs (the left five GANs in Fig.21). However,
for GANs with small size and less T-CONVs (MAGANMNIST) and GANs with big size (DiscoGAN), LerGAN
shows slightly less energy saving than what FPGA-GAN
accelerator performs. This is because LerGAN consumes more
energy when updating networks, consequently extra energy
cost can not be amortized by the energy saving opportunity. On
average, LerGAN has 1.04√ó energy consumption than FPGAGAN accelerator. Moreover, as shown in Fig.21 and 22, though
more duplication (e.g. LerGAN-high) brings more speedup, it
results in more energy consumption.
D. Energy Distribution
Fig.23 shows the overall energy distribution of LerGAN
executed across the experimented benchmarks. The energy of
computing dominates 70.4% of the total energy in LerGAN
since it has a large amount of ReRAM-tile-related operations,
while that of communication occupies 16%, benefited from
our 3D-connected PIM design. Moreover, we break down the
energy distribution of a ReRAM tile, as shown in Fig.24. The
results show that cell switching (40.16%) and ADC (45.14%)
are the two main energy-consuming contributors. Several
studies [66] [37] contribute on reducing energy consumption
of cell switching and ADC. If LerGAN is equipped with 1-
pJ cell switching [66], and a more energy-saving ADC (e.g.
60% [37]), it can achieve nearly 3√ó power reduction.
E. Overhead
The overhead of LerGAN has two parts: software overhead
and hardware overhead. For the software overhead caused by
ZFDR and ZFDM, LerGAN spends 32.52% more time than
traditional methods on compiling. However, compared with
the total time spent on training a GAN(e.g. several days), the
overhead of few minutes incurred by the software overhead can
be ignored. For the hardware, since we add some switches and
wires, it causes 13.3% space overhead compared with PRIME.
However, this space overhead can be justified by the higher
performance (2.1√ó speedup) delivered by LerGAN, compared
with PRIME using the same space.
VII. RELATED WORK
3D Network on Chip (NoC) There are several prior
studiess on 3D NoC [38] [29] [51] [8] [1], which are proposed
for shortening connections. However, their complex routing
algorithms are not suitable for GAN, while our succinct 3D
connection design fits GAN well.
NN accelerators Many recent works accelerate NN based
on FPGAs [67] [45] [69] [57] [3] and ASICs [18] [23] [68]
[40] [12] [43] [55] [44] [2]. Diannao family was proposed
based on Near-Data Processing (NDP) [11] [13] [16] [41],
which locates processors near the memory to reduce the
overhead of off-chip memory access. Our design is based on
ReRAM-based PIM, further reducing data movements.
ReRAM-based NN accelerators PRIME [15] is an accelerator on basic computations of inference like MMV computation. ISAAC [56] proposed a pipeline solution to accelerate
inference of CNNs. PipeLayer [59] further proposed a pipeline
solution with intra-layer parallelism on both inference and
training of CNNs. TIME [14] proposed a ReRAM-based
training-in-memory architecture and further reduced the frequency of ReRAM read/write. Our work proposes a zero-free,
3D connected GAN accelerator.
GAN accelerators Song et.al. [47] proposed FPGA-based
GAN accelerator. It uses well-designed dataflows to remove
zero operations and increase data reuse on FPGA. Amir et.al.
proposed a SIMD-MIMD acceleration for GAN [5] [4] [6],
by removing zeros in GAN training. Chen et.al. proposed
ReGAN, a ReRAM-based GAN accelerator using pipeline [10]
design. Our LerGAN design is PIM-based and flexible to
handle all zero-related scenarios in GAN training.
VIII. CONCLUSIONS
This paper proposes a PIM-based GAN accelerator: LerGAN, which achieves low data movement and zero-free computation. LerGAN has two main techniques: (1) Zero-Free
Data Reshaping (ZFDR) designed for ReRAM-based PIM
to remove computations with zeros; and (2) reconfigurable
3D connection in PIM which removes the bottleneck of
long data movement. LerGAN also combines these techniques
with minor modifications of software and memory controller.
Experiments show that both these techniques are critical in
accelerating GAN training. Experiments show that LerGAN
achieves 47.2√ó, 21.42√ó and 7.46√ó speedup over FPGA-based
GAN accelerator, GPU platform and PRIME respectively.
Moreover, LerGAN achieves 9.75√ó, 7.68√ó energy saving on
average over GPU platform, PRIME respectively, and has
1.04√ó energy consuming over FPGA-based GAN accelerator.
