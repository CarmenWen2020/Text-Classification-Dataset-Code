ABSTRACT
Micro-architecture units like caches are notorious for leaking secrets across security domains. An attacker program can contend for
on-chip state or bandwidth and can even use speculative execution
in processors to drive this contention; and protecting against all
contention-driven attacks is exceptionally challenging. Prior works
can mitigate contention channels through caches by partitioning
the larger, lower-level caches or by looking for anomalous performance or contention behavior. Neither scales to large number of
fine-grained domains as required by browsers and web-services
that place many domains within the same address space.
We observe that cache contention channels have a unique property – contention leaks information only when it is cyclic, i.e., domain A interferes with domain B, followed by interference from B
to A. We propose to use this cyclic interference property to detect
micro-architectural attacks as anomalous cyclic interference. Unlike
partitioning, our detection approach scales to many concurrent domains in a single address space; and unlike prior anomaly detectors,
cyclic interference is robust to noise from benign interference.
We track cyclic interference using non-intrusive detectors in an
out-of-order core and stress test our prototype, Cyclone, with finegrained isolation in browsers (against speculation-driven attacks)
and coarse-grained isolation of cores (against covert-channels embedded in database and machine learning workloads). Full-system
simulations on an ARM micro-architecture show close to perfect
detection rates and 260 − 1000× lower false positives than using
(state-of-the-art) contention alone, with slowdowns of only ∼3.6%.
CCS CONCEPTS
• Security and privacy → Side-channel analysis and countermeasures; Malware and its mitigation.
KEYWORDS
side-channel defenses, secure architectures, anomaly detection
1 INTRODUCTION
Isolation is fundamental to security but surprisingly hard to achieve
in practice. Even when encryption and virtual memory prevent an
attacker from directly reading secret data, side-channels through
the micro-architecture leak secrets such as private keys [1, 2, 7,
50, 65, 66, 78, 95], database queries [59], webpage contents [4],
kernel memory [49, 54], etc. Side-channel attacks have recently used
speculative execution [10–12, 35, 49, 51, 54, 77] as an initial step
that greatly amplifies their ability to read secrets across isolation
boundaries such as virtual machines, processes, or even browser
sandboxes.
Isolation is especially difficult since many security scenarios require information to not leak among fine-grained security domains
(e.g., sandboxes) that interleave execution at the scale of a few
instructions. For example, a browser loading a web-page isolates
tens of origins (i.e., website domains) in the same address space, a
57
MICRO-52, October 12–16, 2019, Columbus, OH, USA Harris and Wei, et al.
web-service isolates data from many distinct users, an application
isolates untrusted libraries (including kernel code), etc. Supporting
isolation in the same address space is crucial to maintaining performance for many applications (e.g., persistent processes to handle
web requests in FastCGI). Unfortunately, speculative attacks bypass
all language enforced isolation mechanisms [61] on current systems. Isolating coarse-grained domains—such as virtual machines
assigned to separate cores—is also challenging and requires customized mechanisms to prevent side-channel leaks through shared
caches, memory controllers, or other resources.
Most prior defenses focus on the coarse-grained scenario and
use two complementary approaches: (a) prevent side-channel leaks
by partitioning resources such as caches [22, 33, 44, 48, 55, 56, 81,
83, 84] and memory controller bandwidth [23, 71, 80, 82, 98] among
security domains, or (b) detect side-channel attacks based on anomalous micro-architecture usage [67], performance counter traces [18],
or contention behavior [13, 38] and trigger higher OS-level detectors or virtual machine migrations [62]. While partitioning resources works well when domains are few, partitioning across tens
of domains dramatically decreases performance—our SPEC experiments show a 33% slowdown when partitioning an 8-way L1 cache
and a 16-way L2 cache into eight domains in the same address space.
Detectors, on the other hand, miss attacks and raise false alarms
when evasive attacks supply adversarial inputs – we evaluate this
in § 3.
In this paper, we identify a new property—cyclic interference
across security domains—that is common to all known cache contention side-channel attacks, including when they are used deliberately (covert-channels) or driven by transient execution (i.e.,
Spectre/Meltdown family of attacks). Fig. 1 depicts this property.
On the left, an attacker domain contends directly for a cache line
("prime-access-probe") with the victim where the prime and access steps create directional contention from a spy to the victim
and the probe step completes the cycle. On the right, the attacker
flushes/evicts cache lines first to let the victim bring the cache line
in – creating the first step in the cycle – while the cycle is completed
when the spy reloads the cache line. Interestingly, in the presence of
many security domains, if the cache line is evicted by an unrelated
(e.g., non-secret) domain, the cycle is broken and the contention is
harmless. While these two attacks look distinct, both require a cycle
of directional interference—we describe this intuition in § 4 and
examine in § 6 how it applies to speculation-driven attacks (Spectre
and Meltdown) without triggering false alarms in benign programs
that are specifically created to be similar to both ("SpectreBenign").
We introduce Cyclone, a system that efficiently tracks directional interference in the micro-architecture in order to detect cycles. Cyclone handles coarse-and-fine-grained isolation by enabling
software to specify security domains in a security lattice to the
micro-architecture. Cyclone then performs micro-architectural information flow tracking on these security domains in the registers,
caches, and main memory. This tracking defines new propagation
rules for accessing micro-architectural resources and accounts for
speculative execution. Further, we introduce a non-invasive tracing
system, distributed across the micro-architecture, that monitors
cyclic interference events and raises alerts when a cache contention
attack occurs. Our key idea is to design local detectors (LDs) that
passively observe requests to each cache, track directional interference conservatively, and forward local anomalous summaries to a
global detector (GD). LDs count cyclic interference events, sending
summaries to the more programmable GD when events occur above
a threshold within a time window. The GD uses more sophisticated
algorithms to separate out attacks from false positives.
We stress-test Cyclone using fine-grained isolation of origins (i.e.,
website domains) in a browser (with a Spectre-V1 attack embedded
inside an origin), and coarse-grained isolation of cores running
privacy-sensitive applications (with cache-based covert channels
embedded in each application). We further evaluate the detector using a mix of memory-intensive SPEC workloads. We compare cyclic
interference to an improved state-of-the-art system to track contention across domains [13, 38]. For fine-grained isolation against
a Spectre browser attack, Cyclone detects 100% of the attack compared to 80% for a contention tracking system [13]. Additionally,
Cyclone has a 260× lower false-positive rate. For coarse-grained
core-isolation, both Cyclone and contention tracking detect all
attacks. In a benign scenario of 4 concurrent SPEC applications, Cyclone generates only 12 false-positives per second, while contention
tracking generates 12,000 false-positives per second.
The LDs and GDs in Cyclone do not impact the critical path of
our simulated ARM processor while the IPC is lowered by 2.4% due
to DRAM tag accesses. The tags which Cyclone relies on to track
domains throughout the micro-architecture increase the cache size
by 6.25% and the main memory usage by 1.5% when configured to
use 8-bit domain-ids. A non-secure processor that uses the extra
tag storage in Cyclone to store data instead would see only a 1.2%
performance increase. With the extra DRAM accesses and potential
opportunity loss, Cyclone sees up to 3.6% performance overhead.
The main contributions of Cyclone are: (i) a new feature for
anomaly detectors, cyclic interference, common to all known
contention-based cache attacks (ii) a micro-architecture that propagates security domain tags throughout the registers, caches, and
memory (iii) software support in the kernel and JavaScript engine
to inform the micro-architecture of both fine and coarse-grained
security domains as a security lattice (iv) a distributed anomaly
detector that tracks cyclic interference with significantly lower
false positives (260× for browser and 1000× for a SPEC-mix) and
∼ 100% true positives for speculation-driven attacks in browsers,
OpenCV, libSVM, and a PostgreSQL database.
2 BACKGROUND
2.1 Isolation Requirements: Coarse- vs.
Fine-Grained
Modern systems provide strong isolation between security domains
through both hardware and software enforced mechanisms such
as virtual memory [5], virtualization [6], and safe languages [60].
Coarse-grained isolation places security domains in separate address spaces (e.g., processes or virtual machines), typically using the
hardware memory management unit (MMU) to enforce confidentiality. Many applications also implement fine-grained isolation where
multiple security domains run in the same thread of execution and
share the virtual address space. Instead of hardware enforced isolation, these applications use language level enforcement such as
58
Cyclone: Detecting Contention-Based Cache Information Leaks Through Cyclic Interference MICRO-52, October 12–16, 2019, Columbus, OH, USA
type and dynamic bounds checks to enforce confidentiality. This
type of fine-grained isolation is often referred to as sandboxing.
In a web browser, the JavaScript engine enforces the same-origin
policy: isolation between separate origins (i.e., web domains). For
example, a Google ad on a page will be isolated from the parts of
the page that don’t originate from Google. Fine-grained isolation is
useful since a single web page can have tens of origins, e.g., over
16 for www.cnn.com.
Efficient isolation also requires allowing legitimate information
flows between security domains. A common way of specifying allowed information flows is a security lattice [20]. A security lattice
describes the level of security that an element in the lattice has access to. Each element in a security lattice is a security domain, such
as a virtual machine, process, or sandboxed program. In this model
information flows are restricted between low and high elements in
the lattice.
2.2 Side- and Covert-Channels
Modern processors share micro-architectural resources like DRAM,
caches, TLBs, functional units, predictors etc. extensively. Unfortunately, an attacker can learn information about a victim based
on their usage of these resources, thereby bypassing hardware
and software isolation mechanisms. An attacker exfiltrates information either through contention on a resource between security
domains (e.g., processes, VMs, sandboxes) or by directly observing the victim’s usage through a legitimate external interface (e.g.,
remote timing attacks on SSL [9]). We refer to these information
leaks as contention side-channels and observation side-channels,
respectively. A covert-channel is a special case of side-channels
where a trojan intentionally leaks information to a spy sharing
the resource, for example a compromised text editor leaking sensitive documents. From the perspective of the micro-architectural
resource, covert-channels are indistinguishable from side-channels.
However a covert-channel attack can achieve much higher rates of
information leakage as the attacker is in full control of how they
exercise the resource. A special type of observation channel is the
termination channel [28], where the total execution time of the
program leaks information.
A particularly powerful mechanism for information leakage is
speculation-driven attacks [10, 12, 35, 49, 51, 54, 77] where transient
instructions operate on sensitive information. Transient instructions are instructions executed speculatively (i.e., before they are
known to be valid) and ultimately thrown away, or squashed, when
it is determined they should not have been executed. Because these
transient instructions may alter micro-architectural state before
finishing all permission checks, an attacker can learn sensitive information using these transient instructions much more easily. These
speculation-driven side-channels allow an attacker to bypass all
language-enforced sandboxing mechanisms [61].
A very common and high bandwidth type of side-channel
attack is through the caches such as Prime+Probe [57, 66],
Evict/Flush+Reload [29, 91], and other variants [21, 40, 53, 94].
Cache attacks occur either through contention for particular cache
sets (e.g., Prime+Probe) or through contention for particular memory addresses (e.g., Flush+Reload). For example, in a Prime+Probe
cache attack, the attacker first primes the cache by bringing in a
line, lets the victim execute the information leak, and then measures the timing of a cache probe access. If the victim causes the
attacker’s line to be evicted, they will observe a slower execution
time than if the access was a cache hit; thus revealing information
about the victim’s access. Cache side-channel attacks have been
shown on the first level caches [1, 95], as well as shared last level
(LLC) caches [30, 43, 57].
2.3 Threat Model
The focus of this work is defending against cache channels that occur through contention, both when a victim and attacker share the
same address space (e.g., browser sandboxing) and when they are
isolated by the kernel or hypervisor using virtual memory. Observation channels (e.g., remote timing attacks on SSL [9]), including
the termination channel, are not in scope.
We identify five important requirements defenses must satisfy
to mitigate cache contention side-channels: (R1) support settings
(e.g., a web browser) with fine-grained isolation where tens of
domains share the same address space and thread of execution, (R2)
scale well with many concurrent domains, (R3) handle speculationdriven attacks, (R4) prevent all cache contention attacks or (for
anomaly detection solutions) detect most attacks with a low falsepositive rate, and (R5) have a low performance overhead.
3 MOTIVATION
3.1 Potential Defenses and Limitations
3.1.1 Partitioning and Flushing. One natural solution to microarchitectural side-channels is to prevent the sharing of resources
between security domains. Thus many approaches aim to partition resources in space (e.g., cache partitioning [22, 48, 55, 81, 83])
or in time (e.g., one domain per core, memory controller scheduling [23, 71, 80]). To prevent sharing of the virtual address space,
Chrome implements Site Isolation where separate origins (i.e., website domains) are placed in separate processes. Rather than partition,
a simple defense is to ensure all micro-architectural state is flushed
when switching between security domains [27].
Unfortunately partitioning and flushing can have significant
overheads, especially in settings with fine-grained isolation. Our
experiments show 33% IPC overhead for a mix of SPEC2017 apps
when using way-partitioning, where each out-of-order core gets
only a single way of the cache. In Chrome, Site Isolation incurs a
memory overhead of about 10-13% in real workloads [70]. Further,
partitioning does not scale to a large number of security domains
(e.g., way-partitioning is limited to the number of ways). Thus while
these approaches succeed in fully preventing even speculationdriven attacks (R3, 4), they have high overheads (R5)—especially
in fine-grained isolation settings with many domains (R1, 2).
3.1.2 Randomization and Encryption. Another approach is to introduce randomness or utilize encryption when accessing the resource [37, 56, 69, 83, 86, 96] to make it more difficult for the attacker to infer the information. However, these defenses are still
vulnerable to capacity attacks (i.e., contention for the entire capacity of the cache rather than specific sets). For example, Lipp et.
al. [53] show that cache attacks are still possible on an ARM system
that uses a random replacement policy. Additionally, approaches
59
MICRO-52, October 12–16, 2019, Columbus, OH, USA Harris and Wei, et al.
Spectre
Deliberately
evict(array2)
reload(array2)
Spectre Benign
Unintentionally
evict(array2)
Benign computation
if (x < array1_size) {
 char _t = array1[x];
 y = array2[_t*512];
}
Call Vulnerable JavaScript Function!
Figure 2: Comparison of Spectre and SpectreBenign executions. Both pages repeatedly call a browser JavaScript
function with an input used for a potentially speculative
bounds check. However, SpectreBenign does not access out
of bounds classified memory speculatively, and does not
reload array2.
such as CEASER [69] only attempt to make it more difficult to
find cache conflict sets, thus they do not defend against attacks
through memory address contention (e.g., Flush+Reload). Tablebased randomization approaches [83, 84] require significant storage
overheads: either 1.25MB or 8.5MB for an 8MB LLC [69] depending
on whether the OS implements sharing of mapping tables. Thus
these approaches scale well, work in fine-grained isolation settings,
and handle speculation-driven attacks (R1, 2, 3), but do not fully
prevent attacks (R4) and can have high overheads (R5).
3.1.3 Anomaly Detection. Rather than prevent the information
leakage, another approach is to detect an active attack, called anomaly detection. Anomaly detectors monitor system behavior rather
than modify the system to eliminate the possibility of information
leakage, thus typically leading to low performance overheads and
easier deployment. In addition, they provide a mechanism to protect against future attacks. While well-designed anomaly detectors
can detect most real attacks, the key challenge is reducing false
alerts. Advanced attacks circumvent signature-based approaches
and static analysis [63, 93]. Thus dynamic detection systems have
been proposed to detect traditional malware such as worms and
viruses [18, 46, 47, 67, 73, 90] as well as micro-architectural cache
side-channel attacks [13, 14, 18, 79, 93]. Anomaly detectors typically
train a machine-learning model on the system’s execution characteristics such as OS level signals (e.g., system call traces) [15, 89],
instruction traces [3], or micro-architectural signals (e.g., statistics
like cache misses from the performance monitoring unit (PMU)).
These anomaly detectors can be grouped under three classes:
D1: Generic, unsupervised detectors, which are trained on a set
of representative benign applications. These detect deviations from
the trained benign behavior, potentially capturing future unknown
attacks and protecting a diverse set of applications.
D2: Application-Specific, unsupervised detectors, which are
trained on a representative set of benign inputs for one specific
application. These detectors can achieve better detection rates, but
fail to protect systems with diverse workloads.
D3: Application-Specific, supervised detectors, which are
trained on a representative set of both benign and malicious inputs.
Such detectors excel when the attacks on the system are similar to
what they were trained on. In practice, such detectors are difficult
to deploy since they require knowledge of all possible malicious
behavior and each application configuration to be effective.
3.2 Anomaly Detection with PMUs
One anomaly detection approach for existing systems is to utilize
performance monitoring units (PMUs) to measure statistics (e.g.,
cache misses) to detect when cache contention channels are being
exploited. PMU-based anomaly detection systems can meet all the
requirements in § 2.3 if they have low false-positive rates (R4).
We evaluate the ability of the three types of detectors, described
in § 3.1.3, to detect a JavaScript Spectre attack on both an ARM and
x86 system using the provided PMUs.
Detector Testing and Training. We test each detector by running a browser that visits a series of benign websites as well as a
malicious site with an embedded Spectre attack. The Spectre attack abuses a vulnerable browser JavaScript function that has a
speculative bounds check based on the passed input. To construct
"evasive" attacks that look benign, an attacker can modify existing
applications that also invoke the same vulnerable function [46].
Thus, we additionally test the detectors using a benign website,
SpectreBenign, that calls the same vulnerable function, but does
not provide inputs to access out-of-bounds, classified memory and
does not probe the cache. Fig. 2 shows the executions of these two
pages. SpectreBenign stress tests the robustness of these detectors
(i.e. false positive rates against adversarial test cases) to help understand their limitations. In order to train a generic, unsupervised
detector, we collect traces on a set of six SPEC2017 programs to
represent a diverse set of applications. The app-specific detectors
are trained specifically on the browser, visiting only benign websites for unsupervised and websites with both benign and Spectre
for supervised.
Experimental Setup. We collect PMU traces on a 2GHz, 64bit
ARM Cortex A57 and a 3.5GHz, 64bit x86 Intel i7-4770K. Since our
Spectre implementation in JavaScript abuses branch misprediction
to create an Evict+Reload channel on data cache, we select performance counters related to branch predictions and cache misses
throughout the cache hierarchy. We also include performance counters like cycle count and instructions retired that were reported to
work well in detecting cache side-channels [14, 79, 93]. On ARM
we evaluate cycle counts, instructions retired, branch predicts and
mispredicts, together with L1 data cache misses and L2 write backs.
On x86, we evaluate all cycles, unhalted cycles, instructions retired,
all executed branch instructions, all executed mispredicted branch
instructions, L2 demand data reads, L2 demand data read misses,
L3 read hits, and L3 read misses. Single counter selection is done
first and then combinations of the best candidates are evaluated
for multi-counter based detection. From this analysis we use L2
data writebacks for the ARM detector, while the x86 detector uses
a combination of instructions retired, number of branches, and L2
data read misses.
While there are many choices of feature extraction and classification algorithm, we follow best-practices from prior work on
60
Cyclone: Detecting Contention-Based Cache Information Leaks Through Cyclic Interference MICRO-52, October 12–16, 2019, Columbus, OH, USA
0 0.2 0.4 0.6 0.8 1
0
0.2
0.4
0.6
0.8
1
False Positive Rate
True Positive Rate
0 0.2 0.4 0.6 0.8 1
0
0.2
0.4
0.6
0.8
1
False Positive Rate
True Positive Rate
Generic, Unsupervised Detector: Without SB With SB 
Application-Specific, Unsupervised Detector: Without SB With SB
Application-Specific, Supervised Detector: Without SB With SB 
ARM x86
D1:
D2:
D3:
Figure 3: ROC of Three PMU-based Detectors. When SpectreBenign (SB) is included for testing, PMU-based detectors
suffer from high false positives. AUC scores for the above
figure with and without SB are given as follows:
ARM: D1 {Without: 0.92, With: 0.59}, D2 {Without: 0.97,
With: 0.64}, D3 {Without: 1.00, With: 0.83}
x86: D1 {Without: 0.93, With: 0.72}, D2 {Without: 0.98, With:
0.76}, D3 {Without: 0.99, With: 0.97}
anomaly detection with PMUs. Specifically, we run context-switchaware, per-process data collection multiple times to address the
non-determinism issue pointed out in [17]. We use a temporal bagof-words model [45] to extract features. We use one-class SVM (Support Vector Machine) with the radial basis function kernel [45, 73]
for unsupervised detectors (D1 and D2), and XGBoost (Extreme
Gradient Boosted Trees) [17, 18, 97] for supervised detectors (D3),
both with ten-fold cross validation [17, 45, 97].
Analysis. Fig. 3 shows the detection performance of each detector
with a ROC (receiver operating characteristic) curve to depict the
true positive and false positive rates. Each detector is tested with
and without SpectreBenign. The results show that when the detector specifically looks out for Spectre (supervised), it performs well
and only sees slight degradation when faced with SpectreBenign.
However, for unsupervised detectors, when faced with SpectreBenign (or similar-looking benign examples), otherwise well-designed
anomaly detectors suffer from high false positives.
4 PROPERTY: CYCLIC INTERFERENCE
Cyclone uses cyclic interference for detecting contention-based
cache side-channel attacks. In this section, we define cyclic interference and introduce the security lattices used for coarse and
fine-grained isolation. To reduce false-positives (R4), we introduce
domain propagation rules and a declassification process. As a driving example, we explain how cyclic interference appears in both
Prime+Probe and Flush+Reload attacks. Later in § 6 we present
detailed analysis on cyclic interference for speculative attacks (R3).
4.1 Cyclic Interference
Direction of Interference. Interference on micro-architectural
resources is directional. It occurs from a source to a destination,
in which the source of interference, the previously issued instructions, affect the micro-architectural behavior of the interference
destination, i.e., the current instruction that is attempting to use the
Kernel
Process A Process B
Kernel Declassified
(a) Coarse-Grained isolation
Sandbox Engine
Sandbox A Sandbox B
Kernel Declassified
Kernel
(b) Fine-Grained isolation
Figure 4: Security lattice. Fine-Grained isolation restricts infomation flow even within the same address space. However
parts of kernel need to be declassified to allow legitimate information flows (§ 5.2).
resource. Moreover, a successful side- or covert-channel attack consists of two purposefully controlled directional interference events.
To reliably recover information from a micro-architectural channel,
it is vital for the attacker to know the state of the channel resource.
The attacker accomplishes this by accessing the resource prior to
the victim operation. Therefore, interference from the attacker is
inflicted on the victim during the victim’s access. In order to retrieve the transmitted information, the attacker must then probe
the resource after the victim’s access. This time, interference occurs
from the victim to the attacker. Two such consecutive directional
interference events on the same resource construct a successful
information leak, and will inevitably create a cyclic interference
event. However, if the resource is accessed by a third party in between attacker and victim, there will be neither information leak
nor cyclic interference.
Notation of (cyclic) interference. We use the symbol ; to describe the direction of interference on shared resources and physical memory. {a ; b} depicts interference from domain a to b,
in which operations of domain a happen before ones of b. For example, {a ; b ; c} shows interference first happened from a
to b, then from b to c. Therefore, the cyclic interference is noted
as {a ; b ; a}, where interference {b ; a} follows {a ; b}.
When this event occurs due to interference on a resource we call it
cyclic resource interference (CRI), while when it occurs on a memory
address we call it cyclic memory interference (CMI).
4.2 Security Lattice and Domain Propagation
Fig. 4 depicts the security lattice used for coarse- and fine-grained
isolation. Fine-grained isolation, shown in Fig. 4b, needed in sandboxing environments like browsers and web servers, further restricts information flow from the engine to the sandboxes and
across sandboxes, even within the same address space. Given attacks like Spectre/Meltdown that leak kernel memory, labeling all
kernel memory as secret seems intuitive. However, this is inaccurate
and can lead to high false positives. Several kernel functions legitimately write to user memory—such as setting up a new user-space
page—and these writes should be explicitly declassified, allowing
information flow to the user program without creating cycles of
interference. We place such declassified parts of the kernel lower
in the security lattice described in § 5.2.
61
MICRO-52, October 12–16, 2019, Columbus, OH, USA Harris and Wei, et al.
Operation Example Security Tag Propagation
Arithmetic XOR x1, x2, x3 T[x1] ← max(T[x2],T[x3])
Store STR x1, [x2, #Imm] T[Mem[x2+Imm]] ← max(T[x1],T[CPU])
Load LDR x1 ,[x2, #Imm] T[x1] ← T[Mem[x2+Imm]]
T[Mem[x2+Imm]] ← propagate(T[Mem[x2+Imm]],T[x2])
Table 1: Security tag propagation rules. Mem[ADDR] represents the content stored at ADDR. T[] represents the security tag of a
register or a memory location. T[CPU] represents the security tag of the currently executing domain. Algorithm propagate is
depicted in Fig. 5.
1 def propagate(Tag[mem], Tag[op]):
2 if lattice_comparable(Tag[mem], Tag[op]):
3 return max(Tag[mem], Tag[op])
4 elif mem is shared:
5 return Tag[op]
6 else:
7 return Tag[mem]
Figure 5: Domain propagation function. max returns the tag
higher in the security lattice.
Security domain tags are propagated throughout architectural
and micro-architectural state to enable tracking of cyclic interference. We determine the security tag of each hardware unit based on
the security domain that currently occupies it. We also determine
the tag of each memory location based on the security domains of
both the register and the memory operands of the instruction that
most recently accessed this location.
Table 1 summarizes how a new security tag is computed for different operations. For arithmetic operations, the security domain of
the destination register is the max of the operands (i.e., higher in the
lattice). When operand domains are incomparable, max escalates to
a lattice domain that is higher than all operands. For memory loads,
depending on the security tags of both operands and the loaded
data from memory, the memory security domain of the destination
is updated using the propagate function depicted in Fig. 5: for comparable domains (i.e., there is a hierarchical relationship), it returns
the one higher in the lattice; for incomparable domains it returns
the security level of the addressing register used if the memory is
shared, otherwise it returns the security level of the memory.
It is important to note that the propagation rules are extended
for memory reads. Besides the destination register, memory reads
update the security tag in the memory hierarchy depending on
whether micro-architectural state changes will be visible to other
domains. For example, for a memory location shared between incomparable domains a and b, a LLC miss for a load of a that uses
data from domain b as the index will update the memory security
tag in LLC to b. However, a hit retains the current memory security
tag in the cache line.
4.3 Attack Examples
Next we describe how Prime+Probe and Flush+Reload exhibit
cyclic resource and memory interference, respectively. Speculative attacks are analyzed in § 6. For each cache line, we save both
the current and previous resource and memory domains, noted
as Blk (r es_dom, r es_dom′
, mem_dom, mem_dom′
) where ′
represents the previous domain. For example, Blk (a, b, a, b) depicts a
Reload: Blk(a, b, a, b)
Access: Blk(b, X, b, a)
Flush (clean): Blk(X, X, a, X)
Reload: Blk(a, X, a, X)
No Access: Blk(X, X, X, X)
Flush (clean): Blk(X, X, X, X)
Probe: Blk(a ,b, X, X)
Access: Blk(b, a, X, X)
Prime: Blk(a, X, X, X)
Time
Prime+Probe Evict/Flush+Reload
{a↝b↝a} cycle completed!
Transmit a bit 0
Transmit a bit 1
{a↝b↝a} cycle completed! Spy Victim
Figure 6: Description of how resource and memory domains
are updated to discover cyclic interference in Prime+Probe
and Flush+Reload. The metadata state of a cache line is notated as Blk (r es_dom, r es_dom′
, mem_dom, mem_dom′
) where
′
represents the previous domain. X refers to a don’t care or
unknown domain. An occurence of cyclic interference is denoted as {a ; b ; a}.
cache line whose current domains on resource and memory are a,
while the previous domains on resource and memory are b. X is
used for don’t-care or unknown domains. We assume no knowledge of the previous state of the cache. We refer to the attacker as
security domain a and the victim as domain b. Fig. 6 shows how the
state of domains is updated for a cache line under attack. Every iteration of Prime+Probe creates a cyclic resource interference (CRI)
event, while Flush+Reload exhibits cyclic memory interference
(CMI) whenever there is a 0-1 bit pattern.
4.4 Challenges in Tracking Cyclic Interference
Labeling. To support both lattices in Fig. 4, we need to label different sandboxes as different domains but must allow some information flows, such as legitimate kernel writes to user memory, or
explicit communication via shared memory or objects (R1, 2, 4).
Speculative Execution. Interference can result from speculative
execution, where traditional MMU permission checks no longer
guarantee confidentiality in the presence of micro-architectural
side-channels. Thus each micro-architectural operation, speculative
or not, needs to be tracked (R3).
Domain Propagation. Interference can occur on both hardware
resources and memory addresses. Hence, besides information flow
tracking on architectural state like registers and memory locations,
62
Cyclone: Detecting Contention-Based Cache Information Leaks Through Cyclic Interference MICRO-52, October 12–16, 2019, Columbus, OH, USA
Core 0
 L1 $
Exe. Units
Interconnect
Shared $
DRAM
Memory Controller
GD
LD
Domain Tracking Support Cyclone Cache Detector
LD
LD
Predictors
LD
Reg. File LD
Tags Core 1
 L1 $
Exe. Units
LD TLB Predictors
Reg. File LD
Tags
LD TLB
Tags
LD
Tags
Tags
Tag Controller
Figure 7: Processor Architecture with Cyclone. Our prototype places Local Detectors (LDs) on the caches for cyclic
resource and memory interference, and modifies structures
like the register file to store domains. Potential future work
for Cyclone could place LDs on other units shown with
dashed lines.
micro-architectural resources need to be tagged and tracked. Further, the domains needs to be propagated from architectural state,
e.g. registers and memory, to micro-architectural state (R3, 4).
Hardware Efficiency. Inteference is not explicitly expressed in
the software of the victim and attacker. Thus, cyclic interference
must be tracked in hardware efficiently (R5).
To overcome these challenges, we propose an architecture that
properly propagates and tracks fine-grained domains throughout
cores, caches, and memory.
5 CYCLONE ARCHITECTURE
Cyclone tracks both CRI and CMI in local detectors, and aggregates
and filters alerts in a global detector. We first discuss hardware
and software support in Cyclone to track directional interference
among fine-grained security domains. Then we introduce our local
detector prototype for contention-based cache information leaks
which tracks cyclic interference. Importantly, Cyclone can still track
cyclic interference in speculation-based attacks (R3), which manifest when a victim accesses a location based on attacker controlled
inputs. Finally, we show how a global detector can be used to combine alerts and time series features from local detectors to create a
robust, efficient anomaly detection system with low false-positives
(R4, 5).
5.1 Hardware Support
Fig. 7 shows an overview of the Cyclone architecture. The cores are
modified to include a domain-id control register, add domain-ids to
the register file, and add logic for propagating domains. The domainid control register defines the security domain of the code currently
executing. The register domain-ids are updated based on the lattice
described in § 4. Memory requests carry a domain-id which corresponds to the security domain associated with the operands used
to calculate the memory address. This mechanism enables Cyclone
to track whether memory instructions are influenced by untrusted,
attacker-controlled inputs or classified secrets.
To track cyclic interference, a history of the security domains
on shared resources needs to be kept. Specifically, Cyclone implements tracking for current and previous domain-ids. We associate
a current and previous resource domain as well as a current and
previous memory domain with each cache line to track both cyclic
resource interference (CRI) and cyclic memory interference (CMI).
Whenever a cache line is accessed, if the domain-id of the request
differs from the current domain-id, the current is moved to previous and then updated based on our security lattice. Note that a
particular deployment of Cyclone may choose to only track interference in the last-level cache, or only on the caches in certain cores
depending on the threat model and desired performance overheads.
Every cache line of main memory also has a tag associated with
it that holds the security domain of the last access. Memory tags
are implemented by reserving space at the end of DRAM and a
simple mapping from cache line to tag. There are no new instructions for managing tags, memory requests have domains associated
with them based on the domain register set by software and our
propagation rules. This memory domain tracking enables detection of attacks that contend for specific memory addresses such as
Flush+Reload and Evict+Reload in addition to resource contention
attacks (R4). Note that when a cache hit for a load occurs we do
not update the memory domain, just the resource domain.
Cyclone reduces the false positives in hardware (R4). First, Cyclone provides a shared bit in the domain-id for software to mark
memory regions as shared. This allows explicit sharing between different domains by not propagating shared memory domains (Fig. 5
line 5). Second, Cyclone lowers the source register and memory
security domains upon committed writes. Committing write instructions satisfy both hardware permission and software bounds
checks, indicating that the domain writing memory has valid ownership of the data. This helps prevent over-tainting due to the lattice
escalation policy. Finally, Cyclone provides support for domain
masking used to explicitly allow contention between security domains. For example, it can be used to allow contention created by
explicit communication in (e.g.) producer-consumer applications.
5.2 Software Support
Cyclone’s software support enables defining fine-grained security
domains to meet application-level security requirements. It provides
system and application software with support to assign and manage
domains. Although software compartmentalization [31, 85] is not
the focus of this paper, we discuss our efforts to leverage such
support.
Domain-ids are associated with particular users (e.g., tied to cloud
account), and must be managed by the software that enforces isolation. For example, within the kernel, new processes are initialized
with a user’s security domain, and the domain-id control register is
managed on context and mode switches. By default, the kernel sits
higher in the security lattice than any user processes. For example,
page tables are marked with kernel security domains and are confidential to user processes. However, not all data accessed by the
kernel should be marked as classified since various kernel functions
63
MICRO-52, October 12–16, 2019, Columbus, OH, USA Harris and Wei, et al.
Shift Shift Shift Shift Shift Shift
CRI/CMI Event 
Detector
Request Domain
Domain
Previous
Domain
=
=
Event Counter
Rst
En
Interval Counter
Wrap
Threshold
Event Histories
Shift Shift Shift Shift
>=
CRI/CMI Local Detector
8
8
Valid Alert
Window
To GD
# Buckets
Event Counter
Rst
En
# Buckets
Figure 8: Cyclone cache local detector (LD) design. Each
cache is augmented with two local detectors, one for cyclic
memory interference and one for cyclic resource interference. The LD consists of one 32-bit interval counter, one
8-bit event counter, four 8-bit event history registers perbucket, and logic to check thresholds and send alerts to the
global detector.
operate on user memory or inputs. Cyclone supports a declassification operation for those functions. For example in __copy_to_user,
store operations to user memory set the domain to unclassified.
Specifically, we declassify the kernel’s operations in the following
scenarios: (1) process creation (e.g. fork), (2) memory management
(e.g., zero-init), and (3) syscall (e.g., socket read/write).
Applications themselves must also be modified in a similar manner to the OS kernel if they implement intra-address space finegrained isolation. In our evaluation (§ 8), we modify the implementation of the PhantomJS [34] browser to leverage this isolation. We
assign all JavaScript sandboxes in the same frame the same security
domain, while JavaScript sandboxes in different frames get distinct
security domains (R1, 2). This complies with the same origin policy, where JavaScript instances only have access to information
within the same origin. The browser engine (WebKit) also has its
own security domain such that it is isolated from every JavaScript
sandbox. In addition, during transition from the WebKit engine to
the JavaScript executor who executes the sandbox, common data
structures and global objects used by both the WebKit engine and
the JS executor have to be properly declassified ∗
. We modified both
the kernel and the JavaScript engine to ensure domains are properly
labeled and declassified to reduce false-positives (R4).
5.3 Local and Global Detectors
Cyclone employs a combination of local detectors (LDs) and a global
detector (GD) to allow trade-offs between an efficient design and
detector performance.
Local detectors function similar to traditional performance counters, but instead are programmed to track cyclic interference with
fine-grained domains. LDs are placed physically next to each cache
and snoop on the traffic. Such snoopy detectors do not require modifications to the cache as the tracking logic is outside the monitored
resource. They are responsible for storing the history of security
domains and tracking cyclic interference. Each LD has counters
∗Note that PhantomJS is controlled by a JavaScript controller that specifies which
actions to take (e.g., the pages to visit). Since this script can access many internal data
structures, we assign it the same security domain as the browser engine.
that increment when cyclic interference events occur. An interval counter parameter determines the number of cycles between
counter resets. Whenever a sample is collected, it is first investigated in the LD and possibly sent off to a GD which has abundant
temporal information of the system for anomaly classification.
The GD in Cyclone is ultimately responsible for determining if
the LD alerts are malicious. The GD consists of a classifier trained
specifically for the user’s deployed system and set of workloads. As
samples are collected from the LDs, the GD aggregates and extracts
features before performing inference using the classifier. The GD
is intended to be programmable to enable the user to choose their
classifier (SVM, CNN, LSTM, etc.) and feature extraction process
to achieve their desired security requirements. We envision the
GD similar to the power-management unit in a modern SoC; these
units are often even implemented as full-fledged micro-controllers.
Depending on the deployment scenario of a system utilizing Cyclone, a user may or may not require this level of programmability
and could instead implement a fixed-function GD.
5.4 Cache Detector Prototype
Our LD cache detector prototype implements a set of counters (up
to 32 in our prototype) that are shared by all the cache lines. Fig. 8
depicts the LD design for one event counter. Bucketing maps each
line of the cache to a counter instead of keeping a counter for each
cache set. When a cyclic interference event occurs, a simple hash
function maps the address to a bucket and increments the counter.
The LD functions by recording samples of the event counters on
every interval counter reset into a N-sample Event History buffer.
When a sample over a specified threshold is observed, an alert is
raised, and that sample along with the previous N samples (referred
to as a window) are sent to the GD for classification. Windowing is
carried out to give the GD more context in predicting an anomaly,
while trading-off LD storage and alert frequency sent to the GD. For
our prototype we determine the threshold using the 99th percentile
of the distribution of counter values in the training set of benign
applications ( five in our experiments), and we choose a window
size of four samples. Our GD prototype then computes statistics on
the window (max and mean) and uses a one-class SVM model to
classify the window using these features. The choice of number of
buckets and sampling interval balances implementation overhead
and desired accuracy. Sensitivity studies for these parameters are
shown in § 8.5. Contention-only tracking uses the same local detector shown in Fig. 8, but only increments the event counter when
the domain stored for that line differs from the current request
domain. Contention without buckets has just one event counter for
the whole cache instead of a set of counters.
6 CYCLIC INTERFERENCE IN ADVANCED
ATTACKS
As Cyclone tracks information flow at the micro-architecture level,
the domain propagation rules described in § 4.2 still apply to speculative instructions as long as they leave a trace in the microarchitecture. In this section, we discuss how cyclic interference
enables Cyclone to meet R3 in presence of Spectre and Meltdown
as well as how cyclic interference discriminates the SpectreBenign
example in § 3.2 (R4). We use the notation described in § 4.3 to
64
Cyclone: Detecting Contention-Based Cache Information Leaks Through Cyclic Interference MICRO-52, October 12–16, 2019, Columbus, OH, USA
depict the state of the current and previous resource and memory
domains of each cache line. In the following examples, we refer to
the attacker as security domain a and the victim as domain b.
Spectre: Bounds Check Bypass. We use a Spectre variant with a
Evict+Reload cache channel shown in Fig. 2 as an example. This
variant uses 256 (2
8
) different shared cache lines to transmit 1-byte
of leaked information per iteration. The shared cache lines map
one-to-one to the byte values. We show that cyclic interference
on shared physical memory exists in Spectre when non-repeating
bytes are leaked and transmitted.
Consider two iterations of an example Spectre attack leaking a
sequence of two distinct bytes: 0x80, 0x64. At T1, attacker domain
a evicts all shared cache lines out of the cache, and subsequently
supplies a malicious input x to the victim code, executed by domain
b. At T2, the victim mispredicts the branch and executes the wrong
path speculatively. The first load, indexed by the malicious input
x, brings in a secret byte, 0x80 from memory. Then the second
memory read, using the secret byte as an index, subsequently loads
in a shared cache line mapped to the byte 0x80. At T3, the attacker
scans through the shared memory region, testing each byte value,
including 0x64 and 0x80. The read to the shared cached line mapped
to 0x80 hits in cache. The access to the memory block mapped to
0x64 misses in cache. At T4, attacker again evicts the shared cache
lines, and feeds the victim code with a malicious input x
′
, pointing
to the next secret byte, 0x64. At T5, the victim speculatively brings
in this byte and then loads a shared cache line mapped to the byte
0x64. Finally, at T6, attacker probes the 256 shared cache lines. This
time, access to the shared line mapped to byte 0x64 hits in cache.
From T1 to T6, the Spectre attack transmits two byte values 0x80
and 0x64. Interference on shared physical memory occurs as follows:
at T3, due to the miss on the cache line mapped to 0x64, domain a
reads from main memory, updating the in-main-memory security
tag of this memory location to domain a as it modifies the microarchitectural state of the shared memory location. When domain
b accesses this memory block from main memory at T5, the state
of the cache line brought in is Blk(b, X, b, a). Then at T6, domain
a hits on this cache line and the state becomes Blk(a, b, a, b),
creating cyclic interference on shared memory as {a ; b ; a}.
Meltdown. Meltdown reads classified kernel memory from a user
program. Similarly to Spectre, Meltdown uses a Flush+Reload channel. However, the FLUSH, ACCESS, and RELOAD phases are all
performed by the attacker whose domain a is lower than the kernel
domain b in the lattice, i.e., a ⊂ b.
During the ACCESS phase, the first load to classified kernel
memory propagates the kernel domain b to the destination register.
In the second load, the attacker uses this register to speculatively
access a memory location. Based on the propagation rule (Fig. 5
line 3 since a ⊂ b), the loaded cache line will also have the tag
b. Thus when attacker performs Flush+Reload on this cache line,
cyclic interference exists {a ; b ; a}.
SpectreBenign: In-Bound Array Accesses. SpectreBenign in
Fig. 2, without the RELOAD phase, does not infer any secrets from
the victim. Interference may still exist but does not form a cycle.
Further, if the array1 is unclassified or shared, in-bound accesses
do not leak information. Consider a benign situation where every
access of the victim is in-bound to a shared location. During the
ACCESS phase: the victim’s first load, addressed by inputs from the
attacker (domain a), accesses an in-bound shared memory location.
Because the micro-architectural state of this shared cache line is
affected by domain a, the loaded cache line and the destination register will both be tagged as a (Fig. 5 line 5). The second load, using
this register (domain a) as address, reads a shared memory array2
and the loaded line is again tagged as a. Thus, cyclic interference
will not take place on the shared array2.
7 EXPERIMENTAL METHODOLOGY
7.1 System Configuration
Arch ISA ARM v8
Frequency 3GHz
BPred 2048-Entry BiModal Predictor
Fetch 8 wide, 64-entry IQ
Issue 8 wide, 192-entry ROB
Core
Writeback 8 wide, 32-entry LQ, 32-entry SQ
L1-I, L1-D 64kB, 8-way, 64B line, 2cycles, LRU,
4 20-entry MSHR, no prefetch
L2 (LLC) 2MB, 16-way, 64B line, 20 cycles, stride prefetch,
Memor
LRU, 8-entry write-buffer, 4 20-entry MSHR
y
DRAM 16GB Micron-MT40A2G4 DDR4
Table 2: Gem5 System Configurations
We implement Cyclone’s design using full-system gem5 [8] configured to simulate an out of order (OoO) processor running the
ARMv8 ISA. Table 2 shows the specific configuration used in our
experiments. We choose parameters to be similar to a modern ARM
OoO core such as the Cortex-A73. Note that our design could be
ported to any ISA. We simulate ARM due to superior support for
full-system mode in gem5 which enables us to perform end-to-end
real-world security evaluations with complex applications such as
SQL databases and web browsers.
7.2 Workloads
Our workloads are divided into two sets: one that evaluates Cyclone’s detection ability and another that evaluates overheads.
Our first set of security-centric workloads are applications that
operate on potentially sensitive information. These include classification (libSVM: classifies sensitive inputs), object recognition
(OpenCV: operates on sensitive images), and a medical database
(PostgreSQL: operates on sensitive patient information). Each of
these applications is modified to embed a per-set Prime+Probe
covert-channel on the LLC that leaks bits across isolation boundaries to a co-resident receiver. The receiver process can then reconstruct the sensitive information. These bit leaks are interleaved
with normal benign application behavior. In our experiments, we
use inter-process communication between the covert channel gadgets to synchronize the leak phases. This assumes a more powerful
attacker than one who must synchronize by exercising the channel.
Our next security-centric workload is PhantomJS [34], a headless browser that allows automating page loads using JavaScript.
As discussed in § 2.1, a browser is an application that implements
fine-grained isolation between potentially many domains. Thus
PhantomJS enables us to exercise the ability of our detector to
scale to many domains while still maintaining low false positives
65
MICRO-52, October 12–16, 2019, Columbus, OH, USA Harris and Wei, et al.
(R1, 4). To this end, we implement a hardware attack vector that
violates fine-grained isolation in PhantomJS—Spectre-V1 bounds
check bypass. In addition to the attacks, we simulate benign executions consisting of PhantomJS visiting various websites collected
by Gutierrez et al. [32].
To better assess the value of Cyclone, in addition to tracking
cyclic interference, we implement contention-tracking similar to
prior work [13, 38]. Rather than counting cyclic interference events,
contention-tracking only discovers when there is directional interference with any other domain, and does not discover cycles.
Further, we apply our bucketing scheme to the contention-based
detectors to track at a spatially finer-granularity. In all security
evaluations, we compare tracking cyclic interference to contention
and bucketed contention.
Our performance workloads include a representative set of five
SPECspeed 2017 applications (cactuBSSN, mcf, leela, xz, and deepsjeng) taken from [68]. The performance workloads enable us to
evaluate the overhead of Cyclone and the presence of false-positives
when there is no attack. For the mixed SPEC workloads, we fastforward all benchmarks past the initialization point of the application that takes the longest to initialize (cactuBSSN). We then
warm-up for 50 million cycles and simulate detailed statistics for 1
billion cycles. For non-SPEC workloads, we fast-forward past initialization and then run to completion. All experiments are performed
in gem5 full-system mode, running Ubuntu 16.04 with Linux kernel
v4.15 (the most recent kernel supported by gem5 with ARM at time
of writing).
8 RESULTS AND ANALYSIS
In this section, we analyze our detector’s performance on both resource and memory based (e.g., Flush+Reload) micro-architectural
information leak attacks on cache. We compare tracking of cyclic
interference with contention and bucketed contention, as described
in § 5.2 and 7.2. We report classification metrics such as precision,
false positive rate, and F1 score. Recall describes the accuracy of
a detector in identifying all attacks instances, while false positive
rate depicts its practicality. F1 score is the harmonic mean of precision and recall. We omit ROC curves since there are very few
malicious samples compared to benign. The covert-channel experiments group results into leak frequencies which are based on how
many cycles an attacker chooses to transmit a single bit. In addition
to detector effectiveness, we analyze the performance trade-off of
our detector prototype due to extra DRAM traffic and if the detector
tracking area were instead devoted to storing data in the cache.
8.1 Case Study 1: False Positives Stress Test
In this case study, we run several benign applications concurrently
in order to quantify false positives in Cyclone. Specifically, we simulate a mix of 1 to 5 SPEC2017 programs (§ 7.2) on a shared machine
with Cyclone. Each application is assigned a unique domain ID
from the kernel and we run a max of 6 concurrent applications,
including the kernel, on our four-core simulation. Fig. 9 (top) shows
a heat map of cyclic interference observed in the L2 cache over
80 million cycles simulated in region of interest. The cyclic interference is aggregated into 32 cache buckets, shown on the y-axis.
A darker color indicates higher intensity of the interference. The
0 1000 2000 3000 4000 5000 6000 7000 8000
0
5
10
15
20
25
30
0
5
10
15
Time Interval (10K Cycles)
LLC CRI Buckets
Four CPU2017 Apps
1900 1920 1940 1960 1980
0
5
10
15
20
25
30
1900 1920 1940 1960 1980
0
5
10
15
Time Interval (10K Cycles) Time Interval (10K Cycles)
LLC CRI Buckets
Benign Medical SQL LLC-CC Medical SQL
Low Intensity CRI High Intensity CRI (Attack!) 
Figure 9: HeatMap of cyclic resource interference (CRI) in
L2 Cache sets on a mix of four SPEC2017 programs and
on a medical SQL queries. Benign SPEC and medical show
only low intensity CRI, but the medical with Prime+Probe
covert-channel show clear high intensity CRI during the
leak phases.
benign SPEC mixed workload exhibits only low intensity cyclic
interference events (less than 6 events per 10k cycles).
8.2 Case Study 2: Information Leaks in
Privacy-Sensitive Applications
We embed a cross-process LLC Prime+Probe covert-channel into
three privacy-sensitive applications: SVM classification, facial
recognition, and a medical SQL database. Note that a highbandwidth, cross-process Prime+Probe attack can also be performed
on the private L1 cache in systems which support simultaneous multithreading (SMT), however our gem5 simulation is limited to one
hardware thread per core. Fig. 9 (bottom) shows the frequency of
cyclic interference on each of the 32 LLC cache buckets throughout
the program run on our medical database, sampled at a granularity
of 10k cycles. There is very low intensity of cyclic resource interference (CRI) on the benign application run shown on the left, while
the leak phases of the covert-channel on the right are clearly visible
with high intensity CRI. For brevity we only show the heatmap for
the medical database. SVM classification and face recognition show
similar cyclic interference behavior.
As described in § 5.2, our LD+GD setup consists of simple thresholding and windowing at the LD combined with a one-class SVM
classifier that uses max and mean features on the windows at the GD.
The interval size between counter samples used in this case-study
is 10k and the window size is four.
Table 3 shows detector results for the Prime+Probe covertchannel on three privacy-sensitive applications for generic detectors. The table also shows the average performance of them on
benign SPEC2017 workloads (3 different mixes of 4 SPEC apps running on 4 cores). Fig. 10 plots the F1 Scores for the generic and
application-specific detectors. Testing per malicious app yields similar results with bucketed contention and CRI. The trade-off between
66
Cyclone: Detecting Contention-Based Cache Information Leaks Through Cyclic Interference MICRO-52, October 12–16, 2019, Columbus, OH, USA
Attack Scenarios Contention Detector Contention Buckets Detector Cyclone
App Attack
Bandwidth (bps)
Cyles Per
Bit Leak Alerts/s Precision Missed
Attacks/s Alerts/s Precision Missed
Attacks/s Alerts/s Precision Missed
Attacks/s
LibSVM 2391k 1000 253k 0.9334 23.6 235k 0.9998 0 235k 0.9998 0
239.1k 10000 246k 0.9689 550.1 199k 1 0 199k 1 0
Medical
DB
90k 1000 159k 0.0574 4.6 9k 0.9987 0 9k 0.9999 1.8
9k 10000 158k 0.0538 575.8 4k 0.9985 0 4k 1 0.9
Face
Detection
99k 1000 16k 0.6029 0 10k 0.9992 0 10k 0.9999 0
9.9k 10000 16k 0.6165 0 9k 0.9991 0 9k 1 0
Benign
SPEC2017 0 0 300k 0 0 12k 0 0 12 0 0
Table 3: Generic, unsupervised detection performance of Cyclone with cyclic resource interference (CRI) against Prime+Probe
covert-channel attacks. Each row in this table describe how Cyclone performs given a specific attack scenario. For example,
the second row in the table reports that when Prime+Probe covert-channel in LibSVM uses 1000 cycles to leak each single bit,
achieving a bandwidth at 2391kbps, contention based detectors report 253k alerts per second, 93% of which are true alarms,
missing 23.6 attacks per second. However, both our Contention Buckets Detector and Cyclone report around 235k alerts per
second, 99.98% of which are true alerts, missing no attacks. Since, missed attacks captures false negatives, we omit recall here
for brevity.
4000
3000
1000
500
300
0
0.2
0.4
0.6
0.8
1
4000
3000
1000
500
300
4000
3000
1000
500
300
Contention Contention Buckets CRI
Leak Freq.(KHz) Leak Freq.(KHz) Leak Freq.(KHz)
F1 Score
libSVM Medical DB Face Recognition
4000
3000
1000
500
300
0
0.2
0.4
0.6
0.8
1
4000
3000
1000
500
300
4000
3000
1000
500
300
Contention Contention Buckets CRI
Leak Freq.(KHz) Leak Freq.(KHz) Leak Freq.(KHz)
F1 Score
libSVM Medical DB Face Recognition
Generic
App
Specific
Figure 10: Generic (top) and application-specific (bottom),
unsupervised detector F1 scores. Tracking cyclic resource interference improves detection results compared to both contention and bucketed contention tracking. Leak frequency
refers to the amount of cycles an attacker chooses to transmit a single bit.
the bucketed contention detector and Cyclone lies in between false
positives (reduced precision) and false negatives (missed attacks).
Cyclone has better precision and recall, but incurs a few false negatives. Bucketed contention, on the other hand, tolerates reduced
precision in lieu of eliminating all false negatives. However, the real
advantage of tracking cyclic interference shines in benign workloads which exhibit significant contention (12,000 alerts/second
compared to only 12).
We simulate a setting of diverse benign and malicious workloads
by running a mix of concurrent SPEC applications, time-interleaved
with all three privacy-sensitive applications compromised with a
Prime+Probe covert-channel. Overall, we create five mixed testing
sets each of which contain executions of four concurrent SPEC
apps (on all 4 cores). The testing sets also consist of SVM classification, face detection, and a medical DB, all running Prime+Probe
at a particular leak frequency. The four SPEC workloads used for
3157
2000
600
428
333
0
0.2
0.4
0.6
0.8
1
Contention Contention Buckets CRI
Leak Freq.(KHz)
F1 Score
Mixed Testing Set
Figure 11: Generic, unsupervised detector F1 scores. We
report results for a sample of mixed benign and malicious workloads. While contention tracking with buckets
improves significantly upon normal contention tracking,
cyclic resource interference achieves near perfect F1 scores.
each mixed testing set are chosen out of the five SPECspeed 2017
applications mentioned in § 7.2. Global detectors based on all three
designs (contention, bucketed contention, and CRI) are trained to
cover a range of benign behaviors: a SPEC workload mix of 1-5
concurrently running applications and benign executions of the
privacy-sensitive applications. Fig. 11 plots the F1 scores for these
mixed testing workloads. Cyclic interference is not affected by the
presence of diverse benign samples in the workload whereas both
types of contention tracking exhibit a large number of false positives. We conclude that one-way directional interference occurs
much more frequently than cyclic interference in benign applications, making cyclic interference a more robust signal for detecting
cache contention leaks.
8.3 Case Study 3: Remote Attacks in Sandboxes
with Fine-Grained Isolation
To evaluate Cyclone in a fine-grained isolation setting, we use
PhantomJS with 9 different benign websites†
[32], Spectre, and
SpectreBenign (described in § 3.2) implemented in JavaScript. After
modifying PhantomJS to assign distinct domains for each website
†Amazon, BBC, CNN, CraigslistNY, eBay, Google, Slashdot, Twitter, and Wikipedia
67
MICRO-52, October 12–16, 2019, Columbus, OH, USA Harris and Wei, et al.
GoogleAmazonBBC
Slashdot TwitterWiki
0
0.2
0.4
0.6
0.8
1
Contention Contention Buckets CMI
Website
Recall
0.02
0.03
0.03
0.02
0.03
0.01
(a) Recall (Higher is better)
BenignGoogleAmazonBBC
Slashdot TwitterWiki
2
5
1000
2
5
10k
2
5
100k
2
Contention Contention Buckets CMI
Website
False Positives (logscale)
0
241
298
506
895
1352
1706
(b) False Positives (Lower is better)
Figure 12: Generic, unsupervised detector recall and number
of false positives for Spectre in a web browser. Compared
to pure contention tracking, Cyclone achieves higher recall
and lower false positives by tracking cyclic memory interference(DMI). Notably, Cyclone detects all byte leaks (recall
is always 1), and creates zero false positives when there’s no
attack.
frame, loading each website involves on average 7 security domains.
The rendering of websites experiences on average 93.2 security
domain switches per second.
We implement a cross-site password stealing attack using Spectre. Rather than searching for a usable Spectre gadget in PhantomJS,
we extend the JavaScript API to include a function that is vulnerable
to a Spectre variant similar to Fig. 2, i.e. bounds-check-bypass [49].
In addition, we assume that the victim’s browser does not support
strict Site Isolation (one process per origin even in the same page)
and that the attacker has prior knowledge about the memory locations of the passwords. A remote attacker exploiting JavaScript
does not have direct access to cache flush instructions, and thus performs an Evict+Reload attack. Our Spectre implementation enables
the attacker to read arbitrary memory contents within the browser
process’s address space, bypassing the isolation boundaries of the
JavaScript sandbox. We apply the attack to 9 different benign web
sites†
. It fails on 3 of them due to unintentional cache evictions
created by the browser. On the remaining 6 websites, Spectre successfully steals a total of 672 bytes at varying attack bandwidths
ranging from 110.1 to 115.2 bits/second.
We configure our cache detector LD to sample every 100k cycles,
while the window size is kept at four. To detect every byte leak, we
set no thresholds on the CMI at the local detector. Fig. 12 depicts
the detection performance of Cyclone with CMI-based LDs in a
generic, unsupervised setup, against the remote Spectre variants on
6 different websites. Results are compared to contention tracking
without bucketing and with 32 buckets. Unlike case study 2, where a
contention bucket detector detects almost all covert-channel attacks
but with higher false positives, contention-based detectors fail to
detect all spectre attacks. On the y-axis we plot recall and false
positives to better visualize this difference. On the x-axis, we list
the 6 different websites being attacked. Compared to contention
tracking with and without buckets, Cyclone achieves higher recall
and lower false positives.
Fig. 12a shows that Cyclone detects all byte leaks (recall is always 1). However, the recall for tracking contention with buckets
degrades compared to without buckets. This degradation is due to 3157
2000
600
428
333
0
0.2
0.4
0.6
0.8
1
CRI 32 Buckets CRI 16 Buckets
CRI 8 Buckets CRI 4 Buckets
Leak Freq. (kHz)
F1 Score
(a) Bucket sensitivity
3157
2000
600
428
333
0
0.2
0.4
0.6
0.8
1
CRI 10k CRI 20k CRI 30k CRI 40k
CRI 50k
Leak Freq. (kHz)
F1 Score
(b) Sampling Sensitivity
Figure 13: Sensitivity studies for Cyclone. A larger number of buckets and finer-granularity interval sizes improve
the F1 scores of our detector. However, these improvements
come at a cost of more area for counters and increased traffic
to the global detector.
contention being prevalent even in benign applications. Bucketing
disaggregates the attacker’s contention across all sets, reducing the
interference to a benign intensity. Thus the bucketed contention detector fails to classify the attacks as anomalous. Meanwhile, Fig. 12b
shows the number of false positives plotted on a logarithmic scale.
The first group, at 0 bps effective bandwidth, shows the detector
false positives on SpectreBenign. In this benign setting, both types
of contention tracking report large number of false alarms, while
CMI introduces no false positives. Cyclone with CMI detects 100%
of the attacks, compared to 80% detection using contention tracking,
while reducing false positives by 260×. Further, we verify that on
the 3 failed attacks, CMI creates no additional false positives.
8.4 Case Study 4: Sensitivity Studies
We perform sensitivity studies in order to arrive at the best parameters for Cyclone. Fig. 13 summarizes our system’s sensitivity to the
number of counter buckets and the sampling granularity. We experiment with 4 to 32 buckets and a sampling granularity between 10k
to 100k cycles. We show our results on the same mixed testing sets
from Fig. 11. We observe that the F1 score of a CRI-based detector
increases with increasing number of buckets. While having one
bucket per set would be ideal, the area overheads would be too large
for a realistic implementation (e.g., 2048 counters for the LLC only
in our prototype). We also note that there is no need to strive for
such fine-grained counters since we already achieve near perfect F1
scores with 32 buckets. As expected, finer-grained time-sampling
increases accuracy. However, our experiments sampling at a finer
granularity than 10k cycles fail to improve the scores dramatically,
thus we perform all of our experiments with a 10k sampling frequency and using 32 buckets. Additionally, finer-grained interval
sizes will increase the amount of traffic sent to the GD.
8.5 Performance Evaluation
We use the SPEC2017 performance workloads to evaluate the performance impact of Cyclone when no channel is being created.
First, we evaluate the overhead of extra DRAM transactions to
read and update memory domains which are stored at the end of
the address space. Next, we compared IPC to a system where the
68
Cyclone: Detecting Contention-Based Cache Information Leaks Through Cyclic Interference MICRO-52, October 12–16, 2019, Columbus, OH, USA
detector area used for domain tracking is instead used for data in
the cache. Finally, we compare the performance to a system that
does way-partitioning for each domain. We did not explicitly model
interconnect traffic due to alerts sent to the GD. However, our alert
message is 4 bytes leading to only 48 bytes/second in the benign
case for the 12 alerts/second shown in Table 3. Context-switching
the domain-id control register requires only four instructions to
save and switch to the kernel domain-id and two instructions to
restore; regardless of the number of concurrent domains. We evaluated single SPEC benchmarks without our kernel changes and saw
negligible (<0.001 IPC) performance change. As discussed in § 8.3,
the JavaScript engine switches sandboxes only 93.2 times per second (much less frequent than the kernel), thus has less overhead
than the kernel.
Cache Overheads. As discussed in § 5, each 64B cache line is
tagged with four 8-bit wide domain-ids. This choice adds an overhead of 32-bits per cache line, leading to a worst-case space overhead of 1 way for the L1 and 2 ways for the LLC based on the
sizes in Table 2. Thus the area overhead for Cyclone is estimated at
6.25% of the total cache data-store, 32 bits of meta-data for every 64
bytes of cache data. Our experiments on SPEC benchmarks show
that the IPC speedup over our system achieved by allocating the
extra area to data instead of tags is about 1.2% on average without any partitioning and remains approximately the same for a
per-core partitioned cache. However for fine-grained isolation, we
would need many cache partitions to prevent information leakage
between sandboxes. The same workloads running on an 8-way
partitioned L1 and 16-way partitioned L2 see a slowdown of up to
33% on average with a max slowdown of 40%. Further increasing
partitioning will cause more performance degradation, whereas
Cyclone is only limited by the choice of domain-id width.
DRAM Overheads. The DRAM overhead to store 8-bit domain
tags for every 64 bytes is 1.5% of the total size. Our DRAM tag transactions result in a 2.4% IPC decrease on SPEC. Note that the only
optimization we implement is eliminating writes that don’t change
the domain (i.e., silent writes). We do not currently implement tag
caching or tag compression which have been shown to significantly
reduce this overhead [42, 74].
Detector Overheads. Since the local detector works in parallel
with the corresponding domain-id, the entire monitoring system is
off the critical path of the processor. The global detector contains a
pre-trained SVM model, the maximum size for which is 311 bytes
in our simulations. Due to this small size, we did not directly model
any potential system effects such as memory bandwidth for the
initial (e.g., at boot-time) GD setup. The GD can be implemented
as a programmable micro-controller or as custom hardware. One
possible implementation is a systolic array architecture computing
the dot product between the support and test vectors with a 2-
dimensional array of MAC units that uses a scratchpad and FIFO
buffers for storage [52].
9 DISCUSSION & RELATED WORK
Discussion. To evade Cyclone, an attacker can spread the cycles
over time-windows to keep the values closer to benign interference,
which greatly reduces bandwidth (down to single bits per second in
our experiments). Alternatively, an attacker can eliminate cycles of
interference by colluding with another security domain, attempting
to mislead a defense when it initializes the security label lattice.
To avoid collusion, security domains must be set up to correctly
reflect trust assumptions (e.g., each identity/origin gets a single label
that is assigned to all VMs spawned by that origin). Identities thus
rely on real-world constraints such as credit card numbers used to
purchase cloud services to throttle unconstrained collusion among
labels. Alternatively, the system must be configured to isolate each
domain from the union of all other domains. Cyclone provides alerts
that can be combined with OS-level signals (e.g., from osquery [39])
and handled in software [62]. We expect an end-to-end attack will
exhibit behavior such as filesystem and network activity that can be
used to drive down our false-positive rate. We note that processing
a few alerts per second will have a negligible impact on overall
system performance.
Related Work. Cyclone improves upon contention-tracking detectors [13, 38] by exploring the opportunity to track cyclic interference and introducing an efficient distributed detection architecture.
OS techniques like timing protection [27] can be used in addition
to Cyclone to trade-off overheads in various settings.
Rather than detect when a side-channel is exploited at run-time,
some approaches aim to verify there is no information leakage
in the micro-architecture [24, 25, 41, 75, 76, 92]. Deng et. al. [19]
introduce a three-step model that verifies the existence of sidechannels in secure-cache designs by searching through possible
execution paths; this work identifies a similar flow of interference.
Tagged architectures have a long history dating back to the 60s
and 70s [26], with use cases such as capabilities [36, 88], memory safety [64, 87], and taint tracking [16, 72]. Compared to traditional page-sized metadata (e.g., RWX permissions), some of these
systems propose efficient mechanisms for finer-granularity metadata [42, 87]. Cyclone leverages these principles to enable cache-line
granularity tagging of memory, as well as tagging of resources in
the micro-architecture. Other systems [58] utilize similar microarchitectural tagging for quality-of-service instead of domain tracking. Cyclone could repurpose the tagging support provided by these
architectures to implement interference tracking. For example [16]
provides 4 bits per memory word which could be used to track
domains per cache line.
10 CONCLUSION
We introduce Cyclone, a distributed anomaly detection system that
tracks a new property called cyclic interference which is common to
all known contention-based cache information leaks. Our extensive
full-system evaluation with browser- and core-level isolation shows
that cyclic interference is extremely resilient to false positives while
remaining highly accurate. Cyclone provides a new conceptual
direction for achieving protection of micro-architectural structures,
especially in fine-grained isolation scenarios where partitioning
across tens of security domains does not scale.
