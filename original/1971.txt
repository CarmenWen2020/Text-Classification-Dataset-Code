ABSTRACT
The effectiveness of deep neural networks (DNN) in vision, speech,
and language processing has prompted a tremendous demand for
energy-efficient high-performance DNN inference systems. Due to
the increasing memory intensity of most DNN workloads, main
memory can dominate the system’s energy consumption and stall
time. One effective way to reduce the energy consumption and
increase the performance of DNN inference systems is by using
approximate memory, which operates with reduced supply voltage and reduced access latency parameters that violate standard
specifications. Using approximate memory reduces reliability, leading to higher bit error rates. Fortunately, neural networks have an
intrinsic capacity to tolerate increased bit errors. This can enable
energy-efficient and high-performance neural network inference
using approximate DRAM devices.
Based on this observation, we propose EDEN, the first general
framework that reduces DNN energy consumption and DNN evaluation latency by using approximate DRAM devices, while strictly
meeting a user-specified target DNN accuracy. EDEN relies on two
key ideas: 1) retraining the DNN for a target approximate DRAM
device to increase the DNN’s error tolerance, and 2) efficient mapping of the error tolerance of each individual DNN data type to a
corresponding approximate DRAM partition in a way that meets
the user-specified DNN accuracy requirements.
We evaluate EDEN on multi-core CPUs, GPUs, and DNN accelerators with error models obtained from real approximate DRAM
devices. We show that EDEN’s DNN retraining technique reliably
improves the error resiliency of the DNN by an order of magnitude.
For a target accuracy within 1% of the original DNN, our results
show that EDEN enables 1) an average DRAM energy reduction
of 21%, 37%, 31%, and 32% in CPU, GPU, and two different DNN
accelerator architectures, respectively, across a variety of state-ofthe-art networks, and 2) an average (maximum) speedup of 8% (17%)
and 2.7% (5.5%) in CPU and GPU architectures, respectively, when
evaluating latency-bound neural networks.
CCS CONCEPTS
• Computing methodologies → Neural networks; • Computer
systems organization → Neural networks; Special purpose systems; • Hardware → Dynamic memory.
KEYWORDS
deep neural networks, error tolerance, energy efficiency, machine
learning, DRAM, memory systems
1 INTRODUCTION
Deep neural networks (DNNs) [87, 90] are an effective solution to
challenges in computer vision, speech recognition, language translation, drug discovery, robotics, particle physics, and a number of
other domains [9, 22, 41, 49, 50, 68, 84, 87, 102, 137, 149]. DNNs
and their various flavors (convolutional neural networks [84], fullyconnected neural networks [88], and recurrent neural networks
[49]) are commonly evaluated in settings with edge devices that
demand low energy and real-time responses [13, 146]. Unfortunately, DNNs have high computational and memory demands that
make these energy and performance requirements difficult to fulfill.
As such, neural networks have been the subject of many recent
accelerators and DNN-focused architectures. Recent works (e.g.,
[6–8, 14, 25, 26, 29, 52, 54, 70, 100, 126, 152, 154, 158, 181]) focus on
building specialized architectures for efficient computation scheduling and dataflow to execute DNNs [86, 109].
Improvements to accelerator efficiency [27, 85], DNN-optimized
GPU kernels [23, 28], and libraries designed to efficiently leverage instruction set extensions [23, 83] have improved the computational efficiency of DNN evaluation. However, improving the
memory efficiency of DNN evaluation is an on-going challenge
[13, 29, 37, 54, 107, 148]. The memory intensity of DNN inference is
increasing, and the sizes of state-of-art DNNs have grown dramatically in recent years. The winning model of the 2017 ILSVRC image
recognition challenge [140], ResNeXt, contains 837M FP32 parameters (3.3 GB) [171]. This is 13.5x the parameter count of AlexNet,
the winning model in 2012 [84]. More recent models have broken
the one billion FP32 parameter mark (3.7 GB) [153]. As the machine
learning community trends towards larger, more expressive neural
networks, we expect off-chip memory problems to bottleneck DNN
evaluation.
The focus of this work is to alleviate two main issues (energy
and latency) of off-chip DRAM for neural network workloads. First,
DRAM has high energy consumption. Prior works on DNN accelerators report that between 30 to 80% of system energy is consumed by
DRAM [26, 99, 113, 130]. Second, DRAM has high latency. A load or
store that misses the last level cache (LLC) can take 100x longer time
to service compared to an L1 cache hit [32, 43, 44, 96, 114–116, 159].
Prior work in accelerator design has targeted DRAM latency as a
challenge for sparse and irregular DNN inference [165].
To overcome both DRAM energy and latency issues, recent
works use three main approaches. First, some works reduce numeric bitwidth, reuse model weights, and use other algorithmic
strategies to reduce the memory requirements of the DNN workload [24, 48, 55, 60, 64, 66, 82, 103, 117, 146, 172, 175, 176, 184]. Second, other works propose new DRAM designs that offer lower en166
ergy and latency than commodity DRAM [19–21, 57, 91, 93, 94, 168].
Third, some works propose processing-in-memory approaches that
can reduce data movement and access data with lower latency and
energy [13, 29, 40, 45, 65, 101, 107, 148, 150, 152]. In this work, we
propose an approach that is orthogonal to these existing works: we
customize the major operational parameters (e.g., voltage, latency)
of existing DRAM chips to better suit the intrinsic characteristics
of a DNN. Our approach is based on two key insights:
(1) DNNs demonstrate remarkable robustness to errors introduced in input, weight, and output data types. This error
tolerance allows accurate DNN evaluation on unreliable hardware if the DNN error tolerance is accurately characterized
and bit error rates are appropriately controlled.
(2) DRAM manufacturers trade performance for reliability. Prior
works show that reducing DRAM supply voltage and timing
parameters improves the DRAM energy consumption and
latency, respectively, at the cost of reduced reliability, i.e.,
increased bit error rate [15, 19, 21, 47, 94].
To exploit these two insights, we propose EDEN1
: the first framework that improves energy efficiency and performance for DNN
inference by using approximate DRAM, which operates with reduced DRAM parameters (e.g., voltage and latency). EDEN strictly
meets a user-specified target DNN accuracy by providing a general
framework that 1) uses a new retraining mechanism to improve
the accuracy of a DNN when executed on approximate DRAM, and
2) maps the DNN to the approximate DRAM using information obtained from rigorous characterizations of the DNN error tolerance
and DRAM error properties.
EDEN is based on three key steps. First, EDEN improves the error
tolerance of the target DNN by retraining the DNN using the error
characteristics of the approximate DRAM module. Second, EDEN
profiles the improved DNN to identify the error tolerance levels
of all DNN data (e.g., different layer weights of the DNN). Third,
EDEN maps different DNN data to different DRAM partitions that
best fit each datum’s characteristics, and accordingly selects the
voltage and latency parameters to operate each DRAM partition.
By applying these three steps, EDEN can map an arbitrary DNN
workload to an arbitrary approximate DRAM module to evaluate a
DNN with low energy, high performance, and high accuracy.
To show example benefits of our approach, we use EDEN to
run inference on DNNs using approximate DRAM with 1) reduced
DRAM supply voltage (VDD ) to decrease DRAM energy consumption, and 2) reduced DRAM latency to reduce the execution time of
latency-bound DNNs. EDEN adjusts the DRAM supply voltage and
DRAM latency through interaction with the memory controller
firmware. For a target accuracy within 1% of the original DNN, our
results show that EDEN enables 1) an average DRAM energy reduction of 32% across CPU, GPU and DNN accelerator (e.g., Tensor
Processing Unit [69]) architectures, and 2) cycle reductions of up
to 17% when evaluating latency-bound neural networks.
Our evaluation indicates that the larger benefits of EDEN would
stem from its capacity to run on most hardware platforms in use
today for neural network inference, including CPUs, GPUs, FPGAs,
and DNN accelerators. Because EDEN is a general approach, its
principles can be applied 1) on any platform that uses DRAM, and 2)
across memory technologies that can trade-off different parameters
(e.g., voltage, latency) at the expense of reliability. Although our
evaluation examines supply voltage and access latency reductions,
the EDEN framework can be used also to improve performance
and energy in other ways: for example, EDEN could increase the
1Energy-Efficient Deep Neural Network Inference Using Approximate DRAM
effective memory bandwidth by increasing the data bus frequency
at the expense of reliability.
This paper makes the following five key contributions:
• We introduce EDEN, the first general framework that increases the energy efficiency and performance of DNN inference by using approximate DRAM that operates with
reduced voltage and latency parameters at the expense of
reliability. EDEN provides a systematic way to scale main
memory parameters (e.g., supply voltage and latencies) while
achieving a user-specified DNN accuracy target.
• We introduce a methodology to retain DNN accuracy in the
presence of approximate DRAM. Our evaluation shows that
EDEN increases the bit error tolerance of a DNN by 5-10x
(depending on the network) through a customized retraining
procedure called curricular retraining.
• We provide a systematic, empirical characterization of the
resiliency of state-of-art DNN workloads [63, 64, 146] to
the errors introduced by approximate DRAM. We examine
error resiliency across different numeric precisions, pruning
levels, and data types (e.g. DNN layer weights). We find that
1) lower precision levels and DNN data closer to the first and
last layers exhibit lower error resiliency, and 2) magnitudebased pruning does not have a significant impact on error
resiliency.
• We propose four error models to represent the common error
patterns that an approximate DRAM device exhibits. To do
so, we characterize the bit flip distributions that are caused
by reduced voltage and latency parameters on eight real
DDR4 DRAM modules.
• We evaluate EDEN on multi-core CPUs, GPUs, and DNN
accelerators. For a target accuracy within 1% of the original
DNN, our results show that EDEN enables 1) an average
DRAM energy reduction of 21%, 37%, 31%, and 32% in CPU,
GPU, and two different DNN accelerator architectures, respectively, across a variety of state-of-the-art networks, and
2) an average (maximum) speedup of 8% (17%) and 2.7% (5.5%)
in CPU and GPU architectures, respectively, when evaluating latency-bound neural networks. For a target accuracy
the same as the original, EDEN enables 16% average energy
savings and 4% average speedup in CPU architectures.
2 BACKGROUND
2.1 Deep Neural Networks
A deep neural network (DNN) is a neural network with more than
two layers [87]. DNNs are composed of a variety of different layers,
including convolutional layers, fully-connected layers, and pooling
layers. Figure 1 shows the three main data types of a DNN layer,
and how three DNN layers are connected with each other. Each
of these layers is defined by a weight matrix learned via a onetime training process that is executed before the DNN is ready for
inference. The three DNN data types that require loads and stores
from main memory include each layer’s input feature maps (IFMs),
output feature maps (OFMs), and the weights. Each layer processes
its IFMs using the layer’s weights, and produces OFMs. The OFMs
of a layer are fed to the next layer as the next layer’s IFMs. In this
work, we explore the introduction of bit errors into the three data
types of each layer.
Modern DNNs contain hundreds of layers, providing the DNN
with a large number of trainable weights. The existence of such
a large number of weights is commonly referred to as overparameterization, and is, in part, the source of a DNN’s accuracy [42].
167
Layer
N-1
Layer
N
Layer
N+1
Weights Weights Weights
… OFMs/IFMs OFMs/IFMs … OFMs/IFMs
Weights Weights Weights Weights Weights
Weights
OFMs/IFMs OFMs/IFMs OFMs/IFMs OFMs/IFMs OFMs/IFMs OFMs/IFMs OFMs/IFMs
OFMs/IFMs OFMs/IFMs
Figure 1: Example of three DNN layers. Each layer is composed of its weights, input feature maps (IFMs), and output
feature maps (OFMs).
Overparameterization allows the model to have sufficient learning capacity so that the network can approximate complex inputoutput functions, and adequately capture high-level semantics (e.g.,
the characteristics of a cat in an input image) [120]. Importantly,
overparameterization allows the network to obtain some level of
error resilience, generalize across different inputs, and be robust
to insignificant changes to the input (e.g., background pixels in an
image) [123]. Common training-time techniques such as adding
white noise and input feature map dropout try to force the network
to not rely on any single OFM element and enable robustness in
the presence of statistical variance in the IFMs [160]. In this work,
we show that we can also adapt DNNs and their training procedure to achieve partial error robustness against bit errors caused
by approximate DRAM, by fundamentally taking advantage of the
overparameterization in the DNN.
Quantization. Quantizing floating-point weights and OFMs into
low-precision fixed-point numbers can greatly improve performance and energy consumption of DNNs [62]. Many prior works
demonstrate that it is possible to quantize DNNs to limited numeric
precision (e.g., eight-bit integers) without significantly affecting
DNN accuracy [33, 55, 62, 66, 103, 165, 170, 184]. In our evaluations,
we quantize all DNN models to four different numeric precisions :
int4 (4-bit), int8 (8-bit), int16 (16-bit), and FP32 (32-bit).
Pruning. Pruning [34] reduces the memory footprint of a DNN by
sparsifying the weights and feature maps. This is done by zeroing
the lowest magnitude weights and retraining [55, 98, 177]. We study
the effects of pruning in our evaluations.
Training. Training is the process of estimating the best set of
weights that maximize the accuracy of DNN inference. Training is
usually performed with an iterative gradient descent algorithm [139]
using a particular training dataset. The training dataset is divided
into batches. One iteration is the number of batches needed to complete one epoch. One epoch completes when the entire dataset is
passed once through the training algorithm.
2.2 DRAM Organization and Operation
DRAM Organization. A DRAM device is organized hierarchically.
Figure 2a shows a DRAM cell that consists of a capacitor and an
access transistor. A capacitor encodes a bit value with its charge
level. The DRAM cell capacitor is connected to a bitline via an access
transistor that is controlled by a wordline. Figure 2b shows how the
DRAM cells are organized in the form of a 2D array (i.e., a subarray).
Cells in a column of a subarray share a single bitline. Turning on an
access transistor causes charge sharing between the capacitor and
the bitline, which shifts the bitline voltage up or down based on
the charge level of the cell’s capacitor. Each bitline is connected to
a sense amplifier (SA) circuit that detects this shift and amplifies it
to a full 0 or 1. The cells that share the same wordline in a subarray
are referred to as a DRAM row. A row decoder drives a wordline
to enable all cells in a DRAM row. Therefore, charge sharing and
sense amplification operate at row granularity. The array of sense
amplifiers in a subarray is referred to as row buffer. Each subarray
SA
SA
SA
SA
SA
SA
Row	Decoder
Wordline
Bitline
Access	
TransistorCapacitor
(a)	DRAM	Cell (b)	DRAM	Subarray (c)	DRAM	device
Memory	Controller
Row	Buffer
bank
DRAM	chips
…
bank
bank
bank
bank
I/O	logicbank
bank
bus
Figure 2: DRAM organization.
typically consists of 512-1024 rows each of which is typically as
large as 2-8KB.
Figure 2c shows the organization of subarrays, banks, and chips
that form a DRAM device. Each bank partially decodes a given row
address and selects the corresponding subarray’s row buffer. On
a read operation, the I/O logic sends the requested portion of the
target row from the corresponding subarray’s row buffer to the
memory controller. A DRAM chip contains multiple banks that
can operate in parallel. A DRAM device is composed of multiple
DRAM chips that share the same command/address bus and are
simultaneously accessed to provide high bandwidth and capacity.
In a typical system, each memory controller interfaces with a single
DRAM bus. We refer the readers to [17, 19–21, 56, 57, 73, 79, 91, 93,
94, 105, 106, 151, 162, 168, 182] for more detail on DRAM structure
and design.
DRAM Operation. Accessing data stored in each row follows
the sequence of memory controller commands illustrated in Figure 3. First, the activation command (ACT) activates the row by
pulling up the wordline and enabling sense amplification. After
a manufacturer-specified tRCD nanoseconds, the data is reliably
sensed and amplified in the row buffer. Second, the read command
(READ) reads the data from the row buffer to the IO circuitry. After
a manufacturer-specified CL nanoseconds, the data is available on
the memory bus. Third, the precharge command (PRE) prepares the
DRAM bank for activation of another row. A precharge command
can be issued a manufacturer-specified tRAS nanoseconds after an
activation command, and an activation command can be issued tRP
nanoseconds after a precharge command. tRCD , tRAS , tRP , and CL
are examples of DRAM timing parameters and their nominal values
provided in DRAM DDR4 datasheets are 12.5ns, 32ns, 12.5ns, and
12.5ns respectively [67].
ACT READ PRE ACT
Data
tRCD CL
tRAS tRP
Timing
Parameters
Commands
Data	Bus
Figure 3: DRAM read timing. We explore reductions oftRCD ,
tRAS , and tRP as part of EDEN’s evaluation. CL is a characteristic of the device, and not adjustable in the memory controller [67].
2.3 Reducing DRAM Parameters
We build on a large body of work on characterizing DRAM behavior
in sub-reliable operation regimes of supply voltage and latency
parameters [15, 18, 19, 21, 58, 76–78, 93, 94, 105, 128].
DRAM Voltage Reduction. Voltage reduction is critical to reducing DRAM power consumption since power is proportional
to the square of supply voltage (i.e., VDD
2 × f ) [112, 167]. Prior
research [21, 36] shows that reducing voltage increases the propagation delay of signals, which can cause errors when using unmodified
168
timing parameters. One work avoids these errors by increasing the
tRCD and tRP latencies [21] to ensure reliable operation. In contrast,
our goal in this work is to aggressively reduce power consumption
and latency by decreasing both supply voltage and timing parameters, which inevitably causes errors in the form of bit flips in the
weakest cells of DRAM, making DRAM approximate. Resulting
error patterns often exhibit locality. Chang et al. [21] observe that
these bit flips accumulate in certain regions (e.g., banks and rows)
of DRAM.
DRAM Access Latency Reduction. Latency reduction is critical
to increase system performance, as heavily emphasized by a recent
study on workload-DRAM interactions [46]. Previous works characterize real DRAM devices to find the minimum reliable row activation (tRCD ) and precharge (tRP ) latency values [18, 19, 76, 93, 94].
According to these studies, the minimum DRAM latency values are
significantly smaller than the values that datasheets report, due
to conservative guardbands introduced by DRAM manufacturers.
Further reducing these latency values cause bit flips in weak or
unstable DRAM cells.
DRAM Refresh Rate Reduction. Other than voltage and latency,
previous research also shows that reducing the refresh rate of
DRAM chips both can increase performance and reduce energy
consumption at the cost of introducing errors [35, 58, 72, 74, 75,
105, 106, 128, 129] that are tolerable by many workloads that can
tolerate bit errors [5, 71, 122, 183].
3 EDEN FRAMEWORK
To efficiently solve the energy and latency issues of off-chip DRAM
for neural network workloads, we propose EDEN. EDEN is the
first general framework that improves energy efficiency and performance for neural network inference by using approximate DRAM.
EDEN is based on two main insights: 1) neural networks are tolerant to errors, and 2) DRAM timing parameters and voltage can be
reduced at the cost of introducing more bit errors.
We first provide an overview of EDEN in Section 3.1, and explain
EDEN’s three steps in Sections 3.2, 3.3, and 3.4. Finally, Section 3.5
explains the changes required by the target DNN inference system
to support a DNN generated by EDEN.
3.1 EDEN: A High Level Overview
EDEN enables the effective execution of DNN workloads using
approximate DRAM through three key steps: 1) boosting DNN error
tolerance, 2) DNN error tolerance characterization, and 3) DNNDRAM mapping. These steps are repeated iteratively until EDEN
finds the most aggressive DNN and DRAM configuration that meets
the target accuracy requirements. EDEN transforms a DNN that
is trained on reliable hardware into a device-tuned DNN that is
able to run on a system that uses approximate DRAM at a target
accuracy level. EDEN allows tight control of the trade-off between
accuracy and performance by enabling the user/system to specify
the maximal tolerable accuracy degradation. Figure 4 provides an
overview of the three steps of EDEN, which we describe next.
1. Boosting DNN Error Tolerance. EDEN introduces curricular
retraining, a new retraining mechanism that boosts a DNN’s error
tolerance for a target approximate DRAM module. Our curricular
retraining mechanism uses the error characteristics of the target
approximate DRAM to inject errors into the DNN training procedure and boost the DNN accuracy. The key novelty of curricular
retraining is to inject errors at a progressive rate during the training process with the goal of increasing DNN error tolerance while
avoiding accuracy collapse with error correction. EDEN boosts
Final
DNN
DNN	to	DRAM	
Mapping
3
Baseline
DNN
DNN
Error
Profile
DNN
Accuracy	
Target
Boosted
DNN
Boos=ng
DNN	Error	Tolerance
1
DNN	Error	Tolerance	
Characteriza=on
2
DRAM
Error
Profile
Figure 4: Overview of the EDEN framework.
the intrinsic bit error tolerance of the baseline DNN by 5-10x. We
describe our boosting mechanism in Section 3.2.
2. DNN Error Tolerance Characterization. EDEN characterizes
the error resilience of each boosted DNN data type (i.e., IFMs, OFMs,
and DNN weights) to identify the limits of bit error tolerance. EDEN
measures the effect of bit errors on overall accuracy using the DNN
validation dataset. We describe error tolerance characterization in
Section 3.3.
3. DNN to DRAM Mapping. EDEN maps the error tolerance of
each DNN data type to a corresponding approximate DRAM partition (e.g., chip, bank, or subarray) in a way that meets the specified
accuracy requirements, while maximizing performance. We describe DNN to DRAM mapping in Section 3.4.
Together, the three steps of EDEN enable a baseline DNN to
become a specialized DNN that is error-tolerant and device-tuned
to a target approximate DRAM. EDEN enables energy efficient, highperformance DNN inference on the target approximate DRAM with
a user-defined accuracy.
3.2 Boosting DNN Error Tolerance
According to our evaluations, the error tolerance of common DNNs
is not sufficient to enable significant DRAM voltage and timing
parameter reductions. To overcome this issue, we propose curricular
retraining, a new retraining mechanism that improves the error
tolerance of a DNN when running with approximate DRAM that
injects errors into memory locations accessed by the DNN.
The key idea of curricular retraining is based on the observation
that introducing high error rates immediately at the beginning of
retraining process occasionally causes training divergence and a
phenomenon called accuracy collapse. To mitigate this problem,
curricular retraining slowly increases the error rate of the approximate DRAM from 0 to a target value in a step-wise fashion. In our
experiments, we observe a good training convergence rate when
we increase the error rate every two epochs (i.e., two passes of
the entire training dataset). EDEN uses approximate DRAM in the
forward pass, and it uses reliable DRAM for the backward pass.
We demonstrate in Section 6.4 that our curricular retraining
mechanism is effective at improving the accuracy of DNN inference
executed on systems with approximate DRAM.
Our experiments show that curricular retraining does not help
to improve DNN accuracy on reliable DRAM. This implies that
introducing bit error is not a regularization technique,2 but rather, a
way of obtaining congruence between the DNN training algorithms
and the errors injected by approximate DRAM.
Correcting Implausible Values. While executing curricular retraining, a single bit error in the exponent bits of a floating point
2Regularization is a technique that makes slight modifications to the training algorithm
such that the DNN model generalizes better.
169
value can cause accuracy collapse in the trained DNN. For example, a bit error in the exponent of a weight creates an enormously
large value (e.g., >108
) that propagates through the DNN layers,
dominating weights that are significantly smaller (e.g., <10).
To avoid this issue, we propose a mechanism to avoid accuracy
collapse caused by bit errors introduced by approximate DRAM.
The key idea of our mechanism is to correct the values that are
implausible. When a value is loaded from memory, our mechanism
probabilistically detects that a data type likely contains an error by
comparing its value against predefined thresholds. The thresholds
of the curricular retraining data types are computed during training
of the baseline DNN on DRAM with nominal parameters. Those
thresholds usually have rather small values (e.g., most weights in
SqueezeNet1.1 are within the range [-5,5]).
Upon detection of an error (i.e, the fact that a value is out of
the threshold range) during curricular retraining, EDEN 1) corrects
the erroneous value by zeroing the value, and 2) uses the corrected
value for curricular retraining.
Our mechanism for correcting implausible values can be implemented in two ways. First, a software implementation that modifies
the DNN framework to include extra instructions that correct implausible values resulting from each DNN memory access. Second,
a hardware implementation that adds a simple hardware logic to
the memory controller that corrects implausible values resulting
from each approximate DRAM memory request. Section 5 describes
our low cost hardware implementation.
In our experiments, we find that our mechanism for correcting
implausible values increases the tolerable bit error rate from 10−7
to 10−3
to achieve <1% accuracy degradation in the eight FP32
DNNs we analyze. We evaluate an alternative mechanism for error
correction that saturates an out-of-threshold value (by resetting to
the closest threshold value) instead of zeroing it. We observe that
saturating obtains lower DNN accuracy than zeroing at the same
approximate DRAM bit error rate across all DNN models (e.g., 8% on
CIFAR-10 and 7% on ImageNet). We also correct implausible values
during the execution of DNN inference to improve the inference
accuracy (Section 3.5).
3.3 DNN Error Tolerance Characterization
EDEN aims to guarantee that the accuracy of a DNN meets the
minimum value required by the user. To this end, EDEN characterizes the boosted DNN (obtained from our boosting mechanism in
Section 3.2) to find the maximum tolerable bit error rate (BER) by
progressively decreasing the approximate DRAM parameters, i.e.,
voltage and latency. EDEN performs either a coarse-grained or a
fine-grained DNN error tolerance characterization.
Coarse-Grained Characterization. EDEN’s coarse-grained characterization determines the highest BER that can be applied uniformly to the entire DNN, while meeting the accuracy requirements
of the user. This characterization is useful for mapping the DNN
to commodity systems (see Section 3.4) that apply reduced DRAM
parameters to an entire DRAM module (without fine-grained control).
To find the highest BER that satisfies the accuracy goal, our
coarse-grained characterization method performs a logarithmicscale binary search on the error rates. We can use binary search because we found that DNN error-tolerance curves are monotonically
decreasing. To adjust the BER while doing this characterization,
EDEN can either 1) tune the parameters of approximate DRAM,
or 2) use DRAM error models for injecting bit errors into memory
locations (see Section 4). EDEN optimizes the error resiliency of
a DNN by repeating cycles of DNN error tolerance boosting (Section 3.2), coarse-grained DNN characterization, and DNN to DRAM
mapping (Section 3.4) until the highest tolerable BER stops improving. We evaluate our coarse-grained characterization mechanism
in Section 6.5.
Fine-Grained Characterization. EDEN can exploit variation in
the error tolerances of different DNN data types by clustering the
data according to its error tolerance level, and assigning each cluster
to a different DRAM partition whose error rate matches the error
tolerance level of the cluster (see Section 3.4). For example, we find
that the first and the last convolutional layers have tolerable BERs
2-3x smaller than the average middle layer in a DNN (in agreement
with prior work [166, 180]).
To conduct a fine-grained DNN characterization, EDEN searches
for the highest tolerable BER of each weight and IFM that still
yields an acceptable DNN accuracy. This search space is exponential with respect to the DNN’s layer count. To tackle the search
space challenge, EDEN employs a DNN data sweep procedure that
performs iterations over a list of DNN data types. The mechanism
tries to increase the tolerable error rate of a data type by a small
amount, and tests if the DNN still meets the accuracy requirements.
When a DNN data type cannot tolerate more increase in error rate,
it is removed from the sweep list. We evaluate our fine-grained
characterization mechanism in Section 6.6.
Effect of Pruning. EDEN does not include pruning (Section 2.1)
as part of its boosting routine due to two observations. First, we
find that DNN sparsification does not improve the error tolerance.
Our experiments show that when we create 10%, 50%, 75%, and
90% sparsity through energy-aware pruning [175], error tolerance
of FP32 and int8 DNNs, DNN error tolerance does not improve
significantly. Second, the zero values in the network, which increase
with pruning, are sensitive to memory error perturbations.
3.4 DNN to DRAM Mapping
After characterizing the error tolerance of each DNN data type,
EDEN maps each data type to the appropriate DRAM partition (with
the appropriate voltage and latency parameters) that satisfies the
data type’s error tolerance. Our mechanism aims to map a data type
that is very tolerant (intolerant) to errors into a DRAM partition
with the highest (lowest) BER, matching the error tolerance of the
DNN and the BER of the DRAM partition as much as possible.
DRAM Bit Error Rate Characterization. To obtain the BER characteristics of a DRAM device (both in aggregate and for each partition), we perform reduced voltage and reduced latency tests for
a number of data patterns. For each voltage level, we iteratively
test two consecutive rows at a time. We populate these rows with
inverted data patterns for the worst-case evaluation. Then, we
read each bit with reduced timing parameters (e.g., tRCD). This
characterization requires fine-grained control of the DRAM timing parameters and supply voltage level. EDEN’s characterization
mechanism is very similar to experimental DRAM characterization
mechanisms proposed and evaluated in prior works for DRAM
voltage [21, 47] and DRAM latency [18, 19, 58, 76, 93, 94].
Coarse-grained DNN to DRAM module mapping. All DNN
data types stored within the same DRAM module are exposed to the
same DRAM voltage level and timing parameters. These parameters
are tuned to produce a bit error rate that is tolerable by all DNN
data types that are mapped to the module.
Under coarse-grained mapping, the application does not need
to be modified. Algorithms used in DNN inference are oblivious to
170
the DRAM mapping used by the memory controller. The memory
controller maps all inference-related requests to the appropriate
approximate DRAM module. Data that cannot tolerate bit errors
at any reduced voltage and latency levels is stored in a separate
DRAM module whose voltage and latency parameters follow the
manufacturer specifications.
Coarse-grained mapping can be easily supported by existing systems that allow the modification ofVdd and/ortRCD/RP parameters
in the BIOS across the entire DRAM module. Section 5 describes
the simple hardware changes required to support coarse-grained
mapping. We evaluate our coarse-grained mapping mechanism in
Section 6.5.
Fine-grained DNN to DRAM module mapping. DNN data types
stored in different DRAM partitions can be exposed to different
DRAM voltage levels and/or timing parameters. DRAM can be
partitioned at chip, rank, bank, or subarray level granularities. Algorithm 1 describes our algorithm for fine-grained mapping of DNN
data to DRAM partitions. Our algorithm uses rigorous DRAM characterization and DNN characterization to iteratively assign DNN
data to DRAM partitions in three basic steps. First, our mechanism
looks for DRAM partitions that have BERs lower than the tolerable BER of a given DNN data type. Second, we select the DRAM
partition with the largest parameter reduction that meets the BER
requirements. Third, if the partition has enough space available,
our mechanism assigns the DNN data type to the DRAM partition.
We evaluate our fine-grained mapping mechanism in Section 6.6.
Algorithm 1 Fine-grained DNN to DRAM mapping
1 function DNN_to_DRAM_Mapping(DNN_characterization,
DRAM_characterization):
2 sorted_data = sort_DNN_data(DNN_characterization)
3 for (target_BER, DNN_data) in sorted_data:
4 # Find the DRAM partition that has the least
voltage/latency at target_BER, and can fit
the DNN_data
5 for DRAM_partition in DRAM_characterization
6 partition_params =
get_voltage_latency(DRAM_partition,
target_BER)
7 if DNN_data.size < DRAM_partition.size :
8 if partition_params < best_parameters:
9 best_parameters = partition_params
10 chosen_partition = DRAM_partition
11 DRAM_partition.size -= DNN_data.size
12 final_mapping[chosen_partition].append(DNN_data)
13 return final_mapping
A system that supports fine-grained mapping requires changes
in the memory controller (for voltage and latency adjustment) and
in DRAM (for only voltage adjustment). We describe the hardware
changes required to support fine-grained mapping in Section 5.
3.5 DNN Inference with Approximate DRAM
EDEN generates a boosted DNN for running inference in a target system that uses approximate DRAM. EDEN does not require
any modifications in DNN inference hardware, framework, or algorithm, except for correcting implausible values. Similar to what
happens in our curricular retraining (Section 3.2), a single bit error
in the exponent bits of a floating point value can cause accuracy
collapse during DNN inference. We use the same mechanism for correcting implausible values in our curricular retraining mechanism
(i.e., we zero the values that are outside of a predefined threshold
range) to avoid accuracy collapse caused by bit errors introduced
by approximate DRAM during DNN inference.
4 ENABLING EDEN WITH ERROR MODELS
EDEN requires extensive characterization of the target approximate
DRAM device for boosting DNN error tolerance (Section 3.2), characterization of DNN error tolerance (Section 3.3), and mapping of
the DNN to the approximate DRAM device (Section 3.4). However,
applying EDEN in a target system where DNN inference can be
performed is not always feasible or practical. For example, a lowcost DNN inference accelerator [26] might perform very slowly
when executing our curricular retraining mechanism, because it
is not optimized for training. Similarly, the target hardware might
not be available, or might have very limited availability (e.g., in the
pre-production phase of a new approximate hardware design).
To solve this problem and enable EDEN even when target DRAM
devices are not available for characterization, we propose to execute
the EDEN framework in a system that is different from the target
approximate system. We call this idea EDEN offloading. The main
challenge of offloading EDEN to a different system is how to faithfully emulate the errors injected by the target approximate DRAM
into the DNN. To address this challenge, we use four different error
models that are representative of most of the error patterns that
are observed in real approximate DRAM modules.
EDEN’s DRAM Error Models. EDEN uses four probabilistic error
models that closely fit the error patterns observed in a real approximate DRAM module. Our models contain information about the
location of weak cells in the DRAM module, which is used to decide
the spatial distribution of bit errors during DNN error tolerance
boosting. We create four different types of error models from the
data we obtain based on our characterization of existing DRAM
devices using SoftMC [58] and a variety of DDR3 and DDR4 DRAM
modules. Our error models are consistent with the error patterns
observed by prior works [19, 21, 76–78, 94]. In addition, our error
models are parameterizable and can be tuned to model individual
DRAM chips, ranks, banks, and subarrays from different vendors.
• Error Model 0: the bit errors follow a uniform random
distribution across a DRAM bank. Several prior works observe that reducing activation latency (tRCD ) and precharge
latency (tRP ) can cause randomly distributed bit flips due
to manufacturing process variation at the level of DRAM
cells [15, 19, 93, 94]. We model these errors with two key
parameters: 1) P is the percentage of weak cells (i.e., cells
that fail with reduced DRAM parameters), and 2) FA is the
probability of an error in any weak cell. Such uniform random distributions are already observed in prior works [10,
53, 133, 164].
• Error Model 1: the bit errors follow a vertical distribution
across the bitlines of a DRAM bank. Prior works [19, 21,
76, 93] observe that some bitlines experience more bit flips
than others under reduced DRAM parameters due to: 1)
manufacturing process variation across sense amplifiers [19,
21, 76], and 2) design-induced latency variation that arises
from the varying distance between different bitlines and
the row decoder [93]. We model this error distribution with
two key parameters: 1) PB is the percentage of weak cells in
bitline B, and 2) FB is the probability of an error in the weak
cells of bitline B.
171
1.1 1.2
10 9
10 6
10 3
100
Bit Error Rate
Vendor A
0xff
0xcc
0xaa
0x00
1.1 1.2
Supply Voltage (V)
Vendor B
1.1 1.2 1.3
Vendor C
2.5 5.0 7.5 10.0
10 9
10 6
10 3
100
Bit Error Rate
Vendor A
2.5 5.0 7.5 10.0
tRCD (ns)
Vendor B
2.5 5.0 7.5 10.0
Vendor C
Figure 5: Bit error rates depend on the data pattern stored
in DRAM, with reduced supply voltage [21] and reduced
tRCD [19, 21, 76, 93, 94], motivating Error Model 3. Data is
based on DDR3 DRAM modules from three major vendors.
• Error Model 2: the bit errors follow a horizontal distribution across the wordlines of a DRAM bank. Prior works [19,
21, 76, 93] observe that some DRAM rows experience more
bit flips than others under reduced DRAM parameters due to
1) manufacturing process variation across DRAM rows [19,
21, 76], and 2) design-induced latency variation that arises
from the varying distance between different DRAM rows
and the row buffer [93]. We model this error distribution
with two key parameters: 1) PW is the percentage of weak
cells in wordline W , and 2) FW is the probability of an error
in the weak cells of wordline W .
• Error Model 3: the bit errors follow a uniform random
distribution that depends on the content of the cells (i.e., this
is a data-dependent error model). Figure 5 illustrates how the
bit error rates depend on the data pattern stored in DRAM,
for reduced voltage (top) and reduced tRCD (bottom). We
observe that 0-to-1 flips are more probable with tRCD scaling,
and 1-to-0 flips are more probable with voltage scaling. Prior
works provide rigorous analyses of data patterns in DRAM
with reduced voltage [21] and timing parameters [19] that
show results similar to ours. This error model has three key
parameters: 1) P is the percentage of weak cells, 2) FV 1 is
the probability of an error in the weak cells that contain a 1
value, and 3) FV 0 is the probability of an error in the weak
cells that contain a 0 value.
Model Selection. EDEN applies a maximum likelihood estimation
(MLE) [128] procedure to determine 1) the parameters (P, FA, PB,
FB, PW , FW , FV 1 and FV 0) of each error model, and 2) the error
model that is most likely to produce the errors observed in the real
approximate DRAM chip. In case two models have very similar
probability of producing the observed errors, our selection mechanism chooses Error Model 0 if possible, or one of the error models
randomly otherwise. Our selection mechanism favors Error Model
0 because we find that it the is error model that performs better.
We observe that generating and injecting errors by software with
Error Model 0 in both DNN retraining and inference is 1.3x faster
than injecting errors with other error models in our experimental
setup. We observe that Error Model 0 provides 1) a reasonable approximation of Error Model 1, if max(FB) − min(FB) < 0.05 and
PB ≈ P, and 2) a reasonable approximation of Error Model 2, if
max(FW ) − min(FW ) < 0.05 and PW ≈ P.
Handling Error Variations. Error rates and error patterns depend
on two types of factors. First, factors intrinsic to the DRAM device.
The most common intrinsic factors are caused by manufacturer
[21, 105], chip, and bank variability [77, 94]. Intrinsic factors are
established at DRAM fabrication time. Second, factors extrinsic to
the DRAM device that depend on environmental or operating conditions. The most common extrinsic factors are aging [111, 147], data
values [74], and temperature [51]. Extrinsic factors can introduce
significant variability in the error patterns.
EDEN can capture intrinsic factors in the error model with a
unique DRAM characterization pass. However, capturing extrinsic
factors in the error model is more challenging. Our DNN models
capture three factors extrinsic to the DRAM device.
First, EDEN can capture data dependent errors by generating
different error models for different DNN models (i.e., different IFM
and weight values in memory). For each DNN model, EDEN stores
the actual weight and IFM values in the target approximate DRAM
before characterization to capture data dependencies.
Second, EDEN can capture temperature variations by generating
different error models for the same approximate DRAM operating
at different temperatures. Errors increase with higher temperatures [94, 105], so the model must match the temperature of DNN
inference execution.
Third, EDEN can capture DRAM aging by periodically regenerating new error models. In our experiments with real DRAM
modules, we find that the errors are temporally consistent and stable for days of continuous execution (with ±5°C deviations from
the profiling temperature), without requiring re-characterization.
Prior works [76, 94] report similar results.
We find in our evaluation that our error models are sufficiently
expressive to generate a boosted DNN that executes on real approximate DRAM with minimal accuracy loss (Section 6.4). Our
four error models are also sufficiently expressive to encompass the
bit-error models proposed in prior works [12, 128].
5 MEMORY CONTROLLER SUPPORT
To obtain the most out of EDEN, we modify the memory controller
to 1) correct implausible values during both curricular retraining
and DNN inference, 2) support coarse-grained memory mapping,
and 3) support fine-grained memory mapping.
Hardware Support for Correcting Implausible Values. We correct implausible values that cause accuracy collapse during both
curricular retraining (Section 3.2) and DNN inference (Section 3.5).
Our mechanism 1) compares a loaded value to an upper-bound and
a lower-bound threshold, and 2) sets the value to zero (i.e., supplies
the load with a zero result) in case the value is out of bounds. Because these operations are done for every memory access that loads
a DNN value, it can cause significant performance degradation if
performed in software. To mitigate this issue, we incorporate simple
hardware logic in the memory controller that we call bounding logic.
Our bounding logic 1) compares the exponent part of the loaded
floating point value to DNN-specific upper-bound and lower-bound
thresholds, and 2) zeros the input value if the value is out of bounds.
In our implementation, the latency of this logic is only 1 cycle and
its hardware cost is negligible.
Enabling Coarse-Grained Mapping. Coarse-grained mapping
applies the same voltage and timing parameters to the entire DRAM
for executing a particular DNN workload. However, different DNN
172
workloads might require applying different sets of DRAM parameters to maximize energy savings and performance. In many existing
commodity systems, the memory controller sets the DRAM voltage and the timing parameters at start-up, and it is not possible to
change them at runtime. To overcome this limitation, the memory
controller requires minimal hardware support for changing the
DRAM parameters of each DRAM module at runtime.
Enabling Fine-Grained Mapping. Fine-grained mapping applies
different voltage and/or timing parameters to different DRAM partitions.
To apply different voltages to different memory partitions, EDEN
1) adopts the approach used by Voltron [21] to implement a robust
design for voltage scaling at the bank granularity based on modest changes to the power delivery network, and 2) tracks which
memory partition is operating at what voltage. To implement this
mechanism in commodity DDR4/LPDDR4 chips with 16/32 banks,
EDEN requires at most 32B of meta-data to represent all 8-bit voltage step values.
To apply different timing parameters to different memory partitions, EDEN requires memory controller support for 1) configuring
the target memory partition to operate at specific timing parameters,
and 2) tracking which memory partition is operating at what latency. For the timing parameter we tested in our evaluation (tRCD ),
4-bits are enough to encode all possible values of the parameter
with enough resolution.
It is sufficient for EDEN to split DRAM into at most 2
10 partitions,
because most commonly used DNN architectures have at most 1024
different types of error-resilient IFMs and weights. EDEN requires
1KB of metadata to support 2
10 partitions. To support mappings at
subarray level granularity (i.e., the finest supported granularity),
EDEN needs a larger amount of metadata. For example, for an 8GB
DDR4 DRAM module with 2048 subarrays, EDEN needs to store
2KB of metadata.
6 DNN ACCURACY EVALUATION
In this section, we evaluate EDEN’s ability to improve DNN accuracy in approximate DRAM. We explain our methodology (Section 6.1), evaluate the accuracy of our error models (Section 6.2),
evaluate the error tolerance of the DNN baselines (Section 6.3),
and analyze the accuracy of our curricular retraining mechanism
(Section 6.4).
6.1 Methodology
We use an FPGA-based infrastructure running SoftMC [3, 58] to
reduce DRAM voltage and timing parameters. SoftMC allows executing memory controller commands on individual banks, and
modifying tRCD and other DRAM timing parameters. We perform
all our experiments at room temperature. Using this infrastructure,
we can obtain characteristics of real approximate DRAM devices.
However, our infrastructure also has some performance limitations
caused by delays introduced with SoftMC’s FPGA buffering, hostFPGA data transmission, and instruction batching on the FPGA.
To overcome these performance limitations, we emulate real
approximate DRAM modules by using the error models described in
Section 4. To ensure that our evaluation is accurate, we validate our
error models against real approximate DRAM devices (Section 6.2).
We incorporate EDEN’s error models into DNN inference libraries by following the methodology described in Figure 6. We
create a framework on top of PyTorch [127] that allows us to modify the loading of weights and IFMs. Our PyTorch implementation
1) injects errors into the original IFM and weight values using
our DRAM error models, and 2) applies our mechanism to correct
implausible values caused by bit errors in IFMs and weights (Section 3.2). Our DRAM error models are implemented as custom GPU
kernels for efficient and simple integration into PyTorch. This simulation allows us to obtain DNN accuracy estimates 80-90x faster
than with the SoftMC infrastructure.
Error	Injec*on	
Using	DRAM
Error	Models
Weight/IFM
Correc*ng
Implausible	
Values
Final
Weight/IFM
Figure 6: Methodology to incorporate DRAM error models
in the DNN evaluation framework.
DNN Baselines. We describe the DNN baselines that we use
in the evaluation of the three EDEN steps (Sections 3.2, 3.3,
and 3.4). Table 1 lists the eight modern and commonly-used
DNN models we evaluate. We target both small (e.g., CIFAR10 [4]) and large-scale (e.g., ILSVRC2012 [140]) image classification datasets. ResNet101 [59], VGG-16 [156], and DenseNet201 [63]
models are top-five winners of past ImageNet ILSVRC competitions
[84, 140]. We use Google MobileNetV2 [146] to test smaller, mobileoptimized networks that are widely used on mobile platforms, and
SqueezeNet [64] to test embedded, real-time applications. Table 1
also shows the summed sizes of all IFMs and weights of each network for processing one input, which is a good indicator of the
memory intensity of each DNN model.
Model Dataset Model Size IFM+Weight
Size
ResNet101 [59] CIFAR10 [4] 163.0MB 100.0MB
MobileNetV2 [146] CIFAR10 [4] 22.7MB 68.5MB
VGG-16 [156] ILSVRC2012 [140] 528.0MB 218.0MB
DenseNet201 [63] ILSVRC2012 [140] 76.0MB 439.0MB
SqueezeNet1.1 [64] ILSVRC2012 [140] 4.8MB 53.8MB
Alexnet [84] CIFAR10 [4] 233.0MB 208.0MB
YOLO [137] MSCOCO [104] 237.0MB 360.0MB
YOLO-Tiny [137] MSCOCO [104] 33.8MB 51.3MB
LeNet⋆ [89] CIFAR10 [4] 1.65MB 2.30MB
⋆ we use this small model in some evaluations where the experimental
setup does not support large models.
Table 1: DNN models used in our evaluations. The listed total
model size and summed IFM+weight sizes are for the FP32
variant of each model.
Table 2 shows the accuracy we obtain in our experiments for our
baseline networks across four different numeric precisions (int4,
int8, int16 and FP32), using reliable commodity DRAM. We quantize
using the popular symmetric linear DNN quantization scheme [103].
This quantization scheme applies weight-dependent affine scaling
to linearly map weights into the range [−2
b−1
, 2
b−1 − 1], where b
is the target model weight bit precision. YOLO and YOLO-Tiny’s
framework only support int8 and FP32 numeric precisions.
Our baseline accuracies match stated numbers in relevant literature [59, 63, 64, 146, 156]. Two of the models, DenseNet201 and
SqueezeNet1.1, suffer from accuracy collapse at 4-bit precision. We
did not use hyper-parameter tuning in our baselines or subsequent
experiments. All results use the default DNN architectures and
learning rates.
6.2 Accuracy Validation of the Error Models
EDEN uses errors obtained from real DRAM devices to build and select accurate error models. We profile the DRAM 1) before running
173
Model int4 int8 int16 FP32
ResNet101 [59] 89.11% 93.14% 93.11% 94.20%
MobileNetV2 [146] 51.00% 70.44% 70.46% 78.35%
VGG-16 [156] 59.05% 70.48% 70.53% 71.59%
DenseNet201 [63] 0.31% 74.60% 74.82% 76.90%
SqueezeNet1.1 [64] 8.07% 57.07% 57.39% 58.18%
Alexnet [84] 83.13% 86.04% 87.21% 89.13%
YOLO⋆ [137] – 44.60% – 55.30%
YOLO-Tiny⋆ [137] – 14.10% – 23.70%
LeNet [89] – 61.30% – 67.40%
⋆ these models use mean average precision (mAP) instead of
the accuracy metric.
Table 2: Baseline accuracies of the networks used in our evaluation with reliable DRAM memory (no bit errors) using different numeric precisions.
DNN inference, and 2) when the environmental factors that can affect the error patterns change (e.g., when temperature changes). We
find that an error model can be accurate for many days if the environmental conditions do not change significantly, as also observed
in prior work [76, 93, 94].
We derive our probabilistic error models (Section 4) from data
obtained from eight real DRAM modules. We use the same FPGA
infrastructure as the one described in Section 6.1. We find that
complete profiling of a 16-bank, 4GB DDR4 DRAM module takes
under 4 minutes in our evaluation setup. We can speed up the
profiling time by 2-5x using more sophisticated DRAM profiling
methodologies [129].
We validate our error models by comparing the DNN accuracy
obtained after injecting bit errors using our DRAM error models to
the accuracy obtained with each real approximate DRAM module.
Figure 7 shows an example of the DNN accuracy obtained using
DRAM modules from three major vendors with reduced voltage and
tRCD , and the DNN accuracy obtained using our Error Model 0. We
use Error Model 0 because it is the model that fits better the errors
observed in the three tested DRAM modules. Our main observation
is that the DNN accuracy obtained with our model is very similar to
that obtained with real approximate DRAM devices. We conclude
that our error models mimic very well the errors observed in real
approximate DRAM devices.
1.0 1.1 1.2
Voltage (V)
0.2
0.3
0.4
0.5
0.6
0.7
Accuracy
5 10
tRCD (ns)
Vendor A, SoftMC
Vendor B, SoftMC
Vendor C, SoftMC
Vendor A, Error Model 0
Vendor B, Error Model 0
Vendor C, Error Model 0
Figure 7: LeNet/CIFAR-10 accuracies obtained using real approximate DRAM devices (via SoftMC) and using our Error
Model 0. Error bars show the 95% confidence interval of Error Model 0.
6.3 Error Tolerance of Baseline DNNs
To better understand the baseline error tolerance of each DNN
(before boosting the error tolerance), we examine the error tolerance of the baseline DNNs. This also shows us how differences in
quantization, best-fit error model, and BER can potentially affect
the final DNN accuracy.
Figure 8 shows the accuracy of ResNet101 at different precision
levels and BERs using all four error models. We see that all DNNs
exhibit an accuracy drop at high BER (> 10−2
), but different error
models cause the drop-off for all DNNs to be higher or lower. This
is rooted in how each error model disperses bit errors into the DNN
IFMs and weights. A good example of this is Error Model 1, which
exhibits the most early and extreme drop-offs, especially for FP32
DNNs. We find that the cause of this is that, in our experimental
setup, IFMs and weights are aligned in DRAM, so the MSBs of
different DNN data types are mapped to the same bitline B. If the
percentage of weak cells in bitline B (PB) is high, the DNN suffers
many MSB failures. However, Error Model 0 distributes these weak
cell failures uniformly and randomly across the bank, causing far
fewer MSB failures. In general, the way in which each error model
captures the distribution of weak cells across data layout in memory
greatly affects its impact on the error curve.
0.00
0.25
0.50
0.75
1.00
Accuracy
Error Model 0 Error Model 1
10 4 10 3 10 2 10 1
BER
0.00
0.25
0.50
0.75
1.00
Accuracy
Error Model 2
10 4 10 3 10 2 10 1
BER
Error Model 3
4-bit
8-bit
16-bit
32-bit
Figure 8: ResNet101 accuracy across different BERs (x-axis)
and quantization levels when we use four error models to
inject bit errors. We fit the parameters of the error models to
the errors observed by reducing tRCD in a real DRAM device
from Vendor A.
Quantization. Precision also affects the error model and the error
tolerance curve. For example, in Error Model 2, we observe that the
int-4 DNN has the weakest error tolerance curve. We find that this
is because Error Model 2 clusters weak cells along a row: a large
number of neighboring 4-bit values end up corrupted when Error
Model 2 indicates a weak wordline. This is in contrast to larger
precisions, which might have numbers distributed more evenly
across rows, or error models that do not capture error locality (e.g.,
Error Model 0). In general, we find that clusters of erroneous values
cause significant problems with accuracy (the errors compound
faster as they interact with each other in the DNN). Such locality of
errors is more common in low-bitwidth precisions and with spatial
correlation-based error models (Error Models 1 and 2).
DNN Size. We observe that larger DNNs (e.g., VGG16) are more
error resilient. Larger models exhibit an accuracy drop-off at higher
BER (> 10−2
) as compared to smaller models (e.g. SqueezeNet1.1,
< 10−3
). These results are not plotted.
174
Accuracy Collapse. We can observe the accuracy collapse phenomenon caused by implausible values (see Section 3.2) when we
increase the bit error rate over 10−6
in large networks. These implausible values propagate, and in the end, they cause accuracy
collapse in the DNN.
6.4 Curricular Retraining Evaluation
We run DNN inference on real DRAM devices using the boosted
DNN model generated by our curricular retraining mechanism.
To our knowledge, this is the first demonstration of DNN inference on real approximate memory. We also evaluate our curricular
retraining mechanism using our error models (see Section 4).
Experimental Setup. We evaluate curricular retraining using real
DRAM devices by running LeNet [89] on the CIFAR-10 [4] validation dataset. We use SoftMC [58] to scale VDD and tRCD on an
FPGA-based infrastructure connected to a DDR3 DRAM module.
We also evaluate curricular retraining using our error models by
running ResNet [59] on the CIFAR-10 validation dataset.
Results with Real DRAM. Figure 9 shows the accuracy of 1) baseline LeNet without applying any retraining mechanism (Baseline),
and 2) LeNeT boosted with our curricular retraining mechanism
(Boosted), as a function of DRAM supply voltage and tRCD . We
make two observations. First, EDEN’s boosted LeNet allows a voltage reduction of ∼0.25V and a tRCD reduction of 4.5ns, while maintaining accuracy values equivalent to those provided by nominal
voltage (1.35V) and nominal tRCD (12.5ns). Second, the accuracy of
baseline LeNet decreases very quickly when reducing voltage and
tRCD below the nominal values. We conclude that our curricular
retraining mechanism can effectively boost the accuracy of LeNeT
on approximate DRAM with reduced voltage and tRCD .
1.05 1.20 1.35
Voltage (V)
0.2
0.4
0.6
0.8
Accuracy
Baseline Boosted
2.5 5.0 7.5 10.0 12.5
tRCD (ns)
Figure 9: LeNet accuracy using baseline and boosted DNNs.
Results with Error Models. Figure 10 (left) shows an experiment
that retrains ResNet101 with two different models: 1) a good-fit error
model (that closely matches the tested device) and 2) a poor-fit error
model. We make two observations. First, retraining using a poor-fit
error model (red), yields little improvement over the baseline (no
retraining, green). Second, retraining with a good-fit error model
(blue) improves BER at the 89% accuracy point by >10x (shifting the
BER curve right). We conclude that using a good-fit error model in
the retraining mechanism is critical to avoid accuracy collapse.
Figure 10 (right) shows the effectiveness of our curricular retraining mechanism using a good-fit error model. We make two
observations. First, the accuracy of the DNN with regular retraining
(purple) collapses, compared to the baseline DNN (no retraining,
green). Second, the DNN trained with our curricular retraining
(orange) exhibits a boosted error tolerance. We conclude that our
curricular retraining mechanism is effective at boosting the DNN
accuracy in systems that use approximate DRAM.
Running this retraining process for 10-15 epochs is sufficient to
boost tolerable BERs by 5-10x to achieve the same DNN accuracy
10 4 10 3 10 2 10 1
0.0
0.2
0.4
0.6
0.8
1.0
Bit Error Rate
Accuracy
Poor-Fit Error Model
Good-Fit Error Model
Baseline
10 4 10 3 10 2 10 1
Non-Curricular Retraining
Curricular Retraining
Baseline
Figure 10: Accuracy of boosted ResNet101 DNNs in presence
of memory errors. Left: accuracy of poor-fit and good-fit error models. Right: accuracy of non-curricular and curricular
retraining using a good-fit error model.
as the baseline DNN executed in DRAM with nominal parameters.
For our ResNet101 on CIFAR-10 with an NVIDIA Tesla P100, this
one-time boosting completes within 10 minutes.
6.5 Coarse-Grained DNN Characterization
and Mapping
In this section, we show the results of EDEN’s coarse-grained DNN
characterization (see Section 3.3) and how the target DNN model
maps to an approximate DRAM with optimized parameters for a
target accuracy degradation of < 1%.
Characterization. Table 3 shows the DNN’s maximum tolerable
BER for eight DNN models with FP32 and int8 numeric precisions.
FP32 int8
Model BER ∆VDD ∆tRCD BER ∆VDD ∆tRCD
ResNet101 4.0% -0.30V -5.5ns 4.0% -0.30V -5.5ns
MobileNetV2 1.0% -0.25V -1.0ns 0.5% -0.10V -1.0ns
VGG-16 5.0% -0.35V -6.0ns 5.0% -0.35V -6.0ns
DenseNet201 1.5% -0.25V -2.0ns 1.5% -0.25V -2.0ns
SqueezeNet1.1 0.5% -0.10V -1.0ns 0.5% -0.10V -1.0ns
AlexNet 3.0% -0.30V -4.5ns 3.0% -0.30V -4.5ns
YOLO 5.0% -0.35V -6.0ns 4.0% -0.30V -5.5ns
YOLO-Tiny 3.5% -0.30V -5.0ns 3.0% -0.30V -4.5ns
Table 3: Maximum tolerable BER for each DNN using
EDEN’s coarse-grained characterization, and DRAM parameter reduction to achieve the maximum tolerable BER. Nominal parameters are VDD = 1.35V and tRCD = 12.5ns.
We observe that the maximum tolerable BER demonstrates significant variation depending on the DNN model. For example, YOLO
tolerates 5% BER and SqueezeNet tolerates only 0.5%. We conclude
that 1) the maximum tolerable BER highly depends on the DNN
model, and 2) DNN characterization is required to optimize approximate DRAM parameters for each DNN model.
Mapping. EDEN maps each DNN model to an approximate DRAM
module that operates with the maximum reduction in voltage
(∆VDD ) and tRCD (∆tRCD ) that leads to a BER below the maximum DNN tolerable BER for that DNN model. Table 3 shows the
maximum reduction in DRAM voltage (∆VDD ) and tRCD (∆tRCD )
that causes a DRAM BER below the maximum tolerable BER, for a
target DRAM module from vendor A. The nominal DRAM parameters for this DRAM module are VDD = 1.35V and tRCD = 12.5ns .
We make two observations. First, the tolerable BER of a network
175
is directly related to the maximum tolerable VDD and tRCD reductions. Second, the reductions in VDD and tRCD are very significant
compared to the nominal values. For example, EDEN can reduce
voltage by 26% and tRCD by 48% in YOLO while maintaining the
DNN accuracy to be within 1% of the original accuracy.
6.6 Fine-Grained DNN Characterization
and Mapping
Characterization. We characterize the ResNet101 DNN model
with our fine-grained DNN characterization procedure (see Section 3.3). For each IFM and weight, we iteratively increase the bit
error rate until we reach the maximum tolerable BER of the data
type for a particular target accuracy degradation. We perform a
full network retraining in each iteration. To reduce the runtime of
our procedure , we sample 10% of the validation set during each
inference run to obtain the accuracy estimate. We also bootstrap
the BERs to the BER found in coarse-grained DNN characterization and use a linear scale in 0.5 increments around that value. For
ResNet101, this one-time characterization completes in one hour
using an Intel Xeon CPU E3-1225 [1].
Figure 11 shows the maximum tolerable BER for each IFM and
weight in ResNet101 obtained with our fine-grained DNN characterization method (Section 3.3), assuming a maximum accuracy loss
of <1%. Each bar in the figure represents the BER tolerance of an
IFM or weight, and they are ordered by their depth in the DNN,
going deeper from left to right. We make three observations. First,
fine-grained characterization enables individual IFMs and weights
to tolerate up to 3x BER (13% for the last weight) of the maximum
tolerable BER of the coarse-grained approach (4% for ResNet101 in
Table 3). Second, weights usually tolerate more errors than IFMs.
Third, the maximum tolerable BER is smaller in the first layers than
in the middle layers of the DNN. We conclude that fine-grained
DNN characterization enables a significant increase in the maximum tolerable BER compared to coarse-grained characterization.
Weights and IFMs
2%
4%
6%
8%
10%
12%
BER
IFMs Weights
Figure 11: Fine-grained characterization of the tolerable
BERs of ResNet101 IFMs and weights. Deeper layers are on
the right.
Mapping. We map each individual IFM or weight into different
DRAM partitions based on 1) the BER tolerance of each IFM and
weight, and 2) the BER of each DRAM partition, using our algorithm in Section 3.4. Figure 12 shows an example that maps the
ResNet101 IFMs and weights from Figure 11 into 4 different DRAM
partitions with different voltage parameters that introduce different BERs (four horizontal colored bars), following the algorithm in
Section 3.4.
We conclude that the wide range of tolerable BERs across all
ResNet101 data types enables the use of both 1) DRAM partitions
with significant voltage reduction (e.g., horizontal red line), and 2)
DRAM partitions with moderate voltage reduction (e.g., horizontal
blue line).
7 SYSTEM LEVEL EVALUATION
We evaluate EDEN in three different DNN inference architectures:
CPUs, GPUs, and inference accelerators.
Weights and IFMs
2%
4%
6%
8%
10%
12%
BER
IFMs Weights
Figure 12: Mapping of ResNet101 IFMs and weights into
four partitions with different VDD values (colored horizontal lines)
7.1 CPU Inference
Experimental Setup. We evaluate EDEN on top of a multi-core
OoO CPU using the simulated core configuration listed in Table
4. We use ZSim [145] and Ramulator [81] to simulate the core and
the DRAM subsystem, respectively. We use DRAMPower [16] to
estimate energy consumption for DDR4 devices. We use a 2-channel,
32-bank 8GB DDR4-2133 DRAM device.
Cores 2 Cores @ 4.0 GHz, 32nm, 4-wide OoO,
Buffers: 18-entry fetch, 128-entry decode,
128-entry reorder buffer,
L1 Caches 32KB, 8-way, 2-cycle, Split Data/Instr.
L2 Caches 512KB per core, 8-way, 4-cycle, Shared Data/Instr.,
Stream Prefetcher
L3 Caches 8MB per core, 16-way, 6-cycle, Shared Data/Instr.,
Stream Prefetcher
Main Memory 8GB DDR4-2133 DRAM, 2 channels, 16 banks/channel
Table 4: Simulated system configuration.
We use twelve different inference benchmarks: eight from the Intel OpenVINO toolkit [83] and four from the AlexeyAB-fork of the
DarkNet framework [136]. For each DNN, we study the FP32 and
the int8-quantized variant. We use 8-bit quantization in our baselines, because it is commonly used for production CPU workloads
[66]. We evaluate EDEN’s coarse-grained DNN characterization
procedure and target a < 1% accuracy degradation. Table 3 lists the
reduced VDD and tRCD values.
DRAM Energy. Figure 13 shows the DRAM energy savings of
EDEN, compared to a system with DRAM operating at nominal
voltage and nominal latency. We make two observations. First,
EDEN achieves significant DRAM energy savings across different
DNN models. The average DRAM energy savings is 21% across all
workloads, and 29% each for YOLO and VGG. Second, the DRAM
energy savings for FP32 and int8 are roughly the same, because the
voltage reduction is very similar for both precisions (see Table 3).
FP32 int8 FP32 int8 FP32 int8 FP32 int8 FP32 int8 FP32 int8 FP32 int8
0%
10%
20%
30%
DRAM Energy
Reduction
YOLO-T YOLO ResNet VGG SqueezeNetDenseNet Gmean
Figure 13: DRAM energy savings of EDEN. We use FP32 and
quantized int8 networks.
We also perform evaluations for a target accuracy that is the same
as the original. Our results show that EDEN enables an average
DRAM energy reduction of 16% (up to 18%).
We conclude that EDEN is effective at saving DNN inference
energy by reducing voltage while maintaining the DNN accuracy
within 1% of the original.
176
Performance. Figure 14 shows the speedup of EDEN when we
reduce tRCD , and the speedup of a system with a DRAM module
that has ideal tRCD = 0, compared to a system that uses DRAM
with nominal timing parameters. We make three observations. First,
YOLO DNNs exhibit high speedup with EDEN, reaching up to 17%
speedup. The results of YOLO are better than the average because
YOLO is more sensitive to DRAM latency. This is because some
steps in YOLO (e.g., Non-Maximum Suppression [61, 119], confidence and IoU thresholding [137, 138]) perform arbitrary indexing
into matrices that lead to random memory accesses, which cannot
easily be predicted by the prefetchers . Second, the average speedup
of EDEN (8%) is very close to the average speedup of the ideal
system with tRCD = 0 (10%). Third, we find that SqueezeNet1.1
and ResNet101 exhibit very little maximum theoretical speedup
because they are not bottlenecked by memory latency.
FP32 int8 FP32 int8 FP32 int8 FP32 int8 FP32 int8 FP32 int8 FP32 int8
0.95
1.00
1.05
1.10
1.15
1.20
Speedup
YOLO-T YOLO ResNet VGG SqueezeNet DenseNet Gmean
EDEN tRCD = 0
Figure 14: Speedup of EDEN over baseline and versus a system with ideal activation latency. We use FP32 and an quantized int8 networks.
We also perform evaluations for a target accuracy that is the same
as the original. Our results show that EDEN enables an average
performance gain of 4% (up to 7%).
We conclude that EDEN is effective at improving DNN inference
performance by reducing DRAM latency while maintaining the
DNN accuracy within 1% of the original, especially on DNNs that
are sensitive to memory latency.
7.2 Accelerators
We evaluate EDEN on three different accelerators: GPU [124], Eyeriss [26], and TPU [69].
GPU Inference. We evaluate EDEN on a GPU using the cycleaccurate GPGPU-Sim simulator [11]. We use GPUWattch [95] to
evaluate the overall GPU energy consumption. Table 5 details the
NVIDIA Titan X GPU model [2] we use in our evaluation. We use
the reduced tRCD and VDD values that provide < 1% accuracy
degradation (as listed in Table 3). We adapt four DarkNet-based
binaries to run inference on the FP32/int8 YOLO and YOLO-Tiny
DNNs.
Shader Core 28 SMs, 1417 MHz, 32 SIMT Width,
64 Warps per SM, 4 GTO Schedulers per Core
Private L1 Cache 24 KB per SMM, Cache Block Size 128B
Shared Memory 96 KB, 32 Banks. Shared L2 Cache: 3MB
Main Memory GDDR5, 2500MHz, 6 channels, 24 chips
Table 5: Simulated NVIDIA Titan X GPU configuration
Our results show that EDEN provides 37% average energy reduction (41.7% for YOLO-Tiny, and 32.6% for YOLO) compared to a
GPU that uses DRAM with nominal parameters.
Our results also show that EDEN provides 2.7% average speedup
(5.5% for the YOLO-Tiny, and 0% for YOLO) compared to a GPU
that uses DRAM with nominal parameters. DRAM with ideal tRCD
(tRCD = 0) provides 6% speedup for YOLO-Tiny and 2% speedup for
YOLO. These results indicate that 1) the YOLO DNN family is not
DRAM latency bound in our evaluation configuration, and 2) EDEN
can achieve close to the ideal speedup of zero activation latency
when the DNN is latency bound.
Neural Network Inference Accelerators. We evaluate EDEN on
Eyeriss [26] and Google’s Tensor Processing Unit (TPU) [69] using
the cycle-accurate SCALE-Sim simulator [144]. We use DRAMPower [16] to obtain DRAM energy consumption from memory
traces produced by SCALE-Sim. We use the built-in int8 AlexNet
and YOLO-Tiny models and their accelerator-specific dataflows. We
use DRAM parameters that yield a maximum accuracy loss of 1%
(Table 3). Table 6 details the configuration of the Eyeriss and TPU
inference accelerators. Eyeriss has an array of 12x14 processing
elements (PEs) with a 324KB SRAM buffer for all data types (i.e.,
IFMs, weights and OFMs), and the TPU has an array of 256x256
PEs with a 24MB SRAM buffer for all data types. We evaluate both
accelerators with DDR4 and LPDDR3 DRAM configurations, using
Alexnet and YOLO-Tiny workloads.
Eyeriss TPU
Array 12 × 14 PEs 256 × 256 PEs
SRAM Buffers 324 KB 24 MB
Main Memory 4GB DDR4-2400 4GB DDR4-2400
4GB LPDDR3-1600 4GB LPDDR3-1600
Table 6: Simulated Eyeriss and TPU configurations.
Our results show that reducing the voltage level in DDR4 DRAM
leads to significant DRAM energy reductions on both Eyeriss and
TPU accelerators. EDEN provides 1) 31% average DRAM energy
savings on Eyeriss (31% for YOLO-Tiny, and 32% for Alexnet), and
2) 32% average DRAM energy savings on TPU (31% for YOLO-Tiny,
and 34% for Alexnet).
Our results with a reduced voltage level in LPDDR3 are similar
to those with DDR4. EDEN provides an average DRAM energy
reduction of 21% for both Eyeriss and TPU accelerators running
YOLO-Tiny and Alexnet. By using the accelerator/network/cache/-
DRAM energy breakdown provided by the Eyeriss evaluations on
AlexNet [161], we estimate that EDEN can provide 26.8% systemlevel energy reduction on fully-connected layers and 7% systemlevel energy reduction on convolutional layers.
Our results with reduced tRCD in LPDDR3 and DDR4 show
that Eyeriss and TPU exhibit no speedup from reducing tRCD . We
observe that prefetchers are very effective in these architectures
because the memory access patterns in the evaluated DNNs are
very predictable.
8 RELATED WORK
To our knowledge, this paper is the first to propose a general framework that reduces energy consumption and increases performance
of DNN inference by using approximate DRAM with reduced voltage and latency. EDEN introduces a new methodology to improve
DNN’s tolerance to approximate DRAM errors which is based on
DNN error tolerance characterization and a new curricular retraining mechanism. We demonstrate the effectiveness of EDEN by using
error patterns that occur in real approximate DRAM devices.
In this section, we discuss closely related work on 1) approximate
computing hardware for DNN workloads, and 2) modifying DRAM
parameters.
Approximate Computing Hardware for DNN Workloads.
Many prior works propose to use approximate computing hardware
for executing machine learning workloads [30, 38, 97, 110, 118, 131,
132, 134, 141, 143, 155, 163, 166, 169, 173, 174, 179, 180]. All these
177
works propose techniques for improving DNN tolerance for different types of approximate hardware mechanisms and error injection
rates. Compared to these works, EDEN is unique in 1) being the
first work to use approximate DRAM with reduced voltage and
latency, 2) being the first demonstration of DNN inference using
error characterization of real approximate DRAM devices, 3) using
a novel curricular retraining mechanism that is able to customize
the DNN for tolerating high error rates injected by the target approximate DRAM, and 4) mapping each DNN data type to a DRAM
partition based on the error tolerance of the DNN data type and
the bit error rate of the DRAM partition. We classify related works
on approximate hardware for DNN workloads into six categories.
First, works that reduce DRAM refresh to save DNN energy [121,
122, 164]. RANA [164] and St-DRC [121] propose to reduce DRAM
refresh rate in the embedded DRAM (eDRAM) memory of DNN
accelerators. Nguyen et al. [122] propose to apply similar refresh optimization techniques to off-chip DRAM in DNN accelerators. These
mechanisms use customized retraining mechanisms to improve the
accuracy of the DNN in the presence of a moderate amount of
errors.
Second, works that study the error tolerance of neural networks
to uniform random faults in SRAM memory [97, 118, 134, 142, 143].
For example, Li et al. [97] analyze the effect of various numeric
representations on error tolerance. Minerva [135] proposes an
algorithm-aware fault mitigation technique to mitigate the effects
of low-voltage SRAM in DNN accelerators.
Third, works that study approximate arithmetic logic in DNN
workloads [141, 141, 178, 179]. ThUnderVolt [178] proposes to underscale the voltage of arithmetic elements. Salami et al. [141] and
Zhang et al. [179] present fault-mitigation techniques for neural
networks that minimize errors in faulty registers and logic blocks
with pruning and retraining.
Fourth, works that study approximate emerging memory technologies for neural network acceleration. Panda et al. [125] and
Kim [80] propose neuromorphic accelerators that use spintronics
and memristors to run a proof-of-concept fuzzy neural network.
Fifth, works that study the effects of approximate storage devices
on DNN workloads [132, 155]. Qin et al. [132] study the error tolerance of neural networks that are stored in approximate non-volatile
memory (NVM) media. The authors study the effects of turning the
ECC off in parts of the NVM media that store the neural network
data. Wen et al. [155] propose to mitigate the effects of unreliable
disk reads with a specialized ECC variant that aims to mitigate
error patterns present in weights of shallow neural networks.
Sixth, works that study the intrinsic error resilience of DNNs by
injecting randomly-distributed errors in DNN data [110, 110, 141,
163, 166, 179, 180]. These works assume that the errors can come
from any component of the system (i.e., they do not target a specific
approximate hardware component). Marques et al. [110] study the
accuracy of DNNs under different error injection rates and propose
various error mitigation techniques. This work uses a simple probabilistic method to artificially inject errors into the DNN model.
ApproxANN [180] uses an algorithm that optimizes the DNN accuracy by taking into account the error tolerance and the criticality of
each component of the network. The quality-configurable Neuromorphic Processing Engine (qcNPE) [166] uses processing elements
with dynamically configurable accuracy for executing approximate
neural networks.
Modifying DRAM Parameters. Many prior works study the effects of modifying DRAM parameters on reliability, performance
and energy consumption. We already discuss some prior works
that reduce DRAM voltage, access latency, and refresh rate in Section 2.3. EDEN leverages the characterization techniques introduced
in Voltron [21] and Flexible-Latency DRAM [19] to perform the
DRAM characterization required to map a DNN to approximate
DRAM with reduced voltage and reduced latency (Section 3.4). We
classify other related works that modify DRAM parameters into
three categories.
First, works that aim to characterize and reduce energy consumption at reduced supply voltage levels [21, 36, 39, 47]. David et
al. [36] propose memory dynamic voltage and frequency scaling
(DVFS) to reduce DRAM power. MemScale [39] provides dynamic
voltage and/or frequency scaling in main memory to reduce energy
consumption, while meeting a maximum tolerable performance
degradation. Voltron [21] studies voltage reduction in real DRAM
devices in detail and proposes solutions to reduce voltage reliably
based on observed error characteristics and system performance
requirements. VAMPIRE [47] proposes a new DRAM power model
that is based on the characteristics of real DRAM devices.
Second, works that investigate DRAM characteristics under reduced access latency [15, 19, 21, 76–78, 93, 94]. Adaptive-Latency
DRAM [94] characterizes the guardbands present in timing parameters defined by DRAM manufacturers, and exploits the extra timing
margins to reliably reduce DRAM latency across different chips
and temperatures. Flexible-Latency DRAM [19] analyzes the spatial
distribution of reduced-latency-induced cell failures, and uses this
information to reliably access different regions of DRAM with different timing parameters. DIVA-DRAM [93] proposes an automatic
method for finding the lowest reliable operation latency of DRAM,
via a combination of runtime profiling and ECC.
Third, works that aim to reduce DRAM latency by modifying the
microarchitecture of DRAM or the memory controller [31, 56, 57, 91,
92, 108, 157, 168]. These works reduce latency without introducing
bit errors.
9 CONCLUSION
This paper introduces EDEN, the first general framework that enables energy-efficient and high-performance DNN inference via
approximate DRAM, while strictly meeting a target DNN accuracy.
EDEN uses an iterative mechanism that profiles the DNN and the
target approximate DRAM with reduced voltage and timing parameters. EDEN improves DNN accuracy with a novel curricular
retraining mechanism that tolerates high bit error rates. We evaluate EDEN in both simulation and on real hardware. Our evaluation
shows that EDEN enables 1) an average DRAM energy reduction
of 21%, 37%, 31%, and 32% in CPU, GPU, Eyeriss, and TPU architectures, respectively, across a variety of state-of-the-art DNNs, and 2)
average (maximum) performance gains of 8% (17%) in CPUs and
2.7% (5.5%) in GPUs, for latency-bound DNNs. We expect that the
core principles of EDEN generalize well across different memory
devices, memory parameters, and memory technologies. We hope
that EDEN enables further research and development on the use of
approximate memory for machine learning workloads.