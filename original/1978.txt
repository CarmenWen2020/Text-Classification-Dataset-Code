ABSTRACT
Quantum computing is on the cusp of reality with Noisy IntermediateScale Quantum (NISQ) machines currently under development and
testing. Some of the most promising algorithms for these machines
are variational algorithms that employ classical optimization coupled with quantum hardware to evaluate the quality of each candidate solution. Recent work used GRadient Descent Pulse Engineering (GRAPE) to translate quantum programs into highly optimized
machine control pulses, resulting in a significant reduction in the
execution time of programs. This is critical, as quantum machines
can barely support the execution of short programs before failing.
However, GRAPE suffers from high compilation latency, which is
untenable in variational algorithms since compilation is interleaved
with computation. We propose two strategies for partial compilation, exploiting the structure of variational circuits to pre-compile
optimal pulses for specific blocks of gates. Our results indicate significant pulse speedups ranging from 1.5x-3x in typical benchmarks,
with only a small fraction of the compilation latency of GRAPE.
CCS CONCEPTS
• Computer systems organization → Quantum computing.
KEYWORDS
quantum computing, optimal control, variational algorithms
1 INTRODUCTION
In the Noisy Intermediate-Scale Quantum (NISQ) era, we expect
to operate hardware with hundreds or thousands of quantum bits
(qubits), acted on by imperfect gates [42]. Moreover, connectivity
in these NISQ machines will be sparse and qubits will have modest
lifetimes. Given these limitations, NISQ era machines will not be
able to execute large-scale quantum algorithms like Shor Factoring
[45] and Grover Search [20], which rely on error correction that
requires millions of qubits [38, 48].
However, recently, variational algorithms have been introduced
that are well matched to NISQ machines. This new class of algorithms has a wide range of applications such as molecular ground
state estimation [41], MAXCUT approximation [14], and prime factorization [2]. The two defining features of a variational algorithm
are that:
(1) the algorithm complies with the constraints of NISQ hardware. Thus, the circuit for a variational algorithm should
have modest requirements in qubit count (circuit width) and
runtime (circuit depth / critical path).
(2) the quantum circuit for the algorithm is parametrized by a
list of angles. These parameters are optimized by a classical
optimizer over the course of many iterations. For this reason,
variational algorithms are also termed as hybrid quantumclassical algorithms [42]. Typically, a classical optimizer that
is robust to small amounts of noise (e.g. Nelder-Mead) is
chosen [32, 41].
Standard non-variational quantum algorithms are fully specified at compile time and therefore can be fully optimized by static
compilation tools as in previous work [23, 26]. By contrast, each
iteration of a variational algorithm depends on the results of the
previous iteration–hence, compilation must be interleaved through
the computation. As even small instances of variational algorithms
will require thousands of iterations [24], the compilation latency for
each iteration therefore becomes a serious limitation. This feature
of variational algorithms is a significant departure from previous
non-variational quantum algorithms.
To cope with this limitation on compilation latency, past work
on variational algorithms has performed compilation under the
standard gate-based model. This methodology has the advantage
of extremely fast compilation–a lookup table maps each gate to
a sequence of machine-level control pulses so that compilation
simply amounts to concatenating the pulses corresponding to each
266
MICRO-52, October 12–16, 2019, Columbus, OH, USA Gokhale et al.
gate. We note that this compilation procedure is a conservative
picture of experimental approaches to gate-based compilation. In
practice, parametrized gates may be handled by a step-function
lookup table that depends on the run-time parameters, with the
aim of reducing errors, as demonstrated in [4, 34, 36].
The gate-based compilation model is known to fall short of the
GRadient Ascent Pulse Engineering (GRAPE) [17, 25] compilation
technique, which compiles directly to the level of the machinelevel control pulses that a quantum computer actually executes. In
past work [1, 27, 44], GRAPE has been used to achieve 2-5x pulse
speeedups over gate-based compilation for a range of quantum
algorithms. Since fidelity decreases exponentially in time, with
respect to the extremely short lifetimes of qubits, reducing the
pulse duration is critical to ensuring that a computation completes
before being completely scrambled by quantum decoherence effects.
Thus, 2-5x pulse speedups translate to an even bigger advantage in
the success probability of a quantum circuit.
However, GRAPE-based compilation has a substantial cost: compilation time. Running GRAPE control on a circuit with just four
qubits takes several minutes. For representative four qubit circuits,
we observed compile times ranging from 10 minutes to 1 hour, even
with state-of-the-art hardware and GPU acceleration. This would
amount to several weeks or months of total compilation latency
over the course of thousands of iterations (and millions of iterations will be needed for larger problems). By contrast, typical pulse
times for quantum circuits are on the order of microseconds, so the
compilation latency imposed by GRAPE is untenable. Thus, GRAPEbased compilation is not practical out-of-the-box for variational
algorithms.
In this paper, we introduce partial compilation, a strategy that approaches the pulse duration speedup of GRAPE, but with a manageable overhead in compilation latency. With this powerful new compiler capability, we enable the architectural choice of pulselevel instructions, which supports more complex near-term applications through lower latencies and thus much lower error rates.
This architectural choice would be infeasible without our compiler
support. Our specific contributions include:
• Demonstration of the advantage of GRAPE over gate based
compilation for variational algorithms
• Strict partial compilation, a strategy that pre-computes optimal pulses for parametrization-independent blocks of gates.
This strategy is strictly better than gate-based compilation–
it achieves a significant pulse speedup (approaching GRAPE
results), with no overhead in compilation latency.
• Flexible partial compilation, a strategy that performs as well
as full GRAPE, but with a dramatic speedup in compilation
latency via precomputed hyperparameter optimization.
The rest of this paper is organized as follows. Section 2 gives
prerequisite background on quantum computation and Section 3
describes related work from prior research. Section 4 describes characteristics of our benchmark variational algorithms, with particular
attention to the structural properties that our compilation strategies
exploit. Section 5 explains the GRAPE compilation methodology.
Sections 6 and 7 explain our partial compilation strategies and
Section 8 discusses our results. We conclude in Section 9 and propose future work in Section 10. Appendix A presents the system
Hamiltonian that we consider in GRAPE.
2 BACKGROUND ON QUANTUM
COMPUTATION
2.1 Qubits
The fundamental unit of quantum computation is a quantum bit, or
qubit. A qubit has two basis states, which are represented by state
vectors denoted
|0⟩ =

1
0

and |1⟩ =

0
1

.
Unlike a classical bit, the state of a qubit can be in a superposition
of both |0⟩ and |1⟩. In particular, the space of valid qubit states
are α |0⟩ + β |1⟩, normalized such that |α |
2 + |β |
2 = 1. When a
qubit is measured, its quantum state collapses and either |0⟩ or |1⟩
is measured, with probabilities |α |
2
and |β |
2
respectively.
A two-qubit system has four basis states:
|00⟩ =
©
­
­
­
«
1
0
0
0
ª
®
®
®
¬
, |01⟩ =
©
­
­
­
«
0
1
0
0
ª
®
®
®
¬
, |10⟩ =
©
­
­
­
«
0
0
1
0
ª
®
®
®
¬
, and |11⟩ =
©
­
­
­
«
0
0
0
1
ª
®
®
®
¬
and any two-qubit state can be expressed as the superposition
α |00⟩ +β |01⟩ +γ |10⟩ +δ |11⟩ (normalized so that |α | + |β |
2 + |γ |
2 +
|δ |
2 = 1). More generally, an N-qubit system has 2
N basis states.
Therefore, 2
N numbers, called amplitudes, are needed to describe
the state of a general N-qubit system. This exponential scaling gives
rise to both the difficulty of classically simulating a quantum system,
as well as the potential for quantum computers to exponentially
outperform classical computers in certain applications.
2.2 Quantum Gates
A quantum algorithm is described in terms of a quantum circuit,
which is a sequence of 1- and 2- input quantum gates. Every quantum gate is represented by a square matrix, and the action of a
gate is to left-multiply a state vector by the gate’s matrix. Because
quantum states are normalized by measurement probabilities, these
matrices must preserve l
2
-norms. This corresponding set of matrices are unitary (orthogonal) matrices. The unitary matrices for two
important single-qubit gates are:
Rx (θ) =

i cos θ
2
sin θ
2
sin θ
2
i cos θ
2

and Rz (ϕ) =

1 0
0 e
iϕ

At θ = π, the Rx (π) gate has matrix 
2.3 Gate-Based Compilation
At the lowest level of hardware, quantum computers are controlled
by analog pulses. Therefore, quantum compilation must translate
from a high level quantum algorithm down to a sequence of control
pulses. Once a quantum algorithm has been decomposed into a
quantum circuit comprising single- and two- qubit gates, gate-based
compilation simply proceeds by concatenating a sequence of pulses
corresponding to each gate. In particular, a lookup table maps from
each gate in the gate set to a sequence of control pulses that executes
that gate. Table 1 indicates the total pulse duration for each gate in
the compilation basis gate set. These pulse durations are based on
the gmon-qubit [7] quantum system described in Appendix A.
As previously noted, the {Rx (θ), Rz (ϕ), CX} gate set alone is
sufficient for universality, so in principle the H and SWAP gates
could be removed from the compilation basis gate set. However,
we include the generated pulses (using GRAPE as described below)
for these gates in our compilation set, because quantum assembly
languages typically include them in their basis set [19, 22, 33, 46,
47, 50].
The advantage of the gate-based approach is its short pulse
compilation time, as the lookup and concatenation of pulses can
be accomplished almost instantaneously. However, it prevents the
optimization of pulses from happening across the gates, because
there might exists a global pulse for the entire circuit that is shorter
and more accurate than the concatenated one. The quality of the
concatenated pulse relies heavily on an efficient gate decomposition
of the quantum algorithm.
2.4 GRAPE
GRadient Pulse Engineering (GRAPE) is a strategy for compilation
that numerically finds the best control pulses needed to execute a
quantum circuit or subcircuit by following a gradient descent procedure [10, 25]. We use the Tensorflow implementation of GRAPE
described in [27]. In contrast to the gate based approach, GRAPE
does not have the limitation incurred by the gate decomposition.
Instead, it directly searches for the optimal control pulse for the
input circuit as a whole. Our full GRAPE procedure is described
further detail in Section 5.
3 RELATED WORK
Past publications of variational algorithm implementations have
relied on gate-based compilation, using parametrized gates such
as Rx (θ) and Rz (ϕ). Existing quantum languages offer support for
such parametrized gates [19, 22, 33, 46, 47, 53]. In most languages,
the angles must be declared at compile time–thus at every iteration of a variational algorithm, a new circuit is compiled based
on the new parametrization. Rigetti’s Quil [46] language goes a
step further by supporting runtime resolution of the parameters
in parameters gates, which allows dynamic implementations of
variational algorithms. However, as acknowledged in the Quil specifications, this approach hampers circuit optimization, because the
actual parameters are not known until runtime.
While this paper treats gate-based compilation as a simple lookup
table between gates and pulses, experimental implementations have
already moved directionally towards GRAPE-style, because pulse
sequences can depend on the input angles in a complicated fashion.
For example, in [4], a parametrized U (ϕ) gate has five different
pulse sequence decompositions, each corresponding to ϕ in ranges
set by the breakpoints [−π, 2.25, −0.25, 0.25, 2.25, π]. [36] and [34]
have similar step-function gate-to-pulse translation.
The growing overhead of compilation latency has been recognized, and recent work has proposed the development of specialized
FPGAs for the compilation of variational algorithms [35]. More
broadly, we note that pulse level control is at the cusp of industry
adoption. An open specification for pulse-level control, OpenPulse,
was standardized recently [33], and IBM plans to introduce an API
for pulse level control in 2019 [21]. Pulse access to quantum machines will open the door to experimental realizations of GRAPE,
including for variational algorithms as proposed in this paper.
4 VARIATIONAL BENCHMARKS
Variational quantum algorithms are important in the near-term
because they comply with the constraints of NISQ hardware. In
268
MICRO-52, October 12–16, 2019, Columbus, OH, USA Gokhale et al.
Variational Algorithm
Quantum Classical
Quantum
hardware
Classical
hardware
“Parameterized circuit” “Gradient descent”
New trial parameters
Partial compilation
Pulse optimization
Input parameters: "⃗
Evaluate: E["⃗]
Output ("⃗, E()*["⃗]) after 
sufficient iterations.
Next guess: "′
("⃗, E "⃗ )
Search for E-./
Figure 1: Illustration of a variational quantum algorithm
that alternates between a quantum circuit and a classical optimizer. In this process, the quantum circuit (parameterized
by ®θ) evaluates some cost function E[
®θ], and the classical optimizer gradient descends for the next set of parameters.
particular, variational algorithms have innate error resilience, due
to the hybrid alternation with a noise-robust classical optimizer
[32, 41]. Every iteration of a variational algorithm is parameterized
by a list of angles. In general, the parameter space explored by a
variational algorithm is not known a priori–the classical optimizer
picks the next iteration’s parameters based on the results of the
previous iterations. Consequently, the compilation for each iteration is interleaved with the actual computation. A schematic of this
process is illustrated in Figure 1.
There are two variational quantum algorithms: Variational Quantum Eigensolver and Quantum Approximate Optimization Algorithm. We discuss both below.
4.1 Variational Quantum Eigensolver
The Variational Quantum Eigensolver (VQE) is used to find the
ground state energy of a molecule, a task that is exponentially
difficult in general for a classical computer, but is believed to be
efficiently solvable by a quantum computer [31]. Estimating the
molecular ground state has important applications to chemistry
such as determining reaction rates [13] and molecular geometry
[40]. A conventional quantum algorithm for solving this problem is
called the Quantum Phase Estimation (QPE) algorithm [28]. However, for a target precision ϵ, QPE requires a quantum circuit with
depth O(1/ϵ), whereas VQE algorithm requires O(1/ϵ
2
) iterations
of depth-O(1) circuits[52]. The latter assumes a much more relaxed
fidelity requirement on the qubits and gate operations, because the
higher the circuit depth, the more likely the circuit experiences
an error at the end. At a high level, VQE can be conceptualized
as a guess-check-repeat algorithm. The check stage involves the
preparation of a quantum state corresponding to the guess. This
preparation stage is done in polynomial time on a quantum computer, but would incur exponential cost (owing to the 2
N state
Molecule Width (# of Qubits) # of Params Gate-Based Runtime
H2 2 3 35 ns
LiH 4 8 872 ns
BeH2 6 26 5308 ns
NaH 8 24 5490 ns
H2O 10 92 33842 ns
Table 2: Benchmarked circuits for VQE, using the UCCSD
ansatz. Each circuit was optimized, parallel-scheduled,
mapped using IBM Qiskit’s tools, augmented by an additional optimization pass we wrote to merge consecutive rotation gates. The Gate-Based Runtime is indexed to the pulse
durations for each gate reported in Table 1.
vector scaling) in general on a classical computer. This contrast
gives rise to a potential quantum speedup for VQE.
The quantum circuit corresponding to the guess is termed an
ansatz. While many ansatz choices are possible, Unitary Coupled
Cluster Single-Double (UCCSD), an ansatz motivated by principles
of quantum chemistry, is considered the gold standard [6, 43]. The
UCCSD ansatz is also promising because it could circumvent the
barren plateaus issue that affects many other ansatzes [31].
We benchmark the UCCSD ansatz for five molecules: H2, LiH,
BeH2, NaH, H2O. These molecules span the state of the art for
experimental implementations of VQE: H2O is the largest molecule
addressed by VQE [36] to date. We generated our UCCSD ansatz
circuits using the IBM Qiskit implementation described in [5] as
well as the PySCF Python package [49] to manage molecular data.
Both the the circuit depth and number of ansatz parameters in
UCCSD scale as O(N
4
) in the circuit width [3]. Table 2 specifies
the exact circuit width, number of variational parameters, and gatebased runtime (circuit depth) for each of the benchmarks. The
reported gate-based runtimes are indexed to the pulse durations of
each gate reported in Table 1. Each circuit was optimized using IBM
Qiskit’s circuit optimizer pass system, Qiskit’s circuit mapper (to
conform to nearest neighbor connectivity), and a custom compiler
pass to merge neighboring rotation gates on the same axis. We
also exploit parallelism to simultaneously schedule as many gates
as posisble; the reported gate-based runtimes are for the critical
path through the parallelized circuit. These circuit optimizations
form a fair baseline for the best circuit runtimes achievable by gate
based compilation. Our full circuit optimization code, along with
the results of optimization applied to our benchmarks, is available
on our Github repository [18].
4.2 QAOA
Quantum Approximate Optimization Algorithm (QAOA) is an algorithm for generating approximate solutions to problems that are
hard to solve exactly. At an intuitive level, QAOA can be understood as an alternating pattern of Mixing and Cost-Optimization
steps. At each Mixing step, QAOA applies diffusion so that every
possible state is explored in quantum superposition. At each CostOptimization step, a bias is applied to boost the magnitudes of quantum states that minimize a cost function. Thereafter, measuring
269
Partial Compilation of Variational Algorithms for Noisy Intermediate-Scale Quantum Machines MICRO-52, October 12–16, 2019, Columbus, OH, USA
can yield an approximate solution close to optimal with high probability. The number of alternating Mixing and Cost-Optimization
rounds is known as p. Even for small p, QAOA has competitive
results against classical approximation algorithms. For example,
at p = 1, QAOA applied to the NP-hard MAXCUT problem yields
a cut of size at least 69% of the optimal cut size [14]. At p = 5,
simulations have demonstrated that QAOA achieves mean parity
with the best-known classical algorithm, Goemans-Williamson, for
10 node graphs [9]. For larger p, QAOA is expected to outperform
classical approximation algorithms even for worst-case bounds, although theoretical guarantees have not been established yet. QAOA
is of particular interest in the near term because recent work has
shown that it is computationally universal [29]. Moreover, QAOA
has shown experimental resilience to noise [39]. For these reasons,
QAOA is a leading candidate for quantum supremacy [15], the solution of a classically-infeasible problem using a quantum computer.
Similarly to VQE, QAOA is a guess-check-repeat algorithm. In
the case of QAOA, the guesses correspond to “Mixing magnitude
during iteration 1 ≤ i ≤ p" and “Cost-Optimization magnitude
during iteration 1 ≤ i ≤ p". Hence, the number of parameters in a
QAOA circuit is 2p: one scalar for Mixing magnitude and one for
Cost-Optimization magnitude, for each of the p rounds.
We benchmark QAOA for N = 6 and 8 node graphs, with the
number of QAOA rounds p spanning from 1 to 8. For each (N,p) pair,
we benchmark for two types of random graphs: 3-regular (each node
is connected to three neighbors) and Erdos-Renyi (each possible
edge is included with 50% probability). This yields 2 × 8 × 2 = 32
benchmarks circuits for QAOA. The gate-based runtimes for each
of these benchmarks are reported in Table 3. As with the VQE
benchmarks, the runtimes are computed after circuit mapping and
optimizations, to form a fair baseline.
5 GRAPE COMPILATION
In this section, we describe GRAPE (GRadient Ascent Pulse Engineering), a compilation technique that aims to produce the optimal
possible sequence of analog control pulses needed to realize the
unitary matrix transformation for a targeted quantum circuit. At an
abstract level, GRAPE simply treats the underlying quantum computer as a black box. The black box accepts time-discretized control
pulses as input and outputs the unitary matrix of the transformation
that is realized by the input control pulses. GRAPE performs gradient descent over the space of possible control pulses to search for
the optimal sequence of input signals that achieve the targeted unitary matrix up to a specified fidelity. We used the Tensorflow-based
implementation of GRAPE described in [27], which has demonstrated good performance. The gradients are computed analytically
and backpropogated with automatic differentiation.
In this paper, we define the optimal sequence of control pulse as
the one of shortest duration–thus, we seek to speed up the pulse
time with respect to gate-based compilation. Reducing the pulse
time is important in quantum computation because qubits have
short lifetimes due to quantum decoherence effects. The decoherence error increases exponential with time, so the effect of a pulse
time speedup enters the power of an exponential term. We focus
on this error metric because it is one of the dominant error terms
for superconducting qubits and it is well understood. However, in
N = 6 N = 8
3-Regular Erdos-Renyi 3-Regular Erdos-Renyi
p = 1 113 ns 84 ns 163 ns 157 ns
p = 2 199 ns 151 ns 365 ns 297 ns
p = 3 277 ns 223 ns 530 ns 443 ns
p = 4 356 ns 296 ns 695 ns 596 ns
p = 5 434 ns 368 ns 860 ns 750 ns
p = 6 512 ns 440 ns 1025 ns 903 ns
p = 7 590 ns 512 ns 1191 ns 1056 ns
p = 8 668 ns 584 ns 1356 ns 1209 ns
Table 3: Gate-based runtimes for our 32 benchmark QAOA
MAXCUT circuits. Our benchmarks consider two types of
random graphs: 3-Regular and Erdos-Renyi. We consider
both 6 and 8 node graphs–the number of qubits in the circuit is the same as the number of nodes in the graph. We
benchmarked over p, the number of repetitions of the basic
QAOA block, ranging from 1 to 8, which represents a range
of p that is of both theoretical and practical interest [9]. As in
Table 2, the gate-based runtimes are based on the gate times
in Table 1, after each circuit has been optimized, parallelscheduled, and mapped.
principle, GRAPE can be used to control other sources of error such
as gate errors, State Preparation and Measurement (SPAM) errors,
and qubit crosstalk, as demonstrated in past work [1, 8, 12].
5.1 Speedup Sources
Because GRAPE translates directly from a unitary matrix to hardwarelevel control pulses–without the overhead of an intermediate set
of quantum gates–it achieves more optimized control pulses than
gate-based compilation does. In particular, we observed significant
pulse speedups from GRAPE due to the following factors:
• ISA alignment. Gate based compilation incurs a significant overhead because the set of basis gates will not be
directly implementable on a target machine. For example,
while quantum circuits are typically compiled down to CX
(CNOT) gates as the default two-qubit instructions, actual
quantum computers implement a wide range of native twoqubit operations such as the MS gate or the iSWAP gate.
Compiling gates to pulses incurs a significant overhead from
this ISA misalignment.
• Fractional gates. A unique feature of quantum computing is that all operations can be fractionally performed–for
example, CX1/2
is a valid quantum gate, as is CXp more
generally for any power. Often, a fractional application of a
basis gate is sufficient to execute a larger quantum operation.
The fixed basis set of gate based compilation misses these
optimizations, whereas GRAPE works in a continuous basis
and realizes fractional gates when beneficial.
• Control Field Asymmetries. While gate based compilation puts Rx and Rz gates on an equal footing, at a physical
level, there is often a significant asymmetry between the
270
MICRO-52, October 12–16, 2019, Columbus, OH, USA Gokhale et al.
speed and reliability of these operations. As described in
A, we model a representative quantum system in which Zaxis qubit rotations are 15 times faster than X-axis qubit
rotations. GRAPE’s search for the shortest pulse realization
will therefore leverage this asymmetry, preferring Z rotations when possible. For example, the H gate is typically
implemented by the Rx (
−π
2
)Rz (
−π
2
)Rx (
−π
2
) pulse sequence,
which involves two X-axis rotations and one Z-axis rotation. We observe that our GRAPE system instead discovers the equivalent Rz (
−π
2
)Rx (
−π
2
)Rz (
−π
2
) pulse sequence,
which only requires one X-axis rotation and therefore executes significantly faster.
• Maximal circuit optimization. Although quantum circuits
can be optimized at the gate-level by repeatedly applying a
set of circuit identity templates, the set of templates must be
finite. Opportunities for optimization between distant gates
(both in width and depth) may be overlooked. By contrast,
GRAPE subsumes all circuit optimizations by working directly in terms of the unitary matrix of the circuit, as opposed
to the gate decomposition.
5.2 Circuit Blocking for GRAPE
While GRAPE can achieve significant pulse speedups, it is limited
by two factors:
• The unitary matrix of the targeted quantum circuit must be
specified as input to the GRAPE program. An N-qubit circuit
has a 2
N × 2
N matrix (due to the exponential state space of
an N-qubit space), which imposes a bound on the maximum
circuit size that GRAPE can handle.
• The total convergence time for GRAPE’s gradient descent
scales exponentially in the size of the target quantum circuit
[27]. For example, it typically takes our GRAPE implementation several minutes to find the pulses for a 4 qubit QAOA
MAXCUT circuit. Experientially, we also found difficulty
consistently finding convergence for deep quantum circuits
with N > 5 qubits.
For this reason, it is necessary to partition large quantum circuits
into blocks of manageable width. We blocked into subcircuits of
up to 4 qubits, using the aggregation methodology discussed in
[44]. Specifically, we select maximal subcircuits of 4 qubit width,
such that partitioning the subcircuit does not delay the execution
of subcircuits. This methodology ensures that full GRAPE is strictly
better than gate based compilation–otherwise, subcircuits may
induce serialization that underperforms gate based compilation.
Details are discussed in Section 4.3 of [44].
5.3 Binary Search for Minimum Pulse Time
In prior work [27, 44], the pulse length is specified as a static ‘upper
bound’ parameter, total_time. Pulse speedups are then performed
by adding a term to the cost function that rewards pulses that realize the targeted unitary matrix in time shorter than total_time.
However, to comply with the automatic differentiation methodology for analytically computing gradients, this cost function term is
continuous and rewards gradual progress of the pulse towards the
target unitary matrix. By contrast, our ultimate goal is to find the
binary cutoff point specifying the minimal possible time needed
Figure 2: Pulse lengths from gate based compilation and full
GRAPE for MAXCUT on the 4-node clique. While the gate
based pulse times are simply linear in the number of QAOA
rounds p, the GRAPE based times asymptote to an upper
bound. For each p, a random parametrization was set. The
ratio varies from 2.0x at p = 1 to 12.0x at p = 6.
to achieve a pulse. Moreover, setting the relative weighting of the
speedup term to the fidelity term in the cost function is difficult.
Poor choices of weights can either prevent GRAPE from achieving
any speedup or realizing the target fidelity.
As proposed by the prior work [27], our methodology adaptively changes the total_time by binary searching for the shortest
total_time needed to achieve a target unitary matrix. While this
incurs the overhead of running on the more iterations 1
, it is worthwhile because minimizing the pulse time is exponentially critical
in terms of reducing errors.
5.4 GRAPE Compilation for QAOA
There are a range of theoretical results setting upper bounds on
the circuit complexity needed to achieve a particular quantum
operation. For example, it is known that 3 CX gates, sandwiched
by single-qubit rotations, is sufficient to implement any two qubit
operation. These results were recently generalized to the context
of quantum optimal control (a generalization of GRAPE) with a
proof that any N-qubit operation can be achieved in O(4
N ) time
via optimal control [30].
This implies that GRAPE can achieve a significant advantage
over gate-based compilation in algorithms like QAOA that have
p repeated blocks. While the pulse length from gate-based compilation scales linearly in the p, the GRAPE based pulse length is
upper bounded by the maximum time it takes to implement any
transformation for an N-qubit circuit. Figure 2 demonstrates this
behavior for QAOA MAXCUT on the 4-node clique problem. While
the pulse length from gate based compilation scales linearly in the
number of QAOA rounds p, it asymptotes below 50 ns for GRAPE
based pulse lengths. Thus, the pulse speedup advantage of GRAPE
increases with p.
1
Specifically, on the order of loд(M/∆t) iterations where M is the upper bound on
total_time and ∆t is the desired precision, which we set to 0.3 ns.
271
Partial Compilation of Variational Algorithms for Noisy Intermediate-Scale Quantum Machines MICRO-52, October 12–16, 2019, Columbus, OH, USA
As our QAOA benchmarks have circuit widths of 6 and 8 qubits–
larger than the 4 qubit blocks we feed to GRAPE–the number of
serial blocks will scale linearly with p. Therefore, we don’t expect
to see an unboundedly growing speedup of GRAPE with increasing
p, but we still expect to see gains within each 4 qubit block.
6 STRICT PARTIAL COMPILATION
While full quantum optimal control generates the fastest possible
pulse sequence for a target circuit, its compilation latency on the
order of several minutes is untenable for variational algorithms,
in which compilation is interleaved with computation. In order to
approach the pulse speedup of GRAPE without incurring the full
cost in compilation latency, it is necessary to exploit the structure of
the variational circuits. We term this structural analysis as partial
compilation, and it is executed as pre-computation step prior to
executing the variational algorithm on a quantum computer.
Our first strategy, Strict Partial Compilation, stems from the
observation that for typical circuits in variational algorithms, most
of the gates are independent of the parametrization. For example,
Figure 3a shows an example variational circuit. While the circuit
has many gates, only four of them depend on the variational θi
parameters. All of the other gates can be blocked into maximal
parametrization-independent subcircuits. Figure 3b demonstrates
the application of strict partial compilation to the variational circuit
from Figure 3a. The sequence of resulting subcircuits is [Fixed,
Rz (θ1), Fixed, Rz (θ1), Fixed, Rz (θ2), Fixed, Rz (θ3)], which exhibits
strict alternation between ‘Fixed’ subcircuits that don’t depend on
any θi and Rz (θi) gates that do depend on the parametrization.
After the strict partial compilation blocking is performed, we
use full GRAPE to pre-compute the shortest pulse sequence needed
to execute each Fixed subcircuit. These static precompiled pulse
sequences can be defined as microinstructions in a low-level assembly such as eQASM [16]. Thereafter, at runtime, the pulse sequence
for any parametrization can be generated by simply concatenating
the pre-computed pulse sequences for Fixed blocks with the control
pulses for each parametrization-dependent Rz (θi) gate. Thus, strict
partial compilation retains the extremely fast (essentially instant)
compilation time of standard gate based compilation. However,
since each Fixed block was compiled by GRAPE, the resulting pulse
duration is shorter than if the Fixed blocks had been compiled by
gate based compilation. Thus, strict partial compilation achieves
pulse speedups over gate-based compilation, with no increase in
compilation latency.
Full discussion of the results is deferred to Section 8. A priori,
we note that the performance of strict partial compilation is tied
to the depth of the Fixed subcircuits. For deeper Fixed subcircuits,
GRAPE has more opportunities for optimization and can achieve a
greater advantage over gate-based compilation. From inspection of
Figure 3a, we see that the depth of Fixed blocks is determined by
the frequency of Rz (θi) gates. For our benchmarked VQE-UCCSD
circuits, Rz (θi) gates comprise only 5-8% of the total number of
gates, so the Fixed subcircuits have reasonably long depths. For our
benchmarked QAOA circuits however, the Rz (θi) gates comprise 15-
28% of the total number of gates, so the Fixed subcircuits have short
depths and the potential advantage of strict partial compilation is
limited. This motivates us to consider other strategies that more
closely match the pulse speedups of full GRAPE.
7 FLEXIBLE PARTIAL COMPILATION
As strict partial compilation is bottlenecked by the depth of Fixed
subcircuits, we are motivated to consider strategies that create
deeper subcircuits. The core idea behind flexible partial compilation
is to create subcircuits that are only ‘slightly’ parametrized, in that
they depend on at most one of the θi variational parameters. As
discussed below, we can perform hyperparameter tuning to ensure
that GRAPE finds optimized pulses for single-angle parametrized
subcircuits much faster than for general subcircuits.
7.1 Parameter Monotonicity
An initial strategy for creating these single-angle parametrized
subcircuits would be to merge each consecutive pair of Fixed and
Rz (θi) subcircuits into a single subcircuit that only depends on
θi
. However, this strategy would add at most one gate of depth to
each subcircuit, which would not lead to significantly better pulses.
However, we make a key observation which we term parameter
monotonicity. For both the VQE UCCSD and QAOA circuits, the
appearances of θi-dependent gates is monotonic in i–once a θi
dependent gate appears, the subsequent parametrization-dependent
gates must be θj for j ≥ i. As a result, subcircuits with the same
value of θi must be consecutive. For example, the sequence of angles
in parametrization-dependent gates could be [θ1, θ1, θ2, θ3] as in
Figure 3a, but not [θ1, θ2, θ3, θ1].
At a high level, parameter monotonicity for VQE/UCCSD and
QAOA arise because their circuit constructions sequentially apply a
circuit corresponding to each parameter exactly once. For instance,
in QAOA, each parameter corresponds to the magnitude of Mixing
or Cost-Optimization during the ith round–once the corresponding
Mixing or Cost-Optimization has been applied, the circuit no longer
depends on that parameter. Parameter monotonicity is not immediately obvious from visual inspection of variational circuits, because
the circuit constructions and optimizations transform individual
θi-dependent gates to ones that are parametrized in terms −θi or
θi /2. We resolve these latent dependencies by explicitly tagging
the dependent parameter in software during the variational circuit
construction phase.
The implication of parameter monotonicity is that the subcircuits considered by flexible partial compilation are significantly
deeper than the ones considered by strict partial compilation. Figure 3c demonstrates a small example; note that the θ1-dependent
subcircuit indicated by red dashed lines is significantly deeper than
the subcircuits generated by strict partial compilation.
7.2 Hyperparameter Optimization
In GRAPE, an optimal control pulse is one that minimizes a set
of cost functions corresponding to control amplitude, target state
infidelity, and evolution time, among others[27]. To obtain an optimal control pulse, the GRAPE algorithm manipulates a set of
time-discrete control fields that act on a quantum system. It may
analytically compute gradients of the cost functions to be minimized with respect to the control fields. These gradients are used to
update control fields with an optimizer such as ADAM or L-BFGS-B.
272
MICRO-52, October 12–16, 2019, Columbus, OH, USA Gokhale et al.
(a) This is a representative variational circuit, decomposed into gates. In gate-based compilation,
each gate is translated by a lookup table to analog control pulses. Compilation amounts to simple
concatenation of these control pulses. GRAPE (denoted by the dashed line) considers the unitary
matrix for the full circuit and performs gradient descent to find the shortest control pulses that
realize the circuit. GRAPE achieves significant pulse speedups, but has substantial compilation latency.
(b) Strict partial compilation blocks the circuit into a strictly alternating sequence of Fixed
(parametrization-independent) subcircuits and Rz (θi ) gates. Each Fixed subcircuit is precompiled
with GRAPE, so that compilation at runtime simply involves concatenating the pulses for each
subcircuit.
(c) Flexible partial compilation blocks the circuit into subcircuits that depend on exactly one parameter, θi
. Parameter monotonicity ensures that these subcircuits have significantly longer depth
than the Fixed blocks of strict partial compilation. We use hyperparameter optimization to precompute good hyperparameters (learning rate and decay rate) for each subcircuit. When all θi are
specified at runtime, we used the tuned hyperparameters to quickly find optimized pulses for each
subcircuit.
Figure 3: Comparison of compilation strategies. Subfigure (a) depicts gate-based and GRAPE- based compilation for a variational circuit. These two compilation approaches represent opposite ends of a spectrum trading off between between compilation latency and control pulse speedup. We introduce two new compilation strategies, strict and flexible partial compilation,
that approach the pulse speedup of GRAPE without the large compilation latency. Subfigures (b) and (c) demonstrates strict
and flexible partial compilation respectively.
273
Partial Compilation of Variational Algorithms for Noisy Intermediate-Scale Quantum Machines MICRO-52, October 12–16, 2019, Columbus, OH, USA
Figure 4: The 0th single-angle dependent subcircuit of the
UCCSD LiH circuit has two angle dependent gates, the 7th
has eight. These four qubit circuits are representative of
the circuits studied in this work as well as larger future circuits due to the necessity of circuit blocking for circuits with
more than four qubits. The graphs above plot GRAPE error
against ADAM learning rate. For each permutation of the argument of the angle dependent gates in the subcircuits, the
same range of learning rate values achieves the lowest error.
As opposed to the control fields, which are parameters manipulated
by GRAPE, these optimizers have their own parameters such as
learning rate and learning rate decay. These parameters are termed
hyperparameters because they are set before the learning process
begins.
Because they are inputs to the learning process, there is no closed
form expression relating hyperparameters and the cost functions
a learning model is minimizing. This makes hyperparameter optimization an ideal candidate for derivative free optimization techniques. Recent work has shown that tuning hyperparameters with
methods such as bayesian optimization and radial basis functions
can significantly improve performance for stochastic and expensive
objectives such as minimizing the training error of neural networks
[11, 51]. In our work, we employ hyperparameter optimization on
GRAPE’s ADAM optimizer. We realize faster convergence to a desired error rate over the baseline, significantly reducing compilation
latency.
In particular, we make the observation that a high-performing
hyperparameter configuration for a single-angle parameterized
subcircuit is robust to changes in the argument of its θi-dependent
gates, as shown in Figure 4. Therefore, we are able to precompute
high-performing hyperparameter configurations for each singleangle parameterized subcircuit and employ them in compilation.
For each iteration of a variational algorithm, the argument of the
θi-dependent gates of each subcircuit will change, but the same
hyperparameters are specified to GRAPE’s optimizer, maintaining
the same reduced compilation latency.
5.3μs 5.5μs 33.8μs
BeH  (6 Qubits) NaH (8 Qubits) H O (10 Qubits)
Gate
Strict
Flexible
GRAPE
0.0
0.5
1.0
1.5
2.0
Pulse Speedup Factor
Figure 5: Pulse speedup factors (relative to gate based compilation) for VQE circuits. Full QOC 1.5-2x reductions in pulse
durations for these circuits. Strict and flexible partial compilation recover 95% and 99% of this speedup respectively.
Detailed results are reported in Table 4.
8 RESULTS
Our results were collected using over 200,000 CPU-core hours on
Intel Xeon E5-2680 processors, using up to 64 GB of memory per
GRAPE process. The large volume of compute is a result of both
the high cost of running GRAPE and the number and large circuit
size of benchmarks. We fixed randomization seeds when appropriate for both reproducability and consistency between identical
benchmarks. Our results are available in Jupyter notebooks on our
Github repository [18].
8.1 Pulse Speedups
Figure 5 shows the pulse times speedup factors across our QAOA
benchmarks for partial compilation and for full GRAPE, normalized
to the gate-based compilation baseline. We present the normalized
speedup factors, because the H2O VQE-UCCSD benchmark is 10x
larger; the raw pulse times are presented in Table 4.
For the BeH2 and NaH VQE-UCCSD benchmarks, full GRAPE
gives a 2.15x and 2.00x speedup in pulse duration respectively. Strict
partial compilation is able to recover almost this full advantage, with
speedups at 2.04x and 1.93x respectively. As discussed in Section 6,
this matches the expectations, because the VQE-UCCSD benchmarks have relatively deep Fixed subcircuits. Finally, the speedups
for flexible partial compilation are 2.12x and 1.98x, which nearly
closes the gap between strict partial compilation and GRAPE.
The H2O benchmark has similar relative speedups between strict,
flexible, and GRAPE, with factors of 1.37, 1.44, 1.44.2 However, the
advantage over gate based compilation is smaller than for the BeH2
and NaH benchmarks.
Figure 6 shows results for QAOA benchmarks. Strict partial
compilation has speedups of 1.22x and 1.33x across the N = 6
2
In fact, the pulse speedup for flexible partial compilation exactly matches GRAPE,
because each 4-qubit block handled by GRAPE depends on at most one parameter.
274
MICRO-52, October 12–16, 2019, Columbus, OH, USA Gokhale et al.
●
●
●
●
●
●
●
●
■
■
■
■
■
■ ■
■
◆ ◆
◆
◆
◆
◆ ◆
◆
▲ ▲ ▲ ▲
▲ ▲ ▲
▲
1 2 3 4 5 6 7 8 p
100
200
300
400
500
600
700
Pulse Length (ns)
3-Regular N=6
●
●
●
●
●
●
●
●
■
■
■
■
■
■
◆ ◆
◆
◆
◆
◆
◆
▲ ▲
▲
▲
▲
▲ ▲
▲
1 2 3 4 5 6 7 8 p
100
200
300
400
500
600
Pulse Length (ns)
Erdos-Renyi N=6
●
●
●
●
●
●
●
●
■
■
■
■
■
■
■
◆
◆
◆
◆
◆
◆
◆
◆
▲
▲
▲
▲
▲
▲
▲
▲
1 2 3 4 5 6 7 8 p
200
400
600
800
1000
1200
1400
Pulse Length (ns)
3-Regular N=8
●
●
●
●
●
●
●
●
■
■
■
■
■
◆
◆
◆ ◆
◆
◆
▲
▲
▲
▲
▲ ▲
1 2 3 4 5 6 7 8 p
200
400
600
800
1000
1200
Pulse Length (ns)
Erdos-Renyi N=8
Figure 6: Pulse durations for QAOA MAXCUT benchmarks under the four compilation techniques, across all benchmarks. The
gate based pulse time always increases linearly in p, the number of repeated rounds in the QAOA circuit. The average GRAPE
pulse speedup is 2.6x for 6-node graphs and 1.8x for 8-node graphs. Strict partial compilation only achieves a modest speedup
over gate based compilation, but flexible partial compilation essentially matches the GRAPE speedup exactly. The omitted
data points correspond to computations that did not complete in 12 CPU-core hours, even after parallelizing subcircuit jobs.
Max-Cut
Compilation UCCSD 3-Regular, N=6 Erdos-Renyi, N=6 3-Regular, N=8 Erdos-Renyi, N=8
Techniques H2 LiH BeH2 NaH H2O p=1 p=5 p=1 p=5 p=1 p=5 p=1 p=5
Gate-based 35.3 871.1 5308.3 5490.4 33842.2 113.2 433.6 83.7 367.8 162.5 860.0 157.1 749.5
Strict Partial 15.0 307.0 2596.5 2842.7 24781.4 91.2 397.6 54.0 291.8 134.0 711.6 100.0 551.7
Flexible Partial 5.0 84.0 2503.8 2770.8 23546.7 72.0 206.2 26.4 150.0 112.0 498.9 80.5 434.8
Full GRAPE 3.1 19.3 2461.7 2752.0 23546.7 72.0 179.0 26.6 141.2 112.0 498.9 81.6 513.7
Table 4: Experimental results for pulse durations (in nanoseconds) across the VQE-UCCSD and QAOA benchmarks.
and N = 8 qubit benchmarks respectively. By contrast, flexible
partial compilation has average speedups of 2.3x and 1.8x across
the N = 6 and N = 8 benchmarks, which almost matches the results
from GRAPE. This separation between strict and flexible partial
compilation matches the expected results discussed in Section 6.
The high frequency of parametrized gates in QAOA limits the depth
of Fixed blocks, so strict blocking has limited mileage. However,
due to the four-qubit maximum subcircuit size for GRAPE, each
block will rarely depend on more than one θi parameter. On these
single-angle dependent blocks, flexible partial compilation achieves
the same pulse speedups as GRAPE.
8.2 Compilation Latency Reduction
Figure 7 shows the compilation latency reduction achieved by flexible partial compilation, relative to full GRAPE compilation. As
described in Section 7.2, flexible partial compilation is able to dramatically speed up the gradient descent’s convergence by tuning the
learning rate and decay rate hyperparameters on a per-subcircuit
basis. We note that the 3-regular graphs achieve particularly high
compilation latency reduction factors of 80.3x and 81.9x. Across
all benchmarks, the reduction in compile time is from hours to
minutes, which is critical in the context of variational algorithms.
275
Partial Compilation of Variational Algorithms for Noisy Intermediate-Scale Quantum Machines MICRO-52, October 12–16, 2019, Columbus, OH, USA
17 163 s
305 s
12 387 s
1057 s
19 065 s
1261 s
12 786 s
159 s
23 718 s
289 s
11 645 s
263 s
19 356 s
1258 s
BeH  NaH H O 3Reg N=6 3Reg N=8 Erdos N=6 Erdos N=8
0
20
40
60
80
Compilation Latency Reduction
Figure 7: Reduction factors in compilation latency. The ratios indicate the average compilation latency using flexible
partial compilation divided by latency using full GRAPE
compilation. Flexible partial compilation uses about an
hour of pre-compute time to determine the best learning
rate - decay rate pair for each subcircuit.
8.3 Simulation with Realistic Pulses
While we performed our GRAPE runs without accounting for error
or noise sources for simplicity, it can be adapted to account for these
sources. For example, we could demand well-shaped pulses, account
for leakage into higher states outside the binary qubit abstraction,
or explicitly model the qubit decoherence times. To demonstrate
that these sources can be accounted for, we re-ran two of our VQE
and QAOA benchmarks with Full GRAPE using these more realistic
assumptions:
• Allowing only 1 pulse datapoint every nanosecond (1 GSa/s),
versus 20 GSa/s in the other results presented in this paper.
• Including leakage into the qutrit leakage level. Other results
in this paper use the binary-qubit approximation, as outlined
in the system Hamiltonian in Appendix A.
• Application of aggressive pulse regularization in GRAPE to
ensure that the pulse shapes follow a Gaussian envelope and
have smooth 1st and 2nd derivatives.
Table 4 compares the pulse speedups due to GRAPE, under both
our standard (less realistic) GRAPE settings and under the more
realistic settings that account for the three items above. For VQE
and QAOA applications, the GRAPE speedups speedups are 11.4x
(standard) vs 8.8x (realistic) and 4.5x (standard) vs. 3.0x (realistic)
respectively. While the more realistic pulses do seem to have somewhat lower pulse speedup factors, they are similar and still feature
significant speedup over gate based compilation.
8.4 Aggregate Impact on Total Runtime
For a quantitative sense of aggregate impact, we note that VQE
requires thousands of iterations, even for small molecules. For instance, past work in VQE, towards estimating the ground state
energy of BeH2, required 3500 iterations [24]. Per Figure 7, this
would amount to over 2 years of runtime compilation latency via
Full-GRAPE. By contrast, strict partial compilation achieves zero
runtime compilation latency via lookup table, and the pre-computed
pulses for the fixed blocks were compiled in under 1 hour. Since
the UCCSD ansatz has quartic scaling in the number of parameters
Gate ns → GRAPE ns (reduction) H2 VQE Erdos-Renyi N = 3
Standard 35.3 → 3.1 (11.4x) 15.0 → 3.3 (4.5x)
More Realistic 420 → 48 (8.8x) 285 → 96 (3.0x)
Table 5: Speedups due to GRAPE compilation under the standard settings and under more realistic settings, which account for lower sampling rates, qutrit leakage, and pulse regularization. Results are given for the H2 VQE benchmark
and for the Erdos-Renyi N = 3 QAOA benchmark. The
speedup factors due to GRAPE are similar with and without
the more realistic assumptions.
[43], the number of iterations required scales aggressively for bigger
molecules and the advantage of our approach will scale favorably.
Further experimental work is needed to estimate the advantage of
our approach for larger molecules in terms of total runtime, but
extrapolation from small molecules BeH2 seems promising. Similarly, while the improvement in quality-of-result due to the shorter
pulse times from GRAPE is difficult to quantify without concrete
experiments, we emphasize that the error due to decoherence scales
exponentially with quantum runtime. Therefore, we again expect
favorable results, owing to the significant pulse time speedup of
our techniques relative to gate based compilation.
9 CONCLUSION
Variational quantum algorithms such as VQE and QAOA are strong
candidates for demonstrating a quantum advantage in problems
such as molecular ground state estimation, MAXCUT approximation, and prime factorization. Unlike prior algorithms, variational
algorithms are parametrized, with the parameters at each iteration determined based on the results of previous iterations. Consequently, compilation is interleaved with computation. As a result,
it is not practical to each variational circuit with out-of-the-box
GRAPE, which takes several minutes to find an optimized pulse
even on small (4-qubit) circuit.
Our partial compilation techniques offer a path to achieving the
pulse speedups of GRAPE, without incurring its compilation latency.
On the VQE-UCCSD circuits, our strict partial compilation strategy
achieves 1.5x-2x pulse speedups over gate based compilation, almost
matching the speedups from full GRAPE. Strict partial compilation
is performed by precomputing optimal pulses for Fixed blocks.
During execution, it has the same–essentially instant–lookup table
based compilation procedure as gate based compilation. Thus, strict
partial compilation is strictly better than gate based compilation.
For QAOA circuits, while strict partial compilation only achieves
modest pulse speedup, we find that flexible partial compilation
almost exactly matches the pulse speedups of GRAPE. Flexible partial compilation precomputes the best hyperparameters for each
slice, so that when the θi parameters are specified at runtime, an
optimized pulse sequence can be computed rapidly. For our benchmarked circuits, we found 10-100x reductions in compilation latency
from flexible partial compilation, relative to full GRAPE compilation.
We emphasize that achieving optimized pulses is critical because
error due to decoherence error is exponential in the pulse duration.
276
MICRO-52, October 12–16, 2019, Columbus, OH, USA Gokhale et al.
Thus, our pulse speedups are not merely about wall time speedups
for quantum circuits, but moreso about making computations possible in the first place, before the qubits decohere.
10 FUTURE WORK
The industry adoption of the OpenPulse standard will usher an
experimental era for pulse-level control. Running our partial compilation schemes on an actual machine will be valuable in terms of determining exactly how to weigh tradeoffs between pre-computation
resources, compilation latency, and pulse durations.
On the computational side, we also see significant potential for
extending the scalability of GRAPE. While past work has successfully used GRAPE on 10 qubit widths with very simple circuits (for
example, 10 identical single-qubit rotations in parallel), we found
that for complicated circuits, GRAPE only converges reliabily with
widths up to 4 qubits. This 4-qubit blocking width limits the depths
of the subcircuits that both GRAPE and our partial compilation
schemes can consider. For example, in the additional two VQEUCCSD molecules benchmarks (H2 and LiH) reported in Table 4,
flexible partial compilation and full GRAPE achieve 7-50x pulse
speedups because the benchmarks are 2 and 4 qubits in width. Thus,
investigating the convergence properties of GRAPE and extending
the circuit widths it reliably converges for will substantially extend
the advantage that these techniques can achieve over gate based
compilation