While computer-aided design is a major part of many modern manufacturing pipelines, the design files typically generated describe raw geometry.
Lost in this representation is the procedure by which these designs were
generated. In this paper, we present a method for reverse-engineering the
process by which 3D models may have been generated, in the language of
constructive solid geometry (CSG). Observing that CSG is a formal grammar,
we formulate this inverse CSG problem as a program synthesis problem. Our
solution is an algorithm that couples geometric processing with state-ofthe-art program synthesis techniques. In this scheme, geometric processing
is used to convert the mixed discrete and continuous domain of CSG trees
to a pure discrete domain where modern program synthesizers excel. We
demonstrate the efficiency and scalability of our algorithm on several different examples, including those with over 100 primitive parts. We show
that our algorithm is able to find simple programs which are close to the
ground truth, and demonstrate our method’s applicability in mesh re-editing.
Finally, we compare our method to prior state-of-the-art. We demonstrate
that our algorithm dominates previous methods in terms of resulting CSG
compactness and runtime, and can handle far more complex input meshes
than any previous method.
CCS Concepts: • Computing methodologies → Mesh geometry models; Parametric curve and surface models;
Additional Key Words and Phrases: Procedural Modeling, CSG, CAD
1 INTRODUCTION
Computer-aided design (CAD) software has become a key part
of many modern mass-manufacturing pipelines over the last few
decades. CAD tools are parametric by design, allowing designers
to create easily modifiable shapes. This enables engineers to iterate
over the design parameters to improve the performance of objects or
to adapt existing designs so that they can be reused in new scenarios.
For this reason, there has been a growing interest in using parametric
CAD representations for fabrication-oriented design exploration
and optimization algorithms [Schulz et al. 2017; Shugrina et al. 2015].
ACM Transactions on Graphics, Vol. 37, No. 6, Article 213. Publication date: November 2018.
213:2 • Du, T. et al
Unfortunately, CAD procedures are rarely readily available with
released models. The constructive parametric representations are
internal to CAD systems, which typically only allow for exporting
a design as a 3D mesh or a boundary representation (B-Rep). As a
result, there is a vast quantity of important legacy models whose
original procedural definitions have been lost in the years since
their creation. In addition, many crafted objects were not originally
designed in CAD systems at all, and many more products undergo
shop floor changes that make the original CAD files inaccurate. For
such models, the only available shape representations are 3D scans
of the manufactured design that necessarily incorporate noise due
to imperfections in the scanning process.
New techniques to reverse engineer CAD models from 3D shapes,
such as Monte Carlo sampling methods and genetic algorithms, have
attracted the interest of many researchers. Central to any technique
is an expressive and concise representation. A natural choice of
parametric representation is constructive solid geometry (CSG) as it
is a well understood, widely accepted staple in modern CAD systems
and is compact in its representation. CSG encodes geometries as
trees that are constructed by recursively applying boolean operators
to primitive shapes [Requicha and Rossignac 1992]. Theory for the
automatic conversion of 3D models to CSG trees has been widely
studied for the past 20 years.
However, the current leading techniques either do not scale well
for large problems [Fayolle and Pasko 2016] or cannot produce
compact representations [Buchele and Crawford 2004]. Furthermore,
these methods assume the input shape is an exact B-Rep, as opposed
to a 3D model that can come from a low-resolution mesh or a noisy
3D scan. In this paper, we propose a new, scalable approach to
reverse engineer CAD models based on the realization that CSG is
simply a class of computer programs. This means that generating a
CSG tree can be framed as a program synthesis problem.
Program synthesis is a process by which computer programs
are generated from descriptions of their intended behavior. These
techniques seek to generate programs which not only satisfy their
specifications, but also do so as parsimoniously as possible. Program
synthesis has proven effective in a wide range of problem domains,
including synthesizing entity matching rules for databases [Singh
et al. 2017], inferring excel formulas [Gulwani et al. 2012], and experiment design in biology [Koksal et al. 2013]. Our work builds on
constraint-based synthesis, a specific class of synthesis algorithms
that works by symbolically representing a space of candidate programs and framing the search for a correct program in this space as
a constraint satisfaction problem [Solar-Lezama 2008]. Constraintbased methods can scale to large search spaces by leveraging the
capabilities of modern constraint-solvers and are easily extended to
cover different sets of shape primitives by simply including them in
the search space. This is in contrast to purely deductive methods
that start from a naive valid solution and apply deductive rules to
improve the program’s quality (typically measured by its length).
These methods can have a hard time finding optimal solutions without the help of carefully crafted rules tailored to each primitive.
There are three main challenges in applying constraint-based
program synthesis techniques to the task of reverse engineering
CAD models. First, the most scalable constraint-based synthesis
systems work by reducing problems to boolean satisfiability (SAT),
a purely discrete problem. This is a good fit for discovering the
boolean structure of the CSG model, but CAD models also involve
continuous parameters (e.g. the positions and extents of primitive
shapes). Second, the correctness of the program to be synthesized
is naturally defined as a geometric constraint, since the 3D shape
described by the synthesized CSG program must occupy the same
volume in space as the volume contained inside the input mesh.
However, this requirement is too complex to be used as a basis
for program synthesis, so we need to translate this high-level requirement into a set of constraints on the program behavior that
the synthesizer can use to efficiently prune the space of possible
programs. Third, noisy inputs (e.g. a mesh generated from a scan)
generate inconsistencies in the specification with respect to our limited primitive shapes, which could lead to contradicting constraints
that cannot be satisfied.
In this paper, we address these challenges to provide a complete
and scalable pipeline for generating a compact CSG tree from noisy
data that can be approximated at various levels. We address the issue
of a mixed continuous and discrete search problem together with
the issue of noise by breaking the search into two steps: First, we use
robust primitive detection methods based on RANSAC and graphcut to infer the location and orientation of the primitive shapes,
which resolves the continuous search problem in the presence of
noisy inputs. After the location and orientation of the primitives
are fixed, the remaining search problem is purely discrete, which
we solve using Sketch, a state of the art program synthesis tool
based on SAT solving [Solar-Lezama 2008]. To generate constraints
suitable for program synthesis, we take advantage of canonical
intersection terms [Shapiro and Vossler 1991]. We conduct extensive
experiments with a CAD library composed of 50 models. The dataset,
CAD files, and source code are openly available with this paper.
In this work, we contribute the following:
• A formulation that decouples the continuous aspects of the
inverse CSG problem from the combinatorial ones, allowing
us to leverage mature program synthesis techniques.
• Implementation of a complete pipeline that generates CSG
trees from noisy inputs at varied approximation levels.
• Empirical evidence that our method can synthesize CSG programs for several complex models, demonstrating the efficiency, scalability, and robustness of our algorithm and its
immediate application to mesh re-editing.
2 RELATED WORK
Our work draws ideas from previous work on modeling with parametric CAD, inverse procedural modeling, reverse engineering CAD,
program synthesis, and primitive detection.
Modeling with Parametric CAD. Parametric CAD systems allow
designers to define a geometry as the execution of a list of procedures that depend on a set of parameter values [Farin et al. 2002].
This parametric representation defines and constrains the ways the
shape can be modified, allowing it to preserve the structure and
other meaningful characteristics, such as manufacturing considerations. Koyama et al. [2015] use CAD to parametrize the space of
manufacturable connectors. Similarly, Shugrina et al. [2015] and
ACM Transactions on Graphics, Vol. 37, No. 6, Article 213. Publication date: November 2018.
InverseCSG: Automatic Conversion of 3D Models to CSG Trees • 213:3
Schulz et al. [2017] use parametric CAD models for fabricationoriented design optimization. These recent works argue that the
advantage of directly using CAD models over algorithms for automatic parametrization of an input 3D mesh [Bokeloh et al. 2012;
Jacobson et al. 2011; Zheng et al. 2011] include: (1) greater and more
meaningful geometric variations (as opposed to some dimensions)
and (2) automatic exposure of relational constraints that can be used
to understand function and support multiple fabrication methods.
In these works, however, the parametric models are taken as an
input and assumed to be carefully specified by expert engineers.
There has been some recent work on extracting editable 3D structures or revealing constraints from input that does not contain CAD
structure. Chen et al. [2013] allow geometric re-editing from images.
Similarly, Xu et al. [2016] propose an interactive method for extracting functional information of mechanisms from multi-view images.
In both of these techniques, however, detailed user sketches are used
to extract information on the shape components and their relations.
In this work, we propose a method for automatically generating a
CSG tree from a shape without any additional user assistance. This
approach identifies the full structure and provides a plausible means
by which the geometry could have been instantiated.
Inverse Procedural Modeling. The problem of recovering the list of
geometry procedures that reconstruct a 3D shape is a special case of
inverse procedural modeling. Over the years, two primary strategies
have been developed for tackling this domain. Recognition-based
strategies attempt to discover certain attributes of the underlying
shape, such as classified geometry or segmentations [Fish et al. 2014;
Kim et al. 2013; Litman et al. 2014; Tulsiani et al. 2017; Valentin et al.
2015; Xie et al. 2014; Zhu et al. 2017] in order to estimate the input’s structure. These techniques are typically based off machine
learning techniques or geometrically principled rules. While fast,
they provide limited insight of a shape’s underlying structure and
can be difficult to debug. On the other hand, search-based strategies
attempt to fully explain the input shape by sampling-based methods [Chaudhuri et al. 2011; Fan and Wonka 2016; Hämäläinen et al.
2014; Kalogerakis et al. 2012; Khungurn et al. 2015; Nishida et al.
2016; Ritchie et al. 2015; Schwarz and Wonka 2014; Talton et al. 2011;
Wu et al. 2014] or direct search algorithms [Duncan et al. 2016; Fu
et al. 2015; Lau et al. 2011; Peng et al. 2016; Shao et al. 2016]. Since
search must be applied to each input geometry, these methods are
typically slower; however, the fact that they return the geometry’s
underlying structure typically makes them more informative and
robust. Our approach borrows techniques from both: we semantically segment our input geometry using recognition and then rely
on program synthesis methods which take a direct-search approach
for solving constraints.
Reverse Engineering CAD. Reverse engineering a CAD model is
a classic research problem in the CAD community. The input to
this problem is typically a shape represented as a surface mesh or a
point cloud, and the output is a solid 3D model that can be used in
CAD software for further operations. Central to this problem is the
step that converts a boundary representation (B-rep) of a mesh into
a CSG model. [Shapiro and Vossler 1991] first proposed a method
to solve the general problem of converting a b-rep into CSG models
using halfspaces, and lots of improvements have been proposed in
later work [Buchele 1999; Buchele and Crawford 2004; Buchele and
Roles 2001; Shapiro and Vossler 1993]. At a high level, this line of
research attempts to solve the problem in a deductive manner: given
a set of surface patches on the mesh, the method tries to find the
correct combination of them by applying a series of rules, e.g., if a
halfplane fully encloses the input shape then the solution can be
represented as an intersection of this halfspace and everything else
left. As a result, the quality of the solution is greatly shaped by the
set of rules one can find to apply. Our method is in sharp contrast
to previous work in that we formulate a search problem that allows
a modern program synthesizer to explore a much larger space and
solve much larger-scale examples than in previous work.
Another family of approaches to reverse engineering a model
is evolutionary algorithms. Some attempts have been made to use
genetic algorithms to optimize a CSG tree such that certain constraints are satisfied [Hamza and Saitou 2004; Weiss 2009]. More
recent work [Fayolle and Pasko 2016] considered the possibility of
taking a B-rep as input to the evolutionary algorithm. The output
of their method is a CSG tree that closely approximates the surface
boundary. One bottleneck of evolutionary algorithms is their long
runtime and large consumption of computational resources. Further,
their non-deterministic nature makes it hard to control and understand their behavior throughout the optimization. By comparison,
although our method also searches a large space, the search is much
more directed; the constraint solver is able to take advantage of the
structure of the constraints to prune large sections of the space and
converge to a solution much faster.
There are two concurrent papers that attempt to solve the similar
problem but from different perspectives: the CSGNet paper [Sharma
et al. 2018] trains a neural network that takes as input a 2D or 3D
shape and outputs a CSG program. Compared to their work, our
method does not require a training dataset and we demonstrate our
algorithm on 3D shapes of much higher complexity. Wu et al. [2018]
reconstruct a CSG tree from raw point clouds by extracting the
primitives and inferring CSG tree structures. When building the
CSG tree, they divide the bounding box into voxels and label each
voxel as inside or outside the point cloud. A CSG tree is then built
in a bottom-up manner by solving an energy minimization problem
based on the labels of each voxel. Our work shares a similar pipeline
but does not require discretizing the inputs into voxels, which allows
us to handle inputs with details at various levels.
Program Synthesis. The field of program synthesis also has a
long history [Alur et al. 2013; Gulwani et al. 2017]. There have
been several approaches to program synthesis including constraintbased search [Solar-Lezama et al. 2006], enumerative search [Udupa
et al. 2013], and stochastic search [Schkufza et al. 2014]. In addition,
there are program synthesis systems that are specifically targeted to
some domains. For example, Gulwani et al. [2011] use a specialized
algorithm to learn string transformation programs very efficiently.
Deductive synthesis techniques also have a long history in the
program synthesis space, including a number of recent success
stories [Delaware et al. 2015; Püschel et al. 2004]. These techniques
generally scale well because they break the synthesis problem into
small local reasoning steps. It can, however, be difficult to engineer
ACM Transactions on Graphics, Vol. 37, No. 6, Article 213. Publication date: November 2018.
213:4 • Du, T. et al
the deductive rules and rule application heuristics to ensure the
system efficiently finds a good solution.
For inverse CAD, a constraint-based approach is better suited
because the enumerative search does not scale. This is due to the
large, high-dimensional search space; stochastic approaches have a
low probability of finding the correct program through sampling
techniques. Hence, in this paper, we use a constraint-based program
synthesis system called Sketch [Solar-Lezama 2008; Solar-Lezama
et al. 2006]. Sketch is a general purpose synthesis system in the
sense that it allows users to specify the grammar describing the space
of possible programs in a high-level language and automatically
generates the constraints for SAT solving.
Primitive Detection. Primitive detection is a well studied problem
and many solutions have been proposed [Attene et al. 2006; CohenSteiner et al. 2004; Le and Duan 2017; Li et al. 2011; Schnabel et al.
2007; Wu Leif Kobbelt 2005; Yan et al. 2012]. In particular, Li et
al. [2011] propose a primitive detection method that aims to satisfy
CAD constraints like symmetry or perpendicularity. We do not
apply their method to our problem directly because CAD models
do not always have such assumptions. Instead, we implement our
primitive detector based on the RANSAC approach [Schnabel et al.
2007] because of its efficiency and robustness.
3 OVERVIEW
In this section, we state the inverse CSG problem and present an
overview of the method. This is a simplified version of the algorithm as described in Sections 4 and 5. In Section 6, we extend
this algorithm with a segmentation procedure which allows our
method to scale to more complex geometries. Our method’s pipeline
is illustrated in Figure 2.
We test our method on a benchmark of 50 CAD models. The
dataset, CAD files, and source code are openly available with this
paper. In terms of the CAD file, We use the format defined by OpenSCAD [OpenSCAD 2018] because it is open-source and freely available. Note that the zero-volume surfaces in some of the generated
meshes are due to the numerical instabilities of OpenSCAD. These
artifacts are not an indicator of the incorrectness of the resulting
CSG tree. As a comparison, we model the same CSG trees in commercial software and get clean results (Figure 3).
3.1 Inverse CSG
Given an input surface mesh M, we wish to find a program which
generates an output geometry, such that every point in space is in
its interior if and only if it is also in the interior of M. Put more
simply, this means that the interior of M and this geometry must
occupy the same volumetric region.
In this paper, we focus on the space of CSG programs, which can
interchangeably be described as trees. The CSG grammar, as we
will describe formally in Section 4, provides a complete language
of 3D geometry, making it an expressive choice. At a high level,
the CSG grammar is comprised of discrete boolean operators and
3D geometric primitives which are described as a mix of discrete
and continuous parameters. To our knowledge, no existing search
methods can efficiently search over CSG program structure and its
discrete and continuous parameters. Thus, the key to the solution
will be reducing this mixed search problem into a purely discrete
search.
3.2 Method Overview
Our method takes a manifold surface mesh as input and performs
intelligent geometric preprocessing to transform the problem into a
compact, discrete form that existing methods in program synthesis
can solve efficiently. Below we briefly describe each step in the
pipeline (Figure 2).
Primitive Detection. First, we resolve the continuous parameters
in the search space by proposing a set of candidate primitives (Section 4.1). This discrete set covers all primitive choices and is generated from the input surface’s geometric features and geometric
reasoning. This step fixes the values of every continuous parameter
and reduces the mixed search problem into a discrete one. This step
is also robust to noise and can deal with approximations.
Sampling. Our original problem statement is intractable as a specification for the synthesis process. Luckily, as previous work [Shapiro
and Vossler 1991] pointed out, given a finite set of primitives, one
can choose a finite subset of point constraints which renders the rest
of the constraints redundant. The method thus intelligently samples
from the entire set of point constraints, keeping only those which
add information to our search (Section 4.2). This step transforms
the infinite constraint set into a finite one.
Synthesis. Since the inverse CSG problem reduces to a compact,
semantic search over a discrete language, we apply program synthesis techniques in order to efficiently solve the problem (Section 5),
feeding in the sampled points as constraints. At the end of this step,
the method is guaranteed to find a feasible CSG program whose
output matches the input mesh geometry as close as possible.
Post-processing. Finally, we further simplify the output program
using deductive rules and then re-parameterize the program for
easy end-user editing (Section 7).
4 INVERSE CSG FORMULATION
We state our problem definition as follows:
Definition 4.1. Given a mesh M, the goal is to find a simple CSG
tree such that its interior occupies the same volumetric space:
min
CSG
Complexity(CSG)
s.t. ∀p ∈ R
3
, Inside(CSG,p) ⇔ Inside(M,p)
(1)
Here Complexity is a discrete function that evaluates the complexity of the tree. In our implementation, we limit CSG as a binary
tree and define Complexity as the number of nodes in the tree. Introducing Complexity biases our search towards simpler CSG trees.
The constraints check all points and ensure that each point is inside
CSG if and only if it is also inside M.
Grammar. Before we describe how to solve the problem from
Definition 4.1, we first need to specify the search space for CSG
trees. This search space is defined by the grammar shown in Figure 4.
In this grammar, each leaf node is a solid primitive, parametrized
by variables such that its shape is completely defined in the 3D
ACM Transactions on Graphics, Vol. 37, No. 6, Article 213. Publication date: November 2018.
InverseCSG: Automatic Conversion of 3D Models to CSG Trees • 213:5
Input
(mesh)
Primitive Extraction Sampling Synthesis Post-Processing
+
+
+
+
+
-
-
-
-
-
- -
-
-
-
-
-
∪ ∖
Transformation to
Discrete Problem
Transformation to Finite
Specification
+ +
+
+
+
-
-
-
-
-
- -
-
-
-
-
-
∪ ∖
Fig. 2. An overview of our pipeline with a 2D example. As input, our method takes in a potentially noisy surface mesh. First, we extract an over-complete set
of possible primitives in the scene (left blue box). In this example, two circles are detected, as well as four hyperplanes. In the second step of preprocessing
(center-left blue box), our method attempts to add a labeled sample in each region of the scene, as sectioned by the surface primitives. Samples inside (outside)
the input geometry are represented with a blue plus (a red minus). The samples and primitives are fed into our synthesizer (center-right blue box), which
produces a correct CSG program as output. The resulting program is post-processed (right blue box); its program structure is simplified (not shown) and
its geometric parameters are re-parameterized with metaparameters, allowing it to be interactively edited. Here, the positive and negative space circles
are detected as symmetric and metaparameterized with a single radius variable. They are then edited to make the body larger and the tail thinner, while
preserving the matching curvature.
Fig. 3. Here we show one mesh result generated by our pipeline (left). Note
that the degenerated planes in red boxes are not resolved by OpenSCAD.
We model the same CSG tree in OnShape (right), and all these zero-volume
planes are successfully removed.
space. For example, if Type is a sphere, then Parameter consists of
its center and radius. For our experiments, we consider four types
of solid primitives — spheres, cylinders, cuboids, and tori — but it is
straightforward to add more primitive types. The internal nodes in
the grammar are standard boolean operators: union, intersection,
and subtraction.
The above problem definition reveals two challenges: first, the
search space of CSG programs combines both discrete (boolean
operators and primitive selections) and continuous (primitive parameterization) variables, making the optimization problem inherently challenging. Second, this problem specifies an infinite number
of constraints to satisfy, since it considers all points in 3D space.
Subsections 4.1 and 4.2 discuss our solutions to these challenges.
CSG C := L | I
Leaf L := SolidPrimitiveType (Parameter)
Internal I := Union(C1,C2) | Intersection(C1,C2) |
Subtraction(C1,C2)
Fig. 4. The CSG grammar. The leaf nodes are solid primitives with a geometric type and shape parameters. The internal nodes are boolean operators.
4.1 Detecting Primitives
We first remove the continuous variables by detecting primitives
in the mesh. However, notice that it is difficult to infer full solid
primitive parameters from the surface especially for primitives such
as cuboids. Thus, at this stage, we can only detect surface primitives
such as spherical surfaces, (infinitely large) planes, and (infinitely
long) cylindrical surfaces. Each surface primitive represents a boundary f (x) = 0, x ∈ R
3
and can be faithfully detected from the mesh
itself. We will first discuss our method to detect all surface primitives,
then describe how we can extract solid primitives from them.
4.1.1 Detecting Surface Primitives. The goal of surface primitive
detection is twofold: locally, for each facet in the mesh we want
to find a surface primitive that is as close as possible; globally, the
total number of surface primitives should be kept low to avoid
oversegmentation. Our surface primitive detector is built on top
of the efficient RANSAC method [Schnabel et al. 2007] with a few
extensions to improve its robustness and flexibility. First, we run
the efficient RANSAC algorithm multiple times and collect surface
primitives at various scales. Second, we select the set of surface
primitives by running a graph-cut algorithm on a graph G = (V, E)
defined on the surface of the mesh, where each facet is a node vi
and each pair of adjacent facets defines an edge eij . Let { f1, f2, · · · }
ACM Transactions on Graphics, Vol. 37, No. 6, Article 213. Publication date: November 2018.
213:6 • Du, T. et al
be the set of the surface primitives detected in the first step, we then
find a graph-cut in order to assign f s to each facet vi by minimizing
the following energy:
E =
Õ
vi
Eunary + α
Õ
ei j
Ebinary + β
Õ
fi
El abel (2)
The unary energy for each facet is defined as
Eunary (vi
, f ) =
∫
x∈vi
|Dist(x, f )|dx (3)
where f is the surface primitive assigned to vi
. The binary energy
on each edge is
Ebinary (eij , fi
, fj) =
(
0, if fi = fj
1, otherwise
(4)
where fi and fj are the surface primitives assigned to vi and vj
. The
label energy is defined as
El abel(f ) =
(
0, if f is not assigned to any node
1, otherwise
(5)
The label energy can be thought of as a sparsifier on the set of
output primitives, preferring assignments where fewer primitives
are needed. This term is useful because our multiple invocations of
RANSAC can detect a large number of potential surface primitives;
the label energy term helps prune unnecessary primitives.
The user-defined scaling factors α and β allow for a tradeoff
between favoring small distances to facets and fewer numbers of
surface primitives. Combining efficient RANSAC and graph-cut
algorithm results in a surface primitive detector that is both robust
to noises and flexible to approximate the mesh at various level.
4.1.2 Adding Auxiliary Planes. The above algorithm can detect
all visible surface primitives. In order to reconstruct solid primitives,
we also need to infer hidden surfaces. For example, if one face of a
cuboid is hidden inside another solid primitive, it will be impossible
to exactly determine the cuboid’s dimensions. We use the method
in [Shapiro and Vossler 1991, 1993] to add auxiliary planes. Specifically, we use the point samples to be described shortly to detect
whether a new auxiliary plane is needed, and choose to add planes
that are at certain anchor points (e.g., the center of a sphere) and
parallel to the detected surface primitives.
4.1.3 Building Solid Primitives. We construct solid primitives
once all surface primitives are collected. Building the solid primitives can itself be formulated as a discrete search problem: We
first locally solidify surface primitives by replacing f (x) = 0 with
f (x) ≥ 0, x ∈ R
3
, and then we build a solid primitive by intersecting the individually solidified surface primitives. For example, a
cuboid can be built by searching for three pairs of parallel planes
orthogonal to each other and intersecting either themselves or their
complements, depending on their signs. Although this solid primitive construction adds one more layer of search below the leaf node
in the grammar, the search space is now purely discrete: all continuous parameters have been determined at this point and encoded
in as a discrete search.
4.2 Reducing the Number of Constraints
Now that we have reduced the search space to a discrete one, the
next step is to handle the infinite number of point constraints. Previous work [Shapiro and Vossler 1991, 1993] has laid the theoretical
foundation for tackling this problem, which we briefly state below:
Definition 4.2 (Canonical intersection term). Let { f1, · · · , fn } be
the set of all surface primitives. A canonical intersection term C is
defined asC = ∩
n
i=1
Fi where Fi
is either {x|fi(x) > 0} or {x|fi(x) <
0}.
In other words, a canonical intersection term is an intersection
of halfspaces induced by each surface primitive. Based on the above
definition, [Shapiro and Vossler 1991] proposed the following describability theorem:
Definition 4.3. An input mesh is describable by surface primitives
{ f1, · · · , fn } if there exists a CSG tree whose leaves are fis and it
occupies the same volumetric region as the interior of the mesh.
Theorem 4.4. An input mesh is describable by surface primitives
{ f1, · · · , fn } if and only if every canonical intersection term has the
same classification with respect to the mesh.
The theorem is based on the fact that each canonical intersection
term is either fully included or excluded in the CSG tree, so the input
mesh can be accurately reconstructed if and only if each canonical
intersection term is fully inside or outside the mesh. As a result,
instead of checking every point p ∈ R
3
, it is sufficient to check only
one representative point from each canonical intersection term.
4.2.1 Sampling-based Method. Although [Shapiro and Vossler
1991] established the theoretical foundation, it assumes all the canonical intersection terms are given beforehand. In practice, however, as
the number of canonical intersection terms grows combinatorially,
enumerating all canonical intersection terms quickly becomes intractable. This motivates us to use a sampling-based method to find a
representative from approximately all canonical intersection terms:
we uniformly sample points inside the bounding box of the input
mesh, then keep only one representative sample in each canonical
intersection term. Then, we divide all resulting representatives into
two sets, P
+ and P
−, based on whether they are inside our outside
the input mesh, respectively.
4.2.2 Handling Imperfect Input. Sometimes the input mesh cannot be precisely reconstructed because there are missing surface
primitives, or because the mesh is noisy or imperfect. This causes
ambiguity when we assign labels (positive or negative) to representatives because both positive and negative samples can occur in a
single canonical intersection term. In this case, we assign the label
based on the majority of samples in that canonical intersection term.
This is equivalent to finding a CSG tree such that the volumetric
difference between it and the input mesh is minimized.
This step concludes the preprocessing step and leaves us with a
more tractable problem with a finite number of constraints:
ACM Transactions on Graphics, Vol. 37, No. 6, Article 213. Publication date: November 2018.
InverseCSG: Automatic Conversion of 3D Models to CSG Trees • 213:7
ALGORITHM 1: A naïve algorithm for finding a feasible solution
Input: Surface Primitives fi (x) = 0; P
+; P
−.
Output: A CSG tree that satisfies all constraints in Problem 4.5.
CSG = ∅;
for each p ∈ P
+ do
Cp = R
3
;
for each fi do
if fi (p) > 0 then
Cp = Cp ∩ {fi (p) > 0};
else
Cp = Cp ∩ {fi (p) < 0};
end
end
CSG = CSG ∪ Cp ;
end
return CSG;
Definition 4.5. Problem (1) can be equivalently redefined as the
following discrete problem:
min
CSG
Complexity(CSG)
s.t. PrimitiveSet(CSG) = {Detected Primitives}
∀p ∈ P
+
, Inside(CSG,p) = T rue
∀p ∈ P
−
, Inside(CSG,p) = False
(6)
4.3 A Naïve Algorithm
Algorithm 1 describes a naïve algorithm that produces a feasible
CSG solution to the problem in Definition 4.5 that satisfies all the
constraints but does not attempt to minimize its complexity.
Intuitively, Algorithm 1 outputs a long program that generates a
flattened CSG tree by merging many small 3D pieces. To get a rough
idea of how large the resulting CSG tree could be in the worst case,
recall that an arrangement of n general planes partitions the space
into O(n
3
) nonempty canonical intersection terms, which grows
quickly to tens of thousands of regions when we increase n to a
number even as small as 30. Even if only one percent of them are
occupied by the input mesh, this still leaves hundreds of subtrees for
Algorithm 1 to merge. As a result, this algorithm returns a concise
CSG program in practice only if |P
+| is very small.
5 ALGORITHM USING PROGRAM SYNTHESIS
Algorithm 1 provides a valid solution to the problem defined in
Definition 4.5. However, the resulting CSG program is far from compact. It might be possible to simplify this CSG program to some
extent using set theory rules, but piecing together all the small regions in the solution produced by Algorithm 1 is inherently a hard
task. In this section, we describe an algorithm that uses program
synthesis to directly search for a simple program that satisfies the
constraints in Definition 4.5. Since even small-sized programs can
induce a significantly large search space, for the algorithm described
in this section, we assume that the desired CSG program is small in
size. In the next section, we rectify this scalability issue by providing a divide-and-conquer algorithm which operates atop program
synthesis.
Program Synthesis. In program synthesis, one defines a space of
programs and attempts to search within the space for a program that
meets an input specification. For this algorithm, we define the search
space as all CSG trees that have at most k = 32 nodes within the
grammar specified in Section 4. We define the specification that the
positive (negative) representative points P
+ (P
−) lie in the interior
(exterior) of the CSG program generated mesh. Specifically, among
all CSG trees that have no more than k nodes, the synthesizer must
find the smallest one that can satisfy the point constraints on P
+
and P
−. As one can see, if there exists a tree of size k that satisfies
all the point constraints, the synthesizer, in theory, should be able to
find it within the search space. The success of a synthesizer hinges
on its ability to quickly search through the colossal search space
to find a satisfying solution. To give an example of how big this
search space is, given a choice of 10 solid primitives and depth 5, the
total number of valid CSG trees is 4.3 × 1025, making any explicit
enumeration of the search space infeasible. In our work, we rely
on Sketch [Solar-Lezama et al. 2006], a state-of-the-art program
synthesis system that uses constraint-based reasoning using SAT
solvers to efficiently search through this space. Sketch gives you the
choice of searching for the globally optimal solution or performing
only best-effort optimization. In our experiments, we run with besteffort optimization because it is faster and works well in practice.
Counter-Example Guided Inductive Synthesis. One of the key algorithmic components which allows Sketch to scale is the CounterExample Guided Inductive Synthesis (CEGIS) algorithm. The insight
is that while all constraints need to be satisfied for a program to be
correct, not all constraints need to be considered by the synthesizer
to produce the correct program: Imagine we’re synthesizing a linear
function y = mx +b, there can be thousands of point constraints on
the line, but only 2 distinct points are needed. CEGIS employs two
sub-routines, a synthesizer and a checker: The synthesizer solves
the search problem on a subset of constraints, producing a candidate
program. The checker takes the candidate program and, if possible,
produces a counter-example — that is, a constraint that invalidates
the candidate program. This counter-example is added to the subset
of constraints, prompting the synthesizer to find a better candidate
program. CEGIS terminates successfully when the checker fails to
produce a counter-example and terminates unsuccessfully when
the synthesizer fails to produce a candidate program. By iteratively
adding counter-examples to the subset, CEGIS limits the number of
constraints that need to be considered by the synthesizer, making
synthesis scalable.
Our Algorithm. We now have enough information to describe
Algorithm 2, which is built on top of Sketch and CEGIS. The algorithm is designed to solve small-scale problems under the assumption that the desired program is in the space of programs given
to Sketch. The algorithm returns a simple CSG tree satisfying all
point constraints.
Theorem 5.1. Algorithm 2 finds a feasible solution in finite time if
the desired program is in the search space given to the synthesizer.
The proof can be found in Appendix A.
ACM Transactions on Graphics, Vol. 37, No. 6, Article 213. Publication date: November 2018.
213:8 • Du, T. et al
ALGORITHM 2: An algorithm for small-scale problems.
Input: Surface Primitives fi (x) = 0; P
+; P
−.
Output: A CSG tree that satisfies all constraints in Definition 4.5.
Q+ = Pick a subset of P
+;
Q− = Pick a subset of P
−;
CSG = ∅;
do
CSG = The result from calling a synthesizer to satisfy Q+ and Q−;
Diff = ∅;
for each p ∈ P
+ do
if not Inside(CSG, p) then
Diff = Diff ∪ {p };
end
end
for each p ∈ P
− do
if Inside(CSG, p) then
Diff = Diff ∪ {p };
end
end
Pick a subset of points in Diff and add them to Q+ and Q− accordingly;
while Diff , ∅;
return CSG;
6 ALGORITHM FOR LARGE-SCALE PROBLEMS
We now describe how to scale the algorithm in Section 5 to large
problems. The key insight is to split the set of point constraints from
Definition 4.5 so that the synthesizer will only have to discover the
program for a small portion of the actual mesh. In an extreme case,
if we give only one positive point constraint to satisfy, then we can
always switch to Algorithm 1 to ensure success. Formally, the idea
is stated by Theorem 6.1:
Theorem 6.1. Let P
+
1
, P
+
2
, · · · , P
+
m be a partition of P
+ in Definition 4.5. Let Ti be the solution to the following problem:
min
Ti
Complexity(Ti)
s.t. PrimitiveSet(Ti) = {Detected Primitives}
∀p ∈ P
+
i
, Inside(Ti
,p) = T rue
∀p ∈ P
−
, Inside(Ti
,p) = False
(7)
Then ∪Ti
is a feasible solution to Definition 4.5.
The proof can be found in Appendix A.
While Theorem 6.1 does not specify a partition method, in practice semantically meaningful partitions like mesh segmentation or
point cloud segmentation techniques produce simpler and more
semantically meaningful programs than arbitrary partitions. This is
intuitive as geometrically similar points usually have a better chance
of being from the same CSG subtree. In our experiments, we tested
surface mesh segmentation, spectral clustering, and hierarchical
agglomerative clustering (HAC). We have found that HAC provides
the best trade-off of algorithmic simplicity and desirable results.
Algorithm 3 shows our final algorithm based on Theorem 6.1.
It recursively calls Algorithm 2 on the different partitions; if the
synthesizer fails on any partition, then the positive constraints are
split and the algorithm is run again. For the base case when |P
+
i
| = 1,
ALGORITHM 3: Final algorithm to solve large-scale problems.
Input: Surface Primitives fi (x) = 0; P
+; P
−.
Output: A CSG tree that satisfies all constraints in Definition 4.5.
if |P
+ | = 1 then
return CSG from Algorithm 1;
end
Compute (CSG, succeed) using Algorithm 2;
if succeed then
return CSG;
else
CSG = ∅;
Partition P
+ into P
+
1
, P
+
2
, · · · , P
+
m;
for each P
+
i
do
Ti = Recursively call Algorithm 3 with P
+
i
and P
−;
CSG = CSG ∪ Ti
;
end
return CSG;
end
the algorithm reverts back to Algorithm 1, which is guaranteed to
produce a solution for that partition. However, reaching the base
case is very rare (it never happened in our experiments) since the
search space that the synthesizer can handle is typically much bigger
than the size of a single partition.
Theorem 6.2. Algorithm 3 is guaranteed to produce a feasible
solution to the problem in Definition 4.5 in finite time.
The proof can be found in Appendix A.
7 POST-PROCESSING
The post-processing procedure has two stages. First, our method
attempts to further simplify the CSG tree returned by Algorithm 3.
Second, symmetric patterns are detected and reparameterized for
end-user re-editing. We describe each of these processes in turn.
7.1 Simplification
Following Algorithm 3, we begin a procedure to simplify its output.
Since the output is a union of the outputs produced by the program
synthesis system for the different segments, there might be some
unnecessary redundancies across the segments. We eliminate these
redundancies by applying a set of equivalence rules to simplify the
output CSG tree.
This simplification consists of three steps. In the first step, all
extremely similar pairs of solid primitives are identified. Two solid
primitives are considered similar if their types are the same and
their positions, orientations, and parameterizations are all close in
Euclidean distance. These similar solid primitives are replaced with
a single common solid primitive.
In the second step, all intersections and unions are flattened
with respective nested operations, and redundant expressions are
eliminated. For example, (A∪B)∪A would be flattened to (A∪B∪A),
and the redundant ∪A would be eliminated, yieldingA∪B. The same
would be true if all of the unions were changed to intersections.
However, expressions with mixtures of operators, such as (A∪B)∩A
would not be simplified in any way in this step.
ACM Transactions on Graphics, Vol. 37, No. 6, Article 213. Publication date: November 2018.
InverseCSG: Automatic Conversion of 3D Models to CSG Trees • 213:9
In the third and final step, our algorithm recursively attempts to
simplify nested expressions. During each simplification, all combinations of all sub-expressions are compared, and a set of prescribed
simplification rules are greedily applied. If a pair of subexpressions
is simplified at a certain depth in the expression tree, the entire
tree is re-simplified from that node downward, in order to take
advantage of potentially newly exposed simplifications.
7.2 Symmetry-Based Re-editing
While the resulting CSG tree is useful in that it can be directly edited,
each component of the tree is independent. Parameterizations are
isolated to each individual solid primitive. In order to facilitate
easy user exploration and editing of the resulting CSG tree, we reparameterize some of the solid primitives of the resulting CSG tree
in order to take advantage of potential symmetries. In particular,
we loop over each pair of solid primitives of the same type in our
CSG tree and compare their volumetric parameterizations. For each
pair, we compare sphere radii, cylinder radii, cylinder heights, and
cuboid bounding box extent triplets (disregarding order). If any of
these four quantities match, we consider the solid primitive pair to
be symmetric in that parameter (or parameter set, in the case of the
cuboid), and reparameterize them with a meta-parameter. This metaparameterization allows all detected symmetric solid primitives to
be edited simultaneously by changing a single value, preserving the
detected symmetry.
8 RESULTS
In this section, we first present a new dataset for benchmarking the
performances of different reverse engineering methods. We then
compare our algorithm to two baselines and report their performances on our dataset. For almost every model in the dataset, our
method manages to find a much more compact CSG tree compared
to the baseline approaches and reconstruct all examples with < 7%
relative error (Figure 8). Next, we demonstrate the robustness of our
method by testing it on imperfect meshes. Finally, we discuss the
effectiveness of our simplification step and present mesh re-editing
examples.
8.1 Benchmark
Although reverse engineering a surface mesh to a CSG tree is a
long-studied problem, not a lot of effort has been made to build
a test set for evaluating different algorithms. The lack of a highquality dataset makes it more difficult to fairly compare between
different methods. In this work, we attempt to close this gap by
presenting a dataset that consists of 50 clean surface meshes of
various complexity. These meshes are collected from examples in
the previous work [Buchele and Crawford 2004; Fayolle and Pasko
2016] and online CAD libraries [GrabCAD 2018; Thingiverse 2018;
Zhou and Jacobson 2016], including objects such as brackets, gears,
and knot structures. The simplest of these surface meshes can be
constructed by fewer than 10 surface primitives while the most
complex model requires over 100 surface primitives. We ask readers
to refer to Figure 5, 6, and 7 for more details.
We use this benchmark set to evaluate our algorithm and two
baselines [Buchele and Crawford 2004; Fayolle and Pasko 2016].
Fig. 5. Here we show five examples from the benchmark and our solutions.
Left: input meshes. Middle: output meshes reconstructed from our CSG
solutions. Right: intermediate CSG results for visualization purposes. We
visualize the CSG trees by doing a post-order tree traversal. For these five
examples, the complete visualization can be found in our video.
Each method takes as input a mesh from the dataset and outputs
the best CSG tree it can find. We evaluate methods on three metrics:
the complexity of the tree (the number of nodes), the volumetric
difference between the mesh and the tree, and the runtime.
8.2 Comparison to Deductive Methods
Since Theorem 4.4 was proposed in [Shapiro and Vossler 1991], many
follow-up methods have been proposed [Buchele 1999; Buchele
and Crawford 2004; Buchele and Roles 2001; Shapiro 2001; Shapiro
and Vossler 1993] to try to solve both 2D and 3D meshes. At a
high level, this line of research attempts to solve the problem in a
deductive manner: knowing the sign of each canonical intersection
ACM Transactions on Graphics, Vol. 37, No. 6, Article 213. Publication date: November 2018.
213:10 • Du, T. et al
Fig. 6. Eight representative examples out of the 50 models in our benchmark.
9 11 12 14 15 15 15 16 17 17 17 19 19 21 22 24 26 28 28 29 30 32 36 36 36 37 37 38 38 40 42 42 46 47 47 47 48 53 53 55 57 57 58
65 65
71 73
79
98
119
0
20
40
60
80
100
120
140
11 67 162 161 130 159 176 167 157 168 169 101 170 156 158 96 112 41 144 129 107 145 60 114 142 133 140 56 127 91 128 148 131 82 117 126 152 150 155 139 39 123 109 81 147 146 160 143 153 68
Number of surface primitives
Example ID
Fig. 7. Our benchmark provides meshes of various complexity (number of surface primitives). This chart shows the number of surface primitives in each mesh
in an increasing complexity order.
term, a union of all the positive canonical intersection terms is
considered as an initial (valid) solution. Then, a set of equivalence
rules are iteratively applied to simplify this solution. In this section,
we implemented the BHC algorithm in [Buchele and Crawford 2004]
and evaluate its performance on our benchmark. The output is a
binary CSG tree saved in an OpenSCAD file and no post-processing
was applied. The results are compared to ours and discussed below.
Tree Complexity. We evaluate the tree complexity in terms of
the number of nodes (Figure 9). For almost every example, our
method generates significantly more concise solutions, and the
trend becomes more obvious as the problem size scales up. This is
because our synthesizer gives the performance boost in generating
a smaller number of leaf and internal nodes.
Volumetric Difference. Since both methods are built on top of
Theorem 4.4, the results are guaranteed to have small volumetric
difference (Figure 8). The standard Hausdorff distance is also evaluated and provided along with the volumetric error. The relative
errors shown in these examples are mostly due to the difference
between perfect curved surfaces and the tessellation in the input
meshes (Figure 11).
Runtime. Figure 10 shows the runtime of our algorithm for each
example in the benchmark. Runtime less than 2 minutes is not displayed in Figure 10 due to the axis range. The most time-consuming
ACM Transactions on Graphics, Vol. 37, No. 6, Article 213. Publication date: November 2018.
InverseCSG: Automatic Conversion of 3D Models to CSG Trees • 213:11
0
0.01
0.02
0.03
0.04
0.05
0.06
0.07
0.08
11 67 162161130159176167157168169101170156158 96 112 41 144129107145 60 114142133140 56 127 91 128148131 82 117126152150155139 39 123109 81 147146160143153 68
Relative reconstruction error
Example ID
Volume Hausdorff
Fig. 8. The relative reconstruction error using our method. Blue: the relative volumetric error, computed by dividing the volumetric difference by the volume of
the input mesh. Orange: the relative Hausdorff distance, computed by the Hausdorff distance divided by the size of the bounding box of the input mesh.
0
200
400
600
800
1000
1200
1400
11 67 162161130159176167157168169101170156158 96 112 41 144129107145 60 114142133140 56 127 91 128148131 82 117126152150155139 39 123109 81 147146160143153 68
Number of nodes in solution
Example ID
Ours BHC >3000
Fig. 9. Comparison between our method and the BHC algorithm in terms of node numbers.
0
50
100
150
200
250
300
350
11 67 162161130159176167157168169101170156158 96 112 41 144129107145 60 114142133140 56 127 91 128148131 82 117126152150155139 39 123109 81 147146160143153 68
Runtime in minutes
Example ID
Fig. 10. Time spent on each example in the data set by our method. Missing columns mean the examples were solved in less than 2 minutes.
example was finished in 330.3 minutes, and the average runtime
across the whole benchmark is 38.3 minutes. The time reported in
Figure 10 was measured by running our algorithm in the sequential mode in order to make a fair comparison to other baselines. In
practice, one can parallelize the algorithm in Section 6 because after
segmentation, solving each part is completely independent of each
other.
Compared to our method, the BHC algorithm has an expected
O(n
3
) running time where n is the number of surface primitives. For
our benchmark where most examples have n < 100, we observed
the BHC algorithm finished typically in less than a few minutes.
Although BHC is a faster algorithm, our method generates much
more compact solutions, making it arguably the better choice when
the runtime is not a bottleneck.
ACM Transactions on Graphics, Vol. 37, No. 6, Article 213. Publication date: November 2018.
213:12 • Du, T. et al
8.3 Comparison to Genetic Algorithm
Fig. 11. Here we show example 67, the one with the largest volumetric error
in Figure 8. Left: the input mesh which triangulates the spherical surface
using 24×12 squares. Right: our synthesizer recognizes the underlying sphere
and exports it as a high-resolution mesh, causing the large volumetric
difference shown in Figure 8 (6.5%, column 2).
We also compared our algorithm to a genetic algorithmic approach presented in [Fayolle and Pasko 2016]. We ran this algorithm
on our benchmark using the parameters as they reported them —
50, 000 sample points and a population size of 150.
We compared our algorithm to the genetic algorithm on four
different meshes, running on a Xeon E5-1620 3.5 GHz processor.
Solving for the CSG of these meshes scaled exceptionally poorly in
the number of candidate primitives. Examples 101, 128, and 145 had
19, 42, and 32 surface primitives respectively, and each required at
least 2 hours per iteration. Given that they each required over 100
iterations, we terminated the optimization after 200 hours without
completion. By comparison, our algorithm was able to solve these
problems in 1.6, 15.2, and 4.6 minutes.
We were able to run one example to completion using the genetic
algorithm. The genetic algorithm ran on example 96, with 12 solid
primitives in approximately 2 hours, and ultimately terminated
with 14% error. Figure 12 shows the energy of the elite CSG tree
versus the generation. The genetic algorithm’s most computationally
expensive step — the energy function evaluation — is embarrassingly
parallelizable, and speedups scale linearly with the number of CPU
cores available up to the population size. Ideally, when we use 150
cores, this approach can be sped up to a runtime 8 minutes and
56 seconds. However, we note that most CPUs have no more than
8 cores (parallelizing on 8 cores would require more than 4 hours
for this example), leaving such parallelization infeasible outside of
cloud applications. By comparison, our algorithm was able to solve
example 96 in only 50 seconds on a single thread — faster than any
parallelization of the genetic algorithm, while using significantly
fewer resources, and producing only 0.0023% error. For reference,
we show the evolution of the genetic algorithm’s elite candidate
CSG tree energy function and volumetric error in Figure 13.
To further demonstrate the scalability of our algorithm versus
the genetic algorithm, we ran the genetic algorithm on a CSG tree
comprised of a single leaf cuboid and provided 6 candidate primitives.
Single-threaded, the genetic algorithm was able to find the optimal
solution in 1 hour 4 mins (and 103 generations). Given 150 cores, this
0
20000
40000
60000
80000
100000
120000
1 101 201 301 401 501 601
Energy
Generation
Fig. 12. The energy as defined by [Fayolle and Pasko 2016] of the elite CSG
tree in the genetic algorithm’s population, vs. generation. While the energy
improves rapidly at the beginning, it is unable to resolve all discrepancies
between the input and generated mesh after 672 iterations.
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
1 101 201 301 401 501 601
Relative volumetric error
Generation
Fig. 13. The relative volumetric error of the elite CSG tree in the genetic
algorithm’s population, vs. generation. The energy in [Fayolle and Pasko
2016] is purely defined on the surface difference so it fails to capture the volumetric change. Thus, while energy monotonically increases, the volumetric
error oscillates between generations.
Fig. 14. The input mesh (left) and the mesh produced by the best CSG tree
after termination of the genetic algorithm (right). Note that the genetic
algorithm’s output still has a few points of notable volumetric difference,
particularly containing extra segments at the top-left-back and bottom.
ACM Transactions on Graphics, Vol. 37, No. 6, Article 213. Publication date: November 2018.
InverseCSG: Automatic Conversion of 3D Models to CSG Trees • 213:13
could be solved in around 40 seconds. By comparison, our algorithm
solves the problem single-threaded in less than 5 seconds. We note
that our algorithm, when running, considers 216 solid primitives
and is still around 800 times faster. If the genetic algorithm was
fed 15 candidate primitives, iterations took longer than an hour
apiece and was not run to completion. To give a stronger sense as
to the comparative robustness between algorithms with respect to
unnecessary candidate primitives, our algorithm solved example 96
having been given 216133 candidate solid primitives.
8.4 Robustness
Most examples in our benchmark were surface meshes exported
from CAD software. As a result, we know in advance there exists
at least one CSG program that can perfectly represent the input
mesh. In this section, we demonstrate the robustness of our algorithm by pushing it to solve noisy meshes that cannot be precisely
described by our CSG grammar. Moreover, to show in our pipeline
the synthesizer is resilient to changes in primitive detection results,
we send the synthesizer various number of surface primitives and
evaluate its output. In both cases, our pipeline is able to find an
approximation of the input mesh at various levels.
8.4.1 Handling General Mesh Inputs. Here we provide three examples to show our algorithm is robust to handle input meshes
beyond the capability of our CSG grammar. The Fandisk example
(Figure 15) contains general quadratic surfaces not yet supported
by our grammar, and our pipeline found a good approximation of
Fandisk using spheres, planes, and cylinders only.
In the next two examples, we alternate the inputs by adding
noises (Figure 16) or remeshing (Figure 17). The results show that
our pipeline can tolerate a certain amount of changes in the inputs
while still generating solutions that capture the underlying structure.
This is mostly because of the robustness of our primitive detector.
Fig. 15. Our pipeline can approximate meshes made from primitives not
included in the grammar. Left: the Fandisk example that contains quadratic
surfaces; Right: the output of our method that approximates the input mesh.
8.4.2 Varying Surface Primitive Number. Another question we
ask is how robust our synthesizer is if the primitive detector fails
to deliver the right set of surface primitives. As explained in Section 4, the synthesizer will attempt to use the given primitives to
approximate the mesh as closely as possible. Figure 18 demonstrates
this in example 39, which has 57 surface primitives in total. Here
Fig. 16. Solving input meshes with different amount of noises. Top row from
left to right: 0%, 1%, and 2% noises are added. Bottom row: our solutions.
Fig. 17. Solving remeshed models. Top row: input meshes that use a different
number of slices to approximate curved surfaces. Bottom row: our solutions.
we vary the threshold in our graph-cut algorithm to generate 10,
20, 40, and eventually 57 surface primitives and send them to the
synthesizer. As the number of primitives increases, the volumetric
difference becomes smaller and the synthesizer gradually converges
to the input mesh. As shown in the figure, even with limited primitives, the synthesizer still does reasonably well in finding a good
approximation of the mesh.
8.5 Post-processing
8.5.1 Program Simplification. We applied our simplification procedure to all of our output CSG solutions (Figure 19). In general, we
found that our method was able to reduce the number of tree nodes
by 16% on average. This reduction was in part due to flattening
binary expressions of the same type and in part due to recognizing duplicated subtrees between segments. Since our simplification
algorithm does not reason about geometry, it cannot, e.g., merge
adjacent cuboids, or remove shapes which have no impact on the
ACM Transactions on Graphics, Vol. 37, No. 6, Article 213. Publication date: November 2018.
213:14 • Du, T. et al
Fig. 18. Using a various number of primitives to approximate example 39.
Left in the red box: the original mesh. Right: results from our pipeline using
10, 20, 40, and 57 surface primitives. As the number of primitives increases,
the result converges to the input mesh.
output geometry. We leave such extensions to our method for future
work.
8.5.2 Mesh Re-editing. We present an example of changing CSG
parameters using our symmetry-based re-parameterization in Figure 20. We found that our method is good at detecting and metaparameterizing most symmetries. However, symmetries may be
missed in two cases. First, if two geometries are very similar but
differ beyond the user-chosen threshold distance, they will not be detected as symmetric. This is an inevitable drawback of thresholding.
Second, although two geometries in a design might be symmetric,
the detected CSG might not be symmetric due to occlusion. For
example, one primitive in a symmetric pair may be longer than
the other if it protrudes into, and is completely covered by, other
existing geometry in the part. This phenomenon can create both
false positives and false negatives. In example 160, some symmetries
of the base frame were missed for this latter reason. Frame pieces on
one side are longer than the other, although visually they look the
same since the extra length contributes to a corner which is already
covered by an adjacent cuboid primitive. In either of these cases
the geometry, though symmetric, will not be meta-parameterized
as such.
9 DISCUSSION
Reverse engineering a CAD model is a classic and fundamental
problem. Despite its long history, solving it in a general 3D setting
is still considered to be very difficult due to its huge search space. By
combining geometric processing methods and program synthesis
techniques, we have presented a pipeline that pushes the problem
of reverse engineering a CAD model to a larger scale that has not
been seen in any previous work. This scalability improvement is
mostly because of our effort to reformulating the original problem
as a discrete search task that modern program synthesizers excel in,
and understanding how far we can push a program synthesizer to
solve this classic problem remains an exciting direction to explore.
As pointed out before, our pipeline is also robust to imperfect
inputs, including meshes not describable by our grammar or missing
surface primitives. This is in part due to the primitive detector
being resilient to noise, and in part due to preprocessing samples in
each canonical intersection term to avoid potential conflicts in the
synthesizer beforehand. Alternatively, we can choose to increase
the expressiveness of our grammar by including more primitive
types, e.g., quadratic or even B-spline surfaces, which opens up the
possibility of accurately reconstructing a free-form geometry.
One limitation of our work is that our results are greatly shaped by
the segmentation method used in our algorithm. Good segmentation
generally leads to compact solutions and short programs, whereas
bad segmentation may result in broken pieces and overcomplicated
solutions. In our algorithm design, we intentionally avoid relying
on a specific segmentation method in exchange for generality so
that different segmentation methods can be modularly swapped.
It is natural to extend our pipeline to combine mesh and point
cloud-based segmentations, which we leave for future work.
Finally, the CSG grammar discussed in this paper is limited to
basic CSG operations. In the future, it would be interesting to explore
the possibility of integrating higher-level programming language
concepts like for loops, if-else statements, or even recursive calls
into the pipeline. Interestingly, it turns out we can build strong
connections between these concepts and classic geometry problems.
For example, synthesizing a for loop in a CSG program can be linked
to detecting symmetric or repeated patterns on the mesh. As a result,
we believe combining these two active research fields will open up
new possibilities and inspire more exciting research work to come
in the future.
10 CONCLUSION
We have presented a novel method which infers CSG programs that
reconstruct an input triangle mesh. We built a dataset of 50 CAD
models of varying complexity, where the most complex one has over
100 surface primitives. The dataset has more examples, and more
complex examples, than previous work. By intelligently converting
a mixed, over-constrained search problem into a discrete, compact
form, we presented a parallelizable search algorithm that solved
examples in the dataset. Further, we demonstrated the robustness of
our algorithm by solving examples not describable by our grammar.
Finally, since our method returns parameterized CSG programs, it
provides a powerful means for end-users to edit and understand the
structure of 3D meshes.
By decoupling primitive detection and search, we have created a
general and flexible framework. By formulating our problem in the
context of programming languages, we have been able to employ
state-of-the-art program synthesis techniques, which can quickly
produce high-quality, compact results. In the future, we hope to
extend our method to more complex classes of geometry, such as
spline surfaces. We also hope to introduce higher level programming
concepts to the pipeline and further explore the connections between program synthesis, geometry processing, and computer-aided
design. We look forward to seeing how the community can apply
our proposed techniques to more complex, real-world problems.
A THEOREMS AND PROOFS
Proof of Theorem 5.1. To show the algorithm terminates in finite
time, note that |Q
+|+|Q
−| increases by at least one at each iteration.
ACM Transactions on Graphics, Vol. 37, No. 6, Article 213. Publication date: November 2018.
InverseCSG: Automatic Conversion of 3D Models to CSG Trees • 213:15
0
100
200
300
400
500
600
11 67 162161130159176167157168169101170156158 96 112 41 144129107145 60 114142133140 56 127 91 128148131 82 117126152150155139 39 123109 81 147146160143153 68
Number of nodes in solution
Example ID
Before simplification After simplification
Fig. 19. The number of tree nodes in our solutions before and after applying the simplification step in Section 8.5.
Fig. 20. Symmetry-based re-editing results in example 160. The leftmost
figure shows the output shape from our algorithm, then three sequential
editing operations are applied, highlighted in red boxes.
Since |Q
+| ≤ |P
+| and |Q
−| ≤ |P
−|, the loop runs at most |P
+|+|P
−|
times. Upon termination, the Diff set is empty, meaning that CSG
satisfies all points in P
+ and P
− and therefore it is a feasible solution
to Problem 4.5.
Proof of Theorem 6.1. By definition, CSG uses only detected primitives. To see points in P
+ are inside CSG, pick any p ∈ P
+. Since
{P
+
i
} is a partition of P
+, p must come from some P
+
i
. Thus p ∈ Ti ⊂
CSG. To see that all points in P
− are excluded, assume there is
one counter-example p ∈ P
− but p ∈ CSG. Therefore, there exists i such that p ∈ Ti
, which contradicts to the fact that ∀p ∈
P
−, Inside(Ti
,p) = False.
Proof of Theorem 6.2. To show the recursion terminates in finite
time, just note that |P
+| strictly decreases in each recursive call. To
show the guarantee, notice that Algorithm 1 never fails and whenever Algorithm 2 fails it is reduced to Algorithm 1 eventually. The
fact that the solution is feasible comes directly from the correctness
of Algorithm 1, Algorithm 2, and Theorem 6.1.