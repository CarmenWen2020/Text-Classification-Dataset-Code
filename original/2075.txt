Regression-based algorithms have shown to be good at denoising Monte
Carlo (MC) renderings by leveraging its inexpensive by-products (e.g., feature buers). However, when using higher-order models to handle complex
cases, these techniques often overt to noise in the input. For this reason,
supervised learning methods have been proposed that train on a large collection of reference examples, but they use explicit lters that limit their
denoising ability. To address these problems, we propose a novel, supervised
learning approach that allows the ltering kernel to be more complex and
general by leveraging a deep convolutional neural network (CNN) architecture. In one embodiment of our framework, the CNN directly predicts the
nal denoised pixel value as a highly non-linear combination of the input
features. In a second approach, we introduce a novel, kernel-prediction network which uses the CNN to estimate the local weighting kernels used to
compute each denoised pixel from its neighbors. We train and evaluate our
networks on production data and observe improvements over state-of-theart MC denoisers, showing that our methods generalize well to a variety of
scenes. We conclude by analyzing various components of our architecture
and identify areas of further research in deep learning for MC denoising.
CCS Concepts: â€¢ Computing methodologies â†’ Computer graphics;
Rendering; Ray tracing;
Additional Key Words and Phrases: Monte Carlo rendering, Monte Carlo
denoising, global illumination
1 INTRODUCTION
In recent years, physically-based image synthesis has become widespread in feature animation and visual eects [Keller et al. 2015].
ACM Transactions on Graphics, Vol. 36, No. 4, Article 97. Publication date: July 2017.
97:2 â€¢ Bako, S. et al.
Fueled by the desire to produce photorealistic imagery, many production studios have switched their rendering algorithms from REYESstyle micropolygon architectures [Cook et al. 1987] to physicallybased Monte Carlo (MC) path tracing [Kajiya 1986]. While MC
rendering algorithms can satisfy strict quality requirements, they
do so at an immense computational cost and with convergence characteristics that require long rendering times for noise-free images,
especially for scenes with complex light transport.
Fortunately, recent postprocess, image-space, general MC denoising algorithms have demonstrated it is possible to achieve highquality results at considerably reduced sampling rates (see Zwicker
et al. [2015] and Sen et al. [2015] for an overview), and commercial
renderers are now incorporating these techniques. For example,
Chaos Groupâ€™s VRay renderer, the Corona renderer, and Pixarâ€™s
RenderMan now ship with integrated denoisers. Moreover, many
production houses are developing their own internal solutions [Goddard 2014] or using third-party tools (e.g., the Altus denoiser).
Although a wide variety of image-space MC denoising approaches
have been proposed, most state-of-the-art techniques use a regression framework [Moon et al. 2014; Bitterli et al. 2016]. Improvements
have been achieved thanks to more robust distance metrics, higher
order regression models, and diverse auxiliary buers tailored to
specic light transport components. These advances, however, have
come at the cost of ever-increasing complexity, while oering progressively diminishing returns. This is partially because higherorder regression models are prone to overtting to the noisy input.
To circumvent the noise-tting problem, Kalantari et al. [2015]
recently proposed an MC denoiser based on supervised learning that
is trained with a set of examples of noisy inputs and the corresponding reference outputs. However, this approach used a relatively
simple multi-layer perceptron (MLP) for the learning model and
was trained on a small number of scenes. More importantly, their
approach hardcoded the lter to either be a joint bilateral or joint
non-local means, which limited the exibility of their system.
To address these shortcomings, in this paper we propose a novel,
supervised learning framework that allows for more complex and
general ltering kernels by leveraging deep convolutional neural
networks (CNNs). The ever-increasing amount of production data
oers the large and diverse dataset required for training a deep CNN
to learn the complex mapping between a large collection of noisy
inputs and corresponding references. The advantage is that CNNs
are able to learn powerful, non-linear models for such a mapping by
leveraging information from the entire set of training images, not
just a single input as in many of the previous approaches. Moreover,
once trained, CNNs are fast to evaluate and do not require manual
tuning or parameter tweaking. Finally, such a system can more
robustly cope with noisy renderings to generate high-quality results
on a variety of MC eects without overtting.
Although our approach could be used for other applications of
physically-based image synthesis, in this work we focus on highquality denoising of static images for production environments.
Specically, our contributions are as follows:
â€¢ Our main contribution is the rst deep learning solution for
denoising MC renderings which was trained and evaluated
on actual production data. Our architecture performs on par
or better than existing state-of-the-art denoising methods.
â€¢ Inspired by the standard approach of estimating a pixel
value as a weighted average of its noisy neighborhood, we
propose a novel kernel-prediction CNN architecture that
computes the locally optimal neighborhood weights. This
provides regularization for a better training convergence
rate and facilitates use in production environments.
â€¢ Finally, we explore and analyze the various processing and
design decisions of our system, including our two-network
framework for denoising diuse and specular components
of the image separately, and a simple normalization procedure that signicantly improves our approach (as well as
previous methods) for images with high dynamic range.
2 PREVIOUS WORK
Both MC denoising and deep learning have been the focus of extensive research, the scope of which is too large to be covered in
this paper. Therefore, for MC denoising, we will restrict ourselves
to the most directly related of the a posteriori methods, which treat
the renderer as a black box. For a more complete overview, we refer
readers to the review by Zwicker et al. [2015]. For deep learning, we
will focus on convolutional neural networks [LeCun et al. 2015].
2.1 Image-space General Monte Carlo Denoising
We begin by discussing image-space denoising methods that lter
the noise from general distributed Monte Carlo eects (e.g., depth of
eld, motion blur, glossy reections, and global illumination). The
most successful state-of-the-art methods build on the idea of using
generic non-linear image-space lters [Rushmeier and Ward 1994]
and auxiliary feature buers as a guide to improve the robustness of
the ltering process [McCool 1999]. A key development introduced
by Sen and Darabi [2012] was to leverage noisy auxiliary buers
in a joint bilateral ltering scheme, where the bandwidths of the
various auxiliary features are derived from the sample statistics.
Li et al. [2012] later proposed to estimate the lter error with the
SURE metric [Stein 1981] to set the lter bandwidths, while Moon
et al. [2014] used asymptotic bias analysis to do so. In our system,
the training procedure implicitly learns the appropriate weighting
of the various auxiliary buers.
A particularly successful application of these ideas was to use
the non-local means lter of Buades et al. [2005] in a joint ltering
scheme [Rousselle et al. 2013; Moon et al. 2013; Zimmer et al. 2015].
The enduring appeal of the non-local means lter for denoising MC
renderings is largely due to its versatility. Indeed, more powerful
image-space lters, such as BM3D [Dabov et al. 2006], have seen
less use for MC denoising with some notable exceptions [Kalantari
and Sen 2013]. This is due to the fact that they have not yet been
successfully extended to leverage auxiliary buers, a key component
of current state-of-the-art methods. In our work, we propose to use
machine learning instead of a xed lter, which not only has been
shown to perform on par with state-of-the-art image lters [Burger
et al. 2012], but also allows us to feed our network with auxiliary
buers and leverage the robustness they provide.
Recently, it was shown that joint ltering methods, such as those
cited above, can be interpreted as linear regressions using a zeroorder model, and that, more generally, most state-of-the-art MC
denoising techniques are based on a linear regression using a zeroACM Transactions on Graphics, Vol. 36, No. 4, Article 97. Publication date: July 2017.
Kernel-Predicting Convolutional Networks for Denoising Monte Carlo Renderings â€¢ 97:3
or rst-order model [Moon et al. 2014; Bitterli et al. 2016]. Methods
leveraging a rst-order model have proved to be very useful for MC
denoising [Bauszat et al. 2011; Moon et al. 2014; Bitterli et al. 2016],
and while higher-order models have also been explored [Moon
et al. 2016], it must be done carefully to prevent overtting to the
input noise. In contrast, the deep CNN used in our system can oer
powerful non-linear mappings, without overtting, by learning the
complex relationship between noisy and reference data across a
large training set.
Recently, Kalantari et al. [2015] proposed a learning-based ltering approach, which is closely related to our own work. However,
their network uses a xed lter as a back-end, and therefore inherits
its limitations. In contrast, we propose a solution that implicitly
learns the lter itself and therefore produces better results.
Finally, there is concurrent work by Chakravarty et al. [2017]
that also applies deep learning to denoise Monte Carlo renderings,
but it targets dierent applications than ours focusing more on
interactive renderings with low sample counts instead of high-end,
production-quality renderings. To facilitate comparisons between
the two approaches, we both compare to a previous baseline method
in our respective papers (see Sec. 6).
2.2 Convolutional Neural Networks
In recent years, convolutional neural networks (CNNs) have emerged
as a ubiquitous model in machine learning, achieving state-of-theart performance in a diverse range of tasks such as image classi-
cation [He et al. 2016], speech processing [Oord et al. 2016], and
many others. CNNs have also been used a great deal for a variety
of low-level, image-processing tasks. In particular, several works
have considered the problem of natural image denoising [Xie et al.
2012; Zhang et al. 2016; Gharbi et al. 2016] and the highly related
problem of image super-resolution [Yang et al. 2016].
However, a naÃ¯ve application of a convolutional network to MC
denoising exposes a wide range of issues that is handled in our
framework. First, training a network to compute a denoised color
from only a raw, noisy color buer causes overblurring since the
network cannot distinguish between scene noise and scene detail.
Moreover, since the rendered images have high dynamic range, direct training can cause unstable weights (e.g., extremely large or
small values) that cause bright ringing and color artifacts in the
nal image. By preprocessing our features as well as exploiting
the diuse/specular decomposition, we are able to preserve important detail while denoising the image. Furthermore, we introduce
the novel kernel prediction architecture (Sec. 4.1) to keep training
tractable/stable. In Sec. 7, we motivate and explore how these design
decisions aect the performance of our system.
3 THEORETICAL BACKGROUND
Before introducing our proposed denoising framework, we rst
dene our notation and present the interpretation of denoising as
a supervised learning problem. To begin, the samples output by a
typical MC renderer can be averaged down into a vector of per-pixel
data, xp = {cp,fp }, where xp âˆˆ R
3+D . Here, cp represents the RGB
color channels and fp is a set of D auxiliary features (e.g., surface
normals, depth, albedo, and their corresponding variances).
The goal of MC denoising is to obtain a ltered estimateDcp that
is as close as possible to a ground truth result cp that would be
obtained as the number of samples goes to innity. This estimate is
usually computed by operating on a block Xp of per-pixel vectors
around the neighborhood N (p) to produce the ltered output at
pixel p. Given a denoising function Ð´(Xp ; Î¸ ) with parameters Î¸, the
ideal denoising parameters at every pixel can be written as:
DÎ¸p = argmin
Î¸
`(cp,Ð´(Xp ; Î¸ )), (1)
where the denoised value is Dcp = Ð´(Xp ;DÎ¸p ) and `(c,Dc) is a loss
function between the ground truth value, c, and the denoised value.
Clearly, optimizing Eq. 1 is impossible since ground truth values c
are not available at run time. Instead, most MC denoising algorithms
estimate the denoised color at a pixel by replacing Ð´(Xp ; Î¸ ) with
Î¸
>Ï•(xq ), where function Ï• : R
3+D â†’ R
M is a (possibly non-linear)
feature transformation with parameters Î¸. They then solve the
following weighted least-squares regression on the color values, cq,
around the neighborhood, q âˆˆ N (p):
DÎ¸p = argmin
Î¸
X
q âˆˆN (p)

cq âˆ’ Î¸
>Ï•(xq )
2
Ï‰(xp, xq ), (2)
where the nal denoised pixel value is computed asDcp = DÎ¸
>
p Ï•(xp ).
In this case, the regression kernel Ï‰(xp, xq ) helps to ignore values
that are corrupted by noise, e.g., by changing the feature bandwidths
in a joint bilateral lter [Sen and Darabi 2012]. Note that Ï‰ could
potentially also operate on patches, rather than single pixels, as in
the case of a joint non-local means lter.
As observed previously [Moon et al. 2014; Bitterli et al. 2016],
some of the previous methods can be classied as zero-order methods with Ï•0 (xq ) = 1 [Sen and Darabi 2012; Rousselle et al. 2013],
rst-order methods with Ï•1 (xq ) = [1; xq] [Moon et al. 2014], or
higher-order methods [Moon et al. 2016] where Ï•m (xq ) enumerates all the polynomial terms of xq up to degree m (see Bitterli et
al. [2016] for a detailed discussion).
With this formulation in mind, the limitations of these individual
approaches can be understood in terms of bias-variance tradeo
[Friedman et al. 2001]. Zero-order methods are equivalent to using an explicit function such as a joint bilateral [Li et al. 2012] or
non-local means lter [Rousselle et al. 2012]. These represent a
restrictive class of functions that trade reduction in variance for a
high modeling bias. Although a well-chosen weighting kernel, Ï‰,
can yield good performance [Rousselle et al. 2013; Kalantari et al.
2015], such approaches are fundamentally limited by their explicit
lters. In this work, we seek to remove this limitation by making
the lter kernel more exible and powerful.
Furthermore, using a rst- or higher-order regression increases
the complexity of the function, but is prone to overtting as DÎ¸p is
estimated locally using only a single image and can easily t to the
noise. To address this problem, Kalantari et al. [2015] proposed to
take a supervised learning approach to estimate Ð´ using a dataset D
of N example pairs of noisy image patches and their corresponding
reference color information, D = {(X1, c1), . . . , (XN , cN )}, where
ci corresponds to the reference color at the center of patch Xi
located at pixel i of one of the many input images. Here, the goal
is to nd parameters of the denoising function, Ð´, that minimize
ACM Transactions on Graphics, Vol. 36, No. 4, Article 97. Publication date: July 2017.
97:4 â€¢ Bako, S. et al.
albedo irradiance
color
Direct
or
Weighted
reconstruction
Diffuse CNN
Specular CNN
100x
5x5
Diffuse components
Specular components
Denoised image exponential
transform
Direct
or
Weighted
reconstruction
albedo
multiply
logarithmic
transform &
normalization &
gradient extraction
albedo
divide
100x
5x5
100x
5x5
Preprocessing Filtering Postprocessing
Renderer
normalization &
gradient extraction
Fig. 2. An overview of our general framework. We start by preprocessing diuse and specular data coming from the rendering system independently, and then
feed the information to two separate networks which denoise the diuse and specular illumination, respectively. The output from each network undergoes
reconstruction and postprocessing before being combined to obtain the final, denoised image.
the average loss with respect to the reference values across all the
patches in D:
DÎ¸ = argmin
Î¸
1
N
X
N
i=1
`(ci
,Ð´(Xi
; Î¸ )), (3)
In this case, the parameters, Î¸, are optimized with respect to all the
reference examples, not the noisy information as in Eq. 2. If DÎ¸ is
estimated on a large and representative training data set, then it can
adapt to a wide variety of noise and scene characteristics.
However, the approach of Kalantari et al. [2015] has several limitations, the most important of which is that the function Ð´(Xi
; Î¸ )
was hardcoded to be either a joint bilateral or joint non-local means
lter with bandwidths provided by a multi-layer perceptron (MLP)
with trained weights, Î¸. Because the lter was xed, the resulting
system lacked the exibility to handle the wide range of Monte
Carlo noise that can be encountered in production environments.
To address this limitation, we consider extending the supervised
learning approach to handle signicantly more complex functions
for Ð´, which results in more exibility while still avoiding overtting.
Thus, we can reduce modeling bias while simultaneously ensuring
the variance of the estimator is kept under control for a suitably
large N. This enables the resulting denoiser to generalize well to
images not used during training.
To do this, we observe that there are three issues inherent to the
supervised learning framework that must be considered to develop
a better MC denoising system:
(i) The function, Ð´, must be exible enough to capture the complex relationship between input data and reference colors
for a wide range of scenarios. In the following section, we
describe how we model Ð´ using deep convolutional networks.
(ii) The choice of loss function, `, is critical. Ideally, the loss
must capture perceptually important dierences between
the estimated and reference color. However, it must also be
easy to evaluate and optimize. We use the absolute value
loss function, `1, (Sec. 5) and explore its benets in Sec. 7.
(iii) In order for our model to be deep yet avoid overtting,
we require a large training dataset, D. Since we require
reference images rendered at high sample counts, obtaining
a large data set is extremely computationally expensive.
Furthermore, in order to generalize well, the network needs
examples that are representative of the various eects to
be denoised. We describe our data in Sec. 5.
4 DEEP CONVOLUTIONAL DENOISING
In this section, we describe our approach to model the denoising
function Ð´ in Eq. (3) with a deep convolutional neural network
(CNN). Since each layer of a CNN applies multiple spatial kernels
with learnable weights that are shared over the entire image space,
they are naturally suited for the denoising task and have indeed been
previously used for traditional image denoising [Xie et al. 2012].
Furthermore, by joining many such layers together with activation
functions, CNNs are able to learn highly nonlinear functions of
the input features, which are important for obtaining high-quality
outputs. Fig. 2 illustrates our entire denoising pipeline. We rst
focus on the ltering core of the denoiserâ€”the network architecture
and the reconstruction lterâ€”and later describe data decomposition
and preprocessing that are specic to the problem of MC denoising.
4.1 Network Architecture
We use deep fully convolutional networks with no fully-connected
layers to keep the number of parameters reasonably low. This reduces the danger of overtting and speeds up both training and
inference. Stacking many convolutional layers together eectively
increases the size of the input receptive eld to capture more context
and long-range dependencies [Simonyan and Zisserman 2014].
In each layer l, the network applies a linear convolution to the
output of the previous layer, adds a constant bias, and then applies
an element-wise nonlinear transformation f
l
(Â·), also known as
the activation function, to produce output z
l = f
l

Wl
âˆ— z
lâˆ’1 + b
l

.
Here, Wl
and b
l
are tensors of weights and biases (the weights in
W are shared appropriately to represent linear convolution kernels),
and z
lâˆ’1
is the output of the previous layer. For the rst layer, we
set z
0 = Xp , which provides the block of per-pixel vectors around
pixel p as input to our CNN.
For all layers, we use rectied linear unit (ReLU) activations,
f
l
(a) = max(0, a), except for the last layer, L, where f
L
(a) = a
ACM Transactions on Graphics, Vol. 36, No. 4, Article 97. Publication date: July 2017.
Kernel-Predicting Convolutional Networks for Denoising Monte Carlo Renderings â€¢ 97:5
(i.e., the identity function). Despite their C1 discontinuity, ReLUs
have been shown to achieve state-of-the-art performance in many
tasks and are known to encourage the (non-convex) optimization
procedure to nd better local minima [Balduzzi et al. 2016].
The weights and biases Î¸ = {(W1
, b
1
), . . . , (WL
, b
L
)}, represent
the trainable parameters of Ð´ for our L-layer CNN. The dimensions
of the weights in each layer, which are xed before training, are
described in Sec. 5.2.
4.2 Reconstruction Methods
In our system, the function Ð´ outputs denoised color values using
one of two possible architectures: a direct-prediction convolutional
network (DPCN) or a novel kernel-prediction convolutional network
(KPCN). We now describe each one in turn.
Direct Prediction Convolutional Network (DPCN). Producing the
denoised image using direct prediction is straightforward. We simply
choose the size of the nal layer of the network to ensure that for
each pixel, p, the corresponding element of the network output,
z
L
p âˆˆ R
3
is the denoised color:
Dcp = Ð´direct(Xp ; Î¸ ) = z
L
p
.
Direct prediction achieves good results. However, we found that
the unconstrained nature and complexity of the problem makes
optimization dicult. The magnitude and variance of the stochastic
gradients computed during training can be large, which slows convergence. For example, in order to obtain good performance, the
DPCN architecture required over a week of training.
Kernel Prediction Convolutional Network (KPCN). Instead of directly outputting a denoised pixel,Dcp , the nal layer of the network
outputs a kernel of scalar weights that is applied to the noisy neighborhood of p to produceDcp . Letting N (p) be the k Ã—k neighborhood
centered around pixel p, the dimensions of the nal layer are chosen
so that the output is z
L
p âˆˆ R
kÃ—k
. Note that the kernel size k is speci-
ed before training along with the other network hyperparameters
(e.g., layer size, CNN kernel size, and so on) and the same weights
are applied to each RGB color channel.
Dening [z
L
p
]q as the q-th entry in the vector obtained by attening z
L
p
, we compute the nal, normalized kernel weights as
wpq =
exp([z
L
p
]q )
P
q
0âˆˆN (p)
exp([z
L
p
]q
0 )
,
and the denoised pixel color as
Dcp = Ð´weighted(Xp ; Î¸ ) =
X
q âˆˆN (p)
cqwpq .
The kernel weights can be interpreted as including a softmax activation function on the network outputs in the nal layer over the
entire neighborhood. This enforces that 0 â‰¤ wpq â‰¤ 1, âˆ€q âˆˆ N (p)
and P
q âˆˆN (p) wpq = 1. Doing this has three specic benets:
(i) It ensures that the nal color estimate always lies within
the convex hull of the respective neighborhood of the input
image. This vastly reduces the search space of output values
as compared to the direct-prediction method and avoids
potential artifacts (e.g., color shifts).
(ii) It ensures the gradients of the error with respect to the
kernel weights are well behaved, which prevents large oscillatory changes to the network parameters caused by the
high dynamic range of the input. Intuitively, the weights
need only encode the relative importance of the neighborhood; the network does not need to learn the absolute scale.
In general, scale-reparameterization schemes have recently
proven to be crucial for obtaining low-variance gradients
and speeding up convergence [Salimans and Kingma 2016].
(iii) It could potentially be used for denoising across layers of
a given frame, a common case in production, by applying
the same reconstruction weights to each component.
We analyze the behavior of both of our proposed architectures in
Sec. 7, observing that both converge to a similar overall error, but at
dierent speeds. For example, with our training data, the weighted
kernel prediction converges roughly 5-6Ã— faster than the direct
reconstruction. Due to its faster convergence, we use the KPCN
architecture for all results and analysis, unless otherwise noted.
4.3 Diuse/Specular Decomposition
Denoising the color output of a MC renderer in a single ltering operation may be prone to overblurring (see Sec. 7). This is because the
various components of the image have dierent noise characteristics and spatial structure, which often leads to conicting denoising
constraints. We mitigate this issue by decomposing the image into
diuse and specular components as in Zimmer et al. [2015]. These
components are then independently preprocessed, ltered, and postprocessed, before recombining them to obtain the nal image, as
illustrated in Figure 2.
Diuse-component Preprocessing. The diuse colorâ€”the outgoing
radiance due to diuse reectionâ€”is well behaved and typically has
small ranges. Thus, training the diuse CNN is stable and the resulting network yields good performance without color preprocessing.
However, in practice, we factor out the noisy albedo produced by the
renderer in the preprocessing step, to have the CNN use the eective irradiance [Zimmer et al. 2015],Hcdiuse = cdiuse  (falbedo + Ïµ ),
where  is an element-wise (Hadamard) division and Ïµ = 0.00316 in
our implementation. This allows for larger ltering kernels, since
the irradiance buer is smoother. Our postprocessing step inverts
this procedure (i.e., multiplies back the albedo), thereby restoring
all texture detail.
Specular-component Preprocessing. Denoising the specular color
is a challenging problem due to the high dynamic range of specular
and glossy reections; the values in one image can span several
orders of magnitude. The large variations and arbitrary correlations in the input make the iterative optimization process highly
unstable. We thus apply a log transform to each color channel of
the input image yieldingHcspecular = log(1 + cspecular), which signi-
cantly reduces the range of color values. This transformation greatly
improves results and avoids artifacts in regions with high dynamic
range (see Sec. 7).
After the two components have been denoised separately, we apply the inverse of the preprocessing transform to the reconstructed
output of each network and compute the nal denoised image,
Dc = (falbedo + Ïµ ) Dcdiuse + exp(Dcspecular) âˆ’ 1, (4)
ACM Transactions on Graphics, Vol. 36, No. 4, Article 97. Publication date: July 2017.
97:6 â€¢ Bako, S. et al.
Fig. 3. Example reference images from our 600 frame training set, sampled
from the full Finding Dory film.
where  is an element-wise (Hadamard) product. To train our system, we pre-train the specular and diuse networks separately on
the specular and diuse references, respectively. Afterwards, we
apply Eq. 4 and ne-tune the complete framework by minimizing
the error of the nal image for additional iterations. This allows us
to recover missing detail and obtain sharper results.
5 EXPERIMENTAL SETUP
5.1 Data
Training a deep neural network requires obtaining a large and representative dataset in order to learn the complex relationship between
input and output while avoiding overtting. For our training set,
we used 600 representative frames sampled from the entire movie
Finding Dory generated using RenderManâ€™s path-tracer (Fig. 3).
Meanwhile, our test set consists of 25 diverse frames from the
lms Cars 3 and Coco, and contain eects such as motion blur,
depth of eld, glossy reections, and global illumination. These
lms signicantly dier in style and content, testing how our system
generalizes to new inputs. For example, the test set includes mostly
outdoor scenes with a wide-range of color palettes that are very
dierent from Finding Dory.
The reference images for training were rendered with 1024 samples per pixel (spp). Although we considered removing the residual
noise from these using standard MC denoisers, we found that the
CNNs performed better when trained on images with uncorrelated
residual noise rather than correlated errors and artifacts introduced
by the additional denoising step. Therefore, we used reference images that, although still contained a small amount of visible noise,
were converged enough to properly train with.
To evaluate our proposed approach, we trained, validated, and
tested on inputs rendered at a xed 128 spp (for production-level
quality) and 32 spp (for pre-visualization). For each scene, the renderer outputs the diuse and specular RGB color buers, cdiuse and
cspecular, the corresponding per-pixel, color variances, Ïƒ
2
diuse and
Ïƒ
2
specular, the feature buers, f, consisting of surface normals (3 channels), albedo (3 channels), depth (1 channel), and the corresponding
per-pixel feature variances, Ïƒf
2
. In our implementation, we convert
variances of three channels to a single channel by computing its
luminance. Thus, we have 2 channels for the color variance (for
diuse and specular) and 3 channels for the feature variance.
As is commonly done in machine learning, we process some of
the raw data to provide the network with more useful features that
facilitate learning and convergence. First, since the depth values can
have arbitrary ranges, we linearly scale it to the range [0, 1] for each
frame. We also preprocess the color buers as described previously
in Sec. 4.3 to getHcdiuse andHcspecular. Finally, we take the gradients
in both x and y directions, Gx and Gy , for all buers, as we found
these highlight important details that facilitate training.
Since we preprocess the color buers, we must apply an appropriate transformation to their variances to make them valid. In general,
if we apply a transformation, h, to a random variable, X, we can
approximate the corresponding transformation on its second moment using a Taylor series expansion: Ïƒh(X ) â‰ˆ (h
0
(ÂµX ))2Ïƒ
2
X
, where
ÂµX and Ïƒ
2
X
are the mean and variance of X, respectively, and h
0
is
the derivative with respect to X. Thus, for the diuse and specular
components, the modied variance is given by:
(HÏƒdiuse)
2 â‰ˆ Ïƒ
2
diuse  (falbedo + Ïµ )
2
,
(HÏƒspecular)
2 â‰ˆ Ïƒ
2
specular  (Hcspecular)
2
. (5)
After this processing, we construct our network input as:
x = {Hc,Gx ({Hc,f}),Gy ({Hc,f}),HÏƒ
2
, Ïƒf
2
},
whereHc and HÏƒ
2
are either diuse or specular.
After processing the data at each pixel, we split the images into
65 Ã— 65 patches that are sampled, shued, and used to train the
network. Although uniform sampling could be used to select the
patches from each frame, we found that this was suboptimal as the
network would be frequently shown simple cases containing smooth
regions that are straightforward to denoise. Instead, we wanted the
network to be exposed to and learn how to handle dicult cases.
To do this, we use the following sampling strategy, inspired by
Gharbi et al. [2016], to get 400 patches for each 1920 Ã— 1080 frame.
We start with dart throwing to nd candidate patches, which we
then prune using a PDF based on the variance of the noisy color
buer and the shading normals. Using the color ensures that we
target regions that have lots of noise, detail, or texture, while using
the normal buer provides examples with geometric complexity.
Finally, to ensure that we provide a proper balance between the easy
and hard cases and avoid biasing the network, we automatically
accept a patch after it has been rejected a certain number of times.
5.2 Training
We use eight hidden layers (i.e., nine total convolutions, so L = 9)
with 100 kernels of 5Ã—5 in each layer for each network. For KPCN, we
used an output kernel with size k = 21. Weights for both the 128 and
32 spp networks were initialized using the Xavier method [Glorot
and Bengio 2010]. Specically, we generate random values from a
uniform distribution with a variance determined by the number of
nodes between layers.
The specular and diuse networks are trained independently using the `1 (absolute value) error metric. We observed that this loss
function oered the best perceptual quality while still being fast
to compute and optimize (see Sec. 7 for additional justication).
The loss for the diuse network is computed between the reconstructed irradiance (i.e., before multiplying with the albedo) and the
ACM Transactions on Graphics, Vol. 36, No. 4, Article 97. Publication date: July 2017.
Kernel-Predicting Convolutional Networks for Denoising Monte Carlo Renderings â€¢ 97:7
Ours Input (32 spp) RDFC (log) APR (log) NFOR (log) LBF-RF (log) Ours Ref. (1K-4K spp)
relative `2 19.21e-3 1.67e-3 2.66e-3 1.29e-3 2.15e-3 1.16e-3
1 âˆ’ SSIM 0.354 0.043 0.058 0.034 0.051 0.032
relative `2 18.88e-3 1.54e-3 1.95e-3 1.24e-3 2.67e-3 0.93e-3
1 âˆ’ SSIM 0.271 0.026 0.028 0.019 0.038 0.016
relative `2 9.28e-3 2.44e-3 3.35e-3 2.12e-3 4.69e-3 2.16e-3
1 âˆ’ SSIM 0.090 0.023 0.030 0.019 0.027 0.019
relative `2 14.92e-3 1.40e-3 1.68e-3 1.12e-2 1.71e-2 0.97e-2
1 âˆ’ SSIM 0.360 0.058 0.059 0.046 0.057 0.045
relative `2 20.31e-4 3.69e-4 5.33e-4 3.10e-4 5.19e-4 2.67e-4
1 âˆ’ SSIM 0.069 0.011 0.016 0.009 0.015 0.008
Fig. 4. We demonstrate favorable results relative to state-of-the-art denoisers on 32 spp production-quality data, oen removing more noise while still keeping
detail and beer preserving highlights. Please see the supplemental material for comparisons with 128 spp data typically used in the final stages of production.
Note that the LBF results shown are run with modifications that can cause suboptimal performance (see text).
albedo-factorized reference image. The loss for the specular CNNs
is computed in the log domain.
The networks were optimized using the ADAM [Kingma and Ba
2014] optimizer in TensorFlow [Abadi et al. 2015] with a learning
rate of 10âˆ’5
and mini-batches of size 5. Each network is pre-trained
for approximately 750K iterations over the course of ~1.5 days on
an Nvidia Quadro M6000 GPU. Afterwards, the system is combined
and ne-tuned (Sec. 4.3) for another ~0.5 days or 250K iterations.
6 RESULTS
To evaluate our method, we compare our results to a range of stateof-the-art methods: RDFC [Rousselle et al. 2013], APR [Moon et al.
2016], NFOR [Bitterli et al. 2016], and LBF [Kalantari et al. 2015]. In
the supplemental, we also compare against the RenderMan denoiser,
which was used during the production of the lms in the training/test sets. We use four metrics to evaluate the results: `1, relative
`1, relative `2 [Rousselle et al. 2011], and Structural Similarity Index
(SSIM) [Wang et al. 2004] (see supplemental for a description of how
these are computed). For conciseness, we report only relative `2 and
SSIM in the paper, as they are the most commonly used. See our
supplemental material for full resolution results at 16, 32, and 128
samples per pixel (spp), all metrics with heat maps, and a web-based
interactive viewer that allows for inspection of the results.1
All denoisers are given the same inputs: the color buer and the
albedo, normal, and depth buers corresponding to the rst ray
intersection. Note that we save the feature buers at the rst diuse
intersection in order to handle specular regions with little useful
information (e.g., glass). Previous methods gave better results when
run with some of our preprocessing steps, so we report them like
this in the paper. In particular, we applied all methods on top of our
diuse/specular decomposition, including the albedo divide for the
diuse component and the log transform of the specular component. Interestingly, the log transform often signicantly increased
the robustness of these denoisers and resulted in much fewer halo
1
Supplemental materials can be found here: https://doi.org/10.7919/F4057CVT.
ACM Transactions on Graphics, Vol. 36, No. 4, Article 97. Publication date: July 2017.
97:8 â€¢ Bako, S. et al.
0%
10%
20%
30%
40%
50%
60%
w/o log transform
w/ log transform
RDFC APR NFOR LBF-RF KPCN
0%
10%
20%
30%
40%
50%
60%
RDFC APR NFOR LBF-RF KPCN RDFC APR NFOR LBF-RF KPCN 32 spp 128 spp
(a) relative `2 (b) `1 (c) 1âˆ’SSIM
Fig. 5. Average performance of RDFC, APR, NFOR, LBF-RF, and our KPCN
across test scenes for 32 spp (top) and 128 spp (boom) inputs. The values
are relative to the noisy input and expressed as percentages (%); lower
is beer. The dark-colored bars show the performance of prior art with
decomposition, irradiance factorization, but without log-transforming the
specular component. The light-colored bars show performance with the log
transform. For increased robustness, the relative `2 error was computed as
a trimmed mean, removing 0.01% of the best and the worst pixels per image.
artifacts (see our supplemental material for results using the raw
specular component).
For all the denoisers, we multiply in the albedo buer extracted
from a separate, higher sampling rate pass to obtain the nal image.
In practice, this noise-free albedo could be generated from either a
fast high-sample count render that ignores illumination calculations
or alternatively from a separate denoising process (e.g., preltering).
Furthermore, for all methods, we currently ignore the alpha channel
during the ltering process, so to generate the nal image, we simply
use the original alpha and zero out the appropriate regions to avoid
color bleeding. Finally, for the production data we used, RenderMan
has been congured to send out 8 shadow rays at the rst bounce
of each sample to get a better estimate of the direct illumination.
Our noisy renderings use correlated samples because of low discrepancy sampling, so we cannot directly estimate an accurate
variance of the per-pixel sample mean. Instead, we instrumented
RenderMan to output the two-buer variance used in previous
works [Rousselle et al. 2012] to properly evaluate RDFC, NFOR, and
APR on our test data. Note that the training/test data for our system
has the raw sample variances directly from the renderer, rather than
the two-buer variances used in the aforementioned methods.
All methods used the default settings suggested by the authors,
except for LBF, where we trained the network on our own data using
a joint non-local means lter back-end and the MLP architecture
described in the original paper. Since our training dataset does not
have the two-buer variance expected by LBF, their system cannot
pre-lter the features. Thus, for fairer comparisons, we substitute
the pre-ltered features with the relatively noise-free ones of the
reference image and denote it as LBF-RF (for reference features).
However, there are still some distinct dierences from the original implementation that cause LBF to run suboptimally. First, our
dataset does not provide some of the primary features expected by
LBF, namely the secondary albedo and direct visibility, which are
useful guiding features for the lter. To compensate for this missing
data, we instead replace the LBF secondary features corresponding
to these two primary features with features calculated from the
noisy color buers. However, as observed in their paper, using such
buers leads to overtting and residual noise. These issues are further exacerbated by substituting the noisy sample mean variance
into the joint non-local means lter instead of the ltered two-buer
variance expected by LBF. As a result, the LBF results shown here
tend to leave excessive residual noise.
As described in Sec. 5, we trained our CNN on 600 frames from
the lm Finding Dory, all rendered at a uniform sampling rate of 32
and 128 spp with references at 1024 spp. We trained two networks,
one for each sampling rate, and applied them to the test data with
the corresponding sampling rate. In Fig. 4, we show a subset of
results from our test set containing 25 frames from the lms Cars
3 and Coco on 32 spp data (see supplemental for all results at both
sampling rates).
Overall, we perform as well or better than state-of-the-art techniques both perceptually and quantitatively. For example, rows 1,
4, and 5 of Fig. 4 show how previous methods have residual noise
in the car decals, childâ€™s face, and car headlight, respectively, while
our approach removes the noise and still preserves detail. Furthermore, our approach generates a smooth result on the glass of row
2 and keeps the energy of the strong specular highlight in row 3.
Meanwhile, the other approaches tend to introduce lter artifacts
and lose energy in bright regions.
Figure 5 shows a comparison of the average performance of each
method across all test scenes with respect to each error metric for
both 32 and 128 spp. We observe that our network consistently
improves over state of the art across all error metrics shown. In
Fig. 6, we demonstrate the exibility of our method by processing
inputs at 16 spp with our network trained on 32 spp data. As shown,
despite being trained on a higher sampling rate, our network is
able to successfully extrapolate to this data while still improving on
the state-of-the-art methods. In particular, the previous approaches
tend to leave excessive residual noise relative to our approach along
the edges of the cables.
To facilitate future comparisons and demonstrate our networkâ€™s
ability to perform well on noisier data from a dierent rendering
system, we provide results in Fig. 7 on publicly available Tungsten scenes [Bitterli 2016] and compare our approach to a baseline
method, NFOR [Bitterli et al. 2016]. In particular, the results show
slight residual noise in the NFOR result even at 128 spp, while our
approach more closely resembles the reference. A similar gure in
concurrent work [Chaitanya et al. 2017] allows readers to see the
relative improvements over the baseline, facilitating comparisons
of these two systems.
Note that to produce these results, we trained our system on a set
of Tungsten training scenes (see Sec. 7 for results with our original
training). Specically, we took 8 Tungsten scenes not in our test set
and randomly modied them in various ways, including swapping
materials, camera parameters, and environment maps to generate
1484 unique training scenes. Please see the supplemental for a list
of the original Tungsten scenes used to generate the training set.
ACM Transactions on Graphics, Vol. 36, No. 4, Article 97. Publication date: July 2017.
Kernel-Predicting Convolutional Networks for Denoising Monte Carlo Renderings â€¢ 97:9
Ours Input (16 spp) RDFC (log) APR (log) NFOR (log) LBF-RF (log) Ours Ref. (1K spp)
relative `2 7.03e-3 1.86e-3 2.10e-3 1.91e-3 1.93e-3 0.99e-3
1 âˆ’ SSIM 0.147 0.032 0.038 0.032 0.031 0.023
Fig. 6. Our network trained on 32 spp data and tested on 16 spp data still performs well relative to other approaches. This demonstrates that our technique
can successfully extrapolate to other sampling rates. See supplemental for additional results at 16 spp.
Ours Input (128 spp) NFOR (log) Ours Ref. (32K spp)
relative `2 29.15e-3 0.90e-3 0.69e-3
1 âˆ’ SSIM 0.562 0.019 0.017
relative `2 38.57e-3 1.12e-3 0.92e-3
1 âˆ’ SSIM 0.552 0.025 0.024
relative `2 77.82e-3 2.92e-3 2.50e-3
1 âˆ’ SSIM 0.633 0.041 0.038
Fig. 7. We retrained our network on data rendered with the Tungsten path tracer and compared with a baseline approach (NFOR) on scenes from Bierli et al.
[2016] using the publicly available lighting and camera parameters. See the concurrent work of Chaitanya et al. [2017] for a similar figure.
In terms of timing, for an HD image of 1920Ã—1080, our network
takes about 12 seconds to evaluate and output a full denoised image.
For comparison, the timings for the other GPU-based approaches
are approximately 10 seconds for RDFC, 10-20 seconds for APR, and
20 seconds for LBF. The CPU version of NFOR takes 4-6 minutes.
It is worth noting that these images take about 100 core hours to
render at 128 spp, so no additional samples can be rendered in the
time it takes to evaluate any of the denoisers.
7 ANALYSIS
In this section, we analyze the various design choices made in our
network architecture using hold-out frames from Finding Dory and
test frames from Cars 3. We begin by examining the choice of loss
function, a crucial aspect of our design as it determines what the
network deems important. For MC denoising, we ideally want a loss
function that reects the perceptual quality of the image relative to
the reference. To evaluate the behavior of various error metrics, we
optimize the network with each and evaluate their performance on
held-out training data from Finding Dory and validation data from
Cars 3. We evaluate ve common metrics: `1, relative `1, `2, relative
`2, and SSIM, when optimizing for each in turn. Fig. 8 shows that
the network trained with the `1 metric consistently has the lowest
error across all ve metrics for both datasets. Due to this robustness,
we chose the `1 error metric for our system.
It is interesting to note that sometimes the network optimized on
a given error is not always the best performing one. For example, the
ACM Transactions on Graphics, Vol. 36, No. 4, Article 97. Publication date: July 2017.
97:10 â€¢ Bako, S. et al.
0 100K 200K 300K 400K 500K 600K 700K
iterations
`1 loss (log)
`1
relative `1
`2
relative `2
SSIM
0 100K 200K 300K 400K 500K 600K 700K
iterations
relative
`1 loss (log)
`1
relative `1
`2
relative `2
SSIM
0 100K 200K 300K 400K 500K 600K 700K
iterations
`
2 loss (log)
`1
relative `1
`2
relative `2
SSIM
0 100K 200K 300K 400K 500K 600K 700K
iterations
relative
`
2 loss (log)
`1
relative `1
`2
relative `2
SSIM
0 100K 200K 300K 400K 500K 600K 700K
iterations
SSIM loss (log)
`1
relative `1
`2
relative `2
SSIM
(a) `1 (b) relative `1 (c) `2 (d) relative `2 (e) SSIM
Fig. 8. Here we show convergence plots of networks optimized with common error metrics evaluated on hold-out data from Finding Dory. For example,
(a) shows the `1 error of the dataset using networks trained on `1, relative `1, `2, relative `2, and SSIM. The network trained with `1 consistently has the best
performance across all the error metrics tested. This behavior carries over to our validation set of Cars 3 images (see supplemental materials).
25 50 75 100 125 150 175 200
time [h]
`1 loss (log)
DPCN
KPCN
25 50 75 100 125 150 175 200
time [h]
`1 loss (log)
DPCN
KPCN
(a) Diuse (b) Specular
Fig. 9. Comparison of optimization speed between the DPCN and KPCN
architectures. Although both approaches converge to a similar error on the
Cars 3 validation set, the KPCN system converges 5â€“6Ã— faster.
network trained on `1 error performs better on `2 than the network
optimized on `2. One possible reason for this is that `2 is sensitive
to outliers, such as reies, or extremely bright specular highlights
that signicantly contribute to the error. Trying to compensate for
these regions will sacrice performance elsewhere, while networks
trained on dierent losses are more robust to outliers.
Figure 9 compares the validation loss between the DPCN and
KPCN reconstruction schemes as a function of hours trained for both
the specular and diuse networks. We stop training the KPCN after
50 hours and show the average loss during the last 10% of training
with the horizontal, dashed line. We observed that the convergence
of the DPCN is slower with considerably higher variance, on average
requiring 5-6Ã— longer to reach the same loss value. Therefore, by
imposing reasonable constraints on the network output, we can
greatly speed up training without sacricing average performance.
Since there has been previous work in using machine learning for
natural image denoising, we evaluated the performance of naÃ¯vely
applying a CNN to the problem of MC denoising. Specically, we
train on the raw color buer (without decomposition or the albedo
divide) and directly output the denoised color. 2 As shown in Fig. 10,
such a network produces overblurred results since it has no features/information to allow it to distinguish between scene noise and
detail. Furthermore, since the input and output have high dynamic
range, it cannot properly handle bright regions and causes ringing
and color artifacts around highlights. Moreover, working in the
HDR domain causes instability in the network weights making it
dicult to train properly.
Next, we evaluate the eect of the various additions to our framework that alleviate the aforementioned issues of a vanilla CNN.
2We use the same hyperparameters as reported for our nal architecture: 8 hidden
layers of 5Ã—5Ã—100.
First, we explored the eect of including extra features as input.
One signicant advantage over deep networks used in the denoising of photographs is that we can utilize additional information
output by the rendering system including shading normals, depth,
and albedo. Thus, we trained our architecture with and without
our additional features (Sec. 5). The network trained only on the
color buer cannot dierentiate between scene detail and noise, so
it overblurs compared to our full approach (see Fig. 11).
We found that training with high dynamic range data introduced
many issues. Namely, the wide range of values for both the inputs
and outputs created instability in the weights and made training
dicult. Fig. 12 shows how using the log transform of the color
buer and its corresponding transformed variance (Eq. 5) reduces
artifacts in bright regions. Interestingly, we found that working in
the log domain had benets for previous denoising techniques as
well, reducing halos and ringing issues (see the supplemental for
results of previous approaches with and without the log transform).
Both the diuse/specular decomposition and albedo factorization
also improve our method signicantly. The decomposition allows
the networks to separately handle the fundamentally dierent diffuse and specular noise. Furthermore, by dividing out the albedo
from the diuse illumination and thereby denoising the eective
irradiance, we can preserve texture details more easily. We retrained
our system without the albedo divide and observed overblurring. For
example, Fig. 13 shows how the decals on the car become overblurred
and illegible without the albedo divide. Moreover, if we perform the
albedo divide without the decomposition, the network preserves
detail but has clear artifacts in specular regions. In this experiment,
we still perform the log transform to handle the high dynamic range.
Figure 14 further demonstrates the ability of our network to generalize to new scenes with dierent artistic styles than are present
in our training set. This is a frame from the photorealistic short lm
Piper denoised by our network without additional training or modi-
cation (i.e., trained only on Finding Dory). This suggests that the
network is not overtting to a specic style, lm, or noise pattern
and instead learns a robust relationship between input and output
enabling good performance on a wide variety of data.
There are various inherent limitations of our learning-based approach, however. First, our results can lose scene detail that is not
properly captured by our input features and that is not present in
our training set. For example, in the top row of Fig. 15, we show
how the lines on the jumbo screen are removed because they are
not in the auxiliary features and the network mistakes them for
ACM Transactions on Graphics, Vol. 36, No. 4, Article 97. Publication date: July 2017.
Kernel-Predicting Convolutional Networks for Denoising Monte Carlo Renderings â€¢ 97:11
Ours Input (32 spp) Vanilla CNN Ours Ref. (1K spp)
Fig. 10. We naively apply a CNN for MC denoising using only the unprocessed color buer as input and directly outpuing the denoised image. The high
dynamic range data creates color artifacts around highlights (top row), while the missing additional features results in overblurring of detail (boom row).
Ours Input (32 spp) w/o Features w/ Features Ref. (2K spp)
Fig. 11. When training using only the diuse/specular color buers without additional features, the network overblurs detail.
Ours Input (32 spp) w/o Log w/ Log Ref. (2K spp)
Fig. 12. When we train with high dynamic range images, we observe artifacts in regions with large-valued specular highlights. Our full approach with the log
and corresponding transformed variance handles these diicult cases beer.
Ours Input (32 spp) w/o Decomposition,
w/o Albedo divide
w/ Decomposition,
w/o Albedo divide
w/o Decomposition,
w/ Albedo divide
w/ Decomposition,
w/ Albedo divide Ref. (2K spp)
Fig. 13. Retraining our network without the diuse/specular decomposition or albedo factorization results in overblurred textures, such as these illegible
car decals. Using the decomposition without the albedo divide continues to overblur (top row). On the other hand, doing the albedo divide without the
decomposition creates artifacts in specular regions (boom row). Our full approach preserves the text clearly and closely resembles the reference.
scene noise. Also, since such patches were not present in the training dataset, the network cannot resolve them using only the color
buer. However, this could be potentially alleviated by additional
training on similar examples. Likewise, examples of all distributed
eects from the test set should be shown during training, otherwise
the network cannot properly denoise them. For example, volumetric
eects with lots of ne detail, such as re or smoke, that were not
in the training set are typically overblurred by our system (second
row of Fig. 15).
Another limitation occurs when applying our method to a different rendering system than the one it was trained on. The third
row of Fig. 15 shows the results of using the network trained with
Finding Dory data from RenderMan on test data from the Tungsten
renderer. Although both renderers output the same features, there
are inevitable dierences (e.g., dynamic range and noise levels) that
can cause artifacts. These issues largely disappear when training on
the Tungsten data, although our approach still generates artifacts
when the input has severe noise, such as with the 32 spp scene
shown in the last row of Fig. 15.
ACM Transactions on Graphics, Vol. 36, No. 4, Article 97. Publication date: July 2017.
97:12 â€¢ Bako, S. et al.
Ours Input (32 spp) Ours Ref. (1K spp)
Fig. 14. We demonstrate how our network is able to denoise a photorealistic frame from the short film Piper, which significantly diers from the training data,
Finding Dory. Note that even at low sampling rates, our network generalizes well and produces high-quality denoised results.
Ours Input (32 spp) NFOR (log) Ours Ref. (2K spp)
Ours Input (32 spp) NFOR (log) Ours Ref. (8K spp)
Ours Input (128 spp) w/o Retraining w/ Retraining (Ours) Ref. (32K spp)
Ours Input (32 spp) NFOR (log) Ours Ref. (32K spp)
Fig. 15. We demonstrate various limitations of our approach. When the input features fail to capture important scene detail, the network will mistake it for
noise and try to remove it (top row). Examples of fire were not used in training, so our method tends to overblur these cases (second row). Applying a network
trained on data from a dierent rendering system will cause artifacts due to inherent dierences in noise levels, ranges, and sampling strategies. The results
are significantly improved if the network is instead trained on data from the new rendering system (third row). However, even when trained on this data, the
network struggles with extremely noisy inputs (boom row).
8 FUTURE WORK AND CONCLUSIONS
Although we have demonstrated a robust, learning-based MC denoising algorithm in this paper, there are many design decisions that
could be explored more extensively to further improve performance.
To facilitate this exploration and enable others to run our system
on publicly available Tungsten scenes, we will release the code and
trained weights to the community.
The rst potential topic to investigate is the choice of error metric.
Often, perceptually important features are not captured by any
of the standard loss metrics which also behave quite dierently
from each other. We see notable examples of this in Sec. 6 and
Sec. 7. This poses an especially important problem during training. A
more thorough investigation of perceptual loss functions is required,
which would improve both network training and lead to a more
principled perceptual evaluation of results.
Furthermore, we presented a simple sampling approach for selecting important patches from each image used in training. Although
this helped performance, our approach is far from optimal. One can
imagine using other features and metrics to better sample patches
ACM Transactions on Graphics, Vol. 36, No. 4, Article 97. Publication date: July 2017.
Kernel-Predicting Convolutional Networks for Denoising Monte Carlo Renderings â€¢ 97:13
and allow the network to converge faster or even learn more complicated relationships.
Our networkâ€™s hyperparameters are also not optimal. We explored
various layer numbers/sizes and kernel sizes to nd settings that
work well, but a more thorough search through the parameter space
could reveal better ones. Dierent architectures and concepts might
also yield improved performance. We explored the use of recurrent
and residual connections [Yang et al. 2016; He et al. 2016], but found
little benet. However, these could be potentially useful tools to explore much deeper networks that improve performance yet keep the
number of model parameters tractable. Moreover, generative models, such as variational autoencoders [Kingma and Welling 2013],
and generative adversarial networks have shown great promise for
natural image super-resolution and denoising [Ledig et al. 2016].
Although scaling to high-resolution images presents a large computational hurdle for these methods, it would be an interesting avenue
for future research.
Finally, we demonstrated results for denoising only a single image
at a time, but it would be useful to handle animated sequences as well.
This extension is non-trivial and involves further exploration of the
architecture and design to be able to preserve temporal coherency
across neighboring denoised frames. For example, the concurrent
work of Chakravarty et al. [2017] focuses on denoising sequences
at interactive rates.
In summary, we have presented the rst successful step towards
practically using deep convolutional networks for denoising Monte
Carlo rendered images in production environments. Specically,
we demonstrated that a deep learning approach can recognize the
fundamental, underlying relationship between the noisy and reference data without overtting, all while still being able to withstand
the strict production demands on quality. Although it uses a relatively straightforward architecture, our solution is fast, robust,
stable to train/evaluate, and it performs favorably with respect to
state-of-the-art denoising algorithms.