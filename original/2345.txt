1. Introduction
1.1. Sample complexity and VC dimension
Machine learning is one of the most successful parts of AI, with impressive practical applications in areas ranging from image processing and speech recognition, to even beating
Go champions. Its theoretical aspects have been deeply studied, revealing beautiful structure and mathematical characterizations of when (efficient) learning is or is not possible in
various settings.
1.1.1. The PAC setting
Leslie Valiant (1984)’s Probably Approximately Correct (PAC) learning model gives a precise complexity-theoretic definition of what it means for a concept class to be (efficiently)
learnable. For simplicity we will (without loss of generality) focus on concepts that are
Boolean functions, c : {0, 1}
n → {0, 1}. Equivalently, a concept c is a subset of {0, 1}
n
,
namely {x : c(x) = 1}. Let C ⊆ {f : {0, 1}
n → {0, 1}} be a concept class. This could for
example be the class of functions computed by disjunctive normal form (DNF) formulas of
a certain size, or Boolean circuits or decision trees of a certain depth.
The goal of a learning algorithm (the learner) is to probably approximate some unknown
target concept c ∈ C from random labeled examples. Each labeled example is of the form
(x, c(x)) where x is distributed according to some unknown distribution D over {0, 1}
n
.
After processing a number of such examples (hopefully not too many), the learner outputs
some hypothesis h. We say that h is ε-approximately correct (w.r.t. the target concept c) if
its error probability under D is at most ε: Prx∼D[h(x) 6= c(x)] ≤ ε. Note that the learning
phase and the evaluation phase (i.e., whether a hypothesis is approximately correct) are
according to the same distribution D—as if the learner is taught and then tested by the
same teacher. An (ε, δ)-learner for the concept class C is one whose hypothesis is probably
approximately correct:
For all target concepts c ∈ C and distributions D:
Pr[the learner’s output h is ε-approximately correct] ≥ 1 − δ,
where the probability is over the sequence of examples and the learner’s internal randomness.
Note that we leave the learner the freedom to output an h which is not in C . If always
h ∈ C , then the learner is called a proper PAC-learner.
Of course, we want the learner to be as efficient as possible. Its sample complexity is the
worst-case number of examples it uses, and its time complexity is the worst-case running
time of the learner. In this paper we focus on sample complexity. This allows us to ignore
technical issues of how the runtime of an algorithm is measured, and in what form the
hypothesis h is given as output by the learner.
The sample complexity of a concept class C is the sample complexity of the most efficient
learner for C . It is a function of ε, δ, and of course of C itself. One of the most fundamental
results in learning theory is that the sample complexity of C is tightly determined by a
combinatorial parameter called the VC dimension of C , due to and named after Vapnik
and Chervonenkis (1971). The VC dimension of C is the size of the biggest S ⊆ {0, 1}
n
that can be labeled in all 2|S| possible ways by concepts from C : for each sequence of |S|
2
Optimal Quantum Sample Complexity of Learning Algorithms
binary labels for the elements of S, there is a c ∈ C that has that labeling.1 Knowing
this VC dimension (and ε, δ) already tells us the sample complexity of C up to constant
factors. Blumer et al. (1989) proved that the sample complexity of C is lower bounded by
Ω(d/ε + log(1/δ)/ε), and they proved an upper bound that was worse by a log(1/ε)-factor.
In very recent work, Hanneke (2016) (improving on Simon (2015)) got rid of this log(1/ε)-
factor for PAC learning,2
showing that the lower bound of Blumer et al. is in fact optimal:
the sample complexity of C in the PAC setting is
Θ
d
ε
+
log(1/δ)
ε

. (1)
1.1.2. The agnostic setting
The PAC model assumes that the labeled examples are generated according to a target
concept c ∈ C . However, in many learning situations that is not a realistic assumption, for
example when the examples are noisy in some way or when we have no reason to believe
there is an underlying target concept at all. The agnostic model of learning, introduced
by Haussler (1992) and Kearns et al. (1994), takes this into account. Here, the examples
are generated according to a distribution D on {0, 1}
n+1. The error of a specific concept
c : {0, 1}
n → {0, 1} is defined to be errD(c) = Pr(x,b)∼D[c(x) 6= b]. When we are restricted
to hypotheses in C , we would like to find the hypothesis that minimizes errD(c) over all
c ∈ C . However, it may require very many examples to do that exactly. In the spirit of the
PAC model, the goal of the learner is now to output an h ∈ C whose error is at most an
additive ε worse than that of the best (= lowest-error) concepts in C .
Like in the PAC model, the optimal sample complexity of such agnostic learners is
tightly determined by the VC dimension of C : it is
Θ
 d
ε
2
+
log(1/δ)
ε
2

, (2)
where the lower bound was proven by Vapnik and Chervonenkis (1974) (see also Simon
(1996)), and the upper bound was proven by Talagrand (1994). Shalev-Shwartz and BenDavid (2014) call Eq. (1) and Eq. (2) the “Fundamental Theorem of PAC learning.”
1.2. Our results
In this paper we are interested in quantum sample complexity. Here a quantum example
for some concept c : {0, 1}
n → {0, 1}, according to some distribution D, corresponds to an
(n + 1)-qubit state
X
x∈{0,1}n
p
D(x)|x, c(x)i.
In other words, instead of a random labeled example, an example is now given by a coherent
quantum superposition where the square-roots of the probabilities become the amplitudes.3
1. Such an S is said to be shattered by C .
2. Hanneke’s learner is not proper, meaning that its hypothesis h is not always in C . It is known that the
extra log(1/ε)-factor is sometimes necessary for proper PAC learners.
3. We could allow more general quantum examples P
x∈{0,1}n αx|x, c(x)i, where we only require |αx|
2 =
D(x). However, that will not affect our results since our lower bounds apply to quantum examples where
3
Arunachalam and de Wolf
This model was introduced by Bshouty and Jackson (1999), who showed that DNF formulas
are learnable in polynomial time from quantum examples when D is uniform. For learning
DNF under the uniform distribution from classical examples, Verbeurgt (1990) gave the
best upper bound of quasipolynomial time. With the added power of “membership queries,”
where the learner can actively ask for the label of any x of his choice, DNF formulas are
known to be learnable in polynomial time under uniform D by a result of Jackson (1997), but
without membership queries polynomial-time learnability is a longstanding open problem
(see Daniely and Shalev-Shwartz (2016) for a recent hardness result) .
How reasonable are examples that are given as a coherent superposition rather than as
a random sample? They may seem unreasonable a priori because quantum superpositions
seem very fragile and are easily collapsed by measurement, but if we accept the “church
of the larger Hilbert space” view on quantum mechanics, where the universe just evolves
unitarily without any collapses, then they may become more palatable. It is also possible
that the quantum examples are generated by some coherent quantum process that acts like
the teacher.
How many quantum examples are needed to learn a concept class C of VC dimension d?
Since a learner can just measure a quantum example in order to obtain a classical example,
the upper bounds on classical sample complexity trivially imply the same upper bounds
on quantum sample complexity. But what about the lower bounds? Are there situations
where quantum examples are more powerful than classical? Indeed there are. We already
mentioned the results of Bshouty and Jackson (1999) for learning DNF under the uniform
distribution without membership queries. Another good example is the learnability of the
concept class of linear functions over F2, C = {c(x) = a · x : a ∈ {0, 1}
n}, again under the
uniform distribution D. It is easy to see that a classical learner needs about n examples to
learn an unknown c ∈ C under this D. However, if we are given one quantum example
X
x∈{0,1}n
p
D(x)|x, c(x)i =
1
√
2
n
X
x∈{0,1}n
|x, a · xi,
then a small modification of the Bernstein and Vazirani (1997) algorithm can recover a
(and hence c) with probability 1/2. Hence O(1) quantum examples suffice to learn c exactly,
with high probability, under the uniform distribution. Atıcı and Servedio (2009) used similar
ideas to learning k-juntas (concepts depending on only k of their n variables) from quantum
examples under the uniform distribution. However, PAC learning requires a learner to learn
c under all possible distributions D, not just the uniform one. The success probability of
the Bernstein-Vazirani algorithm deteriorates sharply when D is far from uniform, but that
does not rule out the existence of other quantum learners that use o(n) quantum examples
and succeed for all D.
Our main result in this paper is that quantum examples are not actually more powerful
than classical labeled examples in the PAC model and in the agnostic model: we prove
that the lower bounds on classical sample complexity of Eq. (1) and Eq. (2) hold for quantum examples as well. Accordingly, despite several distribution-specific speedups, quantum
examples do not significantly reduce sample complexity if we require our learner to work
we know the amplitudes are square-rooted probabilities. Adding more degrees of freedom to quantum
examples does not make learning easier.
4
Optimal Quantum Sample Complexity of Learning Algorithms
for all distributions D. This should be contrasted with the situation when considering the
time complexity of learning. Servedio and Gortler (2004) considered a concept class (already considered in the literature by Kearns and Valiant (1994)) that can be PAC-learned
in polynomial time by a quantum computer, even with only classical examples, but that
cannot be PAC-learned in polynomial time by a classical learner unless Blum integers can
be factored in polynomial time (which is widely believed to be false).
Earlier work on quantum sample complexity had already gotten close to extending the
lower bound of Eq. (1) to PAC learning from quantum examples. Atıcı and Servedio (2005)
first proved a lower bound of Ω(√
d/ε + d + log(1/δ)/ε), which was subsequently improved
by Zhang (2010) to
Ω
d
1−η
ε
+ d +
log(1/δ)
ε

for arbitrarily small constant η > 0. (3)
Here we optimize these bounds, removing the η and achieving the optimal lower bound for
quantum sample complexity in the PAC model (Eq. (1)).
We also show that the lower bound (Eq. (2)) for the agnostic model extends to quantum
examples. As far as we know, in contrast to the PAC model, no earlier results were known
for quantum sample complexity in the agnostic model.
We have two different proof approaches, which we sketch below.
1.2.1. An information-theoretic argument
In Section 3 we give a fairly intuitive information-theoretic argument that gives optimal
lower bounds for classical sample complexity, and that gives nearly-optimal lower bounds
for quantum sample complexity. Let us first see how we can prove the classical PAC lower
bound of Eq. (1). Suppose S = {s0, s1, . . . , sd} is shattered by C (we now assume VC
dimension d + 1 for ease of notation). Then we can consider a distribution D that puts
probability 1 − 4ε on s0 and probability 4ε/d on each of s1, . . . , sd.
4 For every possible
labeling (`1 . . . `d) ∈ {0, 1}
d of s1, . . . , sd there will be a concept c ∈ C that labels s0 with 0,
and labels si with `i for all i ∈ {1, . . . , d}. Under D, most examples will be (s0, 0) and
hence give us no information when we are learning one of those 2d
concepts. Suppose we
have a learner that ε-approximates c with high probability under this D using T examples.
Informally, our information-theoretic argument has the following three steps:
1. In order to ε-approximate c, the learner has to learn the c-labels of at least 3/4
of the s1, . . . , sd (since together these have 4ε of the D-weight, and we want an εapproximation). As all 2d
labelings are possible, the T examples together contain
Ω(d) bits of information about c.
2. T examples give at most T times as much information about c as one example.
3. One example gives only O(ε) bits of information about c, because it will tell us one of
the labels of s1, . . . , sd only with probability 4ε (and otherwise it just gives c(s0) = 0).
4. We remark that the distributions used here (and later in the agnostic setting) for proving lower bounds
on quantum sample complexity have been used in the literature before for analyzing classical sample
complexity.
5
Arunachalam and de Wolf
Putting these steps together implies T = Ω(d/ε).5 This argument for the PAC setting
is similar to an algorithmic-information argument of Apolloni and Gentile (1998) and an
information-theoretic argument for variants of the PAC model with noisy examples by Gentile and Helmbold (2001).
As far as we know, this type of reasoning has not yet been applied to the sample
complexity of agnostic learning. To get good lower bounds there, we consider a set of
distributions Da, indexed by d-bit string a. These distributions still have the property
that if a learner gets ε-close to the minimal error, then it will have to learn Ω(d) bits of
information about the distribution (i.e., about a). Hence the first step of the argument
remains the same. The second step of our argument also remains the same, and the third
step shows an upper bound of O(ε
2
) on the amount of information that the learner can get
from one example. This then implies T = Ω(d/ε2
). We can also reformulate this for the
case where we want the expected additional error of the hypothesis over the best classifier
in C to be at most ε, which is how lower bounds are often stated in learning theory. We
emphasize that our information-theoretic proof is simpler than the proofs in Anthony and
Bartlett (2009); Audibert (2009); Shalev-Shwartz and Ben-David (2014); Kontorovich and
Pinelis (2016).
This information-theoretic approach recovers the optimal classical bounds on sample
complexity, but also generalizes readily to the quantum case where the learner gets T
quantum examples. To obtain lower bounds on quantum sample complexity we use the same
distributions D (now corresponding to a coherent quantum state) and basically just need to
re-analyze the third step of the argument. In the PAC setting we show that one quantum
example gives at most O(ε log(d/ε)) bits of information about c, and in the agnostic setting
it gives O(ε
2
log(d/ε)) bits. This implies lower bounds on sample complexity that are only
a logarithmic factor worse than the optimal classical bounds for the PAC setting (Eq. (1))
and the agnostic setting (Eq. (2)). This is not quite optimal yet, but already better than
the previous best known lower bound (Eq. (3)). The logarithmic loss in step 3 is actually
inherent in this information-theoretic argument: in some cases a quantum example can give
roughly ε log d bits of information about c, for example when c comes from the concept class
of linear functions.
1.2.2. A state-identification argument
In order to get rid of the logarithmic factor we then try another proof approach, which
views learning from quantum examples as a quantum state-identification problem: we are
given T copies of the quantum example for some concept c and need to ε-approximate c
from this. In order to render ε-approximation of c equivalent to exact identification of c,
we use good linear error-correcting codes, restricting to concepts whose d-bit labeling of
the elements of the shattered set s1, . . . , sd corresponds to a codeword. We then have 2Ω(d)
possible concepts, one for each codeword, and need to identify the target concept from a
quantum state that is the tensor product of T identical quantum examples.
State-identification problems have been well studied, and many tools are available for analyzing them. In particular, the so-called “Pretty Good Measurement” (PGM, also referred
to as “square root measurement” by Eldar and Forney Jr (2001)) is a specific measurement
5. The other part of the lower bound of Eq. (1) does not depend on d and is fairly easy to prove.
6
Optimal Quantum Sample Complexity of Learning Algorithms
that one can always use for state identification, and whose success probability is no more
than quadratically worse than that of the very best measurement (even better, in our application the PGM is the optimal measurement). In Section 4 we use Fourier analysis to give
an exact analysis of the average success probability of the PGM on the state-identification
problems that come from both the PAC and the agnostic model. This analysis could be
useful in other settings as well. Here it implies that the number of quantum examples, T,
is lower bounded by Eq. (1) in the PAC setting, and by Eq. (2) in the agnostic setting.
Using the Pretty Good Measurement, we are also able to prove lower bounds for PAC
learning under random classification noise, which models the real-world situation that the
learning data can have some errors. Classically in the random classification noise model
(introduced by Angluin and Laird (1988)), instead of obtaining labeled examples (x, c(x))
for some unknown c ∈ C , the learner obtains noisy examples (x, bx), where bx = c(x) with
probability 1 − η and bx = 1 − c(x) with probability η, for some noise rate η ∈ [0, 1/2).
Similarly, in the quantum learning model we could naturally define a noisy quantum example
as an (n + 1)-qubit state
X
x∈{0,1}n
p
(1 − η)D(x)|x, c(x)i +
p
ηD(x)|x, 1 − c(x)i.
Using the PGM, we are able to show that the quantum sample complexity of PAC learning
a concept class C under random classification noise is:
Ω
 d
(1 − 2η)
2ε
+
log(1/δ)
(1 − 2η)
2ε

. (4)
We remark here that the best known classical sample complexity lower bound (see Simon
(1996)) under the random classification noise is equal to the quantum sample complexity
lower bound proven in Eq. (4).
1.3. Related work
Here we briefly mention related work on quantum learning, referring to our survey Arunachalam and de Wolf (2017) for more details. In this paper we focus on sample complexity,
which is a fundamental information-theoretic quantity. Sample complexity concerns a form
of “passive” learning: the learner gets a number of examples at the start of the process,
and then has to extract enough information about the target concept from these. We may
also consider more active learning settings, in particular ones where the learner can make
membership queries (i.e., learn the label c(x) for any x of his choice). Servedio and Gortler
(2004) showed that in this setting, classical and quantum complexity are polynomially related. They also exhibit an example of a factor-n speed-up from quantum membership
queries using the Bernstein-Vazirani algorithm. Jackson et al. (2002) showed how quantum
membership queries can improve Jackson (1997)’s classical algorithm for learning DNF with
membership queries under the uniform distribution.
For quantum exact learning (also referred to as the oracle identification problem in the
quantum literature), Kothari (2014) resolved a conjecture of Hunziker et al. (2010), that
states that for any concept class C , the number of quantum membership queries required
to exactly identify a concept c ∈ C is O(
log
√
|C |
γˆC
), where ˆγ
C is a combinatorial parameter
7
Arunachalam and de Wolf
of the concept class C which we shall not define here (see Atıcı and Servedio (2005) for a
precise definition). Montanaro (2012) showed how low-degree polynomials over a finite field
can be identified more efficiently using quantum algorithms.
In many ways the time complexity of learning is at least as important as the sample complexity. We already mentioned that Servedio and Gortler (2004) exhibited a concept class
based on factoring Blum integers that can be learned in quantum polynomial time but not in
classical polynomial time, unless Blum integers can be factored efficiently. Under the weaker
(and widely believed) assumption that one-way functions exist, they exhibited a concept
class that can be learned exactly in polynomial time using quantum membership queries,
but that takes superpolynomial time to learn from classical membership queries. Gavinsky
(2012) introduced a model of learning called “Predictive Quantum” (PQ), a variation of
quantum PAC learning, and exhibited a relational concept class that is polynomial-time
learnable in PQ, while any “reasonable” classical model requires an exponential number of
classical examples to learn the concept class.
A¨ımeur et al. (2006, 2013) considered a number of quantum algorithms in learning
contexts such as clustering via minimum spanning tree, divisive clustering, and k-medians,
using variants of Grover (1996)’s algorithm to improve the time complexity of the analogous
classical algorithms. Recently, there have been some quantum machine learning algorithms
based on Harrow et al. (2009)’s algorithm (commonly referred to as the HHL algorithm) for
solving (in a weak sense) very well-behaved linear systems. However, these algorithms often
come with some fine print that limits their applicability, and their advantage over classical is
not always clear. We refer the reader to the fine print by Aaronson (2015) for references and
caveats. There has also been some work on quantum training of neural networks by Wiebe
et al. (2016a,b).
In addition to learning classical objects such as Boolean functions, one may also study
the learnability of quantum objects. In particular, Aaronson (2007) studied how well n-qubit
quantum states can be learned from measurement results. In general, an n-qubit state ρ
is specified by exp(n) many parameters, and exp(n) measurement results on equally many
copies of ρ are needed to learn a good approximation of ρ (say, in trace distance). However,
Aaronson showed an interesting and surprisingly efficient PAC-like result: from O(n) measurement results, with measurements chosen i.i.d. according to an unknown distribution D
on the set of all possible two-outcome measurements, we can learn an n-qubit quantum
state ρe that has roughly the same expectation value as ρ for “most” possible two-outcome
measurements. In the latter, “most” is again measured under D, just like in the usual PAC
learning the error of the learner’s hypothesis is evaluated under the same distribution D
that generated the learner’s examples. Accordingly, O(n) rather than exp(n) measurement
results suffice to approximately learn an n-qubit state for most practical purposes.
The use of Fourier analysis in analyzing the success probability of the Pretty Good
Measurement in quantum state identification appears in a number of earlier works. By
considering the dihedral hidden subgroup problem (DHSP) as a state-identification problem, Bacon et al. (2006) show that the PGM is the optimal measurement for DHSP and
prove a lower bound on the sample complexity of Ω(log |G |) for a dihedral group G using
Fourier analysis. Ambainis and Montanaro (2014) view the “search with wildcard” problem
as a state-identification problem. Using ideas similar to ours, they show that the (x, y)-th
entry of the Gram matrix for the ensemble depends on the Hamming distance between x
8
Optimal Quantum Sample Complexity of Learning Algorithms
and y, allowing them to use Fourier analysis to obtain an upper bound on the success
probability of the state-identification problem using the PGM.
1.4. Organization
In Section 2 we formally define the classical and quantum learning models and introduce the
Pretty Good Measurement. In Section 3 we prove our information-theoretic lower bounds
both for classical and quantum learning. In Section 4 we prove an optimal quantum lower
bound for PAC and agnostic learning by viewing the learning process as a state-identification
problem. We conclude in Section 5 with a conclusion of the results and some open questions
for further work.
2. Preliminaries
2.1. Notation
Let [n] = {1, . . . , n}. For x, y ∈ {0, 1}
d
, the bit-wise sum x + y is over F2, the Hamming
distance dH(x, y) is the number of indices on which x and y differ, |x + y| is the Hamming
weight of the string x + y (which equals dH(x, y)), and x · y =
P
i
xiyi (where the sum
is over F2). For a vector z ∈ R
d
, the norm of z is defined as kzk = (P
i
z
2
i
)
1/2
. For an
n-dimensional vector space, the standard basis is denoted by {ei ∈ {0, 1}
n
: i ∈ [n]}, where
ei
is the vector with a 1 in the i-th coordinate and 0’s elsewhere. We write log for logarithm
to base 2, and ln for base e. We will often use the bijection between the sets {0, 1}
k and
[2k
] throughout this paper. Let 1[A] be the indicator for an event A, and let δx,y = 1[x=y]
.
We denote random variables in bold, such as A, B.
For a Boolean function f : {0, 1}
m → {0, 1} and M ∈ F
m×k
2 we define f ◦ M : {0, 1}
k →
{0, 1} as (f ◦ M)(x) := f(Mx) (where the matrix-vector product is over F2) for all x ∈
{0, 1}
k
. For a distribution D : {0, 1}
n → [0, 1], let supp(D) = {x ∈ {0, 1}
n
: D(x) 6= 0}. By
x ∼ D, we mean x is sampled according to the distribution D, i.e., Pr[X = x] = D(x).
If M is a positive semidefinite (psd) matrix, we define √
M as the unique psd matrix
that satisfies √
M ·
√
M = M, and √
M(i, j) as the (i, j)-th entry of √
M. For a matrix
A ∈ R
m×n
, we denote the singular values of A by σ1(A) ≥ σ2(A) ≥ · · · ≥ σmin{m,n}
(A) ≥ 0.
The spectral norm of A is kAk = maxx∈Rn,kxk=1 kAxk = σ1. Given a set of d-dimensional
vectors U = {u1, . . . , un} ∈ R
d
, the Gram matrix V corresponding to the set U is the n × n
psd matrix defined as V (i, j) = u
t
iuj for i, j ∈ [n], where u
t
i
is the row vector that is the
transpose of the column vector ui
.
A technical tool used in our analysis of state-identification problems is Fourier analysis on the Boolean cube. We will just introduce the basics of Fourier analysis here, referring to O’Donnell (2014) for more. Define the inner product between functions f, g :
{0, 1}
n → R as
hf, gi = E
x
[f(x) · g(x)]
where the expectation is uniform over x ∈ {0, 1}
n
. For S ⊆ [n] (equivalently S ∈ {0, 1}
n
),
let χS(x) := (−1)S·x denote the parity of the variables (of x) indexed by the set S. It is
easy to see that the set of functions {χS}S⊆[n]
forms an orthonormal basis for the space of
9
Arunachalam and de Wolf
real-valued functions over the Boolean cube. Hence every f can be decomposed as
f(x) = X
S⊆[n]
fb(S)(−1)S·x
for all x ∈ {0, 1}
n
,
where fb(S) = hf, χSi = Ex[f(x) · χS(x)] is called a Fourier coefficient of f.
2.2. Learning in general
In machine learning, a concept class C over {0, 1}
n
is a set of concepts c : {0, 1}
n → {0, 1}.
We refer to a concept class C as being trivial if either C contains only one concept, or C
contains two concepts c0, c1 with c0(x) = 1 − c1(x) for every x ∈ {0, 1}
n
. For c : {0, 1}
n →
{0, 1}, we will often refer to the tuple (x, c(x)) ∈ {0, 1}
n+1 as a labeled example, where c(x)
is the label of x.
A central combinatorial concept in learning is the Vapnik and Chervonenkis (1971)
dimension, also referred to as the VC dimension. Fix a concept class C over {0, 1}
n
. A set
S = {s1, . . . , st} ⊆ {0, 1}
n
is said to be shattered by a concept class C if {(c(s1), . . . , c(st)) :
c ∈ C } = {0, 1}
t
. In other words, for every labeling ` ∈ {0, 1}
t
, there exists a c ∈ C such
that (c(s1), . . . , c(st)) = `. The VC dimension of a concept class C is the size of the largest
S ⊆ {0, 1}
n
that is shattered by C .
2.3. Classical learning models
In this paper we will be concerned mainly with the PAC (Probably Approximately Correct) model of learning introduced by Valiant (1984), and the agnostic model of learning
introduced by Haussler (1992) and Kearns et al. (1994). For further reading, see standard
textbooks in computational learning theory such as Kearns and Vazirani (1994); Anthony
and Bartlett (2009); Shalev-Shwartz and Ben-David (2014).
In the classical PAC model, a learner A is given access to a random example oracle
PEX(c, D) which generates labeled examples of the form (x, c(x)) where x is drawn from an
unknown distribution D : {0, 1}
n → [0, 1] and c ∈ C is the target concept that A is trying
to learn. For a concept c ∈ C and hypothesis h : {0, 1}
n → {0, 1}, we define the error of h
compared to the target concept c, under D, as errD(h, c) = Prx∼D[h(x) 6= c(x)]. A learning
algorithm A is an (ε, δ)-PAC learner for C , if the following holds:
For every c ∈ C and distribution D, given access to the PEX(c, D) oracle:
A outputs an h such that errD(h, c) ≤ ε with probability at least 1 − δ.
The sample complexity of A is the maximum number of invocations of the PEX(c, D)
oracle which the learner makes, over all concepts c ∈ C , distributions D, and the internal
randomness of the learner. The (ε, δ)-PAC sample complexity of a concept class C is the
minimum sample complexity over all (ε, δ)-PAC learners for C .
Agnostic learning is the following model: for a distribution D : {0, 1}
n+1 → [0, 1], a
learner A is given access to an AEX(D) oracle that generates examples of the form (x, b)
drawn from the distribution D. We define the error of h : {0, 1}
n → {0, 1} under D as
errD(h) = Pr(x,b)∼D[h(x) 6= b]. When h is restricted to come from a concept class C , the
minimal error achievable is optD(C ) = minc∈C {errD(c)}. In agnostic learning, a learner A
10
Optimal Quantum Sample Complexity of Learning Algorithms
needs to output a hypothesis h whose error is not much bigger than optD(C ). A learning
algorithm A is an (ε, δ)-agnostic learner for C if:
For every distribution D on {0, 1}
n+1, given access to the AEX(D) oracle:
A outputs an h ∈ C such that errD(h) ≤ optD(C ) + ε with probability at least
1 − δ.
Note that if there is a c ∈ C which perfectly classifies every x with label y for (x, y) ∈
supp(D), then optD(C ) = 0 and we are in the setting of proper PAC learning. The sample
complexity of A is the maximum number of invocations of the AEX(c, D) oracle which the
learner makes, over all distributions D and over the learner’s internal randomness. The
(ε, δ)-agnostic sample complexity of a concept class C is the minimum sample complexity
over all (ε, δ)-agnostic learners for C .
2.4. Quantum information theory
Throughout this paper we will assume the reader is familiar with the following quantum terminology. An n-dimensional pure state is |ψi =
Pn
i=1 αi
|ii, where |ii is the ndimensional unit vector that has a 1 only at position i, the αi
’s are complex numbers called
the amplitudes, and P
i∈[n]
|αi
|
2 = 1. An n-dimensional mixed state (or density matrix )
ρ =
Pn
i=1 pi
|ψiihψi
| is a mixture of pure states |ψ1i, . . . , |ψni prepared with probabilities
p
P
1, . . . , pn, respectively. The eigenvalues λ1, . . . , λn of ρ are non-negative reals and satisfy
i∈[n]
λi = 1. If ρ is pure (i.e., ρ = |ψihψ| for some |ψi), then one of the eigenvalues is 1
and the others are 0.
To obtain classical information from ρ, one could apply a POVM (positive-operatorvalued measure) to the state ρ. An m-outcome POVM is specified by a set of positive
semidefinite matrices {Mi}i∈[m] with the property P
i Mi = Id. When this POVM is applied
to the mixed state ρ, the probability of the j-th outcome is given by Tr(Mjρ).
For a probability vector (p1, . . . , pk) (where P
i∈[k]
pi = 1), the entropy function is defined
as H(p1, . . . , pk) = −
P
i∈[k]
pi
log pi
. When k = 2, with p1 = p and p2 = 1 − p, we denote
the binary entropy function as H(p). For a state ρAB on the Hilbert space HA ⊗ HB,
we let ρA be the reduced state after taking the partial trace over HB. The entropy of
a quantum state ρA is defined as S(A) = −Tr(ρA log ρA). The mutual information is
defined as I(A : B) = S(A) + S(B) − S(AB), and conditional entropy is defined as
S(A|B) = S(AB) − S(B). Classical information-theoretic quantities correspond to the
special case where ρ is a diagonal matrix whose diagonal corresponds to the probability
distribution of the random variable. Writing ρA in its eigenbasis, it follows that S(A) =
H(λ1, . . . , λdim(ρA)
), where λ1, . . . , λdim(ρA) are the eigenvalues of ρ. If ρA is a pure state,
S(A) = 0.
2.5. Quantum learning models
The quantum PAC learning model was introduced by Bshouty and Jackson (1999). The
quantum PAC model is a generalization of the classical PAC model, in which instead of having access to random examples (x, c(x)) from the PEX(c, D) oracle, the learner now has access to superpositions over all (x, c(x)). For an unknown distribution D : {0, 1}
n → [0, 1] and
11
Arunachalam and de Wolf
concept c ∈ C , a quantum example oracle QPEX(c, D) acts on |0
n
, 0i and produces a quantum example P
x∈{0,1}n
p
D(x)|x, c(x)i (we leave QPEX undefined on other basis states).
A quantum learner is given access to some copies of the state generated by QPEX(c, D)
and performs a POVM where each outcome is associated with a hypothesis. A learning
algorithm A is an (ε, δ)-PAC quantum learner for C if:
For every c ∈ C and distribution D, given access to the QPEX(c, D) oracle:
A outputs an h such that errD(h, c) ≤ ε, with probability at least 1 − δ.
The sample complexity of A is the maximum number invocations of the QPEX(c, D) oracle,
maximized over all c ∈ C , distributions D, and the learner’s internal randomness. The (ε, δ)-
PAC quantum sample complexity of a concept class C is the minimum sample complexity
over all (ε, δ)-PAC quantum learners for C .
We define quantum agnostic learning now. For a joint distribution D : {0, 1}
n+1 → [0, 1]
over the set of examples, the learner has access to an QAEX(D) oracle which acts on |0
n
, 0i
and produces a quantum example P
(x,b)∈{0,1}n+1 p
D(x, b)|x, bi. A learning algorithm A is
an (ε, δ)-agnostic quantum learner for C if:
For every distribution D, given access to the QAEX(D) oracle:
A outputs an h ∈ C such that errD(h) ≤ optD(C ) + ε with probability at
least 1 − δ.
The sample complexity of A is the maximum number invocations of the QAEX(D) oracle
over all distributions D and over the learner’s internal randomness. The (ε, δ)-agnostic
quantum sample complexity of a concept class C is the minimum sample complexity over
all (ε, δ)-agnostic quantum learners for C .
2.6. Pretty Good Measurement
Consider an ensemble of d-dimensional states, E = {(pi
, |ψii)}i∈[m]
, where P
i∈[m]
pi = 1.
Suppose we are given an unknown state |ψii sampled according to the probabilities and we
are interested in maximizing the average probability of success to identify the state that
we are given. For a POVM specified by positive semidefinite matrices M = {Mi}i∈[m]
, the
probability of obtaining outcome j equals hψi
|Mj |ψii. The average success probability is
defined as
PM(E) = Xm
i=1
pihψi
|Mi
|ψii.
Let P
opt(E) = maxM PM(E) denote the optimal average success probability of E, where the
maximization is over the set of valid m-outcome POVMs.
For every ensemble E, the so-called Pretty Good Measurement (PGM) is a specific POVM
(depending on the ensemble E), which we shall define shortly, that does reasonably well
against E.
Theorem 1 Let E = {(pi
, |ψii)}i∈[m] be an ensemble of d-dimensional states. Suppose
P
P GM (E) is defined as the average success probability of identifying the states in E using
the PGM, then we have that
P
opt(E)
2 ≤ P
P GM (E) ≤ P
opt(E).
12
Optimal Quantum Sample Complexity of Learning Algorithms
Proof The second inequality in the theorem follows because P
opt(E) is a maximization
over all valid POVMs and the first inequality was shown by Barnum and Knill (2002). For
completeness we give a simple proof of P
opt(E)
2 ≤ P
P GM (E) below (similar to Montanaro
(2007)). Let |ψ
0
i
i =
√pi
|ψii, and E
0 = {|ψ
0
i
i : i ∈ [m]} be the set of states in E, renormalized
to reflect their probabilities. Define ρ =
P
i∈[m]
|ψ
0
i
ihψ
0
i
|. The PGM is defined as the set of
measurement operators {|νiihνi
|}i∈[m] where |νii = ρ
−1/2
|ψ
0
i
i (the inverse square root of ρ is
taken over its non-zero eigenvalues). We first verify this is a valid POVM:
Xm
i=1
|νiihνi
| = ρ
−1/2
Xm
i=1
|ψ
0
i
ihψ
0
i
|

ρ
−1/2 = Id .
Let G be the Gram matrix for the set E
0
, i.e., G(i, j) = hψ
0
i
|ψ
0
j
i for i, j ∈ [m]. It can be
verified that √
G(i, j) = hψ
0
i
|ρ
−1/2
|ψ
0
j
i. Hence
P
P GM (E) = X
i∈[m]
pi
|hνi
|ψii|2 =
X
i∈[m]
|hνi
|ψ
0
i
i|2
=
X
i∈[m]
hψ
0
i
|ρ
−1/2
|ψ
0
i
i
2 =
X
i∈[m]
√
G(i, i)
2
.
We now prove P
opt(E)
2 ≤ P
P GM (E). Suppose M is the optimal measurement. Since
E consists of pure states, by a result of Eldar et al. (2003), we can assume without loss of
generality that the measurement operators in M are rank-1, so Mi = |µiihµi
| for some |µii.
Note that
1 = Tr(ρ) = Tr X
i∈[m]
|µiihµi
|ρ
1/2 X
j∈[m]
|µj ihµj |ρ
1/2

=
X
i,j∈[m]
|hµi
|ρ
1/2
|µj i|2 ≥
X
i∈[m]
hµi
|ρ
1/2
|µii
2
.
(5)
Then, using the Cauchy-Schwarz inequality, we have
P
opt(E) = X
i∈[m]
|hµi
|ψ
0
i
i|2 =
X
i∈[m]
|hµi
|ρ
1/4
ρ
−1/4
|ψ
0
i
i|2
≤
X
i∈[m]
hµi
|ρ
1/2
|µiihψ
0
i
|ρ
−1/2
|ψ
0
i
i
≤
sX
i∈[m]
hµi
|ρ
1/2|µii
2
sX
i∈[m]
hψ
0
i
|ρ−1/2|ψ
0
i
i
2
Eq. (5)
≤
sX
i∈[m]
hψ
0
i
|ρ−1/2|ψ
0
i
i
2 =
q
P P GM (E).
13
Arunachalam and de Wolf
The above shows that for all ensembles E, the PGM for that ensemble is not much
worse than the optimal measurement. In some cases the PGM is the optimal measurement.
In particular, an ensemble E is called geometrically uniform if E = {Ui
|ϕi : i ∈ [m]} for
some Abelian group of matrices {Ui}i∈[m] and state |ϕi. Eldar and Forney Jr (2001) showed
P
opt(E) = P
P GM (E) for such E.
2.7. Known results and required claims
The following theorems characterize the sample complexity of classical PAC and agnostic learning.
Theorem 2 (Blumer et al. (1989); Hanneke (2016)) Let C be a concept class with
VC-dim(C ) = d + 1. In the PAC model, Θ

d
ε +
log(1/δ)
ε

examples are necessary and
sufficient for a classical (ε, δ)-PAC learner for C .
Theorem 3 (Vapnik and Chervonenkis (1974); Simon (1996); Talagrand (1994))
Let C be a concept class with VC-dim(C ) = d. In the agnostic model, Θ

d
ε
2 +
log(1/δ)
ε
2

examples are necessary and sufficient for a classical (ε, δ)-agnostic learner for C .
We will use the following well-known theorem from the theory of error-correcting codes
(which follows immediately from the Gilbert-Varshamov bound):
Theorem 4 For every sufficiently large integer n, there exists an integer k ∈ [n/4, n] and a
matrix M ∈ F
n×k
2
of rank k, such that the associated [n, k, d]2 linear code {Mx : x ∈ {0, 1}
k}
has minimal distance d ≥ n/8.
We will need the following claims later
Claim 5 Let f : {0, 1}
m → R and let M ∈ F
m×k
2
. Then the Fourier coefficients of f ◦ M
are f\◦ M(Q) = P
S∈{0,1}m:MtS=Q fb(S) for all Q ⊆ [k] (where Mt
is the transpose of the
matrix M).
Proof Writing out the Fourier coefficients of f ◦ M
f\◦ M(Q) = E
z∈{0,1}
k
[(f ◦ M)(z)(−1)Q·z
]
= E
z∈{0,1}
k
h X
S∈{0,1}m
fb(S)(−1)S·(Mz)+Q·z
i
(Fourier expansion of f)
=
X
S∈{0,1}m
fb(S) E
z∈{0,1}
k
[(−1)(MtS+Q)·z
] (using hS, Mzi = hMtS, zi)
=
X
S:MtS=Q
fb(S). (using Ez∈{0,1}
k (−1)(z1+z2)·z = δz1,z2
)
14
Optimal Quantum Sample Complexity of Learning Algorithms
Claim 6 max{(c/√
t)
t
: t ∈ [1, c2
]} = e
c
2/(2e)
.
Proof The value of t at which the function 
c/√
t
t
is the largest, is obtained by differentiating the function with respect to t,
d
dt

c/√
t
t
= (c/√
t)
t

ln(c/√
t) − 1/2

.
Equating the derivative to zero we obtain the maxima (the second derivative can be checked
to be negative) at t = c
2/e.
Fact 7 For all ε ∈ [0, 1/2] we have H(ε) ≤ O(ε log(1/ε)), and (from the Taylor series)
1 − H(1/2 + ε) ≤ 2ε
2
/ ln 2 + O(ε
4
).
Fact 8 For every positive integer n, we have that
n
k

≤ 2
nH(k/n)
for all k ≤ n and
Pm
i=0
n
i

≤ 2
nH(m/n)
for all m ≤ n/2.
The following facts are well-known in quantum information theory.
Fact 9 (Kaye et al., 2006, Appendix A.9) Let binary random variable b ∈ {0, 1} be
uniformly distributed. Suppose an algorithm is given |ψbi (for unknown b) and is required to guess whether b = 0 or b = 1. It will guess correctly with probability at most
1
2 +
1
2
p
1 − |hψ0|ψ1i|2.
Note that if we can distinguish |ψ0i and |ψ1i with probability ≥ 1 − δ, then |hψ0|ψ1i| ≤
2
p
δ(1 − δ).
Fact 10 (Subadditivity of quantum entropy): For an arbitrary bipartite state ρAB on the
Hilbert space HA ⊗ HB, it holds that S(ρAB) ≤ S(ρA) + S(ρB).
3. Information-theoretic lower bounds
Upper bounds on sample complexity carry over from classical to quantum PAC learning,
because a quantum example becomes a classical example if we just measure it. Our main
goal is to show that the lower bounds also carry over. All our lower bounds will involve
two terms, one that is independent of C and one that is dependent on the VC dimension of
C . In Section 3.1 we prove the VC-independent part of the lower bounds for the quantum
setting (which also is a lower bound for the classical setting), in Section 3.2 we present
an information-theoretic lower bound on sample complexity for PAC learning and agnostic
learning which yields optimal VC-dependent bounds in the classical case. Using similar
ideas, in Section 3.3 we obtain near-optimal bounds in the quantum case.
  
Arunachalam and de Wolf
3.1. VC-independent part of lower bounds
Lemma 11 (Atıcı and Servedio (2005)) Let C be a non-trivial concept class. For every δ ∈ (0, 1/2), ε ∈ (0, 1/4), a (ε, δ)-PAC quantum learner for C has sample complexity
Ω( 1
ε
log 1
δ
).
Proof Since C is non-trivial, we may assume there are two concepts c1, c2 ∈ C defined
on two inputs {x1, x2} as follows c1(x1) = c2(x1) = 0 and c1(x2) = 0, c2(x2) = 1. Consider
the distribution D(x1) = 1 − ε and D(x2) = ε. For i ∈ {1, 2}, the state of the algorithm
after T queries to QPEX(ci
, D) is |ψii = (√
1 − ε|x1, 0i +
√
ε|x2, ci(x2)i)
⊗T
. It follows that
hψ1|ψ2i = (1−ε)
T
. Since the success probability of an (ε, δ)-PAC quantum learner is ≥ 1−δ,
Fact 9 implies hψ1|ψ2i ≤ 2
p
δ(1 − δ). Hence T = Ω( 1
ε
log 1
δ
).
Lemma 12 Let C be a non-trivial concept class. For every δ ∈ (0, 1/2), ε ∈ (0, 1/4), a
(ε, δ)-agnostic quantum learner for C has sample complexity Ω( 1
ε
2 log 1
δ
).
Proof Since C is non-trivial, we may assume there are two concepts c1, c2 ∈ C and
there exists an input x ∈ {0, 1}
n
such that c1(x) 6= c2(x). Consider the two distributions
D− and D+ defined as follows: D±(x, c1(x)) = (1 ± ε)/2 and D±(x, c2(x)) = (1 ∓ ε)/2.
Let |ψ±i be the state after T queries to QAEX(D±), i.e., |ψ±i = (p
p
(1 ± ε)/2|x, c1(x)i +
(1 ∓ ε)/2|x, c2(x)i)
⊗T
. It follows that hψ+|ψ−i = (1 − ε
2
)
T /2
. Since the success probability of an (ε, δ)-agnostic quantum learner is ≥ 1 − δ, Fact 9 implies hψ+|ψ−i ≤ 2
p
δ(1 − δ).
Hence T = Ω( 1
ε
2 log 1
δ
)
3.2. Information-theoretic lower bounds on sample complexity: classical case
3.2.1. Optimal lower bound for classical PAC learning
Theorem 13 Let C be a concept class with VC-dim(C ) = d+1. Then for every δ ∈ (0, 1/2)
and ε ∈ (0, 1/4), every (ε, δ)-PAC learner for C has sample complexity Ω

d
ε +
log(1/δ)
ε

.
Proof Consider an (ε, δ)-PAC learner for C that uses T examples. The d-independent
part of the lower bound, T = Ω(log(1/δ)/ε), even holds for quantum examples and was
proven in Lemma 11. Hence it remains to prove T = Ω(d/ε). It suffices to show this for
a specific distribution D, defined as follows. Let S = {s0, s1, . . . , sd} ⊆ {0, 1}
n be some
(d + 1)-element set shattered by C . Define D(s0) = 1 − 4ε and D(si) = 4ε/d for all i ∈ [d].
Because S is shattered by C , for each string a ∈ {0, 1}
d
, there exists a concept ca ∈ C
such that ca(s0) = 0 and ca(si) = ai for all i ∈ [d]. We define two correlated random
variables A and B corresponding to the concept and to the examples, respectively. Let A
be a random variable that is uniformly distributed over {0, 1}
d
; if A = a, let B = B1 . . . BT
be T i.i.d. examples from ca according to D. We give the following three-step analysis of
these random variables:
1. I(A : B) ≥ (1 − δ)(1 − H(1/4))d − H(δ) = Ω(d).
Proof. Let random variable h(B) ∈ {0, 1}
d be the hypothesis that the learner produces
16
Optimal Quantum Sample Complexity of Learning Algorithms
(given the examples in B) restricted to the elements s1, . . . , sd. Note that the error
of the hypothesis errD(h(B), cA) equals dH(A, h(B)) · 4ε/d, because each si where A
and h(B) differ contributes D(si) = 4ε/d to the error. Let Z be the indicator random
variable for the event that the error is ≤ ε. If Z = 1, then dH(A, h(B)) ≤ d/4. Since
we are analyzing an (ε, δ)-PAC learner, we have Pr[Z = 1] ≥ 1−δ, and H(Z) ≤ H(δ).
Given a string h(B) that is d/4-close to A, A ranges over a set of only Pd/4
i=0
d
i

≤
2
H(1/4)d possible d-bit strings (using Fact 8), hence
H(A | B, Z = 1) ≤ H(A | h(B), Z = 1) ≤ H(1/4)d.
We now lower bound I(A : B) as follows:
I(A : B) = H(A) − H(A | B)
≥ H(A) − H(A | B, Z) − H(Z)
= H(A) − Pr[Z = 1] · H(A | B, Z = 1)−
Pr[Z = 0] · H(A | B, Z = 0) − H(Z)
≥ d − (1 − δ)H(1/4)d − δd − H(δ)
= (1 − δ)(1 − H(1/4))d − H(δ).
2. I(A : B) ≤ T · I(A : B1).
Proof. This inequality essentially appeared in (Jain and Zhang, 2009, Lemma 5), we
include the proof for completeness.
I(A : B) = H(B) − H(B | A) = H(B) −
X
T
i=1
H(Bi
| A)
≤
X
T
i=1
H(Bi) −
X
T
i=1
H(Bi
| A) = X
T
i=1
I(A : Bi),
where the second equality used independence of the Bi
’s conditioned on A, and the
inequality uses Fact 10. Since I(A : Bi) = I(A : B1) for all i, we get the inequality.
3. I(A : B1) = 4ε.
Proof. View B1 = (I,L) as consisting of an index I ∈ {0, 1, . . . , d} and a corresponding
label L ∈ {0, 1}. With probability 1 − 4ε, (I,L) = (0, 0). For each i ∈ [d], with
probability 4ε/d, (I,L) = (i, Ai). Note that I(A : I) = 0 because I is independent
of A; I(A : L | I = 0) = 0; and I(A : L | I = i) = I(Ai
: L | I = i) = H(Ai
| I =
i) − H(Ai
| L, I = i) = 1 − 0 = 1 for all i ∈ [d]. We have
I(A : B1) = I(A : I) + I(A : L | I) = X
d
i=1
Pr[I = i] · I(A : L | I = i) = 4ε.
Combining these three steps implies T = Ω(d/ε).
1 
Arunachalam and de Wolf
3.2.2. Optimal lower bound for classical agnostic learning
Theorem 14 Let C be a concept class with VC-dim(C ) = d. Then for every δ ∈ (0, 1/2)
and ε ∈ (0, 1/4), every (ε, δ)-agnostic learner for C has sample complexity Ω

d
ε
2 +
log(1/δ)
ε
2

.
Proof The d-independent part of the lower bound, T = Ω(log(1/δ)/ε2
), even holds for
quantum examples and was proven in Lemma 12. For the other part, the proof is similar to
Theorem 13, as follows. Assume an (ε, δ)-agnostic learner for C that uses T examples. We
need to prove T = Ω(d/ε2
). For shattered set S = {s1, . . . , sd} ⊆ {0, 1}
n and a ∈ {0, 1}
d
,
define distribution Da on [d] × {0, 1} by Da(i, `) = (1 + (−1)ai+`4ε)/2d.
Again let random variable A ∈ {0, 1}
d be uniformly random, corresponding to the values
of concept ca on S, and B = B1 . . . BT be T i.i.d. samples from Da. Note that ca is the
minimal-error concept from C w.r.t. Da, and concept ca˜ has additional error dH(a, a˜)·4ε/d.
Accordingly, an (ε, δ)-agnostic learner has to produce (from B) an h(B) ∈ {0, 1}
d
, which,
with probability at least 1 − δ, is d/4-close to A. Our three-step analysis is very similar to
Theorem 13; only the third step changes:
1. I(A : B) ≥ (1 − δ)(1 − H(1/4))d − H(δ) = Ω(d).
2. I(A : B) ≤ T · I(A : B1).
3. I(A : B1) = 1 − H(1/2 + 2ε) = O(ε
2
).
Proof. View the Da-distributed random variable B1 = (I,L) as index I ∈ [d] and
label L ∈ {0, 1}. The marginal distribution of I is uniform; conditioned on I = i, the
bit L equals Ai with probability 1/2 + 2ε. Hence
I(A : L | I = i) = I(Ai
: L | I = i) = H(Ai
| I = i) − H(Ai
| L, I = i)
= 1 − H(1/2 + 2ε).
Using Fact 7, we have
I(A : B1) = I(A : I) + I(A : L | I) = X
d
i=1
Pr[I = i] · I(A : L | I = i)
= 1 − H(1/2 + 2ε) = O(ε
2
).
Combining these three steps implies T = Ω(d/ε2
).
In the theorem below, we optimize the constant in the lower bound of the sample
complexity in Theorem 14. In learning theory such lower bounds are often stated slightly
differently. In order to compare the lower bounds, we introduce the following. We first
define an ε-average agnostic learner for a concept class C as a learner that, given access to
T samples from an AEX(D) oracle (for some unknown distribution D), needs to output a
hypothesis hXY (where (X, Y) ∼ DT
) that satisfies
E
(X,Y)∼DT
[errD(hXY)] − optD(C ) ≤ ε.
18
Optimal Quantum Sample Complexity of Learning Algorithms
Lower bounds on the quantity (E(X,Y)∼DT [errD(hXY)]−optD(C )) are generally referred to
as minimax lower bounds in learning theory. For concept class C , Audibert (2008, 2009)
showed that there exists a distribution D, such that if the agnostic learner uses T samples
from AEX(D), then
E
(X,Y)∼DT
[errD(hXY)] − optD(C ) ≥
1
6
r
d
T
.
Equivalently, this is a lower bound of T ≥
d
36ε
2 on the sample complexity of an ε-average
agnostic learner. We obtain a slightly weaker lower bound that is essentially T ≥
d
62ε
2 :
Theorem 15 Let C be a concept class with VC-dim(C ) = d. Then for every ε ∈ (0, 1/10],
there exists a distribution for which every ε-average agnostic learner has sample complexity
at least d
ε
2 ·

1
62 −
log(2d+2)
4d

.
Proof The proof is similar to Theorem 14. Assume an ε-average agnostic learner for C
that uses T samples. For shattered set S = {s1, . . . , sd} ⊆ {0, 1}
n and a ∈ {0, 1}
d
, define
distribution Da on [d] × {0, 1} by Da(i, `) = (1 + (−1)ai+`βε)/2d, for some constant β ≥ 2
which we shall pick later.
Again let random variable A ∈ {0, 1}
d be uniformly random, corresponding to the values
of concept ca on S, and B = B1 . . . BT be T i.i.d. samples from Da. Note that ca is the
minimal-error concept from C w.r.t. Da, and concept ca˜ has additional error dH(a, a˜)·βε/d.
Accordingly, an ε-average agnostic learner has to produce (from B) an h(B) ∈ {0, 1}
d
, which
satisfies EA,B[dH(A, h(B))] ≤ d/β.
Our three-step analysis is very similar to Theorem 14; only the first step changes:
1. I(A : B) ≥ d(1 − H(1/β)) − log(d + 1).
Proof. Define random variable Z = dH(A, h(B)), then E[Z] ≤ d/β. Note that given
a string h(B) that is `-close to A, A ranges over a set of only
d
`

≤ 2
H(`/d)d possible
d-bit strings (using Fact 8), hence
H(A | B, Z = `) ≤ H(A | h(B), Z = `) ≤ H(`/d)d.
We now lower bound I(A : B):
I(A : B) = H(A) − H(A | B)
≥ H(A) − H(A | B, Z) − H(Z)
= d −
X
d+1
`=0
Pr[Z = `] · H(A | B, Z = `) − H(Z)
≥ d − E
`∈{0,...,d}
[H(`/d)d] − log(d + 1) (since Z ∈ {0, . . . , d})
≥ d − dHE`
[`]
d

− log(d + 1) (using Jensen’s inequality)
≥ d − dH(1/β) − log(d + 1), (using E[Z] ≤ d/β)
where for the third inequality we used the concavity of the binary entropy function to
conclude E`
[H(`/d)] ≤ H(E`
[`]/d), and for the fourth inequality we used that β ≥ 2.
1 
Arunachalam and de Wolf
2. I(A : B) ≤ T · I(A : B1).
3. I(A : B1) = 1 − H(1/2 + βε/2)
Fact 7
≤ β
2
ε
2/ ln 4 + O(ε
4
).
Combining these three steps implies
T ≥
d ln 4
ε
2
·
1 − H(1/β)
β
2 + O(ε
2)
−
log(d + 1)
β
2d + O(dε2)

.
Using ε ≤ 1/10, β = 4 to optimize this lower bound, we obtain T ≥
d
ε
2 ·

1
62 −
log(2d+2)
4d

.
3.3. Information-theoretic lower bounds on sample complexity: quantum case
Here we will “quantize” the above two classical information-theoretic proofs, yielding lower
bounds for quantum sample complexity (in both the PAC and the agnostic setting) that
are tight up to a logarithmic factor.
3.3.1. Near-optimal lower bound for quantum PAC learning
Theorem 16 Let C be a concept class with VC-dim(C ) = d + 1. Then, for every δ ∈
(0, 1/2) and ε ∈ (0, 1/4), every (ε, δ)-PAC quantum learner for C has sample complexity Ω

d
ε log(d/ε) +
log(1/δ)
ε

.
Proof The proof is analogous to Theorem 13. We use the same distribution D, with the
Bi now being quantum samples: |ψai =
P
i∈{0,1,...,d}
p
D(si)|i, ca(si)i. The AB-system is
now in the following classical-quantum state:
1
2
d
X
a∈{0,1}
d
|aiha| ⊗ |ψaihψa|
⊗T
.
The first two steps of our argument are identical to Theorem 13. We only need to re-analyze
step 3:
1. I(A : B) ≥ (1 − δ)(1 − H(1/4))d − H(δ) = Ω(d).
2. I(A : B) ≤ T · I(A : B1).
3. I(A : B1) ≤ H(4ε) + 4ε log(2d) = O(ε log(d/ε)).
Proof. Since AB is a classical-quantum state, we have
I(A : B1) = S(A) + S(B1) − S(AB1) = S(B1),
where the first equality follows from definition and the second equality uses S(A) = d
since A is uniformly distributed in {0, 1}
d
, and S(AB1) = d since the matrix σ =
1
2
d
P
a∈{0,1}
d |aiha| ⊗ |ψaihψa| is block diagonal with 2d
rank-1 blocks on the diagonal.
20
Optimal Quantum Sample Complexity of Learning Algorithms
It thus suffices to bound the entropy of the singular values of the reduced state of B1,
which is
ρ =
1
2
d
X
a∈{0,1}
d
|ψaihψa|.
Let σ0 ≥ σ1 ≥ · · · ≥ σ2d ≥ 0 be its singular values. Since ρ is a density matrix, these
form a probability distribution. Note that the upper-left entry of the matrix |ψaihψa| is
D(s0) = 1−4ε, hence so is the upper-left entry of ρ. This implies σ0 ≥ 1−4ε. Consider
sampling a number N ∈ {0, 1, . . . , 2d} according to the σ-distribution. Let Z be the
indicator random variable for the event N 6= 0, which has probability 1−σ0 ≤ 4ε. Note
that H(N | Z = 0) = 0, because Z = 0 implies N = 0. Also, H(N | Z = 1) ≤ log(2d),
because if Z = 1 then N ranges over 2d elements. We now have
S(ρ) = H(N) = H(N, Z) = H(Z) + H(N | Z)
= H(Z) + Pr[Z = 0] · H(N | Z = 0) + Pr[Z = 1] · H(N | Z = 1)
≤ H(4ε) + 4ε log(2d)
= O(ε log(d/ε)). (using Fact 7)
Combining these three steps implies T = Ω
d
ε log(d/ε)

.
3.3.2. Near-optimal lower bound for quantum agnostic learning
Theorem 17 Let C be a concept class with VC-dim(C ) = d. Then for every δ ∈ (0, 1/2),
ε ∈ (0, 1/4), every (ε, δ)-agnostic quantum learner for C has sample complexity Ω

d
ε
2 log(d/ε)+
log(1/δ)
ε
2

.
Proof The proof is analogous to Theorem 14, with the Bi now being quantum samples
for Da, |ψai =
P
i∈[d],`∈{0,1}
p
Da(i, `)|i, `i. Again we only need to re-analyze step 3:
1. I(A : B) ≥ (1 − δ)(1 − H(1/4))d − H(δ) = Ω(d).
2. I(A : B) ≤ T · I(A : B1).
3. I(A : B1) = O(ε
2
log(d/ε)).
Proof of step 3. As in step 3 of the proof of Theorem 16, it suffices to upper bound
the entropy of
ρ =
1
2
d
X
a∈{0,1}
d
|ψaihψa|.
We lower bound the largest singular value of ρ. Consider |ψi = √
1
2d
P
i∈[d],`∈{0,1}
|i, `i.
hψ|ψai =
1
d
X
i∈[d]
1
2
√
1 + 4ε +
√
1 − 4ε

=
1
2
√
1 + 4ε +
√
1 − 4ε

≥ 1 − 2ε
2 − O(ε
4
),
21
Arunachalam and de Wolf
where the last inequality used the Taylor series expansion of √
1 + x. This implies
that the largest singular value of ρ is at least
hψ|ρ|ψi =
1
2
d
X
a∈{0,1}
d
|hψ|ψai|2 ≥ 1 − 4ε
2 − O(ε
4
).
We can now finish as in step 3 of the proof of Theorem 16:
I(A : B1) ≤ S(ρ) ≤ H(4ε
2
) + 4ε
2
log(2d)
Fact 7 = O(ε
2
log(d/ε)).
Combining these three steps implies T = Ω
d
ε
2 log(d/ε)

.
4. A lower bound by analysis of state identification
In this section we present a tight lower bound on quantum sample complexity for both
the PAC and the agnostic learning settings, using ideas from Fourier analysis to analyze
the performance of the Pretty Good Measurement. The core of both lower bounds is the
following theorem.
Theorem 18 For m ≥ 10, let f : {0, 1}
m → R be defined as f(z) = (1 − β
|z|
m
)
T
for some
β ∈ (0, 1] and T ∈ [1, m/(e
3β)]. For k ≤ m, let M ∈ F
m×k
2
be a matrix with rank k. Suppose
A ∈ R
2
k×2
k
is defined as A(x, y) = (f ◦ M)(x + y) for x, y ∈ {0, 1}
k
, then
√
A(x, x) ≤
2
√
e
2
k/2

1 −
β
2
T /2
e
11T
2β
2/m+
√
Tmβ for all x ∈ {0, 1}
k
.
Proof The structure of the proof is to first diagonalize A, relating its eigenvalues to the
Fourier coefficients of f. This allows to calculate the diagonal entries of √
A exactly in
terms of those Fourier coefficients. We then upper bound those Fourier coefficients using a
combinatorial argument.
We first observe the well-known relation between the eigenvalues of a matrix P defined
as P(x, y) = g(x + y) for x, y ∈ {0, 1}
k
, and the Fourier coefficients of g.
Claim 19 Suppose g : {0, 1}
k → R and P ∈ R
2
k×2
k
is defined as P(x, y) = g(x + y), then
the eigenvalues of P are {2
k
gb(Q) : Q ∈ {0, 1}
k}.
Proof Let H ∈ R
2
k×2
k
be the matrix defined as H(x, y) = (−1)x·y
for x, y ∈ {0, 1}
k
. It is
easy to see that H−1
(x, y) = (−1)x·y/2
k
. We now show that H diagonalizes P:
(HP H−1
)(x, y) = 1
2
k
X
z1,z2∈{0,1}
k
(−1)z1·x+z2·y
g(z1 + z2)
=
1
2
k
X
z1,z2,Q∈{0,1}
k
(−1)z1·x+z2·y
gb(Q)(−1)Q·(z1+z2)
(Fourier expansion of g)
=
1
2
k
X
Q∈{0,1}
k
gb(Q)
X
z1∈{0,1}
k
(−1)(x+Q)·z1 X
z2∈{0,1}
k
(−1)(y+Q)·z2
= 2k
gb(x)δx,y,
22
Optimal Quantum Sample Complexity of Learning Algorithms
where we used P
z∈{0,1}
k [(−1)(a+b)·z
] = 2k
δa,b in the last equality. The eigenvalues of P are
the diagonal entries, {2
k
gb(Q) : Q ∈ {0, 1}
k}.
We now relate the diagonal entries of √
A to the Fourier coefficients of f:
Claim 20 For all x ∈ {0, 1}
k
, we have
√
A(x, x) = 1
2
k/2
X
Q∈{0,1}
k
s X
S∈{0,1}m:MtS=Q
fb(S).
Proof Since A(x, y) = (f ◦ M)(x + y), by Claim 19 it follows that H (as defined in the
proof of Claim 19) diagonalizes A and the eigenvalues of A are {2
kf\◦ M(Q) : Q ∈ {0, 1}
k}.
Hence, we have
√
A = H−1
· diagnq
2
kf\◦ M(Q) : Q ∈ {0, 1}
k
o · H,
and the diagonal entries of √
A are
√
A(x, x) = 1
2
k/2
X
Q∈{0,1}
k
q
f\◦ M(Q)
Claim 5 =
1
2
k/2
X
Q∈{0,1}
k
s X
S∈{0,1}m:MtS=Q
fb(S).
In the following lemma, we give an upper bound on the Fourier coefficients of f, which
in turn (from the claim above) gives an upper bound on the diagonal entries of √
A.
Lemma 21 For β ∈ (0, 1], the Fourier coefficients of f : {0, 1}
m → R defined as f(z) =
(1 − β
|z|
m
)
T
, satisfy
0 ≤ fb(S) ≤ 4e

1 −
β
2
T T β
m
q
e
22T
2β
2/m, for all S such that |S| = q.
Proof In order to see why the Fourier coefficients of f are non-negative, we first define
the set U = {u
⊗T
x }x∈{0,1}m where ux =
√
1 − β|0, 0i +
p
β/mP
i∈[m]
|i, xii. Let V be the
2
m × 2
m Gram matrix for the set U. For x, y ∈ {0, 1}
m, we have
V (x, y) = (u
∗
xuy)
T =

1 − β +
β
m
Xm
i=1
hxi
|yii
T
=

1 − β +
β
m
(m − |x + y|)
T
=

1 − β
|x + y|
m
T
= f(x + y).
By Claim 19, the eigenvalues of the Gram matrix V are {2
mfb(S) : S ∈ {0, 1}
m}. Since the
Gram matrix is psd, its eigenvalues are non-negative, which implies that fb(S) ≥ 0 for all
S ∈ {0, 1}
m.
23
Arunachalam and de Wolf
We now prove the upper bound in the lemma. By definition,
fb(S) = E
z∈{0,1}m
h1 − β
|z|
m
T
(−1)S·z
i
= E
z∈{0,1}m
h1 −
β
2
+
β
2m
Xm
i=1
(−1)zi
T
(−1)S·z
i
(since |z| =
P
i∈[m]
1−(−1)zi
2
)
=
X
T
`=0

T
`

1 −
β
2
T −` β
2m
`
E
z∈{0,1}m
h Xm
i1,...,i`=1
(−1)z·(ei1+···+ei`
+S)
i
=
X
T
`=0

T
`

1 −
β
2
T −` β
2m
` Xm
i1,...,i`=1
1[ei1+···+ei`
=S]
,
using Ez∈{0,1}m[(−1)(z1+z2)·z
] = δz1,z2
in the last equality.
We will use the following claim to upper bound the combinatorial sum in the quantity above.
Claim 22 Fix S ∈ {0, 1}
m with Hamming weight |S| = q. For every ` ∈ {q, . . . , T}, we
have
Xm
i1,...,i`=1
1[ei1+···+ei`
=S] ≤
(
`! · m(`−q)/2
.2
(`−q)/2
((` − q)/2)!
if (` − q) is even
0 otherwise
Proof Since |S| = q, we can write S = er1 + · · · + erq
for distinct r1, . . . , rq ∈ [m]. There
are
`
q

ways to pick q indices in (i1, . . . , i`) (w.l.o.g. let them be i1, . . . , iq) and there are q!
factorial ways to assign (r1, . . . , rq) to (i1, . . . , iq). It remains to count the number of ways
that we can assign values to the remaining indices iq+1, . . . , i` such that eiq+1 +· · ·+ei` = 0.
If ` − q is odd then this number is 0, so from now on assume ` − q is even. We upper bound
the number of such assignments by partitioning the ` − q indices into pairs and assigning
the same value to both indices in each pair.
We first count the number of ways to partition a set of ` − q indices into subsets of
size 2. This number is exactly (` − q)!
2
(`−q)/2
((` − q)/2)!−1
. Furthermore, there are m
possible values that can be assigned to the pair of indices in each of the (` − q)/2 subsets
such that ei +ej = 0 within each subset. Note that assigning m possible values to each pair
of indices in the (` − q)/2 subsets overcounts, but this rough upper bound is sufficient for
our purposes.
Combining the three arguments, we conclude
X
d
i1,...,i`=1
1[ei1+···+ei`
=S] ≤

`
q

q! · (` − q)! · m(`−q)/2
.2
(`−q)/2
((` − q)/2)!
.
which yields the claim.
2 
Optimal Quantum Sample Complexity of Learning Algorithms
Continuing with the evaluation of the Fourier coefficient and using the claim above,
we have
fb(S) = X
T
`=0

T
`

1 −
β
2
T −` β
2m
` Xm
i1,...,i`=1
1[ei1+···+ei`
=S]
≤
X
T
`=q

T
`

1 −
β
2
T −` β
2m
`
`! · m(`−q)/2
.2
(`−q)/2
` − q
2

!

(by Claim 22)
=

1 −
β
2
T  2
m
q/2X
T
`=q

T
`

`!
 β
m(2 − β)
`m
2
`/2.` − q
2

!
≤

1 −
β
2
T  2
m
q/2X
T
`=q

T ·
β
m
·
r
m
2
`.` − q
2

! (since β < 1 and
T
`

`! ≤ T
`
)
=

1 −
β
2
T  2
m
q/2 T β
√
2m
q
T
X−q
r=0
 T β
√
2m
r 1
(r/2)! (substituting r ← (` − q))
≤

1 −
β
2
T T β
m
q
T
X−q
r=0
 T β
√
2m
r e
r/2
(r/2)r/2
(using n! ≥ (n/e)
n
)
=

1 −
β
2
T T β
m
q
T
X−q
r=0
√
eT β
√
mr
r
≤

1 −
β
2
T T β
m
qX
T
r=0
√
eT β
√
mr
r
(since the summands are ≥ 0)
=

1 −
β
2
T T β
m
q
de
3T
2β
2 X
/me
r=0
√
eT β
√
mr
r
+
X
T
r=de
3T2β2/me+1
√
eT β
√
mr
r
.
Note that by the assumptions of the theorem, T
2
e
3β
2/m ≤ T β ≤ T, which allowed us to
split the sum into two pieces in the last equality. At this point, we upper bound both pieces
in the last equation separately. For the first piece, using Claim 6 it follows that  √
eT β
√
mr r
is
maximized at r = dT
2β
2/me. Hence we get
de
3T
2β
2 X
/me
r=0
√
eT β
√
mr
r
≤

2 +
e
3T
2β
2
m

e
dT
2β
2/me/2 ≤ 2e
22T
2β
2/m+1
, (6)
where the first inequality uses Claim 6 and the second inequality uses 2 + x ≤ 2e
x
for x ≥ 0
and e
3 + 1/2 ≤ 22. For the second piece, we use
X
T
r=de
3T2β2/me+1
√
eT β
√
mr
r
≤
X
T
r=de
3T2β2/me+1
1
e
r
≤
X
T
r=1
1
e
r
=
1 − e
−T
e − 1
≤ 2/3. (7)
2 
Arunachalam and de Wolf
So we finally get
fb(S) ≤

1 −
β
2
T T β
m
q
2e
22T
2β
2/m+1 + 2/3

(using Eq. (6), (7))
≤ 4e

1 −
β
2
T T β
m
q
e
22T
2β
2/m (since 22T
2β
2/m > 0)
The theorem follows by putting together Claim 20 and Lemma 21:
√
A(x, x) = 1
2
k/2
X
Q∈{0,1}
k
s X
S∈{0,1}m:MtS=Q
fb(S) (using Claim 20)
≤
1
2
k/2
X
Q∈{0,1}
k
X
S∈{0,1}m:MtS=Q
q
fb(S) (using lower bound from Lemma 21)
=
1
2
k/2
X
S∈{0,1}m
q
fb(S) (∪Q{S : MtS = Q} = {0, 1}
m since rank(M)=k)
=
1
2
k/2
Xm
q=0
X
S∈{0,1}m:|S|=q
q
fb(S)
≤
2
√
e
2
k/2

1 −
β
2
T /2
e
11T
2β
2/mXm
q=0

m
q
T β
m
q/2
(using Lemma 21)
=
2
√
e
2
k/2

1 −
β
2
T /2
e
11T
2β
2/m
1 + r
T β
m
m
(using binomial theorem)
≤
2
√
e
2
k/2

1 −
β
2
T /2
e
11T
2β
2/m+
√
Tmβ
. (using (1 + x)
t ≤ e
xt for x, t ≥ 0)
4.1. Optimal lower bound for quantum PAC learning
We can now prove our tight lower bound on quantum sample complexity in the PAC model:
Theorem 23 Let C be a concept class with VC-dim(C ) = d + 1, for sufficiently large d.
Then for every δ ∈ (0, 1/2) and ε ∈ (0, 1/20), every (ε, δ)-PAC quantum learner for C has
sample complexity Ω

d
ε +
1
ε
log 1
δ

.
Proof The d-independent part of the lower bound is Lemma 11. To prove the d-dependent
part, define a distribution D on a set S = {s0, . . . , sd} ⊆ {0, 1}
n
that is shattered by C as
follows: D(s0) = 1 − 20ε and D(si) = 20ε/d for all i ∈ [d].
Now consider a [d, k, r]2 linear code (for k ≥ d/4, distance r ≥ d/8) as shown to exist in
Theorem 4 with the generator matrix M ∈ F
d×k
2
of rank k. Let {Mx : x ∈ {0, 1}
k} ⊆ {0, 1}
d
be the set of codewords in this linear code; these satisfy dH(Mx, My) ≥ d/8 whenever x 6= y.
For each x ∈ {0, 1}
k
, let c
x be a concept defined on the shattered set as: c
x
(s0) = 0 and
26
Optimal Quantum Sample Complexity of Learning Algorithms
c
x
(si) = (Mx)i for all i ∈ [d]. The existence of such concepts in C follows from the fact
that S is shattered by C . From the distance property of the code, we have Prs∼D[c
x
(s) 6=
c
y
(s)] ≥
20ε
d
d
8 = 5ε/2. This in particular implies that an (ε, δ)-PAC quantum learner that
tries to ε-approximate a concept from {c
x
: x ∈ {0, 1}
k} should successfully identify that
concept with probability at least 1 − δ.
We now consider the following state-identification problem: for x ∈ {0, 1}
k
, denote
|ψxi =
P
i∈{0,...,d}
p
D(si)|si
, cx
(si)i. Let the (ε, δ)-PAC quantum sample complexity be T.
Assume T ≤ d/(20e
3
ε), since otherwise T ≥ Ω(d/ε) and the theorem follows. Suppose
the learner has knowledge of the ensemble E = {(2−k
, |ψxi
⊗T
) : x ∈ {0, 1}
k}, and is given
|ψxi
⊗T ∈ E for a uniformly random x. The learner would like to maximize the average
probability of success to identify the given state. For this problem, we prove a lower bound
on T using the PGM defined in Section 2.6. In particular, we show that using the PGM,
if a learner successfully identifies the states in E, then T = Ω(d/ε). Since the PGM is
the optimal measurement6
that the learner could have performed, the result follows. The
following lemma makes this lower bound rigorous and will conclude the proof of the theorem.
Lemma 24 For every x ∈ {0, 1}
k
, let |ψxi =
P
i∈{0,...,d}
p
D(si)|si
, cx
(si)i, and E =
{(2−k
, |ψxi
⊗T
) : x ∈ {0, 1}
k}. Then
P
P GM (E) ≤
4e
2
d/4+T ε e
8800T
2ε
2/d+4√
5T dε
.
Before we prove the lemma, we first show why it implies the theorem. Since we observed
above that P
opt(E) = P
P GM (E), a good learner satisfies P
P GM (E) = Ω(1) (say for δ = 1/4),
which in turn implies (by taking logarithms) that Ω(d + T ε) ≤ O(T
2
ε
2/d +
√
T dε). Hence,
it follows that
Ω(max{d, T ε}) ≤ O(min{T
2
ε
2
/d, √
T dε}).
Note that if T ε maximizes the left-hand side, then d ≤ T ε and hence T ≥ Ω(d/ε). The
remaining cases are Ω(d) ≤ T
2
ε
2/d and Ω(d) ≤
√
T dε. Both these statements give us
T ≥ Ω(d/ε).7 Hence the theorem follows, and it remains to prove Lemma 24:
Proof Let E
0 = {2
−k/2
|ψxi
⊗T
: x ∈ {0, 1}
k} and G be the 2k × 2
k Gram matrix for E
0
.
As we saw in Section 2.6, the success probability of identifying the states in the ensemble
E using the PGM is
P
P GM (E) = X
x∈{0,1}
k
√
G(x, x)
2
.
6. For x ∈ {0, 1}
k
, define unitary Ucx : |si, bi → |si, b + c
x
(si)i for all i ∈ {0, . . . , d}. The ensemble E is
generated by applying {Ucx }x∈{0,1}k to |ϕi =
P
i∈{0,...,d}
p
D(si)|si, 0i. View c
x = (0, Mx) ∈ {0, 1}
d+1
as a concatenated string where Mx is a codeword of the [d, k, r]2 code. Since the 2k
codewords of
the [d, k, r]2 code form a linear subspace, {Ucx }x∈{0,1}k is an Abelian group. From the discussion in
Section 2.6, we conclude that the PGM is the optimal measurement for this state-identification problem.
7. We made no attempt to optimize the constants here. Also, we remark that this tight lower bound on
sample complexity implies that Lemma 21 is tight up to constant factors in the exponent.
27
Arunachalam and de Wolf
For all x, y ∈ {0, 1}
k
, the entries of the Gram matrix G can be written as:
G(x, y) = 1
2
k
hψx|ψyi
T =
1
2
k

(1 − 20ε) + 20ε
d
X
d
i=1
hc
x
(si)|c
y
(si)i
T
=
1
2
k

(1 − 20ε) + 20ε
d
(d − dH(Mx, My))T
=
1
2
k

1 −
20ε
d
dH(Mx, My)
T
,
where Mx, My ∈ {0, 1}
d are codewords in the linear code defined earlier. Define f :
{0, 1}
d → R as f(z) = (1 −
20ε
d
|z|)
T
, and let A(x, y) = (f ◦ M)(x + y) for x, y ∈ {0, 1}
k
.
Note that G = A/2
k
. Since we assumed T ≤ d/(20e
3
ε), we can use Theorem 18 (by choosing
m = d and β = 20ε) to upper bound the success probability of successfully identifying the
states in the ensemble E using the PGM.
P
P GM (E) = X
x∈{0,1}
k
√
G(x, x)
2
=
1
2
k
X
x∈{0,1}
k
√
A(x, x)
2
(since G = A/2
k
)
≤
4e
2
k

1 −
β
2
T
e
22T
2β
2/d+2√
T dβ (using Theorem 18)
=
4e
2
k

1 − 10ε
T
e
8800T
2ε
2/d+4√
5T dε (substituting β = 20ε)
≤
4e
2
k+T ε e
8800T
2ε
2/d+4√
5T dε (using (1 − 10ε)
T ≤ e
−10εT ≤ 2
−εT )
The lemma follows by observing that k ≥ d/4.
4.2. Optimal lower bound for quantum agnostic learning
We now use the same approach to obtain a tight lower bound on quantum sample complexity
in the agnostic setting.
Theorem 25 Let C be a concept class with VC-dim(C ) = d, for sufficiently large d. Then
for every δ ∈ (0, 1/2) and ε ∈ (0, 1/10), every (ε, δ)-agnostic quantum learner for C has
sample complexity Ω

d
ε
2 +
1
ε
2 log 1
δ

.
Proof The d-independent part of the lower bound is Lemma 12. For the d-dependent term
in the lower bound, consider a [d, k, r]2 linear code (for k ≥ d/4, distance r ≥ d/8) as shown
to exist in Theorem 4, with generator matrix M ∈ F
d×k
2
of rank k. Let {Mx : x ∈ {0, 1}
k} ⊆
28
Optimal Quantum Sample Complexity of Learning Algorithms
{0, 1}
d be the set of 2k
codewords in this linear code; these satisfy dH(Mx, My) ≥ d/8
whenever x 6= y. To each codeword x ∈ {0, 1}
k we associate a distribution Dx as follows:
Dx(si
, b) = 1
d
1
2
+
1
2
(−1)(Mx)i+bα

, for (i, b) ∈ [d] × {0, 1},
where S = {s1, . . . , sd} is a set that is shattered by C , and α is a parameter which we
shall pick later. Let c
x ∈ C be a concept that labels S according to Mx ∈ {0, 1}
d
. The
existence of such c
x ∈ C follows from the fact that S is shattered by C . Note that c
x
is
the minimal-error concept in C w.r.t. Dx. A learner that labels S according to some string
` ∈ {0, 1}
d has additional error dH(Mx, `) · α/d compared to c
x
. This in particular implies
that an (ε, δ)-agnostic quantum learner has to find (with probability at least 1 − δ) an `
such that dH(Mx, `) ≤ dε/α. We pick α = 20ε and we get dH(Mx, `) ≤ d/20. However,
since Mx was a codeword of a [d, k, r]2 code with distance r ≥ d/8, finding an ` satisfying
dH(Mx, `) ≤ d/20 is equivalent to identifying Mx, and hence x.
Now consider the following state-identification problem: for x ∈ {0, 1}
k
P
, let |ψxi =
(i,b)∈[d]×{0,1}
p
Dx(si
, b)|si
, bi. Let the (ε, δ)-agnostic quantum sample complexity be T.
Assume T ≤ d/(100e
3
ε
2
), since otherwise T ≥ Ω(d/ε2
) and the theorem follows. Suppose
the learner has knowledge of the ensemble E = {(2−k
, |ψxi
⊗T
) : x ∈ {0, 1}
k}, and is given
|ψxi
⊗T ∈ E for uniformly random x. The learner would like to maximize the average
probability of success to identify the given state. For this problem, we prove a lower bound
on T using the PGM defined in Section 2.6. In particular, we show that using the PGM,
if a learner successfully identifies the states in E, then T = Ω(d/ε2
). Since the PGM is
the optimal measurement8
that the learner could have performed, the result follows. The
following lemma makes this lower bound rigorous and will conclude the proof of the theorem.
Lemma 26 For x ∈ {0, 1}
k
, let |ψxi =
P
(i,b)∈[d]×{0,1}
p
Dx(si
, b)|si
, bi, and consider the
ensemble E = {(2−k
, |ψxi
⊗T
) : x ∈ {0, 1}
k}. Then
P
P GM (E) ≤
4e
e
(d ln 2)/4+25T ε2
e
220000T
2ε
4/d+20√
T dε2
.
Before we prove the lemma, we first show why it implies the theorem. Since we observed
above that P
opt(E) = P
P GM (E), a good learner satisfies P
P GM (E) = Ω(1) (say for δ = 1/4),
which in turn implies
Ω(max{d, T ε2
}) ≤ O(min{T
2
ε
4
/d, √
T dε2}).
Like in the proof of Theorem 23, this implies a lower bound of T = Ω(d/ε2
) and proves the
theorem. It remains to prove Lemma 26:
8. For x ∈ {0, 1}
k
, define unitary Ucx =
P
i∈[d]
|siihsi| ⊗ X
(Mx)i
, where X is the NOT-gate, so
X
(Mx)i
|bi = |b + (Mx)ii for b ∈ {0, 1}. The ensemble E is generated by applying {Ucx }x∈{0,1}k to
|ϕi = √1
d
P
(i,b)∈[d]×{0,1}
q1
2 +
1
2
(−1)bα|si, bi. Since the 2k
codewords of the [d, k, r]2 code form a linear
subspace, {Ucx }x∈{0,1}k is an Abelian group. From the discussion in Section 2.6, we conclude that the
PGM is the optimal measurement for this state-identification problem.
29
Arunachalam and de Wolf
Proof Let E
0 = {2
−k/2
|ψxi
⊗T
: x ∈ {0, 1}
k} and G be the 2k × 2
k Gram matrix for the
set E
0
. As we saw in Section 2.6, the success probability of identifying the states in the
ensemble E using the PGM is
P
P GM (E) = X
x∈{0,1}
k
√
G(x, x)
2
.
For all x, y ∈ {0, 1}
k
, the entries of G can be written as:
2
k
· G(x, y) = hψx|ψyi
T
=
 X
(i,b)∈[d]×{0,1}
q
Dx(i, b)Dy(i, b)
T
=
 1
2d
X
(i,b)∈[d]×{0,1}
q
(1 + 10ε(−1)(Mx)i+b)(1 + 10ε(−1)(M y)i+b)
T
=
 1
2d
X
(i,b):
(Mx)i=(M y)i
(1 + 10ε(−1)(Mx)i+b
) + 1
2d
X
(i,b):
(Mx)i6=(M y)i
p
1 − 100ε
2
T
=
d − dH(Mx, My)
d
+
√
1 − 100ε
2
d
dH(Mx, My)
T
=

1 −
1 −
√
1 − 100ε
2
d
dH(Mx, My)
T
.
where we used α = 20ε in the third equality.
Let β = 1 −
√
1 − 100ε
2, which is at most 1 for ε ≤ 1/10. Define f : {0, 1}
d → R as
f(z) = (1 −
β
d
|z|)
T
, and let A(x, y) = (f ◦ M)(x + y) for x, y ∈ {0, 1}
k
. Then G = A/2
k
.
Note that T ≤ d/(100e
3
ε
2
) ≤ d/(e
3β) (the first inequality is by assumption and the second
inequality follows for ε ≤ 1/10 and β ≤ 1). Since we assumed T ≤ d/(100e
3
ε
2
), we can
use Theorem 18 (by choosing m = d and β = 1 −
√
1 − 100ε
2) to upper bound the success
probability of identifying the states in the ensemble E:
P
P GM (E) = X
x∈{0,1}
k
√
G(x, x)
2
=
1
2
k
X
x∈{0,1}
k
√
A(x, x)
2
(since G = A/2
k
)
≤
4e
2
k

1 −
β
2
T
e
22T
2β
2/d+2√
T dβ (using Theorem 18)
≤
4e
2
k

1 −
β
2
T
e
220000T
2ε
4/d+20√
T dε2
(using β = 1 −
√
1 − 100ε
2 ≤ 100ε
2
)
≤
4e
2
k

1 − 25ε
2
T
e
220000T
2ε
4/d+20√
T dε2
(using √
1 − 100ε
2 ≤ 1 − 50ε
2
)
≤
4e
e
k ln 2+25T ε2
e
220000T
2ε
4/d+20√
T dε2
. (using (1 − x)
t ≤ e
−xt for x, t ≥ 0)
The lemma follows by observing that k ≥ d/4.
30
Optimal Quantum Sample Complexity of Learning Algorithms
4.3. Additional results
In this section we mention two additional results that can also be obtained using Theorem 18.
4.3.1. Quantum PAC sample complexity under random classification noise
In the theorem below, we show a lower bound on the quantum PAC sample complexity
under the random classification noise model with noise rate η. Recall that in this model,
for every c ∈ C and distribution D, ε, δ > 0, given access to copies of the η-noisy state,
X
x∈{0,1}n
p
(1 − η)D(x)|x, c(x)i +
p
ηD(x)|x, 1 − c(x)i,
a (ε, δ)-PAC quantum learner is required to output an hypothesis h such that errD(c, h) ≤ ε
with probability at least 1 − δ.
Theorem 27 Let C be a concept class with VC-dim(C ) = d + 1, for sufficiently large d.
Then for every δ ∈ (0, 1/2), ε ∈ (0, 1/20) and η ∈ (0, 1/2), every (ε, δ)-PAC quantum learner
for C in the PAC setting with random classification noise rate η, has sample complexity
Ω

d
(1−2η)
2ε +
log(1/δ)
(1−2η)
2ε

.
One can use exactly the same proof technique as in Lemma 11 and Theorem 23 to
prove this, with only the additional inequality 1 − 2
p
η(1 − η) ≤ (1 − 2η)
2
, which holds for
η ≤ 1/2. We omit the details of the calculation.
4.3.2. Distinguishing codeword states
Ashley Montanaro (personal communication) alerted us to the following interesting special
case of our PGM-based result.
Consider an [n, k, d]2 linear code {Mx : x ∈ {0, 1}
k}, where M ∈ F
n×k
2
is the rank-k
generator matrix of the code, k = Ω(n), and distinct codewords have Hamming distance at
least d.
9 For every x ∈ {0, 1}
k
, define a codeword state |ψxi = √
1
n
P
i∈[n]
|i,(Mx)ii. These
states form an example of a quantum fingerprinting scheme considered earlier by Buhrman
et al. (2001): 2k
states whose pairwise inner products are bounded away from 1. How many
copies do we need to identify one such fingerprint?
Let E = {(2−k
, |ψxi) : x ∈ {0, 1}
k} be an ensemble of codeword states. Consider the
following task: given T copies of an unknown state drawn uniformly from E, we are required
to identify the state with probability ≥ 4/5. From Holevo’s theorem one can easily obtain
a lower bound of T = Ω(k/ log n) copies, since the learner should obtain Ω(k) bits of
information (i.e., identify k-bit string x with probability ≥ 4/5), while each copy of the
codeword state gives at most log n bits of information. In the theorem below, we improve
that Ω(k/ log n) to the optimal Ω(k) for constant-rate codes.
Theorem 28 Let E = {|ψxi = √
1
n
P
i∈[n]
|i,(Mx)ii : x ∈ {0, 1}
k}, where M ∈ F
n×k
2
is
the generator matrix of an [n, k, d]2 linear code with k = Ω(n). Then Ω(k) copies of an
9. Note that throughout this paper C was a concept class in {0, 1}
n
and d was the VC dimension of C .
The use of n, d in this section has been changed to conform to the convention in coding theory.
31
Arunachalam and de Wolf
unknown state from E (drawn uniformly at random) are necessary to be able to identify that
state with probability at least 4/5.
One can use exactly the proof technique of Theorem 23 to prove the theorem. Suppose
we are given T copies of the unknown codeword state. Assume T ≤ n, since otherwise
T ≥ n ≥
√
kn and the theorem follows. Observe that the Gram matrix G for E
0 =
{2
−k/2
|ψxi
⊗T
: x ∈ {0, 1}
k} can be written as G(x, y) = 1
2
k

1−
|M(x+y)|
n
T
for x, y ∈ {0, 1}
k
.
Using Theorem 18 (choosing β = 1 and m = n) to upper bound the success probability of
successfully identifying the states in the ensemble E using the PGM, we obtain
P
P GM (E) ≤
4e
2
k+T
e
22T
2/n+2√
T n
.
As in the proof of Theorem 23, this implies the lower bound of Theorem 28. We omit the
details of the calculation.
5. Conclusion
The main result of this paper is that quantum examples give no significant improvement over
the usual random examples in passive, distribution-independent settings. Of course, these
negative results do not mean that quantum machine learning is useless. In our introduction
we already mentioned improvements from quantum examples for learning under the uniform
distribution; improvements from using quantum membership queries; and improvements in
time complexity based on quantum algorithms like Grover’s and HHL. Quantum machine
learning is still in its infancy, and we hope for many more positive results.
We end by identifying a number of open questions for future work:
• We gave lower bounds on sample complexity for the rather benign random classification noise. What about other noise models, such as malicious noise?
• What is the quantum sample complexity for learning concepts whose range is [k]
rather than {0, 1}, for some k > 2? Even the classical sample complexity is not fully
determined yet (Shalev-Shwartz and Ben-David, 2014, Section 29.2).
• In the introduction we mentioned a few examples of learning under the uniform distribution where quantum examples are significantly more powerful than classical examples. Can we find more such examples of quantum improvements in sample complexity
in fixed-distribution settings?
• Can we find more examples of quantum speed-up in time complexity of learning?