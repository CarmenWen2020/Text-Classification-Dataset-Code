
In this paper, we study the efficiency of a Restarted SubGradient (RSG) method that
periodically restarts the standard subgradient method (SG). We show that, when applied
to a broad class of convex optimization problems, RSG method can find an -optimal
solution with a lower complexity than the SG method. In particular, we first show that
RSG can reduce the dependence of SGâ€™s iteration complexity on the distance between the
initial solution and the optimal set to that between the -level set and the optimal set
multiplied by a logarithmic factor. Moreover, we show the advantages of RSG over SG
in solving a broad family of problems that satisfy a local error bound condition, and also
demonstrate its advantages for three specific families of convex optimization problems with
different power constants in the local error bound condition. (a) For the problems whose
epigraph is a polyhedron, RSG is shown to converge linearly. (b) For the problems with
local quadratic growth property in the -sublevel set, RSG has an O(
1

log( 1

)) iteration
complexity. (c) For the problems that admit a local Kurdyka- Lojasiewicz property with a
power constant of Î² âˆˆ [0, 1), RSG has an O(
1

2Î² log( 1

)) iteration complexity. The novelty
of our analysis lies at exploiting the lower bound of the first-order optimality residual at the
-level set. It is this novelty that allows us to explore the local properties of functions (e.g.,
local quadratic growth property, local Kurdyka- Lojasiewicz property, more generally local
error bound conditions) to develop the improved convergence of RSG. We also develop
a practical variant of RSG enjoying faster convergence than the SG method, which can
be run without knowing the involved parameters in the local error bound condition. We
demonstrate the effectiveness of the proposed algorithms on several machine learning tasks
including regression, classification and matrix completion.
Keywords: subgradient method, improved convergence, local error bound, machine
learning
1. Introduction
We consider the following generic optimization problem
fâˆ— := min
wâˆˆâ„¦
f(w), (1)
âˆ—. Correspondence
c 2018 Tianbao Yang and Qihang Lin.
License: CC-BY 4.0, see https://creativecommons.org/licenses/by/4.0/. Attribution requirements are provided
at http://jmlr.org/papers/v19/17-016.html.
Yang and Lin
where f : R
d â†’ (âˆ’âˆ, +âˆ] is an extended-valued, lower semicontinuous and convex function, and â„¦ âŠ† R
d
is a closed convex set such that â„¦ âŠ† dom(f). Here, we do not assume
the smoothness of f on dom(f). During the past several decades, many fast (especially
linearly convergent) optimization algorithms have been developed for (1) when f is smooth
and/or strongly convex. On the contrary, there are relatively fewer techniques for solving
generic non-smooth and non-strongly convex optimization problems, which have many applications in machine learning, statistics, computer vision, and etc. To solve (1) with f
being potentially non-smooth and non-strongly convex, one of the simplest algorithms to
use is the subgradient (SG) 1 method. When f is Lipschitz-continuous, it is known that
SG method requires O(1/2
) iterations for obtaining an -optimal solution (Rockafellar,
1970; Nesterov, 2004). It has been shown that this iteration complexity is unimprovable
for general non-smooth and non-strongly convex problems in a black-box first-order oracle model of computation (Nemirovsky A.S. and Yudin, 1983). However, better iteration
complexity can be achieved by other first-order algorithms for certain classes of f where
additional structural information is available (Nesterov, 2005; Gilpin et al., 2012; Freund
and Lu, 2017; Renegar, 2014, 2015, 2016).
In this paper, we present a generic restarted subgradient (RSG) method for solving (1)
which runs in multiple stages with each stage warm-started by the solution from the previous
stage. Within each stage, the standard projected subgradient update is performed for a
fixed number of iterations with a constant step size. This step size is reduced geometrically
from stage to stage. With these schemes, we show that RSG can achieve a lower iteration
complexity than the classical SG method when f belongs to some classes of functions. In
particular, we summarize the main results and properties of RSG below:
â€¢ For the general problem (1), under mild assumptions (see Assumption 1 and 2), RSG
has an iteration complexity of O(
1

2 log( 0

)) which has an additional log( 0

)
2
term but
has significantly smaller constant in O(Â·) compared to SG. In particular, compared
with SG whose iteration complexity quadratically depends on the distance from the
initial solution to the optimal set, RSGâ€™s iteration complexity has a quadratic dependence on the distance from the -level set to the optimal set, which is much smaller
than the distance from the initial solution to the optimal set. Its dependence on the
initial solution is through 0 - a known upper bound of the initial optimality gap,
which only scales logarithmically.
â€¢ When the epigraph of f over â„¦ is a polyhedron, RSG can achieve linear convergence,
i.e., an O(log( 1

)) iteration complexity.
â€¢ When f is locally quadratically growing (see Definition 10), which is a weaker condition than strong convexity, RSG can achieve an O(
1

log( 1

)) iteration complexity.
â€¢ When f admits a local Kurdyka- Lojasiewicz property (see Definition 13) with a
power desingularizing function of degree 1 âˆ’ Î² where Î² âˆˆ [0, 1), RSG can achieve
an O(
1

2Î² log( 1

)) complexity.
1. In this paper, we use SG to refer deterministic subgradient method, though it is used in literature for
stochastic gradient methods.
2. 0 is a known upper bound of the initial optimality gap in terms of the objective value.
2
RSG: Beating Subgradient Method without Smoothness and Strong Convexity
These results, except for the first one, are derived from a generic complexity of RSG for the
problem satisfying a local error condition (15), which has a close connection to the existing
error bound conditions and growth conditions in the literature (Pang, 1997, 1987; Luo and
Tseng, 1993; Necoara et al., 2015; Bolte et al., 2006). In spite of its simplicity, the analysis of
RSG provides additional insight on improving first-order methodsâ€™ iteration complexity via
restarting. It is known that restarting can improve the theoretical complexity of (stochastic)
SG method for non-smooth problems when strongly convexity is assumed (Ghadimi and
Lan, 2013; Chen et al., 2012; Hazan and Kale, 2011) but we show that restarting can be
still helpful for SG methods under other (weaker) assumptions. We would like to remark
that the key lemma (Lemma 4) developed in this work can be leveraged to develop faster
algorithms in different contexts. For example, built on the groundwork laid in this paper,
Xu et al. (2016) have developed new smoothing algorithms to improve the convergence
of Nesterovâ€™s smoothing algorithm (Nesterov, 2005) for non-smooth optimization with a
special structure, and Xu et al. (2017) have developed new stochastic subgradient methods
to improve the convergence of standard stochastic subgradient method.
We organize the reminder of the paper as follows. Section 2 reviews some related work.
Section 3 presents some preliminaries and notations. Section 4 presents the algorithm of
RSG and the general theory of convergence. Section 5 considers several classes of nonsmooth and non-strongly convex problems and shows the improved iteration complexities
of RSG. Section 6 presents parameter-free variants of RSG. Section 8 presents some experimental results. Finally, we conclude in Section 9.
2. Related Work
Smoothness and strong convexity are two key properties of a convex optimization problem
that affect the iteration complexity of finding an -optimal solution by first-order methods.
In general, a lower iteration complexity is expected when the problem is either smooth or
strongly convex. Recently there has emerged a surge of interest in further accelerating firstorder methods for non-strongly convex or non-smooth problems that satisfy some particular
conditions (Bach and Moulines, 2013; Wang and Lin, 2014; So and Zhou, 2017; Hou et al.,
2013; Zhou et al., 2015; Gong and Ye, 2014; Gilpin et al., 2012; Freund and Lu, 2017). The
key condition for us to develop an improved complexity is a local error bound condition (15)
which is closely related to the error bound conditions in the literature (Pang, 1987, 1997;
Luo and Tseng, 1993; Necoara et al., 2015; Bolte et al., 2006; Zhang, 2016).
Various error bound conditions have been exploited in many studies to analyze the
convergence of optimization algorithms. For example, Luo and Tseng (1992a,b, 1993) established the asymptotic linear convergence of a class of feasible descent algorithms for
smooth optimization, including coordinate descent method and projected gradient method,
based on a local error bound condition. Their results on coordinate descent method were
further extended to a more general class of objective functions and constraints by Tseng
and Yun (2009a,b). Wang and Lin (2014) showed that a global error bound holds for a
family of non-strongly convex and smooth objective functions for which feasible descent
methods can achieve a global linear convergence rate. Recently, these error bounds have
been generalized and leveraged to show faster convergence for structured convex optimization that consists of a smooth function and a simple non-smooth function (Hou et al., 2013;
3
Yang and Lin
Zhou and So, 2017; Zhou et al., 2015). Recently, Necoara and Clipici (2016) considered a
generalized error bound condition, and established linear convergence of a parallel version
of a randomized (block) coordinate descent method for minimizing the sum of a partially
separable smooth convex function and a fully separable non-smooth convex function.
We would like to emphasize that the aforementioned error bounds are different from the
local error bound explored in this paper. In particular, they bound the distance of a point
to the optimal set by using the norm of the projected gradient or proximal gradient at the
point, thus requiring the (partial) smoothness of the objective function. In contrast, we
bound the distance of a point to the optimal set by its objective residual with respect to the
optimal value, covering a much broader family of functions. More recently, there have appeared many studies that consider smooth optimization or composite smooth optimization
problems whose objective functions satisfy different error bound conditions, growth conditions or other non-degeneracy conditions and established the linear convergence rates of several first-order methods including proximal-gradient method, accelerated gradient method,
prox-linear method and so on (Gong and Ye, 2014; Necoara et al., 2015; Zhang and Cheng,
2015; Zhang, 2016; Karimi et al., 2016; Drusvyatskiy and Lewis, 2018; Drusvyatskiy and
Kempton, 2016; Hou et al., 2013; Zhou et al., 2015). The relative strength and relationships between some of those conditions are studied by Necoara et al. (2015) and Zhang
(2016). For example, Necoara et al. (2015) showed that under the smoothness assumption
the second-order growth condition (i.e., the considered error bound condition in the present
work with Î¸ = 1/2) is equivalent to the error bound condition considered by Wang and Lin
(2014). It was brought to our attention that the local error bound condition in the present
paper is closely related to metric subregularity of subdifferentials (Artacho and Geoffroy,
2008; Kruger, 2015; Drusvyatskiy et al., 2014; Mordukhovich and Ouyang, 2015).
Gilpin et al. (2012) established a polyhedral error bound condition for problems whose
epigraph is polyhedral and domain is a bounded polytope. Using this polyhedral error
bound condition, they studied a two-person zero-sum game and proposed a restarted firstorder method based on Nesterovâ€™s smoothing technique (Nesterov, 2005) that can find the
Nash equilibrium and has linear convergence rate. The differences between Gilpin et al.
(2012)â€™s work and this work are: (i) we study subgradient methods instead of Nesterovâ€™s
smoothing technique, where the former have broader applicability than Nesterovâ€™s smoothing technique; (ii) our linear convergence can be derived for a slightly general problem where
the domain is allowed to be an unbounded polyhedron as long as the polyhedral error bound
condition in Lemma 8 holds, which is the case for many important applications; (iii) we
consider a general condition that subsumes the polyhedral error bound condition as a special case and we try to solve the general problem (1) rather than the bilinear saddle-point
problem considered by Gilpin et al. (2012).
The error bound condition that allows us to derive a linear convergence of RSG is
the same to the weak sharp minimum condition, which was first coined in 1970s (Polyak,
1979). However, it was used even earlier for studying the convergence of subgradient
method (Eremin, 1965; Polyak, 1969). Later, it was studied in many subsequent works (Polyak,
1987; Burke and Ferris., 1993; Studniarski and Ward, 1999; Ferris, 1991; Burke and Deng,
2002, 2005, 2009). Finite or linear convergence of several algorithms has been established
under the weak sharp minimum condition, including gradient projection method (Polyak,
1987), the proximal point algorithm (PPA) (Ferris, 1991), and subgradient method with a
4
RSG: Beating Subgradient Method without Smoothness and Strong Convexity
particular choice of step size (see below) (Polyak, 1969). We would like to emphasize the
differences between the results in these works and the results in the present work that make
our results novel: (i) the gradient projection method and its finite convergence established
in (Polyak, 1987) requires the gradient of the objective function to be Lipschitz continuous,
i.e., the objective function is smooth (see Polyak, 1987, Chap. 7, pp 207, Theorem 1),
in contrast we do not assume smoothness of the objective function; (ii) the PPA studied
in (Ferris, 1991) requires solving a proximal sub-problem consisting of the original objective
function and a strongly convex function at every iteration, and therefore its finite convergence does not mean that only a finite number of subgradient evaluations is needed. In
contrast, the linear convergence in this paper was in terms of the number of subgradient
evaluations; (iii) linear convergence of a subgradient method studied by Polyak (1969) requires knowing the optimal objective value for setting its step size, and its convergence is
in terms of the distance of the iterates to the optimal set, which is weaker than our linear
convergence in terms of objective gap. In addition, our method does not require knowing
the optimal objective value. Instead the basic variant of RSG that has a linear convergence only needs to know the value of the multiplicative constant parameter in the local
error bound condition. For problems without knowing this parameter, we also develop a
practical variant of RSG that can achieve a convergence rate close to linear convergence.
In his recent work (Renegar, 2014, 2015, 2016), Renegar presented a framework of applying first-order methods to general conic optimization problems by transforming the original
problem into an equivalent convex optimization problem with only linear equality constraints and a Lipschitz-continuous objective function. This framework greatly extends the
applicability of first-order methods to the problems with general linear inequality constraints
and leads to new algorithms and new iteration complexity. One of his results related to
this work implies (Renegar, 2015, Corollary 3.4), if the objective function has a polyhedral
epigraph and the optimal objective value is known beforehand, a subgradient method can
have a linear convergence rate. Compared to this result of his, our method does not need to
know the optimal objective value. Note that Renegarâ€™s method can be applied in a general
setting where the objective function is not necessarily polyhedral while our method obtains
improved iteration complexities under the local error bound conditions.
More recently, Freund and Lu (2017) proposed a new SG method by assuming that
a strict lower bound of fâˆ—, denoted by fslb, is known and f satisfies a growth condition,
kw âˆ’ wâˆ—k2 â‰¤ G Â· (f(w) âˆ’ fslb), where wâˆ—
is the optimal solution closest to w and G
is a growth rate constant depending on fslb. Using a novel step size that incorporates
fslb, for non-smooth optimization, their SG method achieves an iteration complexity of
O(G
2
(
log H

0 +
1

02 )) for finding a solution wË† such that f(wË† ) âˆ’ fâˆ— â‰¤ 
0
(fâˆ— âˆ’ fslb), where
H =
f(w0)âˆ’fslb
fâˆ—âˆ’fslb
and w0 is the initial solution. We note that there are several key differences
in the theoretical properties and implementations between our work and that by Freund
and Lu (2017): (i) Their growth condition has a similar form to the inequality (7) proved
for a general function but there are still noticeable differences in the both sides and the
growth constants. (ii) The convergence results established by Freund and Lu (2017) are
based on finding an solution wË† with a relative error of 
0 while we consider absolute error.
(iii) By rewriting the convergence results of Freund and Lu (2017) in terms of absolute
accuracy  with  = 
0
(fâˆ— âˆ’fslb), their algorithmâ€™s complexity depends on fâˆ— âˆ’fslb and may
be higher than ours if fâˆ— âˆ’ fslb is large. However, Freund and Luâ€™s new SG method is still
5
Yang and Lin
attractive due to that it is a parameter free algorithm without requiring the value of the
growth constant G. We will compared our RSG method with the method of Freund and Lu
(2017) with more details in Section 7.
Restarting and multi-stage strategies have been employed to achieve the (uniformly) optimal theoretical complexity of (stochastic) SG methods when f is strongly convex (Ghadimi
and Lan, 2013; Chen et al., 2012; Hazan and Kale, 2011) or uniformly convex (Juditsky and
Nesterov, 2014). Here, we show that restarting can be still helpful even without uniform or
strong convexity. Furthermore, in all the algorithms proposed in existing works (Ghadimi
and Lan, 2013; Chen et al., 2012; Hazan and Kale, 2011; Juditsky and Nesterov, 2014), the
number of iterations per stage increases between stages while our algorithm uses the same
number of iterations in all stages. This provides a different possibility of designing restarted
algorithms for a better complexity only under a local error bound condition.
3. Preliminaries
In this section, we define some notations used in this paper and present the main assumptions needed to establish our results. We use âˆ‚f(w) to denote the set of subgradients (the
subdifferential) of f at w. Since the objective function is not necessarily strongly convex,
the optimal solution is not necessarily unique. We denote by â„¦âˆ— the optimal solution set
and by fâˆ— the unique optimal objective value. We denote by k Â· k2 the Euclidean norm in
R
d
.
Throughout the paper, we make the following assumption.
Assumption 1 For the convex minimization problem (1), we assume
a. For any w0 âˆˆ â„¦, we know a constant 0 â‰¥ 0 such that f(w0) âˆ’ fâˆ— â‰¤ 0.
b. There exists a constant G such that maxvâˆˆâˆ‚f(w) kvk2 â‰¤ G for any w âˆˆ â„¦.
We make several remarks about the above assumptions: (i) Assumption 1.a is equivalent
to assuming we know a lower bound of fâˆ— which is one of the assumptions made by Freund
and Lu (2017). In machine learning applications, fâˆ— is usually bounded below by zero, i.e.,
fâˆ— â‰¥ 0, so that 0 = f(w0) for any w0 âˆˆ R
d will satisfy the condition; (ii) Assumption 1.b
is a standard assumption also made in many previous subgradient-based methods.
Let wâˆ— denote the closest optimal solution in â„¦âˆ— to w measured in terms of norm k Â· k2,
i.e.,
wâˆ—
:= arg min
uâˆˆâ„¦âˆ—
ku âˆ’ wk
2
2
.
Note that wâˆ—
is uniquely defined for any w due to the convexity of â„¦âˆ— and that k Â· k2
2
is
strongly convex. We denote by L the -level set of f(w) and by S the -sublevel set of
f(w), respectively, i.e.,
L := {w âˆˆ â„¦ : f(w) = fâˆ— + } and S := {w âˆˆ â„¦ : f(w) â‰¤ fâˆ— + }. (2)
Let B be the maximum distance between the points in the -level set L and the optimal
set â„¦âˆ—, i.e.,
B := max
wâˆˆL
min
uâˆˆâ„¦âˆ—
kw âˆ’ uk2 = max
wâˆˆL
kw âˆ’ wâˆ—
k2. (3)
In the sequel, we also make the following assumption.
6
RSG: Beating Subgradient Method without Smoothness and Strong Convexity
Assumption 2 For the convex minimization problem (1), we assume that B is finite.
Remark: B is finite when the optimal set â„¦âˆ— is bounded (e.g., when the objective function
is a proper lower-semicontinuous convex and coercive function). This is because that the
sublevel set S must be bounded for any  â‰¥ 0 (Rockafellar, 1970, Corollary 8.7.1). Nevertheless, the bounded optimal set is not a necessary condition for a finite B. For example,
f(x) = max(0, x). Although its optimal set is not bounded, B = . In Section 5, we will
consider a broad family of problems with a local error bound condition, which will satisfy
the above assumption.
Let w
â€ 
 denote the closest point in the -sublevel set to w, i.e.,
wâ€ 

:= arg min
uâˆˆS
ku âˆ’ wk
2
2
. (4)
Denote by â„¦\S = {w âˆˆ â„¦ : w 6âˆˆ S}. It is easy to show that w
â€ 
 âˆˆ L when w âˆˆ â„¦\S (using
the optimality condition of 4).
Given w âˆˆ â„¦, we denote the normal cone of â„¦ at w by Nâ„¦(w). Formally, Nâ„¦(w) =
{v âˆˆ R
d
: v
>(u âˆ’ w) â‰¤ 0, âˆ€u âˆˆ â„¦}. Define dist(0, f(w) + Nâ„¦(w)) as
dist(0, f(w) + Nâ„¦(w)) := min
gâˆˆâˆ‚f(w),vâˆˆNâ„¦(w)
kg + vk2. (5)
Note that w âˆˆ â„¦âˆ— if and only if dist(0, f(w)+Nâ„¦(w)) = 0. Therefore, we call dist(0, f(w)+
Nâ„¦(w)) the first-order optimality residual of (1) at w âˆˆ â„¦. Given any  > 0 such that
L 6= âˆ…, we define a constant Ï as
Ï := min
wâˆˆL
dist(0, f(w) + Nâ„¦(w)). (6)
Given the notations above, we provide the following lemma which is the key to our
analysis.
Lemma 1 For any  > 0 such that L 6= âˆ… and any w âˆˆ â„¦, we have
kw âˆ’ wâ€ 
k2 â‰¤
1
Ï
(f(w) âˆ’ f(wâ€ 

)). (7)
Proof Since the conclusion holds trivially if w âˆˆ S (so that w
â€ 
 = w), we assume w âˆˆ â„¦\S.
According to the first-order optimality conditions of (4), there exist a scalar Î¶ â‰¥ 0 (the
Lagrangian multiplier of the constraint f(u) â‰¤ fâˆ— +  in 4), a subgradient g âˆˆ âˆ‚f(w
â€ 
 ) and
a vector v âˆˆ Nâ„¦(w
â€ 
 ) such that
wâ€ 
 âˆ’ w + Î¶g + v = 0. (8)
The definition of normal cone leads to (w
â€ 
 âˆ’ w)
>v â‰¥ 0. This inequality and the convexity
of f(Â·) imply
Î¶

f(w) âˆ’ f(wâ€ 

)

â‰¥ Î¶(w âˆ’ wâ€ 

)
>g â‰¥ (w âˆ’ wâ€ 

)
> (Î¶g + v) = kw âˆ’ wâ€ 
k
2
2
,
7
Yang and Lin
where the equality is due to (8). Since w âˆˆ â„¦\S, we must have kw âˆ’ w
â€ 
k2 > 0 so that
Î¶ > 0. Therefore, w
â€ 
 âˆˆ L by complementary slackness. Dividing the inequality above by
Î¶ gives
f(w) âˆ’ f(wâ€ 

) â‰¥
kw âˆ’ w
â€ 
k
2
2
Î¶
= kw âˆ’ wâ€ 
k2kg + v/Î¶k2 â‰¥ Ïkw âˆ’ wâ€ 
k2, (9)
where the equality is due to (8) and the last inequality is due to the definition of Ï in (6).
The lemma is then proved.
The inequality in (7) is the key to achieve improved convergence by RSG, which hinges
on the condition that the first-order optimality residual on the -level set is lower bounded.
It is important to note that (i) the above result depends on f rather than the optimization
algorithm applied; and (ii) the above result can be generalized to using other norms such
as the p-norm kwkp (p âˆˆ (1, 2]) to measure the distance between w and w
â€ 
 and using the
corresponding dual norm to define the lower bound of the residual in (5) and (6). This
generalization allows one to design mirror decent (Nemirovski et al., 2009) variant of RSG.
To our best knowledge, this is the first work that leverages the lower bound of the optimal
residual to improve the convergence for non-smooth convex optimization.
In the next several sections, we will exhibit the value of Ï for different classes of problems
and discuss its impact on the convergence. In the sequel, we abuse the Big O notation
T = O(h()) to mean that there exists a constant C > 0 independent of  such that
T â‰¤ Ch().
4. Restarted SubGradient (RSG) Method and Its Generic Complexity
for General Problem
In this section, we present a framework of restarted subgradient (RSG) method and prove
its general convergence result using Lemma 1. It will be noticed that the algorithmic results
developed in this section is less interesting from the viewpoint of practice. However, it will
exhibit the insights for the improvements and provide the template for the developments in
next several sections, where we will present improved convergence of RSG for problems of
different classes.
The steps of RSG are presented in Algorithm 2 where SG is a subroutine of projected
subgradient method given in Algorithm 1 and Î â„¦[w] is defined as
Î â„¦[w] = arg min
uâˆˆâ„¦
ku âˆ’ wk
2
2
.
The values of K and t in RSG will be revealed later for proving the convergence of RSG to
an 2-optimal solution. The number of iterations t is the only varying parameter in RSG
that depends on the classes of problems. The parameter Î± could be any value larger than
1 (e.g., 2) and it only has a small influence on the iteration complexity.
We emphasize that (i) RSG is a generic algorithm that is applicable to a broad family
of non-smooth and/or non-strongly convex problems without changing updating schemes
except for one tuning parameter, the number of iterations per stage, whose best value
varies with problems; (ii) RSG has different variants with different subroutines in stages. In
8
RSG: Beating Subgradient Method without Smoothness and Strong Convexity
Algorithm 1 SG: wb T = SG(w1, Î·, T)
1: Input: a step size Î·, the number of iterations T, and the initial solution w1 âˆˆ â„¦
2: for Ï„ = 1, . . . , T do
3: Query the subgradient oracle to obtain G(wÏ„ ) âˆˆ âˆ‚f(wÏ„ )
4: Update wÏ„+1 = Î â„¦[wÏ„ âˆ’ Î·G(wÏ„ )]
5: end for
6: Output: wb T =
PT
Ï„=1
wÏ„
T
Algorithm 2 RSG: wK = RSG(w0, K, t, Î±)
1: Input: the number of stages K and the number of iterations t per-stage, w0 âˆˆ â„¦, and
Î± > 1.
2: Set Î·1 = 0/(Î±G2
), where 0 is from Assumption 1.a
3: for k = 1, . . . , K do
4: Call subroutine SG to obtain wk = SG(wkâˆ’1, Î·k, t)
5: Set Î·k+1 = Î·k/Î±
6: end for
7: Output: wK
fact, we can use other optimization algorithms than SG as the subroutine in Algorithm 2,
as long as a similar convergence result to Lemma 2 is guaranteed. Examples include dual
averaging (Nesterov, 2009) and the regularized dual averaging (Chen et al., 2012) in the nonEuclidean space. In the following discussions, we will focus on using SG as the subroutine.
Next, we establish the convergence of RSG. It relies on the convergence result of the SG
subroutine which is given in the lemma below.
Lemma 2 (Zinkevich, 2003; Nesterov, 2004) If Algorithm 1 runs for T iterations, we have,
for any w âˆˆ â„¦,
f(wb T ) âˆ’ f(w) â‰¤
G2Î·
2
+
kw1 âˆ’ wk
2
2
2Î·T
.
We omit the proof because it follows a standard analysis and can be found in cited papers.
With the above lemma, we can prove the following convergence of RSG.
Theorem 3 Suppose Assumption 1 and 2 holds. If t â‰¥
Î±
2G2
Ï
2

and K = dlogÎ±(
0

)e in
Algorithm 2, with at most K stages, Algorithm 2 returns a solution wK such that f(wK) âˆ’
fâˆ— â‰¤ 2. The total number of iterations for Algorithm 2 to find an 2-optimal solution is at
most T = tdlogÎ±(
0

)e where t â‰¥
Î±
2G2
Ï
2

.
Remark: If t also satisfies t = O

Î±
2G2
Ï
2


, then the iteration complexity of Algorithm 2 for
finding an -optimal solution is O

Î±
2G2
Ï
2

dlogÎ±(
0

)e

.
Proof
Let w
â€ 
k, denote the closest point to wk in the -sublevel set. Let k := 0
Î±k so that
Î·k = k/G2 because Î·1 = 0/(Î±G2
) and Î·k+1 = Î·k/Î±. We will show by induction that
f(wk) âˆ’ fâˆ— â‰¤ k + , (10)
9
Yang and Lin
for k = 0, 1, . . . , K which leads to our conclusion if we let k = K.
Note that (10) holds obviously for k = 0. Suppose it holds for k âˆ’1, namely, f(wkâˆ’1)âˆ’
fâˆ— â‰¤ kâˆ’1 + . We want to prove (10) for k. We apply Lemma 2 to the k-th stage of
Algorithm 2 and get
f(wk) âˆ’ f(w
â€ 
kâˆ’1,
) â‰¤
G2Î·k
2
+
kwkâˆ’1 âˆ’ w
â€ 
kâˆ’1,
k
2
2
2Î·kt
. (11)
We now consider two cases for wkâˆ’1. First, assume f(wkâˆ’1)âˆ’fâˆ— â‰¤ , i.e., wkâˆ’1 âˆˆ S. Then
w
â€ 
kâˆ’1, = wkâˆ’1 and f(wk) âˆ’ f(w
â€ 
kâˆ’1,
) â‰¤
G2Î·k
2 =
k
2
. As a result,
f(wk) âˆ’ fâˆ— â‰¤ f(w
â€ 
kâˆ’1,
) âˆ’ fâˆ— +
k
2
â‰¤  + k.
Next, we consider the case that f(wkâˆ’1)âˆ’fâˆ— > , i.e., wkâˆ’1 6âˆˆ S. Then we have f(w
â€ 
kâˆ’1,
) =
fâˆ— + . By Lemma 1, we have
kwkâˆ’1 âˆ’ w
â€ 
kâˆ’1,
k2 â‰¤
1
Ï
(f(wkâˆ’1) âˆ’ f(w
â€ 
kâˆ’1,
)) =
f(wkâˆ’1) âˆ’ fâˆ— + (fâˆ— âˆ’ f(w
â€ 
kâˆ’1,
))
Ï
â‰¤
kâˆ’1 +  âˆ’ 
Ï
.
(12)
Combining (11) and (12) and using the facts that Î·k =
k
G2
and t â‰¥
Î±
2G2
Ï
2

, we have
f(wk) âˆ’ f(w
â€ 
kâˆ’1,
) â‰¤
k
2
+

2
kâˆ’1
2kÎ±2
= k,
which, together with the fact that f(w
â€ 
kâˆ’1,
) = fâˆ— + , implies (10) for k. Therefore, by
induction, we have (10) holds for k = 1, 2, . . . , K so that
f(wK) âˆ’ fâˆ— â‰¤ K +  =
0
Î±K
+  â‰¤ 2,
where the last inequality is due to the definition of K.
In Theorem 3, the iteration complexity of RSG for the general problem (1) is given
in terms of Ï. Next, we show that Ï â‰¥

B
, which allows us to leverage the local error
bound condition in next sections to upper bound B to obtain specialized and more practical
algorithms for different classes of problems.
Lemma 4 For any  > 0 such that L 6= âˆ…, we have Ï â‰¥

B
, where B is defined in (3),
and for any w âˆˆ â„¦
kw âˆ’ wâ€ 
k2 â‰¤
kw
â€ 
 âˆ’ wâˆ—
 k2

(f(w) âˆ’ f(wâ€ 

)) â‰¤
B

(f(w) âˆ’ f(wâ€ 

)), (13)
where wâˆ—

is the closest point in â„¦âˆ— to w
â€ 
 .
10
RSG: Beating Subgradient Method without Smoothness and Strong Convexity
Ç«
w
â€ 
Ç«
w
B
B â‰¤ dist(w
â€ 
Ç«
, â„¦âˆ—)
kw âˆ’ w
â€ 
Ç«
k
A â‰¤ f(w) âˆ’ f(w
â€ 
Ç«
)
wâˆ—
Î¸
Ç«
dist(w
â€ 
Ç«
,â„¦âˆ—)
â‰¤
Ç«
B
= tan Î¸ =
A
kwâˆ’w
â€ 
Ç«
k
â‰¤
f(w)âˆ’f(w
â€ 
Ç«
)
kwâˆ’w
â€ 
Ç«
k
f(Â·)
Figure 1: A geometric illustration of the inequality (13), where dist(w
â€ 
 , â„¦âˆ—) = |w
â€ 
 âˆ’ w
âˆ—

|.
Proof Given any u âˆˆ L, let gu be any subgradient in âˆ‚f(u) and vu be any vector in
Nâ„¦(u). By the convexity of f(Â·) and the definition of normal cone, we have
f(u
âˆ—
) âˆ’ f(u) â‰¥ (u
âˆ— âˆ’ u)
>gu â‰¥ (u
âˆ— âˆ’ u)
> (gu + vu),
where u
âˆ—
is the closest point in â„¦âˆ— to u. This inequality further implies
ku
âˆ— âˆ’ uk2kgu + vuk2 â‰¥ f(u) âˆ’ f(u
âˆ—
) = , âˆ€gu âˆˆ âˆ‚f(u) and vu âˆˆ Nâ„¦(u), (14)
where the equality is because u âˆˆ L. By (14) and the definition of B, we obtain
Bkgu + vuk2 â‰¥  =â‡’ kgu + vuk2 â‰¥ /B.
Since gu + vu can be any element in âˆ‚f(u) + Nâ„¦(u), we have Ï â‰¥

B
by the definition (6).
To prove (13), we assume w âˆˆ â„¦\S and thus w
â€ 
 âˆˆ L; otherwise it is trivial. In the
proof of Lemma 1, we have shown that (see (9)) there exists g âˆˆ âˆ‚f(w
â€ 
 ) and v âˆˆ Nâ„¦(w
â€ 
 )
such that f(w) âˆ’ f(w
â€ 
 ) â‰¥ kw âˆ’ w
â€ 
k2kg + v/Î¶k2, which, according to (14) with u = w
â€ 
 ,
gu = g and vu = v/Î¶, leads to (13).
A geometric explanation of the inequality (13) in one dimension is shown in Figure 1. With
Lemma 4, the iteration complexity of RSG can be stated in terms of B in the following
corollary of Theorem 3.
Corollary 5 Suppose Assumption 1 holds. The iteration complexity of RSG for obtaining
an 2-optimal solution is O(
Î±
2G2B2


2 dlogÎ±(
0

)e) provided t =
Î±
2G2B2


2 and K = dlogÎ±(
0

)e.
11
Yang and Lin
We will compare this result with SG in Section 7. Compared to the standard SG, the above
improved result of RSG does require knowing strong knolwedge about f. In particular, one
issue is that the above improved complexity is obtained by choosing t =
Î±
2G2B2


2 , which
requires knowing the order of magnitude of B, if not its exact value. To address the issue
of unknown B for general problems, in the next section, we consider different families
of problems that admit a local error bound condition and show that the requirement of
knowing B is relaxed to knowing some particular parameters related to the local error
bound.
5. RSG for Some Classes of Non-smooth Non-strongly Convex
Optimization
In this section, we consider a particular family of problems that admit local error bounds
and show the improved iteration complexities of RSG compared to standard SG method.
5.1 Complexity for the Problems with Local Error Bounds
We first define a local error bound condition of the objective function.
Definition 6 We say f(Â·) admits a local error bound on the -sublevel set S if
kw âˆ’ wâˆ—
k2 â‰¤ c(f(w) âˆ’ fâˆ—)
Î¸
, âˆ€w âˆˆ S, (15)
where wâˆ—
is the closet point in â„¦âˆ— to w, Î¸ âˆˆ (0, 1] and 0 < c < âˆ are constants.
Because S2 âŠ‚ S1
for 2 â‰¤ 1, if (15) holds for some , it will always hold when  decreases
to zero with the same Î¸ and c. Indeed, a smaller  may induce a smaller value of c. It is
notable that the local error bound condition has been extensively studied in the community of optimization, mathematical programming and variational analysis (Yang, 2009; Li,
2010, 2013; Artacho and Geoffroy, 2008; Kruger, 2015; Drusvyatskiy et al., 2014; Li and
Mordukhovich, 2012; Hou et al., 2013; Zhou and So, 2017; Zhou et al., 2015), to name just
a few of them. The value of Î¸ has been exhibited for many problems. For certain problems,
the value of c is also computable (see Bolte et al., 2017).
If the problem admits a local error bound like (15), RSG can achieve a better iteration
complexity than O(1/2
). In particular, the property (15) implies
B â‰¤ cÎ¸
. (16)
Replacing B in Corollary 5 by this upper bound and choosing t =
Î±
2G2
c
2

2(1âˆ’Î¸)
in RSG if c and
Î¸ are known, we obtain the following complexity of RSG.
Corollary 7 Suppose Assumption 1 holds and f(Â·) admits a local error bound on S. The
iteration complexity of RSG for obtaining an 2-optimal solution is O

Î±
2G2
c
2

2(1âˆ’Î¸)
logÎ±

0



provided t =
Î±
2G2
c
2

2(1âˆ’Î¸) and K = dlogÎ±(
0

)e.
Remark: If t = Î˜( Î±
2G2

2(1âˆ’Î¸)
) >
Î±
2G2
c
2

2(1âˆ’Î¸)
, then the same order of iteration complexity remains.
If one aims to find a point w such that kwâˆ’wâˆ—k2 â‰¤ , we can apply RSG to find a solution w
1 
RSG: Beating Subgradient Method without Smoothness and Strong Convexity
such that f(w) âˆ’ fâˆ— â‰¤ (/c)
1/Î¸ â‰¤  (where the last inequality is due to Î¸ â‰¤ 1 and assuming
c â‰¥ 1 without loss of generality). Then under the local error bound condition, we have
kwâˆ’wâˆ—k2 â‰¤ c(f(w)âˆ’fâˆ—)
Î¸ â‰¤ . For finding a solution w such that f(w)âˆ’fâˆ— â‰¤ (/c)
1/Î¸ â‰¤ ,
RSG requires an iteration complexity of Oe(
1

2(1âˆ’Î¸)/Î¸ ). Therefore, in order to find a solution
w such that kw âˆ’ wâˆ—k2 â‰¤ , the iteration complexity of RSG is Oe(
1

2(1âˆ’Î¸)/Î¸ ).
Next, we will consider different convex optimization problems that admit a local error
bound on S with different Î¸ and show the faster convergence of RSG when applied to these
problems.
5.2 Linear Convergence for Polyhedral Convex Optimization
In this subsection, we consider a special family of non-smooth and non-strongly convex
problems where the epigraph of f(Â·) over â„¦ is a polyhedron. In this case, we call (1) a
polyhedral convex minimization problem. We show that, in polyhedral convex minimization problem, f(Â·) has a linear growth property and admits a local error bound with
Î¸ = 1 so that B â‰¤ c for a constant c < âˆ.
Lemma 8 (Polyhedral Error Bound Condition) Suppose â„¦ is a polyhedron and the
epigraph of f(Â·) is also polyhedron. There exists a constant Îº > 0 such that
kw âˆ’ wâˆ—
k2 â‰¤
f(w) âˆ’ fâˆ—
Îº
, âˆ€w âˆˆ â„¦.
Thus, f(Â·) admits a local error bound on S with Î¸ = 1 and c =
1
Îº
3
(so B â‰¤

Îº
) for any
 > 0.
Remark: The above inequality is also known as weak sharp minimum condition in literature (Burke and Ferris., 1993; Studniarski and Ward, 1999; Ferris, 1991; Burke and Deng,
2002, 2005, 2009). A proof of Lemma 8 is given by Burke and Ferris. (1993). We also provide a proof (see Yang and Lin, 2016). We remark that the above result can be extended to
any valid norm to measure the distance between w and wâˆ—. Lemma 8 generalizes Lemma
4 of Gilpin et al. (2012), which requires â„¦ to be a bounded polyhedron, to a similar result
where â„¦ can be an unbounded polyhedron. This generalization is simple but useful because
it helps the development of efficient algorithms based on this error bound for unconstrained
problems without artificially including a box constraint.
Lemma 8 provides the basis for RSG to achieve a linear convergence for the polyhedral
convex minimization problems. In fact, the following linear convergence of RSG can be
obtained if we plugin the values of Î¸ = 1 and c =
1
Îº
into Corollary 7.
Corollary 9 Suppose Assumption 1 holds and (1) is a polyhedral convex minimization problem. The iteration complexity of RSG for obtaining an -optimal solution is O(
Î±
2G2
Îº2 dlogÎ±(
0

)e)
provided t =
Î±
2G2
Îº2 and K = dlogÎ±(
0

)e.
We want to point out that Corollary 9 can be proved directly by replacing w
â€ 
kâˆ’1,
by wâˆ—
kâˆ’1
and replacing Ï by Îº in the proof of Theorem 3. Here, we derive it as a corollary of a
3. In fact, this property of f(Â·) is a global error bound on â„¦.
13
Yang and Lin
more general result. We also want to mention that, as shown by Renegar (2015), the linear
convergence rate in Corollary 9 can be also obtained by a SG method for the historically
best solution, provided fâˆ— is known.
5.2.1 Examples
Many non-smooth and non-strongly convex machine learning problems satisfy the assumptions of Corollary 9, for example, `1 or `âˆ constrained or regularized piecewise linear
loss minimization. In many machine learning tasks (e.g., classification and regression),
there exists a set of data {(xi
, yi)}i=1,2,...,n and one often needs to solve the following empirical risk minimization problem
min
wâˆˆRd
f(w) ,
1
n
Xn
i=1
`(w>xi
, yi) + R(w),
where R(w) is a regularization term and `(z, y) denotes a loss function. We consider a
special case where (a) R(w) is a `1 regularizer, `âˆ regularizer or an indicator function of a
`1/`âˆ ball centered at zero; and (b) `(z, y) is any piecewise linear loss function, including
hinge loss `(z, y) = max(0, 1 âˆ’ yz), absolute loss `(z, y) = |z âˆ’ y|, -insensitive loss `(z, y) =
max(|z âˆ’y| âˆ’, 0), and etc (Yang et al., 2014). It is easy to show that the epigraph of f(w)
is a polyhedron if f(w) is defined as a sum of any of these regularization terms and any of
these loss functions. In fact, a piecewise linear loss functions can be generally written as
`(w>x, y) = max
1â‰¤jâ‰¤m
ajw>x + bj , (17)
where (aj , bj ) for j = 1, 2, . . . , m are finitely many pairs of scalars. The formulation (17)
indicates that `(w>x, y) is a piecewise affine function so that its epigraph is a polyhedron.
In addition, the `1 or `âˆ norm is also a polyhedral function because we can represent them
as
kwk1 =
X
d
i=1
max(wi
, âˆ’wi), kwkâˆ = max
1â‰¤iâ‰¤d
|wi
| = max
1â‰¤iâ‰¤d
max(wi
, âˆ’wi).
Since the sum of finitely many polyhedral functions is also a polyhedral function, the epigraph of f(w) is a polyhedron.
Another important family of problems whose objective function has a polyhedral epigraph is submodular function minimization. Let V = {1, . . . , d} be a set and 2V
denote its power set. A submodular function F(A) : 2V â†’ R is a set function such that
F(A)+F(B) â‰¥ F(AâˆªB)+F(Aâˆ©B) for all subsets A, B âŠ† V and F(âˆ…) = 0. A submodular
function minimization can be cast into a non-smooth convex optimization using the LovÂ´asz
extension (Bach, 2013). In particular, let the base polyhedron B(F) be defined as
B(F) = {s âˆˆ R
d
, s(V ) = F(V ), âˆ€A âŠ† V, s(A) â‰¤ F(A)},
where s(A) = P
iâˆˆA
si
. Then the LovÂ´asz extension of F(A) is f(w) = maxsâˆˆB(F) w>s,
and minAâŠ†V F(A) = minwâˆˆ[0,1]d f(w). As a result, a submodular function minimization is
essentially a non-smooth and non-strongly convex optimization with a polyhedral epigraph.
14
RSG: Beating Subgradient Method without Smoothness and Strong Convexity
5.3 Improved Convergence for Locally Semi-Strongly Convex Problems
First, we give a definition of local semi-strong convexity.
Definition 10 A function f(w) is semi-strongly convex on the -sublevel set S if there
exists Î» > 0 such that
Î»
2
kw âˆ’ wâˆ—
k
2
2 â‰¤ f(w) âˆ’ f(wâˆ—
), âˆ€w âˆˆ S, (18)
where wâˆ—
is the closest point to w in the optimal set.
We refer to the property (18) as local semi-strong convexity when S 6= â„¦. The two papers
(Gong and Ye, 2014; Necoara et al., 2015) have explored the semi-strong convexity on the
whole domain â„¦ to prove linear convergence of smooth optimization problems. In some
literature (Necoara et al., 2015), the inequality (18) is also called second-order growth
property. Necoara et al. (2015) have also shown that a class of problems satisfy (18) (see
examples given below). The inequality (18) indicates that f(Â·) admits a local error bound
on S with Î¸ =
1
2
and c =
q
2
Î»
, which leads to the following the corollary about the iteration
complexity of RSG for locally semi-strongly convex problems.
Corollary 11 Suppose Assumption 1 holds and f(w) is semi-strongly convex on S. Then
B â‰¤
q
2
Î»
4and the iteration complexity of RSG for obtaining an 2-optimal solution is
O(
2Î±
2G2
Î» dlogÎ±(
0

)e) provided t =
2Î±
2G2
Î» and K = dlogÎ±(
0

)e.
Remark: Here, we obtain an Oe(1/) iteration complexity (Oe(Â·) suppresses constants and
logarithmic terms) only with local semi-strong convexity. It is obvious that strong convexity
implies local semi-strong convexity (Hazan and Kale, 2011) but not vice versa.
For examples, let us consider a family of functions in the form of f(w) = h(Xw)+r(w),
where X âˆˆ R
nÃ—d
, h(Â·) is strongly convex on any compact set and r(Â·) has a polyhedral
epigraph. According to (Gong and Ye, 2014; Necoara et al., 2015), such a function f(w)
satisfies (18) for any  â‰¤ 0 with a constant value for Î». Although smoothness is assumed
for h(Â·) in (Gong and Ye, 2014; Necoara et al., 2015), we find that it is not necessary for
proving (18). We state this result as the lemma below.
Lemma 12 Suppose Assumption 1 holds, â„¦ = {w âˆˆ R
d
|Cw â‰¤ b} with C âˆˆ R
kÃ—d and
b âˆˆ R
k
, and f(w) = h(Xw) + r(w) where h : R
n â†’ R satisfies dom(h) = R
k and is a
strongly convex function on any compact set in R
n
, and r(w) has a polyhedral epigraph.
Then, f(w) satisfies (18) for any  â‰¤ 0.
The proof of this lemma can be duplicated following analysis in some existing works (Gong
and Ye, 2014; Necoara et al., 2015; Necoara and Clipici, 2016). For example, it is almost
identical to the proof of Lemma 1 by Gong and Ye (2014) which assumes h(Â·) is smooth.
However, a similar result holds without the smoothness of h(Â·).
4. Recall (16).
15
Yang and Lin
The function of this type covers some commonly used loss functions and regularization
terms in machine learning and statistics. For example, we can consider robust regression
with/without `1 regularizer (Xu et al., 2010; Bertsimas and Copenhaver, 2014):
min
wâˆˆâ„¦
1
n
Xn
i=1
|x
>
i w âˆ’ yi
|
p + Î»kwk1, (19)
where p âˆˆ (1, 2), xi âˆˆ R
d denotes the feature vector and yi
is the target output. The objective function is in the form of h(Xw) + r(w) where X is a n Ã— d matrix with x1, x2, . . . , xn
being its rows and h(u) := Pn
i=1 |ui âˆ’ yi
|
p
. According to Goebel and Rockafellar (2007),
h(u) is a strongly convex function on any compact set so that the objective function above
is semi-strongly convex on S for any  â‰¤ 0.
5.4 Improved Convergence for Convex Problems with KL property
Lastly, we consider a family of non-smooth functions with a local Kurdyka- Lojasiewicz (KL)
property. The definition of KL property is given below.
Definition 13 The function f(w) has the Kurdyka - Lojasiewicz (KL) property at wÂ¯ if
there exist Î· âˆˆ (0, âˆ], a neighborhood UwÂ¯ of wÂ¯ and a continuous concave function Ï• :
[0, Î·) â†’ R+ such that (i) Ï•(0) = 0; (ii) Ï• is continuous on (0, Î·); (iii) for all s âˆˆ (0, Î·),
Ï•
0
(s) > 0; (iv) and for all w âˆˆ UwÂ¯ âˆ© {w : f(wÂ¯ ) < f(w) < f(wÂ¯ ) + Î·}, the Kurdyka -
 Lojasiewicz (KL) inequality holds
Ï•
0
(f(w) âˆ’ f(wÂ¯ ))kâˆ‚f(w)k2 â‰¥ 1, (20)
where kâˆ‚f(w)k2 := mingâˆˆâˆ‚f(w) kgk2.
The function Ï• is called the desingularizing function of f at wÂ¯ , which sharpens the
function f(w) by reparameterization. An important desingularizing function is in the form
of Ï•(s) = cs1âˆ’Î²
for some c > 0 and Î² âˆˆ [0, 1), by which, (20) gives the KL inequality
kâˆ‚f(w)k2 â‰¥
1
c(1 âˆ’ Î²)
(f(w) âˆ’ f(wÂ¯ ))Î²
.
Note that all semi-algebraic functions satisfy the KL property at any point (Bolte et al.,
2014). Indeed, all the concrete examples given before satisfy the Kurdyka - Lojasiewicz
property. For more discussions about the KL property, we refer readers to some previous
works (Bolte et al., 2014, 2007; Schneider and Uschmajew, 2015; Attouch et al., 2013;
Bolte et al., 2006). The following corollary states the iteration complexity of RSG for
unconstrained problems that have the KL property at each wÂ¯ âˆˆ â„¦âˆ— .
Corollary 14 Suppose Assumption 1 holds, f(w) satisfies a (uniform) Kurdyka - Lojasiewicz
property at any wÂ¯ âˆˆ â„¦âˆ— with the same desingularizing function Ï• and constant Î·, and
S âŠ‚ âˆªwÂ¯ âˆˆâ„¦âˆ—
[UwÂ¯ âˆ© {w : f(wÂ¯ ) < f(w) < f(wÂ¯ ) + Î·}] . (21)
RSG has an iteration complexity of O

Î±
2G2
(
Ï•()

)
2
dlogÎ±(
0

)e

for obtaining an 2-optimal
solution provided t = Î±
2G2
(Ï•()/)
2
. In addition, if Ï•(s) = cs1âˆ’Î²
for some c > 0 and
Î² âˆˆ [0, 1), the iteration complexity of RSG is O(
Î±
2G2
c
2
(1âˆ’Î²)
2

2Î² dlogÎ±(
0

)e) provided t =
Î±
2G2
c
2

2Î²
and K = dlogÎ±(
0

)e.
16
RSG: Beating Subgradient Method without Smoothness and Strong Convexity
Proof We can prove the above corollary following a result by Bolte et al. (2017) as presented
in Proposition 1 in the Appendix. According to Proposition 1, if f(Â·) satisfies the KL
property at wÂ¯ , then for all w âˆˆ UwÂ¯ âˆ© {w : f(wÂ¯ ) < f(w) < f(wÂ¯ ) + Î·} it holds that
kw âˆ’ wâˆ—k2 â‰¤ Ï•(f(w) âˆ’ f(wÂ¯ )). It then, under the uniform condition in (21), implies that,
for any w âˆˆ S
kw âˆ’ wâˆ—
k2 â‰¤ Ï•(f(w) âˆ’ fâˆ—) â‰¤ Ï•(),
where we use the monotonic property of Ï•. Then the first conclusion follows similarly as
Corollary 5 by noting B â‰¤ Ï•(). The second conclusion immediately follows by setting
Ï•(s) = cs1âˆ’Î²
in the first conclusion. Please note that the above inequality implies the local
error bound condition with Î¸ = 1 âˆ’ Î² for Ï•(s) = cs1âˆ’Î²
.
While the conclusion in Corollary 14 hinges on a condition in (21) for certain UwÂ¯ and Î·,
in practice many convex functions (e.g., continuous semi-algebraic or subanalytic functions)
satisfy the KL property with U = R
d and any finite Î· < âˆ (Attouch et al., 2010; Bolte
et al., 2017; Li, 2010).
It is worth mentioning that to our best knowledge, the present work is the first to
leverage the KL property for developing improved subgradient methods, though it has
been explored in non-convex and convex optimization for deterministic descent methods for
smooth optimization (Bolte et al., 2017, 2014; Attouch et al., 2010; Karimi et al., 2016). For
example, Bolte et al. (2017) studied the convergence of subgradient descent sequence
for minimizing a convex function under an error bound condition. A sequence {xk} is
called a subgradient descent sequence if there exist a > 0, b > 0 it satisfies two conditions,
namely sufficient decrease condition f(xk) + akxk âˆ’ xkâˆ’1k
2
2 â‰¤ f(xkâˆ’1), and relative error
condition, i.e., there exists Ï‰k âˆˆ âˆ‚f(xk) such that kÏ‰kk2 â‰¤ bkxk âˆ’ xkâˆ’1k2. However, for
a general non-smooth function f(x), the sequence generated by subgradient method, i.e.,
xk = xkâˆ’1âˆ’Î·kâˆ‚âˆ‡f(xkâˆ’1) do not necessarily satisfy the above two conditions. Instead, Bolte
et al. (2017) considered proximal gradient method that only applies to a smaller family of
functions consisting of a smooth component and a non-smooth component by assuming the
proximal mapping for the non-smooth component can be efficiently computed. In contrast,
our algorithm and analysis are developed for much general non-smooth functions.
6. Variants of RSG without knowing the constant c and the exponent Î¸
in the local error bound
In Section 5, we have discussed the local error bound and presented several classes of
problems to reveal the magnitude of B, i.e., B = cÎ¸
. For some problems, the value of
Î¸ is exhibited. However, the value of the constant c could be still difficult to estimate,
which renders it challenging to set the appropriate value t =
Î±
2
c
2G2

2(1âˆ’Î¸)
for inner iterations of
RSG. In practice, one might use a sufficiently large c to set up the value of t. However,
such an approach might be vulnerable to both over-estimation and under-estimation of t.
Over-estimating the value of t leads to a waste of iterations while under-estimation leads to
an less accurate solution that might not reach to the target accuracy level. In addition, for
some problems the value of Î¸ is still an open problem. One interesting family of objective
functions in machine learning is the sum of piecewise linear loss over training data and a
17
Yang and Lin
nuclear norm regularizer or an overlapped or non-overlapped group lasso regularizer. In this
section, we present variants of RSG that can be implemented without knowing the value
of c in the local error bound condition and even the value of exponent Î¸, and prove their
improved convergence over the SG method.
6.1 RSG without knowing c
The key idea is to use an increasing sequence of t and another level of restarting for RSG.
The detailed steps are presented in Algorithm 3, to which we refer as R2SG. With large
enough t1 in R2SG, the complexity of R2SG for finding an  solution is given by the theorem
below.
Theorem 15 Suppose  â‰¤ 0/4 and K = dlogÎ±(0/)e. Let t1 in Algorithm 3 be large
enough so that there exists Ë†1 âˆˆ (, 0/2), with which f(Â·) satisfies a local error bound
condition on SË†1 with Î¸ âˆˆ (0, 1) and the constant cË†, and t1 =
Î±
2
cË†
2G2
Ë†
2(1âˆ’Î¸)
1
. Then, with at
most S = dlog2
(Ë†1/)e + 1 calls of RSG in Algorithm 3, we find a solution wS
such that
f(wS
) âˆ’ fâˆ— â‰¤ 2. The total number of iterations of R2SG for obtaining 2-optimal solution
is upper bounded by TS = O

cË†
2G2

2(1âˆ’Î¸) dlogÎ±(
0

)e

.
Proof Since K = dlogÎ±(0/)e â‰¥ dlogÎ±(0/Ë†1)e and t1 =
Î±
2
cË†
2G2
Ë†
2(1âˆ’Î¸)
1
, we can apply Corollary 7
with  = Ë†1 to the first call of RSG in Algorithm 3 so that the output w1
satisfies
f(w1
) âˆ’ fâˆ— â‰¤ 2Ë†1. (22)
Then, we consider the second call of RSG with the initial solution w1
satisfying (22). By
the setup K = dlogÎ±(0/)e â‰¥ dlogÎ±(2Ë†1/(Ë†1/2))e and t2 = t12
2(1âˆ’Î¸) =
cË†
2G2
(Ë†1/2)2(1âˆ’Î¸)
, we can
apply Corollary 7 with  = Ë†1/2 and 0 = 2Ë†1 so that the output w2 of the second call
satisfies f(w2
) âˆ’ fâˆ— â‰¤ Ë†1. By repeating this argument for all the subsequent calls of RSG,
with at most S = dlog2
(Ë†1/)e + 1 calls, Algorithm 3 ensures that
f(wS
) âˆ’ fâˆ— â‰¤ 2Ë†1/2
Sâˆ’1 â‰¤ 2.
The total number of iterations during the S calls of RSG is bounded by
TS = K
X
S
s=1
ts = K
X
S
s=1
t12
2(sâˆ’1)(1âˆ’Î¸) = Kt12
2(Sâˆ’1)(1âˆ’Î¸)X
S
s=1

1
2
2(1âˆ’Î¸)
Sâˆ’s
â‰¤
Kt12
2(Sâˆ’1)(1âˆ’Î¸)
1 âˆ’ 1/2
2(1âˆ’Î¸)
â‰¤ O

Kt1

Ë†1

2(1âˆ’Î¸)
!
= O

cË†
2G2

2(1âˆ’Î¸)
dlogÎ±(
0

)e

.
Remark: We make several remarks about Algorithm 3 and Theorem 15: (i) Theorem 15
applies only when Î¸ âˆˆ (0, 1). If Î¸ = 1, in order to have an increasing sequence of ts, we can
set Î¸ in Algorithm 3 to a little smaller value than 1 in practical implementation, and the
18
RSG: Beating Subgradient Method without Smoothness and Strong Convexity
Algorithm 3 RSG with restarting: R2SG
1: Input: the number of iterations t1 in each stage of the first call of RSG and the number
of stages K in each call of RSG
2: Initialization: w0 âˆˆ â„¦;
3: for s = 1, 2 . . . , S do
4: Let ws = RSG(wsâˆ’1
, K, ts, Î±)
5: Let ts+1 = ts2
2(1âˆ’Î¸)
6: end for
iteration complexity in Theorem 15 implies that R2SG can enjoy a convergence rate close
to linear convergence for problems satisfying the weak sharp minimum condition. (ii) the 0
in the implementation of RSG (Algorthm 2) can be re-calibrated for s â‰¥ 2 to improve the
performance (e.g., one can use the relationship f(wsâˆ’1) âˆ’ fâˆ— = f(wsâˆ’2) âˆ’ fâˆ— + f(wsâˆ’1) âˆ’
f(wsâˆ’2) to do re-calibration); (iii) as a tradeoff, the exiting criterion of R2SG is not as
automatic as RSG. In fact, the total number of calls S of RSG for obtaining an 2-optimal
solution depends on an unknown parameter (namely Ë†1). In practice, one could use other
stopping criteria to terminate the algorithm. For example, in machine learning applications
one can monitor the performance on the validation data set to terminate the algorithm.
(vi) The quantities Ë†1, S in the proof above are implicitly determined by t1 and one does
not need to compute Ë†1 and S in order to apply Algorithm 3. Finally, we note that when
a local strong convexity condition holds on SË†1 with Ë†1 â‰¥  one might derive an iteration
complexity of O(1/) for SG by first showing that SG converges to SË†1 with a number of
iterations independent of , then showing that the iterates stay within SË†1
and converge to
an -level set with an iteration complexity of O(1/) following existing analysis of SG for
strongly convex functions, e.g., (Lacoste-Julien et al., 2012). However, it still needs to know
the value of the local strong convexity parameter unlike our result in Theorem 15 that does
not need to known the local strong convexity parameter.
6.2 RSG for unknown Î¸ and c
Without knowing Î¸ âˆˆ (0, 1] and c to get a sharper local error bound, we can simply let
Î¸ = 0 and c = B
0 with 
0 â‰¥ , which still render the inequaity (15) hold (c.f. Definition 6).
Then we can employ the same trick to increase the values of t. In particular, we start with
a sufficiently large value of t and run RSG with K = dlogÎ±(0/)e stages, and then increase
the value of t by a factor of 4 and repeat the process.
Theorem 16 Let Î¸ = 0 in Algorithm 3 and suppose  â‰¤ 0/4 and K = dlogÎ±(0/)e.
Assume t1 in Algorithm 3 is large enough so that there exists Ë†1 âˆˆ (, 0/2] giving t1 =
Î±
2B2
Ë†1
G2
Ë†
2
1
. Then, with at most S = dlog2
(Ë†1/)e + 1 calls of RSG in Algorithm 3, we find
a solution wS
such that f(wS
) âˆ’ fâˆ— â‰¤ 2. The total number of iterations of R2SG for
obtaining 2-optimal solution is upper bounded by TS = O

B2
Ë†1
G2

2 dlogÎ±(
0

)e

.
19
Yang and Lin
Remark: Since B/ is a monotonically decreasing function in  (Xu et al., 2017, Lemma
7), such a t1 in Theorem 16 exists. Note that if the problem satisfies a KL property as in
Corollary 14 and the value of Î² is unknown, the above theorem still holds.
Proof The proof is similar to that of Theorem 15 except that we let c = BË†1
and Î¸ = 0.
Since K = dlogÎ±(0/)e â‰¥ dlogÎ±(0/Ë†1)e and t1 =
Î±
2B2
Ë†1
G2
Ë†
2
1
, we can apply Corollary 5 with
 = Ë†1 to the first call of RSG in Algorithm 3 so that the output w1
satisfies
f(w1
) âˆ’ fâˆ— â‰¤ 2Ë†1. (23)
Then, we consider the second call of RSG with the initial solution w1
satisfying (23). By
the setup K = dlogÎ±(0/)e â‰¥ dlogÎ±(2Ë†1/(Ë†1/2))e and t2 = t12
2 =
B2
Ë†1
G2
(Ë†1/2)2 , we can apply
Corollary 5 with  = Ë†1/2 and 0 = 2Ë†1 (noting that BË†1 > BË†1/2
) so that the output w2 of
the second call satisfies f(w2
) âˆ’ fâˆ— â‰¤ Ë†1. By repeating this argument for all the subsequent
calls of RSG, with at most S = dlog2
(Ë†1/)e + 1 calls, Algorithm 3 ensures that
f(wS
) âˆ’ fâˆ— â‰¤ 2Ë†1/2
Sâˆ’1 â‰¤ 2.
The total number of iterations during the S calls of RSG is bounded by
TS = K
X
S
s=1
ts = K
X
S
s=1
t12
2(sâˆ’1) = Kt12
2(Sâˆ’1)X
S
s=1

1
2
2
Sâˆ’s
â‰¤
Kt12
2(Sâˆ’1)
1 âˆ’ 1/2
2
â‰¤ O

Kt1

Ë†1

2
!
= O

B2
Ë†1
G2

2
dlogÎ±(
0

)e
!
.
7. Discussions and Comparisons
In this section, we further discuss the obtained results and compare them with existing
results.
7.1 Comparison with the standard SG
The standard SGâ€™s iteration complexity is known as O(
G2kw0âˆ’wâˆ—
0
k
2
2

2 ) for achieving an 2-
optimal solution. By assuming t is appropriately set in RSG according to Corollary 5, its
iteration complexity is O(
G2B2


2 log(0/)), which depends on B2

instead of kw0 âˆ’ wâˆ—
0
k
2
2
and
only has a logarithmic dependence on 0, the upper bound of f(w0) âˆ’ fâˆ—. When the initial
solution is far from the optimal set so that B2
  kw0 âˆ’ wâˆ—
0
k
2
2
, RSG could have a lower
worst-case complexity. Even if t is not appropriately set up to be larger than Î±
2G2B2
 /2
,
Theorem 16 guarantees that the proposed R2SG could still has a lower iteration complexity
than that of SG as long as t1 is sufficiently large. In some special cases, e.g., when f satisfies
the local error bound condition (15) with Î¸ âˆˆ (0, 1], RSG only needs O

1

2(1âˆ’Î¸)
log
1



iterations (see Corollary 7 and Theorem 15), which has a better dependency on  than the
complexity of standard SG method.
2 
RSG: Beating Subgradient Method without Smoothness and Strong Convexity
7.2 Comparison with the SG method by Freund and Lu (2017)
Freund and Lu (2017) introduced a similar but different growth condition:
kw âˆ’ wâˆ—
k2 â‰¤ G Â· (f(w) âˆ’ fslb), âˆ€w âˆˆ â„¦, (24)
where fslb is a strict lower bound of fâˆ—. The main differences from our key condition (7)
are: the left-hand side is the distance of w to the optimal set in (24) while it is the distance
of w to the -sublevel set in (7); the right-hand side is the objective gap with respect to fslb
in (24) and it is the objective gap with respect to fâˆ— in (7); the growth constant G in (24)
varies with fslb and Ï in (7) may depend on  in general.
Freund and Luâ€™s SG method has an iteration complexity of O(G2G
2
(
log H

0 +
1

02 )) for
finding a solution wË† such that f(wË† ) âˆ’ fâˆ— â‰¤ 
0
(fâˆ— âˆ’ fslb), where fslb and G are defined in
(24) and H =
f(w0)âˆ’fslb
fâˆ—âˆ’fslb
. In comparison, our RSG can be better if fâˆ— âˆ’ fslb is large. To see
this, we represent the complexity of the method by Freund and Lu (2017) in terms of the
absolute error  with  = 
0
(fâˆ— âˆ’ fslb) and obtain O(G2G
2
(
(fâˆ—âˆ’fslb) log H
 +
(fâˆ—âˆ’fslb)
2

2 )). If the
gap fâˆ— âˆ’ fslb is large, e.g., O(f(w0) âˆ’ fslb), the second term is dominating, which is at least
â„¦( G2kw0âˆ’wâˆ—
0
k
2
2

2 ) due to the definition of G in (24). This complexity has the same order of
magnitude as the standard SG method so that RSG can be better due to the reasoning in
last paragraph. More generally, the iteration complexity of Freund and Luâ€™s SG method can
be reduced to O(
G2B2
fâˆ—âˆ’fslb

2 ) by choosing the best G in the proof of Theorem 1.1 in Freund
and Lu (2017)â€™s paper, which depends on fâˆ— âˆ’ fslb. In comparison, RSG could have a
lower complexity if fâˆ— âˆ’ fslb is larger than  as in Corollary 5 or Ë†1 as in Theorem 15. Our
experiments in subsection 8.4 also corroborate this point. In addition, RSG can leverage
the local error bound condition to enjoy a lower iteration complexity than O(1/2
).
7.3 Comparison with the method by Juditsky and Nesterov (2014)
Juditsky and Nesterov (2014) considered primal-dual subgradient methods for solving the
problem (1) with f being uniformly convex, namely,
f(Î±w + (1 âˆ’ Î±)v) â‰¤ Î±f(w) + (1 âˆ’ Î±)f(v) âˆ’
1
2
ÂµÎ±(1 âˆ’ Î±)[Î±
Ïâˆ’1 + (1 âˆ’ Î±)
Ïâˆ’1
]kw âˆ’ vk
Ï
2
,
for any w and v in â„¦ and any Î± âˆˆ [0, 1] 5
, where Ï âˆˆ [2, +âˆ] and Âµ â‰¥ 0. In this case, the
method by (Juditsky and Nesterov, 2014) has an iteration complexity of O

G2
Âµ2/Ï
2(Ïâˆ’1)/Ï 
.
The uniform convexity of f further implies f(w) âˆ’ fâˆ— â‰¥
1
2
Âµkw âˆ’ wâˆ—k
Ï
2
for any w âˆˆ â„¦ so
that f(Â·) admits a local error bound on the -sublevel set S with c =

2
Âµ
 1
Ï
and Î¸ =
1
Ï
.
Therefore, our RSG has a complexity of O

G2
Âµ2/Ï
2(Ïâˆ’1)/Ï log( 0

)

according to Corollary 7.
Compared to the result of Juditsky and Nesterov (2014), our complexity is higher by a
logarithmic factor. However, we only require the local error bound property of f that is
weaker than uniform convexity and also covers much broader family of functions. Note that
the above comparison is fair, since for achieving a target -optimal solution the algorithms
5. The Euclidean norm in the definition here can be replaced by a general norm as in (Juditsky and
Nesterov, 2014).
21
Yang and Lin
0 10 20
3
3.5
4
4.5
objective
robust regression (p=1)
0 10 20 âˆ’25
âˆ’20
âˆ’15
âˆ’10
âˆ’5
0
log(levelâˆ’gap)
#of stages
t=102
t=103
t=104
(a) different t
0 10 20
8
10
12
14
16
18
20
objective
robust regression (p=1.5)
0 10 20 âˆ’25
âˆ’20
âˆ’15
âˆ’10
âˆ’5
0
5
log(levelâˆ’gap)
#of stages
t=102
t=103
t=104
(b) different t
0 2 4 6 8 10
x 104
âˆ’15
âˆ’10
âˆ’5
0
#of iterations
log(objective gap)
robust regression (p=1)
SG
RSG (t=103
)
R
2SG (t1=103
)
RSG (t=104
)
(c) different algorithms
0 5 10 15
x 104
âˆ’40
âˆ’30
âˆ’20
âˆ’10
0
10
#of iterations
log(objective gap)
robust regression (p=1.5)
SG
RSG (t=103
)
R
2SG (t1=103
)
RSG (t=104
)
(d) different algorithms
Figure 2: Comparison of RSG with different t and of different algorithms on the housing
data. One iteration means one subgradient update in all algorithms. (t1 for R2SG
represents the initial value of t in the first call of RSG.)
proposed by Juditsky and Nesterov (2014) do need the knowledge of uniform convexity
parameter Ï and the parameter Âµ. It is worth mentioning that Juditsky and Nesterov
(2014) also presented algorithms with a fixed number of iterations T as input that achieve
adaptive rates without knowledge of Ï and Âµ. However, they only considered the case when
Ï >= 2, which corresponds to Î¸ â‰¤ 1/2 in our notations, while our methods can be applied
also when Î¸ > 1/2.
8. Experiments
In this section, we present some experiments to demonstrate the effectiveness of RSG. We
first consider several applications in machine learning, in particular regression, classification
and matrix completion, and focus on the comparison between RSG and SG. Then we make
comparison between RSG with Freund & Luâ€™s SG variant for solving regression problems. In
experiments, all compared algorithms use the same initial solution unless otherwise specified.
22
RSG: Beating Subgradient Method without Smoothness and Strong Convexity
0 10 20
0.1
0.15
0.2
0.25
0.3
0.35
objective
robust regression (p=1)
0 10 20 âˆ’25
âˆ’20
âˆ’15
âˆ’10
âˆ’5
0
log(levelâˆ’gap)
#of stages
t=102
t=103
t=104
(a) different t
0 10 20
0.05
0.1
0.15
0.2
0.25
objective
robust regression (p=1.5)
#of stages
0 10 20 âˆ’25
âˆ’20
âˆ’15
âˆ’10
âˆ’5
0
log(levelâˆ’gap)
t=102
t=103
t=104
(b) different t
0 0.5 1 1.5 2
x 105
âˆ’30
âˆ’25
âˆ’20
âˆ’15
âˆ’10
âˆ’5
0
#of iterations
log(objective gap)
robust regression (p=1)
SG
RSG (t=103
)
R
2SG (t1=103
)
RSG (t=104
)
(c) different algorithms
0 0.5 1 1.5 2
x 105
âˆ’30
âˆ’25
âˆ’20
âˆ’15
âˆ’10
âˆ’5
0
#of iterations
log(objective gap)
robust regression (p=1.5)
SG
RSG (t=103
)
R
2SG (t1=103
)
RSG (t=104
)
(d) different algorithms
Figure 3: Comparison of RSG with different t and of different algorithms on the space-ga
data. One iteration means one subgradient update in all algorithms.
8.1 Robust Regression
The regression problem is to predict an output y based on a feature vector x âˆˆ R
d
. Given
a set of training examples (xi
, yi), i = 1, . . . , n, a linear regression model can be found by
solving the optimization problem in (19).
We solve two instances of the problem with p = 1 and p = 1.5 and Î» = 0. We conduct
experiments on two data sets from libsvm website 6
, namely housing (n = 506 and d = 13)
and space-ga (n = 3107 and d = 6). We first examine the convergence behavior of RSG
with different values for the number of iterations per-stage t = 102
, 103
, and 104
. The value
of Î± is set to 2 in all experiments. The initial step size of RSG is set to be proportional to
0/2 with the same scaling parameter for different variants. We plot the results on housing
data in Figure 2 (a,b) and on space-ga data in Figure 3 (a,b). In each figure, we plot the
objective value vs number of stages and the log difference between the objective value and
the converged value (to which we refer as level gap). We can clearly see that with different
values of t RSG converges to an -level set and the convergence rate is linear in terms of
the number of stages, which is consistent with our theory.
Secondly, we compare with SG to verify the effectiveness of RSG. The baseline SG is
implemented with a decreasing step size proportional to 1/
âˆš
Ï„ , where Ï„ is the iteration
6. https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/
23
Yang and Lin
0 0.5 1 1.5 2
x 105
0.34
0.36
0.38
0.4
0.42
0.44
#of iterations
Objective
R
2SG
SG
(a) comparison between different algorithms
0 0.5 1 1.5 2
x 105
0.35
0.4
0.45
0.5
0.55
0.6
0.65
0.7
#of iterations
Objective
R
2SG (initial 1)
R
2SG (initial 2)
SG (initial 1)
SG (initial 2)
(b) sensitivity to initial solutions
Figure 4: Results for solving SVM classification with GFlassso regularizer. In (b), the
objective values of the two initial solutions are 1 and 70.35. One iteration means
one subgradient update in all algorithms.
index. The initial step size of SG is tuned in a wide range to give the fastest convergence.
The initial step size of RSG is also tuned around the best initial step size of SG. The results
are shown in Figure 2(c,d) and Figure 3(c,d), where we show RSG with two different values
of t and also R2SG with an increasing sequence of t. In implementing R2SG, we restart RSG
for every 5 stages, and increase the number of iterations by a certain factor. In particular,we
increase t by a factor of 1.15 and 1.5 respectively for p = 1 and p = 1.5. From the results,
we can see that (i) RSG with a smaller value of t = 103
can quickly converge to an -level,
which is less accurate than SG after running a sufficiently large number of iterations; (ii)
RSG with a relatively large value t = 104
can converge to a much more accurate solution;
(iv) R2SG converges much faster than SG and can bridge the gap between RSG-t = 103
and RSG-t = 104
.
8.2 SVM Classification with a graph-guided fused lasso
The classification problem is to predict a binary class label y âˆˆ {1, âˆ’1} based on a feature
vector x âˆˆ R
d
. Given a set of training examples (xi
, yi), i = 1, . . . , n, the problem of training
a linear classification model can be cast into
min
wâˆˆRd
F(w) := 1
n
Xn
i=1
`(w>xi
, yi) + R(w).
Here we consider the hinge loss `(z, y) = max(0, 1âˆ’yz) as in support vector machine (SVM)
and a graph-guided fused lasso (GFlasso) regularizer R(w) = Î»kF wk1 (Kim et al., 2009),
where F = [Fij ]mÃ—d âˆˆ R
mÃ—d
encodes the edge information between variables. Suppose
there is a graph G = {V, E} where nodes V are the attributes and each edge is assigned a
weight sij that represents some kind of similarity between attribute i and attribute j. Let
E = {e1, . . . , em} denote a set of m edges, where an edge eÏ„ = (iÏ„ , jÏ„ ) consists of a tuple
of two attributes. Then the Ï„ -th row of F matrix can be formed by setting FÏ„,iÏ„ = siÏ„ ,jÏ„
and FÏ„,jÏ„ = âˆ’siÏ„ ,jÏ„
for (iÏ„ , jÏ„ ) âˆˆ E, and zeros for other entries. Then the GFlasso becomes
24
RSG: Beating Subgradient Method without Smoothness and Strong Convexity
0 5 10 15
#of iterations 10 4
0
1
2
3
4
objective
absolute loss
SG
R
2SG
0 5 10 15
#of iterations 10 4
0
2
4
6
8
10
objective
hinge loss
SG
R
2SG
Figure 5: Results for solving low rank matrix completion with different loss functions.
R(w) = Î»
P
(i,j)âˆˆE sij |wi âˆ’ wj |. Previous studies have found that a carefully designed
GFlasso regularization helps in reducing the risk of over-fitting. In this experiment, we
follow (Ouyang et al., 2013) to generate a dependency graph by sparse inverse covariance
selection (Friedman et al., 2008). To this end, we first generate a sparse inverse covariance
matrix using the method in (Friedman et al., 2008) and then assign an equal weight sij = 1
to all edges that have non-zero entries in the resulting inverse covariance matrix. We
conduct the experiment on the dna data (n = 2000 and d = 180) from the libsvm website,
which has three class labels. We solve the above problem to classify class 3 versus the rest.
The comparison between different algorithms starting from an initial solution with all zero
entries for solving the above problem with Î» = 0.1 is presented in Figure 4(a). For R2SG,
we start from t1 = 103 and restart it every 10 stages with t increased by a factor of 1.15.
The initial step sizes for all algorithms are tuned.
We also compare the dependence of R2SGâ€™s convergence on the initial solution with
that of SG. We use two different initial solutions (the first initial solution w0 = 0 and the
second initial solution w0 is generated once from a normal Gaussian distribution). The
convergence curves of the two algorithms from the two different initial solutions are plotted
in Figure 4(b). Note that the initial step sizes of SG and R2SG are separately tuned for
each initial solution. We can see that R2SG is much less sensitive to a bad initial solution
than SG consistent with our theory.
8.3 Matrix Completion for Collaborative Filtering
In this subsection, we consider low rank matrix completion problems to demonstrate the
effectiveness of R2SG without having the knowledge of c and Î¸ in the local error bound
condition. We consider a movie recommendation data set, namely MovieLens 100k data 7
,
which contains 100, 000 ratings from m = 943 users on n = 1682 movies. We formulate
the problem as a task of recovering a full user-movie rating matrix X from the partially
observed matrix Y . The objective is composed of a loss function measuring the difference
between X and Y on the observed entries and a nuclear norm regularizer on X for enforcing
7. https://grouplens.org/datasets/movielens/
25
Yang and Lin
a low rank, i.e.,
min
XâˆˆRmÃ—n
1
N
X
(i,j)âˆˆÎ£
`(Xij , Yij ) + Î»kXkâˆ—, (25)
where Î£ is a set of user-movie pairs that denote the observed entries, `(Â·, Â·) denote a loss
function, kXkâˆ— denotes the nuclear norm, N = |Î£| and Î» > 0 is a regularization parameter.
We consider two loss functions, i.e, the hinge loss and the absolute loss. For absolute
loss, we set `(a, b) = |a âˆ’ b|. For hinge loss, we follow Rennie and Srebro (2005) by
introducing four thresholds Î¸1,2,3,4 due to there are five distinct ratings in {1, 2, 3, 4, 5}
that can be assigned to each movie, and defining `(a, b) = P4
r=1 max(0, 1 âˆ’ T
r
i,j (Î¸r âˆ’ Xij )),
where T
r
ij =

1 if r â‰¥ Yij
0 otherwise . In our experiment, we set Î¸1,2,3,4 = (0, 3, 6, 9) and Î» = 10âˆ’5
following (Yang et al., 2014). Since the loss function and the nuclear norm are both semialgebraic functions (Yang et al., 2016; Bolte et al., 2014), then the problem (25) satisfies an
error bound condition on any compact set (Bolte et al., 2017). However, it remains an open
problem what are the proper values of c and Î¸ to make local error bound condition hold.
Hence, we run R2SG by setting Î¸ = 0. To compare with SG, we simply set t1 = 10 - the
number of iterations of each stage of the first call of RSG. The baseline SG is implemented
in the same way as before. The results of the objective values vs the number of iterations
are plotted in Figure 5. We can see that R2SG converges much faster than SG, verifying
the effectiveness of R2SG predicted by Theorem 16.
8.4 Comparison with Freund & Luâ€™s SG
In this subsection, we compare the proposed RSG with Freund & Luâ€™ SG algorithm empirically. The later algorithm is designed with a fixed relative accuracy 
0
such that f(xt)âˆ’fâˆ—
fâˆ—âˆ’fslb
â‰¤ 
0
,
where fslb is a strict lower bound of fâˆ—, and requires to maintain the best solution in terms
of the objective value during the optimization. For fair comparison, we run RSG with a
fixed t and then vary 
0
for Freund & Luâ€™s SG algorithm that is an input parameter, and
then plot the objective values versus the running time and the number of iterations for both
algorithms. The experiments are conducted on the two classification data sets as used in
subsection 8.1, namely the housing data and the space-ga data, for solving robust regression problems (19) with p = 1 and p = 1.5. The strict lower bound fslb in Freund & Luâ€™s
algorithm is set to 0. The results are shown in Figure 6 and Figure 7, where SGR refers to
Freund & Luâ€™s SG algorithm with a specified relative accuracy. For each problem instance
(a data set and a particular value of p), we report two results comparing the objective values
vs. running time and the number of iterations. We can see that RSG is very competitive
in performance in terms of running time and converge faster than Freund & Luâ€™s algorithm
with a small 
0 = 10âˆ’4
for achieving the same accurate solution (e.g., with objective gap
less than 10âˆ’10).
9. Conclusion
In this work, we have proposed a novel restarted subgradient method for non-smooth and/or
non-strongly convex optimization for obtaining an -optimal solution. By leveraging the
26
RSG: Beating Subgradient Method without Smoothness and Strong Convexity
0 5 10 15 20 25 âˆ’15
âˆ’10
âˆ’5
0
5
running time (s)
log(objective gap)
robust regression (p=1)
RSG (t=104
)
SGR (Îµâ€™=10âˆ’1)
SGR (Îµâ€™=10âˆ’2)
SGR (Îµâ€™=10âˆ’3)
SGR (Îµâ€™=10âˆ’4)
0 2 4 6 8 10
x 104
âˆ’15
âˆ’10
âˆ’5
0
5
#iterations
log(objective gap)
robust regression (p=1)
RSG (t=104
)
SGR (Îµâ€™=10âˆ’1)
SGR (Îµâ€™=10âˆ’2)
SGR (Îµâ€™=10âˆ’3)
SGR (Îµâ€™=10âˆ’4)
0 5 10 15 20 25 30 35 âˆ’40
âˆ’30
âˆ’20
âˆ’10
0
10
running time (s)
log(objective gap)
robust regression (p=1.5)
RSG (t=104
)
SGR (Îµâ€™=10âˆ’1)
SGR (Îµâ€™=10âˆ’2)
SGR (Îµâ€™=10âˆ’3)
SGR (Îµâ€™=10âˆ’4)
0 2 4 6 8 10
x 104
âˆ’40
âˆ’30
âˆ’20
âˆ’10
0
10
#iterations
log(objective gap)
robust regression (p=1.5)
RSG (t=104
)
SGR (Îµâ€™=10âˆ’1)
SGR (Îµâ€™=10âˆ’2)
SGR (Îµâ€™=10âˆ’3)
SGR (Îµâ€™=10âˆ’4)
Figure 6: Comparison of RSG with Freund & Luâ€™s SG algorithm (SGR) on the housing
data.
0 20 40 60 80 100 âˆ’20
âˆ’15
âˆ’10
âˆ’5
0
running time (s)
log (objective gap)
robust regression (p=1)
RSG (t=104
)
SGR (Îµâ€™=10âˆ’1)
SGR (Îµâ€™=10âˆ’2)
SGR (Îµâ€™=10âˆ’3)
SGR (Îµâ€™=10âˆ’4)
0 2 4 6 8 10
x 104
âˆ’20
âˆ’15
âˆ’10
âˆ’5
0
#iterations
log(objective gap)
robust regression (p=1)
RSG (t=104
)
SGR (Îµâ€™=10âˆ’1)
SGR (Îµâ€™=10âˆ’2)
SGR (Îµâ€™=10âˆ’3)
SGR (Îµâ€™=10âˆ’4)
0 50 100 150 âˆ’25
âˆ’20
âˆ’15
âˆ’10
âˆ’5
0
running time (s)
log (objective gap)
robust regression (p=1.5)
RSG (t=104
)
SGR (Îµâ€™=10âˆ’1)
SGR (Îµâ€™=10âˆ’2)
SGR (Îµâ€™=10âˆ’3)
SGR (Îµâ€™=10âˆ’4)
0 2 4 6 8 10
x 104
âˆ’25
âˆ’20
âˆ’15
âˆ’10
âˆ’5
0
#iterations
log(objective gap)
robust regression (p=1.5)
RSG (t=104
)
SGR (Îµâ€™=10âˆ’1)
SGR (Îµâ€™=10âˆ’2)
SGR (Îµâ€™=10âˆ’3)
SGR (Îµâ€™=10âˆ’4)
Figure 7: Comparison of RSG with Freund & Luâ€™s SG algorithm (SGR) on the space-ga
data.
lower bound of the first-order optimality residual, we establish a generic complexity of RSG
that improves over standard subgradient method. We have also considered several classes
of non-smooth and non-strongly convex problems that admit a local error bound condition
and derived the improved order of iteration complexities for RSG. Several extensions have
been made to design a parameter-free variant of RSG without requiring the knowledge of
the constants in the local error bound condition. Experimental results on several machine
learning tasks have demonstrated the effectiveness of the proposed algorithms in comparison
to the subgradient method.
