As data sets continue to increase in size and multi-core computer architectures are developed,
asynchronous parallel optimization algorithms become more and more essential to the field
of Machine Learning. Unfortunately, conducting the theoretical analysis asynchronous
methods is difficult, notably due to the introduction of delay and inconsistency in inherently
sequential algorithms. Handling these issues often requires resorting to simplifying but
unrealistic assumptions. Through a novel perspective, we revisit and clarify a subtle but
important technical issue present in a large fraction of the recent convergence rate proofs for
asynchronous parallel optimization algorithms, and propose a simplification of the recently
introduced â€œperturbed iterateâ€ framework that resolves it. We demonstrate the usefulness
of our new framework by analyzing three distinct asynchronous parallel incremental optimization algorithms: Hogwild (asynchronous Sgd), Kromagnon (asynchronous Svrg)
and Asaga, a novel asynchronous parallel version of the incremental gradient algorithm
Saga that enjoys fast linear convergence rates. We are able to both remove problematic
assumptions and obtain better theoretical results. Notably, we prove that Asaga and
Kromagnon can obtain a theoretical linear speedup on multi-core systems even without
sparsity assumptions. We present results of an implementation on a 40-core architecture
illustrating the practical speedups as well as the hardware overhead. Finally, we investigate
the overlap constant, an ill-understood but central quantity for the theoretical analysis
of asynchronous parallel algorithms. We find that it encompasses much more complexity
than suggested in previous work, and often is order-of-magnitude bigger than traditionally
thought.
Keywords: optimization, machine learning, large scale, asynchronous parallel, sparsity

Leblond, Pedregosa and Lacoste-Julien
1. Introduction
We consider the unconstrained optimization problem of minimizing a finite sum of smooth
convex functions:
min
xâˆˆRd
f(x), f(x) := 1
n
Xn
i=1
fi(x), (1)
where each fi
is assumed to be convex with L-Lipschitz continuous gradient, f is Âµ-strongly
convex and n is large (for example, the number of data points in a regularized empirical
risk minimization setting). We define a condition number for this problem as Îº := L/Âµ, as
is standard in the finite sum literature.1 A flurry of randomized incremental algorithms
(which at each iteration select i at random and process only one gradient f
0
i
) have recently
been proposed to solve (1) with a fast2
linear convergence rate, such as Sag (Le Roux
et al., 2012), Sdca (Shalev-Shwartz and Zhang, 2013), Svrg (Johnson and Zhang, 2013)
and Saga (Defazio et al., 2014). These algorithms can be interpreted as variance reduced
versions of the stochastic gradient descent (Sgd) algorithm, and they have demonstrated both
theoretical and practical improvements over Sgd (for the finite sum optimization problem 1).
In order to take advantage of the multi-core architecture of modern computers, the
aforementioned optimization algorithms need to be adapted to the asynchronous parallel
setting, where multiple threads work concurrently. Much work has been devoted recently
in proposing and analyzing asynchronous parallel variants of algorithms such as Sgd (Niu
et al., 2011), Sdca (Hsieh et al., 2015) and Svrg (Reddi et al., 2015; Mania et al., 2017;
Zhao and Li, 2016). Among the incremental gradient algorithms with fast linear convergence
rates that can optimize (1) in its general form, only Svrg had had an asynchronous parallel
version proposed.3 No such adaptation had been attempted for Saga until Leblond et al.
(2017), even though one could argue that it is a more natural candidate as, contrarily to
Svrg, it is not epoch-based and thus has no synchronization barriers at all. The present
paper is an extended journal version of the conference paper from Leblond et al. (2017).
The usual frameworks for asynchronous analysis are quite intricate (see Section 2.2)
and thus require strong simplifying assumptions. They are not well suited to the study of
complex algorithms such as Saga. We therefore base our investigation on the newly proposed
â€œperturbed iterateâ€ framework introduced in Mania et al. (2017), which we also improve upon
in order to properly analyze Saga. Deriving a framework in which the analysis of Saga is
possible enables us to highlight the deficiencies of previous frameworks and to define a better
alternative. Our new approach is not limited to Saga but can be used to investigate other
algorithms and improve their existing bounds.
Contributions. In Section 2, we propose a simplification of the â€œperturbed iterateâ€ framework from Mania et al. (2017) as a basis for our asynchronous convergence analysis. At the
1. Since we have assumed that each individual fi is L-smooth, f itself is L-smooth â€“ but its smoothness
constant Lf could be much smaller. While the more classical condition number is Îºb := Lf/Âµ, our rates
are in terms of this bigger L/Âµ in this paper.
2. Their complexity in terms of gradient evaluations to reach an accuracy of  is O((n + Îº)log(
1/)), in
contrast to O(nÎºb log(1/)) for batch gradient descent in the worst case.
3. We note that Sdca requires the knowledge of an explicit Âµ-strongly convex regularizer in (1), whereas
Sag / Saga are adaptive to any local strong convexity of f (Schmidt et al., 2016; Defazio et al., 2014).
The variant of Svrg from Hofmann et al. (2015) is also adaptive (we review this variant in Section 4.1).
2
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
same time, through a novel perspective, we revisit and clarify a technical problem present in
a large fraction of the literature on randomized asynchronous parallel algorithms (with the
exception of Mania et al. 2017, which also highlights this issue): namely, they all assume
unbiased gradient estimates, an assumption that is inconsistent with their proof technique
without further unpractical synchronization assumptions.
In Section 3.1, we present a novel sparse variant of Saga that is more adapted to the
parallel setting than the original Saga algorithm. In Section 3.2, we present Asaga, a
lock-free asynchronous parallel version of Sparse Saga that does not require consistent
read or write operations. We give a tailored convergence analysis for Asaga. Our main
result states that Asaga obtains the same geometric convergence rate per update as Saga
when the overlap bound Ï„ (which scales with the number of cores) satisfies Ï„ â‰¤ O(n) and
Ï„ â‰¤ O( âˆš1
âˆ† max{1,
n
Îº
}), where âˆ† â‰¤ 1 is a measure of the sparsity of the problem. This
notably implies that a linear speedup is theoretically possible even without sparsity in the
well-conditioned regime where n  Îº. This result is in contrast to previous analysis which
always required some sparsity assumptions.
In Section 4, we revisit the asynchronous variant of Svrg from Mania et al. (2017),
Kromagnon, while removing their gradient bound assumption (which was inconsistent with
the strongly convex setting).4 We prove that the algorithm enjoys the same fast rates of
convergence as Svrg under similar conditions as Asaga â€“ whereas the original paper only
provided analysis for slower rates (in both the sequential and the asynchronous case), and
thus less meaningful speedup results.
In Section 5, in order to show that our improved â€œafter readâ€ perturbed iterate framework
can be used to revisit the analysis of other optimization routines with correct proofs that do
not assume homogeneous computation, we provide the analysis of the Hogwild algorithm
first introduced in Niu et al. (2011). Our framework allows us to remove the classic gradient
bound assumption and to prove speedups in more realistic settings.
In Section 6, we provide a practical implementation of Asaga and illustrate its performance on a 40-core architecture, showing improvements compared to asynchronous variants
of Svrg and Sgd. We also present experiments on the overlap bound Ï„ , showing that it
encompasses much more complexity than suggested in previous work.
Related Work. The seminal textbook of Bertsekas and Tsitsiklis (1989) provides most of
the foundational work for parallel and distributed optimization algorithms. An asynchronous
variant of Sgd with constant step size called Hogwild was presented by Niu et al. (2011);
part of their framework of analysis was re-used and inspired most of the recent literature on
asynchronous parallel optimization algorithms with convergence rates, including asynchronous
variants of coordinate descent (Liu et al., 2015), Sdca (Hsieh et al., 2015), Sgd for non-convex
problems (De Sa et al., 2015; Lian et al., 2015), Sgd for stochastic optimization (Duchi
et al., 2015) and Svrg (Reddi et al., 2015; Zhao and Li, 2016). These papers make use of
4. Although the authors mention that this gradient bound assumption can be enforced through the use of a
thresholding operator, they do not explain how to handle the interplay between this non-linear operator
and the asynchrony of the algorithm. Their theoretical analysis relies on the linearity of the operations
(e.g. to derive (Mania et al., 2017, Eq. (2.6))), and thus this claim is not currently supported by theory
(note that a strongly convex function over an unbounded domain always has unbounded gradients).
3
Leblond, Pedregosa and Lacoste-Julien
an unbiased gradient assumption that is not consistent with the proof technique, and thus
suffers from technical problems5
that we highlight in Section 2.2.
The â€œperturbed iterateâ€ framework presented in Mania et al. (2017) is to the best of
our knowledge the only one that does not suffer from this problem, and our convergence
analysis builds heavily from their approach, while simplifying it. In particular, the authors
assumed that f was both strongly convex and had a bound on the gradient, two inconsistent
assumptions in the unconstrained setting that they analyzed. We overcome these difficulties
by using tighter inequalities that remove the requirement of a bound on the gradient. We
also propose a more convenient way to label the iterates (see Section 2.2). The sparse version
of Saga that we propose is also inspired from the sparse version of Svrg proposed by Mania
et al. (2017).
Reddi et al. (2015) presents a hybrid algorithm called Hsag that includes Saga and
Svrg as special cases. Their asynchronous analysis is epoch-based though, and thus does
not handle a fully asynchronous version of Saga as we do. Moreover, they require consistent
reads and do not propose an efficient sparse implementation for Saga, in contrast to Asaga.
Pan et al. (2016) proposes a black box mini-batch algorithm to parallelize Sgd-like
methods while maintaining serial equivalence through smart update partitioning. When the
data set is sparse enough, they obtain speedups over â€œHogwildâ€ implementations of Svrg
and Saga.
6 However, these â€œHogwildâ€ implementations appear to be quite suboptimal,
as they do not leverage data set sparsity efficiently: they try to adapt the â€œlazy updatesâ€
trick from Schmidt et al. (2016) to the asynchronous parallel setting â€“ which as discussed
in Appendix E is extremely difficult â€“ and end up making several approximations which
severely penalize the performance of the algorithms. In particular, they have to use much
smaller step sizes than in the sequential version, which makes for worse results.
Pedregosa et al. (2017) extend the Asaga algorithm presented in Section 3.2 to the
proximal setting.
Notation. We denote by E a full expectation with respect to all the randomness in the
system, and by E the conditional expectation of a random i (the index of the factor fi chosen
in Sgd and other algorithms), conditioned on all the past, where â€œpastâ€ will be clear from
the context. [x]v represents the coordinate v of the vector x âˆˆ R
d
. For sequential algorithms,
x
+ is the updated parameter vector after one algorithm iteration.
2. Revisiting the Perturbed Iterate Framework for Asynchronous
Analysis
As most recent parallel optimization contributions, we use a similar hardware model to Niu
et al. (2011). We consider multiple cores which all have read and write access to a shared
memory. The cores update a central parameter vector in an asynchronous and lock-free
fashion. Unlike Niu et al. (2011), we do not assume that the vector reads are consistent:
multiple cores can read and write different coordinates of the shared vector at the same time.
This also implies that a full vector read for a core might not correspond to any consistent
state in the shared memory at any specific point in time.
5. Except (Duchi et al., 2015) that can be easily fixed by incrementing their global counter before sampling.
6. By â€œHogwildâ€, the authors mean asynchronous parallel variants where cores independently run the
sequential update rule.
4
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
2.1. Perturbed Iterate Framework
We first review the â€œperturbed iterateâ€ framework recently introduced by Mania et al. (2017)
which will form the basis of our analysis. In the sequential setting, stochastic gradient descent
and its variants can be characterized by the following update rule:
xt+1 = xt âˆ’ Î³g(xt
, it), (2)
where it
is a random variable independent from xt and we have the unbiasedness condition
Eg(xt
, it) = f
0
(xt) (recall that E is the relevant-past conditional expectation with respect to
it).
Unfortunately, in the parallel setting, we manipulate stale, inconsistent reads of shared
parameters and thus we do not have such a straightforward relationship. Instead, Mania et al.
(2017) proposed to distinguish xË†t
, the actual value read by a core to compute an update,
from xt
, a â€œvirtual iterateâ€ that we can analyze and is defined by the update equation:
xt+1 := xt âˆ’ Î³g(Ë†xt
, it). (3)
We can thus interpret xË†t as a noisy (perturbed) version of xt due to the effect of asynchrony.
We formalize the precise meaning of xt and xË†t
in the next section. We first note that
all references mentioned in the related work section that analyzed asynchronous parallel
randomized algorithms assumed that the following unbiasedness condition holds:
[unbiasedness condition] E[g(Ë†xt
, it)|xË†t
] = f
0
(Ë†xt).
7
(4)
This condition is at the heart of most convergence proofs for randomized optimization
methods.8 Mania et al. (2017) correctly pointed out that most of the literature thus made
the often implicit assumption that it
is independent of xË†t
. But as we explain below, this
assumption is incompatible with a non-uniform asynchronous model in the analysis approach
used in most of the recent literature.
2.2. On the Difficulty of Labeling the Iterates
Formalizing the meaning of xt and xË†t highlights a subtle but important difficulty arising when
analyzing randomized parallel algorithms: what is the meaning of t? This is the problem of
labeling the iterates for the purpose of the analysis, and this labeling can have randomness
itself that needs to be taken in consideration when interpreting the meaning of an expression
like E[xt
]. In this section, we contrast three different approaches in a unified framework. We
notably clarify the dependency issues that the labeling from Mania et al. (2017) resolves and
propose a new, simpler labeling which allows for much simpler proof techniques.
7. We note that to be completely formal and define this conditional expectation more precisely, one would
need to define another random vector that describes the entire system randomness, including all the reads,
writes, delays, etc. Conditioning on xË†t in (4) is actually a shorthand to indicate that we are conditioning
on all the relevant â€œpastâ€ that defines both the value of xË†t as well as the fact that it was the t
th labeled
element. For clarity of exposition, we will not go into this level of technical detail, but one could define
the appropriate sigma fields to condition on in order to make this equation fully rigorous.
8. A notable exception is Sag (Le Roux et al., 2012) which has biased updates and thus requires a significantly
more complex convergence proof. Making Sag unbiased leads to Saga (Defazio et al., 2014), with a
much simpler convergence proof.
5
Leblond, Pedregosa and Lacoste-Julien
We consider algorithms that execute in parallel the following four steps, where t is a
global labeling that needs to be defined:9
1. Read the information in shared memory (xË†t).
2. Sample it
.
3. Perform some computations using (xË†t
, it).
4. Write an update to shared memory.
(5)
The â€œAfter Writeâ€ Approach. We call the â€œafter writeâ€ approach the standard global
labeling scheme used in Niu et al. (2011) and re-used in all the later papers that we mentioned
in the related work section, with the notable exceptions of Mania et al. (2017) and Duchi
et al. (2015). In this approach, t is a (virtual) global counter recording the number of
successful writes to the shared memory x (incremented after step 4 in 5); xt thus represents
the (true) content of the shared memory after t updates. The interpretation of the crucial
equation (3) then means that xË†t represents the (delayed) local copy value of the core that
made the (t + 1)th successful update; it represents the factor sampled by this core for this
update. Notice that in this framework, the value of xË†t and it
is unknown at â€œtime tâ€; we have
to wait to the later time when the next core writes to memory to finally determine that its
local variables are the ones labeled by t. We thus see that here xË†t and it are not necessarily
independent â€“ they share dependence through the assignment of the t label. In particular,
if some values of it yield faster updates than others, it will influence the label assignment
defining xË†t
. We provide a concrete example of this possible dependency in Figure 1.
The only way we can think to resolve this issue and ensure unbiasedness is to assume that
the computation time for the algorithm running on a core is independent of the sample i chosen.
This assumption seems overly strong in the context of potentially heterogeneous factors fi
â€™s,
and is thus a fundamental flaw for analyzing non-uniform asynchronous computation that
has mostly been ignored in the recent asynchronous optimization literature.10
9. Observe that contrary to most asynchronous algorithms, we choose to read the shared parameter vector
before sampling the next data point. We made this design choice to emphasize that in order for xË†t and it
to be independent â€“ which will prove crucial for the analysis â€“ the reading of the shared parameter has
to be independent of the sampled data point. Although in practice one would prefer to only read the
necessary parameters after sampling the relevant data point, for the sake of the analysis we cannot allow
this source of dependence. We note that our analysis could also handle reading the parameter first and
then sampling as long as independence is ensured, but for clarity of presentation, we decided to make
this independence explicit.
Mania et al. (2017) make the opposite presentation choice. In their main analysis, they explicitly
assume that xË†t and it are independent, although they explain that it is not the case in practical
implementations. The authors then propose a scheme to handle the dependency directly in their appendix.
However, this â€œfixâ€ can only be applied in a restricted setup: only for the Hogwild algorithm, with the
assumption that the norm of the gradient is uniformly bounded. Furthermore, even in this restricted
setup, the scheme leads to worsened theoretical results (the bound on Ï„ is Îº
2 worse). Applying it to
a more complex algorithm such as Kromagnon or Asaga would mean overcoming several significant
hurdles and is thus still an open problem.
In the absence of a better option, we choose to enforce the independence of xË†t and it with our
modified steps ordering.
10. We note that Bertsekas and Tsitsiklis (1989) briefly discussed this issue (see Section 7.8.3), stressing that
their analysis for SGD required that the scheduling of computation was independent from the randomness
from SGD, but they did not offer any solution if this assumption was not satisfied. Both the â€œbefore readâ€
labeling from Mania et al. (2017) and our proposed â€œafter readâ€ labeling resolve this issue.
6
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
f1 f2
core 1 Ã—
core 2 Ã—
f
0
i0
(Ë†x0) f
0
1
(Ë†x0)
f1 f2
core 1 Ã—
core 2 Ã—
f
0
1
(Ë†x0)
f1 f2
core 1 Ã—
core 2 Ã—
f
0
1
(Ë†x0)
f1 f2
core 1 Ã—
core 2 Ã—
f
0
2
(Ë†x0)
Figure 1: Suppose that we have two cores and that f has two factors: f1 which has support on only
one variable, and f2 which has support on 106
variables and thus yields a gradient step that is significantly
more expensive to compute. x0 is the initial content of the memory, and we do not know yet whether xË†0
is the local copy read by the first core or the second core, but we are sure that xË†0 = x0 as no update can
occur in shared memory without incrementing the counter. There are four possibilities for the next step
defining x1 depending on which index i was sampled on each core. If any core samples i = 1, we know
that x1 = x0 âˆ’ Î³f0
1(x0) as it will be the first (much faster update) to complete. This happens in 3 out of
4 possibilities; we thus have that Ex1 = x0 âˆ’ Î³(
3
4
f
0
1(x0) + 1
4
f
0
2(x0)). We see that this analysis scheme does
not satisfy the crucial unbiasedness condition (4). To understand this subtle point better, note that in this
very simple example, i0 and i1 are not independent. We can show that P(i1 = 2 | i0 = 2) = 1. They share
dependency through the labeling assignment.
The â€œBefore Readâ€ Approach. Mania et al. (2017) address this issue by proposing
instead to increment the global t counter just before a new core starts to read the shared
memory (before step 1 in 5). In their framework, xË†t represents the (inconsistent) read that
was made by this core in this computational block, and it represents the chosen sample. The
update rule (3) represents a definition of the meaning of xt
, which is now a â€œvirtual iterateâ€
as it does not necessarily correspond to the content of the shared memory at any point.
The real quantities manipulated by the algorithm in this approach are the xË†t
â€™s, whereas
xt
is used only for the analysis â€“ consequently, the critical quantity we want to see vanish
is EkxË†t âˆ’ x
âˆ—k
2
. The independence of it with xË†t can be simply enforced in this approach
by making sure that the way the shared memory x is read does not depend on it (e.g. by
reading all its coordinates in a fixed order). Note that this implies that we have to read all
of xâ€™s coordinates, regardless of the size of fit
â€™s support. This is a much weaker condition
than the assumption that all the computation in a block does not depend on it as required
by the â€œafter writeâ€ approach, and is thus more reasonable.
A New Global Ordering: the â€œAfter Readâ€ Approach. The â€œbefore readâ€ approach
gives rise to the following complication in the analysis: xË†t can depend on ir for r > t. This
is because t is a global time ordering only on the assignment of computation to a core, not
on when xË†t was finished being read. This means that we need to consider both the â€œfutureâ€
and the â€œpastâ€ when analyzing xt
. To simplify the analysis, we thus propose a third way to
label the iterates that we call â€œafter readâ€: xË†t represents the (t + 1)th fully completed read (t
incremented after step 1 in 5). As in the â€œbefore readâ€ approach, we can ensure that it
is
independent of xË†t by ensuring that how we read does not depend on it
. But unlike in the
â€œbefore readâ€ approach, t here now does represent a global ordering on the xË†t
iterates â€“ and
thus we have that ir is independent of xË†t for r > t. Again using (3) as the definition of the
virtual iterate xt as in the perturbed iterate framework, we then have a very simple form for
7
Leblond, Pedregosa and Lacoste-Julien
the value of xt and xË†t (assuming atomic writes, see Property 5 below):
xt = x0 âˆ’ Î³
X
tâˆ’1
u=0
g(Ë†xu, Î±Ë†
u
, iu) ;
[Ë†xt
]v = [x0]v âˆ’ Î³
X
tâˆ’1
u=0
u s.t. coordinate v was written
for u before t
[g(Ë†xu, Î±Ë†
u
, iu)]v .
(6)
This proved crucial for our Asaga proof and allowed us to obtain better bounds for Hogwild
and the Kromagnon algorithm presented in Mania et al. (2017).
The main idea of the perturbed iterate framework is to use this handle on xË†t âˆ’ xt to
analyze the convergence for xt
. As xt
is a virtual quantity, Mania et al. (2017) supposed that
there exists an index T such that xT lives in shared memory (T is a pre-set final iteration
number after which all computation is completed, which means xT = xË†T ) and gave their
convergence result for this xT .
In this paper, we instead state the convergence results directly in terms of xË†t
, thus
avoiding the need for an unwieldy pre-set final iteration counter, and also enabling guarantees
during the entire course of the algorithm.
Remark 1 As mentioned in footnote 9, Mania et al. (2017) choose to sample a data point
first and only then read the shared parameter vector in (5). One advantage of this option is
that it allows for reading only the relevant dimensions of the parameter vector, although it
means losing the crucial independence property between xË†t and it.
We can thus consider that their labeling approach is â€œafter samplingâ€ rather than â€œbefore
readâ€ (both are equivalent given their ordering). If we take this view, then by switching the
order of the sampling and the reading steps in their setup, the â€œafter samplingâ€ approach
becomes equivalent to our proposed â€œafter readâ€ labeling.
However, the framework in which they place their analysis is the â€œbefore readâ€ approach
as described above, which results in having to take into account troublesome â€œfutureâ€ terms
in (6). These additional terms make the analysis considerably harder and ultimately lead to
worse theoretical results.
3. Asynchronous Parallel Sparse Saga
We start by presenting Sparse Saga, a sparse variant of the Saga algorithm that is more
adapted to the asynchronous parallel setting. We then introduce Asaga, the asynchronous
parallel version of Sparse Saga. Finally, we state both convergence and speedup results for
Asaga and give an outline of their proofs.
3.1. Sparse Saga
Borrowing our notation from Hofmann et al. (2015), we first present the original Saga
algorithm and then describe our novel sparse variant.
Original Saga Algorithm. The standard Saga algorithm (Defazio et al., 2014) maintains
two moving quantities to optimize (1): the current iterate x and a table (memory) of historical
8
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
gradients (Î±i)
n
i=1.
11 At every iteration, the Saga algorithm samples uniformly at random an
index i âˆˆ {1, . . . , n}, and then executes the following update on x and Î± (for the unconstrained
optimization version):
x
+ = x âˆ’ Î³

f
0
i
(x) âˆ’ Î±i + Â¯Î±

; Î±
+
i = f
0
i
(x), (7)
where Î³ is the step size and Î±Â¯ := 1/n
Pn
i=1 Î±i can be updated efficiently in an online
fashion. Crucially, EÎ±i = Î±Â¯ and thus the update direction is unbiased (Ex
+ = x âˆ’ Î³f0
(x)).
Furthermore, it can be proven (see Defazio et al., 2014) that under a reasonable condition on
Î³, the update has vanishing variance, which enables the algorithm to converge linearly with
a constant step size.
Motivation for a Variant. In its current form, every Saga update is dense even if the
individual gradients are sparse due to the historical gradient (Î±Â¯) term. Schmidt et al. (2016)
introduced an implementation technique denoted lagged updates in which each iteration has a
cost proportional to the size of the support of f
0
i
(x). However, this technique involves keeping
track of past updates and is not easily adaptable to the parallel setting (see Appendix E).
We therefore introduce Sparse Saga, a novel variant which explicitly takes sparsity into
account and is easily parallelizable.
Sparse Saga Algorithm. As in the Sparse Svrg algorithm proposed in Mania et al.
(2017), we obtain Sparse Saga by a simple modification of the parameter update rule in (7)
where Î±Â¯ is replaced by a sparse version equivalent in expectation:
x
+ = x âˆ’ Î³(f
0
i
(x) âˆ’ Î±i + DiÎ±Â¯), (8)
where Di
is a diagonal matrix that makes a weighted projection on the support of f
0
i
. More
precisely, let Si be the support of the gradient f
0
i
function (i.e., the set of coordinates where
f
0
i
can be nonzero). Let D be a d Ã— d diagonal reweighting matrix, with coefficients 1/pv on
the diagonal, where pv is the probability that dimension v belongs to Si when i is sampled
uniformly at random in {1, ..., n}. We then define Di
:= PSiD, where PSi
is the projection
onto Si
. The reweighting by D ensures that EDiÎ±Â¯ = Î±Â¯, and thus that the update is still
unbiased despite the sparsifying projection.
Convergence Result for (Serial) Sparse Saga. For clarity of exposition, we model
our convergence result after the simple form of Hofmann et al. (2015, Corollary 3). Note that
the rate we obtain for Sparse Saga is the same as the one obtained in the aforementioned
reference for Saga.
Theorem 2 Let Î³ =
a
5L
for any a â‰¤ 1. Then Sparse Saga converges geometrically in
expectation with a rate factor of at least Ï(a) = 1
5 min  1
n
, a 1
Îº
	
, i.e., for xt obtained after t
updates, we have Ekxtâˆ’x
âˆ—k
2 â‰¤ (1 âˆ’ Ï)
t C0, where C0 := kx0âˆ’x
âˆ—k
2+
1
5L2
Pn
i=1 kÎ±
0
i âˆ’f
0
i
(x
âˆ—
)k
2
.
11. For linear predictor models, the memory Î±
0
i can be stored as a scalar. Following Hofmann et al. (2015), Î±
0
i
can be initialized to any convenient value (typically 0), unlike the prescribed f
0
i (x0) analyzed in (Defazio
et al., 2014).
 
Leblond, Pedregosa and Lacoste-Julien
Proof outline. We reuse the proof technique from Hofmann et al. (2015), in which a
combination of classical strong convexity and Lipschitz inequalities is used to derive the
inequality (Hofmann et al., 2015, Lemma 1):
Ekx
+ âˆ’x
âˆ—
k
2 â‰¤(1âˆ’Î³Âµ)kxâˆ’x
âˆ—
k
2 + 2Î³
2EkÎ±i âˆ’ f
0
i
(x
âˆ—
)k
2 + (4Î³
2L âˆ’ 2Î³)

f(x) âˆ’ f(x
âˆ—
)

. (9)
This gives a contraction term. A Lyapunov function is then defined to control the two other
terms. To ensure our variant converges at the same rate as regular Saga, we only need to
prove that the above inequality (Hofmann et al., 2015, Lemma 1) is still verified. To prove
this, we derive close variants of equations (6) and (9) in their paper. The rest of the proof
can be reused without modification. The full details can be found in Appendix A.
Comparison with Lagged Updates. The lagged updates technique in Saga is based on
the observation that the updates for component [x]v need not be applied until this coefficient
needs to be accessed, that is, until the next iteration t such that v âˆˆ Sit
. We refer the reader
to Schmidt et al. (2016) for more details.
Interestingly, the expected number of iterations between two steps where a given dimension
v is in the support of the partial gradient is p
âˆ’1
v
, where pv is the probability that v is in the
support of the partial gradient at a given step. p
âˆ’1
v
is precisely the term which we use to
multiply the update to [x]v in Sparse Saga. Therefore one may see the updates in Sparse
Saga as anticipated updates, whereas those in the Schmidt et al. (2016) implementation are
lagged.
The two algorithms appear to be very close, even though Sparse Saga uses an expectation
to multiply a given update whereas the lazy implementation uses a random variable (with
the same expectation). Sparse Saga therefore uses a slightly more aggressive strategy, which
may explain the result of our experiments (see Section 6.3): both Sparse Saga and Saga
with lagged updates had similar convergence in terms of number of iterations, with the
Sparse Saga scheme being slightly faster in terms of runtime.
Although Sparse Saga requires the computation of the pv probabilities, this can be done
during a first pass throughout the data (during which constant step size Sgd may be used)
at a negligible cost.
3.2. Asynchronous Parallel Sparse Saga
We describe Asaga, a sparse asynchronous parallel implementation of Sparse Saga, in
Algorithm 1 in the theoretical form that we analyze, and in Algorithm 2 as its practical
implementation. We state our convergence result and analyze our algorithm using the
improved perturbed iterate framework.
In the specific case of (Sparse) Saga, we have to add the additional read memory
argument Î±Ë†
t
to our perturbed update (3):
xt+1 := xt âˆ’ Î³g(Ë†xt
, Î±Ë†
t
, it);
g(Ë†xt
, Î±Ë†
t
, it) := f
0
it
(Ë†xt) âˆ’ Î±Ë†
t
it + Dit

1/n
Pn
i=1 Î±Ë†
t
i

.
(10)
Before stating our convergence result, we highlight some properties of Algorithm 1 and make
one central assumption.
  
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Algorithm 1 Asaga (analyzed algorithm)
1: Initialize shared variables x and (Î±i)
n
i=1
2: keep doing in parallel
3: xË† = inconsistent read of x
4: âˆ€j, Î±Ë†j = inconsistent read of Î±j
5: Sample i uniformly in {1, ..., n}
6: Let Si be fi
â€™s support
7: [Â¯Î±]Si = 1/n
Pn
k=1[Ë†Î±k]Si
8:
9: [Î´x]Si = âˆ’Î³(f
0
i
(Ë†x) âˆ’ Î±Ë†i + Di
[Â¯Î±]Si
)
10: for v in Si do
11: [x]v â† [x]v + [Î´x]v // atomic
12: [Î±i
]v â† [f
0
i
(Ë†x)]v
13: // â€˜â†â€™ denotes a shared memory update.
14: end for
15: end parallel loop
Algorithm 2 Asaga (implementation)
1: Initialize shared x, (Î±i)
n
i=1 and Î±Â¯
2: keep doing in parallel
3: Sample i uniformly in {1, ..., n}
4: Let Si be fi
â€™s support
5: [Ë†x]Si = inconsistent read of x on Si
6: Î±Ë†i = inconsistent read of Î±i
7: [Â¯Î±]Si = inconsistent read of Î±Â¯ on Si
8: [Î´Î±]Si = f
0
i
([Ë†x]Si
) âˆ’ Î±Ë†i
9: [Î´x]Si = âˆ’Î³([Î´Î±]Si + Di
[Â¯Î±]Si
)
10: for v in Si do
11: [x]v â† [x]v + [Î´x]v // atomic
12: [Î±i
]v â† [Î±i
]v + [Î´Î±]v // atomic
13: [Â¯Î±]v â† [ Â¯Î±]v + 1/n[Î´Î±]v // atomic
14: end for
15: end parallel loop
Property 3 (independence) Given the â€œafter readâ€ global ordering, ir is independent of
xË†t âˆ€r â‰¥ t.
The independence property for r = t is assumed in most of the parallel optimization literature,
even though it is not verified in case the â€œafter writeâ€ labeling is used. We emulate Mania
et al. (2017) and enforce this independence in Algorithm 1 by having the core read all the
shared data parameters and historical gradients before starting their iterations. Although
this is too expensive to be practical if the data is sparse, this is required by the theoretical
Algorithm 1 that we can analyze. The independence for r > t is a consequence of using the
â€œafter readâ€ global ordering instead of the â€œbefore readâ€ one.
Property 4 (unbiased estimator) The update, gt
:= g(xË†t
, Î±Ë†
t
, it), is an unbiased estimator of the true gradient at xË†t, i.e. (10) yields (4) in conditional expectation.
This property is crucial for the analysis, as in most related literature. It follows by the
independence of it with xË†t and from the computation of Î±Â¯ on line 7 of Algorithm 1, which
ensures that EÎ±Ë†i = 1/nPn
k=1[Î±Ë†k]Si = [Î±Â¯]Si
, making the update unbiased. In practice,
recomputing Î±Â¯ is not optimal, but storing it instead introduces potential bias issues in the
proof (as detailed in Appendix F.3).
Property 5 (atomicity) The shared parameter coordinate update of [x]v on line 11 is
atomic.
Since our updates are additions, there are no overwrites, even when several cores compete for
the same resources. In practice, this is enforced by using compare-and-swap semantics, which
are heavily optimized at the processor level and have minimal overhead. Our experiments
with non-thread safe algorithms (i.e. where this property is not verified, see Figure 7 of
Appendix F) show that compare-and-swap is necessary to optimize to high accuracy.
11
Leblond, Pedregosa and Lacoste-Julien
Finally, as is standard in the literature, we make an assumption on the maximum delay
that asynchrony can cause â€“ this is the partially asynchronous setting as defined in Bertsekas
and Tsitsiklis (1989):
Assumption 6 (bounded overlaps) We assume that there exists a uniform bound, called Ï„ ,
on the maximum number of iterations that can overlap together. We say that iterations r and
t overlap if at some point they are processed concurrently. One iteration is being processed
from the start of the reading of the shared parameters to the end of the writing of its update.
The bound Ï„ means that iterations r cannot overlap with iteration t for r â‰¥ t + Ï„ + 1, and
thus that every coordinate update from iteration t is successfully written to memory before
the iteration t + Ï„ + 1 starts.
Our result will give us conditions on Ï„ subject to which we have linear speedups. Ï„ is
usually seen as a proxy for p, the number of cores (which lowerbounds it). However, though
Ï„ appears to depend linearly on p, it actually depends on several other factors (notably
the data sparsity distribution) and can be orders of magnitude bigger than p in real-life
experiments. We can upper bound Ï„ by (p âˆ’ 1)R, where R is the ratio of the maximum
over the minimum iteration time (which encompasses theoretical aspects as well as hardware
overhead). More details can be found in Section 6.7.
Explicit effect of asynchrony. By using the overlap Assumption 6 in the expression (6)
for the iterates, we obtain the following explicit effect of asynchrony that is crucially used in
our proof:
xË†t âˆ’ xt = Î³
X
tâˆ’1
u=(tâˆ’Ï„)+
G
t
u
g(Ë†xu, Î±Ë†
u
, iu), (11)
where Gt
u are d Ã— d diagonal matrices with terms in {0, +1}. From our definition of t and xt
,
it is clear that every update in xË†t
is already in xt â€“ this is the 0 case. Conversely, some
updates might be late: this is the +1 case. xË†t may be lacking some updates from the â€œpast"
in some sense, whereas given our global ordering definition, it cannot contain updates from
the â€œfuture".
3.3. Convergence and Speedup Results
We now state our main theoretical results. We give a detailed outline of the proof in
Section 3.3.2 and its full details in Appendix B.
We first define a notion of problem sparsity, as it will appear in our results.
Definition 7 (Sparsity) As in Niu et al. (2011), we introduce âˆ†r := maxv=1..d |{i : v âˆˆ
Si}|. âˆ†r is the maximum right-degree in the bipartite graph of the factors and the dimensions,
i.e., the maximum number of data points with a specific feature. For succinctness, we also
define âˆ† := âˆ†r/n. We have 1 â‰¤ âˆ†r â‰¤ n, and hence 1/n â‰¤ âˆ† â‰¤ 1.
12
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
3.3.1. Convergence and Speedup Statements
Theorem 8 (Convergence guarantee and rate of Asaga) Suppose Ï„ < n/10.
12 Let
a
âˆ—
(Ï„ ) := 1
32 
1 + Ï„
âˆš
âˆ†

Î¾(Îº, âˆ†, Ï„ )
where Î¾(Îº, âˆ†, Ï„ ) := s
1 +
1
8Îº
min{
1
âˆš
âˆ†
, Ï„}
(note that Î¾(Îº, âˆ†, Ï„ ) â‰ˆ 1 unless Îº < 1/
âˆš
âˆ† (â‰¤
âˆš
n)).
(12)
For any step size Î³ =
a
L
with a â‰¤ a
âˆ—
(Ï„ ), the inconsistent read iterates of Algorithm 1 converge
in expectation at a geometric rate of at least: Ï(a) = 1
5 min  1
n
, a 1
Îº
	
, i.e., Ef(xË†t) âˆ’ f(x
âˆ—
) â‰¤
(1âˆ’Ï)
t CËœ
0, where CËœ
0 is a constant independent of t (â‰ˆ
n
Î³
C0 with C0 as defined in Theorem 2).
This result is very close to Sagaâ€™s original convergence theorem, but with the maximum step
size divided by an extra 1 + Ï„
âˆš
âˆ† factor. Referring to Hofmann et al. (2015) and our own
Theorem 2, the rate factor for Saga is min{1/n, a/Îº} up to a constant factor. Comparing
this rate with Theorem 8 and inferring the conditions on the maximum step size a
âˆ—
(Ï„ ), we
get the following conditions on the overlap Ï„ for Asaga to have the same rate as Saga
(comparing upper bounds).
Corollary 9 (Speedup condition) Suppose Ï„ â‰¤ O(n) and Ï„ â‰¤ O( âˆš1
âˆ† max{1,
n
Îº
}). Then
using the step size Î³ = a
âˆ—(Ï„)/L from (12), Asaga converges geometrically with rate factor
â„¦(min{
1
n
,
1
Îº
}) (similar to Saga), and is thus linearly faster than its sequential counterpart
up to a constant factor. Moreover, if Ï„ â‰¤ O( âˆš
1
âˆ†
), then a universal step size of Î˜( 1
L
) can be
used for Asaga to be adaptive to local strong convexity with a similar rate to Saga (i.e.,
knowledge of Îº is not required).
Interestingly, in the well-conditioned regime (n > Îº, where Saga enjoys a range of step sizes
which all give the same contraction ratio), Asaga enjoys the same rate as Saga even in
the non-sparse regime (âˆ† = 1) for Ï„ < O(n/Îº). This is in contrast to the previous work on
asynchronous incremental gradient methods which required some kind of sparsity to get a
theoretical linear speedup over their sequential counterpart (Niu et al., 2011; Mania et al.,
2017). In the ill-conditioned regime (Îº > n), sparsity is required for a linear speedup, with a
bound on Ï„ of O(
âˆš
n) in the best-case (though degenerate) scenario where âˆ† = 1/n.
The proof for Corollary 9 can be found in Appendix B.9.
Comparison to related work.
â€¢ We give the first convergence analysis for an asynchronous parallel version of Saga
(note that Reddi et al. (2015) only covers an epoch based version of Saga with random
stopping times, a fairly different algorithm).
â€¢ Theorem 8 can be directly extended to the a parallel extension of the Svrg version
from Hofmann et al. (2015) which is adaptive to the local strong convexity with similar
rates (see Section 4.2).
â€¢ In contrast to the parallel Svrg analysis from Reddi et al. (2015, Thm. 2), our proof
technique handles inconsistent reads and a non-uniform processing speed across fi
â€™s.
12. Asaga can actually converge for any Ï„ , but the maximum step size then has a term of exp(Ï„ /n) in the
denominator with much worse constants. See Appendix B.7.
13
Leblond, Pedregosa and Lacoste-Julien
Our bounds are similar (noting that âˆ† is equivalent to theirs), except for the adaptivity
to local strong convexity: Asaga does not need to know Îº for optimal performance,
contrary to parallel Svrg (see Section 4 for more details).
â€¢ In contrast to the Svrg analysis from Mania et al. (2017, Thm. 14), we obtain a better
dependence on the condition number in our rate (1/Îº vs. 1/Îº2 on their work) and on
the sparsity (they obtain Ï„ â‰¤ O(âˆ†âˆ’1/3
)), while we furthermore remove their gradient
bound assumption. We also give our convergence guarantee on xË†t during the algorithm,
whereas they only bound the error for the â€œlastâ€ iterate xT .
3.3.2. Proof Outline of Theorem 8
We give here an extended outline of the proof. We detail key lemmas in Section 3.3.3.
Initial recursive inequality. Let gt
:= g(xË†t
, Î±Ë†
t
, it). By expanding the update equation (10) defining the virtual iterate xt+1 and introducing xË†t
in the inner product term, we
obtain:
kxt+1 âˆ’ x
âˆ—
k
2 = kxt âˆ’ Î³gt âˆ’ x
âˆ—
k
2
= kxt âˆ’ x
âˆ—
k
2 + Î³
2
kgtk
2 âˆ’ 2Î³hxt âˆ’ x
âˆ—
, gti
= kxt âˆ’ x
âˆ—
k
2 + Î³
2
kgtk
2 âˆ’ 2Î³hxË†t âˆ’ x
âˆ—
, gti + 2Î³hxË†t âˆ’ xt
, gti. (13)
Note that we introduce xË†t
in the inner product because gt
is a function of xË†t
, not xt
.
In the sequential setting, we require it to be independent of xt to obtain unbiasedness.
In the perturbed iterate framework, we instead require that it
is independent of xË†t (see
Property 3). This crucial property enables us to use the unbiasedness condition (4) to write:
EhxË†tâˆ’x
âˆ—
, gti = EhxË†tâˆ’x
âˆ—
, f0
(xË†t)i. Taking the expectation of (13) and using this unbiasedness
condition we obtain an expression that allows us to use the Âµ-strong convexity of f:
13
hxË†t âˆ’ x
âˆ—
, f0
(Ë†xt)i â‰¥ f(Ë†xt) âˆ’ f(x
âˆ—
) + Âµ
2
kxË†t âˆ’ x
âˆ—
k
2
. (14)
With further manipulations on the expectation of (13), including the use of the standard
inequality ka + bk
2 â‰¤ 2kak
2 + 2kbk
2
(see Appendix B.1), we obtain our basic recursive
contraction inequality:
at+1 â‰¤ (1 âˆ’
Î³Âµ
2
)at + Î³
2Ekgtk
2 +Î³ÂµEkxË†t âˆ’ xtk
2 + 2Î³EhxË†t âˆ’ xt
, gti
| {z }
additional asynchrony terms
âˆ’2Î³et
, (15)
where at
:= Ekxt âˆ’ x
âˆ—k
2 and et
:= Ef(Ë†xt) âˆ’ f(x
âˆ—
).
Inequality (15) is a midway point between the one derived in the proof of Lemma 1
in Hofmann et al. (2015) and Equation (2.5) in Mania et al. (2017), because we use the
tighter strong convexity bound (14) than in the latter (giving us the important extra term
âˆ’2Î³et).
In the sequential setting, one crucially uses the negative suboptimality term âˆ’2Î³et to
cancel the variance term Î³
2Ekgtk
2
(thus deriving a condition on Î³). In our setting, we need
13. Note that here is our departure point with Mania et al. (2017) who replaced the f(xË†t) âˆ’ f(x
âˆ—
) term with
the lower bound Âµ
2
kxË†t âˆ’ x
âˆ—
k
2
in this relationship (see their Equation (2.4)), thus yielding an inequality
too loose afterwards to get the fast rates for Svrg.
14
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
to bound the additional asynchrony terms using the same negative suboptimality in order to
prove convergence and speedup for our parallel algorithm â€“ this will give stronger constraints
on the maximum step size.
The rest of the proof then proceeds as follows:
1. By using the expansion (11) for xË†t âˆ’ xt
, we can bound the additional asynchrony terms
in (15) in terms of the past updates (Ekguk
2
)uâ‰¤t
. This gives Lemma 10 below.
2. We then bound the updates Ekgtk
2
in terms of past suboptimalities (ev)vâ‰¤u by using
standard Saga inequalities and carefully analyzing the update rule for Î±
+
i
(7) in
expectation. This gives Lemma 13 below.
3. By applying Lemma 13 to the result of Lemma 10, we obtain a master contraction
inequality (27) in terms of at+1, at and (eu)uâ‰¤t
.
4. We define a novel Lyapunov function Lt =
Pt
u=0(1 âˆ’ Ï)
tâˆ’uau and manipulate the
master inequality to show that Lt
is bounded by a contraction, subject to a maximum
step size condition on Î³ (given in Lemma 14 below).
5. Finally, we unroll the Lyapunov inequality to get the convergence Theorem 8.
3.3.3. Details
We list the key lemmas below with their proof sketch, and pointers to the relevant parts of
Appendix B for detailed proofs.
Lemma 10 (Inequality in terms of gt
:= g(Ë†xt
, Î±Ë†
t
, it)) For all t â‰¥ 0:
at+1 â‰¤ (1 âˆ’
Î³Âµ
2
)at + Î³
2C1Ekgtk
2 + Î³
2C2
X
tâˆ’1
u=(tâˆ’Ï„)+
Ekguk
2 âˆ’ 2Î³et
, (16)
where C1 := 1 + âˆš
âˆ†Ï„ and C2 := âˆš
âˆ† + Î³ÂµC1 .
14 (17)
To prove this lemma we need to bound both EkxË†t âˆ’ x
âˆ—k
2 and EhxË†t âˆ’ xt
, gti with respect to
(Ekguk
2
)uâ‰¤t
. We achieve this by crucially using Equation (11), together with the following
proposition, which we derive by a combination of Cauchy-Schwartz and our sparsity definition
(see Section B.2).
Proposition 11 For any u 6= t,
E|hgu, gti| â‰¤
âˆš
âˆ†
2
(Ekguk
2 + Ekgtk
2
). (18)
To derive this essential inequality for both the right-hand-side terms of Eq. (18), we start by
proving a relevant property of âˆ†. We reuse the sparsity constant introduced in Reddi et al.
(2015) and relate it to the one we have defined earlier, âˆ†r:
14. Note that C2 depends on Î³. In the rest of the paper, we write C2(Î³) instead of C2 when we want to draw
attention to that dependency.
15
Leblond, Pedregosa and Lacoste-Julien
Remark 12 Let D be the smallest constant such that:
Ekxk
2
i =
1
n
Xn
i=1
kxk
2
i â‰¤ Dkxk
2 âˆ€x âˆˆ R
d
, (19)
where k.ki is defined to be the `2-norm restricted to the support Si of fi. We have:
D =
âˆ†r
n
= âˆ† . (20)
Proof We have:
Ekxk
2
i =
1
n
Xn
i=1
kxk
2
i =
1
n
Xn
i=1
X
vâˆˆSi
[x]
2
v =
1
n
X
d
v=1
X
i|vâˆˆSi
[x]
2
v =
1
n
X
d
v=1
Î´v[x]
2
v
, (21)
where Î´v := |(i | v âˆˆ Si)|. This implies:
D â‰¥
1
n
X
d
v=1
Î´v
[x]
2
v
kxk
2
. (22)
Since D is the minimum constant satisfying this inequality, we have:
D = max
xâˆˆRd
1
n
X
d
v=1
Î´v
[x]
2
v
kxk
2
. (23)
We need to find x such that it maximizes the right-hand side term. Note that the vector
([x]
2
v/kxk
2
)v=1..d is in the unit probability simplex, which means that an equivalent problem
is the maximization over all convex combinations of (Î´v)v=1..d. This maximum is found by
putting all the weight on the maximum Î´v, which is âˆ†r by definition.
This implies that âˆ† = âˆ†r/n is indeed the smallest constant satisfying (19).
Proof of Proposition 11 Let u 6= t. Without loss of generality, u < t.
15 Then:
E|hgu, gti| â‰¤ Ekgukitkgtk (Sparse inner product; support of gt
is Sit
)
â‰¤
q
Ekguk
2
it
p
Ekgtk
2 (Cauchy-Schwarz for expectations)
â‰¤
p
âˆ†Ekguk
2
p
Ekgtk
2 (Remark 12 and it âŠ¥âŠ¥ gu, âˆ€u < t)
â‰¤
âˆš
âˆ†
2
(Ekguk
2 + Ekgtk
2
). (AM-GM inequality)
All told, we have:
E|hgu, gti| â‰¤
âˆš
âˆ†
2
(Ekguk
2 + Ekgtk
2
). (24)
15. One only has to switch u and t if u > t.
16
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Lemma 13 (Suboptimality bound on Ekgtk
2
) For all t â‰¥ 0,
Ekgtk
2 â‰¤ 4Let +
4L
n
X
tâˆ’1
u=1
(1 âˆ’
1
n
)
(tâˆ’2Ï„âˆ’uâˆ’1)+ eu + 4L(1 âˆ’
1
n
)
(tâˆ’Ï„)+ eËœ0 , (25)
where eËœ0 := 1
2L
EkÎ±
0
i âˆ’ f
0
i
(x
âˆ—
)k
2
.
16
From our proof of convergence for Sparse Saga we know that (see Appendix A):
Ekgtk
2 â‰¤ 2Ekf
0
it
(Ë†xt) âˆ’ f
0
it
(x
âˆ—
)k
2 + 2EkÎ±Ë†
t
it âˆ’ f
0
it
(x
âˆ—
)k
2
. (26)
We can handle the first term by taking the expectation over a Lipschitz inequality (Hofmann
et al. (2015, Equations 7 and 8). All that remains to prove the lemma is to express the
EkÎ±Ë†
t
it âˆ’ f
0
it
(x
âˆ—
)k
2
term in terms of past suboptimalities. We note that it can be seen as an
expectation of past first terms with an adequate probability distribution which we derive
and bound.
From our algorithm, we know that each dimension of the memory vector [Î±Ë†i
]v contains a
partial gradient computed at some point in the past [f
0
i
(xË†u
t
i,v
)]v
17 (unless u = 0, in which case
we replace the partial gradient with Î±
0
i
). We then derive bounds on P(u
t
i,v = u) and sum on
all possible u. Together with clever conditioning, we obtain Lemma 13 (see Section B.3).
Master inequality. Let Ht be defined as Ht
:= Ptâˆ’1
u=1(1 âˆ’
1
n
)
(tâˆ’2Ï„âˆ’uâˆ’1)+ eu. Then, by
setting (25) into Lemma 10, we get (see Section B.5):
at+1 â‰¤(1 âˆ’
Î³Âµ
2
)at âˆ’ 2Î³et + 4LÎ³2C1

et + (1 âˆ’
1
n
)
(tâˆ’Ï„)+ eËœ0

+
4LÎ³2C1
n
Ht
+ 4LÎ³2C2
X
tâˆ’1
u=(tâˆ’Ï„)+
(eu + (1 âˆ’
1
n
)
(uâˆ’Ï„)+ eËœ0

+
4LÎ³2C2
n
X
tâˆ’1
u=(tâˆ’Ï„)+
Hu .
(27)
Lyapunov function and associated recursive inequality. We now have the beginning
of a contraction with additional positive terms which all converge to 0 as we near the
optimum, as well as our classical negative suboptimality term. This is not unusual in the
variance reduction literature. One successful approach in the sequential case is then to define
a Lyapunov function which encompasses all terms and is a true contraction (see Defazio
et al., 2014; Hofmann et al., 2015). We emulate this solution here. However, while all terms
in the sequential case only depend on the current iterate, t, in the parallel case we have terms
â€œfrom the pastâ€ in our inequality. To resolve this issue, we define a more involved Lyapunov
function which also encompasses past iterates:
Lt =
X
t
u=0
(1 âˆ’ Ï)
tâˆ’u
au, 0 < Ï < 1, (28)
where Ï is a target contraction rate that we define later.
16. We introduce this quantity instead of e0 so as to be able to handle the arbitrary initialization of the Î±
0
i
.
17. More precisely: âˆ€t, i, v âˆƒu
t
i,v < t s.t. [Ë†Î±
t
i
]v = [f
0
i (Ë†xut
i,v
)]v.
1 
Leblond, Pedregosa and Lacoste-Julien
Using the master inequality (27), we get (see Appendix B.6):
Lt+1 = (1 âˆ’ Ï)
t+1a0 +
X
t
u=0
(1 âˆ’ Ï)
tâˆ’u
au+1
â‰¤ (1 âˆ’ Ï)
t+1a0 + (1 âˆ’
Î³Âµ
2
)Lt +
X
t
u=1
r
t
u
eu + r
t
0
eËœ0 . (29)
The aim is to prove that Lt
is bounded by a contraction. We have two promising terms at
the beginning of the inequality, and then we need to handle the last term. Basically, we can
rearrange the sums in (27) to expose a simple sum of eu multiplied by factors r
t
u
.
Under specific conditions on Ï and Î³, we can prove that r
t
u
is negative for all u â‰¥ 1, which
coupled with the fact that each eu is positive means that we can safely drop the sum term
from the inequality. The r
t
0
term is a bit trickier and is handled separately.
In order to obtain a bound on et directly rather than on EkxË†t âˆ’ x
âˆ—k
2
, we then introduce
an additional Î³et term on both sides of (29). The bound on Î³ under which the modified
r
t
t + Î³ is negative is then twice as small (we could have used any multiplier between 0 and
2Î³, but chose Î³ for simplicityâ€™s sake). This condition is given in the following Lemma.
Lemma 14 (Sufficient condition for convergence) Suppose Ï„ < n/10 and Ï â‰¤ 1/4n. If
Î³ â‰¤ Î³
âˆ— =
1
32L(1 + âˆš
âˆ†Ï„ )
q
1 + 1
8Îº min(Ï„, âˆš
1
âˆ†
)
(30)
then for all u â‰¥ 1, the coefficients r
t
u
from (29) are negative. Furthermore, we have r
t
t +Î³ â‰¤ 0
and thus:
Î³et + Lt+1 â‰¤ (1 âˆ’ Ï)
t+1a0 + (1 âˆ’
Î³Âµ
2
)Lt + r
t
0
eËœ0 . (31)
We obtain this result after carefully deriving the r
t
u
terms. We find a second-order polynomial
inequality in Î³, which we simplify down to (30) (see Appendix B.7).
We can then finish the argument to bound the suboptimality error et
. We have:
Lt+1 â‰¤ Î³et + Lt+1 â‰¤ (1 âˆ’
Î³Âµ
2
)Lt + (1 âˆ’ Ï)
t+1(a0 + AeËœ0). (32)
We have two linearly contracting terms. The sum contracts linearly with the worst rate
between the two (the smallest geometric rate factor). If we define Ï
âˆ—
:= Î½ min(Ï, Î³Âµ/2), with
0 < Î½ < 1,
18 then we get:
Î³et + Lt+1 â‰¤ (1 âˆ’
Î³Âµ
2
)
t+1L0 + (1 âˆ’ Ï
âˆ—
)
t+1 a0 + AeËœ0
1 âˆ’ Î·
(33)
Î³et â‰¤ (1 âˆ’ Ï
âˆ—
)
t+1
L0 +
1
1 âˆ’ Î·
(a0 + AeËœ0)

, (34)
where Î· := 1âˆ’M
1âˆ’Ï
âˆ— with M := max(Ï, Î³Âµ/2). Our geometric rate factor is thus Ï
âˆ—
(see
Appendix B.8).
18. Î½ is introduced to circumvent the problematic case where Ï and Î³Âµ/2 are too close together.
1 
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
4. Asynchronous Parallel Svrg with the â€œAfter Readâ€ Labeling
Asaga vs. asynchronous Svrg. There are several scenarios in which Asaga can be
practically advantageous over its closely related cousin, asynchronous Svrg (note though
that â€œasynchronousâ€ Svrg still requires one synchronization step per epoch to compute a
full gradient).
First, while Saga trades memory for less computation, in the case of generalized linear
models the memory cost can be reduced to O(n), compared to O(d) for Svrg (Johnson and
Zhang, 2013). This is of course also true for their asynchronous counterparts.
Second, as Asaga does not require any synchronization steps, it is better suited to
heterogeneous computing environments (where cores have different clock speeds or are shared
with other applications).
Finally, Asaga does not require knowing the condition number Îº for optimal convergence
in the sparse regime. It is thus adaptive to local strong convexity, whereas Svrg is not.
Indeed, Svrg and its asynchronous variant require setting an additional hyper-parameter
â€“ the epoch size m â€“ which needs to be at least â„¦(Îº) for convergence but yields a slower
effective convergence rate than Asaga if it is set much bigger than Îº. Svrg thus requires
tuning this additional hyper-parameter or running the risk of either slower convergence (if
the epoch size chosen is much bigger than the condition number) or even not converging at
all (if m is chosen to be much smaller than Îº).19
Motivation for analyzing asynchronous Svrg. Despite the advantages that we have
just listed, in the case of complex models, the storage cost of Saga may become too expensive
for practical use. Svrg (Johnson and Zhang, 2013) trades off more computation for less
storage and does not suffer from this drawback. It can thus be applied to cases where Saga
cannot (e.g. deep learning models, see Reddi et al., 2016).
Another advantage of Kromagnon is that the historical gradient term f
0
(xËœ) is fixed
during an epoch, while its Asaga equivalent, Î±Â¯, has to be updated at each iteration, either
by recomputing if from the Î±Ë† â€“ which is costly â€“ or by updating a maintained quantity
â€“ which is cheaper but may ultimately result in introducing some bias in the update (see
Appendix F.3 for more details on this subtle issue).
It is thus worthwhile to carry out the analysis of Kromagnon (Mania et al., 2017)20, the
asynchronous parallel version of Svrg, although it has to be noted that since Svrg requires
regularly computing batch gradients, Kromagnon will present regular synchronization steps
as well as coordinated computation â€“ making it less attractive for the asynchronous parallel
setting.
We first extend our Asaga analysis to analyze the convergence of a variant of Svrg
presented in Hofmann et al. (2015), obtaining exactly the same bounds. This variant improves
upon the initial algorithm because it does not require tuning the epoch size hyperparameter
and is thus adaptive to local strong convexity (see Section 4.1). Furthermore, it allows for a
19. Note that as Saga (and contrary to the original Svrg) the Svrg variant from Hofmann et al. (2015)
does not require knowledge of Îº and is thus adaptive to local strong convexity, which carries over to its
asynchronous adaptation that we analyze in Section 4.2.
20. The speedup analysis presented in Mania et al. (2017) is not fully satisfactory as it does not achieve
state-of-the-art convergence results for either Svrg or Kromagnon. Furthermore, we are able to remove
their uniform gradient bound assumption, which is inconsistent with strong convexity.
19
Leblond, Pedregosa and Lacoste-Julien
cleaner analysis where â€“ contrary to Svrg â€“ we do not have to replace the final parameters
of an epoch by one of its random iterates.
Then, using our â€œafter readâ€ labeling, we are also able to derive a convergence and speedup
proof for Kromagnon, with comparable results to our Asaga analysis. In particular, we
prove that as for Asaga in the â€œwell-conditionedâ€ regime Kromagnon can achieve a linear
speedup even without sparsity assumptions.
4.1. Svrg Algorithms
We start by describing the original Svrg algorithm, the variant given in Hofmann et al.
(2015) and the sparse asynchronous parallel adaptation, Kromagnon.
Original Svrg algorithm. The standard Svrg algorithm (Johnson and Zhang, 2013) is
very similar to Saga. The main difference is that instead of maintaining a table of historical
gradients, Svrg uses a â€œreferenceâ€ batch gradient f
0
(xËœ), updated at regular intervals (typically
every m iterations, where m is a hyper-parameter). Svrg is thus an epoch-based algorithm,
where at the beginning of every epoch a reference iterate xËœ is chosen and its gradient is
computed. Then, at every iteration in the epoch, the algorithm samples uniformly at random
an index i âˆˆ {1, . . . , n}, and then executes the following update on x:
x
+ = x âˆ’ Î³

f
0
i
(x) âˆ’ f
0
i
(Ëœx) + f
0
(Ëœx)

. (35)
As for Saga the update direction is unbiased (Ex
+ = x âˆ’ Î³f0
(x)) and it can be proven (see
Johnson and Zhang, 2013) that under a reasonable condition on Î³ and m (the epoch size),
the update has vanishing variance, which enables the algorithm to converge linearly with a
constant step size.
Hofmannâ€™s Svrg variant. Hofmann et al. (2015) introduce a variant where the size of
the epoch is a random variable. At each iteration t, a first Bernoulli random variable Bt with
p = 1/n is sampled. If Bt = 1, then the algorithm updates the reference iterate, xËœ = xt and
computes its full gradient as its new â€œreference gradientâ€. If Bt = 0, the algorithm executes
the normal Svrg inner update. Note that this variant is adaptive to local strong convexity,
as it does not require the inner loop epoch size m = â„¦(Îº) as a hyperparameter. In that
respect it is closer to Saga than the original Svrg algorithm which is not adaptive.
Kromagnon. Kromagnon, introduced in Mania et al. (2017) is obtained by using the
same sparse update technique as Sparse Saga, and then running the resulting algorithm in
parallel (see Algorithm 3).
4.2. Extension to the Svrg Variant from Hofmann et al. (2015)
We introduce Ahsvrg â€“ a sparse asynchronous parallel version for the Svrg variant from Hofmann et al. (2015) â€“ in Algorithm 4. Every core runs stochastic updates independently as
long as they are all sampling inner updates, and coordinate whenever one of them decides to
do a batch gradient computation. The one difficulty of this approach is that each core needs
to be able to communicate to every other core that they should stop doing inner updates
and start computing a synchronized batch gradient instead.
To this end, we introduce a new shared variable, s, which represents the â€œstateâ€ of the
computation. This variable is checked by each core c before each update. If s = 1, then
2 
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Algorithm 3 Kromagnon (Mania et al., 2017)
1: Initialize shared x and x0
2: while True do
3: Compute in parallel g = f
0
(x0) (synchronously)
4: for i = 1..m do in parallel (asynchronously)
5: Sample i uniformly in {1, ..., n}
6: Let Si be fi
â€™s support
7: [Ë†x]Si = inconsistent read of x on Si
8: [Î´x]Si = âˆ’Î³([f
0
i
(Ë†xt) âˆ’ f
0
i
(x0)]Si + Di
[g]Si
)
9: for v in Si do
10: [x]v = [x]v + [Î´x]v // atomic
11: end for
12: end parallel loop
13: x0 = x
14: end while
Algorithm 4 Ahsvrg
1: Initialize shared x, s and x0
2: while True do
3: Compute in parallel g = f
0
(x0) (synchronously)
4: s = 0
5: while s = 0 do in parallel (asynchronously)
6: Sample B with p = 1/n
7: if B = 1 then
8: s = 1
9: else
10: Sample i uniformly in {1, ..., n}
11: Let Si be fi
â€™s support
12: [Ë†x]Si = inconsistent read of x on Si
13: [Î´x]Si = âˆ’Î³([f
0
i
(Ë†xt) âˆ’ f
0
i
(x0)]Si + Di
[g]Si
)
14: for v in Si do
15: [x]v = [x]v + [Î´x]v // atomic
16: end for
17: end if
18: end parallel loop
19: x0 = x
20: end while
another core has called for a batch gradient computation and core c starts computing its
allocated part of this computation. If s = 0, core c proceeds to sample a first random variable.
Then it either samples and performs an inner update and keeps going, or it samples a full
gradient computation, in which case it updates s to 1 and starts computing its allocated
21
Leblond, Pedregosa and Lacoste-Julien
part of the computation. Once a full gradient is computed, s is set to 0 once again and every
core resume their loop.
Our Asaga convergence and speedup proofs can easily be adapted to accommodate
Ahsvrg since it is closer to Saga than the initial Svrg algorithm. To prove convergence,
all one has to do is to modify Lemma 13 very slightly (the only difference is that the
(t âˆ’ 2Ï„ âˆ’ u âˆ’ 1)+ exponent is replaced by (t âˆ’ Ï„ âˆ’ u âˆ’ 1)+ and the rest of the proof can be
used as is). The justification for this small tweak is that the batch steps in Svrg are fully
synchronized. More details can be found in Appendix B.4.
4.3. Fast Convergence and Speedup Rates for Kromagnon
We now state our main theoretical results. We give a detailed outline of the proof in
Section 4.4 and its full details in Appendix C.
Theorem 15 (Convergence guarantee and rate of Kromagnon) Suppose the step
size Î³ and epoch size m are chosen such that the following condition holds:
0 < Î¸ :=
1
ÂµÎ³m + 2L(1 + 2âˆš
âˆ†Ï„ )(Î³ + Ï„ÂµÎ³2
)
1 âˆ’ 2L(1 + 2âˆš
âˆ†Ï„ )(Î³ + Ï„ÂµÎ³2)
< 1 . (36)
Then the inconsistent read iterates of Kromagnon converge in expectation at a geometric
rate, i.e.
Ef(Ëœxk) âˆ’ f(x
âˆ—
) â‰¤ Î¸
t
(f(x0) âˆ’ f(x
âˆ—
)), (37)
where xËœk is the initial iterate for epoch k, which is obtained by choosing uniformly at random
among the inconsistent read iterates from the previous epoch.
This result is similar to the theorem given in the original Svrg paper (Johnson and Zhang,
2013). Indeed, if we remove the asynchronous part (i.e. if we set Ï„ = 0), we get exactly the
same rate and condition. It also has the same form as the one given in Reddi et al. (2015),
which was derived for dense asynchronous Svrg in the easier setting of consistent read and
writes (and in the flawed â€œafter writeâ€ framework), and gives essentially the same conditions
on Î³ and m.
In the canonical example presented in most Svrg papers, with Îº = n, m = O(n) and
Î³ = 1/10L, Svrg obtains a convergence rate of 0.5. Reddi et al. (2015) get the same rate by
setting Î³ = 1/20 max(1,
âˆš
âˆ†Ï„)L and m = O

n(1 + âˆš
âˆ†Ï„ )

. Following the same line of reasoning
(setting Î³ = 1/20 max(1,
âˆš
âˆ†Ï„)L, Ï„ = O(n) and Î¸ = 0.5 and computing the resulting condition on
m), these values for Î³ and m also give us a convergence rate of 0.5. Therefore, as in Reddi
et al. (2015), when Îº = n we get a linear speedup for Ï„ < 1/
âˆš
âˆ† (which can be as big as âˆš
n
in the degenerate case where no data points share any feature with each other). Note that
this is the same speedup condition as Asaga in this regime.
Svrg theorems are usually similar to Theorem 15, which does not give an optimal step
size or epoch size. This makes the analysis of a parallel speedup difficult, prompting authors
to compare rates in specific cases with most parameters fixed, as we have just done. In order
to investigate the speedup and step size conditions more precisely and thus derive a more
general theorem, we now give Svrg and Kromagnon results modeled on Theorem 8.
2 
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Corollary 16 (Convergence guarantee and rate for serial Svrg) Let Î³ =
a
4L
for any
a â‰¤
1
4
and m =
32Îº
a
. Then Svrg converges geometrically in expectation with a rate factor
per gradient computation of at least Ï(a) = 1
4 min  1
n
,
a
64Îº
	
, i.e.
Ef(Ëœxk) âˆ’ f(x
âˆ—
) â‰¤ (1 âˆ’ Ï)
k(2m+n)
(f(x0) âˆ’ f(x
âˆ—
)) âˆ€k â‰¥ 0 . (38)
Due to Svrgâ€™s special structure, we cannot write Ef(xt) âˆ’ f(x
âˆ—
) â‰¤ (1 âˆ’ Ï)
t
(f(x0) âˆ’ f(x
âˆ—
))
for all t â‰¥ 0. However, expressing the convergence properties of this algorithm in terms of a
rate factor per gradient computation (of which there are 2m + n per epoch) makes it easier
to compare convergence rates, either to similar algorithms such as Saga or to its parallel
variant Kromagnon â€“ and thus to study the speedup obtained by parallelizing Svrg.
Compared to Saga, this result is very close. The main difference is that the additional
hyper-parameter m has to be set and requires knowledge of Âµ. This illustrates the fact that
Svrg is not adaptive to local strong convexity, whereas both Saga and Hofmannâ€™s Svrg
are.
Corollary 17 (Simplified convergence guarantee and rate for Kromagnon) Let
a
âˆ—
(Ï„ ) = 1
4(1 + 2âˆš
âˆ†Ï„ )(1 + Ï„
16Îº
)
. (39)
For any step size Î³ =
a
4L
with a â‰¤ a
âˆ—
(Ï„ ) and m =
32Îº
a
, Kromagnon converges geometrically
in expectation with a rate factor per gradient computation of at least Ï(a) = 1
4 min  1
n
,
a
64Îº
	
,
i.e.
Ef(Ëœxk) âˆ’ f(x
âˆ—
) â‰¤ (1 âˆ’ Ï)
k(2m+n)
(f(x0) âˆ’ f(x
âˆ—
)) âˆ€k â‰¥ 0 . (40)
This result is again quite close to Corollary 16 derived in the serial case. We see that the
maximum step size is divided by an additional (1 + 2Ï„
âˆš
âˆ†) term, while the convergence rate
is the same. Comparing the rates and the maximum allowable step sizes in both settings
give us the sufficient condition on Ï„ to get a linear speedup.
Corollary 18 (Speedup condition) Suppose Ï„ â‰¤ O(n) and Ï„ â‰¤ O( âˆš1
âˆ† max{1,
n
Îº
}). If
n â‰¥ Îº, also suppose Ï„ â‰¤
âˆš
nâˆ†âˆ’1/2
. Then using the step size Î³ = a
âˆ—(Ï„)/L from (39),
Kromagnon converges geometrically with rate factor â„¦(min{
1
n
,
1
Îº
}) (similar to Svrg), and
is thus linearly faster than its sequential counterpart up to a constant factor.
This result is almost the same as Asaga, with the additional condition that Ï„ â‰¤ O(
âˆš
n) in
the well-conditioned regime. We see that in this regime Kromagnon can also get the same
rate as Svrg even without sparsity, which had not been observed in previous work.
Furthermore, one has to note that Ï„ is generally smaller for Kromagnon than for Asaga
since it is reset to 0 at the beginning of each new epoch (where all cores are synchronized
once more).
23
Leblond, Pedregosa and Lacoste-Julien
Comparison to related work.
â€¢ Corollary 16 provides a rate of convergence per gradient computation for Svrg, contrary
to most of the literature on this algorithm (including the seminal paper Johnson and
Zhang, 2013). This result allows for easy comparison with Saga and other algorithms
(in contrast, KoneÄnÃ½ and RichtÃ¡rik 2013 is more involved).
â€¢ In contrast to the Svrg analysis from Reddi et al. (2015, Thm. 2), our proof technique
handles inconsistent reads and a non-uniform processing speed across fi
â€™s. While
Theorem 15 is similar to theirs, Corollary 16 and 17 are more precise results. They
enable a finer analysis of the speedup conditions (Corollary 18) â€“ including the possible
speedup without sparsity regime.
â€¢ In contrast to the Kromagnon analysis from Mania et al. (2017, Thm. 14), Theorem 15
gives a better dependence on the condition number in the rate (1/Îº vs. 1/Îº2
for them)
and on the sparsity (they get Ï„ â‰¤ O(âˆ†âˆ’1/3
)), while we remove their gradient bound
assumption. Our results are state-of-the-art for Svrg (contrary to theirs) and so
our speedup comparison is more meaningful. Finally, Theorem 15 gives convergence
guarantees on xË†t during the algorithm, whereas they only bound the error for the â€œlastâ€
iterate xT .
4.4. Proof of Theorem 15
We now give a detailed outline of the proof. Its full details can be found in Appendix C.
Our proof technique begins as our Asaga analysis. In particular, Properties 3, 4, 5 are also
verified for Kromagnon21, and as in our Asaga analysis, we make Assumption 6 (bounded
overlaps). Consequently, the basic recursive contraction inequality (15) and Lemma 10 also
hold. However, when we derive the equivalent of Lemma 13, we get a slightly different form,
which prompts a difference in the rest of the proof technique.
Lemma 19 (Suboptimality bound on Ekgtk
2
)
Ekgtk
2 â‰¤ 4Let + 4LeËœk âˆ€k â‰¥ 0, km â‰¤ t â‰¤ (k + 1)m , (41)
where eËœk := Ef(Ëœxk) âˆ’ f(x
âˆ—
) and xËœk is the initial iterate for epoch k.
We give the proof in Appendix C.1. To derive both terms, we use the same technique as for
the first term of Lemma 13. Although this is a much simpler result than Lemma 13 in the
case of Asaga, two key differences prevent us from reusing the same Lyapunov function
proof technique. First, the e0 term in Lemma 13 is replaced by eËœk which depends on the
epoch number. Second, this term is not multiplied by a geometrically decreasing quantity,
which means the âˆ’2Î³e0 term is not sufficient to cancel out all of the e0 terms coming from
subsequent inequalities. To solve this issue, we go to more traditional Svrg techniques.
The rest of the proof is as follows:
1. By substituting Lemma 19 into Lemma 10, we get a master contraction inequality (42)
in terms of at+1, at and eu, u â‰¤ t.
21. Note that similarly to Asaga, the Kromagnon algorithm which we analyze reads the parameters first
and then samples. This is necessary in order for Property 3 to be verified at r = t, although not practical
when it comes to actual implementation.
24
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
2. As in Johnson and Zhang (2013), we sum the master contraction inequality over a whole
epoch, and then use the same randomization trick (44) to relate (et)kmâ‰¤tâ‰¤(k+1)mâˆ’1
to
eËœk.
3. We thus obtain a contraction inequality between eËœk and eËœkâˆ’1, which finishes the proof
for Theorem 15.
4. We then only have to derive the conditions on Î³, Ï„ and m under which we contractions
and compare convergence rates to finish the proofs for Corollary 16, Corollary 17 and
Corollary 18.
We list the key points below with their proof sketch, and give the detailed proof in
Appendix C.
Master inequality. As in our Asaga analysis, we apply (41) to the result of Lemma 10,
which gives us that for all k â‰¥ 0, km â‰¤ t â‰¤ (k + 1)m âˆ’ 1 (see Appendix C.2):
at+1 â‰¤ (1 âˆ’
Î³Âµ
2
)at + (4LÎ³2C1 âˆ’ 2Î³)et + 4LÎ³2C2
X
tâˆ’1
u=max(km,tâˆ’Ï„)
eu + (4LÎ³2C1 + 4LÎ³2
Ï„C2)Ëœek .
(42)
Contraction inequality. As we previously mentioned, the term in eËœk is not multiplied
by a geometrically decreasing factor, so using the same Lyapunov function as for Asaga
cannot work. Instead, we apply the same method as in the original Svrg paper (Johnson
and Zhang, 2013): we sum the master contraction inequality over a whole epoch. This gives
us (see Appendix C.2):
a(k+1)m â‰¤ akm + (4LÎ³2C1 + 4LÎ³2
Ï„C2 âˆ’ 2Î³)
(k+1)
Xmâˆ’1
t=km
et + m(4LÎ³2C1 + 4LÎ³2
Ï„C2)Ëœek . (43)
To cancel out the eËœk term, we only have one negative term on the right-hand side of (43):
âˆ’2Î³
P(k+1)mâˆ’1
t=km et
. This means we need to relate P(k+1)mâˆ’1
t=km et to eËœk. We can do it using
the same randomization trick as in Johnson and Zhang (2013): instead of choosing the last
iterate of the k
th epoch as xËœk, we pick one of the iterates of the epoch uniformly at random.
This means we get:
eËœk = Ef(Ëœxk) âˆ’ f(x
âˆ—
) = 1
m
km
Xâˆ’1
t=(kâˆ’1)m
et (44)
We now have: P(k+1)mâˆ’1
t=km et = meËœk+1. Combined with the fact that akm â‰¤
2
Âµ
eËœk and that we
can remove the positive a(k+1)m term from the left-hand-side of (43), this gives us our final
recursion inequality:

2Î³m âˆ’ 4LÎ³2C1m âˆ’ 4LÎ³2
Ï„C2m

eËœk+1 â‰¤
 2
Âµ
+ 4LÎ³2C1m + 4LÎ³2
Ï„C2m

eËœk (45)
Replacing C1 and C2 by their values (defined in 17) in (45) directly leads to Theorem 15.
  
Leblond, Pedregosa and Lacoste-Julien
Algorithm 5 Hogwild
1: Initialize shared variable x
2: keep doing in parallel
3: xË† = inconsistent read of x
4: Sample i uniformly in {1, ..., n}
5: Let Si be fi
â€™s support
6: [Î´x]Si
:= âˆ’Î³f0
i
(Ë†x)
7: for v in Si do
8: [x]v â† [x]v + [Î´x]v // atomic
9: end for
10: end parallel loop
5. Hogwild Analysis
In order to show that our improved â€œafter readâ€ perturbed iterate framework can be used to
revisit the analysis of other optimization routines with correct proofs that do not assume
homogeneous computation, we now provide the analysis of the Hogwild algorithm (i.e.
asynchronous parallel constant step size Sgd) first introduced in Niu et al. (2011).
We start by describing Hogwild in Algorithm 5, and then give our theoretical convergence
and speedup results and their proofs. Note that our framework allows us to easily remove the
classical bounded gradient assumption, which is used in one form or another in most of the
literature (Niu et al., 2011; De Sa et al., 2015; Mania et al., 2017) â€“ although it is inconsistent
with strong convexity in the unconstrained regime. This allows for better bounds where the
uniform bound on kf
0
i
(x)k
2
is replaced by its variance at the optimum.
5.1. Theoretical Results
We now state the theoretical results of our analysis of Hogwild with inconsistent reads and
writes in the â€œafter read frameworkâ€. We give an outline of the proof in Section 5.2 and its
full details in Appendix D. We start with a useful definition.
Definition 20 Let Ïƒ
2 = Ekf
0
i
(x
âˆ—
)k
2
be the variance of the gradient estimator at the optimum.
For reference, we start by giving the rate of convergence of serial Sgd (see e.g. Schmidt,
2014).
Theorem 21 (Convergence guarantee and rate of Sgd) Let a â‰¤
1
2
. Then for any
step size Î³ =
a
L
, Sgd converges in expectation to b-accuracy at a geometric rate of at least:
Ï(a) = a/Îº, i.e., Ekxt âˆ’ x
âˆ—k
2 â‰¤ (1 âˆ’ Ï)
tkx0 âˆ’ x
âˆ—k
2 + b, where b = 2 Î³Ïƒ2
Âµ
.
As Sgd only converges linearly up to a ball around the optimum, to make sure we reach
-accuracy, it is necessary that 2Î³Ïƒ2
Âµ â‰¤ , i.e. Î³ â‰¤
Âµ
2Ïƒ2 . All told, in order to get linear
convergence to -accuracy, serial Sgd requires Î³ â‰¤ min  1
2L
,
Âµ
2Ïƒ2
	
. The proof can be found
in Appendix D.3.
26
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Theorem 22 (Convergence guarantee and rate of Hogwild) Let
a
âˆ—
(Ï„ ) := 1
5

1 + 2Ï„
âˆš
âˆ†

Î¾(Îº, âˆ†, Ï„ )
where Î¾(Îº, âˆ†, Ï„ ) := s
1 +
1
2Îº
min{
1
âˆš
âˆ†
, Ï„}
(note that Î¾(Îº, âˆ†, Ï„ ) â‰ˆ 1 unless Îº < 1/
âˆš
âˆ† (â‰¤
âˆš
n)).
(46)
For any step size Î³ =
a
L
with a â‰¤ min 
a
âˆ—
(Ï„ ),
Îº
Ï„
	
, the inconsistent read iterates of Algorithm 5
converge in expectation to b-accuracy at a geometric rate of at least: Ï(a) = a/Îº, i.e.,
EkxË†t âˆ’ x
âˆ—k
2 â‰¤ (1 âˆ’ Ï)
t
(2kx0 âˆ’ x
âˆ—k
2
) + b, where b = ( 8Î³(C1+Ï„C2)
Âµ + 4Î³
2C1Ï„ )Ïƒ
2 and C1 and
C2(Î³) are defined in (17).
Once again this result is quite close to the one obtained for serial Sgd. Note that we recover
this exact condition (up to a small constant factor) if we set Ï„ = 0, i.e. if we force our
asynchronous algorithm to be serial.
The condition a â‰¤
Îº
Ï„
is equivalent to Î³ÂµÏ„ â‰¤ 1 and should be thought of as a condition on
Ï„ . We will see that it is always verified in the regime we are interested in, that is the linear
speed-up regime (where more stringent conditions are imposed on Ï„ ).
We now investigate the conditions under which Hogwild is linearly faster than Sgd.
Note that to derive these conditions we need not only compare their respective convergence
rates, but also the size of the ball around the optimum to which both algorithms converge.
These quantities are provided in Theorems 21 and 22.
Corollary 23 (Speedup condition) Suppose Ï„ = O(min{ âˆš
1
âˆ†
, Îº}). Then for any step size
Î³ â‰¤
a
âˆ—(Ï„)
L = O(
1
L
) (i.e., any allowable step size for Sgd), Hogwild converges geometrically
to a ball of radius rh = O(
Î³Ïƒ2
Âµ
) with rate factor Ï =
Î³Âµ
2
(similar to Sgd), and is thus linearly
faster than its sequential counterpart up to a constant factor.
Moreover, a universal step size of Î˜( 1
L
) can be used for Hogwild to be adaptive to local
strong convexity with a similar rate to Sgd (i.e., knowledge of Îº is not required).
If Î³ = O(1/L), Hogwild obtains the same convergence rate as Sgd and converges to a ball
of equivalent radius. Since the maximum step size guaranteeing linear convergence for Sgd
is also O(1/L), Hogwild is linearly faster than Sgd for any reasonable step size â€“ under the
condition that Ï„ = O(min{ âˆš
1
âˆ†
, Îº}). We also remark that since Î³ â‰¤ 1/L and Ï„ â‰¤ Îº, we have
Î³ÂµÏ„ â‰¤ 1, which means the condition a â‰¤
Îº
Ï„
is superseded by a â‰¤ a
âˆ—
(Ï„ ) in Theorem 22.
We note that the condition on Ï„ is much more restrictive if the condition number is small
than for Asaga and Kromagnon. This can be explained by the fact that both Saga and
Svrg have a composite rate factor which is not directly proportional to the step size. As a
result, in the well-conditioned setting these algorithms enjoy a range of step sizes that all
give the same contraction rate. This allows their asynchronous variants to use smaller step
sizes while maintaining linear speedups. Sgd, on the other hand, has a rate factor that is
directly proportional to its step size, hence the more restrictive condition on Ï„ .
Function values results. Our results are derived directly on iterates, that is, we bound
the distance between xË†t and x
âˆ—
. We can easily obtain results on function values to
27
Leblond, Pedregosa and Lacoste-Julien
bound Ef(Ë†xt) âˆ’ f(x
âˆ—
) by adapting the classical smoothness inequality:22 Ef(xt) âˆ’ f(x
âˆ—
) â‰¤
L
2
Ekxt âˆ’ x
âˆ—k
2
to the asynchronous parallel setting.
Convergence to -accuracy. As noted in Mania et al. (2017), for our algorithm to
converge to -accuracy for some  > 0, we require an additional bound on the step size to
make sure that the radius of the ball to which we converge is small enough. For Sgd, this
means using a step size Î³ = O(
Âµ
Ïƒ2 ) (see Appendix D.3). We can also prove that under the
conditions that Ï„ = O( âˆš
1
âˆ†
) and Î³ÂµÏ„ â‰¤ 1, Hogwild requires the same bound on the step
size to converge to -accuracy (see Appendix D.4).
If  is small enough, the active upper bound on the step size is Î³ = O(
Âµ
Ïƒ2 ) for both
algorithms. In this regime, we obtain a relaxed condition on Ï„ for a linear speedup. The
condition Ï„ â‰¤ Îº which came from comparing maximum allowable step sizes is removed.
Instead, we enforce Î³ÂµÏ„ â‰¤ 1, which gives us the weaker condition Ï„ = O(
Ïƒ
2
Âµ2 ). Our condition
on the overlap is then: Ï„ = O(min{ âˆš
1
âˆ†
,
Ïƒ
2
Âµ2 }). We see that this is similar to the condition
obtained by Mania et al. (2017, Theorem 4) in their Hogwild analysis, although we have
the variance at the optimum Ïƒ
2
instead of a squared global bound on the gradient.
Comparison to related work.
â€¢ We give the first convergence analysis for Hogwild with no assumption on a global
bound on the gradient (M). This allows us to replace the usual dependence in M2 by
a term in Ïƒ
2 which is potentially significantly smaller. This means improved upper
bounds on the step size and the allowed overlap.
â€¢ We obtain the same condition on the step size for linear convergence to -accuracy
of Hogwild as previous analysis for serial Sgd (e.g. Needell et al., 2014) â€“ given
Ï„ â‰¤ 1/Î³Âµ.
â€¢ In contrast to the Hogwild analysis from Niu et al. (2011); De Sa et al. (2015), our
proof technique handles inconsistent reads and a non-uniform processing speed across
fi
â€™s. Further, Corollary 23 gives a better dependence on the sparsity than in Niu et al.
(2011), where Ï„ â‰¤ O(âˆ†âˆ’1/4
), and does not require various bounds on the gradient
assumptions.
â€¢ In contrast to the Hogwild analysis from Mania et al. (2017, Thm. 3), removing their
gradient bound assumption enables us to get a (potentially) significantly better upper
bound condition on Ï„ for a linear speedup. We also give our convergence guarantee on
xË†t during the algorithm, whereas they only bound the error for the â€œlastâ€ iterate xT .
5.2. Proof of Theorem 22 and Corollary 23
Here again, our proof technique begins as our Asaga analysis, with Properties 3, 4, 5 also
verified for Hogwild23. As in our Asaga analysis, we make Assumption 6. Consequently,
the basic recursive contraction inequality (15) and Lemma 10 also hold. As for Kromagnon,
the proof diverges when we derive the equivalent of Lemma 13.
22. See e.g. Moulines and Bach (2011).
23. Once again, in our analysis the Hogwild algorithms reads the parameters before sampling, so that
Property 3 is verified for r = t.
28
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Lemma 24 (Suboptimality bound on Ekgtk
2
) For all t â‰¥ 0,
Ekgtk
2 â‰¤ 4Let + 2Ïƒ
2
. (47)
We give the proof in Appendix D.1. To derive both terms, we use the same technique as
for the first term of Lemma 13. This result is simpler than both Lemma 13 (for Asaga)
and Lemma 19 (for Kromagnon). The second term in this case does not even vanish as t
grows. This reflects the fact that constant step size Sgd does not converge to the optimum
but rather to a ball around it. However, this simpler form allows us to simply unroll the
resulting master inequality to get our convergence result.
The rest of the proof is as follows:
1. By substituting Lemma 24 into Lemma 10, we get a master contraction inequality (48)
in terms of at+1, at
, (eu, u â‰¤ t) and Ïƒ
2
.
2. We then unroll this master inequality and cleverly regroup terms to obtain a contraction
inequality (49) between at
, a0 and Ïƒ
2
.
3. By using that kxË†tâˆ’x
âˆ—k
2 â‰¤ 2at+ 2kxË†tâˆ’xtk
2
, we obtain a contraction inequality directly
on the â€œrealâ€ iterates (as opposed to the â€œvirtualâ€ iterates as in Mania et al., 2017),
subject to a maximum step size condition on Î³. This finishes the proof for Theorem 22.
4. Finally, we only have to derive the conditions on Î³ and Ï„ under which Hogwild
converges with a similar convergence rate to a ball with a similar radius than serial
Sgd to finish the proof for Corollary 23.
We list the key points below with their proof sketch, and give the detailed proof in
Appendix D.
Master inequality. As in our Asaga analysis, we plug (47) in Lemma 10, which gives us
that (see Appendix D.2):
at+1 â‰¤ (1 âˆ’
Î³Âµ
2
)at + (4LÎ³2C1 âˆ’ 2Î³)et + 4LÎ³2C2
X
tâˆ’1
u=(tâˆ’Ï„)+
eu + 2Î³
2Ïƒ
2
(C1 + Ï„C2). (48)
Contraction inequality on xt. As we previously mentioned, the term in Ïƒ
2 does not
vanish so we cannot use either our Asaga or our Kromagnon proof technique. Instead, we
unroll Equation (48) all the way to t = 0. This gives us (see Appendix D.2):
at+1 â‰¤ (1âˆ’
Î³Âµ
2
)
t+1a0+(4LÎ³2C1+8LÎ³2
Ï„C2âˆ’2Î³)
X
t
u=0
(1âˆ’
Î³Âµ
2
)
tâˆ’u
eu+
4Î³Ïƒ2
Âµ
(C1+Ï„C2). (49)
29
Leblond, Pedregosa and Lacoste-Julien
Contraction inequality on xË†t. We now use that kxË†t âˆ’ x
âˆ—k
2 â‰¤ 2at + 2kxË†t âˆ’ xtk
2
together
with our previous bound (65). Together with (49), we get (see Appendix D.2):
EkxË†t âˆ’ x
âˆ—
k
2 â‰¤ (1 âˆ’
Î³Âµ
2
)
t+12a0 +
8Î³(C1 + Ï„C2)
Âµ
+ 4Î³
2C1Ï„

Ïƒ
2
+ (24LÎ³2C1 + 16LÎ³2
Ï„C2 âˆ’ 4Î³)
X
t
u=0
(1 âˆ’
Î³Âµ
2
)
tâˆ’u
eu . (50)
To get our final contraction inequality, we need to safely remove all the eu terms, so we
enforce 16LÎ³2C1 + 16LÎ³2
Ï„C2 âˆ’ 4Î³ â‰¤ 0. This leads directly to Theorem 22.
Convergence rate and ball-size comparison. To prove Corollary 23, we simply show
that under the condition Ï„ = O(min{ âˆš
1
âˆ†
, Îº}), the biggest allowable step size for Hogwild
to converge linearly is O(1/L), as is also the case for Sgd; and that the size of the ball to
which both algorithms converge is of the same order. The proof is finished by remarking
that for both algorithms, the rates of convergence are directly proportional to the step size.
6. Empirical Results
We now present the results of our experiments. We first compare our new sequential algorithm,
Sparse Saga, to its existing alternative, Saga with lagged updates and to the original Saga
algorithm as a baseline. We then move on to our main results, the empirical comparison
of Asaga, Kromagnon and Hogwild. Finally, we present additional results, including
convergence and speedup figures with respect to the number of iteration (i.e. â€œtheoretical
speedupsâ€) and measures on the Ï„ constant.
6.1. Experimental Setup
Models. Although Asaga can be applied more broadly, we focus on logistic regression,
a model of particular practical importance. The associated objective function takes the
following form:
1
n
Xn
i=1
log
1 + exp(âˆ’bia
|
i
x)

+
Âµ
2
kxk
2
, (51)
where ai âˆˆ R
d and bi âˆˆ {âˆ’1, +1} are the data samples.
Data sets. We consider two sparse data sets: RCV1 (Lewis et al., 2004) and URL (Ma
et al., 2009); and a dense one, Covtype (Collobert et al., 2002), with statistics listed in the
table below. As in Le Roux et al. (2012), Covtype is standardized, thus 100% dense. âˆ† is
O(1) in all data sets, hence not very insightful when relating it to our theoretical results.
Deriving a less coarse sparsity bound remains an open problem.
Hardware and software. Experiments were run on a 40-core machine with 384GB of
memory. All algorithms were implemented in Scala. We chose this high-level language despite
its typical 20x slowdown compared to C (when using standard libraries, see Appendix F.2)
because our primary concern was that the code may easily be reused and extended for
research purposes (to this end, we have made all our code available at http://www.di.ens.
fr/sierra/research/asaga/).
3 
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Table 1: Basic data set statistics.
n d density L
RCV1 697,641 47,236 0.15% 0.25
URL 2,396,130 3,231,961 0.004% 128.4
Covtype 581,012 54 100% 48428
6.2. Implementation Details
Regularization. Following Schmidt et al. (2016), the amount of regularization used was set
to Âµ = 1/n. In each update, we project the gradient of the regularization term (we multiply
it by Di as we also do with the vector Î±Â¯) to preserve the sparsity pattern while maintaining
an unbiased estimate of the gradient. For squared `2, the Sparse Saga updates becomes:
x
+ = x âˆ’ Î³(f
0
i
(x) âˆ’ Î±i + DiÎ±Â¯ + ÂµDix). (52)
Comparison with the theoretical algorithm. The algorithm we used in the experiments
is fully detailed in Algorithm 2. There are two differences with Algorithm 1. First, in the
implementation we choose it at random before we read the feature vector ait
. This enables
us to only read the necessary data for a given iteration (i.e. [xË†t
]Si
, [Î±Ë†
t
i
], [Î±Â¯
t
]Si
). Although this
violates Property 3, it still performs well in practice.
Second, we maintain Î±Â¯
t
in memory. This saves the cost of recomputing it at every
iteration (which we can no longer do since we only read a subset data). Again, in practice
the implemented algorithm enjoys good performance. But this design choice raises a subtle
point: the update is not guaranteed to be unbiased in this setup (see Appendix F.3 for more
details).
Step sizes. For each algorithm, we picked the best step size among 10 equally spaced
values in a grid, and made sure that the best step size was never at the boundary of this
interval. For Covtype and RCV1, we used the interval [
1
10L
,
10
L
], whereas for URL we used
the interval [
1
L
,
100
L
] as it admitted larger step sizes. It turns out that the best step size
was fairly constant for different number of cores for both Asaga and Kromagnon, and
both algorithms had similar best step sizes (0.7 for RCV1, 0.05 for URL and 5 Ã— 10âˆ’5
for
Covtype).
6.3. Comparison of Sequential Algorithms: Sparse Saga vs Lagged updates
We compare the Sparse Saga variant proposed in Section 3.1 to two other approaches: the
naive (i.e., dense) update scheme and the lagged updates implementation described in Defazio
et al. (2014). Note that we use different datasets from the parallel experiments, including a
subset of the RCV1 data set and the Realsim data set (see description in Appendix F.1).
Figure 2 reveals that sparse and lagged updates have a lower cost per iteration than their
dense counterpart, resulting in faster convergence for sparse data sets. Furthermore, while
the two approaches had similar convergence in terms of number of iterations, the Sparse
Saga scheme is slightly faster in terms of runtime (and as previously pointed out, sparse
updates are better adapted for the asynchronous setting). For the dense data set (Covtype),
the three approaches exhibit similar performance.
31
Leblond, Pedregosa and Lacoste-Julien
Figure 2: Lagged vs Sparse Saga updates. Suboptimality with respect to time for
different Saga update schemes on various data sets. First row: suboptimality as a function
of time. Second row: suboptimality as a the number of passes over the data set. For sparse
data sets (RCV1 and Real-sim), lagged and sparse updates have a lower cost per iteration
which result in faster convergence.
32
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
(a) Suboptimality as a function of time. (b) Speedup as a function of the number of cores
Figure 3: Convergence and speedup for asynchronous stochastic gradient descent
methods. We display results for RCV1 and URL. Results for Covtype can be found in
Section 6.6.
6.4. Asaga vs. Kromagnon vs. Hogwild
We compare three different asynchronous variants of stochastic gradient methods on the
aforementioned data sets: Asaga, presented in this work, Kromagnon, the asynchronous
sparse Svrg method described in Mania et al. (2017) and Hogwild (Niu et al., 2011). Each
method had its step size chosen so as to give the fastest convergence (up to a suboptimality
of 10âˆ’3
in the special case of Hogwild). The results can be seen in Figure 3a: for each
method we consider its asynchronous version with both one (hence sequential) and ten
processors. This figure reveals that the asynchronous version offers a significant speedup over
its sequential counterpart.
We then examine the speedup relative to the increase in the number of cores. The
speedup is measured as time to achieve a suboptimality of 10âˆ’5
(10âˆ’3
for Hogwild) with
one core divided by time to achieve the same suboptimality with several cores, averaged over
3 runs. Again, we choose step size leading to fastest convergence24 (see Appendix F.2 for
information about the step sizes). Results are displayed in Figure 3b.
As predicted by our theory, we observe linear â€œtheoreticalâ€ speedups (i.e. in terms of
number of iterations, see Section 6.6). However, with respect to running time, the speedups
seem to taper off after 20 cores. This phenomenon can be explained by the fact that our
hardware model is by necessity a simplification of reality. As noted in Duchi et al. (2015), in
a modern machine there is no such thing as shared memory. Each core has its own levels of
cache (L1, L2, L3) in addition to RAM. These faster pools of memory are fully leveraged
when using a single core. Unfortunately, as soon as several cores start writing to common
locations, cache coherency protocols have to be deployed to ensure that the information
is consistent across cores. These protocols come with computational overheads. As more
and more cores are used, the shared information goes lower and lower in the memory stack,
and the overheads get more and more costly. It may be the case that on much bigger data
sets, where the cache memory is unlikely to provide benefits even for a single core (since
24. Although we performed grid search on a large interval, we observed that the best step size was fairly
constant for different number of cores, and similar for Asaga and Kromagnon.
33
Leblond, Pedregosa and Lacoste-Julien
Figure 4: Comparison on the Covtype data set. Left: suboptimality. Right: speedup. The
number of cores in the legend only refers to the left plot.
sampling items repeatedly becomes rare), the running time speedups actually improve. More
experimentation is needed to quantify these effects and potentially increase performance.
6.5. Effect of Sparsity
Sparsity plays an important role in our theoretical results, where we find that while it
is necessary in the â€œill-conditionedâ€ regime to get linear speedups, it is not in the â€œwellconditionedâ€ regime. We confront this to real-life experiments by comparing the convergence
and speedup performance of our three asynchronous algorithms on the Covtype data set,
which is fully dense after standardization. The results appear in Figure 4.
While we still see a significant improvement in speed when increasing the number of cores,
this improvement is smaller than the one we observe for sparser data sets. The speedups we
observe are consequently smaller, and taper off earlier than on our other data sets. However,
since the observed â€œtheoreticalâ€ speedup is linear (see Section 6.6), we can attribute this
worse performance to higher hardware overhead. This is expected because each update is
fully dense and thus the shared parameters are much more heavily contended for than in our
sparse datasets.
One thing we notice when computing the âˆ† constant for our data sets is that it often
fails to capture the full sparsity distribution, being essentially a maximum: for all three data
sets, we obtain âˆ† = O(1). This means that âˆ† can be quite big even for very sparse data
sets. Deriving a less coarse bound remains an open problem.
6.6. Theoretical Speedups
In the previous experimental sections, we have shown experimental speedup results where
suboptimality was a function of the running time. This measure encompasses both theoretical
algorithmic properties and hardware overheads (such as contention of shared memory) which
are not taken into account in our analysis.
34
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Figure 5: Theoretical speedups. Suboptimality with respect to number of iterations for
Asaga, Kromagnon and Hogwild with 1 and 10 cores. Curves almost coincide, which
means the theoretical speedup is almost the number of cores p, hence linear.
In order to isolate these two effects, we now plot our convergence experiments where
suboptimality is a function of the number of iterations; thus, we abstract away any potential
hardware overhead.25 The experimental results can be seen in Figure 5.
For all three algorithms and all three data sets, the curves for 1 and 10 cores almost
coincide, which means that we are indeed in the â€œtheoretical linear speedupâ€ regime. Indeed,
when we plotted the amount of iterations required to converge to a given accuracy as a
function of the number of cores, we obtained straight horizontal lines for our three algorithms.
The fact that the speedups we observe in running time are less than linear can thus
be attributed to various hardware overheads, including shared variable contention â€“ the
compare-and-swap operations are more and more expensive as the number of competing
requests increases â€“ and cache effects as mentioned in Section 6.4.
6.7. A Closer Look at the Ï„ Constant
6.7.1. Theory
In the parallel optimization literature, Ï„ is often referred to as a proxy for the number of
cores. However, intuitively as well as in practice, it appears that there are a number of
other factors that can influence this quantity. We will now attempt to give a few qualitative
arguments as to what these other factors might be and how they relate to Ï„ .
Number of cores. The first of these factors is indeed the number of cores. If we have p
cores, Ï„ â‰¥ p âˆ’ 1. Indeed, in the best-case scenario where all cores have exactly the same
execution speed for a single iteration, Ï„ = p âˆ’ 1.
Length of an iteration. To get more insight into what Ï„ really encompasses, let us now
try to define the worst-case scenario in the preceding example. Consider 2 cores. In the worst
25. To do so, we implement a global counter which is sparsely updated (every 100 iterations for example) in
order not to modify the asynchrony of the system. This counter is used only for plotting purposes and is
not needed otherwise.
35
Leblond, Pedregosa and Lacoste-Julien
case, one core runs while the other is stuck. Then the overlap is t for all t and eventually
grows to +âˆ. If we assume that one core runs twice as fast as the other, then Ï„ = 2. If both
run at the same speed, Ï„ = 1.
It appears then that a relevant quantity is R, the ratio between the fastest execution
time and the slowest execution time for a single iteration. We have Ï„ â‰¤ (p âˆ’ 1)R, which can
be arbitrarily bigger than p.
There are several factors at play in R itself. These include:
â€¢ the speed of execution of the cores themselves (i.e. clock time).
â€¢ the data matrix itself. Different support sizes for fi means different gradient computation times. If one fi has support of size n while all the others have support of size 1
for example, R may eventually become very big.
â€¢ the length of the computation itself. The longer our algorithm runs, the more likely it
is to explore the potential corner cases of the data matrix.
The overlap is then upper bounded by the number of cores multiplied by the ratio of the
maximum iteration time over the minimum iteration time (which is linked to the sparsity
distribution of the data matrix). This is an upper bound, which means that in some cases
it will not really be useful. For example, if one factor has support size 1 and all others
have support size d, the probability of the event which corresponds to the upper bound is
exponentially small in d. We conjecture that a more useful indicator could be ratio of the
maximum iteration time over the expected iteration time.
To sum up this preliminary theoretical exploration, the Ï„ term encompasses much more
complexity than is usually implied in the literature. This is reflected in the experiments we
ran, where the constant was orders of magnitude bigger than the number of cores.
6.7.2. Experimental Results
In order to verify our intuition about the Ï„ variable, we ran several experiments on all three
data sets, whose characteristics are reminded in Table 2. Î´
i
l
is the support size of fi
.
Table 2: Density measures including minimum, average and maximum support size Î´
i
l
of the
factors.
n d density max(Î´
i
l
) min(Î´
i
l
)
Â¯Î´l max(Î´
i
l
)/
Â¯Î´l
RCV1 697,641 47,236 0.15% 1,224 4 73.2 16.7
URL 2,396,130 3,231,961 0.003% 414 16 115.6 3.58
Covtype 581,012 54 100% 12 8 11.88 1.01
To estimate Ï„ , we compute the average overlap over 100 iterations, i.e. the difference in
labeling between the end of the hundredth iteration and the start of the first iteration on,
divided by 100. This quantity is a lower bound on the actual overlap (which is a maximum,
not an average). We then take its maximum observed value. The reason why we use an
average is that computing the overlap requires using a global counter, which we do not want
36
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Figure 6: Overlap. Overlap as a function of the number of cores for both Asaga and
Hogwild on all three data sets.
to update every iteration since it would make it a heavily contentious quantity susceptible of
artificially changing the asynchrony pattern of our algorithm.
The results we observe are order of magnitude bigger than p, indicating that Ï„ can indeed
not be dismissed as a mere proxy for the number of cores, but has to be more carefully
analyzed.
First, we plot the maximum observed Ï„ as a function of the number of cores (see Figure 6).
We observe that the relationship does indeed seem to be roughly linear with respect to the
number of cores until 30 cores. After 30 cores, we observe what may be a phase transition
where the slope increases significantly.
Second, we measured the maximum observed Ï„ as a function of the number of epochs.
We omit the figure since we did not observe any dependency; that is, Ï„ does not seem to
depend on the number of epochs. We know that it must depend on the number of iterations
(since it cannot be bigger, and is an increasing function with respect to that number for
example), but it appears that a stable value is reached quite quickly (before one full epoch is
done).
If we allowed the computations to run forever, we would eventually observe an event
such that Ï„ would reach the upper bound mentioned in Section 6.7.1, so it may be that Ï„ is
actually a very slowly increasing function of the number of iterations.
7. Conclusions and Future Work
Building on the recently proposed â€œperturbed iterateâ€ framework, we have proposed a novel
perspective to clarify an important technical issue present in a large fraction of the recent
convergence rate proofs for asynchronous parallel optimization algorithms. To resolve it, we
have introduced a novel â€œafter readâ€ framework and demonstrated its usefulness by analyzing
three asynchronous parallel incremental optimization algorithms, including Asaga, a novel
sparse and fully asynchronous variant of the incremental gradient algorithm Saga. Our proof
technique accommodates more realistic settings than is usually the case in the literature (such
as inconsistent reads and writes and an unbounded gradient); we obtain tighter conditions
37
Leblond, Pedregosa and Lacoste-Julien
than in previous work. In particular, we show that Asaga is linearly faster than Saga
under mild conditions, and that sparsity is not always necessary to get linear speedups. Our
empirical benchmarks confirm speedups up to 10x.
Schmidt et al. (2016) have shown that Sag enjoys much improved performance when
combined with non-uniform sampling and line-search. We have also noticed that our âˆ†r
constant (being essentially a maximum) sometimes fails to accurately represent the full
sparsity distribution of our data sets. Finally, while our algorithm can be directly ported
to a distributed master-worker architecture, its communication pattern would have to
be optimized to avoid prohibitive costs. Limiting communications can be interpreted as
artificially increasing the delay, yielding an interesting trade-off between delay influence and
communication costs.
These constitute interesting directions for future analysis, as well as a further exploration
of the Ï„ term, which we have shown encompasses more complexity than previously thought.
Acknowledgments
We would like to thank Xinghao Pan for sharing with us their implementation of Kromagnon,
as well as Alberto Chiappa for spotting a typo in the proof. This work was partially supported
by a Google Research Award and the MSR-Inria Joint Center. FP acknowledges financial
support from the chaire Ã‰conomie des nouvelles donnÃ©es with the data science joint research
initiative with the fonds AXA pour la recherche.
38
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Appendix Outline:
â€¢ In Appendix A, we adapt the proof from Hofmann et al. (2015) to prove Theorem 2,
our convergence result for serial Sparse Saga.
â€¢ In Appendix B, we give the complete details for the proof of convergence for Asaga
(Theorem 8) as well as its linear speedup regimes (Corollary 9).
â€¢ In Appendix C, we give the full details for the proof of convergence for Kromagnon
(Theorem 15) as well as a simpler convergence result for both Svrg (Corollary 16)
and Kromagnon (Corollary 17) and finally the latterâ€™s linear speedup regimes (Corollary 18)
â€¢ In Appendix D, we give the full details for the proof of convergence for Hogwild
(Theorem 22) as well as its linear speedup regimes (Corollary 23).
â€¢ In Appendix E, we explain why adapting the lagged updates implementation of Saga
to the asynchronous setting is difficult.
â€¢ In Appendix F, we give additional details about the data sets and our implementation.
Appendix A. Sparse Saga â€“ Proof of Theorem 2
Proof sketch for Hofmann et al. (2015). As we will heavily reuse the proof technique
from Hofmann et al. (2015), we start by giving its sketch.
First, the authors combine classical strong convexity and Lipschitz inequalities to derive
the following inequality (Hofmann et al., 2015, Lemma 1):
Ekx
+ âˆ’x
âˆ—
k
2 â‰¤(1âˆ’Î³Âµ)kxâˆ’x
âˆ—
k
2 + 2Î³
2EkÎ±i âˆ’ f
0
i
(x
âˆ—
)k
2 + (4Î³
2L âˆ’ 2Î³)

f(x) âˆ’ f(x
âˆ—
)

. (53)
This gives a contraction term, as well as two additional terms; 2Î³
2EkÎ±i âˆ’ f
0
i
(x
âˆ—
)k
2
is a
positive variance term, but (4Î³
2L âˆ’ 2Î³)

f(x) âˆ’ f(x
âˆ—
)

is a negative suboptimality term
(provided Î³ is small enough). The suboptimality term can then be used to cancel the variance
one.
Second, the authors use a classical smoothness upper bound to control the variance term
and relate it to the suboptimality. However, since the Î±i are partial gradients computed at
previous time steps, the upper bounds of the variance involve suboptimality at previous time
steps, which are not directly relatable to the current suboptimality.
Third, to circumvent this issue, a Lyapunov function is defined to encompass both current
and past terms. To finish the proof, Hofmann et al. (2015) show that the Lyapunov function
is a contraction.
Proof outline. Fortunately, we can reuse most of the proof from Hofmann et al. (2015)
to show that Sparse Saga converges at the same rate as regular Saga. In fact, once we
establish that Hofmann et al. (2015, Lemma 1) is still verified we are done.
To prove this, we show that the gradient estimator is unbiased, and then derive close
variants of equations (6) and (9) in their paper, which we remind the reader of here:
Ekf
0
i
(x) âˆ’ Î±Â¯ik
2 â‰¤ 2Ekf
0
i
(x) âˆ’ f
0
i
(x
âˆ—
)k
2+2EkÎ±Â¯i âˆ’ f
0
i
(x
âˆ—
)k
2 Hofmann et al. (2015, Eq. 6)
EkÎ±Â¯i âˆ’ f
0
i
(x
âˆ—
)k
2 â‰¤ EkÎ±i âˆ’ f
0
i
(x
âˆ—
)k
2
. Hofmann et al. (2015, Eq. 9)
  
Leblond, Pedregosa and Lacoste-Julien
Unbiased gradient estimator. We first show that the update estimator is unbiased. The
estimator is unbiased if:
EDiÎ±Â¯ = EÎ±i =
1
n
Xn
i=1
Î±i
. (54)
We have:
EDiÎ±Â¯ =
1
n
Xn
i=1
DiÎ±Â¯ =
1
n
Xn
i=1
PSiDÎ±Â¯ =
1
n
Xn
i=1
X
vâˆˆSi
[Â¯Î±]vev
pv
=
X
d
v=1
ï£«
ï£­
X
i| vâˆˆSi
1
ï£¶
ï£¸
[Â¯Î±]vev
npv
,
where ev is the vector whose only nonzero component is the v component which is equal to 1.
By definition, P
i|vâˆˆSi
1 = npv, which gives us Equation (54).
Deriving Hofmann et al. (2015, Equation 6). We define Î±Â¯i
:= Î±i âˆ’ DiÎ±Â¯ (contrary
to Hofmann et al. (2015) where the authors define Î±Â¯i
:= Î±i âˆ’ Î±Â¯ since they do not concern
themselves with sparsity). Using the inequality ka + bk
2 â‰¤ 2kak
2 + 2kbk
2
, we get:
Ekf
0
i
(x) âˆ’ Î±Â¯ik
2 â‰¤ 2Ekf
0
i
(x) âˆ’ f
0
i
(x
âˆ—
)k
2 + 2EkÎ±Â¯i âˆ’ f
0
i
(x
âˆ—
)k
2
, (55)
which is our equivalent to Hofmann et al. (2015, Eq. 6), where only our definition of Î±Â¯i
differs.
Deriving Hofmann et al. (2015, Equation 9). We want to prove Hofmann et al. (2015,
Eq. 9):
EkÎ±Â¯i âˆ’ f
0
i
(x
âˆ—
)k
2 â‰¤ EkÎ±i âˆ’ f
0
i
(x
âˆ—
)k
2
. (56)
We have:
EkÎ±Â¯i âˆ’ f
0
i
(x
âˆ—
)k
2 = EkÎ±i âˆ’ f
0
i
(x
âˆ—
)k
2 âˆ’ 2EhÎ±i âˆ’ f
0
i
(x
âˆ—
), DiÎ±Â¯i + EkDiÎ±Â¯k
2
. (57)
Let DÂ¬i
:= PS
c
i D; we then have the orthogonal decomposition DÎ± = DiÎ± + DÂ¬iÎ± with
DiÎ± âŠ¥ DÂ¬iÎ±, as they have disjoint support. We now use the orthogonality of DÂ¬iÎ± with any
vector with support in Si to simplify the expression (57) as follows:
EhÎ±i âˆ’ f
0
i
(x
âˆ—
), DiÎ±Â¯i = EhÎ±i âˆ’ f
0
i
(x
âˆ—
), DiÎ±Â¯ + DÂ¬iÎ±Â¯i (Î±i âˆ’ f
0
i
(x
âˆ—
) âŠ¥ DÂ¬iÎ±Â¯)
= EhÎ±i âˆ’ f
0
i
(x
âˆ—
), DÎ±Â¯i
= hE

Î±i âˆ’ f
0
i
(x
âˆ—
)

, DÎ±Â¯i
= hEÎ±i
, DÎ±Â¯i (f
0
(x
âˆ—
) = 0)
= Â¯Î±
|DÎ± . Â¯ (58)
Similarly,
EkDiÎ±Â¯k
2 = EhDiÎ±, D Â¯ iÎ±Â¯i
= EhDiÎ±, D Â¯ Î±Â¯i (DiÎ±Â¯ âŠ¥ DÂ¬iÎ±Â¯)
= hEDiÎ±, D Â¯ Î±Â¯i
= Â¯Î±
|DÎ± . Â¯ (59)
4 
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Putting it all together,
EkÎ±Â¯i âˆ’ f
0
i
(x
âˆ—
)k
2 = EkÎ±i âˆ’ f
0
i
(x
âˆ—
)k
2 âˆ’ Î±Â¯
|DÎ±Â¯ â‰¤ EkÎ±i âˆ’ f
0
i
(x
âˆ—
)k
2
. (60)
This is our version of Hofmann et al. (2015, Equation 9), which finishes the proof
of Hofmann et al. (2015, Lemma 1). The rest of the proof from Hofmann et al. (2015) can
then be reused without modification to obtain Theorem 2.
Appendix B. Asaga â€“ Proof of Theorem 8 and Corollary 9
B.1. Initial Recursive Inequality Derivation
We start by proving Equation (15). Let gt
:= g(Ë†xt
, Î±Ë†
t
, it). From (10), we get:
kxt+1 âˆ’ x
âˆ—
k
2 = kxt âˆ’ Î³gt âˆ’ x
âˆ—
k
2 = kxt âˆ’ x
âˆ—
k
2 + Î³
2
kgtk
2 âˆ’ 2Î³hxt âˆ’ x
âˆ—
, gti
= kxt âˆ’ x
âˆ—
k
2 + Î³
2
kgtk
2 âˆ’ 2Î³hxË†t âˆ’ x
âˆ—
, gti + 2Î³hxË†t âˆ’ xt
, gti.
In order to prove Equation (15), we need to bound the âˆ’2Î³hxË†t âˆ’ x
âˆ—
, gti term. Thanks to
Property 3, we can write:
EhxË†t âˆ’ x
âˆ—
, gti = EhxË†t âˆ’ x
âˆ—
, Egti = EhxË†t âˆ’ x
âˆ—
, f0
(Ë†xt)i.
We can now use a classical strong convexity bound as well as a squared triangle inequality
to get:
âˆ’hxË†t âˆ’ x
âˆ—
, f0
(Ë†xt)i â‰¤ âˆ’
f(Ë†xt) âˆ’ f(x
âˆ—
)

âˆ’
Âµ
2
kxË†t âˆ’ x
âˆ—
k
2
(Strong convexity bound)
âˆ’kxË†t âˆ’ x
âˆ—
k
2 â‰¤ kxË†t âˆ’ xtk
2 âˆ’
1
2
kxt âˆ’ x
âˆ—
k
2
(ka + bk
2 â‰¤ 2kak
2 + 2kbk
2
)
âˆ’2Î³EhxË†t âˆ’ x
âˆ—
, gti â‰¤ âˆ’Î³Âµ
2
Ekxt âˆ’ x
âˆ—
k
2 + Î³ÂµEkxË†t âˆ’ xtk
2 âˆ’ 2Î³

Ef(Ë†xt) âˆ’ f(x
âˆ—
)

. (61)
Putting it all together, we get the initial recursive inequality (15), rewritten here explicitly:
at+1 â‰¤ (1 âˆ’
Î³Âµ
2
)at + Î³
2Ekgtk
2 + Î³ÂµEkxË†t âˆ’ xtk
2 + 2Î³EhxË†t âˆ’ xt
, gti âˆ’ 2Î³et
, (62)
where at
:= Ekxt âˆ’ x
âˆ—k
2 and et
:= Ef(Ë†xt) âˆ’ f(x
âˆ—
).
B.2. Proof of Lemma 10 (inequality in terms of gt
:= g(Ë†xt
, Î±Ë†
t
, it))
To prove Lemma 10, we now bound both EkxË†t âˆ’ xtk
2 and EhxË†t âˆ’ xt
, gti with respect to
(Ekguk
2
)uâ‰¤t
.
  
Leblond, Pedregosa and Lacoste-Julien
Bounding EhxË†t âˆ’ xt
, gti in terms of gu.
1
Î³
EhxË†t âˆ’ xt
, gti =
X
tâˆ’1
u=(tâˆ’Ï„)+
EhG
t
u
gu, gti (by Equation (11))
â‰¤
X
tâˆ’1
u=(tâˆ’Ï„)+
E|hgu, gti| (Gt
u diagonal matrices with terms in {0, 1})
â‰¤
X
tâˆ’1
u=(tâˆ’Ï„)+
âˆš
âˆ†
2
(Ekguk
2 + Ekgtk
2
) (by Proposition 11)
â‰¤
âˆš
âˆ†
2
X
tâˆ’1
u=(tâˆ’Ï„)+
Ekguk
2 +
âˆš
âˆ†Ï„
2
Ekgtk
2
. (63)
Bounding EkxË†t âˆ’ xtk
2 with respect to gu Thanks to the expansion for xË†t âˆ’ xt (11), we
get:
kxË†t âˆ’ xtk
2 â‰¤ Î³
2 X
tâˆ’1
u,v=(tâˆ’Ï„)+
|hG
t
u
gu, Gt
v
gvi| â‰¤ Î³
2 X
tâˆ’1
u=(tâˆ’Ï„)+
kguk
2 + Î³
2 X
tâˆ’1
u,v=(tâˆ’Ï„)+
u6=v
|hG
t
u
gu, Gt
v
gvi| .
Using (18) from Proposition 11, we have that for u 6= v:
E|hG
t
u
gu, Gt
v
gvi| â‰¤ E|hgu, gvi| â‰¤
âˆš
âˆ†
2
(Ekguk
2 + Ekgvk
2
). (64)
By taking the expectation and using (64), we get:
EkxË†t âˆ’ xtk
2 â‰¤ Î³
2 X
tâˆ’1
u=(tâˆ’Ï„)+
Ekguk
2 + Î³
2
âˆš
âˆ†(Ï„ âˆ’ 1)+
X
tâˆ’1
u=(tâˆ’Ï„)+
Ekguk
2
= Î³
2

1 + âˆš
âˆ†(Ï„ âˆ’ 1)+
 X
tâˆ’1
u=(tâˆ’Ï„)+
Ekguk
2
â‰¤ Î³
2

1 + âˆš
âˆ†Ï„
 X
tâˆ’1
u=(tâˆ’Ï„)+
Ekguk
2
. (65)
We can now rewrite (15) in terms of Ekgtk
2
, which finishes the proof for Lemma 10 (by
introducing C1 and C2 as specified by 17 in Lemma 10):
at+1 â‰¤ (1 âˆ’
Î³Âµ
2
)at âˆ’ 2Î³et + Î³
2Ekgtk
2 + Î³
3Âµ(1 + âˆš
âˆ†Ï„ )
X
tâˆ’1
u=(tâˆ’Ï„)+
Ekguk
2
+ Î³
2
âˆš
âˆ†
X
tâˆ’1
u=(tâˆ’Ï„)+
Ekguk
2 + Î³
2
âˆš
âˆ†Ï„Ekgtk
2
â‰¤ (1 âˆ’
Î³Âµ
2
)at âˆ’ 2Î³et + Î³
2C1Ekgtk
2 + Î³
2C2
X
tâˆ’1
u=(tâˆ’Ï„)+
Ekguk
2
. (66)
  
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
B.3. Proof of Lemma 13 (suboptimality bound on Ekgtk
2
)
We now derive our bound on gt with respect to suboptimality. From Appendix A, we know
that:
Ekgtk
2 â‰¤ 2Ekf
0
it
(Ë†xt) âˆ’ f
0
it
(x
âˆ—
)k
2 + 2EkÎ±Ë†
t
it âˆ’ f
0
it
(x
âˆ—
)k
2
(67)
Ekf
0
it
(Ë†xt) âˆ’ f
0
it
(x
âˆ—
)k
2 â‰¤ 2L

Ef(Ë†xt) âˆ’ f(x
âˆ—
)

= 2Let
. (68)
N. B.: In the following, it is a random variable picked uniformly at random in
{1, ..., n}, whereas i is a fixed constant.
We still have to handle the EkÎ±Ë†
t
it âˆ’ f
0
it
(x
âˆ—
)k
2
term and express it in terms of past
suboptimalities. We know from our definition of t that it and xË†u are independent âˆ€u < t.
Given the â€œafter readâ€ global ordering, E â€“ the expectation on it conditioned on xË†t and all
â€œpast" xË†u and iu â€“ is well defined, and we can rewrite our quantity as:
EkÎ±Ë†
t
it âˆ’ f
0
it
(x
âˆ—
)k
2 = E

EkÎ±Ë†
t
it âˆ’ f
0
it
(x
âˆ—
)k
2

= E
1
n
Xn
i=1
kÎ±Ë†
t
i âˆ’ f
0
i
(x
âˆ—
)k
2
=
1
n
Xn
i=1
EkÎ±Ë†
t
i âˆ’ f
0
i
(x
âˆ—
)k
2
.
Now, with i fixed, let u
t
i,l be the time of the iterate last used to write the [Î±Ë†
t
i
]l quantity,
i.e. [Î±Ë†
t
i
]l = [f
0
i
(xË†u
t
i,l
)]l
. We know26 that 0 â‰¤ u
t
i,l â‰¤ t âˆ’ 1. To use this information, we first
need to split Î±Ë†i along its dimensions to handle the possible inconsistencies among them:
EkÎ±Ë†
t
i âˆ’ f
0
i
(x
âˆ—
)k
2 = E
X
d
l=1

[Ë†Î±
t
i
]l âˆ’ [f
0
i
(x
âˆ—
)]l
2 =
X
d
l=1
E
h
[Ë†Î±
t
i
]l âˆ’ [f
0
i
(x
âˆ—
)]l
2
i
.
This gives us:
EkÎ±Ë†
t
i âˆ’ f
0
i
(x
âˆ—
)k
2 =
X
d
l=1
E
h
f
0
i
(Ë†xu
t
i,l
)l âˆ’ f
0
i
(x
âˆ—
)l
2
i
=
X
d
l=1
E
hX
tâˆ’1
u=0
1{u
t
i,l=u}

f
0
i
(Ë†xu)l âˆ’ f
0
i
(x
âˆ—
)l
2
i
=
X
tâˆ’1
u=0
X
d
l=1
E
h
1{u
t
i,l=u}

f
0
i
(Ë†xu)l âˆ’ f
0
i
(x
âˆ—
)l
2
i
. (69)
We will now rewrite the indicator so as to obtain independent events from the rest of the
equality. This will enable us to distribute the expectation. Suppose u > 0 (u = 0 is a special
case which we will handle afterwards). {u
t
i,l = u} requires two things:
26. In the case where u = 0, one would have to replace the partial gradient with Î±
0
i
. We omit this special
case here for clarity of expositi       
Leblond, Pedregosa and Lacoste-Julien
1. at time u, i was picked uniformly at random,
2. (roughly) i was not picked again between u and t.
We need to refine both conditions because we have to account for possible collisions due to
asynchrony. We know from our definition of Ï„ that the t
th iteration finishes before at t+Ï„ + 1,
but it may still be unfinished by time t + Ï„ . This means that we can only be sure that an
update selecting i at time v has been written to memory at time t if v â‰¤ t âˆ’ Ï„ âˆ’ 1. Later
updates may not have been written yet at time t. Similarly, updates before v = u + Ï„ + 1
may be overwritten by the u
th update so we cannot infer that they did not select i. From
this discussion, we conclude that u
t
i,l = u implies that iv 6= i for all v between u + Ï„ + 1 and
t âˆ’ Ï„ âˆ’ 1, though it can still happen that iv = i for v outside this range.
Using the fact that iu and iv are independent for v 6= u, we can thus upper bound the
indicator function appearing in (69) as follows:
1{u
t
i,l=u} â‰¤ 1{iu=i}1{iv6=i âˆ€v s.t. u+Ï„+1â‰¤vâ‰¤tâˆ’Ï„âˆ’1}
. (70)
This gives us:
E
h
1{u
t
i,l=u}

f
0
i
(Ë†xu)l âˆ’ f
0
i
(x
âˆ—
)l
2
i
â‰¤ E
h
1{iu=i}1{iv6=i âˆ€v s.t. u+Ï„+1â‰¤vâ‰¤tâˆ’Ï„âˆ’1}

f
0
i
(Ë†xu)l âˆ’ f
0
i
(x
âˆ—
)l
2
i
â‰¤ P{iu = i}P{iv 6= i âˆ€v s.t. u + Ï„ + 1 â‰¤ v â‰¤ t âˆ’ Ï„ âˆ’ 1}E

f
0
i
(Ë†xu)l âˆ’ f
0
i
(x
âˆ—
)l
2
(iv âŠ¥âŠ¥ xË†u, âˆ€v â‰¥ u)
â‰¤
1
n
(1 âˆ’
1
n
)
(tâˆ’2Ï„âˆ’uâˆ’1)+ E

f
0
i
(Ë†xu)l âˆ’ f
0
i
(x
âˆ—
)l
2
. (71)
Note that the third line used the crucial independence assumption iv âŠ¥âŠ¥ xË†u, âˆ€v â‰¥ u arising
from our â€œAfter Readâ€ ordering. Summing over all dimensions l, we then get:
E
h
1{u
t
i,l=u}kf
0
i
(Ë†xu) âˆ’ f
0
i
(x
âˆ—
)k
2
i
â‰¤
1
n
(1 âˆ’
1
n
)
(tâˆ’2Ï„âˆ’uâˆ’1)+ Ekf
0
i
(Ë†xu) âˆ’ f
0
i
(x
âˆ—
)k
2
. (72)
So now:
EkÎ±Ë†
t
it âˆ’ f
0
it
(x
âˆ—
)k
2 âˆ’ Î»eËœ0 â‰¤
1
n
Xn
i=1
X
tâˆ’1
u=1
1
n
(1 âˆ’
1
n
)
(tâˆ’2Ï„âˆ’uâˆ’1)+ Ekf
0
i
(Ë†xu) âˆ’ f
0
i
(x
âˆ—
)k
2
=
X
tâˆ’1
u=1
1
n
(1 âˆ’
1
n
)
(tâˆ’2Ï„âˆ’uâˆ’1)+
1
n
Xn
i=1
Ekf
0
i
(Ë†xu) âˆ’ f
0
i
(x
âˆ—
)k
2
=
X
tâˆ’1
u=1
1
n
(1 âˆ’
1
n
)
(tâˆ’2Ï„âˆ’uâˆ’1)+ E

Ekf
0
iu
(Ë†xu) âˆ’ f
0
iu
(x
âˆ—
)k
2

(iu âŠ¥âŠ¥ xË†u)
â‰¤
2L
n
X
tâˆ’1
u=1
(1 âˆ’
1
n
)
(tâˆ’2Ï„âˆ’uâˆ’1)+ eu (by Equation 68)
=
2L
n
(tâˆ’2
XÏ„âˆ’1)+
u=1
(1 âˆ’
1
n
)
tâˆ’2Ï„âˆ’uâˆ’1
eu +
2L
n
X
tâˆ’1
u=max(1,tâˆ’2Ï„)
eu . (73)    
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Note that we have excluded eËœ0 from our formula, using a generic Î» multiplier. We need
to treat the case u = 0 differently to bound 1{u
t
i,l=u}
. Because all our initial Î±i are initialized
to a fixed Î±
0
i
, {u
t
i = 0} just means that i has not been picked between 0 and t âˆ’ Ï„ âˆ’ 1, i.e.
{iv 6= i âˆ€ v s.t. 0 â‰¤ v â‰¤ t âˆ’ Ï„ âˆ’ 1}. This means that the 1{iu=i}
term in (70) disappears and
thus we lose a 1
n
factor compared to the case where u > 1.
Let us now evaluate Î». We have:
E
h
1{u
t
i=0}kÎ±
0
i âˆ’ f
0
i
(x
âˆ—
)k
2
i
â‰¤ E
h
1{iv6=i âˆ€ v s.t. 0â‰¤vâ‰¤tâˆ’Ï„âˆ’1}kÎ±
0
i âˆ’ f
0
i
(x
âˆ—
)k
2
i
â‰¤ P{iv 6= i âˆ€ v s.t. 0 â‰¤ v â‰¤ t âˆ’ Ï„ âˆ’ 1}EkÎ±
0
i âˆ’ f
0
i
(x
âˆ—
)k
2
â‰¤ (1 âˆ’
1
n
)
(tâˆ’Ï„)+ EkÎ±
0
i âˆ’ f
0
i
(x
âˆ—
)k
2
. (74)
Plugging (73) and (74) into (67), we get Lemma 13:
Ekgtk
2 â‰¤ 4Let +
4L
n
X
tâˆ’1
u=1
(1 âˆ’
1
n
)
(tâˆ’2Ï„âˆ’uâˆ’1)+ eu + 4L(1 âˆ’
1
n
)
(tâˆ’Ï„)+ eËœ0 , (75)
where we have introduced eËœ0 =
1
2L
EkÎ±
0
i âˆ’f
0
i
(x
âˆ—
)k
2
. Note that in the original Saga algorithm,
a batch gradient is computed to set the Î±
0
i = f
0
i
(x0). In this setting, we can write Lemma 13
using only eËœ0 â‰¤ e0 thanks to (68). In the more general setting where we initialize all Î±
0
i
to a
fixed quantity, we cannot use (68) to bound EkÎ±
0
i âˆ’ f
0
i
(x
âˆ—
)k
2 which means that we have to
introduce eËœ0.
B.4. Lemma 13 for Ahsvrg
In the simpler case of Ahsvrg as described in 4.2, we have a slight variation of (69):
Ekf
0
i
(x
t
0
) âˆ’ f
0
i
(x
âˆ—
)k
2 =
X
tâˆ’1
u=0
Ek1{u
t
i=u}

f
0
i
(Ë†xu) âˆ’ f
0
i
(x
âˆ—
)

k
2
. (76)
Note that there is no sum over dimensions in this case because the full gradient computations
and writes are synchronized (so the reference gradient is consistent).
As in Section B.3, we can upper bound the indicator 1{u
t
i=u}
. Now, {u
t
i,l = u} requires
two things: first, the next B variable sampled after the u
th update, BËœ
u
27, was 1; second, B
was 0 for every update between u and t (roughly). Since the batch step is fully synchronized,
we do not have to worry about updates from the past overwriting the reference gradient (and
the iterates xu where we compute the gradient contains all past updates because we have
waited for every core to finish its current update).
However, updating the state variable s to 1 once a B = 1 variable is sampled is not
atomic. So it is possible to have iterations with time label bigger than u and that still use an
older reference gradient for their update28. Fortunately, we can consider the state update as
27. We introduce this quantity because the iterations where full gradients are computed do not receive a
time label since they do not correspond to updates to the iterates.
28. Conceivably, another core could start a new iteration, draw B = 1 and try to update s to 1 themselves.
This is not an issue since the operation of updating s to 1 is idempotent. Only one reference gradient
would be computed in this case.
4 
Leblond, Pedregosa and Lacoste-Julien
any regular update to shared parameters. As such, Assumption 6 applies to it. This means
that we can be certain that the reference gradient has been updated for iterations with time
label v â‰¥ u + Ï„ + 1.
This gives us:
Ek1{u
t
i=u}

f
0
i
(Ë†xu) âˆ’ f
0
i
(x
âˆ—
)

k
2 â‰¤ E
h
1{BËœu=1}
1{Bv=0 âˆ€v s.t. u+1â‰¤vâ‰¤tâˆ’Ï„âˆ’1}kf
0
i
(Ë†xu) âˆ’ f
0
i
(x
âˆ—
)k
2
i
â‰¤
1
n

1 âˆ’
1
n
(tâˆ’Ï„âˆ’uâˆ’1)+ Ekf
0
i
(Ë†xu) âˆ’ f
0
i
(x
âˆ—
)k
2
. (77)
This proves Lemma 13 for Ahsvrg (while we actually have a slightly better exponent,
(tâˆ’Ï„ âˆ’uâˆ’1)+, we can upperbound it by the term in Lemma 13). Armed with this result, we
can finish the proof of Theorem 8 for Ahsvrg in exactly the same manner as for Asaga. By
remarking that the cost to get to iteration t (including computing reference batch gradients)
is the same in the sequential and parallel version, we see that our analysis for Corollary 9 for
Asaga also applies for Ahsvrg, so both algorithms obey the same convergence and speedup
results.
B.5. Master Inequality Derivation
Now, if we combine the bound on Ekgtk
2 which we just derived (i.e. Lemma 13) with
Lemma 10, we get:
at+1 â‰¤(1 âˆ’
Î³Âµ
2
)at âˆ’ 2Î³et
+ 4LÎ³2C1et +
4LÎ³2C1
n
X
tâˆ’1
u=1
(1 âˆ’
1
n
)
(tâˆ’2Ï„âˆ’uâˆ’1)+ eu + 4LÎ³2C1(1 âˆ’
1
n
)
(tâˆ’Ï„)+ eËœ0
+ 4LÎ³2C2
X
tâˆ’1
u=(tâˆ’Ï„)+
eu + 4LÎ³2C2
X
tâˆ’1
u=(tâˆ’Ï„)+
(1 âˆ’
1
n
)
(uâˆ’Ï„)+ eËœ0
+
4LÎ³2C2
n
X
tâˆ’1
u=(tâˆ’Ï„)+
Xuâˆ’1
v=1
(1 âˆ’
1
n
)
(uâˆ’2Ï„âˆ’vâˆ’1)+ ev .
(78)
If we define Ht
:= Ptâˆ’1
u=1(1 âˆ’
1
n
)
(tâˆ’2Ï„âˆ’uâˆ’1)+ eu, then we get:
at+1 â‰¤(1 âˆ’
Î³Âµ
2
)at âˆ’ 2Î³et
+ 4LÎ³2C1

et + (1 âˆ’
1
n
)
(tâˆ’Ï„)+ eËœ0

+
4LÎ³2C1
n
Ht
+ 4LÎ³2C2
X
tâˆ’1
u=(tâˆ’Ï„)+
(eu + (1 âˆ’
1
n
)
(uâˆ’Ï„)+ eËœ0

+
4LÎ³2C2
n
X
tâˆ’1
u=(tâˆ’Ï„)+
Hu ,
(79)
which is the master inequality (27).   
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
B.6. Lyapunov Function and Associated Recursive Inequality
We define Lt
:= Pt
u=0(1 âˆ’ Ï)
tâˆ’uau for some target contraction rate Ï < 1 to be defined later.
We have:
Lt+1 = (1 âˆ’ Ï)
t+1a0 +
X
t+1
u=1
(1 âˆ’ Ï)
t+1âˆ’u
au = (1 âˆ’ Ï)
t+1a0 +
X
t
u=0
(1 âˆ’ Ï)
tâˆ’u
au+1 . (80)
We now use our new bound on at+1, (79):
Lt+1 â‰¤ (1 âˆ’ Ï)
t+1a0 +
X
t
u=0
(1 âˆ’ Ï)
tâˆ’u
h
(1 âˆ’
Î³Âµ
2
)au âˆ’ 2Î³eu + 4LÎ³2C1

eu + (1 âˆ’
1
n
)
(uâˆ’Ï„)+ eËœ0

+
4LÎ³2C1
n
Hu +
4LÎ³2C2
n
Xuâˆ’1
v=(uâˆ’Ï„)+
Hv
+ 4LÎ³2C2
Xuâˆ’1
v=(uâˆ’Ï„)+
(ev + (1 âˆ’
1
n
)
(vâˆ’Ï„)+ eËœ0

i
â‰¤ (1 âˆ’ Ï)
t+1a0 + (1 âˆ’
Î³Âµ
2
)Lt
+
X
t
u=0
(1 âˆ’ Ï)
tâˆ’u
h
âˆ’ 2Î³eu + 4LÎ³2C1

eu + (1 âˆ’
1
n
)
(uâˆ’Ï„)+ eËœ0

+
4LÎ³2C1
n
Hu +
4LÎ³2C2
n
Xuâˆ’1
v=(uâˆ’Ï„)+
Hv
+ 4LÎ³2C2
Xuâˆ’1
v=(uâˆ’Ï„)+
(ev + (1 âˆ’
1
n
)
(vâˆ’Ï„)+ eËœ0

i
. (81)
We can now rearrange the sums to expose a simple sum of eu multiplied by factors r
t
u
:
Lt+1 â‰¤ (1 âˆ’ Ï)
t+1a0 + (1 âˆ’
Î³Âµ
2
)Lt +
X
t
u=1
r
t
u
eu + r
t
0
eËœ0 . (82)
B.7. Proof of Lemma 14 (sufficient condition for convergence for Asaga)
We want to make explicit what conditions on Ï and Î³ are necessary to ensure that r
t
u
is
negative for all u â‰¥ 1. Since each eu is positive, we will then be able to safely drop the sum
term from the inequality. The r
t
0
term is a bit trickier and is handled separately. Indeed,
trying to enforce that r
t
0
is negative results in a significantly worse condition on Î³ and
eventually a convergence rate smaller by a factor of n than our final result. Instead, we
handle this term directly in the Lyapunov function.
Computation of r
t
u
. Letâ€™s now make the multiplying factor explicit. We assume u â‰¥ 1.
We split r
t
u
into five parts coming from (81):
â€¢ r1, the part coming from the âˆ’2Î³eu terms;
  
Leblond, Pedregosa and Lacoste-Julien
â€¢ r2, coming from 4LÎ³2C1eu;
â€¢ r3, coming from 4LÎ³2C1
n Hu;
â€¢ r4, coming from 4LÎ³2C2
Puâˆ’1
v=(uâˆ’Ï„)+
ev;
â€¢ r5, coming from 4LÎ³2C2
n
Puâˆ’1
v=(uâˆ’Ï„)+
Hv.
r1 is easy to derive. Each of these terms appears only in one inequality. So for u at time t,
the term is:
r1 = âˆ’2Î³(1 âˆ’ Ï)
tâˆ’u
. (83)
For much the same reasons, r2 is also easy to derive and is:
r2 = 4LÎ³2C1(1 âˆ’ Ï)
tâˆ’u
. (84)
r3 is a bit trickier, because for a given v > 0 there are several Hu which contain ev. The key
insight is that we can rewrite our double sum in the following manner:
X
t
u=0
(1 âˆ’ Ï)
tâˆ’uXuâˆ’1
v=1
(1 âˆ’
1
n
)
(uâˆ’2Ï„âˆ’vâˆ’1)+ ev
=
X
tâˆ’1
v=1
ev
X
t
u=v+1
(1 âˆ’ Ï)
tâˆ’u
(1 âˆ’
1
n
)
(uâˆ’2Ï„âˆ’vâˆ’1)+
â‰¤
X
tâˆ’1
v=1
ev
h
min(
X
t,v+2Ï„)
u=v+1
(1 âˆ’ Ï)
tâˆ’u +
X
t
u=v+2Ï„+1
(1 âˆ’ Ï)
tâˆ’u
(1 âˆ’
1
n
)
uâˆ’2Ï„âˆ’vâˆ’1
i
â‰¤
X
tâˆ’1
v=1
ev
h
2Ï„ (1 âˆ’ Ï)
tâˆ’vâˆ’2Ï„ + (1 âˆ’ Ï)
tâˆ’vâˆ’2Ï„âˆ’1 X
t
u=v+2Ï„+1
q
uâˆ’2Ï„âˆ’vâˆ’1
i
â‰¤
X
tâˆ’1
v=1
(1 âˆ’ Ï)
tâˆ’v
ev(1 âˆ’ Ï)
âˆ’2Ï„âˆ’1

2Ï„ +
1
1 âˆ’ q

, (85)
where we have defined:
q :=
1 âˆ’ 1/n
1 âˆ’ Ï
, with the assumption Ï <
1
n
. (86)
Note that we have bounded the min(t, v + 2Ï„ ) term by v + 2Ï„ in the first sub-sum, effectively
adding more positive terms.
This gives us that at time t, for u:
r3 â‰¤
4LÎ³2C1
n
(1 âˆ’ Ï)
tâˆ’u
(1 âˆ’ Ï)
âˆ’2Ï„âˆ’1

2Ï„ +
1
1 âˆ’ q

. (87)
For r4 we use the same trick:
X
t
u=0
(1 âˆ’ Ï)
tâˆ’u Xuâˆ’1
v=(uâˆ’Ï„)+
ev =
X
tâˆ’1
v=0
ev
min(
X
t,v+Ï„)
u=v+1
(1 âˆ’ Ï)
tâˆ’u
â‰¤
X
tâˆ’1
v=0
ev
Xv+Ï„
u=v+1
(1 âˆ’ Ï)
tâˆ’u â‰¤
X
tâˆ’1
v=0
evÏ„ (1 âˆ’ Ï)
tâˆ’vâˆ’Ï„
. (88)
48    
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
This gives us that at time t, for u:
r4 â‰¤ 4LÎ³2C2(1 âˆ’ Ï)
tâˆ’u
Ï„ (1 âˆ’ Ï)
âˆ’Ï„
. (89)
Finally we compute r5 which is the most complicated term. Indeed, to find the factor of
ew for a given w > 0, one has to compute a triple sum, Pt
u=0(1 âˆ’ Ï)
tâˆ’u Puâˆ’1
v=(uâˆ’Ï„)+
Hv. We
start by computing the factor of ew in the inner double sum, Puâˆ’1
v=(uâˆ’Ï„)+
Hv.
Xuâˆ’1
v=(uâˆ’Ï„)+
Xvâˆ’1
w=1
(1 âˆ’
1
n
)
(vâˆ’2Ï„âˆ’wâˆ’1)+ ew =
Xuâˆ’2
w=1
ew
Xuâˆ’1
v=max(w+1,uâˆ’Ï„)
(1 âˆ’
1
n
)
(vâˆ’2Ï„âˆ’wâˆ’1)+ . (90)
Now there are at most Ï„ terms for each ew. If w â‰¤ u âˆ’ 3Ï„ âˆ’ 1, then the exponent is positive
in every term and it is always bigger than u âˆ’ 3Ï„ âˆ’ 1 âˆ’ w, which means we can bound the
sum by Ï„ (1 âˆ’
1
n
)
uâˆ’3Ï„âˆ’1âˆ’w. Otherwise we can simply bound the sum by Ï„ . We get:
Xuâˆ’1
v=(uâˆ’Ï„)+
Hv â‰¤
Xuâˆ’2
w=1

1{uâˆ’3Ï„â‰¤wâ‰¤uâˆ’2}Ï„ + 1{wâ‰¤uâˆ’3Ï„âˆ’1}Ï„ (1 âˆ’
1
n
)
uâˆ’3Ï„âˆ’1âˆ’w

ew . (91)
This means that for w at time t:
r5 â‰¤
4LÎ³2C2
n
X
t
u=0
(1 âˆ’ Ï)
tâˆ’u

1{uâˆ’3Ï„â‰¤wâ‰¤uâˆ’2}Ï„ + 1{wâ‰¤uâˆ’3Ï„âˆ’1}Ï„ (1 âˆ’
1
n
)
uâˆ’3Ï„âˆ’1âˆ’w

â‰¤
4LÎ³2C2
n
h
min(
X
t,w+3Ï„)
u=w+2
Ï„ (1 âˆ’ Ï)
tâˆ’u +
X
t
u=w+3Ï„+1
Ï„ (1 âˆ’
1
n
)
uâˆ’3Ï„âˆ’1âˆ’w(1 âˆ’ Ï)
tâˆ’u
i
â‰¤
4LÎ³2C2
n
Ï„
h
(1 âˆ’ Ï)
tâˆ’w(1 âˆ’ Ï)
âˆ’3Ï„
3Ï„
+ (1 âˆ’ Ï)
tâˆ’w(1 âˆ’ Ï)
âˆ’1âˆ’3Ï„ X
t
u=w+3Ï„+1
(1 âˆ’
1
n
)
uâˆ’3Ï„âˆ’1âˆ’w(1 âˆ’ Ï)
âˆ’u+3Ï„+1+w
i
â‰¤
4LÎ³2C2
n
Ï„ (1 âˆ’ Ï)
tâˆ’w(1 âˆ’ Ï)
âˆ’3Ï„âˆ’1

3Ï„ +
1
(1 âˆ’ q)

. (92)
By combining the five terms together (83, 84, 87, 89 and 92), we get that âˆ€u s.t. 1 â‰¤ u â‰¤ t:
r
t
u â‰¤ (1 âˆ’ Ï)
tâˆ’u
h
âˆ’ 2Î³ + 4LÎ³2C1 +
4LÎ³2C1
n
(1 âˆ’ Ï)
âˆ’2Ï„âˆ’1

2Ï„ +
1
1 âˆ’ q

+ 4LÎ³2C2Ï„ (1 âˆ’ Ï)
âˆ’Ï„ +
4LÎ³2C2
n
Ï„ (1 âˆ’ Ï)
âˆ’3Ï„âˆ’1

3Ï„ +
1
1 âˆ’ q

i
.
(93)
Computation of r
t
0
. Recall that we treat the eËœ0 term separately in Section B.3. The
initialization of Saga creates an initial synchronization, which means that the contribution
of eËœ0 in our bound on Ekgtk
2
(75) is roughly n times bigger than the contribution of any
eu for 1 < u < t.
29 In order to safely handle this term in our Lyapunov inequality, we only
need to prove that it is bounded by a reasonable constant. Here again, we split r
t
0
in five
contributions coming from (81):
29. This is explained in details right before (74).       
Leblond, Pedregosa and Lacoste-Julien
â€¢ r1, the part coming from the âˆ’2Î³eu terms;
â€¢ r2, coming from 4LÎ³2C1eu;
â€¢ r3, coming from 4LÎ³2C1(1 âˆ’
1
n
)
(uâˆ’Ï„)+ eËœ0;
â€¢ r4, coming from 4LÎ³2C2
Puâˆ’1
v=(uâˆ’Ï„)+
ev;
â€¢ r5, coming from 4LÎ³2C2
Puâˆ’1
v=(uâˆ’Ï„)+
(1 âˆ’
1
n
)
(vâˆ’Ï„)+ eËœ0.
Note that there is no eËœ0 in Ht
, which is why we can safely ignore these terms here.
We have r1 = âˆ’2Î³(1 âˆ’ Ï)
t and r2 = 4LÎ³2C1(1 âˆ’ Ï)
t
.
Let us compute r3.
X
t
u=0
(1 âˆ’ Ï)
tâˆ’u
(1 âˆ’
1
n
)
(uâˆ’Ï„)+
=
min(
X
t,Ï„)
u=0
(1 âˆ’ Ï)
tâˆ’u +
X
t
u=Ï„+1
(1 âˆ’ Ï)
tâˆ’u
(1 âˆ’
1
n
)
uâˆ’Ï„
â‰¤ (Ï„ + 1)(1 âˆ’ Ï)
tâˆ’Ï„ + (1 âˆ’ Ï)
tâˆ’Ï„ X
t
u=Ï„+1
(1 âˆ’ Ï)
Ï„âˆ’u
(1 âˆ’
1
n
)
uâˆ’Ï„
â‰¤ (1 âˆ’ Ï)
t
(1 âˆ’ Ï)
âˆ’Ï„

Ï„ + 1 +
1
1 âˆ’ q

. (94)
This gives us:
r3 â‰¤ (1 âˆ’ Ï)
t
4LÎ³2C1(1 âˆ’ Ï)
âˆ’Ï„

Ï„ + 1 +
1
1 âˆ’ q

. (95)
We have already computed r4 for u > 0 and the computation is exactly the same for
u = 0. r4 â‰¤ (1 âˆ’ Ï)
t4LÎ³2C2
Ï„
1âˆ’Ï
.
Finally we compute r5.
X
t
u=0
(1 âˆ’ Ï)
tâˆ’u Xuâˆ’1
v=(uâˆ’Ï„)+
(1 âˆ’
1
n
)
(vâˆ’Ï„)+
=
X
tâˆ’1
v=1
min(
X
t,v+Ï„)
u=v+1
(1 âˆ’ Ï)
tâˆ’u
(1 âˆ’
1
n
)
(vâˆ’Ï„)+
â‰¤
min(
X
tâˆ’1,Ï„)
v=1
Xv+Ï„
u=v+1
(1 âˆ’ Ï)
tâˆ’u +
X
tâˆ’1
v=Ï„+1
min(
X
t,v+Ï„)
u=v+1
(1 âˆ’ Ï)
tâˆ’u
(1 âˆ’
1
n
)
vâˆ’Ï„
â‰¤ Ï„
2
(1 âˆ’ Ï)
tâˆ’2Ï„ +
X
tâˆ’1
v=Ï„+1
(1 âˆ’
1
n
)
vâˆ’Ï„
Ï„ (1 âˆ’ Ï)
tâˆ’vâˆ’Ï„
â‰¤ Ï„
2
(1 âˆ’ Ï)
tâˆ’2Ï„ + Ï„ (1 âˆ’ Ï)
t
(1 âˆ’ Ï)
âˆ’2Ï„ X
tâˆ’1
v=Ï„+1
(1 âˆ’
1
n
)
vâˆ’Ï„
Ï„ (1 âˆ’ Ï)
âˆ’v+Ï„
â‰¤ (1 âˆ’ Ï)
t
(1 âˆ’ Ï)
âˆ’2Ï„

Ï„
2 + Ï„
1
1 âˆ’ q

. (96)   
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Which means:
r5 â‰¤ (1 âˆ’ Ï)
t
4LÎ³2C2(1 âˆ’ Ï)
âˆ’2Ï„

Ï„
2 + Ï„
1
1 âˆ’ q

. (97)
Putting it all together, we get that: âˆ€t â‰¥ 0,
r
t
0 â‰¤ (1 âˆ’ Ï)
t
h âˆ’ 2Î³ + 4LÎ³2C1 + 4LÎ³2C2
Ï„
1 âˆ’ Ï
e0
eËœ0
+ 4LÎ³2C1(1 âˆ’ Ï)
âˆ’Ï„

Ï„ + 1 +
1
1 âˆ’ q

+ 4LÎ³2C2Ï„ (1 âˆ’ Ï)
âˆ’2Ï„

Ï„ +
1
1 âˆ’ q

i
.
(98)
Sufficient condition for convergence. We need all r
t
u
, u â‰¥ 1 to be negative so we can
safely drop them from (82). Note that for every u, this is the same condition. We will reduce
that condition to a second-order polynomial sign condition. We also remark that since Î³ â‰¥ 0,
we can upper bound our terms in Î³ and Î³
2
in this upcoming polynomial, which will give us
sufficient conditions for convergence.
Now, recall that C2(Î³) (as defined in (17)) depends on Î³. We thus need to expand it
once more to find our conditions. We have:
C1 = 1 + âˆš
âˆ†Ï„ ; C2 =
âˆš
âˆ† + Î³ÂµC1 .
Dividing the bracket in (93) by Î³ and rearranging as a second degree polynomial, we get
the condition:
4L

C1 +
C1
n
(1 âˆ’ Ï)
âˆ’2Ï„âˆ’1
h
2Ï„ +
1
1 âˆ’ q
i
+
h âˆš
âˆ†Ï„
(1 âˆ’ Ï)
Ï„
+
âˆš
âˆ†Ï„
n
(1 âˆ’ Ï)
âˆ’3Ï„âˆ’1
(3Ï„ +
1
1 âˆ’ q
)
i
!
Î³
+ 8ÂµC1LÏ„h
(1 âˆ’ Ï)
âˆ’Ï„ +
1
n
(1 âˆ’ Ï)
âˆ’3Ï„âˆ’1
(3Ï„ +
1
1 âˆ’ q
)
i
Î³
2 + 2 â‰¤ 0 . (99)
The discriminant of this polynomial is always positive, so Î³ needs to be between its two roots.
The smallest is negative, so the condition is not relevant to our case (where Î³ > 0). By
solving analytically for the positive root Ï†, we get an upper bound condition on Î³ that can
be used for any overlap Ï„ and guarantee convergence. Unfortunately, for large Ï„ , the upper
bound becomes exponentially small because of the presence of Ï„ in the exponent in (99).
More specifically, by using the bound 1/(1 âˆ’ Ï) â‰¤ exp(2Ï)
30 and thus (1 âˆ’ Ï)
âˆ’Ï„ â‰¤ exp(2Ï„ Ï)
in (99), we would obtain factors of the form exp(Ï„ /n) in the denominator for the root Ï†
(recall that Ï < 1/n).
Our Lemma 14 is derived instead under the assumption that Ï„ â‰¤ O(n), with the constants
chosen in order to make the condition (99) more interpretable and to relate our convergence
result with the standard SAGA convergence (see Theorem 2). As explained in Section 6.7,
the assumption that Ï„ â‰¤ O(n) appears reasonable in practice. First, by using Bernoulliâ€™s
inequality, we have:
(1 âˆ’ Ï)
kÏ„ â‰¥ 1 âˆ’ kÏ„ Ï for integers kÏ„ â‰¥ 0 . (100)
30. This bound can be derived from the inequality (1 âˆ’ x/2) â‰¥ exp(âˆ’x) which is valid for 0 â‰¤ x â‰¤ 1.59.   
Leblond, Pedregosa and Lacoste-Julien
To get manageable constants, we make the following slightly more restrictive assumptions on
the target rate Ï
31 and overlap Ï„ :
32
Ï â‰¤
1
4n
(101)
Ï„ â‰¤
n
10
. (102)
We then have:
1
1 âˆ’ q
â‰¤
4n
3
(103)
1
1 âˆ’ Ï
â‰¤
4
3
(104)
kÏ„ Ï â‰¤
3
40
for 1 â‰¤ k â‰¤ 3 (105)
(1 âˆ’ Ï)
âˆ’kÏ„ â‰¤
1
1 âˆ’ kÏ„ Ï â‰¤
40
37
for 1 â‰¤ k â‰¤ 3 and by using (100). (106)
We can now upper bound loosely the three terms in brackets appearing in (99) as follows:
(1 âˆ’ Ï)
âˆ’2Ï„âˆ’1

2Ï„ +
1
1 âˆ’ q

â‰¤ 3n (107)
âˆš
âˆ†Ï„ (1 âˆ’ Ï)
âˆ’Ï„ +
âˆš
âˆ†Ï„
n
(1 âˆ’ Ï)
âˆ’3Ï„âˆ’1
(3Ï„ +
1
1 âˆ’ q
) â‰¤ 4
âˆš
âˆ†Ï„ â‰¤ 4C1 (108)
(1 âˆ’ Ï)
âˆ’Ï„ +
1
n
(1 âˆ’ Ï)
âˆ’3Ï„âˆ’1
(3Ï„ +
1
1 âˆ’ q
) â‰¤ 4 . (109)
By plugging (107)â€“(109) into (99), we get the simpler sufficient condition on Î³:
âˆ’1 + 16LC1Î³ + 16LC1ÂµÏ„ Î³2 â‰¤ 0 . (110)
The positive root Ï† is:
Ï† =
16LC1(
q
1 + ÂµÏ„
4LC1
âˆ’ 1)
32LC1ÂµÏ„
=
q
1 + ÂµÏ„
4LC1
âˆ’ 1
2ÂµÏ„
. (111)
We simplify it further by using the inequality:33
âˆš
x âˆ’ 1 â‰¥
x âˆ’ 1
2
âˆš
x
âˆ€x > 0 . (112)
Using (112) in (111), and recalling that Îº := L/Âµ, we get:
Ï† â‰¥
1
16LC1
q
1 + Ï„
4ÎºC1
. (113)
31. Note that we already expected Ï < 1/n.
32. This bound on Ï„ is reasonable in practice, see Appendix 6.7.
33. This inequality can be derived by using the concavity property f(y) â‰¤ f(x) + (y âˆ’ x)f
0
(x) on the
differentiable concave function f(x) = âˆš
x with y = 1.
52  
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Since Ï„
C1
=
Ï„
1+âˆš
âˆ†Ï„
â‰¤ min(Ï„, âˆš
1
âˆ†
), we get that a sufficient condition on our step size is:
Î³ â‰¤
1
16L(1 + âˆš
âˆ†Ï„ )
q
1 + 1
4Îº min(Ï„, âˆš
1
âˆ†
)
. (114)
Subject to our conditions on Î³, Ï and Ï„ , we then have that: r
t
u â‰¤ 0 for all u s.t. 1 â‰¤ u â‰¤ t.
This means we can rewrite (82) as:
Lt+1 â‰¤ (1 âˆ’ Ï)
t+1a0 + (1 âˆ’
Î³Âµ
2
)Lt + r
t
0
eËœ0 . (115)
Now, we could finish the proof from this inequality, but it would only give us a convergence
result in terms of at = Ekxt âˆ’ x
âˆ—k
2
. A better result would be in terms of the suboptimality
at xË†t (because xË†t
is a real quantity in the algorithm whereas xt
is virtual). Fortunately, to
get such a result, we can easily adapt (115).
We make et appear on the left side of (115), by adding Î³ to r
t
t
in (82):34
Î³et + Lt+1 â‰¤ (1 âˆ’ Ï)
t+1a0 + (1 âˆ’
Î³Âµ
2
)Lt +
X
tâˆ’1
u=1
r
t
u
eu + r
t
0
eËœ0 + (r
t
t + Î³)et
. (116)
We now require the stronger property that Î³ + r
t
t â‰¤ 0, which translates to replacing âˆ’2Î³
with âˆ’Î³ in (93):
0 â‰¥
h
âˆ’ Î³ + 4LÎ³2C1 +
4LÎ³2C1
n
(1 âˆ’ Ï)
âˆ’2Ï„âˆ’1

2Ï„ +
1
1 âˆ’ q

+ 4LÎ³2C2Ï„ (1 âˆ’ Ï)
âˆ’Ï„ +
4LÎ³2C2
n
Ï„ (1 âˆ’ Ï)
âˆ’3Ï„

3Ï„ +
1
1 âˆ’ q

i
.
(117)
We can easily derive a new stronger condition on Î³ under which we can drop all the
eu, u > 0 terms in (116):
Î³ â‰¤ Î³
âˆ— =
1
32L(1 + âˆš
âˆ†Ï„ )
q
1 + 1
8Îº min(Ï„, âˆš
1
âˆ†
)
, (118)
and thus under which we get:
Î³et + Lt+1 â‰¤ (1 âˆ’ Ï)
t+1a0 + (1 âˆ’
Î³Âµ
2
)Lt + r
t
0
eËœ0. (119)
This finishes the proof of Lemma 14.
34. We could use any multiplier from 0 to 2Î³, but choose Î³ for simplicity. For this reason and because our
analysis of the r
t
t term was loose, we could derive a tighter bound, but it does not change the leading
terms.
  
Leblond, Pedregosa and Lacoste-Julien
B.8. Proof of Theorem 8 (convergence guarantee and rate of Asaga)
End of Lyapunov convergence. We continue with the assumptions of Lemma 14 which
gave us (119). Thanks to (98), we can also rewrite r
t
0 â‰¤ (1 âˆ’ Ï)
t+1A where A is a constant
which depends on n, âˆ†, Î³ and L but is finite and crucially does not depend on t. In fact,
by reusing similar arguments as in B.7, we can show the loose bound A â‰¤ Î³n under the
assumptions of Lemma 14 (including Î³ â‰¤ Î³
âˆ—
).35 We then have:
Lt+1 â‰¤ Î³et + Lt+1 â‰¤ (1 âˆ’
Î³Âµ
2
)Lt + (1 âˆ’ Ï)
t+1(a0 + AeËœ0)
â‰¤ (1 âˆ’
Î³Âµ
2
)
t+1L0 + (a0 + AeËœ0)
X
t+1
k=0
(1 âˆ’ Ï)
t+1âˆ’k
(1 âˆ’
Î³Âµ
2
)
k
. (120)
We have two linearly contracting terms. The sum contracts linearly with the minimum geometric rate factor between Î³Âµ/2 and Ï. If we define m := min(Ï, Î³Âµ/2), M := max(Ï, Î³Âµ/2)
and Ï
âˆ—
:= Î½m with 0 < Î½ < 1,
36 we then get:37
Î³et â‰¤ Î³et + Lt+1 â‰¤ (1 âˆ’
Î³Âµ
2
)
t+1L0 + (a0 + AeËœ0)
X
t+1
k=0
(1 âˆ’ m)
t+1âˆ’k
(1 âˆ’ M)
k
â‰¤ (1 âˆ’
Î³Âµ
2
)
t+1L0 + (a0 + AeËœ0)
X
t+1
k=0
(1 âˆ’ Ï
âˆ—
)
t+1âˆ’k
(1 âˆ’ M)
k
â‰¤ (1 âˆ’
Î³Âµ
2
)
t+1L0 + (a0 + AeËœ0)(1 âˆ’ Ï
âˆ—
)
t+1X
t+1
k=0
(1 âˆ’ Ï
âˆ—
)
âˆ’k
(1 âˆ’ M)
k
â‰¤ (1 âˆ’
Î³Âµ
2
)
t+1L0 + (1 âˆ’ Ï
âˆ—
)
t+1 1
1 âˆ’ Î·
(a0 + AeËœ0)
â‰¤ (1 âˆ’ Ï
âˆ—
)
t+1
a0 +
1
1 âˆ’ Î·
(a0 + AeËœ0)

, (121)
where Î· := 1âˆ’M
1âˆ’Ï
âˆ— . We have 1
1âˆ’Î· =
1âˆ’Ï
âˆ—
Mâˆ’Ï
âˆ— .
By taking Î½ =
4
5
and setting Ï =
1
4n
â€“ its maximal value allowed by the assumptions of
Lemma 14 â€“ we get M â‰¥
1
4n
and Ï
âˆ— â‰¤
1
5n
, which means 1
1âˆ’Î· â‰¤ 20n. All told, using A â‰¤ Î³n,
we get:
et â‰¤ (1 âˆ’ Ï
âˆ—
)
t+1CËœ
0, (122)
where:
CËœ
0 :=
21n
Î³

kx0 âˆ’ x
âˆ—
k
2 + Î³
n
2L
EkÎ±
0
i âˆ’ f
0
i
(x
âˆ—
)k
2

. (123)
Since we set Ï =
1
4n
, Î½ =
4
5
, we have Î½Ï =
1
5n
. Using a step size Î³ =
a
L
as in Theorem 8,
we get Î½
Î³Âµ
2 =
2a
5Îº
. We thus obtain a geometric rate of Ï
âˆ— = min{
1
5n
, a 2
5Îº
}, which we simplified
35. In particular, note that e0 does not appear in the definition of A because it turns out that the parenthesis
group multiplying e0 in (98) is negative. Indeed, it contains less positive terms than (93) which we showed
to be negative under the assumptions from Lemma 14.
36. Î½ is introduced to circumvent the problematic case where Ï and Î³Âµ/2 are too close together, which does
not prevent the geometric convergence, but makes the constant 1
1âˆ’Î·
potentially very big (in the case both
terms are equal, the sum even becomes an annoying linear term in t).
37. Note that if m 6= Ï, we can perform the index change t + 1 âˆ’ k â†’ k to get the sum.
5 
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
to 1
5 min{
1
n
, a 1
Îº
} in Theorem 8, finishing the proof. We also observe that CËœ
0 â‰¤
60n
Î³
C0, with
C0 defined in Theorem 2.
B.9. Proof of Corollary 9 (speedup regimes for Asaga)
Referring to Hofmann et al. (2015) and our own Theorem 2, the geometric rate factor of
Saga is 1
5 min{
1
n
,
a
Îº
} for a step size of Î³ =
a
5L
. We start by proving the first part of the
corollary which considers the step size Î³ =
a
L with a = a
âˆ—
(Ï„ ). We distinguish between two
regimes to study the parallel speedup our algorithm obtains and to derive a condition on Ï„
for which we have a linear speedup.
Well-conditioned regime. In this regime, n > Îº and the geometric rate factor of sequential
Saga is 1
5n
. To get a linear speedup (up to a constant factor), we need to enforce Ï
âˆ— = â„¦( 1
n
).
We recall that Ï
âˆ— = min{
1
5n
, a 1
5Îº
}.
We already have 1
5n = â„¦( 1
n
). This means that we need Ï„ to verify a
âˆ—(Ï„)
5Îº = â„¦( 1
n
), where
a
âˆ—
(Ï„ ) = 1
32(1+Ï„
âˆš
âˆ†)Î¾(Îº,âˆ†,Ï„)
according to Theorem 8. Recall that Î¾(Îº, âˆ†, Ï„ ) := q
1 + 1
8Îº min{ âˆš
1
âˆ†
, Ï„}.
Up to a constant factor, this means we can give the following sufficient condition:
1
Îº

1 + Ï„
âˆš
âˆ†

Î¾(Îº, âˆ†, Ï„ )
= â„¦ 1
n

(124)
i.e.

1 + Ï„
âˆš
âˆ†

Î¾(Îº, âˆ†, Ï„ ) = O
n
Îº

. (125)
We now consider two alternatives, depending on whether Îº is bigger than âˆš
1
âˆ†
or not. If
Îº â‰¥ âˆš
1
âˆ†
, then Î¾(Îº, âˆ†, Ï„ ) < 2 and we can rewrite the sufficient condition (125) as:
Ï„ = O(1) n
Îº
âˆš
âˆ†
. (126)
In the alternative case, Îº â‰¤ âˆš
1
âˆ†
. Since a
âˆ—
(Ï„ ) is decreasing in Ï„ , we can suppose Ï„ â‰¥ âˆš
1
âˆ†
without loss of generality and thus Î¾(Îº, âˆ†, Ï„ ) = q
1 + 1
8Îº
âˆš
âˆ†
. We can then rewrite the
sufficient condition (125) as:
Ï„
âˆš
âˆ†
âˆš
Îº
âˆš4 âˆ†
= O(
n
Îº
) ;
Ï„ = O(1) n
âˆš
Îº
âˆš4 âˆ†
. (127)
We observe that since we have supposed that Îº â‰¤ âˆš
1
âˆ†
, we have p
Îº
âˆš
âˆ† â‰¤ Îº
âˆš
âˆ† â‰¤ 1,
which means that our initial assumption that Ï„ < n
10 is stronger than condition (127).
We can now combine both cases to get the following sufficient condition for the geometric
rate factor of Asaga to be the same order as sequential Saga when n > Îº:
Ï„ = O(1) n
Îº
âˆš
âˆ†
; Ï„ = O(n). (128)
55
Leblond, Pedregosa and Lacoste-Julien
Ill-conditioned regime. In this regime, Îº > n and the geometric rate factor of sequential
Saga is a
1
Îº
. Here, to obtain a linear speedup, we need Ï
âˆ— = O(
1
Îº
). Since 1
n >
1
Îº
, all we
require is that a
âˆ—(Ï„)
Îº = â„¦( 1
Îº
) where a
âˆ—
(Ï„ ) = 1
32(1+Ï„
âˆš
âˆ†)Î¾(Îº,âˆ†,Ï„)
, which reduces to a
âˆ—
(Ï„ ) = â„¦(1).
We can give the following sufficient condition:
1

1 + Ï„
âˆš
âˆ†

Î¾(Îº, âˆ†, Ï„ )
= â„¦(1) (129)
Using that 1
n â‰¤ âˆ† â‰¤ 1 and that Îº > n, we get that Î¾(Îº, âˆ†, Ï„ ) â‰¤ 2, which means our
sufficient condition becomes:
Ï„
âˆš
âˆ† = O(1)
Ï„ =
O(1)
âˆš
âˆ†
. (130)
This finishes the proof for the first part of Corollary 9.
Universal step size. If Ï„ = O( âˆš
1
âˆ†
), then Î¾(Îº, âˆ†, Ï„ ) = O(1) and (1 + Ï„
âˆš
âˆ†) = O(1), and
thus a
âˆ—
(Ï„ ) = â„¦(1) (for any n and Îº). This means that the universal step size Î³ = Î˜(1/L)
satisfies Î³ â‰¤ a
âˆ—
(Ï„ ) for any Îº, giving the same rate factor â„¦(min{
1
n
,
1
Îº
}) that sequential Saga
has, completing the proof for the second part of Corollary 9.
Appendix C. Kromagnon â€“ Proof of Theorem 15 and Corollary 18
C.1. Proof of Lemma 19 (suboptimality bound on Ekgtk
2
)
Mania et al. (2017, Lemma 9), tells us that for serial sparse Svrg we have for all km â‰¤ t â‰¤
(k + 1)m âˆ’ 1:
Ekgtk
2 â‰¤ 2Ekf
0
it
(Ë†xt) âˆ’ f
0
it
(x
âˆ—
)k
2 + 2Ekf
0
it
(Ë†xk) âˆ’ f
0
it
(x
âˆ—
)k
2
. (131)
This remains true in the case of Kromagnon. We can use Hofmann et al. (2015, Equations
7 and 8) to bound both terms in the following manner:
Ekgtk
2 â‰¤ 4L(Ef(Ë†xt) âˆ’ f(x
âˆ—
)) + 4L(Ef(Ëœxk) âˆ’ f(x
âˆ—
)) â‰¤ 4Let + 4LeËœk . (132)
C.2. Proof of Theorem 15 (convergence guarantee and rate of Kromagnon)
Master inequality derivation. As in our Asaga analysis, we plug Lemma 19 in Lemma 10,
which gives us that for all k â‰¥ 0, km â‰¤ t â‰¤ (k + 1)m âˆ’ 1:
at+1 â‰¤ (1 âˆ’
Î³Âµ
2
)at + Î³
2C1(4Let + 4LeËœk) + Î³
2C2
X
tâˆ’1
u=max(km,tâˆ’Ï„)
(4Let + 4LeËœk) âˆ’ 2Î³et
. (133)
56
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
By grouping the eËœk and the et terms we get our master inequality (42):
at+1 â‰¤ (1 âˆ’
Î³Âµ
2
)at + (4LÎ³2C1 âˆ’ 2Î³)et + 4LÎ³2C2
X
tâˆ’1
u=max(km,tâˆ’Ï„)
eu + (4LÎ³2C1 + 4LÎ³2
Ï„C2)Ëœek .
Contraction inequality derivation. We now adopt the same method as in the original
Svrg paper (Johnson and Zhang, 2013); we sum the master inequality over a whole epoch
and then we use the randomization trick:
eËœk = Ef(Ëœxk) âˆ’ f(x
âˆ—
) = 1
m
km
Xâˆ’1
t=(kâˆ’1)m
et (134)
This gives us:
(k
X
+1)m
t=km+1
at â‰¤(1 âˆ’
Î³Âµ
2
)
(k+1)
Xmâˆ’1
t=km
at + (4LÎ³2C1 âˆ’ 2Î³)
(k+1)
Xmâˆ’1
t=km
et
+ 4LÎ³2C2
(k+1)
Xmâˆ’1
t=km
X
tâˆ’1
u=max(km,tâˆ’Ï„)
eu + m(4LÎ³2C1 + 4LÎ³2
Ï„C2)Ëœek .
(135)
Since 1 âˆ’
Î³Âµ
2 < 1, we can upper bound it by 1, and then remove all the telescoping terms
from (135). We also have:
(k+1)
Xmâˆ’1
t=km
X
tâˆ’1
u=max(km,tâˆ’Ï„)
eu =
(k+1)
Xmâˆ’2
u=km
min((k+1)
Xmâˆ’1,u+Ï„)
t=u+1
eu â‰¤ Ï„
(k+1)
Xmâˆ’2
u=km
eu
â‰¤ Ï„
(k+1)
Xmâˆ’1
u=km
eu .
(136)
All told:
a(k+1)m â‰¤ akm + (4LÎ³2C1 + 4LÎ³2
Ï„C2 âˆ’ 2Î³)
(k+1)
Xmâˆ’1
t=km
et + m(4LÎ³2C1 + 4LÎ³2
Ï„C2)Ëœek . (137)
Now we use the randomization trick (134):
a(k+1)m â‰¤ akm + (4LÎ³2C1 + 4LÎ³2
Ï„C2 âˆ’ 2Î³)meËœk+1 + m(4LÎ³2C1 + 4LÎ³2
Ï„C2)Ëœek . (138)
Finally, in order to get a recursive inequality in eËœk, we can remove the positive a(k+1)m term
from the left-hand side of (138) and bound the akm term on the right-hand side by 2ekm/Âµ
using a standard strong convexity inequality. We get our final contraction inequality (45):
(2Î³m âˆ’ 4mLÎ³2C1 âˆ’ 4mLÎ³2
Ï„C2)Ëœek+1 â‰¤
 2
Âµ
+ 4mLÎ³2C1 + 4mLÎ³2
Ï„C2

eËœk .
5 
Leblond, Pedregosa and Lacoste-Julien
C.3. Proof of Corollary 16, Corollary 17 and Corollary 18 (speedup regimes)
A simpler result for Svrg. The standard convergence rate for serial Svrg is given by:
Î¸ :=
1
ÂµÎ³m + 2LÎ³
1 âˆ’ 2LÎ³
. (139)
If we define a such that Î³ = a/4L, we obtain:
Î¸ =
4Îº
am +
a
2
1 âˆ’
a
2
. (140)
Now, since we need Î¸ â‰¤ 1, we see that we require a â‰¤ 1. The optimal value of the denominator
is then 1 (when a = 0), whereas the worst case value is 1/2 (a = 1). We can thus upper
bound Î¸ by replacing the denominator with 1/2, while satisfied that we do not lose more than
a factor of 2. This gives us:
Î¸ â‰¤
8Îº
am
+ a . (141)
Enforcing Î¸ â‰¤ 1/2 can be done easily by choosing a â‰¤ 1/4 and m = 32Îº/a. Now, to be able to
compare algorithms easily, we want to frame our result in terms of rate factor per gradient
computation Ï, such that (38) is verified:
Ef(Ëœxk) âˆ’ f(x
âˆ—
) â‰¤ (1 âˆ’ Ï)
k(2m+n)
(Ef(x0) âˆ’ f(x
âˆ—
)) âˆ€k â‰¥ 0 .
We define Ïb := 1 âˆ’ Î¸. We want to estimate Ï such that (1 âˆ’ Ï)
2m+n = 1 âˆ’ Ïb. We get that
Ï = 1 âˆ’ (1 âˆ’ Ïb)
1
2m+n . Using Bernoulliâ€™s inequality, we get:
Ï â‰¥
Ïb
2m + n
â‰¥
1
2(2m + n)
â‰¥
1
4
min  1
2m
,
1
n
	
â‰¥
1
4
min  a
64Îº
,
1
n
	
. (142)
This finishes the proof for Corollary 16.
A simpler result for Kromagnon. We also define a such that Î³ = a/4L. Theorem 15
tells us that:
Î¸ =
4Îº
am +
a
2C3(1 + Ï„
16Îº
)
1 âˆ’
a
2C3(1 + Ï„
16Îº
)
. (143)
We can once again upper bound Î¸ by removing its denominator at a reasonable worst-case
cost of a factor of 2:
Î¸ â‰¤
8Îº
am
+ aC3(1 + Ï„
16Îº
). (144)
Now, to enforce Î¸ â‰¤ 1/2, we can choose a â‰¤
1
4C3(1+ Ï„
16Îº
)
and m =
32Îº
a
. We also obtain a
rate factor per gradient computation of: Ï â‰¥
1
4 min{
a
64Îº
,
1
n
}. This finishes the proof of
Corollary 17.
58
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Speedup conditions. All we have to do now is to compare the rate factors of Svrg and
Kromagnon in different regimes. Note that while our convergence result hold for any
a â‰¤ 1/4 Svrg (or the slightly more complex expression in the case of Kromagnon), the
best step size (in terms of number of gradient computations) ensuring Î¸ â‰¤
1
2
is the biggest
allowable one â€“ thus this is the one we use for our comparison.
Suppose we are in the â€œwell-conditionedâ€ regime where n â‰¥ Îº. The rate factor of Svrg is
â„¦(1/n). To make sure we have a linear speedup, we need the rate factor of Kromagnon to
also be â„¦(1/n), which means that:
1
256ÎºC3 + 16Ï„C3
= â„¦( 1
n
) (145)
Recalling that C3 = 1 + 2Ï„
âˆš
âˆ†, we can rewrite (145) as:
Îº = O(n) ; ÎºÏ„âˆš
âˆ† = O(n) ; Ï„ = O(n) ; Ï„
2
âˆš
âˆ† = O(n). (146)
We can condense these conditions down to:
Ï„ = O(
n
Îº
âˆš
âˆ†
) ; Ï„ = O(
p
nâˆ†âˆ’1/2). (147)
Suppose now we are in the â€œill-conditionedâ€ regime, where Îº â‰¥ n. The rate factor of Svrg is
now â„¦(1/Îº). To make sure we have a linear speedup, we need the rate factor of Kromagnon
to also be â„¦(1/Îº), which means that:
1
256ÎºC3 + 16Ï„C3
= â„¦( 1
Îº
) (148)
We can derive the following sufficient conditions:
Ï„ = O(
1
âˆš
âˆ†
) ; Ï„ = O(Îº). (149)
Since Îº â‰¥ n, we obtain the conditions of Corollary 18 and thus finish its proof.
Appendix D. Hogwild â€“ Proof of Theorem 22 and Corollary 23
D.1. Proof of Lemma 24 (suboptimality bound on Ekgtk
2
)
As was the case for proving Lemma 13 and Lemma 19, we simply introduce f
0
i
(x
âˆ—
) in gt to
derive our bound.
Ekgtk
2 = Ekf
0
i
(Ë†xt)k
2 = Ekf
0
i
(Ë†xt) âˆ’ f
0
i
(x
âˆ—
) + f
0
i
(x
âˆ—
)k
2
â‰¤ 2Ekf
0
i
(Ë†xt) âˆ’ f
0
i
(x
âˆ—
)k
2 + 2Ekf
0
i
(x
âˆ—
)k
2
(ka + bk
2 â‰¤ 2kak
2 + 2kbk
2
)
â‰¤ 4Let + 2Ïƒ
2
. (Hofmann et al. (2015), Eq (7) & (8))
59
Leblond, Pedregosa and Lacoste-Julien
D.2. Proof of Theorem 22 (convergence guarantee and rate of Hogwild)
Master inequality derivation. Once again, we plug Lemma 24 into Lemma 10 which
gives us:
at+1 â‰¤ (1 âˆ’
Î³Âµ
2
)at + Î³
2C1(4Let + 2Ïƒ
2
) + Î³
2C2
X
tâˆ’1
u=(tâˆ’Ï„)+
(4Leu + 2Ïƒ
2
) âˆ’ 2Î³et
. (150)
By grouping the et and the Ïƒ
2
terms we get our master inequality (48):
at+1 â‰¤ (1 âˆ’
Î³Âµ
2
)at + (4LÎ³2C1 âˆ’ 2Î³)et + 4LÎ³2C2
X
tâˆ’1
u=(tâˆ’Ï„)+
eu + 2Î³
2Ïƒ
2
(C1 + Ï„C2).
Contraction inequality derivation (xt). We now unroll (48) all the way to t = 0 to get:
at+1 â‰¤ (1 âˆ’
Î³Âµ
2
)
t+1a0 +
X
t
u=0
(1 âˆ’
Î³Âµ
2
)
tâˆ’u
(4LÎ³2C1 âˆ’ 2Î³)eu
+
X
t
u=0
(1 âˆ’
Î³Âµ
2
)
tâˆ’u
4LÎ³2C2
Xuâˆ’1
v=(uâˆ’Ï„)+
ev
+
X
t
u=0
(1 âˆ’
Î³Âµ
2
)
tâˆ’u
2Î³
2Ïƒ
2
(C1 + Ï„C2).
(151)
Now we can simplify these terms as follows:
X
t
u=0
(1 âˆ’
Î³Âµ
2
)
tâˆ’u Xuâˆ’1
v=(uâˆ’Ï„)+
ev =
X
tâˆ’1
v=0
min(
X
t,v+Ï„)
u=v+1
(1 âˆ’
Î³Âµ
2
)
tâˆ’u
ev
=
X
tâˆ’1
v=0
(1 âˆ’
Î³Âµ
2
)
tâˆ’v
ev
min(
X
t,v+Ï„)
u=v+1
(1 âˆ’
Î³Âµ
2
)
vâˆ’u
â‰¤
X
tâˆ’1
v=0
(1 âˆ’
Î³Âµ
2
)
tâˆ’v
evÏ„ (1 âˆ’
Î³Âµ
2
)
âˆ’Ï„
â‰¤ Ï„ (1 âˆ’
Î³Âµ
2
)
âˆ’Ï„ X
t
v=0
(1 âˆ’
Î³Âµ
2
)
tâˆ’v
ev . (152)
This (1 âˆ’
Î³Âµ
2
)
âˆ’Ï„
term is easily bounded, as we did in (107) for Asaga. Using Bernoulliâ€™s
inequality (100), we get that if we assume Ï„ â‰¤
1
Î³Âµ
:
38
(1 âˆ’
Î³Âµ
2
)
âˆ’Ï„ â‰¤ 2 . (153)
38. While this assumption on Ï„ may appear restrictive, it is in fact weaker than the condition for a linear
speed-up obtained by our analysis in Corollary 23.
60
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
We note that the last term in (151) is a geometric sum:
X
t
u=0
(1 âˆ’
Î³Âµ
2
)
tâˆ’uÏƒ
2 =
2
Î³Âµ
Ïƒ
2
. (154)
We plug (152)â€“(154) in (151) to obtain (49):
at+1 â‰¤ (1 âˆ’
Î³Âµ
2
)
t+1a0 + (4LÎ³2C1 + 8LÎ³2
Ï„C2 âˆ’ 2Î³)
X
t
u=0
(1 âˆ’
Î³Âµ
2
)
tâˆ’u
eu +
4Î³Ïƒ2
Âµ
(C1 + Ï„C2).
Contraction inequality derivation (xË†t). We now have an contraction inequality for the
convergence of xt to x
âˆ—
. However, since this quantity does not exist (except if we fix the
number of iterations prior to running the algorithm and then wait for all iterations to be
finished â€“ an unwieldy solution), we rather want to prove that xË†t converges to x
âˆ—
. In order
to do this, we use the simple following inequality:
kxË†t âˆ’ x
âˆ—
k
2 â‰¤ 2at + 2kxË†t âˆ’ xtk
2
. (155)
We already have a contraction bound on the first term (49). For the second term, we
combine (65) with Lemma 24 to get:
EkxË†t âˆ’ xtk
2 â‰¤ 4LÎ³2C1
X
tâˆ’1
u=(tâˆ’Ï„)+
eu + 2Î³
2
Ï„Ïƒ2
. (156)
To make it easier to combine with (49), we rewrite (156) as:
EkxË†t âˆ’ xtk
2 â‰¤ 4LÎ³2C1(1 âˆ’
Î³Âµ
2
)
âˆ’Ï„ X
tâˆ’1
u=(tâˆ’Ï„)+
(1 âˆ’
Î³Âµ
2
)
tâˆ’1âˆ’u
eu + 2Î³
2
Ï„Ïƒ2
â‰¤ 8LÎ³2C1
X
tâˆ’1
u=(tâˆ’Ï„)+
(1 âˆ’
Î³Âµ
2
)
tâˆ’1âˆ’u
eu + 2Î³
2
Ï„Ïƒ2
â‰¤ 8LÎ³2C1
X
tâˆ’1
u=0
(1 âˆ’
Î³Âµ
2
)
tâˆ’1âˆ’u
eu + 2Î³
2
Ï„Ïƒ2
.
(157)
Combining (49) and (157) gives us (50):
EkxË†t âˆ’ x
âˆ—
k
2 â‰¤ (1 âˆ’
Î³Âµ
2
)
t+12a0 + (8Î³(C1 + Ï„C2)
Âµ
+ 4Î³
2C1Ï„ )Ïƒ
2
+ (24LÎ³2C1 + 16LÎ³2
Ï„C2 âˆ’ 4Î³)
X
t
u=0
(1 âˆ’
Î³Âµ
2
)
tâˆ’u
eu .
Maximum step size condition on Î³. To prove Theorem 22, we need an inequality of
the following type: EkxË†t âˆ’ xtk
2 â‰¤ (1 âˆ’ Ï)
ta + b. To give this form to Equation (50), we need
61
Leblond, Pedregosa and Lacoste-Julien
to remove all the (eu, u < t) terms from its right-hand side. To safely do so, we need to
enforce that all these terms are negative, hence that:
24LÎ³2C1 + 16LÎ³2
Ï„C2 âˆ’ 4Î³ â‰¤ 0 . (158)
Plugging the values of C1 and C2 we get:
4LÂµÏ„ (1 + âˆš
âˆ†Ï„ )Î³
2 + 6L(1 + 2âˆš
âˆ†Ï„ )Î³ âˆ’ 1 â‰¤ 0 . (159)
As in our Asaga analysis, this reduces to a second-order polynomial sign condition. We
remark again that since Î³ â‰¥ 0, we can upper bound our terms in Î³ and Î³
2
in this polynomial,
which will still give us sufficient conditions for convergence. This means if we define
C3 := 1 + 2âˆš
âˆ†Ï„ , a sufficient condition is:
4LÂµÏ„C3Î³
2 + 6LC3Î³ âˆ’ 1 â‰¤ 0 . (160)
The discriminant of this polynomial is always positive, so Î³ needs to be between its two
roots. The smallest is negative, so the condition is not relevant to our case (where Î³ > 0).
By solving analytically for the positive root Ï†, we get an upper bound condition on Î³ that
can be used for any overlap Ï„ and guarantee convergence. This positive root is:
Ï† =
3
4
q
1 + ÂµÏ„
2LC3
âˆ’ 1)
LC3
. (161)
We simplify it further by using (112):
Ï† â‰¥
3
16LC3
q
1 + Ï„
2ÎºC3
. (162)
This finishes the proof for Theorem 22.
D.3. Proof of Theorem 21 (convergence result for serial Sgd)
In order to analyze Corollary 23, we need to derive the maximum allowable step size for
serial Sgd. Note that Sgd verifies a simpler contraction inequality than Lemma 10. For all
t â‰¥ 0:
at+1 â‰¤ (1 âˆ’ Î³Âµ)at + Î³
2Ekgtk
2 âˆ’ 2Î³et
, (163)
Here, the contraction factor is (1 âˆ’ Î³Âµ) instead of (1 âˆ’
Î³Âµ
2
) because xË†t = xt so there is no
need for a triangle inequality to get back kxt âˆ’ x
âˆ—k
2
from kxË†t âˆ’ x
âˆ—k
2 after we apply our
strong convexity bound in our initial recursive inequality (see Section B.1). Lemma 24 also
holds for serial Sgd. By plugging it into (163), we get:
at+1 â‰¤ (1 âˆ’ Î³Âµ)at + (4LÎ³2 âˆ’ 2Î³)et + 2Î³
2Ïƒ
2
. (164)
We then unroll (164) until t = 0 to get:
at+1 â‰¤ (1 âˆ’ Î³Âµ)
t+1a0 + (4LÎ³2 âˆ’ 2Î³)
X
t
u=0
(1 âˆ’ Î³Âµ)
tâˆ’u
eu + 2
Î³Ïƒ2
Âµ
. (165)
62
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
To get linear convergence up to a ball around the optimum, we need to remove the (eu, 0 â‰¤
u â‰¤ t) terms from the right-hand side of the equation. To safely do this, we need these terms
to be negative, i.e. 4LÎ³2 âˆ’ 2Î³ â‰¤ 0. We can then trivially derive the condition on Î³ to achieve
linear convergence: Î³ â‰¤
1
2L
.
We see that if Î³ = a/L with a â‰¤ 1/2, Sgd converges at a geometric rate of at least:
Ï(a) = a/Îº, up to a ball of radius 2
Î³Ïƒ2
Âµ
around the optimum. Now, to make sure we reach
-accuracy, we need 2Î³Ïƒ2
Âµ â‰¤ , i.e. Î³ â‰¤
Âµ
2Ïƒ2 . All told, in order to get linear convergence to
-accuracy, serial Sgd requires Î³ â‰¤ min  1
2L
,
Âµ
2Ïƒ2
	
.
D.4. Proof of Corollary 23 (speedup regimes for Hogwild)
The convergence rate of both Sgd and Hogwild is directly proportional to the step size.
Thus, in order to make sure Hogwild is linearly faster than Sgd for any reasonable step
size, we need to show that the maximum allowable step size ensuring linear convergence for
Hogwild â€“ given in Theorem 22 â€“ is of the same order as the one for Sgd, O(1/L). Recalling
that Î³ =
a
L
, we get the following sufficient condition: a
âˆ—
(Ï„ ) = O(1).
Given (46), the definition of a
âˆ—
(Ï„ ), we require both:
Ï„
âˆš
âˆ† = O(1) ; s
1 +
1
2Îº
min{
1
âˆš
âˆ†
, Ï„} = O(1). (166)
This gives us the final condition on Ï„ for a linear speedup: Ï„ = O(min{ âˆš
1
âˆ†
, Îº}).
To finish the proof of Corollary 23, we only have to show that under this condition, the
size of the ball is of the same order regardless of the algorithm used.
Using Î³ÂµÏ„ â‰¤ 1 and Ï„ â‰¤ âˆš
1
âˆ†
, we get that (
8Î³(C1+Ï„C2)
Âµ +4Î³
2C1Ï„ )Ïƒ
2 = O(
Î³Ïƒ2
Âµ
), which finishes
the proof of Corollary 23. Note that these two conditions are weaker than Ï„ = O(min{ âˆš
1
âˆ†
, Îº}),
which allows us to get better bounds in case we want to reach -accuracy with Âµ
Ïƒ2  1
2L
.
Appendix E. On the Difficulty of Parallel Lagged Updates
In the implementation presented in Schmidt et al. (2016), the dense part (Î±Â¯) of the updates
is deferred. Instead of writing dense updates, counters cd are kept for each coordinate of the
parameter vector â€“ which represent the last time these variables were updated â€“ as well as
the average gradient Î±Â¯ for each coordinate. Then, whenever a component [xË†]d is needed (in
order to compute a new gradient), we subtract Î³(t âˆ’ cd)[Î±Â¯]d from it and cd is set to t. It
is possible to do this without modifying the algorithm because [Î±Â¯]d only changes when [xË†]d
also does.
In the sequential setting, this results in the same iterations as performing the updates
in a dense fashion, since the coordinates are only stale when they are not used. Note that
at the end of an execution all counters have to be subtracted at once to get the true final
parameter vector (and to bring every cd counter to the final t).
In the parallel setting, several issues arise:
â€¢ two cores might be attempting to correct the lag at the same time. In which case
since updates are done as additions and not replacements (which is necessary to ensure
63
Leblond, Pedregosa and Lacoste-Julien
that there are no overwrites), the lag might be corrected multiple times, i.e. overly
corrected.
â€¢ we would have to read and write atomically to each [xË†d], cd, [Î±Â¯]d triplet, which is highly
impractical.
â€¢ we would need to have an explicit global counter, which we do not in Asaga (our
global counter t being used solely for the proof).
â€¢ in the dense setting, updates happen coordinate by coordinate. So at time t the
number of Î±Â¯ updates a coordinate has received from a fixed past time cd is a random
variable, which may differs from coordinate to coordinate. Whereas in the lagged
implementation, the multiplier is always (t âˆ’ cd) which is a constant (conditional to
cd), which means a potentially different xË†t
.
â€¢ the trick used in Reddi et al. (2015) for asynchronous parallel Svrg does not apply
here because it relies on the fact that the â€œreferenceâ€ gradient term in Svrg is constant
throughout a whole epoch, which is not the case for Saga.
All these points mean both that the implementation of such a scheme in the parallel
setting would be impractical, and that it would actually yields a different algorithm than the
dense version, which would be even harder to analyze. This is confirmed by Pan et al. (2016),
where the authors tried to implement a parallel version of the lagged updates scheme and
had to alter the algorithm to succeed, obtaining an algorithm with suboptimal performance
as a result.
Appendix F. Additional Empirical Details
F.1. Detailed Description of Data Sets
We run our experiments on four data sets. In every case, we run logistic regression for the
purpose of binary classification.
RCV1 (n = 697, 641, d = 47, 236). The first is the Reuters Corpus Volume I (RCV1) data
set (Lewis et al., 2004), an archive of over 800,000 manually categorized newswire stories
made available by Reuters, Ltd. for research purposes. The associated task is a binary text
categorization.
URL (n = 2, 396, 130, d = 3, 231, 961). Our second data set was first introduced in Ma
et al. (2009). Its associated task is a binary malicious URL detection. This data set contains
more than 2 million URLs obtained at random from Yahooâ€™s directory listing (for the â€œbenignâ€
URLs) and from a large Web mail provider (for the â€œmaliciousâ€ URLs). The benign to
malicious ratio is 2. Features include lexical information as well as metadata. This data set
was obtained from the libsvmtools project.39
39. http://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/binary.html
64
Improved Parallel Optimization Analysis for Stochastic Incremental Methods
Covertype (n = 581, 012, d = 54). On our third data set, the associated task is a binary
classification problem (down from 7 classes originally, following the pre-treatment of Collobert
et al., 2002). The features are cartographic variables. Contrarily to the first two, this is a
dense data set.
Realsim (n = 73, 218, d = 20, 958). We only use our fourth data set for non-parallel
experiments and a specific compare-and-swap test. It constitutes of UseNet articles taken
from four discussion groups (simulated auto racing, simulated aviation, real autos, real
aviation).
F.2. Implementation Details
Hardware. All experiments were run on a Dell PowerEdge 920 machine with 4 Intel Xeon
E7-4830v2 processors with 10 2.2GHz cores each and 384GB 1600 MHz RAM.
Software. All algorithms were implemented in the Scala language and the software stack
consisted of a Linux operating system running Scala 2.11.7 and Java 1.6.
We chose this expressive, high level language for our experimentation despite its typical
20x slower performance compared to C because our primary concern was that the code may
easily be reused and extended for research purposes (which is harder to achieve with low
level, heavily optimized C code; especially for error prone parallel computing).
As a result our timed experiments exhibit sub-optimal running times, e.g. compared
to KoneÄnÃ½ and RichtÃ¡rik (2013). This is as we expected. The observed slowdown is
both consistent across data sets (roughly 20x) and with other papers that use Scala code
(e.g. Mania et al. 2017, Ma et al. 2015, Fig. 2).
Despite this slowdown, our experiments show state-of-the-art results in convergence
per number of iterations. Furthermore, the speed-up patterns that we observe for our
implementation of Hogwild and Kromagnon are similar to the ones given in Mania et al.
(2017); Niu et al. (2011); Reddi et al. (2015) (in various languages).
The code we used to run all the experiments is available at http://www.di.ens.fr/
sierra/research/asaga/.
Necessity of compare-and-swap operations. Interestingly, we have found necessary
to use compare-and-swap instructions in the implementation of Asaga. In Figure 7, we
display suboptimality plots using non-thread safe operations and compare-and-swap (CAS)
operations. The non-thread safe version starts faster but then fails to converge beyond a
specific level of suboptimality, while the compare-and-swap version does converges linearly
up to machine precision.
For compare-and-swap instructions we used the AtomicDoubleArray class from the
Google library Guava. This class uses an AtomicLongArray under the hood (from package
java.util.concurrent.atomic in the standard Java library), which does indeed benefit
from lower-level CPU-optimized instructions.
Efficient storage of the Î±i. Storing n gradient may seem like an expensive proposition,
but for linear predictor models, one can actually store a single scalar per gradient (as proposed
in Schmidt et al., 2016), which is what we do in our implementation of Asaga.
65
Leblond, Pedregosa and Lacoste-Julien
Figure 7: Compare and swap in the implementation of Asaga. Suboptimality
as a function of time for Asaga, both using compare-and-swap (CAS) operations and
using standard operations. The graph reveals that CAS is indeed needed in a practical
implementation to ensure convergence to a high precision.
F.3. Biased Update in the Implementation
In the implementation detailed in Algorithm 2, Î±Â¯ is maintained in memory instead of being
recomputed for every iteration. This saves both the cost of reading every data point for each
iteration and of computing Î±Â¯ for each iteration.
However, this removes the unbiasedness guarantee. The problem here is the definition of
the expectation of Î±Ë†i
. Since we are sampling uniformly at random, the average of the Î±Ë†i
is
taken at the precise moment when we read the Î±
t
i
components. Without synchronization,
between two reads to a single coordinate in Î±i and in Î±Â¯, new updates might arrive in Î±Â¯ that
are not yet taken into account in Î±i
. Conversely, writes to a component of Î±i might precede
the corresponding write in Î±Â¯ and induce another source of bias.
In order to alleviate this issue, we can use coordinate-level locks on Î±i and Î±Â¯ to make
sure they are always synchronized. Such low-level locks are quite inexpensive when d is large,
especially when compared to vector-wide locks.
However, as previously noted, experimental results indicate that this fix is not necessary.