When performing regression on a data set with p variables, it is often of interest to go
beyond using main linear effects and include interactions as products between individual
variables. For small-scale problems, these interactions can be computed explicitly but this
leads to a computational complexity of at least O(p
2
) if done naively. This cost can be
prohibitive if p is very large.
We introduce a new randomised algorithm that is able to discover interactions with
high probability and under mild conditions has a runtime that is subquadratic in p. We
show that strong interactions can be discovered in almost linear time, whilst finding weaker
interactions requires O(p
Œ±) operations for 1 < Œ± < 2 depending on their strength. The
underlying idea is to transform interaction search into a closest pair problem which can be
solved efficiently in subquadratic time. The algorithm is called xyz and is implemented in
the language R. We demonstrate its efficiency for application to genome-wide association
studies, where more than 1011 interactions can be screened in under 280 seconds with a
single-core 1.2 GHz CPU.
Keywords: interactions, high-dimensional data, regression, computational tradeoffs,
close pairs
1. Introduction
Given a response vector Y ‚àà R
n and matrix of associated predictors X = (X1, . . . , Xp) ‚àà
R
n√óp
, finding interactions is often of great interest as they may reveal important relationships and improve predictive power. When the number of variables p is large, fitting a model
involving interactions can involve serious computational challenges. The simplest form of
‚àó. Supported by the Isaac Newton Trust Early Career Support Scheme, the Alan Turing Institute under
the EPSRC grant EP/N510129/1 and EPSRC Programme Grant EP/N031938/1
interaction search consists of screening for pairs (j, k) with high inner product between the
outcome of interest Y and the point-wise product Xj ‚ó¶ Xk:
Keep all pairs (j, k) for which YT
(Xj ‚ó¶ Xk)/n > Œ∫. (1)
This search is of complexity O(np2
) in a naive implementation and quickly becomes infeasible for large p. Of course one would typically be interested in maximising (absolute values
of) correlations rather than dot products in (1), an optimisation problem that would be at
least as computationally intensive.
Even more challenging is the task of fitting a linear regression model involving pairwise
interactions:
Yi = ¬µ +
X
p
j=1
XijŒ≤j +
X
p
k=1
X
k‚àí1
j=1
XijXikŒ∏jk + Œµi
. (2)
Here ¬µ ‚àà R is the intercept and Œ≤j and Œ∏jk contain coefficients for main effects and interactions respectively, and Œµi
is random noise.
In this paper, we make several contributions to the problem of searching for interactions
in high-dimensional settings.
(a) We first establish a form of equivalence between (1) and closest-pair problems (Shamos
and Hoey, 1975; Agarwal et al., 1991). Assume for now that all predictors and outcomes
are binary, so Xij , Yi ‚àà {‚àí1, 1} (we will later relax this assumption) and define Z ‚àà
{‚àí1, 1}
n√óp as Zij = YiXij . Then it is straightforward to show that (1) is equivalent to
Keep all pairs (j, k) for which kXj ‚àí Zkk2 < Œ∫0
(3)
for some Œ∫
0
. This connects the search for interactions to literature in computational
geometry on problems of finding closest pairs of points.
(b) We introduce the xyz algorithm to solve (3) based on randomly projecting each of the
columns in X and Z to a one-dimensional space. By exploiting the ability to sort the
resulting 2p points with O(p log(p)) computational cost, we achieve a run time that is
always subquadratic in p and can even reach a linear complexity O(np) when Œ∫ is much
larger than the quantity |YT
(Xj ‚ó¶ Xk)|/n of the bulk of the pairs (j, k). We show that
our approach can be viewed as an example of locality sensitive hashing (Leskovec et al.,
2014) optimised for our specific problem.
(c) We show how any method for solving (1) can be used to fit regression models with
interactions (15) by building it into an algorithm for the Lasso (Tibshirani, 1996). The
use of xyz thus leads to a procedure for applying the Lasso to all main effects and
interactions with computational cost that scales subquadratically in p.
(d) We provide implementations of both the core xyz algorithm and its extension to the
Lasso in the R package xyz, which is available on github (Thanei, 2016) and CRAN.
Our work here is thus related to ‚Äúclosest pairs of points‚Äù algorithms in computational
geometry as well as an extensive literature on modelling interactions in statistics, both of
which we now review.
2
The xyz algorithm for fast interaction search in high-dimensional data
1.1 Related work
A common approach to avoid the quadratic cost in p of searching over all pairs of variables (1) is to restrict the search space: one can first seek a small number of important
main effects, and then only consider interactions involving these discovered main effects.
More specifically, one could fit a main effects Lasso (Tibshirani, 1996) to the data first,
add interactions between selected main effects to the matrix of predictors, and then run
the Lasso once more on the augmented design matrix in order to produce the final model
(see Wu et al. (2010) for example). Tree-based methods such as CART (Breiman et al.,
1984) work in a similar fashion by aiming to identify an important main effect and then
only considering interactions involving this discovered effect.
However it is quite possible for the signal to be such that main effects corresponding
to important interactions are hard to detect. As a concrete example of this phenomenon,
consider the setting where X is generated randomly with all entries independent and having
the uniform distribution on {‚àí1, 1}. Suppose the response is given by Yi = Xi1Xi2, so there
is no noise. Since the distribution Yi
|Xij is the same for all k, main effects regressions would
find it challenging to select variables 1 and 2. Note that by reparametrising the model by
adding one to each entry of X for example, we obtain Yi = (Xi1 ‚àí 1)(Xi2 ‚àí 1) = 1 ‚àí Xi1 ‚àí
Xi2 + Xi1Xi2. The model now respects the so-called strong hierarchical principle (Bien
et al., 2013) that interactions are only present when their main effects are. The hierarchical
principle is useful to impose on any fitted model. However, imposing the principle on
the model does not imply that the interactions will easily be found by searching for main
effects first. The difficulty of the example problem is due to interaction effects masking
main effects: this is a property of the signal E(Yi) and of course no reparametrisation can
make the main effects any easier to find. Approaches that increase the set of interactions
to be considered iteratively can help to tackle this sort of issue in practice (Bickel et al.,
2010; Hao and Zhang, 2014; Friedman, 1991; Shah, 2016) as can those that randomise the
search procedure (Breiman, 2001). However they cannot eliminate the problem of missing
interactions, nor do these approaches offer guarantees of how likely it is that they discover
an interaction.
As alluded to earlier, the pure interaction search problem (3) is related to close pairs
of points problems, and more specifically the close bichromatic pairs problem in computational geometry (Agarwal et al., 1991). Most research in this area has focused on algorithms
that lead to computationally optimal results in the number of points p whilst considering
the dimension n to be constant. This has resulted in algorithms where the scaling of the
computational complexity with n is at least of order 2n
(Shamos and Hoey, 1975). Since
for meaningful statistical results one would typically require n  log(p), these approaches
would not lead to subquadratic complexity. An exception is the so-called lightbulb algorithm (Paturi et al., 1989) which employs a similar strategy for binary data; our work here
shows that this is optimal among random projection-based methods and also that it may
be modified to handle continuous data and also detect interactions in high-dimensional
regression settings.
In the special case where n = p and Zij , Xij ‚àà {‚àí1, 1}, (3) may be seen to be equivalent
to searching for large magnitude entries in the product of square matrices X and Z
T
. This
latter problem is amenable to fast matrix multiplication algorithms, which in theory can
3
Thanei, Meinshausen and Shah
deliver a subquadratic complexity of roughly O(p
2.4
) = O(np1.4
) (Williams, 2012; Davie
and Stothers, 2013; Le Gall, 2012). However the constants hidden in the order notation are
typically very large, and practical implementations are unavailable. The Strassen algorithm
(Strassen, 1969) is the only fast matrix multiplication algorithm used regularly in practice
to the best of our knowledge. With a complexity of roughly O(p
2.8
) = O(np1.8
), the
improvement over a brute force close pairs search is only slight.
The strategy we use is most closely related to locality sensitive hashing (LSH) (Indyk
and Motwani, 1998) which encompasses a family of hashing procedures such that similar
points are mapped to the same bucket with high probability. A close pair search can then
be conducted by searching among pairs mapped to the same bucket. In fact, our approach
for solving (3) can be thought of as an example of LSH optimised for our particular problem
setting. This connection is detailed in Appendix B.
A seemingly attractive alternative to the subsampling-based LSH-strategy we employ is
the method of random projections which is motivated by the theoretical guarantees offered
by the Johnson‚ÄìLindenstrauss Lemma (Achlioptas, 2003). Perhaps surprisingly, we can
show that using random projections instead of our subsampling-based scheme leads to a
quadratic run time for interaction search (see Theorem 1 and section 5.1).
An approach that bears some similarity with our procedure is that of epiq (Arkin et al.,
2014). This works by projecting the data and then searches through a lower dimensional
representation for close pairs. This appears to improve upon a naive brute force empirically
but there are no proven guarantees that the run time improves on the O(np2
) complexity
of a naive search.
The Random Intersection Trees algorithm of Shah and Meinshausen (2014) searches for
potentially deeper interactions in data with both X and Y binary. In certain cases with
strong interactions a complexity close to linear in p is achieved; however it is not clear how
to generalise the approach to continuous data or embed it within a regression procedure.
The idea of Kong et al. (2016) is to first transform the data by forming YÀú = Y ‚ó¶ Y
and XÀú
j = Xj ‚ó¶ Xj for each predictor. Next XÀú
j and YÀú are tested for independence using
the distance correlation test. In certain settings, this can reveal important interactions
with a computational cost linear in p. However, the powers of these tests depend on the
distributions of the transformed variables XÀú
j . For example in the binary case when X ‚àà
{‚àí1, 1}
n√óp
, each transformed variable will be a vector of 1‚Äôs and the independence tests
will be unhelpful. We will see that our proposed approach works particularly well in this
setting.
1.2 Organisation of the paper
In Section 2 we consider the case where both the response Y and the predictors X are
binary. We first demonstrate how (15) may be converted to a form of closest pair of
points problem. We then introduce a general version of the xyz algorithm which solves
this based on random projections. As we show in Section 2.1 there is a particular random
projection distribution that is optimal for our purposes. This leads to our final version
of the xyz algorithm which we present in Section 2.3 along with an analysis of its run
time and probabilistic guarantees that it recovers important interactions. In Section 3 we
extend the xyz algorithm to continuous data. These ideas are then used in Section 4 to
4
The xyz algorithm for fast interaction search in high-dimensional data
demonstrate how the xyz algorithm can be embedded within common algorithms for highdimensional regression (Friedman et al., 2010) allowing high-dimensional regression models
with interactions to be fitted with subquadratic complexity in p. Section 5 contains a variety
of numerical experiments on real and simulated data that complement our theoretical results
and demonstrate the effectiveness of our proposal in practice. We conclude with a brief
discussion in Section 6 and all proofs are collected in the Appendix.
2. The xyz algorithm for binary data
In this section, we present a version of the xyz algorithm applicable in the special case where
both X and Y are binary, so Xij ‚àà {‚àí1, 1} and Yi ‚àà {‚àí1, 1}. We build up to the algorithm
in stages, giving the final version in Section 2.2.
Define Z ‚àà {‚àí1, 1}
n√óp by Zij = YiXij and
Œ≥jk =
1
n
Xn
i=1
1{Yi=XijXik}
. (4)
We call Œ≥jk the interaction strength of the pair (j, k). It is easy to see that the interaction
search problem (1) can be expressed in terms of either the Œ≥jk or the normalised squared
distances. Indeed
2Œ≥jk ‚àí 1 = YT
(Xj ‚ó¶ Xk)/n = Z
T
j Xk/n = 1 ‚àí kZj ‚àí Xkk
2
2/(2n). (5)
Thus those pairs (j, k) with YT
(Xj ‚ó¶ Xk)/n large will have Œ≥jk large, and kZj ‚àí Xkk
2
2
small. This equivalence suggests that to solve (1), we can search for pairs (j, k) of columns
Zj , Xk that are close in `2 distance. At first sight, this new problem would also appear
to involve a search across all pairs, and would thus incur an O(np2
) cost. As mentioned
in the introduction, close pair searches that avoid a quadratic cost in p incur typically an
exponential cost in n. Since n would typically be much larger than log(p), such searches
would be computationally infeasible.
We can however project each of the n-dimensional columns of X and Z to a lower dimensional space and then perform a close pairs search. The Johnson‚ÄìLindenstrauss Lemma,
which states roughly that one can project p points into a space of dimension O(log(p))
and faithfully preserve distances, may appear particularly relevant here. The issue is that
the projected dimension suggested by the Johnson‚ÄìLindenstrauss Lemma is still too large
to allow for an efficient close pairs search. The following observation however gives some
encouragement: if we had Y = Xj ‚ó¶ Xk so Xj = Zk, even a one-dimensional projection
R ‚àà R
n will have |RT
(Xj ‚àíZk)| = 0 = kXj ‚àíZkk2, which implies that a perfect interaction
will have zero distance in the projected space. We will later see that our approach leads to
a linear run time in such a case. Importantly, we are only interested in using a projection
that preserves the distances between the close pairs rather than all pairs, which makes our
problem very different to the setting considered in the Johnson‚ÄìLindenstrauss Lemma.
With this in mind, consider the following general strategy. First project the columns
of X and Z to one-dimensional vectors x and z using a random projection R: x = XT R,
z = Z
T R. Next for some threshold œÑ , collect all pairs (j, k) such that |xj ‚àí zk| ‚â§ œÑ in
the set E. By first sorting x and z, a step requiring only O(p log(p)) computations (see
5
Thanei, Meinshausen and Shah
for example Sedgewick (1998)), this close pairs search can be shown to be very efficient.
Given this set of candidate interactions, we can check for each (j, k) ‚àà E whether we have
Œ≥jk ‚â• Œ≥. The process can be repeated L times with different random projections, and one
would hope that given enough repetitions, any given strong interaction would be present in
one of the candidate sets E1, . . . , EL with high probability. This approach is summarised
in Algorithm 1 which we term the general form of the xyz algorithm. A schematic overview
is given in Figure 1.
Algorithm 1 A general form of the xyz algorithm.
Input: X ‚àà {‚àí1, 1}
n√óp
, Y ‚àà {‚àí1, 1}
n
Parameters: Œæ = (G, L, œÑ, Œ≥). Here G is the joint distribution for the projection vector
R, L is the number of projections, and œÑ and Œ≥ are the thresholds for close pairs and
interactions strength respectively.
Output: I set of strong interactions.
1: Form Z via Zij = YiXij and set I := ‚àÖ.
2: for l ‚àà {1, . . . , L} do
3: Draw random vector R ‚àà R
n with distribution G and project the data using R, to
form
x = XT R and z = Z
T R.
4: Collect in El all pairs (j, k) such that |xj ‚àí zk| ‚â§ œÑ .
5: Add to I those (j, k) ‚àà El
for which Œ≥jk ‚â• Œ≥.
6: end for
There are several parameters that must be selected, and a key choice to be made is the
form of the random projection R. For the joint distribution G of R we consider the following
general class of distributions, which includes both dense and sparse projections. We sample
a random or deterministic number M of indices from the set {1, . . . , n}, i1, . . . , iM, either
with or without replacement. Then, given a distribution F ‚àà F where F is a class of
distributions to be specified later, we form a vector D ‚àà RM with independent components
each distributed according to F. We then define the random projection vector R by
Ri =
X
M
m=1
Dm1{im=i}
, i = 1, . . . , n. (6)
Each configuration of the xyz algorithm is characterised by fixing the following parameters:
(i) G, a distribution for the projection vector R which is determined through (6) by F ‚àà F,
a distribution for the subsample size M and whether sampling is with replacement or
not;
(ii) L ‚àà N, the number of projection steps;
(iii) œÑ ‚â• 0, the close pairs threshold;
(iv) Œ≥ ‚àà (0, 1), the interaction strength threshold.
6
The xyz algorithm for fast interaction search in high-dimensional data
We will denote the collection of all possible parameter levels by Œû. This includes the
following subclasses of interest. Fix F ‚àà F.
(a) Dense projections. Let R ‚àà R
n have independent components distributed according
to F and denote the distribution of R by G. This falls within our general framework
above with M set to n and sampling without replacement. Let
Œûdense := {Œæ ‚àà Œû with joint distribution equal to G}.
(b) Subsampling. Let Gsubsample be the set of distributions for R obtained through (6)
when subsampling with replacement. Let
Œûsubsample := {Œæ ‚àà Œû : joint distribution G ‚àà Gsubsample}.
(c) Minimal subsampling. Let Œûminimal be the set of all parameters in Œûsubsample such
that the close pairs threshold is œÑ = 0 and M takes randomly values in the set {m, m+1}
for some positive integer m.
Œûminimal := {Œæ ‚àà Œûsubsample with œÑ = 0 and M ‚àà {m, m + 1} for some m ‚àà N}.
Note that we have suppressed the dependence of the classes above on the fixed distribution
F ‚àà F for notational simplicity. We define F to be the set of all univariate absolutely
continuous and symmetric distributions with bounded density and finite third moment.
The restriction to continuous distributions in F ensures that Œûminimal is invariant to the
choice of F: when œÑ ‚â° 0, every F ‚àà F with L ‚àà N and the distribution for M fixed yields
the same algorithm. Moreover the set of close pairs in Cl
is simply the set of pairs (j, k)
that have Ximj = Zimk for all m = 1, . . . , M, that is the set of pairs that are equal on the
subsampled rows. We note that the symmetry and boundedness of the densities in F and
finiteness of the third moment are mainly technical conditions necessary for the theoretical
developments in the following section. We will assume without loss of generality that the
second moment is equal to 1. This condition places no additional restriction on Œû since a
different second moment may be absorbed into the choice of œÑ .
Minimal subsampling represents a very small subset of the much larger class of randomised algorithms outlined above. However, Theorem 1 below shows that minimal subsampling is essentially always at least as good as any algorithm from the wider class, which
is perhaps surprising. A beneficial consequence of this result is that we only need to search
for the optimal ways of selecting M and L; the threshold œÑ is fixed at œÑ = 0 and the choice
of the continuous distribution F is inconsequential for minimal subsampling. The choices
we give in Section 2.2 yield a subquadratic run time that approaches linear in p when the
interactions to be discovered are much stronger than the bulk of the remaining interactions.
2.1 Optimality of minimal subsampling
In this section, we compare the run time of the algorithms in Œæ ‚àà Œûdense, Œûsubsample and
Œûminimal that return strong interactions with high probability. Let (j
‚àó
, k‚àó
) be the indices of
7
Thanei, Meinshausen and Shah
a) b) c)
Figure 1: Illustration of the general xyz algorithm. The strongest interaction is the pair
(1, 2) and p = 4. Panel a) illustrates the interaction search among Y and Xj ‚ó¶ Xk, panel b)
shows the closest pair problem after the transformation Zij = XijYi and panel c) depicts
the closest pair problem after the data has been projected. These are the three main steps
in the xyz algorithm.
a strongest interaction pair, that is Œ≥j
‚àók
‚àó = maxj,k‚àà{1,...,p} Œ≥jk. We will consider algorithms
Œæ with Œ≥ set to Œ≥j
‚àók
‚àó . Define the power of Œæ ‚àà Œû as
Power(Œæ) := PŒæ((j
‚àó
, k‚àó
) ‚àà I).
For Œ∑ ‚àà (0, 1), let
Œûdense(Œ∑) = {Œæ ‚àà Œûdense : Power(Œæ) ‚â• Œ∑},
and define Œûsubsample(Œ∑) and Œûminimal(Œ∑) analogously. Note that these classes depend on the
underlying F ‚àà F, which is considered to be fixed, and moreover that we are fixing Œ≥ = Œ≥j
‚àók
‚àó .
We consider an asymptotic regime where we have a sequence of response‚Äìpredictor matrix
pairs (Y(n)
, X(n)
) ‚àà R
n√óR
n√ópn . Write Œ≥
(n)
jk for the corresponding interaction strengths, and
let Œ≥
(n)
1 = maxj,k Œ≥
(n)
jk . Let fŒ≥(n) be the probability mass function corresponding to drawing
an element of Œ≥
(n) uniformly at random. Note that fŒ≥(n) has domain {0, 1/n, 2/n, . . . , 1}.
We make the following assumptions about the sequence of interaction strength matrices
Œ≥
(n)
.
(A1) There exists c0 such that |{(j, k) : Œ≥
(n)
jk = Œ≥
(n)
1
}| ‚â§ c0pn.
(A2) There exists Œ≥l > 0, Œ≥u < 1 such that Œ≥u ‚â• Œ≥
(n)
1 ‚â• Œ≥l
for all n.
(A3) There exists œÅ < 1 such that fŒ≥(n) is non-increasing on [œÅŒ≥
(n)
1
, Œ≥
(n)
1
) ‚à© {0, 1/n, . . . , 1}.
Assumption (A1) is rather weak: typically one would expect the maximal strength interaction to be essentially unique, while (A1) requires that at most of order pn interactions have
maximal strength. (A2) requires the maximal interaction strength to be bounded away
from 0 and 1, which is the region where complexity results for the search of interactions
are of interest. As mentioned earlier, if the maximal interaction strength is 1, it will always
be retained in the close-pair sets Cl
, whilst if its strength is too close to 0, then it is near
impossible to distinguish it from the remaining interactions. (A3) ensures a certain form of
separation between maximal strength interactions and the bulk of the interactions.
8
The xyz algorithm for fast interaction search in high-dimensional data
To aid readability, in the following we suppress the dependence of quantities on n in the
notation. Given X and Y, we may define T(Œæ) as the expected number of computational
operations performed by the algorithm corresponding to Œæ. We have the following result.
Theorem 1 Given F ‚àà F and Œ∑ ‚àà (0, 1), there exists n0 such that for all n ‚â• n0 we have
inf
Œæ‚ààŒûminimal(Œ∑)
T(Œæ) = inf
Œæ‚ààŒûsubsample(Œ∑)
T(Œæ), (7)
inf
Œæ‚ààŒûminimal(Œ∑)
T(Œæ)
np2 ‚Üí 0, (8)
and there exists c > 0 such that
inf
Œæ‚ààŒûdense(Œ∑)
T(Œæ)
np2
> c. (9)
The theorem shows that the optimal run time is achieved when using minimal subsampling. The last point is surprising: setting R ‚àº N (0, I), for example, will not improve the
computational complexity over the brute-force approach and dense Gaussian projections
hence do not reduce the complexity of the search. This is not caused by the larger computational effort involved in computing the dense projections: indeed even if these could
be computed for free this result would remain. Rather the cost stems from the fact that
dense projections have a much lower power for detecting true close pairs in the projected
one-dimensional space.
2.2 The final version of xyz
The optimality properties of minimal subsampling presented in the previous section suggest
the approach set out in Algorithm 2, which we will refer to as the xyz algorithm. Here we
Algorithm 2 Final version of the xyz algorithm.
Input: X ‚àà {‚àí1, 1}
n√óp
, Y ‚àà {‚àí1, 1}
n
, subsample size M, number of projections L,
threshold for interaction strength Œ≥.
Output: I set of strong interactions.
1: Form Z via Zij = YiXij .
2: for l ‚àà {1, . . . , L} do
3: Form R ‚àà R
n as in (6) with distribution F = U[0, 1] and set x = XT R, z = Z
T R.
4: Find all pairs (j, k) such that xj = zk and store these in El
.
5: Add to I those pairs in El
for which Œ≥jk ‚â• Œ≥.
6: end for
are using a simplified version of the minimal subsampling proposal given in the previous
section where we keep M fixed rather than allowing it to be random. The reason is that the
potential additional gain from allowing M to be any one of two consecutive numbers with
certain probabilities is minimal but necessary for Theorem 1 and so the simpler approach
is preferable. We note that the uniform distribution in line 3 may be replaced with any
continuous distribution to yield identical results.
9
Thanei, Meinshausen and Shah
4
6
7 2 3
5
1 9 8
3 2
4
1 5 7 6
9
8
Figure 2: Illustration of an equal pairs search among components of x, z ‚àà R
p when p = 9.
The horizontal locations of blue and green circles numbered j give xj and zj respectively.
Sorting of (x, z) allows traversal of the unique locations. At each of these it is checked
whether points of both colours are present, and if so, the indices are recorded. Here the set
of equal pairs ({3} √ó {4, 6}) ‚à™ ({5} √ó {2}) ‚à™ ({7, 9} √ó {1, 5}) would be returned.
To perform the equal pairs search in line 4, we sort the concatenation (x, z) ‚àà R
2p
to
determine the unique elements of {x1, . . . , xp, z1, . . . , zp}. At each of these locations, we
can check if there are components from both x and z lying there, and if so record their
indices. This procedure, which is illustrated in Figure 2, gives us the set of equal pairs E
in the form of a union of Cartesian products. The computational cost is O(p log(p)). This
complexity is driven by the cost of sorting whilst the recording of indices is linear in p. We
note, however, that looping through the set of equal pairs in order to output a list of close
pairs of the form (j1, k1), . . . ,(j|E|
, k|E|
) would incur an additional cost of the size of E,
though in typical usage we would have |E| = o(p). Readers familiar with locality sensitive
hashing (LSH) can find a short interpretation of equal pairs search as an LSH-family in the
appendix. In the next section, we discuss in detail the impact of minimal subsampling on
the complexity of the xyz algorithm and the discovery probability it attains.
2.3 Computational and statistical properties of xyz
We have the following upper bound on the expected number of computational operations
performed by xyz (Algorithm 2) when the subsample size and number of repetitions are M
and L:
C(M, L) := np
(i)
+ L{M p
(ii)
+ p log(p)
(iii)
+ nEŒæ(|E1|)
(iv)
}. (10)
The terms may be explained as follows: (i) construction of Z; (ii) multiplying M subsampled
rows of X and Z by R ‚àà R
n
; (iii) finding the equal pairs; (iv) checking whether the
interactions exceed the interaction strength threshold Œ≥. Note we have omitted a constant
factor from the upper bound C(M, L). There is a lower bound only differing from (10)
in the equal pairs search term (iii), which is p instead of p log(p). It will be shown that
(iv) is the dominating term and therefore the upper and lower bound are asymptotically
equivalent, implying the bounds are tight.
An interaction with strength Œ≥ is retained in E1 with probability Œ≥M. Hence it is present
in the final set of interactions I with probability
Œ∑(M, L) = 1 ‚àí (1 ‚àí Œ≥
M)
L
. (11)
10
The xyz algorithm for fast interaction search in high-dimensional data
The following result demonstrates how the xyz algorithm can be used to find interactions
whilst incurring only a subquadratic computational cost.
Theorem 2 Let FŒì be the distribution function corresponding to a random draw from the
set of interaction strengths {Œ≥jk}j,k‚àà{1,...,p}
. Given an interaction strength threshold Œ≥, let
1‚àíFŒì(Œ≥) = c1/p. Define Œ≥0 = p
‚àí1/M and let c2 be defined by 1‚àíFŒì(Œ≥0) = c2p
log(Œ≥)/ log(Œ≥0)‚àí1
.
We assume that Œ≥0 < Œ≥. Finally given a discovery threshold Œ∑
0 ‚àà [1/2, 1) let L be the minimal
L
0
such that Œ∑(M, L0
) ‚â• Œ∑
0
. Ignoring constant factors we have
C(M, L) ‚â§ log{1/(1 ‚àí Œ∑
0
)}(1 + c1 + c2)[{1 + 1/ log(Œ≥
‚àí1
0
)} log(p) + n]p
1+log(Œ≥)/ log(Œ≥0)
.
If n  log(p) and Œ≥0 is bounded away from 1 we see that the dominant term in the above
is
cnp1+log(Œ≥)/ log(Œ≥0)
, (12)
where c = log{1/(1 ‚àí Œ∑
0
)}(1 + c1 + c2). Typically we would expect Œ≥ to be such that
|{Œ≥jk : Œ≥jk > Œ≥}| ‚àº p as only the largest interactions would be of interest: thus we may think
of c1 as relatively small. If M is such that Œ≥0 is also larger than the bulk of the interactions,
we would also expect c2 to be small. Indeed, suppose that the proportion of interactions
whose strengths are larger than Œ≥0 is 1 ‚àí FŒì(Œ≥0) = c
0
1
/p. Then c2 = c
0
1
/plog(Œ≥)/ log(Œ≥0) < c0
1
.
As a concrete example, if Œ≥ = 0.9 and M is such that Œ≥0 = 0.55, the exponent in (12)
is around 1.17, which is significantly smaller than the exponent of 2 that a brute-force
approach would incur; see also the examples in Section 5. Note also that when Œ≥ = 1, the
exponent is 1 for all Œ≥0 < 1: if we are only interested in interactions whose strength is as
large as possible, we have a run time that is linear in p.
It is interesting to compare our results here with the run times of approaches based on
fast matrix multiplication. By computing XT Z we may solve the interaction search problem
(1). Naive matrix multiplication would require O(np2
) operations, but there are faster
alternatives when n = p. The fastest known algorithm (Williams, 2012) gives a theoretical
run time of O(np1.37) when n = p. For xyz to achieve such a run time when Œ≥0 = 0.55 for
example, the target interaction strength would have to be Œ≥ ‚â• 0.81: a somewhat moderate
interaction strength. For Œ≥ > 0.81, xyz is strictly better; we also note that fast matrix
multiplication algorithms tend to be unstable or lack a known implementation and are
therefore rarely used in practice. A further advantage is that the xyz algorithm has an
optimal memory usage of O(np).
We also note that whilst Theorem 2 concerns the the discovery of any single interaction
with strength at least Œ≥, the run time required to discover a fixed number interactions with
strength at least Œ≥ would only differ by a multiplicative constant. If we however want a
guarantee of discovering the p strongest pairs the bound in Theorem 2 would no longer
hold.
To minimise the run time in (12), we would like Œ≥0 to be larger than most of the
interactions in order that c2 and hence c be small, yet a smaller Œ≥0 yields a more favourable
exponent. Thus a careful choice of M, on which Œ≥0 depends, is required for xyz to enjoy
good performance. In the following we show that an optimal choice of M exists, and we
discuss how this M may be estimated based on the data.
Clearly if for some pair (M, L), we find another pair (M0
, L0
) with Œ∑(M0
, L0
) > Œ∑(M, L)
but C(M0
, L0
) ‚â§ C(M, L), we should always use (M0
, L0
) rather than (M, L). It turns out
11
Thanei, Meinshausen and Shah
that there is in fact an optimal choice of M such that the parameter choice is not dominated
by any others in this fashion. Define
M‚àó = arg min
M‚ààN

‚àí
1
log(1 ‚àí Œ≥M)

M p + p log(p) + n
X
j,k
Œ≥
M
jk , (13)
where it is implicitly assumed that the minimiser is unique. This will always be the case
except for peculiar values of Œ≥.
Proposition 3 Let L ‚àà N. If (M0
, L0
) ‚àà N
2 has Œ∑(M0
, L0
) ‚â• Œ∑(M‚àó
, L), then also C(M0
, L0
) ‚â•
C(M‚àó
, L) with the final inequality being strict if M0 6= M‚àó and M‚àó
is a unique minimiser.
Thus there is a unique Pareto optimal M. Although the definition of M‚àó
involves the
moments of FŒì, this can be estimated by sampling from {Œ≥jk}. We can then numerically
optimise a plugin version of the objective to arrive at an approximately optimal M.
3. Interaction search on continuous data
In the previous section we demonstrated how the xyz algorithm can be used to efficiently
solve the simplest form of interaction search (1) when both X and Y are binary. In this
section we show how small modifications to the basic algorithm can allow it to do the same
when Y is continuous, and also when X is continuous. We discuss the regression setting in
Section 4.
3.1 Continuous Y and binary X
We begin by considering the setting where X ‚àà {‚àí1, 1}
n√óp
, but where we now allow realvalued Y ‚àà R
n
. Without loss of generality, we will assume kYk1 = 1. The approach we
take is motivated by the observation that the inner product YT
(Xj ‚ó¶Xk) can be interpreted
as a weighted inner product of Xj ‚ó¶ Xk with the sign pattern of Y, using weights wi = |Yi
|.
With this in mind, we modify xyz in the following way. We set Z to be Zij = sgn(Yi)Xij .
Let i1, . . . , iM ‚àà {1, . . . , n} be i.i.d. such that P(is = i) = wi
. Forming the projection vector
R using (6), we then find the probability of (j, k) being in the equal pairs set may be
computed as follows.
{P(RT Xj = RT Zk)}
1/M = P (Xisj = sgn(Yis
)Xisk for all s = 1, . . . , M)
= P(Xi1j = sgn(Yi1
)Xi1k) as the is are i.i.d.
=
Xn
i=1
P(Xi1j = sgn(Yi1
)Xi1k|i1 = i)P(i1 = i)
=
Xn
i=1
|Yi
|1{Xij=sgn(Yi)Xik}
=
X
i:sgn(Yi)=XijXik
YiXijXik =: ÀúŒ≥jk,
where P here is with respect to the randomness of R (and, equivalently, the random indices
i1, . . . , iM) with Y and X considered fixed. The calculation above shows that the run time
12
The xyz algorithm for fast interaction search in high-dimensional data
bound of Theorem 2 continues to hold in the setting with continuous Y provided we replace
the interaction strengths Œ≥jk with their continuous analogues ÀúŒ≥jk.
As a simple example, consider the model
Yi = Xi1Xi2 + Œµi
,
with Œµi ‚àº N (0, œÉ2
) and X generated randomly having each entry drawn independently from
{‚àí1, 1} each with probability 1/2. Then for a non-interacting pair j 6= 1, 2 or k 6= 1, 2, we
have ÀúŒ≥jk ‚âà 0.5. For the pair (1, 2) we calculate an interaction strength of
Œ≥Àú12 = P(sgn(Yi1
) = Xi11Xi12) = P(sgn(Xi11Xi12 + Œµi) = Xi11Xi12)
= P(|Œµi
| < 1) + 1
2
P(|Œµi
| > 1) = 1
2
(1 + P(|Œµi
| < 1)).
Note that here that probability is over the randomness in the noise Œµi
. A quick simulation
gives the following table:
œÉ
2 0.1 0.25 0.5 1 2 5
Œ≥Àú12 0.99 0.98 0.92 0.84 0.76 0.67
Using Theorem 2 and the above table we can estimate the computational complexity needed
to discover the pair (1, 2) given a value of œÉ
2
.
3.2 Continuous Y and continuous X
The previous section demonstrated how resampling with non-uniform weights transforms a
setup with continuous Y into one with binary response. If both X and Y are continuous, we
continue to use the previous strategy to deal with the continuous response. For the matrix
X with continuous predictor values we cannot use weighted resampling as the weights
would depend on the interaction pair of interest. In the following we examine the effects of
transformations of X to a binary data matrix XÀú . To allow for randomized mappings, we
define the transformations via a function g : R 7‚Üí [0, 1] as
P(XÀú
ij = 1) = g(Xij ) and 1 ‚àí P(XÀú
ij = ‚àí1) = 1 ‚àí g(Xij ),
where the transformation is always applied independently for each entry of the predictor
matrix and for each subsample.
The following gives the probability of Yi agreeing in sign with XÀú
ijXÀú
ik when i is sampled
with probability proportional to |Yi
|.
Proposition 4 Given the transform P(XÀú
ij = 1) = g(Xij ) and sampling an index is according to P(is = i) = Yi/kYk1, then the probability of a match is
P(sgn(Yis
) = XÀú
isjXÀú
isk) = 1
2
+
1
2kYk1
Xn
i=1
Yi(1 ‚àí 2g(Xij ))(1 ‚àí 2g(Xik)). (14)
Thus we may define a continuous analogue of the interaction strength Œ≥jk based on the
transform given by g as
Œ≥
g
jk =
1
2
+
1
2kYk1
Xn
i=1
Yi(1 ‚àí 2g(Xij ))(1 ‚àí 2g(Xik)).
13
Thanei, Meinshausen and Shah
These quantities may be substituted into Theorem 2 to yield the following upper bound on
expected run time when using xyz on transformed data.
Corollary 5 Let FŒìg be the distribution function corresponding to a random draw from the
set of interaction strengths {Œ≥
g
jk}j,k‚àà{1,...,p}
. Given an interaction strength threshold Œ≥, let
1‚àíFŒìg (Œ≥) = c1/p. Define Œ≥0 = p
‚àí1/M and let c2 be defined by 1‚àíFŒì(Œ≥0) = c2p
log(Œ≥)/ log(Œ≥0)‚àí1
.
We assume that Œ≥0 < Œ≥. Finally given a discovery threshold Œ∑
0 ‚àà [1/2, 1) let L be the minimal
L
0
such that Œ∑(M, L0
) ‚â• Œ∑
0
. Ignoring constant factors we have
C(M, L) ‚â§ log{1/(1 ‚àí Œ∑
0
)}(1 + c1 + c2)[{1 + 1/ log(Œ≥
‚àí1
0
)} log(p) + n]p
1+log(Œ≥)/ log(Œ≥0)
.
The expected computational costs depends critically on the distribution of the interaction
strengths FŒìg . To gain a better understanding of what impact different transformations
have on this distribution and subsequently on run time we will study the following simple
model for (Y, X) ‚àà R
n √ó R
n√óp
:
Yi = Xij‚àóXik‚àó + Œµi
, i = 1, . . . , n, (15)
where the Œµi are independent and have identical sub-exponential distributions symmetric
about 0 and the rows of X are i.i.d. We now introduce two practically useful choices of g
and study their properties in the context of model (15).
The unbiased transform
A natural choice for the transform g is one that satisfies the unbiasedness requirement:
E(XÀú
ij ) = Xij . (16)
It turns out that this requirement uniquely defines the transform, which we refer to as the
unbiased transform.
Proposition 6 Let Xij ‚àà [‚àí1, 1]. If its transformed version XÀú
ij satisfies (16), then g takes
the form
P(XÀú
ij = 1) = g(Xij ) = Xij + 1
2
.
Furthermore the interaction strength in (14) is given by
P(sgn(Yis
) = XÀú
isjXÀú
isk) = Œ≥
g
jk =
1
2
+
1
2kYk1
Xn
i=1
YiXijXik.
Proposition 6 shows that Œ≥
g
jk is a monotone function of the inner product Pn
i=1 YiXijXik.
We remark that if the entries of X do not lie in [‚àí1, 1], we may divide each entry in
the ith row by ŒΩi
:= maxj |Xij |, and multiply Yi by ŒΩ
2
i
, for each i. Proposition 6 will
then hold for the scaled versions of Y and X. In order to describe the performance of
the unbiased transform when applied to data generated by the model (15), we define the
following quantities:
E(|Xij‚àóXik‚àó |) = m1, E(X2
ij‚àóX2
ik‚àó ) = m2 and E(|Œµi
|) = mŒµ.
We consider an asymptotic regime where p = pn may diverge as n tends to infinity, though
we suppress this in the notation. We introduce the following assumptions.
14
The xyz algorithm for fast interaction search in high-dimensional data
(B1) m2(ru‚àí1) ‚â§ E(Xij‚àóXik‚àóXijXik) ‚â§ m2(1‚àíru), for ru ‚àà (0, 1) and ‚àÄ j, k ‚àà {1, . . . , p}
2
.
(B2) The noise level satisfies the bound
1
1 ‚àí ru
> 1 +
m
m1
.
(B3) Let p be such that be such that
log(n) log(p)
n
n‚Üí‚àû‚Üí 0.
(B1) ensures non-interactions are not too strongly correlated to the actual interaction pair
(j
‚àó
, k‚àó
). Note that (B3) allows for high-dimensional settings with p  n.
Theorem 7 Assume all entries of X have mean zero and lie in [‚àí1, 1] almost surely.
Further assume (B1)‚Äì(B3) hold. When M and L are as in Corollary 5 and the unbiased
transform is used, we have
C(M, L) = oP

np
1+Œ¥+
log(1/2+m2/2(m1+mŒµ))
log(1/2+m2(1‚àíru)/2m1)

for any Œ¥ > 0. Here P is with respect to the randomness in X and Œµ.
Though the run time above can often improve significantly on the worst-case quadratic run
time, observe that unlike in the binary case, if there is no noise and Yi = Xij‚àóXik‚àó , we do not
necessarily have a run time close to linear in p. For example, when Xij
iid‚àº Uniform(‚àí1, 1),
the interaction strength of the true interaction can be shown to equal to
Œ≥
g
j
‚àók
‚àó =
1
2
+
Pn
i=1 YiXij‚àóXik‚àó
2kYk1
=
1
2
+
kYk
2
2
2kYk1
n‚Üí‚àû=
13
18
.
Substituting this into the run time given by Theorem 2, this would result in an expected
complexity of roughly O(np1.47); this is still substantially smaller than a quadratic run time,
but raises the question as to whether such a loss in speed is avoidable.
Additionally, if X has several outlying entries, normalising the design matrix by scaling
by the row-wise maximums can shrink Œ≥
g
j
‚àók
‚àó towards 1/2. To limit the impact of this
normalisation, we can first cap the entries of X so their absolute value is bounded by
some c > 0. Though the resulting interaction strength will not have the form given in
Proposition 6, it may better discriminate between interactions of interest and noise.
Capping with c = 1 is closely related to applying the sign transform, which we study
next.
The sign transform
We now consider the sign transform given by XÀú
ij = sgn(Xij ); if there are zero cases we use
a coin toss to map them to {‚àí1, 1}. For the sign transform we have g(Xij ) = 2 sgn(Xij )‚àí1
and so the interaction strength is given as:
P(sgn(Yis
) = XÀú
isjXÀú
isk) = Œ≥
g
jk =
1
2
+
1
2kYk1
Xn
i=1
Yisgn(Xij )sgn(Xik).
15
Thanei, Meinshausen and Shah
The sign transform recovers the close to linear run time achieved in the binary case when a
interaction is perfect as now if Yi = Xij‚àóXik‚àó , we have Œ≥
g
j
‚àók
‚àó = 1. Also the sign transform is
not adversely affected by the presence of outlying entries in X, and for our theory we can
relax the assumption that the entries of X are in [‚àí1, 1] to here only requiring that they
have a subexponential distribution. To facilitate comparison with the unbiased transform,
we impose assumptions analogous to (B1)‚Äì(B3):
(C1) rs/2 ‚â§ P(Xij < 0|Xik, Xij‚àó , Xik‚àó ) ‚â§ 1 ‚àí rs/2, for rs ‚àà (0, 1) and ‚àÄ j, k ‚àà {1, ..., p}
2
.
(C2) The noise level satisfies
1
1 ‚àí rs
> 1 +
m
m1
.
(C3) Let p be such that
log(p)
5
n
n‚Üí‚àû‚Üí 0.
Theorem 8 Suppose that each entry of X has a mean-zero subexponential distribution.
Further assume (C1)‚Äì(C3). When M and L are as in Corollary 5 and the sign transform
is used, we have
C(M, L) = oP

np
1+Œ¥+
log(1/2+m1/2(m1+mŒµ))
log(1‚àírs)

for any Œ¥ > 0. Here P is with respect to the randomness in X and Œµ.
Both transforms yield a run time of the form oP(npŒ±). Comparing the exponents Œ± we have:
unbiased transform:
Œ±u = 1 +
log(1/2 + m2/2(m1 + mŒµ))
log(1/2 + m2(1 ‚àí ru)/2m1)
sign transform:
Œ±s = 1 +
log(1/2 + m1/2(m1 + mŒµ))
log(1/2 + (1 ‚àí rs)/2) .
For bounded data X ‚àà [‚àí1, 1]n√óp and when mŒµ  m1, we have m1/2(m1 + mŒµ) ‚âà 1/2 so
that Œ±s = 1 whereas Œ±u > 1. Hence in case of a strong signal the sign transform can give a
smaller run time than the unbiased transform.
4. Application to Lasso regression
Thus far we have only considered the simple version of the interaction search problem (1)
involving finding pairs of variables whose interaction has a large dot product with Y. In
this section we show how any solution to this, and in particular the xyz algorithm, may be
used to fit the Lasso (Tibshirani, 1996) to all main effects and pairwise interactions in an
efficient fashion.
Given a response Y ‚àà R
n and a matrix of predictors X ‚àà R
n√óp
, let W ‚àà R
n√óp(p+1)/2
be the matrix of interactions defined by
W = (X1 ‚ó¶ X1, X1 ‚ó¶ X2, ¬∑ ¬∑ ¬∑ , X1 ‚ó¶ Xp, X2 ‚ó¶ X2, X2 ‚ó¶ X3, ¬∑ ¬∑ ¬∑ , Xp ‚ó¶ Xp).
16
The xyz algorithm for fast interaction search in high-dimensional data
We will assume that Y and the columns of X have been centred. Note that the centring
of X means the W implicitly contains main effects terms. Let WÀú be a version of W with
centred columns. Consider the Lasso objective function
(Œ≤ÀÜ, Œ∏ÀÜ) = argmin
Œ≤‚ààRp,Œ∏‚ààRp(p+1)/2

1
2n
kY ‚àí XŒ≤ ‚àí WÀú Œ∏k
2
2 + Œª(kŒ≤k1 + kŒ∏k1)

. (17)
Note that since the entire design matrix in the above is column-centred, any intercept term
would always be zero.
In order to avoid a cost of O(np2
) it is necessary to avoid explicitly computing W. To
describe our approach, we first review in Algorithm 3 the active set strategy employed by
several of the fastest Lasso solvers such as glmnet (Friedman et al., 2010). We use the
notation that for a matrix M and a set of column indices H, MH is the submatrix of M
formed from those columns indexed by H. Similarly for a vector v and component indices
H, vH is the subvector of v formed from the components of v indexed by H.
Algorithm 3 Active set strategy for Lasso computation
Input: X, Y and grid of Œª values Œª1 > ¬∑ ¬∑ ¬∑ > ŒªL.
Output: Lasso solutions Œ≤ÀÜ
Œªl
and Œ∏ÀÜ
Œªl
at each Œª on the grid.
1: for l ‚àà {1, . . . , L} do
2: If l = 1 set A, B = ‚àÖ; otherwise set A = {k : Œ≤ÀÜ
Œªl‚àí1,k 6= 0} and B = {k :
ÀÜŒ∏Œªl‚àí1,k 6= 0}.
3: Compute the Lasso solution (Œ≤ÀÜ, Œ∏ÀÜ) when Œª = Œªl under the additional constraint that
Œ≤ÀÜAc = 0 and Œ∏ÀÜBc = 0.
4: Let U = {k : |XT
k
(Y ‚àí XAŒ≤ÀÜA ‚àí WÀú BŒ∏ÀÜB)|/n > Œªl} and V = {k : |WÀú T
k
(Y ‚àí XAŒ≤ÀÜA ‚àí
WÀú BŒ∏ÀÜB)|/n > Œªl} be the set of coordinates that violate the KKT conditions when (Œ≤ÀÜ, Œ∏ÀÜ)
is taken as a candidate solution.
5: If U and V are empty, we set Œ≤ÀÜ
Œªl = Œ≤ÀÜ, Œ∏ÀÜ
Œªl = Œ∏ÀÜ. Else we update A = A ‚à™ U and
B = B ‚à™ V and return to line 3.
6: end for
As the sets A and B would be small, computation of the Lasso solution in line 3 is
not too expensive. Instead line 4, which performs a check of the Karush‚ÄìKuhn‚ÄìTucker
(KKT) conditions involving dot products of all interaction terms and the residuals, is the
computational bottleneck: a naive approach would incur a cost of O(np2
) at this stage.
There is however a clear similarity between the KKT conditions check for the interactions and the simple interaction search problem (1). Indeed the computation of V , the
set containing all interactions that violate the KKT conditions, may be expressed in the
following way:
Keep all pairs (j, k) for which |(Y ‚àí XAŒ≤ÀÜA ‚àí WÀú BŒ∏ÀÜB)
T
(Xj ‚ó¶ Xk)/n| > Œªl
. (18)
Note that since Y ‚àí XAŒ≤ÀÜA ‚àí WÀú BŒ∏ÀÜB is necessarily centered, there is no need to center
the interactions in (18). In order to solve (18) we can use the xyz algorithm, setting Œ≥ in
Algorithm 2 to Œªl and Y to each of ¬±(Y ‚àí XAŒ≤ÀÜA ‚àí WÀú BŒ∏ÀÜB) in turn.
Precisely the same strategy of performing KKT condition checks using xyz can be used
to accelerate computation for interaction modeling for a variety of variants of the Lasso such
17
Thanei, Meinshausen and Shah
as the elastic net (Zou and Hastie, 2005) and `1-penalised generalised linear models. Note
also that it is straightforward to use a different scaling for the penalty on the interaction
coefficients in (17), which may be helpful in practice.
5. Experiments
To test the algorithm and theory developed in the previous sections, we run a sequence of
experiments on real and simulated data.
5.1 Comparison of minimal subsampling and dense projections
One of the surprising outcomes of our theoretical analysis is extent of the suboptimality of
Gaussian random projections, which whilst they suffice for the conclusion of the Johnson‚Äì
Lindenstrauss Lemma, are not well-suited for our purposes here (see Theorem 1). We
can explicitly compute the probability of retaining an interaction of strength Œ≥ in E1 for
both dense Gaussian projections ŒæGauss and minimal subsampling Œæminimal given an equal
computational budget. We consider various values of p ranging from 10 up to 106 and we
fix n = 1000. We set L = 1 and select other parameters of the algorithms to ensure the
average size of E1 is equal to p in the setting when all interaction strengths are equal to
0.5. Specifically we make the following choices.
‚Ä¢ ŒæGauss: the close pairs threshold œÑ ‚â• 0 is the 1/p‚Äìquantile of the distribution of |W|
when W ‚àº N(0, 0.5n).
‚Ä¢ Œæminimal: the subsample size M = dlog(1/p)/ log(0.5)e.
We then plot the probability Œ∑ of discovering an interaction of strength Œ≥, as a function of
Œ≥ for different values of p (Figure 3). For Œæminimal, Œ∑ is given in equation (11). For ŒæGauss,
Œ∑ is the 1/p‚Äìquantile of the distribution of |W| when W ‚àº N(0, n(1 ‚àí Œ≥)).
5.2 Scaling
In this experiment we test how the xyz algorithm scales on a simple test example as we
increase the dimension p. We generate data X ‚àà R
n√óp with each entry sampled independently uniformly from {‚àí1, 1}. We do this for different values of p, ranging from 1000
to 30 000: this way for the largest p considered there are more than 400 million possible
interactions. Then for each X we construct response vectors Y such that only the pair
(1, 2) is a strong interaction with an interaction strength taking values in {0.7, 0.8, 0.9}.
Through this construction, if n is large enough, all the pairs except (1, 2) will have an interaction strength around 0.5, and very few will have one above 0.55. We thus set M so
that Œ≥0 = p
‚àí1/M ‚âà 0.55. Since the only strong interaction is (1, 2), we set Œ≥ = Œ≥12 Each
data set configuration determined by p and Œ≥12 is simulated 300 times and we measure the
time it takes xyz to find the pair (1, 2). In Figure 3 we plot the average run time against
the dimension p with the different choices for Œ≥12 highlighted in different colours.
Theorem 2 indicates that the run time should be of the order np1+log(Œ≥)/ log(Œ≥0)
. We see
that the experimental results here are in close agreement with this prediction.
18
The xyz algorithm for fast interaction search in high-dimensional data
interaction strength Œ≥
discovery probability
Œ∑
0.5 0.6 0.7 0.8 0.9 1
1e‚àí6 1e‚àí4 1e‚àí2
dimension p
time in seconds
‚óè
‚óè
‚óè
‚óè
‚óè
‚óè
‚óè
1e3 5e3 1e4 3e4
0.1 1 10 50
Figure 3: Left panel: Discovery probability as a function of Œ≥ for different values of
p ‚àà {101
, . . . , 106} (colours decreasing in p from yellow p = 106
to green p = 10). The lower
lines correspond to the dense Gaussian projections, the upper lines to minimal subsampling.
It can be seen that the discovery probability for minimal subsampling is much higher (up
to factor 104
) than for Gaussian projections. Right panel: Time to discover the interaction
pair as a function of the data set dimension p. Lines correspond to the theoretical prediction
(with the intercept chosen based on the data points) and symbols give the actual measured
run time. Colour coding: green Œ≥ = 0.7, orange Œ≥ = 0.8 and purple Œ≥ = 0.9.
5.3 Run on SNP data
In the next experiment we compare the performance of xyz to its closest competitors on a
real data set. For each method we measure the time it takes to discover strong interactions.
We consider the LURIC data set (Winkelmann et al., 2001), which contains data of patients
that were hospitalised for coronary angiography. We use a preprocessed version of the data
set that is made up of n = 859 observations and 687 253 predictors. The data set is binary.
The response Y indicates coronary disease (1 corresponding to affected and ‚àí1 healthy) and
X contains Single Nucleotide Polymorphisms (SNPs) which are variations of base-pairs on
DNA. The response vector Y is strongly unbalanced: there are 681 affected cases (Yi = 1)
and 178 unaffected (Yi = ‚àí1).
To get a contrast of the performance of xyz we compare it to epiq (Arkin et al., 2014),
another method for fast high-dimensional interaction search. In order for epiq to detect
interactions it needs to assume the model
Yi = Œ±j
‚àók
‚àóXij‚àóXik‚àó + Œµi
, (19)
where Œµi ‚àº N (0, œÉ2
). It then searches for interactions by considering the test statistics
Tjk = (RT
(Y ‚ó¶ Xj ))(RT Xk)
where R ‚àº N (0, I). These are used to try to find the pair (j
‚àó
, k‚àó
), which is assumed to be the
pair for which the inner product YT
(Xj ‚ó¶ Xk) is maximal. It is an easy calculation to show
19
Thanei, Meinshausen and Shah
that E(Tjk) = YT
(Xj ‚ó¶ Xk). To maximise the inner product on the right, epiq considers
pairs where T
2
jk is large by looking at pairs where both (RT
(Y ‚ó¶ Xj ))2 and (RT Xk)
2 are
large. While the approach of epiq is somewhat related to xyz, there are no bounds available
for the time it takes to find strong interactions.
We also compare both methods to a naive approach where we subsample a fixed number
of interactions uniformly at random, and retain the strongest one. We refer to this as naive
search.
At fixed time intervals we check for the strongest interaction found so far with all
three methods. We plot the interaction strength as a function of the computational time
(Figure 4). All three methods eventually discover interactions of very similar strength and
it would be a hasty judgement to say whether one significantly outperforms the others. xyz
nevertheless discovers the strongest interactions on average for a fixed run time compared
to the other two approaches. To get a clearer picture we run two additional experiments
on a slight modification of the LURIC data set. We implant artificial interactions where we
set the strength to Œ≥12 = 0.8 and another example with Œ≥12 = 0.9. In these two experiments
xyz clearly outperforms all other methods considered (Figure 4; panels 3 and 4). Besides
xyz being the fastest at interaction search, it also offers a probabilistic guarantee that there
are no strong interactions left in the data. This guarantee comes out of Theorem 2. To run
xyz we have to calculate the optimal subsample size (13) for use of minimal subsampling:
M‚àó = arg min
M‚ààN

‚àí
1
log(1 ‚àí Œ≥M)

M p + p log(p) + n
X
j,k
Œ≥
M
jk  = 21.
The sum in this optimisation can be approximated by uniformly sampling over pairs. Assume we have an interaction pair (j
‚àó
, k‚àó
) with interaction strength Œ≥j
‚àók
‚àó = 0.85 and say
the rest of the pairs (j, k) have an interaction strength of no more than Œ≥jk ‚â§ 0.55. The
probability that we discover this pair in one run (L = 1) of the xyz algorithm is Œ≥
21
j
‚àók
‚àó .
Therefore the probability of missing this pair after L = 100 runs is given by
(1 ‚àí Œ≥
21
j
‚àók
‚àó )
L ‚âà 0.03.
Note that the number of possible interactions is p(p ‚àí 1)/2 ‚âà 1011. The whole search took
280 seconds. Naive search offers a similar guarantee, however it is extremely weak. The
probability of not discovering the pair after drawing pL samples (with L = 100) is bounded
by [1 ‚àí 2/{p(p ‚àí 1)}]
Lp ‚âà 0.999. If we consider the run time guarantee from Theorem 2,
the dominating term in the complexity of xyz in terms of p is
p
1+ log(0.85)
log(0.55) ‚âà p
1.27
.
This may be compared to the expected run time of order p
2
for naive search, which means
that xyz is about 30 000 times faster than naive search (when p = 687 253). In the empirical
comparison this factor is around 20 000.
20
The xyz algorithm for fast interaction search in high-dimensional data
interaction strength
0.35 0.45 0.55
0 2000 4000 6000
‚óè ‚óè ‚óè ‚óè ‚óè ‚óè
time
interaction strength
‚óè ‚óè ‚óè ‚óè ‚óè ‚óè ‚óè ‚óè ‚óè ‚óè ‚óè ‚óè
0.5 0.6 0.7 0.8 0.9 1
10 50 200
‚óè ‚óè ‚óè
‚óè
‚óè
‚óè
time
‚óè ‚óè ‚óè ‚óè ‚óè ‚óè
‚óè ‚óè ‚óè ‚óè ‚óè ‚óè
10 50 200
‚óè
‚óè ‚óè ‚óè ‚óè ‚óè
time
‚óè ‚óè ‚óè ‚óè ‚óè ‚óè
‚óè ‚óè ‚óè ‚óè ‚óè ‚óè
10 50 200
Figure 4: Left: Histogram of interaction strength of 106
interaction pairs, sampled at
random from the more than 1011 existing pairs from the LURIC data set. The right three
panels show the interaction strength of the discovered pairs as a function of the computation
time for xyz (green), epiq (orange) and naive search (purple). The first panel gives results
on the the original LURIC data set, and the second and third (rightmost) panels show
results with an implanted interaction with strengths Œ≥12 = 0.8 and Œ≥12 = 0.95 respectively.
It can be clearly seen that xyz outperforms its competitors by a large margin.
5.4 Regression on artificial data
In this section we demonstrate the capabilities of xyz in interaction search for continuous
data as explained in Section 3. We simulate two different models of the form (15):
Yi = ¬µ +
X
p
j=1
XijŒ≤j +
X
p
k=1
X
k‚àí1
j=1
XijXikŒ∏jk + Œµi
.
We consider three settings. For all three settings we have n = 1000. We let p ‚àà {250, 500, 750,
1000}. Each row of X is generated i.i.d. as N (0, Œ£). The magnitudes of both the main
and interaction effects are chosen uniformly from the interval [2, 6] (20 main effects and 10
interaction effects) and we set Œµi ‚àº N (0, 1). The three settings we consider are as follows.
1. Œ£ = I ‚àà R
p√óp
, we generate a hierarchical model: Œ∏jk 6= 0 ‚áí Œ≤j 6= 0 and Œ≤k 6= 0. We
first sample the main effects and then pick interaction effects uniformly from the pairs
of main effects.
2. Œ£ = I ‚àà R
p√óp
, we generate a strictly non-hierarchical model: Œ∏jk 6= 0 ‚áí Œ≤j = 0 and
Œ≤k = 0. We first sample the main effects and then pick interaction effects uniformly
from all pairs excluding main effects as coordinates.
3. We repeat the setting 2 with a data set that contains strong correlations. We create
a dependence structure in X, by first generating a DAG with on average 10 edges per
node. Each node is sampled so that it is a linear function of its parents plus some
independent centred Gaussian noise, with a variance of 10% the variance coming from
the direct parents. The resulting correlation matrix then unveils for each variable Xj
21
Thanei, Meinshausen and Shah
a substantial number of variables strongly correlated to Xj (There is usually around
10 variables with a correlation of above 0.9). Such a correlation structure will make
it easier to detect pairs of variables whose product can serve as strong predictor of Y,
even though it has not been included in the construction of Y.
We run three different procedures to estimate the main and interaction effects.
‚Ä¢ Two-stage Lasso: We fit the Lasso to the data, and then run the Lasso once more
on an augmented design matrix containing interactions between all selected main
effects. Complexity analysis of the Least Angle Regression (LARS) algorithm (Efron
et al., 2004) suggests the computational cost would be O(np min(n, p)), making the
procedure very efficient. However, as the results show, it struggles in situations such
as that given by model 2, where a main effects regression will fail to select variables
involved in strong interactions.
‚Ä¢ Lasso with all interactions: Building the full interaction matrix and computing
the standard Lasso on this augmented data matrix. Analysis of the LARS algorithm
would suggest the computational complexity would be in the order O(np2 min(n, p2
)).
Nevertheless, for small p, this approach is feasible.
‚Ä¢ xyz: This is Algorithm 3; we set the parameter L to be ‚àöp in order to target the
strong interactions.
The experiment (seen in Figure 5) shows that xyz enjoys the favourable properties of both
its competitors: it is as fast as the two-stage Lasso that gives an almost linear run time in p,
and it is about as accurate as the estimator calculated from screening all pairs (brute-force).
0.0 0.2 0.4 0.6 0.8 1.0
normalized prediction error
0.01 0.1 1 10 100
‚óè‚óè
‚óè‚óè
‚óè
‚óè
‚óè ‚óè ‚óè
‚óè
‚óè
‚óè
‚óè
‚óè‚óè
‚óè
‚óè
‚óè‚óè
time
0.01 0.1 1 10 100
‚óè‚óè
‚óè ‚óè
‚óè
‚óè
‚óè
‚óè
‚óè
‚óè
‚óè
‚óè
‚óè‚óè ‚óè
‚óè
‚óè‚óè
‚óè
‚óè
time
0.01 0.1 1 10 100
‚óè
‚óè
‚óè‚óè
‚óè
‚óè ‚óè
‚óè
‚óè
‚óè
‚óè
‚óè
‚óè‚óè ‚óè
‚óè
‚óè‚óè
‚óè
‚óè
time
Figure 5: Normalised `
2
2 prediction error as a function of time in seconds. Triangle: Twostage Lasso. Circle: xyz -regression. Cross: Brute-force. The different colours correspond
to different values of p: green p = 250, orange p = 500, purple p = 750 and pink p = 1000.
The left panel shows the results on setting 1, center panel shows setting 2 and right panel
setting 3.
22
The xyz algorithm for fast interaction search in high-dimensional data
5.5 Regression on real data
Here we run xyz regression on continuous real data sets where the ground truth is unknown.
On each data set we pick at random p = 2000 variables and run xyz and the Lasso implemented in glmnet with all interactions included. We subsample an increasing number of
variables to vary the difficulty of the regression problem. For each sample we measure the
run time and the normalized out of sample squared `
2
2
error:
kYtest ‚àí XtestŒ≤ÀÜ ‚àí WÀú
testŒ∏ÀÜk
2
2
kYtestk
2
2
.
Experiments are run on the following three different data sets:
‚Ä¢ Riboflavin: The Riboflavin production data set (B¬®uhlmann et al., 2014) contains
n = 71 samples and p = 4088 predictors (gene-expressions). The response Y and the
design X are both continuous.
‚Ä¢ Kemmeren: The Kemmeren (Kemmeren and et al., 2014) data set records knockouts of p = 6170 genes. The data X is continuous. We sample Y randomly from the
genes not present in the subsample taken from X.
‚Ä¢ Climate: The climate data set from the CNRM model from the CMIP5 model
ensemble (Knutti et al., 2013) simulates the temperature of points on the northern
hemisphere which is recorded in X. The response Y simulates the temperature on a
random position on the southern hemisphere. The data contains n = 231 observations.
‚àí2 ‚àí1 0 1 2
0.15 0.25 0.35 0.45
time
normalized mean squared error
‚àí2 ‚àí1 0 1 2
0.15 0.25 0.35 0.45
time
‚àí2 ‚àí1 0 1 2
0.15 0.25 0.35 0.45
time
Figure 6: From left to right column the experiments correspond to Riboflavin, Kemmeren
and Climate. The y-axis depicts the normalized squared error and the x-axis records the run
time in seconds on the log10 scale. It can be seen that xyz (purple) offers clear computational
advantages while giving similar level of prediction error to the Lasso fitted to all interactions
as implemented in glmnet (green).
For each experiment we fix the number of runs L to ‚àöp so the run time of xyz is O(np1.5
).
The experiments show that the xyz algorithm has a similar prediction performance to the
Lasso applied to all interactions as implemented in glmnet. However xyz is around 100
times faster for p = 2000. The results of all 6 experiments can be seen in Figure 6.
23
Thanei, Meinshausen and Shah
6. Discussion
In this work we exploited a relationship between closest pairs of point problems and interaction search. By solving the former problem using random projections to project points
down to a one-dimensional space and then sorting the resulting projected points, we were
able to produce an algorithm for interaction search that enjoys a run time that is sub
quadratic under mild assumptions and when used to search for very strong interactions
can be almost linear. Though we have looked at interaction search in this paper, the basic
engine for computing the large inner products between collections of vectors may have other
interesting applications, for example in large-scale clustering problems. We hope to study
such applications in future work.
24
The xyz algorithm for fast interaction search in high-dimensional data
Table of frequently used notation
n, p number of observations and number of variables
X, Y predictor matrix and response vector
Xj jth variable / column of X
Œ≤, Œ∏ coefficients of main effects and interaction effects
Œ≥jk interaction strength of the pair (j, k)
G distribution of projection
M subsample size
R projection vector
L number of projections
œÑ, Œ≥ close pairs threshold and interaction strength threshold
Œû set of all configurations of the xyz algorithm, the elements
of this set are denoted by Œæ
Œ∑ probability that a given interaction is present in the output
of the xyz algorithm
XÀú binarized version of X
W predictor matrix containing all possible interaction pairs
Appendix A
Here we include proofs that were omitted earlier.
Proof of Theorem 1
In the following, we fix the following notation for convenience:
Œ® = Œûminimal, Œ®(Œ∑) = Œûminimal(Œ∑),
Œû = Œûsubsample, Œû(Œ∑) = Œûsubsample(Œ∑).
Note that both Œ®(Œ∑) and Œû(Œ∑) depend on F though this is suppressed in the notation. Also
define Œûall = Œû ‚à™ Œûdense and Œûall(Œ∑) = Œû(Œ∑) ‚à™ Œûdense(Œ∑). We will reference the parameters
levels contained in Œæ ‚àà Œûall as ŒæL and ŒæœÑ . If Œæ ‚àà Œû then we will write ŒæM for the distribution
of the subsample size M.
If we let V denote the complexity of the search for œÑ -close pairs, similarly to (10) we
have that
T(Œæ) = c1np + L(c2EŒæM p + EŒæV + c3nEŒæ|E1|), (20)
where c1, c2, c3 are constants. Suppose œà ‚àà Œ® and Œæ ‚àà Œû have EŒæ|E1| = Eœà|E1|. Then since
searching for œÑ -close pairs is at least as computationally difficult as finding equal pairs we
know that EŒæV ‚â• EœàV .
Similarly for Œæ ‚àà Œûdense we have
T(Œæ) = c1np + L(c2np + EŒæV + c3nEŒæ|E1|). (21)
25
Thanei, Meinshausen and Shah
For Œæ ‚àà Œûall, define
Œ±(Œæ) = EŒæ|E1|/p2
, Œ≤(Œæ) = PŒæ((j
‚àó
, k‚àó
) ‚àà I1)
where I1 is the set of candidate interactions I when L = 1. Note that
PŒæ((j
‚àó
, k‚àó
) ‚àà I) = 1 ‚àí {1 ‚àí Œ≤(Œæ)}
ŒæL .
Thus any Œæ ‚àà Œûall(Œ∑) with T(Œæ) minimal must have ŒæL as the smallest L such that 1 ‚àí {1 ‚àí
Œ≤(Œæ)}
ŒæL ‚â• Œ∑, whence
ŒæL = dlog(1 ‚àí Œ∑)/ log{1 ‚àí Œ≤(Œæ)}e . (22)
Note that Œ≤(Œæ) does not depend on ŒæL, so the above equation completely determines the
optimal choice of L once other parameters have been fixed. We will therefore henceforth assume that L has been chosen this way so that the discovery probability of all the algorithms
is at least Œ∑.
The proofs of (8) and (9) are contained in Lemmas 12 and 13 respectively. The proof
of (7) is more involved and proceeds by establishing a Neyman‚ÄìPearson type lemma (Lemmas 10 and 11) showing that given a constraint on the ‚Äòsize‚Äô Œ± that is sufficiently small,
minimal subsampling enjoys maximal ‚Äòpower‚Äô Œ≤. To complete the argument, we show that
any sequence of algorithms with size Œ± remaining constant as p ‚Üí ‚àû cannot have a subquadratic complexity, whilst Lemma 12 attests that in contrast minimal subsampling does
have subquadratic complexity under the assumptions of the theorem. Several auxiliary
technical lemmas are collected in Section 6
Our proofs Lemmas 10 and 11 make use of the following bound on a quantity related
to the ratio of the size to the power of minimal subsampling.
Lemma 9 Suppose œà ‚àà Œ® has distribution for M placing mass on M and M + 1. Under
the assumptions of Theorem 1,
Œ±(œà)
Œ≥M
1
‚â§
2
1 ‚àí œÅ
1
M + 1
.
Proof We have
Œ±(œà)
Œ≥M
1
‚â§
1
p
2
X
j,k
(Œ≥jk/Œ≥1)
M ‚â§
c0
p
+
nŒ≥
X1‚àí1
i=0
 i
nŒ≥1
M
fn(i/n).
Now the sum on the RHS is maximised over fn obeying constraints (A1) and (A2) in the
following way. If œÅŒ≥1n > Œ≥1n ‚àí 1 then fn places all available mass on Œ≥1 ‚àí 1/n. Otherwise
fn should be as close to constant as possible on dœÅŒ≥1ne /n, . . . ,(Œ≥1n ‚àí 1)/n, and zero below
dœÅŒ≥1ne /n. In both cases it can be seen that
nŒ≥
X1‚àí1
i=0
 i
nŒ≥1
M
fn(i/n) ‚â§
2
1 ‚àí œÅ
Z 1
(1+œÅ)/2
x
Mdx ‚â§
2
1 ‚àí œÅ
1
M + 1
.
The following Neyman‚ÄìPearson-type lemma considers only non-randomised algorithms in
Œû. In Lemma 11 we extend this result to randomised algorithms.
26
The xyz algorithm for fast interaction search in high-dimensional data
Lemma 10 Let Œû0 be the set of Œæ ‚àà Œû such that ŒæM places mass only on a single M, so
the subsample size is not randomised. There exists an Œ±0 independent of n such that for all
Œ±
0 ‚â§ Œ±0, we have
sup
œà‚ààŒ®:Œ±(œà)‚â§Œ±0
Œ≤(œà) = sup
Œæ‚ààŒû0:Œ±(Œæ)‚â§Œ±0
Œ≤(Œæ).
Moreover the suprema are achieved.
Proof Each Œæ ‚àà Œû0 is parametrised by its close pairs threshold œÑ and subsample size M.
Given a Œæ ‚àà Œû0 with parameter values œÑ and M we compute Œ±(Œæ) as follows. Note that by
replacing the threshold œÑ by œÑ /2, we may assume that X and Z have entries in {‚àí1/2, 1/2}.
Thus Xj ‚àíZk has components in {‚àí1, 0, 1}. Let Jjk be the number of non-zero components
of (Ximj ‚àí Zimk)M
m=1. Then Jjk ‚àº Binom(M, 1 ‚àí Œ≥jk). Thus
P
 




X
M
m=1
Dm(Ximj ‚àí Zimk)





‚â§ œÑ

= P(Jjk = 0) +X
M
r=1
P
 




Xr
m=1
Dm





‚â§ œÑ

P(Jjk = r),
noting that Dm
d= ‚àíDm. By Lemma 14 we know there exists an a > 0 such that for all
œÑ ‚â§ a
‚àö
M the RHS is bounded below by
Œ≥
M
jk +
X
M
r=r0
c1œÑ
‚àö
r

M
r

Œ≥
M‚àír
jk (1 ‚àí Œ≥jk)
r
(23)
for M sufficiently large. Here the constants a, c1 > 0 and r0 ‚àà N depend only on F.
Consider œÑ > a‚àö
M. In this case, for r ‚â§ M sufficiently large we have by Lemma 14
P
 




Xr
m=1
Dm





‚â§ œÑ

‚â• P
 




Xr
m=1
Dm





‚â§ a
‚àö
r

‚â• c1a.
However then for M sufficiently large,
P(Jjk = 0) +X
M
r=1
P
 




Xr
m=1
Dm





‚â§ œÑ

P(Jjk = r) ‚â• c1a/2,
so Œ±(Œæ) ‚â• c1a/2. Note also that we must have Œ±0 ‚â• Œ±(Œæ) ‚â• Œ≥M
l
, so M ‚â• log(Œ±0)/ log(Œ≥l).
Thus by choosing 0 < Œ±0 < c1a/2 sufficiently small, we can rule out œÑ > a‚àö
M and so we
henceforth assume that œÑ ‚â§ a
‚àö
M, and that M is sufficiently large such that (23) holds for
all (j, k).
We have
Œ±(Œæ) ‚â•
1
p
2
X
j,k

Œ≥
M
jk + œÑ
X
M
r=r0
c1
‚àö
r

M
r

Œ≥
M‚àír
jk (1 ‚àí Œ≥jk)
r

. (24)
Similarly we have
Œ≤(Œæ) ‚â§ Œ≥
M
1 + œÑ
X
M
r=1
c2
‚àö
r

M
r

Œ≥
M‚àír
1
(1 ‚àí Œ≥1)
r
. (25)
27
Thanei, Meinshausen and Shah
Now substituting the upper bound on œÑ implied by (24) into (25), we get
Œ≤(Œæ) ‚â§ Œ≥
M
1 + QM

Œ±(Œæ) ‚àí
1
p
2
X
j,k
Œ≥
M
jk 
where
QM =
c2
PM
r=1 r
‚àí1/2
M
r

Œ≥
M‚àír
1
(1 ‚àí Œ≥1)
r
c1p‚àí2 P
j,k
P
r=r0
r‚àí1/2
M
r

Œ≥
M‚àír
jk (1 ‚àí Œ≥jk)
r
.
Now by Lemma 15, for M sufficiently large and some constant Q we have
QM ‚â§ Q
‚àö
P
1 ‚àí Œ≥1
j,k p
1 ‚àí Œ≥jk/p2
‚â§ Q.
Thus
Œ≤(Œæ) ‚â§ Œ≥
M
1 + Q

Œ±(Œæ) ‚àí
1
p
2
X
j,k
Œ≥
M
jk 
(26)
for all M sufficiently large. Now given Œ±0, let M0 be such that
1
p
2
X
j,k
Œ≥
M0
jk ‚â• Œ±0 ‚â•
1
p
2
X
j,k
Œ≥
M0+1
jk .
Consider the minimal subsampling algorithm œà that chooses subsample size as either M0
or M0 + 1 with probabilities b and 1 ‚àí b such that
Œ±(œà) = 1
p
2
X
j,k
{bŒ≥M0
jk + (1 ‚àí b)Œ≥
M0+1
jk } = Œ±0.
Then we have Œ≤(œà) = bŒ≥M0
1 + (1 ‚àí b)Œ≥
M0+1
1
. Now suppose Œæ ‚àà Œû0 has Œ±(Œæ) ‚â§ Œ±0. Then in
particular M ‚â• M0 + 1. We first examine the case where M = M0 + 1. Then
1
Œ≥
M0
1
{Œ≤(œà) ‚àí Œ≤(Œæ)} ‚â• b + (1 ‚àí b)Œ≥1 ‚àí Œ≥1 ‚àí
Q
Œ≥
M0
1

Œ±0 ‚àí
1
p
2
X
j,k
Œ≥
M0+1
j,k 
= b + (1 ‚àí b)Œ≥1 ‚àí Œ≥1 ‚àí
aQ
Œ≥
M0
1
1
p
2
X
j,k
(Œ≥
M0
j,k ‚àí Œ≥
M0+1
j,k )
‚â• b

(1 ‚àí Œ≥u) ‚àí
2Q
1 ‚àí œÅ
1
M0 + 1
,
using Lemma 9 in the final line. Note this is non-negative for M0 sufficiently large. When
M ‚â• M0 + 2 we instead have
Œ≤(Œæ)
Œ≤(œà)
‚â§
Œ≤(Œæ)
Œ≥
M0+1
1
‚â§ Œ≥1 +
2Q
Œ≥1(1 ‚àí œÅ)
1
M0 + 1
‚â§ Œ≥u +
2Q
Œ≥l(1 ‚àí œÅ)
1
M0 + 1
< 1
for M0 sufficiently large. Recall that by making Œ±0 sufficiently small, we can force M0 to
be arbitrarily large. Thus the result is proved.
  
The xyz algorithm for fast interaction search in high-dimensional data
Lemma 11 There exists an Œ±0 independent of n such that for all Œ±
0 ‚â§ Œ±0, we have
sup
œà‚ààŒ®:Œ±(œà)‚â§Œ±0
Œ≤(œà) = sup
Œæ‚ààŒû:Œ±(Œæ)‚â§Œ±0
Œ≤(Œæ).
Moreover the suprema are achieved.
Proof With a slight abuse of notation, write Œæ(M0
, œÑ 0
) for the element of Œæ ‚àà Œû that fixes
M = M0 and œÑ = œÑ
0
. Using the notation of Lemma 10, define function f : [0, 1] ‚Üí [0, 1] by
f(Œ±
0
) = sup
Œæ‚ààŒû0: Œ±(Œæ)‚â§Œ±0
Œ≤(Œæ).
Note that for Œæ ‚àà Œû we have
Œ≤(Œæ) ‚â§ EM‚àºŒæM f[Œ±{Œæ(M, ŒæœÑ )}]. (27)
Now by Lemma 10 we know there exists Œ±0 (depending on F) such that on [0, Œ±0], f is the
linear interpolation of points

1
p
2
X
j,k
Œ≥
M
j,k, Œ≥M
1
‚àû
M=1
.
We claim that f is concave on [0, Œ±0]. Indeed, it suffices to show that the slopes of the successive linear interpolants are decreasing in this region, or equivalently that their reciprocals
are increasing. We have
1
p
2
X
j,k
Œ≥
M+1
jk ‚àí Œ≥M
jk
Œ≥
M+1
1 ‚àí Œ≥M
1
=
1
p
2
X
j,k

Œ≥j,k
Œ≥1
M
Œ≥jk ‚àí 1
Œ≥1 ‚àí 1
(28)
which increases as M decreases, thus proving the claim.
Note also that the RHS of (28) is at most Œ±(œà)/{(1 ‚àí Œ≥u)Œ≥M
1
} when œà has subsample
size fixed at M. Thus by Lemma 9 we see the derivatives of the linear interpolants approach
infinity as they get closer to the origin. This implies the existence of an 0 < Œ±1 < Œ±0 such
that ‚àí sup
‚àÇ(‚àíf)(Œ±1)

‚â• {1 ‚àí f(Œ±1)}/(Œ±0 ‚àí Œ±1), where ‚àÇ(‚àíf)(Œ±1) denotes the subdifferential of the function ‚àíf at Œ±1. We may therefore invoke Lemma 16 to conclude that for Œæ
with Œ±(Œæ) ‚â§ Œ±1
EM‚àºŒæM f[Œ±{Œæ(M, ŒæœÑ )}] ‚â§ f[EM‚àºŒæM Œ±{Œæ(M, ŒæœÑ )}] = f(Œ±(Œæ)) ‚â§ f(Œ±1) = max
œà‚ààŒ®:Œ±(œà)‚â§Œ±1
Œ≤(œà).
Combining with (27) gives the result.
The next lemma establishes subquadratic complexity of minimal subsampling.
Lemma 12 Under the assumptions of Theorem 1, we have infœà‚ààŒ®(Œ∑) T(œà)/(np2
) ‚Üí 0.
Proof Let œà ‚àà Œ® be such that œàM places all mass on M. We have that Œ≤(œà) = Œ≥M
1
. Thus
using the inequality ‚àíx ‚â§ log(1 ‚àí x) for x ‚àà (0, 1), we have
œàL ‚â§ ‚àíŒ≥
‚àíM
1
log(1 ‚àí Œ∑).
2 
Thanei, Meinshausen and Shah
Lemma 9 gives an upper bound on œàLEœàE1. Note that EœàV = O(p log(p)). Thus ignoring
constant factors, we have
T(œà)/(np2
) ‚â§
M + log(p)
Œ≥M
1 np
+
1
M + 1
.
Taking M =

log(1/
‚àöp)/ log(Œ≥1)

then ensures T(œà)/(np2
) ‚Üí 0.
Lemma 13 Let Œæ ‚àà Œûdense. There exists c > 0 and n0 ‚àà N such that for all n ‚â• n0,
inf
Œæ‚ààŒûdense
T(Œæ)/(np2
) > c.
Proof Each Œæ ‚àà Œûdense is parametrised by its close pairs threshold œÑ . Given a Œæ ‚àà Œûdense(F)
with close pairs threshold œÑ we compute Œ±(Œæ) as follows. Similarly to Lemma 10 we may
assume without loss of generality that X and Z have entries in {‚àí1/2, 1/2} so Xj ‚àí Zk has
components in {‚àí1, 0, 1}. Since Ri
d= ‚àíRi as F ‚àà F, we have
P
 




Xn
i=1
Ri(Xij ‚àí Zik)





‚â§ œÑ

= P







n(1
X‚àíŒ≥jk)
i=1
Ri






‚â§ œÑ

.
We now use Lemma 14. For n(1‚àíŒ≥u) sufficiently large, when œÑ ‚â§ a
‚àö
n the RHS is bounded
below by
c1œÑ
p
n(1 ‚àí Œ≥jk)
.
Here constant a, c1 > 0 also depend only on F. Thus
Œ±(Œæ) ‚â•
1
p
2
X
j,k
c1œÑ
p
n(1 ‚àí Œ≥jk)
‚â• c1œÑ /‚àö
n. (29)
Similarly we have
Œ≤(Œæ) ‚â§
c2œÑ
p
n(1 ‚àí Œ≥1)
. (30)
Note that from (29), when œÑ > a‚àö
n we have Œ±(Œæ) ‚â• c1a. Thus from (21) we know there
exists n0 such that for all n ‚â• n0, we have
inf
Œæ‚ààŒûdense(Œ∑):ŒæœÑ >a‚àö
n
T(Œæ)/(np2
) ‚â• inf
Œæ‚ààŒûdense(Œ∑):ŒæœÑ >a‚àö
n
ŒæLŒ±(Œæ) ‚â• ŒæLc1a > 0. (31)
We therefore need only consider the case where œÑ ‚â§ a
‚àö
n and where Œ±(Œæ) ‚Üí 0.
Substituting the upper bound on œÑ implied by (29) into (30), we get
Œ≤(Œæ) ‚â§ Œ±(Œæ)
c2
c1
‚àö
1 ‚àí Œ≥u
.
30
The xyz algorithm for fast interaction search in high-dimensional data
Note that then
ŒæL ‚â•
log(1 ‚àí Œ∑)
log{1 ‚àí Œ±(Œæ)c2/(c1
‚àö
1 ‚àí Œ≥u)}
‚â• c3
log
1/1 ‚àí Œ∑

Œ±(Œæ)
for some c3 > 0 provided Œ±(Œæ) < 1/2 say. However this gives us
inf
Œæ‚ààŒûdense(Œ∑):ŒæœÑ ‚â§a
‚àö
n
T(Œæ)/(np2
) ‚â• inf
Œæ‚ààŒûdense(Œ∑):ŒæœÑ ‚â§a
‚àö
n
ŒæLŒ±(Œæ) ‚â• min{1/2, c3 log
1/1 ‚àí Œ∑

} > 0.
Combined with (31) this give the result.
With the previous lemmas in place, we are in a position to prove (7) of Theorem 1.
Proof of Theorem 1
The proofs of (8) and (9) are contained in Lemmas 12 and 13 respectively. To show (7)
we argue as follows. Given F and Œ∑, suppose for contradiction that there exists a sequence
Œæ
(1), Œæ(2)
, . . . and n1 < n2 < ¬∑ ¬∑ ¬∑ such that (making the dependence on n of the computational
time explicit)
inf
œà‚ààŒ®(Œ∑)
T
(nk)
(œà) > T(nk)
(Œæ
(k)
)
for all k. By Lemma 12, we must have T
(nk)
(Œæ
(k)
)/(np2
) ‚Üí 0. This implies that Œ±(Œæ
(k)
) ‚Üí 0.
By Lemma 11, we know that for k sufficiently large
sup
œà‚ààŒ®:Œ±(œà)=Œ±(Œæ
(k))
Œ≤(œà) ‚â• Œ≤(Œæ
(k)
).
Let œà
(k) be the maximiser of the LHS. In order for T
(nk)
(œà
(k)
) > T(nk)
(Œæ
(k)
), it must be the
case that EM‚àºœà
(k)
M
M > EM‚àºŒæ
(k)
M
M. However we claim that Œæ = œà
(k) minimises EM‚àºŒæM M
among all Œæ ‚àà Œû with Œ±(Œæ) ‚â§ Œ±(Œæ
(k)
) =: Œ±0, which gives a contradiction and completes the
proof. Let f be the function that linearly interpolates the points

1
p
2
X
j,k
Œ≥
M
j,k, M‚àû
M=1
.
Note that f is decreasing. By considering the inverse of f it is clear that f is convex. With
a slight abuse of notation, write Œæ(M, œÑ ) for the element of Œæ ‚àà Œû such that ŒæM places all
mass on M and ŒæœÑ = œÑ . Note that
EM‚àºŒæM M = EM‚àºŒæM f[Œ±{Œæ(M, 0)}] ‚â• EM‚àºŒæM f[Œ±{Œæ(M, ŒæœÑ )}].
Now suppose Œæ has Œ±(Œæ) ‚â§ Œ±0. Then from the above and Jensen‚Äôs inequality,
EM‚àºŒæM M ‚â• f

EM‚àºŒæM Œ±(Œæ(M, ŒæœÑ ))
‚â• f(Œ±0) = EM‚àºœà
(k)
M
M.   
Thanei, Meinshausen and Shah
Proof of Theorem 2
First note that from (11) we have L ‚â§ log(1‚àíŒ∑
0
)/ log(1‚àíŒ≥M)+1. Then using the inequality
log(1 ‚àí x) ‚â§ ‚àíx for x ‚àà (0, 1), we have
L ‚â§
log{1/(1 ‚àí Œ∑
0
)} + 1
Œ≥M
.
Note that from the definition of Œ≥0 we have Œ≥
‚àíM = p
log(Œ≥)/ log(Œ≥0)
. We then see that
Œ≥
‚àíME(E1) = Œ≥
‚àíM X
j,k
Œ≥
M
jk
‚â§ Œ≥
‚àíM
 X
j,k:Œ≥jk>Œ≥
Œ≥
M
jk +
X
j,k:Œ≥0<Œ≥jk‚â§Œ≥
Œ≥
M
jk +
X
j,k:Œ≥jk‚â§Œ≥0
Œ≥
M
jk 
‚â§ c1pŒ≥‚àíM + c2p
1+log(Œ≥)/ log(Œ≥0) + p
2
Œ≥
M
0 Œ≥
‚àíM
‚â§ (c1 + c2 + 1)p
1+log(Œ≥)/ log(Œ≥0)
.
Collecting together the terms in (10) we have
C(M, L) ‚â§ np + [log{1/(1 ‚àí Œ∑
0
)} + 1][log(p){1 + 1/ log(Œ≥
‚àí1
0
)} + n(c1 + c2 + 1)]p
1+log(Œ≥)/ log(Œ≥0)
from which the result easily follows.
Proof of Proposition 3
Let Œ∑
‚àó = Œ∑(M‚àó
, L). Note that in order for Œ∑(M0
, L0
) ‚â• Œ∑
‚àó
it must be the case that L
0 ‚â•
log(1 ‚àí Œ∑
‚àó
)/ log(1 ‚àí Œ≥M0
). Therefore
C(M0
, L0
) ‚àí np ‚â•
log(1 ‚àí Œ∑
‚àó
)
log(1 ‚àí Œ≥M0
)

M0
p + p log(p) + n
X
j,k
Œ≥
M0
jk 
‚â• min
M‚ààN
log(1 ‚àí Œ∑
‚àó
)
log(1 ‚àí Œ≥M)

M p + p log(p) + n
X
j,k
Œ≥
M
jk 
(32)
=
log(1 ‚àí Œ∑
‚àó
)
log(1 ‚àí Œ≥M‚àó
)

M‚àó
p + p log(p) + n
X
j,k
Œ≥
M‚àó
jk 
= C(M‚àó
, L).
Moreover, the inequality leading to (32) is strict if M‚àó
is the unique minimiser and M0 6= M‚àó
.
Technical lemmas
Lemma 14 Let F ‚àà F and suppose (Ri)‚àû
i=1 is an i.i.d. sequence with Ri ‚àº F.
Then for all a > 0, there exists c1, c2 > 0 and l0 ‚àà N such that for all l ‚â• l0 and
0 ‚â§ œÑ ‚â§ a
‚àö
l we have
c1œÑ
‚àö
l
‚â§ P

X
l
i=1
Ri

 ‚â§ œÑ

‚â§
c2œÑ
‚àö
l
.
32
The xyz algorithm for fast interaction search in high-dimensional data
Proof Let fl be the density of Pl
i=1 Ri/
‚àö
l. Note that as E(|R1|
3
) < ‚àû, we must have
E(R2
1
) < ‚àû, so we may assume without loss of generality that E(R2
1
) = 1. Then by Theorem
3 of Petrov (1964) we have that for sufficiently large l,
|fl(t) ‚àí œÜ(t)| ‚â§ c
‚àö
l(1 + |t|
3)
. (33)
Here c is a constant and œÜ(t) = e
‚àít
2/2/
‚àö
2œÄ is the standard normal density. Now by the
mean value theorem, we have
2 inf
0‚â§t‚â§œÑ /‚àö
l
{fl(t)}
œÑ
‚àö
l
‚â§ P

X
l
i=1
Ri

/
‚àö
l ‚â§ œÑ /‚àö
l

‚â§ 2 sup
0‚â§t‚â§œÑ /‚àö
l
{fl(t)}
œÑ
‚àö
l
.
Thus from (33), for l sufficiently large we have
P

X
l
i=1
Ri

 ‚â§ œÑ

‚â•
œÑ
‚àö
l
 ‚àö
2
‚àö
œÄ
exp{‚àíœÑ
2
/(2l)} ‚àí 2c
‚àö
l

.
Note that for a > 0 and l sufficiently large we have p
2/œÄe‚àía
2/2 > 2c/‚àö
l, whence
P

X
l
i=1
Ri

 ‚â§ œÑ

‚â•
c1œÑ
‚àö
l
for 0 ‚â§ œÑ ‚â§ a
‚àö
l, some c1 > 0. A similar argument yields the upper bound in the final
result.
Lemma 15 Suppose Œ≥ ‚àà [0, 1). For all M ‚àà N we have
X
M
r=1
1
‚àö
r

M
r

(1 ‚àí Œ≥)
r
Œ≥
M‚àír ‚â§
‚àö
2
p
(1 ‚àí Œ≥)M
. (34)
Given r0 ‚àà N and Œ≥ ‚àà [0, 1), there exists c > 0 and M0 ‚àà N such that for all M ‚â• M0 we
have
X
M
r=r0
1
‚àö
r

M
r

(1 ‚àí Œ≥)
r
Œ≥
M‚àír ‚â•
c
p
(1 ‚àí Œ≥)M
. (35)
Proof First we show the upper bound (34). Let J ‚àº Binomial(M, 1 ‚àí Œ≥).
X
M
r=1
1
‚àö
r

M
r

(1 ‚àí Œ≥)
r
Œ≥
M‚àír ‚â§
‚àö
2
X
M
r=1
1
‚àö
r + 1
M
r

(1 ‚àí Œ≥)
r
Œ≥
M‚àír
‚â§
‚àö
2E(1/
‚àö
J + 1).
33
Thanei, Meinshausen and Shah
Next, by Jensen‚Äôs inequality we have E(1/
‚àö
J + 1) ‚â§
p
E{1/(J + 1)}. We now compute
E{1/(J + 1)} as follows.
E

1
J + 1
=
X
M
r=0
1
r + 1
M
r

(1 ‚àí Œ≥)
r
Œ≥
M‚àír
=
1
M + 1
X
M
r=0

M + 1
r + 1 
(1 ‚àí Œ≥)
r
Œ≥
M‚àír
=
1
(1 ‚àí Œ≥)(M + 1)
X
M
r=0

M + 1
r + 1 
(1 ‚àí Œ≥)
r+1Œ≥
M‚àír
=
1 ‚àí Œ≥M+1
(1 ‚àí Œ≥)(M + 1) ‚â§
1
(1 ‚àí Œ≥)(M + 1).
Putting things together gives (34).
Turning now to (35), we see that the LHS equals
E(1/
‚àö
J1{J‚â•r0}
) = E(1/
‚àö
J|J ‚â• r0)P(J ‚â• r0).
By Jensen‚Äôs inequality we have
E(1/
‚àö
J|J ‚â• r0) ‚â•
1
p
E(J|J ‚â• r0)
=
p
P(J ‚â• r0)
q
E(J1{J‚â•r0}
)
‚â•
p
P(J ‚â• r0)
p
(1 ‚àí Œ≥)M
.
But as M ‚Üí ‚àû, P(J ‚â• r0) ‚Üí 1, which easily gives the result.
Lemma 16 Let f : [0, ‚àû) ‚Üí [0, 1] be non-decreasing. Suppose there exists 0 < Œ±1 < Œ±0
such that:
(i) f is concave on [0, Œ±0];
(ii) ‚àí sup
‚àÇ(‚àíf)(Œ±1)

‚â• {1 ‚àí f(Œ±1)}/(Œ±0 ‚àí Œ±1), where ‚àÇ(‚àíf)(Œ±1) denotes the subdifferential of the function ‚àíf at Œ±1.
Then if random variable X has E(X) ‚â§ Œ±0, then f(EX) ‚â• Ef(X).
Proof Write m = ‚àí sup
‚àÇ(‚àíf)(Œ±1)

Let function g : [0, ‚àû) ‚Üí [0, ‚àû) be defined as follows.
g(x) = (
f(x) if 0 ‚â§ x ‚â§ Œ±1
f(Œ±1) + m(x ‚àí Œ±1) if x > Œ±1.
Note that g thus defined has g(Œ±0) ‚â• 1. We see that g is convex and g ‚â• f. Thus if
E(X) ‚â§ Œ±1, by Jensen‚Äôs inequality we have
f(EX) = g(EX) ‚â• Eg(X) ‚â• Ef(X).
  
The xyz algorithm for fast interaction search in high-dimensional data
Appendix B
Connection to LSH
Minimal subsampling as considered in Algorithm 2 is closely related to the locality-sensitive
hashing (LSH) framework: Define h(j) = RT Xj (R corresponds to the minimal subsampling projection) to be the hashing function and H to be the family of such functions, from
which we sample uniformly. Then H is (Œ≥, cŒ≥, p1, p2)-sensitive, that is:
‚Ä¢ if Œ≥jk ‚â• Œ≥ then P(h(j) = h(k)) ‚â• p1
‚Ä¢ if Œ≥jk ‚â§ cŒ≥ then P(h(j) = h(k)) ‚â§ p2,
where 0 < c < 1. In the case of the minimal subsampling we have p1 = Œ≥M and p2 = Œ≥McM.
However, the typical LSH machinery cannot be applied directly to the equal pairs problem
above. In our setting, we are not interested in preserving close pairs but rather the closest
pairs. Theorem 1 establishes that the family H leads to the maximal ratio p1/p2 among all
linear hashing families.
Appendix C
Proof of Proposition 4
Proof
P(sgn(Yi) = XÀú
ijXÀú
ik) = sgn(Yi) + 1
2
(g(Xij )g(Xik) + (1 ‚àí g(Xij ))(1 ‚àí g(Xik)))
+
1 ‚àí sgn(Yi)
2
(g(Xij )(1 ‚àí g(Xik)) + (1 ‚àí g(Xij ))g(Xik))
=
1
2
+
sgn(Yi)
2
(1 ‚àí 2g(Xij ))(1 ‚àí 2g(Xik)).
Appendix D
The unbiased transform and the sign transform
Proposition 6
Proof The equation
E[XÀú
ij ] = P(XÀú
ij = 1) ‚àí P(XÀú
ij = ‚àí1) = Xij ,
implies
P(XÀú
ij = 1) = Xij + 1
2
This uniquely determines the unbiased transform.
Next we show two Lemmas that will be useful when proving Theorems 7 and 8.
35
Thanei, Meinshausen and Shah
Lemma 17 Consider the setup of Theorem 7. Then there exists constants C
Œµ
1
, CŒµ
2 > 0 such
that defining
Œ±
u
n,p = Œ±
u
n,p(t) = 
1 +
t + log(nCŒµ
1
)
CŒµ
2
p
2{t + log(4p)}/n,
with probability at least 1 ‚àí 2 exp(‚àít) we have:
P
i
YiXij‚àóXik‚àó
kYk1
‚àà/
h
‚àí
m2 ‚àí Œ±
u
n,p
m1 + mŒµ + Œ±u
n,p
,
m2 ‚àí Œ±
u
n,p
m1 + mŒµ + Œ±u
n,p
i
Pn
i=1 YiXijXik
kYk1
‚àà
h
‚àí
m2(1 ‚àí ru) + Œ±
u
n,p
m1 ‚àí Œ±u
n,p
,
m2(1 ‚àí ru) + Œ±
u
n,p
m1 ‚àí Œ±u
n,p
i
‚àÄ(j, k) 6= (j
‚àó
, k‚àó
).
Proof First we consider a capped version of Œµ:
Œµ
0
i =
(
Œµi
if |Œµi
| ‚â§ œÉ
œÉsgn(Œµi) otherwise,
where œÉ is to be chosen later. We may apply Hoeffding‚Äôs inequality to these bounded
variables. We have to bound two terms:
Pn
i=1 YiXij‚àóXik‚àó
kYk1
from below and
Pn
i=1 YiXijXik
kYk1
from above, for (j, k) 6= (j
‚àó
, k‚àó
).
Schematically the first term can be dealt with in the following way:
P
 A + B
C + D
‚â•
a + b
c + d

‚â• 1 ‚àí P(A ‚â§ a) ‚àí P(B ‚â§ b) ‚àí P(C ‚â• c) ‚àí P(D ‚â• d) (36)
where
A + B =
Xn
i=1
(Xij‚àóXik‚àó )
2 + Œµ
0
iXij‚àóXik‚àó and C + D =
Xn
i=1
|Xij‚àóXik‚àó + Œµ
0
i
|.
We deal with each term individually. Using Hoeffding‚Äôs inequality we get:
A : P
Pp
i=1(Xij‚àóXik‚àó )
2 ‚â§ nm2 ‚àí Œ¥

‚â§ exp(‚àíŒ¥
2/2n))
B : P
Pn
i=1 Œµ
0
iXij‚àóXik‚àó ‚â§ ‚àíŒ∫

‚â§ exp(‚àíŒ∫
2/2nœÉ2
)
C : P
Pn
i=1 |Xij‚àóXik‚àó | ‚â• nm1 + Œ¥

‚â§ exp(‚àíŒ¥
2/2n)
D : P
Pn
i=1 |Œµ
0
i
| ‚â• nmŒµ + Œ∫

‚â§ exp(‚àí2Œ∫
2/nœÉ2
).
This gives us a bound of the interaction strength of the true interaction pair:
P
P
i
YiXij‚àóXik‚àó
kYk1
‚â•
nm2 ‚àí Œ¥ ‚àí Œ∫
nm1 + nmŒµ + Œ¥ + Œ∫

‚â• 1 ‚àí exp(‚àíŒ¥
2
/2n) ‚àí exp(‚àíŒ¥
2
/2n)
‚àí exp(‚àíŒ∫
2
/2nœÉ2
) ‚àí exp(‚àíŒ∫
2
/2nœÉ2
)
Similarly we can treat the interaction strength of the non interacting pairs:
36
The xyz algorithm for fast interaction search in high-dimensional data
A : Here we use assumption (B1):
m2(ru ‚àí 1) ‚â§ E[Xij‚àóXik‚àóXimXio] ‚â§ m2(1 ‚àí ru).
Hence, P
Pn
i=1 Xij‚àóXik‚àóXijXik ‚â• nm2(1 ‚àí ru) + Œ¥

‚â• exp(‚àíŒ¥/2n).
For the rest we run the same bounds as before (using |Xij‚àóXik‚àó + Œµ
0
i
| ‚â• |Xij‚àóXik‚àó | + Œµ
0
i
).
This yields the bound
P
Pn
i=1 YiXijXik
kYk1
‚â§
nm2(1 ‚àí ru) + Œ¥ + Œ∫
nm1 ‚àí Œ¥ ‚àí Œ∫

‚â• 1 ‚àí exp(‚àíŒ¥
2
/2n) ‚àí exp(‚àíŒ¥
2
/2n)
‚àí exp(‚àíŒ∫
2
/2nœÉ2
) ‚àí exp(‚àíŒ∫
2
/2nœÉ2
)
The above inequality needs to hold for all at most p
2 pairs that are not interactions, so that
we effectively multiply the exponential terms with p
2
. Another factor of 2 is multiplied in
for the negative sign, as the fraction also has to be bounded away from ‚àí1. In total we
thus have:
Pn
i=1 YiXij‚àóXik‚àó
kYk1
‚àà/
h
‚àí
nm2 ‚àí Œ¥ ‚àí Œ∫
nm1 + nmŒµ + Œ¥ + Œ∫
,
nm2 ‚àí Œ¥ ‚àí Œ∫
nm1 + nmŒµ + Œ¥ + Œ∫
i
Pn
i=1 YiXijXik
kYk1
‚àà
h
‚àí
nm2(1 ‚àí ru) + Œ¥ + Œ∫
nm1 ‚àí Œ¥ ‚àí Œ∫
,
nm2(1 ‚àí ru) + Œ¥ + Œ∫
nm1 ‚àí Œ¥ ‚àí Œ∫
i
‚àÄ(m, o) 6= (j, l)
with probability at least 1 ‚àí exp(‚àíŒ¥
2
/2n) ‚àí exp(‚àíŒ¥
2
/2n) ‚àí exp(‚àíŒ∫
2
/2nœÉ2
) ‚àí exp(‚àíŒ∫
2
/2nœÉ2
).
Finally, let œÉ ‚â• 1, then we have to set Œ¥ and Œ∫ so that the probability is bigger than
1 ‚àí exp(‚àít). This gives:
exp(‚àít) = 4p exp(‚àíŒ¥
2
/2n) and exp(‚àít) = 4p exp(‚àíŒ∫
2
/2nœÉ2
).
This gives
Œ¥ =
p
2n(t + log(4p)) and Œ∫ =
p
2nœÉ2(t + log(4p)).
Thus for Œ±
u
n,p =
‚àö
2(t+log(4p))(1+œÉ2)
‚àö
n
,
P
i
YiXij‚àóXik‚àó
kYk1
‚àà/
h
‚àí
m2 ‚àí Œ±
u
n,p
m1 + mŒµ + Œ±u
n,p
,
m2 ‚àí Œ±
u
n,p
m1 + mŒµ + Œ±u
n,p
i
Pn
i=1 YiXijXik
kYk1
‚àà
h
‚àí
m2(1 ‚àí ru) + Œ±
u
n,p
m1 ‚àí Œ±u
n,p
,
m2(1 ‚àí ru) + Œ±
u
n,p
m1 ‚àí Œ±u
n,p
i
‚àÄ(j, k) 6= (j
‚àó
, k‚àó
)
with probability at least 1 ‚àí exp(‚àít).
Now we extend this result to the case of unbounded errors, that is we now assume that with
high probability Œµi are bounded:
P(Œµi = Œµ
0
i
, ‚àÄ i) = 1 ‚àí exp(‚àít).
37
Thanei, Meinshausen and Shah
Here we used the sub-exponential tail behavior of Œµ. We have P(|Œµi
| ‚â• t) ‚â§ C
Œµ
1
exp(‚àíC
Œµ
2
t).
Hence we set
t = C
Œµ
2œÉ ‚àí log(nCŒµ
1
) ‚áí œÉ =
t + log(nCŒµ
1
)
CŒµ
2
Thus,
Œ±
u
n,p =
q
2{t + log(4p)}{1 + (t+log(nCŒµ
1
)
CŒµ
2
)}
2}
‚àö
n
with probability at least 1 ‚àí 2 exp(‚àít) we have:
P
i
YiXij‚àóXik‚àó
kYk1
‚àà/
h
‚àí
m2 ‚àí Œ±
u
n,p
m1 + mŒµ + Œ±u
n,p
,
m2 ‚àí Œ±
u
n,p
m1 + mŒµ + Œ±u
n,p
i
Pn
i=1 YiXijXik
kYk1
‚àà
h
‚àí
m2(1 ‚àí ru) + Œ±
u
n,p
m1 ‚àí Œ±u
n,p
,
m2(1 ‚àí ru) + Œ±
u
n,p
m1 ‚àí Œ±u
n,p
i
‚àÄ(j, k) 6= (j
‚àó
, k‚àó
).
Next we prove the equivalent result for the sign transform. The proof is very similar to the
unbiased case:
Lemma 18 Consider the setup of Theorem 8. Then there exists constants C
X
1
, CX
2
, CŒµ
1
, CŒµ
2 >
0 such that defining
Œ±
s
n,p = Œ±
s
n,p(t) =
r
2(t + log(4p))t+log(pnCX
1
)
CX
2
4
+

t+log(nCŒµ
1
)
CŒµ
2
2
‚àö
n
,
with probability at least 1 ‚àí 3 exp(‚àít) we have:
Pn
i=1 Yisgn(Xij‚àóXik‚àó )
kYk1
‚àà/
h
‚àí
m1 ‚àí Œ±
s
n,p
m1 + mŒµ + Œ±s
n,p
,
m1 ‚àí Œ±
s
n,p
m1 + mŒµ + Œ±s
n,p
i
Pn
i=1 Yisgn(XijXik)
kYk1
‚àà
h
‚àí
m1(1 ‚àí rs) + Œ±
s
n,p
m1 ‚àí Œ±s
n,p
,
m1(1 ‚àí rs) + Œ±
s
n,p
m1 ‚àí Œ±s
n,p
i
‚àÄ (m, o) 6= (j
‚àó
, k‚àó
).
Proof First consider capped versions of the random variables of interest:
X0
ij =
(
Xij if |Xij | ‚â§ M
Msgn(Xij ) otherwise
and Œµ
0
i =
(
Œµi
if |Œµi
| ‚â§ œÉ
œÉsgn(Œµi) otherwise
where M and œÉ are to be chosen later. Given these capped variables we can use Hoeffding‚Äôs
inequality as we now deal with bounded variables. We have to bound two terms:
Pn
i=1 Yisgn(X0
ij‚àóX0
ik‚àó )
kYk1
from below and
Pn
i=1 Yisgn(X0
ijX0
ik)
kYk1
from above, for (j, k) 6= (j
‚àó
, k‚àó
)
As in Lemma 17 equation (36):
A + B =
Xn
i=1
|X0
ij‚àóX0
ik‚àó | + Œµ
0
i
sgn(X0
ij‚àóX0
ik‚àó ) and C + D =
Xn
i=1
|X0
ij‚àóX0
ik‚àó + Œµ
0
i
|.
We deal with each term individually. Using Hoeffding‚Äôs inequality we get:
38
The xyz algorithm for fast interaction search in high-dimensional data
A : P
Pp
i=1 |X0
ij‚àóX0
ik‚àó | ‚â§ nm1 ‚àí Œ¥

‚â§ exp(‚àíŒ¥
2/2nM4
))
B : P
Pn
i=1 Œµ
0
i ‚â§ ‚àíŒ∫

‚â§ exp(‚àíŒ∫
2/2nœÉ2
)
C : P
Pn
i=1 |X0
ij‚àóX0
ik‚àó | ‚â• nm1 + Œ¥

‚â§ exp(‚àíŒ¥
2/2nM4
)
D : P
Pn
i=1 |Œµ
0
| ‚â• nm0
Œµ + Œ∫

‚â§ exp(‚àí2Œ∫
2/nœÉ2
)
This gives us a bound of the interaction strength of the true interaction pair:
P
P
i
Yisgn(X0
ij‚àóX0
ik‚àó )
kYk1
‚â•
nm1 ‚àí Œ¥ ‚àí Œ∫
nm1 + nmŒµ + Œ¥ + Œ∫

‚â• 1 ‚àí 2 exp(‚àíŒ¥
2
/2nM4
) ‚àí 2 exp(‚àíŒ∫
2
/2nœÉ2
)
Similarly we can treat the interaction strength of the non interacting pairs:
A : Here we use assumption (C1). It implies
rs/2 ‚â§ P(sgn(X0
ij‚àóX0
ik‚àó ) = sgn(X0
ijX0
ik)|X) ‚â§ 1 ‚àí rs/2.
This we use for computing the expectation:
E[X0
ij‚àóX0
ik‚àó sgn(X0
ijX0
ik)] = E[E[|X0
ij‚àóX0
ik‚àó |sgn(X0
ijX0
ikX0
ij‚àóX0
ik‚àó )]
= E[E[2|X0
ij‚àóX0
ik‚àó |1{sgn(X0
ijX0
ikX0
ij‚àóX0
ik‚àó )=1}
|X]] ‚àí E[|X0
ij‚àóX0
ik‚àó |]
= E[E[2|X0
ij‚àóX0
ik‚àó ||X]]P(sgn(X0
ijX0
ikX0
ij‚àóX0
ik‚àó ) = 1|X) ‚àí E[|X0
ij‚àóX0
ik‚àó |]
= E[|X0
ij‚àóX0
ik‚àó |](2P(sgn(X0
ijX0
ikX0
ij‚àóX0
ik‚àó ) = 1|X) ‚àí 1).
Thus the expectation is given as:
m1(rs ‚àí 1) ‚â§ E[X0
ij‚àóX0
ik‚àó sgn(X0
ijX0
ik)] ‚â§ m1(1 ‚àí rs).
Hence, P
Pn
i=1 X0
ij‚àóX0
ik‚àó sgn(X0
ijX0
ik) ‚â• nm1(1 ‚àí rs) + Œ¥

‚â• exp(‚àí2Œ¥/nM4
).
For the rest we use the same bounds as before (using |X0
ij‚àóX0
ik‚àó + Œµ
0
i
| ‚â• |X0
ij‚àóX0
ik‚àó | + Œµ
0
i
).
This yields the bound
P
Pn
i=1 Yisgn(X0
ijX0
ik)
kYk1
‚â§
nm1(1 ‚àí rs) + Œ¥ + Œ∫
nm1 ‚àí Œ¥ ‚àí Œ∫

‚â• 1 ‚àí exp(‚àí2Œ¥
2
/nM4
) ‚àí exp(‚àí2Œ∫
2
/nœÉ2
).
The above inequality needs to hold for the at most p
2 pairs that are not interactions, so
that we effectively multiply the exponential terms with p
2
. Another factor of 2 is multiplied
in for the negative sign, as the fraction also has to be bounded away from ‚àí1. In total we
thus have:
P
i
Yisgn(X0
ij‚àóX0
ik‚àó )
kYk1
‚àà/
h
‚àí
nm1 ‚àí Œ¥ ‚àí Œ∫
nm1 + nmŒµ + Œ¥ + Œ∫
,
nm1 ‚àí Œ¥ ‚àí Œ∫
nm1 + nmŒµ + Œ¥ + Œ∫
i
Pn
i=1 Yisgn(X0
ijX0
ik)
kYk1
‚àà
h
‚àí
nm1(1 ‚àí rs) + Œ¥ + Œ∫
nm1 ‚àí Œ¥ ‚àí Œ∫
,
nm1(1 ‚àí rs) + Œ¥ + Œ∫
nm1 ‚àí Œ¥ ‚àí Œ∫
i
‚àÄ(j, k) 6= (j
‚àó
, k‚àó
)
with probability at least 1 ‚àí 2p exp(‚àíŒ¥
2
/2nM4
) ‚àí 2p exp(‚àíŒ∫
2
/2nœÉ2
).
39
Thanei, Meinshausen and Shah
Finally we have to set Œ¥ and Œ∫ so that the probability is bigger than 1 ‚àí exp(‚àít). This
gives:
exp(‚àít) = 4p exp(‚àíŒ¥
2
/2nM4
) and exp(‚àít) = 4p exp(‚àíŒ∫
2
/2nœÉ2
)
This gives
Œ¥ =
p
2nM4(t + log(4p)) and Œ∫ =
p
2nœÉ2(t + log(4p))
Thus for Œ±
s
n,p =
‚àö
2(t+log(4p))(M4+œÉ2)
‚àö
n
P
i
Yisgn(X0
ij‚àóX0
ik‚àó )
kYk1
‚àà/
h
‚àí
m1 ‚àí Œ±
s
n,p
m1 + mŒµ + Œ±s
n,p
,
m1 ‚àí Œ±
s
n,p
m1 + mŒµ + Œ±s
n,p
i
Pn
i=1 Yisgn(X0
ijX0
ik)
kYk1
‚àà
h
‚àí
m1(1 ‚àí rs) + Œ±
s
n,p
m1 ‚àí Œ±s
n,p
,
m1(1 ‚àí rs) + Œ±
s
n,p
m1 ‚àí Œ±s
n,p
i
‚àÄ(j, k) 6= (j
‚àó
, k‚àó
)
with probability at least 1 ‚àí exp(‚àít).
We now extend this result to the case of unbounded variables, that is we now assume that
with high probability the variables Xij and Œµi are bounded:
P( Xij = X0
ij , ‚àÄ i, j) = 1 ‚àí exp(‚àít) and P(Œµi = Œµ
0
ij , ‚àÄ i) = 1 ‚àí exp(‚àít).
Here we used the sub-exponential tail behaviour of the Xij and Œµi
. There exists constants
C
X
1
, C
X
2
such that P(|Xij | ‚â• t) ‚â§ C
X
1
exp(‚àíC
X
2
t) and similarly for Œµ. Hence we set
t = C
X
2 M ‚àí log(pnCX
1
) ‚áí M =
t + log(pnCX
1
)
CX
2
t = C
Œµ
2œÉ ‚àí log(nCŒµ
1
) ‚áí œÉ =
t + log(nCŒµ
1
)
CŒµ
2
Thus we have
Œ±
s
n,p =
r
2(t + log(4p))t+log(pnCX
1
)
CX
2
4
+

t+log(nCŒµ
1
)
CŒµ
2
2
‚àö
n
Next we prove Theorem 7:
Proof Given Œ¥,  > 0, choose t such that 3 exp(‚àít) < . From (B3) we have that Œ±
u
n,p(t)
defined in Lemma 17 satisfies Œ±
u
n,p(t) ‚Üí 0 as n ‚Üí ‚àû. Thus from Lemma 17 we know that
there exists N such that for all n ‚â• N, with probability 1 ‚àí  we have
log(Œ≥
g
j
‚àók
‚àó )
log(Œ≥
g
jk)
<
log{(1 + m2
m1+mŒµ
)/2}
log{(1 + m1
m2(1‚àírs)
)/2}
+ Œ¥/2.
Thus for n ‚â• N, applying Corollary 5 we have that with probability 1 ‚àí ,
C(M, L) ‚â§ cnp
1+Œ¥/2+ log(1/2+m2/2((m1+mŒµ)))
log(1/2+m2(1‚àíru)/(2m1))
,
for some constant c.
The proof of Theorem 8 is very similar and is thus omitted.
40
The xyz algorithm for fast interaction search in high-dimensional data
