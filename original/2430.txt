With the growing of economic globalization and world economic integration, customer demands are becoming increasingly personalization and diversification. How to design a reasonable schedule scheme becomes the key point of industries. Flexible job shop scheduling problem (FJSP) is an extension of the classical job scheduling problem (JSP). It is an important problem in the modern manufacturing system, and constitutes to one of the most difficult combinatorial optimization problems. This paper defines an objective function, which aims at minimizing the makespan, under the conveyor constraints. Moreover, we present a genetic algorithm (GA)-based approach to optimizing the objective. Specifically, we firstly propose a method for solving conveyor-constrained FJSP (CDFJSP) by using a plug-in greedy algorithm and a binary search algorithm. Considering the unexpected events that usually occur in real-life applications, a real-time method with dispatching rules (RDRP) is proposed. Extensive experimental results demonstrate the efficacy of our proposed methods.

Introduction
With the rapid development of modern industrial technology, the demand of intelligent manufacturing has shown an explosive growth, because most traditional manufacturing systems heavily rely on hierarchical step-by-step structures and their planning and scheduling are usually based on centralized control leading to lack of flexibility. Although the last two decades have witnessed the trends of digital modernization in different industrial fields reshaping business modes, production organization, system management, etc., many traditional manufacturing factories in underdeveloped or developing countries remain human labor-based, which brings several inevitable problems like inefficient production, excessive cost, frequently scheduling conflicts, and without adaptation to irregular workshop disturbances. Therefore, developing effective digitalized scheduling methods and techniques becomes essential for transforming traditional human labor-based factories to intelligent manufacturing ones.

There exist several workshop styles in intelligent manufacturing systems [17, 38]. The well-known job-shop scheduling problem (JSP) is composed of a set of machines and a set of jobs [3]. The sequence of operations in JSP is predetermined, and each operation is processed on a specified machine. In real-world manufacturing systems, however, operations can be processed on multiple machines, which is so-called flexible job-shop problem (FJSP) [12]. It indicates that two decisions, including operation sequencing and machine (worker) assignment, must to be made simultaneously. The goal constitutes to optimize machine resources in order to achieve the objectives such as minimizing the makespan [11]. FJSP is a NP-hard problem (non-deterministic polynomial hard problem) [4], which makes it impossible to obtain an optimal solution in a reasonable amount of time. Therefore, these kinds of scheduling problems are mostly solved by using heuristic methods, i.e., particle swarm optimization (PSO), genetic algorithm (GA), tabu search, etc., which can obtain a satisfactory solution in a relatively short time [5].

In addition, many practical scheduling problems are in dynamic environment. In static scheduling, all the jobs and machines (workers) are readiness at the beginning of the scheduling horizon, and all of information is known in advance. Apparently, static scheduling cannot cope with unexpected conditions, e.g., unpredicted job arrivals or job delay [35] which may occur in real-time manufacturing process. It may make static scheduling result deviate from the actual execution process and affect the subsequent scheduling decisions if a large number of dynamic constraints exist. In order to cope with dynamic changes and reduce computational complexity, dispatching rules (DRs) [13, 19, 23] have been widely applied in dynamic scheduling. A DR is a priority function of the job-shop attributes, such as the capacity of conveyor and operation processing time. It calculates the priority for each operation waiting in the queue, and the best one is selected to be processed subsequently. In this way, only each decision point can be made efficiently through computation.

Our research is motivated by a real-world scheduling problem in a cloth manufacturing company in China. The company is specialized in the production of fast retailing clothes-made of varies materials. Clothing shops are their mainly customers. These products are fabricated in predefined lots what we refer in our system as jobs, each of which is composed of multiple operations of a specific product. The components for various clothes subsequently run through various manufacturing operations, for example, peeling, sewing and spraying, in predefined sequences in order to complete the final products. The items of each lot (batch) are jointly stored and moved in marked baskets to ensure that a specific operation of a job must to be completed for the entire lot, before the processing of the next operation of the job can be started. The jobs are divided into batch line jobs and complete line jobs. The batch line is utilized for assembling components, which are sent to the complete line for making the completed products. Under the two different production lines, workers’ skills can be fully integrated with machine skills.

Currently, the scheduling of the production processes at our industry partner is a daily manual task with a planning horizon of about half day. In the real production process, worker’s proficiency (efficiency) usually changes over time. As a result, some workers may have idle time, and the assembly line jam may occur if one of workers is inefficient. In addition, the transmission time among machines has a heavy impact on scheduling result. It may be unfeasible if the transmission time is too long even if the scheduling result is very tight. Moreover, if the scheduling tasks’ number is too large, we cannot accomplish the optimal solution in the required time (5 mins in our industrial application) and cannot cope with the emergency scenarios that may make the original schedule unworkable. In order to solve the aforementioned problems, we were asked to implement scheduling algorithms that are capable of taking account of the real-time conditions or a certain interval to trigger the schedule updating. Additionally, we were asked to design two schemes. First, providing the scheduling results for minimizing the makespan when the trigger condition is met based on the worker proficiency, transmission time and conveyor capacity. Second, designing a real-time scheduling system entirely based on some dispatching rules of the production line, that is, to determine which worker is the best choice based on the real-time information.

In this paper, we firstly use a genetic algorithm (GA) that considers the conveyor carrying capacity, transmission time, and worker real-time proficiency to update the scheduling result in order to cope with dynamic situations. The GA has powerful global searching ability and effective searching ability, it can find a suitable trade-off between runtime and solution quality under constraints. In order to solve our problem more effectively, effective encoding method, genetic operators, neighborhood structure and binary search are utilized in this method. Second, we design a system to fully satisfy the real-time request based on some dispatching rules. In the following context, we refer to the first problem as conveyor-constrained FJSP with dynamic environments (CDFJSP). Moreover, the second problem was referred as a real-time problem with dispatching rules (RDRP).

The remainder of this paper is structured as follows. Related work is presented in Sect. 2. The CDFJSP and RDRP are modeled in Sect. 3. Experimental results are reported in Sect. 4. Section 5 describes the conclusions and the future work.

Related work
In this section, we mainly review related work on scheduling problem. We firstly introduce the classical algorithm about job-shop scheduling models. Second, we review the manufacturing related methods. Finally, we briefly describe the characteristics of our method.

Job-shop scheduling models
One of the most important fields in the advanced planning and scheduling (APS) is scheduling problem. Scheduling which is essential for manufacturing industries aims at determining the assignment of plant resources.

Actually, there exists various methods widely used for plant scheduling. JSP [3] considers operation sequences of a machine in order to minimize their makespan. In JSP, operations must to be processed on a specified machine and no more machines can be chosen. If some or all of operations can operate on different machines, we call it FJSP [12] which is the advanced model of JSP. If some machines can be chosen, we call it part FJSP (P-FJSP). If all of machines can be chosen, we call it complete FJSP (C-FJSP). In addition, considering multi-resources, such as production capacity that is restricted by tools, dies, fixtures, operators, vehicles and other manufacturing resource constraints, we call it multi-resources or multi-resources FJSP model (MrFJSP). An advanced planning and scheduling model [21] which integrates process planning and production scheduling was proposed. The model includes the main features of a scheduling system including flexible operations’ sequences, resource requirements and alternative schedules. Similarly, an integrated transportation scheduling model [25] was reported. It is constructed based on bill of manufacturing with information technology of XML family. Furthermore,when considering multi-plants and transportations among them, it becomes a multi-plants-based (MPFJSP) model, which can be regarded as a highly complicated model due to its dynamical re-scheduling operations and different resource management constraints. In later study, an advanced planning and scheduling (APS) model [21] was proposed by synthesizing process planning and production scheduling. On the other hand, by integrating the transportation between plants and manufacturing process, an extended APS model [25] was introduced based on GA. All of aforementioned scheduling models, however, focused on centralized scheduling. These methods have difficulty in addressing real-time requests and dynamic changes in a manufacturing system.

Related industry manufacturing method
The problem of the industry application in this research can be seen as an FJSP. In general, the methods for solving FJSP can be classified into two categories: the exact method and the approximation method. The exact method contains branch-and-bound methods and mathematical programming (MP) methods. But they can only address small-scale FJSPs. The approximation method contains GA [7, 26, 36], tabu search [15, 18], and other artificial intelligence (AI)-based approaches [20] which can quickly get better solutions to meeting the requests of practical problems.

The earlist method to work on FJSP, presented by Brucker and Schlie [4], introduced a polynomial graphical algorithm (PGA) to solve a two-job FJSP. A mixed integer nonlinear program (MINLP) [30] was then proposed to solve the common cycle multi-product lot-scheduling problem in deterministic flexible job shops, where the planning horizon is finite and fixed by management. Four most widely used formulations of the FJSP were compiled from literature and a new time-indexed model was reported in [6]. However, these exact algorithms cannot solve a large-scale FJSP effectively in which the total number of operations may be very large (e.g., more than 200) [26]. Therefore, most of presented methods for solving real-world FJSP have concentrated on the approximation methods.

Evolutionary algorithm (EA) is an effective type of meta-heuristic method, including genetic programming, GA, evolution programming, and evolution strategies. Falkenauer and Bouffouix [10] utilized GAs to optimize the JSP with many tasks, many machines, and precedence constraints. They showed the difficulty of modeling the JSP and then presented an encoding method to overcome these difficulties. A GA [8] was proposed by developing a new chromosome representation and adopting different strategies for crossover and mutation operators to solve the FJSP. Subsequently, many variants of GA were widely adopted to solve the FJSP [1, 2, 33]. Moreover, some researchers attempted to utilize GA for dealing with multi-objective functions. For example, several DRs discovered [29] by genetic programming were utilized to solve the multi-objective FJSP. Similarly, a multi-objective EA [5] was proposed by utilizing effective genetic operators and maintaining population diversity.

Other meta-heuristic search-based methods, such as tabu search [16, 24], simulated annealing [28, 32] and differential evolution [34, 37], have also been widely used to solve the static scheduling in FJSP. These meta-heuristic methods usually perform well in achieving reasonable solutions with less time because of their powerful global search ability. However, their major drawback lies in the lack of capability to adapt to dynamic environmental changes, which usually occur in real-world industrial applications.

In a dynamic FJSP, certain unpredicted conditions may occur in real time and affect the subsequent scheduling decisions. As a result, the DRs which depend on current state information to decide the next step schedule can be used under dynamic scheduling conditions. Since DRs achieve the solution iteratively, their execution time costs are smaller in a significant rate than those of meta-heuristic methods [31]. In order to further minimize the makespan, a new DR [9] was proposed together with a comparison to three existing DRs under dynamic conditions. In addition, a particle swarm optimization (PSO) algorithm [14] was utilized to compare six DRs for scheduling tasks under heterogeneously distributed environments.

Features of our method
Based on the above literature review, it can be seen that FJSPs with changes in worker efficiency, transmission time and conveyor constraints have received little attention. In real-world applications, the production line jam caused by workers can lead to the obsolescence of scheduling results. To address the thorny problems encountered by our industry partners, we modeled the problem as a CDFJSP, which is based on a real-world scheduling issue. We presented a heuristic algorithm based on the literature [25]. In this research, an effective hybrid algorithm has been proposed for the FJSP in static scheduling environment. Unlike previous research [16], we model the CDFJSP based on conveyor’s carrying capacity, machine in-between transmission time, and worker’s real-time proficiency, which are more practical implications to update the scheduling result in order to cope with dynamic situations. Attributed to the powerful global searching ability of GA by considering the constraint of the conveyor capacity, the optimal solution can be obtained with a satisfactory time cost. In order to solve the FJSP effectively, we also use binary search for the efficiency of decoding. On the other hand, we develop the RDRP, a real-time method, which integrates logic inequalities to determine the optimal selection of workers based on the real-time information. Moreover, in this research, we tackle one job at a time to achieve the sub-second response in RDRP due to its real-time job assignment.

Scheduling models with real-world constraints
In this section, we firstly present the scheduling problem for CDFJSP. Then, we propose an incremental model for CDFJSP. The implementation details of our proposed models are illustrated.

Overview of our framework
The flexible work-shop scheduling is more complex than the traditional work shop scheduling problem. In CDFJSP, some constraints and conditions based on real-world applications are considered into the procedure of GA for performing local search. The basic workflow of the CDFJSP is shown in Fig. 1. All details of the proposed CDFJSP will be given sequentially in the following sub-sections. For clarity, the overall procedure of the CDFJSP is described as follows:

(1)
Load the jobs in order, and ensure that the number of jobs does not exceed the conveyor carrying capacity; update the workers’ proficiency database and get the latest worker efficiency.

(2)
Set up the parameters of the proposed CDFJSP, including the population size P, the number of iterations G, the selection probability 𝑝𝑟, the crossover probability 𝑝𝑐 and the mutation probability 𝑝𝑚, etc.

(3)
Initialize the population and set Gen = 1 (here, Gen is the current generation).

(4)
Evaluate every individual in the population through the objective function.

(5)
If the termination criterion (when the number of generations reaches to the maximum value) is satisfied, go to Step (7); or else, go to Step (5).

(6)
Perform selection, crossover and mutation operators to generate the new population.

(7)
Set Gen = Gen + 1, and go to Step (3).

(8)
Output the best solution.

(9)
Use the solutions accomplished at the Step (7) to perform the incremental model.

(10)
If unexpected situations occur (for example, some workers are not in the work station, or assemble line jam happens), go to Step (1).

Moreover, a real-time scheduling system (RDRP) which solely relies on some dispatching rules of the production line is developed in order to determine which worker is the best choice based on the real-time information. The overall workflow of the proposed two models is shown in Fig. 1.

Fig. 1
figure 1
Overview of our systematic framework

Full size image
Scheduling for CDFJSP
Notation
The jobs in our industrial partner are divided into batch-line jobs and product-line jobs. However, for both batch-line or product-line, the minimum processing unit that may be some parts of fixed number products to be processed is an already matched and marked basket for machines (workers), which is called ‘job’ in CDFJSP. Let 𝐽={𝐽1,...,𝐽𝑛} denote a set of jobs, 𝑀={𝑀1,...,𝑀𝑚} be a set of machines, and 𝑊={𝑊1,...,𝑊𝑤} be a set of workers, each of which has been assigned to a corresponding station at the beginning of the schedule. Each job 𝐽𝑛∈𝐽 consists of a sequence of operations 𝑂𝑗𝑖={𝑂𝑗𝑖,1,...,𝑂𝑗𝑖,𝑘}, where k is the number of operations that 𝑂𝑗𝑖 comprises. Each operation 𝑂𝑗𝑖,𝑘 can be executed on a subset of compatible machines ( 𝑀𝐽𝑖,𝑘∈𝑀𝑚). The workers are multi-skilled and machines are multifunctional, that is, the skill of a station is the intersection of worker’s skill and machine function. In addition, the operating time is calculated based on user proficiency in each operation 𝑃𝑟𝑤𝑗𝑖,𝑘. If the standard process time for each operation is 𝐼𝐸𝑂𝐽𝑖,𝑘, then the operating time is 𝑇𝑂𝐽𝑖,𝑘=𝑃𝑟𝑤𝑗𝑖,𝑘×𝐼𝐸𝑂𝐽𝑖,𝑘. Thus, the CDFJSP problem can be defined as the 𝑛×𝑚 FJSP [38], if 𝑀𝐽𝑖,𝑘=𝑀𝑚 for all operations, we have a fully flexible problem. For clarify, a simple process of CDFJSP is illustrated in Fig. 2.

Fig. 2
figure 2
Scheduling for CDFJSP

Full size image
The CDFJSP problem is thus can be decomposed into two sub-problems: the machine selection problem (MS) and the operations sorting problem that can assign each operation to an appropriate machine, and to sort the operations on the machines to satisfy some criteria. The constraints and conditions in this problem are illustrated as follows:

(1)
Jobs are independent from each other. The operations among different jobs have no precedence constraints. Nonetheless, the operations in the same job cannot be processed simultaneously and each machine can handle one job at a time.

(2)
Machines are independent from each other, and a machine can only execute one operation at a given time.

(3)
Job preemption is not permitted. That is, each operation must to be completed without interruption, once it starts.

(4)
All jobs and machines are available at the beginning point.

(5)
After a job is processed on a machine, the conveyor transfer time must to be taken into account when the job is transported to the next machine.

(6)
Operating time is calculated based on user proficiency.

(7)
The number of tasks during each scheduled cycle cannot exceed the maximum loading of the conveyor belt.

For clarity, Table 1 shows an example of CDFJSP including three jobs and three machines. The number of the operations of each job, processing time and operating time are presented. For example, the processing time of 𝑂1,1 on machine 𝑀2 is 𝑇𝑂1,1,2=4, and the processing time on machine 𝑀3 is 𝑇𝑂1,1,3=6. Symbol ‘-’ means that a machine cannot execute the corresponding operation. In other words, it does not belong to the subset of the intersection of worker skill and machine function for that operation.

Let 𝐶𝑗𝑖 be the completion time of the job 𝐽𝑖. The objective of this problem is to assign each operation to an appropriate machine, and to sequence the operations on machines in order to minimize the maximal completion time of all operations:

𝐹 = min𝑗𝑖∈𝐽{max𝑗𝑖∈𝐽 𝐶𝑗𝑖|𝑖=1,2,...,𝑛}
(1)
Table 1 Example of a three-job, three-machine problem
Full size table
Encoding and decoding scheme
In FJSP, each chromosome represents a solution to a problem. Encoding of an individual is critical for an application of GA to such a scheduling problem. In the CDFJSP, the encoding method which can always get a feasible solution in [38] for FJSP is adopted. The solution is a combination of machine assignment and operation sequencing decisions in CDFJSP. Thus, the chromosome includes two strings: the first one is the operations sequencing (OS) string that is utilized to determine the sequence of operations; and the second one is the machine selection (MS) string that is used to assign the corresponding operation to a machine. In addition, it is worth noting that the machine sequence in MS is sorted corresponding to the operation sequence in jobs, and it is unrelated to the OS string, which ensures a feasible solution after crossover or mutation.

Fig. 3
figure 3
Chromosome

Full size image
Figure 3 shows a chromosome that includes the OS string and the MS string. The OS string is operation-based which is comprised of the jobs’ numbers, and the MS string denotes the selection of machines for the corresponding operations of each job. The sequence of operation processed and the corresponding machines shown in Fig. 3: (𝑂11,𝑀2),(𝑂21,𝑀3),(𝑂12,𝑀1),(𝑂31,𝑀2),(𝑂22,𝑀1), (𝑂32,𝑀3), the processing time sequence is [4, 4, 5, 7, 7, 6].

The decoding process aims at converting chromosomes into dispatch solutions. The solution is formulated by one OS string and one MS string. In our system, an active schedule decoding method that uses a plug-in greedy algorithm and a binary search algorithm is adopted into CDFJSP. The notations utilized to illustrate the decoding procedure are given in Table 2.

Table 2 Notations used in decoding process
Full size table
Step1: Input a gene in the OS string and transfer it to an operation u.

Step2: Check the idle time of the machine of the operation u and obtain the idle areas [(𝑑𝑠1,𝑑𝑒1),(𝑑𝑠2,𝑑𝑒2),...,(𝑑𝑠𝑛,ℚ)] (if 𝑑𝑠𝑛 is 0, then the idle time is [(0,ℚ)]).

Step3: Use the binary search algorithm to check the idle areas (if 𝑚𝑎𝑥(𝑆𝑇𝑀𝑃[𝑢]+𝑝𝑢,𝑆𝑇𝐽𝑃[𝑢]+𝑝𝑢+𝑇𝐽𝑃[𝑢]<=𝑑𝑒𝑖), else: check the next idle area).

Step4: Generate the idle sets based on the starting time and completion time for every operation of every job.

Step 5: Evaluating whether the gene of the OS string has been completed, if satisfied, to end; else, to Step 1.

The sets of starting time and completion time for each operation can be achieved based on the above procedure, that is, the schedule can be decoded to a schedule as shown in Fig. 4.

Fig. 4
figure 4
Gantt chart for decoding

Full size image
Selection
The selection scheme in a GA is to make high-performance individuals survive with a greater probability according to the fitness, and to determine how the next population of solution is created. In this paper, two selection operators are adopted. The first one is the tournament selection scheme. In this tournament selection, two individuals are selected randomly from the population and the individual with better fitness is selected when the random value (randomly generated between 0–1) is less than a predefined selection probability value (generally set to 0.8). In this way, a tradeoff can be made between exploration and exploitation of the gene pool. The other one is the elitist selection scheme which reproduces a certain number of individuals base on 𝑝𝑟×𝑝𝑜𝑝𝑠𝑖𝑧𝑒 (where 𝑝𝑟 is the reproduction probability; popsize is the size of population) considering their fitness values.

Crossover
The main genetic operation in GA is crossover which determines the global search capability of GA. Some popular crossover schemes in GA include Single Point Crossover (SPX), Multiple Point Crossover (MPX), Position-based Crossover (PX), Job-based Order Crossover (JOX), and Precedence Preserving Order-based Crossover [26]. In our system, two crossover operators have been adopted for the OS string and MS string, respectively. The first one is IPOX (an improved algorithm based on the POX) [26]. Another operator is a uniform crossover (UX) that has been adopted for the MS string. The implementation details of crossover operators are elaborated as follows.

(1) IPOX procedure in OS string:

Fig. 5
figure 5
IPOX crossover for OS

Full size image
In IPOX, chromosomes can inherit the properties of parent individuals better, because each individual can perform multiple operations. The basic working process is described as follows:

Step1: The job set 𝐽=𝐽1,...,𝐽𝑛 is divided into two groups, 𝜑1 and 𝜑2, randomly;

Step2: Any elements in the parent chromosome P1/P2 which contained the set 𝜑1 / 𝜑2 are copied to the same position in the offspring C1/C2, and are then deleted in P1/P2.

Step3: The remaining elements in P1/P2 that are not included in set 𝜑1 / 𝜑2 are copied to the offspring C2/C1, which need to maintain their empty positions.

Figure 5 shows an example of the IPOX crossover operator. There are five jobs and one of the job set is equal to 1,3. The gray part in P1 that includes job1 and job3 is appended to C1. We then delete the job1 and job3 in P2 and append the remaining white part in P2 into C1 to produce new individuals.

(2) UX crossover in MS string:

In UX operator, since every gene in this string denotes the selected machine for the fixed operations, the sequence of each gene must remain unchanged in the whole searching process. This crossover can ensure to generate feasible offspring if the selected parents are feasible. The basic process of UX crossover is described as follows:

Step1: Randomly select two positions A and B in the parent chromosome P1/P2 (the values of the two positions are different).

Step2: The elements in P1/P2 which in the position A and B are appended to the offspring C1/C2 sequentially.

Step3: The remaining elements in P1/P2 are appended to the empty positions in C1/C2 sequentially.

Fig. 6
figure 6
UX crossover for MS

Full size image
Figure 6 shows an example of the UX crossover operator. There exist 5 jobs, and we randomly generate two different positions in P1/P2 where the second position and the fourth position are chosen in P1 and P2. The gray part in P1/P2 is appended to C1/C2. Then, append the remaining white part in P1 into C2, while the white part in P2 is appended into C1 to produce C1 and C2.

Mutation
In this research, two mutation operators have been adopted for the OS string and MS string, respectively. For OS string, the mutation operator is the neighborhood mutation method [27] which performs well for the chromosome generation. On the other hand, we design a random selection mutation operator method for MS string in our system.

(1) The mutation operator for OS string is the neighborhood mutation method. The basic working procedure of this method is described as follows:

Step1: Randomly select r elements in the parent string P1 (which is dependent on the string size, typically 3), and generate all the neighborhood OS strings;

Step2: Randomly choose the one in the neighborhood OS strings and set it as the current offspring;

Fig. 7
figure 7
Neighborhood mutation for OS

Full size image
Figure 7 describes an example of the neighborhood mutation. The first, second and fifth positions are selected. Then, five neighborhood OS strings are generated. One of them is selected randomly as the offspring.

The mutation operator for MS string is the random selection mutation method which can be described as follows:

Step1: Randomly select r positions in the parent P (r is the half of the length of the MS string);

Step2: For each position, change the value of this selected position to the other machine in the machine set that has the minimum processing time of the corresponding operation.

Fig. 8
figure 8
Mutation for MS

Full size image
Figure 8 shows an example of the mutation operator for MS string. In this example, three different positions are chosen. The first, second and fourth positions are selected. They represent the selected machines for 𝑂21, 𝑂31 and 𝑂22, respectively. The offspring is generated by changing the values of these positions to the other machines in the machine set of the corresponding operation.

The Incremental model for CDFJSP
After using the aforementioned model to get the scheduling plan, we need to use an incremental model to ensure that the production line can complete line jobs according to the scheduling results. When workers complete an operation, they need to punch a clock to record the current production status. At this time, incremental model will ensure the production line to carry out stable and ordered production operations.

According to the card information, the incremental model determines which machine the job is transferred to, i.e., the job direction. In addition, the incremental model determines whether new jobs should be added to the production line, i.e., job addition. Workshop production line is often affected by external factors, such as personnel changes or occurrence of assembly line jam. In case of special circumstances, a production line is often unable to carry out production according to the original scheduling plan. Therefore, an incremental model is highly demanded in order to address these special cases in real time.

The model of arranged jobs
When a machine 𝑀𝑠𝑟𝑐 completes an operation 𝑂𝐽𝑠𝑟𝑐,𝑣, the incremental model decides the current job 𝐽𝑠𝑟𝑐 which a machine 𝑀𝑑𝑠𝑡 flows to and which job 𝐽𝑑𝑠𝑡 flow to the machine 𝑀𝑠𝑟𝑐 (𝑂𝐽𝑠𝑟𝑐,𝑣∈𝑂𝑗𝑖,𝑀𝑠𝑟𝑐,𝑀𝑑𝑠𝑡∈𝑀). The procedure to determine which machine 𝑀𝑑𝑠𝑡 the current job 𝐽𝑠𝑟𝑐 will flow to is designed as described in Algorithm 1.

figure a
The model of loading new jobs
In order to load new jobs, it is important to determine which job 𝐽𝑑𝑠𝑡 is to flow to the machine 𝑀𝑠𝑟𝑐, the procedure of the algorithm is described as Algorithm 2.

figure b
If workers work continuously for a long time, their efficiency usually decrease. As a result, the original scheduling scheme may fail. In addition, workers are often transferred during working hours. For example, a worker leaves the station temporarily due to personal reasons, or a new worker joins the work. When such a special situation occurs, the incremental model calls the static scheduling model to obtain a new scheduling plan (the idle time list should be reset if there exists some unfinished jobs), and the production line executes production operations according to the new scheduling plan in real-world applications.

Real-time scheduling system
A real-time scheduling system (RDRP) is proposed by depending on some dispatching rules of the production line, that is, to determine which machine (worker) is the best choice based on the real-time information.

When a machine 𝑀𝑠𝑟𝑐 completes an operation 𝑂𝐽𝑖,𝑘(𝑠𝑟𝑐,𝑘∈𝑂𝐽𝑖), one can select the optimal machine 𝑀𝑑𝑠𝑡(𝑀𝑠𝑟𝑐,𝑀𝑑𝑠𝑡∈𝑀) to perform the next operation 𝑂𝐽𝑠𝑟𝑐,𝑘+1 according to the situation of the production line. First, we can find all of machines that can perform the job 𝐽𝑠𝑟𝑐. We use machine skills 𝑆𝑂𝑖,𝑀𝑚 to mark on whether machine 𝑀𝑚(𝑀𝑚∈𝑀) can do the operation. The processing time of an operation 𝑂𝐽𝑖,𝑘∈𝑂𝐽𝑖 of job 𝐽𝑖,𝑘∈𝐽𝑖, is denote by 𝑇𝑂𝐽𝑖,𝑘,𝑀𝑚. If the machine can do the operation, we set 𝑆𝑂𝐽𝑖,𝑘,𝑀𝑚=1, else 𝑆𝑂𝐽𝑖,𝑘,𝑀𝑚=0. If a machine can do continuous operations, we define 𝑁𝑂𝐽𝑖,𝑀𝑚=𝑚𝑎𝑥(∑𝑛𝑘=1𝑆𝑂𝐽𝑖,𝑘,𝑀𝑚), which indicates the number of continuous operations 𝑀𝑚 can do from the operation 𝑂𝐽𝑖,𝑘 in job 𝐽𝑖. We assume that the moving time of each machine is the same. Let 𝑑𝑀𝑖,𝑀𝑗 represent the distance from machine 𝑀𝑖 to 𝑀𝑗, and the maximum distance is denoted by 𝑑𝑚𝑎𝑥. When we use dispatching rules to choose the optimal result, it is necessary to normalize each result of the rules. The normalize distance is denoted by 𝐷𝑀𝑖,𝑀𝑗=(𝑑𝑀𝑖−𝑑𝑀𝑗+𝑑𝑚𝑎𝑥)/𝑑𝑚𝑎𝑥. The three score 𝑁𝑂𝐽𝑠𝑟𝑐,𝑖+1,𝑀𝑚,𝑇𝑂𝐽𝑠𝑟𝑐,𝑖+1,𝑀𝑚 and 𝐷𝑀𝑖,𝑀𝑗 are used to choose the candidate workers. After the score 𝑁𝑂𝐽𝑠𝑟𝑐,𝑖+1,𝑀𝑚,𝑇𝑂𝐽𝑠𝑟𝑐,𝑖+1,𝑀𝑚 and 𝐷𝑀𝑖,𝑀𝑗 normalization, we sum the three scores up and select two candidate machines with the highest score for a further selection. The algorithm is designed as follows:

figure c
Experiment
In order to evaluate the performance of our approaches, we conducted extensive experimental verifications, which were performed on a PC with an Intel(R) Core (TM) i5-8250U CPU, running at 1.80 GHz, and 8 GB of RAM under a 64-bit version of Windows8. All algorithms were implemented in Python (PyCharm 2020.1 x64). Specifically, in our implementations, WTFJSP refers to the model that has different constraints with CDFJSP as presented in Sect. 4.1. This approach is intended to work under a different scenario for evaluating the performance of CDFJSP. The tasks were split according to the conveyor’s carrying capacity for evaluating its influence on WTFJSP and CDFJSP.

The WTFJSP model
The WTFJSP is a model based on GA for FJSP. In this research, the WTFJSP and CDFJSP are designed for different scenarios. The CDFJSP is motivated by a real-world problem setting, in which the operation time of a job in the production line is almost equal to the transfer time between different machines, that is, the transmission time has a great influence on the scheduling results. For some industrial applications, however, the transmission time is usually assumed to be negligible. It thus has slight influence on the scheduling [16]. In WTFJSP, we set the transmission time between two work stations is 0.6s which can be igonred compared to the operation time. This model is in line with the formulations mentioned in Sect. 3.2, but replaces the Step 3 of decoding method in Sect. 3.2.2 to use the binary search algorithm to check the idle areas (if max (𝑆𝑇𝑀𝑃[𝑢]+𝑝𝑢,𝑆𝑇𝐽𝑃[𝑢]+𝑝𝑢)≤𝑑𝑒𝑖, the starting time max(𝑆𝑇𝑀𝑃[𝑢],𝑆𝑇𝐽𝑃[𝑢])≥𝑑𝑠𝑖; or else, check the next idle area).The objective function is to minimize the maximal completion time of all operations and other constraints are identical to the ones in the CDFJSP. Furthermore, in order to illustrate the effectiveness and performance of the proposed method, the simulated annealing optimization algorithm (SAOA) [22] which yields the same constraints with WTFJSP.

Instance generation and parameter settings
Random testbed for transmission time
Our tests about the transmission time were performed on randomly generated test instances that belong to three classes of instance sets. They were small, medium and large instance sets according to the data sizes. Each class is composed of eight sets of test instances with differing numbers of jobs I and machines M. The schedule size of the problem is denoted by 𝑆𝑖𝑧𝑒|𝐼|×|𝑀|. |𝑂𝑖| denotes the number of jobs 𝑖∈𝐼 and the eligible machine is denoted as 𝑚𝑂𝑖,𝑗(𝑚∈𝑀) that can do operation 𝑂𝑖,𝑗 for 𝑂𝑖,𝑗∈𝑂𝑖. The process of generating test data of the operations is described as follows (assuming that machines/workers can perform all operations of jobs in order to test the lower limit efficiency of different models). We firstly designed the parameters of each model which are set by the identifier 𝑆𝑖𝑧𝑒|𝐼|×|𝑀|. Since in the real-world application, the maximum size of the conveyor capacity is 55 and the number of workers in a cell is between 23 and 27, the maximum size of the test data that we set was 𝐿55×55. Subsequently, we constructed varied processing time over the corresponding eligible machines 𝑇𝑚𝑂𝑖,𝑗 for 𝑚𝑂𝑖,𝑗∈𝑚 from uniform distributions over [0.5,1.5] (0.5 minutes is the minimum operation time in the real world and 1.5 is the maximum operation time) as given in Table 3. In the last step, we set the selection probability 𝑝𝑟=0.5, the crossover probability 𝑝𝑐=0.8 and the mutation probability 𝑝𝑚=0.1 for all sizes, and the size of the population (popSize) and maximum value (maxGen) were set based on the data sizes given in Table 3.

Table 3 Notations used in decoding process
Full size table
In order to test the impact of transmission time on scheduling results with respect to the parameters shown in Table 3. We set the transmission time (Tran) between two adjacent machines into three types of data for each schedule size in Table 3. The first one is much less than the minimum execution time 𝑇𝑟𝑎𝑛𝑚𝑖𝑛=0.1(𝑠), that is, the maximum transmission time between 𝑚1 and 𝑚25 is 0.24s. The second one is similar to the operation time of jobs which we set 𝑇𝑟𝑎𝑛𝑚𝑒𝑑𝑖𝑢𝑚=0.06(𝑚𝑖𝑛) and the maximum transmission time between 𝑚1 and 𝑚25 is 1.44 min. The last one is much larger than the operation time of jobs set as 𝑇𝑟𝑎𝑛𝑙𝑎𝑟𝑔𝑒=2(𝑚𝑖𝑛) and the maximum transmission time between𝑚1 and 𝑚25 is 48 min. Here, we calculated the distance between different machines in the form of:

𝑓(𝑥)={(𝑘−𝑣)×𝑇𝑟𝑎𝑛,(𝑣−𝑘+𝑛)×𝑇𝑟𝑎𝑛,𝑘≥𝑣(𝑘,𝑣∈𝑀)𝑘<𝑣(𝑘,𝑣∈𝑀)
(2)
Real-world instances for conveyor carrying capacity
As mentioned in Sect. 1, our system is motivated by a real-word problem. The production data include the standard processing time on eligible machines and worker skill proficiency, as well as the customer demands (the standard production cycle) over a time period of several months. In addition, we were provided with the information on conveyor carrying capacity. Based on these data, we constructed ten realistic scheduling scenarios with the maximum amount of data for examining our algorithms. The tasks were split according to the conveyor carrying capacity (55) in ten types of data. The split size was set from 10 to 55 with an increment of 5. The problem size is 100×180, where 100 is the job size and each job contains 180 operations. The parameters of GA were predefined as: popsize = 100, maxGen = 100, 𝑝𝑟=0.5, 𝑝𝑐=0.8, 𝑝𝑚=0.1. According to these ten types of data, we are able to observe the optimal solutions and processing time for flexibly tackle emergency scenarios in CDFJSP and WTFJSP.

The instances for RDRP
The data for RDRP were simulated according to the scale of small-sized production lines. For example, a production line was composed of ten workers, ten machines, and five kinds of jobs. The number of operations included in each job was drawn from uniform distribution [4, 7], the number of operations each worker can do was drawn from uniform distribution [11, 18], and the number of operations that can be produced by each machine was drawn from uniform distributed in [18, 33]. Based on these attributes, a part of operations was extracted from the operation set with equal probability. Similarly, the types of operations included in each job and the types of operations that can be produced by each machine can be obtained.

Results and analysis
Results for random testbed instances for transmission time
The performance of WTFJSP in comparison with CDFJSP is illustrated in Table 4 for the small test instances of our random testbed. For each instance set, each approach and each objective function, the result present information on the average makespan (the objective function) values of the best solutions returned by respective approaches (columns 𝑀𝑆𝑚𝑖𝑛) as well as the average runtimes (columns 𝑇𝑎𝑣𝑔) in each iteration for computing these solutions.

Table 4 shows the experimental results of our two approaches WTFJSP and CDFJSP comparisons with SAOA. The results marked by * are the best results among all these algorithms. We observe that in small instances our WTFJSP and CDFJSP can get the optimal solution in a certain amount of time, and the efficiency of the algorithms was slightly affected by the transmission time. However, in the scenario of CDFJSP, the time of an operation of a job is equivalent to the sum of operation time and extra transmission time. For instance, if each job’s operation time is 0.5 sec and the transmission time between the machine1 and machine 15 is 0.9s, the real time of this job that is transferred from machine1 to machine 15 is 0.14s, which is nearly a triple of the job execution time. Hence, the optimal solution of CDFJSP is always larger than that of WTFJSP. For clarity, Fig. 9 illustrates the Gantt chart of the problem WTFJSP in of small instance. The colored box represents operation time of jobs, and the black box represents the transmission time of conveyor belt.

Table 4 Experimental results of small instance
Full size table
Fig. 9
figure 9
Gantt chart of problem WTFJSP in 𝑆9×5 of small instance

Full size image
We observe large differences in the average solution qualities for different problem sizes, 𝑇𝑟𝑎𝑛𝑚𝑖𝑛, 𝑇𝑟𝑎𝑛𝑚𝑒𝑑𝑖𝑢𝑚, 𝑇𝑟𝑎𝑛𝑙𝑎𝑟𝑔𝑒, as shown in Tables 4, 5 and 6, respectively. The Gantt chart of the problem WTFJSP in 𝑀30×15 of medium instance is visualized in Fig. 10. In 𝑇𝑟𝑎𝑛𝑚𝑖𝑛 scenarios, transfer time can bring positive impact as the total transfer time was reduced for all jobs. However, when the transmission time is similar to the operation time, the scheduling results look quite bad and even worse for the type of 𝑇𝑟𝑎𝑛𝑙𝑎𝑟𝑔𝑒. It indicates that transmission time has a significant effect for scheduling. In summary, if the transmission time of the industry is closer to the job operation time, operations can be combined into large processes according to worker skills in order to minimize the impact of transmission time.

Table 5 Experimental results of medium instance
Full size table
Fig. 10
figure 10
Gantt chart of problem WTFJSP in 𝑀30×15 of medium instance

Full size image
Table 6 Experimental results of large instance
Full size table
Results for real-world instances with conveyor carrying capacity
Table 7 illustrates the runtime and objective function values determined by CDFJSP and WTFJSP. The time shown in Table 7 was the total time for the case of 100*180 after split the jobs in order to unify the time dimensions. As can be seen, the case with CPT= 55 outperforms than other parameters with respect to the average objective function values (with the server configuration of our system, the case with CPT=55 can be solved in 5 minutes). This effect becomes obvious for the objective of minimizing makespan. Our system can perform better in schedule results when the conveyors have larger carrying capacity. But the average computational time of CPT=10 can get feasible solution in 35s (3.5s at a time) which can quickly respond to emergent scenarios and provide the scheduling results.

Table 7 Performance for real-world instances
Full size table
The size of the conveyor constraint is utilized to trigger incremental scheduling. Even if an unexpected scenario occurs, the scheduling can restart again in a limited time. Thus, our optimization system can effectively respond to unexpected scenarios at the same time to get a relatively optimal solution for a period of time. To sum up, the constraints and the decoding method in FJSP as well as the algorithms applied to determine these solutions should be all considered when attempting to balance the tradeoff between runtime and solution quality, especially in addressing medium or large instances. Moreover, the workers’ skills, the number of machines and the proficiency of worker skills have major influence on the performance of scheduling algorithms.

Results for RDRP
Table 8 shows the scores of the real-time scheduling scheme on the simulated production line. To compare the scheduling results, Table 9 also gives the score of the random allocation scheme. ‘score1,’ ‘score2,’ and ‘score3’ are the scores of selected operations according to three conditions set in Sect. 3.4, score1 is 𝑁𝑂𝐽𝑠𝑟𝑐,𝑖+1,𝑀𝑚, score2 is 𝑇𝑂𝐽𝑠𝑟𝑐,𝑖+1,𝑀𝑚 and score3 is 𝐷𝑀𝑖,𝑀𝑗. According to the requirements by the real industry scenarios, the weight of score1, score2 and score3 are, respectively, 0.6, 0.3 and 0.1, then, the final score is 0.6 × score1 + 0.3 × score2 + 0.1 × score3. It can be seen that the scheduling through the real-time scheduling scheme has a higher score. In fact, if operations are randomly assigned to the machine, the results become worse as the current state and the differences between machines are not fully taken into account. On the contrary, the real-time scheduling scheme can make the production line more efficient.

Table 8 Score of real-time scheduling scheme
Full size table
Table 9 Randomly assigned scheme score
Full size table
Conclusion
In this paper, we have introduced a worker-constrained flexible job shop scheduling problem with transmission time and conveyor constraints. An effective CDFJSP has been proposed to solve the dynamic scheduling problem, and a real-time based method, RDRP, was introduced to solve the real-time scheduling problem. In CDFJSP, we have analyzed the objective to minimize the makespan. Three types of data have been used to test the effects of transmission time. The results demonstrate the effectiveness of the proposed CDFJSP for solving the FJSP in solution quality and computational time. Our system also addressed the cases well in terms of emergency insertions or changes in employee proficiency. In practice, the decisions on the frequency of computing solutions as well as on the algorithms applied to determine these solutions are of major importance for finding a suitable trade-off between runtime and solution quality. In the future, we can combine other algorithms in evolutionary algorithms and other LS methods to construct more effective hybrid algorithms to solve the scheduling problems. On the other hand, developing multi-objective methods for FJSP deserves further investigation in future work.

Keywords
Flexible job shop
Task scheduling
Genetic algorithm
Combinatorial optimization
Intelligent manufacturing
