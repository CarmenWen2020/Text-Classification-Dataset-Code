The rapidly expanding nature of the Internet of Things (IoT) networks is beginning to attract interest across a range of applications, including smart homes, smart transportation, smart health, and industrial contexts such as smart robotics. This cutting-edge technology enables individuals to track and control their integrated environment in real-time and remotely via a thousands of IoT devices comprised of sensors and actuators that actively participate in sensing, processing, storing and sharing information. Nonetheless, IoT devices are frequently deployed in hostile environments, wherein adversaries attempt to capture them in order to seize control of the entire network. One such example of potentially malicious behaviour is the cloning of IoT devices, in which an attacker can physically capture the devices, obtain some sensitive information, duplicate the devices, and intelligently deploy them in desired locations to conduct various insider attacks. A device cloning attack on IoT networks is a significant security concern since it allows for selective forwarding, sink-hole, black-hole, and warm-hole attacks. To address this issue, this paper provides an efficient scheme for detecting clone node attack on mobile IoT networks that uses semantic information of IoT devices known as context information to locate them securely. We design the location proof mechanism by combining location proofs and batch verification of the extended elliptic curve digital signature technique (ECDSA*) to accelerate the verification process at selected trusted nodes. Furthermore, we present a model for selecting trustworthy IoT devices based on their profile capabilities, enabling them to be chosen from the other IoT devices for the location proof-verification procedure. Compared with existing studies, the performance analysis and experimental results suggest that our proposed scheme provides a high degree of detection accuracy with minimal detection time and significantly reduces the computation, communication, energy and storage overheads.


Keywords
Internet of Things
Clone node attack
Clone detection
Replica node detection
Context-aware information
Location proof

1. Introduction
The Internet of Things (IoT) is an emerging and promising network paradigm, consisting of a large number of devices that provide people and objects with the means to interact, communicate and share data for multiple purposes (Al-Fuqaha et al., 2015). The devices included in IoT networks are typically mobile, heterogeneous in nature, and placed in a diverse environment to collect data and information that is sent to specific managing authorities, e.g. clouds, for analysis or decision-making refinement (Díaz et al., 2016). For example, IoT-based smart home features a variety of automated devices, including smart refrigerators, thermostats, doorbells, security alarms, and so on., which allow homeowners to control and manage their homes remotely and to inform them when suspicious activity occurs in their absence (Alaa et al., 2017). Further, the IoT-based vehicular network enables vehicles on the road to connect and communicate bidirectionally with other mobile vehicles and road facilities to support critical communications and actions (Guerrero-Ibanez et al., 2015). Few other prominent IoT-based applications are smart cities (Zanella et al., 2014), smart grids (Yun and Yuxin, 2010), smart health (Qadri et al., 2020), and IoT-based industries, such as supply-chain management (Wollschlaeger et al., 2017).

Apart from providing quality services to users in their several day-to-day routine activities, IoT devices have experienced a large number of attacks ranging from security threats to privacy concerns due to the limitations of their functional capabilities (i.e., computing, storage, energy), heterogeneous design, restricted features, improper standard guidelines and lack of advanced security protocols (Yang et al., 2017). For example, IoT devices are primarily non-tempered resistant and versatile, so malicious attackers can easily compromise the authentication mechanisms and take control of the available devices in the IoT network (Frustaci et al., 2017). Thus, a clone node attack is an attack on IoT devices that specifically targets the authentication mechanism. Clone node attack is also known as device replication attack or device cloning attack (Parno et al., 2005). Since a cloned node has access to all secret information (authentication codes and keys), it behaves similarly to legitimate nodes and engages in network-related other malicious activities such as a selective forwarding attack, wormhole attack and blackhole attack (Raza et al., 2013).

In a clone node attack, the attacker can capture the physical devices from the IoT network by extracting their secret credential, including ID, public and private keys. There are several steps to exploiting this vulnerability which involve capturing the physical device, obtaining the secret credentials, modifying its function, and placing it back in the network at some desired location (Numan et al., 2020). In most cases, IoT devices are designed and assembled by untrustworthy security partners and lack updated security firmware and certificates, which may contribute to the clone node attack (Becher et al., 2006). Thus, a clone node attack is regarded as the most severe attack in which claim to be legitimate nodes with the same credentials as original nodes. A scenario of clone node attack and its influence on IoT-based networks is illustrated in Fig. 1. In this scenario, an attacker successfully compromises the IoT network by obtaining the credentials of already-existing IoT devices and making clones that communicate with the server through a gateway or base station. The primary objective of the attacker in a clone node attack is first to make clones of captured IoT devices and then deploy those clone devices in specific geographic locations from which he can easily intercept communication or get personal data of users.

Detecting clone node attack on wireless sensor networks (WSNs) and IoT-based networks is a significant challenge, as an adversary can easily compromise an authentication process by creating that are identical to the legitimate node. The existing works demonstrate the efforts made by researchers and academia to detect clone node attack. For instance, one of the simplest ways to mitigate the risk of a clone node attack on a WSNs is for each device to periodically send a message to a base station via some data forwarding protocol, containing its information and the information of all its neighbouring devices. When the base station receives the message, it confirms its existence using a secret key previously shared between the particular node and the base station. However, these information-forwarding approaches (Raza et al., 2013, Xing et al., 2008, Shanmugam and Paramasivam, 2020) have a number of disadvantages when applied to large-scale sensor networks. For instance, when a forwarding information protocol requires each node to send information to the base station about its neighbouring nodes, the entire network could become congested with redundant information, resulting in additional communication and storage overhead. Additionally, this approach adds additional processing overhead to the verification process by verifying each piece of information separately. Moreover, adversaries can intercept, drop, and generate their authentication messages if a shared secret key is compromised. Another category of solutions for detecting clone node attack is based on a technique known as the “witness finding technique” in which nodes are required to discover the existence of the clone’s nodes based on their positions conflicting with those of other nodes in the network. In the witness finding technique, each device must maintain track of the information of their neighbouring witness nodes, such as public keys and location. However, existing works (Parno et al., 2005, Lou et al., 2012, Lalar et al., 2020, Mbarek et al., 2021) based on witness finding technique have limitations in terms of the usage of symmetric (e.g., AES) and asymmetric cryptographic algorithms (e.g., RSA), which proved insufficient when applied in resource-constrained IoT devices, resulting in increased computation and memory overhead. Furthermore, witness finding approaches enable users to deploy witness nodes and discover clones in specified targeted regions, leaving some compromised nodes unattended. Several other detection solutions for clone nodes have also been proposed, including routing and time-analysis (Devi and Jaison, 2020), threshold values (Rikli and Alnasser, 2016), set functions (union and intersection) (Choi et al., 2007), keys maximum usage (Brooks et al., 2007), and exponential smoothing algorithm (Alsaedi et al., 2017).


Download : Download high-res image (469KB)
Download : Download full-size image
Fig. 1. A scenario of clone node attack and its influence in IoT.

While the primary goal of the approaches mentioned above is to detect clone node attack using various detection mechanisms successfully, these designed approaches work best with static position patterns in which devices are deployed in fixed locations across the network (e.g., static networks) and are frequently inapplicable to detect clones in mobility environments. With the advent of Mobile Ad-Hoc Networks (MANETs) and the emergence of IoT networks with various applications, such as vehicular networks, devices are worked according to mobility position patterns and are frequently required to move around the network to collect data and communicate with other moving devices. As a result, detecting clone node attack on mobile networks is more challenging than in static networks. Until now, only a few mobility-assisted detection approaches have been proposed for detecting clone node attack on mobile sensors or MANETs. For example, Conti et al. (2014) proposed a clone node attack detection mechanism in distributed mobile sensor networks by enforcing each node to communicate with their neighbours for collecting their detail such as ID and location in only a one-hop communication pattern. However, similar to neighbour finding techniques used in existing static networks, mobile networks inherited the same information redundancy limitations, which occasionally resulted in network storage overhead. Similarly to the witness finding approach used in static networks, the centralised (Ho et al., 2009) and distributed (Zhou et al., 2016) approaches are proposed for detecting mobile clone nodes using sequential probability, and statistical hypothesis, respectively, for collecting samples from all neighbouring witness nodes and then forwarding them to the base station only when the relevant witnesses meet. A concept similar to witness finding is proposed in Shaukat et al. (2020), where a multi-level clone node attack detection scheme based on Danger Theory (DT) is proposed for mobile wireless sensor networks. Moreover, Yu et al. (2013) proposed a clone detection approach based on two localisation algorithms: eXtremely efficient detection (XED) and efficient distributed detection (EDD). Each node communicates with only its one-hop neighbours in the XED and EDD algorithms by exchanging random numbers to detect clone node attack, which essentially implies that nodes execute the task independently of the base station. However, the proposed approach has a shortcoming in terms of its ability to detect when clone nodes exchange the same random value. Lee et al. (2018) proposed a clone node attack detection mechanism for IoT networks based on a multidimensional scaling approach. This approach builds a network map by utilising the nodes’ relative neighbourhood-distance information. Since this strategy aims to achieve a high detection rate for clone node attack in the network, the network map building approach for the mobility behaviour of the device often incurred additional processing costs, resulting in a decrease in network efficiency.

1.1. Motivation and problem formulation
After conducting a comprehensive literature review on methodologies for detecting clone node attack in WSNs, MANETs, and a few IoT-based networks, we first define the security requirements and objectives for designing an efficient and mobility-based detection mechanism in IoT networks. Then, we derive the motivation and formulate a research problem for our proposed scheme by considering the security requirements, objectives, and gaps in existing works.

1.1.1. Security requirements
As with existing clone node attack detection approaches, an important security requirement of our proposed scheme is to secure IoT devices by preventing them from being captured physically, often through clone node attack. Furthermore, by preventing clone node attack, we prevent an attacker from introducing false data into the network, ensuring data sharing protection. Moreover, since an attacker may capture one or more devices and deploy them in various strategic locations, the security requirement is to prevent the attacker from gaining control of the entire network, resulting in a denial of service (DoS) or distributed denial of service (DDoS) attack. Finally, when trusted devices are used to execute verification tasks, we ensure that the security requirement of selecting trusted devices based on device profiling capabilities is met.

1.1.2. Objectives
To achieve the clone node attack detection objectives, the mechanism must be capable of identifying the mobility behaviour of IoT devices in response to changes in environmental conditions. A clone node attack detection mechanism must achieve a high detection rate of attacks in the network, which can be achieved by capturing and analysing the dynamic information of the network to track each activity of the attacker. The detection time is also a critical objective for designing the robust clone node attack detection system, as it enables adversaries to be detected in real-time. Additionally, IoT networks are frequently comprised of heterogeneous devices that are resource-constrained and incapable of performing computationally intensive activities or storing vast volumes of data. As a result, when designing the clone node attack detection mechanism, it is critical to take into account the computation, storage, and energy limitations of IoT devices.

1.1.3. Research gap
While existing schemes for detecting clone node attack have demonstrated the capacity to detect clone node attack on WSNs, MANETs, and a few IoT-based networks, these schemes have several shortcomings, which we summarise as follows. (i) The adherent challenges of integrating ad-hoc networks into IoT networks in terms of device addresses, context information awareness, information discovery techniques, and gateway node placement in mobile networks (Bruzgiene et al., 2017, Quy et al., 2021, Alshaker and Almutairi, 2021), (ii) A large number of existing approaches are primarily built for static types of networks (Parno et al., 2005, Raza et al., 2013, Xing et al., 2008, Shanmugam and Paramasivam, 2020, Lalar et al., 2020, Mbarek et al., 2021, Devi and Jaison, 2020, Rikli and Alnasser, 2016, Choi et al., 2007, Brooks et al., 2007, Alsaedi et al., 2017) that are incapable of detecting mobility behaviours of nodes in the network, (iii) The majority of techniques (Raza et al., 2013, Conti et al., 2014, Shaukat et al., 2014) detect clone node attack by utilising inherent device attributes such as ID and pre-defined position on a geographic map, however, they are unable to capture environment-related dynamic attributes of deployed networks, (iv) The techniques based on information-forwarding protocols (Raza et al., 2013, Xing et al., 2008, Shanmugam and Paramasivam, 2020, Conti et al., 2014, Quy et al., 2021, Bruzgiene et al., 2017) operated primarily in a centralised fashion in which all nodes collected redundant information about their neighbouring nodes and sent it to a central party for detection, resulting in increased storage, computation, and communication overheads on the base station side, (v) The witness-finding strategies (Parno et al., 2005, Lou et al., 2012, Lalar et al., 2020, Mbarek et al., 2021, Ho et al., 2009, Zhou et al., 2016) target clone clones within a specified and limited geographic area, leaving some clone nodes unattended, (vi) Some techniques (Lalar et al., 2020, Devi and Jaison, 2020, Brooks et al., 2007) detected clone node attack by utilising expensive cryptographic protocols such as AES (Advanced Encryption Standard) and Rivest–Shamir–Adleman (RSA), which required more power to perform the desired tasks and thus inefficient for resource-constrained IoT devices.

To overcome the shortcomings of existing clone node attack detection mechanisms and to accomplish the aforementioned objectives, we propose an efficient detection scheme for clone node attack on mobile IoT networks. In our proposed method, we used the concept of a context-aware system to capture the environment-related dynamic attributes (or so-called context-aware information) of deployed IoT devices in order to track their location and perform timely actions in the network. Context information is semantic information that helps users interpret the networking environment and then locate network entities based on their relationships with the environment. Furthermore, to minimise redundant information transmission and to cover the entire geographic area of a network, we proposed a location-proof system that works in conjunction with context-aware dynamic modalities information to detect adversary-deployed clone nodes. Besides this, in order to overcome the limitations of existing cryptographic schemes and reduce the computational load on the base station associated with verifying each individual signature, we used batch verification of ECDSA* (an upgraded version of the elliptic curve digital signature algorithm) to accelerate the verification process of location proofs. To select trusted devices for location proof verification, we proposed the trusted nodes model, which takes into account device profiling characteristics such as processing capability, sensed context information, and confidence credibility. Finally, in order to illustrate the feasibility and efficiency of our proposed solution in an IoT setting, we constructed a prototype and assessed its robustness in terms of detection probability, detection time, computing overhead, storage overhead, and communication overhead.

1.2. Contributions
The following are the main contributions to this work:

•
We propose an efficient clone node attack detection scheme for mobile IoT networks by leveraging the concept of context-aware systems to capture dynamic semantic attributes of IoT devices in relation to their deployed environment.

•
We design a location-proof system that makes use of captured context-aware dynamic semantic information to generate location proofs capable of tracking IoT devices regardless of their geographic location.

•
We present a model for selecting trustworthy IoT devices based on their profile capabilities, enabling them to be chosen from the other IoT devices for the location proof-verification procedure.

•
We implement a prototype of our proposed scheme to demonstrate its applicability to mobile IoT networks and compare its robustness and effectiveness in terms of computation, communication, and storage overhead to existing clone node attack detection schemes.

1.3. Paper organisation
The rest of the paper is organised as follows: Section 2 presents the background to our work and a detailed description of the existing clone node attack detection mechanisms and their comparative analysis. In Section 3, we describe the methodology of our proposed scheme, which includes network and attacker models, a description of the enhanced elliptic curve digital signature algorithms, and the proposed model for selecting trustworthy nodes. Section 4 discusses the working of our proposed location proof systems, including the algorithms and execution flow. The evaluation framework and performance analysis and results discussion of our proposed scheme is presented in Section 5 and Section 6, respectively. In Section 7, we discussed the working of our proposed scheme followed by the achieved objectives. Finally, in Section 8, we summarise our proposed work and discuss our future work.

2. Background and related work
This section first covers the background concepts of our work and then provides an overview of existing state-of-the-art clone node attack detection mechanisms with their strengths and limitation, as the related work.

2.1. Background
In the background section, we have included the following concepts, such as context-aware systems, location-proof systems, and batch verification, which describe their introduction, components, features, and their use in IoT networks.

2.1.1. Context-aware systems
The IoT-based network consists of a generous amount of connected devices stacked with a certain degree of intelligence that helps collect data from the deployed environment. These devices are expected to produce a large amount of data, which often requires careful identification, interpretation, and analysis to perform further action on it. A context-aware system is an exemplary IoT environment in which the mechanism is developed to keep track of surrounding objects and further help to provide timely feedback to the user or related applications (Abowd et al., 1999, Perera et al., 2013).

Context-aware systems are implemented in IoT-based environments to obtain the operational information from the landscaping eco-system and then respond appropriately to the users and applications. These systems analyse and translate data produced by IoT devices into contextual information, providing a high level of understanding of semantic data used for machine-integrated setup. In such systems, the server transforms the information stored in devices into a higher-level type and analyses it semantically before acting on it to perform further operations. Therefore, context information is the foundation that allows users to understand the networking environment and then locate the network entities by leveraging the relationships between the entities and the environment (de Matos et al., 2020).

Context information is used to describe the state of an environment, which is typically composed of the following primary entities: users, an application, a location, or a device. There are essentially two forms of contextual information used in the IoT environments, such as primary and secondary. In the primary context, the information is specified as name, time, location, activity, etc. Furthermore, the secondary context is any information that can be measured by using the primary context. For example, the sensor deployed in the smart city environment is capable of monitoring vehicle position information along with other information, such as vehicle identification, activity, time, and so on Sezer et al. (2017).

2.1.2. Location proof system (LPS)
Location-based services are primarily used to support a variety of services in diverse IoT-based applications, such as tracking and monitoring patients, tracking the location of vehicles on the road, and determining the actual position of an individual (Zafar et al., 2020a). However, it is critical and a difficult problem in most IoT-based applications to establish trust for the physical presence of any users and its operated devices at a specific location and time using an efficient, accurate, and robust method (Krishna and Lorenz, 2020).

To resolve this issue, LPSs are being developed in IoT-based applications, which provide a means for creating and sharing digitally signed context data to provide evidence of a particular user’s location at any point instance at a given time. Such systems provide secure proof of a user’s location, in which LPS first verify a location of a device at a given time and then grant the additional access needed for a particular device (Sun et al., 2017). Additionally, it may also facilitate the process of establishing evidence for a variety of location-based scenarios, including a single location, travel route history, and event summaries such as running and walking (Zafar et al., 2020b).

2.1.3. Batch verification
With the proliferation of IoT applications ranging from home to large-scale industrial setups and adopting advanced communication protocols, security has evolved into an integral component of IoT networks. To guarantee the security of IoT devices and the data they transmit, digital signatures are used to verify the authenticity of the devices or messages during communication (Alamer, 2020). However, since IoT network scalability is critical in most applications, verifying individual IoT device signatures is a time-consuming process that is not recommended in IoT systems. It is possible, however, to significantly minimise verification time by verifying digital signatures in batches.

Batch Verification is a concept that involves verifying multiple signatures simultaneously in order to minimise the time taken to validate each signature generated by thousands of sensor nodes in large-scale IoT networks. The benefit of applying the batch verification concept to IoT networks is that it considerably reduces the computation load and time required by IoT devices by confirming multiple digital signatures simultaneously (Kittur and Pais, 2017, Hu et al., 2019). Numerous batch verification methods have been proposed for several cryptographic protocols, including the Digital Signature Algorithm (DSA) (Naccache et al., 1994) and the RSA (Harn, 1998). However, these protocols are not appropriate to IoT devices due to their resource scarcity. Recent years have seen a surge of interest in the use of ECDSA in IoT applications, owing to the smaller key and signature sizes needed by ECDSA compared to DSA and RSA. However, the implementation of batch verification of these protocols is not immediately applicable to ECDSA signatures (Karati et al., 2012).

2.2. Related work
This section details the existing detection mechanisms for clone node attack on WSNs, MANETs and IoT-based networks. Furthermore, we also provide the comparative analysis of our proposed scheme with existing schemes in terms of detection approaches, location pattern, placement of detection modules, and achieve objectives, as presented in Table 1.

Based on their detection ability, we categorised the clone node attack detection mechanisms into two position patterns of devices in the deployed network: static and mobile. Since most nodes deployed in an IoT setting adhere to a static position pattern due to their fixed locations, it becomes easier to detect node replicas or clones by matching their identities. On the other hand, detecting clone node attack in a mobility pattern is more difficult because nodes are not fixed in one location and often move in the network. Therefore, even if identity information is successfully matched, it is difficult to conclude that a clone of the ID is found in another location (Shaukat et al., 2014).


Table 1. A comparative analysis of our proposed scheme with existing clone node attack detection mechanisms in WSNs, MANETs and IoT.

Ref	Detection approach	Location pattern	Detection module placement	Achieved objectives
DP	DT	CO	SO	CMO	EC
Xing et al. (2008)	Collecting and forwarding neighbour nodes information	Static	Centralised	✓	✗	✓	✓	✓	✗
Raza et al. (2013)	Collecting and forwarding neighbour nodes information	Static	Centralised and Distributed	✓	✓	✓	✓	✗	✓
Shanmugam and Paramasivam (2020)	Collecting and forwarding neighbour nodes information	Static	Centralised	✓	✗	✗	✗	✗	✗
Parno et al. (2005)	Witness finding	Static	Distributed	✓	✗	✓	✓	✓	✗
Lou et al. (2012)	Witness finding	Static	Centralised	✓	✗	✗	✗	✗	✗
Lalar et al. (2020)	Witness finding	Static	Distributed	✓	✗	✓	✗	✗	✗
Mbarek et al. (2021)	Witness finding	Static	Centralised	✓	✗	✗	✗	✓	✗
Devi and Jaison (2020)	Analysis of routing and time information	Static	Centralised	✓	✗	✗	✗	✗	✗
Rikli and Alnasser (2016)	Define threshold values	Static	Centralised	✓	✗	✓	✗	✗	✗
Choi et al. (2007)	Set functions (union and intersection)	Static	Centralised	✓	✗	✓	✓	✓	✗
Brooks et al. (2007)	Maximum use of keys	Static	Centralised	✓	✗	✗	✗	✓	✗
Alsaedi et al. (2017)	Exponential smoothing algorithm	Static	Centralised	✓	✗	✗	✓	✓	✓
Conti et al. (2014)	Collecting and forwarding neighbour nodes information	Mobile	Centralised	✓	✗	✗	✗	✓	✗
Ho et al. (2009)	Witness finding	Mobile	Centralised	✓	✗	✓	✓	✓	✗
Zhou et al. (2016)	Witness finding	Mobile	Distributed	✓	✓	✓	✓	✓	✗
Shaukat et al. (2020)	Witness finding	Mobile	Centralised	✓	✓	✓	✓	✓	✓
Yu et al. (2013)	Localisation algorithms	Mobile	Distributed	✓	✓	✓	✓	✓	✓
Lee et al. (2018)	Network mapping	Mobile	Distributed	✓	✓	✓	✓	✓	✓
Saravanan and Ilavarasan (2018)	Polynomial Key	Mobile	Centralised	✓	✗	✗	✗	✗	✗
Xing and Cheng (2010)	Analysis of time and space domain	Mobile	Centralised	✓	✗	✓	✓	✓	✗
Our proposed scheme	Context-aware information based location proofs	Mobile	Distributed	✓	✓	✓	✓	✓	✓
DP = Detection Probability, DT = Detection Time, CO = Computation Overhead, SO = Storage Overhead, CMO = Communication Overhead, EC = Energy Consumption.

2.2.1. Static network mechanisms
In static networks, a commonly used technique for detecting cloned node attack is to compare the information of all neighbouring nodes, in which each node compares its information to the information of all neighbouring nodes and then determines whether or not there is any inconsistency in the stored information (Xing et al., 2008). Raza et al. (2013) suggested a clone node attack detection protocol for the 6LoWPAN (IPv6 over Low-Power Wireless Personal Area Networks) called SVELTE to detect unusual behaviours, such as cloning and selective forwarding. In this protocol, each node, including its parents and neighbours, is allocated with a unique ID and the rank information using a mapper function called the 6LoWPAN Mapper. Later, the mapper feature employed by the parent node can identify anomalies between the node IDs and their ranks. However, if an attacker can capture a parent node, this information is shielded from the other replicas in the network. Shanmugam and Paramasivam (2020) proposed a method for detecting clone node attack on an IoT-enabled smart cities environment using a fingerprint-based zero-knowledge mechanism for two-level authentication of sensor devices. The base station calculates the unique fingerprint for each node using information about its immediate surroundings, which is defined by a superimposed s-distinct code matrix. Although this work claims a high detection rate by comparing the fingerprints of each device to the stored information at the base station, this method increases the computation overhead on the base station if a large number of sensor nodes need to verify their fingerprints simultaneously. Additionally, this work restricts the sensor device pattern to a static network, increasing the communication overhead between cluster nodes and base stations.

Witness finding is another widely used technique for detecting clone node attack in static networks. In particular, the idea of using the witness finding technique is to find the existence of clone’s nodes and decide what proportion of nodes are cloned based on their positions being conflicted with others in the network (Lou et al., 2012). For example, Parno et al. (2005) suggested a witness-based scheme for detecting replica nodes in which several witness nodes were randomly chosen or selected along the network’s forwarding path. Thus, each sensor node kept track of the identity of neighbouring nodes and the location of several witness nodes. However, the scheme is inefficient for most sensor nodes with limited memory since it is based on public-key cryptography, which allows each sensor to store the public keys of the other nodes, increasing the memory overhead. Another witness finding approach is proposed in Mbarek et al. (2021), which makes use of a trust-based notion to detect clone node attack on a 6LoWPAN network based on RPL (Routing Protocol for Low-Power and Lossy Networks) in the existence of testing replica nodes. The logic of the trust-based detection technique is that a small number of duplicate arbitrary nodes with credentials such as ID and location information are deliberately inserted into the network as replica test nodes to examine the witness nodes’ responses. However, suppose the witness nodes cannot detect the replica nodes, then the network is considered compromised, which means an attacker can successfully deploy the compromised witness nodes who protect replicas from being detected. Lalar et al. (2020) presented a hybrid approach for detecting clone node attack in WSNs, utilising symmetric and asymmetric encryption to meet the minimum key usage criteria. While the proposed scheme intends to secure the network from clone node attack, it has been demonstrated in a wide range of literature that traditional cryptographic mechanisms such as AES and RSA are inefficient for resource-constrained IoT devices due to their increased bit length for key sizes and messages.

Brooks et al. (2007) employ the principle of random key predistribution to detect clone attacks in sensor networks, in which the keys accessible on clone nodes and their maximum usage for authentication determine the attacker’s presence in the network. The process recovered from a cloning attack by eliminating ties using cloned keys upon identification of clone nodes. Choi et al. (2007) proposed a clone node attack detection mechanism for sensor networks to reduce computation and storage overhead by using various set operations such as union and interactions. The main idea of the proposed scheme is to detect clones by calculating set functions (intersection and union) on exclusive subsets in the network to define additional exclusive unit subsets across neighbours securely. Nonetheless, this method allows an attacker to obtain the secret information of the sensor nodes, which can then be used to conduct network-wide insider attacks.

Alsaedi et al. (2017) developed a multi-level-based cloning mechanism to verify the identity and positions of nodes using the exponential smoothing trust algorithm. In this process, the energy consumption of the nodes suggested the difference between the legitimate nodes and the cloned nodes, which means that nodes with higher energy consumption in the network are considered to be cloned nodes. However, this approach significantly increased the energy consumption of routine workload due to the additional computation required to differentiate the cloned and original nodes. Additionally, the rate of false positives for clone detection is also increased.

Rikli and Alnasser (2016) proposed a trust-profiling based mechanism that detects cloned nodes attack in wireless sensor networks. In this method, trust values called threshold values are determined for the subsequent adjacent nodes, and then these values are used to decide whether the observed values are less than the calculated threshold values. This method, however, introduces an additional computational overhead for large networks with hundreds of nodes, as each sensor node determines the threshold value for their neighbouring nodes and then compares it to the threshold values of others for detection purposes. Furthermore, Devi and Jaison (2020) presented a hybrid clone node attack detection mechanism for SDN-enabled WSNs by examining the underlying network’s route-level and time-based operations. However, the proposed approach has significant shortcomings in recognising the unique mobile aspect of nodes when they change their location and hence does not correspond to the mobility of IoT devices. Additionally, the proposed approach focuses only on network-wide operations for detecting clone node attack, ignoring other security concerns.

2.2.2. Mobile network mechanisms
While detecting clone node attack is a significant challenge due to the limited capabilities of sensor devices, the network topology, the environmental constraints, and the protocols used, very few clone node attack detection approaches have been proposed for mobile sensor networks, or MANETs, in comparison to static network detection approaches. Further, as the MANETs schemes emphasise the nodes’ mobility behaviour, specific adherent issues in MANETs must be addressed when implementing MANETs in IoT networks (Bruzgiene et al., 2017). Although most of the clone node attack detection approaches designed for mobile networks are similar to those used in static networks, such as identifying neighbourhood details (e.g., IP, IDs, and location), finding witnesses, establishing trust, and time analysis, a small number used alternative approaches such as localised algorithms and multi-dimensional scaling.

For instance, a common and straightforward solution to detect clone node attack is that the packets must be routed via the internet using IP addresses on MANETS. However, the disadvantage of this solution is that a node must develop an efficient method for determining if a given address in the MANET is accessible or not and whether a gateway or access point is required. Furthermore, because nodes are inherently unaware of their contexts, obtaining the IP addresses of neighbouring nodes is challenging (Quy et al., 2021). Another frequently utilised strategy in MANETs is the discovery procedure, which must be carried out to acquire surrounding information. However, because these processes require nodes to exchange a massive number of packets, they are not suitable for more extensive networks. Moreover, another challenge to integrating MANETs into IoT is the placement of access points that should enable mobile nodes to connect to the internet (Alshaker and Almutairi, 2021). However, some access points in these networks are only designed to perform limited functions such as directing information and maintaining the most recent record. On the other hand, due to the mobility of nodes, the suitable location of a gateway may be a problematic design aspect, and the optimal placement of a gateway may be highly dependent on mobility conditions.

By using the idea of forwarding neighbourhood information, Conti et al. (2014) proposed a distributed scheme for detecting clone node attack in a mobile wireless sensor network by using an efficient and cooperative routing protocol based on the one-hop communication model. However, similar to the neighbour-based information finding approaches used by most previous works, this scheme also compares the ID and location of each node to those of its neighbour nodes to identify differences in the found information stored locally at the nodes. Furthermore, this strategy does not provide any method to protect shared information using cryptographic protocols if the adversary compromises the ID and location of nodes to create replicas. Saravanan and Ilavarasan (2018) proposed the clone node attack detection scheme in MANETs using dynamic cryptography and polynomial key verification method. The polynomial key verification algorithm determines whether nodes in the network are replicas or authentic nodes. However, this method imposes limitations on the network regarding extra communication overhead as data is sent through alternate routes to reach the destination if it encounters malicious nodes in the network.

Similarly to the witness finding strategy in static networks, Zhou et al. (2016) proposed a distributed technique for detecting mobile replica nodes by sending location claims to sensor nodes in order to collect samples when the relevant witnesses met. This technique performs sequential tests based on statistical hypotheses to detect the clone node attack following the witness nodes, significantly reducing the communication overhead and false positive/negative rate. However, this technique has a limitation in terms of users capabilities to first designate specific geographic regions at regular intervals in order to deploy witness nodes to detect mobile clone devices. Ho et al. (2009) presented a centralised system for detecting replica nodes in mobile sensor networks, in which the base station is responsible for collecting location claims from network nodes, referred to as mobile nodes. In this method, node location claims are utilised to compute the node speed used to calculate and launch the sequential probability ratio test (SPRT) for replica detection. Shaukat et al. (2020) proposed a multi-level clone node attack detection scheme for mobile wireless sensor networks that use the Danger Theory (DT) idea to detect clones in a centralised and distributed fashion. The fundamental function of DT is to identify the dangerous area impacted by a security threat or danger. As a result, this work employs DT-based clone detection to identify contaminated areas by analysing anomalous behaviour of mobile nodes on three levels, referred to as multi-level detection. The danger zone is emphasised in the first step by examining anomalous behaviour of mobile nodes; the second stage uses the device’s battery voltage information and random number; and in the third stage, devices communicate about replica to other network nodes. However, this scheme has limitations in the following aspects: the danger zone selected in the first step can only detect clone node attack in the designated area based on their frequency of interaction with the cluster head. Additionally, similar to the XED mechanism (Yu et al., 2013), this scheme determines the clone node attack by generating and comparing a random number to the values of other nodes in the network, increasing overall communication overhead.

Xing and Cheng (2010) presented a scheme for detecting clone node attack in MANETs by combining time and space domain analysis and including the capability of detecting unlimited replicas. A cryptographic one-way hash function is used in this approach to generate paradoxes that can be used to reveal network replicas. However, this technique has a disadvantage because it creates extra communication overhead to the mobile network when nodes interact and periodically broadcast neighbourhood information to a base station. Yu et al. (2013) proposed a clone detection method based on two localisation algorithms, such as XED and EDD. In the XED algorithm, two nodes establish an interaction setup by exchanging a random number. If these nodes wish to contact again in the future, they can determine whether this is the same node they met previously by asking the random number. The EDD technique employs a time concept to detect clone node attack, in which their high probability of communicating determines the interaction between two nodes during a specified period. If the nodes communicate over the defined threshold time for an extended period, they can encounter the replica with the same ID. In both the XED and EDD algorithms, each node communicates with only its one-hop neighbours, unlike a distributed method, which means that nodes complete the task independently of the base station. However, this method has the drawback of requiring each node to impose network-wide revocation of exchange messages to discover clone node attack, which can flood the entire network with exchange messages, incurring network-wide communication, computation, and storage overheads.

Furthermore, Lee et al. (2018) suggested a multi-dimensional scaling-based approach for detecting clone node attack in IoT networks that works for both static and mobile networks. This method generates the network map by using the relative neighbourhood-distance information for the nodes and distributing the total computational load across multiple base stations with increased computational capacity. However, since this strategy aims to achieve a high detection rate for clone node attack, the network map building approach for the mobility behaviour of the device often incurred additional processing costs, resulting in a decrease in network efficiency.

3. Proposed methodology
This section describes our proposed methodology for detecting clone node attack on IoT networks using sensed context-aware information and location-based services provided by an LPS. First, we create a network model of our proposed scheme that provides an overview of the cloned node detection mechanism for an IoT network. The network model consists of different entities such as the original node, clone node, and gateway node and an explanation of their working mechanism and the assumptions underlying them. Then, in the attacker model, we outline the assumptions and capabilities of an attacker for carrying out malicious actions in an IoT network. Furthermore, we summarise the batch verification protocol for ECDSA*, which aims to aid our proposed detection scheme with its underlying algorithms.

3.1. Network model
We consider an IoT network composed of many heterogeneous resource-constrained IoT devices connected to gateway nodes to facilitate their interaction and provision of a variety of services. Furthermore, IoT devices adopt a spatial mobility pattern, allowing them to move freely within a specific geographic region. The primary objective of the proposed scheme is to detect clone node attack on IoT networks efficiently by leveraging context-aware information sensed by IoT devices and to achieve a high detection rate with minimum storage and communication overhead. Fig. 2 depicts the network model of the proposed context-aware clone node detection mechanism in the IoT environment.


Download : Download high-res image (897KB)
Download : Download full-size image
Fig. 2. Network model.

The network model is represented as an undirected graph G = (V, E), where V and E denote a set of nodes and edges, respectively. We employ a connected graph model in which an edge exists between nodes u and v, (u, v)  E, if the Gaussian distribution (Wang et al., 2008) between  and  such as   1. In our proposed network model, we have the following communicating components: original nodes, clone nodes, and gateway nodes. The following are the specifics for each component:

3.1.1. Original nodes
In our network model, an original node is referred to as a “IoT device”. An IoT network is a collection of heterogeneous, resource-constrained IoT devices equipped with sensors and actuators that allow data transmission to other nodes and communication through the internet. The nodes in the network exhibit mobile behaviour that are geographically distributed via a random waypoint (RWP) mobility model (Johnson and Maltz, 1996). The criteria for choosing this model allow devices to move around and provide appropriate patterns to geographic regions used for most real-time applications. To minimise the computational complexity of the mobility pattern, each node in the network can have a maximum of “p” neighbours, where “p” belongs to the interval {1, }, and n is the total number of nodes in the network.

Further, each node is associated with specific information known as context information gathered from the deployed environment. The context information is often expressed as semantic information used to uniquely identify objects (e.g., IoT devices) about the deployed environment and is easily comprehended and interpreted by humans. The following parameters pertain to the context information (CI) sensed by the original nodes in our proposed network model:

•
ID: An ID is a unique identifier that is guaranteed to be distinct from all other identifiers used to identify networked objects, such as IoT devices. Therefore, it is one of the important context information parameters utilised to identify nodes in our proposed network model. For instance, each network node has a unique identity, and all unique identities are represented as a collection of identities, such as ID = {
, 
, 
, …, 
}, where ID = {
  i  I}, for which I = {1, …, n}.

•
Time: In an IoT context, each device generates data observations that are followed by a timestamp. This timestamp is critical in the analysis section because it defines when data is collected and allows for statistical and time-series analysis. There is no single format that imposes data and time serialisation requirements for data collection. However, we used the ISO8601 format for DateTime representation in our proposed model, which is defined as YYYY-MM-DDTHH:mm:ss.sssZ.

•
Location: The data obtained by IoT devices must be attributed to the device’s relative location at the time of collection. Indeed, when location data is paired with timestamps, companies can determine when and where anything is or was. As a result, we defined a graph G = (V, E) as two-dimensional, which means that G is a Euclidean graph in which each node has a coordinate (
, 
) in a two-dimensional space. The coordinates (
, 
) indicate the position of node i within the defined object plane.

•
Activity: Since IoT devices are equipped with sensors and actuators, they can perform a wide range of activities over the network, including data sensing, computation, temperature control, and data transmission. Additionally, some powerful IoT devices can perform a limited range of data filtering and analysis functions.

Each original node is equipped with a pair of keys: a private key (e.g., 
) that is kept secret and a public key (e.g., 
) that is accessible to everyone. The private key 
 is used to sign the context information as digital content in our proposed scheme. The IoT device employs its private key to identify itself as the issuer of the context information.

3.1.2. Clone node
A clone node is a replica of the original node in the network model that the attacker physically captures to control a more significant portion of the setup and perform malicious actions over it. Several steps are involved in exploiting this vulnerability, including capturing the physical device, extracting the hidden credentials, modifying its function, and reinstating it into the network at a different location. In our network model, the attacker can create clone nodes by capturing and copying their context information, which is referred to as captured context information (CCI).

3.1.3. Gateway node
A gateway is a device that acts as an interface between IoT devices and other systems, such as the cloud. IoT gateways can be physical or virtual devices that collect data from IoT devices and send it to the cloud for processing and storage. Since IoT devices cannot communicate directly over the internet, they are typically connected via a gateway.

In our proposed network model, a gateway node has many responsibilities such as (i) provide the interaction between IoT devices and the external server, (ii) ensure the verification process of location proofs signatures, (iii) it possesses the keys material, such as the public key used for signature verification, for all deployed IoT devices, as well as his own key-pair, e.g., public and private keys, (iv) it keeps track of all deployed IoT devices and their associated context information, which is denoted by a set CI = {
, 
, 
, …, 
}, where  = {
  i  I}, for which I = {1, …, n}.

3.2. Assumptions about the network model
•
The gateway node is a trusted third party that provides secure interaction between IoT devices and systems.

•
The gateway node maintains its role as the central trusted authority.

•
The communication medium utilises a symmetric routing pattern, which refers to the same path taken by data movement between original nodes and gateway nodes and vice-versa.

3.3. Attacker model
In our attacker model, we consider an environment in which an attacker can obtain physical parameters from IoT devices, copy them and replicate or clone legitimate nodes to attack the IoT network. Since cloned nodes have hidden credentials for authentication and encryption purposes, stolen credentials can interrupt network operations and launch numerous attacks inside the network.

•
The attacker’s capability is limited to the extent that it can compromise a small number of nodes that is less than the total number of original nodes.

•
An attacker has complete control over the compromised nodes, which are limited in number.

•
An attacker with malicious intent is capable of dropping or misdirecting information before forwarding it to the base station.

•
An attacker can place IoT devices in strategic locations, such as redirecting traffic to a specific server.

•
An attacker may manipulate the detection mechanism in order to remain undetected in the detection scenario.

•
Cloned nodes can also collaborate with other cloned nodes by exchanging their cloned identifiers extracted from the original nodes.

3.4. Enhanced elliptic curve digital signature algorithm (ECDSA*)
Elliptic curve cryptography (ECC) is a subset of public-key cryptography focused on the elliptic curves derived from the algebraic structure over finite fields (Hankerson et al., 2006). Elliptic Curve Digital Signature Algorithm (ECDSA) is a digital signature algorithm that utilises ECC to derive the keys set such as public, and private (Johnson et al., 2001). Although ECDSA performs similarly to other signature algorithms such as DSA and RSA, it is more efficient and robust due to its ECC foundation, which needs smaller keys to provide equivalent security. Using the ECDSA in IoT networks has proven effective in improving speed and reliability while improving the performance and strength of the overall ECC algorithm. Furthermore, a variation of ECDSA called ECDSA* has been proposed that requires less time to compute and validate signatures and provides 40% more efficiency in verification without compromising security than ECDSA (Antipa et al., 2005).

We employed the concept of ECDSA* in our work to address the limits of resource-constrained IoT devices when it comes to running intensive cryptographic algorithms and to increase the computational efficiency of signature verification.

3.4.1. ECDSA* batch verification
As stated in Section 2.1.3, batch verification is a technique for validating several digital signatures in less time than it takes to validate them individually. In this technique, the signer produces t signatures by interacting with the verifier, and the verifier validates all of these t signatures at the same time.

ECDSA is a standard digital signature algorithm in IoT since it offers the same level of security as public-key cryptography but uses smaller key sizes and ensures the authenticity of devices and data communication between them. Therefore, in our work, we aimed at ECDSA* signatures to verify location proof signatures produced by IoT devices. Similarly to the ECDSA, the ECDSA* requires the implementation of the following algorithms: (i) key generation, (ii) signature generation and (iii) signature verification. The followings outline the implementation and descriptions of these algorithms.

•
ECDSA* key generation algorithm: The Algorithm 1 demonstrate the working of the ECDSA* key generation mechanism, including public and private keys. The algorithm for key generation generates a public and private key pair for use in the signing and verification processes. It is important to note that the key generation algorithm for ECDSA and ECDSA* works similarly. This algorithm takes standard domain parameters as a set such as {p, E, P, n, h}. These parameters are listed in greater detail below.

–
p = The order in which the prime field 
 exists

–
E (a,b) = An elliptic curve 
 defined over the prime field 

–
P = A non-zero random base point in E (
)

–
n = The ordinal value of P, which is normally a prime number.

–
h = The co-factor 
 

The private key can be computed by selecting a random integer d from the range d = {1, }. While, the public key Q is calculated by multiplying the private key d by a non-zero random base point P.

Download : Download high-res image (256KB)
Download : Download full-size image
•
ECDSA* signature generation algorithm: The signing process is performed to generate the actual digital signature. Even though the algorithm for generating signatures is similar to that used by ECDSA, the signature forward to the verifier is different for ECDSA and ECDSA* signature schemes. Algorithm 2 illustrates the ECDSA* Signature Generation procedure, which begins with the following parameters as inputs: message m, hash function H, and domain parameters such as P, and outputs the signature (r, s) for each participant. In IoT, for example, each different signature is generated for each device for verification. The signature generation process in this algorithm begins with the selection of the k parameters as a random integer between 1 and . Following that, the coordinates X are determined by multiplying the random integer k by the random point P. The hash function H (in this case, SHA-1) takes the message m and produces a hash value in the form of a digest string value, which is then converted to an integer e. Finally, a signature value s is calculated by taking the inverse of k random integers and multiplying the sum of integer e and private key d by r. The final output of ECDSA* signature generation is a pair, such as (r, s).


Download : Download high-res image (353KB)
Download : Download full-size image
•
ECDSA* signature verification algorithm: The signature verification process is used to verify the signatures sent by the signer with his/her public key. The verification process depends on the signature size; the lengthy the signature is, the more time-consuming. Hence the signature verification algorithms are a little different since the signature size is different. Algorithm 3 illustrates the process of ECDSA* signature verification. This algorithm requires the following inputs: a signature value (r, s) that must be validated and a public key Q. However, the signature verification output is in the form of a binary decision, such as accept or reject. The signature verification process begins by determining if the signature values r and s belong to the interval [1, ] or not. Following that, the hash H function calculates the hash value of the message m for comparison purposes. Similarly to the signature generation algorithm, the hash value is converted into an integer e. By taking the modulus of the inverse value of the signature, an integer value w is generated. Following that, two coordinates, 
 and 
, are determined by multiplying the integers e and r by the value w, respectively. An X value is generated by combining the multiplications of P and Q by the calculated coordinates (
, 
) from the previous step. A  is an identity element for which the ordinal value n of the base point P over the curve E is calculated as, n P = . If X = , the signature will be rejected. However, if X  , it will be accepted if and only if  = r.


Download : Download high-res image (388KB)
Download : Download full-size image
3.5. Selection of trusted nodes
Batch verification significantly reduces the time required to validate the signature of each IoT device on gateway nodes. In IoT networks, gateway nodes are considered to have greater computing power than resource-constrained IoT devices. However, along with providing internet connectivity through cloud services, gateway nodes in an IoT network often have additional responsibilities such as data preprocessing, data aggregation, and running protocols to ensure the security of connected IoT devices. Considering these responsibilities, it is a critical requirement for batch verification to minimise the amount of work at gateway nodes. One approach is to offload the signature verification task from the gateway node to a few other IoT devices without compromising security.

However, one of the critical tasks is to select the trusted IoT devices for signature verification from the pool of available IoT devices in the network. To facilitate this, we proposed the model to select the trusted IoT devices from available IoT devices for signature verification tasks. Numerous other trusted models for selecting nodes to perform computation tasks have also been proposed, some of which are cloud-based and platform-dependent. In contrast, others concentrate on selecting individuals based on their trust values (Khalil et al., 2021, Altaf et al., 2020, Qolomany et al., 2020). For instance, one model (Kittur and Pais, 2020) is proposed for selecting trusted IoT devices for signature verification. Since this proposed model selects IoT devices based on physical and security criteria, it imposes additional computation overhead on the overall system by selecting IoT devices that satisfy these two critical conditions.

Given that IoT devices usually have limited processing power, memory, and battery capacity, it is important to select trusted IoT devices and distribute the load to them to perform operations similar to those previously performed by the gateway nodes. Thus, we aim to distinguish trustworthy IoT devices from other IoT devices that exhibit the ECDSA* signature verification process more efficiently and timely. Our trusted device selection model focuses on selecting trusted IoT devices based on device profiling capabilities such as processing capacity, sensed context information, and confidence credibility.

For instance, in a specific IoT network region, a collection of devices is represented as  = {
, 
, 
, …, 
}, where  = {
  i  I}, for which I = {1, …, n}. The entire category of network devices is subdivided into two sets: simple devices 
 and trustworthy device 
. Simple devices are responsible for signature generation, while trusted devices are responsible for batch signature verification. Both types of devices are subsets of the total number of devices and may be expressed as 
   and 
  , respectively. However, these two subsets are not equal, such as 
  
. The total number of trusted devices is less than the total number of simple devices, such as t  s, where s represents the total number of simple devices and t represents the total number of trustworthy devices.

To select trustworthy devices, the confidence credibility element plays a key role in which multiple known trust factors are determined when a transaction occurs between simple IoT devices 
 and trusted IoT devices 
 to evaluate an IoT device’s trustworthiness. To calculate the confidence C, we divide the confidence credibility for an individual IoT device into two measures: implicit confidence and explicit confidence. In implicit confidence IC, trust is determined by examining an independent reputation of IoT device. In explicit confidence EC, the trust placed in the suggestions of other nodes based on their prior experiences. The confidence measure for the t devices can be represented as a set, such as 
 = {
, 
, 
, …, 
}, where 
 = {
  i  I}, for which I = {1, …, t}.

The overall confidence of both implicit and explicit measures for the given devices in the IoT network is determined in Eq. (1). (1)

Eq. (1) provides the formula for calculating total confidence that is composed of two parts: 
 represents the implicit trust between a simple IoT device and a trusted IoT device, and 
 represents the explicit trust between a simple IoT device and a trusted IoT device. The  and  are the total weighted factors for IC and EC, respectively, and the total weighted factor  is determined as  + .

Both weighted factors 
 and 
 satisfy the following equations independently, as shown in Eqs. (2), (3). (2)
 (3)

The implicit confidence for a trusted IoT system is measured by adding the implicit confidence for a location as sensed context information to the device’s feedback. If no transaction history exists for IoT devices 
, an initial value is allocated to implicit confidence; however, if there is no association between IoT devices 
, the default value of 0.5 is used. The implicit confidence interval for a set of devices at specific locations is computed using Eq. (4). (4)

where  is further subdivided into two weights,  
 and  
, for 
 and 
 respectively at various locations L = {
, 
, 
, …, 
}, where  = {
  i  I}, for which I = {1, …, n}, as specified below. 
 
 

Eq. (5) calculates the weighted factors for 
 and 
 with respect to their locations. (5)

Where 
 can be calculated using the Euclidean distance method defined in the Algorithm 4.

The aggregate implicit confidence (previous and recent) of all trusted IoT devices is determined using Eq. (6). (6)

Following the implicit confidence measurement, we measured the explicit confidence measurement when simple IoT devices request feedback fd about the location of a trusted IoT device at a particular point. All IoT devices measure the location of a trusted IoT device and transmit the requested location as feedback to the requested IoT devices. For explicit confidence EC, the p trusted levels can be calculated as follows: 
, where 0  
  1. For IoT devices, the trusted level sequence can be implemented as 
 
 
  …, 
.

Individual feedback fd from IoT devices can be calculated by measuring their position, which is expressed as fd
. The explicit confidence EC for a trusted device 
 in terms of its feedback 
 is measured using Eq. (7). (7)
 

The explicit confidence for the trusted IoT device is measured using Eq. (8). (8)
 
where 
 represents the individual feedback for trusted IoT devices regarding location, and FDs represents the aggregate feedback for trusted IoT devices regarding the location that is obtained from all connected devices. 
 denotes the weighted factors that the trusted IoT device possesses in the requested node. The overall weighted factor can be calculated by using Eq. (9), taking into account input from all IoT devices. (9)
where 
 = 1.

4. Proposed location proof system
This section presents the LPS model following the context-aware modalities localisation technique. We developed several algorithms to explain the process of detecting clone node attack on LPS. Finally, this section discusses the execution flow of our proposed scheme between various components of the LPS model by using location proofs and batch verification concepts.

4.1. Localisation technique
Localisation is an important concept in LPS, in which localisation and network/location infrastructure-independent methods are used to determine the location of the user’s device. Localisation refers to how a device determines its position with another device, satellite or maps, etc. Several software-based or hardware-based techniques have been used for localisation, including fingerprint, distance-bounding protocol, context-based modalities, proximity, triangulation, beaconing, and mobile network or tower-based approaches.

We used context-aware modalities as a technique for localisation in our work because we used context-aware information to detect clone node attack on IoT networks. The basic idea behind context-based localisation is that it gathers various contextual values about the IoT device environment, such as ambient acoustic light, noise level, humidity, temperature, and Wi-Fi and Bluetooth signal power, and then generates proof of presence for physical device location by combining all of them to determine the device’s location. Contextual information is collected simultaneously by the verifier and device. The device produces the proof of presence, which includes context information, and the verifier validates the context information to confirm the device’s physical presence.

The network model of the LPS used to detect clone node attack on IoT networks via a context-aware information-based localisation technique is shown in Fig. 3. The network model of an LPS incorporates the following entities:

•
Prover: The provers are the IoT devices that want to demonstrate that adversaries have not compromised their identities and location. We referred to the simple IoT device as “Prover” for simplicity.

•
Clone node: The clone nodes are compromised IoT devices whose credentials, such as context information, have been compromised by the attacker.

•
Verifier: The verifiers are the selected IoT devices that employ a trust model and communicate with the gateway to verify the evidence. We referred to the selected IoT devices as “Verifiers” for simplicity.

•
LBS: The gateway nodes serve as location-based services (LBS), with verifier IoT devices serving as clients.

In our proposed scheme, we consider a scenario in which a client of an LBS, referred to as verifiers, aims to demonstrate to the LBS the existence of provers at a specific location to detect clone node attack in an IoT environment. A prover and a verifier simultaneously collect contextual data through IoT devices to create an incident context. To validate the proofs, the verifier IoT devices compare the context information obtained from the prover IoT devices to their own context information to determine whether or not the IoT device has been compromised. For proof validation, we used the ECDSA* signature process, in which each party (prover and verifier) is assigned their public and private keys. We assume that an intruder from outside the context cannot detect context information.

4.2. Proposed algorithms
Along with describing the network model, attacker model, and working mechanism of ECDSA*, we proposed several algorithms to demonstrate the execution of an LPS for detecting clone node attack in an IoT environment. These algorithms include a location calculation algorithm, a location proof generation algorithm, and a location proof-verification algorithm. The procedure of each proposed algorithm is defined in the Algorithms 4–6. Table 2 shows the notations and descriptions used in the Algorithms 4–6.


Table 2. Notations.

Notations	Description
Provers’ identification
Data sensing time
Location on two dimensional space
Prover’s activity at specific time
Context information
{
, 
, 
, …, 
}	A set of stored context information on LBS
H	Hash function (SHA256)
Prover’s private key
Location Proof
Location Proof Signature
{
, 
, 
, …, 
}	A set of provers’ signature
{
, 
, 
, …, 
}	A set of provers’ public keys
{
, 
, 
, …, 
}	A set of verifiers for batch verification
Signature()	Elliptic Curve Digital Signature function
isEmpty()	Checking the location proof request
isNotExisted()	Checking the existence of context information
revert()	Sent back the transaction
4.2.1. Location calculation algorithm
Approximating distance is a significant obstacle when addressing a location in the majority of the IoT networks. The Algorithm 4 demonstrates the process of determining the locations of network devices. We estimate the location of each device (such as the prover and verifier) as a key element of context information in our proposed location proof framework model by measuring the distance between the provers and verifiers in two-dimensional (2-D) space. A prover in two-dimensional space is represented by P = {
, 
}, whereas a verifier in two-dimensional space is represented by V = {
, 
}. Based on their distance estimation, we used the Euclidean distance algorithm to calculate the location of each prover with respect to the verifiers. The distance between verifier and prover is denoted by 
.

The euclidean distance process starts by taking the prover and verifier’s coordinates in two-dimensional space, such as P = {
, 
} and V = {
, 
}, as input values respectively. It calculates the distance between each verifier {
, 
, 
, …, 
} by taking the square root of difference between the coordinates of each verifier and prover pair. After calculating the distance between their provers, each verifier maintains a list of the euclidean distances between their provers as determined locations at specific points, such as {
, 
, 
, …, 
}.


Download : Download high-res image (291KB)
Download : Download full-size image
4.2.2. Generate location proof
The Algorithm 5 demonstrates the process of generating location proofs for IoT devices showing their presence at a specific location in terms of LBS. The proof generation process begins with sensing the contextual information of the prover and the verifier about their deployed environment. The context information includes the identification of IoT device ID, data sensing time T, its specific location Loc and activity Actv. The combination of such information is referred to as CI, and it is maintained and stored at LBS as {
, 
, 
, …, 
}. A location Loc between two IoT devices or between an IoT device and a selected IoT device is determined using the Euclidean distance algorithm, which determines the length of a segment connecting the two points and its location in 2-dimensional space or at a specific point in place. An IoT device’s activity can be any operation, such as monitoring, sensing, or broadcasting at a specific time T. To generate a location proof, a verifier first requests that the prover generate a proof using sensed context information such as CI. The proof is generated by signing the context information CI using the prover’s private key 
. The signature 
 is generated using the ECDSA* signature generation algorithm (Algorithm 2).


Download : Download high-res image (469KB)
Download : Download full-size image
4.2.3. Verify location proof
The Algorithm 6 illustrates the process of verifying location proofs for IoT devices claiming to be at a specific location with context information CI. The verification process begins with taking inputs such as provers’ signatures as {
, 
, 
, …, 
}, and their respective public keys as {
, 
, 
, …, 
}. To validate the position proof obtained from the prover, the verifiers {
, 
, 
, …, 
} analyse the contextual information CI from the LBS and perform ECDSA* batch verification on the signatures (Algorithm 3) after getting confirmation about the availability of stored information on the LBS. As the batch verification process is carried out by multiple verifiers chosen using the trust model, the LBS maintains and controls the list of verifiers. The verifiers used the prover’s public key 
 to validate the signature 
. After successfully verifying the signatures obtained from each selected verifier, the verifier will confirm the authenticity of the IoT device in the network and accept the proof with location confirmation and other credentials. However, if the signature is not successfully verified, the verifier notifies the LBS of compromising the prover in the IoT network.


Download : Download high-res image (451KB)
Download : Download full-size image
4.3. Execution flow
The detection of clone node attack on an IoT environment uses the numerous interconnected modules included in the proposed network model. Following the proposed network model, we proposed an LPS for detecting clones node in an IoT environment, which consists of the following entities: prover, clone nodes, verifiers, and LBS, all of which interact with one another to detect a clone node attack successfully. Fig. 4 depicts the execution flow of our proposed LPS model, which demonstrates the relationship between the entities (successful/failed). In addition, the execution flow diagram illustrates the method of implementing a proposed clone node attack detection scheme based on the LPS.


Download : Download high-res image (624KB)
Download : Download full-size image
Fig. 4. Execution flow of location proof system.

Detecting clone node attack begins with the prover and verifiers sensing information about the deployed environment. The context information includes the identifier of the IoT device ID the time stamp for data sensing Time, the device’s specific location, and the activity performed Activity. The combination of these context information is grouped and represented as CI. Following the process of sensing context information CI, the verifiers save this information to the LBS entity and receive an acknowledgement from the LBS about the saved information.

After storing the context information in the LBS, the verifiers request that the prover give the location proof to validate the prover’s authenticity and ascertain whether or not the prover has been compromised. The prover generates a location proof of sensed context information CI using the ECDSA* signature generation method and sends it to the verifiers for verification. Upon receiving the signed proof, the verifiers compare the existence of context information CI with stored context information CI to the LBS and receive acknowledgement of the existence of information to the LBS.

After obtaining the signed proof from the prover, the verifiers conduct the proof verification process on the received signed proof using the ECDSA* batch verification process and determine the provers liable for pretending to be at a particular location using context information. If the verifiers verify the signed proof successfully, it notifies the prover of the accepted location proof. Meanwhile, the verifiers notify the LBS when a prover is compromised in the network.

We designed two scenarios in the LPS to detect clone node attack on the IoT context, such as detecting the clone node attack by evaluating and comparing the details to the LBS and requesting the location proof to the clone node determining its compromise after verification. In the former case, if the verifiers do not successfully verify the signature, then LBS indicates that the provers in the network have been compromised. In the latter case, the verifier requests the clone node’s location proof in order to validate its authenticity and location modification. Since an intruder created clones of the provers and copied their context information CI to cloned context information CCI, the verifiers compare the cloned context information CCI to the previously stored context information CI after receiving the location proof from the cloned node. Upon receiving confirmation from LBS that context information did not exist, the verifiers rejected the location proof and informed LBS about the provers’ compromise.

5. Evaluation framework
To examine the applicability and robustness of our proposed system for detecting clone node attack on an IoT environment, we configured a Linux cluster system as an evaluation framework and used the C programming language to implement defined functions and attack scenarios. The configured cluster system consists of 10 machines, one of which serves as the master machine and nine as computing nodes. Each machine has 20 cores, and each core run with 2.11 GHz and 8 GB of memory. We setup each machine in a cluster setup to simulate 40 IoT devices. Thus, to simulate the multiple IoT devices in the network, we used the multi-threading concept to divide a single processor into multiple required threads. Since each thread corresponds to one sensor node, mainly defined for the required task. We communicate with other machines in the cluster system via the MPI (Message Passing Interface) library available for the C programming language. For batch verification using ECDSA*, we utilised the prime curve (P-256), in which all parameters evaluated for experimentation are NIST-recommended traditional values. Table 3 contains information about the hardware, software, libraries and network configuration used as a testbed for our evaluation framework.

In our experiment, we examined a network comprised of between 100 and 500 IoT devices. From these IoT devices, we choose 350 IoT devices that need to be verified as clone nodes in the network. In our proposed LPS, the provers are the IoT devices that want to demonstrate that adversaries have not compromised their identities and location of IoT devices. We estimate the location of each device (for example, the prover and verifier) as a critical piece of context information in our proposed location proof framework model by calculating the distance between the provers and verifiers in two-dimensional (2-D) graph space. The graph dimension detail is specified in Section 3.1.1.

As stated earlier, we identified nine computing machines out of the total ten machines in the cluster system as IoT devices, and each machine is simulated as one of the 40 IoT devices in the LPS architecture, making a total of 360 IoT devices available in our simulation setup. The responsibilities of IoT devices include sensing context-aware data and generating a location proof as a signature for this sensed context information. As a result, the sensing capabilities of IoT devices include sensing information such as deployed location in a two-dimensional space, data sensing time intervals, and the activity performed by these devices at a specific time. Furthermore, each IoT device is granted a unique ID to separate it from other devices apart from sensing data. Thus, all this information is used to build the context for identifying clone nodes in the LPS. However, we did not use a dataset to conduct our experiment, instead of providing self-configuration context information such as ID, time, location, and activity to each IoT device.


Table 3. Configuration of our evaluation framework as a testbed.

Hardware specifics
CPU clock cycles	2.11 GHz
CPU architecture	
Memory	8 GB
Linux cluster system	10 machines (Each with 20 cores)
Software specifics including libraries
Operating systems	Ubuntu 18.04
Programming language	C language
Communication library	MPI library for C language
Communication routines	 and 
Cryptographic library	ECDSA (secp256k1)
Network setup
IoT devices	350
Verifier	40
Graph dimension	2-D
We expressly chose a master computer machine as the verifier to verify location proofs in our implementation setup. Furthermore, to maximise the master machine’s computational capabilities, we select one-third of the total IoT devices from the master machine as verifiers for verification tasks, and the remaining computational capabilities are used for other computational tasks such as storing the data to the LBS. In other words, the verifiers employed in the implementation arrangement are nearly 12% of available IoT devices in the cluster configuration.

6. Performance analysis and results discussion
Following the configuration of an evaluation framework for the purpose of implementing an IoT-based network comprised of provers and verifiers, we conducted a series of experiments to evaluate the performance of our proposed scheme for detecting cloned nodes and analysed the results using a variety of evaluation parameters. These parameters include the attack detection probability, detection time, computational overhead, communication overhead, storage overhead and energy utilisation. We repeated each experiment 20 times for each performance metric, including key creation for provers and verifiers, location proof generation and verification, storage overhead, and communication overhead to obtain accurate values as the experimental results.

To provide a comprehensive analysis of our proposed scheme and verify its underlying security properties, we performed formal analysis, modelling, and verification procedure, all of which aim to ensure the correctness and robustness of systems and further ensure that no problematic scenarios or anomalies exist (Hameed et al., 2021).1

To compare our proposed scheme to existing works and to analyse its effectiveness for IoT networks, we chose the existing state-of-the-art schemes based on the detailed comparative analysis presented in Table 1. Since our proposed scheme aims to achieve the distributed detection of clone node attack in mobile IoT environment and achieve the effectiveness of the proposed solution in terms of detection rate, detection time, computation overhead, storage overhead, and communication overhead for resource-constrained IoT devices. As a result, we firstly chose only those existing schemes (Zhou et al., 2016, Yu et al., 2013, Lee et al., 2018) that meet the criteria of mobility location pattern, distributed detection module placement, and efficiency in terms of the parameters listed above. Then, after further analysis, we have excluded the scheme (Lee et al., 2018) from our performance analysis comparisons, such as storage overhead and communication overhead, because the scheme claims to reduce storage overhead and communication overhead by only collecting location information from neighbouring nodes and forwarding it to the BS, therefore ignoring the other dynamic environment-related parameters used to achieve effectiveness and accuracy detection, such as time and activity.

We evaluate the effectiveness of our proposed scheme in terms of achieving the following objectives: attack detection analysis, which includes detection probability and detection time, and performance-related parameters for IoT networks, such as computational overhead, storage overhead, and communication overhead. The results analysis shows that our proposed scheme helps detect clone node attack on IoT networks with a high detection rate in a reasonable amount of time. Additionally, our proposed scheme has a lower computational, communication, and storage overhead than the existing schemes.

The following sections go into detail about each objective and their supporting simulation results.

6.1. Attack detection analysis
We analysed the detection of clone node attack in our proposed scheme using two parameters: detection probability and detection time. The detection probability estimates the probability that cloned or replica nodes will be accurately detected. In contrast, the detection time indicates the time required to detect clone node attack our network successfully. Each of which is discussed and measured in more detail in the following sub-sections:

Further, we considered two different types of environments when configuring the clone nodes setup.

•
Sparse environment: The network is built and operated using a limited number of IoT devices in a sparse device environment. We choose 20 devices from the total number of available devices on the network to operate as clone devices in our setup.

•
Dense environment: The number of clone devices in a dense setup ranges between 25 and 50.

6.1.1. Detection probability
The detection probability can be described as the proportion of successfully detected cloned nodes divided by the number of cloned nodes in the deployed IoT ecosystem.

Since our proposed scheme detects clone node attack based on context information collected by both the prover and the verifier and then stored in LBS for verification purposes. Each prover must prove its location by creating location proofs at varying intervals, then validated by the network’s selected trusted nodes known as verifiers. The verification step verifies the sensed context information to the data stored at the LBS. The proposed scheme determines whether or not a device has been compromised by successfully verifying and matching such information. The detection of clone node attack resiliency in our proposed scheme is based on two scenarios:

•
Case I: An adversary  compromises a random prover P, replicates it and creates a clone node P’ of it by extracting all of the prover’s credentials, including the context information CI, and deploying it in several locations throughout the network. In a network model, all network nodes are represented as an undirected graph G = (V, E), where V and E denote a collection of nodes and edges, respectively. To detect clone node attack, suppose a verifier V generates and sends a location proof request to a prover P. When the adversary  receives a location proof request at clone node P, it generates the signature for the location proof 
 and sends it to the verifier V for verification. Once the verifier V receives the 
, it performs the ECDSA* on the location proof and, if the signature does not include context information, V determines that the prover P has been compromised.

•
Case II: An adversary  compromises a random prover P, replicates it and creates a clone node P’ of it by collecting all of the prover’s credentials, including the context information CI, and deploying it in various locations throughout the network. To identify clone node attack, consider that a verifier V makes a location proof request and sends it to the cloned node P’. When the clone node P’ received a location proof request, the verifier V compared the cloned context information CCI to the CI stored at LBS. However, because the location information of the original nodes has been changed during the cloning process, CI  CCI, the verifier V can infer that prover P’ is the compromised node in the network.

Considering both cases for clone node attack detection on our proposed LPS, we demonstrate that our proposed detection scheme achieves the maximum detection resiliency and provides the highest probability of clone node attack detection. However, the latter situation is more computationally efficient because it simply requires verifying and matching the information with the information stored in the LBS, as opposed to the other case, which requires verifiers to perform ECDSA* batch verification to validate the signatures. As a result, we can confidently assert that our proposed scheme achieves the highest detection probability of 100% in both cases. Finally, we compare the detection probability of our proposed scheme to that of the existing schemes (Zhou et al., 2016, Yu et al., 2013), which have detection rates of 90% and 92.5%, respectively.

6.1.2. Detection time
The detection time is a time required for the protocol or system to successfully identify the clone nodes in the underlying network. The detection time in our proposed scheme is the overall time required to complete the entire procedure, beginning with the generation of location proofs and ending with their successful verification to detect a clone node attack. Furthermore, we discussed the methods and procedures used by existing approaches to determining their clone node attack detection time. For instance, the approach (Zhou et al., 2016) estimated the detection time based on the detection probability of iterations initiated from each node to all its neighbouring nodes in various communication ranges to find clone nodes. However, if there are  neighbour nodes, the detection time for a single node will also be increased, as iterations for all neighbour nodes must be performed to find the clone node. The approach (Yu et al., 2013) used bootstrapping time for the instances of random numbers assigned to replica nodes to detect clones; however, if the network contains d replicas, time will be considerably increased for all neighbourhood nodes connected to those replicas, and time detection is completely dependent on the probability contexts.

We determine the detection time for both sparse and dense environments in our proposed scheme and compare the obtained results with the existing approaches. Fig. 5 depicts the detection time of a clone node attack in a sparse environment, demonstrating a significant improvement over existing approaches. Additionally, we examined the detection time for clone node attack when the standard ECDSA technique was used. Finally, Fig. 6 illustrates the detection time for clone node attack in a dense environment. The detection time analysis for both environments (e.g., sparse and dense) reveals that our proposed scheme significantly reduces the detection time compared to standard ECDSA and existing approaches.

6.2. Computational overhead
Another significant factor in determining the efficiency of our proposed scheme is the computation time. Our proposed scheme defines computational time as the time required to perform various operations such as key generation for provers and verifiers, signature generation for provers to generate location proofs, and verification time for verifiers to verify the location proofs. Our proposed scheme assumes that LBS is a trustworthy entity capable of performing cryptographic operations without processing or storage constraints. The computation time required to perform each operation in the proposed scheme is detailed below.

6.2.1. Key generation
Our proposed scheme generates a pair of ECDSA keys with the P-256 (secp256k1) curve for signing and verifying location proofs to detect clone node attack on the IoT environment. Even though our LPS is based on the batch verification process for ECDSA*, the key generation process for both ECDSA and ECDSA* is identical. The process of generating ECDSA* keys is described in detail in the Algorithm 1. The length of keys is specified in bits, and the time required to generate them is calculated in seconds. Thus, the security requirements of ECDSA are met proportionately by a shorter key length, and similar levels of security are achieved by other cryptographic algorithms such as RSA. A significant benefit of a smaller key size is that computations can be performed more quickly, reducing storage space, processing power, power consumption, and bandwidth.

We calculate the time required to generate the public and private keys for the provers and verifiers in LPS. Each device is required to generate and verify location proofs. For example, the prover’s private key generates location proofs as a signature, verified using the prover’s public key. Fig. 7 specifies the time in seconds required to generate the public and private keys of provers. The analysis demonstrates that private keys take less time to generate than public keys. Public keys are generated by multiplying the respective private key with an elliptic curve generator point. Similarly to the generation of public and private keys of provers, Fig. 8 illustrates the time required in seconds to generate the public and private keys of verifiers.


Download : Download high-res image (205KB)
Download : Download full-size image
Fig. 7. Public and private keys (Provers).


Download : Download high-res image (200KB)
Download : Download full-size image
Fig. 8. Public and private keys (Verifiers).

Additionally, we determine the cost of keys generation in terms of the total number of N provers and verifiers, which is N).

6.2.2. Location proof generation
The process of generating location proofs in an LPS is intimately linked to the process of getting the location proof request from the verifier and then generating the signatures, as illustrated and explained in the Algorithm 2. To detect clone node attack on IoT networks using an LPS, each verifier requests proof of location from the provers to determine whether or not the prover has been compromised. Each prover uses its private key to sign its sensed data, referred to as context data, and sends it to the verifier to formulate the location proof. The signature process converts the sensed context information into a hash value using various hash functions. We used the secp256k1 curve in ECDSA* to generate the hash value of the context information using the SHA256 hash function. The computational cost of generating location proofs, including request generation and proof generation, is depicted in Fig. 9. The analysis reveals that requesting a location proof takes less time to compute than generating a location proof since the provers need to perform the signature generation function throughout the generation process.

Additionally, as indicated in the working mechanism of LPS, the location of each device is essential for identifying between original and clone nodes, and it is computed using the Euclidean distance specified in the location calculation Algorithm 5. We estimated the average computational time required to calculate the locations of deployed devices such as provers and verifiers as part of their context information in LPS. However, because the devices in the mobility network constantly change their locations, we believe that the computational cost continually increases as the number of devices in the network increases. The cost of estimating the location of provers and verifiers in the LPS is illustrated in Fig. 10.

We analyse the computational complexity of generating a location proof by estimating its location between devices using the Euclidean distance technique and then calculating the cost of each prover’s signature generation. For example, since each of the provers and verifiers has a coordinate (
, 
) in a two-dimensional space, the distance difference between them for a N devices take linear time, followed by squares, additions, and square root, each of which also requires the linear amount of time. As a result, the total computational complexity of N provers and verifiers is N). Additionally, each prover generates its signature independently in response to a request from the verifiers for location proofs. Thus, similar to location estimation, the signature generation procedure takes linear time, and the overall cost of generating signatures is N) for N provers. To summarise, when the computational difficulty of location estimation N) and signature generation N) are added together, the overall computational complexity for location proof generation is N).

6.2.3. Location proof verification
After obtaining location proofs in the form of signatures from provers, the verifiers verify the proofs to detect clone node attack. Since our scheme used the ECDSA* batch verification approach to validate several digital signatures at once rather than individually. The working mechanism of location proof verification using batch verification is explained and discussed in detail in Algorithm 6.

In our experiments, we define several batch sizes for batch verification of location proofs, which correspond to the number of signatures to be verified in each batch. As stated earlier, the verification process in an LPS is performed by trusted verifiers; therefore, we assigned each signature to each verifier for the sake of simplicity rather than having the base station verify each signature individually. In addition, the ECDSA* batch verification methodology includes operations such as point addition and scalar multiplication, which may affect the time required to verify signatures.

We specify the total five batches for location proof verification in our experiment based on the number of verifiers in the LPS. The batch size increases by five in each simulation; for example, 5, 10, 15, 20, 25, the computational time in seconds is determined. We compared the batch verification time of ECDSA* with the simple ECDSA for each batch size and concluded that batch verification of ECDSA* is substantially more computationally efficient than the ordinary ECDSA.

The computational time taken in seconds for verification of location proofs utilising batch verification of ECDSA* concerning ordinary ECDSA for batch size five validated by the verifiers is depicted in Fig. 11(a).

Fig. 11(b) illustrates the computing time in seconds required to verify location proofs using ECDSA* versus traditional ECDSA on a batch size ten.

Fig. 11(c), Fig. 11, Fig. 11 illustrate the computing times in seconds required to verify location proofs utilising batch verification of ECDSA* in comparison to standard ECDSA on batch sizes of 15, 20, and 25.

Fig. 11(f) illustrates the computational time in seconds required to verify location proofs in the proposed scheme using the ECDSA* and conventional ECDSA for all specified batch sizes. We conclude that batch verification is significantly more efficient than conventional ECDSA and thus highly recommended for resource-constrained IoT devices.

Additionally, we determine the computational complexity of verifiers verifying location proofs in the LPS. For example, each verifier requests that the prover provide location proofs for verification to detect clone node attack. Each verifier requests the total number of  tracked provers, thus if the LPS has N verifiers, the total computational cost of verifying each verifier’s location proofs is O().

6.3. Storage overhead
We analyse the performance of our proposed scheme in terms of storage overhead and compare it to the most relevant works (Zhou et al., 2016, Yu et al., 2013). The storage overhead associated with the clone node attack detection mechanism is expressed as the average number of bytes required to store detection values at each node. In our proposed scheme, the storage overhead is defined as the average number of detected data, such as context information stored on IoT devices, that any detection protocol must collect to successfully detect clone node attack in an IoT environment. To demonstrate the feasibility of our proposed scheme from a storage overhead perspective, we consider IoT devices to be resource-constrained devices.

Furthermore, we analyse the storage overhead of our proposed scheme with regard to LPS from two perspectives: individual device (i.e., prover and verifier) storage overhead and total scheme storage overhead. Each of which is discussed in detail and measured in the subsections that follow.

6.3.1. Storage overhead of individual device
We measure the storage overhead associated with each device in LPS as the average number of bytes required to store the context information CI in each device, such as the prover P and verifier V. As previously mentioned, the context information is composed of the unique device identification ID, the time T, the position Loc, and the activity Actv, each of which requires two bytes, two-byte, four bytes, and eight-byte, respectively. As a result, the context information requires eight bytes to store in each prover and verifier. For each prover and verifier’s public and private keys, we use the 256-bit elliptic curve (also known as secp256k1). The private key is 32 bytes in size, while the compressed public key is 33 bytes. These public and private keys are unique to each device and are created only once. However, context information is generated each time the prover device changes position, and the verifier must identify it. Table 4 specifies the storage requirements for an individual device in terms of context information and key pairs, which reflects the storage overhead associated with the prover and verifier in the proposed scheme. Each device stores an average of 81 bytes, used for iterations to detect clone nodes in the LPS. Since each device, regardless of the number of inputs, follows the same steps to sense the same information, the objective complexity of storage overhead for both prover and verifier is .


Table 4. Storage requirement of each device.

Context information
ID	2 bytes
Time	2 bytes
Location	4 bytes
Activity	8 bytes
ECDSA key-pair
Private key	32 bytes
Public key (compressed)	33 bytes
Since our proposed scheme identifies clone nodes using device location proofs, which require each device to sense context data and generate proofs that trusted verifiers can validate. However, as the existing scheme (Zhou et al., 2016), detect the node using a witness finding approach in which each witness node is required to store the required number of copies of the time-location claim for each of their neighbour nodes. For instance, if the network has n witness nodes, each node must store information on its  neighbour nodes; thus, the storage cost on each node is proportional to the number of neighbour nodes and thus increases accordingly.

Furthermore, the storage overhead in Yu et al. (2013) is calculated for the two localised methods, XED and EDD, and each node maintains a list or array of d neighbour nodes to track their information. However, in XED, nodes maintain two arrays to store and communicate information about their neighbours; thus, we compared the storage overhead of our proposed scheme to that of the EDD localised algorithm. Furthermore, their experiments vary the number of neighbour nodes from 5 to 30, but for the sake of simplicity and comparison, we used their lowest number of neighbour nodes.

6.3.2. Storage overhead of overall scheme
We measure the storage overhead of our proposed scheme with the existing schemes (Zhou et al., 2016, Yu et al., 2013) concerning several iterations performed by both prover and verifier and an average number of bytes taken to detect clone node attack in an IoT network.

To detect clone node attack, a verifier must initiate the location proof mechanism and send it to the prover to verify whether or not it has been compromised. Thus, each node (prover and verifier) must contribute and perform iterations to detect clone nodes. Fig. 12(c) depicts the proposed scheme’s overall storage overhead to the existing schemes (Zhou et al., 2016, Yu et al., 2013) in terms of the number of iterations (in bytes) performed by devices to detect clone node attack. To conclude, as per the storage overhead analysis, our proposed scheme is significantly more efficient in terms of storage overhead and requires less space on IoT devices than existing schemes, thus increasing the overall performance of IoT networks.

Additionally, we determine the objective complexity of our proposed scheme in terms of its overall storage overhead. For example, in proposed LPS, each prover P sense and store the context information CI such as unique ID, time T, location Loc, and activity Actv which is used to generate the location proof LP to be verified by the verifiers for detection of clone nodes in the network. The context information is also called the detection information that needs to be stored in a prover when the protocol for detecting node clone attacks works in networks. Each verifier V also need to sense the context information CI used to compare with the context information CI obtain from the prover P. For detection of clone nodes, each verifier V need to obtain a location proof LP from prover P which is computed from Algorithm 5. Upon receiving a latest location proof 
 from prover P, the former location proof 
 is ignored, only latest location proof 
 is stored to wait for the next location proof 
. To store all the location proofs from the prover P, a first come first served (FCFS) queue is maintained. Therefore, a fixed length of storage space including a location proof and queue is required for each prover. Each verifier V has the  tracked provers and every prover P has  verifiers, thus the total storage cost of each node (prover and verifier) is O().

The storage overhead measurement for IoT devices shows that the increase in the number of iterations performed during the clone node attack detection is the reason for the system’s total storage overhead.

6.4. Communication overhead
The term “communication overhead” in IoT-based networks refers to the data sent to or from the base station to IoT devices in order to accomplish various network operations. In our proposed scheme, communication overhead is defined as the average number of iterations (or messages) transmitted and received by each node throughout various network operations used to detect clone node attack in LPS. Along with the number of iterations, it is critical to determine the total number of bytes required for each successfully detected operation via the network since this information helps determine the network channel’s bandwidth.

The networks operations included in our proposed scheme are sensing the context information, storing the context information on some servers in location-based services, requesting and accepting location proofs between verifier and provers and between verifiers and clone nodes, and reporting of different iterations among verifiers, provers, clone nodes, and LBS as illustrated in detail in Section 4.3. We estimate the communication costs associated with these operations based on the estimated number of messages transmitted and the bytes required to transmit messages across the network channel.

Similar to the performance analysis of the proposed scheme in terms of storage overhead, we also calculated and analysed the communication overhead of our proposed scheme with the existing schemes (Zhou et al., 2016, Yu et al., 2013). Communication overhead is described in Zhou et al. (2016) as the average number of messages sent and received by each node when the method for detecting node clone attacks executes in networks. Similar to the storage overhead, the communication cost of Yu et al. (2013) localised technique for finding clone nodes is to first communicate with only its one-hop neighbours and then collect and store the information in the array. However, the communication cost for XED is about twice that of EDD, as each node maintains two arrays for data collection and communication. As a result, again, we consider the communication overhead of EDD in our results analysis because it is more appropriate and comparable to our approach.

The explanation of comparison and justification of results of different operations performed in our scheme to measure the communication overhead in terms of the message transmitted and bytes required is in the following sections.

6.4.1. No. of messages transmitted
In this section, we measure the communication overhead of our proposed scheme in terms of the number of messages transmitted over the network to perform different operations to detect clone node attack.

Our proposed scheme defines several scenarios in which different networking operations are performed to determine the communication overhead. In the first scenario, the communication overhead for provers and verifiers sensing context information to initiate the LPS process for detecting clone node attack in the network is measured. The communication overhead, in this scenario, is largely dependent on the number of iterations and the number of devices connected during the initial setup process. Verifiers are the primary devices in this operation, working with provers and the LBS to verify location proofs. Fig. 13(a) compares the communication overhead associated with an initial scenario of our proposed scheme to that of existing schemes. The analysis of this comparison demonstrates that our scheme significantly reduces communication overhead in comparison to existing schemes.

In the second scenario, we measured the communication overhead associated with storing context information on the LBS. The verifiers have a higher communication overhead than the LBS during this procedure, as they undertake additional network activities to store the context information. Fig. 13(b) shows the communication overhead associated with the verifiers and LBS storing the context information.

In the third scenario, we measured the communication overhead associated with verifying location proofs at the verifier’s side, which comprised generating requests from the verifier and obtaining location proofs from the provers. Fig. 13(c) demonstrating the communication overhead in terms of iterations required to request and generate location proofs for detecting clone nodes attack between provers and verifiers. The analysis demonstrates that the communication overhead for location proof generated on the verifiers’ side is high, as verifiers must generate the proof request and verify it with the LBS, in addition to notifying provers about the device breach.

In the fourth scenario, we estimate the communication cost of identifying clone node attack in a network. Similar to the third situation, communication overhead increases as more clone nodes are found in the network. Fig. 13(d) illustrates the communication overhead between clone nodes and verifiers in terms of iterations required to detect clone nodes in the network.

Finally, we analyse the overall communication overhead of the proposed scheme in terms of the various entities involved in the LPS, including provers, verifiers, clone nodes, and LBS. Fig. 13(e) demonstrates the overall communication overhead of our proposed LPS in terms of iterations between the system’s devices, which include provers, verifiers, clone nodes, and LBS.

By measuring the communication overhead of our proposed scheme in terms of the number of messages transmitted for various network operations aimed at detecting clone node attack, we conclude that our scheme achieved significant results while minimising the overall communication overhead of the IoT network. Additionally, we revealed the communication overhead of each device, indicating that the verifier performs numerous iterations as the primary element for verifying network operations such as sensing data, storing it in the LBS, generating and validating proofs, and detecting clone node attack in the system.

6.4.2. No. of bytes required
We consider the same scenarios as in Section 6.4.1 to measure the computation overhead in terms of bytes required. In addition, we analysed the obtained results of the computation overhead of our proposed scheme with the computation overhead of existing schemes. The results analysis of computation overhead of different scenarios is depicted in Figs. 14(a)–14(e).

By comparing the communication overhead of our proposed scheme to the communication overhead of existing schemes (Zhou et al., 2016, Yu et al., 2013), we determined that our scheme achieves significant results while executing various network operations to identify clone nodes.

6.5. Energy utilisation
As mentioned before, IoT devices are often tiny in size, price affordable, and battery-powered, allowing for mass deployment to establish large IoT networks. Furthermore, when conducting essential or non-critical tasks in IoT networks, resources such as energy, memory, compute speed, and bandwidth is greatly limited. Thus, it is essential to consider the energy utilisation of IoT devices as a performance metric to maximise the life expectancy of the overall IoT network by considering the following factors: network design, mechanism or algorithm selection, data operations, localisation method, and routing.

To measure the energy utilisation of IoT devices in our proposed scheme, we divide the energy measurement, as a performance matrix, into two distinct measurements: energy consumption and network lifespan.

6.5.1. Energy consumption
To accurately anticipate the energy consumption of IoT networks, numerous energy consumption models have been proposed (Heinzelman et al., 2002, Zhu and Papavassiliou, 2003, Miller and Vaidya, 2005), each of which measures energy consumption related to different operations performed by sensor nodes such as detecting, processing, and receiving data. We used the energy consumption model proposed by Halgamuge et al. (2009) in our work, which takes into account all energy consumption parameters, including sensing, logging, processing communication, transient, logging, actuation and cluster creation.

In sensing, the sensing system connects the sensor node to the real environment. In order to sample and convert physical signals to electrical signals, sensor power is consumed. Sensor logging consumes the same energy as reading bytes for packet production and writing it to memory for later usage. The energy required by the microcontroller for data processing and grouping is associated with two components: energy loss from switches and energy loss owing to leakage of current. In communication, a sensor radio enables energy dissipation by a sensor node in conjunction with communication with surrounding sensor nodes. This energy dissipation can be classified as transmitting and receiving data. In actuation, energy dissipation is largely application-dependent, referring to the number of sensor nodes within a cluster node. Radio and microcontroller units (MCU) offer many operating modes, including active, idle, and sleep, which require significant energy dissipation while switching between them.

In our proposed scheme, both provers and verifiers devices for detecting clone node attack consumed energy during various scenarios (i.e., operations), such as sensing and processing context information, communicating context information, and generating and verifying location proofs. In our proposed scheme, provers and verifiers communicate over a single hop. Therefore, we assume that each prover used time division multiple access (TDMA) (Falconer et al., 1995) within the verifier range. Furthermore, we utilised the same values as in the used model for various sensor nodes consumption factors such as sensing time, sleeping time, energy dissipation for activation, and actuation (Halgamuge et al., 2009). The hardware parameters utilised in our simulations, such as the current necessary to wake up the sensor and the sleep time, are taken from Mica2 Motes (mic, 2021). Since we used the specifications of actual hardware devices, as Mica2 Motes, we believe that the obtained energy consumption findings accurately reflect the actual energy consumption behaviour of devices. Finally, we used the same number of devices and parameters for network size and configuration as discussed in the evaluation framework (Section 5).

To estimate the energy consumption of IoT devices (i.e., provers and verifiers) in our proposed scheme, we considered three key scenarios related to clone node attack detection: (i) sensing and processing context information, (ii) location proof generation, and (iii) location proof verification. We measured the energy consumption of both provers and verifiers in the first scenario by sensing and processing context information. In the second scenario, we measure the energy consumed by the provers in generating the location proofs. Finally, in the third scenario, we measure the energy consumed by the verifiers in verifying the location proofs.

Fig. 15 illustrates the energy consumption of three scenarios by prover and verifier. The analysis of the results showed that in the given network size, provers utilised significantly more energy when generating location proofs than in other cases. Additionally, because the location proof verification process is distributed parallelly across the verifiers, it consumes less energy than other scenarios. Additionally, we provide a comparison of our proposed scheme’s energy consumption to that of existing schemes, as illustrated in Fig. 16. The comparison analysis reveals that our method consumes significantly less energy while detecting clone node attack, indicating that it is more efficient than the existing schemes (Zhou et al., 2016, Yu et al., 2013).


Download : Download high-res image (265KB)
Download : Download full-size image
Fig. 15. Energy consumption (Context information processing, location proof generation, location proof verification).


Download : Download high-res image (250KB)
Download : Download full-size image
Fig. 16. Comparison of energy consumption of proposed scheme with existing schemes.

6.5.2. Network lifespan
Apart from determining the energy consumption of provers and verifiers in LPS under various scenarios, we also determined the network lifespan or the total time each sensor node spent performing the various functions. In our proposed LPS approach, the network lifespan is related to the lifetime of the provers and verifiers, as they pass through various rounds, each of which comprises multiple steps. For instance, a sensor node passes through the following steps in each round: initialisation, sensing, computation, transmission, and sleep, and each phase is linked with a cost expressed in time. On the other hand, a verifier follows the same steps as a prover, except it must conduct an additional step, such as receiving data from linked provers and performing a computation on it before transmitting it to the LBS.

We used the same scenarios outlined in the previous section to estimate the lifespan of devices in our proposed scheme. In context information sensing and processing scenario, we compute the lifespan of provers and verifiers using the equation mentioned in our existing work (Hameed et al., 2018). (10)


Download : Download high-res image (270KB)
Download : Download full-size image
Fig. 17. Network lifespan (Context information processing, location proof generation, location proof verification).

The parameters in Eq. (10) are as follows: The active time cost, referred to as the initialisation cost, is 
 = 1 ms, the sensing time cost is 
 = 0.5 ms, the computational cost is 
, the transmission cost is 
 = 1000 ms, and the sleeping time cost is 
 = 999 ms. For example, we have 
 = 32.5 ms that represents the computation cost of sensing and processing the context information before sending it to the LBS. By adding all the above values in Eq. (10), we compute the lifetime of provers and verifiers in milliseconds.

In the second scenario, we utilised Eq. (10) to determine the time spent by provers on the generation of location proofs, which comprises both proof generation and location estimation. In the third scenario, we measured the time spent by the verifier validating the location proofs in order to determine the presence of a clone node attack on the network. Due to the fact that the verifier must also receive data regarding the verification of location proofs from other nodes, the verifier needs to add additional time called receiving time 
. We utilised Eq. (11) to determine the time span of the verifiers, which is composed of several time parameters associated with the steps of the sensor node. The Eq. (11) is identical to the Eq. (10), except for the data receiving time 
 and the newly computed value of 
 at the verifier. (11)

Fig. 17 illustrated the network lifespan of the proposed scheme when prover and verifiers executed various operations. As with the energy consumption analysis, the network lifespan analysis demonstrates that the provers consume more energy on generating the location proofs, extending the network’s lifespan to its maximum value, as opposed to the other scenarios.

6.6. Complexity analysis of proposed scheme
Along with analysing the communication overhead of our proposed scheme, we perform a worst-case analysis to determine its objective complexity. For example, provers and verifiers incur a network cost of N) message transmission when sensing context information. Similarly to sensing context information, storing such information to the LBS incurs N) message transmission costs across the network. We consider a tree to generate location proofs requests for provers, with the root acting as a verifier that propagates location proofs to the provers functioning as leaf nodes. The amount of location proofs sent to provers is proportional to the size of a tree. Assume that P trees are generated for the network’s provers and have a moderate degree of 
. As a result, the total number of iterations executed by the tree is calculated using Eq. (12). (12)
 

Where h is the height of the tree for the provers and is denoted as: 
 

N is the total number of devices, K denotes the average size of a subset of the tree, and the network generates a total of 
 
 sub-trees. As a result, the location proof message transmission takes 
 
 in the tree structure, resulting in a total message transmission rate of 
 
 in the network.

The transmission of iterations in a tree is identical to the creation of the tree, except that each root incurs an additional cost for transmitting a final subset iteration to the root node, such as a verifier. Thus, the iteration transmission overhead in the network is 
 
.

As a result, the objective complexity of our proposed scheme in terms of network communication overhead is estimated by combining the costs of all iterations required to perform various network operations necessary to detect a clone node attack on the network using Eq. (13). (13)
 
 

In contrast to other schemes that constantly collect and relay vast amounts of data to the base station, our proposed scheme has a lower communication overhead on the network since it is only needed to check the neighbour node’s position evidence. Since communication cost in an LPS is proportional to the number of trusted verifiers, we argue that the proposed scheme is appealing due to its mobile nature and lower communication overhead.

Table 5 compares the computational complexity of evaluation parameters such as computation overhead, storage overhead, and communication overhead in our proposed system to existing state-of-the-art schemes. According to the analysis results, our scheme has a lower overhead in all computational complexities.


Table 5. Comparison of evaluation parameters with existing schemes.

Schemes	Evaluation parameters
Computation
overhead	Storage overhead	Communication
overhead
Zhou et al. (2016)	O(N)	O()	O(N)
Yu et al. (2013)	O(N)	O(N)	O(N)
Lee et al. (2018)	O(
)	O(N)	O(N)
Our proposed scheme	O(N) + O(N) + O()	O()	O(N)
7. Discussion
This work proposed a context-aware information system-based efficient method for detecting clone node attack on mobile IoT networks. The context-aware system captures dynamic attributes about the environment (also referred to as context-aware information) of deployed IoT devices across the network. Furthermore, the proposed work supports the integration of a location proof system, which is utilised to track and locate the accurate position of IoT devices using a localisation technique. Since the proposed work is based on context-aware information of IoT devices, the location proof system employed context-aware modalities as a technique for detecting clone node attack. Furthermore, the location proof system considers a scenario in which a client of an LPS proof system, referred to as verifiers, wants to demonstrate to the LPS the existence of provers at a specific location. Thus, a prover and a verifier collect context information from their deployed environment at the same time to generate an incident context. To detect clone node attack, a verifier requests that the provers provide a piece of evidence called a location proof, which the verifier must verify via the location proof system. Comparing the context information collected from the prover IoT devices to their own context information enables them to determine if the IoT device has been compromised. To mitigate the server-side burden for verifying location proofs, this work incorporates a batch verification concept in which the verification process is shifted from the server to selected trusted devices to perform the verification in parallel, thereby improving overall computational efficiency. To select trustworthy IoT devices from a pool of available devices for batch verification, we propose a selection model that prioritises device profile features such as processing capability, sensed context information, and confidence credibility. We proposed several algorithms to illustrate the efficient execution of an LPS in an IoT environment for identifying clone node attack.

To determine the robustness, effectiveness, and applicability of the proposed work for IoT networks, a series of experiments is conducted to obtain data, followed by a detailed analysis of the proposed work’s performance in terms of achieving the following objectives: Analysis of attack detection, including the probability of detection and detection time, as well as performance-related metrics for IoT networks, such as computing overhead, storage overhead, and communication overhead. To evaluate performance, the proposed work is compared to existing state-of-the-art schemes that meet the objectives above. For instance, the detection likelihood and robustness of the proposed work are calculated using adversary capability scenarios, and it is concluded that the proposed work has a detection accuracy of 100%. Furthermore, in terms of detection time, the proposed work analysed two environments, sparse and dense, based on the number of nodes, and compared it to the existing ECDSA technique to demonstrate that the proposed work detected attacks faster. Further, to determine the efficiency of the proposed work for resource-constrained IoT devices, the computation, storage and communication overheads are also evaluated. Different contexts are explored and evaluated in terms of computation overhead, including key generation, location proof generation and location proof verification. The storage overhead analysis evaluates the storage overhead of both provers and verifiers in a location proof system, concluding that the proposed work significantly reduces storage overhead compared to previous schemes. Similar to storage overhead analysis, the proposed scheme’s communication overhead is determined by the number of iterations and bytes used in those transactions to identify clone node attack compared to existing schemes. Finally, the proposed work is also analysed and evaluated in terms of energy utilisation.

8. Conclusion and future work
This paper proposes an efficient clone node attack detection scheme for mobile IoT networks by leveraging the concept of context-aware systems to capture dynamic semantic attributes of IoT devices in relation to their deployed environment. Furthermore, we design a location-proof system that makes use of captured context-aware dynamic semantic information to generate location proofs capable of tracking IoT devices regardless of their geographic location. We used the ECDSA* batch verification concept to overcome the inherent limitations of resource-constrained IoT devices and further minimise the base station’s computational load by verifying each individual location proof concurrently on selected trustworthy nodes. We present a model for selecting trustworthy IoT devices based on their profile-based capabilities, enabling them to be chosen from the other IoT devices for the location proof-verification procedure. We implement a prototype of our proposed scheme to demonstrate its applicability to mobile IoT networks and compare its robustness and effectiveness in terms of computation, communication, and storage overhead to existing clone node attack detection schemes. The experimental results are compared to existing schemes and conclude that our system provides a robust and considerable attack detection rate for clone node attack on IoT networks while minimising computing, storage, communication and energy overhead. In our future work, we intend to develop our prototype in a real-time IoT-based scenario to assess its applicability for large industrial setups, focusing on network-related parameters such as packet latency, communication latency, data throughput and packet drop ratio, etc.