Skip to main content
Advertisement

SpringerLink

Search
Go to cart
Log in
Download PDF
Original Article
Published: 15 January 2022
Design of innovative CAPTCHA for hindi language
Mohinder Kumar, M. K. Jindal & Munish Kumar 
Neural Computing and Applications volume 34, pages4957–4992 (2022)Cite this article

53 Accesses

1 Altmetric

Metricsdetails

Abstract
Designing a CAPTCHA possessing the property of a sweet spot is always a challenge. Text-based CAPTCHAs are popular among websites. The history of text-based schemes shows that these schemes are broken with a very high success rate. Most of these broken schemes are designed using English language-based letters. It motivated the researchers to design non-English-based CAPTCHA schemes. The author has also successfully broken some Hindi language-based CAPTCHA schemes. After breaking the existing 20 typical CAPTCHA designs in the Hindi language, the authors have observed some serious limitations in a text-based scheme. In this article, the authors have used important guidelines that are proposed in the previous work by the authors. The authors implemented these guidelines to design a secure and usable CAPTCHA in the Hindi language. In this article, we have developed a new CAPTCHA based on the Hindi language and tested the proposed design from a security and usability point of view. The proposed novel CAPTCHA scheme first time uses a combination of printed and handwritten Hindi characters. The proposed scheme is 100% secure from computer attacks and also 90% usable.

Access provided by University of Auckland Library

Introduction
With the increase in online hacking attacks on the websites and the failure of most CAPTCHA schemes, there is a need for an alternative design that can be used as a CAPTCHA. The design must provide a faster and cheaper solution for stopping a computer program from attacking websites. Fig. 36 Flowchart of Version 1.0 Kevin et al. (2017) proposed an algorithm to break Google reCAPTCHA successfully, and it is a big challenge for the researcher community to think about it. So, it is the most urgent need of time to develop a new CAPTCHA that is very useful. Kumar et al. [25] have discussed the various types of CAPTCHAs. Text-based CAPTCHAs are very popular and have several advantages over other types of CAPTCHA like infinite database, user-friendliness, lots of variety, etc. But most of the CAPTCHAs are available in English language or Roman script. Unfortunately, all these are broken with high success rates. With the increasing number of internet users in India, we got the idea to design a new text CAPTCHA that is not English language-based. Hindi CAPTCHA is a better alternative for this, and some of the researchers have already developed the Hindi language-based CAPTCHA that is not secure. Designing a CAPTCHA possessing the property of a sweet spot is always a challenge. A CAPTCHA that is understandable by humans easily (usability) but not by a machine (security) at the same time possesses a sweet spot property. We developed a new CAPTCHA based on the Hindi language and tested this new design from a security and usability point of view. The whole paper is divided into eight sections. In the second section, existing work has been discussed. The third section discusses our motivation behind this research. The fourth section discusses the designing criteria of the proposed novel Hindi CAPTCHA. The fifth section is about the implementation of the proposed design. The sixth section discusses the testing of the proposed design. The seventh section highlights the scope of the research. The eighth section concludes the work with future work, and the last section is the acknowledgment section.

Background
We have classified the development of text-based CAPTCHA broadly into two types: printed text and handwritten text. Further, these two types of CAPTCHA are classified according to the language in which the text is written.

Printed text-based CAPTCHA
Printed text-based CAPTCHA in english language
Chen et al. [17] discussed that the most popular CAPTCHA scheme is text-based CAPTCHA that comes into the picture with the family of Gimpy CAPTCHAs like Gimpy, EZ Gimpy, and Gimpy-r. Gimpy CAPTCHA displays approximately ten words, and the user is asked to type three words correctly. The EZ Gimpy CAPTCHA displays only a single word with a cluttered background. Mori and Malik [30] highlighted that Gimpy CAPTCHA uses 411 words and EZ Gimpy uses 561 words. In 2003 Mori et al. proposed two algorithms to break these CAPTCHAs. They optimized the Shape Context matching technique for matching EZ Gimpy words. For EZ Gimpy CAPTCHA they proposed three steps algorithm. The first step performs quick tests to hypothesize locations of letters in the range. In the second step, they extract strings of these hypothesized letters with a Direct Acyclic Graph that form candidate words. They use tri-grams to further minimize the data set at this stage. The third step chooses the most likely word(s) by evaluating the matching score for each of these words. The success rate for EZ Gimpy is 92%. For Gimpy CAPTCHA, they proposed an algorithm that extracts the whole word at once. The algorithm success rate for finding >  = 1 word(s) in Gimpy CAPTCHA is 92%, >  = 2 words are 75%, and three words is 33%. Moy et al. [31] again broke EZ Gimpy and a newer version of Gimpy CAPTCHA that is Gimpy r, with a success rate of 99% and 78%, respectively.

Gimpy-r produces challenges that are a combination of 4 random letters among 19 letters. The challenges are hard to break with cluttered backgrounds and distorted letters. The EZ-gimpy is handled with template images because of the small database. The Gimpy-r is handled with a letter segmentation approach due to large possible combinations. The author used the concept of cores (3 most distinct circular of radius 16 pixels areas in the image and 24 mini patches for breaking EZ-Gimpy). To break the Gimpy-r scheme, the author proposed a novel technique of mesh generation and global/local distortion removal. The author claimed that these techniques can be used to remove all kinds of distortions in the images. Ahmad and Yan [2] discussed the role of colors in CAPTCHA design concerning usability and security. A number of color CAPTCHAs like Gimpy-r (81%), EZ-Gimpy (100%), LinkedIn and FreeCap (100%), BotBlock (100%) Megaupload (63.7%), BotDetect (100%), phpCAPTCHA.org (95%-100%) and Cryptograph (100%) are broken by Ahmad et al. [2]. The authors used a new Color Filling Segmentation (CFS) technique for segmentation for solving color CAPTCHAs. The algorithm fills every large connected component with a different color. Bansal et al. proposed an approach to break EZ-Gimply’s four schemes (simple background, black mesh background, white mesh background, and loosely connected characters). The authors reported a 97.90% success rate of recognition. The model uses pre-processing (image binarization, low pass filtering, and dilation), character segmentation, feature extraction (number of holes, the height of characters, maximum number of white-black transitions, light fall, and nature of vertical stroke) a finally Hidden Markov Model for recognition characters.

Imsamai and Phimoltares [20] designed a new 3D CAPTCHA in 2010. In April 2014, with some improvement, they used it. Six random alphanumeric letters are given to the user with several distortions like rotation, overlapping, straight line in the middle, salt and pepper noise, background with color/patterns, character color variation, scaling of characters, font variation, use of special characters are used to make it attack-proof. The author has shown that the scheme is resistant to pre-processing, vertical segmentation, Color Filling Segmentation, pixel count attack, OCR, and Dictionary attack. Susilo et al. [40] proposed a Stereoscopic 3D CAPTCHA. The proposed scheme is text-based CAPTCHA built from stereoscopic 3D images. It has a limitation that it is usable only with the help of 3D display glasses. It is very secure as the 3D images produce a lot of noise. The variable length also strengthens it. Nguyen et al. (2014) developed an algorithm to break the three most popular but similar 3D CAPTCHA schemes (Super CAPTCHA, 3D CAPTCHA, and TeaBag3D 1.2). The authors found some weaknesses in the design and then attacked these three CAPTCHA schemes with a success rate of 32% in 3.0 s, 58% in 4.0 s, and 31% in 4.0 s for Super CAPTCHA, 3D CAPTCHA, and TeaBag3D 1.2, respectively. Alsuhibany [5] developed an optimization technique to enhance the usability of CAPTCHA that is based on the Crowding Character Together just like Google CAPTCHA. The author has designed a three-stage algorithm to optimize usability while retaining the security of the CAPTCHA. The algorithm is based on the optimization rules that tell the system to decide what should be the optimized characters for a given confusing character, or set of characters. For example, “vv” should be replaced as “vk”, then refining the optimized text that tells the system to refine the optimized text so that after picking the non-confusing characters still the problem remains. For example, in “cl” replace with m can further create confining as “am” and finally position the optimized characters. Bursztein et al. (2014) proposed an enhancement in the Google CAPTCHA scheme by making it a more usable scheme. The usability is increased 6.7% from the previous design and it is reported 95.3%. The author applied a lot of changes in visual features (character set, change in counts of characters, font size, font families, foreground colors, background colors), anti-segmentation features (character overlapping, random dot size, random dot counts, line types, line counts, line widths, line position, similar foreground /background colors), and anti-recognition features (rotated character counts, rotated character degrees, vertical shifting sizes, character size variations, character distortions). Chellapilla et al. [15] developed a method to break some popular CAPTCHAs like Mailblocks (88.8%), Register (95.4%), Yahoo/EZ Gimpy (90.3%), Yahoo version 2 (95.2%), Ticketmaster (82.3%), Google/Gmail (89.3%). They followed a segmentation step and then a recognition step to break all these HIPs. For Mailblocks, the red channel is selected and binarizes the image. Then erosion extracts the largest connected components. Too large components were divided into two or three components. Vertically overlapped half characters are merged in the last. For Register.com, the images are smoothed, binarized, and the five largest connected components are identified. Yahoo/EZ Gimpy (no mesh) images are converted to greyscale images, a threshold to black and white, and select large connected components. (Black mesh) Image is converted to greyscale, the threshold to black and white, remove vertical and horizontal lines that don’t have neighboring pixels, and finally select connected components. In the case of white mesh, the image is converted to greyscale, the threshold to black and white, add black pixels in white line locations if there are neighboring pixels and, finally, select large connected components. For Ticketmaster, the image is converted to greyscale, and it is the threshold to B&W, dilate and then erode the image, and finally select the largest connected components. This same attack is used to break Yahoo version 2 and Google/Gmail HIP. Bursztein et al. (2011) developed a new DeCAPTCHA tool for breaking the 13 most popular CAPTCHA like Baidu, Blizzard, eBay, Google, and ReCAPTCHA. They found that most of the schemes are easily broken with their novel attack. Several guidelines are proposed to design an anti-recognition (small charset, not use distortion, use rotation in conjunction, etc.) and anti-segmentation (not use complex background, use large lines, match line slope, match line color with text, use collapsing, etc.) scheme. They also recommended using k-NN and SVM for classification. Noise removal algorithm like Gibbs denoising algorithm and line finding algorithms like the Canny Edge Detection algorithm and Hough Transform algorithm is used for noise removals. The accuracy ranges from 2 to 73% is achieved in breaking all these 13 schemes.

Yan and Ahmad [44] broke Microsoft CAPTCHA with a novel technique with an accuracy of 60% in just 80 ms. The author binarizes the image, fixing the broken characters, segmented the image vertically. After this, the Color Filling Segmentation (CFS) is applied to fill each segment with a different color. Many thick arcs remain in the challenges that are removed with some observations like pixel count, location, shape (without circle). Before recognition, some of the connected characters are present in the challenges that are removed by the pixel counts method. The author also discussed the cases where the algorithm fails to segment the challenge along with the strengths and weaknesses of the Microsoft CAPTCHA. Huang et al. [19] developed an enhanced segmentation algorithm to segment Yahoo and MSN CAPTCHA schemes, and they achieved a segmentation rate of 79% and 76% on MSN and Yahoo CAPTCHA, respectively. Two new algorithms were developed Projection and Middle-Axis point separation for segmentation of line clutters that are as thick as the characters and of varying lengths. This clutter can be intersected or not intersected with characters. With projection, the pixels counts are projected of each column on the x-axis, and using the middle axis point separation method the cutting lines are generated that cut segment the characters vertically.

Gao et al. [18] developed an algorithm to break the 5 Hollow CAPTCHAs schemes used by Yahoo, Tencent, Sina, CmPay, and Baidu. The authors achieved 36%, 89%, 59%, 66%, and 51% accuracy, respectively, in breaking these CAPTCHAs. The attack contains image binarization, repair contour lines, CFS to fill hollow parts, Noise Component Removal, Contour Line Removal, Ranking Chunks (using CNN classifier), Combine and Identity, get Optimal Partition and finally Recognition result. Contour repairing is a novel technique explained by the authors. Bursztein et al. (2014) developed a generic algorithm to break six popular CAPTCHAs schemes that are Baidu (54.38%), CNN (48.54%), eBay (48.61%), reCAPTCHA (19.74%), Wikipedia (26.36%), and Yahoo (5.33%). The algorithm is not based on classical segmentation followed by the recognition method, but it does both these tasks simultaneously. The algorithm has four vital components Cut-Point Detector, Slicer, Scorer, and Arbiter. The Cut Point Detector generates several possible cuts that are the basis for segmentation. The cuts are derived from inflection points of two curves. The curves are made up of examining the second derivative of the curve generated by following the top and bottom pixels of the CAPTCHA. The Slicer applies heuristics to extract the meaningful segments on the cut points and build a graph. The Scorer traverses the graph and applies OCR to each meaningful segment with the help of k-NN. Finally, the Arbitrator using the Ensemble Learning Approach selects the final value for the CAPTCHA. The algorithm decreases a lot of cut points by applying some filters. It also handles the occluding lines by adding a new character class to the k-NN. The author also pinpoints some areas of improvement, but we think that some design improvements can make the CAPTCHA stronger, like adding an occluding line of sine wave shapes or blobs. The character position is linear in all CAPTCHAs. Making the position of each character at a random location both vertically as well as horizontally can defeat the algorithm. Recently Tang et al [41] presented a new model for breaking text-based CAPTCHA using deep learning. They reported a high success rate in breaking Roman and Chinese language-based CAPTCHAs. Their work includes fifty different CAPTCHA schemes. Their work is Deep CNN-based.

Printed text-based CAPTCHA in Chinese language
Yu et al. [45] proposed the Chinese language-based CAPTCHA with a comparison with Roman-based English CAPTCHA. The main objective is to do a usability analysis of the Chinese characters. The usability is evaluated in terms of 3 independent variables effectiveness (average solving time), efficiency (correction rate), and satisfaction (online questionnaire and face-to-face interview). They highlighted the major difference between the cognition process of solving English and Chinese CAPTCHAs as the Chinese character set is much large and not as simple to recognize as English letters are. The study includes Random English Characters, Frequent English Words, Random Chinese Characters, Frequent Chinese Words, Less Frequent Chinese Characters, Similar Form Chinese Characters, Similar Initial Consonants, and similar Simple or Compound Vowels Chinese characters. The four types of fonts Yahei, Songti, Heiti, and Caoshu are used in the Chinese CAPTCHA schemes. The last font has the least readability. No trouble is reported in identifying the character by the humans in both languages. Algwil et al. [4] analyzed the viability of Chinese language-based CAPTCHA. The authors are motivated towards this new design due to the scalability of the Chinese character set. The Chinese language character set is large in number (3375 classes) as compared to Roman counterparts (26 classes). It is proven that computers can recognize a single Roman character with a 100% success rate. This success rate drops 60% in the worst case, but the human success rate also drops to 10%. The recognition of the Chinese character set is not tested. So the author has made an effort to try this. These three types of Character design are prepared G1 (geometric transformation and random warping), G2 (geometric transformation, random warping, eight arcs of one pixel wide that are placed on the top of each character), and G3 (all distortions of G2 with the arcs are 16). To test the designs for anti-recognition Deep Neural networks (DNN) and Multi-Column Deep Neural networks (MCDNN) are used. The error rate of DNN/MCDNN on G1, G2 and G3 is 0.407%, 7.805%, 15.517% and 10.086%, respectively. A popular Chinese CAPTCHA CAPTCHA is also tested with DNN/MCDNN, and a 0% error rate is reported. So, it was concluded that even after a successful recognition of a single Chinese character, it is possible to make a better CAPTCHA design with the Chinese language due to its scalability features.

Printed text-based CAPTCHA in Hindi language
Sushma et al. (2011) proposed a Devanagari Script-based CAPTCHA [108]. A word is a random number of letter words. The words contain “Matras” as well. To add the noise in several patterns, like a mosaic, arcs/jaws, vertically overlapped patterns are used. The headline is also removed to make it unrecognizable for the bots. The author has not given any usability rate of humans. Also, the testing for security is not checked for this scheme.

Printed text-based CAPTCHA in Punjabi language
Saini and Bala [37] developed a new Gurmukhi language based on CAPTCHA for bot protection on the internet. Several advantages are discussed of Gurmukhi CAPTCHA like good for Punjabi users, no need to learn Punjabi as the on-screen keyboard is given in the design, 41 letters are used to design random CAPTCHA so the number of possible CAPTCHAs is large, with the inclusion of audio option the CAPTCHA is usable by the users of any age without any trouble, etc. The authors reported the average time to solve CAPTCHA 14.07 s and the usability rate for humans is 75%. Security testing is also missing from this design.

Handwritten text-based CAPTCHA
Handwritten text-based CAPTCHA in english language
In 2004 Rusu et al. first time introduced handwritten CAPTCHA. It was of two types. In the first type, a collection of over 4000 images of handwritten US city names was used to generate a challenge. A nosy background is the main transformation and for making the design segment-proof arcs, lines and grids are used. Other transformations like spread, wave, median filter, and blur filters are also used as extra transformations. In the design at most three transformations are used at a time to main the usability of the scheme. The second was made of a set of 20,000 handwritten character images. A challenge contains 5–10 characters. To make the designs segment proof various types of noisy patterns like lines, arcs, rectangles, and circles) are used. To make character obfuscate various filters like median, blur, and edge filters are used. This CAPTCHA was tested with two words recognizers Word Model Recognizer [23] and HMM Recognizer [17]. For testing, a set of 4127 CAPTCHAs of US city names and 3000 non-sense word CAPTCHAs were used. Both word recognizers are lexicon-based. WMR achieved a 9% recognition rate on city name schemes and 12% on the random character-based scheme. HMM successfully recognized 4% and 3% schemes from city name-based and random characters-based schemes, respectively. In 2005 Rusu and Govindaraju proposed a novel handwritten CAPTCHA scheme that is based on the concept of Gestalt Philosophy and Perception Laws. These laws include laws of closure (ability to fill gaps of missing part into an image), similarity (ability to group similar things to create a pattern), proximity (ability to group similar things according to spatial closeness), continuity (ability to group things based on a pattern to create a whole figure), and inclusiveness (ability to see an image as a whole rather than small parts of the image) and figure-ground distinction. This scheme is also tested by WMR and Accuscript. WMR is a segmentation-based recognizer. WMR achieved a 12.9–35.9% breaking rate and Accuscript achieved a 1.5–32.3% breaking rate on the proposed scheme with a single type of transformation. This testing shows that occlusion by waves/lines/arcs is the best option to make the design safe from word recognizers. In 2009 Thomas et al. proposed a novel approach to generate syntactic handwritten CAPTCHA. This method can generate a cursive handwritten string of prewritten English character images. The characters are captured having beginning and endpoint ligatures. A novel algorithm of 7 steps is developed for generating these synthetic handwritten CAPTCHA. Thomas et al. evaluated the performance of this scheme with two-word recognizers WMR and Accuscript. Although the scheme was based on random handwritten characters that were combined synthetically the resting was done on the English words. A set of 2800 sample images was given for security testing. WMR achieved a breaking rate that ranges from 0% to 23.69% and Accuscript achieved 0%- 37.78%. This breaking rate is achieved with zero or a single type of distortion. The breaking rates decrease for WMR (1.42%), and Accuscript (2.58%) after all transformations are applied. The scheme was also tested after applying pre-processing to 4000 images. On pre-processed images, WMR achieved a breaking rate from 0% to 13.14%, and Accuscript achieved 0% to 23.97%. In 2012 Rao and Singh proposed a new random handwritten CAPTCHA that is based on colorful words and numbers. This time handwritten characters are not only taken from alphabets but numeric characters are also used. The length of the CAPTCHA also varies from 4 to 7 characters. The combination of words and a number is placed vertically also. Character images are taken from answer sheets of students and closeted as upper alpha, lower-alpha, and numbers. An algorithm starts by picking two numbers from (4, 5, 6, and 7) for a length of CAPTCHA words. After then every character is taken from the clusters along with a color code. Even the scheme uses the vertical placement of words, but the user is free to ignore leading and trailing spaces. Rao and Singh tested the proposed scheme from a security point of view by feeding the sample CAPTCHA images into five free OCRs. Breaking rate are 25.5, 13.91, 16.57, 11.1 and 17.5% achieved by OnlineOCR, freeOCR, freeOnlineOCR, newOCR and i2OCR, respectively. In 2015 Leiva and Alvaro proposed µcaptcha based on mathematical equations. The name “µcaptcha” is taken due to the use of mathematical (66 symbols) symbols that are commonly used in a mathematical equation. To pass the challenge the user has to draw over the already written equation. The developers want to make a CAPTCHA for touch-capable devices on which traditional text-based CAPTCHA needs more time to solve. Highlighting CAPTCHA is also works similar to the µcaptcha, but it requires a high precision while drawing on the touch screen. On mobile devices, high precision is not ubiquitous due to the cost of touch screens cost. The scheme requires 4–6 strokes to solve the challenge. This scheme is also tested with the proposed scheme with InfyReader (mathematical OCR). The sample images are given after applying a binary filter. Even after the use of morphological operations not able to de-noise the image. The InfyReader did not recognize the challenge. In 2018 Aldosari proposed a multilingual handwritten text-based CAPTCHA in which text combines multiple languages (English, French, Spanish and Arabic). CAPTCHA language is selected as per the region of the user extracted from the IP address of the web page. The character images were collected by writing alphabets in four languages by 100 volunteers that make the database of 10,700 images. Multilingual CAPTCHA is also tested with ready-made OCRs. Total 6 OCR tools (TesseractOCR v 3.01, Capture2Text, i2OCR, freeOCR, onlineOCR and newOCR) are used to break the design. 500 CAPTCHA samples for each Language are tested. For English, French, and Spanish all the six OCR tools are used. For Arabic, only i2OCR and newOCR are used. A collection of 10,000 samples is given to these OCR tools, and the recognition rate for Multilingual CAPTCHA is reported as 0.06% that is not acceptable for a CAPTCHA to be a secure one. Recognition rates for partially recognized, not recognized, and not found are 3.97, 46.36, and 49.61%, respectively.

Handwritten text-based CAPTCHA in arabic language
Alsuhibany [7] developed an Arabic Handwritten CAPTCHA for cybersecurity. It is easier for Arab users to solve Arabic CAPTCHA. The images are generated from the KHATT database of offline Arabic handwritten text. Various distortions are applied to 28 Arabic characters. Arabic characters are special features as they have different shapes of a single character when used in the beginning, middle, and end of the word. The overlapping of characters in the writing style of the Arabic language also makes it a secure scheme. Also, the author has used the less mature Arabic OCR as an advantage for this new CAPTCHA. The algorithm contains six steps. In the first step “Pseudo Word Generation”, a three to eight random letter word is generated, that is converted to Unicode in the second step “Converting Characters to Unicode”. In the third step “Selecting a Writer”, the algorithm selects a specific or random writer to generate CAPTCHA. In the fourth step “Selecting a Character Image” the image of each character is returned to make a handwritten Arabic word. The background of height 200 pixels and random width including several handwritten character images are also prepared in this step. In the fifth step “Detecting Joint Points and Connection”, the algorithm connects the characters to make a complete word. In the final step “Binarization”, the image is converted to B&W. Distortion of black arcs, white arcs, or a combination of black and white arcs of different widths and lengths are used. For testing Tesseract, ABBYYY, and Newocr.com engines are used. They are failed in recognition of the characters. The robustness of CAPTCHA is 98.3%. Parvez and Alsuhibany [33] tested an Arabic scheme for security using two words recognizers (a structural word recognition-based and a Convolutional Neural Network-based). 5000 CAPTCHA samples of each distortion level (total 20,000 CAPTCHA samples) are tested for structural word recognizer. The recognition n rate for distortion level 0, 1, 2 and 3 are 32.2%, 0.04%, 1.86% and 0.06%, respectively. For CNN (25 layers) based word recognizer 40,850 sample images are used. This time samples from distortions levels 1, 2, and 3 are used. The recognition accuracy for level 2 distortions is reported 28.12%, and for level 3 it is reported 7.21%. It is to be noted that for both types of recognizers only characters are recognized not the segmentation points. Sot the challenge remains half unsolved. Google reCaptcha is the most popular CAPTCHA. Kevin et al. (2017) developed a method known as un-CAPTCHA to attack Google ReCaptcha by attacking its audio challenge. They reported an 85.15% success rate over-testing of 450 challenges. Their method solved successfully 450 challenges in just 5.42 s. They used a speech text for text generation and speech recognition systems (Google Cloud, Bing Speech Recognition, IBM Bluemix, Google Speech API, Wit-AI, and Sphinx) for recognition. They also used the concept of phonetic mapping and ensemble. Some of the CAPTCHA schemes discussed in this section are also shown in Fig. 1.

Fig. 1
figure 1
Samples of text based CAPTCHAs

Full size image
Motivation
From the existing developments in CAPTCHA, it is clear that it is hard to design a CAPTCHA that is secure as well as usable. Several CAPTCHAs are successfully compromised. Some research has proven that non-native language-based CAPTCHAs are more usable for native internet users. Banday and Shah [8] did analyses of the multilingual and native lingual CAPTCHA on the websites. They observed that users are more accurate and fast for the native language CAPTCHA compared to English language-based CAPTCHA. The experiment with Urdu CAPTCHA shows that even after the noise is added to native CAPTCHA the accuracy is less decreased (only 1% to 6%) as compared to English (12–17%). The study also shows that audio CAPTCHA is more difficult as compare to text CAPTCHA and image CAPTCHA. So, the native language CAPTCHA can be beneficial for the users. This idea motivated us to design a CAPTCHA for the native internet users of Indian. We picked up the Devanagari script after considering its impact on the Indian population as well as the world population. Here are some of the key points that show the importance of Hindi in websites. There are a total of 121 languages and 270 mother tongues. Twenty-two languages are specified in the eighth schedule to the Constitution of India. India has a total population of 21, 08, 54, 97, 7100 and 52, 83, 47, 193 number of persons who returned the language Hindi (and the mother tongues grouped under each) as their mother tongue. It is 44% of India’s population. The data from census 2011 clearly shows that the number of citizens in India whose mother tongue is Hindi is increasing drastically. The Hindi language also takes a very important place in the table of the world’s languages. Hindi is the 4th widely speaking language in the world, as shown in Table Table 8 Denoising and segmentation of sample image of Version 2.0[Display Image Removed]1.

Table 1 List of most widely speaking languages in the world (Wikipedia)
Full size table
It is also important to know that number of users in India is also increasing at unbelievable speed. India is the 2nd Country whose percentage of the population is using the Internet (https://www.internetworldstats.com/top20.htm) as shown in Table 2.

Table 2 Top 10 Countries with the highest number of Internet users, December 31, 2017
Full size table
43% of India’s population can feel comfortable by a secure using Hindi CAPTCHA. The government can achieve its goal of ‘Electronic Governance’ by making its sites secure with native content. The most popular CAPTCHA will be alive again with all new security features. The Indian websites will be more secure by the bot programs. The proposed technique for developing the Hindi language CAPTCHA may also be used for developing CAPTCHA of other Indian languages. In the literature, some native language (Devanagari and Gurmukhi) CAPTCHAs exist. The security of these schemes is not tested, so we have tested the security of Devanagari script-based CAPTCHAs. We tried to break 20 unique Devanagari script-based CAPTCHAs (Kumar et al. [25]), and it was founded that text-based CAPTCHAs need to be made secure from the segmentation point of view. We also proposed the benchmarks [27] for designing a secure and usable Devanagari CAPTCHA that is implemented in this work.

Design criteria
To design a text CAPTCHA, several factors like characters, fonts, noise, and the number of characters, are needed to be considered. For this novel design, we have chosen the following important factors.

Character set
What character set should be used? It is important to select the appropriate character set. We have selected 45 characters from the Hindi language, as shown in Table 3.

Table 3 Selected character set
Full size table
We selected these characters by observing the following important factors:

Previous designs use a lesser number of characters. Some of the characters are very similar that creates confusion. We have selected 45 different characters and removed some of the confusing characters that were used in previous schemes. The additional characters are 'ई', 'ऐ', 'ऊ', 'औ', 'व', 'ह', 'श', 'ष', 'स'. We decided to remove the following The removed character are ‘ऌ’, ‘ऩ’, ‘ऱ’, ‘ळ’.

The main reason for our choice is that these characters are commonly used. It is clear from the keyboard layout in a smartphone, as shown in Fig. 2a and b. Most people access websites through smartphones and these 45 characters appear on a commonly used Hindi keyboard.

We have removed confusing letters like ‘ऌ’, ‘ऩ’, and ‘ऱ’ to enhance usability.

We have added new characters like 'ह', 'श', 'ष', 'स', 'ई', 'ऐ', and 'ऊ' that are unique in appearance. That will make the design recognize proof and also increase usability.

Even we have used some similar characters like ['ब' and 'व'], ['इ' and 'ई'], ['ए' and 'ऐ'], ['उ' and 'ऊ'] and ['ओ' and 'औ']. We have designed the CAPTCHA in such a way that it does not create any confusion for humans and retain its usability.

Fig. 2
figure 2
Smartphone keyboard layout

Full size image
Font
The CAPTCHA should not depend on one type of font design within a single challenge. We have selected 12 different types of readymade fonts and categorized these fonts as bold (312 characters) and regular (225 characters). Table 4 lists the name of these fonts S.N. field is just the serial number of font families, and the Font family field contains the name of the font family.

Table 4 Selected font families
Full size table
One of the bold styles also includes hollow characters (DINA 20).

From Figs. 3, 4, 5, 6, 7, 8, 9, 10, 11, 12. 13 and 14 shows the font face of the selected font families as shown below.

Fig. 3
figure 3
A_Akhil font

Full size image
Fig. 4
figure 4
Amita font

Full size image
Fig. 5
figure 5
Arya font

Full size image
Fig. 6
figure 6
Arya2 font

Full size image
Fig. 7
figure 7
Bahun font

Full size image
Fig. 8
figure 8
Baloo font

Full size image
Fig. 9
figure 9
Bhakapur font

Full size image
Fig. 10
figure 10
DINA20 font

Full size image
Fig. 11
figure 11
DV-TTSurekhEN font

Full size image
Fig. 12
figure 12
Mahamaya font

Full size image
Fig. 13
figure 13
Rozha one font

Full size image
Fig. 14
figure 14
Tillana font

Full size image
Handwritten characters
We have also included handwritten Hindi characters to enhance the security of our design. These handwritten characters are of further of two types. One is with a black background and white foreground (160 characters), second is with white background and black foreground (215 characters). Figure 15a shows samples of these handwritten characters with a black background, and Fig. 15b shows handwritten characters with white background. We got these handwritten character sets from UCI and Kaggle repositories that are freely available.

Fig. 15
figure 15
Handwritten characters a black back color and white fore color, b white back color and black fore color

Full size image
Background shade
The biggest weakness that we observed in all text-based schemes is the single type of background. In this novel design, we have used different backgrounds for each letter. It will make the design segment proof at an optimum level. We also used the concept of randomness here. For making the background so versatile we have used three types of background depending on the shades of colors. The dark background used darker colors. The medium backgrounds have shades that are not very dark and not very light. Finally, light backgrounds have lighter shades than the first two. Figure 16a–c shows the samples of dark, medium, and light backgrounds, respectively.

Fig. 16
figure 16
a Dark, b medium and c light shaded backgrounds

Full size image
These backgrounds are of random shapes. We have also chosen a random portion of 50 × 50 of these backgrounds while picking as a background. There are 100 backgrounds under each category that make a total of 300 backgrounds.

Use of color
Human eyes are very sensitive to colors. We have also tried to make use of colors in characters and backgrounds as well.

Use of colors in backgrounds
Some of the colored backgrounds are shown in Fig. 17a-h. Colored backgrounds are not just filled with a solid color. Figure 17a, b and f are colored with texture. In Fig. 17c, and d multi colors are used as strips. In Fig. 17e, gradient shades of colors are used. In Fig. 17g natural scenes are used, and finally, in Fig. 17h, a 3-D object has been presented as a background. When the characters are embedded in these colored backgrounds the characters become segment proof. These backgrounds make CAPTCHA also very interesting to look at.

Use of colors in characters

We also use colors in character generation. Single-colored characters are easy to extract from the images, so we used the concept of multi-colored characters. Figure 18 shows a solid-colored character.

The character is visible but it is also very easy to segment this character. To avoid such risks, we have also used the concept of multi-colored characters as shown in Fig. 19 (a) and Fig. 20 (a). In Fig. 19 (b) the different colors are visible. Figure 20 (b) is also showing the various darker shades in the character. Such variations in colors make the character difficult to segment from the background. The background used in Fig. 19 (a) is a solid black color but in actual implementation, the backgrounds are not filled with such solid colors.

Use of scaling factor

It was observed that different scaling has a good effect on the security of a CAPTCHA. We have used the scaling both in backgrounds as well as characters. The purpose of scaling is to increase the variety of information present in the design.

Use of scaling factor in background

It looks strange to use scaling in the background, but we have a very sound reason for it. As we have used only 300 backgrounds so to increase the variety in the backgrounds, scaling will help a lot. For example, using 300 backgrounds with six different scaling factors, the total combinations of backgrounds become 300 × 6 background patterns. Figure 21 shows a background with original scaling, and Fig. 22 (a)–(e) shows the various scaled versions of it.

It is clear from Fig. 22 that the same background can represent five different versions of the same pattern character and background. Now it is difficult to write a program to extract a particular type of pattern. It would be slow if someone tries to make a program to extract patterns of different scales.

Use of scaling factor in character

Fig. 17
figure 17
Color backgrounds

Full size image
Fig. 18
figure 18
Solid colored character

Full size image
Fig. 19
figure 19
a Multi-colored character, b multi colors

Full size image
Fig. 20
figure 20
a Multi-colored character with darker shades, b various shades

Full size image
Fig. 21
figure 21
Background with original scale

Full size image
Fig. 22
figure 22
Different scaled version of Fig. 21 a 150%, b 120%, c 90%, d 70% and e 50%

Full size image
Similar to scaling in the background, we also adopted scaling of the character image. We have used a total of 912 characters images, and we also used to scale these images with six different scale factors, so it makes the combinations of 912 × 6 images. To retrieve such a huge number of letters will is almost impossible. Even if the characters are captured with a lot of effort, the classifier will have to train on all the images. It slows down and makes the classifier so bulky that it will take a lot of time to recognize the images. Note that here we are talking about only clean letters without any rotation, color combinations, and noisy patches, etc. Figure 23b–e shows a character image with differently scaled versions of Fig. 23a.

Fig. 23
figure 23
A character with different scaled versions

Full size image
Use of rotation
We also used the concept of rotation to generate a greater number of patterns both with backgrounds and character images.

Rotation of background
It is observed that the rotation of an image can generate multiple versions of the same image. It will enhance the security of a CAPTCHA. We have used the maximum range of rotation, i.e., from 0 to 360 degrees, for the background. Figure 24 shows the original background, and Fig. 25a–j shows the various rotated version of this background.

Fig. 24
figure 24
Original background

Full size image
Fig. 25
figure 25
Rotated versions of original Fig. 24

Full size image
From Fig. 25a–j, it is clear that a single image appears differently with a different angle. We have a total of 300 background images, and with the use of 0–360 degree rotation, the number of background images becomes 300 × 360. It makes a huge number of patterns in the background.

Rotation of character image
Similar to the background we have implemented rotated versions of character images. We have used a smaller range of angles from -350 to + 350 to rotate a character image due to the risk of decrease usability. Figure 26a–e shows a character image with its rotated versions.

Fig. 26
figure 26
Character image with rotated versions

Full size image
Use of cropping
It is our observation that if someday it is possible to recognize all the variations of background images are collected, then the design will be vulnerable to attack. One more tool that can be exploited is to increase the number of background images tremendously. Cropping of an image is a common method. It will help in increasing the number of patterns if we crop an image randomly for a fixed size. However, if the image has only a regular pattern then this technique might not be very useful. It will produce a different background every time if the background has an irregular pattern. For example, an image shown in Fig. 27, can be used to generate all images in Fig. 28a–o with the help of a cropping tool.

Fig. 27
figure 27
Image with irregular background

Full size image
Fig. 28
figure 28
Cropped images of Fig. 27

Full size image
We can see that all fifteen background images are generated with only a single background. It is possible to use one image in this way because the original size of these backgrounds is larger. We need a small amount of area to hold a single character image. We have blended the character image on these smaller cropped images. 15 sub-images are just to clarify the idea. In actual implementation, we have created many more images from a single image every time. For example, it is possible to generate 2500 backgrounds of 50 × 50 size if one background has a 100 × 100 pixel size is cropped. It will increase the security to much extent.

Addition of noise
We also added traditional noisy patches like lines, arcs, and circles. We have generated seven types of artificial nosy patches that add an extra layer of security to our design. These different types of noisy patches are discussed below:

Arcs
Arcs are always selected as a pattern of noise in CAPTCHA designs. We also used arcs as a hurdle for a program. We do not use arcs of black color because black arcs are always mixed with the information and make it non-usable. Colorful arcs are not so much irritating and also hide the information about the letter. Removing these arcs by selecting a particular color is not possible because we have created these arcs using a range of colors. A major portion of the character will also be removed if someone removes these arcs. We have also picked random thickness of the arcs that will add more security to our CAPTCHA. It is not possible to remove arcs based on a particular thickness. Similar to color, the thickness of noisy patches also plays role in removing the character information while removing an arc based on thickness. Figure 29 shows the use of random arcs. In Fig. 29a, b, and c, the arcs are generated at random positions with random colors and thickness.

Fig. 29
figure 29
Random use of arcs

Full size image
In Fig. 29a and c the arcs are implemented on a straight character image and in Fig. 29b the arcs are implemented on a rotated and scaled-down image. The variation in the color of arcs is clearly visible. Also, the variation of thickness can be observed.

Triangles
We have also used a new kind of patch that is triangle-shaped. We implemented this patch also in a colored pattern of noise. The variation in size and thickness is also implemented. Figure 30a–c shows the use of a triangle as a noisy patch.

Fig. 30
figure 30
Triangles as noisy patches

Full size image
In Fig. 30a, triangles are implemented on a scaled-down image. In Fig. 30b, the image is normal-sized, and triangles are on different locations finally, in Fig. 30c, overlapping triangles are used with a scaled-up image.

Horizontal lines
Lines are also a common type of noise in CAPTCHA history. We have implemented three types of lines as a noisy patch. Horizontal lines, vertical lines, and randomly inclined lines are three types that we have used. Figure 31a–c shows the use of horizontal lines. These horizontal lines are also assigned random colors. The number and locations of lines are also random. We can also see the randomness in the thickness of these lines. In Fig. 31a, three lines are present, and all have a random thickness. In Fig. 31b, the positions and colors of the line are different, but the number of lines is three again. In Fig. 31c, the number is 4 also the locations and colors are selected randomly.

Fig. 31
figure 31
Horizontal lines

Full size image
Vertical lines
Similar to horizontal lines, we have used vertical lines as a noisy pattern. Figure 32a–c shows the use of vertical lines. In Fig. 32a, b, and c, lines are of different colors, different locations, and different numbers are added to the character images. It is important to see that character information is very clear even after the use of these lines due to the use of colors. Also, the effort of removing lines is not possible without using the information of the letters. So, these lines are contributing towards the security of CAPTCHA.

Fig. 32
figure 32
Vertical lines

Full size image
Random lines
In addition to horizontal and vertical lines, we have also included the concept of randomly inclined lines. These are the most difficult noises to be removed from an image. The lines have different thicknesses as well as different colors. Figure 33a–c shows the use of these randomly inclined lines. In Fig. 33a, only three lines are present, while in Fig. 33b and c, more lines are present. We can observe the variation in the thickness of these lines. The colors are also randomly selected for these lines. The most important fact is that information of the characters is easily understandable by humans.

Fig. 33
figure 33
Randomly inclined lines

Full size image
Ellipse
A less commonly used patch is an ellipse. It contributes to security but does not affect usability. Due to the use of colored elliptical patches, it is easily distinguished from the character information. Figure 34a–c shows the effect of these elliptical patches. In Fig. 34a, b, and c, the randomness of colors, positions, sizes, and numbers can be observed. In the Hindi language, no elliptical pattern is present, so they do not decrease the usability. Their presence can strengthen the design.

Fig. 34
figure 34
Use of elliptical patches

Full size image
Circle, diamond and star
The most commonly used noisy patch is the circular patch. Many of the characters in the Hindi language have a circular patch at all locations. It makes its usage risky. To avoid this risk, we have used the circular patch in various colors. With the circular patch, two more types of the patch are generated one is a star and another is a diamond. Figure 35a the circular patch is used. In Fig. 35b, c, and d, the diamond and star-shaped patches are also visible. These patches are not interfering with the information but provide a lot of randomness in the noise that will make the design very secure.

Fig. 35
figure 35
Use of circular, diamond and star patch

Full size image
Methodology
The detailed implementation of the model is described in the next section.

Implementation
With the implementation of all the above segments, we have developed two versions of our new CAPTCHA that is based on the Hindi language. Both of the versions have a difference in terms of noise. There are fewer noisy patterns in the first version. The second is designed with more number of noisy patterns. The difference is more elaborated with the help of a working flowchart of both these designs. We have implemented the extensive use of randomness in our designs that are the basis of security. We have also taken care of the usability concern.

We have chosen five types of segments S1, S2, S3, S4, and S5 for preparing each character image of the final CAPTCHA image. All five segments are occurring at least one time in the design. The position is also changed randomly each time that makes the design unpredictable. These segments are different in Version 1.0 and Version 2.0. All five segments for Version 1.0 are explained in Table 5. The Segment field represents the segment name and the Segment creation field highlights the steps to create the segment.

Table 5 Segments for version 1.0
Full size table
The flowcharts for both the versions Version 1.0 and Version 2.0 are shown in Figs. 36 and 37 below:

Fig. 36
figure 36
Flowchart of Version 1.0

Full size image
Fig. 37
figure 37
Flowchart of Version 2.0

Full size image
Samples
Here we have shown some of the samples of our proposed CAPTCHA. Figures 38, 39 show 12 sample images of proposed Hindi CAPTCHA Version 1.0 and Version 2.0. From all the samples in Figs. 38 and 39, it is clear that the length of CAPTCHA can vary from five to eight characters. Figure 38b, c, e, and h have five characters. Figure 38f has six characters. Figure 38a, d, and i have seven characters, and Fig. 38g has eight characters. All the variations of fonts, backgrounds, patches re successfully implemented in this design.

Fig. 38
figure 38
Samples of proposed Hindi CAPTCHA Version 1.0

Full size image
Fig. 39
figure 39
Samples of proposed Hindi CAPTCHA Version 2.0

Full size image
The length of CAPTCHA in Fig. 39a, e, and f is five. It is six in Fig. 39b and d. It is seven in Fig. 39d, h, and i. In Fig. 39c and g, it is eight.

Testing Security and Usability of proposed CAPTCHAs
With the advancement in machine learning and deep learning models, recognition is getting very high accuracy. That is why the field of character recognition is also improving. The strength of a CAPTCHA relies majorly on its anti-segmentation characteristic. If a CAPTCHA is not safe from segmentation then it is not a secure CAPTCHA. To test both of our proposed designs (Version 1.0 and Version 2.0), we have tested these designs for various kinds of segmentation attacks because recognition starts after the successful segmentation of characters. The details of attacking our design are discussed in the following sections.

Denoising
To start the de-captcha process, we must start by cleaning the image. In our case, cleaning the image is not possible due to so much variation in the background. Let’s try to clean an image as shown in Fig. 40a. It is from Version 1.0. We tried to clean it with the various image processing operations like binarization, high pass filters, low pass filters, and morphological operations, etc. Figure 40b shows that after conversion of the original image into binary. Out of seven, only one character is clear, and all others are not. The second, fifth, sixth, and seventh characters are so disturbed that no program can segment these. So binarization alone is not very useful. Most of the time, noisy patterns can be removed by blurring the image. This practice is used many times by us in cleaning the existing Hindi CAPTCHA schemes. The use of multiple backgrounds has the advantage that blur operation is not able to clean the noise from the image. That can be seen after generating the binary version of the image. Figure 40c shows the effect of the binary operation of a blurred version of Fig. 40a. Figure 40c shows that even after blur operation the binary image is not much cleaned. This is due to the variations that we have implemented in the design. Similar to blur the median is also a very common operation that we have used to clean the noise from the image. Figure 40d shows the effect of the median filter on the original image. This time the shades are very clean and smooth, but the noisy backgrounds have so many variations that nothing has changed in the background noise. The minimum filter is also useful to minimize the noise. The use of the minimum filter is shown in Fig. 40e. The result of the minimum filter is also not very useful for cleaning the image. The second and third characters are almost washed out. It is due to the use of different thicknesses in font and variations in font designs. The maximum filter is also very effectively used by us in the denoising step for existing Hindi CAPTCHAs. Figure 40f shows the result of the maximum filter on the sample image. The results are better than a minimum filter. The second and third letters are visible after denoising the image. But the noisy background makes the character extraction very difficult. So, the efforts of removing noises from the characters are gone in vain. Several morphological operations are used to clean the images. To use these morphological filters the image must be in binary format. We have used these morphological operations extensively for denoising the images of existing Hindi CAPTCHA schemes. There are four major morphological operations. We have applied all these to our sample image. Binary erosion is very effective in removing noise in binary images. In a binary, the white pixels are considered as foreground and black pixels are considered as background. With the help of this operation, the foreground area is shrinking according to the kernel definition. So, if white noise is present then it can be cleaned with binary erosion. We also used this operation for denoising the images. The result of binary erosion on our sample image is shown in Fig. 40g. The results also do not contribute to cleaning the image. Too much use of binary erosion also has negative effects of creating noise or losing the information from the image. Binary dilation is the reverse of binary erosion. This operation shirks the black pixels in a binary image. This operation is very effective for removing the noise if there are black noisy pixels present. The use of binary dilation on our sample image is shown in Fig. 40h. Due to the randomness in the image, the dilation process failed in cleaning our sample image. The fifth and seventh letters are lost in the noise. It is not easy to segment characters from the image. These operations are combinations of binary erosion and binary dilation. The binary opening is nothing but erosion followed by a dilation. This operation gives smoothing to the image by breaking narrow joins and removing thin protrusions. We also used this operation many times to solve the schemes. The effect of this operation also does not show any significant task in cleaning the image as shown in Fig. 40i. All the narrow breaking points are filled nicely if the comparison is made in the binary version of Fig. 40b and this opened version of the sample image. But the noise is not much cleaned. The binary closing operation is just the reverse of binary opening. Binary closing is nothing but a dilation followed by erosion. Binary opening and closing are second-level operations because they use the basic operations and utilize their results. This operation also gives smoothing to the image by joining the narrow breaks and thin differences. It is also very useful in filling small holes. We also used this operation many times to solve the existing Hindi CAPTCHA schemes. This operation is not able to perform any noise cleaning in the image, as shown in Fig. 40j. Another important filter that can be used indirectly for denoising purposes is the edge filter.

Fig. 40
figure 40
a Original sample, b binary filter, c blur filter, d median filter, e minimum filter, f maximum filter, g binary erosion, h binary dilation i binary opening j binary closing, k edge filter and l skeleton filter

Full size image
There are a lot of edge filters available in image processing. It looks strange that how edge-finding can be utilized in the de-captcha process. We have used this several times this filter to find a way for character segmentation. Most of the noisy patterns are wiped out very quickly. That is why we also tried this filter to clean the sample image. Figure 40k, gives the result of an edge filter on the sample image of Fig. 40a. Many of the noisy areas are cleaned. Character boundaries are also clearly visible after applying the edge filter. But the information of characters is not extracted from this image. The 2nd, 5th, and 7th characters are broken into several pieces, and it is hard to extract useful information from these characters.

So, it shows that edge filters are also not much effective here in character segmentation. The skeleton filter is the most effective in noise-cleaning because it retains the minimum information of the image. It is extensively used in image processing to get the basic structure of the pattern. We do not use this filter in our previous work while cleaning the 20 schemes [26], but we tried it on our sample image, as shown in Fig. 40l. It is clear that character information became visible, but it is also not effective in clearing the noisy pattern in the image.

Security testing of proposed scheme with all proposed algorithms
A CAPTCHA is assumed to be secure if it is not easy to segment. The proposed new Hindi CAPTCHA is secure from all tools discussed above. Individually these tools are not able to segment the new proposed design. What will happen if all these tools are used simultaneously to break our new proposed Hindi CAPTCHA? This is a question that can be answered by testing this new scheme with previously proposed CAPTCHA-breaking algorithms [26] (Table 6).

Table 6 Segments for Version 2.0
Full size table
We have tested all the breaking algorithms developed on new designs. We came to the result that these algorithms are not able to segment the designs also. We tested these algorithms on 2000 CAPTCHA images from both versions (1000 in each version). There are 6480 characters in the sample images of Version 1.0 and 6518 characters in the sample images of Version 2.0. Every character class is used in this 2000 sample. Then we tried to segment the images. Figure 41 shows a sample image out of 1000 samples of Version 1.0. Table 7 shows the results of cleaned images by all the algorithms.

Fig. 41
figure 41
Sample image Version 1.0

Full size image
Table 7 De-noising and segmentation of sample image of version 1.0
Full size table
Table 7 shows the algorithm, the result of cleaning the image of that algorithm, and the extracted characters by each algorithm.

Table 7 shows that even the use of all breaking tools simultaneously is not able to clear the images of Version 1.0. Even a single image is not segmented at all. Not a single character is perfectly segmented. We have tested 1000 samples, and we observed that no single sample is segmented with 100% accurate segmentation with all algorithms. So, it makes our new Hindi CAPTCHA Version 1.0 is segment-proof. Figure 42 shows a sample image of our proposed Hindi CAPTCHA Version 2.0. All the segments are overlaid with noise.

Fig. 42
figure 42
Sample image Version 2.0

Full size image
Table 8 Denoising and segmentation of sample image of Version 2.0
Full size table
Table 8 shows the attack of all 20 algorithms on Version 2.0. Table 8 shows that even the use of all breaking tools simultaneously is not able to clear the image of Version 2.0. We have tested 1000 samples, and we observed that no single sample is segmented with 100% accurate segmentation with all algorithms. So, it makes our new Hindi CAPTCHA Version 2.0 also segment proof.

Table 9 shows the rate of segmentation for both of the proposed versions. We have 6480 and 6518 characters in Version 1.0 and Version 2.0, respectively. Table 9 shows the name of the previously proposed [26] algorithms and correctly characters segmented out of total characters in 1000 samples. Table 9 also shows the success rate of segmentation. We observed that only handwritten characters in which no noise is added (Version 1.0) are segmented. It is important to note that at most three handwritten characters can be present in an image. We also observed that no single CAPTCHA is segmented with a 100% success rate. So, our new CAPTCHA is very secure.

Table 9 Success rate of segmentation on proposed Hindi CAPTCHA Version 1.0 and Version 2.0
Full size table
Figure 43 visualizes Table 9 where the x axis represents the algorithms and the y axis represents the segmentation rate achieved on the new proposed CAPTCHA design. It is clear that Version 2.0 is more segment proof as compared to Version 1.0.

Fig. 43
figure 43
Segmentation attack on V 1.0 and V 2.0

Full size image
We have achieved a segmentation rate for Version 1.0 that ranges from only 0.12% to 7.16%. For Version 2.0 the segmentation rate decreases, and it varies from 0% to 2.03%. It is clear after observing Sects. 6.1 and 6.2 that the proposed scheme is segment-proof. It is not possible to extract all the characters in any single CAPTCHA sample. We have observed the following important reasons that make our proposed scheme so strong. These reasons show that why the use of image processing tools (individual and collective) has no effect in segmenting the characters.

Each of the character images contains a separate background pattern that makes it very difficult to write a code that can remove the background. In all of the previously proposed schemes, the background pattern is single that is easy to remove.

The use of color, greyscale and binary background also make the scheme too hard to segment.

The presence of multi-colors inside a single character makes it harder to pick particular color information. This information can be exploited to extract that character later.

The use of overlaid noisy patterns makes the extract of characters very hard.

The use of the handwritten and printed characters in a single CAPTCHA is used the first time that adds extra security in the design.

The use of multiple font styles adds an extra level of security. The random use of various transformations, (rotation and scaling) makes it harder to extract a whole character image from the scheme.

Usability
A CAPTCHA must not be secure only, but it must also be usable. The usability says that it must be solvable by humans easily. After testing the security of our new Hindi CAPTCHA, we have to test its usability. For this purpose, we developed a GUI that generates a single CAPTCHA at one time. We showed it to various users and matched the input with the image. The age of users varies from 8 to 72 years. The qualification of the participants also varies from primary class to post-graduation. Tables 10 and 11 show the usability statistics of our proposed Hindi CAPTCHA Version 1.0 and Version 2.0, respectively. Figure 44 visualizes Tables 10 and 11. Users are more comfortable with Version 1.0 as compared to Version 2.0. The time required to solve Version 1.0 is less than Version 2.0. There is a big margin for Version 1.0 and Version 2.0. So, Version 2.0 is below the acceptable rate as for as usability is concerned.

Table 10 Usability statistics version 1.0
Full size table
Table 11 Usability statistics version 2.0
Full size table
Fig. 44
figure 44
V 1.0 and V 2.0 usability comparison

Full size image
We observed that it would not be a good idea to increase the complexity of the design as the usability decreases below a sufficient level. The comparison of the security and usability of the proposed design with the existing schemes is shown in Table 12.

Table 12 Usability and security comparison of proposed design
Full size table
It is clear from the above Table 12 that the proposed Hindi language-based CAPTCHA is stronger and more usable as compared to English language-based CAPTCHA. There is a significant difference in both of the criteria (security and usability) of a CAPTCHA scheme. We observed the following points that make the scheme more usable:

The gap between characters is very enough that makes the characters easily readable.

The use of bright color in character also makes the scheme useful.

The transformation of background and character is not too high that makes the characters readable.

The use of colored noisy patterns like lines, ovals, triangles does not affect the usability of the scheme while providing more security in the proposed scheme.

The shape of noisy patterns does not resemble the character that also proves good for the usability of the scheme.

The selection of the character set also played a positive role in this scheme. We have most of the dropped similar characters that create confusion among the users.

Indeed, classification problems must also include the use of deep learning attacks. Deep learning can be used to break a text-based CAPTCHA scheme. We observed that in the case of our proposed scheme it is not possible to segment the characters. So, the deep learning attacks have no use.

Scope of proposed CAPTCHA
We developed algorithms to break existing Hindi CAPTCHA designs. We also developed algorithms to generate a new Hindi CAPTCHA. So, we can divide the scope of this work into two broader applications as discussed below:

Breaking of other language-based CAPTCHAs
The algorithms developed to break Hindi CAPTCHAs can be used to test the security of CAPTCHAs based on other languages that use the same pattern. The proposed algorithms can also be used to break many other CAPTCHAs that use the same kind of patterns for backgrounds and noises. We got some samples of CAPTCHAs in approximately 46 different languages, as shown in Table 13. Table 13 shows the region in which the language is used, and names of languages in which similar CAPTCHAs are available.

Table 13 Similar CAPTCHAs for other languages
Full size table
Table 14 shows some of the other CAPTCHAs based on the same pattern of background, and noise. Table 14 represents the CAPTCHA image and the cleaned image after applying the algorithms. The results are satisfactory on these scripts as well.

Table 14 De-noising other language CAPTCHAs
Full size table
Creation of other language-based CAPTCHA
The proposed methodology can be used to generate new CAPTCHA based on other scripts. As most of the text-based CAPTCHAs are successfully broken by the researchers, this new methodology can be used to generate a CAPTCHA that is based on another script. It will make the text CAPTCHA alive once again.

Conclusion and future work
With the increase in online hacking attacks on the websites and the failure of most of the CAPTCHA schemes, we need an alternative design that can be used as a CAPTCHA. The design must provide a faster and cheaper solution for stopping a computer program from attacking websites. We know that Google reCAPTCHA has been successfully broken, and it is a big challenge for the researcher community to think about it. So, it is the most urgent need of time to develop a new CAPTCHA that is very useful. Text-based CAPTCHAs are very popular and have several advantages over other types of CAPTCHA like infinite database, user-friendliness, many varieties, etc. But most of the CAPTCHAs are available in English language or Roman script. Unfortunately, all these are broken with high success rates. With the increasing number of internet users in India, we want to design a new CAPTCHA that is not English language-based. Hindi CAPTCHA is best for this, and some of the researchers have developed the Hindi language-based CAPTCHA. The security of these Hindi CAPTCHAs is never tested. So, we took this step as our research work.

We started our work to understand the text CAPTCHAs developed in almost every corner of the world. We studied the segmentation methods as well as breaking methods of these CAPTCHAs. The usability of text-based CAPTCHA varies from 93% to 100%, and the breaking rate varies from 2%-100%. We also studied the OCR for Hindi characters to know the accuracy of OCR on clean Hindi text with a recognition rate from 76% to 98.5%.

We developed a new CAPTCHA based on the Hindi language, and tested our new design from a security and usability point of view. With the successfully breaking of all 20 schemes with high accuracy [26], we derived benchmarks [27] for design in a secure text CAPTCHA. Some of these are an appropriate use of colors, dissimilar backgrounds, more than one noisy patch, and appropriate use of distortions, appropriate use of overlapping, and positions of letters. All these benchmarks are used to design a novel Hindi CAPTCHA. The length of our new CAPTCHA varies from 5 to 8 characters; we used five types of segments to generate each character in the CAPTCHA. The first segment uses a dark background and a character image of random color, the second segment uses a light background with a character image of random color, the third segment uses a colored background with a solid color character, the fourth segment is a simple character image with white background and black color but it uses five different types of colored noisy patches, and the last segment uses handwritten characters of two types (black color and white color). The design needs to be tested for its security and usability. For testing the security of the proposed CAPTCHA, we have taken 1000 samples each from Version 1.0 and Version 2.0. We attacked these samples with all of our developed algorithms that use many tools simultaneously to break a CAPTCHA. We observed that no algorithm was successful in segmenting any single CAPTCHA. We also tested individual image processing tools to break the new design, but no tool could clean the image so that we can segment it and then recognize it. These tools include binarization, low pass filters, nonlinear filters, mathematical morphology, and edge filters, etc. This proves the security of the proposed design. For testing the usability, we generated 550 CAPTCHA samples to 55 users whose age and qualification varies from 8 years to 72 years and primary to post-graduate, respectively. We got 90% accuracy by these users the average time to solve a single image was about 10 s. It places our CAPTCHA in a true sweet spot that is the desired property of a CAPTCHA. We have planned to do the following tasks in the future.

Testing the security of remaining CAPTCHA designs
In our previous work we picked 20 CAPTCHAs for our work. We are planning to solve other remaining CAPTCHAs in the future. Figure 45 shows some remaining harder designs that we are planning to test for security. Our previous work will help us a lot in breaking these CAPTCHAs as well.

Fig. 45
figure 45
Remaining Hindi CAPTCHAs to test

Full size image
Development of toolbox
We have developed 20 different algorithms to break the 20 Hindi CAPTCHA designs. The toolbox is a method in which a single genetic algorithm is developed to solve all types of text-based CAPTCHAs. It is not developed for CAPTCHA in any language because it is very hard to develop a toolbox. We are planning to develop a toolbox that will recognize all 20 CAPTCHAs designs. Although we have to satisfy with a decreased success rate of de-noising, segmentation, and recognition, yet it will be very beneficial from space and time complexities.

Keywords
CAPTCHA
reCAPTCHA
Cyber Security
Hindi CAPTCHA
Devanagari CAPTCHA