The service usage analysis, aiming at identifying customers’ messaging behaviors based on encrypted App
traffic flows, has become a challenging and emergent task for service providers. Prior literature usually starts
from segmenting a traffic sequence into single-usage subsequences, and then classify the subsequences into
different usage types. However, they could suffer from inaccurate traffic segmentations and mixed-usage subsequences. To address this challenge, we exploit a multi-label multi-view learning strategy and develop an
enhanced framework for in-App usage analytics. Specifically, we first devise an enhanced traffic segmentation method to reduce mixed-usage subsequences. Besides, we develop a multi-label multi-view logistic
classification method, which comprises two alignments. The first alignment is to make use of the classification consistency between packet-length view and time-delay view of traffic subsequences and improve
classification accuracy. The second alignment is to combine the classification of single-usage subsequence and
the post-classification of mixed-usage subsequences into a unified multi-label logistic classification problem.
Finally, we present extensive experiments with real-world datasets to demonstrate the effectiveness of our
approach. We find that the proposed multi-label multi-view framework can help overcome the pain of mixedusage subsequences and can be generalized to latent activity analysis in sequential data, beyond in-App usage
analytics.
Categories and Subject Descriptors: H.2.8 [Database Management]: Database Applications-Spatial
Databases and GIS
General Terms: Design, Implementation Algorithms, Experimentation, Performance
Additional Key Words and Phrases: In-App analytics, service usage, Internet traffic, multi-view, multi-label
1 INTRODUCTION
Recently, mobile users have more choices beyond traditional SMS and MMS communications with
the emergence of mobile messaging Apps, e.g., WhatsApp, Facebook Messager, and WeChat, where
mobile users not only can send texts and multi-medias to each other, but also can connect with
friends in real time via stream voice or video call. They can even engage in commercial activities
such as paying bills, shopping, and sharing moments. Mobile companies highly necessitate inApp usage analytics as a powerful weapon, in order to profile end users and improve business
performances.
However, it is challenging to analyze and classify service usages in mobile messaging Apps due
to the following aspects: (i) Messaging Apps are increasingly using unpredictable port numbers and
may encrypt the content of packets. Traditional packet inspection methods that are based on TCP
or UDP port numbers or reconstruct protocol signatures are insufficient for mobile messaging Apps
(Haffner et al. 2005; Karagiannis et al. 2004; Sen et al. 2004). Also, privacy regulations are imposed
by government agencies to limit third parties from inspecting packet contents. (ii) To overcome
the privacy issue, a ubiquitous choice is data mining solutions, which first segment an Internet
traffic sequence into single-usage subsequences and then discover distinctive traffic patterns for
single-usage classification. However, in practice, many segmented subsequences are not always
single usage. Some of them are mixed-usage subsequence, and thereby significantly jeopardize the
accuracy of single-usage classification.
Figure 1 shows a motivation example: even though the shadow part of the traffic sequence is
mixed usage and includes audio note, text, location sharing, and picture, the traffic segmentation
machine misidentifies this part as a single-usage subsequence, which brings in huge interference
for usage classification. We naturally raise a question: how to make our analytics framework resistant and robust to the inference of mixed-usage subsequence. For this purpose, in this article, we classify the service usage types of traffic subsequences through a multi-label multi-view
perspective. In particular, we present a multi-label multi-view logistic classification method to
jointly capture the packet-length view and time-delay view of Internet traffic sequences and tackle
both single-usage classification and mixed-usage detection/post-classification in a single task via
a multi-label logistic strategy.
A sequence of encrypted Internet traffic flow from a mobile Messaging App is compromised of
a series of packets associated with packet length and sent time. This sequence can be represented
by a sequence of packet length marked by its sent order or by a time series marked by its sent time.
On one hand, we can describe the sequence by extracting features from its packet-length sequence,
which represents the transmission patterns of data volumes. On the other hand, we can describe
the sequence by extracting features from its time-delay sequence, which represents the time intervals of consecutive packet pairs. From the perspective of packet length, as shown in Figure 1,
different service usages vary over the mean and variance of packet lengths, as well as the forward
or backward variances at different quantiles of a packet-length sequence. For example, Figure 2(a)
shows texts are frequent in time, small in size, and usually generate a pulse in traffic, followed
by another pulse representing a text reply. In addition, Figure 2(b) demonstrates most packets of
stream video call are fully loaded. From the perspective of time delay, Figure 2(c) illustrates most
of the data in short video are transmitted in the end. And Figure 2(d) shows most of the data in
location sharing are sent in the initial phase. Be sure to notice that Figure 1 shows a longer traffic
sequence of location sharing in a shorter figure, and Figure 2 shows a shorter traffic sequence of
location sharing in a longer figure. Therefore, visually, the traffic of location sharing in Figure 1 is
more dense. We regard each perspective as a view and exploit multi-view learning to utilize the
mutual-agreement between packet-length view and time-delay view for improving classification
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
A Multi-Label Multi-View Learning Framework for In-App Service Usage Analysis 40:3
Fig. 1. Example of traffic flow of consequent in-App usages of mobile messaging App.
Fig. 2. Packet-length sequences of four example usage types with respect to observation positions (i.e., step)
and observation times (i.e., time).
accuracy. In other words, since the classification results of two views should be similar, the view
alignment is employed to penalize their disagreements.
Although existing data mining techniques can help segment a long traffic flow into a set of
single-usage traffic subsequences, the segmented subsequences are not always single-usage and
are usually mixed-usage subsequences, which bring in numerous inference for single-usage traffic
classification. As a result, the outlier detection step is introduced to detect mixed-usage subsequences and then perform post-segmentation and post-classification. To align single-usage classification and mixed-usage detection together, we generalize the two cases and assume each segmented traffic subsequence has multiple service usage types where each is represented by a binary
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
40:4 Y. Fu et al.
indicator (0 or 1). We then design a multi-label logistic classifier to simultaneously mimic both
single-usage classification and mixed-usage detection. The classifier outputs the probabilities of
all the usage types given an unknown traffic subsequence. In this way, we detect what are mixed,
quantify how they are mixed, and moreover, classify the major service usage type with the highest
probability.
Along this line, in this article, we propose a new framework to classify in-App service usages
using encrypted Internet traffic data by exploiting a multi-label multi-view strategy. Specifically,
we first develop a data collection platform to collect Internet traffic data from mobile messaging
Apps and corresponding service usage types. Also, we devise an enhanced method for traffic segmentation to reduce the ratio of mixed-usage subsequences. The segmented traffic subsequences
and the benchmark usage types are compiled together as training data. Based on the training data,
we construct two views to characterize the traffic subsequences: (1) a feature set of packet-length
view and (2) a feature set of time-delay view. Given the co-existence of single-usage and mixedusage subsequences and multi-view agreement regularity, we design a service usage classifier by
exploiting a multi-label multi-view strategy that reinforces the prediction consistency between
the packet-length view and the time-delay view and address both single-usage classification and
mixed-usage detection in a single task. Given a subsequence, the learned classifier can output the
probabilities of all usage types and classify the subsequence as the usage with max probability.
Finally, we present extensive experimental results on real-world data of WeChat and WhatsApp
to demonstrate the enhanced effectiveness of our method.
2 PRELIMINARIES
We first introduce the problem statement and then present the overview of our proposed
framework.
2.1 Problem Statement
Our task is to segment and classify an Internet traffic sequence of a mobile messaging App into
a sequence of usage activities where each is a triple consisting of a start time, an end time, and
a usage type. A traffic sequence refers to a sequence of observations, each of which contains the
information of packet length and sent time. Formally, given an Internet traffic sequence denoted by
F = ({ti,li})
I
i=1 where I is the number of observations and li represents the length of the i-th packet
at the i-th timestamp ti , our framework should return a sequence of in-App usage activities denoted
by ({bn, en,un })N
n=1, where bn, en, and un, respectively, represent the begin time, the end time, and
the single usage or the mixed usages of the n-th usage activity. Essentially, there are two major
tasks: (1) traffic segmentation: to segment a traffic sequence into multiple traffic subsequences of
single-usage, and (2) traffic classification: to classify the major usage given a traffic subsequence
that can be single-usage or mixed-usage.
We formulate this problem as a multi-label multi-view learning task. (i) “multi-label:” by applying segmentation algorithm, we segment the original traffic flow into multiple sub-sequences.
Among these sub-sequences, most of them may have only one type. But some of them might have
mixed types. We can unique both single-usage subsequences and mixed-usage subsequences as
subsequences that are associated with multiple labels (i.e., usage types), each of which is indicated by a probability. (ii) “multi-view:” Since we can extract traffic flow features from different
perspectives such as packet length against step, packet length against time, etc., we can regard
each perspective as a view, and then exploit multi-view learning to utilize the mutual-agreement
between these views to penalize the disagreements among the view predictions, and ultimately, to
improve predictive performances.
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
A Multi-Label Multi-View Learning Framework for In-App Service Usage Analysis 40:5
Fig. 3. The framework of traffic usage classification.
Fig. 4. Data collection platform of mobile messaging Apps.
2.2 Framework Overview
Figure 3 shows the proposed framework. We proceed with three phases: (1) data collection,
(2) traffic segmentation, and (3) multi-label multi-view traffic classification.
(1) Data collection: we collect the traffic sequences of messaging Apps from a group of volunteers
via a platform as shown in Figure 4. Each traffic sequence is a sequence of observations where each
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
40:6 Y. Fu et al.
Table 1. Classic Usage Types
in Messaging Apps
# Usage Type
1 text
2 picture
3 audio note
4 stream video call
5 location sharing
6 short video
7 news feed
8 outlier or unknown mixture of usages
contains the information of packet length and sent time. Also, we collect the corresponding start
times, end times, and service usage types reported by volunteers.
(2) Traffic segmentation: we devise a connectivity constrained clustering algorithm for traffic
segmentation. Our intuition is to first divide traffic sequences into small slots of an appropriately
short duration, e.g., 5 seconds. After that, we extract the features of each slot and cluster them
based on their similarities in feature space and temporal neighboring constraints.
(3) Multi-label multi-view traffic classification: we extract the feature set of the packet-length
view and the feature set of the time-delay view from the segmented traffic subsequences, where
some are single-usage while others are mixed-usage. After that, each subsequence along with its
two feature vectors and its usage types are compiled into a training dataset. The dataset is fed into
a multi-label multi-view logistic classifier that outputs a vector of probabilities for all usage types.
Finally, we identify the usage type with max probability as the major usage of a subsequence.
3 DATA COLLECTION
As mentioned in Section 1, there is more than one in-App usage type for mobile messaging Apps.
We first enumerate the usage types we are interested in (see Table 1) and then collect the Internet
traffic data of these usage types. To guarantee data quality, we design and deploy the data collection
platform as shown in Figure 4. We recruit volunteers who are required to use WeChat and/or
WhatsApp with our specially configured smartphones. Specifically, we select Samsung Galaxy S II
as our experimental handsets. Then, we remove SIM cards and install brand new Android OS. Only
system required Apps and targeted messaging Apps are installed. Besides, we set up an Android
firewall and grant Internet access permission to the targeted Apps. With the above settings, we can
monitor the Wi-Fi access point (AP), which is set up to be the only way the experimental handset
can access the Internet. Using a sniffer, one can monitor and analyze network traffic. WireShark is
such a well-known packet sniffing and analyzer tool (www.wireshark.org). We utilize it to crawl
the packet information (e.g., timestamp, packet size, etc.) of traffic flows transmitted on specific
AP. In particular, we establish the virtual access point (vAP) on a host computer, and each vAP
accept only one handset to connect. Also, we use packet filtering rules to retain the valued packets
depicting content information. Meanwhile, mobile volunteers are required to manually report their
corresponding usage types as ground-truth labels. Finally, both the Internet traffic and the reported
usage types are organized, archived, and stored in our data repository. With this setup, we assure
that only the messaging App traffic is captured. In real-world data collection, we can first filter
out other traffic flows (e.g., http, ftp, email) with traffic classification at the application/protocol
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
A Multi-Label Multi-View Learning Framework for In-App Service Usage Analysis 40:7
Fig. 5. An example of traffic flow.
level, which is a thoroughly studied problem (e.g., Crotti et al. (2007) and Zander et al. (2005)), then
adopt our data collection platform.
4 TRAFFIC FLOW SEGMENTATION
Generally, there are two kinds of dialogs within in-App usage: (i) Idling dialogs that only contain
background traffic when no usage is activated. Figure 5 shows idling dialogs compromised of small
(typical ranging from 50 to 70 bytes), low density (0.5Hz) packets. (ii) Active dialogs that contain
one or more usages. As shown in Figure 5, it is much more challenging to discover the boundary of
two adjacent usages in one active dialog due to their short switch time and sometimes their similar
traffic patterns. Therefore, traffic segmentation includes two tasks: (i) idling dialogs identification
and (ii) intra-dialog usage segmentation. The first task can be easily completed by comparing observed packet lengths with benchmark background traffic. Here, we focus on the intra-dialog usage
segmentation, which is formally defined as follows: Given an Internet traffic sequence ({ti,li})
I
i=1
from an active dialog, where I is the number of received packets and li represents the length of
the i-th packet at time ti , the traffic segmentation is designed to partition the traffic sequence into
small segments of boundary (ti,tj), within which the packets are generated from the same usage
type. Before introducing the proposed algorithm, let us first introduce some preliminaries.
Time Window. Instead of comparing the adjacent packet length, we first separate the traffic
flow into a set of windows. A time window Wn is a portion of traffic sequence starting from tn
0 to
tn
wn . The size of a time windowτ is fixed, s.t. tn
wn − tn
0 ≤ τ . There is a time gap Δ, s.t. tn+1 0 − tn
wn ≤ Δ,
between two adjacent time windows. Each time window is then represented by a feature vector
extracted from our feature extraction function Vn = F E(Wn ). The features extracted in our segmentation algorithm include overall packet-length descriptive statistics, traffic density, percentages of elements with value in K equal-sized ranges, and top-Q frequent fixed-size continuous
subsequences that will be described in detail in Section 5.2. These features are informative for
calculating the time window similarities in an efficient and effective way.
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.  
40:8 Y. Fu et al.
ALGORITHM 1: Connectivity Constrained Clustering
Input: A set of active dialog traffic sequence F = {(ti,li )}
I
i=1
Initialization: Separate traffic sequence F into a set of time windows F = W1,W2,...,WN where Wn is a
small portion of traffic sequences extracted by the time window.
Output: A set of activity-activity segment boundary time of K usages:tk , k = 1, 2,...,K − 1
While EXIST D(Vn,Vn + 1) < δ ∀n ≤ N − 1 do
(1) Find closest windows in feature space q=arдminqD(Vq,Vq+1 |q = 1,..., N − 1)
(2) Merge traffic sequences of closest windows: Wq=Wq +Wq+1
(3) Update feature vector of merged window Vq = V (Wq )
(4) Update window indexes p = p − 1 ∀p > q + 1, N = N − 1
End While
Outputtn=tn
wn +tn+1 0
2 n = 1,..., N − 1
The performance of our proposed traffic segmentation algorithm is affected by the time window
size τ and the window gap Δ. A larger window size helps extract a more stable and representative
feature vector but also makes the feature vector less sensitive to short activities. A smaller window
gap helps improve the segment accuracy but also increases the computation cost by creating more
windows. In our experiment, the window gap Δ is chosen to be 1 second to achieve a high segmentation accuracy since the user activity switch time is larger than 1 second. The window size τ
is 5 seconds such that we could capture enough traffic packets for stable traffic feature extraction.
Distance Metric. We first introduce how to calculate the distance between two time windows.
The distance for any two feature vectors (V,U ) is calculated by:
D(V,U) =

|V|
d=1
exp
(Vd −Ud )
2
σd , (1)
where σd is the standard deviation of the d-th feature Vd .
Connectivity Constrained Clustering. Based on the above distance metric, the proposed
clustering algorithm groups the time windows into different clusters. Within each cluster, the
time windows are temporally adjacent (connected) and have short distance in feature space. In
particular, after we split the traffic sequence into a set of N time windows represented by their
feature vectors, we first search the most similar time windows that are adjacent to each other.
The most similar time windows are merged into a bigger window of traffic and a new stage of
N − 1 time windows is generated. This procedure is repeated several times until any adjacent time
windows are far away from each other in feature space.
The algorithm is further described in Algorithm 1 in detail. Specifically, after we split the traffic
sequence into a set of N time windows represented by their feature vectors, Step 1 searches the
most similar time windows that are adjacent with each other. Steps 2–4 merge the time windows
found in Step 1 into a bigger window of traffic and a new stage of N − 1 time windows is generated.
This procedure is repeated several times until any adjacent time windows are far away from each
other in feature space. The threshold δ (set up as 0.8 in our experiment) is determined by the
smallest distance between the feature vectors of the two most similar distinct usages. Step 1 ensures
that the merged time windows in one cluster are timely connected. Steps 2–4 build a bottom to top
process to cluster similar time windows. Unlike the traditional connectivity constrained clustering
algorithm, it is unnecessary to specify the exact number of clusters. If an intermediate stage does
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.   
A Multi-Label Multi-View Learning Framework for In-App Service Usage Analysis 40:9
not satisfy the loop stop condition, it indicates that we separate at least one activity into two or
more time windows, which will be merged in the next loop. The number of clusters is directly
decided by the distance between any adjacent time windows.
5 MULTIPLE VIEW GENERATION
It is crucial to acquire redundant views for multi-view learning. In this section, we detail how to
obtain multiple views that sufficiently represent the traffic flow data of mobile messaging Apps.
5.1 View Construction
Given the meta traffic flow F = {t1,l1,...,tI ,lI}, we can decompose F into two sequences F P L =
{l1,...,lI } and FT D = {t1,...,tI }. The first sequence F P L is a sequence of packet lengths that can
be exploited for traffic classification in terms of data transmission patterns. The second sequence
FT D represents the timing of the packet transmission over the network. To better understand the
traffic flows from the perspective of packet transmission dynamics, we examine the first-order
difference of FT D , i.e., the sequence of time intervals between two consecutive packets, denoted as
FˆT D = {t2 − t1,...,tI − tI−1}. Indeed, the sequence of time delays (FˆT D ) characterizes the patterns
from two aspects, i.e., the implementation/design logics of in-App usages and the protocols of data
transmission, which can help discriminate usage types as well. For the simplicity of notations and
formulations, hereinafter, we use FT D instead of FˆT D to represent the sequence of time delays.
To this end, for each traffic flow F , we can obtain two sequences representing and discriminating
the usage types embedded in the traffic data from different aspects, i.e., packet-length view and
time-delay view. Since the information embedded in both packet-length view and time-delay view
is expressed in the format of time series, we can utilize a similar feature extraction strategy on
these two sequences and, finally, can construct the feature set in two different views: xP L and xT D .
Let X be the original single-view feature set. Then, with the above decomposition, we have two
exclusive sub-feature sets in different views: X = xP L ∪ xT D .
5.2 Feature Extraction
In this section, we detail our feature extraction method. Specifically, each view (xP L or xT D ) is
constructed by incorporating the global and local features of the sequential data. Global features
consist of
—Overall descriptive statistics: It is vital to exploit overall descriptive statistics, as they can
describe the basic properties of packet-length (or time delay) distribution from multiple
aspects. Given a sequence F P L/FT D , we extract the first-order and second-order descriptive statistics (i.e., standard deviation, median, minimum, skewness, kurtosis, and standard
error) as features.
—Percentages of elements with value in K equal-sized ranges: Given a sequence F P L/FT D , we
first identify the minimum and maximum values of this sequence. We then split the range
from minimum to maximum into K equal-sized subranges. For each subrange, we calculate the number and the percentage of elements in this subrange. Finally, we obtain a Ksize feature vector, each of which represents the percentage of elements with value in the
k-th subrange.
—Lengths of longest monotone subsequences: We examine the longest monotone (including
increasing and decreasing) subsequences of a sequence F P L/FT D , and use the lengths of
these two subsequences to describe the tendency and skewness of the traffic flow.
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
40:10 Y. Fu et al.
Local features consist of
—Variances in backward and forward directions: Given a sequence F P L/FT D , we first select
three representative observation positions (i.e., 1st quartile, 2nd quartile, and 3rd quartile
element numbers) from the sequence. Then, for each selected position, we split the
sequence into two subsequences with respect to backward and forward directions. Finally,
we calculate the variances of these subsequences (i.e., 3 × 2 = 6 subsequences in the
experiment) as features.
—Hopping counts: We count the number of elements whose value is greater than the next
element’s with a significant margin. We take this number as a feature to characterize the
fluctuation of the sequence.
—Top-S frequent fixed-size continuous subsequences and the corresponding frequencies: For a
sequence F P L/FT D , similarly, we first identify the range of element values, and split this
range into K equal-sized subranges. For each element in the sequence, we replace this element with k if its value is in the k-th subrange. In this way, we map this sequence into a
new string sequence. With this string sequence, we identify all the continuous subsequences
with size ranging from 3 to 20 and calculate their corresponding number of occurrences in
this string sequence. Finally, we use the top-S numbers of occurrences as features (S = 5 in
the experiment).
6 MULTI-LABEL MULTI-VIEW LOGISTIC CLASSIFICATION OF
IN-APP SERVICE USAGES
In this section, we first introduce the mathmatical notations of our proposed model. We then formulate an unique objective function for multi-label multi-view logistic classification. Also, we
develop effective methods to solve the optimization problem. Finally, we show how to use the
proposed model for in-App service usage classification.
6.1 Notations
We first define some notations. Specifically, we use bold capital letters (e.g., X) and bold lowercase letters (e.g., x) to denote matrices and vectors, respectively. We use non-bold letters (e.g.,
x) to represent scalars and Greek letters (e.g., λ) as parameters. Unless stated, all vectors are in
column form. Consider M usage types classification tasks indexed as 1,..., M, and N segmented
traffic subsequences indexed as 1,...,N. Each segmented traffic subsequence is described by its
packet-length view and time-delay view. Let the data set of the packet-length view of the task m
be (xP L
n ,ym,n ), where ym,n ∈ {1, 0}, xP L
n ∈ Rd P L and dP L is the number of packet-length features.
Let the data set of the time-delay view of the task m be (xT D
n ,ym,n ), where xT D
n ∈ RdT D and dT D
is the number of time-delay features.
6.2 Objective Function
The classification task of a service usage type consists of packet-length based classification and
time-delay based classification, i.e., f P L
m,n = xP L
n wP L
m and f T D
m,n = xT D
n wT D
m , where wP L
m and wT D
m parameterize the linear classifier for the m-th usage type with respect to the packet-length view
and the time-delay view, f P L
m,n and f T D
m,n represent the likelihoods that ym,n = 1 in terms of the
packet-length view and the time-delay view. However, the model can be easily extended to other
convex, smooth, and non-linear prediction functions. Without prior knowledge on the weights of
the packet-length view and the time-delay view, we assume that both views contribute equally.
Thus, the final classification result of both views for the m-th usage type on the subsequence n is
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
A Multi-Label Multi-View Learning Framework for In-App Service Usage Analysis 40:11
computed by the following fusion:
fm,n = 1
2
(f P L
m (xP L
n ) + f T D
m (xT D
n )) (2)
For the m-th usage type and the subsequence n, the probability of ym,n given the packet-length
view xP L
n and the time-delay view xT D
n , which we argued, is proportional to the product of the
likelihoods of point-wise consistency and pair-wise consistency. Next, we introduce the modeling
of each consistency in detail.
First, the point-wise consistency Ppt aims at minimizing the loss between ground-truth usage
types and predicted usage types given training traffic subsequences; that is, to maximize the likelihood between ym,n and fm,n modeled via logistic regression:
Ppt (ym,n |xP L
n , xT D
n ) ≈ Δ(fm,n )
ym,n [1 − Δ(fm,n )]
1−ym,n , (3)
where Δ(x) = 1
1+exp(−x ) is a sigmoid function for logistic regression. Second, the pair-wise consistency Ppr is used to minimize the loss between the packet-length based prediction and the timedelay based prediction of each training traffic subsequence, that is, to maximize the likelihood
between f P L
m (xP L
n ) and f T D
m (xT D
n ) modeled via pair-wise comparison as,
Ppr (ym,n |xP L
n , xT D
n ) ≈ N (f P L
m,n − f T D
m,n |0, σ ), (4)
where N (x |0, σ ) = 1
σ exp(− x2
2σ 2 ) is a zero-mean Gaussian distribution indicating that as both the
packet-length and time-delay views can effectively describes the characteristics of a traffic subsequence, there should be a pair-wise agreement between the packet-length view based prediction
and the time-delay view based prediction. σ impacts the shape of Gaussian distribution and is a
prior empirically given as an input.
Therefore, the probability of ym,n given the packet-length view xP L
m,n and the time-delay view
xT D
n is P (ym,n |xP L
n , xT D
n ) ≈ PptPpr . Finally, we aggregate the likelihoods of all the usage classification tasks and all the training subsequences together, in a way that we exploit the relatedness of
multiple views for enhancing the performances. Specifically, the overall likelihood is given by
L =

M
m=1

N
n=1
P (ym,n |xP L
n , xT D
n ) (5)
6.3 Solving the Optimization Problem
With the formulated overall likelihood L, the learning objective is to find the best estimation of
the parameters Φ = {wP L
m , wT D
m } that maximizes the overall likelihood. Hence, by inferring Equation (5), we can obtain the log of L for the proposed model,
L =

M
m=1

N
n=1
⎡
⎢
⎢
⎢
⎢
⎣
−1
2
ln σ2 − (f P L
m,n − f T D
m,n )
2
2σ2
⎤
⎥
⎥
⎥
⎥
⎦
+

M
m=1

N
n=1
ym,nln 1
1 + exp(−fm,n )
+

M
m=1

N
n=1
(1 − ym,n )ln exp(−fm,n )
1 + exp(−fm,n )
(6)
Since the objective function is differentiable, we apply a gradient descent method to maximize
the log of L, denoted by L, via wP L
m (#it + 1) = wP L
m (#it) + ϵ ∂(L)
∂wP L
m
and wT D
m (#it + 1) = wT D
m (#it) +
ϵ ∂(L)
∂wT D
m
where #it represent the iteration number and ϵ controls the step size.
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.        
40:12 Y. Fu et al.
Table 2. The Characteristics of the WeChat Internet Traffic Data
# Usage Type Packets Bytes Avg. Traffic /min
1 text 105K 20M 24K
2 picture 294K 215M 1,175K
3 audio note 82K 37M 29K
4 stream video call 2,222K 734M 2,850K
5 location sharing 15K 5,944K 149K
6 short video 70K 50M 823K
7 news feed 595K 381M 755K
8 outlier 1,517K 59.7M 194K
Table 3. The Characteristics of the WhatsApp Internet Traffic Data
# Usage Type Packets Bytes Avg. Traffic /min
1 text 33.724K 387.373K 1.222K
2 audio note 79.626K 3.967M 22.709K
3 picture 85.761K 6.432M 52.120K
4 stream voice call 209.229K 4.127M 33.308K
5 location sharing 11.313K 289.964K 3.274K
6 short video 385.122K 43.295M 328.179K
6.4 Classifying Service Usages
Given a segmented traffic subsequence, our method outputs the probabilities of each usage type by
Δ(fm,n ). Then, we can rank all the probabilities and classify the traffic subsequence as the major
service usage type with the highest probability.
7 EXPERIMENTAL RESULTS
In this section, we evaluate the performance of our developed system with the real-world data of
Internet traffic collected from WhatsApp and WeChat.
7.1 Data Description
We collected the network traffic data by monitoring the service usage activities of mobile volunteers in WeChat and WhatsApp. To collect the WeChat data, we hired 15 volunteers. Each mobile
volunteer was equipped with one Samsung handset (Samsung Galaxy S II) with Android operating system (version 4.0.4). The time period of data collection spanned from December 2, 2014 to
December 31, 2014. The volunteers were required to perform the seven types of service usages
in their daily life (i.e., morning, noon, afternoon, and night), and manually record the start time,
the end time, and the types of their in-App usage activities. To collect the WhatsApp data, we
additionally hired five volunteers (different from the volunteers for WeChat data collection) and
examined their WhatsApp daily usage in the time period from September 25, 2015 to October 18,
2015. Section 3 details the application deployment. Tables 2 and 3 show the basic statistics of our
collected data for different types of service usages with respect to WeChat and WhatsApp.
7.2 Study of Traffic Segmentation
Evaluation Baseline. The method proposed in our work for messaging application traffic
segmentation is denoted as Connectivity-Constrained-Clustering (Tri-C). In order to confirm the
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
A Multi-Label Multi-View Learning Framework for In-App Service Usage Analysis 40:13
Table 4. Segmentation Accuracy Comparison
Activity 1 Activity 2 Tri-C SE pt-HierClus SE KMeans SE
text picture 1.994 1.554 3.857 3.471 5.304 4.848
text audio note 1.600 0.678 5.153 2.164 5.197 1.983
text video 2.587 1.278 3.567 2.338 3.489 3.120
text location 2.120 0.579 4.491 5.973 4.457 6.304
text sight 1.430 0.411 3.653 0.582 6.799 3.585
picture audio note 2.986 1.051 3.956 0.959 5.230 2.778
picture video 4.189 2.659 4.167 3.463 3.652 3.528
audio note video 1.356 1.660 8.794 0.879 4.990 4.475
audio note location 4.673 3.885 6.785 3.469 6.020 3.059
video location 0.709 0.606 2.517 1.758 3.133 3.031
location sight 2.617 0.597 3.725 0.511 6.793 3.243
effectiveness of our model, we conduct experiments to compare our method with the following
baselines:
—pt-HierClus (Fu et al. 2016b): The pt-HierClus is a bottom-up hierarchical clustering in
terms of packet size and time delay. The basic idea is that for any two small-size adjacent
packets, if the gap between their sent times is small, they are likely to be from the same
usage; two large-size adjacent packets, if the gap between their sent times is small, are
likely to be from the same usage as well. This method is simple and empirical. There are
thresholds to define small or large packets (small or large time gaps). The thresholds make
this method very ad-hoc.
—KMeans Clustering: the KMeans Clustering partitions the time windows into K clusters in
which each observation belongs to the cluster with the nearest distance in feature space.
Motivated by the imaging segmentation (Nanetti et al. 2009), in our experiment, the time
sequence is considered as one feature to ensure the inner cluster traffic connectivity.
Evaluation Metric. There are two aspects to evaluate the accuracy of a segmentation algorithm: (1) The number of activities (or number of segments) and (2) the time difference between
the ground-truth activity switch time and the predicted switch time. Given the ground-truth activity boundary timeti and our predicted boundary time tj , these two criteria are integrated into
the evaluation metric defined below:
F =

i

j
min(|ti − tj |)
Experimental Results. Table 4 presents the experimental results of the baseline algorithm
and our proposed segmentation algorithm on 11 activity-activity boundaries. For each activityactivity pair, we collect three sets of active traffic dialogs and record the ground-truth labels. As
can be seen in Table 4, our proposed method outperforms the baselines with a significant margin.
For the activities with very similar traffic patterns (e.g., Picture-Audio Note, Location Share NoteSight and Audio Note-Location share), our proposed method can also achieve a small segmentation
error of about 3 seconds, which is small enough compared to the activity switch time uncertainties.
7.3 Study of Traffic Classification
In this section, we first briefly introduce the baseline methods for comparison and then present
the experimental results on the WhatsApp and WeChat datasets.
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.    
40:14 Y. Fu et al.
Evaluation Baselines. To illustrate the effectiveness, we use four baseline algorithms for performance comparison. First of all, we name our method as
—Multi-View Multi-Label (MVML): we exploit the mutual agreement among Multi-Views,
i.e., packet-length view and time-delay view as well as the Multi-Label logistic classification
to overcome the interference of mixed-usage subsequences. We then compare our method
MVML with the following baseline methods.
—Naive Bayesian (NB): NB is a probabilistic classifier based on applying Bayes’s theorem
with strong (naive) independence assumptions between the features. Specifically, we used
the Gaussian NB package of the Scikit-Learn library.1 It implements the Gaussian NB algorithm for classification (Chan et al. 1982). The likelihood of the features is assumed to
be Gaussian. The parameters of NB are estimated using maximum likelihood. We set the
prior probabilities of the classes, which is a hyper-parameter, according to the training
data.
—K-Nearest Neighbors classifier (KNN): a traffic subsequence is classified by a majority vote
of its neighbors, with the subsequence being assigned to the usage type most common
among its KNN. Specifically, we used the Quadratic Discriminant Analysis package of the
the Scikit-Learn library.2 It implements learning based on the KNN of each query point,
where k is an integer value specified by the user. We set the number of neighbors as five.
—Quadratic Discriminant Analysis (QDA): QDA separates the traffic subsequences of different
in-App usage types by a quadric surface. It is a more general version of the linear classifier. Specifically, we used the KNeighborsClassifier package of the Scikit-Learn library.3 It
implements a classifier with a quadratic decision boundary, generated by fitting class conditional densities to the data and using Bayes’s rule. We set the tolerance for the stopping
criteria as 1.0e-4.
—AdaBoost classifier (AB): AdaBoost is adaptive in the sense that subsequent weak learners
are tweaked in favor of those traffic subsequences misclassified by previous classifiers. AdaBoost is sensitive to mixed-usage sequences and abnormal traffic noises. Specifically, we
used the AdaBoost Classifier package of the Scikit-Learn library.4 It implements the algorithm known as AdaBoost-SAMME (Zhu et al. 2009). We used Decision Tree Classifiers as
default estimators. We set the maximum number of estimators at which boosting is terminated as 50. We set the learning rate that shrinks the contribution of each classifier as
one.
Evaluation Metrics. We measured the classification performance of different features and classifiers with the proposed system using the following evaluation metrics:
—Overall Accuracy is the ratio of the number of True Positives to the number of True Positives
and False Positives for all classes. We use this metric to measure the accuracy of a classifier
on the test data of all seven service usage types. The latter three metrics measures the
classification accuracies of each service usage type from different aspects.
—Precision is the ratio of the number of True Positives to the number of True Positives and
False Positives with respect to a specific type of service usage.
—Recall is the ratio of the number of True Positives to the number of True Positives and False
Negatives with respect to a specific type of service usage.
1http://scikit-learn.org/stable/modules/classes.html. 2http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html. 3http://scikit-learn.org/stable/modules/generated/sklearn.discriminant_analysis.QuadraticDiscriminantAnalysis.html. 4http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostClassifier.html.
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
A Multi-Label Multi-View Learning Framework for In-App Service Usage Analysis 40:15
Fig. 6. The comparison of our method with baseline methods in terms of overall accuracy on WhatsApp and
WeChat.
Table 5. Performance Comparison on WhatsApp Data
U1, U2, U3, U4, U5, U6, respectively, denote text, audio note,
picture, stream voice call, location sharing, and short video.
Method MVML NB KNN QDA AB
U1 0.84 0.744 0.577 0.965 0.610
U2 0.846 0.824 0.609 1.0 0.0
U3 0.792 0.486 0.821 0.762 0.395
Precision U4 0.957 1.0 0.783 1.0 1.0
U5 0.738 1.0 0.609 0.773 0.935
U6 0.969 0.953 0.440 0.624 0.143
U1 1.0 1.0 0.732 0.809 0.825
U2 0.647 0.418 0.629 0.5 0.0
U3 0.884 0.947 0.742 0.857 0.984
Recall U4 1.0 1.0 0.806 0.862 1.0
U5 0.861 0.695 0.219 0.983 0.983
U6 0.689 0.612 0.661 0.930 0.031
U1 0.868 0.853 0.646 0.88 0.701
U2 0.797 0.554 0.619 0.867 0.0
U3 0.809 0.643 0.780 0.807 0.563
F-measure U4 0.966 1.0 0.794 0.926 1.0
U5 0.760 0.82 0.322 0.866 0.959
U6 0.896 0.745 0.529 0.746 0.051
—F-measure considers both precision and recall in a single metric by taking their harmonic
mean: 2 × precision × recall/(precision + recall).
Overall Performances on WhatsApp. Figure 6(a) shows the overall classification accuracy
of each approach on all six usage types. Our method clearly outperforms the baselines with significant improvement. Table 5 shows the results of each approach in terms of precision, recall, and
f-measure on every service usage type. These results validate the effectiveness of our multi-view
multi-label strategy for overcoming the interference of mixed-usage subsequences. Particularly,
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
40:16 Y. Fu et al.
Table 6. Performance Comparison on WeChat Data
U1, U2, U3, U4, U5, U6, and U7, respectively, denote text, picture,
audio note, stream video call, location sharing, short video, and
news feed.
Method MVML NB KNN QDA AB
U1 0.597 0.410 0.516 0.490 0.218
U2 1.0 0.893 0.620 0.949 1.0
U3 0.846 0.813 0.762 0.0 0.611
Precision U4 0.932 0.741 0.453 0.885 0.0
U5 0.658 0.607 0.511 0.793 0.792
U6 0.765 0.767 0.6 0.593 0.357
U7 0.714 0.4 0.707 0.389 0.0
U1 0.714 0.696 0.516 0.797 0.911
U2 0.964 1.0 0.620 1.0 0.915
U3 0.733 0.867 0.762 0.0 0.759
Recall U4 0.621 0.667 0.453 0.915 0.0
U5 0.929 0.548 0.511 0.868 0.745
U6 0.754 0.657 0.6 0.810 0.076
U7 0.648 0.294 0.707 0.125 0.0
U1 0.650 0.447 0.615 0.607 0.352
U2 0.981 0.912 0.688 0.974 0.956
U3 0.786 0.823 0.627 0.0 0.677
F-measure U4 0.745 0.725 0.523 0.9 0.0
U5 0.770 0.594 0.451 0.829 0.768
U6 0.759 0.742 0.5 0.685 0.125
U7 0.680 0.373 0.532 0.190 0.0
f-measure represents the balance between precision and recall. Our methods, compared with
baselines, are more balanced between precision and recall. Even though the precision of the QDA
method is high, its recall can be refined. Also, NB outperforms KNN in terms of both precision and
recall, which indicates the latter approach is insufficient for noisy traffic classification, especially
when combining both single-usage and mixed-usage subsequences. Indeed, the nearest neighbor
method mainly relies on the features extracted from quality traffic data.
Overall Performances on WeChat. Figure 6(b) shows the overall accuracy of our method is
higher than the baselines. Table 6 shows the results of each approach with respect to precision, recall, and f-measure on every service usage type. The figures obviously demonstrate the superiority
of our method compared with the baselines. Specifically, our method consistently shows significant improvement in terms of both precision and f-measure. QDA, as a non-linear discriminate
analysis method, illustrates its robustness and holds the second place.
Based on the above observations, we can argue that our proposed method is an appropriate
approach for in-App analytics.
Mixed-Usage Detections. Although our objective is to accurately classify major usage, we also
study the mixed-usage detection using our proposed method. Specifically, for each usage type m,
we use the learned model to output the probability of each subsequence in the training data, and
compute the mean of the median probability of label-m subsequences and the median probability
of non-label-m subsequences. Then, we will use this probability as a threshold for detecting the
usage m in the test data. With the above method, for each subsequence, we can output a binary
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
A Multi-Label Multi-View Learning Framework for In-App Service Usage Analysis 40:17
Table 7. Comparison of Mixed Detection Data
Method MVML OVRNB
Hamming Distance WeChat Data 754 1,132
WhatsApp Data 622 876
Fig. 7. The overall accuracy comparison on our method and single views.
indication vector where each entry represents a usage type and its corresponding value (1 or 0)
represents true or false. To measure the effectiveness, we use the Hamming Distance between
predicted binary indication vector and benchmark binary indication vector. The smaller the Hamming distance, the higher the accuracy. We compare our method with One versus Rest multi-label
NB classifier (namely OVRNB).5 Table 7 shows our method not only can spot major usage even
with the inference of mixed-usage subsequences, but also is helpful for detecting non-major
usages.
7.4 Study of Views
To demonstrate the descriptiveness of each view, we compared our method over the following
combinations:
—pl-view: Only the packet-length view is used.
— td-view: Only the time-delay view is used
—ours: Both the packet-length view and the time-delay view are used, which is exactly our
proposed method.
The overall accuracies of view comparison on WhatsApp and WeChat data are shown in
Figure 7(a) and Figure 7(b), respectively. The accuracies of view comparison over single usage type on WhatsApp and WeChat data are shown in Table 8 and Table 9, respectively. From
both figures and tables, we observe that: (1) the combinations of packet-length and time-delay
views outperform each individual one. This observation reveals that the more views fed to our
model, the better the performance will be. (2) the pl-view outperforms td-view, which implies
that packet-length information can achieve better performance than time-delay information. In
sum, they verify that the heterogeneous information distributed across various views is usually
5http://scikit-learn.org/stable/modules/multiclass.html.
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
40:18 Y. Fu et al.
Table 8. View Comparison on WhatsApp Data
Method ours pl-view td-view
Precision
U1 0.84 0.736 0.839
U2 0.846 1.0 0.923
U3 0.792 0.695 0.625
U4 0.957 0.9 0.9
U5 0.738 0.875 0.8
U6 0.969 1.0 0.8
Recall
U1 1.0 1.0 0.904
U2 0.647 0.780 0.333
U3 0.884 0.953 0.897
U4 1.0 1.0 1.0
U5 0.861 0.757 0.737
U6 0.689 0.592 0.8
F-measure
U1 0.868 0.777 0.851
U2 0.797 0.947 0.682
U3 0.809 0.735 0.665
U4 0.966 0.918 0.918
U5 0.760 0.848 0.787
U6 0.896 0.879 0.8
complementary rather than conflicting, and appropriate aggregation of these can provide a better way to capture Internet traffic characteristics comprehensively, and consequently, boost the
performance.
7.5 A Case Study for User Behavior Profiling
Third-party service providers are usually interested in predicting which type of in-App service
usages a mobile user is going to engage next. This can be identified by examining the transition probabilities among different usage types. Specifically, given the WeChat traffic data collected from a randomly-selected user, our method can output her daily sequential usage types.
Her usage patterns can be described by a probability transition matrix of usages M(u). Here,
we present a case study. Figure 8 plots the probabilistic transition matrix of the selected user’s
usage habits in WeChat. We can observe that this user prefers to engage in text service of
WeChat after sharing pictures with friends (or receiving pictures from friends). With this transition matrix, we can derive frequent sub-sequential patterns from M(u), and obtain the preferred service usage path for the given user. Also, we can cluster sequential usage patterns of
mobile users in order to discover the latent communities of mobile users, and understand user
behaviors at group level, and efficiently recommend in-App services. Mobile business can benefit from this application. For example, mobile App designers can improve their products by optimizing resource scheduling with the awareness of customers’ usage patterns; network service
providers can adjust the quota of network bandwidth to guarantee the service quality for VIP
customers.
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
A Multi-Label Multi-View Learning Framework for In-App Service Usage Analysis 40:19
Table 9. View Comparison on WeChat Data
Method ours pl-view td-view
Precision
U1 0.597 0.636 0.565
U2 1.0 0.885 0.964
U3 0.846 0.667 0.667
U4 0.932 0.857 0.771
U5 0.658 0.690 0.688
U6 0.765 0.857 0.636
U7 0.714 0.476 0.425
Recall
U1 0.714 0.438 0.382
U2 0.964 1.0 1.0
U3 0.733 0.923 0.75
U4 0.621 0.8 0.771
U5 0.929 0.588 0.524
U6 0.754 0.75 0.618
U7 0.648 0.690 0.654
F-measure
U1 0.650 0.583 0.516
U2 0.981 0.905 0.971
U3 0.786 0.706 0.682
U4 0.745 0.845 0.771
U5 0.770 0.667 0.647
U6 0.759 0.833 0.633
U7 0.680 0.508 0.457
Fig. 8. The sample transition probability matrix of WeChat usage for a mobile user.
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
40:20 Y. Fu et al.
8 RELATED WORK
Related work can be grouped into three categories: (1) traditional Internet traffic classification,
(2) in-app usage analysis, (3) time series segmentation and classification, and (4) multi-view
learning.
Non-Encrypted and Encrypted Traffic Classification. The goal of traffic classification is to
understand the type of traffic carried on the Internet. Traditional non-encrypted traffic classification is based on direct inspection of packet content. The simplest methods are to infer the application of Internet traffic by assuming that most applications consistently use well-known TCP or
UDP port numbers. Unfortunately, port-based methods do not work when adopting unpredictable
port numbers (Karagiannis et al. 2004). More papers construct session and application information
from IP packets to classify traffic applications, namely a payload-based method (Haffner et al. 2005;
Karagiannis et al. 2004; Sen et al. 2004). Payload-based methods, however, suffer from significant
complexity and processing loads (Alshammari and Zincir-Heywood 2009). Since more and more
applications adopt encrypted data transmission for security reasons, encrypted traffic classification emerges and exploits traffic statistics or host behaviors for classifying traffic. They can be
categorized into: (1) flow feature based approaches and (2) host behavior based approaches (Kim
et al. 2008). The flow feature based approaches correlate the statistical properties (e.g., mean and
variance of packet-length distribution) of traffic flow to applications of IP traffic (Kim et al. 2008;
Paxson 1994). The host behavior based approaches exploit the host profiles and the network-wide
interaction between different hosts (e.g., constructing traffic dispersion graphs) for classifying traffic applications (Iliofotou et al. 2007; Karagiannis et al. 2005).
In-App Usage Analysis. Mobile user behavior analysis is typically based on massive user digital footprints, such as voice calls and SMSs (Ghose and Han 2011), digital media consumption (video
and audio) (Ghose and Han 2011), and Apps usage (Falaki et al. 2010; Xu et al. 2011). Our work is
closely related to in-App usage analysis. For example, Falaki et al. (2010) developed a custom logging tool to inspect App usage behavior and found that the behaviors of people using mobile Apps
are substantially diverse. Also, Xu et al. (2011) collected anonymized IP-level networking traces
in a large tier-1 cellular network and distinguished the traffic from different Apps by exploring
signatures from HTTP headers. Moreover, Qian et al. (2011) also proposed an novel approach to
expose the cross-layer interaction among various layers to diagnose usage of mobile Apps. Finally,
Tongaonkar et al. (2013) utilized the advertising traffic originating from the Apps to identify App
usage patterns. The work in Fu et al. (2016b) proposed a step-by-step analytic method including
traffic clustering, traffic classification using existing classifiers, outlier detection, outlier handling.
The work in Liu et al. (2017) proposed an online version of traffic classification method based on
the previous work in Fu et al. (2016a, 2016b). While in reality, traffic clustering can produce both
single-usage traffic segments and mixed-usage traffic segments, this method assumes each traffic
segment is single-usage after clustering and exploit post-classification outlier handling using Hidden Markov model. Our work is extended from Fu et al. (2016a) and is different from the above
work because the proposed method aligns the classification of both single-usage traffic segments
and mixed-usage traffic segments via the multi-label logistic predictive model. To increase the predictive accuracy, we further incorporate the idea of multi-view learning into multi-label logistic
predictive model to take advantage of both the packet-length view and the time-delay view, and
ultimately develop a unified learning framework.
Time Series Segmentation and Classification. Our work has a close connection with time
series classification. Bakshi and Stephanopoulos (1994) proposed a trend-based approach for
time series classification but with low interpretability. Keogh and Pazzani (1998) later proposed
a piece-wise representation, which is robust to noise and can be applied in a relevance feedback
framework. To overcome the obstacle of high dimensionality, Jeng and Huang (2007) utilized
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
A Multi-Label Multi-View Learning Framework for In-App Service Usage Analysis 40:21
singular value decomposition to select essential frequencies. Besides, the segmentation (or
summarization) aims to approximate time series by reducing its dimensionality while retaining
its essential features. A famous method is piece-wise linear approximation (PLA) (Shatkay and
Zdonik 1996), whose basic idea is to split the time series into most representative segments, and
then fit a polynomial model for each segment. To improve PLA, sliding windows (Shatkay and
Zdonik 1996), top-down approach (Li et al. 1998), and bottom-up approach (Keogh and Pazzani
1998), and fast greedy algorithms (Himberg et al. 2001) were proposed. Unlike PLA, Palpanas
et al. (2008) proposed a representation of time series that implicitly handles the segmentation of
time series by utilizing user-specified amnesic functions, while Abonyi et al. (2003) proposed to
group time points by their similarity.
Multi-view and Multi-label Learning. Multi-view learning is a machine learning paradigm
that explores diverse views of data for enhancing model learning. The basic idea of multi-view
learning is to make use of the consistency among different views to achieve better performance.
It can be categorized into: co-training, multiple kernel learning, and subspace learning (Xu et al.
2013). Co-training is most related to our work as it aims to train alternatively to maximize the mutual agreement on two distinct views of the data. Co-training was originally proposed for the problem of semi-supervised learning, in which there is access to labeled as well as unlabeled data (Blum
and Mitchell 1998). Its intuition is that classifier h1 adds examples to the labeled set that classifier
h2 will then be able to use for learning. If the conditional independence assumption is violated, the
added examples will be less informative. Instead of committing labels for the unlabeled examples,
the work in Nigam and Ghani (2000) runs EM in each view and gives unlabeled examples probabilistic labels that may change from one iteration to another. Furthermore, given two hypothesis
spaces, H1 and H2, each of which contain a predictor that well-approximates the target function,
in the case of co-training, these two are defined over different “views” of the data and trained alternatively to maximize mutual agreement on unlabeled examples. Recent studies have formulated
this intuition as joint complexity regularization (Sindhwani et al. 2005; Sindhwani and Rosenberg
2008), or co-regularization, between H1 and H2, which are taken to be Reproducing Kernel Hilbert
Spaces (RKHSs) of functions defined on the input space. Most co-training methods focus on how
to minimize the disagreement between two classifiers in order to obtain satisfactory performance
of multi-view learners. Graph-based algorithms for co-training also exist: for instance, Yu et al.
(2011) proposed a Bayesian undirected graphical model for co-training through Gaussian process
(GP). Most studies on multi-view learning focus on classification problems, and regression problems can also be solved in a similar way (Zhou and Li 2005). The work in Zhai et al. (2012) proposed
a new method called Multiview Metric Learning with Global consistency and Local smoothness
(MVML-GL) to jointly consider global consistency and local smoothness in a multi-view observation space. The work in Liu et al. (2016) strategically combined both multi-view learning and
multi-task learning for urban water quality prediction. Also, our work is related to multi-label classification, where each example is associated with multiple class labels (Wu et al. 2015; Wu et al.
2016). Wu et al. (2016) proposed the ML-FOREST algorithm to learn an ensemble of hierarchical
multi-label classifier trees to reveal the intrinsic label dependencies for multi-label classification.
The work in Wu et al. (2015) proposed a hierarchical tree model for multi-label learning, and to
develop the ML-Tree algorithm for finding the tree structure. The work in Shi et al. (2014) studied the problem of multi-objective multi-label classification and proposed the MOML algorithm to
optimize over multiple objectives simultaneously.
9 CONCLUSION
Summary. In this article, we developed an analytic framework for classifying service usages
using encrypted Internet traffic in mobile messaging Apps by exploiting a multi-label multi-view
ACM Transactions on Intelligent Systems and Technology, Vol. 9, No. 4, Article 40. Publication date: January 2018.
40:22 Y. Fu et al.
strategy. There are three modules in our system including data collection, traffic segmentation,
and multi-label multi-view logistic classification. Specifically, we first built a data collection
platform to collect the Internet traffic sequences of in-App usages and the corresponding usage
types reported by mobile users. For traffic segmentation, we introduced an enhanced time series
segmentation method for clustering traffic sequences into single-usage subsequences. For traffic
classification, we developed a multi-label multi-view learning strategy. In particular, we first
constructed the packet-length view and the time-delay view to exploit their mutual agreement.
And then, we learned a multi-label multi-view logistic classifier to overcome the interference
from mixed usage traffic. Finally, the experimental results on real-world WeChat and WhatsApp
data demonstrate the performances of the proposed method.
Implication. Sequential activity analysis has been, and will always be, a challenging problem in
various application scenarios (e.g., in-App usage analysis with in-App traffic and browsing activity
analysis with browsing traffic). The co-existence of single-usage and mixed-usage subsequences
after traffic segmentation significantly jeopardizes the accuracy of in-App usage classification. Motivated by this challenge, we propose a multi-view multi-label logistic classification strategy. The
multi-view formulation can help to exploit the consistency and mutual agreement among various
views on Internet traffic sequences, or even various sequences. The multi-label formulation can
help to reduce the step of post-classification via mixed-usage outlier detection and handling, as it
unifies both single-usage classification and mixed-usage classification. The logistic classification
formulation can help to output the probability of each service usage type and make our method
more robust under a noisy environment. The multi-view multi-label logistic strategy can be generalized to similar challenge scenarios in which sequential segmentation methods cannot clearly and
accurately split sequences into subsequences of our interests, and thereby generate subsequences
with mixed activities or statuses.