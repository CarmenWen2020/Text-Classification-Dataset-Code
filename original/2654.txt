Despite exciting progress on cryptography, secure and efficient query processing over outsourced data remains an open challenge. We develop a communication-efficient and information-theoretically secure system, entitled Obscure for aggregation queries with conjunctive or disjunctive predicates, using secret-sharing. Obscure is strongly secure (i.e., secure regardless of the computational-capabilities of an adversary) and prevents the network, as well as, the (adversarial) servers to learn the user’s queries, results, or the database. In addition, Obscure provides additional security features, such as hiding access-patterns (i.e., hiding the identity of the tuple satisfying a query) and hiding query-patterns (i.e., hiding which two queries are identical). Also, Obscure does not require any communication between any two servers that store the secret-shared data before/during/after the query execution. Moreover, our techniques deal with the secret-shared data that is outsourced by a single or multiple database owners, as well as, allows a user, which may not be the database owner, to execute the query over secret-shared data. We further develop (non-mandatory) privacy-preserving result verification algorithms that detect malicious behaviors, and experimentally validate the efficiency of Obscure on large datasets, the size of which prior approaches of secret-sharing or multi-party computation systems have not scaled to.

SECTION 1Introduction
Database-as-a-service (DaS) [36] allows authenticated users to execute their queries on an untrusted public cloud. Over the last two decades, several cryptographic techniques (e.g., [8], [33], [35], [44], [46]) have been proposed secure and privacy-preserving computations in the DaS model. These techniques can be broadly classified based on cryptographic security into two categories:

Computationally secure techniques that assume the adversary lacks adequate computational capabilities to break the underlying cryptographic mechanism in polynomial time (i.e., a practically short amount of time). Non-deterministic encryption [35], homomorphic encryption [33], order-preserving encryption (OPE) [8], and searchable-encryption [46] are examples of such techniques.

Information-theoretically secure techniques that are unconditionally secure and independent of adversary’s computational capabilities. Shamir’s secret-sharing (SSS) [44] is a well-known information-theoretically secure protocol. In SSS, multiple (secure) shares of a dataset are kept at mutually suspicious servers, such that a single server cannot learn anything about the data. Secret-sharing-based techniques are secure under the assumption that a majority of the servers (equal to the threshold of the secret-sharing mechanism) do not collude. Secret-sharing mechanisms also have applications in other areas such as Byzantine agreement, secure multiparty computations (MPC), and threshold cryptography, as discussed in [14].

The computationally or information-theoretically secure database techniques can also be broadly classified into two categories, based on the supported queries: (i) Techniques that support selection/join: Different cryptographic techniques are built for selection queries, e.g., searchable encryption, deterministic/non-deterministic encryption, and OPE; and (ii) Techniques that support aggregation: Cryptographic techniques that exploit homomorphic mechanisms such as homomorphic encryption, SSS, or MPC techniques.

While both computationally and information-theoretically secure techniques have been studied extensively in the cryptographic domain, secure data management has focused disproportionately on computationally secure techniques (e.g., OPE, homomorphic encryption, searchable-encryption, and bucketization [36]) resulting in systems such as CryptDB [42], Monomi [48], MariaDB [1], CorrectDB [10]). Some exceptions to the above include [28], [29], [30], [50] that have focused on secret-sharing.

Recently, both academia [23], [28], [30], [50] and industries [2], [9], [16] have begun to explore information-theoretically secure techniques using MPC that efficiently supports OLAP tasks involving aggregation queries, while achieving higher security than computationally secure techniques.1 For instance, commercial systems, such as Jana [9] by Galois, Pulsar [2] by Stealth Software, Sharemind [16] by Cybernetica, and products by companies such as Unbound Tech., Partisia, Secret Double Octopus, and SecretSkyDB Ltd. have explored MPC-based databases systems that offer strong security guarantees. Benefits of MPC-based methods in terms of both higher-level security and relatively efficient support for aggregation queries have been extensively discussed in both scientific articles [24], [31], [41], [43] and popular media [4], [5], [6], [7].

Much of the above work on MPC-based secure data management requires several servers to collaborate to answer queries. These collaborations require several rounds of communication among non-colluding servers. Instead, we explore secure data management based on SSS that does not require servers to collaborate to generate answers and can, hence, be implemented more efficiently. There is prior work on exploring secret-sharing for SQL processing [28], [29], [30], [50], but the developed techniques suffer from several drawbacks, e.g., weak security guarantees such as leakage of access patterns, significant overhead of maintaining polynomials for generating shares at the database (DB) owner, no support for third-party query execution on the secret-shared outsourced database, etc. We discuss the limitations of existing secret-sharing-based data management techniques in details in Section 2.2.

Contribution. Our contributions in this paper are threefold:

SSS-based algorithms (entitled Obscure) that support a large class of access-pattern-hiding aggregation queries with selection. Obscure supports count, sum, average, maximum, minimum, top-k, and reverse top-k, queries, without revealing anything about data/query/results to an adversary.

An oblivious result verification algorithm for aggregation queries such that an adversary does not learn anything from the verification. Obscure’s verification step is not mandatory. A querier may run verification occasionally to confirm the correctness of results.

A comprehensive experimental evaluation of Obscure on a variety of queries that clearly highlight its scalability to moderate-size datasets and its efficiency compared to both state-of-the-art MPC-based solutions, as well as, to the simple strategy of downloading encrypted data at the client, decrypting it, and running queries at the (trusted) client.

Applications. Our proposed algorithms can deal with datasets outsourced by a single or multiple DB owners. Here, we provide examples of each scenario.
DB Outsourcing by a Single DB Owner: Hospital Database. A hospital may outsource its patient database to an (untrusted cloud) server. Given the sensitivity of the patient records, such data needs to be secured cryptographically. The hospital may still wish to execute analytical queries on the sever over such data (e.g., number of influenza patients seen in the last month) for its own internal logistical planning.

DB Outsourcing by Multiple DB Owners: Smart Metering (or IoT Sensors). Smart meters’ data outsourcing is an example of multiple DB owners and a single querier. In smart meter settings, smart meter devices keep the energy consumptions of a home at given time intervals and send the data to the servers [45]. This data contains behavioral information of the user; hence, a cryptographic technique should be used to make it secure before outsourcing. Users may execute queries on this secure database for monitoring and comparing their usage to that of others in the neighborhood. Executing such aggregate queries involve count, sum, and maximum operations in an oblivious manner at the server for preventing access to users’ behavioral information. Our proposed algorithms prevent an adversarial server to learn the user’s behaviors, when storing the database or executing a query. Privacy-preserving data integration [11], [12], [13], [15], [39], where different datasets–owned by different DB owners–are intergraded into a single dataset, is also an example DB outsourcing by multiple owners. However, [11], [12], [13], [15], [39] deal with only encrypted data integration; thus, we do not discuss such techniques in detail.

Outline of the Paper. Section 2 provides an overview of secret-sharing techniques and related work. Sections 3 and 4 provide the model, an adversary model, security properties, and data outsourcing model. Section 5 provides conjunctive/disjunctive count queries and their verification algorithm. Section 6 provides conjunctive/disjunctive sum queries and their verification algorithm. Section 7 provides an algorithm for fetching tuples having maximum values in some attributes with their verification. Section 9 provides an experimental evaluation.

Appendix. In appendix, which can be found on the Computer Society Digital Library at http://doi.ieeecomputersociety.org.ezproxy.auckland.ac.nz/10.1109/TKDE.2020.2983932, we provide the following: an example of count query verification using secret-shared data, an approach for finding maximum over SSS databases outsourced by multiple DB owners, approaches for the minimum and top-k, an outline for security proofs, and a communication-efficient strategy for knowing tuples that satisfied a query predicate.

SECTION 2Background
Here, we provide an overview of secret-sharing with an example and compare our proposed approach with existing works.

2.1 Building Blocks
Obscure is based on SSS, string-matching operations over SSS, and order-preserving secret-sharing (OP-SS). This section provides an overview of these existing techniques.

Shamir’s Secret-Sharing. In SSS [44], the DB owner divides a secret value, say S, into c different fragments, called shares, and sends each share to a set of c non-communicating participants/servers. These servers cannot know the secret S until they collect c′<c shares. In particular, the DB owner randomly selects a polynomial of degree c′ with c′ random coefficients, i.e., f(x)=a0+a1x+a2x2+⋯+ac′xc′, where f(x)∈Fp[x], p is a prime number, Fp is a finite field of order p, a0=S, and ai∈N(1≤i≤c′). The DB owner distributes the secret S into c shares by placing x=1,2,…,c into f(x). The secret can be reconstructed based on any c′+1 shares using Lagrange interpolation [22]. Note that c′≤c, where c is often taken to be larger than c′ to tolerate malicious adversaries that may modify the value of their shares. For this paper, however, since we are not addressing the availability of data, we will consider c and c′ to be identical.

SSS allows an addition of shares, i.e., if s(a)i and s(b)i are shares of two values a and b, respectively, at the server i, then the server i can compute an addition of a and b itself, i.e., a+b=s(a)+s(b), without knowing real values of a and b.

String-Matching Operation on Secret-Shares. Accumulating-Automata (AA) [27] is a new string-matching technique on secret-shares that do not require servers to collaborate to do the operation, unlike MPC-techniques [9], [16], [17], [18], [25], [38]. Here, we explain AA to show how string-matching can be performed on secret-shares.

Let D be the cleartext data. Let S(D)i (1≤i≤c) be the ith secret-share of D stored at the ith server, and c be the number of non-communicating servers. AA allows a user to search a pattern, pt, by creating c secret-shares of pt (denoted by S(pt)i, 1≤i≤c), so that the ith server can search the secret-shared pattern S(pt)i over S(D)i. The result of the string-matching operation is either 1 of secret-share form, if S(pt)i matches with a secret-shared string in S(D)i or 0 of secret-share form; otherwise. Note that when searching a pattern on the servers, AA uses multiplication of shares, as well as, the additive property of SSS, which will be clear by the following example. Thus, if the user wants to search a pattern of length l in only one communication round, while the DB owner and the user are using a polynomial of degree one, then due to multiplication of shares, the final degree of the polynomial will be 2l, and solving such a polynomial will require at least 2l+1 shares.

Example. Assume that the domain of symbols has only three symbols, namely A, B, and C. Thus, A can be represented as ⟨1,0,0⟩. Similarly, B and C can be represented as ⟨0,1,0⟩ and ⟨0,0,1⟩, respectively.

DB owner side. Suppose that the DB owner wants to outsource B to the (cloud) servers. Hence, the DB owner may represent B as its unary representation: ⟨0,1,0⟩. If the DB owner outsources the vector ⟨0,1,0⟩ to the servers, it will reveal the symbol. Thus, the DB owner uses any three polynomials of an identical degree, as shown in Table 1, to create three shares.

TABLE 1 Secret-Shares of a Vector ⟨0,1,0⟩〈0,1,0〉, Created by the DB Owner
Table 1- 
Secret-Shares of a Vector $\langle 0,1,0\rangle$〈0,1,0〉, Created by the DB Owner
User-side. Suppose that the user wants to search for a symbol B. The user will first represent B as a unary vector, ⟨0,1,0⟩, and then, create secret-shares of B, as shown in Table 2. Note that there is no need to ask the DB owner to send any polynomials to create shares or ask the DB owner to execute the search query.

TABLE 2 Secret-Shares of a Vector ⟨0,1,0⟩〈0,1,0〉, Created by the User/Querier
Table 2- 
Secret-Shares of a Vector $\langle 0,1,0\rangle$〈0,1,0〉, Created by the User/Querier
Server-Side. Each server performs position-wise multiplication of the vectors that they have, adds all the multiplication resultants, and sends them to the user, as shown in Table 3. An important point to note here is that the server cannot deduce the keyword, as well as, the data by observing data/query/results.

TABLE 3 Multiplication of Shares and Addition of Final Shares by the Servers

User-Side. After receiving the outputs (⟨y1=43,y2=147,y3=313⟩) from the three servers, the user executes Lagrange interpolation [22] to construct the secret answer, as follows:
(x−x2)(x−x3)(x1−x2)(x1−x3)×y1+(x−x1)(x−x3)(x2−x1)(x2−x3)×y2+(x−x1)(x−x2)(x3−x1)(x3−x2)×y3
View Source
=(x−2)(x−3)(1−2)(1−3)×43+(x−1)(x−3)(2−1)(2−3)×147+(x−1)(x−2)(3−1)(3−2)×313=1
View Source

The final answer is 1 that confirms that the secret-shares at the servers have B.

Note. In this paper, we use AA that utilizes unary representation as a building block. A recent paper Prio [23] also uses a unary representation; however, we use significantly fewer number of bits compared to Prio’s unary representation. One can use Prio’s unary representation too or use a different private string-matching technique over secret-shares that supports string-matching over the shares.

Order-Preserving Secret-Sharing. The concept of OP-SS was introduced in [29]. OP-SS maintains the order of the values in secret-shares too, e.g., if v1 and v2 are two values in cleartext such that v1<v2, then S(v1)<S(v2) at any server. It is clear that finding records with maximum or minimum values using OP-SS are trivial. However, ordering revealed by OP-SS can leak more information about records. Consider, for instance, an employee relation, given in Table 5. For explanation purpose, we represent Table 5 in cleartext. In Table 5, the salary field can be stored using OP-SS. If we know (background knowledge) that employees in the security department earn more money than others, we can infer from the representation that the second tuple corresponds to someone from the security department. Thus, OP-SS, by itself, offers little security. However, as we will see later in Section 7, by splitting the fields such as salary that can be stored using OP-SS, while storing other fields using SSS, we, thus, can benefit from the ordering supported by OP-SS without compromising on security.

TABLE 4 Query Types Supported by Obscure
Table 4- 
Query Types Supported by Obscure
TABLE 7 A Relation: Employee
Table 7- 
A Relation: Employee
2’s Complement-Based Sigbit Computation. [26] provided 2’s complement-based sigbit computation. We will use signbit to find if two numbers are equal or not, as follows: A≥B if signbit(A−B)=0, and A<B if signbit(A−B)=1. Let A=[an,an−1,…,a1] be a n bit number and B=[bn,bn−1,…,b1] be a n bit number. 2’s complement subtraction converts B−A into B+A¯+1, where A¯+1 is 2’s complement representation of −A. We start from the least significant bit (LSB) and go through the rest of the bits. The method inverts ai (by doing 1−ai, where 1≤i≤n), calculates a¯0+b0+1 and its carry bit. After finishing this on all the n bits, the most significant bit (MSB) keeps the signbit.

2.2 Comparison With Existing Work
Comparison With SSS Databases. In 2006, Emekçi et al. [29] introduced the first work on SSS data for executing sum, maximum, and minimum queries. However, [29] uses a trusted-third-party to perform queries and is not secure, since it uses OP-SS to answer maximum/minimum queries. Another paper by Emekçi et al. [30] on OP-SS based aggregation queries requires the database owner to retain each polynomial, which was used to create database shares, resulting in the DB owner to store n×m polynomials, where n and m are the numbers of tuples and attributes in a relation. [30] is also not secure, since it reveals access-patterns (i.e., the identity of tuples that satisfy a query) and using OP-SS.2 Like [30], [50] proposed a similar approach and also suffers from similar disadvantages. [47] proposed SSS-based sum and average queries; however, they also require the DB owner to retain tuple-ids of qualifying tuples. [28] used a novel string-matching operation over the shares at the server, but it cannot perform general aggregations with selection over complex predicates. In short, all the SSS-based solutions for aggregation queries either overburden the DB owner (by storing enough data related to polynomials and fully participating in a query execution), are insecure due to OP-SS, reveal access-patterns, or support a very limited form of aggregation queries without any selection criteria.

In contrast, Obscure eliminates all such limitations. It provides a fully secure and efficient solution for implementing aggregation queries with selections. Our experimental results will show that Obscure scales to datasets with 6M tuples on TPC-H queries, the size of which prior secret-sharing and/or MPC-based techniques have never scaled to. The key to the efficient performance of Obscure still is exploiting OP-SS – while OP-SS, in itself, is not secure (it is prone to background knowledge attacks, for instance). The way Obscure uses OP-SS, as will be clear in Section 4, it prevents such attacks by appropriately partitioning data, while still being able to exploit OP-SS for efficiency. In addition, to support aggregation with selections, Obscure exploits the string-matching techniques over shares developed in [27].

Furthermore, as we will see in experimental section (Section 9), Obscure scales to datasets with 6M tuples on TPC-H queries.

Comparison With MPC-Techniques. Obscure also overcomes several limitations of existing MPC-based solutions. Recent work, Prio [23] supports a mechanism for confirming the maximum number, if the maximum number is known; however, Prio [23] does not provide any mechanism to compute the maximum/minimum. Also, Prio does not provide methods to execute conjunctive and disjunctive count/sum queries. Another recent work [17] deals with adding shares in an array under malicious servers and malicious users, using the properties of SSS and public-key settings. However, [17] is unable to execute a single-dimensional, conjunctive, or disjunctive sum query. Note that (as per our assumption) though, [17] can tolerate malicious users, while Obscure is designed to only handle malicious servers, and it assumes users to be trustworthy.

Other works, e.g., Sepia [18] and [25], perform addition and less than operations, and use many communication rounds. In contrast, Obscure uses minimal communication rounds between the user and each server, (when having enough shares). Specifically, count, sum, average, and their verification algorithms require at most two rounds between each server and the user. However, maximum/minimum finding algorithms require at most four communication rounds. In addition, our scheme achieves the minimum communication cost for aggregate queries, especially for count, sum, and average queries, by aggregating data locally at each server.

Comparison With MPC/SSS-Based Verification Approaches. [38] and [47] developed verification approaches for secret-shared data. [38] considered verification process for MPC using a trusted-third-party verifier. While overburdening the DB owner by keeping metadata for each tuple, [47] provided metadata-based operation verification (i.e., whether all the desired tuples are scanned or not) for only sum queries, unlike Obscure’s result verification for all queries. Obscure verification methods neither involve the DB owner to verify the results nor require a trusted-third-party verifier.

SECTION 3Preliminary
This section provides a description of entities, an adversarial model, and security properties for obliviously executing queries.

3.1 The Model
We assume the following three entities in our model.

A set of c>2 non-communicating servers. The servers do not exchange data with each other to compute any answer. The only possible data exchange of a server is with the user/querier or the database owner.

The trusted database owner, that creates c secret-shares of the data and transfers the ith share to the ith server. The secret-shares are created by an algorithm that supports non-interactive addition and multiplication of two shares, which is required to execute the private string-matching operation, at the server, as explained in Section 2.3

An (authenticated, authorized, and trusted) user/querier, who executes queries on the secret-shared data at the servers. The query is sent to servers. The user fetches the partial outputs from the servers and performs a simple operation (polynomial interpolation using Lagrange polynomials [22]) to obtain the secret-value.

3.2 Adversarial Model
We consider two adversarial models, in both of which the cloud servers (storing secret-shares) are not trustworthy. In the honest but curious model, the server correctly computes the assigned task without tampering with data or hiding answers. However, the server may exploit side information (e.g., query execution, background knowledge, and output size) to gain as much information as possible about the stored data. Such a model is considered widely in many cryptographic algorithms and in widely used in DaS [20], [36], [49], [51]. We also consider a malicious adversary that could deviate from the algorithm and delete tuples from the relation. Users and database owners, in contrast, are assumed to be not malicious.

Only authenticated users can request query on servers. Further, we follow the restriction of the standard SSS that the adversary cannot collude with all (or possibly the majority of) the servers. Thus, the adversary cannot generate/insert/update shares at the majority of the servers. Also, the adversary cannot eavesdrop on a majority of communication channels between the user and the servers. This can be achieved by either encrypting the traffic between user and servers, or by using anonymous routing [34], in which case the adversary cannot gain knowledge of servers that store the secret-shares. Note that if the adversary could either collude with or successfully eavesdrop on the communication channels between the majority of servers and user, the secret-sharing technique will not apply.4 The validity of the assumptions behind secret-sharing has been extensively discussed in prior work [24], [31], [41], [43]. The adversary can be aware of the public information, such as the actual number of tuples and number of attributes in a relation, which will not affect the security of the proposed scheme, though such leakage can be prevented by adding fake tuples and attributes.5

3.3 Security Properties
In the above-mentioned adversarial model, an adversary wishes to learn the (entire/partial) data and query predicates. Hence, a secure algorithm must prevent an adversary to learn the data (i) by just looking the cryptographically-secure data and deduce the frequency of each value (i.e., frequency-count attacks), and (ii) when executing a query and deduce which tuples satisfy a query predicate (i.e., access-pattern attacks) and how many tuples satisfy a query predicate (i.e., output-size attacks). Thus, in order to prevent these attacks, our security definitions are identical to the standard security definition as in [19], [21], [32]. An algorithm is privacy-preserving if it maintains the privacy of the querier (i.e., query privacy), the privacy of data from the servers, and performs identical operations, regardless of the user query.

Query/Querier’s privacy requires that the user’s query must be hidden from the server, the DB owner, and the communication channel. In addition, the server cannot distinguish between two or more queries of the same type based on the output. Queries are of the same type based on their output size. For instance, all count queries are of the same type since they return almost an identical number of bits.

Definition. Users Privacy. For any probabilistic polynomial time adversarial server having a secret-shared relation S(R) and any two input query predicates, say p1 and p2, the server cannot distinguish p1 or p2 based on the executed computations for either p1 and p2.

Privacy from the server requires that the stored input data, intermediate data during a computation, and output data are not revealed to the server, and the secret value can only be reconstructed by the DB owner or an authorized user. In addition, two or more occurrences of a value in the relation must be different at the server to prevent frequency analysis while data at rest. Recall that due to secret-shared relations (by following the approach given in Section 2.1), the server cannot learn the relations and frequency-analysis, and in addition, due to maintaining the query privacy, the server cannot learn the query and the output.

Here, we, also, must ensure that the server’s behavior must be identical for a given query, and the servers provide an identical answer to the same query, regardless of the users (recall that user might be different compared to the data owner in our model). To show that we need to compare the real execution of the algorithm at the servers against the ideal execution of the algorithm at a trusted party having the same data and the same query predicate. An algorithm maintains the data privacy from the server if the real and ideal executions of the algorithm return an identical answer to the user.

Definition. Privacy From the Server. For any given secret-shared relation S(R) at a server, any query predicate qp, and any real user, say U, there exists a probabilistic polynomial time (PPT) user U′ in the ideal execution, such that the outputs to U and U′ for the query predicate qp on the relation S(R) are identical.

Properties of Verification. We provide verification properties against malicious behaviors. A verification method must be oblivious and find any misbehavior of the servers when computing a query. We follow the verification properties from [38], as follows: (i) the verification method cannot be refuted by the majority of the malicious servers, and (ii) the verification method should not leak any additional information.

Algorithms’ Performance. We analyze our oblivious aggregation algorithms on the following parameters, which are stated in Table 7: (i) Communication rounds. The number of rounds that is required between the user and each server to obtain an answer to the query. (ii) Scan cost at the server. We measure scan cost at the server in terms of the number of the rounds that the server performs to read the entire dataset. (iii) Computational cost at the user. The number of values/tuples that the user interpolates to know the final output.

TABLE 6 Two Relations Obtained From Employee Relation
Table 6- 
Two Relations Obtained From Employee Relation
TABLE 5 Complexities of the Algorithms
Table 5- 
Complexities of the Algorithms
3.4 Obscure Overview
Let us introduce Obscure at a high-level. Obscure allows single-dimensional and multi-dimensional conjunctive/disjunctive equality queries. Note that the method of Obscure for handling these types of queries is different from SQL, since Obscure does not support query optimization and indexing6 due to secret-shared data. Further, Obscure handles range-based queries by converting the range into equality queries. Executing a query on Obscure requires four phases, as follows:

Phase 1: Data upload by DB owner(s). The DB owner uploads data to non-communicating servers using a secret-sharing mechanism that allows addition and multiplication (e.g., [27]) at the servers.

Phase 2: Query generation by the user. The user generates a query, creates secret-shares of the query predicate, and sends them to the servers. For generating secret-shares of the query predicate, the user follows the strategies given in Section 5 (count query), Section 6 (sum queries), Section 7 (maximum/minimum), and Sections 5.1,6.1 (verification).

Phase 3: Query processing by the servers. The servers process an input query in an oblivious manner such that neither the query nor the results satisfying the query are revealed to the adversary. Finally, the servers transfer their outputs to the user.

Phase 4: Result construction by the user. The user performs Lagrange interpolation on the received results, which provide an answer to the query. The user can also verify these results by following the methods given in Sections 5.1, 6.1, 7.3.

Table 4 shows queries supported by Obscure, where α and γ are aggregation operators, such as count, sum, average, maximum, and minimum. In order to execute these operators, we provide algorithms in the following sections. As will become clear soon, the proposed algorithms may take at most three communication rounds between the servers and the user. Further, note that in Obscure, a group-by query requires us to know the name of groups, prior to query execution. For example, if the group-by operation is executed on Department attribute, then we need to know all unique department names.

SECTION 4Data Outsourcing
This section provides details on creating and outsourcing a database of secret-shared form. The DB owner wishes to outsource a relation R having attributes A1,A2,…,Am and n tuples, and creates the following two relations R1 and R2:

Relation R1 that consists of all the attributes A1,A2,…,Am along with two additional attributes, namely TID (tuple-id) and Index. As will become clear in Section 7, the TID attribute will help in finding tuples having the maximum/minimum/top-k values, and the Index attribute will be used to know the tuples satisfying the query predicate. The ith values of the TID and Index attributes have the same and unique random number between 1 to n.

Relation R2 that consists of three attributes CTID (cleartext tuple-id), SSTID (secret-shared tuple-id), and an attribute, say Ac, on which a comparison operator (minimum, maximum, and top-k) needs to be supported.7

The ith values of the attributes CTID and SSTID of the relation R2 keep the ith value of the TID attribute of the relation R1. The ith value of the attributes Ac of the relation R2 keeps the ith value of an attribute of the relation R1 on which the user wants to execute a comparison operator. Further, the tuples of the relations R2 are randomly permuted. The reason for doing permutation is that the adversary cannot relate any tuple of both the secret-shared relations, which will be clear soon by the example below.

Note. The relation S(R1) will be used to answer count and sum queries, while it will be clear in Section 7 how the user can use the two relations S(R1) and S(R2) together to fetch a tuple having maximum/minimum/top-k/reverse-top-k value in an attribute.

Example. Consider the Employee relation (see Table 5). The DB owner creates R1= Employee1 relation8 (see Table 6 a) with TID and Index attributes. Further, the DB owner creates R2= Employee2 relation (see Table 6 b) having three attributes CTID, SSTID, and Salary.

Creating Secret-Shares. Let Ai[aj] (1≤i≤m+1 and 1≤j≤n) be the jth value of the attribute Ai. The DB owner creates c secret-shares of each attribute value Ai[aj] of the relation R1 using a secret-sharing mechanism that allows string-matching operations at the server (as specified in Section 2). However, c shares of the jth value of the attribute Am+2 (i.e., Index) are obtained using SSS. This will result in c relations: S(R1)1, S(R1)2, …, S(R1)c, each having m+2 attributes. The notation S(R1)k denotes the kth secret-shared relation of R1 at the server k. We use the notation Ai[S(aj)]k to indicate the jth secret-shared value of the ith attribute of a secret-shared relation at the server k.

Further, on the relation R2, the DB owner creates c secret-shares of each value of SSTID using a secret-sharing mechanism that allows string-matching operations on the servers and each value of Ac using order-preserving secret-sharing [29], [30], [37]. The secret-shares of the relation R2 are denoted by S(R2)i (1≤i≤c). The attribute CTID is outsourced in cleartext with the shared relation S(R2)i. It is important to mention that CTID attribute allows fast search due to cleartext representation than SSTID attribute, which allows search over shares.

Note that the DB owner’s objective is to hide any relationship between the two relations when creating shares of the relations S(R1) and S(R2), i.e., the adversary cannot know by just observing any two tuples of the two relations that whether these tuples share a common value in the attribute TID/SSTID and Ac or not. Thus, shares of an ith (1≤i≤n) value of the attribute TID in the relation S(R1)j and in the attribute SSTID of the relation S(R2)j must be different at the jth server. Also, by default, the attribute Ac have different shares in both the relations, due to using different secret-sharing mechanisms for different attributes. The DB owner outsources the relations S(R1)i and S(R2)i to the ith server.

Note. Naveed et al. [40] showed that a cryptographically secured database that is also an using order-preserving cryptographic technique (e.g., order-preserving encryption or OP-SS) may reveal the entire data when mixed with publicly known databases. Hence, in order to overcome such a vulnerability of order-preserving cryptographic techniques, we created two relations, and importantly, the above-mentioned representation, even though it uses OP-SS does not suffer from attacks based on background knowledge, as mentioned in Section 2. Of course, instead of using the two relations, the DB owner can outsource only a single relation without using OP-SS. In the case of a single relation, while we reduce the size of the outsourced dataset, we need to compare each pair of two shares, and it will result in increased communication cost, as well as, communication rounds, as shown in previous works [18], [25], which were developed to compare two shares.

SECTION 5Count Query and Verification
In this section, we develop techniques to support count queries over secret-shared dataset outsourced by a single or multiple DB owners. The query execution does not involve the DB owner or the querier to answer the query. Further, we develop a method to verify the count query results.

Conjunctive Count Query. Our conjunctive equality-based count query scans the entire relation only once for checking single/multiple conditions of the query predicate. For example, consider the following conjunctive count query: select count(*) from R where A1=v1 ∧ A2=v2 ∧ … ∧ Am=vm.

The user transforms the query predicates to c secret-shares that result in the following query at the jth server: select count(*) from S(R1)j where A1=S(v1)j ∧ A2=S(v2)j ∧ … ∧ Am=S(vm)j. Note that the single-dimensional query will have only one condition. Each server j performs the following operations:
Output=∑k=1k=n∏i=1i=m(Ai[S(ak)]j⊗S(vi)j),
View Source⊗ shows a string-matching operation that depends on the underlying text representation. For example, if the text is represented as a unary vector, as explained in Section 2, ⊗ is a bit-wise multiplication and addition over a vector’s elements, whose results will be 0 or 1 of secret-share form. Each server j compares the query predicate value S(vi) against kth value (1≤k≤n) of the attribute Ai, multiplies all the resulting comparison for each of the attributes for the kth tuple. This will result in a single value for the kth tuple, and finally, the server adds all those values. Since secret-sharing allows the addition of two shares, the sum of all n resultant shares provides the occurrences of tuples that satisfy the query predicate of secret-share form in the relation S(R1) at the jth server. On receiving the values from the servers, the user performs Lagrange interpolation [22] to get the final answer in cleartext.

Correctness. The occurrence of kth tuple will only be included when the multiplication of m comparisons results in 1 of secret-share form. Having only a single 0 as a comparison resultant over an attribute of kth tuple produce 0 of secret-share form; thus, the kth tuple will not be included. Thus, the correct occurrences over all tuples are included that satisfy the query’s where clause.

Example. We explain the above conjunctive count query method using the following query on the Employee relation (refer to Table 5): select count(*) from Employee where Name = ‘John’ and Salary = ‘1000’. Table 8 shows the result of the private string-matching on the attribute Name, denoted by o1, and on the attribute Salary, denoted by o2. Finally, the last column shows the result of the query for each row and the final count answer for all the tuples. Note that for the purpose of explanation, we use cleartext values; however, the server will perform all operations over secret-shares. For the first tuple, when the servers check the first value of Name attribute against the query predicate John and the first value of Salary attribute against the query predicate 1000, the multiplication of both the results of string-matching becomes 1. For the second tuple, when the server checks the second value of Name and Salary attributes against the query predicate John and 1000, respectively, the multiplication of both the results become 0. All the other tuples are processed in the same way.

TABLE 8 An Execution of the Conjunctive Count Query

Disjunctive Count Query. Our disjunctive count query also scans the entire relation only once for checking multiple conditions of the query predicate, like the conjunctive count query. Consider, for example, the following disjunctive count query: select count(*) from R where A1=v1 ∨ A2=v2 ∨ … ∨ Am=vm

The user transforms the query predicates to c secret-shares that results in the following query at the jth server: select count(*) from S(R1)j where A1=S(v1)j ∨ … ∨ Am=S(vm)j The server j performs the following operation:
Resultki=Ai[S(ak)]j⊗S(vi)j,1≤i≤m
View SourceRight-click on figure for MathML and additional features.
Output=∑k=1k=n(((Resultk1 OR Resultk2) OR Resultk3)…
View Source
 OR Resultkm).
View SourceTo capture the OR operation for each tuple k, the server generates m different results either 0 or 1 of secret-share form, denoted by Resulti (1≤i≤m), each of which corresponds to the comparison for one attribute. To compute the final result of the OR operation for each tuple k, one can perform binary-tree style computation. However, for simplicity, we used an iterative OR operation, as follows:
tempk1tempk2Outputk=Resultk1+Resultk2−Resultk1×Resultk2=tempk1+Resultk3−tempk1×Resultk3⋮=tempkm−1+Resultkm−tempkm−1×Resultkm.
View SourceAfter performing the same operation on each tuple, finally, the server adds all the resultant of the OR operation (∑k=nk=1Outputk) and sends to the user. The user performs an interpolation on the received values that is the answer to the disjunctive count query.

Correctness. The disjunctive counting operation counts only those tuples that satisfy one of the query predicates. Thus, by performing OR operation over string-matching resultants for an ith tuple results in 1 of secret-share form, if the tuple satisfied one of the query predicates. Thus, the sum of the OR operation resultant surely provides an answer to the query.

Information Leakage Discussion. The user sends query predicates of secret-share form, and the string-matching operation is executed on all the values of the desired attribute. Hence, access-patterns are hidden from the adversary, so that the server cannot distinguish any query predicate in the count queries. The output of any count query is of secret-share form and contains an identical number of bits. Thus, based on the output size, the adversary cannot know the exact count, as well as, differentiate two count queries. However, the adversary can know whether the count query is single-dimensional, conjunctive or disjunctive count query.

5.1 Verifying Count Query Results
In this section, we describe how results of count query can be verified. Note that we explain the algorithms only for a single-dimensional query predicate. Conjunctive and disjunctive predicates can be handled in the same way.

Here, our objective is to verify that (i) all tuples of the databases are checked against the count query predicates, and (ii) all answers to the query predicate (0 or 1 of secret-share form) are included in the answer. In order to verify both the conditions, the server performs two functions, f1 and f2, as follows:
op1=f1(x)=∑i=1i=n(S(xi)⊗oi)
View Source
op2=op1+f2(y)=op1+∑i=1i=nf2(S(yi)⊗(1−oi)),
View SourceRight-click on figure for MathML and additional features.i.e., the server executes the functions f1 and f2 on n secret-shared values each (of two newly added attributes Ax and Ay, outsourced by the DB owner, described below). In the above equations oi is the output of the string-matching operation carried on the ith value of an attribute, say Aj, on which the user wants to execute the count query. The server sends the outputs of the function f1, denoted by op1, and the sum of the outputs of f1 and f2, denoted by op2, to the user. The outputs op1 and op2 ensure the count result verification and that the server has checked each tuple, respectively. The verification method for a count query works as follows:

The DB Owner. For enabling a count query result verification over any attribute, the DB owner adds two attributes, say Ax and Ay, having initialized with one, to the relation R1. The values of the attributes Ax and Ay are also outsourced of SSS form (not unary representations) to the servers.

Server. Each server k executes the count query, as mentioned in Section 5, i.e., it executes the private string-matching operation on the ith (1≤i≤n) value of the attribute Aj against the query predicate and adds all the resultant values. In addition, each server k executes the functions f1 and f2. The function f1 (and f2) multiplies the ith value of the Ax (and Ay) attribute by the ith string-matching resultant (and by the complement of the ith string-matching resultant). The server k sends the following three things: (i) the sum of the string-matching operation over the attribute Aj, as a result, say ⟨result⟩k, of the count query, (ii) the outputs of the function f1: ⟨op1⟩k, and (iii) the sum of outputs of the function f1 and f2: ⟨op2⟩k, to the user.

User-side. The user interpolates the received three values from each server, which result in Iresult, Iop1, and Iop2. If the server followed the algorithm, the user will obtain: Iresult=Iop1 and Iop2=n, where n is the number of tuples in the relation, and it is known to the user.

Example. In Appendix A, available online, we provide an example of count query verification over secret-shares. However, here, we explain the above method using the following query on the Employee relation (refer to Table 5): select count(*) from Employee where Name = ‘John’. Table 9 shows the result of the private string-matching, functions f1 and f2 at a server. Note that for the purpose of explanation, we use cleartext values; however, the server will perform all operations over secret-shares. For the first tuple, when the servers check the first value of Name attribute against the query predicate, the result of string-matching becomes 1 that is multiplied by the first value of the attribute Ax, and results in 1. The complement of the resultant is multiplied by the first value of the attribute Ay, and results in 0. All the other tuples are processed in the same way. Note that for this query, result=op1=2 and op2=6, if server performs each operation correctly.

TABLE 9 An Execution of the Count Query Verification
Table 9- 
An Execution of the Count Query Verification
Correctness. Consider two cases: (i) all servers discard an entire identical tuple for processing, or (ii) all servers correctly process each value of the attribute Aj, op1, and op2; however, they do not add an identical resultant, oi (1≤i≤n), of the string-matching operation. In the first case, the user finds Iresult=Iop1 to be true. However, the second condition (Iop2=n) will never be true, since discarding one tuple will result in Iop2=n−1. In the second case, the servers will send the wrong result by discarding an ith count query resultant, and they will also discard the ith value of the attribute Ax to produce Iresult=Iop1 at the user-side. Here, the user, however, finds the second condition Iop2=n to be false.

Thus, the above verification method correctly verifies the count query result, always, under the assumption of SSS that an adversary cannot collude all (or the majority of) the servers, as given in Section 3.2.

SECTION 6Sum and Average Queries
The sum and average queries are based on the search operation as mentioned above in the case of conjunctive/disjunctive count queries. In this section, we briefly present sum and average queries on a secret-shared database outsourced by single or multiple DB owners. Then, we develop a result verification approach for sum queries.

Conjunctive Sum Query. Consider the following query: select sum(Aℓ) from R where A1=v1∧A2=v2∧…∧Am=vm.

In the secret-sharing setting, the user transforms the above query into the following query at the jth server: select sum(Aℓ) from S(R1)j where A1=S(v1)j∧A2=S(v2)j∧…∧Am=S(vm)j. This query will be executed in a similar manner as conjunctive count query except for the difference that the ith resultant of matching the query predicate is multiplied by the ith values of the attribute Aℓ. The jth server performs the following operation on each attribute on which the user wants to compute the sum, i.e., Aℓ and Aq:
∑k=1k=nAℓ[S(ak)]j×(∏i=1i=m(Ai[S(ak)]j⊗S(vi)j)).
View SourceCorrectness. The correctness of conjunctive sum queries is similar to the argument for the correctness of conjunctive count queries.

Disjunctive Sum Query. Consider the following query: select sum(Aℓ) from R where A1=v1∨A2=v2∨…∨Am=vm. The user transforms the query predicates to c secret-shares that results in the following query at the jth server:
selectsum(Aℓ)fromS(R1)j
View Source
whereA1=S(v1)j∨A2=S(v2)j∨…∨Am=S(vm)j.
View Source

The server j executes the following computation:
Resultki=Ai[S(ak)]j⊗S(vi)j,1≤i≤m,1≤k≤n
View SourceRight-click on figure for MathML and additional features.
Output=∑k=1k=nAℓ[S(ak)]j×(((Resultk1 OR Resultk2) OR 
View SourceRight-click on figure for MathML and additional features.
Resultk3)… OR Resultkn).
View Source

The server multiplies the kth comparison resultant by the kth value of the attribute, on which the user wants to execute the sum operation (e.g., Aℓ), and then, adds all values of the attribute Aℓ.

Correctness. The correctness of a disjunctive sum query is similar to the correctness of a disjunctive count query.

Average Queries. In our settings, computing the average query is a combination of the counting and the sum queries. The user requests the server to send the count and the sum of the desired values, and the user computes the average at their end.

Information Leakage Discussion. Sum queries work identically to count queries. Sum queries, like count queries, hide the facts which tuples are included in the sum operation, and the sum of the values.

6.1 Result Verification of Sum Queries
Now, we develop a result verification approach for a single-dimensional sum query. The approach can be extended for conjunctive and disjunctive sum queries. Let Aℓ be an attribute whose values will be included by the following sum query: select sum(Aℓ) from R where Aq=v.

Here, our objective is to verify that (i) all tuples of the databases are checked against the sum query predicates, Aq=v, and (ii) only all qualified values of the attribute Aℓ are included as an answer to the sum query. The verification of a sum query first verifies the occurrences of the tuples that qualify the query predicate, using the mechanism for count query verification (Section 5.1). Further, the server computes two functions, f1 and f2, to verify both the conditions of sum-query verification in an oblivious manner, as follows:
op1=f1(x)=∑i=1i=noi(xi+ai+oi)
View SourceRight-click on figure for MathML and additional features.
op2=f1(x)=∑i=1i=noi(yi+ai+oi),
View SourceRight-click on figure for MathML and additional features.i.e., the server executes the functions f1 and f2 on n values, described below. In the above equations, oi is the output of the string-matching operation carried on the ith value of the attribute Aq, and ai be the ith (1≤i≤n) value of the attribute Aℓ. The server sends the sum of the outputs of the function f1, denoted by op1, and the outputs of f2, denoted by op2, to the user. Particularly, the verification method for a sum query works as follows:

The DB Owner. Analogous with the count verification method, if the data owner wants to provide verification for sum queries, new attributes should be added. Thus, the DB owner adds two attributes, say Ax and Ay, to the relation R1. The ith values of the attributes Ax and Ay are any two random numbers whose difference equals to −ai, where ai is the ith value of the attribute Aℓ. The values of the attributes Ax and Ay are also secret-shared using SSS. For example, in Table 10, boldface numbers show these random numbers of the attribute Ax and Ay in cleartext.

TABLE 10 An Execution of the Sum Query Verification

Servers. The servers execute the above-mentioned sum query, i.e., each server k executes the private string-matching operation on the ith (1≤i≤n) value of the attribute Aq against the query predicate v and multiplies the resultant value by the ith value of the attribute Aℓ. The server k adds all the resultant values of the attributes Aℓ.

Verification Stage. The server k executes the functions f1 and f2 on each value xi and yi of the attributes Ax and Ay, by following the above-mentioned equations. Finally, the server k sends the following three things to the user: (i) the sum of the resultant values of the attributes Aℓ, say ⟨sumℓ⟩k, (ii) the sum of the output of the string-matching operations carried on the attribute Aq, say ⟨sumq⟩k,9 against the query predicate, and (iii) the sum of outputs of the functions f1 and f2, say ⟨sumf1f2⟩k.

User-side. The user interpolates the received three values from each server, which results in Isumℓ, Isumq, and Isumf1f2. The user checks the value of Isumf1f2−2×Isumq and Isumℓ, and if it finds equal, then it implies that the server has correctly executed the sum query.

Example. We explain the above method using the following query on the Employee relation (refer to Table 5): select sum(Salary) from Employee where Dept = ‘Testing’. Table 10 shows the result of the private string-matching (o), the values of the attributes Ax and Ay in boldface, and the execution of the functions f1 and f2 at a server. Note that for the purpose of explanation, we show the verification operation in cleartext; however, the server will perform all operations over secret-shares.

For the first tuple, when the server checks the first value of Dept attribute against the query predicate, the string-matching resultant, o1, becomes 1 that is multiplied by the first value of the attribute Salary. Also, the server adds the salary of the first tuple to the first values of the attributes Ax and Ay with o1. Then, the server multiplies the summation outputs by o1.

For the second tuple, the servers perform the same operations, as did on the first tuple; however, the string-matching resultant o2 becomes 0, which results in the second values of the attributes Ax and Ay to be 0. The servers perform the same operations on the remaining tuples. Finally, the servers send the summation of oi (i.e., 2), the sum of the salaries of qualified tuples (i.e., 6000), and the sum of outputs of the functions f1 and f2 (i.e., 6004), to the user. Note that for this query, Isumf1f2−2×Isumq=Isumℓ, i.e., 6004−2×2=6000.

Correctness. The occurrences of qualified tuples against a query predicates can be verified using the method given in Section 5.1. Consider two cases: (i) all servers discard an entire identical tuple for processing, or (ii) all servers correctly process the query predicate, but they discard the ith values of the attributes Aℓ, Ax, and Ay.

The first case is easy to deal with, since the count query verification will inform the user that an identical tuple is discarded by the server for any processing. In the second case, the user finds Isumf1f2−2×Isumq≠Isumℓ, since an adversary cannot provide a wrong value of Isumq, which is detected by count query verification. In order to hold the equation Isumf1f2−2×Isumq=Isumℓ, the adversary needs to generate shares such that Isumf1f2−Isumℓ=2×Isumq, but an adversary cannot generate any share, as per the assumption of SSS that an adversary cannot produce a share, since it requires to collude all (or the majority of) the servers, which is impossible due to the assumption of SSS, as mentioned in Section 3.2.

SECTION 7Maximum Query
This section provides methods for finding the maximum value and retrieving the corresponding tuples for the two types of queries, where the first type of query (QMax1) does not have any query condition, while another (QMax2) is a conditional query, as follows:

QMax1. select * from Employee where Salary in (select max(Salary) from Employee)

QMax2. select * from Employee as E1 where E1.Dept = ’Testing’ and Salary in (select max(salary) from Employee as E2 where E2.Dept = ’Testing’)10

Note that the string-matching secret-sharing algorithms (as explained in Section 2) cannot find the maximum value, as these algorithms provide only equality checking mechanisms, not comparing mechanisms to compare between values. For answering maximum queries, we provide two methods: The first method, called SDBMax is applicable for the case when only a single DB owner outsources the database. It will be clear soon that SDBMax takes only one communication round when answering an unconditional query (like QMax1) and at most two communication rounds for answering a conditional query (like QMax2). The second method, called MDBMax is applicable to the scenario when multiple DB owners outsource their data to the servers.

SDBMax. In this section, we assume that Ac be an attribute of the relation S(R1) on which the user wishes to execute maximum queries. Our idea is based on a combination of OP-SS [29], [37] and SSS [27], [44] techniques. Specifically, for answering maximum queries, SDBMax uses the two relations S(R1) and S(R2), which are secured using secret-shared and OP-SS, respectively, as explained in Section 3.1. In particular, according to our data model (Section 3.1), the attribute Ac will exist in the relations S(R1)i and S(R2)i at the server i. The strategy is to jointly execute a query on the relations S(R1)i and S(R2)i and obliviously retrieve the entire tuple from S(R1)i. In this paper, due to space restrictions, we develop SDBMax for the case when only a single tuple has the maximum value; for example, in Employee relation (see Table 5), the maximum salary over all employees is unique.

7.1 Unconditional Maximum Query
Recall that by observing the shares of the attribute Ac of the relation S(R1), the server cannot find the maximum value of the attribute Ac. However, the server can find the maximum value of the attribute Ac using the relation S(R2), which is secret-shared using OP-SS. Thus, to retrieve a tuple having the maximum value in the attribute Ac of the relation S(R1)i, the ith server executes the following steps:

On the relation S(R2)i. Since the secret-shared values of the attribute Ac of the relation S(R2)i are comparable, the server i finds a tuple ⟨S(tk),S(value)⟩i having the maximum value in the attribute Ac, where S(tk)i is the kth secret-shared tuple-id (in the attribute SSTID) and S(value)i is the secret-shared value of the Ac attribute in the kth tuple.

On the relation S(R1)i. Now, the server i performs the join of the tuple ⟨S(tk),S(value)⟩i with all the tuples of the relation S(R1)i by comparing the tuple-ids (TID attribute’s values) of the relation S(R1)i with S(tk)i, as follows:
∑k=1k=nAp[S(ak)]i×(TID[S(ak)]i⊗S(tk)i).
View SourceRight-click on figure for MathML and additional features.Where p (1≤p≤m) is the number of attributes in the relation R and TID is the tuple-id attribute of S(R1)i. The server i compares the tuple-id ⟨S(tk)⟩i with each kth value of the attribute TID of S(R1)i and multiplies the resultant by the first m attribute values of the tuple k. Finally, the server i adds all the values of each m attribute.

Correctness. The server i can find the tuple having the maximum value in the attribute Ac of the relation S(R2)i. Afterward, the comparison of the tuple-id S(tk)i with all the values of the TID attribute of the relation S(R1)i results in n−1 zeros (when the tuple-ids do not match) and only one (when the tuple-ids match) of secret-share form. Further, the multiplication of the resultant (0 or 1 of secret-share form) by the entire tuple will leave only one tuple in the relation S(R1)i, which satisfies the query.
Information Leakage Discussion. The adversary will know only the order of the values, due to OP-SS implemented on the relation S(R2). However, revealing only the order is not threatening, since the adversary may know the domain of the values, for example, the domain of age or salary.

Recall that, as mentioned in Section 3.1, the relations S(R1) and S(R2) share attributes: TID/SSTID and Ac (the attribute on which a comparison operation will be carried). However, by just observing these two relations, the adversary cannot know any relationship between them, as well as, which tuple of the relation S(R1) has the maximum value in the attribute Ac, due to different representations of common TID/SSTID and Ac values between the relations. Furthermore, after the above-mentioned maximum query (QMax1) execution, the adversary cannot learn which tuple of the relation S(R1) has the maximum value in the attribute Ac, due to executing an identical operation on each tuple of S(R1) when joining with a single tuple of S(R2).

7.2 Conditional Maximum Query
The maximum value of the attribute Ac may be different from the Ac’s maximum value of the tuple satisfying the where clause of a query. For example, in Employee relation, the maximum salary of the testing department is 2,000, while the maximum salary of the employees is 100,000. Thus, the method given for answering unconditional maximum queries is not applicable here. In the following, we provide a method to answer maximum queries that have conditional predicates (like QMax2), and that uses two communication rounds between the user and the servers, as follows:

Round 1. The user obliviously knows the indexes of the relation S(R1) satisfying the where clause of the query (the method for obliviously finding the indexes is given below).

Round 2. The user interpolates the received indexes and sends the desired indexes in cleartext to the servers. Each server i finds the maximum value of the attribute Ac in the requested indexes by looking into the attribute CTID of the relation S(R2)i and results in a tuple, say ⟨S(tk),S(value)⟩i, where S(tk)i shows the secret-shared tuple-id (from SSTID attribute) and S(value)i shows the secret-shared maximum value. Now, the server i performs a join operation between all the tuples of S(R1)i and ⟨S(tk),S(value)⟩i, as performed when answering unconditional maximum (QMax1) queries; see Section 7.1. This operation results in a tuple that satisfies the conditional maximum query.

Note. The difference between the methods for answering unconditional and conditional maximum queries is that first we need to know the desired indexes of S(R1) relation satisfying the where clause of a query in the case of conditional maximum queries.

Correctness. The correctness of the above method can be argued in a similar way as the method for answering unconditional maximum queries.

Information Leakage Discussion. In round 1, due to obliviously retrieving indexes of S(R1), the adversary cannot know which tuples satisfy the query predicate. In round 2, the user sends only the desired indexes in cleartext to fasten the lookup of the maximum salary. Note that by sending indexes, the adversary learns the number of tuples that satisfies the query predicate;11 however, the adversary cannot learn which tuples of the relation S(R1) have those indexes. Due to OP-SS, the adversary also knows only the order of values of Ac attribute in the requested indexes. However, joining the tuple of S(R2), which has the maximum value in Ac attribute, with all tuples of S(R1) will not reveal which tuple satisfies the query predicate, as well as, have the maximum value in Ac.

Aside: Hiding Frequency-Analysis in Round 2 Used for Conditional Maximum Queries. In the above-mentioned round 2, the user reveals the number of tuples satisfying a query predicate. Now, below, we provide a method to hide frequency-count information:

User-side. The user interpolates the received indexes (after round 1) and sends the desired indexes with some fake indexes, which do not satisfy the query predicate in the round 1, in cleartext to the servers. Let x=r+f be the indexes that are transmitted to the servers, where r and f be the real and fake indexes, respectively. Note that the maximum value of the attribute Ac over x tuples may be more than the maximum value over r tuples. Hence, the user does the following computation to appropriately send the indexes: The user arranges the x indexes in a x−−√×x−−√ matrix, where all r real indexes appear before f fake indexes. Then, the user creates x−−√ groups of tuples ids, say g1,g2,…,gx√, where all tuples ids in an ith row of the matrix become a part of the group gi. Note that in this case only one of the groups, say gmix, may contain both the real and fake indexes. Now, the user asks the server to find the maximum value of the attribute Ac in each group except for the group gmix and to fetch all x−−√ tuples of the group gmix.

Server. For each group, gj, except the group gmix, each server i finds the maximum value of the attribute Ac by looking into the attribute CTID of the relation S(R2)i and results in a tuple, say ⟨S(tk),S(value)⟩i. Further, the server i fetches all x−−√ tuples of the group gmix. Then, the server i performs a join operation (based on the attribute TID and SSTID, as performed in the second step for answering unconditional maximum queries; see Section 7.1) between all the tuples of S(R1)i and 2x−−√−1 tuples obtained from the relation S(R2), and returns 2x−−√−1 tuples to the user. The user finds the maximum value over the r real tuples. Note that 2x−−√−1 tuples must satisfy a conditional maximum query; however, due to space restrictions, we do not prove this claim here.

Note that this method, on one hand, hides the frequency-count; on the other hand, it requires the servers and the user process more tuples than the method that reveals the frequency-count.

Obliviously Finding the Indexes. For finding the indexes, each server k executes the following operation: Index[i]k×(Ap[i]k⊗S(v)k), i.e., the server executes string-matching operations on each value of the desired attribute, say Ap, of the relation S(R1) and checks the occurrence of the query predicate v. Then, the server k multiplies the ith resultant of the string-matching operation by the ith value of Index attribute of the relation S(R1). Finally, the server sends all the n values of the attribute Index to the user, where n is the number of tuples in the relation. The user interpolates the received values and knows the desired indexes.12

7.3 Verification of Maximum Query
This section provides a method to verify the tuple having maximum value in an attribute, Ac. Note that verifying only the maximum value of the tuple is trivial, since ⟨S(value)⟩i of S(R2)i is also a part of the attribute of Ac of S(R1)i, and servers send a joined output of the relations (see step 2 in Section 7.1). Thus, servers cannot alter the maximum value. However, servers can alter other attribute values of the tuple. Thus, we provide a method to verify the received tuple.

Verification of Retrieved Tuple. This method is an extension of the sum verification method (as given in Section 6.1). The server computes two functions, f1 and f2, in an oblivious manner, as follows:
op1=f1(x)=∑i=1i=noi(xi+sij)
View SourceRight-click on figure for MathML and additional features.
op2=f1(x)=∑i=1i=noi(yi+sij),
View Sourcei.e., the server executes the functions f1 and f2 on n values, described below. In the above equations, oi is the output of the string-matching operation carried on the ith value of the TID attribute, and si,j be the ith (1≤i≤n) value of the attribute j, where 1≤j≤m. The server sends the difference of the outputs of the functions f1 and f2 to the user. Particularly, the tuple verification method works as follows:

The DB Owner. The DB owner adds one value to each of the attribute values of a tuple along with new attributes, say Ax and Ay.

Let A1 be an attribute having only numbers. For A1 attribute, the newly added ith value in cleartext is same as the existing ith value in A1 attribute. Let A2 be an attribute having English alphabets, say attribute Name in Employee relation in Table 5. The new value is the sum of the positions of each appeared alphabet in English letters; for example, the first value in the attribute Name is John, the DB owner adds 47 (10+15+8+14). When creating shares of the two values at the ith position of the attribute A1 or A2, the first value’s shares are created using the mechanism that supports string-matching at the server, as mentioned in Section 2.1, and the second value’s shares are created using SSS.

The ith values of the attributes Ax and Ay are two random numbers whose difference equals to −ai, where ai is the ith value obtained after summing all the newly added values to each attribute of the ith tuple. The values of the attributes Ax and Ay are secret-shared using SSS. E.g., in Table 11, numbers show newly added values to attributes Name′, Dept′, and random numbers (in bold-face) of the attributes Ax and Ay in cleartext (a prime (′) symbol is used to distinguish these values from the original attribute values).

TABLE 11 An Execution of the Tuple Retrieval Verification

Servers. Each server k executes the method for tuple retrieval as given in step 2 in Section 7.1. Then, the server k executes functions f1 and f2, i.e., adds all the m newly added values (one in each attribute) to xi and yi of the attributes Ax and Ay, respectively, and then, multiply the resultant of the string-matching operation carried on TID attribute of the relation S(R1)k. Finally, the server k sends the following two things to the user: (i) the tuple having the maximum value in the attribute Ac of the relation S(R1)k; and (ii) the difference of outputs of the functions f1 and f2, say ⟨difff1f2⟩k.

User. After interpolation, the user obtains the desired tuple and a value, say Idifff1f2. Like the DB owner, the user generates a value for each of the attribute values of the received tuple (see the first step above for generating values), compares against Isumf1f2, and if it finds equal, then it implies that the server has correctly sent the tuple.

Example. Table 11 shows the verification process for the first tuple-id of employee relation; see Table 5. Note that the values and computation are shown in the cleartext; however, the values are of secret-share form and the computation will be carried on shares at servers.

SECTION 8Other Operations
This section considers two more cases of a maximum query, where the maximum value can occur in multiple tuples (Section 8.1) and find the maximum value (or retrieve the tuple having the maximum value) over a dataset outsourced by multiple DB owners (Section B). Further, we present an algorithm for a group-by query.

8.1 Multiple Occurrences of the Maximum Value
In practical applications, more than one tuple may have the maximum value in an attribute, e.g., two employees (E103 and E015) earn the maximum salary in design department; see Table 5. However, the above-mentioned methods (for QMax1 or QMax2) cannot fetch all those tuples from the relation S(R1) in one round. The reason is that since the server i uses OP-SS values of the attribute Ac in the relation S(R2)i for finding the maximum value, where more than one occurrences of a value have different representations, the sever i cannot find all the tuples of S(R2) having the identical maximum value, by looking OP-SS values.

In this subsection, we, thus, provide a simple two-communication-round method for solving unconditional maximum queries. This method can be easily extended to conditional maximum queries.

Data Outsourcing. The DB owner outsources the relation S(R1) as mentioned in Section 3.1. However, the DB owner outsources the relation S(R2) with four columns: CTID, SSTID, OP-SS-Ac, and SS-Ac. The first three columns are created in the same way as mentioned in Section 3.1. The ith value of SS-Ac attribute has the same value as the ith value of OP-SS-Ac attribute. However, this value is secret-shared using the unary representation, as the column Ac of the relation S(R1) has, and the DB owner uses different polynomials over the ith value of the attribute Ac of S(R1) and the attribute SS-Ac of S(R2); thus, the adversary cannot observe that which two values are identical in the two relations.

Query Execution. The method uses two communication rounds as follows:

Round 1. In round 1, the server i finds a tuple ⟨S(tk),S(value1),S(value2)⟩i having the maximum value (denoted by ⟨S(value)1⟩i) in the attribute Ac, where S(tk)i is the kth secret-shared tuple-id (in the attribute SSTID) and ⟨S(value)2⟩i is the secret-shared value of the SS-Ac attribute in the kth tuple. Afterward, the server i performs the following:
Index[k]×(AC[S(k)]i⊗S(value2)i),1≤k≤n,
View Sourcei.e., the server compares ⟨S(value2)⟩i with each kth value of the attribute Ac of the relation S(R1) and multiplies the resultant by the kth index values. The server i provides a list of n numbers to the user.

Round 2. After interpolating n numbers, the user gets a list of n numbers having 0 and Index values, where the desired maximum value of the attribute Ac exists. Then, the user fetches all the tuples having the maximum values based on the received Index value. In particular, the user creates new secret-shares of the matching indexes in a way that the server can perform searching operation on TID attribute. The server executes the following computation to retrieve all the tuples, say T, having the maximum value in the attribute Ac:
∑k=1k=nAp[S(ak)]i×(TID[S(ak)]i⊗S(tj)i).
View SourceRight-click on figure for MathML and additional features.

Where 1≤p≤m, 1≤j≤T and 1≤k≤n, i.e., the server i compares each received tuple-id T with each tuple-id of the relation S(R1)i and multiplies the resultant to the first m attributes of the relation S(R1)i. Finally, the server i adds all the attribute values for each tuple-id T.

Complexities. As mentioned, fetching all tuples having the maximum value in the attribute Ac requires two communication rounds when answering an unconditional query. Further, each server scans the entire relation S(R1) twice. However, finding the maximum number over the attribute OP-SS-Ac can be done using an index.

Information Leakage Discussion. The adversary learns the order of the values. The adversary will not learn which tuple has the maximum value in the attribute Ac. But, the adversary may learn how many tuples have the maximum value. This can be prevented by asking queries for fake tuples in round 2 by generating random TID values, which should be larger than n (the number of tuples in the relation).

Aside. We can prevent having to outsource S(R2), by adding one additional communication round between the user and the server. In that case, the server provides a tuple having the maximum value in the attribute Ac, and then, the user finds occurrences of the maximum value in the relation S(R2) by using one additional round.

Note. Answering conditional maximum query. The above mechanism can easily be extended to support conditional maximum queries. For answering a conditional maximum query, the user includes the above-mentioned two steps to the method given in Section 7.2. Thus, fetching all tuples having the maximum value in the attribute Ac requires three communication rounds, and each server scans the entire relation S(R1) three times. In particular, in the first round, the server i provides Index values to the user. In the second round, the server i finds the tuple having the maximum value in the attribute Ac from the requested tuple-ids, implements the above-mentioned method given in round 1, and provides a list of n numbers. In the last round, the user fetches all the desired tuples.

8.2 Group-by Query
A group-by query in combination with aggregation (viz., count/sum), can be executed similar to the aggregation query as mentioned in Sections 5 and 6, if the set of possible values – for the attribute on which the group-by query will be executed – is known to the user in advance. For example, consider the following group-by query on Employee relation, shown in Table 5:
selectDept,count(Dept)fromEmployee
View SourceRight-click on figure for MathML and additional features.
groupbyDept.
View SourceRight-click on figure for MathML and additional features.In this query, the user needs to know the name of departments, i.e., Testing, Security, and Design, and then, the user can execute the query at the servers for each department. Below, we briefly summarize, the execution of a group-by query with count/sum aggregation operation.

Group-by Query With Count. Consider the following group-by query: select Ai, count(Ai) from R group by Ai. For answering this group-by query, the server j executes the following computation on each tuple of the relation R for each group (1 to g):
Outputl=∑k=1k=n(Ai[S(ak)]j⊗S(vl)j).
View SourceWhere 1≤l≤g, vl is the name of each group, ⊗ shows a string-matching operation, and Outputl is the answer to the group-by query. The server j will return ⟨S(vl)j,Outputl⟩, where 1≤l≤g. The user interpolates the received answers from the server to obtain the final answer to the query. Note that since the user will receive each group name, the user will know the correct answer to group-by queries for each group.

Group-by Query With Sum. Consider the following group-by query involving sum operation: select Ai, sum(Aℓ) from R group by Ai. For answering this group-by query, the server j executes the following computation on each tuple of the relation R for each group (1 to g):
Suml=∑k=1k=nAℓ[S(ak)]j×(Ai[S(ak)]j⊗S(vl)j).
View SourceRight-click on figure for MathML and additional features.Where 1≤l≤g, vl is the name of each group, ⊗ shows a string-matching operation, and Suml is the answer to the group-by query. The server j will return ⟨S(vl)j,Suml⟩, where 1≤l≤g.

Information Leakage Discussion. In executing the following query: select Dept, count(Dept) from Employee group by Dept, the adversary may learn the number of groups in an attribute, by receiving only three values, one value for each department. However, the user may also hide such information, by asking queries for additional fake groups. For example, the user may ask the count query for fake groups such as Sale and Production, including the three real groups (Testing, Security, and Design). Since the stored data and query predicates are secret-shared, the adversary cannot learn how many unique values exist in an attribute. In this case, the count query answer for real groups, after interpolation at the user-side, will produce the desired answers, but for the fake group, the user will obtain zero as the answer. Since the user knows the real and fake groups, the user can distinguish the results.

Note that since the proposed algorithms for group-by queries produce the result of secret-shared form, it prevents the adversary to know the frequency-count of each group. In addition, since the proposed algorithms check each group name against the desired attribute’s values of each tuple, it hides access-patterns and prevents the adversary to know which group name is real or fake. Further, note that different attributes in a relation may have a different number of unique values, and hence, group-by queries over different attributes will produce a different number of answers, (depending on the unique values in attributes). We can also hide this fact by executing a group-by query for fake groups. While such a method will prevent information leakages based on the number of groups across different groups, it will incur computational cost and communication cost.

8.3 Bucketization-Based Range Queries
As we mentioned, we convert a range query into several point queries that cover the entire range. However, as per Exp 8 (Fig. 5), as the range increases, the computation time also increases. In order to reduce the computation time, we propose a new method that creates bins over the domain of attribute values and organizes these bins into a k-way tree, where k is the number of child nodes of a node or the number of values in each node at the lowest level. The bucketization-based range queries works as follows:


Fig. 1.
2-way tree for 32 values.

Show All

Fig. 2. - 
Exp 3. Impact of parallelism, evaluated using AWS servers with 144GB RAM, 3.0GHz Intel Xeon CPU with 72 cores.
Fig. 2.
Exp 3. Impact of parallelism, evaluated using AWS servers with 144GB RAM, 3.0GHz Intel Xeon CPU with 72 cores.

Show All

Fig. 3. - 
Exp 4. Result verification.
Fig. 3.
Exp 4. Result verification.

Show All

Fig. 4. - 
Exp 5. Impact of the number of shares, using a single threaded implementation on 32 GB RAM, 2.5 GHz Intel Xeon CPU.
Fig. 4.
Exp 5. Impact of the number of shares, using a single threaded implementation on 32 GB RAM, 2.5 GHz Intel Xeon CPU.

Show All

Fig. 5. - 
Exp 7: Impact of executing range queries.
Fig. 5.
Exp 7: Impact of executing range queries.

Show All

DB Owner. Assume that the domain of values in an attribute has 1,2,…,n numbers. The DB owner first creates a k-way tree, by creating n/k nodes at the 0th-level by placing 1,2,…,k numbers in the first node, k+1,k+2,…,2k numbers in the second node, and so on. The first level node has ⌈n/k2⌉ nodes, where the first node of the first level becomes the parent of the first k nodes of 0th node. The second node of the first level becomes a parent of k+1,k+2,…,2k nodes of 0th-level. In this way, the DB owner constructs a k-way tree of height ⌈logk(n/k)+1⌉. Now for each level, except the root node and the leaf level, the DB owner adds one attribute in the relation R. An ith value of the attribute corresponding to a level, say j, is set to be the node id of the jth level’s node that covers the ith value at the leaf level (i.e., level 0).

Assume that an attribute A of a relation R has 32 numbers (1,2,…,32).13 Here, we show how does the DB owner create a 2-way tree and three additional columns. Fig. 1 shows a 2-way tree for 32 numbers. In a 2-way tree, the 0th level has n/k=16 nodes, each with two numbers. The tree height is logk(n/k)+1=5. Here, the DB owner adds three columns, say A1, A2, and A3, in the relation for levels 1, 2, and 3 of the tree; see Table 12. Note that, for example, 9th value of the attributes A1, A2, and A3 contains node-ids of the respective levels that cover 9th value of the level 0. Thus, the attribute A1 contains 103, since Node 103 covers the value 9, the attribute A2 contains 201, since Node 201 covers the value 9, and the attribute A3 contains 301, since Node 301 covers the value 9.

TABLE 12 A Relation RR Having Three New Attributes, A1A1, A2A2, and A3A3, Based on Bucketization of Range Values
Table 12- 
A Relation $R$R Having Three New Attributes, $A_1$A1, $A_2$A2, and $A_3$A3, Based on Bucketization of Range Values
Creating Secret-Shares of the Relation. The DB owner c secret-shares of each attribute value Ai[aj] of the relation R using a secret-sharing mechanism that allows string-matching operations at the server (as specified in Section 2).

User. We assume that the user is aware of the k value used in the k-way tree creation. For a given range, the user first finds the minimal set of nodes that cover the range, and then, creates secret-shares of those node values. We follow a least-match method for searching node values. Assume a query for counting the number of tuples having values between 1 and 13. The best-match method will find only Node 301 that satisfies this query. However, it will cover some other values too, resulting in a wrong answer to the query. Thus, using a minimal set of nodes that cover the range, the user breaks the range into sub-ranges such as Node 201, Node 103, and value 13. Note that by breaking the range from 1-13 into point queries requires searching 13 different values. However, in the modified representation of ranges using 2-way tree, the server will search only for three values.

Finally, the user creates secret-shares of these three values (Node 201, Node 103, and value 13) and sends them to the servers with the information of the desired attribute on which the server should search for a value.

Server. The server executes the count query as mentioned in Section 5. Particularly, in this example, each server searches for Node 201 in the attribute A2, for Node 103 in the attribute A1, and for the value 13 in the attribute A. Finally, the server adds the outputs of all three individual searches, which produce the final answer to the count query.

Note. By following the same idea of breaking a range into sub-range, one can execute conjunctive and disjunctive count/sum queries.

SECTION 9Experiments
This section evaluates the scalability of Obscure and compares it against other SSS- and MPC-based systems. We used a 16 GB RAM machine as a DB owner, as well as, a user that communicates with AWS servers. For our experiments, we used two types of AWS servers – a relatively weaker 32 GB, 2.5 GHz, Intel Xeon CPU (Exp 2, 5, 6), and a powerful 144 GB RAM, 3.0 GHz Intel Xeon CPU with 72 cores to study the impact of multi-threaded processing (Exp 3, 8).

9.1 Obscure Evaluation
Secret-Share (SS) Dataset Generation. We used four columns (Orderkey (OK), Partkey (PK), Linenumber (LN), and Suppkey(SK)) of LineItem table of TPC-H benchmark to generate 1M and 6M rows. To the best of our knowledge, this is the first such experiment of SSS-based approaches to such large datasets. We next explain the method followed to generate SS data for 1M rows. A similar method was used for generating SS data for 6M rows.

The four columns of LineItem table only contain numbers: OK: 1 to 300,000 (1,500,000 in 6M), PK: 1 to 40,000 (200,000 in 6M), LN: 1 to 7, and SK: 1 to 2000 (200,000 in 6M). The following steps are required to generate SS of the four columns in 1M rows:

The first step was to pad each number of each column with zeros. Hence, all numbers in a column contain identical digits to prevent an adversary to know the distribution of values. For example, after padding 1 of OK was 000,001. Similarly, values of PK and SK were padded. We did not pad LN values, since they took only one digit.

The second step was representing each digit into a set of ten numbers, as mentioned in Section 2.1, having only 0s or 1s. For example, 000,001 (one value of OK attribute) was converted into 60 numbers, having all zeros except positions 1, 11, 21, 31, 41, and 52. Here, a group of the first ten numbers shows the first digit, i.e., 0, a group of 11th to 20th number shows the second digit, i.e., 0, and so on.14 Similarly, each value of PK, SK, and LN was converted. We also added columns for TID, Index, count, sum, and maximum verification, and it resulted in the relation R1. Further, we created another relation, R2, with three attributes CTID, SSTID, and OK, as mentioned in Section 4.

The third step was creating SS of these numbers. We selected a polynomial f(x)=secret_value+a1x, where a1 was selected randomly between 1 to 10M for each number, the modulus is chosen as 15,000,017, and x was varied from one to fifteen to obtain fifteen shares of each value. On R2, we implemented OP-SS on OK attribute, and also generated fifteen shares of SSTID. Thus, we got S(R1)i and S(R2)i, 1≤i≤15. (Exp 5 will discuss in detail why are we generating fifteen shares.) For sum and tuple retrieval queries’ time minimization, we add four more attributes corresponding to each of the four attributes in LineItem table. A value of each of the four attributes has only one secret-shared value, created using SSS (not after padding). But, one can also implement the same query on secret-shared values obtained after step 2.

Lastly, we placed ith share of S(R1) and S(R2) to ith AWS server.

Exp 1. Data Generation Time. Table 13 shows the time to generate secret-shared LineItem table of size 1M and 6M rows, at the DB owner machine. Note that due to unary representation, the size of the data is large; however, the data generation time of Obscure is significantly less than an MPC system, which will be discussed in Section 9.2.

TABLE 13 Exp. 1. Average Time and Size for Shared Data Generation Using Single-Threaded Implementation at the DB Owner
Table 13- 
Exp. 1. Average Time and Size for Shared Data Generation Using Single-Threaded Implementation at the DB Owner
Exp 2. Obscure performance. In Obscure, we used multiple cores of CPU by writing parallel programs for one-dimensional (1D) count/sum, two-dimensional conjunctive-equality (2CE) count/sum, three-dimensional disjunctive-equality (3DE) count/sum, unconditional maximum (Unc-Max), conditional maximum (C-Max), and group-by queries on the LineItem table having 1M and 6M rows. A parallel program divides rows into blocks with one thread processing one block, and then, the intermediate results (generated by each thread) are reduced by the master thread to produce the final result.

For this experiment having fifteen shares, we used AWS servers with 144 GB RAM, 3.0 GHz Intel Xeon CPU with 72 cores, and varied the degree of parallelism up to 48 (number of parallel threads). Increasing more threads did not provide speed-up, since the execution time reached close to the time spent in the sequential part of the program (Amdahl’s law); furthermore, the execution time increases due to thread maintenance overheads. Fig. 2 shows as the number of threads increases, the computation time decreases. Also, observe that the data fetch time from the database remains (almost) same and less than the processing time. Further, the computation time reduces significantly due to using many threads on powerful servers (Fig. 2). Also, note that as the size of data increases, the time increases slightly more than linearly. This is due to the unary representation that requires 10 more numbers (for the 6M rows table) to cover one new additional digit in all attribute values (except LN attribute). This increase results in additional multiplications during string-matching. An important observation is that executing any query took at most 13seconds on 1M rows and 75seconds on 6M rows.

Count and Sum Queries. Fig. 2 shows the time taken by 1D, 2CE conjunctive-equality, and three-dimensional disjunctive-equality (3DE) count and sum queries. CE queries were executed on OK and LN, and DE queries involved OK, PK, and LN attributes. Observe that as the number of predicates increases, the computation time also increases, due to an increasing number of multiplications. The time difference between computations on 1M and 6M rows is about 6-7.4 percent.

Maximum Queries. Fetching the tuple having the maximum value in an unconditional maximum query was very efficient, due to OP-SS, and took at most 9seconds on 1M rows and at most 50seconds on 6M rows; see Fig. 2. We executed 1D conditional maximum query (C-Max). C-Max requires to know the tuple-ids that satisfy the condition in relation S(R1), and then, determining the maximum value from S(R2). Note that in both UnC-Max and C-Max, we achieve the maximum efficiently, due to OP-SS, (while also preventing background-knowledge-based attacks on OP-SS). The time difference between fetching a tuple having the maximum value from 1M and 6M data is about 5.5-6.6 percent.

Group-by Queries. A group-by query works in a similar manner to 1D count/sum query. Fig. 2 shows the time taken by a group-by query when the number of groups was seven (due to LN attribute that has seven values), where we counted the number of OK values corresponding to each LN value.

Exp 3. Impact of Local Processing at a Resource-Constrained User. To show the practicality of Obscure, we did an experiment, where a resource-constrained user downloads the entire encrypted data and executes the computation at their end after decrypting the data and loading into a database system. We restricted the user to have a machine with 1 GB RAM and single-core 1.35 GHz CPU using docker, unlike multicore servers used in Exp 3, and executed the same queries that we executed in Exp 3. With this setup, decryption time at the user side was 54s and 259s for 1M and 6M rows, respectively. Further, loading decrypted data into a database system (MySQL) at the user-side took 20s and 120s for 1M and 6M rows, respectively. All queries used in Exp 2 were executed in 1-5s for both 1M and 6M rows. Note that the user computation time is significantly higher compared to the computation time of queries in Exp 3. For example, end-to-end 1D count query execution in Exp 3 over 6M secret-shared rows took 26s (see Fig. 2b), while the same query took 385s when decrypting and loading the data into MySQL at the resource-constrained user.

Exp 4. Overheads of Result Verification. This experiment finds the overheads of the result verification approaches. Fig. 3a shows that count result verification steps do not incur a significant cost at the servers, since executing result verification requires only two more multiplications and modulo on each row’s Ax and Ay values (see Section 5.1). However, in the case of a sum query, the cost increases, due to first verifying count query results, and then, sum query results. If one drops count query result verification, the cost decreases significantly; see Fig. 3b. Fig. 3c shows the time comparison between fetching a tuple having the maximum value in an attribute and verifying that tuple. Here, in the case of UnC-Max-Tuple-Fetch, this step does not involve any condition checking. However, in the case of Cond-Max-Tuple-Fetch, we need to first apply count query verification method to verify that query predicate(s) are evaluated correctly. As mentioned previously, we are evaluating conditional maximum query for 1D predicate; hence, this step increases the time of verification by 304 and 790 seconds (s), in the case of 1M and 6M rows, respectively.

Exp 5. Impact of Number of Shares. In this experiment, we study the impact of the number of shares on the performance of Obscure. For this experiment, we used four different setups with data, secret shared between 3, 5, 11, and 15 servers. Due to space restrictions, we show results for 1M rows only. Fig. 4 shows computation time at the server and user side, with a different number of shares.

The results demonstrate two tradeoffs, first between the number of shares and computation time at the user, and second between the number of shares and the amount of data transferred from each server to the user. As the number of shares decreases, the computation time at the user increases; since the string-matching operation results in the degree of polynomials to be doubled, and if servers do not have enough shares, they cannot compute the final answer and may require more than one round of communication with the user to compute the SS aggregate value. Thus, the communication cost also increases with a decreasing number of shares.

From Fig. 4, it is clear that as the number of shares increases, the computation time at the user decreases and at the server increases, while the overall query execution time decreases, generally. In Appendix E, available online, we discuss the processing of each query under a different number of shares.

Exp 6. Impact of Communication Cost. An interesting point was the impact of the communication cost. Since servers send data to the user over the network, it may affect the overall performance. As mentioned in Exp 4., using 3 servers, the communication cost increases as compared to 15 servers. For instance, in executing DE count/sum queries over PK, LN, and OK attributes took the highest amount of data transfer when using 3 servers. Since the number of digits of the three predicates was 12 in 1M rows and 14 in 6M rows, each server sends 12 files (each of size 7 MB) in the case of 1M rows and 14 files (each of size 48 MB).

Hence, the server to user communication was 84 MB/server in the case of 1M rows and 672 MB/server in the case of 6M rows. However, in the case of 15 servers, the server to user communication was 7 MB/server in the case of 1M rows and 48 MB/server in the case of 6M rows. When using slow (100 MB/s), medium (500 MB/s), and fast (1 GB/s) speed of data transmission, the data transmission time in the case of 15 servers was negligible. However, in the case of 6M, it took 7s, 1s, less than 1s per server, respectively, on slow, medium, and fast transmission speed.

Observe that the computation time at the server was at least 40s in any query on 6M rows (when using 72 core servers; Fig. 2b) that was significantly more than the communication time between user and servers. Thus, the communication time does not affect the servers’s computation time, which was the bottleneck.

Exp 7. Range Queries. We evaluated range queries for 1D-count and 1D-sum operations. Given a range query involving k continuous values, we converted it into k 1D-count/sum queries (one per value in the range). However, this may require scanning the secret-shared relation k-times at the server. In order to reduce the number of scans, we processed (as per 1D-count or sum query) all the k-values in the range on each tuple, before processing the next tuple. As a result, we got k values (as per the 1D-count or sum query) after processing the entire relation. Finally, the server adds all k values and sends them to the user. We implemented a range query involving 1D-count/sum operations, using 48 threads on AWS servers with 144 GB RAM, 3.0 GHz Intel Xeon CPU with 72 cores. Fig. 5 shows that as the length of range increases the computation time also increases. In Appendix 8.3, available online, we provide a bucketization-based approach to reduce the computation time while increasing the range values.

Exp 8. Bucketization-Based Range Queries. We pre-computed the range information with k=10 for OrderKey values (with domain of 1-150000) of LineItem table of TPC-H. We outsourced the secret-shared version of this range information along with the original data. We executed 1D-count query on OrderKey values. Fig. 6 shows that with pre-computed range information in the form of buckets significantly decreases the computation time (i.e., the amount of time spent in range-based filtering over secret-shared data). Note that the naïve range implementation scales linearly with the length of range, whereas the bucketized pre-computed range information along with each tuple, takes almost constant time even after increasing the range length. Furthermore, it sometimes drops as fewer buckets are able to cover the entire range. For example, a range of 1-99 requires 19 searches (9 for 9 buckets covering values from 1 to 90 and extra 9 searches for values 91 to 99), whereas for a range from 1 to 100 we only need 1 bucket to represent it, therefore the time required to execute a range query for 1 to 100 decreases. Fig. 7 shows how the number of multiplications per row varies with the increase in the range length. We can see that the naïve implementation requires many multiplications as compared to the bucketization-based range algorithm. However, since we store range information along with each tuple, the size of the database increases, requiring more time to scan the table. Fig. 6 shows that for small-sized ranges (length <10), the naïve algorithm performs better as the number of multiplication require by both the algorithms are equal, but the scanning time for the naïve algorithm is smaller than the bucketization-based algorithm.

Fig. 6. - 
Exp 8: Impact of executing range queries using bucketization.
Fig. 6.
Exp 8: Impact of executing range queries using bucketization.

Show All

Fig. 7. - 
Exp 8: Number of multiplication operations used in string-matching operation in range queries.
Fig. 7.
Exp 8: Number of multiplication operations used in string-matching operation in range queries.

Show All

Exp 9. Obscure performance on a weaker machine. In this experiment, we explored Obscure on a relatively weaker single-threaded machine with 32 GB. We chose this machine since (as will be clear in Section 9.2) the MPC system, we used, can only work on a local single-threaded machine. To be able to compare against that we also execute Obscure on 32 GB AWS servers. Note that single-threaded implementation of Obscure incurs time overheads, which are significantly reduced when using many threads on powerful servers; see Exp 2. Likewise Exp 2, we executed count, sum, unconditional and conditional maximum, and group-by queries on the LineItem table having 1M and 6M rows using fifteen shares; see Fig. 8. Note that Fig. 8 shows that determining only the maximum value is efficient due to OP-SS, in the case of unconditional maximum queries (UnC-Max-Det, QMax1, see Section 7).


Fig. 8.
Exp 9. Obscure performance using a single-threaded implementation on 32GB RAM, 2.5GHz Intel Xeon CPU.

Show All

9.2 Comparing With Other Works
The previous works on SSS-based techniques either did not report any experiments [27], [29] or scaled to only a very small dataset, or used techniques that, while efficient, were insecure [30], [50]. For instance, [30], [50] are both vulnerable to access-pattern attacks. Furthermore, these approaches achieve efficient query processing times (e.g., 90 ms for aggregation queries on databases of size 150K) by executing queries on SS data identically to that on cleartext, which requires user sides to retain polynomials, which were used to generate SS-data. Thus, as mentioned in Section 2.2, the DB owner keeps n×m polynomials, where n and m are the number of rows and columns in a database, respectively.

MPC-based methods, e.g., [9], [16], [17], [18], are secure, they also do not scale to large datasets due to high overhead of share creation and/or query execution. For example, MPC-based Sepia [18] used 65K values for only count operation without any condition with the help of three to nine servers, and recent Bonawitz et al. [17] (appeared in CCS 2017) used only 500K values for count and sum of the numbers. Note that Sepia [18] and Bonawitz et al. [17] do not support conjunctive/disjunctive count/sum queries.

We evaluated one of the state-of-the-art industrial MPC-based systems that we refer to system Z to get a better sense of its performance compared to Obscure, whose performance is given in Fig. 8. However, we note that the MPC systems, as mentioned in Section 1, are not available as either open source, and, often, not even available for purchase, except in the context of a contract. We were able to gain access to System Z, due to our ongoing collaboration with the team under the anonymity understanding. We installed system Z (having three SS of LineItem) on the local machine, since it was not allowed to install it on AWS. Also, note that we cannot directly compare system Z and Obscure, since system Z uses a single machine to keep all three shares. Inserting 1M rows in system Z took 9 hours, while the size of SS data was 1GB. We executed the same queries using the system Z, which took the following time: 532s for 1D count, 808s for CE count, 1099s for DE count, 531s for 1D sum, 801s for CE sum, 1073s for DE sum, 2205s for UnC-Max-Tuple-Fetch, and 2304s for Cond-Max-Tuple-Fetch.

SECTION 10Conclusion
We proposed Obscure that is a information-theoretically secure, oblivious, and communication efficient system for answering aggregation queries (count, sum, and maximum having single-dimensional, conjunctive, or disjunctive query predicates) on a secret-shared dataset outsourced by either a single DB or multiple DB owners. Obscure also supports efficient result verification algorithms to protect against malicious adversarial cloud servers that deviate from the algorithm, due to software/hardware bugs. Our experimental results on 1M rows and 6M secret-shared rows using AWS servers show better performance as compared a simple strategy of downloading encrypted data, decrypting, and then, executing the query at a resource-constrained user. Further, we showed a tradeoff between the number of shares and performance.

Future Directions. While Obscure supports a wide range of aggregation queries, there are some issues that we plan to extend in the future, listed below:

Reducing the number of communication rounds between the user and the server to one for any aggregation query.

Designing an algorithm for group-by queries without knowing the unique values of the attribute on which the group-by query will be executed; recall that the existing algorithm for group-by queries requires to know the unique values in an attribute.

Dealing with multiple aggregation operators in a query. For example, Obscure can execute the following query in one communication round between the user and the server: SELECT avg(age), max(age) FORM Employee by creating two sub-queries, one for average and another for maximum. One may consider how to execute such a query only in one communication round, without creating two sub-queries.

Extending this work on GPU-based efficient join and nested queries, since the proposed algorithms use multiplication and addition operations, which can be supported by GPU very efficiently.