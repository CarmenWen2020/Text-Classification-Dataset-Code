There is a growing interest in applying deep learning (DL) to healthcare, driven by the availability of data with multiple feature channels in rich-data environments (e.g., intensive care units). However, in many other practical situations, we can only access data with much fewer feature channels in a poor-data environments (e.g., at home), which often results in predictive models with poor performance. How can we boost the performance of models learned from such poor-data environment by leveraging knowledge extracted from existing models trained using rich data in a related environment? To address this question, we develop a knowledge infusion framework named CHEER that can succinctly summarize such rich model into transferable representations, which can be incorporated into the poor model to improve its performance. The infused model is analyzed theoretically and evaluated empirically on several datasets. Our empirical results showed that CHEER outperformed baselines by 5.60 to 46.80 percent in terms of the macro-F1 score on multiple physiological datasets.
SECTION 1Introduction
In rich-data environments with strong observation capabilities, data often come with rich representations that encompass multiple channels of features. For example, multiple leads of Electrocardiogram (ECG) signals in hospital used for diagnosing heart diseases are measured in intensive care units (ICU), of which each lead is considered a feature channel. The availability of such rich-data environment has thus sparked strong interest in applying deep learning (DL) for predictive health analytics as DL models built on data with multi-channel features have demonstrated promising results in healthcare [1]. However, in many practical scenarios, such rich data are often private and not accessible due to privacy concern. Thus, we often have to develop DL models on lower quality data comprising fewer feature channels, which were collected from poor-data environments with limited observation capabilities (e.g., home monitoring devices which provide only a single channel of feature). Inevitably, the performance of state-of-the-art DL models, which are fueled by the abundance and richness of data, becomes much less impressive in such poor-data environments.

To alleviate this issue, we hypothesize that learning patterns consolidated by DL models trained in one environment often encode information that can be transferred to related environments. For example, a heart disease detection model trained on rich-data from 12 ECG channels in a hospital will likely carry pertinent information that can help improve a similar model trained on poor-data from a single ECG channel collected by a wearable device due to the correlation between their data. Motivated by this intuition, we further postulate that given access to a prior model trained on rich-data, the performance of a DL model built on a related poor-data can be improved if we can extract transferable information from the rich model and infuse them into the poor model. This is related to deep transfer learning and knowledge distillation but with a new setup that has not been addressed before, as elaborated in Section 2 below.

In this work, we propose a knowledge infusion framework, named CHEER, to address the aforementioned challenges. In particular, CHEER aims to effectively transfer domain-invariant knowledge consolidated from a rich model with high-quality data demand to a poor model with low data demand and model complexity, which is more suitable for deployment in poor-data settings. We also demonstrate empirically that CHEER helps bridge the performance gap between DL models applied in rich- and poor-data settings. Specifically, we have made the following key contributions:

We develop a transferable representation that summarizes the rich model and then infuses the summarized knowledge effectively into the poor model (Section 3.2). The representation can be applied to a wide range of existing DL models.

We perform theoretical analysis to demonstrate the efficiency of knowledge infusion mechanism of CHEER. Our theoretical results show that under practical learning configurations and mild assumptions, the poor model’s prediction will agree with that of the rich model with high probability (Section 4).

Finally, we also conduct extensive empirical studies to demonstrate the efficiency of CHEER on several healthcare datasets. Our results show that CHEER outperformed the second best approach (knowledge distillation) and the baseline without knowledge infusion by 5.60 and 46.80 percent, respectively, in terms of macro-F1 score and demonstrated more robust performance (Section 5).

SECTION 2Related Works
Deep Transfer Learning. Most existing deep transfer learning methods transfer knowledge across domains while assuming the target and source models have equivalent modeling and/or data representation capacities. For example, deep domain adaptation have focused mainly on learning domain-invariant representations between very specific domains (e.g., image data) on [2], [3], [4], [5], [6], [7], [8], [9], [10]. Furthermore, this can only be achieved by training both models jointly on source and target domain data.

More recently, another type of deep transfer learning [11] has been developed to transfer only the attention mechanism [12] from complex to shallow neural network to boost its performance. Both source and target models, however, need to be jointly trained on the same dataset. In our setting, since source and target datasets are not available at the same time and that the target model often has to adopt representations with significantly less modeling capacity to be compatible with the poor-data domain with weak observation capabilities.

Knowledge Distillation. Knowledge distillation [13] or mimic learning [14] aim to transfer the predictive power from a high-capacity but expensive DL model to a simpler model such as shallow neural networks for ease of deployment [15], [16], [17], [18]. This can usually be achieved via training simple models on soft labels learned from high-capacity models, which, however, assume that both models operate on the same domain and have access to the same data or at least datasets with similar qualities. In our setting, we only have access to low-quality data with poor feature representation, and an additional set of limited paired data that include both rich and poor representations (e.g., high-quality ICU data and lower-quality health-monitoring information from personal devices) of the same object.

Domain Adaptation. There also exists another body of non-deep learning transfer paradigms that were often referred to as domain adaption. This however often include methods that not only assume access domain-specific [19], [20], [21], [22], [23] and/or model-specific knowledge of the domains being adapted [24], [25], [26], [27], [28], [29], [30], [31], but are also not applicable to deep learning models [32], [33] with arbitrary architecture as addressed in our work.

In particular, our method does not impose any specific assumption on the data domain and the deep learning model of interest. We recognize that our method is only demonstrated on deep model (with arbitrary architecture) in this research but our formulation can be straightforwardly extended to non-deep model as well. We omit such detail in the current manuscript to keep the focus on deep models which are of greater interest in healthcare context due to their expressive representation in modeling multi-channel data.

SECTION 3The CHEER Method
3.1 Data and Problem Definition
Rich and Poor Datasets. Let Hr≜{(xri,yri)}ni=1 and Hp≜{(xpi,ypi)}mi=1 denote the rich and poor datasets, respectively. The subscript i indexes the ith data point (e.g., the ith patient in healthcare applications), which contains input feature vector xri or xpi and output target yri or ypi of the rich or poor datasets. The rich and poor input features xri∈Rr and xpi∈Rp are r- and p-dimensional vectors with p≪r, respectively. The output targets, yri and ypi∈{1…c}, are categorical variables. The input features of these datasets (i.e., xri and xpi) are non-overlapping as they are assumed to be collected from different channels of data (i.e., different data modalities). In the remaining of this paper, we will use data channel and data modality interchangeably.

For example, the rich data can be the physiological data from ICU (e.g., vital signs, continuous blood pressure and electrocardiography) or temporal event sequences such as electronic health records with discrete medical codes, while the poor data are collected from personal wearable devices. The target can be the mortality status of those patients, onset of heart diseases and etc. Note that these raw data are not necessarily plain feature vectors. They can be arbitrary rich features such as time series, images and text data. We will present one detailed implementation using time series data in Section 3.3.

Input Features. We (implicitly) assume that the raw data of interest comprises (says, p or r) multiple sensory channels, each of which can be represented by or embedded1 into a particular feature signal (i.e., one feature per channel). This results in an embedded feature vector of size p or r (per data point), respectively. In a different practice, a single channel may be encoded by multiple latent features and our method will still be applicable. In this paper, however, we will assume one embedded feature per channel to remain close to the standard setting of our healthcare scenario, which is detailed below.

Paired Dataset. To leverage both rich and poor datasets, we need a small amount of paired data to learn the relationships between them, which is denoted as Ho≜{(xri,xpi,yi)}ki=1. Note that the paired dataset contains both rich and poor input features, i.e., xri and xpi, of the same subjects (hence, sharing the same target yi).

Concretely, this means a concatenated input xoi=[xri,xpi] of the paired dataset has o=p+r features where the first r features are collected from r rich channels (with highly accurate observation capability) while the remaining p features are collected from p poor channels (with significantly more noisy observations). We note that our method and analysis also apply to settings where xpi⊆xri. In such cases, xoi=xri and o=r (though the number of data point i for which xri is accessible as paired data is much less than the number of those with accessible xpi). To avoid confusion, however, we will proceed with the implicit assumption that there is no feature overlapping between poor and rich datasets in the remaining of this paper.

For example, the paired dataset may comprise of rich data from ICU (xpi) and poor data from wearable sensors (xri), which are extracted from the same patient i. The paired dataset often contains much fewer data points (i.e., patients) than the rich and poor datasets themselves, and cannot be used alone to train a prediction model with high quality.

Problem Definition. Given (1) a poor dataset Hp collected from a particular patient cohort of interest, (2) a paired dataset Ho collected from a limited sample of patients, and (3) a rich model T(y|xr) which were pre-trained on private (rich) data of the same patient cohort, we are interested in learning a model S(y|xp) using both Hp, Ho and T(y|xr), which can perform better than a vanilla model D(y|xp) generated using only Hp or Ho.

Challenges. This requires the ability to transfer the learned knowledge from T(y|xr) to improve the prediction quality of S(y|xp). This is however a highly non-trivial task because (a) T(y|xr) only generates meaningful prediction if we can provide input from rich data channels, (b) its training data is private and cannot be accessed to enable knowledge distillation and/or domain adaptation, and (c) the paired data is limited and cannot be used alone to build an accurate prediction model.

Solution Sketch. Combining these sources of information coherently to generate a useful prediction model on the patient cohort of interest is therefore a challenging task which has not been investigated before. To address this challenge, the idea is to align both rich and poor models using a transferable representation described in Section 3.2. This representation in turn helps infuse knowledge from the rich model into the poor model, thus improving its performance. The overall structure of CHEER is shown in Fig. 1. The notations are summarized in Table 1.

TABLE 1 Notations Used in CHEER
Table 1- 
Notations Used in CHEER
Fig. 1. - 
CHEER: (a) a rich model was first built using rich multi-modal or multi-channel data; (b) the behaviors of rich model are then infused into the poor model using paired data (i.e., behavior infusion); and (c) the poor model is trained to fit both the rich model’s predictions on paired data and its poor dataset (i.e., target infusion).
Fig. 1.
CHEER: (a) a rich model was first built using rich multi-modal or multi-channel data; (b) the behaviors of rich model are then infused into the poor model using paired data (i.e., behavior infusion); and (c) the poor model is trained to fit both the rich model’s predictions on paired data and its poor dataset (i.e., target infusion).

Show All

3.2 Learning Transferable Rich Model
In our knowledge infusion task, the rich model is assumed to be trained in advance using the rich dataset Hr≜{(xri,yri)}ni=1. The rich dataset is, however, not accessible and we only have access to the rich model. The knowledge infusion task aims to consolidate the knowledge acquired by the rich model and infuse it with a simpler model (i.e., the poor model).

Transferable Representation. To characterize a DL model, we first describe the building blocks and then discuss how they would interact to generate the final prediction scores. In particular, let Qr(xr), Ar(xr) and Or denote the building blocks, namely Feature Extraction, Feature Scoring and Feature Aggregation, respectively. Intuitively, the Feature Extraction first transforms raw input feature xr into a vector of high-level features Qr(xr), whose importance are then scored by the Feature Scoring function Ar(xr). The high-level features Qr(xr) are combined first via a linear transformation Qr(xr)⊤Ar(xr) that focuses the model’s attention on important features. The results are translated into a vector of final predictive probabilities via the Feature Aggregation function Or(Qr(xr)⊤Ar(xr)), which implements a non-linear transformation. Mathematically, the above workflow can be succinctly characterized using the following conditional probability distributions:
T(y | xr)≜Pr(y | Q⊤r(xr)Ar(xr);Or) .(1)
View SourceRight-click on figure for MathML and additional features.We will describe these building blocks in more details next.

Feature Extraction. Dealing with complex input data such as time series, images and text, it is common to derive more effective features instead of directly using the raw input xr. The extracted features are denoted as Qr(xr)≜[q1r(xr)…qlrr(xr)]∈Rd×lr where qir(xr)∈Rd is a d-dimensional feature vector extracted by the ith feature extractor from the raw input xr. Each feature extractor is applied to a separate segment of the time series input (defined later in Section 3.3). To avoid cluttering the notations, we shorten Qr(xr) as Qr.

Feature Scoring. Since the extracted features are of various importance to each subject, they are combined via weights specific to each subject. More formally, the extracted features Qr(xr) of the rich model are combined via Q⊤r(xr)Ar(xr) using subject-specific weight vector Ar(xr)≜[a(1)r(xr)…a(d)r(xr)]∈Rd.

Essentially, each weight component a(i)r(xr) maps from the raw input feature xr to the important score of its ith extracted feature. For each dimension i, a(i)r(xr)≜a(i)r(xr;ω(i)r) parameterized by a set of parameters ω(i)r, which are learned using the rich dataset.

Feature Aggregation. The feature aggregation implements a nonlinear transformation Or (e.g., a feed-forward layer) that maps the combined features into final predictive scores. The input to this component is the linearly combined feature Qr(xr)⊤Ar(xr) and the output is a vector of logistic inputs,
r(xr)  ≜  [r1…rc]  =  Or(Qr(xr)⊤Ar(xr)) ,(2)
View SourceRight-click on figure for MathML and additional features.which is subsequently passed through the softmax function to compute the predictive probability for each candidate label,
T(y=j|xri)≜exp(rj)/(∑κ=1cexp(rκ)) .(3)
View SourceRight-click on figure for MathML and additional features.

3.3 A DNN Implementation of Rich Model
This section describes an instantiation of the aforementioned abstract building blocks using a popular DNN architecture with self-attention mechanism [34] for modeling multivariate time series [35]. Fig. 2 illustrates the DNN implementation.

Raw Features. Raw data from rich data environment often consist of multivariate time series such as physiological signals collected from hospital or temporal event sequences such as electronic health records (EHR) with discrete medical codes. In the following, we consider the raw feature input xri as continuous monitoring data (e.g., blood pressure measures) for illustration purpose.

Feature Extraction. To handle such continuous time series, we extract a set of domain-specific features using CNN and RNN models. More specifically, we splits the raw time series xri into lr non-overlapping segments of equal length.

That is, xri≜(sri,m) where m=1…lr and sri,m∈RDr such that Dr×lr=r with r denotes the number of features of the rich data. Then, we apply stacked 1-D convolutional neural networks (CNNr) with mean pooling (Pr) on each segment, i.e.,
hri,m≜Pr(CNNr(sri,m)),(4)
View SourceRight-click on figure for MathML and additional features.where hri,m∈Rkr, and kr denotes the number of filters of the CNN components of the rich model. After that, we place a recurrent neural network (RNNr) across the output segments of the previous CNN and Pooling layers
qri,m≜RNNr(qri,m−1,hri,m)  ∈  Rd ,(5)
View SourceRight-click on figure for MathML and additional features.The output segments of the RNN layer are then concatenated to generate the feature matrix,
Q(i)r≜[qri,1…qri,lr]  ∈  Rd×lr ,(6)
View Sourcewhich correspond to our domain-specific feature extractors Qr(xri)≜[q1r(xri)…qlrr(xri)] where qtr(xri)=qri,t∈Rd, as defined previously in our transferable representation (Section 3.2).

Feature Scoring. The concatenated features Q(i)r is then fed to the self-attention component ATTr to generate a vector of importance scores for the output components, i.e., a(i)r≜ATTr(Q(i)r)∈Rd. For more details on how to construct this component, see [36], [37], [38] and [34]. The result corresponds to the feature scoring functions2 Ar(xri)≜[a(1)r(xri)…a(d)r(xri)] where a(t)r(xri)=[a(i)r]t∈R.

Feature Aggregation. The extracted features Q(i)r are combined using the above feature scoring functions, which yields Q(i)⊤ra(i)r. The combined features are subsequently passed through a linear layer with densely connected hidden units (DENSEr),
g(i)r≜DENSEr(Q(i)⊤ra(i)r;wr) ,(7)
View SourceRight-click on figure for MathML and additional features.where g(i)r∈Rc with c denotes the number of class labels and wr denotes the parametric weights of the dense layers. Then, the output of the dense layer is transformed into a probability distribution over class labels via the following softmax activation functions parameterized with softmax temperatures τr:
T(y=j|xri)≜exp([g(i)r]j/τr)/∑κ=1cexp([g(i)r]κ/τr).
View SourceThe entire process corresponds to the feature aggregation function Or(Qr(xr)⊤Ar(xr)) parameterized by {wr,τr}.

3.4 Knowledge Infusion for Poor Model
To infuse the above knowledge extracted from the rich model to the poor model, we adopt the same transferable representation for the poor model as follows:
S(y | xp)≜Pr(y | Q⊤p(xp)Ap(xp);Op),
View SourceRight-click on figure for MathML and additional features.where Qp, Ap(xp)≜[a(1)p(xp;ω(1)p)…a(d)p(xp;ω(d)p)]∈Rd and Op are the poor model’s domain-specific feature extractors, feature scoring functions and feature aggregation functions, which are similar in format to those of the rich model. Infusing knowledge from the rich model to the poor model can then be boiled down to matching these components between them. This process can be decomposed into two steps:

Behavior Infusion. As mentioned above, each scoring function a(i)p(xp;ω(i)p) is defined by a weight vector ω(i)p. The collection of these weight vectors thus defines the poor model’s learning behaviors (i.e., its feature scoring mechanism).

Given the input components {(xpt,xrt)}kt=1 of the subjects included in the paired dataset Ho and the rich model’s scoring outputs {a(i)r(xrt)}kt=1 at those subjects, we can construct an auxiliary dataset Bi≜{(xpt,a(i)r(xrt))}kt=1 to learn the corresponding behavior ω(i)p of the poor model so that its scoring mechanism is similar to that of the rich model. That is, we want to learn a mapping from a poor data point xp to the important score assigned to its ith latent feature by the rich model. Formally, this can be cast as the optimization task given by Eq. (8)
minimizeω(i)pLi(ω(i)p)≜12∑t=1k(a(i)p(xpt;ω(i)p)−a(i)r(xrt))2+λ∥ω(i)p∥22.(8)
View SourceRight-click on figure for MathML and additional features.For example, if we parameterize a(i)p(xpt;ω(i)p)=ω(i)⊤pxpt and choose λ=0, then Eq. 8 reduces to a linear regression task, which can be solved analytically. Alternatively, by choosing λ=1, Eq. (8) reduces to a maximum a posterior (MAP) inference task with normal prior imposed on ω(i)p, which is also analytically solvable.

Incorporating more sophisticated, non-linear parameterization for a(i)p(xpt;ω(i)p) (e.g., deep neural network with varying structures) is also possible but Eq. (8) can only be optimized approximately via numerical methods (see Section 3.2). Eq. (8) can be solved via standard gradient descent. The complexity of deriving the solution thus depends on the number of iteration τ and the cost of computing the gradient of ω(i)p which depends on the parameterization of a(i)p but is usually O(w) where w=maxi|ω(i)p|. As such, the cost of computing the gradient of the objective function with respect to a particular i is O(kw). As there are τ iterations, the cost of solving for the optimal ω(i)p is O(τkw). Lastly, since we are doing this for d values of i, the total complexity would be O(τkwd).

Target Infusion. Given the poor model’s learned behaviors {ω(i)p}di=1 (which were fitted to those of the rich model via solving Eq. (8)), we now want to optimize the poor model’s feature aggregation Op and feature extraction Qp components so that its predictions will (a) fit those of the rich model on paired data Ho; and also (b) fit the ground truth {ypt}mt=1 provided by the poor data Hp. Formally, this can be achieved by solving the following optimization task:
minOp,QpLp≜1k∑t=1k∑y=1c(T(yt|xrt;Or,Qr)−S(y|xpt;Op,Qp))2+1m∑t=1m(1−S(ypt|xpt;Op,Qp))2.(9)
View SourceRight-click on figure for MathML and additional features.To understand the above, note that the first term tries to fit poor model S to rich model T in the context of the paired dataset Ho≜{(xpt,xrt,yt)}kt=1 while the second term tries to adjust the poor model’s fitted behavior and target in a local context of its poor data Hp≜{(xpt,ypt)}mt=1. This allows the second term to act as a filter that downplays distilled patterns which are irrelevant in the poor data context. Again, Eq. (9) can be solved depending on how we parameterize the aforementioned components (Op,Qp).

For example, Op can be set as a linear feed-forward layer with densely connected hidden units, which are activated by a softmax function. Again, Eq. (9) could be solved via standard gradient descent. The cost of computing the gradient would depend linearly on the total no. np of neurons in the parameterization of Op and Qp for the poor model. In particular, the gradient computation complexity for one iteration is O(np(mpc+kc2)). For τ iteration, the total cost would be O(τnp(mpc+kc2)).

Both steps of behavior infusion and target infusion are succinctly summarized in Algorithm 1 below.

Algorithm 1. CHEER(Hp, T(y|xr), Ho)
Input: rich model T(y|xr), poor data Hp and paired data Ho

Infuse rich model’s behavior via Ho

i←1

while i≤d do

ω(i)p←argminLi(ω(i)p) via (8);

a(i)p(xp)←a(i)p(xp;ω(i)p)

i←i+1

end while

Ap ← [a(1)p(xp;ω(1)p)…a(d)p(xp;ω(d)p)]

Infuse rich model’s target via (Ho,Hp) and Ap

(Qp,Op) ← argminLp via (9)

Output: poor model S(y|xp)←(Ap,Qp,Op)

SECTION 4Theoretical Analysis
In this section, we provide theoretical analysis for CHEER. Our goal is to show that under certain practical assumptions and with respect to a random instance x=(xp,xr)∼P(x) drawn from an arbitrary data distribution P, the prediction yp≜argmaxS(y|xp) of the resulting poor model will agree with that of the rich model, yr≜argmaxT(y|xr), with high probability, thus demonstrating the accuracy of our knowledge infusion algorithm in Section 3.4.

High-Level Ideas. To achieve this, our strategy is to first bound the expected target fitting loss (see Definition 2) on a random instance x≜(xp,xr)∼P(x) of the poor model with respect to its optimized scoring function Ap, feature extraction Qp and feature aggregation Op components via solving Eqs. (8) and (9) in Section 3.4 (see Lemma 1).

We can then characterize the sufficient condition on the target fitting loss (see Definition 1) with respect to a particular instance x≜(xp,xr) for the poor model to agree with the rich model on their predictions of xp and xr, respectively (see Lemma 2). The probability that this sufficient condition happens can then be bounded in terms of the bound on the expected target fitting loss in Lemma 1 (see Theorem 1), which in turn characterizes how likely the poor model will agree with the rich model on the prediction of a random data instance. To proceed, we put forward the following assumptions and definitions:

4Definition 1.
Let θp≜{Op,Qp,Ap} denote an arbitrary parameterization of the poor model. The particular target fitting loss of the poor model with respect to a data instance x≜(xp,xr) is
Lˆx(θp)≜∑y=1c(T(y|xr)−S(y|xp))2+1m∑t=1m(1−S(ypt|xpt))2 ,(10)
View SourceRight-click on figure for MathML and additional features.where c denotes the number of classes, T(y|xr) and S(y|xp) denotes the probability scores assigned to candidate class y by the rich and poor models, respectively.

4Definition 2.
Let θp be defined as in Definition 1. The expected target fitting loss of the poor model with respect to the parameterization θp is defined below,
L(θp)≜Ex∼P(x)[Lˆx(θp)] ,(11)
View Sourcewhere the expectation is over the unknown data distribution P(x).

4Definition 3.
Let x=(xp,xr) and y(x)≜argmaxcy=1T(y|xr). The robustness constant of the rich model is defined below,
ϕ≜12min(xp,xr)(T(y(x) | xr)−maxy≠y(x)T(y | xr)) ,(12)
View SourceRight-click on figure for MathML and additional features.That is, if the probability scores of the model are being perturbed additively within ϕ, its prediction outcome will not change.

4Assumption 1.
The paired data points xi=(xpi,xri) of Ho are assumed to be distributed independently and identically from P(x).

4Assumption 2.
The hard-label predictions yp≜argmaxS(y|xp) and yr≜argmaxT(y|xr) of the poor and rich models are unique.

Given the above, we are now ready to state our first result:

4Lemma 1.
Let θ∗p and θˆp denote the optimal parameterization of the poor model that yields the minimum expected target fitting loss (see Definition 2) and the optimal solution found by minimizing the objective functions in Eqs. (8) and (9), respectively. Let α≜L(θ∗p), δ∈(0,1) and c denote the number of classes in our predictive task. If k≜|Ho|≥((c+1)2/(2ϵ2))log(2/δ) then,
Pr(L(θˆp) ≤ α + 2ϵ)≥1−δ .(13)
View SourceRight-click on figure for MathML and additional features.

4Proof.
We first note that by definition in Eq. (10), for all x, Lˆx(θ)≤c+1. Then, let us define the empirical target fitting loss as
Lˆ(θ)≜1k∑i=1kLˆx(i)(θ) ,(14)
View Sourcewhere {Lˆx(i)(θ)}ki=1 can be treated as identically and independently distributed random variables in (0,c+1). Then, by Definition 2, it also follows that L(θ)=E[Lˆ(θ)]. Thus, by Hoeffding inequality
Pr(∣∣L(θ)−Lˆ(θ)∣∣≤ϵ)≥1−2exp(−2kϵ2(c+1)2).(15)
View SourceThen, for an arbitrary δ∈(0,1), setting δ≤exp(−2kϵ2/(c+1)2) and solving for k yields k≥((c+1)2/(2ϵ2))log(2/δ). Thus, for k≥((c+1)2/(2ϵ2))log(2/δ), with probability at least 1−δ, |L(θ)−Lˆ(θ)|≤ϵ holds simultaneously for all θ. When that happens with probability at least 1−δ, we have
L(θˆp)≤Lˆ(θˆp)+ϵ≤Lˆ(θ∗p)+ϵ ≤ L(θ∗p)+2ϵ=α+2ϵ .(16)
View SourceThat is, Pr(Lˆ(θˆp)≤α+2ϵ) ≥ 1−δ, which completes our proof for Lemma 1. Note that the above 2nd inequality follows from the definition of θˆp≜argminθLˆ(θp), which implies Lˆ(θˆp)≤Lˆ(θ∗p). This result implies the expected target fitting loss L(θˆp) incurred by our knowledge infusion algorithm in Section 3.4 can be made arbitrarily close (with high confidence) to the optimal expected target fitting loss α≜L(θ∗p) with a sufficiently large paired dataset Ho.

4Lemma 2.
Let x=(xp,xr) and θˆp as defined in Lemma 1. If the corresponding particular target fitting loss (see Definition 1) Lˆx(θˆp)≤ϕ2, then both poor and rich models agree on their predictions for xp and xr, respectively. That is, yp≜maxyS(y|xp) and yr≜maxyT(y|xr) are the same.

4Proof.
Let yp and yr be defined as in the statement of Lemma 2. We have
S(yp | xp)≥S(yr | xp)  ≥  T(yr | xr)−ϕ≥T(yp | xr)+2ϕ−ϕ≥S(yp | xp)+2ϕ−2ϕ  =  S(yp | xp).(17)
View Source

To understand Eq. (17), note that the first inequality follows from the definition of yp. The second inequality follows from the fact that Lˆx(θˆp)≤ϕ2, which implies ∀y (S(y|xp)−T(y|xr))2≤ϕ2 and hence, |S(yr|xp)−T(yr|xr)|≤ϕ or S(yr|xp)≥T(yr|xr)−ϕ. The third inequality follows from the definitions of ϕ (see Definition 3) and yr. Finally, the last inequality follows from the definition of yp and that Lˆx(θˆp)≤ϕ2, which also implies T(yp|xr)≥S(yp|xp)−ϕ.

Eq. (17) thus implies S(yp|xp)≥S(yr|xp)≥S(yp|xp) and hence, S(yp|xp)=S(yr|yp). Since the hard-label prediction is unique (see Assumption 3), this means yr=yp and hence, by definitions of yr and yp, the poor and rich models yiezx ld the same prediction. This completes our proof for Lemma 2.

Intuitively, Lemma 2 specifies the sufficient condition under which the poor model will yield the same hard-label prediction on a particular data instance x as the rich model. Thus, if we know how likely this sufficient condition will happen, we will also know how likely the poor model will imitate the rich model successfully on a random data instance. This intuition is the key result of our theoretical analysis and is formalized below:

4Theorem 1.
Let δ∈(0,1) and x=(xp,xr) denote a random instance drawn from P(x). Let k≜|Ho| denote the size of the paired dataset Ho, which were used to fit the learning behaviors of the poor model to that of the rich model, and E denotes the event that both models agree on their predictions of x. If k≥((c+1)2/(2ϵ2))log(2/δ), then with probability at least 1−δ,
Pr(E)≥1−1ϕ2(α+2ϵ) .(18)
View SourceRight-click on figure for MathML and additional features.

4Proof.
Since Lˆx(θˆp)≤ϕ2 implies E, it follows that
Pr(E)≥Pr(Lˆx(θˆp)≤ϕ2) .(19)
View SourceRight-click on figure for MathML and additional features.

Then, by Markov inequality, we have
Pr(Lˆx(θˆp)>ϕ2)≤ϕ−2E[Lˆx(θˆp)]=ϕ−2L(θˆp) .(20)
View SourceSubtracting both sides of Eq. (20) from a unit probability yields
Pr(Lˆx(θˆp)≤ϕ2)≥1 − ϕ−2L(θˆp) ,(21)
View SourceRight-click on figure for MathML and additional features.where the last equality follows because E[Lˆx(θˆp)]=L(θˆp), which follows immediately from Definitions 1 and 2 and Assumption 1. Thus, plugging Eqs. (21) into (19) yields
Pr(E)≥1 − ϕ−2L(θˆp) .(22)
View SourceRight-click on figure for MathML and additional features.Applying Lemma 2, we know that with probability 1−δ, L(θˆp)≤α+2ϵ. Thus, plugging this into Eq. (22) yields
Pr(E)≥1 − ϕ−2(α+2ϵ) .(23)
View SourceRight-click on figure for MathML and additional features.That is, by union bound, with probability at least 1−δ−ϕ−2(α+2ϵ), the poor model yields the same prediction as that of the rich model. This completes our proof for Theorem 1.

This immediately implies E will happen with probability at least 1−δ−(1/ϕ2)(α+2ϵ). The chance for the poor model to yield the same prediction as the rich model on an arbitrary instance (i.e., knowledge infusion succeeds) is therefore at least 1−δ−(1/ϕ2)(α+2ϵ).

SECTION 5Experiments
5.1 Experimental Settings
Datasets. We use the following datasets in our evaluation. The data statistics are summarized in Table 2.

A. MIMIC-III Critical Care Database (MIMIC-III)3 is collected from more than 58,000 ICU patients at the Beth Israel Deaconess Medical Center (BIDMC) from June 2001 to October 2012 [39]. We collect a subset of 9,488 patients who has one of the following (most frequent) diseases in their main diagnosis: (1) acute myocardial infarction, (2) chronic ischemic heart disease, (3) heart failure, (4) intracerebral hemorrhage, (5) specified procedures complications, (6) lung diseases, (7) endocardium diseases, and (8) septicaemia. The task is disease diagnosis classification (i.e., predicting which of 8 diseases the patient has) based on features collected from 6 data channels: vital sign time series including Heart Rate (HR), Respiratory Rate (RR), Blood Pressure mean (BPm), Blood Pressure systolic (BPs), Blood Pressure diastolic (BPd) and Blood Oxygen Saturation (SpO2). We randomly divided the data into training (80 percent), validation (10 percent) and testing (10 percent) sets.

B. PTB Diagnostic ECG Database (PTBDB)4 is a 15-channel 1,000 Hz ECG time series including 12 conventional leads and 3 Frank leads [40], [41] collected from both healthy controls and cases of heart diseases, which amounts to a total number of 549 records. The given task is to classify ECG to one of the following categories: (1) myocardial infarction, (2) healthy control, (3) heart failure, (4) bundle branch block, (5) dysrhythmia, and (6) hypertrophy. We down-sampled the data to 200 Hz and pre-processed it following the “frame-by-frame” method [42] with sliding windows of 10-second duration and 5-second stepping between adjacent windows.

C. NEDC TUH EEG Artifact Corpus (EEG)5 is a 22-channel 500 Hz sensor time series collected from over 30,000 EEGs spanning the years from 2002 to present [43]. The task is to classify 5 types of EEG events including (1) eye movements (EYEM), (2) chewing (CHEW), (3) shivering (SHIV), (4) electrode pop, electrode static, and lead artifacts (ELPP), and (5) muscle artifacts (MUSC). We randomly divided the data into training (80 percent), validation (10 percent) and testing (10 percent) sets by records.

The statistics of the above datasets, as well as the architectures of the rich and poor models on each dataset are summarized in the tables below.

Baselines. We compare CHEER against the following baselines and also summarize them in Table 3–8.

Direct. In all experiments, we train a neural network model parameterized with CHEER directly on the poor dataset without knowledge infusion from the rich model. The resulting model can be used to produce a lower bound of predictive performance on each dataset.

Knowledge Distilling (KD) [13]. KD transfers predictive power from teacher to student models via soft labels produced by the teacher model. In our experiments, all KD models have similar complexity as the infused model generated by CHEER. The degree of label softness (i.e., the temperature parameter of soft-max activation function) in KD is set to 5.

Attention Transfer (AT) [11]. AT enhances shallow neural networks by leveraging attention mechanism [12] to learn a similar attention behavior of a full-fledged deep neural network (DNN). In our experiments, we first train a DNN with attention component, which can be parameterized by CHEER. The trained attention component of DNN is then transferred to that of a shallow neural networks in poor-data environment via activation-based attention transfer with L2-normalization.

Heterogeneous Domain Adaptation (HDA) [26]. Maximize Mean Discrepancy (MMD) loss [44] has been successfully used in domain adaptation such as [7]. However, one drawback is that these works only consider homogeneous settings where the source and target domains have the same feature space, or use the same architecture of neural network. To mitigate this limitation, HDA [26] proposed modification of soft MMD loss to handle with heterogeneity between source domain and target domain.

Performance Metrics. The tested methods’ prediction performance was compared based on their corresponding areas under the Precision-Recall (PR-AUC) and Receiver Operating Characteristic curves (ROC-AUC) as well as the accuracy and F1 score, which are often used in multi-class classification to evaluate the tested method’s prediction quality. In particular, accuracy is measured by the ratio between the number of correctly classified instances and the total number of test instances. F1 score is the harmonic average of precision (the proportion of true positive cases among the predicted positive cases) and recall (the proportion of positive cases whose are correctly identified), with threshold 0.5 to determine whether a predictive probability for being positive is large enough (larger than threshold) to actually assign a positive label to the case being considered or not.

Then, we use the average of F1 scores evaluated for each label (i.e., macro-F1 score) to summarize the averaged predictive performance of all tested methods across all classes. The ROC-AUC and PR-AUC scores are computed based on predicted probabilities and ground-truths directly. For ROC-AUC, it is the area under the curve produced by points of true positive rate (TPR) and false positive rate (FPR) at various threshold settings. Likewise, the PR-AUC score is the area under the curve produced by points of (precision, recall) at various threshold settings. In our experiments, we report the average PR-AUC and ROC-AUC since all three tasks are multi-class classification.

Training Details.

For each method, the reported results (mean performance and its empirical standard deviation) are averaged over 20 independent runs. For each run, we randomly split the entire dataset into training (80 percent), validation (10 percent) and test sets (10 percent). All models are built using the training and validation sets and then, evaluated using test set. We use Adam optimizer [45] to train each model, with the default learning rate set to 0.001. The number of training epoches for each model is set as 200 and an early stopping criterion is invoked if the performance does not improve in 20 epoches. All models are implemented in Keras with Tensorflow backend and tested on a system equipped with 64 GB RAM, 12 Intel Core i7-6850K 3.60 GHz CPUs and Nvidia GeForce GTX 1080. For fair comparison, we use the same model architecture and hyper-parameter setting for Direct, KD, AT, HDA and CHEER. For rich dataset, we use the entire amount of dataset with the entire set of data features. For poor dataset, we vary the size of paired dataset and the number of features to analyze the effect of knowledge infusion in different data settings as shown in Section 4.3. The default maximum amount of paired data is set to 50 percent of entire dataset, and the default number of data features used in the poor dataset is set to be half of the entire set of data features. In Section 4.2, to compare the tested methods’ knowledge infusion performance under different data settings, we use the default settings for all models (including CHEER and other baselines).

5.2 Performance Comparison
Results on MIMIC-III, PTBDB and EEG datasets are reported in Tables 9, 10 and 11, respectively. In this experiment, we set the size of paired dataset to 50 percent of the size of the rich data, and set the number of features used in poor-data environment to 3, 7, 11 for MIMIC-III, PTBDB and EEG, respectively. In all datasets, it can be observed that the infused model generated by CHEER consistently achieves the best predictive performance among those of the tested methods, which demonstrates the advantage of our knowledge infusion framework over existing transfer methods such as KD and AT.

TABLE 2 Data Statistics
Table 2- 
Data Statistics
TABLE 3 The Architecture of Rich Model in MIMIC-III, Which Includes a Total of 51.6k Parameters
Table 3- 
The Architecture of Rich Model in MIMIC-III, Which Includes a Total of 51.6k Parameters
TABLE 4 The Architecture of the Infused, Poor Model Used by CHEER, Direct, KD and AT for Knowledge Infusion in MIMIC-III, Which Includes a Total of 3.5k Parameters

TABLE 5 The Architecture of Rich Model in PTBDB, Which Includes a Total of 688.8k Parameters

TABLE 6 The Architecture of the Infused, Poor Model Used by CHEER, Direct, KD and AT for Knowledge Infusion in PTBDB, Which Includes a Total 45.0k Parameters
Table 6- 
The Architecture of the Infused, Poor Model Used by CHEER, Direct, KD and AT for Knowledge Infusion in PTBDB, Which Includes a Total 45.0k Parameters
TABLE 7 The Architecture of Rich Model in EEG, Which Includes a Total of 417.4k Parameters
Table 7- 
The Architecture of Rich Model in EEG, Which Includes a Total of 417.4k Parameters
TABLE 8 The Architecture of the Infused, Poor Model Used by CHEER, Direct, KD and AT for Knowledge Infusion in EEG, Which Includes a Total of 51.6k Parameters

TABLE 9 Performance Comparison on MIMIC-III Dataset
Table 9- 
Performance Comparison on MIMIC-III Dataset
TABLE 10 Performance Comparison on PTBDB Dataset
Table 10- 
Performance Comparison on PTBDB Dataset
TABLE 11 Performance Comparison on EEG Dataset

Notably, in terms of the macro-F1 scores, CHEER improves over KD, AT, HDA and Direct by 5.60, 23.95, 31.84 and 46.80 percent, respectively, on MIMIC-III dataset. The infused model generated by CHEER also achieves 81.69 percent performance of the rich model on PTBDB in terms of the macro-F1 score (i.e., 0.299/0.366, see Table 10) while adopting an architecture that is 15.14 times smaller than the rich model’s (see Tables 5 and 6). We have also performed a significance test to validate the significance of our reported improvement of CHEER over the baselines in Table 12.

TABLE 12 The pp-Values of Corresponding tt-Tests (on One-Tail) for Every Two Samples of ROC-AUC Scores of CHEER and a Tested Benchmark (i.e., Direct, KD, AT and HDA) on MIMIC-III, PTBDB and EEG Datasets, Respectively
Table 12- 
The $p$p-Values of Corresponding $t$t-Tests (on One-Tail) for Every Two Samples of ROC-AUC Scores of CHEER and a Tested Benchmark (i.e., Direct, KD, AT and HDA) on MIMIC-III, PTBDB and EEG Datasets, Respectively
Furthermore, it can also be observed that the performance variance of the infused model generated by CHEER (as reflected in the reported standard deviation) is the lowest among all tested methods’, which suggests that CHEER’s knowledge infusion is more robust. Our investigation in Section 5.3 further shows that this is the result of CHEER being able to perform both target and behavior infusion. This helps the infused model generated by CHEER achieved better and more stable performance than those of KD, HDA and AT, which either match the prediction target or reasoning behavior of the rich and poor models (but not both). This consequently leads to their less robust performance with wide fluctuation in different data settings, as demonstrated next in Section 5.3.

5.3 Analyzing Knowledge Infusion Effect in Different Data Settings
To further analyze the advantages of CHEER’s knowledge infusion over those of the existing works (e.g., KD and AT), we perform additional experiments to examine how the variations in (1) sizes of the paired dataset and (2) the number of features of the poor dataset will affect the infused model’s performance. The results are shown in Figs. 3 and 4, respectively. In particular, Fig. 3 shows how the ROC-AUC of the infused model generated by each tested method varies when we increase the ratio between the size of the paired dataset and that of the rich data. Fig. 4, on the other hand, shows how the infused model’s ROC-AUC varies when we increase the number of features of the poor dataset. In both settings, the reported performance of all methods is averaged over 10 independent runs.

Fig. 2. - 
The DNN Implementation of CHEER.
Fig. 2.
The DNN Implementation of CHEER.

Show All


Fig. 3.
Graphs of achieved ROC-AUC scores on (a) MIMIC-III, (b) PTBDB and (c) EEG of the infused models generated by Direct, KD, AT, HDA and CHEER with different sizes of the paired datasets. The X-axis shows the ratio between the size of the paired dataset and that of the rich dataset.

Show All


Fig. 4.
Graphs of achieved ROC-AUC scores on (a) MIMIC-III, (b) PTBDB and (c) EEG of the infused models generated by Direct, KD, AT, HDA and CHEER with different number of data channels (i.e., features) included in the poor dataset. Notice that all method use the same set of selected features for each run.

Show All

Varying Paired Data. Fig. 3 shows that (a) CHEER outperforms all baselines with varying sizes of the paired data and (b) direct learning on poor data yields significantly worse performance across all settings. Both of which are consistent with our observations earlier on the superior knowledge infusion performance of CHEER. The infused models generated by KD, HDA and AT both perform consistently worse than that of CHEER by a substantial margin across all datasets. Their performance also fluctuates over a much wider range (especially on EEG data) than that of CHEER when we vary the size of the paired datasets. This shows that CHEER’s knowledge infusion is more data efficient and robust under different data settings.

On another note, we also notice that when the amount of paired data increases from 20 to 30 percent of the rich data, there is a performance drop that happens to all tested methods with attention transfer (i.e., CHEER and AT) on MIMIC-III but not on PTBDB and EEG. This is, however, not surprising since unlike PTBDB and EEG, MIMIC-III comprises of more heterogeneous types of signals and its data distribution is also more unbalanced, which affects the attention learning, and causes similar performance drop patterns between methods with attention transfer such as CHEER and AT.

Varying The Number of Features. Fig. 4 shows how the prediction performance of the infused models generated by tested methods changes as we vary the number of features in poor data. In particular, it can be observed that the performance of CHEER’s infused model on all datasets increases steadily as we increase the number of input features observed by the poor model, which is expected.

On the other hand, it is perhaps surprising that as the number of features increases, the performance of KD, HDA, AT and Direct fluctuates more widely on PTBDB and EEG datasets, which is in contrast to our observation of CHEER. This is, however, not unexpected since the informativeness of different features are different and hence, to utilize and combine them effectively, we need an accurate feature weighting/scoring mechanism. This is not possible in the cases of Direct, KD, HDA and AT because (a) Direct completely lacks knowledge infusion from the rich model, (b) KD and HDA only performs target transfer from the rich to poor model, and ignores the weighting/scoring mechanism, and (c) AT only transfers the scoring mechanism to the poor model (i.e., attention transfer) but not the feature aggregation mechanism, which is also necessary to combine the weighted features correctly. In contrast, CHEER transfers both the weighting/scoring (via behavior infusion) and feature aggregation (via target infusion) mechanisms, thus performs more robustly and is able to produce steady gain (without radical fluctuations) in term of performance when the number of features increases. This supports our observations earlier regarding the lowest performance variance achieved by the infused model of CHEER, which also suggests that CHEER’s knowledge infusion scheme is more robust than those of KD, HDA and AT.

Finally, to demonstrate how the performance of CHEER varies with different choices of feature sets for poor data, we computed the mutual information between each feature and the class label, and then ranked them in decreasing order. The performance of CHEER on all datasets is then reported in two cases, which include (a) K features with highest mutual information, and (b) K features with lowest mutual information. In particular, the reported results (see Table 13) show that a feature set with low mutual information to the class label will induce worse transfer performance and conversely, a feature set (with the same number of features) with high mutual information will likely improve the transfer performance.

TABLE 13 CHEER’s Performance on MIMIC-III, PTBDB and EEG With (Left-Column) KK Features With Highest Mutual Information (MI) to the Class Label as Features of the Poor Dataset; and (Right-Column) KK Features With Lowest Mutual Information to the Class Label as Features of the Poor Dataset
Table 13- 
CHEER’s Performance on MIMIC-III, PTBDB and EEG With (Left-Column) $K$K Features With Highest Mutual Information (MI) to the Class Label as Features of the Poor Dataset; and (Right-Column) $K$K Features With Lowest Mutual Information to the Class Label as Features of the Poor Dataset
To further inspect the effects of used modalities in CHEER, we also computed the averaged entropy of each modality across all classes, and ranked them in decreasing order for each dataset. Then, we selected a small number of top-ranked, middle-ranked and bottom-ranked features from the entire set of modalities. These are marked as Top, Middle and Bottom respectively in Table 14.

TABLE 14 CHEER’s Performance Using Different Sets of Data Features With Different Information Quality (as Measured by Their Entropy Scores)

The number of selected features for each rank is 2, 4 and 5 for MIMIC-III, PTBDB and EEG, respectively. Finally, we report the ROC-AUC scores achieved by the corresponding infused models generated by CHEER for each of those feature settings in Table 14. It can be observed from this table that the ROC-AUC of the infused model degrades consistently across all datasets when we change the features of poor data from those in Top to Middle and then to Bottom. This verifies our statement earlier that the informativeness of different data features are different.

SECTION 6Conclusion
This paper develops a knowledge infusion framework (named CHEER) that helps infuse knowledge acquired by a rich model trained on feature-rich data with a poor model which only has access to feature-poor data. The developed framework leverages a new model representation to re-parameterize the rich model and consequently, consolidate its learning behaviors into succinct summaries that can be infused efficiently with the poor model to improve its performance. To demonstrate the efficiency of CHEER, we evaluated CHEER on multiple real-world datasets, which show very promising results. We also develop a formal theoretical analysis to guarantee the performance of CHEER under practical assumptions. Future extensions of CHEER includes the following potential settings: incorporating meta/contextual information as part of the features and/or learning from data with missing labels.