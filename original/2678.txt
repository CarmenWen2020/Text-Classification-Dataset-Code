The social presence theory in social psychology suggests that computer-mediated online interactions are inferior to face-to-face, in-person interactions. Thus, it's important to organize social activities for online social network users to meet in person. In this paper, we consider the scenarios of organizing in person friend-making social activities via online social networks (OSNs) and formulate a new research problem, namely, Hop-bounded Maximum Group Friending (HMGF) , that takes into consideration both existing friendships and the likelihood of new friend making in organization of the targeted in person friend-making social activities. To find a set of attendees for such social activities, HMGF is unique and challenging due to the interplay of the group size, the constraint on existing friendships, and the objective of maximizing the likelihood of friend making. We prove that HMGF is NP-Hard, and there exists no approximation algorithm for it unless P=NP . We also provide an Integer Linear Programming (ILP) formulation for the HMGF problem. The ILP formulation, which can be solved efficiently by a commercial solver to obtain the optimal solution for small HMGF instances, acts as a baseline approach for comparison in the evaluation of the proposed algorithm. We further propose an error-bounded approximation algorithm, MaxGF , to efficiently obtain the solutions very close to the optimal solutions. To boost the performance, we devise two graph-theoretical pruning strategies, namely Neighbor Pruning and Core Pruning , which can effectively avoid redundant graph explorations to improve the performance of HMGF. We also study HMGF on a class of special graphs, threshold graphs , which have properties very similar to many online social networks. We prove that MaxGF can obtain the optimal solution to HMGF on threshold graphs in polynomial time. We conduct a user study to validate our problem formulation and perform extensive experiments on real datasets to demonstrate the efficiency and effectiveness of our proposed algorithm. The experimental results manifest that our proposed algorithms outperform the baselines, including the ILP formulation.
SECTION 1Introduction
With the wide popularity and accessibility of online social networks (OSNs), e.g., Facebook, Meetup, and Skout,1 more and more people initiate friend gatherings or group activities via these OSNs. For example, more than 16 million events are created on Facebook each month to organize various kinds of activities,2 while more than 500 thousand face-to-face activities are initiated in Meetup.3 Those activities are organized for a great variety of purposes, e.g., friend gatherings, cocktail parties, concerts, and marathon events, showing the wide use of OSNs as a convenient means for initiating real-life activities among friends. However, the activity organization services in the aforementioned OSNs only consider the current friendships existing in the OSNs.

To help users expand their circles of friends in cyberspace, friend recommendation services have been deployed in OSNs to suggest potential friends to users. Many friend recommendation services employ link prediction algorithms, e.g., [18], [19], to analyze the features, similarity or interaction patterns of users in order to infer potential future friendships between users. By leveraging the rich information in OSNs, link prediction algorithms show high accuracy for recommending online friends in OSNs.

As social presence theory [24] in social psychology suggests, nevertheless, computer-mediated online interactions are inferior to face-to-face, in-person interactions, i.e., off-line friend-making activities are usually more preferred to their on-line counterparts in cyberspace. Therefore, in this paper, we consider the scenarios of organizing offline, face-to-face friend-making activities via OSN services, e.g., organizing groups for excursion in conferences, inviting attendees to housewarming parties, etc. It is widely believed that finding socially cohesive groups of participants is essential for maintaining a warm atmosphere during the activities. However, finding sufficient friend candidates is also very important for a successful friend-making activity. Notice that there is a gap between existing activity organization approaches and friend recommendation services in OSNs for the scenarios under consideration. Existing activity organization approaches mostly focus on extracting socially cohesive groups from OSNs based on certain cohesive measures (e.g., density, diameter) of social networks with different constraints (e.g., time, spatial distance, and interests) on the participants [5], [6], [7], [8]. On the other hand, friend recommendation schemes, e.g., [18], [19], mostly aim to recommend potential new friends for each individual, instead of finding a group of people for friend making. We argue that in addition to themes of common interests, it is desirable to organize friend-making activities by mixing the potential friends, who may be interested in getting acquainted with each other (as indicated by a link prediction algorithm), and existing friends (as lubricators). To the best knowledge of the authors, the following two important factors, 1) the existing friendships among attendees, and 2) the potential friendships among attendees, have not been considered simultaneously in existing activity organization services. To bridge the gap, a new activity organization service that takes into account these two factors is desirable.

In this paper, we investigate the problem of selecting a set of candidate attendees from an OSN for a friend-making activity by considering both the existing and potential friendships among the attendees. Specifically, we model the OSN as a heterogeneous social graph G=(V,E,R), where V is the set of individuals, E is the set of friend edges, and R is the set of weighted potential friend edges (or potential edges for short). Here a friend edge (u,v) (which is unweighted) denotes that individuals u and v are mutual friends, while a potential edge [u′,v′] indicates that individuals u′ and v′ are likely to become friends, whereas the edge weight w[u′,v′] (where w:R→(0,1]) quantifies the likelihood.4

We formulate a new research problem, namely Hop-bounded Maximum Group Friending (HMGF), to find a group with tight social relationships among existing friends and potential friends (i.e., who are not friends yet). Given the heterogeneous social graph G=(V,E,R) as described above, HMGF finds a friend-making group that 1) maximizes the likelihood of making new friends among the group, i.e., the group has the highest ratio of the total potential edge weight to the group size, 2) ensures that the social tightness, i.e., hop count on friend edges in G between each pair of individuals is small, and 3) the group contains a sufficient number of participants, because too small a group may not work well for friend-making activities.

Fig. 1 illustrates a heterogeneous social graph G and the interplay of the considered factors in finding the optimal group in G for HMGF. Fig. 1 presents G, where a dashed line, e.g., [a,b] with weight 0.6, is a potential edge and a solid line, e.g., (c,d), is a friend edge. Fig. 1b shows a group H1:{a,e,f,g} with many potential edges and thus a high total weight. However, not all the members of this group have common friends as social lubricators. In contrast, Fig. 1c shows a group H2:{c,d,f,g} tightly connected by friend edges. While H2 may be a good choice for the gathering of close friends, the goal of friend-making is missed. Finally, Fig. 1d shows H3:{d,e,f,g}, which is a better choice than H1 and H2 for friend-making activities because each pair of potential friends in H3 have a common existing friend. Moreover, the average potential edge weight among them is high, indicating members are likely to make new friends.

Fig. 1. - 
Illustrative example.
Fig. 1.
Illustrative example.

Show All

Finding the optimal solution for HMGF is very challenging because there are many important factors to consider, including the hop constraint, group size and the total weight of potential edges in a group. Indeed, we prove that HMGF is NP-Hard and not approximable within any ratio (i.e., there exists no approximation algorithm for HMGF). Moreover, we prove that if the hop constraint can be slightly relaxed to allow a small error, there exists a 3-approximation algorithm for HMGF. Further, that algorithm is able to find the optimal solutions in threshold graphs, which have graph characteristics (e.g., degree distribution, clustering coefficient) very similar to many online social networks [28]. Theoretical analysis and empirical results show that our algorithm can obtain good solutions efficiently.

The contributions made in this study are summarized as follows.

For organization of friend-making activities, we consider both the existing and potential friendships in a heterogeneous social graph and formulate a new problem, namely, Hop-bounded Maximum Group Friending (HMGF), for finding suitable attendees. To our best knowledge, HMGF is the first attempt for activities that considers these two relationships amongst attendees.

We prove that HMGF is NP-Hard, and there exists no approximation algorithm for HMGF unless P=NP. We propose an Integer Linear Programming (ILP) formulation for HMGF. The ILP formulation, which can be solved efficiently with any commercial solver (e.g., IBM CPLEX), serves as a baseline for evaluation of the proposed algorithm.

We then propose a 3-approximation algorithm, called MaxGF, with a guaranteed error bound for solving HMGF efficiently and effectively. We also propose two graph-theoretical pruning strategies, Neighbor Pruning and Core Pruning, to significantly improve the efficiency of HMGF.

We study HMGF on a special graph class, threshold graphs, and show that the proposed MaxGF algorithm is able to obtain the optimal solution for HMGF on threshold graphs in polynomial time.

We conduct a user study of 50 users to validate our argument for considering both existing and potential friendships in activity organization. We also perform extensive experiments on real datasets to evaluate the proposed algorithm. Experimental results manifest that MaxGF obtains solutions very close to the optimal ones very efficiently.

The rest of this paper is organized as follows. Section 2 formulates HMGF and proves it NP-Hard with no approximation algorithm. Section 3 reviews the related work, and Section 4 details the algorithm design. Section 5 introduces the pruning strategies, and Section 6 analyzes the performance of the proposed algorithm on threshold graphs. Section 7 reports a user study and the experimental results. Section 8 concludes this paper.

SECTION 2Problem Formulation
In the following, we first formally formulate the Hop-bounded Maximum Group Friending problem studied in this paper. Additionally, we prove that the proposed HMGF problem is NP-Hard and inapproximable within any factor unless P=NP. Finally, we propose an Integer Linear Programming formulation for HMGF. The ILP formulation can be solved by any commercial solver such as CPLEX [2] to obtain the optimal solution for HMGF and thus serves as a baseline for evaluation of the proposed algorithm.

2.1 Problem Formulation
Based on the heterogeneous social graph described earlier, here we formulate the Hop-bounded Maximum Group Friending problem. Given two individuals u and v, let dEG(u,v) be the shortest path between u and v via friend edges in G. Moreover, given H⊆G, let |H| denote the number of vertices in H. Then, w(H) denotes the total weight of potential edges in H, and average weight, σ(H)=w(H)|H|, is the average weight of the potential edges connected to each individual in H.5 HMGF is formulated as follows.

Problem: Hop-Bounded Maximum Group Friending.

Given: A social network G=(V,E,R), hop constraint h, and size constraint p.

Objective: Find an induced subgraph H⊆G with the maximum σ(H), where |H|≥p and dEG(u,v)≤h,∀u,v∈H.

Efficient processing of HMGF is very challenging to achieve due to the following reasons: 1) The interplay of the total weight w(H) and the size of H. To maximize σ(H), finding a small H may not be a good choice because the number of edges in a small graph tends to be small as well, resulting in a small average weight. On the other hand, finding a large H (which usually has a high w(H)) may not lead to the maximum σ(H), either, because the denominator of the objective function, i.e., |H|, becomes large as well. Therefore, the key is to strike a good balance between the graph size |H| and the total weight w(H). 2) HMGF includes a hop constraint (say h=2) on friend edges to ensure that every pair of individuals is not too distant socially from each other. However, selecting a potential edge [u,v] with a large weight w[u,v] does not necessarily satisfy the hop constraint, i.e., dEG(u,v)>h which is determined based on existing friend edges. In this case, it may not always be a good strategy to prioritize on heavily weighted edges in order to maximize σ(H), especially when u and v do not share a common friend nearby via the friend edges.

In the following, we prove the NP-Hardness and inapproximability of HMGF. As proved in Theorem 1, finding even a feasible solution to HMGF is hard, i.e., extracting a feasible solution to satisfy the constraints of HMGF is NP-Complete, which is proved with a reduction from the well-known NP-Complete Clique problem. In other words, finding a feasible solution to HMGF is NP-Complete. Therefore, approximating HMGF (i.e., finding a feasible solution with a performance guarantee) within polynomial time is not possible unless P=NP, and it is envisaged that no polynomial-time approximation algorithm exists for HMGF.

Theorem 1.
HMGF is NP-Hard and there is no polynomial-time approximation algorithm for HMGF unless P=NP.

Proof.
(NP-Hardness). We prove the NP-Hardness of HMGF with a reduction from the Clique problem (CP), which is an NP-Complete problem. The decision problem of CP is that given a graph Gc (with no isolated vertex) and an integer k, we would like to decide whether there exists a set C⊆Gc consisting of at least k vertices such that each vertex in C is adjacent to each other vertex. Given an instance of CP with the graph Gc=(Vc,Ec) having no isolated vertex and an integer k, we create an instance of HMGF with the input graph G=(V,E,R) by setting: i) V=V1⋃V2, where V1=Vc and vertices in V2 form a one-to-one correspondence to edges in Ec. That is, V2={Ve|e∈Ec}, i.e., for each edge e in Ec, there is exactly one vertex Ve in V2 in correspondence. ii) (u,v)∉E,∀u,v∈V1, i.e., V1 is an independent set on friend edges; (u,v)∈E,∀u,v∈V2, i.e., V2 is a clique on friend edges; (u,ve)∈E for u∈V1, ve∈V2 if and only if e is incident to u. iii) the potential edges in R and the corresponding weights are assigned arbitrarily. Here, without loss of generality, we fix the weight of each potential edge to 0.5. iv) p=k+|Ec|. v) h=2.

Figs. 2a and 2b show an example of Gc and G, respectively. Please note that each vertex in V1 has at least one neighbor in V2 because Gc has no isolated vertex. Since (u,v)∈E,∀u,v∈V2, by construction, it is clear that dEG(u,v)≤2, ∀u∈V1, v∈V2.


Fig. 2.
Example of Gc and G.

Show All

To complete the proof of NP-Hardness, we show that there exists a set C consisting of at least k vertices in Gc such that each vertex in C is adjacent to each other vertex if and only if G contains an induced subgraph H⊆G satisfying |H|≥p and dEG(u,v)≤h,∀u,v∈H (that is, H is a feasible solution of HMGF). We first prove the necessary condition. Suppose that there exists a set C consisting of at least k vertices in Gc such that each vertex in C is adjacent to each other vertex. Let H denote the subgraph of G induced by C⋃V2. Recall that dEG(u,v)≤2 holds for u∈V1, v∈V2. By construction, it is clear |H|≥p and dEG(u,v)≤h,∀u,v∈H. We then prove the sufficient condition. Suppose that G contains an induced subgraph H⊆G satisfying |H|≥p and dEG(u,v)≤h,∀u,v∈H. Since |H|≥p=k+|V2|, |V1⋂H|≥k holds. Thus, dEG(u,v)=2,∀u,v∈V1⋂H, which implies that dEcGc(u,v)=1,∀u,v∈C, where C is the same set of V1⋂H in Gc. Hence there exists a set C consisting of at least k vertices in Gc such that each vertex in C is adjacent to each other vertex. Therefore, HMGF is NP-Hard.

Inapproximability Within Any Factor. If there exists a polynomial-time ρ-approximation algorithm A of HMGF with ρ<∞, then A gives a ρ-approximate solution for the case that the input HMGF instance has a feasible solution, and gives no solution otherwise. Given any instance of CP, this algorithm can solve this instance in polynomial time because any returned feasible solution of HMGF implies TRUE for CP, and no solution implies FALSE for CP. Thus, there is no polynomial-time approximation algorithm for HMGF unless P=NP. The theorem follows.

The above theorem manifests that HMGF has no approximation algorithm. Nevertheless, we later show that HMGF becomes approximable if a small error h is allowed in the hop constraint. More specifically, in Section 4, we propose an error-bounded approximation algorithm for HMGF, which returns a solution H with guaranteed σ(H), while dEG(u,v) for any two vertices u and v in H may exceed h but is always bounded by 2h. Afterward, we present a post-processing procedure to tailor the solution for satisfying the hop constraint.

2.2 Integer Linear Programming Formulation
In this subsection, we propose the Integer Linear Programming formulation for HMGF. The formulation consists of the following decision variables. Specifically, let xi be the binary decision variable indicating whether an individual vi∈V is selected in the solution subgraph H. That is, xi=1 if vi∈H holds, and xi=0 if vi∉H. Then, the hop constraint in HMGF requires that for any pair of individuals vi and vj in H, dEG(vi,vj)≤h holds. In other words, if dEG(vi,vj)>h, vi and vj cannot appear in H at the same time. Therefore, the hop constraint is expressed as follows.
xi+xj≤1,∀vi,vj∈V,dEG(vi,vj)>h.(1)
View SourceRight-click on figure for MathML and additional features.

Furthermore, HMGF requires the selected subgraph H to have at least p individuals, i.e., |H|≥p. Therefore, the size constraint is formulated as follows.
∑vi∈Vxi≥p.(2)
View SourceRight-click on figure for MathML and additional features.

In addition, for each potential edge [vi,vj], we define binary decision variable zij=1 if and only if both endpoints vi and vj are selected in H as follows.
zij≥xi+xj−1,∀[vi,vj]∈R,(3)
View Source
zij≤xi+xj2,∀[vi,vj]∈R.(4)
View Source

In other words, zij=0 if any of vi and vj is not in H. Then, w(H) can be described by ∑[vi,vj]∈Rw[vi,vj]zij, i.e., the sum of all the potential edge weights w[vi,vj] with their two endpoints vi and vj selected in H. Based on the above decision variables, the objective function of HMGF is as follows.
max∑[vi,vj]∈Rw[vi,vj]zij∑∀vi∈Vxi.(5)
View Source

However, Eq. (5) is not linear because the denominator includes decision variable xi. To tackle the above issue, we first introduce a new binary decision variable gn, 1≤n≤|V|, to represent the size of the obtained subgraph H. That is, gn=1 if and only if |H|=n. We derive gn according to the following Size Indication Constraints.
∑n∈[1,|V|]gn=1,(6)
View Source
∑∀vi∈Vxi=∑n∈[1,|V|]n⋅gn.(7)
View Source

The first constraint (Eq. (6)) ensures that there is only one n∈[1,|V|] such that gn=1, and the second constraint (Eq. (7)) enforces n⋅gn=|H|, i.e., gn=1 only when n=|H| holds. Equipped with gn, we derive the objective value σ of HMGF according to the following Fraction Elimination Constraint, which plays the key role to ensure the linearity of HMGF.
σ≤∑[vi,vj]∈Rw[vi,vj]zijn+(1−gn)∑∀[vi,vj]∈Rw[vi,vj], ∀1≤n≤|V|.(8)
View SourceRight-click on figure for MathML and additional features.

For every n∈[1,|V|] in Eq. (8), if gn=1, n corresponds to the size of subgraph H, i.e., n=|H|. In this case, the Right-Hand-Side (RHS) becomes ∑[vi,vj]∈Rw[vi,vj]zij|H|+0, and the equality in the constraint holds in this case because HMGF is a maximization problem. By contrast, if gn=0, Eq. (8) becomes a redundant constraint because it does not impose any stricter restriction on σ. In other words, σ will not be derived by gn with n≠|H|.

Therefore, the ILP formulation for HMGF is formally specified as follows.

Objective Function
maxσ.(9)
View Source

Subject to:

Hop Constraint (Eq. (1)), Size Constraint (Eq. (2)), Quadric Elimination Constraints (Eqs. (3), (4)), Size Indication Constraints (Eqs. (6), (7)), and Fraction Elimination Constraint (Eq. (8)).

In our experiments in Section 7, we solve the above ILP formulation with an IBM CPLEX commercial solver [2] as a baseline approach to evaluate the proposed algorithm.

SECTION 3Related Work
Extracting dense subgraphs or social cohesive groups among social networks is a natural way for selecting a set of close friends for a gathering. Various social cohesive measures have been proposed for finding dense social subgraphs, e.g., diameter [1], density [3], clique and its variations [4]. Although these social cohesive measures cover a wide range of application scenarios, they focus on deriving groups based only on the existing friendships in the social network. In contrast, HMGF studied in this paper aims to find the optimal group by considering both the existing and potential friendships for friend-making activities. Therefore, the existing works mentioned above cannot be directly applied to HMGF.

Research on finding a set of attendees for activities based on the social tightness among existing friends [5], [6], [7], [8] has been reported in the literature. Social-Temporal Group Query [5] checks the available times of attendees to find the social cohesive group with the most suitable activity time. Geo-Social Group Queries [6], [7] extract socially tight groups while considering certain spatial properties. The willingness optimization for social group problem [8] selects a set of attendees for an activity while maximizing their willingness to participate. Although these works find suitable attendees for activities based on existing friendships among the attendees, they ignore the likelihood of making new friends among the attendees. Therefore, these works may not be suitable for socialization activities discussed in this paper.

Community detection methods have been actively studied to extract densely connected subgraphs from social networks for different scenarios [10], [11], [12], [13], [14], [15], [16], [17]. Overlapping community detection identifies communities that can overlap each other, i.e., vertices can belong to different communities [10], [11]. Due to the computation overhead incurred for finding communities in large social networks, effective processing strategies are proposed to enhance the efficiency [13], [14], [15], [16]. By extending the definition of community, Chen and Hero study the problem of deep community detection, which identifies the connected components appearing only when a set of vetices and edges are removed from the graph [17]. The above approaches are able to effectively identify different communities in social networks. However, they consider only the friend edges for communities and thus cannot be used to organize friend-making activities.

Link prediction analyzes the features, similarity, and interaction patterns among individuals in order to recommend possible friends to the users [18], [19], [20], [21], [22]. Current link prediction algorithms are based on different approaches, including graph-topological features, classification models, hierarchical probabilistic models, and linear algebraic methods. These works show good prediction accuracy for friend recommendation in social networks. In this paper, to estimate the likelihood of how individuals may potentially become friends in the future, we employ the above link prediction algorithms for deriving the potential edges among the individuals.

To the best knowledge of the authors, there exists no algorithm for activity organization that considers both the existing friendships and the likelihood of making new friends when selecting activity attendees. HMGF examines the social tightness among existing friends and the likelihood of becoming friends for non-friend attendees. We envisage that our research result can benefit various social network applications for activity organization.

SECTION 4Error-Bounded Approximation Algorithm for HMGF
4.1 Algorithm Description
To tackle HMGF, a naïve approach is to enumerate all possible combinations of vertices so as to find the subgraph H that has the maximum σ(H) while following the hop and group size constraints. However, this approach is computationally intensive and thus not applicable for a large-scale social network. To efficiently answer HMGF, we propose an algorithm, called MaxGF, which is a 3-approximation algorithm with a guaranteed error bound h. MaxGF limits the search space of candidate solutions by dividing the graph into different hop-bounded subgraphs such that their sizes are much smaller than |V|. Then, it iteratively removes improper vertices that are inclined to generate a small σ(H) on the hop-bounded subgraphs. Specifically, we define the incident weight of a vertex v in an induced subgraph H⊆G as τH(v), where τH(v)=∑u∈Hw[v,u], i.e., the incident weight of v is the total weight of the potential edges incident to v in H. By carefully examining the incident weights of the vertices, we remove from the hop-bounded subgraph those vertices that contribute no gain in the objective function. Moreover, we propose an effective pruning strategy for trimming redundant search. Finally, a post-processing procedure is proposed to ensure that the returned solution follows the hop constraint.

In the following, we detail MaxGF (the pseudo code of MaxGF is presented in Algorithm 1). Table 1 summarizes the notations used by MaxGF. To obtain the hop-bounded subgraphs, MaxGF first sorts the vertices in accordance with their incident weights and iteratively selects a vertex v with the maximum incident weight from G as a reference vertex. A hop-bounded subgraph Hv is constructed from v by including every vertex u within h hops from v on the friend edges, i.e., Hv={u|dEG(u,v)≤h}. Notice that, if |Hv|<p, it is not necessary to examine Hv because any subgraph in Hv may not be a feasible solution due to the size constraint.

TABLE 1 Notations used by MaxGF

Algorithm 1. MaxGF
Input: Social graph G=(V,E,R), hop constraint h, and size constraint p

U←G, SAPX←∅

while U≠∅ do

v←argmaxu∈UτG(u), U←U−{v}

let Hv be the induced subgraph of G with vertices as {u|dEG(u,v)≤h}

if |Hv|<p or 12⋅maxu∈HvτHv(u)≤σ(SAPX) then

continue;

let S1←Hv

for i←1 to |Hv| do

v^i←argminu∈SiτSi(u)

Si+1←Si−{v^i}

let S∗v be the Si with the maximum σ(Si) where |Si|≥p

if σ(S∗v)>σ(SAPX) then

SAPX←S∗v

PostProcessing(SAPX)

output SAPX

Additionally, we propose an effective pruning strategy, named Weight Threshold Pruning (WTP), for Hv. Let SAPX denote the best solution obtained so far. If half of the maximum incident weight among the vertices u in Hv, i.e., (1/2)⋅maxu∈HvτHv(u), does not exceed σ(SAPX), there exists no subgraph H in Hv with σ(H) better than σ(SAPX). More specifically, the following Lemma 1 details the proposed Weight Threshold Pruning.

Lemma 1
(Weight Threshold Pruning). If 12⋅maxu∈HvτHv(u)≤σ(SAPX) holds, Hv can be pruned.

Proof.
The average weight σ(H) of any subgraph H⊆Hv must satisfy the following inequality,
σ(H)=∑t∈HτH(t)2|H|≤maxu∈HvτHv(u)⋅|H|2|H|=12⋅maxu∈HvτHv(u).(10)
View SourceTherefore, if 12⋅maxu∈HvτHv(u)≤σ(SAPX) holds, there exists no subgraph in Hv with the average weight greater than σ(SAPX), and Hv can be pruned.

Next, MaxGF starts to find the solution in Hv with the maximized average weight in |Hv| steps. Let Si+1 denote the subgraph after removing a vertex v^i from Si in step i. We initialize S1=Hv. At each step i afterwards, Si+1 is the subgraph Si−{v^i}. In each step i, the vertex with the lowest incident weight in Si is selected as v^i, i.e., v^i=argminu∈SiτSi(u), because excluding the vertices with low incident weights is inclined to increase the average weight of the the remaining subgraph. After v^i and its incident potential edges are removed from Si, the remaining graph is Si+1, which is processed in the next step i+1. The above procedure ends when Si is empty.

To maximize the objective function σ(H)=w(H)|H|, after a hop-bounded subgraph Hv is processed, S∗v is extracted as the subgraph Si with the maximum σ(Si) in Hv where |Si|≥p. If σ(S∗v)>σ(SAPX), we replace SAPX with S∗v. As such, we continue to extract the next vertex v′ and examine the corresponding hop-bounded subgraph Hv′ until all vertices have been examined. Afterward, a post-processing procedure (detailed later) is employed on the best solution obtained in the algorithm, i.e., SAPX, to ensure that the hop constraint is satisfied and to further maximize σ(SAPX). Finally, SAPX is output as the solution.

Running Example of Algorithm MaxGF. Given the input graph G in Fig. 3a with h=2 and p=2, we illustrate MaxGF step by step. In the while-loop at lines 2 to 13 of Algorithm 1, MaxGF first extracts vertex e (line 3), which incurs the maximum incident weight, i.e., τG(e) is maximum among all the vertices. Then, MaxGF extracts the hop-bounded subgraph of e, i.e., He={c,d,e,f,g} (line 4). Fig. 3b shows He. Since |He|=5>2, and 12⋅maxu∈HeτHe(u)>σ(SAPX) (because SAPX=∅ and thus σ(SAPX)=0), the hop-bounded subgraph |He| is not pruned by Weight Threshold Pruning (lines 5). Afterward, MaxGF sets S1={c,d,e,f,g} (i.e., the same as He), as shown in Fig. 3b, and MaxGF enters the for-loop at lines 8 to 10.

Fig. 3. - 
Running example of MaxGF.
Fig. 3.
Running example of MaxGF.

Show All

At the first iteration of the for-loop (i.e., i=1), since τS1(d)=0 and τS1(c)=0, either d or c can be set as vˆ1. Here, without loss of the generality, we assume MaxGF sets vˆ1=d (line 9). Then, MaxGF removes vˆ1 from S1 to generate S2, i.e., S2={c,e,f,g} (line 10), as shown in Fig. 3c. Now, MaxGF enters the second iteration of the for-loop (i.e., i=2), which then identifies vˆ2=c (line 9) and generates S3 by removing vˆ2 from S2, i.e., S3={e,f,g} (line 10), as shown in Fig. 3d. Again, MaxGF enters the third iteration of the for-loop (i.e., i=3) and sets vˆ3=g because τS3(g)=0.15, smaller than τS3(e)=0.17 and τS3(f)=0.16 (line 9). Then, MaxGF removes vˆ3 from S3 to generate S4, where S4={e,f} (line 10), as shown in Fig. 3e. MaxGF continues the 4th and 5th iterations of the for-loop, and generates S5={e} and S6=∅. Afterward, MaxGF sets S∗v=S3={e,f,g} (line 11) because σ(S1)=0.48, σ(S2)=0.6, σ(S3)=0.8, and σ(S4)=0.45, while |S5|<p and |S6|<p. Moreover, since σ(S∗)>σ(SAPX), MaxGF sets SAPX=S∗ (lines 12 to 13). Now, MaxGF has completed processing the hop-bounded graph He. MaxGF enters the second iteration of the while-loop at line 2 to examine the hop-bounded subgraph of f, i.e., Hf. It repeats the above iterations until all the vertices are examined. After the while-loop, MaxGF returns SAPX={e,f,g} with σ(SAPX)=0.8, which is also the optimal solution of this HMGF instance.

4.2 Theoretical Bound
Here we analyze the theoretical bound of MaxGF. Given the hop-bounded subgraph Hv, we first prove that there exists a subgraph F⊆Hv such that 3⋅w(F) is an upper bound of the total potential edge weight for the optimal solution to the HMGF instance on Hv. Then, we prove that for each Hv, the average weight of S∗v obtained in the MaxGF algorithm, i.e., σ(S∗v), is at least 13 the average weight for the optimal solution of HMGF on Hv. Finally, based on the properties of the hop-bounded subgraph and SAPX, we prove that the proposed algorithm is a 3-approximation algorithm with guaranteed error bound to HMGF.

Let SOPTv denote the optimal solution of the HMGF instance on Hv with σ(SOPTv)>0, we first prove that the largest subgraph F in Hv, where τF(u)≥23σ(SOPTv), ∀u∈F, is not an empty graph.

Lemma 2.
The largest subgraph F⊆Hv, where τF(u)≥23σ(SOPTv), ∀u∈F, is not an empty graph.

Proof.
Please refer to Appendix A for the detailed proof, which can be found on the Computer Society Digital Library at http://doi.ieeecomputersociety.org.ezproxy.auckland.ac.nz/10.1109/TKDE.2020.2980516.

With the existence of F proven above, we now derive an upper bound of the total potential edge weight of SOPTv, i.e., w(SOPTv), according to w(F).

Lemma 3.
w(SOPTv) is upper bounded by 3⋅w(F), i.e., 3⋅w(F)>w(SOPTv).

Proof.
Please refer to Appendix B for the detailed proof, available in the online supplemental material.

With the lemmas above, we turn our attention to analyzing MaxGF proposed in Section 4.1. Consider the processing of Hv in MaxGF. When we are iteratively extracting v^i which has the minimum incident weight in Si, if v^i is the first extracted vertex such that v^i∈F (i.e., step i is the earliest step such that v^i∈F), then we have the following lemma.

Lemma 4.
During the processing of Hv in MaxGF, if step i is the earliest step where the extracted v^i from Si is in F, then τSi(u)≥23σ(SOPTv), ∀u∈Si. Moreover, F=Si.

Proof.
If v^i is the first vertex in F selected during the process, F⊆Si holds because in each step j,1≤j≤(i−1), no v^j is in F. Moreover, τF(u)≥23σ(SOPTv), ∀u∈F implies that τF(v^i)≥23σ(SOPTv). Since F⊆Si, τSi(v^i)≥τF(v^i)≥23σ(SOPTv) holds. In addition, v^i is selected to have the minimum τSi(v^i) in Si. Therefore, τSi(u)≥23σ(SOPTv), ∀u∈Si. On the other hand, since F is the largest subgraph in Hv with τF(t)≥23σ(SOPTv), ∀t∈F and τSi(u)≥23σ(SOPTv), ∀u∈Si, this implies Si⊆F. Together with F⊆Si derived earlier, F=Si holds. Moreover, there exists no v^j where j<i such that τSj(v^j)≥23σ(SOPTv). Otherwise, v^j∈F and v^i is not the first extracted vertex in F.

We combine the results obtained above to derive the bound on σ(S∗v), where S∗v is the group Si which has the maximum σ(Si) among all Si with |Si|≥p obtained by MaxGF in Hv.

Theorem 2.
During processing of Hv in MaxGF, let i be the earliest step such that v^i satisfies τSi(v^i)≥23σ(SOPTv), then σ(S∗v)≥13σ(SOPTv).

Proof.
Since τSi(v^i)≥23σ(SOPTv) holds, each u∈Si must have its incident weight τSi(u)≥23σ(SOPTv). Recall that the average weight of Si is σ(Si)=12|Si|∑u∈SiτSi(u). Therefore, σ(Si)≥12|Si|⋅|Si|⋅23σ(SOPTv)=13σ(SOPTv). If |Si|≥p, then σ(S∗v)≥13σ(SOPTv) holds because Si is a candidate of S∗v. If |Si|<p, then there must exist Sj with j<i and |Sj|=p (i.e., Sj is derived earlier than Si, and thus Si⊆Sj). Since Si=F as proved in Lemma 4, and 3⋅w(F)>w(SOPTv), therefore, σ(Sj)=w(Sj)p≥w(Si)p=w(F)p>13⋅pw(SOPTv). Due to |SOPTv|≥p, 13⋅pw(SOPTv)≥13⋅|SOPTv|w(SOPTv)=13σ(SOPTv). Therefore, if |Si|<p, σ(S∗v)≥13σ(SOPTv) also holds because Sj is a candidate of S∗v. The theorem follows.

Finally, let SOPT denote the optimal solution of HMGF on G, the following theorem states that the solution obtained by MaxGF, i.e., SAPX, has σ(SAPX) at least 13⋅σ(SOPT), and the error is bounded by h.

Theorem 3.
MaxGF returns the solution SAPX with σ(SAPX)≥σ(SOPT)3 and dEG(u,v)≤2⋅h, ∀u,v∈SAPX.

Proof.
Let SOPTv be the optimal solution of HMGF on the subgraph Hv⊆G. Then, σ(SOPT)=maxv∈Gσ(SOPTv) holds. Since σ(SAPX)=maxv∈Gσ(S∗v), we have σ(SAPX)≥maxv∈Gσ(SOPTv)3 according to Theorem 2, which implies that σ(SAPX)≥σ(SOPT)3. On the other hand, dEG(u,v) of any two vertices u and v in SAPX may exceed h. Nevertheless, dEG(u,v) is bounded by 2h since the distance from the reference vertex of SAPX to any other vertex is at most h. Therefore, maxu,v∈SAPXdEG(u,v)≤maxt∈Gmaxu,v∈HtdEG(u,v)≤2h. That is, dEG(u,v)≤2⋅h,∀u,v∈SAPX. The theorem follows.

Post-Processing Procedure. More specifically, given SAPX obtained in the algorithm, we first define the notion of boundary vertices. A vertex u in SAPX is a boundary vertex if there exists at least one other vertex v in SAPX such that the shortest path from u to v via friend edges contains more than h edges. Let B denote the set of boundary vertices. MaxGF includes the following adjustment steps in the post-processing procedure. 1) Expand: a vertex v∈(V∖SAPX) can be added into SAPX if adding v does not increase |B| but increases σ(SAPX). We give priority to the vertex v that maximizes σ(SAPX∪{v}). 2) Shrink: given a boundary vertex u∈B, u can be safely removed if after removing u from SAPX, |B| decreases but σ(SAPX) does not. We give priority to the u that maximizes σ(SAPX−{u}). Please note that the above post-processing procedure minimizes maxu,v∈SAPXdEG(u,v) while increasing σ(SAPX). Therefore, after post processing, the performance and error bounds of MaxGF still hold.

Time Complexity. We detail the time complexity analysis in Appendix C, available in the online supplemental material.

SECTION 5Pruning Strategies
In this section, we further improve the efficiency of MaxGF by avoiding the examinations of redundant vertices in the social network. More specifically, we observe that after MaxGF updates the currently best solution SAPX, some hop-bounded subgraphs do not need to be examined because no improved solution can be generated. Therefore, we first design an effective pruning strategy, namely Neighbor Pruning in Section 5.1, which compares SAPX and the total weight of the incident edges of candidate pruned vertices in the hop-bounded subgraphs. Then, we propose a new pruning strategy, called Core Pruning in Section 5.2, to effectively trim off more redundant vertices according to the socially dense structures embedded in each hop-bounded subgraph. We prove that MaxGF with Neighbor Pruning and Core Pruning can still preserve the approximation ratio of HMGF. The experimental results in Section 7 manifest that the two pruning strategies significantly improve the efficiency of MaxGF.

5.1 Neighbor Pruning
Given the hop-bounded subgraph Hv of each vertex v and SAPX (i.e., the best solution obtained so far), Neighbor Pruning carefully examines the total weight of incident potential edges for each vertex in Hv. The corresponding vertex or the whole Hv is removed if it does not lead to an improved solution. More specifically, Neighbor Pruning first derives the incident weight τHv(u) of each vertex u∈Hv, which is the sum of potential edge weights linking from u to its neighbors in Hv. The incident weight of u (i.e., τHv(u)), representing an upper bound of the edge weights that u can contribute, is leveraged for pruning.

Example 1.
Fig. 4 illustrates the idea of Neighbor Pruning with p=4. Fig. 4a shows the initial hop-bounded subgraph Hv for some v∈V, and here only the potential edges are plotted for the clarity of presentation. Notice that Hv in Fig. 4a is not removed by the Weight Threshold Pruning (Lemma 1). However, Neighbor Pruning here truncates vertices {a,e,f} safely (with the reason detailed later) when σ(SAPX)=0.8, as shown in Fig. 4b.


Fig. 4.
Running example of pruning strategies.

Show All

More specifically, let c denote the objective value of the currently best solution, i.e., c=σ(SAPX). Given a hop-bounded subgraph Hv, let C−⊆Hv be the set of vertices in Hv with the incident weights smaller than c, i.e., C−={u|τHv(u)<c,u∈Hv}. In the following, we first explore the case without the size constraint (i.e., p=0) in Section 5.1.1 and show that given any vertex u∈Hv with τHv(u)<c, u can be safely discarded from Hv. Afterward, we study the case with the size constraint (i.e., p>0) in Section 5.1.2. Let H′v denote the remaining subgraph after removing each vertex u with τHv(u)<c, and let wHv(H′v)=12⋅∑u∈H′vτHv(u). We carefully examine three different cases: 1) |H′v|≥p, 2) |H′v|<p and wHv(H′v)|H′v|<12⋅c, and 3) |H′v|<p but wHv(H′v)|H′v|≥12⋅c, to ensure that Neighbor Pruning still preserves the approximation ratio.

Note that Neighbor Pruning can be performed very efficiently because MaxGF has kept track of the incident weight of each vertex in Hv. Therefore, Neighbor Pruning only needs one scan over the vertices in Hv to obtain the set C− and then derive H′v. That is, the time complexity of MaxGF equipped with Neighbor Pruning does not increase.

5.1.1 Neighbor Pruning Without Size Constraint
We first discuss the case without the size constraint, i.e., p=0. Lemma 5 first proves that for any subgraph Q⊆Hv with σ(Q)≥c, combining any subset Cˆ−⊆C− with Q always decreases the average weight, i.e., σ(Q∪Cˆ−)<σ(Q). Then, Lemma 6 further proves that if σ(Q)<c, combining any subset Cˆ−⊆C− with Q does not increase the average weight. With the two lemmas, we conclude that when p=0, vertices in C− are redundant and thus do not need to be examined.

Example 2.
Given Hv in Fig. 4a with p=0 and c=0.8, C−={a,e,f} can be directly trimmed from Hv, as shown in Fig. 4b. Moreover, if c=1.5 and p=0, C−=Hv, i.e., the whole Hv can be safely pruned without examination.

Lemma 5.
Given C−={u|τHv(u)<c,u∈Hv} and any Q⊆Hv with σ(Q)≥c, for every subgraph Cˆ−⊆C−, σ(Q∪Cˆ−)<σ(Q) always holds.

Proof.
We prove the lemma by induction. We first consider the case when adding exactly one vertex u∈C− to Q, i.e., Cˆ−={u}. Then, the reduction of the objective value is
σ(Q)−σ(Q∪{u})=w(Q)|Q|−w(Q∪{u})|Q|+1≥w(Q)|Q|−w(Q)+τHv(u)|Q|+1.(11)
View SourceSince τHv(u)<c, w(Q)|Q|−w(Q)+τHv(u)|Q|+1>w(Q)|Q|−w(Q)+c|Q|+1=w(Q)−c⋅|Q||Q|⋅(|Q|+1). Because σ(Q)≥c, w(Q)≥|Q|⋅c holds. Therefore, σ(Q)−σ(Q∪{u})>0, and this lemma holds when combining exactly one vertex in C− with Q.

Assume that the lemma holds when adding any k vertices in C− to Q. That is, let Cˆ−⊆C− with |Cˆ−|=k and Qˆ=(Q∪Cˆ−). We have σ(Q)>σ(Qˆ). Then, for any vertex u∈(C−∖Qˆ), the following inequality holds:
σ(Qˆ∪{u})≤w(Qˆ)+τHv(u)|Q|+k+1<w(Qˆ)+c|Q|+k+1.(12)
View SourceRight-click on figure for MathML and additional features.Because σ(Qˆ)<σ(Q), w(Qˆ)≤(|Q|+k)⋅w(Q)|Q| holds. Therefore, σ(Qˆ∪{u})<(|Q|+k)⋅w(Q)+|Q|⋅c|Q|⋅(|Q|+k+1). Hence, σ(Q)−σ(Qˆ∪{u})>w(Q)|Q|−(|Q|+k)⋅w(Q)+|Q|⋅c|Q|⋅(|Q|+k+1)=w(Q)−|Q|⋅c|Q|⋅(|Q|+k+1). Since σ(Q)≥c implies w(Q)≥|Q|⋅c, as a result, σ(Q)−σ(Qˆ∪{u})>|Q|⋅c−|Q|⋅c|Q|⋅(|Q|+k+1)=0. The lemma follows.

Lemma 5 indicates that when σ(Q)≥c, adding any subset of C− into Q always decreases the objective value. The following lemma further proves that if σ(Q)<c, σ(Q∪Cˆ−)<c always holds for any Cˆ−⊆C−. That is, there does not exist a subgraph Cˆ−⊆C− such that Q∪Cˆ− outperforms SAPX.

Lemma 6.
Given C−={u|τHv(u)<c,u∈Hv} and any Q⊆Hv with σ(Q)<c, for any subgraph Cˆ−⊆C−, σ(Q∪Cˆ−)<c always holds.

Proof.
We prove the lemma by induction. We first consider the case when adding exactly one vertex u∈C− to Q, i.e., Cˆ−={u}. Then, σ(Q∪{u})=w(Q∪{u})|Q|+1≤w(Q)+τHv(u)|Q|+1<w(Q)+c|Q|+1. Since σ(Q)<c, w(Q)<|Q|⋅c also holds. Therefore, σ(Q∪{u})<|Q|⋅c+c|Q|+1=c.

Assume that the lemma holds when adding any k vertices in C− to Q. That is, let Cˆ−⊆C− with |Cˆ−|=k and Qˆ=(Q∪Cˆ−), σ(Qˆ)<c holds. Then, for any vertex u∈(C−∖Qˆ), σ(Qˆ∪{u})<c holds. We have σ(Qˆ∪{u})≤w(Qˆ)+τHv(u)|Q|+k+1<w(Qˆ)+c|Q|+k+1. Because σ(Qˆ)<c implies that w(Qˆ)<(|Q|+k)⋅c holds, σ(Qˆ∪{u})<(|Q|+k)⋅c+c|Q|+k+1=c. The lemma follows.

Lemmas 5 and 6 indicate that given a hop-bounded subgraph Hv and the currently best solution SAPX with σ(SAPX)=c, any vertex u with τHv(u)<c can be safely removed from the hop-bounded subgraph Hv if the size constraint is not employed, i.e., p=0. However, if p>0, more detailed analyses are required to ensure the solution quality after pruning.

5.1.2 Neighbor Pruning With Size Constraint
In the following, we first define the maximum incident weight of a subgraph Q⊆Hv on a hop-bounded subgraph Hv, i.e., wHv(Q)=12⋅∑u∈QτHv(u). Please note that wHv(Q)≥w(Q) always holds because Q⊆Hv. Specifically, let H′v denote the hop-bounded graph after removing each vertex u with τHv(u)<c from the original Hv, where c=σ(SAPX) is the average weight of the currently best solution SAPX. Then, the following three cases for H′v are considered.

|H′v|≥p. MaxGF starts directly from H′v, instead of Hv, i.e., those vertices u with τHv(u)<c are pruned from Hv (see Lemma 7 below).

|H′v|<p, and wHv(H′v)|H′v|<12⋅c. The whole Hv is pruned (see Lemma 8 below).

|H′v|<p, but wHv(H′v)|H′v|≥12⋅c. In this case, MaxGF starts from the original Hv to find if there is a solution better than SAPX.

The following lemmas prove the first two cases above.

Lemma 7.
If |H′v|≥p, MaxGF starts directly from H′v, instead of Hv, and every vertex u with τHv(u)<c is pruned from Hv.

Proof.
If |H′v|≥p, according to Lemmas 5 and 6, the vertices in C−={u|τHv(u)<c,u∈Hv} are removed from Hv directly to produce H′v because for any Q⊆Hv and any Cˆ−⊆C−, one of the following two cases must hold. 1) σ(Q∪Cˆ−)≤σ(Cˆ−), indicating that for any Q⊆H′v with |Q|≥p, Q outperforms Q∪Cˆ−. 2) σ(Q∪Cˆ−)<c, indicating that for any subgraph Q⊆H′v, adding any subset of Cˆ− into Q does not outperform the currently best solution SAPX.

Lemma 8.
If |H′v|<p, and wHv(H′v)|H′v|<12⋅c, the whole Hv can be truncated because no subgraph Sˆ⊆Hv satisfies σ(Sˆ)≥c.

Proof.
Since |H′v|<p and wHv(H′v)|H′v|<12⋅c, wHv(H′v)<c2⋅|H′v| holds. Let Q denote any subgraph of H′v, i.e., Q⊆H′v, the following inequality shows an upper bound of wHv(Q).
wHv(Q)≤wHv(H′v)<c2⋅|H′v|.(13)
View Source

Let X⊆(Hv∖H′v), i.e., X is a subgraph of C−=(Hv∖H′v) and τHv(u)<c,∀u∈X. Any candidate solution Sˆ⊆Hv that satisfies the size constraint must follow one of the following conditions. 1) Sˆ=(Q∪X) and |Q∪X|≥p. In other words, one part of Sˆ belongs to H′v, whereas the other part is in C−). 2) Sˆ=X and |X|≥p. Because σ(X)<c for any X⊆(Hv∖H′v), it is only necessary to explore the first case.

For the first case, w(Q∪X)≤wHv(Q∪X)=wHv(Q)+wHv(X) holds because Q∩X=∅, and we have the following equation.
wHv(Q∪X)=12⋅∑u∈(Q∪X)τHv(u)=12⋅(∑u∈QτHv(u)+∑t∈XτHv(t))=wHv(Q)+wHv(X).(14)
View SourceRight-click on figure for MathML and additional features.

Therefore, the upper bound of the average weight of (Q∪X), i.e., σ(Q∪X) can be derived as follows.
σ(Q∪X)=w(Q∪X)|Q∪X|≤wHv(Q)+wHv(X)|Q∪X|.(15)
View SourceRight-click on figure for MathML and additional features.

According to Eq. (13), we have wHv(Q)<c2⋅|H′v|. Moreover, wHv(X)≤12⋅∑u∈XτHv(u)<12⋅c⋅|X| because τHv(u)<c,∀u∈X. Therefore, σ(Q∪X)<c2⋅|H′v|+c2⋅|X||Q|+|X| holds (recall that Q∩X=∅, leading to |Q∪X|=|Q|+|X|). Note that |H′v|<p≤(|Q|+|X|), and thus the following inequality holds.
σ(Q∪X)<c2⋅(|Q|+|X|)+c2⋅|X||Q|+|X|<c2⋅(|Q|+|X|)+c2⋅(|Q|+|X|)|Q|+|X|=c.(16)
View Source

Therefore, if |H′v|<p and wHv(H′v)|H′v|<12⋅c, the whole Hv is trimmed because there exists no subgraph Sˆ⊆Hv satisfying σ(Sˆ)≥c. The lemma follows.

Given the currently best solution SAPX with c=σ(SAPX) and a hop-bounded subgraph Hv, let H′v be the hop-bounded subgraph after removing each vertex u with τHv(u)<c from the original Hv. The following theorem proves that Neighbor Pruning preserves the approximation ratio of MaxGF.

Theorem 4.
(Neighbor Pruning). MaxGF with Neighbor Pruning finds the solution no worse than MaxGF.

Proof.
According to Lemma 7, if |H′v|≥p, MaxGF starts directly on H′v, instead of Hv. Moreover, according to Lemma 8, |H′v|<p, and wHv(H′v)|H′v|<12⋅c, the whole Hv is safely truncated. Because Neighbor Pruning only trims the hop-bounded subgraphs and vertices that do not generate better solutions than SAPX, the performance bound in Theorem 3 still holds. The theorem follows.

5.2 Core Pruning
Neighbor Pruning prunes every vertex u with τHv(u)<σ(SAPX) in the hop-bounded subgraph Hv. In this section, Core Pruning further prunes every vertex with τHv(u)≥c when the neighbors of u do not have sufficient incident weights, i.e., u and its neighbors cannot collaboratively form a subgraph with sufficient average weight. To better explain the idea, we first introduce the notion of weighted core [25] on potential edges.

Given a heterogeneous social network G=(V,E,R), a w-weighted core Kw on the potential edges is an induced maximal subgraph with each vertex u in Kw satisfying τKw(u)≥w,∀u∈Kw. Note that a w-weighted core Kw is maximal, i.e., there exists no supergraph Kˆw⊇Kw satisfying the above condition. Fig. 4a presents an example of a 0.7-weighted core, i.e., Hv. On the other hand, {c,d,g} is not a 0.7-weighted core because {c,d,g} is not maximal, i.e., {c,d,g} is a subgraph of Hv in Fig. 4a. The maximal w-weighted cores can be obtained in polynomial time [25], by recursively deleting each vertex v with the incident weight smaller than w. Moreover, we further define the weighted core number (or core number) of vertex u in a graph H, κH(u), as the largest w with u located in any w-weighted core of H. Note that, by definition, if Kw is a w-weighted core, it must also be a w′-weighted core for any w′<w. Equipped with the notion of w-weighted cores, Core Pruning is more effective than Neighbor Pruning in Section 5.1 because the vertices pruned by Core Pruning form a superset of the set of vertices pruned by Neighbor Pruning.

Example 3.
Consider the example in Fig. 4 again. Fig. 4a shows the vertices and the potential edges in a hop-bounded subgraph Hv with p=4 and σ(SAPX)=0.8. Neighbor Pruning only removes vertices {a,e,f}, and MaxGF is required to examine the subgraph induced by {b,c,d,g} in this case. In contrast, Core Pruning guarantees that the whole Hv can be safely truncated without sacrificing the solution quality. In the following, we first explore Core Pruning without the size constraint (i.e., p=0).

5.2.1 Core Pruning Without Size Constraint
Given the hop-bounded subgraph Hv and the currently best solution SAPX with c=σ(SAPX), Core Pruning without the size constraint states that for any vertex u∈Hv with κHv(u)<c, u can be directly truncated. Consider the running example in Fig. 4a again with p=0 and c=0.8. Although each vertex u∈{b,c,d,g} has τHv(u)>c=0.8, κHv(u)<0.8,∀u∈{b,c,d,g}. Therefore, the whole Hv={a,b,c,d,e,f,g} can be pruned by Core Pruning. By contrast, Neighbor Pruning only trims off {a,e,f} in this case.

Core Pruning is based on the following key observations. 1) Given a subgraph Q⊆Hv that does not contain a c-weighted core, we can always identify a vertex u∈Q such that τQ(u)<c (otherwise, Q must be a c-weighted core). 2) According to Lemmas 5 and 6, u can be removed from Q because choosing u cannot improve any solution to outperform SAPX. 3) Moreover, Q−{u} does not contain a c-weighted core, either. According to the above observations, all the vertices in Q can be safely truncated in accordance with the following theorem.

Theorem 5.
(Core Pruning Without Size Constraint). Given the currently best solution SAPX with c=σ(SAPX), a hop-bounded subgraph Hv, and the size constraint p=0, any vertex u∈Hv can be trimmed off from Hv if κHv(u)<c holds.

Proof.
If τHv(u)<c, then u can be directly trimmed from Hv according to Lemmas 5 and 6. Therefore, we focus on the case with τHv(u)≥c, where Hv is the union of the maximal c-weighted core Kc and the rest K−, i.e., Hv=Kc∪K− and Kc∩K−=∅. Recall that any vertex u∈K− must satisfy κHv(u)<c; otherwise, u is included in Kc.

Without loss of generality, we assume that K−≠∅. Then, there exists a vertex u1∈K− such that τHv(u1)<c. Otherwise, the whole Hv is a c-weighted core and K−=∅. Then, u1 can be trimmed, according to Lemmas 5 and 6. Let Z1=Hv and Z2=Hv−{u1}. Then, if Z2≠Kc, there exists a vertex u2∈Z2 such that τZ2(u2)<c (otherwise, Z2 is a c-weighted core, contradicting the assumption that Kc is the maximal c-weighted core). We repeat the above steps and remove the vertices until no vertex uj∈Zj with τZj(uj)<c exists. Assume that we remove {u1,…,um} from Hv, and no further vertex um+1 in the remaining graph Zm+1 satisfies τZm+1(um+1)<c. That is, the above process stops when we obtain Zm+1.

In the following, we prove that ⋃i∈[1,m]ui=K−. First, we prove by contradiction that ⋃i∈[1,m]ui⊆K−, i.e., there does not exist a vertex ui∈{u1,…,um} such that κHv(ui)≥c. Assume that there is ui∈{u1,…,um} with κHv(ui)≥c, i.e., τZi(ui)<c holds during the above vertex-removing process. Since κHv(ui)≥c, ui is in the c-weighted core Kc, where τKc(ui)≥c must hold. Therefore, τZi(ui)<c only if {u1,…,ui−1} includes at least another vertex that is also in Kc, say uj, where j∈[1,i−1], and uj∈Kc holds. Similarly, at least one vertex in {u1,…,uj−1},j<i must belong to Kc, and so on. Finally, we conclude that u1∈Kc must hold, i.e., τHv(u1)≥c. However, based on the above vertex-removing process, τHv(u1)<c leads to a contradiction. Therefore, there exists no vertex in {u1,…,um} such that κHv(ui)≥c. It concludes that κHv(ui)<c,∀i∈[1,m], i.e., ⋃i∈[1,m]ui⊆K−.

Second, we prove that K−⊆⋃i∈[1,m]ui. Given any vertex a∈K−, by definition, κHv(a)<c. Note that τZm+1(u)≥c,∀u∈Zm+1, indicating that Zm+1 is a c-weighted core, and κHv(u)≥c. Since κHv(a)<c holds, a∉Zm+1. Recall that Hv=⋃i∈[1,m]ui∪Zm+1 and ⋃i∈[1,m]ui∩Zm+1=∅. Because a∉Zm+1, a∈⋃i∈[1,m]ui holds. Therefore, we have K−⊆⋃i∈[1,m]ui.

Based on the two cases above, we conclude that ⋃i∈[1,m]ui=K−. Since every vertex in ⋃i∈[1,m]ui=K− can be safely trimmed, we conclude that given u∈Hv with κHv(u)<c, u can be trimmed from Hv. The theorem follows.

5.2.2 Core Pruning With Size Constraint
Given a hop-bounded subgraph Hv and the currently best solution SAPX with c=σ(SAPX), let H′v denote the hop-bounded subgraph after removing each vertex u with κHv(u)<c. Similar to Neighbor Pruning, three cases are examined when the size constraint is considered, i.e., p>0.

|H′v|≥p. In this case, MaxGF starts directly from H′v without considering the vertices with κHv(u)<c. According to Lemmas 5 and 6, each removed vertex u (with κHv(u)<c) cannot improve any subset of vertices in Hv and thus may be pruned. The proof is similar to Lemma 7 in Neighbor Pruning.

|H′v|<p, and wHv(H′v)|H′|v<12⋅c. In this case, the whole Hv can be pruned. Thus, MaxGF moves on to examine the next hop-bounded subgraph. The proof is similar to Lemma 8 in Neighbor Pruning.

|H′v|<p, but wHv(H′v)|H′|v≥12⋅c. In this case, MaxGF needs to examine the whole Hv.

It is worth noticing that Core Pruning only trims the hop-bounded subgraphs and vertices that never generate better solutions than SAPX. Therefore, the performance bound in Theorem 3 still holds.

Discussion. Note that the core number of each vertex v∈G can be computed efficiently offline [27]. Moreover, for the core number of a vertex u∈Hv⊆G, κHv(u)≤κG(u). Therefore, we can first derive the core number of each vertex in G offline and exploit the core numbers for performing Core Pruning on Hv. Similar to Neighbor Pruning, Core Pruning needs one scan over the vertices in Hv to remove redundant vertices from Hv. Therefore, employing Core Pruning does not increase the time complexity of MaxGF.

SECTION 6Solution Optimality of MaxGF in Threshold Graphs
In this section, we analyze the performance of MaxGF on threshold graphs, a special class of graphs which exhibit many properties similar to well-known large-scale online social networks [26], [28], e.g., Youtube, Flickr, Live-Journal. These properties include the degree distribution, local clustering coefficient, edge density, and the largest component size. Analyzing the proposed MaxGF algorithm in threshold graphs helps us understand the performance and behavior of the algorithm in popular large-scale online social networks. In the following, we first formally define the threshold graphs.

6Definition 1.
Mahadev and Peled [26] A graph Gˆ is a threshold graph if there exists a weight ωv for every vertex v in Gˆ and a threshold value t such that an edge (u,v) exists in Gˆ if and only if ωu+ωv≥t holds.

Fig. 5a presents an example of the threshold graph with t=6, where a weight is associated with each vertex. Fig. 5b shows both the friend edges (solid lines) and the potential edges (dotted lines). In this section, we first analyze the tractability of HMGF where the graph induced by (V,E), i.e., the existing friendships of individuals, is a connected threshold graph. We consider the case of HMGF on threshold graphs, i.e., HMGF-Threshold (HMGF-T), with h≥2. Recall that in HMGF, if there is a friend edge (u,v) between u and v, the potential edge [u,v] does not exist. Therefore, the potential edge set R actually is the complement of the friend edge set E on G.


Fig. 5.
Example of solving HMGF-T with MaxGF.

Show All

In the following, we prove that the MaxGF algorithm proposed in Section 4 obtains the optimal solution to HMGF-T in polynomial time. Given a vertex x, we first define the neighbor set of x on a graph Gˆ, i.e., NGˆ(x), as the 1-hop neighbors of x on Gˆ. Moreover, the closed neighbor set of x, i.e., NGˆ[x], is defined as the union of x's neighbor set and x itself, i.e., NGˆ[x]=NGˆ(x)∪{x}. We first introduce an important notion, vicinal pre-order [26], which describes an ordering relationship of two neighboring vertices x and y, defined in terms of their common neighbors. Specifically, the vincial pre-order x≲Gˆy states that in Gˆ, every vertex (except y) adjacent to x is also adjacent to y. In other words, x≲Gˆy if and only if all x's neighbors are all included in y's closed neighbor set, i.e., NGˆ(x)⊆NGˆ[y]. The vicinal pre-order of a graph is linear if for any two vertices x and y in the graph, x≲Gˆy, or y≲Gˆx, or both hold. Accordingly, Lemma 9 presents the relationship between vicinal pre-order and a threshold graph.

6Lemma 9.
Mahadev and Peled [26] A graph Gˆ is a threshold graph if and only if the vicinal pre-order on Gˆ is linear.

Thus, given a threshold graph Gˆ=(Vˆ,Eˆ), we can relabel the vertices in Vˆ to {v1,v2,..,v|Vˆ|} such that v1≲Gˆv2≲Gˆv3…≲Gˆv|Vˆ|. To show that MaxGF finds the optimal solution, Lemma 10 first proves that the complement graph of a threshold graph is also a threshold graph, and then Lemma 11 connects the vicinal pre-order to the objective function of HMGF-T, which is the average weight of the solution group H, i.e., σ(H)=w(H)|H|, where w(H) is the total potential edge weight induced by H.

6Lemma 10.
Given a threshold graph Gˆ=(Vˆ,Eˆ), the complement graph GˆC=(Vˆ,EˆC) of Gˆ is also a threshold graph.

6Proof.
For Gˆ, we can relabel the vertices to {v1,v2,..,v|Vˆ|} such that v1≲Gˆv2≲Gˆv3…≲Gˆv|Vˆ|. Recall that x≲Gˆy indicates that NGˆ(x)⊆NGˆ[y] and implies that NGˆC(y)⊆NGˆC[x]. Therefore, v|Vˆ|≲GˆC…≲GˆCv1 holds. According to Lemma 9, GˆC is also a threshold graph, and the lemma follows.

6Lemma 11.
Given a threshold graph Gˆ=(Vˆ,Eˆ) with vicinal pre-order v1≲Gˆv2⋯≲Gˆv|Vˆ|, σ(S)≤σ({v|Vˆ|,v|Vˆ|−1,…,v|Vˆ|−k+1}) holds for every S⊆Vˆ with |S|=k.

6Proof.
For each S⊆Vˆ with |S|=k and a vertex vi∉S with its label satisfying n−k+1≤i≤n, there exists a vertex s∈S such that s≲Gˆvi and NGˆ(s)⊆NGˆ[vi]. Therefore, σ(S)≤σ((S−{s})∪vi) holds. Let i=|Vˆ|, and we have σ(S)≤σ((S−{s})∪v|Vˆ|) after replacing the vertex s∈S with v|Vˆ|. Similarly, we can substitute another s by v|Vˆ|−1, v|Vˆ|−2,…,v|Vˆ|−k+1 iteratively and have σ(S)≤σ({v|Vˆ|,v|Vˆ|−1,…,v|Vˆ|−k+1}). The lemma follows.

Equipped with the above lemmas, the following theorem proves that MaxGF finds the optimal solution.

6Theorem 6.
MaxGF obtains the optimal solution for HMGF-T in polynomial time.

6Proof.
For the input graph G=(V,E,R) of HMGF-T, let GE=(V,E) denote a set of individuals and their friendships, while GR=(V,R) denotes the same set of individuals and their potential edges. According to Lemma 10, GE and GR are both threshold graphs. The vicinal pre-order for GE is v1≲GEv2≲GE…≲GEv|V|, whereas the vicinal pre-order for GR is v|V|≲GRv|V|−1≲GR…≲GRv1.

For any two vertices p and q, either i) (p,q)∈E, or ii) (p,v|V|)∈E and (v|V|,q)∈E, because v1≲GEv2≲GE…≲GEv|V|. Therefore, dEG(p,q)≤2 holds, satisfying the hop constraint of HMGF-T. According to Lemma 11, at the ith iteration in MaxGF, Si is the optimal solution with the size constraint |V|−i. The time complexity of MaxGF is O(|V|log|V|⋅(|E|+|R|)) as analyzed in Appendix C, available in the online supplemental material. Therefore, MaxGF obtains the optimal solution to HMGF-T in polynomial time. The theorem follows.

6Example 4.
Consider Fig. 5a as an example with t=6, where a vertex weight is associated with each vertex. Again, Fig. 5b shows G=(V,E,R) with the solid lines representing the friend edges and the dotted lines representing the potential edges. Assume h=2, and S1=G holds because Hv=G for any v∈G, as shown in Fig. 5b. In the first iteration (i=1), MaxGF removes v6 to generate S2 because it incurs the minimum incident weight. Fig. 5c presents the result S2. It is the optimal solution to HMGF-T with the size constraint p=|V|−i=6−1=5. MaxGF then proceeds to the second iteration (i=2) and removes v5 from S2 to construct S3, as shown in Fig. 5d. It is the optimal solution to HMGF-T with the size constraint p=4.

SECTION 7Experimental Results
In the following, we compare HMGF with several baselines in large-scale real datasets and present a user study in Facebook.

7.1 Experiment Setup
We evaluate the performance of MaxGF on three real datasets summarized in Table 2, including FB [23], DBLP [32], and Youtube.6 The FB dataset is extracted from Facebook with 63K vertices and 817K friend edges. DBLP is a co-author network including 317K vertices and 1M friend edges. Youtube is a video-sharing social network with 1.1M vertices and 3M friend edges. The potential edges are generated by a link prediction algorithm [19] by exploring the node neighborhoods, i.e., common neighbors and Jaccard's coefficient, where the weight of each potential edge is ranged within (0,1].

TABLE 2 Summary of Datasets for General Social Networks

Moreover, we construct different threshold graphs for HMGF-T according to the above real datasets by setting different threshold values, whereas the threshold t (defined in Definition 1) is derived according to [26], [28]. Specifically, for a graph G=(V,E,R), we generate the corresponding threshold graph GT=(V,ET,RT) [26], [31]. Given the selected threshold t and an initially empty ET, for any two vertices u and v in V, if δ(v)+δ(u)≥t, a new friend edge (u,v) is added to the threshold graph, i.e., (u,v)∈ET, where δ(v) denotes the degree of v on (V,E). Recall that if a friend edge (u,v) exists, there is no potential edge [u,v] for u and v because they are already friends. Therefore, the set of potential edges RT is the complement of ET in the experiments, and each potential edge [u,v]∈RT is associated with a weight w[u,v]. The weights of potential edges are generated by a link prediction algorithm [19] as described above.

We compare MaxGF with four baseline approaches, i.e., BF, ILP, DkS, RMC, and (k,r)-core. BF is a brute-force approach that finds the optimal solution to each HMGF instance by enumerating all possible combinations. ILP acquires the optimal solution based on the Integer Linear Programming formulation in Section 2.2 solved by a popular commercial solver IBM CPLEX [2]. DkS is a category of algorithms widely adopted by many previous approaches [33], [34], [35] to extract dense subgraphs.7 Not designed to consider the potential edges and the hop constraint, DkS examines only the friend edges. In contrast, MaxGF examines both the friend and potential edges while exploiting the proposed pruning and post-processing strategies.

RMC is a state-of-the-art randomized algorithm for extracting the maximum clique from a given graph, which obtains near-optimal solutions very efficiently [29]. It is employed on the potential edges to extract a clique with p vertices.8 Since RMC is designed to extract the maximum clique from an unweighted graph, it does not consider the friend edges and the weights of potential edges.9 Finally, (k,r)-core [30] is the state-of-the-art dense subgraph extraction approach that considers both friendship and the similarity of users on their different attributes. In other words, (k,r)-core examines both existing friendships and the potential friendships of the users (modeled as weighted similarity edges). The goal of the (k,r)-core problem is to find the group of users with a k-core on friend edges, i.e., each group member has at least k other existing friends in the same group, where the weight of every induced similarity edge in the group is at least r, i.e., any two members in the group are similar to each other. Please note that although (k,r)-core requires the selected subgraph to form a k-core on friend edges, the hop distance between the vertices is not bounded.

We evaluate all approaches according to Feasibility Ratio (FeaRatio) and Objective Ratio (ObjRatio), which respectively measure the proportion of solutions satisfying the hop constraint, and the ratio of the average weights (i.e., σ(H)) achieved by each approach relative to that of the optimal solution (ILP). All algorithms are implemented in an HP DL580 server with Quadcore Intel X5450 3.0 GHz CPUs and 1 TB RAM. We measure 30 instances in each scenario and present the averaged results. By default, MaxGF is equipped with the proposed Weight Threshold Pruning in order to output the solution in a reasonable time. The performance results of MaxGF equipped with other pruning strategies, i.e., Neighbor Pruning and Core Pruning, are presented in Section 7.3.

In addition to the experiments, we also conduct a user study with 1,573 candidate group members. These candidates form a social network with 30,124 edges. We compare the proposed MaxGF algorithm with the other two baselines to demonstrate that the proposed approach is able to significantly increase the number of new friendships. We also present discussions regarding the user study results, including: i) how friendships grow with time for the groups selected by different approaches, and ii) a case study. The user study results validate that our proposed approach outperforms the other baselines in friend-making activities because we consider the existing and potential friendships at the same time. For the detailed descriptions of the baselines, experimental setup, and results, please refer to Appendix F, available in the online supplemental material.

7.2 Comparisons With Optimal Solutions on Small Graphs
We first consider small instances of HMGF since BF does not return the optimal solutions on large networks within a reasonable time. We evaluate MaxGF against BF, ILP, and DkS on small graphs randomly extracted from FB. Fig. 6a compares the execution time of all algorithms with different graph sizes. Since BF enumerates all the subgraphs H with |H|≥p, the execution time grows exponentially. Although ILP is solved by employing a commercial solver CPLEX, it still incurs at least twice the execution time of MaxGF, because the hop-bounded subgraphs and the pruning strategies in MaxGF effectively trim the search space. Figs. 6b and 6c present the Feasibility Ratio and Objective Ratio of the algorithms, respectively. MaxGF effectively generates high ObjRatio because it iteratively removes the vertices with low incident weights from each hop-bounded subgraph Hv and extracts the solution SAPX with the maximum σ(SAPX) among different subgraphs in different Hv, to strike a good balance between the average edge weight and group size. Moreover, the high FeaRatio and ObjRatio manifest that the post-processing procedure effectively restores the hop constraint and maximizes the average weight accordingly. By contrast, DkS considers neither the hop constraint nor the potential edges. Thus it generates the solutions with small FeaRatio and ObjRatio.

Fig. 6. - 
Comparisons with optimal solutions.
Fig. 6.
Comparisons with optimal solutions.

Show All

Figs. 6d to 6f compare the execution time, FeaRatio, and ObjRatio with different h. Although many more candidate vertices are examined when h increases, the execution time of MaxGF grows slowly because the proposed pruning strategies effectively avoid examining the hop-bounded subgraphs that do not lead to a better solution. Compared with DkS, FeaRatio and ObjRatio of MaxGF with different h are sufficiently high because it employs hop-bounded subgraphs to avoid generating the solutions with large hop distances on friend edges. Moreover, the post-processing procedure effectively restores the hop constraint and maximizes the objective value. By contrast, ObjRatio of DkS plummets as h grows because DkS only examines the friend edges. The average weights of the optimal solutions increase as h becomes larger, and thus ObjRatio of DkS plunges in this case.

7.3 Experiments on Large Datasets
Fig. 7 presents the results of sensitivity tests on the proposed MaxGF, Neighbor Pruning and Core Pruning approaches with the baseline approach, RMC. Figs. 7a and 7b demonstrate the effectiveness of the pruning strategies on FB and DBLP, respectively. As p increases, the execution time of all approaches in Figs. 7a (FB) and 7b (DBLP) drops because all algorithms with a larger p do not need to examine small groups. MaxGF-NP (MaxGF with Neighbor Pruning) and MaxGF-CP (MaxGF with and Core Pruning) significantly reduce the computation time because they enable MaxGF to skip a massive number of vertices that cannot generate better solutions. Moreover, MaxGF-CP outperforms MaxGF-NP because the set of trimmed redundant vertices in Core Pruning is a superset of the vertices pruned by Neighbor Pruning. It is worth noting that MaxGF-NP and MaxGF-CP are more effective on FB than on DBLP because FB has more potential edges with larger weights, enabling Neighbor Pruning and Core Pruning strategies to avoid many unnecessary examinations. RMC requires small execution time because it is a randomized approach to find the maximum clique. However, Figs. 7c, 7e, and 7f all show that RMC has very poor solution quality. Therefore, RMC does not work well for organizing a friend-making activity.


Fig. 7.
Results of sensitivity tests.

Show All

Figs. 7c and 7d compare the objective values (i.e., average weights, σ(H)) and returned group sizes (i.e., |H|) with different p, respectively. As shown in Fig. 7c, σ(H) of FB is much larger than that of DBLP due to higher potential edge weights in FB, i.e., users on FB usually share more common friends. Also, as reported by Fig. 7d, the returned group sizes on FB are larger because the diameter (on friend edges) of FB is smaller. Each hop-bounded subgraph of FB contains much more vertices and thus tends to generate larger groups. Fig. 7e compares the average weights with different h. The average weight increases for a larger h because more candidate vertices are examined to generate better solutions.

Fig. 7f presents the results in Youtube dataset. The average weights of Youtube are much smaller because Youtube is sparse in friend edges (average degree: 2.6, diameter: 24). In this case, much fewer vertices can be included in each hop-bounded subgraph, and it is thus more difficult to find many new friends with the introduction of close friends. Moreover, recall that RMC does not consider the hop constraint h, and thus only one bar for each p value is plotted here. The average weights of MaxGF outperform RMC on Youtube since RMC does not consider the likelihood of making new friends. Those groups are less suitable for friend-making activities because the likelihoods of making new friends are usually tiny.

Finally, we compare our proposed MaxGF with RMC and (k,r)-core on the FB dataset. Here, we present the results of two k values for (k,r)-core, i.e., k=5 and k=7. Similar to [30], we set r as the top 0.3 percent largest potential edge weight in the FB dataset. Figs. 7g and 7h compare the objective values (i.e., the average potential edge weights) of MaxGF, (k,r)-core, and RMC. In all h and p values, the average weights (objective values) of MaxGF outperform (k,r)-core and RMC. This is because (k,r)-core requires the selected group to have every potential edge weight at least r, which is a more strict requirement, and RMC does not consider the potential edge weights. It is worth noting that all (5,r)-core, (7,r)-core, and RMC do not return feasible solutions. That is, their selected groups do not satisfy the hop constraint.

We parallelize the proposed MaxGF algorithm and show its performance in Appendix D, available in the online supplemental material. Moreover, we compare the performance of MaxGF with input graphs generated by different link prediction algorithm in Appendix E, available in the online supplemental material.

7.4 Evaluations on Large Threshold Graphs
Fig. 8 compares MaxGF with DkS on different threshold graphs, where the constructed threshold graphs from FB, DBLP, and Youtube are named FB-T, DBLP-T, and Youtube-T, respectively. Fig. 8a first evaluates various scenarios with different thresholds t. MaxGF finds the solutions with very high objective values (i.e., average weights) because it acquires the optimal solution to HMGF-T as shown in Theorem 6. In contrast, the solution quality of DkS is poor because it examines only the friend edges and tends to find the solutions densely connected on friend edges with very few potential edges.


Fig. 8.
Evaluations on threshold graphs.

Show All

When the threshold t becomes larger, the number of friend edges decreases, and the number of potential edges grows (recall that the set of potential edges is the complement of the set of friend edges). Therefore, the computation time of MaxGF gradually increases because it needs to consider more potential edges, and the solution quality of MaxGF in this case also improves. Fig. 8b compares the execution time on different datasets with the group size constraint p set to 0.5⋅|V|. When the threshold decreases, the execution time drops sharply, where Youtube-T incurs the largest execution time since it has the largest number of potential edges and vertices. Note that all the solutions returned by MaxGF are optimal solutions, i.e., they all achieve 100 percent feasibility and objective ratios.

7.5 User Study
For the detailed descriptions of the baselines, experimental setup, and results, please refer to the Appendix F, available in the online supplemental material.

SECTION 8Conclusion
To bridge the gap between the state-of-the-art activity organization and friend recommendation in OSNs, in this paper, we propose to explore existing and potential friendships of individuals on OSNs for friend-making activity organization. We formulate a new research problem, namely, Hop-bounded Maximum Group Friending, to find suitable activity attendees. We prove that HMGF is NP-Hard and there exists no approximation algorithm unless P=NP. We derive an ILP formulation and then propose an approximation algorithm with guaranteed error bound, i.e., MaxGF, to find good solutions efficiently. We also propose effective pruning strategies to significantly improve the efficiency of MaxGF. In addition, we show that MaxGF is able to obtain the optimal solution for HMGF on threshold graphs in polynomial time. We conduct a user study and extensive experiments to evaluate the performance of MaxGF. The study shows that MaxGF outperforms other relevant approaches in terms of both solution quality and efficiency. Users prefer the groups returned by MaxGF because MaxGF is able to select individuals who are likely to become friends, indicating that the proposed HMGF and MaxGF meet the users’ practical needs.