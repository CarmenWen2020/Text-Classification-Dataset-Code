Cloud computing is motivating data owners to outsource their databases to the cloud. However, for privacy concerns, the sensitive data has to be encrypted before outsourcing, which inevitably posts a challenging task for effective data utilization. Existing work either focuses on keyword searches, or suffers from inadequate security guarantees or inefficiency. In this paper, we concentrate on multi-dimensional range queries over dynamic encrypted cloud data. We first propose a tree-based private range query scheme over dynamic encrypted cloud data (TRQED), which supports faster-than-linear range queries and protects single-dimensional privacy. Then, we discuss the defects of TRQED in terms of privacy-preservation. We modify the framework of the system by adopting a two-server model and put forward a safer range query scheme, called TRQED ^{+} . By newly designed secure node query (SNQ) and secure point query (SPQ), we propose the perturbation-based oblivious R-tree traversal (ORT) operation to preserve both path pattern and stronger single-dimensional privacy. Finally, we conduct comprehensive experiments on real-world datasets and perform comparisons with existing works to evaluate the performance of the proposed schemes. Experimental results show that our TRQED and TRQED ^+ surpass the state-of-the-art methods in privacy-preservation level and efficiency.
SECTION 1Introduction
With the prevalence of cloud computing, database outsourcing [1] has become a popular service nowadays. In the cloud computing paradigm, a data owner prefers to remotely store their data into the cloud so as to benefit from outsourcing heavy storage and management tasks to the cloud server. This motivates more and more individuals and enterprises to outsource their local databases. Data outsourcing, however, raises serious privacy concerns. Sensitive data, such as emails and medical records, have to be encrypted to protect the privacy before outsourcing [2], [3]. Unfortunately, this introduces new challenges to data utilization. How to enable effective queries over encrypted cloud data while preserving the privacy is one of the most important to be solved.

One trivial approach is to download and decrypt the data locally, which is clearly impractical and contradicts with our motivation. Traditional searchable encryption (SE) schemes [2], [4], [5] have been proposed to support specific types of queries, such as keyword searching [5], [6]. However, considering the equality and inequality conditions specified by the SQL, based on which multi-dimensional range queries are evaluated, traditional SE schemes would not be adequate.

To support multi-dimensional range queries over encrypted data, Boneh et al. designed a predicate encryption scheme [7] by using Hidden Vector Encryption (HVE) [8]. The scheme, however, incurs high computation due to heavy reliance on public-key cryptography, and cannot prevent the cloud server from identifying whether two encrypted queries are from the same query, which we refer to as query privacy. To improve the efficiency, researchers proposed a symmetric scheme LSED+ [9] and an Rˆ-tree scheme [10] by decomposing a multi-dimensional range query into multiple single-dimensional queries. However, both schemes suffer from single-dimensional privacy leakage, meaning the server would learn the relationship between every single-dimensional query and its corresponding query results. To solve this problem, Wang et al. [11] proposed a scheme Maple based on HVE. However, a public-key scheme, Maple incurs heavy computation cost, and fails to preserve the query privacy. Moreover, Maple cannot support dynamic operations, i.e., insertion, deletion and modification. In summary, all aforementioned multi-dimensional range query solutions either suffer from inadequate privacy guarantees, i.e., query privacy and single-dimensional privacy or fail in efficiency. Moreover, most works achieving faster-than-linear search do not support dynamic operations. Thus, the problem of private range query over dynamic encrypted cloud data remains open to date.

Our work focuses on addressing the problem of multi-dimensional private range queries over dynamic encrypted cloud data. Specifically, our design goals are as follows.

Multi-dimensional range query. The design should enable multi-dimensional range queries over encrypted data, and return the correct results.

Data dynamics support. The design supports data update including insertion, deletion and modification.

Privacy-preservation. The design should prevent the cloud server from learning additional sensitive information from database, index and query. Especially, the privacy requirements include Data privacy, Index privacy, Query privacy, Single-dimensional privacy and Path pattern privacy.

High efficiency. The above goals should be achieved with low system overhead and high efficiency.

In our previous work [12], we first proposed a Tree-based private Range Query scheme over dynamic Encrypted cloud Data (TRQED), which enables efficient range queries without revealing sensitive information to the cloud server. In TRQED, we proposed the perturbation-based inner product comparison (IPC) and extended dimensions to convert the same query to varied query vectors and obfuscate the cloud server’s view, which can preserve query privacy and single-dimensional privacy. To reduce the system overhead, we also designed the lightweight point intersection predicate encryption (PIPE) and the range intersection predicate encryption (RIPE), thus transforming the query processing into an efficient traversal of a tree by checking the relations between the given range query and tree nodes. Our contributions in the previous work [12] are summarized as follows:

We present TRQED, the first private range query scheme which achieves faster-than-linear search and supports data dynamics while preserving the query privacy and single-dimensional privacy simultaneously.

We use the perturbation-based IPC and extended dimensions to preserve the query privacy and single-dimensional privacy, and propose two building blocks PIPE and RIPE to enable efficient range query.

We theoretically prove that our scheme is secure against semi-honest adversaries under known background model.

In TRQED, however, we did not cover path pattern privacy [11] which can leak out useful information to the cloud server. Besides, TRQED cannot fully preserve single-dimensional privacy against powerful statistical attacks. Based on the TRQED scheme, we redesign the system framework and make a trade-off between efficiency and security to further enhance privacy protection level. To preserve path pattern and single-dimensional privacy, we perform a range query by using two cloud servers to traverse R-tree collaboratively. Moreover, we exploit secure scalar product (SSP) protocol and develop oblivious R-tree traversal (ORT), which mainly consists of secure node query (SNQ) and secure point query (SPQ), to prevent the two cloud servers from inferring each other’s sensitive information.

Compared with the preliminary conference version [12] of this paper, we have modified the architecture of system model in TRQED to support stronger privacy guarantees. To preserve path pattern and stronger single-dimensional privacy, we have adopted a two-server model and designed oblivious R-tree traversal operation. The enhanced version of TRQED is called TRQED+. In summary, the paper substantially extends our previous work as follows:

We modify the framework of the system by adopting two-server model and put forward TRQED+, a security-enhanced version of TRQED. Compared with TRQED, TRQED+ additionally provides stronger single-dimensional privacy preservation and path pattern preservation.

We propose the perturbation-based oblivious R-tree traversal operation, which includes SNQ and SPQ. Oblivious traversal allows us to preserve path pattern privacy during R-tree traversal. Moreover, we achieve stronger single-dimensional privacy preservation by exploiting SSP protocol in SNQ and SPQ.

To evaluate the performance of TRQED and TRQED+, we conduct extensive experiments on real-world datasets. Evaluation shows that TRQED is more efficient than existing works, and for our safer TRQED+, the overhead on computation and communication are affordable.

We organize this paper in the following manner. In Section 2, we outline the system model, threat models, design goals, and primary notations. Section 3 depicts the basic design of IPE, which includes PIPE and RIPE. Then, we detailedly present the TRQED and TRQED+ in Sections 4 and 5, respectively. We show the simulation results and introduce the related works on searchable encryption and range queries in Sections 6 and 7. Finally, we conclude this paper in Section 8.

SECTION 2Problem Formulation
2.1 System Model
The system model we consider in this paper consists of three entities: a data owner, a cloud server and multiple authorized users, as depicted in Fig. 1. The data owner wants to outsource its database (e.g., a large set of data records) to the cloud in order to reduce the management cost. To protect the privacy, the sensitive data is encrypted before outsourcing. For queries over encrypted data, the data owner builds a searchable index with a multi-dimensional index, and encrypts the index. Afterwards, the owner outsources the encrypted database and index to the cloud server. Users have mutual authentication capability with the data owner, and can search the encrypted cloud data by submitting an encrypted range query to the server. Once receiving the search token, the cloud server searches the tree-based index and returns the set of matched data records.

Fig. 1. - 
Architecture of private range query over encrypted cloud data.
Fig. 1.
Architecture of private range query over encrypted cloud data.

Show All

Herein, we employ R-tree [13] to build the index. R-tree is a type of multi-dimensional data structure, which represents each node is with a Minimum Bounding Rectangle (MBR), and nearby objects are grouped in the same layer. In our work, each data record is essentially an element of points set of leaf node. We consider each node of R-tree has the form (R,p), where R represents an MBR. A leaf-node points to a set of (encrypted) multi-dimensional points that its MBR covers. Closely located leaf-nodes are further grouped into an upper-level node. The process is repeated recursively until the root node is derived. Thus, an index node stores a set of pointers for its children. In particular, the pointers of a leaf node are for the multi-dimensional points, and the pointers of a non-leaf node are for its child nodes.

2.2 Threat Model
We consider a semi-honest (also known as honest-but-curious [5], [10], [11], [14], [15]) cloud server in the threat model, which is the foundation of designing secure protocols against malicious adversaries [16]. That is, the server follows the protocol honestly, but it is curious to record all intermediate results and try to deduce useful information about the data and queries. We assume the authorized users are trusted by the data owner and do not collude with the server.

In terms of the level of privacy protection, there are two kinds of threat models, namely Known ciphertext model and Known background model with respect to the assumption of the cloud server¡¯s ability. Wang et al. [17] adopt the former model to provide security for privacy-preserving range queries over encrypted cloud data. Herein, we adopt the latter, namely Known background model, which is also considered in some existing works [5], [6]. In this model, the cloud server is supposed to not only know the encrypted dataset and index as in the former two models, but also possess more knowledge such as the distribution of queries. As an instance of possible attacks, the server could launch frequency analysis attacks combined with the background information to deduce useful information.

2.3 Privacy Requirements
Before proposing a secure query scheme, we need to clearly understand the definition of various privacy requirements, which are related to different data stakeholders [18].

Data privacy and Index privacy. The data owner holds the original database, and builds a tree-based index to organize data. Both data and index involve sensitive information of the owner. Therefore, a secure scheme should ensure that the cloud server cannot infer exact information from encrypted data and index.

Query privacy. The authorized users submit encrypted search token to the cloud server, and the latter executes query task. However, the search token and search results can not reveal the specific query range of the authorized user.

Single-dimensional privacy and Path pattern. During the search process, the cloud server can not obtain single-dimensional matching results and search paths from the intermediate results.

2.4 Notations
We use the following primary notations and definitions in the rest of the paper.

D: the set of n data records D={D1,…,Dn}.

D∗: the encrypted data set D∗={D∗1,…,D∗n}.

A: the set of w numerical attributes, denoted as A={A1,…,Aw}.

Di: a data record, denoted as a point Di={d1,…,dw}, where dj is a value in the jth dimension.

I: the R-tree index of D. I={D1,…,Dn;N1,…, Nm}, where Nj is a node, and Di is a data point associated with a leaf node.

I∗: the encrypted index. I∗={C1,…,Cn;E1,…, Em}, where Ej is an encrypted node, and Ci is an encrypted data point.

Q: a range query over any subset of w′ attributes, w′≤w, denoted as an MBR=(R1,…,Rw), where Ri is denoted as a range {(xi,l,xi,r)} in the ith dimension.

IDQ: the query result returned as a set of data record identifiers.

Each numeric attribute Ai represents a dimension. Note that D and I are encrypted separately, and the encrypted data point Ci is the encrypted index for data record Di, and stores the location of the encrypted record D∗i.

SECTION 3Intersection Predicate Encryption
The range queries over R-tree can be implemented by checking the relations that whether a point (i.e., a data record Ci) is inside an MBR (i.e., a range query Q) or whether an MBR Ei intersects with the given query region Q. In this section, we first present a method called inner product comparison (IPC) to convert a range query into inner product computation in the ciphertext domain, and design two predicate encryptions to determine the geometric relationships through extended usage of SSW [19] and secure kNN (k-nearest neighbor) computation [20].

3.1 Inner Product Comparison
3.1.1 Comparison Predicate
In the predicate query model [9], the users send predicate functions p as queries to the cloud server. The server searches the tuples of which the attribute values d satisfies p(d)=true and then returns the query results. Herein, for a one-dimensional range query [xl,xr] and a point d, we propose a function p:R+→R, where R is the set of real numbers as:
p(d)=(d−xl)(d−xr).(1)
View SourceThere are three types of relationships between point d and range [xl,xr]: d<xl, d>xr and xl≤d≤xr. For the former two types, (d−xl)(d−xr)>0, and for the third type, (d−xl)(d−xr)≤0. Therefore, the predicate function regards p(d)≤0 as true iff d is in the closed range [xl,xr] and false otherwise.

To preserve privacy, we add perturbations δ to the predicate p(d) as:
p˜(d)=(d−xl)(d−xr)(d+δ),(2)
View Sourcewhere δ is a κ bit positive number (κ is a given security parameter). δ is much larger than |d| so that d+δ must be a positive number. Therefore, p˜(d)≤0 iff xl≤d≤xr. As such, the statistical information of transformed queries are different from that of plain ones, and the perturbation-based predicate can find the correct tuples of which d∈[xl,xr].

3.1.2 Vector Extraction
We transform the predicate p˜(d) into query and value vectors. According to the expansion form of Eq. (2), we define the query vector p and value vector v as:
p=⎛⎝⎜⎜⎜1−xl−xr+δxlxr−xlδ−xrδxlxrδ⎞⎠⎟⎟⎟,v=(d3,d2,d,1)T.
View SourceRight-click on figure for MathML and additional features.As such, the inner product is ⟨p,v⟩=p˜(d), and ⟨p,v⟩≤0 is true iff d∈[xl,xr].

3.1.3 Vector Encryption
We employ the matrix-based encryption to encrypt the vectors, which enables the cloud server to process the encrypted queries without revealing sensitive information. The secret key for vector encryption is a four-dimensional invertible matrix. Alternatively, we can also adopt a ϕ-dimensional matrix where ϕ>4 as the key, and add dummy values into additional (ϕ−4) dimensions which satisfy that ∑ϕi=5pivi=0. For simplicity, we herein adopt a four-dimensional invertible matrix M to encrypt p. Correspondingly, the encryption key for v is M˜=|det(M)|M−1, where det(M) is the determinant of M as follows:
EM(p)=rpMTp(3)
View Source
EM˜(v)=rv|det(M)|M−1v,(4)
View Sourcewhere rp and rv are randomly generated positive numbers.

In the ciphertext domain, the query processing is to find the tuples of which the encrypted value vector EM˜(v) satisfies ⟨EM(p),EM˜(v)⟩≤0, which is computed as
⟨EM(p),EM˜(v)⟩=rprv|det(M)|⟨p,v⟩.(5)
View SourceAs rprv|det(M)|>0, ⟨EM(p),EM˜(v)⟩ depends on the ⟨p,v⟩. Thus, ⟨EM(p),EM˜(v)⟩≤0 is true iff d∈[xl,xr].

According to IPC, we can estimate the relationship between point d and range [xl,xr] without decryption. Next, we design two secure and efficient building blocks to check whether a value d is inside a range MBR and whether two MBRs intersect.

3.2 Point Intersection Predicate Encryption (PIPE)
Based on IPC, we introduce a Point Intersection Predicate Encryption (PIPE) to check whether a value d is inside a range MBR. Inspired by the predicate encryptions in [9], [11], the 1-dimensional PIPE (1dPIPE) is detailed as follows:

Setup(1κ). On input a security parameter κ, output a secret key SK.

Encrypt(SK, d). On input SK and a value d, output ciphertext C=rvM˜v, where v=(d3,d2,d,1)T and rv is a generated random positive number.

GenToken(SK, R). On input SK and a range R=[xl,xr], output search token TK=rpMTp, where p=(1,−xl−xr+δ,xlxr−xlδ−xrδ,xlxrδ)T, and rp is a random positive number.

Query(TK, C). On input TK and C, output 1 iff ⟨TK,C⟩≤0 and 0 otherwise.

Algorithm 1. wdPIPE
– Setup(1κ). On input a security parameter κ, output a secret key SK={M,M˜,ΩP}.

– Encrypt(SK,D). On input SK and a point D=(d1,…,dw), output ciphertext C=rv(ΩP([M˜v1,…, M˜v2w])), where rv is a random positive number, and for i∈[1,2w],

vi={(d3i,d2i,di,1)T,(ri,1,ri,2,ri,3,ri,4)T,i≤wi>w,
View Source

where ri,j is a random positive number for 1≤j≤4.

– GenToken(SK,MBR). On input SK and a range query MBR=(R1,…,Rw), where Rk=[xk,l,xk,r], output search token TK=rp(ΩP([MTp1,…,MTp2w])), where rp is a random positive number, and for i∈[1,2w],

pi=⎧⎩⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎛⎝⎜⎜⎜⎜1−xi,l−xi,r+δxi,lxi,r−(xi,l+xi,r)δxi,lxi,rδ⎞⎠⎟⎟⎟⎟,(r′i,1,r′i,2,r′i,3,r′i,4)T,i≤wi>w,
View Source

where r′i,j is a random negative number for 1≤j≤4.

– Query(TK, C). On input TK and C, output 1 iff ⟨tki,ci⟩≤0,∀i∈[1,2w], or output 0 otherwise.


Algorithm 
We now extend the 1dPIPE to the multi-dimensional case and construct the w-dimensional point predicate encryption (wdPIPE) to check whether a multi-dimensional point D is inside a query range. It is based on the geometric relationship that if a point is inside a query range, the value of this point in every dimension is inside the corresponding single-dimension range of the MBR, and vice versa:
D∈MBR⇔{di∈Ri},∀i∈[1,w].(6)
View SourceRight-click on figure for MathML and additional features.where the point D=(d1,…,dw) and query range MBR= (R1,…,Rw). The details of wdPIPE are presented in Algorithm 1. Note that the dimension w is extended to 2w dimensions in the inner product queries, of which scalar products of the added dimensions are below zero, to obfuscate the cloud server’s view and preserve the single-dimensional privacy. It is worth emphasizing that ΩP is a permutation function, which is generated randomly by the data owner, to obfuscate the order of 2w dimensions.

Correctness. The inner product for i≤w is
⟨tki,ci⟩= rprv|det(M)|⟨pi,vi⟩.
View Source

The inner product for dimension i>w is
⟨tki,ci⟩=rprv|det(M)|∑ri,jr′i,j,
View Source

where ri,j>0,r′i,j<0 for 1≤j≤4, which guarantees the inner product below 0. Thus, if D∈MBR, ⟨tki,ci⟩≤0 ∀i∈[1,2w]. The probability of returning the point is negligible if D is not inside the range.

Example. We show the correctness by an instance. For simplicity, we set ΩP([1,2,3,4])=[4,1,2,3] and the pair {M,M˜}:
M=⎛⎝⎜⎜⎜11−304−231−1−1−4−1−11−2−1⎞⎠⎟⎟⎟,M˜=⎛⎝⎜⎜⎜48−2106−2−108−62−4614−140−42⎞⎠⎟⎟⎟.
View SourceWe have two points (i.e., D1=(1,2) and D2=(3,4)) and a range query (i.e., MBR=([2,4],[1,5])). We encrypt D1 and D2 by using Encrypt(SK,D). Assume that rv=9 for D1 and rv=2 for D2. Then we can get C1 and C2:
C1C2=⎛⎝⎜⎜⎜522162−828234162−54−144−162522414−576738468−72−990414⎞⎠⎟⎟⎟=⎛⎝⎜⎜⎜184312−176320316380−312636684948−6081500324−52−372−16⎞⎠⎟⎟⎟.
View SourceWe encrypt the range query MBR by using GenToken(SK, MBR). Assume that rp=3 and δ=77, we can get a search token TK:
TK=⎛⎝⎜⎜⎜738−1800193213384302−2652338410864329−3372411317971587−211228231569⎞⎠⎟⎟⎟.
View Source

By executing Query(TK, C), we can easily get the following result: Query(TK,C1)→0, Query(TK,C2)→1. Obviously, the result is in line with the fact, i.e., D1∉MBR and D2∈MBR.

3.3 Range Intersection Predicate Encryption (RIPE)
Based on IPC, we propose a new Range Intersection Predicate Encryption (RIPE) to check whether two MBRs intersect. We begin with the 1-dimensional case. For two ranges R=[xl,xr] and R′=[x′l,x′r], we find that there exists a true proposition:
R∩R′≠∅⇔p=(xl−x′r)(xr−x′l)≤0.
View SourceRight-click on figure for MathML and additional features.

Similarly, add the perturbation to the predicate, and we can obtain
pˆ=(xl−x′r)(xr−x′l)(xr+δ),(7)
View Sourcewhere δ is also a positive random number. In the same way, we express the predicate as query and value vectors as follows:
p=⎛⎝⎜⎜⎜xr+δ−x2r−xrδ−xlxr−xlδxlxr(xr+δ)⎞⎠⎟⎟⎟,v=(x′lx′r,x′r,x′l,1)T.
View Source

In the same way, we design the 1dRIPE, and further extend it to the multi-dimensional case. As shown in Algorithm 2, the wdRIPE is to check whether two multi-dimensional ranges intersect based on the fact that if two MBRs intersect, the range of each dimension will intersect, and vice versa:
MBR∩MBR′≠∅⇔pi=(xi,l−x′i,r)(xi,r−x′i,l)≤0
View Source

where MBR=(R1,…,Rw), Ri=[xi,l,xi,r], MBR′=(R1′,…,Rw′), and Ri′=[xi,l′,xi,r′], ∀i∈[1,w].

Using IPC, the correctness proof of wdRIPE is similar to that of wdPIPE.

Algorithm 2. wdRIPE
– Setup(1κ). On input a security parameter κ, output a secret key SK={M,M˜,ΩR}.

– Encrypt(SK,MBR′). On input SK and an MBR′=(R′1,…,R′w), where R′k=[x′k,l,x′k,r], output ciphertext C=rv(ΩR([M˜v1,…,M˜v2w])), where rv is a generated random positive number, for i∈[1,2w],

vi={(x′i,lx′i,r,x′i,r,x′i,l,1)T,(ri,1,ri,2,ri,3,ri,4)T,i≤wi>w,
View Source

where ri,j is a random positive number for 1≤j≤4.

– GenToken(SK,MBR). On input SK and a range query MBR=(R1,…,Rw), where Rk=[xk,l,xk,r], output search token TK=rp(ΩR([MTp1,…,MTp2w])), where rp is a random positive number, for i∈[1,2w],

pi=⎧⎩⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎛⎝⎜⎜⎜⎜xi,r+δ−x2i,r−xi,rδ−xi,lxi,r−xi,lδxi,lxi,r(xi,r+δ)⎞⎠⎟⎟⎟⎟,(r′i,1,r′i,2,r′i,3,r′i,4)T,i≤wi>w,
View SourceRight-click on figure for MathML and additional features.

where r′i,j is a random negative number for 1≤j≤4.

– Query(TK, C). On input TK and C, output 1 iff ⟨tki,ci⟩≤0,∀i∈[1,2w], or output 0 otherwise.



Example. We use the same {M,M˜} as in Section 3.2, and set ΩR([1,2,3,4])=[2,3,4,1]. We have two MBRs (i.e., MBR′1=([1,4],[1,3]) and MBR′2=([5,6],[2,3])) and a range query (i.e., MBR=([2,4],[1,5])). We encrypt MBR′1 and MBR′2 by using Encrypt(SK,MBR′). Assume that rv=4 for MBR′1 and rv=3 for MBR′2, then we can get C1 and C2:
C1C2=⎛⎝⎜⎜⎜15224−16072368−272−128−92821640−3606419248−208144⎞⎠⎟⎟⎟=⎛⎝⎜⎜⎜13296−1501624026−474−108252−168−336−336420672−4201008⎞⎠⎟⎟⎟.
View SourceWe encrypt the range query MBR by using GenToken(SK, MBR). Assume that rp=5 and δ=55, we can get a search token TK:
TK=⎛⎝⎜⎜⎜−30048009002700325−8551230450185−2710212511758854130885−2655⎞⎠⎟⎟⎟.
View Source

By executing Query(TK, C), we can easily get the following result: Query(TK,C1)→1, Query(TK,C2)→0. Obviously, the result is in line with the fact, i.e., MBR∩MBR′1≠∅ and MBR∩MBR′2=∅.

SECTION 4Tree-Based Private Range Query Over Encrypted Cloud Data
Based on the building blocks PIPE and RIPE, we can present our TRQED formally.

4.1 TRQED Construction
To perform private range query, TRQED searches the R-tree index through the four polynomial algorithms (Setup,EncIndex,GenToken,Query), which are presented as follows.

Setup(1κ). On input a security parameter κ, the data owner generates a secret key SK={SKpoint, SKnode,SKdata}, where
SKpoint←SKnode←SKdata←wdPIPE.Setup(1κ),wdRIPE.Setup(1κ),AES(1κ).
View SourceRight-click on figure for MathML and additional features.

EncIndex(SK,D). On input the SK and dataset D, the data owner builds an R-tree I={D1,…,Dn, N1,…,Nm}, where {Di}ni=1 is a data point associated with a leaf node, and {Nj}mj=1 is a node. Then data owner encrypts every node and data point separately as follows:
Ci←Ej←wdPIPE.Encrypt(SKpoint,Di),wdRIPE.Encrypt(SKnode,Nj).
View Sourcewhere {Ci}ni=1 is an encrypted data point, and {Ej}mj=1 is an encrypted node. The data records are encrypted as follows:
D∗i←AES.encrypt(SKdata,Di),for 1≤i≤n.
View Source

Afterwards, the data owner outsources the encrypted index I∗={C1,…,Cn, E1,…,Em} and dataset D∗ to the cloud server.

GenToken(SK, Q). On input the SK and a range query Q, the owner generates a search token TK={TKpoint,TKnode}, where
TKpoint←TKnode←wdPIPE.GenToken(SKpoint,Q),wdRIPE.GenToken(SKnode,Q).
View SourceThen TK is distributed to authorized users and submitted to the cloud.

Query(TK, I∗). On input the TK and I∗, the cloud server searches tree I∗ level-by-level as follows:

For a non-leaf node Ej, if wdRIPE.Query(TKnode, Ej) is true, it continues to search the child nodes of Ej; otherwise it stops searching this branch.

For a leaf node Ej′, if wdRIPE.Query(TKnode, Ej′) is true, it continues to search the data points set associated with the node Ej′; otherwise it stops searching this branch.

For a data point Ci, if wdPIPE. Query(TKpoint,Ci) is true, that indicates Di∈Q, and it puts the identifier Ii of this point into the list IDQ.

Finally, the server returns a set IDQ of identifiers of matched data records, and the user obtains the results.

Correctness. The correctness of TRQED is based on the correctness of wdPIPE and wdRIPE. Formally, for all κ∈N, let SK←RSetup(1κ), I∗←REncIndex(SK,D), TK←RGenToken(SK,Q). If Di∈Q,
Pr[Query(TK,I∗)=IDQ,Ii∈IDQ]=1.
View SourceRight-click on figure for MathML and additional features.
If Di∉Q,
Pr[Query(TK,I∗)=IDQ,Ii∈IDQ]≤negl(κ),
View Source

where negl(κ) is a negligible function in κ. Thus, Query(TK, I∗) returns Ii if and only if Di∈Q.

Example. Fig. 2 depicts an example of R-tree and its encryption. The data owner builds an R-tree I={D1,…,D8,N1,…,N6}, and uses the secret key to encrypt it. For a range query Q submitted by the user, the data owner sends corresponding search token TK={TKpoint,TKnode} to the user. The user submits TK to the cloud, and the latter executes Query(TK, I∗). We assume that the traversal process on the unencrypted R-tree I is {N2}→{N5,N6}→{D6,D7}. Based on the correctness of wdPIPE and wdRIPE, the traversal process on I∗ is {E2}→{E5,E6}→{C6,C7}, i.e., Query(TK, I∗) returns IDQ={I6,I7}. Then, the cloud server sends {D∗6,D∗7} to the user, and the latter uses SKdata to decrypt {D∗6,D∗7} to obtain data records.


Fig. 2.
An example of R-tree and its encryption.

Show All

4.2 Data Update
TRQED can support basic data dynamics in range query processing. We assume that each time one record update is processed, and the fan-out of the R-tree is big enough so that TRQED does not split or merge a non-leaf node in the tree. Let us recall the data layout in R-tree [13]. R-tree organizes data in pages, i.e., nodes correspond to disk pages. The maximum number of entries in each node (i.e., fan-out) is approximately equal to PAGE_SIZEENTRY_SIZE. Currently, PAGE_SIZE is typically 4096 bytes. Therefore, the above assumption is reasonable.

4.2.1 Insertion
To insert a new record D¯, we should find the leaf node of R-tree that contains this tuple. That is, the algorithm needs to traverse the index by testing whether a point (i.e., D¯) is inside an MBR of the node, which is based on equality query. Roughly speaking, equality query is a specific type of range query. For a new data record D¯=(d¯1,…,d¯w), it can be expressed as a range MBR¯¯¯¯¯¯¯¯¯¯¯=(R¯1,…,R¯w), where R¯j =[d¯j,d¯j], for 1≤j≤w. Then the data owner computes an update token TKπ with GenToken(SK,MBR¯¯¯¯¯¯¯¯¯¯¯) of wdPIPE and wdRIPE. After receiving the token and C¯ generated by wdPIPE.Encrypt(SKpoint,D¯), the cloud server searches the R-tree until it finds the leaf node E¯ that contains D¯. Afterwards, the server just inserts this tuple into the points set of leaf node E¯, and puts the encrypted record into D∗.

4.2.2 Deletion
To delete a data record, the algorithm should search for its location in the R-tree index. Specifically, it first finds the leaf node that contains the record, and then checks whether a data point is equal to the record. Given the record D′, the owner submits the deletion token TKπ similarly with the above MBR¯¯¯¯¯¯¯¯¯¯¯. The token consists of (TK¯¯¯¯¯¯¯¯point,TK¯¯¯¯¯¯¯¯node), which enables the server to locate the record D¯. Then the cloud server deletes D¯, and deletes the corresponding encrypted record.

4.2.3 Modification
Data modification is considered as a combination of deletion of old value and insertion of new value [9]. The server just needs to perform one deletion and insertion to modify a record, and thus we omit the details here for brevity.

The UpdToken and Update are defined as follow:

UpdToken(SK,π,MBR¯¯¯¯¯¯¯¯¯¯¯). On input SK, update option π∈ {insertion, deletion, modification}, and a target record MBR¯¯¯¯¯¯¯¯¯¯¯=(R¯1,…,R¯w), where R¯j=[d¯j,d¯j], the owner outputs a token TKπ=(TK¯¯¯¯¯¯¯¯point,TK¯¯¯¯¯¯¯¯node), where
TK¯¯¯¯¯¯¯¯point←TK¯¯¯¯¯¯¯¯node←wdPIPE.GenToken(SKpoint,MBR¯¯¯¯¯¯¯¯¯¯¯),wdRIPE.GenToken(SKnode,MBR¯¯¯¯¯¯¯¯¯¯¯).
View Source

Update(TKπ, I∗, C¯). On input the token TKπ, the index I∗, and ciphertext of the record C¯, where C¯=wdPIPE.Encrypt(SKpoint,D¯), the cloud server outputs a new I∗ and updates the D∗.

If π=insertion, call Query(TK¯¯¯¯¯¯¯¯node, I∗) and find the leaf node E¯ where C¯∈E¯. Insert the data point C¯ in the points set of leaf node E¯, and add encrypted record into D∗.

If π=deletion, call Query(TK¯¯¯¯¯¯¯¯¯, I∗) to find the data point C¯. If yes, delete C¯ from the R-tree, and delete encrypted record from D∗.

If π=modification, first perform the deletion operation, and then perform insertion operation.

4.3 Security Analysis
The security guarantees stated above ensure that nothing beyond the access pattern, search pattern and path pattern should be leaked. We first prove the intersection predicate encryption is indistinguishably secure. Then we adopt the simulation-based security model [16], [21], [22] to prove that TRQED is secure under known background model.

Lemma 1.
The intersection predicate encryption schemes are semantically secure if the encrypted messages are indistinguishable.

Proof.
We just have to prove that the probability for the probabilistic polynomial-time (PPT) adversary to break the encrypted messages of IPE schemes (i.e., PIPE and RIPE) is negligible. Suppose the challenger runs Setup(1κ) to generate an intersection encryption system SK, and a PPT adversary A submits two messages m0 and m1. The challenger randomly chooses b∈{0,1}, encrypts mb with SK, and sends the ciphertext to A. Then the adversary A takes a guess b′ of b. Recall with the perturbation-based matrix encryption, a random number is used each time, thus transforming a plaintext into varied ciphertext with the same key. It is easy to conclude that A cannot guess b correctly with a probability higher than 1/2. Thus the advantage in the security game is AdvIPE,A(κ)=|Pr[b=b′]−12|<negl(κ). Moreover, considering the invertible matrix is random, it is difficult to be cracked, as there are an infinite number of key pairs. Thus we say that the IPE schemes are semantically secure.

The indistinguishability of encrypted vectors and tokens is based on the indistinguishability of the pseudo-random number and perturbation-based matrix encryption, so that the index privacy is preserved. Based on Lemma 1, we analyze the security of TRQED.

Theorem 1.
TRQED is secure against semi-honest adversaries under the known background model.

Before proving the Theorem 1, we introduce some notions used in [22] and adapt them for our proof.

History: an interaction between the user and cloud server, determined by a dataset D, a searchable index I and a set of queries Q=(q1,…,qτ) submitted by users, denoted as the knowledge H=(D,I,Q).

View: the encrypted form of H under the secret key SK, denoted as V(H), i.e., the encrypted dataset D∗, the secure index I∗, and the search tokens TK(Q). Note that the cloud server can only see the views.

Trace: given a history H, the trace Tr(H) is the information which can be learned by the cloud server. It contains the access pattern α(H), search pattern σ(H), path pattern δ(H) and the returned identifiers ID(Q). Let ID(q) be the set of identifiers of the matched data records, and α(H)={ID(q1),…,ID(qτ)}. Let P(q) be the set of identifiers of the matched nodes in I, and δ(H)={P(q1),…,P(qτ)}. The search pattern σ(H) is an n×τ binary matrix where σ(H)i,j is 1 if Ii is returned by a query qj, and 0 otherwise. Then we have Tr(H)={ID(Q),α(H),σ(H),δ(H)}.

Under known background model, we assume the server obtains the Tr(H), and a certain number of queries and its probability pairs (qi,pi). Informally, given two histories with the same trace, if the server with the distribution of queries cannot distinguish which view of them is generated by the simulator, he cannot learn additional knowledge beyond what we are willing to leak (i.e., the trace), and thus our solution is secure.

Proof.
Let S be a simulator that can simulate a view V′ indistinguishable from the cloud server’s view V(H)={D∗,I∗,TK(Q)}. To achieve this, the S does the following:

To generate D′, S selects a random D′i∈{0,1}|D∗i|, D∗i∈D∗, 1≤i≤|D∗|, and outputs D′={D′i,1≤i≤|D∗|}.

S randomly picks an invertible matrix M′1,M′2∈R4×4. Set SK′={M′1,M′2}.

To generate I′(D′), S first generates a vector of 2w elements for each v′i∈I′(D′), 1≤i≤|I∗| as the index, then does the following:

For each element of v′i, S replaces it with a four-dimensional vector (ri,1,…,ri,4)T, where ri,k is a random number for 1≤i≤n,1≤k≤4.

S encrypts each v′i with the M′2, and obtains I′(D′)={EncSK′(v′i),1≤i≤|I∗|}.

S constructs the query Q′ and the search tokens TK(Q′) as follows. For each q′i∈Q′, 1≤i≤τ,

Generates a vector of 2w elements, denoted as u′i, and replace each element with a four-dimensional vector (r′i,1,…,r′i,4)T, where r′i,k is a random number for 1≤i≤n,1≤k≤4. Output Q′={q′i,1≤i≤τ}.

Generate the search token for each q′i by encrypting u′i with M′1 from SK′ for 1≤i≤τ. Then S obtains EncSK′(Q′)={EncSK′(q′1),…,EncSK′(q′τ)}.

S outputs the view V′=(D′,I′(D′),TK(Q′).

The correctness of such construction is easy to demonstrate by querying TK(Q′) over I′(D′). The index I′(D′) and the token TK(Q′) generate the same trace as the one that the cloud server has. We claim that no PPT adversary can distinguish the view V′ from V(H). Specifically, due to the semantic security of IPE and AES, no PPT adversary can distinguish the D∗ from D′. Moreover, the PPT adversary with the query and probability pairs cannot distinguish which tokens are generated from the same query because of the indistinguishability of random perturbation-based comparison predicate, so that it cannot exploit the distributions of plain and encrypted queries to deduce information. Thus Theorem 1 holds.

SECTION 5TRQED+ With Enhanced Security
Our TRQED scheme achieves faster-than-linear search and supports dynamic operations while preserving the query and single-dimensional privacy, simultaneously. However, it should be pointed out that this scheme is weak in terms of preserving single-dimensional privacy. Although we have extended the number of dimensions from w to 2w, the cloud server can still deduce which dimensions are for dummy data at a high probability by statistical analysis of the intersecting results of wdPIPE.Query and wdRIPE.Query. Besides, we ignore access pattern, search pattern and path pattern in order to ensure high efficiency. Unfortunately, through analyzing these informations, the cloud server may be able to deduce some useful information about the data and queries [11], [23]. So, in this section, we target at a safer design, called TRQED+.

It is helpful to make use of Private Information Retrieval (PIR) [24] or Oblivious RAM (ORAM) Protocol [25] to address the issues of access pattern and search pattern. However, for practical applications, both PIR and ORAM suffer from the effectiveness issue. In order to ensure effectiveness and practicality, we intentionally ignore access pattern and search pattern. Naturally, we focus on preserving path pattern and stronger single-dimensional privacy through effective design.

5.1 System Model With Two Cloud Servers
In order to achieve our design goals, we add a cloud server to the original system model illustrated in Fig. 1. Therefore, the modified system model consists of a data owner, two cloud servers and multiple authorized users, as depicted in Fig. 3. The two servers are denoted as S1 and S2, respectively. We assume that S1 and S2 are non-colluding and semi-honest. Such an assumption is reasonable and has been widely used in related research fields [26], [27], [28]. The companies that provide cloud services, such as Google and Amazon, are legitimate and well-established. A collusion will damage their reputation.


Fig. 3.
Architecture of TRQED+ with two cloud servers.

Show All

Similarly, the data owner first builds index (i.e., I) and encrypts the index (i.e., I∗) and data (i.e., D∗). The data owner divides the encrypted index I∗ into two parts, encrypted index nodes {E1,…, Em} and encrypted data points {C1,…,Cn}, and sends them to S1 and S2, respectively. Simultaneously, the data owner outsources the encrypted data set D∗ to S2. In the query phase, an authorized user sends the query range to the data owner and obtains the search token (i.e., TK={TKpoint,TKnode}). Similarly, the user submits TKpoint and TKnode to S1 and S2, respectively. On receiving the search token, S1 and S2 cooperatively perform the query task.

5.2 Modified PIPE and RIPE
As mentioned above, extending dimension cannot fully preserve single-dimensional privacy. We will exploit a flexible matrix column random-permutation in our new design. Thus, we do not have to extend dimensions. Specifically, for wdPIPE and wdRIPE, we modify ciphertext C and search token TK as follows:
CTK=rv(M˜v1,…,M˜vw)=rp(MTp1,…,MTpw).
View SourceWe call the modified algorithms wdPIPE+ and wdRIPE+.

5.3 Oblivious R-Tree Traversal
Inspired by the traversal path obfuscation in [29], we design an oblivious R-tree traversal (ORT) on the basis of the original scheme to preserving path pattern and single-dimension privacy. In our new design, cloud servers S1 and S2 cooperatively execute a query without sacrificing path pattern and single-dimension privacy.

5.3.1 Secure Scalar Product
Before describing ORT, we introduce a basic secure multi-party computation (SMC) protocol, called secure scalar product (SSP) protocol. In [30], Atallah et al. first put forward the scalar product protocol to solve the scalar product problem, defined as follows.

Definition 1.
(Scalar Product Problem). Alice has a vector x=(x1,…,xn) and Bob has a vector y=(y1,…,yn). Alice (but not Bob) is to get the result of u=x⋅y+v where v is a random scalar known to Bob only.

For the usual scalar product computation, let v=0 in Definition 1. SSP protocol is diffusely studied in data mining, information retrieval and other fields [31], [32]. Diverse approaches have been proposed in accordance with different settings. In this paper, we adopt the approach proposed in [32] to achieve the secure intersection operation.

5.3.2 Secure Intersection Operation
First, we present a secure intersection (SI) operation. We consider a ciphertext C and a range query TK which are defined in both wdPIPE and wdRIPE algorithm. C and TK are both 4×w matrices, so we define C=(c1,…,cw) and TK=(tk1,…,tkw), where ci and tki are the column vectors. We assume that Alice has TK and Bob has C. They can execute secure intersection operation through obfuscating the two matrices as follows:

Phase 1: At the beginning of this phase, Bob has ciphertext C, and Alice has search token TK. Then,

Bob obfuscates C by w random diagonal matrices {R1,1,…,R1,w} and a permutation function Ωw.
C′=Ωw((R1,1c1,…,R1,wcw))=(c′1,…,c′w).
View SourceRight-click on figure for MathML and additional features.

Alice obfuscates TK by w random diagonal matrices {R2,1,…,R2,w}.
TK′=(R2,1tk1,…,R2,wtkw)=(tk′1,…,tk′w).
View Source

Bob and Alice exchange C′ and TK′.

Phase 2: At the beginning of this phase, Bob has TK′, and Alice has C′. Similarity,

Bob obfuscates TK′ as follows:
TK′′=Ωw((R−11,1tk′1,…,R−11,wtk′w))=(tk′′1,…,tk′′w).
View Source

Alice obfuscates C′ as follows:
C′′=(R−12,1c′1,…,R−12,wc′w)=(c′′1,…,c′′w).
View Source

Now, Bob and Alice obtain obfuscated token TK′′ and ciphertext C′′, respectively. For 1≤i≤w, Bob and Alice can cooperatively calculate ⟨tk′′i,c′′i⟩ through above-mentioned SSP protocol. It’s simple to prove that,
⟨tk′′i,c′′i⟩≤0,∀i∈[1,w]⇔⟨tki,ci⟩≤0,∀i∈[1,w].
View SourceRight-click on figure for MathML and additional features.

5.3.3 Secure Query Based R-Tree
In our new scheme, data owner divides the encrypted index I∗ into two parts, i.e., {E1,…, Em} and {C1,…,Cn}, which are sent to S1 and S2 respectively. Moreover, authorized users submit TKpoint to S1 and TKnode to S2. Naturally, the query process will also be divided into two parts, i.e., node query and point query.

Note that tree traversal is executed according to the level iteratively. For level h∈[1,H], S1 has node set O and S2 has range query token TKnode. In order to achieve a secure query between S1 and S2, we present a secure node query (SNQ) operation.

SNQ operation is described as follows:

S1 first generates a random perturbation function Ω and adopts it to obfuscate the order of nodes in O. We denote perturbed O by O. The purpose of adopting perturbation function is to obfuscate S2’s view.

For perturbed node set O, S1 (as Bob in SI) uses {R1,1,…,R1,w} and Ωw to obfuscate each node of O according to Phase 1 of SI, and the obfuscated result is denoted as O′. Similarly, S2 (as Alice in SI) obfuscates TKnode and then gets TK′node. Afterwards, S1 and S2 exchange O′ and TK′node.

Once receiving TK′node from S2, S1 can immediately get TK′′node according to Phase 2 of SI. For each node of O′, S2 first checks its flag. If the check result is true, S2 continues to process it according to Phase 2 and then gets the intersecting result by employing SSP protocol; otherwise, current node is impossible to intersect with the query range. After processing all node of O′, S2 gets the intersecting result set.

S2 sends the intersecting result set to S1. S1 recovers the order of the results by exploiting the inverse perturbation function Ω−1 and then assigns the results to corresponding children.

The above SNQ operation is repeated until the leaf level. After processing leaf nodes, S1 sends the intersecting results to S2. According to the results, S2 knows which data point sets intersect with the query range. Next, S2 needs to query these point sets. Similarly, we present a secure point query (SPQ) operation by employing the above-mentioned SI operation.

SPQ operation is described as follows:

For point set P, S2 (as Bob in SI) uses {R2,1,…,R2,w} and Ωw to obfuscate each point of P according to Phase 1 of SI, and the obfuscated result is denoted as P′. Similarly, S1 (as Alice in SI) obfuscates TKpoint and gets TK′point. Then S2 and S1 exchange P′ and TK′point.

Once receiving TK′point from S1, S2 can immediately get TK′′point according to Phase 2 of SI. For each point of P′, S1 processes it according to Phase 2. We denote obfuscated point set by P′′.

S1 and S2 use TK′′point to query every point of P′′ by employing SSP protocol, and S2 gets the query result.

5.3.4 Flag Encryption
In our new scheme, S2 needs to send the intersecting results of every level to S1, so that the latter can assign the results to the corresponding child nodes. However, S1 should not know the exact information of the results (i.e., flag equals 0 or 1). In other words, S2 has to encrypt the intersecting results. We use Paillier cryptosystem [33] to ensure that S1 cannot learn the intersecting results. Specifically, at the beginning of the query processing, S2 generates a key pair {pk,sk} and sends the public key pk to S1. Before sending the intersecting results to S1, S2 uses pk to encrypt them. On the other hand, after assigning the encrypted results to child notes, S1 multiples the flag of every child node by 0^ (encrypted form) to obfuscate S2’s view. S2 can check the encrypted flag by decrypting it with the secret key sk.

5.3.5 Oblivious R-Tree Traversal Algorithm
Now, we can summarize the oblivious R-tree traversal (ORT) algorithm. The details of ORT are presented in Algorithm 3.

Algorithm 3. ORT
– Setup(1κ). On input a security parameter κ, S2 generates a key pair {pk,sk} for flag encryption. Moreover, S1 and S2 randomly generates {R1,1,…,R1,w} and {R2,1,…,R2,w}, respectively, where R1,i and R2,j are diagonal matrices without zero diagonal elements.

– PaiEpk , PaiDsk. Encryption function and decryption function in Paillier cryptosystem.

– SNQ(O, TKnode). For h∈[1,H], S1 has node set O of level h and S2 has query token TKnode. S1 and S2 execute above-mentioned secure node query operation. Note that the flags of nodes are initialized to PaiEpk(1) when h=1.

– SPQ(P, TKpoint). S2 has query token TKnode and S1 has candidate point set P. S1 and S2 execute above-mentioned secure point query operation.

5.4 TRQED+ Construction
Adopting aforementioned oblivious R-tree traversal, we propose a tree-based private range query scheme over dynamic encrypted cloud data with enhanced security guarantees. As same as TRQED, TRQED+ consists of four polynomial algorithms (Setup,EncIndex,GenToken,Query). We present them as follows.

Setup(1κ). The data owner generates a secret key SK={SKpoint, SKnode,SKdata}.

EncIndex(SK,D). As similar as TRQED, the data owner builds an R-tree I={D1,…,Dn, N1,…,Nm} and then encrypts the index and data as follows:
Ci←Ej←D∗i←wdPIPE+.Encrypt(SKpoint,Di),wdRIPE+.Encrypt(SKnode,Nj),AES.encrypt(SKdata,Di).
View SourceRight-click on figure for MathML and additional features.Afterwards, the data owner outsources {E1,…, Em} and {C1,…,Cn} to the cloud servers S1 and S2, respectively. Simultaneously, the data owner outsources the encrypted dataset D∗ to S2.

GenToken(SK, Q). The data owner generates a search token TK={TKpoint,TKnode}, where
TKpoint←TKnode←wdPIPE+.GenToken(SKpoint,Q),wdRIPE+.GenToken(SKnode,Q).
View SourceRight-click on figure for MathML and additional features.Then TK is distributed to authorized users. Then users submit TKpoint and TKnode to S1 and S2, respectively.

Query(TK, I∗). On input the TK and I∗, the cloud servers S1 and S2 cooperatively perform a secure range search as follows:

By executing ORT.Setup(1κ), S2 generates a key pair {pk,sk} and {R2,1,…,R2,w}, and S1 generates {R1,1,…,R1,w}. Then, S2 sends pk to S1.

S1 and S2 cooperatively execute ORT.SNQ(O, TKnode) iteratively until the leaf level. On receiving the intersecting results of leaf nodes, S1 uses the inverse perturbation function to recover the order of the results. Then S1 multiplies them by ORT.PaiE(0) and then sends these results to S2. By using ORT.PaiD(⋅) to decrypt these results, S2 learns which point sets are candidates.

For candidate point set P, S1 and S2 cooperatively execute ORT.SPQ(P, TKpoint). According to the design of algorithm ORT.SPQ(⋅), S2 will get the point query results. If a data point Ci belongs to the query range, S2 puts the identifier Ii of this data point into the list IDQ.

Finally, the cloud server S2 returns a set IDQ of identifiers of matched data records, and the user obtains the results.

5.5 An Example of Query
For a better understanding of TRQED+, we describe the query process in detail through the example of Fig. 2. The same as TRQED, the data owner builds and encrypts R-tree in TRQED+. The user submits range query Q, and receives corresponding search token TK={TKpoint,TKnode} from the data owner. However, the query process in TRQED+ is quite different from that in TRQED. The data owner outsources {E1,…,E6} and {C1,…,C8} to S1 and S2, respectively. The user with query Q submits TKpoint and TKnode to S1 and S2, respectively. Then, we describe the traversal process layer by layer.

h=1 (root, non-leaf layer): S1 initializes the flags of {E1,E2} to {1^,1^} (encrypted form). According to SNQ, S1 can get obfuscated search token TK′′node, and S2 can get obfuscated candidate nodes {E′′2,E′′1}. By employing SSP protocol, S2 obtains the intersecting result set {1,0}. After that, S2 encrypts and sends the flag set {1^,0^} to S1, who then recovers the order of the flags and assigns them to corresponding child nodes.

h=2 (leaf layer): S1 multiples the flag of each node by 0^ to obfuscate S2’s view, which is equivalent to the addition operation on the plaintext domain. Therefore, the flags of nodes N3,N4,N5,N6 are {0^,0^,1^,1^}. According to SNQ, S1 obfuscates these nodes, and sends {N′6(1^),N′4(0^),N′3(0^),N′5(1^)}. After that, S2 can get candidate nodes {N′′6,N′′5} by checking flags. By employing SSP protocol, S2 obtains the intersecting result set {1,1}. Then, S2 encrypts and sends the flag set {1^,0^,0^,1^} to S1. Afterwards, S1 recovers the order of the flags, and gets {0^,0^,1^,1^}.

Data points layer: Similarly, for each encrypted flag, S1 multiples it by 0^ to obfuscate S2’s view, and then sends the flag set to S2. By decrypting these flag, S2 gets the candidate point set P={C5,C6,C7,C8}. S1 and S2 cooperatively execute ORT.SPQ(P, TKpoint), and S2 gets the results {0,1,1,0}.

Finally, S2 sends {D∗6,D∗7} to the user, and the latter uses SKdata to decrypt {D∗6,D∗7} to obtain data records.

5.6 Analysis
5.6.1 Correctness Analysis
As stated in SI (see Section 5.3.2), for a ciphertext C and a search token TK, SI can guarantee that,
⟨tk′′i,c′′i⟩≤0,∀i∈[1,w]⇔⟨tki,ci⟩≤0,∀i∈[1,w].
View Source

Therefore, Our modifications do not affect the correctness of the original scheme TRQED. In other words, the correctness of TRQED+ is based on the correctness of TRQED. And the correctness of TRQED has been proved in Section 4.1. Hence, the query results are correct.

5.6.2 Security Analysis
Compared with basic TRQED, TRQED+ performs the oblivious tree traversal operation during the query processing. Inherited from TRQED scheme, it’s easy to prove that the TRQED+ scheme can protect data privacy, index privacy and query privacy under the known background model. Next, we show that ORT operation can protect path pattern and single-dimensional privacy.

Path Pattern Privacy. During searching each level of R-tree, we adopt SSP protocol in secure intersection operation so that S1 is unable to know the intersecting results between nodes and query token. Although knowing intersecting results, S2 cannot distinguish the nodes that are obfuscated by S1. Specifically, before sending node set O of each level to S2, S1 uses perturbation function Ω to obfuscate the order of nodes in O. As a result, S2 is unable to learn the true traversal path. Hence, neither S1 nor S2 can learn which nodes match the query token. For every query, {R1,1,…,R1,w} and {R2,1,…,R2,w} are independently generated by S1 and S2, respectively. And perturbation function Ω and Ωw are always regenerated when they are used. Hence, an oblivious R-tree traversal algorithm can protect path pattern under known background model.

Single-Dimensional Privacy. For node query and point query during the query process, we adopt SNQ operation and SPQ operation, respectively. As we have analysed above, only S2 is allowed to know the intersecting results, and S2 cannot distinguish the nodes that are obfuscated. Moreover, S1 adopts perturbation function Ωw to obfuscate the order of all columns of each matrix. In other words, S1 and S2 cannot obtain the exact search results for any single-dimensional query. Similarly, In SPQ, for each data point, two cloud servers are not able to exactly know which dimensions match the range of the requested query. Therefore, ORT can fully prevent single-dimensional privacy leakage.

5.7 TRQED+-Based Data Update
Though TRQED+ executes range query by two servers, it still supports basic dynamic operations in range query processing. As the same as TRQED, we assume that each time a record is updated, no splitting or merging is incurred. The main idea of TRQED+-based data updating is similar to that of TRQED. Data modification is considered as a deletion followed by an insertion. The detailed description is as follows.

Insertion. For a new data record D¯ that needs to be inserted, we express it as a range MBR¯¯¯¯¯¯¯¯¯¯¯. First, the data owner computes an update token TKπ=TK¯¯¯¯¯¯¯¯node. Then the data owner sends TKπ, C¯ and the encrypted data record to the cloud server S2. Once receiving them, S2 searches the R-tree with the cooperation of cloud server S1 until it finds the leaf node E¯ that contains D¯. S2 puts the encrypted record into D∗, and inserts C¯ and identifier of encrypted record into the correct point set.

Deletion. Given the record D¯, the owner submits the deletion token TKπ={TK¯¯¯¯¯¯¯¯point,TK¯¯¯¯¯¯¯¯node}. The cloud server S2 locates the record D¯ with the cooperation of S1. Then S2 deletes C¯, together with its corresponding encrypted record and identifier.

SECTION 6Evaluation
We evaluate the performance of our schemes on a real-world (REAL) dataset from the U.S. census bureau dataset [34]. The REAL dataset consists of 299,285 records with more than 20 attributes. We chose a number of records (from 20,000 to 100,000) to construct our datasets with needed dimensionality, and built R-tree indexes on each REAL dataset. (Note here that we do not limit the size of the dataset. Under the premise of ensuring the validity of the experiment, a lager dataset will get the similar evaluation result.) The data owner, user and cloud servers are all set on desktop computers with 3.20 GHz CPU and 4 GB RAM. We adopt GMP library and AES CTR mode for data encryption, and set the security parameter κ at 128 and bit length l of each attribute at 32. For performance evaluation, we focus on overhead and efficiency as the schemes are proved to have a high search accuracy, which we omit for space reasons. 100 queries are executed and their average costs are reported.

6.1 Overhead and Efficiency of TRQED
We first discuss the performance of TRQED, which mainly includes overhead and efficiency. Compared to TRQED+, TRQED fails to preserve path pattern and stronger single-dimensional privacy, but has higher search efficiency.

6.1.1 Setup
To set up the system, the data owner first encrypts all nodes of the R-tree index, of which each node requires about O(w) matrix-vector multiplications and bits. Here we are interested in the encryption overhead ignoring tree construction cost. As shown in Figs. 4a and 4b, the costs of index encryption is increasing with the number of dimensions w and data records n, as the TRQED should encrypt each non-leaf node of R-tree with RIPE and each leaf node with PIPE. That is, TRQED trades off the setup time and storage cost for improvement of the search efficiency.


Fig. 4.
Setup and token generation cost: (a) R-tree index encryption time versus n with dimensions w=2,4,6; (b) Total storage cost versus n with w=2,4,6; (c) Token generation time versus w with n=100,000.

Show All

6.1.2 Token Generation
We evaluate the experimental results of generating search tokens in Fig. 4c. The time of token generation per query is linearly increasing with the number of dimensions w, as TRQED needs to spend additional time to generate tokens in the added dimensions.

6.1.3 Search
We can see from Fig. 5a the impact of w and n on the search time per query. The search time shows a logarithmic increase trend as n increases, as the cloud server searches the R-tree level-by-level honestly to check whether the node satisfies Query(TK,I∗)=true. If fixing n, the cost shows a linear trend with the dimensions w, as the amount of inner product computations at each node increases with w. This verifies search time is linear with the number of dimensions and the height of R-tree. In Fig. 5b, it can be seen that the average communication cost is linear with w, n has little effect, as the communication cost is composed of the generated search tokens and matched records.


Fig. 5.
Search efficiency: (a) Search time versus n with w=2,4,6; (b) Communication cost versus w with n=60,000,100,000.

Show All

The efficiency of data update is similar to that of the search phase, as the update operation is essentially fulfilled through search. The detailed results are omitted due to space limitation. Roughly speaking, the insertion and deletion operations require about the same computation, while the modification needs about the double computation overhead.

6.2 TRQED versus Prior Art
We compare our TRQED with the existing protocols, i.e., BonehW [7], LSED+ [9], WangR [10], and Maple [11] in terms of privacy and data dynamics. As for efficiency, BonehW [7] fails to achieve faster-than-linear search and LSED+ [9] achieves efficiency at the price of revealing ordering information and compromising privacy which makes it be impractical. Therefore, we focus our efficiency comparison on WangR [10] and Maple [11], which are practical and represent the state-of-the-art multi-dimensional range query schemes.

6.2.1 Privacy and Data Dynamics
We compare the privacy guarantees and data dynamics support of the four related schemes and our TRQED, as shown in Table 1. As for the query and single-dimensional privacy, LSED+ and WangR preserve the query privacy and do not provide single-dimensional privacy. BonehW and Maple preserve the single-dimensional privacy and fail in query privacy. In contrast, our TRQED preserves both the query privacy and single-dimensional privacy. However, TRQED is weak in terms of preserving single-dimensional privacy. Although we have extended the dimension w to 2w dimensions, the cloud server can still deduce which dimensions are dummy data at high probability by statistical analysis of intersecting results of wdPIPE.Query and wdRIPE.Query. As to data dynamics, only LSED+ and our TRQED can provide data update while the other three schemes do not support.

TABLE 1 Comparison Among Different Solutions

6.2.2 Efficiency
The experimental results of search efficiency are depicted in Fig. 6a with n varying from 20,000 to 100,000. They all show an increasing trend as n increases. Fig. 6b illustrates the search time of the three schemes are all linearly increasing with w. By contrast, the time cost of TRQED is slightly smaller than that of WangR because of the smaller coefficient of the time complexity. Compared with Maple, TRQED and WangR are much faster than Maple, as Maple relies on public-key cryptography and the impact of domain limit T cannot be ignored. Thus, the proposed TRQED is more efficient.

Fig. 6. - 
Performance comparison: (a) Average search time of the schemes versus $n$n with $w = 2$w=2; (b) Average search time versus $w$w with $n = 100,000$n=100,000.
Fig. 6.
Performance comparison: (a) Average search time of the schemes versus n with w=2; (b) Average search time versus w with n=100,000.

Show All

From the above comparison, we can conclude TRQED has a better performance than prior art. It has a comparatively desirable overhead.

6.3 Performance of TRQED+
In terms of system architecture, TRQED+ is very different from TRQED. To improve the security, TRQED+ uses two non-collusion cloud servers. For comparison, we evaluate three algorithms, which are BASIC, TRQED and TRQED+.

6.3.1 Enhanced Security
Compared with TRQED, TRQED+ provides stronger privacy guarantees, as shown in Table 1. TRQED can preserve single-dimensional privacy to a certain extent. However, the cloud server can use statistical analysis to guess which dimensions are dummy. By executing SNQ and SPQ operations, TRQED+ can perform a search task while preserving single-dimensional privacy. Furthermore, TRQED fails in path pattern privacy, as with many existing arts. The oblivious R-tree traversal operation designed in TRQED+ can assure that path pattern will not be revealed to cloud servers.

6.3.2 Search Efficiency
For evaluating the performance of TRQED+, we add a BASIC solution to the comparison. Briefly, BASIC performs the SPQ operation to check all data points encrypted by wdPIPE+ without any tree structure. As shown in Fig. 7, the search time of three algorithms are all increasing with data records n. Conspicuously, TRQED shows the best search performance. Compared with others, TRQED is about 200 times faster than TRQED+ and 2000 times faster than BASIC, as the latter two solutions use dual-server architecture with large communication time cost. Nevertheless, TRQED+ and BASIC with more complex operations can better preserve single-dimensional privacy. Moreover, compared with BASIC, TRQED+ can not only greatly improve the search efficiency by using R-tree structure, but also avoid path pattern being revealed during the traversal process.

Fig. 7. - 
Performance comparison: Average search time of the schemes versus $n$n with $w = 2$w=2.
Fig. 7.
Performance comparison: Average search time of the schemes versus n with w=2.

Show All

SECTION 7Related Work
Our work is related to prior art in two aspects: searchable encryption and range query.

Searchable Encryption. The issue of secure query processing on encrypted cloud data has been studied in recent years. An ideal approach is using ORAM [25]. However, the efficiency of ORAM is a huge concern for real applications. Traditional Searchable Encryption (SE) schemes [2], [35] have been put forward to support simple types of queries, but directly deploying them would not be adequate for practical use. Wong et al. proposed a SCONEDB model [20], which achieved secure kNN query over encrypted vector databases. Li et al. [4] proposed an authorized private keyword search framework. Subsequently, researchers studied the privacy-preserving multi-keyword ranked search [5], fuzzy search [6], and verifiable search [36]. However, the researches only support keyword searches or single-dimensional range queries, which cannot be applied to the complex multi-dimensional range queries.

Range Query. Papadopoulos et al. [37] studied range queries in authenticated data structures while the privacy requirements are not considered. In [38], Kawamoto et al. proposed a private range query approach at the price of much more memorizing space. By using HVE, BonehW [7] designed a public-key query system to support multi-dimensional range queries over encrypted data. However, the scheme incurs high computation due to heavy reliance on public-key cryptography, and cannot protect query privacy. To improve query efficiency, [9] and [10] aimed to achieve faster-than-linear search time. However, as mentioned before, these two schemes would cause single-dimensional privacy leakage. To protect single-dimensional privacy, [11] proposed a scheme Maple based on HVE and R-trees. As a public-key scheme, it suffers from heavy computation and fails to provide query privacy. Afterward, the authors proposed a symmetric-key MDRSE [39], which achieves faster-than-linear search, query privacy and single-dimensional privacy simultaneously. However, it should know all the range domain sizes of the dimensions in advance, and thus cannot support data update effectively. Furthermore, the client of the schemes who outsources database should be the one that searches, which is different from our private range query model.

SECTION 8Conclusion
In this paper, we have studied the problem of multi-dimensional private range queries over dynamic encrypted cloud data. Our proposed TRQED is the first private range query scheme that achieves faster-than-linear search and supports data dynamics while preserving the query privacy and single-dimensional privacy simultaneously. Furthermore, we also extended our design based on TRQED scheme. To achieving a higher privacy protection level, we have designed oblivious R-tree traversal and proposed TRQED+, the security-enhanced version of TRQED. Perturbation-based ORT operation can prevent servers from learning path pattern during the search of R-tree. On the other hand, exploiting SSP protocol in SNQ and SPQ can achieve stronger single-dimensional privacy preservation.

However, we should point out that there are two main unsolved challenges, i.e., splitting or merging of nodes, and access pattern on an encrypted database. Our schemes support data dynamics on condition that the updating data do not split or merge a non-leaf node in R-tree. Moreover, the cloud server could learn the access pattern during executing range queries. We hope these challenges will be overcome in future work.