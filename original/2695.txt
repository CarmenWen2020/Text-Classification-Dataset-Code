Piecewise Linear Approximation (PLA) is one of the most widely used approaches for representing a time series with a set of approximated line segments. With this compressed form of representation, many large complicated time series can be efficiently stored, transmitted and analyzed. In this article, with the introduced concept of “semi-connection” that allowing two representation lines to be connected at a point between two consecutive time stamps, we propose a new optimal linear-time PLA algorithm SemiOptConnAlg for generating the least number of semi-connected line segments with guaranteed maximum error bound. With extended experimental tests, we demonstrate that the proposed algorithm is very efficient in execution time and achieves better performances than the state-of-art solutions.
SECTION 1Introduction
A time series is a sequence of data points, each represented by a real number, arranged according to its time sequence. This form of data can be extracted from many fields, including medical and commerce. A good compression strategy for such data can greatly reduce data storage size, expedite data transmission and even improve query efficiency [16], [19].

There are many methods to compress a time series. These include Discrete Wavelet Transform [16], Symbolic Mapping [18], Histograms [19] and Piecewise Linear Approximation (PLA) [10], [12], [13], etc. PLA is a fundamental research problem and has been extensively studied for decades under different criteria. The basic idea of PLA is to represent a time series with a number of straight lines so that the original time series can be precisely approximated and more efficiently processed. In this article, we shall study this problem bounded with maximum error in approximation. This can be expressed as follows.

The Problem. Let P=(p1,…,pn) be a time series and δ be an error bound. We use Si=(psi,psi+1,…,pei) to denote the fragment of P of time slot [si,ei] (si<ei≤n). The problem L∞-bound PLA is to divide P into k fragments S1,S2,…,Sk; where each fragment Si=(psi,psi+1,…,pei) (i∈{1,2,…,k}, ps1=p1, pei+1=psi+1 and pek=pn) can be approximated by a linear function (i.e., segment) fi(t) satisfying the pre-defined error bound of
|fi(t)−pt|≤δ,(1.1)
View Sourcewhere the domain of t is
⎧⎩⎨⎪⎪t∈[s1,ei+1)t∈(si−1,ei+1)t∈(si−1,ei]i=1,1<i<k,i=k.
View SourceA linear function that satisfies Equation (1.1) for the data points of Si is called a (feasible) representation or segment1 of Si. We call it connected L∞-bound PLA (or simply, connected) if there exist connected linear representations, i.e., fi(ei)=fi+1(si+1) holds for each i (1≤i≤k−1) (Fig. 1 ii). Otherwise, it is called disconnected (Fig. 1i). The segmentation result is called optimal if the number of constructed segments (or fragments) k is minimum. Furthermore, the segmentation result is called semi-connected L∞-bound PLA (or simply, semi-connected) if fi(xi)=fi+1(xi) where ei≤xi≤si+1 holds2 for each i (1≤i≤k−1) (Fig. 1 iii). Conceptually, semi-connection is an extension of connection mentioned above.


Fig. 1.
The disconnected/connected/semi-connected segments.

Show All

In this article, we shall propose an optimal linear-time L∞-bound PLA algorithm for constructing semi-connected segments.

Related Work. On the research of L∞-bound PLA, Rourke, et al. [15] proposed the first optimal disconnected linear-time PLA algorithm in 1981. Recently, Xie, et al. [21] gave another completely different optimal method for the same problem.3 The general idea of their approaches [15], [21] is to adjust each segment to approximate the greatest number of data points. To do this, their methods need to determine the range of all feasible segments and incrementally update it for a consecutive data point. Whenever a new point cannot be approximated by a segment within the error bound, a new segment begins. In the process of determining the range of feasible segments, the algorithm of Rourke [15] maintains a convex polygon in the slope-offset space while DisConnAlg [21] maintains two minimized (partial) convex hulls in the time-value space (time domain) progressively. Generally, these partial convex hulls are much smaller in size than that of a convex polygon. As a result, DisConnAlg not only achieves a speed of up to 4 times faster, but a lower memory cost of 27 percent on the tested data sets. DisConnAlg generates the minimum number of line segments through the “forward-checking” strategy that maximally extends each “local” segment in the forward direction. Furthermore, at the end of the article [21], Xie, et al. also indicate that the idea of DisConnAlg can be used to construct connected line segments through the construction of next segment using the feasible region of the previous segment.4 We denote this algorithm that generates connected segments in [21] as XieConnAlg in this article.

For the construction of connected segments, there were many heuristic algorithms in literature. Liu, et al. [13] proposed an Feasible Space Window (FSW) algorithm to construct connected segments from a fixed initial point. Qi, et al. [20], [22] extended FSW from straight-line segments to curve (polynomial) segments. Combining the ideas of DisConnAlg and XieConnAlg, Zhao, et al. [23] presented a linear time algorithm (denoted as ConnSegAlg) which outperforms FSW and XieConnAlg by generating fewer connected segments. However, it is difficult to directly convert XieConnAlg and ConnSegAlg of [21], [23] to build an optimal connected representation, especially in linear time complexity. For example, ConnSegAlg may lead to readjusting all previously generated segments to guarantee that the current segment reaches the maximum possible time stamp. This could require both higher costs in time and storage. Through scrutinizing the whole process, we have found that the problem can be simplified if we allow two consecutive segments to be connected between two time tags. That is, two segments semi-connect at a point of interval [ti,ti+1] (Fig. 1 iii).

In fact, this research problem of constructing optimal semi-connected segments5 was first solved by Imai and Hakimi, et al. [7], [8]. Hakimi, et al. [7] proposed an online method by searching the shortest path in a constructed “pipeline”: Any line in the “pipeline” can guarantee that the reconstructed points is within a pre-defined error bound. The idea of “pipeline” is originally from Suri [25] for finding a minimum-link monotone polygonal chain within a simple polygon. In 2015, with the idea of [7], [15], Luo, et al. [14] designed an online PLA algorithm, which is termed as PipeMixedAlg in this article, to construct mixed (i.e., semi-connected and disconnected) segments to minimize the storage size for the outputs. It is a dynamic programming (DP) algorithm that embraces a clever “early-output technique” to quickly extract part of the optimal solution from the DP to make the algorithm online. As a byproduct, PipeMixedAlg can be modified to obtain a linear-time PLA algorithm, which is referred to as PipeOptConnAlg6 in this article, for generating semi-connected segments under the prescribed maximum error bound.

There were also many PLA research upon variant error criterions [26], [27], [28], [29], [30] in computational geometry. These research results are either infeasible or less obvious to be used for generating semi-connected segments with linear time complexity. For example, Egyed, et al. [26] proposed a linear time algorithm for constructing one straight line stabbing a series of convex objects with maximum error bound. Agarwal, et al. [28] proposed a nonlinear time algorithm for solving connected PLA problem in x-monotone polygonal chains. In streaming setting, Abam, et al. [29] discussed the “restricted” line simplification problem with Fréchet Distance. In the end of [27], Guibas, et al. proposed a theoretical greedy algorithm to compute an “unrestricted” minimum link chain of fatten objects with disjointing. Different from the “pipeline” methodology, this theoretical result is derived from some structural properties of convex objects, which is quite similar to the mechanism of our proposed algorithm. At the end of their article, the authors raised an open problem on how to design an efficient implementation as their future work. From their results, it is still not clear how to obtain a linear-time semi-connected PLA algorithm.

There were many other research focused on constructing a pre-defined (or the smallest) number of straight line segments with minimal (or with pre-defined) holistic errors (i.e., L2-norm) between the data points in the original time series and the corresponding data points in the representation lines, respectively. These include Top-down, Bottom-up [9] and evolutionary algorithms [4]. Bellman, et al. [2] proposed an optimal algorithm for online processing which used the dynamic programming framework to minimize the holistic approximation error recursively as new data points are introduced. Due to the time complexity of O(kn2) where k is the number of segments and n is the whole length of the time series, this algorithm is expensive for processing large data. As such, some heuristic strategies were suggested to improve the efficiency of data processing. This was evident in the Sliding Window (SW) algorithm [1] and improved SW (SWAB) [9].

To generate L2-norm representations as in SW or SWAB, the number of processed data points needs to be fixed. Let k be the fixed-window size. Since a data stream is naturally unbounded in size, those constructed representations with SW or SWAB were not error-guaranteed on each individual data point and their approximation qualities were unjustified for the given error bound on a k-sized sliding window which was moving from the very left of the time series to the right. Consequently, this means that these algorithms would be insufficient in obtaining error-guaranteed analytical results for the given error bound [5], [6]. Furthermore, although any two adjacent disconnected segments can be connected using an added naive segment to link them, the total number of segments (storage) is far from the smallest (optimal). For example, as stated in Section 4, the average storage cost for the outputs of PipeOptConnAlg is about 67 percent of that DisConnAlg in all tested situations.

Our contributions. The contributions of this article can be summarized as follows:

A new algorithm SemiOptConnAlg that constructs the optimal number of semi-connected segments within a given error bound in L∞ was proposed. This algorithm processes data streams progressively with linear time complexity and extremely low memory requirement. Different from the “pipeline” based algorithm like PipeOptConnAlg, SemiOptConnAlg is designed in the time-value space and optimized according to a series of reduction properties.

We tested on 43 data sets arbitrarily selected from a public domain [11] to verify our theoretical conclusions by comparing SemiOptConnAlg with DisConnAlg and PipeOptConnAlg in terms of time costs, memory costs, the number of constructed segments (storage), the sensitivity of δ values on error bound, and the scalability on data size. The results show that: SemiOptConnAlg has achieved lower time and memory costs and outputs the minimum number of semi-connected segments. The storage and representation lines outputted by SemiOptConnAlg are exactly the same as PipeOptConnAlg. Its scalability evaluations on time costs, maximum space usage and varied maximum errors outperform that of PipeOptConnAlg.

The rest of the article is organized as follows: Section 2 is the preliminaries; Section 3 gives the detailed method and the proofs on properties; Section 4 is the experimental results, including the performance comparisons among DisConnAlg, PipeOptConnAlg and SemiOptConnAlg; Section 5 concludes this article. Table 1 summarizes all the symbols frequently used throughout this article.

TABLE 1 Notations

SECTION 2Preliminary
In this section, we provide a more focused discussion on how the methods of DisConnAlg [21], ConnSegAlg [23] and PipeOptConnAlg [14] relate to the discussed problem.

DisConnAlg is an optimal linear time algorithm for constructing disconnected segments for time series. To minimize the number of generated segments, it ensures that each segment approximates the highest number of data points. This is done by incrementally adjusting the range of all feasible lines in the process of adding consecutive points. Whenever no feasible lines can approximate the new point within the error bound, the construction process is stopped and a new line segment begins. In the process of generating a segment, two extreme lines7 which represent the bounds of all feasible lines are iteratively updated as new data is introduced. To efficiently update the extreme lines, two “convex hulls” are incrementally maintained to avoid the extensive search cost. More specifically, suppose that S=(p1,p2,…,pn) is a fragment constructed from DisConnAlg and let u[1,k+1] and l[1,k+1] be the slope (gradient) of the upper and lower extreme lines when pk is approximated for k∈{1,…,n−1}. Then, from [21],
⎧⎩⎨⎪⎪⎪⎪⎪⎪l[1,k+1]u[1,k+1]==maxpi¯¯¯¯¯∈cvx¯¯¯¯¯¯¯¯(k){(yk+1−δ)−(yi+δ)(tk+1−ti),l[1,k]},minpi––∈cvx––––(k){(yk+1+δ)−(yi−δ)(tk+1−ti),u[1,k]},(2.1)
View SourceRight-click on figure for MathML and additional features.

where cvx¯¯¯¯¯¯¯¯(k) and cvx––––(k) are the set of convex points of {pa¯¯¯¯¯,…,pd¯¯¯¯¯} and {pb––,…,pc––}, respectively. The extreme points pa, pb, pc and pd are defined by
⎧⎩⎨⎪⎪⎪⎪⎪⎪{a,c}{b,d}==argmin1≤i<j≤k(yj−δ)−(yi+δ)(tj−ti),(a<c),argmin1≤i<j≤k(yj+δ)−(yi−δ)(tj−ti),(b<d).(2.2)
View Source

To update the extreme lines for a new data point, these convex hulls need to be maintained. Since the number of points in the convex hulls can be significantly smaller than the total number of data points in the relevant intervals, the convex hulls can be efficiently updated using the triangle check technique of [3] through recursively examining the three most recent consecutive points and then propagating backwards. When updating the upper/lower convex hull, if the middle point is above/below or on the line formed by the other two points, then the middle point is removed. This process is continued for the remaining three most recent consecutive points until the middle point is no longer being removed.

Fig. 2 illustrates the process of updating the extreme lines and convex hulls. Initially, both the extreme lines and convex hulls are from points p1 and p2 (Fig. 2i). When the next point pk+1 is introduced, we use Theorem 2 from [21] and Equation (2.1) to determine the new extreme lines u[1,k+1] and l[1,k+1]. As seen in Figs. 2 ii and 2 iii, the new convex hulls cvx¯¯¯¯¯¯¯¯(k+1) and cvx––––(k+1) can be constructed by removing the earliest point in cvx––––(k) and deleting the two latest points in cvx¯¯¯¯¯¯¯¯(k), respectively.

Fig. 2. - 
The process of updating extreme lines and convex hulls.
Fig. 2.
The process of updating extreme lines and convex hulls.

Show All

DisConnAlg has been used for constructing connected segments in XieConnAlg. To make segment Si+1 connect to segment Si, XieConnAlg employs DisConnAlg to build Si+1 beginning from the last data point pei of Si within the restricted region of two extreme lines of Si at tei (i.e., feasible region) as seen in Fig. 3i. To further minimize the number of connected segments, ConnSegAlg [23] uses two strategies, “backward-checking” and “length-checking”, to build connected segments. As denoted in Fig. 3, “backward-checking” is used to check and decide if the current (pending) segment8 constructed from DisConnAlg can be connected to the previous segment. Since DisConnAlg is an optimal algorithm, if the check succeeds, the current segment reaches the farthest data point and can approximate the data with the largest possible time stamp. Otherwise, it indicates that the last data point of this segment cannot be approximated with a single segment that connects to its previous segment. Whereas “length-checking” is to ensure if two connected segments constructed by XieConnAlg [21] can stretch further (i.e., larger time stamp) than the single segment generated by DisConnAlg and output the two connected segments if it is true. Otherwise, a trivial segment is added to connect the two disconnected parts.


Fig. 3.
The idea of “backward-checking” and “length-checking”.

Show All

As mentioned above, the “backward-checking” strategy only checks a single earlier point in the backwards direction. This is insufficient for obtaining an optimal solution. As indicated in Fig. 4i, the pending segment can intersect at an earlier time stamp. In this figure, “backward-checking” fails at point pe1, and the two disconnected segments are connected at point pe1−1. Similarly, the “length-checking” strategy is not designed to make the second connected segment reach the farthest possible point. As depicted in Fig. 4 ii, suppose that points pe1+1 and ps3 are checked by the “length-checking” strategy. There may exist a point p′s3 between pe1+1 and ps3 that makes the further point p′e3 approximated.

Fig. 4. - 
Insufficiency of previous strategies.
Fig. 4.
Insufficiency of previous strategies.

Show All

Motivated from the above issues on “backward-checking” and “length-checking”, we introduce the concept of “semi-connectivity” for representing a time series with the smallest number of semi-connected segments. The semi-connected line segments are the connected lines that are not restricted to be connected at exact time indexes. Our general idea is to construct a pended segment that is semi-connected to the closest earlier segment and, at the same time, approximates the “furthest” possible successive data point (i.e., the data point with largest time tag). In next section, we shall show that this “locally maximal” property can be obtained by shrinking and extending a pending segment in the forwards and backwards directions.

Almost all existed algorithms on constructing optimal semi-connected segments, such as PipeOptConnAlg, are “pipeline” based. Its main idea is: (1) Construct a polygon between up-boundary and low-boundary; (2) Search the furthest visible window within this polygon; (3) Output the line intersecting the adjacent visible windows as a segment. For two point p and q, let the linear function passing through p and q be linep,q(t)=line(p,q). As depicted in Fig. 6, we initialize window w1 to be the line with p1–– and p1¯¯¯¯¯ as endpoints. To construct a polygon, let up-boundary bu1(t)=linep1¯¯¯¯¯,p2¯¯¯¯¯(t) and low-boundary bl1(t)=linep1–––,p2–––(t). For i>1, set
⎧⎩⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪bui(t)=max(linepi¯¯¯¯¯,pi+1¯¯¯¯¯¯¯¯¯(t),min(linepi−1––––,pi¯¯¯¯¯(t),linepi+2––––,pi+1¯¯¯¯¯¯¯¯¯(t))),bli(t)=min(linepi––pi+1––––(t),max(linepi−1¯¯¯¯¯¯¯¯¯pi––(t),linepi+2¯¯¯¯¯¯¯¯¯pi+1––––(t))).
View SourceRight-click on figure for MathML and additional features.To get window w2 from w1 from the polygon, it needs to construct two convex hulls from up-boundary and low-boundary of the polygon, respectively. The two convex hulls are then maintained for point p5. Window w2 is determined by the extreme lines of two convex hulls [14]. At this time, the region on the right of w2 is not shined by w1. Iteratively construct wi from wi−1 until the time series is ended.

Fig. 5. - 
Semi-connectivity.
Fig. 5.
Semi-connectivity.

Show All


Fig. 6.
The main idea of PipeOptConnAlg.

Show All

SECTION 3Optimal Semi-Connected Algorithm
Suppose we have the first two segments S1 and S2 constructed by DisConnAlg [21]. These two segments are “locally maximal” which reaches the furthest possible data points. If S2 can not semi-connect to S1, S2 needs to be shrunk by deleting the latest data point and extended backwards. This process is repeated until S2 semi-connects to S1. Lemma 3.1 confirms that the modified S2 is locally maximal as it approximates the “furthest” possible successive data point. By repeating the above process and updating S2, we can construct two semi-connected segments.

Let S′k+1=(ps′k+1,…,pe′k+1) be the (k+1)th pending segment constructed by DisConnAlg. With the above steps, S′k+1 is “transformed” to Sk+1=(psk+1,…,pek+1) which semi-connects to segment Sk by repeatedly removing its end point and adding an earlier point in Sk. Generally, tsk+1≤ts′k+1 and tek+1≤te′k+1 hold. In Lemma 3.1, we will show that it needs at least k+1 semi-connected segments to approximate time series P=(p1,p2,…,pek+1). As such, we say that this constructed Sk+1 is “locally maximal” and approximates the “furthest” possible data point. For example, in Fig. 5i, the start and end time stamp of the (k+1)th pending segment S′k+1 are ts′k+1 and te′k+1, respectively. After Sk+1 is built by deleting pe′k+1 and extending psk+1, the end time stamp of Sk becomes t1, sacrificing a data point psk+1 for semi-connecting to Sk+1. At this stage, Sk+1 reaches the “furthest” possible data point.

3.1 Construct Semi-Connection Using Extreme Lines
Suppose that we have constructed semi-connected segments S1, S2,…, and Sk. Let Sk+1 be the pending segment generated by DisConnAlg starting at data point pek+1. Let the extreme lines of Sk and Sk+1 be lk, uk and lk+1, uk+1, respectively. In the following, we will show how to update Sk+1 to semi-connect Sk via extreme lines.

Fig. 5 ii depicts the structure of Sk from three aspects: (1) The extreme lines lk and uk represent the lower and upper representation lines of Sk to semi-connect Sk−1; (2) pcvxk––––– and pcvxk¯¯¯¯¯¯¯¯¯¯¯ are on lk and uk, respectively; (3) Sk cannot approximate the data point psk+1 as it is located either below lk or above uk.

The following reduction property is to locate the feasible representations of Sk and Sk+1 for semi-connection. It indicates that a feasible representation line of Sk+1 is semi-connected to a feasible representation line of Sk if and only if lk+1 is semi-connected to lk (or uk+1 is semi-connected to uk) according to the locations of psk+1.

Property 3.1.
Let rk and rk+1 be any feasible representation lines of Sk and Sk+1, respectively.

When psk+1 is located below lk, Sk+1 is semi-connected to Sk if and only if rk+1 is semi-connected to lk, and the intersection point of rk+1 and lk is not on the left side of data point pcvxk–––––.

When psk+1 is located above uk, Sk+1 is semi-connected to Sk if and only if rk+1 is semi-connected to uk, and the intersection point of rk+1 and uk is on the left side of data point pcvxk¯¯¯¯¯¯¯¯¯¯¯.

The proof of Property 3.1 is quite straightforward. First, the extreme lines of lk and uk are the special cases of representation line rk. Second, if the intersection point of rk and rk+1 is before (i.e., on the left side of) pcvxk––––– (or pcvxk¯¯¯¯¯¯¯¯¯¯¯), then the approximation error of rk+1 at point pcvxk––––– (or pcvxk¯¯¯¯¯¯¯¯¯¯¯) is above the predefined tolerance and contradicts to the hypothesis that rk+1 is a representation line.

In the process of deciding semi-connection, Property 3.1 implies that only one extreme line and its data points on the right side of pcvxk––––– (or pcvxk¯¯¯¯¯¯¯¯¯¯¯) in Sk need to be examined. However, the selection of which extreme lines are used as representations merely depends on the location of the start point of the next segment. Therefore, we use status=(a,b), where a,b∈{up,down}, for the selection of representative extreme lines in SemiOptConnAlg. We define operation “!” as: if a is down (or up), then !a is up (or down). Once status=(a,b) is instantiated, the selected semi-connected extreme lines from Sk+1 and Sk are decided (and vice versa).

Example 1.
Suppose three segments S1, S2 and S3 are semi-connected. Let ui, li, psi and pei be the upper and lower extreme line, the start point and the end point of segment Si, respectively. One way of choosing semi-connected extreme lines is shown in Fig. 7

Fig. 7. - 
The patterns of status.
Fig. 7.
The patterns of status.

Show All

. If b=“down” in status=(a,b) of S2, then semi-connected representation line r2 is set to be the lower extremes line l2 of S2, or else set r2 to be u2.
One remaining question, which will be discussed next, is how to set the values of status prior to the process of constructing semi-connected segments. This is very important for the efficiency of SemiOptConnAlg, as without it, the number of updated extreme lines can be much more than needed.

Without loss of generality, let interl and interu be the intersection points of lk+1 and uk+1 with lk, respectively. The steps of constructing a semi-connected segment from Sk+1 can be summarized into the following three cases:

Case 1. Both extreme lines of Sk+1 are semi-connected to Sk. Under this situation: (i) For any feasible representation lines rk of Sk and rk+1 of Sk+1, rk+1 is semi-connected to rk; (ii) status=(a,b) is determined by the positions of data points psk+1 and psk+2 (i.e., the start points of next segments). For example, if psk+1 is above (up) line uk and psk+2 is below (down) line lk+1, then status=(up,down) with a=“up” and b=“down”.

In Figs. 8i and 8 ii, both lk+1 and uk+1 can be used to approximate the points in Sk that are located after interl and interu, respectively. In Fig. 8i, since psk+1 is below (down) line lk and psk+2 is above (up) line uk+1, status=(down,up) holds. Therefore, the selected representations are lk and uk+1 in this situation. Similarly, if status=(down,down), the selected representations are lk and lk+1 as shown in Fig. 8 ii.

Case 2. Only one of the extreme lines of Sk+1 is semi-connected to Sk. In this situation, we would extend the segment Sk+1 built from DisConnAlg backwards. This can be done by repeatedly adding the last data point of Sk into Sk+1. The extreme lines and the convex hulls of Sk+1 can be updated by the Equations (2.1) and (2.2) backwardly. This process updates the extreme line of Sk+1 that was not semi-connected to Sk into a semi-connected line.


Fig. 8.
Sk and Sk+1 in Case 1 and Case 2.

Show All

In Fig. 8 iv, lk+1 can approximate the points in Sk that are located after interl. In this situation, uk+1 is neither intersected with lk nor approximated to the last point in Sk that is located after interu. The updated uk+1 (denoted as u′k+1) intersect with lk at point inter′u and u′k+1 can approximate the last point in Sk located after inter′u. If status=(down,up), we select the updated extreme line u′k+1 as the representation line, making it “closer” to the next segment.

It should be noted that uk+1 would be neither selected as a representation nor used to construct any representations if status=(down,down). Under this situation, uk+1 does not need to be updated as it will not affect the selection of semi-connected representations. Thus, as shown in Fig. 8 iii, we select the extreme line lk+1 as the representation line.

Like the situation of Case 1, status=(a,b) is determined by the positions of data points psk+1 and psk+2.

Case 3. Both extreme lines of Sk+1 are not semi-connected to Sk. To make Sk+1 semi-connected to Sk, Sk+1 need to be shrunk from the side of data arrival and extended backwardly to see if the updated Sk+1 is semi-connected to Sk. If not, the procedure is repeated until the updated Sk+1 satisfies the condition described in Case 2. From Property 3.2, status=(a,b) is determined by the value of its first parameter. That is, if psk+1 is above (up) line uk, then psk+2 is below (down) line lk+1.

In Fig. 9, both lk+1 and uk+1 cannot semi-connect to lk when Sk+1 covers the data point psk+2−1. After shrinking (removing) the data point psk+2−1 from Sk+1, the updated extreme line l′k+1 is intersected with lk and it can be used to approximate the data point pek. At this time, uk+1 is not changed and Case 3 is converted into Case 2. Note that status=(down,down) is updated into status=(down,up) as confirmed by Property 3.2.

Fig. 9. - 
$S_k$Sk and $S_{k+1}$Sk+1 in Case 3.
Fig. 9.
Sk and Sk+1 in Case 3.

Show All

Property 3.2.
Suppose that Sk+1 is not semi-connected to Sk. Then status=(up,down) or status=(down,up).

Proof.
We only illustrate on the condition of status=(down,up). The proof for status=(up,down) is very similar to that of status=(down,up).

Since psk+1 is below (down) line lk and lk+1 is not semi-connected to Sk, the process of removing the last data point pek+1 of Sk+1 and extending Sk+1 backwards can decrease the slops of lk+1 and uk+1. Again, since the lower extreme line of trivial segment St=(pek,pek+1) is always semi-connected to Sk, there exist a minimum number h>0 such that the extreme lines of S′=(psk+1,psk+1+1,…,pek−h) are semi-connected to Sk. Let u′ be the upper extreme line of S′. Since data point pek−h+1 is in Sk+1 but not in S′, pek−h+1 is located above (up) line u′, leading to status=(down,up).

As mentioned in Case 1 and Case 2, status=(a,b) is determined by the positions of data points psk+1 and psk+2, which, in turn, is determined by Sk and Sk+1; the disjoint segments generated from DisConnAlg of [21]. From the above statement, status=(a,b) can be instantiated after Sk and Sk+1 are built. However, it must be before the process of the semi-connection check or the update of Sk+1. While in Case 3, status=(a,b) can be instantiated after Sk+1 being built and the semi-connection check with Sk+1.

In summary, we have the following conditions for Case 2 and Case 3. This suggests that the decision of Case 2 or Case 3 can be done by checking one extreme line. Subsequently, status=(a,b) can be instantiated by checking one extreme line.

Extension strategy: In Case 2, Sk+1 needs to be extended backwards.

This strategy exists in Case 2 if (i) psk+1 is below lk and lk+1 is semi-connected to lk, or (ii) psk+1 is above uk and uk+1 is semi-connected to uk.

Shrinking strategy: In Case 3, Sk+1 needs to be shrunk from the last data point and then extended backwards. This strategy exists in Case 3 if (i) psk+1 is below lk and lk+1 is not semi-connected to lk, or (ii) psk+1 is above uk and uk+1 is not semi-connected to uk.

3.2 Algorithm
In the following, we explain the pseudo code of SemiOptConnAlg (Algorithm 1). The outline of Algorithm 1 is summarized into the following steps.

(Lines 1-5). Construct the first disconnected segment (S,u,l,ts,te) by DisConnAlg in which S is the segment, l and u are lower and upper extreme lines of S, ts=t1 and te are the start and end time stamps of S. Set the number of semi-segment k=1. Based on the position of data point pte+1 that is relevant to u or l, initialize status=(a,b) and extrm (the selected extreme line). Set a=ϕ, b=down, and extrm=l if pte+1 located below line l. Set b=up, extrm=u if pte+1 located above line u. Set inter0 to be the point of extrm at time t1 and store it.

(Lines 6 and 7). Construct the disconnected segment (S′,u′,l′,t′s,t′e) by DisConnAlg starting from t′s=te+1 as the current pending segment.

(Lines 8-12). This part is relevant to Case 3. In Case 3, none of the extreme lines of l′ and u′ are semi-connected to the previous segment. Our strategy is to transform Case 3 to Case 2 or Case l.

The shrinking and extending process as described in Case 3 will be conducted. Thus, p′e will be updated to be the shrunk time tag and p′s will be updated to be the extended time tag. Based on Property 3.2, update status as a=b,b=!a. Go to Step 4.

If it is not Case 3, go to Step 4.

(Lines 13-17). This part is relevant to Case 2. In Case 2, only one of the extreme lines of l′ and u′ are semi-connected to the previous segment.

The extending process is conducted as described in Case 2. p′s is updated to be the extended time tag and p′e is not changed. Based on the position of data point pt′e+1 that is relevant to u′ or l′, update status, i.e, set a=b and b=down if pt′e+1 located below line l′ or b=up if pt′e+1 located above line u′. Go to Step 6.

If it is not Case 2, go to Step 5.

(Lines 18-20). This part is relevant to Case 1 where both extreme lines of l′ and u′ are semi-connected to segment S. According to Property 3.1, it implies that both extreme lines of l′ and u′ are semi-connected to extreme line l or extreme line u, respectively. Based on the position of data point pt′e+1 that is relevant to u′ or l′, update status, i.e, set a=b and b=down if pt′e+1 located below line l′ or b=up if pt′e+1 located above line u′.

(Lines 21-31). If b=down in status, store the intersection point interk of l′ and extrm, and update extrm=l′. If b=up in status, store the intersection point interk of u′ and extrm, and update extrm=u′. Update k=k+1 and te=t′e.

Repeat the above from Step 2 for the last segment until all data points have been processed. Output the stored data.

3.3 Properties
In the following, we first prove that SemiOptConnAlg is optimal which generates the least number of semi-connected segments. We then measure the storage and the actual running time of SemiOptConnAlg and DisConnAlg. Lastly, we briefly indicate that SemiOptConnAlg and PipeOptConnAlg can generate the exact same representing segments.

To prove SemiOptConnAlg is optimal, we need the following lemma. It says that each currently generated segment in SemiOptConnAlg reaches the farthest possible data point by preserving semi-connectedness.

Algorithm 1. Function SemiOptConnAlg (P,δ)
Input:

time sequence P=(p1,p2,…,pn,…), error bound δ

Output:

The semi-connected points (inter0,inter1,inter2,…)

Description

Use DisConnAlg to generate the first segment (S,u,l,ts,te) in which S is the segment, u and l are lower and upper extreme lines of S, ts and te are the start and end time stamps of S

Set the number of segments k=1

Set extrm: if pte+1 is under l, then set extrm to be l. Otherwise, set extrm to be u

Set status: a=Φ, b=down if pte+1 located below line l or b=up if pte+1 located above line u.

Store the intersection inter0 of extrm at time tag t1.

while (not finished segmenting time series) do

Use DisConnAlg to generate the next disconnected segment (S′,u′,l′,t′s,t′e) in which S′ is the segment, u′ and l′ are lower and upper extreme lines of S′, t′s=te+1 and t′e are the start and end time stamps of S′

if (Case 3) then

do “Shrinking strategy”

Update t′e and t′s

Update status by a=b,b=!a

end if

if (Case 2) then

do “Extending strategy”

Update t′e and t′s

Update status according to the position of data point pt′e+1 that relevant to u′ or l′.

end if

if (Case 1) then

Update status according to the position of data point pt′e+1 that relevant to u′ or l′

end if

if (b==Down) then

Store the intersection point interk of l′ and extrm

update extrm=l′

end if

if (b==Up) then

Store the intersection point interk of u′ and extrm

update extrm=u′

end if

k=k+1

te=t′e

end while

Lemma 3.1.
Given a time series P=(p1,p2,…,pn) and an error bound δ. Let S1,S2,…,Sk be the semi-connected segments constructed up to point pek from SemiOptConnAlg where ek<n. That is, Sk is semi-connected with Sk−1 but it cannot approximate data point pek+1.

Proof.
Clearly, the claims are true for k=1 as S1 is maximum and constructed from DisConnAlg. Suppose that the claims are true for k<h where h>1. We prove the claims are true for k=h in the following.

If the lemma does not hold true for k=h, we assume that there exists an optimal semi-connected solution S′=(S′1,S′2,…,S′m) where e′m=eh+1 and m≤h hold for the last data point pe′m of S′m.

From the hypothesis stated above, let S~h−1 be the (h−1)th segment constructed from SemiOptConnAlg before the construction of Sh (i.e., S~h−1 is the segment of Sh−1 without shrinking). For the last data point pe~h−1 of S~h−1, according to the assumption and the hypothesis, eh−1≤e~h−1, e′m−1≤e~h−1 and h−1≤m−1 hold. Therefore, h=m holds.

On the other hand, since the set of data points of Sh is a subset of S′h, S′h can semi-connect to S~h−1. The segment constructed by DisConnAlg started from point pe~h−1+1 can reach point peh+1 and can semi-connect to S~h−1, which is contradictory to the hypothesis that point pek+1 is not in Sk. Thus, the claims are proven.

Theorem 3.1.
SemiOptConnAlg is a linear-time algorithm that generates minimum number of semi-connected segments for any given time series P=(p1,p2,…,pn) and error bound δ.

Proof.
Since the proof on the least number of segments is directly from Lemma 3.1, we only give the proof on time complexity in the following.

As shown in Algorithm 1, SemiOptConnAlg employs DisConnAlg to construct the pending disconnected segment and checks whether it is semi-connected to the previous segment. This check is implemented by the three designed cases discussed in Section 3.1. In the while loop, the costs of constructing/updating a new segment are of three parts: the cost of constructing a new disconnected segment, the cost of shrinking data points and the cost of extending data points. Suppose the pending disconnected segment Sk+1. Let the number of points in Sk+1 be mk+1. According to the illustrations on page 10 of paper [21], the cost of constructing Sk+1 is dominated by the costs of updating convex hulls and is bound by (4+c1)mk+1 [21], where c1 is a constant number that summarizes other costs in the process. In the process of shrinking data points (let the number of shrunk points be m′≤mk+1), we do not need to update the convex hulls in order to compute the extreme lines as the extreme lines have been stored in advance. So the cost can be denoted as c2m′.

Similarly, the cost of extending Sk+1 to semi-connect to Sk is bound by (4+c1)(mk+1−m′+mk) where mk is the number of points in Sk. Thus, the total cost of constructing a new semi-connected segment is bound by (4+c1)mk+1+c2m′+(4+c1)(mk+1−m′+mk)≤(6+2c1)mk+1+(4+c1)mk. We therefore conclude that the time complexity of SemiOptConnAlg algorithm is O(n).

Let the number of segments constructed from SemiOptConnAlg, ConnSegAlg and DisConnAlg be m, h and k, respectively. According to Theorem 2.1 [23], k≤h≤2k−1 holds. Then k≤m≤2k−1 holds as m≤h holds. Based on this, we have the bounds on storage costs for SemiOptConnAlg.

Property 3.3.
Let r and r′ be the number of outputted data points of SemiOptConnAlg and DisConnAlg, respectively. Then (r′+2)/2≤r≤r′.

Since each disconnected segment needs to store two points while the whole semi-connected segments only need to store the turning points plus the start and end points, we have r=m+1 and r′=2k. Thus, (r′+2)/2≤r≤r′ holds.

Property 3.4 indicates that the running time of SemiOptConnAlg is within the four times that of DisConnAlg.

Property 3.4.
For a given time series P and an error bound δ, let t(S) and t(D) be the processing time of SemiOptConnAlg and DisConnAlg, respectively. Then t(D)≤t(S)≤4×t(D) holds.

Proof.
Since SemiOptConnAlg uses DisConnAlg as basic operations, we can rewrite t(S) into two parts. That is,
t(S)=t(DInS)+t(PInS),
View SourceRight-click on figure for MathML and additional features.where t(DInS) and t(PInS) are the time cost on calling DisConnAlg and the time cost on the post processing phase, respectively.

Obviously, the best case of SemiOptConnAlg is that each pending disconnected segment can semi-connect to the previous one without shrinking any point. At this time, t(D)=t(DInS) and t(PInS)≥0 hold due to the extra computations on the“backward-checking” process. Thus, t(D)≤t(S) holds.

In the worst case of t(DInS), each pending disconnected segment constructed by DisConnAlg cannot semi-connect to its previous segment until only the start point of this segment is left after repeatedly shrinking. DisConnAlg is required to build a segment start from the next data point. This may cause DisConnAlg to build segments starting from two adjacent data points. Therefore, t(DInS)≤2×t(D).

In the worst case of t(PInS), the shrunk segment only deletes the latest point and is extended to semi-connect with the previous segment at the second data point. t(PInS) is determined by the number of points in the shrunk and extended segment, which is bound by the length of two disconnected segments from DisConnAlg. So t(PInS) is bound by 2×t(D). Thus, we have t(S)≤4×t(D).

Let k be the number of segments generated from DisConnAlg on time series P. From the proof of Property 3.4, we know that, in the process of constructing semi-connected segments, the number of calls on DisConnAlg from SemiOptConnAlg is bound by 2k.

Next, we will briefly indicate that SemiOptConnAlg and PipeOptConnAlg can generate the exact same representing segments. Since both SemiOptConnAlg and PipeOptConnAlg are optimal and generate the same number of semi-connected representative segments for any given time series P and error bound δ, these two algorithms will construct the same extreme lines.9 Taken the extreme lines as the outputted semi-connected segments, we therefore have the following property.

Property 3.5.
For any time series P=(p1,p2,…,pn) and an error bound δ, SemiOptConnAlg and PipeOptConnAlg generate the same set of representative segments.

SECTION 4Experiments
In this section, we evaluate the performance of SemiOptConnAlg by experimentally comparing it against DisConnAlg and PipeOptConnAlg on a wide range of data sets. The comparisons are made in terms of the number of segments constructed, storage costs, time costs, memory costs, scalability and representation quality.

In the experiments, we use the original source codes of DisConnAlg and PipeOptConnAlg obtained from the authors of [14], [21], respectively. All algorithms are implemented with C++. All experiments are performed on a laptop with a 2.4 GHz CPU and 12G memory. Our tests use 43 data sets selected from the UCR time series archive [11]. These data sets have been widely used for the evaluation of time series algorithms.

On testing, each algorithm is run 10 times for each data set and the average of the results and its standard deviation are reported. We set the error bound to be 2.5, 5 and 10 percent of the value range of testing data sets, respectively. We only display the results for the situation of δ=2.5% since other results are very similar.

Storage Costs, Time Costs and Memory Costs. The tested results on the number of constructed segments and storage costs are listed in Table 2 and Fig. 10. Let k be the number of segments generated from DisConnAlg and rk be its storage cost. Then rk=2k, which stores the number of end points of the constructed segments. Table 2 confirms:

Although the methods of SemiOptConnAlg and PipeOptConnAlg are very different, they generate the same number of outputs on all tested data sets;

TABLE 2 Number of segments
Table 2- 
Number of segments
Fig. 10. - 
Storage costs of SemiOptConnAlg and DisConnAlg on 43 data sets.
Fig. 10.
Storage costs of SemiOptConnAlg and DisConnAlg on 43 data sets.

Show All

The number of semi-connected segments constructed by SemiOptConnAlg is within [k,2k−1], which is confirmed from Theorem 3.1. More specifically, the number of segments constructed by SemiOptConnAlg is about 134 percent of that constructed by DisConnAlg on the tested data sets;

As claimed in Property 3.3, the storage costs of SemiOptConnAlg are less than that of DisConnAlg and are bound in [(rk+2)/2,rk] as shown in Fig. 10. The average storage cost for the outputs of SemiOptConnAlg is about 67 percent of that from DisConnAlg on 43 tested data sets.

Let t(D), t(S) and t(P) be the time costs of DisConnAlg, SemiOptConnAlg and PipeOptConnAlg, respectively. As having been discussed in the previous section,
t(S)=t(DInS)+t(PInS),
View Sourcewhere t(DInS) is the time cost on generating disconnected segments by DisConnAlg and t(PInS) is the time cost on the post processing phase. All the results on time costs are listed in Table 2. These results have confirmed that

Property 3.4 and 3.5 are verified from all tested data sets;

The average time costs of SemiOptConnAlg and PipeOptConnAlg are about 202ms and 713ms, respectively. SemiOptConnAlg is about 3 times faster than that of PipeOptConnAlg. The extra time consumption of PipeOptConnAlg comes from that (i) SemiOptConnAlg is designed in time domain, without constructing a polygon as in PipeOptConnAlg; (ii) SemiOptConnAlg can immediately output a segment from one extreme line.

We compare SemiOptConnAlg against PipeOptConnAlg on memory costs in Fig. 11. These results indicate that the average maximum memory cost of PipeOptConnAlg and SemiOptConnAlg is about 0.43 kb and 0.25 kb, respectively; The memory cost of PipeOptConnAlg can be 2.5 times larger than that by SemiOptConnAlg on a tested data set.

Scalability. On scalability tests, we designed two experimental strategies: (I) Data lengths impact on time and memory costs. We divided the testing data set into 20 fragments and computed the accumulated time cost and the maximum memory cost on each fragment. (II) Error bounds impact on time and memory costs. We computed the time and maximum memory costs on the varying error bounds from 1 to 10 percent of the testing data set range.

Fig. 11. - 
Memory costs of SemiOptConnAlg and PipeOptConnAlg on 43 data sets.
Fig. 11.
Memory costs of SemiOptConnAlg and PipeOptConnAlg on 43 data sets.

Show All

We only present the results on “StarLight”, “MALLAT”, “wafer” and “Diatom” for the sake of brevity. “StarLight” and “MALLAT” are the top two largest among the 43 data sets which include 8441901 and 2403626 data points, respectively. “wafer” and “Diatom” are the data sets which achieve the minimum (i.e., 1.2) and the maximum (i.e., 3) memory cost ratios between SemiOptConnAlg and PipeOptConnAlg among the 43 data sets. The tested results on strategies (I) and (II) are shown in Figs. 12 and 13, respectively. These results indicate:

With the data length increasing, the time cost of SemiOptConnAlg and PipeOptConnAlg are both increasing, but the variation tendency of SemiOptConnAlg is much slower than that of PipeOptConnAlg. The differences on their memory costs fluctuate around 0.32 kb, 0.38 kb, 0.15 kb, and 0.45 kb on “wafer” and “Diatom”, respectively.

Fig. 12. - 
Time and memory costs with varied length.
Fig. 12.
Time and memory costs with varied length.

Show All


Fig. 13.
Time and memory costs with varied error.

Show All

With the error bound increasing, the time costs of SemiOptConnAlg and PipeOptConnAlg are close to constant, but SemiOptConnAlg is about 3 times quicker than that of PipeOptConnAlg. The memory costs of SemiOptConnAlg are about 20 to 88 percent of that PipeOptConnAlg.

Representation Quality. The representation quality of SemiOptConnAlg is evaluated from two perspectives in the following: the minimized mean square error on the outputted segments and the accurate representation on ECG data.

Considering that many research results on PLA algorithms are on mean square error (L2-error), we first illustrate the representation advantages of SemiOptConnAlg against DisConnAlg through comparing their L2-error on the approximation of original data points under the fixed storage costs. This test strengthened and detailed the testing results in Figs. 11a and 11b of [14], specially for PipeOptConnAlg.

We adjust L∞ error from 1 to 10 percent of the data set range separately to make SemiOptConnAlg and DisConnAlg have the same storage on the sets of constructed segments. We then compute the L2 errors on their outputted segments. The results on “Lighting2” and “Diatom” are depicted in Fig. 14. For the same error bound in L∞, it shows that: (1) Under the same storage costs, the L2 errors of semi-connected segments are always smaller than those of disconnected segments. (2) The L2 errors on semi-connected segments and disconnected segments are decreasing as the storage sizes increase, but the tendency variation of semi-connected is slower than disconnected. Similar test results were obtained for the remaining tested data sets.

Fig. 14. - 
$L_2$L2-error on the representations of DisConnAlg and SemiOptConnAlg.
Fig. 14.
L2-error on the representations of DisConnAlg and SemiOptConnAlg.

Show All

The next test results are about the representation of ECG data picked up from MIT [24] which is depicted with the thick grey curve in Fig. 15i. We construct segments with a fixed storage cost or on a fixed error bound to represent the ECG data. In this regard, we set the error bounds of SemiOptConnAlg and DisConnAlg to be 0.01547 and obtained a storage of 42 and 62 respectively on the outputs (Figs. 15 ii and 15v). We then readjust the error bound of DisConnAlg to 0.0456 for achieving the storage of 42 (Fig. 15 iii). Figs. 15 iv and 15 vi are the “connected version” of Figs. 15 iii and 15v by connecting any two adjacent disconnected lines with a trivial line. Three advantages on the semi-connected representation are observed: (1) Under the same storage cost or error bound, the ECG curve can be represented with better precision and smoothness in semi-connected lines than that of disconnected lines; (2) For the tendencies marked by rectangles, semi-connected lines are more consistent with the corresponding original parts than that of disconnected ones; (3) For some important ECG features, the results by SemiOptConnAlg are more precise than that from DisConnAlg. For example, the peaks of T wave marked by ellipses are shifted away from the original locations when represented in disconnected segments, which can result in incorrect practical diagnostic results for patients.

Fig. 15. - 
Visual differences on ECG representations by DisConnAlg and SemiOptConnAlg.
Fig. 15.
Visual differences on ECG representations by DisConnAlg and SemiOptConnAlg.

Show All

SECTION 5Conclusion
In this article, we present a new linear time PLA algorithm to construct line segments with guaranteed max-error bound. We prove that SemiOptConnAlg can construct the minimum number of semi-connected segments. Extensive experiments on 43 data sets indicate that the proposed algorithm is very efficient and has better time and memory performance than PipeOptConnAlg. This obtained technique has been used in image processing with successful satisfaction in [17].

In [14], the authors proposed a new method that uses “mixed” segments to reduce storage further. As such, we have converted SemiOptConnAlg to generate “mixed segments” which achieved better test results. Our next research work will be focused on obtaining a more efficient way of computing mixed segments.

