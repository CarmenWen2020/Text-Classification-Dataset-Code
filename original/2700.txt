Named entity recognition (NER) is the task to identify mentions of rigid designators from text belonging to predefined semantic types such as person, location, organization etc. NER always serves as the foundation for many natural language applications such as question answering, text summarization, and machine translation. Early NER systems got a huge success in achieving good performance with the cost of human engineering in designing domain-specific features and rules. In recent years, deep learning, empowered by continuous real-valued vector representations and semantic composition through nonlinear processing, has been employed in NER systems, yielding stat-of-the-art performance. In this paper, we provide a comprehensive review on existing deep learning techniques for NER. We first introduce NER resources, including tagged NER corpora and off-the-shelf NER tools. Then, we systematically categorize existing works based on a taxonomy along three axes: distributed representations for input, context encoder, and tag decoder. Next, we survey the most representative methods for recent applied techniques of deep learning in new NER problem settings and applications. Finally, we present readers with the challenges faced by NER systems and outline future directions in this area.
SECTION 1Introduction
Named Entity Recognition (NER) aims to recognize mentions of rigid designators from text belonging to predefined semantic types such as person, location, organization etc. [1]. NER not only acts as a standalone tool for information extraction (IE), but also plays an essential role in a variety of natural language processing (NLP) applications such as text understanding [2], [3], information retrieval [4], [5], automatic text summarization [6], question answering [7], machine translation [8], and knowledge base construction [9] etc.

Evolution of NER. The term “Named Entity” (NE) was first used at the sixth Message Understanding Conference (MUC-6) [10], as the task of identifying names of organizations, people and geographic locations in text, as well as currency, time and percentage expressions. Since MUC-6 there has been increasing interest in NER, and various scientific events (e.g., CoNLL03 [11], ACE [12], IREX [13], and TREC Entity Track [14]) devote much effort to this topic.

Regarding the problem definition, Petasis et al. [15] restricted the definition of named entities: “A NE is a proper noun, serving as a name for something or someone”. This restriction is justified by the significant percentage of proper nouns present in a corpus. Nadeau and Sekine [1] claimed that the word “Named” restricted the task to only those entities for which one or many rigid designators stands for the referent. Rigid designator, defined in [16], include proper names and natural kind terms like biological species and substances. Despite the various definitions of NEs, researchers have reached common consensus on the types of NEs to recognize. We generally divide NEs into two categories: generic NEs (e.g., person and location) and domain-specific NEs (e.g., proteins, enzymes, and genes). In this paper, we mainly focus on generic NEs in English language. We do not claim this article to be exhaustive or representative of all NER works on all languages.

As to the techniques applied in NER, there are four main streams: 1) Rule-based approaches, which do not need annotated data as they rely on hand-crafted rules; 2) Unsupervised learning approaches, which rely on unsupervised algorithms without hand-labeled training examples; 3) Feature-based supervised learning approaches, which rely on supervised learning algorithms with careful feature engineering; 4) Deep-learning based approaches, which automatically discover representations needed for the classification and/or detection from raw input in an end-to-end manner. We brief 1), 2) and 3), and review 4) in detail.

Motivations for Conducting This Survey. In recent years, deep learning (DL, also named deep neural network) has attracted significant attention due to its success in various domains. Starting with Collobert et al. [17], DL-based NER systems with minimal feature engineering have been flourishing. Over the past few years, a considerable number of studies have applied deep learning to NER and successively advanced the state-of-the-art performance [17], [18], [19], [20], [21]. This trend motivates us to conduct a survey to report the current status of deep learning techniques in NER research. By comparing the choices of DL architectures, we aim to identify factors affecting NER performance as well as issues and challenges.

On the other hand, although NER studies have been thriving for a few decades, to the best of our knowledge, there are few reviews in this field so far. Arguably the most established one was published by Nadeau and Sekine [1] in 2007. This survey presents an overview of the technique trend from hand-crafted rules towards machine learning. Marrero et al. [22] summarized NER works from the perspectives of fallacies, challenges and opportunities in 2013. Then Patawar and Potey [23] provided a short review in 2015. The two recent short surveys are on new domains [24] and complex entity mentions [25], respectively. In summary, existing surveys mainly cover feature-based machine learning models, but not the modern DL-based NER systems. More germane to this work are the two recent surveys [26], [27] in 2018. Goyal et al. [27] surveyed developments and progresses made in NER. However, they did not include recent advances of deep learning techniques. Yadav and Bethard [26] presented a short survey of recent advances in NER based on representations of words in sentence. This survey focuses more on the distributed representations for input (e.g., char- and word-level embeddings) and do not review the context encoders and tag decoders. The recent trend of applied deep learning on NER tasks (e.g., multi-task learning, transfer learning, reinforcement leanring and adversarial learning) are not in their servery as well.

Contributions of This Survey. We intensely review applications of deep learning techniques in NER, to enlighten and guide researchers and practitioners in this area. Specifically, we consolidate NER corpora, off-the-shelf NER systems (from both academia and industry) in a tabular form, to provide useful resources for NER research community. We then present a comprehensive survey on deep learning techniques for NER. To this end, we propose a new taxonomy, which systematically organizes DL-based NER approaches along three axes: distributed representations for input, context encoder (for capturing contextual dependencies for tag decoder), and tag decoder (for predicting labels of words in the given sequence). In addition, we also survey the most representative methods for recent applied deep learning techniques in new NER problem settings and applications. Finally, we present readers with the challenges faced by NER systems and outline future directions in this area.

SECTION 2Background
We first give a formal formulation of the NER problem. We then introduce the widely-used NER datasets and tools. Next, we detail the evaluation metrics and summarize the traditional approaches to NER.

2.1 What is NER?
A named entity is a word or a phrase that clearly identifies one item from a set of other items that have similar attributes [28]. Examples of named entities are organization, person, and location names in general domain; gene, protein, drug and disease names in biomedical domain. NER is the process of locating and classifying named entities in text into predefined entity categories.

Formally, given a sequence of tokens s=⟨w1,w2,…,wN⟩, NER is to output a list of tuples ⟨Is,Ie,t⟩, each of which is a named entity mentioned in s. Here, Is∈[1,N] and Ie∈[1,N] are the start and the end indexes of a named entity mention; t is the entity type from a predefined category set. Fig. 1 shows an example where a NER system recognizes three named entities from the given sentence. When NER was first defined in MUC-6 [10], the task is to recognize names of people, organizations, locations, and time, currency, percentage expressions in text. Note that the task focuses on a small set of coarse entity types and one type per named entity. We call this kind of NER tasks as coarse-grained NER [10], [11]. Recently, some fine-grained NER tasks [29], [30], [31], [32], [33] focus on a much larger set of entity types where a mention may be assigned multiple fine-grained types.

Fig. 1. - 
An illustration of the named entity recognition task.
Fig. 1.
An illustration of the named entity recognition task.

Show All

NER acts as an important pre-processing step for a variety of downstream applications such as information retrieval, question answering, machine translation, etc. Here, we use semantic search as an example to illustrate the importance of NER in supporting various applications. Semantic search refers to a collection of techniques, which enable search engines to understand the concepts, meaning, and intent behind the queries from users [34]. According to [4], about 71 percent of search queries contain at least one named entity. Recognizing named entities in search queries would help us to better understand user intents, hence to provide better search results. To incorporate named entities in search, entity-based language models [34], which consider individual terms as well as term sequences that have been annotated as entities (both in documents and in queries), have been proposed by Raviv et al. [35]. There are also studies utilizing named entities for an enhanced user experience, such as query recommendation [36], query auto-completion [37], [38] and entity cards [39], [40].

2.2 NER Resources: Datasets and Tools
High quality annotations are critical for both model learning and evaluation. In the following, we summarize widely-used datasets and off-the-shelf tools for English NER.

A tagged corpus is a collection of documents that contain annotations of one or more entity types. Table 1 lists some widely-used datasets with their data sources and number of entity types (also known as tag types). Summarized in Table 1, before 2005, datasets were mainly developed by annotating news articles with a small number of entity types, suitable for coarse-grained NER tasks. After that, more datasets were developed on various kinds of text sources including Wikipedia articles, conversation, and user-generated text (e.g., tweets and YouTube comments and StackExchange posts in W-NUT). The number of tag types becomes significantly larger, e.g., 505 in HYENA. We also list a number of domain specific datasets, particularly developed on PubMed and MEDLINE texts. The number of entity types ranges from 1 in NCBI-Disease to 36 in GENIA.

TABLE 1 List of Annotated Datasets for English NER
Table 1- 
List of Annotated Datasets for English NER
We note that many recent NER works report their performance on CoNLL03 and OntoNotes datasets (see Table 3). CoNLL03 contains annotations for Reuters news in two languages: English and German. The English dataset has a large portion of sports news with annotations in four entity types (Person, Location, Organization, and Miscellaneous) [11]. The goal of the OntoNotes project was to annotate a large corpus, comprising of various genres (weblogs, news, talk shows, broadcast, usenet newsgroups, and conversational telephone speech) with structural information (syntax and predicate argument structure) and shallow semantics (word sense linked to an ontology and coreference). There are 5 versions, from Release 1.0 to Release 5.0. The texts are annotated with 18 entity types. We also note two Github repositores1 which host some NER corpora.

TABLE 2 Off-the-Shelf NER Tools Offered by Academia and Industry Projects
Table 2- 
Off-the-Shelf NER Tools Offered by Academia and Industry Projects
TABLE 3 Summary of Recent Works on Neural NER
Table 3- 
Summary of Recent Works on Neural NER
There are many NER tools available online with pre-trained models. Table 2 summarizes popular ones for English NER by academia (top) and industry (bottom).

2.3 NER Evaluation Metrics
NER systems are usually evaluated by comparing their outputs against human annotations. The comparison can be quantified by either exact-match or relaxed match.

2.3.1 Exact-Match Evaluation
NER involves identifying both entity boundaries and entity types. With “exact-match evaluation”, a named entity is considered correctly recognized only if its both boundaries and type match ground truth [11], [41]. Precision, Recall, and F-score are computed on the number of true positives (TP), false positives (FP), and false negatives (FN).

True Positive: entities that are recognized by NER and match ground truth.

False Positive: entities that are recognized by NER but do not match ground truth.

False Negative: entities annotated in the ground truth that are not recognized by NER.

Precision measures the ability of a NER system to present only correct entities, and Recall measures the ability of a NER system to recognize all entities in a corpus.
Precision=TPTP+FPRecall=TPTP+FN.
View SourceRight-click on figure for MathML and additional features.

F-score is the harmonic mean of precision and recall, and the balanced F-score is most commonly used
F-score=2×Precision×RecallPrecision+Recall.
View SourceRight-click on figure for MathML and additional features.

As most of NER systems involve multiple entity types, it is often required to assess the performance across all entity classes. Two measures are commonly used for this purpose: macro-averaged F-score and micro-averaged F-score. Macro-averaged F-score computes the F-score independently for each entity type, then takes the average (hence treating all entity types equally). Micro-averaged F-score aggregates the contributions of entities from all classes to compute the average (treating all entities equally). The latter can be heavily affected by the quality of recognizing entities in large classes in the corpus.

2.3.2 Relaxed-Match Evaluation
MUC-6 [10] defines a relaxed-match evaluation: a correct type is credited if an entity is assigned its correct type regardless its boundaries as long as there is an overlap with ground truth boundaries; a correct boundary is credited regardless an entity's type assignment. Then ACE [12] proposes a more complex evaluation procedure. It resolves a few issues like partial match and wrong type, and considers subtypes of named entities. However, it is problematic because the final scores are comparable only when parameters are fixed [1], [22], [23]. Complex evaluation methods are not intuitive and make error analysis difficult. Thus, complex evaluation methods are not widely used in recent studies.

2.4 Traditional Approaches to NER
Traditional approaches to NER are broadly classified into three main streams: rule-based, unsupervised learning, and feature-based supervised learning approaches [1], [26].

2.4.1 Rule-Based Approaches
Rule-based NER systems rely on hand-crafted rules. Rules can be designed based on domain-specific gazetteers [9], [42] and syntactic-lexical patterns [43]. Kim [44] proposed to use Brill rule inference approach for speech input. This system generates rules automatically based on Brill's part-of-speech tagger. In biomedical domain, Hanisch et al. [45] proposed ProMiner, which leverages a pre-processed synonym dictionary to identify protein mentions and potential gene in biomedical text. Quimbaya et al. [46] proposed a dictionary-based approach for NER in electronic health records. Experimental results show the approach improves recall while having limited impact on precision.

Some other well-known rule-based NER systems include LaSIE-II [47], NetOwl [48], Facile [49], SAR [50], FASTUS [51], and LTG [52] systems. These systems are mainly based on hand-crafted semantic and syntactic rules to recognize entities. Rule-based systems work very well when lexicon is exhaustive. Due to domain-specific rules and incomplete dictionaries, high precision and low recall are often observed from such systems, and the systems cannot be transferred to other domains.

2.4.2 Unsupervised Learning Approaches
A typical approach of unsupervised learning is clustering [1]. Clustering-based NER systems extract named entities from the clustered groups based on context similarity. The key idea is that lexical resources, lexical patterns, and statistics computed on a large corpus can be used to infer mentions of named entities. Collins et al. [53] observed that use of unlabeled data reduces the requirements for supervision to just 7 simple “seed” rules. The authors then presented two unsupervised algorithms for named entity classification. Similarly, KNOWITALL [9] leveraged a set of predicate names as input and bootstraps its recognition process from a small set of generic extraction patterns.

Nadeau et al. [54] proposed an unsupervised system for gazetteer building and named entity ambiguity resolution. This system combines entity extraction and disambiguation based on simple yet highly effective heuristics. In addition, Zhang and Elhadad [43] proposed an unsupervised approach to extracting named entities from biomedical text. Instead of supervision, their model resorts to terminologies, corpus statistics (e.g., inverse document frequency and context vectors) and shallow syntactic knowledge (e.g., noun phrase chunking). Experiments on two mainstream biomedical datasets demonstrate the effectiveness and generalizability of their unsupervised approach.

2.4.3 Feature-Based Supervised Learning Approaches
Applying supervised learning, NER is cast to a multi-class classification or sequence labeling task. Given annotated data samples, features are carefully designed to represent each training example. Machine learning algorithms are then utilized to learn a model to recognize similar patterns from unseen data.

Feature engineering is critical in supervised NER systems. Feature vector representation is an abstraction over text where a word is represented by one or many Boolean, numeric, or nominal values [1], [55]. Word-level features (e.g., case, morphology, and part-of-speech tag) [56], [57], [58], list lookup features (e.g., Wikipedia gazetteer and DBpedia gazetteer) [59], [60], [61], [62], and document and corpus features (e.g., local syntax and multiple occurrences) [63], [64], [65], [66] have been widely used in various supervised NER systems. More feature designs are discussed in [1], [28], [67]

Based on these features, many machine learning algorithms have been applied in supervised NER, including Hidden Markov Models (HMM) [68], Decision Trees [69], Maximum Entropy Models [70], Support Vector Machines (SVM) [71], and Conditional Random Fields (CRF) [72].

Bikel et al. [73], [74] proposed the first HMM-based NER system, named IdentiFinder, to identify and classify names, dates, time expressions, and numerical quantities. In addition, Szarvas et al. [75] developed a multilingual NER system by using C4.5 decision tree and AdaBoostM1 learning algorithm. A major merit is that it provides an opportunity to train several independent decision tree classifiers through different subsets of features then combine their decisions through a majority voting scheme. Borthwick et al. [76] proposed “maximum entropy named entity” (MENE) by applying the maximum entropy theory. MENE is able to make use of an extraordinarily diverse range of knowledge sources in making its tagging decisions. Other systems using maximum entropy can be found in [77], [78], [79].

McNamee and Mayfield [80] used 1,000 language-related and 258 orthography and punctuation features to train SVM classifiers. Each classifier makes binary decision whether the current token belongs to one of the eight classes, i.e., B- (Beginning), I- (Inside) for PERSON, ORGANIZATION, LOCATION, and MIS tags. SVM does not consider “neighboring” words when predicting an entity label. CRFs takes context into account. McCallum and Li [81] proposed a feature induction method for CRFs in NER. Experiments were performed on CoNLL03, and achieved F-score of 84.04 percent for English. Krishnan and Manning [66] proposed a two-stage approach based on two coupled CRF classifiers. The second CRF makes use of the latent representations derived from the output of the first CRF. We note that CRF-based NER has been widely applied to texts in various domains, including biomedical text [57], [82], tweets [83], [84] and chemical text [85].

SECTION 3Deep Learning Techniques for NER
In recent years, DL-based NER models become dominant and achieve state-of-the-art results. Compared to feature-based approaches, deep learning is beneficial in discovering hidden features automatically. Next, we first briefly introduce what deep learning is, and why deep learning for NER. We then survey DL-based NER approaches.

3.1 Why Deep Learning for NER?
Deep learning is a field of machine learning that is composed of multiple processing layers to learn representations of data with multiple levels of abstraction [86]. The typical layers are artificial neural networks which consists of the forward pass and backward pass. The forward pass computes a weighted sum of their inputs from the previous layer and pass the result through a non-linear function. The backward pass is to compute the gradient of an objective function with respect to the weights of a multilayer stack of modules via the chain rule of derivatives. The key advantage of deep learning is the capability of representation learning and the semantic composition empowered by both the vector representation and neural processing. This allows a machine to be fed with raw data and to automatically discover latent representations and processing needed for classification or detection [86].

There are three core strengths of applying deep learning techniques to NER. First, NER benefits from the non-linear transformation, which generates non-linear mappings from input to output. Compared with linear models (e.g., log-linear HMM and linear chain CRF), DL-based models are able to learn complex and intricate features from data via non-linear activation functions. Second, deep learning saves significant effort on designing NER features. The traditional feature-based approaches require considerable amount of engineering skill and domain expertise. DL-based models, on the other hand, are effective in automatically learning useful representations and underlying factors from raw data. Third, deep neural NER models can be trained in an end-to-end paradigm, by gradient descent. This property enables us to design possibly complex NER systems.

Why We Use a New Taxonomy in This Survey? Existing taxonomy [26], [87] is based on character-level encoder, word-level encoder, and tag decoder. We argue that the description of “word-level encoder” is inaccurate because word-level information is used twice in a typical DL-based NER model: 1) word-level representations are used as raw features, and 2) word-level representations (together with character-level representations) are used to capture context dependence for tag decoding. In this survey, we summarize recent advances in NER with the general architecture presented in Fig. 2. Distributed representations for input consider word- and character-level embeddings as well as incorporation of additional features like POS tag and gazetteer that have been effective in feature-based based approaches. Context encoder is to capture the context dependencies using CNN, RNN, or other networks. Tag decoder predict tags for tokens in the input sequence. For instance, in Fig. 2 each token is predicted with a tag indicated by B-(begin), I-(inside), E-(end), S-(singleton) of a named entity with its type, or O-(outside) of named entities. Note that there are other tag schemes or tag notations, e.g., BIO. Tag decoder may also be trained to detect entity boundaries and then the detected text spans are classified to the entity types.

Fig. 2. - 
The taxonomy of DL-based NER. From input sequence to predicted tags, a DL-based NER model consists of distributed representations for input, context encoder, and tag decoder.
Fig. 2.
The taxonomy of DL-based NER. From input sequence to predicted tags, a DL-based NER model consists of distributed representations for input, context encoder, and tag decoder.

Show All

3.2 Distributed Representations for Input
A straightforward option of representing a word is one-hot vector representation. In one-hot vector space, two distinct words have completely different representations and are orthogonal. Distributed representation represents words in low dimensional real-valued dense vectors where each dimension represents a latent feature. Automatically learned from text, distributed representation captures semantic and syntactic properties of word, which do not explicitly present in the input to NER. Next, we review three types of distributed representations that have been used in NER models: word-level, character-level, and hybrid representations.

3.2.1 Word-Level Representation
Some studies [88], [89], [90] employed word-level representation, which is typically pre-trained over large collections of text through unsupervised algorithms such as continuous bag-of-words (CBOW) and continuous skip-gram models [91]. Recent studies [87], [92] have shown the importance of such pre-trained word embeddings. Using as the input, the pre-trained word embeddings can be either fixed or further fine-tuned during NER model training. Commonly used word embeddings include Google Word2Vec, Stanford GloVe, Facebook fastText and SENNA.

Yao et al. [93] proposed Bio-NER, a biomedical NER model based on deep neural network architecture. The word representation in Bio-NER is trained on PubMed database using skip-gram model. The dictionary contains 205,924 words in 600 dimensional vectors. Nguyen et al. [88] used word2vec toolkit to learn word embeddings for English from the Gigaword corpus augmented with newsgroups data from Broad Operational Language Technologies (BOLT). Zhai et al. [94] designed a neural model for sequence chunking, which consists of two sub-tasks: segmentation and labeling. The neural model can be fed with SENNA embeddings or randomly initialized embeddings.

Zheng et al. [89] jointly extracted entities and relations using a single model. This end-to-end model uses word embeddings learned on NYT corpus by word2vec tookit. Strubell et al. [90] proposed a tagging scheme based on Iterated Dilated Convolutional Neural Networks (ID-CNNs). The lookup table in their model are initialized by 100-dimensional embeddings trained on SENNA corpus by skip-n-gram. In their proposed neural model for extracting entities and their relations, Zhou et al. [95] used the pre-trained 300-dimensional word vectors from Google. In addition, GloVe [96], [97] and fastText [98] are also widely used in NER tasks.

3.2.2 Character-Level Representation
Instead of only considering word-level representations as the basic input, several studies [99], [100] incorporated character-based word representations learned from an end-to-end neural model. Character-level representation has been found useful for exploiting explicit sub-word-level information such as prefix and suffix. Another advantage of character-level representation is that it naturally handles out-of-vocabulary. Thus character-based model is able to infer representations for unseen words and share information of morpheme-level regularities. There are two widely-used architectures for extracting character-level representation: CNN-based and RNN-based models. Figs. 3a and 3b illustrate the two architectures.

Fig. 3. - 
CNN-based and RNN-based models for extracting character-level representation for a word.
Fig. 3.
CNN-based and RNN-based models for extracting character-level representation for a word.

Show All

Ma et al. [96] utilized a CNN for extracting character-level representations of words. Then the character representation vector is concatenated with the word embedding before feeding into a RNN context encoder. Likewise, Li et al. [97] applied a series of convolutional and highway layers to generate character-level representations for words. The final embeddings of words are fed into a bidirectional recursive network. Yang et al. [101] proposed a neural reranking model for NER, where a convolutional layer with a fixed window-size is used on top of a character embedding layer. Recently, Peters et al. [102] proposed ELMo word representation, which are computed on top of two-layer bidirectional language models with character convolutions.

For RNN-based models, Long Short-Term Memory (LSTM) and Gated Recurrent Unit (GRU) are two typical choices of the basic units. Kuru et al. [99] proposed CharNER, a character-level tagger for language-independent NER. CharNER considers a sentence as a sequence of characters and utilizes LSTMs to extract character-level representations. It outputs a tag distribution for each character instead of each word. Then word-level tags are obtained from the character-level tags. Their results show that taking characters as the primary representation is superior to words as the basic input unit. Lample et al. [19] utilized a bidirectional LSTM to extract character-level representations of words. Similar to [96], character-level representation is concatenated with pre-trained word-level embedding from a word lookup table. Gridach [103] investigated word embeddings and character-level representation in identifying biomedical named entities. Rei et al. [104] combined character-level representations with word embeddings using a gating mechanism. In this way, Rei's model dynamically decides how much information to use from a character- or word-level component. Tran et al. [100] introduced a neural NER model with stack residual LSTM and trainable bias decoding, where word features are extracted from word embeddings and character-level RNN. Yang et al. [105] developed a model to handle both cross-lingual and multi-task joint training in a unified manner. They employed a deep bidirectional GRU to learn informative morphological representation from the character sequence of a word. Then character-level representation and word embedding are concatenated to produce the final representation for a word.

Recent advances in language modeling using recurrent neural networks made it viable to model language as distributions over characters. The contextual string embeddings by Akbik et al. [106], uses character-level neural language model to generate a contextualized embedding for a string of characters in a sentential context. An important property is that the embeddings are contextualized by their surrounding text, meaning that the same word has different embeddings depending on its contextual use. Fig. 4 illustrates the architecture of extracting a contextual string embedding for word “Washington” in a sentential context.

Fig. 4. - 
Extraction of a contextual string embedding for word “Washington” in a sentential context [106]. From the forward language model (shown in red), the model extracts the output hidden state after the last character in the word. From the backward language model (shown in blue), the model extracts the output hidden state before the first character in the word. Both output hidden states are concatenated to form the final embedding of a word.
Fig. 4.
Extraction of a contextual string embedding for word “Washington” in a sentential context [106]. From the forward language model (shown in red), the model extracts the output hidden state after the last character in the word. From the backward language model (shown in blue), the model extracts the output hidden state before the first character in the word. Both output hidden states are concatenated to form the final embedding of a word.

Show All

3.2.3 Hybrid Representation
Besides word-level and character-level representations, some studies also incorporate additional information (e.g., gazetteers [18], [107], lexical similarity [108], linguistic dependency [109] and visual features [110]) into the final representations of words, before feeding into context encoding layers. In other words, the DL-based representation is combined with feature-based approach in a hybrid manner. Adding additional information may lead to improvements in NER performance, with the price of hurting generality of these systems.

The use of neural models for NER was pioneered by [17], where an architecture based on temporal convolutional neural networks over word sequence was proposed. When incorporating common priori knowledge (e.g., gazetteers and POS), the resulting system outperforms the baseline using only word-level representations. In the BiLSTM-CRF model by Huang et al. [18], four types of features are used for the NER task: spelling features, context features, word embeddings, and gazetteer features. Their experimental results show that the extra features (i.e., gazetteers) boost tagging accuracy. The BiLSTM-CNN model by Chiu and Nichols [20] incorporates a bidirectional LSTM and a character-level CNN. Besides word embeddings, the model uses additional word-level features (capitalization, lexicons) and character-level features (4-dimensional vector representing the type of a character: upper case, lower case, punctuation, other).

Wei et al. [111] presented a CRF-based neural system for recognizing and normalizing disease names. This system employs rich features in addition to word embeddings, including words, POS tags, chunking, and word shape features (e.g., dictionary and morphological features). Strubell et al. [90] concatenated 100-dimensional embeddings with a 5-dimensional word shape vector (e.g., all capitalized, not capitalized, first-letter capitalized or contains a capital letter). Lin et al. [112] concatenated character-level representation, word-level representation, and syntactical word representation (i.e., POS tags, dependency roles, word positions, head positions) to form a comprehensive word representation. A multi-task approach for NER was proposed by Aguilar et al. [113]. This approach utilizes a CNN to capture orthographic features and word shapes at character level. For syntactical and contextual information at word level, e.g., POS and word embeddings, the model implements a LSTM architecture. Jansson and Liu [114] proposed to combine Latent Dirichlet Allocation (LDA) with deep learning on character-level and word-level embeddings.

Xu et al. [115] proposed a local detection approach for NER based on fixed-size ordinally forgetting encoding (FOFE) [116], FOFE explores both character-level and word-level representations for each fragment and its contexts. In the multi-modal NER system by Moon et al. [117], for noisy user-generated data like tweets and Snapchat captions, word embeddings, character embeddings, and visual features are merged with modality attention. Ghaddar and Langlais [108] found that it was unfair that lexical features had been mostly discarded in neural NER systems. They proposed an alternative lexical representation which is trained offline and can be added to any neural NER system. The lexical representation is computed for each word with a 120-dimensional vector, where each element encodes the similarity of the word with an entity type. Recently, Devlin et al. [118] proposed a new language representation model called BERT, bidirectional encoder representations from transformers. BERT uses masked language models to enable pre-trained deep bidirectional representations. For a given token, its input representation is comprised by summing the corresponding position, segment and token embeddings. Note that pre-trained language model embeddings often require large-scale corpora for training, and intrinsically incorporate auxiliary embeddings (e.g., position and segment embeddings). For this reason, we category these contextualized language-model embeddings as hybrid representations in this survey.

3.3 Context Encoder Architectures
Here, we now review widely-used context encoder architectures: convolutional neural networks, recurrent neural networks, recursive neural networks, and deep transformer.

3.3.1 Convolutional Neural Networks
Collobert et al. [17] proposed a sentence approach network where a word is tagged with the consideration of whole sentence, shown in Fig. 5. Each word in the input sequence is embedded to an N-dimensional vector after the stage of input representation. Then a convolutional layer is used to produce local features around each word, and the size of the output of the convolutional layers depends on the number of words in the sentence. The global feature vector is constructed by combining local feature vectors extracted by the convolutional layers. The dimension of the global feature vector is fixed, independent of the sentence length, in order to apply subsequent standard affine layers. Two approaches are widely used to extract global features: a max or an averaging operation over the position (i.e., “time” step) in the sentence. Finally, these fixed-size global features are fed into tag decoder to compute distribution scores for all possible tags for the words in the network input. Following Collobert's work, Yao et al. [93] proposed Bio-NER for biomedical NER. Wu et al. [119] utilized a convolutional layer to generate global features represented by a number of global hidden nodes. Both local features and global features are then fed into a standard affine network to recognize named entities in clinical text.

Fig. 5. - 
Sentence approach network based on CNN [17]. The convolution layer extracts features from the whole sentence, treating it as a sequence with global structure.
Fig. 5.
Sentence approach network based on CNN [17]. The convolution layer extracts features from the whole sentence, treating it as a sequence with global structure.

Show All

Zhou et al. [95] observed that with RNN latter words influence the final sentence representation more than former words. However, important words may appear anywhere in a sentence. In their proposed model, named BLSTM-RE, BLSTM is used to capture long-term dependencies and obtain the whole representation of an input sequence. CNN is then utilized to learn a high-level representation, which is then fed into a sigmoid classifier. Finally, the whole sentence representation (generated by BLSTM) and the relation presentation (generated by the sigmoid classifier) are fed into another LSTM to predict entities.

Strubell et al. [90] proposed Iterated Dilated Convolutional Neural Networks, which have better capacity than traditional CNNs for large context and structured prediction. Unlike LSTMs whose sequential processing on sentence of length N requires O(N) time even in the face of parallelism, ID-CNNs permit fixed-depth convolutions to run in parallel across entire documents. Fig. 6 shows the architecture of a dilated CNN block, where four stacked dilated convolutions of width 3 produce token representations. Experimental results show that ID-CNNs achieves 14-20x test-time speedups compared to Bi-LSTM-CRF while retaining comparable accuracy.

Fig. 6. - 
A dilated CNN block with maximum dilation width 4 and filter width 3. Neurons contributing to a single highlighted neuron in the last layer are highlighted [90].
Fig. 6.
A dilated CNN block with maximum dilation width 4 and filter width 3. Neurons contributing to a single highlighted neuron in the last layer are highlighted [90].

Show All

3.3.2 Recurrent Neural Networks
Recurrent neural networks, together with its variants such as gated recurrent unit and long-short term memory, have demonstrated remarkable achievements in modeling sequential data. In particular, bidirectional RNNs efficiently make use of past information (via forward states) and future information (via backward states) for a specific time frame [18]. Thus, a token encoded by a bidirectional RNN will contain evidence from the whole input sentence. Bidirectional RNNs therefore become de facto standard for composing deep context-dependent representations of text [90], [96]. A typical architecture of RNN-based context encoder is shown in Fig. 7.

Fig. 7. - 
The architecture of RNN-based context encoder.
Fig. 7.
The architecture of RNN-based context encoder.

Show All

The work by Huang et al. [18] is among the first to utilize a bidirectional LSTM CRF architecture to sequence tagging tasks (POS, chunking and NER). Following [18], a body of works [19], [20], [88], [89], [94], [95], [96], [100], [104], [111], [112] applied BiLSTM as the basic architecture to encode sequence context information. Yang et al. [105] employed deep GRUs on both character and word levels to encode morphology and context information. They further extended their model to cross-lingual and multi-task joint trained by sharing the architecture and parameters.

Gregoric et al. [120] employed multiple independent bidirectional LSTM units across the same input. Their model promotes diversity among the LSTM units by employing an inter-model regularization term. By distributing computation across multiple smaller LSTMs, they found a reduction in total number of parameters. Recently, some studies [121], [122] designed LSTM-based neural networks for nested named entity recognition. Katiyar and Cardie [121] presented a modification to standard LSTM-based sequence labeling model to handle nested named entity recognition. Ju et al. [122] proposed a neural model to identify nested entities by dynamically stacking flat NER layers until no outer entities are extracted. Each flat NER layer employs bidirectional LSTM to capture sequential context. The model merges the outputs of the LSTM layer in the current flat NER layer to construct new representations for the detected entities and then feeds them into the next flat NER layer.

3.3.3 Recursive Neural Networks
Recursive neural networks are non-linear adaptive models that are able to learn deep structured information, by traversing a given structure in topological order. Named entities are highly related to linguistic constituents, e.g., noun phrases [97]. However, typical sequential labeling approaches take little into consideration about phrase structures of sentences. To this end, Li et al. [97] proposed to classify every node in a constituency structure for NER. This model recursively calculates hidden state vectors of every node and classifies each node by these hidden vectors. Fig. 8 shows how to recursively compute two hidden state features for every node. The bottom-up direction calculates the semantic composition of the subtree of each node, and the top-down counterpart propagates to that node the linguistic structures which contain the subtree. Given hidden vectors for every node, the network calculates a probability distribution of entity types plus a special non-entity type.

Fig. 8. - 
Bidirectional recursive neural networks for NER [97]. The computations are done recursively in two directions. The bottom-up direction computes the semantic composition of the subtree of each node, and the top-down counterpart propagates to that node the linguistic structures which contain the subtree.
Fig. 8.
Bidirectional recursive neural networks for NER [97]. The computations are done recursively in two directions. The bottom-up direction computes the semantic composition of the subtree of each node, and the top-down counterpart propagates to that node the linguistic structures which contain the subtree.

Show All

3.3.4 Neural Language Models
Language model is a family of models describing the generation of sequences. Given a token sequence, (t1,t2,…,tN), a forward language model computes the probability of the sequence by modeling the probability of token tk given its history (t1,…,tk−1) [21]
p(t1,t2,…,tN)=∏k=1Np(tk|t1,t2,…,tk−1).(1)
View SourceRight-click on figure for MathML and additional features.A backward language model is similar to a forward language model, except it runs over the sequence in reverse order, predicting the previous token given its future context
p(t1,t2,…,tN)=∏k=1Np(tk|tk+1,tk+2,…,tN).(2)
View SourceRight-click on figure for MathML and additional features.For neural language models, probability of token tk can be computed by the output of recurrent neural networks. At each position k, we can obtain two context-dependent representations (forward and backward) and then combine them as the final language model embedding for token tk. Such language-model-augmented knowledge has been empirically verified to be helpful in numerous sequence labeling tasks [21], [102], [123], [124], [125], [126].

Rei [123] proposed a framework with a secondary objective –learning to predict surrounding words for each word in the dataset. Fig. 9 illustrates the architecture with a short sentence on the NER task. At each time step (i.e., token position), the network is optimised to predict the previous token, the current tag, and the next token in the sequence. The added language modeling objective encourages the system to learn richer feature representations which are then reused for sequence labeling.

Fig. 9. - 
A sequence labeling model with an additional language modeling objective [123], performing NER on the sentence “Fischler proposes measures”. At each token position (e.g., “proposes”), the network is optimised to predict the previous word (“Fischler”), the current label (“O”), and the next word (“measures”) in the sequence.
Fig. 9.
A sequence labeling model with an additional language modeling objective [123], performing NER on the sentence “Fischler proposes measures”. At each token position (e.g., “proposes”), the network is optimised to predict the previous word (“Fischler”), the current label (“O”), and the next word (“measures”) in the sequence.

Show All

Peters et al. [21] proposed TagLM, a language model augmented sequence tagger. This tagger considers both pre-trained word embeddings and bidirectional language model embeddings for every token in the input sequence for sequence labeling task. Fig. 10 shows the architecture of LM-LSTM-CRF model [124], [125]. The language model and sequence tagging model share the same character-level layer in a multi-task learning manner. The vectors from character-level embeddings, pre-trained word embeddings, and language model representations, are concatenated and fed into the word-level LSTMs. Experimental results demonstrate that multi-task learning is an effective approach to guide the language model to learn task-specific knowledge.

Fig. 10. - 
Sequence labeling architecture with contextualized representations [124]. Character-level representation, pre-trained word embedding and contextualized representation from bidirectional language models are concatenated and further fed into context encoder.
Fig. 10.
Sequence labeling architecture with contextualized representations [124]. Character-level representation, pre-trained word embedding and contextualized representation from bidirectional language models are concatenated and further fed into context encoder.

Show All

Fig. 4 shows the contextual string embedding using neural character-level language modeling by Akbik et al. [106]. They utilized the hidden states of a forward-backward recurrent neural network to create contextualized word embeddings. A major merit of this model is that character-level language model is independent of tokenization and a fixed vocabulary. Peters et al. [102] proposed ELMo representations, which are computed on top of two-layer bidirectional language models with character convolutions. This new type of deep contextualized word representation is capable of modeling both complex characteristics of word usage (e.g., semantics and syntax), and usage variations across linguistic contexts (e.g., polysemy).

3.3.5 Deep Transformer
Neural sequence labeling models are typically based on complex convolutional or recurrent networks which consists of encoders and decoders. Transformer, proposed by Vaswani et al. [127], dispenses with recurrence and convolutions entirely. Transformer utilizes stacked self-attention and point-wise, fully connected layers to build basic blocks for encoder and decoder. Experiments on various tasks [127], [128], [129] show Transformers to be superior in quality while requiring significantly less time to train.

Based on transformer, Radford et al. [130] proposed Generative Pre-trained Transformer (GPT) for language understanding tasks. GPT has a two-stage training procedure. First, they use a language modeling objective with Transformers on unlabeled data to learn the initial parameters. Then they adapt these parameters to a target task using the supervised objective, resulting in minimal changes to the pre-trained model. Unlike GPT (a left-to-right architecture), Bidirectional Encoder Representations from Transformers (BERT) is proposed to pre-train deep bidirectional Transformer by jointly conditioning on both left and right context in all layers [118]. Fig. 11 summarizes BERT [118], GPT [130] and ELMo [102]. In addition, Baevski et al. [131] proposed a novel cloze-driven pre-training regime based on a bi-directional Transformer, which is trained with a cloze-style objective and predicts the center word given all left and right context.

Fig. 11. - 
Differences in pre-training model architectures [118]. Google BERT uses a bidirectional Transformer (abbreviated as “Trm”). OpenAI GPT uses a left-to-right Transformer. AllenNLP ELMo uses the concatenation of independently trained left-to-right and right-to-left LSTM to generate features for downstream tasks.
Fig. 11.
Differences in pre-training model architectures [118]. Google BERT uses a bidirectional Transformer (abbreviated as “Trm”). OpenAI GPT uses a left-to-right Transformer. AllenNLP ELMo uses the concatenation of independently trained left-to-right and right-to-left LSTM to generate features for downstream tasks.

Show All

These language model embeddings pre-trained using Transformer are becoming a new paradigm of NER. First, these embeddings are contextualized and can be used to replace the traditional embeddings, such as Google Word2vec and Stanford GloVe. Some studies [107], [109], [132], [133], [134], [135] have achieved promising performance via leveraging the combination of traditional embeddings and language model embeddings. Second, these language model embeddings can be further fine-tuned with one additional output layer for a wide range of tasks including NER and chunking. Especially, Li et al. [136], [137] framed the NER task as a machine reading comprehension (MRC) problem, which can be solved by fine-tuning the BERT model.

3.4 Tag Decoder Architectures
Tag decoder is the final stage in a NER model. It takes context-dependent representations as input and produce a sequence of tags corresponding to the input sequence. Fig. 12 summarizes four architectures of tag decoders: MLP + softmax layer, conditional random fields (CRFs), recurrent neural networks, and pointer networks.

Fig. 12. - 
Differences in four tag decoders: MLP+Softmax, CRF, RNN, and Pointer network.
Fig. 12.
Differences in four tag decoders: MLP+Softmax, CRF, RNN, and Pointer network.

Show All

3.4.1 Multi-Layer Perceptron + Softmax
NER is in general formulated as a sequence labeling problem. With a multi-layer Perceptron + Softmax layer as the tag decoder layer, the sequence labeling task is cast as a multi-class classification problem. Tag for each word is independently predicted based on the context-dependent representations without taking into account its neighbors.

A number of NER models [90], [97], [115], [118], [138] that have been introduced earlier use MLP + Softmax as the tag decoder. As a domain-specific NER task, Tomori et al. [139] used softmax as tag decoder to predict game states in Japanese chess game. Their model takes both input from text and input from chess board (9×9 squares with 40 pieces of 14 different types) and predict 21 named entities specific to this game. Text representations and game state embeddings are both fed to a softmax layer for prediction of named entities using BIO tag scheme.

3.4.2 Conditional Random Fields
A conditional random field is a random field globally conditioned on the observation sequence [72]. CRFs have been widely used in feature-based supervised learning approaches (see Section 2.4.3). Many deep learning based NER models use a CRF layer as the tag decoder, e.g., on top of an bidirectional LSTM layer [18], [89], [102], [140], and on top of a CNN layer [17], [90], [93]. Listed in Table 3, CRF is the most common choice for tag decoder, and the state-of-the-art performance on CoNLL03 and OntoNotes5.0 is achieved by [106] with a CRF tag decoder.

CRFs, however, cannot make full use of segment-level information because the inner properties of segments cannot be fully encoded with word-level representations. Zhuo et al. [141] then proposed gated recursive semi-markov CRFs, which directly model segments instead of words, and automatically extract segment-level features through a gated recursive convolutional neural network. Recently, Ye and Ling [142] proposed hybrid semi-Markov CRFs for neural sequence labeling. This approach adopts segments instead of words as the basic units for feature extraction and transition modeling. Word-level labels are utilized in deriving segment scores. Thus, this approach is able to leverage both word- and segment-level information for segment score calculation.

3.4.3 Recurrent Neural Networks
A few studies [87], [88], [89], [95], [143] have explored RNN to decode tags. Shen et al. [87] reported that RNN tag decoders outperform CRF and are faster to train when the number of entity types is large. Fig. 12c illustrates the workflow of RNN-based tag decoders, which serve as a language model to greedily produce a tag sequence. The [GO]-symbol at the first step is provided as y1 to the RNN decoder. Subsequently, at each time step i, the RNN decoder computes current decoder hidden state hDeci+1 in terms of previous step tag yi, previous step decoder hidden state hDeci and current step encoder hidden state hEnci+1; the current output tag yi+1 is decoded by using a softmax loss function and is further fed as an input to the next time step. Finally, we obtain a tag sequence over all time steps.

3.4.4 Pointer Networks
Pointer networks apply RNNs to learn the conditional probability of an output sequence with elements that are discrete tokens corresponding to the positions in an input sequence [144], [145]. It represents variable length dictionaries by using a softmax probability distribution as a “pointer”. Zhai et al. [94] first applied pointer networks to produce sequence tags. Illustrated in Fig. 12d, pointer networks first identify a chunk (or a segment), and then label it. This operation is repeated until all the words in input sequence are processed. In Fig. 12d, given the start token “<s>”, the segment “Michael Jeffery Jordan” is first identified and then labeled as “PERSON”. The segmentation and labeling can be done by two separate neural networks in pointer networks. Next, “Michael Jeffery Jordan” is taken as input and fed into pointer networks. As a result, the segment “was” is identified and labeled as “O”.

3.5 Summary of DL-Based NER
Architecture Summary. Table 3 summarizes recent works on neural NER by their architecture choices. BiLSTM-CRF is the most common architecture for NER using deep learning. The method [131] which pre-trains a bi-directional Transformer model in a cloze-style manner, achieves the state-of-the-art performance (93.5 percent) on CoNLL03. The work with BERT and dice loss [137] achieves the state-of-the-art performance (92.07 percent) on OntoNotes5.0.

The success of a NER system heavily relies on its input representation. Integrating or fine-tuning pre-trained language model embeddings is becoming a new paradigm for neural NER. When leveraging these language model embeddings, there are significant performance improvements [102], [106], [107], [131], [132], [133], [134], [135], [136], [137]. The last column in Table 3 lists the reported performance in F-score on a few benchmark datasets. While high F-scores have been reported on formal documents (e.g., CoNLL03 and OntoNotes5.0), NER on noisy data (e.g., W-NUT17) remains challenging.

Architecture Comparison. We discuss pros and cons from three perspectives: input, encoder, and decoder. First, no consensus has been reached about whether external knowledge should be or how to integrate into DL-based NER models. Some studies [107], [109], [132], [141] shows that NER performance can be boosted with external knowledge. However, the disadvantages are also apparent: 1) acquiring external knowledge is labor-intensive (e.g., gazetteers) or computationally expensive (e.g., dependency); 2) integrating external knowledge adversely affects end-to-end learning and hurts the generality of DL-based systems.

Second, Transformer encoder is more effective than LSTM when Transformer is pre-trained on huge corpora. Transformers fail on NER task if they are not pre-trained and when the training data is limited [146], [147]. On the other hand, Transformer encoder is faster than recursive layers when the length of the sequence n is smaller than the dimensionality of the representation d (complexities: self-attention O(n2⋅d) and recurrent O(n⋅d2)) [127].

Third, a major disadvantage of RNN and Pointer Network decoders lies in greedily decoding, which means that the input of current step needs the output of previous step. This mechanism may have a significant impact on the speed and is an obstacle to parallelization. CRF is the most common choice for tag decoder. CRF is powerful to capture label transition dependencies when adopting non-language-model (i.e., non-contextualized) embeddings such as Word2vec and GloVe. However, CRF could be computationally expensive when the number of entity types is large. More importantly, CRF does not always lead to better performance compared with softmax classification when adopting contextualized language model embeddings such as BERT and ELMo [136], [138].

For end users, what architecture to choose is data and domain task dependent. If data is abundant, training models with RNNs from scratch and fine-tuning contextualized language models could be considered. If data is scarce, adopting transfer strategies might be a better choice. For newswires domain, there are many pre-trained off-the-shelf models available. For specific domains (e.g., medical and social media), fine-tuning general-purpose contextualized language models with domain-specific data is often an effective way.

NER for Different Languages. In this survey, we mainly focus on NER in English and in general domain. Apart from English language, there are many studies on other languages or cross-lingual settings. Wu et al. [119] and Wang et al. [148] investigated NER in Chinese clinical text. Zhang and Yang [149] proposed a lattice-structured LSTM model for Chinese NER, which encodes a sequence of input characters as well as all potential words that match a lexicon. Other than Chinese, many studies are conducted on other languages. Examples include Mongolian [150], Czech [151], Arabic [152], Urdu [153], Vietnamese [154], Indonesian [155], and Japanese [156]. Each language has its own characteristics for understanding the fundamentals of NER task on that language. There are also a number of studies [105], [157], [158], [159] aiming to solve the NER problem in a cross-lingual setting by transferring knowledge from a source language to a target language with few or no labels.

SECTION 4Applied Deep Learning for NER
Sections 3.2, 3.3, and 3.4 outline typical network architectures for NER. In this section, we survey recent applied deep learning techniques that are being explored for NER.

4.1 Deep Multi-Task Learning for NER
Multi-task learning [160] is an approach that learns a group of related tasks together. By considering the relation between different tasks, multi-task learning algorithms are expected to achieve better results than the ones that learn each task individually.

Collobert et al. [17] trained a window/sentence approach network to jointly perform POS, Chunk, NER, and SRL tasks. This multi-task mechanism lets the training algorithm to discover internal representations that are useful for all the tasks of interest. Yang et al. [105] proposed a multi-task joint model, to learn language-specific regularities, jointly trained for POS, Chunk, and NER tasks. Rei [123] found that by including an unsupervised language modeling objective in the training process, the sequence labeling model achieves consistent performance improvement. Lin et al. [159] proposed a multi-lingual multi-task architecture for low-resource settings, which can effectively transfer different types of knowledge to improve the main model.

Other than considering NER together with other sequence labeling tasks, multi-task learning framework can be applied for joint extraction of entities and relations [89], [95], or to model NER as two related subtasks: entity segmentation and entity category prediction [113], [161]. In biomedical domain, because of the differences in different datasets, NER on each dataset is considered as a task in a multi-task setting [162], [163]. A main assumption here is that the different datasets share the same character- and word-level information. Then multi-task learning is applied to make more efficient use of the data and to encourage the models to learn more generalized representations.

4.2 Deep Transfer Learning for NER
Transfer learning aims to perform a machine learning task on a target domain by taking advantage of knowledge learned from a source domain [164]. In NLP, transfer learning is also known as domain adaptation. On NER tasks, the traditional approach is through bootstrapping algorithms [165], [166], [167]. Recently, a few approaches [126], [168], [169], [170], [171], [172] have been proposed for low-resource and across-domain NER using deep neural networks.

Pan et al. [168] proposed a transfer joint embedding (TJE) approach for cross-domain NER. TJE employs label embedding techniques to transform multi-class classification to regression in a low-dimensional latent space. Qu et al. [173] observed that related named entity types often share lexical and context features. Their approach learns the correlation between source and target named entity types using a two-layer neural network. Their approach is applicable to the setting that the source domain has similar (but not identical) named entity types with the target domain. Peng and Dredze [161] explored transfer learning in a multi-task learning setting, where they considered two domains: news and social media, for two tasks: word segmentation and NER.

In the setting of transfer learning, different neural models commonly share different parts of model parameters between source task and target task. Yang et al. [174] first investigated the transferability of different layers of representations. Then they presented three different parameter-sharing architectures for cross-domain, cross-lingual, and cross-application scenarios. If two tasks have mappable label sets, there is a shared CRF layer, otherwise, each task learns a separate CRF layer. Experimental results show significant improvements on various datasets under low-resource conditions (i.e., fewer available annotations). Pius and Mark [175] extended Yang's approach to allow joint training on informal corpus (e.g., WNUT 2017), and to incorporate sentence level feature representation. Their approach achieved the 2nd place at the WNUT 2017 shared task for NER, obtaining an F1-score of 40.78 percent. Zhao et al. [176] proposed a multi-task model with domain adaption, where the fully connection ayer are adapted to different datasets, and the CRF features are computed separately. A major merit of Zhao's model is that the instances with different distribution and misaligned annotation guideline are filtered out in data selection procedure. Different from these parameter-sharing architectures, Lee et al. [169] applied transfer learning in NER by training a model on source task and using the trained model on target task for fine-tuning. Recently, Lin and Lu [170] also proposed a fine-tuning approach for NER by introducing three neural adaptation layers: word adaptation layer, sentence adaptation layer, and output adaptation layer. Beryozkin et al. [177] proposed a tag-hierarchy model for heterogeneous tag-sets NER setting, where the hierarchy is used during inference to map fine-grained tags onto a target tag-set. In addition, some studies [163], [178], [179] explored transfer learning in biomedical NER to reduce the amount of required labeled data.

4.3 Deep Active Learning for NER
The key idea behind active learning is that a machine learning algorithm can perform better with substantially less data from training, if it is allowed to choose the data from which it learns [180]. Deep learning typically requires a large amount of training data which is costly to obtain. Thus, combining deep learning with active learning is expected to reduce data annotation effort.

Training with active learning proceeds in multiple rounds. However, traditional active learning schemes are expensive for deep learning because after each round they require complete retraining of the classifier with newly annotated samples. Because retraining from scratch is not practical for deep learning, Shen et al. [87] proposed to carry out incremental training for NER with each batch of new labels. They mix newly annotated samples with the existing ones, and update neural network weights for a small number of epochs, before querying for labels in a new round. Specifically, at the beginning of each round, the active learning algorithm chooses sentences to be annotated, to the predefined budget. The model parameters are updated by training on the augmented dataset, after receiving chose annotations. The active learning algorithm adopts uncertainty sampling strategy [181] in selecting sentences to be annotated. Experimental results show that active learning algorithms achieve 99 percent performance of the best deep learning model trained on full data using only 24.9 percent of the training data on the English dataset and 30.1 percent on Chinese dataset. Moreover, 12.0 and 16.9 percent of training data were enough for deep active learning model to outperform shallow models learned on full training data [182].

4.4 Deep Reinforcement Learning for NER
Reinforcement learning (RL) is a branch of machine learning inspired by behaviorist psychology, which is concerned with how software agents take actions in an environment so as to maximize some cumulative rewards [183], [184]. The idea is that an agent will learn from the environment by interacting with it and receiving rewards for performing actions. Specifically, the RL problem can be formulated as follows [185]: the environment is modeled as a stochastic finite state machine with inputs (actions from agent) and outputs (observations and rewards to the agent). It consists of three key components: (i) state transition function, (ii) observation (i.e., output) function, and (iii) reward function. The agent is also modeled as a stochastic finite state machine with inputs (observations/rewards from the environment) and outputs (actions to the environment). It consists of two components: (i) state transition function, and (ii) policy/output function. The ultimate goal of an agent is to learn a good state-update function and policy by attempting to maximize the cumulative rewards.

Narasimhan et al. [186] modeled the task of information extraction as a Markov decision process (MDP), which dynamically incorporates entity predictions and provides flexibility to choose the next search query from a set of automatically generated alternatives. The process is comprised of issuing search queries, extraction from new sources, and reconciliation of extracted values, and the process repeats until sufficient evidence is obtained. In order to learn a good policy for an agent, they utilize a deep Q-network [187] as a function approximator, in which the state-action value function (i.e., Q-function) is approximated by using a deep neural network. Recently, Yang et al. [188] utilized the data generated by distant supervision to perform new type named entity recognition in new domains. The instance selector is based on reinforcement learning and obtains the feedback reward from the NE tagger, aiming at choosing positive sentences to reduce the effect of noisy annotation.

4.5 Deep Adversarial Learning for NER
Adversarial learning [189] is the process of explicitly training a model on adversarial examples. The purpose is to make the model more robust to attack or to reduce its test error on clean inputs. Adversarial networks learn to generate from a training distribution through a 2-player game: one network generates candidates (generative network) and the other evaluates them (discriminative network). Typically, the generative network learns to map from a latent space to a particular data distribution of interest, while the discriminative network discriminates between candidates generated by the generator and instances from the real-world data distribution [190].

For NER, adversarial examples are often produced in two ways. Some studies [191], [192], [193] considered the instances in a source domain as adversarial examples for a target domain, and vice versa. For example, Li et al. [192] and Cao et al. [193] both incorporated adversarial examples from other domains to encourage domain-invariant features for cross-domain NER. Another option is to prepare an adversarial sample by adding an original sample with a perturbation. For example, dual adversarial transfer network (DATNet), proposed in [194], aims to deal with the problem of low-resource NER. An adversarial sample is produced by adding original sample with a perturbation bounded by a small norm ϵ to maximize the loss function as follows: ηx=argmaxη:∥η∥2≤ϵl(Θ;x+η), where Θ is the current model parameters set, ϵ can be determined on validation set. An adversarial example is constructed by xadv=x+ηx. The classifier is trained on the mixture of original and adversarial examples to improve generalization.

4.6 Neural Attention for NER
The attention mechanism is loosely based on the visual attention mechanism found in human [195]. For example, people usually focus on a certain region of an image with “high resolution” while perceiving the surrounding region with “low resolution”. Neural attention mechanism allows neural networks have the ability to focus on a subset of its inputs. By applying attention mechanism, a NER model could capture the most informative elements in the inputs. In particular, the Transformer architecture reviewed in Section 3.3.5 relies entirely on attention mechanism to draw global dependencies between input and output.

There are many other ways of applying attention mechanism in NER tasks. Rei et al. [104] applied an attention mechanism to dynamically decide how much information to use from a character- or word-level component in an end-to-end NER model. Zukov-Gregoric et al. [196] explored the self-attention mechanism in NER, where the weights are dependent on a single sequence (rather than on the relation between two sequences). Xu et al. [197] proposed an attention-based neural NER architecture to leverage document-level global information. In particular, the document-level information is obtained from document represented by pre-trained bidirectional language model with neural attention. Zhang et al. [198] used an adaptive co-attention network for NER in tweets. This adaptive co-attention network is a multi-modal model using co-attention process. Co-attention includes visual attention and textual attention to capture the semantic interaction between different modalities.

SECTION 5Challenges and Future Directions
Discussed in Section 3.5, the choices tag decoders do not vary as much as the choices of input representations and context encoders. From Google Word2vec to the more recent BERT model, DL-based NER benefits significantly from the advances made in pre-trained embeddings in modeling languages. Without the need of complicated feature-engineering, we now have the opportunity to re-look the NER task for its challenges and potential future directions.

5.1 Challenges
Data Annotation. Supervised NER systems, including DL-based NER, require big annotated data in training. However, data annotation remains time consuming and expensive. It is a big challenge for many resource-poor languages and specific domains as domain experts are needed to perform annotation tasks.

Quality and consistency of the annotation are both major concerns because of the language ambiguity. For instance, a same named entity may be annotated with different types. As an example, “Baltimore” in the sentence “Baltimore defeated the Yankees”, is labeled as Location in MUC-7 and Organization in CoNLL03. Both “Empire State” and “Empire State Building”, is labeled as Location in CoNLL03 and ACE datasets, causing confusion in entity boundaries. Because of the inconsistency in data annotation, model trained on one dataset may not work well on another even if the documents in the two datasets are from the same domain.

To make data annotation even more complicated, Katiyar and Cardie [121] reported that nested entities are fairly common: 17 percent of the entities in the GENIA corpus are embedded within another entity; in the ACE corpora, 30 percent of sentences contain nested entities. There is a need to develop common annotation schemes to be applicable to both nested entities and fine-grained entities, where one named entity may be assigned multiple types.

Informal Text and Unseen Entities. Listed in Table 3, decent results are reported on datasets with formal documents (e.g., news articles). However, on user-generated text e.g., WUT-17 dataset, the best F-scores are slightly above 40 percent. NER on informal text (e.g., tweets, comments, user forums) is more challenging than on formal text due to the shortness and noisiness. Many user-generated texts are domain specific as well. In many application scenarios, a NER system has to deal with user-generated text such as customer support in e-commerce and banking.

Another interesting dimension to evaluate the robustness and effectiveness of NER system is its capability of identifying unusual, previously-unseen entities in the context of emerging discussions. There exists a shared task2 for this direction of research on WUT-17 dataset [199].

5.2 Future Directions
With the advances in modeling languages and demand in real-world applications, we expect NER to receive more attention from researchers. On the other hand, NER is in general considered as a pre-processing component to downstream applications. That means a particular NER task is defined by the requirement of downstream application, e.g., the types of named entities and whether there is a need to detect nested entities [200]. Based on the studies in this survey, we list the following directions for further exploration in NER research.

Fine-Grained NER and Boundary Detection. While many existing studies [19], [96], [108] focused on coarse-grained NER in general domain, we expect more research on fine-grained NER in domain-specific areas to support various real word applications [201]. The challenges in fine-grained NER are the significant increase in NE types and the complication introduced by allowing a named entity to have multiple NE types. This calls for a re-visit of the common NER approaches where the entity boundaries and the types are detected simultaneously e.g., by using B- I- E- S-(entity type) and O as the decoding tags. It is worth considering to define named entity boundary detection as a dedicated task to detect NE boundaries while ignoring the NE types. The decoupling of boundary detection and NE type classification enables common and robust solutions for boundary detection that can be shared across different domains, and dedicated domain-specific approaches for NE type classification. Correct entity boundaries also effectively alleviate error propagation in entity linking to knowledge bases. There has been some studies [94], [202] which consider entity boundary detection as an intermediate step (i.e., a subtask) in NER. To the best of our knowledge, no existing work separately focuses on entity boundary detection to provide a robust recognizer. We expect a breakout in this research direction in the future.

Joint NER and Entity Linking. Entity linking (EL) [203], also known as named entity disambiguation or normalization, is the task to determine the identity of entities mentioned in text with reference to a knowledge base, e.g., Wikipedia in general domain and the Unified Medical Language System (UMLS) in biomedical domain. Most existing studies consider NER and entity linking as two separate tasks in a pipeline setting. We consider that the semantics carried by the successfully linked entities (e.g., through the related entities in the knowledge base) are significantly enriched [65], [204]. That is, linked entities contributes to the successful detection of entity boundaries and correct classification of entity types. It is worth exploring approaches for jointly performing NER and EL, or even entity boundary detection, entity type classification, and entity linking, so that each subtask benefits from the partial output by other subtasks, and alleviate error propagations that are unavoidable in pipeline settings.

DL-Based NER on Informal Text With Auxiliary Resource. As discussed in Section 5.1, performance of DL-based NER on informal text or user-generated content remains low. This calls for more research in this area. In particular, we note that the performance of NER benefits significantly from the availability of auxiliary resources [205], [206], [207], e.g., a dictionary of location names in user language. While Table 3 does not provide strong evidence of involving gazetteer as additional features leads to performance increase to NER in general domain, we consider auxiliary resources are often necessary to better understand user-generated content. The question is how to obtain matching auxiliary resources for a NER task on user-generated content or domain-specific text, and how to effectively incorporate the auxiliary resources in DL-based NER.

Scalability of DL-Based NER. Making neural NER models more scalable is still a challenge. Moreover, there is still a need for solutions on optimizing exponential growth of parameters when the size of data grows [208]. Some DL-based NER models have achieved good performance with the cost of massive computing power. For example, the ELMo representation represents each word with a 3×1024-dimensional vector, and the model was trained for 5 weeks on 32 GPUs [106]. Google BERT representations were trained on 64 cloud TPUs. However, end users are not able to fine-tune these models if they have no access to powerful computing resources. Developing approaches to balancing model complexity and scalability will be a promising direction. On the other hand, model compression and pruning techniques are also options to reduce the space and computation time required for model learning.

Deep Transfer Learning for NER. Many entity-focused applications resort to off-the-shelf NER systems to recognize named entities. However, model trained on one dataset may not work well on other texts due to the differences in characteristics of languages as well as the differences in annotations. Although there are some studies of applying deep transfer learning to NER (see Section 4.2), this problem has not been fully explored. More future efforts should be dedicated on how to effectively transfer knowledge from one domain to another by exploring the following research problems: (a) developing a robust recognizer, which is able to work well across different domains; (b) exploring zero-shot, one-shot and few-shot learning in NER tasks; (c) providing solutions to address domain mismatch, and label mismatch in cross-domain settings.

An Easy-to-Use Toolkit for DL-Based NER. Recently, Röder et al. [209] developed GERBIL, which provides researchers, end users and developers with easy-to-use interfaces for benchmarking entity annotation tools with the aim of ensuring repeatable and archiveable experiments. However, it does not involve recent DL-based techniques. Ott [210] presented FAIRSEQ, a fast, extensible toolkit for sequence modeling, especially for machine translation and text stigmatization. Dernoncourt et al. [211] implemented a framework, named NeuroNER, which only relies on a variant of recurrent neural network. In recent years, many deep learning frameworks (e.g., TensorFlow, PyTorch, and Keras) have been designed to offer building blocks for designing, training and validating deep neural networks, through a high level programming interface.3In order to re-implement the architectures in Table 3, developers may write codes from scratch with existing deep learning frameworks. We envision that an easy-to-use NER toolkit can guide developers to complete it with some standardized modules: data-processing, input representation, context encoder, tag decoder, and effectiveness measure. We believe that experts and non-experts can both benefit from such toolkits.

SECTION 6Conclusion
This survey aims to review recent studies on deep learning-based NER solutions to help new researchers building a comprehensive understanding of this field. We include in this survey the background of the NER research, a brief of traditional approaches, current state-of-the-arts, and challenges and future research directions. First, we consolidate available NER resources, including tagged NER corpora and off-the-shelf NER systems, with focus on NER in general domain and NER in English. We present these resources in a tabular form and provide links to them for easy access. Second, we introduce preliminaries such as definition of NER task, evaluation metrics, traditional approaches to NER, and basic concepts in deep learning. Third, we review the literature based on varying models of deep learning and map these studies according to a new taxonomy. We further survey the most representative methods for recent applied deep learning techniques in new problem settings and applications. Finally, we summarize the applications of NER and present readers with challenges in NER and future directions. We hope that this survey can provide a good reference when designing DL-based NER models.