With the ever-increasing urbanization process, modeling people's spatiotemporal activities from their online traces has become a crucial task. State-of-the-art methods for this task rely on cross-modal embedding, which maps items from different modalities (e.g., location, time, text) into the same latent space. Despite their inspiring results, existing cross-modal embedding methods merely capture co-occurrences between items without modeling their high-order interactions. In this paper, we first construct two graphs from raw data records to represent the user interaction graph layer and activity graph layer and propose a hierarchical cross-modal embedding method that takes the high-order relationships into consideration. The key notion behind our method is a novel hierarchical embedding framework with meta-graphs connecting different layers. We introduce both inter-record and intra-record meta-graph structures, which enable learning distributed representations that preserve high-order proximities across graphs from different layers. Our empirical experiments on three real-world datasets demonstrate that our method not only outperforms state-of-the-art methods for spatiotemporal activity prediction, but also captures cross-modal proximity at a finer granularity.
SECTION 1Introduction
With the rapid progress of urbanization [1], [2] worldwide, urban centres with large numbers of inhabitants are incessant to gather. According to the World Urbanization Prospects1 published by the United Nations in 2018, the urban population of the world has increased to 4.2 billion, 55 percent of the world's population, in 2018 and by 2050, 68 percent of the world's population is projected to be urban. With such rapid urbanization process around the world, modeling people's activities has been recognized as an essential task [3] to handle with urban challenges like traffic congestion and resource allocation. Besides, choosing when and where to visit, eat or relax has become a fundamental demand for almost everyone, no matter local residents or ecdemic tourists. Answering questions like “Where should a shopping mania who cares about accessible transportation go?”, “What are the popular activities around the beach at dusk?” and “When is the fit time for visiting the changing of the guard at the palace?” has become challenging not only for tourists, but even for local residents in the city because of their complex spatiotemporal dynamics.

Spatiotemporal activity modeling, which aims at modeling people's activities in different locations and time periods, plays an important role in solving these problems [3], [4]. The recent outgrowth of mobile data (e.g., geo-tagged social media, cellular data) sheds new light on automating this task. The number of worldwide mobile users has grown to 6.8 billion2 and people can post their activities almost anytime and anywhere through their in-hand GPS-enabled mobile devices. Therefore, the mobile data provide an extensive and detailed coverage of urban activities, serving as a natural proxy for modeling human activities in urban spaces [5], [6], [7], [8].

The key to modeling spatiotemporal activities from mobile data is to define a cross-modal similarity that can capture the proximities between different modalities, e.g., location, time, and text. Most previous approaches exploit latent variable models for this problem [9], [10], [11], [12], [13], but such approaches are unscalable and rely on many prior distribution assumptions which may deviate from real data. Recently, cross-modal embedding methods [7], [14] have demonstrated inspiring results in this problem. Based on their co-occurrences within the same record, cross-modal embedding methods map items from different modalities into the same latent space to preserve their proximities.

Despite the remarkable success of existing cross-modal embedding techniques, they suffer from two major drawbacks in capturing item similarities. First, the interactions among items across different records are not adequately explored. For example, Fig. 1 demonstrates a pair of tweets, which is correlated through an “@” between two users. We can see User A is talking about a newly released movie, but the keywords are actually more related to the location and time specified by User B. Such proximities can be captured by high-order analysis of the information flow “text → user → user ⟨location, time⟩” across records, but would be missed if we only consider co-occurrences within single record. If we model user interactions at one layer and the activity at another layer, this kind of inter-record relationship will exist hierarchically across the two layers. Statistical data exhibit these inter-record interactions are prevalent in real-world corpus, e.g., 16.8 percent records have mentioned other users in UTGEO2011 dataset.3 Taking such inter-record relationships into consideration may be useful for exploiting high-order information in the results of cross-modal predictions and facilitate the imperfects of previous alternatives.

Fig. 1. - 
Interactions between records of text-rich mobile data.
Fig. 1.
Interactions between records of text-rich mobile data.

Show All

Second, the semantics of the text intra the same record are not fully exploited. Existing methods usually regard each word as a basic textual unit and learn its embedding individually. However, it is known that the semantic meaning of a keyword depends on its context. As a result, conventional methods may suffer from the word sense disambiguation (WSD) problem since they fail to recognize context of keywords and capture the disambiguated meaning of them. For example, the keyword “ape” may indicate “imitate uncritically”. But when surrounded by “drawn” and “planet”, it should be recognized as “gorilla”, and the phrase refers to a movie name. Therefore, the whole text message needs to be considered together when embedding the textual units of text-rich mobile data, which may enhance the performance of cross-modal embedding.

In this paper, we propose spatiotemporal activity modeling via hierarchical cross-modal embedding (ACTOR for short) from mobile data. Our method embeds items from different modalities (location, time, text) into a latent vector space, but differs from existing cross-modal embedding techniques in that it adopts a hierarchical embedding framework to preserve kinds of high-order item proximities. The hierarchy lies between the different constructed graphs from the raw mobile data. To fully encode the cross-modal co-occurrence relationship and user interactions, we first construct an activity graph and a user interaction graph, respectively. Then two kinds of meta-graphs, namely inter-record and intra-record meta-graphs are devised based on these two graphs to encode high-order relationships. Each graph acts as an embedding layer while nodes from different layers are embedded with the aid of meta-graphs. High-order proximity of vertices are preserved by the proposed meta-graphs because they include more than two pass-through hops in the graph. A hierarchical embedding framework is proposed based on meta-graphs which can preserve high-order proximities. Previous models could be considered as a single-layer special case of our framework.

We have performed experiments on three real-world datasets. The results demonstrate that the embeddings learned by ACTOR not only achieve the best quantitative performance in the cross-modal prediction tasks compared with the state-of-the-arts, but also preserve cross-modal proximities at a finer granularity. To the best of our knowledge, we are the first attempt to adopt hierarchical cross-modal embedding to model high-order information when modeling spatiotemporal activities.

The main contributions of this paper are highlighted as follows:

We propose a novel hierarchical cross-modal representation learning method for spatiotemporal activity modeling, which can preserve high-order proximities in mobile data. Different from previous studies, high-order information plays an important role in our embedding algorithm.

We propose a flexible meta-graph based embedding framework named ACTOR, which can perform hierarchical embedding on graphs of different layers. Specifically, we investigate several kinds of high-order meta-graphs in the proposed embedding algorithm.

We evaluate the effectiveness and efficiency of ACTOR on three real-world datasets. Experimental results demonstrate that ACTOR is a scalable framework and significantly outperforms the state-of-the-art methods in the tasks of cross-modal prediction and neighbor search.

The remainder of the paper is organized as follows. We summarize the related work in Section 2 and give the problem definition and overview in Section 3. Subsequently, graph construction and proximity are presented in Section 4. We introduce the framework of our method in Section 5, and the experimental results are shown in Section 6. We conclude this paper in Section 7.

SECTION 2Related Work
In this section, we briefly review the existing work related to our problem from the following three aspects: spatiotemporal activity modeling, graph representation learning and hierarchical graph embedding.

2.1 Spatiotemporal Activity Modeling
Spatiotemporal activity modeling has been receiving increasing research interest in the past few years. Existing methods can be categorized into two categories: topic model based and embedding based methods. Generally, the former extends classic topic models to bridge different data modalities, by assuming each latent topic can generate observations over not only textual keywords but also locations. [15] extends LDA by assuming multinomial distribution on text and Gaussian distribution over regions and [16] extends the model to more complex distributions. Kling et al. [17] extend PLSA with similar assumptions. One common limitation of the above methods is that they have to impose distribution assumptions on different modalities, which may not fit the true distribution in the real data well. Recently, embedding-based methods [7], [8], [14], [18], [19] have been proposed for spatiotemporal activity modeling. Zheng et al. [18] build a user-location-activity tensor and use factorization to learn latent representations for users and locations for personalized recommendation. Zhang et al. [7] propose a cross-modal embedding which maps different spatial units, temporal units and textual units into the same latent space to obtain their vector representations. Later on, they also develop a method [8] that processes continuous data streams and reveals recency-aware spatiotemporal activities. To address data scarcity problem, Zhang et al. design approaches [14] to transfer knowledge from external sources. Recently, some other researches focus on modeling sequential spatiotemporal activities, e.g., human flow prediction, etc. For example, Wang et al. [19] learn the representations from a flow graph and a spatial graph. Feng et al. [20] propose an attentional model named DeepMove to predict human mobility from the sparse and lengthy trajectories. Lin et al. [21] propose a deep learning-based convolutional model DeepSTN+ to predict crowd flows in the metropolis. Our work is related to [7] as we both use graph embedding for cross-modal representation learning. However, they do not consider high-order information like social relationship or semantic meaning.

2.2 Graph Representation Learning
Graph representation learning (also known as graph embedding) aims to learn low-dimensional representations for nodes or sub-graphs whose topological correlativeness in original graphs are preserved. Current methods can be categorized into random walk based and neural network based methods.

DeepWalk [22] is a representative homogeneous graph embedding method, which generalizes the skip-gram model in language modeling to graphs and exploits random walks to learn the features of vertices. Node2vec [23] investigates biased random walk to capture the diversity of connectivity patterns in networks. Tang et al. [24] introduce LINE, which defines loss functions to preserve the first-order and second-order proximity. Our work is different from DeepWalk, node2vec and LINE because they all belong to homogeneous graph embedding but the activity graph in this paper is a heterogeneous graph. Metapath2vec [25] is a recent representative heterogeneous graph embedding algorithm. It formalizes meta-path based random walks on the heterogeneous graph, which is not directly applicable for meta-graph based embedding in this paper.

Graph neural network [26], [27] is a series of neural network based graph representation learning methods. Graph convolutional neural network generalizes convolution operation to the graph domain, which can further be categorized as spectral approaches and spatial approaches. Spectral approaches [28], [29], [30], [31] work with a spectral representation of the graphs and the learned filters depend on the Laplacian eigenbasis. Spatial approaches [32], [33], [34] define convolutions directly on the graph. Our work is different from these graph neural network approaches since the main technical part of this paper belongs to random walk based methods. Therefore, we do not adopt neural network based methods as our baselines.

2.3 Hierarchical Graph Embedding
Recently, several attempts have been made to explore the hierarchical representations of nodes and graphs. For instance, Kriegel et al. [35] extend reference node embedding for approximating shortest path distance on graphs and propose hierarchical embedding to solve the problem of high storage cost. Mousavi et al. [36] propose a hierarchical framework which extracts local and global features from different scales of given graph at the same time. NetHiex [37] incorporates the hierarchical taxonomy into network embedding and HARP [38] decomposes a graph in a series of levels, and then embeds the hierarchy of graphs from the coarsest one to the original graph. DIFFPOOL [39] is a differentiable graph pooling module to generate hierarchical representations of graphs for the task of graph classification. Different from the above algorithms, the hierarchical learning process in this paper lies in modeling high-order relationships across or inside the records of text-rich mobile data, which are encoded by the proposed two kinds of meta-graphs.

SECTION 3Problem Definition and Overview
In this section, we give the description of mobile data and the problem definition of spatiotemporal activity modeling.

Let R={r1,r2,…,rN} be a corpus of mobile data records. Each record ri∈R is defined by a tuple ⟨ti,li,Wi⟩, i=1,2,…,N, where

ti is the creating timestamp of ri;

li is a two-dimensional vector that represents the user's location when ri is created;

Wi={wi1,…,win} is a bag of keywords denoting the text message of ri;

The problem of spatiotemporal activity modeling in this paper is to mine R and find some regularities of people's daily life. As there are three factors that are intertwined, an effective spatiotemporal activity model should accurately capture their cross-modal correlations. In another word, given any two of the three factors, the model is expected to predict the remaining one. Formally:

Activity prediction. Given t∗, l∗ and a text candidate set Cw={w1,…,wm}, find the most possible activity keyword w∗ from Cw;

Location prediction. Given t∗, W∗ and a location candidate set Cl={l1,…,lm}, find the most possible location l∗ from Cl;

Time prediction. Given l∗, W∗ and a time candidate set Ct={t1,…,tm}, find the most possible time t∗ from Ct.

An overview of the ACTOR framework could be found in Fig. 2. Hotspot detection is first conducted on the raw mobile data records and then we design two kinds of graphs to describe the data. After that, the hierarchical embedding algorithm could be applied on those graphs for downstream tasks like cross-modal prediction.

Fig. 2. - 
The overview framework of ACTOR.
Fig. 2.
The overview framework of ACTOR.

Show All

SECTION 4Graph Construction and Proximity
In this section, we first construct the activity graph and user interaction graph. Then we define proximity of different orders. Last, the algorithm for detecting spatial and temporal hotspots is introduced.

4.1 Activity Graph and User Interaction Graph
Definition 1 (Activity Graph).
An activity graph G=(V,E) is a heterogeneous graph, where V={v1,…,vn} is a set of vertices including spatial, temporal and textual units, and E is a set of edges, eij∈E if and only if vi and vj appear in the same record, i≠j, i,j∈{1,…,n}. Moreover, G is associated with an vertex type mapping function fv:V→Ov and an edge type mapping function fe:E→Oe, where Ov={T,L,W} represents the vertex type set and Oe={TL,LW,WT,WW} represents the edge type set. Within each edge type, the edge weight is set to be the co-occurrence count.

Besides the co-occurrence of these units, mobile users often mention others in their own posts. Consequently, we can construct a user interaction graph to model this kind of behavior. Formally, we have the following definition.

Definition 2 (User Interaction Graph).
A user interaction graph G′=(V′,E′) is a homogeneous graph, where vi∈V′ represents a mobile user and eij∈E′ indicates that user i mentioned another user j, i,j∈{1,…,|V′|}. The edge weight is set to be the mentioned counts.

As the example shown in Fig. 1, we can construct the corresponding activity graph and user interaction graph demonstrated in Fig. 3a. User B has mentioned user A in the textual records so there is an edge between user A and user B. The activity graph contains three modalities. The spatial unit comes from the location of the activity and the temporal unit derives from the created timestamp. These units are called spatial and temporal hotspots and the detection algorithm would be detailed in Section 4.3. The textual unit refers to the bag of words model in each record, where some frequent and meaningless words are removed. Since each co-occurrence appears only once, the weights of all edge are set to be 1 and we omit its weights for brevity.

Fig. 3. - 
(a) An illustrative example of the hierarchical embedding framework. $\mathsf {T}_i$Ti and $\mathsf {L}_i$Li ($i=1,2$i=1,2) are the spatial and temporal units derived from the timestamps and locations of the tweets. The textual units $\mathsf {W}_i$Wi ($i=1,2$i=1,2) correspond to the words in the dashed box. Two units are connected if they appear in the same record. User ${\sf B}$B mentioned user ${\sf A}$A in the text thus the two users are linked. (b) The intra-record meta-graph $\mathsf {M}_0$M0 are constructed according to the co-occurrence relationships of the spatial, temporal and textual units, which models high-order relationships inside records. The inter-record meta-graphs are built between the records who mentioned each other via the user interaction graph, which model high-order relationships between records. $\mathsf {M}_1$M1 to $\mathsf {M}_6$M6 are categorized according to different combinations of units connected to the users. The nodes and edges marked in blue color denote an instance of $\mathsf {M}_4$M4.
Fig. 3.
(a) An illustrative example of the hierarchical embedding framework. Ti and Li (i=1,2) are the spatial and temporal units derived from the timestamps and locations of the tweets. The textual units Wi (i=1,2) correspond to the words in the dashed box. Two units are connected if they appear in the same record. User B mentioned user A in the text thus the two users are linked. (b) The intra-record meta-graph M0 are constructed according to the co-occurrence relationships of the spatial, temporal and textual units, which models high-order relationships inside records. The inter-record meta-graphs are built between the records who mentioned each other via the user interaction graph, which model high-order relationships between records. M1 to M6 are categorized according to different combinations of units connected to the users. The nodes and edges marked in blue color denote an instance of M4.

Show All

4.2 Definition of Proximity
Based on a graph, we could define first-order proximity and second-order proximity. Furthermore, high-order proximity could also be introduced.

Definition 3 (First-order Proximity).
Given a graph G=(V,E), V={v1,…,vn}, the first-order proximity between a pair of vertices (vi,vj) is the edge weight if vi and vj are linked by an edge. If no edge is observed between vi and vj, their first-order proximity is 0.

The neighborhood relationship in [7] stems from spatial and temporal continuities. Different from that, in this paper, we define the neighborhood relationship as a second-order proximity, which is widely used in network analysis [24], [40]. In another word, for any two vertices in our activity graph, the more neighbors they have in common, the more related they are.

Definition 4 (Second-order Proximity).
Given a graph G=(V,E), V={v1,…,vn}, the second-order proximity between a pair of vertices (vi,vj) is the similarity between their adjacency distribution, i≠j, i,j∈{1,…,n}. Mathematically, let pvi=(ai1,…,ain) denote the first-order proximity of vi, then the second-order proximity between vi and vj is determined by the similarity between pvi and pvj.

In the activity graph, given a pair of vertices, the first-order proximity is defined to be the edge weight and the second-order proximity is the similarity between their adjacency distribution. High-order proximity is defined to be the connection with more than two hops in the graph. Taking Fig. 3a as an example, the temporal unit T1 has high-order proximity with the textual unit W2 via the connections in user interaction graph. We aim to design a hierarchical embedding framework with proximities of different orders preserved simultaneously.

4.3 Hotspot Detector
Due to the accuracy of the GPS-enabled devices and people's different customs and schedules, the raw mobile data displays obvious spatio-temporal variations and data sparsity. As addressed in [7], the spatial and temporal units in the activity graph of this paper comes from hotspot detection, since people's activities in urban areas often burst in geographical regions and time periods. Kernel density estimation is used to define the spatial and temporal hotspots since it has no assumption about the underlying data distribution. Suppose {x1,…,xn} are n data points in the d-dimensional space Rd, the kernel density at any point x is given by
f(x)=1nhd∑i=1nK(x−xih),
View SourceRight-click on figure for MathML and additional features.where K(⋅) is the Epanechnikov [41] kernel function and h is the kernel bandwidth.

Definition 5 (Spatial and Temporal Hotspots).
R is a mobile data corpus, L and T are the collections of locations and timestamps in R, respectively. A spatial hotspot is defined as a local maximum of the kernel function estimated from L. Similarly, a temporal hotspot is defined to be a local maximum of the kernel function estimated from T.

The mean shift [41] algorithm is employed to detect the spatial and temporal hotspots. For a given data point x, which can be either location or timestamp, let y(k) be the center of current window in iteration k, and {x1,…,xm} be the m data points inside the window. The mean shift vector for y(k) is m(y(k))=∑mi=1(xi−y(k))m, then y(k) is shifted by m(y(k)) as shown in Equation (1). The sequence {y(k)} will converge to the hotspot that x belongs to. All the hotspots can be detected after performing this algorithm for every data point.
y(k+1)=y(k)+m(y(k))=1m∑i=1mxi.(1)
View SourceRight-click on figure for MathML and additional features.

After hotspot detection, for a new data point, we can find the hotspot that it belongs to by calculating the distances with all the detected hotspots and choosing the closest one.

SECTION 5The ACTOR Approach
In this section, we detail the proposed ACTOR approach. First, we introduce the definitions of the meta-graphs encoding inter-record and intra-record relationships of mobile data. Then we propose the hierarchical embedding framework based on the constructed graphs and proposed meta-graphs. Finally, we give the complete algorithm of ACTOR and some discussions about it.

5.1 Meta-Graph
Definition 6 (Meta-Graph).
A meta-graph S=(X,A) is a sub-graphical scheme of graph G=(V,E), where X⊆V is a set of vertices along with its vertex type, and A is the adjacent relationship defined on X.

The intra-record meta-graph encodes the co-occurrence relationship inside the records shown as M0 in Fig. 3b. The inter-record meta-graph aims to reflect the relationships among different records. According to different node types that it connects, it can be further categorized into M1 – M6 in Fig. 3b. It can be noticed that the inter-record meta-graphs depict high-order relationships between units in the activity graph since they contain more than two hops in the graph. For example, we can find an instance of M4 in Fig. 3a.

5.2 Hierarchical Embedding Framework
Overall, as demonstrated in Fig. 3a, the framework contains three layers, the record layer, the activity graph layer and the user interaction graph layer. Correspondingly, the embedding framework can be decomposed into two steps. First, the user interaction graph is embedded to get the user embedding vectors from their interactive behaviors. Second, we devise a novel approach using meta-graph to model the high-order relationships between the user interaction graph and activity graph. The inter-record meta-graph connects two layers and guides the initialization of units in the activity graph from the embedding of user interaction graph. The intra-record meta-graph is employed to model the cross-modal co-occurrence relationship within the same record. The embedding objective is built based on both inter-record and intra-record meta-graphs.

5.2.1 Initialization
To begin with, the user interaction graph is embedded using LINE [24] and it is desired that those users who interact with each other frequently are close in the vector space. For those users who have never interacted with others, we use a random vector to represent them. The user embeddings are used to initialize the nodes in the activity graph. For a node in the activity graph, it may have connections with different users and we choose the user with the highest weight to get the initial embedding vector.

5.2.2 Embedding
Similar with the skip-gram [42] model, for each center vertex vi and its known embedding vector xi, we want to predict the context embedding x′j of its context vertex vj. The context of vi could be defined as all the vj that fe(vi,vj) belongs to the same edge type, thus the context of a vertex may differ with different edge types. Given an edge type e and the center vertex vi, the probability of context vj generated by vertex vi could be defined as Eq. (2).
pe(vj|vi)=exp(x′jTxi)∑fe(vi,vk)=eexp(x′kTxi),(2)
View SourceRight-click on figure for MathML and additional features.pe(⋅|vi) defines a model distribution over the context of vertex vi and the empirical distribution p^e(⋅|vi) could be defined by Eq. (3), where aij is the weight of the edge (vi,vj) and dei is the degree of vertex vi in the edge type e.
p^e(vj|vi)=aijdei,wheredei=∑fe(vi,vk)=eaik.(3)
View SourceRight-click on figure for MathML and additional features.

To fully reconstruct the co-occurrence relationship, the conditional distribution of the contexts pe(⋅|vi) specified by the low-dimensional representation should be close to the empirical distribution p^e(⋅|vi). Therefore, we minimize the following objective function:
Je=∑vi∈VeλiD(p^e(⋅|vi),pe(⋅|vi)),(4)
View SourceRight-click on figure for MathML and additional features.where Ve={v∈V|∃v′∈V,s.t. fe(v,v′)=e}, λi is the importance weight of vertex vi and D(⋅,⋅) is the distance between two distributions. In this paper, we choose the KL-divergence as the measure between two distributions and evaluate the importance of vertex vi by its degree dei. In such settings, the objective function could be rewritten as
Je=−∑fe(vi,vj)=eaijlogpe(vj|vi).(5)
View SourceRight-click on figure for MathML and additional features.

Since we have defined edge types and meta-graphs to preserve different orders of proximity, the overall objective function is
J=∑e∈MintraJe+∑e∈MinterJe,(6)
View SourceRight-click on figure for MathML and additional features.where Mintra={TL,LW,WT,WW} is the set of edge types in the intra-record meta-graph4 and Minter={UT,UW,UL} is part of the edge types in the inter-record meta-graph.

5.2.3 Optimization
When optimizing Eq. (5), the denominator in Eq. (2) requires the summation over all the edges of type e with center vertex vi, which is highly computationally expensive. We adopt the approach of negative sampling proposed in [43]. Specifically, it specifies the following objective function for each edge (vi,vj):
JNEG=−logσ(x′jTxi)−∑k=1KEvk∼P(v)logσ(−x′kTxi),(7)
View SourceRight-click on figure for MathML and additional features.where σ is the sigmoid function. The first term models the observed edge (vi,vj) and the second term models the negative edges drawn from the noise distribution P(v)∝d34v, where dv is the out-degree of vertex v and K is the number of negative edges.

The updating rules for different variables can be derived by taking the derivatives of the above objective function and we list them as follows.
∂JNEG∂xi=−[1−σ(x′jTxi)]x′j+σ(x′kTxi)x′k(8)
View SourceRight-click on figure for MathML and additional features.
∂JNEG∂x′j=−[1−σ(x′jTxi)]xi(9)
View SourceRight-click on figure for MathML and additional features.
∂JNEG∂x′k=σ(x′kTxi)xi.(10)
View SourceThe updating rule for edge type e can be written as Eq. (11).
∂Je∂xi=∑fe(vi,vj)=eaij∂JNEG∂xi.(11)
View SourceRight-click on figure for MathML and additional features.

Following [24], we sample from the original edges with sampling probabilities proportional to the original edge weights. Thus we could treat the weights of sampled edges as equal and choose a suitable learning rate η for the algorithm. The alias sampling [44] method is used for edge sampling, which takes O(1) time when repeatedly drawing samples from the same distribution. We adopt the asynchronous stochastic gradient algorithm [45] for optimizing Equation (5). In each step, a mini-batch of edges from a certain kind of meta-graph are sampled, suppose the size of mini-batch is m, and the embedding vectors are updated by Equations (12), (13), and (14).
xi←xi−η∑m∂JNEG∂xi(12)
View SourceRight-click on figure for MathML and additional features.
x′j←x′j−η∑m∂JNEG∂x′j(13)
View Source
x′k←x′k−η∑m∂JNEG∂x′k.(14)
View SourceRight-click on figure for MathML and additional features.

5.3 ACTOR Algorithm
ACTOR is a hierarchical activity modeling framework based on mobile data generated in urban areas and the learning scheme of ACTOR is summarized in Algorithm 1.

Algorithm 1. ACTOR
Input: R: A corpus of mobile data, Minter: inter-record meta-graphs, Mintra: intra-record meta-graphs, d: The embedding dimension, K: Number of negative samples, MaxEpoch: Maximum iteration epochs, m: Number of sampling edges.

Output: The embedding vectors.

Apply the mean-shift algorithm to the timestamps and locations to detect spatial and temporal hotspots;

Construct an activity graph G=(V,E), V={v1,…,vn} and a user interaction graph G′=(V′,E′);

Train the user interaction graph with LINE and get the user embeddings;

Initialize the center vectors {xi}ni=1 and context vectors {x′i}ni=1 of units in the activity graph with the corresponding pretrained user embedding vectors;

for k = 0 to MaxEpoch−1 do

for e ∈ Minter do

Sample m edges from E of type e;

Updating {xi} and {x′i} with Equations (12), (13), and (14)

for e ∈ Mintra do

Sample m edges from E of type e;

Updating {xi} and {x′i} with Equations (12), (13), and (14)

return {xi}ni=1 and {x′i}ni=1.

Given a corpus of mobile data R, spatial and temporal hotspots are first detected (Line 1). After that, these hotspots, together with the textual units are constructed into an activity graph and a user interaction graph is built based on the mentioned records (Line 2). Then the user interaction graph is trained to get the user embedding vector (Line 3). For each vertex in the graph, we initialize its center vector and context vector with its pre-trained user embedding vector (Line 4). Then, we alternate the graph embedding method to the instances of inter-record and intra-record meta-graphs and update the center and context vectors in the iteration (Line 5-11). Finally, the output is the center vectors and context vectors of all the vertices (line 12).

5.4 Discussions
We argue that ACTOR is a high-order proximity preserved cross-modal embedding algorithm. The inter-record meta-graph encodes the high-order proximity from activity graph to the user interaction graph since each instance of them contains more than two hops in the graph. The hierarchical embedding framework tends to preserve high-order proximity in the embedded space as encoded by the meta-graphs.

Besides, ACTOR is a general hierarchical cross-modal embedding framework, where meta-graphs can be flexibly assigned to probe connections between different graphs. Thus previous methods could be considered as special cases of ACTOR. For instance, CrossMap [7] could be obtained by embedding only the activity graph without hierarchical embeddding strategy.

Next we analyze the time complexity of the proposed ACTOR. Suppose d is the dimension of embedding vector and K is the number of negative samples, each step of optimization takes O(d(K+1)), under the condition that sampling an edge from the alias table takes constant time. And the iteration step is usually proportional to the number of edges O(|E|). Therefore, the overall time complexity of our proposed ACTOR is O(dK|E|).

SECTION 6Experiment
In this section, we report our experimental results on qualitative and quantitative evaluations of ACTOR on three real-world datasets.

6.1 Experimental Setup
6.1.1 Datasets
We conducted the experiments on three public benchmark datasets.

UTGEO2011 [46] contains 38 million tweets collected across the entire globe between September 4th and November 29th, 2011. A subset is provided in [46] with around 10,000 users and we adopt it as benchmark dataset in our paper.

TWEET [7] consists of 1.1 million geo-tagged tweets published in Los Angeles during August 1st to November 30th, 2014.

4SQ [7] includes around 0.6 million Foursquare checkins posted in New York from August 2010 to October 2011.

The train/valid/test split is done randomly from all the records and the detailed statistics of the datasets can be summarized in Table 1, including the scale of the corresponding constructed activity graphs.

TABLE 1 Statistics of Datasets
Table 1- 
Statistics of Datasets
6.1.2 Compared Methods
LGTA [17] can discover and compare geographical topics from GPS-associated documents, combining both location and text information.

MGTM [16] is a state-of-the-art geographical topic model which captures dependencies between geographical regions based on a multi-Dirichlet process.

Metapath2vec [25] is a state-of-the-art heterogeneous embedding algorithm. It performs heterogeneous random walks on the graph according to the pre-defined meta-paths and then encodes each vertex into vector space.

LINE [24] defines loss function to preserve the first-order or second-order proximity separately for graph embedding. We also adapt LINE to the activity graph with the auxiliary vertex type of U and derive LINE(U) as another baseline.

CrossMap [7] is a state-of-the-art method for spatiotemporal activity modeling. It jointly maps different units into the latent space but only models the co-occurrence and neighborhood relationships. Similar as LINE(U), we also extend CrossMap on the activity graph with the auxiliary vertex type of U and derive CrossMap(U) for a comprehensive comparison.

ACTOR: the model proposed in this paper.

6.1.3 Parameter Settings
The major parameters of ACTOR include the latent embedding dimension d, learning rate η, number of negative samples K, the batch size m, the maximum epoch MaxEpoch. For the three datasets above, we set d=300, η=0.02, K=1, m=256, MaxEpoch=100. For the baselines, we finely tuned the corresponding parameters in order to perform a fair comparison. In our experiments the reported results are the average of five runs.

The ACTOR algorithm is implemented in C++ and experiments are conducted on a CentOS 6.9 server, with 32 cores Intel(R) Xeon(R) 2.10 GHz CPU and 64 GB memory.

6.2 Cross-Modal Prediction
6.2.1 Prediction Method
We quantitatively evaluate the performance of ACTOR by cross-modal prediction. It can be decomposed into three sub-tasks: activity prediction, location prediction and time prediction.

Take the location prediction as an example. Suppose we have obtained vector representations for all the units in the training corpus. For each query in the test set, with the time and text modalities known, the location candidate set is composed of the ground truth location and noisy locations that are randomly chosen from the spatial hotspots of the test set. Then we could compute the cosine similarity of each candidate location to the observed timestamp and keywords and rank them in the descending order in terms of similarity. The ranked list is regarded as the predicted result. In our experiments, besides the ground truth, 10 noisy candidates are randomly chosen from the test corpus and hence the size of candidate set is 11.

6.2.2 Evaluation Metric
The Mean Reciprocal Rank (MRR) is adopted to quantify the performance of this model. Formally, given a set Q of queries, the MRR is the average of the reciprocal ranks of each query in Q, as Eq. (15) shows.
MRR=1|Q|∑i=1|Q|1ranki,(15)
View SourceRight-click on figure for MathML and additional features.where ranki refers to the rank position of the ground truth for the ith query. Specifically, in this paper, each record in the test corpus is a query and ranki refers to the rank position of the ith record.

6.2.3 Experimental Results and Discussions
The experimental results of various methods on the three datasets are presented in Table 2. For each dataset, we demonstrate the MRR metrics on three prediction tasks. From the table, we observe that ACTOR consistently outperform all the other methods on the two datasets, with at most 85.9 percent improvements compared with LGTA and 16.0 percent improvements with CrossMap.

TABLE 2 Mean Reciprocal Rank for Cross-Modal Retrieval

LINE and metapath2vec are two representative graph embedding algorithms. LINE is designed mainly for homogeneous graph thus it performs much more poorly than ACTOR in embedding activity graph which contains vertices of different types. Metapath2vec is developed for heterogeneous graph but the embeddings rely on the generated random walks. We have tried to use the proposed meta-graphs M1 – M6 as meta-paths to generate random walks but the predict results are far from satisfactory. It is difficult to perform random walk on the user interaction graph since it is rarely sparse. Therefore, we explore other meta-paths and report the best scores on these three datasets in Table 2. The meta-path for UTGEO2011 and TWEET is L−W−T−W but for 4SQ, both L−W−T−W and T−L−W−W are adopted. The window size and number of negative samples are set to be 3 and 5 respectively.

LINE and CrossMap are not originally designed for high-order embedding but they could be simply modified and applied on the activity graph with auxiliary vertex type U, which are the results of LINE(U) and CrossMap(U). Compared with LINE and CrossMap, the user vertices bring extra information and obtain performance improvements to some extent. However, through hierarchical cross-modal embedding, ACTOR could encode high-order proximities into the embedding procedures and consequently ACTOR performs better than LINE(U) and CrossMap(U).

6.2.4 Case Study
To figure out the reason why ACTOR outperforms other baselines, especially CrossMap, we perform cross-modal prediction on the same record and noise candidates using these two methods, then observe their ranking results.

For activity prediction task, the original tweet is shown as Fig. 4. The tweet was posted at a prop room while the attached text directly mentioned it. The aim is to tell the most possible text from the mix of 1 groundtruth and 10 randomly chosen noise text. The ranking results of ACTOR and CrossMap are presented in Fig. 5. As we can see, the groundtruth text ranked 1st in ACTOR but 7th in CrossMap. The hierarchical embeddings adopted by ACTOR could capture the cross-modal correlation precisely thus it can match the text with the location closely.


Fig. 4.
The ground truth tweet for activity prediction.

Show All

Fig. 5. - 
Ranking results of both methods for activity prediction. ACT is short for ACTOR and CM is short for CrossMap.
Fig. 5.
Ranking results of both methods for activity prediction. ACT is short for ACTOR and CM is short for CrossMap.

Show All

For time prediction task, the original tweet is shown as Fig. 6. The task is to predict the most possible time when the performance took place at this music bar. As Table 3 shows, the top 3 timestamps both methods returned are acceptable since most bars will arrange their performance at night, when the number of customers reaches the peak of a day.


Fig. 6.
The ground truth tweet for time prediction.

Show All

For location prediction task, the original tweet was posted at a pavilion as Fig. 7 shows, which can be inferred from the text as well. ACTOR ranked the groundtruth in the 1st place. The top 4 places that CrossMap returned are listed in Fig. 8, where the groundtruth was in the 3rd place. Although we can find another pavilion near the 1st place, there is no obvious connection between grocery store and the 2nd place, neither the 4th place. We infer that ACTOR could capture the function of the place due to multiple orders of proximities preserved in the activity graph while CrossMap may have some inaccurate correlations.

Fig. 7. - 
The ground truth tweet for location prediction.
Fig. 7.
The ground truth tweet for location prediction.

Show All

Fig. 8. - 
Ranking results of CrossMap for location prediction.
Fig. 8.
Ranking results of CrossMap for location prediction.

Show All

6.3 Ablation Test
We identify two key structures in our proposed ACTOR framework: inter-record structure and intra-record structure. Inter-record structure refers to the hierarchical embedding framework induced by the inter-record meta-graph, say the pre-training of user interaction graph and embedding with Minter={UT,UW,UL} in the activity graph. Intra-record structure refers to the bag of words model in the intra-record meta-graph, that we consider words together rather than treat them as individual textual unit. We address the model without inter-record structure as ACTOR w/o inter, the model without intra-record structure as ACTOR w/o intra, and the complete model proposed in this paper as ACTOR-complete. The ablation test results can be found in Table 4.

TABLE 3 Ranking Results of Both Methods for Time Prediction
Table 3- 
Ranking Results of Both Methods for Time Prediction
TABLE 4 Mean Reciprocal Rank for Ablation Test
Table 4- 
Mean Reciprocal Rank for Ablation Test
As demonstrated in the table, both inter and intra structures of ACTOR contribute to the final performance. No matter which part of the model is removed, the MRR metric would decline a little. For UTGEO2011, hierarchical embedding strategy and inter-record meta-graph contribute more than intra-record meta-graph since the performance of ACTOR w/o inter is worse than ACTOR w/o intra. For TWEET and 4SQ dataset, we have no information about the user interactions but we can still link the units in the activity graph to the user and part of the inter-record meta-graph could also help with the cross-modal correlation as we can conclude from the results of ACTOR w/o inter for TWEET and 4SQ.

6.4 Neighbor Search
Next, we investigate the effectiveness of the obtained embeddings by qualitative comparisons. In particular, we evaluate the resultant cross-modal correlations through the results under different kinds of queries, namely spatial query, temporal query and textual query, on the TWEET dataset. From the previous comparison, CrossMap is shown as the strongest competitor, hence we focus on comparing our ACTOR and CrossMap in such evaluation.

6.4.1 Spatial Query
Fig. 9 shows the results when we query the location of the port of Los Angeles, whose latitude and longitude is (33.7395, -118.2599). The results of ACTOR are closely related to the port, like “dock”, “departure” or the place “port of LA”. However, CrossMap prefers some general words like “today”, “time”, etc. Clearly, ACTOR performs better in capturing the characteristic of the place than CrossMap.

Fig. 9. - 
Spatial query of port of Los Angeles.
Fig. 9.
Spatial query of port of Los Angeles.

Show All

6.4.2 Temporal Query
Fig. 10 shows the results of the temporal query of “10:00pm”. From the figure, we observe both methods return temporal hotspots close to 10:00pm but the textual results differ a lot. Unlike CrossMap returns some general words like “tonight” or “like”, ACTOR finds some specific activities in the evening, like listening to music,5 watching TV series,6 sports programs,7 and some information about the occurring places, e.g., “dance hall” or “box seat”. The results also demonstrate that ACTOR might correlate more specific activities.


Fig. 10.
Temporal query of 10:00pm.

Show All

6.4.3 Textual Query
For the textual query, we search the popular sports bar “Patrick Molloy's Sports Pub” at Hermosa Beach, LA. The keyword for this bar is “patrick_molloy_sport_pub” in our vocabulary and the search results are shown in Fig. 11. Both methods return temporal hotspots around free time and spatial hotspots near the pub except one outlier in the result of CrossMap, but the textual results8 differ. It is worth mentioning that ACTOR returns several specific words containing hermosa beach in which the pub is located at while CrossMap just returns similar pubs. Clearly, ACTOR embeds more information from the whole text than CrossMap.

Fig. 11. - 
Textual query of “patrick_molloy_sport_pub”.
Fig. 11.
Textual query of “patrick_molloy_sport_pub”.

Show All

6.5 Scalability
We finally evaluate the scalability of ACTOR on the TWEET dataset as we expand the sampling edges or increase the computing threads. The basic number of sampling edges is 4 million. First, we investigate the performance of ACTOR by multipling the sampling edges 1, 2, 3, 4 times and the total running time is shown in Fig. 12a, from which we argue that ACTOR is robust in dealing with increasing sampling edges as the running time scales linearly with the number of sampling edges. To study the strong scalability of ACTOR, we keep the basic number of sampling edges and vary the computing thread from 1 to 4. Fig. 12b exhibits the corresponding results. From the figure we argue that ACTOR is highly parallelizable using multi-thread stochastic gradient algorithm. To test the weak scalability, we keep the threads and edges growing in pace with each other and the performance is shown as Fig. 12c, the running time remains nearly constant as the simultaneous increase of both threads and edges. From the results we can conclude that ACTOR achieves a good scaleup. To sum up, the proposed ACTOR demonstrates a good scalability and is practical for large-scale datasets.

Fig. 12. - 
Scalability of ACTOR.
Fig. 12.
Scalability of ACTOR.

Show All

SECTION 7Conclusion
In this paper, we study the problem of spatiotemporal activity modeling and propose ACTOR, a hierarchical cross-modal embedding framework. The key technical contribution lies in the design of meta-graphs for hierarchical embedding to capture high-order relationship of spatiotemporal activities. Combined with these meta-graphs, ACTOR jointly embeds all spatial, temporal and textual units into the same space where proximities of different orders are simultaneously probed. We conduct extensive experiments on three real-world datasets. The empirical results demonstrate that ACTOR significantly outperforms other baselines due to the preserved high-order proximities.

