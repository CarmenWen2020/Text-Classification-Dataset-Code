Huge amounts of spatio-textual objects, such as geo-tagged tweets, are being generated at an unprecedented scale, leading to a variety of applications such as location-based recommendation and sponsored search. Many of these applications need to support moving top-k spatio-textual subscriptions. For example, while walking, a tourist issues a moving subscription and looks for top-k advertisements published by nearby shops. Unfortunately, existing methods that monitor the results of spatio-textual subscriptions support only static top-k subscriptions or moving boolean subscriptions. In this article, we propose a novel system, called Lamps (Location-Aware Moving Top-k Pub/Sub), which continuously monitors the top-k most relevant spatio-textual objects for a large number of moving top-k spatio-textual subscriptions simultaneously. To the best of our knowledge, this is the first study of a location-aware moving top-k pub/sub system. As with existing works on continuous moving top-k subscription processing, Lamps employs the concept of a safe region to monitor top-k results. However, unlike with existing works that assume static objects, top-k result updates may be triggered by newly generated objects. To continuously monitor the top-k results for massive moving subscriptions efficiently, we propose SQ-tree, a novel index based on safe regions, to filter subscriptions whose top-k results do not change. Moreover, to reduce the expensive cost of safe region re-evaluation, we develop a novel approximation technique for safe region construction. Our experimental results on real datasets show that Lamps achieves higher performance than baseline approaches.
SECTION 1Introduction
Because of the prevalence of social networks and GPS-enabled mobile devices, huge amounts of objects with both spatial and textual information, referred to as spatio-textual objects, have been generated in a streaming fashion. This has led to the popularity of location-aware pub/sub systems in many applications, such as location-based recommendation [1] and sponsored search [2]. In such a system, a large number of users register their interests (e.g., keywords and locations) as spatio-textual subscriptions. Then, the system delivers a stream of spatio-textual objects (e.g., geo-tagged tweets, e-coupons, and advertisements) generated by publishers (e.g., restaurants) to the relevant subscriptions. Various location-aware pub/sub systems have been proposed [3], [4], [5], [6], [7]. Most of them focus on boolean matching, thereby users may receive few matching objects or may be overwhelmed by a huge volume of matching objects. In such a situation, a top-k subscription, which can control the size of the objects to be received, is useful. Unfortunately, existing works focus on static subscriptions and cannot support moving subscriptions efficiently. Note that many real-world applications need to support moving subscriptions [5], [8], [9], [10], [11]. For example, while walking, a tourist looks for top-k advertisements published by nearby shops. Because he/she is walking, his/her location (subscription location) changes continuously.

Motivated by the fact that none of the current systems can support moving top-k subscriptions against streaming objects, in this paper, we propose a novel system, called Location-Aware Moving Top-k Pub/Sub (Lamps), which continuously monitors the top-k most relevant spatio-textual objects for a large number of moving top-k spatio-textual subscriptions simultaneously. Specifically, for each subscription, we score objects based on their spatial and textual similarities, and the top-k results are continuously maintained against streaming objects (i.e., object generations and expirations) and the movements of users.

1Example 1.
Fig. 1 shows an example of a location-aware moving top-k pub/sub system that delivers e-coupons to potential consumers. In this example, there are four users (subscriptions) and four restaurants (publishers) that continuously generate e-coupons. Each restaurant can generate multiple e-coupons and delete its generated e-coupons. Each user registers his/her interest as a subscription and monitors the top-1 most relevant e-coupon. At timestamp ts=2, we assume that five e-coupons (o1 - o5) have been published and the top-1 result for user u3 is e-coupon o1, because o1 has the highest spatial and textual similarities to the subscription of u3. In other words, o1 is the closest to the location of u3 and has the common keyword “sushi” as u3. Also, the top-1 result for u2 is o4. At ts=3, new e-coupons o6 and o7 are published and each user moves, and then the result for each user is updated. The top-1 result for u3 becomes o7, because o7 is closer to the current location of u3 and its keywords are more similar to the keywords of u3. Furthermore, u2 moves west, thereby the top-1 result for u2 becomes o1 because o1 is closer to u2 than o4.


Fig. 1.
A location-aware moving top-k pub/sub system. At ts=3, o6 and o7 are newly published and each user moves to the tip of the arrow.

Show All

Challenges. There are two key challenges for efficiently monitoring the top-k result of each moving subscription. When a spatio-textual object is generated or expires, the top-k result of each subscription may change. We need to monitor the up-to-date top-k results for a massive number of subscriptions over a stream of spatio-textual objects. When a user u moves, the score of each object for u varies, so the top-k result of u may change. We need to monitor the up-to-date top-k result for each subscription against the movements of users.

To monitor the top-k results for all subscriptions over a stream of objects, a straightforward approach works as follows: When a new spatio-textual object o is generated, for each subscription s, we calculate the score of o. If the score of o is better than the score of the current kth result, o becomes the result of s. Moreover, when an object o′ expires, for each subscription whose top-k result contains o′, we need to re-evaluate its result. For example, in Fig. 1, the expiration of o1 invalidates the current top-1 result of u2, thereby we have to re-evaluate the result for u2. The straightforward approach accesses all objects and calculates the scores, but this approach is computationally expensive if the number of subscriptions is large and the spatio-textual objects are frequently generated and frequently expire.

To monitor the top-k result for each subscription against the movements of users, a straightforward approach re-calculates the scores of all objects and updates the top-k result of u whenever u moves. However, this approach incurs an expensive computational cost. To avoid unnecessary computation, several works have proposed safe region techniques for a moving top-k subscription [8], [10], [12]. A safe region is a region where the top-k result does not change. In other words, the top-k result needs to be re-evaluated only when the user exits the safe region. These safe regions however fail to function when streaming objects are considered. This is because safe regions may change when objects are newly generated. When users exit their safe regions or their top-k results change, moreover, we need to re-evaluate their safe regions. Even a state-of-the-art safe region construction algorithm [10] incurs a large evaluation cost if the system stores a lot of objects.

The works in [4], [5] have proposed location-aware moving pub/sub systems. The underlying idea of them is to group similar subscriptions and filter simultaneously a set of subscripitions for a newly generated object. It is challenging to achieve a similar optimization for moving top-k pub/sub. These works focus on range-based moving boolean subscriptions. Boolean subscriptions do not have the concept of score, so thresholds for filtering them never change. Moreover, their results are not affected by expired objects. Top-k results, on the other hand, are affected by object generation, expiration, and user movements. This means that the threshold for each subscription always changes. Therefore, it is more challenging to monitor the exact top-k result for each subscription efficiently.

Overview of Our Proposed System. Lamps employs a novel index, namely SQ-tree, which integrates a Quad-tree with safe regions to effectively maintain moving top-k spatio-textual subscriptions. SQ-tree can filter subscriptions whose top-k results and safe regions do not change when a new object is generated. Besides, we propose an efficient algorithm to retrieve objects that become top-k objects when an object expires or users exit their safe regions. To reduce the expensive safe region evaluation cost, furthermore, we develop a novel approximation technique for safe region construction.

Contributions. We summarize our contributions below.

We address, for the first time, the problem of monitoring top-k spatio-textual objects for a large number of moving top-k spatio-textual subscriptions. To tackle this problem, we propose a novel system, called Lamps.

We develop a novel approximation technique for safe region construction to reduce the safe region evaluation cost.

We propose a novel index based on a Quad-tree and safe regions, SQ-tree, to efficiently filter moving subscriptions whose top-k results and safe regions do not change when a new object is generated.

We conduct experiments using real datasets, and the results show that Lamps achieves higher performance than baseline approaches.

Organization. We provide preliminary information in Section 2. We present Lamps from Sections 3, 4, 5, and 6 and introduce our experimental results in Section 7. We review some related works in Section 8 and conclude this paper in Section 9.

SECTION 2Preliminary
First, in Section 2.1 we formally present some concepts that are used throughout this paper. Section 2.2 introduces the safe region technique for a moving top-k subscription.

2.1 Definition
We define spatio-textual object and Moving top-k Spatio-Textual (MkST) subscription issued by a user.

Definition 1 (Spatio-textual object).
A spatio-textual object, which is generated by a publisher, is defined as o=(p,t,ts), where o.p is the location of o, o.t is a set of keywords of o, and ts is the timestamp when o is generated.

Definition 2 (MkST subscription).
A MkST subscription is defined as s=(p,t,k,α), where s.p is the current location of the user, s.t is a set of keywords such that 1≤|s.t|≤tmax, s.k is the number of objects requested, and s.α is the preference parameter (0<s.α<1) used in the scoring function to evaluate the relevance between s and an object. Given an object o and s, the score of o for s, score(s,o), is calculated as follows [10], [13]:
score(s,o)=s.α⋅dist(s.p,o.p)+(1−s.α)⋅text(s.t,o.t),(1)
View Sourcewhere dist(s.p,o.p) is the spatial proximity and text(s.t,o.t) is the textual similarity between s and o. Given an object set O, the answer of s is a subset of O, A, such that (1) |A|=k, and (2) ∀o∗∈A, ∀o′∈O∖A, score(s,o∗)≤score(s,o′).1

In the following of this paper, we abbreviate s.k and s.α as k and α, respectively, if there is no ambiguity.

To compute spatial proximity, we utilize the euclidean distance dist(s.p,o.p)=Edist(s.p,o.p)Maxdist as with [3], [4], [5], [10], [14], [15], [16].2 Edist(s.p,o.p) is the euclidean distance between s.p and o.p, and Maxdist is the maximum distance in the spatial area R2 where subscriptions and objects exist. We see that dist(⋅,⋅)∈[0,1]. For textual similarity, there are three widely used set-based similarity functions, namely Jaccard, Dice, and Cosine similarities [18]. Lamps can employ any similarity function that uniquely determines the textual similarity by a given subscription and an object. In this paper, we use Jaccard similarity as the default function, because it is usually used in set similarity search [19], i.e., text(s.t,o.t)=1−|s.t∩o.t||s.t∪o.t|. Note that in Section 7.3 we verify the performance of Lamps when Dice and Cosine similarities are employed. Then, score(s,o) is within [0,1].

Problem Statement. We consider a set of MkST subscriptions S and a dynamic set O of spatio-textual objects. Subscribers can move randomly at any time (i.e., movements of users) [4]. Publishers can insert their newly generated objects into O (i.e., object generation) and remove objects that they have generated from O (i.e., object expiration). We aim to continuously monitor the top-k results for all subscriptions against object generation, object expiration, and movements of users.

Example 2.
Fig. 2 shows a running example used throughout this paper. In this example, there are ten registered subscriptions {s1,…,s10} and eight objects have been generated {o1,…,o8}. Moreover, two objects o9 and o10 are newly generated, and we assume s1.k=2. Specifically, o2 and o5 have high spatial and textual similarities to s1. Thus, the top-k results of s1 are o2 and o5.


Fig. 2.
Running example. Eight objects {o1,…,o8} have been generated and two objects o9 and o10 are newly generated.

Show All

2.2 Safe Region Technique
Lamps employs the concept of the safe region [12] to monitor top-k results. Therefore, we first define the safe region and a relevant concept, the dominant region.

Definition 3 (Safe region).
Given O, s=(p,t,k,α), and A of s, the safe region of s, R, is
R={p′|∀o∗∈A,∀o′∈O∖A,score(s′,o∗)≤score(s′,o′)},
View SourceRight-click on figure for MathML and additional features.where s′ is s after moving to a new location p′, i.e., s′=(p′,t,k,α).

Note that the safe region of s is a region where the top-k result of s does not change.

Definition 4 (Dominant region).
Given s=(p,t,k,α) and two objects o∗ and o′, the dominant region of o∗ to o′, Do∗,o′, is
Do∗,o′={p′|score(s′,o∗)≤score(s′,o′)},
View Sourcewhere s′ is s after moving to a new location p′, i.e., s′=(p′,t,k,α).

We see that the dominant region of o∗ to o′ is a region where score(s,o∗)≤score(s,o′). The following lemma is showed and proved in literature [10].

Lemma 1.
Given O, s, and A, the safe region of s, R, is R=∩o∗∈A(∩o′∈O∖ADo∗,o′).

Local Safe Region. To efficiently compute a safe region, literature [10] proposed a local safe region (LSR), which is a subset of the safe region. Notice that we can monitor the exact top-k results by re-evaluating them only when users exit their LSR. [10] models each object o as a circle Co with a center o.p and radius of ro=1−αα⋅text(s.t,o.t). Then, score(s,o)=α(dist(s.p,o.p)+ro). The LSR is computed in the following three steps.

Step 1. For each object o∗∈A, we compute an ellipse Eo∗ and the intersection of these ellipses E=∩o∗∈AEo∗. Note that
Eo∗={p′|dist(s′.p′,o∗.p)+dist(s.p,s′.p′)≤γ−ro∗},(2)
View Sourcewhere γ=max{dist(s.p,o∗.p)+ro∗|o∗∈A}+Δ and Δ is a parameter of an approximate ratio. Obviously Eo∗ is an ellipse with s.p and o∗.p as two foci.

Example 3.
In Fig. 3, because s1.k=2 and the top-k results of s1 are o2 and o5, E is the intersection of Eo2 and Eo5.

Fig. 3. - 
Example of LSR. Because $s_1.k = 2$s1.k=2 and the top-k results of $s_1$s1 are $o_2$o2 and $o_5$o5, the LSR of $s_1$s1 is the shaded region $\mathcal {E}_{o_{2}} \cap \mathcal {E}_{o_{5}} \cap D$Eo2∩Eo5∩D.
Fig. 3.
Example of LSR. Because s1.k=2 and the top-k results of s1 are o2 and o5, the LSR of s1 is the shaded region Eo2∩Eo5∩D.

Show All

Step 2. Let Cs be a circle centered at s.p with radius γ. When s′.p′∈E, each object o does not become the top-k result of s′ if Co is not inside Cs. If Co is not inside Cs, γ≤dist(s.p,o.p)+ro. Then, score(s′,o∗)<score(s′,o) for each object o∗∈A. Let Os be the set of objects whose circles are inside Cs and that are not the top-k result of s. Because each object o′∈Os may become the top-k result of s′, we need to compute the region where the top-k result does not change by o′. We compute the dominant region Do∗,o′ for each object o′∈Os, and the intersection of these dominant regions D=∩o∗∈A(∩o′∈OsDo∗,o′).

Example 4.
In Fig. 3, because Co1 and Co3 are not inside Cs1, o1 and o3 never become the top-k result of s′1. Os1 contains only o4 and o6, therefore, we compute the dominant regions for o4 and o6, and the intersection of these regions.

Step 3. We compute the LSR E∩D.

Theorem 1.
The total time complexity of the LSR construction algorithm is O(μk|Os|), where μ is the cost of calculating the intersection of two polygons (dominant regions).

Proof
All proofs can be found in Appendix A, which can be found on the Computer Society Digital Library at http://doi.ieeecomputersociety.org.ezproxy.auckland.ac.nz/10.1109/TKDE.2020.2979176.

Approximate Safe Region. The local safe region construction needs to compute the dominant region Do∗,o′ for each object o′∈Os. Many objects exist in Os if the system stores a lot of objects, thereby it incurs a large evaluation cost. To avoid this cost, We propose a novel technique that can compute an approximate safe region (ASR), regardless of the distribution of objects. As with LSR, ASR is a subset (partial area) of the exact safe region. Therefore, we can monitor the exact top-k results by re-evaluating them only when users exit their ASR. Let ok+1 be the object whose score for s is the (k+1)th smallest when the safe region of s is computed. In this technique, we set γ=dist(s.p,ok+1.p)+rok+1. Then we have the following lemma:

Lemma 2.
If γ=dist(s.p,ok+1.p)+rok+1, Os=∅

From Lemma 2, we do not need to compute the dominant regions. Therefore, we can compute the safe region only by computing the ellipses and their intersection. That is, our proposed technique can compute an ASR while reducing the evaluation cost. Moreover, ASR is not necessarily a subset of the LSR. For example, if max{dist(s.p,o∗.p)+ro∗|o∗∈A}+Δ<dist(s.p,ok+1.p)+rok+1, the ASR is a superset of LSR. To compute the ASR quickly, we find ok+1 at the same time as we update the top-k result, which is shown later. In the following part of this paper, when we refer to a safe region, it means its ASR if there is no ambiguity. That is, R=E.

Example 5.
Fig. 4 shows an example of an ASR of s1. At timestamp ts, the top-k results of s1 are o2 and o5, and ok+1 is o4. Therefore, we compute s1.R with γ=dist(s1.p,o4.p)+ro4. At ts+1, we need to re-compute s1.R because s1 exits s1.R. Because the score of each object changes, the top-k results become o2 and o4, and ok+1 is o3. Therefore, we re-compute s1.R based on o2, o4, and o3.


Fig. 4.
Example of an ASR. At ts, the ASR of s1 is the shaded region Eo2∩Eo5. At ts+1, because the top-k result becomes o2 and o4, the ASR of s1 becomes the shaded region Eo2∩Eo4.

Show All

Theorem 2.
The worst time complexity of the ASR construction algorithm is O(k2).

Because O(k2)≪O(μk|Os|), our approach can obtain a subset of SR much faster than [10].

SECTION 3Framework
Fig. 5 shows the framework of Lamps. As with [13], [20], we assume that subscriptions are pre-registered in Lamps. Lamps can also support subscription update (issue and delete). In Section 6, we will discuss the procedure when a subscription is newly issued or deleted. The input of Lamps includes object generation/expiration and movements of users. Here, we introduce how to process them at a high level. To efficiently deal with them, Lamps employs subscription, result, and object indices.

Object Generation. When a new object o is generated, we need to identify the set of subscriptions whose top-k results change because of o. First, we find a candidate set of subscriptions from the subscription index and update the object index. For each subscription in the set, we update the top-k result and its safe region. If the top-k result and the safe region change, they are sent to the user, and the subscription and the result indices are also updated.

Object Expiration. When an object o′ expires, we need to re-evaluate the results of the subscriptions whose top-k results contain o′. First, we obtain a set of subscriptions whose top-k results contain o′ from the result index that maintains the top-k results of all the subscriptions, and we update the object index. For each subscription in the set, we evaluate the new top-k result and its safe region by using the object index. The new top-k result and the safe region are sent to the user, and the subscription and the result indices are also updated.

Movement of User. Recall that users receive and maintain their safe regions at the same time as their top-k results. Therefore, they can check whether they exit their safe regions or not by themselves. When a user u exits his/her safe region, u reports the current location to Lamps. Lamps deals with this case as with the case of object expiration.


Fig. 5.
Framework of lamps.

Show All

In the following section, we introduce the details of how to process object generation and expiration. (Recall that Lamps processes those cases in which users exit their safe regions in the same way as object expiration.) Table 1 summarizes the mathematical notations used throughout this paper.

TABLE 1 Summary of Notations
Table 1- 
Summary of Notations
SECTION 4Process of Object Generation
When a new object o is generated, we need to identify the set of subscriptions whose top-k results change by o. An efficient approach achieving this is to maintain subscriptions by using a spatial index, such as R-tree and Quad-tree. However, because the current locations of subscriptions are unknown, we cannot simply maintain them by using a spatial index. To solve this problem, Lamps employs a novel index, namely SQ-tree. This index maintains MkST subscriptions based on their safe regions and a Quad-tree, and it can filter a set of subscriptions whose top-k results do not change by o without requesting their current locations.

In this section, we first propose a novel filtering technique in Section 4.1. Then we present the detailed SQ-tree in Section 4.2. We introduce the algorithm for object generation in Section 4.3 and how to update SQ-tree is presented in Section 4.4.

4.1 Filtering Technique
Given a newly generated object o, we need to identify all subscriptions whose top-k results change by o. We denote the kth smallest score of a subscription s as kscore(s). Then the top-k result of s needs to be updated if kscore(s)>score(s,o). A lot of works have studied spatio-textual search, and it is well known that text-first filtering techniques have good performances [21]. In this section, we propose a novel filtering technique, which filters a set of subscriptions whose top-k results do not change, based on the number of common keywords between s.t and o.t.

Assume that s.p is known. (This assumption is removed later.) Let i be the number of common keywords between s.t and o.t, i.e, |s.t∩o.t|=i. Then we can compute a lower bound of text(s.t,o.t), textlb(s.t,o.t|i), for s such that |s.t∩o.t|=i:

Lemma 3.
textlb(s.t,o.t|i)=1−i|s.t|.

Based on Lemma 3 and Equation (1), we can derive a spatial proximity threshold, λ(s,o|i), for s such that |s.t∩o.t|=i
λ(s,o|i)=kscore(s)α−1−αα⋅textlb(s.t,o.t|i).(3)
View SourceThe following theorem is immediately derived from Equation (3).

Theorem 3.
A newly generated object o does not become the top-k result of s if λ(s,o|i)<dist(s.p,o.p).

Theorem 3 claims that we can safely prune s if λ(s,o|i)<dist(s.p,o.p).

We have assumed that s.p is known. However, without requesting the current locations of all users, the above filtering does not function, because kscore(s) is determined by s.p and λ(s,o|i) is also determined by s.p. To safely prune s regardless of where s is in its safe region R, we modify the above filtering technique. Let kscoreub(s) be the upper bound of kscore(s) when s.p is any position in R. We can compute kscoreub(s):

Lemma 4.
kscoreub(s)=γ⋅α+kscore(s)2

Based on Equation (3) and Lemma 4, we can derive the spatial proximity threshold when s.p is any position in R
λ(s,o|i)=kscoreub(s)α−1−αα⋅textlb(s.t,o.t|i).(4)
View SourceRight-click on figure for MathML and additional features.The following theorem is derived from Equation (4).

Theorem 4.
A newly generated object o does not become the top-k result of s if λ(s,o|i)<dist(s.R,o.p), where dist(s.R,o.p) is the minimum value of the spatial proximity between any position in s.R and o.p.

Theorem 4 claims that we can safely prune s and do not need to update s.R if λ(s,o|i)<dist(s.R,o.p).

4.2 SQ-Tree
Structure. SQ-tree maintains MkST subscriptions based on their safe regions and a Quad-tree as shown in Fig. 6. By exploiting the filtering technique introduced in Section 4.1, it can filter a set of subscriptions whose top-k results do not change by o without requesting their current locations. Each node of an SQ-tree maintains the subscriptions whose centroids of safe regions are in the area of the node. Moreover, unlike conventional spatial indices, the SQ-tree maintains subscriptions not only in its leaf nodes but also in its non-leaf nodes.


Fig. 6.
Illustration of an SQ-tree.

Show All

A node n of the SQ-tree stores the following information.

Sn: a set of subscriptions maintained in n.

In: an inverted file for the subcaptions contained in Sn.

Λn[⋅]: a spatial proximity threshold to filter a set of subscriptions contained in Sn (Equation (6)).

In addtion, let Srn be a set of subscriptions maintained in the subtree rooted at n. If n is a non-leaf node, n stores the following additional information.
Trn: a set of keywords held by subscriptions in Srn.

Λrn[⋅]: a spatial proximity threshold to filter all subcaptions contained in Srn (Equation (7)).

Example 6.
Assume that subscriptions exist as shown in Fig. 2 and that each triangle indicates the centroid of a subscription. Then an SQ-tree is constructed as shown in Fig. 6. For example, Sn2={s1,s3}, so n2 stores an inverted file of their keywords and Λn[⋅]. Because Srn2={s1,s2,s3,s4,s5}, a set of their keywords and Λrn[⋅] are stored in n2.

We introduce the details of spatial proximity thresholds Λn[⋅] and Λrn[⋅]. We first define the minimum value of the spatial proximity between o.p and n, dist(n,o.p).

Definition 5 (dist(n,o.p)).
dist(n,o.p)={0dist(p∗,o.p)(o.p∈n)(o.p∉n),
View SourceRight-click on figure for MathML and additional features.where p∗ is the nearest location from o.p on the boundary of n, and o.p∈n denotes that o.p is in the area of n.

When a subscription s is maintained in n, however, there are two cases: R is fully contained in n (denoted by R⊆n) and R is partially contained in n (denoted by R⊈n). Let c be the centroid of R. In the right case in Fig. 7


Fig. 7.
Example of maintaining s in n.

Show All

, i.e., R⊈n, dist(n,o.p)≤dist(R,o.p) does not always hold. To consider how far R protrudes from n, we define the additional spatial proximity, add(R,n).
Definition 6 (add(R,n)).
add(R,n)={0distf(c,R)−distn(c,n)(R⊆n)(R⊈n),
View Sourcewhere distf(c,R) is the spatial proximity from c to the farthest boundary of R and distn(c,n) is the spatial proximity from c to the nearest boundary of n.

Now the following inequality holds.
dist(n,o.p)≤dist(R,o.p)+add(R,n).(5)
View SourceRight-click on figure for MathML and additional features.Then Λrn[i] and Λn[i] are respectively defined as follows:
Λn[i]=max{λ(s,o|i)+add(s.R,n)|s∈Sn},(6)
View Source
Λrn[i]=max{λ(s,o|i)+add(s.R,n)|s∈Srn},(7)
View Sourcewhere λ(s,o|i)=λ(s,o||s.t|) if |s.t|<i.

Λn[i] indicates a spatial proximity threshold for subscriptions s∈Sn such that |s.t∩o.t|=i. Also, Λrn[i] indicates a spatial proximity threshold for all subscriptions s∈Srn when |Trn∩o.t|=i.

Space Complexity. Each node of SQ-tree stores an inverted file for the subscriptions maintained in the node. The space complexity of SQ-tree is thus O(∑s∈S|s.t|).

Construction. Since the scoring function is based on the spatial proximity and the textual relevance, it is desirable that a subscription index maintains subscriptions based on both the factors. However, a spatial index, such as R-tree and Quad-tree, focuses only on the spatial factor, regardless of the textual factor. To solve this problem, an SQ-tree maintains subscriptions not only in leaf nodes but also in non-leaf nodes based on the textual factor. This is because, if a non-leaf node n maintains subscriptions, for each child node n′ of n, the number of subscriptions maintained in the subtree rooted at n′, i.e., |Srn′|, decreases. Thereby, each spatial proximity threshold Λrn[⋅] of n′ becomes tight, and n′ tends to be pruned.

We then introduce an algorithm that determines the node for maintaining subscriptions. We consider whether a subscription s should be maintained in a node n. Let E[dist(n,o.p)]3 be an expected value of dist(n,o.p) when an object o is generated. Then the probable number of common keywords, pnum(s,n), where the top-k result of s needs to be updated, is calculated as follows:
pnum(s,n)=⌊(1−scoreub(s)−α⋅E[dist(n)]1−α)⋅|s.t|⌋.
View SourceRight-click on figure for MathML and additional features.Moreover, we assume that the distribution of object keywords does not change much over time. Then we define the expected value of in=|Trn∩o.t|, E[in].

Definition 7 (E[in]).
E[in]=∑w∈Trn|Ow||O|,
View SourceRight-click on figure for MathML and additional features.where Ow is a set of objects whose t contains a keyword w and E[in]=tmax if E[in]≥tmax.

When an object is generated, s tends to be pruned if E[in]<pnum(s,n). Thus subscriptions that satisfy this condition are maintained in n even if n is not a leaf node. In Section 7.3, we verify the accuracy of E[in].

Algorithm. Algorithm 1 describes how to insert a subscription s into a node n of the SQ-tree.4 We first update Srn, Trn, E[in], and Λrn[⋅] (lines 1–2). If n is a leaf node, we update Sn, In, and Λn[⋅] (lines 3–5). Furthermore, if |Sn| is larger than the node capacity, which is the maximum number of subscriptions that a leaf node can maintain, we create child nodes and distribute subscriptions with pnum(s,n)≥E[in] to the child nodes. After that, we recompute Λn[⋅] upon subscriptions that are not distributed (lines 6–7). On the other hand, if n is not a leaf node, we distribute subscriptions with pnum(s,n)≥E[in] to its child nodes (line 9). If E[in]<pnum(s,n), we update Sn, In, and Λn[⋅]. If E[in]≥pnum(s,n), we recursively execute Insert(n′,s) where n′ is the child node of n if c is contained in n′ (lines 10–16).

Algorithm 1. Insert(n,s)
Input: n and s

Srn←Srn∪{s}

Update Trn, E[in], and, Λrn[⋅]

if n is a leaf node then

Sn←Sn∪{s}

Update In and Λn[⋅]

if |Sn| is larger than the node capacity then

Create child nodes, distribute subscriptions to child nodes, and recompute Λn[⋅].

else

Distribute subscriptions to child nodes.

if E[in]<pnum(s,n) then

Sn←Sn∪{s}

Update In and Λn[⋅]

else

for ∀n′∈N //N is n's children do

if s.c∈n′ then

Insert(n′,s)

Filtering. We introduce how to filter the subscriptions maintained in each node of the SQ-tree. This filtering is performed in two steps (node filtering and subscriptions filtering). We assume that an object o is generated and we check a node n.

Subscriptions Filtering. Here, we focus on how to filter subscriptions maintained by a node n. Let imin be the smallest i such that Λn[i]≥dist(n,o.p). imin indicates the minimum required number of common keywords for o to become the top-k result of each subscription in Sn. So, we have the following theorem:

Theorem 5.
Given a newly generated object o and imin, o does not become the top-k result of s∈Sn if |s.t∩o.t|<imin.

From Theorem 5, we can safely prune subscriptions s such that |s.t∩o.t|<imin, and we do not need to update their top-k results and safe regions.

Example 7.
In Figs. 2 and 6, we assume that o9 is generated and we check n2. Because Λn2[1]<dist(n2,o9.p)<Λn2[2], imin=2. Therefore, the top-k result of each subscription s∈Sn, s1 and s3, may be updated by o9 if |s.t∩o.t|≥2. From Fig. 2, |s1.t∩o9.t|=2 and |s3.t∩o9.t|=1. We therefore add only s1 to the set of candidate subscriptions.

Node Filtering. We next present how to filter all subscriptions contained in a subtree rooted at n. Recall that Trn is a set of keywords contained in s∈Srn. Given in=min{|Trn∩o.t|,tmax}, we have the following theorem:

Theorem 6.
If Λrn[in]<dist(n,o.p), a newly generated object o does not become the top-k result of s∈Srn.

Theorem 6 claims that we can safely prune n, i.e., we do not need to update the top-k results and safe regions of all subscriptions contained in Srn if Λrn[in]<dist(n,o.p).

Example 8.
In Figs. 2 and 6, we assume that o10 is generated and we check n2. The common keyword between Trn2 and o10.t is w2, so in2=1. Since dist(n2,o10.p)=0.6, Λrn2[in]<dist(n2,o10.p). Therefore, n2 is pruned. That is, the top-k results and the safe regions of all subscriptions contained in Srn2 are not updated by o10.

Algorithm 2. HandleGeneratedObject(o)
Input: o

Sg←∅,H←∅ //Sg is a set of candidate subscriptions

Push root node of SQ-tree into H

while H≠∅ do

n← the node popped from H

in← min(|Trn∩o.t|,tmax)

if Λrn[in]≥dist(n,o.p) then

if n is not a leaf node then

for ∀n′∈N //N is n's children do

if Srn′≠∅ then

Push n′ into H

if Sn≠∅ then

imin← min{i|Λn[i]≥dist(n,o.p)}

if imin≤in then

for ∀s∈Sn where |s.t∩o.t|≥imin do

Sg←Sg∪{s}

UpdateResult(o,Sg)

4.3 Algorithm for Object Generation
Algorithm 2 describes the SQ-tree based algorithm for object generation. Following the filtering-and-verification paradigm, we first obtain a set of candidate subscriptions by using SQ-tree (lines 1–15), and then verify the candidate subscriptions (line 16). Specifically, we first initialize a set Sg of candidate subscriptions and a heap H to keep the nodes of SQ-tree which have not been pruned, and the root node of SQ-tree is pushed H (lines 1–2). Each node n popped in line 4 is processed as follows. We first calculate in (line 5). Next, if n is not pruned by node filtering (line 6) and n is not a leaf node, each child node n′ of n such that Srn′≠∅ is pushed into H (lines 7–10). If Sn≠∅, in addition, we execute the subscriptions filtering for subscriptions contained in Sn (lines 12–15). We first obtain imin (line 12). If in<imin, we have |s.t∩o.t|<imin for each subscription s∈Sn. In this case, all subscriptions contained in Sn are pruned. Therefore, iff imin≤in, we add s∈Sn, where |s.t∩o.t|≥imin, to Sg (lines 13–15). After filtering, we execute UpdateResult for Sg (line 16).

Algorithm 3 describes how to update the result and the safe region of each subscription s∈Sg. First, we ask the user who issued s for his/her current location, update the scores of the current top-k results, and calculate score(s,o) (lines 2–3). If score(s,o)<kscore(s), the top-k result of s is updated (i.e., o becomes a new top-k result of s) and the object whose score for s was the kth smallest before the top-k result update becomes ok+1 (lines 5–7). On the other hand, if score(s,o)≥kscore(s), the top-k result of s does not change. Because we need to update the safe region of s and o is not necessarily ok+1, we execute RetrieveObject to get ok+1. (We introduce the details later.) Then we compute a new safe region of s by using the ASR construction algorithm (line 10).

Algorithm 3. UpdateResult(o,Sg)
Input: o,Sg

for ∀s∈Sg do

Update s.l and score(s,o∗) for each object o∗∈s.A

Calculate score(s,o)

ok+1←∅

if score(s,o)<kscore(s) then

ok+1← the object whose score for s is the kth smallest

s.A←s.A∪{o}−{ok+1}

else

ok+1← RetrieveObject(s)

Compute the ASR of s based on ok+1

Theorem 7.
The worst time complexity of the algorithm for object generation is O(∑s∈Sϕ|s.t|), where ϕ is the average number of objects containing each keyword.

4.4 SQ-Tree Maintenance
When the top-k result and the safe region of a subscription s are updated, we need to update the SQ-tree, because the node that maintains s and the information stored in each node may change. If the centroid of the updated safe region of s is contained in n where n maintains s, we update the information stored in n and the ancestor nodes of n if necessary. Otherwise, we remove s from the SQ-tree once and insert it again based on the updated safe region.

SECTION 5Process of Object Expiration
5.1 IQF
When an object o′ expires, we need to re-evaluate the top-k results and the safe regions of subscriptions whose top-k results contain o′. To obtain such subscriptions, we use the result index that maintains objects that are top-k results of at least one subscription. When we re-evaluate the top-k result and the safe region of a subscription s, we have to retrieve the objects whose scores for s are the kth and (k+1)th smallest, ok and ok+1. To retrieve such objects efficiently, Lamps employs the object index, namely IQF, which is composed of Inverted file, and Quad-tree for each Frequent keyword, as shown in Fig. 8. Recall that an object must contain at least one common keyword with a subscription s to become the top-k result of s. Therefore, IQF maintains objects with an inverted file. If a keyword w∈s.t is contained in a lot of objects, however, it is time-consuming to check all the objects contained in the posting list of w, PL[w]. To solve this problem, we employ the concept of Inverted linear Quad-tree, which creates a Quad-tree for each keyword and is a state-of-the-art index for spatio-textual top-k search [22]. If we create Quad-trees for all keywords, however, we incur a large memory cost. Therefore, we create a Quad-tree, Qw, for each frequent keyword w. In this paper, frequent keywords are defined as the keywords whose appearance frequencies are in the top-x percent among all keywords. (If x is large, we create Qw′ for a non-frequent keyword w′, and it incurs a large memory cost. Therefore, we determine x empirically.)

Space Complexity. IQF maintains an inverted file for each object. The space complexity of IQF is O(∑o∈O|o.t|).

Fig. 8. - 
Example of IQF.
Fig. 8.
Example of IQF.

Show All

5.2 Algorithm for Object Expiration
Here, we focus on how to retrieve ok. Recall that we need ok+1 to calculate the ASR. We obtain it at the same time as we retrieve ok. For each object o∈Os.t∖s.A, if |s.t∩o.t|=i, the lower bound of score(s,o), scorelb(s,o|i), is calculated as follows:
scorelb(s,o|i)=(1−α)⋅(1−i|s.t|).
View SourceRight-click on figure for MathML and additional features.Let ob be the object that has the best score among the objects checked so far. Then we have the following theorem:

Theorem 8.
If scorelb(s,o|i)≥score(s,ob), for each object o∈Os.t∖s.A such that |s.t∩o.t|≤i, score(s,o)≥score(s,ob).

From Theorem 8, we can safely prune objects such that |s.t∩o.t|<i and ob becomes ok if scorelb(s,o|i)≥score(s,ob).

Algorithm 4 describes how to retrieve ok. Because the object with a large |s.t∩o.t| is likely to become ok, we should check each object o in descending order of |s.t∩o.t|=i. If i>1, for each object o∈Os.t∖s.A with |s.t∩o.t|=i, we set o to ok if score(s,o)<score(s,ok). (lines 7–9). On the other hand, if i=1, for each keyword w∈s.t, we execute Search−QF(Qw,s,ok), where w is a frequent keyword. Otherwise, we set o to ok for each object o contained in PL[w] if score(s,o)<score(s,ok). (lines 10–16). Search−QF(Qw,s,ok) checks the objects in Qw closer to s.p in order and sets o to ok if o∉s.A and score(s,o)<score(s,ok). If the scores of unchecked objects are never smaller than score(s,ok), we terminate the retrieval.

Algorithm 4. RetrieveObject(s)
Input: s,O

ok←∅

for ∀o∈Os.t∖s.A do

Compute |s.t∩o.t| by using Inverted file

i←|s.t|

while i>0∧scorelb(s,o,|i)<score(s,ok) do

if i>1 then

for ∀o∈Os.t∖s.A such that |s.t∩o.t|=i do

if score(s,o)<score(s,ok) then

ok←o

else

for ∀w∈s.t do

if w is a frequent keyword then

Search−QF(Qw,s,ok)

else

for ∀o∈PL[w]∖s.A do

if score(s,o)<score(s,ok) then

ok←o

i←i−1

return ok

Example 9.
Assume that objects exist as shown in Fig. 2 and w1 and w2 are frequent keywords. Then IQF is constructed as shown in Fig. 8. Moreover, we assume that o1 expires, and we re-calculate the top-k result of s2. Since s2.t={w1,w4}, we first check the objects whose keywords contain both w1 and w4, i.e., o3 and o5. If scorelb(s2,o|1)<score(s2,ok) after checking those objects, we need to check the objects whose keywords contain w1 or w4. When we check the objects whose keywords contain w1, we check the objects in Qw1 closer to s2.p in order. On the other hand, when we check the objects whose keywords contain w4, we check all objects in PL[w4]. Finally, the object, whose score is the smallest among the checked objects, becomes the new top-k result of s2.

Theorem 9.
The worst time complexity of the algorithm for object expiration is O(∑s∈Seϕ|s.t|), where Se is a set of subscriptions whose top-k results contain an expired object and ϕ is the average number of objects containing each keyword.

SECTION 6Discussion
Spatial Proximity Functions. In this paper, we use the euclidean distance for spatial proximity function. If we use road network distance, we compute a safe segment for each subscription [11]. A safe segment is a potion of edge where the top-k result does not change. That is, a safe segment is the road network version of a safe region. Then, we maintain subscriptions based on their safe segments and a G-tree [23], and filter a set of subscriptions whose top-k results do not change by the newly generated object.

Textual Similarity Functions. In this paper, we use Jaccard similarity for textual similarity function. If we use Dice or Cosine similarities, it is enough to change Lemma 3 based on their definitions. In Appendix B.2, available in the online supplemental material, we verify the performance when we use each similarity function.

Procedure of Subscription Issue and Deletion. If a new subscription s is issued, we can compute the top-k result of s in the same way as Algorithm 4, and then we retrieve (k+1) objects whose scores for s are the smallest. After that, we compute the ASR of s and its centroid and then insert s into the SQ-tree. If a subscription s′ is deleted, we remove s′ from the SQ-tree and update information stored in the node n, which maintain s′, and the ancestor nodes of n if necessary.

SECTION 7Experiment
In this section, we conduct extensive experiments to verify the efficiency of Lamps. All algorithms were implemented in C++, and all experiments were conducted on a PC with 3.20 GHz Intel Core i7 processor and 64 GB RAM. Following the typical setting of pub/sub systems (e.g., [13], [20]), we assume that the indices fit in the main memory to support real-time response.

7.1 Experimental Setup
Since this is the first work of the problem of monitoring top-k spatio-textual objects for a large number of moving top-k spatio-textual subscriptions, there is no existing method. Therefore, we compared Lamps with Naive and three methods that adopt some of the functions of Lamps: Lamps w/o ASR, Lamps w/o SQ-tree, and Lamps w/o IQF. In Lamps w/o ASR, we use LSR instead of ASR for the safe region of each subscription. Because there is no existing index maintaining moving top-k subscriptions, Lamps w/o SQ-tree accesses all subscriptions and updates the results when an object is generated. Lamps w/o IQF adopts IQ-tree instead of IQF to maintain objects. IQ-tree is a hybrid structure of inverted file and Quad-tree, like IR-tree [24].

Object Datasets. We used two real datasets to simulate object stream. TWEETS consists of 20 million geo-tagged tweets located inside the United States [6]. PLACES consists of 9.4 million public places inside the United States [14]. Each entry in PLACES includes the geo-location and the set of keywords. The statistics of the two datasets are summarized in Table 2.

TABLE 2 Dataset Statistics
Table 2- 
Dataset Statistics
Trajectory Datasets. We used real and synthetic trajectories to simulate the movements of users. For the real trajectories, we used the GPS records from OSM.5 In our experiments, timestamp (ts), was used to capture the periodicity of location update. We set each ts to be 1 second in the experiments. We extracted 1,000,000 trajectories, and each trajectory contains 100 sequential points. For the synthetic trajectories, we generated 1,000,000 trajectories based on the intersections and the roads of the United States6 (SUS). Each trajectory contains 1,000 sequential points.

Subscription Workload. We generated |S| MkST subscriptions based on the object datasets. (The default |S| is 1,000,000.) For each subscription, we randomly picked l keywords from a tweet or an entry as subscription keywords (1≤l≤5). For the trajectory of each subscription, we randomly chose a trajectory from the extracted or generated trajectories. For each subscription s, in addition, the preference parameter s.α was randomly chosen from (0, 1) and k was a random number between 1 and kmax. Throughout the experiments, we set kmax to 10, unless otherwise specified.

Object Workload. Our experiment starts after |Oinit| initial objects are generated. (The default |Oinit| is 1,000,000.) For each timestamp, we generate f object updates including object generations and object expirations. (The default f is 100.) Let ϵ be the percentage of expirations, and object updates include f⋅(1−ϵ) object generations and f⋅ϵ object expirations. Note that object expirations in the real applications introduced in Section 1 are very rare compared with object generations [25]. Therefore, ϵ is a small value and we used 0.1 as the default value of ϵ.

We report the update time (the average time to update the top-k results of subscriptions against object generations/expirations and movements of users per ts). The update time includes the generated objects’ processing (GOP) time, the expired objects’ processing (EOP) time, and the movements of users processing (MUP) time.

7.2 Tuning
First, we tune the value of x, where x is the percentage of frequent keywords among all keywords. Recall that we create Qw for each keyword w whose appearance frequency is in the top-x percent among all keywords (see Section 5).

Fig. 9 reports the retrieval time (the average time to retrieve ok+1) and the memory cost against the two datasets. Although the memory cost increases with the increase of x, the retrieval time is almost constant when x≥0.5. Therefore, we set 0.5 as the default x value in the following experiments, because it strikes a good trade-off between the retrieval time and the memory cost.

Fig. 9. - 
Impacts of $x$x.
Fig. 9.
Impacts of x.

Show All

7.3 Experimental Results
Comparison Between LSR and ASR. Fig. 10 reports the computation times (the average times required to compute the safe regions of users who exit their safe regions per ts) of the LSR and the ASR using the two datasets where each parameter follows the default setting. The number of subscriptions that exit their safe regions per ts in ASR case is slightly larger than that in LSR case, because ASR tends to be smaller than LSR. However, the ASR is computed very fast by avoiding computation of the dominant regions and their intersections, so, at a timestamp, ASR computation does not become an overhead of result update even if the number of subscriptions that exit their safe regions is large.

Fig. 10. - 
Comparison between LSR and ASR.
Fig. 10.
Comparison between LSR and ASR.

Show All

Accuracy of E[in]. We verify the accuracy of E[in] in Fig. 11 by using each dataset and varying the number of subscriptions |S|. Fig. 11 reports the average error (the average of |E[in]−in| calculated in the node filtering). We see that E[in] is sufficiently accurate, because the average error is less than 1 regardless of |S|.


Fig. 11.
Accuracy of E[in].

Show All

Overall Performance. Table 3 shows the update time of each method where each parameter is the default setting. Lamps is the fastest among all the methods, regardless of the object and trajectory datasets. When we use PLACES, the update time is longer than when we use TWEETS. This is because the vocabulary size of PLACES is smaller than that of TWEETS. On PLACES, each object and subscription tend to have the same keywords, thereby the number of subscriptions whose top-k results may change by a newly generated object increases and the posting list of each keyword is large. As mentioned above, ASR has much better performance than LSR. Therefore, Lamps is much faster than Lamps w/o ASR. Moreover, Lamps is much faster than Lamps w/o SQ-tree because Lamps can filter subscriptions whose top-k results do not change by using SQ-tree when an object is generated.

TABLE 3 Average Update Time [ms] of Each Method

Lamps is faster than Lamps w/o IQF, and has an advantage in the aspect of memory cost. Table 4 shows the memory cost of each method when we use OSM. Lamps needs less memory cost than Lamps w/o IQF. Recall that Lamps w/o IQF adopts IQ-tree instead of IQF to maintain objects. IQ-tree incurs a large memory cost, because each node of IQ-tree creates an inverted file for keywords of objects maintained in the subtree rooted at the node.

TABLE 4 Memory Cost [GB] of Each Method
Table 4- 
Memory Cost [GB] of Each Method
In the following experiments, we compared Lamps with Lamps w/o SQ-tree. When we examined the impact of frequency of object updates, we add Lamps w/o IQF as a competitor. Moreover, we use OSM for trajectory dataset since the update time of each dataset is almost the same.

Impact of kmax. We examined the impact of kmax and Fig. 12 shows the result. Lamps consistently updates the top-k results faster than Lamps w/o SQ-tree. Both methods need a longer update time as kmax increases. When kmax increases, the possibility that an expired object is contained in the top-k results for the subscriptions becomes high. Because the numbers of recalculations of the top-k results and safe regions increase, the EOP time increases. When kmax increases, moreover, the average kscore(s) of the subscriptions becomes larger, so a newly generated object is more likely to affect more top-k results of the subscriptions. With a large kmax, the GOP time of Lamps increases. On the other hand, the GOP time of Lamps w/o SQ-tree is constant because Lamps w/o SQ-tree always checks the top-k results of all subscriptions when an object is generated. Therefore, the difference in update time between Lamps and Lamps w/o SQ-tree becomes slightly smaller as kmax increases.

Impact of Number of Subscriptions. We examined the impact of number of subscriptions, |S|, and Fig. 13 shows the result. Lamps updates the top-k results faster than Lamps w/o SQ-tree. Both methods need a longer update time as |S| increases. The difference in update time between Lamps and Lamps w/o SQ-tree becomes larger as |S| increases (Note that Fig. 13 plots the result on log scale.). Lamps w/o SQ-tree checks the top-k results of all subscriptions when an object is generated. On the other hand, Lamps can filter subscriptions whose top-k results do not change. Because the difference in the number of subscriptions whose top-k results are updated becomes larger as |S| increases, the difference in update time becomes larger.

Impact of Number of Initial Objects. We examined the impact of number of initial objects, |Oinit|, and Fig. 14 shows the result. Lamps updates the top-k results faster than Lamps w/o SQ-tree. Both methods need a longer update time as |Oinit| increases. When |Oinit| increases, a newly generated object will affect fewer top-k results of subscriptions, and the possibility that an expired object is contained in the top-k results of the subscriptions becomes low. However, the number of users that exit their safe regions and the number of objects checked when the top-k results and the safe regions are recalculated increases. Therefore, the update time slightly increases.

Impact of Frequency of Object Updates. We examined the impact of frequency of object updates, f. Fig. 15 shows the result, and Lamps is a clear winner. Moreover, all methods need a longer update time as f increases. This is because all methods process newly generated and expired objects one by one, so the GOP and EOP time of all methods increases linearly.

Impact of Percentage of Expirations. We examined the impact of percentage of expirations, ϵ. Recall that we generate f object updates for each timestamp and they include f⋅(1−ϵ) object generations and f⋅ϵ object expirations. Fig. 16 shows the result and Lamps is a clear winner. Because Lamps and Lamps w/o IQF efficiently update the top-k results by using SQ-tree, the GOP time of them is small. The update time of them increases as ϵ increases. On the other hand, the GOP time of Lamps w/o SQ-tree is much larger than the EOP time. This is because Lamps w/o SQ-tree accesses all subscriptions and updates the results when an object is generated, so the update time of Lamps w/o SQ-tree decreases as ϵ increases.

Fig. 12. - 
Impact of $k_{max}$kmax.
Fig. 12.
Impact of kmax.

Show All

Fig. 13. - 
Impact of $|S|$|S|.
Fig. 13.
Impact of |S|.

Show All


Fig. 14.
Impact of |Oinit|.

Show All

Fig. 15. - 
Impacts of $f$f.
Fig. 15.
Impacts of f.

Show All

Fig. 16. - 
Impacts of $\epsilon$ε.
Fig. 16.
Impacts of ϵ.

Show All

SECTION 8Related Work
In this section, we review the existing studies of spatio-textual top-k search, pub/sub systems, and moving query processing.

Spatio-Textual Top-k Query. Spatio-textual top-k query has been widely studied [22], [26], [27], [28]. These studies proposed methods that combine both a spatial index (e.g., R-tree and Quad-tree) and a textual index (e.g., an inverted file). A good summary of spatio-textual query processing is available in [21], and text-first filtering techniques have good performances. In addition, [22] proposed inverted linear Quad-tree (IL-Quad-tree), which creates a Quad-tree for each keyword. IL-Quad-tree is a state-of-the-art index for spatio-textual top-k query, thus we employ the concept of IL-Quad-tree for the object index of Lamps. Recently, a variety of spatio-textual top-k queries have been studied, for example, reverse spatio-textual query [17], why-not top-k spatio-textual query [29], and time-aware spatio-textual query [30]. However, these works did not consider streaming objects.

Pub/Sub System. Recently, location-aware pub/sub systems have been studied [5], [6], [13], [14], [15], [20], [31], [32], [33], [34]. The works in [5], [14], [15], [20], [31], [33] studied the boolean matching problem. For example, in [20] and [14], AP-tree and FAST, which can find subscriptions such that the location of a newly generated object o is in their ranges and the keywords of o contain their keywords, were proposed. Moreover, literature [32] studied a similarity search problem in which each query has a pre-given threshold. These works differ from ours because they do not consider top-k monitoring. Literatures [6] and [13] addressed the problem of monitoring spatio-textual top-k objects for a large number of subscriptions. The methods proposed in these works maintain subscriptions with an index based on a Quad-tree and filter the subscriptions whose top-k results do not change when an object is generated. However, these works assume that the locations of users (subscriptions) are static. These methods cannot simply maintain moving subscriptions.

Moving Query Processing. Many studies have addressed the problem of monitoring spatio-textual objects for moving queries [4], [5], [8], [9], [10]. The works in [5], [8], [9], [10] proposed methods that compute the safe region of a query q and re-evaluate the result of q when the user who issued q exits his/her safe region. However, literatures [8], [9], [10] did not consider streaming objects. Because the safe region may change because of the generation of new objects, the methods proposed in these works need to re-compute the safe region whenever a new object is generated. This incurs a large evaluation cost. On the other hand, literatures [4], [5] considered streaming objects. For example, in [5], an impact region, which is a region where a newly generated object may become the result when a user is in his/her safe region, was proposed. However, these works differ from ours because they focus on range queries.

SECTION 9Conclusion
Many applications based on pub/sub systems and moving query processing have been attracting a lot of attention. In this paper, we addressed the problem of monitoring top-k spatio-textual objects for a large number of moving top-k spatio-textual subscriptions. To tackle this problem, we proposed a novel system, called Lamps. Lamps employs a novel index, namely SQ-tree, which maintains subscriptions based on their safe regions and a Quad-tree, and it can filter subscriptions whose top-k results do not change when a new object is generated. Moreover, we proposed an efficient algorithm to retrieve the objects that become top-k objects when an object expires or when users exit their safe regions. We furthermore developed a novel approximation technique for safe region construction. We evaluated Lamps by experiments on real datasets, and the results show that Lamps achieves higher performance than baseline approaches.