As the scale of datasets used for big data applications expands rapidly, there have been increased efforts to develop faster algorithms. This paper addresses big data summarisation problems using the submodular maximisation approach and proposes an efficient algorithm for maximising general non-negative submodular objective functions subject to k-extendible system constraints. Leveraging a random sampling process and a decreasing threshold strategy, this work proposes an algorithm, named Sample Decreasing Threshold Greedy (SDTG). The proposed algorithm obtains an expected approximation guarantee of 11+𝑘−𝜖 for maximising monotone submodular functions and of 𝑘(1+𝑘)2−𝜖 in non-monotone cases with expected computational complexity of 𝑂(𝑛(1+𝑘)𝜖ln𝑟𝜖). Here, r is the largest size of feasible solutions, and 𝜖∈(0,11+𝑘) is an adjustable designing parameter for the trade-off between the approximation ratio and the computational complexity. The performance of the proposed algorithm is validated and compared with that of benchmark algorithms through experiments with a movie recommendation system based on a real database.

Introduction
The research of big data has received extensive attention due to its great significance [1]. Data summarisation, which involves extracting representative information with certain constraints from a large-scale dataset, is one of the compelling directions of big data processing [2]. Typical applications of big data summarisation include personalised recommendation systems [3,4,5,6], exemplar-based clustering [7,8,9], and summarisation of text [10, 11], images [12,13,14], corpus [8, 15], and videos [16, 17], just to name a few.

The unprecedented growth of modern datasets requires efficient and effective techniques to process a mass of data. Computational complexity is one of the grand challenges of big data operations [1]. Fortunately, the quality of data summarisation outcome can be often measured by submodular set functions [11, 12, 14], where the marginal gain value of an element decreases as more elements have already been selected, namely diminishing returns [18]. It is well known that the greedy-related algorithms are efficient and can provide an approximation guarantee for maximising submodular functions [19]. Hence, the big data summarisation problem can be handled as maximising a submodular function based on a large-scale dataset, meanwhile satisfying a certain constraint or a combination of several constraints [2].

This paper addresses big data summarisation problems using the submodular maximisation approach, especially subject to k-extendible system constraints. Note that the k-extendible system constraint is a general type of constraint that has been widely studied. The concept of k-extendible systems was first introduced by Mestre in 2006 [20]. The intersection of k matroids based on the same ground set is always k-extendible [20]. Many types of constraints handled in submodular maximisation problems fall into the k-extendible system constraint, such as the cardinality constraint, partition matroid constraint, and k-matroid constraint.

The issue is that finding the optimal solution of submodular maximisation is NP-hard, and the sizes of datasets tend to increase. NP-hard problems are known to significantly suffer from “curse of dimensionality”, which implies that the complexity of the problem explodes as the problem size increases. Therefore, the trend of increasing sizes of datasets combined with the NP-hardness of the problem urges the development of more computationally efficient optimisation algorithms. The Sample Greedy algorithm (Sample, for short) proposed in [21] is one of the state-of-the-art algorithms for constrained submodular maximisation problems. Specifically, Sample [21] was the fastest algorithm (before this work) for maximising non-monotone submodular functions subject to a k-extendible system constraint.

Inspired by the sampling strategy from [21] and a decreasing threshold idea from [22], this work proposes an algorithm that is even faster than Sample [21]. The proposed algorithm, which is named as Sample Decreasing Threshold Greedy (SDTG), provides an expected approximation guarantee of 𝑝−𝜖 for maximising monotone submodular functions and of 𝑝(1−𝑝)−𝜖 for non-monotone cases with expected time complexity of only 𝑂(𝑝𝑛𝜖ln𝑟𝜖), where 𝑝∈(0,11+𝑘] is the sampling probability and 𝜖∈(0,𝑝) is the threshold decreasing parameter. If the sampling probability p is set as 11+𝑘, then SDTG provides the best approximation ratios for both monotone and non-monotone submodular functions which are 11+𝑘−𝜖 and 𝑘(1+𝑘)2−𝜖, respectively. Here, 𝜖 acts as a design parameter for the trade-off between the approximation ratio and the computational complexity. The proposed algorithm is validated through experiments with a movie recommendation system based on the MovieLens [23] which is a widely used real movie information database. Experimental results demonstrate that the proposed algorithm outperforms benchmark algorithms in terms of both solution quality and computation efficiency. The main contributions of this work are summarised as follows:

This work proposes the current fastest algorithm, SDTG, for maximising non-monotone submodular functions subject to k-extendible system constraints;

Precise mathematical proofs are provided for analysing the theoretical guarantees of the proposed algorithm;

Experiments with a movie recommendation system based on a real database are carried out to reveal the practical performance of SDTG for solving the big data summarisation problem.

The rest part of this work is organised as follows. “Related works” section investigates related articles for constrained submodular maximisation problems. In “Preliminaries” section, some basic knowledge related to the proposed algorithm is presented. “Algorithm and analysis” section demonstrates the proposed algorithm and analyses its theoretical performance in detail. The performance and validity of the theoretical results are then testified through experiments with a movie recommendation system in “Experiments” section. “Conclusions” section offers the conclusions of this paper and possible future research directions.

Related works
There have been numerous works recently carried out to develop more efficient constrained submodular maximisation algorithms, and many of them endeavour to increase computational efficiency even by sacrificing some degree of approximation ratio. These works are classified by the types of constraints, and their developments are summarised in the following.

Cardinality constraint
The Sieve-Streaming proposed by Badanidiyuru et al. [12] is the first single-pass streaming algorithm for maximising monotone submodular functions, achieving approximation guarantee of 1/2−𝜖 with computational complexity of 𝑂(𝑛𝜖log𝑟). Here, n is the size of the ground set, r is the size of the largest feasible solution. Norouzi-Fard et al. [9] proposed another single-pass algorithm SALSA that improved the approximation guarantee to a value better than 1/2. They also extended their work to a multi-pass algorithm P-PASS that provided the trade-off between the approximation ratio and the number of passes. The Decreasing Threshold Greedy proposed in [22] obtained an approximation ratio of 1−1/𝑒−𝜖 with time complexity of 𝑂(𝑛𝜖log𝑛𝜖) for monotone submodular functions. This is the first streaming algorithm whose computational complexity is independent of r. Later, the sampling-based Stochastic Greedy proposed by Mirzasoleiman et al. [24] achieved an expectantly the same approximation ratio with lower time complexity of 𝑂(𝑛log1𝜖), compared with the Decreasing Threshold Greedy [22]. The Stochastic Greedy gets orders of magnitudes faster by losing only a bit of approximation ratio compared with other benchmark algorithms. Then Buchbinder et al. [25] extended the Stochastic Greedy to general non-monotone cases and achieved an approximation guarantee of 1/𝑒−𝜖 with computational complexity of 𝑂(𝑛𝜖2log1𝜖). Recently, Breuer et al. [26] proposed an efficient algorithm FAST for the monotone case, using the adaptive sequencing technique. FAST achieves an approximation ratio of 1−1/𝑒−𝜖, with 𝑂(𝑛loglog𝑟) queries.

Matroid constraint
The original greedy algorithm (Greedy) [19] provides an approximation ratio of 1/2 with time complexity of O(nr) for monotone submodular maximisation. Nemhauser and Wolsely [27] proved that no algorithm can achieve an approximation ratio better than 1−1/𝑒 with polynomial time complexity. The continuous greedy based on the multilinear extension was utilised to achieve an approximation ratio of 1−1/𝑒 [28]. The measured continuous greedy algorithm developed by Feldman et al. [29] achieved a (1−1/𝑒)-approximation for the monotone case and a 1/e-approximation for the non-monotone case. This is the first algorithm to provide a constant factor of approximation for maximising non-monotone submodular functions subject to a partition matroid constraint. However, the sophisticated continuous algorithms are inherently too time-consuming to be applied directly in the real world [30]. To remedy this, the idea of decreasing threshold [22] was adapted to reduce the computational complexity [31]. Badanidiyuru and Vondrak [22] proposed a new variant of the continuous greedy algorithm and achieved an approximation ratio of 1−1/𝑒−𝜖 with complexity of 𝑂(𝑛𝑟𝜖4log2𝑟𝜖) for monotone submodular functions. Then, a close variant of the Decreasing Threshold Greedy described in [25] provided an approximation ratio of 1/2−𝜖 with computational complexity of 𝑂(𝑛𝜖log𝑟𝜖) for the monotone case.

k-extendible system constraint
It is known that Greedy [19] achieves a 11+𝑘-approximation for maximising monotone submodular functions subject to a k-extendible system constraint. The Decreasing Threshold Greedy [22] provides a slightly worse approximation guarantee of 11+𝑘+𝜖 but requires lower computational complexity of 𝑂(𝑛𝜖2log2𝑛𝜖) than Greedy [19] does for maximising monotone submodular functions. For the non-monotone case, Gupta et al. [32] proposed an algorithm achieving an approximation ratio of 𝑘(𝑘+1)(3𝑘+3) with time complexity of O(nrk). Then, the approximation ratio was improved to 𝑘(𝑘+1)(2𝑘+1) by an algorithm called FANTOM proposed by Mirzasoleiman et al. [5] with the same complexity. After this, Feldman et al. [21] made a significant breakthrough in terms of both approximation ratio and time complexity. The Sample algorithm proposed in [21] achieved an approximation ratio of 𝑘(𝑘+1)2 with complexity of 𝑂(𝑛+𝑛𝑟/𝑘). Experiments based on a movie recommendation system in [21] confirmed that Sample outperformed FANTOM in terms of computational efficiency.

In summary, gradual improvements have been made for solving the constrained submodular maximisation problems recently. However, the rapid expansion in the scale of modern datasets urges persistent developments for faster algorithms. An immediate research question would be whether or not one can develop an algorithm that can further improve the efficiency of maximising general non-negative submodular functions especially subject to k-extendible system constraints.

Preliminaries
This section presents some necessary definitions and basic concepts related to the proposed algorithm. The definitions and concepts can also be found in our previous works [33,34,35].

Definition 1
(Submodularity [21]) A set function 𝑓:2→ℝ is submodular if, ∀ 𝑋,𝑌⊆,

𝑓(𝑋)+𝑓(𝑌)≥𝑓(𝑋∩𝑌)+𝑓(𝑋∪𝑌).
where  is named as “ground set” which is a finite set containing all elements. Equivalently, ∀ 𝐴⊆𝐵⊆ and 𝑢∈−𝐵,

𝑓(𝐴∪{𝑢})−𝑓(𝐴)≥𝑓(𝐵∪{𝑢})−𝑓(𝐵).
(1)
Definition 2
(Marginal gain value [36] (mgv)) For a set function 𝑓:2→ℝ, a set 𝑆⊆, and an element 𝑢∈, the marginal gain value of f at S with respect to u is defined as

Δ𝑓(𝑢|𝑆)≐𝑓(𝑆∪{𝑢})−𝑓(𝑆),
where ≐ means equal by definition. This work denotes the marginal gain value as “mgv” for tidiness.

The inequality (1) is known as the diminishing return, which is a crucial property of submodular functions: the mgv of a given element will never increase as more elements have already been selected. One intuitive example for the submodularity is the sensor placement problem: The space coverage increment obtained by adding an extra fire detector to a particular position of a room will never increase as more detectors have already been placed in the room.

Definition 3
(Monotonicity [36]) A set function 𝑓:2→ℝ is monotone if, ∀𝐴⊆𝐵⊆, 𝑓(𝐴)≤𝑓(𝐵). f is non-monotone if it is not monotone.

The submodular objective functions considered in this paper are normalised (i.e. 𝑓(∅)=0), non-negative (i.e. 𝑓(𝑆)≥0, ∀𝑆⊆), and can be either monotone or non-monotone.

Definition 4
(Matroid [22]) A matroid is a pair =(,) where  is the ground set, and ⊆2 is a collection of independent sets, satisfying:

∅∈;

If 𝐴⊆𝐵,𝐵∈, then 𝐴∈;

If 𝐴,𝐵∈,|𝐴|<|𝐵|, then ∃ 𝑢∈𝐵−𝐴  such  that  𝐴∪{𝑢}∈.

Specifically, matroid constraints include uniform matroid constraints and partition matroid constraints. The uniform matroid constraint is also called cardinality constraint, which is a special case of matroid constraints where any subset 𝑆⊆ satisfying |𝑆|≤𝑟 is independent, i.e. 𝑆∈. The partition matroid constraint means that an independent subset S can contain at most a certain number of elements from each of the disjoint partitions of .

A typical example for the partition matroid constraint is the security camera system: Each camera of the system can only point to one of its admissible directions at a certain moment. The partition matroid constraint is a special case of k-extendible system constraints where k equals to 1. A formal definition of the k-extendible system constraint is given following an auxiliary concept.

Definition 5
(Extension [21]) If an independent set B strictly contains an independent set A, then B is called an extension of A.

Definition 6
(k-extendible system [20]) A k-extendible system is an independence system (,) that for every independent set 𝐴∈, an extension B of A, and an element 𝑢∉𝐴, 𝐴∪{𝑢}∈, there exists a subset 𝑋⊆𝐵−𝐴 with |𝑋|≤𝑘 such that (𝐵−𝑋)∪{𝑢}∈.

Intuitively, if an element u is added into an independent set A of a k-extendible system, it requires at most k other elements to be removed from A in order to keep the set independent [21]. For example, a certain user of a movie recommendation system likes three genres of movies: Action, Adventure, and Sci-Fi. Suppose that this user wants at most one movie from each of these three genres. Note that a movie can belong to multiple genres. Here are four movies with genre information: 𝑚𝑣1 (Action), 𝑚𝑣2 (Adventure), 𝑚𝑣3 (Sci-Fi), and 𝑚𝑣4 (Action, Adventure, Sci-Fi). According to the requirement from the user, a recommendation list 𝑆={𝑚𝑣1,𝑚𝑣2,𝑚𝑣3} is independent, i.e., 𝑆∈; adding 𝑚𝑣4 to S will make it dependent. Movies 𝑚𝑣1, 𝑚𝑣2, and 𝑚𝑣3 must be removed from S to keep it independent if 𝑚𝑣4 is remained in S. Therefore, the constraint in this example is a 3-extendible system constraint.

The following is an important claim that provides the mathematical foundation for Sample [21] to work well in non-monotone submodular maximisation. Readers are referred to [37] for the proof of Claim 1.

Claim 1
(Due to [37]) Let ℎ:2→ℝ≥0 be a submodular function, and let S be a random subset of . If each element of S appears with a probability at most p (not necessarily independently), then 𝔼[ℎ(𝑆)]≥(1−𝑝)ℎ(∅).

Algorithm and analysis
This section describes SDTG in Algorithm 1 and analyses its theoretical performance in detail. Note that the proposed algorithm is based on submodular optimisation like in our previous studies [33,34,35]. Hence the analysis shares some essences of logic in our previous works. An equivalent version of Algorithm 1 is introduced as Algorithm 2 to better analyse SDTG.

Algorithm
This work proposes to leverage the sampling strategy [21] and develop a variant of decreasing threshold idea to design a summarisation algorithm. On the one hand, the random sampling at the beginning of SDTG can help the algorithm to avoid getting trapped in local optima. It can also help to accelerate the algorithm because only a small portion of elements from the ground set is considered. On the other hand, the decreasing threshold can further accelerate the algorithm. Note that Greedy [19] needs to reevaluate all the remaining elements to find the best one during each iteration. In contrast, SDTG searches for a relatively good element whose mgv is no less than the current threshold instead of looking for the best one. Therefore, SDTG does not have to reevaluate all remaining elements every time before selecting an extra element.

Some notations from Algorithm 1 are stated in the following:  is the ground set containing all elements.  is the collection of all feasible sets (independent); r is the maximum cardinality of feasible sets in ; p is the sampling probability (uniform distribution); 𝜖 is the threshold decreasing parameter determining the decreasing speed of the threshold; S is the solution set containing the selected elements; R is a set containing the remaining sampled elements; 𝜃 is the decreasing threshold.

The structure of Algorithm 1 consists of two phases. The first phase (lines 1–4) is sampling where elements are randomly selected from the ground set  with probability p to form a sample set R. The probability distribution of sampling is uniform. The second phase (lines 5–22) is selecting where an independent solution set S is selected from R using decreasing threshold greedy. The initial threshold is set as the largest mgv given the empty set and denoted as d (line 5). The terminal threshold is set as 𝜖𝑟𝑑 (line 6). The reason for choosing this value as the termination condition will be given later in the proof part.

figure a
More details of the second phase are given in the following. One loop of the inner “for” loops is named as one iteration. At the beginning of each iteration, SDTG checks independency of 𝑆∪{𝑢}. If it is not independent, then remove element u from R (lines 8–9). Otherwise, calculate the mgv of u and compare it with the current threshold 𝜃. If the mgv of u is greater than or equals to 𝜃, then add u to S and remove it from R (lines 11–13). An element u is named as a qualified element if the mgv of u given S is no less than the current threshold 𝜃. If the mgv of an element is already less than 𝜖𝑟𝑑, it will never become greater or equal to 𝜖𝑟𝑑 in subsequent iterations due to submodularity. Therefore, this element can be removed from R immediately, as stated in lines 15–17. Note that each element in R will be evaluated only for one time under one threshold. If the mgv of an element is between 𝜖𝑟𝑑 and 𝜃, this element will remain in R for the next outer loop where the threshold will decrease. The remaining elements in R will be reevaluated and their updated mgvs will be compared with a decreased new threshold. The threshold keeps decreasing after all remaining elements in R have been evaluated until reaching the termination condition.

Analysis
To better analyse the theoretical approximation performance of Algorithm 1, this work leverages some analysing techniques that were used in [21]. A few auxiliary variables have been introduced to transform SDTG to an equivalent version, i.e., Algorithm 2.

figure b
In Algorithm 2, variables C, 𝑆𝑐, Q, and 𝐾𝑐 are introduced only for the convenience of analysis and have no effect on the final output S. Therefore, Algorithm 2 and Algorithm 1 are equivalent in terms of solution quality. The rules of these variables are as follows.

C is a set that contains all considered elements that have mgvs greater or equal to the threshold 𝜃 in a certain iteration of Algorithm 2 no matter whether they are added into S or not.

𝑆𝑐 is a set that contains the selected elements at the beginning of the current iteration. At the end of this iteration, 𝑆=𝑆𝑐∪{𝑐} if c is added into S and Q, otherwise S equals to 𝑆𝑐.

Q is a set that bridges the relationship between the solution S and the optimal solution OPT. Q starts at OPT at the beginning of the algorithm and changes over time. Note that, Q is introduced only for analysis and there is no need to know the exact value of Q or OPT. In each iteration, the element added into S is also added into Q. At the same time, a set 𝐾𝑐 is removed from Q to keep the independence of Q if an element c is added into Q. Note that, if an element c is already in Q and is considered but not added into S at the current iteration, then this element c should be removed from Q.

𝐾𝑐 is a set that is introduced to keep Q independent and help Q to remove c that is not added to S. According to the property of k-extendible systems, Algorithm 2 is able to remove a set 𝐾𝑐⊆𝑄−𝑆 which contains at most k elements from Q if an element is added into the currently independent set Q. In addition, if c is not added to S and 𝑐∈𝑄 at the beginning of some iteration, then 𝐾𝑐={𝑐}.

The theoretical performance of the proposed algorithm SDTG is summarised in Theorem 1.

Theorem 1
SDTG achieves an approximation guarantee of at least 11+𝑘−𝜖 for maximising monotone submodular functions subject to k-extendible system constraints and of 𝑘(1+𝑘)2−𝜖 for non-monotone cases with computational complexity of 𝑂(𝑛(1+𝑘)𝜖ln𝑟𝜖), where n sis the size of the ground set, r is the largest size of a feasible solution, and 𝜖∈(0,11+𝑘) is the threshold decreasing parameter.

The computational complexity can be easily proved. Assume that there are in total x number of loops in the outer “for” loop of Algorithm 1. Thus,

(1−𝜖)𝑥=𝜖𝑟.
Solving the above equation yields

𝑥=ln𝑟𝜖ln11−𝜖≤1𝜖ln𝑟𝜖.
There are expectantly at most 𝑝⋅𝑛 function evaluations in each outer loop. Therefore, the time complexity of Algorithm 1 is 𝑂(𝑝𝑛𝜖ln𝑟𝜖). ◻

The following part of this section analyses the approximation ratios of SDTG in both monotone and non-monotone cases through Algorithm 2.

Lemma 1
𝑓(𝑆)>11+𝜖𝑓(𝑄).

Proof
According to Algorithm 2, at the end of each iteration, the set Q is independent i.e. 𝑄∈. S is a subset of Q, i.e. 𝑆⊆𝑄, as every element c that is added to S is also in Q. Therefore, 𝑆∪{𝑞}∈ ∀𝑞∈𝑄−𝑆 by the property of independent systems and |𝑄−𝑆|≤𝑟. At the termination of Algorithm 2, Δ𝑓(𝑞|𝑆)<𝜖𝑟𝑑 ∀𝑞∈𝑄−𝑆 and 𝑓(𝑆)≥𝑑. Thus,

∑𝑞∈𝑄−𝑆Δ𝑓(𝑞|𝑆)<∑𝑞∈𝑄−𝑆𝜖𝑟𝑑≤𝜖⋅|𝑄−𝑆|𝑟𝑓(𝑆)≤𝜖⋅𝑓(𝑆).
Let 𝑄−𝑆={𝑞1,𝑞2,…,𝑞|𝑄−𝑆|}, then

𝑓(𝑆)=𝑓(𝑄)−∑𝑖=1|𝑄−𝑆|Δ𝑓(𝑞𝑖|𝑆∪{𝑞1,…,𝑞𝑖−1})≥𝑓(𝑄)−∑𝑖=1|𝑄−𝑆|Δ𝑓(𝑞𝑖|𝑆)>𝑓(𝑄)−𝜖⋅𝑓(𝑆).
(submodularity)
The result is clear by rearranging the above inequality. ◻

Remark 1
Lemma 1 indicates that, at the termination of Algorithm 2, f(S) gets close to f(Q) if 𝜖 is small enough. This means that if the mgv of an element is less than 𝜖𝑟𝑑, then this element can be considered negligible because it has very limited contribution to f(S). This is the reason why the terminal threshold is set as 𝜖𝑟𝑑.

Lemma 2
𝔼[|𝐾𝑢|]≤𝑃𝑟𝑚𝑎𝑥 where 𝑃𝑟𝑚𝑎𝑥=max(𝑝𝑘,1−𝑝).

Proof
There are three cases to analyse, depending on whether the current element u is considered at some point of iteration, i.e. 𝑢∈𝐶, and whether u is already in Q at the beginning of the iteration in Algorithm 2. Note that the size of 𝐾𝑢 is kept as small as possible.

i.
If 𝑢∉𝐶 for whole iterations, 𝐾𝑢=∅ and thus the expectation is obtained as:

𝔼[|𝐾𝑢|]=0.
ii.
If 𝑢∈𝐶 and 𝑢∈𝑄 at the beginning of the iteration, then 𝐾𝑢=∅ for 𝑢∈𝑠 and 𝐾𝑢={𝑢} for 𝑢∉𝑠. Since u is sampled in 𝑠 with probability p, the expectation is obtained as:

𝔼[|𝐾𝑢|]=𝑝⋅|∅|+(1−𝑝)|{𝑢}|=1−𝑝.
iii.
If 𝑢∈𝐶 and 𝑢∉𝑄 at the beginning of the iteration, then 𝐾𝑢 contains at most k elements for 𝑢∈𝑠, and 𝐾𝑢=∅ for 𝑢∉𝑠. According to the property of k-extendible systems, if Q becomes dependent after adding u, then Q can remove at most k elements to remain independence. If Q is still independent after adding u, then 𝐾𝑢=∅. Therefore,

𝔼[|𝐾𝑢|]≤𝑝⋅𝑘+(1−𝑝)|∅|=𝑝𝑘.
In summary, 𝔼[|𝐾𝑢|]≤max(𝑝𝑘,1−𝑝). ◻

Lemma 3
𝔼[𝑓(𝑆)]=∑𝑢∈𝑝𝔼[Δ𝑓(𝑢|𝑆𝑢)].

Proof
Let us define a random variable 𝑢 such that its value is equal to the increase of f(S) when 𝑢∈ is considered, i.e.

𝑓(𝑆)=𝑓(∅)+∑𝑢∈𝑢.
Note that since f is assumed to be normalised, 𝑓(∅)=0. Given the event 𝑢 specifying all the decisions made before considering u, the conditional expectation of 𝑢 is obtained as

𝔼[𝑢|𝑢]=∑𝑢𝑃(𝑢|𝑢)𝑢.
Here, if u is sampled, 𝑢 is equal to Δ𝑓(𝑢|𝑆′𝑢) with the probability of 𝑃(𝑢|𝑢)=𝑝, where 𝑆′𝑢 is defined as 𝑆𝑢 given the event 𝑢. Note that if u is sampled but not in C, Δ𝑓(𝑢|𝑆′𝑢) is defined as 0 by convention. Otherwise if u is not sampled, 𝑢 is zero. Hence, the conditional expectation of 𝑢 is:

𝔼[𝑢|𝑢]=𝑝Δ𝑓(𝑢|𝑆′𝑢)=𝑝𝔼[Δ𝑓(𝑢|𝑆𝑢)|𝑢].
By the law of total expectation, the expectation of 𝑢 is obtained as:

𝔼[𝑢]=𝔼[𝔼[𝑢|𝑢)]]=∑𝑢𝑃(𝑢)𝔼[𝑢|𝑢]=𝑝𝔼[Δ𝑓(𝑢|𝑆𝑢)].
Hence, the expectation of f(S) is obtained as:

𝔼[𝑓(𝑆)]=∑𝑢∈𝑝𝔼[Δ𝑓(𝑢|𝑆𝑢)].
◻

Lemma 4
𝔼[𝑓(𝑆)]>(1−𝜖)𝑝(1−𝜖2)𝑝+𝑃𝑟𝑚𝑎𝑥𝔼[𝑓(𝑆∪𝑂𝑃𝑇)].

Proof
In a certain iteration and given the current threshold 𝜃, if 𝑢∈𝐶 it implies that

Δ𝑓(𝑢|𝑆𝑢)≥𝜃.
(2)
While if an element 𝑞∈𝐾𝑢−𝑆 was not selected before this iteration, then

Δ𝑓(𝑞|𝑆𝑢)<𝜃/(1−𝜖).
(3)
Combining Eqs. (2) and (3) yields

Δ𝑓(𝑢|𝑆𝑢)>(1−𝜖)Δ𝑓(𝑞|𝑆𝑢) ∀𝑞∈𝐾𝑢−𝑆.
(4)
Additionally, any element can be removed from Q at most once. In other words, the element that is contained in 𝐾𝑢 at one iteration is always different from those in other iterations when 𝐾𝑢 is not empty. Therefore, the sets {𝐾𝑢−𝑆}𝑢∈ are disjoint. According to the definition and evolution of Q, Q can be expressed as

𝑄=(𝑂𝑃𝑇−∪𝑢∈𝐾𝑢)∪𝑆=(𝑆∪𝑂𝑃𝑇)−∪𝑢∈(𝐾𝑢−𝑆).
(5)
Denote  as ={𝑢1,𝑢2,⋯,𝑢||}. Then we define 𝑄𝑖𝑢 as

𝑄𝑖𝑢≐(𝑆∪𝑂𝑃𝑇)−∪𝑢∈𝑖(𝐾𝑢−𝑆)
where 𝑖={𝑢1,⋯,𝑢𝑖}. Denote 𝐾𝑢 and 𝑆𝑢 corresponding to 𝑢𝑖 in the i-th iteration as 𝐾𝑖𝑢 and 𝑆𝑖𝑢, respectively. It is clear that 𝑆𝑖𝑢⊆𝑆⊆𝑄𝑖𝑢. Using Eq. (5), one can have

𝑓(𝑄)=𝑓(𝑆∪𝑂𝑃𝑇)−∑𝑖=1||Δ𝑓(𝐾𝑖𝑢−𝑆|𝑄𝑖𝑢)≥𝑓(𝑆∪𝑂𝑃𝑇)−∑𝑖=1||∑𝑞∈𝐾𝑖𝑢−𝑆Δ𝑓(𝑞|𝑆𝑖𝑢)(submodularity)>𝑓(𝑆∪𝑂𝑃𝑇)−∑𝑢∈|𝐾𝑢−𝑆|11−𝜖Δ𝑓(𝑢|𝑆𝑢)(Eq. (4))≥𝑓(𝑆∪𝑂𝑃𝑇)−∑𝑢∈|𝐾𝑢|11−𝜖Δ𝑓(𝑢|𝑆𝑢).
Taking expectation over f(S) yields

𝔼[𝑓(𝑆)]>11+𝜖𝔼[𝑓(𝑄)]>11+𝜖𝔼[𝑓(𝑆∪𝑂𝑃𝑇)]−1(1+𝜖)(1−𝜖)⋅𝔼[|𝐾𝑢|]⋅∑𝑢∈𝔼[Δ𝑓(𝑢|𝑆𝑢)]≥11+𝜖𝔼[𝑓(𝑆∪𝑂𝑃𝑇)]−1(1+𝜖)(1−𝜖)⋅𝑃𝑟𝑚𝑎𝑥⋅∑𝑢∈𝔼[Δ𝑓(𝑢|𝑆𝑢)]=11+𝜖𝔼[𝑓(𝑆∪𝑂𝑃𝑇)]−1(1+𝜖)(1−𝜖)⋅𝑃𝑟𝑚𝑎𝑥𝑝⋅𝔼[𝑓(𝑆)].(Lemma 1)(Lemma2)(Lemma3)
The result is clear by rearranging the above inequality. ◻

Let us finish the proof of Theorem 1 in the following part of this section.

Proof
(Theorem 1) Recall that, p is the sampling probability and 𝑝∈(0,1]. Hence

𝑃𝑟𝑚𝑎𝑥=max(𝑝𝑘,1−𝑝)={1−𝑝𝑝𝑘 for 𝑝∈(0,11+𝑘] for 𝑝∈(11+𝑘,1].
It is necessary to analyse the relationship between 𝑓(𝑆∪𝑂𝑃𝑇) and f(OPT) with monotone and non-monotone submodular objective functions, respectively, to get the approximation guarantees for both cases.

If f is monotone, then 𝑓(𝑆∪𝑂𝑃𝑇)≥𝑓(𝑂𝑃𝑇). According to Lemma 4,

𝔼[𝑓(𝑆)]>(1−𝜖)𝑝(1−𝜖2)𝑝+𝑃𝑟𝑚𝑎𝑥⋅𝔼[𝑓(𝑆∪𝑂𝑃𝑇)]≥(1−𝜖)𝑝(1−𝜖2)𝑝+𝑃𝑟𝑚𝑎𝑥⋅𝑓(𝑂𝑃𝑇).
When 𝑝∈(0,11+𝑘], it holds that

𝔼[𝑓(𝑆)]>(1−𝜖)𝑝(1−𝜖2)𝑝+1−𝑝⋅𝑓(𝑂𝑃𝑇)>(𝑝−𝜖)⋅𝑓(𝑂𝑃𝑇).
When 𝑝∈(11+𝑘,1], it holds that

𝔼[𝑓(𝑆)]>(1−𝜖)𝑝(1−𝜖2)𝑝+𝑝𝑘⋅𝑓(𝑂𝑃𝑇)>(11+𝑘−𝜖)⋅𝑓(𝑂𝑃𝑇).
If f is non-monotone, let us define a new submodular and non-monotone function ℎ:2→ℝ≥0 as ℎ(𝑋)=𝑓(𝑋∪𝑂𝑃𝑇) ∀𝑋⊆. Since S contains each element with probability at most p and according to Claim 1, it is clear that

𝔼[𝑓(𝑆∪𝑂𝑃𝑇)]=𝔼[ℎ(𝑆)]≥(1−𝑝)ℎ(∅)=(1−𝑝)𝑓(𝑂𝑃𝑇).
(6)
Combining Eq. (6) with Lemma 4 yields

𝔼[𝑓(𝑆)]>(1−𝜖)𝑝(1−𝜖2)𝑝+𝑃𝑟𝑚𝑎𝑥⋅𝔼[𝑓(𝑆∪𝑂𝑃𝑇)]≥(1−𝜖)𝑝(1−𝑝)(1−𝜖2)𝑝+𝑃𝑟𝑚𝑎𝑥⋅𝑓(𝑂𝑃𝑇).
When 𝑝∈(0,11+𝑘], it holds that

𝔼[𝑓(𝑆)]>(1−𝜖)𝑝(1−𝑝)(1−𝜖2)𝑝+1−𝑝⋅𝑓(𝑂𝑃𝑇)>[𝑝(1−𝑝)−𝜖]⋅𝑓(𝑂𝑃𝑇).
When 𝑝∈(11+𝑘,1], it holds that

𝔼[𝑓(𝑆)]>(1−𝜖)𝑝(1−𝑝)(1−𝜖2)𝑝+𝑝𝑘⋅𝑓(𝑂𝑃𝑇)>(11+𝑘−𝜖)(1−𝑝)⋅𝑓(𝑂𝑃𝑇).
In summary, if f is monotone, the expected approximation ratios are

𝔼[𝑓(𝑆)]>{(𝑝−𝜖)⋅𝑓(𝑂𝑃𝑇)(11+𝑘−𝜖)⋅𝑓(𝑂𝑃𝑇) for 𝑝∈(0,11+𝑘] for 𝑝∈(11+𝑘,1].
(7)
If f is non-monotone, the expected approximation ratios are

𝔼[𝑓(𝑆)]>{[𝑝(1−𝑝)−𝜖]⋅𝑓(𝑂𝑃𝑇)(11+𝑘−𝜖)(1−𝑝)⋅𝑓(𝑂𝑃𝑇) for 𝑝∈(0,11+𝑘] for 𝑝∈(11+𝑘,1].
(8)
Eqs. (7) and (8) show that, for 𝑝∈(11+𝑘,1], the expected approximation ratio becomes stagnated in the monotone case and decreasing in the non-monotone case. Moreover, the computational complexity increases as the sampling probability gets larger. On the other side, for 𝑝∈(0,11+𝑘], the sampling probability provides adjustment capability for the trade-off between the approximation ratio and computational complexity. As the probability increases for 𝑝∈(0,11+𝑘], the expected approximation ratios improve for both monotone and non-monotone cases, but the computational complexity also increases.

Recall that the theoretical time complexity is 𝑂(𝑝𝑛𝜖ln𝑟𝜖). The impact of 𝜖 on the solution quality and time complexity is more desirable than that of p. Therefore, this work fixes the sampling probability as 𝑝=11+𝑘 and leave 𝜖 as an adjustable designing parameter for the trade-off of solution quality versus time complexity. According to Eqs. (7) and (8), the best expected approximation ratios can be readily obtained, when 𝑝=11+𝑘, as:

𝔼[𝑓(𝑆)]>{(11+𝑘−𝜖)⋅𝑓(𝑂𝑃𝑇)[𝑘(1+𝑘)2−𝜖]⋅𝑓(𝑂𝑃𝑇) if𝑓 is  monotone  if𝑓 is  non-monotone .
◻

Experiments
This section testifies the proposed algorithm SDTG through experiments using a real database and compares its performance with that of Greedy [19] and Sample [21]. For a fair comparison, this section uses the basic versions of these algorithms without integrating the Lazy strategy [38]. Note that the performance of Sample and FANTOM [5] has already been compared in [21].

Experimental setup
The database used in the experiments is MovieLens 20M [23]. This database contains 20 million ratings and 465,000 tag applications applied to 27,000 movies by 138,000 users. Movies in the database are classified into 19 genres, such as Action, Comedy, Drama, etc. Besides, each movie is also scored according to the relevance with 1128 genome tags forming 12 million relevance scores in total.

The objective of the movie recommendation system in the experiments is to select a shortlist of movies that are representative yet diverse for users based on their favourite movie genres. The objective function is introduced from [5, 21]. Let  be the set of all movies and G be the set of all movie genres. Denote (𝑔) as the set of all movies that belong to the movie genre 𝑔∈𝐺. Denote G(i) as the set of genres that the movie i belongs to. Note that one movie can belong to different genres, hence |𝐺(𝑖)|≥1. Let 𝑠𝑖𝑗 represent the similarity between movie i and movie j. Denote 𝐺𝜇 as the set of all movie genres that the user 𝜇 likes, 𝐺𝜇⊆𝐺. The movies that can be considered by the user 𝜇 is contained in the set 𝜇=∪𝑔∈𝐺𝜇(𝑔). The objective function of movie recommendation for user 𝜇 is given by

𝑓𝜇(𝑆)=∑𝑖∈𝑆∑𝑗∈𝜇𝑠𝑖𝑗−𝜆∑𝑖∈𝑆∑𝑗∈𝑆𝑠𝑖𝑗
(9)
where 𝜆∈[0,1] is the penalty parameter for the similarity between movies within the recommendation list S. The objective function Eq. (9) is non-negative, non-monotone, and submodular. The first term of Eq. (9) reflects the representativeness of the selected movies, and the second term helps to increase diversity. It is desired to achieve high objective function value with low computational complexity.

The similarity value between movie i and movie j can be calculated based on the Euclidean distance of relevance scores

𝑠𝑖𝑗=1∑𝑡=1𝑁𝑡(𝛾𝑖𝑡−𝛾𝑗𝑡)2‾‾‾‾‾‾‾‾‾‾‾‾√
where 𝑁𝑡=1128 is the number of all genome tags, 𝛾𝑖𝑡 and 𝛾𝑗𝑡 are the relevance scores in terms of the tag t for movie i and movie j, respectively. The calculation of the similarity map took around 35 days on Cranfield HPC—Delta,Footnote1 using 128 CPUs with parallel computing.

The constraints of the movie recommendation system come from the upper limits of the number of movies in total and in each movie genre. The first constraint is an upper limit m on the total number of movies in the movie recommendation list for the user. The second one is an upper limit 𝑚𝑔 (named as a genre limit) on the number of movies that belong to the movie genre g. According to [21], the movie recommendation system is subject to a |𝐺𝜇|-extendible system constraint.

In the experiments, suppose that the user’s favourite movie genres are Action, Adventure, and Sci-Fi. Then, the constraint of the movie recommendation system is a 3-extendible system constraint. Movies with ids less than 30,000 are within consideration since not all movies have genome scores in the database. Set the upper limit on the total number of movies as 𝑚=15, and the genre limit as varying numbers from 1 to 6. Set the sampling probability for Sample and SDTG as 𝑝=0.25, and the threshold decreasing parameter for SDTG as 𝜖=0.2. Set the penalty parameter as 𝜆=0.8. Denoted Max Sample (4) and Max SDTG (4) as the best selections from 4 rounds of Sample and SDTG, respectively. The results of Sample and SDTG are based on 100 rounds of these two algorithms. The running time for these algorithms is measured as the number of objective function evaluations which is independent on the computer conditions. Note that, the experimental results for Sample and SDTG vary somehow each time as the algorithms are related to random sampling.

Results
The performance of SDTG is compared with that of benchmark algorithms in terms of both function values and running time in Fig. 1. It is clear from Fig. 1a that, on average, Sample and SDTG related algorithms outperform Greedy in terms of solution quality. The quality of solutions provided by SDTG is better than that of Sample, although SDTG has a slightly worse theoretical approximation guarantee than Sample does. Overall, Max SDTG (4) achieves the highest function value. Figure 1b shows the number of function evaluations consumed by different algorithms. Four rounds of Sample requires the largest number of function evaluations when 𝑚𝑔≥2. Relatively, Greedy requires a bit fewer function evaluations than Max Sample (4) does. But four rounds of SDTG requires significantly fewer evaluations. Overall, Greedy and Sample-related algorithms consume increasing numbers of function evaluations as 𝑚𝑔 goes up. However, the numbers of function evaluations of the SDTG-related algorithms almost stay constant when 𝑚𝑔≥2. When 𝑚𝑔=6, four rounds of SDTG is even faster than one round of Sample.

Fig. 1
figure 1
Performance comparison of different algorithms

Full size image
Figure 1c, d illustrate the distribution of function value and running time for 100 rounds of Sample and SDTG algorithms. Recall that, Max Sample (4) and Max SDTG (4) represent the maximum values achieved by four rounds of Sample and SDTG, respectively. And Greedy is a deterministic algorithm. Therefore, these three items do not appear in Fig. 1c, d that are for demonstrating the distribution resulted from random sampling. Overall, the function value distribution of SDTG has similar spreads with Sample’s, but SDTG achieves higher median values than Sample does. In terms of running time, SDTG has significantly smaller spreads and lower median values than Sample does. The comparison between Sample and SDTG indicates that SDTG not only achieves better function values but also is faster and more reliable.

Figure 1e, f demonstrate the ratio comparison of the solution quality and running time of different algorithms. The performance of Max Sample (4) is set as a baseline for other algorithms in comparison. When 𝑚𝑔=2, Max SDTG (4) achieves a significantly better function value but consumes fewer function evaluations than Max Sample (4) does. While 𝑚𝑔=5, Max SDTG (4) achieves a much better function value (38.4% higher) and consumes a dramatically smaller number of function evaluations (76.1% fewer). On average, SDTG finds better solutions but only consumes 6.1% of function evaluations compared with Max Sample (4). In both cases, Greedy is the least competitive one among all algorithms because it achieves the worst function values and requires the second largest number of function evaluations. SDTG provides high-quality solutions yet consumes the fewest function evaluations, which is of great advantage when handling large-scale datasets.

Discussion
The reason why Greedy performs poorly in terms of solution quality is that it greedily selects the best element during each iteration heading to bad local optima. On the other side, with the help of the sampling process, Sample and SDTG related algorithms are able to avoid those elements that can get the algorithms trapped in bad local optima. The threshold in SDTG can further help the algorithm to avoid those local optima. This is why SDTG practically outperforms Sample in terms of solution quality. Table 1 explains the reason in detail. According to the definition of the genre limit constraint, at most two movies can be selected from each genre of Adventure, Action, and Sci-Fi when 𝑚𝑔=2. The maximum number of movies without violating the aforementioned constraint is six. Greedy only recommends three movies and reaches the upper genre limit. However, Max Sample (4) and Max SDTG (4) are able to recommend five and six movies, respectively, which better fit the objective of the movie recommendation system.

Table 1 Movies recommended by different algorithms, 𝑚𝑔=2
Full size table
The reason why Greedy performs poorly in terms of running time is that it has to calculate the mgvs of all remaining elements given the current selection to find the best one. Sample is faster than Greedy because it only considers a small portion of the ground set, although it also needs to evaluate all remaining elements in the sample set. Different from Sample, SDTG can stop evaluating once it finds one qualified element and adds this element to the selection set immediately. This means that SDTG does not have to evaluate all the remaining elements in the sample set in order to select an extra element. Therefore, SDTG consumes fewer function evaluations than Sample does on average. In addition, the running time of Sample is highly dependent on the size of the sample set because it needs to evaluate all elements in the sample set. In contrast, SDTG can usually find a qualified element from the front positions of the sample set and stop evaluating. Therefore, the running time of SDTG is less related to the size of the sample set compared with Sample’s. This is the reason why the spread of running time distribution of SDTG is smaller than Sample’s.

Trade-off of solution quality vs. running time
This section also examines the impact of the threshold parameter 𝜖 on solution quality and running time. This will help us to choose a desirable value of 𝜖 and to have a deeper comprehension of SDTG. The value of 𝜖 varies from 0.04 to 0.24 with a step of 0.04. Two cases are checked where 𝑚𝑔 equals to 2 and 5, respectively. Other settings are as same as previous ones. We run 100 rounds of SDTG and record the function values and the number of function evaluations in each round.

Figure 2 demonstrates the experimental results with varying values of the threshold decreasing parameter. The distributions of function value and running time are illustrated in Fig. 2a, b, respectively. Figure 2a shows that the impact of changing 𝜖 on function values is not significant. Function values fluctuate slightly when 𝜖≥0.08. However, the solution quality for both 𝑚𝑔=2 and 𝑚𝑔=5 is obviously worse when 𝜖 equals to 0.04 than that with larger values of 𝜖. This is because the threshold decreases very slowly with an extremely small 𝜖. In this case, the mgv of the element selected by SDTG in each iteration is very close to the largest one. As mentioned before, the decreasing threshold can also help SDTG to avoid local optima. An extremely small 𝜖 makes SDTG close to Sample, which weakens the advantage of the decreasing threshold. Figure 2b shows that the median values of running time decrease obviously as 𝜖 increases. The spreads of running time also become smaller as 𝜖 goes up. The reason is that the threshold decreases faster with a larger 𝜖. When evaluating the mgvs of the remaining elements one by one, SDTG can find a qualified element more quickly with a smaller threshold. The running time of SDTG also becomes less dependent on the size of the sample set.

Fig. 2
figure 2
The effect of 𝜖 on function value and running time

Full size image
Conclusions
This paper has presented an efficient algorithm, Sample Decreasing Threshold Greedy (SDTG), to deal with big data summarisation problems. The proposed algorithm achieves an expected approximation ratio of 𝑘(1+𝑘)2−𝜖 for maximising general non-monotone submodular objective functions subject to k-extendible system constraints with only 𝑂(𝑛(1+𝑘)𝜖ln𝑟𝜖) value oracle calls. The performance of SDTG is testified and compared with that of benchmark algorithms through experiments with a movie recommendation system based on a widely-used movie information database. The experimental results indicate that the proposed algorithm has great application potentials in large-scale discrete optimisation problems where the sizes of datasets are enormous such as the applications of machine learning and big data science. We believe that our results are also instrumental for the personalised recommendation systems on internet platforms, like Netflix, YouTube, and Amazon, etc. SDTG can be further accelerated by adapting the Lazy Greedy strategy [38]. A future research direction could also be accelerating the proposed algorithm by combining distributed computing.

Abbreviations
SDTG:
Sample decreasing threshold greedy

mgv :
Marginal gain value

OPT:
Optimal solution

Max Sample (4):
Run 4 rounds of Sample and get the maximum function value

Max SDTG (4):
Run 4 rounds of SDTG and get the maximum function value

