Nowadays a large amount of data is originated by complex systems, such as social networks, transportation systems, computer and service networks. These systems can be modeled by using graphs and studied by exploiting graph metrics, such as betweenness centrality (BC), a popular metric to analyze node centrality of graphs. In spite of its great potential, this metric requires long computation time, especially for large graphs. In this paper, we present a very fast algorithm to compute BC of undirected graphs by exploiting clustering. The algorithm leverages structural properties of graphs to find classes of equivalent nodes: by selecting one representative node for each class, we are able to compute BC by significantly reducing the number of single-source shortest path explorations adopted by Brandes‚Äô algorithm. We formally prove the graph properties that we exploit to define the algorithm and present an implementation based on Scala for both sequential and parallel map-reduce executions. The experimental evaluation of both versions, conducted with synthetic and real graphs, reveals that our solution largely outperforms Brandes‚Äô algorithm and significantly improves known heuristics.

Introduction
The massive amount of data available today in many domains is often originated by complex systems that can be modeled as graphs (e.g., social networks, transportation networks, computer networks, service networks, etc.) where network centrality is exploited for identifying important nodes (or edges) of the modeled systems.

Among centrality metrics, betweenness centrality (BC) [1] is receiving an increasing interest. Its popularity is due to the potential in identifying critical nodes (or edges) since this metric measures the extent to which a node (or edge) sustains the information flow between any other pair of nodes in the network.

BC is widely used, with both directed and undirected graphs, to identify opinion leaders or influential people in social network analysis [2], critical intersections in transportation networks [3,4,5,6,7], vulnerabilities in computer networks [8], threats from terrorist networks [9]. However, in spite of the great potential, the computation time of BC often represents a barrier to the application of this metric in large-scale contexts, especially with dynamic graphs.

In recent years, the Floyd method [10], which requires ùëÇ(ùëõ3) computation time, has been overcome by the well known Brandes‚Äô algorithm [11]. Given a graph G(V, E), it exhibits ùëÇ(ùëõ+ùëö) space complexity, O(nm) time complexity for unweighted graphs and ùëÇ(ùëõùëö+ùëõ2ùëôùëúùëî(ùëõ)) for weighted ones, where ùëõ=|ùëâ| is the number of nodes and ùëö=|ùê∏| the number of edges. However, the polynomial complexity of Brandes‚Äô algorithm, which is almost quadratic for very sparse graphs, is still an obstacle for analyzing very large networks. Such problem becomes even more evident and limiting if centrality is used for real-time analysis of dynamic networks.

In the last decade, many researchers have therefore worked with the aim of improving the performance of Brandes‚Äô algorithm.

In this paper, we propose an algorithm based on clustering, inspired by previous work on approximated BC computation [6, 12], which makes possible the exact computation of BC on large, undirected graphs with an impressive speedup when compared to Brandes‚Äô algorithm and a significant improvement over recent variants of Brandes‚Äô algorithm based on clustering [13].

The algorithm leverages structural properties of graphs to find classes of equivalent nodes: by selecting one representative node for each class, we are able to compute BC by significantly reducing the number of single-source shortest path explorations required by Brandes‚Äô algorithm. We formally prove the graph properties that we exploit to define and implement two versions of the algorithm based on Scala for both sequential and parallel map-reduce executions. The experimental analysis has been conducted by testing both versions of the algorithm on synthetic and real-world graphs. The algorithm we propose is able to work with undirected, weighted or unweighted graphs. In this paper, we focus on unweighted graphs while its extension to weighted ones can be easily obtained by substituting the breadth-first search (BFS) with Dijkstra algorithm.

Undirected graphs are very common in real-world systems; examples are social networks, communication networks, protein interactions graphs, people interaction graphs, finite element meshes, etc. Among these graphs, scale-free and Barab√°si-Albert graphs [14] represent an important target of our analysis, since they model many real-world systems, such as the World Wide Web, the Internet and other computer networks, citation networks, social networks, airline networks, financial networks, etc.

The main contributions of the paper are:

Introduction of the general concept of equivalence class for reducing BC computation time.

Formal proof about the existence of topological properties to identify an equivalence class with respect to clusters‚Äô border nodes in undirected graphs.

Two variants of Brandes‚Äô back propagation technique to avoid the direct computation of the dependency score on cluster nodes due to pivots.

Scala-based implementations of the proposed algorithm for both sequential and parallel map-reduce executions.

Extensive evaluation of the proposed algorithm with both synthetic and real large-scale graphs.

The rest of the paper is organized as follows. "Related work" section positions the paper with reference to the main results from the literature. "Background" section introduces the notation we use in the rest of the paper, as well as the background concepts and algorithms that are at the basis of the proposed solution. "Clustering and BC computation" section presents the main properties we exploit to define the algorithm when clustering is used to identify classes of equivalent nodes. "E1C-FastBC algorithm" section illustrates the rationale of the specific implementation of the algorithm and the main steps that characterize it, by presenting also the constituent sub-algorithms exploited for the implementation. "Experimental evaluation" section reports on the experimental results obtained by running the proposed algorithm on several synthetic and real graphs characterized by different sizes and topological properties. "Mathematical foundations" section is dedicated to the formal proofs of the theorem and claims used in our algorithm for fast BC computation. Finally, "Conclusion" summarizes the results and discusses the limits of the proposed solution by highlighting possible future improvements.

Related work
Brandes‚Äô algorithm is a fast and robust solution to compute BC, but it is not adequate for real-time processing of large graphs, since BC computation time increases very rapidly with the graph size, even in sparsely-connected configurations.

Several approaches, either exact or approximated, have been developed to reduce BC computation time by improving Brandes‚Äô algorithm. The proposed solutions can be classified into five main categories: (a) exploiting and increasing parallelism; (b) updating the BC of specific nodes in dynamically evolving graphs; (c) estimating BC via a partial exploration of the graph in terms of nodes or edges; (d) exploiting structural properties of some kinds of graphs to compress them; (e) reducing complexity by decomposing graphs in clusters. It is worth noting that some proposals may belong to multiple categories since in many cases, techniques falling in a category can be complemented with other ones to further reducing computation time.

Exploiting parallelism Brandes‚Äô algorithm is extremely parallelizable due to the possibility of performing n independent breadth first searches (BFS) or Dijkstra explorations on a shared graph structure. In [15], an efficient parallel implementation of BC computation is provided. The solution leverages fine-grained multi-level parallelism by concurrently traversing the neighbors of a given node via a shared data structure with granular locking in order to increase concurrency. The improved version of the previous approach, proposed in [16], removes the need for locking in the dependency accumulation stage of Brandes‚Äô algorithm through the adoption of a successor list instead of a predecessor list for each node. In [17], the authors propose a MPI-based parallel implementation of the adaptive sampling algorithm KADABRA [18]. Other efforts in this direction try to exploit the large amount of cores available on GPUs to better exploit parallelism [19].

Incremental computation These (stream-based) approaches try to avoid recomputing the BC values of all the nodes of a graph when they are known for a previous configuration, by performing computation over only a small portion of the graph that is impacted by some changes. Recently, an efficient algorithm for streamed BC computation [20] of evolving graphs has been proposed based on edges addition or removal. However, the algorithm is efficient only when the new graph changes in only one edge if compared with the old one. Continuous BC processing of large graphs to handle streamed changes of a significant number of edges is therefore inefficient. MR-IBC [21] is a MapReduce-based incremental algorithm for BC computation in large-scale dynamic networks that supports edge addition or removal. The paper exploits distributed computing to achieve scalability and reduce computing time. Even in this case, the focus is on changes related to one single edge. The solution proposed in [22], instead, handles batches of updates in parallel. In particular, it exploits a bi-connected component decomposition technique along with some structural properties to improve performance.

Approximated computation These algorithms aim at achieving low computation time by calculating approximated BC values. Brandes and Pich proposed in [23] an approximated algorithm for faster BC calculation by choosing only ùëò‚â™ùëõ nodes, called pivots, as sources for the single-source shortest path (SSSP) algorithm through different strategies, showing that random selection of pivots can achieve accuracy levels comparable to other heuristics. The approach has been further improved by other authors [24]. The goal of these algorithms is to calculate the BC only for selected nodes called pivot nodes. The selection of these nodes depends on the problem to solve and may limit the use of BC.

KADABRA [18] is an adaptive sampling algorithm to approximate betweenness centrality. In particular, it adopts a probabilistic approach: BC of a node v is seen as the probability that, given two randomly selected nodes s and t and a randomly selected shortest path p between them, v belongs to p. The algorithm allows to specify the maximum absolute error and the probability that error is guaranteed.

A similar approach is followed in ABRA [25], a suite of algorithms to compute high-quality approximations of the betweenness centrality of all nodes (or edges) of both static and fully dynamic graphs by using progressive random sampling.

Topology manipulation. Some algorithms exploit topological properties of graphs to accelerate BC computation. Puzis et al. in [26] propose two heuristics to simplify BC computation: (a) identification of structural equivalent nodes, i.e., nodes that have the same centrality index and contribute equally to the centrality of other nodes; (b) partitioning a large graph in smaller bi-connected sub-graphs. Computation time on the graph partitions is significantly lower due to the quadratic to cubic complexity of Brandes‚Äô algorithm. The authors also combine the two techniques to improve the speedup when compared with Brandes‚Äô algorithm. In [27], the authors use both compression and splitting techniques, including the ones developed in [26], to reduce the size of the input graph and its largest connected component since these are the main parameters that affects the computation time. In particular, they split the input graph by using bridges and articulation vertices and compress it by removing degree-1, identical and side vertices. Bridges and articulation vertices are edges and nodes, respectively, whose removal from a graph leads to a new graph with a greater number of connected components; degree-1 vertices are leaf nodes which, considered as source and targets, contribute equally to the computation of BC of crossed nodes; identical vertices are the ones characterized by the same neighbors and, consequently, by the same BC values; side vertices are nodes such that the graphs induced by their neighbors are cliques and they are not crossed by shortest paths. By using all these techniques, the authors achieve significant speedup with different kinds of graphs. The authors in [28] propose a variant of Brandes‚Äô algorithm based on topological characteristics of social networks where nodes belonging to particular tree structures are not considered for Brandes‚Äô SSSP explorations; their contribution is simply computed by counting. Topology manipulation and graph compression are very useful techniques with some types of graphs and are complementary to other solutions from the literature, including the one proposed in this paper.

Reducing complexity by decomposing graphs in clusters A way to compute BC is to cluster a large graph into smaller sub-graphs, calculate the BC inside these small graphs, and then compute the BC on the remaining part of the graph. A first paper based on this approach was proposed in [12]. This technique exploits a fast clustering method [29] to identify clusters inside a graph. The border nodes of the clusters are then used as reference nodes to discover, for each cluster, classes of nodes that contribute the same way to the dependency score of the nodes outside the clusters. For each class, a pivot node is selected as representative node for the computation of the dependency scores from the class nodes to the other graph nodes by exploiting the well-known SSSP exploration of the graph. Hence, the dependency score is multiplied by the cardinality of the class the source node belongs to and summed up to the local contribution of BC, computed by considering only nodes belonging to the clusters, to obtain the final approximated values of BC. This technique can be also classified among the ones based on pivots, typically used for computing approximated BC values, even if the strategy adopted to identify pivots is based on clustering. The authors in [13] propose a technique based on clustering to reduce the complexity of BC computation. They prove that with a decomposition of graphs into hierarchical sub networks (HSNs), time complexity can be reduced to ùëÇ(ùëõ2) for unweighted graphs under the hypotheis that the number of clusters ùëê‚â´ùëò/2. In that case, the speedup, compared with Brandes‚Äô algorithm, is in the order of one half of the graph‚Äôs average degree k, since the number of edges ùëö=ùëò‚ãÖùëõ/2. This means that if the considered graph has a number of edges ùëö‚àºùëõ, then ùëò‚àº2 and the speedup is 1, that is, the algorithm is not able to improve Brandes‚Äô algorithm.

A very similar solution has been proposed in [30]. Differently from [13], the authors propose to build a simplified hierarchical representation of the graph after clustering (named Skeleton) by substituting each cluster with a weighted clique connecting the cluster border nodes. This way, they reduce the number of nodes in the Skeleton but need the more computationally expensive Dijkstra algorithm for computing the shortest paths over the weighted graph. Moreover, the proposed solution computes exact BC values of nodes only with respect to a subset of nodes of a graph, named target set. When the target set includes all the nodes of a given graph, the solution converges towards Brandes‚Äô algorithm, but with the additional overhead due to the creation and exploitation of the skeleton graph.

Very recently, a Graph Neural Network (GNN) based model to approximate betweenness and closeness centrality has been proposed [31]. This work, among other similar ones [32], demonstrates that the efficient computation of the BC is a topic of great interest even in the field of deep learning and, particularly, graph neural networks.

In this paper, we propose a technique to reduce the time needed for computing exact values of BC in undirected graphs by: (i) computing BC as the sum of two main contributions, local for each cluster and global among clusters (category e), (ii) reducing the SSSP explorations for the global phase through the identification of pivot nodes (category c), and (iii) considering HSN-based corrections on local contributions and the properties of undirected graphs to completely remove errors during computation (which affected the first proposal in [12]). This paper extends our previous proposal in [33], by significantly improving the algorithm and its implementations that now have been tested also with real graphs. Moreover, we formally prove the correctness of the proposed technique.

It is worth noting that our algorithm could be complemented by algorithms from different aforementioned categories, such as finer-grained parallelism from the first category or compression-based techniques exploiting graphs topological properties as the ones falling within the second category. Conversely, incremental and approximated computations are approaches for specific classes of applications that regard slowly changing graphs or rank-based exploitation of BC, respectively, which we consider out of the scope of this paper.

Background
In this section, we first introduce the notation used throughout the paper, then we briefly describe Brandes‚Äô algorithm. Finally, we present the concept of equivalence class, which constitutes the basis of our algorithm.

Let ùêÜ(ùêï,ùêÑ) be an undirected unweighted graph with ùêï representing the set of n vertices (or nodes) and ùêÑ the set of m edges (or links). Let ùë†,ùë°‚ààùêï be two generic nodes of ùêÜ. We denote by ùëíùë†,ùë° the edge connecting s and t. The neighbors of a vertex s are all vertices u such that ùëíùë†,ùë¢‚ààùêÑ. The distance between s and t, denoted by ùëëùêÜ(ùë†,ùë°), is the length of the shortest path(s) connecting them in ùêÜ. The number of shortest paths between s and t is denoted by ùúéùë†,ùë°, whereas the number of shortest paths between s and t that cross a generic node ùë£‚ààùêï is denoted by ùúéùë†,ùë°(ùë£). It is worth noting that since the graph is undirected, ùëëùêÜ and ùúé are symmetric functions, thus ùëëùêÜ(ùë†,ùë°)=ùëëùêÜ(ùë°,ùë†),  ùúéùë†,ùë°=ùúéùë°,ùë† and ùúéùë†,ùë°(ùë£)=ùúéùë°,ùë†(ùë£). Given a generic node ùë§‚ààùêï,  ùêèùë†(ùë§)={ùë¢‚ààùêï:ùëíùë¢,ùë§‚ààùêÑ,ùëëùêÜ(ùë†,ùë§)=ùëëùêÜ(ùë†,ùë¢)+1} is the set of direct predecessors of vertex w on shortest paths from s.

The betweenness centrality (BC) of a vertex ùë£‚ààùêï is defined as follows:

ùêµùê∂(ùë£)=‚àëùë†‚â†ùë£‚â†ùë°‚ààùêïùúéùë†,ùë°(ùë£)ùúéùë†,ùë°
(1)
BC(v) thus represents the fraction of shortest paths containing v among all the shortest paths in the graph between any generic pair of nodes s and t, summed over all possible pairs s and t with ùë†‚â†ùë£,  ùë†‚â†ùë° and ùë£‚â†ùë°.

We refer to Table 1 for a summary of the notation used in the paper.

Table 1 Notation
Full size table
Brandes‚Äô algorithm
Brandes‚Äô algorithm is the fastest known general-purpose sequential algorithm for computing BC. It is based on the notions of pair-dependency and dependency score. Let us consider two generic nodes ùë†,ùë°‚ààùêï. Given shortest paths counts ùúéùë†,ùë°(ùë£) and ùúéùë†,ùë°, the pair-dependency ùõøùë†,ùë°(ùë£) of a pair s, t on an intermediary node ùë£‚ààùêï is defined as follows:

ùõøùë†,ùë°(ùë£)=ùúéùë†,ùë°(ùë£)ùúéùë†,ùë°
(2)
The pair-dependency represents the fraction of shortest paths between s and t crossing v. The dependency score ùõøùë†,‚ãÖ(ùë£) of a vertex s on a vertex ùë£‚ààùêï is then defined as follows:

ùõøùë†,‚ãÖ(ùë£)=‚àëùë°‚ààùêïùõøùë†,ùë°(ùë£)
(3)
BC can thus be redefined in terms of dependency score:

ùêµùê∂(ùë£)=‚àëùë†‚â†ùë£‚â†ùë°‚ààùêïùúéùë†,ùë°(ùë£)ùúéùë†,ùë°=‚àëùë†‚â†ùë£‚â†ùë°‚ààùêïùõøùë†,ùë°(ùë£)=‚àëùë†‚ààùêïùõøùë†,‚ãÖ(ùë£)
(4)
The key observation of Brandes‚Äô algorithm is that the dependency score obeys a recursive formula. In particular, for each ùë†‚ààùêï we have:

ùõøùë†,‚ãÖ(ùë£)=‚àëùë§:ùë£‚ààùêèùë†(ùë§)ùúéùë†,ùë£ùúéùë†,ùë§‚ãÖ(1+ùõøùë†,‚ãÖ(ùë§))
(5)
Brandes‚Äô algorithm runs in two phases, exploiting equation 5. For each (source) node ùë†‚ààùêï, in the first phase, a single-source shortest-paths (SSSP) algorithm, based on breadth-first search (BFS), is executed on ùêÜ to find all the shortest paths rooted in s. In the second phase, dependency scores are accumulated by backtracking along the discovered shortest paths using the recursive relation in Eq. 5. In backtracking, nodes are visited in descending order of distance from the source. During these two phases, for each node ùë£‚ààùêï the algorithm builds and exploits the following data structures: the set of direct predecessors ùêèùë†ùêèùë†(ùë£) on shortest paths from the source, the distance ùëëùêÜ(ùë†,ùë£) from the source, the number of shortest paths ùúéùë†,ùë£ from the source and the dependency score ùõøùë†,‚ãÖ(ùë£) that accumulates the contribution of the source on node v due to all destinations during the back-propagation step.

Equivalence class
To reduce the number of explorations and thus lower the BC computation time, we exploit the concept of equivalence class. Formally, given a connected sub-graph ùêÜÃÇ  of ùêÜ induced by the set of nodes ùêïùêÜÃÇ ‚äÇùêï, we define an equivalence class ùêäùëñ as any subset of nodes in ùêïùêÜÃÇ  that produce the same dependency score on all nodes‚Äîand for destinations‚Äîoutside sub-graph ùêÜÃÇ  when used as sources for SSSP explorations.

By choosing only one representative node (called pivot) for each class, the correct dependency scores of nodes can be computed by multiplying the scores computed via the SSSP rooted in the pivot by the cardinality of the class, i.e., let ùëòùëñ be a pivot of ùêäùëñ and ùë£‚àâùêïùêÜÃÇ , a node outside sub-graph ùêÜÃÇ , we have:

‚àëùë†‚ààùêäùëñ‚àëùë°‚àâùêïùêÜÃÇ ùõøùë†,ùë°(ùë£)=|ùêäùëñ|‚ãÖ‚àëùë°‚àâùêïùêÜÃÇ ùõøùëòùëñ,ùë°(ùë£)
which, according to our notation, can be re-written as:

‚àëùë†‚ààùêäùëñùõøùë†,ùêïùêÜÃÇ ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£)=|ùêäùëñ|‚ãÖùõøùëòùëñ,ùêïùêÜÃÇ ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£)
(6)
Equation 6 clearly shows that a low number of classes significantly reduces the computation time, by allowing to skip a high number of SSSP explorations.

Clustering and BC computation
A possible technique to identify equivalence classes is to consider reference nodes. Given a generic sub-graph ùêÜÃÇ , the reference nodes in ùêïùêÜÃÇ  are those that need to be traversed to reach, via shortest paths from nodes in ùêïùêÜÃÇ , any other node in ùêïùêÜÃÇ ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ.

In this paper, to easily identify reference nodes, we use clustering, and to increase the chances of identifying a low number of equivalence classes, we consider a clustering technique based on modularity, which allows reducing the amount of connections among groups of nodes belonging to different clusters, and, consequently, lowers the number of reference nodes to be considered for discovering equivalence classes.

The proposed approach relies on a set of mathematical properties that, for the sake of readability, are introduced and used in the following subsections, but proved in section  "Mathematical foundations", at the end of the paper.

Equivalence class with clustering
Let us assume a given graph ùêÜ is split into a set of clusters ùêÇ, where a single cluster ùêÇùëñ is a connected sub-graph of ùêÜ induced by a set of nodes ùêïùêÇùëñ‚äÇùêï.

For each cluster ùêÇùëñ‚ààùêÇ, it is possible to identify a set of border nodes ùêÅùêçùêÇùëñ. A border node ùëèùëñ‚ààùêÅùêçùêÇùëñ is a node belonging to ùêÇùëñ and having at least one neighbor belonging to another cluster, as graphically presented in Fig. 1 (circled nodes are border nodes).

Fig. 1
figure 1
Example of clustering

Full size image
To discover equivalence classes, for each cluster ùêÇùëñ, we group nodes based on their distance and number of shortest paths to the border nodes. To this end, we can leverage the following theorem (see "Mathematical foundations" section, Theorem 6.1, for formal proof).

Let ùëò‚àà‚Ñù+ and ùëô‚àà‚Ñù, let ùêÇùëñ be a generic cluster of graph ùêÜ with border nodes ùêÅùêçùêÇùëñ, and ùë†,ùëù‚ààùêïùêÇùëñ. If  ‚àÄ ùëèùëó‚ààùêÅùêçùêÇùëñ ùúéùë†,ùëèùëó=ùëò‚ãÖùúéùëù,ùëèùëó and ùëëùêÜ(ùë†,ùëèùëó)=ùëëùêÜ(ùëù,ùëèùëó)+ùëô, then  ùõøùë†,ùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£)=ùõøùëù,ùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£),  ‚àÄùë£‚ààùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ.

In other words, any given pair of nodes ùë†, ùëù belonging to the sub-graph induced by nodes in cluster ùêÇùëñ (i.e., ùë†,ùëù‚ààùêïùêÇùëñ), produces the same dependency score on all nodes ùë£‚ààùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ for destinations ùë°‚ààùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ if the distances and the number of shortest paths from s and p to every border node of ùêÇùëñ are the same, except for an additive or multiplicative factor, respectively.

From the previous theorem, we can derive the following corollary (formally proved in section "Mathematical foundations" as Corollary 6.1):

if  ‚àÄ ùëèùëó‚ààùêÅùêçùêÇùëñ, ùúéÃÇ ùë†,ùëèùëó=ùúéÃÇ ùëù,ùëèùëó and  ùëëùêÜ^(ùë†,ùëèùëó)=ùëëùêÜ^(ùëù,ùëèùëó), then ùõøùë†,ùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£)=ùõøùëù,ùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£), ‚àÄùë£‚ààùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ, where ùëëÃÇ ùêÜ(ùë†,ùëèùëó) represents the normalized distance of the generic node s to the generic border node ùëèùëó, defined as follows:

ùëëÃÇ ùêÜ(ùë†,ùëèùëó)=ùëëùêÜ(ùë†,ùëèùëó)‚àíùëöùëñùëõùëèùëò‚ààùêÅùêçùêÇùëñùëëùêÜ(ùë†,ùëèùëò)
and ùúéÃÇ ùë†,ùëèùëó represents the normalized number of shortest paths from the generic node s to the generic border node ùëèùëó, and is defined as:

ùúéÃÇ ùë†,ùëèùëó=ùúéùë†,ùëèùëó/ùëöùëñùëõùëèùëò‚ààùêÅùêçùêÇùëñùúéùë†,ùëèùëò
Normalized distance and normalized shortest paths simplify the identification of classes since they are characterized by the same vector of normalized distances and shortest paths as explained below with an example and the support of a graphical representation.

Let ùêÜ be the simple graph reported in Fig. 1a, decomposed in three clusters, each separately shown in Fig. 1b. We focus on the blue cluster, referred as ùêÇ1, in order to illustrate the concept of equivalence class (see Table 2 and Fig. 2).

Table 2 Normalized distances and normalized number of shortest paths for the blue cluster ùê∂1
Full size table
Fig. 2
figure 2
Classes of equivalent nodes in the blue cluster ùê∂1

Full size image
In ùêÇ1, nodes 1 and 2 are border nodes (i.e., ùëè1 and ùëè2 in Table 2), while the remaining nodes of ùêÇ1 are related to ùëè1 and ùëè2 according to the properties detailed in Table 2: for each node the normalized distances and normalized number of shortest paths to the border nodes are reported. According to our previous definitions, nodes 3, 4, 6, 14 and 5, 1 can be grouped in two classes respectively, whereas node 2 is assigned to a singleton class. Nodes 1, 2 and 14 are the pivotsFootnote1.

Cluster-based exact BC computation
The equivalence classes allow us to compute the dependency score on nodes‚Äîand for destinations‚Äîthat do not belong to the same cluster of the source node, which means that the contributions computed via this approach are only partial. To obtain the total BC, we rewrite Eq. 4 as follows:

ùêµùê∂(ùë£)=‚àëùë†‚ààùêïùõøùë†,‚ãÖ(ùë£)=‚àëùë†‚ààùêï‚àëùë°‚ààùêïùêÇ(ùë†)ùõøùë†,ùë°(ùë£)+‚àëùë†‚ààùêï‚àëùë°‚àâùêïùêÇ(ùë†)ùõøùë†,ùë°(ùë£)=‚àëùë†‚ààùêïùêÇ(ùë£)‚àëùë°‚ààùêïùêÇ(ùë£)ùõøùë†,ùë°(ùë£)ÓÑΩÓÑæÓÖÅÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãsum of local dependency scores = ùõøùúÜ(ùë£)+‚àëùë†‚ààùêï‚àëùë°‚àâùêïùêÇ(ùë†)ùõøùë†,ùë°(ùë£)ÓÑΩÓÑæÓÖÅÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãsum of global dependency scores = ùõøùõæ(ùë£)+‚àëùë†‚àâùêïùêÇ(ùë£)‚àëùë°‚ààùêïùêÇ(ùë†)ùõøùë†,ùë°(ùë£)ÓÑΩÓÑæÓÖÅÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãsum of dependency scores on external node = ùõøùúñ(ùë£)
(7)
As a result, we can distinguish two main terms, local and global dependency scores. The additional term is necessary to properly take into account the possible existence of shortest paths connecting nodes of the same cluster via nodes belonging to one or more different clusters, i.e., external nodes.

We define the local dependency score of a node s on a node v,  ùõøùúÜùë†,‚ãÖ(ùë£), as the sum of pair dependency scores for which source s, the destinations and node v belong all to the same cluster. We define the local BC of a node v,  ùõøùúÜ(ùë£), as the BC of v computed on the sub-graph ùêÇ(ùë£).

Local BC is computed using Brandes‚Äô algorithm inside each clusterFootnote2, which generates, as a by-product, additional information (i.e., the number of shortest paths and distances to border nodes). This information is later used to group nodes into equivalence classes and to fasten the computation of global dependency scores, as further discussed (see section "Algorithm implementation").

The global dependency score of a node s on a node v,  ùõøùõæùë†,‚ãÖ(ùë£), is the sum of all the pair dependency scores for which destinations do not belong to the same cluster of source node s. The global BC of the generic node v,  ùõøùõæ(ùë£), is thus the sum of the global dependency scores for source node s ranging over the whole set of nodes ùêï.

The dependency score of a node s on an external node v, i.e. ùêÇ(ùë£)‚â†ùêÇ(ùë†), noted as ùõøùúñùë†,‚ãÖ(ùë£), is the sum of all the pair dependency scores for which destinations belong to the same cluster of the source node s. We denote by ùõøùúñ(ùë£) the sum of all the dependency scores on v, when v is an external node and the sources and destinations are in the same cluster, different from ùêÇ(ùë£).

This last term ùõøùúñ(ùë£) is equal to zero when the clustering is ideal, i.e. when all the shortest paths between any pair of nodes of a cluster only contain nodes from that same cluster. When this condition is not fulfilled, multiple side effects due to the presence of external nodes have to be taken into account, as discussed below.

External nodes/shortest paths
Given a cluster ùêÇùëñ, two nodes ùë†,ùë°‚ààùêÇùëñ and two border nodes ùëè1,ùëè2‚ààùêÇùëñ, there may exist shortest paths between s and t which exit ùêÇùëñ through ùëè1, cross a certain number of nodes belonging to other clusters and then re-enter ùêÇùëñ through ùëè2. We call these shortest paths external shortest paths and the nodes lying on them which do not belong to ùêÇùëñ,  ùêÑùêçùêÇùëñ, external nodes of ùêÇùëñ. If the existence of such external shortest paths is neglected, BC computation will be affected by an error due to incorrect values of the distances and the counts of shortest paths between pairs of nodes inside the same cluster. Consequently, an error in the computation of the local BC,  ùõøùúÜ, and in the identification of equivalence classes will be introduced. This was one of the approximation errors affected the previous version of our algorithm [12]. To remove this intra-cluster error, we join the idea proposed by the authors in [13]. After clustering, we build a Hierarchical Sub-Network (HSN), i.e., a sub-graph of ùêÜ induced by the border nodes of all the clusters and nodes lying on the intra-cluster shortest paths between pairs of border nodes of the same cluster.

By retrieving all the shortest paths between pairs of border nodes of the same cluster via the HSN, we are able to identify possible external nodes for that cluster. Afterwards, we can extend each cluster with the related external nodes and use the extended clusters as sub-graphs to identify equivalence classes and pivots. Thus, local BC ùõøùúÜ can be correctly computed inside these extended clusters instead of the initial ones.

Formally, an extended cluster ùêÇ‚àóùëñ of a cluster ùêÇùëñ‚ààùêÇ is defined as a connected sub-graph induced by nodes ùêïùêÇ‚àóùëñ=ùêïùêÇùëñ‚à™ùêÑùêçùêÇùëñ.

To better understand how the HSN is built and how it is used to form the extended clusters, we provide an illustrative example. Let us consider again the clustered graph from Fig. 1. In cluster ùêÇ1, nodes 1 and 2 are border nodes, while node 4 lies on the only intra-cluster shortest path between them. In cluster ùêÇ2, nodes 17 and 20 are border nodes and nodes 15, 21, 19 and 16 lie on the intra-cluster shortest paths between them. Finally, in cluster ùêÇ3, there is only border node 8. All the aforementioned nodes build up the HSN (see Fig. 3a). If we now consider the shortest paths between border nodes 1 and 2 via the HSN, we notice that node 17 lies on a shortest path connecting the two former nodes. Consequently, it represents an external node of ùêÇ1 (see Fig. 3b).

Fig. 3
figure 3
Example of external node found through the HSN

Full size image
Dependency score of pivots
From the equivalence class relationship described in section "Equivalence class", a pivot of such a class is representative only for the dependency scores on nodes v‚Äîand destinations t‚Äîwhich do not belong to its own cluster. In fact, given a cluster ùêÇùëñ‚ààùêÇ and all its equivalence classes ùêäùêÇùëñ, from Eq. 6, we have:

‚àëùë†‚ààùêäùê¢ùõøùë†,ùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£)=|ùêäùëñ|‚ãÖùõøùëòùëñ,ùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£)  ‚àÄùë£‚ààùëâùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ,ùêäùëñ‚ààùêäùêÇùëñ.
(8)
This equation can be exploited to speed up computation of BC building on Brandes‚Äô algorithm and SSSP explorations, but only holds if  ùë£‚ààùêïùê∂ùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ. Thus, it cannot be directly applied to correctly compute values of global BC when v is in the same cluster of the source. Therefore, the algorithm requires a more elaborated approach to properly and efficiently calculate the contribution from the pivot of ùêäùêÇùëñ to the BC of nodes ùë£‚ààùêïùê∂ùëñFootnote3.

First of all, let us decompose the global dependency scores from Eq. 7 based on the cluster of node v as follows:

ùõøùõæ(ùë£)=‚àëùë†‚àâùêïùêÇ(ùë£)‚àëùë°‚àâ(ùêïùêÇ(ùë£)‚à™ùêïùêÇ(ùë†))ùõøùë†,ùë°(ùë£)+‚àëùë†‚àâùêïùêÇ(ùë£)‚àëùë°‚ààùêïùêÇ(ùë£)ùõøùë†,ùë°(ùë£)+‚àëùë†‚ààùêïùêÇ(ùë£)‚àëùë°‚àâùêïùêÇ(ùë£)ùõøùë†,ùë°(ùë£)
(9)
The previous equation can be further simplified by considering the following claim, which is proved in section "Mathematical foundations" as Claim 6.1. In undirected graphs:

‚àëùë†‚ààùêïùêÇ(ùë£)‚àëùë°‚àâùêïùêÇ(ùë£)ùõøùë†,ùë°(ùë£)=‚àëùë†‚àâùêïùêÇ(ùë£)‚àëùë°‚ààùêïùêÇ(ùë£)ùõøùë†,ùë°(ùë£)
(10)
By relying on Eq. 10, it becomes possible to replace with zero the sum of the pair-dependencies ùõøùë†,ùë°(ùë£) for which ùë†‚ààùêïùêÇ(ùë£) and ùë°‚ààùêïùêÇ(ùë£)‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ in Eq. 9 and compensate later the lack of this term by doubling the sum of the pair-dependencies ùõøùë†,ùë°(ùë£) for which ùë†‚ààùêïùêÇ(ùë£)‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ and ùë°‚ààùêïùêÇ(ùë£).

Global dependency scores in Eq. 9 are therefore redefined as follows:

ùõøùõæ(ùë£)=‚àëùë†‚àâùêïùêÇ(ùë£)‚àëùë°‚àâ(ùêïùêÇ(ùë£)‚à™ùêïùêÇ(ùë†))ùõøùë†,ùë°(ùë£)+2‚ãÖ‚àëùë†‚àâùêïùêÇ(ùë£)‚àëùë°‚ààùêïùêÇ(ùë£)ùõøùë†,ùë°(ùë£)
(11)
With this further step, we can now use pivots to efficiently compute the exact global BC. In particular, let ùõøùõæùë†,ùêïùêÇ(ùë£)(ùë£) and ùõøùõæùë†,ùêïùêÇ(ùë£)‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£) be the global dependency scores from node s on node v for destinations not belonging to ùêÇ(ùë†), but belonging to ùêÇ(ùë£), and the global dependency score from node s on node v for destinations not belonging to ùêÇ(ùë†) and ùêÇ(ùë£). Eq. 11 can be rewritten as follows:

ùõøùõæ(ùë£)=‚àëùë†‚àâùêïùêÇ(ùë£)[2‚ãÖùõøùõæùë†,ùêïùêÇ(ùë£)(ùë£)+ùõøùõæùë†,ùêïùêÇ(ùë£)‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£))]
(12)
Therefore, given a cluster ùêÇùëñ‚ààùêÇ and all its equivalence classes ùêäùêÇùëñ, we have:

‚àÄùë£‚àâùêïùêÇùëñ,ùêäùëñ‚ààùêäùêÇùëñ,‚àëùë†‚ààùêäùëñ(2‚ãÖùõøùõæùë†,ùêïùêÇ(ùë£)(ùë£)+ùõøùõæùë†,ùêïùêÇ(ùë£)‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£))=|ùêäùëñ|‚ãÖ(2‚ãÖùõøùõæùëòùëñ,ùêïùêÇ(ùë£)(ùë£)+ùõøùõæùëòùëñ,ùêïùêÇ(ùë£)‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£))
(13)
Equation 13 means that, during the back propagation phase, we should distinguish between contributions due to destinations inside the same cluster of v and contributions due to destinations outside the cluster of v.

For a better understanding of the formulas above, let us consider an illustrative example by leveraging again the clustered graph from Fig. 1 and the equivalence classes of cluster ùêÇ1 from Fig. 2.

The pivot node of the equivalence class composed of nodes {3, 4, 6, 14} is node 14. According to the proposed approach, we calculate the dependency scores from node 14 on all nodes of clusters ùêÇ2 and ùêÇ3 and multiply them by 4, avoiding to calculate the dependencies scores from nodes 3, 4 and 6. This way, the computation time is divided by 4. However, while it is correct to multiply by 4 the dependency scores for nodes in ùêÇ2 and ùêÇ3, it is not for nodes belonging to the same cluster of the pivot (see Fig. 4a) since nodes 14, 3, 4, 6 of the class are equivalent only with reference to border nodes of cluster ùêÇ1 (nodes 1, 2). Therefore, we can not multiply by 4 the dependency scores on nodes 1, 2, 3, 4, 5, 6 since these scores are not the same when computed, for instance, from node 14 or node 4. To avoid the problem, we put these dependency scores to 0 and we later compensate during SSSP explorations from a pivot node in ùêÇ2 and ùêÇ3 (see Fig. 4b).

Fig. 4
figure 4
Global SSSP explorations from pivots

Full size image
Back-propagation. Differently from Brandes‚Äô algorithm, it is not possible to directly express the global dependency scoreFootnote4 of a node v,  ùõøùõæùë†,‚ãÖ(ùë£), in terms of the global dependency scores of w,  ùõøùõæùë†,‚ãÖ(ùë§) , where ùë£‚ààùêèùë†(ùë§). Indeed, when ùêÇ(ùë£)‚â†ùêÇ(ùë§) (i.e., when crossing a cluster), the set of destinations of w which do not belong to ùêÇ(ùë§) can be composed of both destinations belonging to ùêÇ(ùë£) and destinations not belonging to ùêÇ(ùë£): for the former, the pair-dependencies have to be multiplied by 2, whereas for the latter no further operation is needed (see Eq. 13).

To overcome this problem, we apply the classic recursive formula of Brandes‚Äô algorithm (Eq. 5) on a vector of contributions, propagating the global dependency scores ùõøùõæùë†,‚ãÖ(ùë£). The dimensions of this vector of contributions correspond to the number of clusters, so that the contribution due to a destination t is assigned to ùõøùõæùë†,ùêïùêÇ(ùë°)(ùë£). Formally, we have the following recursive formula:

‚àÄùêÇùëñ‚ààùêÇ‚àñùêÇ(ùë†):ùõøùõæùë†,ùêïùêÇùëñ(ùë£)=‚àëùë§:ùë£‚ààùêèùë†(ùë§)ùúéùë†,ùë£ùúéùë†,ùë§‚àó(ùüôùë§‚ààùêÇùëñ+ùõøùõæùë†,ùêïùêÇùëñ(ùë§)),
(14)
where ùüôùë§‚ààùêÇùëñ represents a boolean variable equal to 1 if ùë§‚ààùêÇùëñ, 0 otherwiseFootnote5. At the end of the back-propagation phase, we put the dependency scores of nodes v belonging to the same cluster of the (pivot) source node to 0, whereas the dependency scores of nodes belonging to the other clusters are computed using the following formula:

ùõøùõæùë†,ùêïùêÇ(ùë†)‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£)=2‚ãÖùõøùõæùë†,ùêïùêÇ(ùë£)(ùë£)+‚àëùêÇùëñ‚â†ùêÇ(ùë£)ùõøùõæùë†,ùêïùêÇùëñ(ùë£)
(15)
Finally, according to Eq. 13,  ùõøùõæùë†,‚ãÖ(ùë£) is multiplied by the cardinality of the equivalence class s belongs to.

E1C-FastBC algorithm
In this section, we describe the E1C-FastBC algorithm, the implementation of the cluster-based solution introduced in the previous section. We also discuss a parallel version based on MapReduce.

Louvain clustering
To group nodes in clusters and minimize the number of border nodes, |ùêÅùêç|, and consequently |ùêÅùêçùêÇùëñ| for each cluster ùêÇùëñ‚ààùêÇ, we exploit a modularity-based clustering algorithm. Modularity is a scalar metric, defined in the range -1 and 1, which measures the density of links inside clusters as compared to links between them: the higher its value, the lower the number of inter-clusters links. Consequently, maximizing the modularity score reduces the number of border nodes in the clusters. This allows not only to keep low the complexity of the algorithm by reducing the size of the HSN and the number of nodes against which topological properties (normalized distances and normalized number of shortest paths) have to be computed, but also to maximise the chances of having few equivalence classes, each with many nodes, since smaller vectors (those storing the topological properties) increase the probability of having linear dependency among them and consequently a smaller number of classes. This is highly beneficial from the perspective of reducing SSSP explorations.

The Louvain method [29] is an example of modularity-based clustering technique. Its time complexity of ùëÇ(ùëõùëôùëúùëî2ùëõ) is very good compared to that of Brandes‚Äô algorithm. The Louvain algorithm runs in two phases which are iteratively repeated. In the first phase, each node is initially assigned to its own cluster and moved in the cluster of the neighbor which ensures the maximum increase of modularity, with respect to the previous configuration. This phase terminates when all nodes have been explored and no further modularity improvement is possible. In the second phase, a new graph is generated by considering the identified clusters as nodes, and the loops inside them as self-loops. Phase one is then repeated using the graph generated by the second phase. The two phases are iterated until a maximum of modularity is reached and a hierarchical structure of clusters has been formed. The output of the algorithm, and consequently the modularity of the identified clusters, may be affected by the order nodes are evaluated with. This order can also influence the computation time. To improve solutions that are sub-optimal in terms of modularity, multiple runs of the algorithm can be performed over the same network, each associated to a different order for the analysis of the nodes.

Algorithm implementation
Algorithm 1 reports the pseudo-code of the E1C-FastBC algorithm taking as input an undirected unweighted graph ùêÜ and producing in output the exact values of BC for every node in ùêï. The algorithm is composed of several phases. We provide a detailed description for all the intermediate phases, while the associated pseudo-code is provided for the most relevant ones in Algorithm 1.

figure a
At line 2, the Louvain, modularity-based clustering algorithm is exploited for splitting graph ùêÜ into a set of clusters ùêÇ (see section Louvain clustering). These clusters do not need to be explicitly stored in a dedicated data structure as they represent a view of the starting graph, filtered through a membership information stored in every node.

At line 3, we identify the set of border nodes ùêÅùêç by checking, for each node ùë£‚ààùêï, the existence of at least one neighbor belonging to a different cluster.

At line 4, the nodes building up the HSN, referred as ùêïùêªùëÜùëÅ, are retrieved. As detailed in the pseudo-code of Algorithm 2, to build the HSN we first execute |ùêÅùêç| local BFS, each rooted in a border node used as source, i.e.,  ùë†‚ààùêÅùêç. The term local here refers to the fact that only nodes belonging to the same cluster of s, i.e.,  ùêïùêÇ(ùë†), are crossed during the explorations. Each BFS returns the set of direct predecessors ùêèùë†(ùêïùêÇ(ùë†)) of every node in ùêïùêÇ(ùë†) on shortest paths from s. These sets are later used at line 6 of Algorithm 2 to cross the discovered shortest paths backwards starting from destinations t.

Each traversal returns the set of nodes lying on the shortest paths between a pair of border nodes of the same cluster: these nodes, together with the source and destination border nodes themselves, belong to the HSN and are therefore added to the set of all its nodes, i.e., ùêïùêªùëÜùëÅ.

figure b
At line 5, we identify external nodes ùêÑùêç as detailed in Algorithm 3. First, a BFS is executed from each source ùë†‚ààùêÅùêç. In these explorations, only nodes of the HSN, ùêïùêªùëÜùëÅ, are considered. Each BFS returns the set of direct predecessors of every node in ùêïùêªùëÜùëÅ on shortest paths from s, i.e., ùêèùë†(ùêïùêªùëÜùëÅ). Similarly to the previous step, shortest paths are crossed backwards from destination t to source s using the sets of predecessors and every crossed node not belonging to the cluster of s and t is added to the set of external node ùêÑùêç.

figure c
The extended clusters ùêÇ‚àó are generated at line 6 of Algorithm 1 from the original clusters, updated with the external nodes.

At line 7, we compute in each (extended) cluster, (i) the local BC on every node, i.e., ùõøùúÜ, (ii) BC contributions ùõøùúñ on external nodes, and (iii) the topological properties of every node, i.e., the normalized distances ùëëÃÇ  and the normalized numbers of shortest paths ùúéÃÇ , computed with respect to the set of border nodes belonging to the cluster of the node. These topological properties are subsequently used at line 8 to find equivalence classes (see section "Equivalence class with clustering"). A modified version of Brandes‚Äô algorithm enables the computation of all these metrics, as described in Algorithm 4.

The only difference compared to the canonical implementation of Brandes‚Äô algorithm is related to the back-propagation phase: in our case, the contributions due to the external nodes (as destinations) are not propagated, since they represent non-local destinations.

figure d
At line 9, we compute the global BC, ùõøùõæ. As shown in Algorithm 5, a second modified version of Brandes‚Äô algorithm, which exploits Eq. 13, Eq. 14 and Eq. 15, is run from one pivot ùëòùëñ, randomly selected from each class ùêæùëñ‚ààùêä. From the explorations rooted at the class pivots, the global dependency scores, ùõøùõæùëòùëñ,ùêïùêÇ(ùëòùëñ)‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùêï) are computed on every other node v of the graph. The global BC of every node v is then obtained by summing the global dependency scores deriving from all the pivots.

Finally, at lines 10‚Äì12 of Algorithm 1, all the previously computed partial terms are aggregated via a sum operation to obtain the exact BC values for each node.

figure e
Parallel implementation with map/reduce
The proposed E1C-FastBC algorithm can be parallelized since the execution of its sub-algorithms is highly parallelizable, with the only exception of the selected clustering algorithm. We can exploit data parallelism by performing the same operations on different partitions of a given graph leveraging the MapReduce paradigm since most of the computations are applied to each node of the graph.

Figure 5 reports the representation of the parallel version of E1C-FastBC, built using some key concepts introduced in Apache Spark, a popular big data processing engine that we use to run the tests reported in the experimental evaluation. Spark applications are generally defined in terms of transformations and actions that are applied to Resilient Distributed Datasets (RDDs). RDDs are immutable collections of data partitioned across the worker nodes of a cluster. Transformations and actions can be processed in parallel on such partitions. In particular, transformations are functions that produce new RDDs starting from the ones they are invoked on, whereas actions are functions that return the result of a computation performed over an RDD.

Fig. 5
figure 5
Map-reduce, Spark-based description of E1C-FastBC. The main execution flow is represented by solid arrows, while dashed ones represent broadcast variables. Jobs and tasks are depicted as rounded rectangles and cubes, respectively. RDDs are shown as non-rounded rectangles

Full size image
A Spark application is a collection of jobs, each created to perform an action, and executed by one or more executors deployed on the worker nodes of the cluster by running, in parallel, tasks over the partitions of an RDD. The tasks of the jobs encapsulate all the transformations that have to be applied to RDDs. The latter are then collected at the end of the jobs by the master node of a cluster: such node hosts the driver, which is the process responsible for running the application.

To process RDDs, jobs may also require other inputs that can possibly be shared across executors through the so-called broadcast variables: they are lazily copied between worker nodes during execution.

The parallel version of E1C-FastBC is a sequence of jobs, each implementing one or more sub-algorithms of the algorithm, as detailed in Fig. 5. The main execution flow is represented with solid arrows, whereas, with dashed arrows, we present data that are copied via broadcast among all Spark workers and needed to carry out the jobs. Each job executes a specific type of task, as illustrated in Fig. 5, and receives two classes of inputs: (i) RDDs, which are used to guide parallelism, i.e., the number of tasks, and (ii) broadcast variables, which are used by every single task to process its own partition. In the following, we describe each job in terms of tasks behaviors and needed inputs.

Job 1 organizes the graph into clusters (Algorithm 1, line 2) by performing parallel executions of the Louvain method, using different configurations with the aim of selecting the one that produces the clustering with the best modularity score.

The job takes as input the graph, passed as broadcast variable, and outputs the clusters. The starting RDD, which does not contain data, only enables parallel executions of multiple runs of the Louvain method.

Job 2 identifies border nodes (Algorithm 1, line 3), by checking for each node the existence of at least one neighbor belonging to a different cluster. It requires as input the set of clusters and the graph, both passed as broadcast variables. The starting RDD contains all the nodes to analyze, and it is built from the whole set of graph vertices.

Job 3 retrieves the HSN nodes (Algorithm 1, line 4), by performing, for each border node, a constrained (intra-cluster) BFS. It needs the border nodes, the clusters and the graph as its inputs. A broadcast variable is used for all of them, but the set of border nodes is also used to build the starting RDD. Nevertheless, each execution requires the availability of the whole set of border nodes (i) to avoid leaving clusters while performing BFSs and (ii) to check whether a destination is a border node.

Job 4 discovers the external nodes (Algorithm 1, lines 5‚Äì6) through BFSs bound to nodes belonging to the HSN. Consequently, compared to Job 3, it requires HSN nodes as additional input, passed in the form of broadcast variable, while the starting RDD is the same as that of Job 3. At the end, the job outputs the clusters extended with external nodes.

Job 5 computes the local BC, the BC on external nodes, the normalized distances and normalized numbers of shortest paths (Algorithm 1, line 7). The job receives the graph, the clusters, the extended clusters and the border nodes as inputs, all transferred as broadcast variablesFootnote6. The starting RDD of this job contains all the nodes of the graph.

Job 6 identifies the equivalence classes and their pivots (Algorithm 1, line 8). The starting RDD contains the topological properties (normalized distances and normalized number of shortest paths) per node, while the inputs passed as broadcast variables are the same as the previous job.

Job 7 computes the global BC (Algorithm 1, line 9) by using a starting RDD containing pairs composed of a pivot and the cardinality of its equivalence class. The only inputs passed via broadcast variables are the graph and the clusters.

Final BC values are obtained by aggregating all the previously calculated values. This step is performed entirely on the driver in a sequential manner. In all cases, except for Job 1, we use a node-level grain: all functions encapsulated in the various tasks are defined to work starting from a single node (simple node, border node or pivot).

Figure 6 reports a detailed description of Job 2 to exemplify how a job is performed. Solid arrows represent elaboration phases, while the dashed ones represent data transfer phases. The dotted box shows the set of transformations applied by the tasks hosted on the executors over the different partitions. The first dashed box reports the source code related to the job, whereas the second reports the source code of the first map task in the pipeline. The job is triggered by the collect action. The driver builds the initial RDD by executing the parallelize method (1). The number of partitions is equal to the number of executors, i.e., each executor works on a single partition. Partitions are sent to executors along with the operations to be performed on them (2). These operations are encapsulated in a task. In particular, the first map operation (3a) generates an intermediate RDD of key-value pairs where the second element is the unique node identifier and the first element is a boolean value (true/false) that depends on whether the node is a border node or not. Then, the filter operation creates a new intermediate RDD containing only the pairs with the key equal to true (3b). Finally, the second map operation produces an RDD by extracting only the second element of the previous pairs (3c). Hence, the border nodes are collected on the driver (4) and stored in a set (5).

Fig. 6
figure 6
Map-reduce, detailed description of Job2 Includes elaboration and data transfer phases (solid and dashed arrows), the set of transformations applied by the tasks (dotted box) and the related source code (dashed boxes)

Full size image
Experimental evaluation
In this section, we report the main results of the experimental evaluation we conducted by testing the algorithm with both sequential and parallel executions on different types of graphs, and with different graphs and sizes.

We compare the execution times obtained with our algorithm to those obtained with other algorithms by using the Algorithmic Speedup (AS). Given two algorithms, ùëé1 and ùëé2, the algorithmic speedup of ùëé1 over ùëé2 with p cores, noted as ùê¥ùëÜùëé1/ùëé2ùëù, is defined as ùëáùëé2ùëù/ùëáùëé1ùëù, where ùëáùëé2ùëù and ùëáùëé1ùëù are the computation times obtained with p cores using algorithms ùëé2 and ùëé1, respectively. Hence, the larger the value of AS, the faster ùëé1 is compared to ùëé2 with the same computing resources. For example, ùê¥ùëÜ=2 means that the time taken by ùëé1 is half the time taken by ùëé2 and therefore that ùëé1 is two times faster than ùëé2.

In particular, we will compare the E1C-FastBC algorithm, labelled with Óà±, with Brandes‚Äô algorithm, labelled as ÓàÆ and with the solution proposed in [13], labelled with Óà¥. We chose this algorithm for comparison because it belongs to the same category as ours (cluster-based computation) and it addresses the problem of exact BC computation.

However, due to the unavailability of source/executable code for Óà¥, we only consider the AS metric in sequential mode, by relying on the indications provided by the authors in the paper for its computation (see Eq. 7 in [13]).

To further explore the performance of our solution, we also analyze the efficiency of the E1C-FastBC algorithm, based on the canonical definition of speedup. Specifically, the speedup obtained with p cores is defined as ùëÜùëù=ùëáùë†/ùëáùëù, where ùëáùë† is the computation time in sequential mode and ùëáùëù is the computation time with p cores. The efficiency with p cores, noted as ùê∏ùëù, is then defined as ùëÜùëù/ùëù.

Efficiency ùê∏ùëù may influence the AS metric as demonstrated by the following analysis. From the definition of speedup, ùëáùëé2ùëù=ùëáùëé2ùë†/ùëÜùëé2ùëù, where ùëáùëé2ùë† and ùëÜùëé2ùëù are the execution time in sequential mode and the speedup obtained with p cores of algorithm ùëé2. Similarly, we can write ùëáùëé1ùëù=ùëáùëé1ùë†/ùëÜùëé1ùëù. By using these equations in the definition of the AS metric, we have that ùê¥ùëÜùëé1/ùëé2ùëù = (ùëáùëé2ùë†/ùëáùëé1ùë†)‚ãÖ(ùëÜùëé1ùëù/ùëÜùëé2ùëù). From the definition of efficiency, ùëÜùëé1ùëù/ùëÜùëé2ùëù=ùê∏ùëé1ùëù/ùê∏ùëé2ùëù and consequently ùê¥ùëÜùëé1/ùëé2ùëù = (ùëáùëé2ùë†/ùëáùëé1ùë†)‚ãÖ(ùê∏ùëé1ùëù/ùê∏ùëé2ùëù).

The relationship between AS and ùê∏ùëù suggests that if ùëé1 and ùëé2 have comparable efficiency with p cores, then the AS only depends on the ratio of the execution times of the two algorithms in sequential mode, thus providing interesting insights to comparatively analyze the two different solutions.

Finally, we also provide a breakdown analysis of the computation time of our solution, useful to investigate the contribution of each composing sub-algorithms. In all reported tests, we checked the accuracy of our solution by always observing zero error on BC values.

Datasets
In our tests, we consider both synthetic and real graphs.

For the first category, we focus on scale-free graphs generated using the implementation of the Barab√°si-Albert model provided by the Python library NetworkX. According to that model, a graph of n nodes is grown by attaching new nodes, one at a time, each with ùëö‚Ä≤ edges that are preferentially attached to existing nodes with high degree. In our case, ùëö‚Ä≤, which is called the preferential attachment coefficient, is equal to 1. This way, we have graphs with ùëö=ùëõ‚àí1 edges and an average degree approximately equal to 2, i.e., double the preferential attachment coefficient. This choice is motivated by the features of the current implementation of our algorithm that benefits of high modularity. In other words, this class of dataset is considered as best-case scenario. However, as mentioned in the introduction, this does not limit the applicability of our solution because many real-world systems can be represented with the Barab√°si-Albert model. In particular, to analyze the algorithm in terms of performance and scalability, we generate graphs with different sizes (see Table 3).

Table 3 Topological information of synthetic & real graphs
Full size table
For the second category, we focus on some real graphsFootnote7 available in public datasets. Table 3 reports all the graphs we use, together with some relevant properties. In particular, for each graph we consider the average degree (ùëëùëéùë£ùëî), the max degree (ùëëùëöùëéùë•) and the average clustering coefficient (ùëêùëêùëéùë£ùëî).

All the datasets, except the one related to the Lyon road network, are scale-free graphs.

Experimentation testbed
The platform for our experiments is a server machine with 128 GB of RAM and 2 sockets Intel(R) Xeon(R) CPU E5-2680 v4 @ 2.40GHz, with 14 physical cores and 2 threads per core for a total of 28 logical cores per socket and 56 virtual cores in hyper threading, running Linux Debian as operating system.

Both Brandes‚Äô algorithm and E1C-FastBC are implemented in Scala and executed using Apache Spark 2.2.0 in standalone mode. In particular, we deploy a spark cluster composed of the master node and one worker node holding all available resources (56 cores and approximately 125GB of memory). Tests are performed employing a driver with one core and 30GB of memory, and a variable number of executors having a variable amount of memory and computing resources. Specifically, except for the case with one core (sequential execution) where there is only one executor that holds all the resources (i.e., the single core and 90GB of memory), we fix the total number of cores for the experimentation and instantiate a number of executors such that each of them has 5 cores. The amount of memory is divided evenly among executors. For instance, with 5 cores we only deploy one executor with 90GB of memory, while with 10 cores two executors, each with 45 GB of memory, are deployed.

The RDDs are decomposed in a number of partitions equal to the total number of cores.

Synthetic graphs analysis
Figure 7 shows the algorithmic speedup of E1C-FastBC over Brandes‚Äô algorithm, ùê¥ùëÜÓà±/ÓàÆùëù, obtained on the synthetic graphs in both sequential and parallel modes. In particular, we double the number of nodes from 25,000 to 800,000, and we consider a number of cores p equals to 1, 5, 10, 15, 20 and 25. We estimate by log-log regression the computation times with Brandes‚Äô algorithm for the graphs with 400,000 and 800,000 nodes, since executions would require weeks to complete, whereas our algorithm ends in maximum 31.5 min and 1.64 h, respectively (sequential mode).

As highlighted by Fig. 7, ùê¥ùëÜÓà±/ÓàÆùëù increases with the size of the graph, meaning that E1C-FastBC is not only faster than Brandes‚Äô algorithm but its speedup grows with larger graphs. This is due to the fact that the computation of our algorithm is strongly dependent on the number of border nodes (|ùêÅùêç|), pivots (|ùêä|) and external nodes (|ùêÑùêç|), in addition to the number of nodes (n) and edges (m). The first two variables increase slowly compared to the number of nodes and edges, while the third is almost always zero (only in one case it was equal to 2). The drawback is that ùê¥ùëÜÓà±/ÓàÆùëù decreases as the number of cores increases. This behaviour is due to the fact that the Brandes‚Äô algorithm is more efficient than E1C-FastBC (see Fig. 8). This means that the ratio ùê∏ùëé1ùëù/ùê∏ùëé2ùëù in the relationship between the AS metric and the efficiency is lower than 1. Consequently, the AS value in the sequential case is not preserved as the number of cores increases. However, as the following efficiency analysis will further clarify, this does not mean that E1C-FastBC is less scalable than Brandes‚Äô algorithm, but rather that it needs very large graphs to better exploit the available computing resources. This statement is also confirmed by Fig. 7, which clearly shows that when the graph size is 400,000, a higher number of cores performs even better than a smaller one: in particular, we have that the ùê¥ùëÜÓà±/ÓàÆùëù is better with 5 cores than with 1 core. To have a similar behavior even for a number of cores greater than 5, we should consider larger graphs.

Fig. 7
figure 7
Comparison with Brandes‚Äô algorithm. Algorithmic speedup analysis-ùê¥ùëÜÓà±/ÓàÆùëù=[1,5,10,15,20,25]

Full size image
Fig. 8
figure 8
Comparison with Brandes‚Äô algorithm. Efficiency analysis- ùê∏ùëù=[1,5,10,15,20,25]

Full size image
To better understand the performance of E1C-FastBC, we investigate its efficiency with respect to that of Brandes‚Äô algorithm. Figure 8 reports the results of the efficiency analysis performed for the two algorithms. In both cases, it is possible to observe that: (i) the efficiency decreases as the number of cores increases and (ii) for a given number of cores, it increases as the number of nodes increases.

However, it is worth to highlight that in the efficiency analysis, we use different but overlapping ranges of values for the number of nodes. In particular, for our solution we select larger graphs since we aim at showing that our algorithm scale well especially with very large graphs. In fact, the efficiency trend is almost the same in the two cases reported in Fig. 8. Moreover, given the maximum values of the number of nodes for the two algorithms (800,000 for ours, 200,000 for Brandes‚Äô), efficiency values are approximately the same with 5 cores (i.e., the first considered parallel configuration) but significantly diverge as the number of cores increases. In particular, efficiency of E1C-FastBC decreases with a higher rate.

The reason for this behaviour lies in the reduced amount of computation required by our solution. Indeed, pivots allow to significantly decrease the number of (modified) Brandes‚Äô SSSP explorations performed on the whole graph, which represent the heaviest part of the whole computation (see Figs. 13 and 14), thus reducing the workload of each core.

Our solution also introduces another benefit: it allows to mitigate the variability of the computation times due to the different topological characteristics of the graphs and to the partitioning of data performed by Spark during executions. Indeed, there may exist some partitions of the RDDs characterized by a high concentration of nodes that generate the most complex shortest path trees.

The time required to process these partitions directly impacts the time required to process the whole RDD, since partitions are processed in parallel. However, Spark tasks process each single partition sequentially. This aspect, combined with the fact that the number of partitions of an RDD is always equal to the number of cores and the default partitioning scheme of Spark distributes data evenly across the partitions, explains the punctual efficiency drops that can be observed in the plot related to Brandes‚Äô algorithm, when using graphs with 50,000 and 100,000 nodes and a low number of cores (see Fig. 8b).

Figure 9 reports the algorithmic speedup of E1C-FastBC over Brandes‚Äô algorithm, ùê¥ùëÜÓà±/ÓàÆùëù=1, alongside with the algorithmic speedup of the approach in [13] over Brandes, ùê¥ùëÜÓà¥/ÓàÆùëù=1, on synthetic graphs and in sequential settings. ùê¥ùëÜÓà¥/ÓàÆùëù=1 is analytically computed based on Eq. 7 provided in [13].

Fig. 9
figure 9
Comparison with the solution proposed in [13]. Algorithmic speedup analysis with synthetic graphs in sequential mode- ùê¥ùëÜÓà±/ÓàÆùëù=1 and ùê¥ùëÜÓà¥/ÓàÆùëù=1. ùê¥ùëÜÓà¥/ÓàÆùëù=1 is always equal to 1 for synthetic graphs (see section "Synthetic graphs analysis"). We therefore add only one single zoomed bar in the figure just to make it visible to the reader

Full size image
Using such equation, it is possible to observe that: (i) ùê¥ùëÜÓà¥/ÓàÆùëù=1 depends on the number of clusters (|ùêÇ|) and the average degree (ùëëùëéùë£ùëî), and (ii) when |ùêÇ|+2‚â´ùëëùëéùë£ùëî/2, it can be approximated with ùëëùëéùë£ùëî/2. Therefore, since for synthetic graphs the average degree is constant and the number of clusters increases with the number of nodes, ùê¥ùëÜÓà¥/ÓàÆùëù=1 is always approximately equal to 1 (the average degree is 2). In particular, the higher the number of clusters, the closer to 1 the ùê¥ùëÜÓà¥/ÓàÆùëù=1. This means that the algorithm proposed in [13] is not able to improve that of Brandes. Conversely, ours is able to do it by a large multiplicative factor. We can thus conclude that our solution always outperforms the one in [13] with synthetic graphs.

Real graphs analysis
Figure 10 reports the results of the analysis of ùê¥ùëÜÓà±/ÓàÆùëù=1 and ùê¥ùëÜÓà¥/ÓàÆùëù=1 carried out on real graphs. ùê¥ùëÜÓà¥/ÓàÆùëù=1 is computed again using Eq. 7 provided in [13]. In all cases, our solution outperforms the one in [13].

Fig. 10
figure 10
Comparison with the solution proposed in [13]. Algorithmic speedup analysis with real graphs in sequential mode-ùê¥ùëÜÓà±/ÓàÆùëù=1 and ùê¥ùëÜÓà¥/ÓàÆùëù=1

Full size image
To further confirm the considerations on the scalability of our solution, reported in the previous section, we analyze in the following both the algorithmic speedup and efficiency values of E1C-FastBC on the lyon-road-network graph, for which we observed a very high number of pivots (about 60% of the number of nodes) and the lowest algorithmic speedup factor. As shown in Fig. 11, the AS is always greater than 1, thus confirming the usefulness of our solution, although the reported values are not comparable to those obtained on synthetic graphs (see Fig. 7) with a similar number of nodes (100,000 and 200,000). In spite of this, the algorithm becomes more scalable and efficient than in the case of synthetic graphs with 100,000 and 200,000 nodes due to the increased amount of computation resulting from the higher number of border nodes, pivots and external nodes (see Fig. 12). Also in this case, by considering the two figures (Figs. 11 and 12), it is possible to note the dependency relationship between the AS metric and the efficiency. In particular, going from 15 to 20 cores the difference between efficiency values for the Brandes‚Äô algorithm and of E1C-FastBC decreases while AS increases.

Fig. 11
figure 11
Algorithmic speedup analysis for lyon-road-network graph in parallel mode-ùê¥ùëÜÓà±/ÓàÆùëù=[1,5,10,15,20,25]

Full size image
Fig. 12
figure 12
Efficiency analysis for lyon-road-network graph-ùê∏ùëù=[1,5,10,15,20,25]. Comparison with synthetic graphs having similar size (100k and 200k nodes) and with Brandes‚Äô algorithm on the same graph

Full size image
Breakdown of computation time
In this section, we analyze the contributions of the different component sub-algorithms to the overall computation time of E1C-FastBC. The goal of this analysis is to find bottlenecks that limit scalability and, consequently, room for further improvements.

We split the algorithm in seven parts (see Algorithm 1): Dataset Reading, Louvain Clustering (line 2), HSN & External Nodes (lines 3‚Äì6), Local BC & Top. Props. (line 7), Classes & Pivots (line 8), Global BC (line 9) and Final Accumulation (lines 10‚Äì12). Figures 13 and 14 report the time taken by each of the parts above. Results have been obtained by running our algorithm on the synthetic graphs with 100,000 and 200,000 nodes in sequential and parallel modes. The level of parallelism (i.e., total number of exploited cores) is indicated on the x-axis of the figures.

Fig. 13
figure 13
Breakdown analysis of computation time on synthetic graph with 100,000 nodes

Full size image
Fig. 14
figure 14
Breakdown analysis of computation time on synthetic graph with 200,000 nodes

Full size image
The parts exhibiting the highest computation time are Global BC and Local BC & Top. Props.. They both show a very good scalability as increasing resources up to the maximum limit (25 cores) translates into a reduction in time.

The third heaviest part is Louvain Clustering. Its computation time does not keep decreasing when augmenting parallelism beyond 5 cores. This is due to the fact that we have chosen to launch 10 parallel executions of the Louvain method in different configurations with the aim of selecting the one that produces the clustering with the best modularity score. This aspect highlights a potential bottleneck, since the computation time of Louvain Clustering at high levels of parallelism becomes comparable with those related to Global BC and Local BC & Top. Props..

As already discussed in section "Synthetic graphs analysis", the number of external nodes for our synthetic graphs is almost always equal to zero. Therefore, the contribution of HSN & External Nodes is not relevant as well as those of Classes & Pivots and Final Accumulation. In particular, the latter is a sequential step entirely performed on the driver. Therefore it does not vary with the number of cores.

For Dataset Reading, computation time slowly increases with the number of cores due to the overhead introduced for creating the initial RDD, by reading data from the file system, with a number of partitions equal to the number of cores. Even for this step, the computation time becomes comparable with those obtained for Local BC & Top. Props. and Global BC when the parallelism increases.

It is worth to note that synthetic graphs represent a sort of best-case scenario: the very low number of border nodes and pivots, together with the almost complete absence of external nodes, allows for excellent performance. A more realistic scenario is analyzed in the following, by focusing on a real graph.

Figure 15 reports the time taken by each part of the algorithm on the ego-twitter graphFootnote8, in sequential and parallel modes. In this case, HSN & External Nodes becomes the second heaviest contribution with values comparable to those of Local BC & Top. Props.. This is mainly due to the increased number of external nodes and confirms the importance of achieving ideal clustering. Similar considerations as those made for synthetic graphs apply as well to the remaining contributions from the breakdown analysis related to the ego-twitter graph.

Fig. 15
figure 15
Breakdown analysis of computation time on real graph ego-twitter

Full size image
Mathematical foundations
As discussed in "Clustering and BC computation" section, our algorithm relies on multiple mathematical properties to allow for the exact fast computation of BC. In the following, we provide the mathematical proofs of the mathematical foundation (theorem, corollary and claim) at the basis our algorithm. In theorem 6.1, we prove that two nodes of the same cluster that satisfy some properties produce the same dependency score on nodes outside the cluster for destinations that are outside the cluster.

Theorem 6.1
Let ùëò‚àà‚Ñù+ and ùëô‚àà‚Ñù, let ùêÇùëñ be a generic cluster of graph ùêÜ with border nodes ùêÅùêçùêÇùëñ and ùë†,ùëù‚ààùêïùêÇùëñ. If  ‚àÄ ùëèùëó‚ààùêÅùêçùêÇùëñ ùúéùë†,ùëèùëó=ùëò‚ãÖùúéùëù,ùëèùëó and ùëëùêÜ(ùë†,ùëèùëó)=ùëëùêÜ(ùëù,ùëèùëó)+ùëô, then ùõøùë†,ùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£)=ùõøùëù,ùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£), ‚àÄùë£‚ààùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ.

Proof
By rewriting the statement of the theorem as follows:

‚àÄùë£‚ààùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ,ùõøùë†,ùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£)=ùõøùëù,ùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£) ‚ü∫ ‚àëùë°‚àâùêïùêÇùëñùúéùë†,ùë°(ùë£)ùúéùë†,ùë°=‚àëùë°‚àâùêïùêÇùëñùúéùëù,ùë°(ùë£)ùúéùëù,ùë°
(16)
we can prove it by proving that the two following conditions:

ùúéùë†,ùë°(ùë£)=ùëò‚ãÖùúéùëù,ùë°(ùë£)  ‚àÄùë£,ùë°‚ààùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ
(17)
and

ùúéùë†,ùë°=ùëò‚ãÖùúéùëù,ùë°  ‚àÄùë°‚ààùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ
(18)
hold under the hypotheses of the theorem.

Let us first prove the following Lemma 6.1, which permits to express the relationship on the distances to cluster border nodes (i.e., ùëëùêÜ(ùë†,ùëèùëó)=ùëëùêÜ(ùëù,ùëèùëó)+ùëô) as an equivalence of the sets of border nodes traversed from s and p to reach nodes t outside the given cluster.

Lemma 6.1
Let ùêÅùêçùêÇùëñ(ùë¢,ùë°)‚äÜùêÅùêçùêÇùëñ denote the set of border nodes of cluster ùêÇùëñ on the shortest paths from ùë¢‚ààùêïùêÇùëñ to ùë°‚ààùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ. Given a constant ùëô‚àà‚Ñù and two nodes ùë†,ùëù‚ààùêïùêÇùëñ, if ùëëùêÜ(ùë†,ùëèùëó)=ùëëùêÜ(ùëù,ùëèùëó)+ùëô  ‚àÄ ùëèùëó‚ààùêÅùêçùêÇùëñ then  ùêÅùêçùêÇùëñ(ùë†,ùë°)=ùêÅùêçùêÇùëñ(ùëù,ùë°).

Proof
Let us consider two border nodes ùëèùëó,ùëèùëò‚ààùêÅùêçùêÇùëñ with ùëèùëó‚ààùêÅùêçùêÇùëñ(ùë†,ùë°) and ùëèùëò‚àâùêÅùêçùêÇùëñ(ùë†,ùë°). By definition of shortest path between two nodes, we have:

ùëëùêÜ(ùë†,ùëèùëò)+ùëëùêÜ(ùëèùëò,ùë°)>ùëëùêÜ(ùë†,ùë°)
(19)
Given that ùëèùëó‚ààùêÅùêçùêÇùëñ(ùë†,ùë°) by hypothesis, Eq. 19 can be easily re-written as follows:

‚ü∫ ùëëùêÜ(ùë†,ùëèùëò)+ùëëùêÜ(ùëèùëò,ùë°)>ùëëùêÜ(ùë†,ùë°)ùëëùêÜ(ùë†,ùëèùëò)+ùëëùêÜ(ùëèùëò,ùë°)>ùëëùêÜ(ùë†,ùëèùëó)+ùëëùêÜ(ùëèùëó,ùë°)
(20)
Now, by relying on the hypothesis of the lemma, we exploit the relationships holding between the distances of generic nodes s and p to each border node in ùêÅùêçùêÇùëñ, thus obtaining:

‚ü∫ ‚ü∫ ùëëùêÜ(ùë†,ùëèùëò)+ùëëùêÜ(ùëèùëò,ùë°)>ùëëùêÜ(ùë†,ùë°)ùëëùêÜ(ùëù,ùëèùëò)+ùëô+ùëëùêÜ(ùëèùëò,ùë°)>ùëëùêÜ(ùëù,ùëèùëó)+ùëô+ùëëùêÜ(ùëèùëó,ùë°)ùëëùêÜ(ùëù,ùëèùëò)+ùëëùêÜ(ùëèùëò,ùë°)>ùëëùêÜ(ùëù,ùëèùëó)+ùëëùêÜ(ùëèùëó,ùë°)
(21)
From Eq. 21, we can derive that ùëèùëò does not belong to any shortest path between p and t, i.e.:

ùëëùêÜ(ùë†,ùëèùëò)+ùëëùêÜ(ùëèùëò,ùë°)>ùëëùêÜ(ùë†,ùë°)‚ü∫ ùëèùëò‚àâùêÅùêçùêÇùëñ(ùëù,ùë°)
As the relation above holds for any node ùëèùëò ‚ààùêÅùêçùêÇùëñ which does not belong to any shortest path between s and t, we can conclude that:

ùêÅùêçùêÇùëñ(ùëù,ùë°)‚äÜùêÅùêçùêÇùëñ(ùë†,ùë°)
(22)
Likewise, it is possible to prove that if ùëèùëó‚ààùêÅùêçùêÇùëñ(ùëù,ùë°) and ùëèùëò‚àâùêÅùêçùêÇùëñ(ùëù,ùë°), we have:

ùëëùêÜ(ùëù,ùëèùëò)+ùëëùêÜ(ùëèùëò,ùë°)>ùëëùêÜ(ùëù,ùë°)‚ü∫ùêÅùêçùêÇùëñ(ùë†,ùë°)‚äÜùêÅùêçùêÇùëñ(ùëù,ùë°)
(23)
Therefore, from Eq. 22 and Eq. 23, we can conclude that the following relationship holds:

‚ü∫ ùêÅùêçùêÇùëñ(ùë†,ùë°)‚äÜùêÅùêçùêÇùëñ(ùëù,ùë°) AND  ùêÅùêçùêÇùëñ(ùëù,ùë°)‚äÜùêÅùêçùêÇùëñ(ùë†,ùë°)ùêÅùêçùêÇùëñ(ùë†,ùë°)=ùêÅùêçùêÇùëñ(ùëù,ùë°)
(24)
which proves the lemma. ‚óª

To complete the proof of Theorem 6.1, we need now to prove Eq. 17 and Eq. 18. To that purpose, we consider the following lemma.

Lemma 6.2
Let s be a node of cluster ùêÇùëñ, and t any node in ùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ. ùêÅùêçùêÇùëñ(ùë†,ùë°) is the set of border nodes of cluster ùêÇùëñ that belong to the shortest paths between s and t. If ùêÅùêçùêÇùëñ(ùë†,ùë°)=ùêÅùêçùêÇùëñ(ùëù,ùë°), then, ‚àÄùë°‚ààùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ, ùúéùë†,ùë°=ùëò‚ãÖùúéùëù,ùë° and ùúéùë†,ùë°(ùë£)=ùëò‚ãÖùúéùëù,ùë°(ùë£).

Proof
By leveraging Bellman‚Äôs criterion:

ùúéùë†,ùë°=‚àëùëèùëó‚ààùêÅùêçùêÇùëñ(ùë†,ùë°)ùúéùë†,ùëèùëó‚ãÖùúéùëèùëó,ùë°.
(25)
From the hypothesis of Theorem 6.1, we know that ùúéùë†,ùëèùëó=ùëò‚ãÖùúéùëù,ùëèùëó  ‚àÄùëèùëó‚ààùêÅùêçùêÇùëñ and equivalently ‚àÄùëèùëó‚ààùêÅùêç(ùë†,ùë°), as ùêÅùêç(ùë†,ùë°)‚äÜùêÅùêçùêÇùëñ. Therefore, Eq. 25 becomes:

ùúéùë†,ùë°=‚àëùëèùëó‚ààùêÅùêçùêÇùëñ(ùë†,ùë°)ùëò‚ãÖùúéùëù,ùëèùëó‚ãÖùúéùëèùëó,ùë°
(26)
By the hypotheses of this lemma, we also know that ùêÅùêçùêÇùëñ(ùë†,ùë°)=ùêÅùêçùêÇùëñ(ùëù,ùë°). Thus, we have:

‚àëùëèùëó‚ààùêÅùêçùêÇùëñ(ùë†,ùë°)ùëò‚ãÖùúéùëù,ùëèùëó‚ãÖùúéùëèùëó,ùë°=ùëò‚ãÖ‚àëùëèùëó‚ààùêÅùêçùêÇùëñ(ùëù,ùë°)ùúéùëù,ùëèùëó‚ãÖùúéùëèùëó,ùë°=ùëò‚ãÖùúéùëù,ùë°
(27)
With the same reasoning, it is also evident to prove the following:

ùúéùë†,ùë°(ùë£)=ùëò‚ãÖùúéùëù,ùë°(ùë£)
(28)
‚óª

Eq. 28 and Eq. 27 from Lemma 6.2 prove, via Lemma 6.1, Eq. 17 and Eq. 18 respectively. Therefore Theorem 6.1 is proved. ‚óª

We now prove that the normalized distances and number of shortest paths fulfill the conditions of Theorem 6.1 and hence can be used to group nodes into classes of equivalence.

Corollary 6.1
If  ‚àÄ ùëèùëó‚ààùêÅùêçùêÇùëñ: ùúéÃÇ ùë†,ùëèùëó=ùúéÃÇ ùëù,ùëèùëó ùëéùëõùëë ùëëùêÜ^(ùë†,ùëèùëó)=ùëëùêÜ^(ùëù,ùëèùëó), ùë°‚Ñéùëíùëõ ùõøùë†,ùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£)=ùõøùëù,ùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ(ùë£),  ‚àÄùë£‚ààùêïùêÇùëñ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ.

Proof
To prove the corollary, we only need to prove that the following two equations hold:

ùëëùêÜ^(ùë†,ùëèùëó)=ùëëùêÜ^(ùëù,ùëèùëó)  ‚àÄùëèùëó‚ààùêÅùêçùêÇùëñ‚üπùëëùêÜ(ùë†,ùëèùëó)=ùëëùêÜ(ùëù,ùëèùëó)+ùëô  ‚àÄùëèùëó‚ààùêÅùêçùêÇùëñ
(29)
and:

ùúéÃÇ ùë†,ùëèùëó=ùúéÃÇ ùëù,ùëèùëó  ‚àÄùëèùëó‚ààùêÅùêçùêÇùëñ‚üπùúéùë†,ùëèùëó=ùëò‚ãÖùúéùëù,ùëèùëó  ‚àÄùëèùëó‚ààùêÅùêçùêÇùëñ
(30)
Let us consider any two generic pair of nodes s and p belonging to cluster ùêÇùëñ such that:

‚àÄùëèùëó‚ààùêÅùêçùêÇùëñ,ùëëùêÜ(ùë†,ùëèùëó)‚àíùëöùëñùëõùëèùëò‚ààùêÅùêçùêÇùëñùëëùêÜ(ùë†,ùëèùëò)=ùëëùêÜ(ùëù,ùëèùëó)‚àíùëöùëñùëõùëèùëò‚ààùêÅùêçùêÇùëñùëëùêÜ(ùëù,ùëèùëò)
(31)
ANDùúéùë†,ùëèùëóùëöùëñùëõùëèùëò‚ààùêÅùêçùêÇùëñùúéùë†,ùëèùëò=ùúéùëù,ùëèùëóùëöùëñùëõùëèùëò‚ààùêÅùêçùêÇùëñùúéùëù,ùëèùëò
(32)
By definition, Eq. 31 can be easily re-written as follows:

‚ü∫ ‚ü∫ ‚àÄùëèùëó‚ààùêÅùêçùêÇùëñ,ùëëùêÜ(ùë†,ùëèùëó)‚àíùëöùëñùëõùëèùëò‚ààùêÅùêçùêÇùëñùëëùêÜ(ùë†,ùëèùëò)=ùëëùêÜ(ùëù,ùëèùëó)‚àíùëöùëñùëõùëèùëò‚ààùêÅùêçùêÇùëñùëëùêÜ(ùëù,ùëèùëò)ùëëùêÜ(ùë†,ùëèùëó)=ùëëùêÜ(ùëù,ùëèùëó)‚àíùëöùëñùëõùëèùëò‚ààùêÅùêçùêÇùëñùëëùêÜ(ùëù,ùëèùëò)+ùëöùëñùëõùëèùëò‚ààùêÅùêçùêÇùëñùëëùêÜ(ùë†,ùëèùëò)ÓÑΩÓÑæÓÖÅÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãconstant valueùëëùêÜ(ùë†,ùëèùëó)=ùëëùêÜ(ùëù,ùëèùëó)+ùëô  with ùëô‚àà‚Ñù
which corresponds to Eq. 29.

Likewise, Eq. 32 can be re-written as:

‚ü∫ ‚ü∫ ‚àÄùëèùëó‚ààùêÅùêçùêÇùëñ,ùúéùë†,ùëèùëóùëöùëñùëõùëèùëò‚ààùêÅùêçùêÇùëñùúéùë†,ùëèùëò=ùúéùëù,ùëèùëóùëöùëñùëõùëèùëò‚ààùêÅùêçùêÇùëñùúéùëù,ùëèùëòùúéùë†,ùëèùëó=ùúéùëù,ùëèùëó‚ãÖùëöùëñùëõùëèùëò‚ààùêÅùêçùêÇùëñùúéùë†,ùëèùëòùëöùëñùëõùëèùëò‚ààùêÅùêçùêÇùëñùúéùëù,ùëèùëòÓÑΩÓÑæÓÖÅÓÖãÓÖãÓÖãÓÖãÓÖãÓÖãconstant ratioùúéùë†,ùëèùëó=ùúéùëù,ùëèùëó‚ãÖùëò  with ùëò‚àà‚Ñù+
which corresponds to Eq. 30. As the two equations (Eq. 29 and Eq. 30) are jointly satisfied, the corollary is proved from Theorem 6.1. ‚óª

Claim 6.1
In undirected graphs:

‚àëùë†‚ààùêïùêÇ(ùë£)‚àëùë°‚àâùêïùêÇ(ùë£)ùõøùë†,ùë°(ùë£)=‚àëùë†‚àâùêïùêÇ(ùë£)‚àëùë°‚ààùêïùêÇ(ùë£)ùõøùë†,ùë°(ùë£)
(33)
The proof of the claim above, used in section "Dependency score of pivots", is entirely based on the property of undirection. We remove part of the estimation errors we had in the previous implementations ( [12]) by changing the computation of global dependency score using this claim.

Proof
Thanks to the undirected nature of the graph, we have:

‚àëùë†‚ààùêïùêÇ(ùë£)‚àëùë°‚àâùêïùêÇ(ùë£)ùõøùë†,ùë°(ùë£)=‚àëùë†‚ààùêïùêÇ(ùë£)‚àëùë°‚àâùêïùêÇ(ùë£)ùúéùë†,ùë°(ùë£)ùúéùë†,ùë°=‚àëùë†‚ààùêïùêÇ(ùë£)‚àëùë°‚àâùêïùêÇ(ùë£)ùúéùë°,ùë†(ùë£)ùúéùë°,ùë†=‚àëùë°‚àâùêïùêÇ(ùë£)‚àëùë†‚ààùêïùêÇ(ùë£)ùúéùë°,ùë†(ùë£)ùúéùë°,ùë†
Now, by changing the name of variables s and t:

‚àëùë†‚ààùêïùêÇ(ùë£)‚àëùë°‚àâùêïùêÇ(ùë£)ùõøùë†,ùë°(ùë£)=‚àëùë°‚àâùêïùêÇ(ùë£)‚àëùë†‚ààùêïùêÇ(ùë£)ùúéùë°,ùë†(ùë£)ùúéùë°,ùë†=‚àëùë†‚àâùêïùêÇ(ùë£)‚àëùë°‚ààùêïùêÇ(ùë£)ùúéùë†,ùë°(ùë£)ùúéùë†,ùë°=‚àëùë†‚àâùêïùêÇ(ùë£)‚àëùë°‚ààùêïùêÇ(ùë£)ùõøùë†,ùë°(ùë£)
‚óª

Conclusion
In this paper, we presented a very fast algorithm for performing the exact computation of BC in undirected graphs. The algorithm exploits clustering and structural properties of graphs to reduce the computing time. In particular, the algorithm exhibits an impressive speedup (compared with Brandes‚Äô algorithm and the one labelled with Óà¥, especially for very large scale-free graphs with an attachment coefficient ùëö=1. A significant speedup is achieved also with other kinds of graphs, as demonstrated by the results obtained with real graphs. The reduction of the computation time is mainly due to the adoption of pivots, i.e., nodes that contribute equally to the dependency score of other graph nodes.

The paper described both a sequential and a map-reduce parallel version of the algorithm implemented in Scala over Spark. The experimental analysis, performed with reference to the number of cores exploited for computation, revealed that the efficiency is slightly lower than Brandes‚Äô algorithm but it increases with graph size. In fact the granularity per Spark-task of the SSSP computations is small when graphs are not very large due to the relative low number of pivots.

The speedup of E1C-FastBC strongly depends on the number of pivots; thus clustering and modularity play a key role for the computation time of the algorithm. As future work, we aim to study other clustering methods for more effectively identifying border nodes in (synthetic and real) graphs with different topologies. Finally, we will investigate a better mapping of the algorithm on distributed resources, when data-parallelism is exploited, by improving locality especially when different Spark executors are usedÔªø.

