A business process model may be used as both a communication artefact for gathering and sharing knowledge of a business practice among stakeholders and as a specification for the automation of the process by a Business Process Management System (BPMS). For each of these uses, it is desirable to have an ability to visualise the process model from a range of different perspectives and at various levels of granularity. Such views are a common feature of enterprise architecture frameworks, but process modelling and management systems and tools generally have a limited number of available views to offer. This paper presents a taxonomy of process views that are presented in the literature and then proposes the definition and use of a common process model ontology, from which an extensible range of process views may be derived. The approach is illustrated through the realisation of a plug-in component for the YAWL BPMS, although it is by no means limited to that environment. The component illustrates that the process views frequently mentioned in the literature as desirable can be effectively implemented and extended using an ontology-based approach. It is envisaged that the accessibility of a repertoire of views that support business process development will lead to greater efficiencies through more accurate process definitions and improved change management support.

Access provided by University of Auckland Library

Introduction
A business process model defines a set of tasks that are collectively performed to achieve some business objective. A model is described via three primary perspectives: control-flow, which specifies which tasks need to be performed, and their ordering; data, which defines the structures, variables and values representing the information required to achieve the business objective, and passed from task to task during the performance of a process; and resource, which assigns (human) resources, systems and applications to perform the actual work delegated to each task. Thus, a process model is an orchestration that delivers the right work to the right resource at the right time.

A business process model therefore provides a representation of an underlying business process and serves a dual purpose. As a basis for planning and communication, complex business practices can be represented by a relatively simple graphical model that can facilitate conversation, shared understanding and requirements gathering between subject matter experts, users, developers and other stakeholders. As a basis for automation, process models represent an execution script for coordinating an array of people and systems in the support of an organisation’s business practices.

Fig. 1
figure 1
An example model of a simple procure-to-pay process (control-flow view, YAWL notation)

Full size image
There is however a dilemma: the graphical model cannot be simultaneously clear and concise enough for general stakeholder understanding, while containing all the detailed information required for automation purposes [4, 5]. Furthermore, the optimal degree of detail in presented information depends on each stakeholder’s role and their concrete concerns at particular times. For process designers, there is the additional need to have access to information across all process perspectives in a form that is concise, comprehensive and comprehensible, without risking cognitive overload.

In the domain of enterprise architectures, views are a well-established means of dealing with system complexity. Each view describes a portion or all of a system at a chosen granularity and is designed to address needs from the perspective of a particular designer or stakeholder [34]. Methods and supporting tools for enterprise architectures provide for the creation of a large number of different views, all derived from a common architecture description.

Current process modelling paradigms and tools in the BPMS domain typically highlight a particular perspective of the whole process and leave the remainder hidden from view. The problem is exacerbated by the lack of a common process description language across BPM systems from which new views can be derived as needs arise.

This paper describes a solution that provides for the mapping of concrete process model specifications to a common ontological model and proposes a systematic and extensible way of deriving views through the querying of the ontology. This approach represents the first use of an ontology as the basis for the generation of process views, to the best of our knowledge. The realisation of a plugin for the YAWL business process management system [62] demonstrates that this ontological approach can yield new and innovative views of a process model and is extensible so that additional views may be created as required. While the approach described here is illustrated with YAWL, it is generic and by no means limited to that environment.

The paper is organised as follows: in Sect. 2 we examine the field of business process management, its stakeholders and their needs. A taxonomy of process views collated from the literature is presented in Sect. 3, categorising them according to the three main process perspectives. Section 4 introduces ontologies in general, discusses how a process model ontology may be derived and describes a concrete ontology derived from the YAWL process language. Section 5 details a realisation of our approach as a plugin to the YAWL process designer tool, illustrated with examples of different views for a small but realistic specification. Section 6 presents an evaluation of our approach by process modelling experts and practitioners. Section 7 discusses related work, while Sect. 8 offers some future directions and concludes the paper.

Background
Business process models define business practices by identifying activities and their relationships, and presenting them as commonly understood communication artefacts [73]. Consequently, models aid stakeholder understanding of the processes that concern them. When process designers add detail regarding ordinal and temporal relations, data bindings, resources and systems, process models become templates for business automation, delivering tangible benefits to the organisation such as improvements in efficiency, process control, customer relations, cost savings, systems integration and continuing process improvement [43]. They also facilitate the rapid and reliable adaptation of software systems to changing environments [18, 51, 73]. The explicit representation of processes enables management support at the (re)design level and is a shift away from hard-coding processes [18]. The ability to quickly adapt and change software systems is a prerequisite for continuous improvement [43, 73].

For any business process, there may be a wide number of stakeholders, all with differing concerns. The management team, process owners and domain experts [19] want to understand the process at a relatively high granularity, and are concerned with process optimisation, data provenance, prevention of information leakage, fraud resistance, risk assessment and so on. Business process performance indicators [51, 67] such as throughput time, error rate and cost [51] are important to every manager. Other concerns include the outcome of a process instance [19] and the quality of the workflow from a client satisfaction and a work experience point of view [51].

Process analysts and system engineers [19] are primarily concerned with change analysis, i.e. the consequences of modifying the model for a proper functioning of the process at runtime. Considerations include logical correctness, control-flow soundness [67, 69], soundness in the presence of data [60], and correct and efficient resource allocations.

Process participants sometimes want to have an overview of the process and an understanding of their role within it. BPMS administrators are mainly concerned with process behaviour at runtime, but they also need to understand the process in order to perform problem analysis and resolution.

It is therefore clear that there exists a need for the ability to efficiently present process information as views of various formats and at different levels of granularity to meet the numerous needs of myriad stakeholders.

In the enterprise architecture domain, the availability of views is a well-established means of breaking down the description of complex systems to comprehensible parts. Views can take several forms, both graphical and textual. Tools for creating architecture descriptions, such as ARIS [33] or the system architect [25], allow for the generation of a multitude of different views.

Business processes are only one part of an enterprise architecture. The goal of using graphical notations in business process modelling is to make process models manageable despite their inherent complexity [38, 39]. However, such complexity cannot be represented in the graphical process model without negatively impacting comprehensibility. This problem necessitates the use of views to make such information accessible to stakeholders as required. Despite this need, there is still a large number of disparate paradigms offered, each providing representations that reflect the subjectivities of its advocates. Consequently, many tools have only a very limited set of views available.

A taxonomy of process views
A review of the literature provides some insight into the process views that may be important to the stakeholders described in the previous section. The list below summarises the review, categorised by the dominant process perspectives: control-flow (C), data (D), and resources (R) [58]. All views that are concerned with additional information not contained in the process specification, or those representing alternative approaches, are marked with an (A).

C: Control-flow:
   The control-flow view shows the ordering of tasks in a graphical manner by connecting them with arcs and split and join operators that model parallelism and choice. It is the dominant view in all process modelling paradigms based on Petri nets [40, 67], and flow-related languages such as BPMN [73], EPCs [59] and YAWL [68].

C: Reduced individual views:
   These views aim to present slices of complex process specifications for certain stakeholders [7, 38, 39, 61]. These reductions are also called relative workflows [77] or public and private workflows [65, 70]. The result is similar to the behaviour diagrams of S-BPM [23].

D: Data model:
   These data-oriented views present the data structures of a process and how they are populated and used during process instantiation, for example Entity-Relationship diagrams [42, 73].

D: CRUD:
   These task-oriented views show how tasks create, read, update, and delete data elements [42, 64].

R: Organisational model:
   An organisational model can contain employees, their positions, roles and capabilities, and much more [36, 40], or it can also take the form of an organisational chart [67, 73].

DC: Data flow:
   Data flow views show how data are handled by tasks [40, 42, 56, 73]. Typically, data inputs and outputs from tasks are shown graphically in a flow diagram [53, 54]. Sometimes the data themselves are not shown and only data dependencies between tasks play a role [59, 73]. Scientific workflow systems like Kepler [9] or Taverna [30] are examples of data-driven systems. Another approach is to derive the control-flow of a process from the structure of data [45], products [1, 52, 71], or documents [72].

RC: Control-flow with resources:
   The control-flow view is extended to show the resources assigned to tasks, for example via connectors in EPCs [59], or via ‘swimlanes’ in BPMN [73, 74].

DRC: Resource interaction:
   These views show the designated resource classes [67] and the data or messages they exchange during process execution. An example is the ARIS interaction diagram [59]. In S-BPM this is called process overview [23].

DRC: Sequence diagram:
   These views show an event diagram of interacting processes [73], a UML sequence diagram [14, 48] or similar to understand the dynamic behaviour of the process and to discover unnecessary steps [40]. In general, there is more than one sequence diagram for any process specification.

A: Cross-cutting:
   Cross-cutting concerns are those aspects of a process that affect several other concerns, such as data validation or authorisation. The concern-based decomposition of workflow specifications typical of aspect-oriented workflow systems provide cross-cutting views of the process [13, 35].

A: Events:
Events are often shown as annotations to the graphical control-flow view, for example the messages, timers and errors in BPMN [73], or time constraints more generally in a number of tools [6, 20]. Event-based workflows (a variant of declarative workflows) provide a view where only potential events are shown, with no preconceptions of the ordering or flow of them for each process instance [31].

A: Statistics:
   Statistical, simulation [40] or Markovian analysis [67] can be performed if XOR- and OR-splits are decorated with probabilities. This is a feature implemented in ARIS and WoPeD [24].

A: Worklist:
   A worklist represents the tasks assigned to a particular participant in a process instance, and can take many forms, both graphical and tabular. For example, a worklist may be realised as a visualisation which gives hints on which work items to choose at execution time, or to the location at which the work will take place [10, 15].

A: Constraints:
   Constraint-based workflow comprise activities and a set of rules (constraints) that specify what is allowed and forbidden during execution. The set of possible flow orderings are implicitly defined by the given constraints: anything allowed and not forbidden is possible during execution [50].

A: Exception handling:
   Exception handling often involves the invocation of extra processing steps that perform compensation activities. They are sometimes shown as branches attached to the primary control-flow or may be detached as a separate view. A specific graphical syntax for exception handling in workflows is proposed in  Russell et al. [57] and in Adams et al. [2].

A: Business objectives:
   Business objectives can be shown as linked to functions in ARIS [46], and are the dominant feature in goal-based workflow systems [37].

Table 1 High-level categorisation of view properties
Full size table
In addition to the categorisation by perspective presented above, views can also be described using a triple, where each element is one or other of each of three descriptor pairs, as shown in Table 1. The choice made in each pair relies generally on the following factors:

Overlay versus independent:
   According to Moody [44], even “apparently minor changes in visual appearance can have dramatic impacts on understanding and problem-solving performance”. As mentioned previously, the graphical representation of the control-flow perspective is the dominant concrete view of a process. For views involving tasks, it is therefore often preferable to present the view as an overlay of the control-flow view without changing the order of existing elements. In this way the view becomes an extension of the stakeholder’s existing mental model of the process. Independent views are more applicable when information cannot be cleanly added to the existing graphical control-flow view, and/or when there is a large amount of information to display.

Complete versus partial:
   Complete views have the advantage of encapsulating all relevant information in a single view that can, for example, be printed or saved as documentation. Partial views are useful when there is more information than can be reasonably encapsulated in a single view, but portions of the omitted information may be desired at times by a subset of relevant stakeholders.

Graphical versus textual:
   Graphical representations of views are typically quicker to grasp and easier to comprehend and remember than textual ones, especially when showing relations between different classes or objects. Textual views, such as matrices, provide a viable format for large amounts of related information, even if such views extend for more than one viewport (e.g. a computer screen, dialog bounds or page).

Except for those views categorised as alternative (A)—those which require access to runtime information, or to data obtained through process mining methods [66], or those that require information from external sources— the information stored within the process specification alone is sufficient to potentially derive a set of views over a process model.

Nevertheless, it is important to realise that the majority of views described in this section represent the primary or dominant view of individual systems or products. That is, the views are limited in many cases to the sometimes quite different paradigms and tools that contain them. There is no holistic approach to supporting the creation of an extensible set of disparate views from the extant information stored in a process specification. However, by transforming a process specification to an ontological definition, as described in the next section, a common basis for the generation of an extensible set of views can be established.

An ontology for process specifications
An ontology is defined by Gruber [26] as “a set of representational primitives with which to model a domain of knowledge or discourse”. That is, an ontology defines a vocabulary that can be used to unambiguously communicate information about a domain, and typically consists of concepts and objects (or classes), their properties and the relationships among them, expressed as triples. Each ontology is built at the semantic level, providing explicit meanings for its vocabulary and formal constraints on its coherent use, representative of first-order logic. As such, an ontology may be reasoned upon to produce facts derived from, and consistent with, its classes, relations and constraints. Each class may be described as a template for sets of individuals, each of which is a particular instance of its class. This allows for base ontologies to be augmented with instantiations, so that those instances may also be reasoned upon, using the same relations and constraints that define the underlying vocabulary.

Ontologies are employed in various ways across a broad range of information systems-related research domains as diverse as knowledge engineering, qualitative modelling, database design, knowledge management and organisation, natural language translation and geographical and biological information systems [27]. Ontologies offer a wide range of semantic expressiveness, from simple lists to knowledge bases that allow for the dynamic inclusion of new arbitrary types of relationships between concepts [32].

The W3C Semantic Web standard provides the Web Ontology Language (OWL) [75] as a specific formalism for encoding ontologies. OWL allows an ontology to be encoded as a formal specification of an abstract data model, independent of its particular native form [26]. An advantage of encoding an ontology in OWL is that it provides logical extensions for reasoning about classes and properties. For example, it allows classes to be defined as disjoint, or as the intersection of two other classes. It also allows properties to be denoted as, for example, transitive, symmetric or functional, or for one to be defined to be the inverse of another.

As described earlier, a business process model is an abstract, necessarily simplified definition of an underlying business practice. It contains information and descriptors defining the business process from a number of perspectives (primarily including control-flow, data and resourcing), and as such can be said to represent a domain of knowledge as objects, concepts and properties, and the relationships that hold among them. However, they are typically stored in language-specific formats (e.g. XML documents) that lack the structure necessary to allow them to be reasoned upon in a generic way.

By providing a means to transform the objects and properties able to be defined in a process specification language into the classes, properties and rules of an OWL ontology, any particular model based on that language may be represented as an instantiation of the ontology, where all of the (non-runtime) details of the given process are encoded within it, together with a set of individuals and assertions that can be reasoned upon. In this way, an ontology can capture the wider semantics of any process specification, as well as the internal semantics of individual tasks within it (such as data and resourcing information) [32]. The ability to reason upon and query the ontology supports the derivation of an extensible set of process model views, precluding the need to ‘hard-wire’ view descriptors and properties into a modelling tool.

Deriving a base ontology
In this and later sections, the YAWL process language is used to illustrate our approach. YAWL was chosen for its expressiveness, its relatively small object set, and the support it offered to realise the approach as an extension of the open-source YAWL system. However, the choice of YAWL as the exemplar language should not be seen as a preclusion of the generic nature of our approach; in fact, our approach is extensible to other activity-centric modelling languages (cf. Sect. 4.1.1). In capturing the objects, properties and relationships of a YAWL specification within an ontology, the aim was to avoid superfluous detail while still providing all the information required to implement the views described in Sect. 5. The base ontology and rule set have been published on GitHub and are readily available for downloadFootnote1.

The construction of a YAWL specification has much in common with those of other activity-centric process languages. In YAWL:

Control-flow:
   A specification is made up of a number of nets, one of which is the root or parent net, with all others designated as subnets. Each net contains a number of net elements, which may be either a task (conceptually a Petri net transition) or a condition (conceptually a Petri net place), and a set of flow-relations (directed arcs) that join the net elements together, thus defining the control-flow of the specification. Two special types of condition are defined: an input condition that denotes the condition that begins the control-flow for the net and an output condition that denotes the condition that ends it.

Data:
   A net is a type of decomposition, which defines the data parameters (variables and their types) input to and output from it. A task may also be associated with a decomposition, which defines the data input parameters and output parameters for that taskFootnote2. For each parameter in a decomposition, a mapping may be defined that assigns a value (for an input parameter) typically from a net-level parameter, and another that assigns a value (for an output parameter) typically to a net-level parameter. Each mapping contains an expression that defines the value to be assigned.

Resources:
   A task may be assigned to one or more roles and/or one or more individual participants. A role is defined as a related set of individual participants.

Fig. 2
figure 2
Ontology objects

Full size image
The italicised terms in the description above correspond to the object types of the base ontology, as shown in Fig. 2. Each ontology object is matched directly from its specification equivalent, except for the Mapping and Expression objects, which are represented as complex data properties within the specification, necessitating their construction as objects in the ontology. All are directly sourced from the specification document, as are the following object properties (the bolded object is denoted as the domain of the property, those objects in parentheses represent the range of each property):

Specification:
hasDecomposition (net).

Net:
hasInputCondition (condition), hasOutputCondition (condition), hasNetElement (net element).

Task:
decomposesTo (decomposition), flowsInto (net element), hasInputMapping (ma-pping), hasOutputMapping (mapping), hasRole (role), hasParticipant (participant), hasFamiliarTaskFootnote3 (task), hasFourEyesTaskFootnote4 (task).

Mapping:
hasExpression (expression), mapsTo (parameter).

Expression:
refersTo (parameter).

The flowsInto property of a task has as its range the immediately subsequent net element (or elements) according to the control-flow definition of the specification. From these property definitions, OWL provides for the following derived properties:

flowsFrom as the inverse of flowsInto.

hasPredecessor as the transitive of flowsFrom.

The ability to easily derive these two properties greatly simplifies the traversal of a net (a base requirement for the derivation of many views). The set of objects, properties and relations described above represent the core facts of the ontology.

Applicability to other languages
As mentioned above, YAWL was chosen as the exemplar language for this article for many reasons, most notably because it provided the platform for an implementation as an extension to an existing system environment (cf. Sect. 5). However, that choice by no means precludes the applicability of our approach to other activity-centric process modelling languages. While the object names in the ontology derive from their equivalent YAWL components and relations, the conceptualisation of each object can be directly mapped to objects in other languages. That is, the object names are simply labels, the components and relations they represent directly correspond to the equivalent components and relations of other languages.

For example, Table 2 lists the YAWL object labels applied to the ontology, and the BPMN components that are their equivalents. Just as a YAWL specification must be parsed to populate the ontology, so must a BPMN specification be parsed to populate the same, unchanged ontology with the components and relations within it by assigning the relevant facts to the objects and relations of the ontology (cf. Sect. 4.3). That is, while the mechanism for the parsing of a process specification to populate the ontology is particular to each language, there are no modifications that are required to be made to the ontology itself to accommodate the population of specification details that have been described in different process languages.

Table 2 Object class equivalence mappings YAWL ↔ BPMN
Full size table
Adding rules to the base ontology
An ontology may be augmented with rules that can be interpreted by a reasoner (i.e. a logical inference engine) to derive new inferred facts from the ontology, which are then made available for querying in the same way as any other fact. A number of such rules were added to the base process ontology to support simplified querying that returns information appropriate for populating a variety of views. A selection of interesting derived facts is detailed below.

Basic rule syntax consists of one or more premises leading to one (or more) conclusion(s). Each premise and conclusion typically takes the form of a triple. The conclusion is reached if the conjunction of all premises is logically consistent.

All terms beginning with a question mark (?) represent variables into which individuals that form the domain (preceding) or range (succeeding) of the specified property may be substituted. The colon at the beginning of property terms in the following examples represents a shortened prefix for the ontology namespace (a unique identifier prefix for the ontology).

Extension of the flowsInto property
figure d
A task object may define an atomic task, or it may define a composite task (i.e. a container task that decomposes to a subnet, i.e. a subprocess). This rule extends the flowsInto property so that an element prior to a composite task (i.e. a task that decomposes to a subnet) may be considered to flow directly into the first task of that subnet. This, and a complementary rule for flow out of a subnet to its parent net, effectively allows for the control-flow of a specification to be queried as a continuous flow for any number of nets (rather than each net being considered to have its own flow). These two rules greatly simplify traversal through multi-net specifications.

The rule may be read as follows: If a net element Element flows into a task Task AND Task decomposes to net Net AND Net has input condition InputCondition (only composite tasks can have a decomposition containing an input condition) AND InputCondition flows into a task SubNetTask THEN we can infer that Element flows into SubNetTask.

Data values assignment
figure e
This rule is required so that output data assignments between task (i.e. local) and net (i.e. global) variables can be discovered. It effectively deals with the particular way in which YAWL data assignments are defined within a specification, where a mapping has an expression that may refer to a task variable, and a mapsTo property that defines the net variable the value is to be assigned to.

Data flow
figure f
This rule allows for the discovery of data flow for all data through a specification. It relies on two other derived properties: readsDataFrom (a task reads a value from a particular net variable) and writesDataTo (a task writes a value to a particular net variable). Then, using the hasPredecessor property (a transitive property of the inverse of flowsInto), we can say that where a task Task1 that writes to a net variable occurs prior to (in control-flow terms) a task Task2 that reads from that same variable, then it can be said that Task2 has data predecessor Task1.

Resource flow
figure g
This rule succinctly defines the resource-flow of a specification, that is which roles pass work to other roles. It makes use of the flowsFrom property (the inverse of flowsInto).

This selected sample of rules exemplifies the ease with which new facts can be derived from the existing objects and properties of the base ontology, allowing a great deal of knowledge to be added without having to rely on hard-wired programming to define all the necessary relations. Perhaps more importantly, the set of rules can be extended at any time (cf. Sect. 5.2.4).

Populating the base ontology with facts
After creating the base ontology and defining the required additional rules, the ontology can then be populated with the information stored within a process model specification, so that the actual individual objects, constructs and relations described in the process model instance (i.e. the facts of the model) can be queried and reasoned about.

The procedure can be illustrated with reference to Fig. 1, which shows a control-flow view of the top-level net of a simple procure-to-pay process. The information displayed in this view is stored in a specification document, along with all of the information relating to data and resourcing perspectives of the process. The specification document is an XML document generated by the modelling tool, capturing a complete description of all three perspectives in a transportable XML format. The modelling tool reconstructs the process definition by loading and parsing this XML representation. Listing 1 shows a small snippet of the specification XML document for the process, illustrating how information is stored within the document.

The document must be parsed so that all the objects and properties specified for the process may be extracted and used to populate the base ontology. Each object is referred to as an individual, and related individuals form a set of objects representing the domain and/or the range of a base fact. For example, the net shown in Fig. 1 becomes an individual member of the set of nets in the process, which represents the domain of relations such as hasInputCondition and hasOutputCondition (discussed in the previous section). The set of task individuals belonging to the net, for example ‘Confirm availability’, ‘Approve rental request’, ‘Cancel request’ etc., form the domain of some relations (e.g. hasInputMapping, hasRole), the range of others (e.g. hasNetElement) or both domain and range (e.g. hasFamiliarTask, flowsInto). The binding of individuals to base object classes proceeds for all objects in the specification.

Once all the individuals have populated the ontology, the properties and relations assigned to each object in the specification document are also parsed and transferred to the relevant properties and relations defined within the ontology. For example, a task element in the document shown in Listing 1 contains a nextElementRef element defining the identifier property of the next subsequent task in the control-flow. Thus, the flowsInto relation between the two tasks can be defined within the populated ontology.

The ability to populate a base ontology with the individual instances, properties and relations of a process model specification provides a powerful method for structured classification over which reasoning may be applied to infer semantic data not easily derived from the proprietary format of the underlying specification document.

figure h
Querying the ontology
The populated ontology may be queried using the SPARQL query language, designed by the W3C RDF Data Access Working Group [76] for accessing knowledge contained in ontology models. SPARQL regards an ontology as a database consisting of a set of “subject-predicate-object” triples. An example of a basic SPARQL select query is:

figure i
This query returns a list of triples, each comprising the name of a task and its associated roles for all tasks that have at least one role associated. This is achieved by matching the pattern in the WHERE clause against all of the triples in the ontology. The hasRole predicate in the clause is a fixed value (i.e. it does not represent a variable), so only triples with a matching predicate will be returned. A term preceded by a question mark (?) denotes a variable and as such will match any value in that position in all matching predicates.

SPARQL queries provide an easily implemented method for extracting information from the ontology and thus are used extensively when creating views of populated ontology content, as detailed in the next section.

Implementation
A realisation of the conceptual overview described in the previous section has been implemented as a plugin for the YAWL process editor tool, which serves to illustrate some of the features of the approach, and provide some examples of the kinds of views that can be generated from a populated ontological model. As a plugin, the implementation is a discrete module that does not require any changes to be made to the underlying editor tool. Thus, the described framework provides an abstraction layer that serves to demonstrate the applicability of the approach for other process modelling environments.

Architecture
The system architecture for the implementation is shown in Fig. 3.

Fig. 3
figure 3
System architecture of ontology views plugin

Full size image
The first time a user requests a view, via a button click or menu selection within the process editor tool, initialisation of the ontology model begins. The Specification Parser parses the process specification (natively expressed as an XML document) to extract its member object definitions, then creates the unique individuals and properties that compose and describe the specification. This specification parser component is modelling language specific and so is pluggable to accommodate various other modelling languages and their specification formats; this is the only architectural component that needs to be substituted if another language is to be used. The Ontology Populator then loads a copy of the Base Ontology from file and injects the parsed individuals and properties into it, producing a Populated Model of the specification’s ontology. Once the model is initialised, it is ready to be interrogated by the Reasoner, which itself is initialised by loading two sets of inference rules from file, one core set of rules (i.e. the rules that define the properties and relations of the base ontology) and the other a set of user-defined rules (if any have been defined).

Each particular view request generates a number of SPARQL queries that are processed by the Query Interface then applied to the populated model by the Reasoner. The result sets returned from the Reasoner are then passed through the Visualiser, which generates the requested view and returns it to the process editor for display.

The plugin uses the YAWL Process EditorFootnote5 core libraries to parse the specification, the Apache JenaFootnote6 libraries to assist the building, maintenance and querying of the ontology model, the PrefuseFootnote7 library to generate radial graph displays (if required by the chosen view) and the Apache POIFootnote8 libraries to save ontology triples to Excel file format (when selected by a user). The plugin and all libraries are Java-based and open source. The completed plugin can be downloaded from the YAWL repositoryFootnote9.

Realised views
While by no means exhaustive, the implemented views illustrate various ways in which result sets extracted from the populated ontology may be used to generate effective visualisations. Three of the implemented views are briefly described below, categorised using the definitions from Sect. 2. Examples of each view in this section use the case study “Procure to Pay” (P2P) [19] and its implementation as a YAWL process in Hense and Malz [29]. The basic control-flow view of the top-level YAWL process net can be seen depicted in Fig. 1.

Resource control-flow overlay [RC(O,C,G)]
This view produces an overlay on the graphical control-flow view of a process model (Fig. 4) to depict resourcing information. The visualisation assigns a particular colour to each Role allocated to tasks within the model, which are used to overlay the default colouring of each task to visually indicate how each task is resourced. A ‘key’ table is also displayed that links each designated colour to the name of the Role it represents. All of this resourcing information is usually hidden from immediate view, that is the default control-flow view, and only accessible via property settings in various dialogs, so the advantages of presenting that information visually via an overlaid view are clear. All changes in the underlying resourcing properties are immediately reflected in the overlaid view via an automatic refresh of the populated ontology model. This view, like all others implemented, can be displayed or removed at any time by user selection.

Fig. 4
figure 4
Resource overlay view

Full size image
According to Moody [44], “color is one of the most cognitively effective of all visual variables”. People are highly attuned to colour variations, which are detected three times faster, and are more easily remembered, than differences in shape, for example [44]. Also, an overlay makes no changes to the mental model a stakeholder will already have of the underlying graphical control-flow, thereby eliminating any threat of cognitive stress. The information provided by the overlay is seen as an enhancement of the control-flow view, rather than a distraction from it.

Further, tasks related by a ‘familiar task’ constraint may have that relation displayed as a green dotted arc between them, while those related by a ‘separation of duties’ constraint are joined by a red dotted arc, if chosen by the user. The result can be seen in Fig. 5. All resourcing constraints between tasks within the net are discovered by executing two simple queries against the ontology model:

SELECT ?Task1 ?Task2 WHERE { ?Task1 :hasFamiliarTask ?Task2 }

SELECT ?Task1 ?Task2 WHERE { ?Task1 :hasFourEyesTask ?Task2 }

A high-level view of resourcing is desirable for subject matter experts and managers. The use of a colour-based overlay in this implementation provides a clear understanding of how the specification is resourced, without having to constrain or modify in any way the control-flow layout (unlike the swimlanes approach of BPMN and others) or annotation by text or icon (such as resource depiction in EPCs).

Fig. 5
figure 5
Resource overlay view with constraint information added

Full size image
Resource-flow graph [RC/DRC(I,P,G)]
This view displays the flow of work among resources for the process as a radial graph (Fig. 6). Flow is shown as directed arcs and is bidirectional where work flows from one role to another and back again. The view’s content can be restricted by the user selecting or deselecting particular roles. The graph can be manipulated by the user to change the arrangement of its nodes as an aid to viewer comprehension.

Fig. 6
figure 6
Resource relation graph view

Full size image
There are four subviews available:

Data-flow Shows a directed temporal relation between roles R1,R2 when R1 assigns a value to a variable and, sometime later in the process, R2 reads the value of that variable.

Data-flow (strict) Shows a directed temporal relation between roles R1,R2 when R1 assigns a value to a variable and, in the next immediate task, R2 reads the value of that variable.

Control-flow Shows a directed temporal relation between roles R1,R2 when R1 performs a task and, sometime later in the process, R2 performs a task.

Control-flow (strict) Shows a directed temporal relation between roles R1,R2 when R1 performs a task and R2 performs the next immediate task.

Whenever data are tightly bound to a process, that is where all or most tasks work with the same data set, the content of the data-flow graph will converge to that of the control-flow graph.

Stakeholders with concerns about data security are obvious clients for this view, since it shows which resources have access to particular data, and in what sequence the data are accessed. This view will be more concise than a UML sequence diagram in many cases, and since it is interactive, relations between particular role subsets can be highlighted.

Task-variable I/O matrix [DC(I,C,T)]
This view shows an alternate representation of the relations between tasks and data variables in a process specification (Fig. 7). Rather than a graphical layout, a matrix is displayed that shows every task (X-axis) mapped against every variable (Y-axis), and which of those tasks reads from (R) and/or writes to (W) each variable.

The tasks in the matrix are listed in control-flow order, meaning that the flow of data variable reads and writes is shown left-to-right across the matrix, replicating the natural flow order of the standard graphical control-flow process model representation. When generating this view, the ordering is determined by comparing the hasPredecessor relation for each task pair. Where each task in a pair was a predecessor of the other (representing a loop in the control flow), ordering was determined by which has the shortest path from the net’s input (i.e. starting) condition, using flowsInto relations.

Fig. 7
figure 7
Task-variable matrix

Full size image
Adding new rules
New user-defined rules can be added to the ontology at any time, via the ‘user-defined rule editor’ component of the plugin. Once the rule has been validated and saved, it is made available to the ontology for use in the creation of new views. New properties may also be added to the base ontology, using existing objects for domain and range. For example, a new property called loopsWith may be created in the base ontology, with both a domain and range of a task object, to define those tasks that appear in a loop of the control-flow. Then, a new rule can be created:

figure j
Finally, a query of the form:

figure k
will return all of the pairs of tasks that appear in a loop together. A coloured overlay view can then be constructed to show all related pairs.

Evaluation
To assess the usefulness and applicability of our approach, we conducted a series of interviews with five BPMS experts in Europe and North America, all of whom have had experience using the YAWL process modelling tool. Most of the experts also indicated proficiency with other BPMN-based systems, including jBPMFootnote10, BizagiFootnote11, BonitaFootnote12 and Oracle BPM SuiteFootnote13. During the interviews, participants were shown a process model from the YAWL4Film project [49], designed to support those activities that could be automated within the process of film production. Interviewees were then shown several views based on that original model and asked for their opinions on whether the views added value in terms of comprehensibility and insight.

Fig. 8
figure 8
YAWL4Film process diagram (editor default view) [49]

Full size image
Figure 8 shows the YAWL4Film process model as it appears by default in the process modelling tool. Note that the icons decorating many of the tasks were added by the original modeller and do not form part of the specification language. Within the model, three phases can be recognised:

1.
Initialisation The first five tasks of the process, which involve the loading of various cast, crew, location and scheduling information.

2.
Call sheet The remaining tasks within the bottom sequence, concerned with the creation and distribution of the call sheet (i.e. the daily shooting schedule).

3.
DPR The group of tasks at the top of the model that are designed to produce and distribute the daily progress report (DPR).

These three phases were pointed out to each interviewee, who was then asked to respond to three specific questions:

1.
Where are the cast list, crew list and location notes, once loaded during the initialisation phase, referred to in the remaining phases of the process?

2.
How are the call sheet and DPR phases linked, in terms of data objects?

3.
Which resource roles participate in each of the three phases?

After considering question 1, the interviewee was shown the Task-variable I/O matrix view, similar to the example shown in Fig. 7. When asked whether that view afforded additional insight and greatly helped in answering the question, four agreed and one strongly agreed. One expert would have liked the ability to highlight particular rows and columns when clicked, while another suggested the ability to reduce the matrix to only those rows and columns selected. Another expert proposed the ability to reorder tasks and variables (currently the view orders tasks based on control flow, while data variables are ordered alphabetically), similarly another noted that loops in the control-flow posed problems for task ordering. Finally, another expert requested the ability to drill-down for subnets (currently all tasks and variables are shown at the same level, prefixed by the name of their containing net).

Fig. 9
figure 9
Task-variable relation graph view

Full size image
For question 2, after some consideration the task-variable relation graph view was shown to the interviewee, as shown in Fig. 9. This view provides a list of all tasks and data variables, from which selections can be made. The graph then illustrates the connections between the selections, where directed arcs indicate the direction of information flow (e.g. an arc from a variable to a task denotes that the variable is input into the task). The experts were again asked if the view afforded additional insight and greatly helped in answering the question. Here, three agreed, while two remained neutral. One expert felt this view was a good complement to the previous matrix view, although the graph had the potential to become cluttered with more than a few selections. One expert said he would like to see this graph as an overlay over the standard control-flow view of the process, essentially transforming the view from a Data I/O Graph [DC(I,P,G)] to a new Data I/O Overlay [DC(O,P,G)]. Another suggested that deselections should be ‘assisted’. Two experts felt that the inclusion of the containing net prefix cluttered the graph and should probably be omitted.

The final view shown to interviewees, after reflecting on question 3, was the resource overlay view, similar to that shown in Fig. 4. Here, when asked whether the view afforded additional insight and greatly helped in answering the question, four experts strongly agreed and one agreed. One stated this view would be of great benefit in other tools (Bizagi was specifically named) and provided a better view of resources over tasks than the BPMN pools and lanes approach. Others suggested potential enhancements: the ability to select a subset of particular resources/colours, to have separate toggles for constraints (rather than the current all-or-none choice) and the use of abbreviated text instead of colour.

Table 3 Summary of expert responses (5-point Likert scale)
Full size table
A summary of responses is shown in Table 3. All of the interviewed experts agreed that the ability to generate different views over a process specification afforded new insights into the process and greatly assisted in the comprehensibility of models. In particular, all responded very favourably to the Resource Overlay view.

Related work
Section 2 categorises related literature in the area of process model views. Many of the approaches described in that section arose from research into the types of views that were found to be beneficial to stakeholders. However, besides the basic graphical control-flow perspective, each of the remainder is limited to one or two disparate tools (i.e. no one tool provides more than a handful of views) and none are based on a common ontology.

The related work with reference to user-selectable process views is quite sparse. Further, no references could be found that mention the use of a common ontology for the generation of process model views.

Figl et al. [21] provide an analysis of the usability of different process modelling languages, in terms of their graphical expressiveness, clarity and user perceptions. However, only a control-flow view is considered. The presentation of a process model view with user-selectable granularity is discussed in Caetano et al. [12]. The view is graphical control-flow based with annotations at various hierarchical levels. No other view types are available, and no ontology is built.

Most of the literature with respect to the application of ontological frameworks to process modelling is concerned with providing assistance to the verification, understandability, constraint definition, grammars and semantic correctness of processes. A formal ontological description of the BPMN language is provided in Rospocher et al. [55], which is then used as a semantic artefact from which ontological reasoning services such as consistency and compliance checking (i.e. verification and validation) of a BPMN specification may be performed. Similarly, Thomas and Fellmann [63] proposes a formal ontology where the semantics for process model elements can be represented by ontological terms using natural language. The goal here again is verification and validation of process specifications. The same goals are cited in Filipowska et al. [22] and Cabral et al. [11], which each describe a set of ontologies to support semantic BPM.

A meta-language is conceived in De Nicola et al. [16] that has the primary goal of providing a formal semantics for BPMN, and to facilitate sharing and reuse among process-implementing tools. A similar approach is taken in Nguyen and Le Thanh [47] for Coloured Petri Nets (CPN), and in Aslam et al [3] using BPEL as a base language. Born et al [8] propose the development of a ‘business functions ontology’ so that process models can be built using a common labelling grammar, with the goal of improving consistency and understandability among stakeholders. A related approach is presented by Markovic and Kowalkiewicz [41], where an ontology for modelling business goals, which can be linked to process models, aims to enrich process description and analysis. Di Francescomarino et al. [17] also present an approach that annotates process models with information sourced from an ontology based on a set of correctness criteria to assist in the verification of models. A foundational ontology is presented in Guizzardi and Wagner [28], which may be used to guide process modelling and evaluate the modelling methods used.

Future work and conclusion
This paper discussed the advantages of deriving an extensible set of views from a common ontology for business processes and presented a realisation as a plugin to the YAWL environment that illustrated the types of views that may be generated. Examples of graphical overlays, graph-based relationship maps, tables and matrices were described and shown, which attest to the applicability of the approach, and serve as a means for validation by representing the most common view categories across a number of BPM products and tools. A favourable evaluation of the approach by domain experts further corroborates its usefulness and extensibility. The paper also demonstrated how a process ontology can be extended at any time through the addition of new properties and rules that immediately provide the basis for new views.

Currently, the knowledge base is limited to the information contained in the static process specification document (i.e. design time information). An avenue for future work is to extend the functionality by incorporating process engine runtime information, as well as information stored in supporting services, such as those that handle runtime resourcing decisions, exception handling, scheduling and cost estimation. Another avenue of future work would involve user testing as a form of validation. This can be achieved by collecting user statistics on an opt-in basis.