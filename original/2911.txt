Morris (Rev Econ Stud 67:57–78, 2000) defines the p-cohesion by a connected subgraph in which every vertex has at least a fraction p of its neighbors in the subgraph, i.e., at most a fraction (1−p) of its neighbors outside. We can find that a p-cohesion ensures not only inner-cohesiveness but also outer-sparseness. The textbook on networks by Easley and Kleinberg  (Networks, Crowds, and Markets - Reasoning About a Highly Connected World, Cambridge University Press, 2010) shows that p-cohesions are fortress-like cohesive subgraphs which can hamper the entry of the cascade, following the contagion model. Despite the elegant definition and promising properties, to our best knowledge, there is no existing study on p-cohesion regarding problem complexity and efficient computing algorithms. In this paper, we fill this gap by conducting a comprehensive theoretical analysis on the complexity of the problem and developing efficient computing algorithms. We focus on the minimal p-cohesion because they are elementary units of p-cohesions and the combination of multiple minimal p-cohesions is a larger p-cohesion. We demonstrate that the discovered minimal p-cohesions can be utilized to solve the MinSeed problem: finding a smallest set of initial adopters (seeds) such that all the network users are eventually influenced. Extensive experiments on 8 real-life social networks verify the effectiveness of this model and the efficiency of our algorithms.

Access provided by University of Auckland Library

Introduction
Graphs have been widely used in many real-life applications. A variety of cohesive subgraph models are proposed for graph analysis, including k-core, k-truss, clique, p-cohesion and so on. Given a graph and a real number p∈(0,1), a p-cohesion is defined as a connected subgraph where every vertex has, at least, a fraction p of its neighbors in the subgraph [29]. This definition implies that every vertex in a p-cohesion has, at most, a fraction (1−p) of its neighbors outside of the p-cohesion. The advantages of the p-cohesion model over other existing cohesive subgraph models are twofold: First, with a large p value, we can find a p-cohesion ensures not only inner-cohesiveness, as the vertices inside a p-cohesion are cohesive; but also outer-sparseness, as the outside neighbors of the p-cohesion have a sparse connection to the p-cohesion; second, in many applications, it is more natural to consider the percentage of the neighbors instead of the same number of neighbors (such as the k value in a k-core) within the cohesive subgraph. For instance, in real-life social networks, a large-degree user may need more neighbors than a small-degree user to encourage her/him to adopt a behavior [4].

The p-cohesion is also related to the contagion model, which is introduced in [29] to study the interaction of large populations: Given a graph with some initial adopters of a behavior “A” and a cascading threshold r∈(0,1), a user will adopt “A” if at least a fraction r of his/her neighbors already adopted “A.” Clearly, with the contagion model, for any p-cohesion S with p>(1−r), none of the users in S will adopt “A” if S does not contain any initial adopters; in other words, the influence coming from outside of S alone cannot affect any user in S. In this sense, a p-cohesion is a fortress regarding the contagion model.

Fig. 1
figure 1
A Graph, p=0.6

Full size image
Example 1
Figure 1 shows a small graph. Suppose p=0.6, we use the gray-filled rectangles to label every user u with the smallest number of neighbors required for u to stay in a p-cohesion. A minimal p-cohesion S is marked in the dashed circle, which is the subgraph induced by vertices u1, u2, u3, u4 and u5. Suppose r=0.5 in the contagion model and there is no initial adopter in S for product “A,” any user in S will not adopt “A” even if all the other users (not in S) adopted “A.”

The fortress-like cohesive subgraphs (i.e., p-cohesions) are critical for information diffusion related applications. They may be information islands in social networks, focalization in viral marketing, etc. We may benefit from exploiting the fortress property of p-cohesions. For instance, in viral marketing, it is usually hard to peddle a new product to homogeneous users in social groups (e.g., p-cohesions) who use another competing product, while these users form a business focalization [12]. Offering incentives such as discounts or free product trials to users in p-cohesions may help in the successful marketing of a new product.

In this paper, we are interested in the minimal p-cohesion problem where we say a p-cohesion S is minimal if there does not exist a proper subgraph S′ of S (S′⊂S) which is also a p-cohesion. This is because: (1) they are elementary units of p-cohesions, and the union of multiple minimal p-cohesions forms a larger p-cohesion; (2) we may avoid enumerating an overwhelming number of p-cohesions; and (3) it is more useful to find small fortresses in influence-related applications. For instance, it is immediate that the whole graph or a connected component is a p-cohesion for any p value, but this is not interesting.

Minimal p-cohesions also enable us to find good heuristics for the MinSeed problem under the contagion model; that is, given a target graph and a cascading threshold r, find a minimum set of seeds such that the whole graph is eventually influenced. The minimal p-cohesions can hinder the entry of cascades to it, and the vertices inside a p-cohesion are relatively isolated from the outside vertices. Therefore, by giving certain priorities to seed the vertices inside the minimal p-cohesions, we may break the entry barriers of the p-cohesions by the great influence power of the selected seeds. The p-cohesion can thus benefit the applications of influence studies, e.g., viral marketing and online fraud control [18].

In this paper, we study two representative problems with regard to the p-cohesion model: minimum p-cohesion search and diversified p-cohesion enumeration.

Minimum p-cohesion search aims to find the smallest p-cohesion containing the given query vertex, i.e., the p-cohesion with the smallest number of vertices to which a user (query vertex) belongs. We show this problem is NP-hard, and some heuristics are proposed to efficiently identify a p-cohesion with a small size for the given query vertex.

Diversified p-cohesion enumeration aims to find a set of disjoint p-cohesions which can cover as many vertices as possible. Here, we consider diversity because, in practice, the user may be overwhelmed by the exponential number of minimal p-cohesions. Thus, in this paper, we design efficient algorithms to find a set of disjoint minimal p-cohesions.

Contributions
Despite the elegant definition and promising properties of the p-cohesion model, to our best knowledge, there is no study on the problem hardness or the efficient computing algorithms. The major contributions of this paper are as follows.

On the theoretical side, we prove that (1) the problem of finding the smallest p-cohesion is NP-hard and it does not admit any constant-factor approximation, unless P=NP; and (2) the number of minimal p-cohesions can be exponential in the graph size. On the practical side, we propose efficient algorithms to find a small p-cohesion containing a query vertex, as the basic computing unit for p-cohesion related computations. Due to the huge number of p-cohesions, we also propose efficient algorithms based on the computing unit to identify a set of disjoint minimal p-cohesions. As an application example, the algorithms are applied in the MinSeed problem to reduce the seeding cost, by carefully utilizing the fortress property of p-cohesions. Comprehensive experiments are conducted to demonstrate the effectiveness of p-cohesion on modeling cohesive subgraphs, compared with other classical cohesive subgraph models. Due to the fortress property, the proposed algorithms are also effective on solving influence problems such as influence maximization, under different influence cascade models. Extensive efficiency reports show that our algorithms can fast return on large real-life graphs.

Related work
Cohesive subgraph models
Various subgraph models are proposed to accommodate different scenarios, including p-cohesion studied in this paper. Clique [11, 26] is the most cohesive subgraph where every two vertices are adjacent. Because of the over-restriction of the clique model, some clique relaxation models are proposed such as k-plex [34], k-core [21, 25, 33], k-truss [9, 44], k-fami [43] and dense subgraph [13, 31], to name a few. It is intractable to compute some models such as clique enumeration and finding the densest k subgraph, as there is no polynomial-time algorithm existed.

Some cohesive subgraph works aim to discover small-size subgraphs. Amini et al. [2] study some degree-constrained subgraph problems including the minimum-size k-core search. Cui et al. [10] propose efficient algorithms to locally search the k-core. Barbieri et al. [5] propose greedy algorithms to search the minimum k-core for one or multiple query vertices. Wood et al. [39] study the k-assemblies based on minimal k-core computation. The above cohesive subgraph models only consider the cohesiveness inside the subgraphs and ignore the interactions from outside. The work most-related with p-cohesion is the k-defensive alliance [15, 32, 41] which finds a subgraph S where each vertex v in S has at least k more neighbors in S than out of S. When k=0, the model corresponds to the p-cohesion with p=0.5. However, there is no such mapping between the two models for an arbitrary p value. We stress that none of the above subgraph models possess the fortress property of p-cohesion to defend the influence of information cascades.

According to the definition of p-cohesion [29], different vertices in a p-cohesion subgraph need different number of neighbors inside the subgraph to remain engaged. Therefore, it is infeasible to apply the methods with fixed threshold for each unit (vertex or edge), e.g., k-core and k-truss computations. The framework of clique enumeration [7] can be utilized to find minimal p-cohesions, while this exact solution can only handle very small graphs, e.g., it cannot finish in one week for a graph with 80 vertices in our experiments. It is consistent with the hardness results of p-cohesion computation proved in this paper: Finding the minimum p-cohesion is NP-hard to approximate for any constant factor, and there are graphs with an exponential number of minimal p-cohesions.

Influence cascade models Morris [29] introduces the contagion model and p-cohesion to characterize social choices in local interaction systems. The paper also studies the diffusion of a behavior from a finite set of initial adopters to all network users. Ugander et al. [37] show that the contagion probability of a user is strongly influenced by his local neighbors, e.g., neighbors in cohesive subgraphs. Zarezade et al. [42] study correlated cascades based on the fact that the adoption of a behavior by a user is influenced by the aggregation of the behaviors of his/her neighbors. Easley and Kleinberg [12] make the same observation as the above in various applications. They further emphasize the contagion model and the p-cohesion that it is difficult for new innovations to enter tightly knit social groups (i.e., p-cohesions), because people tend to interact with their friends or acquaintances.

In addition to the contagion model, there are some other information cascade models, such as independent cascade model (IC) and linear threshold (LT) model [19], where the influence maximization problem and seed minimization problem have been extensively studied, e.g., [3, 16, 35, 45]. It uses polynomial time to compute the influence spread of given seeds in the contagion model, while this influence computation is NP-hard for both IC and LT models [27]. For a set of seeds, the spread area of their influence is certain in contagion model, while the influence spread is uncertain and complex in IC and LT models due to the possible world assumption.

Table 1 Summary of Notations
Full size table
Preliminaries
Assume there is an unweighted and undirected graph G=(V,E) with n vertices and m edges, where V (resp. E) represents the set of vertices (resp. edges). S denotes a subgraph of G. Let N(u, S) denote the set of adjacent vertices (i.e., neighbors) of u in S. Let deg(u, S) denote the number of vertices in S which are adjacent to u. We may omit the target graph in notations when the context is clear, e.g., using deg(u) instead of deg(u, G). In this paper, if a vertex is deleted, its incident edges are also deleted accordingly.

The contagion model in [12, 29] defines the following cascading condition when some vertices are activated and the others are not.

Definition 1
Cascading Condition. Given a graph G and a cascading threshold r∈(0,1), an inactivated vertex u∈V(G) will be activated iff the number of activated neighbors of u is at least ⌈r×deg(u,G)⌉.

The cascades in a graph may imply some interesting subgraphs which are named p-cohesions.

Definition 2
p-Cohesion. Given a graph G and a real number p∈(0,1), a connected subgraph S is a p-cohesion of G, denoted by Cp(G), where deg(u,S)≥⌈p×deg(u,G)⌉ for every vertex u∈S.

Easley and Kleinberg [12] prove that the p-cohesion subgraphs have the “fortress” property to hamper the progression of information cascades.

Property 1
“Fortress.” Given a graph G and a real number p∈(0,1), for an arbitrary p-cohesion S of G, according to the Cascading Condition (Definition 1) with threshold r>1−p, no vertex in S can be activated when all vertices in S are inactivated initially, even if all the vertices in V(G)∖V(S) are activated.

Definition 3
Minimal p-cohesion. Given a graph G and a real number p∈(0,1), a p-cohesion S of G is called minimal if it is an elementary unit of p-cohesion, i.e., every proper subgraph S′⊂S is not a p-cohesion.

Problemstatement Given an undirected and unweighted graph G, and a real number p∈(0,1), we aim to develop algorithms for the following two representative problems: (1) M––inimum p–-C––ohesion S––earch (MPCS): Given a query vertex q, find the smallest p-cohesion containing q in G; and (2) D––iversified p–-C––ohesion E––numeration (DPCE): Enumerate a set of disjoint minimal p-cohesions.

Minimum p-cohesion search
In this section, we study the minimum p-cohesion search problem, i.e., MPCS. Firstly, we analyze the complexity of the problem, and then present the solution.

Problem analysis
In this section, we prove that the MPCS problem is NP-hard to approximate for any constant factor. Let MinPC denote the computation to find the smallest p-cohesion in G (without query vertices).

Fig. 2
figure 2
Construction Example of Theorem 1, p=12

Full size image
Theorem 1
The MPCS problem is NP-hard, for any fixed p∈(0,1).

Proof
We prove the hardness of MPCS by the hardness of finding a minimum p-cohesion in G without query vertices, i.e., MinPC. If there is a polynomial solution for MPCS, we can immediately come up with a polynomial solution to find the minimum p-cohesion in G (MinPC) by conducting MPCS on every vertex.

For MinPC, we show a reduction from Vertex Cover in cubic graphs which proved to be NP-hard in cubic graphs [1, 17]. Given an arbitrary cubic graph H as an instance of vertex cover, with |V(H)|=n, we construct an instance G of MinPC as follows.

We may assume that |E(H)|=3n2=3×2l for some integer l, without loss of generality [2]. As shown in Fig. 2, we construct a rooted tree T with a height of l+1, where the root vertex has 3 child vertices. Except for the root and leaves, every vertex in T has 1 parent vertex and 2 child vertices. So T contains 3×2l leaf vertices, where the leaf set is denoted by L. Then, we add a copy of L, denoted by F, and add a Hamiltonian cycle on L and F as in the figure. The elements in F are identified with the elements in E(H). Now, we add a set A which is a copy of V(H) with the identifications. Then, we add an edge between a vertex u∈A and a vertex e∈F (i.e., corresponding to an edge in H) if and only if u is incident to e in H. Let G˜ be the graph constructed in this way.

Let ST denote a star-like subgraph which is induced by a center vertex and its ⌈|G˜|p⌉ neighbors, where |G˜|=|V(T)|+|V(F)|+|V(A)|. Then, for every vertex u in T (resp. F), we connect u to every center vertex in k−3 (resp. max(k−4,0)) copies of ST, where k=⌊2p⌋+1. The construction is completed.

Every vertex in the star-like subgraph has a degree one except the center vertices. When 23<p<1, we have that every vertex in F has a degree of 4 in G and every vertex in V(G)∖F has a degree of 3 in G. When 0<p≤23, every vertex in T and F has a degree of k in G. If a p-cohesion Cp contains a vertex in one of the star-like subgraphs, then Cp has to contain more than |V(T)|+|V(F)|+|V(A)| vertices which makes Cp not a minimum p-cohesion, as shown in the following.

According to the definition of p-cohesion, if a vertex u∈T∪F is in a minimum p-cohesion (Cp) of G, u has at least 3 neighbors in Cp. Based on the construction, if a minimum p-cohesion contains a vertex in T∪F, it has to contain every vertex in T∪F. Furthermore, a minimum p-cohesion cannot only contain the vertices in T∪F or A. So a minimum p-cohesion is induced by all the vertices in T∪F and a smallest subset of vertices in A such that each vertex in F has at least a degree of 3 in the p-cohesion. Clearly, such a p-cohesion contains at most |V(T)|+|V(F)|+|V(A)| number of vertices. Then, the minimum p-cohesion search problem on G is exactly the Vertex Cover problem in H. □

Theorem 2
The MPCS problem does not admit a PTAS, unless P = NP.

Proof
We still use the reduction in the proof of Theorem 1, and let G be the graph constructed in the reduction from an arbitrary cubic graph H (as in Fig. 2), where |V(H)|=n, and |E(H)|=3n2=3×2l for some integer l. As proved, the minimum p-cohesion search problem on G is exactly the Vertex Cover problem in H. The p-cohesion of the constructed graph G contains at most |V(T)|+|V(F)|+|V(A)| number of vertices, where |V(T)|=1+3×20+3×21+⋯+3×2l=3×2l+1−2=6n2−2, |V(F)|=L=3×2l=3n2, and |V(A)|=n. Thus, we have

OPTMinPC(G)=OPTVC(H)+|V(T)|+|V(F)|=OPTVC+9n2−2
(1)
where OPTMinPC(G) (resp. OPTVC(H)) is the size of the optimal solution for the MinPC in the constructed graph G (resp. Vertex Cover in cubic graph H). We omit the target graph in notations when the context is clear, e.g., using OPTMinPC instead of OPTMinPC(G). Note that any solution of MinPC in G of size SOLNMinPC induces a solution of Vertex Cover problem in H of size SOLNVC=SOLNMinPC−9n2+2. Suppose that MinPC admits a PTAS, i.e., for any ϵ>0 we can find a solution for MinPC in polynomial time in graph G of size SOLNMinPC≤(1+ϵ)⋅OPTMinPC. Therefore, we can find a solution of Vertex Cover in H in polynomial time with size

SOLNVC=SOLNMinPC−9n2+2≤(1+ϵ)⋅OPTMinPC−9n2+2
(2)
Based on Eqs. 1 and 2, we have

SOLNVC≤(1+ϵ)⋅OPTVC+ϵ⋅(9n2−2)
(3)
Since H is a cubic graph, any solution of Vertex Cover in H has at least |E(H)|3=n2 nodes, i.e., n2≤OPTVC. Using this in Eq. 3, we have

SOLNVC≤(1+ϵ)⋅OPTVC+ϵ⋅(9n2−2)≤(1+10⋅ϵ)⋅OPTVC
(4)
Thus, the existence of a PTAS for MinPC would imply the existence of a PTAS for Vertex Cover in the cubic graphs, which is impossible unless P = NP [1]. □

Fig. 3
figure 3
Error Amplification in the Proof of Theorem 3, p=12

Full size image
Theorem 3
The MPCS problem does not admit any constant-factor approximation, unless P = NP.

Proof
Following the construction in Theorem 2, the theorem is proved by applying the standard error amplification technique [2]. Let G1={G} be the family of graphs constructed from the instances H of Vertex Cover (as in Fig. 2), G being a typical member of this family, and let α>1 be the factor of approximation of MinPC that exists by Theorem 1.

We construct a sequence of families of graph Gs, such that MinPC problem is hard to approximate within a factor θ(αs) in the family Gs. This proves that MinPC does not have any constant-factor approximation. In the following, Gs will denote a typical element of Gs constructed from the element G∈G1. We describe the construction of G2 and obtain the result by repeating the same construction inductively to obtain Gs.

We take a copy of the subgraph G˜⊂G constructed in the proof of Theorem 1 and denote it as G′. It is proved that a p-cohesion Cp does contain any vertex in ST in the construction. For every vertex u∈G′, let du=deg(u,G′). For each u, we construct a graph Gu as follows. First, take another copy of the subgraph G˜⊂G, denoted as G′′, and choose du arbitrary vertices x1,x2,…,xdu of degree three in T⊂G′′, i.e., xi∈T, i=1,2,…,du. Then, replace each of these vertices xi with a cycle of length four, and join three vertices of the cycle to the three neighbors of xi, i=1,…,du. Then, we connect the du edges incident to u to the du vertices of degree two in the cycles. Let Gu be the graph constructed in this way. An example is shown in Fig. 3.

Now, replace every vertex u∈G′ with Gu mentioned above, denoted the constructed graph as G2˜. Similar to Theorem 1, let ST denote a star-like subgraph which is induced by a center vertex and its ⌈|G2˜|p⌉ neighbors. Then for every vertex u∈G2˜ with degree 3 (resp. with degree 4), we join u to every center vertex in k−3 (resp. max(k−4,0)) copies of ST, where k=⌊2p⌋+1. This completes the construction of the graph G2.

We have that |V(G2)|=|V(G˜)|2+o(|V(G˜)|2)+o(⌈|G2˜|p⌉), because each vertex of G˜ is replaced with a copy of G˜ where we had replaced some of the vertices with a cycle of length four, and we add some copies of ST to vertices in G2˜, i.e., o(⌈|G2|˜p⌉). To find a solution of the MinPC problem in G2, for any u∈V(G), once a vertex in Gu is chosen, we have to solve MinPC in G, which is hard up to a constant factor α. But approximating the number of u’s for which we should touch Gu is also solving MinPC in G, which is hard up to the same factor α. This proves that approximating MinPC in G2 is hard up to a factor α2. The proof of the theorem is completed by repeating this procedure, applying the same construction to obtain G3, and inductively Gs. Note that in each construction of Gi, the size of the ST is different, which is ⌈|Gi˜|p⌉, where i=1,2,…,s. Note that Gi is a supergraph of Gi˜ by adding some copies of ST to some vertices in Gi˜. In order to build Gs from Gs−1, we replace each vertex u∈V(Gs−1) with a copy of Gs−1 in which deg(u,Gs−1) arbitrary vertices of degree three have been replaced with a cycle of length four. □

Exact search algorithms
figure g
figure h
Algorithms 1 and 2 show the pseudo-code for finding the exact minimum p-cohesions containing a query vertex, based on the framework proposed by Bron and Kerbosch [7] which is to enumerate the maximal cliques in a backtracking manner. In Algorithm 1, we use R to denote the intermediate vertex set of a p-cohesion containing the query vertex q. G(R) is a p-cohesion that every vertex in R satisfies the definition of p-cohesion, i.e., deg(v,G(R))≥⌈p×deg(v,G)⌉. Set P is the candidate set that the combining of P and R may be a p-cohesion. By X, we denote the vertices that have been processed. p is the parameter for p-cohesion, and c is the minimum size of all p-cohesions we found. Within each recursive call, the algorithm considers vertices in P in turn. If there are no such vertices, it backtracks. For each vertex v chosen from P, it makes a recursive call in which v is added to R and X, respectively, and in which P is P∪(N(v)−R)−X, which finds and reports all p-cohesions containing vertex v. Then, it removes v from R and P to exclude it in future p-cohesions and continues with the next vertex in P.

In Algorithm 2, we invoke Algorithm 1 with R={q}, P=N(q), X={q} and c=|V(S)|, where S is the input graph. The p-cohesion returned by Algorithm 1 is the minimum p-cohesion containing query vertex q. Note that we can also enumerate all the p-cohesions of a graph, i.e., execute Algorithm 1 with “SubPCExact(∅, V(G), ∅, p, |V(G)|).”

As our experiments on real-life graphs find that the size of a minimal p-cohesion is close to the minimum p-cohesion, and the number of minimal p-cohesions is enormous, considering the hardness results of p-cohesion computation, we design heuristic algorithms to fast retrieve a minimal p-cohesions or a set of disjoint minimal p-cohesions.

Heuristic search algorithms
Globalsearchalgorithm. As previously mentioned, the whole graph or a connected component is a p-cohesion. By removing a vertex from a p-cohesion, it may cause the collapse of the p-cohesion, resulting in a smaller p-cohesion or an empty set. In Algorithm 3, we show the removal of a vertex may lead to the shrink of the p-cohesion.

Let u be a vertex that should be removed from a graph S. After removing u and the edges incident to u, if there is a vertex v in S violating the p-cohesion constraint (Line 2), we remove v and its incident edges from S at Line 3. The algorithm returns a smaller p-cohesion or an empty set.

figure i
Time complexity.––––––––––––––––– If a vertex u is deleted at Line 1 or 3, only the neighbors of u may violate the definition of p-cohesion (Line 2). Thus, each vertex is visited once for deletion and each edge is visited once for degree update and vertex marking. The time complexity of Algorithm 3 is O(m+n).

Space complexity.––––––––––––––––– The subgraph S and the neighbor set take O(m+n) space, respectively. The degree set, to-delete set and vertex index take O(n) respectively. The space complexity of Algorithm 3 is O(m+n).

Example 2
Figure 1 shows a graph with the label of the smallest number of neighbors required for every vertex in a p-cohesion, when p=0.6. If the input graph S is induced by {u1,…,u13}, and u=u12, in Algorithm 3, the deletion of u leads to the removal of u11, u13 and u10 (Lines 2-3) according to the label (p-cohesion constraint). The returned S is induced by {u1,…,u9}. In Algorithm 3, if the input graph S is induced by {u1,u2,u3,u4,u5}, and u=u4, the deletion of u leads to the removal of u5, u2, u3 and u1, such that the returned S is an empty set.

Based on the above collapse procedure, we propose a global search algorithm to compute a minimal p-cohesion containing q in a top-down manner. Let S be the connected component containing the query vertex q, which is a p-cohesion, we iteratively remove a vertex from S without violating the p-cohesion constraint until no such vertex exists.

figure j
Algorithm 4 shows the details of the global search algorithm. Let S be a copy of the connected component in G which contains q (Line 1). At Line 2, T ensures each vertex in S is visited once only. Let S′ be a copy of S (Line 5). We select an unvisited vertex u with the largest degree in S (Line 4) and compute the p-cohesion on S after deleting u by invoking Algorithm 3 (Line 6). If the returned subgraph is empty or q is deleted from S, we recover S (Line 7). When every vertex in current S is visited, S is a minimal p-cohesion. In this paper, the vertex with the largest degree in current S will be chosen first at Line 4, because a large degree vertex may fast reduce the size of current p-cohesion (S).

Time complexity.––––––––––––––––– The visit of every vertex in V(S) takes O(n) (Line 4). Algorithm 3 (Line 6) and the recover of S (Line 7) take O(m+n) for one iteration, respectively. Thus, the time complexity of Algorithm 4 is O(n(m+n)).

Space complexity.––––––––––––––––– The subgraph S, S′ and the neighbor set take O(m+n) space, respectively. The set T and deg(⋅) take O(n) space, respectively. The space complexity of Algorithm 4 is O(m+n).

Example 3
Figure 1 shows a graph with the label of the smallest number of neighbors required for every vertex in a p-cohesion, when p=0.6. If q=u1, Algorithm 4 may firstly choose u10 at Line 4, and then, delete u11, u12 and u13 by the collapse procedure (Algorithm 3). At the next loop, it deletes u4 which leads to the deletion of all the vertices according to the constraint of p-cohesion, i.e., S=∅. Thus, we recover S and try another unvisited vertex in S until no more vertices can be deleted. Finally, the vertices in ∪1≤i≤5ui induce a minimal p-cohesion containing q.

figure k
Localsearchalgorithm. Due to the giant component phenomenon [12], the connected component containing the query may occupy a large part of the graph. In such cases, Algorithm 4 is inefficient on large graphs. To improve algorithm efficiency, we can compute the minimal p-cohesion on a reduced S. In a bottom-up manner, we repeatedly expand the vertices starting from the query vertex to form a p-cohesion subgraph which may be much smaller than the initial connected component S. Algorithm 5 shows the local search procedure from q on a graph G. The set D records the to-expand vertices, and set T ensures that each chosen vertex is expanded only once (Lines 1-4). When we expand a vertex v, b is the number of v’s neighbors in D (Line 4). We add max(⌈p×deg(v,G)⌉−b,0) neighbors of v to D, such that v can stay in the resulting p-cohesion (Line 5).

In Algorithm 5, at Line 3, the chosen vertex v is the vertex with the largest degree in D at that time. At Line 2, we compute a score f(u) for every vertex. At Line 5, we choose the vertices in N(v, G) with the largest score f(u) in G-G(D) since the existence of such vertices can get a good trade-off between the gain and penalty effect of adding one vertex to D. All these chosen vertices are added to D for further expansion (Line 6). After the expansion of every vertex in D, the vertices in D can induce a p-cohesion subgraph. By invoking Algorithm 4 (Line 7), we can get the minimal p-cohesion containing the query vertex q.

Score function. A straightforward score definition for a vertex u∉D is the gain effect of adding u to D, denoted by f+(u), specifically, f+(u) records the number of u’s neighbor v in D with deg(v,G(D))<⌈p×deg(v,G)⌉:

f+(u)=|{v|deg(v,G(D))<⌈p×deg(v,G)⌉,v∈N(u,G(D))}|
(5)
Intuitively, f+(u) denotes the inclusion of u into D could contribute to increasing the degrees of some vertices in D s.t. they are closer to satisfy the p-cohesion constraint.

Besides, there is also a penalty effect of adding u to D, since u may need extra neighbors outside of D to make it have at least ⌈p×deg(u,G)⌉ neighbors in D. We denote the penalty by f−(u):

f−(u)=max{0,⌈p×deg(u,G)⌉−|N(u,G(D))|}
(6)
By considering both the gain and penalty effect, we define a score for a vertex u to determine which neighbor should be selected in Line 5 with the trade-off between its gain and penalty. The ultimate score of a vertex u is defined as:

f(u)=f+(u)−f−(u)
(7)
As for Algorithm 5, in Line 5, for an expanding vertex v, we choose its neighbors u∉D with the largest scores f(u).

Example 4
Figure 1 shows a graph with the label of the minimum number of neighbors required for every vertex in a p-cohesion, when p=0.6. If u=u1, Algorithm 5 may firstly add u2, u3 and u4 to D, s.t., u1 satisfies the threshold for existing in a p-cohesion. Then, u2 and u3 are expanded with no vertex pushed into D. Then, u4 is expanded, which adds u5 to D, because f(u5)=f+(u5)−f−(u5)=1−0=1 is larger than f(u6)=1−2=−1 and f(u7)=1−2=−1. When all the vertices in D have been expanded, the algorithm returns the induced subgraph by ∪1≤i≤5ui.

Time complexity.––––––––––––––––– Let n^ and m^ denote the number of vertices and edges of G(D), respectively. In Line 3 of Algorithm 5, the total number of visited vertices in D is n^. For each vertex in D, the value b can be retrieved by visiting its neighbors, which takes O(m+n) for one iteration. The update of f(⋅) for the neighbors of a vertex v takes O(deg(v,G)∗log(deg(v,G))). The retrieval of P takes O(m+n) for one iteration. The score computation at each iteration takes O(m+n) because deg(⋅,G(D)) and N(⋅,G(D)) can be maintained when each vertex is added to D by visiting the neighbors of the vertex, and each vertex is added to D at most once. At Line 7, Algorithm 4 takes O(n^(m^+n^)). As n^≤n and m^≤m, the time complexity of Algorithm 5 is O(n^(m+n)).

Space complexity.––––––––––––––––– The sets D, T, P, f(⋅) and deg(⋅) take O(n) space, respectively. G and N(⋅) take O(m+n) space, respectively. The space complexity of Algorithm 5 is O(m+n).

Algorithm correctness.–––––––––––––––––––––– In Algorithm 5, every vertex v in D is expanded once at Line 3, which ensures v has sufficient neighbors in the partial set D by adding enough neighbors of v into D (Lines 5-6). When every vertex v in D has been expanded, every v in D satisfies deg(v,G(D))>=⌈p×deg(v,G)⌉, i.e., the returned G(D) is a p-cohesion containing u. Then, we invoke Algorithm 4 in Line 7. As the correctness of Algorithm 4 is immediate (it follows the definition of p-cohesion), Algorithm 5 is correct.

Progressive search algorithm
In this section, we devise a p––rogressive s––earch a––lgorithm to get a p––-c––ohesion containing a query vertex, namely PSA-PC. Given a vertex set Vt as a partial solution, we can compute the upper/lower bounds of the minimum size of a p-cohesion containing Vt. When the size upper/lower bounds of the partial solution is converged, we would get a size guaranteed p-cohesion regarding the size of optimally minimum p-cohesion.

Motivated by [24], we would conduct a B––est-F––irst S––earch (BFS). A BFS tree would be constructed, where the root is the query vertex and every tree node contains one vertex. For each tree node t, its partial solution Vt for this node contains the vertex in the node and all vertices in its ancestor nodes. In PSA-PC, when a tree node t is visited and t contains the vertex u, we add the child nodes of t to the search tree where each child node contains a unique neighbor of a vertex in Vt with vertex id larger than u, in case of duplicate computation. Then, for each partial solution Vt, we compute the upper/lower bounds based on the following algorithms.

(i) Upper bound We conduct the LocalSearch algorithm (Algorithm 5) equipped with Eq. (7) to get a minimal p-cohesion containing Vt. The returned p-cohesion will be used to update the global size upper bound s+ of the optimally minimum p-cohesion. Also, the returned p-cohesion will be the current best solution containing Vt;

(ii) Lower bound For each vertex in u∈Vt, we compute the number of neighbors that u need to stay in a p-cohesion: Du=max{0,⌈p×deg(u,G)⌉−|N(u,G(Vt))|}. We use NDmax=maxu∈Vt{Du} to denote the largest number of new vertices required to stay in the p-cohesion containing Vt. So, |Vt|+NDmax is the size lower bound s−(t) of the optimally minimum p-cohesion containing Vt.

The algorithm PSA-PC will return once s+s−≤c is satisfied, where c is a user-specified approximation ratio on the size of p-cohesion.

figure l
The pseudo-code is given in Algorithm 6. We use t to denote a tree node in the BFS tree T. The vertex set Vt of a node t consists of the vertex t.v in t and all vertices in the ancestor nodes of t. We use s+ to denote the upper bound of optimal minimum p-cohesion and use s−(t) to denote the size lower bound of the minimum p-cohesion containing Vt. A priority queue Q is used to denote the leaf nodes in T to be visited, where the key of a node t is s−(t) in ascending order.

In each iteration (Lines 5-17), the node t with the smallest lower bound value s−(t) is popped at Line 5. For current processing t.v, we expand it by each neighbor u of a vertex in Vt with id(u)>id(t.v) (Line 6), where id(u) is the identifier of u. At Lines 7-8, for each child node t′ of t, we compute the size lower bound of the minimum p-cohesion containing V′t, where V′t contains t′.v and all vertices in Vt. For the size upper bound s+(t′), at Line 10, we conduct Algorithm 5 equipped with Eq. (7) to get the p-cohesion containing V′t, denoted by R′, with s+(t′)=|R′|. The global upper bound s+ and current best solution R will be updated by s+(t′) and R′ if s+(t′)<s+ (Lines 11-12). At Line 15, a search branch following t′ can be stopped if s−(t′)≥s+ because the size of the p-cohesion containing current V′t cannot be smaller than current solution |R|.

At Line 16, the global lower bound s− is updated as the smallest s−(⋅) among all nodes in Q. The algorithm will return when s+s−≤c is satisfied at Line 17 or the queue is empty.

Algorithm Correctness.––––––––––––––––––––––– Every subgraph R′ retrieved at Line 1 is a p-cohesion containing q, and hence, the upper bound s+ is correctly maintained in Algorithm 6. Given the correctness of the lower bound s−, we have s−≤|R∗|≤s+, where R∗ is the optimal solution. When Algorithm 6 terminates, we will return current best solution R with s+s−≤c.

Diversified enumeration
In this section, we study the diversified p-cohesion enumeration problem (DPCE): Enumerate a set of disjoint minimal p-cohesions.

Problem analysis
Firstly, we show the number of minimal p-cohesion for a graph can be exponential by the following theorem.

Theorem 4
There exists a graph G that contains an exponential number of minimal p-cohesions, for every fixed p∈(0,1).

Proof
We prove the theorem based on the exponential number of maximal cliques in a graph G. Suppose G is empty initially, we add a vertex set O=∪1≤i≤nvi to G where n=2x and x∈N+. For every vertex vi∈O, we connect vi to every other vertex in O except the opposite vertex vj where |j−i|=n2, i.e., the degree of every vertex v∈O is deg(v,G)=n−2.

For every vertex v∈O, we add y extra vertices and connect each of them to v:

y=⎧⎩⎨⎪⎪⌈(n−2)⋅(12p−1)⌉,⌈(n−2)⋅(12(1−p)−1)⌉,0<p<1212≤p<1
(8)
The construction is completed. We have |V(G)|=n+n⋅y. For every vertex v∈O, we have deg(v,G)= (n−2) +y:

deg(v,G)=⎧⎩⎨⎪⎪⌈(n−2)2p⌉,⌈(n−2)2(1−p)⌉,0<p<1212≤p<1
(9)
For both cases of p, we have p⋅deg(v,G)≥n−22. So for each vertex in O to be in a minimal p-cohesion S, at least n−22 of its neighbors are also in S. Note that, for a maximal clique of G(O), the degree of every vertex in the clique is n−22. If we count each minimal p-cohesion in which each vertex contained in O has exactly n−22 neighbors in O, the number of the minimal p-cohesions is at least the number of maximal cliques in G(O) which is 2n/2. Thus, the number of minimal p-cohesions in G is exponential. □

According to Theorem 4, the number of minimal p-cohesions may be overwhelming to users. Moreover, the p-cohesions discovered may heavily overlap with each other. Thus, we are interested in tackling the diversified minimal p-cohesion enumeration problem (DPCE) for graph G: We prefer to find a set of disjoint minimal p-cohesions for G.

Pivot-based local search (PLS)
In this section, we efficiently find a set of disjoint minimal p-cohesions based on the algorithms for MPCS.

Baselinealgorithm. A straightforward method to find a set of disjoint p-cohesions for a graph is to repeatedly find a minimal p-cohesion and remove it. Thus, we propose an algorithm in a top-down manner: For a graph G, starting with a connected component S, we can find a minimal p-cohesion by Algorithm 4: “Cp= GlobalSearch(S, p, ∅).” We remove Cp and the vertices violating the p-cohesion constraint after the removal of Cp. Repeatedly when all vertices are removed from graph G, we can get a set of disjoint minimal p-cohesions.

A pivot-based local search algorithm Finding one minimal p-cohesion in a top-down manner without a pivot is time-costly. Motivated by the MPCS, we can improve the efficiency of the BaseLine Algorithm by adding a pivot u and finding a minimal p-cohesion containing u by Algorithm 5. The details are shown in Algorithm 7.

At Line 1, we record the degree of every vertex in G. The set T is used to ensure every vertex is checked exactly once. Then, we compute a minimal p-cohesion on each connected component S of current graph G from Line 2. A minimal p-cohesion Cp can be computed by Algorithm 5 with subgraph S, threshold p and a vertex u∈S. We delete Cp from S and record Cp in C (Line 6). We delete the vertices violating the fraction threshold of p-cohesion in S to further reduce S (Lines 7-8). Algorithm 7 returns the set of minimal p-cohesions in C.

At Line 3, we select the vertex with the smallest degree in S because a small degree pivot can fast expand to a p-cohesion and keep the advantage of the pivot that prunes more vertices at the early stage. Besides, the chosen pivot allows us to compute the minimal p-cohesion on a reduced initial S at Line 5 of Algorithm 7, which can improve the efficiency significantly.

Time complexity.––––––––––––––––– The visit of the connected components in the graph takes O(n) at most (Line 2). Algorithm 5 takes O(n(m+n)) for one iteration (Line 5). The update of S and C takes O(m+n) at most (Lines 6-8). Thus, the time complexity of Algorithm 7 is O(n2(m+n)) in the worst case.

Space complexity.––––––––––––––––– Algorithm 5 takes O(m+n) space. The G, Cp and C take O(m+n) space. The deg(⋅) and T take O(n) space. The space complexity of Algorithm 7 is O(m+n).

figure m
An application on MinSeed
In this section, we study an application of the minimal p-cohesion subgraphs on the contagion model introduced by [12, 29] along with the p-cohesion. To promote the sale of a product B, the company may give incentives to some seed users, such as a discount or free product trial. These seed users are regarded as activated (i.e., influenced) for using B, which may influence (i.e., activate) their friends to use B. The influence will further cascade to the friends of the activated users. In the following, we formally introduce the cascading rule.

Definition 4
Cascading Rule. Given a graph G, the set of activated vertices A∈V(G) and a cascading threshold r∈(0,1), we have: (1) a vertex u∈(V(G)∖A) is immediately activated iff there are at least ⌈r×deg(u,G)⌉ activated neighbors of u in G, i.e., deg(u,G(A))≥⌈r×deg(u,G)⌉, and (2) a seed vertex u is always activated.

Given a target user group (which induces a graph) to cascade, a company may wish to find the fewest seed users (initial adopters) such that all the target users are activated while the promotion expense is minimized. Thus, the MinSeed problem is defined.

MinSeedproblem Given a target graph G with no activated vertices, and a cascading threshold r∈(0,1), the MinSeed problem is to find a set of seed vertices D in V(G), such that (1) all the vertices in V(G) are activated by applying the Cascading Rule repeatedly, and (2) |D| is minimized.

We prove that MinSeed is NP-hard by a reduction from Vertex Cover problem. Given a graph G, when r is large enough, e.g., r=|V(G)−1|/|V(G)|, the activation of a vertex needs all its neighbors to be activated first. To activate all the vertices in G, each edge in G should be incident to at least one seed vertex. Thus, MinSeed with such a r is exactly Vertex Cover which is NP-hard.

figure n
Heuristicseedselection. Algorithm 8 shows the basic framework to find an approximate solution for MinSeed. For every vertex v in G, we use c(v) to record the number of activated neighbors (Line 1). Set D records the selected seeds, and set A records the activated vertices except the seeds (Line 2). We select an inactivated vertex u as a seed and use L to record the activated vertices by seed u (Lines 3-4). We update the c(⋅) value for the inactivated neighbors of each vertex in L (Lines 6-7). An inactivated neighbor v is activated if c(v)≥⌈r×deg(v,G)⌉ (Lines 8-9). The algorithm returns D as the seed set.

Time complexity.––––––––––––––––– Algorithm 8 activates each vertex in G by exactly one time and updates the c(⋅) value of its neighbors. So the time complexity of Algorithm 8 is O(m+n) if the seed selection at Line 3 takes up to O(m+n).

Space complexity.––––––––––––––––– Sets c(⋅), D, A, L and deg(⋅) take O(n) space, respectively. G and N(⋅) take O(m+n) space, respectively. The space complexity of Algorithm 8 is O(m+n).

Algorithm correctness. Every vertex in G is either pushed into D as a seed, or pushed into A as an activated vertex by the seeds. Since the seeds are regarded as activated, the D returned by Algorithm 8 is a feasible solution of MinSeed.

Selection order. The vertex selection order in Line 3 decides the number of resulting seeds. Because the minimal p-cohesions prevent outside influence spread according to the Fortress property, the vertices in the p-cohesions are relatively isolated from the non-p-cohesion vertices. By giving certain priorities to fortress vertices, we may break through the barrier of influence spread from the non-p-cohesion vertices to the p-cohesion vertices. Thus, the number of seeds required may be reduced. For MinSeed, we explore the following seed selection orders.

IC-Deg selection. We select a vertex u with the largest degree in G at Line 3, because such a u can increase the c(⋅) values by a great extent and such a u can relax the fortress property when it is in a minimal p-cohesion.

IC-Core selection. The coreness of a vertex u is the largest value of kmax such that u is in the kmax-core, i.e., u∈km-core and u∉(kmax+1)-core. We select a vertex u with the largest coreness in G at Line 3, because the coreness of a vertex reflects its importance/influence [24].

IC-Truss selection. The trussness of a vertex u is defined as the largest value of trussness of an edge incident to u. The trussness of an edge e is the largest value of km such that e is in the km-truss, i.e., e∈km-truss and e∉(km+1)-truss. Similar to the IC-Core Selection, we select a vertex u with the largest trussness in G at Line 3, because the trussness of a vertex also reflects the importance/influence of the vertex [38].

IC-BF selection. We select a vertex u at Line 3 such that the size increase of A is the largest with the selection of u. Such a u is “best” in a greedy view. When there are ties, we choose the one with the largest degree in G, as in the degree-based selection. We hope these “best” vertices can effectively break the boundaries of the fortresses.

IC-PC selection. We find that the vertices with extremely large degrees have great influence power. So firstly we select α×|V(G)| vertices as seeds which have the largest degrees in G. Then, we retrieve a set C of minimal p-cohesions on G-G(D∪A) by the PLS algorithm where p=1−r+ε and ε is an infinitesimal positive number. We compute a weight β×deg(u,G) for each vertex u in C. For a vertex v not in C, its weight is just deg(v, G). Then, we continue to select a vertex u as a seed which has the largest weight in G at Line 3. In this way, the fortress property may be relaxed by giving priorities to the vertices in the minimal p-cohesions.

Example 5
Figure 1 shows a graph where r=0.5 and all the users are inactivated. By IC-Deg, Algorithm 8 may select u10 and u4 sequentially. By IC-BF, Algorithm 8 may select u10, u7 and u5 sequentially. By IC-PC, when α=0.01 and β=2, Algorithm 8 may select u4 and u5.

Experimental evaluation
This section evaluates the effectiveness and efficiency of all techniques through comprehensive experiments.

Algorithms. To the best of our knowledge, there is no existing work investigating the p-cohesion computation. We implement and evaluate 6 algorithms for p-cohesion computation and 3 algorithms for MinSeed as shown in Table 2.

Datasets. 8 real-life graphs are deployed in our experiments. The original data of Yelp are from [40], DBLP is from [23], and the others are from [22]. In DBLP, each vertex represents an author and each edge between two authors represents the two authors have at least 5 co-authored papers. The other datasets have existing vertices and edges. For Gowalla and Brightkite, we remove the vertices without check-ins and their incident edges. We transfer directed edges to undirected edges. Table 3 shows the statistics of the datasets.

Table 2 Summary of Algorithms
Full size table
Table 3 Statistics of Datasets
Full size table
Settings. All programs are implemented in standard C++ and are compiled with G++ in Linux. All experiments are performed on a machine with Intel Xeon 2.3GHz CPU and Redhat Linux system. The runtime of an algorithm is set to INF if it cannot finish in 1 hour.

Statistical results
Exact number of p-cohesions.–––––––––––––––––––––––––––– We can enumerate the minimal p-cohesions in a graph by ExactPC (Algorithm 1). Due to the huge time and space cost, we only compute the minimal/minimum p-cohesions on a small graph G with p=0.6. We extract the small graph G with 70 vertices from the Yelp dataset. Note that the minimal p-cohesion computation on a graph with 80 vertices cannot finish in one week. For the search of the minimum p-cohesion containing a query vertex, we report the results from SubPCExact (Algorithm 2) over 100 independent tests. In each test, we randomly select a vertex from G as the query vertex q and compute all the minimal p-cohesions containing q by Algorithm 2. The results show that the average number of minimal p-cohesions containing a query q is 16, 549.27, and the size of a minimal p-cohesion is in average 1.194 times the size of (exact) minimum p-cohesion. We also compute the number of all the minimal p-cohesions in G with 70 vertices by Algorithm 1, i.e., “SubPCExact(∅, V(G), ∅, p, |V(G)|).” The number of minimal p-cohesions of G is 87, 429, which is over-whelming.

Fig. 4
figure 4
Average Size of Minimal p-Cohesions

Full size image
Score function evaluation forMPCS.–––––––––––––––––––––––––––––––––––– Figure 4 reports the average minimal p-cohesion subgraph size returned by GlobalS, LocalS and LocalS * over 100 runs. One query vertex is selected randomly from all the vertices. Figure 4a shows the result on 8 datasets with p=0.6. The score function-based algorithm LocalS * can significantly outperform GlobalS regarding average size, because the search space of GlobalS is larger. Some large degree vertices may be chosen in the execution of GlobalS, and they usually need more neighbors to stay in a p-cohesion. On most of the datasets, LocalS * can significantly outperform LocalS. For example, on DBLP, the number of vertices returned by LocalS is almost 5 times greater than the number of vertices returned by LocalS *. This implies that considering only the gain effect (Eq. (5)) during the expansion procedure cannot guarantee a good performance. Figure 4b, c reports the results of three algorithms by varying the constraint p from 0.1 to 0.9 on DBLP (4b) and Amazon (4c), respectively. In both figures, the sizes of the minimal p-cohesion subgraphs returned by GlobalS, LocalS and LocalS * increase as p grows, since a large p inherently requires more vertices in a p-cohesion subgraph. When p is very large, the results of the three algorithms are similar, because nearly the whole graph is returned.

Fig. 5
figure 5
Average Size of Minimal p-Cohesions, p=0.6, c=1.8

Full size image
Size guaranteed p-cohesion.––––––––––––––––––––––––––– We can get a minimal p-cohesions with certain size guarantee by PSA-PC (Algorithm 6). Figure 5 shows the average size of p-cohesion subgraphs on 8 datasets, where p=0.6 and approximation ratio c=1.8. As depicted in Fig. 4, the LocalS * outperforms the other two algorithms. Thus, in Fig. 5, we compare the results returned by PSA-PC and LocalS * over 100 independent tests. In each test, we randomly select a vertex from a graph G as the query vertex q and compute the minimal p-cohesions containing q by PSA-PC and LocalS *, respectively.

As PSA-PC is costly, it cannot finish in one hour for about 87% queries in the experiments. Thus, we terminate PSA-PC when the runtime reaches one hour and get the latest p-cohesion from it. Given such time limit, the returned results from PSA-PC can outperform LocalS* regarding the average size from all the queries, due to the theoretical guarantee of PSA-PC.

Effectiveness on cohesive subgraph modeling
Comparing different cohesive subgraphs.––––––––––––––––––––––––––––––––––––––– For each query vertex v, we compute the minimal p-cohesion by LocalS *, the ⌈p×deg(v,G)⌉-core by [6], the (⌈p×deg(v,G)⌉ +1)-truss by [9], the maximal clique by [36] and the edge densest subgraph by [14] where every computed subgraph contains v. The query vertex is randomly selected from all the vertices in the graph. In Fig. 6, we report the modularity scores [30] on the evaluated subgraph and the subgraph of the outside, for each of the above models, when p=0.6. The scores are the average values from 100 independent tests. Consistent with the definition, the minimal p-cohesion shows better modularity scores because it holds both inner-cohesiveness and outer-sparseness. In Fig. 7, we report the clustering coefficient of the induced subgraphs computed by each model. Figure 7 shows the p-cohesions have higher clustering coefficients on all the datasets than other models except the clique.

Fig. 6
figure 6
Comparing Modularity of Different Cohesive Subgraph Models, p=0.6

Full size image
Fig. 7
figure 7
Comparing Clustering Coefficient of Different Cohesive Subgraph Models, p=0.6

Full size image
Cases of MPCS––––––––––––––––. In Fig. 8, we depict a minimal p-cohesion S containing the query vertex “20317” found by LocalS * with p=0.6 on Email. The p-cohesion contains all the grey vertices. In Fig. 9, we find a s-clique containing the query vertex “20317” where s=|V(S)|. The s-clique contains all the gray vertices. We also depict all the 1-hop neighbors of one vertex in the p-cohesion or the s-clique, to show the outer connections to the subgraph. In Fig. 8, we can see the vertices in S are sparsely connected to their outside neighbors. However, in Fig. 9, vertex “24944” has a dense connection with its neighbors outside of the s-clique. The outside influence cascades may enter the s-clique through “24944.” We also compute the ⌈p×deg(v,G)⌉-core and the (⌈p×deg(v,G)⌉ +1)-truss containing vertex “20317.” The numbers of vertices in two subgraphs are 11,538 and 10,097, respectively. The sizes are too large for community-oriented applications. For each subgraph, there are some vertices with many neighbors outside the subgraph. In Figs. 10 and 11, we depict the minimal p-cohesion S found by LocalS * with p=0.6 and a |V(S)|-clique containing the query vertex “251583” on DBLP. We also compute the ⌈p×deg(v,G)⌉-core and the (⌈p×deg(v,G)⌉ +1)-truss containing vertex “251583,” and the sizes of these two subgraphs are 35,281 and 22,499, respectively. The results on DBLP are similar to that on Email.

Fig. 8
figure 8
A Minimal p-cohesion on Email

Full size image
Fig. 9
figure 9
An s-Clique on Email

Full size image
Fig. 10
figure 10
A Minimal p-cohesion on DBLP

Full size image
Fig. 11
figure 11
An s-Clique on DBLP

Full size image
Fig. 12
figure 12
PLS on DBLP, p=0.8

Full size image
Cases of DPCE––––––––––––––––. Figure 12 depicts a part of DBLP with the minimal p-cohesions discovered by PLS when p=0.8. The p-cohesions are marked by the black edges and their incident vertices. We also show all the vertices which are within the 5-hop neighborhood of one vertex in the p-cohesions. We can see the minimal p-cohesions have a loose connection to their outside neighbors.

Effectiveness on fortress property
Fortress property on different influence models.–––––––––––––––––––––––––––––––––––––––––––––– We examine the fortress property of p-cohesions under different cascade models: the contagion model, the independent cascade (IC) model and the linear threshold (LT) model [18]. The target minimal p-cohesions are computed by PLS. For each influence test, we randomly choose b=0.1×|V(G)| seeds. We follow the settings in [18] to compute the influence spread. During the cascade procedures of the LT and IC models, each edge (u, v) is split to two directed edges (u, v) and (v, u). The existing probability of each directed edge, i.e., (u, v), is set as 1/deg(v). For the LT model, we randomly distribute a threshold from 0 to 1 for each vertex v as the influence threshold. We generate 10 possible worlds on both the IC and LT models, to compute the influenced vertices and generate the average influence ratios.

Fig. 13
figure 13
Fortress Property of Different Cascade Models

Full size image
In Fig. 13, Contagion, IC and LT represent the average influence ratio of “the number of influenced p-cohesion vertices” divided by “the number of all the influenced vertices” for contagion, IC model and LT model, respectively. We use BaseValue, i.e., |V(Cp(G))|/|V(G)|, to represent “the number of p-cohesion vertices” divided by “the number of all the vertices,” as a base value for influence comparison. The setting is p=0.6 and r=1−p+0.001. BaseValue is basically larger than Contagion, IC and LT, among different settings, which implies that the vertices in a p-cohesion have a relatively smaller possibility to be influenced than the other vertices, under every evaluated influence model. The p-cohesion holds the fortress property on all the evaluated influence models, because a p-cohesion maintains a sparse connection to the outside s.t. the influence spread from outside is hard to enter the p-cohesion on these influence spread models.

Figure 13 also shows that the percentages of p-cohesion vertices over different graphs are different, which would affect the influence power of contagion model. For example, about 17.4% of the vertices from Epinion are in p-cohesions, and only about 14.1% of them can be influenced under the contagion model, while about 67.4% of the vertices of DBLP are in p-cohesions, and almost 65.1% of them can be influenced under the contagion model. It indicates that the higher occupation of the p-cohesion vertices would result in the higher influence power of the contagion model.

Fig. 14
figure 14
Fortress Property of Different Cohesive Subgraphs

Full size image
Fortress property on different cohesive subgraphs.–––––––––––––––––––––––––––––––––––––––––––––––– In Fig. 14, we evaluate the fortress property of the minimal p-cohesion, which is compared with different cohesive subgraph models: k-core [33] and s-clique [20], k-truss [9] and the edge densest subgraph [14]. The query vertex is randomly selected on the graph. The minimal p-cohesion is computed by LocalS *. For the s-clique containing the query vertex, we choose the size of the minimal p-cohesion as the parameter s. For k-core (resp. k-truss), the input of k is the largest value of k such that the k-core (resp. k-truss) containing the query vertex is not empty.

We report the average ratio of influenced (i.e., activated) vertices over all the vertices under the contagion model [12, 29] over 100 independent tests with p=0.5 and influence ratio r=1.0−p+0.001. For each influence test, we randomly choose b=x×|V(S)| seeds where S is the connected component containing the query vertex in the graph. In Fig. 14, Minimal p-Cohesion represents the average ratio of “the number of influenced vertices in the p-cohesion (denoted by S)” divided by “the number of all the vertices in S.” It is similar for s-Clique, k-Truss, k-Core and Edge Densest. The figure shows that all other cohesive subgraphs have more difficulty in hindering the influence spread from outside, compared with p-cohesion, because they do not guarantee the outer-sparseness. The minimal p-cohesion shows a stronger fortress property than the others on all the settings.

Fig. 15
figure 15
Minimal vs Non-Minimal p-Cohesions

Full size image
Evaluation of minimal and non-minimal p-cohesions.––––––––––––––––––––––––––––––––––––––––––––––––––– Figure 15 evaluates the effectiveness of “minimal” constraint on p-cohesion, by comparing the fortress property of minimal p-cohesions and non-minimal p-cohesions. Each time for a random query vertex in G, we compute a minimal p-cohesion by LocalS * and a corresponding non-minimal p-cohesion by the expansion procedure of LocalS *. We conduct 100 influence tests under the contagion model. In each test, we randomly choose b=0.1×|V(S)| seeds to compute the influenced vertices, for 10 times, where S is the connected component containing the query vertex.

In Fig. 15, Minimal p-Cohesion represents the average ratio of “the number of influenced vertices in the minimal p-cohesion (denoted by S)” divided by “the number of all the vertices in S.” Non-Minimal p-Cohesion represents the average ratio of “the number of influenced vertices in the non-minimal p-cohesion (denoted by S′)” divided by “the number of all the vertices in S′.” The minimal p-cohesion shows stronger fortress property than the non-minimal p-cohesion, because the smaller diameter and size may benefit the defend of information cascades coming from the outside.

Effectiveness on influence maximization and MinSeed problems
Fig. 16
figure 16
Influence Maximization of Different Methods

Full size image
Evaluation on influence maximization.––––––––––––––––––––––––––––––––––––– To further verify the effectiveness of the fortress property, we utilize the p-cohesions in the problem of influence maximization, compared with existing works [8, 28]. The minimal p-cohesions used in the experiment are computed by PLS with p=0.6. We follow the settings in [28] to compute the influence spread. The IC model is used as the influence cascade model, and the influence spread probability r=1−p=0.4. We report the result on R=100 rounds where we select b=50 inactive vertices as the seeds in each round.

Specifically, during the seed selection of our IM-PC on each round, we compute the influence spread with the following steps: (1) Choose an inactive vertex from all minimal p-cohesions with the largest degree as the seed; (2) compute the spread of the influence of this seed; (3) repeat step (1) and step (2) for b times; and (4) report the average number of active vertices for all rounds. For the method IMUG [28], we probe m=⌈0.001∗|V(G)|⌉ vertices and select b seeds for each round s.t the expected number of active vertices in the R-th round is maximized [28]. Since the IMUG is for unknown graph, we probe the vertex with the largest degree as a seed, because such a vertex has a larger influence spread than other heuristics [18]. The DegreeDiscountIC [8] is based on degree discount method, which select the vertices with the largest number of inactivated neighbors as the seeds.

In Fig. 16, we report the average number of active vertices for different seed selection methods. The results show that the number of activated vertices by IM-PC is larger than DegreeDiscountIC and IMUG. It is because that the vertices in a minimal p-cohesion are hard to be influenced than other vertices, and the seed from p-cohesions (IM-PC) can break the entry barriers of the p-cohesions, while DegreeDiscountIC and IMUG do not consider this fortress property.

Evaluation ofMinSeed algorithms.–––––––––––––––––––––––––––––––––– In Table 4 and Table 5, we report the seed numbers returned by IC-Deg, IC-BF, IC-Core, IC-Truss, and IC-PC when r varies from 0.2 to 0.8. We report the seed numbers on four datasets, i.e., Email, Brightkite, Gowalla and Amazon. According to Property 1, it is difficult for the p-cohesions to be influenced from the outside vertices. Our IC-PC gives selection priority to the vertices in minimal p-cohesions such that the resulting seed numbers can be reduced. We set ε as 0.001 and p=1−r+ε. According to statistical observation, we set α=0.01 and β=2.

Tables 4 and 5 show that the IC-PC significantly selects less seeds than the other algorithms, which helps to reduce the cost of cascading the network. Some results of IC-BF are not reported because the computation cannot finish within 1 week. All methods of IC-Deg, IC-Core, IC-Truss and IC-PC are efficient, because IC-PC just additionally conducts PLS on a reduced graph and the PLS is efficient. We observe that the seed number is much smaller than the size of a dataset, e.g., the seed number of IC-PC on Brightkite (resp. Gowalla) is only 2.5% (resp. 2.7%) of its vertex number when r=0.4.

Table 4 Seed Numbers of Email and Brightkite with Different Methods
Full size table
Table 5 Seed Numbers of Gowalla and Amazon with Different Methods
Full size table
Efficiency report
In this section, we report the runtime of finding a minimal p-cohesion and finding the disjoint minimal p-cohesions.

Fig. 17
figure 17
Finding a Minimal p-Cohesion

Full size image
Score function evaluation on MPCS.–––––––––––––––––––––––––––––––––––– Here, we report the average runtime of GlobalS, LocalS and LocalS * to compute a minimal p-cohesion containing a query vertex q over 100 runs. One query vertex is randomly selected among all the vertices. Figure 17a reports the runtime on all the datasets when p=0.6. We observe that the runtime on a dataset is strongly affected by its vertex number, since every vertex belongs to at least 1 minimal p-cohesion in the result. Figure 17b, c reports the runtime on DBLP and Amazon with p varying from 0.1 to 0.9. The runtime of GlobalS drops slightly with the increase of p, because a larger p makes vertex deletion more efficient. LocalS and LocalS * perform faster when p is small, because the computation space is reduced for a small p. Note that LocalS and LocalS * expand the query vertex to a p-cohesion and then delete the vertices from the p-cohesion to produce a minimal p-cohesion containing q. LocalS runs slower than LocalS *, because the former does not consider the penalty effect during the expansion procedure and usually finds a larger p-cohesion than LocalS *. When p=0.9, the runtime of LocalS * is not larger than that of p=0.8 on Amazon, because the p-cohesions have a similar size for both p values, while the deletion procedure is faster for p=0.9. In general, LocalS * significantly outperforms GlobalS on runtime.

Fig. 18
figure 18
Finding Disjoint Minimal p-Cohesions

Full size image
Evaluating algorithms forDPCE.––––––––––––––––––––––––––––––––– Here, we evaluate the performance of BaseTD, BaseTD+ and PLS to find disjoint minimal p-cohesions. Figure 18a reports the performance on all the datasets when p=0.6. Figure. 18b and 18c shows that BaseTD and BaseTD+ cannot finish the computation in 1 hour when p is small. Although the computation of one minimal p-cohesion is fast when p is small, the size of produced p-cohesion is quite small such that we have to compute much more minimal p-cohesions than that of large p values. This issue is relaxed when p is large enough such as p=0.6. There are 4 factors which influence the trends of runtime: (a) the size of every expanded p-cohesion, (b) the size of every resulting minimal p-cohesion, (c) the number of resulting minimal p-cohesions and (d) the deletion procedure from an expanded p-cohesion to a minimal p-cohesion. When the p value increases, usually (a) increases, (b) increases, (c) decreases and (d) speeds up, which, in total, constitutes the trends of runtime for different p. In general, PLS is significantly faster than the other algorithms.

Conclusion
In this paper, we study two representative problems on the fortress-like p-cohesion subgraphs: minimum p-cohesion search and diversified p-cohesion enumeration. We analyze the complexity of the problems and prove that finding a minimum p-cohesion is NP-hard to approximate for any constant factor and the minimal p-cohesion enumeration is intractable. From theory to practice, we propose efficient algorithms to find a minimal p-cohesion for a query vertex and a set of disjoint minimal p-cohesions. For a feasible solution of MinSeed, we employ the discovered minimal p-cohesions to reduce the seed number required for cascading the whole network. Comprehensive experiments show that our algorithms are efficient, the minimal p-cohesions hold the fortress property, and the algorithms help solve the MinSeed problem. In the future, it is interesting to study whether there are more applications of p-cohesion, e.g., community deception, graph decomposition and network stability.