While data sharing cross management is increasingly popular, there are challenges in such a decentralized data sharing mode, especially in terms of transaction fairness and copyright protection. However, few schemes consider both fairness and copyright protection in the current literature. In this paper, we propose a flexible and Ethereum-based scheme to facilitate copyright protection in data sharing blockchain, by using watermark-based policies. This allows us to achieve properties such as preventing the re-selling of data (e.g., partial data, combined data, and leaked data). We also design five algorithms to automatically guarantee data sharing fairness and proactively protect data copyright, by using smart contracts. In other words, several new security features are introduced to existing transaction schemes, while still achieving feasible performance. The response times for each key step of smart contract in the proposed scheme is between 0.41 s and 0.91 s.

Previous
Next 
Keywords
Data sharing

Data transaction

Smart contract

Digital watermarks

Blockchain

Smart city

1. Introduction
Edge computing is increasingly popular in a broad range of applications such as smart cities, partly due to the benefits over a pure cloud computing deployment, and advances in communication technologies that enable communications for significant data volume pervasively and ubiquitously. However, in existing systems, most data collected within a system are generally not shared with other systems/entities in the ecosystem. For example, data sensed and collected by the Internet of Things (IoT) devices within a smart building may not be shared with other systems in the smart city. In other words, most systems remain siloed, and consequently data are not shared due to separation of management domains.

There has been a trend of moving towards data sharing, particularly between systems and platforms, in order to maximize data value and facilitate informed decision making, for example using data sharing as a service platform (Dai et al., 2019). Existing data sharing markets can be either centralized or decentralized. In the former model, a centralized entity charges some admission fee or imposes commission on the transactions. While decentralized data transaction models may not have such limitations, there are also challenges in the design and implementation of decentralized data sharing platforms. For example, how do we ensure the fairness of data transactions, without requiring a centralized governance model? Also, how do we achieve copyright protection of the exchanged data such as defending against illegal/unauthorized re-sharing of sold data? In addition, the fairness in data transactions means that the participant who conducts a malicious transaction to affect the profit of the other participant should be penalized, and the participant who is victimized should potentially be compensated.

Hence, this necessitates the design of a platform that is self-governable. In recent years, many different approaches to ensure copyright protection on data transactions have been designed, such as those based on digital watermark, and blockchain. However, existing approaches generally do not allow one to handle disputes that occur during the transactions. In a recent work, Dai et al. (2019) introduced a blockchain-based data trading ecosystem, where neither the data broker nor the buyer can obtain access to the seller’s raw data. Specifically, both data broker and buyer can only get access to the analysis findings that they require. The authors also presented a set of trading protocols for the data trading market.

Along a similar line, in this paper we propose a decentralized scheme for flexible and self-governable data sharing. The scheme allows one to enforce proactive data copyright protection and automatically guarantee fair sharing, using watermarks and smart contracts respectively. In our scheme, the blockchain will also be used as a transaction account book, value exchange channel, and virtual database on watermarks. A summary of this paper’s contributions is as follows:

1.
We propose a flexible scheme for data copyright protection in data sharing by using watermark-based policies, e.g., minimizing the risk of re-selling of partial, combined, and/or leaked data.

2.
We propose dedicated algorithms and protocols for automatically guaranteeing data sharing fairness and pro-actively protecting data copyright in data transactions by using smart contracts.

In the next section, we will review relevant prior work. The trade model and transaction process are presented in Section 3. Section 4 describes our scheme, and its evaluation and analysis are respectively presented in Sections 5 Discussion, 6 Evaluation and analysis. Finally, Section 7 concludes the paper.

2. Related work
We will now discuss recent literature related to secure data sharing and copyright protection.

2.1. Data sharing based on blockchain
There have been attempts to design blockchain-based secure data sharing, as previously discussed. For example, Liu (2016) explored the application of blockchain for data sharing in healthcare to record operations on the medical data and protect the integrity of sharing data. Karafiloski and Mishev (2017) surveyed existing big data solutions that could be empowered by the blockchain technology for personal data protection, digital property, Internet of things, and healthcare fields. Vo et al. (2018) presented a blockchain-based business application for micro-insurance and artificial intelligent (AI) marketplace. They also designed a blockchain-powered big data analysis platform. In a separate work, Guan et al. (2018) proposed a trusted big data collection and trading system using blockchain, with the aim of providing a fair and trusted platform for each participant. Specifically, the blockchain is applied to provide decentralized accounting and trading platform. In their scheme, sharing of private data transactions can be realized to a certain extent.

Nasonov et al. (2018) proposed a distributed big data platform, where a blockchain-based distributed digital data marketplace is used to ensure data transaction integrity. Bandara et al. (2018) proposed a blockchain based big data storage, built over Apache Cassandra distributed database. Their scheme can make big data structured and meaningful, and more secure at the same time. On this basis, it is easier for users to more effectively analyze big data. Zhang et al. (2019) explored the application of blockchain for the Internet of Vehicles (IoV), and more specifically in facilitating the vehicle to broadcast information and realizing trusted storage of information. In addition, the information broadcast and stored on the blockchain is authenticated and undeniable. Yang et al. (2019) presented a blockchain-based method to protect transaction records, by protecting sensitive personal information during data sharing, and also ensuring the efficiency of data sharing.

2.2. Smart contracts in data sharing
A number of smart contract-based schemes to facilitate big data sharing have been proposed, some of which have been implemented and used in practice. Bartoletti and Pompianu (2017), for example, studied how smart contract was interpreted in some of these platforms and analyzed the most common programming patterns in Ethereum. Their research work on the design patterns of these smart contracts helps other researchers make targeted improvements to these technologies related to smart contracts and blockchain. Mao et al. (2018) provided a blockchain-based credit evaluation system to strengthen the effectiveness of supervision and management in the food supply chain, which gathers credit evaluation text from traders by smart contracts on the blockchain. Zhuang et al. (2018) employed coded smart contract regulations to simulate several scenarios in healthcare processes. Various levels of data access privileges have also been designed to utilize a suite of customized smart contract settings. Wright and Serguieva (2017) proposed an efficient and secure automated management mechanism for smart contracts that is a method for the transfer of smart contracts underlying a hundred entities among disparate smart contracts or subcontracts. The scheme they proposed contributes to service delivery and enable resources to be accessed and allocated on a smaller scale. Gilcrest and Carvalho (2018) analyzed the value of smart contracts and blockchain as alternatives to traditional contractual obligations, as well as the advantages and disadvantages of replacing traditional contracts with these novel technologies. They also explored possible innovations in smart contracts and blockchain in the regulatory field, as well as how U.S. lawmakers are starting to deal with smart contracts and blockchain. Ali et al. (2018) proposed a secure data provenance framework for cloud-centric IoT networks by utilizing the immutable, deterministic and public nature of the blockchain smart contracts. They designed the framework in which the cryptographic hash of the device metadata is stored in the blockchain, while the actual data is stored off-chain. This approach makes the framework quite scalable in a network built with IoT devices. At the same time, in their design, they deploy multiple smart contracts in the blockchain to ensure the correctness of the source of the data stored in the cloud.

2.3. Copyright protection for big data
Copyright protection for big data is another topic of ongoing interest. For example, Agyekum et al. (2019) utilized a blockchain network, whose processing node acts as the proxy server that performs re-encryption on the data. To guarantee data confidentiality, the scheme stores some data on the blockchain and others on the cloud. The application of blockchain retains interaction records between entities and their solutions do not involve any trusted third party, while it also allows fine-grained access control. Liang et al. (2018) reviewed existing digital copyright protection mechanisms for big data markets, including digital copyright identification, digital rights management, digital encryption, watermarking, and others, as well as outlining challenges in data protection for the data trading lifecycle. In our big data era, the dissemination and transactions involving big data have also become more extensive, and data may involve secondary transactions without authorization from data sources. For example, Martin-Sanchez et al. (2017) identified common methodological challenges and reviewed relevant initiatives related to the re-use of patient data collected in routine clinical care, as well as analyzing the economic benefits derived from the secondary use of this data.

2.4. Digital watermarking for copyright protection
It is generally acknowledged in the literature that digital watermarking is an efficient solution to achieve copyright protection of big data. For example, Agrawal et al. (2003) demonstrated the potential to use watermarking database relations to deter data piracy. The advantage of their scheme is that there is no need to access the original data as well as the watermarking during watermarking detection. Moreover, the watermarking can be effectively maintained when inserting, updating, and deleting. And Lafaye et al. (2012) proposed a watermarking method for vectorial geographical databases especially on buildings. To protect the copyright of geographic data, their method can resist partial watermarking removal attacks, such as noise addition, cropping, and over-watermarking. Also, Bhargava et al. (2012) presented a digital image authentication system (DIAS), designed to perform visible and invisible watermarking on images. DIAS contains two main parts, one for hiding information inside images, and the other for image information detection, that can be applied for both color images and gray images. Recently, a watermark based access control scheme for image big data was proposed by Guo et al. (2018) Instead of storing the access control strategies on the server, their scheme adds access control strategies to the image being accessed as the watermarking. The accessors in this model can view images without accessing the server, which also reduces the burden on the server and reduces access delay. The above works can be considered as possibilities or achievements of the applications of digital watermarking in protecting image big data copyright.

Differing from these existing literature, we focus on achieving more flexible copyright protection, which relies on various protection policies embedded in watermarks. Specifically, we propose proactive protection based on smart contracts, and our scheme is decentralized without relying on any trusted third party.

In the next section, we will describe the problem formulation.

3. Preliminary
3.1. System model
Data sharing can be conducted by any individual participator who is part of the data sharing community, for example as paying customers. In other words, any entity that installs the client software will join the community as a member. We thus do not assume the existence of a centralized trusted party and do not rely on any intermediate data markets. We also assume all data trading can be conducted online, and all payments are conducted in a pre-defined blockchain system, which could be a virtual autonomous community or organization for big data sharing.

Current classical blockchain systems, such as Bitcoin (BTC),Ethereum (ETH), and enterprise operation system (EOS), can be applied as the underlying blockchain infrastructure, in which portfolios of smart contract functions can be enabled. As the copyright of data must be protected, client software of the blockchain system will be extended by plug-in tools, which implement our proposed extra functions, such as watermark embedding, watermark extracting, and block retrieving.

We also assume that concrete watermarking methods are available and independent of the design of our scheme; thus, it is out of the scope of the paper. Specifically, in this paper we focus on the design of blockchain frameworks and protocols based on smart contracts using available watermarks.

Blockchain can be broadly considered a virtual list-based database with decentralized consensus. Policies regulating the further transaction privileges can be stored in the blockchain, and can be accessed by all participants. Watermarks will convey policies and be embedded in trading data. Those policies usually can be negotiated off-line in the community as system parameters, specified by various watermarks, such as re-selling enabled and re-selling disabled.

3.2. Adversary model
In this section, according to the real process of data trading, we identify six typical potential adversaries in decentralized data trading scenarios which are the most common attacks on data trading participants and the most threatening attacks on data trading systems. The specific definitions of these attacks are shown as follows:

Definition 1

Repeat Transaction Attack. Adversary intends to re-sell prior purchased data. Specifically, the adversary sells the data purchased from a seller to another participant without authorization.

Definition 2

Partial Transaction Attack. Adversary intends to re-sell partial prior purchased data. Specifically, the adversary sells the partial data bought from a seller to another participant without the seller’s authorization.

Definition 3

Combination Transaction Attack. Adversary intends to combine multiple prior purchased data, partially or entirely. Specifically, the adversary sells the combined data bought from different sellers to another participant without authorization.

Definition 4

Leakage Transaction Attack. One intends to or makes mistakes to leak prior purchased data to others. Specifically, the adversary leaks the purchased data to other people.

In order to resist the above four attacks, our scheme uses robust watermarks that are embedded within data as identification, which are difficult to be tampered by attackers. In addition, transaction information and watermarking information are uploaded to the blockchain as a result of a transaction, and cannot be modified and can be easily traceable.

Definition 5

Transaction Fraud. One peer in the transaction is cheated by another peer, resulting in the loss of data or token. Specifically, on the one hand, the buyer has paid tokens to the adversary, but the adversary does not send the data to the buyer or sends the incorrect data to the buyer, which means the loss of the token for the buyer; On the other hand, if the adversary has received the data from the seller, however, the adversary does not pay for the data, which means the loss of the data for the seller.

Definition 6

Faked Transaction. The transaction information is faked. Specifically, the adversary only intends to interfere with the normal transaction and actually the adversary does not want to trade with the seller. The adversary can affect the performance and availability of the entire system by initiating a large number of faked transactions.

In order to resist the above two attacks, we regulate the transaction launching conditions by smart contracts pro-actively. In addition, transaction information and data watermarking information of both peers are stored in the smart contracts and executed automatically.

4. Proposed scheme
We will now present the key notations used in the remainder of the paper in Table 1.

To explain our proposed scheme, we assume there exist two entities called Alice and Bob where Alice has the data that Bob is interested in buying.


Table 1. Notations.

Notations	Description
Watermark
The token amount of traded data configured by Alice
The token amount of security deposit configured by Alice
Private key of Bob
Public key of Bob
Symmetric key of Alice
Symmetric key of Alice encrypted by 
Big data of Alice
Big data of Alice encrypted by 
Message digest for 
 from Alice
Message digest for 
 from Bob
Message digest for  from Alice
Message digest for  from Bob
Payment address configured by Alice
Address of traded data configured by Alice
Report of Bob
Time limit of every steps during the transaction
Time limit of sending report after Bob received the key
4.1. Design of smart contract templates
We leverage existing smart contracts and blockchain to perform two main functions: automatically responding to big data transactions and automatically responding to report information.

Also, we define the reward and punishment mechanism as follows:

Definition 7

Buyer’s reward mechanism. Before a transaction, Alice will pay a token amount of security deposit 
 to the smart contract. If Bob detects dishonest behaviors in big data , he can send 
 to the smart contract with Alice’s symmetric key  as evidence. After that, other miners can access  to verify 
 by ,  or  in . If 
 is true, then the smart contract will refund and compensate Bob with 
 that Alice paid.

Definition 8

Seller’s punishment mechanism. Similar to the above situation, if other miners verify 
 as true, then the smart contract will send 
 to Bob as compensation and refund Bob’s prior payment (i.e., 
).

Definition 9

Buyer’s punishment mechanism. If other miners verify that 
 as false, then the smart contract will send 
 to Alice and refund 
 to Alice.

To realize the data transaction, our smart contract will have the following three modules:

1.
Trading Module. This module receives the parameters that Alice or Bob sends, and the module can provide different responses according to the parameters. And this module in the smart contract includes the algorithm for the trading process, which is shown in Algorithm 1.


Download : Download high-res image (808KB)
Download : Download full-size image
2.
Verification Module. This module shows the address of the public tool to generate hash values. The module provides  and 
 that Alice claimed, and Bob can verify  and 
 by them. The specific process is shown in Algorithm 2.


Download : Download high-res image (782KB)
Download : Download full-size image
3.
Report Module. This module receives 
, and Bob should upload  received from Alice as evidence. In this way, other miners can access , then verify whether Alice cheats Bob by ,  or  in . Algorithm 3 describes this module.


Download : Download high-res image (721KB)
Download : Download full-size image
After Alice sets all parameters that need to be initialized in the smart contract, then Alice should deploy the smart contract designed above on the blockchain. Otherwise, the trading will not be accepted by others.

4.2. Initialization of smart contracts
All transactions need to adopt the above smart contract template, and Alice sets the parameters of the smart contract for trading.

First, Alice should generate a  and embed it into . The method  generated is 
where  is digital signing algorithm, 
 is Alice’s private key,  is any cryptographic hash function,  is the big data of Alice, and  is the watermark which embeds into  is the mark of  generated by Alice.

Seller (e.g., Alice):

(1) Compute 
, where  is the traded data;  is the symmetric key generated by Alice;  is any symmetric encryption function; and 
 is the encrypted traded data.

(2) Upload 
 to , where 
 is the encrypted traded data as in (1);  is the address of traded data configured by Alice.

(3) Compute 
, where  is the message digest for 
 from Alice;  is any cryptographic hash function; 
 is the encrypted traded data as in (1).

(4) Compute 
, where 
 is the message digest for  from Alice;  is any cryptographic hash function;  is the symmetric key generated by Alice as in (1).

(5) Upload , 
 and  to the smart contract, where  is the message digest for 
 from Alice; 
 is the message digest for  from Alice;  is the address of traded data configured by Alice.

(6) Send 
 to the smart contract, where 
; 
 is the token amount in smart contract configured by Alice; 
 is the token amount of security deposit in smart contract configured by Alice.

The above processes (1) and (2) are shown in Fig. 1 and the overall process is shown in Fig. 2.

We also remark that the inclusion of 
 allows one to verify that  Alice uploads to  is consistent with the data Bob downloads. There are two possible situations: 1) Alice uploads  which is not the digital commodity she claimed; 2) some attackers may tamper or destroy .


Download : Download high-res image (258KB)
Download : Download full-size image
Fig. 2. Initialization of the smart contract.

Besides, we set 
 and 
 in the smart contract, whose function is to guarantee the interests of Alice and Bob and complete the transaction. For example, if Alice receives 
 Bob paid, without Alice actually sending  to Bob, the smart contract will end the transaction and refund 
 to Bob after 
 runs out. Also, if the transaction process has been completed, and Bob does not send 
, after 
 exhausting, Alice can complete the transaction. In addition, the smart contract will send 
 and 
 to Alice.

4.3. Transaction response
The buyer who wants to buy  should first get the  in the smart contract.

Buyer (e.g., Bob):

(1) Download 
 from , where 
 is the encrypted traded data;  is the address of traded data configured by Alice.

(2) Get  and 
 from the smart contract, where  is the message digest for 
 from Alice; 
 is the message digest for  from Alice.

(3) Compute 
, where 
 is the message digest for 
 from Bob;  is any cryptographic hash function; 
 is encrypted traded data as in (1).

(4) Check if 
.

On the one hand, if Bob finds 
 and  in the smart contract are equal, Bob pays 
 to the smart contract, and then uploads 
 to the smart contract. This process is shown in Fig. 3. On the other hand, if Bob finds that 
 and  are not equal, Bob does not pay and gives up the transaction.

4.4. Transaction execution
Next, the process of transferring keys between the seller and the buyer is described.

Seller (e.g., Alice):

(1) Verify 
 in the smart contract, if 
 is correct then downloading 
, where 
 is the token amount in the smart contract configured by Alice; 
 is the public key of Bob.

(2) Encrypt  as the way of 
, where  is an algorithm for encrypting keys;  is the symmetric key of Alice; 
 is the public key of Bob as in (1).

(3) Upload 
 to the smart contract, where 
 is the symmetric key of Alice which is encrypted by algorithms  through  and 
 as in (2).

Buyer (e.g., Bob):

(1) Obtain 
, where 
 is the symmetric key of Alice which is encrypted by algorithms  through  and 
.

(2) Decrypt as the way of 
, where  is the symmetric key of Alice;  is the decryption key algorithm corresponding to ; 
 is the symmetric key of Alice which is encrypted by algorithms  through  and 
; 
 is the private key of Bob.

(3) Decrypt 
 by , where 
 is the big data of Alice encrypted by ;  is the symmetric key of Alice as in (2).

(4) Try to detect and extract  in , where  is the big data of Alice;  is the watermark.

This process is shown in Fig. 4.

4.5. Transaction monitoring
If Bob finds that the extracted  is problematic, then it could be one of these two cases: 1)  provided by Alice is incorrect and this lead to a messy ; 2) Bob finds two or more  in the , which indicates that the big data has been traded twice or more.

Buyer (e.g., Bob):

(1) Find the  in the  is incorrect or has some problems, where  is the watermark;  is the big data of Alice.

(2) Send 
 to the smart contract, where 
 is the report of Bob.

Verifier (e.g., Cindy):

(1) Check 
, where 
 is the report of Bob.

(2) Send the result of the 
 to the smart contract, where 
 is the report of Bob as in (1):

•
If 
 is verified correct by Cindy, then the smart contract will refund 
 to Bob and compensate for Bob by 
.

•
If 
 is verified incorrect by Cindy, the smart contract will send 
 and 
 to Alice.

•
If the verifier does not respond to 
, when 
 is run out, both Alice and Bob can end the transaction and the smart contract will refund 
 to Bob and 
 to Alice.

Also, miners can be rewarded for participating in the validation, which can be easily achieved in a smart contract. For example, if Bob’s report is correct, the miners participating in the verification can get 5% of 
 as a reward for the verification. If Bob’s report is incorrect, the miners participating in the verification can get 5% of 
 as a reward for the verification. This may serve as a motivation for invoking miners to participate in the validation. In addition, this is an anonymous network and we set a time limit for verification reports. Once the time limit is exceeded, the transaction will fail, and the smart contract will return 
 to Bob and 
 to Alice. Also, the validation message is broadcast. Since there is a reward for validation, miners will try to participate. In summary, it is very difficult to collude with a dishonest buyer in our proposed system.

4.6. Enhancement of flexibility
We will now describe how we improve the flexibility of our scheme, by carrying different trading strategies in watermarks for different types of transaction authorizations.

Different types of transactions can be specified by various types of watermarks. For example, data embedded with watermark 
 can be traded multiple times, but data embedded with watermark 
 can be traded only once (i.e., re-selling disallowed). Data embedded with watermark 
 can only be traded at specific time-span, and data embedded with watermark 
 can only be traded after  days, e.g.,  (this is also referred to as embargo).

Different types of watermarks correspond to different strategies. Data users can embed different watermarks into the data according to different needs. In addition, verifiers can also determine whether the transaction is legitimate according to the type of watermarks.

It is also necessary to initialize the authorization corresponding to the watermark type in the smart contract, which expands the function of the smart contract and makes the scheme we proposed more flexible.

In order to add new functions for our scheme, we first propose a method for generated watermarks with type information. The approach of generating watermarks is 
where  is digital signing algorithm; 
 is Alice’s private key;  is any cryptographic hash function;  is the big data of Alice;  is the watermark which embeds into  is the mark of  generated by Alice;  is the type information corresponding to specific transaction strategies;

We assume that there are  types of watermarks, where , for example, 
 and 
.  can also take on other values greater than 2, but an overlarge value of  is likely to result in a decrease in trading efficiency according to the transaction process of our scheme. Algorithm 4 describes the improved method.


Download : Download high-res image (637KB)
Download : Download full-size image
5. Discussion
5.1. Novel watermarks
In addition, we consider a method to enhance our proposed scheme. It may be possible to detect and extract watermarks in encrypted big data.

Due to the special construction of big data, we can use whitespace and other methods to construct the watermark. When encrypting big data, it is possible to encrypt readable content without encrypting watermark information such as whitespace. The result is that the available content is encrypted, but the watermark is not. Thus, buyers can verify the watermarks in the data without the need to first decrypt it.

5.2. Improvement of report module
In our scheme, if one buyer (e.g., Bob) sends the incorrect report, then Bob loses 
 he pays to the smart contract but he still obtains the data. Such a penalty is too light. Therefore, to improve our scheme and prevent malicious reports, we consider adding the following step before Bob sends the report.

•
If Bob wants to send a report to the smart contract, then he should pay the security deposit with a value that is commensurate with the value of the data to the smart contract first. Only upon the successful payment of such a deposit will the smart contract accept his report.

Algorithm 5 describes this module.


Download : Download high-res image (786KB)
Download : Download full-size image
5.3. Reliable methods to verify reports
The scheme we propose only lets one miner (not Alice or Bob) verify 
 and sends the result to the smart as the final result. In real-world trading situations, it may not be appropriate to verify 
 in such a manner, because that one miner has too much power. Therefore, to solve the problem, we present three effective rules to enhance our scheme:

1.
Only miners who have successfully traded a certain number of times can verify the report. A reputable miner is defined to be one who has completed many transactions and has a good reputation (since false/dishonest verification will impact on the miner’s reputation). To select the miners of good repute, we can trace logs and collect the trading information to analyze their reputation, and then design an algorithm to achieve the goal. For example, it is not hard to find a miner who had successfully completed at least  number of transactions in the recent  number of days.

2.
Set the minimum number of miners involved. If not only one miner is involved in the verification, we can set a number  that the report should be verified by at least  miners, or the verification is invalid. At the same time, we should make rules for judging the result of the verification finished by  miners.

3.
Set threshold values for verification. In order to solve the problem of judging the verification above, we consider that it is necessary to set threshold values. More specifically, for example, we can set a threshold value for the smart contract judging the result. We assume the threshold value is 75% and 50%. That means if there are at least 75% miners who join the verification agree the report is correct, then the smart contract can judge that the report is correct, and send all tokens to the buyer. But if the proportion is between 75% and 50%, the transaction is controversial, and the smart contract refunds tokens to both the buyer and the seller. And if the proportion is below 50%, the smart contract will believe the report is incorrect, thus it sends all tokens to the seller.

6. Evaluation and analysis
6.1. Experiment setting
We use Remix, an online editor to compile and run the code.1 And we refer interested readers to see our work on GitHub2 for the specific method and examples to use our scheme. Next, we will analyze the security and performance of our scheme.

6.2. Security analysis
We choose three typical and recent related work, namely: BDCP (Yang et al., 2018), TBDCT model (Guan et al., 2018) and SDTE (Dai et al., 2019), and compare them with our proposed scheme — see Table 2.

Proposition 1

Our scheme can defend against repeat transaction attacks.


Table 2. Comparison of transaction schemes’ capabilities against different types of attacks.

BDCP (Yang et al., 2018)	TBDCT (Guan et al., 2018)	SDTE (Dai et al., 2019)	Our scheme
Repeat transaction attack	×	×	×	✓
Partial transaction attack	×	×	×	✓
Combination transaction attack	×	×	×	✓
Leakage transaction attack	✓	✓	✓	✓
Transaction Fraud	×	✓	✓	✓
Faked transaction	×	✓	✓	✓
Proof

When the seller sells whole unauthorized big data (so-called repeat transaction) to others, the specific process to prevent the repeat transaction attacks is shown as the following steps:

1.
The buyer receives  and extracts  in .  is the big data of the seller and  is the watermark.

2.
The buyer finds there is one and only one  in . The buyer continues to verify the signature of :

(a)
The signature of  is correct. The transaction is successful, and the buyer can end the transaction. Then the smart contract will send 
 to the seller and refund 
 to the seller.

(b)
The signature of  is incorrect. That means the seller sells unauthorized data, and the buyer can report the seller to the smart contract. After the verification of the 
, the smart contract will send 
 to the buyer and refund 
 to the buyer.

3.
The buyer finds at least two  in . The big data sold by the seller must be unauthorized, and the buyer can report the seller to the smart contract. After the verification of 
, the smart contract will send 
 to the buyer and refund 
 to the buyer.

4.
The buyer finds no  in  or unrecognized  in . In our scheme, the seller should embed the watermarking before the transaction starts and ensures watermarking integrity. Therefore, it is the seller that breaks the rule of the transaction, and the buyer can report the seller to the smart contract. After the verification of 
, the smart contract will send 
 to the buyer and refund 
 to the buyer.

Driven by the rewards raised by the smart contract according to the different situations, buyers always choose to report repeat transaction behaviors for maximizing the interests. Therefore, sellers will not gain benefits from repeat transactions, which also means repeat transaction attacks will never happen. □

Proposition 2

Our scheme can defend against partial transaction attacks.

Proof

When the seller divides the data that has been previously purchased from another participant into several pieces and partially trades them, the buyer can still extract  in the partial data since we use robust watermarking. Thus, the partial transaction attack is a special kind of repeat transaction attacks, and the way to prove that it will never happen is the same as Proposition 1.  □

Proposition 3

Our scheme can defend against combination transaction attacks.

Proof

When the seller entirely or partially combines two or more pieces of different big data that the seller has bought from other participants previously together to sell, the buyer can still extract  in the combined data because of the robustness of watermarking we use. Therefore, the combination transaction attack is also a special type of repeat transaction attacks, and the method to prove that it will never happen is also the same as Proposition 1.  □

Proposition 4

Our scheme can defend against leakage transaction attacks.

Proof

When the buyer trades the obtained big data in the black market, due to the application of the robust watermarking, leakage transaction attacks can be prevented as below:

1.
Other participants in the black market want to buy the data sold by the buyer. The watermarking can be used as legal evidence, therefore they are subject to legal risk when they are found owning unauthorized data and they will be sentenced and should pay a large amount of money that is quite higher than the original price of the data for their wrongful trading practices.

2.
Other participants in the black market want to re-sell the data sold by the buyer. It is hard to implement in our system according to the rules we set, and it is also difficult to trade it in the black market for the high legal risk as mentioned above.

Taking the high legal risk for modest profits, the participants will not leak the data to the black market. □

Proposition 5

Our scheme can defend against transaction fraud.

Proof

When the seller or the buyer cheats the other party in the transaction, the designed smart contract and rewards and punishment mechanism in the system can be used to resist transaction fraud as follows:

1.
The buyer cheats the seller. This will never happen, because the transaction will be activated only when the buyer has paid 
, then:

(a)
The buyer receives 
 but (s)he does not confirm before the time limit. The smart contract will send 
 to the seller and refund 
 to the seller.

(b)
The buyer sends 
 to the smart contract for cheating the seller. If the result of verification on the smart contract shows that 
 is incorrect, the smart contract will send 
 to the seller and refund 
 to the seller.

2.
The seller cheats the buyer. If the seller does not upload the required parameters to the smart contract before the time limit in any step, the buyer can terminate the transaction, and then the smart contract will refund 
 to the seller and 
 to the buyer.

As shown above, the rewards and punishment mechanism and the process controlled by the smart contract can ensure that both parties cannot implement transaction fraud during the transaction. □

Proposition 6

Our scheme can defend against the faked transaction.

Proof

When any party implements the faked transaction, the methods to prevent such attacks is shown below:

1.
The buyer implements the faked transaction. The seller sets the amount of the deposit for the buyer as 
 and after the buyer pays 
 and 
 to the smart contract, the transaction starts. If the buyer does not continue the transaction in any step of the transaction, the smart contract will refund 
 and 
 to the buyer and 
 to the seller after reaching the time limit of the transaction.

2.
The seller implements the faked transaction. The seller should upload the data and calculate the hash values of each essential component in the transaction. The seller should also set the parameters for the smart contract initialization. Finally, the seller should send 
 to the smart contract to start waiting for the transaction.

On the basis of the above explanation, we can see that any party that launches the faked transaction will waste himself/herself a lot of time, tokens and the computing resources, but it only interferes with one transaction in the system. That also means if participants aim to attack the performance and availability of the system through launching a large number of faked transactions, they must take the huge consumption into consideration. Therefore, due to the enormous spending with little rewards, the faked transaction will never happen. □

In summary, digital watermarking mainly serves as protection of data copyright. The smart contract and reward and punishment mechanism are mainly used to realize automatic transaction and supervision, as well as to prevent transaction fraud and faked transactions.

6.3. Performance analysis
The proposed scheme does not rely on the third trust party, which can be applied in current edge computing scenarios and break individual security management constraints by self-governance. Also, it can avoid the burden of the centralized data market. The scalability of this architecture is better.

For decentralized self-trading, we propose a fair mechanism based on the smart contract, which can be executed at the client, which further improves the scalability. The proposed scheme is compatible with current mainstream blockchain infrastructure, e.g., Ethereum. The extra watermark enabling modules can be installed or as a plug-in with current blockchain client, thus the deployment is easy and portability can be guaranteed.

Since the transactions are time-sensitive, if each step of the transaction takes too long, it will have a negative impact on the entire trading system. Therefore, we test the response time of some vital steps of the smart contract.

In order to reduce the error, we tested multiple times and took the average of the response time of each important step as the result. The compiler version for testing is 0.4.24commit, and the test environment is JavaScript VM. The result is shown in Table 3. And the unit of the number in Table 3 is seconds.

From Table 3, we can see that the longest response time is 0.91 s, the shortest response time is 0.41 s, and the average response time of each step is less than 1 s. Also, the data fluctuation is small, indicating that the stability of the system is strong, for the maximum and minimum differences in time are respectively 0.18 s and 0.05 s in the same set of data in the table. In summary, our solution can meet the transaction time requirements.


Table 3. Performance analysis on response time.

Average
Deploy smart contract	0.73	0.83	0.91	0.85	0.88	0.840
Set amount	0.45	0.50	0.46	0.48	0.48	0.474
Upload hash of data	0.63	0.53	0.61	0.66	0.56	0.598
Send security deposit	0.46	0.50	0.55	0.45	0.41	0.474
Upload public key	0.81	0.80	0.75	0.82	0.76	0.788
End transaction	0.58	0.61	0.55	0.63	0.57	0.588
7. Conclusions
As the value of data becomes increasingly important, there is a need to secure such valuable data, particularly those that are intangible (e.g., intellectual property). Hence, in this paper we proposed a scheme to prevent unauthorized re-selling of big data. Specifically, our scheme uses smart contracts and watermarks, where we designed the smart contract template and adopted robust watermarks for the data trading. By using smart contracts to automate the entire process, the efficiency is significantly improved. Our proposed scheme can also resist a broader range of attacks compared to other recent approaches. In addition, the smart contract can be used to monitor transactions, and the reward and punishment mechanism can guarantee the fairness of buyers by reporting illegal transactions.

Future research includes implementing a refined prototype of our proposed approach in a commercial setting, for implementation in collaboration with a real-world service provider. This will allow us to more accurately evaluate the real-world utility of such an approach. In addition, some proofs will also be further improved in the future version.

