It is expected that in the future traditional gas, water, electricity, parking, etc. meters will be replaced by smart meters (i.e., smart IoT devices) to provide many advantages. To avoid the need to find power sources for a huge number of such smart meters, they are expected to operate on batteries and the batteries should be able to last for a long time to avoid frequent battery replacements. The operation office of these smart meters needs to collect their usage data periodically for billing purposes. In this work, we used wake-up radios (WuR) and a drone to design and implement a wakeup and data collection system to collect the usage data of smart meters. In our system, smart meters are powered off most of the time to save their battery power. When our drone approaches them and sends out a wake-up signal (WuS) packet, they will be powered on, send their usage data to the drone, and then be powered off. We have conducted real-life experiments to evaluate the performance of our system under different conditions. We measured the wakeup and data transfer success probability, the wakeup and data transfer delay, the amount of data that can be transferred while the drone is flying over a smart meter, and the power saving ratio for a smart meter. Experimental results show that our approach works well and can reduce the energy consumption of a smart meter by a factor of 180 when the data collection cycle is more than 10 days. Even if the data collection cycle is shortened to only 1 day, the energy consumption can still be reduced by a factor of 145.


Keywords
IoT
Power saving

Wake-up radio

Drone


1. Introduction
In a city, the number of gas, water, electricity, parking, or other kinds of meters is very huge. These meters measure the usages of various kinds of resources. The operation office of these meters needs to periodically collect their usage data for billing or data analytic purposes. A fast and low-cost data collection system to collect data from a large number of meters is essential to the operation office of these meters.

Recently, as more and more IoT devices are deployed, it is expected that in the future a city will become smart by having various kinds of smart IoT devices. Such a smart city will operate more efficiently and provide safer and more comfortable environments for humans to live in. Due to this trend, more and more smart meters, which are traditional meters equipped with smart IoT devices, are being deployed. Since the number of smart meters will be huge in the future, to avoid the need to find power sources for them (for electricity meters, this problem is less of a concern), it is expected that most of them will operate on batteries and these batteries should last for a long time to avoid frequent battery replacements.

Using the capability of smart meters, the way of collecting data from them can differ from the current way of collecting data from traditional meters. This difference provides an opportunity and imposes a challenge at the same time.

The opportunity is that the required manpower can be saved. In the current way, the operation office dispatches meter readers to the scenes of meters to collect their usage data. Because every home has gas, water, and electricity meters, a meter reader usually walks along streets to record the usage data of these meters. This manual data collection method is labor-intensive, time-consuming, and may cause man-made errors. To avoid these problems, a smart meter can use wireless transmissions to periodically transmit their data to the operation office through a wireless base station, gateway, or access point. For example, in Begishev et al. (2018), the authors used 3GPP LTE and NB-IoT technologies to collect data from IoT devices.

Although using wireless transmissions to replace meter readers is a way to solve the above problems, some smart meters cannot successfully transmit their data to the operation office by wireless transmissions. One reason is that the smart meter may be located at a place where the quality of the communication path between it and the wireless receiver is poor. This problem is very common for smart utility meters as their locations are usually near the ground and thus their wireless signals can be easily blocked by high buildings nearby. For example, in Wang et al. (2018), the authors used a Low-Power Wide-Area Network (LPWAN) technology to collect long-term PM2.5 air quality data on the campus and reported high packet loss rates at several locations.

As for the challenge, smart meters should operate for a long time without frequent battery replacements. If a smart meter consumes much power, its battery will need to be replaced often. With a huge number of smart meters in the future, this will be very labor-intensive and time-consuming. Thus, a smart meter should save its power as much as it can to prolong its battery life.

To exploit this opportunity and deal with this challenge, we apply the drone and WuR technologies in our system. The drone is used to replace meter readers to save manpower and the WuR is used by smart meters so that they can be powered off most of the time to greatly reduce their energy consumption. In our system, when the drone approaches these smart meters, it will send out a WuS packet to each of them. On receiving such a packet, a smart meter will be powered on, send its data to the wireless receiver mounted on the drone, and then be powered off. Since currently the cycle of manual data collection set by the operation office is very long to save manpower, which is two months in Taiwan for gas, water, and electricity meters, our system can significantly reduce the energy consumption of these smart meters.

Our paper makes the following contributions. First, through hardware and software co-designs and implementation, our system has successfully operated in real-life environments. We have used and deployed nine such smart meters on our campus and experimental results show that the drone in our system could successfully wake up and collect data from all of them. Second, using our system, we measured and reported its real-life performance including the wakeup and data transfer success probability, wakeup delay and data transfer delay, data transfer throughput, and data transfer size. Third, our measurements show that, as long as the data collection cycle is more than 10 days, our system can reduce the energy consumption of a smart meter by a factor of 180 when compared to the traditional always-on design. Even if the data collection cycle is shortened to only 1 day, the energy consumption can still be reduced by a factor of 145. Lastly, our system can wake up advanced smart meters that are equipped with a high-speed microcontroller running an operating system. Such smart meters can provide more advanced functions than those equipped with a low-speed microcontroller not running an operating system.

This paper is organized as follows. Related works are discussed in Section 2. Section 3 provides background information about the radio technologies that we used. Section 4 describes the hardware and software co-designs and implementation of our system. Section 5 presents performance results measured in real-life scenarios. Section 6 discusses several non-technical issues such as the cost of this approach and the regulations about this approach when deployed in the real world. Section 8 discusses future work that we plan to conduct. Lastly, Section 7 concludes the paper.

2. Related work
In the literature, many papers have studied how to use mobile sinks to perform data collection in Wireless Sensor Network (WSN) (Khan et al., 2014). A mobile sink in these studies could be a person, vehicle, drone, or other kinds of moving objects. Although the goal of these papers is the same as that of our system — collecting data from many devices, most of these papers only used simulations or mathematical models to perform the studies without designing and implementing a real system. For example, in Tazibt et al. (2017), the authors aimed to building a UAV-based (Unmanned Aerial Vehicle) data-gathering network. However, they only focused on planning the drone’s optimal flying path and their results were derived just based on their mathematical models. In contrast, our work focuses on designing and implementing a real drone-based data collection system and measuring its real-life performance.

In Saha et al. (2018), the authors used a Raspberry Pi (Anon, 0000a) development board and a drone to implement a smart agricultural system. The Raspberry Pi was equipped with a gas sensor, a RGB-D sensor, and a thermal camera. It was mounted on the drone to take images of the crops and gather the gas level on the ground. After getting the images and data of crops, it analyzed the images and data to judge the quality of crops. In their system, the drone did not communicate with IoT devices on the ground, which is different from the designs of our system.

The work reported in de A. Lima et al. (2018) measured the maximum achievable data rates of IEEE 802.11 when used to transfer data from an IoT device in a forest to a drone. Because the transferred data are the photos captured by a camera and the size of each photo ranged between 500 KB and 1 MB, the authors decided to use a high-rate IEEE 802.11 interface rather than a low-power-low-rate Sigfox (Anon, 0000b), LoRa (Anon, 0000c), or NB-IoT (Anon, 0000d) interface to transfer the photos. Compared with our work, although the authors also focused on sending data from IoT devices to a drone, the drone in their experiments did not use any WuR to wake up IoT devices.

In Chia-An et al. (2020), the authors envisioned an IoT network in which each IoT device uses a WuR to prolong its battery life and proposed two hashing-based schemes to achieve collision-free data transmissions for receiver-initiated data collection. The authors first assumed a small network topology in which the receiver can directly receive data from all IoT devices. Based on this small topology, they used mathematical models to analyze the performances of their proposed schemes including access success probability, access delay, and energy consumption. Then, they considered a larger network topology where the receiver cannot directly receive data from all IoT devices but instead need to partition the network for data collection. For such network topologies, they used simulations to compute the performances of their proposed schemes. Compared with our system, the authors in Chia-An et al. (2020) did not design, implement, or measure the performances of a real WuR-based data collection system.

The authors in Piyare et al. (2017) performed a survey about various WuR technologies and compared them from the physical layer to the network layer. They also made a detailed taxonomy of various WuRs and analyzed their advantages and disadvantages. Although they listed several usage scenarios for WuRs, they did not consider the scenario in which a drone flying in the air uses a WuR to wake up IoT devices on the ground.

In Won et al. (2015), the authors proposed a secure communication protocol between a drone and smart objects that could be waked up from sleep. They implemented the proposed protocol on real hardware devices to validate their designs and measure the on-line computation time required for key generation and exchanges. Compared with our work, their work did not use the WuR technology but instead used an IEEE 802.15.4 interface to simulate a WuR. As a result, reducing battery power consumption by using the WuR technology was not the focus of their work. Additionally, the smart objects in their work were equipped with a very low-speed microcontroller running TinyOS (Levis, 2006), whose functions were very limited. In contrast, in our work we used a Raspberry Pi running Linux operating system and a real WuR to implement smart meters. As a result, the hardware and software co-designs and implementation of our work differ greatly from those of their work.

Recently, the authors in Zhang and Li (2020) proposed a drone-enabled IoT relay system. They used the drone to collect the data of IoT devices in hard-to-reach areas. In their work, the IoT devices used IEEE 802.11ac as the main radio to transfer data to the drone and used LoRa as the wake-up radio. Compared to our work, their work did not focus on how to use wake-up radios to reduce the energy consumption of an IoT device. The authors used the FETMX6DL-C core board, which has a quad-core processor, as the hardware platform for the IoT device. In their system, the power of the IoT device was always on and the LoRa module, which was used as the wake-up radio, only turned on/off the IEEE 802.11ac interface rather than the whole hardware platform. As a result, the authors did not report any measurement results about energy consumption reduction enabled by their system.

We compare and summarize the differences between our work and the above related works in Table 1. The “X” mark in the table indicates “did not use”. One can see that our work is the only work that reports energy-saving results of IoT devices in real-life experiments. As can be seen from the table, two of them (Tazibt et al., 2017, Chia-An et al., 2020) used simulation approaches that operated in simplified and closed simulation environments. As a result, their performance data cannot be compared to the performance of our scheme, which was carried out in the real life under realistic communication effects such as Rayleigh fading effects. As for the other four works (Saha et al., 2018, de A. Lima et al., 2018, Won et al., 2015, Zhang and Li, 2020) that used real-life experiments to measure the performance of their schemes, they either did not implement the wake-up mechanism or did not report the wakeup performance in their paper because the wakeup mechanism was not their focuses. As a result, their papers do not report any wakeup performance and thus the performance of our scheme cannot be benchmarked with these works.


Table 1. Comparison of our work with other related works.

Ref	Method	IoT device MCU	Main Radio	WuR	Wake-up Mechanism	Report Energy Saving Results
Tazibt et al. (2017)	Simulation	X	X	X	X	No
Saha et al. (2018)	Real-life experiment	Rasp-Pi (Linux OS)	X
(camera capture)	X	X	No
de A. Lima et al. (2018)	Real-life experiment	Rasp-Pi (Linux OS)	IEEE 802.11	X	X	No
Chia-An et al. (2020)	Simulation	X	X	X	Broadcast
(Multiple devices)	Yes
Won et al. (2015)	Real-life experiment	low-speed MCU (TinyOS)	IEEE 802.15.4	IEEE 802.15.4	Broadcast
(Multiple devices)	No
Zhang and Li (2020)	Real-life experiment	4-core MCU
(Linux OS)	IEEE 802.11ac
(2.4 or 5 GHz)	LoRa	Not mentioned
(Single device)	No
Our work	Real-life experiment	Rasp-Pi (Linux OS)	IEEE 802.11n (2.4 GHz)	RFM69 915 MHz	Unicast
(Multiple devices)	Yes
3. Background
In this section, we provide background information about WuR and IEEE 802.11n WiFi, which are used in our system.

3.1. Wake-up radio technology
Currently, duty-cycling Medium Access Control (MAC) protocols are commonly used to prolong the battery life of IoT devices (Carrano et al., 2014). However, these protocols must maintain time to synchronize many IoT devices to ensure that the receiver is awake when the transmitter is sending data to it. Due to the used duty-cycling methods, a packet may have to wait for a long time before it can be transmitted. Besides, the receiver may suffer from idle listening, which wastes its battery power.

3.1.1. Architecture of wake-up radios
To overcome the aforementioned problems, the WuR technology was proposed. The authors in Piyare et al. (2017) made a thorough survey of state-of-the-art WuR hardware designs and the medium access control protocols suitable for them. Fig. 1 shows a typical architecture of a WuR.

Compared to the traditional architecture without using a WuR, an ultra-low-power, secondary radio module is added to the IoT device. This module is called the “Wake-up Radio transceiver”. The power consumption of this wake-up radio transceiver is much lower than that of the main radio transceiver, which is used to transmit data. Therefore, it can stay in the always-on state and let the microcontroller unit (MCU), which controls the main radio transceiver and various sensors, stay asleep or be powered off most of the time. When the wake-up radio transceiver receives a wake-up signal (WuS) packet, it will notify the MCU by sending a hardware interrupt to it. On receiving such an interrupt, the MCU will be powered on. Then, the MCU will turn on the main radio transceiver and use it to transmit the data.


Fig. 1. The architecture of a wake-up radio.

3.1.2. Transmitter-Initiated (TI) or Receiver-Initiated (RI) data transfer
Although using WuRs can overcome the problems caused by using duty-cycling MAC protocols, they still need to use a suitable MAC protocol to coordinate their uses. In Piyare et al. (2017), the authors classified the MAC protocols proposed for WuR into three categorizes according to which device plays the role of the initiator. These categories are: (1) transmitter-initiated (TI) data reporting, (2) receiver-initiated (RI) data collection, and (3) bi-directional data transfer, respectively. Fig. 2 illustrate the TI and RI communication schemes.

Transmitter-Initiated (TI).
In this scheme, the Transmitter initiates the data reporting process by sending the WuS packet to the Receiver. After the Receiver receives the WuS packet, it turns on its main radio transceiver and uses it to receive the data transmitted by the Transmitter. One drawback of this scheme is that the Transmitter does not know whether the Receiver has been successfully waked up before it uses the main radio to transmit its data to the Receiver. Since this scheme is more suitable for data reporting rather than data collection, our system does not use this scheme.


Fig. 2. Different WuR communication schemes.

Receiver-Initiated (RI).
In this scheme, the Receiver (i.e., the data collector, which is mounted on the drone in our system) actively sends WuS packets. When the specified Transmitter (i.e., an IoT device in our system) receives a WuS packet, it will turn on its main radio transceiver and use it to send its data to the Receiver. In our system, the drone acts as the data collector and it will fly over many IoT devices to collect their data. Because the RI scheme is more suitable for such scenarios, it is used by our system.

3.2. IEEE 802.11n WiFi interface
In our system, the main radio used on the drone and IoT devices is an IEEE 802.11n WiFi interface operating in the ad-hoc mode. Nowadays, most usages of WiFi use the infrastructure mode, in which an access point is needed to provide communication between it and a WiFi node. If two WiFi nodes need to exchange their data, their packets need to go through the access point. Although the infrastructure mode provides many advantages over the ad-hoc mode, it is inefficient for our system as the drone and a specified IoT device can communicate directly between themselves and there is no need to use an access point between them. Thus, our system uses the ad-hoc mode for the IEEE 802.11n interface. To be brief, in the rest of the paper, we will simply use the WiFi interface to refer to the IEEE 802.11n interface.

4. Design and implementation
To be brief, we use the “Receiver” to represent the device mounted on the drone that collects data from smart meters and use the “Transmitter” to represent a smart meter that sends data to the Receiver. To better suit the context, in the following we may use the “drone” and “Receiver” interchangeably. Additionally, we may use the “IoT device”, “Raspberry Pi”, “Transmitter”, and “smart meter” interchangeably.

4.1. System architecture
As depicted in Fig. 3, our system has two different kinds of devices: the drone and IoT devices. Each of them has two radio transceivers: the WuR (operating at 915 MHz) and WiFi (operating at 2.4 GHz). Because the range of WuR is longer than that of WiFi, the IoT device will be waked up first before it can use WiFi to transmit its data to the drone. After receiving the WuS packet, the WuR of the IoT device powers up the MCU of the IoT device, which then boots up its operating system and then continuously tries to establish a TCP connection with the drone over WiFi. After a short time interval, when the drone enters the WiFi range of the IoT device, the TCP connection setup will succeed. Then, the IoT device starts sending its data over the established TCP connection to the drone. After the data transfer is completed, the IoT device will automatically shut down and be powered off.

In our system, the operation phase of an IoT device repeatedly goes through: (1) sleep, (2) boot, (3) active, (4) shutdown, and (5) sleep again. Note that due to the designs of our system, when we say that an IoT device, whose MCU is a Raspberry Pi, is in the sleep mode, actually it is powered off completely. The details of our design and implementation will be presented later. The boot phase is the interval in which the Raspberry Pi is powering up and booting up its operating system. The active phase is the time interval in which the Raspberry Pi is powered up and is used for transmitting data from the Raspberry Pi to the drone through WiFi. The shutdown phase is the interval in which the Raspberry Pi is shutting down its operating system and then be powered off.


Fig. 3. The work flow of our system.

4.2. Hardware selection
4.2.1. Microcontroller unit
For an IoT device, the MCU that it uses plays an important role. IoT devices performing simple tasks often seek to save power and thus the MCUs that they use usually run very lightweight operating systems (OS) or even do not run any OS. Two such examples include the Arduino using the ATmega328P microcontroller and STM32 using the ARM Cortex X microcontroller. Because our system uses the WuR technology, our system can afford to use a more powerful MCU for IoT devices so that they can perform more advanced functions as smart meters. Thus, we decided to use a Raspberry Pi 3 Model B (Anon, 0000a) as the hardware platform for the IoT devices in our system. Raspberry Pi 3B is a Single Board Computer (SBC) released by the Raspberry Pi Foundation in 2012. It is based on the ARM architecture and runs the Linux operating system (Raspbian GNU/Linux 9, Linux kernel version: 4.19.66), which enables it to perform various advanced tasks. It supports wireless radios such as WiFi and Bluetooth and its MCU (a 64-bit quad-core ARM Cortex-A53) runs at 1.2 GHz. These capabilities allow a Raspberry Pi to connect various IoT sensors and act as a smart IoT device.

4.2.2. Main radio
When selecting the main radio used by the drone and IoT devices, the range and data rate must be considered. The range must be large enough for a drone flying at a high altitude to exchange data with an IoT device on the ground. Because the goal of our system is to collect data in a smart city, the drone must fly at least 60 m above the ground, which is about 20 floors, to avoid hitting buildings. This means that the range must be much larger than 60 m so that the strength of the signal received at the drone or the IoT device can be strong enough to enable high-rate transmissions. The data rate of the main radio is also an important consideration. If the data rate can be high, during the short interval while the flying drone and the IoT device are still within the range of their main radios, a large amount of data can be transferred from the IoT device to the drone. The transferred data can be a high-resolution picture or a short video clip, which enables more versatile IoT applications.

Although the Raspberry Pi has a built-in WiFi interface, our system does not use it. To keep its size to a minimum, the Raspberry Pi uses a chip antenna soldered directly on the board to send and receive wireless signals. This compact design, however, limits the range of its built-in WiFi interface to be less than 30 m and thus unsuitable for our system. Therefore, we used the Aisie WS24L wireless adapter (Anon, 0000e) with a 2 dBi gain antenna as shown in Fig. 4(a) as the main radio. Its product specifications state that its range can reach 830 m in open space and its maximum data rate can go up to 150 Mbps. Because in our system the drone flies at an altitude of 60 m, we measured the maximum horizontal distance between the drone and the IoT device within which their WiFi interfaces can still be used to transfer data. We found that it was about 400 m. To be brief, in the rest of the paper we will simply use the “ WiFi range” to refer to it.

4.2.3. Wake-up radio
When choosing the WuR, we want the WuR to be ultra low power because it must be always on to listen for WuS packets. The WuS packet sent out by a WuR is a tiny packet of only 32 bytes. Due to its small size, unlike the main radio, a WuR need not transmit its packets at a high rate. Instead, a low-rate WuR is good enough and providing a long wake-up range is more important. Considering these requirements, we chose the RFM69HCW Anon (0000f) module shown in Fig. 4(b) as the WuR used on the drone and IoT devices. The RFM69HCW can generate a hardware interrupt from each DIOx pin to wake up the MCU when it receives a WuS packet. It operates at the 915 MHz frequency band and its transmit power and data rate can be configured to suit different needs. In our system, we set its data rate to 300 kbps and its transmit power to +13 dBm. Like what we did for measuring the maximum WiFi range when the drone flies at an altitude of 60 m, we conducted similar measurements and found that the maximum WuR range was about 500 m for the drone.

4.2.4. Delay relay module
On the IoT device, we used a programmable delay relay module shown in Fig. 4(c) to control when and how much time to provide power to the Raspberry Pi. Its relay function controls whether to provide power to the Raspberry Pi. Its delay function controls how long to continuously provide the power once the relay function is turned on. In our system, the delay is set to 120 s to give the Raspberry Pi enough time to boot up and transfer its data to the drone. It can be adjusted to suit different IoT applications.

4.2.5. Block diagram and circuit schematic
Fig. 5 shows the block diagram of our system. The WuR (i.e., RFM69HCW) uses an SPI (Serial Peripheral Interface) to communicate with the Raspberry Pi so that the Raspberry Pi can program it. The Aisie WS24L WiFi wireless adapter communicates with the Raspberry Pi through a USB port and it appears as a network interface to the operating system of the Raspberry Pi. The “relay function” block indicates the used delay relay module. It is used only on the IoT devices and not used on the drone.

To properly connect these components and make the whole system function correctly, we designed a circuit and its schematic is shown in Fig. 6. The input voltage is 12 V. Because both the Raspberry Pi and relay function need 5 volt power input and the RFM69HCW needs 3.3 volt power input, two voltage regulators LM7805 and LT1086 are used to lower the input voltage to 5 V and 3.3 V, respectively. After the raw voltage input, a 10 ohms resistor R1 and 100  capacitors C1, C2, C3 are used in the circuit to reduce inrush currents. We welded an antenna on the RFM69HCW and its gain is  dBi.


Fig. 5. The block diagram of our system.

When the RFM69HCW receives a WuS packet, it will generate a signal on its DIO0 and DIO2 pins. With this signal and the inverter transistor Q1, the RFM69HCW controls the relay function whether to provide power to the Raspberry Pi. The same signal is forwarded to the Raspberry Pi as an interrupt signal via its GPIO25 (Pin 22). This notifies the Raspberry Pi to generate and send an ACK packet to the RFM69HCW after booting up, which will be explained in Section 4.3.1. We sent the circuit schematic to a PCB company to manufacture 10 PCBs of this circuit. The bottom and largest PCB shown in Fig. 13 shows one of them.


Fig. 6. The circuit schematic of our system.

4.3. Wireless communication protocol
In our system, we designed and implemented a communication protocol for the WuR and main radio, respectively. In the following, we explain the detailed designs.

4.3.1. Wake-up radio
Our system wakes up multiple IoT devices through sending unicast WuS packets to each of them rather than sending multicast or broadcast WuS packets to wake them up at the same time. Although using the multicast/broadcast mechanism seems more bandwidth efficient for WuR, several serious problems may occur with this method and thus we decided to use the unicast mechanism instead. The first problem is that after being waked up, transferring data, and then being powered off, an IoT device may be re-waked up again, again, and again each time when it receives a multicast/broadcast WuS packet. This will unnecessarily waste its battery power. The second problem is that since the range of WuR is larger than that of the main radio, when a multicast/broadcast WuS packet simultaneously wakes up many IoT devices, they will need to wait until the drone flies into the range of their main radios before they can start transferring their data to the drone. However, since the drone will fly away from the IoT devices that are in the back of it, the drone will not enter the main radio range of these IoT devices. In this case, these devices are unnecessarily waked up and their battery power is unnecessarily wasted. Another problem is that if too many IoT devices are waked up simultaneously by a multicast/broadcast WuS packet, they will contend for the bandwidth of the shared main radio channel to transfer their data to the drone, resulting in a high packet collision rate and a low data transfer throughput for each IoT device. For these reasons, our system currently uses the unicast mechanism to control when to wake up an IoT device.

Fig. 7 shows the format of WuR packets. The WuS packet sent by the drone and the ACK packet sent by the IoT devices use the same packet format. They are distinguished by their Destination RFID and Source RFID. The RFID length is 64 bits. The entire packet size including the preamble and CRC (Cyclic Redundancy Check) is 256 bits in total, which is only 32 bytes. Since the data rate of RFM69HCW is 300 kbps, the transmission time () of a WuS packet or an ACK packet is 853.3 microseconds. In our design, every time when the drone sends a WuS packet, it will listen for a short period of time to receive ACK packets before sending WuS packets to other IoT devices. Note that the ACK packets to be received may be sent by the IoT devices that have received their WuS packets earlier. If this period is set too short, the probability of successfully receiving ACK packets may decrease. Thus, we set it to 10 times the Tx time, which is  microseconds = 8.53 ms. With this setting, the drone can wake up more than 100 IoT devices in one second, which is fast enough for the smart meter data collection application.

The protocol used by the Receiver (i.e., the drone) to wake up multiple Transmitters (i.e., IoT devices) is shown in Fig. 8. In our system, the WuR of each device (including the Receiver and Transmitters) is given a unique RFID. The Receiver maintains a wake-up list containing the RFIDs of the Transmitters that need to be waked up at present. The initial wake-up list can be pre-programmed or received via the LTE network. In this work, we used the LTE network to transmit the initial wake-up list to the Receiver. Assuming that the Receiver knows the locations of all Transmitters, it can dynamically update this list based on its current location, flying speed, and flying direction and the locations of the Transmitters whose data should be collected. For example, based on its current location, the Receiver can simply put the Transmitters that are within the range of its WuR on the list. Considering the current flying speed, flying direction, and pre-planned flying paths ahead, the Receiver can further filter the list by dropping out those Transmitters that are in the back of the Receiver as the Receiver will move away from them. More advanced methods used to update the current wake-up list are possible and we leave this work as one of our future work. In Section 5.7, we used a small field trial to demonstrate a possible way to update the current wake-up list.


Fig. 7. The packet format of WuR packets.

The Receiver sends WuS packets to the Transmitters in the wake-up list using the RR (Round Robin) method with an interval of 8.53 ms between sending two WuS packets. As explained in Fig. 7, this period is used to receive ACK packets and they may come from other Transmitters that have received their WuS packets and not necessarily come from the Transmitter whose WuS packet was just sent. This asynchronous design enables the Receiver to wake up other Transmitters before receiving an ACK packet from the current Transmitter. When the Transmitter receives a WuS packet, it parses the WuS packet to check the destination RFID and source RFID. Because the RFM69HCW operates in the unlicensed 915 MHz band, which is shared by many different applications, the Transmitter will process the received WuS packet only when the destination RFID is the same as its own RFID and the source RFID represents the Receiver from which it wants to receive the WuS packet. Otherwise, it will drop the received WuS packet without processing it.

When processing the WuS packet, the RFM69HCW generates a signal to the relay function to provide power to the Raspberry Pi. It also sends an interrupt signal to the Raspberry Pi as explained in Section 4.2.5. This design is for the following reasons. Since the RFM69HCW does not have an MCU, it cannot create an ACK packet and send it to the Receiver by itself after receiving the WuS packet. Thus, in our design, after the Raspberry Pi is boot up, it uses SPI to control the RFM69HCW and switches its mode to the transmit mode to transmit an ACK packet, which is created by the Raspberry Pi, to the Receiver. When the Receiver receives the ACK packet, it will remove the Transmitter from its current wake-up list. Note that after the ACK packet is sent, the RFM69HCW returns to the receive mode. Such a design is for the case that the sent ACK may get lost. In that case, because the Receiver (drone) will send another WuS packet to the Transmitter, the RFM69HCW needs to stay in the receive mode to receive the WuS packet and then sends back the ACK packet.

The WuS packet sent to a Transmitter may be lost due to weak signal or interference. However, since the Receiver will repeatedly send a WuS packet to each Transmitter on its current wake-up list, in a few rounds the Transmitter will successfully receive the WuS packet and be waked up. If the ACK packet sent by the Transmitter to the Receiver is lost due to weak signal or collisions with the ACK packets sent by other Transmitters, the Receiver will send a WuS packet to the Transmitter in the next round and this process will continue until it receives an ACK packet from the Transmitter. Due to the designs of our circuit, if the Transmitter (i.e., the Raspberry Pi) is already powered on and it receives a WuS packet, the remaining time of the relay’s delay will not be reset to the full delay. Instead, it will continue to count down until it expires and at that moment the relay function will cut off the power to the Raspberry Pi.

On the other hand, as explained in Section 4.2.5, receiving a WuS packet will cause the RFM69HCW to generate an interrupt signal to the Raspberry Pi. When the Raspberry Pi is powered on, each time when it receives such a signal, it will create and send an ACK packet to the RFM69HCW asking it to send the ACK packet to the Receiver. Due to this design, even if all earlier ACK packets were lost, the Receiver will continue to send WuS packets to the Transmitter until it receives an ACK packet from the Transmitter. Since the ACK packet is generated by the Raspberry Pi rather than the RFM69HCW, receiving an ACK packet means that the Raspberry Pi has been powered up, its operating system has been boot up, and the programs running on it are ready to transfer data to the Receiver.

4.3.2. Main radio
As presented earlier, our system uses the ad-hoc mode WiFi interface as the main radio for transferring data from the Transmitter to the Receiver. Because in our system we want the Transmitter to be able to reliably transfer a large amount of data to the Receiver, our system uses the TCP protocol for the data transfer. In our system, a server process is executed on the Receiver, passively waiting for a TCP connection request to arrive. On the other hand, a client process is run up on the Transmitter after the Raspberry Pi is boot up and it actively sets up a TCP connection to the server process. Fig. 9 shows the steps for setting up a TCP connection between the Transmitter and Receiver and transferring data over the connection via the main radio.

Because the range of WuR is larger than that of main radio, after the Raspberry Pi is boot up, the first few TCP connection setup requests made by the Transmitter over its main radio may fail due to out of range. The TCP connection will be established when the Receiver flies into the range of the main radio of the Transmitter. However, because TCP will increase its retransmission timeout period exponentially after each failed retransmission, the TCP retransmission timeout period may grow up to 127 s. After that, the TCP connection request will fail. To overcome these problems, the client process uses the non-blocking mode to call the connect() system call to set up the TCP connection. By using this mode, the client process can initiate a new TCP connection request every second without being blocked for a long time due to long TCP timeouts.


Fig. 9. The steps for setting up a TCP connection and transferring data over the connection via the main radio.

After the TCP connection is established, the server process running on the Receiver calls the fork() system call to fork a child process to handle this new connection. As for the original server process, it continuously waits for new connection requests to arrive from other Transmitters. The client process transfers its data to the child server process over the established TCP connection. When the transfer is completed, the client process closes the TCP connection and the child server process is terminated. The client process then calls the shutdown() system call to shut down the operating system of the Raspberry Pi. When the relay delay timer expires, the relay function cuts off the power to the Raspberry Pi, which causes the Raspberry Pi to be powered off. As mentioned in Section 4.2.4, currently the full delay is set to 120 s and it can be adjusted depending on the amount of data to be transferred over the connection and other factors such as the flying speed of the Receiver, the bandwidth of the used main radio, the power on and boot up time of the Transmitter, etc.

To clearly show the operations performed by the drone and the IoT device and their interactions, Fig. 10, Fig. 11 show the flow chart of the operations of the drone and that of the IoT device, respectively.

5. Performance evaluation
To study how much energy of a Transmitter can be saved by our system and how much data can be transferred from a Transmitter to the Receiver while the Receiver is flying over the Transmitter, using only one Transmitter is enough for such performance evaluations. Therefore, in this work we used only one Transmitter for performance evaluation.

5.1. Experimental settings
Fig. 12(a) shows the photo of a Transmitter and Fig. 12(b) shows the photo of the Receiver, respectively. We placed the Transmitter on a chair about 1 meter above the ground in open space. The connection between the smart meter and the drone is in line-of-sight (LOS) condition. The Receiver was mounted on the drone and the drone flew at an altitude of 60 m to avoid hitting buildings. In each experiment, the drone took off from a place that was 600 m away from the Transmitter and flew towards the Transmitter. The purpose of choosing 600 m as the initial distance between the drone and the Transmitter was that this distance is greater than the range of the WuR. With these settings, the scenario of the experiment could simulate the real-life scenarios.

5.2. Energy consumption comparison
Here, we compare the energy consumption of a Transmitter if it is always powered on with that if it operates in our system. If a Transmitter is always powered on, its MCU needs a continuous power supply. Since the MCU of the Transmitter is a Raspberry Pi and the specification shows that generally the input voltage and current consumption of a Raspberry Pi are 5 V and 250 mA, respectively, the power consumed by it in a data collection cycle is shown in the following equation. Note that: (1) when the Raspberry Pi connects more I/O devices/sensors, its current will increase, (2) there are 86400 s in one day, (3) the symbol  represents the data collection cycle in days, and (4) the computed energy consumption is in Joule. (1)

The energy consumption of our system in a data collection cycle is composed of two parts: the part consumed in the period when the Raspberry Pi is powered on and the part in the period when it is powered off. The two parts can be computed respectively and then summed together to obtain the energy consumption of our system in a cycle. Because the delay of the relay function is set to 120 s in our system, the powered-on time in a cycle is 120 s and the powered-off time is the cycle time in seconds minus 120 s. During the powered-off time, the WuR transceiver still consumes energy with 3.3 V as its input voltage. To precisely calculate the energy consumed by the WuR while the Raspberry Pi is powered off, we need to consider its operations in more details as follows.

According to the specification of RFM69HCW, it has three operating modes including the transmit mode, receive mode, and idle mode. These three modes consume 45 mA, 16 mA, and 1.2 A, respectively. To reduce its energy consumption while listening for WuS packets, it can be configured to periodically switch between the receive mode and the idle mode. During the idle mode, only the RC oscillator runs and thus the current consumption can be reduced to only 1.2 A.

For the RFM69HCW, the time staying in the receive mode () and in the idle mode () can be set to 4.1 ms multiplied by N, where N can be a value between 1 and 255. As presented above, because the time interval  used by the drone to send two consecutive WuS packets is set to 8.53 ms, we set the N value for to 22, which uses 90.2 ms for and it is about 10 times . To save energy, we set the N value for to 255, which uses 1045.5 ms for . With these settings, the ratio of to is 11.59. If we increase the ratio, more energy can be saved. However, doing so may increase the wakeup delay or even make the wakeup process fail. Thus, currently we use these settings. (2)(3)(4)(5)(6)

In the above, A1 is the average current consumption of the RFM69HCW during the Raspberry Pi’s powered-off period. Suppose that the data collection cycle is c days in length. Since in a cycle, the Raspberry Pi’s powered-on period is 120 s, P1(c) is the energy consumption of the RFM69HCW when the Raspberry Pi is powered off in a cycle. Because to simplify the design of our system, we let the RFM69HCW stay in the transmit mode during the 120-second powered-on period, X is its energy consumption in this period. As for Y, it is the energy consumption of the Raspberry Pi when it is powered on. Summing up these parts, (c) is the ideal energy consumption of our system in a data collection cycle, assuming it is c days long.

Next, we measured the real current consumption of our system with a digital ammeter as shown in Fig. 13. The measurements were conducted separately under three different conditions. First, we powered off the Raspberry Pi and let the RFM69HCW stay in the receive mode to measure the current consumption. As shown in Fig. 13, it was 3.38 mA and less than the 16 mA documented in the specification. Then, the Raspberry Pi remained powered off and we let the RFM69HCW stay in the idle mode. In this condition, the current consumption was 282 A, which is greater than the 1.2 A documented in the specification. The extra current consumption may be due to our using two voltage regulators and resistors in the circuit and 12 V as the input voltage for our system (see Fig. 6). Then, we powered on the Raspberry Pi and let the RFM69HCW stay in the transmit mode to measure the current consumption during the powered-on period. According to the digital ammeter, the current consumption of our system in this condition exhibited a special pattern. In the beginning, the current consumption stayed at 60 mA for one second. Then, it went up to 200 mA immediately and then gradually went down back to 60 mA. This pattern repeated itself continuously. This pattern is caused by the Raspberry Pi and we do not know how to explain it. To obtain the average current consumption, we set the average current consumption during this powered-on period to mA. With these measured current consumption, we calculate the real energy consumption of our system in a data collection cycle by the following equations: (7)(8)(9)(10)

In the above, A2 is the average real current consumption of the RFM69HCW during the Raspberry Pi’s powered-off period. P2(c) is the energy consumption of the RFM69HCW when the Raspberry Pi is powered off in a cycle. Z is the real energy consumption of our system when the Raspberry Pi is powered on. Summing up the two parts, (c) is the real energy consumption of our system in a data collection cycle, assuming it is c days long.

Fig. 13. Measuring the current consumption of our system by using a digital ammeter.

Under different values of the data collection cycle length c days, Fig. 14 compares the (c), (c), and (c), which are the lines denoted by the “Without WuR”, “with WuR (ideal)”, and “our system”, respectively. Clearly, without using WuRs, the energy consumption in a data collection cycle is proportional to the cycle length and much larger than that when using WuRs. When using WuRs, the lines of (c) and (c) overlap together and look almost the same on the used KJoule scale.

To clearly see the difference between the (c) and (c), we calculate two power saving ratios of and and show them in Fig. 15. The former ratio is the curve denoted by “with WuR (ideal)” and the latter ratio is the curve denoted by “our system”. The power saving ratio represents how many times the power consumption of the always-on scheme can be reduced by using our system. There is a gap between the power saving ratio of our system and the ideal power saving ratio. The reasons for the difference have been discussed above when deriving the equations of (c) and (c), and the difference may be reduced by using a more advanced circuit design. From the curve of “our system”, we can see that its power saving ratio can go up to 180 when the cycle length is larger than 10 days. Even when the cycle length is shortened to only 2 days, the power saving ratio of our system can still reach 160.

5.3. Wakeup and data transfer success probability
In a real-life scenario, the drone may not fly right over an IoT device. Usually, it follows the streets and collects data from nearby IoT devices. In the following experiments, we tested different flight routes for the drone and they are shown in Fig. 16. These routes differ in their horizontal shortest distance to the IoT device. (To be brief, in the rest of the paper we will just use the “shortest distance” to refer to the “horizontal shortest distance” when the context is clear.) The shortest distance affects the strength of received signals sent over the main radio (i.e., WiFi) and thus affects the throughput of the data transfer from the IoT device to the drone. In the experiments, two different speeds were used for the drone and they are 13 km/hr and 26 km/hr, respectively.

For the drone to collect data from an IoT device, we define a success as follows. We regard the entire process of the drone approaching and leaving the IoT device as one round. In each round, if the drone can wake up the IoT device and receive 1 K bytes of data through WiFi, we call this round a success. On the contrary, if the IoT device cannot be waked up, this round is considered as a failure. The reason for using 1 K bytes as the threshold is because the size of the usage data of most smart meters is very small and generally less than 1 K bytes. For this reason, the LoRa network (Anon, 0000c) limits its packet size to only 50 bytes and the Sigfox (Anon, 0000b) network limits its packet size to only 12 bytes.


Download : Download high-res image (169KB)
Download : Download full-size image
Fig. 16. The shortest distances of different flight routes.

Even if an IoT device can be waked up, its 1-KByte data transfer may fail. As explained in Section 4.3.2, after the IoT device is waked up, it is likely that the drone has not entered its WiFi range. Thus, even though the IoT device continuously tries to establish a TCP connection to the drone to transfer data to it, the connection setup may fail in the first few attempts and the data transfer over the connection thus has to be delayed. Since the delay of the relay function is set to 120 s, if the drone cannot fly into the WiFi range within 2 min since the IoT device is waked up, the Raspberry Pi will be shut down and then cut off its power supply. In such a case, no data will be transferred to the drone, even though the IoT device has been awakened. In all of the above cases, we regard it as a failure.

Fig. 17 shows the success probability vs. different shortest distance when the drone flew at two different speeds. For each flying speed, we conducted real-life experiments 10 times for each shortest distance and used the number of successes to calculate the success probability. As shown, the success probability is 100% when the shortest distance was within 80 m. Within 240 m, more than 50% of tested rounds succeeded. At 400 m, which is almost the WiFi range, the success probability is 0% for the 26 km/hr speed and 10% for the 13 km/hr speed. These results show that as the shortest distance increased, the success probability decreased, which was reasonable and expected.

The flying speed of the drone can affect the success probability. As shown in the figure, when the shortest distance was larger than 240 m and the drone flew at a lower speed (13 km/hr), the success probability was higher. This can be explained by Fig. 18. In this figure, 400 m is used as the WiFi range and 500 m is used as the WuR range. is the range on the flight route where the drone is in the WiFi range of the IoT device. Note that is the range on the route where the drone is in the WuR range of the IoT device and is the range on the route where the drone can wake up the IoT device but the IoT device cannot send data to it via WiFi. As can be seen, when the shortest distance increases, will decrease, and the amount of time in which the drone stays in will decrease. If the drone uses a higher speed to fly, this amount of time will be further reduced. This will reduce the chance of successfully setting up a TCP connection over WiFi and then finishing the data transfer over the TCP connection. This explains why in Fig. 17 when the shortest distance gradually approaches the WiFi range, using 13 km/hr rather than 26 km/hr as the flying speed of the drone results in higher success probabilities.

The experimental results measured and reported in Fig. 17 show that when the shortest distance was less than 80 m, the success probability of our system can be 100%. If the drone knows the locations of IoT devices, which is not hard for fixed-location smart meters, and knows its current location, which is available through its own GPS receiver, the drone can send out unicast WuS packets to wake up a specific IoT device only when the shortest distance to that IoT device is less than 80 m. At a shortest distance that is larger than 80 m such as 160 m, although the success probability may drop to 70% or 80% (depending on the used flying speed), the drone can still send out unicast WuS packets to wake up a specific IoT device. If the wakeup and data transfer cannot succeed, the drone can try the wakeup again when it gets close to the IoT device at a later time, may be on a different route. There are several strategies that can be used to collect data from many IoT devices through using multiple rounds and multiple routes for the drone. Note that using multiple rounds and multiple routes for the drone to collect data may be needed as even when the shortest distance is less than 80 m, the wakeup and data transfer may still fail due to the blockage of wireless signals caused by nearby high buildings in certain directions. To overcome such problems, the drone may need to approach the IoT device on different routes. Because such large-scale performance studies require expensive hardware resources and are better conducted by simulations, we leave them as our future work.


Download : Download high-res image (217KB)
Download : Download full-size image
Fig. 17. The success probability on routes having different shortest distances.


Download : Download high-res image (192KB)
Download : Download full-size image
Fig. 18. The range on the flight route where the drone is in the WiFi range of the IoT device.

5.4. Wakeup delay and total delay
We define the wakeup delay as the elapsed time from when the IoT device receives a WuS packet to when the IoT device uses its WuR to send back an ACK packet to the drone after its Raspberry Pi is turned on. The total delay is defined as the wakeup delay plus an additional time to successfully transfer 1 K bytes of data to the drone.

When measuring the elapsed time, we encountered a difficulty as follows. When the RFM69HCW of the IoT device receives a WuS packet, the Raspberry Pi is powered off. Thus, we cannot get the current time from the Raspberry Pi’s clock, which is needed to calculate the wakeup delay. To overcome this problem, we pre-powered on the Raspberry Pi in this set of experiments. When the RFM69HCW received a WuS packet, it generated and sent an interrupt via its DIO0 pin to the Raspberry Pi. At this time, the Raspberry Pi stored the current time into a file and rebooted itself. After the reboot, the Raspberry Pi sent out the ACK packet and then subtracted the stored time from its current clock to obtain the wakeup delay. Using this method, the wakeup delay measured was not the boot-up time but instead was a slightly longer reboot time.

For each different shortest distance, we conducted 10 experiments. Because the success probability is almost 0% in the 400-meter shortest distance case, we did not conduct experiments for this case. Fig. 19, Fig. 20 show the wakeup delays when the drone flew at 13 km/hr and 26 km/hr, respectively. The “Experiment ID” on the horizontal axis indicates the 10 experiments conducted for each different shortest distance. Fig. 21 shows the average and standard deviation of the wakeup delays of these results under different shortest distances. As shown in these figures, these wakeup delays were very close and their average was very close to the reboot time of the Raspberry Pi, which is around 10 s. It can be seen that the wakeup process was very reliable and the wakeup delays were not affected by the shortest distance when it was less than or equal to 320 m. (Note that the range of the WuR is 500 m.) In addition, one can see that the flying speed of the drone did not affect the wakeup delays.

From this figure, one also sees that at the same shortest distance, the average total delays when the flying speed was 26 km/hr were smaller than those when the speed was 13 km/hr. This phenomenon can be explained by in Fig. 18. is the range on the flight route where the IoT device has been waked up but still cannot start transferring its data to the drone via WiFi. The amount of time staying in this range constitutes a large component of the total delay. Since using a higher flying speed can reduce this amount of time, as shown in Fig. 24, the higher the drone’s speed, the smaller the average total delay.


Download : Download high-res image (189KB)
Download : Download full-size image
Fig. 24. The average total delays on routes having different shortest distances.

By comparing Fig. 21, Fig. 24, one can see that the difference between the average wakeup delay and the average total delay at the same shortest distance was about 5 s. This 5-second delay was not solely caused by the data transfer time of the 1-KByte data. Instead, it was caused by: (1) the delay of forming and then joining a WiFi network that operates in the ad-hoc mode, (2) the subsequent TCP 3-way handshake procedure for setting up the TCP connection, (3) the transmission of the 1-KByte data, and (4) the TCP 4-way handshake procedure for tearing down the TCP connection. According to the WiFi standards, when a WiFi node wants to join an ad-hoc mode WiFi network, it needs to detect whether other nodes are sending beacons. Thus, it needs to listen on WiFi channels for detecting a beacon. If no beacons can be received for a certain amount of time, then it needs to send its beacons periodically. In our system, when the drone flies into the WiFi range of an IoT device, the WiFi interfaces on the drone and the IoT device need to go through this beacon-probing process independently. Only after the ad-hoc mode WiFi network has been formed between them and both of them have joined the WiFi network can they start to transmit their data over the WiFi channel.

To see the effect of the number of IoT devices on the WiFi ad-hoc network setup time, we placed ten IoT devices on a desk in our lab as shown in Fig. 25 and measured the average WiFi ad-hoc network setup time. We varied the number of IoT devices participating in an experiment to see its effect. For each experiment, the drone sent WuS packets to all participating IoT devices using the protocol shown in Fig. 8. Because these IoT devices were very close to the drone (less than 1 meter), we found that all of them were successfully waked up in each experiment. To measure the average WiFi ad-hoc network setup time of an experiment, we define the WiFi ad-hoc network setup time for an IoT device as the elapsed time from when the drone sent a WuS packet to it to the time when the drone received a UDP packet from it. The average WiFi ad-hoc network setup time of an experiment is the average of the elapsed time of all participating IoT devices measured on the drone. For each experiment composed of a specific number of IoT devices, we repeated the experiment ten times. Then, the average and standard deviation of the ten runs were calculated and reported in Fig. 26.

To exclude the boot-up time of Raspberry Pi from this time measurement, we let the Raspberry Pi of these IoT devices be always-on. When an IoT device received the WuS packet, it immediately used the “iw” command Anon (0000g) provided by Linux to turn on its WiFi interface and set it to the ad-hoc mode. Then, it immediately sent a UDP packet to the drone. Because sending a UDP packet can exclude the TCP 3-way handshake procedure for setting up a TCP connection and the TCP 4-way handshake procedure for tearing down the TCP connection, the measured elapsed time on the drone was closer to the WiFi ad-hoc network setup time. Note that the WiFi ad-hoc network must be set up first before the UDP packet can be sent out and received by the drone. Thus, the elapsed time between sending out a WuS packet and receiving a UDP packet on the drone must include the WiFi ad-hoc network setup time.

As can be seen from Fig. 26, when the number of IoT devices increased the average WiFi ad-hoc network setup time increased as well. However, the increasing rate was mild and even when the number of IoT devices was increased to ten, the average WiFi ad-hoc network setup time was still less than 1.5 s, which is acceptable for our system. Because the difference between the average wakeup delay and the average total delay at the same shortest distance was about 5 s but the average WiFi ad-hoc network setup time was only 1.5 s, the left unaccounted 3.5 s may be due to the TCP 3-way handshake procedure for setting up the TCP connection and the TCP 4-way handshake procedure for tearing down the TCP connection performed in the dynamic flying conditions. We note that the 1.5 s was measured in the ideal condition where the drone and the IoT device were both placed on the same desk with a very good communication path between them. When the drone flew at a specific speed and at the altitude of 60 m, since the quality of the communication path between the drone and an IoT device will be unstable due to the Rayleigh fading effects, the average WiFi ad-hoc network setup time may be higher than 1.5 s.


Download : Download high-res image (531KB)
Download : Download full-size image
Fig. 25. The ten IoT devices used for the experiments (indoor, placed together on a desk).

5.5. Data transfer throughput
We measured the data transfer throughput from an IoT device to the drone at different horizontal distances between them. Initially, the drone and the IoT device were at the same place. Then, the drone flew up and stayed at the 60 m altitude as in the previous experiments. Then, it flew away from the IoT device and stayed at the places where the horizontal distance between it and the IoT device was 10, 20, 30, …, 500 m, with a spacing of 10 m. At each of these distances, we used iPerf3 (Anon, 0000h) to perform a 30-second data transfer and measured the transfer throughput. We conducted such an experiment three times and the average throughputs of these experiments are shown in Fig. 27.

From Fig. 27, one can see that the maximum throughput was achieved at about 100 m and it could reach 2 Mbit/s. When the distance further increased, due to the poorer and poorer signal quality, the throughput decreased. When the distance was 0 meter, which means that the drone stayed right above the IoT device, the throughput was not the maximum. Instead, the throughput was quite small. This is due to the very low antenna gain between the drone and IoT device in this condition. The dipole antenna is the kind of antenna that is most commonly used in mobile applications due to their widespread radiated pattern (Caputo, 2014). Fig. 28 illustrates the typical radiation pattern for a dipole antenna in three dimensions (, and ). As can be seen, the maximum gains are achieved on the horizontal plane (i.e., when the elevation angle is 0 degree) and the minimum gains are achieved when the elevation angle is 90 or -90 degrees.


Download : Download high-res image (171KB)
Download : Download full-size image
Fig. 27. The average transfer throughput of three experiments at different distances.

Since we mounted the dipole antenna (i.e., the white antenna) vertically on the drone and IoT device as shown in Fig. 12, when the drone was right above the IoT device, the elevation angles for the IoT device and the drone were 90 and -90 degrees, respectively. In this condition, the antenna gain was the lowest and the signal quality was poor. As a result, the throughput at distance 0 meter was very low. On the contrary, when the drone was away from the IoT device with a distance around 100 m, the elevation angle between them produced the best signal quality and thus generated the highest throughput. When the distance further increased, the long distance became the main reason for the low throughput as the signal became weaker and weaker.

We also measured the average signal strength (in dBm) at these distances. On the IoT device we used the “airmon-ng” tool (Anon, 0000i) to put the WiFi network interface into the monitor mode. Then, we executed the tcpdump tool to capture the packets received on the WiFi interface. In each experiment, we let the drone sent 100 ping request packets to the IoT device. The tcpdump tool returned the signal strength of each received ping request packet in dBm. To compute the average signal strength of an experiment at a specific distance, we averaged the signal strength of all received packets in the experiment. For each experiment, we repeated the experiment ten times. Then, the average and standard deviation of the ten runs were calculated and reported in Fig. 29. As can be seen, the measured average signal strength at different distances were consistent with the above explanations. That is, when the distance increased, the average signal strength decreased. Besides, due to the radiation pattern of the used dipole antenna, when the distance gradually approached zero, the average signal strength decreased as well.


Download : Download high-res image (258KB)
Download : Download full-size image
Fig. 28. The radiation pattern of a dipole antenna.

Because the ping command can output the packet loss rate of the ping request packets that it sends out, in the above experiments we also measured the packet loss rate of each experiment, which was the output of the executed ping command. For each experiment, we repeated the experiment ten times. Then, the average and standard deviation of the ten runs were calculated and reported in Fig. 30.


Download : Download high-res image (162KB)
Download : Download full-size image
Fig. 29. The average signal strength at different distances.

5.6. Data transfer size
With the measurement data shown in Fig. 27, we used the model shown in Fig. 18 to calculate the amount of data that an IoT device can transfer to the drone when the drone is flying to collect data. This amount depends on the speed of the drone, the shortest distance from the drone to the IoT device, and the data transfer throughput at different distances. As shown in Fig. 27, because the transfer throughput varies at different distances and the distance varies over time while the drone is flying, we used Algorithm 1 and the measurement data shown in Fig. 27 to calculate the amount of data that can be transferred during the period when the drone and IoT device are within their WiFi range.


Download : Download high-res image (404KB)
Download : Download full-size image
In this algorithm, is the shortest distance between the drone and the IoT device and is the flying speed of the drone. is the transfer throughput measured at the i distance, which is taken from Fig. 27. If is not one of the distances used in the measurement experiments described in Section 5.5, we used the interpolation method to compute . Because the transfer throughput varies at different distances and the distance varies over time when the drone moves, we need to use an integral to accumulate the data transferred in each time interval while the drone and IoT device are still within their WiFi range. For performing the accumulation, we use 0.5 s as the time interval and denote it by . is the moving distance of the drone in a time interval.
Using Fig. 18 to explain, represents the place on the flight route where the WiFi can start to be used and represents the place where the WiFi can no longer be used for the data transfer. Their absolute values represent their distances to the “red” triangle on the route, where the shortest distance occurs. Since we set the coordinate of the triangle on the route to 0, is . To suit the following for loop, we let be positive. In the for loop, is initialized as and gets decremented by in each time interval until its value is less than , which means that the drone has moved out of the WiFi range. With and , is the distance between the drone and the IoT device. is the transfer throughput measured at the d distance and is taken from Fig. 27. is the amount of data that can be transferred at this place and in this time interval. accumulates the amount of data transferred in each time interval and its final value is the amount of data that can be transferred in this data collection round.

The results generated based on this model are shown in Fig. 31, which shows the size of the data transferred when the drone flies at different speeds. Different line styles represent different shortest distances between the drone and the IoT device. As can be seen, the lower the drone’s speed, the longer the time it can stay in the WiFi range, and thus the larger the size of the transferred data. This figure shows the results when the speed of the drone is from 0 km/hr to 60 km/hr. Although using a very low speed for the drone enables an IoT device to transfer more of its data to the drone while they are within the WiFi range, doing so will slow down the whole data collection task for the drone and is not practical.

Thus, we assume that the speed of the drone will be at least 10 km/hr for the data collection task and Fig. 32 zooms into this area to show the details. One can see that when the drone flies at the speed of 10 km/hr, the drone can receive data of 24.4, 21.3, 12.1, and 3.7 MB from an IoT device when the shortest distances between them are 80, 0, 160, and 240 m, respectively. In the worst case, it can still receive data of 3.7 MB, which can be a high-resolution picture, an audio file, or a short video clip. The best results occur when the shortest distance is 80 m. The reason can be explained by the radiation pattern of antenna shown in Section 5.5. In real-life usages, the drone will fly along streets to collect data of nearby IoT devices and the distance between it and these IoT devices will be less than 80 m. In such usages, the size of the data transferred can be up to 20 MB, which can enable novel IoT applications.

5.7. Collecting data from multiple IoT devices deployed on our campus
In addition to evaluating the performance of our system with only one IoT device, we also made a small field trial with nine IoT devices on our campus to see how our system would perform to collect their data. We requested and obtained the permissions from the managers of nine buildings on our campus to mount our IoT devices on the rooftops of these buildings. Fig. 33 shows the place where the IoT device was mounted on the rooftop. As can be seen, it was mounted on the concrete wall, which is about 1 meter high, on the rooftop. Because of this wall, if the drone and the IoT device were on different sides of the wall, this wall might block the line-of-sight communication path between the drone and the IoT device. On the other hand, if the drone and the IoT device were on the same side of the wall, the drone and the IoT device might have a line-of-sight communication path between them, if the path was not blocked by other high buildings nearby. Fig. 33 shows that even when the IoT device was in the wakeup range of the drone, it might not be waked up by the drone due to the line-of-sight blockage problem. Because the spatial and temporal dynamic characteristics of wireless communication further worsened the problem, we took a dynamic approach to collect the data of these IoT devices.

Fig. 34(a) shows the locations of these IoT devices and the flying path traveled by the drone to collect their data. The map legend is shown in Fig. 34(b). We adopted the dynamic clustering algorithm proposed in Chia-An et al. (2020) to collect the data. The algorithm can produce a set of clusters (discs) with a specified radius that together cover all nodes on a map. In our usage, we let the IoT devices whose data had not been collected as the input to this algorithm. Based on Fig. 27, we set the radius to 250 m as the data transfer throughput will be very low when the distance is larger than 250 m.


Download : Download high-res image (403KB)
Download : Download full-size image
Fig. 33. The place where the IoT device was mounted on the rooftop.

At the beginning of this experiment, we used this algorithm to generate a set of clusters. Then, we controlled the drone to let it fly to the center of the cluster that was closest to its current position. Then, the drone sent out WuS packets to wake up the IoT devices within its wakeup range. We let the drone stay at its current wakeup position for 30 s to receive the data of these IoT devices. However, some IoT devices in the current wakeup range might not be waked up successfully due to the wireless communication problems presented above. If the drone did not receive any data from an IoT device within 30 s, then waking up the IoT device was considered unsuccessful. Such IoT devices and the other IoT devices whose data had not been collected were taken together as input to the clustering algorithm to produce the new set of clusters for the next step. Then, we controlled the drone to let it fly to the center of the cluster that was closest to its current position. The above process was repeated until the drone had collected data from all of the nine IoT devices.

During the field trial, we used a notebook computer near the drone operator to run a program, which executed the clustering algorithm. Because the locations of these IoT devices were fixed, their locations were pre-input to the program. This program used Google map API to display these IoT devices on the map and each IoT devices had a corresponding checkbox on the screen. When the data of an IoT device had been collected by the drone, the drone immediately sent a message to the notebook computer via the LTE network to notify it of this event. When seeing this message on the screen of the notebook computer, the drone operator clicked on the checkbox of this IoT device to indicate to this program that this IoT device should be removed from its processing list. When the current 30-second wakeup period ended, the drone operator clicked an execution button on the screen to trigger the clustering algorithm again. The output of the program then showed the remaining IoT devices, the circles (representing the clusters) covering these IoT devices, and the center of these circles, and the current drone location on the map. Based on the information shown on the map, the drone operator then flew the drone to the center of the closest cluster to perform the above data collection procedure.

Note that the drone used in this work does not have the auto-pilot capability. Thus, in the above operations the drone operator needed to manually fly the drone to the center of the closest cluster. If a drone has the auto-pilot capability and the auto-pilot function is allowed in an area, the above data collection process in that area can be automatic without human intervention.

In this small field trial, the drone sent WuS packets at five different positions and the total distance of its flying path was 864 m. The flying speed of the drone was set to 26 km/hr. The purpose of this small field trial was to illustrate a possible data collection method for our system. More efficient and elaborate methods are possible and will be evaluated as our future work.

6. Discussion
The main contributions of this work are the technical design, implementation, and performance evaluation of our system when deployed on our campus. As for non-technical issues such as the regulations about the uses of drone and the cost/benefit of the drone approach compared to those of the traditional data collection method, we discuss them below.

6.1. Regulations about the uses of drones
Although drones have been continuously used in various research fields in recent years, due to safety and privacy concerns, several areas have made legal regulations for the uses of drones. In Table 2, we summarize the drone-related regulations in the United States, European Union, and Taiwan.

Generally, the flying altitude limitation is under 120 m except for special-purpose applications, and no-fly zones (NFZ) are set around airports or other important facilities such as gas processing plants. Drone operators are not allowed to use alcohol or drugs and should fly the drone within the visual line-of-sight distance. In the United States (Anon, 0000j), there are two types of drones — recreational and commercial. Both of them need registrations. To fly commercial drones, one must have a Remote Pilot Certificate issued by the FAA (Anon, 0000m). In European Union (Anon, 0000k), drones are classified into three categories — open, specific, and certified. Only operating in the open category need not require a prior authorization or a pilot license.


Table 2. Regulations about the uses of drone in the United States, European Union, and Taiwan.

United States Anon (0000j)	European Union Anon (0000k)	Taiwan Anon (0000l)
Altitude limitation	120 m	120 m	120 m
Distance to operator	line-of-sight	line-of-sight	line-of-sight
Categories	Recreational (under 30 kg) Commercial (over 30 kg)	Open (under 900 g) Specific (0.9 4 kg) Certified (4 25 kg)	Lightweight (under 2 kg) General (2 15 kg) Profession (over 15 kg)
Authorization needed	Recreational ✓
Commercial ✓	Specific ✓
Certified ✓	General ✓
Profession ✓
License needed	Commercial ✓	Specific ✓
Certified ✓	General (subject)✓
Profession (technique) ✓
In Taiwan (Anon, 0000l), drones are classified based on their weights. To fly drones over 2 kg, the operator must take a subject test and register the drone. To fly drones over 15 kg, the operator needs to additionally obtain a drone technical pilot license. The drone that we used in this work is only 907g, so it is unnecessary for us to obtain a pilot license to fly this drone. Besides, in Taiwan the altitude limitation of drone varies across three different areas — the no-fly zone (NFZ), restricted area (under 60 m), and allowed area (under 120 m). Because the experiments conducted in this work were all carried out on our campus (which is among the allowed areas) and the altitude of the drone was fixed at 60 m, all conducted experiments complied with the legal regulations in Taiwan.

6.2. Cost–benefit analysis of the drone approach with the traditional method
The hardware cost of our approach has two parts. The first part is the drone and the second part is the IoT devices. The drone that we used in this work is DJI Mavic Air 2 (Anon, 0000n), which costs about 800 USD. To implement an IoT device in our system, we used a Raspberry Pi, which is about 35 USD, a wake-up radio module — RFM69, which is 12.95 USD, a relay module, which is 11 USD, and a WiFi radio module, which is 12.5 USD, respectively. The resistors, capacitors, and voltage regulators used in our design cost about 10 USD. Thus, the total cost of an IoT device in our system is 84.45 USD. Note that the IoT device implemented in this work is just a prototype of smart meters demonstrating the feasibility of our approach. If smart meters are widely adopted in the future and utility companies are willing to manufacture them, due to their huge number, the cost of an IoT device used in our system can be greatly reduced.

As for the cost of the qualified drone human operator, as explained previously, since the drone used in our system is only 907g, it is unnecessary to obtain a pilot license to fly this drone. Thus, the meter reader can operate the drone to collect data from meters.

To demonstrate the benefits of using a drone to collect data from multiple smart meters, we use Fig. 35, Fig. 34 to make a simple comparison. As shown in Fig. 34(a), the drone flew 864 m to collect the data of the nine IoT devices. In contrast, as shown in Fig. 35 the meter reader would need to walk 1.38 km to record the data of each of the nine meters. Because the speed of the drone was 26 km/h = 7.22 m/s, the number of staying at a wakeup position was 5, and the time spent at each wakeup position was 30 s, the total time needed to collect the data of all of the nine IoT devices was 267 s. In contrast, in the traditional method the number of recording data in front of the meter is 9. We assumed that the walking speed of the meter reader is the normal 4 km/hr, which is 1.11 m/s, and the time needed for the meter reader to record the data of a meter is 10 s, then the total time needed to record the data of all of the nine meters would be 1333 s. Dividing 1333 by 267 yields 4.99, which indicates a speedup of almost 5.

The above cost–benefit analysis of our approach and the traditional method is very preliminary and the derived speedup is only for this particular small field trial. We leave more advanced analyses as future work.

7. Conclusion
In this paper, we design and implement a real system to collect data from smart meters. A smart meter can be a gas, water, electricity, parking, etc. meter that is implemented by an IoT device. Our system uses the WuR technology and drone technology to reduce the energy consumption of IoT devices. We designed our own circuit and used a real WuR to implement such an IoT device. According to our real-life measurements, compared with the always-on scheme, such an IoT device can reduce its energy consumption by a factor of 180 when the data collection cycle is more than 10 days. Even if the data collection cycle is shortened to only 1 day, the energy consumption can still be reduced by a factor of 145.

Using this system, we measured the wakeup and data transfer success probability, wakeup delay and total delay, data transfer throughput, and data transfer size under different important system parameters such as the shortest distance between the drone and an IoT device and the flying speed of the drone. These experimental results show that if the shortest distance between the drone and an IoT device is less than or equal to 80 m, the wakeup and data transfer success probability can be 100%, the total delay (which includes the wakeup delay and the 1-KByte data transfer delay) is less than 20 s, the data transfer throughput can be up to 2 Mbit/s, and up to 20 MB of data can be transferred from the IoT device to the drone when they are still within their WiFi range.

We also have used and deployed nine such IoT devices on our campus to test how the drone in our system would fly to collect their data. Experimental results show that the drone in our system worked successfully to wake up and collect the data of these IoT devices. Based on these real-life measurement results, we are developing a simulator and will use it to study the performance of our system when it collects data from thousands of IoT devices.

8. Future work
Although the hardware and software co-designs of our system have been successfully implemented and our system can reduce energy consumption by a factor of 180 when the data collection cycle is more than 10 days, there are still many places that can to be improved. In the following, we discuss several issues and leave them as our future work.

The first issue is the current method of using unicast WuS packets. When sending unicast WuS packets to many IoT devices, we need to send them one bye one. If there are many IoT devices, the wakeup delay may be increased. In our design, after the drone wakes up a specific IoT device, it does not need to wait for receiving an ACK packet from the IoT device to confirm that the IoT device has been waked up. Instead, the drone can still continue to wake up other IoT devices. Therefore, our system can use multicast/broadcast WuS packets to wake up many IoT devices simultaneously and use a collision-free algorithm for their ACK packets. To prevent an IoT device from being waked up again and again due to receiving many multicast/broadcast WuS packets, we may modify our circuit design and use some hardware to overcome this problem. For example, we may add a hardware timer to the WuR so that it will ignore future incoming WuS packets in a specified time period. But this timer needs to be powered on to count down during this period and thus will unnecessarily consume energy, conflicting with the goal of our system to reduce energy consumption. Currently, several geofencing techniques could be used to limit the packet transmission in the proposed architecture and we are considering to use them in our future system.

The second issue is about the drone energy consumption, which limits the flying time of the drone. For the drone (Anon, 0000n) used in this work, its battery can allow it to fly only 34 min. Thus, if a data collection process needs to take more than 34 min, the drone operator will need to replace the battery of the drone roughly every half an hour.

In this work, we have used and deployed nine IoT devices on our campus to see how our system would perform to collect their data. As shown in our experimental results, our system worked successfully to collect all of their data. However, to study the performance of our system when the number of IoT devices further grows up to thousands, which is more similar to the real-life smart meter data collection scenarios, due to the prohibitively expensive hardware costs, we will have to resort to simulations to perform such studies.

After our system can be faithfully simulated by a simulator to study how it will work with thousands of IoT devices, many interesting research problems can be studied with this simulator. For example, based on the locations of these IoT devices, what are the best flight routes for the drone to collect their data. Since the wakeup and data transfer success probability will not be always 100% in the real life, which will be affected by the speed of the drone, the shortest distance between the drone and the IoT devices, and the environments surrounding the IoT devices, how to design a multi-round and multi-route scheme for the drone to successfully collect data from all IoT devices is important. These topics are important for the real-life usages of a drone wakeup and data collection system and are our future works.

