Authentication of restricted memory devices presents significant problems since memory consumption is high in mutual authentication using cryptographic protocols in IoT environments. According to previous studies, the development of a multi-factor mutual authentication method that can be used in fog and cloud computing remains a challenge. The present work aims to improve a method of mutual authentication with multi-factor using an adjustable variable response time, challenge-response function, and nonce. With these factors, the same method can be regulated for both the Fog and Cloud Computing contexts. We compared the present method with the evaluations carried out in related works, achieving a satisfactory result regarding the cost of computing and communication. The code developed in Java showed a better average processing time, low energy consumption than other studies, and a linear complexity metric. Finally, using the Proverif tool and an informal analysis to provide the security assessment, it was demonstrated that it is impossible to derive the discovery of keys, keeping the proposed method safe.

Keywords
Mutual authentication
Multi-factor
Internet of things
Fog
Cloud

1. Introduction
The evolution of the equipment, connected to the Internet, allows the interaction and data transfer between objects used in everyday life and a network. Each object has its characteristics and, even with a small size, can send and receive data between the real world and the Internet, thus forming an IoT (Internet of Things) network.

An IoT network's main characteristic is to have equipment that characterizes a ubiquitous network of sensors and actuators communicating (Xia et al., 2012; Patel Patelet al., 2016). The hardware limitation is another feature that restricts IoT equipment, which implements robust security mechanisms challenging.

The research on IoT security presented by Hassan et al. (Hassanet al., 2019) shows the following trends in IoT authentication methods, according to the literature, from 2016 to 2018: lightweight authentication (approximately 55%), mutual authentication (approximately 27%), and, use of multiple factors (approximately 18%).

Mutual authentication that uses multi-factors in authentication is scarce in environments that deal with IoT, fog, and cloud. In our related works section, Table 1 shows that from 24 works, only six works use multi-factor authentication mechanisms: Aghili et al. (2019), Ayub et al. (2020), Kiran, Pasupuleti and Eswari (Kiran et al., 2019), Loffi et al. (2019), Rao, Santhi and Hussain (Rao et al., 2019) and Sharma and Kalra (2018). Only the work of Loffi et al. (2019), and Kiran, Pasupuleti, and Eswari (Kiran et al., 2019) deals with mutual authentication while the other four have only unidirectional authentication by default.


Table 1. Resulting related works.

Work	REF	Auth	Key	Security	Factors	Context
Aghili et al. (2019)	Aghili et al. (2019)	Simple	XOR	Proverif	Multi-factor (3)	–
Alshahrani and Traore (2019)	Alshahrani and Traore (2019)	Mutual	XOR	BAN Logic/AVISPA	Challenge-Response	–
Ayub et al. (2020)	Ayub et al. (2020)	Simple	ECC	ROM	Multi-factor (3)	Cloud
Dey et al. (2018)	Dey et al. (2018)	Mutual	RSA	Theoretical	–	Cloud
Erroutbi et al. (2019)	Erroutbi et al. (2019)	Mutual	XOR	Theoretical	–	Fog
Fan et al. (2020)	Fan et al. (2020)	Mutual	XOR	BAN Logic	Smart Card	Cloud
Gope and Das (2017)	Gope and Das (2017)	Mutual	XOR	Theoretical	–	Cloud
Gupta and Quamara (2018)	Gupta and Quamara (2018)	Mutual	RSA	AVISPA	Smart Card	Cloud
Hassan et al. (2019)	Hassan et al. (2019)	Mutual	XOR	Proverif	–	Cloud
Imine et al. (2018)	Imine et al. (2018)	Mutual	RSA	Theoretical	–	Fog
Kalra and Sood (2015)	Kalra and Sood (2015)	Mutual	ECC	AVISPA	–	Cloud
Khan and Aggarwal (2019)	Khan and Aggarwal (2019)	Mutual	ECC	Theoretical	–	Cloud
Kiran et al. (2019)	Kiran et al. (2019)	Mutual	ECC	Theoretical	Multi-factor (2)	Cloud
Loffi et al. (2019)	Loffi et al. (2019)	Mutual	RSA	AVISPA	Multi-factor (3)	Fog
Rao et al. (2019)	Rao et al. (2019)	Simple	–	Theoretical	Multi-factor (2)	–
Salem (2018)	Salem (2018)	Mutual	ECC	Theoretical	–	Fog
Sethia et al. (2018)	Sethia et al. (2018)	Mutual	XOR	AVISPA	–	Cloud
Shah and Venkatesan (2018)	Shah and Venkatesan (2018)	Mutual	XOR	Theoretical	–	Cloud
Sharma and Kalra (2018)	Sharma and Kalra (2018)	Simple	XOR	AVISPA	Multi-factor (3)	Cloud
Tewari and Gupta (2018)	Tewari and Gupta (2018)	Mutual	ECC	Theoretical	Smart Card	–
Wang et al. (2018)	Wang et al. (2018)	Mutual	ECC	Proverif	Smart Card	Edge/Cloud
Wazid et al. (2019)	Wazid et al. (2019)	Mutual	ECC	AVISPA	–	Fog/Cloud
Wu et al. (2017)	Wu et al. (2017)	Mutual	XOR	Proverif	–	Cloud
Zhou et al. (2019)	Zhou et al. (2019)	Mutual	XOR	Proverif	–	Cloud
Our work (2020)	this	Mutual	RSA/
ECC	Proverif	Multi-factor (3)	Fog/Cloud
The multi-factor authentication proposal developed in this work aims at using the following three factors in an IoT-Fog-Cloud environment: the variable adjustable response time, a challenge-response function, and a nonce constructed with identities in mind. In IoT environments, the delay of response time in interactions between the parties represents a challenge and a new aspect, as it can be adjusted to provide a flexible authentication method and aid in detecting attacks such as man-in-the-middle. The choice of different challenge-response functions is also useful because they can be tuned according to the type of hardware available. The construction and use of nonces that connect the parties’ identities in their design can prevent impersonation attacks.

1.1. Motivation
The literature describes research problems and opportunities in the studies of the authors Alshahrani and Traore (2019), Ayub et al. (2020), Imine et al. (2018), Salem (2018), and Zhou et al. (2019). Among the research opportunities cited are: implementation of handshake using elliptic curves, and verification of the complexity of the proposed algorithm (Ayub et al., 2020; Imine et al., 2018); application of elliptical curves with verification of energy consumption and authentication time (Alshahrani and Traore, 2019; Salem, 2018); and the need to use a formal security verification tool, representing the complexity of the algorithm (Imine et al., 2018; Zhou et al., 2019).

To achieve light and efficient authentication, it is essential to evaluate the cryptographic mechanisms, strategies used in authentication, and the energy consumption involved (Aghili et al., 2019; Rao et al., 2019; Sharma and Kalra, 2018; Alshahrani and Traore, 2019; Shah and Venkatesan, 2018). The evaluation of energy consumption can assist in the implementation of the authentication method in devices with restricted power capacities, to increase the durability of batteries or to reduce electrical consumption.

We used the method described in Loffi et al. (2019). Only two articles deal with mutual authentication of multiple factors, that of the author Kiran, Pasupuleti and Eswari (Kiran et al., 2019) and Loffi et al. (2019) according to our review in Section 3. As the goal of the work is to perform the maximum automatic authentications and maintain the security level, Loffi et al. (2019) supports the present work, as it presents three types of automatic authentications (nonce, timestamp, and challenge-response). In our previous study, described in Loffi et al. (2019), a strategy of mutual authentication with integrity was proposed, using existing cryptographic methods for devices with memory restriction in the context of IoT in fog environments with an algorithm developed in C++.

In this work, our main research concerns are:

1.
to propose a flexible multi-factor authentication method for the IoT-Fog-Cloud environment;

2.
to propose adjustable factors of authentication to adapt the protocol to the environment where it will be used;

3.
to define a cipher string with a choice between using elliptic curve cryptography (ECC) or RSA;

4.
to specify the multi-factor mutual authentication method in Java language algorithm;

5.
to measure the complexity of the algorithm, the estimated execution time, computational and communication cost of the proposed architecture;

6.
to compare the estimated runtime based on computational cost with real runtime with the Java algorithm;

7.
to perform security proofs to guarantee the security characteristics of the protocol;

8.
to measure energy consumption of the developed proposal.

1.2. Contributions of the work
The contributions of this paper are manifold and are here described:

●
This paper proposes a mutual and multi-factor authentication method in the IoT-Fog-Cloud environment. This proposal's new features are the use of the following three factors, mutually: adjustable variable response time (named tolerance time rate), challenge-response function, and nonce constructed with identities in mind. This tolerance time rate can be adjusted to wait for the complete authentication process to be carried out correctly, avoiding man-in-the-middle and impersonation attacks. It also allows using the same authentication method to be regulated for the Fog Computing and Cloud Computing contexts. The challenge-response function can be defined according to the context needs and continuously verify the authenticity of the method exchanges. The nonce ties the parameters of time, source, and target identification to prevent impersonation attacks since it is always used in the protocol interactions.

●
The implementations were developed in Java and, different from our previous work defined in Loffi et al. (2019) using C++, in this work, the protocol implemented the adjustable tolerance time rate (ttr) to avoid both man-in-the-middle and impersonation attacks. This implementation adds elliptic curve cryptography as a cipher option. According to the threat model presented in Section 4.3, if the opponent cannot modify the messages in less time than ttr, the messages will be discarded because it will be considered a man-in-the-middle attack.

●
A threat model is presented in Section 4.3. Section 6.1 analyzes security informally. The formal security evaluations are described using the ProVerif tool (Section 6.2). The ProVerif security evaluation showed that the attacker could not observe the protocol messages to derive or discover the secret key obtained at the end of the authentication protocol.

●
Satisfactory results were obtained regarding the execution times of the Java code in the implementation of the protocol. Comparing runtime execution times of client, fog, and cloud nodes, when they interact using the authentication protocol, the outcomes showed that the cipher string ECDHE_ECDSA_AES128-CBC_SHA512 is executed faster than using the cipher string DHE_RSA_AES128-CBC_SHA512 (Section 6.6 details all the performance results obtained).

●
Analyzing the entire specification of the algorithm in Java, it can be concluded that it is O(n) (described in Section 6.3). Furthermore, using Google's cloud, it can be seen that the communication cost for each authentication cycle is 1280 bits for ECC and 1400 bits for RSA.

●
The works of Ayub et al. (2020), Kalra and Sood (2015), Kiran, Pasupuleti and Eswari (Kiran et al., 2019) and Wazid et al. (2019) also show performance times of their authentication proposals. Although, these metrics are described in terms of variable execution times of hash function (named Th), asymmetric encryption times (named Te, Tecm) and symmetric encryption times (named Ts). The work of Ayub et al. (2020) achieved 10Th + 3Tecm; Kalra and Sood (2015) achieved 10Th + 9Tecm; Kiran, Pasupuleti and Eswari (Kiran et al., 2019) achieved 7Th + 2Te; and Wazid et al. (2019) achieved 9Th + 4Tecm. Our work achieved the performance result of 7Th + 7Te + 1Ts.

●
There is an analysis of energy consumption, as also developed in other works of the literature such as Zhou et al. (2019), and Shah and Venkatesan (2018). The measurement of energy consumption is a challenging task in IoT environments, and few works describe this metric. In our work, the average energy consumption of 4792.29 mJ per cycle of code execution using the cipher string DHE_RSA_AES128-CBC_SHA512 and the average consumption of 191.62 mJ per cycle of code execution using the cipher string ECDHE_ECDSA_AES128-CBC_SHA512 (Section 6.7 details the energy consumption results obtained).

1.3. Paper organization
In Fig. 1, an organization of the next sections is presented. It briefly presents the results obtained in each section. Section 2 presents the basic concepts in the research topic. Section 3 describes the related works to this proposal. Section 4 describes the mutual authentication with the multi-factor method. Section 5 proposes the implementation of the mutual authentication method, together with the specifications of the algorithm in Java. Section 6 presents the evaluation of the protocol by verifying the security characteristics, the complexity of the algorithm, the computation and communication cost, performance at runtime, and energy consumption. Lastly, in Section 7, final considerations are presented, putting forward the contributions, limitations, and the proposal for future analysis.

Fig. 1
Download : Download high-res image (1MB)
Download : Download full-size image
Fig. 1. Organization of article results.

2. Basic concepts
This section describes the main concepts necessary to understand this work.

Internet of Things: Atzori, Iera, and Morabito (Atzori et al., 2010) define IoT as a variety of interconnected objects and things, for example, garage lights that turn on when the presence sensor detects a car. The Internet of Things can be applied to different contexts, which are defined through services and infrastructure that will be used, such as machine to machine (M2M) and in Industry (Wang et al., 2019; Esfahani et al., 2017; Voas, 2016). Always taking the context into account, the IoT devices are used to collect, actuat, process and retransmit data through a communication channel (Voas, 2016; Wurm et al., 2016). Three general contexts can be used for IoT applications – Cloud Computing, Fog Computing, and Edge Computing – the difference among them exclusively concerning the application context (Mahmud et al., 2018).

Cloud Computing: Mell and Grance (Mell Granceet al., 2011) from the National Institute of Standards and Technology (NIST) define cloud computing as a model that enables ubiquitous, convenient and on-demand access, over a network, to a centralized and shared set of configurable computational resources that can be provisioned and released quickly, through management or interaction with the service provider. It is evident through Fig. 2 how Cloud Computing can be used in IoT. In the context of Cloud Computing, there is no intermediate processing layer, thus processing takes place in the cloud (Wang et al., 2019).

Fig. 2
Download : Download high-res image (498KB)
Download : Download full-size image
Fig. 2. Context vs. Location.

Fog Computing: The organization NIST defines fog computing as an omnipresent network access layer model, which offers a continuous sharing of scalable computing resources through the use of distributed networks and low latency in communication between the end-user of the edge and the intermediate location (Iorga et al., 2018). As seen in Fig. 2, Fog Computing can be used in the IoT, considering it has an intermediate layer of data processing before sending it to the Cloud.

Edge Computing: This refers to a network layer that links the end devices to its users and which aims to provide local computing capacity for a sensor, actuator, or another device on the local network (Iorga et al., 2018) (Satyanarayanan, 2017). Fig. 2 illustrates how Edge Computing can be used in IoT, noting that it does not have an intermediate layer or a cloud processing layer.

Each paradigm applied to IoT has its advantages and disadvantages. Cloud computing has higher storage and processing capacity; however, it can have significant latency when sending all data collected from a network to the cloud. To solve this problem, fog computing is used because it is located close to the sensor devices and can process or summarize the data. Edge computing is located near or closer to each sensor for high-speed data processing, featuring real-time processing along with the sensor and actuator for quick decision making. Fog computing moves the edge computing activities to processors that are connected to the LAN or intermediate layer, which are physically more distant from the sensors and actuators.

Handshake: This can be considered a negotiation process between two or more devices to recognize each other and be ready to start an exchange of data (Schneier, 2007). This process is used in communication protocols like TLS (Transport Layer Security) and TCP (Transmission Control Protocol).

Mutual Authentication: Authentication describes the process of verifying whether the identity or attribute value of an entity or system resource is true (Mohammed and Elsadig, 2013) (Shirey, 2007). In mutual authentication, also known as bidirectional or two-way authentication, verification is done by both parties of the communication, usually referred to as the client and server (Kothmayr et al., 2013) (Otway and Rees, 1987).

Multiple Authentication Factors: The factors are the methods used for authentication. Several factors can be used to perform authentication: knowledge of something (e.g., the password), possession of something (e.g., a physical card), biometric characteristic (e.g., a person's fingerprint), context (e.g., the IP (Internet Protocol) address of the entity or the location where the entity is located) and challenge with a correct answer (Stallings, 2014; Aman and Sikdar, 2018).

Multi-factor authentication is based on two or more authentication factors. Therefore, the factors are directly linked to authentication methods. Accordingly, one method of user authentication factors involves creating functions or mechanisms which can be used during the handshake without any need for user input. A clear demonstration of this can be seen in the generation of a challenge-response, which Backes et al. (2007) presents as an abstraction for the end-user. In the challenge-response, it is also possible to acquire information, such as obtaining the processing speed of the other system through the complexity of the calculation requested as a challenge.

3. Related works
This section describes related works in literature, citing their characteristics and contributions in the area of authentication. To obtain an overview of state of the art in multi-factor mutual authentication, we performed a systematic mapping of literature.

Three different electronic databases were defined, where the articles were searched: ACM, IEEE, and ScienceDirect. To form the Search String, five keywords were used, resulting in the following: “Mutual Authentication” AND (“Internet of Things” OR “IoT”) AND (“Fog” OR “Cloud”).

Regarding the inclusion and exclusion process of the articles. The databases were searched using the previously presented string in Stage 1, on July 10, 2020. Then, in Stage 2, articles that were not articles published in conferences or journals were excluded. In Stage 3, articles published before 2015 were excluded. In Stage 4, based on title and keywords, articles were excluded. In Stage 5, the Abstract was read, excluding articles not linked to this research. Similarly, in Stage 6, the Introduction and Conclusion were read, and the exclusion was performed. Finally, in Stage 7, the complete reading was performed, and non-relevant articles were excluded, and there was no similarity with the present study.

Table 1 presents a comparison among the works considering the following requirements: dealing with authentication (Auth column); cryptographic algorithm for key exchange (Key column); presenting the proposed security analysis (Security column); number of factors used in authentication (Factors); and, the context of application in IoT (Context).

As can be seen in Table 1, of the 24 articles resulting from the systematic review, 20 articles ((Alshahrani and Traore, 2019), (Dey et al., 2018), (Erroutbi et al., 2019), (Fan et al., 2020), (Gope and Das, 2017), (Gupta and Quamara, 2018), (Hassan et al., 2019), (Imine et al., 2018), (Kalra and Sood, 2015), (Khan and Aggarwal, 2019), (Kiran et al., 2019), (Loffi et al., 2019), (Salem, 2018), (Sethia et al., 2018), (Shah and Venkatesan, 2018), (Tewari and Gupta, 2018), (Wang et al., 2018), (Wazid et al., 2019), (Wu et al., 2017), (Zhou et al., 2019)) presented a method of mutual authentication. From these articles, the authors Erroutbi, El Hanjri, and Sekkaki ((Erroutbi et al., 2019)), Imine et al. (2018)), Loffi et al. (2019)) and Salem (2018) presented a method of mutual authentication using the IoT environments in the context of fog computing. In addition, some works ((Dey et al., 2018), (Fan et al., 2020), (Gope and Das, 2017), (Gupta and Quamara, 2018), (Hassan et al., 2019), (Kalra and Sood, 2015), (Khan and Aggarwal, 2019), (Kiran et al., 2019), (Sethia et al., 2018), (Shah and Venkatesan, 2018), (Wang et al., 2018), (Wu et al., 2017), (Zhou et al., 2019)) use the mutual authentication with Cloud computing context. The authors Wazid et al. (2019)) presented the method using Cloud Computing and Fog Computing for mutual authentication.

It can also be seen in the “Factors” column of Table 1 that six articles ((Aghili et al., 2019), (Ayub et al., 2020), (Kiran et al., 2019), (Loffi et al., 2019), (Rao et al., 2019), (Sharma and Kalra, 2018)) use the multi-factor. The authors Kiran, Pasupuleti, and Eswari (Kiran et al., 2019) and Rao, Santhi, and Hussain (Rao et al., 2019) proposed a two-factor authentication protocol and the Aghili et al. (2019), Ayub et al. (2020), Loffi et al. (2019), Sharma and Kalra (2018) proposed a three-factor authentication protocol for IoT architecture, but using the simple authentication. These protocols were lightweight and optimized for devices with limited processing capacity. The Theoretical proof was also presented in the works of Kiran, Pasupuleti, and Eswari (Kiran et al., 2019), and Rao, Santhi, and Hussain (Rao et al., 2019). Loffi et al. (2019) and Sharma, and Kalra (Sharma and Kalra, 2018) presented formal proof using AVISPA tool. On the other hand, Aghili et al. (2019) used the Proverif tool, and Ayub et al. (2020) used the Random Oracle Model (ROM) tool. Additionally, some articles ((Alshahrani and Traore, 2019), (Fan et al., 2020)) used the Burrows-Abadi-Needham (BAN) logic, which is a set of rules for defining and analyzing information exchange protocols. Rao, Santhi, and Hussain (Rao et al., 2019) presented a method on authenticated message, using any predefined keys.

The other options that are presented in the Factors column are authentication factors, namely: the “challenge-response” present in the article of Alshahrani and Traore (Alshahrani et al., 2019) that uses mathematical challenges and received the response of challenges; and “Smart card” present in the works of Fan et al. (2020), Gupta and Quamara (2018), Tewari and Gupta (2018), and Wang et al. (2018).

As can be seen in Key column in Table 1, there are 13 papers ((Aghili et al., 2019), (Alshahrani and Traore, 2019), (Erroutbi et al., 2019), (Fan et al., 2020), (Gope and Das, 2017), (Hassan et al., 2019), (Kalra and Sood, 2015), (Sethia et al., 2018), (Shah and Venkatesan, 2018), (Sharma and Kalra, 2018), (Wu et al., 2017), (Zhou et al., 2019)) that present the use of or-exclusive techniques (XOR) as an authentication methodology. Thus, these works do not use key exchange, and when using a key, they take into account the definition prior to authentication. The other options that are presented in the Key column is “ECC” and “RSA”. For the “RSA” option, there are the articles of ((Dey et al., 2018), (Gupta and Quamara, 2018), (Imine et al., 2018), (Loffi et al., 2019)) that use Rivest-Shamir-Adleman (RSA) as a basis for key exchange, those that use the digital certificate or only the RSA key generated in the methods. For the “ECC” option, the articles ((Ayub et al., 2020), (Kalra and Sood, 2015), (Khan and Aggarwal, 2019), (Kiran et al., 2019), (Salem, 2018), (Tewari and Gupta, 2018), (Wang et al., 2018), (Wazid et al., 2019)) are based on the Elliptic-Curve Cryptography (ECC); they are the ones that use elliptical curves to perform the exchange of keys among the parties.

Considering the six articles that presented the use of multi-factors, the authors Aghili et al. (2019) and Ayub et al. (2020) presented the authentication factors with the smart card, password, and biometrics. Kiran, Pasupuleti, and Eswari (Kiran et al., 2019) presented the authentication factors using biometrics and password. On the other hand, Sharma and Kalra (2018), Rao, Santhi, and Hussain (Rao et al., 2019) and Loffi et al. (2019) presented the authentication factors that use automatic factor verification: Sharma and Kalra (2018) use the timestamps, Rao, Santhi, and Hussain (Rao et al., 2019) use the nonce value and Loffi et al. (2019) use the nonce value, timestamps, and challenge-response. In this way, multi-factor is automatically provided.

We describe in more detail the work of Loffi et al. (2019) because it is our previous work. The authors Loffi et al. (2019) described a solution for security in the connection of the sensor node and gateway node considering low processing and storage devices in the fog computing using UDP as standard. This work presented a significant contribution, which was developing an optimized mutual authentication model, using strategies of identification factors in the nodes, and adding a new authentication method in a real IoT environment in the context of fog computing. The authors used cryptographic techniques such as RSA, AES, and SHA-512 to develop a handshake between the parties. However, the main point addressed in the study was the authentication factors: the challenge-response function, response time, and nonce. The article verified the security of the proposed protocol with the AVISPA tool. Also, memory consumption and transmission times spent on the practical execution of the protocol were evaluated. Many improvements could be foreseen in the study, which inspires our current work: inclusion of the adjustable tolerance time ratio in the response time so that the same method can be used for the Fog Computing and Cloud Computing contexts dynamically, besides of preventing attacks such as man-in-the-middle and impersonation; description of computation costs of the proposed authentication method; formal evaluation with the Proverif tool; the improvement of the dual authentication option using RSA key or elliptical curves; and, an assessment of energy consumption during the protocol execution stages.

4. Mutual authentication with multi-factor method
The “Connection” phase involves the use of the connect method on the client and the wait_connect method on the server. The “Disconnection” phase involves the use of both client and server disconnect methods. These connection and disconnection operations are mandatory at least once to be able to use the options in the “Publisher” and “Subscriber” phases. In “Publisher”, the client uses the publish method and the server uses the listen method, respectively, for sending and receiving data. For the “Subscriber” option, the client uses the request method, and the server uses the publish_server method, respectively, for ordering and sending data. To verify the connection, there is the “Verification” phase, which uses the isConnected methods from both the client and the server.

According to Fig. 4, after the connection request is returned in the “Connection” phase, the customer initiates the Handshake method. For the Handshake method, we created the multi-factor mutual authentication model. Thus, the following handshake model is presented.

4.1. Handshake model
In general, the proposed solution has similar characteristics to the TLS (Transport Layer Security) protocol handshake, but with some peculiarities regarding its mutual authentication and its multi-factor authentication. Initially, the model can be divided into two processes: Handshake and Multi-Factor Authentication.

The Handshake Process takes place in three stages, and simultaneously: Identification of Parties, Asymmetric Key Exchange, and Symmetric Key Agreement.

The Multi-Factor Authentication Process takes place in three stages, and the three factors are analyzed during the handshake to occur the mutual authentication: Challenge-response Function, Response Time, and Nonce.

4.1.1. The handshake process
The Handshake Process takes place through the exchange of messages between the parties, to identify the parties, exchange keys, and session key agreement. Table 2 shows the notations used to explain the operation of each step of the handshake process.


Table 2. Notations.

Notation	Description
Syn	Initial synchronization request for authentication
Ack	Acknowledgment message
nx	Nonce of Part X (Client or Server)
tpx	Time spent calculating and building the package - processing time
Public key of part X
Private key of part X
Signature of parameters using the private key of Part X
Encryption of parameters using the public key of Part X
Fdrx	Challenge-response function of part X
Response of the challenge-response function of X applied to the value of the public key sent from Part X
DHx	Value resulting from the calculation of the Diffie-Hellman of Part X
g	Diffie-Hellman calculation base value
p	Diffie-Hellman module value
iv	Initialization vector of AES
Encryption of parameters using the secret key shared between the parties
ctr	Network time counter
ctp	Processing time counter
ctt	Total time counter
time	Value of local time obtained at the time of capture
IDsource	Identification value of the source part of the packet
IDdest	Identification value of the destination part of the packet
seq	Sequential value to identify the packet
mttr	Variable with an fixed value of tolerance time rate
ttr	Variable with an adjustable value of tolerance time rate
x	Briefly represents PART A (Client) or B (Server)
The first stage was the recognition of the parts through an identification message (colored in orange). In the second stage, a set of exchanges took place intending to mutually authenticate and exchange the asymmetric keys of the parts (colored in green). In the third stage, there were exchanges which aimed to establish a session key or secret key (colored in yellow). After these steps, there was the exchange of encrypted data represented by the step colored in purple.

Before beginning the Handshake steps shown in Fig. 5, standard processes, and values are presented since they are used in several Handshake steps: nonce value, finish the process, nonce analysis, and challenge-response function analysis.

Nonce value. The nonce value (nA or nB) for all transactions that a creation is required is obtained from Function 1:(1)

Finish process. Terminates the connection and initiates another synchronization request in the first step if PART A is finished.

Nonce analysis process. If the nonce value of any PART (nx) is equal to the previously generated nonce x, authentication continues, if it is not, terminates this step and starts the finishing process.

Process of analysis of the challenge-response function. If the resulting value of the function (Fdrx) applied to the public key (
) is equal to function response (R(Fdrx)), authentication continues, if not, terminate this step and starts the finishing process.

Maximum Tolerance Time Rate. The maximum tolerance time rate (mttr) is a fixed value that is used to limit the waiting time. Thus, avoiding infinite loops within the model. Therefore, 5 s are used as the standard in the second and sixth steps of PART A and the third step of PART B.

Variable Tolerance Time Rate. The tolerance time rate (ttr) is a variable with an adjustable value, which is dependent on the environment of authentication and is obtained from Function 2. It is a measure that tries to figure out the maximum delay of time considered in a typical behavior of the Handshake protocol, described in the next sections, avoiding the possibility of man-in-the-middle attacks. This value may vary depending on the application environment and physical distance between devices X and Y considered.(2)

The value of ttr is calculated in each independent environment before running the protocol by executing the test codes, such as 50 times, to acquire an average tolerance time rate. The parameter tpX of Function 2 represents the processing time of part X. The parameter trY of Function 2 represents the network time of part Y. Finally, the percentage value of Function 2 have to be calculated through testing the environment and will define the average tolerance time rate to be considered for this environment.

In section 4.2, it was used a percentage of 40% for the Fog Computing context and 75% for the Cloud Computing context. If a delay higher than 75% for the Cloud Computing context was identified, the environment could be subject to a possible attack, such as a man-in-the-middle attack.

For a better understanding of each step, during assembly of the package and receipt, the Handshake process is explained individually in PART A (Client-Side) and PART B (Server Side).

4.1.1.1. PART A: client side
First step. Starts with PART A by calculating the value of nonce (nA) from function 1. Subsequently, PART A concatenates in a packet the Syn – used true Boolean value to represent the Syn flag – and the generated nonce. Before sending to the receiver, PART A initiates a network time counter (ctr) – which assists in monitoring the network and processing time of the receiver – in sequence the packet is sent to PART B and goes to the second step.

Second step. Starts by monitoring if the receive time does not exceed 5 s of the maximum tolerance time rate (mttr), if it passes, finishes this step and starts the finish process, if not, continues authentication in this step. Upon receiving the PART B packet, the network time counter (ctr) ends, calculates the network time value (trA) and starts the processing time counter (ctp). Subsequently, PART A opens the received packet and enters the nonce A (nA) analysis process with that received and stored. Sequentially, PART A stores the time of the network counter and the nonce of B (nB) received and moves on to the third step.

Third step. In this step, the exchange of sets of authentication parameters and asymmetric keys of the parts begins. Initially, PART A generates a pair of asymmetric keys with the help of the RSA cryptography or Elliptic-curve cryptography, being a public one (
) and a private one (
) – for the purpose of memory optimization and performance, digital certificate is not used, only numbers in the keys, however it is possible to configure the use of certificate. A new nonce (nA) value is generated based on the description of Function 1. A challenge-response function (FdrA) is created, which is defined from a combination of the basic math function (addition, subtraction or multiplication) and a random value generated. The next task is to perform the signature with the RSA algorithm or ECDSA (Elliptic Curve Digital Signature Algorithm) of the previously generated parameters and the nonce B (nB) received in the previous step. Then, the processing time value (tpA) is calculated from the end of the processing time counter (ctp). Finally, a package is mounted containing: the public key of PART A (
); a challenge-response function (FdrA); the nonce value (nB), which was received from the other party in the previous step; the value of nonce (nA) generated; the signature of the whole set of previous parameters; and the processing time (tpA). Then, a total time counter (ctt) is started and the data packet is sent to PART B and finally it is moved to the fourth step.

Fourth step. Starts by monitoring if the total time counter (ctt) does not extrapolate the sum of the processing time (tpA) with the network time (trB), considering the tolerance time rate (ttr), i.e., ctt ≤ tpA + trB + ttr. If it passes, finishes this step and starts the process of completion, if not, the receipt of the PART B packet is monitored. Upon receiving the packet, the total time counter (ctt) ends. PART A opens the received packet and performs the process of analyzing the signature of the parameters, then executes the process of analysis of nonce A (nA) with the received and stored, after that, it executes the analysis of the challenge-response function. If all is correct, PART A stores the nonce of B (nB) received, the challenge-response function of B (FdrB), the public key of B (
), and finally moves to step five.

Fifth step. In order to respond to the other party that all parameters have been stored and understood, this step sends a confirmation packet. Before sending, PART A calculates the resulting value of the Challenge-Response Function (
) and generates a new value for the nonce (nA). Sequentially, it assembles a package containing: the flag with false value, that represents the understood (Ack); the challenge-response response (
); the nonce value received in the previous step (nB); the new value generated from nonce (nA). After that, the packet is signed (RSA or ECDSA) with the private key of the sender. Finally, in a concatenated way, it sends the assembled package with its respective signature to PART B, and starts the total time counter (ctt). This ends the key exchange phase and moves on to the sixth step.

Sixth step. From this step the symmetric key agreement phase occurs. However, before this occurs, it must be monitored if the total time counter (ctt) does not exceed 5 s of the maximum tolerance time rate (mttr). If it passes, finishes that step and starts the finish process. If it does not, continue the key agreement in this step. Upon receiving the PART B packet, the total time counter (ctt) ends and starts the processing time counter (ctp). PART A decrypts the received packet with its private key (
) and enters the parsing signature analysis process, then performs the process of analyzing nonce with the nonce (nA) received and stored. Only after verifying the integrity and authenticity of the packet, the part stores the nonce of B (nB), the resulting value of B (DHB) together with the Diffie-Hellman base (g) and module (p), generated by PART B. Finally, move on to the seventh step.

Seventh step. PART A performs the calculation of the Diffie-Hellman values from the information from PART B in the previous step, obtaining the resulting value (DHA) and the value for the session key (DHK). PART A also calculates a new nonce value (nA) through function 1. A signature for the Diffie-Hellman (DHA) value is applied with the private key of PART A. Still, the result is concatenated to the following values: Diffie-Hellman (DHA) value; nonce of destination (nB); nonce generated (nA). Afterwards, the data encryption is done with the public key (
) of PART B. Then the processing time counter (ctp), which after the calculation results in the value of the processing time (tpA), is stopped, and its value is concatenated at the end of the encrypted packet. This resulting packet is sent to PART B and, simultaneously, the total time counter (ctt) is started. Finally, finish this step and move on to the eighth step.

Eighth step. Starts by monitoring if the total time counter (ctt) does not extrapolate the sum of the processing time (tpA) with the network time (trB) and with tolerance time rate (ttr), i.e., ctt ≤ tpA + trB + ttr. If it exceeds, it finishes this step and starts the finish process, if not, the receipt of the PART B packet is monitored. Upon receipt of the PART B packet, the total time counter (ctt) is stopped and PART A decrypts the packet received with the session key (DHK) and enters the nonce analysis process with nonce (nA) received and stored. So at the end it verifies if the decryption of the package occurred correctly with the reading of the Ack flag. Thus, closing the symmetric (secret) key agreement process between the parties and moving on to the ninth step.

Ninth and successive steps. After the key agreement, PART A and PART B will be able to exchange encrypted data with a symmetric key (DHK), which may be ephemeral or permanent in relation to its use in data exchange. From that point on PART A can use the Publish and Disconnect methods present in the library.

4.1.1.2. PART B: Server Side
First step. Receives the package from PART A and stores the nonce of part A (nA).

Second step. Starts with PART B calculating and storing the nonce (nB) value from function 1. Then, PART B concatenates in a packet the Flag Ack enabled and the nonce (nB) generated and the nonce (nA) received previously. Subsequently, it starts the network time counter (ctr) and sends the packet created to PART A, after which it goes to the third step.

Third step. Starts by monitoring if the receive time does not exceed 5 s of the maximum tolerance time rate (mttr). If it does, it finishes this step and starts the finish process. If not, continue authentication in this step. Upon receiving the PART B packet, the network time counter (ctr) is stopped and the processing time counter (ctp) is started. Then the authentication of PART B opens the received packet and enters the process of analysis of the signature of the parameters, then performs the analysis of nonce (nB) with the received and stored, after that, occurs the analysis of the challenge-response function. Only after the whole analysis, the values nonce of the opposing party (nA), challenge-response function (FdrA), public key (
) and processing time (tpA) will be stored. Finally, move to the fourth step.

Fourth step. The auxiliary time counter (ctx) is started and PART B generates a pair of asymmetric keys (
 e 
) with the help of the RSA cryptography or elliptic curve cryptography (according to the initial configuration of cipher string). A new nonce value (nB) is also generated from the parameters adopted in Function 1. The obtaining result of the challenge-response function (
) is calculated. In addition, it is created a challenge-response function (FdrB) of PART B. Then, the previously generated parameters (
, F(FdrA), FdrB, and nA) are signed with RSA Algorithm or ECDSA together with the nonce (nB) received in the previous step. Thereafter, the processing time counter (ctp) is stopped and the processing time value (tpB) is calculated. In addition, the auxiliary time counter (ctx) is stopped. The auxiliary time counter (ctx) will be subtracted from the network time counter (ctr), resulting in the network time value (trA). Sequentially, a package is created containing: its public key (
); the response to the challenge-response function (
); the challenge-response function (FdrB) generated; the nonce value that was received from the opposite party in the previous step (nA); the generated nonce value (nB); the signature of the parameters; and the value of the processing time (tpB). Then, the total time counter (ctt) is started and the packet is sent to PART A.

Fifth step. Starts by monitoring if the total time counter (ctt) does not extrapolate the sum of the processing time (tpB) with the network time (trB) and with tolerance time rate (ttr), i.e., ctt ≤ tpB + trB + ttr. If it does, it finishes this step and starts the finish process, if not, the receipt of the package of PART A is monitored. Upon receipt of the package, the total time counter (ctt) is stopped. Subsequently, PART B opens the received package and performs the analysis of the signature of the parameters, then executes the analysis of nonce B (nB) with the received and stored, after that, it enters the process of analysis of the challenge-response function. Sequentially, if all is correct, PART B stores the nonce (nA) and the public key (
) of PART A, and finally moves to the sixth step.

Sixth step. The processing time counter (ctp) is started and the Diffie-Hellman values are calculated. It calculates a resultant Diffie-Hellman (DHB) value along with the values of the base (g) and the value of the module (p). Besides these values, a new nonce (nB) and a random value (iv) are generated for later use in the symmetric algorithm. Sequentially, a packet with the previous concatenated values (DHB, g, p, iv, nB) is assembled together with the nonce (nA) received from the opposing party. Then, the Diffie-Hellman (DHB) values are signed with RSA Algorithm or ECDSA, with their parameters (g and p) and the initialization vector (iv) of AES. The result of the signed value is concatenated with the previous mounted packet, and this is encrypted with the recipient's public key (
). The processing time counter (ctp) is stopped and the processing time (tpB) is calculated. This value is concatenated at the end of the previous package. Finally, the total time counter is started, the resulting packet is sent to PART A and the end of the process goes to the seventh step.

Seventh step. Starts by monitoring if the total time counter (ctt) does not extrapolate the sum of twice the processing time (tpB) with the network time (trB) and with tolerance time rate (ttr). If it does, it finishes this step and starts the finish process, if not, the receipt of the PART A packet is monitored. Upon receipt of the packet, the total time counter (ctt) is stopped. Subsequently, PART B decrypts the received packet with the private key (
) and performs the process of analyzing the signature of the parameters, then executes the analysis of nonce B (nB) with the received and stored. Then, it stores the received nonce (nA) and calculates the session key with Diffie-Hellman and its parameters (g and p). Finally, move on to the eighth step.

Eighth step. Starts by mounting a package that contains: the flag Ack and the nonce (nB) value received in the previous step. Sequentially, encrypts the packet with the session key (DHK) and sends the packet to PART A.

Ninth and successive steps. After the agreement of keys, PART B is able to receive data encrypted with a symmetric key (DHK), which may be ephemeral or permanent in relation to its use in data exchange.

4.1.2. The Multi-Factor Authentication Process
The Multi-factor Authentication is intended to both, strongly authenticate and provide a way to detect some out of rule behavior between parties, enabling a secure break of the interaction. Three authentication factors are present in our work: the challenge-response function, the response time, and the nonce.

Challenge-response function. It is an identity verification mechanism through a mathematical function. This verification can result in a discontinuation of the communication if the response value of the function is incorrect. The challenge-response function is composed of three components: the challenged value (
); the mathematical function (Fdrx); and the resulting value (
), which is the result of the application of the challenged value in the mathematical function of the challenge-response.

Response time. It is a mechanism of time collection and analysis of similarities of identities. This value may vary depending on the application environment and physical distance between considered devices. This measures the delay resulting from the sending until the reception of the response packet. The client sets this calculation (PART A) and the server (PART B): the value of the processing time (tp) plus the network time (tr) value between the parts plus the tolerance time rate (ttr). So, ResponseTime = tp + tr + ttr.

Nonce. Is another identity verification mechanism, which uses the nonce of the handshake for verification. It checks whether the sent nonce is the same as that received in the previous step. The same can be verified through Function 1. The nonce represents the forwarding of the commit (Time), concatenated to the target identifier, source identifier, and a random sequence.

4.2. Solution scope
Considering the literature presented in Section 3, some key features, such as the cryptographic mechanisms and strategies used in authentication, are crucial to provide fair and secure authentication in IoT environments that interact with fog and cloud.

Mutual authentication that uses multi-factors in authentication is scarce. Table 1 presents 24 related work (excluding our own). From these 24 works, only six works use multi-factor authentication mechanisms: Aghili et al. (2019), Ayub et al. (2020), Kiran, Pasupuleti and Eswari (Kiran et al., 2019), Loffi et al. (2019), Rao, Santhi and Hussain (Rao et al., 2019) and Sharma and Kalra (2018). Only the work of Loffi et al. (2019) and Kiran, Pasupuleti, and Eswari (Kiran et al., 2019) deals with mutual authentication while the other four have only unidirectional authentication by default.

The works of Aghili et al. (2019) and Ayub et al. (2020) use smartcard, biometrics scheme, and password as multi-factor authentication mechanisms. Kiran, Pasupuleti and Eswari (Kiran et al., 2019) use biometrics and password as authentication factors. Some sequence graphical passwords and nonces (random numbers) are used in the work of Rao, Santhi and Hussain (Rao et al., 2019). Finally, Sharma and Kalra (2018) (Sharma and Kalra, 2018) uses smartcards, passwords, and timestamps.

In this way, it was concluded that Loffi et al. (2019) would be used as a basis, and some characteristics have to be improved to advance the research:

1.
Inclusion of the elliptical curve algorithm as a means of exchanging keys present in the second stage (green) and the key agreement present in the third stage (yellow) of the scheme shown in Fig. 5;

2.
Inclusion of the variable adjustable tolerance time ratio (ttr) in the response time so that the same method can be used for the Fog Computing and Cloud Computing contexts;

3.
Development of improved code in Java language using the client-server communication structure.

Fig. 6 shows the IoT environment that was used for the development of the mutual authentication scheme. It contains a Raspberry Pi 3 (Quad-Core 1.2 GHz Broadcom BCM2837 64bit CPU) device as a “sensor node”, a notebook (i7-3630QM 2.4 GHz) as a “fog node”, and a cloud instance with Xeon Skylake 3.5 GHz as a “cloud node”.

Fig. 6
Download : Download high-res image (375KB)
Download : Download full-size image
Fig. 6. Proposed Architecture in Loffi et al. (Loffi et al., 2019).

The environment present in Fig. 6 was used to compare the contexts of fog computing and cloud computing. In the context of fog computing, experiments are carried out between the “sensor node” and “fog node”. In cloud computing, the test between the “sensor node” and the “cloud node” is performed. These two contexts were presented in the form of client-server.

This research developed the code in the Java language using the client-server communication structure with functions called publisher-subscriber with UDP connection. The Broker will not be used, only functions with similar names.

To achieve a variable and adjustable tolerance time rate in response time, it was noted that in some moments, the implementation was presented by Loffi et al. (2019) did not complete the Handshake. Therefore, investigations were carried out in the implementation, and it was concluded that it was necessary to add a time tolerance rate according to the application context in the response time. Thus, tests were performed, and a time tolerance rate parameter was added to each method that represents the steps in Fig. 5. In Fog computing, there is a maximum tolerance of 45% and in the context of Cloud computing 80%.

In order to know the correct value for the tolerance time rate (ttr) in the environment, there must be preliminary tests with varying values in the variable ttr (The variable ttr is located inside the handshake() method of class IoTAuth_client), from 0% to the maximum value previously indicated. The correct value for the tolerance time rate (ttr) is the one that completes the handshake in the context environment of all executions. If the finishing process is reached before completing the handshake, it is recommended to increase the tolerance time rate (ttr) value up to the indicated limit.

The authentication application's scope will cover the following encryption methods: AES, RSA, ECC, and Diffie-Hellman. Thus, the larger scope of work is to tailor the appropriate cryptosystems to meet the requirements of an optimized authentication method using the Java language for library suitability.

For the development of elliptic curves and RSA keys in parallel, standardized strings of cipher suites, called cipher strings, were used, as currently occurs in TLS (in the present study, TLS libraries were not used). There are two cipher strings available in this research: ECDHE_ECDSA_AES128-CBC_SHA512 and DHE_RSA_AES128-CBC_SHA512.

The string ECDHE_ECDSA_AES128-CBC_SHA512 represents that the ephemeral Diffie-Hellman algorithm with elliptic curves will be used for the symmetric key agreement (ECDHE) and, for authentication, the digital signature algorithm for elliptic curves (ECDSA) is used. The 128-bit AES algorithm was used in CBC mode for symmetric encryption, and to hash the information, the 512-bit SHA algorithm was used. There is the inclusion of the elliptic curve algorithm as a means of exchanging keys present in the second stage (green) and the key agreement present in the third stage (yellow) of the scheme shown in Fig. 5.

On the other hand, the string DHE_RSA_AES128-CBC_SHA512 represents that the ephemeral Diffie-Hellman algorithm will be used for the symmetric key agreement (DHE), for authentication, the RSA algorithm with asymmetric key generation is used, the AES algorithm with 128 bits in CBC mode for symmetric encryption, and to hash, the information, the SHA algorithm with 512 bits were used. There is the inclusion of the RSA algorithm as a means of exchanging keys present in the second stage (green) and in the key agreement present in the third stage (yellow) of the scheme shown in Fig. 5.

4.3. Threat model
In the current IoT-Fog-Cloud research, the widely accepted threat model Dolev and Yao (1983) has been followed and used. Under the Dolev-Yao model, the parties can communicate via a secure channel. However, the communication channel is public. Therefore, in this model, the opponent can delete and block messages that are transferred through the channel and be able to intercept all messages transferred in the protocol as being a passive opponent. However, to modify messages, the opponent has only the tolerance time rate (ttr) of our proposal as a limit of time. Otherwise, if the opponent cannot modify the messages in less time than ttr, the messages will be discarded because it will be considered a man-in-the-middle attack. The opponent can try an impersonation attack if he/she modifies a message in less time than the following limit: processing time of part X (tpX)+ network time of part Y (trY) + tolerance time rate (ttr) of the environment. In this way, the opponent could try to impersonate some of the parts of the interaction. The nonce used in our proposal, which ties the parameters of time, source, and target identification, will prevent impersonation attacks since it is always used in the protocol interactions. The physical capture of IoT sensors is possible by the opponent. This way, it can extract credentials from the IoT sensor memory. The extracted data can be applied to calculate the session key and perpetrate an impersonation attack.

5. Algorithm specifications
This section presents the developed interface. The proposal was made in the Java programming language, and the client-server methods developed are called Publisher and Subscriber. It was based on the article Loffi et al. (2019), who wrote the interface in C++ programming.

As previously shown, Fig. 4 illustrates a sequence diagram with the possible executions with the developed Java code.

Listing 1 notes the methods available to the customer. Thus, for the sensor/actuator client to make the connection with the server, the destination address and the port (connect method) must be utilized, and subsequently, the publication of some data on the server, requiring data to be published (publish method). The sensor/actuator can request data available on the server through a specific topic (request method). Finally, it is possible to disconnect from the server (disconnect method) or check if the connection between the sensor and the server is established (isConnected method).


Listing 1. Java Client Sensor/Actuator Call Methods

∗ boolean connect(String address, int port){...}
∗ boolean publish(String data){...}
∗ String request(String topic){...}
∗ boolean disconnect( ){...}
∗ boolean isConnected( ){...}
Listing 2 notes the possible methods for the server when implemented with the Java programming language. The server can wait for a connection on a specific port (wait_connect method), listen to publication on a port for a specific time (listen method), publish some data when requested (publish_server method), disconnect from the sensor/actuator (disconnect method), check how the connection is in relation to the establishment or not (isConnected method). It is also possible to define the configuration of cryptographic algorithms, using the setciphersuite method. When not configured, ECDHE_ECDSA_AES128-CBC_SHA512 is used as the first option, and if the customer does not have support, DHE_RSA_AES128-CBC_SHA512 is used.


Listing 2. Java Server Call Methods

∗ boolean wait_connect(int port){...}
∗ String listen(int timeout){...}
∗ boolean publish_server(String data){...}
∗ boolean disconnect( ){...}
∗ boolean isConnected( ){...}
∗ boolean setciphersuite(String ciphersuite){...}
Listing 3 shows an example of an application code for the sensor/actuator client, using the library interface (the connection between the mutual authentication protocol and the final application), called IoTAuth_client, and the usage representation of the methods that were shown in Listing 1. The application represents the operation of sending and requesting data in a temperature sensing.

The Java library containing the code for the server and the client is available on GitHub, available at the following link: https://github.com/leandroloffi/iotAuth_Java.

As can be seen in Listing 3, the process starts with the connection request (Connection phase in Fig. 4) with a specific server, in this case, with IP “135.243.230.153” and port ‘8655’. Subsequently, the verification is conducted if the client is connected and, if so, the client publishes the temperature data on the server and, soon after, the client requests the data that are on the server, without specifying a topic. Finally, the client requires a disconnection from the server.


Listing 3. Client Application Example.

DECLARES client1:IoTAuth_client
DECLARES requested:Chars
client1 = IoTAuth_client(true)
WHILE client1.isConnected = false DO:
 client1.connect(“135.243.230.153”, 8655)
 IF client1.isConnected = true THEN
 client1.publish(“temperature:_25C”)
 requested = client1.request()
 PRINTS(requested)
 client1.disconnect()
 END_IF
END_WHILE
Fig. A.8 displays the developed classes, constructors, functions, and private (red lock) and public (green lock and gray balls) global variables.

The general relationship between the classes can be observed in Fig. A.9. In summary, it can be acknowledged that from the main class main_client, the IoTAuth_client class is called through the connect method, which through an initial contact of connection in the UDPClient class, receives and decides about which algorithm to use through the configuration performed on the server. In sequence, the IoTAuth_client class calls different functions, which are the steps defined in Fig. 5 in the Util_client class, which correspondingly, calls different classes for its operation. This Util_client class implements all the steps presented in Fig. 5 in methods/functions.

In Fig. A.10, observe the execution output by the customer. It should be noted that the verbose mode – an option to provide additional details about what is happening during the Handshake – was used when instantiating the class “new IoTAuth_client (true);” with the true Boolean statement. To better visualize the output and keep the organization, a decision was made to show only the variables used with the JSON library, without the values loaded in those variables.

The execution of the client is completed with the execution of the server, thus in Listing 4 a final application for the server is presented using the interface methods with the proposed protocol. In Java, the process starts by configuring the Cipher String ECDHE_ECDSA_AES128-CBC_SHA512 and then a connection to the handshake is expected on a port (8655), and then awaits publication or data request. Likewise, it checks for a disconnection request.


Listing 4. Server Application Example

DECLARES server1:IoTAuth_server
DECLARES value:Chars
server1 = IoTAuth_server(false)
server1.setciphersuite(“ECDHE_ECDSA_AES128_−CBC_SHA512”)
server1.wait_connect(8655);
WHILE client1.isConnected = false DO:
 value = server.listen(10000)
 IF value = “timeOut” THEN
 PRINTS(“TIMEOUT!“)
 ELSE IF value = “request” THEN
 server.publish_server(“Hi,_I_am_the_response_of_the_request”)
 ELSE
 PRINTS(value)
 END_IF
END_WHILE
As made evident in Fig. A.11, there are in the displayed classes, constructors, functions, and global private (red lock) and public (green lock and gray balls) variables.

The general relationship between the classes can be seen in Fig. A.12. To summarize, it should be noted that from the main class main_server, the IoTAuth_server class is called through the wait_connect(port) function, which listens to the port that was passed by parameter, when an initial contact occurs, the UDPserver class is used. After making the initial connection contact, the handshake proposed accesses the Util_server class through its methods, which in turn calls different classes for its operation, as shown in the UML in Fig. A.12.

In Fig. A.13 the execution output by the server can be seen. It should be noted that the available verbose mode was used when instantiating the class “new IoTAuth_server (true);” with the true Boolean statement. To visualize the output and keep the organization, it was decided that only the variables used with the JSON library would be shown, without the values that are loaded in those variables.

6. Evaluations and analyzes
This section describes the informal security analysis of the mutual authentication method and the formal security evaluation using the ProVerif tool. The complexity of the code developed in Java is described. The cost of computing and communication were estimated. Measurements of the time required to perform mutual authentication and energy expenditure measures are also presented in this section.

6.1. Informal security analysis
This section presents an informal security analysis of the multi-factor authentication method proposed in this work.

●
Use of asymmetric keys: The first guarantee of mutual authentication is the use of asymmetric keys (not certificates) sent mutually and used to verify the signature of parameters between part A and part B. Steps 3, 4, and 5 have the only signature of parameters without encrypting them: the first part of the packet are the parameters and the second part is the signature of those parameters. This signature is authenticating the parameters and authenticates parties in a mutual way. Mutual authentication guarantees confidence in interaction because data can be verified in each step.

●
Use of Nonces: nonces are exchanged and signed between part A and part B in each one of the handshakes (except step 9). The nonce is calculated as nx = HASH(time | IDdest | IDsource | seq). Nonces takes the value of local time, the identification of destination, the identification of the source, and a sequence number. These nonces guarantee protection against impersonation attacks since link identities of parties in their calculus. If the attacker tries to fabricate a nonce, it will be hard for him to succeed because he should know identifications, the local time, and the sequence number used. Nonces prevent replay attacks since they add a timestamp to the package.

●
Use of challenge-response functions: A challenge-response function FdrA is sent from part A to part B in step 3. In step 4, part B calculates FdrA using the public key of part A (
) and sends this value to part A. Only part B could calculate the correct challenge-response function because FdrA was received in step 3. Finally, in step 5, part A calculates the challenge-response function FdrB, using the public key of part B (
), and send this value to part B. If both parties have correctly calculated the challenge-response functions, the authentication phase (steps 3, 4, and 5) guarantees the freshness, mutual authentication and prevents replay attacks.

●
Session key agreement: steps 6, 7, and 8 perform key agreement by exchanging parameters of Diffie-Hellmann (DHB, DHA, g, p) between the parties. Nonces continue to be sent in steps 6, 7, and 8. The IV value is the initialization vector value necessary to encrypt the message using the AES algorithm in steps 8 and 9. It is worth noting that steps 6, 7, and 8 are encrypted. The generation of new session keys, in this IoT context, guarantee forward secrecy in the protocol, preventing keys eventually discovered in previous communications to be used again by the attacker.

●
Three metrics of time are used in the mutual authentication: network time (trY), processing time (tpX), and variable tolerance time rate (ttr). The idea is to use trY, tpX, and ttr to control the delay between messages of the protocol. This control helps deal with a maximum delay in the protocol to prevent man-in-the-middle and impersonation attacks, besides execution problems. The network time (trY) measures the time spent to go and return, the RTT (Round-trip time) of each part in the environment. Steps 1 and 2 define the network time (trA) of part A. Steps 2 and 3 serve to define the network time (trB) of part B. At the beginning of step 3, tpA begins to count the processing time that part A will take to mount the whole packet to transfer to part B. When it finishes mounting all the packet, tpA stops counting the time, and its value is passed to part B. In the beginning of step 4, part B performs the same operation, i.e., starts to count tpB, and once finishing to mount the whole packet, calculating FdrA, tpB finishes the counter, and its value is transferred to part A. So, the values of processing times are stored. Once part A and part B have network and processing times, they can calculate tolerance time rate as 
 (considering X and Y as A and/or B). Then, the maximum delay considered normal behavior in the protocol would be tpX + trY + ttr. If this maximum delay is exceeded, the protocol stops and can consider this fact an attack.

●
Resistance to Man-in-the-middle attacks: The attacker has only the tolerance time rate (ttr) of our proposal as a limit of time to try the modification of the message, as the man-in-the-middle. If he/she exceeds ttr, the other party will identify this message as invalid and will stop the protocol (ctt > tpX + trY + ttr). It is required for the attacker to know nonces and challenge-response functions, which cannot be forged. Hence, the proposed protocol is secure against man-in-the-middle attacks.

●
Resistance to Impersonation attacks: The protocol is secure against impersonation attacks because it has: the three metrics of time to control the delay; the use of nonces that link time, identities of the parties, and a sequence number (nonces are used in all steps, except step 9); and, the challenge-response functions. It is required for the attacker to know how to calculate and use these three factors, which have high complexity.

6.2. Formal security evaluation with the ProVerif Tool
For the formal evaluation of the method proposed, the Proverif tool was used. According to Blanchet et al. (2010), “ProVerif is an automatic cryptographic protocol verifier […] This protocol verifier is based on a representation of the protocol by Horn clauses”. ProVerif supports a set of cryptographic primitives such as: symmetric and asymmetric encryption; digital signatures; hash functions; non-interactive zero-knowledge tests; among others.

The ProVerif tool verifies more security properties and complements the AVISPA verification presented by Loffi et al. (2019). The ProVerif tool was used to verify the following security properties: discovery of the proposed secret; verification of authentication in the proposed protocol; checking matching properties (between functions and variables); verification between processes that differ only in terms; robust secret verification (the intruder cannot distinguish the secret from a random value).

The specification describes and assesses the security components of the protocol presented in section 4 in the π calculus language. Each component was specified separately; however, initially, some general specifications were used for both the sensor and the server, as presented in Listing 5. The supported types are declared, the symmetric and asymmetric encryption functions, signature, and Diffie-Hellman, among other protocols, functions like FDR (Challenge-Response function).


Listing 5. Initial Specification for ProVerif tool

(∗ Declaration ∗)
type nonce.
type syn.
type ack.
type fdr.
type tp.
type end.
(∗ Symmetric key encryption ∗)
type key.
fun senc(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; sdec(senc(m,k),k) = m.
(∗ Asymmetric key encryption ∗)
type skey.
type pkey.
fun pk(skey): pkey.
fun aenc(bitstring, pkey): bitstring.
reduc forall m: bitstring, sk: skey; adec(aenc(m,pk(sk)),sk) = m.
(∗ Diffie−Hellman Declaration ∗)
type G.
type exponent.
type modo.
fun sign1(G, skey): bitstring.
reduc forall m: G, k: skey; getmess1(sign1(m,k)) = m.
reduc forall m: G, k: skey; checksign1(sign1(m,k), pk(k)) = m.
fun enc(bitstring, G): bitstring.
reduc forall x: bitstring, y: G; dec(enc(x,y),y) = x.
const g: G.
const p: G.
fun exp(G, exponent): G.
equation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).
(∗ Digital signatures ∗)
fun spk(skey): pkey.
fun sign(bitstring, skey): bitstring.
reduc forall m: bitstring, ssk: skey; getmess(sign(m,ssk)) = m.
reduc forall m: bitstring, ssk: skey; checksign(sign(m,ssk),spk(ssk)) = m.
(∗ Function ∗)
fun Rfdr(fdr,pkey): bitstring.
reduc forall m: bitstring; getRfdr(m) = m.
free c:channel.
free k:bitstring [private].
query attacker(k).
let end1() =
 new end2:end;
 out(c, end2).
After presenting the general specifications, Listing 6 exhibits the specification used by the sensor or client in ProVerif to verify the security of the proposed protocol. It should be noted that the specification is divided, as shown in Fig. 5.


Listing 6. Client Specification for ProVerif tool

let clientA() =
 (∗ STEP 1 ∗)
 new nonceA1:nonce;
 new SynA:syn;
 out(c,(SynA, nonceA1));
 (∗ STEP 2 ∗)
 in(c, (AckB:ack, nonceA_v1:nonce, nonceB1:nonce));
 if nonceA_v1 = nonceA1 then (
 (∗ STEP 3 ∗)
 new skA:skey;
 new tpA:tp;
 new FdrA:fdr;
 new nonceA2:nonce;
 let pkA = pk(skA) in
 out(c, (pkA, FdrA, nonceB1, nonceA2, sign((pkA, FdrA, nonceB1, nonceA2), skA), tpA));
 (∗ STEP 4 ∗)
 in(c, (pkB:pkey, RfdrB:bitstring, FdrB:fdr, nonceA_v2:nonce, nonceB2:nonce, m:bitstring, tpB_4:tp);
 if nonceA_v2 = nonceA2 && Rfdr(FdrA, pkA) = RfdrB then (
 (∗ STEP 5 ∗)
 new nonceA3:nonce;
 new AckA:ack;
 out(c, (AckA, Rfdr(FdrB, pkB), nonceB2, nonceA3, sign((AckA, Rfdr(FdrB, pkB), nonceB2, nonceA3),skA)));
 (∗ STEP 6 ∗)
 in(c, (dhB:G, nonceA_v3:nonce, nonceB4:nonce, m0:bitstring));
 if nonceA_v3 = nonceA3 then (
 (∗ STEP 7 ∗)
 new n1:exponent;
 new nonceA4:nonce;
 let (=dhB, = g, = p) = checksign(m0,pkA) in
 let k = exp(dhB, n1) in
 out(c, (exp(g, n1), nonceB4, nonceA4, sign1(exp(g, n1), skA)));
 (∗ STEP 8 ∗)
 in (c, (=AckB, nonceA_v4:nonce));
 if nonceA_v4 <> nonceA4 then (
 end1()
 )
 ) else (
 end1()
 )
 )else(
Listing 7 features the specification used by the gateway or server for ProVerif to verify the security of the proposed protocol. Similarly, this specification is based on the steps shown in Fig. 5.


Listing 7. Server Specification for ProVerif tool

let serverB() =
 (∗ STEP 1 ∗)
 in(c,(SynA:syn, nonceA1:nonce));
 (∗ STEP 2 ∗)
 new nonceB1:nonce;
 new AckB:ack;
 out(c,(AckB, nonceA1, nonceB1));
 (∗ STEP 3 ∗)
 in(c, (pkA:pkey, FdrA:fdr, nonceB_v1:nonce, nonceA2:nonce, m:bitstring, tpA_3:tp));
 if nonceB_v1 = nonceB1 then (
 (∗ STEP 4 ∗)
 new nonceB2:nonce;
 new skB:skey;
 new tpB:tp;
 new FdrB:fdr;
 let pkB = pk(skB) in
 let (=pkA,=FdrA, = nonceB_v1, = nonceA2) = checksign(m,pkA) in
 out(c, (pkB, Rfdr(FdrA, pkA), FdrB, nonceA2, nonceB2, sign((pkB, Rfdr(FdrA, pkA), FdrB, nonceA2, nonceB2),skB), tpB));
 (∗ STEP 5 ∗)
 in(c, (AckA:ack, RfdrB:bitstring, nonceB_v2:nonce, nonceA3:nonce, m1:bitstring, tpA_5:tp));
 if nonceB_v2 = nonceB2 && Rfdr(FdrB, pkB) = RfdrB then (
 (∗ STEP 6 ∗)
 new nonceB4:nonce;
 new n0:exponent;
 new tpB2:tp;
 let(=AckA,=RfdrB, = nonceB_v2, = nonceA3) = checksign(m,pkA) in
 out(c,(exp(g, n0), g, p, nonceA3, nonceB4, sign((exp(g, n0), g, p), skB)));
 (∗ STEP 7 ∗)
 in (c, (DHA:G, nonceB_v4:nonce, nonceA4:nonce, m2:bitstring));
 if nonceB_v4 = nonceB4 then (let x1 = checksign1(m2, pkA) in let k = exp(x1, n0) in
 (∗ STEP 8 ∗)
 new AckB2:ack;
 out(c, enc((AckB2, nonceA4), k))
 ) else (
 end1()
 )
 ) else (
 end1()
 )
 ) else (
 end1()
 ).
Lastly, Listing 8 presents the specification of the main process that defines two parallel processes: the first is the client or sensor process, and the second is the gateway or server process. The exclamation point before the server string (serverB) implies the execution of several sessions to supply several requests from clients simultaneously.


Listing 8. Main Specification for ProVerif Tool

process
 ((clientA()) | (!serverB()))
After executing the specification in the ProVerif tool, it is possible to observe in Fig. A.7 that the result obtained was “RESULT not attacker (k[]) is true”. This result signifies that with the secret k[], it is impossible to have a derivation for key discovery (Prada, 2011). Consequently, it can be concluded that after execution, only the client and the server are aware of the symmetric key established in the eighth step of Fig. 5.

6.3. Algorithm complexity
The algorithm's complexity is linked to the big-O notation that describes the behavior of the functions and the characteristics of the algorithm when it tends to a specific value or the infinite (Leiserson et al., 2001). This notation is part of other theories known as Landau notation, Bachmann-Landau notation, or asymptotic notation, named by Edmund Landau and Paul Bachmann (Beigi, 2011). Therefore, to use the notation big-O to characterize and summarize all the functions present in the developed algorithm, all of the functions linked to it must be understood.

It should be stated that in the article Loffi et al. (2019), the C++ language was used to develop the code. The code developed through Java in this study followed the same logic as the code described in Loffi et al. (2019), albeit using the Java language as well as similarities in the functions of the publisher/subscriber. Correspondingly, the “publish” method sends client data to the connected server, and the server's “listen()” method keeps listening to data sent from all clients (sequentially in a list).

Analyzing all written code and taking the worst-case should always be considered in the asymptotic analysis (Leiserson et al., 2001). Thus, it is concluded that the notation big-O (characteristic of the algorithm) is O(n), because the code is presented linearly, without double use of “for” functions or any other feature that increases the complexity of the algorithm. One can take as an example the specification of author Imine et al. (2018) that presents O(n). Therefore, it can be said that the present work has the same characteristic as the article by Imene et al. (Imine et al., 2018).

6.4. Computation cost
The computational cost of the mutual authentication method is analyzed in this section.

Table 3 presents the computational cost comparison in theoretical form. For the present work, the operation defined in the Function 1 was considered, being equivalent to 1 hash (Th). For each operation performed for encryption with asymmetric keys with ECC and RSA, one encryption cost (Te/Tecm) was considered. For each encryption using symmetric keys, one encryption cost (Ts) was considered.


Table 3. Comparison of computation cost (theoretical).

Work	REF	cost
Aghili et al. (2019)	Aghili et al. (2019)	28Th + 1Tbh
Sethia et al. (2018)	Sethia et al. (2018)	22Th + 18Ts
Gope and Das (2017)	Gope and Das (2017)	10Th
Hassan et al. (2019)	Hassan et al. (2019)	6Th + 2Ts
Zhou et al. (2019)	Zhou et al. (2019)	19Th
Fan et al. (2020)	Fan et al. (2020)	2Th + 6Ts
Alshahrani and Traore (2019)	Alshahrani and Traore (2019)	17Th
Sharma and Kalra (2018)	Sharma and Kalra (2018)	9Th
Wu et al. (2017)	Wu et al. (2017)	18Th
Ayub et al. (2020)	Ayub et al. (2020)	10Th + 3Tecm
Kalra and Sood (2015)	Kalra and Sood (2015)	10Th + 9Tecm
Kiran, Pasupuleti and Eswari (2019)	Kiran et al. (2019)	7Th + 2Te
Wazid et al. (2019)	Wazid et al. (2019)	9Th + 4Tecm
Our work	this	7Th + 7Te + 1Ts
We compared the present work with previous works in Table 3. We present only the works that showed their computational cost in a theoretical way. On the other hand, for the sake of comparison, one should only consider the works that used ECC keys. In this way, the work of Ayub et al. (2020) achieved 10Th + 3Tecm; Kalra and Sood (2015) achieved 10Th + 9Tecm; Kiran, Pasupuleti and Eswari (Kiran et al., 2019) achieved 7Th + 2Te; and Wazid et al. (2019) achieved 9Th + 4Tecm. Our work achieved the performance result of 7Th + 7Te + 1Ts. Thus, it can be said that the present work has a median value compared to other articles. However, this paper focuses on providing high security of mutual authentication for IoT devices.

For comparison, in this work we consider the approximate values of Th ≈ 0.0004 ms, Te ≈ Tecm ≈ 17.1 ms, Tbh ≈ 0.01 ms, and Ts ≈ 0.1303 ms. Table 4 presents a comparison between the present work and previous works. This table takes into account the values previously reported for each cost in Table 3. So, the values presented in Table 4 are the results of calculating the theoretical computational cost presented in the articles, using the approximate values of Th ≈ 0.0004 ms, Te ≈ Tecm ≈ 17.1 ms, Tbh ≈ 0.01 ms, and Ts ≈ 0.1303 ms.


Table 4. Comparison of computation cost (performance).

Work	REF	cost (ms)
Aghili et al. (2019)	Aghili et al. (2019)	0.0212
Sethia et al. (2018)	Sethia et al. (2018)	2.3542
Alshahrani and Traore (2019)	Alshahrani and Traore (2019)	0.0068
Fan et al. (2020)	Fan et al. (2020)	0.7826
Gope and Das (2017)	Gope and Das (2017)	0.004
Hassan et al. (2019)	Hassan et al. (2019)	0.263
Sharma and Kalra (2018)	Sharma and Kalra (2018)	0.0036
Wu et al. (2017)	Wu et al. (2017)	0.0072
Zhou et al. (2019)	Zhou et al. (2019)	0.0076
Ayub et al. (2020)	Ayub et al. (2020)	51.304
Kalra and Sood (2015)	Kalra and Sood (2015)	153.904
Kiran, Pasupuleti and Eswari (2019)	Kiran et al. (2019)	34.2028
Wazid et al. (2019)	Wazid et al. (2019)	68.4036
Our work	this	119.8331
This work has a performance cost of 119.8331 ms. Therefore, our work performs better than the work of the authors Kalra and Sood (2015). However, it remains behind the other articles (Ayub et al., 2020; Kiran et al., 2019; Wazid et al., 2019) that used ECC keys.

6.5. Communication cost
Communication cost was analyzed. We consider nonce, hash, and timestamps to be 160 bits, 160 bits, and 32 bits. Since the 1024-bit RSA public-key cryptography system provides a level of security equivalent to that of the 160-bit ECC (Vanstone, 1992), an elliptic curve point P = (Px, Py) consumes (160 + 160) = 320 bits. Tests were carried out between the sensor node and Google's cloud, from which it is possible to extract the information that the algorithm consumed approximately 1400 bits for each authentication request using RSA keys, and 1280 bits using ECC keys. Table 5 shows the comparison of the communication cost.


Table 5. Comparison of communication cost.

Work	REF	network
Aghili et al. (2019)	Aghili et al. (2019)	2208 bits
Alshahrani and Traore (2019)	Alshahrani and Traore (2019)	1376 bits
Gope and Das (2017)	Gope and Das (2017)	576 bits
Wu et al. (2017)	Wu et al. (2017)	3932 bits
Zhou et al. (2019)	Zhou et al. (2019)	5856 bits
Ayub et al. (2020)	Ayub et al. (2020)	2112 bits
Kalra and Sood (2015)	Kalra and Sood (2015)	1280 bits
Loffi et al. (2019)	Loffi et al. (2019)	1400 bits
Our work	this	1400 bits (RSA)
1280 bits (ECC)
It should also be considered that this work and only a few other works (Loffi et al., 2019; Ayub et al., 2020; Kalra and Sood, 2015) use ECC or RSA, the others in the table are works that use XOR techniques without keys. Therefore, it can be said that the present work is equal or even better than the compared works (Loffi et al., 2019; Ayub et al., 2020; Kalra and Sood, 2015).

6.6. Runtime performance in Java
This section describes the performance results for the protocol developed in Java. Regarding the performance of storage consumption in Java, the client occupies 86,633 bytes of RAM, and the server occupies 90,112 bytes of RAM. It is important to note that in Java, the code is represented in bytecodes (class).

Regarding the execution times, they were obtained for each of the protocol steps described in section 4. Each protocol step was tested for the following interactions: between a client/sensor and a server/fog; and between a client/sensor and a server/cloud.

It is important to note that, although the descriptions follow the type of interaction (client-fog or client-cloud), the execution times refer to the time spent processing the protocol on the node itself: client node, fog node, or cloud node. The network time is excluded from the calculation.

As previously discussed, Fig. 6 presents the IoT environment in which the mutual authentication scheme was used for evaluation. Therefore, for the present study, a Raspberry Pi 3 (Quad-Core 1.2 GHz Broadcom BCM2837 64bit CPU) device was used to represent the sensor node, for the Fog node a notebook (i7-3630QM 2.4 GHz) was used and Google's cloud computing architecture was used as the Cloud node (Xeon - Skylake 3.5 GHz).

Two ways of running the tests have been developed. In the first, there is an internal repetition in the Java code itself, called an internal repetition. In the second, the repetition of the tests was done through scripts (.sh on Linux and.bat on Windows), which was called external repetition. The execution with internal repetition showed better performance in the execution time because there was the loading of the code and the instances in memory (Deitel and Deitel, 2008).

It is worth noting that each row of the values presented in Table 6, Table 7, Table 8, Table 9 were values obtained by calculating the time spent to perform the functions of the steps (step_1_client(), step_2_client(), […] and step_1_server(), step_2_server(), […]). These developed methods are present in the Util_client and Util_server classes. Therefore, the values presented do not take network time into account. These methods represent the proposed authentication method shown in Fig. 5.


Table 6. Average runtime performance with external repetition (DHE_RSA_AES128-CBC_SHA512).

STEP	Client (Sensor)	Server (Fog)	Server (Cloud)
1st	267 ms	371 ms	328 ms
2nd	48 ms	51 ms	50 ms
3rd	6,201 ms	717 ms	705 ms
4th	326 ms	815 ms	718 ms
5th	102 ms	10 ms	10 ms
6th	514 ms	104 ms	102 ms
7th	248 ms	37 ms	36 ms
8th	198 ms	30 ms	23 ms
TOTAL	7,904 ms	2,135 ms	1,972 ms

Table 7. Average runtime performance with external repetition (ECDHE_ECDSA_AES128-CBC_SHA512).

STEP	Client (Sensor)	Server (Fog)	Server (Cloud)
1st	287 ms	362 ms	352 ms
2nd	50 ms	3 ms	3 ms
3rd	240 ms	45 ms	38 ms
4th	100 ms	318 ms	276 ms
5th	149 ms	10 ms	10 ms
6th	3,184 ms	1,186 ms	1,011 ms
7th	306 ms	32 ms	31 ms
8th	228 ms	45 ms	23 ms
TOTAL	4,544 ms	2,001 ms	1,744 ms

Table 8. Average runtime performance with internal repetition (DHE_RSA_AES128-CBC_SHA512).

STEP	Client (Sensor)	Server (Fog)	Server (Cloud)
1st	2 ms	4 ms	3 ms
2nd	5 ms	1 ms	1 ms
3rd	4,011 ms	1 ms	1 ms
4th	227 ms	230 ms	130 ms
5th	90 ms	2 ms	2 ms
6th	412 ms	6 ms	6 ms
7th	103 ms	17 ms	10 ms
8th	41 ms	1 ms	1 ms
TOTAL	4,891 ms	262 ms	154 ms

Table 9. Average runtime performance with internal repetition (ECDHE_ECDSA_AES128-CBC_SHA512).

STEP	Client (Sensor)	Server (Fog)	Server (Cloud)
1st	1 ms	17 ms	16 ms
2nd	2 ms	1 ms	1 ms
3rd	30 ms	8 ms	4 ms
4th	34 ms	20 ms	7 ms
5th	17 ms	4 ms	4 ms
6th	91 ms	55 ms	16 ms
7th	97 ms	20 ms	16 ms
8th	14 ms	3 ms	1 ms
TOTAL	286 ms	128 ms	65 ms
Table 6 exhibits the average time performance of 25 runs with external repetition results when evaluating the protocol in the environment of Fig. 6. It was tested in the client environment with a fog node and then in the client environment with a cloud node. In this first test of these two environments, the cipher string DHE_RSA_AES128-CBC_SHA512 was configured in the server configuration. During all tests, an average of 25 executions was maintained with external repetitions of the code for each environment, resulting in an average value of processing/execution time, which is shown in Table 6. It should also be clarified that step 3 on the client was when RSA asymmetric keys were generated, thus having great variation in time. The total execution time obtained when the client node interacts with fog node is 10,039 ms (7,904 ms added with 2,135 ms). When the client node interacts with the cloud node, the result is 9876 ms (7,904 ms added with 1,972 ms).

Table 7 shows the protocol execution time in a client environment with a fog node and a client environment with a cloud node. For this evaluation, the cipher string ECDHE_ECDSA_AES128-CBC_SHA512 was used to configure the server in both environments. Keeping the average of 25 executions with external repetitions of the code for each environment, an average value of processing/execution time resulted in what is shown in Table 7. The total execution time obtained when the client node interacts with fog node is 6545 ms (4544 ms added with 2001 ms). When the client node interacts with the cloud node, the result is 6288 ms (4544 ms added with 1744 ms).

As mentioned earlier, two forms of executions were tested, one with external repetitions, through execution by scripts, and the internal repetition which uses the Java code itself. The case of internal repetitions in the code itself is presented below, considering, in the same way as in previous tests, the evaluation of the protocol in a client environment with a fog node and a client environment with a cloud node. The cipher string DHE_RSA_AES128-CBC_SHA512 was configured on the server, maintaining an average of 25 executions with internal code repetition for each environment. It resulted in an average value of processing/execution time, evidenced in Table 8. The total execution time obtained when the client node interacts with fog node is 5153 ms (4891 ms plus 262 ms). When the client node interacts with the cloud node, the result is 5045 ms (4891 ms plus 154 ms).

Table 9 shows the protocol execution time in a client environment with a fog node and a client environment with a cloud node, in which the cipher string ECDHE_ECDSA_AES128-CBC_SHA512 was configured on the server. With an average of 25 executions with internal code repetition for each environment, the average values of processing/execution time are shown in Table 9. The total execution time obtained when the client node interacts with fog node is 414 ms (286 ms added to 128 ms). When the client node interacts with the cloud node, the result is 351 ms (286 ms plus 65 ms).

Table 10 presents a comparison between the present work and previous works that have some information on real runtime.


Table 10. Real runtime metrics.

Work	REF	Conf.	time (ms)
Sethia et al. (2018)	Sethia et al. (2018)	XOR	313.87 ms
Zhou et al. (2019)	Zhou et al. (2019)	XOR	563.3 ms
Imine et al. (2018)	Imine et al. (2018)	RSA	10.487 ms
Loffi et al. (2019)	Loffi et al. (2019)	RSA	24.03 ms
Wazid et al. (2019)	Wazid et al. (2019)	ECC	54.124 ms
Schmitt et al. (2017)	Schmitt et al. (2017)	RSA	5165 ms
ECC	1614 ms
Our work	this	RSA	5153 ms
ECC	414 ms
It should be noted that the works are shown in Table 10 are based on real applications, except the article by author Wazid et al. (2019) who performed the simulation with 54.124 ms of execution. As can be seen in Table 1, the authors Sethia, Gupta, and Saran (Sethia et al., 2018) and Zhou et al. (2019) did not use any type of authentication keys (RSA or ECC). However, they presented an implementation using the C++ language. On the other hand, the authors’ Imine et al. (2018) and Loffi et al. (2019) used implementations with RSA keys specified in the C++ language, which had runtimes of 10.487 ms and 24.03 ms, respectively.

Schmitt et al. (2017) describes a prototype of two-way authentication for IoT and uses DTLS with RSA and ECC. However, their work is not included in the study presented in Section 3 (Springer database was not included), but we will consider this comparison because its implementation method is comparable to ours and use RSA and ECC. Therefore, considering the internal execution between the Sensor node and Fog node, we can see in Table 10 that the present work has an execution time of 5153 ms and 414 ms for RSA and ECC keys, respectively. The work of Schmitt et al. (2017) has 5165 ms and 1614 ms for RSA and ECC, respectively. So, our work presents faster execution times.

6.7. Performance in energy consumption
As IoT devices have reduced memory, processing, and battery capacity, it is essential to be aware of the energy consumption that a system produces, especially when it involves the execution of cryptographic functions. Thus, this section presents the average energy consumption that the developed code produced.

In this work, we sought to present the real consumption using the Raspberry Pi, based on the tests performed on Bekaroo and Santokhee (2016) that used the Raspberry Pi 2 B and a wattmeter.

The consumption tests were performed only on the Raspberry Pi 3 B+ device since the focus of the analysis was the IoT device. So, the Raspberry Pi equipment was used as a client and later as a server. The average was performed by analyzing the consumption for 1 min with the repetition of the action.

Before performing the first test, it was necessary to present the device's consumption without executing the proposed code. The device was accessed via SSH without Wi-Fi and HDMI output. Therefore, as shown in Table 11 in these standby configurations, there was an average of 1.9 Watts.


Table 11. Comparison of estimated energy consumption.

Configuration of Raspberry Pi 3 B+	Power (W)	Current (A)
Stand by	1.90	0.026
Execution with RSA	2.83	0.035
Execution with ECC	2.36	0.033
In the first configuration, the Raspberry Pi device's consumption was measured with the configuration of the string DHE_RSA_AES128-CBC_SHA512 with an external and internal loop in the code, for evaluation by the client, followed by the server. These consumptions were similar; consequently, they will be presented together. We were considering that the consumption without code execution is 1.9 Watts. Thus, it can be calculated that the code's execution developed spent 0.93 Watts (2.83 Watts minus 1.9 Watts).

In the second configuration, consumption tests for the algorithm were also performed using the string ECDHE_ECDSA_AES128-CBC_SHA512. According to the analysis carried out with the configuration, for both the client and the server, there was an average consumption of 0.46 Watts (2.36 Watts minus 1.9 Watts) for executing the code.

Table 12 presents a comparison between our work and previous works that present some information on energy consumption. The values of Table 11, Table 10 can be used to calculate the value of energy consumption, multiplying Power (Table 11) with time (Table 10) according to Function 3.


Table 12. Estimated energy consumption per interaction.

Work	REF	Key	Energy
Alshahrani and Traore (2019)	Alshahrani and Traore (2019)	XOR	0.109 mJ
Shah and Venkatesan (2018)	Shah and Venkatesan (2018)	XOR	646.75 μJ
Zhou et al. (2019)	Zhou et al. (2019)	XOR	310.9 mW
Schmitt et al. (2017)	Schmitt et al. (2017)	RSA	619.5 mJ
ECC	193.6 mJ
Our work	this	RSA	4792.29 mJ
ECC	191.62 mJ
In Table 12, whenever possible, there was a conversion to mJ. It is important to note that the vast majority of previous works use XOR methods. Therefore, no work listed in Section 3 uses the ECC and RSA keys and presents energy consumption measures. However, the work of Schmitt et al. (2017) presented the consumption for RSA keys of 619.5 mJ and ECC keys 193.6 mJ for the whole handshake. On the other hand, using the techniques presented in Bekaroo and Santokhee (2016), Function 3 and the times shown in Table 10, our work consumed 4792.29 mJ and 191.62 mJ for the RSA and ECC keys, respectively.(3)

In general, comparing our work with Schmitt et al. (2017) present in Table 12, it can be seen that our work performed the experiment in a real way and achieved a better consumption about the use of elliptic curves.

7. Conclusion and future work
This study presented an evolution of the previous research carried out and described in Loffi et al. (2019). The findings in Loffi et al. (2019) described how a mutual authentication strategy with integrity had been proposed in conjunction with cryptographic methods for memory-constrained devices for the context of IoT in fog environments.

In this study, a multi-factor mutual authentication protocol was specified using an adjustable response time factor (ttr) applying to Fog or Cloud. The development of the Java language protocol and tests with RSA keys and elliptical curves were carried out. We adapted the use of cryptographic strings to be used by the end user. The threats available in the method were verified, and we presented the informal and formal security assessment using the ProVerif tool. Finally, we estimate the cost of computation, communication, execution of the protocol, and analyzed the complexity of the algorithm and presented the energy consumption.

Future works proposed include the improvement in the algorithm and the order of complexity of this work; the analysis of other studies that perform handshake on mutual authentication protocols in IoT environments; and the use of other cryptographic algorithms.