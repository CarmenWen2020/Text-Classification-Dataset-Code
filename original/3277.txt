Recently, blockchain adoption in prosumer-side energy trading has been actively studied. However, most of the conventional frameworks permanently store all transactions which increases blockchain management cost and reduces the user privacy. Additionally, most of the existing solutions focus on facilitating energy trading and negotiation, while ignoring two critical issues: data acquisition and contract execution. The former refers to the process of collecting power generation/consumption information from on-site energy resources which is required to scale. The latter refers to the process of adjusting controllable loads’ operation in real-time. In this paper, we propose a removable blockchain architecture that introduces a Temporary Chain (TC) where transactions can be stored for a particular period of time. The architecture enables an energy manager node to effectively collect data for facilitating real-time load control. TC reduces the volume of transactions stored in blockchain which increases scalability, throughput, and privacy of the users and reduces latency. We present two approaches to implement TC which are: i) blackboard where a central authority stores temporary transactions, and ii) removable ledger. We introduce a lightweight mode to transfer data. The implementation results show that the proposed framework reduces blockchain storage size and delay and increases throughput.

Keywords
Blockchain
Energy trading
Load control

1. Introduction
Modern smart grids are characterized by the wide deployment of metering and sensing infrastructure and the prevalence of distributed Renewable Energy Sources (RES). These advances transform the energy entities in the demand side from pure energy consumers to energy prosumers (producers and consumers), capable of both generating and consuming energy and establishing two-way communication (Jacobs, 2016). This transformation opens a yet unexplored opportunity for trading energy in the distribution network level, directly among prosumers and other pure consumers. Facilitating such prosumer-side energy trading has several benefits, including a lower dependency on the main grid, fostering demand-side economics, enhancing energy efficiency in distribution systems, and achieving overall cost savings and improving profitability for demand side energy entities.

1.1. Motivation
Prosumer-side energy trading has been actively studied in recent years (Luo et al., 2016). A prosumer may consist of mulitple energy generation/consumption resources, e.g., a smart home. Each prosumer is equipped with an Energy Manager Node (EMN) that manages the load/generation of the underlying resources. Unlike the grid-level wholesale power market, there are a large number of prosumers in a power distribution system. Centrally managing the energy trading and settlement processes would lead to significant computation and communication overheads for the utility. Further, prosumer-side energy trading usually involves prosumers’ private data (e.g., smart meter data and trading prices). Centrally collecting and managing such large volumes of sensitive data is a non-trivial issue for the utility, as it involves security and privacy risks. Two main strategies to facilitate energy trading of prosumers are: i) to establish centralized marketplaces to collect the bids of the participating prosumers and determine the energy trading clearing price and amount (Nunna and Srinivasan, 2017; Ghorani et al., 2018), and ii) to use peer-to-peer negotiation or optimization mechanisms (Morstyn and McCulloch, 2018; Luo et al., 2016) to enable the prosumers to achieve energy trading agreements without a centralized market regulator.

In recent years, blockchain (Dorri et al., 2019a), a decentralized ledger technology, has been introduced as a framework to support prosumer-side energy trading activities (Aitzhan and Svetinovic, 2016; Dorri et al., 2018; Li et al., 2017). Blockchain can provide a decentralized solution to facilitate energy trading at the edge of the grid without central management of the utility. This would make the system highly scalable and compatible with modern power distribution systems that host a large number of prosumers. The immutable nature of blockchain can also prevent tampering with the prosumer's sensitive data. The decentralized and trustable nature of blockchain is well-suited to the operation of geographically dispersed prosumers for supporting autonomous interactions in modern power distribution networks. Conventional blockchains consist of two layers which are peer-to-peer layer and blockchain layer. In Dorri et al. (2018) the authors propose a secure and private blockchain-based framework for energy trading. In Garg et al. (2019) the authors propose a blockchain-based solution to facilitate trade of energy for electric vehicles. Power ledger (Power Ledger) has introduced a blockchain-based distributed framework that enables the households with renewable sources to trade their surplus energy with their neighbors. A prototype of their framework is operational in Perth, Australia.

Despite promising benefits of blockchain, the existing frameworks (Power Ledger; Garg et al., 2019; Dorri et al., 2018; Aitzhan and Svetinovic, 2016) suffer from a number of limitations. We study these limitations in two levels:

1.1.1. Blockchain level
where we focus on the challenges associated with the blockchain architecture. First, most of the state-of-the-art blockchains impose significant requirements on computational resources and have limited scalability. Additionally, conventional blockchain-based energy trading frameworks permanently store all transactions. Thus, the blockchain database size increases perpetually which in turn increases the storage requirements and network bandwidth overheads and thus the management costs. Most of the existing blockchains suffer from limited throughput, i.e., the total number of transactions that can be stored in the blockchain per second, which limits their applicability for large scale networks such as smart grids. Another side-effect is the increased latency experienced by the end users to store transactions. Second, the existing blockchains create a permanent public history of interactions of participants. Studies have demonstrated that malicious nodes can deanonymize users by analyzing and classifying transactions in the blockchain (Dorri et al., 2019b, 2019c) which in turn endangers user privacy.

Finally, an EMN may impose a high load on the network, e.g., collect data from the underlying energy resources every minute. Transferring such large volume of data demands significant bandwidth from the energy resources and may not be scalable in smart grid with millions of devices.

While this paper studies the outlined challenges in an energy-centric scenario, these challenges are common in any value exchange marketplace scenario.

1.1.2. Energy management level
where we focus on managing the user energy demand/load. The existing research in prosumer side energy trading mainly focuses on the energy amount and price negotiation and contract settlement issues of prosumer-side energy trading (Aitzhan and Svetinovic, 2016; Dorri et al., 2018; Li et al., 2017; Luo et al., 2016; Nunna and Srinivasan, 2017), while seldom considering all the stages involved in energy trading which include ex-ante data acquisition (i.e., data collected to forecast energy consumption/generation) and real-time energy balance. In ex-ante data acquisition, the EMN of the prosumer collects the power consumption/generation data of the on-site energy resources in particular time-intervals, e.g., 1 min basis. Real-time energy balance requires the prosumer to effectively execute a previously signed energy trading contract. As Diego Dal Canto, an innovation manager with the multi-national utility Enel, states (Peck and Wagman, 2017): “What about forecasting of consumption and generation? If you want to offer 1 kW-hour, tomorrow at five, and you offer that and someone buys, you have to actually deliver”. However, the persistence of data and lack of scalability limits the ability of the conventional blockchains to deliver the outlined functionalities for energy trading. Additionally, most devices in smart grid have limited resources and thus generating such huge volume of transactions may be beyond their capabilities.

1.2. Our contribution
This paper proposes a multi-layer lightweight blockchain architecture to overcome the above limitations in both levels and support efficient prosumer-side energy trading activities through the following innovative mechanisms:

(1)
We propose a Temporary Chain (TC) that allows the users to achieve temporary immutability of transactions by storing them for a particular period of time. By assigning an expiry time to each transaction stored in TC and recording the hash of TC in the block headers stored by full nodes (i.e., the nodes that store new blocks to the blockchain), the proposed system can ensure the consistency of TC. TC reduces the need to store transactions in the main blockchain which in turn reduces the associated overheads and latency for energy trading, and increases user privacy as fewer transactions are publicly stored in blockchain.

(2)
Based on (1), we propose two approaches for implementing the TC: a) a centralized approach that uses a blackboard (BB) that is a central database where only selected nodes have write permission, and b) a distributed approach that uses a Removable Ledger (RL) where all participating prosumers have read and write permission. BB is maintained centrally by a trusted authority (e.g., the distribution system operator) while RL is maintained by all prosumers. The former approach is well-suited for current smart grid deployments which rely on a Trusted Third Party (TTP) (as outlined earlier) which can host the BB, while RL is paradigm shift towards a more decentralized architecture;

(3)
The framework incorporates two modes for ex-ante data acquisition which are: i) normal mode: where the devices generate transactions using asymmetric encryption methods, and ii) lightweight mode: where the devices rely on the hash function and a set of known parameters to exchange data while protecting data integrity.

(4)
Compared to the existing works that only focus on the energy trading negotiation and contract settlement issues, the proposed system designs a series of communication protocols to integrate the three stages involved in the prosumer-side energy trading into a comprehensive framework: a) ex-ante data acquisition; b) ex-ante energy trading negotiation; and c) real-time load control for contract execution. We study the impact of real-time load control through a case study.

While we present our framework in the context of distributed energy trading, the introduced blockchain architecture is generic and can be generalized to other application domains. The rest of the paper is organized as follows. In Section 2 we review the literature on the existing works in blockchain-based energy management. Section 3 outlines the details of the proposed multi-layer architecture. Section 4 studies prosumer side energy trading based on the proposed architecture. Section 5 outlines a case study. We study the performance and security of the proposed framework in Section 6. Finally, Section 7 concludes the paper.

2. Literature review
This section gives an overview of the state-of-the-art blockchain-based energy trading frameworks. First, we discuss the existing algorithms that we used in this paper in Section 2.1. Next, we study the existing prosumer side energy trading frameworks in Section 2.2. Section 2.3 outlines the existing blockchain-based solutions for prosumer side energy trading.

2.1. Preliminaries
In this section, we discuss the details of the algorithms that are later used in our architecture. Conventional blockchains broadcast all transactions in the network. In energy trading, the prosumers may require to exchange multiple transactions to negotiate over the energy price or amount which potentially increases packet overhead. Dorri et al. (2018) proposes an Anonymous Routing Backbone (ARB) that enables blockchain participants to route transactions based on Public Key (PK) of the destination. A group of resource available nodes, e.g., grid controller, form a backbone network where they route transactions to a particular destination based on Routing Bytes (RB) which are essentially the X most significant bytes of the PK of the destination. Each backbone node receives transactions with a particular RB and transfer those to the users. The users must connect to the RB corresponding to their PK to receive transactions. The backbone nodes initialize a Distributed Hash Table (DHT), which identifies the backbone node corresponding to each value of RB. The users send transaction to the closest backbone node who then routes transaction to the backbone node corresponding to the RB using conventional routing algorithms such as OSPF [RFC2328].

Another fundamental algorithm used in our framework is Certificate of Existence (CoE) (Dorri et al., 2018). CoE enables blockchain participants to anonymously verify if a transaction is generated by a genuine smart meter. Conventional methods in the literature assume that either the PK of a particular meter is known to all participants or a Central Authority (CA) can verify that a PK belongs to a genuine smart meter. However, these methods suffer from centralization and lack of privacy as participants or CA can track the transactions generated by a smart meter and thus compromise the user privacy. CoE enables the participants to verify that transactions are signed by a genuine meter while protecting the privacy of the smart meter owner. The manufacturer of each meter creates a private/public key pair for each smart meter (known as M-PK-/M-PK+ respectively) and serves as the CA for M-PK+s. Once deployed, each meter generates a number of public/private keys and constructs a Merkle tree by recursively hashing PKs. The meter then sends the root of the tree to another randomly chosen meter (known as verifier) to be signed that is used as the CoE.

Upon receipt of the request, the verifier validates M-PK+ using CA of the meter manufacturer. If validated, the verifier returns the signed root of the Merkle tree to the requester. The smart meter signs the future transactions with the private key corresponding to a PK that exists in the Merkle tree. The meter populates the leaves of the Merkle tree necessary to prove the existence of the PK in the transaction which protects against malicious nodes that may pretend to be the owner of the CoE. In summary, CoE enables the verifier smart meter to vouch for the authenticity of the meter generating the transaction without revealing the generator's identity. Details of CoE can be found in Dorri et al. (2018).

In Dorri et al. (2018) we proposed the concept of atomic meta-transactions to reduce reliance on TTP. An atomic meta-transaction is considered valid only if it is coupled with another transaction in a particular time-period. Once both atomic meta-transactions are generated, a smart contract is triggered that pays the energy price to the energy producer. In this paper, we modify the atomic meta-transactions and eliminate the reliance on a smart contract which in turn further reduces the processing and packet overhead of the blockchain and the cost incurred on the user.

2.2. Prosumer side energy trading
Many researches have investigated the mechanisms of facilitating prosumer-side energy trading. These techniques can be generally categorized into two classes: auction-based markets (Nunna and Srinivasan, 2017; Ghorani et al., 2018) and Peer-to-Peer (P2P) trading mechanisms (Morstyn and McCulloch, 2018; Luo et al., 2016).

Auction-based markets are structurally similar to the grid-level wholesale energy market, representing centralized marketplaces which collect the energy selling/purchase bids from the participants and determine the market clearing price for energy trading based on the demand-supply relationship. The authors in Nunna and Srinivasan (2017) propose an auction-based electricity market to enable microgrids to trade surplus local energy resources with each other. In Ghorani et al. (2018), the authors design a bidding strategy for transactive agents to participant in a local energy market, aiming at maximizing the profit of the agent by considering the market risk. The authors in Lian et al. (2018) evaluate the performance of the double-auction market mechanism in transactive energy systems which identified several strengths and limitations when applying this mechanism to support prosumers’ energy trading.

In P2P based trading mechanisms, prosumers autonomously negotiate with each other regarding the price and amount of the traded energy without a centralized marketplace. The authors in Morstyn and McCulloch (2018) present a P2P energy market architecture, which comprehensively considers the impact of prosumer's energy trading behaviors on network power losses, battery energy storage systems' depreciation, and the environment. The authors in Luo et al. (2016) design a P2P electricity trading system for microgrids based on multi-agent architecture. In the system, the agents in multiple microgrids form different coalitions. In each coalition, the participated microgrid agents negotiate energy price and amount through a set of agent-coalition algorithms. After an energy trading agreement is achieved, the seller and buyer's microgrid performs an optimal scheduling to allocate energy production and consumption among its on-site energy resources.

2.3. Applications of blockchain in prosumer side energy trading
Blockchain applications in energy trading have received a tremendous attention from both academia and industry. The authors in Jindal et al. (2019) propose SURVIVOR: a blockchain-based edge-as-a-service framework for energy trading. SURVIVOR employs edge computing to process energy trading decisions closer to the end devices which in turn reduces computational and packet overhead in blockchain. Blockchain is employed to secure the communications and establish trust among the participants.

The authors in Garg et al. (2019) propose a blockchain-based framework to trade energy in vehicle-to-grid (V2G) networks. A central controller initializes the system and manages the requests between electric vehicles and charging stations. The authentication of the vehicles is performed centrally by the controller. After trading the energy, the corresponding transaction is stored in the blockchain.

The authors in Dang et al. (2019) propose a new market structure for demand side load management in big industrial energy users. Each big industrial user collects the energy demand/load information from devices installed in the site. The collected information are aggregated to find the total amount of energy that the user must buy or sell. The user can also directly control the load to reduce the cost of energy.

The authors in Aitzhan and Svetinovic (2016) develop a decentralized energy trading platform called ‘PriWatt’, which relies on blockchain as its backbone for facilitating residential buildings to trade surplus solar power with each other. In PriWatt, an energy trading event can be described by a transaction that consists of an instance of changing ownership of tokens through digital signing portion of data and broadcasting it to the network.

The authors in Li et al. (2017) design a consortium blockchain system to support P2P energy trading activities of different kinds energy entities in the Industrial Internet of Things (IIoT) environment. The blockchain system integrates a credit-based payment scheme to support fast and frequent energy trading. The scheme sets up a credit bank for each authorized energy aggregator; the credit bank provides loans to energy nodes based on their credit values and performs payment directly from shared wallets. In this way, the communication and consensus costs incurred by transferring energy coins from different wallet addresses can be reduced.

The authors in Gai et al. (2019) design a privacy-preserving consortium blockchain, which uses a one-to-multiple mapping method to distribute the energy trading tokens of a participant into multiple accounts, so as to prevent energy trading trends from being revealed.

The most representative blockchain-based solution in industry is the Brooklyn Microgrid (BMG) project launched by LO3 Energy (Mengelkamp et al., 2018), which has established a local energy market in Brooklyn, New York, USA. The participants are residents located across three power distribution networks in the BMG's region. Through BMG, a resident can sell any excess solar power produced by their rooftop solar panel to the neighbors who need power. The BMG system includes two sub-systems: a virtual community energy market platform and a physical microgrid. The former serves as the cyber infrastructure of BMG; its core component is a private blockchain system using the Tendermint protocol. The physical microgrid is an electrical power grid that complements the existing grid and provides backup assistance to present power outages.

As outlined in Section 1, the existing blockchain-based solutions store all transactions in the blockchain which in turn increases the blockchain management cost, reduces scalability, and reduces the user privacy as large volume of data about the user is publicly available. The existing solutions only support energy trading among the users at the granularity of a day in advance and neglect real-time energy management which empowers the grid operator to balance the load in real-time and thus prevents energy shortage or surplus. The existing solutions do not consider the limited resources available in the smart grid devices that limits them from generating transactions in short time intervals, e.g., a minute. Most of the existing works (Mengelkamp et al., 2018; Li et al., 2017; Dang et al., 2019) demand the presence of a TTP to oversee the energy trading to ensure both side of the trade commit to their obligations which increases the reliance on centralized infrastructure and potentially compromises user privacy.

In our architecture we propose a temporary chain that empowers the participating nodes to temporarily store transactions which reduces the blockchain overheads. Our architecture introduces real-time energy balance to ensure stable operation of the grid. We introduce lightweight data transmission mode that significantly reduces the resources consumed by the smart grid devices and thus facilitates data transmission in short time intervals.

3. Multi-layer blockchain architecture
In this section, we outline the details of the proposed multi-layer blockchain for energy trading between prosumers. Conventional blockchain-based prosumer-side energy trading frameworks usually adopt a two-layer architecture which comprises of a peer-to-peer network and a blockchain layer. Utilizing this architecture in the smart grid context reduces the scalability, increases the blockchain management cost, and reduces the user privacy (see blockchain-level challenges outlined in Section 1.1). We propose a three-layer blockchain architecture that, as shown in Fig. 1, comprises of three logical layers namely peer-to-peer, Temporary Chain (TC), and main chain layers. Main chain is essentially the blockchain layer that acts as the permanent data repository while TC is a middle layer that serves as a temporary immutable database and enables the users to store transactions for a particular time period.

Fig. 1
Download : Download high-res image (372KB)
Download : Download full-size image
Fig. 1. An overview of the proposed architecture.

The details of the proposed blockchain architecture is introduced below, while the nomenclature used in this study is given in Table 1, Table 2. Each index, say index i, refers to the varying index, if refers to the last member in a set, and I refers to the set of indexes.


Table 1. Summary of the nomenclature used in this paper.

Notion	Definition
PNi	Participating nodes in the blockchain
EMN	Energy Manager Node
ER	Energy Resources
TC	Temporary Chain
MC	Main Chain
TC.ti	transaction that is stored in TC
MC.ti	transaction that is stored in MC
tx a	transaction of type x generated by node a
expti	the expiry time of ti
bm	blackboard manager
b{i,id}	ID of the ith block
bRL	a block in RL
Nfull	nodes that store new blocks in the MC
Δt	Time interval for energy resources to send their data to EMN
tID	ID of a node in Sec 4.1.2
tpat	pattern employed by an EMN in Sec 4.1.2
tsv	secret value known only to a user and EMN in Sec 4.1.2
δ	The time period when two atomic transaction must
be generated
adv	adversary node

Table 2. Summary of the indexes used in this paper.

Index	Definition
i	the index of nodes in the public blockchain
j	the index of nodes in a private blockchain
m	the index of adversary nodes
3.1. Peer-to-peer layer
The peer-to-peer layer is an overlay network interconnecting PNi and enabling these nodes to broadcast transactions to each other. PNi can be the prosumers, power utility, and power distribution managers. Assume A & B ∈ PN. Depending on the scale of the grid, the prosumers may consist of multiple resources (ER) that produce/consume energy, e.g., a smart building, or a virtual power plant. EMN manages the load of ERs in each prosumer. A can communicate with B by generating and broadcasting a transaction tA. The structure of ti depends on the application and is discussed in Section 4.

3.2. Temporary chain (TC)
TC functions as an intermediate layer between peer-to-peer and blockchain layers to increase the scalability of the proposed architecture and privacy of the participants. TC stores particular ti for a predefined period of time expti to achieve temporary immutability. TC inherits trust and consensus from the main blockchain as detailed in the rest of this section. As shown in Fig. 1, PNi may skip TC and store ti in the main chain. In Section 4 we will further elaborate on the type of ti that are stored in TC.

To ensure immutability, the hash of the transactions in TC is periodically stored in the main chain (detailed in the next paragraphs). Thus, TC introduces temporary immutability which in turn reduces the blockchain database size and enhances the user privacy as not all transactions are available post-ante in the publicly accessible main chain. TC reduces the number of transactions that need to be permanently stored in the blockchain which in turn impacts the resources consumed by Nfull as fewer blocks are stored in the main chain (see Section 6 for detailed discussion). On the flip side, TC incurs a small overhead that is the time taken to remove expired transactions from the database. Additionally, the hash of TC is stored as a new header field in blocks in the main chain which imposes a small overhead in the memory footprint of the main chain database.

In designing TC, we considered the trade-off between centralization and distribution. We propose two types of databases namely Blackboard (BB) database and Removable Ledger (RL). The former is a central database managed by a trusted authority, while the latter is a removable chain of blocks that is distributed among all participants. In the rest of this section, we describe the details of these methods.

3.2.1. Blackboard (BB)
Blackboard (BB) is a database where PNi have different read/write permissions. A subset of participating nodes bm ∈ PN have write permission on BB and other nodes have read permission only. Similar to conventional replicated databases, bm employ replication methods (Wiesmann et al., 2000) to maintain a consistent view of the data stored in BB.

Energy trading activities in smart grid environments unavoidably involve reliance on trusted authorities, e.g., system operator, market regulator, and power companies. The trusted authorities potentially can function as bm given that they hold responsibility of overseeing the grid operations and are trusted by the users. Note that the potential malicious activities of bm can be detected due to the distributed nature of the blockchain as outlined in Section 6.1.

It is critical for bm to distinguish temporary ti that must be stored in TC (represented as TC.ti) from those that are stored in the main chain (represented as MC.ti). Thus, we update the structure of ti by adding a tuple (temp, expiry_time) where temp is a flag indicating if ti is a temporary transaction and expiry_time indicates the duration in which a temporary transaction must be stored in TC.

bm monitors the received ti to identify temporary transactions. ti ∈ TC if ti.temp = true. If this condition is met, bm stores TC.ti in BB which is readable to all PNi. ti remains stored in BB till time.now() > ti.timestamp + ti.expiry_time. It is worth noting that TC.ti is ignored by the validators in the main chain layer which is discussed later in this section. bm keeps track of the expiry time of the stored TC.ti and removes them when they are expired, i.e., time.now() > ti.timestamp + ti.expiry_time.

3.2.2. Removable ledger (RL)
RL is a database shared across PNi where TC.ti are grouped in the form of blocks bRL by full nodes Nfull, i.e., the nodes that store ti into MC. Similar to the blocks stored in MC, bRL are broadcast to the network and Nfull maintain a copy of RL along with the copy of MC. RL is implemented in the same network as MC and thus the participants and transaction flow are the same. Conceptually, RL is similar to MC with the following differences:

●
Each Nfull generates bRL from TC.ti that are not yet stored in RL and appends this block to RL. The structure of a block in RL is as follows: < B_ID, P_B_ID, PK, Sign, Trans > where B_ID is the identifier of the block, i.e., the hash of the block content, P_B_ID is the hash of the previous block in RL which creates a chain. The next two fields are the PK and signature of Nfull that generates the block. The transactions are recorded in Trans field. RL relies on the same consensus algorithm that is run in the main chain for storing new blocks. Thus, each block in RL is linked to a block in MC. When a Nfull generates a block in the main chain b, it also generates a new bRL. The hash of bRL is stored in the header of the blocks in the main chain which ensures consistent view of RL. As the frequency with which a new block is generated in the main chain and the volume of transactions generated in RL varies, bRL can be of any particular size.

●
RL enables PNi to remove their TC.ti without breaking the consistency of the ledger by employing the method proposed in Dorri et al. (2019b). Each block in conventional blockchains consists of block header Bheader and block transactions Btrans. Biheader = (b{i, id}, b{i-1, id}, timestamp) where Biheader refers to the header of the ith block and b{i,id} and b{i-1,id} refers to the id of the ith and i-1st block respectively, which is the hash of the block content. b{i,id} = hash(bi-1, timestamp, t1, …, tn), where n is the total number of transactions in the block. Thus, if the content of ti is removed, the new biid will not match with the previous one and thus breaks the blockchain consistency.

In contrast, in RL brl{i, id} = hash(bi-1, timestamp, t1id, …, tnid) where tiid is the hash of the transaction content and ensures the integrity of ti (which is based on the idea of Dorri et al. (2019b)). ti can be removed while tiid remains stored to ensure the consistency of the RL. The transaction generator can prove the existence of its transaction by storing the transaction content locally and revealing it to the party that needs to verify the existence of the transaction. By comparing the hash of the transaction provided by the node with the hash stored in the blockchain, one can verify if the transaction previously has been stored in the blockchain. As the hash of the transaction is stored in the RL, PNi can verify that the transaction content is not modified and thus accept the received transaction.

●
Nfull stores brl{i,id} in bi that ensures the consistency of RL in the network.

Depending on the application, the network designers may chose to employ either BB or RL in TC. As outlined earlier, the presence of the TTP is unavoidable in the existing smart grids. BB supports the current grid TTP architecture while reducing the storage overhead on participating nodes, while RL supports future decentralized grid systems at a slightly higher storage cost. BB suits networks where there is trusted entity that can function as bm. Although BB leads to some degree of centralization, it incurs no storage overhead on Nfull as they are not required to store TC.ti, while in RL Nfull must store the database. Additionally, the querying time for TC.ti is lower as compared with RL where Nfull need to search the ledger to find TC.ti. However, BB relies on centralized TTP to store the data which potentially suffers from lack of privacy and centralization.

3.3. Main chain (MC) layer
MC layer is the main blockchain that connects all PNi and establishes a trusted network among them. Each PNi that participates in the MC is known by a Public Key (PKi+). To enhance their anonymity level, PNi may change their PKi+ per ti.

MC may encompass a number of private chains (prichains). ∀ prichains, PNj participantes in prichain, where j ⊂ I. prichains may be generated for different purposes which are latter discussed in Section 4. To ensure the integrity of the prichain, the hash of prichain is frequently stored in the form of a transaction in MC.

We employ a public blockchain as MC. Storing new blocks in the blockchain involves following a consensus algorithm which ensures security of the blockchain. The consensus algorithms employed in conventional blockchains, e.g., Proof of Work (POW) and Proof of Stake, consume significant resources, limits throughput, and incurs delay in storing transactions. To address the outlined challenges, we employ Distributed Time-based Consensus (DTC) (Dorri et al., 2019a) as the underlying consensus algorithm. Based on DTC, each validator is permitted to generate one block per a specific time period known as the consensus period. The latter is defined based on the load in the network which ensures the blockchain is self-scaling as the network throughput can be adjusted based on the load generated by PNi.

In blockchains all ti are broadcast to the network which enables distributed management of the blockchain. However, in many applications including smart grids, the users may need to directly communicate with each other, e.g., to negotiate the price of energy. If all these exchanges are manifested as transactions, a significant amount of broadcast overhead would be incurred. To address this challenge, MC supports direct communication of ti by employing the blockchain-based routing algorithm proposed in Dorri et al. (2018) (see discussion in Section 2).

In this section we introduced an optimized blockchain architecture that addresses the first two challenges associated with the existing blockchains as discussed in Section 1.1. Next, we discuss data dissemination methods along with real-time energy balance as outlined in the third blockchain-level challenge and the energy management level challenge in Section 1.1.

4. Multi-layer blockchain-based prosumer side energy trading
In this section, we discuss the details of the prosumer-side energy trading scheme using the framework outlined in Section 3. The proposed energy management framework consists of three main stages: i) data acquisition, where an energy manager node EMN ∈ PN gathers energy data of all on-site ER of the prosumers, and ii) energy negotiation where prosumers negotiate with each other and form pre-ante contracts. Each contract specifies the energy trading amount and price between the involved prosumers, and iii) real-time energy balance, where each prosumer performs real-time load control to execute the pre-ante contract, i.e., the actual power production and consumption matches with the contract as much as possible. The application of the proposed blockchain system in these scenarios is based on a premise that smart meters are tamper resistant. We propose to store most of the transactions involved in the outlined three main stages in the TC to reduce the associated overhead in managing blockchain and increase scalability which is discussed with greater details in the rest of this section.

4.1. Data acquisition
In this sub-section, we outline the process of enabling a prosumer's EMN to monitor its on-site energy demand edj and energy production epj. The proposed solution is a generic, scalable architecture that is applicable for prosumers with different scales. An EMN can be an agent for a prosumer with a limited number of connected ER (e.g., a single house); or it can be a prosumer managing a large number of geographically dispersed ER (e.g., a microgrid or a virtual power plant). The managed ER are required to send their data to the EMN at pre-specified time intervals Δt. Δt is normally set as short intervals, e.g., 1 min, to ensure proper services to ER. With large number of ER, transferring such large volume of data demands significant resources from each ER. Thus, we propose two modes that can be employed to transfer data which are discussed below.

4.1.1. Normal mode
In this mode, a prichain is established that is employed by ERj and EMN to exchange data. EMN authorizes ERj to join prichain and generate a genesis transaction for each ERj that allows them to exchange data. This prevents malicious nodes from exchanging data and thus manipulating the energy demand or load of the network. ERj share their data by generating a Data Transmission (DT) transaction that is structured as < T_ID, P_T_ID, data, PK, Sign > where T_ID is the identity of the transaction that is essentially the hash of the transaction and P_T_ID is the identity of the previous transaction of the same ERj that chains all transactions of ERj. data is the energy demand/load. Finally, ERj populates PKj+ and the corresponding signature in the last two fields.

To enhance the privacy of ERj, methods such as zero knowledge proof (Rackoff and Simon, 1991) can be employed that enable ERj to prove the knowledge of a particular data, that can be the private key or a challenge response, without revealing the actual data. This in turn enhances the anonymity of ERj. In case of employing such methods, the structure of the DT transactions is modified to < T_ID, data, anonymous_proof > where anonymous_proof is provided by ERj to prove knowledge of a particular data. The details of zero knowledge proof are beyond the scope of this paper and are discussed in Rackoff and Simon (1991).

4.1.2. Lightweight mode
As outlined earlier in this section, EMN may require data with a certain Δt from ERj. It is critical to ensure the integrity of the transmitted data, thus, in conventional methods the signed hash of the transmitted data is included in the message. The large volume of communicated data, increases the processing overhead on both ERj and EMN while mainly ERj have limited resources. Motivated by the outlined challenges, we propose lightweight mode that employs a hash-based verification mechanism to reduce the overheads associated with signing messages in the process of transferring edi and epi. As explored by many studies in the literature, such as (Trakadas et al., 2008), asymmetric encryption demands higher computational resources and thus energy as compared with hashing algorithms.

EMN manages a prichain where ERj are connected to share data. We propose a secret that enables ERj to exchange data reliably without relying on encryption. Unlike conventional blockchains where PK+ is employed as the identity of the nodes, in prichain each ERj employs an IDj which is a random string s selected by ERj where s = x1,x2, …, xnf, n is the size of the string and xn ∈ 0,1,2,..,9,a,b,c, …,z. During the bootstrapping, each ERj generates a tID, a pattern tpat, e.g., adding previous ID with a constant value, and a secret value tsv and shares with EMN. ERj encrypts these values by PK+EMN which protects against malicious nodes that may eavesdrop the communication to extract the exchanged values. EMN ensures that ∀a, b ∈ J|(IDa, pata, seca)≠(IDb, patb, secb). To enhance anonymity, ERj may change their ID in each t using a pattern patj. Conceptually, changing ID is similar to changing PK in conventional blockchains. The secret value is a secret only known to ERj, e.g., a password.

ERj shares its data by generating Lightweight Demand Load (LDL) transaction tjLDL = < ID, data, DLFlag, secret > , where ID is as discussed above. Data is the power reading. DLFlag is a flag that identifies if the value in data field is demand (DLFlag = 0) or load (DLFlag = 1). Recall that lightweight mode ensures integrity of the data by introducing a hash-based data integrity method which also protects against non-repudiation. The Secret field, represented as tsec, stores the hash of the data to ensure integrity. tsec = hash(secret value + nonce + data) where nonce, i.e., tnonce, is a one-time value used to prevent replay attack which conceptually is similar to the nonce employed in Ethereum transactions (Woodet al., 2014). data is the exchanged energy demand/load data which potentially protects against data modification (see discussion in Section 6.1). ERj broadcasts tjLDL in prichain.

When EMN receives tjLDL, it extracts tj.ID and locates < secretvalue, nonce, pattern > j. To verify data integrity, EMN checks if hash(secret value + nonce + data) = tsec. This protects against non-repudiation as the secret value is only known to ERj. If verified, tjLDL is accepted and EMN updates the corresponding nonce and ID as new.nonce = old.nonce + 1 and new.ID = old.ID + pattern.

During each Δt EMN collects all tjLDL of the corresponding ERs. Overall load prichainload and demand prichaindemand is calculated as follows:(1)
(2)

In each Δt EMN creates a Merkle tree Δt by recursively hashing ERj.sec. The signed root of the Merkle tree is then stored in MC. This provides a level of auditability where EMN can later prove the load/demand data provided by ERj. To do so, EMN must store ERj.sec locally. Storing only the root hash of the Merkle tree, in place of all received ERj.sec, reduces the processing overhead and memory requirement for managing the blockchain and thus increases scalability. Note that the demand/load data are only critical for EMN and ERj to prove the existence of their transactions which can be conducted using the root hash of the Merkle tree.

By employing the outlined methods, EMN collects edj and epj of ERj. EMN aggregates and process the received data to calculate the load/demand of energy for the future. In the next section, we discuss energy trading between PNi.

4.2. Energy trading negotiation
The EMN of a producer first generates an Energy Supply (ES) transaction (tES, step 1 in Fig. 2) that is structured as 
 

where timestamp represents when the transaction was generated and is used to identify when to remove a temporary transaction, supply is the total amount of energy the producer wishes to inject to the grid, price is the price of the energy, negotiation is a flag that indicates whether the energy price is negotiable. tES is employed by the energy producer to advertise its energy, thus we propose to store this transaction in TC and remove it from TC after Expirey_time. PK and Sign are the PK+ and the corresponding signature of the energy producer.

An energy consumer can explore TC to locate potential energy producers (step 2). The consumers may start a negotiation with the energy producer in case ES.negotiation = 1. To negotiate with the producer (step 3), the consumer generates an Energy Negotiation (EN) transaction (tEN) that is structured as 
 

where p and c represent energy producer and consumers respectively. The producer and consumer may negotiate till they both reach agreement over the trade conditions, i.e., energy price and amount, and sign tEN. tEN are stored in TC to reduce the blockchain overhead and increase scalability. To reduce the associated packet overhead during negotiation, we employ the routing protocol proposed in Dorri et al. (2018) that enables blockchain participants to exchange unicast messages over blockchain. A detailed discussion on the routing algorithm is proposed in Section 2.

Once the energy producer and consumer reach an agreement on trade conditions, the consumer generates a Trade Agreement (TA) transaction (tTA, step 4) that is part of an atomic meta-transaction (conceptually similar to (Dorri et al., 2018)) meaning that it only is considered as valid if (and only if) it is coupled with another transaction within a specified time period δ. If the other transaction is not generated by δ, tTA is discarded. tTA puts the money in the consumer account on hold as the money is not yet transferred to the producer account. When the other transaction involved in atomic meta-transaction is generated, the money is transferred to the producer account as outlined in details later in this section. δ ensures that if the energy producer does not commit to its obligations, the consumer money will be refunded after δ period of time. tTA is structured as 
 

where supply_ID is T_ID of the corresponding tES transaction, price and amount are the price and amount of energy that the consumer is willing to buy and are populated based on the agreed values in tEN. Expiry_time represents δ.

tTA is stored in TC for the period of δ. Once the energy consumer broadcasts tTA, the producer starts injecting energy to the grid. Once the total amount of injected energy reached the agreed amount identified in tTA, the smart meter of the producer generates an Energy Payment (EP), step 5 transaction (tEP). tEP is part of the atomic meta-transaction that must be coupled with a tTA to be considered as valid. tEP is structured as

< T_ID, timestamp, TA_ID, Amount, Sign, COE > where TA_ID corresponds to T_ID of the corresponding tTA. Amount is the amount of injected energy and sign is the signature of the smart meter. COE is the certificate of existence as discussed in Section 2 that ensures anonymity of the smart meter while enabling the participants to anonymously verify that the transaction is generated by a genuine smart meter.

When the participating nodes in the blockchain receive tEP, they retrieve the corresponding tTA to verify these transactions. The first step is to verify COE to ensure that the tEP is generated by a genuine smart meter as outlined earlier in Section 2. Next, they verify if the amount in tEP matches with the one in tTA. Once verified, both tTA and tEP transactions are stored in MC (step 6) and thus the energy price is paid to the producer. Nfull removes tTA form TC as it is permanently stored in the MC.

4.3. Real-time load control
Due to inevitable uncertainties in the prosumer operation environment (e.g., renewable power output, temperature, and power consumption due to people's behavior variations), the energy delivery reliability becomes an important issue. Some mechanisms are necessary to facilitate the prosumer to execute its ex-ante signed contract as precise as possible, which is less investigated in the literature.

In this paper, we propose to use the multi-layer blockchain to facilitate the internal real-time energy management of the prosumer. That is, the EMN node of each prosumer communicates with its internal ER to adjust their real-time power consumption or production, so as to make the prosumer's total net-power follow the ex-ante energy trading contract. The EMN and the prosumer would have signed a contract that allows EMN to shift the energy consumption/generation pattern of some devices in the prosumer site which can essentially be a smart contract stored in MC (step 0 in Fig. 3). For each prosumer, the internal load control process involves two steps which are summarized in Fig. 3 and illustrated in details below.

(1)
Load data collection: Based on the contract signed in step 0, EMN installs sensors in the prosumer site for monitoring site condition. Initially, EMN creates a genesis transaction for each sensor which contains a link to the transaction that contains ID of the contract transaction (1.1). The sensors collect and share particular data from the prosumer site depending on the sensor type, e.g., temperature and power consumption. The genesis transaction needs to be signed by both EMN and the prosumer to ensure the installed sensors are as defined in the contract (1.2). Once deployed, the sensors periodically send data to EMN as outlined in Section 4.1 (1.3).

(2)
Action determination and execution: Based on the load data collected from sensors, EMN determines the load control actions (2.1) using methods such as proposed in Ruiz et al. (2009). EMN then informs ERj of the identified action using a Load Control transaction tLC (2.2) that is structured as 
 

Fig. 3
Download : Download high-res image (134KB)
Download : Download full-size image
Fig. 3. Illustration of the transactions exchanged during real-time load control process.

where P_T_ID is the identifier of the previous transaction of the same prosumer. EMN initially generates a genesis transaction for each authorized prosumer. The prosumer chains all future transactions to the genesis transaction by storing the ID of their previous transaction in P_T_ID field of the new transactions. tLC is a multisig transaction and requires two signatures (out of two) to be considered as a valid transaction in the blockchain. The next four fields are the PK+ and signature of the transaction generator (G) and receiver (R). On receipt of tLC, the devices first verify the transaction by validating the signature with the corresponding PK+. Once verified, the devices perform the indicated action in the transaction (2.3).

The aforementioned steps enable EMN to manage the energy consumption/generation of the prosumers in real-time to prevent energy shortage or surplus in an area. The surplus energy in an area potentially increases the voltage and overload the transmission lines which in turn damages the physical transmission lines.

5. Case study
In this section, we study the performance of the proposed framework in controlling real-time energy production/consumption through a case study. Recall from Section 4.3 that the proposed framework introduces real-time load control to ensure the predicted energy consumption/generation amount matches with the actual value in real-time. We use SimHouse, a household energy consumption simulator, that is shown in Fig. 4 to simulate the daily appliance-level energy consumption profiles of residential prosumers. SimHouse is a household power load generator that uses an open architecture, allowing users to simulate different lifestyles and appliance energy consumption behaviors based on an underlying appliance power measurement database. As a case study, Fig. 5 shows the day-ahead desired energy use behaviors of a residential prosumer equipped with a rooftop PV solar panel. There are three kinds of energy resources managed by the prosumer: (1) base load, which is composed of critical appliances that are manually controlled by the occupant (e.g., TV and computer); (2) solar power output; and (3) controllable appliances whose operations can be automatically controlled by the prosumer's energy management system.

Fig. 4
Download : Download high-res image (490KB)
Download : Download full-size image
Fig. 4. SimHouse simulation environment.

Fig. 5
Download : Download high-res image (456KB)
Download : Download full-size image
Fig. 5. One-day energy production and consumption schedules of the prosumer.

The configurations of the controllable appliances are given in Table 3. The controllability is classified into two types:


Table 3. Setting of controllable appliances.

Name	Controllability	AOTR	Desired Operation Starting Time	Operation Duration	Rated Power	Interruptible	Adjustable Power Range	MONLT	MOFFLT
Amplifier	Type 2	–	4:00pm	70 min	0.4 kW	–	[0.3 kW, 0.5 kW]	–	–
Washing Machine	Type 1	[8am, 11:15am]	9:10am	70 min	0.7 kW	Yes	–	15 min	15 min
Dryer	Type 1	[9:50am, 5:25pm]	10:50am	85 min	1.1 kW	Yes	–	10 min	5 min
Heater 1	Type 2	–	8:50am	65 min	0.6 kW	–	[0.4 kW, 1.0 kW]	–	–
Heater 2	Type 2	–	10:05pm	110mins	0.6 kW	–	[0.4 kW, 1.0 kW]	–	–
Light 1	Type 2	–	6:00pm	135 min	0.2 kW	–	[0.05 kW, 0.4 kW]	–	–
Light 2	Type 2	–	7:40pm	215 min	0.28 kW	–	[0.08 kW, 0.45 kW]	–	–
Light 3	Type 2	–	6:50am	55mins	0.15 kW	–	[0.05 kW, 0.25 kW]	–	–
Oven	Type 1	[11:30am, 2pm]	12:05pm	50mins	1.2 kW	No	–	–	–
AOTR = “Allowable Operation Time Range”; MONLT = “Minimum Online Time”; MOFFLT = “Minimum Offline Time”.

(1)
Time-shiftable appliances (type 1), whose operation time can be scheduled in an allowable time range that is pre-specified by the occupant. The appliances with this type are further categorized as interruptible and uninterrupti-ble appliances. An interruptible appliance's operation can be paused and resumed later while an uninterruptible appliance cannot. An interruptible appliance has a minimum online time constraint and a maximum online time constraint, which specify the minimum time duration after which the appliance can be paused/resumed again, so as to prevent the mechanical device of the appliance from frequent pause/resume actions.

(2)
power-adjustable appliances (type 2). These appliances' operation time cannot be shifted, but their power consumption can be adjusted in a certain range.

Based on the forecasted solar power energy generation, forecasted base load and desired energy use behaviors, the forecasted net-load profile of the prosumer 
 can be calculated following Eqs. (3), (4):(3)
(4)

where 
 is the forecasted net-load of the prosumer in the tth time slot (kW); 
 is the forecasted base load at time slot t (kW): 
 is the forecasted power output from the prosumer's solar panel at time slot t (kW); 
 is the power consumption of the nth controllable appliance at time slot t (kW); N is the total number of controllable appliances.

The forecasted net-load profile of the simulated prosumer is shown in Fig. 6. Based on the profile and the available energy and demand in the distributed energy trading market, the prosumer can determine the energy amount and price it intends to sell to/purchase from the market.We disregard the energy negotiation in this case study to focus on the energy trading and demand control. In this simulation, we assume the prosumer determines to sell and purchase energy to and from other prosumers with the amounts shown in Fig. 6, where the negative and positive values indicate the sold and purchased power, respectively.

Fig. 6
Download : Download high-res image (336KB)
Download : Download full-size image
Fig. 6. Forecasted net-load and energy trading amounts.

The actual based load and solar power may deviate the forecasted ones due to the inevitable uncertainties of the occupant's behaviors and solar radiation. In this simulation, we generate the forecasted based load and solar power in Fig. 5 by adding a Gaussian noise onto the actual based load and solar power data:(5)
(6)

where 
 and 
 are actual base load and solar power output at time slot t (kW), respectively. σ(a, b) generates a Gaussian noise with the mean of a and deviation of b. In the real-time operation stage, after perceiving 
 and 
, the prosumer's energy management system adjusts the operation of controllable appliances at the current time slot to try to satisfy:(7) 
 where 
 is the day-ahead (or hours-ahead) determined traded power at the current time slot t (kW. Negative value for selling power and positive value for purchasing power). The rationale of Eq. (7) is that if the prosumer needs to sell energy to other prosumers at the current time slot t, then the prosumer's energy management system tries to make 
, so that it can actually produce adequate energy to sell; if the prosumer needs to purchase energy from others, the energy management system tries to make 
 so that it will consume the energy bought from the other prosumers.

Fig. 7 shows the prosumer's actual operation results with the real-time load control. It can be seen that the power consumption of the controllable appliances with type 2 (lights and heaters) and one controllable appliance with type 1 (clothes dryer) are adjusted to make the prosumer executes its energy trading contracts as much as possible.

Fig. 7
Download : Download high-res image (376KB)
Download : Download full-size image
Fig. 7. One-day actual operation of the prosumer.

The effect of load control is further illustrated in Fig. 8, which shows the profiles of the forecasted net-load, actual net-load without load control, and actual net-load with load control of the prosumer. The zoomed part in sub-figures demonstrate the net-load under 3 scenarios in some intervals with energy trade. It can be clearly seen that with load control, the actual net-load of the prosumer is closer to the forecasted (i.e., desired) netload. As a result, the amount of traded energy that cannot be actually executed is reduced compared to the scenario of without load control, as shown in Table 4.

Fig. 8
Download : Download high-res image (261KB)
Download : Download full-size image
Fig. 8. Net-load profiles of the prosumer under 3 scenarios.


Table 4. Setting of controllable appliances.

Unexecuted Selling Energy	Unexecuted Purchased Energy
With load control	0.7kWh	0.8kWh
Without load control	0.4kWh	0.3kWh
6. Evaluation and discussion
In this section, we analyze the security and privacy of the framework in Section 6.1 followed by performance evaluation in Section 6.2.

6.1. Security and privacy analysis
This section studies the security, privacy, and fault tolerance, of the proposed architecture. We first outline the threat mode and then discuss possible attacks and how to protect against those.

Threat Model: We define an adversary as advm where advm ⊂ PN & m > = 1. advm are able to sniff the communications, discard blockchain transactions, generate fake transactions, pretend to be another prosumerj where prosumerj ∉ ADV, attempt to remove transactions from TC, and compromise the integrity of communications. We assume that standard asymmetric encryption is in use which cannot be compromised by advm. We assume smart meters are tamper resistant and thus no one can tamper with their transactions. advm may attempt to compromise the security of an energy trade. We assume that bm is trusted and has enough resources to employ high resource consuming security algorithms and thus cannot be compromised.

Security: In the following we discuss possible attack scenarios and outline how the proposed architecture protects against those.

Transaction removal: In this attack, advm attempts to remove a transaction from TC while the Δt is not yet expired. advm may conduct this attack by either removing transaction from its local copy of RL and broadcasting the latter to its neighbors as the latest version of RL or attempting to remove from BB. Recall from Section 3 that the transactions contain timestamp and expiry time that indicate when Nfull can remove transactions from TC. The transaction generator signs the hash of the transaction content which potentially protects against advm that may attempt to modify transaction. Thus, it is impossible for advm to remove a transaction from RL before Δt.

It is possible that a new PNi joining the network may request to download the latest version of RL from advm. advm may remove particular transactions and send to new PNi as the latest version of RL. When a transaction is generated that references a transaction that no longer exists in RL, new PNi requests RL from another Nfull. Thus, the new node will eventually update its RL version with a small delay.

Recall from Section 3 that BB is a read-only database and only bm has the write authority. It is assumed that bm employs strong security safeguards and thus advm is unable to modify the content of BB. In case bm maliciously removes unexpired transactions from the blockchain, the transaction generator informs PNi by broadcasting the original version of its transaction. The malicious behavior of bm can be detected by PNi by evaluating the timestamp of the transaction. Note that bm periodically stores the hash of BB in MC, thus, ERj can prove the existence of their transaction in BB.

Data Tampering: In this attack advm attempts to inject fake ed and ep to the grid which potentiality may disrupt the grid functionality. Recall from Section 4 that the proposed architecture employs two data acquisition modes which are normal and lightweight mode. In both modes, EMN accepts transactions only from pre-registered prosumers which protects against unauthorized prosumers that may attempt to inject information to the grid. The proposed architecture protects against advm that may modify the data of a ENj during transmission. In the normal mode, the transaction generator signs the hash of the transaction content which protects its integrity. In the lightweight mode, secret = hash(secret value + nonce + data) that protects the integrity of the exchanged data. Any modification of data will change the secret value and thus can be detected by EMN.

EMN stores the transactions generated by ERj locally and stores the root of the Merkle tree constructed using all received transactions during Δt in MC. This can later be used to find the liable party for providing false information. Recall that ERj could employ privacy-preserving methods such as zero-knowledge proof in the normal mode to enhance their privacy against curious EMN that may attempt to build virtual profile about ERj. In case of detecting a data tampering attack, EMN can request ERj to reveal their identity and thus find the liable party.

Note that the proposed architecture provides a high level of auditability, however, similar to other blockchain frameworks, it cannot verify the authenticity of the data injected to the blockchain. This challenge is known as data trust in the literature and is beyond the scope of this paper (Dedeoglu et al., 2019).

Masking: In this attack advm pretend to be another node and generates transactions on their behave. In our architecture, transactions are generated using asymmetric encryption or hash-based verified method (see Section 3). The transactions that are generated using asymmetric encryption are signed by a private key that is only known to the transaction generator and thus protects against masking attack. In the hash-based verification method, each transaction contains a hash value that is hash(secret value + nonce + data). Similar to the private key in asymmetric encryption, the secret value is only known to the transaction generator and EMN. Thus, EMN is the only participant that can conduct masking attack. Recall that in this mode, it is assumed that EMN is trusted.

Double Selling: In this attack advm is an energy producer that attempts to sell its energy more than once by trading their energy with more than one ERj. Recall from Section 4 that tTA and tEP are atomic meta-transactions that must be generated within δ to be considered as valid. advm receives tTA from multiple nodes as it agreed to trade the same amount of energy to all. The tEP is generated by the smart meter which is assumed to be tamper resistance, thus advm cannot generate fake tEP. Each tEP contains the ID of the corresponding tTA which prevents advm to spend the same amount of energy twice. Thus, the smart meter of advm will eventually generate only one tEP. The remaining tTA will be removed from tRL by the end of δ.

False Load Claim: In this attack adv is an EMN that has signed contract with ERj to adjust their load to balance the network. advm may falsely claim that the energy demand in the network is high and thus attempt to reduce the load in the consumer site. This potentially increases EMN benefit as it can sell the same energy to other ERj with higher price. tDT transactions are broadcast in private chain and thus all ERj will receive those which enables them to measure the load in the network and verify the decisions made by EMNk. tDT transactions are stored in the private chain which introduces high auditability for ERj. Malicious behavior of EMN can be readily detected.

Privacy: In the following we discuss the privacy of the users, i.e., PNi. The following privacy-preserving methods enhance the privacy of the proposed architecture:

i)
Reducing the number of transactions in MC: Recall from Section 3 that PNi employ a changeable PK+i as their identity which introduces a level of anonymity. However, recent studies show that advm can deanonymize a user by classifying blockchain transactions and linking anonymous transactions to a PNi (Dorri et al., 2019c). Persistence of a large volume of transactions about a PNi increases the available information about PNi which potentially facilitates user deanonymization. Our framework uses a TC as an intermediate layer where PNi can store transactions temporary which reduces the historical volume of data available about each PNi in the public blockchain.

ii)
Reducing the reliance on TTP: Conventional frameworks in energy trading, require a TTP to oversee the trade to ensure that both side of the trading commit to their obligations. The TTP can potentially collect privacy-sensitive data about the involved parties and thus compromise their privacy. We introduced atomic meta-transactions that reduces the reliance on TTP while ensuring that the involved parties in trade commit to their obligations.

iii)
Anonymous verification of smart meters: It is critical for PNi to verify that a transaction is generated by a genuine smart meter. On the other side, the smart meter reveals privacy sensitive information about the meter owner. We employ COE (Dorri et al., 2018) that is enables anonymous verification of the smart meters that in turn enhances the privacy of PNi.

Fault tolerance: Fault tolerance refers to the resilience of the network when a number of nodes become faulty and thus stop functioning which might be the result of an accident or a malicious activity. The proposed architecture relies on blockchain as the underlying communication and data management framework where any node in the network may participate in management of the ledger. A salient feature of the blockchain architecture is that nodes may join or leave the network without impacting the normal operations of the network. The network will only be affected if a majority of the validators simultaneously leave the network, which is highly unlikely. The fault tolerance of the proposed architecture is thus inherited from the robustness offered by blockchain. Recall from Section 3.2 that TC is implemented using RL or BB. RL is managed by the blockchain nodes and thus achieves the same fault tolerance level. In BB, it is assumed that a trusted entity will run the network and different replications of the data are maintained to achieve high fault tolerance.

6.2. Performance evaluation
In this section we discuss the performance of our architecture through implementation.

6.2.1. Implementation setting
We implemented the framework in Hyperledger Fabric (Hyperledger Fabric) as it offers higher flexibility in programming and modifying the transaction flow as compared with other existing frameworks such as Ethereum (Woodet al., 2014). Note that the core features that impact the performance of our algorithm are independent from the underlying blockchain and thus any existing blockchain platform can be employed to evaluate the performance of the framework. Fig. 9 represents an overview of different components of the implementation and their relations. The implementation contains three main layers which are: i) peer-to-peer layer, ii) TC layer that includes BB and RL, and iii) MC layer.

Fig. 9
Download : Download high-res image (234KB)
Download : Download full-size image
Fig. 9. An overview of the components involved in the implementation.

Recall from Section 4 that the proposed framework involves three stages which are data acquisition, energy trading and real-time load control. To implement the last two stages, individual smart contracts are implemented and deployed in MC layer following the blockchain workflow format described in Bore et al. (2019). The data acquisition stage involves transferring data that is handled by all PNi. The transactions generated by PNi are handled by the process manager component by instantiating a workflow to determine which smart contract will execute the received transactions. The process manager verifies transactions exchanged between multiple layers and stores them in RL. The pub/sub event listener forwards unprocessed transactions to MC using Kafka (2020). Once the transaction is committed in blockchain, the pub/sub event listener receives the response in outgoing queue.

We implemented a conventional blockchain framework as the baseline for comparing the performance of the proposed framework. In the baseline, all transactions are submitted to the blockchain. The blockchain network comprises of 20 users that generate transactions at a fixed rate round control with increment of 20 transactions per second (tps) in each round, starting from 20 tps to 240 tps. The users send their transactions to the blockchain layer that is implemented using Hyperledger Fabric framework comprising of four organization each with one peer and a solo orderer. The peers and the orderer are configured in a docker compose (version 1.25) virtual environment hosted on a Linux server with 12 3.70 GHz Intel(R) Xeon(R) W-2135 CPUs. Crash Fault Tolerant (CFT) (Yusuf et al., 2019) is employed as the underlying consensus algorithm for both the baseline and the proposed method. Note that the performance of our architecture is independent of the underlying consensus algorithm.

Recall from Section 3 that the proposed architecture introduces lightweight and normal modes to transfer data to EMN. The lightweight mode aimed to reduce the overhead in low resource available devices in smart grid. To study the performance, both data transmission modes are implemented using Java programming language. We run these algorithms on a Raspberry Pi device as a proxy for low resource available devices.

6.2.2. Implementation results
Recall from Section 1 that one of the key contributions of this work is the introduction of TC to reduce the processing overhead incurred in managing the blockchain. We compare the memory footprint of the blockchain in each of the underlying nodes in our framework with that of the baseline. We assume that each trade involves four energy negotiation transactions tEN, one energy supply transaction tES, one tTA trade agreement transaction, and one energy payment transaction tEP. As evident from the results shown in Fig. 10, the proposed framework reduces the blockchain database size by around 45% which can be attributed to the introduction of the TC.

Fig. 10
Download : Download high-res image (198KB)
Download : Download full-size image
Fig. 10. Evaluation of the blockchain database size.

The introduction of TC enables the users to store transactions temporarily which reduces the total number of transactions that are stored in the permanent blockchain and thus increases blockchain scalability. To evaluate this, we studied the latency and the blockchain throughput in a scenario where 100 energy trades are conducted. The simulations results are shown in Fig. 11.

Fig. 11
Download : Download high-res image (224KB)
Download : Download full-size image
Fig. 11. Evaluation of the blockchain throughput and latency.

Recall that in baseline all transactions must be stored in the blockchain while in our framework only tTA, and tEP are stored in the main chain which in turn increases the blockchain throughput. As shown in Fig. 11, the proposed method improves the throughput. The impact of throughput is more visible when transaction rate is above 100. The main reason is that for transaction rate smaller than 100 transactions, all transactions can be stored in the blockchain while when the transaction rate increases, the maximum network throughput is reached in the blockchain. Similarly, the latency involved in storing transactions in our method significantly reduces as compared with the baseline method particularly at higher transaction rates where the baseline reaches saturation.

Next we evaluate the impact of TC on the blockchain overhead by measuring the cumulative number of blocks generated in the blockchain to conduct 100 trades. We assume each trade involves 7 transactions which are 4 tEN, 1 tES, 1 tTA, and 1 tEP. Recall from Section 4 that our framework only stores tTA and tEP in the blockchain. We considered a baseline method where all the above transactions are stored in the blockchain. Assuming that the block size in blockchain is 10 transactions, the number of blocks will be as shown in Table 5. In this table Ω represents the total cost of running the consensus algorithm, including computational, packet, and storage, that may vary based on the consensus algorithm employed in the network.


Table 5. Evaluation of the impact of TC on blockchain overhead.

Number of Blocks	Consensus overhead
Baseline	70	70Ω
Our framework	20	20Ω
Next, we evaluate the performance of lightweight and normal data transmission modes (see Section 4). We run both normal and lightweight modes in Raspberry Pi and measured the processing time taken to generate transactions. The results are shown in Fig. 12. The processing time overhead during the lightweight mode ranges from [20–67] ms, while in normal mode the processing overhead is [36699-432517] ms. The main reason is that generating new key pairs for each transaction and signing the transaction using asymmetric encryption is resource consuming while the lightweight mode only demands hashing of the pre-defined values.

Fig. 12
Download : Download high-res image (116KB)
Download : Download full-size image
Fig. 12. Evaluation of the processing time in lightweight and normal data transmission modes.

Based on the simulation results, the proposed framework increases the scalability of the blockchain as compared with conventional blockchains. The reduced blockchain database size reduces the overheads in managing the blockchain and thus increases the scalability. The increased blockchain throughput along with the reduced latency ensure that a larger number of transactions can be committed in the blockchain with low delay and thus enables larger number of participants to participate in the blockchain network. Finally, the proposed framework significantly reduces the number of blocks and thus consensus overhead for conducting a trade in blockchain (see Table 5) which in turn leads to higher scalability.

7. Conclusion and open research problems
In this paper, we proposed a three-layered blockchain architecture that enables the participating nodes to achieve temporary immutability by storing transactions for only a particular period of time. We studied our architecture using an energy trading scenario, however the core blockchain architecture addresses challenges that are fundamental to any value transfer marketplace scenario. Our energy trading scenario comprises of three stages which are: i) data acquisition where the participating nodes share their energy consumption/generation data with energy manager node (EMN) who is responsible for managing energy for a group of users. To reduce the computational overhead associated with frequently generating transactions to share data, we proposed a lightweight data sharing method that relies on a hash function to ensure the integrity of the data, ii) prosumer side energy trading where EMN trades energy with other nodes. EMN may also negotiate over the energy price or amount, and iii) Real-time energy balance where EMN can communicate with its nodes to shift their energy consumption/generation pattern. This ensures that the system is reliable as the actual energy consumption/generation value may be different with the predicted value. Implementation results show that the proposed architecture reduces the latency and memory overhead of the blockchain and increases throughput.

We identified the following limitations and challenges for future works:

1.
Computational and communication cost issue. Most prosumers in a power distribution system are residential users equipped with devices with limited computational and communication capacities (e.g., smart phones, smart meters, and personal computers). The computational and communication cost of the blockchain within the context of a large-scale system should be evaluated.

2.
Support other grid-level applications. The blockchain system in this paper is primarily designed for supporting energy trading among prosumers. As an information infrastructure, the data recorded in the blockchain ledgers (e.g., smart meter data and energy trading transactions) can also be aggregated and used by the power utility for other applications, such as generation planning, electricity retail pricing, and power flow calculations. Developing and embedding grid application-specific protocols into the blockchain system therefore has practical meaning and deserves further investigation.
