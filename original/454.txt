In medical cloud computing, a patient can remotely outsource her medical data to the cloud server. In this case, only authorized doctors are allowed to access the data since the medical data is highly sensitive. Before outsourcing, the data is commonly encrypted, where the corresponding secret key is sent to authorized doctors. However, performing searches on encrypted medical data is difficult without decryption. In this paper, we propose two Secure and Efficient Dynamic Searchable Symmetric Encryption (SEDSSE) schemes over medical cloud data. First, we utilize the secure k-Nearest Neighbor (kNN) and Attribute-Based Encryption (ABE) techniques to construct a dynamic searchable symmetric encryption scheme, which can achieve forward privacy and backward privacy simultaneously. These tow security properties are vital and very challenging in the area of dynamic searchable symmetric encryption. Then, we propose an enhanced scheme to solve the key sharing problem which widely exists in the kNN based searchable encryption scheme. Compared with existing proposals, our schemes are better in terms of storage, search and updating complexity. Extensive experiments demonstrate the efficiency of our schemes on storage overhead, index building, trapdoor generating and query.

SECTION 1Introduction
Health care service has been extensively studied to improve medical quality and reduce the cost of medical services [1], [2]. With a large amount of medical data, a health care system must extend its scale to provide efficient and secure services [3]. Media cloud computing treats computing itself as a utility, which rent out the computing and storage resources to patients and doctors. It is a promising computing paradigm that enables dynamic resource allocation, self-demand services, measurement of service, transparency of resource, etc [4], [5], [6], [7]. As such, a patient is able to store one's sensitive data on cloud server remotely, namely data outsourcing, and then open her cloud data to the doctors.

Note that, the medical data stored in cloud server may contain private and sensitive information (e.g., medical case and diagnostic report). The medical data should be well encrypted before it is uploaded to the cloud. However, the encrypted data may compromise the usability of the data such as performing searches on the ciphertext. To address the problem, Searchable Symmetric Encryption (SSE) schemes have been proposed in several literatures as a fundamental approach to enabling keyword search over encrypted cloud data [8]. The existing searchable encryption schemes can achieve fuzzy and ranked keyword search, multi-keyword search, and so on [9], [10], [11].

Recently, many k-Nearest Neighbor (kNN) based SSE schemes (e.g., [11]) have been proposed to search over encrypted data. However, in such schemes every search shares the same secret key among users, which may cause disclosure of privacy. On the other hand, it is challenging, especially in the health care system, to develop a dynamic version of SSE (DSSE) in which the data is inserted into a collection arbitrarily (forward privacy) or deleted from a collection (backward privacy). Stefanov et al. [12] proposed an efficient DSSE scheme, which can achieve forward privacy, but cannot ensure backward privacy. Some researchers [13], [14] leverage Oblivious Random Access Memory (ORAM) to ensure the forward and backward privacy. However, in DSSE, those schemes significantly raise the complexity in storage, search and updating processes.

To address the above issues, in this paper, we propose a Secure and Efficient Dynamic Searchable Symmetric Encryption (SEDSSE) scheme over medical cloud data. This work extends and improves our previous research [15]. Specifically, this paper addresses two new issues: the collusion between the cloud server and search users as well as different secret key distribution among search users. In addition, we apply the new design to the health care system. Furthermore, the security and performance are analyzed. The original contributions of the paper are:

First, we combine the k-Nearest Neighbor (kNN) and Attribute-Based Encryption (ABE) techniques to propose a Secure and Efficient Dynamic Searchable Symmetric Encryption scheme, named SEPSSE_I. The proposed scheme can achieve forward privacy, backward privacy, and collusion resistance between the cloud server and search users.

Second, based on the scheme, we further propose an enhanced scheme, named SEPSSE_II to solve the key sharing problem which widely exists in the kNN based searchable encryption approaches. Compared with existing DSSE schemes, our proposed schemes are have less storage costs, search and updating complexity. Extensive experiments proves the efficiency of proposed scheme in term of storage overhead, index building, trapdoor generating and query.

The organization of this paper is as follows. Section 2 outlines the system model, security requirements and design goals and Section 3 introduces several basic techniques. The developed schemes and updating operations are presented in Sections 4 and 5, respectively. An enhanced scheme is proposed in Section 6 to address the key sharing problem. The security analysis and performance evaluation are conducted in Sections 7 and 8, respectively. The related works are presented in Section 9 and finally Section 10 makes a conclusion of the paper.

SECTION 2System Model, Security Requirements and Design Goals
2.1 System Model
As shown in Fig. 1, our schemes consist of four entities (For simplicity, we do not mark the trusted authority in Fig. 1).

Trusted authority: A trusted authority (TA) is a trusted third party. We use it to generate attribute-based encryption (ABE) key to encrypt the medical documents. Patients’ documents will be encrypted and only some doctors satisfying the corresponding access policy can decrypt them.


Fig. 1.
System model.

Show All

Patient: A patient uploads her documents to cloud servers to provide reliable and convenient data access to the authorized search doctors. To preserve the medical data privacy, the patient encrypts the documents under an access policy using attribute-based encryption. To improve the search efficiency, she generates several keywords for every outsourced document. The index of which is then constructed according to the keywords by using the private key of the secure kNN scheme. Then, the encrypted documents and the corresponding indexes are sent to cloud servers. Patient also submits the private key to the corresponding search doctors.

Cloud server: A cloud server should be an intermediary entity which is expected to store the ciphertexts of the documents and the corresponding indexes submitted by patients. Then, cloud sever provides search and data access services to authorized doctors. When a trapdoor generated by a search doctor is uploaded to cloud, a set of matching documents will be returned after running certain operations.

Doctor: An authorized doctor receives the secret key from the patient, where this key can be used to generate trapdoors. When she performs searches over outsourced documents on cloud servers, she should generate a set of search keywords. The doctor utilizes the private key to construct a trapdoor and uploads it to cloud servers base on the set of keywords. At last, she obtains the matched documents set from cloud server then decrypts them by using the corresponding ABE key received from the trusted authority. After getting the health information of the patient, the doctor can also outsource medical report to the cloud server by the same way. For simplicity, we just consider one-way communication in our schemes.

2.2 Security Requirements
We consider the cloud server as semi-trusted, i.e., it is curious about the content of private and sensitive information indicated by the queries when search doctors performing the searches. The security requirements are defined as follows.

Privacy preservation of indexes, documents and trapdoors: It is suppose to be the most important and basic security property in common searchable encryption schemes. If ignoring the privacy issues, searchable encryption will be out of the question. Namely, proposed scheme should satisfy this privacy requirement. In particular, in terms of document privacy, ours is safer than common searchable encryption approaches because of the use of ABE technique [16].

Unlinkability of trapdoors: The unlinkability of trapdoors is defined in a harsh model, Known Background Model [11], to research more comprehensive privacy and security of proposed schemes. In this paper, the public cloud server is suppose to be powerful. It can also possess additional statistical information through a known comparable data set. For instance, the statistical information of trapdoors, indexes and even some keywords may be leaked.

Collusion resistance between the cloud server and search users: General searchable encryption schemes encrypt all outsourced documents with the same key. If the cloud server conspires with one search user then it can decrypt all documents outsourced. Therefore, in our schemes, we use ABE technique to encrypt the oursourced documents, so that one search user can only access a given number of documents if and only if she satisfies the corresponding access policy.

Key non-sharing in search: In our general kNN based searchable encryption schemes, all search users share the same secret key (S,M1,M2). Therefore, the trapdoor generated by one search user can be decrypted by other search users, which causes disclosure of user privacy. In our basic scheme, one doctor's search request can be decrypted by other doctors, hence we propose an enhanced scheme to solve this problem.

Forward privacy and backward privacy: In DSSE, the outsourced documents need to be frequently updated. For strong privacy and security requirements, we also consider whether cloud servers can infer that the newly added document contains a specific keyword searched in the past. It is formally called as forward privacy, and we try to achieve it. Compared with forward privacy, backward privacy is an another critical security requirement in DSSE, the formal definition is: any given query cannot be performed on deleted documents. The cloud server is semi-trusted, and it is curious about the content of private information. Documents which should be removed from the storage space may be spared. Further more, it may use it to match newly received queries for its special purpose. Therefore, a scheme that achieves both forward privacy and backward privacy is proposed in this paper.

Access pattern: Access pattern is actually the results of sequential searches, consisting of the returned identity sets according to the given search keyword collections. Several searchable encryption schemes, e.g., [17], try to hide the access pattern by utilizing private information retrieval (PIR) technique [18]. However, protecting the access pattern is not the key design goal of proposed scheme. Moreover, PIR based techniques must “touch” all the data outsourced on the servers which will lead to low efficiency in the environment of huge cloud system.

2.3 Design Goals
In order to achieve secure and efficient dynamic searchable symmetric encryption schemes over medical cloud data, the following goals should be achieved:

Strong security: In health care system, privacy-preservation is very important. Therefore, the most important goal is to satisfy the security requirements listed in Section 2.2. Without this, searchable encryption will be meaningless.

Multi-keyword search: This paper is also aims to enable multi-keyword search on encrypted outsourced cloud data. Multi-keyword search is more practical than the common single keyword search. Besides, multi-keyword search meets the requirements of search doctors and achieve better search efficiency.

Efficient updating: It may update data more frequently than general searchable encryption proposals, e.g., delete and insert operation. However, entire indexes are outsourced and encrypted by data owners. Considering cloud computing environment, the amount of indexes may be large. Base on which, the updating efficiency becomes a critical factor. The optimal choice is not to update the outsourced indexes while running updating operations. In this paper, the proposed scheme achieve updating operations with constant cost.

Access control: In our previous design [15], we send the symmetric secret key to the authorized doctors directly. If a doctor conspires with the cloud server, then all encrypted documents will be decrypted by the cloud server. Therefore, we introduce the ABE technique to solve this problem.

SECTION 3Preliminaries
3.1 Relevance Score
The frequency of the keyword appears in the document will be indicated with the relevance score between a keyword and a document. Without loss of generality, we adopt a widely used expression in [19] to evaluate the relevance score as:
Score(T˜,Fj)=∑t∈T˜1|Fj|⋅(1+lnfj,t)⋅ln(1+Nft),(1)
View Source

where fj,t represents the frequency of keyword t in document Fj; ft represents the number of documents that contain the keyword t; N represents the number of files in the collection; and |Fj| represents the length of Fj, which obtained by counting the number of indexed keywords.

3.2 Notation
F - the outsourced document collection, which represents a batch of N documents F=(f1,f2,…,fN).

C - the encrypted document collection according to F, denoted as a set of N documents C=(C1,C2,…,CN).

T - the dictionary of keyword with m keywords, which is denoted as T=(t1,t2,…,tm).

I - the outsourced collection of index, which is constructed from each document's keywords, denoted as I=(I1,I2,…,IN).

T˜ - the set of search keyword, which is produced by any search doctor and is also a subset of T.

QT˜ - the keyword set's trapdoor, denoted as T˜.

D - a set of number, initialized as {1,2,3,…,d}, where d represents the outsourced document collection's maximum size.

D¯¯¯¯ - a collection of number, initialized as ∅.

3.3 Access Policy
Informally, according to ciphertext policy attribute-based encryption (CP-ABE), access policy is bound up with ciphertext specifying who is able to decrypt ciphertext. In the proposed schemes, we utilize AND-gates on negative attributes, multi-valued attributes and wildcards. Negative attribute indicates that the doctor does not possess this attribute. Wildcard indicates that the attribute doesn't need to be considered in decryption[16].

Definition.
U={att1,…,attn} denotes a collection of attributes. Let Si={vi,1,…,vi,ni} be a collection of possible values in each atti∈U, where ni=|Si| is atti's total amount of possible values. For U, U¯={¬atti,…,¬attn} denotes a collection of negative attributes . Let L=[L1,…,Ln] represents any doctor's attribute list, where Li∈Si∪{¬atti}. Let W=[W1,…,Wn] represents an access policy, where Wi∈Si∪{¬atti,∗}.

For all i=1,…,n,Li=Wi or Wi=∗, L⊨W indicates that a given attribute list L abides by a specific access policy W. Moreover, we utilize L≠W to represent that L doesn't satisfy W.

Algorithm 1. Generation algorithm of Vj
Input:   D,D¯¯¯¯

Output:   (V1,V2,⋯,VN),D,D¯¯¯¯

for j=1 to N do

randomly choose an element vj from D: vj←RD

randomly choose aj←RZ∗q

Vj={Vj[i]}=⎧⎩⎨⎪⎪aj,−aj,β∗, if i=vj, if i=d+1, other.
View SourceRight-click on figure for MathML and additional features.

D=D−{vj}

D¯¯¯¯=D¯¯¯¯+{vj}

end for

return (V1,V2,…,VN),D,D¯¯¯¯

Algorithm 
SECTION 4Proposed Sedsse_ I Scheme
In this section, we will present the proposed scheme that constructs a searchable encryption protocol by utilizing the secure k-nearest neighbor (kNN) algorithm [20]. We also leverage CP-ABE technique to encrypt the symmetric secret key ski and to encrypt the outsourced documents stored in cloud servers. Here, we clarify some symbols. G denotes a bilinear group with a generator g whose prime order is p. The bilinear map is denoted as e:G×G→G1. An encoding between G1 and G can be represented as E:G→G1. k is a security parameter, which indicates the size of the given groups. Let U={att1,…,attn} denote a collection of attributes. Let Si={vi,1,…,vi,ni} denote a collection of possible values bounded up with atti and ni=|Si|. L=[L1,…,Ln] represents a doctor's attribute list. W=[W1,…,Wn] denotes an access policy. The proposed algorithms are shown as follows:

Gen(1k). A patient randomly generates the secret key K=(S,M1,M2). Here, S is an binary vector with (m+d+1) dimensions, M1 and M2 are two invertible matrices with (m+d+1)×(m+d+1) elements. The binary vector S is utilized as splitting indicator to split a plaintext vector into two random vectors, which conceals the real value of the plaintext vector. M1 and M2 are utilized to encode the split vectors. Details about the security and correctness is discussed in [20]. For ABE, a tuple G=[p,G,G1,g∈G,e]←Gen(1k), y∈RZp and g2,g3∈RG is generated by the trusted authority (TA). For constructing bilinear groups Gen, the security parameter k is regarded as an input and the tuple G is the outputs, where log(p)=Θ(k). TA produces values {ti,j∈RZp}1⩽j⩽ni and {ai,bi∈RZp} for every attribute atti (1⩽i⩽n). Then, TA calculates g1=gy, Y=e(g1,g2), {{Ti,j=gti,j}1⩽j⩽ni,Ai=gai,Bi=gbi}1⩽i⩽n. Finally, PK (public key) is shown as
PK=⟨g,g1,g2,g3,e,Y,{{Ti,j}1⩽j⩽ni,Ai,Bi}1⩽i⩽n⟩.(2)
View SourceThen, the master key can be denoted as MK=⟨y,{{ti,j}1⩽j⩽ni,ai,bi}1⩽i⩽n⟩.

GenIndex(F,K). A m-dimensional vector Pj is generated by patient according to the ciphertext of document fj(j=1,2,…,N). Each bit Pj[i] of the vector represents keyword ti's relevance score in Fj, i.e., Pj[i]=Score(ti,Fj). Then, the vector Pj is extended to an vector P′j=Pj||Vj with (m+d+1) dimensions by the patient, where Vj is also a (d+1)-dimensional vector. In order to ensure document collection's certain scalability, d is set as the outsourced document collection's possible maximum amount. Let maxS be the possible maximum relevance score between a document and a search keyword set. Then, the patient create a random parameter β, where β>maxS. Hence, we can use Algorithm 1 to generate the vector Vj(j=1,2,…,N), where β∗ denote β's arbitrary integer multiples. In that way, the type of Vj can be illustrated as follows:
V1=(β∗,β∗,…,a1,β∗,…,β∗,−a1)V2=(β∗,β∗,a2,…,β∗,…,β∗,−a2)V3=(β∗,β∗,…,β∗,a3,…,β∗,−a3)⋯(3)
View SourceWe will utilize the secure kNN scheme to encrypt the vector P′j. The patient leverages vector S to split P′j into two vectors (pa,pb) with (m+d+1) dimensions. As mentioned above, the vector S is used as a splitting indicator. That is, if S[i]=0 (i=1,2,…,m+d+1), pa[i] and pb[i] are both set as P′j[i]; if S[i]=1 (i=1,2,…,m+d+1), the original value of P′j[i] will be split into pa[i] and pb[i] (P′[i]=pa[i]+pb[i]) randomly. After that, the encrypted document Cj's index can be computed as
Ij=(MT1pa,MT2pb).(4)
View SourceAt last, we submit the key tuple (K,D¯¯¯¯) to the authorized search doctors by leveraging secret channels, and skj(j=1,2,…,N) will be sent to encryptor, where the symmetric key skj is used to generate the ciphertext of outsourced documents stored in cloud servers. β and D are published and stored by the patient itself in its own storage space.

KeyGen(MK,L). Let L=[L1,L2,…,Ln] denote the attribute list of the doctor that has the corresponding secret key. TA chooses ri,r′i,r′′i∈RZp for 1⩽i⩽n, sets r=∑ni=1ri and computes D0=gy−r2. TA computes Di and Fi for 1⩽i⩽n as
Di={(gri2Tr′ii,ki,gr′i)(if Li=vi,ki)(gri2Ar′ii,gr′i) (if Li=¬atti),Fi=(gri2Br′′ii,gr′′i).(5)
View SourceThen, TA will output SKL=⟨L,D0,{Di,Fi}1⩽i⩽n⟩ (secret key) to the doctor.

Encrypt(PK,M,W). An encryptor first chooses s∈RZp, and then computes C~=fj⋅Ys and C0=gs,C′0=gs3 to generate the ciphertext of medical document fj∈G1 strictly follow the access policy W. After that, the encryptor computes Ci for 1⩽i⩽n as follow:
Ci=⎧⎩⎨⎪⎪⎪⎪Tsi,kiAsiBsi(if W=vi,ki)(if Wi=¬atti)(if Wi=∗).(6)
View SourceThe encryptor outputs the ciphertext CTW=⟨W,C~,C0,C′0,{Ci}1⩽i⩽n⟩ to the server, where CTW will be combined with encrypted document Cj, and then the patient outsources the combination to the cloud server.

ReKGen(SKL,W). Let SKL be a valid private key, and an access policy is denoted as W. To generate W's re-encryption key, choose d∈RZp and compute gd, D′i=(Di,1gd3,Di,2), F′i=(Fi,1gd3,Fi,2). Set D′0=D0 and compute C, which is encrypted E(gd) under a given access policy W. That is, C=Encrypt(PK,E(gd),W). Then, W's re-encryption key should be RKL→W=⟨L,W,D′0,{D′i,F′i}1⩽i⩽n,C⟩.

Reencrypt(RKL→W′,CTW). RKL→W′ represents the access policy W′'s valid re-encryption key and ⟨W,C~,C0,C′0,{Ci}1⩽i⩽n⟩ is a well-designed ciphertext which is denoted as CTW. We will figure out whether L⊨W by checking W. If L≠W, return ⊥; otherwise, for 1⩽i⩽n, compute:
Ei=⎧⎩⎨⎪⎪⎪⎪e(C0,D′i,1)e(Ci,D′i,2)(if  W′i≠∗)e(C0,F′i,1)e(Ci,F′i,2) (if  W′i=∗)⎫⎭⎬⎪⎪⎪⎪=e(g,g3)sde(g,g2)sri.(7)
View SourceAfterwards, compute C¯=e(C0,D′0)∏ni=1Ei=e(gs,gy−r2)e(g,g2)sre(g,g3)nsd=e(g,g2)yse(g,g3)nsd and outsource a re-encrypted ciphertext
CT′=⟨W′,C~,C′0,C¯,C⟩.(8)
View SourceNote that, C can be re-encrypted again. As illustrated in algorithm Decrypt, we can find that the recipient can decrypt the re-encrypted ciphertext only by using gd. Therefore, we have CT′′=⟨W′′,C~,C′0,C¯,C′⟩, where C′ is acquired by running the Reencrypt algorithm, and the input is another RKL′→W′′ and C. The size of ciphertext and decryption cost increase linearly with re-encryption time. As mentioned in [14], for non-interactive scheme, the costs are inevitable.

GenTrapdoor(T˜,K,D¯¯¯¯). First, for searching, the keyword set T˜ is generated by search doctor. According to T˜, the search doctor creates a binary vector Q with m dimensions, where Q[i] indicates whether the ith keyword of dictionary ti is in T˜. For instance, Q[i]=1 represents yes, and Q[i]=0 indicates no. Then, the vector Q will be extended to another vector Q′=Q||V′ with (m+d+1) dimensions by the search doctor, where V′ is a vector with (d+1) dimensions and we generate it as follows.
V′={V′[i]}={1,0, if i∈D¯¯¯¯∪{d+1}, other.(9)
View SourceTherefore, Q′ can be split into two (m+d+1) vectors (qa,qb) by the search doctor. Specifically, if S[i]=0 (i=1,2,…,m+d+1), the original value of Q′[i] should be split into qa[i] and qb[i] randomly. Besides, if S[i]=1 (i=1,2,…,m+d+1), we set both qa[i] and qb[i] as Q′[i]. So, we generate trapdoor QT˜ by calculating:
QT˜=(M−11qa,M−12qb).(10)
View Source

Search(Ij,QT˜). All previously obtained indexes are stored in cloud servers. Once coming a trapdoor, the relevance score is calculated as follows:
Score(T˜,Fj)=Pj⋅Q=(P′j⋅Q′) mod β=(pa⋅qa+pb⋅qb) mod β=(MT1pa,MT2pb)⋅(M−11qa,M−12qb) mod β=(Ij⋅QT˜) mod β.(11)
View SourceA larger score can reflect the corresponding searched document Fj is more relevant to search keyword collection T˜. Therefore, the top scored encrypted documents should be returned to the search doctor. But at this point, the search doctor cannot decrypt the documents Cj without skj.

Decrypt(CTW,SKL). Upon receiving the encrypted documents with top scores, the decryptor will check W to know whether L⊨W. If L⊨W, she can proceed. Then, as shown below, CT is decrypted by the decryptor through utilizing private key SKL.

If CT is an original well-formed ciphertext, then

for 1⩽i⩽n, compute
D′i={Di,1(if  Wi≠∗)Fi,1 (if  Wi=∗),D′′i={Di,2(if  Wi≠∗)Fi,2 (if  Wi=∗),(12)
View Source

fj(j=1,2,…,N)=C~∏ni=1e(Ci,D′′i)/(e(C0,D0)∏ni=1e(C0,D′i)).

Else if CT is a re-encrypted well-formed ciphertext, then

decrypt E(gd) from C using the secret key SKL and decodes it to gd,

fj=C~⋅e(C′0,gd)n/C¯.

Else if CT is a multi-time re-encrypted ciphertext, decryption will be similar to the above phases.

After obtaining the skj, the search doctor can decrypt the encrypted documents. The decryptor locates on the server side.

SECTION 5Dynamic Updating
In a DSSE scheme, delete operation and insert operation may be used more frequently than common schemes. The privacy of outsourced documents may be disclosed by running such operations. In this part, we try to fusion updating operations in one searchable encryption scheme, which can ensure both backward privacy and forward privacy. Note that, when executing the updating operations over some documents, the other documents’ indexes need no change. For instance, the updating cost is constant. Thus, the proposed scheme achieves extremely high efficiency in the updating phase.

Delete (Fj) When a patient deletes a document Fj from cloud servers, the vj should be send to search doctors by patient himself through the secret channel. The details of the operations are illustrated in Algorithm 2. Moreover, the cloud server will delete the ciphertext of document Cj, the corresponding index Ij and ciphertext CTW from its storage space.

Insert (Fl): When a patient needs to add a document Fl, he first creates the index Il, the ciphertext CTW and the ciphertext of document Cl. Then, all these data should be send to cloud server by himself. Once received, the cloud server stores them in the patient's own storage space. The details of operations are depicted in Algorithm 3.

SECTION Algorithm 2.delete Algorithm
Input:   D,D¯¯¯¯,vj

Output:   D,D¯¯¯¯

D=D+{vj}

send vj to the search doctors

D¯¯¯¯=D¯¯¯¯−{vj}

return D,D¯¯¯¯

SECTION Algorithm 3.insert Algorithm
Input:   D,D¯¯¯¯

Output:   Vl,D,D¯¯¯¯

randomly choose an element vl from D: vl←RD

randomly choose al←RZ∗q

Vl={Vl[i]}=⎧⎩⎨⎪⎪al,−al,β∗, if i=vl, if i=d+1, other.(13)
View SourceRight-click on figure for MathML and additional features.

D=D−{vl}

send vl to the search doctors

D¯¯¯¯=D¯¯¯¯+{vl}

return Vl,D,D¯¯¯¯

Algorithm 
SECTION 6Enhanced Sedsse_II Scheme Without Key Sharing
In our basic searchable encryption system, each search doctor shares the same secret key K=(S,M1,M2). This causes a security issue, i.e., key sharing. The trapdoor generated by a search doctor can be decrypted by other search doctors, which will disclose the privacy information of the search doctor. Therefore, we propose an enhanced scheme to solve this problem.

For a patient, based on the secret key K=(S,M1,M2), the binary vector S will not be changed, but M1 and M2. We replace M1 with (M1N1,M1N2), where (N1,N2) are both invertible matrices with size (m+d+1)×(m+d+1). For a search doctor Ui, the corresponding M−11 in its secret key K=(S,M−11,M−12) will be replaced as (N−11M′i,N−12M′′i) where M′i and M′′i are two randomly chosen matrices and M′i+M′′i=M−11. Hence, in the query phase of the basic searchable encryption scheme, pa⋅qTa can be computed as
paM1⋅M−11qTa mod g=pa⋅qTa mod g.(14)
View SourceIn the enhanced scheme, it can be replaced as
paM1N1⋅N−11M′iqTa+paM1N2⋅N−12M′′iqTa mod g=paM1⋅M′iqTa+paM1⋅M′′iqTa mod g=pa(M1⋅M′i+M1⋅M′′i)qTa mod g=pa(M1⋅M−11)qTa mod g=pa⋅qTa mod g.(15)
View SourceRight-click on figure for MathML and additional features.

Similar to M1, the matrix M2 can also be replaced by (M2N3,M2N4) in a patient's secret key and (N−13M′′′i,N−14M′′′′i) in each doctor's secret key, where (N3,N4) are all invertible matrices with size (m+d+1)×(m+d+1).

The improved point is that we achieve the keyword search secretly while each search doctor Ui uses a different secret key, i.e., (N−11M′i,N−12M′′i,N−13M′′′i,N−14M′′′′i), which is generated by the patient and sent to the corresponding search doctor. The search doctor Uj with secret key (N−11M′j,N−12M′′j) cannot decrypt the trapdoor (N−11M′iqTa,N−12M′′iqTa) generated by Ui.

SECTION 7Security Analysis
In this part, we give a detail analysis of the security issues for the proposed scheme.

7.1 Privacy Preservation of Documents, Indexes and Trapdoors
Considering the security requirement, the outsourced documents are encrypted before being uploaded to cloud servers. Therefore, we encrypt documents by utilizing the symmetric crypto-system (e.g., AES [21]), but due to the introduction of ABE technique, the corresponding symmetric private key sk created by the patient will not be sent to the authorized doctors immediately. Only the doctors who have the attributes set L satisfying the corresponding access policy W can obtain the secret key sk. It prevents the unauthorized doctors from accessing the documents. Indexes and trapdoors are protected by the secure kNN scheme, which is a non-deterministic algorithm. Once they are encoded by kNN, even the collections of search keyword (or two documents’ keyword collections) are exactly the same, the trapdoors (or indexes) are still different. In our previous design, the same secret key K is shared by all authorized doctors, which would cause key sharing security issue. The doctor can decrypt the trapdoor generated by another doctor using the shared secret key K. In order to solve this problem, we make M multiply a matrix N used to confuse M, and add the randomness property to M which would be split into two randomly chosen matrices. By using the above method, the key sharing security issue could be avoided, and the trapdoor privacy would be protected. More discussions about security can be found in [16], [20].

7.2 Unlinkability of Trapdoors
Under Known Background Model, the leakage of sensitive privacy information may caused by the trapdoor's linkability. For instance: 1) whether the same keyword is searched by two different trapdoors; 2) whether a trapdoor searches two different keywords simultaneously.

Known Background Model: In this model, cloud server is able to obtain some sensitive statistical information from a known comparable dataset, which is similar to the targeting dataset in nature.

Considering the first issue, due to the property of non-deterministic of secure kNN, even the search keyword collections are exactly the same, the trapdoors should still be different. For instance, by utilizing the split indicator S, Q′ will be split into two vectors (qa,qb) randomly. Considering the second issue, we leverage two matrices (M−11,M−12) to encrypt vectors (qa,qb). Even if a keyword bit Q′[i] is disclosed, it is impossible to compute the else keyword bits. This strong security property is strictly proofed in [20]. Thus, it is also hard to infer whether a trapdoor searches two different keywords simultaneously. Therefore, the proposed schemes can ensure trapdoor's unlinkability.

7.3 Collusion Resistance Between the Cloud Server and Search Users
In general searchable encryption scheme, all outsourced documents are encrypted by the same key. That is very dangerous, i.e., if the cloud server conspires with one search user then it can decrypt all documents outsourced. Therefore, in our schemes, we use ABE technique to encrypt the oursourced documents, so that one search user can only touch a part of documents if and only if she satisfies the corresponding access policy. The effect of collusion between the cloud server and search users can be drastically reduced. Namely, we achieve the goal of controlling the risk of collusion between the cloud server and search users .

7.4 Key Non-Sharing in Search
In our normal kNN based searchable encryption scheme, all search users share the same secret key (S,M1,M2). Therefore, the trapdoor generated by one search user can be decrypted by any other search users, which causes disclosure of user's privacy. In our basic scheme, one doctor's search request can be decrypted by other doctors, hence we propose an enhanced scheme to solve this problem. In such scheme, the patient's index is still encrypted by one secret key (M1N1,M1N2), and every doctor Ui uses a different secret (N−11M′i,N−12M′′i,N−13M′′′i,N−14M′′′′i). With this, one doctor cannot decrypt trapdoors of the other doctors, which is more acceptable in the medical data search scheme.

7.5 Forward Privacy and Backward Privacy
Since the cloud server is honest-but-curious, it may store some historical data, such as deleted documents and previous queries, into its own storage space. The privacy requirements are that the previous queries can not search the newly inserted documents and the newly received query is not able to run over the deleted documents. In the proposed schemes, for any legitimate search, there will be:
Score(T˜,Fj)=(Ij⋅QT˜) mod β=(P′j⋅Q′) mod β=(Pj⋅Q+∑i=1d+1Vj[i]⋅V′[i]) mod β=(Pj⋅Q+aj+β∗−aj) mod β=Pj⋅Q.(16)
View SourceHowever, when the the deleted documents (or new documents) are touched by newly added queries (or previous queries), there will be:
Score(T˜,Fj)=(Ij⋅QT˜) mod β=(Pj⋅Q+∑i=1d+1Vj[i]⋅V′[i]) mod β=(Pj⋅Q+β∗−aj) mod β=(Pj⋅Q−aj) mod β.(17)
View SourceRight-click on figure for MathML and additional features.Due to the randomization of the security parameter aj, the could server cannot obtain the accurate relevance score. Thus, the proposed schemes can ensure both backward privacy and forward privacy.

For summarization, the different schemes’ security level is shown in Table 1. We can easily find that privacy protection of indexes, trapdoors and documents as well as trapdoor's unlinkability can be preserved by all DSSE schemes. However, only the proposed scheme and ORAM schemes [13], [14] are able to ensure both backward privacy and forward privacy simultaneously. Besides, the proposed SEDSSE_ II solves the key sharing problem existed in general secure kNN based search schemes.

TABLE 1 Comparison of Security Level (where I and II represents SEDSSE_ I and SEDSSE_II, respectively.)

SECTION 8Performance Evaluation
In this part, we will analyze the performance of proposed schemes compared with other SSE schemes. Specifically, we compare the performance of our schemes with DSSE schemes and SSE schemes, respectively, in terms of storage complexity, updating complexity and the complexity of Index building, Trapdoor generating and Query.

8.1 Comparing with DSSE
8.1.1 Update Complexity
In the ORAM schemes [13], [14], we can see the updating complexity is high, as shown in Table 2. The general SSE schemes [9], [11] cannot support dynamic updating operations. Much better than general SSE schemes, our scheme's updating complexity is constant O(1). When some of the documents are updated by the patient, the other outsourced documents conduct no changes.

TABLE 2 Comparison of Performance (Where NN is the number of documents, and λλ is a security parameter.)

8.1.2 Storage Complexity
As shown in Table 2, the storage complexity of the proposed and ORAM schemes [13], [14] are respectively O(N2) and O(N+λ). In order to preserve corresponding security requirement, the security parameter λ's value must be large enough. As illustrated in Fig. 2, if we set λ=264 and λ=280, we can find that even the number of documents is 230, our schemes’ storage complexity is still lower. In most ORAM schemes, both the cloud server and the search user are required to store the data, which definitely spends search user's additional storage space. For the proposed SEDSSE_I and SEDSSE_II, most parts of the dataset is outsourced to cloud server, which can burden the most storage costs. The search user only need to store the number collection D¯¯¯¯ with low cost.


Fig. 2.
Comparison of storage complexity.

Show All

8.1.3 Search Complexity
Further, the proposed and ORAM [13], [14] schemes’ search complexity are respectively O(N2) and O(λ⋅log2N). As depicted in Fig. 3, even the total number of documents is 230, our schemes have lower search complexity than ORAM schemes.


Fig. 3.
Comparison of search complexity.

Show All

8.2 Comparing with SSE
8.2.1 Storage Overhead
As shown in Fig. 4, for our schemes, the size of each index/trapdoor is linear with the size of dictionary. Hence, our schemes can achieve high efficiency. In contrast, since TRSE [10] needs to encode index/trapdoor vector's each dimension by utilizing fully homomorphic encryption, the size of index/trapdoor is huge. Note that, in Query and Trapdoor generating phases, the computational and communication costs are irrelevant with the number of query keywords. Therefore, compared with several multiple-keyword schemes [23], [24], the proposed schemes achieve higher efficiency. Specifically, their overhead is linear with query keywords’ number.

Fig. 4. - 
Size of index/trapdoor.
Fig. 4.
Size of index/trapdoor.

Show All

8.2.2 Indexbuild Time
In our schemes, each dimension of vector Pj is a relevance score of keyword, i.e., Pj[i]=Score(ti,Fj). As illustrated in Fig. 5, the size of the number of documents and keyword dictionary will both influence the computation time. We introduce the number collection D to extend Pj, so the time is related to the generation of extended vector Vj. Then, with the corresponding relevance score vector, our schemes can build the index using secure kNN computation. Moreover, from Fig. 6, we can find that the time costed by building index is determined by the total number of documents and the dictionary's size. Better than TRSE [10] and MRSE [11], the proposed schemes also achieve higher computational efficiency.


Fig. 5.
Time of computing relevance score. (a) When the dictionary's size is different but the documents’ number is same, N=6000. (b) When the documents’ number is different but the dictionary's size is same, |W|=6000.

Show All

Fig. 6. - 
Time of building index. (a) When the dictionary's size is different but the documents’ number is same, $N$N=6000. (b) When the documents’ number is different but the dictionary's size is same, $|\mathcal {W}|=6000$|W|=6000.
Fig. 6.
Time of building index. (a) When the dictionary's size is different but the documents’ number is same, N=6000. (b) When the documents’ number is different but the dictionary's size is same, |W|=6000.

Show All

8.2.3 Trapdoorgen Time
For generating trapdoor, MRSE [11] first produces a vector according to the collection of search keyword T˜. Then, encrypts the vector by leveraging secure kNN scheme. Similarly, TRSE [10] creates a vector and encrypt each dimension utilizing homomorphic encryption. Our schemes also first generate the query vector Q. The time to generate the extended vector Q′ is related with the number collection D. Since the kNN computation scheme is proved secure, even the multiple queries’ vectors are the same, the trapdoors are still different. Thus, the computational overhead of proposed basic scheme and MRSE [11] are exactly the same in the phase of trapdoor generating. As depicted in Fig. 7, the time of trapdoor generating is influenced by the dictionary's size severely instead of the query keywords’ number. Therefore, the proposed schemes also perform efficient in the phase of trapdoor generating.

Fig. 7. - 
Time of generating trapdoor. (a) When the dictionary's size is different but the documents’ number is same, $|\widetilde{\mathcal {W}}|$|W˜|=20. (b) When the documents’ number is different but the dictionary's size is same, $|\mathcal {W}|=6000$|W|=6000.
Fig. 7.
Time of generating trapdoor. (a) When the dictionary's size is different but the documents’ number is same, |W˜|=20. (b) When the documents’ number is different but the dictionary's size is same, |W|=6000.

Show All

8.2.4 Query Time
As both MRSE [11] and our basic scheme leverage the secure kNN computation scheme, the query time is the same. The computational cost of query phase, as illustrated in Fig. 8, is greatly influenced by the number of documents and dictionary's size, and is almost irrelevant with query keywords’ number. We can find that the proposed schemes can also achieve efficiency in the query phase.


Fig. 8.
Time for query. (a) When the dictionary's size is different but the documents’ number is same, N=6000. (b) When the documents’ number is different but the dictionary's size is same, |W|=6000.

Show All

Overall, our schemes are efficient in terms of storage complexity, updating complexity and the complexity of Index building, Trapdoor generating and Query. Specifically, the updating overhead of our schemes can be almost negligible, which is more practical than other SSE or DSSE schemes.

Discussions. It is a promising idea to develop the approximation algorithm to help hide the key information from the aspect of privacy-preserving data mining. However, as a work mainly focuses on the encrypted searching, in this paper, we mostly pay our attention to privacy-preserving search, search functionality and search efficiency. Such a setting has been widely used in many recent related works [8], [9], [11], [25]. With an in-depth study on the problem of encrypted searching in current step, it is our intention to release the assumptions in the future to make the work applicable to privacy-preserving data mining.

SECTION 9Related Works
9.1 Static SSE
Boneh et al. firslty put forward the concept of SPE in [26] to achieve single keyword search over encrypted data with heavy computational cost. Curtmola et al. [27] refined the definition of SSE later. Boneh et al. [24] also presented a conjunctive, subset, and range query scheme over encrypted data. Recently in static searchable symmetric encryption, Wang et al. have developed the ranked keyword search scheme in [8] and proposed a novel scheme supporting similarity search in [25]. However, these schemes cannot efficiently support multi-keyword search. To overcome this problem, Sun et al. [9] also considered the relevance scores to construct a multi-keyword scheme, which performed efficient query through leveraging multidimensional tree. In [10], Yu et al. proposed a multi-keyword ranked search scheme with high security by utilizing fully homomorphic encryption. Cao et al. also presented a multi-keyword ranked search scheme [11], which can return ranked results and achieve higher efficiency. As mentioned by Ren et al. [28], there still exists many security challenges for public clouds.

9.2 Dynamic SSE
Song et al. first proposed the concept of DSSE [29], which provided an explicitly definition of searchable encryption and support insertions/deletions operations of documents. However, the overhead of documents updating is heavy. Kamara et al. [22] proposed a dynamic scheme which is able to efficiently delete and insert documents and prove the security under adaptive chosen-keyword attacks. Two schemes with sublinear search and updating time were developed in [12], [30], and such schemes have stronger security property, such as forward privacy. Moreover, several ORAM schemes [13], [14] provide almost perfect security property for querying encrypted data, which is able to ensure both backward and forward privacy with the price of high updating complexity. Recently, Yuan et al. [31] have made several significant contributions in the area of image-centric social discovery.

SECTION 10Conclusion
In this paper, we present two practical dynamic searchable encryption schemes with strong security properties. The first one can not only achieve collusion resistance between the cloud server and search users, but also can ensure both backward and forward privacy. The second one further solves the key sharing problem which widely exists in the kNN based searchable encryption scheme. Performance analysis demonstrates that our schemes can achieve better efficiency than the existing works in terms of search, storage and updating complexity. Extensive experiments demonstrate the efficiency of our schemes in term of storage overhead, index building, trapdoor generating and query.