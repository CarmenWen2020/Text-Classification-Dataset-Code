IoT (Internet of things) devices often collect data and store the data in the cloud for sharing and further processing; This collection, sharing, and processing will inevitably encounter secure access and authentication issues. Attribute based signature (ABS), which utilizes the signer’s attributes to generate private keys, plays a competent role in data authentication and identity privacy preservation. In ABS, there are multiple authorities that issue different private keys for signers based on their various attributes, and a central authority is usually established to manage all these attribute authorities. However, one security concern is that if the central authority is compromised, the whole system will be broken. In this paper, we present an outsourced decentralized multi-authority attribute based signature (ODMA-ABS) scheme. The proposed ODMA-ABS achieves attribute privacy and stronger authority-corruption resistance than existing multi-authority attribute based signature schemes can achieve. In addition, the overhead to generate a signature is further reduced by outsourcing expensive computation to a signing cloud server. We present extensive security analysis and experimental simulation of the proposed scheme. We also propose an access control scheme that is based on ODMA-ABS.
SECTION 1Introduction
Attribute based signature (ABS) is a primitive that derives from identity based signature [1]. ABS enables a signer to endorse a piece of message using a set of attributes instead of his/her unique identity, promoting the harmony between message endorsement and identity privacy preservation. In an ABS, the user uses his attribute set to query the attribute authority for private keys corresponding to certain attributes. Since an individual may have various kinds of attributes, e.g., gender, profession, address, etc., there are usually multiple attribute authorities that handle requests of different kinds of attributes. This multi-authority setting helps amortize the computational overhead in a single authority case and more importantly, enhances the security since one or some of the authorities’ compromising or corruption may not affect the others.

However, a multi-authority setting leads to difficulty regarding how to generate a common secret for signature’s generation given that authorities may not trust or communicate with each other. A feasible means is to establish a central authority that holds the common secret and allocates different parts of this secret to each attribute authority to help with private keys’ generation. However this means returns us to the disadvantages in a single authority scenario because once the central authority is compromised, the whole system will no longer be secure. Therefore, a key point in a multi-authority attribute based signature is decentralization. In this paper, we take use of the idea that is introduced in decentralized multi-authority attribute based encryption schemes [2]. The core idea is to simulate the functionality of a central authority through interactions among different attribute authorities.

Efficiency is another key point for the practical applications of the ABS. Actually, the multi-authority setting does not reduce overhead for the signer, instead, it may even increase the overhead in certain ways because the signer must interact with multiple authorities to obtain the secret keys associated with his/her whole attributes. This situation may even worsen when the signer wants to perform the message endorsing action on portable devices that lack sufficient computational power, such as the IoT devices. Fortunately, this predicament can be effectively improved if we notice that generating a signature is essentially using private keys to execute a computation on the message because now, with the assistance of Cloud computing, the signer can choose to outsource a heavy portion of the computation that must be done in the signing phase to a cloud server to reduce his/her local cost. In this paradigm, since the cloud server is commercial and may not be fully trusted, the challenge is to assure the correctness of a server’s output as well as the security of the signature protocol (e.g., unforgeability). Specifically, given an attribute based signature protocol, the signer cannot simply send all of his/her private keys to the cloud server to generate the signature. This issue is obvious because, if so, the server will be able to forge the signer’s signature on any other messages thereafter. To maintain security, one feasible means is to encode the private keys using fully homomorphic encryption; however, this will inherently bring huge computation overhead. In this paper, we divide the private keys in two parts and let the signer outsource the “big” part of them while maintaining the “small” part as a secret. The cloud server uses the “big” part of the private keys to generate a partial signature and return it to the signer. The signer can combine the other part that is generated from the “small” private key part with the partial signature to obtain the final signature. Note that, without the part of the signature that is generated from the “small” private key part, the partial signature is not a valid signature. In addition, it is necessary that the partial signature is able to be verified by the signer to maintain correctness. Fortunately, this verification can be derived from the verification of the original ABS protocol; this enables us to construct the secure and efficient ABS protocol.

1.1 Applications
As an important cryptographic primitive to maintain anonymity, (multi-authority) attribute based signature has various applications in the IoT scenario. Here, we introduce two common applications, anonymous data certification and access control. There are also other applications of ABS, such as fulfilling security requirement in attribute based messaging system [3], etc.

1.1.1 Anonymous Data Certification
In the IoT paradigm, smart devices that are equipped with sensors are connected to the cloud. The sensors continuously collect data information from the surroundings and then upload these data to the cloud for sharing or further processing. For example, in the vehicular ad hoc networks (VANETs), sensors on the vehicle collect the surrounding road condition of their location and can share it with others in the network. In the smart home system, the sensors embedded in the house collect information of the user’s house, such as temperature and light intensity, and upload the data to the cloud, after which evaluations on the data are performed to decide the optimal deployment for this house. Usually, the data that is collected by the sensors should be certificated before uploading to convince the cloud that the data are from devices that belong to a legitimate user. To do so, it is feasible to utilize the user’s identity to generate a signature for the data, that is, applying an identity based signature scheme on the data. However, this means will inherently expose the user’s identity. Notice that the exposure of the identity may lead to huge security concerns. For example, in a VANET, the road information that is uploaded by the user implicitly implies the location of the user him/herself, and an adversary can easily obtain it then infer where the user is when this uploaded information is certified by his/her certain identity. Additionally, in the smart home system, if the uploaded information is linked to a certain identity, an adversary can observe and obtain useful information about the user’s house such as when it is empty. The above concerns are caused because the linkage between data and an identity exists. However, it is currently sufficient to certify that the data originates from a legitimate user if we can prove that the data owner has some required characters (or attributes). Attribute based signature is able to realize this functionality and therefore preserves the identity privacy.

1.1.2 Access Control
Another application of attribute based signature is to provide an access control policy for IoT devices. Traditional access control schemes usually grant access by establishing a relationship between devices and individuals. However, with the increase of the amount and variety of IoT devices, it is inconvenient to define the identities that can access certain devices, especially when the device is not personal. In fact, the access to such devices is essentially defined by a number of characters (attributes) instead of specific identities. furthermore, if the user accesses a public device by verifying his/her identity, certain private information may be leaked by monitoring the device. For example his/her location information may be learned by tracking the location of the device. Since multi-authority attribute based signature implicitly provides a means to prove the legitimacy of an anonymous identity, it can be utilized to construct a flexible and privacy preserving access control scheme that is based on attributes.

1.2 Our Contribution
`In this paper, we propose a novel model called outsourced decentralized multi-authority attribute based signature (ODMA-ABS). This model captures both the security requirements of an ABS protocol and the efficiency requirement of an outsourcing computation protocol. We present the specific construction of an ODMA-ABS protocol and provide the corresponding analysis of each property, such as correctness, unforgeability, attribute privacy, efficiency, outsourcing security and privacy. We also conduct an experimental simulation to show the performance of ODMA-ABS. In addition, we propose an attribute based access control scheme, ABAC, as a specific application of ODMA-ABS and discuss the key update of ABAC.

This paper is an extension of its corresponding conference version [6]. In the revised version, the adversarial model of ODMA-ABS is enhanced from semi-honest to malicious. We propose a novel ODMA-ABS that is secure under this new model, analyze the outsourcing security and privacy, and conduct an experimental simulation to show practical performance. The proposed novel ABAC achieves nontransferability and is efficient for the user by introducing an aiding server. In addition, some of the content is extended. For example, we specifically explain the ideas behind our construction and the unforgeability proof. We formalize the definition of attribute privacy and provide rigorous proof instead of simply intuition, and more figures and tables are added for better understanding. All of the above are not shown in the conference version.

1.3 Related Works
1.3.1 Attribute Based Signature
There are a number of protocols that maintain anonymous authentication, such as group signature [4] and ring signature [5]. However, these protocols all suffer from certain disadvantages. Group signature, which requires a “manager” to address the identities of the group, may suffer from identity exposure when the “manager” is compromised. Ring signature, which requires the signer to collect all the public keys of other members in the ring, may not be convenient in many practical scenarios. Considering thiss situation, attribute based signature may play a much better role in practice. ABS was first defined and constructed in 2008 by Maji et al. [3]. The researchers presented a scheme supporting the predicate described by a monotone span program. Later, a (k,n)-threshold predicate construction was proposed by Shahandashti and Safavi-Naini [7]. In 2010, Li et al. [8] proposed another construction that achieves better efficiency than that in [7]. Futhermore, the researchers also proposed a construction for the multi-authority scenario. There are other works that focus on MA-ABS [9], [10], [11]. In 2013, Okamoto and Takashima [12] proposed the first decentralized multi-authority attribute-based signature (DMA-ABS) scheme in the random oracle model, which removes the trusted central authority of the MA-ABS scheme. Although the researchers’ scheme was as efficient as the former MA-ABS, the sizes of the private keys and signature remain very large.

1.3.2 Outsourcing Computation
Outsourcing computation was first proposed by Hohenberger and Lysyanskaya [13] and formally defined by Gennaro et al. [14]. Gennaro et al. proposed a means to use Gentry’s [15] fully homomorphic encryption (FHE) together with Yao’s [16] 2-party computation to securely outsource any circuit evaluation. Since operating FHE is very expensive, the scheme is not very practical. Later other works [17], [18], [19] were proposed to improve the performance in using FHE, but the performance is still not ideal.

To avoid using FHE, certain works have been done to seek other means to securely outsource specific kinds of computation. Regarding attribute based cryptography, Green et al. [20] proposed a scheme to outsource the decryption phase of attribute based encryption (ABE) scheme, and Zhou et al. [21] proposed a scheme to outsource the encryption and decryption of ABE. Recently, Cai et al. [22] proposed an Electronic health record system, which supports offline encryption and outsourced decryption in mobile cloud computing. In 2014, Chen et al. [23] proposed an outsourced attribute based signature (OABS) scheme. The researchers utilize the blinding technique to make attribute private keys piecewise; thus, it will preserve attribute privacy in the outsourcing paradigm. However the scheme is constructed in a single authority model. In 2017, Ren et al. [24] proposed another OABS scheme that achieves correctness verification of the outsourced signing operation; however, it remains a single authority proposal. In Table 1, we present a comparison in certain properties among different ABS schemes, including the decentralized multi-authority ABS [12], the outsourced ABS [23], the outsourced ABS with verification of outsourcing operation [24] and our ODMA-ABS.

TABLE 1 Comparison Among Different Attribute Based Signature Schemes

1.4 Paper Organization
The remaining part of the paper is organized as follows. Necessary preliminaries are provided for the proposed schemes in Section 2. The model of decentralized multi-authority attribute based signature (DMA-ABS) is defined in Section 3. The proposed outsourced decentralized multi-authority attribute based signature scheme is presented and analyzed in Section 4. An attribute based access control scheme is proposed and discussed in Section 5. Section 6 concludes the paper.

SECTION 2Preliminaries
In this section, we first introduce the notations used in this paper. Then we provide the definitions of pseudorandom function (PRF), Bilinear Map, threshold predicate for multi set and Lagrange coefficient. We also provide the computational assumptions that our protocol are based on, the co-CDH assumption and XDH assumption.

2.1 Notations
The main notations that are used in this paper are shown and explained in Table 2.

TABLE 2 Notations in this Paper

2.2 Pseudorandom Function
Our construction utilizes the pseudorandom function (PRF) [25]. Informally speaking, a PRF takes as input a random value in the domain and outputs a value that is computational indistinguishable from a truly random value in the range. We give the specific definition of the pseudorandom function family below.

Definition 1 (Pseudorandom function family).
Let F={fs|s∈{0,1}λ}λ∈N. Then F is called a family of (X(λ),Y(λ)) pseudorandom function if the following holds,

∀λ∈N,∀s∈{0,1}λ,fs:{0,1}X(λ)→{0,1}Y(λ);

∀λ∈N,∀s∈{0,1}λ,fs can be computed in polynomial time;

Pseudorandomness: for any probabilistic polynomial time algorithm A, there holds
|Pr[Afs(1λ)=1|s←U{0,1}λ]−Pr[Ag(1λ)=1|g←UR(X(λ),Y(λ))]|≤negl(λ),
View SourceRight-click on figure for MathML and additional features.where R(X(λ),Y(λ)) is the set of all possible functions g:{0,1}X(λ)→{0,1}Y(λ).

2.3 Bilinear Map
Our construction also utilizes the bilinear map. The bilinear map is a powerful tool in non-interactive authentication and has been widely applied in both signature and outsourcing computation schemes [26], [27].

Definition 2 (Bilinear map).
Let G1,G2 and GT be finite cyclic multiplicative groups of prime order p, and g1,g2 be generators of G1 and G2 respectively. A map e^:G1×G2→GT is called a bilinear map if it satisfies the following properties:

Bilinearity: it holds that
e^(ga1,gb2)=e^(g1,g2)ab(1)
View Sourcefor all a,b∈Zp.

Non-degeneracy: There exist G1∈G1,G2∈G2 such that e^(G1,G2)≠1.

Computability: There exists an efficient algorithm to compute e^(G1,G2) for any G1∈G1,G2∈G2.

We say that the bilinear group is symmetric if there exists an efficiently computable isomorphism ϕ from G1 to G2 and an efficiently computable isomorphism ϕ′ from G2 to G1. Similarly, we say that the bilinear group is asymmetric if such ϕ′ does not exist. (ϕ from G1 to G2 may or may not exists.) Our construction is based on asymmetric group where such ϕ exists.

2.4 Threshold Predicate
Our construction applies to threshold predicate scenario. We modify the definition of threshold presicate to make it suitable for multi-set scenario.

Definition 3 (Threshold predicate).
Let C∗=⋃k∈{1,…,N}C∗k be a union of attribute sets, with each C∗k of size mk. And let n=∑k∈{1,…,N}nk be an integer, where each nk is an integer in [0,mk]. A threshold predicate for multi-set is a monotone boolean function that is defined as follows.
Υn,C∗(A)={1,0,|A∩C∗k|≥nk, for k∈{1,…,N}otherwise.
View Source

We say that an attribute set A satisfies a predicate Υ if Υ(A)=1.

2.5 Lagrange Coefficient
Our construction utilizes the Lagrange interpolation.

Definition 4 (Lagrange coefficient).
Let p(⋅) be a d−1 degree polynomial, and p(1),…,p(d) be the corresponding values in d points. Write S={1,…,d}. We define the Lagrange coefficient in the computation p(x) as
Δi,S(x)=∏j∈S,j≠ix−ji−j.
View SourceRight-click on figure for MathML and additional features.

Then the polynomial p(x) can be represented as
p(x)=∑i=1dp(i)Δi,S(x).(2)
View SourceRight-click on figure for MathML and additional features.

2.6 Computational Assumption
Our construction is based on standard assumptions, the co-CDH assumption and the XDH assumption.

Definition 5 (co-CDH Assumption).
Let GB be a bilinear group generator that takes as input a parameter λ and outputs a description of a bilinear group (p,g1,g2,G1,G2,GT,e^), where p is the order, g1,g2 the generators of G1,G2 respectively, and e^ the bilinear map from G1×G2 to GT. We say that the co-CDH assumption (t,ϵ) holds if for any probabilistic polynomial t-time algorithm A there holds
|Pr[A(p,g1,g2,ga1,gb2)=gab2]|≤ϵ,
View SourceRight-click on figure for MathML and additional features.where a,b∈RZp.

Definition 6 (XDH assumption).
Let (p,g1,g2,G1,G2,GT,e^,

ϕ) be an asymmetric bilinear tuple where ϕ is a one way map from G1 to G2. We say that the XDH assumption (t,ϵ) holds in G2 if for any probabilistic polynomial t-time algorithm A there holds
|Pr[A(p,e^,ϕ,g1,g2,ga2,gb2,gab2)=1]−Pr[A(p,e^,ϕ,g1,g2,ga2,gb2,gc2)=1|≤ϵ,
View Sourcewhere a,b,c∈RZp.

Notice that the XDH assumption does not hold in symmetric bilinear groups. This is obvious since that one can map ga2 onto the element in G1 and uses bilinear map e^ to distinguish the XDH tuple. The same thing also holds for group G1 in asymmetric setting since ϕ exists.

SECTION 3Modeling ODMA-ABS
In this section, we present some relative definitions of the ODMA-ABS. Fig. 1 shows the system architecture of ODMA-ABS. We define each algorithm that is corresponding to each phase in Fig. 1.


Fig. 1.
System Architecture: “Auth1, Auth2, Auth3” refer to different attribute authorities, “User” refers to the signer who would like to generate the signature, “SCS” refers to the signing cloud server that generates partial signature for the user. The signature is verified by a verifier, who is not indicated in the figure.

Show All

3.1 Definitions
Definition 7 (Outsourced decentralized multi-authority attribute based signature).
An outsourced decentralized multi-authority attribute based signature protocol π is defined via the following five algorithms.

(PP,MSK)←Setup(λ,N): The randomized system setup algorithm takes as input a secure parameter λ, the number of attribute authorities N, and outputs the public parameter PP and the master secret key MSK for each attribute authority. This is done by interactions among the multiple authorities.

(OK,SK)←AKeyGen(PP,MSK,Au): The randomized key generation algorithm takes as input the public parameter PP, the master secret key MSK, the attribute set Au of user u and outputs the outsourcing key OK and the private key SK. Here Au=⋃k∈{1,…,N}Ak,u, where Ak,u represents the attribute subset that is certified by the kth attribute authority. This procedure is done independently by interaction between the user and each attribute authority.

(σpart,W)←Signout(OK,Au,Υn,C∗): The randomized outsourced signing algorithm takes as input the outsourcing key OK of all attribute authorities, the user’s attribute set Au, a predicate Υnk,C∗k where C∗=⋃k∈{1,…,N}C∗k and n=∑k∈{1,…,N}nk. It outputs the partial signature σpart and the corresponding witness W. This algorithm is done by the signing cloud server (SCS).

(σ,⊥)←Sign(SK,m,σpart,W,Υn,C∗): The randomized signing algorithm takes as input the private key SK, the message to-be-signed m, the partial signature σpart, the witness W, the predicate Υn,C∗ and outputs the formal signature σ if the partial signature is verified and accepted, or a symbol ⊥ if the partial signature is rejected. This is done by the user.

b←Verify(PP,σ,m,Υn,C∗): The deterministic verification algorithm takes as input the public parameter PP, the signature σ with signed message m and predicate Υn,C∗ and outputs 1 if it the signature is valid and 0 otherwise. This is done by the verifier.

Definition 8 (Correctness).
An ODMA-ABS protocol is correct if for all (PP,MSK)←RSetup(λ,N), all attribute sets {Ak}, all (OK,SK)←RAKeyGen(PP,MSK,Au), all predicate Υn,C∗, all σpart←RSignout(OK,Au,Υn,C∗), all messages m, and all σ←RSign(SK,m,σpart,Υn,C∗), the verification algorithm outputs 1 with probability 1−ϵ where ϵ is negligible.

An ODMA-ABS protocol is required to satisfy the existential unforgeability property. Consider the unforgeability experiment ExpeufF,ODMA-ABS between a challenger C and an adversary F in a selective predicate model.

Initial C receives a corrupted authorities set Kc⊆{1,…,N} and the challenge predicate Υn,C∗, where C∗=⋃k∉KcC∗k and n=∑k∉Kcnk.

Setup C runs the Setup(λ,N) algorithm. It sends PP to F and keeps MSK.

Query F is allowed to perform a series of the following queries.

Private key query: F can query C for SK with an identity u.

Outsourcing key query: F can query C for OK with attribute union set A=⋃k∉KcAk.

Signing query: F can query C for signature with message m and predicate Υ.

Forgery F outputs a tuple (m∗,σ∗,Υn,C∗).

We say that F wins if i) (m∗,σ∗,Υn,C∗) passes the verification algorithm; ii) Υn,C∗(A)≠1 for any A that has been submitted to the Outsourcing key query oracle; iii) (m∗,Υn,C∗) has not been submitted to the Signing query oracle.

Definition 9 (Unforgeability).
An ODMA-ABS scheme is (t,ϵ,n,qP,qO,qS)-unforgeable if no probabilistic polynomial t time adversary F can win the unforgeability experiment over ϵ when at most n attribute authorities are corrupted, with at most qP, qO, and qS times of private key query, outsourcing key query and signing query respectively.

An ODMA-ABS protocol is supposed to achieve attribute privacy for the signer. Informally speaking, attribute privacy requires that the signature reveals nothing about user’s identity or attribute set except for what is revealed explicitly. This holds even for the situation that the adversary gets access to the user’s attribute private keys. Former definition is based on the following experiment ExpaprF,ODMA-ABS between a challenger C and an adversary F.

Setup C runs the Setup(λ,N) algorithm. It sends (PP,MSK) to F.

Query F is provided with access to privatekeyoracle, outsourcing keyoracle and signing oracle as that in ExpeufF,ODMA-ABS.

Challenge F outputs a tuple (Au0,Au1,Υn,C∗,m), where Υn,C∗(Aui)=1 for (i=0,1). F then sends the tuple to C. C picks a random bit b∈{1,2} and runs AKeyGen algorithm with input (PP,MSK,Aub). Consequently, C gets OKb and SKb. It then runs algorithms Signout and Sign with input (OKb,Aub,Υn,C∗) and (SK,m,σpart,Υn,C∗) respectively to get a challenging signature σ∗, which is then sent back to F.

Guess Upon receiving σ∗, F outputs a bit b′∈{0,1} and wins the game if b′=b.

Definition 10 (Attribute Privacy).
An ODMA-ABS protocol achieves attribute private for the signer if no probabilistic polynomial time adversary F can win the above game with an advantage probability no less than 12+negl(λ), where negl() is a negligible function.

As an outsourcing computation protocol, the ODMA-ABS is also required to satisfy the efficiency property.

Definition 11 (Efficiency).
An ODMA-ABS scheme is efficient if the total computation cost on the signer side is less than the cost to generate the signature all by the user.

SECTION 4The proposed ODMA-ABS Protocol
4.1 Anonymous Key Issue Protocol
Our construction takes use of an anonymous key issue (AKI) protocol proposed in [28]. We would like to give a brief introduction first.

The AKI is an interactive protocol executed between a user and an attribute authority. In the AKI, a user U and an attribute authority A have access to some commonly known values, and keep some secret values. They jointly compute a value through the following steps.

Step 1: Set up the public parameters including a group G of order p, two group elements g,h∈G and a hash function that maps a string to an element in Zp.

Step 2: A general 2-party computation protocol is executed on input (u,a1) from U and β from A, where u is the hash value of the U’s identity GID, and (a1,β)∈RG. Such 2-party computation can be realized via the protocol in [29]. As a result, A obtains x:=(β+u)a1modp.

Step 3: A computes X1:=gτ/x, X2:=hατ and sends X1,X2 to U, where α,τ∈RZp.

Step 4: On receiving X1,X2, U picks a2∈RZp and computes Y:=(Xa11X2)a2. Then Y is sent to A.

Step 5: On receiving Y, A picks a γ∈RZp and computes Z:=Yγ/τ. Then Z is sent to U.

Step 6: finally, on receiving Z, U computes Z1/a2=(hαg1/(β+u))γ.

The correctness of the above protocol is easy to verify by the following equation.
Z1/a2=Yγ/(τ/a2)=(Xa1γ/τ1Xγ/τ2)=(ga1γ/xhαγ)=(hαg1/(β+u))γ.(3)
View Source

The above protocol is secure under DDH assumption assuming that the underlying 2-party computation is secure. The proof can be found in [28].

Now we are about to utilize the AKI protocol to construct the signature protocol.

4.2 ODMA-ABS Construction
The construction is based on the signature scheme of Li et at.’s [8]. In [8], a multi-authority ABS is proposed with a central authority established to allocate differen parts of a shared secret to each authority. By utilizing the AKI protocol above, the function of the central authority can be simulated by interactions among the multiple authorities. However, notice that the scheme in [8] is based on the symmetric bilinear group where XDH assumption does not hold and thus the AKI can not be used directly. So we should first change the underlying bilinear group to an asymmetric one and reconstruct a corresponding multi-authority attribute based signature protocol. After that we are able to use the AKI protocol to remove the central authority. In addition, it is observed that the resulting attribute signing keys for the user cannot reconstruct a secret without the master secret key, hence they can be outsourced to a signing cloud server (SCS) to generate a partial signature and the user can then combine this partial signature with the other part that is generated from the master secret key to fulfill the formal signature, which will greatly reduce the computational overhead of the user. However, since the SCS is commercial and cannot be fully trusted, it is necessary for the user to check whether the SCS has performed the partial signature computation correctly, and this check is better to operate on the spot. We address this problem by requiring the SCS to generate an auxiliary witness for the user to verify the validity of the partial signature. The verification is passed only when the partial signature is correctly generated. Additionally, to reduce the computational overhead of the user, we let the SCS do most of the computations required in the verification and output the corresponding results as the witness.

We will present the details of each algorithm. Let the Lagrange coefficients be as that in Definition 4. Then the proposed ODMA-ABS scheme is shown by the following five algorithms as follows.

Setup(λ,N): On input the security parameter λ, and a common reference string (CRS), the N attribute authorities generate an admissible asymmetric bilinear group denoted by e=(p,g1,g2,G1,G2,GT,e^(⋅,⋅),ϕ(⋅)) and two collision resistant Hash functions (CRHF) H:{0,1}∗→Zp and H′:{0,1}∗→G2. The former maps user’s global identity GID to an element in Zp (denoted by u, i.e., H(GID)=u) and the latter maps the message to be signed to an element in G2. Select an admissible G2∈RG2 among the authorities. Next, for each attribute authority k∈{1,…,N}, redefine the attributes in universe {Uk}k∈{1,…,N} as elements in Zp, and define a dk-element default attribute set Ck. Choose a CRHF Hk:{0,1}∗→G2, which maps each attribute i to the element in G2. Select xk,vk∈RZp and compute yk=Gxk2,Yk=gvk1,Zk=e^(Yk,G2).

Next the authorities pairwise engage a two party key exchange protocol such that authority k and j share a unique seed skj∈Zp, which is only known to them two but not to any other authority i∉{k,j}. Specially, define skj=sjk. Then the pseudorandom function between authority k and j for user u is defined as
PRFkj(u)=Gxkxj/(skj+u)2,u∈Zp.(4)
View Source

Finally, the public parameter
PP=({yk,Yk,Zk,Hk,dk}k∈{1,…,N},H,H′,e^,G2),
View Sourceand the master secret key
MSK=({xk,vk,{skj}j∈{1,…,N}∖{k}}k∈{1,…,N}).
View SourceRight-click on figure for MathML and additional features.

AKeyGen(PP,MSK,Au): To generate the key on attribute set Au=⋃k∈{1,…,N}Ak,u, user u interacts with authority k that works as follows.

For j∈{1,…,N}∖{k}, let
g=yxkj,h=G2,α=δkjRkj,β=skj,γ=δkj,
View SourceRight-click on figure for MathML and additional features.where Rkj is selected randomly from Zp by k, δkj=1 if k>j and δkj=−1 otherwise. Then N−1 times of anonymous key issuing protocols between u and k are executed independently. As a consequence, u gets
DkjDkj=GRkj2PRFkj(u),k>j=GRkj2/PRFkj(u),k<j.
View Source

Authority k randomly selects a dk−1 degree polynomial pk(⋅) such that
pk(0)=vk−∑j∈{1,…,N}∖{k}Rkj,(5)
View Sourceand for each attribute i∈Ak,u∪Ck and each rk,i randomly selected from Zp, k computes
dk,i0=Gpk(i)2Hk(i)rk,i,dk,i1=grk,i1.
View Source

Authority k outputs the user’s outsourcing key
OKk=({dk,i0,dk,i1}i∈Ak,u∪Ck),
View Sourceand the user’s private key
SKk=({Dkj}j∈{1,…,N}∖{k}).
View Source

Finally, the user’s outsourcing keys and private keys are
OK={OKk}k∈{1,…,N},SK={SKk}k∈{1,…,N}.
View Source

Signout(OK,Au,Υn,C∗): For an outsourced signing query from user u, with OK={OKk}k∈{1,…,N}, Au=⋃k∈{1,…,N}Ak,u and predicate Υn,C∗(⋅), where C∗=⋃k∈{1,…,N}C∗k, n=∑k∈{1,…,N}nk, |C∗k|=mk and nk could be 0, the SCS works as follows.

For each k∈{1,…,N}, select a random nk-element attribute subset A′k⊆Ak,u∩C∗k, and a (dk−nk)-element default attribute subset C′k⊆Ck. Define Sk=A′k∪C′k, and then |Sk|=dk. The explanation of these different kinds of attribute sets managed by authority k is listed together in Table 3 for better understanding.

TABLE 3 Explanation of Different Sets Managed By Authority k k
Table 3- 
Explanation of Different Sets Managed By Authority $k$

k


Select mk+dk−nk random values sk,1,…,sk,mk+dk−nk from Zp, and compute the following items
σ′0σ′k,i=∏1≤k≤N⎛⎝∏i∈SkdΔi,Sk(0)k,i0∏i∈C∗k∪C′kHk(i)sk,i⎞⎠={dΔi,Sk(0)k,i1gsk,i1,gsk,i1,i∈Ski∈C∗k∖A′k.
View Source

Compute the following terms in addition.
W1=e^(g1,σ′0),W2=∏1≤k≤N⎡⎣∏i∈C∗k∪C′kZke^(σ′k,i,Hk(i))⎤⎦.
View Source

Finally, output the partial signature together with the corresponding witness
σpart=(σ′0,{{σ′k,i}i∈C∗k∪C′k}k∈{1,…,N}),W=(W1,W2).
View SourceRight-click on figure for MathML and additional features.

Sign(SK,m,σpart,W,Υn,C∗): To generate the formal signature after receiving σpart from SCS and owning (SK,m,Υn,C∗), u works as follows.

Compute
Du=∏(k,j)∈{1,…,N}×{1,…,N}∖{k}Dk,j.
View SourceRight-click on figure for MathML and additional features.

Check if the following equation holds.
e^(g1,Du)⋅W1=?W2.(6)
View Source

If the above equation holds, then select a random value s from Zp and compute
σ0=Du⋅σ′0⋅H′(m∥Υn,C∗)sσs=gs1,σk,i=σ′k,i.
View Source

Finally, output the final signature as
σ=(σ0,σs,{{σk,i}i∈C∗k∪C′k}k∈{1,…,N}).
View SourceRight-click on figure for MathML and additional features.

Verify(PP,σ,m,Υn,C∗): On input the signature σ, the message m with predicate Υn,C∗ and let v=H′(m∥Υn,C∗), the verification is processed by checking the following equation
e^(g1,σ0)=?∏1≤k≤N⎡⎣∏i∈C∗k∪C′kZke^(σk,i,Hk(i))⎤⎦⋅e^(σs,v).(7)
View SourceRight-click on figure for MathML and additional features.Output 1 and accept the signature if the above equation holds; otherwise 0 and reject the signature.

Remark.
The verification of Equation 6 is an extension compared with the scheme in the conference version. Note that by multiplying e^(g1,v) on each side of Equation (6) we get Equation (7). Thus the correctness of this verification procedure is guaranteed. Also, since W1,W2 are generated from the partial signature and public parameter, thus they will not affect the security of the protocol. In addition, the verification of partial signature only requires one pairing operation and one multiplication operation. So this does not affect the efficiency of the whole scheme.

4.3 Security Analysis
We present analysis of correctness, unforgeability, attribute privacy, efficiency respectively, and outsourcing security and privacy.

4.3.1 Correctness
Correctness is shown in the following theorem.

Theorem 1.
The proposed ODMA-ABS scheme is correct.

Proof.
Let Du=∏(k,j)∈{1,…,N}×{1,…,N}∖{k}Dk,j, Sk=A′k∪c′k and v=H′(m∥Υn,C∗). The correctness of our proposed scheme is proved by the following equation.
e^(g1,σ0)=e^(g1,Du⋅∏k⎛⎝∏i∈SkdΔi,Sk(0)k,i0∏i∈C∗k∪C′kHk(i)sk,i)vs⎞⎠=e^(g1,g∑kvk2∏k⎛⎝∏i∈SkHk(i)rk,iΔi,Sk(0)∏i∈C∗k∪C′kHk(i)sk,i)vs⎞⎠=e^(g1,g∑kvk2)⋅∏k⎛⎝∏i∈C∗k∪C′ke^(σk,i,Hk(i))⎞⎠⋅e^(g1,vs)=∏1≤k≤N⎡⎣∏i∈C∗k∪C′kZke^(σk,i,Hk(i))⎤⎦⋅e^(σs,v).(8)
View SourceRight-click on figure for MathML and additional features.

4.3.2 Unforgeability
The ODMA-ABS protocol achieves unforgeability. We have the following theorem.

Theorem 2.
The proposed ODMA-ABS protocol is existentially unforgeable under co-CDH assumption.

Proof.
The intuition behind the reduction to co-CDH problem is as follows: According to the unforgeability definition, given a co-CDH tuple (ga1,gb2), We expect to construct a simulator that solves the co-CDH problem by utilizing an adversary who is able to forge the ODMA-ABS as a subroutine. The simulator needs to simulate the response of the attribute authority when receiving a query from the adversary and after that gives a co-CDH solution from the signature that the adversary forges. Note that in the multi-authority setting, the adversary is allowed to corrupt a number of attribute authorities. Here we prove the case when N−1 attribute authorities are corrupted. Since the corrupted authorities are all set before setup stage, the simulator only needs to simulate the honest authority to answer the query of the adversary. The specific procedure is presented below.

Let F be an adversary that has a non-negligible advantage ϵ in breaking the unforgeability of the proposed ODMA-ABS protocol. And suppose that F makes at most qHk,qH′,qP,qO and qS times of queries to the hash functions Hk (of authority k), H′, the private key generation oracle, the outsourcing key generation oracle and the signing oracle respectively. Given a co-CDH tuple (ga1,gb2,e^) and to compute gab2, the simulator S executes the simulation as follows.

Initial S receives a corrupted authorities set {1,…,N}∖{k} and a challenge predicate Υnk,C∗k. Here the predicate is restricted for only authority k since other authorities are corrupted and can generate the corresponding signature for any predicate.

Setup Let the default attribute set denoted by Ck for authority k. S selects a dk−nk subset C′k⊆Ck and publishes G1=ga1,G2=gb2 to F. k picks xk∈RZp and interacts with other k−1 authorities and shares the secret seeds skj. Publish yk=Gxk2 to F.

Query S initializes an integer j=0, an empty table L and an empty set U, F is allowed to issue queries as follows.

Hk-query. S maintains a list L1 to store the answers to the hash oracle Hk. On receiving a query i, C first checks the list L1 and returns the corresponding answer if the same value has been queried. Otherwise, S simulates as follows.

If i∈C∗k∪C′k, it chooses a βk,i∈Zp and answers Hk(i)=gβk,i2.

If i∉C∗k∪C′k, it chooses αk,i,βk,i∈Zp and answers Hk(i)=G2αk,igβk,i2.

After returning Hk(i), S adds the tuple (i,Hk(i)) onto the list L1.

H′-query. S picks a value δ∈R{1,…,qH′} and maintains a list L2 to store the answers to the hash oracle H′. On receiving the lth query ml∥Υnl,C∗l for 1≤l≤q2 and 1≤nl,k≤dk, where nl=∑k∉Kcnl,k, S first checks the list L2 and returns the corresponding answer if the same value has been queried. Otherwise, S simulates as follows.

If l=δ, it chooses a β′k,δ∈Zp and answers H′(ml∥Υnl,C∗l)=gβ′k,δ2.

If l≠δ, it chooses αk,l,βk,′l∈Zp and answers H′(ml∥Υnl,C∗l)=G2α′k,lgβ′k,l2.

After returning H′(ml∥Υnl,C∗l), S adds the tuple (ml∥Υnl,C∗l,H′(ml∥Υnl,C∗l)) onto the list L2.

Private key query. On receiving a secret key query of identity u, S first sets U=U∪{u} and maintains a list L3. Then it checks if (u,SK) exists in L. If so, return SK. Otherwise, S performs the same operation as that in ODMA-ABS protocol. This is because the secret key set {xk} is not invalid. As a consequence, F receives Dkj=GRkj2PRFkj(u) for k>j and Dkj=GRkj2/PRFkj(u) for k<j, where Rkj is randomly selected from Zp by C. Finally, after returning SK, S adds the tuple (u,SK) onto the list L3.

Outsourcing key query. On receiving an outsourcing key query of attribute set Ak, S sets j=j+1 and maintains a list L4. Then S simulates as follows.

If |Ak∩C∗k|<nk, S chooses three sets Γ,Γ′,S such that Γ=(Ak∩C∗k)∪C′k, |Γ′|=dk−1 and Γ⊆Γ′⊆Ak∪C′k, S=Γ′∪{0}. Here we assume |Ak|>nk. Then for i∈Γ′, S chooses τk,i,rk,i∈RZp and simulates
{dk,i0=ϕ(G1)τk,iHk(i)rk,idk,i1=grk,i1.
View SourceFor i∈(Ak∪Ck)∖Γ′, let Rk=∑j∈{1,…,N}∖{k}Rkj, rk,i=r′k,i−aΔi,S(0)αk,i where r′k,i∈RZp and simulate
⎧⎩⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪dk,i0=dk,i1=ϕ(G1)∑j∈Γ′τk,jΔj,S(i)−(Rk+βk,iαk,i)Δ0,S(i)G2αk,ir′k,igβk,ir′k,i2G1−Δ0,S(i)αk,igr′k,i2.
View Source

If |Ak∩C∗k|≥nk, C chooses a1 and a random polynomial pk(⋅) with pk(0)=a1 and simulates OKk for i∈Ak∪Ck as
(dk,i0,dk,i1)=(ϕ(G1)pk(⋅)Hk(i)rk,i,grk,i1),
View Sourcewhere rk,i∈RZp.

Signing Query. On receiving a signing query on (m,Υn′,C∗), S first simulates the outsourced signing phase for corrupted authorities j∈{1,…,N}∖{k}. Since all keys corresponding to corrupted authorities are well prepared, the simulation of σj,0 and σj,i executes just the same as that in the outsourced signing phase of ODMA-ABS protocol, where σj,0 represents the factors to construct σ′0 except the part generated from authority k’s OK. To simulate the part of k’s with query (m,Υn′,C∗), C checks whether |Ak∩C∗k|<nk. If so, S executes the above private key query and outsourcing key query once again and generates a signature with other k−1 part normally as that in the protocol. Otherwise, i.e., |Ak∩C∗k|≥nk, if H′(m∥Υn,C∗)=gβ′k,δ2, the simulation is aborted. Otherwise, assume that H′(m∥Υn,C∗)=G2α′k,lgβ′k,l2, then S selects a n′k-element subset C^∗⊆C∗k and a (dk−n′k)-element subset C′′k⊆Ck. Let sk,i=s′k,i−aα′k,l, Sk=C^∗∪C′′k and the signature is simulated as follows:
σ0σk,iσs=∏j∈{1,…,N}∖{k}σj,0∏i∈Sk[Hk(i)rk,iΔi,S(0)]∏i∈C∗k∪C′′k[Hk(i)sk,i]G2α′k,ls′k,lϕ(G1)−β′k,lα′k,lgβ′k,ls′k,l2={grk,iΔi,Sk(0)+sk,i1,gsk,i1,i∈Ski∈C∗k∖C^∗=G−1α′k,l1gs′1,
View Sourcewhere s′,rk,i,sk,t∈RZp for i∈C^∗∪C′′k, t∈C∗∪C′′k and {σj,i}j∈{1,…,N}∖{k} remain the same as that in ODMA-ABS protocol. Finally, S returns simulated signature (σ0,σs,{{σj,i}i∈C∗j∪C′′j}j∈{1,…,N}) to F. Here we claim that σ0 is correctly simulated based on the following equation
σ0====∏j∈{1,…,N}∖{k}σj,0∏i∈Sk[Hk(i)rk,iΔi,Sk(0)]∏j∈C∗k∪C′′k[Hk(i)sk,i]G2α′k,ls′k,lϕ(G1)−β′k,lα′k,lgβ′k,ls′k,l2ϕ(G1)b∏j∈{1,…,N}∖{k}σj,0∏i∈Sk[Hk(i)rk,iΔi,Sk(0)]∏i∈C∗k∪C′′k[Hk(i)sk,i]H′(m∥Υn′,C∗)sϕ(G1)Rk∏j∈{1,…,N}∖{k}σj,0∏i∈Sk[dΔi,Sk(0)k,i0]∏i∈C∗k∪C′′k[Hk(i)sk,i]H′(m∥Υn′,C∗)sDu∏1≤j≤N⎡⎣⎢∏i∈SjdΔi,Sj(0)j,i0∏i∈C∗j∪C′′jHj(i)sj,i⎤⎦⎥H′(m∥Υn′,C∗)s.(9)
View Source

Forgery After performing the query phase, F outputs a forged signature σ∗ on message m∗ with predicate Υn,C∗. If the associated default attribute set is not C′k or H′(m∥Υn′,C∗)≠gβ′k,δ2, S will abort. Otherwise the forged signature passes the verification algorithm which means,
e^(g1,σ∗0)=∏1≤j≤N⎡⎣⎢∏i∈C∗j∪C′jYje^(σ∗j,i,Hj(i))⎤⎦⎥e^(σ∗s,H′(m∗∥Υn′,C∗))=∏1≤j≤N⎡⎣⎢∏i∈C∗j∪C′je^(σ∗j,i,Hj(i))⎤⎦⎥∏1≤j≤NZje^(σ∗s,H′(m∗∥Υn′,C∗))=∏1≤j≤N⎡⎣⎢∏i∈C∗j∪C′je^(σ∗j,i,gβj,i2)⎤⎦⎥e^(G1,G2)∏j∈{1,…,N}∖{k}Zje^(σ∗s,gβ′k,δ2)).(10)
View SourceThen S can compute gab2 as,
gab2=σ∗0∏j∈{1,…,N}∖{k}Gvj2∏i∈C∗k∪C′k(ϕ(σ∗k,i)βk,i)ϕ(σs∗)β′k,δ.(11)
View SourceRight-click on figure for MathML and additional features.

Assume that F breaks the unforgeability of the proposed ODMA-ABS protocol in t time with probability ϵ. Then we can build a simulator to solve the co-CDH problem in t′ time with probability ϵ′, where t′≈(∑kqHk+qH′+N(N−1)qP+2|AO¯¯¯¯¯¯¯|qO+32∑k(|C∗k¯¯¯¯¯¯|+dk−nk¯¯¯¯¯)qS)te and ϵ′=ϵqH′(dk−nkdk−1). Here AO¯¯¯¯¯¯¯ represents the average number of attributes in queried set in outsourcing key query respectively. C∗k¯¯¯¯¯¯ and nk¯¯¯¯¯ represent the average values of the predicate parameters in signing query. 1qh′ and 1(dk−nkdk−1) represent the probabilities of which the cases “the associated default attribute set is C′k and H′(m,Υn′k,C∗k)=gβ′k,δ2” happen respectively. What is more, te represents the time to perform a single-based exponentiation operation in G1 or G2, and we assume without loss of reasonability that one multi-based exponentiation which multiples up to 2 single-based exponentiation takes roughly the same as a single-based exponentiation [23].

4.3.3 Attribute Privacy
The ODMA-ABS also achieves attribute privacy.

Theorem 3.
The proposed ODMA-ABS protocol is attribute private.

Proof.
The proof of the theorem is simple. In fact, the core of our construction is that any of the values of dk attribute points can reconstruct the polynomial by Lagrange interpolation. And we simply take nk attributes from the user’s attribute set (also belong to the predicate attribute set) and dk−nk attributes from the default attribute set. Thus, it is obvious that for attribute sets Au0 and Au1 that both satisfy the predicate, they both catch such dk elements that together with some dk−nk elements from the default attribute set can retrieve the value of the polynomial at point 0 and furthermore generate a valid signature. This indicates that the valid signature do not reveal which attribute set it takes use of. Assume without loss of generality that nk=mk, we present the formal proof below.

Setup. The challenger C chooses a security parameter λ and runs setup algorithm in the ODMA-ABS scheme to generate
PP=({yk,Yk,Zk,Hk,dk}k∈{1,…,N},H,H′,e^,G2),MSK=({xk,vk,{skj}j∈{1,…,N}∖{k}}k∈{1,…,N}).
View SourceIt then publishes theme to adversary F.

Query. F is provided with access to privatekeyoracle, outsourcingkeyoracle and signing oracle. Since the master secret key is given to adversary. The simulation of the oracle response is obvious. We omit it here.

Challenge After querying phase, F outputs a tuple (Au0,Au1,Υn,C∗,m), where Υn,C∗(Aui)=1 for (i=0,1), i.e., C∗⊂Aui for i=0,1. The tuple is then sent to C. C randomly picks a bit b∈{0,1} to determine which attribute set is used to generate the signature. After that C chooses a (dk−nk)-element default attribute subset C′k⊆Ck for each k∈{1,…,N} and runs the Signout and Sign algorithms accordingly. Consequently, the challenging signature σ∗ is generated and sent to F.

Guess F outputs a bit b′ as a guess to which attribute is used to generate the challenging signature.

Note that in the Challenge phase, since C∗⊂Aui for i=0,1, we have A′k⊆Ak,ui∩C∗k=C∗k for i=0,1.With the assumption that nk=mk and the fact that |A′k|=nk, we have A′k=C∗k. Thus after running the Signout and Sign algorithms, the challenging signature σ∗ is of the following form, by letting A′k=C∗k.
σ∗=(σ0,σs,{{σk,i}i∈C∗k∪C′k}k∈{1,…,N}),
View Sourcewhere
σ0=∏1≤k≤NGvk2(∏i∈C∗k∪C′kHk(i)rk,iΔi,Sk(0)+sk,i)⋅H′(m∥Υn,C∗)s,(12)
View Sourceand
σk,i=grk,iΔi,Sk(0)+sk,i1, for i∈C∗k∪C′k,k∈{1,…,N}.(13)
View Sourceσs=gs1 remains the same as that in the ODMA-ABS scheme.

Based on the Lagrange interpolation function, it is easy to see that the challenging signature σ∗ can be generated by secret keys produced from either attribute set Au0 or Au1. In another word, any signature generated by secret keys produced from Au0 can also be generated by secret keys produced from Au1. Thus given a valid signature and without extra information, the adversary is not able to distinguish which set of Aui (i∈{0,1}) is used to generate it with a probability better than 12+negl(λ), which means the attribute privacy for signer holds.

4.3.4 Efficiency
The ODMA-ABS protocol achieves the efficiency requirement of an outsourcing computation scheme.

Theorem 4.
The proposed ODMA-ABS protocol is efficient.

Proof.
It is easy to see that without SCS, the extra computations that the signer needs to operate are the same as that in the Signout and the computation that the sigher saves is just the checking of Equation (6). It is obvious that the extra computations are far more expensive than the saved one. This indicates that the efficiency is satisfied. More details of the simulated experiment will be illustrated to show the efficiency in Section 4.4.

4.3.5 Outsourcing Security and Privacy
As an outsourcing computation protocol, our ODMA-ABS also achieves the property of outsourcing security. In an outosurcing protocol, security implies that an untrusted worker (i.e., cloud server) is unable to make the user accept an incorrect result that it outputs with non-negligible probability. And for ODMA-ABS, this means that an untrusted server, if not honestly executing the Signout algorithm, is unable to output a partial signature that passes the user’s verification (i.e., Equation (6)) with non-negligible probability. To prove that outsourcing security holds for ODMA-ABS, we notice that the verification of outsourcing procedure (i.e., Equation (6)) is equivalent to the verification of final signature (i.e., Equation (7)). So we would like to reduce the outsourcing security to ODMA-ABS unforgeabilility. We claim that an adversarial cloud server, who has the outsourcing key that is related to singer’s attribute set Au, is not able to forge a valid signature. Consider the following two cases.

The cloud server would like to forge a signature for some predicate Υ that satisfies Υ(Au)=0. This is the same scenario as that in the ungorgeability experiment, with the difference that the adversary is unable to access the private key oracle. According to Theorem 2, the adversary cannot forge a valid signature, even if it is able to access the private key oracle.

The cloud server would like to forge a signature for the predicate Υ^ that satisfies Υ^(Au)=1. Notice that this is no longer identical to the unforgeability experiment. To prove the unforgeability in this situation, we consider a multi-authority ABS protocol. In the new MA-ABS, a central authority (indicated by authority 0) holds a secret key SK that is identical to the SK in ODMA-ABS. This SK is associated with the attribute that is unique for each user. If we mark this attribute as iu then the user’s attribute set will become A′u=Au∪iu. Also, the central authority allocates different master secret keys to each attribute authority k (k∈{1,…,N}). The authority k uses its unique master key to generate attribute private key that is identical to OKk in ODMA-ABS. Other algorithms in MA-ABS remains the same as that in ODMA-ABS. Such MA-ABS is equivalent to the one proposed in [8]. If we consider the same adversarial behavior in this MA-ABS, it will be forging a valid signature for the predicate Υ^ that satisfies Υ^(Au)=0. With a similar method in [8] and the unforgeability proof of ODMA-ABS, it is easy to prove the unforgeability of the corresponding MA-ABS protocol.

Above all, the security of the outsourcing procedure is proved.

As to privacy, the cloud server gets the outsourcing keys of the user. However, these outsourcing keys include nothing that is relative to the user’s identity u. u is embedded in SK that is kept secret by the user. So the privacy of the user’s identity is preserved.

4.4 Performance
To evaluate the performance of the proposed scheme, we present theoretical analysis of storage complexity and experimental simulation of computation and communication overhead.

4.4.1 Theoretical Analysis of Storage Complexity
For the signer, the storage overhead involves private keys SK and outsourcing keys OK that are returned by attribute authorities, partial signature σpart that is returned by the signing cloud server, and the final signature σ. To be specific, let |G| represent the length of the element in the group used in ODMA-ABS protocol, i.e., |G|=poly(λ). We show a comparison between ODMA-ABS and chen et al.’s OABS [23] with respect to key size and signature size in Table 4. In the table, ik,u=|Ak,u|, dk,nk,mk refer to the same as that in the ODMA-ABS protocol, and iu,d,n,m refer to the corresponding ik,u,dk,nk,mk in our multi-authority setting. From the table, it is easy to tell that the storage complexities of ODMA-ABS and OABS are both O(poly(λ)). Also, for the attributes of the same signer, we have iu=∑Nk=1ik,u. In practice, it is acceptable to have the values of nk and mk satisfying n=∑Nk=1nk and m=∑Nk=1mk. So if we set proper values for dk, we can get an ODMA-ABS that is comparable with OABS [23] in storage overhead.

TABLE 4 Comparison with Respect to Key Size and Signature Size
Table 4- 
Comparison with Respect to Key Size and Signature Size
4.4.2 Experimental Results for ODMA-ABS
In this part, we analyze the results of the experimental simulations for each algorithm in the proposed ODMA-ABS scheme. Notice that there are three entities involved in the experiment, the attribute authorities, the signer, and the signing cloud server. The attribute authorities are simulated on a Linux machine with Intel (R) Core (TM) i7-6550U CPU processor running at 2.50 GHz and 4 GB RAM; The signer is simulated on a virtual machine with Intel (R) Core (TM) i7-8550U CPU processor running at 1.80 GHz and 512 MB RAM; And the signing cloud server (SCS) is deployed in the public cloud provided by our institution with the following configuration shown in Table 5. The bandwidth between user and cloud server is 200 Mbps. The Verify algorithm is simulated on a Linux machine with Intel (R) Core (TM) i7-6550U CPU processor running at 2.50 GHz and 4 GB RAM. When implementing each algorithm in the proposed protocol, C programming language with the Pairing Based Cryptography Library-0.5.14 (PBC Library-0.5.14) is used.

TABLE 5 Cloud Configuration

In the experiment, We implement three schemes, the OABS [23], the original DMA-ABS and the proposed ODMA-ABS. The original DMA-ABS is constructed simply in the following ways. (i) The Setup, KeyGen and Verify algorithms remain unchanged compared with ODMA-ABS. The same Signout algorithm is performed by the signer instead of being outsourced to the SCS. (ii) The computation of terms W1,W2 and the verification of outsourcing results are no longer needed by either the SCS or the user. By comparing the original DMA-ABS with ODMA-ABS, we show a computation overhead reduction by means of outsourcing technology. And by comparing OABS [23] with ODMA-ABS, we show that the computation and communication overhead of the two schemes are comparable, while ODMA-ABS achieves better properties in security and privacy preservation. Now we give more details about the experiments of each algorithm. We fix the number of attribute authorities in DMA-ABS and ODMA-ABS N=3.

The Setup algorithms are performed by the attribute authority(ies). In OABS [23], there is only one authority and we just need to simulate the deployment in this authority. When it comes to DMA-ABS and ODMA-ABS, there are multiple authorities. And each authority not only executes its own operation but also interacts with other ones. We claim that the internal operation of each authority can be executed in parallel. In the Setup phases of all the three schemes, the variables that affect the time cost are d (dk) and |U| (|Uk|), i.e., the orders of the default attribute set and the attribute universe respectively. It is reasonable to have |U|=∑k|Uk| because multiple authorities just classify and manage different kinds of attributes, while not making the whole attributes universe increase. But it is improper to have d=∑kdk because the value of dk is also associated with the security of the protocol and should not be much smallers than d. In this experiment, we let dk=d. This may result in a little more storage burden for ODMA-ABS compared with OABS [23]. We present a time cost comparison of Setup algorithms among three schemes in Fig. 2a by choosing dk=10,20 respectively, and |Uk| varying from 20 to 60. The result shows that even when we set d=dk, which makes ∑kdk>d, our ODMA-ABS still achieves a better performance than OABS. This is because in ODMA-ABS the deployment procedures inside all authorities are executed in parallel, and the interactions among authorities are much less time-consuming than the deployment procedures. Fig. 2a also shows that the time costs of DMA-ABS and ODMA-ABS are almost the same. This is because the two Setup algorithms in DMA-ABS and ODMA-ABS remain the same.


Fig. 2.
Efficiency Comparison for Setup, KeyGen, Signing and Verify Among OABS, ODMA-ABS and DMA-ABS.

Show All

In the KeyGen phase, the variables that affect the time cost become d (dk) and |Au| (|Ak,u|). In the experiment, we also choose dk=d=10,20 respectively, and |Ak,u| varying from 8 to 20. Notice that |Au|=∑k|Ak,u| since the user’s attribute set remains identical in different schemes. The result of time cost is shown in Fig. 2b. From the figure we can see that our ODMA-ABS achieves a better performance than OABS in KeyGen time. This is because in ODMA-ABS the attribute authorities can generate user’s attribute in parallel. Also, the KeyGen algorithms in DMA-ABS and ODMA-ABS are still idnetical, which results in little difference of time cost between ODMA-ABS and DMA-ABS.

In the Signing phase, the user needs to interact with the signing cloud server (SCS). The total time cost in the whole procedure involves communication part and computation part. The variables that affect the communication cost are d (dk) and |Au| (|Ak,u|) as is shown in Table 4. And the variables that affect the computation cost become n (nk) and m (mk), i.e., the threshold values and the orders of the attribute set in the predicate. In this experiment, we assume that the certain user has obtained the keys from the attribute authority(ies) and would like to generate a signature with respect to the predicate Υn,C∗, where |C∗|=m and n=∑Nk=1nk, m=∑Nk=1mk. Under such circumstances the values of d (dk) and |Au| (|Ak,u|) are fixed and the values of n (nk) and m (mk) are changeable. The simulation of the algorithms in three different schemes are conducted in several cases for d=dk=10, |Ak,u|=10, nk=5,10, mk=20,30,40 respectively. The result is shown in Fig. 2c, where “com.” is short for “communication”. Comparing the performance of ODMA-ABS with DMA-ABS, it is obvious to see that the total time cost to generate the signature is reduced by utilizing outsourcing technique, and the reduction is much more remarkable with respect to the user’s overhead. This is consistent with our analysis in Section 4.3.4. Comparing the performance of ODMA-ABS with OABS, we can see that the performance on the signer side in ODMA-ABS is better than that in OABS. This is because in ODMA-ABS the signer just needs to multiply the secret key by σpart, while the signer in OABS has to deal with another private key pair associated with the default attribute, which is much more time-consuming. However, due to the fact that d<∑kdk, the communication and SCS’s computation cost in ODMA-ABS are more than that in OABS. Actually, when we choose a smaller value for dk to have d=∑kdk, the performance of communication and SCS’s computation cost in both schemes can become comparable, while the advantage of ODMA-ABS in signer’s overhead still maintains. We consider it as a trade-off between efficiency and security.

Finally, in the Verify phase, the variables that affect the time cost are d (dk),n (nk) and m (mk). More specifically, by observing Equation (7) we can deduce that the time cost of Verify algorithm is proportional to the value m+d−n (mk+dk−nk). Similar with the assumption in the Signing phase, we fix dk=d=10 and varying the values of nk and mk with nk=5,10, mk from 20 to 60. The result is shown in Fig. 2d. We can see that the performance of ODMA-ABS and DMA-ABS are almost identical since the two Verify algorithms in both schemes remain the same. And the performance of OABS is better than the two decentralizing schemes. This is still because of the values we choose for d and dk.

SECTION 5An Access Control Scheme Based on ODMA-ABS
In this section, we discuss the applications of ODMA-ABS that can be used in the IoT scenario. As introduced in previous section, (multi-authority) attribute based signature can provide anonymous certification of data and access control for IoT devices. To realize access control for IoT devices, we design an attribute based access control (ABAC) scheme that is derived from the idea of the proposed ODMA-ABS.

5.1 Construction of the Attribute Based Access Control scheme
There are usually three kinds of entities in the attribute based access control system: the server that stores resource, the user who would like to access certain resource in the server and the attribute authorities that issue private keys for the user. We will design the ABAC scheme in decentralized multi-authority setting. In ABAC, the user can request attribute private keys from each attribute authority. Then the user generates corresponding proofs to show that his/her attributes satisfy certain predicate and sends them to the server for verification. One concern in this process is that the user may share some of his/her attribute private keys with others to let them be able to have the same access to certain resource. To address this, we introduce a unique secret key that is related to the user. The user needs to generate a proof of this secret key together with his/her attributes to prove his/her legitimate identity. This proof generation is easy to conduct in the asymmetric bilinear group. In addition, the user’s computational overhead to generate the proof of the legitimate identity can be further reduced by outsourcing. Since the outsourcing technique is similar with that in the ODMA-ABS, it will be omitted in the following construction. Our ABAC scheme involves three phases that work as follows.

Setup. On input the security parameter λ, and a common reference string (CRS), the N attribute authorities generate an admissible asymmetric bilinear group denoted by e=(p,g1,g2,G1,G2,GT,e^(⋅,⋅),ϕ(⋅)) and two collision resistant Hash functions (CRHF) H:{0,1}∗→Zp, H′:{0,1}∗→G2. The hash functions are similar with that in the ODMA-ABS scheme. Select an admissible G2∈RG2 among the authorities. For each attribute authority k∈{1,…,N}, redefine the attributes in universe {Uk}k∈{1,…,N} as elements in Zp, and define a dk-element default attribute set Ck. Choose a CRHF Hk:{0,1}∗→G2 that maps each attribute i to the element in G2. Select xk,vk∈RZp and compute yk=Gxk2,Yk=gvk1,Zk=e^(Yk,G2). Next the authorities pairwise engage a two party key exchange protocol as that in ODMA-ABS and consequently authority k and j share a unique seed skj∈Zp that satisfies skj=sjk.

Finally, output the public parameter and the master secret key as
PP=({yk,Yk,Zk,Hk,dk}k∈{1,…,N},H,H′,e^,G2),MSK=({xk,vk,{skj}j∈{1,…,N}∖{k}}k∈{1,…,N}).
View SourceRight-click on figure for MathML and additional features.

User Grant: Assume that the user u has the public key pku=Gs2 where s is the secret key and his attribute set Au=⋃k∈{1,…,N}Ak,u, user u interacts with authority k that works as follows.

For j∈{1,…,N}∖{k}, run the AKI protocol between j and u as that in ODMA-ABS. As a consequence, u gets
DkjDkj=GRkj2PRFkj(u),k>j=GRkj2/PRFkj(u),k<j.
View SourceRight-click on figure for MathML and additional features.

k randomly selects a dk−1 degree polynomial pk(⋅) such that
pk(0)=vk−∑j∈{1,…,N}∖{k}Rkj,(14)
View Sourceand for each i∈Ak,u∪Ck and each rk,i randomly selected from Zp, computes
dk,i0=Gpk(i)2(pkuHk(i))rk,i,dk,i1=grk,i1.
View Source

k outputs the private key tuple SKK=
({dk,i0,dk,i1}i∈Ak,u∪Ck,{Dkj}j∈{1,…,N}∖{k}).
View SourceRight-click on figure for MathML and additional features.

Finally, output the user’s private keys as
SK={SKk}k∈{1,…,N}.
View SourceRight-click on figure for MathML and additional features.

File Access: Suppose that the user has obtained the private keys and would like to access some resource with the policy that is defined by predicate Υn,C∗(⋅) (similar with that in ODMA-ABS scheme), the user takes the following steps.

For each k∈{1,…,N}, select a random nk-element attribute subset A′k⊆Ak,u∩C∗k, and a (dk−nk)-element default attribute subset C′k⊆Ck. Define Sk=A′k∪C′k, and then |Sk|=dk.

Select mk+d−nk random values sk,1,…,sk,mk+d−nk from Zp, and compute the following items
σ′0σ′k,i=∏1≤k≤N(∏i∈SkdΔi,Sk(0)k,i0∏i∈C∗k∪C′k(pkuHk(i))sk,i)={dΔi,Sk(0)k,i1gsk,i1,gsk,i1,i∈Ski∈C∗k∖A′k.
View Source

Compute
Du=∏(k,j)∈{1,…,N}×{1,…,N}∖{k}Dk,j,
View Sourceand then compute
σ0=Du⋅σ′0,σk,i=σ′sk,i.
View Source

The user then sends the tuple (σ0,σ′k,i,σk,i). The server checks if the following equation holds.
e^(g1,σ0)=?∏1≤k≤N⎡⎣∏i∈C∗k∪C′kZke^(σ′k,i,Hk(i))e^(σk,i,G2)⎤⎦.(15)
View SourceRight-click on figure for MathML and additional features.If the above equation holds, then the user will be allowed to access the resource that is stored in the server. Otherwise, the access request will be rejected.

5.2 Attribute Key Update
In this part, we discuss the update of attribute private keys. In practical scenario, the attribute set of a user may not be constant all the time. Sometimes, certain attribute of the user will be revoked from the user’s attribute set or there will be some new attributes inserted in the user’s attribute set. It is required that the attribute private keys are effectively updated when the attribute set of the user is changed. Here “effectively” means that the update shall only happen to the keys that are associated with the inserted/revoked attributes. In this paper, we just briefly introduce how to realize effective update for attribute private keys, but leave the technical details in the future work. To do so, we let each attribute authority build a set of all users who owns certain attribute and allocate a unique attribute group key for the set. The group key and the set are shared with the resource storage server. The storage server then choose a key encoding key (KEK) to encode the group key. When a user propose an access request to the storage server, it returns the encoded group key to the user. The user can obtain the KEK by his current attribute set and then get the group key. And the authentication tuple that the user generates is required to contain the correct attribute group key. When certain attribute is changed, the attribute authority not only generates a new private key for user but also change the corresponding attribute group key and the user set for the storage server. The server also updates the corresponding KEK. When a request is proposed by the user, the updated group key and KEK will be sent to him/her. And the outdated attribute private keys can no longer be used since it cannot generate the correct authentication tuple with either updated group key or outdated group key. We will present detailed algorithms for attribute key update in the future work. Moreover, to make the access control scheme more robust, we also consider two-factor authentication. There are some good techniques that can be utilized to realize two-factor authentication [30], [31]. We will discuss more in the future work.

SECTION 6Conclusion
We have presented an outsourced decentralized multi-authority attribute based signature scheme. The ODMA-ABS achieves attribute privacy and is able to detect malicious behaviors of the signing cloud server. Furthermore, by outsourcing heavy computation overhead to a signing cloud server, the scheme also achieves strong performance in efficiency. We have proved the security properties and compared certain schemes to show the advantages of our scheme. An access control scheme based on the proposed ODMA-ABS is also presented as a specific application of ODMA-ABS.

