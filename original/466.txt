The deployment of cloud storage services has significant benefits in managing data for users. However, it also causes many security concerns, and one of them is data integrity. Public verification techniques can enable a user to employ a third-party auditor to verify the data integrity on behalf of her/him, whereas existing public verification schemes are vulnerable to procrastinating auditors who may not perform verifications on time. Furthermore, most of public verification schemes are constructed on the public key infrastructure (PKI), and thereby suffer from certificate management problem. In this paper, we propose a c ertificateless p ublic v erification scheme against p rocrastinating a uditors (CPVPA) by using blockchain technology . The key idea is to require auditors to record each verification result into a transaction on a blockchain. Because transactions on the blockchain are time-sensitive, the verification can be time-stamped after the transaction is recorded into the blockchain, which enables users to check whether auditors perform the verifications at the prescribed time. Moreover, CPVPA is built on certificateless cryptography, and is free from the certificate management problem. We present rigorous security proofs to demonstrate the security of CPVPA, and conduct a comprehensive performance evaluation to show that CPVPA is efficient.
The deployment of cloud storage services has significant benefits in managing data for users. However, it also causes many security concerns, and one of them is data integrity. Public verification techniques can enable a user to employ a third-party auditor to verify the data integrity on behalf of her/him, whereas existing public verification schemes are vulnerable to procrastinating auditors who may not perform verifications on time. Furthermore, most of public verification schemes are constructed on the public key infrastructure (PKI), and thereby suffer from certificate management problem. In this paper, we propose a c ertificateless p ublic v erification scheme against p rocrastinating a uditors (CPVPA) by using blockchain technology . The key idea is to require auditors to record each verification result into a transaction on a blockchain. Because transactions on the blockchain are time-sensitive, the verification can be time-stamped after the transaction is recorded into the blockchain, which enables users to check whether auditors perform the verifications at the prescribed time. Moreover, CPVPA is built on certificateless cryptography, and is free from the certificate management problem. We present rigorous security proofs to demonstrate the security of CPVPA, and conduct a comprehensive performance evaluation to show that CPVPA is efficient.

SECTION 1Introduction
With cloud storage services, users outsource their data to cloud servers and access that data remotely over the Internet [1], [2]. These services provide users an efficient and flexible way to manage their data, while users are free from heavy local storage costs [3], [4], [5]. Although users enjoy great benefits from these services, data outsourcing has also incurred critical security issues [6], [7], [8]. One of the most important security concerns is data integrity [9], [10]. Unlike traditional data management paradigm, where users store their data locally, users would not physically own their data once having outsourced the data to cloud servers. Hence, users are always worried about the data integrity, i.e., whether the outsourced data is well maintained on cloud servers.

The integrity of outsourced data is being put at risk in practice [11], [12]. For example, the cloud servers may always conceal incidents of data corruption for good reputation, or may delete a part of data that is never accessed to reduce the storage costs [13], [14]. Furthermore, an external adversary may tamper with the outsourced data for financial or political reasons [15]. Hence, it is necessary to verify the integrity of outsourced data periodically. The verification can be performed by the users themselves. However, this lays a heavy communication burden on users to retrieve and verify the data.

Public verification techniques enable users to outsource the data integrity verification to a dedicated third-party auditor. The auditor periodically checks the data integrity, and informs the users that the data may be corrupted once the checking fails [16]. In most of public verification schemes, the auditor is assumed to be honest and reliable. If the auditor is compromised, these schemes would be invalidated. For example, an irresponsible auditor may always generate a good integrity report without performing the verification to avoid the verification costs. In such a way, the auditor is virtually non-existent. Furthermore, a compromised auditor may be incentivized by cloud servers to generate a bias verification result to deceive the users for profits. To resist the compromised auditor, the users are required to audit the auditor's behaviors [17], [18], [19]: After each verification, the auditor records the information used to verify the data integrity, which enables the user to audit the validity of the auditor's behavior.

In existing public verification schemes, the auditor needs to perform the verification periodically so that the data corruption can be detected as soon as possible. Actually, periodical verification can reflect the state of integrity of the outsourced data in each period, which enables the user to find the data corruption within the period. For example, in a cloud-assisted electronic health system, the outsourced electronic health records (EHRs) are sensitive [20], [21], [22], and should be verified periodically to guarantee their correctness. Any time the EHRs are corrupted, the healthcare provider can find it within the period, stops to use the corrupted EHRs, and attempts to recover the EHRs at once. This can protect the healthcare provider against losses caused by the EHR corruption as far as possible. However, an irresponsible auditor may procrastinate on the scheduled verification, due to network failures, system errors, or request from the cloud server.1 We call this auditor a procrastinating auditor, it deviates from the original objective of public verification schemes, i.e., detecting data corruption as soon as possible. It might be too late to recover the data loss or damage if the auditor procrastinates on the verification. In fact, the procrastinating auditor also cannot be detected in the public verification schemes, even though malicious auditors can be detected there [17], [18], [19].

Furthermore, most public verification schemes are built on the public key infrastructure (PKI), where the auditor has to maintain the users’ certificates to select correct public keys for verifications. Consequently, these schemes suffer from the certificate management problem (including certificate revocation, storage, distribution, and verification). It is inefficient in practice [23], [24].

In this paper, we present the first certificateless public data integrity verification scheme that resists malicious and procrastinating auditors, dubbed CPVPA. The key idea behind CPVPA is to use blockchain-based currencies (i.e., on-chain currencies), such as Bitcoin and Ethereum [25], [26], [27], which provide a secure way to conduct transactions without a central authority (i.e., bank). In CPVPA, the auditor is required to create a new transaction after each verification, where the information corresponding to the verification is integrated into the transaction, and the auditor conducts the transaction. After the transaction is recorded into the blockchain, the user can verify the time when the verification was performed by checking the generation time of the transaction. We stress that for a blockchain system, the more participants in it, the stronger security guarantee it can provide. Therefore, we construct CPVPA on a well-established and widely-used blockchain system (e.g., Ethereum), rather than a newly created one. Moreover, CPVPA is built on the certificateless cryptography [28] and avoids the certificate management problem. Specifically, the contributions of this work are summarized as follows.

We analyze existing public verification schemes, and demonstrate that existing schemes cannot resist a procrastinating auditor who may not perform the data integrity verification on schedule and deviate from the original objective of public verification schemes, i.e., detecting the data corruption as soon as possible.

We present a certificateless public verification of data integrity scheme, namely CPVPA, to resist malicious and procrastinating auditors, where each verification performed by the auditor is time-stamped by integrating it into a transaction of a blockchain, e.g., Ethereum. Such a mechanism enables the user to check the time when the auditor performs the verification. CPVPA addresses the certificate management problem existing in most of existing public verification schemes.

We present rigorous security proofs to prove that CPVPA is secure against the procrastinating auditor defined in this paper and the semi-trusted server and the malicious auditor defined in the strongest model [14], [17], [18]. We also provide a comprehensive performance evaluation, and demonstrate that CPVPA has a constant communication overhead, and is efficient in terms of computational overhead on both the server side and the user side.

The remainder of this paper is organized as follows. We motivate CPVPA in Section 2, and define the system model, adversary model, and design goals and present preliminaries in Section 3. We propose CPVPA in Section 4 and analyze its security in Section 5. We provide the performance evaluation in Section 6, review the related work in Section 7, and draw the conclusions and present some open problems in Section 8.

SECTION 2Problem Statement
2.1 Public Verification of Data Integrity
The key idea of the public verification technique [13], [14], [15] is that the user (i.e., data owner) splits the data into multiple blocks, computes a signature for each one, and outsources the data blocks as well as corresponding signatures to the cloud server. When the auditor verifies the data integrity, it chooses a random subset of all data blocks (e.g., sample 300 blocks from 10,000 ones) and sends the sampled blocks’ indexes (as a challenging message) to the cloud server. The cloud server responses with the corresponding proof, the auditor checks the integrity of challenged blocks by verifying the validity of the proof. If the verification passes, the integrity of entire data set is ensured. The key technique used here is aggregated signature [29], which enables the auditor to verify multiple blocks simultaneously without downloading the data.

In public verification schemes, after data outsourcing, the user sets a verification period (i.e., the frequency at which the auditor performs the verification). Then the auditor verifies the outsourced data integrity at the corresponding time. In practice, the auditor generates a verification report containing multiple verification results (corresponding to multiple periods, we call these periods an epoch). If in any period the verification result is “Reject”, it means that the data may be corrupted and the auditor needs to inform the user at once. Otherwise, the auditor generates a verification log and provides the user with the log at the end of each epoch. Since the auditor can verify the data integrity without the user's participation, the user can assign the auditor to perform the verification with any period as needed. In other words, from the user's perspective, if the outsourced data is corrupted, the longest delay within which she/he needs to find the data corruption should be the verification period.

We stress that the frequency at which the auditor checks the data integrity would not be very high in practice, due to the following reasons. First, the auditor serves multiple users simultaneously. If users require the auditor to perform the data integrity verification with a high frequency, e.g., performing the verification every hour, the auditor would bear a heavy communication and computation burden. Furthermore, the higher frequency to perform the data integrity verification, the more costs to employ the auditor. From a pragmatic standpoint, users would not require the auditor to perform data integrity verification with a high frequency in existing scenarios. Second, performing the data integrity verification with a high frequency would also cause heavy verification burden on the cloud server. As pointed out by Armknecht et al. [17], if integrating security mechanisms into existing cloud systems incurs considerable costs on the cloud service providers, most of the providers would not accept liability for the corresponding security guarantees in their Service Level Agreements (SLAs) and only ensure the service availability.

2.2 On the Vulnerability of Existing Public Verification Schemes against Procrastinating Auditors
In most of existing public verification schemes [14], [16], [30], auditors are assumed to be honest and reliable. This means that the auditor would honestly follow the prescribed schemes, and performs the verification reliably.2

These schemes cannot resist malicious auditors. The most trivial attack a malicious auditor can perform is that it always generates a good integrity report without verifying the data integrity to avoid the verification burden. To thwart such the attack, the user is able to audit the auditor's behavior at the end of each epoch. However, a more tricky attack still exists in the mechanism: the auditor colludes with the cloud server, and always generates bias challenging messages such that only the data blocks which are well maintained are verified, this avoids revealing the data corruption. To resist this attack, the challenging messages should not be predetermined by any participant. Existing schemes [17], [18], [19] utilize Bitcoin to generate the challenging messages to ensure the randomness of challenged data blocks, where the auditor extracts the hash value of the latest block from the Bitcoin blockchain, and generates the challenging message according to the security parameter and the extracted hash value. Since in the Bitcoin blockchain the hash value of a block generated at a future time is unpredictable, this ensures that the auditor cannot generate a bias challenging message to deceive the user, and enables the user to efficiently audit the auditor's behavior.

However, such the mechanism is vulnerable to a procrastinating auditor. Assuming the agreed verification period is 1 day, and an epoch is 1 month (i.e., 30 days), this means that the auditor checks the outsourced data integrity one time per day, and the user audits the auditor's behaviors one time per month. Normally, the auditor would perform the verification every day and generate a verification report every 30 days. For a procrastinating auditor, it would not perform the verification on the first 29 days, and would perform the verification 30 times on the last day, where the challenging messages in each verification of the first 29 days can be regenerated in the 30th day. As such, the verification report only reflects the most recent (the 30th day's) state of integrity for the outsourced data. This deviates from the public verification's original target: if the outsourced data is corrupted, the data owner is able to find it within 1 day (i.e., one verification period).

To resist the procrastinating auditor, a straightforward solution is to require the user to audit the auditor's behaviours in a random time interval. However, before the user audits the correctness of auditor's behaviours, she/he needs to interact with the auditor to obtain the data that records the auditor's behaviours for the auditing, this sufficiently gives rise to forge the data for the auditor and cloud server. As such, a procrastinating auditor can pass the user's auditing by colluding with the cloud server. Another straightforward solution is to introduce a trusted service provider who provides a time-stamping service [33]. After each verification, the auditor is required to query the time-stamping on the information, which is used to check the data integrity, and is used to be audited by the user to prove the correctness of its behavior. This enables the information to be time-sensitive, and therefore can resist the procrastinating auditor. Nevertheless, the security of this mechanism relies on the security and reliability of the time-stamping service provider, and the provider here becomes a single point of failure. Furthermore, the provider has to bear heavy communication and computation burden in the case of multiple users and auditors. As such, how to resist the procrastinating auditor without introducing any trusted entity is a very challenging problem.

2.3 On the (in)efficiency of PKI-Based Public Verification Schemes
Most public verification schemes are built on PKI, where a fully trusted certificate authority issues participants’ certificates, and the auditor has to maintain users’ certificates to select correct public keys for verifications. However, certificate management (including revocation, storage, distribution, and verification) is inefficient in practice [18], [28]. Therefore, removing the certificate management problem could be economic and favorable in practice.

SECTION 3Definitions and Preliminaries
3.1 System Model
As depicted in Fig. 1, four different entities are involved in CPVPA: cloud user (data owner), cloud server, third-party auditor (TPA), and key generation center (KGC).

User: The user is the data owner, who outsources her/his data to the cloud server and accesses the outsourced data as needed. After data outsourcing, the user employs a TPA, agrees a verification period with TPA, and let TPA periodically verify the data integrity.


Fig. 1.
System model.

Show All

Cloud server: The cloud server is subject to a cloud service provider. It provides storage services for users. It has a huge amount of storage space.

TPA: TPA works for the user. It generates the verification results based on the proof information from the cloud server, and detects the data corruption as soon as possible. The communication between TPA and other entities is authenticated.

KGC: The KGC is subject to an authority. It generates a partial private key for the user by using the user's identity.

A formal definition of CPVPA is given in the following:

Definition 1.
CPVPA is composed of five algorithms, Setup, Store, Audit, LogGen, and CheckLog.

Setup. In this algorithm, necessary parameters used in the subsequent algorithms are generated.

Store. In this algorithm, a user outsources the data to a cloud server. The user needs to generate verification tags (i.e., signatures) that enable a TPA to verify the data integrity. Furthermore, the correctness of outsourced data should be confirmed by the cloud server.

Audit. This algorithm enables TPA to check the data integrity, and allows the cloud server to prove that the outsourced data is well maintained.

LogGen. This algorithm enables TPA to generate a log file, which records the TPA's verification information.

CheckLog. This algorithm enables the user to audit the TPA's behavior by checking the validity and correctness of the log file.

3.2 Threat Model
In the threat model, we consider threats from three different aspects: semi-trusted servers, misbehaved auditors, and malicious users.

Semi-Trusted Servers. The cloud server is a semi-trusted entity. We follow the existing threat model of cloud servers [14] with the integration of the threat model of certificateless cryptography [28], [34]. It may hide the incident of data corruption by forging a proof information to deceive TPA. The cloud server may become two types of adversaries:

Type I adversary AI: He is able to replace the public key of the user with a value of his choice, but he cannot access to the KGC's master key.

Type II adversary AII: He is able to access the KGC's master key but cannot perform public key replacement.

Misbehaved Auditors. We extend the existing threat models of malicious auditors [17], [18]. TPA may be compromised, which means that TPA may hide an incident of data corruption from the user by colluding with the cloud server. Furthermore, TPA may deviate from the prescribed verification period, and may not perform the verification on schedule.

Malicious Users. We follow the existing threat model of malicious users [17], [18]. The only attack the user may perform is that he uploads incorrect verification tags (signatures) to circumvent the cloud server.

3.3 Challenges and Design Goals
In this paper, we target at designing a secure public verification of data integrity scheme for cloud storage systems, where two challenges should be addressed:

How to resist the procrastinating TPA without introducing any trusted participant. Existing schemes assume that TPA would perform the data integrity verification at the prescribed time. However, procrastinating auditors would not detect the data corruption as soon as possible, and it might be too late to recover the data loss or damage. Such the procrastination is hardly to be detected without a trusted participant's help.

How to avoid the certificate management. As discussed before, certificate management is cumbersome and costly in practice. Enabling TPA to verify the data integrity without managing users’ certificates could be economic and favorable in practice.

To enable secure verification of outsourced data integrity in cloud storage under the aforementioned model, the following objects should be achieved.

Efficiency: The communication and computation overhead should be as efficient as possible; TPA is able to verify the data integrity without managing the users’ certificates and bearing a priori bound on the number of verification interactions; TPA should be stateless, and is not required to maintain and update state during verification.

Security: When a cloud server passes the TPA's verification, it must possess the specified data intact; A malicious TPA and a procrastinating TPA cannot deceive the user; Collusion between any two participants cannot break the security of the proposed scheme.

3.4 Notation
Given two integers u,v∈N,(u≤v), where N is natural number set, we denote by [u,v] the set {u,u+1,u+2,…,v}. Given a finite set T, |T| denotes the number of components in T. Given two bit-strings x and y, x||y denotes their concatenation.

3.5 Bilinear Pairing
Give two multiplicative groups G and GT (they have the same prime order p), e: G×G→GT is a bilinear pairing if it has three properties:

Bilinearity: e(gu,qv)=e(g,q)uv, ∀g,q∈G, u,v∈Z∗p.

Non-degeneracy: ∀g,q∈G; g≠q, e(g,q)≠1.

It is efficient to compute e.

Computation Diffe-Hellman (CDH) problem in G: given G and one of its generator g, for any unknown a,b∈Z∗q, given ga and gb; compute gab.

3.6 Public Blockchain and On-Chain Currencies
A blockchain is composed of multiple data elements, in which each data element is called a block. All blocks form a chain, where the security is guaranteed by utilizing a cryptographic hash function. Each block typically contains a hash pointer as a link to a previous block, a timestamp, and transaction data [25]. Only if a transaction's validity is verified, it can be recorded into the block. Generally, blockchains can be classified into two categories: private blockchains and public blockchains. In private blockchains (including consortium blockchains), the verifications are performed by authorized participants, who may be employed by the blockchain managers or the managers themselves. In public blockchains, the verifications can be performed by any participant in the network: a transaction can be recorded into a block, only if it has been verified and accepted by a considerable majority [35], [36], [37].

The most prominent manifestation of public blockchain is on-chain currencies, e.g., Bitcoin [25] and Ethereum [26]. In these currencies, the public blockchain is utilized to record a ledger that efficiently keeps track of transactions between two participants in a distributed manner. Furthermore, such a ledger is publicly verifiable and secure against modification of chained blocks, the participants who verify the transaction and maintain the blockchain are called miner. Actually, the more miners that participate in a public blockchain system, the stronger security guarantee the blockchain system has. In this work, we utilize the Ethereum blockchain to construct CPVPA, since Ethereum is more expressive than other on-chain currencies and Ethereum is the one of most popular blockchain systems.

A simplified Ethereum blockchain is depicted in Fig. 2: Transactions are denoted by Tx; the hash value of current block is denoted by BlockHash; the hash value of the previous block is denoted by PrevBlockHash; Nonce denotes a solution of proof-of-work (PoW) puzzles detailed later; Time denotes the timestamp to indicate when the block is appended to the blockchain; MerkleRoot denotes the root value of a Merkle hash tree [38] formed by all transactions in current block. The ledger of Ethereum can be thought of as a state transition system, where there is a “state” consisting of the ownership status of all existing Ethers (which are the underlying value token) and a “state transition function” that takes a state and a transaction as input, and outputs a new state which is the result. When a new block is added into the chain, all transactions recorded in the block should be verified first, and then miners compute a valid nonce (denoted by Nonce in Fig. 2) such that the hash value of the block is less than or equal to a value provided by the Ethereum system. This process is a proof of work and is well known as “Mining”. The first miner who finds the nonce broadcasts the block of transactions together with this nonce. Other participants can verify that the nonce is a valid solution, and hence add the new block to their blockchain. Once the block is added to the chain, all the corresponding state information has been updated. More technique details can be found in [26].


Fig. 2.
A simplified Ethereum blockchain.

Show All

In Ethereum, the state is made up of objects called “account”. Generally, Ethereum includes two categories of accounts: externally owned ones and contract ones. Externally owned accounts are controlled by private keys. Contract accounts are controlled by their contract code. Each smart contract corresponds to a contract account, after the contract is deployed and contained by the Ethereum blockchain, one can send message to the contract account (i.e., transferring Ethers from an account to the contract account) to trigger the execution of the smart contract, where the data included in the “data field” can be set as the input of the contract. For the transaction between two external owned accounts, once the transaction is recorded into the blockchain, the accounts’ balances are updated. Note that the transactions between two external accounts in Ethereum also include a “data” field. The user who conducts the transaction (i.e., the payer shown in Fig. 2) can set the data field to be any binary data she/he chooses.

There are three fundamental properties in secure blockchain systems [39], [40], [41]:

φ-chain consistency. Blockchains of any two honest miners at any point in time during the mining execution can differ only in the last φ blocks.

(ι,φ)-chain quality. For an honest miner's blockchain, the fraction of blocks mined by honest miners in any sequence of φ or more successive blocks is at least ι. In other words, the probability that any φ successive blocks on the blockchain are generated by an adversarial miner whose hashrate is less than 51 percent of the network's mining hashrate can be negligible. In Ethereum, φ≥12.

Chain growth. The number of blocks that are appended to the blockchain during any given time interval is deterministic. In other words, the blockchain’ height would steadily increase with respect to both short and long terms.

With the above fundamental properties as well as the inherent characteristics of PoW-based consensus algorithm, we derive two properties from the Ethereum blockchain and adopt them to construct CPVPA.

Unpredicted hash value.3 The hash value (denoted by BlockHash in Fig. 2) of each block on the blockchain only can be determined after a valid nonce is computed and verified by all miners. Once the block is appended to the blockchain, its hash value is deterministic and resistant to modification. This means that given a point in time time, if time is a point in the past, the hash value of the latest block that has appeared since time on the blockchain is publicly verifiable and can be extracted efficiently; if time is a point in the future, the hash value is computationally unpredictable. We stress that the fact that the hash value of blocks generated in the future cannot be predicted does not means that the hash value cannot be biased by an adversary who has infinite budget. Since the adversary can incentivize a miner who first mine a block to throw the newly mined block away and continue to mine if the hash value of the block does not meet the adversary's requirement [42].

Time-sensitive data state. For a transaction with a string Ti as its Data value, if a block including this transaction is accepted by a majority of miners and is chained to the blockchain, the string Ti is then time-stamped. It means that Ti was created earlier than the time that the block is appended to the blockchain. Thus Ti is time-sensitive. Furthermore, due to the property of chain growth, it is feasible to derive the time when the block was appended to the blockchain from the height of the block. Specifically, if a transaction with Ti is recorded into the blockchain, anyone can extract the corresponding block's height (which is denoted by t1) to determine whether Ti is generated no later than BlockTimet1, where BlockTimet1 denotes the height-derived time. By doing so, an Ethereum blockchain provides an efficient and secure service for time-stamping a digital document but without introducing any trusted authority [33].

SECTION 4The Proposed CPVPA
4.1 Overview
We utilize the Ethereum blockchain as the underlying public blockchain. Fig. 3 shows the proposed CPVPA.


Fig. 3.
The proposed CPVPA.

Show All

CPVPA consists of two phases. In the first phase, the auditor verifies the integrity of outsourced data. In the second phase, the user audits the auditor's behavior.

In the first phase, the verification period is determined by the user. For a point in time when the data integrity should be verified, TPA first extracts the hash values of φ successive blocks that are the latest ones confirmed on the Ethereum blockchain, where φ denotes the number of blocks deep used to confirm a transaction (in the Ethereum, φ=12), and these hash values are denoted by {Blt−φ+1,Blt−φ+2,…,Blt}. Then TPA generates a challenging message on {Blt−φ+1,Blt−φ+2,…,Blt}, and sends it to the cloud server. Upon receiving the challenging message, the cloud server computes the corresponding proof. TPA checks the validity of the proof to verify the data integrity. If the checking fails, TPA informs the user that the data may be corrupted; Otherwise, TPA sets {Blt−φ+1,Blt−φ+2,…,Blt} and the proof as a log entry, stores the entry to a log file, and creates a transaction that transfers 0 deposit from its account to the user's account,4 wherein the data field is set to the hash value of the entry. In this paper, for the sake of simplicity, we assume the transaction is recorded to the block whose height is t+φ+1 and PrevBlockHash =Blt+φ, as shown in Fig. 4.


Fig. 4.
The Transaction Tx1 in PVPA.

Show All

In the second phase, the user audits the TPA's behavior in a much longer period compared with the verification period. We first show how is a single entry (without loss of generality, {Blt−φ+1,Blt−φ+2,…,Blt} and the corresponding proof) in the log file audited by the user. The user first determines the verification time that TPA should perform data integrity verification. Then she/he obtains {Blt−φ+1,Blt−φ+2,…,Blt} from the Ethereum blockchain according to the agreed verification time, and extracts the hash value of the entry from the transaction. Next she/he regenerates the challenging message on {Blt−φ+1,Blt−φ+2,…,Blt}, and checks the validity of the corresponding proof by using the challenging message generated by herself/himself. If the checking passes, it means that TPA performs the verification correctly. Multiple entries can be audited simultaneously, and the auditing costs can be amortized over these entries, which we show in Section 6.

4.2 Construction of CPVPA
A user U, a TPA, a cloud server C, and a KGC are involved in CPVPA. The user U has an identity IDU.

Phase 1. TPA verifies the data integrity.

Setup. Based on the security parameter ℓ, KGC determines the system parameters as follows:

Determine the bilinear pairing e:G×G→GT, in which G and GT are multiplicative groups with the same prime order p and g is a generator of G.

Choose a random λ∈Zp as the master key and computes PM=gλ as its public key.

Choose five hash functions H(⋅), H1(⋅), H2(⋅), H3(⋅), H4(⋅), where H(⋅):{0,1}∗→Zp,H1(⋅)∼H4(⋅):{0,1}∗→G are cryptographic hash functions.

Choose a pseudorandom permutation πkey(⋅) and a pseudorandom function fkey(⋅) [43].

The system parameters are {e,G,GT,g,p,H(⋅),H1(⋅)∼H5(⋅),πkey(⋅),fkey(⋅)}.

The KGC generates the partial private key for U using IDU as follows:

Compute QU,0=H1(IDU,0) and QU,1=H1(IDU,1).

Compute DU,0=QλU,0 and DU,1=QλU,1.

U chooses a random xU∈Z∗p and computes pkU=gxU.

U's signing key is sskU={xU,DU,0,DU,1}, and the corresponding public key is spkU={pkU,IDU}.

Store.

U transfers his/her data M into n blocks: M={mi}1≤i≤n.

U randomly chooses an element name∈Zp for file naming, randomly chooses a one-time number Δ∈Zp, and computes τ=H(name||n||Δ||spkU).

U randomly chooses r∈Z∗p, and computes R=gr, V=H3(Δ), W=H4(Δ).

For each i∈[1,n], U computes Ti=H2(i||τ||R), and Si=(DU,0⋅VxU)mi⋅(DU,1⋅WxU)H(i||τ||R)⋅Tri.

U outsources M~={M,{Si}i=1,2,…,n,R,Δ} to C.

After receiving M~, C first computes τ=H(name||n||Δ||spkU), and then it verifies the correctness of the data by checking
e(∏i=1nSi,g)=e(∏i=1n(QmiU,0⋅QℏiU,1),PM)×e(∏i=1n(Vmi⋅Wℏi),pkU)e(∏i=1nTi,R),
View SourceRight-click on figure for MathML and additional features.where ℏi=H(i||τ||R). If the checking passes, C accepts M~.

Audit. To check the integrity of outsourced data, TPA first generates a challenging message as follows:

Extract {Blt−φ+1,Blt−φ+2,…,Blt} from the Ethereum blockchain based on the current time, where φ denotes the number of blocks deep used to confirm a transaction, t denotes the height of the block that is latest confirmed at the current time.

Set ({Blt−φ+1,Blt−φ+2,…,Blt},t) as the challenging message and send it to C.

After receiving ({Blt−φ+1,Blt−φ+2,…,Blt},t) from TPA, C first checks the validity, i.e., whether {Blt−φ+1,Blt−φ+2,…,Blt} are the correct ones on the blockchain. If the checking fails, C rejects; Otherwise, C generates the proof information as follows:

Compute k1=h1(Blt−φ+1||Blt−φ+2||…||Blt) and k2=h2(Blt−φ+1||Blt−φ+2||…||Blt), where h1(⋅) is a secure hash function and maps {0,1}∗ to the key space of πkey(⋅), and h2(⋅) is a secure hash function and maps {0,1}∗ to the key space of fkey(⋅).

Compute iξ=πk1(ξ),viξ=fk2(ξ), ξ=1,2,…,c, where c is the number of data blocks that should be checked, and is determined by ℓ.

Compute S=∏ξ=1cSviξiξ, μ=∑ξ=1cviξmiξ.

Send {S,R,μ,Δ} to TPA.

Upon receiving the proof information from C, TPA verifies the data integrity as follows:

Compute τ=H(name||n||Δ||spkU).

Compute k1=h1(Blt−φ+1||Blt−φ+2||…||Blt) and k2=h2(Blt−φ+1||Blt−φ+2||…||Blt).

Compute iξ=πk1(ξ),viξ=fk2(ξ),ξ=1,2,…,c.

Check whether
e(S,g)=e(QμU,0⋅∏ξ=1cQviξℏiξU,1,PM)e(∏ξ=1cTviξiξ,R)×e(Vμ⋅∏ξ=1cWviξℏiξ,pkU),(1)
View Sourcewhere ℏiξ=H(iξ||τ||R), Tiξ=H2(iξ||τ||R).

If the Equation (1) holds, TPA outputs the verification result as Accept; Otherwise, TPA outputs the verification result as Reject.

Phase 2. The user checks the TPA's behavior.

LogGen. TPA generates a log file as follows:

For each verification task, generate an entry as {Blt−φ+1,Blt−φ+2,…,Blt,t,S,μ}.

Store the entry to a log file Λ in chronological order, as shown in Table 1.

TABLE 1 The Log File ΛΛ in CPVPA

Compute the hash value (hereinafter, we take the first verification task as an example)
θt1=H(Bl(1)t−φ+1||Bl(1)t−φ+2||…||Bl(1)t||t(1)||S(1)||μ(1)).
View Source

Generate a transaction Tx1 shown in Fig. 4, where the data field is set to θt1, and upload it to the Ethereum blockchain. Ideally, Tx1 is recorded in the block whose height is t+φ+1 and hash value is Bl(1)t+φ+1.

CheckLog. We first show that how to check the validity of a single entry (e.g., the first row) in Λ:

U first acquires t(1) and t(1)+φ+1, and derives the physical time when the verification is performed from t(1) and t(1)+φ+1. If the time does not match the agreed one, U sets the checking result as Reject.

U acquires Bl(1)t from the Ethereum blockchain, and extracts θt1 from the block whose hash value is Bl(1)t+φ+1. If the extraction fails, U sets the checking result as Reject.

U checks that whether θt1 matches the entry in the first row of Λ.

U computes τ=H(name||n||Δ||spkU), i(1)ξ=πk1(ξ),v(1)iξ=fk2(ξ), where
k1k2=h1(Bl(1)t−φ+1||Bl(1)t−φ+2||…||Bl(1)t),=h2(Bl(1)t−φ+1||Bl(1)t−φ+2||…||Bl(1)t).
View Source

U checks
e(S(1),g)=e(Qμ(1)U,0⋅∏ξ=1cQv(1)iξℏ(1)iξU,1,PM)×e(Vμ(1)⋅∏ξ=1cWv(1)iξℏ(1)iξ,pkU)×e(∏ξ=1c(T(1)iξ)v(1)iξ,R),(2)
View Sourcewhere ℏ(1)iξ=H(i(1)ξ||τ||R), T(1)iξ=H2(i(1)ξ||τ||R). If the checking fails, U sets the auditing result as Reject; Otherwise, the auditing result is Accept.

In practice, a user needs to audit multiple entries to ensure the correctness of the TPA's behaviour during an epoch. To reduce the auditing costs, multiple entries in Λ can be audited simultaneously. Specifically, the user picks a random b-element subset of the set [1,l]. Let {l1,l2,…,lb} be the picked subset. The user then audits the TPA's behaviour by checking
e(∏η=1bS(lη),g)=e(∏η=1bQμ(lη)U,0⋅∏η=1b∏ξ=1cQv(lη)iξℏ(lη)iξU,1,PM)×e(∏η=1bVμ(lη)⋅∏η=1b∏ξ=1cWv(lη)iξℏ(lη)iξ,pkU)×e(∏η=1b∏ξ=1c(T(lη)iξ)v(lη)iξ,R).
View SourceIf the check fails, U sets the auditing result as Reject; Otherwise, the auditing result is Accept.

Correctness. The correctness of CPVPA depends on the correctness of Equations (1) and (2), and we provide the correctness proof in the following:
e(S,g)=e(∏ξ=1cSviξiξ,g)=e(∏ξ=1cQviξmiξU,0,PM)e(∏ξ=1cVviξmiξ,pkU)×e(∏ξ=1cQviξℏiξU,1,PM)e(∏ξ=1cWviξℏiξ,pkU)×e(∏ξ=1cTviξiξ,R)=e(QμU,0⋅∏ξ=1cQviξℏiξU,1,PM)×e(Vμ⋅∏ξ=1cWviξℏiξ,pkU)e(∏ξ=1cTviξiξ,R).
View Source

4.3 Remark and Further Discussion
In CPVPA, we do not set the timestamp recorded in the block as the transaction time (i.e., when the verification is performed), since the timestamp recorded in the Ethereum block might suffer from up to 15 minutes error. In CPVPA, the user derives the transaction time from the height of the block which includes the transaction, due to the property of chain growth discussed in Section 3.6.

Now, we show how to compute the height-derived physical time when a block was generated. An Ethereum block averagely takes 15.85579752 seconds (this is counted based on the data released by Etherscan5) to be mined from the time of genesis block (which was generated on 2015-07-30) to the time of block with height 5,784,426 (which is the last block generated on 2018-06-15). We denote time5784426 the height-derived physical time that transactions included in the block with height 5,784,426 were generated. time5784426=time0+15.85579752×5784426 (seconds), where time0 is the physical time that the genesis block of Ethereum was created (2015-07-30, 03:26:13 PM +UTC).

In CPVPA, the main goal of utilizing blockchain-based currencies is to resist procrastinating auditors. CPVPA also achieves an appealing feature, which we believe might be of independent interest. The auditor cannot pre-perform the scheduled verifications due to the unpredictability of block's hash value. In other words, if the auditor is required to verify the data integrity at a point in time, it has to perform the verification at the point in time. Our proposed mechanism used to resist procrastinating auditors is well compatible with most of existing public verification of data integrity schemes.

We stress that we construct CPVPA on PoW-based blockchain systems, such as Bitcoin and Ethereum. Theoretically, CPVPA can also be constructed on the blockchain systems that are based on other consensus algorithms (e.g., proof of stake (PoS) [44]), since the φ-chain consistency, (ι,φ)-chain quality, and chain growth are fundamental properties for secure blockchain systems. However, due to the differences on the block structure of the PoS-based blockchains, constructing CPVPA on different PoS-based blockchains requires different constructions. Furthermore, as discussed before, for a public blockchain system, the more participants in it, the stronger security guarantee it can provide. The number of participants in existing PoS-based blockchain systems, e.g., CARDANO [44], is much less than that in Ethereum. Therefore, if we construct CPVPA on these blockchains, the costs that the adversary breaks the security of CPVPA are reduced significantly.

SECTION 5Security Analysis
5Lemma 1.
The signature σi={Si,R} in CPVPA is existentially unforgeable under adaptively chosen-message attack.

To prove this lemma, we first define two games corresponding to the type I adversary and type II adversary, respectively.

Game I (for adversary AI):

Setup: a challenger ℘ runs the Setup algorithm and obtains the public parameters. ℘ sends the public parameters to AI.

Query:

Public-Key-Replacement queries PKR(IDU,spk′U): AI is able to choose a new public key spk′U={QU,0,QU,1,pk∗U} and sets spk′U as the new public key of U. ℘ will record this replacement.

Sign queries S(Δi,mi,IDU,spkU): AI can request U's signature on a message mi under a state information Δi. On receiving a query S(Δi,mi,IDU,spkU), ℘ generates the corresponding signature σi, and sends σi to AI.

Forgery: For the IDU, AI outputs the corresponding public key spk′U, a messages m∗, a state information Δ∗, and a signature σ∗.

We say that AI wins Game I if and only if:

σ∗ is a valid signature on m∗ with state information Δ∗ under IDU and spk′U.

m∗ is not submitted during the sign queries.

Game II (for adversary AII):

Setup: a challenger ℘ runs the Setup algorithm and obtains the secret and public parameters. ℘ sends the public parameters and the KGC's master key to AII.

Query:

Sign queries S(Δi,mi,IDU,spkU): AII can request U's signature on a message mi under a state information Δi. On receiving a query S(Δi,mi,IDU,spkU), ℘ generates the corresponding signature σi, and sends σi to AII.

Forgery: For the IDU, AII outputs a messages m∗, a state information Δ∗, and a signature σ∗.

We say that AII wins Game II if and only if:

σ∗ is a valid signature on m∗ with state information Δ∗ under IDU and spkU.

m∗ is not submitted during the sign queries.

5Proof.
We first prove that the advantage that AI wins Game I is negligible.

Let ℘ be a CDH attacker who receives a random instance (g,ga,gb) of the CDH problem in G and needs to compute gab. Here, we show that if AI is able to forge a signature with a probability ϵ, ℘ is able to solve the CDH problem by using AI's output with the same probability. Due to space limitation, we only show the proof sketch and omit some interaction details. In fact, this proof follows the proof of [34].

At the beginning of the game, ℘ sets PM=ga as an instance of the CDH problem, and simulates H(⋅),H1(⋅)∼H4(⋅) as random oracles. In the game, ℘ sets QU,0=gα∗U,0⋅gα′∗U,0b, QU,1=gα∗U,1⋅gα′∗U,1b, T=gς∗, V=gβ∗, and W=gγ∗, where α∗U,0,α′∗U,0,α∗U,1,α′∗U,1,ς∗,β∗,γ∗∈Z∗p are chosen randomly. For any signature query on any message m under any state information, ℘ responses with the corresponding signature as follows.

℘ sets H(R)=−(mα′∗U,0)/α′∗U,1.

℘ randomly chooses r∈Zp, computes R=gr and
S=gα∗Um⋅a⋅g(β∗m)xU⋅g−((mα′∗U,0⋅α∗U,1)/α′∗U,1)⋅a×g−((α′∗U,0γ∗m)/(α′∗U,1))xU⋅gς∗r.
View Source

℘ responses with (S,R).

Finally, AI outputs a tuple {m∗,σ∗,Δ∗,pk∗U}, where σ∗={S∗,R∗} is a valid signature of m∗ under Δ∗ and pk∗U.

Since σ∗ is a valid signature, we have
e(S∗,g)=e(Qm∗U,0⋅QH∗U,1,PM)×e((V∗)m∗⋅(W∗)H∗,pk∗U)×e(T∗,R∗),(3)
View Sourcewhere H∗=H(R∗), T∗=H2(R∗). Here, we discuss the security of a single signature, hence the form H∗ is slightly different from the one in CPVPA. This difference should not reduce the security of Si. Note that
e(S∗,g)=e(gm∗α∗U,0a⋅gm∗α′∗U,0ab⋅gH∗α∗U,1a⋅gH∗α′∗U,1ab×(pk∗U)m∗β∗⋅(pk∗U)H∗γ∗⋅(R∗)ς∗,g).
View SourceWe have
gab=(S∗⋅(gm∗α∗U,0a⋅gH∗α∗U,1a⋅(pk∗U)m∗β∗×(pk∗U)H∗γ∗⋅(R∗)ς∗)−1)(m∗α′∗U,0+H∗α′∗U,1)−1.
View Source

By this way, ℘ can solve the CDH problem.

For AII, let ℘ be a CDH attacker who have received a random instance (g,ga,gb) of the CDH problem and needs to compute gab by using AII's output.

At the beginning of Game II, ℘ randomly selects λ,xU∈Z∗p and obtains the public parameters. Then ℘ sends λ and the public parameters to AII. In Game II, ℘ sets T=gβ∗, V=gγ∗⋅gγ′∗a, W=gς∗⋅gς′∗a, and pkU=gxUb, where β∗,γ∗,γ′∗,ς∗,ς′∗∈Z∗p are chosen randomly. For any signature query on any message m under any state information, ℘ responses with the corresponding signature as follows.

℘ sets H(R)=−(γ′∗m)/(ς′∗).

℘ randomly choose r∈Zp, computes R=gr and
S=H1(U,0)λ⋅H1(U,1)λ⋅gγ∗mxU×g−((ς∗γ′∗m)/ς′∗)xU⋅gβ∗r.
View Source

℘ outputs (S,R) as the response.

Finally, AII outputs a tuple {m∗,σ∗,Δ∗}, where σ∗={S∗,R∗} is a valid signature of m∗ under Δ∗.

Since σ∗ is a valid signature, it satisfies the Equation (3). By our setting, we also have
e(S∗,g)=e(Qλm∗U,0⋅QλH∗U,1⋅gxUbm∗γ∗×gxUbm∗γ′∗a⋅gxUbH∗ς∗×gxUbH∗ς′∗a⋅(R∗)β∗,g),
View Sourcewhere QU,0=H1(IDU,0), QU,1=H1(IDU,1), and H∗=H(R). ℘ can solve the CDH problem
gab=(S∗⋅(Qλm∗U,0⋅QλH∗U,1⋅(R∗)β∗×g(xUm∗γ∗+xUH∗ς∗)b)−1)(xUm∗r′∗+xUH∗ς′∗)−1.
View Source

This concludes the proof of this lemma.

5Claim 1.
CPVPA achieves the authenticity defined by [14], i.e., if the cloud server passes the TPA's verification, it must well maintains the specified data.

5Proof.
To prove the authenticity of CPVPA, we define a sequence of games with interleaved analysis.

Game 0. This game is simply the challenge game between TPA and the cloud server defined in Section 4.2.

Game 1. This game is the same as Game 0, with the exception of one difference. The adversary is trained to be able to forge a part of the proof information in Audit. Since σi={Si,R} in CPVPA is existential unforgeable, here, the challenger records each proof information generated by the adversary, and declares failure and aborts if

the proof information is a valid one;

μ′ in the proof information is different from the expected μ.

Analysis. As Game 1 defined, in the case that the challenger aborts, the proof information generated by the adversary is {S,R,μ′,Δ}. due to the correctness of CPVPA, we have
e(S,g)=e(QμU,0⋅∏ξ=1cQviξℏiξU,1,PM)×e(Vμ⋅∏ξ=1cWviξℏiξ,pkU)×e(∏ξ=1cTviξiξ,R),(4)
View Sourceand for the adversary's output, we have
e(S,g)=e(Qμ′U,0⋅∑ξ=1cQviξℏiξU,1,PM)×e(Vμ′⋅∏ξ=1cWviξℏiξ,pkU)×e(∏ξ=1cTviξiξ,R).(5)
View SourceSince μ≠μ′, μ¯=μ−μ′≠0. We further have
QμU,0≠Qμ′U,0,Vμ≠Vμ′.
View SourceFurthermore, we also have
e(QμU,0,PM)e(Vμ,pkU)=e(Qμ′U,0,PM)e(Vμ′,pkU).
View SourceRight-click on figure for MathML and additional features.Rearranging terms yields
e(QμλU,0⋅VμxU,g)=e(Qμ′λU,0⋅Vμ′xU,P),
View SourceRight-click on figure for MathML and additional features.that is, (QλU,0⋅VxU)μ=(QλU,0⋅VxU)μ′. We set ω=QλU,0⋅VxU, and for arbitrary ω, we can represent it as ω=(g∗)ζ∗⋅(g′∗)ζ′∗, where ζ∗,ζ′∗∈Zp, g∗,g′∗∈G are random elements. Similarly, there exists χ∈Zp such that g∗=(g′∗)χ. Here, the CDH problem is that given g′∗ and g∗=(g′∗)χ, computing χ. By our setting, the solution of CDH problem is χ=−(ζ′∗/ζ∗).

Game 2. This game is the same as Game 1, with the exception of one difference. The adversary is trained to be able to forge any part of proof information in Audit. That is, the challenger records each proof information generated by the adversary, and declares failure and aborts if

the proof information {S′,R′,μ′,Δ} is a valid one;

the proof information {S′,R′,μ′,Δ} is different from the expected {S,R,μ,Δ}.

Analysis. We consider the user as the challenger. At the beginning of the game, the challenger sets PM=gs as an instance of the CDH problem. Then the challenger randomly chooses α0,α′0,α1,α′1∈Zp and sets Hi=−miα′0α′−11, QU,0=gα0⋅(g′)α′0, and QU,1=gα1⋅(g′)α′1. For random values r and xU, the challenger computes (Si,Ri)
RiSi=gri=(DU,0⋅VxU)mi⋅(DU,1⋅WxU)ℏi⋅Tri=g(miα0−miα′0α1α′−11)s⋅VmixU×(Wmiα′0α′−11xU)−1⋅Tri.
View Source

The challenger continues to interact with the adversary. When the challenger aborts, the received proof information is {S′,R′,μ′,Δ}, while the expected one is {S,R,μ,Δ}. Due to the correctness of CPVPA, we have the Equation (3) and
e(S′,g)=e(Qμ′U,0⋅∏ξ=1cQviξℏiξU,1,PM)×e(Vμ′⋅∏ξ=1cWviξℏiξ,pkU)⋅e(∑ξ=1c(T′iξ)viξ,R′).
View SourceBy our setting, (S′,R′)≠(S,R). Clearly, μ≠μ′, and we define μ¯=μ′−μ. Here, the CDH problem is that given (g,g′,gs) computing (g′)s.

Now we have e(S′/S,P)=e(Qsμ¯U,0⋅VxUμ¯⋅∏ξ=1c((T′iξ)r′/Triξ)viξ,g). Recall that QU,0=gα0⋅(g′)α′0, we can further get S′/S=gsμ¯α0⋅(g′)sμ¯α′0⋅VxUμ¯⋅∏cξ=1((T′iξ)r′/Triξ)viξ. Finally, the CDH solution
(g′)s=(S′⋅S−1⋅(gsμ¯α0)−1⋅(VxUμ¯)−1×∏ξ=1c((T′iξ)r′⋅Triξ)viξ)(μ¯α′0)−1.
View Source

This concludes the proof.

5Lemma 2.
In a PoW-based public blockchain system, such as Bitcoin and Ethereum, an adversary cannot pre-determine the hash value of the block generated at a future time.

5Proof.
We first introduce the preimage resistance of a cryptographic hash function.

A hash function is preimage resistant if given a uniform y it is infeasible for a PPT adversary to find a value x such that H(x) = y [43].

With the preimage resistance of hash function, the proof of this lemma is straightforward.

Assuming the block of underlying blockchain has the form shown in Fig. 4, where Bl_{t} = H(Bl_{t-1}||\mathsf {Nonce}||\mathsf {Time}||\mathsf {MerkleRoot}), and H(\cdot) is a secure hash function with preimage resistance. If the adversary can pre-determine Bl_{t}, the preimage resistance of H(\cdot) is broken.

This concludes this lemma.

5Claim 2.
CPVPA is able to thwart malicious auditors who can perform two attacks to break the security:

Forging an entry in the log file \Lambda to pass the user's audit;

Sampling bias challenging messages to generate bias verification results.

5Proof.
For the first case, we will discuss it in two aspects.

First, TPA forges an entry \lbrace Bl_{t-\varphi +1}, \ldots, Bl_{t}, S^{^{\prime }}, R^{^{\prime }}, \mu ^{^{\prime }}\rbrace that can pass the user's auditing. However, due to the authenticity of CPVPA, it is computationally infeasible to generate the entry. Specifically, since we have proved that if the data loss occurs, the cloud server can pass the auditor's verification with negligible probability. If TPA is able to forge the entry that passes the user's auditing, the cloud server is able to break the authenticity of CPVPA by following the TPA's method.

Second (for the procrastinating auditor), at the time BlockTime_{t} + time_{1}, time_{1} > 0, TPA forges an entry to convince the user that the entry is generated at the time BlockTime_{t}. In this attack, TPA needs to generate a transaction and record it to a block that has been chained in the Ethereum blockchain. However, due to the security of Ethereum, this attack is computationally infeasible.

For the second case, we will analyze it in three aspects.

First, the hash values of blocks used to compute the challenging messages cannot be pre-determined and specified by any entity, due to Lemma 2.

Second, the blocks used to compute the challenging messages would not be generated by the adversary, due to (\iota, \varphi)-chain quality of the Ethereum blockchain [39], [45].

Third, the only attack the malicious auditor can perform is to bias the hash value of the blocks by incentivizing the miners who mine a new block to throw the newly mined block away and continue to mine if the hash value of the block does not meet the adversary's requirement. Here, the adversary's requirement to the biased hash value is that the indexes of challenged blocks that generated on the hash value of the blocks exclude the corrupted ones, i.e., for \xi = 1, 2, \ldots, c, i_{\xi } = \pi _{h_{1}(Bl_{t-\varphi +1}||Bl_{t-\varphi +2}||\cdots ||Bl_{t})}(\xi) would not include the indexes of corrupted blocks. Note that the adversary can bias \lbrace i_{\xi }\rbrace (\xi = \lbrace 1, 2, \ldots, c\rbrace) only by biasing Bl_{t}. Now, we compute the probability that the adversary successfully biases Bl_{t}. The adversary model and game model follow the ones proposed by Pierrot et al. [42].

For illustration, we assume an adversary \mathcal {A} who aims at biasing Bl_{t} to break the security of CPVPA. In our setting, the indexes of corrupted data blocks form a set \varepsilon, \mathcal {A} wins whenever anyone of indexes of challenged blocks generated by Bl_{t} do not fall in \varepsilon. Let \Upsilon : \varepsilon \rightarrow \lbrace 0,1\rbrace be the characteristic function that predicates whether a given value meets \mathcal {A}'s requirement.

We denote by P the probability for a extracted hash value of a block Bl to satisfy \Upsilon (Bl) = 1. We stress that P is essentially a probability that the corrupted data set can pass the auditor's verification in CPVPA. As evaluated by [9], [16], [31], if \rho fraction of data is corrupted, then randomly (uniformly) sampling c blocks would reach the detection probability P_{detec} = 1 - (1-\rho)^{c}. Therefore, \begin{equation*} P = 1 - P_{detec} = (1 - \rho)^{c}. \tag{6} \end{equation*}
View Source

\mathcal {A}'s strategy here is straightforward: he will focus all his computational power on mining the next block and incentivize the miners to throw the newly mined blocks away and continue to mine if \Upsilon (Bl) = 0, where the hash value of the newly mined block is denoted by Bl.

We denote by P_{\mathcal {A}} the probability that \mathcal {A} wins. According to [42], we know that \begin{equation*} P_{\mathcal {A}} = \frac{P}{1 - \vartheta (1-P)}, \tag{7} \end{equation*}
View Sourcewhere \vartheta denotes the proportion of \mathcal {A}'s mining hashrate. In our security analysis, we assume \vartheta < 51\%, otherwise, the security of underlying blockchain would be broken.

According to Equations (6) and (7), we have \begin{equation*} P_{\mathcal {A}} = \frac{(1 - \rho)^{c}}{1 - \vartheta (1-(1 - \rho)^{c})}. \tag{8} \end{equation*}
View Source

We show the probability that \mathcal {A} wins in Fig. 5, where \rho = 1\%. For instance, when \vartheta = 1/4, \rho = 1\%, c = 460, the probability that \mathcal {A} wins is 0.01305; When \vartheta is set to 1/2 and others parameters remain the same, P_{\mathcal {A}} is increased from 0.01305 to 0.01983. Note that \vartheta = 1/2 denotes that the adversary is very powerful, but the probability that \mathcal {A} wins is still very small.


Fig. 5.
Probability that the adversary wins.

Show All

The above analysis demonstrates that CPVPA is able to thwart malicious auditors.

This concludes the proof of this claim.

In CPVPA, it is easy to prove that the security holds under the cases that the user colludes with TPA to circumvent the cloud server, and the user colludes with the server to circumvent TPA. Here we would not elaborate on it in details.

SECTION 6Performance Evaluation
We evaluate the performance of the proposed scheme in terms of communication overhead and computation overhead. All experiments are conducted on a computer with the Window 10 system, an Intel Core 2 i5 CPU, and 8 GB DDR 3 of RAM. The code is implemented by utilizing C language and MIRACL Library. The security level is chosen to be 80 bits for the evaluation, which means that the pairing is based on the MNT curve,6 its base field size is 159 bits and its embedding degree is 6.

In [14], there is a discussion about the difference on the sector number. For the sake of brevity, we only provide the atomic operation analysis for the case that the sector number is 1 in the following. Furthermore, we assume that the total number of data blocks is less than 10,000.

6.1 Communication Overhead
We first show the communication costs between TPA and the cloud server in Fig. 6, and also give a comparison with SWP [14]. In CPVPA, the communication costs between TPA and the cloud server are constant, while those in SWP is proportional to the number of challenged data blocks.


Fig. 6.
The communication overhead.

Show All

6.2 Computation Overhead
We specify the computational costs with respect to cryptographic operations in Table 2.

TABLE 2 Notation of Operations

We show the computation costs on the server side of CPVPA, SWP [14], SCLPV [18], and CLPA [24] in Table 3, where c denotes the total number of challenged data blocks. Since the challenging messages in CPVPA are computed on the hash value of the Ethereum blockchain, this requires additional computation costs. However, these additional costs ensure the (low) constant communication costs between the server and TPA, and also protects CPVPA from malicious or/and procrastinating auditors.

TABLE 3 Computation Costs on the Server Side
Table 3- 
Computation Costs on the Server Side
We show a comparison of computation costs on the auditor side in Table 4, and show the computation delay on the TPA of CPVPA in Fig. 7.

Fig. 7. - 
The verification delay on the TPA side.
Fig. 7.
The verification delay on the TPA side.

Show All

TABLE 4 Computation Costs on the TPA Side
Table 4- 
Computation Costs on the TPA Side
Compared with existing schemes, CPVPA requires the user to audit the TPA's behavior at the end of each epoch. The costs of user's auditing are the same as the TPA's verification costs, when the user checks a single entry. However, when the user checks multiple entries simultaneously, the auditing costs can be amortized over these entries and reduced significantly. We show the user's auditing delay in Fig. 8.

Fig. 8. - 
The auditing delay on the user side.
Fig. 8.
The auditing delay on the user side.

Show All

According to the analysis, we can see that the user is able to audit the TPA's behavior within 1 minute in the case of 50 entries. Furthermore, as discussed before, the period that the user audits the TPA's behavior is much longer than the one that TPA verifies the data integrity, and these additional costs ensure that CPVPA can resist procrastinating auditors. Therefore, these computational costs on the user can be accepted in practice.

From the system perspective, CPVPA does not require the user, the auditor, and the cloud server to be a full node of Ethereum network, since there is a light client protocol of Ethereum.7 It allows a user to conduct Ethereum transactions without maintaining the Ethereum blockchain. The block information of the Ethereum blockchain is released by multiple sites and systems in real time, such as Etherscan8 and Etherchain.9 This allows the user, the auditor, and the cloud server to securely extract the block information from the Ethereum blockchain. Therefore, the user, the auditor, and the cloud server in CPVPA would not incur a heavy burden in terms of communication and computation costs.

SECTION 7Related Work
To ensure the integrity of data stored on a remote and untrusted server, Juels et al. [30] presented the “proofs of retrievability” (POR) technique. However, in [30], public verification is not considered, and hence the data owner needs to verify the data integrity periodically. This requires the data owner to keep online for verification. As such, the data owner has to bear heavy communication and verification burden to retrieve and use the data. In the mean time, Ateniese et al. [16] presented the “provable data possession” (PDP) technique, where the public verification was first considered: the data owner is able to employ a third-party auditor to check the data integrity on behalf of her/him. Subsequently, Shacham et al. [14] presented the first compact POR scheme with full proofs of security against arbitrary adversaries. Inspired by the Shacham et al.'s work, researchers have presented several public verification schemes with different features [9], [13], [15], [32], [46]. These schemes are constructed on the homomorphic signature technique [29].

Privacy preserving public verification has also attracted attentions in the recent literature. A privacy-preserving public verification scheme enables the auditor to verify the integrity of oursourced data without learning the content of the data. Most of existing privacy-preserving schemes, such as [9], [15], [31], [32], require the cloud server to utilize a random mask to blind the proof information such that the auditor can check the validity of the proof information without extracting the data content. For our scheme, to protect users’ data against the auditor, we encrypt the data before generating the tags. Since in CPVPA, we consider that the auditor may collude with the cloud server, the cloud server would straightforward send the data to the auditor to violate the data privacy of users.

The above schemes are built on certificate-based cryptography and thereby are confronted with the certificate management problem. To avoid managing certificates in a public verification scheme, some schemes [10], [47] constructed on the identity-based signature schemes were proposed. However, these schemes are subject to an inherent drawback: the key escrow problem [28]. Wang et al. [23] proposed the first certificateless public verification scheme. Then some certificateless public verification schemes with enhanced security were proposed [18], [24]. These schemes are constructed on the homomorphic certificateless signature schemes. Therefore, the auditor in these schemes does not need to manage the users’ certificates without confronting with the key escrow problem.

Furthermore, in the existing schemes, the auditor is assumed to be honest and reliable. However, this is a very strong assumption, due to the fact that compromising auditors could be feasible in reality. Recently, Armknecht et al. [17] proposed the first PoR scheme that thwarts malicious auditors, and Zhang et al. [18] proposed the first public verification scheme with resistance against malicious auditors. These schemes cannot resist procrastinating auditors who may not perform the data integrity verification on schedule. A procrastinating auditor can deviate from the primary objective of public verification that detect the data corruption as soon as possible. It is worth clarifying that resistance against procrastinating auditors is vitally important for public verification schemes in practice. More detailed survey on public verification of data integrity can be found in [48].

SECTION 8Conclusion and Future Work
In this paper, we have proposed a certificateless public verification scheme against the procrastinating auditor, namely CPVPA. CPVPA utilizes on-chain currencies, where each verification performed by the auditor is integrated into a transaction on the blockchain of on-chain currencies. Furthermore, CPVPA is free from the certificate management problem. The security analysis demonstrates that CPVPA provides the strongest security guarantee compared with existing schemes. We have also provided a comprehensive performance evaluation, which demonstrates that CPVPA has a constant communication overhead and is efficient in terms of computation costs.

For the future work, we will investigate how to construct CPVPA on other blockchain systems. Since the main drawback of proofs of work is the energy consumption, constructing CPVPA on other blockchain systems (e.g., proofs-of-stake-based blockchain systems) can save energy. However, it requires an elaborated design to achieve the same security guarantee while ensuring the high efficiency. This remains an open research issue that should be further explored. We will also investigate how to use blockchains to improve cloud storage services in terms of security, performance, and functionality. As the outsourced data processing (e.g., outsourced computation and searching over encrypted data) has also played an important role in current information age, we will explore the integration of blockchain into existing schemes, which should have a deep impact on outsourced data processing.